head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.2
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.03.01.08.04;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	GzHqjSTnBjdF7Wcw;

1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
#
# This is a home for regular expression tests that do not fit into
# the format supported by re/regexp.t.  If you want to add a test
# that does fit that format, add it to re/re_tests, not here.

BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(../lib .);
    require './test.pl';
    require './charset_tools.pl';
    skip_all_if_miniperl("miniperl can't load Tie::Hash::NamedCapture, need for %+ and %-");
}

use strict;
use warnings;
use 5.010;
our ($REGMARK, $REGERROR);

sub run_tests;

$| = 1;

run_tests() unless caller;

#
# Tests start here.
#
sub run_tests {

    {
        # Japhy -- added 03/03/2001
        () = (my $str = "abc") =~ /(...)/;
        $str = "def";
        is($1, "abc", 'Changing subject does not modify $1');
    }

  SKIP:
    {
        # The trick is that in EBCDIC the explicit numeric range should
        # match (as also in non-EBCDIC) but the explicit alphabetic range
        # should not match.
        ok "\x8e" =~ /[\x89-\x91]/, '"\x8e" =~ /[\x89-\x91]/';
        ok "\xce" =~ /[\xc9-\xd1]/, '"\xce" =~ /[\xc9-\xd1]/';
        ok "\xd0" =~ /[\xc9-\xd1]/, '"\xd0" =~ /[\xc9-\xd1]/';

        skip "Not an EBCDIC platform", 2 unless ord ('i') == 0x89 &&
                                                ord ('J') == 0xd1;

        # In most places these tests would succeed since \x8e does not
        # in most character sets match 'i' or 'j' nor would \xce match
        # 'I' or 'J', but strictly speaking these tests are here for
        # the good of EBCDIC, so let's test these only there.
        unlike("\x8e", qr/[i-j]/, '"\x8e" !~ /[i-j]/');
        unlike("\xce", qr/[I-J]/, '"\xce" !~ /[I-J]/');
        unlike("\xd0", qr/[I-J]/, '"\xd0" !~ /[I-J]/');
    }

    {
        ok "\x{ab}"   =~ /\x{ab}/,   '"\x{ab}"   =~ /\x{ab}/  ';
        ok "\x{abcd}" =~ /\x{abcd}/, '"\x{abcd}" =~ /\x{abcd}/';
    }

    {
        my $message = 'bug id 20001008.001';

        my $strasse = "stra" . uni_to_native("\337") . "e";
        my @@x = ("$strasse 138", "$strasse 138");
        for (@@x) {
            ok(s/(\d+)\s*([\w\-]+)/$1 . uc $2/e, $message);
            ok(my ($latin) = /^(.+)(?:\s+\d)/, $message);
            is($latin, $strasse, $message);
	    ok($latin =~ s/$strasse/straße/, $message);
            #
            # Previous code follows, but outcommented - there were no tests.
            #
            # $latin =~ s/stra\337e/straße/; # \303\237 after the 2nd a
            # use utf8; # needed for the raw UTF-8
            # $latin =~ s!(s)tr(?:aß|s+e)!$1tr.!; # \303\237 after the a
        }
    }

    {
        my $message = 'Test \x escapes';
        ok("ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\xd4", $message);
        ok("ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}", $message);
        ok("ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}", $message);
        ok("ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\xd4", $message);
        ok("ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4", $message);
        ok("ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}", $message);
        ok("ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}", $message);
        ok("ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4", $message);
    }

    {
        my $message = 'Match code points > 255';
        $_ = "abc\x{100}\x{200}\x{300}\x{380}\x{400}defg";
        ok(/(.\x{300})./, $message);
        ok($` eq "abc\x{100}"            && length ($`) == 4, $message);
        ok($& eq "\x{200}\x{300}\x{380}" && length ($&) == 3, $message);
        ok($' eq "\x{400}defg"           && length ($') == 5, $message);
        ok($1 eq "\x{200}\x{300}"        && length ($1) == 2, $message);
    }

    {
        my $x = "\x{10FFFD}";
        $x =~ s/(.)/$1/g;
        ok ord($x) == 0x10FFFD && length($x) == 1, "From Robin Houston";
    }

    {
        my %d = (
            "7f" => [0, 0, 0],
            "80" => [1, 1, 0],
            "ff" => [1, 1, 0],
           "100" => [0, 1, 1],
        );

        while (my ($code, $match) = each %d) {
            my $message = "Properties of \\x$code";
            my $char = eval qq ["\\x{$code}"];

            is(0 + ($char =~ /[\x80-\xff]/),    $$match[0], $message);
            is(0 + ($char =~ /[\x80-\x{100}]/), $$match[1], $message);
            is(0 + ($char =~ /[\x{100}]/),      $$match[2], $message);
        }
    }

    {
        # From Japhy
	foreach (qw(c g o)) {
	    warning_like(sub {'' =~ "(?$_)"},    qr/^Useless \(\?$_\)/);
	    warning_like(sub {'' =~ "(?-$_)"},   qr/^Useless \(\?-$_\)/);
	}

        # Now test multi-error regexes
	foreach (['(?g-o)', qr/^Useless \(\?g\)/, qr/^Useless \(\?-o\)/],
		 ['(?g-c)', qr/^Useless \(\?g\)/, qr/^Useless \(\?-c\)/],
		 # (?c) means (?g) error won't be thrown
		 ['(?o-cg)', qr/^Useless \(\?o\)/, qr/^Useless \(\?-c\)/],
		 ['(?ogc)', qr/^Useless \(\?o\)/, qr/^Useless \(\?g\)/,
		  qr/^Useless \(\?c\)/],
		) {
	    my ($re, @@warnings) = @@$_;
	    warnings_like(sub {eval "qr/$re/"}, \@@warnings, "qr/$re/ warns");
	}
    }

    {
        my $message = "/x tests";
        $_ = "foo";
        foreach my $pat (<<"        --", <<"        --") {
          /f
           o\r
           o
           \$
          /x
        --
          /f
           o
           o
           \$\r
          /x
        --
	    is(eval $pat, 1, $message);
	    is($@@, '', $message);
	}
    }

    {
        my $message = "/o feature";
        sub test_o {$_ [0] =~ /$_[1]/o; return $1}
        is(test_o ('abc', '(.)..'), 'a', $message);
        is(test_o ('abc', '..(.)'), 'a', $message);
    }

    {
        # Test basic $^N usage outside of a regex
        my $message = '$^N usage outside of a regex';
        my $x = "abcdef";
        ok(($x =~ /cde/                  and !defined $^N), $message);
        ok(($x =~ /(cde)/                and $^N eq "cde"), $message);
        ok(($x =~ /(c)(d)(e)/            and $^N eq   "e"), $message);
        ok(($x =~ /(c(d)e)/              and $^N eq "cde"), $message);
        ok(($x =~ /(foo)|(c(d)e)/        and $^N eq "cde"), $message);
        ok(($x =~ /(c(d)e)|(foo)/        and $^N eq "cde"), $message);
        ok(($x =~ /(c(d)e)|(abc)/        and $^N eq "abc"), $message);
        ok(($x =~ /(c(d)e)|(abc)x/       and $^N eq "cde"), $message);
        ok(($x =~ /(c(d)e)(abc)?/        and $^N eq "cde"), $message);
        ok(($x =~ /(?:c(d)e)/            and $^N eq   "d"), $message);
        ok(($x =~ /(?:c(d)e)(?:f)/       and $^N eq   "d"), $message);
        ok(($x =~ /(?:([abc])|([def]))*/ and $^N eq   "f"), $message);
        ok(($x =~ /(?:([ace])|([bdf]))*/ and $^N eq   "f"), $message);
        ok(($x =~ /(([ace])|([bd]))*/    and $^N eq   "e"), $message);
       {ok(($x =~ /(([ace])|([bdf]))*/   and $^N eq   "f"), $message);}
        ## Test to see if $^N is automatically localized -- it should now
        ## have the value set in the previous test.
        is($^N, "e", '$^N is automatically localized');

        # Now test inside (?{ ... })
        $message = '$^N usage inside (?{ ... })';
        our ($y, $z);
        ok(($x =~ /a([abc])(?{$y=$^N})c/                    and $y eq  "b"), $message);
        ok(($x =~ /a([abc]+)(?{$y=$^N})d/                   and $y eq  "bc"), $message);
        ok(($x =~ /a([abcdefg]+)(?{$y=$^N})d/               and $y eq  "bc"), $message);
        ok(($x =~ /(a([abcdefg]+)(?{$y=$^N})d)(?{$z=$^N})e/ and $y eq  "bc"
                                                            and $z eq "abcd"), $message);
        ok(($x =~ /(a([abcdefg]+)(?{$y=$^N})de)(?{$z=$^N})/ and $y eq  "bc"
                                                            and $z eq "abcde"), $message);

    }

  SKIP:
    {
        ## Should probably put in tests for all the POSIX stuff,
        ## but not sure how to guarantee a specific locale......

        my $message = 'Test [[:cntrl:]]';
        my $AllBytes = join "" => map {chr} 0 .. 255;
        (my $x = $AllBytes) =~ s/[[:cntrl:]]//g;
        $x = join "", sort { $a cmp $b }
                      map { chr utf8::native_to_unicode(ord $_) } split "", $x;
        is($x, join("", map {chr} 0x20 .. 0x7E, 0x80 .. 0xFF), $message);

        ($x = $AllBytes) =~ s/[^[:cntrl:]]//g;
        $x = join "", sort { $a cmp $b }
                       map { chr utf8::native_to_unicode(ord $_) } split "", $x;
        is($x, (join "", map {chr} 0x00 .. 0x1F, 0x7F), $message);
    }

    {
        # With /s modifier UTF8 chars were interpreted as bytes
        my $message = "UTF-8 chars aren't bytes";
        my $a = "Hello \x{263A} World";
        my @@a = ($a =~ /./gs);
        is($#a, 12, $message);
    }

    {
        no warnings 'digit';
        # Check that \x## works. 5.6.1 and 5.005_03 fail some of these.
        my $x;
        $x = "\x4e" . "E";
        ok ($x =~ /^\x4EE$/, "Check only 2 bytes of hex are matched.");

        $x = "\x4e" . "i";
        ok ($x =~ /^\x4Ei$/, "Check that invalid hex digit stops it (2)");

        $x = "\x4" . "j";
        ok ($x =~ /^\x4j$/,  "Check that invalid hex digit stops it (1)");

        $x = "\x0" . "k";
        ok ($x =~ /^\xk$/,   "Check that invalid hex digit stops it (0)");

        $x = "\x0" . "x";
        ok ($x =~ /^\xx$/, "\\xx isn't to be treated as \\0");

        $x = "\x0" . "xa";
        ok ($x =~ /^\xxa$/, "\\xxa isn't to be treated as \\xa");

        $x = "\x9" . "_b";
        ok ($x =~ /^\x9_b$/, "\\x9_b isn't to be treated as \\x9b");

        # and now again in [] ranges

        $x = "\x4e" . "E";
        ok ($x =~ /^[\x4EE]{2}$/, "Check only 2 bytes of hex are matched.");

        $x = "\x4e" . "i";
        ok ($x =~ /^[\x4Ei]{2}$/, "Check that invalid hex digit stops it (2)");

        $x = "\x4" . "j";
        ok ($x =~ /^[\x4j]{2}$/,  "Check that invalid hex digit stops it (1)");

        $x = "\x0" . "k";
        ok ($x =~ /^[\xk]{2}$/,   "Check that invalid hex digit stops it (0)");

        $x = "\x0" . "x";
        ok ($x =~ /^[\xx]{2}$/, "\\xx isn't to be treated as \\0");

        $x = "\x0" . "xa";
        ok ($x =~ /^[\xxa]{3}$/, "\\xxa isn't to be treated as \\xa");

        $x = "\x9" . "_b";
        ok ($x =~ /^[\x9_b]{3}$/, "\\x9_b isn't to be treated as \\x9b");

        # Check that \x{##} works. 5.6.1 fails quite a few of these.

        $x = "\x9b";
        ok ($x =~ /^\x{9_b}$/, "\\x{9_b} is to be treated as \\x9b");

        $x = "\x9b" . "y";
        ok ($x =~ /^\x{9_b}y$/, "\\x{9_b} is to be treated as \\x9b (again)");

        $x = "\x9b" . "y";
        ok ($x =~ /^\x{9b_}y$/, "\\x{9b_} is to be treated as \\x9b");

        $x = "\x9b" . "y";
        ok ($x =~ /^\x{9_bq}y$/, "\\x{9_bc} is to be treated as \\x9b");

        $x = "\x0" . "y";
        ok ($x =~ /^\x{x9b}y$/, "\\x{x9b} is to be treated as \\x0");

        $x = "\x0" . "y";
        ok ($x =~ /^\x{0x9b}y$/, "\\x{0x9b} is to be treated as \\x0");

        $x = "\x9b" . "y";
        ok ($x =~ /^\x{09b}y$/, "\\x{09b} is to be treated as \\x9b");

        $x = "\x9b";
        ok ($x =~ /^[\x{9_b}]$/, "\\x{9_b} is to be treated as \\x9b");

        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{9_b}y]{2}$/,
                                 "\\x{9_b} is to be treated as \\x9b (again)");

        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{9b_}y]{2}$/, "\\x{9b_} is to be treated as \\x9b");

        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{9_bq}y]{2}$/, "\\x{9_bc} is to be treated as \\x9b");

        $x = "\x0" . "y";
        ok ($x =~ /^[\x{x9b}y]{2}$/, "\\x{x9b} is to be treated as \\x0");

        $x = "\x0" . "y";
        ok ($x =~ /^[\x{0x9b}y]{2}$/, "\\x{0x9b} is to be treated as \\x0");

        $x = "\x9b" . "y";
        ok ($x =~ /^[\x{09b}y]{2}$/, "\\x{09b} is to be treated as \\x9b");

    }

    {
        # High bit bug -- japhy
        my $x = "ab\200d";
        ok $x =~ /.*?\200/, "High bit fine";
    }

    {
        # The basic character classes and Unicode
        ok "\x{0100}" =~ /\w/, 'LATIN CAPITAL LETTER A WITH MACRON in /\w/';
        ok "\x{0660}" =~ /\d/, 'ARABIC-INDIC DIGIT ZERO in /\d/';
        ok "\x{1680}" =~ /\s/, 'OGHAM SPACE MARK in /\s/';
    }

    {
        my $message = "Folding matches and Unicode";
        like("a\x{100}", qr/A/i, $message);
        like("A\x{100}", qr/a/i, $message);
        like("a\x{100}", qr/a/i, $message);
        like("A\x{100}", qr/A/i, $message);
        like("\x{101}a", qr/\x{100}/i, $message);
        like("\x{100}a", qr/\x{100}/i, $message);
        like("\x{101}a", qr/\x{101}/i, $message);
        like("\x{100}a", qr/\x{101}/i, $message);
        like("a\x{100}", qr/A\x{100}/i, $message);
        like("A\x{100}", qr/a\x{100}/i, $message);
        like("a\x{100}", qr/a\x{100}/i, $message);
        like("A\x{100}", qr/A\x{100}/i, $message);
        like("a\x{100}", qr/[A]/i, $message);
        like("A\x{100}", qr/[a]/i, $message);
        like("a\x{100}", qr/[a]/i, $message);
        like("A\x{100}", qr/[A]/i, $message);
        like("\x{101}a", qr/[\x{100}]/i, $message);
        like("\x{100}a", qr/[\x{100}]/i, $message);
        like("\x{101}a", qr/[\x{101}]/i, $message);
        like("\x{100}a", qr/[\x{101}]/i, $message);
    }

    {
        use charnames ':full';
        my $message = "Folding 'LATIN LETTER A WITH GRAVE'";

        my $lower = "\N{LATIN SMALL LETTER A WITH GRAVE}";
        my $UPPER = "\N{LATIN CAPITAL LETTER A WITH GRAVE}";

        like($lower, qr/$UPPER/i, $message);
        like($UPPER, qr/$lower/i, $message);
        like($lower, qr/[$UPPER]/i, $message);
        like($UPPER, qr/[$lower]/i, $message);

        $message = "Folding 'GREEK LETTER ALPHA WITH VRACHY'";

        $lower = "\N{GREEK CAPITAL LETTER ALPHA WITH VRACHY}";
        $UPPER = "\N{GREEK SMALL LETTER ALPHA WITH VRACHY}";

        like($lower, qr/$UPPER/i, $message);
        like($UPPER, qr/$lower/i, $message);
        like($lower, qr/[$UPPER]/i, $message);
        like($UPPER, qr/[$lower]/i, $message);

        $message = "Folding 'LATIN LETTER Y WITH DIAERESIS'";

        $lower = "\N{LATIN SMALL LETTER Y WITH DIAERESIS}";
        $UPPER = "\N{LATIN CAPITAL LETTER Y WITH DIAERESIS}";

        like($lower, qr/$UPPER/i, $message);
        like($UPPER, qr/$lower/i, $message);
        like($lower, qr/[$UPPER]/i, $message);
        like($UPPER, qr/[$lower]/i, $message);
    }

    {
        use charnames ':full';
        my $message = "GREEK CAPITAL LETTER SIGMA vs " .
                         "COMBINING GREEK PERISPOMENI";

        my $SIGMA = "\N{GREEK CAPITAL LETTER SIGMA}";
        my $char  = "\N{COMBINING GREEK PERISPOMENI}";

        warning_is(sub {unlike("_:$char:_", qr/_:$SIGMA:_/i, $message)}, undef,
		   'Did not warn [change a5961de5f4215b5c]');
    }

    {
        my $message = '\X';
        use charnames ':full';

        ok("a!"                          =~ /^(\X)!/ && $1 eq "a", $message);
        ok("\xDF!"                       =~ /^(\X)!/ && $1 eq "\xDF", $message);
        ok("\x{100}!"                    =~ /^(\X)!/ && $1 eq "\x{100}", $message);
        ok("\x{100}\x{300}!"             =~ /^(\X)!/ && $1 eq "\x{100}\x{300}", $message);
        ok("\N{LATIN CAPITAL LETTER E}!" =~ /^(\X)!/ &&
               $1 eq "\N{LATIN CAPITAL LETTER E}", $message);
        ok("\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}!"
                                         =~ /^(\X)!/ &&
               $1 eq "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}", $message);

    }

    {
        my $message = "Final Sigma";

        my $SIGMA = "\x{03A3}"; # CAPITAL
        my $Sigma = "\x{03C2}"; # SMALL FINAL
        my $sigma = "\x{03C3}"; # SMALL

        like($SIGMA, qr/$SIGMA/i, $message);
        like($SIGMA, qr/$Sigma/i, $message);
        like($SIGMA, qr/$sigma/i, $message);

        like($Sigma, qr/$SIGMA/i, $message);
        like($Sigma, qr/$Sigma/i, $message);
        like($Sigma, qr/$sigma/i, $message);

        like($sigma, qr/$SIGMA/i, $message);
        like($sigma, qr/$Sigma/i, $message);
        like($sigma, qr/$sigma/i, $message);

        like($SIGMA, qr/[$SIGMA]/i, $message);
        like($SIGMA, qr/[$Sigma]/i, $message);
        like($SIGMA, qr/[$sigma]/i, $message);

        like($Sigma, qr/[$SIGMA]/i, $message);
        like($Sigma, qr/[$Sigma]/i, $message);
        like($Sigma, qr/[$sigma]/i, $message);

        like($sigma, qr/[$SIGMA]/i, $message);
        like($sigma, qr/[$Sigma]/i, $message);
        like($sigma, qr/[$sigma]/i, $message);

        $message = "More final Sigma";

        my $S3 = "$SIGMA$Sigma$sigma";

        ok(":$S3:" =~ /:(($SIGMA)+):/i   && $1 eq $S3 && $2 eq $sigma, $message);
        ok(":$S3:" =~ /:(($Sigma)+):/i   && $1 eq $S3 && $2 eq $sigma, $message);
        ok(":$S3:" =~ /:(($sigma)+):/i   && $1 eq $S3 && $2 eq $sigma, $message);

        ok(":$S3:" =~ /:(([$SIGMA])+):/i && $1 eq $S3 && $2 eq $sigma, $message);
        ok(":$S3:" =~ /:(([$Sigma])+):/i && $1 eq $S3 && $2 eq $sigma, $message);
        ok(":$S3:" =~ /:(([$sigma])+):/i && $1 eq $S3 && $2 eq $sigma, $message);
    }

    {
        use charnames ':full';
        my $message = "Parlez-Vous " .
                         "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais?";

        ok("Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran.ais/ &&
            $& eq "Francais", $message);
        ok("Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran.ais/ &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais", $message);
        ok("Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Xais/ &&
            $& eq "Francais", $message);
        ok("Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran\Xais/  &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais", $message);
        ok("Franc\N{COMBINING CEDILLA}ais" =~ /Fran\Xais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais", $message);
        ok("Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
           /Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais/  &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais", $message);
        ok("Franc\N{COMBINING CEDILLA}ais" =~ /Franc\N{COMBINING CEDILLA}ais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais", $message);

        my @@f = (
            ["Fran\N{LATIN SMALL LETTER C}ais",                    "Francais"],
            ["Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais",
                               "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais"],
            ["Franc\N{COMBINING CEDILLA}ais", "Franc\N{COMBINING CEDILLA}ais"],
        );
        foreach my $entry (@@f) {
            my ($subject, $match) = @@$entry;
            ok($subject =~ /Fran(?:c\N{COMBINING CEDILLA}?|
                    \N{LATIN SMALL LETTER C WITH CEDILLA})ais/x &&
               $& eq $match, $message);
        }
    }

    {
        my $message = "Lingering (and useless) UTF8 flag doesn't mess up /i";
        my $pat = "ABcde";
        my $str = "abcDE\x{100}";
        chop $str;
        like($str, qr/$pat/i, $message);

        $pat = "ABcde\x{100}";
        $str = "abcDE";
        chop $pat;
        like($str, qr/$pat/i, $message);

        $pat = "ABcde\x{100}";
        $str = "abcDE\x{100}";
        chop $pat;
        chop $str;
        like($str, qr/$pat/i, $message);
    }

    {
        use charnames ':full';
        my $message = "LATIN SMALL LETTER SHARP S " .
                         "(\N{LATIN SMALL LETTER SHARP S})";

        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/\N{LATIN SMALL LETTER SHARP S}/, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/\N{LATIN SMALL LETTER SHARP S}/i, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/[\N{LATIN SMALL LETTER SHARP S}]/, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/[\N{LATIN SMALL LETTER SHARP S}]/i, $message);

        like("ss", qr /\N{LATIN SMALL LETTER SHARP S}/i, $message);
        like("SS", qr /\N{LATIN SMALL LETTER SHARP S}/i, $message);
        like("ss", qr/[\N{LATIN SMALL LETTER SHARP S}]/i, $message);
        like("SS", qr/[\N{LATIN SMALL LETTER SHARP S}]/i, $message);

        like("\N{LATIN SMALL LETTER SHARP S}", qr/ss/i, $message);
        like("\N{LATIN SMALL LETTER SHARP S}", qr/SS/i, $message);

         $message = "Unoptimized named sequence in class";
        like("ss", qr/[\N{LATIN SMALL LETTER SHARP S}x]/i, $message);
        like("SS", qr/[\N{LATIN SMALL LETTER SHARP S}x]/i, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/[\N{LATIN SMALL LETTER SHARP S}x]/, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/[\N{LATIN SMALL LETTER SHARP S}x]/i, $message);
    }

    {
        # More whitespace: U+0085, U+2028, U+2029\n";

        # U+0085, U+00A0 need to be forced to be Unicode, the \x{100} does that.
        ok "<\x{100}" . uni_to_native("\x{0085}") . ">" =~ /<\x{100}\s>/, '\x{0085} in \s';
        ok        "<" . uni_to_native("\x{0085}") . ">" =~        /<\v>/, '\x{0085} in \v';
        ok "<\x{100}" . uni_to_native("\x{00A0}") . ">" =~ /<\x{100}\s>/, '\x{00A0} in \s';
        ok        "<" . uni_to_native("\x{00A0}") . ">" =~        /<\h>/, '\x{00A0} in \h';
        my @@h = map {sprintf "%05x" => $_} 0x01680, 0x02000 .. 0x0200A,
                                           0x0202F, 0x0205F, 0x03000;
        my @@v = map {sprintf "%05x" => $_} 0x02028, 0x02029;

        my @@H = map {sprintf "%05x" => $_} 0x01361,   0x0200B, 0x02408, 0x02420,
                                           0x0303F,   0xE0020, 0x180E;
        my @@V = map {sprintf "%05x" => $_} 0x0008A .. 0x0008D, 0x00348, 0x10100,
                                           0xE005F,   0xE007C, 0x180E;

        for my $hex (@@h) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\s>/, "\\x{$hex} in \\s";
            ok $str =~ /<\h>/, "\\x{$hex} in \\h";
            ok $str !~ /<\v>/, "\\x{$hex} not in \\v";
        }

        for my $hex (@@v) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\s>/, "\\x{$hex} in \\s";
            ok $str =~ /<\v>/, "\\x{$hex} in \\v";
            ok $str !~ /<\h>/, "\\x{$hex} not in \\h";
        }

        for my $hex (@@H) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\S>/, "\\x{$hex} in \\S";
            ok $str =~ /<\H>/, "\\x{$hex} in \\H";
        }

        for my $hex (@@V) {
            my $str = eval qq ["<\\x{$hex}>"];
            ok $str =~ /<\S>/, "\\x{$hex} in \\S";
            ok $str =~ /<\V>/, "\\x{$hex} in \\V";
        }
    }

    {
        # . with /s should work on characters, as opposed to bytes
        my $message = ". with /s works on characters, not bytes";

        my $s = "\x{e4}\x{100}";
        # This is not expected to match: the point is that
        # neither should we get "Malformed UTF-8" warnings.
        warning_is(sub {$s =~ /\G(.+?)\n/gcs}, undef,
		   "No 'Malformed UTF-8' warning");

        my @@c;
        push @@c => $1 while $s =~ /\G(.)/gs;

        local $" = "";
        is("@@c", $s, $message);

        # Test only chars < 256
        my $t1 = "Q003\n\n\x{e4}\x{f6}\n\nQ004\n\n\x{e7}";
        my $r1 = "";
        while ($t1 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
        $r1 .= $1 . $2;
        }

        my $t2 = $t1 . "\x{100}"; # Repeat with a larger char
        my $r2 = "";
        while ($t2 =~ / \G ( .+? ) \n\s+ ( .+? ) ( $ | \n\s+ ) /xgcs) {
        $r2 .= $1 . $2;
        }
        $r2 =~ s/\x{100}//;

        is($r1, $r2, $message);
    }

    {
        my $message = "Unicode lookbehind";
        like("A\x{100}B"       , qr/(?<=A.)B/, $message);
        like("A\x{200}\x{300}B", qr/(?<=A..)B/, $message);
        like("\x{400}AB"       , qr/(?<=\x{400}.)B/, $message);
        like("\x{500}\x{600}B" , qr/(?<=\x{500}.)B/, $message);

        # Original code also contained:
        # ok "\x{500\x{600}}B"  =~ /(?<=\x{500}.)B/;
        # but that looks like a typo.
    }

    {
        my $message = 'UTF-8 hash keys and /$/';
        # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters
        #                                         /2002-01/msg01327.html

        my $u = "a\x{100}";
        my $v = substr ($u, 0, 1);
        my $w = substr ($u, 1, 1);
        my %u = ($u => $u, $v => $v, $w => $w);
        for (keys %u) {
            my $m1 =            /^\w*$/ ? 1 : 0;
            my $m2 = $u {$_} =~ /^\w*$/ ? 1 : 0;
            is($m1, $m2, $message);
        }
    }

    {
        my $message = "No SEGV in s/// and UTF-8";
        my $s = "s#\x{100}" x 4;
        ok($s =~ s/[^\w]/ /g, $message);
        if ( 1 or $ENV{PERL_TEST_LEGACY_POSIX_CC} ) {
            is($s, "s \x{100}" x 4, $message);
        }
        else {
            is($s, "s  " x 4, $message);
        }
    }

    {
        my $message = "UTF-8 bug (maybe already known?)";
        my $u = "foo";
        $u =~ s/./\x{100}/g;
        is($u, "\x{100}\x{100}\x{100}", $message);

        $u = "foobar";
        $u =~ s/[ao]/\x{100}/g;
        is($u, "f\x{100}\x{100}b\x{100}r", $message);

        $u =~ s/\x{100}/e/g;
        is($u, "feeber", $message);
    }

    {
        my $message = "UTF-8 bug with s///";
        # check utf8/non-utf8 mixtures
        # try to force all float/anchored check combinations

        my $c = "\x{100}";
        my $subst;
        for my $re ("xx.*$c", "x.*$c$c", "$c.*xx", "$c$c.*x",
                    "xx.*(?=$c)", "(?=$c).*xx",) {
            unlike("xxx", qr/$re/, $message);
            ok(+($subst = "xxx") !~ s/$re//, $message);
        }
        for my $re ("xx.*$c*", "$c*.*xx") {
            like("xxx", qr/$re/, $message);
            ok(+($subst = "xxx") =~ s/$re//, $message);
            is($subst, "", $message);
        }
        for my $re ("xxy*", "y*xx") {
            like("xx$c", qr/$re/, $message);
            ok(+($subst = "xx$c") =~ s/$re//, $message);
            is($subst, $c, $message);
            unlike("xy$c", qr/$re/, $message);
            ok(+($subst = "xy$c") !~ s/$re//, $message);
        }
        for my $re ("xy$c*z", "x$c*yz") {
            like("xyz", qr/$re/, $message);
            ok(+($subst = "xyz") =~ s/$re//, $message);
            is($subst, "", $message);
        }
    }

    {
        # The second half of RT #114808
        warning_is(sub {'aa' =~ /.+\x{100}/}, undef,
                   'utf8-only floating substr, non-utf8 target, no warning');
    }

    {
        my $message = "qr /.../x";
        my $R = qr / A B C # D E/x;
        ok("ABCDE" =~    $R   && $& eq "ABC", $message);
        ok("ABCDE" =~   /$R/  && $& eq "ABC", $message);
        ok("ABCDE" =~  m/$R/  && $& eq "ABC", $message);
        ok("ABCDE" =~  /($R)/ && $1 eq "ABC", $message);
        ok("ABCDE" =~ m/($R)/ && $1 eq "ABC", $message);
    }

    {
        local $\;
        $_ = 'aaaaaaaaaa';
        utf8::upgrade($_); chop $_; $\="\n";
        ok /[^\s]+/, 'm/[^\s]/ utf8';
        ok /[^\d]+/, 'm/[^\d]/ utf8';
        ok +($a = $_, $_ =~ s/[^\s]+/./g), 's/[^\s]/ utf8';
        ok +($a = $_, $a =~ s/[^\d]+/./g), 's/[^\s]/ utf8';
    }

    {
        # Subject: Odd regexp behavior
        # From: Markus Kuhn <Markus.Kuhn@@cl.cam.ac.uk>
        # Date: Wed, 26 Feb 2003 16:53:12 +0000
        # Message-Id: <E18o4nw-0008Ly-00@@wisbech.cl.cam.ac.uk>
        # To: perl-unicode@@perl.org

        my $message = 'Markus Kuhn 2003-02-26';

        my $x = "\x{2019}\nk";
        ok($x =~ s/(\S)\n(\S)/$1 $2/sg, $message);
        is($x, "\x{2019} k", $message);

        $x = "b\nk";
        ok($x =~ s/(\S)\n(\S)/$1 $2/sg, $message);
        is($x, "b k", $message);

        like("\x{2019}", qr/\S/, $message);
    }

    {
        ok "\x{100}\n" =~ /\x{100}\n$/, "UTF-8 length cache and fbm_compile";
    }

    {
        package Str;
        use overload q /""/ => sub {${$_ [0]};};
        sub new {my ($c, $v) = @@_; bless \$v, $c;}

        package main;
        $_ = Str -> new ("a\x{100}/\x{100}b");
        ok join (":", /\b(.)\x{100}/g) eq "a:/", "re_intuit_start and PL_bostr";
    }

    {
        my $re = qq /^([^X]*)X/;
        utf8::upgrade ($re);
        ok "\x{100}X" =~ /$re/, "S_cl_and ANYOF_UNICODE & ANYOF_INVERTED";
        my $loc_re = qq /(?l:^([^X]*)X)/;
        utf8::upgrade ($loc_re);
        no warnings 'locale';
        ok "\x{100}X" =~ /$loc_re/, "locale, S_cl_and ANYOF_UNICODE & ANYOF_INVERTED";
    }

    {
        ok "123\x{100}" =~ /^.*1.*23\x{100}$/,
           'UTF-8 + multiple floating substr';
    }

    {
        my $message = '<20030808193656.5109.1@@llama.ni-s.u-net.com>';

        # LATIN SMALL/CAPITAL LETTER A WITH MACRON
        like("  \x{101}", qr/\x{100}/i, $message);

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
        like("  \x{1E01}", qr/\x{1E00}/i, $message);

        # DESERET SMALL/CAPITAL LETTER LONG I
        like("  \x{10428}", qr/\x{10400}/i, $message);

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
        like("  \x{1E01}x", qr/\x{1E00}X/i, $message);
    }

    {
        for (120 .. 130, 240 .. 260) {
            my $head = 'x' x $_;
            my $message = q [Don't misparse \x{...} in regexp ] .
                             q [near EXACT char count limit];
            for my $tail ('\x{0061}', '\x{1234}', '\x61') {
                eval qq{like("$head$tail", qr/$head$tail/, \$message)};
		is($@@, '', $message);
            }
            $message = q [Don't misparse \N{...} in regexp ] .
                             q [near EXACT char count limit];
            for my $tail ('\N{SNOWFLAKE}') {
                eval qq {use charnames ':full';
                         like("$head$tail", qr/$head$tail/, \$message)};
		is($@@, '', $message);
            }
        }
    }

    {   # TRIE related
        our @@got = ();
        "words" =~ /(word|word|word)(?{push @@got, $1})s$/;
        is(@@got, 1, "TRIE optimisation");

        @@got = ();
        "words" =~ /(word|word|word)(?{push @@got,$1})s$/i;
        is(@@got, 1,"TRIEF optimisation");

        my @@nums = map {int rand 1000} 1 .. 100;
        my $re = "(" . (join "|", @@nums) . ")";
        $re = qr/\b$re\b/;

        foreach (@@nums) {
            ok $_ =~ /$re/, "Trie nums";
        }

        $_ = join " ", @@nums;
        @@got = ();
        push @@got, $1 while /$re/g;

        my %count;
        $count {$_} ++ for @@got;
        my $ok = 1;
        for (@@nums) {
            $ok = 0 if --$count {$_} < 0;
        }
        ok $ok, "Trie min count matches";
    }

    {
        # TRIE related
        # LATIN SMALL/CAPITAL LETTER A WITH MACRON
        ok "foba  \x{101}foo" =~ qr/(foo|\x{100}foo|bar)/i &&
           $1 eq "\x{101}foo",
           "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH MACRON";

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW
        ok "foba  \x{1E01}foo" =~ qr/(foo|\x{1E00}foo|bar)/i &&
           $1 eq "\x{1E01}foo",
           "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW";

        # DESERET SMALL/CAPITAL LETTER LONG I
        ok "foba  \x{10428}foo" =~ qr/(foo|\x{10400}foo|bar)/i &&
           $1 eq "\x{10428}foo",
           "TRIEF + DESERET SMALL/CAPITAL LETTER LONG I";

        # LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'
        ok "foba  \x{1E01}xfoo" =~ qr/(foo|\x{1E00}Xfoo|bar)/i &&
           $1 eq "\x{1E01}xfoo",
           "TRIEF + LATIN SMALL/CAPITAL LETTER A WITH RING BELOW + 'X'";

        use charnames ':full';

        my $s = "\N{LATIN SMALL LETTER SHARP S}";
        ok "foba  ba$s" =~ qr/(foo|Ba$s|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";
        ok "foba  ba$s" =~ qr/(Ba$s|foo|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";
        ok "foba  ba$s" =~ qr/(foo|bar|Ba$s)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";

        ok "foba  ba$s" =~ qr/(foo|Bass|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ ss";

        ok "foba  ba$s" =~ qr/(foo|BaSS|bar)/i &&  $1 eq "ba$s",
           "TRIEF + LATIN SMALL LETTER SHARP S =~ SS";

        ok "foba  ba${s}pxySS$s$s" =~ qr/(b(?:a${s}t|a${s}f|a${s}p)[xy]+$s*)/i
            &&  $1 eq "ba${s}pxySS$s$s",
           "COMMON PREFIX TRIEF + LATIN SMALL LETTER SHARP S";
    }

    {
	BEGIN {
	    unshift @@INC, 'lib';
	}
        use Cname;

        ok 'fooB'  =~ /\N{foo}[\N{B}\N{b}]/, "Passthrough charname";
        my $name = "foo\xDF";
        my $result = eval "'A${name}B'  =~ /^A\\N{$name}B\$/";
        ok !$@@ && $result,  "Passthrough charname of non-ASCII, Latin1";
        #
        # Why doesn't must_warn work here?
        #
        my $w;
        local $SIG {__WARN__} = sub {$w .= "@@_"};
        $result = eval 'q(WARN) =~ /^[\N{WARN}]$/';
        ok !$@@ && $result && ! $w,  '\N{} returning multi-char works';

        undef $w;
        eval q [ok "\0" !~ /[\N{EMPTY-STR}XY]/,
                   "Zerolength charname in charclass doesn't match \\\\0"];
        ok $w && $w =~ /Ignoring zero length/,
                 'Ignoring zero length \N{} in character class warning';
        undef $w;
        eval q [ok 'xy' =~ /x[\N{EMPTY-STR} y]/x,
                    'Empty string charname in [] is ignored; finds a following character'];
        ok $w && $w =~ /Ignoring zero length/,
                 'Ignoring zero length \N{} in character class warning';
        undef $w;
        eval q [ok 'x ' =~ /x[\N{EMPTY-STR} y]/,
                    'Empty string charname in [] is ignored; finds a following blank under /x'];
        ok $w && $w =~ /Ignoring zero length/,
                 'Ignoring zero length \N{} in character class warning';

        ok 'AB'  =~ /(\N{EVIL})/ && $1 eq 'A', 'Charname caching $1';
        ok 'ABC' =~ /(\N{EVIL})/,              'Charname caching $1';
        ok 'xy'  =~ /x\N{EMPTY-STR}y/,
                    'Empty string charname produces NOTHING node';
        ok ''    =~ /\N{EMPTY-STR}/,
                    'Empty string charname produces NOTHING node';
        ok "\N{LONG-STR}" =~ /^\N{LONG-STR}$/, 'Verify that long string works';
        ok "\N{LONG-STR}" =~ /^\N{LONG-STR}$/i, 'Verify under folding that long string works';

        eval '/(?[[\N{EMPTY-STR}]])/';
        ok $@@ && $@@ =~ /Zero length \\N\{}/;

        undef $w;
        {
            () = eval q ["\N{TOO  MANY SPACES}"];
            like ($@@, qr/charnames alias definitions may not contain a sequence of multiple spaces/, "Multiple spaces in a row in a charnames alias is fatal");
            eval q [use utf8; () = "\N{TOO  MANY SPACES}"];
            like ($@@, qr/charnames alias definitions may not contain a sequence of multiple spaces/,  "... same under utf8");
        }

        undef $w;
        {
            () = eval q ["\N{TRAILING SPACE }"];
            like ($@@, qr/charnames alias definitions may not contain trailing white-space/, "Trailing white-space in a charnames alias is fatal");
            eval q [use utf8; () = "\N{TRAILING SPACE }"];
            like ($@@, qr/charnames alias definitions may not contain trailing white-space/, "... same under utf8");
        }

        undef $w;
        my $Cedilla_Latin1 = "GAR"
                           . uni_to_native("\xC7")
                           . "ON";
        my $Cedilla_utf8 = $Cedilla_Latin1;
        utf8::upgrade($Cedilla_utf8);
        eval qq[is("\\N{$Cedilla_Latin1}", "$Cedilla_Latin1", "A cedilla in character name works")];
        undef $w;
            {
            use feature 'unicode_eval';
            eval qq[use utf8; is("\\N{$Cedilla_utf8}", "$Cedilla_utf8", "... same under 'use utf8': they work")];
        }

        undef $w;
        my $NBSP_Latin1 = "NBSP"
                        . uni_to_native("\xA0")
                        . "SEPARATED"
                        . uni_to_native("\xA0")
                        . "SPACE";
        my $NBSP_utf8 = $NBSP_Latin1;
        utf8::upgrade($NBSP_utf8);
        eval qq[is("\\N{$NBSP_Latin1}", "$NBSP_Latin1", "An NBSP in character name works")];
        like ($w, qr/NO-BREAK SPACE in a charnames alias definition is deprecated/, "... but returns a deprecation warning");
        undef $w;
            {
            use feature 'unicode_eval';
            eval qq[use utf8; is("\\N{$NBSP_utf8}", "$NBSP_utf8", "Same under 'use utf8': they work")];
            like ($w, qr/NO-BREAK SPACE in a charnames alias definition is deprecated/, "... but return a deprecation warning");
        }
        {
            # disable lexical warnings
            BEGIN { ${^WARNING_BITS} = undef; $^W = 0 }
            undef $w;
            () = eval qq["\\N{$NBSP_Latin1}"];
            like ($w, qr/NO-BREAK SPACE in a charnames alias definition is deprecated/, "And returns a deprecation warning outside of lexical warnings");
            undef $w;
            use feature 'unicode_eval';
            eval qq[use utf8; () = "\\N{$NBSP_utf8}"];
            like ($w, qr/NO-BREAK SPACE in a charnames alias definition is deprecated/, "... same under utf8");
        }
        {
            no warnings 'deprecated';
            undef $w;
            eval qq["\\N{$NBSP_Latin1}"];
            ok (! defined $w, "... and no warning if warnings are off");
            use feature 'unicode_eval';
            eval qq[use utf8; "\\N{$NBSP_utf8}"];
            ok (! defined $w, "... same under 'use utf8'");
        }
        {
            use warnings FATAL=>'deprecated';
            () = eval qq["\\N{$NBSP_Latin1}"];
            like ($@@, qr/NO-BREAK SPACE in a charnames alias definition is deprecated/, "... the warning can be fatal");
            use feature 'unicode_eval';
            eval qq[use utf8; () = "\\N{$NBSP_utf8}"];
            like ($@@, qr/NO-BREAK SPACE in a charnames alias definition is deprecated/, "... same under utf8");
        }

        {
            BEGIN { no strict; *CnameTest:: = *{"_charnames\0A::" } }
            package CnameTest { sub translator { pop } }
            BEGIN { $^H{charnames} = \&CnameTest::translator }
            undef $w;
            () = eval q ["\N{TOO  MANY SPACES}"];
            like ($@@, qr/charnames alias definitions may not contain a sequence of multiple spaces/,
                 'translators in _charnames\0* packages get validated');
        }

        # If remove the limitation in regcomp code these should work
        # differently
        undef $w;
        eval q [ok "\N{TOO-LONG-STR}" =~ /^\N{TOO-LONG-STR}$/, 'Verify that what once was too long a string works'];
        eval 'q() =~ /\N{4F}/';
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that leading digit in name gives error';
        eval 'q() =~ /\N{COM,MA}/';
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that comma in name gives error';
        $name = "A" . uni_to_native("\x{D7}") . "O";
        eval "q(W) =~ /\\N{$name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that latin1 symbol in name gives error';
        my $utf8_name = "7 CITIES OF GOLD";
        utf8::upgrade($utf8_name);
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that leading digit in utf8 name gives error';
        $utf8_name = "SHARP #";
        utf8::upgrade($utf8_name);
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that ASCII symbol in utf8 name gives error';
        $utf8_name = "A HOUSE " . uni_to_native("\xF7") . " AGAINST ITSELF";
        utf8::upgrade($utf8_name);
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that latin1 symbol in utf8 name gives error';
        $utf8_name = "\x{664} HORSEMEN}";
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that leading above Latin1 digit in utf8 name gives error';
        $utf8_name = "A \x{1F4A9} WOULD SMELL AS SWEET}";
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that above Latin1 symbol in utf8 name gives error';

        undef $w;
        $name = "A" . uni_to_native("\x{D1}") . "O";
        eval "q(W) =~ /\\N{$name}/";
        ok ! $w, 'Verify that latin1 letter in name doesnt give warning';

        # This tests the code path that restarts the parse when the recursive
        # call to S_reg() from within S_grok_bslash_N() discovers that the
        # pattern needs to be recalculated as UTF-8.  use eval to avoid
        # needing literal Unicode in this source file:
        my $r = eval "qr/\\N{\x{100}\x{100}}/";
        isnt $r, undef, "Generated regex for multi-char UTF-8 charname"
	    or diag($@@);
        ok "\x{100}\x{100}" =~ $r, "which matches";
    }

    {
        use charnames ':full';

        ok 'aabc' !~ /a\N{PLUS SIGN}b/, '/a\N{PLUS SIGN}b/ against aabc';
        ok 'a+bc' =~ /a\N{PLUS SIGN}b/, '/a\N{PLUS SIGN}b/ against a+bc';

        ok ' A B' =~ /\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
            'Intermixed named and unicode escapes';
        ok "\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}" =~
           /\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}/,
            'Intermixed named and unicode escapes';
        ok "\N{SPACE}\N{U+0041}\N{SPACE}\N{U+0042}" =~
           /[\N{SPACE}\N{U+0041}][\N{SPACE}\N{U+0042}]/,
            'Intermixed named and unicode escapes';
        ok "\0" =~ /^\N{NULL}$/, 'Verify that \N{NULL} works; is not confused with an error';
    }

    {
        our $brackets;
        $brackets = qr{
            {  (?> [^{}]+ | (??{ $brackets }) )* }
        }x;

        ok "{b{c}d" !~ m/^((??{ $brackets }))/, "Bracket mismatch";

        SKIP: {
            our @@stack = ();
            my @@expect = qw(
                stuff1
                stuff2
                <stuff1>and<stuff2>
                right
                <right>
                <<right>>
                <<<right>>>
                <<stuff1>and<stuff2>><<<<right>>>>
            );

            local $_ = '<<<stuff1>and<stuff2>><<<<right>>>>>';
            ok /^(<((?:(?>[^<>]+)|(?1))*)>(?{push @@stack, $2 }))$/,
                "Recursion matches";
            is(@@stack, @@expect, "Right amount of matches")
                 or skip "Won't test individual results as count isn't equal",
                          0 + @@expect;
            my $idx = 0;
            foreach my $expect (@@expect) {
                is($stack [$idx], $expect,
		   "Expecting '$expect' at stack pos #$idx");
                $idx ++;
            }
        }
    }

    {
        my $s = '123453456';
        $s =~ s/(?<digits>\d+)\k<digits>/$+{digits}/;
        ok $s eq '123456', 'Named capture (angle brackets) s///';
        $s = '123453456';
        $s =~ s/(?'digits'\d+)\k'digits'/$+{digits}/;
        ok $s eq '123456', 'Named capture (single quotes) s///';
    }

    {
        my @@ary = (
            pack('U', 0x00F1), # n-tilde
            '_'.pack('U', 0x00F1), # _ + n-tilde
            'c'.pack('U', 0x0327),        # c + cedilla
            pack('U*', 0x00F1, 0x0327),# n-tilde + cedilla
            pack('U', 0x0391),            # ALPHA
            pack('U', 0x0391).'2',        # ALPHA + 2
            pack('U', 0x0391).'_',        # ALPHA + _
        );

        for my $uni (@@ary) {
            my ($r1, $c1, $r2, $c2) = eval qq {
                use utf8;
                scalar ("..foo foo.." =~ /(?'${uni}'foo) \\k'${uni}'/),
                        \$+{${uni}},
                scalar ("..bar bar.." =~ /(?<${uni}>bar) \\k<${uni}>/),
                        \$+{${uni}};
            };
            ok $r1,                         "Named capture UTF (?'')";
            ok defined $c1 && $c1 eq 'foo', "Named capture UTF \%+";
            ok $r2,                         "Named capture UTF (?<>)";
            ok defined $c2 && $c2 eq 'bar', "Named capture UTF \%+";
        }
    }

    {
        my $s = 'foo bar baz';
        my @@res;
        if ('1234' =~ /(?<A>1)(?<B>2)(?<A>3)(?<B>4)/) {
            foreach my $name (sort keys(%-)) {
                my $ary = $- {$name};
                foreach my $idx (0 .. $#$ary) {
                    push @@res, "$name:$idx:$ary->[$idx]";
                }
            }
        }
        my @@expect = qw (A:0:1 A:1:3 B:0:2 B:1:4);
        is("@@res", "@@expect", "Check %-");
        eval'
            no warnings "uninitialized";
            print for $- {this_key_doesnt_exist};
        ';
        ok !$@@,'lvalue $- {...} should not throw an exception';
    }

    {
        # \, breaks {3,4}
        no warnings qw{deprecated regexp};
        ok "xaaay"    !~ /xa{3\,4}y/, '\, in a pattern';
        ok "xa{3,4}y" =~ /xa{3\,4}y/, '\, in a pattern';

        # \c\ followed by _
        ok "x\c_y"    !~ /x\c\_y/,    '\_ in a pattern';
        ok "x\c\_y"   =~ /x\c\_y/,    '\_ in a pattern';

        # \c\ followed by other characters
        for my $c ("z", "\0", "!", chr(254), chr(256)) {
            my $targ = "a" . uni_to_native("\034") . "$c";
            my $reg  = "a\\c\\$c";
            ok eval ("qq/$targ/ =~ /$reg/"), "\\c\\ in pattern";
        }
    }

    {   # Test the (*PRUNE) pattern
        our $count = 0;
        'aaab' =~ /a+b?(?{$count++})(*FAIL)/;
        is($count, 9, "Expect 9 for no (*PRUNE)");
        $count = 0;
        'aaab' =~ /a+b?(*PRUNE)(?{$count++})(*FAIL)/;
        is($count, 3, "Expect 3 with (*PRUNE)");
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*PRUNE)(?{$count++})(*FAIL)/g;
        is($count, 4, "/.(*PRUNE)/");
        $count = 0;
        'aaab' =~ /a+b?(??{'(*PRUNE)'})(?{$count++})(*FAIL)/;
        is($count, 3, "Expect 3 with (*PRUNE)");
        local $_ = 'aaab';
        $count = 0;
        1 while /.(??{'(*PRUNE)'})(?{$count++})(*FAIL)/g;
        is($count, 4, "/.(*PRUNE)/");
    }

    {   # Test the (*SKIP) pattern
        our $count = 0;
        'aaab' =~ /a+b?(*SKIP)(?{$count++})(*FAIL)/;
        is($count, 1, "Expect 1 with (*SKIP)");
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*SKIP)(?{$count++})(*FAIL)/g;
        is($count, 4, "/.(*SKIP)/");
        $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while /(a+b?)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
        is($count, 2, "Expect 2 with (*SKIP)");
        is("@@res", "aaab aaab", "Adjacent (*SKIP) works as expected");
    }

    {   # Test the (*SKIP) pattern
        our $count = 0;
        'aaab' =~ /a+b?(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/;
        is($count, 1, "Expect 1 with (*SKIP)");
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*MARK:foo)(*SKIP)(?{$count++})(*FAIL)/g;
        is($count, 4, "/.(*SKIP)/");
        $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while /(a+b?)(*MARK:foo)(*SKIP)(?{$count++; push @@res,$1})(*FAIL)/g;
        is($count, 2, "Expect 2 with (*SKIP)");
        is("@@res", "aaab aaab", "Adjacent (*SKIP) works as expected");
    }

    {   # Test the (*SKIP) pattern
        our $count = 0;
        'aaab' =~ /a*(*MARK:a)b?(*MARK:b)(*SKIP:a)(?{$count++})(*FAIL)/;
        is($count, 3, "Expect 3 with *MARK:a)b?(*MARK:b)(*SKIP:a)");
        local $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while
        /(a*(*MARK:a)b?)(*MARK:x)(*SKIP:a)(?{$count++; push @@res,$1})(*FAIL)/g;
        is($count, 5, "Expect 5 with (*MARK:a)b?)(*MARK:x)(*SKIP:a)");
        is("@@res", "aaab b aaab b ",
	   "Adjacent (*MARK:a)b?)(*MARK:x)(*SKIP:a) works as expected");
    }

    {   # Test the (*COMMIT) pattern
        our $count = 0;
        'aaabaaab' =~ /a+b?(*COMMIT)(?{$count++})(*FAIL)/;
        is($count, 1, "Expect 1 with (*COMMIT)");
        local $_ = 'aaab';
        $count = 0;
        1 while /.(*COMMIT)(?{$count++})(*FAIL)/g;
        is($count, 1, "/.(*COMMIT)/");
        $_ = 'aaabaaab';
        $count = 0;
        our @@res = ();
        1 while /(a+b?)(*COMMIT)(?{$count++; push @@res,$1})(*FAIL)/g;
        is($count, 1, "Expect 1 with (*COMMIT)");
        is("@@res", "aaab", "Adjacent (*COMMIT) works as expected");

	ok("1\n2a\n" !~ /^\d+(*COMMIT)\w+/m, "COMMIT and anchors");
    }

    {
        # Test named commits and the $REGERROR var
        local $REGERROR;
        for my $name ('', ':foo') {
            for my $pat ("(*PRUNE$name)",
                         ($name ? "(*MARK$name)" : "") . "(*SKIP$name)",
                         "(*COMMIT$name)") {
                for my $suffix ('(*FAIL)', '') {
                    'aaaab' =~ /a+b$pat$suffix/;
                    is($REGERROR,
                         ($suffix ? ($name ? 'foo' : "1") : ""),
                        "Test $pat and \$REGERROR $suffix");
                }
            }
        }
    }

    {
        # Test named commits and the $REGERROR var
        package Fnorble;
        our $REGERROR;
        local $REGERROR;
        for my $name ('', ':foo') {
            for my $pat ("(*PRUNE$name)",
                         ($name ? "(*MARK$name)" : "") . "(*SKIP$name)",
                         "(*COMMIT$name)") {
                for my $suffix ('(*FAIL)','') {
                    'aaaab' =~ /a+b$pat$suffix/;
		    ::is($REGERROR,
                         ($suffix ? ($name ? 'foo' : "1") : ""),
			 "Test $pat and \$REGERROR $suffix");
                }
            }
        }
    }

    {
        # Test named commits and the $REGERROR var
	my $message = '$REGERROR';
        local $REGERROR;
        for my $word (qw (bar baz bop)) {
            $REGERROR = "";
            "aaaaa$word" =~
              /a+(?:bar(*COMMIT:bar)|baz(*COMMIT:baz)|bop(*COMMIT:bop))(*FAIL)/;
            is($REGERROR, $word, $message);
        }
    }

    {
        #Mindnumbingly simple test of (*THEN)
        for ("ABC","BAX") {
            ok /A (*THEN) X | B (*THEN) C/x, "Simple (*THEN) test";
        }
    }

    {
        my $message = "Relative Recursion";
        my $parens = qr/(\((?:[^()]++|(?-1))*+\))/;
        local $_ = 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))';
        my ($all, $one, $two) = ('', '', '');
        ok(m/foo $parens \s* \+ \s* bar $parens/x, $message);
        is($1, '((2*3)+4-3)', $message);
        is($2, '(2*(3+4)-1*(2-3))', $message);
        is($&, 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))', $message);
        is($&, $_, $message);
    }

    {
        my $spaces="      ";
        local $_ = join 'bar', $spaces, $spaces;
        our $count = 0;
        s/(?>\s+bar)(?{$count++})//g;
        is($_, $spaces, "SUSPEND final string");
        is($count, 1, "Optimiser should have prevented more than one match");
    }

    {
        # From Message-ID: <877ixs6oa6.fsf@@k75.linux.bogus>
        my $dow_name = "nada";
        my $parser = "(\$dow_name) = \$time_string =~ /(D\x{e9}\\ " .
                     "C\x{e9}adaoin|D\x{e9}\\ Sathairn|\\w+|\x{100})/";
        my $time_string = "D\x{e9} C\x{e9}adaoin";
        eval $parser;
        ok !$@@, "Test Eval worked";
        is($dow_name, $time_string, "UTF-8 trie common prefix extraction");
    }

    {
        my $v;
        ($v = 'bar') =~ /(\w+)/g;
        $v = 'foo';
        is("$1", 'bar',
	   '$1 is safe after /g - may fail due to specialized config in pp_hot.c');
    }

    {
        my $message = "http://nntp.perl.org/group/perl.perl5.porters/118663";
        my $qr_barR1 = qr/(bar)\g-1/;
        like("foobarbarxyz", $qr_barR1, $message);
        like("foobarbarxyz", qr/foo${qr_barR1}xyz/, $message);
        like("foobarbarxyz", qr/(foo)${qr_barR1}xyz/, $message);
        like("foobarbarxyz", qr/(foo)(bar)\g{-1}xyz/, $message);
        like("foobarbarxyz", qr/(foo${qr_barR1})xyz/, $message);
        like("foobarbarxyz", qr/(foo(bar)\g{-1})xyz/, $message);
    }

    {
        my $message = '$REGMARK';
        our @@r = ();
        local $REGMARK;
        local $REGERROR;
        like('foofoo', qr/foo (*MARK:foo) (?{push @@r,$REGMARK}) /x, $message);
        is("@@r","foo", $message);
        is($REGMARK, "foo", $message);
        unlike('foofoo', qr/foo (*MARK:foo) (*FAIL) /x, $message);
        is($REGMARK, '', $message);
        is($REGERROR, 'foo', $message);
    }

    {
        my $message = '\K test';
        my $x;
        $x = "abc.def.ghi.jkl";
        $x =~ s/.*\K\..*//;
        is($x, "abc.def.ghi", $message);

        $x = "one two three four";
        $x =~ s/o+ \Kthree//g;
        is($x, "one two  four", $message);

        $x = "abcde";
        $x =~ s/(.)\K/$1/g;
        is($x, "aabbccddee", $message);
    }

    {
        sub kt {
            return '4' if $_[0] eq '09028623';
        }
        # Nested EVAL using PL_curpm (via $1 or friends)
        my $re;
        our $grabit = qr/ ([0-6][0-9]{7}) (??{ kt $1 }) [890] /x;
        $re = qr/^ ( (??{ $grabit }) ) $ /x;
        my @@res = '0902862349' =~ $re;
        is(join ("-", @@res), "0902862349",
	   'PL_curpm is set properly on nested eval');

        our $qr = qr/ (o) (??{ $1 }) /x;
        ok 'boob'=~/( b (??{ $qr }) b )/x && 1, "PL_curpm, nested eval";
    }

    {
        use charnames ":full";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "I =~ Alphabetic";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{Uppercase}/,  "I =~ Uppercase";
        ok "\N{ROMAN NUMERAL ONE}" !~ /\p{Lowercase}/,  "I !~ Lowercase";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "I =~ ID_Start";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "I =~ ID_Continue";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Alphabetic}/, "i =~ Alphabetic";
        ok "\N{SMALL ROMAN NUMERAL ONE}" !~ /\p{Uppercase}/,  "i !~ Uppercase";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Uppercase}/i,  "i =~ Uppercase under /i";
        ok "\N{SMALL ROMAN NUMERAL ONE}" !~ /\p{Titlecase}/,  "i !~ Titlecase";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Titlecase}/i,  "i =~ Titlecase under /i";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{Lowercase}/i,  "I =~ Lowercase under /i";

        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Lowercase}/,  "i =~ Lowercase";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDStart}/,    "i =~ ID_Start";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{IDContinue}/, "i =~ ID_Continue"
    }

    {   # More checking that /i works on the few properties that it makes a
        # difference.  Uppercase, Lowercase, and Titlecase were done in the
        # block above
        ok "A" =~ /\p{PosixUpper}/,  "A =~ PosixUpper";
        ok "A" =~ /\p{PosixUpper}/i,  "A =~ PosixUpper under /i";
        ok "A" !~ /\p{PosixLower}/,  "A !~ PosixLower";
        ok "A" =~ /\p{PosixLower}/i,  "A =~ PosixLower under /i";
        ok "a" !~ /\p{PosixUpper}/,  "a !~ PosixUpper";
        ok "a" =~ /\p{PosixUpper}/i,  "a =~ PosixUpper under /i";
        ok "a" =~ /\p{PosixLower}/,  "a =~ PosixLower";
        ok "a" =~ /\p{PosixLower}/i,  "a =~ PosixLower under /i";

        ok uni_to_native("\xC0") =~ /\p{XPosixUpper}/,  "\\xC0 =~ XPosixUpper";
        ok uni_to_native("\xC0") =~ /\p{XPosixUpper}/i,  "\\xC0 =~ XPosixUpper under /i";
        ok uni_to_native("\xC0") !~ /\p{XPosixLower}/,  "\\xC0 !~ XPosixLower";
        ok uni_to_native("\xC0") =~ /\p{XPosixLower}/i,  "\\xC0 =~ XPosixLower under /i";
        ok uni_to_native("\xE0") !~ /\p{XPosixUpper}/,  "\\xE0 !~ XPosixUpper";
        ok uni_to_native("\xE0") =~ /\p{XPosixUpper}/i,  "\\xE0 =~ XPosixUpper under /i";
        ok uni_to_native("\xE0") =~ /\p{XPosixLower}/,  "\\xE0 =~ XPosixLower";
        ok uni_to_native("\xE0") =~ /\p{XPosixLower}/i,  "\\xE0 =~ XPosixLower under /i";

        ok uni_to_native("\xC0") =~ /\p{UppercaseLetter}/,  "\\xC0 =~ UppercaseLetter";
        ok uni_to_native("\xC0") =~ /\p{UppercaseLetter}/i,  "\\xC0 =~ UppercaseLetter under /i";
        ok uni_to_native("\xC0") !~ /\p{LowercaseLetter}/,  "\\xC0 !~ LowercaseLetter";
        ok uni_to_native("\xC0") =~ /\p{LowercaseLetter}/i,  "\\xC0 =~ LowercaseLetter under /i";
        ok uni_to_native("\xC0") !~ /\p{TitlecaseLetter}/,  "\\xC0 !~ TitlecaseLetter";
        ok uni_to_native("\xC0") =~ /\p{TitlecaseLetter}/i,  "\\xC0 =~ TitlecaseLetter under /i";
        ok uni_to_native("\xE0") !~ /\p{UppercaseLetter}/,  "\\xE0 !~ UppercaseLetter";
        ok uni_to_native("\xE0") =~ /\p{UppercaseLetter}/i,  "\\xE0 =~ UppercaseLetter under /i";
        ok uni_to_native("\xE0") =~ /\p{LowercaseLetter}/,  "\\xE0 =~ LowercaseLetter";
        ok uni_to_native("\xE0") =~ /\p{LowercaseLetter}/i,  "\\xE0 =~ LowercaseLetter under /i";
        ok uni_to_native("\xE0") !~ /\p{TitlecaseLetter}/,  "\\xE0 !~ TitlecaseLetter";
        ok uni_to_native("\xE0") =~ /\p{TitlecaseLetter}/i,  "\\xE0 =~ TitlecaseLetter under /i";
        ok "\x{1C5}" !~ /\p{UppercaseLetter}/,  "\\x{1C5} !~ UppercaseLetter";
        ok "\x{1C5}" =~ /\p{UppercaseLetter}/i,  "\\x{1C5} =~ UppercaseLetter under /i";
        ok "\x{1C5}" !~ /\p{LowercaseLetter}/,  "\\x{1C5} !~ LowercaseLetter";
        ok "\x{1C5}" =~ /\p{LowercaseLetter}/i,  "\\x{1C5} =~ LowercaseLetter under /i";
        ok "\x{1C5}" =~ /\p{TitlecaseLetter}/,  "\\x{1C5} =~ TitlecaseLetter";
        ok "\x{1C5}" =~ /\p{TitlecaseLetter}/i,  "\\x{1C5} =~ TitlecaseLetter under /i";
    }

    {
        # requirement of Unicode Technical Standard #18, 1.7 Code Points
        # cf. http://www.unicode.org/reports/tr18/#Supplementary_Characters
        for my $u (0x7FF, 0x800, 0xFFFF, 0x10000) {
            no warnings 'utf8'; # oops
            my $c = chr $u;
            my $x = sprintf '%04X', $u;
            ok "A${c}B" =~ /A[\0-\x{10000}]B/, "Unicode range - $x";
        }
    }

    {
        my $res="";

        if ('1' =~ /(?|(?<digit>1)|(?<digit>2))/) {
            $res = "@@{$- {digit}}";
        }
        is($res, "1",
	   "Check that (?|...) doesnt cause dupe entries in the names array");

        $res = "";
        if ('11' =~ /(?|(?<digit>1)|(?<digit>2))(?&digit)/) {
            $res = "@@{$- {digit}}";
        }
        is($res, "1",
	   "Check that (?&..) to a buffer inside a (?|...) goes to the leftmost");
    }

    {
        use warnings;
        my $message = "ASCII pattern that really is UTF-8";
        my @@w;
        local $SIG {__WARN__} = sub {push @@w, "@@_"};
        my $c = qq (\x{DF});
        like($c, qr/${c}|\x{100}/, $message);
        is("@@w", '', $message);
    }

    {
        my $message = "Corruption of match results of qr// across scopes";
        my $qr = qr/(fo+)(ba+r)/;
        'foobar' =~ /$qr/;
        is("$1$2", "foobar", $message);
        {
            'foooooobaaaaar' =~ /$qr/;
            is("$1$2", 'foooooobaaaaar', $message);
        }
        is("$1$2", "foobar", $message);
    }

    {
        my $message = "HORIZWS";
        local $_ = "\t \r\n \n \t".chr(11)."\n";
        s/\H/H/g;
        s/\h/h/g;
        is($_, "hhHHhHhhHH", $message);
        $_ = "\t \r\n \n \t" . chr (11) . "\n";
        utf8::upgrade ($_);
        s/\H/H/g;
        s/\h/h/g;
        is($_, "hhHHhHhhHH", $message);
    }

    {
        # Various whitespace special patterns
        my @@h = map {chr utf8::unicode_to_native($_) }
                             0x09,   0x20,   0xa0,   0x1680, 0x2000,
                             0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,
                             0x2007, 0x2008, 0x2009, 0x200a, 0x202f, 0x205f,
                             0x3000;
        my @@v = map {chr utf8::unicode_to_native($_) }
                             0x0a,   0x0b,   0x0c,   0x0d,   0x85, 0x2028,
                             0x2029;
        my @@lb = (uni_to_native("\x0D\x0A"),
                             map {chr utf8::unicode_to_native($_) }
                                  0x0A .. 0x0D, 0x85, 0x2028, 0x2029);
        foreach my $t ([\@@h,  qr/\h/, qr/\h+/],
                       [\@@v,  qr/\v/, qr/\v+/],
                       [\@@lb, qr/\R/, qr/\R+/],) {
            my $ary = shift @@$t;
            foreach my $pat (@@$t) {
                foreach my $str (@@$ary) {
                    my $temp_str = $str;
                    $temp_str = display($temp_str);
                    ok $str =~ /($pat)/, $temp_str . " =~ /($pat)";
                    my $temp_1 = $1;
                    is($1, $str, "\$1='" . display($temp_1) . "' eq '" . $temp_str . "' after ($pat)");
                    utf8::upgrade ($str);
                    ok $str =~ /($pat)/, "Upgraded " . $temp_str . " =~ /($pat)/";
                    is($1, $str, "\$1='" . display($temp_1) . "' eq '" . $temp_str . "'(upgraded) after ($pat)");
                }
            }
        }
    }

    {
        # Check that \\xDF match properly in its various forms
        # Test that \xDF matches properly. this is pretty hacky stuff,
        # but its actually needed. The malarky with '-' is to prevent
        # compilation caching from playing any role in the test.
        my @@df = (chr utf8::unicode_to_native(0xDF), '-', chr utf8::unicode_to_native(0xDF));
        utf8::upgrade ($df [2]);
        my @@strs = ('ss', 'sS', 'Ss', 'SS', chr utf8::unicode_to_native(0xDF));
        my @@ss = map {("$_", "$_")} @@strs;
        utf8::upgrade ($ss [$_ * 2 + 1]) for 0 .. $#strs;

        for my $ssi (0 .. $#ss) {
            for my $dfi (0 .. $#df) {
                my $pat = $df [$dfi];
                my $str = $ss [$ssi];
                my $utf_df = ($dfi > 1) ? 'utf8' : '';
                my $utf_ss = ($ssi % 2) ? 'utf8' : '';
                my $sstr;   # We hard-code the ebcdic value below to avoid
                            # perturbing the test
                ($sstr = $str) =~ s/\xDF/\\xDF/ if $::IS_ASCII;
                ($sstr = $str) =~ s/\x59/\\x59/ if $::IS_EBCDIC;

                if ($utf_df || $utf_ss || length ($ss [$ssi]) == 1) {
                    my $ret = $str =~ /$pat/i;
                    next if $pat eq '-';
                    if ($::IS_ASCII) {
                        ok $ret, "\"$sstr\" =~ /\\xDF/i " .
                             "(str is @@{[$utf_ss||'latin']}, pat is " .
                             "@@{[$utf_df||'latin']})";
                    }
                    else {
                        ok $ret, "\"$sstr\" =~ /\\x59/i " .
                             "(str is @@{[$utf_ss||'latin']}, pat is " .
                             "@@{[$utf_df||'latin']})";
                    }
                }
                else {
                    my $ret = $str !~ /$pat/i;
                    next if $pat eq '-';
                    if ($::IS_EBCDIC) {
                        ok $ret, "\"$sstr\" !~ /\\x59/i " .
                             "(str is @@{[$utf_ss||'latin']}, pat is " .
                             "@@{[$utf_df||'latin']})";
                    }
                    else {
                        ok $ret, "\"$sstr\" !~ /\\xDF/i " .
                             "(str is @@{[$utf_ss||'latin']}, pat is " .
                             "@@{[$utf_df||'latin']})";
                    }
                }
            }
        }
    }

    {
        my $message = "BBC(Bleadperl Breaks CPAN) Today: String::Multibyte";
        my $re  = qr/(?:[\x00-\xFF]{4})/;
        my $hyp = "\0\0\0-";
        my $esc = "\0\0\0\\";

        my $str = "$esc$hyp$hyp$esc$esc";
        my @@a = ($str =~ /\G(?:\Q$esc$esc\E|\Q$esc$hyp\E|$re)/g);

        is(@@a,3, $message);
        local $" = "=";
        is("@@a","$esc$hyp=$hyp=$esc$esc", $message);
    }

    {
        # Test for keys in %+ and %-
        my $message = 'Test keys in %+ and %-';
        no warnings 'uninitialized';
        local $_ = "abcdef";
        /(?<foo>a)|(?<foo>b)/;
        is((join ",", sort keys %+), "foo", $message);
        is((join ",", sort keys %-), "foo", $message);
        is((join ",", sort values %+), "a", $message);
        is((join ",", sort map "@@$_", values %-), "a ", $message);
        /(?<bar>a)(?<bar>b)(?<quux>.)/;
        is((join ",", sort keys %+), "bar,quux", $message);
        is((join ",", sort keys %-), "bar,quux", $message);
        is((join ",", sort values %+), "a,c", $message); # leftmost
        is((join ",", sort map "@@$_", values %-), "a b,c", $message);
        /(?<un>a)(?<deux>c)?/; # second buffer won't capture
        is((join ",", sort keys %+), "un", $message);
        is((join ",", sort keys %-), "deux,un", $message);
        is((join ",", sort values %+), "a", $message);
        is((join ",", sort map "@@$_", values %-), ",a", $message);
    }

    {
        # length() on captures, the numbered ones end up in Perl_magic_len
        local $_ = "aoeu " . uni_to_native("\xe6") . "var ook";
        /^ \w+ \s (?<eek>\S+)/x;

        is(length $`,      0, q[length $`]);
        is(length $',      4, q[length $']);
        is(length $&,      9, q[length $&]);
        is(length $1,      4, q[length $1]);
        is(length $+{eek}, 4, q[length $+{eek} == length $1]);
    }

    {
        my $ok = -1;

        $ok = exists ($-{x}) ? 1 : 0 if 'bar' =~ /(?<x>foo)|bar/;
        is($ok, 1, '$-{x} exists after "bar"=~/(?<x>foo)|bar/');
        is(scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/');
        is(scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/');

        $ok = -1;
        $ok = exists ($+{x}) ? 1 : 0 if 'bar' =~ /(?<x>foo)|bar/;
        is($ok, 0, '$+{x} not exists after "bar"=~/(?<x>foo)|bar/');
        is(scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/');
        is(scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/');

        $ok = -1;
        $ok = exists ($-{x}) ? 1 : 0 if 'foo' =~ /(?<x>foo)|bar/;
        is($ok, 1, '$-{x} exists after "foo"=~/(?<x>foo)|bar/');
        is(scalar (%+), 1, 'scalar %+ == 1 after "foo"=~/(?<x>foo)|bar/');
        is(scalar (%-), 1, 'scalar %- == 1 after "foo"=~/(?<x>foo)|bar/');

        $ok = -1;
        $ok = exists ($+{x}) ? 1 : 0 if 'foo'=~/(?<x>foo)|bar/;
        is($ok, 1, '$+{x} exists after "foo"=~/(?<x>foo)|bar/');
    }

    {
        local $_;
        ($_ = 'abc') =~ /(abc)/g;
        $_ = '123';
        is("$1", 'abc', "/g leads to unsafe match vars: $1");

        fresh_perl_is(<<'EOP', ">abc<\n", {}, 'mention $&');
$&;
my $x; 
($x='abc')=~/(abc)/g; 
$x='123'; 
print ">$1<\n";
EOP

        fresh_perl_is(<<'EOP', ">abc<\n", {}, 'no mention of $&');
my $x; 
($x='abc')=~/(abc)/g; 
$x='123'; 
print ">$1<\n";
EOP
    }

    {
        # Message-ID: <20070818091501.7eff4831@@r2d2>
        my $str = "";
        for (0 .. 5) {
            my @@x;
            $str .= "@@x"; # this should ALWAYS be the empty string
            'a' =~ /(a|)/;
            push @@x, 1;
        }
        is(length $str, 0, "Trie scope error, string should be empty");
        $str = "";
        my @@foo = ('a') x 5;
        for (@@foo) {
            my @@bar;
            $str .= "@@bar";
            s/a|/push @@bar, 1/e;
        }
        is(length $str, 0, "Trie scope error, string should be empty");
    }

    {
# more TRIE/AHOCORASICK problems with mixed utf8 / latin-1 and case folding
    for my $ord (160 .. 255) {
        my $chr = utf8::unicode_to_native($ord);
        my $chr_byte = chr($chr);
        my $chr_utf8 = chr($chr); utf8::upgrade($chr_utf8);
        my $rx = qr{$chr_byte|X}i;
        ok($chr_utf8 =~ $rx, "utf8/latin, codepoint $chr");
    }
    }

    {
        our $a = 3; "" =~ /(??{ $a })/;
        our $b = $a;
        is($b, $a, "Copy of scalar used for postponed subexpression");
    }

    {
        our @@ctl_n = ();
        our @@plus = ();
        our $nested_tags;
        $nested_tags = qr{
            <
               (\w+)
               (?{
                       push @@ctl_n,$^N;
                       push @@plus,$+;
               })
            >
            (??{$nested_tags})*
            </\s* \w+ \s*>
        }x;

        my $match = '<bla><blubb></blubb></bla>' =~ m/^$nested_tags$/;
        ok $match, 'nested construct matches';
        is("@@ctl_n", "bla blubb", '$^N inside of (?{}) works as expected');
        is("@@plus",  "bla blubb", '$+  inside of (?{}) works as expected');
    }

    SKIP: {
        # XXX: This set of tests is essentially broken, POSIX character classes
        # should not have differing definitions under Unicode.
        # There are property names for that.
        skip "Tests assume ASCII", 4 unless $::IS_ASCII;

        my @@notIsPunct = grep {/[[:punct:]]/ and not /\p{IsPunct}/}
                                map {chr} 0x20 .. 0x7f;
        is(join ('', @@notIsPunct), '$+<=>^`|~',
	   '[:punct:] disagrees with IsPunct on Symbols');

        my @@isPrint = grep {not /[[:print:]]/ and /\p{IsPrint}/}
                            map {chr} 0 .. 0x1f, 0x7f .. 0x9f;
        is(join ('', @@isPrint), "",
	   'IsPrint agrees with [:print:] on control characters');

        my @@isPunct = grep {/[[:punct:]]/ != /\p{IsPunct}/}
                            map {chr} 0x80 .. 0xff;
        is(join ('', @@isPunct), "\xa1\xa7\xab\xb6\xb7\xbb\xbf",    # ¡ « · » ¿
	   'IsPunct disagrees with [:punct:] outside ASCII');

        my @@isPunctLatin1 = eval q {
            grep {/[[:punct:]]/u != /\p{IsPunct}/} map {chr} 0x80 .. 0xff;
        };
        skip "Eval failed ($@@)", 1 if $@@;
        skip "PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS set to 0", 1
              if !$ENV{PERL_TEST_LEGACY_POSIX_CC};
        is(join ('', @@isPunctLatin1), '',
	   'IsPunct agrees with [:punct:] with explicit Latin1');
    }

    {
	# Tests for [#perl 71942]
        our $count_a;
        our $count_b;

        my $c = 0;
        for my $re (
#            [
#                should match?,
#                input string,
#                re 1,
#                re 2,
#                expected values of count_a and count_b,
#            ]
            [
                0,
                "xababz",
                qr/a+(?{$count_a++})b?(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})b?(*COMMIT)z/,
                1,
            ],
            [
                0,
                "xababz",
                qr/a+(?{$count_a++})b?(*COMMIT)\s*(*FAIL)/,
                qr/a+(?{$count_b++})b?(*COMMIT)\s*z/,
                1,
            ],
            [
                0,
                "xababz",
                qr/a+(?{$count_a++})(?:b|)?(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})(?:b|)?(*COMMIT)z/,
                1,
            ],
            [
                0,
                "xababz",
                qr/a+(?{$count_a++})b{0,6}(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})b{0,6}(*COMMIT)z/,
                1,
            ],
            [
                0,
                "xabcabcz",
                qr/a+(?{$count_a++})(bc){0,6}(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})(bc){0,6}(*COMMIT)z/,
                1,
            ],
            [
                0,
                "xabcabcz",
                qr/a+(?{$count_a++})(bc*){0,6}(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})(bc*){0,6}(*COMMIT)z/,
                1,
            ],


            [
                0,
                "aaaabtz",
                qr/a+(?{$count_a++})b?(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})b?(*PRUNE)z/,
                4,
            ],
            [
                0,
                "aaaabtz",
                qr/a+(?{$count_a++})b?(*PRUNE)\s*(*FAIL)/,
                qr/a+(?{$count_b++})b?(*PRUNE)\s*z/,
                4,
            ],
            [
                0,
                "aaaabtz",
                qr/a+(?{$count_a++})(?:b|)(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})(?:b|)(*PRUNE)z/,
                4,
            ],
            [
                0,
                "aaaabtz",
                qr/a+(?{$count_a++})b{0,6}(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})b{0,6}(*PRUNE)z/,
                4,
            ],
            [
                0,
                "aaaabctz",
                qr/a+(?{$count_a++})(bc){0,6}(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})(bc){0,6}(*PRUNE)z/,
                4,
            ],
            [
                0,
                "aaaabctz",
                qr/a+(?{$count_a++})(bc*){0,6}(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})(bc*){0,6}(*PRUNE)z/,
                4,
            ],

            [
                0,
                "aaabaaab",
                qr/a+(?{$count_a++;})b?(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})b?(*SKIP)z/,
                2,
            ],
            [
                0,
                "aaabaaab",
                qr/a+(?{$count_a++;})b?(*SKIP)\s*(*FAIL)/,
                qr/a+(?{$count_b++;})b?(*SKIP)\s*z/,
                2,
            ],
            [
                0,
                "aaabaaab",
                qr/a+(?{$count_a++;})(?:b|)(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})(?:b|)(*SKIP)z/,
                2,
            ],
            [
                0,
                "aaabaaab",
                qr/a+(?{$count_a++;})b{0,6}(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})b{0,6}(*SKIP)z/,
                2,
            ],
            [
                0,
                "aaabcaaabc",
                qr/a+(?{$count_a++;})(bc){0,6}(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})(bc){0,6}(*SKIP)z/,
                2,
            ],
            [
                0,
                "aaabcaaabc",
                qr/a+(?{$count_a++;})(bc*){0,6}(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})(bc*){0,6}(*SKIP)z/,
                2,
            ],


            [
                0,
                "aaddbdaabyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? b?  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? b?  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbdaabyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? b?  (*SKIP:T1) \s* (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? b?  (*SKIP:T1) \s* z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbdaabyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? (?:b|)  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? (?:b|)  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbdaabyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? b{0,6}  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? b{0,6}  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbcdaabcyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? (bc){0,6}  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? (bc){0,6}  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbcdaabcyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? (bc*){0,6}  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? (bc*){0,6}  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],


            [
                0,
                "aaaaddbdaabyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? b?   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? b?   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbdaabyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? b?   (*MARK:T1) (*SKIP:T1) \s* (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? b?   (*MARK:T1) (*SKIP:T1) \s* z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbdaabyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? (?:b|)   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? (?:b|)   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbdaabyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? b{0,6}   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? b{0,6}   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbcdaabcyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? (bc){0,6}   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? (bc){0,6}   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbcdaabcyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? (bc*){0,6}   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? (bc*){0,6}   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],


            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) C? (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) C? (*THEN)  | A D) z/x,
                1,
            ],
            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) C? (*THEN)  | A D) \s* (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) C? (*THEN)  | A D) \s* z/x,
                1,
            ],
            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) (?:C|) (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) (?:C|) (*THEN)  | A D) z/x,
                1,
            ],
            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) C{0,6} (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) C{0,6} (*THEN)  | A D) z/x,
                1,
            ],
            [
                0,
                "AbcdCEBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) (CE){0,6} (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) (CE){0,6} (*THEN)  | A D) z/x,
                1,
            ],
            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) (CE*){0,6} (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) (CE*){0,6} (*THEN)  | A D) z/x,
                1,
            ],
        ) {
            $c++;
            $count_a = 0;
            $count_b = 0;

            my $match_a = ($re->[1] =~ $re->[2]) || 0;
            my $match_b = ($re->[1] =~ $re->[3]) || 0;

            is($match_a, $re->[0], "match a " . ($re->[0] ? "succeeded" : "failed") . " ($c)");
            is($match_b, $re->[0], "match b " . ($re->[0] ? "succeeded" : "failed") . " ($c)");
            is($count_a, $re->[4], "count a ($c)");
            is($count_b, $re->[4], "count b ($c)");
        }
    }

    {   # Bleadperl v5.13.8-292-gf56b639 breaks NEZUMI/Unicode-LineBreak-1.011
        # \xdf in lookbehind failed to compile as is multi-char fold
        my $message = "Lookbehind with \\xdf matchable compiles";
        my $r = eval 'qr{
            (?u: (?<=^url:) |
                 (?<=[/]) (?=[^/]) |
                 (?<=[^-.]) (?=[-~.,_?\#%=&]) |
                 (?<=[=&]) (?=.)
            )}iox';
	is($@@, '', $message);
	object_ok($r, 'Regexp', $message);
    }

    # RT #82610
    ok 'foo/file.fob' =~ m,^(?=[^\.])[^/]*/(?=[^\.])[^/]*\.fo[^/]$,;

    {   # This was failing unless an explicit /d was added
        my $E0 = uni_to_native("\xE0");
        my $p = qr/[_$E0]/i;
        utf8::upgrade($p);
        like(uni_to_native("\xC0"), qr/$p/, "Verify \"\\xC0\" =~ /[\\xE0_]/i; pattern in utf8");
    }

    ok "x" =~ /\A(?>(?:(?:)A|B|C?x))\z/,
        "Check TRIE does not overwrite EXACT following NOTHING at start - RT #111842";

    {
        my $single = ":";
        my $upper = "\x{390}";  # Fold is 3 chars.
        my $multi = CORE::fc($upper);

        my $failed = 0;

        # Try forcing a node to be split, with a multi-char fold at the
        # boundary
        for my $repeat (1 .. 300) {
            my $string = $single x $repeat;
            my $lhs = $string . $upper;
            if ($lhs !~ m/$string$multi/i) {
                $failed = $repeat;
                last;
            }
        }
        ok(! $failed, "Matched multi-char fold across EXACTFish node boundaries; if failed, was at count $failed");

        $failed = 0;
        for my $repeat (1 .. 300) {
            my $string = $single x $repeat;
            my $lhs = $string . "\N{LATIN SMALL LIGATURE FFI}";
            if ($lhs !~ m/${string}ff\N{LATIN SMALL LETTER I}/i) {
                $failed = $repeat;
                last;
            }
        }
        ok(! $failed, "Matched multi-char fold across EXACTFish node boundaries; if failed, was at count $failed");

        $failed = 0;
        for my $repeat (1 .. 300) {
            my $string = $single x $repeat;
            my $lhs = $string . "\N{LATIN SMALL LIGATURE FFL}";
            if ($lhs !~ m/${string}ff\N{U+6c}/i) {
                $failed = $repeat;
                last;
            }
        }
        ok(! $failed, "Matched multi-char fold across EXACTFish node boundaries; if failed, was at count $failed");

        # This tests that under /d matching that an 'ss' split across two
        # parts of a node doesn't end up turning into something that matches
        # \xDF unless it is in utf8.
        $failed = 0;
        $single = 'a';  # Is non-terminal multi-char fold char
        for my $repeat (1 .. 300) {
            my $string = $single x $repeat;
            my $lhs = "$string\N{LATIN SMALL LETTER SHARP S}";
            utf8::downgrade($lhs);
            $string .= "s";
            if ($lhs =~ m/${string}s/di) {
                $failed = $repeat;
                last;
            }
        }
        ok(! $failed, "Matched multi-char fold 'ss' across EXACTF node boundaries; if failed, was at count $failed");
    }

    {
        fresh_perl_is('print eval "\"\x{101}\" =~ /[[:lower:]]/", "\n"; print eval "\"\x{100}\" =~ /[[:lower:]]/i", "\n";',
                      "1\n1",   # Both re's should match
                      {},
                      "get [:lower:] swash in first eval; test under /i in second");
    }

    {
        fresh_perl_is(<<'EOF',
                my $s = "\x{41c}";
                $s =~ /(.*)/ or die;
                $ls = lc $1;
                print $ls eq lc $s ? "good\n" : "bad: [$ls]\n";
EOF
            "good\n",
            {},
            "swash triggered by lc() doesn't corrupt \$1"
        );
    }

    {
        #' RT #119075
        no warnings 'regexp';   # Silence "has useless greediness modifier"
        local $@@;
        eval { /a{0}?/; };
        ok(! $@@,
            "PCRE regression test: No 'Quantifier follows nothing in regex' warning");

    }

    {
        unlike("\xB5", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        like("\xB6", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        unlike("\xB7", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        like("\xB5", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
        unlike("\xB6", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
        like("\xB7", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");

        unlike("_\xB5", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        like("_\xB6", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        unlike("_\xB7", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        like("_\xB5", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
        unlike("_\xB6", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
        like("_\xB7", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
    }

    # These are defined later, so won't be known at regex compile time above
    sub IsMyRuntimeProperty {
        return "B6\n";
    }

    sub IsntMyRuntimeProperty {
        return "!B6\n";
    }

    {   # [perl 121777]
        my $regex;
        { package Some;
            # define a Unicode propertyIs_q
            sub Is_q
            {
                sprintf '%x', ord 'q'
            }
            $regex = qr/\p{Is_q}/;

            # If we uncomment the following line, prior to the patch that
            # fixed this, everything would work because we would have expanded
            # the property by the time the regex in the 'like' below got
            # compiled.
            #'q' =~ $regex;
        }

        like('q', $regex, 'User-defined property matches outside package');

        package Some {
            main::like('abcq', qr/abc$regex/, 'Run-time compiled in-package user-defined property matches');
        }
    }

    {   # From Lingua::Stem::UniNE; no ticket filed but related to #121778
        use utf8;
        my $word = 'рабта';
        $word =~ s{ (?:
                          ия  # definite articles for nouns:
                        | ът  # ∙ masculine
                        | та  # ∙ feminine
                        | то  # ∙ neutral
                        | те  # ∙ plural
                    ) $ }{}x;
        is($word, 'раб', "Handles UTF8 trie correctly");
    }

    { # [perl #122460]
        my $a = "rdvark";
        $a =~ /(?{})(?=[A-Za-z0-9_])a*?/g;
        is (pos $a, 0, "optimizer correctly thinks (?=...) is 0-length");
    }

    {   # [perl #123417] multi-char \N{...} tripping roundly
        use Cname;
        my $qr = qr$(\N{foo})$;
        "afoot" =~ eval "qr/$qr/";
        is "$1" || $@@, "foo", 'multichar \N{...} stringified and retoked';
    }
    {   # empty \N{...} tripping roundly
        no warnings 'deprecated';
        BEGIN { $^H{charnames} = sub { "" } }
        my $qr = qr$(a\N{foo}t)$;
        "at" =~ eval "qr/$qr/";
        is "$1" || $@@, "at", 'empty \N{...} stringified and retoked';
    }

    is (scalar split(/\b{sb}/, "Don't think twice.  It's all right."),
        2, '\b{wb} splits sentences correctly');


    # !!! NOTE!  Keep the following tests last -- they may crash perl

    print "# Tests that follow may crash perl\n";
    {
        eval '/\k/';
        ok $@@ =~ /\QSequence \k... not terminated in regex;\E/,
           'Lone \k not allowed';
    }

    {
        my $message = "Substitution with lookahead (possible segv)";
        $_ = "ns1ns1ns1";
        s/ns(?=\d)/ns_/g;
        is($_, "ns_1ns_1ns_1", $message);
        $_ = "ns1";
        s/ns(?=\d)/ns_/;
        is($_, "ns_1", $message);
        $_ = "123";
        s/(?=\d+)|(?<=\d)/!Bang!/g;
        is($_, "!Bang!1!Bang!2!Bang!3!Bang!", $message);
    }

    { 
        # Earlier versions of Perl said this was fatal.
        my $message = "U+0FFFF shouldn't crash the regex engine";
        no warnings 'utf8';
        my $a = eval "chr(65535)";
        use warnings;
        my $warning_message;
        local $SIG{__WARN__} = sub { $warning_message = $_[0] };
        eval $a =~ /[a-z]/;
        ok(1, $message);  # If it didn't crash, it worked.
    }

    TODO: {   # Was looping
        todo_skip('Triggers thread clone SEGV. See #86550')
	  if $::running_as_thread && $::running_as_thread;
        watchdog(10);   # Use a bigger value for busy systems
        like("\x{00DF}", qr/[\x{1E9E}_]*/i, "\"\\x{00DF}\" =~ /[\\x{1E9E}_]*/i was looping");
    }

    {   # Bug #90536, caused failed assertion
        unlike("s\N{U+DF}", qr/^\x{00DF}/i, "\"s\\N{U+DF}\", qr/^\\x{00DF}/i");
    }

    # User-defined Unicode properties to match above-Unicode code points
    sub Is_32_Bit_Super { return "110000\tFFFFFFFF\n" }
    sub Is_Portable_Super { return '!utf8::Any' }   # Matches beyond 32 bits

    {   # Assertion was failing on on 64-bit platforms; just didn't work on 32.
        no warnings qw(non_unicode portable);
        no warnings 'deprecated'; # These are above IV_MAX
        use Config;

        # We use 'ok' instead of 'like' because the warnings are lexically
        # scoped, and want to turn them off, so have to do the match in this
        # scope.
        if ($Config{uvsize} < 8) {
            ok(chr(0xFFFF_FFFE) =~ /\p{Is_32_Bit_Super}/,
                            "chr(0xFFFF_FFFE) can match a Unicode property");
            ok(chr(0xFFFF_FFFF) =~ /\p{Is_32_Bit_Super}/,
                            "chr(0xFFFF_FFFF) can match a Unicode property");
            my $p = qr/^[\x{FFFF_FFFF}]$/;
            ok(chr(0xFFFF_FFFF) =~ $p,
                    "chr(0xFFFF_FFFF) can match itself in a [class]");
            ok(chr(0xFFFF_FFFF) =~ $p, # Tests any caching
                    "chr(0xFFFF_FFFF) can match itself in a [class] subsequently");
        }
        else {
            no warnings 'overflow';
            ok(chr(0xFFFF_FFFF_FFFF_FFFE) =~ qr/\p{Is_Portable_Super}/,
                    "chr(0xFFFF_FFFF_FFFF_FFFE) can match a Unicode property");
            ok(chr(0xFFFF_FFFF_FFFF_FFFF) =~ qr/^\p{Is_Portable_Super}$/,
                    "chr(0xFFFF_FFFF_FFFF_FFFF) can match a Unicode property");

            my $p = qr/^[\x{FFFF_FFFF_FFFF_FFFF}]$/;
            ok(chr(0xFFFF_FFFF_FFFF_FFFF) =~ $p,
                    "chr(0xFFFF_FFFF_FFFF_FFFF) can match itself in a [class]");
            ok(chr(0xFFFF_FFFF_FFFF_FFFF) =~ $p, # Tests any caching
                    "chr(0xFFFF_FFFF_FFFF_FFFF) can match itself in a [class] subsequently");

            # This test is because something was declared as 32 bits, but
            # should have been cast to 64; only a problem where
            # sizeof(STRLEN) != sizeof(UV)
            ok(chr(0xFFFF_FFFF_FFFF_FFFE) !~ qr/\p{Is_32_Bit_Super}/, "chr(0xFFFF_FFFF_FFFF_FFFE) shouldn't match a range ending in 0xFFFF_FFFF");
        }
    }

    { # [perl #112530], the code below caused a panic
        sub InFoo { "a\tb\n9\ta\n" }
        like(chr(0xA), qr/\p{InFoo}/,
                            "Overlapping ranges in user-defined properties");
    }

    { # [perl #125990], the final 2 tests below each caused a panic.
        # The \0's are not necessary; it could be a printable character
        # instead, but were in the ticket, so using them.
        my $sharp_s = chr utf8::unicode_to_native(0xdf);
        my $string        = ("\0" x 8)
                          . ($sharp_s x 3)
                          . ("\0" x 42)
                          .  "ý";
        my $folded_string = ("\0" x 8)
                          . ("ss" x 3)
                          . ("\0" x 42)
                          .  "ý";
        utf8::downgrade($string);
        utf8::downgrade($folded_string);

        like($string, qr/$string/i, "LATIN SMALL SHARP S matches itself under /id");
        unlike($folded_string, qr/$string/i, "LATIN SMALL SHARP S doesn't match 'ss' under /di");
        no warnings 'deprecated';
        like($folded_string, qr/\N{}$string/i, "\\N{} earlier than LATIN SMALL SHARP S transforms /di into /ui, matches 'ss'");
        like($folded_string, qr/$string\N{}/i, "\\N{} after LATIN SMALL SHARP S transforms /di into /ui, matches 'ss'");
    }

    { # Regexp:Grammars was broken:
  # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2013-06/msg01290.html
        fresh_perl_like('use warnings; "abc" =~ qr{(?&foo){0}abc(?<foo>)}',
                        qr/Quantifier unexpected on zero-length expression/,
                        {},
                        'No segfault on qr{(?&foo){0}abc(?<foo>)}');
    }

    SKIP:
    {   # [perl #125826] buffer overflow in TRIE_STORE_REVCHAR
        # (during compilation, so use a fresh perl)
        $Config{uvsize} == 8
	  or skip("need large code-points for this test", 1);

        # This is above IV_MAX on 32 bit machines, so turn off those warnings
	fresh_perl_is('no warnings "deprecated"; /\x{E000000000}|/ and print qq(ok\n)', "ok\n", {},
		      "buffer overflow in TRIE_STORE_REVCHAR");
    }

    {
        fresh_perl_like('use warnings; s 0(?(?!00000000000000000000000000·000000)\500000000 0000000000000000000000000000000000000000000000000000·00000000000000000000000000000000 0',
                        qr/Switch \(\?\(condition\)\.\.\. not terminated/,
                        {},
                        'No segfault [perl #126886]');
    }

    # !!! NOTE that tests that aren't at all likely to crash perl should go
    # a ways above, above these last ones.  There's a comment there that, like
    # this comment, contains the word 'NOTE'

    done_testing();
} # End of sub run_tests

1;
@


1.2
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d7 8
d18 1
a18 1

a23 8

BEGIN {
    chdir 't' if -d 't';
    @@INC = ('../lib','.');
    require './test.pl';
    skip_all_if_miniperl("miniperl can't load Tie::Hash::NamedCapture, need for %+ and %-");
}

a31 47
        my $message = '\C matches octet';
        $_ = "a\x{100}b";
        ok(/(.)(\C)(\C)(.)/, $message);
        is($1, "a", $message);
        if ($::IS_ASCII) {     # ASCII (or equivalent), should be UTF-8
            is($2, "\xC4", $message);
            is($3, "\x80", $message);
        }
        elsif ($::IS_EBCDIC) { # EBCDIC (or equivalent), should be UTF-EBCDIC
            is($2, "\x8C", $message);
            is($3, "\x41", $message);
        }
        else {
            SKIP: {
                ok 0, "Unexpected platform", "ord ('A') =" . ord 'A';
                skip "Unexpected platform";
            }
        }
        is($4, "b", $message);
    }

    {
        my $message = '\C matches octet';
        $_ = "\x{100}";
        ok(/(\C)/g, $message);
        if ($::IS_ASCII) {
            is($1, "\xC4", $message);
        }
        elsif ($::IS_EBCDIC) {
            is($1, "\x8C", $message);
        }
        else {
            ok 0, "Unexpected platform", "ord ('A') = " . ord 'A';
        }
        ok(/(\C)/g, $message);
        if ($::IS_ASCII) {
            is($1, "\x80", $message);
        }
        elsif ($::IS_EBCDIC) {
            is($1, "\x41", $message);
        }
        else {
            ok 0, "Unexpected platform", "ord ('A') = " . ord 'A';
        }
    }

    {
d67 2
a68 1
        my @@x = ("stra\337e 138", "stra\337e 138");
d72 2
a73 2
            is($latin, "stra\337e", $message);
	    ok($latin =~ s/stra\337e/straße/, $message);
a217 1
        skip "Not an ASCII platform", 2 unless $::IS_ASCII;
d221 2
d226 2
a239 16
        my $message = '. matches \n with /s';
        my $str1 = "foo\nbar";
        my $str2 = "foo\n\x{100}bar";
        my ($a, $b) = map {chr} $::IS_ASCII ? (0xc4, 0x80) : (0x8c, 0x41);
        my @@a;
        @@a = $str1 =~ /./g;   is(@@a, 6, $message); is("@@a", "f o o b a r", $message);
        @@a = $str1 =~ /./gs;  is(@@a, 7, $message); is("@@a", "f o o \n b a r", $message);
        @@a = $str1 =~ /\C/g;  is(@@a, 7, $message); is("@@a", "f o o \n b a r", $message);
        @@a = $str1 =~ /\C/gs; is(@@a, 7, $message); is("@@a", "f o o \n b a r", $message);
        @@a = $str2 =~ /./g;   is(@@a, 7, $message); is("@@a", "f o o \x{100} b a r", $message);
        @@a = $str2 =~ /./gs;  is(@@a, 8, $message); is("@@a", "f o o \n \x{100} b a r", $message);
        @@a = $str2 =~ /\C/g;  is(@@a, 9, $message); is("@@a", "f o o \n $a $b b a r", $message);
        @@a = $str2 =~ /\C/gs; is(@@a, 9, $message); is("@@a", "f o o \n $a $b b a r", $message);
    }

    {
a429 3
        $message = '\C and \X';
        like("!abc!", qr/a\Cc/, $message);
        like("!abc!", qr/a\Xc/, $message);
a484 4
        ok("Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Cais/ &&
            $& eq "Francais", $message);
        # COMBINING CEDILLA is two bytes when encoded
        like("Franc\N{COMBINING CEDILLA}ais", qr/Franc\C\Cais/, $message);
d565 4
a568 8
      SKIP: {
          skip "EBCDIC platform", 4 if $::IS_EBCDIC;
          # Do \x{0015} and \x{0041} match \s in EBCDIC?
          ok "<\x{100}\x{0085}>" =~ /<\x{100}\s>/, '\x{0085} in \s';
          ok        "<\x{0085}>" =~        /<\v>/, '\x{0085} in \v';
          ok "<\x{100}\x{00A0}>" =~ /<\x{100}\s>/, '\x{00A0} in \s';
          ok        "<\x{00A0}>" =~        /<\h>/, '\x{00A0} in \h';
        }
d789 1
d907 3
a909 3
    BEGIN {
        unshift @@INC, 'lib';
    }
d921 2
a922 3
        eval 'q(xxWxx) =~ /[\N{WARN}]/';
        ok $w && $w =~ /Using just the first character returned by \\N\{} in character class/,
                 "single character in [\\N{}] warning";
a952 5
        eval q [is("\N{TOO  MANY SPACES}", "TOO  MANY SPACES", "Multiple spaces in character name works")];
        like ($w, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... but returns a deprecation warning");
        undef $w;
        eval q [use utf8; is("\N{TOO  MANY SPACES}", "TOO  MANY SPACES", "Same under 'use utf8': they work")];
        like ($w, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... but return a deprecation warning");
a953 3
            # disable lexical warnings
            BEGIN { ${^WARNING_BITS} = undef; $^W = 0 }
            undef $w;
d955 1
a955 2
            like ($w, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... and returns a deprecation warning outside of lexical warnings");
            undef $w;
d957 1
a957 1
            like ($w, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... same under utf8");
d959 2
d962 4
a965 6
            no warnings 'deprecated';
            undef $w;
            eval q ["\N{TOO  MANY SPACES}"];
            ok (! defined $w, "... and no warning if warnings are off");
            eval q [use utf8; "\N{TOO  MANY SPACES}"];
            ok (! defined $w, "... same under 'use utf8'");
d967 12
a978 6
        {
            use warnings FATAL=> 'deprecated';
            () = eval q ["\N{TOO  MANY SPACES}"];
            like ($@@, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... the deprecation warning can be fatal");
            eval q [use utf8; () = "\N{TOO  MANY SPACES}"];
            like ($@@, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... same under utf8");
d982 9
a990 2
        eval q [is("\N{TRAILING SPACE }", "TRAILING SPACE ", "Trailing space in character name works")];
        like ($w, qr/Trailing white-space in a charnames alias definition is deprecated/, "... but returns a deprecation warning");
d992 5
a996 2
        eval q [use utf8; is("\N{TRAILING SPACE }", "TRAILING SPACE ", "Same under 'use utf8': they work")];
        like ($w, qr/Trailing white-space in a charnames alias definition is deprecated/, "... but returns a deprecation warning");
d1001 2
a1002 2
            () = eval q ["\N{TRAILING SPACE }"];
            like ($w, qr/Trailing white-space in a charnames alias definition is deprecated/, "... and returns a deprecation warning outside of lexical warnings");
d1004 3
a1006 2
            eval q [use utf8; () = "\N{TRAILING SPACE }"];
            like ($w, qr/Trailing white-space in a charnames alias definition is deprecated/, "... same under utf8");
d1011 1
a1011 1
            eval q ["\N{TRAILING SPACE }"];
d1013 2
a1014 1
            eval q [use utf8; "\N{TRAILING SPACE }"];
d1019 5
a1023 4
            () = eval q ["\N{TRAILING SPACE }"];
            like ($@@, qr/Trailing white-space in a charnames alias definition is deprecated/, "... the warning can be fatal");
            eval q [use utf8; () = "\N{TRAILING SPACE }"];
            like ($@@, qr/Trailing white-space in a charnames alias definition is deprecated/, "... same under utf8");
d1032 1
a1032 1
            like ($w, qr/A sequence of multiple spaces/,
a1039 2
        eval 'q(syntax error) =~ /\N{MALFORMED}/';
        ok $@@ && $@@ =~ /Malformed/, 'Verify that malformed utf8 gives an error';
d1044 1
a1044 1
        $name = "A\x{D7}O";
d1055 1
a1055 1
        $utf8_name = "A HOUSE \xF7 AGAINST ITSELF";
d1067 1
a1067 1
        $name = "A\x{D1}O";
d1145 2
a1146 2
            pack('U', 0x00F1),            # n-tilde
            '_'.pack('U', 0x00F1),        # _ + n-tilde
d1148 1
a1148 1
            pack('U*', 0x00F1, 0x0327),   # n-tilde + cedilla
d1191 1
d1201 1
a1201 1
            my $targ = "a\034$c";
d1293 1
a1293 1
        our $REGERROR;
d1312 1
d1330 1
a1330 1
        our $REGERROR;
d1400 2
a1401 1
        our ($REGMARK, $REGERROR);
d1473 21
a1493 21
        ok "\xC0" =~ /\p{XPosixUpper}/,  "\\xC0 =~ XPosixUpper";
        ok "\xC0" =~ /\p{XPosixUpper}/i,  "\\xC0 =~ XPosixUpper under /i";
        ok "\xC0" !~ /\p{XPosixLower}/,  "\\xC0 !~ XPosixLower";
        ok "\xC0" =~ /\p{XPosixLower}/i,  "\\xC0 =~ XPosixLower under /i";
        ok "\xE0" !~ /\p{XPosixUpper}/,  "\\xE0 !~ XPosixUpper";
        ok "\xE0" =~ /\p{XPosixUpper}/i,  "\\xE0 =~ XPosixUpper under /i";
        ok "\xE0" =~ /\p{XPosixLower}/,  "\\xE0 =~ XPosixLower";
        ok "\xE0" =~ /\p{XPosixLower}/i,  "\\xE0 =~ XPosixLower under /i";

        ok "\xC0" =~ /\p{UppercaseLetter}/,  "\\xC0 =~ UppercaseLetter";
        ok "\xC0" =~ /\p{UppercaseLetter}/i,  "\\xC0 =~ UppercaseLetter under /i";
        ok "\xC0" !~ /\p{LowercaseLetter}/,  "\\xC0 !~ LowercaseLetter";
        ok "\xC0" =~ /\p{LowercaseLetter}/i,  "\\xC0 =~ LowercaseLetter under /i";
        ok "\xC0" !~ /\p{TitlecaseLetter}/,  "\\xC0 !~ TitlecaseLetter";
        ok "\xC0" =~ /\p{TitlecaseLetter}/i,  "\\xC0 =~ TitlecaseLetter under /i";
        ok "\xE0" !~ /\p{UppercaseLetter}/,  "\\xE0 !~ UppercaseLetter";
        ok "\xE0" =~ /\p{UppercaseLetter}/i,  "\\xE0 =~ UppercaseLetter under /i";
        ok "\xE0" =~ /\p{LowercaseLetter}/,  "\\xE0 =~ LowercaseLetter";
        ok "\xE0" =~ /\p{LowercaseLetter}/i,  "\\xE0 =~ LowercaseLetter under /i";
        ok "\xE0" !~ /\p{TitlecaseLetter}/,  "\\xE0 !~ TitlecaseLetter";
        ok "\xE0" =~ /\p{TitlecaseLetter}/i,  "\\xE0 =~ TitlecaseLetter under /i";
d1567 2
a1568 1
        my @@h = map {chr $_}   0x09,   0x20,   0xa0, 0x1680, 0x2000,
d1572 2
a1573 1
        my @@v = map {chr $_}   0x0a,   0x0b,   0x0c,   0x0d,   0x85, 0x2028,
d1575 3
a1577 1
        my @@lb = ("\x0D\x0A", map {chr $_} 0x0A .. 0x0D, 0x85, 0x2028, 0x2029);
d1602 1
a1602 1
        my @@df = (chr (0xDF), '-', chr (0xDF));
d1604 1
a1604 1
        my @@strs = ('ss', 'sS', 'Ss', 'SS', chr (0xDF));
d1614 4
a1617 1
                (my $sstr = $str) =~ s/\xDF/\\xDF/;
d1622 2
a1623 1
                    ok $ret, "\"$sstr\" =~ /\\xDF/i " .
d1626 6
d1636 7
a1642 1
                    ok $ret, "\"$sstr\" !~ /\\xDF/i " .
d1645 1
d1668 2
a1669 2
        no warnings 'uninitialized', 'deprecated', 'experimental::lexical_topic';
        my $_ = "abcdef";
d1689 1
a1689 2
        no warnings 'deprecated', 'experimental::lexical_topic';
        my $_ = "aoeu \xe6var ook";
d1768 2
a1769 1
    for my $chr (160 .. 255) {
d1827 1
a1827 3
            no warnings 'deprecated';
            use encoding 'latin1';
            grep {/[[:punct:]]/ != /\p{IsPunct}/} map {chr} 0x80 .. 0xff;
d2143 2
a2144 1
        my $p = qr/[\xE0_]/i;
d2146 1
a2146 1
        like("\xC0", $p, "Verify \"\\xC0\" =~ /[\\xE0_]/i; pattern in utf8");
d2266 24
d2309 20
a2328 3
    #
    # Keep the following tests last -- they may crash perl
    #
d2378 1
d2383 1
a2383 1
        # scope
d2417 1
a2417 1
        like("\n", qr/\p{InFoo}/,
d2421 22
d2446 1
a2446 1
                        'Quantifier unexpected on zero-length expression',
d2451 18
d2470 2
a2471 1
    # a ways above, above these last ones.
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
# This is a home for regular expression tests that don't fit into
d20 2
a21 1
    do "re/ReTest.pl" or die $@@;
a23 3

plan tests => 1159;  # Update this when adding/deleting tests.

a30 1
  SKIP:
d32 1
a32 1
        local $Message = '\C matches octet';
d34 9
a42 9
        ok /(.)(\C)(\C)(.)/ or skip q [\C doesn't match], 4;
        iseq $1, "a";
        if ($IS_ASCII) {     # ASCII (or equivalent), should be UTF-8
            iseq $2, "\xC4";
            iseq $3, "\x80";
        }
        elsif ($IS_EBCDIC) { # EBCDIC (or equivalent), should be UTF-EBCDIC
            iseq $2, "\x8C";
            iseq $3, "\x41";
d46 1
a46 1
                ok 0, "Unexpected platform", "ord ('A') = $ordA";
d50 1
a50 1
        iseq $4, "b";
a52 2

  SKIP:
d54 1
a54 1
        local $Message = '\C matches octet';
d56 3
a58 3
        ok /(\C)/g or skip q [\C doesn't match], 2;
        if ($IS_ASCII) {
            iseq $1, "\xC4";
d60 2
a61 2
        elsif ($IS_EBCDIC) {
            iseq $1, "\x8C";
d64 1
a64 1
            ok 0, "Unexpected platform", "ord ('A') = $ordA";
d66 3
a68 3
        ok /(\C)/g or skip q [\C doesn't match];
        if ($IS_ASCII) {
            iseq $1, "\x80";
d70 2
a71 2
        elsif ($IS_EBCDIC) {
            iseq $1, "\x41";
d74 1
a74 1
            ok 0, "Unexpected platform", "ord ('A') = $ordA";
a77 1

d82 1
a82 1
        iseq $1, "abc", 'Changing subject does not modify $1';
a84 1

d92 1
d101 3
a103 2
        nok "\x8e" !~ /[i-j]/, '"\x8e" !~ /[i-j]/';
        nok "\xce" !~ /[I-J]/, '"\xce" !~ /[I-J]/';
a105 1

a110 1

d112 1
a112 1
        local $Message = 'bug id 20001008.001';
d116 4
a119 4
            ok s/(\d+)\s*([\w\-]+)/$1 . uc $2/e;
            ok my ($latin) = /^(.+)(?:\s+\d)/;
            iseq $latin, "stra\337e";
        ok $latin =~ s/stra\337e/straße/;
a128 1

d130 9
a138 9
        local $Message = 'Test \x escapes';
        ok "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
        ok "ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\xd4";
        ok "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
        ok "ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}";
        ok "ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4";
a140 2

  SKIP:
d142 1
a142 1
        local $Message = 'Match code points > 255';
d144 5
a148 5
        ok /(.\x{300})./ or skip "No match", 4;
        ok $` eq "abc\x{100}"            && length ($`) == 4;
        ok $& eq "\x{200}\x{300}\x{380}" && length ($&) == 3;
        ok $' eq "\x{400}defg"           && length ($') == 5;
        ok $1 eq "\x{200}\x{300}"        && length ($1) == 2;
a150 2


a156 1

d164 1
a164 1
      SKIP:
d166 1
a166 1
            local $Message = "Properties of \\x$code";
d168 4
a171 4
            my $i = 0;
            ok (($char =~ /[\x80-\xff]/)            xor !$$match [$i ++]);
            ok (($char =~ /[\x80-\x{100}]/)         xor !$$match [$i ++]);
            ok (($char =~ /[\x{100}]/)              xor !$$match [$i ++]);
a174 1

d177 4
a180 7
        local $Message;
        must_warn 'qr/(?c)/',    '^Useless \(\?c\)';
        must_warn 'qr/(?-c)/',   '^Useless \(\?-c\)';
        must_warn 'qr/(?g)/',    '^Useless \(\?g\)';
        must_warn 'qr/(?-g)/',   '^Useless \(\?-g\)';
        must_warn 'qr/(?o)/',    '^Useless \(\?o\)';
        must_warn 'qr/(?-o)/',   '^Useless \(\?-o\)';
d183 10
a192 6
        must_warn 'qr/(?g-o)/',  '^Useless \(\?g\).*\nUseless \(\?-o\)';
        must_warn 'qr/(?g-c)/',  '^Useless \(\?g\).*\nUseless \(\?-c\)';
        # (?c) means (?g) error won't be thrown
        must_warn 'qr/(?o-cg)/', '^Useless \(\?o\).*\nUseless \(\?-c\)';
        must_warn 'qr/(?ogc)/',  '^Useless \(\?o\).*\nUseless \(\?g\).*\n' .
                                  'Useless \(\?c\)';
a194 1

d196 1
a196 1
        local $Message = "/x tests";
d198 1
a198 1
        eval_ok <<"        --";
a204 1
        eval_ok <<"        --";
d211 3
a215 1

d217 1
a217 1
        local $Message = "/o feature";
d219 2
a220 2
        iseq test_o ('abc', '(.)..'), 'a';
        iseq test_o ('abc', '..(.)'), 'a';
d225 1
a225 1
        local $Message = '$^N usage outside of a regex';
d227 15
a241 15
        ok ($x =~ /cde/                  and !defined $^N);
        ok ($x =~ /(cde)/                and $^N eq "cde");
        ok ($x =~ /(c)(d)(e)/            and $^N eq   "e");
        ok ($x =~ /(c(d)e)/              and $^N eq "cde");
        ok ($x =~ /(foo)|(c(d)e)/        and $^N eq "cde");
        ok ($x =~ /(c(d)e)|(foo)/        and $^N eq "cde");
        ok ($x =~ /(c(d)e)|(abc)/        and $^N eq "abc");
        ok ($x =~ /(c(d)e)|(abc)x/       and $^N eq "cde");
        ok ($x =~ /(c(d)e)(abc)?/        and $^N eq "cde");
        ok ($x =~ /(?:c(d)e)/            and $^N eq   "d");
        ok ($x =~ /(?:c(d)e)(?:f)/       and $^N eq   "d");
        ok ($x =~ /(?:([abc])|([def]))*/ and $^N eq   "f");
        ok ($x =~ /(?:([ace])|([bdf]))*/ and $^N eq   "f");
        ok ($x =~ /(([ace])|([bd]))*/    and $^N eq   "e");
       {ok ($x =~ /(([ace])|([bdf]))*/   and $^N eq   "f");}
d244 1
a244 1
        iseq $^N, "e", '$^N is automatically localized';
d247 1
a247 1
        local $Message = '$^N usage inside (?{ ... })';
d249 7
a255 7
        ok ($x =~ /a([abc])(?{$y=$^N})c/                    and $y eq  "b");
        ok ($x =~ /a([abc]+)(?{$y=$^N})d/                   and $y eq  "bc");
        ok ($x =~ /a([abcdefg]+)(?{$y=$^N})d/               and $y eq  "bc");
        ok ($x =~ /(a([abcdefg]+)(?{$y=$^N})d)(?{$z=$^N})e/ and $y eq  "bc"
                                                            and $z eq "abcd");
        ok ($x =~ /(a([abcdefg]+)(?{$y=$^N})de)(?{$z=$^N})/ and $y eq  "bc"
                                                            and $z eq "abcde");
a258 1

d264 2
a265 2
        skip "Not an ASCII platform", 2 unless $IS_ASCII;
        local $Message = 'Test [[:cntrl:]]';
d268 1
a268 1
        iseq $x, join "", map {chr} 0x20 .. 0x7E, 0x80 .. 0xFF;
d271 1
a271 1
        iseq $x, join "", map {chr} 0x00 .. 0x1F, 0x7F;
a273 1

d276 1
a276 1
        local $Message = "UTF-8 chars aren't bytes";
d279 1
a279 1
        iseq $#a, 12;
a281 1

d283 1
a283 1
        local $Message = '. matches \n with /s';
d286 1
a286 1
        my ($a, $b) = map {chr} $IS_ASCII ? (0xc4, 0x80) : (0x8c, 0x41);
d288 8
a295 8
        @@a = $str1 =~ /./g;   iseq @@a, 6; iseq "@@a", "f o o b a r";
        @@a = $str1 =~ /./gs;  iseq @@a, 7; iseq "@@a", "f o o \n b a r";
        @@a = $str1 =~ /\C/g;  iseq @@a, 7; iseq "@@a", "f o o \n b a r";
        @@a = $str1 =~ /\C/gs; iseq @@a, 7; iseq "@@a", "f o o \n b a r";
        @@a = $str2 =~ /./g;   iseq @@a, 7; iseq "@@a", "f o o \x{100} b a r";
        @@a = $str2 =~ /./gs;  iseq @@a, 8; iseq "@@a", "f o o \n \x{100} b a r";
        @@a = $str2 =~ /\C/g;  iseq @@a, 9; iseq "@@a", "f o o \n $a $b b a r";
        @@a = $str2 =~ /\C/gs; iseq @@a, 9; iseq "@@a", "f o o \n $a $b b a r";
a297 1

a392 1

a398 1

a405 1

d407 21
a427 21
        local $Message = "Folding matches and Unicode";
        ok "a\x{100}" =~ /A/i;
        ok "A\x{100}" =~ /a/i;
        ok "a\x{100}" =~ /a/i;
        ok "A\x{100}" =~ /A/i;
        ok "\x{101}a" =~ /\x{100}/i;
        ok "\x{100}a" =~ /\x{100}/i;
        ok "\x{101}a" =~ /\x{101}/i;
        ok "\x{100}a" =~ /\x{101}/i;
        ok "a\x{100}" =~ /A\x{100}/i;
        ok "A\x{100}" =~ /a\x{100}/i;
        ok "a\x{100}" =~ /a\x{100}/i;
        ok "A\x{100}" =~ /A\x{100}/i;
        ok "a\x{100}" =~ /[A]/i;
        ok "A\x{100}" =~ /[a]/i;
        ok "a\x{100}" =~ /[a]/i;
        ok "A\x{100}" =~ /[A]/i;
        ok "\x{101}a" =~ /[\x{100}]/i;
        ok "\x{100}a" =~ /[\x{100}]/i;
        ok "\x{101}a" =~ /[\x{101}]/i;
        ok "\x{100}a" =~ /[\x{101}]/i;
a429 1

d432 1
a432 1
        local $Message = "Folding 'LATIN LETTER A WITH GRAVE'";
d437 4
a440 4
        ok $lower =~ m/$UPPER/i;
        ok $UPPER =~ m/$lower/i;
        ok $lower =~ m/[$UPPER]/i;
        ok $UPPER =~ m/[$lower]/i;
d442 1
a442 1
        local $Message = "Folding 'GREEK LETTER ALPHA WITH VRACHY'";
d447 4
a450 4
        ok $lower =~ m/$UPPER/i;
        ok $UPPER =~ m/$lower/i;
        ok $lower =~ m/[$UPPER]/i;
        ok $UPPER =~ m/[$lower]/i;
d452 1
a452 1
        local $Message = "Folding 'LATIN LETTER Y WITH DIAERESIS'";
d457 4
a460 4
        ok $lower =~ m/$UPPER/i;
        ok $UPPER =~ m/$lower/i;
        ok $lower =~ m/[$UPPER]/i;
        ok $UPPER =~ m/[$lower]/i;
a462 1

d465 1
a465 2
        local $PatchId = "13843";
        local $Message = "GREEK CAPITAL LETTER SIGMA vs " .
d471 2
a472 1
        may_not_warn sub {ok "_:$char:_" !~ m/_:$SIGMA:_/i};
a474 1

d476 1
a476 1
        local $Message = '\X';
d479 7
a485 7
        ok "a!"                          =~ /^(\X)!/ && $1 eq "a";
        ok "\xDF!"                       =~ /^(\X)!/ && $1 eq "\xDF";
        ok "\x{100}!"                    =~ /^(\X)!/ && $1 eq "\x{100}";
        ok "\x{100}\x{300}!"             =~ /^(\X)!/ && $1 eq "\x{100}\x{300}";
        ok "\N{LATIN CAPITAL LETTER E}!" =~ /^(\X)!/ &&
               $1 eq "\N{LATIN CAPITAL LETTER E}";
        ok "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}!"
d487 1
a487 1
               $1 eq "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}";
d489 3
a491 3
        local $Message = '\C and \X';
        ok "!abc!" =~ /a\Cc/;
        ok "!abc!" =~ /a\Xc/;
a493 1

d495 1
a495 1
        local $Message = "Final Sigma";
d501 23
a523 23
        ok $SIGMA =~ /$SIGMA/i;
        ok $SIGMA =~ /$Sigma/i;
        ok $SIGMA =~ /$sigma/i;

        ok $Sigma =~ /$SIGMA/i;
        ok $Sigma =~ /$Sigma/i;
        ok $Sigma =~ /$sigma/i;

        ok $sigma =~ /$SIGMA/i;
        ok $sigma =~ /$Sigma/i;
        ok $sigma =~ /$sigma/i;

        ok $SIGMA =~ /[$SIGMA]/i;
        ok $SIGMA =~ /[$Sigma]/i;
        ok $SIGMA =~ /[$sigma]/i;

        ok $Sigma =~ /[$SIGMA]/i;
        ok $Sigma =~ /[$Sigma]/i;
        ok $Sigma =~ /[$sigma]/i;

        ok $sigma =~ /[$SIGMA]/i;
        ok $sigma =~ /[$Sigma]/i;
        ok $sigma =~ /[$sigma]/i;
d525 1
a525 1
        local $Message = "More final Sigma";
d529 7
a535 7
        ok ":$S3:" =~ /:(($SIGMA)+):/i   && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(($Sigma)+):/i   && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(($sigma)+):/i   && $1 eq $S3 && $2 eq $sigma;

        ok ":$S3:" =~ /:(([$SIGMA])+):/i && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(([$Sigma])+):/i && $1 eq $S3 && $2 eq $sigma;
        ok ":$S3:" =~ /:(([$sigma])+):/i && $1 eq $S3 && $2 eq $sigma;
a537 1

d540 1
a540 1
        local $Message = "Parlez-Vous " .
d543 6
a548 6
        ok "Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran.ais/ &&
            $& eq "Francais";
        ok "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran.ais/ &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais";
        ok "Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Cais/ &&
            $& eq "Francais";
d550 8
a557 8
        ok "Franc\N{COMBINING CEDILLA}ais" =~ /Franc\C\Cais/;
        ok "Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Xais/ &&
            $& eq "Francais";
        ok "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran\Xais/  &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais";
        ok "Franc\N{COMBINING CEDILLA}ais" =~ /Fran\Xais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais";
        ok "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
d559 3
a561 3
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais";
        ok "Franc\N{COMBINING CEDILLA}ais" =~ /Franc\N{COMBINING CEDILLA}ais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais";
d571 1
a571 1
            ok $subject =~ /Fran(?:c\N{COMBINING CEDILLA}?|
d573 1
a573 1
               $& eq $match;
a576 1

d578 1
a578 1
        local $Message = "Lingering (and useless) UTF8 flag doesn't mess up /i";
d582 1
a582 1
        ok $str =~ /$pat/i;
d587 1
a587 1
        ok $str =~ /$pat/i;
d593 1
a593 1
        ok $str =~ /$pat/i;
a595 1

d598 1
a598 1
        local $Message = "LATIN SMALL LETTER SHARP S " .
d601 24
a624 24
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                            /\N{LATIN SMALL LETTER SHARP S}/;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                            /\N{LATIN SMALL LETTER SHARP S}/i;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                           /[\N{LATIN SMALL LETTER SHARP S}]/;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
                                           /[\N{LATIN SMALL LETTER SHARP S}]/i;

        ok "ss" =~  /\N{LATIN SMALL LETTER SHARP S}/i;
        ok "SS" =~  /\N{LATIN SMALL LETTER SHARP S}/i;
        ok "ss" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i;
        ok "SS" =~ /[\N{LATIN SMALL LETTER SHARP S}]/i;

        ok "\N{LATIN SMALL LETTER SHARP S}" =~ /ss/i;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~ /SS/i;

        local $Message = "Unoptimized named sequence in class";
        ok "ss" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i;
        ok "SS" =~ /[\N{LATIN SMALL LETTER SHARP S}x]/i;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
          /[\N{LATIN SMALL LETTER SHARP S}x]/;
        ok "\N{LATIN SMALL LETTER SHARP S}" =~
          /[\N{LATIN SMALL LETTER SHARP S}x]/i;
a626 1

d632 1
a632 1
          skip "EBCDIC platform", 4 if $IS_EBCDIC;
d639 1
a639 1
        my @@h = map {sprintf "%05x" => $_} 0x01680, 0x0180E, 0x02000 .. 0x0200A,
d644 1
a644 1
                                           0x0303F,   0xE0020;
d646 1
a646 1
                                           0xE005F,   0xE007C;
a674 1

d677 1
a677 1
        local $Message = ". with /s works on characters, not bytes";
d682 2
a683 1
        may_not_warn sub {$s =~ /\G(.+?)\n/gcs}, "No 'Malformed UTF-8' warning";
d689 1
a689 1
        iseq "@@c", $s;
d705 1
a705 1
        iseq $r1, $r2;
a707 1

d709 5
a713 5
        local $Message = "Unicode lookbehind";
        ok "A\x{100}B"        =~ /(?<=A.)B/;
        ok "A\x{200}\x{300}B" =~ /(?<=A..)B/;
        ok "\x{400}AB"        =~ /(?<=\x{400}.)B/;
        ok "\x{500}\x{600}B"  =~ /(?<=\x{500}.)B/;
a719 1

d721 1
a721 1
        local $Message = 'UTF-8 hash keys and /$/';
d732 1
a732 1
            iseq $m1, $m2;
a735 1

d737 1
a737 1
        local $Message = "No SEGV in s/// and UTF-8";
d739 1
a739 1
        ok $s =~ s/[^\w]/ /g;
d741 1
a741 1
            iseq $s, "s \x{100}" x 4;
d744 1
a744 1
            iseq $s, "s  " x 4;
a747 1

d749 1
a749 1
        local $Message = "UTF-8 bug (maybe already known?)";
d752 1
a752 1
        iseq $u, "\x{100}\x{100}\x{100}";
d756 1
a756 1
        iseq $u, "f\x{100}\x{100}b\x{100}r";
d759 1
a759 1
        iseq $u, "feeber";
a761 1

d763 1
a763 1
        local $Message = "UTF-8 bug with s///";
d771 2
a772 2
            ok "xxx" !~ /$re/;
            ok +($subst = "xxx") !~ s/$re//;
d775 3
a777 3
            ok "xxx" =~ /$re/;
            ok +($subst = "xxx") =~ s/$re//;
            iseq $subst, "";
d780 5
a784 5
            ok "xx$c" =~ /$re/;
            ok +($subst = "xx$c") =~ s/$re//;
            iseq $subst, $c;
            ok "xy$c" !~ /$re/;
            ok +($subst = "xy$c") !~ s/$re//;
d787 3
a789 3
            ok "xyz" =~ /$re/;
            ok +($subst = "xyz") =~ s/$re//;
            iseq $subst, "";
d793 5
d800 1
a800 1
        local $Message = "qr /.../x";
d802 5
a806 5
        ok "ABCDE" =~    $R   && $& eq "ABC";
        ok "ABCDE" =~   /$R/  && $& eq "ABC";
        ok "ABCDE" =~  m/$R/  && $& eq "ABC";
        ok "ABCDE" =~  /($R)/ && $1 eq "ABC";
        ok "ABCDE" =~ m/($R)/ && $1 eq "ABC";
a808 3



a818 3



d826 1
a826 1
        local $Message = 'Markus Kuhn 2003-02-26';
d829 2
a830 2
        ok $x =~ s/(\S)\n(\S)/$1 $2/sg;
        ok $x eq "\x{2019} k";
d833 2
a834 2
        ok $x =~ s/(\S)\n(\S)/$1 $2/sg;
        ok $x eq "b k";
d836 1
a836 1
        ok "\x{2019}" =~ /\S/;
a838 11

    {
        # XXX DAPM 13-Apr-06. Recursive split is still broken. It's only luck it
        # hasn't been crashing. Disable this test until it is fixed properly.
        # XXX also check what it returns rather than just doing ok(1,...)
        # split /(?{ split "" })/, "abc";
        local $TODO = "Recursive split is still broken";
        ok 0, 'cache_re & "(?{": it dumps core in 5.6.1 & 5.8.0';
    }


a842 1

d857 3
d868 1
a868 1
        local $Message = '<20030808193656.5109.1@@llama.ni-s.u-net.com>';
d871 1
a871 1
        ok "  \x{101}" =~ qr/\x{100}/i;
d874 1
a874 1
        ok "  \x{1E01}" =~ qr/\x{1E00}/i;
d877 1
a877 1
        ok "  \x{10428}" =~ qr/\x{10400}/i;
d880 1
a880 1
        ok "  \x{1E01}x" =~ qr/\x{1E00}X/i;
d884 1
a884 1
        for (120 .. 130) {
d886 2
a887 2
            local $Message = q [Don't misparse \x{...} in regexp ] .
                             q [near 127 char EXACT limit];
d889 2
a890 1
                eval_ok qq ["$head$tail" =~ /$head$tail/];
d892 2
a893 2
            local $Message = q [Don't misparse \N{...} in regexp ] .
                             q [near 127 char EXACT limit];
d895 3
a897 2
                eval_ok qq [use charnames ':full';
                           "$head$tail" =~ /$head$tail/];
d905 1
a905 1
        iseq @@got, 1, "TRIE optimation";
d909 1
a909 1
        iseq @@got, 1,"TRIEF optimisation";
a931 1

a974 3



d982 3
d991 1
a991 1
        ok $w && $w =~ /Using just the first character returned by \\N{} in character class/,
d996 11
a1006 1
                   "Zerolength charname in charclass doesn't match \\0"];
d1019 3
a1021 2
        # If remove the limitation in regcomp code these should work
        # differently
d1023 2
a1024 2
        eval q [ok "\N{LONG-STR}" =~ /^\N{TOO-LONG-STR}$/, 'Verify that too long a string fails gracefully'];
        ok $w && $w =~ /Using just the first characters returned/, 'Verify that got too-long string warning in \N{} that exceeds the limit';
d1026 28
a1053 2
        eval q [ok "\N{LONG-STR}" =~ /^\N{TOO-LONG-STR}$/i, 'Verify under folding that too long a string fails gracefully'];
        ok $w && $w =~ /Using just the first characters returned/, 'Verify under folding that got too-long string warning in \N{} that exceeds the limit';
d1055 2
a1056 2
        eval q [ok "\N{TOO-LONG-STR}" !~ /^\N{TOO-LONG-STR}$/, 'Verify that too long a string doesnt work'];
        ok $w && $w =~ /Using just the first characters returned/, 'Verify that got too-long string warning in \N{} that exceeds the limit';
d1058 40
a1097 2
        eval q [ok "\N{TOO-LONG-STR}" !~ /^\N{TOO-LONG-STR}$/i, 'Verify under folding that too long a string doesnt work'];
        ok $w && $w =~ /Using just the first characters returned/i, 'Verify under folding that got too-long string warning in \N{} that exceeds the limit';
d1099 1
a1101 1
        undef $w;
d1103 1
a1103 2
        ok $w && $w =~ /Deprecated/, 'Verify that leading digit in name gives warning';
        undef $w;
d1105 2
a1106 3
        ok $w && $w =~ /Deprecated/, 'Verify that comma in name gives warning';
        undef $w;
        my $name = "A\x{D7}O";
d1108 20
a1127 1
        ok $w && $w =~ /Deprecated/, 'Verify that latin1 symbol in name gives warning';
d1133 8
a1142 1

a1159 1

d1184 1
a1184 1
            iseq @@stack, @@expect, "Right amount of matches"
d1189 2
a1190 2
                iseq $stack [$idx], $expect,
                    "Expecting '$expect' at stack pos #$idx";
a1195 1

a1204 1

d1243 1
a1243 1
        iseq "@@res", "@@expect", "Check %-";
d1271 1
a1271 1
        iseq $count, 9, "Expect 9 for no (*PRUNE)";
d1274 1
a1274 1
        iseq $count, 3, "Expect 3 with (*PRUNE)";
d1278 1
a1278 1
        iseq $count, 4, "/.(*PRUNE)/";
d1281 1
a1281 1
        iseq $count, 3, "Expect 3 with (*PRUNE)";
d1285 1
a1285 1
        iseq $count, 4, "/.(*PRUNE)/";
a1287 1

d1291 1
a1291 1
        iseq $count, 1, "Expect 1 with (*SKIP)";
d1295 1
a1295 1
        iseq $count, 4, "/.(*SKIP)/";
d1300 2
a1301 2
        iseq $count, 2, "Expect 2 with (*SKIP)";
        iseq "@@res", "aaab aaab", "Adjacent (*SKIP) works as expected";
a1303 1

d1307 1
a1307 1
        iseq $count, 1, "Expect 1 with (*SKIP)";
d1311 1
a1311 1
        iseq $count, 4, "/.(*SKIP)/";
d1316 2
a1317 2
        iseq $count, 2, "Expect 2 with (*SKIP)";
        iseq "@@res", "aaab aaab", "Adjacent (*SKIP) works as expected";
a1319 1

d1323 1
a1323 1
        iseq $count, 3, "Expect 3 with *MARK:a)b?(*MARK:b)(*SKIP:a)";
d1329 3
a1331 3
        iseq $count, 5, "Expect 5 with (*MARK:a)b?)(*MARK:x)(*SKIP:a)";
        iseq "@@res", "aaab b aaab b ",
             "Adjacent (*MARK:a)b?)(*MARK:x)(*SKIP:a) works as expected";
a1333 1

d1337 1
a1337 1
        iseq $count, 1, "Expect 1 with (*COMMIT)";
d1341 1
a1341 1
        iseq $count, 1, "/.(*COMMIT)/";
d1346 4
a1349 2
        iseq $count, 1, "Expect 1 with (*COMMIT)";
        iseq "@@res", "aaab", "Adjacent (*COMMIT) works as expected";
a1351 1

d1361 1
a1361 1
                    iseq $REGERROR,
d1363 1
a1363 1
                        "Test $pat and \$REGERROR $suffix";
a1368 1

d1379 1
a1379 1
                  ::iseq $REGERROR,
d1381 1
a1381 1
                        "Test $pat and \$REGERROR $suffix";
a1386 1

d1389 1
a1389 1
        local $Message = '$REGERROR';
d1395 1
a1395 1
            iseq $REGERROR, $word;
a1405 1

d1407 1
a1407 1
        local $Message = "Relative Recursion";
d1411 5
a1415 5
        ok m/foo $parens \s* \+ \s* bar $parens/x;
        iseq $1, '((2*3)+4-3)';
        iseq $2, '(2*(3+4)-1*(2-3))';
        iseq $&, 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))';
        iseq $&, $_;
d1423 2
a1424 2
        iseq $_, $spaces, "SUSPEND final string";
        iseq $count, 1, "Optimiser should have prevented more than one match";
a1426 1

d1435 1
a1435 1
        iseq $dow_name, $time_string, "UTF-8 trie common prefix extraction";
a1437 1

d1442 2
a1443 2
        iseq "$1", 'bar', '$1 is safe after /g - may fail due ' .
                          'to specialized config in pp_hot.c'
a1445 1

d1447 1
a1447 1
        local $Message = "http://nntp.perl.org/group/perl.perl5.porters/118663";
d1449 6
a1454 6
        ok "foobarbarxyz" =~ $qr_barR1;
        ok "foobarbarxyz" =~ qr/foo${qr_barR1}xyz/;
        ok "foobarbarxyz" =~ qr/(foo)${qr_barR1}xyz/;
        ok "foobarbarxyz" =~ qr/(foo)(bar)\g{-1}xyz/;
        ok "foobarbarxyz" =~ qr/(foo${qr_barR1})xyz/;
        ok "foobarbarxyz" =~ qr/(foo(bar)\g{-1})xyz/;
d1458 1
a1458 1
        local $Message = '$REGMARK';
d1461 6
a1466 6
        ok 'foofoo' =~ /foo (*MARK:foo) (?{push @@r,$REGMARK}) /x;
        iseq "@@r","foo";
        iseq $REGMARK, "foo";
        ok 'foofoo' !~ /foo (*MARK:foo) (*FAIL) /x;
        ok !$REGMARK;
        iseq $REGERROR, 'foo';
a1468 1

d1470 1
a1470 1
        local $Message = '\K test';
d1474 1
a1474 1
        iseq $x, "abc.def.ghi";
d1478 1
a1478 1
        iseq $x, "one two  four";
d1482 1
a1482 1
        iseq $x, "aabbccddee";
a1484 1

d1494 2
a1495 2
        iseq join ("-", @@res), "0902862349",
            'PL_curpm is set properly on nested eval';
a1500 1

d1510 5
d1520 40
a1571 1

d1578 2
a1579 2
        iseq $res, "1",
            "Check that (?|...) doesnt cause dupe entries in the names array";
d1585 2
a1586 2
        iseq $res, "1", "Check that (?&..) to a buffer inside " .
                        "a (?|...) goes to the leftmost";
a1588 1

d1591 1
a1591 1
        local $Message = "ASCII pattern that really is UTF-8";
d1595 2
a1596 2
        ok $c =~ /${c}|\x{100}/;
        ok @@w == 0;
a1598 1

d1600 1
a1600 1
        local $Message = "Corruption of match results of qr// across scopes";
d1603 1
a1603 1
        iseq "$1$2", "foobar";
d1606 1
a1606 1
            iseq "$1$2", 'foooooobaaaaar';
d1608 1
a1608 1
        iseq "$1$2", "foobar";
a1610 1

d1612 1
a1612 1
        local $Message = "HORIZWS";
d1616 1
a1616 1
        iseq $_, "hhHHhHhhHH";
d1621 1
a1621 1
        iseq $_, "hhHHhHhhHH";
a1623 1

d1625 2
a1626 2
        local $Message = "Various whitespace special patterns";
        my @@h = map {chr $_}   0x09,   0x20,   0xa0, 0x1680, 0x180e, 0x2000,
d1639 5
a1643 2
                    ok $str =~ /($pat)/, $pat;
                    iseq $1, $str, $pat;
d1645 2
a1646 2
                    ok $str =~ /($pat)/, "Upgraded string - $pat";
                    iseq $1, $str, "Upgraded string - $pat";
a1651 1

d1653 1
a1653 1
        local $Message = "Check that \\xDF match properly in its various forms";
a1688 1

d1690 1
a1690 1
        local $Message = "BBC(Bleadperl Breaks CPAN) Today: String::Multibyte";
d1698 1
a1698 1
        iseq @@a,3;
d1700 1
a1700 1
        iseq "@@a","$esc$hyp=$hyp=$esc$esc";
a1702 1

d1705 2
a1706 2
        local $Message = 'Test keys in %+ and %-';
        no warnings 'uninitialized';
d1709 4
a1712 4
        iseq ((join ",", sort keys %+), "foo");
        iseq ((join ",", sort keys %-), "foo");
        iseq ((join ",", sort values %+), "a");
        iseq ((join ",", sort map "@@$_", values %-), "a ");
d1714 4
a1717 4
        iseq ((join ",", sort keys %+), "bar,quux");
        iseq ((join ",", sort keys %-), "bar,quux");
        iseq ((join ",", sort values %+), "a,c"); # leftmost
        iseq ((join ",", sort map "@@$_", values %-), "a b,c");
d1719 4
a1722 4
        iseq ((join ",", sort keys %+), "un");
        iseq ((join ",", sort keys %-), "deux,un");
        iseq ((join ",", sort values %+), "a");
        iseq ((join ",", sort map "@@$_", values %-), ",a");
a1724 1

d1727 1
d1731 5
a1735 5
        iseq length ($`),      0, q[length $`];
        iseq length ($'),      4, q[length $'];
        iseq length ($&),      9, q[length $&];
        iseq length ($1),      4, q[length $1];
        iseq length ($+{eek}), 4, q[length $+{eek} == length $1];
a1737 1

d1742 3
a1744 3
        iseq $ok, 1, '$-{x} exists after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/';
d1748 3
a1750 3
        iseq $ok, 0, '$+{x} not exists after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/';
        iseq scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/';
d1754 3
a1756 3
        iseq $ok, 1, '$-{x} exists after "foo"=~/(?<x>foo)|bar/';
        iseq scalar (%+), 1, 'scalar %+ == 1 after "foo"=~/(?<x>foo)|bar/';
        iseq scalar (%-), 1, 'scalar %- == 1 after "foo"=~/(?<x>foo)|bar/';
d1760 1
a1760 1
        iseq $ok, 1, '$+{x} exists after "foo"=~/(?<x>foo)|bar/';
a1762 1

d1767 16
a1782 1
        iseq "$1", 'abc', "/g leads to unsafe match vars: $1";
a1784 1

d1786 1
a1786 1
        local $Message = 'Message-ID: <20070818091501.7eff4831@@r2d2>';
d1794 1
a1794 1
        iseq length ($str), 0, "Trie scope error, string should be empty";
d1802 1
a1802 1
        iseq length ($str), 0, "Trie scope error, string should be empty";
a1804 1

d1818 1
a1818 1
        iseq $b, $a, "Copy of scalar used for postponed subexpression";
a1820 1

d1839 2
a1840 2
        iseq "@@ctl_n", "bla blubb", '$^N inside of (?{}) works as expected';
        iseq "@@plus",  "bla blubb", '$+  inside of (?{}) works as expected';
a1842 1

d1847 1
a1847 1
        skip "Tests assume ASCII", 4 unless $IS_ASCII;
d1851 2
a1852 2
        iseq join ('', @@notIsPunct), '$+<=>^`|~',
            '[:punct:] disagress with IsPunct on Symbols';
d1856 2
a1857 2
        iseq join ('', @@isPrint), "",
            'IsPrint agrees with [:print:] on control characters';
d1861 2
a1862 2
        iseq join ('', @@isPunct), "\xa1\xab\xb7\xbb\xbf",    # ¡ « · » ¿
            'IsPunct disagrees with [:punct:] outside ASCII';
d1865 1
d1872 450
a2321 2
        iseq join ('', @@isPunctLatin1), '',
            'IsPunct agrees with [:punct:] with explicit Latin1';
d2335 1
a2335 1
        local $Message = "Substitution with lookahead (possible segv)";
d2338 1
a2338 1
        iseq $_, "ns_1ns_1ns_1";
d2341 1
a2341 1
        iseq $_, "ns_1";
d2344 1
a2344 1
        iseq $_, "!Bang!1!Bang!2!Bang!3!Bang!";
d2349 1
a2349 1
        local $Message = "U+0FFFF shouldn't crash the regex engine";
d2356 54
a2409 1
        ok(1);  # If it didn't crash, it worked.
d2411 19
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d20 1
a20 2
    require './test.pl';
    skip_all_if_miniperl("miniperl can't load Tie::Hash::NamedCapture, need for %+ and %-");
d23 3
d33 1
d35 1
a35 1
        my $message = '\C matches octet';
d37 9
a45 9
        ok(/(.)(\C)(\C)(.)/, $message);
        is($1, "a", $message);
        if ($::IS_ASCII) {     # ASCII (or equivalent), should be UTF-8
            is($2, "\xC4", $message);
            is($3, "\x80", $message);
        }
        elsif ($::IS_EBCDIC) { # EBCDIC (or equivalent), should be UTF-EBCDIC
            is($2, "\x8C", $message);
            is($3, "\x41", $message);
d49 1
a49 1
                ok 0, "Unexpected platform", "ord ('A') =" . ord 'A';
d53 1
a53 1
        is($4, "b", $message);
d56 2
d59 1
a59 1
        my $message = '\C matches octet';
d61 3
a63 3
        ok(/(\C)/g, $message);
        if ($::IS_ASCII) {
            is($1, "\xC4", $message);
d65 2
a66 2
        elsif ($::IS_EBCDIC) {
            is($1, "\x8C", $message);
d69 1
a69 1
            ok 0, "Unexpected platform", "ord ('A') = " . ord 'A';
d71 3
a73 3
        ok(/(\C)/g, $message);
        if ($::IS_ASCII) {
            is($1, "\x80", $message);
d75 2
a76 2
        elsif ($::IS_EBCDIC) {
            is($1, "\x41", $message);
d79 1
a79 1
            ok 0, "Unexpected platform", "ord ('A') = " . ord 'A';
d83 1
d88 1
a88 1
        is($1, "abc", 'Changing subject does not modify $1');
d91 1
d107 2
a108 2
        unlike("\x8e", qr/[i-j]/, '"\x8e" !~ /[i-j]/');
        unlike("\xce", qr/[I-J]/, '"\xce" !~ /[I-J]/');
d111 1
d117 1
d119 1
a119 1
        my $message = 'bug id 20001008.001';
d123 4
a126 4
            ok(s/(\d+)\s*([\w\-]+)/$1 . uc $2/e, $message);
            ok(my ($latin) = /^(.+)(?:\s+\d)/, $message);
            is($latin, "stra\337e", $message);
	    ok($latin =~ s/stra\337e/straße/, $message);
d136 1
d138 9
a146 9
        my $message = 'Test \x escapes';
        ok("ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\xd4", $message);
        ok("ba\xd4c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}", $message);
        ok("ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\x{d4}", $message);
        ok("ba\x{d4}c" =~ /([a\xd4]+)/ && $1 eq "a\xd4", $message);
        ok("ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4", $message);
        ok("ba\xd4c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}", $message);
        ok("ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\x{d4}", $message);
        ok("ba\x{d4}c" =~ /([a\x{d4}]+)/ && $1 eq "a\xd4", $message);
d149 2
d152 1
a152 1
        my $message = 'Match code points > 255';
d154 5
a158 5
        ok(/(.\x{300})./, $message);
        ok($` eq "abc\x{100}"            && length ($`) == 4, $message);
        ok($& eq "\x{200}\x{300}\x{380}" && length ($&) == 3, $message);
        ok($' eq "\x{400}defg"           && length ($') == 5, $message);
        ok($1 eq "\x{200}\x{300}"        && length ($1) == 2, $message);
d161 2
d169 1
d177 1
a177 1

d179 1
a179 1
            my $message = "Properties of \\x$code";
d181 4
a184 4

            is(0 + ($char =~ /[\x80-\xff]/),    $$match[0], $message);
            is(0 + ($char =~ /[\x80-\x{100}]/), $$match[1], $message);
            is(0 + ($char =~ /[\x{100}]/),      $$match[2], $message);
d188 1
d191 7
a197 4
	foreach (qw(c g o)) {
	    warning_like(sub {'' =~ "(?$_)"},    qr/^Useless \(\?$_\)/);
	    warning_like(sub {'' =~ "(?-$_)"},   qr/^Useless \(\?-$_\)/);
	}
d200 6
a205 10
	foreach (['(?g-o)', qr/^Useless \(\?g\)/, qr/^Useless \(\?-o\)/],
		 ['(?g-c)', qr/^Useless \(\?g\)/, qr/^Useless \(\?-c\)/],
		 # (?c) means (?g) error won't be thrown
		 ['(?o-cg)', qr/^Useless \(\?o\)/, qr/^Useless \(\?-c\)/],
		 ['(?ogc)', qr/^Useless \(\?o\)/, qr/^Useless \(\?g\)/,
		  qr/^Useless \(\?c\)/],
		) {
	    my ($re, @@warnings) = @@$_;
	    warnings_like(sub {eval "qr/$re/"}, \@@warnings, "qr/$re/ warns");
	}
d208 1
d210 1
a210 1
        my $message = "/x tests";
d212 1
a212 1
        foreach my $pat (<<"        --", <<"        --") {
d219 1
a225 3
	    is(eval $pat, 1, $message);
	    is($@@, '', $message);
	}
d228 1
d230 1
a230 1
        my $message = "/o feature";
d232 2
a233 2
        is(test_o ('abc', '(.)..'), 'a', $message);
        is(test_o ('abc', '..(.)'), 'a', $message);
d238 1
a238 1
        my $message = '$^N usage outside of a regex';
d240 15
a254 15
        ok(($x =~ /cde/                  and !defined $^N), $message);
        ok(($x =~ /(cde)/                and $^N eq "cde"), $message);
        ok(($x =~ /(c)(d)(e)/            and $^N eq   "e"), $message);
        ok(($x =~ /(c(d)e)/              and $^N eq "cde"), $message);
        ok(($x =~ /(foo)|(c(d)e)/        and $^N eq "cde"), $message);
        ok(($x =~ /(c(d)e)|(foo)/        and $^N eq "cde"), $message);
        ok(($x =~ /(c(d)e)|(abc)/        and $^N eq "abc"), $message);
        ok(($x =~ /(c(d)e)|(abc)x/       and $^N eq "cde"), $message);
        ok(($x =~ /(c(d)e)(abc)?/        and $^N eq "cde"), $message);
        ok(($x =~ /(?:c(d)e)/            and $^N eq   "d"), $message);
        ok(($x =~ /(?:c(d)e)(?:f)/       and $^N eq   "d"), $message);
        ok(($x =~ /(?:([abc])|([def]))*/ and $^N eq   "f"), $message);
        ok(($x =~ /(?:([ace])|([bdf]))*/ and $^N eq   "f"), $message);
        ok(($x =~ /(([ace])|([bd]))*/    and $^N eq   "e"), $message);
       {ok(($x =~ /(([ace])|([bdf]))*/   and $^N eq   "f"), $message);}
d257 1
a257 1
        is($^N, "e", '$^N is automatically localized');
d260 1
a260 1
        $message = '$^N usage inside (?{ ... })';
d262 7
a268 7
        ok(($x =~ /a([abc])(?{$y=$^N})c/                    and $y eq  "b"), $message);
        ok(($x =~ /a([abc]+)(?{$y=$^N})d/                   and $y eq  "bc"), $message);
        ok(($x =~ /a([abcdefg]+)(?{$y=$^N})d/               and $y eq  "bc"), $message);
        ok(($x =~ /(a([abcdefg]+)(?{$y=$^N})d)(?{$z=$^N})e/ and $y eq  "bc"
                                                            and $z eq "abcd"), $message);
        ok(($x =~ /(a([abcdefg]+)(?{$y=$^N})de)(?{$z=$^N})/ and $y eq  "bc"
                                                            and $z eq "abcde"), $message);
d272 1
d278 2
a279 2
        skip "Not an ASCII platform", 2 unless $::IS_ASCII;
        my $message = 'Test [[:cntrl:]]';
d282 1
a282 1
        is($x, join("", map {chr} 0x20 .. 0x7E, 0x80 .. 0xFF), $message);
d285 1
a285 1
        is($x, (join "", map {chr} 0x00 .. 0x1F, 0x7F), $message);
d288 1
d291 1
a291 1
        my $message = "UTF-8 chars aren't bytes";
d294 1
a294 1
        is($#a, 12, $message);
d297 1
d299 1
a299 1
        my $message = '. matches \n with /s';
d302 1
a302 1
        my ($a, $b) = map {chr} $::IS_ASCII ? (0xc4, 0x80) : (0x8c, 0x41);
d304 8
a311 8
        @@a = $str1 =~ /./g;   is(@@a, 6, $message); is("@@a", "f o o b a r", $message);
        @@a = $str1 =~ /./gs;  is(@@a, 7, $message); is("@@a", "f o o \n b a r", $message);
        @@a = $str1 =~ /\C/g;  is(@@a, 7, $message); is("@@a", "f o o \n b a r", $message);
        @@a = $str1 =~ /\C/gs; is(@@a, 7, $message); is("@@a", "f o o \n b a r", $message);
        @@a = $str2 =~ /./g;   is(@@a, 7, $message); is("@@a", "f o o \x{100} b a r", $message);
        @@a = $str2 =~ /./gs;  is(@@a, 8, $message); is("@@a", "f o o \n \x{100} b a r", $message);
        @@a = $str2 =~ /\C/g;  is(@@a, 9, $message); is("@@a", "f o o \n $a $b b a r", $message);
        @@a = $str2 =~ /\C/gs; is(@@a, 9, $message); is("@@a", "f o o \n $a $b b a r", $message);
d314 1
d410 1
d417 1
d425 1
d427 21
a447 21
        my $message = "Folding matches and Unicode";
        like("a\x{100}", qr/A/i, $message);
        like("A\x{100}", qr/a/i, $message);
        like("a\x{100}", qr/a/i, $message);
        like("A\x{100}", qr/A/i, $message);
        like("\x{101}a", qr/\x{100}/i, $message);
        like("\x{100}a", qr/\x{100}/i, $message);
        like("\x{101}a", qr/\x{101}/i, $message);
        like("\x{100}a", qr/\x{101}/i, $message);
        like("a\x{100}", qr/A\x{100}/i, $message);
        like("A\x{100}", qr/a\x{100}/i, $message);
        like("a\x{100}", qr/a\x{100}/i, $message);
        like("A\x{100}", qr/A\x{100}/i, $message);
        like("a\x{100}", qr/[A]/i, $message);
        like("A\x{100}", qr/[a]/i, $message);
        like("a\x{100}", qr/[a]/i, $message);
        like("A\x{100}", qr/[A]/i, $message);
        like("\x{101}a", qr/[\x{100}]/i, $message);
        like("\x{100}a", qr/[\x{100}]/i, $message);
        like("\x{101}a", qr/[\x{101}]/i, $message);
        like("\x{100}a", qr/[\x{101}]/i, $message);
d450 1
d453 1
a453 1
        my $message = "Folding 'LATIN LETTER A WITH GRAVE'";
d458 4
a461 4
        like($lower, qr/$UPPER/i, $message);
        like($UPPER, qr/$lower/i, $message);
        like($lower, qr/[$UPPER]/i, $message);
        like($UPPER, qr/[$lower]/i, $message);
d463 1
a463 1
        $message = "Folding 'GREEK LETTER ALPHA WITH VRACHY'";
d468 4
a471 4
        like($lower, qr/$UPPER/i, $message);
        like($UPPER, qr/$lower/i, $message);
        like($lower, qr/[$UPPER]/i, $message);
        like($UPPER, qr/[$lower]/i, $message);
d473 1
a473 1
        $message = "Folding 'LATIN LETTER Y WITH DIAERESIS'";
d478 4
a481 4
        like($lower, qr/$UPPER/i, $message);
        like($UPPER, qr/$lower/i, $message);
        like($lower, qr/[$UPPER]/i, $message);
        like($UPPER, qr/[$lower]/i, $message);
d484 1
d487 2
a488 1
        my $message = "GREEK CAPITAL LETTER SIGMA vs " .
d494 1
a494 2
        warning_is(sub {unlike("_:$char:_", qr/_:$SIGMA:_/i, $message)}, undef,
		   'Did not warn [change a5961de5f4215b5c]');
d497 1
d499 1
a499 1
        my $message = '\X';
d502 7
a508 7
        ok("a!"                          =~ /^(\X)!/ && $1 eq "a", $message);
        ok("\xDF!"                       =~ /^(\X)!/ && $1 eq "\xDF", $message);
        ok("\x{100}!"                    =~ /^(\X)!/ && $1 eq "\x{100}", $message);
        ok("\x{100}\x{300}!"             =~ /^(\X)!/ && $1 eq "\x{100}\x{300}", $message);
        ok("\N{LATIN CAPITAL LETTER E}!" =~ /^(\X)!/ &&
               $1 eq "\N{LATIN CAPITAL LETTER E}", $message);
        ok("\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}!"
d510 1
a510 1
               $1 eq "\N{LATIN CAPITAL LETTER E}\N{COMBINING GRAVE ACCENT}", $message);
d512 3
a514 3
        $message = '\C and \X';
        like("!abc!", qr/a\Cc/, $message);
        like("!abc!", qr/a\Xc/, $message);
d517 1
d519 1
a519 1
        my $message = "Final Sigma";
d525 23
a547 23
        like($SIGMA, qr/$SIGMA/i, $message);
        like($SIGMA, qr/$Sigma/i, $message);
        like($SIGMA, qr/$sigma/i, $message);

        like($Sigma, qr/$SIGMA/i, $message);
        like($Sigma, qr/$Sigma/i, $message);
        like($Sigma, qr/$sigma/i, $message);

        like($sigma, qr/$SIGMA/i, $message);
        like($sigma, qr/$Sigma/i, $message);
        like($sigma, qr/$sigma/i, $message);

        like($SIGMA, qr/[$SIGMA]/i, $message);
        like($SIGMA, qr/[$Sigma]/i, $message);
        like($SIGMA, qr/[$sigma]/i, $message);

        like($Sigma, qr/[$SIGMA]/i, $message);
        like($Sigma, qr/[$Sigma]/i, $message);
        like($Sigma, qr/[$sigma]/i, $message);

        like($sigma, qr/[$SIGMA]/i, $message);
        like($sigma, qr/[$Sigma]/i, $message);
        like($sigma, qr/[$sigma]/i, $message);
d549 1
a549 1
        $message = "More final Sigma";
d553 7
a559 7
        ok(":$S3:" =~ /:(($SIGMA)+):/i   && $1 eq $S3 && $2 eq $sigma, $message);
        ok(":$S3:" =~ /:(($Sigma)+):/i   && $1 eq $S3 && $2 eq $sigma, $message);
        ok(":$S3:" =~ /:(($sigma)+):/i   && $1 eq $S3 && $2 eq $sigma, $message);

        ok(":$S3:" =~ /:(([$SIGMA])+):/i && $1 eq $S3 && $2 eq $sigma, $message);
        ok(":$S3:" =~ /:(([$Sigma])+):/i && $1 eq $S3 && $2 eq $sigma, $message);
        ok(":$S3:" =~ /:(([$sigma])+):/i && $1 eq $S3 && $2 eq $sigma, $message);
d562 1
d565 1
a565 1
        my $message = "Parlez-Vous " .
d568 6
a573 6
        ok("Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran.ais/ &&
            $& eq "Francais", $message);
        ok("Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran.ais/ &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais", $message);
        ok("Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Cais/ &&
            $& eq "Francais", $message);
d575 8
a582 8
        like("Franc\N{COMBINING CEDILLA}ais", qr/Franc\C\Cais/, $message);
        ok("Fran\N{LATIN SMALL LETTER C}ais" =~ /Fran\Xais/ &&
            $& eq "Francais", $message);
        ok("Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~ /Fran\Xais/  &&
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais", $message);
        ok("Franc\N{COMBINING CEDILLA}ais" =~ /Fran\Xais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais", $message);
        ok("Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais" =~
d584 3
a586 3
            $& eq "Fran\N{LATIN SMALL LETTER C WITH CEDILLA}ais", $message);
        ok("Franc\N{COMBINING CEDILLA}ais" =~ /Franc\N{COMBINING CEDILLA}ais/ &&
            $& eq "Franc\N{COMBINING CEDILLA}ais", $message);
d596 1
a596 1
            ok($subject =~ /Fran(?:c\N{COMBINING CEDILLA}?|
d598 1
a598 1
               $& eq $match, $message);
d602 1
d604 1
a604 1
        my $message = "Lingering (and useless) UTF8 flag doesn't mess up /i";
d608 1
a608 1
        like($str, qr/$pat/i, $message);
d613 1
a613 1
        like($str, qr/$pat/i, $message);
d619 1
a619 1
        like($str, qr/$pat/i, $message);
d622 1
d625 1
a625 1
        my $message = "LATIN SMALL LETTER SHARP S " .
d628 24
a651 24
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/\N{LATIN SMALL LETTER SHARP S}/, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/\N{LATIN SMALL LETTER SHARP S}/i, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/[\N{LATIN SMALL LETTER SHARP S}]/, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/[\N{LATIN SMALL LETTER SHARP S}]/i, $message);

        like("ss", qr /\N{LATIN SMALL LETTER SHARP S}/i, $message);
        like("SS", qr /\N{LATIN SMALL LETTER SHARP S}/i, $message);
        like("ss", qr/[\N{LATIN SMALL LETTER SHARP S}]/i, $message);
        like("SS", qr/[\N{LATIN SMALL LETTER SHARP S}]/i, $message);

        like("\N{LATIN SMALL LETTER SHARP S}", qr/ss/i, $message);
        like("\N{LATIN SMALL LETTER SHARP S}", qr/SS/i, $message);

         $message = "Unoptimized named sequence in class";
        like("ss", qr/[\N{LATIN SMALL LETTER SHARP S}x]/i, $message);
        like("SS", qr/[\N{LATIN SMALL LETTER SHARP S}x]/i, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/[\N{LATIN SMALL LETTER SHARP S}x]/, $message);
        like("\N{LATIN SMALL LETTER SHARP S}",
	     qr/[\N{LATIN SMALL LETTER SHARP S}x]/i, $message);
d654 1
d660 1
a660 1
          skip "EBCDIC platform", 4 if $::IS_EBCDIC;
d703 1
d706 1
a706 1
        my $message = ". with /s works on characters, not bytes";
d711 1
a711 2
        warning_is(sub {$s =~ /\G(.+?)\n/gcs}, undef,
		   "No 'Malformed UTF-8' warning");
d717 1
a717 1
        is("@@c", $s, $message);
d733 1
a733 1
        is($r1, $r2, $message);
d736 1
d738 5
a742 5
        my $message = "Unicode lookbehind";
        like("A\x{100}B"       , qr/(?<=A.)B/, $message);
        like("A\x{200}\x{300}B", qr/(?<=A..)B/, $message);
        like("\x{400}AB"       , qr/(?<=\x{400}.)B/, $message);
        like("\x{500}\x{600}B" , qr/(?<=\x{500}.)B/, $message);
d749 1
d751 1
a751 1
        my $message = 'UTF-8 hash keys and /$/';
d762 1
a762 1
            is($m1, $m2, $message);
d766 1
d768 1
a768 1
        my $message = "No SEGV in s/// and UTF-8";
d770 1
a770 1
        ok($s =~ s/[^\w]/ /g, $message);
d772 1
a772 1
            is($s, "s \x{100}" x 4, $message);
d775 1
a775 1
            is($s, "s  " x 4, $message);
d779 1
d781 1
a781 1
        my $message = "UTF-8 bug (maybe already known?)";
d784 1
a784 1
        is($u, "\x{100}\x{100}\x{100}", $message);
d788 1
a788 1
        is($u, "f\x{100}\x{100}b\x{100}r", $message);
d791 1
a791 1
        is($u, "feeber", $message);
d794 1
d796 1
a796 1
        my $message = "UTF-8 bug with s///";
d804 2
a805 2
            unlike("xxx", qr/$re/, $message);
            ok(+($subst = "xxx") !~ s/$re//, $message);
d808 3
a810 3
            like("xxx", qr/$re/, $message);
            ok(+($subst = "xxx") =~ s/$re//, $message);
            is($subst, "", $message);
d813 5
a817 5
            like("xx$c", qr/$re/, $message);
            ok(+($subst = "xx$c") =~ s/$re//, $message);
            is($subst, $c, $message);
            unlike("xy$c", qr/$re/, $message);
            ok(+($subst = "xy$c") !~ s/$re//, $message);
d820 3
a822 3
            like("xyz", qr/$re/, $message);
            ok(+($subst = "xyz") =~ s/$re//, $message);
            is($subst, "", $message);
d826 1
d828 1
a828 1
        my $message = "qr /.../x";
d830 5
a834 5
        ok("ABCDE" =~    $R   && $& eq "ABC", $message);
        ok("ABCDE" =~   /$R/  && $& eq "ABC", $message);
        ok("ABCDE" =~  m/$R/  && $& eq "ABC", $message);
        ok("ABCDE" =~  /($R)/ && $1 eq "ABC", $message);
        ok("ABCDE" =~ m/($R)/ && $1 eq "ABC", $message);
d837 3
d850 3
d860 1
a860 1
        my $message = 'Markus Kuhn 2003-02-26';
d863 2
a864 2
        ok($x =~ s/(\S)\n(\S)/$1 $2/sg, $message);
        is($x, "\x{2019} k", $message);
d867 2
a868 2
        ok($x =~ s/(\S)\n(\S)/$1 $2/sg, $message);
        is($x, "b k", $message);
d870 1
a870 1
        like("\x{2019}", qr/\S/, $message);
d873 1
d879 1
a879 1
        local $::TODO = "Recursive split is still broken";
d883 1
d888 1
a902 3
        my $loc_re = qq /(?l:^([^X]*)X)/;
        utf8::upgrade ($loc_re);
        ok "\x{100}X" =~ /$loc_re/, "locale, S_cl_and ANYOF_UNICODE & ANYOF_INVERTED";
d911 1
a911 1
        my $message = '<20030808193656.5109.1@@llama.ni-s.u-net.com>';
d914 1
a914 1
        like("  \x{101}", qr/\x{100}/i, $message);
d917 1
a917 1
        like("  \x{1E01}", qr/\x{1E00}/i, $message);
d920 1
a920 1
        like("  \x{10428}", qr/\x{10400}/i, $message);
d923 1
a923 1
        like("  \x{1E01}x", qr/\x{1E00}X/i, $message);
d929 1
a929 1
            my $message = q [Don't misparse \x{...} in regexp ] .
d932 1
a932 2
                eval qq{like("$head$tail", qr/$head$tail/, \$message)};
		is($@@, '', $message);
d934 1
a934 1
            $message = q [Don't misparse \N{...} in regexp ] .
d937 2
a938 3
                eval qq {use charnames ':full';
                         like("$head$tail", qr/$head$tail/, \$message)};
		is($@@, '', $message);
d946 1
a946 1
        is(@@got, 1, "TRIE optimisation");
d950 1
a950 1
        is(@@got, 1,"TRIEF optimisation");
d973 1
d1017 3
d1038 1
a1038 1
                   "Zerolength charname in charclass doesn't match \\\\0"];
d1054 12
a1065 1
        eval q [ok "\N{TOO-LONG-STR}" =~ /^\N{TOO-LONG-STR}$/, 'Verify that what once was too long a string works'];
d1085 1
d1103 1
d1128 1
a1128 1
            is(@@stack, @@expect, "Right amount of matches")
d1133 2
a1134 2
                is($stack [$idx], $expect,
		   "Expecting '$expect' at stack pos #$idx");
d1140 1
d1150 1
d1189 1
a1189 1
        is("@@res", "@@expect", "Check %-");
d1217 1
a1217 1
        is($count, 9, "Expect 9 for no (*PRUNE)");
d1220 1
a1220 1
        is($count, 3, "Expect 3 with (*PRUNE)");
d1224 1
a1224 1
        is($count, 4, "/.(*PRUNE)/");
d1227 1
a1227 1
        is($count, 3, "Expect 3 with (*PRUNE)");
d1231 1
a1231 1
        is($count, 4, "/.(*PRUNE)/");
d1234 1
d1238 1
a1238 1
        is($count, 1, "Expect 1 with (*SKIP)");
d1242 1
a1242 1
        is($count, 4, "/.(*SKIP)/");
d1247 2
a1248 2
        is($count, 2, "Expect 2 with (*SKIP)");
        is("@@res", "aaab aaab", "Adjacent (*SKIP) works as expected");
d1251 1
d1255 1
a1255 1
        is($count, 1, "Expect 1 with (*SKIP)");
d1259 1
a1259 1
        is($count, 4, "/.(*SKIP)/");
d1264 2
a1265 2
        is($count, 2, "Expect 2 with (*SKIP)");
        is("@@res", "aaab aaab", "Adjacent (*SKIP) works as expected");
d1268 1
d1272 1
a1272 1
        is($count, 3, "Expect 3 with *MARK:a)b?(*MARK:b)(*SKIP:a)");
d1278 3
a1280 3
        is($count, 5, "Expect 5 with (*MARK:a)b?)(*MARK:x)(*SKIP:a)");
        is("@@res", "aaab b aaab b ",
	   "Adjacent (*MARK:a)b?)(*MARK:x)(*SKIP:a) works as expected");
d1283 1
d1287 1
a1287 1
        is($count, 1, "Expect 1 with (*COMMIT)");
d1291 1
a1291 1
        is($count, 1, "/.(*COMMIT)/");
d1296 2
a1297 2
        is($count, 1, "Expect 1 with (*COMMIT)");
        is("@@res", "aaab", "Adjacent (*COMMIT) works as expected");
d1300 1
d1310 1
a1310 1
                    is($REGERROR,
d1312 1
a1312 1
                        "Test $pat and \$REGERROR $suffix");
d1318 1
d1329 1
a1329 1
		    ::is($REGERROR,
d1331 1
a1331 1
			 "Test $pat and \$REGERROR $suffix");
d1337 1
d1340 1
a1340 1
	my $message = '$REGERROR';
d1346 1
a1346 1
            is($REGERROR, $word, $message);
d1357 1
d1359 1
a1359 1
        my $message = "Relative Recursion";
d1363 5
a1367 5
        ok(m/foo $parens \s* \+ \s* bar $parens/x, $message);
        is($1, '((2*3)+4-3)', $message);
        is($2, '(2*(3+4)-1*(2-3))', $message);
        is($&, 'foo((2*3)+4-3) + bar(2*(3+4)-1*(2-3))', $message);
        is($&, $_, $message);
d1375 2
a1376 2
        is($_, $spaces, "SUSPEND final string");
        is($count, 1, "Optimiser should have prevented more than one match");
d1379 1
d1388 1
a1388 1
        is($dow_name, $time_string, "UTF-8 trie common prefix extraction");
d1391 1
d1396 2
a1397 2
        is("$1", 'bar',
	   '$1 is safe after /g - may fail due to specialized config in pp_hot.c');
d1400 1
d1402 1
a1402 1
        my $message = "http://nntp.perl.org/group/perl.perl5.porters/118663";
d1404 6
a1409 6
        like("foobarbarxyz", $qr_barR1, $message);
        like("foobarbarxyz", qr/foo${qr_barR1}xyz/, $message);
        like("foobarbarxyz", qr/(foo)${qr_barR1}xyz/, $message);
        like("foobarbarxyz", qr/(foo)(bar)\g{-1}xyz/, $message);
        like("foobarbarxyz", qr/(foo${qr_barR1})xyz/, $message);
        like("foobarbarxyz", qr/(foo(bar)\g{-1})xyz/, $message);
d1413 1
a1413 1
        my $message = '$REGMARK';
d1416 6
a1421 6
        like('foofoo', qr/foo (*MARK:foo) (?{push @@r,$REGMARK}) /x, $message);
        is("@@r","foo", $message);
        is($REGMARK, "foo", $message);
        unlike('foofoo', qr/foo (*MARK:foo) (*FAIL) /x, $message);
        is($REGMARK, '', $message);
        is($REGERROR, 'foo', $message);
d1424 1
d1426 1
a1426 1
        my $message = '\K test';
d1430 1
a1430 1
        is($x, "abc.def.ghi", $message);
d1434 1
a1434 1
        is($x, "one two  four", $message);
d1438 1
a1438 1
        is($x, "aabbccddee", $message);
d1441 1
d1451 2
a1452 2
        is(join ("-", @@res), "0902862349",
	   'PL_curpm is set properly on nested eval');
d1458 1
a1467 5
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Uppercase}/i,  "i =~ Uppercase under /i";
        ok "\N{SMALL ROMAN NUMERAL ONE}" !~ /\p{Titlecase}/,  "i !~ Titlecase";
        ok "\N{SMALL ROMAN NUMERAL ONE}" =~ /\p{Titlecase}/i,  "i =~ Titlecase under /i";
        ok "\N{ROMAN NUMERAL ONE}" =~ /\p{Lowercase}/i,  "I =~ Lowercase under /i";

a1472 40
    {   # More checking that /i works on the few properties that it makes a
        # difference.  Uppercase, Lowercase, and Titlecase were done in the
        # block above
        ok "A" =~ /\p{PosixUpper}/,  "A =~ PosixUpper";
        ok "A" =~ /\p{PosixUpper}/i,  "A =~ PosixUpper under /i";
        ok "A" !~ /\p{PosixLower}/,  "A !~ PosixLower";
        ok "A" =~ /\p{PosixLower}/i,  "A =~ PosixLower under /i";
        ok "a" !~ /\p{PosixUpper}/,  "a !~ PosixUpper";
        ok "a" =~ /\p{PosixUpper}/i,  "a =~ PosixUpper under /i";
        ok "a" =~ /\p{PosixLower}/,  "a =~ PosixLower";
        ok "a" =~ /\p{PosixLower}/i,  "a =~ PosixLower under /i";

        ok "\xC0" =~ /\p{XPosixUpper}/,  "\\xC0 =~ XPosixUpper";
        ok "\xC0" =~ /\p{XPosixUpper}/i,  "\\xC0 =~ XPosixUpper under /i";
        ok "\xC0" !~ /\p{XPosixLower}/,  "\\xC0 !~ XPosixLower";
        ok "\xC0" =~ /\p{XPosixLower}/i,  "\\xC0 =~ XPosixLower under /i";
        ok "\xE0" !~ /\p{XPosixUpper}/,  "\\xE0 !~ XPosixUpper";
        ok "\xE0" =~ /\p{XPosixUpper}/i,  "\\xE0 =~ XPosixUpper under /i";
        ok "\xE0" =~ /\p{XPosixLower}/,  "\\xE0 =~ XPosixLower";
        ok "\xE0" =~ /\p{XPosixLower}/i,  "\\xE0 =~ XPosixLower under /i";

        ok "\xC0" =~ /\p{UppercaseLetter}/,  "\\xC0 =~ UppercaseLetter";
        ok "\xC0" =~ /\p{UppercaseLetter}/i,  "\\xC0 =~ UppercaseLetter under /i";
        ok "\xC0" !~ /\p{LowercaseLetter}/,  "\\xC0 !~ LowercaseLetter";
        ok "\xC0" =~ /\p{LowercaseLetter}/i,  "\\xC0 =~ LowercaseLetter under /i";
        ok "\xC0" !~ /\p{TitlecaseLetter}/,  "\\xC0 !~ TitlecaseLetter";
        ok "\xC0" =~ /\p{TitlecaseLetter}/i,  "\\xC0 =~ TitlecaseLetter under /i";
        ok "\xE0" !~ /\p{UppercaseLetter}/,  "\\xE0 !~ UppercaseLetter";
        ok "\xE0" =~ /\p{UppercaseLetter}/i,  "\\xE0 =~ UppercaseLetter under /i";
        ok "\xE0" =~ /\p{LowercaseLetter}/,  "\\xE0 =~ LowercaseLetter";
        ok "\xE0" =~ /\p{LowercaseLetter}/i,  "\\xE0 =~ LowercaseLetter under /i";
        ok "\xE0" !~ /\p{TitlecaseLetter}/,  "\\xE0 !~ TitlecaseLetter";
        ok "\xE0" =~ /\p{TitlecaseLetter}/i,  "\\xE0 =~ TitlecaseLetter under /i";
        ok "\x{1C5}" !~ /\p{UppercaseLetter}/,  "\\x{1C5} !~ UppercaseLetter";
        ok "\x{1C5}" =~ /\p{UppercaseLetter}/i,  "\\x{1C5} =~ UppercaseLetter under /i";
        ok "\x{1C5}" !~ /\p{LowercaseLetter}/,  "\\x{1C5} !~ LowercaseLetter";
        ok "\x{1C5}" =~ /\p{LowercaseLetter}/i,  "\\x{1C5} =~ LowercaseLetter under /i";
        ok "\x{1C5}" =~ /\p{TitlecaseLetter}/,  "\\x{1C5} =~ TitlecaseLetter";
        ok "\x{1C5}" =~ /\p{TitlecaseLetter}/i,  "\\x{1C5} =~ TitlecaseLetter under /i";
    }
d1485 1
d1492 2
a1493 2
        is($res, "1",
	   "Check that (?|...) doesnt cause dupe entries in the names array");
d1499 2
a1500 2
        is($res, "1",
	   "Check that (?&..) to a buffer inside a (?|...) goes to the leftmost");
d1503 1
d1506 1
a1506 1
        my $message = "ASCII pattern that really is UTF-8";
d1510 2
a1511 2
        like($c, qr/${c}|\x{100}/, $message);
        is("@@w", '', $message);
d1514 1
d1516 1
a1516 1
        my $message = "Corruption of match results of qr// across scopes";
d1519 1
a1519 1
        is("$1$2", "foobar", $message);
d1522 1
a1522 1
            is("$1$2", 'foooooobaaaaar', $message);
d1524 1
a1524 1
        is("$1$2", "foobar", $message);
d1527 1
d1529 1
a1529 1
        my $message = "HORIZWS";
d1533 1
a1533 1
        is($_, "hhHHhHhhHH", $message);
d1538 1
a1538 1
        is($_, "hhHHhHhhHH", $message);
d1541 1
d1543 1
a1543 1
        # Various whitespace special patterns
d1557 2
a1558 5
                    my $temp_str = $str;
                    $temp_str = display($temp_str);
                    ok $str =~ /($pat)/, $temp_str . " =~ /($pat)";
                    my $temp_1 = $1;
                    is($1, $str, "\$1='" . display($temp_1) . "' eq '" . $temp_str . "' after ($pat)");
d1560 2
a1561 2
                    ok $str =~ /($pat)/, "Upgraded " . $temp_str . " =~ /($pat)/";
                    is($1, $str, "\$1='" . display($temp_1) . "' eq '" . $temp_str . "'(upgraded) after ($pat)");
d1567 1
d1569 1
a1569 1
        # Check that \\xDF match properly in its various forms
d1605 1
d1607 1
a1607 1
        my $message = "BBC(Bleadperl Breaks CPAN) Today: String::Multibyte";
d1615 1
a1615 1
        is(@@a,3, $message);
d1617 1
a1617 1
        is("@@a","$esc$hyp=$hyp=$esc$esc", $message);
d1620 1
d1623 1
a1623 1
        my $message = 'Test keys in %+ and %-';
d1627 4
a1630 4
        is((join ",", sort keys %+), "foo", $message);
        is((join ",", sort keys %-), "foo", $message);
        is((join ",", sort values %+), "a", $message);
        is((join ",", sort map "@@$_", values %-), "a ", $message);
d1632 4
a1635 4
        is((join ",", sort keys %+), "bar,quux", $message);
        is((join ",", sort keys %-), "bar,quux", $message);
        is((join ",", sort values %+), "a,c", $message); # leftmost
        is((join ",", sort map "@@$_", values %-), "a b,c", $message);
d1637 4
a1640 4
        is((join ",", sort keys %+), "un", $message);
        is((join ",", sort keys %-), "deux,un", $message);
        is((join ",", sort values %+), "a", $message);
        is((join ",", sort map "@@$_", values %-), ",a", $message);
d1643 1
d1649 5
a1653 5
        is(length $`,      0, q[length $`]);
        is(length $',      4, q[length $']);
        is(length $&,      9, q[length $&]);
        is(length $1,      4, q[length $1]);
        is(length $+{eek}, 4, q[length $+{eek} == length $1]);
d1656 1
d1661 3
a1663 3
        is($ok, 1, '$-{x} exists after "bar"=~/(?<x>foo)|bar/');
        is(scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/');
        is(scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/');
d1667 3
a1669 3
        is($ok, 0, '$+{x} not exists after "bar"=~/(?<x>foo)|bar/');
        is(scalar (%+), 0, 'scalar %+ == 0 after "bar"=~/(?<x>foo)|bar/');
        is(scalar (%-), 1, 'scalar %- == 1 after "bar"=~/(?<x>foo)|bar/');
d1673 3
a1675 3
        is($ok, 1, '$-{x} exists after "foo"=~/(?<x>foo)|bar/');
        is(scalar (%+), 1, 'scalar %+ == 1 after "foo"=~/(?<x>foo)|bar/');
        is(scalar (%-), 1, 'scalar %- == 1 after "foo"=~/(?<x>foo)|bar/');
d1679 1
a1679 1
        is($ok, 1, '$+{x} exists after "foo"=~/(?<x>foo)|bar/');
d1682 1
d1687 2
a1688 1
        is("$1", 'abc', "/g leads to unsafe match vars: $1");
a1689 16
        fresh_perl_is(<<'EOP', ">abc<\n", {}, 'mention $&');
$&;
my $x; 
($x='abc')=~/(abc)/g; 
$x='123'; 
print ">$1<\n";
EOP

        local $::TODO = 'RT #86042';
        fresh_perl_is(<<'EOP', ">abc<\n", {}, 'no mention of $&');
my $x; 
($x='abc')=~/(abc)/g; 
$x='123'; 
print ">$1<\n";
EOP
    }
d1692 1
a1692 1
        # Message-ID: <20070818091501.7eff4831@@r2d2>
d1700 1
a1700 1
        is(length $str, 0, "Trie scope error, string should be empty");
d1708 1
a1708 1
        is(length $str, 0, "Trie scope error, string should be empty");
d1711 1
d1725 1
a1725 1
        is($b, $a, "Copy of scalar used for postponed subexpression");
d1728 1
d1747 2
a1748 2
        is("@@ctl_n", "bla blubb", '$^N inside of (?{}) works as expected');
        is("@@plus",  "bla blubb", '$+  inside of (?{}) works as expected');
d1751 1
d1756 1
a1756 1
        skip "Tests assume ASCII", 4 unless $::IS_ASCII;
d1760 2
a1761 2
        is(join ('', @@notIsPunct), '$+<=>^`|~',
	   '[:punct:] disagrees with IsPunct on Symbols');
d1765 2
a1766 2
        is(join ('', @@isPrint), "",
	   'IsPrint agrees with [:print:] on control characters');
d1770 2
a1771 2
        is(join ('', @@isPunct), "\xa1\xa7\xab\xb6\xb7\xbb\xbf",    # ¡ « · » ¿
	   'IsPunct disagrees with [:punct:] outside ASCII');
d1780 2
a1781 314
        is(join ('', @@isPunctLatin1), '',
	   'IsPunct agrees with [:punct:] with explicit Latin1');
    }

    {
	# Tests for [#perl 71942]
        our $count_a;
        our $count_b;

        my $c = 0;
        for my $re (
#            [
#                should match?,
#                input string,
#                re 1,
#                re 2,
#                expected values of count_a and count_b,
#            ]
            [
                0,
                "xababz",
                qr/a+(?{$count_a++})b?(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})b?(*COMMIT)z/,
                1,
            ],
            [
                0,
                "xababz",
                qr/a+(?{$count_a++})b?(*COMMIT)\s*(*FAIL)/,
                qr/a+(?{$count_b++})b?(*COMMIT)\s*z/,
                1,
            ],
            [
                0,
                "xababz",
                qr/a+(?{$count_a++})(?:b|)?(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})(?:b|)?(*COMMIT)z/,
                1,
            ],
            [
                0,
                "xababz",
                qr/a+(?{$count_a++})b{0,6}(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})b{0,6}(*COMMIT)z/,
                1,
            ],
            [
                0,
                "xabcabcz",
                qr/a+(?{$count_a++})(bc){0,6}(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})(bc){0,6}(*COMMIT)z/,
                1,
            ],
            [
                0,
                "xabcabcz",
                qr/a+(?{$count_a++})(bc*){0,6}(*COMMIT)(*FAIL)/,
                qr/a+(?{$count_b++})(bc*){0,6}(*COMMIT)z/,
                1,
            ],


            [
                0,
                "aaaabtz",
                qr/a+(?{$count_a++})b?(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})b?(*PRUNE)z/,
                4,
            ],
            [
                0,
                "aaaabtz",
                qr/a+(?{$count_a++})b?(*PRUNE)\s*(*FAIL)/,
                qr/a+(?{$count_b++})b?(*PRUNE)\s*z/,
                4,
            ],
            [
                0,
                "aaaabtz",
                qr/a+(?{$count_a++})(?:b|)(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})(?:b|)(*PRUNE)z/,
                4,
            ],
            [
                0,
                "aaaabtz",
                qr/a+(?{$count_a++})b{0,6}(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})b{0,6}(*PRUNE)z/,
                4,
            ],
            [
                0,
                "aaaabctz",
                qr/a+(?{$count_a++})(bc){0,6}(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})(bc){0,6}(*PRUNE)z/,
                4,
            ],
            [
                0,
                "aaaabctz",
                qr/a+(?{$count_a++})(bc*){0,6}(*PRUNE)(*FAIL)/,
                qr/a+(?{$count_b++})(bc*){0,6}(*PRUNE)z/,
                4,
            ],

            [
                0,
                "aaabaaab",
                qr/a+(?{$count_a++;})b?(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})b?(*SKIP)z/,
                2,
            ],
            [
                0,
                "aaabaaab",
                qr/a+(?{$count_a++;})b?(*SKIP)\s*(*FAIL)/,
                qr/a+(?{$count_b++;})b?(*SKIP)\s*z/,
                2,
            ],
            [
                0,
                "aaabaaab",
                qr/a+(?{$count_a++;})(?:b|)(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})(?:b|)(*SKIP)z/,
                2,
            ],
            [
                0,
                "aaabaaab",
                qr/a+(?{$count_a++;})b{0,6}(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})b{0,6}(*SKIP)z/,
                2,
            ],
            [
                0,
                "aaabcaaabc",
                qr/a+(?{$count_a++;})(bc){0,6}(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})(bc){0,6}(*SKIP)z/,
                2,
            ],
            [
                0,
                "aaabcaaabc",
                qr/a+(?{$count_a++;})(bc*){0,6}(*SKIP)(*FAIL)/,
                qr/a+(?{$count_b++;})(bc*){0,6}(*SKIP)z/,
                2,
            ],


            [
                0,
                "aaddbdaabyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? b?  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? b?  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbdaabyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? b?  (*SKIP:T1) \s* (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? b?  (*SKIP:T1) \s* z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbdaabyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? (?:b|)  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? (?:b|)  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbdaabyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? b{0,6}  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? b{0,6}  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbcdaabcyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? (bc){0,6}  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? (bc){0,6}  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],
            [
                0,
                "aaddbcdaabcyzc",
                qr/a (?{$count_a++;}) (*MARK:T1) (a*) .*? (bc*){0,6}  (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;}) (*MARK:T1) (a*) .*? (bc*){0,6}  (*SKIP:T1) z \s* c \1 /x,
                4,
            ],


            [
                0,
                "aaaaddbdaabyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? b?   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? b?   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbdaabyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? b?   (*MARK:T1) (*SKIP:T1) \s* (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? b?   (*MARK:T1) (*SKIP:T1) \s* z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbdaabyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? (?:b|)   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? (?:b|)   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbdaabyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? b{0,6}   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? b{0,6}   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbcdaabcyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? (bc){0,6}   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? (bc){0,6}   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],
            [
                0,
                "aaaaddbcdaabcyzc",
                qr/a (?{$count_a++;})  (a?) (*MARK:T1) (a*) .*? (bc*){0,6}   (*MARK:T1) (*SKIP:T1) (*FAIL) \s* c \1 /x,
                qr/a (?{$count_b++;})  (a?) (*MARK:T1) (a*) .*? (bc*){0,6}   (*MARK:T1) (*SKIP:T1) z \s* c \1 /x,
                2,
            ],


            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) C? (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) C? (*THEN)  | A D) z/x,
                1,
            ],
            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) C? (*THEN)  | A D) \s* (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) C? (*THEN)  | A D) \s* z/x,
                1,
            ],
            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) (?:C|) (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) (?:C|) (*THEN)  | A D) z/x,
                1,
            ],
            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) C{0,6} (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) C{0,6} (*THEN)  | A D) z/x,
                1,
            ],
            [
                0,
                "AbcdCEBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) (CE){0,6} (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) (CE){0,6} (*THEN)  | A D) z/x,
                1,
            ],
            [
                0,
                "AbcdCBefgBhiBqz",
                qr/(A (.*)  (?{ $count_a++ }) (CE*){0,6} (*THEN)  | A D) (*FAIL)/x,
                qr/(A (.*)  (?{ $count_b++ }) (CE*){0,6} (*THEN)  | A D) z/x,
                1,
            ],
        ) {
            $c++;
            $count_a = 0;
            $count_b = 0;

            my $match_a = ($re->[1] =~ $re->[2]) || 0;
            my $match_b = ($re->[1] =~ $re->[3]) || 0;

            is($match_a, $re->[0], "match a " . ($re->[0] ? "succeeded" : "failed") . " ($c)");
            is($match_b, $re->[0], "match b " . ($re->[0] ? "succeeded" : "failed") . " ($c)");
            is($count_a, $re->[4], "count a ($c)");
            is($count_b, $re->[4], "count b ($c)");
        }
    }

    {   # Bleadperl v5.13.8-292-gf56b639 breaks NEZUMI/Unicode-LineBreak-1.011
        # \xdf in lookbehind failed to compile as is multi-char fold
        my $message = "Lookbehind with \\xdf matchable compiles";
        my $r = eval 'qr{
            (?u: (?<=^url:) |
                 (?<=[/]) (?=[^/]) |
                 (?<=[^-.]) (?=[-~.,_?\#%=&]) |
                 (?<=[=&]) (?=.)
            )}iox';
	is($@@, '', $message);
	object_ok($r, 'Regexp', $message);
    }

    # RT #82610
    ok 'foo/file.fob' =~ m,^(?=[^\.])[^/]*/(?=[^\.])[^/]*\.fo[^/]$,;

    {   # This was failing unless an explicit /d was added
        my $p = qr/[\xE0_]/i;
        utf8::upgrade($p);
        like("\xC0", $p, "Verify \"\\xC0\" =~ /[\\xE0_]/i; pattern in utf8");
a1783 3
    ok "x" =~ /\A(?>(?:(?:)A|B|C?x))\z/,
        "Check TRIE does not overwrite EXACT following NOTHING at start - RT #111842";

d1795 1
a1795 1
        my $message = "Substitution with lookahead (possible segv)";
d1798 1
a1798 1
        is($_, "ns_1ns_1ns_1", $message);
d1801 1
a1801 1
        is($_, "ns_1", $message);
d1804 1
a1804 1
        is($_, "!Bang!1!Bang!2!Bang!3!Bang!", $message);
d1809 1
a1809 1
        my $message = "U+0FFFF shouldn't crash the regex engine";
d1816 1
a1816 8
        ok(1, $message);  # If it didn't crash, it worked.
    }

    TODO: {   # Was looping
        todo_skip('Triggers thread clone SEGV. See #86550')
	  if $::running_as_thread && $::running_as_thread;
        watchdog(10);   # Use a bigger value for busy systems
        like("\x{00DF}", qr/[\x{1E9E}_]*/i, "\"\\x{00DF}\" =~ /[\\x{1E9E}_]*/i was looping");
a1817 46

    {   # Bug #90536, caused failed assertion
        unlike("s\N{U+DF}", qr/^\x{00DF}/i, "\"s\\N{U+DF}\", qr/^\\x{00DF}/i");
    }

    # User-defined Unicode properties to match above-Unicode code points
    sub Is_32_Bit_Super { return "110000\tFFFFFFFF\n" }
    sub Is_Portable_Super { return '!utf8::Any' }   # Matches beyond 32 bits

    {   # Assertion was failing on on 64-bit platforms; just didn't work on 32.
        no warnings qw(non_unicode portable);
        use Config;

        # We use 'ok' instead of 'like' because the warnings are lexically
        # scoped, and want to turn them off, so have to do the match in this
        # scope
        if ($Config{uvsize} < 8) {
            ok(chr(0xFFFF_FFFE) =~ /\p{Is_32_Bit_Super}/,
                            "chr(0xFFFF_FFFE) can match a Unicode property");
            ok(chr(0xFFFF_FFFF) =~ /\p{Is_32_Bit_Super}/,
                            "chr(0xFFFF_FFFF) can match a Unicode property");
        }
        else {
            no warnings 'overflow';
            ok(chr(0xFFFF_FFFF_FFFF_FFFE) =~ qr/\p{Is_Portable_Super}/,
                    "chr(0xFFFF_FFFF_FFFF_FFFE) can match a Unicode property");
            ok(chr(0xFFFF_FFFF_FFFF_FFFF) =~ qr/^\p{Is_Portable_Super}$/,
                    "chr(0xFFFF_FFFF_FFFF_FFFF) can match a Unicode property");

            # This test is because something was declared as 32 bits, but
            # should have been cast to 64; only a problem where
            # sizeof(STRLEN) != sizeof(UV)
            ok(chr(0xFFFF_FFFF_FFFF_FFFE) !~ qr/\p{Is_32_Bit_Super}/, "chr(0xFFFF_FFFF_FFFF_FFFE) shouldn't match a range ending in 0xFFFF_FFFF");
        }
    }

    { # [perl #112530], the code below caused a panic
        sub InFoo { "a\tb\n9\ta\n" }
        like("\n", qr/\p{InFoo}/,
                            "Overlapping ranges in user-defined properties");
    }

    # !!! NOTE that tests that aren't at all likely to crash perl should go
    # a ways above, above these last ones.

    done_testing();
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a791 6
        # The second half of RT #114808
        warning_is(sub {'aa' =~ /.+\x{100}/}, undef,
                   'utf8-only floating substr, non-utf8 target, no warning');
    }

    {
d832 9
d885 1
a885 1
        for (120 .. 130, 240 .. 260) {
d888 1
a888 1
                             q [near EXACT char count limit];
d894 1
a894 1
                             q [near EXACT char count limit];
a982 3
        my $name = "foo\xDF";
        my $result = eval "'A${name}B'  =~ /^A\\N{$name}B\$/";
        ok !$@@ && $result,  "Passthrough charname of non-ASCII, Latin1";
d989 1
a989 1
        ok $w && $w =~ /Using just the first character returned by \\N\{} in character class/,
a996 10
        undef $w;
        eval q [ok 'xy' =~ /x[\N{EMPTY-STR} y]/x,
                    'Empty string charname in [] is ignored; finds a following character'];
        ok $w && $w =~ /Ignoring zero length/,
                 'Ignoring zero length \N{} in character class warning';
        undef $w;
        eval q [ok 'x ' =~ /x[\N{EMPTY-STR} y]/,
                    'Empty string charname in [] is ignored; finds a following blank under /x'];
        ok $w && $w =~ /Ignoring zero length/,
                 'Ignoring zero length \N{} in character class warning';
a1006 31
        eval '/(?[[\N{EMPTY-STR}]])/';
        ok $@@ && $@@ =~ /Zero length \\N\{}/;

        undef $w;
        eval q [is("\N{TOO  MANY SPACES}", "TOO  MANY SPACES", "Multiple spaces in character name works")];
        like ($w, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... but returns a deprecation warning");
        eval q [use utf8; is("\N{TOO  MANY SPACES}", "TOO  MANY SPACES", "Same under 'use utf8': they work")];
        like ($w, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... but return a deprecation warning");
        {
            no warnings 'deprecated';
            undef $w;
            eval q ["\N{TOO  MANY SPACES}"];
            ok (! defined $w, "... and no warning if warnings are off");
            eval q [use utf8; "\N{TOO  MANY SPACES}"];
            ok (! defined $w, "... same under 'use utf8'");
        }

        undef $w;
        eval q [is("\N{TRAILING SPACE }", "TRAILING SPACE ", "Trailing space in character name works")];
        like ($w, qr/Trailing white-space in a charnames alias definition is deprecated/, "... but returns a deprecation warning");
        eval q [use utf8; is("\N{TRAILING SPACE }", "TRAILING SPACE ", "Same under 'use utf8': they work")];
        like ($w, qr/Trailing white-space in a charnames alias definition is deprecated/, "... but returns a deprecation warning");
        {
            no warnings 'deprecated';
            undef $w;
            eval q ["\N{TRAILING SPACE }"];
            ok (! defined $w, "... and no warning if warnings are off");
            eval q [use utf8; "\N{TRAILING SPACE }"];
            ok (! defined $w, "... same under 'use utf8'");
        }

d1013 1
d1015 2
a1016 1
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that leading digit in name gives error';
d1018 3
a1020 2
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that comma in name gives error';
        $name = "A\x{D7}O";
d1022 1
a1022 20
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that latin1 symbol in name gives error';
        my $utf8_name = "7 CITIES OF GOLD";
        utf8::upgrade($utf8_name);
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that leading digit in utf8 name gives error';
        $utf8_name = "SHARP #";
        utf8::upgrade($utf8_name);
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that ASCII symbol in utf8 name gives error';
        $utf8_name = "A HOUSE \xF7 AGAINST ITSELF";
        utf8::upgrade($utf8_name);
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that latin1 symbol in utf8 name gives error';
        $utf8_name = "\x{664} HORSEMEN}";
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that leading above Latin1 digit in utf8 name gives error';
        $utf8_name = "A \x{1F4A9} WOULD SMELL AS SWEET}";
        eval "use utf8; q(W) =~ /\\N{$utf8_name}/";
        ok $@@ && $@@ =~ /Invalid character/, 'Verify that above Latin1 symbol in utf8 name gives error';

a1027 8
        # This tests the code path that restarts the parse when the recursive
        # call to S_reg() from within S_grok_bslash_N() discovers that the
        # pattern needs to be recalculated as UTF-8.  use eval to avoid
        # needing literal Unicode in this source file:
        my $r = eval "qr/\\N{\x{100}\x{100}}/";
        isnt $r, undef, "Generated regex for multi-char UTF-8 charname"
	    or diag($@@);
        ok "\x{100}\x{100}" =~ $r, "which matches";
d1591 1
a1591 1
        no warnings 'uninitialized', 'deprecated', 'experimental::lexical_topic';
a1611 1
        no warnings 'deprecated', 'experimental::lexical_topic';
d1661 1
a1749 1
            no warnings 'deprecated';
a2074 49
    {
        my $single = ":";
        my $upper = "\x{390}";  # Fold is 3 chars.
        my $multi = CORE::fc($upper);

        my $failed = 0;

        # Try forcing a node to be split, with a multi-char fold at the
        # boundary
        for my $repeat (1 .. 300) {
            my $string = $single x $repeat;
            my $lhs = $string . $upper;
            if ($lhs !~ m/$string$multi/i) {
                $failed = $repeat;
                last;
            }
        }
        ok(! $failed, "Matched multi-char fold across EXACTFish node boundaries; if failed, was at count $failed");

        $failed = 0;
        for my $repeat (1 .. 300) {
            my $string = $single x $repeat;
            my $lhs = $string . "\N{LATIN SMALL LIGATURE FFI}";
            if ($lhs !~ m/${string}ff\N{LATIN SMALL LETTER I}/i) {
                $failed = $repeat;
                last;
            }
        }
        ok(! $failed, "Matched multi-char fold across EXACTFish node boundaries; if failed, was at count $failed");

        $failed = 0;
        for my $repeat (1 .. 300) {
            my $string = $single x $repeat;
            my $lhs = $string . "\N{LATIN SMALL LIGATURE FFL}";
            if ($lhs !~ m/${string}ff\N{U+6c}/i) {
                $failed = $repeat;
                last;
            }
        }
        ok(! $failed, "Matched multi-char fold across EXACTFish node boundaries; if failed, was at count $failed");
    }

    {
        fresh_perl_is('print eval "\"\x{101}\" =~ /[[:lower:]]/", "\n"; print eval "\"\x{100}\" =~ /[[:lower:]]/i", "\n";',
                      "1\n1",   # Both re's should match
                      "",
                      "get [:lower:] swash in first eval; test under /i in second");
    }

a2136 5
            my $p = qr/^[\x{FFFF_FFFF}]$/;
            ok(chr(0xFFFF_FFFF) =~ $p,
                    "chr(0xFFFF_FFFF) can match itself in a [class]");
            ok(chr(0xFFFF_FFFF) =~ $p, # Tests any caching
                    "chr(0xFFFF_FFFF) can match itself in a [class] subsequently");
a2144 6
            my $p = qr/^[\x{FFFF_FFFF_FFFF_FFFF}]$/;
            ok(chr(0xFFFF_FFFF_FFFF_FFFF) =~ $p,
                    "chr(0xFFFF_FFFF_FFFF_FFFF) can match itself in a [class]");
            ok(chr(0xFFFF_FFFF_FFFF_FFFF) =~ $p, # Tests any caching
                    "chr(0xFFFF_FFFF_FFFF_FFFF) can match itself in a [class] subsequently");

a2155 8
    }

    { # Regexp:Grammars was broken:
  # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters/2013-06/msg01290.html
        fresh_perl_like('use warnings; "abc" =~ qr{(?&foo){0}abc(?<foo>)}',
                        'Quantifier unexpected on zero-length expression',
                        "",
                        'No segfault on qr{(?&foo){0}abc(?<foo>)}');
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d3 1
a3 1
# This is a home for regular expression tests that do not fit into
a91 1
        ok "\xd0" =~ /[\xc9-\xd1]/, '"\xd0" =~ /[\xc9-\xd1]/';
a101 1
        unlike("\xd0", qr/[I-J]/, '"\xd0" !~ /[I-J]/');
d637 1
a637 1
        my @@h = map {sprintf "%05x" => $_} 0x01680, 0x02000 .. 0x0200A,
d642 1
a642 1
                                           0x0303F,   0xE0020, 0x180E;
d644 1
a644 1
                                           0xE005F,   0xE007C, 0x180E;
a1022 1
        undef $w;
a1025 10
            # disable lexical warnings
            BEGIN { ${^WARNING_BITS} = undef; $^W = 0 }
            undef $w;
            () = eval q ["\N{TOO  MANY SPACES}"];
            like ($w, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... and returns a deprecation warning outside of lexical warnings");
            undef $w;
            eval q [use utf8; () = "\N{TOO  MANY SPACES}"];
            like ($w, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... same under utf8");
        }
        {
a1032 7
        {
            use warnings FATAL=> 'deprecated';
            () = eval q ["\N{TOO  MANY SPACES}"];
            like ($@@, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... the deprecation warning can be fatal");
            eval q [use utf8; () = "\N{TOO  MANY SPACES}"];
            like ($@@, qr/A sequence of multiple spaces in a charnames alias definition is deprecated/, "... same under utf8");
        }
a1036 1
        undef $w;
a1039 10
            # disable lexical warnings
            BEGIN { ${^WARNING_BITS} = undef; $^W = 0 }
            undef $w;
            () = eval q ["\N{TRAILING SPACE }"];
            like ($w, qr/Trailing white-space in a charnames alias definition is deprecated/, "... and returns a deprecation warning outside of lexical warnings");
            undef $w;
            eval q [use utf8; () = "\N{TRAILING SPACE }"];
            like ($w, qr/Trailing white-space in a charnames alias definition is deprecated/, "... same under utf8");
        }
        {
a1046 17
        {
            use warnings FATAL=>'deprecated';
            () = eval q ["\N{TRAILING SPACE }"];
            like ($@@, qr/Trailing white-space in a charnames alias definition is deprecated/, "... the warning can be fatal");
            eval q [use utf8; () = "\N{TRAILING SPACE }"];
            like ($@@, qr/Trailing white-space in a charnames alias definition is deprecated/, "... same under utf8");
        }

        {
            BEGIN { no strict; *CnameTest:: = *{"_charnames\0A::" } }
            package CnameTest { sub translator { pop } }
            BEGIN { $^H{charnames} = \&CnameTest::translator }
            undef $w;
            () = eval q ["\N{TOO  MANY SPACES}"];
            like ($w, qr/A sequence of multiple spaces/,
                 'translators in _charnames\0* packages get validated');
        }
a1299 2

	ok("1\n2a\n" !~ /^\d+(*COMMIT)\w+/m, "COMMIT and anchors");
d1576 1
a1576 1
        my @@h = map {chr $_}   0x09,   0x20,   0xa0, 0x1680, 0x2000,
a2180 17

        # This tests that under /d matching that an 'ss' split across two
        # parts of a node doesn't end up turning into something that matches
        # \xDF unless it is in utf8.
        $failed = 0;
        $single = 'a';  # Is non-terminal multi-char fold char
        for my $repeat (1 .. 300) {
            my $string = $single x $repeat;
            my $lhs = "$string\N{LATIN SMALL LETTER SHARP S}";
            utf8::downgrade($lhs);
            $string .= "s";
            if ($lhs =~ m/${string}s/di) {
                $failed = $repeat;
                last;
            }
        }
        ok(! $failed, "Matched multi-char fold 'ss' across EXACTF node boundaries; if failed, was at count $failed");
d2186 1
a2186 1
                      {},
a2189 54
    {
        #' RT #119075
        no warnings 'regexp';   # Silence "has useless greediness modifier"
        local $@@;
        eval { /a{0}?/; };
        ok(! $@@,
            "PCRE regression test: No 'Quantifier follows nothing in regex' warning");

    }

    {
        unlike("\xB5", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        like("\xB6", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        unlike("\xB7", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        like("\xB5", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
        unlike("\xB6", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
        like("\xB7", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");

        unlike("_\xB5", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        like("_\xB6", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        unlike("_\xB7", qr/^_?\p{IsMyRuntimeProperty}\z/, "yadayada");
        like("_\xB5", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
        unlike("_\xB6", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
        like("_\xB7", qr/^_?\P{IsMyRuntimeProperty}\z/, "yadayada");
    }

    # These are defined later, so won't be known at regex compile time above
    sub IsMyRuntimeProperty {
        return "B6\n";
    }

    sub IsntMyRuntimeProperty {
        return "!B6\n";
    }

    {   # From Lingua::Stem::UniNE; no ticket filed but related to #121778
        use utf8;
        my $word = 'рабта';
        $word =~ s{ (?:
                          ия  # definite articles for nouns:
                        | ът  # ∙ masculine
                        | та  # ∙ feminine
                        | то  # ∙ neutral
                        | те  # ∙ plural
                    ) $ }{}x;
        is($word, 'раб', "Handles UTF8 trie correctly");
    }

    { # [perl #122460]
        my $a = "rdvark";
        $a =~ /(?{})(?=[A-Za-z0-9_])a*?/g;
        is (pos $a, 0, "optimizer correctly thinks (?=...) is 0-length");
    }

d2288 1
a2288 1
                        {},
@


