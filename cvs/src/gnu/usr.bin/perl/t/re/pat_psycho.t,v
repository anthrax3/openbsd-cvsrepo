head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_1:1.1.1.5.0.6
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.8
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.2
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.4
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2015.04.25.19.10.48;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl
#
# This is a home for regular expression tests that don't fit into
# the format supported by re/regexp.t.  If you want to add a test
# that does fit that format, add it to re/re_tests, not here.

use strict;
use warnings;
use 5.010;


sub run_tests;

$| = 1;


BEGIN {
    chdir 't' if -d 't';
    @@INC = ('../lib','.');
    do "re/ReTest.pl" or die $@@;
}


plan tests => 11;  # Update this when adding/deleting tests.

run_tests() unless caller;

#
# Tests start here.
#
sub run_tests {

  SKIP:
    {
        print "# Set PERL_SKIP_PSYCHO_TEST to skip this test\n";
        my @@normal = qw [the are some normal words];

        skip "Skipped Psycho", 2 * @@normal if $ENV {PERL_SKIP_PSYCHO_TEST};

        local $" = "|";

        my @@psycho = (@@normal, map chr $_, 255 .. 20000);
        my $psycho1 = "@@psycho";
        for (my $i = @@psycho; -- $i;) {
            my $j = int rand (1 + $i);
            @@psycho [$i, $j] = @@psycho [$j, $i];
        }
        my $psycho2 = "@@psycho";

        foreach my $word (@@normal) {
            ok $word =~ /($psycho1)/ && $1 eq $word, 'Psycho';
            ok $word =~ /($psycho2)/ && $1 eq $word, 'Psycho';
        }
    }


  SKIP:
    {
        # stress test CURLYX/WHILEM.
        #
        # This test includes varying levels of nesting, and according to
        # profiling done against build 28905, exercises every code line in the
        # CURLYX and WHILEM blocks, except those related to LONGJMP, the
        # super-linear cache and warnings. It executes about 0.5M regexes

        skip "No psycho tests" if $ENV {PERL_SKIP_PSYCHO_TEST};
        print "# Set PERL_SKIP_PSYCHO_TEST to skip this test\n";
        my $r = qr/^
                    (?:
                        ( (?:a|z+)+ )
                        (?:
                            ( (?:b|z+){3,}? )
                            (
                                (?:
                                    (?:
                                        (?:c|z+){1,1}?z
                                    )?
                                    (?:c|z+){1,1}
                                )*
                            )
                            (?:z*){2,}
                            ( (?:z+|d)+ )
                            (?:
                                ( (?:e|z+)+ )
                            )*
                            ( (?:f|z+)+ )
                        )*
                        ( (?:z+|g)+ )
                        (?:
                            ( (?:h|z+)+ )
                        )*
                        ( (?:i|z+)+ )
                    )+
                    ( (?:j|z+)+ )
                    (?:
                        ( (?:k|z+)+ )
                    )*
                    ( (?:l|z+)+ )
              $/x;
          
        my $ok = 1;
        my $msg = "CURLYX stress test";
        OUTER:
          for my $a ("x","a","aa") {
            for my $b ("x","bbb","bbbb") {
              my $bs = $a.$b;
              for my $c ("x","c","cc") {
                my $cs = $bs.$c;
                for my $d ("x","d","dd") {
                  my $ds = $cs.$d;
                  for my $e ("x","e","ee") {
                    my $es = $ds.$e;
                    for my $f ("x","f","ff") {
                      my $fs = $es.$f;
                      for my $g ("x","g","gg") {
                        my $gs = $fs.$g;
                        for my $h ("x","h","hh") {
                          my $hs = $gs.$h;
                          for my $i ("x","i","ii") {
                            my $is = $hs.$i;
                            for my $j ("x","j","jj") {
                              my $js = $is.$j;
                              for my $k ("x","k","kk") {
                                my $ks = $js.$k;
                                for my $l ("x","l","ll") {
                                  my $ls = $ks.$l;
                                  if ($ls =~ $r) {
                                    if ($ls =~ /x/) {
                                      $msg .= ": unexpected match for [$ls]";
                                      $ok = 0;
                                      last OUTER;
                                    }
                                    my $cap = "$1$2$3$4$5$6$7$8$9$10$11$12";
                                    unless ($ls eq $cap) {
                                      $msg .= ": capture: [$ls], got [$cap]";
                                      $ok = 0;
                                      last OUTER;
                                    }
                                  }
                                  else {
                                    unless ($ls =~ /x/) {
                                      $msg = ": failed for [$ls]";
                                      $ok = 0;
                                      last OUTER;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
        }
        ok($ok, $msg);
    }
} # End of sub run_tests

1;
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d20 1
a20 1
    require './test.pl';
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a5 3
#
# this file includes test that my burn a lot of CPU or otherwise be heavy
# on resources. Set env var $PERL_SKIP_PSYCHO_TEST to skip this file
d24 1
a24 2
skip_all('$PERL_SKIP_PSYCHO_TEST set') if $ENV{PERL_SKIP_PSYCHO_TEST};
plan tests => 15;  # Update this when adding/deleting tests.
a31 1
    print "# Set PERL_SKIP_PSYCHO_TEST to skip these tests\n";
d33 1
d35 2
d38 1
a38 3
	# stress test tries

        my @@normal = qw [the are some normal words];
a41 1
	note "setting up trie psycho vars ...";
d51 2
a52 2
            ok $word =~ /($psycho1)/ && $1 eq $word, qq{"$word" =~ /\$psycho1/};
            ok $word =~ /($psycho2)/ && $1 eq $word, qq{"$word" =~ /\$psycho1/};
d57 1
d66 2
a159 43
    }


    {
	# these bits of test code used to run quadratically. If we break
	# anything, they'll start to take minutes to run, rather than
	# seconds. We don't actually measure times or set alarms, since
	# that tends to be very fragile and prone to false positives.
	# Instead, just hope that if someone is messing with
	# performance-related code, they'll re-run the test suite and
	# notice it suddenly takes a lot longer.

	my $x;

	$x = 'x' x 1_000_000;
	1 while $x =~ /(.)/g;
	pass "ascii =~ /(.)/";

	{
	    local ${^UTF8CACHE} = 1; # defeat debugging
	    $x = "\x{100}" x 1_000_000;
	    1 while $x =~ /(.)/g;
	    pass "utf8 =~ /(.)/";
	}

	# run these in separate processes, since they set $&

        fresh_perl_is(<<'EOF', "ok\n", {}, 'ascii =~ /(.)/, mention $&');
$&;
$x = 'x' x 1_000_000;
1 while $x =~ /(.)/g;
print "ok\n";
EOF

        fresh_perl_is(<<'EOF', "ok\n", {}, 'utf8 =~ /(.)/, mention $&');
$&;
local ${^UTF8CACHE} = 1; # defeat debugging
$x = "\x{100}" x 1_000_000;
1 while $x =~ /(.)/g;
print "ok\n";
EOF


@


1.1.1.4
log
@Import perl-5.20.1
@
text
@a69 1
        no warnings 'regexp';   # Silence "has useless greediness modifier"
a101 1
        use warnings 'regexp';
@


1.1.1.5
log
@Import perl-5.20.2
@
text
@a23 3
    if ($^O eq 'dec_osf') {
        skip_all("$^O cannot handle this test");
    }
a27 1

@


