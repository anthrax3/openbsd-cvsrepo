head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.4.0.10
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.6
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.2
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
#
# This is a home for regular expression tests that don't fit into
# the format supported by re/regexp.t.  If you want to add a test
# that does fit that format, add it to re/re_tests, not here.

sub run_tests;

$| = 1;

BEGIN {
    chdir 't' if -d 't';
    @@INC = ('../lib','.');
    require './test.pl';
    skip_all_if_miniperl("miniperl can't load Tie::Hash::NamedCapture, need for %+ and %-");
}

use strict;
use warnings;
use 5.010;
use Config;

plan tests => 2500;  # Update this when adding/deleting tests.

run_tests() unless caller;

#
# Tests start here.
#
sub run_tests {

    like("A \x{263a} B z C", qr/A . B (??{ "z" }) C/,
	 "Match UTF-8 char in presence of (??{ }); Bug 20000731.001");

    {
        no warnings 'uninitialized';
        ok(undef =~ /^([^\/]*)(.*)$/, "Used to cause a SEGV; Bug 20001021.005");
    }

    {
        my $message = 'bug id 20001008.001';

        my @@x = ("stra\337e 138", "stra\337e 138");
        for (@@x) {
            ok(s/(\d+)\s*([\w\-]+)/$1 . uc $2/e, $message);
            ok(my ($latin) = /^(.+)(?:\s+\d)/, $message);
            is($latin, "stra\337e", $message);
	    ok($latin =~ s/stra\337e/straße/, $message);
            #
            # Previous code follows, but outcommented - there were no tests.
            #
            # $latin =~ s/stra\337e/straße/; # \303\237 after the 2nd a
            # use utf8; # needed for the raw UTF-8
            # $latin =~ s!(s)tr(?:aß|s+e)!$1tr.!; # \303\237 after the a
        }
    }

    {
        # Fist half of the bug.
        my $message = 'HEBREW ACCENT QADMA matched by .*; Bug 20001028.003';
        my $X = chr (1448);
        ok(my ($Y) = $X =~ /(.*)/, $message);
        is($Y, v1448, $message);
        is(length $Y, 1, $message);

        # Second half of the bug.
        $message = 'HEBREW ACCENT QADMA in replacement; Bug 20001028.003';
        $X = '';
        $X =~ s/^/chr(1488)/e;
        is(length $X, 1, $message);
        is(ord $X, 1488, $message);
    }

    {   
        my $message = 'Repeated s///; Bug 20001108.001';
        my $X = "Szab\x{f3},Bal\x{e1}zs";
        my $Y = $X;
        $Y =~ s/(B)/$1/ for 0 .. 3;
        is($Y, $X, $message);
        is($X, "Szab\x{f3},Bal\x{e1}zs", $message);
    }

    {
        my $message = 's/// on UTF-8 string; Bug 20000517.001';
        my $x = "\x{100}A";
        $x =~ s/A/B/;
        is($x, "\x{100}B", $message);
        is(length $x, 2, $message);
    }

    {
        # The original bug report had 'no utf8' here but that was irrelevant.

        my $message = "Don't dump core; Bug 20010306.008";
        my $a = "a\x{1234}";
        like($a, qr/\w/, $message);  # used to core dump.
    }

    {
        my $message = '/g in scalar context; Bug 20010410.006';
        for my $rx ('/(.*?)\{(.*?)\}/csg',
		    '/(.*?)\{(.*?)\}/cg',
		    '/(.*?)\{(.*?)\}/sg',
		    '/(.*?)\{(.*?)\}/g',
		    '/(.+?)\{(.+?)\}/csg',) {
            my $i = 0;
            my $input = "a{b}c{d}";
            eval <<"            --";
                while (eval \$input =~ $rx) {
                    \$i ++;
                }
            --
            is($i, 2, $message);
        }
    }

    {
        # Amazingly vertical tabulator is the same in ASCII and EBCDIC.
        for ("\n", "\t", "\014", "\r") {
            unlike($_, qr/[[:print:]]/, sprintf "\\%03o not in [[:print:]]; Bug 20010619.003", ord $_);
        }
        for (" ") {
            like($_, qr/[[:print:]]/, "'$_' in [[:print:]]; Bug 20010619.003");
        }
    }

    {
        # [ID 20010814.004] pos() doesn't work when using =~m// in list context

        $_ = "ababacadaea";
        my $a = join ":", /b./gc;
        my $b = join ":", /a./gc;
        my $c = pos;
        is("$a $b $c", 'ba:ba ad:ae 10', "pos() works with () = m//; Bug 20010814.004");
    }

    {
        # [ID 20010407.006] matching utf8 return values from
        # functions does not work

        my $message = 'UTF-8 return values from functions; Bug 20010407.006';
        package ID_20010407_006;
        sub x {"a\x{1234}"}
        my $x = x;
        my $y;
      ::ok($x =~ /(..)/, $message);
        $y = $1;
      ::ok(length ($y) == 2 && $y eq $x, $message);
      ::ok(x =~ /(..)/, $message);
        $y = $1;
      ::ok(length ($y) == 2 && $y eq $x, $message);
    }

    {
        # High bit bug -- japhy
        my $x = "ab\200d";
        ok $x =~ /.*?\200/, "High bit fine";
    }

    {
        my $message = 'UTF-8 hash keys and /$/';
        # http://www.xray.mpe.mpg.de/mailing-lists/perl5-porters
        #                                         /2002-01/msg01327.html

        my $u = "a\x{100}";
        my $v = substr ($u, 0, 1);
        my $w = substr ($u, 1, 1);
        my %u = ($u => $u, $v => $v, $w => $w);
        for (keys %u) {
            my $m1 =            /^\w*$/ ? 1 : 0;
            my $m2 = $u {$_} =~ /^\w*$/ ? 1 : 0;
            is($m1, $m2, $message);
        }
    }

    {
        my $message = "s///eg [change 13f46d054db22cf4]; Bug 20020124.005";

        for my $char ("a", "\x{df}", "\x{100}") {
            my $x = "$char b $char";
            $x =~ s{($char)}{
                  "c" =~ /c/;
                  "x";
            }ge;
            is(substr ($x, 0, 1), substr ($x, -1, 1), $message);
        }
    }

    {
        my $message = "Correct pmop flags checked when empty pattern; Bug 20020412.005";

        # Requires reuse of last successful pattern.
        my $num = 123;
        $num =~ /\d/;
        for (0 .. 1) {
            my $match = m?? + 0;
            ok($match != $_, $message)
                or diag(sprintf "'match one' %s on %s iteration" =>
			$match ? 'succeeded' : 'failed',
			$_     ? 'second'    : 'first');
        }
        $num =~ /(\d)/;
        my $result = join "" => $num =~ //g;
        is($result, $num, $message);
    }

    {
        my $message = 'UTF-8 regex matches above 32k; Bug 20020630.002';
        for (['byte', "\x{ff}"], ['utf8', "\x{1ff}"]) {
            my ($type, $char) = @@$_;
            for my $len (32000, 32768, 33000) {
                my  $s = $char . "f" x $len;
                my  $r = $s =~ /$char([f]*)/gc;
                ok($r, $message) or diag("<$type x $len>");
                ok(!$r || pos ($s) == $len + 1, $message)
		    or diag("<$type x $len>; pos = @@{[pos $s]}");
            }
        }
    }

    {
        my $s = "\x{100}" x 5;
        my $ok = $s =~ /(\x{100}{4})/;
        my ($ord, $len) = (ord $1, length $1);
        ok $ok && $ord == 0x100 && $len == 4, "No panic: end_shift [change 0e933229fa758625]";
    }

    {
        my $message = 'UTF-8 matching; Bug 15397';
        like("\x{100}", qr/\x{100}/, $message);
        like("\x{100}", qr/(\x{100})/, $message);
        like("\x{100}", qr/(\x{100}){1}/, $message);
        like("\x{100}\x{100}", qr/(\x{100}){2}/, $message);
        like("\x{100}\x{100}", qr/(\x{100})(\x{100})/, $message);
    }

    {
        my $message = 'Neither ()* nor ()*? sets $1 when matched 0 times; Bug 7471';
        local $_       = 'CD';
        ok(/(AB)*?CD/ && !defined $1, $message);
        ok(/(AB)*CD/  && !defined $1, $message);
    }

    {
        my $message = "Caching shouldn't prevent match; Bug 3547";
        my $pattern = "^(b+?|a){1,2}c";
        ok("bac"    =~ /$pattern/ && $1 eq 'a', $message);
        ok("bbac"   =~ /$pattern/ && $1 eq 'a', $message);
        ok("bbbac"  =~ /$pattern/ && $1 eq 'a', $message);
        ok("bbbbac" =~ /$pattern/ && $1 eq 'a', $message);
    }

    {
        ok("\x{100}" =~ /(.)/, '$1 should keep UTF-8 ness; Bug 18232');
        is($1, "\x{100}",  '$1 is UTF-8; Bug 18232');
        { 'a' =~ /./; }
        is($1, "\x{100}",  '$1 is still UTF-8; Bug 18232');
        isnt($1, "\xC4\x80", '$1 is not non-UTF-8; Bug 18232');
    }

    {
        my $message = "Optimizer doesn't prematurely reject match; Bug 19767";
        use utf8;

        my $attr = 'Name-1';
        my $NormalChar      = qr /[\p{IsDigit}\p{IsLower}\p{IsUpper}]/;
        my $NormalWord      = qr /${NormalChar}+?/;
        my $PredNameHyphen  = qr /^${NormalWord}(\-${NormalWord})*?$/;

        $attr =~ /^$/;
        like($attr, $PredNameHyphen, $message);  # Original test.

        "a" =~ m/[b]/;
        like("0", qr/\p{N}+\z/, $message);         # Variant.
    }

    {
        my $message = "(??{ }) doesn't return stale values; Bug 20683";
        our $p = 1;
        foreach (1, 2, 3, 4) {
            $p ++ if /(??{ $p })/
        }
        is($p, 5, $message);

        {
            package P;
            $a = 1;
            sub TIESCALAR {bless []}
            sub FETCH     {$a ++}
        }
        tie $p, "P";
        foreach (1, 2, 3, 4) {
            /(??{ $p })/
        }
        is($p, 5, $message);
    }

    {
        # Subject: Odd regexp behavior
        # From: Markus Kuhn <Markus.Kuhn@@cl.cam.ac.uk>
        # Date: Wed, 26 Feb 2003 16:53:12 +0000
        # Message-Id: <E18o4nw-0008Ly-00@@wisbech.cl.cam.ac.uk>
        # To: perl-unicode@@perl.org

        my $message = 'Markus Kuhn 2003-02-26';
    
        my $x = "\x{2019}\nk";
        ok($x =~ s/(\S)\n(\S)/$1 $2/sg, $message);
        is($x, "\x{2019} k", $message);

        $x = "b\nk";
        ok($x =~ s/(\S)\n(\S)/$1 $2/sg, $message);
        is($x, "b k", $message);

        like("\x{2019}", qr/\S/, $message);
    }

    {
        my $message = "(??{ .. }) in split doesn't corrupt its stack; Bug 21411";
        our $i;
        is('-1-3-5-', join('', split /((??{$i++}))/, '-1-3-5-'), $message);
        no warnings 'syntax';
        @@_ = split /(?{'WOW'})/, 'abc';
        local $" = "|";
        is("@@_", "a|b|c", $message);
    }

    is(join('-', split /(?{ split "" })/, "abc"), 'a-b-c', 'nested split');

    {
        $_ = "code:   'x' { '...' }\n"; study;
        my @@x; push @@x, $& while m/'[^\']*'/gx;
        local $" = ":";
        is("@@x", "'x':'...'", "Parse::RecDescent triggered infinite loop; Bug 17757");
    }

    {
        sub func ($) {
            ok("a\nb" !~ /^b/,  "Propagated modifier; $_[0]; Bug 22354");
            ok("a\nb" =~ /^b/m, "Propagated modifier; $_[0] - with /m; Bug 22354");
        }
        func "standalone";
        $_ = "x"; s/x/func "in subst"/e;
        $_ = "x"; s/x/func "in multiline subst"/em;
        $_ = "x"; /x(?{func "in regexp"})/;
        $_ = "x"; /x(?{func "in multiline regexp"})/m;
    }

    {
        $_    = "abcdef\n";
        my @@x = m/./g;
        is("abcde", $`, 'Global match sets $`; Bug 19049');
    }

    {
        # [perl #23769] Unicode regex broken on simple example
        # regrepeat() didn't handle UTF-8 EXACT case right.

        my $Mess       = 'regrepeat() handles UTF-8 EXACT case right';
        my $message = "$Mess; Bug 23769";

        my $s = "\x{a0}\x{a0}\x{a0}\x{100}"; chop $s;

        like($s, qr/\x{a0}/, $message);
        like($s, qr/\x{a0}+/, $message);
        like($s, qr/\x{a0}\x{a0}/, $message);

        $message = "$Mess (easy variant); Bug 23769";
        ok("aaa\x{100}" =~ /(a+)/, $message);
        is($1, "aaa", $message);

        $message = "$Mess (easy invariant); Bug 23769";
        ok("aaa\x{100}     " =~ /(a+?)/, $message);
        is($1, "a", $message);

        $message = "$Mess (regrepeat variant); Bug 23769";
        ok("\xa0\xa0\xa0\x{100}    " =~ /(\xa0+?)/, $message);
        is($1, "\xa0", $message);

        $message = "$Mess (regrepeat invariant); Bug 23769";
        ok("\xa0\xa0\xa0\x{100}" =~ /(\xa0+)/, $message);
        is($1, "\xa0\xa0\xa0", $message);

        $message = "$Mess (hard variant); Bug 23769";
        ok("\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+?)/, $message);
        is($1, "\xa0\xa1", $message);

        $message = "$Mess (hard invariant); Bug 23769";
        ok("ababab\x{100}  " =~ /((?:ab)+)/, $message);
        is($1, 'ababab', $message);

        ok("\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+)/, $message);
        is($1, "\xa0\xa1\xa0\xa1\xa0\xa1", $message);

        ok("ababab\x{100}  " =~ /((?:ab)+?)/, $message);
        is($1, "ab", $message);

        $message = "Don't match first byte of UTF-8 representation; Bug 23769";
        unlike("\xc4\xc4\xc4", qr/(\x{100}+)/, $message);
        unlike("\xc4\xc4\xc4", qr/(\x{100}+?)/, $message);
        unlike("\xc4\xc4\xc4", qr/(\x{100}++)/, $message);
    }

    {
        # perl panic: pp_match start/end pointers

        is(eval {my ($x, $y) = "bca" =~ /^(?=.*(a)).*(bc)/; "$x-$y"}, "a-bc",
	   'Captures can move backwards in string; Bug 25269');
    }

    {
        # \cA not recognized in character classes
        like("a\cAb", qr/\cA/, '\cA in pattern; Bug 27940');
        like("a\cAb", qr/[\cA]/, '\cA in character class; Bug 27940');
        like("a\cAb", qr/[\cA-\cB]/, '\cA in character class range; Bug 27940');
        like("abc", qr/[^\cA-\cB]/, '\cA in negated character class range; Bug 27940');
        like("a\cBb", qr/[\cA-\cC]/, '\cB in character class range; Bug 27940');
        like("a\cCbc", qr/[^\cA-\cB]/, '\cC in negated character class range; Bug 27940');
        like("a\cAb", qr/(??{"\cA"})/, '\cA in ??{} pattern; Bug 27940');
        unlike("ab", qr/a\cIb/x, '\cI in pattern; Bug 27940');
    }

    {
        # perl #28532: optional zero-width match at end of string is ignored

        ok("abc" =~ /^abc(\z)?/ && defined($1),
           'Optional zero-width match at end of string; Bug 28532');
        ok("abc" =~ /^abc(\z)??/ && !defined($1),
           'Optional zero-width match at end of string; Bug 28532');
    }

    {
        my $utf8 = "\xe9\x{100}"; chop $utf8;
        my $latin1 = "\xe9";

        like($utf8, qr/\xe9/i, "utf8/latin; Bug 36207");
        like($utf8, qr/$latin1/i, "utf8/latin runtime; Bug 36207");
        like($utf8, qr/(abc|\xe9)/i, "utf8/latin trie; Bug 36207");
        like($utf8, qr/(abc|$latin1)/i, "utf8/latin trie runtime; Bug 36207");

        like("\xe9", qr/$utf8/i, "latin/utf8; Bug 36207");
        like("\xe9", qr/(abc|$utf8)/i, "latin/utf8 trie; Bug 36207");
        like($latin1, qr/$utf8/i, "latin/utf8 runtime; Bug 36207");
        like($latin1, qr/(abc|$utf8)/i, "latin/utf8 trie runtime; Bug 36207");
    }

    {
        my $s = "abcd";
        $s =~ /(..)(..)/g;
        $s = $1;
        $s = $2;
        is($2, 'cd',
	   "Assigning to original string does not corrupt match vars; Bug 37038");
    }

    {
        {
            package wooosh;
            sub gloople {"!"}
        }
        my $aeek = bless {} => 'wooosh';
        is(do {$aeek -> gloople () =~ /(.)/g}, 1,
	   "//g match against return value of sub [change e26a497577f3ce7b]");

        sub gloople {"!"}
        is(do{gloople () =~ /(.)/g}, 1,
	   "change e26a497577f3ce7b didn't affect sub calls for some reason");
    }

    {
        # [perl #78680]
        # See changes 26925-26928, which reverted change 26410
        {
            package lv;
            our $var = "abc";
            sub variable : lvalue {$var}
        }
        my $o = bless [] => 'lv';
        my $f = "";
        my $r = eval {
            for (1 .. 2) {
                $f .= $1 if $o -> variable =~ /(.)/g;
            }
            1;
        };
        if ($r) {
            is($f, "ab", "pos() retained between calls");
        }
        else {
            ok 0, "Code failed: $@@";
        }

        our $var = "abc";
        sub variable : lvalue {$var}
        my $g = "";
        my $s = eval {
            for (1 .. 2) {
                $g .= $1 if variable =~ /(.)/g;
            }
            1;
        };
        if ($s) {
            is($g, "ab", "pos() retained between calls");
        }
        else {
            ok 0, "Code failed: $@@";
        }
    }

  SKIP:
    {
        skip "In EBCDIC and unclear what would trigger this bug there" if $::IS_EBCDIC;
        no warnings 'utf8';
        $_ = pack 'U0C2', 0xa2, 0xf8;  # Ill-formed UTF-8
        my $ret = 0;
        is(do {!($ret = s/[\0]+//g)}, 1,
	   "Ill-formed UTF-8 doesn't match NUL in class; Bug 37836");
    }

    {
        # chr(65535) should be allowed in regexes

        no warnings 'utf8'; # To allow non-characters
        my ($c, $r, $s);

        $c = chr 0xffff;
        $c =~ s/$c//g;
        is($c, "", "U+FFFF, parsed as atom; Bug 38293");

        $c = chr 0xffff;
        $r = "\\$c";
        $c =~ s/$r//g;
        is($c, "", "U+FFFF backslashed, parsed as atom; Bug 38293");

        $c = chr 0xffff;
        $c =~ s/[$c]//g;
        is($c, "", "U+FFFF, parsed in class; Bug 38293");

        $c = chr 0xffff;
        $r = "[\\$c]";
        $c =~ s/$r//g;
        is($c, "", "U+FFFF backslashed, parsed in class; Bug 38293");

        $s = "A\x{ffff}B";
        $s =~ s/\x{ffff}//i;
        is($s, "AB", "U+FFFF, EXACTF; Bug 38293");

        $s = "\x{ffff}A";
        $s =~ s/\bA//;
        is($s, "\x{ffff}", "U+FFFF, BOUND; Bug 38293");

        $s = "\x{ffff}!";
        $s =~ s/\B!//;
        is($s, "\x{ffff}", "U+FFFF, NBOUND; Bug 38293");
    }

    {
        
        # The printing characters
        my @@chars = ("A" .. "Z");
        my $delim = ",";
        my $size = 32771 - 4;
        my $str = '';

        # Create some random junk. Inefficient, but it works.
        for (my $i = 0; $i < $size; $ i++) {
            $str .= $chars [rand @@chars];
        }

        $str .= ($delim x 4);
        my $res;
        my $matched;
        ok($str =~ s/^(.*?)${delim}{4}//s, "Pattern matches; Bug 39583");
        is($str, "", "Empty string; Bug 39583");
        ok(defined $1 && length ($1) == $size, '$1 is correct size; Bug 39583');
    }

    {
        like("\0-A", qr/\c@@-A/, '@@- should not be interpolated in a pattern; Bug 27940');
        like("\0\0A", qr/\c@@+A/, '@@+ should not be interpolated in a pattern; Bug 27940');
        like("X\@@-A", qr/X@@-A/, '@@- should not be interpolated in a pattern; Bug 27940');
        like("X\@@\@@A", qr/X@@+A/, '@@+ should not be interpolated in a pattern; Bug 27940');

        like("X\0A", qr/X\c@@?A/,  '\c@@?; Bug 27940');
        like("X\0A", qr/X\c@@*A/,  '\c@@*; Bug 27940');
        like("X\0A", qr/X\c@@(A)/, '\c@@(; Bug 27940');
        like("X\0A", qr/X(\c@@)A/, '\c@@); Bug 27940');
        like("X\0A", qr/X\c@@|ZA/, '\c@@|; Bug 27940');

        like("X\@@A", qr/X@@?A/,  '@@?; Bug 27940');
        like("X\@@A", qr/X@@*A/,  '@@*; Bug 27940');
        like("X\@@A", qr/X@@(A)/, '@@(; Bug 27940');
        like("X\@@A", qr/X(@@)A/, '@@); Bug 27940');
        like("X\@@A", qr/X@@|ZA/, '@@|; Bug 27940');

        local $" = ','; # non-whitespace and non-RE-specific
        like('abc', qr/(.)(.)(.)/, 'The last successful match is bogus; Bug 27940');
        like("A@@+B", qr/A@@{+}B/,  'Interpolation of @@+ in /@@{+}/; Bug 27940');
        like("A@@-B", qr/A@@{-}B/,  'Interpolation of @@- in /@@{-}/; Bug 27940');
        like("A@@+B", qr/A@@{+}B/x, 'Interpolation of @@+ in /@@{+}/x; Bug 27940');
        like("A@@-B", qr/A@@{-}B/x, 'Interpolation of @@- in /@@{-}/x; Bug 27940');
    }

    {
        my $s = 'foo bar baz';
        my (@@k, @@v, @@fetch, $res);
        my $count = 0;
        my @@names = qw ($+{A} $+{B} $+{C});
        if ($s =~ /(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz)/) {
            while (my ($k, $v) = each (%+)) {
                $count++;
            }
            @@k = sort keys   (%+);
            @@v = sort values (%+);
            $res = 1;
            push @@fetch,
                ["$+{A}", "$1"],
                ["$+{B}", "$2"],
                ["$+{C}", "$3"],
            ;
        } 
        foreach (0 .. 2) {
            if ($fetch [$_]) {
                is($fetch[$_][0], $fetch[$_][1], "$names[$_]; Bug 50496");
            } else {
                ok 0, $names[$_];
            }
        }
        is($res, 1, "'$s' =~ /(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz)/; Bug 50496");
        is($count, 3, "Got 3 keys in %+ via each; Bug 50496");
        is(0 + @@k, 3, "Got 3 keys in %+ via keys; Bug 50496");
        is("@@k", "A B C", "Got expected keys; Bug 50496");
        is("@@v", "bar baz foo", "Got expected values; Bug 50496");
        eval '
            no warnings "uninitialized";
            print for $+ {this_key_doesnt_exist};
        ';
        is($@@, '', 'lvalue $+ {...} should not throw an exception; Bug 50496');
    }

    {
        #
        # Almost the same as the block above, except that the capture is nested.
        #

        my $s = 'foo bar baz';
        my (@@k, @@v, @@fetch, $res);
        my $count = 0;
        my @@names = qw ($+{A} $+{B} $+{C} $+{D});
        if ($s =~ /(?<D>(?<A>foo)\s+(?<B>bar)?\s+(?<C>baz))/) {
            while (my ($k,$v) = each(%+)) {
                $count++;
            }
            @@k = sort keys   (%+);
            @@v = sort values (%+);
            $res = 1;
            push @@fetch,
                ["$+{A}", "$2"],
                ["$+{B}", "$3"],
                ["$+{C}", "$4"],
                ["$+{D}", "$1"],
            ;
        }
        foreach (0 .. 3) {
            if ($fetch [$_]) {
                is($fetch[$_][0], $fetch[$_][1], "$names[$_]; Bug 50496");
            } else {
                ok 0, $names [$_];
            }
        }
        is($res, 1, "'$s' =~ /(?<D>(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz))/; Bug 50496");
        is($count, 4, "Got 4 keys in %+ via each; Bug 50496");
        is(@@k, 4, "Got 4 keys in %+ via keys; Bug 50496");
        is("@@k", "A B C D", "Got expected keys; Bug 50496");
        is("@@v", "bar baz foo foo bar baz", "Got expected values; Bug 50496");
        eval '
            no warnings "uninitialized";
            print for $+ {this_key_doesnt_exist};
        ';
        is($@@, '', 'lvalue $+ {...} should not throw an exception; Bug 50496');
    }

    {
        my $str = 'abc'; 
        my $count = 0;
        my $mval = 0;
        my $pval = 0;
        while ($str =~ /b/g) {$mval = $#-; $pval = $#+; $count ++}
        is($mval,  0, '@@- should be empty; Bug 36046');
        is($pval,  0, '@@+ should be empty; Bug 36046');
        is($count, 1, 'Should have matched once only; Bug 36046');
    }

    {
        my $message = '/m in precompiled regexp; Bug 40684';
        my $s = "abc\ndef";
        my $rex = qr'^abc$'m;
        ok($s =~ m/$rex/, $message);
        ok($s =~ m/^abc$/m, $message);
    }

    {
        my $message = '(?: ... )? should not lose $^R; Bug 36909';
        $^R = 'Nothing';
        {
            local $^R = "Bad";
            ok('x foofoo y' =~ m {
                      (foo) # $^R correctly set
                      (?{ "last regexp code result" })
            }x, $message);
            is($^R, 'last regexp code result', $message);
        }
        is($^R, 'Nothing', $message);

        {
            local $^R = "Bad";

            ok('x foofoo y' =~ m {
                      (?:foo|bar)+ # $^R correctly set
                      (?{ "last regexp code result" })
            }x, $message);
            is($^R, 'last regexp code result', $message);
        }
        is($^R, 'Nothing', $message);

        {
            local $^R = "Bad";
            ok('x foofoo y' =~ m {
                      (foo|bar)\1+ # $^R undefined
                      (?{ "last regexp code result" })
            }x, $message);
            is($^R, 'last regexp code result', $message);
        }
        is($^R, 'Nothing', $message);

        {
            local $^R = "Bad";
            ok('x foofoo y' =~ m {
                      (foo|bar)\1 # This time without the +
                      (?{"last regexp code result"})
            }x, $message);
            is($^R, 'last regexp code result', $message);
        }
        is($^R, 'Nothing', $message);
    }

    {
        my $message = 'Match is linear, not quadratic; Bug 22395';
        our $count;
        for my $l (10, 100, 1000) {
            $count = 0;
            ('a' x $l) =~ /(.*)(?{$count++})[bc]/;
            local $::TODO = "Should be L+1 not L*(L+3)/2 (L=$l)";
            is($count, $l + 1, $message);
        }
    }

    {
        my $message = '@@-/@@+ should not have undefined values; Bug 22614';
        local $_ = 'ab';
        our @@len = ();
        /(.){1,}(?{push @@len,0+@@-})(.){1,}(?{})^/;
        is("@@len", "2 2 2", $message);
    }

    {
        my $message = '$& set on s///; Bug 18209';
        my $text = ' word1 word2 word3 word4 word5 word6 ';

        my @@words = ('word1', 'word3', 'word5');
        my $count;
        foreach my $word (@@words) {
            $text =~ s/$word\s//gi; # Leave a space to separate words
                                    # in the resultant str.
            # The following block is not working.
            if ($&) {
                $count ++;
            }
            # End bad block
        }
        is($count, 3, $message);
        is($text, ' word2 word4 word6 ', $message);
    }

    {
        # RT#6893

        local $_ = qq (A\nB\nC\n); 
        my @@res;
        while (m#(\G|\n)([^\n]*)\n#gsx) { 
            push @@res, "$2"; 
            last if @@res > 3;
        }
        is("@@res", "A B C", "/g pattern shouldn't infinite loop; Bug 6893");
    }

    {
        # No optimizer bug
        my @@tails  = ('', '(?(1))', '(|)', '()?');    
        my @@quants = ('*','+');
        my $doit = sub {
            my $pats = shift;
            for (@@_) {
                for my $pat (@@$pats) {
                    for my $quant (@@quants) {
                        for my $tail (@@tails) {
                            my $re = "($pat$quant\$)$tail";
                            ok(/$re/  && $1 eq $_, "'$_' =~ /$re/; Bug 41010");
                            ok(/$re/m && $1 eq $_, "'$_' =~ /$re/m; Bug 41010");
                        }
                    }
                }
            }
        };    
        
        my @@dpats = ('\d',
                     '[1234567890]',
                     '(1|[23]|4|[56]|[78]|[90])',
                     '(?:1|[23]|4|[56]|[78]|[90])',
                     '(1|2|3|4|5|6|7|8|9|0)',
                     '(?:1|2|3|4|5|6|7|8|9|0)');
        my @@spats = ('[ ]', ' ', '( |\t)', '(?: |\t)', '[ \t]', '\s');
        my @@sstrs = ('  ');
        my @@dstrs = ('12345');
        $doit -> (\@@spats, @@sstrs);
        $doit -> (\@@dpats, @@dstrs);
    }

    {
        # [perl #45605] Regexp failure with utf8-flagged and byte-flagged string

        my $utf_8 = "\xd6schel";
        utf8::upgrade ($utf_8);
        $utf_8 =~ m {(\xd6|&Ouml;)schel};
        is($1, "\xd6", "Upgrade error; Bug 45605");
    }

    {
        # Regardless of utf8ness any character matches itself when 
        # doing a case insensitive match. See also [perl #36207] 

        for my $o (0 .. 255) {
            my @@ch = (chr ($o), chr ($o));
            utf8::upgrade ($ch [1]);
            for my $u_str (0, 1) {
                for my $u_pat (0, 1) {
                    like($ch[$u_str], qr/\Q$ch[$u_pat]\E/i,
			 "\$c =~ /\$c/i : chr ($o) : u_str = $u_str u_pat = $u_pat; Bug 36207");
                    like($ch[$u_str], qr/\Q$ch[$u_pat]\E|xyz/i,
			 "\$c=~/\$c|xyz/i : chr($o) : u_str = $u_str u_pat = $u_pat; Bug 36207");
                }
            }
        }
    }

    {
         my $message = '$REGMARK in replacement; Bug 49190';
         our $REGMARK;
         local $_ = "A";
         ok(s/(*:B)A/$REGMARK/, $message);
         is($_, "B", $message);
         $_ = "CCCCBAA";
         ok(s/(*:X)A+|(*:Y)B+|(*:Z)C+/$REGMARK/g, $message);
         is($_, "ZYX", $message);
         # Use a longer name to force reallocation of $REGMARK.
         $_ = "CCCCBAA";
         ok(s/(*:X)A+|(*:YYYYYYYYYYYYYYYY)B+|(*:Z)C+/$REGMARK/g, $message);
         is($_, "ZYYYYYYYYYYYYYYYYX", $message);
    }

    {
        my $message = 'Substitution evaluation in list context; Bug 52658';
        my $reg = '../xxx/';
        my @@te  = ($reg =~ m{^(/?(?:\.\./)*)},
                   $reg =~ s/(x)/'b'/eg > 1 ? '##' : '++');
        is($reg, '../bbb/', $message);
        is($te [0], '../', $message);
    }

    {
        my $a = "xyzt" x 8192;
        like($a, qr/\A(?>[a-z])*\z/,
	     '(?>) does not cause wrongness on long string; Bug 60034');
        my $b = $a . chr 256;
        chop $b;
	is($a, $b, 'Bug 60034');
        like($b, qr/\A(?>[a-z])*\z/,
	     '(?>) does not cause wrongness on long string with UTF-8; Bug 60034');
    }

    #
    # Keep the following tests last -- they may crash perl
    #
    print "# Tests that follow may crash perl\n";
    {   

        my $message = 'Pattern in a loop, failure should not ' .
                         'affect previous success; Bug 19049/38869';
        my @@list = (
            'ab cdef',             # Matches regex
            ('e' x 40000 ) .'ab c' # Matches not, but 'ab c' matches part of it
        );
        my $y;
        my $x;
        foreach (@@list) {
            m/ab(.+)cd/i; # The ignore-case seems to be important
            $y = $1;      # Use $1, which might not be from the last match!
            $x = substr ($list [0], $- [0], $+ [0] - $- [0]);
        }
        is($y, ' ', $message);
        is($x, 'ab cd', $message);
    }

    SKIP: {
        skip("Can run out of memory on os390", 1) if $^O eq 'os390';
        ok (("a" x (2 ** 15 - 10)) =~ /^()(a|bb)*$/, "Recursive stack cracker; Bug 24274");
    }
    {
        ok ((q(a)x 100) =~ /^(??{'(.)'x 100})/, 
            "Regexp /^(??{'(.)'x 100})/ crashes older perls; Bug 24274");
    }

    {
        # [perl #45337] utf8 + "[a]a{2}" + /$.../ = panic: sv_len_utf8 cache

        local ${^UTF8CACHE} = -1;
        my $message = "Shouldn't panic; Bug 45337";
        my $s = "[a]a{2}";
        utf8::upgrade $s;
        like("aaa", qr/$s/, $message);
    }
    {
	my $message = "Check if tree logic breaks \$^R; Bug 57042";
	my $cond_re = qr/\s*
	    \s* (?:
		   \( \s* A  (?{1})
		 | \( \s* B  (?{2})
	       )
	   /x;
	my @@res;
	for my $line ("(A)","(B)") {
	   if ($line =~ m/$cond_re/) {
	       push @@res, $^R ? "#$^R" : "UNDEF";
	   }
	}
	is("@@res","#1 #2", $message);
    }
    {
	no warnings 'closure';
	my $re = qr/A(??{"1"})/;
	ok "A1B" =~ m/^((??{ $re }))((??{"B"}))$/;
	ok $1 eq "A1";
	ok $2 eq "B";
    }

    # This only works under -DEBUGGING because it relies on an assert().
    {
	# Check capture offset re-entrancy of utf8 code.

        sub fswash { $_[0] =~ s/([>X])//g; }

        my $k1 = "." x 4 . ">>";
        fswash($k1);

        my $k2 = "\x{f1}\x{2022}";
        $k2 =~ s/([\360-\362])/>/g;
        fswash($k2);

        is($k2, "\x{2022}", "utf8::SWASHNEW doesn't cause capture leaks; Bug 60508");
    }

    {
	# minimal CURLYM limited to 32767 matches
	my @@pat = (
	    qr{a(x|y)*b},	# CURLYM
	    qr{a(x|y)*?b},	# .. with minmod
	    qr{a([wx]|[yz])*b},	# .. and without tries
	    qr{a([wx]|[yz])*?b},
	);
	my $len = 32768;
	my $s = join '', 'a', 'x' x $len, 'b';
	for my $pat (@@pat) {
	    like($s, $pat, "$pat; Bug 65372");
	}
    }

    {
        local $::TODO = "[perl #38133]";

        "A" =~ /(((?:A))?)+/;
        my $first = $2;

        "A" =~ /(((A))?)+/;
        my $second = $2;

        is($first, $second);
    }    

    {
       my $message
        = 'utf8 =~ /trie/ where trie matches a continuation octet; Bug 70998';

       # Catch warnings:
       my $w;
       local $SIG{__WARN__} = sub { $w .= shift };

       # This bug can be reduced to
       qq{\x{30ab}} =~ /\xab|\xa9/;
       # but it's nice to have a more 'real-world' test. The original test
       # case from the RT ticket follows:

       my %conv = (
                   "\xab"     => "&lt;",
                   "\xa9"     => "(c)",
                  );
       my $conv_rx = '(' . join('|', map { quotemeta } keys %conv) . ')';
       $conv_rx = qr{$conv_rx};

       my $x
        = qq{\x{3042}\x{304b}\x{3055}\x{305f}\x{306a}\x{306f}\x{307e}}
        . qq{\x{3084}\x{3089}\x{308f}\x{3093}\x{3042}\x{304b}\x{3055}}
        . qq{\x{305f}\x{306a}\x{306f}\x{307e}\x{3084}\x{3089}\x{308f}}
        . qq{\x{3093}\x{30a2}\x{30ab}\x{30b5}\x{30bf}\x{30ca}\x{30cf}}
        . qq{\x{30de}\x{30e4}\x{30e9}\x{30ef}\x{30f3}\x{30a2}\x{30ab}}
        . qq{\x{30b5}\x{30bf}\x{30ca}\x{30cf}\x{30de}\x{30e4}\x{30e9}}
        . qq{\x{30ef}\x{30f3}\x{30a2}\x{30ab}\x{30b5}\x{30bf}\x{30ca}}
        . qq{\x{30cf}\x{30de}\x{30e4}\x{30e9}\x{30ef}\x{30f3}};

       $x =~ s{$conv_rx}{$conv{$1}}eg;

       is($w, undef, $message);
    }

    {
        # minimal CURLYM limited to 32767 matches

        is(join("-", "   abc   def  " =~ /(?=(\S+))/g), "abc-bc-c-def-ef-f",
	   'stclass optimisation does not break + inside (?=); Bug 68564');
    }

    {
        use charnames ":full";
        # Delayed interpolation of \N'
        my $r1 = qr/\N{THAI CHARACTER SARA I}/;
        my $s1 = "\x{E34}\x{E34}\x{E34}\x{E34}";

        # Bug #56444
        ok $s1 =~ /$r1+/, 'my $r1 = qr/\N{THAI CHARACTER SARA I}/; my $s1 = "\x{E34}\x{E34}\x{E34}\x{E34}; $s1 =~ /$r1+/';

        # Bug #62056
        ok "${s1}A" =~ m/$s1\N{LATIN CAPITAL LETTER A}/, '"${s1}A" =~ m/$s1\N{LATIN CAPITAL LETTER A}/';

        ok "abbbbc" =~ m/\N{1}/ && $& eq "a", '"abbbbc" =~ m/\N{1}/ && $& eq "a"';
        ok "abbbbc" =~ m/\N{3,4}/ && $& eq "abbb", '"abbbbc" =~ m/\N{3,4}/ && $& eq "abbb"';
    }

    {
        use charnames ":full";
        my $message = '[perl #74982] Period coming after \N{}';
        ok("\x{ff08}." =~ m/\N{FULLWIDTH LEFT PARENTHESIS}./ && $& eq "\x{ff08}.", $message);
        ok("\x{ff08}." =~ m/[\N{FULLWIDTH LEFT PARENTHESIS}]./ && $& eq "\x{ff08}.", $message);
    }

SKIP: {
    ######## "Segfault using HTML::Entities", Richard Jolly <richardjolly@@mac.com>, <A3C7D27E-C9F4-11D8-B294-003065AE00B6@@mac.com> in perl-unicode@@perl.org

    skip('Perl configured without Encode module', 1)
	unless $Config{extensions} =~ / Encode /;

    # Test case cut down by jhi
    fresh_perl_like(<<'EOP', qr!Malformed UTF-8 character \(unexpected end of string\) in substitution \(s///\) at!, {}, 'Segfault using HTML::Entities');
use Encode;
my $t = ord('A') == 193 ? "\xEA" : "\xE9";
Encode::_utf8_on($t);
$t =~ s/([^a])//ge;
EOP
    }

    {
        # pattern must be compiled late or we can break the test file
        my $message = '[perl #115050] repeated nothings in a trie can cause panic';
        my $pattern;
        $pattern = '[xyz]|||';
        ok("blah blah" =~ /$pattern/, $message);
        ok("blah blah" =~ /(?:$pattern)h/, $message);
        $pattern = '|||[xyz]';
        ok("blah blah" =~ /$pattern/, $message);
        ok("blah blah" =~ /(?:$pattern)h/, $message);
    }

    {
        # [perl #4289] First mention $& after a match
	local $::TODO = "these tests fail without Copy-on-Write enabled"
	    if $Config{ccflags} =~ /PERL_NO_COW/;
        fresh_perl_is(
            '$_ = "abc"; /b/g; $_ = "hello"; print eval q|$&|, "\n"',
            "b\n", {}, '$& first mentioned after match');
        fresh_perl_is(
            '$_ = "abc"; /b/g; $_ = "hello"; print eval q|$`|, "\n"',
            "a\n", {}, '$` first mentioned after match');
        fresh_perl_is(
            '$_ = "abc"; /b/g; $_ = "hello"; print eval q|$\'|,"\n"',
            "c\n", {}, '$\' first mentioned after match');
    }

    {
	# [perl #118175] threaded perl-5.18.0 fails pat_rt_report_thr.t
	# this tests some related failures
	#
	# The tests in the block *only* fail when run on 32-bit systems
	# with a malloc that allocates above the 2GB line.  On the system
	# in the report above that only happened in a thread.
	my $s = "\x{1ff}" . "f" x 32;
	ok($s =~ /\x{1ff}[[:alpha:]]+/gca, "POSIXA pointer wrap");
    }
} # End of sub run_tests

1;
@


1.1
log
@Initial revision
@
text
@a6 5
use strict;
use warnings;
use 5.010;


a10 1

d14 2
a15 1
    do "re/ReTest.pl" or die $@@;
d18 4
d23 1
a23 1
plan tests => 2511;  # Update this when adding/deleting tests.
d32 2
a35 8
        local $BugId = '20000731.001';
        ok "A \x{263a} B z C" =~ /A . B (??{ "z" }) C/,
           "Match UTF-8 char in presense of (??{ })";
    }


    {
        local $BugId = '20001021.005';
d37 1
a37 1
        ok undef =~ /^([^\/]*)(.*)$/, "Used to cause a SEGV";
d41 1
a41 1
        local $Message = 'bug id 20001008.001';
d45 4
a48 4
            ok s/(\d+)\s*([\w\-]+)/$1 . uc $2/e;
            ok my ($latin) = /^(.+)(?:\s+\d)/;
            iseq $latin, "stra\337e";
	    ok $latin =~ s/stra\337e/straße/;
a57 1

a58 2
        local $BugId   = '20001028.003';

d60 1
a60 1
        local $Message = 'HEBREW ACCENT QADMA matched by .*';
d62 3
a64 3
        ok my ($Y) = $X =~ /(.*)/;
        iseq $Y, v1448;
        iseq length ($Y), 1;
d67 1
a67 1
        $Message = 'HEBREW ACCENT QADMA in replacement';
d70 2
a71 2
        iseq length $X, 1;
        iseq ord ($X), 1488;
a73 1

d75 1
a75 2
        local $BugId   = '20001108.001';
        local $Message = 'Repeated s///';
d79 2
a80 2
        iseq $Y, $X;
        iseq $X, "Szab\x{f3},Bal\x{e1}zs";
a82 1

d84 1
a84 2
        local $BugId   = '20000517.001';
        local $Message = 's/// on UTF-8 string';
d87 2
a88 2
        iseq $x, "\x{100}B";
        iseq length $x, 2;
a90 1

d92 1
a92 5
        local $BugId   = '20001230.002';
        local $Message = '\C and É';
        ok "École" =~ /^\C\C(.)/ && $1 eq 'c';
        ok "École" =~ /^\C\C(c)/;
    }
d94 1
a94 5

    {
        # The original bug report had 'no utf8' here but that was irrelevant.
        local $BugId   = '20010306.008';
        local $Message = "Don't dump core";
d96 1
a96 1
        ok $a =~ m/\w/;  # used to core dump.
a98 1

d100 1
a100 2
        local $BugId = '20010410.006';
        local $Message = '/g in scalar context';
d113 1
a113 1
            iseq $i, 2;
a117 1
        local $BugId = "20010619.003";
d120 1
a120 1
            ok !/[[:print:]]/, "'$_' not in [[:print:]]";
d123 1
a123 1
            ok  /[[:print:]]/, "'$_' in [[:print:]]";
a126 2


d129 1
a129 1
        local $BugId = '20010814.004';
d134 1
a134 1
        iseq "$a $b $c", 'ba:ba ad:ae 10', "pos() works with () = m//";
a136 1

d140 2
a141 2
        local $BugId   = '20010407.006';
        local $Message = 'UTF-8 return values from functions';
d146 1
a146 1
      ::ok $x =~ /(..)/;
d148 2
a149 2
      ::ok length ($y) == 2 && $y eq $x;
      ::ok x =~ /(..)/;
d151 1
a151 1
      ::ok length ($y) == 2 && $y eq $x;
a159 1

d161 1
a161 1
        local $Message = 'UTF-8 hash keys and /$/';
d172 1
a172 1
            iseq $m1, $m2;
a175 1

d177 1
a177 3
        local $BugId   = "20020124.005";
        local $PatchId = "14795";
        local $Message = "s///eg";
d185 1
a185 1
            iseq substr ($x, 0, 1), substr ($x, -1, 1);
a188 1

d190 1
a190 2
        local $BugId = "20020412.005";
        local $Message = "Correct pmop flags checked when empty pattern";
d196 5
a200 5
            my $match = ?? + 0;
            ok $match != $_, $Message, 
                sprintf "'match one' %s on %s iteration" =>
                               $match ? 'succeeded' : 'failed',
                               $_     ? 'second'    : 'first';
d204 1
a204 1
        iseq $result, $num;
a206 1

d208 1
a208 2
        local $BugId   = '20020630.002';
        local $Message = 'UTF-8 regex matches above 32k';
d214 3
a216 3
                ok  $r, $Message, "<$type x $len>";
                ok !$r || pos ($s) == $len + 1, $Message,
                        "<$type x $len>; pos = @@{[pos $s]}";
a221 1
        local $PatchId = '18179';
d225 1
a225 53
        ok $ok && $ord == 0x100 && $len == 4, "No panic: end_shift";
    }


    {
        local $BugId = '15763';
        our $a = "x\x{100}";
        chop $a;    # Leaves the UTF-8 flag
        $a .= "y";  # 1 byte before 'y'.

        ok $a =~ /^\C/,        'match one \C on 1-byte UTF-8';
        ok $a =~ /^\C{1}/,     'match \C{1}';

        ok $a =~ /^\Cy/,       'match \Cy';
        ok $a =~ /^\C{1}y/,    'match \C{1}y';

        ok $a !~ /^\C\Cy/,     q {don't match two \Cy};
        ok $a !~ /^\C{2}y/,    q {don't match \C{2}y};

        $a = "\x{100}y"; # 2 bytes before "y"

        ok $a =~ /^\C/,        'match one \C on 2-byte UTF-8';
        ok $a =~ /^\C{1}/,     'match \C{1}';
        ok $a =~ /^\C\C/,      'match two \C';
        ok $a =~ /^\C{2}/,     'match \C{2}';

        ok $a =~ /^\C\C\C/,    'match three \C on 2-byte UTF-8 and a byte';
        ok $a =~ /^\C{3}/,     'match \C{3}';

        ok $a =~ /^\C\Cy/,     'match two \C';
        ok $a =~ /^\C{2}y/,    'match \C{2}';

        ok $a !~ /^\C\C\Cy/,   q {don't match three \Cy};
        ok $a !~ /^\C{2}\Cy/,  q {don't match \C{2}\Cy};
        ok $a !~ /^\C{3}y/,    q {don't match \C{3}y};

        $a = "\x{1000}y"; # 3 bytes before "y"

        ok $a =~ /^\C/,        'match one \C on three-byte UTF-8';
        ok $a =~ /^\C{1}/,     'match \C{1}';
        ok $a =~ /^\C\C/,      'match two \C';
        ok $a =~ /^\C{2}/,     'match \C{2}';
        ok $a =~ /^\C\C\C/,    'match three \C';
        ok $a =~ /^\C{3}/,     'match \C{3}';

        ok $a =~ /^\C\C\C\C/,  'match four \C on three-byte UTF-8 and a byte';
        ok $a =~ /^\C{4}/,     'match \C{4}';

        ok $a =~ /^\C\C\Cy/,   'match three \Cy';
        ok $a =~ /^\C{3}y/,    'match \C{3}y';

        ok $a !~ /^\C\C\C\Cy/, q {don't match four \Cy};
        ok $a !~ /^\C{4}y/,    q {don't match \C{4}y};
a227 1
    
d229 6
a234 7
        local $BugId   = '15397';
        local $Message = 'UTF-8 matching';
        ok "\x{100}" =~ /\x{100}/;
        ok "\x{100}" =~ /(\x{100})/;
        ok "\x{100}" =~ /(\x{100}){1}/;
        ok "\x{100}\x{100}" =~ /(\x{100}){2}/;
        ok "\x{100}\x{100}" =~ /(\x{100})(\x{100})/;
a236 1

d238 1
a238 2
        local $BugId   = '7471';
        local $Message = 'Neither ()* nor ()*? sets $1 when matched 0 times';
d240 2
a241 2
        ok /(AB)*?CD/ && !defined $1;
        ok /(AB)*CD/  && !defined $1;
a243 1

d245 1
a245 2
        local $BugId   = '3547';
        local $Message = "Caching shouldn't prevent match";
d247 4
a250 4
        ok "bac"    =~ /$pattern/ && $1 eq 'a';
        ok "bbac"   =~ /$pattern/ && $1 eq 'a';
        ok "bbbac"  =~ /$pattern/ && $1 eq 'a';
        ok "bbbbac" =~ /$pattern/ && $1 eq 'a';
a252 2


d254 2
a255 4
        local $BugId   = '18232';
        local $Message = '$1 should keep UTF-8 ness';
        ok "\x{100}" =~ /(.)/;
        iseq  $1, "\x{100}",  '$1 is UTF-8';
d257 2
a258 2
        iseq  $1, "\x{100}",  '$1 is still UTF-8';
        isneq $1, "\xC4\x80", '$1 is not non-UTF-8';
a260 1

d262 1
a262 2
        local $BugId   = '19767';
        local $Message = "Optimizer doesn't prematurely reject match";
d271 1
a271 1
        ok $attr =~ $PredNameHyphen;  # Original test.
d274 1
a274 1
        ok "0" =~ /\p{N}+\z/;         # Variant.
a276 1

d278 1
a278 2
        local $BugId   = '20683';
        local $Message = "(??{ }) doesn't return stale values";
d283 1
a283 1
        iseq $p, 5;
d295 1
a295 1
        iseq $p, 5;
a297 1

d305 1
a305 1
        local $Message = 'Markus Kuhn 2003-02-26';
d308 2
a309 2
        ok $x =~ s/(\S)\n(\S)/$1 $2/sg;
        ok $x eq "\x{2019} k";
d312 2
a313 2
        ok $x =~ s/(\S)\n(\S)/$1 $2/sg;
        ok $x eq "b k";
d315 1
a315 1
        ok "\x{2019}" =~ /\S/;
a317 1

d319 1
a319 2
        local $BugId = '21411';
        local $Message = "(??{ .. }) in split doesn't corrupt its stack";
d321 1
a321 1
        ok '-1-3-5-' eq join '', split /((??{$i++}))/, '-1-3-5-';
d325 1
a325 11
        iseq "@@_", "a|b|c";
    }


    {
        # XXX DAPM 13-Apr-06. Recursive split is still broken. It's only luck it
        # hasn't been crashing. Disable this test until it is fixed properly.
        # XXX also check what it returns rather than just doing ok(1,...)
        # split /(?{ split "" })/, "abc";
        local $TODO = "Recursive split is still broken";
        ok 0, 'cache_re & "(?{": it dumps core in 5.6.1 & 5.8.0';
d328 1
a330 1
        local $BugId = '17757';
d334 1
a334 1
        iseq "@@x", "'x':'...'", "Parse::RecDescent triggered infinite loop";
a336 1

a337 1
        local $BugId = '22354';
d339 2
a340 2
            ok "a\nb" !~ /^b/,  "Propagated modifier; $_[0]";
            ok "a\nb" =~ /^b/m, "Propagated modifier; $_[0] - with /m";
d345 2
a346 13

        #
        # Next two give 'panic: malloc'.
        # Outcommented, using two TODOs.
        #
        local $TODO    = 'panic: malloc';
        local $Message = 'Postponed regexp and propaged modifier';
      # ok 0 for 1 .. 2;
      SKIP: {
            skip "panic: malloc", 2;
            $_ = "x"; /x(?{func "in regexp"})/;
            $_ = "x"; /x(?{func "in multiline regexp"})/m;
        }
a348 1

a349 1
        local $BugId = '19049';
d352 1
a352 1
        iseq "abcde", $`, 'Global match sets $`';
a354 1

d358 1
a358 1
        local $BugId   = '23769';
d360 1
a360 1
        local $Message = $Mess;
d364 38
a401 38
        ok $s =~ /\x{a0}/;
        ok $s =~ /\x{a0}+/;
        ok $s =~ /\x{a0}\x{a0}/;

        $Message = "$Mess (easy variant)";
        ok "aaa\x{100}" =~ /(a+)/;
        iseq $1, "aaa";

        $Message = "$Mess (easy invariant)";
        ok "aaa\x{100}     " =~ /(a+?)/;
        iseq $1, "a";

        $Message = "$Mess (regrepeat variant)";
        ok "\xa0\xa0\xa0\x{100}    " =~ /(\xa0+?)/;
        iseq $1, "\xa0";

        $Message = "$Mess (regrepeat invariant)";
        ok "\xa0\xa0\xa0\x{100}" =~ /(\xa0+)/;
        iseq $1, "\xa0\xa0\xa0";

        $Message = "$Mess (hard variant)";
        ok "\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+?)/;
        iseq $1, "\xa0\xa1";

        $Message = "$Mess (hard invariant)";
        ok "ababab\x{100}  " =~ /((?:ab)+)/;
        iseq $1, 'ababab';

        ok "\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+)/;
        iseq $1, "\xa0\xa1\xa0\xa1\xa0\xa1";

        ok "ababab\x{100}  " =~ /((?:ab)+?)/;
        iseq $1, "ab";

        $Message = "Don't match first byte of UTF-8 representation";
        ok "\xc4\xc4\xc4" !~ /(\x{100}+)/;
        ok "\xc4\xc4\xc4" !~ /(\x{100}+?)/;
        ok "\xc4\xc4\xc4" !~ /(\x{100}++)/;
a403 1

d406 3
a408 3
        local $BugId = '25269';
        iseq "a-bc", eval {my ($x, $y) = "bca" =~ /^(?=.*(a)).*(bc)/; "$x-$y"},
             'Captures can move backwards in string';
a410 1

d412 9
a420 9
        local $BugId   = '27940'; # \cA not recognized in character classes
        ok "a\cAb" =~ /\cA/, '\cA in pattern';
        ok "a\cAb" =~ /[\cA]/, '\cA in character class';
        ok "a\cAb" =~ /[\cA-\cB]/, '\cA in character class range';
        ok "abc" =~ /[^\cA-\cB]/, '\cA in negated character class range';
        ok "a\cBb" =~ /[\cA-\cC]/, '\cB in character class range';
        ok "a\cCbc" =~ /[^\cA-\cB]/, '\cC in negated character class range';
        ok "a\cAb" =~ /(??{"\cA"})/, '\cA in ??{} pattern';
        ok "ab" !~ /a\cIb/x, '\cI in pattern';
a422 1

d425 5
a429 5
        local $BugId = '28532';
        ok "abc" =~ /^abc(\z)?/ && defined($1),
           'Optional zero-width match at end of string';
        ok "abc" =~ /^abc(\z)??/ && !defined($1),
           'Optional zero-width match at end of string';
a431 2


a432 1
        local $BugId = '36207';
d436 9
a444 9
        ok $utf8 =~ /\xe9/i, "utf8/latin";
        ok $utf8 =~ /$latin1/i, "utf8/latin runtime";
        ok $utf8 =~ /(abc|\xe9)/i, "utf8/latin trie";
        ok $utf8 =~ /(abc|$latin1)/i, "utf8/latin trie runtime";

        ok "\xe9" =~ /$utf8/i, "latin/utf8";
        ok "\xe9" =~ /(abc|$utf8)/i, "latin/utf8 trie";
        ok $latin1 =~ /$utf8/i, "latin/utf8 runtime";
        ok $latin1 =~ /(abc|$utf8)/i, "latin/utf8 trie runtime";
a446 1

a447 1
        local $BugId = '37038';
d452 2
a453 2
        iseq $2, 'cd',
             "Assigning to original string does not corrupt match vars";
a455 1

a456 1
        local $PatchId = '26410';
d462 2
a463 2
        eval_ok sub {$aeek -> gloople () =~ /(.)/g},
               "//g match against return value of sub";
d466 2
a467 2
        eval_ok sub {gloople () =~ /(.)/g},
               "26410 didn't affect sub calls for some reason";
a469 1

d471 2
a472 1
        local $TODO = "See changes 26925-26928, which reverted change 26410";
d487 1
a487 1
            iseq $f, "ab", "pos() retained between calls";
a489 1
            local $TODO;
d503 1
a503 1
            iseq $g, "ab", "pos() retained between calls";
a505 1
            local $TODO;
a509 1

d512 1
a512 2
        local $BugId = '37836';
        skip "In EBCDIC" if $IS_EBCDIC;
d516 2
a517 2
        eval_ok sub {!($ret = s/[\0]+//g)},
                "Ill-formed UTF-8 doesn't match NUL in class";
a519 1

d522 1
a522 1
        local $BugId = '38293';
d528 1
a528 1
        ok $c eq "", "U+FFFF, parsed as atom";
d533 1
a533 1
        ok $c eq "", "U+FFFF backslashed, parsed as atom";
d537 1
a537 1
        ok $c eq "", "U+FFFF, parsed in class";
d542 1
a542 1
        ok $c eq "", "U+FFFF backslashed, parsed in class";
d546 1
a546 1
        ok $s eq "AB", "U+FFFF, EXACTF";
d550 1
a550 1
        ok $s eq "\x{ffff}", "U+FFFF, BOUND";
d554 1
a554 1
        ok $s eq "\x{ffff}", "U+FFFF, NBOUND";
a556 1

a557 1
        local $BugId = '39583';
d573 3
a575 3
        ok $str =~ s/^(.*?)${delim}{4}//s, "Pattern matches";
        iseq $str, "", "Empty string";
        ok defined $1 && length ($1) == $size, '$1 is correct size';
a577 1

d579 16
a594 17
        local $BugId = '27940';
        ok "\0-A"  =~ /\c@@-A/, '@@- should not be interpolated in a pattern';
        ok "\0\0A" =~ /\c@@+A/, '@@+ should not be interpolated in a pattern';
        ok "X\@@-A"  =~ /X@@-A/, '@@- should not be interpolated in a pattern';
        ok "X\@@\@@A" =~ /X@@+A/, '@@+ should not be interpolated in a pattern';

        ok "X\0A" =~ /X\c@@?A/,  '\c@@?';
        ok "X\0A" =~ /X\c@@*A/,  '\c@@*';
        ok "X\0A" =~ /X\c@@(A)/, '\c@@(';
        ok "X\0A" =~ /X(\c@@)A/, '\c@@)';
        ok "X\0A" =~ /X\c@@|ZA/, '\c@@|';

        ok "X\@@A" =~ /X@@?A/,  '@@?';
        ok "X\@@A" =~ /X@@*A/,  '@@*';
        ok "X\@@A" =~ /X@@(A)/, '@@(';
        ok "X\@@A" =~ /X(@@)A/, '@@)';
        ok "X\@@A" =~ /X@@|ZA/, '@@|';
d597 5
a601 5
        ok 'abc' =~ /(.)(.)(.)/, 'The last successful match is bogus';
        ok "A@@+B"  =~ /A@@{+}B/,  'Interpolation of @@+ in /@@{+}/';
        ok "A@@-B"  =~ /A@@{-}B/,  'Interpolation of @@- in /@@{-}/';
        ok "A@@+B"  =~ /A@@{+}B/x, 'Interpolation of @@+ in /@@{+}/x';
        ok "A@@-B"  =~ /A@@{-}B/x, 'Interpolation of @@- in /@@{-}/x';
a603 1

a604 1
        local $BugId = '50496';
d624 1
a624 1
                iseq $fetch [$_] [0], $fetch [$_] [1], $names [$_];
d629 5
a633 5
        iseq $res, 1, "'$s' =~ /(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz)/";
        iseq $count, 3, "Got 3 keys in %+ via each";
        iseq 0 + @@k, 3, 'Got 3 keys in %+ via keys';
        iseq "@@k", "A B C", "Got expected keys";
        iseq "@@v", "bar baz foo", "Got expected values";
d638 1
a638 1
        ok !$@@, 'lvalue $+ {...} should not throw an exception';
a640 1

d645 1
a645 1
        local $BugId = '50496';
d666 1
a666 1
                iseq $fetch [$_] [0], $fetch [$_] [1], $names [$_];
d671 5
a675 5
        iseq $res, 1, "'$s' =~ /(?<D>(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz))/";
        iseq $count, 4, "Got 4 keys in %+ via each";
        iseq @@k, 4, 'Got 4 keys in %+ via keys';
        iseq "@@k", "A B C D", "Got expected keys";
        iseq "@@v", "bar baz foo foo bar baz", "Got expected values";
d680 1
a680 1
        ok !$@@,'lvalue $+ {...} should not throw an exception';
a682 1

a683 1
        local $BugId = '36046';
d689 3
a691 3
        iseq $mval,  0, '@@- should be empty';
        iseq $pval,  0, '@@+ should be empty';
        iseq $count, 1, 'Should have matched once only';
a693 3



d695 1
a695 2
        local $BugId = '40684';
        local $Message = '/m in precompiled regexp';
d698 2
a699 2
        ok $s =~ m/$rex/;
        ok $s =~ m/^abc$/m;
a701 1

d703 1
a703 2
        local $BugId   = '36909';
        local $Message = '(?: ... )? should not lose $^R';
d707 1
a707 1
            ok 'x foofoo y' =~ m {
d710 2
a711 2
            }x;
            iseq $^R, 'last regexp code result';
d713 1
a713 1
        iseq $^R, 'Nothing';
d718 1
a718 1
            ok 'x foofoo y' =~ m {
d721 2
a722 2
            }x;
            iseq $^R, 'last regexp code result';
d724 1
a724 1
        iseq $^R, 'Nothing';
d728 1
a728 1
            ok 'x foofoo y' =~ m {
d731 2
a732 2
            }x;
            iseq $^R, 'last regexp code result';
d734 1
a734 1
        iseq $^R, 'Nothing';
d738 1
a738 1
            ok 'x foofoo y' =~ m {
d741 2
a742 2
            }x;
            iseq $^R, 'last regexp code result';
d744 1
a744 1
        iseq $^R, 'Nothing';
a746 1

d748 1
a748 2
        local $BugId   = '22395';
        local $Message = 'Match is linear, not quadratic';
d753 2
a754 2
            local $TODO = "Should be L+1 not L*(L+3)/2 (L=$l)";
            iseq $count, $l + 1;
a757 1

d759 1
a759 2
        local $BugId   = '22614';
        local $Message = '@@-/@@+ should not have undefined values';
d763 1
a763 1
        iseq "@@len", "2 2 2";
a765 1

d767 1
a767 2
        local $BugId   = '18209';
        local $Message = '$& set on s///';
d773 1
a773 1
            $text =~ s/$word\s//gi; # Leave a space to seperate words
d781 2
a782 2
        iseq $count, 3;
        iseq $text, ' word2 word4 word6 ';
a784 1

d787 1
a787 1
        local $BugId = '6893';
d794 1
a794 1
        iseq "@@res", "A B C", "/g pattern shouldn't infinite loop";
a796 2


d798 1
a798 2
        local $BugId   = '41010';
        local $Message = 'No optimizer bug';
d808 2
a809 2
                            ok /$re/  && $1 eq $_, "'$_' =~ /$re/";
                            ok /$re/m && $1 eq $_, "'$_' =~ /$re/m";
a828 2


a829 1
        local $BugId = '45605';
d835 1
a835 1
        iseq $1, "\xd6", "Upgrade error";
d841 1
a841 1
        local $BugId = '36207';
d847 4
a850 4
                    ok $ch [$u_str] =~ /\Q$ch[$u_pat]\E/i,
                    "\$c =~ /\$c/i : chr ($o) : u_str = $u_str u_pat = $u_pat";
                    ok $ch [$u_str] =~ /\Q$ch[$u_pat]\E|xyz/i,
                    "\$c=~/\$c|xyz/i : chr($o) : u_str = $u_str u_pat = $u_pat";
a855 1

d857 1
a857 2
         local $BugId   = '49190';
         local $Message = '$REGMARK in replacement';
d859 7
a865 3
         my $_ = "A";
         ok s/(*:B)A/$REGMARK/;
         iseq $_, "B";
d867 2
a868 2
         ok s/(*:X)A+|(*:Y)B+|(*:Z)C+/$REGMARK/g;
         iseq $_, "ZYX";
a870 1

d872 1
a872 2
        local $BugId   = '52658';
        local $Message = 'Substitution evaluation in list context';
d876 2
a877 9
        iseq $reg, '../bbb/';
        iseq $te [0], '../';
    }

	# This currently has to come before any "use encoding" in this file.
    {
        local $Message;
        local $BugId   = '59342';
        must_warn 'qr/\400/', '^Use of octal value above 377';
a879 2


a880 1
        local $BugId =  '60034';
d882 2
a883 2
        ok $a =~ /\A(?>[a-z])*\z/,
                '(?>) does not cause wrongness on long string';
d886 3
a888 5
        {
            iseq $a, $b;
        }
        ok $b =~ /\A(?>[a-z])*\z/,
           '(?>) does not cause wrongness on long string with UTF-8';
a890 1

d896 3
a898 3
        local $BugId   = '19049/38869';
        local $Message = 'Pattern in a loop, failure should not ' .
                         'affect previous success';
d910 2
a911 2
        iseq $y, ' ';
        iseq $x, 'ab cd';
d914 4
a917 1

a918 3
        local $BugId = '24274';

        ok (("a" x (2 ** 15 - 10)) =~ /^()(a|bb)*$/, "Recursive stack cracker");
d920 1
a920 1
            "Regexp /^(??{'(.)'x 100})/ crashes older perls");
a922 1

d925 1
a925 1
        local $BugId = '45337';
d927 1
a927 1
        local $Message = "Shouldn't panic";
d930 1
a930 1
        ok "aaa" =~ /$s/;
d933 1
a933 2
        local $BugId = '57042';
	local $Message = "Check if tree logic breaks \$^R";
d946 1
a946 1
	iseq "@@res","#1 #2";
a955 2


d958 1
a958 2
        local $BugId = '60508';
	local $Message = "Check capture offset re-entrancy of utf8 code.";
d969 1
a969 1
        iseq($k2, "\x{2022}", "utf8::SWASHNEW doesn't cause capture leaks");
a971 1

d973 1
a973 1
	local $BugId = 65372;	# minimal CURLYM limited to 32767 matches
d983 1
a983 1
	    ok($s =~ $pat, $pat);
d988 1
a988 1
        local $TODO = "[perl #38133]";
d996 1
a996 1
        iseq($first, $second);
d998 118
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d10 1
a10 1
use Config;
d20 1
a20 2
    require './test.pl';
    skip_all_if_miniperl("miniperl can't load Tie::Hash::NamedCapture, need for %+ and %-");
d24 1
a24 1
plan tests => 2521;  # Update this when adding/deleting tests.
a32 2
    like("A \x{263a} B z C", qr/A . B (??{ "z" }) C/,
	 "Match UTF-8 char in presence of (??{ }); Bug 20000731.001");
d35 8
d44 1
a44 1
        ok(undef =~ /^([^\/]*)(.*)$/, "Used to cause a SEGV; Bug 20001021.005");
d48 1
a48 1
        my $message = 'bug id 20001008.001';
d52 4
a55 4
            ok(s/(\d+)\s*([\w\-]+)/$1 . uc $2/e, $message);
            ok(my ($latin) = /^(.+)(?:\s+\d)/, $message);
            is($latin, "stra\337e", $message);
	    ok($latin =~ s/stra\337e/straße/, $message);
d65 1
d67 2
d70 1
a70 1
        my $message = 'HEBREW ACCENT QADMA matched by .*; Bug 20001028.003';
d72 3
a74 3
        ok(my ($Y) = $X =~ /(.*)/, $message);
        is($Y, v1448, $message);
        is(length $Y, 1, $message);
d77 1
a77 1
        $message = 'HEBREW ACCENT QADMA in replacement; Bug 20001028.003';
d80 2
a81 2
        is(length $X, 1, $message);
        is(ord $X, 1488, $message);
d84 1
d86 2
a87 1
        my $message = 'Repeated s///; Bug 20001108.001';
d91 2
a92 2
        is($Y, $X, $message);
        is($X, "Szab\x{f3},Bal\x{e1}zs", $message);
d95 1
d97 2
a98 1
        my $message = 's/// on UTF-8 string; Bug 20000517.001';
d101 2
a102 2
        is($x, "\x{100}B", $message);
        is(length $x, 2, $message);
d105 1
d107 4
a110 3
        my $message = '\C and É; Bug 20001230.002';
        ok("École" =~ /^\C\C(.)/ && $1 eq 'c', $message);
        like("École", qr/^\C\C(c)/, $message);
d113 1
d116 2
a117 2

        my $message = "Don't dump core; Bug 20010306.008";
d119 1
a119 1
        like($a, qr/\w/, $message);  # used to core dump.
d122 1
d124 2
a125 1
        my $message = '/g in scalar context; Bug 20010410.006';
d138 1
a138 1
            is($i, 2, $message);
d143 1
d146 1
a146 1
            unlike($_, qr/[[:print:]]/, sprintf "\\%03o not in [[:print:]]; Bug 20010619.003", ord $_);
d149 1
a149 1
            like($_, qr/[[:print:]]/, "'$_' in [[:print:]]; Bug 20010619.003");
d153 2
d157 1
a157 1

d162 1
a162 1
        is("$a $b $c", 'ba:ba ad:ae 10', "pos() works with () = m//; Bug 20010814.004");
d165 1
d169 2
a170 2

        my $message = 'UTF-8 return values from functions; Bug 20010407.006';
d175 1
a175 1
      ::ok($x =~ /(..)/, $message);
d177 2
a178 2
      ::ok(length ($y) == 2 && $y eq $x, $message);
      ::ok(x =~ /(..)/, $message);
d180 1
a180 1
      ::ok(length ($y) == 2 && $y eq $x, $message);
d189 1
d191 1
a191 1
        my $message = 'UTF-8 hash keys and /$/';
d202 1
a202 1
            is($m1, $m2, $message);
d206 1
d208 3
a210 1
        my $message = "s///eg [change 13f46d054db22cf4]; Bug 20020124.005";
d218 1
a218 1
            is(substr ($x, 0, 1), substr ($x, -1, 1), $message);
d222 1
d224 2
a225 1
        my $message = "Correct pmop flags checked when empty pattern; Bug 20020412.005";
d231 5
a235 5
            my $match = m?? + 0;
            ok($match != $_, $message)
                or diag(sprintf "'match one' %s on %s iteration" =>
			$match ? 'succeeded' : 'failed',
			$_     ? 'second'    : 'first');
d239 1
a239 1
        is($result, $num, $message);
d242 1
d244 2
a245 1
        my $message = 'UTF-8 regex matches above 32k; Bug 20020630.002';
d251 3
a253 3
                ok($r, $message) or diag("<$type x $len>");
                ok(!$r || pos ($s) == $len + 1, $message)
		    or diag("<$type x $len>; pos = @@{[pos $s]}");
d259 1
d263 1
a263 1
        ok $ok && $ord == 0x100 && $len == 4, "No panic: end_shift [change 0e933229fa758625]";
d266 1
d268 1
d273 2
a274 2
        like($a, qr/^\C/,        'match one \C on 1-byte UTF-8; Bug 15763');
        like($a, qr/^\C{1}/,     'match \C{1}; Bug 15763');
d276 2
a277 2
        like($a, qr/^\Cy/,       'match \Cy; Bug 15763');
        like($a, qr/^\C{1}y/,    'match \C{1}y; Bug 15763');
d279 2
a280 2
        unlike($a, qr/^\C\Cy/,     q {don't match two \Cy; Bug 15763});
        unlike($a, qr/^\C{2}y/,    q {don't match \C{2}y; Bug 15763});
d284 14
a297 14
        like($a, qr/^\C/,        'match one \C on 2-byte UTF-8; Bug 15763');
        like($a, qr/^\C{1}/,     'match \C{1}; Bug 15763');
        like($a, qr/^\C\C/,      'match two \C; Bug 15763');
        like($a, qr/^\C{2}/,     'match \C{2}; Bug 15763');

        like($a, qr/^\C\C\C/,    'match three \C on 2-byte UTF-8 and a byte; Bug 15763');
        like($a, qr/^\C{3}/,     'match \C{3}; Bug 15763');

        like($a, qr/^\C\Cy/,     'match two \C; Bug 15763');
        like($a, qr/^\C{2}y/,    'match \C{2}; Bug 15763');

        unlike($a, qr/^\C\C\Cy/,   q {don't match three \Cy; Bug 15763});
        unlike($a, qr/^\C{2}\Cy/,  q {don't match \C{2}\Cy; Bug 15763});
        unlike($a, qr/^\C{3}y/,    q {don't match \C{3}y; Bug 15763});
d301 6
a306 6
        like($a, qr/^\C/,        'match one \C on three-byte UTF-8; Bug 15763');
        like($a, qr/^\C{1}/,     'match \C{1}; Bug 15763');
        like($a, qr/^\C\C/,      'match two \C; Bug 15763');
        like($a, qr/^\C{2}/,     'match \C{2}; Bug 15763');
        like($a, qr/^\C\C\C/,    'match three \C; Bug 15763');
        like($a, qr/^\C{3}/,     'match \C{3}; Bug 15763');
d308 2
a309 2
        like($a, qr/^\C\C\C\C/,  'match four \C on three-byte UTF-8 and a byte; Bug 15763');
        like($a, qr/^\C{4}/,     'match \C{4}; Bug 15763');
d311 2
a312 2
        like($a, qr/^\C\C\Cy/,   'match three \Cy; Bug 15763');
        like($a, qr/^\C{3}y/,    'match \C{3}y; Bug 15763');
d314 2
a315 2
        unlike($a, qr/^\C\C\C\Cy/, q {don't match four \Cy; Bug 15763});
        unlike($a, qr/^\C{4}y/,    q {don't match \C{4}y; Bug 15763});
d320 7
a326 6
        my $message = 'UTF-8 matching; Bug 15397';
        like("\x{100}", qr/\x{100}/, $message);
        like("\x{100}", qr/(\x{100})/, $message);
        like("\x{100}", qr/(\x{100}){1}/, $message);
        like("\x{100}\x{100}", qr/(\x{100}){2}/, $message);
        like("\x{100}\x{100}", qr/(\x{100})(\x{100})/, $message);
d329 1
d331 2
a332 1
        my $message = 'Neither ()* nor ()*? sets $1 when matched 0 times; Bug 7471';
d334 2
a335 2
        ok(/(AB)*?CD/ && !defined $1, $message);
        ok(/(AB)*CD/  && !defined $1, $message);
d338 1
d340 2
a341 1
        my $message = "Caching shouldn't prevent match; Bug 3547";
d343 4
a346 4
        ok("bac"    =~ /$pattern/ && $1 eq 'a', $message);
        ok("bbac"   =~ /$pattern/ && $1 eq 'a', $message);
        ok("bbbac"  =~ /$pattern/ && $1 eq 'a', $message);
        ok("bbbbac" =~ /$pattern/ && $1 eq 'a', $message);
d349 2
d352 4
a355 2
        ok("\x{100}" =~ /(.)/, '$1 should keep UTF-8 ness; Bug 18232');
        is($1, "\x{100}",  '$1 is UTF-8; Bug 18232');
d357 2
a358 2
        is($1, "\x{100}",  '$1 is still UTF-8; Bug 18232');
        isnt($1, "\xC4\x80", '$1 is not non-UTF-8; Bug 18232');
d361 1
d363 2
a364 1
        my $message = "Optimizer doesn't prematurely reject match; Bug 19767";
d373 1
a373 1
        like($attr, $PredNameHyphen, $message);  # Original test.
d376 1
a376 1
        like("0", qr/\p{N}+\z/, $message);         # Variant.
d379 1
d381 2
a382 1
        my $message = "(??{ }) doesn't return stale values; Bug 20683";
d387 1
a387 1
        is($p, 5, $message);
d399 1
a399 1
        is($p, 5, $message);
d402 1
d410 1
a410 1
        my $message = 'Markus Kuhn 2003-02-26';
d413 2
a414 2
        ok($x =~ s/(\S)\n(\S)/$1 $2/sg, $message);
        is($x, "\x{2019} k", $message);
d417 2
a418 2
        ok($x =~ s/(\S)\n(\S)/$1 $2/sg, $message);
        is($x, "b k", $message);
d420 1
a420 1
        like("\x{2019}", qr/\S/, $message);
d423 1
d425 2
a426 1
        my $message = "(??{ .. }) in split doesn't corrupt its stack; Bug 21411";
d428 1
a428 1
        is('-1-3-5-', join('', split /((??{$i++}))/, '-1-3-5-'), $message);
d432 1
a432 1
        is("@@_", "a|b|c", $message);
d435 1
d441 1
a441 1
        local $::TODO = "Recursive split is still broken";
d445 1
d447 1
d451 1
a451 1
        is("@@x", "'x':'...'", "Parse::RecDescent triggered infinite loop; Bug 17757");
d454 1
d456 1
d458 2
a459 2
            ok("a\nb" !~ /^b/,  "Propagated modifier; $_[0]; Bug 22354");
            ok("a\nb" =~ /^b/m, "Propagated modifier; $_[0] - with /m; Bug 22354");
d464 13
a476 2
        $_ = "x"; /x(?{func "in regexp"})/;
        $_ = "x"; /x(?{func "in multiline regexp"})/m;
d479 1
d481 1
d484 1
a484 1
        is("abcde", $`, 'Global match sets $`; Bug 19049');
d487 1
d491 1
a491 1

d493 1
a493 1
        my $message = "$Mess; Bug 23769";
d497 38
a534 38
        like($s, qr/\x{a0}/, $message);
        like($s, qr/\x{a0}+/, $message);
        like($s, qr/\x{a0}\x{a0}/, $message);

        $message = "$Mess (easy variant); Bug 23769";
        ok("aaa\x{100}" =~ /(a+)/, $message);
        is($1, "aaa", $message);

        $message = "$Mess (easy invariant); Bug 23769";
        ok("aaa\x{100}     " =~ /(a+?)/, $message);
        is($1, "a", $message);

        $message = "$Mess (regrepeat variant); Bug 23769";
        ok("\xa0\xa0\xa0\x{100}    " =~ /(\xa0+?)/, $message);
        is($1, "\xa0", $message);

        $message = "$Mess (regrepeat invariant); Bug 23769";
        ok("\xa0\xa0\xa0\x{100}" =~ /(\xa0+)/, $message);
        is($1, "\xa0\xa0\xa0", $message);

        $message = "$Mess (hard variant); Bug 23769";
        ok("\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+?)/, $message);
        is($1, "\xa0\xa1", $message);

        $message = "$Mess (hard invariant); Bug 23769";
        ok("ababab\x{100}  " =~ /((?:ab)+)/, $message);
        is($1, 'ababab', $message);

        ok("\xa0\xa1\xa0\xa1\xa0\xa1\x{100}" =~ /((?:\xa0\xa1)+)/, $message);
        is($1, "\xa0\xa1\xa0\xa1\xa0\xa1", $message);

        ok("ababab\x{100}  " =~ /((?:ab)+?)/, $message);
        is($1, "ab", $message);

        $message = "Don't match first byte of UTF-8 representation; Bug 23769";
        unlike("\xc4\xc4\xc4", qr/(\x{100}+)/, $message);
        unlike("\xc4\xc4\xc4", qr/(\x{100}+?)/, $message);
        unlike("\xc4\xc4\xc4", qr/(\x{100}++)/, $message);
d537 1
d540 4
a544 3
        is(eval {my ($x, $y) = "bca" =~ /^(?=.*(a)).*(bc)/; "$x-$y"}, "a-bc",
	   'Captures can move backwards in string; Bug 25269');
    }
d547 9
a555 9
        # \cA not recognized in character classes
        like("a\cAb", qr/\cA/, '\cA in pattern; Bug 27940');
        like("a\cAb", qr/[\cA]/, '\cA in character class; Bug 27940');
        like("a\cAb", qr/[\cA-\cB]/, '\cA in character class range; Bug 27940');
        like("abc", qr/[^\cA-\cB]/, '\cA in negated character class range; Bug 27940');
        like("a\cBb", qr/[\cA-\cC]/, '\cB in character class range; Bug 27940');
        like("a\cCbc", qr/[^\cA-\cB]/, '\cC in negated character class range; Bug 27940');
        like("a\cAb", qr/(??{"\cA"})/, '\cA in ??{} pattern; Bug 27940');
        unlike("ab", qr/a\cIb/x, '\cI in pattern; Bug 27940');
d558 1
d561 7
a568 5
        ok("abc" =~ /^abc(\z)?/ && defined($1),
           'Optional zero-width match at end of string; Bug 28532');
        ok("abc" =~ /^abc(\z)??/ && !defined($1),
           'Optional zero-width match at end of string; Bug 28532');
    }
d571 1
d575 9
a583 9
        like($utf8, qr/\xe9/i, "utf8/latin; Bug 36207");
        like($utf8, qr/$latin1/i, "utf8/latin runtime; Bug 36207");
        like($utf8, qr/(abc|\xe9)/i, "utf8/latin trie; Bug 36207");
        like($utf8, qr/(abc|$latin1)/i, "utf8/latin trie runtime; Bug 36207");

        like("\xe9", qr/$utf8/i, "latin/utf8; Bug 36207");
        like("\xe9", qr/(abc|$utf8)/i, "latin/utf8 trie; Bug 36207");
        like($latin1, qr/$utf8/i, "latin/utf8 runtime; Bug 36207");
        like($latin1, qr/(abc|$utf8)/i, "latin/utf8 trie runtime; Bug 36207");
d586 1
d588 1
d593 2
a594 2
        is($2, 'cd',
	   "Assigning to original string does not corrupt match vars; Bug 37038");
d597 1
d599 1
d605 2
a606 2
        is(do {$aeek -> gloople () =~ /(.)/g}, 1,
	   "//g match against return value of sub [change e26a497577f3ce7b]");
d609 2
a610 2
        is(do{gloople () =~ /(.)/g}, 1,
	   "change e26a497577f3ce7b didn't affect sub calls for some reason");
d613 1
d615 1
a615 2
        # [perl #78680]
        # See changes 26925-26928, which reverted change 26410
d630 1
a630 1
            is($f, "ab", "pos() retained between calls");
d633 1
d647 1
a647 1
            is($g, "ab", "pos() retained between calls");
d650 1
d655 1
d658 2
a659 1
        skip "In EBCDIC" if $::IS_EBCDIC;
d663 2
a664 2
        is(do {!($ret = s/[\0]+//g)}, 1,
	   "Ill-formed UTF-8 doesn't match NUL in class; Bug 37836");
d667 1
d670 1
a670 1

d676 1
a676 1
        is($c, "", "U+FFFF, parsed as atom; Bug 38293");
d681 1
a681 1
        is($c, "", "U+FFFF backslashed, parsed as atom; Bug 38293");
d685 1
a685 1
        is($c, "", "U+FFFF, parsed in class; Bug 38293");
d690 1
a690 1
        is($c, "", "U+FFFF backslashed, parsed in class; Bug 38293");
d694 1
a694 1
        is($s, "AB", "U+FFFF, EXACTF; Bug 38293");
d698 1
a698 1
        is($s, "\x{ffff}", "U+FFFF, BOUND; Bug 38293");
d702 1
a702 1
        is($s, "\x{ffff}", "U+FFFF, NBOUND; Bug 38293");
d705 1
d707 1
d723 3
a725 3
        ok($str =~ s/^(.*?)${delim}{4}//s, "Pattern matches; Bug 39583");
        is($str, "", "Empty string; Bug 39583");
        ok(defined $1 && length ($1) == $size, '$1 is correct size; Bug 39583');
d728 1
d730 17
a746 16
        like("\0-A", qr/\c@@-A/, '@@- should not be interpolated in a pattern; Bug 27940');
        like("\0\0A", qr/\c@@+A/, '@@+ should not be interpolated in a pattern; Bug 27940');
        like("X\@@-A", qr/X@@-A/, '@@- should not be interpolated in a pattern; Bug 27940');
        like("X\@@\@@A", qr/X@@+A/, '@@+ should not be interpolated in a pattern; Bug 27940');

        like("X\0A", qr/X\c@@?A/,  '\c@@?; Bug 27940');
        like("X\0A", qr/X\c@@*A/,  '\c@@*; Bug 27940');
        like("X\0A", qr/X\c@@(A)/, '\c@@(; Bug 27940');
        like("X\0A", qr/X(\c@@)A/, '\c@@); Bug 27940');
        like("X\0A", qr/X\c@@|ZA/, '\c@@|; Bug 27940');

        like("X\@@A", qr/X@@?A/,  '@@?; Bug 27940');
        like("X\@@A", qr/X@@*A/,  '@@*; Bug 27940');
        like("X\@@A", qr/X@@(A)/, '@@(; Bug 27940');
        like("X\@@A", qr/X(@@)A/, '@@); Bug 27940');
        like("X\@@A", qr/X@@|ZA/, '@@|; Bug 27940');
d749 5
a753 5
        like('abc', qr/(.)(.)(.)/, 'The last successful match is bogus; Bug 27940');
        like("A@@+B", qr/A@@{+}B/,  'Interpolation of @@+ in /@@{+}/; Bug 27940');
        like("A@@-B", qr/A@@{-}B/,  'Interpolation of @@- in /@@{-}/; Bug 27940');
        like("A@@+B", qr/A@@{+}B/x, 'Interpolation of @@+ in /@@{+}/x; Bug 27940');
        like("A@@-B", qr/A@@{-}B/x, 'Interpolation of @@- in /@@{-}/x; Bug 27940');
d756 1
d758 1
d778 1
a778 1
                is($fetch[$_][0], $fetch[$_][1], "$names[$_]; Bug 50496");
d783 5
a787 5
        is($res, 1, "'$s' =~ /(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz)/; Bug 50496");
        is($count, 3, "Got 3 keys in %+ via each; Bug 50496");
        is(0 + @@k, 3, "Got 3 keys in %+ via keys; Bug 50496");
        is("@@k", "A B C", "Got expected keys; Bug 50496");
        is("@@v", "bar baz foo", "Got expected values; Bug 50496");
d792 1
a792 1
        is($@@, '', 'lvalue $+ {...} should not throw an exception; Bug 50496');
d795 1
d800 1
a800 1

d821 1
a821 1
                is($fetch[$_][0], $fetch[$_][1], "$names[$_]; Bug 50496");
d826 5
a830 5
        is($res, 1, "'$s' =~ /(?<D>(?<A>foo)\\s+(?<B>bar)?\\s+(?<C>baz))/; Bug 50496");
        is($count, 4, "Got 4 keys in %+ via each; Bug 50496");
        is(@@k, 4, "Got 4 keys in %+ via keys; Bug 50496");
        is("@@k", "A B C D", "Got expected keys; Bug 50496");
        is("@@v", "bar baz foo foo bar baz", "Got expected values; Bug 50496");
d835 1
a835 1
        is($@@, '', 'lvalue $+ {...} should not throw an exception; Bug 50496');
d838 1
d840 1
d846 3
a848 3
        is($mval,  0, '@@- should be empty; Bug 36046');
        is($pval,  0, '@@+ should be empty; Bug 36046');
        is($count, 1, 'Should have matched once only; Bug 36046');
d851 3
d855 2
a856 1
        my $message = '/m in precompiled regexp; Bug 40684';
d859 2
a860 2
        ok($s =~ m/$rex/, $message);
        ok($s =~ m/^abc$/m, $message);
d863 1
d865 2
a866 1
        my $message = '(?: ... )? should not lose $^R; Bug 36909';
d870 1
a870 1
            ok('x foofoo y' =~ m {
d873 2
a874 2
            }x, $message);
            is($^R, 'last regexp code result', $message);
d876 1
a876 1
        is($^R, 'Nothing', $message);
d881 1
a881 1
            ok('x foofoo y' =~ m {
d884 2
a885 2
            }x, $message);
            is($^R, 'last regexp code result', $message);
d887 1
a887 1
        is($^R, 'Nothing', $message);
d891 1
a891 1
            ok('x foofoo y' =~ m {
d894 2
a895 2
            }x, $message);
            is($^R, 'last regexp code result', $message);
d897 1
a897 1
        is($^R, 'Nothing', $message);
d901 1
a901 1
            ok('x foofoo y' =~ m {
d904 2
a905 2
            }x, $message);
            is($^R, 'last regexp code result', $message);
d907 1
a907 1
        is($^R, 'Nothing', $message);
d910 1
d912 2
a913 1
        my $message = 'Match is linear, not quadratic; Bug 22395';
d918 2
a919 2
            local $::TODO = "Should be L+1 not L*(L+3)/2 (L=$l)";
            is($count, $l + 1, $message);
d923 1
d925 2
a926 1
        my $message = '@@-/@@+ should not have undefined values; Bug 22614';
d930 1
a930 1
        is("@@len", "2 2 2", $message);
d933 1
d935 2
a936 1
        my $message = '$& set on s///; Bug 18209';
d942 1
a942 1
            $text =~ s/$word\s//gi; # Leave a space to separate words
d950 2
a951 2
        is($count, 3, $message);
        is($text, ' word2 word4 word6 ', $message);
d954 1
d957 1
a957 1

d964 1
a964 1
        is("@@res", "A B C", "/g pattern shouldn't infinite loop; Bug 6893");
d967 2
d970 2
a971 1
        # No optimizer bug
d981 2
a982 2
                            ok(/$re/  && $1 eq $_, "'$_' =~ /$re/; Bug 41010");
                            ok(/$re/m && $1 eq $_, "'$_' =~ /$re/m; Bug 41010");
d1002 2
d1005 1
d1011 1
a1011 1
        is($1, "\xd6", "Upgrade error; Bug 45605");
d1017 1
a1017 1

d1023 4
a1026 4
                    like($ch[$u_str], qr/\Q$ch[$u_pat]\E/i,
			 "\$c =~ /\$c/i : chr ($o) : u_str = $u_str u_pat = $u_pat; Bug 36207");
                    like($ch[$u_str], qr/\Q$ch[$u_pat]\E|xyz/i,
			 "\$c=~/\$c|xyz/i : chr($o) : u_str = $u_str u_pat = $u_pat; Bug 36207");
d1032 1
d1034 2
a1035 1
         my $message = '$REGMARK in replacement; Bug 49190';
d1038 2
a1039 2
         ok(s/(*:B)A/$REGMARK/, $message);
         is($_, "B", $message);
d1041 2
a1042 2
         ok(s/(*:X)A+|(*:Y)B+|(*:Z)C+/$REGMARK/g, $message);
         is($_, "ZYX", $message);
d1045 1
d1047 2
a1048 1
        my $message = 'Substitution evaluation in list context; Bug 52658';
d1052 9
a1060 2
        is($reg, '../bbb/', $message);
        is($te [0], '../', $message);
d1063 2
d1066 1
d1068 2
a1069 2
        like($a, qr/\A(?>[a-z])*\z/,
	     '(?>) does not cause wrongness on long string; Bug 60034');
d1072 5
a1076 3
	is($a, $b, 'Bug 60034');
        like($b, qr/\A(?>[a-z])*\z/,
	     '(?>) does not cause wrongness on long string with UTF-8; Bug 60034');
d1079 1
d1085 3
a1087 3

        my $message = 'Pattern in a loop, failure should not ' .
                         'affect previous success; Bug 19049/38869';
d1099 2
a1100 2
        is($y, ' ', $message);
        is($x, 'ab cd', $message);
d1103 1
d1105 3
a1107 1
        ok (("a" x (2 ** 15 - 10)) =~ /^()(a|bb)*$/, "Recursive stack cracker; Bug 24274");
d1109 1
a1109 1
            "Regexp /^(??{'(.)'x 100})/ crashes older perls; Bug 24274");
d1112 1
d1115 1
a1115 1

d1117 1
a1117 1
        my $message = "Shouldn't panic; Bug 45337";
d1120 1
a1120 1
        like("aaa", qr/$s/, $message);
d1123 2
a1124 1
	my $message = "Check if tree logic breaks \$^R; Bug 57042";
d1137 1
a1137 1
	is("@@res","#1 #2", $message);
d1147 2
d1151 2
a1152 1
	# Check capture offset re-entrancy of utf8 code.
d1163 1
a1163 1
        is($k2, "\x{2022}", "utf8::SWASHNEW doesn't cause capture leaks; Bug 60508");
d1166 1
d1168 1
a1168 1
	# minimal CURLYM limited to 32767 matches
d1178 1
a1178 1
	    like($s, $pat, "$pat; Bug 65372");
d1183 1
a1183 1
        local $::TODO = "[perl #38133]";
d1191 1
a1191 1
        is($first, $second);
a1192 81

    {
       my $message
        = 'utf8 =~ /trie/ where trie matches a continuation octet; Bug 70998';

       # Catch warnings:
       my $w;
       local $SIG{__WARN__} = sub { $w .= shift };

       # This bug can be reduced to
       qq{\x{30ab}} =~ /\xab|\xa9/;
       # but it's nice to have a more 'real-world' test. The original test
       # case from the RT ticket follows:

       my %conv = (
                   "\xab"     => "&lt;",
                   "\xa9"     => "(c)",
                  );
       my $conv_rx = '(' . join('|', map { quotemeta } keys %conv) . ')';
       $conv_rx = qr{$conv_rx};

       my $x
        = qq{\x{3042}\x{304b}\x{3055}\x{305f}\x{306a}\x{306f}\x{307e}}
        . qq{\x{3084}\x{3089}\x{308f}\x{3093}\x{3042}\x{304b}\x{3055}}
        . qq{\x{305f}\x{306a}\x{306f}\x{307e}\x{3084}\x{3089}\x{308f}}
        . qq{\x{3093}\x{30a2}\x{30ab}\x{30b5}\x{30bf}\x{30ca}\x{30cf}}
        . qq{\x{30de}\x{30e4}\x{30e9}\x{30ef}\x{30f3}\x{30a2}\x{30ab}}
        . qq{\x{30b5}\x{30bf}\x{30ca}\x{30cf}\x{30de}\x{30e4}\x{30e9}}
        . qq{\x{30ef}\x{30f3}\x{30a2}\x{30ab}\x{30b5}\x{30bf}\x{30ca}}
        . qq{\x{30cf}\x{30de}\x{30e4}\x{30e9}\x{30ef}\x{30f3}};

       $x =~ s{$conv_rx}{$conv{$1}}eg;

       is($w, undef, $message);
    }

    {
        # minimal CURLYM limited to 32767 matches

        is(join("-", "   abc   def  " =~ /(?=(\S+))/g), "abc-bc-c-def-ef-f",
	   'stclass optimisation does not break + inside (?=); Bug 68564');
    }

    {
        use charnames ":full";
        # Delayed interpolation of \N'
        my $r1 = qr/\N{THAI CHARACTER SARA I}/;
        my $s1 = "\x{E34}\x{E34}\x{E34}\x{E34}";

        # Bug #56444
        ok $s1 =~ /$r1+/, 'my $r1 = qr/\N{THAI CHARACTER SARA I}/; my $s1 = "\x{E34}\x{E34}\x{E34}\x{E34}; $s1 =~ /$r1+/';

        # Bug #62056
        ok "${s1}A" =~ m/$s1\N{LATIN CAPITAL LETTER A}/, '"${s1}A" =~ m/$s1\N{LATIN CAPITAL LETTER A}/';

        ok "abbbbc" =~ m/\N{1}/ && $& eq "a", '"abbbbc" =~ m/\N{1}/ && $& eq "a"';
        ok "abbbbc" =~ m/\N{3,4}/ && $& eq "abbb", '"abbbbc" =~ m/\N{3,4}/ && $& eq "abbb"';
    }

    {
        use charnames ":full";
        my $message = '[perl #74982] Period coming after \N{}';
        ok("\x{ff08}." =~ m/\N{FULLWIDTH LEFT PARENTHESIS}./ && $& eq "\x{ff08}.", $message);
        ok("\x{ff08}." =~ m/[\N{FULLWIDTH LEFT PARENTHESIS}]./ && $& eq "\x{ff08}.", $message);
    }

SKIP: {
    ######## "Segfault using HTML::Entities", Richard Jolly <richardjolly@@mac.com>, <A3C7D27E-C9F4-11D8-B294-003065AE00B6@@mac.com> in perl-unicode@@perl.org

    skip('Perl configured without Encode module', 1)
	unless $Config{extensions} =~ / Encode /;

    # Test case cut down by jhi
    fresh_perl_like(<<'EOP', qr!Malformed UTF-8 character \(unexpected end of string\) in substitution \(s///\) at!, 'Segfault using HTML::Entities');
use Encode;
my $t = ord('A') == 193 ? "\xEA" : "\xE9";
Encode::_utf8_on($t);
$t =~ s/([^a])//ge;
EOP
    }

@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d25 1
a25 1
plan tests => 2532;  # Update this when adding/deleting tests.
d387 8
a394 1
    is(join('-', split /(?{ split "" })/, "abc"), 'a-b-c', 'nested split');
a924 1
         no warnings 'experimental::lexical_topic';
a930 4
         # Use a longer name to force reallocation of $REGMARK.
         $_ = "CCCCBAA";
         ok(s/(*:X)A+|(*:YYYYYYYYYYYYYYYY)B+|(*:Z)C+/$REGMARK/g, $message);
         is($_, "ZYYYYYYYYYYYYYYYYX", $message);
a1137 40
    {
        # pattern must be compiled late or we can break the test file
        my $message = '[perl #115050] repeated nothings in a trie can cause panic';
        my $pattern;
        $pattern = '[xyz]|||';
        ok("blah blah" =~ /$pattern/, $message);
        ok("blah blah" =~ /(?:$pattern)h/, $message);
        $pattern = '|||[xyz]';
        ok("blah blah" =~ /$pattern/, $message);
        ok("blah blah" =~ /(?:$pattern)h/, $message);
    }

    {
        # [perl #4289] First mention $& after a match
        local $::TODO = "these tests fail without Copy-on-Write enabled";
        fresh_perl_is(
            '$_ = "abc"; /b/g; $_ = "hello"; print eval q|$&|, "\n"',
            "b\n", {}, '$& first mentioned after match');
        fresh_perl_is(
            '$_ = "abc"; /b/g; $_ = "hello"; print eval q|$`|, "\n"',
            "a\n", {}, '$` first mentioned after match');
        fresh_perl_is(
            '$_ = "abc"; /b/g; $_ = "hello"; print eval q|$\'|,"\n"',
            "c\n", {}, '$\' first mentioned after match');
    }

    {
	# [perl #118175] threaded perl-5.18.0 fails pat_rt_report_thr.t
	# this tests some related failures
	#
	# The tests in the block *only* fail when run on 32-bit systems
	# with a malloc that allocates above the 2GB line.  On the system
	# in the report above that only happened in a thread.
	my $s = "\x{1ff}" . "f" x 32;
	ok($s =~ /\x{1ff}[[:alpha:]]+/gca, "POSIXA pointer wrap");

	# this one segfaulted under the conditions above
	# of course, CANY is evil, maybe it should crash
	ok($s =~ /.\C+/, "CANY pointer wrap");
    }
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d1128 1
a1128 1
    fresh_perl_like(<<'EOP', qr!Malformed UTF-8 character \(unexpected end of string\) in substitution \(s///\) at!, {}, 'Segfault using HTML::Entities');
d1150 1
a1150 2
	local $::TODO = "these tests fail without Copy-on-Write enabled"
	    if $Config{ccflags} =~ /PERL_NO_COW/;
@


