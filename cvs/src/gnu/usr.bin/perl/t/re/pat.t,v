head	1.9;
access;
symbols
	OPENBSD_6_2:1.9.0.6
	OPENBSD_6_2_BASE:1.9
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.1.0.10
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.8
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.6
	OPENBSD_5_0:1.1.1.1.0.4
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.2
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.9
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.8;
commitid	cxJ08BvJA9Pt2PTM;

1.8
date	2016.04.20.19.35.34;	author millert;	state Exp;
branches;
next	1.7;
commitid	ZEIabvJySz9djFex;

1.7
date	2015.04.25.19.26.22;	author afresh1;	state Exp;
branches;
next	1.6;
commitid	3qGYFVvfrExB70FB;

1.6
date	2015.04.25.19.14.49;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	XRK22kO4se3v2i2I;

1.5
date	2014.11.17.21.01.01;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	LnErp1MFKSuew5Fr;

1.4
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	QP75iYx42Uo7mMxO;

1.3
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.25.20.41.00;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2013.03.25.20.09.37;	author sthen;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.11;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.18;	author afresh1;	state Exp;
branches;
next	1.1.1.5;
commitid	B31cAbBIXiCqnL97;

1.1.1.5
date	2015.04.25.19.10.48;	author afresh1;	state Exp;
branches;
next	1.1.1.6;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.6
date	2017.08.14.13.46.25;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.9
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
#
# This is a home for regular expression tests that don't fit into
# the format supported by re/regexp.t.  If you want to add a test
# that does fit that format, add it to re/re_tests, not here.

use strict;
use warnings;
use 5.010;

sub run_tests;

$| = 1;


BEGIN {
    chdir 't' if -d 't';
    @@INC = ('../lib','.','../ext/re');
    require Config; import Config;
    require './test.pl'; require './charset_tools.pl';
    require './loc_tools.pl';
    skip_all('no re module') unless defined &DynaLoader::boot_DynaLoader;
    skip_all_without_unicode_tables();
}

plan tests => 789;  # Update this when adding/deleting tests.

run_tests() unless caller;

#
# Tests start here.
#
sub run_tests {

    {
        my $x = "abc\ndef\n";
	(my $x_pretty = $x) =~ s/\n/\\n/g;

        ok $x =~ /^abc/,  qq ["$x_pretty" =~ /^abc/];
        ok $x !~ /^def/,  qq ["$x_pretty" !~ /^def/];

        # used to be a test for $*
        ok $x =~ /^def/m, qq ["$x_pretty" =~ /^def/m];

        ok(!($x =~ /^xxx/), qq ["$x_pretty" =~ /^xxx/]);
        ok(!($x !~ /^abc/), qq ["$x_pretty" !~ /^abc/]);

         ok $x =~ /def/, qq ["$x_pretty" =~ /def/];
        ok(!($x !~ /def/), qq ["$x_pretty" !~ /def/]);

         ok $x !~ /.def/, qq ["$x_pretty" !~ /.def/];
        ok(!($x =~ /.def/), qq ["$x_pretty" =~ /.def/]);

         ok $x =~ /\ndef/, qq ["$x_pretty" =~ /\\ndef/];
        ok(!($x !~ /\ndef/), qq ["$x_pretty" !~ /\\ndef/]);
    }

    {
        $_ = '123';
        ok /^([0-9][0-9]*)/, qq [\$_ = '$_'; /^([0-9][0-9]*)/];
    }

    {
        $_ = 'aaabbbccc';
         ok /(a*b*)(c*)/ && $1 eq 'aaabbb' && $2 eq 'ccc',
                                             qq [\$_ = '$_'; /(a*b*)(c*)/];
         ok /(a+b+c+)/ && $1 eq 'aaabbbccc', qq [\$_ = '$_'; /(a+b+c+)/];
        unlike($_, qr/a+b?c+/, qq [\$_ = '$_'; /a+b?c+/]);

        $_ = 'aaabccc';
         ok /a+b?c+/, qq [\$_ = '$_'; /a+b?c+/];
         ok /a*b?c*/, qq [\$_ = '$_'; /a*b?c*/];

        $_ = 'aaaccc';
         ok /a*b?c*/, qq [\$_ = '$_'; /a*b?c*/];
        unlike($_, qr/a*b+c*/, qq [\$_ = '$_'; /a*b+c*/]);

        $_ = 'abcdef';
         ok /bcd|xyz/, qq [\$_ = '$_'; /bcd|xyz/];
         ok /xyz|bcd/, qq [\$_ = '$_'; /xyz|bcd/];
         ok m|bc/*d|,  qq [\$_ = '$_'; m|bc/*d|];
         ok /^$_$/,    qq [\$_ = '$_'; /^\$_\$/];
    }

    {
        # used to be a test for $*
        ok "ab\ncd\n" =~ /^cd/m, q ["ab\ncd\n" =~ /^cd/m];
    }

    {
        our %XXX = map {($_ => $_)} 123, 234, 345;

        our @@XXX = ('ok 1','not ok 1', 'ok 2','not ok 2','not ok 3');
        while ($_ = shift(@@XXX)) {
            my $e = index ($_, 'not') >= 0 ? '' : 1;
            my $r = m?(.*)?;
            is($r, $e, "?(.*)?");
            /not/ && reset;
            if (/not ok 2/) {
                if ($^O eq 'VMS') {
                    $_ = shift(@@XXX);
                }
                else {
                    reset 'X';
                }
            }
        }

        SKIP: {
            if ($^O eq 'VMS') {
                skip "Reset 'X'", 1;
            }
            ok !keys %XXX, "%XXX is empty";
        }

    }

    {
        my $message = "Test empty pattern";
        my $xyz = 'xyz';
        my $cde = 'cde';

        $cde =~ /[^ab]*/;
        $xyz =~ //;
        is($&, $xyz, $message);

        my $foo = '[^ab]*';
        $cde =~ /$foo/;
        $xyz =~ //;
        is($&, $xyz, $message);

        $cde =~ /$foo/;
        my $null;
        no warnings 'uninitialized';
        $xyz =~ /$null/;
        is($&, $xyz, $message);

        $null = "";
        $xyz =~ /$null/;
        is($&, $xyz, $message);
    }

    {
        my $message = q !Check $`, $&, $'!;
        $_ = 'abcdefghi';
        /def/;        # optimized up to cmd
        is("$`:$&:$'", 'abc:def:ghi', $message);

        no warnings 'void';
        /cde/ + 0;    # optimized only to spat
        is("$`:$&:$'", 'ab:cde:fghi', $message);

        /[d][e][f]/;    # not optimized
        is("$`:$&:$'", 'abc:def:ghi', $message);
    }

    {
        $_ = 'now is the {time for all} good men to come to.';
        / \{([^}]*)}/;
        is($1, 'time for all', "Match braces");
    }

    {
        my $message = "{N,M} quantifier";
        $_ = 'xxx {3,4}  yyy   zzz';
        ok(/( {3,4})/, $message);
        is($1, '   ', $message);
        unlike($_, qr/( {4,})/, $message);
        ok(/( {2,3}.)/, $message);
        is($1, '  y', $message);
        ok(/(y{2,3}.)/, $message);
        is($1, 'yyy ', $message);
        unlike($_, qr/x {3,4}/, $message);
        unlike($_, qr/^xxx {3,4}/, $message);
    }

    {
        my $message = "Test /g";
        local $" = ":";
        $_ = "now is the time for all good men to come to.";
        my @@words = /(\w+)/g;
        my $exp   = "now:is:the:time:for:all:good:men:to:come:to";

        is("@@words", $exp, $message);

        @@words = ();
        while (/\w+/g) {
            push (@@words, $&);
        }
        is("@@words", $exp, $message);

        @@words = ();
        pos = 0;
        while (/to/g) {
            push(@@words, $&);
        }
        is("@@words", "to:to", $message);

        pos $_ = 0;
        @@words = /to/g;
        is("@@words", "to:to", $message);
    }

    {
        $_ = "abcdefghi";

        my $pat1 = 'def';
        my $pat2 = '^def';
        my $pat3 = '.def.';
        my $pat4 = 'abc';
        my $pat5 = '^abc';
        my $pat6 = 'abc$';
        my $pat7 = 'ghi';
        my $pat8 = '\w*ghi';
        my $pat9 = 'ghi$';

        my $t1 = my $t2 = my $t3 = my $t4 = my $t5 =
        my $t6 = my $t7 = my $t8 = my $t9 = 0;

        for my $iter (1 .. 5) {
            $t1++ if /$pat1/o;
            $t2++ if /$pat2/o;
            $t3++ if /$pat3/o;
            $t4++ if /$pat4/o;
            $t5++ if /$pat5/o;
            $t6++ if /$pat6/o;
            $t7++ if /$pat7/o;
            $t8++ if /$pat8/o;
            $t9++ if /$pat9/o;
        }
        my $x = "$t1$t2$t3$t4$t5$t6$t7$t8$t9";
        is($x, '505550555', "Test /o");
    }

    {
        my $xyz = 'xyz';
        ok "abc" =~ /^abc$|$xyz/, "| after \$";

        # perl 4.009 says "unmatched ()"
        my $message = '$ inside ()';

        my $result;
        eval '"abc" =~ /a(bc$)|$xyz/; $result = "$&:$1"';
        is($@@, "", $message);
        is($result, "abc:bc", $message);
    }

    {
        my $message = "Scalar /g";
        $_ = "abcfooabcbar";

        ok( /abc/g && $` eq "", $message);
        ok( /abc/g && $` eq "abcfoo", $message);
        ok(!/abc/g, $message);

        $message = "Scalar /gi";
        pos = 0;
        ok( /ABC/gi && $` eq "", $message);
        ok( /ABC/gi && $` eq "abcfoo", $message);
        ok(!/ABC/gi, $message);

        $message = "Scalar /g";
        pos = 0;
        ok( /abc/g && $' eq "fooabcbar", $message);
        ok( /abc/g && $' eq "bar", $message);

        $_ .= '';
        my @@x = /abc/g;
        is(@@x, 2, "/g reset after assignment");
    }

    {
        my $message = '/g, \G and pos';
        $_ = "abdc";
        pos $_ = 2;
        /\Gc/gc;
        is(pos $_, 2, $message);
        /\Gc/g;
        is(pos $_, undef, $message);
    }

    {
        my $message = '(?{ })';
        our $out = 1;
        'abc' =~ m'a(?{ $out = 2 })b';
        is($out, 2, $message);

        $out = 1;
        'abc' =~ m'a(?{ $out = 3 })c';
        is($out, 1, $message);
    }

    {
        $_ = 'foobar1 bar2 foobar3 barfoobar5 foobar6';
        my @@out = /(?<!foo)bar./g;
        is("@@out", 'bar2 barf', "Negative lookbehind");
    }

    {
        my $message = "REG_INFTY tests";
        # Tests which depend on REG_INFTY

	#  Defaults assumed if this fails
	eval { require Config; };
        $::reg_infty   = $Config::Config{reg_infty} // 32767;
        $::reg_infty_m = $::reg_infty - 1;
        $::reg_infty_p = $::reg_infty + 1;
        $::reg_infty_m = $::reg_infty_m;   # Suppress warning.

        # As well as failing if the pattern matches do unexpected things, the
        # next three tests will fail if you should have picked up a lower-than-
        # default value for $reg_infty from Config.pm, but have not.

        is(eval q{('aaa' =~ /(a{1,$::reg_infty_m})/)[0]}, 'aaa', $message);
        is($@@, '', $message);
        is(eval q{('a' x $::reg_infty_m) =~ /a{$::reg_infty_m}/}, 1, $message);
        is($@@, '', $message);
        isnt(q{('a' x ($::reg_infty_m - 1)) !~ /a{$::reg_infty_m}/}, 1, $message);
        is($@@, '', $message);

        eval "'aaa' =~ /a{1,$::reg_infty}/";
        like($@@, qr/^\QQuantifier in {,} bigger than/, $message);
        eval "'aaa' =~ /a{1,$::reg_infty_p}/";
        like($@@, qr/^\QQuantifier in {,} bigger than/, $message);
    }

    {
        # Poke a couple more parse failures
        my $context = 'x' x 256;
        eval qq("${context}y" =~ /(?<=$context)y/);
        ok $@@ =~ /^\QLookbehind longer than 255 not/, "Lookbehind limit";
    }

    {
        # Long Monsters
        for my $l (125, 140, 250, 270, 300000, 30) { # Ordered to free memory
            my $a = 'a' x $l;
	    my $message = "Long monster, length = $l";
	    like("ba$a=", qr/a$a=/, $message);
            unlike("b$a=", qr/a$a=/, $message);
            like("b$a=", qr/ba+=/, $message);

	    like("ba$a=", qr/b(?:a|b)+=/, $message);
        }
    }

    {
        # 20000 nodes, each taking 3 words per string, and 1 per branch
        my $long_constant_len = join '|', 12120 .. 32645;
        my $long_var_len = join '|', 8120 .. 28645;
        my %ans = ( 'ax13876y25677lbc' => 1,
                    'ax13876y25677mcb' => 0, # not b.
                    'ax13876y35677nbc' => 0, # Num too big
                    'ax13876y25677y21378obc' => 1,
                    'ax13876y25677y21378zbc' => 0,    # Not followed by [k-o]
                    'ax13876y25677y21378y21378kbc' => 1,
                    'ax13876y25677y21378y21378kcb' => 0, # Not b.
                    'ax13876y25677y21378y21378y21378kbc' => 0, # 5 runs
                  );

        for (keys %ans) {
	    my $message = "20000 nodes, const-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_constant_len)){2,4}[k-o]).*b./o), $message;

	    $message = "20000 nodes, var-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_var_len)){2,4}[k-o]).*b./o,), $message;
        }
    }

    {
        my $message = "Complicated backtracking";
        $_ = " a (bla()) and x(y b((l)u((e))) and b(l(e)e)e";
        my $expect = "(bla()) ((l)u((e))) (l(e)e)";

        use vars '$c';
        sub matchit {
          m/
             (
               \(
               (?{ $c = 1 })    # Initialize
               (?:
                 (?(?{ $c == 0 })   # PREVIOUS iteration was OK, stop the loop
                   (?!
                   )        # Fail: will unwind one iteration back
                 )
                 (?:
                   [^()]+        # Match a big chunk
                   (?=
                     [()]
                   )        # Do not try to match subchunks
                 |
                   \(
                   (?{ ++$c })
                 |
                   \)
                   (?{ --$c })
                 )
               )+        # This may not match with different subblocks
             )
             (?(?{ $c != 0 })
               (?!
               )        # Fail
             )            # Otherwise the chunk 1 may succeed with $c>0
           /xg;
        }

        my @@ans = ();
        my $res;
        push @@ans, $res while $res = matchit;
        is("@@ans", "1 1 1", $message);

        @@ans = matchit;
        is("@@ans", $expect, $message);

        $message = "Recursion with (??{ })";
        our $matched;
        $matched = qr/\((?:(?>[^()]+)|(??{$matched}))*\)/;

        @@ans = my @@ans1 = ();
        push (@@ans, $res), push (@@ans1, $&) while $res = m/$matched/g;

        is("@@ans", "1 1 1", $message);
        is("@@ans1", $expect, $message);

        @@ans = m/$matched/g;
        is("@@ans", $expect, $message);

    }

    {
        ok "abc" =~ /^(??{"a"})b/, '"abc" =~ /^(??{"a"})b/';
    }

    {
        my @@ans = ('a/b' =~ m%(.*/)?(.*)%);    # Stack may be bad
        is("@@ans", 'a/ b', "Stack may be bad");
    }

    {
        my $message = "Eval-group not allowed at runtime";
        my $code = '{$blah = 45}';
        our $blah = 12;
        eval { /(?$code)/ };
        ok($@@ && $@@ =~ /not allowed at runtime/ && $blah == 12, $message);

	$blah = 12;
	my $res = eval { "xx" =~ /(?$code)/o };
	{
	    no warnings 'uninitialized';
	    chomp $@@; my $message = "$message '$@@', '$res', '$blah'";
	    ok($@@ && $@@ =~ /not allowed at runtime/ && $blah == 12, $message);
	}

        $code = '=xx';
	$blah = 12;
	$res = eval { "xx" =~ /(?$code)/o };
	{
	    no warnings 'uninitialized';
	    my $message = "$message '$@@', '$res', '$blah'";
	    ok(!$@@ && $res, $message);
	}

        $code = '{$blah = 45}';
        $blah = 12;
        eval "/(?$code)/";
        is($blah, 45, $message);

        $blah = 12;
        /(?{$blah = 45})/;
        is($blah, 45, $message);
    }

    {
        my $message = "Pos checks";
        my $x = 'banana';
        $x =~ /.a/g;
        is(pos $x, 2, $message);

        $x =~ /.z/gc;
        is(pos $x, 2, $message);

        sub f {
            my $p = $_[0];
            return $p;
        }

        $x =~ /.a/g;
        is(f (pos $x), 4, $message);
    }

    {
        my $message = 'Checking $^R';
        our $x = $^R = 67;
        'foot' =~ /foo(?{$x = 12; 75})[t]/;
        is($^R, 75, $message);

        $x = $^R = 67;
        'foot' =~ /foo(?{$x = 12; 75})[xy]/;
        ok($^R eq '67' && $x eq '12', $message);

        $x = $^R = 67;
        'foot' =~ /foo(?{ $^R + 12 })((?{ $x = 12; $^R + 17 })[xy])?/;
        ok($^R eq '79' && $x eq '12', $message);
    }

    {
        is(qr/\b\v$/i,    '(?^i:\b\v$)', 'qr/\b\v$/i');
        is(qr/\b\v$/s,    '(?^s:\b\v$)', 'qr/\b\v$/s');
        is(qr/\b\v$/m,    '(?^m:\b\v$)', 'qr/\b\v$/m');
        is(qr/\b\v$/x,    '(?^x:\b\v$)', 'qr/\b\v$/x');
        is(qr/\b\v$/xism, '(?^msix:\b\v$)',  'qr/\b\v$/xism');
        is(qr/\b\v$/,     '(?^:\b\v$)', 'qr/\b\v$/');
    }

    {   # Test that charset modifier work, and are interpolated
        is(qr/\b\v$/, '(?^:\b\v$)', 'Verify no locale, no unicode_strings gives default modifier');
        is(qr/(?l:\b\v$)/, '(?^:(?l:\b\v$))', 'Verify infix l modifier compiles');
        is(qr/(?u:\b\v$)/, '(?^:(?u:\b\v$))', 'Verify infix u modifier compiles');
        is(qr/(?l)\b\v$/, '(?^:(?l)\b\v$)', 'Verify (?l) compiles');
        is(qr/(?u)\b\v$/, '(?^:(?u)\b\v$)', 'Verify (?u) compiles');

        my $dual = qr/\b\v$/;
        my $locale;

      SKIP: {
            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');

            use locale;
            $locale = qr/\b\v$/;
            is($locale,    '(?^l:\b\v$)', 'Verify has l modifier when compiled under use locale');
            no locale;
        }

        use feature 'unicode_strings';
        my $unicode = qr/\b\v$/;
        is($unicode,    '(?^u:\b\v$)', 'Verify has u modifier when compiled under unicode_strings');
        is(qr/abc$dual/,    '(?^u:abc(?^:\b\v$))', 'Verify retains d meaning when interpolated under locale');

      SKIP: {
            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');

            is(qr/abc$locale/,    '(?^u:abc(?^l:\b\v$))', 'Verify retains l when interpolated under unicode_strings');
        }

        no feature 'unicode_strings';
      SKIP: {
            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');
            is(qr/abc$locale/,    '(?^:abc(?^l:\b\v$))', 'Verify retains l when interpolated outside locale and unicode strings');
        }

        is(qr/def$unicode/,    '(?^:def(?^u:\b\v$))', 'Verify retains u when interpolated outside locale and unicode strings');

      SKIP: {
            skip 'Locales not available', 2 unless locales_enabled('LC_CTYPE');

             use locale;
            is(qr/abc$dual/,    '(?^l:abc(?^:\b\v$))', 'Verify retains d meaning when interpolated under locale');
            is(qr/abc$unicode/,    '(?^l:abc(?^u:\b\v$))', 'Verify retains u when interpolated under locale');
        }
    }

    {
        my $message = "Look around";
        $_ = 'xabcx';
        foreach my $ans ('', 'c') {
            ok(/(?<=(?=a)..)((?=c)|.)/g, $message);
            is($1, $ans, $message);
        }
    }

    {
        my $message = "Empty clause";
        $_ = 'a';
        foreach my $ans ('', 'a', '') {
            ok(/^|a|$/g, $message);
            is($&, $ans, $message);
        }
    }

    {
        sub prefixify {
        my $message = "Prefixify";
            {
                my ($v, $a, $b, $res) = @@_;
                ok($v =~ s/\Q$a\E/$b/, $message);
                is($v, $res, $message);
            }
        }

        prefixify ('/a/b/lib/arch', "/a/b/lib", 'X/lib', 'X/lib/arch');
        prefixify ('/a/b/man/arch', "/a/b/man", 'X/man', 'X/man/arch');
    }

    {
        $_ = 'var="foo"';
        /(\")/;
        ok $1 && /$1/, "Capture a quote";
    }

    {
        no warnings 'closure';
        my $message = '(?{ $var } refers to package vars';
        package aa;
        our $c = 2;
        $::c = 3;
        '' =~ /(?{ $c = 4 })/;
        main::is($c, 4, $message);
        main::is($::c, 3, $message);
    }

    {
        is(eval 'q(a:[b]:) =~ /[x[:foo:]]/', undef);
	like ($@@, qr/POSIX class \[:[^:]+:\] unknown in regex/,
	      'POSIX class [: :] must have valid name');

        for my $d (qw [= .]) {
            is(eval "/[[${d}foo${d}]]/", undef);
	    like ($@@, qr/\QPOSIX syntax [$d $d] is reserved for future extensions/,
		  "POSIX syntax [[$d $d]] is an error");
        }
    }

    {
        # test if failure of patterns returns empty list
        my $message = "Failed pattern returns empty list";
        $_ = 'aaa';
        @@_ = /bbb/;
        is("@@_", "", $message);

        @@_ = /bbb/g;
        is("@@_", "", $message);

        @@_ = /(bbb)/;
        is("@@_", "", $message);

        @@_ = /(bbb)/g;
        is("@@_", "", $message);
    }

    {
        my $message = '@@- and @@+ tests';

        /a(?=.$)/;
        is($#+, 0, $message);
        is($#-, 0, $message);
        is($+ [0], 2, $message);
        is($- [0], 1, $message);
        ok(!defined $+ [1] && !defined $- [1] &&
           !defined $+ [2] && !defined $- [2], $message);

        /a(a)(a)/;
        is($#+, 2, $message);
        is($#-, 2, $message);
        is($+ [0], 3, $message);
        is($- [0], 0, $message);
        is($+ [1], 2, $message);
        is($- [1], 1, $message);
        is($+ [2], 3, $message);
        is($- [2], 2, $message);
        ok(!defined $+ [3] && !defined $- [3] &&
           !defined $+ [4] && !defined $- [4], $message);

        # Exists has a special check for @@-/@@+ - bug 45147
        ok(exists $-[0], $message);
        ok(exists $+[0], $message);
        ok(exists $-[2], $message);
        ok(exists $+[2], $message);
        ok(!exists $-[3], $message);
        ok(!exists $+[3], $message);
        ok(exists $-[-1], $message);
        ok(exists $+[-1], $message);
        ok(exists $-[-3], $message);
        ok(exists $+[-3], $message);
        ok(!exists $-[-4], $message);
        ok(!exists $+[-4], $message);

        /.(a)(b)?(a)/;
        is($#+, 3, $message);
        is($#-, 3, $message);
        is($+ [1], 2, $message);
        is($- [1], 1, $message);
        is($+ [3], 3, $message);
        is($- [3], 2, $message);
        ok(!defined $+ [2] && !defined $- [2] &&
           !defined $+ [4] && !defined $- [4], $message);

        /.(a)/;
        is($#+, 1, $message);
        is($#-, 1, $message);
        is($+ [0], 2, $message);
        is($- [0], 0, $message);
        is($+ [1], 2, $message);
        is($- [1], 1, $message);
        ok(!defined $+ [2] && !defined $- [2] &&
           !defined $+ [3] && !defined $- [3], $message);

        /.(a)(ba*)?/;
        is($#+, 2, $message);
        is($#-, 1, $message);

        # Check that values don’t stick
        "     "=~/()()()(.)(..)/;
        my($m,$p) = (\$-[5], \$+[5]);
        () = "$$_" for $m, $p; # FETCH (or eqv.)
        " " =~ /()/;
        is $$m, undef, 'values do not stick to @@- elements';
        is $$p, undef, 'values do not stick to @@+ elements';
    }

    foreach ('$+[0] = 13', '$-[0] = 13', '@@+ = (7, 6, 5)',
	     '@@- = qw (foo bar)', '$^N = 42') {
	is(eval $_, undef);
        like($@@, qr/^Modification of a read-only value attempted/,
	     '$^N, @@- and @@+ are read-only');
    }

    {
        my $message = '\G testing';
        $_ = 'aaa';
        pos = 1;
        my @@a = /\Ga/g;
        is("@@a", "a a", $message);

        my $str = 'abcde';
        pos $str = 2;
        unlike($str, qr/^\G/, $message);
        unlike($str, qr/^.\G/, $message);
        like($str, qr/^..\G/, $message);
        unlike($str, qr/^...\G/, $message);
        ok($str =~ /\G../ && $& eq 'cd', $message);
        ok($str =~ /.\G./ && $& eq 'bc', $message);

    }

    {
        my $message = '\G and intuit and anchoring';
	$_ = "abcdef";
	pos = 0;
	ok($_ =~ /\Gabc/, $message);
	ok($_ =~ /^\Gabc/, $message);

	pos = 3;
	ok($_ =~ /\Gdef/, $message);
	pos = 3;
	ok($_ =~ /\Gdef$/, $message);
	pos = 3;
	ok($_ =~ /abc\Gdef$/, $message);
	pos = 3;
	ok($_ =~ /^abc\Gdef$/, $message);
	pos = 3;
	ok($_ =~ /c\Gd/, $message);
	pos = 3;
	ok($_ =~ /..\GX?def/, $message);
    }

    {
        my $s = '123';
        pos($s) = 1;
        my @@a = $s =~ /(\d)\G/g; # this infinitely looped up till 5.19.1
        is("@@a", "1", '\G looping');
    }


    {
        my $message = 'pos inside (?{ })';
        my $str = 'abcde';
        our ($foo, $bar);
        like($str, qr/b(?{$foo = $_; $bar = pos})c/, $message);
        is($foo, $str, $message);
        is($bar, 2, $message);
        is(pos $str, undef, $message);

        undef $foo;
        undef $bar;
        pos $str = undef;
        ok($str =~ /b(?{$foo = $_; $bar = pos})c/g, $message);
        is($foo, $str, $message);
        is($bar, 2, $message);
        is(pos $str, 3, $message);

        $_ = $str;
        undef $foo;
        undef $bar;
        like($_, qr/b(?{$foo = $_; $bar = pos})c/, $message);
        is($foo, $str, $message);
        is($bar, 2, $message);

        undef $foo;
        undef $bar;
        ok(/b(?{$foo = $_; $bar = pos})c/g, $message);
        is($foo, $str, $message);
        is($bar, 2, $message);
        is(pos, 3, $message);

        undef $foo;
        undef $bar;
        pos = undef;
        1 while /b(?{$foo = $_; $bar = pos})c/g;
        is($foo, $str, $message);
        is($bar, 2, $message);
        is(pos, undef, $message);

        undef $foo;
        undef $bar;
        $_ = 'abcde|abcde';
        ok(s/b(?{$foo = $_; $bar = pos})c/x/g, $message);
        is($foo, 'abcde|abcde', $message);
        is($bar, 8, $message);
        is($_, 'axde|axde', $message);

        # List context:
        $_ = 'abcde|abcde';
        our @@res;
        () = /([ace]).(?{push @@res, $1,$2})([ce])(?{push @@res, $1,$2})/g;
        @@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
        is("@@res", "'a' undef 'a' 'c' 'e' undef 'a' undef 'a' 'c'", $message);

        @@res = ();
        () = /([ace]).(?{push @@res, $`,$&,$'})([ce])(?{push @@res, $`,$&,$'})/g;
        @@res = map {defined $_ ? "'$_'" : 'undef'} @@res;
        is("@@res", "'' 'ab' 'cde|abcde' " .
                     "'' 'abc' 'de|abcde' " .
                     "'abcd' 'e|' 'abcde' " .
                     "'abcde|' 'ab' 'cde' " .
                     "'abcde|' 'abc' 'de'", $message);
    }

    {
        my $message = '\G anchor checks';
        my $foo = 'aabbccddeeffgg';
        pos ($foo) = 1;

	ok($foo =~ /.\G(..)/g, $message);
	is($1, 'ab', $message);

	pos ($foo) += 1;
	ok($foo =~ /.\G(..)/g, $message);
	is($1, 'cc', $message);

	pos ($foo) += 1;
	ok($foo =~ /.\G(..)/g, $message);
	is($1, 'de', $message);

	ok($foo =~ /\Gef/g, $message);

        undef pos $foo;
        ok($foo =~ /\G(..)/g, $message);
        is($1, 'aa', $message);

        ok($foo =~ /\G(..)/g, $message);
        is($1, 'bb', $message);

        pos ($foo) = 5;
        ok($foo =~ /\G(..)/g, $message);
        is($1, 'cd', $message);
    }

    {
        my $message = 'basic \G floating checks';
        my $foo = 'aabbccddeeffgg';
        pos ($foo) = 1;

	ok($foo =~ /a+\G(..)/g, "$message: a+\\G");
	is($1, 'ab', "$message: ab");

	pos ($foo) += 1;
	ok($foo =~ /b+\G(..)/g, "$message: b+\\G");
	is($1, 'cc', "$message: cc");

	pos ($foo) += 1;
	ok($foo =~ /d+\G(..)/g, "$message: d+\\G");
	is($1, 'de', "$message: de");

	ok($foo =~ /\Gef/g, "$message: \\Gef");

        pos ($foo) = 1;

	ok($foo =~ /(?=a+\G)(..)/g, "$message: (?a+\\G)");
	is($1, 'aa', "$message: aa");

        pos ($foo) = 2;

	ok($foo =~ /a(?=a+\G)(..)/g, "$message: a(?=a+\\G)");
	is($1, 'ab', "$message: ab");

    }

    {
        $_ = '123x123';
        my @@res = /(\d*|x)/g;
        local $" = '|';
        is("@@res", "123||x|123|", "0 match in alternation");
    }

    {
        my $message = "Match against temporaries (created via pp_helem())" .
                         " is safe";
        ok({foo => "bar\n" . $^X} -> {foo} =~ /^(.*)\n/g, $message);
        is($1, "bar", $message);
    }

    {
        my $message = 'package $i inside (?{ }), ' .
                         'saved substrings and changing $_';
        our @@a = qw [foo bar];
        our @@b = ();
        s/(\w)(?{push @@b, $1})/,$1,/g for @@a;
        is("@@b", "f o o b a r", $message);
        is("@@a", ",f,,o,,o, ,b,,a,,r,", $message);

        $message = 'lexical $i inside (?{ }), ' .
                         'saved substrings and changing $_';
        no warnings 'closure';
        my @@c = qw [foo bar];
        my @@d = ();
        s/(\w)(?{push @@d, $1})/,$1,/g for @@c;
        is("@@d", "f o o b a r", $message);
        is("@@c", ",f,,o,,o, ,b,,a,,r,", $message);
    }

    {
        my $message = 'Brackets';
        our $brackets;
        $brackets = qr {
            {  (?> [^{}]+ | (??{ $brackets }) )* }
        }x;

        ok("{{}" =~ $brackets, $message);
        is($&, "{}", $message);
        ok("something { long { and } hairy" =~ $brackets, $message);
        is($&, "{ and }", $message);
        ok("something { long { and } hairy" =~ m/((??{ $brackets }))/, $message);
        is($&, "{ and }", $message);
    }

    {
        $_ = "a-a\nxbb";
        pos = 1;
        ok(!m/^-.*bb/mg, '$_ = "a-a\nxbb"; m/^-.*bb/mg');
    }

    {
        my $message = '\G anchor checks';
        my $text = "aaXbXcc";
        pos ($text) = 0;
        ok($text !~ /\GXb*X/g, $message);
    }

    {
        $_ = "xA\n" x 500;
        unlike($_, qr/^\s*A/m, '$_ = "xA\n" x 500; /^\s*A/m"');

        my $text = "abc dbf";
        my @@res = ($text =~ /.*?(b).*?\b/g);
        is("@@res", "b b", '\b is not special');
    }

    {
        my $message = '\S, [\S], \s, [\s]';
        my @@a = map chr, 0 .. 255;
        my @@b = grep m/\S/, @@a;
        my @@c = grep m/[^\s]/, @@a;
        is("@@b", "@@c", $message);

        @@b = grep /\S/, @@a;
        @@c = grep /[\S]/, @@a;
        is("@@b", "@@c", $message);

        @@b = grep /\s/, @@a;
        @@c = grep /[^\S]/, @@a;
        is("@@b", "@@c", $message);

        @@b = grep /\s/, @@a;
        @@c = grep /[\s]/, @@a;
        is("@@b", "@@c", $message);
    }
    {
        my $message = '\D, [\D], \d, [\d]';
        my @@a = map chr, 0 .. 255;
        my @@b = grep /\D/, @@a;
        my @@c = grep /[^\d]/, @@a;
        is("@@b", "@@c", $message);

        @@b = grep /\D/, @@a;
        @@c = grep /[\D]/, @@a;
        is("@@b", "@@c", $message);

        @@b = grep /\d/, @@a;
        @@c = grep /[^\D]/, @@a;
        is("@@b", "@@c", $message);

        @@b = grep /\d/, @@a;
        @@c = grep /[\d]/, @@a;
        is("@@b", "@@c", $message);
    }
    {
        my $message = '\W, [\W], \w, [\w]';
        my @@a = map chr, 0 .. 255;
        my @@b = grep /\W/, @@a;
        my @@c = grep /[^\w]/, @@a;
        is("@@b", "@@c", $message);

        @@b = grep /\W/, @@a;
        @@c = grep /[\W]/, @@a;
        is("@@b", "@@c", $message);

        @@b = grep /\w/, @@a;
        @@c = grep /[^\W]/, @@a;
        is("@@b", "@@c", $message);

        @@b = grep /\w/, @@a;
        @@c = grep /[\w]/, @@a;
        is("@@b", "@@c", $message);
    }

    {
        # see if backtracking optimization works correctly
        my $message = 'Backtrack optimization';
        like("\n\n", qr/\n   $ \n/x, $message);
        like("\n\n", qr/\n*  $ \n/x, $message);
        like("\n\n", qr/\n+  $ \n/x, $message);
        like("\n\n", qr/\n?  $ \n/x, $message);
        like("\n\n", qr/\n*? $ \n/x, $message);
        like("\n\n", qr/\n+? $ \n/x, $message);
        like("\n\n", qr/\n?? $ \n/x, $message);
        unlike("\n\n", qr/\n*+ $ \n/x, $message);
        unlike("\n\n", qr/\n++ $ \n/x, $message);
        like("\n\n", qr/\n?+ $ \n/x, $message);
    }

    {
        package S;
        use overload '""' => sub {'Object S'};
        sub new {bless []}

        my $message  = "Ref stringification";
      ::ok(do { \my $v} =~ /^SCALAR/,   "Scalar ref stringification") or diag($message);
      ::ok(do {\\my $v} =~ /^REF/,      "Ref ref stringification") or diag($message);
      ::ok([]           =~ /^ARRAY/,    "Array ref stringification") or diag($message);
      ::ok({}           =~ /^HASH/,     "Hash ref stringification") or diag($message);
      ::ok('S' -> new   =~ /^Object S/, "Object stringification") or diag($message);
    }

    {
        my $message = "Test result of match used as match";
        ok('a1b' =~ ('xyz' =~ /y/), $message);
        is($`, 'a', $message);
        ok('a1b' =~ ('xyz' =~ /t/), $message);
        is($`, 'a', $message);
    }

    {
        my $message = '"1" is not \s';
        warning_is(sub {unlike("1\n" x 102, qr/^\s*\n/m, $message)},
		   undef, "$message (did not warn)");
    }

    {
        my $message = '\s, [[:space:]] and [[:blank:]]';
        my %space = (spc   => " ",
                     tab   => "\t",
                     cr    => "\r",
                     lf    => "\n",
                     ff    => "\f",
        # There's no \v but the vertical tabulator seems miraculously
        # be 11 both in ASCII and EBCDIC.
                     vt    => chr(11),
                     false => "space");

        my @@space0 = sort grep {$space {$_} =~ /\s/         } keys %space;
        my @@space1 = sort grep {$space {$_} =~ /[[:space:]]/} keys %space;
        my @@space2 = sort grep {$space {$_} =~ /[[:blank:]]/} keys %space;

        is("@@space0", "cr ff lf spc tab vt", $message);
        is("@@space1", "cr ff lf spc tab vt", $message);
        is("@@space2", "spc tab", $message);
    }

    {
        my $n= 50;
        # this must be a high number and go from 0 to N, as the bug we are looking for doesn't
        # seem to be predictable. Slight changes to the test make it fail earlier or later.
        foreach my $i (0 .. $n)
        {
            my $str= "\n" x $i;
            ok $str=~/.*\z/, "implicit MBOL check string disable does not break things length=$i";
        }
    }
    {
        # we are actually testing that we dont die when executing these patterns
        use utf8;
        my $e = "Böck";
        ok(utf8::is_utf8($e),"got a unicode string - rt75680");

        ok($e !~ m/.*?[x]$/, "unicode string against /.*?[x]\$/ - rt75680");
        ok($e !~ m/.*?\p{Space}$/i, "unicode string against /.*?\\p{space}\$/i - rt75680");
        ok($e !~ m/.*?[xyz]$/, "unicode string against /.*?[xyz]\$/ - rt75680");
        ok($e !~ m/(.*?)[,\p{isSpace}]+((?:\p{isAlpha}[\p{isSpace}\.]{1,2})+)\p{isSpace}*$/, "unicode string against big pattern - rt75680");
    }
    {
        # we are actually testing that we dont die when executing these patterns
        my $e = "B" . uni_to_native("\x{f6}") . "ck";
        ok(!utf8::is_utf8($e), "got a latin string - rt75680");

        ok($e !~ m/.*?[x]$/, "latin string against /.*?[x]\$/ - rt75680");
        ok($e !~ m/.*?\p{Space}$/i, "latin string against /.*?\\p{space}\$/i - rt75680");
        ok($e !~ m/.*?[xyz]$/,"latin string against /.*?[xyz]\$/ - rt75680");
        ok($e !~ m/(.*?)[,\p{isSpace}]+((?:\p{isAlpha}[\p{isSpace}\.]{1,2})+)\p{isSpace}*$/,"latin string against big pattern - rt75680");
    }

    {
        #
        # Tests for bug 77414.
        #

        my $message = '\p property after empty * match';
        {
            like("1", qr/\s*\pN/, $message);
            like("-", qr/\s*\p{Dash}/, $message);
            like(" ", qr/\w*\p{Blank}/, $message);
        }

        like("1", qr/\s*\pN+/, $message);
        like("-", qr/\s*\p{Dash}{1}/, $message);
        like(" ", qr/\w*\p{Blank}{1,4}/, $message);

    }

    {   # Some constructs with Latin1 characters cause a utf8 string not
        # to match itself in non-utf8
        my $c = uni_to_native("\xc0");
        my $pattern = my $utf8_pattern = qr/(($c)+,?)/;
        utf8::upgrade($utf8_pattern);
        ok $c =~ $pattern, "\\xc0 =~ $pattern; Neither pattern nor target utf8";
        ok $c =~ /$pattern/i, "\\xc0 =~ /$pattern/i; Neither pattern nor target utf8";
        ok $c =~ $utf8_pattern, "\\xc0 =~ $pattern; pattern utf8, target not";
        ok $c =~ /$utf8_pattern/i, "\\xc0 =~ /$pattern/i; pattern utf8, target not";
        utf8::upgrade($c);
        ok $c =~ $pattern, "\\xc0 =~ $pattern; target utf8, pattern not";
        ok $c =~ /$pattern/i, "\\xc0 =~ /$pattern/i; target utf8, pattern not";
        ok $c =~ $utf8_pattern, "\\xc0 =~ $pattern; Both target and pattern utf8";
        ok $c =~ /$utf8_pattern/i, "\\xc0 =~ /$pattern/i; Both target and pattern utf8";
    }

    {   # Make sure can override the formatting
        use feature 'unicode_strings';
        ok uni_to_native("\xc0") =~ /\w/, 'Under unicode_strings: "\xc0" =~ /\w/';
        ok uni_to_native("\xc0") !~ /(?d:\w)/, 'Under unicode_strings: "\xc0" !~ /(?d:\w)/';
    }

    {
        my $str= "\x{100}";
        chop $str;
        my $qr= qr/$str/;
        is("$qr", "(?^:)", "Empty pattern qr// stringifies to (?^:) with unicode flag enabled - Bug #80212");
        $str= "";
        $qr= qr/$str/;
        is("$qr", "(?^:)", "Empty pattern qr// stringifies to (?^:) with unicode flag disabled - Bug #80212");

    }

    {
        local $::TODO = "[perl #38133]";

        "A" =~ /(((?:A))?)+/;
        my $first = $2;

        "A" =~ /(((A))?)+/;
        my $second = $2;

        is($first, $second);
    }

    {
	# RT #3516: \G in a m//g expression causes problems
	my $count = 0;
	while ("abc" =~ m/(\G[ac])?/g) {
	    last if $count++ > 10;
	}
	ok($count < 10, 'RT #3516 A');

	$count = 0;
	while ("abc" =~ m/(\G|.)[ac]/g) {
	    last if $count++ > 10;
	}
	ok($count < 10, 'RT #3516 B');

	$count = 0;
	while ("abc" =~ m/(\G?[ac])?/g) {
	    last if $count++ > 10;
	}
	ok($count < 10, 'RT #3516 C');
    }
    {
        # RT #84294: Is this a bug in the simple Perl regex?
        #          : Nested buffers and (?{...}) dont play nicely on partial matches
        our @@got= ();
        ok("ab" =~ /((\w+)(?{ push @@got, $2 })){2}/,"RT #84294: Pattern should match");
        my $want= "'ab', 'a', 'b'";
        my $got= join(", ", map { defined($_) ? "'$_'" : "undef" } @@got);
        is($got,$want,'RT #84294: check that "ab" =~ /((\w+)(?{ push @@got, $2 })){2}/ leaves @@got in the correct state');
    }

    {
        # Suppress warnings, as the non-unicode one comes out even if turn off
        # warnings here (because the execution is done in another scope).
        local $SIG{__WARN__} = sub {};
        my $str = "\x{110000}";

        unlike($str, qr/\p{ASCII_Hex_Digit=True}/, "Non-Unicode doesn't match \\p{AHEX=True}");
        like($str, qr/\p{ASCII_Hex_Digit=False}/, "Non-Unicode matches \\p{AHEX=False}");
        like($str, qr/\P{ASCII_Hex_Digit=True}/, "Non-Unicode matches \\P{AHEX=True}");
        unlike($str, qr/\P{ASCII_Hex_Digit=False}/, "Non-Unicode matches \\P{AHEX=FALSE}");
    }

    {
        # Test that IDstart works, but because the author (khw) knows
        # regexes much better than the rest of the core, it is being done here
        # in the context of a regex which relies on buffer names beginng with
        # IDStarts.
        use utf8;
        my $str = "abc";
        like($str, qr/(?<a>abc)/, "'a' is legal IDStart");
        like($str, qr/(?<_>abc)/, "'_' is legal IDStart");
        like($str, qr/(?<ß>abc)/, "U+00DF is legal IDStart");
        like($str, qr/(?<ℕ>abc)/, "U+2115' is legal IDStart");

        # This test works on Unicode 6.0 in which U+2118 and U+212E are legal
        # IDStarts there, but are not Word characters, and therefore Perl
        # doesn't allow them to be IDStarts.  But there is no guarantee that
        # Unicode won't change things around in the future so that at some
        # future Unicode revision these tests would need to be revised.
        foreach my $char ("%", "×", chr(0x2118), chr(0x212E)) {
            my $prog = <<"EOP";
use utf8;;
"abc" =~ qr/(?<$char>abc)/;
EOP
            utf8::encode($prog);
            fresh_perl_like($prog, qr!Group name must start with a non-digit word character!, {},
                        sprintf("'U+%04X not legal IDFirst'", ord($char)));
        }
    }

    { # [perl #101710]
        my $pat = "b";
        utf8::upgrade($pat);
        like("\xffb", qr/$pat/i, "/i: utf8 pattern, non-utf8 string, latin1-char preceding matching char in string");
    }

    { # Crash with @@a =~ // warning
	local $SIG{__WARN__} = sub {
             pass 'no crash for @@a =~ // warning'
        };
	eval ' sub { my @@a =~ // } ';
    }

    { # Concat overloading and qr// thingies
	my @@refs;
	my $qr = qr//;
        package Cat {
            require overload;
            overload->import(
		'""' => sub { ${$_[0]} },
		'.' => sub {
		    push @@refs, ref $_[1] if ref $_[1];
		    bless $_[2] ? \"$_[1]${$_[0]}" : \"${$_[0]}$_[1]"
		}
            );
	}
	my $s = "foo";
	my $o = bless \$s, Cat::;
	/$o$qr/;
	is "@@refs", "Regexp", '/$o$qr/ passes qr ref to cat overload meth';
    }

    {
        my $count=0;
        my $str="\n";
        $count++ while $str=~/.*/g;
        is $count, 2, 'test that ANCH_MBOL works properly. We should get 2 from $count++ while "\n"=~/.*/g';
        my $class_count= 0;
        $class_count++ while $str=~/[^\n]*/g;
        is $class_count, $count, 'while "\n"=~/.*/g and while "\n"=~/[^\n]*/g should behave the same';
        my $anch_count= 0;
        $anch_count++ while $str=~/^.*/mg;
        is $anch_count, 1, 'while "\n"=~/^.*/mg should match only once';
    }

    { # [perl #111174]
        use re '/u';
        my $A_grave = uni_to_native("\xc0");
        like uni_to_native("\xe0"), qr/(?i:$A_grave)/, "(?i: shouldn't lose the passed in /u";
        use re '/a';
        unlike "\x{100}", qr/(?i:\w)/, "(?i: shouldn't lose the passed in /a";
        use re '/aa';
        unlike 'k', qr/(?i:\N{KELVIN SIGN})/, "(?i: shouldn't lose the passed in /aa";
    }

    {
	# the test for whether the pattern should be re-compiled should
	# consider the UTF8ness of the previous and current pattern
	# string, as well as the physical bytes of the pattern string

	for my $s (byte_utf8a_to_utf8n("\xc4\x80"), "\x{100}") {
	    ok($s =~ /^$s$/, "re-compile check is UTF8-aware");
	}
    }

    #  #113682 more overloading and qr//
    # when doing /foo$overloaded/, if $overloaded returns
    # a qr/(?{})/ via qr or "" overloading, then 'use re 'eval'
    # shouldn't be required. Via '.', it still is.
    {
        package Qr0;
	use overload 'qr' => sub { qr/(??{50})/ };

        package Qr1;
	use overload '""' => sub { qr/(??{51})/ };

        package Qr2;
	use overload '.'  => sub { $_[1] . qr/(??{52})/ };

        package Qr3;
	use overload '""' => sub { qr/(??{7})/ },
		     '.'  => sub { $_[1] . qr/(??{53})/ };

        package Qr_indirect;
	use overload '""'  => sub { $_[0][0] };

	package main;

	for my $i (0..3) {
	    my $o = bless [], "Qr$i";
	    if ((0,0,1,1)[$i]) {
		eval { "A5$i" =~ /^A$o$/ };
		like($@@, qr/Eval-group not allowed/, "Qr$i");
		eval { "5$i" =~ /$o/ };
		like($@@, ($i == 3 ? qr/^$/ : qr/no method found,/),
			"Qr$i bare");
		{
		    use re 'eval';
		    ok("A5$i" =~ /^A$o$/, "Qr$i - with use re eval");
		    eval { "5$i" =~ /$o/ };
		    like($@@, ($i == 3 ? qr/^$/ : qr/no method found,/),
			    "Qr$i bare - with use re eval");
		}
	    }
	    else {
		ok("A5$i" =~ /^A$o$/, "Qr$i");
		ok("5$i" =~ /$o/, "Qr$i bare");
	    }
	}

	my $o = bless [ bless [], "Qr1" ], 'Qr_indirect';
	ok("A51" =~ /^A$o/, "Qr_indirect");
	ok("51" =~ /$o/, "Qr_indirect bare");
    }

    {   # Various flags weren't being set when a [] is optimized into an
        # EXACTish node
        ;
        ;
        my $sharp_s = uni_to_native("\xdf");
        ok("\x{017F}\x{017F}" =~ qr/^[$sharp_s]?$/i, "[] to EXACTish optimization");
    }

    {
        for my $char (":", uni_to_native("\x{f7}"), "\x{2010}") {
            my $utf8_char = $char;
            utf8::upgrade($utf8_char);
            my $display = $char;
            $display = display($display);
            my $utf8_display = "utf8::upgrade(\"$display\")";

            like($char, qr/^$char?$/, "\"$display\" =~ /^$display?\$/");
            like($char, qr/^$utf8_char?$/, "my \$p = \"$display\"; utf8::upgrade(\$p); \"$display\" =~ /^\$p?\$/");
            like($utf8_char, qr/^$char?$/, "my \$c = \"$display\"; utf8::upgrade(\$c); \"\$c\" =~ /^$display?\$/");
            like($utf8_char, qr/^$utf8_char?$/, "my \$c = \"$display\"; utf8::upgrade(\$c); my \$p = \"$display\"; utf8::upgrade(\$p); \"\$c\" =~ /^\$p?\$/");
        }
    }

    {
	# #116148: Pattern utf8ness sticks around globally
	# the utf8 in the first match was sticking around for the second
	# match

	use feature 'unicode_strings';

	my $x = "\x{263a}";
	$x =~ /$x/;

	my $text = "Perl";
	ok("Perl" =~ /P.*$/i, '#116148');
    }

    { # 118297: Mixing up- and down-graded strings in regex
        utf8::upgrade(my $u = "\x{e5}");
        utf8::downgrade(my $d = "\x{e5}");
        my $warned;
        local $SIG{__WARN__} = sub { $warned++ if $_[0] =~ /\AMalformed UTF-8/ };
        my $re = qr/$u$d/;
        ok(!$warned, "no warnings when interpolating mixed up-/downgraded strings in pattern");
        my $c = "\x{e5}\x{e5}";
        utf8::downgrade($c);
        like($c, $re, "mixed up-/downgraded pattern matches downgraded string");
        utf8::upgrade($c);
        like($c, $re, "mixed up-/downgraded pattern matches upgraded string");
    }

    {
        # if we have 87 capture buffers defined then \87 should refer to the 87th.
        # test that this is true for 1..100
        # Note that this test causes the engine to recurse at runtime, and
        # hence use a lot of C stack.
        for my $i (1..100) {
            my $capture= "a";
            $capture= "($capture)" for 1 .. $i;
            for my $mid ("","b") {
                my $str= "a${mid}a";
                my $backref= "\\$i";
                eval {
                    ok($str=~/$capture$mid$backref/,"\\$i works with $i buffers '$str'=~/...$mid$backref/");
                    1;
                } or do {
                    is("$@@","","\\$i works with $i buffers works with $i buffers '$str'=~/...$mid$backref/");
                };
            }
        }
    }

    # this mixture of readonly (not COWable) and COWable strings
    # messed up the capture buffers under COW. The actual test results
    # are incidental; the issue is was an AddressSanitizer failure
    {
	my $c ='AB';
	my $res = '';
	for ($c, 'C', $c, 'DE') {
	    ok(/(.)/, "COWable match");
	    $res .= $1;
	}
	is($res, "ACAD");
    }


    {
	# RT #45667
	# /[#$x]/x didn't interpolate the var $x.
	my $b = 'cd';
	my $s = 'abcd$%#&';
	$s =~ s/[a#$b%]/X/g;
	is ($s, 'XbXX$XX&', 'RT #45667 without /x');
	$s = 'abcd$%#&';
	$s =~ s/[a#$b%]/X/gx;
	is ($s, 'XbXX$XX&', 'RT #45667 with /x');
    }

    {
	no warnings "uninitialized";
	my @@a;
	$a[1]++;
	/@@a/;
	pass('no crash with /@@a/ when array has nonexistent elems');
    }

    {
	is runperl(prog => 'delete $::{qq-\cR-}; //; print qq-ok\n-'),
	   "ok\n",
	   'deleting *^R does not result in crashes';
	no warnings 'once';
	*^R = *caretRglobwithnoscalar;
	"" =~ /(?{42})/;
	is $^R, 42, 'assigning to *^R does not result in a crash';
	is runperl(
	     stderr => 1,
	     prog => 'eval q|'
	            .' q-..- =~ /(??{undef *^R;q--})(?{42})/; '
                    .' print qq-$^R\n-'
	            .'|'
	   ),
	   "42\n",
	   'undefining *^R within (??{}) does not result in a crash';
    }

    SKIP: {   # Test literal range end point special handling
        unless ($::IS_EBCDIC) {
            skip "Valid only for EBCDIC", 24;
        }

        like("\x89", qr/[i-j]/, '"\x89" should match [i-j]');
        unlike("\x8A", qr/[i-j]/, '"\x8A" shouldnt match [i-j]');
        unlike("\x90", qr/[i-j]/, '"\x90" shouldnt match [i-j]');
        like("\x91", qr/[i-j]/, '"\x91" should match [i-j]');

        like("\x89", qr/[i-\N{LATIN SMALL LETTER J}]/, '"\x89" should match [i-\N{LATIN SMALL LETTER J}]');
        unlike("\x8A", qr/[i-\N{LATIN SMALL LETTER J}]/, '"\x8A" shouldnt match [i-\N{LATIN SMALL LETTER J}]');
        unlike("\x90", qr/[i-\N{LATIN SMALL LETTER J}]/, '"\x90" shouldnt match [i-\N{LATIN SMALL LETTER J}]');
        like("\x91", qr/[i-\N{LATIN SMALL LETTER J}]/, '"\x91" should match [i-\N{LATIN SMALL LETTER J}]');

        like("\x89", qr/[i-\N{U+6A}]/, '"\x89" should match [i-\N{U+6A}]');
        unlike("\x8A", qr/[i-\N{U+6A}]/, '"\x8A" shouldnt match [i-\N{U+6A}]');
        unlike("\x90", qr/[i-\N{U+6A}]/, '"\x90" shouldnt match [i-\N{U+6A}]');
        like("\x91", qr/[i-\N{U+6A}]/, '"\x91" should match [i-\N{U+6A}]');

        like("\x89", qr/[\N{U+69}-\N{U+6A}]/, '"\x89" should match [\N{U+69}-\N{U+6A}]');
        unlike("\x8A", qr/[\N{U+69}-\N{U+6A}]/, '"\x8A" shouldnt match [\N{U+69}-\N{U+6A}]');
        unlike("\x90", qr/[\N{U+69}-\N{U+6A}]/, '"\x90" shouldnt match [\N{U+69}-\N{U+6A}]');
        like("\x91", qr/[\N{U+69}-\N{U+6A}]/, '"\x91" should match [\N{U+69}-\N{U+6A}]');

        like("\x89", qr/[i-\x{91}]/, '"\x89" should match [i-\x{91}]');
        like("\x8A", qr/[i-\x{91}]/, '"\x8A" should match [i-\x{91}]');
        like("\x90", qr/[i-\x{91}]/, '"\x90" should match [i-\x{91}]');
        like("\x91", qr/[i-\x{91}]/, '"\x91" should match [i-\x{91}]');

        # Need to use eval, because tries to compile on ASCII platforms even
        # though the tests are skipped, and fails because 0x89-j is an illegal
        # range there.
        like("\x89", eval 'qr/[\x{89}-j]/', '"\x89" should match [\x{89}-j]');
        like("\x8A", eval 'qr/[\x{89}-j]/', '"\x8A" should match [\x{89}-j]');
        like("\x90", eval 'qr/[\x{89}-j]/', '"\x90" should match [\x{89}-j]');
        like("\x91", eval 'qr/[\x{89}-j]/', '"\x91" should match [\x{89}-j]');
    }

    # These are based on looking at the code in regcomp.c
    # We don't look for specific code, just the existence of an SSC
    foreach my $re (qw(     qr/a?c/
                            qr/a?c/i
                            qr/[ab]?c/
                            qr/\R?c/
                            qr/\d?c/d
                            qr/\w?c/l
                            qr/\s?c/a
                            qr/[[:lower:]]?c/u
    )) {
      SKIP: {
        skip "no re-debug under miniperl" if is_miniperl;
        my $prog = <<"EOP";
use re qw(Debug COMPILE);
$re;
EOP
        fresh_perl_like($prog, qr/synthetic stclass/, { stderr=>1 }, "$re generates a synthetic start class");
      }
    }

    {
        like "\x{AA}", qr/a?[\W_]/d, "\\W with /d synthetic start class works";
    }

    SKIP: {
        skip("Tests are ASCII-centric, some would fail on EBCDIC", 12) if $::IS_EBCDIC;

        # Verify that the very last Latin-1 U+00FF
        # (LATIN SMALL LETTER Y WITH DIAERESIS)
        # and its UPPER counterpart (U+0178 which is pure Unicode),
        # and likewise for the very first pure Unicode
        # (LATIN CAPITAL LETTER A WITH MACRON) fold-match properly,
        # and there are no off-by-one logic errors in the transition zone.

        ok("\xFF" =~ /\xFF/i, "Y WITH DIAERESIS l =~ l");
        ok("\xFF" =~ /\x{178}/i, "Y WITH DIAERESIS l =~ u");
        ok("\x{178}" =~ /\xFF/i, "Y WITH DIAERESIS u =~ l");
        ok("\x{178}" =~ /\x{178}/i, "Y WITH DIAERESIS u =~ u");

        # U+00FF with U+05D0 (non-casing Hebrew letter).
        ok("\xFF\x{5D0}" =~ /\xFF\x{5D0}/i, "Y WITH DIAERESIS l =~ l");
        ok("\xFF\x{5D0}" =~ /\x{178}\x{5D0}/i, "Y WITH DIAERESIS l =~ u");
        ok("\x{178}\x{5D0}" =~ /\xFF\x{5D0}/i, "Y WITH DIAERESIS u =~ l");
        ok("\x{178}\x{5D0}" =~ /\x{178}\x{5D0}/i, "Y WITH DIAERESIS u =~ u");

        # U+0100.
        ok("\x{100}" =~ /\x{100}/i, "A WITH MACRON u =~ u");
        ok("\x{100}" =~ /\x{101}/i, "A WITH MACRON u =~ l");
        ok("\x{101}" =~ /\x{100}/i, "A WITH MACRON l =~ u");
        ok("\x{101}" =~ /\x{101}/i, "A WITH MACRON l =~ l");
    }

    {
        use utf8;
        ok("abc" =~ /abc/x, "NEL is white-space under /x");
    }

    {
        ok('a(b)c' =~ qr(a\(b\)c), "'\\(' is a literal in qr(...)");
        ok('a[b]c' =~ qr[a\[b\]c], "'\\[' is a literal in qr[...]");
        ok('a{3}c' =~ qr{a\{3\}c},  # Only failed when { could be a meta
              "'\\{' is a literal in qr{...}, where it could be a quantifier");

        # This one is for completeness
        ok('a<b>c' =~ qr<a\<b\>c>, "'\\<' is a literal in qr<...>)");
    }

    {   # Was getting optimized into EXACT (non-folding node)
        my $x = qr/[x]/i;
        utf8::upgrade($x);
        like("X", qr/$x/, "UTF-8 of /[x]/i matches upper case");
    }

    {   # make sure we get an error when \p{} cannot load Unicode tables
        fresh_perl_like(<<'        prog that cannot load uni tables',
            BEGIN {
                @@INC = '../lib';
                require utf8; require 'utf8_heavy.pl';
                @@INC = ();
            }
            $name = 'A B';
            if ($name =~ /(\p{IsUpper}) (\p{IsUpper})/){
                print "It's good! >$1< >$2<\n";
            } else {
                print "It's not good...\n";
            }
        prog that cannot load uni tables
                  qr/^Can't locate unicore\/Heavy\.pl(?x:
                   )|^Can't find Unicode property definition/,
                  undef,
                 '\p{} should not fail silently when uni tables evanesce');
    }

    {   # Special handling of literal-ended ranges in [...] was breaking this
        use utf8;
        like("ÿ", qr/[ÿ-ÿ]/, "\"ÿ\" should match [ÿ-ÿ]");
    }

    {	# [perl #123539]
        like("TffffffffffffTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff", qr/TffffffffffffTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff/il, "");
        like("TffffffffffffT\x{100}TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff", qr/TffffffffffffT\x{100}TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff/il, "");
    }

	{	# [perl #123604]
		my($s, $x, @@x) = ('abc', 'a', 'd');
		my $long = 'b' x 2000;
		my $eval = q{$s =~ m{$x[bbb]c} ? 1 : 0};
		$eval =~ s{bbb}{$long};
		my $match = eval $eval;
		ok(1, "did not crash");
		ok($match, "[bbb...] resolved as character class, not subscript");
	}

	{	# [perl #123755]
		for my $pat ('(??', '(?P', '(?i-') {
			eval qq{ qr/$pat/ };
			ok(1, "qr/$pat/ did not crash");
			eval qq{ qr/${pat}\x{123}/ };
			my $e = $@@;
			like($e, qr{\x{123}},
				"qr/${pat}x/ shows x in error even if it's a wide character");
		}
	}

	{
		# Expect one of these sizes to cause overflow and wrap to negative
		for my $bits (32, 64) {
			my $wrapneg = 2 ** ($bits - 2) * 3;
			for my $sign ('', '-') {
				my $pat = sprintf "qr/(?%s%u)/", $sign, $wrapneg;
				eval $pat;
				ok(1, "big backref $pat did not crash");
			}
		}
	}
        {
            # Test that we handle qr/\8888888/ and variants without an infinite loop,
            # we use a test within a test so we can todo it, and make sure we don't
            # infinite loop our tests.
            # NOTE - Do not put quotes in the code!
            # NOTE - We have to triple escape the backref in the pattern below.
            my $code='
                BEGIN{require q(test.pl);}
                watchdog(3);
                for my $len (1 .. 20) {
                    my $eights= q(8) x $len;
                    eval qq{ qr/\\\\$eights/ };
                }
                print q(No infinite loop here!);
            ';
            fresh_perl_is($code, "No infinite loop here!", {},
                "test that we handle things like m/\\888888888/ without infinite loops" );
        }

        {   # Test that we handle some malformed UTF-8 without looping [perl
            # #123562]

            my $code='
                BEGIN{require q(test.pl);}
                use Encode qw(_utf8_on);
                # \x80 and \x41 are continuation bytes in their respective
                # character sets
                my $malformed = (ord("A") == 65) ? "a\x80\n" : "a\x41\n";
                utf8::downgrade($malformed);
                _utf8_on($malformed);
                watchdog(3);
                $malformed =~ /(\n\r|\r)$/;
                print q(No infinite loop here!);
            ';
            fresh_perl_like($code, qr/Malformed UTF-8 character/, {},
                "test that we handle some UTF-8 malformations without looping" );
        }

	{
		# [perl #123843] hits SEGV trying to compile this pattern
		my $match;
		eval q{ ($match) = ("xxyxxyxy" =~ m{(x+(y(?1))*)}) };
		ok(1, "compiled GOSUB in CURLYM ok");
		is($match, 'xxyxxyx', "matched GOSUB in CURLYM");
	}

	{
		# [perl #123852] doesn't avoid all the capture-related work with
		# //n, leading to possible memory corruption
		eval q{ qr{()(?1)}n };
		my $error = $@@;
		ok(1, "qr{()(?1)}n didn't crash");
		like($error, qr{Reference to nonexistent group},
				'gave appropriate error for qr{()(?1)}n');
	}

	{
            # [perl #126406] panic with unmatchable quantifier
            my $code='
                no warnings "regexp";
                "" =~ m/(.0\N{6,0}0\N{6,0}000000000000000000000000000000000)/;
            ';
            fresh_perl_is($code, "", {},
                            "perl [#126406] panic");
	}
        {
            my $bug="[perl #126182]"; # test for infinite pattern recursion
            for my $tuple (
                    [ 'q(a)=~/(.(?2))((?<=(?=(?1)).))/', "died", "look ahead left recursion fails fast" ],
                    [ 'q(aa)=~/(?R)a/', "died", "left-recursion fails fast", ],
                    [ 'q(bbaa)=~/(?&x)(?(DEFINE)(?<x>(?&y)*a)(?<y>(?&x)*b))/',
                        "died", "inter-cyclic optional left recursion dies" ],
                    [ 'q(abc) =~ /a((?1)?)c/', "died", "optional left recursion dies" ],
                    [ 'q(abc) =~ /a((?1)??)c/', "died", "min mod left recursion dies" ],
                    [ 'q(abc) =~ /a((?1)*)c/', "died", "* left recursion dies" ],
                    [ 'q(abc) =~ /a((?1)+)c/', "died", "+ left recursion dies" ],
                    [ 'q(abc) =~ /a((?1){0,3})c/', "died", "{0,3} left recursion fails fast" ],

                    [ 'q(aaabbb)=~/a(?R)?b/', "matched", "optional self recursion works" ],
                    [ '"((5maa-maa)(maa-3maa))" =~ /(\\\\((?:[^()]++|(?0))*+\\\\))/', "matched",
                        "recursion and possessive captures", "((5maa-maa)(maa-3maa))"],
                    [ '"((5maa-maa)(maa-3maa))" =~ /(\\\\((?:[^()]++|(?1))*+\\\\))/', "matched",
                        "recursion and possessive captures", "((5maa-maa)(maa-3maa))"],
                    [ '"((5maa-maa)(maa-3maa))" =~ /(\\\\((?:[^()]+|(?0))*\\\\))/', "matched",
                        "recursion and possessive captures", "((5maa-maa)(maa-3maa))"],
                    [ '"((5maa-maa)(maa-3maa))" =~ /(\\\\((?:[^()]+|(?1))*\\\\))/', "matched",
                        "recursion and possessive captures", "((5maa-maa)(maa-3maa))"],
            ) {
                my ($expr, $expect, $test_name, $cap1)= @@$tuple;
                # avoid quotes in this code!
                my $code='
                    BEGIN{require q(test.pl);}
                    watchdog(3);
                    my $status= eval(q{ !(' . $expr . ') ? q(failed) : ' .
                        ($cap1 ? '($1 ne q['.$cap1.']) ? qq(badmatch:$1) : ' : '') .
                        ' q(matched) })
                                || ( ( $@@ =~ /Infinite recursion/ ) ? qq(died) : q(strange-death) );
                    print $status;
                ';
                fresh_perl_is($code, $expect, {}, "$bug - $test_name" );
            }
        }
} # End of sub run_tests

1;
@


1.8
log
@Apply fix for perl bug 123562 which has been assigned CVE-2015-8853.
It can cause certain regular expressions with malformed UTF8 inputs
to go into a forever loop and consume 100% CPU.  OK afresh1@@
@
text
@d18 1
a18 1
    @@INC = ('../lib','.');
d20 4
a23 1
    require './test.pl';
d26 1
a26 1
plan tests => 727;  # Update this when adding/deleting tests.
d515 1
a515 7
    SKIP: {   # Test that charset modifier work, and are interpolated
        if (
            !$Config::Config{d_setlocale}
        || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
        ) {
            skip "no locale support", 13
        }
d526 1
a526 1
            skip 'No locale testing without d_setlocale', 1 if(!$Config{d_setlocale});
d528 1
a528 5
            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d540 1
a540 1
            skip 'No locale testing without d_setlocale', 1 if(!$Config{d_setlocale});
d547 1
a547 2
            skip 'No locale testing without d_setlocale', 1 if(!$Config{d_setlocale});

d554 1
a554 1
            skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale});
d556 1
a556 5
             BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
d1102 1
a1102 1
        my $e = "B\x{f6}ck";
d1129 4
a1132 7
    SKIP: {   # Some constructs with Latin1 characters cause a utf8 string not
              # to match itself in non-utf8
        if ($::IS_EBCDIC) {
            skip "Needs to be customized to run on EBCDIC", 6;
        }
        my $c = "\xc0";
        my $pattern = my $utf8_pattern = qr/((\xc0)+,?)/;
d1145 1
a1145 4
    SKIP: {   # Make sure can override the formatting
        if ($::IS_EBCDIC) {
            skip "Needs to be customized to run on EBCDIC", 2;
        }
d1147 2
a1148 2
        ok "\xc0" =~ /\w/, 'Under unicode_strings: "\xc0" =~ /\w/';
        ok "\xc0" !~ /(?d:\w)/, 'Under unicode_strings: "\xc0" !~ /(?d:\w)/';
d1291 2
a1292 1
        like "\xe0", qr/(?i:\xc0)/, "(?i: shouldn't lose the passed in /u";
d1304 1
a1304 1
	for my $s ("\xc4\x80", "\x{100}") {
d1363 2
a1364 1
        ok("\x{017F}\x{017F}" =~ qr/^[\x{00DF}]?$/i, "[] to EXACTish optimization");
d1368 1
a1368 1
        for my $char (":", "\x{f7}", "\x{2010}") {
a1395 7
    { # 117327: Sequence (?#...) not recognized in regex
      # The space between the '(' and '?' is now deprecated; this test should
      # be removed when the deprecation is made fatal.
        no warnings;
        like("ab", qr/a( ?#foo)b/x);
    }

d1484 37
a1520 55
    {
        # [perl #120446]
        # this code should be virtually instantaneous. If it takes 10s of
        # seconds, there a bug in intuit_start.
        # (this test doesn't actually test for slowness - that involves
        # too much danger of false positives on loaded machines - but by
        # putting it here, hopefully someone might notice if it suddenly
        # runs slowly)
        my $s = ('a' x 1_000_000) . 'b';
        my $i = 0;
        for (1..10_000) {
            pos($s) = $_;
            $i++ if $s =~/\Gb/g;
        }
        is($i, 0, "RT 120446: mustn't run slowly");
    }

    {
        # [perl #120692]
        # these tests should be virtually instantaneous. If they take 10s of
        # seconds, there's a bug in intuit_start.

        my $s = 'ab' x 1_000_000;
        utf8::upgrade($s);
        1 while $s =~ m/\Ga+ba+b/g;
        pass("RT#120692 \\G mustn't run slowly");

        $s=~ /^a{1,2}x/ for  1..10_000;
        pass("RT#120692 a{1,2} mustn't run slowly");

        $s=~ /ab.{1,2}x/;
        pass("RT#120692 ab.{1,2} mustn't run slowly");

        $s = "-a-bc" x 250_000;
        $s .= "1a1bc";
        utf8::upgrade($s);
        ok($s =~ /\da\d{0,30000}bc/, "\\d{30000}");

        $s = "-ab\n" x 250_000;
        $s .= "abx";
        ok($s =~ /^ab.*x/m, "distant float with /m");

        my $r = qr/^abcd/;
        $s = "abcd-xyz\n" x 500_000;
        $s =~ /$r\d{1,2}xyz/m for 1..200;
        pass("BOL within //m  mustn't run slowly");

        $s = "abcdefg" x 1_000_000;
        $s =~ /(?-m:^)abcX?fg/m for 1..100;
        pass("BOL within //m  mustn't skip absolute anchored check");

        $s = "abcdefg" x 1_000_000;
        $s =~ /^XX\d{1,10}cde/ for 1..100;
        pass("abs anchored float string should fail quickly");

d1532 1
a1532 1
                            qr/[[:alpha:]]?c/u
d1548 2
d1551 39
d1597 25
d1637 41
d1684 4
a1687 1
                my $malformed = "a\x80\n";
d1695 65
@


1.7
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d23 1
a23 1
plan tests => 726;  # Update this when adding/deleting tests.
d1611 16
@


1.6
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d512 7
a518 1
    {   # Test that charset modifier work, and are interpolated
@


1.5
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d23 1
a23 1
plan tests => 722;  # Update this when adding/deleting tests.
d512 1
a512 7
    SKIP: {   # Test that charset modifier work, and are interpolated
        if (
            !$Config::Config{d_setlocale}
        || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
        ) {
            skip "no locale support", 13
        }
d1591 14
@


1.4
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d512 7
a518 1
    {   # Test that charset modifier work, and are interpolated
@


1.3
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d23 1
a23 1
plan tests => 672;  # Update this when adding/deleting tests.
d512 1
a512 7
    SKIP: {   # Test that charset modifier work, and are interpolated
        if (
            !$Config::Config{d_setlocale}
        || $Config::Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/
        ) {
            skip "no locale support", 13
        }
d706 8
d737 24
d762 5
a766 2
        local $::TODO = $::running_as_thread;
        ok($str =~ /.\G./ && $& eq 'bc', $message);
d769 1
a837 13
        {
            local $::TODO = $::running_as_thread;
            no warnings 'uninitialized';
            ok($foo =~ /.\G(..)/g, $message);
            is($1, 'ab', $message);

            pos ($foo) += 1;
            ok($foo =~ /.\G(..)/g, $message);
            is($1, 'cc', $message);

            pos ($foo) += 1;
            ok($foo =~ /.\G(..)/g, $message);
            is($1, 'de', $message);
d839 12
a850 2
            ok($foo =~ /\Gef/g, $message);
        }
d865 30
d1222 4
a1225 6
        # No non-unicode code points match any Unicode property, even inverse
        # ones
        unlike($str, qr/\p{ASCII_Hex_Digit=True}/, "Non-Unicode doesn't match \\p{}");
        unlike($str, qr/\p{ASCII_Hex_Digit=False}/, "Non-Unicode doesn't match \\p{}");
        like($str, qr/\P{ASCII_Hex_Digit=True}/, "Non-Unicode matches \\P{}");
        like($str, qr/\P{ASCII_Hex_Digit=False}/, "Non-Unicode matches \\P{}");
d1251 1
a1251 1
            fresh_perl_like($prog, qr!Group name must start with a non-digit word character!, "",
d1428 2
a1429 2
        # if we have 87 capture buffers defined then \87 should refer to the
        # 87th.  test that this is true for 1..100
d1448 14
d1463 2
a1464 7
	# RT #119125
	# the earlier fix for /[#](?{})/x, although correct, as a
	# side-effect fixed another long-standing bug where /[#$x]/x
	# didn't interpolate the var $x. Although fixing that is good,
	# it's too big a change for maint, so keep the old buggy behaviour
	# for now.

d1468 1
a1468 1
	is ($s, 'XbXX$XX&', 'RT #119125 without /x');
d1471 118
a1588 1
	is ($s, 'XXcdXXX&', 'RT #119125 with /x');
@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d19 1
d23 1
a23 1
plan tests => 472;  # Update this when adding/deleting tests.
d156 1
a156 1
        / {([^}]*)}/;
d526 14
a539 4
        use locale;
        my $locale = qr/\b\v$/;
        is($locale,    '(?^l:\b\v$)', 'Verify has l modifier when compiled under use locale');
        no locale;
d545 6
a550 1
        is(qr/abc$locale/,    '(?^u:abc(?^l:\b\v$))', 'Verify retains l when interpolated under unicode_strings');
d553 6
a558 1
        is(qr/abc$locale/,    '(?^:abc(?^l:\b\v$))', 'Verify retains l when interpolated outside locale and unicode strings');
d561 11
a571 3
        use locale;
        is(qr/abc$dual/,    '(?^l:abc(?^:\b\v$))', 'Verify retains d meaning when interpolated under locale');
        is(qr/abc$unicode/,    '(?^l:abc(?^u:\b\v$))', 'Verify retains u when interpolated under locale');
d714 2
a715 1
    foreach ('$+[0] = 13', '$-[0] = 13', '@@+ = (7, 6, 5)', '@@- = qw (foo bar)') {
d718 1
a718 1
	     'Elements of @@- and @@+ are read-only');
d1023 1
a1023 1
        is("@@space0", "cr ff lf spc tab", $message);
a1106 45
        # Test that a regex followed by an operator and/or a statement modifier work
        # These tests use string-eval so that it reports a clean error when it fails
        # (without the string eval the test script might be unparseable)

        # Note: these test check the behaviour that currently is valid syntax
        # If a new regex modifier is added and a test fails then there is a backwards-compatibility issue
        # Note-2: a new deprecate warning was added for this with commit e6897b1a5db0410e387ccbf677e89fc4a1d8c97a
        # which indicate that this syntax will be removed in 5.16.
        # When this happens the tests can be removed

	foreach (['my $r = "a" =~ m/a/lt 2', 'm', 'lt'],
		 ['my $r = "a" =~ m/a/le 1', 'm', 'le'],
		 ['my $r = "a" =~ m/a/eq 1', 'm', 'eq'],
		 ['my $r = "a" =~ m/a/ne 0', 'm', 'ne'],
		 ['my $r = "a" =~ m/a/and 1', 'm', 'and'],
		 ['my $r = "a" =~ m/a/unless 0', 'm', 'unless'],
		 ['my $c = 1; my $r; $r = "a" =~ m/a/while $c--', 'm', 'while'],
		 ['my $c = 0; my $r; $r = "a" =~ m/a/until $c++', 'm', 'until'],
		 ['my $r; $r = "a" =~ m/a/for 1', 'm', 'for'],
		 ['my $r; $r = "a" =~ m/a/foreach 1', 'm', 'foreach'],

		 ['my $t = "a"; my $r = $t =~ s/a//lt 2', 's', 'lt'],
		 ['my $t = "a"; my $r = $t =~ s/a//le 1', 's', 'le'],
		 ['my $t = "a"; my $r = $t =~ s/a//ne 0', 's', 'ne'],
		 ['my $t = "a"; my $r = $t =~ s/a//and 1', 's', 'and'],
		 ['my $t = "a"; my $r = $t =~ s/a//unless 0', 's', 'unless'],

		 ['my $c = 1; my $r; my $t = "a"; $r = $t =~ s/a//while $c--', 's', 'while'],
		 ['my $c = 0; my $r; my $t = "a"; $r = $t =~ s/a//until $c++', 's', 'until'],
		 ['my $r; my $t = "a"; $r = $t =~ s/a//for 1', 's', 'for'],
		 ['my $r; my $t = "a"; $r = $t =~ s/a//for 1', 's', 'foreach'],
		) {
	    my $message = sprintf 'regex (%s) followed by $_->[2]',
		$_->[1] eq 'm' ? 'm//' : 's///';
	    my $code = "$_->[0]; 'eval_ok ' . \$r";
	    my $result = do {
		no warnings 'syntax';
		eval $code;
	    };
	    is($@@, '', $message);
	    is($result, 'eval_ok 1', $message);
	}
    }

    {
d1196 1
a1196 1
            fresh_perl_like($prog, qr!Sequence.* not recognized!, "",
d1254 156
@


1.1
log
@Initial revision
@
text
@d5 1
a5 3
# that does fit that format, add it to re/re_tests, not here.  Tests for \N
# should be added here because they are treated as single quoted strings
# there, which means they avoid the lexer which otherwise would look at them.
a10 1

d19 1
a19 1
    do "re/ReTest.pl" or die $@@;
d22 1
a22 2

plan tests => 309;  # Update this when adding/deleting tests.
a31 1

d33 1
d35 2
a36 2
        ok $x =~ /^abc/,  qq ["$x" =~ /^abc/];
        ok $x !~ /^def/,  qq ["$x" !~ /^def/];
d39 1
a39 1
        ok $x =~ /^def/m, qq ["$x" =~ /^def/m];
d41 2
a42 2
        nok $x =~ /^xxx/, qq ["$x" =~ /^xxx/];
        nok $x !~ /^abc/, qq ["$x" !~ /^abc/];
d44 2
a45 2
         ok $x =~ /def/, qq ["$x" =~ /def/];
        nok $x !~ /def/, qq ["$x" !~ /def/];
d47 2
a48 2
         ok $x !~ /.def/, qq ["$x" !~ /.def/];
        nok $x =~ /.def/, qq ["$x" =~ /.def/];
d50 2
a51 2
         ok $x =~ /\ndef/, qq ["$x" =~ /\ndef/];
        nok $x !~ /\ndef/, qq ["$x" !~ /\ndef/];
d64 1
a64 1
        nok /a+b?c+/,                        qq [\$_ = '$_'; /a+b?c+/];
d72 1
a72 1
        nok /a*b+c*/, qq [\$_ = '$_'; /a*b+c*/];
d83 1
a83 1
        ok "ab\ncd\n" =~ /^cd/m, qq ["ab\ncd\n" =~ /^cd/m];
d91 3
a93 3
            my $f = index ($_, 'not') >= 0 ? \&nok : \&ok;
            my $r = ?(.*)?;
            &$f ($r, "?(.*)?");
d115 1
a115 1
        local $Message = "Test empty pattern";
d121 1
a121 1
        iseq $&, $xyz;
d126 1
a126 1
        iseq $&, $xyz;
d132 1
a132 1
        iseq $&, $xyz;
d136 1
a136 1
        iseq $&, $xyz;
d140 1
a140 1
        local $Message = q !Check $`, $&, $'!;
d143 1
a143 1
        iseq "$`:$&:$'", 'abc:def:ghi';
d147 1
a147 1
        iseq "$`:$&:$'", 'ab:cde:fghi';
d150 1
a150 1
        iseq "$`:$&:$'", 'abc:def:ghi';
d156 1
a156 1
        iseq $1, 'time for all', "Match braces";
d160 1
a160 1
        local $Message = "{N,M} quantifier";
d162 9
a170 9
        ok /( {3,4})/;
        iseq $1, '   ';
        ok !/( {4,})/;
        ok /( {2,3}.)/;
        iseq $1, '  y';
        ok /(y{2,3}.)/;
        iseq $1, 'yyy ';
        ok !/x {3,4}/;
        ok !/^xxx {3,4}/;
d174 1
a174 1
        local $Message = "Test /g";
d180 1
a180 1
        iseq "@@words", $exp;
d186 1
a186 1
        iseq "@@words", $exp;
d193 1
a193 1
        iseq "@@words", "to:to";
d197 1
a197 1
        iseq "@@words", "to:to";
d228 1
a228 1
        iseq $x, '505550555', "Test /o";
d231 1
a231 2

    SKIP: {
d236 1
a236 1
        local $Message = '$ inside ()';
d240 2
a241 2
        iseq $@@, "" or skip "eval failed", 1;
        iseq $result, "abc:bc";
a243 1

d245 1
a245 1
        local $Message = "Scalar /g";
d248 3
a250 3
        ok  /abc/g && $` eq "";
        ok  /abc/g && $` eq "abcfoo";
        ok !/abc/g;
d252 1
a252 1
        local $Message = "Scalar /gi";
d254 3
a256 3
        ok  /ABC/gi && $` eq "";
        ok  /ABC/gi && $` eq "abcfoo";
        ok !/ABC/gi;
d258 1
a258 1
        local $Message = "Scalar /g";
d260 2
a261 2
        ok  /abc/g && $' eq "fooabcbar";
        ok  /abc/g && $' eq "bar";
d265 1
a265 1
        iseq @@x, 2, "/g reset after assignment";
d269 1
a269 1
        local $Message = '/g, \G and pos';
d273 1
a273 1
        iseq pos $_, 2;
d275 1
a275 1
        ok !defined pos $_;
d279 1
a279 1
        local $Message = '(?{ })';
d282 1
a282 1
        iseq $out, 2;
d286 1
a286 1
        iseq $out, 1;
a288 1

d292 1
a292 1
        iseq "@@out", 'bar2 barf', "Negative lookbehind";
d296 1
a296 1
        local $Message = "REG_INFTY tests";
d298 4
a301 1
        $::reg_infty   = $Config {reg_infty} // 32767;
d304 1
a304 1
        $::reg_infty_m = $::reg_infty_m;   # Surpress warning.
d310 7
a316 3
        eval_ok q (('aaa' =~ /(a{1,$::reg_infty_m})/)[0] eq 'aaa');
        eval_ok q (('a' x $::reg_infty_m) =~ /a{$::reg_infty_m}/);
        eval_ok q (('a' x ($::reg_infty_m - 1)) !~ /a{$::reg_infty_m}/);
d318 1
a318 1
        ok $@@ =~ /^\QQuantifier in {,} bigger than/;
d320 1
a320 1
        ok $@@ =~ /^\QQuantifier in {,} bigger than/;
a331 1
        local $Message = "Long monster";
d334 4
a337 4
            local $Error = "length = $l";
             ok "ba$a=" =~ /a$a=/;
            nok "b$a="  =~ /a$a=/;
             ok "b$a="  =~ /ba+=/;
d339 1
a339 1
             ok "ba$a=" =~ /b(?:a|b)+=/;
a342 1

a356 1
        local $Message = "20000 nodes";
d358 2
a359 2
            local $Error = "const-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_constant_len)){2,4}[k-o]).*b./o);
d361 2
a362 2
            local $Error = "var-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_var_len)){2,4}[k-o]).*b./o);
d367 1
a367 1
        local $Message = "Complicated backtracking";
d406 1
a406 1
        iseq "@@ans", "1 1 1";
d409 1
a409 1
        iseq "@@ans", $expect;
d411 1
a411 1
        local $Message = "Recursion with (??{ })";
d418 2
a419 2
        iseq "@@ans", "1 1 1";
        iseq "@@ans1", $expect;
d422 1
a422 1
        iseq "@@ans", $expect;
d432 1
a432 1
        iseq "@@ans", 'a/ b', "Stack may be bad";
d436 1
a436 1
        local $Message = "Eval-group not allowed at runtime";
d440 1
a440 1
        ok $@@ && $@@ =~ /not allowed at runtime/ && $blah == 12;
d442 16
a457 12
        for $code ('{$blah = 45}','=xx') {
            $blah = 12;
            my $res = eval { "xx" =~ /(?$code)/o };
            no warnings 'uninitialized';
            local $Error = "'$@@', '$res', '$blah'";
            if ($code eq '=xx') {
                ok !$@@ && $res;
            }
            else {
                ok $@@ && $@@ =~ /not allowed at runtime/ && $blah == 12;
            }
        }
d462 1
a462 1
        iseq $blah, 45;
d466 1
a466 1
        iseq $blah, 45;
d470 1
a470 1
        local $Message = "Pos checks";
d473 1
a473 1
        iseq pos ($x), 2;
d476 1
a476 1
        iseq pos ($x), 2;
d484 1
a484 1
        iseq f (pos ($x)), 4;
d488 1
a488 1
        local $Message = 'Checking $^R';
d491 1
a491 1
        iseq $^R, 75;
d495 1
a495 1
        ok $^R eq '67' && $x eq '12';
d499 1
a499 1
        ok $^R eq '79' && $x eq '12';
d503 6
a508 6
        iseq qr/\b\v$/i,    '(?i-xsm:\b\v$)', 'qr/\b\v$/i';
        iseq qr/\b\v$/s,    '(?s-xim:\b\v$)', 'qr/\b\v$/s';
        iseq qr/\b\v$/m,    '(?m-xis:\b\v$)', 'qr/\b\v$/m';
        iseq qr/\b\v$/x,    '(?x-ism:\b\v$)', 'qr/\b\v$/x';
        iseq qr/\b\v$/xism, '(?msix:\b\v$)',  'qr/\b\v$/xism';
        iseq qr/\b\v$/,     '(?-xism:\b\v$)', 'qr/\b\v$/';
d511 33
d546 1
a546 1
        local $Message = "Look around";
a547 1
      SKIP:
d549 2
a550 2
            ok /(?<=(?=a)..)((?=c)|.)/g or skip "Match failed", 1;
            iseq $1, $ans;
d555 1
a555 1
        local $Message = "Empty clause";
d558 2
a559 2
            ok /^|a|$/g or skip "Match failed", 1;
            iseq $&, $ans;
a563 1
        local $Message = "Prefixify";
d565 2
a566 1
            SKIP: {
d568 2
a569 2
                ok $v =~ s/\Q$a\E/$b/ or skip "Match failed", 1;
                iseq $v, $res;
d585 1
a585 1
        local $Message = '(?{ $var } refers to package vars';
d590 2
a591 2
        main::iseq $c, 4;
        main::iseq $::c, 3;
d595 3
a597 3
        must_die 'q(a:[b]:) =~ /[x[:foo:]]/',
                 'POSIX class \[:[^:]+:\] unknown in regex',
                 'POSIX class [: :] must have valid name';
d600 3
a602 3
            must_die "/[[${d}foo${d}]]/",
                     "\QPOSIX syntax [$d $d] is reserved for future extensions",
                     "POSIX syntax [[$d $d]] is an error";
a605 1

d608 1
a608 1
        local $Message = "Failed pattern returns empty list";
d611 1
a611 1
        iseq "@@_", "";
d614 1
a614 1
        iseq "@@_", "";
d617 1
a617 1
        iseq "@@_", "";
d620 1
a620 1
        iseq "@@_", "";
a622 1

d624 1
a624 1
        local $Message = '@@- and @@+ tests';
d627 6
a632 6
        iseq $#+, 0;
        iseq $#-, 0;
        iseq $+ [0], 2;
        iseq $- [0], 1;
        ok !defined $+ [1] && !defined $- [1] &&
           !defined $+ [2] && !defined $- [2];
d635 24
a658 11
        iseq $#+, 2;
        iseq $#-, 2;
        iseq $+ [0], 3;
        iseq $- [0], 0;
        iseq $+ [1], 2;
        iseq $- [1], 1;
        iseq $+ [2], 3;
        iseq $- [2], 2;
        ok !defined $+ [3] && !defined $- [3] &&
           !defined $+ [4] && !defined $- [4];

d661 8
a668 9
        iseq $#+, 3;
        iseq $#-, 3;
        iseq $+ [1], 2;
        iseq $- [1], 1;
        iseq $+ [3], 3;
        iseq $- [3], 2;
        ok !defined $+ [2] && !defined $- [2] &&
           !defined $+ [4] && !defined $- [4];

d671 8
a678 8
        iseq $#+, 1;
        iseq $#-, 1;
        iseq $+ [0], 2;
        iseq $- [0], 0;
        iseq $+ [1], 2;
        iseq $- [1], 1;
        ok !defined $+ [2] && !defined $- [2] &&
           !defined $+ [3] && !defined $- [3];
d681 2
a682 2
        iseq $#+, 2;
        iseq $#-, 1;
d685 4
a688 8

    {
        local $DiePattern = '^Modification of a read-only value attempted';
        local $Message    = 'Elements of @@- and @@+ are read-only';
        must_die '$+[0] = 13';
        must_die '$-[0] = 13';
        must_die '@@+ = (7, 6, 5)';
        must_die '@@- = qw (foo bar)';
a690 1

d692 1
a692 1
        local $Message = '\G testing';
d696 1
a696 1
        iseq "@@a", "a a";
d700 5
a704 5
        ok $str !~ /^\G/;
        ok $str !~ /^.\G/;
        ok $str =~ /^..\G/;
        ok $str !~ /^...\G/;
        ok $str =~ /\G../ && $& eq 'cd';
d706 2
a707 2
        local $TODO = $running_as_thread;
        ok $str =~ /.\G./ && $& eq 'bc';
a709 1

d711 1
a711 1
        local $Message = 'pos inside (?{ })';
d714 4
a717 4
        ok $str =~ /b(?{$foo = $_; $bar = pos})c/;
        iseq $foo, $str;
        iseq $bar, 2;
        ok !defined pos ($str);
d722 4
a725 4
        ok $str =~ /b(?{$foo = $_; $bar = pos})c/g;
        iseq $foo, $str;
        iseq $bar, 2;
        iseq pos ($str), 3;
d730 3
a732 3
        ok /b(?{$foo = $_; $bar = pos})c/;
        iseq $foo, $str;
        iseq $bar, 2;
d736 4
a739 4
        ok /b(?{$foo = $_; $bar = pos})c/g;
        iseq $foo, $str;
        iseq $bar, 2;
        iseq pos, 3;
d745 3
a747 3
        iseq $foo, $str;
        iseq $bar, 2;
        ok !defined pos;
d752 4
a755 4
        ok s/b(?{$foo = $_; $bar = pos})c/x/g;
        iseq $foo, 'abcde|abcde';
        iseq $bar, 8;
        iseq $_, 'axde|axde';
d762 1
a762 1
        iseq "@@res", "'a' undef 'a' 'c' 'e' undef 'a' undef 'a' 'c'";
d767 1
a767 1
        iseq "@@res", "'' 'ab' 'cde|abcde' " .
d771 1
a771 1
                     "'abcde|' 'abc' 'de'" ;
a773 1

d775 1
a775 1
        local $Message = '\G anchor checks';
d779 1
a779 1
            local $TODO = $running_as_thread;
d781 2
a782 2
            ok $foo =~ /.\G(..)/g;
            iseq $1, 'ab';
d785 2
a786 2
            ok $foo =~ /.\G(..)/g;
            iseq $1, 'cc';
d789 2
a790 2
            ok $foo =~ /.\G(..)/g;
            iseq $1, 'de';
d792 1
a792 1
            ok $foo =~ /\Gef/g;
d796 2
a797 2
        ok $foo =~ /\G(..)/g;
        iseq $1, 'aa';
d799 2
a800 2
        ok $foo =~ /\G(..)/g;
        iseq $1, 'bb';
d803 2
a804 2
        ok $foo =~ /\G(..)/g;
        iseq $1, 'cd';
a806 1

d811 1
a811 1
        iseq "@@res", "123||x|123|", "0 match in alternation";
a813 1

d815 1
a815 1
        local $Message = "Match against temporaries (created via pp_helem())" .
d817 2
a818 2
        ok {foo => "bar\n" . $^X} -> {foo} =~ /^(.*)\n/g;
        iseq $1, "bar";
a820 1

d822 1
a822 1
        local $Message = 'package $i inside (?{ }), ' .
d827 2
a828 2
        iseq "@@b", "f o o b a r";
        iseq "@@a", ",f,,o,,o, ,b,,a,,r,";
d830 1
a830 1
        local $Message = 'lexical $i inside (?{ }), ' .
d836 2
a837 2
        iseq "@@d", "f o o b a r";
        iseq "@@c", ",f,,o,,o, ,b,,a,,r,";
a839 1

d841 1
a841 1
        local $Message = 'Brackets';
d847 6
a852 6
        ok "{{}" =~ $brackets;
        iseq $&, "{}";
        ok "something { long { and } hairy" =~ $brackets;
        iseq $&, "{ and }";
        ok "something { long { and } hairy" =~ m/((??{ $brackets }))/;
        iseq $&, "{ and }";
a854 1

d858 1
a858 1
        nok m/^-.*bb/mg, '$_ = "a-a\nxbb"; m/^-.*bb/mg';
a860 1

d862 1
a862 1
        local $Message = '\G anchor checks';
d865 1
a865 1
        ok $text !~ /\GXb*X/g;
a867 1

d870 1
a870 1
        nok /^\s*A/m, '$_ = "xA\n" x 500; /^\s*A/m"';
d874 1
a874 1
        iseq "@@res", "b b", '\b is not special';
a876 1

d878 1
a878 1
        local $Message = '\S, [\S], \s, [\s]';
d882 1
a882 1
        iseq "@@b", "@@c";
d886 1
a886 1
        iseq "@@b", "@@c";
d890 1
a890 1
        iseq "@@b", "@@c";
d894 1
a894 1
        iseq "@@b", "@@c";
d897 1
a897 1
        local $Message = '\D, [\D], \d, [\d]';
d901 1
a901 1
        iseq "@@b", "@@c";
d905 1
a905 1
        iseq "@@b", "@@c";
d909 1
a909 1
        iseq "@@b", "@@c";
d913 1
a913 1
        iseq "@@b", "@@c";
d916 1
a916 1
        local $Message = '\W, [\W], \w, [\w]';
d920 1
a920 1
        iseq "@@b", "@@c";
d924 1
a924 1
        iseq "@@b", "@@c";
d928 1
a928 1
        iseq "@@b", "@@c";
d932 1
a932 1
        iseq "@@b", "@@c";
a934 1

d937 11
a947 11
        local $Message = 'Backtrack optimization';
        ok "\n\n" =~ /\n   $ \n/x;
        ok "\n\n" =~ /\n*  $ \n/x;
        ok "\n\n" =~ /\n+  $ \n/x;
        ok "\n\n" =~ /\n?  $ \n/x;
        ok "\n\n" =~ /\n*? $ \n/x;
        ok "\n\n" =~ /\n+? $ \n/x;
        ok "\n\n" =~ /\n?? $ \n/x;
        ok "\n\n" !~ /\n*+ $ \n/x;
        ok "\n\n" !~ /\n++ $ \n/x;
        ok "\n\n" =~ /\n?+ $ \n/x;
a949 1

d955 6
a960 6
        local $::Message  = "Ref stringification";
      ::ok do { \my $v} =~ /^SCALAR/,   "Scalar ref stringification";
      ::ok do {\\my $v} =~ /^REF/,      "Ref ref stringification";
      ::ok []           =~ /^ARRAY/,    "Array ref stringification";
      ::ok {}           =~ /^HASH/,     "Hash ref stringification";
      ::ok 'S' -> new   =~ /^Object S/, "Object stringification";
a962 1

d964 5
a968 5
        local $Message = "Test result of match used as match";
        ok 'a1b' =~ ('xyz' =~ /y/);
        iseq $`, 'a';
        ok 'a1b' =~ ('xyz' =~ /t/);
        iseq $`, 'a';
a970 1

d972 3
a974 2
        local $Message = '"1" is not \s';
        may_not_warn sub {ok ("1\n" x 102) !~ /^\s*\n/m};
a976 1

d978 1
a978 1
        local $Message = '\s, [[:space:]] and [[:blank:]]';
d993 3
a995 3
        iseq "@@space0", "cr ff lf spc tab";
        iseq "@@space1", "cr ff lf spc tab vt";
        iseq "@@space2", "spc tab";
d999 8
a1006 20
        use charnames ":full";
        local $Message = 'Delayed interpolation of \N';
        my $r1 = qr/\N{THAI CHARACTER SARA I}/;
        my $s1 = "\x{E34}\x{E34}\x{E34}\x{E34}";

        # Bug #56444
        ok $s1 =~ /$r1+/, 'my $r1 = qr/\N{THAI CHARACTER SARA I}/; my $s1 = "\x{E34}\x{E34}\x{E34}\x{E34}; $s1 =~ /$r1+/';

        # Bug #62056
        ok "${s1}A" =~ m/$s1\N{LATIN CAPITAL LETTER A}/, '"${s1}A" =~ m/$s1\N{LATIN CAPITAL LETTER A}/';

        ok "abbbbc" =~ m/\N{1}/ && $& eq "a", '"abbbbc" =~ m/\N{1}/ && $& eq "a"';
        ok "abbbbc" =~ m/\N{3,4}/ && $& eq "abbb", '"abbbbc" =~ m/\N{3,4}/ && $& eq "abbb"';
    }

    {
        use charnames ":full";
        local $Message = '[perl #74982] Period coming after \N{}';
        ok "\x{ff08}." =~ m/\N{FULLWIDTH LEFT PARENTHESIS}./ && $& eq "\x{ff08}.";
        ok "\x{ff08}." =~ m/[\N{FULLWIDTH LEFT PARENTHESIS}]./ && $& eq "\x{ff08}.";
d1028 240
@


1.1.1.1
log
@Perl 5.12.2 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d5 3
a7 1
# that does fit that format, add it to re/re_tests, not here.
d13 1
d22 1
a22 1
    require './test.pl';
d25 2
a26 1
plan tests => 472;  # Update this when adding/deleting tests.
d36 1
a37 1
	(my $x_pretty = $x) =~ s/\n/\\n/g;
d39 2
a40 2
        ok $x =~ /^abc/,  qq ["$x_pretty" =~ /^abc/];
        ok $x !~ /^def/,  qq ["$x_pretty" !~ /^def/];
d43 1
a43 1
        ok $x =~ /^def/m, qq ["$x_pretty" =~ /^def/m];
d45 2
a46 2
        ok(!($x =~ /^xxx/), qq ["$x_pretty" =~ /^xxx/]);
        ok(!($x !~ /^abc/), qq ["$x_pretty" !~ /^abc/]);
d48 2
a49 2
         ok $x =~ /def/, qq ["$x_pretty" =~ /def/];
        ok(!($x !~ /def/), qq ["$x_pretty" !~ /def/]);
d51 2
a52 2
         ok $x !~ /.def/, qq ["$x_pretty" !~ /.def/];
        ok(!($x =~ /.def/), qq ["$x_pretty" =~ /.def/]);
d54 2
a55 2
         ok $x =~ /\ndef/, qq ["$x_pretty" =~ /\\ndef/];
        ok(!($x !~ /\ndef/), qq ["$x_pretty" !~ /\\ndef/]);
d68 1
a68 1
        unlike($_, qr/a+b?c+/, qq [\$_ = '$_'; /a+b?c+/]);
d76 1
a76 1
        unlike($_, qr/a*b+c*/, qq [\$_ = '$_'; /a*b+c*/]);
d87 1
a87 1
        ok "ab\ncd\n" =~ /^cd/m, q ["ab\ncd\n" =~ /^cd/m];
d95 3
a97 3
            my $e = index ($_, 'not') >= 0 ? '' : 1;
            my $r = m?(.*)?;
            is($r, $e, "?(.*)?");
d119 1
a119 1
        my $message = "Test empty pattern";
d125 1
a125 1
        is($&, $xyz, $message);
d130 1
a130 1
        is($&, $xyz, $message);
d136 1
a136 1
        is($&, $xyz, $message);
d140 1
a140 1
        is($&, $xyz, $message);
d144 1
a144 1
        my $message = q !Check $`, $&, $'!;
d147 1
a147 1
        is("$`:$&:$'", 'abc:def:ghi', $message);
d151 1
a151 1
        is("$`:$&:$'", 'ab:cde:fghi', $message);
d154 1
a154 1
        is("$`:$&:$'", 'abc:def:ghi', $message);
d160 1
a160 1
        is($1, 'time for all', "Match braces");
d164 1
a164 1
        my $message = "{N,M} quantifier";
d166 9
a174 9
        ok(/( {3,4})/, $message);
        is($1, '   ', $message);
        unlike($_, qr/( {4,})/, $message);
        ok(/( {2,3}.)/, $message);
        is($1, '  y', $message);
        ok(/(y{2,3}.)/, $message);
        is($1, 'yyy ', $message);
        unlike($_, qr/x {3,4}/, $message);
        unlike($_, qr/^xxx {3,4}/, $message);
d178 1
a178 1
        my $message = "Test /g";
d184 1
a184 1
        is("@@words", $exp, $message);
d190 1
a190 1
        is("@@words", $exp, $message);
d197 1
a197 1
        is("@@words", "to:to", $message);
d201 1
a201 1
        is("@@words", "to:to", $message);
d232 1
a232 1
        is($x, '505550555', "Test /o");
d235 2
a236 1
    {
d241 1
a241 1
        my $message = '$ inside ()';
d245 2
a246 2
        is($@@, "", $message);
        is($result, "abc:bc", $message);
d249 1
d251 1
a251 1
        my $message = "Scalar /g";
d254 3
a256 3
        ok( /abc/g && $` eq "", $message);
        ok( /abc/g && $` eq "abcfoo", $message);
        ok(!/abc/g, $message);
d258 1
a258 1
        $message = "Scalar /gi";
d260 3
a262 3
        ok( /ABC/gi && $` eq "", $message);
        ok( /ABC/gi && $` eq "abcfoo", $message);
        ok(!/ABC/gi, $message);
d264 1
a264 1
        $message = "Scalar /g";
d266 2
a267 2
        ok( /abc/g && $' eq "fooabcbar", $message);
        ok( /abc/g && $' eq "bar", $message);
d271 1
a271 1
        is(@@x, 2, "/g reset after assignment");
d275 1
a275 1
        my $message = '/g, \G and pos';
d279 1
a279 1
        is(pos $_, 2, $message);
d281 1
a281 1
        is(pos $_, undef, $message);
d285 1
a285 1
        my $message = '(?{ })';
d288 1
a288 1
        is($out, 2, $message);
d292 1
a292 1
        is($out, 1, $message);
d295 1
d299 1
a299 1
        is("@@out", 'bar2 barf', "Negative lookbehind");
d303 1
a303 1
        my $message = "REG_INFTY tests";
d305 1
a305 4

	#  Defaults assumed if this fails
	eval { require Config; };
        $::reg_infty   = $Config::Config{reg_infty} // 32767;
d308 1
a308 1
        $::reg_infty_m = $::reg_infty_m;   # Suppress warning.
d314 3
a316 7
        is(eval q{('aaa' =~ /(a{1,$::reg_infty_m})/)[0]}, 'aaa', $message);
        is($@@, '', $message);
        is(eval q{('a' x $::reg_infty_m) =~ /a{$::reg_infty_m}/}, 1, $message);
        is($@@, '', $message);
        isnt(q{('a' x ($::reg_infty_m - 1)) !~ /a{$::reg_infty_m}/}, 1, $message);
        is($@@, '', $message);

d318 1
a318 1
        like($@@, qr/^\QQuantifier in {,} bigger than/, $message);
d320 1
a320 1
        like($@@, qr/^\QQuantifier in {,} bigger than/, $message);
d332 1
d335 4
a338 4
	    my $message = "Long monster, length = $l";
	    like("ba$a=", qr/a$a=/, $message);
            unlike("b$a=", qr/a$a=/, $message);
            like("b$a=", qr/ba+=/, $message);
d340 1
a340 1
	    like("ba$a=", qr/b(?:a|b)+=/, $message);
d344 1
d359 1
d361 2
a362 2
	    my $message = "20000 nodes, const-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_constant_len)){2,4}[k-o]).*b./o), $message;
d364 2
a365 2
	    $message = "20000 nodes, var-len '$_'";
            ok !($ans{$_} xor /a(?=([yx]($long_var_len)){2,4}[k-o]).*b./o,), $message;
d370 1
a370 1
        my $message = "Complicated backtracking";
d409 1
a409 1
        is("@@ans", "1 1 1", $message);
d412 1
a412 1
        is("@@ans", $expect, $message);
d414 1
a414 1
        $message = "Recursion with (??{ })";
d421 2
a422 2
        is("@@ans", "1 1 1", $message);
        is("@@ans1", $expect, $message);
d425 1
a425 1
        is("@@ans", $expect, $message);
d435 1
a435 1
        is("@@ans", 'a/ b', "Stack may be bad");
d439 1
a439 1
        my $message = "Eval-group not allowed at runtime";
d443 1
a443 1
        ok($@@ && $@@ =~ /not allowed at runtime/ && $blah == 12, $message);
d445 12
a456 16
	$blah = 12;
	my $res = eval { "xx" =~ /(?$code)/o };
	{
	    no warnings 'uninitialized';
	    chomp $@@; my $message = "$message '$@@', '$res', '$blah'";
	    ok($@@ && $@@ =~ /not allowed at runtime/ && $blah == 12, $message);
	}

        $code = '=xx';
	$blah = 12;
	$res = eval { "xx" =~ /(?$code)/o };
	{
	    no warnings 'uninitialized';
	    my $message = "$message '$@@', '$res', '$blah'";
	    ok(!$@@ && $res, $message);
	}
d461 1
a461 1
        is($blah, 45, $message);
d465 1
a465 1
        is($blah, 45, $message);
d469 1
a469 1
        my $message = "Pos checks";
d472 1
a472 1
        is(pos $x, 2, $message);
d475 1
a475 1
        is(pos $x, 2, $message);
d483 1
a483 1
        is(f (pos $x), 4, $message);
d487 1
a487 1
        my $message = 'Checking $^R';
d490 1
a490 1
        is($^R, 75, $message);
d494 1
a494 1
        ok($^R eq '67' && $x eq '12', $message);
d498 1
a498 1
        ok($^R eq '79' && $x eq '12', $message);
d502 6
a507 6
        is(qr/\b\v$/i,    '(?^i:\b\v$)', 'qr/\b\v$/i');
        is(qr/\b\v$/s,    '(?^s:\b\v$)', 'qr/\b\v$/s');
        is(qr/\b\v$/m,    '(?^m:\b\v$)', 'qr/\b\v$/m');
        is(qr/\b\v$/x,    '(?^x:\b\v$)', 'qr/\b\v$/x');
        is(qr/\b\v$/xism, '(?^msix:\b\v$)',  'qr/\b\v$/xism');
        is(qr/\b\v$/,     '(?^:\b\v$)', 'qr/\b\v$/');
a509 27
    {   # Test that charset modifier work, and are interpolated
        is(qr/\b\v$/, '(?^:\b\v$)', 'Verify no locale, no unicode_strings gives default modifier');
        is(qr/(?l:\b\v$)/, '(?^:(?l:\b\v$))', 'Verify infix l modifier compiles');
        is(qr/(?u:\b\v$)/, '(?^:(?u:\b\v$))', 'Verify infix u modifier compiles');
        is(qr/(?l)\b\v$/, '(?^:(?l)\b\v$)', 'Verify (?l) compiles');
        is(qr/(?u)\b\v$/, '(?^:(?u)\b\v$)', 'Verify (?u) compiles');

        my $dual = qr/\b\v$/;
        use locale;
        my $locale = qr/\b\v$/;
        is($locale,    '(?^l:\b\v$)', 'Verify has l modifier when compiled under use locale');
        no locale;

        use feature 'unicode_strings';
        my $unicode = qr/\b\v$/;
        is($unicode,    '(?^u:\b\v$)', 'Verify has u modifier when compiled under unicode_strings');
        is(qr/abc$dual/,    '(?^u:abc(?^:\b\v$))', 'Verify retains d meaning when interpolated under locale');
        is(qr/abc$locale/,    '(?^u:abc(?^l:\b\v$))', 'Verify retains l when interpolated under unicode_strings');

        no feature 'unicode_strings';
        is(qr/abc$locale/,    '(?^:abc(?^l:\b\v$))', 'Verify retains l when interpolated outside locale and unicode strings');
        is(qr/def$unicode/,    '(?^:def(?^u:\b\v$))', 'Verify retains u when interpolated outside locale and unicode strings');

        use locale;
        is(qr/abc$dual/,    '(?^l:abc(?^:\b\v$))', 'Verify retains d meaning when interpolated under locale');
        is(qr/abc$unicode/,    '(?^l:abc(?^u:\b\v$))', 'Verify retains u when interpolated under locale');
    }
d512 1
a512 1
        my $message = "Look around";
d514 1
d516 2
a517 2
            ok(/(?<=(?=a)..)((?=c)|.)/g, $message);
            is($1, $ans, $message);
d522 1
a522 1
        my $message = "Empty clause";
d525 2
a526 2
            ok(/^|a|$/g, $message);
            is($&, $ans, $message);
d531 1
d533 1
a533 2
        my $message = "Prefixify";
            {
d535 2
a536 2
                ok($v =~ s/\Q$a\E/$b/, $message);
                is($v, $res, $message);
d552 1
a552 1
        my $message = '(?{ $var } refers to package vars';
d557 2
a558 2
        main::is($c, 4, $message);
        main::is($::c, 3, $message);
d562 3
a564 3
        is(eval 'q(a:[b]:) =~ /[x[:foo:]]/', undef);
	like ($@@, qr/POSIX class \[:[^:]+:\] unknown in regex/,
	      'POSIX class [: :] must have valid name');
d567 3
a569 3
            is(eval "/[[${d}foo${d}]]/", undef);
	    like ($@@, qr/\QPOSIX syntax [$d $d] is reserved for future extensions/,
		  "POSIX syntax [[$d $d]] is an error");
d573 1
d576 1
a576 1
        my $message = "Failed pattern returns empty list";
d579 1
a579 1
        is("@@_", "", $message);
d582 1
a582 1
        is("@@_", "", $message);
d585 1
a585 1
        is("@@_", "", $message);
d588 1
a588 1
        is("@@_", "", $message);
d591 1
d593 1
a593 1
        my $message = '@@- and @@+ tests';
d596 6
a601 6
        is($#+, 0, $message);
        is($#-, 0, $message);
        is($+ [0], 2, $message);
        is($- [0], 1, $message);
        ok(!defined $+ [1] && !defined $- [1] &&
           !defined $+ [2] && !defined $- [2], $message);
d604 11
a614 24
        is($#+, 2, $message);
        is($#-, 2, $message);
        is($+ [0], 3, $message);
        is($- [0], 0, $message);
        is($+ [1], 2, $message);
        is($- [1], 1, $message);
        is($+ [2], 3, $message);
        is($- [2], 2, $message);
        ok(!defined $+ [3] && !defined $- [3] &&
           !defined $+ [4] && !defined $- [4], $message);

        # Exists has a special check for @@-/@@+ - bug 45147
        ok(exists $-[0], $message);
        ok(exists $+[0], $message);
        ok(exists $-[2], $message);
        ok(exists $+[2], $message);
        ok(!exists $-[3], $message);
        ok(!exists $+[3], $message);
        ok(exists $-[-1], $message);
        ok(exists $+[-1], $message);
        ok(exists $-[-3], $message);
        ok(exists $+[-3], $message);
        ok(!exists $-[-4], $message);
        ok(!exists $+[-4], $message);
d617 9
a625 8
        is($#+, 3, $message);
        is($#-, 3, $message);
        is($+ [1], 2, $message);
        is($- [1], 1, $message);
        is($+ [3], 3, $message);
        is($- [3], 2, $message);
        ok(!defined $+ [2] && !defined $- [2] &&
           !defined $+ [4] && !defined $- [4], $message);
d628 8
a635 8
        is($#+, 1, $message);
        is($#-, 1, $message);
        is($+ [0], 2, $message);
        is($- [0], 0, $message);
        is($+ [1], 2, $message);
        is($- [1], 1, $message);
        ok(!defined $+ [2] && !defined $- [2] &&
           !defined $+ [3] && !defined $- [3], $message);
d638 2
a639 2
        is($#+, 2, $message);
        is($#-, 1, $message);
d642 8
a649 4
    foreach ('$+[0] = 13', '$-[0] = 13', '@@+ = (7, 6, 5)', '@@- = qw (foo bar)') {
	is(eval $_, undef);
        like($@@, qr/^Modification of a read-only value attempted/,
	     'Elements of @@- and @@+ are read-only');
d652 1
d654 1
a654 1
        my $message = '\G testing';
d658 1
a658 1
        is("@@a", "a a", $message);
d662 5
a666 5
        unlike($str, qr/^\G/, $message);
        unlike($str, qr/^.\G/, $message);
        like($str, qr/^..\G/, $message);
        unlike($str, qr/^...\G/, $message);
        ok($str =~ /\G../ && $& eq 'cd', $message);
d668 2
a669 2
        local $::TODO = $::running_as_thread;
        ok($str =~ /.\G./ && $& eq 'bc', $message);
d672 1
d674 1
a674 1
        my $message = 'pos inside (?{ })';
d677 4
a680 4
        like($str, qr/b(?{$foo = $_; $bar = pos})c/, $message);
        is($foo, $str, $message);
        is($bar, 2, $message);
        is(pos $str, undef, $message);
d685 4
a688 4
        ok($str =~ /b(?{$foo = $_; $bar = pos})c/g, $message);
        is($foo, $str, $message);
        is($bar, 2, $message);
        is(pos $str, 3, $message);
d693 3
a695 3
        like($_, qr/b(?{$foo = $_; $bar = pos})c/, $message);
        is($foo, $str, $message);
        is($bar, 2, $message);
d699 4
a702 4
        ok(/b(?{$foo = $_; $bar = pos})c/g, $message);
        is($foo, $str, $message);
        is($bar, 2, $message);
        is(pos, 3, $message);
d708 3
a710 3
        is($foo, $str, $message);
        is($bar, 2, $message);
        is(pos, undef, $message);
d715 4
a718 4
        ok(s/b(?{$foo = $_; $bar = pos})c/x/g, $message);
        is($foo, 'abcde|abcde', $message);
        is($bar, 8, $message);
        is($_, 'axde|axde', $message);
d725 1
a725 1
        is("@@res", "'a' undef 'a' 'c' 'e' undef 'a' undef 'a' 'c'", $message);
d730 1
a730 1
        is("@@res", "'' 'ab' 'cde|abcde' " .
d734 1
a734 1
                     "'abcde|' 'abc' 'de'", $message);
d737 1
d739 1
a739 1
        my $message = '\G anchor checks';
d743 1
a743 1
            local $::TODO = $::running_as_thread;
d745 2
a746 2
            ok($foo =~ /.\G(..)/g, $message);
            is($1, 'ab', $message);
d749 2
a750 2
            ok($foo =~ /.\G(..)/g, $message);
            is($1, 'cc', $message);
d753 2
a754 2
            ok($foo =~ /.\G(..)/g, $message);
            is($1, 'de', $message);
d756 1
a756 1
            ok($foo =~ /\Gef/g, $message);
d760 2
a761 2
        ok($foo =~ /\G(..)/g, $message);
        is($1, 'aa', $message);
d763 2
a764 2
        ok($foo =~ /\G(..)/g, $message);
        is($1, 'bb', $message);
d767 2
a768 2
        ok($foo =~ /\G(..)/g, $message);
        is($1, 'cd', $message);
d771 1
d776 1
a776 1
        is("@@res", "123||x|123|", "0 match in alternation");
d779 1
d781 1
a781 1
        my $message = "Match against temporaries (created via pp_helem())" .
d783 2
a784 2
        ok({foo => "bar\n" . $^X} -> {foo} =~ /^(.*)\n/g, $message);
        is($1, "bar", $message);
d787 1
d789 1
a789 1
        my $message = 'package $i inside (?{ }), ' .
d794 2
a795 2
        is("@@b", "f o o b a r", $message);
        is("@@a", ",f,,o,,o, ,b,,a,,r,", $message);
d797 1
a797 1
        $message = 'lexical $i inside (?{ }), ' .
d803 2
a804 2
        is("@@d", "f o o b a r", $message);
        is("@@c", ",f,,o,,o, ,b,,a,,r,", $message);
d807 1
d809 1
a809 1
        my $message = 'Brackets';
d815 6
a820 6
        ok("{{}" =~ $brackets, $message);
        is($&, "{}", $message);
        ok("something { long { and } hairy" =~ $brackets, $message);
        is($&, "{ and }", $message);
        ok("something { long { and } hairy" =~ m/((??{ $brackets }))/, $message);
        is($&, "{ and }", $message);
d823 1
d827 1
a827 1
        ok(!m/^-.*bb/mg, '$_ = "a-a\nxbb"; m/^-.*bb/mg');
d830 1
d832 1
a832 1
        my $message = '\G anchor checks';
d835 1
a835 1
        ok($text !~ /\GXb*X/g, $message);
d838 1
d841 1
a841 1
        unlike($_, qr/^\s*A/m, '$_ = "xA\n" x 500; /^\s*A/m"');
d845 1
a845 1
        is("@@res", "b b", '\b is not special');
d848 1
d850 1
a850 1
        my $message = '\S, [\S], \s, [\s]';
d854 1
a854 1
        is("@@b", "@@c", $message);
d858 1
a858 1
        is("@@b", "@@c", $message);
d862 1
a862 1
        is("@@b", "@@c", $message);
d866 1
a866 1
        is("@@b", "@@c", $message);
d869 1
a869 1
        my $message = '\D, [\D], \d, [\d]';
d873 1
a873 1
        is("@@b", "@@c", $message);
d877 1
a877 1
        is("@@b", "@@c", $message);
d881 1
a881 1
        is("@@b", "@@c", $message);
d885 1
a885 1
        is("@@b", "@@c", $message);
d888 1
a888 1
        my $message = '\W, [\W], \w, [\w]';
d892 1
a892 1
        is("@@b", "@@c", $message);
d896 1
a896 1
        is("@@b", "@@c", $message);
d900 1
a900 1
        is("@@b", "@@c", $message);
d904 1
a904 1
        is("@@b", "@@c", $message);
d907 1
d910 11
a920 11
        my $message = 'Backtrack optimization';
        like("\n\n", qr/\n   $ \n/x, $message);
        like("\n\n", qr/\n*  $ \n/x, $message);
        like("\n\n", qr/\n+  $ \n/x, $message);
        like("\n\n", qr/\n?  $ \n/x, $message);
        like("\n\n", qr/\n*? $ \n/x, $message);
        like("\n\n", qr/\n+? $ \n/x, $message);
        like("\n\n", qr/\n?? $ \n/x, $message);
        unlike("\n\n", qr/\n*+ $ \n/x, $message);
        unlike("\n\n", qr/\n++ $ \n/x, $message);
        like("\n\n", qr/\n?+ $ \n/x, $message);
d923 1
d929 6
a934 6
        my $message  = "Ref stringification";
      ::ok(do { \my $v} =~ /^SCALAR/,   "Scalar ref stringification") or diag($message);
      ::ok(do {\\my $v} =~ /^REF/,      "Ref ref stringification") or diag($message);
      ::ok([]           =~ /^ARRAY/,    "Array ref stringification") or diag($message);
      ::ok({}           =~ /^HASH/,     "Hash ref stringification") or diag($message);
      ::ok('S' -> new   =~ /^Object S/, "Object stringification") or diag($message);
d937 1
d939 5
a943 5
        my $message = "Test result of match used as match";
        ok('a1b' =~ ('xyz' =~ /y/), $message);
        is($`, 'a', $message);
        ok('a1b' =~ ('xyz' =~ /t/), $message);
        is($`, 'a', $message);
d946 1
d948 2
a949 3
        my $message = '"1" is not \s';
        warning_is(sub {unlike("1\n" x 102, qr/^\s*\n/m, $message)},
		   undef, "$message (did not warn)");
d952 1
d954 1
a954 1
        my $message = '\s, [[:space:]] and [[:blank:]]';
d969 19
a987 3
        is("@@space0", "cr ff lf spc tab", $message);
        is("@@space1", "cr ff lf spc tab vt", $message);
        is("@@space2", "spc tab", $message);
d991 4
a994 8
        my $n= 50;
        # this must be a high number and go from 0 to N, as the bug we are looking for doesn't
        # seem to be predictable. Slight changes to the test make it fail earlier or later.
        foreach my $i (0 .. $n)
        {
            my $str= "\n" x $i;
            ok $str=~/.*\z/, "implicit MBOL check string disable does not break things length=$i";
        }
a1015 240
    }

    {
        #
        # Tests for bug 77414.
        #

        my $message = '\p property after empty * match';
        {
            like("1", qr/\s*\pN/, $message);
            like("-", qr/\s*\p{Dash}/, $message);
            like(" ", qr/\w*\p{Blank}/, $message);
        }

        like("1", qr/\s*\pN+/, $message);
        like("-", qr/\s*\p{Dash}{1}/, $message);
        like(" ", qr/\w*\p{Blank}{1,4}/, $message);

    }

    SKIP: {   # Some constructs with Latin1 characters cause a utf8 string not
              # to match itself in non-utf8
        if ($::IS_EBCDIC) {
            skip "Needs to be customized to run on EBCDIC", 6;
        }
        my $c = "\xc0";
        my $pattern = my $utf8_pattern = qr/((\xc0)+,?)/;
        utf8::upgrade($utf8_pattern);
        ok $c =~ $pattern, "\\xc0 =~ $pattern; Neither pattern nor target utf8";
        ok $c =~ /$pattern/i, "\\xc0 =~ /$pattern/i; Neither pattern nor target utf8";
        ok $c =~ $utf8_pattern, "\\xc0 =~ $pattern; pattern utf8, target not";
        ok $c =~ /$utf8_pattern/i, "\\xc0 =~ /$pattern/i; pattern utf8, target not";
        utf8::upgrade($c);
        ok $c =~ $pattern, "\\xc0 =~ $pattern; target utf8, pattern not";
        ok $c =~ /$pattern/i, "\\xc0 =~ /$pattern/i; target utf8, pattern not";
        ok $c =~ $utf8_pattern, "\\xc0 =~ $pattern; Both target and pattern utf8";
        ok $c =~ /$utf8_pattern/i, "\\xc0 =~ /$pattern/i; Both target and pattern utf8";
    }

    SKIP: {   # Make sure can override the formatting
        if ($::IS_EBCDIC) {
            skip "Needs to be customized to run on EBCDIC", 2;
        }
        use feature 'unicode_strings';
        ok "\xc0" =~ /\w/, 'Under unicode_strings: "\xc0" =~ /\w/';
        ok "\xc0" !~ /(?d:\w)/, 'Under unicode_strings: "\xc0" !~ /(?d:\w)/';
    }

    {
        # Test that a regex followed by an operator and/or a statement modifier work
        # These tests use string-eval so that it reports a clean error when it fails
        # (without the string eval the test script might be unparseable)

        # Note: these test check the behaviour that currently is valid syntax
        # If a new regex modifier is added and a test fails then there is a backwards-compatibility issue
        # Note-2: a new deprecate warning was added for this with commit e6897b1a5db0410e387ccbf677e89fc4a1d8c97a
        # which indicate that this syntax will be removed in 5.16.
        # When this happens the tests can be removed

	foreach (['my $r = "a" =~ m/a/lt 2', 'm', 'lt'],
		 ['my $r = "a" =~ m/a/le 1', 'm', 'le'],
		 ['my $r = "a" =~ m/a/eq 1', 'm', 'eq'],
		 ['my $r = "a" =~ m/a/ne 0', 'm', 'ne'],
		 ['my $r = "a" =~ m/a/and 1', 'm', 'and'],
		 ['my $r = "a" =~ m/a/unless 0', 'm', 'unless'],
		 ['my $c = 1; my $r; $r = "a" =~ m/a/while $c--', 'm', 'while'],
		 ['my $c = 0; my $r; $r = "a" =~ m/a/until $c++', 'm', 'until'],
		 ['my $r; $r = "a" =~ m/a/for 1', 'm', 'for'],
		 ['my $r; $r = "a" =~ m/a/foreach 1', 'm', 'foreach'],

		 ['my $t = "a"; my $r = $t =~ s/a//lt 2', 's', 'lt'],
		 ['my $t = "a"; my $r = $t =~ s/a//le 1', 's', 'le'],
		 ['my $t = "a"; my $r = $t =~ s/a//ne 0', 's', 'ne'],
		 ['my $t = "a"; my $r = $t =~ s/a//and 1', 's', 'and'],
		 ['my $t = "a"; my $r = $t =~ s/a//unless 0', 's', 'unless'],

		 ['my $c = 1; my $r; my $t = "a"; $r = $t =~ s/a//while $c--', 's', 'while'],
		 ['my $c = 0; my $r; my $t = "a"; $r = $t =~ s/a//until $c++', 's', 'until'],
		 ['my $r; my $t = "a"; $r = $t =~ s/a//for 1', 's', 'for'],
		 ['my $r; my $t = "a"; $r = $t =~ s/a//for 1', 's', 'foreach'],
		) {
	    my $message = sprintf 'regex (%s) followed by $_->[2]',
		$_->[1] eq 'm' ? 'm//' : 's///';
	    my $code = "$_->[0]; 'eval_ok ' . \$r";
	    my $result = do {
		no warnings 'syntax';
		eval $code;
	    };
	    is($@@, '', $message);
	    is($result, 'eval_ok 1', $message);
	}
    }

    {
        my $str= "\x{100}";
        chop $str;
        my $qr= qr/$str/;
        is("$qr", "(?^:)", "Empty pattern qr// stringifies to (?^:) with unicode flag enabled - Bug #80212");
        $str= "";
        $qr= qr/$str/;
        is("$qr", "(?^:)", "Empty pattern qr// stringifies to (?^:) with unicode flag disabled - Bug #80212");

    }

    {
        local $::TODO = "[perl #38133]";

        "A" =~ /(((?:A))?)+/;
        my $first = $2;

        "A" =~ /(((A))?)+/;
        my $second = $2;

        is($first, $second);
    }

    {
	# RT #3516: \G in a m//g expression causes problems
	my $count = 0;
	while ("abc" =~ m/(\G[ac])?/g) {
	    last if $count++ > 10;
	}
	ok($count < 10, 'RT #3516 A');

	$count = 0;
	while ("abc" =~ m/(\G|.)[ac]/g) {
	    last if $count++ > 10;
	}
	ok($count < 10, 'RT #3516 B');

	$count = 0;
	while ("abc" =~ m/(\G?[ac])?/g) {
	    last if $count++ > 10;
	}
	ok($count < 10, 'RT #3516 C');
    }
    {
        # RT #84294: Is this a bug in the simple Perl regex?
        #          : Nested buffers and (?{...}) dont play nicely on partial matches
        our @@got= ();
        ok("ab" =~ /((\w+)(?{ push @@got, $2 })){2}/,"RT #84294: Pattern should match");
        my $want= "'ab', 'a', 'b'";
        my $got= join(", ", map { defined($_) ? "'$_'" : "undef" } @@got);
        is($got,$want,'RT #84294: check that "ab" =~ /((\w+)(?{ push @@got, $2 })){2}/ leaves @@got in the correct state');
    }

    {
        # Suppress warnings, as the non-unicode one comes out even if turn off
        # warnings here (because the execution is done in another scope).
        local $SIG{__WARN__} = sub {};
        my $str = "\x{110000}";

        # No non-unicode code points match any Unicode property, even inverse
        # ones
        unlike($str, qr/\p{ASCII_Hex_Digit=True}/, "Non-Unicode doesn't match \\p{}");
        unlike($str, qr/\p{ASCII_Hex_Digit=False}/, "Non-Unicode doesn't match \\p{}");
        like($str, qr/\P{ASCII_Hex_Digit=True}/, "Non-Unicode matches \\P{}");
        like($str, qr/\P{ASCII_Hex_Digit=False}/, "Non-Unicode matches \\P{}");
    }

    {
        # Test that IDstart works, but because the author (khw) knows
        # regexes much better than the rest of the core, it is being done here
        # in the context of a regex which relies on buffer names beginng with
        # IDStarts.
        use utf8;
        my $str = "abc";
        like($str, qr/(?<a>abc)/, "'a' is legal IDStart");
        like($str, qr/(?<_>abc)/, "'_' is legal IDStart");
        like($str, qr/(?<ß>abc)/, "U+00DF is legal IDStart");
        like($str, qr/(?<ℕ>abc)/, "U+2115' is legal IDStart");

        # This test works on Unicode 6.0 in which U+2118 and U+212E are legal
        # IDStarts there, but are not Word characters, and therefore Perl
        # doesn't allow them to be IDStarts.  But there is no guarantee that
        # Unicode won't change things around in the future so that at some
        # future Unicode revision these tests would need to be revised.
        foreach my $char ("%", "×", chr(0x2118), chr(0x212E)) {
            my $prog = <<"EOP";
use utf8;;
"abc" =~ qr/(?<$char>abc)/;
EOP
            utf8::encode($prog);
            fresh_perl_like($prog, qr!Sequence.* not recognized!, "",
                        sprintf("'U+%04X not legal IDFirst'", ord($char)));
        }
    }

    { # [perl #101710]
        my $pat = "b";
        utf8::upgrade($pat);
        like("\xffb", qr/$pat/i, "/i: utf8 pattern, non-utf8 string, latin1-char preceding matching char in string");
    }

    { # Crash with @@a =~ // warning
	local $SIG{__WARN__} = sub {
             pass 'no crash for @@a =~ // warning'
        };
	eval ' sub { my @@a =~ // } ';
    }

    { # Concat overloading and qr// thingies
	my @@refs;
	my $qr = qr//;
        package Cat {
            require overload;
            overload->import(
		'""' => sub { ${$_[0]} },
		'.' => sub {
		    push @@refs, ref $_[1] if ref $_[1];
		    bless $_[2] ? \"$_[1]${$_[0]}" : \"${$_[0]}$_[1]"
		}
            );
	}
	my $s = "foo";
	my $o = bless \$s, Cat::;
	/$o$qr/;
	is "@@refs", "Regexp", '/$o$qr/ passes qr ref to cat overload meth';
    }

    {
        my $count=0;
        my $str="\n";
        $count++ while $str=~/.*/g;
        is $count, 2, 'test that ANCH_MBOL works properly. We should get 2 from $count++ while "\n"=~/.*/g';
        my $class_count= 0;
        $class_count++ while $str=~/[^\n]*/g;
        is $class_count, $count, 'while "\n"=~/.*/g and while "\n"=~/[^\n]*/g should behave the same';
        my $anch_count= 0;
        $anch_count++ while $str=~/^.*/mg;
        is $anch_count, 1, 'while "\n"=~/^.*/mg should match only once';
    }

    { # [perl #111174]
        use re '/u';
        like "\xe0", qr/(?i:\xc0)/, "(?i: shouldn't lose the passed in /u";
        use re '/a';
        unlike "\x{100}", qr/(?i:\w)/, "(?i: shouldn't lose the passed in /a";
        use re '/aa';
        unlike 'k', qr/(?i:\N{KELVIN SIGN})/, "(?i: shouldn't lose the passed in /aa";
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a18 1
    require Config; import Config;
d22 1
a22 1
plan tests => 672;  # Update this when adding/deleting tests.
d155 1
a155 1
        / \{([^}]*)}/;
d519 4
a522 14
        my $locale;

      SKIP: {
            skip 'No locale testing without d_setlocale', 1 if(!$Config{d_setlocale});

            BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            $locale = qr/\b\v$/;
            is($locale,    '(?^l:\b\v$)', 'Verify has l modifier when compiled under use locale');
            no locale;
        }
d528 1
a528 6

      SKIP: {
            skip 'No locale testing without d_setlocale', 1 if(!$Config{d_setlocale});

            is(qr/abc$locale/,    '(?^u:abc(?^l:\b\v$))', 'Verify retains l when interpolated under unicode_strings');
        }
d531 1
a531 6
      SKIP: {
            skip 'No locale testing without d_setlocale', 1 if(!$Config{d_setlocale});

            is(qr/abc$locale/,    '(?^:abc(?^l:\b\v$))', 'Verify retains l when interpolated outside locale and unicode strings');
        }

d534 3
a536 11
      SKIP: {
            skip 'No locale testing without d_setlocale', 2 if(!$Config{d_setlocale});

             BEGIN {
                if($Config{d_setlocale}) {
                    require locale; import locale;
                }
            }
            is(qr/abc$dual/,    '(?^l:abc(?^:\b\v$))', 'Verify retains d meaning when interpolated under locale');
            is(qr/abc$unicode/,    '(?^l:abc(?^u:\b\v$))', 'Verify retains u when interpolated under locale');
        }
d679 1
a679 2
    foreach ('$+[0] = 13', '$-[0] = 13', '@@+ = (7, 6, 5)',
	     '@@- = qw (foo bar)', '$^N = 42') {
d682 1
a682 1
	     '$^N, @@- and @@+ are read-only');
d987 1
a987 1
        is("@@space0", "cr ff lf spc tab vt", $message);
d1071 45
d1205 1
a1205 1
            fresh_perl_like($prog, qr!Group name must start with a non-digit word character!, "",
a1262 156

    {
	# the test for whether the pattern should be re-compiled should
	# consider the UTF8ness of the previous and current pattern
	# string, as well as the physical bytes of the pattern string

	for my $s ("\xc4\x80", "\x{100}") {
	    ok($s =~ /^$s$/, "re-compile check is UTF8-aware");
	}
    }

    #  #113682 more overloading and qr//
    # when doing /foo$overloaded/, if $overloaded returns
    # a qr/(?{})/ via qr or "" overloading, then 'use re 'eval'
    # shouldn't be required. Via '.', it still is.
    {
        package Qr0;
	use overload 'qr' => sub { qr/(??{50})/ };

        package Qr1;
	use overload '""' => sub { qr/(??{51})/ };

        package Qr2;
	use overload '.'  => sub { $_[1] . qr/(??{52})/ };

        package Qr3;
	use overload '""' => sub { qr/(??{7})/ },
		     '.'  => sub { $_[1] . qr/(??{53})/ };

        package Qr_indirect;
	use overload '""'  => sub { $_[0][0] };

	package main;

	for my $i (0..3) {
	    my $o = bless [], "Qr$i";
	    if ((0,0,1,1)[$i]) {
		eval { "A5$i" =~ /^A$o$/ };
		like($@@, qr/Eval-group not allowed/, "Qr$i");
		eval { "5$i" =~ /$o/ };
		like($@@, ($i == 3 ? qr/^$/ : qr/no method found,/),
			"Qr$i bare");
		{
		    use re 'eval';
		    ok("A5$i" =~ /^A$o$/, "Qr$i - with use re eval");
		    eval { "5$i" =~ /$o/ };
		    like($@@, ($i == 3 ? qr/^$/ : qr/no method found,/),
			    "Qr$i bare - with use re eval");
		}
	    }
	    else {
		ok("A5$i" =~ /^A$o$/, "Qr$i");
		ok("5$i" =~ /$o/, "Qr$i bare");
	    }
	}

	my $o = bless [ bless [], "Qr1" ], 'Qr_indirect';
	ok("A51" =~ /^A$o/, "Qr_indirect");
	ok("51" =~ /$o/, "Qr_indirect bare");
    }

    {   # Various flags weren't being set when a [] is optimized into an
        # EXACTish node
        ;
        ;
        ok("\x{017F}\x{017F}" =~ qr/^[\x{00DF}]?$/i, "[] to EXACTish optimization");
    }

    {
        for my $char (":", "\x{f7}", "\x{2010}") {
            my $utf8_char = $char;
            utf8::upgrade($utf8_char);
            my $display = $char;
            $display = display($display);
            my $utf8_display = "utf8::upgrade(\"$display\")";

            like($char, qr/^$char?$/, "\"$display\" =~ /^$display?\$/");
            like($char, qr/^$utf8_char?$/, "my \$p = \"$display\"; utf8::upgrade(\$p); \"$display\" =~ /^\$p?\$/");
            like($utf8_char, qr/^$char?$/, "my \$c = \"$display\"; utf8::upgrade(\$c); \"\$c\" =~ /^$display?\$/");
            like($utf8_char, qr/^$utf8_char?$/, "my \$c = \"$display\"; utf8::upgrade(\$c); my \$p = \"$display\"; utf8::upgrade(\$p); \"\$c\" =~ /^\$p?\$/");
        }
    }

    {
	# #116148: Pattern utf8ness sticks around globally
	# the utf8 in the first match was sticking around for the second
	# match

	use feature 'unicode_strings';

	my $x = "\x{263a}";
	$x =~ /$x/;

	my $text = "Perl";
	ok("Perl" =~ /P.*$/i, '#116148');
    }

    { # 117327: Sequence (?#...) not recognized in regex
      # The space between the '(' and '?' is now deprecated; this test should
      # be removed when the deprecation is made fatal.
        no warnings;
        like("ab", qr/a( ?#foo)b/x);
    }

    { # 118297: Mixing up- and down-graded strings in regex
        utf8::upgrade(my $u = "\x{e5}");
        utf8::downgrade(my $d = "\x{e5}");
        my $warned;
        local $SIG{__WARN__} = sub { $warned++ if $_[0] =~ /\AMalformed UTF-8/ };
        my $re = qr/$u$d/;
        ok(!$warned, "no warnings when interpolating mixed up-/downgraded strings in pattern");
        my $c = "\x{e5}\x{e5}";
        utf8::downgrade($c);
        like($c, $re, "mixed up-/downgraded pattern matches downgraded string");
        utf8::upgrade($c);
        like($c, $re, "mixed up-/downgraded pattern matches upgraded string");
    }

    {
        # if we have 87 capture buffers defined then \87 should refer to the
        # 87th.  test that this is true for 1..100
        # Note that this test causes the engine to recurse at runtime, and
        # hence use a lot of C stack.
        for my $i (1..100) {
            my $capture= "a";
            $capture= "($capture)" for 1 .. $i;
            for my $mid ("","b") {
                my $str= "a${mid}a";
                my $backref= "\\$i";
                eval {
                    ok($str=~/$capture$mid$backref/,"\\$i works with $i buffers '$str'=~/...$mid$backref/");
                    1;
                } or do {
                    is("$@@","","\\$i works with $i buffers works with $i buffers '$str'=~/...$mid$backref/");
                };
            }
        }
    }

    {
	# RT #119125
	# the earlier fix for /[#](?{})/x, although correct, as a
	# side-effect fixed another long-standing bug where /[#$x]/x
	# didn't interpolate the var $x. Although fixing that is good,
	# it's too big a change for maint, so keep the old buggy behaviour
	# for now.

	my $b = 'cd';
	my $s = 'abcd$%#&';
	$s =~ s/[a#$b%]/X/g;
	is ($s, 'XbXX$XX&', 'RT #119125 without /x');
	$s = 'abcd$%#&';
	$s =~ s/[a#$b%]/X/gx;
	is ($s, 'XXcdXXX&', 'RT #119125 with /x');
    }

@


1.1.1.4
log
@Import perl-5.20.1
@
text
@d23 1
a23 1
plan tests => 722;  # Update this when adding/deleting tests.
a705 8

        # Check that values don’t stick
        "     "=~/()()()(.)(..)/;
        my($m,$p) = (\$-[5], \$+[5]);
        () = "$$_" for $m, $p; # FETCH (or eqv.)
        " " =~ /()/;
        is $$m, undef, 'values do not stick to @@- elements';
        is $$p, undef, 'values do not stick to @@+ elements';
d729 2
a731 22

    }

    {
        my $message = '\G and intuit and anchoring';
	$_ = "abcdef";
	pos = 0;
	ok($_ =~ /\Gabc/, $message);
	ok($_ =~ /^\Gabc/, $message);

	pos = 3;
	ok($_ =~ /\Gdef/, $message);
	pos = 3;
	ok($_ =~ /\Gdef$/, $message);
	pos = 3;
	ok($_ =~ /abc\Gdef$/, $message);
	pos = 3;
	ok($_ =~ /^abc\Gdef$/, $message);
	pos = 3;
	ok($_ =~ /c\Gd/, $message);
	pos = 3;
	ok($_ =~ /..\GX?def/, $message);
a734 8
        my $s = '123';
        pos($s) = 1;
        my @@a = $s =~ /(\d)\G/g; # this infinitely looped up till 5.19.1
        is("@@a", "1", '\G looping');
    }


    {
d802 13
d816 2
a817 12
	ok($foo =~ /.\G(..)/g, $message);
	is($1, 'ab', $message);

	pos ($foo) += 1;
	ok($foo =~ /.\G(..)/g, $message);
	is($1, 'cc', $message);

	pos ($foo) += 1;
	ok($foo =~ /.\G(..)/g, $message);
	is($1, 'de', $message);

	ok($foo =~ /\Gef/g, $message);
a831 30
        my $message = 'basic \G floating checks';
        my $foo = 'aabbccddeeffgg';
        pos ($foo) = 1;

	ok($foo =~ /a+\G(..)/g, "$message: a+\\G");
	is($1, 'ab', "$message: ab");

	pos ($foo) += 1;
	ok($foo =~ /b+\G(..)/g, "$message: b+\\G");
	is($1, 'cc', "$message: cc");

	pos ($foo) += 1;
	ok($foo =~ /d+\G(..)/g, "$message: d+\\G");
	is($1, 'de', "$message: de");

	ok($foo =~ /\Gef/g, "$message: \\Gef");

        pos ($foo) = 1;

	ok($foo =~ /(?=a+\G)(..)/g, "$message: (?a+\\G)");
	is($1, 'aa', "$message: aa");

        pos ($foo) = 2;

	ok($foo =~ /a(?=a+\G)(..)/g, "$message: a(?=a+\\G)");
	is($1, 'ab', "$message: ab");

    }

    {
d1159 6
a1164 4
        unlike($str, qr/\p{ASCII_Hex_Digit=True}/, "Non-Unicode doesn't match \\p{AHEX=True}");
        like($str, qr/\p{ASCII_Hex_Digit=False}/, "Non-Unicode matches \\p{AHEX=False}");
        like($str, qr/\P{ASCII_Hex_Digit=True}/, "Non-Unicode matches \\P{AHEX=True}");
        unlike($str, qr/\P{ASCII_Hex_Digit=False}/, "Non-Unicode matches \\P{AHEX=FALSE}");
d1190 1
a1190 1
            fresh_perl_like($prog, qr!Group name must start with a non-digit word character!, {},
d1367 2
a1368 2
        # if we have 87 capture buffers defined then \87 should refer to the 87th.
        # test that this is true for 1..100
d1387 7
a1393 13
    # this mixture of readonly (not COWable) and COWable strings
    # messed up the capture buffers under COW. The actual test results
    # are incidental; the issue is was an AddressSanitizer failure
    {
	my $c ='AB';
	my $res = '';
	for ($c, 'C', $c, 'DE') {
	    ok(/(.)/, "COWable match");
	    $res .= $1;
	}
	is($res, "ACAD");
    }

a1394 3
    {
	# RT #45667
	# /[#$x]/x didn't interpolate the var $x.
d1398 1
a1398 1
	is ($s, 'XbXX$XX&', 'RT #45667 without /x');
d1401 1
a1401 118
	is ($s, 'XbXX$XX&', 'RT #45667 with /x');
    }

    {
	no warnings "uninitialized";
	my @@a;
	$a[1]++;
	/@@a/;
	pass('no crash with /@@a/ when array has nonexistent elems');
    }

    {
	is runperl(prog => 'delete $::{qq-\cR-}; //; print qq-ok\n-'),
	   "ok\n",
	   'deleting *^R does not result in crashes';
	no warnings 'once';
	*^R = *caretRglobwithnoscalar;
	"" =~ /(?{42})/;
	is $^R, 42, 'assigning to *^R does not result in a crash';
	is runperl(
	     stderr => 1,
	     prog => 'eval q|'
	            .' q-..- =~ /(??{undef *^R;q--})(?{42})/; '
                    .' print qq-$^R\n-'
	            .'|'
	   ),
	   "42\n",
	   'undefining *^R within (??{}) does not result in a crash';
    }

    {
        # [perl #120446]
        # this code should be virtually instantaneous. If it takes 10s of
        # seconds, there a bug in intuit_start.
        # (this test doesn't actually test for slowness - that involves
        # too much danger of false positives on loaded machines - but by
        # putting it here, hopefully someone might notice if it suddenly
        # runs slowly)
        my $s = ('a' x 1_000_000) . 'b';
        my $i = 0;
        for (1..10_000) {
            pos($s) = $_;
            $i++ if $s =~/\Gb/g;
        }
        is($i, 0, "RT 120446: mustn't run slowly");
    }

    {
        # [perl #120692]
        # these tests should be virtually instantaneous. If they take 10s of
        # seconds, there's a bug in intuit_start.

        my $s = 'ab' x 1_000_000;
        utf8::upgrade($s);
        1 while $s =~ m/\Ga+ba+b/g;
        pass("RT#120692 \\G mustn't run slowly");

        $s=~ /^a{1,2}x/ for  1..10_000;
        pass("RT#120692 a{1,2} mustn't run slowly");

        $s=~ /ab.{1,2}x/;
        pass("RT#120692 ab.{1,2} mustn't run slowly");

        $s = "-a-bc" x 250_000;
        $s .= "1a1bc";
        utf8::upgrade($s);
        ok($s =~ /\da\d{0,30000}bc/, "\\d{30000}");

        $s = "-ab\n" x 250_000;
        $s .= "abx";
        ok($s =~ /^ab.*x/m, "distant float with /m");

        my $r = qr/^abcd/;
        $s = "abcd-xyz\n" x 500_000;
        $s =~ /$r\d{1,2}xyz/m for 1..200;
        pass("BOL within //m  mustn't run slowly");

        $s = "abcdefg" x 1_000_000;
        $s =~ /(?-m:^)abcX?fg/m for 1..100;
        pass("BOL within //m  mustn't skip absolute anchored check");

        $s = "abcdefg" x 1_000_000;
        $s =~ /^XX\d{1,10}cde/ for 1..100;
        pass("abs anchored float string should fail quickly");

    }

    # These are based on looking at the code in regcomp.c
    # We don't look for specific code, just the existence of an SSC
    foreach my $re (qw(     qr/a?c/
                            qr/a?c/i
                            qr/[ab]?c/
                            qr/\R?c/
                            qr/\d?c/d
                            qr/\w?c/l
                            qr/\s?c/a
                            qr/[[:alpha:]]?c/u
    )) {
      SKIP: {
        skip "no re-debug under miniperl" if is_miniperl;
        my $prog = <<"EOP";
use re qw(Debug COMPILE);
$re;
EOP
        fresh_perl_like($prog, qr/synthetic stclass/, { stderr=>1 }, "$re generates a synthetic start class");
      }
    }

    {
        like "\x{AA}", qr/a?[\W_]/d, "\\W with /d synthetic start class works";
    }



    {   # Was getting optimized into EXACT (non-folding node)
        my $x = qr/[x]/i;
        utf8::upgrade($x);
        like("X", qr/$x/, "UTF-8 of /[x]/i matches upper case");
@


1.1.1.5
log
@Import perl-5.20.2
@
text
@d23 1
a23 1
plan tests => 726;  # Update this when adding/deleting tests.
a1590 14
    {	# [perl #123539]
        like("TffffffffffffTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff", qr/TffffffffffffTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff/il, "");
        like("TffffffffffffT\x{100}TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff", qr/TffffffffffffT\x{100}TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT5TTTTTTTTTTTTTTTTTTTTTTTTT3TTgTTTTTTTTTTTTTTTTTTTTT2TTTTTTTTTTTTTTTTTTTTTTTHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHiHHHHHHHfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff&ffff/il, "");
    }

	{	# [perl #123604]
		my($s, $x, @@x) = ('abc', 'a', 'd');
		my $long = 'b' x 2000;
		my $eval = q{$s =~ m{$x[bbb]c} ? 1 : 0};
		$eval =~ s{bbb}{$long};
		my $match = eval $eval;
		ok(1, "did not crash");
		ok($match, "[bbb...] resolved as character class, not subscript");
	}
@


1.1.1.6
log
@Import perl-5.24.2
@
text
@d18 1
a18 1
    @@INC = ('../lib','.','../ext/re');
d20 1
a20 4
    require './test.pl'; require './charset_tools.pl';
    require './loc_tools.pl';
    skip_all('no re module') unless defined &DynaLoader::boot_DynaLoader;
    skip_all_without_unicode_tables();
d23 1
a23 1
plan tests => 789;  # Update this when adding/deleting tests.
d523 1
a523 1
            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');
d525 5
a529 1
            use locale;
d541 1
a541 1
            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');
d548 2
a549 1
            skip 'Locales not available', 1 unless locales_enabled('LC_CTYPE');
d556 1
a556 1
            skip 'Locales not available', 2 unless locales_enabled('LC_CTYPE');
d558 5
a562 1
             use locale;
d1108 1
a1108 1
        my $e = "B" . uni_to_native("\x{f6}") . "ck";
d1135 7
a1141 4
    {   # Some constructs with Latin1 characters cause a utf8 string not
        # to match itself in non-utf8
        my $c = uni_to_native("\xc0");
        my $pattern = my $utf8_pattern = qr/(($c)+,?)/;
d1154 4
a1157 1
    {   # Make sure can override the formatting
d1159 2
a1160 2
        ok uni_to_native("\xc0") =~ /\w/, 'Under unicode_strings: "\xc0" =~ /\w/';
        ok uni_to_native("\xc0") !~ /(?d:\w)/, 'Under unicode_strings: "\xc0" !~ /(?d:\w)/';
d1303 1
a1303 2
        my $A_grave = uni_to_native("\xc0");
        like uni_to_native("\xe0"), qr/(?i:$A_grave)/, "(?i: shouldn't lose the passed in /u";
d1315 1
a1315 1
	for my $s (byte_utf8a_to_utf8n("\xc4\x80"), "\x{100}") {
d1374 1
a1374 2
        my $sharp_s = uni_to_native("\xdf");
        ok("\x{017F}\x{017F}" =~ qr/^[$sharp_s]?$/i, "[] to EXACTish optimization");
d1378 1
a1378 1
        for my $char (":", uni_to_native("\x{f7}"), "\x{2010}") {
d1406 7
d1501 55
a1555 37
    SKIP: {   # Test literal range end point special handling
        unless ($::IS_EBCDIC) {
            skip "Valid only for EBCDIC", 24;
        }

        like("\x89", qr/[i-j]/, '"\x89" should match [i-j]');
        unlike("\x8A", qr/[i-j]/, '"\x8A" shouldnt match [i-j]');
        unlike("\x90", qr/[i-j]/, '"\x90" shouldnt match [i-j]');
        like("\x91", qr/[i-j]/, '"\x91" should match [i-j]');

        like("\x89", qr/[i-\N{LATIN SMALL LETTER J}]/, '"\x89" should match [i-\N{LATIN SMALL LETTER J}]');
        unlike("\x8A", qr/[i-\N{LATIN SMALL LETTER J}]/, '"\x8A" shouldnt match [i-\N{LATIN SMALL LETTER J}]');
        unlike("\x90", qr/[i-\N{LATIN SMALL LETTER J}]/, '"\x90" shouldnt match [i-\N{LATIN SMALL LETTER J}]');
        like("\x91", qr/[i-\N{LATIN SMALL LETTER J}]/, '"\x91" should match [i-\N{LATIN SMALL LETTER J}]');

        like("\x89", qr/[i-\N{U+6A}]/, '"\x89" should match [i-\N{U+6A}]');
        unlike("\x8A", qr/[i-\N{U+6A}]/, '"\x8A" shouldnt match [i-\N{U+6A}]');
        unlike("\x90", qr/[i-\N{U+6A}]/, '"\x90" shouldnt match [i-\N{U+6A}]');
        like("\x91", qr/[i-\N{U+6A}]/, '"\x91" should match [i-\N{U+6A}]');

        like("\x89", qr/[\N{U+69}-\N{U+6A}]/, '"\x89" should match [\N{U+69}-\N{U+6A}]');
        unlike("\x8A", qr/[\N{U+69}-\N{U+6A}]/, '"\x8A" shouldnt match [\N{U+69}-\N{U+6A}]');
        unlike("\x90", qr/[\N{U+69}-\N{U+6A}]/, '"\x90" shouldnt match [\N{U+69}-\N{U+6A}]');
        like("\x91", qr/[\N{U+69}-\N{U+6A}]/, '"\x91" should match [\N{U+69}-\N{U+6A}]');

        like("\x89", qr/[i-\x{91}]/, '"\x89" should match [i-\x{91}]');
        like("\x8A", qr/[i-\x{91}]/, '"\x8A" should match [i-\x{91}]');
        like("\x90", qr/[i-\x{91}]/, '"\x90" should match [i-\x{91}]');
        like("\x91", qr/[i-\x{91}]/, '"\x91" should match [i-\x{91}]');

        # Need to use eval, because tries to compile on ASCII platforms even
        # though the tests are skipped, and fails because 0x89-j is an illegal
        # range there.
        like("\x89", eval 'qr/[\x{89}-j]/', '"\x89" should match [\x{89}-j]');
        like("\x8A", eval 'qr/[\x{89}-j]/', '"\x8A" should match [\x{89}-j]');
        like("\x90", eval 'qr/[\x{89}-j]/', '"\x90" should match [\x{89}-j]');
        like("\x91", eval 'qr/[\x{89}-j]/', '"\x91" should match [\x{89}-j]');
d1567 1
a1567 1
                            qr/[[:lower:]]?c/u
a1582 2
    SKIP: {
        skip("Tests are ASCII-centric, some would fail on EBCDIC", 12) if $::IS_EBCDIC;
a1583 39
        # Verify that the very last Latin-1 U+00FF
        # (LATIN SMALL LETTER Y WITH DIAERESIS)
        # and its UPPER counterpart (U+0178 which is pure Unicode),
        # and likewise for the very first pure Unicode
        # (LATIN CAPITAL LETTER A WITH MACRON) fold-match properly,
        # and there are no off-by-one logic errors in the transition zone.

        ok("\xFF" =~ /\xFF/i, "Y WITH DIAERESIS l =~ l");
        ok("\xFF" =~ /\x{178}/i, "Y WITH DIAERESIS l =~ u");
        ok("\x{178}" =~ /\xFF/i, "Y WITH DIAERESIS u =~ l");
        ok("\x{178}" =~ /\x{178}/i, "Y WITH DIAERESIS u =~ u");

        # U+00FF with U+05D0 (non-casing Hebrew letter).
        ok("\xFF\x{5D0}" =~ /\xFF\x{5D0}/i, "Y WITH DIAERESIS l =~ l");
        ok("\xFF\x{5D0}" =~ /\x{178}\x{5D0}/i, "Y WITH DIAERESIS l =~ u");
        ok("\x{178}\x{5D0}" =~ /\xFF\x{5D0}/i, "Y WITH DIAERESIS u =~ l");
        ok("\x{178}\x{5D0}" =~ /\x{178}\x{5D0}/i, "Y WITH DIAERESIS u =~ u");

        # U+0100.
        ok("\x{100}" =~ /\x{100}/i, "A WITH MACRON u =~ u");
        ok("\x{100}" =~ /\x{101}/i, "A WITH MACRON u =~ l");
        ok("\x{101}" =~ /\x{100}/i, "A WITH MACRON l =~ u");
        ok("\x{101}" =~ /\x{101}/i, "A WITH MACRON l =~ l");
    }

    {
        use utf8;
        ok("abc" =~ /abc/x, "NEL is white-space under /x");
    }

    {
        ok('a(b)c' =~ qr(a\(b\)c), "'\\(' is a literal in qr(...)");
        ok('a[b]c' =~ qr[a\[b\]c], "'\\[' is a literal in qr[...]");
        ok('a{3}c' =~ qr{a\{3\}c},  # Only failed when { could be a meta
              "'\\{' is a literal in qr{...}, where it could be a quantifier");

        # This one is for completeness
        ok('a<b>c' =~ qr<a\<b\>c>, "'\\<' is a literal in qr<...>)");
    }
a1590 25
    {   # make sure we get an error when \p{} cannot load Unicode tables
        fresh_perl_like(<<'        prog that cannot load uni tables',
            BEGIN {
                @@INC = '../lib';
                require utf8; require 'utf8_heavy.pl';
                @@INC = ();
            }
            $name = 'A B';
            if ($name =~ /(\p{IsUpper}) (\p{IsUpper})/){
                print "It's good! >$1< >$2<\n";
            } else {
                print "It's not good...\n";
            }
        prog that cannot load uni tables
                  qr/^Can't locate unicore\/Heavy\.pl(?x:
                   )|^Can't find Unicode property definition/,
                  undef,
                 '\p{} should not fail silently when uni tables evanesce');
    }

    {   # Special handling of literal-ended ranges in [...] was breaking this
        use utf8;
        like("ÿ", qr/[ÿ-ÿ]/, "\"ÿ\" should match [ÿ-ÿ]");
    }

a1604 125

	{	# [perl #123755]
		for my $pat ('(??', '(?P', '(?i-') {
			eval qq{ qr/$pat/ };
			ok(1, "qr/$pat/ did not crash");
			eval qq{ qr/${pat}\x{123}/ };
			my $e = $@@;
			like($e, qr{\x{123}},
				"qr/${pat}x/ shows x in error even if it's a wide character");
		}
	}

	{
		# Expect one of these sizes to cause overflow and wrap to negative
		for my $bits (32, 64) {
			my $wrapneg = 2 ** ($bits - 2) * 3;
			for my $sign ('', '-') {
				my $pat = sprintf "qr/(?%s%u)/", $sign, $wrapneg;
				eval $pat;
				ok(1, "big backref $pat did not crash");
			}
		}
	}
        {
            # Test that we handle qr/\8888888/ and variants without an infinite loop,
            # we use a test within a test so we can todo it, and make sure we don't
            # infinite loop our tests.
            # NOTE - Do not put quotes in the code!
            # NOTE - We have to triple escape the backref in the pattern below.
            my $code='
                BEGIN{require q(test.pl);}
                watchdog(3);
                for my $len (1 .. 20) {
                    my $eights= q(8) x $len;
                    eval qq{ qr/\\\\$eights/ };
                }
                print q(No infinite loop here!);
            ';
            fresh_perl_is($code, "No infinite loop here!", {},
                "test that we handle things like m/\\888888888/ without infinite loops" );
        }

        {   # Test that we handle some malformed UTF-8 without looping [perl
            # #123562]

            my $code='
                BEGIN{require q(test.pl);}
                use Encode qw(_utf8_on);
                # \x80 and \x41 are continuation bytes in their respective
                # character sets
                my $malformed = (ord("A") == 65) ? "a\x80\n" : "a\x41\n";
                utf8::downgrade($malformed);
                _utf8_on($malformed);
                watchdog(3);
                $malformed =~ /(\n\r|\r)$/;
                print q(No infinite loop here!);
            ';
            fresh_perl_like($code, qr/Malformed UTF-8 character/, {},
                "test that we handle some UTF-8 malformations without looping" );
        }

	{
		# [perl #123843] hits SEGV trying to compile this pattern
		my $match;
		eval q{ ($match) = ("xxyxxyxy" =~ m{(x+(y(?1))*)}) };
		ok(1, "compiled GOSUB in CURLYM ok");
		is($match, 'xxyxxyx', "matched GOSUB in CURLYM");
	}

	{
		# [perl #123852] doesn't avoid all the capture-related work with
		# //n, leading to possible memory corruption
		eval q{ qr{()(?1)}n };
		my $error = $@@;
		ok(1, "qr{()(?1)}n didn't crash");
		like($error, qr{Reference to nonexistent group},
				'gave appropriate error for qr{()(?1)}n');
	}

	{
            # [perl #126406] panic with unmatchable quantifier
            my $code='
                no warnings "regexp";
                "" =~ m/(.0\N{6,0}0\N{6,0}000000000000000000000000000000000)/;
            ';
            fresh_perl_is($code, "", {},
                            "perl [#126406] panic");
	}
        {
            my $bug="[perl #126182]"; # test for infinite pattern recursion
            for my $tuple (
                    [ 'q(a)=~/(.(?2))((?<=(?=(?1)).))/', "died", "look ahead left recursion fails fast" ],
                    [ 'q(aa)=~/(?R)a/', "died", "left-recursion fails fast", ],
                    [ 'q(bbaa)=~/(?&x)(?(DEFINE)(?<x>(?&y)*a)(?<y>(?&x)*b))/',
                        "died", "inter-cyclic optional left recursion dies" ],
                    [ 'q(abc) =~ /a((?1)?)c/', "died", "optional left recursion dies" ],
                    [ 'q(abc) =~ /a((?1)??)c/', "died", "min mod left recursion dies" ],
                    [ 'q(abc) =~ /a((?1)*)c/', "died", "* left recursion dies" ],
                    [ 'q(abc) =~ /a((?1)+)c/', "died", "+ left recursion dies" ],
                    [ 'q(abc) =~ /a((?1){0,3})c/', "died", "{0,3} left recursion fails fast" ],

                    [ 'q(aaabbb)=~/a(?R)?b/', "matched", "optional self recursion works" ],
                    [ '"((5maa-maa)(maa-3maa))" =~ /(\\\\((?:[^()]++|(?0))*+\\\\))/', "matched",
                        "recursion and possessive captures", "((5maa-maa)(maa-3maa))"],
                    [ '"((5maa-maa)(maa-3maa))" =~ /(\\\\((?:[^()]++|(?1))*+\\\\))/', "matched",
                        "recursion and possessive captures", "((5maa-maa)(maa-3maa))"],
                    [ '"((5maa-maa)(maa-3maa))" =~ /(\\\\((?:[^()]+|(?0))*\\\\))/', "matched",
                        "recursion and possessive captures", "((5maa-maa)(maa-3maa))"],
                    [ '"((5maa-maa)(maa-3maa))" =~ /(\\\\((?:[^()]+|(?1))*\\\\))/', "matched",
                        "recursion and possessive captures", "((5maa-maa)(maa-3maa))"],
            ) {
                my ($expr, $expect, $test_name, $cap1)= @@$tuple;
                # avoid quotes in this code!
                my $code='
                    BEGIN{require q(test.pl);}
                    watchdog(3);
                    my $status= eval(q{ !(' . $expr . ') ? q(failed) : ' .
                        ($cap1 ? '($1 ne q['.$cap1.']) ? qq(badmatch:$1) : ' : '') .
                        ' q(matched) })
                                || ( ( $@@ =~ /Infinite recursion/ ) ? qq(died) : q(strange-death) );
                    print $status;
                ';
                fresh_perl_is($code, $expect, {}, "$bug - $test_name" );
            }
        }
@


