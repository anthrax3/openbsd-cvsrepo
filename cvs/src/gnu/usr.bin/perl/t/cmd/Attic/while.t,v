head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.5.0.42
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.40
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.38
	OPENBSD_5_0:1.5.0.36
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.7
date	2014.03.24.15.05.33;	author afresh1;	state dead;
branches;
next	1.6;

1.6
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.07.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.59.58;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.10;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.10;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.41.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.10.38;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.09;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@#!./perl

BEGIN {
    require "test.pl";
}

plan(25);

my $tmpfile = tempfile();
open (tmp,'>', $tmpfile) || die "Can't create Cmd_while.tmp.";
print tmp "tvi925\n";
print tmp "tvi920\n";
print tmp "vt100\n";
print tmp "Amiga\n";
print tmp "paper\n";
close tmp or die "Could not close: $!";

# test "last" command

open(fh, $tmpfile) || die "Can't open Cmd_while.tmp.";
while (<fh>) {
    last if /vt100/;
}
ok(!eof && /vt100/);

# test "next" command

$bad = '';
open(fh, $tmpfile) || die "Can't open Cmd_while.tmp.";
while (<fh>) {
    next if /vt100/;
    $bad = 1 if /vt100/;
}
ok(eof && !/vt100/ && !$bad);

# test "redo" command

$bad = '';
open(fh,$tmpfile) || die "Can't open Cmd_while.tmp.";
while (<fh>) {
    if (s/vt100/VT100/g) {
	s/VT100/Vt100/g;
	redo;
    }
    $bad = 1 if /vt100/;
    $bad = 1 if /VT100/;
}
ok(eof && !$bad);

# now do the same with a label and a continue block

# test "last" command

$badcont = '';
open(fh,$tmpfile) || die "Can't open Cmd_while.tmp.";
line: while (<fh>) {
    if (/vt100/) {last line;}
} continue {
    $badcont = 1 if /vt100/;
}
ok(!eof && /vt100/);
ok(!$badcont);

# test "next" command

$bad = '';
$badcont = 1;
open(fh,$tmpfile) || die "Can't open Cmd_while.tmp.";
entry: while (<fh>) {
    next entry if /vt100/;
    $bad = 1 if /vt100/;
} continue {
    $badcont = '' if /vt100/;
}
ok(eof && !/vt100/ && !$bad);
ok(!$badcont);

# test "redo" command

$bad = '';
$badcont = '';
open(fh,$tmpfile) || die "Can't open Cmd_while.tmp.";
loop: while (<fh>) {
    if (s/vt100/VT100/g) {
	s/VT100/Vt100/g;
	redo loop;
    }
    $bad = 1 if /vt100/;
    $bad = 1 if /VT100/;
} continue {
    $badcont = 1 if /vt100/;
}
ok(eof && !$bad);
ok(!$badcont);

close(fh) || die "Can't close Cmd_while.tmp.";

$i = 9;
{
    $i++;
}
is($i, 10);

# Check curpm is reset when jumping out of a scope
$i = 0;
'abc' =~ /b/;
WHILE:
while (1) {
  $i++;
  is($` . $& . $', "abc");
  {                             # Localize changes to $` and friends
    'end' =~ /end/;
    redo WHILE if $i == 1;
    next WHILE if $i == 2;
    # 3 do a normal loop
    last WHILE if $i == 4;
  }
}
is($` . $& . $', "abc");

# check that scope cleanup happens right when there's a continue block
{
    my $var = 16;
    my (@@got_var, @@got_i);
    while (my $i = ++$var) {
	next if $i == 17;
	last if $i > 17;
	my $i = 0;
    }
    continue {
        ($got_var, $got_i) = ($var, $i);
    }
    is($got_var, 17);
    is($got_i, 17);
}

{
    my $got_l;
    local $l = 18;
    {
        local $l = 0
    }
    continue {
        $got_l = $l;
    }
    is($got_l, 18);
}

{
    my $got_l;
    local $l = 19;
    my $x = 0;
    while (!$x++) {
        local $l = 0
    }
    continue {
        $got_l = $l;
    }
    is($got_l, $l);
}

{
    my $ok = 1;
    $i = 20;
    while (1) {
	my $x;
	$ok = 0 if defined $x;
	if ($i == 21) {
	    next;
	}
	last;
    }
    continue {
        ++$i;
    }
    ok($ok);
}

sub save_context { $_[0] = wantarray; $_[1] }

{
    my $context = -1;
    my $p = sub {
        my $x = 1;
        while ($x--) {
            save_context($context, "foo");
        }
    };
    is(scalar($p->()), 0);
    is($context, undef, "last statement in while block has 'void' context");
}

{
    my $context = -1;
    my $p = sub {
        my $x = 1;
        {
            save_context($context, "foo");
        }
    };
    is(scalar($p->()), "foo");
    is($context, "", "last statement in block has 'scalar' context");
}

{
    # test scope is cleaned
    my $i = 0;
    my @@a;
    while ($i++ < 2) {
        my $x;
        push @@a, \$x;
    }
    ok($a[0] ne $a[1]);
}
@


1.6
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 5
a7 1
print "1..22\n";
d9 2
a10 1
open (tmp,'>Cmd_while.tmp') || die "Can't create Cmd_while.tmp.";
d20 1
a20 1
open(fh,'Cmd_while.tmp') || die "Can't open Cmd_while.tmp.";
d24 1
a24 1
if (!eof && /vt100/) {print "ok 1\n";} else {print "not ok 1 $_\n";}
d29 1
a29 1
open(fh,'Cmd_while.tmp') || die "Can't open Cmd_while.tmp.";
d34 1
a34 1
if (!eof || /vt100/ || $bad) {print "not ok 2\n";} else {print "ok 2\n";}
d39 1
a39 1
open(fh,'Cmd_while.tmp') || die "Can't open Cmd_while.tmp.";
d48 1
a48 1
if (!eof || $bad) {print "not ok 3\n";} else {print "ok 3\n";}
d55 1
a55 1
open(fh,'Cmd_while.tmp') || die "Can't open Cmd_while.tmp.";
d61 2
a62 2
if (!eof && /vt100/) {print "ok 4\n";} else {print "not ok 4\n";}
if (!$badcont) {print "ok 5\n";} else {print "not ok 5\n";}
d68 1
a68 1
open(fh,'Cmd_while.tmp') || die "Can't open Cmd_while.tmp.";
d75 2
a76 2
if (!eof || /vt100/ || $bad) {print "not ok 6\n";} else {print "ok 6\n";}
if (!$badcont) {print "ok 7\n";} else {print "not ok 7\n";}
d82 1
a82 1
open(fh,'Cmd_while.tmp') || die "Can't open Cmd_while.tmp.";
d93 2
a94 2
if (!eof || $bad) {print "not ok 8\n";} else {print "ok 8\n";}
if (!$badcont) {print "ok 9\n";} else {print "not ok 9\n";}
a96 12
unlink 'Cmd_while.tmp' || `/bin/rm Cmd_While.tmp`;

#$x = 0;
#while (1) {
#    if ($x > 1) {last;}
#    next;
#} continue {
#    if ($x++ > 10) {last;}
#    next;
#}
#
#if ($x < 10) {print "ok 10\n";} else {print "not ok 10\n";}
d102 1
a102 1
print "ok $i\n";
d105 1
d110 1
a110 2
  print "#$`,$&,$',\nnot " unless $` . $& . $' eq "abc";
  print "ok $i\n";
d113 4
a116 4
    redo WHILE if $i == 11;
    next WHILE if $i == 12;
    # 13 do a normal loop
    last WHILE if $i == 14;
d119 1
a119 3
$i++;
print "not " unless $` . $& . $' eq "abc";
print "ok $i\n";
d124 1
d131 1
a131 1
        print "ok ", $var-1, "\nok $i\n";
d133 2
d138 1
d144 1
a144 1
        print "ok $l\n"
d146 1
d150 1
d157 1
a157 1
        print "ok $l\n"
d159 1
a161 1
$i = 20;
d163 2
d167 1
a167 3
	print $x if defined $x;
	$x = "not ";
	print "ok $i\n"; ++$i;
d174 38
a211 1
        print "ok $i\n"; ++$i;
d213 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d11 1
a11 1
close tmp;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 3
# $RCSfile: while.t,v $$Revision: 4.1 $$Date: 92/08/07 18:27:15 $

print "1..15\n";
d129 51
@


1.2
log
@perl 5.004_04
@
text
@d5 1
a5 1
print "1..10\n";
d111 19
@


1.1
log
@Initial revision
@
text
@d93 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 1
a5 1
print "1..15\n";
a92 1
close(fh) || die "Can't close Cmd_while.tmp.";
a109 19
print "ok $i\n";

# Check curpm is reset when jumping out of a scope
'abc' =~ /b/;
WHILE:
while (1) {
  $i++;
  print "#$`,$&,$',\nnot " unless $` . $& . $' eq "abc";
  print "ok $i\n";
  {                             # Localize changes to $` and friends
    'end' =~ /end/;
    redo WHILE if $i == 11;
    next WHILE if $i == 12;
    # 13 do a normal loop
    last WHILE if $i == 14;
  }
}
$i++;
print "not " unless $` . $& . $' eq "abc";
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 3
a5 1
print "1..22\n";
a130 51

# check that scope cleanup happens right when there's a continue block
{
    my $var = 16;
    while (my $i = ++$var) {
	next if $i == 17;
	last if $i > 17;
	my $i = 0;
    }
    continue {
        print "ok ", $var-1, "\nok $i\n";
    }
}

{
    local $l = 18;
    {
        local $l = 0
    }
    continue {
        print "ok $l\n"
    }
}

{
    local $l = 19;
    my $x = 0;
    while (!$x++) {
        local $l = 0
    }
    continue {
        print "ok $l\n"
    }
}

$i = 20;
{
    while (1) {
	my $x;
	print $x if defined $x;
	$x = "not ";
	print "ok $i\n"; ++$i;
	if ($i == 21) {
	    next;
	}
	last;
    }
    continue {
        print "ok $i\n"; ++$i;
    }
}
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d11 1
a11 1
close tmp or die "Could not close: $!";
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 5
BEGIN {
    require "test.pl";
}

plan(25);
d5 1
a5 2
my $tmpfile = tempfile();
open (tmp,'>', $tmpfile) || die "Can't create Cmd_while.tmp.";
d15 1
a15 1
open(fh, $tmpfile) || die "Can't open Cmd_while.tmp.";
d19 1
a19 1
ok(!eof && /vt100/);
d24 1
a24 1
open(fh, $tmpfile) || die "Can't open Cmd_while.tmp.";
d29 1
a29 1
ok(eof && !/vt100/ && !$bad);
d34 1
a34 1
open(fh,$tmpfile) || die "Can't open Cmd_while.tmp.";
d43 1
a43 1
ok(eof && !$bad);
d50 1
a50 1
open(fh,$tmpfile) || die "Can't open Cmd_while.tmp.";
d56 2
a57 2
ok(!eof && /vt100/);
ok(!$badcont);
d63 1
a63 1
open(fh,$tmpfile) || die "Can't open Cmd_while.tmp.";
d70 2
a71 2
ok(eof && !/vt100/ && !$bad);
ok(!$badcont);
d77 1
a77 1
open(fh,$tmpfile) || die "Can't open Cmd_while.tmp.";
d88 2
a89 2
ok(eof && !$bad);
ok(!$badcont);
d92 12
d109 1
a109 1
is($i, 10);
a111 1
$i = 0;
d116 2
a117 1
  is($` . $& . $', "abc");
d120 4
a123 4
    redo WHILE if $i == 1;
    next WHILE if $i == 2;
    # 3 do a normal loop
    last WHILE if $i == 4;
d126 3
a128 1
is($` . $& . $', "abc");
a132 1
    my (@@got_var, @@got_i);
d139 1
a139 1
        ($got_var, $got_i) = ($var, $i);
a140 2
    is($got_var, 17);
    is($got_i, 17);
a143 1
    my $got_l;
d149 1
a149 1
        $got_l = $l;
a150 1
    is($got_l, 18);
a153 1
    my $got_l;
d160 1
a160 1
        $got_l = $l;
a161 1
    is($got_l, $l);
d164 1
a165 2
    my $ok = 1;
    $i = 20;
d168 3
a170 1
	$ok = 0 if defined $x;
d177 1
a177 38
        ++$i;
    }
    ok($ok);
}

sub save_context { $_[0] = wantarray; $_[1] }

{
    my $context = -1;
    my $p = sub {
        my $x = 1;
        while ($x--) {
            save_context($context, "foo");
        }
    };
    is(scalar($p->()), 0);
    is($context, undef, "last statement in while block has 'void' context");
}

{
    my $context = -1;
    my $p = sub {
        my $x = 1;
        {
            save_context($context, "foo");
        }
    };
    is(scalar($p->()), "foo");
    is($context, "", "last statement in block has 'scalar' context");
}

{
    # test scope is cleaned
    my $i = 0;
    my @@a;
    while ($i++ < 2) {
        my $x;
        push @@a, \$x;
a178 1
    ok($a[0] ne $a[1]);
@


