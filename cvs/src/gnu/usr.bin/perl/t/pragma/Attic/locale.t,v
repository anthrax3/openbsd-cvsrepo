head	1.5;
access;
symbols
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.5
date	2002.10.27.22.25.37;	author millert;	state dead;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.08.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.40;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.05.52;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.54;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.54;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.54;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@#!./perl -wT

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    unshift @@INC, '.';
    require Config; import Config;
    if (!$Config{d_setlocale} || $Config{ccflags} =~ /\bD?NO_LOCALE\b/) {
	print "1..0\n";
	exit;
    }
}

use strict;

my $debug = 1;

use Dumpvalue;

my $dumper = Dumpvalue->new(
                            tick => qq{"},
                            quoteHighBit => 0,
                            unctrl => "quote"
                           );
sub debug {
  return unless $debug;
  my($mess) = join "", @@_;
  chop $mess;
  print $dumper->stringify($mess,1), "\n";
}

sub debugf {
    printf @@_ if $debug;
}

my $have_setlocale = 0;
eval {
    require POSIX;
    import POSIX ':locale_h';
    $have_setlocale++;
};

# Visual C's CRT goes silly on strings of the form "en_US.ISO8859-1"
# and mingw32 uses said silly CRT
$have_setlocale = 0 if $^O eq 'MSWin32' && $Config{cc} =~ /^(cl|gcc)/i;

my $last = $have_setlocale ? 116 : 98;

print "1..$last\n";

use vars qw(&LC_ALL);

my $a = 'abc %';

sub ok {
    my ($n, $result) = @@_;

    print 'not ' unless ($result);
    print "ok $n\n";
}

# First we'll do a lot of taint checking for locales.
# This is the easiest to test, actually, as any locale,
# even the default locale will taint under 'use locale'.

sub is_tainted { # hello, camel two.
    no warnings 'uninitialized' ;
    my $dummy;
    not eval { $dummy = join("", @@_), kill 0; 1 }
}

sub check_taint ($$) {
    ok $_[0], is_tainted($_[1]);
}

sub check_taint_not ($$) {
    ok $_[0], not is_tainted($_[1]);
}

use locale;	# engage locale and therefore locale taint.

check_taint_not   1, $a;

check_taint       2, uc($a);
check_taint       3, "\U$a";
check_taint       4, ucfirst($a);
check_taint       5, "\u$a";
check_taint       6, lc($a);
check_taint       7, "\L$a";
check_taint       8, lcfirst($a);
check_taint       9, "\l$a";

check_taint_not  10, sprintf('%e', 123.456);
check_taint_not  11, sprintf('%f', 123.456);
check_taint_not  12, sprintf('%g', 123.456);
check_taint_not  13, sprintf('%d', 123.456);
check_taint_not  14, sprintf('%x', 123.456);

$_ = $a;	# untaint $_

$_ = uc($a);	# taint $_

check_taint      15, $_;

/(\w)/;	# taint $&, $`, $', $+, $1.
check_taint      16, $&;
check_taint      17, $`;
check_taint      18, $';
check_taint      19, $+;
check_taint      20, $1;
check_taint_not  21, $2;

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  22, $&;
check_taint_not  23, $`;
check_taint_not  24, $';
check_taint_not  25, $+;
check_taint_not  26, $1;
check_taint_not  27, $2;

/(\W)/;	# taint $&, $`, $', $+, $1.
check_taint      28, $&;
check_taint      29, $`;
check_taint      30, $';
check_taint      31, $+;
check_taint      32, $1;
check_taint_not  33, $2;

/(\s)/;	# taint $&, $`, $', $+, $1.
check_taint      34, $&;
check_taint      35, $`;
check_taint      36, $';
check_taint      37, $+;
check_taint      38, $1;
check_taint_not  39, $2;

/(\S)/;	# taint $&, $`, $', $+, $1.
check_taint      40, $&;
check_taint      41, $`;
check_taint      42, $';
check_taint      43, $+;
check_taint      44, $1;
check_taint_not  45, $2;

$_ = $a;	# untaint $_

check_taint_not  46, $_;

/(b)/;		# this must not taint
check_taint_not  47, $&;
check_taint_not  48, $`;
check_taint_not  49, $';
check_taint_not  50, $+;
check_taint_not  51, $1;
check_taint_not  52, $2;

$_ = $a;	# untaint $_

check_taint_not  53, $_;

$b = uc($a);	# taint $b
s/(.+)/$b/;	# this must taint only the $_

check_taint      54, $_;
check_taint_not  55, $&;
check_taint_not  56, $`;
check_taint_not  57, $';
check_taint_not  58, $+;
check_taint_not  59, $1;
check_taint_not  60, $2;

$_ = $a;	# untaint $_

s/(.+)/b/;	# this must not taint
check_taint_not  61, $_;
check_taint_not  62, $&;
check_taint_not  63, $`;
check_taint_not  64, $';
check_taint_not  65, $+;
check_taint_not  66, $1;
check_taint_not  67, $2;

$b = $a;	# untaint $b

($b = $a) =~ s/\w/$&/;
check_taint      68, $b;	# $b should be tainted.
check_taint_not  69, $a;	# $a should be not.

$_ = $a;	# untaint $_

s/(\w)/\l$1/;	# this must taint
check_taint      70, $_;
check_taint      71, $&;
check_taint      72, $`;
check_taint      73, $';
check_taint      74, $+;
check_taint      75, $1;
check_taint_not  76, $2;

$_ = $a;	# untaint $_

s/(\w)/\L$1/;	# this must taint
check_taint      77, $_;
check_taint      78, $&;
check_taint      79, $`;
check_taint      80, $';
check_taint      81, $+;
check_taint      82, $1;
check_taint_not  83, $2;

$_ = $a;	# untaint $_

s/(\w)/\u$1/;	# this must taint
check_taint      84, $_;
check_taint      85, $&;
check_taint      86, $`;
check_taint      87, $';
check_taint      88, $+;
check_taint      89, $1;
check_taint_not  90, $2;

$_ = $a;	# untaint $_

s/(\w)/\U$1/;	# this must taint
check_taint      91, $_;
check_taint      92, $&;
check_taint      93, $`;
check_taint      94, $';
check_taint      95, $+;
check_taint      96, $1;
check_taint_not  97, $2;

# After all this tainting $a should be cool.

check_taint_not  98, $a;

# I think we've seen quite enough of taint.
# Let us do some *real* locale work now,
# unless setlocale() is missing (i.e. minitest).

exit unless $have_setlocale;

# Find locales.

debug "# Scanning for locales...\n";

# Note that it's okay that some languages have their native names
# capitalized here even though that's not "right".  They are lowercased
# anyway later during the scanning process (and besides, some clueless
# vendor might have them capitalized errorneously anyway).

my $locales = <<EOF;
Afrikaans:af:za:1 15
Arabic:ar:dz eg sa:6 arabic8
Brezhoneg Breton:br:fr:1 15
Bulgarski Bulgarian:bg:bg:5
Chinese:zh:cn tw:cn.EUC eucCN eucTW euc.CN euc.TW Big5 GB2312 tw.EUC
Hrvatski Croatian:hr:hr:2
Cymraeg Welsh:cy:cy:1 14 15
Czech:cs:cz:2
Dansk Danish:dk:da:1 15
Nederlands Dutch:nl:be nl:1 15
English American British:en:au ca gb ie nz us uk zw:1 15 cp850
Esperanto:eo:eo:3
Eesti Estonian:et:ee:4 6 13
Suomi Finnish:fi:fi:1 15
Flamish::fl:1 15
Deutsch German:de:at be ch de lu:1 15
Euskaraz Basque:eu:es fr:1 15
Galego Galician:gl:es:1 15
Ellada Greek:el:gr:7 g8
Frysk:fy:nl:1 15
Greenlandic:kl:gl:4 6
Hebrew:iw:il:8 hebrew8
Hungarian:hu:hu:2
Indonesian:in:id:1 15
Gaeilge Irish:ga:IE:1 14 15
Italiano Italian:it:ch it:1 15
Nihongo Japanese:ja:jp:euc eucJP jp.EUC sjis
Korean:ko:kr:
Latine Latin:la:va:1 15
Latvian:lv:lv:4 6 13
Lithuanian:lt:lt:4 6 13
Macedonian:mk:mk:1 15
Maltese:mt:mt:3
Moldovan:mo:mo:2
Norsk Norwegian:no no\@@nynorsk:no:1 15
Occitan:oc:es:1 15
Polski Polish:pl:pl:2
Rumanian:ro:ro:2
Russki Russian:ru:ru su ua:5 koi8 koi8r KOI8-R koi8u cp1251 cp866
Serbski Serbian:sr:yu:5
Slovak:sk:sk:2
Slovene Slovenian:sl:si:2
Sqhip Albanian:sq:sq:1 15
Svenska Swedish:sv:fi se:1 15
Thai:th:th:11 tis620
Turkish:tr:tr:9 turkish8
Yiddish:yi::1 15
EOF

if ($^O eq 'os390') {
    # These cause heartburn.  Broken locales?
    $locales =~ s/Svenska Swedish:sv:fi se:1 15\n//;
    $locales =~ s/Thai:th:th:11 tis620\n//;
}

sub in_utf8 () { $^H & 0x08 }

if (in_utf8) {
    require "pragma/locale/utf8";
} else {
    require "pragma/locale/latin1";
}

my @@Locale;
my $Locale;
my @@Alnum_;

sub getalnum_ {
    sort grep /\w/, map { chr } 0..255
}

sub trylocale {
    my $locale = shift;
    if (setlocale(LC_ALL, $locale)) {
	push @@Locale, $locale;
    }
}

sub decode_encodings {
    my @@enc;

    foreach (split(/ /, shift)) {
	if (/^(\d+)$/) {
	    push @@enc, "ISO8859-$1";
	    push @@enc, "iso8859$1";	# HP
	    if ($1 eq '1') {
		 push @@enc, "roman8";	# HP
	    }
	} else {
	    push @@enc, $_;
   	    push @@enc, "$_.UTF-8";
	}
    }
    if ($^O eq 'os390') {
	push @@enc, qw(IBM-037 IBM-819 IBM-1047);
    }

    return @@enc;
}

trylocale("C");
trylocale("POSIX");
foreach (0..15) {
    trylocale("ISO8859-$_");
    trylocale("iso8859$_");
    trylocale("iso8859-$_");
    trylocale("iso_8859_$_");
    trylocale("isolatin$_");
    trylocale("isolatin-$_");
    trylocale("iso_latin_$_");
}

# Sanitize the environment so that we can run the external 'locale'
# program without the taint mode getting grumpy.

# $ENV{PATH} is special in VMS.
delete $ENV{PATH} if $^O ne 'VMS' or $Config{d_setenv};

# Other subversive stuff.
delete @@ENV{qw(IFS CDPATH ENV BASH_ENV)};

if (-x "/usr/bin/locale" && open(LOCALES, "/usr/bin/locale -a 2>/dev/null|")) {
    while (<LOCALES>) {
        chomp;
	trylocale($_);
    }
    close(LOCALES);
} elsif ($^O eq 'VMS' && defined($ENV{'SYS$I18N_LOCALE'}) && -d 'SYS$I18N_LOCALE') {
# The SYS$I18N_LOCALE logical name search list was not present on 
# VAX VMS V5.5-12, but was on AXP && VAX VMS V6.2 as well as later versions.
    opendir(LOCALES, "SYS\$I18N_LOCALE:");
    while ($_ = readdir(LOCALES)) {
        chomp;
        trylocale($_);
    }
    close(LOCALES);
} else {

    # This is going to be slow.

    foreach my $locale (split(/\n/, $locales)) {
	my ($locale_name, $language_codes, $country_codes, $encodings) =
	    split(/:/, $locale);
	my @@enc = decode_encodings($encodings);
	foreach my $loc (split(/ /, $locale_name)) {
	    trylocale($loc);
	    foreach my $enc (@@enc) {
		trylocale("$loc.$enc");
	    }
	    $loc = lc $loc;
	    foreach my $enc (@@enc) {
		trylocale("$loc.$enc");
	    }
	}
	foreach my $lang (split(/ /, $language_codes)) {
	    trylocale($lang);
	    foreach my $country (split(/ /, $country_codes)) {
		my $lc = "${lang}_${country}";
		trylocale($lc);
		foreach my $enc (@@enc) {
		    trylocale("$lc.$enc");
		}
		my $lC = "${lang}_\U${country}";
		trylocale($lC);
		foreach my $enc (@@enc) {
		    trylocale("$lC.$enc");
		}
	    }
	}
    }
}

setlocale(LC_ALL, "C");

sub utf8locale { $_[0] =~ /utf-?8/i }

@@Locale = sort @@Locale;

debug "# Locales = @@Locale\n";

my %Problem;
my %Okay;
my %Testing;
my @@Neoalpha;
my %Neoalpha;

sub tryneoalpha {
    my ($Locale, $i, $test) = @@_;
    unless ($test) {
	$Problem{$i}{$Locale} = 1;
	debug "# failed $i with locale '$Locale'\n";
    } else {
	push @@{$Okay{$i}}, $Locale;
    }
}

foreach $Locale (@@Locale) {
    debug "# Locale = $Locale\n";
    @@Alnum_ = getalnum_();
    debug "# w = ", join("",@@Alnum_), "\n";

    unless (setlocale(LC_ALL, $Locale)) {
	foreach (99..103) {
	    $Problem{$_}{$Locale} = -1;
	}
	next;
    }

    # Sieve the uppercase and the lowercase.
    
    my %UPPER = ();
    my %lower = ();
    my %BoThCaSe = ();
    for (@@Alnum_) {
	if (/[^\d_]/) { # skip digits and the _
	    if (uc($_) eq $_) {
		$UPPER{$_} = $_;
	    }
	    if (lc($_) eq $_) {
		$lower{$_} = $_;
	    }
	}
    }
    foreach (keys %UPPER) {
	$BoThCaSe{$_}++ if exists $lower{$_};
    }
    foreach (keys %lower) {
	$BoThCaSe{$_}++ if exists $UPPER{$_};
    }
    foreach (keys %BoThCaSe) {
	delete $UPPER{$_};
	delete $lower{$_};
    }

    debug "# UPPER    = ", join("", sort keys %UPPER   ), "\n";
    debug "# lower    = ", join("", sort keys %lower   ), "\n";
    debug "# BoThCaSe = ", join("", sort keys %BoThCaSe), "\n";

    # Find the alphabets that are not alphabets in the default locale.

    {
	no locale;
    
	@@Neoalpha = ();
	for (keys %UPPER, keys %lower) {
	    push(@@Neoalpha, $_) if (/\W/);
	    $Neoalpha{$_} = $_;
	}
    }

    @@Neoalpha = sort @@Neoalpha;

    debug "# Neoalpha = ", join("",@@Neoalpha), "\n";

    if (@@Neoalpha == 0) {
	# If we have no Neoalphas the remaining tests are no-ops.
	debug "# no Neoalpha, skipping tests 99..102 for locale '$Locale'\n";
	foreach (99..102) {
	    push @@{$Okay{$_}}, $Locale;
	}
    } else {

	# Test \w.
    
	if (utf8locale($Locale)) {
	    # Until the polymorphic regexen arrive.
	    debug "# skipping UTF-8 locale '$Locale'\n";
	} else {
	    my $word = join('', @@Neoalpha);

	    $word =~ /^(\w+)$/;

	    tryneoalpha($Locale, 99, $1 eq $word);
	}

	# Cross-check the whole 8-bit character set.

	for (map { chr } 0..255) {
	    tryneoalpha($Locale, 100,
			(/\w/ xor /\W/) ||
			(/\d/ xor /\D/) ||
			(/\s/ xor /\S/));
	}

	# Test for read-only scalars' locale vs non-locale comparisons.

	{
	    no locale;
	    $a = "qwerty";
	    {
		use locale;
		tryneoalpha($Locale, 101, ($a cmp "qwerty") == 0);
	    }
	}

	{
	    my ($from, $to, $lesser, $greater,
		@@test, %test, $test, $yes, $no, $sign);

	    for (0..9) {
		# Select a slice.
		$from = int(($_*@@Alnum_)/10);
		$to = $from + int(@@Alnum_/10);
		$to = $#Alnum_ if ($to > $#Alnum_);
		$lesser  = join('', @@Alnum_[$from..$to]);
		# Select a slice one character on.
		$from++; $to++;
		$to = $#Alnum_ if ($to > $#Alnum_);
		$greater = join('', @@Alnum_[$from..$to]);
		($yes, $no, $sign) = ($lesser lt $greater
				      ? ("    ", "not ", 1)
				      : ("not ", "    ", -1));
		# all these tests should FAIL (return 0).
		# Exact lt or gt cannot be tested because
		# in some locales, say, eacute and E may test equal.
		@@test = 
		    (
		     $no.'    ($lesser  le $greater)',  # 1
		     'not      ($lesser  ne $greater)', # 2
		     '         ($lesser  eq $greater)', # 3
		     $yes.'    ($lesser  ge $greater)', # 4
		     $yes.'    ($lesser  ge $greater)', # 5
		     $yes.'    ($greater le $lesser )', # 7
		     'not      ($greater ne $lesser )', # 8
		     '         ($greater eq $lesser )', # 9
		     $no.'     ($greater ge $lesser )', # 10
		     'not (($lesser cmp $greater) == -$sign)' # 12
		     );
		@@test{@@test} = 0 x @@test;
		$test = 0;
		for my $ti (@@test) {
		    $test{$ti} = eval $ti;
		    $test ||= $test{$ti}
		}
		tryneoalpha($Locale, 102, $test == 0);
		if ($test) {
		    debug "# lesser  = '$lesser'\n";
		    debug "# greater = '$greater'\n";
		    debug "# lesser cmp greater = ",
		          $lesser cmp $greater, "\n";
		    debug "# greater cmp lesser = ",
		          $greater cmp $lesser, "\n";
		    debug "# (greater) from = $from, to = $to\n";
		    for my $ti (@@test) {
			debugf("# %-40s %-4s", $ti,
			       $test{$ti} ? 'FAIL' : 'ok');
			if ($ti =~ /\(\.*(\$.+ +cmp +\$[^\)]+)\.*\)/) {
			    debugf("(%s == %4d)", $1, eval $1);
			}
			debug "\n#";
		    }

		    last;
		}
	    }
	}
    }

    use locale;

    my ($x, $y) = (1.23, 1.23);

    my $a = "$x";
    printf ''; # printf used to reset locale to "C"
    my $b = "$y";

    debug "# 103..107: a = $a, b = $b, Locale = $Locale\n";

    tryneoalpha($Locale, 103, $a eq $b);

    my $c = "$x";
    my $z = sprintf ''; # sprintf used to reset locale to "C"
    my $d = "$y";

    debug "# 104..107: c = $c, d = $d, Locale = $Locale\n";

    tryneoalpha($Locale, 104, $c eq $d); 

    {
	use warnings;
	my $w = 0;
	local $SIG{__WARN__} = sub { $w++ };

	# the == (among other ops) used to warn for locales
	# that had something else than "." as the radix character

	tryneoalpha($Locale, 105, $c == 1.23);

	tryneoalpha($Locale, 106, $c == $x);

	tryneoalpha($Locale, 107, $c == $d);

	{
	    no locale;
	
	    my $e = "$x";

	    debug "# 108..110: e = $e, Locale = $Locale\n";

	    tryneoalpha($Locale, 108, $e == 1.23);

	    tryneoalpha($Locale, 109, $e == $x);
	    
	    tryneoalpha($Locale, 110, $e == $c);
	}
	
	tryneoalpha($Locale, 111, $w == 0);

	my $f = "1.23";

	debug "# 112..114: f = $f, locale = $Locale\n";

	tryneoalpha($Locale, 112, $f == 1.23);

	tryneoalpha($Locale, 113, $f == $x);
	
	tryneoalpha($Locale, 114, $f == $c);
    }

    # Does taking lc separately differ from taking
    # the lc "in-line"?  (This was the bug 19990704.002, change #3568.)
    # The bug was in the caching of the 'o'-magic.
    {
	use locale;

	sub lcA {
	    my $lc0 = lc $_[0];
	    my $lc1 = lc $_[1];
	    return $lc0 cmp $lc1;
	}

        sub lcB {
	    return lc($_[0]) cmp lc($_[1]);
	}

        my $x = "ab";
        my $y = "aa";
        my $z = "AB";

        tryneoalpha($Locale, 115,
		    lcA($x, $y) == 1 && lcB($x, $y) == 1 ||
		    lcA($x, $z) == 0 && lcB($x, $z) == 0);
    }

    # Does lc of an UPPER (if different from the UPPER) match
    # case-insensitively the UPPER, and does the UPPER match
    # case-insensitively the lc of the UPPER.  And vice versa.
    if (utf8locale($Locale)) {
        # Until the polymorphic regexen arrive.
        debug "# skipping UTF-8 locale '$Locale'\n";
    } else {
	use locale;

	my @@f = ();
	foreach my $x (keys %UPPER) {
	    my $y = lc $x;
	    next unless uc $y eq $x;
	    push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
	}
	foreach my $x (keys %lower) {
	    my $y = uc $x;
	    next unless lc $y eq $x;
	    push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
	}
	tryneoalpha($Locale, 116, @@f == 0);
        if (@@f) {
	    print "# failed 116 locale '$Locale' characters @@f\n"
        }
    }

}

# Recount the errors.

foreach (99..$last) {
    if ($Problem{$_} || !defined $Okay{$_} || !@@{$Okay{$_}}) {
	if ($_ == 102) {
	    print "# The failure of test 102 is not necessarily fatal.\n";
	    print "# It usually indicates a problem in the enviroment,\n";
	    print "# not in Perl itself.\n";
	}
	print "not ";
    }
    print "ok $_\n";
}

# Give final advice.

my $didwarn = 0;

foreach (99..$last) {
    if ($Problem{$_}) {
	my @@f = sort keys %{ $Problem{$_} };
	my $f = join(" ", @@f);
	$f =~ s/(.{50,60}) /$1\n#\t/g;
	print
	    "#\n",
            "# The locale ", (@@f == 1 ? "definition" : "definitions"), "\n#\n",
	    "#\t", $f, "\n#\n",
	    "# on your system may have errors because the locale test $_\n",
            "# failed in ", (@@f == 1 ? "that locale" : "those locales"),
            ".\n";
	print <<EOW;
#
# If your users are not using these locales you are safe for the moment,
# but please report this failure first to perlbug\@@perl.com using the
# perlbug script (as described in the INSTALL file) so that the exact
# details of the failures can be sorted out first and then your operating
# system supplier can be alerted about these anomalies.
#
EOW
	$didwarn = 1;
    }
}

# Tell which locales were okay and which were not.

if ($didwarn) {
    my (@@s, @@F);
    
    foreach my $l (@@Locale) {
	my $p = 0;
	foreach my $t (102..$last) {
	    $p++ if $Problem{$t}{$l};
	}
	push @@s, $l if $p == 0;
      push @@F, $l unless $p == 0;
    }
    
    if (@@s) {
        my $s = join(" ", @@s);
        $s =~ s/(.{50,60}) /$1\n#\t/g;

        warn
    	    "# The following locales\n#\n",
            "#\t", $s, "\n#\n",
	    "# tested okay.\n#\n",
    } else {
        warn "# None of your locales were fully okay.\n";
    }

    if (@@F) {
        my $F = join(" ", @@F);
        $F =~ s/(.{50,60}) /$1\n#\t/g;

        warn
          "# The following locales\n#\n",
            "#\t", $F, "\n#\n",
          "# had problems.\n#\n",
    } else {
        warn "# None of your locales were broken.\n";
    }
}

# eof
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@@


1.3
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
    unshift @@INC, '../lib';
d18 7
d26 4
a29 1
    print @@_ if $debug;
d47 3
a49 1
print "1..", ($have_setlocale ? 116 : 98), "\n";
d257 1
a257 1
Chinese:zh:cn tw:cn.EUC eucCN eucTW euc.CN euc.TW GB2312 tw.EUC
d263 1
a263 1
English American British:en:au ca gb ie nz us uk:1 15 cp850
d286 2
a287 1
Norsk Norwegian:no:no:1 15
d291 1
a291 1
Russki Russian:ru:ru su ua:5 koi8 koi8r koi8u cp1251
d299 1
a299 1
Yiddish:::1 15
d303 1
d343 1
d365 34
a398 19
foreach my $locale (split(/\n/, $locales)) {
    my ($locale_name, $language_codes, $country_codes, $encodings) =
	split(/:/, $locale);
    my @@enc = decode_encodings($encodings);
    foreach my $loc (split(/ /, $locale_name)) {
	trylocale($loc);
	foreach my $enc (@@enc) {
	    trylocale("$loc.$enc");
	}
	$loc = lc $loc;
	foreach my $enc (@@enc) {
	    trylocale("$loc.$enc");
	}
    }
    foreach my $lang (split(/ /, $language_codes)) {
	trylocale($lang);
	foreach my $country (split(/ /, $country_codes)) {
	    my $lc = "${lang}_${country}";
	    trylocale($lc);
d400 1
a400 1
		trylocale("$lc.$enc");
d402 1
a402 2
	    my $lC = "${lang}_\U${country}";
	    trylocale($lC);
d404 16
a419 1
		trylocale("$lC.$enc");
d427 2
a440 2
    debug "# testing $i with locale '$Locale'\n"
	unless $Testing{$i}{$Locale}++;
d452 1
a452 1
    debug "# \\w = @@Alnum_\n";
d487 3
a489 3
    debug "# UPPER    = ", join(" ", sort keys %UPPER   ), "\n";
    debug "# lower    = ", join(" ", sort keys %lower   ), "\n";
    debug "# BoThCaSe = ", join(" ", sort keys %BoThCaSe), "\n";
d505 1
a505 1
    debug "# Neoalpha = @@Neoalpha\n";
d517 4
a520 1
	{
d672 3
a674 1
    debug "# testing 115 with locale '$Locale'\n";
d697 7
a703 2
    debug "# testing 116 with locale '$Locale'\n";
    {
d718 3
a720 2
	print "# testing 116 failed for locale '$Locale' for characters @@f\n"
            if @@f;
d722 1
d727 1
a727 1
foreach (99..116) {
d743 1
a743 1
foreach (99..116) {
d768 1
a768 1
# Tell which locales ere okay.
d771 1
a771 1
    my @@s;
d775 1
a775 1
	foreach my $t (102..102) {
d779 1
d782 11
a792 2
    my $s = join(" ", @@s);
    $s =~ s/(.{50,60}) /$1\n#\t/g;
d794 11
a804 4
    warn
	"# The following locales\n#\n",
        "#\t", $s, "\n#\n",
	"# tested okay.\n#\n",
@


1.2
log
@perl5.005_03 (stock)
@
text
@d5 2
a6 1
    @@INC = '../lib';
d16 10
d37 3
a39 9
# 103 (the last test) may fail but that is okay.
# (It indicates something broken in the environment, not Perl)
# Therefore .. only until 102, not 103.
print "1..", ($have_setlocale ? 102 : 98), "\n";

use vars qw($a
	    $English $German $French $Spanish
	    @@C @@English @@German @@French @@Spanish
	    $Locale @@Locale %iLocale %UPPER %lower @@Neoalpha);
d41 1
a41 1
$a = 'abc %';
d55 1
a55 1
    local $^W;	# no warnings 'undef'
d81 3
a83 3
check_taint      10, sprintf('%e', 123.456);
check_taint      11, sprintf('%f', 123.456);
check_taint      12, sprintf('%g', 123.456);
d227 1
a227 1
#  unless setlocale() is missing (i.e. minitest).
d231 76
a306 1
sub getalnum {
d310 6
a315 2
sub locatelocale ($$@@) {
    my ($lcall, $alnum, @@try) = @@_;
d317 12
a328 8
    undef $$lcall;

    for (@@try) {
	local $^W = 0; # suppress "Subroutine LC_ALL redefined"
	if (setlocale(&LC_ALL, $_)) {
	    $$lcall = $_;
	    @@$alnum = &getalnum;
	    last;
d331 3
d335 1
a335 1
    @@$alnum = () unless (defined $$lcall);
d338 42
a379 1
# Find some default locale
d381 1
a381 1
locatelocale(\$Locale, \@@Locale, qw(C POSIX));
d383 1
a383 1
# Find some English locale
d385 1
a385 7
locatelocale(\$English, \@@English,
	     qw(en_US.ISO8859-1 en_GB.ISO8859-1
		en en_US en_UK en_IE en_CA en_AU en_NZ
		english english.iso88591
		american american.iso88591
		british british.iso88591
		));
d387 17
a403 1
# Find some German locale
d405 11
a415 4
locatelocale(\$German, \@@German,
	     qw(de_DE.ISO8859-1 de_AT.ISO8859-1 de_CH.ISO8859-1
		de de_DE de_AT de_CH
		german german.iso88591));
d417 25
a441 1
# Find some French locale
d443 3
a445 4
locatelocale(\$French, \@@French,
	     qw(fr_FR.ISO8859-1 fr_BE.ISO8859-1 fr_CA.ISO8859-1 fr_CH.ISO8859-1
		fr fr_FR fr_BE fr_CA fr_CH
		french french.iso88591));
d447 1
a447 1
# Find some Spanish locale
d449 9
a457 12
locatelocale(\$Spanish, \@@Spanish,
	     qw(es_AR.ISO8859-1 es_BO.ISO8859-1 es_CL.ISO8859-1
		es_CO.ISO8859-1 es_CR.ISO8859-1 es_EC.ISO8859-1
		es_ES.ISO8859-1 es_GT.ISO8859-1 es_MX.ISO8859-1
		es_NI.ISO8859-1 es_PA.ISO8859-1 es_PE.ISO8859-1
		es_PY.ISO8859-1 es_SV.ISO8859-1 es_UY.ISO8859-1 es_VE.ISO8859-1
		es es_AR es_BO es_CL
		es_CO es_CR es_EC
		es_ES es_GT es_MX
		es_NI es_PA es_PE
		es_PY es_SV es_UY es_VE
		spanish spanish.iso88591));
d459 1
a459 1
# Select the largest of the alpha(num)bets.
d461 1
a461 8
($Locale, @@Locale) = ($English, @@English)
    if (@@English > @@Locale);
($Locale, @@Locale) = ($German, @@German)
    if (@@German  > @@Locale);
($Locale, @@Locale) = ($French, @@French)
    if (@@French  > @@Locale);
($Locale, @@Locale) = ($Spanish, @@Spanish)
    if (@@Spanish > @@Locale);
d463 7
a469 4
{
    local $^W = 0;
    setlocale(&LC_ALL, $Locale);
}
d471 4
a474 1
# Sort it now that LC_ALL has been set.
d476 1
a476 1
@@Locale = sort @@Locale;
d478 2
a479 2
print "# Locale = $Locale\n";
print "# Alnum_ = @@Locale\n";
d481 1
a481 2
{
    my $i = 0;
d483 6
a488 4
    for (@@Locale) {
	$iLocale{$_} = $i++;
    }
}
d490 1
a490 1
# Sieve the uppercase and the lowercase.
d492 7
a498 6
for (@@Locale) {
    if (/[^\d_]/) { # skip digits and the _
	if (lc eq $_) {
	    $UPPER{$_} = uc;
	} else {
	    $lower{$_} = lc;
a499 2
    }
}
d501 56
a556 1
# Find the alphabets that are not alphabets in the default locale.
d558 4
a561 5
{
    no locale;
    
    for (keys %UPPER, keys %lower) {
	push(@@Neoalpha, $_) if (/\W/);
a562 1
}
d564 3
a566 1
@@Neoalpha = sort @@Neoalpha;
d568 3
a570 1
# Test \w.
d572 1
a572 2
{
    my $word = join('', @@Neoalpha);
d574 1
a574 1
    $word =~ /^(\w*)$/;
d576 3
a578 3
    print 'not ' if ($1 ne $word);
}
print "ok 99\n";
d580 1
a580 1
# Find places where the collation order differs from the default locale.
d582 1
a582 3
print "# testing 100\n";
{
    my (@@k, $i, $j, @@d);
d585 34
a618 1
	no locale;
d620 3
a622 1
	@@k = sort (keys %UPPER, keys %lower); 
d625 12
a636 5
    for ($i = 0; $i < @@k; $i++) {
	for ($j = $i + 1; $j < @@k; $j++) {
	    if ($iLocale{$k[$j]} < $iLocale{$k[$i]}) {
		push(@@d, [$k[$j], $k[$i]]);
	    }
d638 8
d648 3
a650 1
    # Cross-check those places.
d652 10
a661 8
    for (@@d) {
	($i, $j) = @@$_;
	if ($i gt $j) {
	    print "# failed 100 at:\n";
	    print "# i = $i, j = $j, i ",
	          $i le $j ? 'le' : 'gt', " j\n";
	    print 'not ';
	    last;
d663 3
a667 1
print "ok 100\n";
d669 1
a669 1
# Cross-check whole character set.
d671 8
a678 11
print "# testing 101\n";
for (map { chr } 0..255) {
    if (/\w/ and /\W/) { print 'not '; last }
    if (/\d/ and /\D/) { print 'not '; last }
    if (/\s/ and /\S/) { print 'not '; last }
    if (/\w/ and /\D/ and not /_/ and
	not (exists $UPPER{$_} or exists $lower{$_})) {
	print "# failed 101 at:\n";
	print "# ", ord($_), " '$_'\n";
	print 'not ';
	last;
d680 1
a681 1
print "ok 101\n";
d683 3
a685 1
# Test for read-onlys.
d687 22
a708 7
print "# testing 102\n";
{
    no locale;
    $a = "qwerty";
    {
	use locale;
	print "not " if $a cmp "qwerty";
a710 1
print "ok 102\n";
d712 1
a712 59
# This test must be the last one because its failure is not fatal.
# The @@Locale should be internally consistent.
# Thanks to Hallvard Furuseth <h.b.furuseth@@usit.uio.no>
# for inventing a way to test for ordering consistency
# without requiring any particular order.
# <jhi@@iki.fi>

print "# testing 103\n";
{
    my ($from, $to, $lesser, $greater, @@test, %test, $test, $yes, $no, $sign);

    for (0..9) {
	# Select a slice.
	$from = int(($_*@@Locale)/10);
	$to = $from + int(@@Locale/10);
        $to = $#Locale if ($to > $#Locale);
	$lesser  = join('', @@Locale[$from..$to]);
	# Select a slice one character on.
	$from++; $to++;
        $to = $#Locale if ($to > $#Locale);
	$greater = join('', @@Locale[$from..$to]);
	($yes, $no, $sign) = ($lesser lt $greater
				? ("    ", "not ", 1)
				: ("not ", "    ", -1));
	# all these tests should FAIL (return 0).
	@@test = 
	    (
	     $no.'    ($lesser  lt $greater)',  # 0
	     $no.'    ($lesser  le $greater)',  # 1
	     'not      ($lesser  ne $greater)', # 2
	     '         ($lesser  eq $greater)', # 3
	     $yes.'    ($lesser  ge $greater)', # 4
	     $yes.'    ($lesser  gt $greater)', # 5
	     $yes.'    ($greater lt $lesser )', # 6
	     $yes.'    ($greater le $lesser )', # 7
	     'not      ($greater ne $lesser )', # 8
	     '         ($greater eq $lesser )', # 9
	     $no.'     ($greater ge $lesser )', # 10
	     $no.'     ($greater gt $lesser )', # 11
	     'not (($lesser cmp $greater) == -$sign)' # 12
	     );
	@@test{@@test} = 0 x @@test;
	$test = 0;
	for my $ti (@@test) { $test{$ti} = eval $ti ; $test ||= $test{$ti} }
	if ($test) {
	    print "# failed 103 at:\n";
	    print "# lesser  = '$lesser'\n";
	    print "# greater = '$greater'\n";
	    print "# lesser cmp greater = ", $lesser cmp $greater, "\n";
	    print "# greater cmp lesser = ", $greater cmp $lesser, "\n";
	    print "# (greater) from = $from, to = $to\n";
	    for my $ti (@@test) {
		printf("# %-40s %-4s", $ti,
		       $test{$ti} ? 'FAIL' : 'ok');
		if ($ti =~ /\(\.*(\$.+ +cmp +\$[^\)]+)\.*\)/) {
		    printf("(%s == %4d)", $1, eval $1);
	        }
		print "\n";
	    }
d714 7
a720 2
	    warn "The locale definition on your system may have errors.\n";
	    last;
d722 1
d724 8
@


1.1
log
@perl 5.004_04
@
text
@d22 7
d293 1
a293 1
    if (length(@@English) > length(@@Locale));
d295 1
a295 1
    if (length(@@German)  > length(@@Locale));
d297 1
a297 1
    if (length(@@French)  > length(@@Locale));
d299 1
a299 4
    if (length(@@Spanish) > length(@@Locale));

print "# Locale = $Locale\n";
print "# Alnum_ = @@Locale\n";
d306 7
d410 1
d426 1
a426 1
# ++$jhi;#@@iki.fi
@


1.1.1.1
log
@perl5.005_03
@
text
@a21 7
# Visual C's CRT goes silly on strings of the form "en_US.ISO8859-1"
# and mingw32 uses said silly CRT
$have_setlocale = 0 if $^O eq 'MSWin32' && $Config{cc} =~ /^(cl|gcc)/i;

# 103 (the last test) may fail but that is okay.
# (It indicates something broken in the environment, not Perl)
# Therefore .. only until 102, not 103.
d286 1
a286 1
    if (@@English > @@Locale);
d288 1
a288 1
    if (@@German  > @@Locale);
d290 1
a290 1
    if (@@French  > @@Locale);
d292 4
a295 1
    if (@@Spanish > @@Locale);
a301 7
# Sort it now that LC_ALL has been set.

@@Locale = sort @@Locale;

print "# Locale = $Locale\n";
print "# Alnum_ = @@Locale\n";

a398 1
print "# testing 102\n";
d414 1
a414 1
# <jhi@@iki.fi>
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d5 1
a5 2
    unshift @@INC, '../lib';
    unshift @@INC, '.';
a14 10
my $debug = 1;

sub debug {
    print @@_ if $debug;
}

sub debugf {
    printf @@_ if $debug;
}

d26 9
a34 3
print "1..", ($have_setlocale ? 116 : 98), "\n";

use vars qw(&LC_ALL);
d36 1
a36 1
my $a = 'abc %';
d50 1
a50 1
    no warnings 'uninitialized' ;
d76 3
a78 3
check_taint_not  10, sprintf('%e', 123.456);
check_taint_not  11, sprintf('%f', 123.456);
check_taint_not  12, sprintf('%g', 123.456);
d222 1
a222 1
# unless setlocale() is missing (i.e. minitest).
d226 1
a226 76
# Find locales.

debug "# Scanning for locales...\n";

# Note that it's okay that some languages have their native names
# capitalized here even though that's not "right".  They are lowercased
# anyway later during the scanning process (and besides, some clueless
# vendor might have them capitalized errorneously anyway).

my $locales = <<EOF;
Afrikaans:af:za:1 15
Arabic:ar:dz eg sa:6 arabic8
Brezhoneg Breton:br:fr:1 15
Bulgarski Bulgarian:bg:bg:5
Chinese:zh:cn tw:cn.EUC eucCN eucTW euc.CN euc.TW GB2312 tw.EUC
Hrvatski Croatian:hr:hr:2
Cymraeg Welsh:cy:cy:1 14 15
Czech:cs:cz:2
Dansk Danish:dk:da:1 15
Nederlands Dutch:nl:be nl:1 15
English American British:en:au ca gb ie nz us uk:1 15 cp850
Esperanto:eo:eo:3
Eesti Estonian:et:ee:4 6 13
Suomi Finnish:fi:fi:1 15
Flamish::fl:1 15
Deutsch German:de:at be ch de lu:1 15
Euskaraz Basque:eu:es fr:1 15
Galego Galician:gl:es:1 15
Ellada Greek:el:gr:7 g8
Frysk:fy:nl:1 15
Greenlandic:kl:gl:4 6
Hebrew:iw:il:8 hebrew8
Hungarian:hu:hu:2
Indonesian:in:id:1 15
Gaeilge Irish:ga:IE:1 14 15
Italiano Italian:it:ch it:1 15
Nihongo Japanese:ja:jp:euc eucJP jp.EUC sjis
Korean:ko:kr:
Latine Latin:la:va:1 15
Latvian:lv:lv:4 6 13
Lithuanian:lt:lt:4 6 13
Macedonian:mk:mk:1 15
Maltese:mt:mt:3
Norsk Norwegian:no:no:1 15
Occitan:oc:es:1 15
Polski Polish:pl:pl:2
Rumanian:ro:ro:2
Russki Russian:ru:ru su ua:5 koi8 koi8r koi8u cp1251
Serbski Serbian:sr:yu:5
Slovak:sk:sk:2
Slovene Slovenian:sl:si:2
Sqhip Albanian:sq:sq:1 15
Svenska Swedish:sv:fi se:1 15
Thai:th:th:11 tis620
Turkish:tr:tr:9 turkish8
Yiddish:::1 15
EOF

if ($^O eq 'os390') {
    $locales =~ s/Svenska Swedish:sv:fi se:1 15\n//;
    $locales =~ s/Thai:th:th:11 tis620\n//;
}

sub in_utf8 () { $^H & 0x08 }

if (in_utf8) {
    require "pragma/locale/utf8";
} else {
    require "pragma/locale/latin1";
}

my @@Locale;
my $Locale;
my @@Alnum_;

sub getalnum_ {
d230 4
a233 6
sub trylocale {
    my $locale = shift;
    if (setlocale(LC_ALL, $locale)) {
	push @@Locale, $locale;
    }
}
d235 6
a240 12
sub decode_encodings {
    my @@enc;

    foreach (split(/ /, shift)) {
	if (/^(\d+)$/) {
	    push @@enc, "ISO8859-$1";
	    push @@enc, "iso8859$1";	# HP
	    if ($1 eq '1') {
		 push @@enc, "roman8";	# HP
	    }
	} else {
	    push @@enc, $_;
a242 3
    if ($^O eq 'os390') {
	push @@enc, qw(IBM-037 IBM-819 IBM-1047);
    }
d244 1
a244 1
    return @@enc;
d247 1
a247 42
trylocale("C");
trylocale("POSIX");
foreach (0..15) {
    trylocale("ISO8859-$_");
    trylocale("iso8859$_");
    trylocale("iso8859-$_");
    trylocale("iso_8859_$_");
    trylocale("isolatin$_");
    trylocale("isolatin-$_");
    trylocale("iso_latin_$_");
}

foreach my $locale (split(/\n/, $locales)) {
    my ($locale_name, $language_codes, $country_codes, $encodings) =
	split(/:/, $locale);
    my @@enc = decode_encodings($encodings);
    foreach my $loc (split(/ /, $locale_name)) {
	trylocale($loc);
	foreach my $enc (@@enc) {
	    trylocale("$loc.$enc");
	}
	$loc = lc $loc;
	foreach my $enc (@@enc) {
	    trylocale("$loc.$enc");
	}
    }
    foreach my $lang (split(/ /, $language_codes)) {
	trylocale($lang);
	foreach my $country (split(/ /, $country_codes)) {
	    my $lc = "${lang}_${country}";
	    trylocale($lc);
	    foreach my $enc (@@enc) {
		trylocale("$lc.$enc");
	    }
	    my $lC = "${lang}_\U${country}";
	    trylocale($lC);
	    foreach my $enc (@@enc) {
		trylocale("$lC.$enc");
	    }
	}
    }
}
d249 1
a249 1
setlocale(LC_ALL, "C");
d251 1
a251 1
@@Locale = sort @@Locale;
d253 7
a259 1
debug "# Locales = @@Locale\n";
d261 1
a261 17
my %Problem;
my %Okay;
my %Testing;
my @@Neoalpha;
my %Neoalpha;

sub tryneoalpha {
    my ($Locale, $i, $test) = @@_;
    debug "# testing $i with locale '$Locale'\n"
	unless $Testing{$i}{$Locale}++;
    unless ($test) {
	$Problem{$i}{$Locale} = 1;
	debug "# failed $i with locale '$Locale'\n";
    } else {
	push @@{$Okay{$i}}, $Locale;
    }
}
d263 4
a266 11
foreach $Locale (@@Locale) {
    debug "# Locale = $Locale\n";
    @@Alnum_ = getalnum_();
    debug "# \\w = @@Alnum_\n";

    unless (setlocale(LC_ALL, $Locale)) {
	foreach (99..103) {
	    $Problem{$_}{$Locale} = -1;
	}
	next;
    }
d268 1
a268 25
    # Sieve the uppercase and the lowercase.
    
    my %UPPER = ();
    my %lower = ();
    my %BoThCaSe = ();
    for (@@Alnum_) {
	if (/[^\d_]/) { # skip digits and the _
	    if (uc($_) eq $_) {
		$UPPER{$_} = $_;
	    }
	    if (lc($_) eq $_) {
		$lower{$_} = $_;
	    }
	}
    }
    foreach (keys %UPPER) {
	$BoThCaSe{$_}++ if exists $lower{$_};
    }
    foreach (keys %lower) {
	$BoThCaSe{$_}++ if exists $UPPER{$_};
    }
    foreach (keys %BoThCaSe) {
	delete $UPPER{$_};
	delete $lower{$_};
    }
d270 4
a273 3
    debug "# UPPER    = ", join(" ", sort keys %UPPER   ), "\n";
    debug "# lower    = ", join(" ", sort keys %lower   ), "\n";
    debug "# BoThCaSe = ", join(" ", sort keys %BoThCaSe), "\n";
d275 1
a275 1
    # Find the alphabets that are not alphabets in the default locale.
d277 12
a288 9
    {
	no locale;
    
	@@Neoalpha = ();
	for (keys %UPPER, keys %lower) {
	    push(@@Neoalpha, $_) if (/\W/);
	    $Neoalpha{$_} = $_;
	}
    }
d290 1
a290 1
    @@Neoalpha = sort @@Neoalpha;
d292 8
a299 1
    debug "# Neoalpha = @@Neoalpha\n";
d301 4
a304 7
    if (@@Neoalpha == 0) {
	# If we have no Neoalphas the remaining tests are no-ops.
	debug "# no Neoalpha, skipping tests 99..102 for locale '$Locale'\n";
	foreach (99..102) {
	    push @@{$Okay{$_}}, $Locale;
	}
    } else {
d306 1
a306 4
	# Test \w.
    
	{
	    my $word = join('', @@Neoalpha);
d308 1
a308 1
	    $word =~ /^(\w+)$/;
d310 2
a311 2
	    tryneoalpha($Locale, 99, $1 eq $word);
	}
d313 2
a314 1
	# Cross-check the whole 8-bit character set.
d316 4
a319 6
	for (map { chr } 0..255) {
	    tryneoalpha($Locale, 100,
			(/\w/ xor /\W/) ||
			(/\d/ xor /\D/) ||
			(/\s/ xor /\S/));
	}
d321 1
a321 1
	# Test for read-only scalars' locale vs non-locale comparisons.
d323 6
a328 7
	{
	    no locale;
	    $a = "qwerty";
	    {
		use locale;
		tryneoalpha($Locale, 101, ($a cmp "qwerty") == 0);
	    }
d330 2
d333 1
a333 56
	{
	    my ($from, $to, $lesser, $greater,
		@@test, %test, $test, $yes, $no, $sign);

	    for (0..9) {
		# Select a slice.
		$from = int(($_*@@Alnum_)/10);
		$to = $from + int(@@Alnum_/10);
		$to = $#Alnum_ if ($to > $#Alnum_);
		$lesser  = join('', @@Alnum_[$from..$to]);
		# Select a slice one character on.
		$from++; $to++;
		$to = $#Alnum_ if ($to > $#Alnum_);
		$greater = join('', @@Alnum_[$from..$to]);
		($yes, $no, $sign) = ($lesser lt $greater
				      ? ("    ", "not ", 1)
				      : ("not ", "    ", -1));
		# all these tests should FAIL (return 0).
		# Exact lt or gt cannot be tested because
		# in some locales, say, eacute and E may test equal.
		@@test = 
		    (
		     $no.'    ($lesser  le $greater)',  # 1
		     'not      ($lesser  ne $greater)', # 2
		     '         ($lesser  eq $greater)', # 3
		     $yes.'    ($lesser  ge $greater)', # 4
		     $yes.'    ($lesser  ge $greater)', # 5
		     $yes.'    ($greater le $lesser )', # 7
		     'not      ($greater ne $lesser )', # 8
		     '         ($greater eq $lesser )', # 9
		     $no.'     ($greater ge $lesser )', # 10
		     'not (($lesser cmp $greater) == -$sign)' # 12
		     );
		@@test{@@test} = 0 x @@test;
		$test = 0;
		for my $ti (@@test) {
		    $test{$ti} = eval $ti;
		    $test ||= $test{$ti}
		}
		tryneoalpha($Locale, 102, $test == 0);
		if ($test) {
		    debug "# lesser  = '$lesser'\n";
		    debug "# greater = '$greater'\n";
		    debug "# lesser cmp greater = ",
		          $lesser cmp $greater, "\n";
		    debug "# greater cmp lesser = ",
		          $greater cmp $lesser, "\n";
		    debug "# (greater) from = $from, to = $to\n";
		    for my $ti (@@test) {
			debugf("# %-40s %-4s", $ti,
			       $test{$ti} ? 'FAIL' : 'ok');
			if ($ti =~ /\(\.*(\$.+ +cmp +\$[^\)]+)\.*\)/) {
			    debugf("(%s == %4d)", $1, eval $1);
			}
			debug "\n#";
		    }
d335 5
a339 4
		    last;
		}
	    }
	}
d341 1
d343 1
a343 1
    use locale;
d345 1
a345 1
    my ($x, $y) = (1.23, 1.23);
d347 2
a348 3
    my $a = "$x";
    printf ''; # printf used to reset locale to "C"
    my $b = "$y";
d350 1
a350 1
    debug "# 103..107: a = $a, b = $b, Locale = $Locale\n";
d352 3
a354 1
    tryneoalpha($Locale, 103, $a eq $b);
d356 1
a356 3
    my $c = "$x";
    my $z = sprintf ''; # sprintf used to reset locale to "C"
    my $d = "$y";
d358 3
a360 3
    debug "# 104..107: c = $c, d = $d, Locale = $Locale\n";

    tryneoalpha($Locale, 104, $c eq $d); 
d363 1
a363 28
	use warnings;
	my $w = 0;
	local $SIG{__WARN__} = sub { $w++ };

	# the == (among other ops) used to warn for locales
	# that had something else than "." as the radix character

	tryneoalpha($Locale, 105, $c == 1.23);

	tryneoalpha($Locale, 106, $c == $x);

	tryneoalpha($Locale, 107, $c == $d);

	{
	    no locale;
	
	    my $e = "$x";

	    debug "# 108..110: e = $e, Locale = $Locale\n";

	    tryneoalpha($Locale, 108, $e == 1.23);

	    tryneoalpha($Locale, 109, $e == $x);
	    
	    tryneoalpha($Locale, 110, $e == $c);
	}
	
	tryneoalpha($Locale, 111, $w == 0);
d365 1
a365 9
	my $f = "1.23";

	debug "# 112..114: f = $f, locale = $Locale\n";

	tryneoalpha($Locale, 112, $f == 1.23);

	tryneoalpha($Locale, 113, $f == $x);
	
	tryneoalpha($Locale, 114, $f == $c);
d368 5
a372 12
    debug "# testing 115 with locale '$Locale'\n";
    {
	use locale;

	sub lcA {
	    my $lc0 = lc $_[0];
	    my $lc1 = lc $_[1];
	    return $lc0 cmp $lc1;
	}

        sub lcB {
	    return lc($_[0]) cmp lc($_[1]);
a373 8

        my $x = "ab";
        my $y = "aa";
        my $z = "AB";

        tryneoalpha($Locale, 115,
		    lcA($x, $y) == 1 && lcB($x, $y) == 1 ||
		    lcA($x, $z) == 0 && lcB($x, $z) == 0);
d376 1
a376 3
    debug "# testing 116 with locale '$Locale'\n";
    {
	use locale;
d378 8
a385 10
	my @@f = ();
	foreach my $x (keys %UPPER) {
	    my $y = lc $x;
	    next unless uc $y eq $x;
	    push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
	}
	foreach my $x (keys %lower) {
	    my $y = uc $x;
	    next unless lc $y eq $x;
	    push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
a386 3
	tryneoalpha($Locale, 116, @@f == 0);
	print "# testing 116 failed for locale '$Locale' for characters @@f\n"
            if @@f;
d389 1
d391 1
a391 1
# Recount the errors.
d393 11
a403 8
foreach (99..116) {
    if ($Problem{$_} || !defined $Okay{$_} || !@@{$Okay{$_}}) {
	if ($_ == 102) {
	    print "# The failure of test 102 is not necessarily fatal.\n";
	    print "# It usually indicates a problem in the enviroment,\n";
	    print "# not in Perl itself.\n";
	}
	print "not ";
a404 1
    print "ok $_\n";
d406 1
d408 1
a408 1
# Give final advice.
d410 7
a416 24
my $didwarn = 0;

foreach (99..116) {
    if ($Problem{$_}) {
	my @@f = sort keys %{ $Problem{$_} };
	my $f = join(" ", @@f);
	$f =~ s/(.{50,60}) /$1\n#\t/g;
	print
	    "#\n",
            "# The locale ", (@@f == 1 ? "definition" : "definitions"), "\n#\n",
	    "#\t", $f, "\n#\n",
	    "# on your system may have errors because the locale test $_\n",
            "# failed in ", (@@f == 1 ? "that locale" : "those locales"),
            ".\n";
	print <<EOW;
#
# If your users are not using these locales you are safe for the moment,
# but please report this failure first to perlbug\@@perl.com using the
# perlbug script (as described in the INSTALL file) so that the exact
# details of the failures can be sorted out first and then your operating
# system supplier can be alerted about these anomalies.
#
EOW
	$didwarn = 1;
d419 1
d421 59
a479 1
# Tell which locales ere okay.
d481 2
a482 7
if ($didwarn) {
    my @@s;
    
    foreach my $l (@@Locale) {
	my $p = 0;
	foreach my $t (102..102) {
	    $p++ if $Problem{$t}{$l};
a483 1
	push @@s, $l if $p == 0;
a484 8
    
    my $s = join(" ", @@s);
    $s =~ s/(.{50,60}) /$1\n#\t/g;

    warn
	"# The following locales\n#\n",
        "#\t", $s, "\n#\n",
	"# tested okay.\n#\n",
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
    @@INC = '../lib';
a17 7
use Dumpvalue;

my $dumper = Dumpvalue->new(
                            tick => qq{"},
                            quoteHighBit => 0,
                            unctrl => "quote"
                           );
d19 1
a19 4
  return unless $debug;
  my($mess) = join "", @@_;
  chop $mess;
  print $dumper->stringify($mess,1), "\n";
d37 1
a37 3
my $last = $have_setlocale ? 116 : 98;

print "1..$last\n";
d245 1
a245 1
Chinese:zh:cn tw:cn.EUC eucCN eucTW euc.CN euc.TW Big5 GB2312 tw.EUC
d251 1
a251 1
English American British:en:au ca gb ie nz us uk zw:1 15 cp850
d274 1
a274 2
Moldovan:mo:mo:2
Norsk Norwegian:no no\@@nynorsk:no:1 15
d278 1
a278 1
Russki Russian:ru:ru su ua:5 koi8 koi8r KOI8-R koi8u cp1251 cp866
d286 1
a286 1
Yiddish:yi::1 15
a289 1
    # These cause heartburn.  Broken locales?
a328 1
   	    push @@enc, "$_.UTF-8";
d350 19
a368 34
# Sanitize the environment so that we can run the external 'locale'
# program without the taint mode getting grumpy.

# $ENV{PATH} is special in VMS.
delete $ENV{PATH} if $^O ne 'VMS' or $Config{d_setenv};

# Other subversive stuff.
delete @@ENV{qw(IFS CDPATH ENV BASH_ENV)};

if (-x "/usr/bin/locale" && open(LOCALES, "/usr/bin/locale -a 2>/dev/null|")) {
    while (<LOCALES>) {
        chomp;
	trylocale($_);
    }
    close(LOCALES);
} elsif ($^O eq 'VMS' && defined($ENV{'SYS$I18N_LOCALE'}) && -d 'SYS$I18N_LOCALE') {
# The SYS$I18N_LOCALE logical name search list was not present on 
# VAX VMS V5.5-12, but was on AXP && VAX VMS V6.2 as well as later versions.
    opendir(LOCALES, "SYS\$I18N_LOCALE:");
    while ($_ = readdir(LOCALES)) {
        chomp;
        trylocale($_);
    }
    close(LOCALES);
} else {

    # This is going to be slow.

    foreach my $locale (split(/\n/, $locales)) {
	my ($locale_name, $language_codes, $country_codes, $encodings) =
	    split(/:/, $locale);
	my @@enc = decode_encodings($encodings);
	foreach my $loc (split(/ /, $locale_name)) {
	    trylocale($loc);
d370 1
a370 1
		trylocale("$loc.$enc");
d372 2
a373 1
	    $loc = lc $loc;
d375 1
a375 16
		trylocale("$loc.$enc");
	    }
	}
	foreach my $lang (split(/ /, $language_codes)) {
	    trylocale($lang);
	    foreach my $country (split(/ /, $country_codes)) {
		my $lc = "${lang}_${country}";
		trylocale($lc);
		foreach my $enc (@@enc) {
		    trylocale("$lc.$enc");
		}
		my $lC = "${lang}_\U${country}";
		trylocale($lC);
		foreach my $enc (@@enc) {
		    trylocale("$lC.$enc");
		}
a382 2
sub utf8locale { $_[0] =~ /utf-?8/i }

d395 2
d408 1
a408 1
    debug "# w = ", join("",@@Alnum_), "\n";
d443 3
a445 3
    debug "# UPPER    = ", join("", sort keys %UPPER   ), "\n";
    debug "# lower    = ", join("", sort keys %lower   ), "\n";
    debug "# BoThCaSe = ", join("", sort keys %BoThCaSe), "\n";
d461 1
a461 1
    debug "# Neoalpha = ", join("",@@Neoalpha), "\n";
d473 1
a473 4
	if (utf8locale($Locale)) {
	    # Until the polymorphic regexen arrive.
	    debug "# skipping UTF-8 locale '$Locale'\n";
	} else {
d625 1
a625 3
    # Does taking lc separately differ from taking
    # the lc "in-line"?  (This was the bug 19990704.002, change #3568.)
    # The bug was in the caching of the 'o'-magic.
d648 2
a649 7
    # Does lc of an UPPER (if different from the UPPER) match
    # case-insensitively the UPPER, and does the UPPER match
    # case-insensitively the lc of the UPPER.  And vice versa.
    if (utf8locale($Locale)) {
        # Until the polymorphic regexen arrive.
        debug "# skipping UTF-8 locale '$Locale'\n";
    } else {
d664 2
a665 3
        if (@@f) {
	    print "# failed 116 locale '$Locale' characters @@f\n"
        }
a666 1

d671 1
a671 1
foreach (99..$last) {
d687 1
a687 1
foreach (99..$last) {
d712 1
a712 1
# Tell which locales were okay and which were not.
d715 1
a715 1
    my (@@s, @@F);
d719 1
a719 1
	foreach my $t (102..$last) {
a722 1
      push @@F, $l unless $p == 0;
d725 2
a726 11
    if (@@s) {
        my $s = join(" ", @@s);
        $s =~ s/(.{50,60}) /$1\n#\t/g;

        warn
    	    "# The following locales\n#\n",
            "#\t", $s, "\n#\n",
	    "# tested okay.\n#\n",
    } else {
        warn "# None of your locales were fully okay.\n";
    }
d728 4
a731 11
    if (@@F) {
        my $F = join(" ", @@F);
        $F =~ s/(.{50,60}) /$1\n#\t/g;

        warn
          "# The following locales\n#\n",
            "#\t", $F, "\n#\n",
          "# had problems.\n#\n",
    } else {
        warn "# None of your locales were broken.\n";
    }
@


