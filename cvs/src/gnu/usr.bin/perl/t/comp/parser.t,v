head	1.3;
access;
symbols
	OPENBSD_6_1:1.3.0.4
	OPENBSD_6_1_BASE:1.3
	OPENBSD_6_0:1.2.0.4
	OPENBSD_6_0_BASE:1.2
	OPENBSD_5_9:1.1.1.10.0.2
	OPENBSD_5_9_BASE:1.1.1.10
	OPENBSD_5_8:1.1.1.10.0.4
	OPENBSD_5_8_BASE:1.1.1.10
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.1.1.9.0.2
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.4
	OPENBSD_5_6_BASE:1.1.1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.8
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.4
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.3
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	cxJ08BvJA9Pt2PTM;

1.2
date	2016.07.03.01.08.04;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	GzHqjSTnBjdF7Wcw;

1.1
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.21.13.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.48.31;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.49.41;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	1.1.1.10;
commitid	B31cAbBIXiCqnL97;

1.1.1.10
date	2015.04.25.19.10.46;	author afresh1;	state Exp;
branches;
next	;
commitid	Wpcs5S8qILgEZC7F;


desc
@@


1.3
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# Checks if the parser behaves correctly in edge cases
# (including weird syntax errors)

BEGIN {
    @@INC = qw(. ../lib);
    chdir 't' if -d 't';
}

print "1..173\n";

sub failed {
    my ($got, $expected, $name) = @@_;

    print "not ok $test - $name\n";
    my @@caller = caller(1);
    print "# Failed test at $caller[1] line $caller[2]\n";
    if (defined $got) {
	print "# Got '$got'\n";
    } else {
	print "# Got undef\n";
    }
    print "# Expected $expected\n";
    return;
}

sub like {
    my ($got, $pattern, $name) = @@_;
    $test = $test + 1;
    if (defined $got && $got =~ $pattern) {
	print "ok $test - $name\n";
	# Principle of least surprise - maintain the expected interface, even
	# though we aren't using it here (yet).
	return 1;
    }
    failed($got, $pattern, $name);
}

sub is {
    my ($got, $expect, $name) = @@_;
    $test = $test + 1;
    if (defined $expect) {
	if (defined $got && $got eq $expect) {
	    print "ok $test - $name\n";
	    return 1;
	}
	failed($got, "'$expect'", $name);
    } else {
	if (!defined $got) {
	    print "ok $test - $name\n";
	    return 1;
	}
	failed($got, 'undef', $name);
    }
}

eval '%@@x=0;';
like( $@@, qr/^Can't modify hash dereference in repeat \(x\)/, '%@@x=0' );

# Bug 20010422.005
eval q{{s//${}/; //}};
like( $@@, qr/syntax error/, 'syntax error, used to dump core' );

# Bug 20010528.007
eval q/"\x{"/;
like( $@@, qr/^Missing right brace on \\x/,
    'syntax error in string, used to dump core' );

eval q/"\N{"/;
like( $@@, qr/^Missing right brace on \\N/,
    'syntax error in string with incomplete \N' );
eval q/"\Nfoo"/;
like( $@@, qr/^Missing braces on \\N/,
    'syntax error in string with incomplete \N' );

eval q/"\o{"/;
like( $@@, qr/^Missing right brace on \\o/,
    'syntax error in string with incomplete \o' );
eval q/"\ofoo"/;
like( $@@, qr/^Missing braces on \\o/,
    'syntax error in string with incomplete \o' );

eval "a.b.c.d.e.f;sub";
like( $@@, qr/^Illegal declaration of anonymous subroutine/,
    'found by Markov chain stress testing' );

# Bug 20010831.001
eval '($a, b) = (1, 2);';
like( $@@, qr/^Can't modify constant item in list assignment/,
    'bareword in list assignment' );

eval 'tie FOO, "Foo";';
like( $@@, qr/^Can't modify constant item in tie /,
    'tying a bareword causes a segfault in 5.6.1' );

eval 'undef foo';
like( $@@, qr/^Can't modify constant item in undef operator /,
    'undefing constant causes a segfault in 5.6.1 [ID 20010906.019]' );

eval 'read($bla, FILE, 1);';
like( $@@, qr/^Can't modify constant item in read /,
    'read($var, FILE, 1) segfaults on 5.6.1 [ID 20011025.054]' );

# This used to dump core (bug #17920)
eval q{ sub { sub { f1(f2();); my($a,$b,$c) } } };
like( $@@, qr/error/, 'lexical block discarded by yacc' );

# bug #18573, used to corrupt memory
eval q{ "\c" };
like( $@@, qr/^Missing control char name in \\c/, q("\c" string) );

eval q{ qq(foo$) };
like( $@@, qr/Final \$ should be \\\$ or \$name/, q($ at end of "" string) );

# two tests for memory corruption problems in the said variables
# (used to dump core or produce strange results)

is( "\Q\Q\Q\Q\Q\Q\Q\Q\Q\Q\Q\Q\Qa", "a", "PL_lex_casestack" );

eval {
{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}
};
is( $@@, '', 'PL_lex_brackstack' );

{
    # tests for bug #20716
    undef $a;
    undef @@b;
    my $a="A";
    is("${a}{", "A{", "interpolation, qq//");
    is("${a}[", "A[", "interpolation, qq//");
    my @@b=("B");
    is("@@{b}{", "B{", "interpolation, qq//");
    is(qr/${a}\{/, '(?^:A\{)', "interpolation, qr//");
    my $c = "A{";
    $c =~ /${a}\{/;
    is($&, 'A{', "interpolation, m//");
    $c =~ s/${a}\{/foo/;
    is($c, 'foo', "interpolation, s/...//");
    $c =~ s/foo/${a}{/;
    is($c, 'A{', "interpolation, s//.../");
    is(<<"${a}{", "A{ A[ B{\n", "interpolation, here doc");
${a}{ ${a}[ @@{b}{
${a}{
}

eval q{ sub a(;; &) { } a { } };
is($@@, '', "';&' sub prototype confuses the lexer");

# Bug #21575
# ensure that the second print statement works, by playing a bit
# with the test output.
my %data = ( foo => "\n" );
print "#";
print(
$data{foo});
$test = $test + 1;
print "ok $test\n";

# Bug #21875
# { q.* => ... } should be interpreted as hash, not block

foreach my $line (split /\n/, <<'EOF')
1 { foo => 'bar' }
1 { qoo => 'bar' }
1 { q   => 'bar' }
1 { qq  => 'bar' }
0 { q,'bar', }
0 { q=bar= }
0 { qq=bar= }
1 { q=bar= => 'bar' }
EOF
{
    my ($expect, $eval) = split / /, $line, 2;
    my $result = eval $eval;
    is($@@, '', "eval $eval");
    is(ref $result, $expect ? 'HASH' : '', $eval);
}

# Bug #24212
{
    local $SIG{__WARN__} = sub { }; # silence mandatory warning
    eval q{ my $x = -F 1; };
    like( $@@, qr/(?i:syntax|parse) error .* near "F 1"/, "unknown filetest operators" );
    is(
        eval q{ sub F { 42 } -F 1 },
	'-42',
	'-F calls the F function'
    );
}

# Bug #24762
{
    eval q{ *foo{CODE} ? 1 : 0 };
    is( $@@, '', "glob subscript in conditional" );
}

# Bug #25824
{
    eval q{ sub f { @@a=@@b=@@c;  {use} } };
    like( $@@, qr/syntax error/, "use without body" );
}

# [perl #2738] perl segfautls on input
{
    eval q{ sub _ <> {} };
    like($@@, qr/Illegal declaration of subroutine main::_/, "readline operator as prototype");

    eval q{ $s = sub <> {} };
    like($@@, qr/Illegal declaration of anonymous subroutine/, "readline operator as prototype");

    eval q{ sub _ __FILE__ {} };
    like($@@, qr/Illegal declaration of subroutine main::_/, "__FILE__ as prototype");
}

# tests for "Bad name"
eval q{ foo::$bar };
like( $@@, qr/Bad name after foo::/, 'Bad name after foo::' );
eval q{ foo''bar };
like( $@@, qr/Bad name after foo'/, 'Bad name after foo\'' );

# test for ?: context error
eval q{($a ? $x : ($y)) = 5};
like( $@@, qr/Assignment to both a list and a scalar/, 'Assignment to both a list and a scalar' );

eval q{ s/x/#/e };
is( $@@, '', 'comments in s///e' );

# these five used to coredump because the op cleanup on parse error could
# be to the wrong pad

eval q[
    sub { our $a= 1;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;
	    sub { my $z
];

like($@@, qr/Missing right curly/, 'nested sub syntax error' );

eval q[
    sub { my ($a,$b,$c,$d,$e,$f,$g,$h,$i,$j,$k,$l,$m,$n,$o,$p,$q,$r,$s,$r);
	    sub { my $z
];
like($@@, qr/Missing right curly/, 'nested sub syntax error 2' );

eval q[
    sub { our $a= 1;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;
	    use DieDieDie;
];

like($@@, qr/Can't locate DieDieDie.pm/, 'croak cleanup' );

eval q[
    sub { my ($a,$b,$c,$d,$e,$f,$g,$h,$i,$j,$k,$l,$m,$n,$o,$p,$q,$r,$s,$r);
	    use DieDieDie;
];

like($@@, qr/Can't locate DieDieDie.pm/, 'croak cleanup 2' );


eval q[
    my @@a;
    my ($a,$b,$c,$d,$e,$f,$g,$h,$i,$j,$k,$l,$m,$n,$o,$p,$q,$r,$s,$r);
    @@a =~ s/a/b/; # compile-time error
    use DieDieDie;
];

like($@@, qr/Can't modify/, 'croak cleanup 3' );

# these might leak, or have duplicate frees, depending on the bugginess of
# the parser stack 'fail in reduce' cleanup code. They're here mainly as
# something to be run under valgrind, with PERL_DESTRUCT_LEVEL=1.

eval q[ BEGIN { } ] for 1..10;
is($@@, "", 'BEGIN 1' );

eval q[ BEGIN { my $x; $x = 1 } ] for 1..10;
is($@@, "", 'BEGIN 2' );

eval q[ BEGIN { \&foo1 } ] for 1..10;
is($@@, "", 'BEGIN 3' );

eval q[ sub foo2 { } ] for 1..10;
is($@@, "", 'BEGIN 4' );

eval q[ sub foo3 { my $x; $x=1 } ] for 1..10;
is($@@, "", 'BEGIN 5' );

eval q[ BEGIN { die } ] for 1..10;
like($@@, qr/BEGIN failed--compilation aborted/, 'BEGIN 6' );

eval q[ BEGIN {\&foo4; die } ] for 1..10;
like($@@, qr/BEGIN failed--compilation aborted/, 'BEGIN 7' );

{
  # RT #70934
  # check both the specific case in the ticket, and a few other paths into
  # S_scan_ident()
  # simplify long ids
  my $x100 = "x" x 256;
  my $xFE = "x" x 254;
  my $xFD = "x" x 253;
  my $xFC = "x" x 252;
  my $xFB = "x" x 251;

  eval qq[ \$#$xFB ];
  is($@@, "", "251 character \$# sigil ident ok");
  eval qq[ \$#$xFC ];
  like($@@, qr/Identifier too long/, "too long id in \$# sigil ctx");

  eval qq[ \$$xFB ];
  is($@@, "", "251 character \$ sigil ident ok");
  eval qq[ \$$xFC ];
  like($@@, qr/Identifier too long/, "too long id in \$ sigil ctx");

  eval qq[ %$xFB ];
  is($@@, "", "251 character % sigil ident ok");
  eval qq[ %$xFC ];
  like($@@, qr/Identifier too long/, "too long id in % sigil ctx");

  eval qq[ \\&$xFB ]; # take a ref since I don't want to call it
  is($@@, "", "251 character & sigil ident ok");
  eval qq[ \\&$xFC ];
  like($@@, qr/Identifier too long/, "too long id in & sigil ctx");

  eval qq[ *$xFC ];
  is($@@, "", "252 character glob ident ok");
  eval qq[ *$xFD ];
  like($@@, qr/Identifier too long/, "too long id in glob ctx");

  eval qq[ for $xFC ];
  like($@@, qr/Missing \$ on loop variable/,
       "252 char id ok, but a different error");
  eval qq[ for $xFD; ];
  like($@@, qr/Identifier too long/, "too long id in for ctx");

  # the specific case from the ticket
  my $x = "x" x 257;
  eval qq[ for $x ];
  like($@@, qr/Identifier too long/, "too long id ticket case");
}

{
  is(exists &zlonk, '', 'sub not present');
  eval qq[ {sub zlonk} ];
  is($@@, '', 'sub declaration followed by a closing curly');
  is(exists &zlonk, 1, 'sub now stubbed');
  is(defined &zlonk, '', 'but no body defined');
}

# [perl #113016] CORE::print::foo
sub CORE'print'foo { 43 } # apostrophes intentional; do not tempt fate
sub CORE'foo'bar { 43 }
is CORE::print::foo, 43, 'CORE::print::foo is not CORE::print ::foo';
is scalar eval "CORE::foo'bar", 43, "CORE::foo'bar is not an error";

# bug #71748
eval q{
	$_ = "";
	s/(.)/
	{
	    #
	}->{$1};
	/e;
	1;
};
is($@@, "", "multiline whitespace inside substitute expression");

eval '@@A =~ s/a/b/; # compilation error
      sub tahi {}
      sub rua;
      sub toru ($);
      sub wha :lvalue;
      sub rima ($%&*$&*\$%\*&$%*&) :method;
      sub ono :lvalue { die }
      sub whitu (_) { die }
      sub waru ($;) :method { die }
      sub iwa { die }
      BEGIN { }';
is $::{tahi}, undef, 'empty sub decl ignored after compilation error';
is $::{rua}, undef, 'stub decl ignored after compilation error';
is $::{toru}, undef, 'stub+proto decl ignored after compilation error';
is $::{wha}, undef, 'stub+attr decl ignored after compilation error';
is $::{rima}, undef, 'stub+proto+attr ignored after compilation error';
is $::{ono}, undef, 'sub decl with attr ignored after compilation error';
is $::{whitu}, undef, 'sub decl w proto ignored after compilation error';
is $::{waru}, undef, 'sub w attr+proto ignored after compilation error';
is $::{iwa}, undef, 'non-empty sub decl ignored after compilation error';
is *BEGIN{CODE}, undef, 'BEGIN leaves no stub after compilation error';

$test = $test + 1;
"ok $test - format inside re-eval" =~ /(?{
    format =
@@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$_
.
write
}).*/;

eval '
"${;

=pod

=cut

}";
';
is $@@, "", 'pod inside string in string eval';
"${;

=pod

=cut

}";
print "ok ", ++$test, " - pod inside string outside of string eval\n";

like "blah blah blah\n", qr/${\ <<END
blah blah blah
END
 }/, 'here docs in multiline quoted construct';
like "blah blah blah\n", eval q|qr/${\ <<END
blah blah blah
END
 }/|, 'here docs in multiline quoted construct in string eval';

# Unterminated here-docs in subst in eval; used to crash
eval 's/${<<END}//';
eval 's//${<<END}/';
print "ok ", ++$test, " - unterminated here-docs in s/// in string eval\n";

sub 'Hello'_he_said (_);
is prototype "Hello::_he_said", '_', 'initial tick in sub declaration';

{
    my @@x = 'string';
    is(eval q{ "$x[0]->strung" }, 'string->strung',
	'literal -> after an array subscript within ""');
    @@x = ['string'];
    # this used to give "string"
    like("$x[0]-> [0]", qr/^ARRAY\([^)]*\)-> \[0]\z/,
	'literal -> [0] after an array subscript within ""');
}

eval 'no if $] >= 5.17.4 warnings => "deprecated"';
is 1,1, ' no crash for "no ... syntax error"';

for my $pkg(()){}
$pkg = 3;
is $pkg, 3, '[perl #114942] for my $foo()){} $foo';

# Check that format 'Foo still works after removing the hack from
# force_word
$test++;
format 'one =
ok @@<< - format 'foo still works
$test
.
{
    local $~ = "one";
    write();
}

$test++;
format ::two =
ok @@<< - format ::foo still works
$test
.
{
    local $~ = "two";
    write();
}

for(__PACKAGE__) {
    eval '$_=42';
    is $_, 'main', '__PACKAGE__ is read-only';
}

$file = __FILE__;
BEGIN{ ${"_<".__FILE__} = \1 }
is __FILE__, $file,
    'no __FILE__ corruption when setting CopFILESV to a ref';

eval 'Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo';
like $@@, "^Identifier too long at ", 'ident buffer overflow';

eval 'for my a1b $i (1) {}';
# ng: 'Missing $ on loop variable'
like $@@, "^No such class a1b at ", 'TYPE of my of for statement';

eval 'method {} {$_,undef}';
like $@@, qq/^Can't call method "method" on unblessed reference at /,
     'method BLOCK {...} does not try to disambiguate';

eval '#line 1 maggapom
      if ($a>3) { $a ++; }
      else {printf(1/0);}';
is $@@, "Illegal division by zero at maggapom line 2.\n",
   'else {foo} line number (no space after {) [perl #122695]';

# parentheses needed for this to fail an assertion in S_maybe_multideref
is +(${[{a=>214}]}[0])->{a}, 214, '($array[...])->{...}';

# This used to fail an assertion because of the OPf_SPECIAL flag on an
# OP_GV that started out as an OP_CONST.  No test output is necessary, as
# successful parsing is sufficient.
sub FILE1 () { 1 }
sub dummy { tell FILE1 }

# More potential multideref assertion failures
# OPf_PARENS on OP_RV2SV in subscript
$x[($_)];
# OPf_SPECIAL on OP_GV in subscript
$x[FILE1->[0]];

# Used to crash [perl #123542]
eval 's /${<>{}) //';

# Also used to crash [perl #123652]
eval{$1=eval{a:}};

# Used to fail assertions [perl #123753]
eval "map+map";
eval "grep+grep";

# ALso failed an assertion [perl #123848]
{
 local $SIG{__WARN__} = sub{};
 eval 'my $_; m// ~~ 0';
}

# RT #124207 syntax error during stringify can leave stringify op
# with multiple children and assertion failures

eval 'qq{@@{0]}${}},{})';
is(1, 1, "RT #124207");


# Add new tests HERE (above this line)

# bug #74022: Loop on characters in \p{OtherIDContinue}
# This test hangs if it fails.
eval chr 0x387;   # forces loading of utf8.pm
is(1,1, '[perl #74022] Parser looping on OtherIDContinue chars');

# More awkward tests for #line. Keep these at the end, as they will screw
# with sane line reporting for any other test failures

sub check ($$$) {
    my ($file, $line, $name) =  @@_;
    my (undef, $got_file, $got_line) = caller;
    like ($got_file, $file, "file of $name");
    is ($got_line, $line, "line of $name");
}

my $this_file = qr/parser\.t(?:\.[bl]eb?)?$/;
#line 3
1 unless
1;
check($this_file, 5, "[perl #118931]");

#line 3
check($this_file, 3, "bare line");

# line 5
check($this_file, 5, "bare line with leading space");

#line 7 
check($this_file, 7, "trailing space still valid");

# line 11 
check($this_file, 11, "leading and trailing");

#	line 13
check($this_file, 13, "leading tab");

#line	17
check($this_file, 17, "middle tab");

#line                                                                        19
check($this_file, 19, "loadsaspaces");

#line 23 KASHPRITZA
check(qr/^KASHPRITZA$/, 23, "bare filename");

#line 29 "KAHEEEE"
check(qr/^KAHEEEE$/, 29, "filename in quotes");

#line 31 "CLINK CLOINK BZZT"
check(qr/^CLINK CLOINK BZZT$/, 31, "filename with spaces in quotes");

#line 37 "THOOM	THOOM"
check(qr/^THOOM	THOOM$/, 37, "filename with tabs in quotes");

#line 41 "GLINK PLINK GLUNK DINK" 
check(qr/^GLINK PLINK GLUNK DINK$/, 41, "a space after the quotes");

#line 43 "BBFRPRAFPGHPP
check(qr/^"BBFRPRAFPGHPP$/, 43, "actually missing a quote is still valid");

#line 47 bang eth
check(qr/^"BBFRPRAFPGHPP$/, 46, "but spaces aren't allowed without quotes");

#line 77sevenseven
check(qr/^"BBFRPRAFPGHPP$/, 49, "need a space after the line number");

eval <<'EOSTANZA'; die $@@ if $@@;
#line 51 "With wonderful deathless ditties|We build up the world's great cities,|And out of a fabulous story|We fashion an empire's glory:|One man with a dream, at pleasure,|Shall go forth and conquer a crown;|And three with a new song's measure|Can trample a kingdom down."
check(qr/^With.*down\.$/, 51, "Overflow the second small buffer check");
EOSTANZA

# And now, turn on the debugger flag for long names
$^P = 0x100;

#line 53 "For we are afar with the dawning|And the suns that are not yet high,|And out of the infinite morning|Intrepid you hear us cry-|How, spite of your human scorning,|Once more God's future draws nigh,|And already goes forth the warning|That ye of the past must die."
check(qr/^For we.*must die\.$/, 53, "Our long line is set up");

eval <<'EOT'; die $@@ if $@@;
#line 59 " "
check(qr/^ $/, 59, "Overflow the first small buffer check only");
EOT

eval <<'EOSTANZA'; die $@@ if $@@;
#line 61 "Great hail! we cry to the comers|From the dazzling unknown shore;|Bring us hither your sun and your summers;|And renew our world as of yore;|You shall teach us your song's new numbers,|And things that we dreamed not before:|Yea, in spite of a dreamer who slumbers,|And a singer who sings no more."
check(qr/^Great hail!.*no more\.$/, 61, "Overflow both small buffer checks");
EOSTANZA

sub check_line ($$) {
    my ($line, $name) =  @@_;
    my (undef, undef, $got_line) = caller;
    is ($got_line, $line, $name);
}

#line 531 parser.t
<<EOU; check_line(531, 'on same line as heredoc');
EOU
s//<<EOV/e if 0;
EOV
check_line(535, 'after here-doc in quotes');
<<EOW; <<EOX;
${check_line(537, 'first line of interp in here-doc');;
  check_line(538, 'second line of interp in here-doc');}
EOW
${check_line(540, 'first line of interp in second here-doc on same line');;
  check_line(541, 'second line of interp in second heredoc on same line');}
EOX
eval <<'EVAL';
#line 545
"${<<EOY; <<EOZ}";
${check_line(546, 'first line of interp in here-doc in quotes in eval');;
  check_line(547, 'second line of interp in here-doc in quotes in eval');}
EOY
${check_line(549, '1st line of interp in 2nd hd, same line in q in eval');;
  check_line(550, '2nd line of interp in 2nd hd, same line in q in eval');}
EOZ
EVAL

time
#line 42
;check_line(42, 'line number after "nullary\n#line"');

"${
#line 53
_}";
check_line(54, 'line number after qq"${#line}"');

#line 24
"
${check_line(25, 'line number inside qq/<newline>${...}/')}";

<<"END";
${;
#line 625
}
END
check_line(627, 'line number after heredoc containing #line');

#line 638
<<ENE . ${

ENE
"bar"};
check_line(642, 'line number after ${expr} surrounding heredoc body');


__END__
# Don't add new tests HERE. See "Add new tests HERE" above.
@


1.2
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d8 1
a8 1
    chdir 't';
d11 1
a11 1
print "1..169\n";
d502 25
d533 17
d698 1
a698 1
# Don't add new tests HERE. See note above
@


1.1
log
@Initial revision
@
text
@d7 2
a8 2
    chdir 't' if -d 't';
    @@INC = '../lib';
d11 46
a56 2
require "./test.pl";
plan( tests => 41 );
d70 14
d140 1
a140 1
    is(qr/${a}{/, '(?-xism:A{)', "interpolation, qr//");
d142 1
a142 1
    $c =~ /${a}{/;
d144 1
a144 1
    $c =~ s/${a}{/foo/;
d163 2
a164 1
pass();
d182 1
a182 1
    ok($@@ eq  '', "eval $eval");
d190 1
a190 1
    like( $@@, qr/syntax error .* near "F 1"/, "unknown filetest operators" );
d197 460
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.3 from CPAN
@
text
@d12 1
a12 1
plan( tests => 42 );
d131 1
a131 1
    like( $@@, qr/(?:syntax|parse) error .* near "F 1"/, "unknown filetest operators" );
a136 6
}

# Bug #24762
{
    eval q{ *foo{CODE} ? 1 : 0 };
    is( $@@, '', "glob subscript in conditional" );
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d12 1
a12 1
plan( tests => 46 );
a142 21
}

# Bug #27024
{
    # this used to segfault (because $[=1 is optimized away to a null block)
    my $x;
    $[ = 1 while $x;
    pass();
    $[ = 0; # restore the original value for less side-effects
}

# [perl #2738] perl segfautls on input
{
    eval q{ sub _ <> {} };
    like($@@, qr/Illegal declaration of subroutine main::_/, "readline operator as prototype");

    eval q{ $s = sub <> {} };
    like($@@, qr/Illegal declaration of anonymous subroutine/, "readline operator as prototype");

    eval q{ sub _ __FILE__ {} };
    like($@@, qr/Illegal declaration of subroutine main::_/, "__FILE__ as prototype");
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d12 1
a12 1
plan( tests => 53 );
a163 22
}

# [perl #36313] perl -e "1for$[=0" crash
{
    my $x;
    $x = 1 for ($[) = 0;
    pass('optimized assignment to $[ used to segfault in list context');
    if ($[ = 0) { $x = 1 }
    pass('optimized assignment to $[ used to segfault in scalar context');
    $x = ($[=2.4);
    is($x, 2, 'scalar assignment to $[ behaves like other variables');
    $x = (($[) = 0);
    is($x, 1, 'list assignment to $[ behaves like other variables');
    $x = eval q{ ($[, $x) = (0) };
    like($@@, qr/That use of \$\[ is unsupported/,
             'cannot assign to $[ in a list');
    eval q{ ($[) = (0, 1) };
    like($@@, qr/That use of \$\[ is unsupported/,
             'cannot assign list of >1 elements to $[');
    eval q{ ($[) = () };
    like($@@, qr/That use of \$\[ is unsupported/,
             'cannot assign list of <1 elements to $[');
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d11 2
a12 2
BEGIN { require "./test.pl"; }
plan( tests => 110 );
a25 7
eval q/"\N{"/;
like( $@@, qr/^Missing right brace on \\N/,
    'syntax error in string with incomplete \N' );
eval q/"\Nfoo"/;
like( $@@, qr/^Missing braces on \\N/,
    'syntax error in string with incomplete \N' );

d131 1
a131 1
    like( $@@, qr/(?i:syntax|parse) error .* near "F 1"/, "unknown filetest operators" );
a144 6
# Bug #25824
{
    eval q{ sub f { @@a=@@b=@@c;  {use} } };
    like( $@@, qr/syntax error/, "use without body" );
}

a186 166

# tests for "Bad name"
eval q{ foo::$bar };
like( $@@, qr/Bad name after foo::/, 'Bad name after foo::' );
eval q{ foo''bar };
like( $@@, qr/Bad name after foo'/, 'Bad name after foo\'' );

# test for ?: context error
eval q{($a ? $x : ($y)) = 5};
like( $@@, qr/Assignment to both a list and a scalar/, 'Assignment to both a list and a scalar' );

eval q{ s/x/#/e };
is( $@@, '', 'comments in s///e' );

# these five used to coredump because the op cleanup on parse error could
# be to the wrong pad

eval q[
    sub { our $a= 1;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;
	    sub { my $z
];

like($@@, qr/Missing right curly/, 'nested sub syntax error' );

eval q[
    sub { my ($a,$b,$c,$d,$e,$f,$g,$h,$i,$j,$k,$l,$m,$n,$o,$p,$q,$r,$s,$r);
	    sub { my $z
];
like($@@, qr/Missing right curly/, 'nested sub syntax error 2' );

eval q[
    sub { our $a= 1;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;$a;
	    use DieDieDie;
];

like($@@, qr/Can't locate DieDieDie.pm/, 'croak cleanup' );

eval q[
    sub { my ($a,$b,$c,$d,$e,$f,$g,$h,$i,$j,$k,$l,$m,$n,$o,$p,$q,$r,$s,$r);
	    use DieDieDie;
];

like($@@, qr/Can't locate DieDieDie.pm/, 'croak cleanup 2' );


eval q[
    my @@a;
    my ($a,$b,$c,$d,$e,$f,$g,$h,$i,$j,$k,$l,$m,$n,$o,$p,$q,$r,$s,$r);
    @@a =~ s/a/b/; # compile-time error
    use DieDieDie;
];

like($@@, qr/Can't modify/, 'croak cleanup 3' );

# these might leak, or have duplicate frees, depending on the bugginess of
# the parser stack 'fail in reduce' cleanup code. They're here mainly as
# something to be run under valgrind, with PERL_DESTRUCT_LEVEL=1.

eval q[ BEGIN { } ] for 1..10;
is($@@, "", 'BEGIN 1' );

eval q[ BEGIN { my $x; $x = 1 } ] for 1..10;
is($@@, "", 'BEGIN 2' );

eval q[ BEGIN { \&foo1 } ] for 1..10;
is($@@, "", 'BEGIN 3' );

eval q[ sub foo2 { } ] for 1..10;
is($@@, "", 'BEGIN 4' );

eval q[ sub foo3 { my $x; $x=1 } ] for 1..10;
is($@@, "", 'BEGIN 5' );

eval q[ BEGIN { die } ] for 1..10;
like($@@, qr/BEGIN failed--compilation aborted/, 'BEGIN 6' );

eval q[ BEGIN {\&foo4; die } ] for 1..10;
like($@@, qr/BEGIN failed--compilation aborted/, 'BEGIN 7' );

# Add new tests HERE:

# More awkward tests for #line. Keep these at the end, as they will screw
# with sane line reporting for any other test failures

sub check ($$$) {
    my ($file, $line, $name) =  @@_;
    my (undef, $got_file, $got_line) = caller;
    like ($got_file, $file, "file of $name");
    is ($got_line, $line, "line of $name");
}

#line 3
check(qr/parser\.t$/, 3, "bare line");

# line 5
check(qr/parser\.t$/, 5, "bare line with leading space");

#line 7 
check(qr/parser\.t$/, 7, "trailing space still valid");

# line 11 
check(qr/parser\.t$/, 11, "leading and trailing");

#	line 13
check(qr/parser\.t$/, 13, "leading tab");

#line	17
check(qr/parser\.t$/, 17, "middle tab");

#line                                                                        19
check(qr/parser\.t$/, 19, "loadsaspaces");

#line 23 KASHPRITZA
check(qr/^KASHPRITZA$/, 23, "bare filename");

#line 29 "KAHEEEE"
check(qr/^KAHEEEE$/, 29, "filename in quotes");

#line 31 "CLINK CLOINK BZZT"
check(qr/^CLINK CLOINK BZZT$/, 31, "filename with spaces in quotes");

#line 37 "THOOM	THOOM"
check(qr/^THOOM	THOOM$/, 37, "filename with tabs in quotes");

#line 41 "GLINK PLINK GLUNK DINK" 
check(qr/^GLINK PLINK GLUNK DINK$/, 41, "a space after the quotes");

#line 43 "BBFRPRAFPGHPP
check(qr/^"BBFRPRAFPGHPP$/, 43, "actually missing a quote is still valid");

#line 47 bang eth
check(qr/^"BBFRPRAFPGHPP$/, 46, "but spaces aren't allowed without quotes");

eval <<'EOSTANZA'; die $@@ if $@@;
#line 51 "With wonderful deathless ditties|We build up the world's great cities,|And out of a fabulous story|We fashion an empire's glory:|One man with a dream, at pleasure,|Shall go forth and conquer a crown;|And three with a new song's measure|Can trample a kingdom down."
check(qr/^With.*down\.$/, 51, "Overflow the second small buffer check");
EOSTANZA

# And now, turn on the debugger flag for long names
$^P = 0x100;

#line 53 "For we are afar with the dawning|And the suns that are not yet high,|And out of the infinite morning|Intrepid you hear us cry-|How, spite of your human scorning,|Once more God's future draws nigh,|And already goes forth the warning|That ye of the past must die."
check(qr/^For we.*must die\.$/, 53, "Our long line is set up");

eval <<'EOT'; die $@@ if $@@;
#line 59 " "
check(qr/^ $/, 59, "Overflow the first small buffer check only");
EOT

eval <<'EOSTANZA'; die $@@ if $@@;
#line 61 "Great hail! we cry to the comers|From the dazzling unknown shore;|Bring us hither your sun and your summers;|And renew our world as of yore;|You shall teach us your song's new numbers,|And things that we dreamed not before:|Yea, in spite of a dreamer who slumbers,|And a singer who sings no more."
check(qr/^Great hail!.*no more\.$/, 61, "Overflow both small buffer checks");
EOSTANZA

{
    my @@x = 'string';
    is(eval q{ "$x[0]->strung" }, 'string->strung',
	'literal -> after an array subscript within ""');
    @@x = ['string'];
    # this used to give "string"
    like("$x[0]-> [0]", qr/^ARRAY\([^)]*\)-> \[0]\z/,
	'literal -> [0] after an array subscript within ""');
}

__END__
# Don't add new tests HERE. See note above
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d6 3
a8 15
print "1..122\n";

sub failed {
    my ($got, $expected, $name) = @@_;

    print "not ok $test - $name\n";
    my @@caller = caller(1);
    print "# Failed test at $caller[1] line $caller[2]\n";
    if (defined $got) {
	print "# Got '$got'\n";
    } else {
	print "# Got undef\n";
    }
    print "# Expected $expected\n";
    return;
d11 2
a12 29
sub like {
    my ($got, $pattern, $name) = @@_;
    $test = $test + 1;
    if (defined $got && $got =~ $pattern) {
	print "ok $test - $name\n";
	# Principle of least surprise - maintain the expected interface, even
	# though we aren't using it here (yet).
	return 1;
    }
    failed($got, $pattern, $name);
}

sub is {
    my ($got, $expect, $name) = @@_;
    $test = $test + 1;
    if (defined $expect) {
	if (defined $got && $got eq $expect) {
	    print "ok $test - $name\n";
	    return 1;
	}
	failed($got, "'$expect'", $name);
    } else {
	if (!defined $got) {
	    print "ok $test - $name\n";
	    return 1;
	}
	failed($got, 'undef', $name);
    }
}
d112 1
a112 2
$test = $test + 1;
print "ok $test\n";
d130 1
a130 1
    is($@@, '', "eval $eval");
d158 9
d179 22
a278 68
{
  # RT #70934
  # check both the specific case in the ticket, and a few other paths into
  # S_scan_ident()
  # simplify long ids
  my $x100 = "x" x 256;
  my $xFE = "x" x 254;
  my $xFD = "x" x 253;
  my $xFC = "x" x 252;
  my $xFB = "x" x 251;

  eval qq[ \$#$xFB ];
  is($@@, "", "251 character \$# sigil ident ok");
  eval qq[ \$#$xFC ];
  like($@@, qr/Identifier too long/, "too long id in \$# sigil ctx");

  eval qq[ \$$xFB ];
  is($@@, "", "251 character \$ sigil ident ok");
  eval qq[ \$$xFC ];
  like($@@, qr/Identifier too long/, "too long id in \$ sigil ctx");

  eval qq[ %$xFB ];
  is($@@, "", "251 character % sigil ident ok");
  eval qq[ %$xFC ];
  like($@@, qr/Identifier too long/, "too long id in % sigil ctx");

  eval qq[ \\&$xFC ]; # take a ref since I don't want to call it
  is($@@, "", "252 character & sigil ident ok");
  eval qq[ \\&$xFD ];
  like($@@, qr/Identifier too long/, "too long id in & sigil ctx");

  eval qq[ *$xFC ];
  is($@@, "", "252 character glob ident ok");
  eval qq[ *$xFD ];
  like($@@, qr/Identifier too long/, "too long id in glob ctx");

  eval qq[ for $xFD ];
  like($@@, qr/Missing \$ on loop variable/,
       "253 char id ok, but a different error");
  eval qq[ for $xFE; ];
  like($@@, qr/Identifier too long/, "too long id in for ctx");

  # the specific case from the ticket
  my $x = "x" x 257;
  eval qq[ for $x ];
  like($@@, qr/Identifier too long/, "too long id ticket case");
}

{
  is(exists &zlonk, '', 'sub not present');
  eval qq[ {sub zlonk} ];
  is($@@, '', 'sub declaration followed by a closing curly');
  is(exists &zlonk, 1, 'sub now stubbed');
  is(defined &zlonk, '', 'but no body defined');
}

# bug #71748
eval q{
	$_ = "";
	s/(.)/
	{
	    #
	}->{$1};
	/e;
	1;
};
is($@@, "", "multiline whitespace inside substitute expression");

a290 1
my $this_file = qr/parser\.t(?:\.[bl]eb?)?$/;
d292 1
a292 1
check($this_file, 3, "bare line");
d295 1
a295 1
check($this_file, 5, "bare line with leading space");
d298 1
a298 1
check($this_file, 7, "trailing space still valid");
d301 1
a301 1
check($this_file, 11, "leading and trailing");
d304 1
a304 1
check($this_file, 13, "leading tab");
d307 1
a307 1
check($this_file, 17, "middle tab");
d310 1
a310 1
check($this_file, 19, "loadsaspaces");
a331 3

#line 77sevenseven
check(qr/^"BBFRPRAFPGHPP$/, 49, "need a space after the line number");
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 1
a6 1
print "1..123\n";
d128 1
a128 1
    is(qr/${a}{/, '(?^:A{)', "interpolation, qr//");
a356 5

# bug #74022: Loop on characters in \p{OtherIDContinue}
# This test hangs if it fails.
eval chr 0x387;
is(1,1, '[perl #74022] Parser looping on OtherIDContinue chars');
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d6 1
a6 1
print "1..155\n";
a71 7
eval q/"\o{"/;
like( $@@, qr/^Missing right brace on \\o/,
    'syntax error in string with incomplete \o' );
eval q/"\ofoo"/;
like( $@@, qr/^Missing braces on \\o/,
    'syntax error in string with incomplete \o' );

d128 1
a128 1
    is(qr/${a}\{/, '(?^:A\{)', "interpolation, qr//");
d130 1
a130 1
    $c =~ /${a}\{/;
d132 1
a132 1
    $c =~ s/${a}\{/foo/;
d314 3
a316 3
  eval qq[ \\&$xFB ]; # take a ref since I don't want to call it
  is($@@, "", "251 character & sigil ident ok");
  eval qq[ \\&$xFC ];
a343 6
# [perl #113016] CORE::print::foo
sub CORE'print'foo { 43 } # apostrophes intentional; do not tempt fate
sub CORE'foo'bar { 43 }
is CORE::print::foo, 43, 'CORE::print::foo is not CORE::print ::foo';
is scalar eval "CORE::foo'bar", 43, "CORE::foo'bar is not an error";

d356 1
a356 93
eval '@@A =~ s/a/b/; # compilation error
      sub tahi {}
      sub rua;
      sub toru ($);
      sub wha :lvalue;
      sub rima ($%&*$&*\$%\*&$%*&) :method;
      sub ono :lvalue { die }
      sub whitu (_) { die }
      sub waru ($;) :method { die }
      sub iwa { die }
      BEGIN { }';
is $::{tahi}, undef, 'empty sub decl ignored after compilation error';
is $::{rua}, undef, 'stub decl ignored after compilation error';
is $::{toru}, undef, 'stub+proto decl ignored after compilation error';
is $::{wha}, undef, 'stub+attr decl ignored after compilation error';
is $::{rima}, undef, 'stub+proto+attr ignored after compilation error';
is $::{ono}, undef, 'sub decl with attr ignored after compilation error';
is $::{whitu}, undef, 'sub decl w proto ignored after compilation error';
is $::{waru}, undef, 'sub w attr+proto ignored after compilation error';
is $::{iwa}, undef, 'non-empty sub decl ignored after compilation error';
is *BEGIN{CODE}, undef, 'BEGIN leaves no stub after compilation error';

$test = $test + 1;
"ok $test - format inside re-eval" =~ /(?{
    format =
@@<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
$_
.
write
}).*/;

eval '
"${;

=pod

=cut

}";
';
is $@@, "", 'pod inside string in string eval';
"${;

=pod

=cut

}";
print "ok ", ++$test, " - pod inside string outside of string eval\n";

like "blah blah blah\n", qr/${\ <<END
blah blah blah
END
 }/, 'here docs in multiline quoted construct';
like "blah blah blah\n", eval q|qr/${\ <<END
blah blah blah
END
 }/|, 'here docs in multiline quoted construct in string eval';

# Unterminated here-docs in subst in eval; used to crash
eval 's/${<<END}//';
eval 's//${<<END}/';
print "ok ", ++$test, " - unterminated here-docs in s/// in string eval\n";

sub 'Hello'_he_said (_);
is prototype "Hello::_he_said", '_', 'initial tick in sub declaration';

{
    my @@x = 'string';
    is(eval q{ "$x[0]->strung" }, 'string->strung',
	'literal -> after an array subscript within ""');
    @@x = ['string'];
    # this used to give "string"
    like("$x[0]-> [0]", qr/^ARRAY\([^)]*\)-> \[0]\z/,
	'literal -> [0] after an array subscript within ""');
}

eval 'no if $] >= 5.17.4 warnings => "deprecated"';
is 1,1, ' no crash for "no ... syntax error"';

for my $pkg(()){}
$pkg = 3;
is $pkg, 3, '[perl #114942] for my $foo()){} $foo';

eval 'Fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo'
    .'ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo';
like $@@, "^Identifier too long at ", 'ident buffer overflow';

# Add new tests HERE (above this line)
d440 9
a448 10
#line 531 parser.t
<<EOU; check('parser\.t', 531, 'on same line as heredoc');
EOU
s//<<EOV/e if 0;
EOV
check('parser\.t', 535, 'after here-doc in quotes');
<<EOW;
${check('parser\.t', 537, 'first line of interp in here-doc');;
  check('parser\.t', 538, 'second line of interp in here-doc');}
EOW
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d6 1
a6 6
BEGIN {
    @@INC = qw(. ../lib);
    chdir 't';
}

print "1..169\n";
d331 1
a331 1
  eval qq[ for $xFC ];
d333 2
a334 2
       "252 char id ok, but a different error");
  eval qq[ for $xFD; ];
a452 32
# Check that format 'Foo still works after removing the hack from
# force_word
$test++;
format 'one =
ok @@<< - format 'foo still works
$test
.
{
    local $~ = "one";
    write();
}

$test++;
format ::two =
ok @@<< - format ::foo still works
$test
.
{
    local $~ = "two";
    write();
}

for(__PACKAGE__) {
    eval '$_=42';
    is $_, 'main', '__PACKAGE__ is read-only';
}

$file = __FILE__;
BEGIN{ ${"_<".__FILE__} = \1 }
is __FILE__, $file,
    'no __FILE__ corruption when setting CopFILESV to a ref';

a460 4
eval 'for my a1b $i (1) {}';
# ng: 'Missing $ on loop variable'
like $@@, "^No such class a1b at ", 'TYPE of my of for statement';

d465 1
a465 1
eval chr 0x387;   # forces loading of utf8.pm
a479 5
1 unless
1;
check($this_file, 5, "[perl #118931]");

#line 3
a544 6
sub check_line ($$) {
    my ($line, $name) =  @@_;
    my (undef, undef, $got_line) = caller;
    is ($got_line, $line, $name);
}

d546 1
a546 1
<<EOU; check_line(531, 'on same line as heredoc');
d550 4
a553 4
check_line(535, 'after here-doc in quotes');
<<EOW; <<EOX;
${check_line(537, 'first line of interp in here-doc');;
  check_line(538, 'second line of interp in here-doc');}
a554 41
${check_line(540, 'first line of interp in second here-doc on same line');;
  check_line(541, 'second line of interp in second heredoc on same line');}
EOX
eval <<'EVAL';
#line 545
"${<<EOY; <<EOZ}";
${check_line(546, 'first line of interp in here-doc in quotes in eval');;
  check_line(547, 'second line of interp in here-doc in quotes in eval');}
EOY
${check_line(549, '1st line of interp in 2nd hd, same line in q in eval');;
  check_line(550, '2nd line of interp in 2nd hd, same line in q in eval');}
EOZ
EVAL

time
#line 42
;check_line(42, 'line number after "nullary\n#line"');

"${
#line 53
_}";
check_line(54, 'line number after qq"${#line}"');

#line 24
"
${check_line(25, 'line number inside qq/<newline>${...}/')}";

<<"END";
${;
#line 625
}
END
check_line(627, 'line number after heredoc containing #line');

#line 638
<<ENE . ${

ENE
"bar"};
check_line(642, 'line number after ${expr} surrounding heredoc body');

@


1.1.1.10
log
@Import perl-5.20.2
@
text
@a501 3
# Used to crash [perl #123542]
eval 's /${<>{}) //';

@


