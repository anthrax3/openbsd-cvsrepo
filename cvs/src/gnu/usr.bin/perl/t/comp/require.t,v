head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.10
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.4
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.6
	OPENBSD_5_8_BASE:1.6
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.6.0.2
	OPENBSD_5_7_BASE:1.6
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.5.0.4
	OPENBSD_5_6_BASE:1.5
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.4.0.6
	OPENBSD_5_5_BASE:1.4
	OPENBSD_5_4:1.4.0.2
	OPENBSD_5_4_BASE:1.4
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.3.0.10
	OPENBSD_5_3_BASE:1.3
	OPENBSD_5_2:1.3.0.8
	OPENBSD_5_2_BASE:1.3
	OPENBSD_5_1_BASE:1.3
	OPENBSD_5_1:1.3.0.6
	OPENBSD_5_0:1.3.0.4
	OPENBSD_5_0_BASE:1.3
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.1.1.7.0.6
	OPENBSD_4_6_BASE:1.1.1.7
	OPENBSD_4_5:1.1.1.7.0.2
	OPENBSD_4_5_BASE:1.1.1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.10
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.8
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.6
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.7
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.6;
commitid	cxJ08BvJA9Pt2PTM;

1.6
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	QP75iYx42Uo7mMxO;

1.5
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.4;

1.4
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.3;

1.3
date	2010.09.24.15.07.05;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2009.08.14.16.34.57;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	99.04.29.22.41.18;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.18;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.38;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.04;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.41;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.43;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.33;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.7
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '.';
    push @@INC, '../lib', '../ext/re';
}

sub do_require {
    %INC = ();
    write_file('bleah.pm',@@_);
    eval { require "bleah.pm" };
    my @@a; # magic guard for scope violations (must be first lexical in file)
}

# don't make this lexical
$i = 1;

my @@files_to_delete = qw (bleah.pm bleah.do bleah.flg urkkk.pm urkkk.pmc
krunch.pm krunch.pmc whap.pm whap.pmc);

# there may be another copy of this test script running, or the files may
# just not have been deleted at the end of the last run; if the former, we
# wait a while so that creating and unlinking these files won't interfere
# with the other process; if the latter, then the delay is harmless.  As
# to why there might be multiple execution of this test file, I don't
# know; but this is an experiment to see if random smoke failures go away.

if (grep -e, @@files_to_delete) {
    print "# Sleeping for 20 secs waiting for other process to finish\n";
    sleep 20;
}


my $Is_EBCDIC = (ord('A') == 193) ? 1 : 0;
my $Is_UTF8   = (${^OPEN} || "") =~ /:utf8/;
my $total_tests = 57;
if ($Is_EBCDIC || $Is_UTF8) { $total_tests -= 3; }
print "1..$total_tests\n";

sub write_file {
    my $f = shift;
    open(REQ,">$f") or die "Can't write '$f': $!";
    binmode REQ;
    print REQ @@_;
    close REQ or die "Could not close $f: $!";
}

eval {require 5.005};
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require 5.005 try 1\n";

eval { require 5.005 };
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require 5.005 try 2\n";

eval { require 5.005; };
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require 5.005 try 3\n";

eval {
    require 5.005
};
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require 5.005 try 4\n";

# new style version numbers

eval { require v5.5.630; };
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require 5.5.630\n";

eval { require(v5.5.630); };
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require(v5.5.630) with parens [perl #124153]\n";

sub v5 { die }
eval { require v5; };
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require v5 ignores sub named v5\n";

eval { require 10.0.2; };
print "# $@@\nnot " unless $@@ =~ /^Perl v10\.0\.2 required/;
print "ok ",$i++," - require 10.0.2\n";

my $ver = 5.005_63;
eval { require $ver; };
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require 5.005_63\n";

# check inaccurate fp
$ver = 10.2;
eval { require $ver; };
print "# $@@\nnot " unless $@@ =~ /^Perl v10\.200.0 required/;
print "ok ",$i++," - require 10.2\n";

$ver = 10.000_02;
eval { require $ver; };
print "# $@@\nnot " unless $@@ =~ /^Perl v10\.0\.20 required/;
print "ok ",$i++," - require 10.000_02\n";

print "not " unless 5.5.1 gt v5.5;
print "ok ",$i++," - 5.5.1 gt v5.5\n";

{
    print "not " unless v5.5.640 eq "\x{5}\x{5}\x{280}";
    print "ok ",$i++," - v5.5.640 eq \\x{5}\\x{5}\\x{280}\n";

    print "not " unless v7.15 eq "\x{7}\x{f}";
    print "ok ",$i++," - v7.15 eq \\x{7}\\x{f}\n";

    print "not "
      unless v1.20.300.4000.50000.600000 eq "\x{1}\x{14}\x{12c}\x{fa0}\x{c350}\x{927c0}";
    print "ok ",$i++," - v1.20.300.4000.50000.600000 eq ...\n";
}

# "use 5.11.0" (and higher) loads strictures.
# check that this doesn't happen with require
eval 'require 5.11.0; ${"foo"} = "bar";';
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require 5.11.0\n";
eval 'BEGIN {require 5.11.0} ${"foo"} = "bar";';
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\ - BEGIN { require 5.11.0}\n";

# interaction with pod (see the eof)
write_file('bleah.pm', "print 'ok $i - require bleah.pm\n'; 1;\n");
require "bleah.pm";
$i++;

# run-time failure in require
do_require "0;\n";
print "# $@@\nnot " unless $@@ =~ /did not return a true/;
print "ok ",$i++," - require returning 0\n";

print "not " if exists $INC{'bleah.pm'};
print "ok ",$i++," - %INC not updated\n";

my $flag_file = 'bleah.flg';
# run-time error in require
for my $expected_compile (1,0) {
    write_file($flag_file, 1);
    print "not " unless -e $flag_file;
    print "ok ",$i++," - exp $expected_compile; bleah.flg\n";
    write_file('bleah.pm', "unlink '$flag_file' or die; \$a=0; \$b=1/\$a; 1;\n");
    print "# $@@\nnot " if eval { require 'bleah.pm' };
    print "ok ",$i++," - exp $expected_compile; require bleah.pm with flag file\n";
    print "not " unless -e $flag_file xor $expected_compile;
    print "ok ",$i++," - exp $expected_compile; -e flag_file\n";
    print "not " unless exists $INC{'bleah.pm'};
    print "ok ",$i++," - exp $expected_compile; exists \$INC{'bleah.pm}\n";
}

# compile-time failure in require
do_require "1)\n";
# bison says 'parse error' instead of 'syntax error',
# various yaccs may or may not capitalize 'syntax'.
print "# $@@\nnot " unless $@@ =~ /(syntax|parse) error/mi;
print "ok ",$i++," - syntax error\n";

# previous failure cached in %INC
print "not " unless exists $INC{'bleah.pm'};
print "ok ",$i++," - cached %INC\n";
write_file($flag_file, 1);
write_file('bleah.pm', "unlink '$flag_file'; 1");
print "# $@@\nnot " if eval { require 'bleah.pm' };
print "ok ",$i++," - eval { require 'bleah.pm' }\n";
print "# $@@\nnot " unless $@@ =~ /Compilation failed/i;
print "ok ",$i++," - Compilation failed\n";
print "not " unless -e $flag_file;
print "ok ",$i++," - -e flag_file\n";
print "not " unless exists $INC{'bleah.pm'};
print "ok ",$i++," - \$INC{'bleah.pm'}\n";

# successful require
do_require "1";
print "# $@@\nnot " if $@@;
print "ok ",$i++," - do_require '1';\n";

# do FILE shouldn't see any outside lexicals
my $x = "ok $i - bleah.do\n";
write_file("bleah.do", <<EOT);
\$x = "not ok $i - bleah.do\\n";
EOT
do "bleah.do" or die $@@;
dofile();
sub dofile { do "bleah.do" or die $@@; };
print $x;

# Test that scalar context is forced for require

write_file('bleah.pm', <<'**BLEAH**'
print "not " if !defined wantarray || wantarray ne '';
print "ok $i - require() context\n";
1;
**BLEAH**
);
                              delete $INC{"bleah.pm"}; ++$::i;
$foo = eval q{require bleah}; delete $INC{"bleah.pm"}; ++$::i;
@@foo = eval q{require bleah}; delete $INC{"bleah.pm"}; ++$::i;
       eval q{require bleah}; delete $INC{"bleah.pm"}; ++$::i;
       eval q{$_=$_+2;require bleah}; delete $INC{"bleah.pm"}; ++$::i;
       eval q{return require bleah}; delete $INC{"bleah.pm"}; ++$::i;
$foo = eval  {require bleah}; delete $INC{"bleah.pm"}; ++$::i;
@@foo = eval  {require bleah}; delete $INC{"bleah.pm"}; ++$::i;
       eval  {require bleah};

# Test for fix of RT #24404 : "require $scalar" may load a directory
my $r = "threads";
eval { require $r };
$i++;
if($@@ =~ /Can't locate threads in \@@INC/) {
    print "ok $i - RT #24404\n";
} else {
    print "not ok - RT #24404$i\n";
}

# require CORE::foo
eval ' require CORE::lc "THREADS" ';
$i++;
if($@@ =~ /Can't locate threads in \@@INC/) {
    print "ok $i - [perl #24482] require CORE::foo\n";
} else {
    print "not ok - [perl #24482] require CORE::foo\n";
}


write_file('bleah.pm', qq(die "This is an expected error";\n));
delete $INC{"bleah.pm"}; ++$::i;
eval { CORE::require bleah; };
if ($@@ =~ /^This is an expected error/) {
    print "ok $i - expected error\n";
} else {
    print "not ok $i - expected error\n";
}

sub write_file_not_thing {
    my ($file, $thing, $test) = @@_;
    write_file($file, <<"EOT");
    print "not ok $test - write_file_not_thing $file\n";
    die "The $thing file should not be loaded";
EOT
}

{
    # Right. We really really need Config here.
    require Config;
    die "Failed to load Config for some reason"
	unless $Config::Config{version};

    my $simple = ++$i;
    my $pmc_older = ++$i;
    my $pmc_dies = ++$i;
    my $no_pmc;
    foreach(Config::non_bincompat_options()) {
	if($_ eq "PERL_DISABLE_PMC"){
	    $no_pmc = 1;
	    last;
	}
    }
    if ($no_pmc) {
	print "# .pmc files are ignored, so test that\n";
	write_file_not_thing('krunch.pmc', '.pmc', $pmc_older);
	write_file('urkkk.pm', qq(print "ok $simple - urkkk.pm branch A\n"));
	write_file('whap.pmc', qq(die "This is not an expected error"));

	print "# Sleeping for 2 seconds before creating some more files\n";
	sleep 2;

	write_file('krunch.pm', qq(print "ok $pmc_older - krunch.pm branch A\n"));
	write_file_not_thing('urkkk.pmc', '.pmc', $simple);
	write_file('whap.pm', qq(die "This is an expected error"));
    } else {
	print "# .pmc files should be loaded, so test that\n";
	write_file('krunch.pmc', qq(print "ok $pmc_older - krunch.pm branch B\n";));
	write_file_not_thing('urkkk.pm', '.pm', $simple);
	write_file('whap.pmc', qq(die "This is an expected error"));

	print "# Sleeping for 2 seconds before creating some more files\n";
	sleep 2;

	write_file_not_thing('krunch.pm', '.pm', $pmc_older);
	write_file('urkkk.pmc', qq(print "ok $simple - urkkk.pm branch B\n";));
	write_file_not_thing('whap.pm', '.pm', $pmc_dies);
    }
    require urkkk;
    require krunch;
    eval {CORE::require whap; 1} and die;

    if ($@@ =~ /^This is an expected error/) {
	print "ok $pmc_dies - pmc_dies\n";
    } else {
	print "not ok $pmc_dies - pmc_dies\n";
    }
}


{
    # if we 'require "op"', since we're in the t/ directory and '.' is the
    # first thing in @@INC, it will try to load t/op/; it should fail and
    # move onto the next path; however, the previous value of $! was
    # leaking into implementation if it was EACCES and we're accessing a
    # directory.

    $! = eval 'use Errno qw(EACCES); EACCES' || 0;
    eval q{require 'op'};
    $i++;
    print "not " if $@@ =~ /Permission denied/;
    print "ok $i - require op\n";
}

# Test "require func()" with abs path when there is no .pmc file.
++$::i;
if (defined &DynaLoader::boot_DynaLoader) {
    require Cwd;
    require File::Spec::Functions;
    eval {
     CORE::require(File::Spec::Functions::catfile(Cwd::getcwd(),"bleah.pm"));
    };
    if ($@@ =~ /^This is an expected error/) {
	print "ok $i - require(func())\n";
    } else {
	print "not ok $i - require(func())\n";
    }
} else {
    print "ok $i # SKIP Cwd may not be available in miniperl\n";
}

{
    BEGIN { ${^OPEN} = ":utf8\0"; }
    %INC = ();
    write_file('bleah.pm',"package F; \$x = '\xD1\x9E';\n");
    eval { require "bleah.pm" };
    $i++;
    my $not = $F::x eq "\xD1\x9E" ? "" : "not ";
    print "${not}ok $i - require ignores I/O layers\n";
}

{
    BEGIN { ${^OPEN} = ":utf8\0"; }
    %INC = ();
    write_file('bleah.pm',"require re; re->import('/x'); 1;\n");
    my $not = eval 'use bleah; "ab" =~ /a b/' ? "" : "not ";
    $i++;
    print "${not}ok $i - require does not localise %^H at run time\n";
}

##########################################
# What follows are UTF-8 specific tests. #
# Add generic tests before this point.   #
##########################################

# UTF-encoded things - skipped on UTF-8 input

if ($Is_UTF8) { exit; }

my %templates = (
		 'UTF-8'    => 'C0U',
		 'UTF-16BE' => 'n',
		 'UTF-16LE' => 'v',
		);

sub bytes_to_utf {
    my ($enc, $content, $do_bom) = @@_;
    my $template = $templates{$enc};
    die "Unsupported encoding $enc" unless $template;
    return pack "$template*", ($do_bom ? 0xFEFF : ()), unpack "C*", $content;
}

foreach (sort keys %templates) {
    $i++; do_require(bytes_to_utf($_, qq(print "ok $i # $_\\n"; 1;\n), 1));
    if ($@@ =~ /^(Unsupported script encoding \Q$_\E)/) {
	print "ok $i # skip $1\n";
    }
}

END {
    foreach my $file (@@files_to_delete) {
	1 while unlink $file;
    }
}

# ***interaction with pod (don't put any thing after here)***

=pod
@


1.6
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d6 1
a6 1
    push @@INC, '../lib';
d37 1
a37 1
my $total_tests = 56;
d73 4
a249 2
    my $ccflags = $Config::Config{ccflags};
    die "Failed to get ccflags for some reason" unless defined $ccflags;
d254 8
a261 1
    if ($ccflags =~ /(?:^|\s)-DPERL_DISABLE_PMC\b/) {
d353 1
a353 1
# UTF-encoded things - skipped on EBCDIC machines and on UTF-8 input
d355 1
a355 1
if ($Is_EBCDIC || $Is_UTF8) { exit; }
@


1.5
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d19 1
a19 1
my @@fjles_to_delete = qw (bleah.pm bleah.do bleah.flg urkkk.pm urkkk.pmc
d22 12
d37 1
a37 1
my $total_tests = 54;
d214 9
d288 15
d369 1
a369 1
    foreach my $file (@@fjles_to_delete) {
@


1.4
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d25 1
a25 1
my $total_tests = 53;
d39 1
a39 1
print "ok ",$i++,"\n";
d43 1
a43 1
print "ok ",$i++,"\n";
d47 1
a47 1
print "ok ",$i++,"\n";
d53 1
a53 1
print "ok ",$i++,"\n";
d59 6
a64 1
print "ok ",$i++,"\n";
d68 1
a68 1
print "ok ",$i++,"\n";
d73 1
a73 1
print "ok ",$i++,"\n";
d79 1
a79 1
print "ok ",$i++,"\n";
d84 1
a84 1
print "ok ",$i++,"\n";
d87 1
a87 1
print "ok ",$i++,"\n";
d91 1
a91 1
    print "ok ",$i++,"\n";
d94 1
a94 1
    print "ok ",$i++,"\n";
d98 1
a98 1
    print "ok ",$i++,"\n";
d105 1
a105 1
print "ok ",$i++,"\n";
d108 1
a108 1
print "ok ",$i++,"\n";
d111 1
a111 1
write_file('bleah.pm', "print 'ok $i\n'; 1;\n");
d118 1
a118 1
print "ok ",$i++,"\n";
d121 1
a121 1
print "ok ",$i++,"\n";
d128 1
a128 1
    print "ok ",$i++,"\n";
d131 1
a131 1
    print "ok ",$i++,"\n";
d133 1
a133 1
    print "ok ",$i++,"\n";
d135 1
a135 1
    print "ok ",$i++,"\n";
d143 1
a143 1
print "ok ",$i++,"\n";
d147 1
a147 1
print "ok ",$i++,"\n";
d151 1
a151 1
print "ok ",$i++,"\n";
d153 1
a153 1
print "ok ",$i++,"\n";
d155 1
a155 1
print "ok ",$i++,"\n";
d157 1
a157 1
print "ok ",$i++,"\n";
d162 1
a162 1
print "ok ",$i++,"\n";
d165 1
a165 1
my $x = "ok $i\n";
d167 1
a167 1
\$x = "not ok $i\\n";
d197 1
a197 1
    print "ok $i\n";
d199 1
a199 1
    print "not ok $i\n";
d207 1
a207 1
    print "ok $i\n";
d209 1
a209 1
    print "not ok $i\n";
d215 1
a215 1
    print "not ok $test\n";
d234 1
a234 1
	write_file('urkkk.pm', qq(print "ok $simple\n"));
d240 1
a240 1
	write_file('krunch.pm', qq(print "ok $pmc_older\n"));
d245 1
a245 1
	write_file('krunch.pmc', qq(print "ok $pmc_older\n";));
d253 1
a253 1
	write_file('urkkk.pmc', qq(print "ok $simple\n";));
d261 1
a261 1
	print "ok $pmc_dies\n";
d263 1
a263 1
	print "not ok $pmc_dies\n";
d276 1
a276 1
	print "ok $i\n";
d278 1
a278 1
	print "not ok $i\n";
@


1.3
log
@merge in perl 5.12.2 plus local changes
@
text
@d25 1
a25 1
my $total_tests = 49;
d101 3
d260 36
@


1.2
log
@- fix for pr 6196 from upstream git

ok millert@@
@
text
@d9 7
d25 1
a25 1
my $total_tests = 50;
a28 7
sub do_require {
    %INC = ();
    write_file('bleah.pm',@@_);
    eval { require "bleah.pm" };
    my @@a; # magic guard for scope violations (must be first lexical in file)
}

a32 1
    use bytes;
a64 8
eval q{ use v5.5.630; };
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";

eval q{ use 10.0.2; };
print "# $@@\nnot " unless $@@ =~ /^Perl v10\.0\.2 required/;
print "ok ",$i++,"\n";

d96 6
d179 1
a258 14
#  [perl #49472] Attributes + Unkown Error

{
    do_require
	'use strict;sub MODIFY_CODE_ATTRIBUTE{} sub f:Blah {$nosuchvar}';
    my $err = $@@;
    $err .= "\n" unless $err =~ /\n$/;
    unless ($err =~ /Global symbol "\$nosuchvar" requires /) {
	$err =~ s/^/# /mg;
	print "${err}not ";
    }
    print "ok ", ++$i, " [perl #49472]\n";
}

d268 12
a279 1
my $utf8 = chr(0xFEFF);
d281 5
a285 5
$i++; do_require(qq(${utf8}print "ok $i\n"; 1;\n));

sub bytes_to_utf16 {
    my $utf16 = pack("$_[0]*", unpack("C*", $_[1]));
    return @@_ == 3 && $_[2] ? pack("$_[0]", 0xFEFF) . $utf16 : $utf16;
a286 3

$i++; do_require(bytes_to_utf16('n', qq(print "ok $i\\n"; 1;\n), 1)); # BE
$i++; do_require(bytes_to_utf16('v', qq(print "ok $i\\n"; 1;\n), 1)); # LE
@


1.1
log
@Initial revision
@
text
@d5 2
a6 1
    @@INC = ('.', '../lib');
d11 10
a20 1
print "1..4\n";
d32 2
d35 68
a102 1
    close REQ;
d115 18
d140 14
d159 142
a300 1
END { unlink 'bleah.pm'; }
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d5 1
a5 1
    unshift @@INC, ('.', '../lib');
d10 1
a10 1
print "1..20\n";
a25 68
eval {require 5.005};
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";

eval { require 5.005 };
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";

eval { require 5.005; };
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";

eval {
    require 5.005
};
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";

# new style version numbers

eval { require v5.5.630; };
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";

eval { require 10.0.2; };
print "# $@@\nnot " unless $@@ =~ /^Perl v10\.0\.2 required/;
print "ok ",$i++,"\n";

eval q{ use v5.5.630; };
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";

eval q{ use 10.0.2; };
print "# $@@\nnot " unless $@@ =~ /^Perl v10\.0\.2 required/;
print "ok ",$i++,"\n";

my $ver = 5.005_63;
eval { require $ver; };
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";

# check inaccurate fp
$ver = 10.2;
eval { require $ver; };
print "# $@@\nnot " unless $@@ =~ /^Perl v10\.200\.0 required/;
print "ok ",$i++,"\n";

$ver = 10.000_02;
eval { require $ver; };
print "# $@@\nnot " unless $@@ =~ /^Perl v10\.0\.20 required/;
print "ok ",$i++,"\n";

print "not " unless 5.5.1 gt v5.5;
print "ok ",$i++,"\n";

{
    use utf8;
    print "not " unless v5.5.640 eq "\x{5}\x{5}\x{280}";
    print "ok ",$i++,"\n";

    print "not " unless v7.15 eq "\x{7}\x{f}";
    print "ok ",$i++,"\n";

    print "not "
      unless v1.20.300.4000.50000.600000 eq "\x{1}\x{14}\x{12c}\x{fa0}\x{c350}\x{927c0}";
    print "ok ",$i++,"\n";
}

d48 1
a48 12
# do FILE shouldn't see any outside lexicals
my $x = "ok $i\n";
write_file("bleah.do", <<EOT);
\$x = "not ok $i\\n";
EOT
do "bleah.do";
dofile();
sub dofile { do "bleah.do"; };
print $x;
$i++;

END { 1 while unlink 'bleah.pm'; 1 while unlink 'bleah.do'; }
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d5 1
a5 2
    @@INC = '.';
    push @@INC, '../lib';
d10 1
a10 9
# Tests 21 .. 23 work only with non broken UTF16-as-code implementations,
# i.e. not EBCDIC Perls.
my $Is_EBCDIC = ord('A') == 193 ? 1 : 0;
if ($Is_EBCDIC) {
   print "1..20\n";
}
else {
   print "1..23\n";
}
a21 2
    binmode REQ;
    use bytes;
d125 1
a125 15

exit if $Is_EBCDIC;

# UTF-encoded things
my $utf8 = chr(0xFEFF);

$i++; do_require(qq(${utf8}print "ok $i\n"; 1;\n));

sub bytes_to_utf16 {
    my $utf16 = pack("$_[0]*", unpack("C*", $_[1]));
    return @@_ == 3 && $_[2] ? pack("$_[0]", 0xFEFF) . $utf16 : $utf16;
}

$i++; do_require(bytes_to_utf16('n', qq(print "ok $i\\n"; 1;\n), 1)); # BE
$i++; do_require(bytes_to_utf16('v', qq(print "ok $i\\n"; 1;\n), 1)); # LE
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d11 9
a19 6

my $Is_EBCDIC = (ord('A') == 193) ? 1 : 0;
my $Is_UTF8   = (${^OPEN} || "") =~ /:utf8/;
my $total_tests = 23;
if ($Is_EBCDIC || $Is_UTF8) { $total_tests = 20; }
print "1..$total_tests\n";
d34 1
a34 1
    close REQ or die "Could not close $f: $!";
d93 1
d137 1
a137 3
# UTF-encoded things - skipped on EBCDIC machines and on UTF-8 input

if ($Is_EBCDIC || $Is_UTF8) { exit; }
d139 1
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d14 2
a15 2
my $total_tests = 30;
if ($Is_EBCDIC || $Is_UTF8) { $total_tests = 27; }
a131 17

# Test that scalar context is forced for require

write_file('bleah.pm', <<'**BLEAH**'
print "not " if !defined wantarray || wantarray ne '';
print "ok $i - require() context\n";
1;
**BLEAH**
);
                              delete $INC{"bleah.pm"}; ++$::i;
$foo = eval q{require bleah}; delete $INC{"bleah.pm"}; ++$::i;
@@foo = eval q{require bleah}; delete $INC{"bleah.pm"}; ++$::i;
       eval q{require bleah}; delete $INC{"bleah.pm"}; ++$::i;
       eval q{$_=$_+2;require bleah}; delete $INC{"bleah.pm"}; ++$::i;
$foo = eval  {require bleah}; delete $INC{"bleah.pm"}; ++$::i;
@@foo = eval  {require bleah}; delete $INC{"bleah.pm"}; ++$::i;
       eval  {require bleah};
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d14 2
a15 2
my $total_tests = 31;
if ($Is_EBCDIC || $Is_UTF8) { $total_tests -= 3; }
a148 15

# Test for fix of RT #24404 : "require $scalar" may load a directory
my $r = "threads";
eval { require $r };
$i++;
if($@@ =~ /Directory .*threads not allowed in require/) {
    print "ok $i\n";
} else {
    print "not ok $i\n";
}

##########################################
# What follows are UTF-8 specific tests. #
# Add generic tests before this point.   #
##########################################
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@a11 4
my @@fjles_to_delete = qw (bleah.pm bleah.do bleah.flg urkkk.pm urkkk.pmc
krunch.pm krunch.pmc whap.pm whap.pmc);


d14 1
a14 1
my $total_tests = 49;
d78 1
a78 1
print "# $@@\nnot " unless $@@ =~ /^Perl v10\.200.0 required/;
a110 18
print "not " if exists $INC{'bleah.pm'};
print "ok ",$i++,"\n";

my $flag_file = 'bleah.flg';
# run-time error in require
for my $expected_compile (1,0) {
    write_file($flag_file, 1);
    print "not " unless -e $flag_file;
    print "ok ",$i++,"\n";
    write_file('bleah.pm', "unlink '$flag_file' or die; \$a=0; \$b=1/\$a; 1;\n");
    print "# $@@\nnot " if eval { require 'bleah.pm' };
    print "ok ",$i++,"\n";
    print "not " unless -e $flag_file xor $expected_compile;
    print "ok ",$i++,"\n";
    print "not " unless exists $INC{'bleah.pm'};
    print "ok ",$i++,"\n";
}

a117 14
# previous failure cached in %INC
print "not " unless exists $INC{'bleah.pm'};
print "ok ",$i++,"\n";
write_file($flag_file, 1);
write_file('bleah.pm', "unlink '$flag_file'; 1");
print "# $@@\nnot " if eval { require 'bleah.pm' };
print "ok ",$i++,"\n";
print "# $@@\nnot " unless $@@ =~ /Compilation failed/i;
print "ok ",$i++,"\n";
print "not " unless -e $flag_file;
print "ok ",$i++,"\n";
print "not " unless exists $INC{'bleah.pm'};
print "ok ",$i++,"\n";

d128 1
a128 1
do "bleah.do" or die $@@;
d130 1
a130 1
sub dofile { do "bleah.do" or die $@@; };
d154 1
a154 11
if($@@ =~ /Can't locate threads in \@@INC/) {
    print "ok $i\n";
} else {
    print "not ok $i\n";
}


write_file('bleah.pm', qq(die "This is an expected error";\n));
delete $INC{"bleah.pm"}; ++$::i;
eval { CORE::require bleah; };
if ($@@ =~ /^This is an expected error/) {
a159 55
sub write_file_not_thing {
    my ($file, $thing, $test) = @@_;
    write_file($file, <<"EOT");
    print "not ok $test\n";
    die "The $thing file should not be loaded";
EOT
}

{
    # Right. We really really need Config here.
    require Config;
    die "Failed to load Config for some reason"
	unless $Config::Config{version};
    my $ccflags = $Config::Config{ccflags};
    die "Failed to get ccflags for some reason" unless defined $ccflags;

    my $simple = ++$i;
    my $pmc_older = ++$i;
    my $pmc_dies = ++$i;
    if ($ccflags =~ /(?:^|\s)-DPERL_DISABLE_PMC\b/) {
	print "# .pmc files are ignored, so test that\n";
	write_file_not_thing('krunch.pmc', '.pmc', $pmc_older);
	write_file('urkkk.pm', qq(print "ok $simple\n"));
	write_file('whap.pmc', qq(die "This is not an expected error"));

	print "# Sleeping for 2 seconds before creating some more files\n";
	sleep 2;

	write_file('krunch.pm', qq(print "ok $pmc_older\n"));
	write_file_not_thing('urkkk.pmc', '.pmc', $simple);
	write_file('whap.pm', qq(die "This is an expected error"));
    } else {
	print "# .pmc files should be loaded, so test that\n";
	write_file('krunch.pmc', qq(print "ok $pmc_older\n";));
	write_file_not_thing('urkkk.pm', '.pm', $simple);
	write_file('whap.pmc', qq(die "This is an expected error"));

	print "# Sleeping for 2 seconds before creating some more files\n";
	sleep 2;

	write_file_not_thing('krunch.pm', '.pm', $pmc_older);
	write_file('urkkk.pmc', qq(print "ok $simple\n";));
	write_file_not_thing('whap.pm', '.pm', $pmc_dies);
    }
    require urkkk;
    require krunch;
    eval {CORE::require whap; 1} and die;

    if ($@@ =~ /^This is an expected error/) {
	print "ok $pmc_dies\n";
    } else {
	print "not ok $pmc_dies\n";
    }
}

d181 1
a181 5
END {
    foreach my $file (@@fjles_to_delete) {
	1 while unlink $file;
    }
}
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d18 1
a18 1
my $total_tests = 50;
a258 14
}

#  [perl #49472] Attributes + Unkown Error

{
    do_require
	'use strict;sub MODIFY_CODE_ATTRIBUTE{} sub f:Blah {$nosuchvar}';
    my $err = $@@;
    $err .= "\n" unless $err =~ /\n$/;
    unless ($err =~ /Global symbol "\$nosuchvar" requires /) {
	$err =~ s/^/# /mg;
	print "${err}not ";
    }
    print "ok ", ++$i, " [perl #49472]\n";
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@a8 7
sub do_require {
    %INC = ();
    write_file('bleah.pm',@@_);
    eval { require "bleah.pm" };
    my @@a; # magic guard for scope violations (must be first lexical in file)
}

d18 1
a18 1
my $total_tests = 49;
d22 7
d33 1
d66 8
a104 6
# "use 5.11.0" (and higher) loads strictures.
# check that this doesn't happen with require
eval 'require 5.11.0; ${"foo"} = "bar";';
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";

a181 1
       eval q{return require bleah}; delete $INC{"bleah.pm"}; ++$::i;
d261 14
d284 7
a290 11
my %templates = (
		 'UTF-8'    => 'C0U',
		 'UTF-16BE' => 'n',
		 'UTF-16LE' => 'v',
		);

sub bytes_to_utf {
    my ($enc, $content, $do_bom) = @@_;
    my $template = $templates{$enc};
    die "Unsupported encoding $enc" unless $template;
    return pack "$template*", ($do_bom ? 0xFEFF : ()), unpack "C*", $content;
d293 2
a294 6
foreach (sort keys %templates) {
    $i++; do_require(bytes_to_utf($_, qq(print "ok $i # $_\\n"; 1;\n), 1));
    if ($@@ =~ /^(Unsupported script encoding \Q$_\E)/) {
	print "ok $i # skip $1\n";
    }
}
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d25 1
a25 1
my $total_tests = 53;
a100 3
eval 'BEGIN {require 5.11.0} ${"foo"} = "bar";';
print "# $@@\nnot " if $@@;
print "ok ",$i++,"\n";
a256 36
}

# Test "require func()" with abs path when there is no .pmc file.
++$::i;
if (defined &DynaLoader::boot_DynaLoader) {
    require Cwd;
    require File::Spec::Functions;
    eval {
     CORE::require(File::Spec::Functions::catfile(Cwd::getcwd(),"bleah.pm"));
    };
    if ($@@ =~ /^This is an expected error/) {
	print "ok $i\n";
    } else {
	print "not ok $i\n";
    }
} else {
    print "ok $i # SKIP Cwd may not be available in miniperl\n";
}

{
    BEGIN { ${^OPEN} = ":utf8\0"; }
    %INC = ();
    write_file('bleah.pm',"package F; \$x = '\xD1\x9E';\n");
    eval { require "bleah.pm" };
    $i++;
    my $not = $F::x eq "\xD1\x9E" ? "" : "not ";
    print "${not}ok $i - require ignores I/O layers\n";
}

{
    BEGIN { ${^OPEN} = ":utf8\0"; }
    %INC = ();
    write_file('bleah.pm',"require re; re->import('/x'); 1;\n");
    my $not = eval 'use bleah; "ab" =~ /a b/' ? "" : "not ";
    $i++;
    print "${not}ok $i - require does not localise %^H at run time\n";
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d25 1
a25 1
my $total_tests = 54;
d39 1
a39 1
print "ok ",$i++," - require 5.005 try 1\n";
d43 1
a43 1
print "ok ",$i++," - require 5.005 try 2\n";
d47 1
a47 1
print "ok ",$i++," - require 5.005 try 3\n";
d53 1
a53 1
print "ok ",$i++," - require 5.005 try 4\n";
d59 1
a59 6
print "ok ",$i++," - require 5.5.630\n";

sub v5 { die }
eval { require v5; };
print "# $@@\nnot " if $@@;
print "ok ",$i++," - require v5 ignores sub named v5\n";
d63 1
a63 1
print "ok ",$i++," - require 10.0.2\n";
d68 1
a68 1
print "ok ",$i++," - require 5.005_63\n";
d74 1
a74 1
print "ok ",$i++," - require 10.2\n";
d79 1
a79 1
print "ok ",$i++," - require 10.000_02\n";
d82 1
a82 1
print "ok ",$i++," - 5.5.1 gt v5.5\n";
d86 1
a86 1
    print "ok ",$i++," - v5.5.640 eq \\x{5}\\x{5}\\x{280}\n";
d89 1
a89 1
    print "ok ",$i++," - v7.15 eq \\x{7}\\x{f}\n";
d93 1
a93 1
    print "ok ",$i++," - v1.20.300.4000.50000.600000 eq ...\n";
d100 1
a100 1
print "ok ",$i++," - require 5.11.0\n";
d103 1
a103 1
print "ok ",$i++,"\ - BEGIN { require 5.11.0}\n";
d106 1
a106 1
write_file('bleah.pm', "print 'ok $i - require bleah.pm\n'; 1;\n");
d113 1
a113 1
print "ok ",$i++," - require returning 0\n";
d116 1
a116 1
print "ok ",$i++," - %INC not updated\n";
d123 1
a123 1
    print "ok ",$i++," - exp $expected_compile; bleah.flg\n";
d126 1
a126 1
    print "ok ",$i++," - exp $expected_compile; require bleah.pm with flag file\n";
d128 1
a128 1
    print "ok ",$i++," - exp $expected_compile; -e flag_file\n";
d130 1
a130 1
    print "ok ",$i++," - exp $expected_compile; exists \$INC{'bleah.pm}\n";
d138 1
a138 1
print "ok ",$i++," - syntax error\n";
d142 1
a142 1
print "ok ",$i++," - cached %INC\n";
d146 1
a146 1
print "ok ",$i++," - eval { require 'bleah.pm' }\n";
d148 1
a148 1
print "ok ",$i++," - Compilation failed\n";
d150 1
a150 1
print "ok ",$i++," - -e flag_file\n";
d152 1
a152 1
print "ok ",$i++," - \$INC{'bleah.pm'}\n";
d157 1
a157 1
print "ok ",$i++," - do_require '1';\n";
d160 1
a160 1
my $x = "ok $i - bleah.do\n";
d162 1
a162 1
\$x = "not ok $i - bleah.do\\n";
d192 1
a192 1
    print "ok $i - RT #24404\n";
d194 1
a194 1
    print "not ok - RT #24404$i\n";
d202 1
a202 1
    print "ok $i - expected error\n";
d204 1
a204 1
    print "not ok $i - expected error\n";
d210 1
a210 1
    print "not ok $test - write_file_not_thing $file\n";
d229 1
a229 1
	write_file('urkkk.pm', qq(print "ok $simple - urkkk.pm branch A\n"));
d235 1
a235 1
	write_file('krunch.pm', qq(print "ok $pmc_older - krunch.pm branch A\n"));
d240 1
a240 1
	write_file('krunch.pmc', qq(print "ok $pmc_older - krunch.pm branch B\n";));
d248 1
a248 1
	write_file('urkkk.pmc', qq(print "ok $simple - urkkk.pm branch B\n";));
d256 1
a256 1
	print "ok $pmc_dies - pmc_dies\n";
d258 1
a258 1
	print "not ok $pmc_dies - pmc_dies\n";
d271 1
a271 1
	print "ok $i - require(func())\n";
d273 1
a273 1
	print "not ok $i - require(func())\n";
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d19 1
a19 1
my @@files_to_delete = qw (bleah.pm bleah.do bleah.flg urkkk.pm urkkk.pmc
a21 12
# there may be another copy of this test script running, or the files may
# just not have been deleted at the end of the last run; if the former, we
# wait a while so that creating and unlinking these files won't interfere
# with the other process; if the latter, then the delay is harmless.  As
# to why there might be multiple execution of this test file, I don't
# know; but this is an experiment to see if random smoke failures go away.

if (grep -e, @@files_to_delete) {
    print "# Sleeping for 20 secs waiting for other process to finish\n";
    sleep 20;
}

d25 1
a25 1
my $total_tests = 56;
a201 9
# require CORE::foo
eval ' require CORE::lc "THREADS" ';
$i++;
if($@@ =~ /Can't locate threads in \@@INC/) {
    print "ok $i - [perl #24482] require CORE::foo\n";
} else {
    print "not ok - [perl #24482] require CORE::foo\n";
}

a266 15

{
    # if we 'require "op"', since we're in the t/ directory and '.' is the
    # first thing in @@INC, it will try to load t/op/; it should fail and
    # move onto the next path; however, the previous value of $! was
    # leaking into implementation if it was EACCES and we're accessing a
    # directory.

    $! = eval 'use Errno qw(EACCES); EACCES' || 0;
    eval q{require 'op'};
    $i++;
    print "not " if $@@ =~ /Permission denied/;
    print "ok $i - require op\n";
}

d333 1
a333 1
    foreach my $file (@@files_to_delete) {
@


