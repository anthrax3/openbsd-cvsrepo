head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.12
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.6
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.8
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.7.0.4
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.18
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.16
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.48.31;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.49.20;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

# Tests the scoping of $^H and %^H

BEGIN {
    @@INC = qw(. ../lib ../ext/re);
    chdir 't' if -d 't';
}

BEGIN { print "1..31\n"; }
BEGIN {
    print "not " if exists $^H{foo};
    print "ok 1 - \$^H{foo} doesn't exist initially\n";
    if (${^OPEN}) {
	print "not " unless $^H & 0x00020000;
	print "ok 2 - \$^H contains HINT_LOCALIZE_HH initially with ${^OPEN}\n";
    } else {
	print "not " if $^H & 0x00020000;
	print "ok 2 - \$^H doesn't contain HINT_LOCALIZE_HH initially\n";
    }
}
{
    # simulate a pragma -- don't forget HINT_LOCALIZE_HH
    BEGIN { $^H |= 0x04020000; $^H{foo} = "a"; }
    BEGIN {
	print "not " if $^H{foo} ne "a";
	print "ok 3 - \$^H{foo} is now 'a'\n";
	print "not " unless $^H & 0x00020000;
	print "ok 4 - \$^H contains HINT_LOCALIZE_HH while compiling\n";
    }
    {
	BEGIN { $^H |= 0x00020000; $^H{foo} = "b"; }
	BEGIN {
	    print "not " if $^H{foo} ne "b";
	    print "ok 5 - \$^H{foo} is now 'b'\n";
	}
    }
    BEGIN {
	print "not " if $^H{foo} ne "a";
	print "ok 6 - \$^H{foo} restored to 'a'\n";
    }
    # The pragma settings disappear after compilation
    # (test at CHECK-time and at run-time)
    CHECK {
	print "not " if exists $^H{foo};
	print "ok 9 - \$^H{foo} doesn't exist when compilation complete\n";
	if (${^OPEN}) {
	    print "not " unless $^H & 0x00020000;
	    print "ok 10 - \$^H contains HINT_LOCALIZE_HH when compilation complete with ${^OPEN}\n";
	} else {
	    print "not " if $^H & 0x00020000;
	    print "ok 10 - \$^H doesn't contain HINT_LOCALIZE_HH when compilation complete\n";
	}
    }
    print "not " if exists $^H{foo};
    print "ok 11 - \$^H{foo} doesn't exist at runtime\n";
    if (${^OPEN}) {
	print "not " unless $^H & 0x00020000;
	print "ok 12 - \$^H contains HINT_LOCALIZE_HH at run-time with ${^OPEN}\n";
    } else {
	print "not " if $^H & 0x00020000;
	print "ok 12 - \$^H doesn't contain HINT_LOCALIZE_HH at run-time\n";
    }
    # op_entereval should keep the pragmas it was compiled with
    eval q*
      BEGIN {
	print "not " if $^H{foo} ne "a";
	print "ok 13 - \$^H{foo} is 'a' at eval-\"\" time\n";
	print "not " unless $^H & 0x00020000;
	print "ok 14 - \$^H contains HINT_LOCALIZE_HH at eval\"\"-time\n";
      }
    *;
}
BEGIN {
    print "not " if exists $^H{foo};
    print "ok 7 - \$^H{foo} doesn't exist while finishing compilation\n";
    if (${^OPEN}) {
	print "not " unless $^H & 0x00020000;
	print "ok 8 - \$^H contains HINT_LOCALIZE_HH while finishing compilation with ${^OPEN}\n";
    } else {
	print "not " if $^H & 0x00020000;
	print "ok 8 - \$^H doesn't contain HINT_LOCALIZE_HH while finishing compilation\n";
    }
}

{
    BEGIN{$^H{x}=1};
    for my $tno (15..16) {
        eval q(
            BEGIN {
                print $^H{x}==1 && !$^H{y} ? "ok $tno\n" : "not ok $tno\n";
            }
            $^H{y} = 1;
        );
        if ($@@) {
            (my $str = $@@)=~s/^/# /gm;
            print "not ok $tno\n$str\n";
        }
    }
}

{
    BEGIN { $^H |= 0x04000000; $^H{foo} = "z"; }

    our($ri0, $rf0); BEGIN { $ri0 = $^H; $rf0 = $^H{foo}; }
    print +($ri0 & 0x04000000 ? "" : "not "), "ok 17 - \$^H correct before require\n";
    print +($rf0 eq "z" ? "" : "not "), "ok 18 - \$^H{foo} correct before require\n";

    our($ra1, $ri1, $rf1, $rfe1);
    BEGIN { require "comp/hints.aux"; }
    print +(!($ri1 & 0x04000000) ? "" : "not "), "ok 19 - \$^H cleared for require\n";
    print +(!defined($rf1) && !$rfe1 ? "" : "not "), "ok 20 - \$^H{foo} cleared for require\n";

    our($ri2, $rf2); BEGIN { $ri2 = $^H; $rf2 = $^H{foo}; }
    print +($ri2 & 0x04000000 ? "" : "not "), "ok 21 - \$^H correct after require\n";
    print +($rf2 eq "z" ? "" : "not "), "ok 22 - \$^H{foo} correct after require\n";
}

# [perl #73174]

{
    my $res;
    BEGIN { $^H{73174} = "foo" }
    BEGIN { $res = ($^H{73174} // "") }
    # /x{100}/i forces loading of utf8.pm, which used to reset %^H
    eval '"" =~ /\x{100}/i; 1'
	# Allow miniperl to fail this regexp compilation (effectively skip
	# the test) in case tables have not been build, but require real
	# perl to succeed.
	or defined &DynaLoader::boot_DynaLoader and die;	
    BEGIN { $res .= '-' . ($^H{73174} // "")}
    $res .= '-' . ($^H{73174} // "");
    print $res eq "foo-foo-" ? "" : "not ",
	"ok 23 - \$^H{foo} correct after /unicode/i (res=$res)\n";
}

# [perl #106282] Crash when tying %^H
# Tying %^H should not result in a crash when the hint hash is cloned.
# Hints should also be copied properly to inner scopes.  See also
# [rt.cpan.org #73402].
eval q`
    # Do something naughty enough, and you get your module mentioned in the
    # test suite. :-)
    package namespace::clean::_TieHintHash;

    sub TIEHASH  { bless[] }
    sub STORE    { $_[0][0]{$_[1]} = $_[2] }
    sub FETCH    { $_[0][0]{$_[1]} }
    sub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }
    sub NEXTKEY  { each %{$_[0][0]} }

    package main;

    BEGIN {
	$^H{foo} = "bar"; # activate localisation magic
	tie( %^H, 'namespace::clean::_TieHintHash' ); # sabotage %^H
	$^H{foo} = "bar"; # create an element in the tied hash
    }
    { # clone the tied hint hash on scope entry
	BEGIN {
	    print "not " x ($^H{foo} ne 'bar'),
		  "ok 24 - tied hint hash is copied to inner scope\n";
	    %^H = ();
	    tie( %^H, 'namespace::clean::_TieHintHash' );
	    $^H{foo} = "bar";
	}
	{
	    BEGIN{
		print
		  "not " x ($^H{foo} ne 'bar'),
		  "ok 25 - tied empty hint hash is copied to inner scope\n"
	    }    
	}
	1;
    }
    1;
` or warn $@@;
print "ok 26 - no crash when cloning a tied hint hash\n";

{
    my $w;
    local $SIG{__WARN__} = sub { $w = shift };
    eval q`
	package namespace::clean::_TieHintHasi;
    
	sub TIEHASH  { bless[] }
	sub STORE    { $_[0][0]{$_[1]} = $_[2] }
	sub FETCH    { $_[0][0]{$_[1]} }
	sub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }
      # Intentionally commented out:
      #  sub NEXTKEY  { each %{$_[0][0]} }
    
	package main;
    
	BEGIN {
    	    $^H{foo} = "bar"; # activate localisation magic
    	    tie( %^H, 'namespace::clean::_TieHintHasi' ); # sabotage %^H
    	    $^H{foo} = "bar"; # create an element in the tied hash
	}
	{ ; } # clone the tied hint hash
    `;
    print "not " if $w;
    print "ok 27 - double-freeing explosive tied hints hash\n";
    print "# got: $w" if $w;
}

# Setting ${^WARNING_HINTS} to its own value should not change things.
{
    my $w;
    local $SIG{__WARN__} = sub { $w++ };
    BEGIN {
	# should have no effect:
	my $x = ${^WARNING_BITS};
	${^WARNING_BITS} = $x;
    }
    {
	local $^W = 1;
	() = 1 + undef;
    }
    print "# ", $w//'no', " warnings\nnot " unless $w == 1;
    print "ok 28 - ",
          "setting \${^WARNING_BITS} to its own value has no effect\n";
}

# [perl #112326]
# this code could cause a crash, due to PL_hints continuing to point to th
# hints hash currently being freed

{
    package Foo;
    my @@h = qw(a 1 b 2);
    BEGIN {
	$^H{FOO} = bless {};
    }
    sub DESTROY {
	@@h = %^H;
	delete $INC{strict}; require strict; # boom!
    }
    my $h = join ':', %h;
    # this isn't the main point of the test; the main point is that
    # it doesn't crash!
    print "not " if $h ne '';
    print "ok 29 - #112326\n";
}


# [perl #112444]
# A destructor called while %^H is freed should not be able to stop %^H
# from being magical (due to *^H{HASH} being undef).
{
    BEGIN {
	# Make sure %^H is clear and not localised, to begin with
	%^H = ();
	$^H = 0;
    }
    DESTROY { %^H }
    {
	{
	    BEGIN {
		$^H{foom} = bless[];
	    }
	} # scope exit triggers destructor, which autovivifies a non-
	  # magical %^H
	BEGIN {
	    # Here we have the %^H created by DESTROY, which is
	    # not localised
	    $^H{112444} = 'baz';
	}
    } # %^H leaks on scope exit
    BEGIN { @@keez = keys %^H }
}
print "not " if @@keez;
print "ok 30 - %^H does not leak when autovivified in destructor\n";
print "# keys are: @@keez\n" if @@keez;


# Add new tests above this require, in case it fails.
require './test.pl';

# bug #27040: hints hash was being double-freed
my $result = runperl(
    prog => '$^H |= 0x20000; eval q{BEGIN { $^H |= 0x20000 }}',
    stderr => 1
);
print "not " if length $result;
print "ok 31 - double-freeing hints hash\n";
print "# got: $result\n" if length $result;

__END__
# Add new tests above require 'test.pl'
@


1.1
log
@Initial revision
@
text
@d1 3
a3 1
#!./perl -w
d5 6
a10 1
BEGIN { print "1..7\n"; }
d14 7
d24 1
a24 1
    BEGIN { $^H |= 0x00020000; $^H{foo} = "a"; }
d27 3
a29 1
	print "ok 2 - \$^H{foo} is now 'a'\n";
d35 1
a35 1
	    print "ok 3 - \$^H{foo} is now 'b'\n";
d40 1
a40 1
	print "ok 4 - \$H^{foo} restored to 'a'\n";
d42 2
d46 8
a53 1
	print "ok 6 - \$^H{foo} doesn't exist when compilation complete\n";
d56 17
a72 1
    print "ok 7 - \$^H{foo} doesn't exist at runtime\n";
d76 8
a83 1
    print "ok 5 - \$^H{foo} doesn't exist while finishing compilation\n";
d85 206
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d1 1
a1 1
#!./perl
d3 1
a3 3
# Tests the scoping of $^H and %^H

BEGIN { print "1..14\n"; }
a6 2
    print "not " if $^H & 0x00020000;
    print "ok 2 - \$^H doesn't contain HINT_LOCALIZE_HH initially\n";
d13 1
a13 3
	print "ok 3 - \$^H{foo} is now 'a'\n";
	print "not " unless $^H & 0x00020000;
	print "ok 4 - \$^H contains HINT_LOCALIZE_HH while compiling\n";
d19 1
a19 1
	    print "ok 5 - \$^H{foo} is now 'b'\n";
d24 1
a24 1
	print "ok 6 - \$H^{foo} restored to 'a'\n";
a25 2
    # The pragma settings disappear after compilation
    # (test at CHECK-time and at run-time)
d28 1
a28 3
	print "ok 9 - \$^H{foo} doesn't exist when compilation complete\n";
	print "not " if $^H & 0x00020000;
	print "ok 10 - \$^H doesn't contain HINT_LOCALIZE_HH when compilation complete\n";
d31 1
a31 10
    print "ok 11 - \$^H{foo} doesn't exist at runtime\n";
    print "not " if $^H & 0x00020000;
    print "ok 12 - \$^H doesn't contain HINT_LOCALIZE_HH at run-time\n";
    # op_entereval should keep the pragmas it was compiled with
    eval q*
	print "not " if $^H{foo} ne "a";
	print "ok 13 - \$^H{foo} is 'a' at eval-\"\" time # TODO\n";
	print "not " unless $^H & 0x00020000;
	print "ok 14 - \$^H contains HINT_LOCALIZE_HH at eval\"\"-time\n";
    *;
d35 1
a35 3
    print "ok 7 - \$^H{foo} doesn't exist while finishing compilation\n";
    print "not " if $^H & 0x00020000;
    print "ok 8 - \$^H doesn't contain HINT_LOCALIZE_HH while finishing compilation\n";
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d5 1
a5 7
BEGIN {
    chdir 't' if -d 't';
    @@INC = qw(. ../lib);
}


BEGIN { print "1..15\n"; }
a57 12

require 'test.pl';

# bug #27040: hints hash was being double-freed
my $result = runperl(
    prog => '$^H |= 0x20000; eval q{BEGIN { $^H |= 0x20000 }}',
    stderr => 1
);
print "not " if length $result;
print "ok 15 - double-freeing hints hash\n";
print "# got: $result\n" if length $result;

@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d11 1
a11 1
BEGIN { print "1..17\n"; }
d15 2
a16 7
    if (${^OPEN}) {
	print "not " unless $^H & 0x00020000;
	print "ok 2 - \$^H contains HINT_LOCALIZE_HH initially with ${^OPEN}\n";
    } else {
	print "not " if $^H & 0x00020000;
	print "ok 2 - \$^H doesn't contain HINT_LOCALIZE_HH initially\n";
    }
d20 1
a20 1
    BEGIN { $^H |= 0x04020000; $^H{foo} = "a"; }
d43 2
a44 7
	if (${^OPEN}) {
	    print "not " unless $^H & 0x00020000;
	    print "ok 10 - \$^H contains HINT_LOCALIZE_HH when compilation complete with ${^OPEN}\n";
	} else {
	    print "not " if $^H & 0x00020000;
	    print "ok 10 - \$^H doesn't contain HINT_LOCALIZE_HH when compilation complete\n";
	}
d48 2
a49 7
    if (${^OPEN}) {
	print "not " unless $^H & 0x00020000;
	print "ok 12 - \$^H contains HINT_LOCALIZE_HH at run-time with ${^OPEN}\n";
    } else {
	print "not " if $^H & 0x00020000;
	print "ok 12 - \$^H doesn't contain HINT_LOCALIZE_HH at run-time\n";
    }
d53 1
a53 1
	print "ok 13 - \$^H{foo} is 'a' at eval-\"\" time\n";
d61 2
a62 7
    if (${^OPEN}) {
	print "not " unless $^H & 0x00020000;
	print "ok 8 - \$^H contains HINT_LOCALIZE_HH while finishing compilation with ${^OPEN}\n";
    } else {
	print "not " if $^H & 0x00020000;
	print "ok 8 - \$^H doesn't contain HINT_LOCALIZE_HH while finishing compilation\n";
    }
a75 13
{
    BEGIN{$^H{x}=1};
    for(1..2) {
        eval q(
            print $^H{x}==1 && !$^H{y} ? "ok\n" : "not ok\n";
            $^H{y} = 1;
        );
        if ($@@) {
            (my $str = $@@)=~s/^/# /gm;
            print "not ok\n$str\n";
        }
    }
}
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d6 1
d10 2
a11 1
BEGIN { print "1..24\n"; }
d41 1
a41 1
	print "ok 6 - \$^H{foo} restored to 'a'\n";
d85 11
d98 1
a98 1
    for my $tno (15..16) {
d100 1
a100 1
            print $^H{x}==1 && !$^H{y} ? "ok $tno\n" : "not ok $tno\n";
d105 1
a105 1
            print "not ok $tno\n$str\n";
a108 47

{
    BEGIN { $^H |= 0x04000000; $^H{foo} = "z"; }

    our($ri0, $rf0); BEGIN { $ri0 = $^H; $rf0 = $^H{foo}; }
    print +($ri0 & 0x04000000 ? "" : "not "), "ok 17 - \$^H correct before require\n";
    print +($rf0 eq "z" ? "" : "not "), "ok 18 - \$^H{foo} correct before require\n";

    our($ra1, $ri1, $rf1, $rfe1);
    BEGIN { require "comp/hints.aux"; }
    print +(!($ri1 & 0x04000000) ? "" : "not "), "ok 19 - \$^H cleared for require\n";
    print +(!defined($rf1) && !$rfe1 ? "" : "not "), "ok 20 - \$^H{foo} cleared for require\n";

    our($ri2, $rf2); BEGIN { $ri2 = $^H; $rf2 = $^H{foo}; }
    print +($ri2 & 0x04000000 ? "" : "not "), "ok 21 - \$^H correct after require\n";
    print +($rf2 eq "z" ? "" : "not "), "ok 22 - \$^H{foo} correct after require\n";
}

# [perl #73174]

{
    my $res;
    BEGIN { $^H{73174} = "foo" }
    BEGIN { $res = ($^H{73174} // "") }
    "" =~ /\x{100}/i;	# forces loading of utf8.pm, which used to reset %^H
    BEGIN { $res .= '-' . ($^H{73174} // "")}
    $res .= '-' . ($^H{73174} // "");
    print $res eq "foo-foo-" ? "" : "not ",
	"ok 23 - \$^H{foo} correct after /unicode/i (res=$res)\n";
}



# Add new tests above this require, in case it fails.
require './test.pl';

# bug #27040: hints hash was being double-freed
my $result = runperl(
    prog => '$^H |= 0x20000; eval q{BEGIN { $^H |= 0x20000 }}',
    stderr => 1
);
print "not " if length $result;
print "ok 24 - double-freeing hints hash\n";
print "# got: $result\n" if length $result;

__END__
# Add new tests above require 'test.pl'
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
BEGIN { print "1..31\n"; }
a64 1
      BEGIN {
a68 1
      }
d87 1
a87 3
            BEGIN {
                print $^H{x}==1 && !$^H{y} ? "ok $tno\n" : "not ok $tno\n";
            }
a126 138
# [perl #106282] Crash when tying %^H
# Tying %^H should not result in a crash when the hint hash is cloned.
# Hints should also be copied properly to inner scopes.  See also
# [rt.cpan.org #73402].
eval q`
    # Do something naughty enough, and you get your module mentioned in the
    # test suite. :-)
    package namespace::clean::_TieHintHash;

    sub TIEHASH  { bless[] }
    sub STORE    { $_[0][0]{$_[1]} = $_[2] }
    sub FETCH    { $_[0][0]{$_[1]} }
    sub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }
    sub NEXTKEY  { each %{$_[0][0]} }

    package main;

    BEGIN {
	$^H{foo} = "bar"; # activate localisation magic
	tie( %^H, 'namespace::clean::_TieHintHash' ); # sabotage %^H
	$^H{foo} = "bar"; # create an element in the tied hash
    }
    { # clone the tied hint hash on scope entry
	BEGIN {
	    print "not " x ($^H{foo} ne 'bar'),
		  "ok 24 - tied hint hash is copied to inner scope\n";
	    %^H = ();
	    tie( %^H, 'namespace::clean::_TieHintHash' );
	    $^H{foo} = "bar";
	}
	{
	    BEGIN{
		print
		  "not " x ($^H{foo} ne 'bar'),
		  "ok 25 - tied empty hint hash is copied to inner scope\n"
	    }    
	}
	1;
    }
    1;
` or warn $@@;
print "ok 26 - no crash when cloning a tied hint hash\n";

{
    my $w;
    local $SIG{__WARN__} = sub { $w = shift };
    eval q`
	package namespace::clean::_TieHintHasi;
    
	sub TIEHASH  { bless[] }
	sub STORE    { $_[0][0]{$_[1]} = $_[2] }
	sub FETCH    { $_[0][0]{$_[1]} }
	sub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }
      # Intentionally commented out:
      #  sub NEXTKEY  { each %{$_[0][0]} }
    
	package main;
    
	BEGIN {
    	    $^H{foo} = "bar"; # activate localisation magic
    	    tie( %^H, 'namespace::clean::_TieHintHasi' ); # sabotage %^H
    	    $^H{foo} = "bar"; # create an element in the tied hash
	}
	{ ; } # clone the tied hint hash
    `;
    print "not " if $w;
    print "ok 27 - double-freeing explosive tied hints hash\n";
    print "# got: $w" if $w;
}

# Setting ${^WARNING_HINTS} to its own value should not change things.
{
    my $w;
    local $SIG{__WARN__} = sub { $w++ };
    BEGIN {
	# should have no effect:
	my $x = ${^WARNING_BITS};
	${^WARNING_BITS} = $x;
    }
    {
	local $^W = 1;
	() = 1 + undef;
    }
    print "# ", $w//'no', " warnings\nnot " unless $w == 1;
    print "ok 28 - ",
          "setting \${^WARNING_BITS} to its own value has no effect\n";
}

# [perl #112326]
# this code could cause a crash, due to PL_hints continuing to point to th
# hints hash currently being freed

{
    package Foo;
    my @@h = qw(a 1 b 2);
    BEGIN {
	$^H{FOO} = bless {};
    }
    sub DESTROY {
	@@h = %^H;
	delete $INC{strict}; require strict; # boom!
    }
    my $h = join ':', %h;
    # this isn't the main point of the test; the main point is that
    # it doesn't crash!
    print "not " if $h ne '';
    print "ok 29 - #112326\n";
}


# [perl #112444]
# A destructor called while %^H is freed should not be able to stop %^H
# from being magical (due to *^H{HASH} being undef).
{
    BEGIN {
	# Make sure %^H is clear and not localised, to begin with
	%^H = ();
	$^H = 0;
    }
    DESTROY { %^H }
    {
	{
	    BEGIN {
		$^H{foom} = bless[];
	    }
	} # scope exit triggers destructor, which autovivifies a non-
	  # magical %^H
	BEGIN {
	    # Here we have the %^H created by DESTROY, which is
	    # not localised
	    $^H{112444} = 'baz';
	}
    } # %^H leaks on scope exit
    BEGIN { @@keez = keys %^H }
}
print "not " if @@keez;
print "ok 30 - %^H does not leak when autovivified in destructor\n";
print "# keys are: @@keez\n" if @@keez;
d138 1
a138 1
print "ok 31 - double-freeing hints hash\n";
@


1.1.1.7
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a6 1
    chdir 't';
@


