head	1.12;
access;
symbols
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.10
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.4
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.6
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	QP75iYx42Uo7mMxO;

1.10
date	2014.03.24.15.05.33;	author afresh1;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.25.20.40.59;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.15.07.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.18;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.47;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.35;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.06;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.07.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.27;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.00.06;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.41.17;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.10.38;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.25.03;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.10;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.49.19;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.46.22;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@perl 5.004_04
@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl
#
# Contributed by Graham Barr <Graham.Barr@@tiuk.ti.com>
#
# So far there are tests for the following prototypes.
# none, () ($) ($@@) ($%) ($;$) (&) (&\@@) (&@@) (%) (\%) (\@@)
#
# It is impossible to test every prototype that can be specified, but
# we should test as many as we can.
#

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

# We need this, as in places we're testing the interaction of prototypes with
# strict
use strict;

print "1..215\n";

my $i = 1;

sub testing (&$) {
    my $p = prototype(shift);
    my $c = shift;
    my $what = defined $c ? '(' . $p . ')' : 'no prototype';   
    print '#' x 25,"\n";
    print '# Testing ',$what,"\n";
    print '#' x 25,"\n";
    print "not "
	if((defined($p) && defined($c) && $p ne $c)
	   || (defined($p) != defined($c)));
    printf "ok %d\n",$i++;
}

@@_ = qw(a b c d);
my @@array;
my %hash;

##
##
##

testing \&no_proto, undef;

sub no_proto {
    print "# \@@_ = (",join(",",@@_),")\n";
    scalar(@@_)
}

print "not " unless 0 == no_proto();
printf "ok %d\n",$i++;

print "not " unless 1 == no_proto(5);
printf "ok %d\n",$i++;

print "not " unless 4 == &no_proto;
printf "ok %d\n",$i++;

print "not " unless 1 == no_proto +6;
printf "ok %d\n",$i++;

print "not " unless 4 == no_proto(@@_);
printf "ok %d\n",$i++;

##
##
##


testing \&no_args, '';

sub no_args () {
    print "# \@@_ = (",join(",",@@_),")\n";
    scalar(@@_)
}

print "not " unless 0 == no_args();
printf "ok %d\n",$i++;

print "not " unless 0 == no_args;
printf "ok %d\n",$i++;

print "not " unless 5 == no_args +5;
printf "ok %d\n",$i++;

print "not " unless 4 == &no_args;
printf "ok %d\n",$i++;

print "not " unless 2 == &no_args(1,2);
printf "ok %d\n",$i++;

eval "no_args(1)";
print "not " unless $@@;
printf "ok %d\n",$i++;

##
##
##

testing \&one_args, '$';

sub one_args ($) {
    print "# \@@_ = (",join(",",@@_),")\n";
    scalar(@@_)
}

print "not " unless 1 == one_args(1);
printf "ok %d\n",$i++;

print "not " unless 1 == one_args +5;
printf "ok %d\n",$i++;

print "not " unless 4 == &one_args;
printf "ok %d\n",$i++;

print "not " unless 2 == &one_args(1,2);
printf "ok %d\n",$i++;

eval "one_args(1,2)";
print "not " unless $@@;
printf "ok %d\n",$i++;

eval "one_args()";
print "not " unless $@@;
printf "ok %d\n",$i++;

sub one_a_args ($) {
    print "# \@@_ = (",join(",",@@_),")\n";
    print "not " unless @@_ == 1 && $_[0] == 4;
    printf "ok %d\n",$i++;
}

one_a_args(@@_);

##
##
##

testing \&over_one_args, '$@@';

sub over_one_args ($@@) {
    print "# \@@_ = (",join(",",@@_),")\n";
    scalar(@@_)
}

print "not " unless 1 == over_one_args(1);
printf "ok %d\n",$i++;

print "not " unless 2 == over_one_args(1,2);
printf "ok %d\n",$i++;

print "not " unless 1 == over_one_args +5;
printf "ok %d\n",$i++;

print "not " unless 4 == &over_one_args;
printf "ok %d\n",$i++;

print "not " unless 2 == &over_one_args(1,2);
printf "ok %d\n",$i++;

print "not " unless 5 == &over_one_args(1,@@_);
printf "ok %d\n",$i++;

eval "over_one_args()";
print "not " unless $@@;
printf "ok %d\n",$i++;

sub over_one_a_args ($@@) {
    print "# \@@_ = (",join(",",@@_),")\n";
    print "not " unless @@_ >= 1 && $_[0] == 4;
    printf "ok %d\n",$i++;
}

over_one_a_args(@@_);
over_one_a_args(@@_,1);
over_one_a_args(@@_,1,2);
over_one_a_args(@@_,@@_);

##
##
##

testing \&scalar_and_hash, '$%';

sub scalar_and_hash ($%) {
    print "# \@@_ = (",join(",",@@_),")\n";
    scalar(@@_)
}

print "not " unless 1 == scalar_and_hash(1);
printf "ok %d\n",$i++;

print "not " unless 3 == scalar_and_hash(1,2,3);
printf "ok %d\n",$i++;

print "not " unless 1 == scalar_and_hash +5;
printf "ok %d\n",$i++;

print "not " unless 4 == &scalar_and_hash;
printf "ok %d\n",$i++;

print "not " unless 2 == &scalar_and_hash(1,2);
printf "ok %d\n",$i++;

print "not " unless 5 == &scalar_and_hash(1,@@_);
printf "ok %d\n",$i++;

eval "scalar_and_hash()";
print "not " unless $@@;
printf "ok %d\n",$i++;

sub scalar_and_hash_a ($@@) {
    print "# \@@_ = (",join(",",@@_),")\n";
    print "not " unless @@_ >= 1 && $_[0] == 4;
    printf "ok %d\n",$i++;
}

scalar_and_hash_a(@@_);
scalar_and_hash_a(@@_,1);
scalar_and_hash_a(@@_,1,2);
scalar_and_hash_a(@@_,@@_);

##
##
##

testing \&one_or_two, '$;$';

sub one_or_two ($;$) {
    print "# \@@_ = (",join(",",@@_),")\n";
    scalar(@@_)
}

print "not " unless 1 == one_or_two(1);
printf "ok %d\n",$i++;

print "not " unless 2 == one_or_two(1,3);
printf "ok %d\n",$i++;

print "not " unless 1 == one_or_two +5;
printf "ok %d\n",$i++;

print "not " unless 4 == &one_or_two;
printf "ok %d\n",$i++;

print "not " unless 3 == &one_or_two(1,2,3);
printf "ok %d\n",$i++;

print "not " unless 5 == &one_or_two(1,@@_);
printf "ok %d\n",$i++;

eval "one_or_two()";
print "not " unless $@@;
printf "ok %d\n",$i++;

eval "one_or_two(1,2,3)";
print "not " unless $@@;
printf "ok %d\n",$i++;

sub one_or_two_a ($;$) {
    print "# \@@_ = (",join(",",@@_),")\n";
    print "not " unless @@_ >= 1 && $_[0] == 4;
    printf "ok %d\n",$i++;
}

one_or_two_a(@@_);
one_or_two_a(@@_,1);
one_or_two_a(@@_,@@_);

##
##
##

testing \&a_sub, '&';

sub a_sub (&) {
    print "# \@@_ = (",join(",",@@_),")\n";
    return unless defined $_[0];
    &{$_[0]};
}

sub tmp_sub_1 { printf "ok %d\n",$i++ }

a_sub { printf "ok %d\n",$i++ };
a_sub \&tmp_sub_1;
a_sub \(&tmp_sub_1);

@@array = ( \&tmp_sub_1 );
eval 'a_sub @@array';
print "not " unless $@@;
printf "ok %d\n",$i++;
eval 'a_sub \@@array';
print "not " unless $@@ =~ /Type of arg/;
printf "ok %d\n",$i++;
eval 'a_sub \%hash';
print "not " unless $@@ =~ /Type of arg/;
printf "ok %d\n",$i++;
eval 'a_sub \$scalar';
print "not " unless $@@ =~ /Type of arg/;
printf "ok %d\n",$i++;
eval 'a_sub \($list, %of, @@refs)';
print "not " unless $@@ =~ /Type of arg/;
printf "ok %d\n",$i++;
eval 'a_sub undef';
print "not " if $@@;
printf "ok %d\n",$i++;

##
##
##

testing \&a_subx, '\&';

sub a_subx (\&) {
    print "# \@@_ = (",join(",",@@_),")\n";
    &{$_[0]};
}

sub tmp_sub_2 { printf "ok %d\n",$i++ }
a_subx &tmp_sub_2;

@@array = ( \&tmp_sub_2 );
eval 'a_subx @@array';
print "not " unless $@@;
printf "ok %d\n",$i++;
my $bad =
    qr/Type of arg 1 to .* must be subroutine \(not subroutine entry\)/;
eval 'a_subx &tmp_sub_2()';
print "not " unless $@@ =~ $bad;
printf "ok %d - \\& prohibits &foo()\n",$i++;
eval 'a_subx tmp_sub_2()';
print "not " unless $@@ =~ $bad;
printf "ok %d - \\& prohibits foo()\n",$i++;
eval 'a_subx tmp_sub_2';
print "not " unless $@@ =~ $bad;
printf "ok %d - \\& prohibits foo where foo is an existing sub\n",$i++;

##
##
##

testing \&sub_aref, '&\@@';

sub sub_aref (&\@@) {
    print "# \@@_ = (",join(",",@@_),")\n";
    my($sub,$array) = @@_;
    print "not " unless @@_ == 2 && @@{$array} == 4;
    print map { &{$sub}($_) } @@{$array}
}

@@array = (qw(O K)," ", $i++);
sub_aref { lc shift } @@array;
print "\n";

##
##
##

testing \&sub_array, '&@@';

sub sub_array (&@@) {
    print "# \@@_ = (",join(",",@@_),")\n";
    print "not " unless @@_ == 5;
    my $sub = shift;
    print map { &{$sub}($_) } @@_
}

@@array = (qw(O K)," ", $i++);
sub_array { lc shift } @@array;
sub_array { lc shift } ('O', 'K', ' ', $i++);
print "\n";

##
##
##

testing \&a_hash, '%';

sub a_hash (%) {
    print "# \@@_ = (",join(",",@@_),")\n";
    scalar(@@_);
}

print "not " unless 1 == a_hash 'a';
printf "ok %d\n",$i++;

print "not " unless 2 == a_hash 'a','b';
printf "ok %d\n",$i++;

##
##
##

testing \&a_hash_ref, '\%';

sub a_hash_ref (\%) {
    print "# \@@_ = (",join(",",@@_),")\n";
    print "not " unless ref($_[0]) && $_[0]->{'a'};
    printf "ok %d\n",$i++;
    $_[0]->{'b'} = 2;
}

%hash = ( a => 1);
a_hash_ref %hash;
print "not " unless $hash{'b'} == 2;
printf "ok %d\n",$i++;

%hash = ( a => 1);
a_hash_ref +(%hash);
print "not " unless $hash{'b'} == 2;
printf "ok %d\n",$i++;

##
##
##

testing \&array_ref_plus, '\@@@@';

sub array_ref_plus (\@@@@) {
    print "# \@@_ = (",join(",",@@_),")\n";
    print "not " unless @@_ == 2 && ref($_[0]) && 1 == @@{$_[0]} && $_[1] eq 'x';
    printf "ok %d\n",$i++;
    @@{$_[0]} = (qw(ok)," ",$i++,"\n");
}

@@array = ('a');
{ my @@more = ('x');
  array_ref_plus @@array, @@more; }
print "not " unless @@array == 4;
print @@array;

@@array = ('a');
{ my @@more = ('x');
  array_ref_plus +(@@array), @@more; }
print "not " unless @@array == 4;
print @@array;

##
##
##

my $p;
print "not " if defined prototype('CORE::print');
print "ok ", $i++, "\n";

print "not " if defined prototype('CORE::system');
print "ok ", $i++, "\n";

print "# CORE::open => ($p)\nnot " if ($p = prototype('CORE::open')) ne '*;$@@';
print "ok ", $i++, "\n";

print "# CORE::Foo => ($p), \$@@ => '$@@'\nnot " 
    if defined ($p = eval { prototype('CORE::Foo') or 1 }) or $@@ !~ /^Can't find an opnumber/;
print "ok ", $i++, "\n";

eval { prototype("CORE::a\0b") };
print "# CORE::a\\0b: \$@@ => '$@@'\nnot " 
    if $@@ !~ /^Can't find an opnumber for "a\0b"/;
print "ok ", $i++, "\n";

eval { prototype("CORE::\x{100}") };
print "# CORE::\\x{100}: => ($p), \$@@ => '$@@'\nnot " 
    if $@@ !~ /^Can't find an opnumber for "\x{100}"/;
print "ok ", $i++, "\n";

"CORE::Foo" =~ /(.*)/;
print "# \$1 containing CORE::Foo => ($p), \$@@ => '$@@'\nnot " 
    if defined ($p = eval { prototype($1) or 1 })
    or $@@ !~ /^Can't find an opnumber/;
print "ok ", $i++, " - \$1 containing CORE::Foo\n";

# correctly note too-short parameter lists that don't end with '$',
#  a possible regression.

sub foo1 ($\@@);
eval q{ foo1 "s" };
print "not " unless $@@ =~ /^Not enough/;
print "ok ", $i++, "\n";

sub foo2 ($\%);
eval q{ foo2 "s" };
print "not " unless $@@ =~ /^Not enough/;
print "ok ", $i++, "\n";

sub X::foo3;
*X::foo3 = sub {'ok'};
print "# $@@not " unless eval {X->foo3} eq 'ok';
print "ok ", $i++, "\n";

sub X::foo4 ($);
*X::foo4 = sub ($) {'ok'};
print "not " unless X->foo4 eq 'ok';
print "ok ", $i++, "\n";

# test if the (*) prototype allows barewords, constants, scalar expressions,
# globs and globrefs (just as CORE::open() does), all under stricture
sub star (*&) { &{$_[1]} }
sub star2 (**&) { &{$_[2]} }
sub BAR { "quux" }
sub Bar::BAZ { "quuz" }
my $star = 'FOO';
star FOO, sub {
    print "not " unless $_[0] eq 'FOO';
    print "ok $i - star FOO\n";
}; $i++;
star(FOO, sub {
	print "not " unless $_[0] eq 'FOO';
	print "ok $i - star(FOO)\n";
    }); $i++;
star "FOO", sub {
    print "not " unless $_[0] eq 'FOO';
    print qq/ok $i - star "FOO"\n/;
}; $i++;
star("FOO", sub {
	print "not " unless $_[0] eq 'FOO';
	print qq/ok $i - star("FOO")\n/;
    }); $i++;
star $star, sub {
    print "not " unless $_[0] eq 'FOO';
    print "ok $i - star \$star\n";
}; $i++;
star($star, sub {
	print "not " unless $_[0] eq 'FOO';
	print "ok $i - star(\$star)\n";
    }); $i++;
star *FOO, sub {
    print "not " unless $_[0] eq \*FOO;
    print "ok $i - star *FOO\n";
}; $i++;
star(*FOO, sub {
	print "not " unless $_[0] eq \*FOO;
	print "ok $i - star(*FOO)\n";
    }); $i++;
star \*FOO, sub {
    print "not " unless $_[0] eq \*FOO;
    print "ok $i - star \\*FOO\n";
}; $i++;
star(\*FOO, sub {
	print "not " unless $_[0] eq \*FOO;
	print "ok $i - star(\\*FOO)\n";
    }); $i++;
star2 FOO, BAR, sub {
    print "not " unless $_[0] eq 'FOO' and $_[1] eq 'quux';
    print "ok $i - star2 FOO, BAR\n";
}; $i++;
star2(Bar::BAZ, FOO, sub {
	print "not " unless $_[0] eq 'quuz' and $_[1] eq 'FOO';
	print "ok $i - star2(Bar::BAZ, FOO)\n"
    }); $i++;
star2 BAR(), FOO, sub {
    print "not " unless $_[0] eq 'quux' and $_[1] eq 'FOO';
    print "ok $i - star2 BAR(), FOO\n"
}; $i++;
star2(FOO, BAR(), sub {
	print "not " unless $_[0] eq 'FOO' and $_[1] eq 'quux';
	print "ok $i - star2(FOO, BAR())\n";
    }); $i++;
star2 "FOO", "BAR", sub {
    print "not " unless $_[0] eq 'FOO' and $_[1] eq 'BAR';
    print qq/ok $i - star2 "FOO", "BAR"\n/;
}; $i++;
star2("FOO", "BAR", sub {
	print "not " unless $_[0] eq 'FOO' and $_[1] eq 'BAR';
	print qq/ok $i - star2("FOO", "BAR")\n/;
    }); $i++;
star2 $star, $star, sub {
    print "not " unless $_[0] eq 'FOO' and $_[1] eq 'FOO';
    print "ok $i - star2 \$star, \$star\n";
}; $i++;
star2($star, $star, sub {
	print "not " unless $_[0] eq 'FOO' and $_[1] eq 'FOO';
	print "ok $i - star2(\$star, \$star)\n";
    }); $i++;
star2 *FOO, *BAR, sub {
    print "not " unless $_[0] eq \*FOO and $_[1] eq \*BAR;
    print "ok $i - star2 *FOO, *BAR\n";
}; $i++;
star2(*FOO, *BAR, sub {
	print "not " unless $_[0] eq \*FOO and $_[1] eq \*BAR;
	print "ok $i - star2(*FOO, *BAR)\n";
    }); $i++;
star2 \*FOO, \*BAR, sub {
    no strict 'refs';
    print "not " unless $_[0] eq \*{'FOO'} and $_[1] eq \*{'BAR'};
    print "ok $i - star2 \*FOO, \*BAR\n";
}; $i++;
star2(\*FOO, \*BAR, sub {
	no strict 'refs';
	print "not " unless $_[0] eq \*{'FOO'} and $_[1] eq \*{'BAR'};
	print "ok $i - star2(\*FOO, \*BAR)\n";
    }); $i++;

# [perl #118585]
# Test that multiple semicolons are treated as one with *
sub star3(;;;*){}
sub star4( ; ; ; ; *){}
print "not " unless eval 'star3 STDERR; 1';
print "ok ", $i++, " star3 STDERR\n";
print "not " unless eval 'star4 STDERR; 1';
print "ok ", $i++, " star4 STDERR\n";

# [perl #2726]
# Test that prototype binding is late
print "not " unless eval 'sub l564($){ l564(); } 1';
print "ok ", $i++, " prototype checking not done within initial definition\n";
print "not " if eval 'sub l566($); sub l566($){ l566(); } 1';
print "ok ", $i++, " prototype checking done if sub pre-declared\n";

# test scalarref prototype
sub sreftest (\$$) {
    print "not " unless ref $_[0];
    print "ok $_[1] - sreftest\n";
}
{
    no strict 'vars';
    sreftest my $sref, $i++;
    sreftest($helem{$i}, $i++);
    sreftest $aelem[0], $i++;
    sreftest sub { [0] }->()[0], $i++;
    sreftest my $a = 'quidgley', $i++;
    print "not " if eval 'return 1; sreftest(3+4)';
    print "ok ", $i++, ' - \$ with invalid argument', "\n";
}

# test single term
sub lazy (+$$) {
    print "not " unless @@_ == 3 && ref $_[0] eq $_[1];
    print "ok $_[2] - non container test\n";
}
sub quietlazy (+) { return shift(@@_) }
sub give_aref { [] }
sub list_or_scalar { wantarray ? (1..10) : [] }
{
    my @@multiarray = ("a".."z");
    my %bighash = @@multiarray;
    lazy(\@@multiarray, 'ARRAY', $i++);
    lazy(\%bighash, 'HASH', $i++);
    lazy({}, 'HASH', $i++);
    lazy(give_aref, 'ARRAY', $i++);
    lazy(3, '', $i++); # allowed by prototype, even if runtime error
    lazy(list_or_scalar, 'ARRAY', $i++); # propagate scalar context
}

# test prototypes when they are evaled and there is a syntax error
# Byacc generates the string "syntax error".  Bison gives the
# string "parse error".
#
for my $p ( "", qw{ () ($) ($@@) ($%) ($;$) (&) (&\@@) (&@@) (%) (\%) (\@@) } ) {
  my $warn = "";
  local $SIG{__WARN__} = sub {
    my $thiswarn = join("",@@_);
    return if $thiswarn =~ /^Prototype mismatch: sub main::evaled_subroutine/;
    $warn .= $thiswarn;
  };
  my $eval = "sub evaled_subroutine $p { &void *; }";
  eval $eval;
  print "# eval[$eval]\nnot " unless $@@ && $@@ =~ /(parse|syntax) error/i;
  print "ok ", $i++, "\n";
  if ($warn eq '') {
     print "ok ", $i++, "\n";
  } else {
    print "not ok ", $i++, "# $warn \n";
  }
}

{
    my $myvar;
    my @@myarray;
    my %myhash;
    sub mysub { print "not calling mysub I hope\n" }
    local *myglob;

    sub myref (\[$@@%&*]) { print "# $_[0]\n"; return "$_[0]" }

    print "not " unless myref($myvar)   =~ /^SCALAR\(/;
    print "ok ", $i++, "\n";
    print "not " unless myref($myvar=7) =~ /^SCALAR\(/;
    print "ok ", $i++, "\n";
    print "not " unless myref(@@myarray) =~ /^ARRAY\(/;
    print "ok ", $i++, "\n";
    print "not " unless myref(%myhash)  =~ /^HASH\(/;
    print "ok ", $i++, "\n";
    print "not " unless myref(&mysub)   =~ /^CODE\(/;
    print "ok ", $i++, "\n";
    print "not " unless myref(*myglob)  =~ /^GLOB\(/;
    print "ok ", $i++, "\n";

    eval q/sub multi1 (\[%@@]) { 1 } multi1 $myvar;/;
    print "not "
	unless $@@ =~ /Type of arg 1 to main::multi1 must be one of \[%\@@\] /;
    print "ok ", $i++, "\n";
    eval q/sub multi2 (\[$*&]) { 1 } multi2 @@myarray;/;
    print "not "
	unless $@@ =~ /Type of arg 1 to main::multi2 must be one of \[\$\*&\] /;
    print "ok ", $i++, "\n";
    eval q/sub multi3 (\[$@@]) { 1 } multi3 %myhash;/;
    print "not "
	unless $@@ =~ /Type of arg 1 to main::multi3 must be one of \[\$\@@\] /;
    print "ok ", $i++, "\n";
    eval q/sub multi4 ($\[%]) { 1 } multi4 1, &mysub;/;
    print "not "
	unless $@@ =~ /Type of arg 2 to main::multi4 must be one of \[%\] /;
    print "ok ", $i++, "\n";
    eval q/sub multi5 (\[$@@]$) { 1 } multi5 *myglob;/;
    print "not "
	unless $@@ =~ /Type of arg 1 to main::multi5 must be one of \[\$\@@\] /
	    && $@@ =~ /Not enough arguments/;
    print "ok ", $i++, "\n";
}

# check that obviously bad prototypes are getting warnings
{
  local $^W = 1;
  my $warn = "";
  local $SIG{__WARN__} = sub { $warn .= join("",@@_) };
  
  eval 'sub badproto (@@bar) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto : \@@bar/;
  print "ok ", $i++, " checking badproto - (\@@bar)\n";

  eval 'sub badproto2 (bar) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto2 : bar/;
  print "ok ", $i++, " checking badproto2 - (bar)\n";
  
  eval 'sub badproto3 (&$bar$@@) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto3 : &\$bar\$\@@/;
  print "ok ", $i++, " checking badproto3 - (&\$bar\$\@@)\n";
  
  eval 'sub badproto4 (@@ $b ar) { 1; }';
  # This one emits two warnings
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto4 : \@@ \$b ar/;
  print "ok ", $i++, " checking badproto4 - (\@@ \$b ar) - illegal character\n";
  print "not " unless $warn =~ /Prototype after '\@@' for main::badproto4 : \@@ \$b ar/;
  print "ok ", $i++, " checking badproto4 - (\@@ \$b ar) - prototype after '\@@'\n";

  eval 'sub badproto5 ($_$) { 1; }';
  print "not " unless $warn =~ /Illegal character after '_' in prototype for main::badproto5 : \$_\$/;
  print "ok ", $i++, " checking badproto5 - (\$_\$) - illegal character after '_'\n";
  print "not " if $warn =~ /Illegal character in prototype for main::badproto5 : \$_\$/;
  print "ok ", $i++, " checking badproto5 - (\$_\$) - but not just illegal character\n";

  eval 'sub badproto6 (bar_) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto6 : bar_/;
  print "ok ", $i++, " checking badproto6 - (bar_) - illegal character\n";
  print "not " if $warn =~ /Illegal character after '_' in prototype for main::badproto6 : bar_/;
  print "ok ", $i++, " checking badproto6 - (bar_) - shouldn't add \"after '_'\"\n";

  eval 'sub badproto7 (_;bar) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto7 : _;bar/;
  print "ok ", $i++, " checking badproto7 - (_;bar) - illegal character\n";
  print "not " if $warn =~ /Illegal character after '_' in prototype for main::badproto7 : _;bar/;
  print "ok ", $i++, " checking badproto7 - (_;bar) - shouldn't add \"after '_'\"\n";

  eval 'sub badproto8 (_b) { 1; }';
  print "not " unless $warn =~ /Illegal character after '_' in prototype for main::badproto8 : _b/;
  print "ok ", $i++, " checking badproto8 - (_b) - illegal character after '_'\n";
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto8 : _b/;
  print "ok ", $i++, " checking badproto8 - (_b) - just illegal character\n";

  eval 'sub badproto9 ([) { 1; }';
  print "not " unless $warn =~ /Missing '\]' in prototype for main::badproto9 : \[/;
  print "ok ", $i++, " checking for matching bracket\n";

  eval 'sub badproto10 ([_]) { 1; }';
  print "not " if $warn =~ /Missing '\]' in prototype for main::badproto10 : \[/;
  print "ok ", $i++, " checking badproto10 - ([_]) - shouldn't trigger matching bracket\n";
  print "not " unless $warn =~ /Illegal character after '_' in prototype for main::badproto10 : \[_\]/;
  print "ok ", $i++, " checking badproto10 - ([_]) - should trigger after '_' warnings\n";
}

# make sure whitespace in prototypes works
eval "sub good (\$\t\$\n\$) { 1; }";
print "not " if $@@;
print "ok ", $i++, "\n";
# [perl #118629]
{
  my $warnings = 0;
  local $SIG{__WARN__} = sub { $warnings++;};
  $::{ckproto_test} = ' $ $ ';
	eval 'sub ckproto_test($$){1;}';
  print "not " if $warnings;
  print "ok ", $i++, " Check that ckproto ignores spaces in comparisons\n";
}

# Ought to fail, doesn't in 5.8.1.
eval 'sub bug (\[%@@]) {  } my $array = [0 .. 1]; bug %$array;';
print "not " unless $@@ =~ /Not a HASH reference/;
print "ok ", $i++, "\n";

# [perl #75904]
# Test that the following prototypes make subs parse as unary functions:
#  * \sigil \[...] ;$ ;* ;\sigil ;\[...]
# [perl #118585]
# As a special case, make sure that ;;* is treated the same as ;*
print "not "
 unless eval 'sub uniproto1 (*) {} uniproto1 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto2 (\$) {} uniproto2 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto3 (\[$%]) {} uniproto3 %_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto4 (;$) {} uniproto4 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto5 (;*) {} uniproto5 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto6 (;\@@) {} uniproto6 @@_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto7 (;\[$%@@]) {} uniproto7 @@_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto8 (+) {} uniproto8 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto9 (;+) {} uniproto9 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto10 (;;;*) {} uniproto10 $_, 1' or warn $@@;
print "ok ", $i++, " - uniproto10 (;;;*)\n";
print "not "
 unless eval 'sub uniproto11 ( ; ; ; * ) {} uniproto10 $_, 1' or warn $@@;
print "ok ", $i++, " - uniproto11 ( ; ; ;  *)\n";
print "not "
 unless eval 'sub uniproto12 (;;;+) {} uniproto12 $_, 1' or warn $@@;
print "ok ", $i++, " - uniproto12 (;;;*)\n";
print "not "
 unless eval 'sub uniproto13 ( ; ; ; + ) {} uniproto13 $_, 1' or warn $@@;
print "ok ", $i++, " - uniproto13 ( ; ; ; * )\n";


# Test that a trailing semicolon makes a sub have listop precedence
sub unilist ($;)  { $_[0]+1 }
sub unilist2(_;)  { $_[0]+1 }
sub unilist3(;$;) { $_[0]+1 }
print "not " unless (unilist 0 || 5) == 6;
print "ok ", $i++, "\n";
print "not " unless (unilist2 0 || 5) == 6;
print "ok ", $i++, "\n";
print "not " unless (unilist3 0 || 5) == 6;
print "ok ", $i++, "\n";

{
  # Lack of prototype on a subroutine definition should override any prototype
  # on the declaration.
  sub z_zwap (&);

  local $SIG{__WARN__} = sub {
    my $thiswarn = join "",@@_;
    if ($thiswarn =~ /^Prototype mismatch: sub main::z_zwap/) {
      print 'ok ', $i++, "\n";
    } else {
      print 'not ok ', $i++, "\n";
      print STDERR $thiswarn;
    }
  };

  eval q{sub z_zwap {return @@_}};

  if ($@@) {
    print "not ok ", $i++, "# $@@";
  } else {
    print "ok ", $i++, "\n";
  }


  my @@a = (6,4,2);
  my @@got  = eval q{z_zwap(@@a)};

  if ($@@) {
    print "not ok ", $i++, " # $@@";
  } else {
    print "ok ", $i++, "\n";
  }

  if ("@@got" eq "@@a") {
    print "ok ", $i++, "\n";
  } else {
    print "not ok ", $i++, " # >@@got<\n";
  }
}

# [perl #123514] prototype with no arguments
$_ = sub ($$$$$$$) {};
@@_ = (1, 2, 3, prototype(), 4, 5, 6);
print "not " unless "@@_" eq '1 2 3 $$$$$$$ 4 5 6';
print "ok ", $i++, " - [perl #123514] (got @@_)\n";
@


1.11
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d21 1
a21 1
print "1..201\n";
d281 1
d289 1
d295 15
d329 11
d411 5
d435 10
d546 1
a546 1
    print "not " unless $_[0] eq 'FOO' and $_[1] eq 'BAR';
d550 1
a550 1
	print "not " unless $_[0] eq 'Bar::BAZ' and $_[1] eq 'FOO';
d889 6
@


1.10
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d21 1
a21 1
print "1..180\n";
d553 16
d679 1
a679 1
  print "ok ", $i++, "\n";
d683 1
a683 1
  print "ok ", $i++, "\n";
d687 1
a687 1
  print "ok ", $i++, "\n";
d690 39
a728 2
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto4 : \@@\$bar/;
  print "ok ", $i++, "\n";
d735 9
d753 2
d782 13
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d21 1
a21 1
print "1..177\n";
d412 1
a412 1
print "# CORE:Foo => ($p), \$@@ => '$@@'\nnot " 
d415 16
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d21 1
a21 1
print "1..153\n";
d412 1
a412 1
print "# CORE:Foo => ($p), \$@@ => `$@@'\nnot " 
d547 23
a593 8
# Not $$;$;$
print "not " unless prototype "CORE::substr" eq '$$;$$';
print "ok ", $i++, "\n";

# recv takes a scalar reference for its second argument
print "not " unless prototype "CORE::recv" eq '*\\$$$';
print "ok ", $i++, "\n";

d605 2
d671 82
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d17 2
d21 1
a21 1
print "1..141\n";
d554 6
a559 1
  no warnings 'prototype';
d564 5
d624 1
a624 1
  use warnings 'syntax';
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d588 2
a589 1
    print "not " unless $@@ =~ /Type of arg 1 to main::multi1 must be one of/;
d592 2
a593 1
    print "not " unless $@@ =~ /Type of arg 1 to main::multi2 must be one of/;
d596 2
a597 1
    print "not " unless $@@ =~ /Type of arg 1 to main::multi3 must be one of/;
d600 2
a601 1
    print "not " unless $@@ =~ /Type of arg 2 to main::multi4 must be one of/;
d604 3
a606 2
    print "not " unless $@@ =~ /Type of arg 1 to main::multi5 must be one of/
		     && $@@ =~ /Not enough arguments/;
d638 1
d641 1
a641 1
print "ok ", $i++, " # TODO Ought to fail, doesn't in 5.8.2\n";
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d19 1
a19 1
print "1..140\n";
d632 4
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d19 1
a19 1
print "1..122\n";
d343 1
d444 90
a533 34
star FOO, sub { print "ok $i\n" if $_[0] eq 'FOO' }; $i++;
star(FOO, sub { print "ok $i\n" if $_[0] eq 'FOO' }); $i++;
star "FOO", sub { print "ok $i\n" if $_[0] eq 'FOO' }; $i++;
star("FOO", sub { print "ok $i\n" if $_[0] eq 'FOO' }); $i++;
star $star, sub { print "ok $i\n" if $_[0] eq 'FOO' }; $i++;
star($star, sub { print "ok $i\n" if $_[0] eq 'FOO' }); $i++;
star *FOO, sub { print "ok $i\n" if $_[0] eq \*FOO }; $i++;
star(*FOO, sub { print "ok $i\n" if $_[0] eq \*FOO }); $i++;
star \*FOO, sub { print "ok $i\n" if $_[0] eq \*FOO }; $i++;
star(\*FOO, sub { print "ok $i\n" if $_[0] eq \*FOO }); $i++;
star2 FOO, BAR, sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'BAR' }; $i++;
star2(Bar::BAZ, FOO, sub { print "ok $i\n"
			if $_[0] eq 'Bar::BAZ' and $_[1] eq 'FOO' }); $i++;
star2 BAR(), FOO, sub { print "ok $i\n"
			if $_[0] eq 'quux' and $_[1] eq 'FOO' }; $i++;
star2(FOO, BAR(), sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'quux' }); $i++;
star2 "FOO", "BAR", sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'BAR' }; $i++;
star2("FOO", "BAR", sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'BAR' }); $i++;
star2 $star, $star, sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'FOO' }; $i++;
star2($star, $star, sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'FOO' }); $i++;
star2 *FOO, *BAR, sub { print "ok $i\n"
			if $_[0] eq \*FOO and $_[1] eq \*BAR }; $i++;
star2(*FOO, *BAR, sub { print "ok $i\n"
			if $_[0] eq \*FOO and $_[1] eq \*BAR }); $i++;
star2 \*FOO, \*BAR, sub { no strict 'refs'; print "ok $i\n"
			if $_[0] eq \*{'FOO'} and $_[1] eq \*{'BAR'} }; $i++;
star2(\*FOO, \*BAR, sub { no strict 'refs'; print "ok $i\n"
			if $_[0] eq \*{'FOO'} and $_[1] eq \*{'BAR'} }); $i++;
d537 2
a538 1
    print "ok $_[1]\n" if ref $_[0];
d548 2
d552 1
a552 1
  no warnings 'redefine';
d555 1
a555 2
  # The /Syntax error/ is seen on OS/390.  It's /syntax error/ elsewhere
  print "# eval[$eval]\nnot " unless $@@ && $@@ =~ /[Ss]yntax error/;
d558 74
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d14 1
a14 1
    unshift @@INC, '../lib';
d19 1
a19 1
print "1..107\n";
d296 19
d487 11
@


1.2
log
@perl5.005_03 (stock)
@
text
@d14 1
a14 1
    @@INC = '../lib';
d19 1
a19 1
print "1..87\n";
d387 1
a387 1
print "# CORE::open => ($p)\nnot " if ($p = prototype('CORE::open')) ne '*;$';
d391 1
a391 1
    if defined ($p = eval { prototype('CORE::Foo') or 1 }) or $@@ !~ /^Cannot find an opnumber/;
d420 3
d425 1
d427 1
d429 1
d431 1
d433 36
@


1.1
log
@perl 5.004_04
@
text
@d19 1
a19 1
print "1..76\n";
d365 1
a365 1
testing \&an_array_ref, '\@@';
d367 1
a367 1
sub an_array_ref (\@@) {
d369 1
a369 1
    print "not " unless ref($_[0]) && 1 == @@{$_[0]};
d375 2
a376 1
an_array_ref @@array;
d380 14
d406 20
@


1.1.1.1
log
@perl5.005_03
@
text
@d19 1
a19 1
print "1..87\n";
d365 1
a365 1
testing \&array_ref_plus, '\@@@@';
d367 1
a367 1
sub array_ref_plus (\@@@@) {
d369 1
a369 1
    print "not " unless @@_ == 2 && ref($_[0]) && 1 == @@{$_[0]} && $_[1] eq 'x';
d375 1
a375 2
{ my @@more = ('x');
  array_ref_plus @@array, @@more; }
a378 14
my $p;
print "not " if defined prototype('CORE::print');
print "ok ", $i++, "\n";

print "not " if defined prototype('CORE::system');
print "ok ", $i++, "\n";

print "# CORE::open => ($p)\nnot " if ($p = prototype('CORE::open')) ne '*;$';
print "ok ", $i++, "\n";

print "# CORE:Foo => ($p), \$@@ => `$@@'\nnot " 
    if defined ($p = eval { prototype('CORE::Foo') or 1 }) or $@@ !~ /^Cannot find an opnumber/;
print "ok ", $i++, "\n";

a390 20

sub X::foo3;
*X::foo3 = sub {'ok'};
print "# $@@not " unless eval {X->foo3} eq 'ok';
print "ok ", $i++, "\n";

sub X::foo4 ($);
*X::foo4 = sub ($) {'ok'};
print "not " unless X->foo4 eq 'ok';
print "ok ", $i++, "\n";

# test if the (*) prototype allows barewords, constants, scalar expressions,
# globs and globrefs (just as CORE::open() does), all under stricture
sub star (*&) { &{$_[1]} }
my $star = 'FOO';
star FOO, sub { print "ok $i\n" if $_[0] eq 'FOO' }; $i++;
star "FOO", sub { print "ok $i\n" if $_[0] eq 'FOO' }; $i++;
star $star, sub { print "ok $i\n" if $_[0] eq 'FOO' }; $i++;
star *FOO, sub { print "ok $i\n" if $_[0] eq \*FOO }; $i++;
star \*FOO, sub { print "ok $i\n" if $_[0] eq \*FOO }; $i++;
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d14 1
a14 1
    unshift @@INC, '../lib';
d19 1
a19 1
print "1..107\n";
d387 1
a387 1
print "# CORE::open => ($p)\nnot " if ($p = prototype('CORE::open')) ne '*;$@@';
d391 1
a391 1
    if defined ($p = eval { prototype('CORE::Foo') or 1 }) or $@@ !~ /^Can't find an opnumber/;
a419 3
sub star2 (**&) { &{$_[2]} }
sub BAR { "quux" }
sub Bar::BAZ { "quuz" }
a421 1
star(FOO, sub { print "ok $i\n" if $_[0] eq 'FOO' }); $i++;
a422 1
star("FOO", sub { print "ok $i\n" if $_[0] eq 'FOO' }); $i++;
a423 1
star($star, sub { print "ok $i\n" if $_[0] eq 'FOO' }); $i++;
a424 1
star(*FOO, sub { print "ok $i\n" if $_[0] eq \*FOO }); $i++;
a425 36
star(\*FOO, sub { print "ok $i\n" if $_[0] eq \*FOO }); $i++;
star2 FOO, BAR, sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'BAR' }; $i++;
star2(Bar::BAZ, FOO, sub { print "ok $i\n"
			if $_[0] eq 'Bar::BAZ' and $_[1] eq 'FOO' }); $i++;
star2 BAR(), FOO, sub { print "ok $i\n"
			if $_[0] eq 'quux' and $_[1] eq 'FOO' }; $i++;
star2(FOO, BAR(), sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'quux' }); $i++;
star2 "FOO", "BAR", sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'BAR' }; $i++;
star2("FOO", "BAR", sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'BAR' }); $i++;
star2 $star, $star, sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'FOO' }; $i++;
star2($star, $star, sub { print "ok $i\n"
			if $_[0] eq 'FOO' and $_[1] eq 'FOO' }); $i++;
star2 *FOO, *BAR, sub { print "ok $i\n"
			if $_[0] eq \*FOO and $_[1] eq \*BAR }; $i++;
star2(*FOO, *BAR, sub { print "ok $i\n"
			if $_[0] eq \*FOO and $_[1] eq \*BAR }); $i++;
star2 \*FOO, \*BAR, sub { no strict 'refs'; print "ok $i\n"
			if $_[0] eq \*{'FOO'} and $_[1] eq \*{'BAR'} }; $i++;
star2(\*FOO, \*BAR, sub { no strict 'refs'; print "ok $i\n"
			if $_[0] eq \*{'FOO'} and $_[1] eq \*{'BAR'} }); $i++;

# test scalarref prototype
sub sreftest (\$$) {
    print "ok $_[1]\n" if ref $_[0];
}
{
    no strict 'vars';
    sreftest my $sref, $i++;
    sreftest($helem{$i}, $i++);
    sreftest $aelem[0], $i++;
}
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d14 1
a14 1
    @@INC = '../lib';
d19 1
a19 1
print "1..122\n";
a295 19
testing \&a_subx, '\&';

sub a_subx (\&) {
    print "# \@@_ = (",join(",",@@_),")\n";
    &{$_[0]};
}

sub tmp_sub_2 { printf "ok %d\n",$i++ }
a_subx &tmp_sub_2;

@@array = ( \&tmp_sub_2 );
eval 'a_subx @@array';
print "not " unless $@@;
printf "ok %d\n",$i++;

##
##
##

a467 11
}

# test prototypes when they are evaled and there is a syntax error
#
for my $p ( "", qw{ () ($) ($@@) ($%) ($;$) (&) (&\@@) (&@@) (%) (\%) (\@@) } ) {
  no warnings 'redefine';
  my $eval = "sub evaled_subroutine $p { &void *; }";
  eval $eval;
  # The /Syntax error/ is seen on OS/390.  It's /syntax error/ elsewhere
  print "# eval[$eval]\nnot " unless $@@ && $@@ =~ /[Ss]yntax error/;
  print "ok ", $i++, "\n";
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d19 1
a19 1
print "1..140\n";
a342 1
sub_array { lc shift } ('O', 'K', ' ', $i++);
d443 34
a476 90
star FOO, sub {
    print "not " unless $_[0] eq 'FOO';
    print "ok $i - star FOO\n";
}; $i++;
star(FOO, sub {
	print "not " unless $_[0] eq 'FOO';
	print "ok $i - star(FOO)\n";
    }); $i++;
star "FOO", sub {
    print "not " unless $_[0] eq 'FOO';
    print qq/ok $i - star "FOO"\n/;
}; $i++;
star("FOO", sub {
	print "not " unless $_[0] eq 'FOO';
	print qq/ok $i - star("FOO")\n/;
    }); $i++;
star $star, sub {
    print "not " unless $_[0] eq 'FOO';
    print "ok $i - star \$star\n";
}; $i++;
star($star, sub {
	print "not " unless $_[0] eq 'FOO';
	print "ok $i - star(\$star)\n";
    }); $i++;
star *FOO, sub {
    print "not " unless $_[0] eq \*FOO;
    print "ok $i - star *FOO\n";
}; $i++;
star(*FOO, sub {
	print "not " unless $_[0] eq \*FOO;
	print "ok $i - star(*FOO)\n";
    }); $i++;
star \*FOO, sub {
    print "not " unless $_[0] eq \*FOO;
    print "ok $i - star \\*FOO\n";
}; $i++;
star(\*FOO, sub {
	print "not " unless $_[0] eq \*FOO;
	print "ok $i - star(\\*FOO)\n";
    }); $i++;
star2 FOO, BAR, sub {
    print "not " unless $_[0] eq 'FOO' and $_[1] eq 'BAR';
    print "ok $i - star2 FOO, BAR\n";
}; $i++;
star2(Bar::BAZ, FOO, sub {
	print "not " unless $_[0] eq 'Bar::BAZ' and $_[1] eq 'FOO';
	print "ok $i - star2(Bar::BAZ, FOO)\n"
    }); $i++;
star2 BAR(), FOO, sub {
    print "not " unless $_[0] eq 'quux' and $_[1] eq 'FOO';
    print "ok $i - star2 BAR(), FOO\n"
}; $i++;
star2(FOO, BAR(), sub {
	print "not " unless $_[0] eq 'FOO' and $_[1] eq 'quux';
	print "ok $i - star2(FOO, BAR())\n";
    }); $i++;
star2 "FOO", "BAR", sub {
    print "not " unless $_[0] eq 'FOO' and $_[1] eq 'BAR';
    print qq/ok $i - star2 "FOO", "BAR"\n/;
}; $i++;
star2("FOO", "BAR", sub {
	print "not " unless $_[0] eq 'FOO' and $_[1] eq 'BAR';
	print qq/ok $i - star2("FOO", "BAR")\n/;
    }); $i++;
star2 $star, $star, sub {
    print "not " unless $_[0] eq 'FOO' and $_[1] eq 'FOO';
    print "ok $i - star2 \$star, \$star\n";
}; $i++;
star2($star, $star, sub {
	print "not " unless $_[0] eq 'FOO' and $_[1] eq 'FOO';
	print "ok $i - star2(\$star, \$star)\n";
    }); $i++;
star2 *FOO, *BAR, sub {
    print "not " unless $_[0] eq \*FOO and $_[1] eq \*BAR;
    print "ok $i - star2 *FOO, *BAR\n";
}; $i++;
star2(*FOO, *BAR, sub {
	print "not " unless $_[0] eq \*FOO and $_[1] eq \*BAR;
	print "ok $i - star2(*FOO, *BAR)\n";
    }); $i++;
star2 \*FOO, \*BAR, sub {
    no strict 'refs';
    print "not " unless $_[0] eq \*{'FOO'} and $_[1] eq \*{'BAR'};
    print "ok $i - star2 \*FOO, \*BAR\n";
}; $i++;
star2(\*FOO, \*BAR, sub {
	no strict 'refs';
	print "not " unless $_[0] eq \*{'FOO'} and $_[1] eq \*{'BAR'};
	print "ok $i - star2(\*FOO, \*BAR)\n";
    }); $i++;
d480 1
a480 2
    print "not " unless ref $_[0];
    print "ok $_[1] - sreftest\n";
a489 2
# Byacc generates the string "syntax error".  Bison gives the
# string "parse error".
d492 1
a492 1
  no warnings 'prototype';
d495 2
a496 1
  print "# eval[$eval]\nnot " unless $@@ && $@@ =~ /(parse|syntax) error/i;
a498 74

# Not $$;$;$
print "not " unless prototype "CORE::substr" eq '$$;$$';
print "ok ", $i++, "\n";

# recv takes a scalar reference for its second argument
print "not " unless prototype "CORE::recv" eq '*\\$$$';
print "ok ", $i++, "\n";

{
    my $myvar;
    my @@myarray;
    my %myhash;
    sub mysub { print "not calling mysub I hope\n" }
    local *myglob;

    sub myref (\[$@@%&*]) { print "# $_[0]\n"; return "$_[0]" }

    print "not " unless myref($myvar)   =~ /^SCALAR\(/;
    print "ok ", $i++, "\n";
    print "not " unless myref(@@myarray) =~ /^ARRAY\(/;
    print "ok ", $i++, "\n";
    print "not " unless myref(%myhash)  =~ /^HASH\(/;
    print "ok ", $i++, "\n";
    print "not " unless myref(&mysub)   =~ /^CODE\(/;
    print "ok ", $i++, "\n";
    print "not " unless myref(*myglob)  =~ /^GLOB\(/;
    print "ok ", $i++, "\n";

    eval q/sub multi1 (\[%@@]) { 1 } multi1 $myvar;/;
    print "not " unless $@@ =~ /Type of arg 1 to main::multi1 must be one of/;
    print "ok ", $i++, "\n";
    eval q/sub multi2 (\[$*&]) { 1 } multi2 @@myarray;/;
    print "not " unless $@@ =~ /Type of arg 1 to main::multi2 must be one of/;
    print "ok ", $i++, "\n";
    eval q/sub multi3 (\[$@@]) { 1 } multi3 %myhash;/;
    print "not " unless $@@ =~ /Type of arg 1 to main::multi3 must be one of/;
    print "ok ", $i++, "\n";
    eval q/sub multi4 ($\[%]) { 1 } multi4 1, &mysub;/;
    print "not " unless $@@ =~ /Type of arg 2 to main::multi4 must be one of/;
    print "ok ", $i++, "\n";
    eval q/sub multi5 (\[$@@]$) { 1 } multi5 *myglob;/;
    print "not " unless $@@ =~ /Type of arg 1 to main::multi5 must be one of/
		     && $@@ =~ /Not enough arguments/;
    print "ok ", $i++, "\n";
}

# check that obviously bad prototypes are getting warnings
{
  use warnings 'syntax';
  my $warn = "";
  local $SIG{__WARN__} = sub { $warn .= join("",@@_) };
  
  eval 'sub badproto (@@bar) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto : \@@bar/;
  print "ok ", $i++, "\n";

  eval 'sub badproto2 (bar) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto2 : bar/;
  print "ok ", $i++, "\n";
  
  eval 'sub badproto3 (&$bar$@@) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto3 : &\$bar\$\@@/;
  print "ok ", $i++, "\n";
  
  eval 'sub badproto4 (@@ $b ar) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto4 : \@@\$bar/;
  print "ok ", $i++, "\n";
}

# make sure whitespace in prototypes works
eval "sub good (\$\t\$\n\$) { 1; }";
print "not " if $@@;
print "ok ", $i++, "\n";
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d19 1
a19 1
print "1..141\n";
a631 4

eval 'sub bug (\[%@@]) {  } my $array = [0 .. 1]; bug %$array;';
print "not " unless $@@ =~ /Not a HASH reference/;
print "ok ", $i++, " # TODO Ought to fail, doesn't in 5.8.2\n";
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d588 1
a588 2
    print "not "
	unless $@@ =~ /Type of arg 1 to main::multi1 must be one of \[%\@@\] /;
d591 1
a591 2
    print "not "
	unless $@@ =~ /Type of arg 1 to main::multi2 must be one of \[\$\*&\] /;
d594 1
a594 2
    print "not "
	unless $@@ =~ /Type of arg 1 to main::multi3 must be one of \[\$\@@\] /;
d597 1
a597 2
    print "not "
	unless $@@ =~ /Type of arg 2 to main::multi4 must be one of \[%\] /;
d600 2
a601 3
    print "not "
	unless $@@ =~ /Type of arg 1 to main::multi5 must be one of \[\$\@@\] /
	    && $@@ =~ /Not enough arguments/;
a632 1
# Ought to fail, doesn't in 5.8.1.
d635 1
a635 1
print "ok ", $i++, "\n";
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@a16 2
# We need this, as in places we're testing the interaction of prototypes with
# strict
d19 1
a19 1
print "1..153\n";
d552 1
a552 6
  my $warn = "";
  local $SIG{__WARN__} = sub {
    my $thiswarn = join("",@@_);
    return if $thiswarn =~ /^Prototype mismatch: sub main::evaled_subroutine/;
    $warn .= $thiswarn;
  };
a556 5
  if ($warn eq '') {
     print "ok ", $i++, "\n";
  } else {
    print "not ok ", $i++, "# $warn \n";
  }
d612 1
a612 1
  local $^W = 1;
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d21 1
a21 1
print "1..177\n";
d412 1
a412 1
print "# CORE:Foo => ($p), \$@@ => '$@@'\nnot " 
a546 23
    sreftest sub { [0] }->()[0], $i++;
    sreftest my $a = 'quidgley', $i++;
    print "not " if eval 'return 1; sreftest(3+4)';
    print "ok ", $i++, ' - \$ with invalid argument', "\n";
}

# test single term
sub lazy (+$$) {
    print "not " unless @@_ == 3 && ref $_[0] eq $_[1];
    print "ok $_[2] - non container test\n";
}
sub quietlazy (+) { return shift(@@_) }
sub give_aref { [] }
sub list_or_scalar { wantarray ? (1..10) : [] }
{
    my @@multiarray = ("a".."z");
    my %bighash = @@multiarray;
    lazy(\@@multiarray, 'ARRAY', $i++);
    lazy(\%bighash, 'HASH', $i++);
    lazy({}, 'HASH', $i++);
    lazy(give_aref, 'ARRAY', $i++);
    lazy(3, '', $i++); # allowed by prototype, even if runtime error
    lazy(list_or_scalar, 'ARRAY', $i++); # propagate scalar context
d571 8
a589 2
    print "not " unless myref($myvar=7) =~ /^SCALAR\(/;
    print "ok ", $i++, "\n";
a653 82

# [perl #75904]
# Test that the following prototypes make subs parse as unary functions:
#  * \sigil \[...] ;$ ;* ;\sigil ;\[...]
print "not "
 unless eval 'sub uniproto1 (*) {} uniproto1 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto2 (\$) {} uniproto2 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto3 (\[$%]) {} uniproto3 %_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto4 (;$) {} uniproto4 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto5 (;*) {} uniproto5 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto6 (;\@@) {} uniproto6 @@_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto7 (;\[$%@@]) {} uniproto7 @@_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto8 (+) {} uniproto8 $_, 1' or warn $@@;
print "ok ", $i++, "\n";
print "not "
 unless eval 'sub uniproto9 (;+) {} uniproto9 $_, 1' or warn $@@;
print "ok ", $i++, "\n";

# Test that a trailing semicolon makes a sub have listop precedence
sub unilist ($;)  { $_[0]+1 }
sub unilist2(_;)  { $_[0]+1 }
sub unilist3(;$;) { $_[0]+1 }
print "not " unless (unilist 0 || 5) == 6;
print "ok ", $i++, "\n";
print "not " unless (unilist2 0 || 5) == 6;
print "ok ", $i++, "\n";
print "not " unless (unilist3 0 || 5) == 6;
print "ok ", $i++, "\n";

{
  # Lack of prototype on a subroutine definition should override any prototype
  # on the declaration.
  sub z_zwap (&);

  local $SIG{__WARN__} = sub {
    my $thiswarn = join "",@@_;
    if ($thiswarn =~ /^Prototype mismatch: sub main::z_zwap/) {
      print 'ok ', $i++, "\n";
    } else {
      print 'not ok ', $i++, "\n";
      print STDERR $thiswarn;
    }
  };

  eval q{sub z_zwap {return @@_}};

  if ($@@) {
    print "not ok ", $i++, "# $@@";
  } else {
    print "ok ", $i++, "\n";
  }


  my @@a = (6,4,2);
  my @@got  = eval q{z_zwap(@@a)};

  if ($@@) {
    print "not ok ", $i++, " # $@@";
  } else {
    print "ok ", $i++, "\n";
  }

  if ("@@got" eq "@@a") {
    print "ok ", $i++, "\n";
  } else {
    print "not ok ", $i++, " # >@@got<\n";
  }
}
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d21 1
a21 1
print "1..180\n";
d412 1
a412 1
print "# CORE::Foo => ($p), \$@@ => '$@@'\nnot " 
a414 16

eval { prototype("CORE::a\0b") };
print "# CORE::a\\0b: \$@@ => '$@@'\nnot " 
    if $@@ !~ /^Can't find an opnumber for "a\0b"/;
print "ok ", $i++, "\n";

eval { prototype("CORE::\x{100}") };
print "# CORE::\\x{100}: => ($p), \$@@ => '$@@'\nnot " 
    if $@@ !~ /^Can't find an opnumber for "\x{100}"/;
print "ok ", $i++, "\n";

"CORE::Foo" =~ /(.*)/;
print "# \$1 containing CORE::Foo => ($p), \$@@ => '$@@'\nnot " 
    if defined ($p = eval { prototype($1) or 1 })
    or $@@ !~ /^Can't find an opnumber/;
print "ok ", $i++, " - \$1 containing CORE::Foo\n";
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d21 1
a21 1
print "1..201\n";
a552 16
# [perl #118585]
# Test that multiple semicolons are treated as one with *
sub star3(;;;*){}
sub star4( ; ; ; ; *){}
print "not " unless eval 'star3 STDERR; 1';
print "ok ", $i++, " star3 STDERR\n";
print "not " unless eval 'star4 STDERR; 1';
print "ok ", $i++, " star4 STDERR\n";

# [perl #2726]
# Test that prototype binding is late
print "not " unless eval 'sub l564($){ l564(); } 1';
print "ok ", $i++, " prototype checking not done within initial definition\n";
print "not " if eval 'sub l566($); sub l566($){ l566(); } 1';
print "ok ", $i++, " prototype checking done if sub pre-declared\n";

d663 1
a663 1
  print "ok ", $i++, " checking badproto - (\@@bar)\n";
d667 1
a667 1
  print "ok ", $i++, " checking badproto2 - (bar)\n";
d671 1
a671 1
  print "ok ", $i++, " checking badproto3 - (&\$bar\$\@@)\n";
d674 2
a675 39
  # This one emits two warnings
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto4 : \@@ \$b ar/;
  print "ok ", $i++, " checking badproto4 - (\@@ \$b ar) - illegal character\n";
  print "not " unless $warn =~ /Prototype after '\@@' for main::badproto4 : \@@ \$b ar/;
  print "ok ", $i++, " checking badproto4 - (\@@ \$b ar) - prototype after '\@@'\n";

  eval 'sub badproto5 ($_$) { 1; }';
  print "not " unless $warn =~ /Illegal character after '_' in prototype for main::badproto5 : \$_\$/;
  print "ok ", $i++, " checking badproto5 - (\$_\$) - illegal character after '_'\n";
  print "not " if $warn =~ /Illegal character in prototype for main::badproto5 : \$_\$/;
  print "ok ", $i++, " checking badproto5 - (\$_\$) - but not just illegal character\n";

  eval 'sub badproto6 (bar_) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto6 : bar_/;
  print "ok ", $i++, " checking badproto6 - (bar_) - illegal character\n";
  print "not " if $warn =~ /Illegal character after '_' in prototype for main::badproto6 : bar_/;
  print "ok ", $i++, " checking badproto6 - (bar_) - shouldn't add \"after '_'\"\n";

  eval 'sub badproto7 (_;bar) { 1; }';
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto7 : _;bar/;
  print "ok ", $i++, " checking badproto7 - (_;bar) - illegal character\n";
  print "not " if $warn =~ /Illegal character after '_' in prototype for main::badproto7 : _;bar/;
  print "ok ", $i++, " checking badproto7 - (_;bar) - shouldn't add \"after '_'\"\n";

  eval 'sub badproto8 (_b) { 1; }';
  print "not " unless $warn =~ /Illegal character after '_' in prototype for main::badproto8 : _b/;
  print "ok ", $i++, " checking badproto8 - (_b) - illegal character after '_'\n";
  print "not " unless $warn =~ /Illegal character in prototype for main::badproto8 : _b/;
  print "ok ", $i++, " checking badproto8 - (_b) - just illegal character\n";

  eval 'sub badproto9 ([) { 1; }';
  print "not " unless $warn =~ /Missing '\]' in prototype for main::badproto9 : \[/;
  print "ok ", $i++, " checking for matching bracket\n";

  eval 'sub badproto10 ([_]) { 1; }';
  print "not " if $warn =~ /Missing '\]' in prototype for main::badproto10 : \[/;
  print "ok ", $i++, " checking badproto10 - ([_]) - shouldn't trigger matching bracket\n";
  print "not " unless $warn =~ /Illegal character after '_' in prototype for main::badproto10 : \[_\]/;
  print "ok ", $i++, " checking badproto10 - ([_]) - should trigger after '_' warnings\n";
a681 9
# [perl #118629]
{
  my $warnings = 0;
  local $SIG{__WARN__} = sub { $warnings++;};
  $::{ckproto_test} = ' $ $ ';
	eval 'sub ckproto_test($$){1;}';
  print "not " if $warnings;
  print "ok ", $i++, " Check that ckproto ignores spaces in comparisons\n";
}
a690 2
# [perl #118585]
# As a special case, make sure that ;;* is treated the same as ;*
a717 13
print "not "
 unless eval 'sub uniproto10 (;;;*) {} uniproto10 $_, 1' or warn $@@;
print "ok ", $i++, " - uniproto10 (;;;*)\n";
print "not "
 unless eval 'sub uniproto11 ( ; ; ; * ) {} uniproto10 $_, 1' or warn $@@;
print "ok ", $i++, " - uniproto11 ( ; ; ;  *)\n";
print "not "
 unless eval 'sub uniproto12 (;;;+) {} uniproto12 $_, 1' or warn $@@;
print "ok ", $i++, " - uniproto12 (;;;*)\n";
print "not "
 unless eval 'sub uniproto13 ( ; ; ; + ) {} uniproto13 $_, 1' or warn $@@;
print "ok ", $i++, " - uniproto13 ( ; ; ; * )\n";

@


1.1.1.11
log
@Import perl-5.24.2
@
text
@d21 1
a21 1
print "1..215\n";
a280 1
    return unless defined $_[0];
a287 1
a_sub \(&tmp_sub_1);
a292 15
eval 'a_sub \@@array';
print "not " unless $@@ =~ /Type of arg/;
printf "ok %d\n",$i++;
eval 'a_sub \%hash';
print "not " unless $@@ =~ /Type of arg/;
printf "ok %d\n",$i++;
eval 'a_sub \$scalar';
print "not " unless $@@ =~ /Type of arg/;
printf "ok %d\n",$i++;
eval 'a_sub \($list, %of, @@refs)';
print "not " unless $@@ =~ /Type of arg/;
printf "ok %d\n",$i++;
eval 'a_sub undef';
print "not " if $@@;
printf "ok %d\n",$i++;
a311 11
my $bad =
    qr/Type of arg 1 to .* must be subroutine \(not subroutine entry\)/;
eval 'a_subx &tmp_sub_2()';
print "not " unless $@@ =~ $bad;
printf "ok %d - \\& prohibits &foo()\n",$i++;
eval 'a_subx tmp_sub_2()';
print "not " unless $@@ =~ $bad;
printf "ok %d - \\& prohibits foo()\n",$i++;
eval 'a_subx tmp_sub_2';
print "not " unless $@@ =~ $bad;
printf "ok %d - \\& prohibits foo where foo is an existing sub\n",$i++;
a382 5
%hash = ( a => 1);
a_hash_ref +(%hash);
print "not " unless $hash{'b'} == 2;
printf "ok %d\n",$i++;

a401 10
@@array = ('a');
{ my @@more = ('x');
  array_ref_plus +(@@array), @@more; }
print "not " unless @@array == 4;
print @@array;

##
##
##

d503 1
a503 1
    print "not " unless $_[0] eq 'FOO' and $_[1] eq 'quux';
d507 1
a507 1
	print "not " unless $_[0] eq 'quuz' and $_[1] eq 'FOO';
a845 6

# [perl #123514] prototype with no arguments
$_ = sub ($$$$$$$) {};
@@_ = (1, 2, 3, prototype(), 4, 5, 6);
print "not " unless "@@_" eq '1 2 3 $$$$$$$ 4 5 6';
print "ok ", $i++, " - [perl #123514] (got @@_)\n";
@


