head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.12.0.10
	OPENBSD_6_0_BASE:1.1.1.12
	OPENBSD_5_9:1.1.1.12.0.4
	OPENBSD_5_9_BASE:1.1.1.12
	OPENBSD_5_8:1.1.1.12.0.6
	OPENBSD_5_8_BASE:1.1.1.12
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.1.1.12.0.2
	OPENBSD_5_7_BASE:1.1.1.12
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.1.1.11.0.4
	OPENBSD_5_6_BASE:1.1.1.11
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.10.0.6
	OPENBSD_5_5_BASE:1.1.1.10
	OPENBSD_5_4:1.1.1.10.0.2
	OPENBSD_5_4_BASE:1.1.1.10
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.1.1.9.0.10
	OPENBSD_5_3_BASE:1.1.1.9
	OPENBSD_5_2:1.1.1.9.0.8
	OPENBSD_5_2_BASE:1.1.1.9
	OPENBSD_5_1_BASE:1.1.1.9
	OPENBSD_5_1:1.1.1.9.0.6
	OPENBSD_5_0:1.1.1.9.0.4
	OPENBSD_5_0_BASE:1.1.1.9
	OPENBSD_4_9:1.1.1.9.0.2
	OPENBSD_4_9_BASE:1.1.1.9
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.1.1.8.0.4
	OPENBSD_4_8_BASE:1.1.1.8
	OPENBSD_4_7:1.1.1.8.0.2
	OPENBSD_4_7_BASE:1.1.1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.1.1.7.0.6
	OPENBSD_4_6_BASE:1.1.1.7
	OPENBSD_4_5:1.1.1.7.0.2
	OPENBSD_4_5_BASE:1.1.1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.19;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.09;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.09;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.29;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.21.13.42;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.48.30;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.01.15.21.18.13;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.40;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.58;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.41;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.49.15;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.09.32;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.09;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.16;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#
# t/test.pl - most of Test::More functionality without the fuss


# NOTE:
#
# It's best to not features found only in more modern Perls here, as some cpan
# distributions copy this file and operate on older Perls.  Similarly keep
# things simple as this may be run under fairly broken circumstances.  For
# example, increment ($x++) has a certain amount of cleverness for things like
#
#   $x = 'zz';
#   $x++; # $x eq 'aaa';
#
# This stands more chance of breaking than just a simple
#
#   $x = $x + 1
#
# In this file, we use the latter "Baby Perl" approach, and increment
# will be worked over by t/op/inc.t

$Level = 1;
my $test = 1;
my $planned;
my $noplan;
my $Perl;       # Safer version of $^X set by which_perl()

# This defines ASCII/UTF-8 vs EBCDIC/UTF-EBCDIC
$::IS_ASCII  = ord 'A' ==  65;
$::IS_EBCDIC = ord 'A' == 193;

$TODO = 0;
$NO_ENDING = 0;
$Tests_Are_Passing = 1;

# Use this instead of print to avoid interference while testing globals.
sub _print {
    local($\, $", $,) = (undef, ' ', '');
    print STDOUT @@_;
}

sub _print_stderr {
    local($\, $", $,) = (undef, ' ', '');
    print STDERR @@_;
}

sub plan {
    my $n;
    if (@@_ == 1) {
	$n = shift;
	if ($n eq 'no_plan') {
	  undef $n;
	  $noplan = 1;
	}
    } else {
	my %plan = @@_;
	$plan{skip_all} and skip_all($plan{skip_all});
	$n = $plan{tests};
    }
    _print "1..$n\n" unless $noplan;
    $planned = $n;
}


# Set the plan at the end.  See Test::More::done_testing.
sub done_testing {
    my $n = $test - 1;
    $n = shift if @@_;

    _print "1..$n\n";
    $planned = $n;
}


END {
    my $ran = $test - 1;
    if (!$NO_ENDING) {
	if (defined $planned && $planned != $ran) {
	    _print_stderr
		"# Looks like you planned $planned tests but ran $ran.\n";
	} elsif ($noplan) {
	    _print "1..$ran\n";
	}
    }
}

sub _diag {
    return unless @@_;
    my @@mess = _comment(@@_);
    $TODO ? _print(@@mess) : _print_stderr(@@mess);
}

# Use this instead of "print STDERR" when outputting failure diagnostic
# messages
sub diag {
    _diag(@@_);
}

# Use this instead of "print" when outputting informational messages
sub note {
    return unless @@_;
    _print( _comment(@@_) );
}

sub is_miniperl {
    return !defined &DynaLoader::boot_DynaLoader;
}

sub set_up_inc {
    # Donâ€™t clobber @@INC under miniperl
    @@INC = () unless is_miniperl;
    unshift @@INC, @@_;
}

sub _comment {
    return map { /^#/ ? "$_\n" : "# $_\n" }
           map { split /\n/ } @@_;
}

sub _have_dynamic_extension {
    my $extension = shift;
    unless (eval {require Config; 1}) {
	warn "test.pl had problems loading Config: $@@";
	return 1;
    }
    $extension =~ s!::!/!g;
    return 1 if ($Config::Config{extensions} =~ /\b$extension\b/);
}

sub skip_all {
    if (@@_) {
        _print "1..0 # Skip @@_\n";
    } else {
	_print "1..0\n";
    }
    exit(0);
}

sub skip_all_if_miniperl {
    skip_all(@@_) if is_miniperl();
}

sub skip_all_without_dynamic_extension {
    my ($extension) = @@_;
    skip_all("no dynamic loading on miniperl, no $extension") if is_miniperl();
    return if &_have_dynamic_extension;
    skip_all("$extension was not built");
}

sub skip_all_without_perlio {
    skip_all('no PerlIO') unless PerlIO::Layer->find('perlio');
}

sub skip_all_without_config {
    unless (eval {require Config; 1}) {
	warn "test.pl had problems loading Config: $@@";
	return;
    }
    foreach (@@_) {
	next if $Config::Config{$_};
	my $key = $_; # Need to copy, before trying to modify.
	$key =~ s/^use//;
	$key =~ s/^d_//;
	skip_all("no $key");
    }
}

sub skip_all_without_unicode_tables { # (but only under miniperl)
    if (is_miniperl()) {
        skip_all_if_miniperl("Unicode tables not built yet")
            unless eval 'require "unicore/Heavy.pl"';
    }
}

sub find_git_or_skip {
    my ($source_dir, $reason);
    if (-d '.git') {
	$source_dir = '.';
    } elsif (-l 'MANIFEST' && -l 'AUTHORS') {
	my $where = readlink 'MANIFEST';
	die "Can't readling MANIFEST: $!" unless defined $where;
	die "Confusing symlink target for MANIFEST, '$where'"
	    unless $where =~ s!/MANIFEST\z!!;
	if (-d "$where/.git") {
	    # Looks like we are in a symlink tree
	    if (exists $ENV{GIT_DIR}) {
		diag("Found source tree at $where, but \$ENV{GIT_DIR} is $ENV{GIT_DIR}. Not changing it");
	    } else {
		note("Found source tree at $where, setting \$ENV{GIT_DIR}");
		$ENV{GIT_DIR} = "$where/.git";
	    }
	    $source_dir = $where;
	}
    } elsif (exists $ENV{GIT_DIR}) {
	my $commit = '8d063cd8450e59ea1c611a2f4f5a21059a2804f1';
	my $out = `git rev-parse --verify --quiet '$commit^{commit}'`;
	chomp $out;
	if($out eq $commit) {
	    $source_dir = '.'
	}
    }
    if ($source_dir) {
	my $version_string = `git --version`;
	if (defined $version_string
	      && $version_string =~ /\Agit version (\d+\.\d+\.\d+)(.*)/) {
	    return $source_dir if eval "v$1 ge v1.5.0";
	    # If you have earlier than 1.5.0 and it works, change this test
	    $reason = "in git checkout, but git version '$1$2' too old";
	} else {
	    $reason = "in git checkout, but cannot run git";
	}
    } else {
	$reason = 'not being run from a git checkout';
    }
    skip_all($reason) if $_[0] && $_[0] eq 'all';
    skip($reason, @@_);
}

sub BAIL_OUT {
    my ($reason) = @@_;
    _print("Bail out!  $reason\n");
    exit 255;
}

sub _ok {
    my ($pass, $where, $name, @@mess) = @@_;
    # Do not try to microoptimize by factoring out the "not ".
    # VMS will avenge.
    my $out;
    if ($name) {
        # escape out '#' or it will interfere with '# skip' and such
        $name =~ s/#/\\#/g;
	$out = $pass ? "ok $test - $name" : "not ok $test - $name";
    } else {
	$out = $pass ? "ok $test" : "not ok $test";
    }

    if ($TODO) {
	$out = $out . " # TODO $TODO";
    } else {
	$Tests_Are_Passing = 0 unless $pass;
    }

    _print "$out\n";

    if ($pass) {
	note @@mess; # Ensure that the message is properly escaped.
    }
    else {
	my $msg = "# Failed test $test - ";
	$msg.= "$name " if $name;
	$msg .= "$where\n";
	_diag $msg;
	_diag @@mess;
    }

    $test = $test + 1; # don't use ++

    return $pass;
}

sub _where {
    my @@caller = caller($Level);
    return "at $caller[1] line $caller[2]";
}

# DON'T use this for matches. Use like() instead.
sub ok ($@@) {
    my ($pass, $name, @@mess) = @@_;
    _ok($pass, _where(), $name, @@mess);
}

sub _q {
    my $x = shift;
    return 'undef' unless defined $x;
    my $q = $x;
    $q =~ s/\\/\\\\/g;
    $q =~ s/'/\\'/g;
    return "'$q'";
}

sub _qq {
    my $x = shift;
    return defined $x ? '"' . display ($x) . '"' : 'undef';
};

# keys are the codes \n etc map to, values are 2 char strings such as \n
my %backslash_escape;
foreach my $x (split //, 'nrtfa\\\'"') {
    $backslash_escape{ord eval "\"\\$x\""} = "\\$x";
}
# A way to display scalars containing control characters and Unicode.
# Trying to avoid setting $_, or relying on local $_ to work.
sub display {
    my @@result;
    foreach my $x (@@_) {
        if (defined $x and not ref $x) {
            my $y = '';
            foreach my $c (unpack("W*", $x)) {
                if ($c > 255) {
                    $y = $y . sprintf "\\x{%x}", $c;
                } elsif ($backslash_escape{$c}) {
                    $y = $y . $backslash_escape{$c};
                } else {
                    my $z = chr $c; # Maybe we can get away with a literal...

                    if ($z !~ /[^[:^print:][:^ascii:]]/) {
                        # The pattern above is equivalent (by de Morgan's
                        # laws) to:
                        #     $z !~ /(?[ [:print:] & [:ascii:] ])/
                        # or, $z is not an ascii printable character

                        # Use octal for characters with small ordinals that
                        # are traditionally expressed as octal: the controls
                        # below space, which on EBCDIC are almost all the
                        # controls, but on ASCII don't include DEL nor the C1
                        # controls.
                        if ($c < ord " ") {
                            $z = sprintf "\\%03o", $c;
                        } else {
                            $z = sprintf "\\x{%x}", $c;
                        }
                    }
                    $y = $y . $z;
                }
            }
            $x = $y;
        }
        return $x unless wantarray;
        push @@result, $x;
    }
    return @@result;
}

sub is ($$@@) {
    my ($got, $expected, $name, @@mess) = @@_;

    my $pass;
    if( !defined $got || !defined $expected ) {
        # undef only matches undef
        $pass = !defined $got && !defined $expected;
    }
    else {
        $pass = $got eq $expected;
    }

    unless ($pass) {
	unshift(@@mess, "#      got "._qq($got)."\n",
		       "# expected "._qq($expected)."\n");
    }
    _ok($pass, _where(), $name, @@mess);
}

sub isnt ($$@@) {
    my ($got, $isnt, $name, @@mess) = @@_;

    my $pass;
    if( !defined $got || !defined $isnt ) {
        # undef only matches undef
        $pass = defined $got || defined $isnt;
    }
    else {
        $pass = $got ne $isnt;
    }

    unless( $pass ) {
        unshift(@@mess, "# it should not be "._qq($got)."\n",
                       "# but it is.\n");
    }
    _ok($pass, _where(), $name, @@mess);
}

sub cmp_ok ($$$@@) {
    my($got, $type, $expected, $name, @@mess) = @@_;

    my $pass;
    {
        local $^W = 0;
        local($@@,$!);   # don't interfere with $@@
                        # eval() sometimes resets $!
        $pass = eval "\$got $type \$expected";
    }
    unless ($pass) {
        # It seems Irix long doubles can have 2147483648 and 2147483648
        # that stringify to the same thing but are actually numerically
        # different. Display the numbers if $type isn't a string operator,
        # and the numbers are stringwise the same.
        # (all string operators have alphabetic names, so tr/a-z// is true)
        # This will also show numbers for some unneeded cases, but will
        # definitely be helpful for things such as == and <= that fail
        if ($got eq $expected and $type !~ tr/a-z//) {
            unshift @@mess, "# $got - $expected = " . ($got - $expected) . "\n";
        }
        unshift(@@mess, "#      got "._qq($got)."\n",
                       "# expected $type "._qq($expected)."\n");
    }
    _ok($pass, _where(), $name, @@mess);
}

# Check that $got is within $range of $expected
# if $range is 0, then check it's exact
# else if $expected is 0, then $range is an absolute value
# otherwise $range is a fractional error.
# Here $range must be numeric, >= 0
# Non numeric ranges might be a useful future extension. (eg %)
sub within ($$$@@) {
    my ($got, $expected, $range, $name, @@mess) = @@_;
    my $pass;
    if (!defined $got or !defined $expected or !defined $range) {
        # This is a fail, but doesn't need extra diagnostics
    } elsif ($got !~ tr/0-9// or $expected !~ tr/0-9// or $range !~ tr/0-9//) {
        # This is a fail
        unshift @@mess, "# got, expected and range must be numeric\n";
    } elsif ($range < 0) {
        # This is also a fail
        unshift @@mess, "# range must not be negative\n";
    } elsif ($range == 0) {
        # Within 0 is ==
        $pass = $got == $expected;
    } elsif ($expected == 0) {
        # If expected is 0, treat range as absolute
        $pass = ($got <= $range) && ($got >= - $range);
    } else {
        my $diff = $got - $expected;
        $pass = abs ($diff / $expected) < $range;
    }
    unless ($pass) {
        if ($got eq $expected) {
            unshift @@mess, "# $got - $expected = " . ($got - $expected) . "\n";
        }
	unshift@@mess, "#      got "._qq($got)."\n",
		      "# expected "._qq($expected)." (within "._qq($range).")\n";
    }
    _ok($pass, _where(), $name, @@mess);
}

# Note: this isn't quite as fancy as Test::More::like().

sub like   ($$@@) { like_yn (0,@@_) }; # 0 for -
sub unlike ($$@@) { like_yn (1,@@_) }; # 1 for un-

sub like_yn ($$$@@) {
    my ($flip, undef, $expected, $name, @@mess) = @@_;

    # We just accept like(..., qr/.../), not like(..., '...'), and
    # definitely not like(..., '/.../') like
    # Test::Builder::maybe_regex() does.
    unless (re::is_regexp($expected)) {
	die "PANIC: The value '$expected' isn't a regexp. The like() function needs a qr// pattern, not a string";
    }

    my $pass;
    $pass = $_[1] =~ /$expected/ if !$flip;
    $pass = $_[1] !~ /$expected/ if $flip;
    my $display_got = $_[1];
    $display_got = display($display_got);
    my $display_expected = $expected;
    $display_expected = display($display_expected);
    unless ($pass) {
	unshift(@@mess, "#      got '$display_got'\n",
		$flip
		? "# expected !~ /$display_expected/\n"
                : "# expected /$display_expected/\n");
    }
    local $Level = $Level + 1;
    _ok($pass, _where(), $name, @@mess);
}

sub pass {
    _ok(1, '', @@_);
}

sub fail {
    _ok(0, _where(), @@_);
}

sub curr_test {
    $test = shift if @@_;
    return $test;
}

sub next_test {
  my $retval = $test;
  $test = $test + 1; # don't use ++
  $retval;
}

# Note: can't pass multipart messages since we try to
# be compatible with Test::More::skip().
sub skip {
    my $why = shift;
    my $n   = @@_ ? shift : 1;
    my $bad_swap;
    my $both_zero;
    {
      local $^W = 0;
      $bad_swap = $why > 0 && $n == 0;
      $both_zero = $why == 0 && $n == 0;
    }
    if ($bad_swap || $both_zero || @@_) {
      my $arg = "'$why', '$n'";
      if (@@_) {
        $arg .= join(", ", '', map { qq['$_'] } @@_);
      }
      die qq[$0: expected skip(why, count), got skip($arg)\n];
    }
    for (1..$n) {
        _print "ok $test # skip $why\n";
        $test = $test + 1;
    }
    local $^W = 0;
    last SKIP;
}

sub skip_if_miniperl {
    skip(@@_) if is_miniperl();
}

sub skip_without_dynamic_extension {
    my $extension = shift;
    skip("no dynamic loading on miniperl, no extension $extension", @@_)
	if is_miniperl();
    return if &_have_dynamic_extension($extension);
    skip("extension $extension was not built", @@_);
}

sub todo_skip {
    my $why = shift;
    my $n   = @@_ ? shift : 1;

    for (1..$n) {
        _print "not ok $test # TODO & SKIP $why\n";
        $test = $test + 1;
    }
    local $^W = 0;
    last TODO;
}

sub eq_array {
    my ($ra, $rb) = @@_;
    return 0 unless $#$ra == $#$rb;
    for my $i (0..$#$ra) {
	next     if !defined $ra->[$i] && !defined $rb->[$i];
	return 0 if !defined $ra->[$i];
	return 0 if !defined $rb->[$i];
	return 0 unless $ra->[$i] eq $rb->[$i];
    }
    return 1;
}

sub eq_hash {
  my ($orig, $suspect) = @@_;
  my $fail;
  while (my ($key, $value) = each %$suspect) {
    # Force a hash recompute if this perl's internals can cache the hash key.
    $key = "" . $key;
    if (exists $orig->{$key}) {
      if (
        defined $orig->{$key} != defined $value
        || (defined $value && $orig->{$key} ne $value)
      ) {
        _print "# key ", _qq($key), " was ", _qq($orig->{$key}),
                     " now ", _qq($value), "\n";
        $fail = 1;
      }
    } else {
      _print "# key ", _qq($key), " is ", _qq($value),
                   ", not in original.\n";
      $fail = 1;
    }
  }
  foreach (keys %$orig) {
    # Force a hash recompute if this perl's internals can cache the hash key.
    $_ = "" . $_;
    next if (exists $suspect->{$_});
    _print "# key ", _qq($_), " was ", _qq($orig->{$_}), " now missing.\n";
    $fail = 1;
  }
  !$fail;
}

# We only provide a subset of the Test::More functionality.
sub require_ok ($) {
    my ($require) = @@_;
    if ($require =~ tr/[A-Za-z0-9:.]//c) {
	fail("Invalid character in \"$require\", passed to require_ok");
    } else {
	eval <<REQUIRE_OK;
require $require;
REQUIRE_OK
	is($@@, '', _where(), "require $require");
    }
}

sub use_ok ($) {
    my ($use) = @@_;
    if ($use =~ tr/[A-Za-z0-9:.]//c) {
	fail("Invalid character in \"$use\", passed to use");
    } else {
	eval <<USE_OK;
use $use;
USE_OK
	is($@@, '', _where(), "use $use");
    }
}

# runperl - Runs a separate perl interpreter and returns its output.
# Arguments :
#   switches => [ command-line switches ]
#   nolib    => 1 # don't use -I../lib (included by default)
#   non_portable => Don't warn if a one liner contains quotes
#   prog     => one-liner (avoid quotes)
#   progs    => [ multi-liner (avoid quotes) ]
#   progfile => perl script
#   stdin    => string to feed the stdin (or undef to redirect from /dev/null)
#   stderr   => If 'devnull' suppresses stderr, if other TRUE value redirect
#               stderr to stdout
#   args     => [ command-line arguments to the perl program ]
#   verbose  => print the command line

my $is_mswin    = $^O eq 'MSWin32';
my $is_netware  = $^O eq 'NetWare';
my $is_vms      = $^O eq 'VMS';
my $is_cygwin   = $^O eq 'cygwin';

sub _quote_args {
    my ($runperl, $args) = @@_;

    foreach (@@$args) {
	# In VMS protect with doublequotes because otherwise
	# DCL will lowercase -- unless already doublequoted.
       $_ = q(").$_.q(") if $is_vms && !/^\"/ && length($_) > 0;
       $runperl = $runperl . ' ' . $_;
    }
    return $runperl;
}

sub _create_runperl { # Create the string to qx in runperl().
    my %args = @@_;
    my $runperl = which_perl();
    if ($runperl =~ m/\s/) {
        $runperl = qq{"$runperl"};
    }
    #- this allows, for example, to set PERL_RUNPERL_DEBUG=/usr/bin/valgrind
    if ($ENV{PERL_RUNPERL_DEBUG}) {
	$runperl = "$ENV{PERL_RUNPERL_DEBUG} $runperl";
    }
    unless ($args{nolib}) {
	$runperl = $runperl . ' "-I../lib"'; # doublequotes because of VMS
    }
    if ($args{switches}) {
	local $Level = 2;
	die "test.pl:runperl(): 'switches' must be an ARRAYREF " . _where()
	    unless ref $args{switches} eq "ARRAY";
	$runperl = _quote_args($runperl, $args{switches});
    }
    if (defined $args{prog}) {
	die "test.pl:runperl(): both 'prog' and 'progs' cannot be used " . _where()
	    if defined $args{progs};
        $args{progs} = [split /\n/, $args{prog}, -1]
    }
    if (defined $args{progs}) {
	die "test.pl:runperl(): 'progs' must be an ARRAYREF " . _where()
	    unless ref $args{progs} eq "ARRAY";
        foreach my $prog (@@{$args{progs}}) {
	    if (!$args{non_portable}) {
		if ($prog =~ tr/'"//) {
		    warn "quotes in prog >>$prog<< are not portable";
		}
		if ($prog =~ /^([<>|]|2>)/) {
		    warn "Initial $1 in prog >>$prog<< is not portable";
		}
		if ($prog =~ /&\z/) {
		    warn "Trailing & in prog >>$prog<< is not portable";
		}
	    }
            if ($is_mswin || $is_netware || $is_vms) {
                $runperl = $runperl . qq ( -e "$prog" );
            }
            else {
                $runperl = $runperl . qq ( -e '$prog' );
            }
        }
    } elsif (defined $args{progfile}) {
	$runperl = $runperl . qq( "$args{progfile}");
    } else {
	# You probably didn't want to be sucking in from the upstream stdin
	die "test.pl:runperl(): none of prog, progs, progfile, args, "
	    . " switches or stdin specified"
	    unless defined $args{args} or defined $args{switches}
		or defined $args{stdin};
    }
    if (defined $args{stdin}) {
	# so we don't try to put literal newlines and crs onto the
	# command line.
	$args{stdin} =~ s/\n/\\n/g;
	$args{stdin} =~ s/\r/\\r/g;

	if ($is_mswin || $is_netware || $is_vms) {
	    $runperl = qq{$Perl -e "print qq(} .
		$args{stdin} . q{)" | } . $runperl;
	}
	else {
	    $runperl = qq{$Perl -e 'print qq(} .
		$args{stdin} . q{)' | } . $runperl;
	}
    } elsif (exists $args{stdin}) {
        # Using the pipe construction above can cause fun on systems which use
        # ksh as /bin/sh, as ksh does pipes differently (with one less process)
        # With sh, for the command line 'perl -e 'print qq()' | perl -e ...'
        # the sh process forks two children, which use exec to start the two
        # perl processes. The parent shell process persists for the duration of
        # the pipeline, and the second perl process starts with no children.
        # With ksh (and zsh), the shell saves a process by forking a child for
        # just the first perl process, and execing itself to start the second.
        # This means that the second perl process starts with one child which
        # it didn't create. This causes "fun" when if the tests assume that
        # wait (or waitpid) will only return information about processes
        # started within the test.
        # They also cause fun on VMS, where the pipe implementation returns
        # the exit code of the process at the front of the pipeline, not the
        # end. This messes up any test using OPTION FATAL.
        # Hence it's useful to have a way to make STDIN be at eof without
        # needing a pipeline, so that the fork tests have a sane environment
        # without these surprises.

        # /dev/null appears to be surprisingly portable.
        $runperl = $runperl . ($is_mswin ? ' <nul' : ' </dev/null');
    }
    if (defined $args{args}) {
	$runperl = _quote_args($runperl, $args{args});
    }
    if (exists $args{stderr} && $args{stderr} eq 'devnull') {
        $runperl = $runperl . ($is_mswin ? ' 2>nul' : ' 2>/dev/null');
    }
    elsif ($args{stderr}) {
        $runperl = $runperl . ' 2>&1';
    }
    if ($args{verbose}) {
	my $runperldisplay = $runperl;
	$runperldisplay =~ s/\n/\n\#/g;
	_print_stderr "# $runperldisplay\n";
    }
    return $runperl;
}

# sub run_perl {} is alias to below
sub runperl {
    die "test.pl:runperl() does not take a hashref"
	if ref $_[0] and ref $_[0] eq 'HASH';
    my $runperl = &_create_runperl;
    my $result;

    my $tainted = ${^TAINT};
    my %args = @@_;
    exists $args{switches} && grep m/^-T$/, @@{$args{switches}} and $tainted = $tainted + 1;

    if ($tainted) {
	# We will assume that if you're running under -T, you really mean to
	# run a fresh perl, so we'll brute force launder everything for you
	my $sep;

	if (! eval {require Config; 1}) {
	    warn "test.pl had problems loading Config: $@@";
	    $sep = ':';
	} else {
	    $sep = $Config::Config{path_sep};
	}

	my @@keys = grep {exists $ENV{$_}} qw(CDPATH IFS ENV BASH_ENV);
	local @@ENV{@@keys} = ();
	# Untaint, plus take out . and empty string:
	local $ENV{'DCL$PATH'} = $1 if $is_vms && exists($ENV{'DCL$PATH'}) && ($ENV{'DCL$PATH'} =~ /(.*)/s);
	$ENV{PATH} =~ /(.*)/s;
	local $ENV{PATH} =
	    join $sep, grep { $_ ne "" and $_ ne "." and -d $_ and
		($is_mswin or $is_vms or !(stat && (stat _)[2]&0022)) }
		    split quotemeta ($sep), $1;
	if ($is_cygwin) {   # Must have /bin under Cygwin
	    if (length $ENV{PATH}) {
		$ENV{PATH} = $ENV{PATH} . $sep;
	    }
	    $ENV{PATH} = $ENV{PATH} . '/bin';
	}
	$runperl =~ /(.*)/s;
	$runperl = $1;

	$result = `$runperl`;
    } else {
	$result = `$runperl`;
    }
    $result =~ s/\n\n/\n/g if $is_vms; # XXX pipes sometimes double these
    return $result;
}

# Nice alias
*run_perl = *run_perl = \&runperl; # shut up "used only once" warning

sub DIE {
    _print_stderr "# @@_\n";
    exit 1;
}

# A somewhat safer version of the sometimes wrong $^X.
sub which_perl {
    unless (defined $Perl) {
	$Perl = $^X;

	# VMS should have 'perl' aliased properly
	return $Perl if $is_vms;

	my $exe;
	if (! eval {require Config; 1}) {
	    warn "test.pl had problems loading Config: $@@";
	    $exe = '';
	} else {
	    $exe = $Config::Config{_exe};
	}
       $exe = '' unless defined $exe;

	# This doesn't absolutize the path: beware of future chdirs().
	# We could do File::Spec->abs2rel() but that does getcwd()s,
	# which is a bit heavyweight to do here.

	if ($Perl =~ /^perl\Q$exe\E$/i) {
	    my $perl = "perl$exe";
	    if (! eval {require File::Spec; 1}) {
		warn "test.pl had problems loading File::Spec: $@@";
		$Perl = "./$perl";
	    } else {
		$Perl = File::Spec->catfile(File::Spec->curdir(), $perl);
	    }
	}

	# Build up the name of the executable file from the name of
	# the command.

	if ($Perl !~ /\Q$exe\E$/i) {
	    $Perl = $Perl . $exe;
	}

	warn "which_perl: cannot find $Perl from $^X" unless -f $Perl;

	# For subcommands to use.
	$ENV{PERLEXE} = $Perl;
    }
    return $Perl;
}

sub unlink_all {
    my $count = 0;
    foreach my $file (@@_) {
        1 while unlink $file;
	if( -f $file ){
	    _print_stderr "# Couldn't unlink '$file': $!\n";
	}else{
	    ++$count;
	}
    }
    $count;
}

# _num_to_alpha - Returns a string of letters representing a positive integer.
# Arguments :
#   number to convert
#   maximum number of letters

# returns undef if the number is negative
# returns undef if the number of letters is greater than the maximum wanted

# _num_to_alpha( 0) eq 'A';
# _num_to_alpha( 1) eq 'B';
# _num_to_alpha(25) eq 'Z';
# _num_to_alpha(26) eq 'AA';
# _num_to_alpha(27) eq 'AB';

my @@letters = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z);

# Avoid ++ -- ranges split negative numbers
sub _num_to_alpha{
    my($num,$max_char) = @@_;
    return unless $num >= 0;
    my $alpha = '';
    my $char_count = 0;
    $max_char = 0 if $max_char < 0;

    while( 1 ){
        $alpha = $letters[ $num % 26 ] . $alpha;
        $num = int( $num / 26 );
        last if $num == 0;
        $num = $num - 1;

        # char limit
        next unless $max_char;
        $char_count = $char_count + 1;
        return if $char_count == $max_char;
    }
    return $alpha;
}

my %tmpfiles;
END { unlink_all keys %tmpfiles }

# A regexp that matches the tempfile names
$::tempfile_regexp = 'tmp\d+[A-Z][A-Z]?';

# Avoid ++, avoid ranges, avoid split //
my $tempfile_count = 0;
sub tempfile {
    while(1){
	my $try = "tmp$$";
        my $alpha = _num_to_alpha($tempfile_count,2);
        last unless defined $alpha;
        $try = $try . $alpha;
        $tempfile_count = $tempfile_count + 1;

	# Need to note all the file names we allocated, as a second request may
	# come before the first is created.
	if (!$tmpfiles{$try} && !-e $try) {
	    # We have a winner
	    $tmpfiles{$try} = 1;
	    return $try;
	}
    }
    die "Can't find temporary file name starting \"tmp$$\"";
}

# register_tempfile - Adds a list of files to be removed at the end of the current test file
# Arguments :
#   a list of files to be removed later

# returns a count of how many file names were actually added

# Reuses %tmpfiles so that tempfile() will also skip any files added here
# even if the file doesn't exist yet.

sub register_tempfile {
    my $count = 0;
    for( @@_ ){
	if( $tmpfiles{$_} ){
	    _print_stderr "# Temporary file '$_' already added\n";
	}else{
	    $tmpfiles{$_} = 1;
	    $count = $count + 1;
	}
    }
    return $count;
}

# This is the temporary file for _fresh_perl
my $tmpfile = tempfile();

sub _fresh_perl {
    my($prog, $action, $expect, $runperl_args, $name) = @@_;

    # Given the choice of the mis-parsable {}
    # (we want an anon hash, but a borked lexer might think that it's a block)
    # or relying on taking a reference to a lexical
    # (\ might be mis-parsed, and the reference counting on the pad may go
    #  awry)
    # it feels like the least-worse thing is to assume that auto-vivification
    # works. At least, this is only going to be a run-time failure, so won't
    # affect tests using this file but not this function.
    $runperl_args->{progfile} ||= $tmpfile;
    $runperl_args->{stderr}     = 1 unless exists $runperl_args->{stderr};

    open TEST, ">$tmpfile" or die "Cannot open $tmpfile: $!";
    print TEST $prog;
    close TEST or die "Cannot close $tmpfile: $!";

    my $results = runperl(%$runperl_args);
    my $status = $?;

    # Clean up the results into something a bit more predictable.
    $results  =~ s/\n+$//;
    $results =~ s/at\s+$::tempfile_regexp\s+line/at - line/g;
    $results =~ s/of\s+$::tempfile_regexp\s+aborted/of - aborted/g;

    # bison says 'parse error' instead of 'syntax error',
    # various yaccs may or may not capitalize 'syntax'.
    $results =~ s/^(syntax|parse) error/syntax error/mig;

    if ($is_vms) {
        # some tests will trigger VMS messages that won't be expected
        $results =~ s/\n?%[A-Z]+-[SIWEF]-[A-Z]+,.*//;

        # pipes double these sometimes
        $results =~ s/\n\n/\n/g;
    }

    # Use the first line of the program as a name if none was given
    unless( $name ) {
        ($first_line, $name) = $prog =~ /^((.{1,50}).*)/;
        $name = $name . '...' if length $first_line > length $name;
    }

    # Historically this was implemented using a closure, but then that means
    # that the tests for closures avoid using this code. Given that there
    # are exactly two callers, doing exactly two things, the simpler approach
    # feels like a better trade off.
    my $pass;
    if ($action eq 'eq') {
	$pass = is($results, $expect, $name);
    } elsif ($action eq '=~') {
	$pass = like($results, $expect, $name);
    } else {
	die "_fresh_perl can't process action '$action'";
    }
	
    unless ($pass) {
        _diag "# PROG: \n$prog\n";
        _diag "# STATUS: $status\n";
    }

    return $pass;
}

#
# fresh_perl_is
#
# Combination of run_perl() and is().
#

sub fresh_perl_is {
    my($prog, $expected, $runperl_args, $name) = @@_;

    # _fresh_perl() is going to clip the trailing newlines off the result.
    # This will make it so the test author doesn't have to know that.
    $expected =~ s/\n+$//;

    local $Level = 2;
    _fresh_perl($prog, 'eq', $expected, $runperl_args, $name);
}

#
# fresh_perl_like
#
# Combination of run_perl() and like().
#

sub fresh_perl_like {
    my($prog, $expected, $runperl_args, $name) = @@_;
    local $Level = 2;
    _fresh_perl($prog, '=~', $expected, $runperl_args, $name);
}

# Many tests use the same format in __DATA__ or external files to specify a
# sequence of (fresh) tests to run, extra files they may temporarily need, and
# what the expected output is.  Putting it here allows common code to serve
# these multiple tests.
#
# Each program is source code to run followed by an "EXPECT" line, followed
# by the expected output.
#
# The code to run may begin with a command line switch such as -w or -0777
# (alphanumerics only), and may contain (note the '# ' on each):
#   # TODO reason for todo
#   # SKIP reason for skip
#   # SKIP ?code to test if this should be skipped
#   # NAME name of the test (as with ok($ok, $name))
#
# The expected output may contain:
#   OPTION list of options
#   OPTIONS list of options
#
# The possible options for OPTION may be:
#   regex - the expected output is a regular expression
#   random - all lines match but in any order
#   fatal - the code will fail fatally (croak, die)
#
# If the actual output contains a line "SKIPPED" the test will be
# skipped.
#
# If the actual output contains a line "PREFIX", any output starting with that
# line will be ignored when comparing with the expected output
#
# If the global variable $FATAL is true then OPTION fatal is the
# default.

sub _setup_one_file {
    my $fh = shift;
    # Store the filename as a program that started at line 0.
    # Real files count lines starting at line 1.
    my @@these = (0, shift);
    my ($lineno, $current);
    while (<$fh>) {
        if ($_ eq "########\n") {
            if (defined $current) {
                push @@these, $lineno, $current;
            }
            undef $current;
        } else {
            if (!defined $current) {
                $lineno = $.;
            }
            $current .= $_;
        }
    }
    if (defined $current) {
        push @@these, $lineno, $current;
    }
    ((scalar @@these) / 2 - 1, @@these);
}

sub setup_multiple_progs {
    my ($tests, @@prgs);
    foreach my $file (@@_) {
        next if $file =~ /(?:~|\.orig|,v)$/;
        next if $file =~ /perlio$/ && !PerlIO::Layer->find('perlio');
        next if -d $file;

        open my $fh, '<', $file or die "Cannot open $file: $!\n" ;
        my $found;
        while (<$fh>) {
            if (/^__END__/) {
                ++$found;
                last;
            }
        }
        # This is an internal error, and should never happen. All bar one of
        # the files had an __END__ marker to signal the end of their preamble,
        # although for some it wasn't technically necessary as they have no
        # tests. It might be possible to process files without an __END__ by
        # seeking back to the start and treating the whole file as tests, but
        # it's simpler and more reliable just to make the rule that all files
        # must have __END__ in. This should never fail - a file without an
        # __END__ should not have been checked in, because the regression tests
        # would not have passed.
        die "Could not find '__END__' in $file"
            unless $found;

        my ($t, @@p) = _setup_one_file($fh, $file);
        $tests += $t;
        push @@prgs, @@p;

        close $fh
            or die "Cannot close $file: $!\n";
    }
    return ($tests, @@prgs);
}

sub run_multiple_progs {
    my $up = shift;
    my @@prgs;
    if ($up) {
	# The tests in lib run in a temporary subdirectory of t, and always
	# pass in a list of "programs" to run
	@@prgs = @@_;
    } else {
        # The tests below t run in t and pass in a file handle. In theory we
        # can pass (caller)[1] as the second argument to report errors with
        # the filename of our caller, as the handle is always DATA. However,
        # line numbers in DATA count from the __END__ token, so will be wrong.
        # Which is more confusing than not providing line numbers. So, for now,
        # don't provide line numbers. No obvious clean solution - one hack
        # would be to seek DATA back to the start and read to the __END__ token,
        # but that feels almost like we should just open $0 instead.

        # Not going to rely on undef in list assignment.
        my $dummy;
        ($dummy, @@prgs) = _setup_one_file(shift);
    }

    my $tmpfile = tempfile();

    my ($file, $line);
  PROGRAM:
    while (defined ($line = shift @@prgs)) {
        $_ = shift @@prgs;
        unless ($line) {
            $file = $_;
            if (defined $file) {
                print "# From $file\n";
            }
	    next;
	}
	my $switch = "";
	my @@temps ;
	my @@temp_path;
	if (s/^(\s*-\w+)//) {
	    $switch = $1;
	}
	my ($prog, $expected) = split(/\nEXPECT(?:\n|$)/, $_, 2);

	my %reason;
	foreach my $what (qw(skip todo)) {
	    $prog =~ s/^#\s*\U$what\E\s*(.*)\n//m and $reason{$what} = $1;
	    # If the SKIP reason starts ? then it's taken as a code snippet to
	    # evaluate. This provides the flexibility to have conditional SKIPs
	    if ($reason{$what} && $reason{$what} =~ s/^\?//) {
		my $temp = eval $reason{$what};
		if ($@@) {
		    die "# In \U$what\E code reason:\n# $reason{$what}\n$@@";
		}
		$reason{$what} = $temp;
	    }
	}

	my $name = '';
	if ($prog =~ s/^#\s*NAME\s+(.+)\n//m) {
	    $name = $1;
	}

	if ($reason{skip}) {
	SKIP:
	  {
	    skip($name ? "$name - $reason{skip}" : $reason{skip}, 1);
	  }
	  next PROGRAM;
	}

	if ($prog =~ /--FILE--/) {
	    my @@files = split(/\n?--FILE--\s*([^\s\n]*)\s*\n/, $prog) ;
	    shift @@files ;
	    die "Internal error: test $_ didn't split into pairs, got " .
		scalar(@@files) . "[" . join("%%%%", @@files) ."]\n"
		    if @@files % 2;
	    while (@@files > 2) {
		my $filename = shift @@files;
		my $code = shift @@files;
		push @@temps, $filename;
		if ($filename =~ m#(.*)/# && $filename !~ m#^\.\./#) {
		    require File::Path;
		    File::Path::mkpath($1);
		    push(@@temp_path, $1);
		}
		open my $fh, '>', $filename or die "Cannot open $filename: $!\n";
		print $fh $code;
		close $fh or die "Cannot close $filename: $!\n";
	    }
	    shift @@files;
	    $prog = shift @@files;
	}

	open my $fh, '>', $tmpfile or die "Cannot open >$tmpfile: $!";
	print $fh q{
        BEGIN {
            open STDERR, '>&', STDOUT
              or die "Can't dup STDOUT->STDERR: $!;";
        }
	};
	print $fh "\n#line 1\n";  # So the line numbers don't get messed up.
	print $fh $prog,"\n";
	close $fh or die "Cannot close $tmpfile: $!";
	my $results = runperl( stderr => 1, progfile => $tmpfile,
			       stdin => undef, $up
			       ? (switches => ["-I$up/lib", $switch], nolib => 1)
			       : (switches => [$switch])
			        );
	my $status = $?;
	$results =~ s/\n+$//;
	# allow expected output to be written as if $prog is on STDIN
	$results =~ s/$::tempfile_regexp/-/g;
	if ($^O eq 'VMS') {
	    # some tests will trigger VMS messages that won't be expected
	    $results =~ s/\n?%[A-Z]+-[SIWEF]-[A-Z]+,.*//;

	    # pipes double these sometimes
	    $results =~ s/\n\n/\n/g;
	}
	# bison says 'parse error' instead of 'syntax error',
	# various yaccs may or may not capitalize 'syntax'.
	$results =~ s/^(syntax|parse) error/syntax error/mig;
	# allow all tests to run when there are leaks
	$results =~ s/Scalars leaked: \d+\n//g;

	$expected =~ s/\n+$//;
	my $prefix = ($results =~ s#^PREFIX(\n|$)##) ;
	# any special options? (OPTIONS foo bar zap)
	my $option_regex = 0;
	my $option_random = 0;
	my $fatal = $FATAL;
	if ($expected =~ s/^OPTIONS? (.+)\n//) {
	    foreach my $option (split(' ', $1)) {
		if ($option eq 'regex') { # allow regular expressions
		    $option_regex = 1;
		}
		elsif ($option eq 'random') { # all lines match, but in any order
		    $option_random = 1;
		}
		elsif ($option eq 'fatal') { # perl should fail
		    $fatal = 1;
		}
		else {
		    die "$0: Unknown OPTION '$option'\n";
		}
	    }
	}
	die "$0: can't have OPTION regex and random\n"
	    if $option_regex + $option_random > 1;
	my $ok = 0;
	if ($results =~ s/^SKIPPED\n//) {
	    print "$results\n" ;
	    $ok = 1;
	}
	else {
	    if ($option_random) {
	        my @@got = sort split "\n", $results;
	        my @@expected = sort split "\n", $expected;

	        $ok = "@@got" eq "@@expected";
	    }
	    elsif ($option_regex) {
	        $ok = $results =~ /^$expected/;
	    }
	    elsif ($prefix) {
	        $ok = $results =~ /^\Q$expected/;
	    }
	    else {
	        $ok = $results eq $expected;
	    }

	    if ($ok && $fatal && !($status >> 8)) {
		$ok = 0;
	    }
	}

	local $::TODO = $reason{todo};

	unless ($ok) {
	    my $err_line = "PROG: $switch\n$prog\n" .
			   "EXPECTED:\n$expected\n";
	    $err_line   .= "EXIT STATUS: != 0\n" if $fatal;
	    $err_line   .= "GOT:\n$results\n";
	    $err_line   .= "EXIT STATUS: " . ($status >> 8) . "\n" if $fatal;
	    if ($::TODO) {
		$err_line =~ s/^/# /mg;
		print $err_line;  # Harness can't filter it out from STDERR.
	    }
	    else {
		print STDERR $err_line;
	    }
	}

        if (defined $file) {
            _ok($ok, "at $file line $line", $name);
        } else {
            # We don't have file and line number data for the test, so report
            # errors as coming from our caller.
            local $Level = $Level + 1;
            ok($ok, $name);
        }

	foreach (@@temps) {
	    unlink $_ if $_;
	}
	foreach (@@temp_path) {
	    File::Path::rmtree $_ if -d $_;
	}
    }
}

sub can_ok ($@@) {
    my($proto, @@methods) = @@_;
    my $class = ref $proto || $proto;

    unless( @@methods ) {
        return _ok( 0, _where(), "$class->can(...)" );
    }

    my @@nok = ();
    foreach my $method (@@methods) {
        local($!, $@@);  # don't interfere with caller's $@@
                        # eval sometimes resets $!
        eval { $proto->can($method) } || push @@nok, $method;
    }

    my $name;
    $name = @@methods == 1 ? "$class->can('$methods[0]')"
                          : "$class->can(...)";

    _ok( !@@nok, _where(), $name );
}


# Call $class->new( @@$args ); and run the result through object_ok.
# See Test::More::new_ok
sub new_ok {
    my($class, $args, $obj_name) = @@_;
    $args ||= [];
    $object_name = "The object" unless defined $obj_name;

    local $Level = $Level + 1;

    my $obj;
    my $ok = eval { $obj = $class->new(@@$args); 1 };
    my $error = $@@;

    if($ok) {
        object_ok($obj, $class, $object_name);
    }
    else {
        ok( 0, "new() died" );
        diag("Error was:  $@@");
    }

    return $obj;

}


sub isa_ok ($$;$) {
    my($object, $class, $obj_name) = @@_;

    my $diag;
    $obj_name = 'The object' unless defined $obj_name;
    my $name = "$obj_name isa $class";
    if( !defined $object ) {
        $diag = "$obj_name isn't defined";
    }
    else {
        my $whatami = ref $object ? 'object' : 'class';

        # We can't use UNIVERSAL::isa because we want to honor isa() overrides
        local($@@, $!);  # eval sometimes resets $!
        my $rslt = eval { $object->isa($class) };
        my $error = $@@;  # in case something else blows away $@@

        if( $error ) {
            if( $error =~ /^Can't call method "isa" on unblessed reference/ ) {
                # It's an unblessed reference
                $obj_name = 'The reference' unless defined $obj_name;
                if( !UNIVERSAL::isa($object, $class) ) {
                    my $ref = ref $object;
                    $diag = "$obj_name isn't a '$class' it's a '$ref'";
                }
            }
            elsif( $error =~ /Can't call method "isa" without a package/ ) {
                # It's something that can't even be a class
                $obj_name = 'The thing' unless defined $obj_name;
                $diag = "$obj_name isn't a class or reference";
            }
            else {
                die <<WHOA;
WHOA! I tried to call ->isa on your object and got some weird error.
This should never happen.  Please contact the author immediately.
Here's the error.
$@@
WHOA
            }
        }
        elsif( !$rslt ) {
            $obj_name = "The $whatami" unless defined $obj_name;
            my $ref = ref $object;
            $diag = "$obj_name isn't a '$class' it's a '$ref'";
        }
    }

    _ok( !$diag, _where(), $name );
}


sub class_ok {
    my($class, $isa, $class_name) = @@_;

    # Written so as to count as one test
    local $Level = $Level + 1;
    if( ref $class ) {
        ok( 0, "$class is a reference, not a class name" );
    }
    else {
        isa_ok($class, $isa, $class_name);
    }
}


sub object_ok {
    my($obj, $isa, $obj_name) = @@_;

    local $Level = $Level + 1;
    if( !ref $obj ) {
        ok( 0, "$obj is not a reference" );
    }
    else {
        isa_ok($obj, $isa, $obj_name);
    }
}


# Purposefully avoiding a closure.
sub __capture {
    push @@::__capture, join "", @@_;
}
    
sub capture_warnings {
    my $code = shift;

    local @@::__capture;
    local $SIG {__WARN__} = \&__capture;
    &$code;
    return @@::__capture;
}

# This will generate a variable number of tests.
# Use done_testing() instead of a fixed plan.
sub warnings_like {
    my ($code, $expect, $name) = @@_;
    local $Level = $Level + 1;

    my @@w = capture_warnings($code);

    cmp_ok(scalar @@w, '==', scalar @@$expect, $name);
    foreach my $e (@@$expect) {
	if (ref $e) {
	    like(shift @@w, $e, $name);
	} else {
	    is(shift @@w, $e, $name);
	}
    }
    if (@@w) {
	diag("Saw these additional warnings:");
	diag($_) foreach @@w;
    }
}

sub _fail_excess_warnings {
    my($expect, $got, $name) = @@_;
    local $Level = $Level + 1;
    # This will fail, and produce diagnostics
    is($expect, scalar @@$got, $name);
    diag("Saw these warnings:");
    diag($_) foreach @@$got;
}

sub warning_is {
    my ($code, $expect, $name) = @@_;
    die sprintf "Expect must be a string or undef, not a %s reference", ref $expect
	if ref $expect;
    local $Level = $Level + 1;
    my @@w = capture_warnings($code);
    if (@@w > 1) {
	_fail_excess_warnings(0 + defined $expect, \@@w, $name);
    } else {
	is($w[0], $expect, $name);
    }
}

sub warning_like {
    my ($code, $expect, $name) = @@_;
    die sprintf "Expect must be a regexp object"
	unless ref $expect eq 'Regexp';
    local $Level = $Level + 1;
    my @@w = capture_warnings($code);
    if (@@w > 1) {
	_fail_excess_warnings(0 + defined $expect, \@@w, $name);
    } else {
	like($w[0], $expect, $name);
    }
}

# Set a watchdog to timeout the entire test file
# NOTE:  If the test file uses 'threads', then call the watchdog() function
#        _AFTER_ the 'threads' module is loaded.
sub watchdog ($;$)
{
    my $timeout = shift;
    my $method  = shift || "";
    my $timeout_msg = 'Test process timed out - terminating';

    # Valgrind slows perl way down so give it more time before dying.
    $timeout *= 10 if $ENV{PERL_VALGRIND};

    my $pid_to_kill = $$;   # PID for this process

    if ($method eq "alarm") {
        goto WATCHDOG_VIA_ALARM;
    }

    # shut up use only once warning
    my $threads_on = $threads::threads && $threads::threads;

    # Don't use a watchdog process if 'threads' is loaded -
    #   use a watchdog thread instead
    if (!$threads_on || $method eq "process") {

        # On Windows and VMS, try launching a watchdog process
        #   using system(1, ...) (see perlport.pod)
        if ($is_mswin || $is_vms) {
            # On Windows, try to get the 'real' PID
            if ($is_mswin) {
                eval { require Win32; };
                if (defined(&Win32::GetCurrentProcessId)) {
                    $pid_to_kill = Win32::GetCurrentProcessId();
                }
            }

            # If we still have a fake PID, we can't use this method at all
            return if ($pid_to_kill <= 0);

            # Launch watchdog process
            my $watchdog;
            eval {
                local $SIG{'__WARN__'} = sub {
                    _diag("Watchdog warning: $_[0]");
                };
                my $sig = $is_vms ? 'TERM' : 'KILL';
                my $prog = "sleep($timeout);" .
                           "warn qq/# $timeout_msg" . '\n/;' .
                           "kill(q/$sig/, $pid_to_kill);";

                # On Windows use the indirect object plus LIST form to guarantee
                # that perl is launched directly rather than via the shell (see
                # perlfunc.pod), and ensure that the LIST has multiple elements
                # since the indirect object plus COMMANDSTRING form seems to
                # hang (see perl #121283). Don't do this on VMS, which doesn't
                # support the LIST form at all.
                if ($is_mswin) {
                    my $runperl = which_perl();
                    if ($runperl =~ m/\s/) {
                        $runperl = qq{"$runperl"};
                    }
                    $watchdog = system({ $runperl } 1, $runperl, '-e', $prog);
                }
                else {
                    my $cmd = _create_runperl(prog => $prog);
                    $watchdog = system(1, $cmd);
                }
            };
            if ($@@ || ($watchdog <= 0)) {
                _diag('Failed to start watchdog');
                _diag($@@) if $@@;
                undef($watchdog);
                return;
            }

            # Add END block to parent to terminate and
            #   clean up watchdog process
            eval("END { local \$! = 0; local \$? = 0;
                        wait() if kill('KILL', $watchdog); };");
            return;
        }

        # Try using fork() to generate a watchdog process
        my $watchdog;
        eval { $watchdog = fork() };
        if (defined($watchdog)) {
            if ($watchdog) {   # Parent process
                # Add END block to parent to terminate and
                #   clean up watchdog process
                eval "END { local \$! = 0; local \$? = 0;
                            wait() if kill('KILL', $watchdog); };";
                return;
            }

            ### Watchdog process code

            # Load POSIX if available
            eval { require POSIX; };

            # Execute the timeout
            sleep($timeout - 2) if ($timeout > 2);   # Workaround for perlbug #49073
            sleep(2);

            # Kill test process if still running
            if (kill(0, $pid_to_kill)) {
                _diag($timeout_msg);
                kill('KILL', $pid_to_kill);
		if ($is_cygwin) {
		    # sometimes the above isn't enough on cygwin
		    sleep 1; # wait a little, it might have worked after all
		    system("/bin/kill -f $pid_to_kill");
		}
            }

            # Don't execute END block (added at beginning of this file)
            $NO_ENDING = 1;

            # Terminate ourself (i.e., the watchdog)
            POSIX::_exit(1) if (defined(&POSIX::_exit));
            exit(1);
        }

        # fork() failed - fall through and try using a thread
    }

    # Use a watchdog thread because either 'threads' is loaded,
    #   or fork() failed
    if (eval {require threads; 1}) {
        'threads'->create(sub {
                # Load POSIX if available
                eval { require POSIX; };

                # Execute the timeout
                my $time_left = $timeout;
                do {
                    $time_left = $time_left - sleep($time_left);
                } while ($time_left > 0);

                # Kill the parent (and ourself)
                select(STDERR); $| = 1;
                _diag($timeout_msg);
                POSIX::_exit(1) if (defined(&POSIX::_exit));
                my $sig = $is_vms ? 'TERM' : 'KILL';
                kill($sig, $pid_to_kill);
            })->detach();
        return;
    }

    # If everything above fails, then just use an alarm timeout
WATCHDOG_VIA_ALARM:
    if (eval { alarm($timeout); 1; }) {
        # Load POSIX if available
        eval { require POSIX; };

        # Alarm handler will do the actual 'killing'
        $SIG{'ALRM'} = sub {
            select(STDERR); $| = 1;
            _diag($timeout_msg);
            POSIX::_exit(1) if (defined(&POSIX::_exit));
            my $sig = $is_vms ? 'TERM' : 'KILL';
            kill($sig, $pid_to_kill);
        };
    }
}

1;
@


1.1
log
@Initial revision
@
text
@d3 15
d19 2
d22 1
d25 6
d34 12
d51 4
d57 2
a58 1
	$n = $plan{tests}; 
d60 11
a70 1
    print STDOUT "1..$n\n";
d74 1
d77 7
a83 2
    if (!$NO_ENDING && defined $planned && $planned != $ran) {
        print STDERR "# Looks like you planned $planned tests but ran $ran.\n";
d87 7
a93 1
# Use this instead of "print STDERR" when outputing failure diagnostic 
d95 6
a100 1
sub _diag {
d102 2
a103 4
    my @@mess = map { /^#/ ? "$_\n" : "# $_\n" } 
               map { split /\n/ } @@_;
    my $fh = $TODO ? *STDOUT : *STDERR;
    print $fh @@mess;
d105 23
d132 1
a132 1
	print STDOUT "1..0 # Skipped: @@_\n";
d134 1
a134 1
	print STDOUT "1..0\n";
d139 86
d238 7
a244 2
    $out .= " # TODO $TODO" if $TODO;
    print STDOUT "$out\n";
d246 9
a254 2
    unless ($pass) {
	_diag "# Failed $where\n";
d257 1
a257 4
    # Ensure that the message is properly escaped.
    _diag @@mess;

    $test++;
d263 1
a263 1
    my @@caller = caller(1);
d268 1
a268 1
sub ok {
d277 2
a278 2
    $q =~ s/\\/\\\\/;
    $q =~ s/'/\\'/;
d299 1
a299 1
            foreach my $c (unpack("U*", $x)) {
d301 1
a301 1
                    $y .= sprintf "\\x{%x}", $c;
d303 1
a303 1
                    $y .= $backslash_escape{$c};
d306 19
a324 2
                    $z = sprintf "\\%03o", $c if $z =~ /[[:^print:]]/;
                    $y .= $z;
d335 1
a335 1
sub is {
d337 10
a346 1
    my $pass = $got eq $expected;
d348 2
a349 2
	unshift(@@mess, "#      got "._q($got)."\n",
		       "# expected "._q($expected)."\n");
d354 1
a354 1
sub isnt {
d356 10
a365 1
    my $pass = $got ne $isnt;
d367 1
a367 1
        unshift(@@mess, "# it should not be "._q($got)."\n",
d373 1
a373 1
sub cmp_ok {
d385 1
a385 1
        # that stringify to the same thing but are acutally numerically
d389 2
a390 2
        # This will also show numbers for some uneeded cases, but will
        # definately be helpful for things such as == and <= that fail
d394 2
a395 2
        unshift(@@mess, "#      got "._q($got)."\n",
                       "# expected $type "._q($expected)."\n");
d406 1
a406 1
sub within {
d431 2
a432 2
	unshift@@mess, "#      got "._q($got)."\n",
		      "# expected "._q($expected)." (within "._q($range).")\n";
d438 14
a451 2
sub like {
    my ($got, $expected, $name, @@mess) = @@_;
d453 11
a463 12
    if (ref $expected eq 'Regexp') {
	$pass = $got =~ $expected;
	unless ($pass) {
	    unshift(@@mess, "#      got '$got'\n",
		           "# expected /$expected/\n");
	}
    } else {
	$pass = $got =~ /$expected/;
	unless ($pass) {
	    unshift(@@mess, "#      got '$got'\n",
		           "# expected /$expected/\n");
	}
d465 1
d483 3
a485 1
  $test++;
d492 15
a506 1
    my $n    = @@_ ? shift : 1;
d508 2
a509 2
        print STDOUT "ok $test # skip: $why\n";
        $test++;
d515 24
d543 3
d558 5
a562 2
      if ($orig->{$key} ne $value) {
        print STDOUT "# key ", _qq($key), " was ", _qq($orig->{$key}),
d567 1
a567 1
      print STDOUT "# key ", _qq($key), " is ", _qq($value), 
d576 1
a576 1
    print STDOUT "# key ", _qq($_), " was ", _qq($orig->{$_}), " now missing.\n";
d582 2
a583 1
sub require_ok {
d585 4
a588 1
    eval <<REQUIRE_OK;
d591 2
a592 1
    _ok(!$@@, _where(), "require $require");
d595 1
a595 1
sub use_ok {
d597 4
a600 1
    eval <<USE_OK;
d603 2
a604 1
    _ok(!$@@, _where(), "use $use");
d607 1
a607 1
# runperl - Runs a separate perl interpreter.
d611 1
d615 3
a617 2
#   stdin    => string to feed the stdin
#   stderr   => redirect stderr to stdout
a622 1
my $is_macos    = $^O eq 'MacOS';
d624 1
d633 1
a633 1
	$$runperl .= ' ' . $_;
d635 1
d638 1
a638 1
sub runperl {
d640 8
a647 1
    my $runperl = $^X;
d649 1
a649 8
	if ($is_macos) {
	    $runperl .= ' -I::lib';
	    # Use UNIX style error messages instead of MPW style.
	    $runperl .= ' -MMac::err=unix' if $args{stderr};
	}
	else {
	    $runperl .= ' "-I../lib"'; # doublequotes because of VMS
	}
d652 4
a655 1
	_quote_args(\$runperl, $args{switches});
d658 3
a660 1
        $args{progs} = [$args{prog}]
d663 2
d666 11
d678 1
a678 1
                $runperl .= qq ( -e "$prog" );
d681 1
a681 1
                $runperl .= qq ( -e '$prog' );
d685 7
a691 1
	$runperl .= qq( "$args{progfile}");
d700 1
a700 1
	    $runperl = qq{$^X -e "print qq(} .
a702 13
	elsif ($is_macos) {
	    # MacOS can only do two processes under MPW at once;
	    # the test itself is one; we can't do two more, so
	    # write to temp file
	    my $stdin = qq{$^X -e 'print qq(} . $args{stdin} . qq{)' > teststdin; };
	    if ($args{verbose}) {
		my $stdindisplay = $stdin;
		$stdindisplay =~ s/\n/\n\#/g;
		print STDERR "# $stdindisplay\n";
	    }
	    `$stdin`;
	    $runperl .= q{ < teststdin };
	}
d704 1
a704 1
	    $runperl = qq{$^X -e 'print qq(} .
d707 22
d731 7
a737 1
	_quote_args(\$runperl, $args{args});
a738 2
    $runperl .= ' 2>&1'          if  $args{stderr} && !$is_macos;
    $runperl .= " \xB3 Dev:Null" if !$args{stderr} &&  $is_macos;
d742 49
a790 1
	print STDERR "# $runperldisplay\n";
d792 1
a792 2
    my $result = `$runperl`;
    $result =~ s/\n\n/\n/ if $is_vms; # XXX pipes sometimes double these
d796 2
a797 1
*run_perl = \&runperl; # Nice alias.
d800 1
a800 1
    print STDERR "# @@_\n";
a804 1
my $Perl;
d808 1
a808 1
	
d810 1
a810 1
	return $Perl if $^O eq 'VMS';
d813 1
a813 2
	eval "require Config; Config->import";
	if ($@@) {
d817 1
a817 1
	    $exe = $Config{_exe};
d820 1
a820 1
	
d824 1
a824 1
	
d827 1
a827 2
	    eval "require File::Spec";
	    if ($@@) {
d839 1
a839 1
	    $Perl .= $exe;
d843 1
a843 1
	
d851 1
d854 5
a858 1
        print STDERR "# Couldn't unlink '$file': $!\n" if -f $file;
d860 1
d863 64
d928 3
a930 3
my $tmpfile = "misctmp000";
1 while -f ++$tmpfile;
END { unlink_all $tmpfile }
d932 1
a932 7
#
# _fresh_perl
#
# The $resolve must be a subref that tests the first argument
# for success, or returns the definition of success (e.g. the
# expected scalar) if given no arguments.
#
d934 2
a935 2
sub _fresh_perl {
    my($prog, $resolve, $runperl_args, $name) = @@_;
d937 12
a948 3
    $runperl_args ||= {};
    $runperl_args->{progfile} = $tmpfile;
    $runperl_args->{stderr} = 1;
d950 2
a951 1
    open TEST, ">$tmpfile" or die "Cannot open $tmpfile: $!";
d953 2
a954 3
    # VMS adjustments
    if( $^O eq 'VMS' ) {
        $prog =~ s#/dev/null#NL:#;
d956 10
a965 4
        # VMS file locking 
        $prog =~ s{if \(-e _ and -f _ and -r _\)}
                  {if (-e _ and -f _)}
    }
d967 2
a968 1
    print TEST $prog, "\n";
d975 3
a977 3
    $results =~ s/\n+$//;
    $results =~ s/at\s+misctmp\d+\s+line/at - line/g;
    $results =~ s/of\s+misctmp\d+\s+aborted/of - aborted/g;
d983 1
a983 1
    if ($^O eq 'VMS') {
d991 19
a1009 1
    my $pass = $resolve->($results);
a1011 2
        _diag "# EXPECTED:\n", $resolve->(), "\n";
        _diag "# GOT:\n$results\n";
d1015 1
a1015 7
    # Use the first line of the program as a name if none was given
    unless( $name ) {
        ($first_line, $name) = $prog =~ /^((.{1,50}).*)/;
        $name .= '...' if length $first_line > length $name;
    }

    _ok($pass, _where(), "fresh_perl - $name");
d1019 1
a1019 1
# run_perl_is
d1026 7
a1032 3
    _fresh_perl($prog,
		sub { @@_ ? $_[0] eq $expected : $expected },
		$runperl_args, $name);
d1036 1
a1036 1
# run_perl_like
d1043 671
a1713 5
    _fresh_perl($prog,
		sub { @@_ ?
			  $_[0] =~ (ref $expected ? $expected : /$expected/) :
		          $expected },
		$runperl_args, $name);
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@a4 1
$Level = 1;
d79 1
a79 1
    my @@caller = caller($Level);
d84 1
a84 1
sub ok ($@@) {
d134 1
a134 1
sub is ($$@@) {
d136 1
a136 10

    my $pass;
    if( !defined $got || !defined $expected ) {
        # undef only matches undef
        $pass = !defined $got && !defined $expected;
    }
    else {
        $pass = $got eq $expected;
    }

d144 1
a144 1
sub isnt ($$@@) {
d146 1
a146 10

    my $pass;
    if( !defined $got || !defined $isnt ) {
        # undef only matches undef
        $pass = defined $got || defined $isnt;
    }
    else {
        $pass = $got ne $isnt;
    }

d154 1
a154 1
sub cmp_ok ($$$@@) {
d187 1
a187 1
sub within ($$$@@) {
d219 1
a219 1
sub like ($$@@) {
d305 1
a305 1
sub require_ok ($) {
d313 1
a313 1
sub use_ok ($) {
d349 1
a349 1
sub _create_runperl { # Create the string to qx in runperl().
d351 1
a351 1
    my $runperl = $^X =~ m/\s/ ? qq{"$^X"} : $^X;
a362 3
	local $Level = 2;
	die "test.pl:runperl(): 'switches' must be an ARRAYREF " . _where()
	    unless ref $args{switches} eq "ARRAY";
a365 2
	die "test.pl:runperl(): both 'prog' and 'progs' cannot be used " . _where()
	    if defined $args{progs};
a368 2
	die "test.pl:runperl(): 'progs' must be an ARRAYREF " . _where()
	    unless ref $args{progs} eq "ARRAY";
a417 5
    return $runperl;
}

sub runperl {
    my $runperl = &_create_runperl;
a564 1
    local $Level = 2;
a577 1
    local $Level = 2;
@


1.1.1.3
log
@perl 5.8.3 from CPAN
@
text
@d589 1
a589 1
# fresh_perl_is
d603 1
a603 1
# fresh_perl_like
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d238 2
a239 6

sub like   ($$@@) { like_yn (0,@@_) }; # 0 for -
sub unlike ($$@@) { like_yn (1,@@_) }; # 1 for un-

sub like_yn ($$$@@) {
    my ($flip, $got, $expected, $name, @@mess) = @@_;
d241 12
a252 5
    $pass = $got =~ /$expected/ if !$flip;
    $pass = $got !~ /$expected/ if $flip;
    unless ($pass) {
	unshift(@@mess, "#      got '$got'\n",
		"# expected /$expected/\n");
@


1.1.1.5
log
@perl 5.8.6 from CPAN
@
text
@a7 1
my $noplan;
a15 4
	if ($n eq 'no_plan') {
	  undef $n;
	  $noplan = 1;
	}
d20 1
a20 1
    print STDOUT "1..$n\n" unless $noplan;
d26 2
a27 7
    if (!$NO_ENDING) {
	if (defined $planned && $planned != $ran) {
	    print STDERR
		"# Looks like you planned $planned tests but ran $ran.\n";
	} elsif ($noplan) {
	    print "1..$ran\n";
	}
a287 3
	next     if !defined $ra->[$i] && !defined $rb->[$i]; 
	return 0 if !defined $ra->[$i];
	return 0 if !defined $rb->[$i];
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d104 2
a105 2
    $q =~ s/\\/\\\\/g;
    $q =~ s/'/\\'/g;
a260 1
    local $Level = 2;
a293 12
sub todo_skip {
    my $why = shift;
    my $n   = @@_ ? shift : 1;

    for (1..$n) {
        print STDOUT "not ok $test # TODO & SKIP: $why\n";
        $test++;
    }
    local $^W = 0;
    last TODO;
}

a380 4
    #- this allows, for example, to set PERL_RUNPERL_DEBUG=/usr/bin/valgrind
    if ($ENV{PERL_RUNPERL_DEBUG}) {
	$runperl = "$ENV{PERL_RUNPERL_DEBUG} $runperl";
    }
a414 6
    } else {
	# You probaby didn't want to be sucking in from the upstream stdin
	die "test.pl:runperl(): none of prog, progs, progfile, args, "
	    . " switches or stdin specified"
	    unless defined $args{args} or defined $args{switches}
		or defined $args{stdin};
a457 2
    die "test.pl:runperl() does not take a hashref"
	if ref $_[0] and ref $_[0] eq 'HASH';
d558 1
a558 1
    print TEST $prog;
a625 62
}

sub can_ok ($@@) {
    my($proto, @@methods) = @@_;
    my $class = ref $proto || $proto;

    unless( @@methods ) {
        return _ok( 0, _where(), "$class->can(...)" );
    }

    my @@nok = ();
    foreach my $method (@@methods) {
        local($!, $@@);  # don't interfere with caller's $@@
                        # eval sometimes resets $!
        eval { $proto->can($method) } || push @@nok, $method;
    }

    my $name;
    $name = @@methods == 1 ? "$class->can('$methods[0]')" 
                          : "$class->can(...)";
    
    _ok( !@@nok, _where(), $name );
}

sub isa_ok ($$;$) {
    my($object, $class, $obj_name) = @@_;

    my $diag;
    $obj_name = 'The object' unless defined $obj_name;
    my $name = "$obj_name isa $class";
    if( !defined $object ) {
        $diag = "$obj_name isn't defined";
    }
    elsif( !ref $object ) {
        $diag = "$obj_name isn't a reference";
    }
    else {
        # We can't use UNIVERSAL::isa because we want to honor isa() overrides
        local($@@, $!);  # eval sometimes resets $!
        my $rslt = eval { $object->isa($class) };
        if( $@@ ) {
            if( $@@ =~ /^Can't call method "isa" on unblessed reference/ ) {
                if( !UNIVERSAL::isa($object, $class) ) {
                    my $ref = ref $object;
                    $diag = "$obj_name isn't a '$class' it's a '$ref'";
                }
            } else {
                die <<WHOA;
WHOA! I tried to call ->isa on your object and got some weird error.
This should never happen.  Please contact the author immediately.
Here's the error.
$@@
WHOA
            }
        }
        elsif( !$rslt ) {
            my $ref = ref $object;
            $diag = "$obj_name isn't a '$class' it's a '$ref'";
        }
    }

    _ok( !$diag, _where(), $name );
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@a2 8


# NOTE:
#
# Increment ($x++) has a certain amount of cleverness for things like
#
#   $x = 'zz';
#   $x++; # $x eq 'aaa';
a3 6
# stands more chance of breaking than just a simple
#
#   $x = $x + 1
#
# In this file, we use the latter "Baby Perl" approach, and increment
# will be worked over by t/op/inc.t
d23 1
a23 1
	$n = $plan{tests};
d41 1
a41 1
# Use this instead of "print STDERR" when outputing failure diagnostic
d45 1
a45 1
    my @@mess = map { /^#/ ? "$_\n" : "# $_\n" }
a51 4
sub diag {
    _diag(@@_);
}

d84 1
a84 1
    $test = $test + 1; # don't use ++
d259 1
a259 2
		$flip
		? "# expected !~ /$expected/\n" : "# expected /$expected/\n");
d261 1
a261 1
    local $Level = $Level + 1;
d279 1
a279 3
  my $retval = $test;
  $test = $test + 1; # don't use ++
  $retval;
d289 1
a289 1
        $test = $test + 1;
d301 1
a301 1
        $test = $test + 1;
d311 1
a311 1
	next     if !defined $ra->[$i] && !defined $rb->[$i];
d332 1
a332 1
      print STDOUT "# key ", _qq($key), " is ", _qq($value),
a378 1
my $is_cygwin   = $^O eq 'cygwin';
d484 1
a484 37
    my $result;

    my $tainted = ${^TAINT};
    my %args = @@_;
    exists $args{switches} && grep m/^-T$/, @@{$args{switches}} and $tainted = $tainted + 1;

    if ($tainted) {
	# We will assume that if you're running under -T, you really mean to
	# run a fresh perl, so we'll brute force launder everything for you
	my $sep;

	eval "require Config; Config->import";
	if ($@@) {
	    warn "test.pl had problems loading Config: $@@";
	    $sep = ':';
	} else {
	    $sep = $Config{path_sep};
	}

	my @@keys = grep {exists $ENV{$_}} qw(CDPATH IFS ENV BASH_ENV);
	local @@ENV{@@keys} = ();
	# Untaint, plus take out . and empty string:
	local $ENV{'DCL$PATH'} = $1 if $is_vms && ($ENV{'DCL$PATH'} =~ /(.*)/s);
	$ENV{PATH} =~ /(.*)/s;
	local $ENV{PATH} =
	    join $sep, grep { $_ ne "" and $_ ne "." and -d $_ and
		($is_mswin or $is_vms or !(stat && (stat _)[2]&0022)) }
		    split quotemeta ($sep), $1;
	$ENV{PATH} .= "$sep/bin" if $is_cygwin;  # Must have /bin under Cygwin

	$runperl =~ /(.*)/s;
	$runperl = $1;

	$result = `$runperl`;
    } else {
	$result = `$runperl`;
    }
d501 1
a501 1

d514 1
a514 1

d518 1
a518 1

d538 1
a538 1

d578 1
a578 1
        # VMS file locking
d669 1
a669 1
    $name = @@methods == 1 ? "$class->can('$methods[0]')"
d671 1
a671 1

@


1.1.1.8
log
@import perl 5.10.1
@
text
@a22 1
my $Perl;       # Safer version of $^X set by which_perl()
a26 11
# Use this instead of print to avoid interference while testing globals.
sub _print {
    local($\, $", $,) = (undef, ' ', '');
    print STDOUT @@_;
}

sub _print_stderr {
    local($\, $", $,) = (undef, ' ', '');
    print STDERR @@_;
}

d39 1
a39 1
    _print "1..$n\n" unless $noplan;
d47 1
a47 1
	    _print_stderr
d50 1
a50 1
	    _print "1..$ran\n";
d61 3
a63 1
    $TODO ? _print(@@mess) : _print_stderr(@@mess);
d72 1
a72 1
        _print "1..0 # Skip @@_\n";
d74 1
a74 1
	_print "1..0\n";
d93 1
a93 1
    _print "$out\n";
d309 1
a309 1
        _print "ok $test # skip $why\n";
d321 1
a321 1
        _print "not ok $test # TODO & SKIP $why\n";
d348 1
a348 1
        _print "# key ", _qq($key), " was ", _qq($orig->{$key}),
d353 1
a353 1
      _print "# key ", _qq($key), " is ", _qq($value),
d362 1
a362 1
    _print "# key ", _qq($_), " was ", _qq($orig->{$_}), " now missing.\n";
d415 1
a415 4
    my $runperl = which_perl();
    if ($runperl =~ m/\s/) {
        $runperl = qq{"$runperl"};
    }
d468 1
a468 1
	    $runperl = qq{$Perl -e "print qq(} .
d475 1
a475 1
	    my $stdin = qq{$Perl -e 'print qq(} . $args{stdin} . qq{)' > teststdin; };
d479 1
a479 1
		_print_stderr "# $stdindisplay\n";
d485 1
a485 1
	    $runperl = qq{$Perl -e 'print qq(} .
d497 1
a497 1
	_print_stderr "# $runperldisplay\n";
d517 2
a518 1
	if (! eval 'require Config; 1') {
d522 1
a522 1
	    $sep = $Config::Config{path_sep};
d550 1
a550 1
    _print_stderr "# @@_\n";
d555 1
d564 2
a565 1
	if (! eval 'require Config; 1') {
d569 1
a569 1
	    $exe = $Config::Config{_exe};
d579 2
a580 1
	    if (! eval 'require File::Spec; 1') {
d606 1
a606 1
        _print_stderr "# Couldn't unlink '$file': $!\n" if -f $file;
a609 28
my %tmpfiles;
END { unlink_all keys %tmpfiles }

# A regexp that matches the tempfile names
$::tempfile_regexp = 'tmp\d+[A-Z][A-Z]?';

# Avoid ++, avoid ranges, avoid split //
my @@letters = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z);
sub tempfile {
    my $count = 0;
    do {
	my $temp = $count;
	my $try = "tmp$$";
	do {
	    $try .= $letters[$temp % 26];
	    $temp = int ($temp / 26);
	} while $temp;
	# Need to note all the file names we allocated, as a second request may
	# come before the first is created.
	if (!-e $try && !$tmpfiles{$try}) {
	    # We have a winner
	    $tmpfiles{$try}++;
	    return $try;
	}
	$count = $count + 1;
    } while $count < 26 * 26;
    die "Can't find temporary file name starting 'tmp$$'";
}
d611 3
a613 2
# This is the temporary file for _fresh_perl
my $tmpfile = tempfile();
d649 2
a650 2
    $results =~ s/at\s+$::tempfile_regexp\s+line/at - line/g;
    $results =~ s/of\s+$::tempfile_regexp\s+aborted/of - aborted/g;
a770 131
}

# Set a watchdog to timeout the entire test file
# NOTE:  If the test file uses 'threads', then call the watchdog() function
#        _AFTER_ the 'threads' module is loaded.
sub watchdog ($)
{
    my $timeout = shift;
    my $timeout_msg = 'Test process timed out - terminating';

    my $pid_to_kill = $$;   # PID for this process

    # Don't use a watchdog process if 'threads' is loaded -
    #   use a watchdog thread instead
    if (! $threads::threads) {

        # On Windows and VMS, try launching a watchdog process
        #   using system(1, ...) (see perlport.pod)
        if (($^O eq 'MSWin32') || ($^O eq 'VMS')) {
            # On Windows, try to get the 'real' PID
            if ($^O eq 'MSWin32') {
                eval { require Win32; };
                if (defined(&Win32::GetCurrentProcessId)) {
                    $pid_to_kill = Win32::GetCurrentProcessId();
                }
            }

            # If we still have a fake PID, we can't use this method at all
            return if ($pid_to_kill <= 0);

            # Launch watchdog process
            my $watchdog;
            eval {
                local $SIG{'__WARN__'} = sub {
                    _diag("Watchdog warning: $_[0]");
                };
                my $sig = $^O eq 'VMS' ? 'TERM' : 'KILL';
                $watchdog = system(1, which_perl(), '-e',
                                                    "sleep($timeout);" .
                                                    "warn('# $timeout_msg\n');" .
                                                    "kill($sig, $pid_to_kill);");
            };
            if ($@@ || ($watchdog <= 0)) {
                _diag('Failed to start watchdog');
                _diag($@@) if $@@;
                undef($watchdog);
                return;
            }

            # Add END block to parent to terminate and
            #   clean up watchdog process
            eval "END { local \$! = 0; local \$? = 0;
                        wait() if kill('KILL', $watchdog); };";
            return;
        }

        # Try using fork() to generate a watchdog process
        my $watchdog;
        eval { $watchdog = fork() };
        if (defined($watchdog)) {
            if ($watchdog) {   # Parent process
                # Add END block to parent to terminate and
                #   clean up watchdog process
                eval "END { local \$! = 0; local \$? = 0;
                            wait() if kill('KILL', $watchdog); };";
                return;
            }

            ### Watchdog process code

            # Load POSIX if available
            eval { require POSIX; };

            # Execute the timeout
            sleep($timeout - 2) if ($timeout > 2);   # Workaround for perlbug #49073
            sleep(2);

            # Kill test process if still running
            if (kill(0, $pid_to_kill)) {
                _diag($timeout_msg);
                kill('KILL', $pid_to_kill);
            }

            # Don't execute END block (added at beginning of this file)
            $NO_ENDING = 1;

            # Terminate ourself (i.e., the watchdog)
            POSIX::_exit(1) if (defined(&POSIX::_exit));
            exit(1);
        }

        # fork() failed - fall through and try using a thread
    }

    # Use a watchdog thread because either 'threads' is loaded,
    #   or fork() failed
    if (eval 'require threads; 1') {
        threads->create(sub {
                # Load POSIX if available
                eval { require POSIX; };

                # Execute the timeout
                my $time_left = $timeout;
                do {
                    $time_left -= sleep($time_left);
                } while ($time_left > 0);

                # Kill the parent (and ourself)
                select(STDERR); $| = 1;
                _diag($timeout_msg);
                POSIX::_exit(1) if (defined(&POSIX::_exit));
                my $sig = $^O eq 'VMS' ? 'TERM' : 'KILL';
                kill($sig, $pid_to_kill);
            })->detach();
        return;
    }

    # If everything above fails, then just use an alarm timeout
    if (eval { alarm($timeout); 1; }) {
        # Load POSIX if available
        eval { require POSIX; };

        # Alarm handler will do the actual 'killing'
        $SIG{'ALRM'} = sub {
            select(STDERR); $| = 1;
            _diag($timeout_msg);
            POSIX::_exit(1) if (defined(&POSIX::_exit));
            my $sig = $^O eq 'VMS' ? 'TERM' : 'KILL';
            kill($sig, $pid_to_kill);
        };
    }
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d102 1
a102 1
    $out = $out . " # TODO $TODO" if $TODO;
d156 1
a156 1
                    $y = $y . sprintf "\\x{%x}", $c;
d158 1
a158 1
                    $y = $y . $backslash_escape{$c};
d161 2
a162 11
                    if ($z =~ /[[:^print:]]/) {

                        # Use octal for characters traditionally expressed as
                        # such: the low controls
                        if ($c <= 037) {
                            $z = sprintf "\\%03o", $c;
                        } else {
                            $z = sprintf "\\x{%x}", $c;
                        }
                    }
                    $y = $y . $z;
d186 2
a187 2
	unshift(@@mess, "#      got "._qq($got)."\n",
		       "# expected "._qq($expected)."\n");
d205 1
a205 1
        unshift(@@mess, "# it should not be "._qq($got)."\n",
d232 2
a233 2
        unshift(@@mess, "#      got "._qq($got)."\n",
                       "# expected $type "._qq($expected)."\n");
d269 2
a270 2
	unshift@@mess, "#      got "._qq($got)."\n",
		      "# expected "._qq($expected)." (within "._qq($range).")\n";
d408 1
d419 1
a419 1
       $runperl = $runperl . ' ' . $_;
a420 1
    return $runperl;
d434 8
a441 1
	$runperl = $runperl . ' "-I../lib"'; # doublequotes because of VMS
d447 1
a447 1
	$runperl = _quote_args($runperl, $args{switches});
d459 1
a459 1
                $runperl = $runperl . qq ( -e "$prog" );
d462 1
a462 1
                $runperl = $runperl . qq ( -e '$prog' );
d466 1
a466 1
	$runperl = $runperl . qq( "$args{progfile}");
d484 13
d503 1
a503 1
	$runperl = _quote_args($runperl, $args{args});
d505 2
a506 1
    $runperl = $runperl . ' 2>&1' if $args{stderr};
d540 1
a540 1
	local $ENV{'DCL$PATH'} = $1 if $is_vms && exists($ENV{'DCL$PATH'}) && ($ENV{'DCL$PATH'} =~ /(.*)/s);
d546 1
a546 1
	$ENV{PATH} = $ENV{PATH} . "$sep/bin" if $is_cygwin;  # Must have /bin under Cygwin
d601 1
a601 1
	    $Perl = $Perl . $exe;
d633 1
a633 1
	    $try = $try . $letters[$temp % 26];
d640 1
a640 1
	    $tmpfiles{$try} = 1;
d662 1
a662 8
    # Given the choice of the mis-parsable {}
    # (we want an anon hash, but a borked lexer might think that it's a block)
    # or relying on taking a reference to a lexical
    # (\ might be mis-parsed, and the reference counting on the pad may go
    #  awry)
    # it feels like the least-worse thing is to assume that auto-vivification
    # works. At least, this is only going to be a run-time failure, so won't
    # affect tests using this file but not this function.
d684 1
a684 1
    $results  =~ s/\n+$//;
d711 1
a711 1
        $name = $name . '...' if length $first_line > length $name;
a724 5

    # _fresh_perl() is going to clip the trailing newlines off the result.
    # This will make it so the test author doesn't have to know that.
    $expected =~ s/\n+$//;

d741 3
a743 1
		sub { @@_ ? $_[0] =~ $expected : $expected },
d844 3
a846 2
                my $cmd = _create_runperl( prog =>  "sleep($timeout);" .
                                                    "warn qq/# $timeout_msg" . '\n/;' .
a847 1
                $watchdog = system(1, $cmd);
d911 1
a911 1
                    $time_left = $time_left - sleep($time_left);
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d2 1
a2 3
# t/test.pl - most of Test::More functionality without the fuss, plus
# has mappings native_to_latin1 and latin1_to_native so that fewer tests
# on non ASCII-ish platforms need to be skipped
a24 4
# This defines ASCII/UTF-8 vs EBCDIC/UTF-EBCDIC
$::IS_ASCII  = ord 'A' ==  65;
$::IS_EBCDIC = ord 'A' == 193;

a26 1
$Tests_Are_Passing = 1;
a54 11

# Set the plan at the end.  See Test::More::done_testing.
sub done_testing {
    my $n = $test - 1;
    $n = shift if @@_;

    _print "1..$n\n";
    $planned = $n;
}


d67 2
d71 2
a72 1
    my @@mess = _comment(@@_);
a75 2
# Use this instead of "print STDERR" when outputting failure diagnostic
# messages
a79 15
# Use this instead of "print" when outputting informational messages
sub note {
    return unless @@_;
    _print( _comment(@@_) );
}

sub is_miniperl {
    return !defined &DynaLoader::boot_DynaLoader;
}

sub _comment {
    return map { /^#/ ? "$_\n" : "# $_\n" }
           map { split /\n/ } @@_;
}

a88 67
sub skip_all_if_miniperl {
    skip_all(@@_) if is_miniperl();
}

sub skip_all_without_dynamic_extension {
    my $extension = shift;
    skip_all("no dynamic loading on miniperl, no $extension") if is_miniperl();
    unless (eval {require Config; 1}) {
	warn "test.pl had problems loading Config: $@@";
	return;
    }
    $extension =~ s!::!/!g;
    return if ($Config::Config{extensions} =~ /\b$extension\b/);
    skip_all("$extension was not built");
}

sub skip_all_without_perlio {
    skip_all('no PerlIO') unless PerlIO::Layer->find('perlio');
}

sub skip_all_without_config {
    unless (eval {require Config; 1}) {
	warn "test.pl had problems loading Config: $@@";
	return;
    }
    foreach (@@_) {
	next if $Config::Config{$_};
	my $key = $_; # Need to copy, before trying to modify.
	$key =~ s/^use//;
	$key =~ s/^d_//;
	skip_all("no $key");
    }
}

sub find_git_or_skip {
    my ($found_dir, $reason);
    if (-d '.git') {
	$found_dir = 1;
    } elsif (-l 'MANIFEST' && -l 'AUTHORS') {
	my $where = readlink 'MANIFEST';
	die "Can't readling MANIFEST: $!" unless defined $where;
	die "Confusing symlink target for MANIFEST, '$where'"
	    unless $where =~ s!/MANIFEST\z!!;
	if (-d "$where/.git") {
	    # Looks like we are in a symlink tree
	    chdir $where or die "Can't chdir '$where': $!";
	    note("Found source tree at $where");
	    $found_dir = 1;
	}
    }
    if ($found_dir) {
	my $version_string = `git --version`;
	if (defined $version_string
	      && $version_string =~ /\Agit version (\d+\.\d+\.\d+)(.*)/) {
	    return if eval "v$1 ge v1.5.0";
	    # If you have earlier than 1.5.0 and it works, change this test
	    $reason = "in git checkout, but git version '$1$2' too old";
	} else {
	    $reason = "in git checkout, but cannot run git";
	}
    } else {
	$reason = 'not being run from a git checkout';
    }
    skip_all($reason) if $_[0] && $_[0] eq 'all';
    skip($reason, @@_);
}

d102 1
a102 6
    if ($TODO) {
	$out = $out . " # TODO $TODO";
    } else {
	$Tests_Are_Passing = 0 unless $pass;
    }

d105 2
a106 9
    if ($pass) {
	note @@mess; # Ensure that the message is properly escaped.
    }
    else {
	my $msg = "# Failed test $test - ";
	$msg.= "$name " if $name;
	$msg .= "$where\n";
	_diag $msg;
	_diag @@mess;
d108 3
d232 1
a232 1
        # that stringify to the same thing but are actually numerically
d236 2
a237 2
        # This will also show numbers for some unneeded cases, but will
        # definitely be helpful for things such as == and <= that fail
d290 1
a290 1
    my ($flip, undef, $expected, $name, @@mess) = @@_;
d292 2
a293 2
    $pass = $_[1] =~ /$expected/ if !$flip;
    $pass = $_[1] !~ /$expected/ if $flip;
d295 1
a295 1
	unshift(@@mess, "#      got '$_[1]'\n",
a334 4
sub skip_if_miniperl {
    skip(@@_) if is_miniperl();
}

a386 1
# We only provide a subset of the Test::More functionality.
d389 1
a389 4
    if ($require =~ tr/[A-Za-z0-9:.]//c) {
	fail("Invalid character in \"$require\", passed to require_ok");
    } else {
	eval <<REQUIRE_OK;
d392 1
a392 2
	is($@@, '', _where(), "require $require");
    }
d397 1
a397 4
    if ($use =~ tr/[A-Za-z0-9:.]//c) {
	fail("Invalid character in \"$use\", passed to use");
    } else {
	eval <<USE_OK;
d400 1
a400 2
	is($@@, '', _where(), "use $use");
    }
a406 1
#   non_portable => Don't warn if a one liner contains quotes
a459 3
	    if ($prog =~ tr/'"// && !$args{non_portable}) {
		warn "quotes in prog >>$prog<< are not portable";
	    }
d470 1
a470 1
	# You probably didn't want to be sucking in from the upstream stdin
d518 1
a518 1
	if (! eval {require Config; 1}) {
d534 2
a535 6
	if ($is_cygwin) {   # Must have /bin under Cygwin
	    if (length $ENV{PATH}) {
		$ENV{PATH} = $ENV{PATH} . $sep;
	    }
	    $ENV{PATH} = $ENV{PATH} . '/bin';
	}
d547 1
a547 2
# Nice alias
*run_perl = *run_perl = \&runperl; # shut up "used only once" warning
d560 1
a560 1
	return $Perl if $is_vms;
d563 1
a563 1
	if (! eval {require Config; 1}) {
d577 1
a577 1
	    if (! eval {require File::Spec; 1}) {
a600 1
    my $count = 0;
d603 1
a603 5
	if( -f $file ){
	    _print_stderr "# Couldn't unlink '$file': $!\n";
	}else{
	    ++$count;
	}
a604 1
    $count;
d639 8
d648 1
a648 1
    my($prog, $action, $expect, $runperl_args, $name) = @@_;
d664 1
a664 1
    if( $is_vms ) {
d687 1
a687 1
    if ($is_vms) {
d695 8
d709 1
a709 19
    # Historically this was implemented using a closure, but then that means
    # that the tests for closures avoid using this code. Given that there
    # are exactly two callers, doing exactly two things, the simpler approach
    # feels like a better trade off.
    my $pass;
    if ($action eq 'eq') {
	$pass = is($results, $expect, $name);
    } elsif ($action eq '=~') {
	$pass = like($results, $expect, $name);
    } else {
	die "_fresh_perl can't process action '$action'";
    }
	
    unless ($pass) {
        _diag "# PROG: \n$prog\n";
        _diag "# STATUS: $status\n";
    }

    return $pass;
d726 3
a728 1
    _fresh_perl($prog, 'eq', $expected, $runperl_args, $name);
d740 3
a742 212
    _fresh_perl($prog, '=~', $expected, $runperl_args, $name);
}

# Many tests use the same format in __DATA__ or external files to specify a
# sequence of (fresh) tests to run, extra files they may temporarily need, and
# what the expected output is. So have excatly one copy of the code to run that
#
# Each program is source code to run followed by an "EXPECT" line, followed
# by the expected output.
#
# The code to run may contain (note the '# ' on each):
#   # TODO reason for todo
#   # SKIP reason for skip
#   # SKIP ?code to test if this should be skipped
#   # NAME name of the test (as with ok($ok, $name))
#
# The expected output may contain:
#   OPTION list of options
#   OPTIONS list of options
#   PREFIX
#     indicates that the supplied output is only a prefix to the
#     expected output
#
# The possible options for OPTION may be:
#   regex - the expected output is a regular expression
#   random - all lines match but in any order
#   fatal - the code will fail fatally (croak, die)
#
# If the actual output contains a line "SKIPPED" the test will be
# skipped.
#
# If the global variable $FATAL is true then OPTION fatal is the
# default.

sub run_multiple_progs {
    my $up = shift;
    my @@prgs;
    if ($up) {
	# The tests in lib run in a temporary subdirectory of t, and always
	# pass in a list of "programs" to run
	@@prgs = @@_;
    } else {
	# The tests below t run in t and pass in a file handle.
	my $fh = shift;
	local $/;
	@@prgs = split "\n########\n", <$fh>;
    }

    my $tmpfile = tempfile();

    for (@@prgs){
	unless (/\n/) {
	    print "# From $_\n";
	    next;
	}
	my $switch = "";
	my @@temps ;
	my @@temp_path;
	if (s/^(\s*-\w+)//) {
	    $switch = $1;
	}
	my ($prog, $expected) = split(/\nEXPECT(?:\n|$)/, $_, 2);

	my %reason;
	foreach my $what (qw(skip todo)) {
	    $prog =~ s/^#\s*\U$what\E\s*(.*)\n//m and $reason{$what} = $1;
	    # If the SKIP reason starts ? then it's taken as a code snippet to
	    # evaluate. This provides the flexibility to have conditional SKIPs
	    if ($reason{$what} && $reason{$what} =~ s/^\?//) {
		my $temp = eval $reason{$what};
		if ($@@) {
		    die "# In \U$what\E code reason:\n# $reason{$what}\n$@@";
		}
		$reason{$what} = $temp;
	    }
	}
	my $name = '';
	if ($prog =~ s/^#\s*NAME\s+(.+)\n//m) {
	    $name = $1;
	}

	if ($prog =~ /--FILE--/) {
	    my @@files = split(/\n--FILE--\s*([^\s\n]*)\s*\n/, $prog) ;
	    shift @@files ;
	    die "Internal error: test $_ didn't split into pairs, got " .
		scalar(@@files) . "[" . join("%%%%", @@files) ."]\n"
		    if @@files % 2;
	    while (@@files > 2) {
		my $filename = shift @@files;
		my $code = shift @@files;
		push @@temps, $filename;
		if ($filename =~ m#(.*)/# && $filename !~ m#^\.\./#) {
		    require File::Path;
		    File::Path::mkpath($1);
		    push(@@temp_path, $1);
		}
		open my $fh, '>', $filename or die "Cannot open $filename: $!\n";
		print $fh $code;
		close $fh or die "Cannot close $filename: $!\n";
	    }
	    shift @@files;
	    $prog = shift @@files;
	}

	open my $fh, '>', $tmpfile or die "Cannot open >$tmpfile: $!";
	print $fh q{
        BEGIN {
            open STDERR, '>&', STDOUT
              or die "Can't dup STDOUT->STDERR: $!;";
        }
	};
	print $fh "\n#line 1\n";  # So the line numbers don't get messed up.
	print $fh $prog,"\n";
	close $fh or die "Cannot close $tmpfile: $!";
	my $results = runperl( stderr => 1, progfile => $tmpfile, $up
			       ? (switches => ["-I$up/lib", $switch], nolib => 1)
			       : (switches => [$switch])
			        );
	my $status = $?;
	$results =~ s/\n+$//;
	# allow expected output to be written as if $prog is on STDIN
	$results =~ s/$::tempfile_regexp/-/g;
	if ($^O eq 'VMS') {
	    # some tests will trigger VMS messages that won't be expected
	    $results =~ s/\n?%[A-Z]+-[SIWEF]-[A-Z]+,.*//;

	    # pipes double these sometimes
	    $results =~ s/\n\n/\n/g;
	}
	# bison says 'parse error' instead of 'syntax error',
	# various yaccs may or may not capitalize 'syntax'.
	$results =~ s/^(syntax|parse) error/syntax error/mig;
	# allow all tests to run when there are leaks
	$results =~ s/Scalars leaked: \d+\n//g;

	$expected =~ s/\n+$//;
	my $prefix = ($results =~ s#^PREFIX(\n|$)##) ;
	# any special options? (OPTIONS foo bar zap)
	my $option_regex = 0;
	my $option_random = 0;
	my $fatal = $FATAL;
	if ($expected =~ s/^OPTIONS? (.+)\n//) {
	    foreach my $option (split(' ', $1)) {
		if ($option eq 'regex') { # allow regular expressions
		    $option_regex = 1;
		}
		elsif ($option eq 'random') { # all lines match, but in any order
		    $option_random = 1;
		}
		elsif ($option eq 'fatal') { # perl should fail
		    $fatal = 1;
		}
		else {
		    die "$0: Unknown OPTION '$option'\n";
		}
	    }
	}
	die "$0: can't have OPTION regex and random\n"
	    if $option_regex + $option_random > 1;
	my $ok = 0;
	if ($results =~ s/^SKIPPED\n//) {
	    print "$results\n" ;
	    $ok = 1;
	}
	else {
	    if ($option_random) {
	        my @@got = sort split "\n", $results;
	        my @@expected = sort split "\n", $expected;

	        $ok = "@@got" eq "@@expected";
	    }
	    elsif ($option_regex) {
	        $ok = $results =~ /^$expected/;
	    }
	    elsif ($prefix) {
	        $ok = $results =~ /^\Q$expected/;
	    }
	    else {
	        $ok = $results eq $expected;
	    }

	    if ($ok && $fatal && !($status >> 8)) {
		$ok = 0;
	    }
	}

	local $::TODO = $reason{todo};

	unless ($ok) {
	    my $err_line = "PROG: $switch\n$prog\n" .
			   "EXPECTED:\n$expected\n";
	    $err_line   .= "EXIT STATUS: != 0\n" if $fatal;
	    $err_line   .= "GOT:\n$results\n";
	    $err_line   .= "EXIT STATUS: " . ($status >> 8) . "\n" if $fatal;
	    if ($::TODO) {
		$err_line =~ s/^/# /mg;
		print $err_line;  # Harness can't filter it out from STDERR.
	    }
	    else {
		print STDERR $err_line;
	    }
	}

	ok($ok, $name);

	foreach (@@temps) {
	    unlink $_ if $_;
	}
	foreach (@@temp_path) {
	    File::Path::rmtree $_ if -d $_;
	}
    }
a766 27

# Call $class->new( @@$args ); and run the result through object_ok.
# See Test::More::new_ok
sub new_ok {
    my($class, $args, $obj_name) = @@_;
    $args ||= [];
    $object_name = "The object" unless defined $obj_name;

    local $Level = $Level + 1;

    my $obj;
    my $ok = eval { $obj = $class->new(@@$args); 1 };
    my $error = $@@;

    if($ok) {
        object_ok($obj, $class, $object_name);
    }
    else {
        ok( 0, "new() died" );
        diag("Error was:  $@@");
    }

    return $obj;

}


d776 3
a779 2
        my $whatami = ref $object ? 'object' : 'class';

d783 2
a784 6
        my $error = $@@;  # in case something else blows away $@@

        if( $error ) {
            if( $error =~ /^Can't call method "isa" on unblessed reference/ ) {
                # It's an unblessed reference
                $obj_name = 'The reference' unless defined $obj_name;
d789 1
a789 7
            }
            elsif( $error =~ /Can't call method "isa" without a package/ ) {
                # It's something that can't even be a class
                $obj_name = 'The thing' unless defined $obj_name;
                $diag = "$obj_name isn't a class or reference";
            }
            else {
a798 1
            $obj_name = "The $whatami" unless defined $obj_name;
a806 99

sub class_ok {
    my($class, $isa, $class_name) = @@_;

    # Written so as to count as one test
    local $Level = $Level + 1;
    if( ref $class ) {
        ok( 0, "$class is a refrence, not a class name" );
    }
    else {
        isa_ok($class, $isa, $class_name);
    }
}


sub object_ok {
    my($obj, $isa, $obj_name) = @@_;

    local $Level = $Level + 1;
    if( !ref $obj ) {
        ok( 0, "$obj is not a reference" );
    }
    else {
        isa_ok($obj, $isa, $obj_name);
    }
}


# Purposefully avoiding a closure.
sub __capture {
    push @@::__capture, join "", @@_;
}
    
sub capture_warnings {
    my $code = shift;

    local @@::__capture;
    local $SIG {__WARN__} = \&__capture;
    &$code;
    return @@::__capture;
}

# This will generate a variable number of tests.
# Use done_testing() instead of a fixed plan.
sub warnings_like {
    my ($code, $expect, $name) = @@_;
    local $Level = $Level + 1;

    my @@w = capture_warnings($code);

    cmp_ok(scalar @@w, '==', scalar @@$expect, $name);
    foreach my $e (@@$expect) {
	if (ref $e) {
	    like(shift @@w, $e, $name);
	} else {
	    is(shift @@w, $e, $name);
	}
    }
    if (@@w) {
	diag("Saw these additional warnings:");
	diag($_) foreach @@w;
    }
}

sub _fail_excess_warnings {
    my($expect, $got, $name) = @@_;
    local $Level = $Level + 1;
    # This will fail, and produce diagnostics
    is($expect, scalar @@$got, $name);
    diag("Saw these warnings:");
    diag($_) foreach @@$got;
}

sub warning_is {
    my ($code, $expect, $name) = @@_;
    die sprintf "Expect must be a string or undef, not a %s reference", ref $expect
	if ref $expect;
    local $Level = $Level + 1;
    my @@w = capture_warnings($code);
    if (@@w > 1) {
	_fail_excess_warnings(0 + defined $expect, \@@w, $name);
    } else {
	is($w[0], $expect, $name);
    }
}

sub warning_like {
    my ($code, $expect, $name) = @@_;
    die sprintf "Expect must be a regexp object"
	unless ref $expect eq 'Regexp';
    local $Level = $Level + 1;
    my @@w = capture_warnings($code);
    if (@@w > 1) {
	_fail_excess_warnings(0 + defined $expect, \@@w, $name);
    } else {
	like($w[0], $expect, $name);
    }
}

d810 1
a810 1
sub watchdog ($;$)
a812 1
    my $method  = shift || "";
a814 3
    # Valgrind slows perl way down so give it more time before dying.
    $timeout *= 10 if $ENV{PERL_VALGRIND};

a816 7
    if ($method eq "alarm") {
        goto WATCHDOG_VIA_ALARM;
    }

    # shut up use only once warning
    my $threads_on = $threads::threads && $threads::threads;

d819 1
a819 1
    if (!$threads_on || $method eq "process") {
d823 1
a823 1
        if ($is_mswin || $is_vms) {
d825 1
a825 1
            if ($is_mswin) {
d841 1
a841 1
                my $sig = $is_vms ? 'TERM' : 'KILL';
a885 5
		if ($is_cygwin) {
		    # sometimes the above isn't enough on cygwin
		    sleep 1; # wait a little, it might have worked after all
		    system("/bin/kill -f $pid_to_kill");
		}
d901 2
a902 2
    if (eval {require threads; 1}) {
        'threads'->create(sub {
d916 1
a916 1
                my $sig = $is_vms ? 'TERM' : 'KILL';
a922 1
WATCHDOG_VIA_ALARM:
d932 1
a932 1
            my $sig = $is_vms ? 'TERM' : 'KILL';
a935 141
}

my $cp_0037 =   # EBCDIC code page 0037
    '\x00\x01\x02\x03\x37\x2D\x2E\x2F\x16\x05\x25\x0B\x0C\x0D\x0E\x0F' .
    '\x10\x11\x12\x13\x3C\x3D\x32\x26\x18\x19\x3F\x27\x1C\x1D\x1E\x1F' .
    '\x40\x5A\x7F\x7B\x5B\x6C\x50\x7D\x4D\x5D\x5C\x4E\x6B\x60\x4B\x61' .
    '\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\x7A\x5E\x4C\x7E\x6E\x6F' .
    '\x7C\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xD1\xD2\xD3\xD4\xD5\xD6' .
    '\xD7\xD8\xD9\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xBA\xE0\xBB\xB0\x6D' .
    '\x79\x81\x82\x83\x84\x85\x86\x87\x88\x89\x91\x92\x93\x94\x95\x96' .
    '\x97\x98\x99\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xC0\x4F\xD0\xA1\x07' .
    '\x20\x21\x22\x23\x24\x15\x06\x17\x28\x29\x2A\x2B\x2C\x09\x0A\x1B' .
    '\x30\x31\x1A\x33\x34\x35\x36\x08\x38\x39\x3A\x3B\x04\x14\x3E\xFF' .
    '\x41\xAA\x4A\xB1\x9F\xB2\x6A\xB5\xBD\xB4\x9A\x8A\x5F\xCA\xAF\xBC' .
    '\x90\x8F\xEA\xFA\xBE\xA0\xB6\xB3\x9D\xDA\x9B\x8B\xB7\xB8\xB9\xAB' .
    '\x64\x65\x62\x66\x63\x67\x9E\x68\x74\x71\x72\x73\x78\x75\x76\x77' .
    '\xAC\x69\xED\xEE\xEB\xEF\xEC\xBF\x80\xFD\xFE\xFB\xFC\xAD\xAE\x59' .
    '\x44\x45\x42\x46\x43\x47\x9C\x48\x54\x51\x52\x53\x58\x55\x56\x57' .
    '\x8C\x49\xCD\xCE\xCB\xCF\xCC\xE1\x70\xDD\xDE\xDB\xDC\x8D\x8E\xDF';

my $cp_1047 =   # EBCDIC code page 1047
    '\x00\x01\x02\x03\x37\x2D\x2E\x2F\x16\x05\x15\x0B\x0C\x0D\x0E\x0F' .
    '\x10\x11\x12\x13\x3C\x3D\x32\x26\x18\x19\x3F\x27\x1C\x1D\x1E\x1F' .
    '\x40\x5A\x7F\x7B\x5B\x6C\x50\x7D\x4D\x5D\x5C\x4E\x6B\x60\x4B\x61' .
    '\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\x7A\x5E\x4C\x7E\x6E\x6F' .
    '\x7C\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xD1\xD2\xD3\xD4\xD5\xD6' .
    '\xD7\xD8\xD9\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xAD\xE0\xBD\x5F\x6D' .
    '\x79\x81\x82\x83\x84\x85\x86\x87\x88\x89\x91\x92\x93\x94\x95\x96' .
    '\x97\x98\x99\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xC0\x4F\xD0\xA1\x07' .
    '\x20\x21\x22\x23\x24\x25\x06\x17\x28\x29\x2A\x2B\x2C\x09\x0A\x1B' .
    '\x30\x31\x1A\x33\x34\x35\x36\x08\x38\x39\x3A\x3B\x04\x14\x3E\xFF' .
    '\x41\xAA\x4A\xB1\x9F\xB2\x6A\xB5\xBB\xB4\x9A\x8A\xB0\xCA\xAF\xBC' .
    '\x90\x8F\xEA\xFA\xBE\xA0\xB6\xB3\x9D\xDA\x9B\x8B\xB7\xB8\xB9\xAB' .
    '\x64\x65\x62\x66\x63\x67\x9E\x68\x74\x71\x72\x73\x78\x75\x76\x77' .
    '\xAC\x69\xED\xEE\xEB\xEF\xEC\xBF\x80\xFD\xFE\xFB\xFC\xBA\xAE\x59' .
    '\x44\x45\x42\x46\x43\x47\x9C\x48\x54\x51\x52\x53\x58\x55\x56\x57' .
    '\x8C\x49\xCD\xCE\xCB\xCF\xCC\xE1\x70\xDD\xDE\xDB\xDC\x8D\x8E\xDF';

my $cp_bc = # EBCDIC code page POSiX-BC
    '\x00\x01\x02\x03\x37\x2D\x2E\x2F\x16\x05\x15\x0B\x0C\x0D\x0E\x0F' .
    '\x10\x11\x12\x13\x3C\x3D\x32\x26\x18\x19\x3F\x27\x1C\x1D\x1E\x1F' .
    '\x40\x5A\x7F\x7B\x5B\x6C\x50\x7D\x4D\x5D\x5C\x4E\x6B\x60\x4B\x61' .
    '\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\x7A\x5E\x4C\x7E\x6E\x6F' .
    '\x7C\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xD1\xD2\xD3\xD4\xD5\xD6' .
    '\xD7\xD8\xD9\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xBB\xBC\xBD\x6A\x6D' .
    '\x4A\x81\x82\x83\x84\x85\x86\x87\x88\x89\x91\x92\x93\x94\x95\x96' .
    '\x97\x98\x99\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xFB\x4F\xFD\xFF\x07' .
    '\x20\x21\x22\x23\x24\x25\x06\x17\x28\x29\x2A\x2B\x2C\x09\x0A\x1B' .
    '\x30\x31\x1A\x33\x34\x35\x36\x08\x38\x39\x3A\x3B\x04\x14\x3E\x5F' .
    '\x41\xAA\xB0\xB1\x9F\xB2\xD0\xB5\x79\xB4\x9A\x8A\xBA\xCA\xAF\xA1' .
    '\x90\x8F\xEA\xFA\xBE\xA0\xB6\xB3\x9D\xDA\x9B\x8B\xB7\xB8\xB9\xAB' .
    '\x64\x65\x62\x66\x63\x67\x9E\x68\x74\x71\x72\x73\x78\x75\x76\x77' .
    '\xAC\x69\xED\xEE\xEB\xEF\xEC\xBF\x80\xE0\xFE\xDD\xFC\xAD\xAE\x59' .
    '\x44\x45\x42\x46\x43\x47\x9C\x48\x54\x51\x52\x53\x58\x55\x56\x57' .
    '\x8C\x49\xCD\xCE\xCB\xCF\xCC\xE1\x70\xC0\xDE\xDB\xDC\x8D\x8E\xDF';

my $straight =  # Avoid ranges
    '\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F' .
    '\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F' .
    '\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F' .
    '\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F' .
    '\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F' .
    '\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F' .
    '\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6A\x6B\x6C\x6D\x6E\x6F' .
    '\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7A\x7B\x7C\x7D\x7E\x7F' .
    '\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F' .
    '\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F' .
    '\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF' .
    '\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF' .
    '\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF' .
    '\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF' .
    '\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF' .
    '\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF';

# The following 2 functions allow tests to work on both EBCDIC and
# ASCII-ish platforms.  They convert string scalars between the native
# character set and the set of 256 characters which is usually called
# Latin1.
#
# These routines don't work on UTF-EBCDIC and UTF-8.

sub native_to_latin1($) {
    my $string = shift;

    return $string if ord('^') == 94;   # ASCII, Latin1
    my $cp;
    if (ord('^') == 95) {    # EBCDIC 1047
        $cp = \$cp_1047;
    }
    elsif (ord('^') == 106) {   # EBCDIC POSIX-BC
        $cp = \$cp_bc;
    }
    elsif (ord('^') == 176)  {   # EBCDIC 037 */
        $cp = \$cp_0037;
    }
    else {
        die "Unknown native character set";
    }

    eval '$string =~ tr/' . $$cp . '/' . $straight . '/';
    return $string;
}

sub latin1_to_native($) {
    my $string = shift;

    return $string if ord('^') == 94;   # ASCII, Latin1
    my $cp;
    if (ord('^') == 95) {    # EBCDIC 1047
        $cp = \$cp_1047;
    }
    elsif (ord('^') == 106) {   # EBCDIC POSIX-BC
        $cp = \$cp_bc;
    }
    elsif (ord('^') == 176)  {   # EBCDIC 037 */
        $cp = \$cp_0037;
    }
    else {
        die "Unknown native character set";
    }

    eval '$string =~ tr/' . $straight . '/' . $$cp . '/';
    return $string;
}

sub ord_latin1_to_native {
    # given an input code point, return the platform's native
    # equivalent value.  Anything above latin1 is itself.

    my $ord = shift;
    return $ord if $ord > 255;
    return ord latin1_to_native(chr $ord);
}

sub ord_native_to_latin1 {
    # given an input platform code point, return the latin1 equivalent value.
    # Anything above latin1 is itself.

    my $ord = shift;
    return $ord if $ord > 255;
    return ord native_to_latin1(chr $ord);
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a111 10
sub _have_dynamic_extension {
    my $extension = shift;
    unless (eval {require Config; 1}) {
	warn "test.pl had problems loading Config: $@@";
	return 1;
    }
    $extension =~ s!::!/!g;
    return 1 if ($Config::Config{extensions} =~ /\b$extension\b/);
}

d126 1
a126 1
    my ($extension) = @@_;
d128 6
a133 1
    return if &_have_dynamic_extension;
d156 1
a156 1
    my ($source_dir, $reason);
d158 1
a158 1
	$source_dir = '.';
d166 3
a168 7
	    if (exists $ENV{GIT_DIR}) {
		diag("Found source tree at $where, but \$ENV{GIT_DIR} is $ENV{GIT_DIR}. Not changing it");
	    } else {
		note("Found source tree at $where, setting \$ENV{GIT_DIR}");
		$ENV{GIT_DIR} = "$where/.git";
	    }
	    $source_dir = $where;
d171 1
a171 1
    if ($source_dir) {
d175 1
a175 1
	    return $source_dir if eval "v$1 ge v1.5.0";
a187 6
sub BAIL_OUT {
    my ($reason) = @@_;
    _print("Bail out!  $reason\n");
    exit 255;
}

a446 7
sub skip_without_dynamic_extension {
    my ($extension) = @@_;
    skip("no dynamic loading on miniperl, no $extension") if is_miniperl();
    return if &_have_dynamic_extension;
    skip("$extension was not built");
}

d478 1
a478 4
      if (
        defined $orig->{$key} != defined $value
        || (defined $value && $orig->{$key} ne $value)
      ) {
a742 38
# _num_to_alpha - Returns a string of letters representing a positive integer.
# Arguments :
#   number to convert
#   maximum number of letters

# returns undef if the number is negative
# returns undef if the number of letters is greater than the maximum wanted

# _num_to_alpha( 0) eq 'A';
# _num_to_alpha( 1) eq 'B';
# _num_to_alpha(25) eq 'Z';
# _num_to_alpha(26) eq 'AA';
# _num_to_alpha(27) eq 'AB';

my @@letters = qw(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z);

# Avoid ++ -- ranges split negative numbers
sub _num_to_alpha{
    my($num,$max_char) = @@_;
    return unless $num >= 0;
    my $alpha = '';
    my $char_count = 0;
    $max_char = 0 if $max_char < 0;

    while( 1 ){
        $alpha = $letters[ $num % 26 ] . $alpha;
        $num = int( $num / 26 );
        last if $num == 0;
        $num = $num - 1;

        # char limit
        next unless $max_char;
        $char_count = $char_count + 1;
        return if $char_count == $max_char;
    }
    return $alpha;
}

d750 1
a750 1
my $tempfile_count = 0;
d752 3
a754 1
    while(1){
d756 4
a759 5
        my $alpha = _num_to_alpha($tempfile_count,2);
        last unless defined $alpha;
        $try = $try . $alpha;
        $tempfile_count = $tempfile_count + 1;

d762 1
a762 1
	if (!$tmpfiles{$try} && !-e $try) {
d767 2
a768 1
    }
d786 2
a787 2
    $runperl_args->{progfile} ||= $tmpfile;
    $runperl_args->{stderr}     = 1 unless exists $runperl_args->{stderr};
d886 1
a886 2
# The code to run may begin with a command line switch such as -w or -0777
# (alphanumerics only), and may contain (note the '# ' on each):
d895 3
a906 3
# If the actual output contains a line "PREFIX", any output starting with that
# line will be ignored when comparing with the expected output
#
a925 1
  PROGRAM:
a951 1

a956 8
	if ($reason{skip}) {
	SKIP:
	  {
	    skip($name ? "$name - $reason{skip}" : $reason{skip}, 1);
	  }
	  next PROGRAM;
	}

d958 1
a958 1
	    my @@files = split(/\n?--FILE--\s*([^\s\n]*)\s*\n/, $prog) ;
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@a178 7
    } elsif (exists $ENV{GIT_DIR}) {
	my $commit = '8d063cd8450e59ea1c611a2f4f5a21059a2804f1';
	my $out = `git rev-parse --verify --quiet '$commit^{commit}'`;
	chomp $out;
	if($out eq $commit) {
	    $source_dir = '.'
	}
d287 1
a287 3
                        # such: the low controls, which on EBCDIC aren't
                        # necessarily the same ones as on ASCII platforms, but
                        # are small ordinals, nonetheless
d549 1
a549 1
# runperl - Runs a separate perl interpreter and returns its output.
d557 2
a558 3
#   stdin    => string to feed the stdin (or undef to redirect from /dev/null)
#   stderr   => If 'devnull' suppresses stderr, if other TRUE value redirect
#               stderr to stdout
d607 2
a608 10
	    if (!$args{non_portable}) {
		if ($prog =~ tr/'"//) {
		    warn "quotes in prog >>$prog<< are not portable";
		}
		if ($prog =~ /^([<>|]|2>)/) {
		    warn "Initial $1 in prog >>$prog<< is not portable";
		}
		if ($prog =~ /&\z/) {
		    warn "Trailing & in prog >>$prog<< is not portable";
		}
a639 22
    } elsif (exists $args{stdin}) {
        # Using the pipe construction above can cause fun on systems which use
        # ksh as /bin/sh, as ksh does pipes differently (with one less process)
        # With sh, for the command line 'perl -e 'print qq()' | perl -e ...'
        # the sh process forks two children, which use exec to start the two
        # perl processes. The parent shell process persists for the duration of
        # the pipeline, and the second perl process starts with no children.
        # With ksh (and zsh), the shell saves a process by forking a child for
        # just the first perl process, and execing itself to start the second.
        # This means that the second perl process starts with one child which
        # it didn't create. This causes "fun" when if the tests assume that
        # wait (or waitpid) will only return information about processes
        # started within the test.
        # They also cause fun on VMS, where the pipe implementation returns
        # the exit code of the process at the front of the pipeline, not the
        # end. This messes up any test using OPTION FATAL.
        # Hence it's useful to have a way to make STDIN be at eof without
        # needing a pipeline, so that the fork tests have a sane environment
        # without these surprises.

        # /dev/null appears to be surprisingly portable.
        $runperl = $runperl . ($is_mswin ? ' <nul' : ' </dev/null');
d644 1
a644 6
    if (exists $args{stderr} && $args{stderr} eq 'devnull') {
        $runperl = $runperl . ($is_mswin ? ' 2>nul' : ' 2>/dev/null');
    }
    elsif ($args{stderr}) {
        $runperl = $runperl . ' 2>&1';
    }
d697 1
a697 1
    $result =~ s/\n\n/\n/g if $is_vms; # XXX pipes sometimes double these
d830 1
a830 23
    die "Can't find temporary file name starting \"tmp$$\"";
}

# register_tempfile - Adds a list of files to be removed at the end of the current test file
# Arguments :
#   a list of files to be removed later

# returns a count of how many file names were actually added

# Reuses %tmpfiles so that tempfile() will also skip any files added here
# even if the file doesn't exist yet.

sub register_tempfile {
    my $count = 0;
    for( @@_ ){
	if( $tmpfiles{$_} ){
	    _print_stderr "# Temporary file '$_' already added\n";
	}else{
	    $tmpfiles{$_} = 1;
	    $count = $count + 1;
	}
    }
    return $count;
d851 10
d942 1
a942 2
# what the expected output is.  Putting it here allows common code to serve
# these multiple tests.
a971 62
sub _setup_one_file {
    my $fh = shift;
    # Store the filename as a program that started at line 0.
    # Real files count lines starting at line 1.
    my @@these = (0, shift);
    my ($lineno, $current);
    while (<$fh>) {
        if ($_ eq "########\n") {
            if (defined $current) {
                push @@these, $lineno, $current;
            }
            undef $current;
        } else {
            if (!defined $current) {
                $lineno = $.;
            }
            $current .= $_;
        }
    }
    if (defined $current) {
        push @@these, $lineno, $current;
    }
    ((scalar @@these) / 2 - 1, @@these);
}

sub setup_multiple_progs {
    my ($tests, @@prgs);
    foreach my $file (@@_) {
        next if $file =~ /(?:~|\.orig|,v)$/;
        next if $file =~ /perlio$/ && !PerlIO::Layer->find('perlio');
        next if -d $file;

        open my $fh, '<', $file or die "Cannot open $file: $!\n" ;
        my $found;
        while (<$fh>) {
            if (/^__END__/) {
                ++$found;
                last;
            }
        }
        # This is an internal error, and should never happen. All bar one of
        # the files had an __END__ marker to signal the end of their preamble,
        # although for some it wasn't technically necessary as they have no
        # tests. It might be possible to process files without an __END__ by
        # seeking back to the start and treating the whole file as tests, but
        # it's simpler and more reliable just to make the rule that all files
        # must have __END__ in. This should never fail - a file without an
        # __END__ should not have been checked in, because the regression tests
        # would not have passed.
        die "Could not find '__END__' in $file"
            unless $found;

        my ($t, @@p) = _setup_one_file($fh, $file);
        $tests += $t;
        push @@prgs, @@p;

        close $fh
            or die "Cannot close $file: $!\n";
    }
    return ($tests, @@prgs);
}

d980 4
a983 12
        # The tests below t run in t and pass in a file handle. In theory we
        # can pass (caller)[1] as the second argument to report errors with
        # the filename of our caller, as the handle is always DATA. However,
        # line numbers in DATA count from the __END__ token, so will be wrong.
        # Which is more confusing than not providing line numbers. So, for now,
        # don't provide line numbers. No obvious clean solution - one hack
        # would be to seek DATA back to the start and read to the __END__ token,
        # but that feels almost like we should just open $0 instead.

        # Not going to rely on undef in list assignment.
        my $dummy;
        ($dummy, @@prgs) = _setup_one_file(shift);
a987 1
    my ($file, $line);
d989 3
a991 7
    while (defined ($line = shift @@prgs)) {
        $_ = shift @@prgs;
        unless ($line) {
            $file = $_;
            if (defined $file) {
                print "# From $file\n";
            }
d1062 1
a1062 2
	my $results = runperl( stderr => 1, progfile => $tmpfile,
			       stdin => undef, $up
d1151 1
a1151 8
        if (defined $file) {
            _ok($ok, "at $file line $line", $name);
        } else {
            # We don't have file and line number data for the test, so report
            # errors as coming from our caller.
            local $Level = $Level + 1;
            ok($ok, $name);
        }
d1420 2
a1421 8
            # Win32 watchdog is launched by cmd.exe shell, so use process group
            # kill, otherwise the watchdog is never killed and harness waits
            # every time for the timeout, #121395
            eval( $is_mswin ?
            "END { local \$! = 0; local \$? = 0;
                        wait() if kill('-KILL', $watchdog); };"
            : "END { local \$! = 0; local \$? = 0;
                        wait() if kill('KILL', $watchdog); };");
d1508 72
d1584 2
d1591 13
a1603 7
    my $output = "";
    for my $i (0 .. length($string) - 1) {
        $output .= chr(ord_native_to_latin1(ord(substr($string, $i, 1))));
    }
    # Preserve utf8ness of input onto the output, even if it didn't need to be
    # utf8
    utf8::upgrade($output) if utf8::is_utf8($string);
d1605 2
a1606 1
    return $output;
d1613 13
a1625 7
    my $output = "";
    for my $i (0 .. length($string) - 1) {
        $output .= chr(ord_latin1_to_native(ord(substr($string, $i, 1))));
    }
    # Preserve utf8ness of input onto the output, even if it didn't need to be
    # utf8
    utf8::upgrade($output) if utf8::is_utf8($string);
d1627 2
a1628 1
    return $output;
d1636 2
a1637 2
    return $ord if ord('^') == 94;   # ASCII, Latin1
    return utf8::unicode_to_native($ord);
d1645 2
a1646 2
    return $ord if ord('^') == 94;   # ASCII, Latin1
    return utf8::native_to_unicode($ord);
@


