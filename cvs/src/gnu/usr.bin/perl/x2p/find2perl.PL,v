head	1.15;
access;
symbols
	OPENBSD_6_0:1.15.0.4
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.13.0.22
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.20
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.16
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.13.0.14
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.12
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.10
	OPENBSD_5_0:1.13.0.8
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.6
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.10.0.8
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.6
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.4
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.15
date	2016.07.25.10.53.04;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	FHUgABTHZQuYQh2B;

1.14
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches
	1.14.4.1
	1.14.6.1;
next	1.13;
commitid	QP75iYx42Uo7mMxO;

1.13
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.36.23;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.23.15;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.09.18.10.41;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.07.21.33.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.53;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.40;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.18.36.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.06.17.09.16;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.05.14.04.22.47;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.07.05;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.35;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.35;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.42.25;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.11.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.22;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.14;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.40;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.49;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.48.50;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.50.02;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.19.07;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.40;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.21;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;

1.14.4.1
date	2016.08.05.01.01.40;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.14.6.1
date	2016.08.05.01.00.56;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.15
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@#!/usr/local/bin/perl

BEGIN { pop @@INC if $INC[-1] eq '.' }
use Config;
use File::Basename qw(&basename &dirname);
use Cwd;

# List explicitly here the variables you want Configure to
# generate.  Metaconfig only looks for shell variables, so you
# have to mention them as if they were shell variables, not
# %Config entries.  Thus you write
#  $startperl
# to ensure Configure will look for $Config{startperl}.

# This forces PL files to create target in same directory as PL file.
# This is so that make depend always knows where to find PL derivatives.
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';

open OUT,">$file" or die "Can't create $file: $!";

print "Extracting $file (with variable substitutions)\n";

# In this section, perl variables will be expanded during extraction.
# You can use $Config{...} to use Configure variables.

print OUT <<"!GROK!THIS!";
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
      if \$running_under_some_shell;
(my \$perlpath = <<'/../') =~ s/\\s*\\z//;
$Config{perlpath}
/../
!GROK!THIS!

# In the following, perl variables are not expanded during extraction.

print OUT <<'!NO!SUBS!';
use strict;
use vars qw/$statdone/;
use File::Spec::Functions 'curdir';
my $startperl = "#! $perlpath -w";

sub tab ();
sub n ($$);
sub fileglob_to_re ($);
sub quote ($);

my @@roots = ();
while ($ARGV[0] =~ /^[^-!(]/) {
    push(@@roots, shift);
}
@@roots = (curdir()) unless @@roots;
for (@@roots) { $_ = quote($_) }
my $roots = join(', ', @@roots);

my $find = "find";
my $indent_depth = 1;
my $stat = 'lstat';
my $decl = '';
my $flushall = '';
my $initfile = '';
my $initnewer = '';
my $out = '';
my $declaresubs = "sub wanted;\n";
my %init = ();
my ($follow_in_effect,$Skip_And) = (0,0);
my $print_needed = 1;

while (@@ARGV) {
    $_ = shift;
    s/^-// || /^[()!]/ || die "Unrecognized switch: $_\n";
    if ($_ eq '(') {
        $out .= tab . "(\n";
        $indent_depth++;
        next;
    } elsif ($_ eq ')') {
        --$indent_depth;
        $out .= tab . ")";
    } elsif ($_ eq 'follow') {
        $follow_in_effect= 1;
        $stat = 'stat';
        $Skip_And= 1;
    } elsif ($_ eq '!') {
        $out .= tab . "!";
        next;
    } elsif (/^(i)?name$/) {
        $out .= tab . '/' . fileglob_to_re(shift) . "/s$1";
    } elsif (/^(i)?path$/) {
        $out .= tab . '$File::Find::name =~ /' . fileglob_to_re(shift) . "/s$1";
    } elsif ($_ eq 'perm') {
        my $onum = shift;
        $onum =~ /^-?[0-7]+$/
            || die "Malformed -perm argument: $onum\n";
        $out .= tab;
        if ($onum =~ s/^-//) {
            $onum = sprintf("0%o", oct($onum) & 07777);
            $out .= "((\$mode & $onum) == $onum)";
        } else {
            $onum =~ s/^0*/0/;
            $out .= "((\$mode & 0777) == $onum)";
        }
    } elsif ($_ eq 'type') {
        (my $filetest = shift) =~ tr/s/S/;
        $out .= tab . "-$filetest _";
    } elsif ($_ eq 'print') {
        $out .= tab . 'print("$name\n")';
	$print_needed = 0;
    } elsif ($_ eq 'print0') {
        $out .= tab . 'print("$name\0")';
	$print_needed = 0;
    } elsif ($_ eq 'fstype') {
        my $type = shift;
        $out .= tab;
        if ($type eq 'nfs') {
            $out .= '($dev < 0)';
        } else {
            $out .= '($dev >= 0)'; #XXX
        }
    } elsif ($_ eq 'user') {
        my $uname = shift;
        $out .= tab . "(\$uid == \$uid{'$uname'})";
        $init{user} = 1;
    } elsif ($_ eq 'group') {
        my $gname = shift;
        $out .= tab . "(\$gid == \$gid{'$gname'})";
        $init{group} = 1;
    } elsif ($_ eq 'nouser') {
        $out .= tab . '!exists $uid{$uid}';
        $init{user} = 1;
    } elsif ($_ eq 'nogroup') {
        $out .= tab . '!exists $gid{$gid}';
        $init{group} = 1;
    } elsif ($_ eq 'links') {
        $out .= tab . n('$nlink', shift);
    } elsif ($_ eq 'inum') {
        $out .= tab . n('$ino', shift);
    } elsif ($_ eq 'size') {
        $_ = shift;
        my $n = 'int(((-s _) + 511) / 512)';
        if (s/c\z//) {
            $n = 'int(-s _)';
        } elsif (s/k\z//) {
            $n = 'int(((-s _) + 1023) / 1024)';
        }
        $out .= tab . n($n, $_);
    } elsif ($_ eq 'atime') {
        $out .= tab . n('int(-A _)', shift);
    } elsif ($_ eq 'mtime') {
        $out .= tab . n('int(-M _)', shift);
    } elsif ($_ eq 'ctime') {
        $out .= tab . n('int(-C _)', shift);
    } elsif ($_ eq 'exec') {
        my @@cmd = ();
        while (@@ARGV && $ARGV[0] ne ';')
            { push(@@cmd, shift) }
        shift;
        $out .= tab;
        if ($cmd[0] =~m#^(?:(?:/usr)?/bin/)?rm$#
                && $cmd[$#cmd] eq '{}'
                && (@@cmd == 2 || (@@cmd == 3 && $cmd[1] eq '-f'))) {
            if (@@cmd == 2) {
                $out .= '(unlink($_) || warn "$name: $!\n")';
            } elsif (!@@ARGV) {
                $out .= 'unlink($_)';
            } else {
                $out .= '(unlink($_) || 1)';
            }
        } else {
            for (@@cmd)
                { s/'/\\'/g }
            { local $" = "','"; $out .= "doexec(0, '@@cmd')"; }
            $declaresubs .= "sub doexec (\$\@@);\n";
            $init{doexec} = 1;
        }
	$print_needed = 0;
    } elsif ($_ eq 'ok') {
        my @@cmd = ();
        while (@@ARGV && $ARGV[0] ne ';')
            { push(@@cmd, shift) }
        shift;
        $out .= tab;
        for (@@cmd)
            { s/'/\\'/g }
        { local $" = "','"; $out .= "doexec(1, '@@cmd')"; }
        $declaresubs .= "sub doexec (\$\@@);\n";
        $init{doexec} = 1;
	$print_needed = 0;
    } elsif ($_ eq 'prune') {
        $out .= tab . '($File::Find::prune = 1)';
    } elsif ($_ eq 'xdev') {
        $out .= tab . '!($File::Find::prune |= ($dev != $File::Find::topdev))'
;
    } elsif ($_ eq 'newer') {
        my $file = shift;
        my $newername = 'AGE_OF' . $file;
        $newername =~ s/\W/_/g;
        $newername = '$' . $newername;
        $out .= tab . "(-M _ < $newername)";
        $initnewer .= "my $newername = -M " . quote($file) . ";\n";
    } elsif ($_ eq 'eval') {
        my $prog = shift;
        $prog =~ s/'/\\'/g;
        $out .= tab . "eval {$prog}";
	$print_needed = 0;
    } elsif ($_ eq 'depth') {
        $find = 'finddepth';
        next;
    } elsif ($_ eq 'ls') {
        $out .= tab . "ls";
        $declaresubs .= "sub ls ();\n";
        $init{ls} = 1;
	$print_needed = 0;
    } elsif ($_ eq 'tar') {
        die "-tar must have a filename argument\n" unless @@ARGV;
        my $file = shift;
        my $fh = 'FH' . $file;
        $fh =~ s/\W/_/g;
        $out .= tab . "tar(*$fh, \$name)";
        $flushall .= "tflushall;\n";
        $declaresubs .= "sub tar;\nsub tflushall ();\n";
        $initfile .= "open($fh, " . quote('> ' . $file) .
                     qq{) || die "Can't open $fh: \$!\\n";\n};
        $init{tar} = 1;
    } elsif (/^(n?)cpio\z/) {
        die "-$_ must have a filename argument\n" unless @@ARGV;
        my $file = shift;
        my $fh = 'FH' . $file;
        $fh =~ s/\W/_/g;
        $out .= tab . "cpio(*$fh, \$name, '$1')";
        $find = 'finddepth';
        $flushall .= "cflushall;\n";
        $declaresubs .= "sub cpio;\nsub cflushall ();\n";
        $initfile .= "open($fh, " . quote('> ' . $file) .
                     qq{) || die "Can't open $fh: \$!\\n";\n};
        $init{cpio} = 1;
    } else {
        die "Unrecognized switch: -$_\n";
    }

    if (@@ARGV) {
        if ($ARGV[0] eq '-o') {
            { local($statdone) = 1; $out .= "\n" . tab . "||\n"; }
            $statdone = 0 if $indent_depth == 1 && exists $init{delayedstat};
            $init{saw_or} = 1;
            shift;
        } else {
            $out .= " &&" unless $Skip_And || $ARGV[0] eq ')';
            $out .= "\n";
            shift if $ARGV[0] eq '-a';
        }
    }
}

if ($print_needed) {
    my $t = tab;
    if ($t !~ /&&\s*$/) { $t .= '&& ' }
    $out .= "\n" . $t . 'print("$name\n")';
}


print <<"END";
$startperl
    eval 'exec $perlpath -S \$0 \${1+"\$@@"}'
        if 0; #\$running_under_some_shell

use strict;
use File::Find ();

# Set the variable \$File::Find::dont_use_nlink if you're using AFS,
# since AFS cheats.

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

$declaresubs

END

if (exists $init{doexec}) {
    print <<'END';
use Cwd ();
my $cwd = Cwd::cwd();

END
}  

if (exists $init{ls}) {
    print <<'END';
my @@rwx = qw(--- --x -w- -wx r-- r-x rw- rwx);
my @@moname = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);

END
}

if (exists $init{user} || exists $init{ls} || exists $init{tar}) {
    print "my (%uid, %user);\n";
    print "while (my (\$name, \$pw, \$uid) = getpwent) {\n";
    print '    $uid{$name} = $uid{$uid} = $uid;', "\n"
        if exists $init{user};
    print '    $user{$uid} = $name unless exists $user{$uid};', "\n"
        if exists $init{ls} || exists $init{tar};
    print "}\n\n";
}

if (exists $init{group} || exists $init{ls} || exists $init{tar}) {
    print "my (%gid, %group);\n";
    print "while (my (\$name, \$pw, \$gid) = getgrent) {\n";
    print '    $gid{$name} = $gid{$gid} = $gid;', "\n"
        if exists $init{group};
    print '    $group{$gid} = $name unless exists $group{$gid};', "\n"
        if exists $init{ls} || exists $init{tar};
    print "}\n\n";
}

print $initnewer, "\n" if $initnewer ne '';
print $initfile, "\n" if $initfile ne '';
$flushall .= "exit;\n";
if (exists $init{declarestat}) {
    $out = <<'END' . $out;
    my ($dev,$ino,$mode,$nlink,$uid,$gid);

END
}

if ( $follow_in_effect ) {
$out =~ s/lstat\(\$_\)/lstat(_)/;
print <<"END";
$decl
# Traverse desired filesystems
File::Find::$find( {wanted => \\&wanted, follow => 1}, $roots);
$flushall

sub wanted {
$out;
}

END
} else {
print <<"END";
$decl
# Traverse desired filesystems
File::Find::$find({wanted => \\&wanted}, $roots);
$flushall

sub wanted {
$out;
}

END
}

if (exists $init{doexec}) {
    print <<'END';

sub doexec ($@@) {
    my $ok = shift;
    my @@command = @@_; # copy so we don't try to s/// aliases to constants
    for my $word (@@command)
        { $word =~ s#{}#$name#g }
    if ($ok) {
        my $old = select(STDOUT);
        $| = 1;
        print "@@command";
        select($old);
        return 0 unless <STDIN> =~ /^y/;
    }
    chdir $cwd; #sigh
    system @@command;
    chdir $File::Find::dir;
    return !$?;
}

END
}

if (exists $init{ls}) {
    print <<'INTRO', <<"SUB", <<'END';

sub sizemm {
    my $rdev = shift;
    sprintf("%3d, %3d", ($rdev >> 8) & 0xff, $rdev & 0xff);
}

sub ls () {
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
INTRO
        \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat(_);
SUB
    my $pname = $name;

    $blocks
        or $blocks = int(($size + 1023) / 1024);

    my $perms = $rwx[$mode & 7];
    $mode >>= 3;
    $perms = $rwx[$mode & 7] . $perms;
    $mode >>= 3;
    $perms = $rwx[$mode & 7] . $perms;
    substr($perms, 2, 1) =~ tr/-x/Ss/ if -u _;
    substr($perms, 5, 1) =~ tr/-x/Ss/ if -g _;
    substr($perms, 8, 1) =~ tr/-x/Tt/ if -k _;
    if    (-f _) { $perms = '-' . $perms; }
    elsif (-d _) { $perms = 'd' . $perms; }
    elsif (-l _) { $perms = 'l' . $perms; $pname .= ' -> ' . readlink($_); }
    elsif (-c _) { $perms = 'c' . $perms; $size = sizemm($rdev); }
    elsif (-b _) { $perms = 'b' . $perms; $size = sizemm($rdev); }
    elsif (-p _) { $perms = 'p' . $perms; }
    elsif (-S _) { $perms = 's' . $perms; }
    else         { $perms = '?' . $perms; }

    my $user = $user{$uid} || $uid;
    my $group = $group{$gid} || $gid;

    my ($sec,$min,$hour,$mday,$mon,$timeyear) = localtime($mtime);
    if (-M _ > 365.25 / 2) {
        $timeyear += 1900;
    } else {
        $timeyear = sprintf("%02d:%02d", $hour, $min);
    }

    printf "%5lu %4ld %-10s %3d %-8s %-8s %8s %s %2d %5s %s\n",
            $ino,
                 $blocks,
                      $perms,
                            $nlink,
                                $user,
                                     $group,
                                          $size,
                                              $moname[$mon],
                                                 $mday,
                                                     $timeyear,
                                                         $pname;
    1;
}

END
}


if (exists $init{cpio} || exists $init{tar}) {
print <<'END';

my %blocks = ();

sub flush {
    my ($fh, $varref, $blksz) = @@_;

    while (length($$varref) >= $blksz) {
        no strict qw/refs/;
        syswrite($fh, $$varref, $blksz);
        substr($$varref, 0, $blksz) = '';
        ++$blocks{$fh};
    }
}

END
}


if (exists $init{cpio}) {
    print <<'INTRO', <<"SUB", <<'END';

my %cpout = ();
my %nc = ();

sub cpio {
    my ($fh, $fname, $nc) = @@_;
    my $text = '';
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
        $atime,$mtime,$ctime,$blksize,$blocks);
    local (*IN);

    if ( ! defined $fname ) {
        $fname = 'TRAILER!!!';
        ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
          $atime,$mtime,$ctime,$blksize,$blocks) = (0) x 13;
    } else {
        ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
INTRO
          \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat(_);
SUB
        if (-f _) {
            open(IN, "./$_\0") || do {
                warn "Couldn't open $fname: $!\n";
                return;
            }
        } else {
            $text = readlink($_);
            $size = 0 unless defined $text;
        }
    }

    $fname =~ s#^\./##;
    $nc{$fh} = $nc;
    if ($nc eq 'n') {
        $cpout{$fh} .=
          sprintf("%06o%06o%06o%06o%06o%06o%06o%06o%011lo%06o%011lo%s\0",
            070707,
            $dev & 0777777,
            $ino & 0777777,
            $mode & 0777777,
            $uid & 0777777,
            $gid & 0777777,
            $nlink & 0777777,
            $rdev & 0177777,
            $mtime,
            length($fname)+1,
            $size,
            $fname);
    } else {
        $cpout{$fh} .= "\0" if length($cpout{$fh}) & 1;
        $cpout{$fh} .= pack("SSSSSSSSLSLa*",
            070707, $dev, $ino, $mode, $uid, $gid, $nlink, $rdev, $mtime,
            length($fname)+1, $size,
            $fname . (length($fname) & 1 ? "\0" : "\0\0"));
    }

    if ($text ne '') {
        $cpout{$fh} .= $text;
    } elsif ($size) {
        my $l;
        flush($fh, \$cpout{$fh}, 5120)
            while ($l = length($cpout{$fh})) >= 5120;
        while (sysread(IN, $cpout{$fh}, 5120 - $l, $l)) {
            flush($fh, \$cpout{$fh}, 5120);
            $l = length($cpout{$fh});
        }
        close IN;
    }
}

sub cflushall () {
    for my $fh (keys %cpout) {
        cpio($fh, undef, $nc{$fh});
        $cpout{$fh} .= "0" x (5120 - length($cpout{$fh}));
        flush($fh, \$cpout{$fh}, 5120);
        print $blocks{$fh} * 10, " blocks\n";
    }
}

END
}

if (exists $init{tar}) {
    print <<'INTRO', <<"SUB", <<'END';

my %tarout = ();
my %linkseen = ();

sub tar {
    my ($fh, $fname) = @@_;
    my $prefix = '';
    my $typeflag = '0';
    my $linkname;
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
INTRO
        \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat(_);
SUB
    local (*IN);

    if ($nlink > 1) {
        if ($linkname = $linkseen{$fh, $dev, $ino}) {
            if (length($linkname) > 100) {
                warn "$0: omitting file with linkname ",
                     "too long for tar output: $linkname\n";
                return;
            }
            $typeflag = '1';
            $size = 0;
        } else {
            $linkseen{$fh, $dev, $ino} = $fname;
        }
    }
    if ($typeflag eq '0') {
        if (-f _) {
            open(IN, "./$_\0") || do {
                warn "Couldn't open $fname: $!\n";
                return;
            }
        } else {
            $linkname = readlink($_);
            if (defined $linkname) { $typeflag = '2' }
            elsif (-c _) { $typeflag = '3' }
            elsif (-b _) { $typeflag = '4' }
            elsif (-d _) { $typeflag = '5' }
            elsif (-p _) { $typeflag = '6' }
        }
    }

    if (length($fname) > 100) {
        ($prefix, $fname) = ($fname =~ m#\A(.*?)/(.{,100})\Z(?!\n)#);
        if (!defined($fname) || length($prefix) > 155) {
            warn "$0: omitting file with name too long for tar output: ",
                 $fname, "\n";
            return;
        }
    }

    $size = 0 if $typeflag ne '0';
    my $header = pack("a100a8a8a8a12a12a8a1a100a6a2a32a32a8a8a155",
                        $fname,
                        sprintf("%7o ", $mode &    0777),
                        sprintf("%7o ", $uid  & 0777777),
                        sprintf("%7o ", $gid  & 0777777),
                        sprintf("%11o ", $size),
                        sprintf("%11o ", $mtime),
                        ' 'x8,
                        $typeflag,
                        defined $linkname ? $linkname : '',
                        "ustar\0",
                        "00",
                        $user{$uid},
                        $group{$gid},
                        ($rdev >> 8) & 0xff,
                        $rdev & 0xff,
                        $prefix,
                     );
    substr($header, 148, 8) = sprintf("%7o ", unpack("%16C*", $header));
    my $l = length($header) % 512;
    $tarout{$fh} .= $header;
    $tarout{$fh} .= "\0" x (512 - $l) if $l;

    if ($size) {
        flush($fh, \$tarout{$fh}, 10240)
            while ($l = length($tarout{$fh})) >= 10240;
        while (sysread(IN, $tarout{$fh}, 10240 - $l, $l)) {
            my $slop = length($tarout{$fh}) % 512;
            $tarout{$fh} .= "\0" x (512 - $slop) if $slop;
            flush($fh, \$tarout{$fh}, 10240);
            $l = length($tarout{$fh});
        }
        close IN;
    }
}

sub tflushall () {
    my $len;
    for my $fh (keys %tarout) {
        $len = 10240 - length($tarout{$fh});
        $len += 10240 if $len < 1024;
        $tarout{$fh} .= "\0" x $len;
        flush($fh, \$tarout{$fh}, 10240);
    }
}

END
}

exit;

############################################################################

sub tab () {
    my $tabstring;

    $tabstring = "\t" x ($indent_depth/2) . ' ' x ($indent_depth%2 * 4);
    if (!$statdone) {
        if ($_ =~ /^(?:name|print|prune|exec|ok|\(|\))/) {
            $init{delayedstat} = 1;
        } else {
            my $statcall = '(($dev,$ino,$mode,$nlink,$uid,$gid) = '
                         . $stat . '($_))';
            if (exists $init{saw_or}) {
                $tabstring .= "(\$nlink || $statcall) &&\n" . $tabstring;
            } else {
                $tabstring .= "$statcall &&\n" . $tabstring;
            }
            $statdone = 1;
            $init{declarestat} = 1;
        }
    }
    $tabstring =~ s/^\s+/ / if $out =~ /!$/;
    $tabstring;
}

sub fileglob_to_re ($) {
    my $x = shift;
    $x =~ s#([./^\$()+])#\\$1#g;
    $x =~ s#\*#.*#g;
    $x =~ s#\?#.#g;
    "^$x\\z";
}

sub n ($$) {
    my ($pre, $n) = @@_;
    $n =~ s/^-/< / || $n =~ s/^\+/> / || $n =~ s/^/== /;
    $n =~ s/ 0*(\d)/ $1/;
    "($pre $n)";
}

sub quote ($) {
    my $string = shift;
    $string =~ s/\\/\\\\/g;
    $string =~ s/'/\\'/g;
    "'$string'";
}

__END__

=head1 NAME

find2perl - translate find command lines to Perl code

=head1 SYNOPSIS

	find2perl [paths] [predicates] | perl

=head1 DESCRIPTION

find2perl is a little translator to convert find command lines to
equivalent Perl code.  The resulting code is typically faster than
running find itself.

"paths" are a set of paths where find2perl will start its searches and
"predicates" are taken from the following list.

=over 4

=item C<! PREDICATE>

Negate the sense of the following predicate.  The C<!> must be passed as
a distinct argument, so it may need to be surrounded by whitespace and/or
quoted from interpretation by the shell using a backslash (just as with
using C<find(1)>).

=item C<( PREDICATES )>

Group the given PREDICATES.  The parentheses must be passed as distinct
arguments, so they may need to be surrounded by whitespace and/or
quoted from interpretation by the shell using a backslash (just as with
using C<find(1)>).

=item C<PREDICATE1 PREDICATE2>

True if _both_ PREDICATE1 and PREDICATE2 are true; PREDICATE2 is not
evaluated if PREDICATE1 is false.

=item C<PREDICATE1 -o PREDICATE2>

True if either one of PREDICATE1 or PREDICATE2 is true; PREDICATE2 is
not evaluated if PREDICATE1 is true.

=item C<-follow>

Follow (dereference) symlinks.  The checking of file attributes depends
on the position of the C<-follow> option. If it precedes the file
check option, an C<stat> is done which means the file check applies to the
file the symbolic link is pointing to. If C<-follow> option follows the
file check option, this now applies to the symbolic link itself, i.e.
an C<lstat> is done.

=item C<-depth>

Change directory traversal algorithm from breadth-first to depth-first.

=item C<-prune>

Do not descend into the directory currently matched.

=item C<-xdev>

Do not traverse mount points (prunes search at mount-point directories).

=item C<-name GLOB>

File name matches specified GLOB wildcard pattern.  GLOB may need to be
quoted to avoid interpretation by the shell (just as with using
C<find(1)>).

=item C<-iname GLOB>

Like C<-name>, but the match is case insensitive.

=item C<-path GLOB>

Path name matches specified GLOB wildcard pattern.

=item C<-ipath GLOB>

Like C<-path>, but the match is case insensitive.

=item C<-perm PERM>

Low-order 9 bits of permission match octal value PERM.

=item C<-perm -PERM>

The bits specified in PERM are all set in file's permissions.

=item C<-type X>

The file's type matches perl's C<-X> operator.

=item C<-fstype TYPE>

Filesystem of current path is of type TYPE (only NFS/non-NFS distinction
is implemented).

=item C<-user USER>

True if USER is owner of file.

=item C<-group GROUP>

True if file's group is GROUP.

=item C<-nouser>

True if file's owner is not in password database.

=item C<-nogroup>

True if file's group is not in group database.

=item C<-inum INUM>

True file's inode number is INUM.

=item C<-links N>

True if (hard) link count of file matches N (see below).

=item C<-size N>

True if file's size matches N (see below) N is normally counted in
512-byte blocks, but a suffix of "c" specifies that size should be
counted in characters (bytes) and a suffix of "k" specifies that
size should be counted in 1024-byte blocks.

=item C<-atime N>

True if last-access time of file matches N (measured in days) (see
below).

=item C<-ctime N>

True if last-changed time of file's inode matches N (measured in days,
see below).

=item C<-mtime N>

True if last-modified time of file matches N (measured in days, see below).

=item C<-newer FILE>

True if last-modified time of file matches N.

=item C<-print>

Print out path of file (always true). If none of C<-exec>, C<-ls>,
C<-print0>, or C<-ok> is specified, then C<-print> will be added
implicitly.

=item C<-print0>

Like -print, but terminates with \0 instead of \n.

=item C<-exec OPTIONS ;>

exec() the arguments in OPTIONS in a subprocess; any occurrence of {} in
OPTIONS will first be substituted with the path of the current
file.  Note that the command "rm" has been special-cased to use perl's
unlink() function instead (as an optimization).  The C<;> must be passed as
a distinct argument, so it may need to be surrounded by whitespace and/or
quoted from interpretation by the shell using a backslash (just as with
using C<find(1)>).

=item C<-ok OPTIONS ;>

Like -exec, but first prompts user; if user's response does not begin
with a y, skip the exec.  The C<;> must be passed as
a distinct argument, so it may need to be surrounded by whitespace and/or
quoted from interpretation by the shell using a backslash (just as with
using C<find(1)>).

=item C<-eval EXPR>

Has the perl script eval() the EXPR.  

=item C<-ls>

Simulates C<-exec ls -dils {} ;>

=item C<-tar FILE>

Adds current output to tar-format FILE.

=item C<-cpio FILE>

Adds current output to old-style cpio-format FILE.

=item C<-ncpio FILE>

Adds current output to "new"-style cpio-format FILE.

=back

Predicates which take a numeric argument N can come in three forms:

   * N is prefixed with a +: match values greater than N
   * N is prefixed with a -: match values less than N
   * N is not prefixed with either + or -: match only values equal to N

=head1 SEE ALSO

find, File::Find.

=cut
!NO!SUBS!

close OUT or die "Can't close $file: $!";
chmod 0755, $file or die "Can't reset permissions for $file: $!\n";
exec("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
chdir $origdir;
@


1.14
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d3 1
@


1.14.4.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a2 1
BEGIN { pop @@INC if $INC[-1] eq '.' }
@


1.14.6.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a2 1
BEGIN { pop @@INC if $INC[-1] eq '.' }
@


1.13
log
@Merge in perl 5.10.1; part two
@
text
@d684 2
a685 1
    $x =~ s#([?*])#.$1#g;
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a44 14
#
# Modified September 26, 1993 to provide proper handling of years after 1999
#   Tom Link <tml+@@pitt.edu>
#   University of Pittsburgh
#
# Modified April 7, 1998 with nasty hacks to implement the troublesome -follow
#  Billy Constantine <wdconsta@@cs.adelaide.edu.au> <billy@@smug.adelaide.edu.au>
#  University of Adelaide, Adelaide, South Australia
#
# Modified 1999-06-10, 1999-07-07 to migrate to cleaner perl5 usage
#   Ken Pizzini <ken@@halcyon.com>
#
# Modified 2000-01-28 to use the 'follow' option of File::Find

d910 1
a910 1
find
@


1.11
log
@merge in perl 5.8.8
@
text
@d845 1
a845 1
counted in characters (bytes) and a suffix of "k" specifes that
@


1.10
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d102 4
a105 2
    } elsif ($_ eq 'name') {
        $out .= tab . '/' . fileglob_to_re(shift) . "/s";
d787 12
@


1.9
log
@merge local changes into perl-5.8.3
@
text
@d218 1
d269 3
a271 1
    $out .= "\n" . tab . '&& print("$name\n")';
d296 8
a370 3

use Cwd ();
my $cwd = Cwd::cwd();
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d83 1
d121 1
d124 1
d189 1
d201 1
d225 1
d267 4
d846 3
a848 1
Print out path of file (always true).
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d194 1
a194 1
        { local $" = "','"; $out .= "doexec(0, '@@cmd')"; }
@


1.6
log
@merge in perl 5.6.1 with our local changes
@
text
@d59 5
d69 1
a69 1
for (@@roots) { $_ = &quote($_) }
d80 1
d88 1
a88 1
        $out .= &tab . "(\n";
d93 1
a93 1
        $out .= &tab . ")";
d99 1
a99 1
        $out .= &tab . "!";
d102 1
a102 1
        $out .= &tab . '/' . &fileglob_to_re(shift) . "/s";
d107 1
a107 1
        $out .= &tab;
d117 1
a117 1
        $out .= &tab . "-$filetest _";
d119 1
a119 1
        $out .= &tab . 'print("$name\n")';
d121 1
a121 1
        $out .= &tab . 'print("$name\0")';
d124 1
a124 1
        $out .= &tab;
d132 1
a132 1
        $out .= &tab . "(\$uid == \$uid{'$uname'})";
d136 1
a136 1
        $out .= &tab . "(\$gid == \$gid{'$gname'})";
d139 1
a139 1
        $out .= &tab . '!exists $uid{$uid}';
d142 1
a142 1
        $out .= &tab . '!exists $gid{$gid}';
d145 1
a145 1
        $out .= &tab . &n('$nlink', shift);
d147 1
a147 1
        $out .= &tab . &n('$ino', shift);
d156 1
a156 1
        $out .= &tab . &n($n, $_);
d158 1
a158 1
        $out .= &tab . &n('int(-A _)', shift);
d160 1
a160 1
        $out .= &tab . &n('int(-M _)', shift);
d162 1
a162 1
        $out .= &tab . &n('int(-C _)', shift);
d168 1
a168 1
        $out .= &tab;
d182 2
a183 1
            { local $" = "','"; $out .= "&doexec(0, '@@cmd')"; }
d191 1
a191 1
        $out .= &tab;
d194 2
a195 1
        { local $" = "','"; $out .= "&doexec(0, '@@cmd')"; }
d198 1
a198 1
        $out .= &tab . '($File::Find::prune = 1)';
d200 1
a200 1
        $out .= &tab . '!($File::Find::prune |= ($dev != $File::Find::topdev))'
d207 2
a208 2
        $out .= &tab . "(-M _ < $newername)";
        $initnewer .= "my $newername = -M " . &quote($file) . ";\n";
d212 1
a212 1
        $out .= &tab . "eval {$prog}";
d217 2
a218 1
        $out .= &tab . "&ls";
d225 4
a228 3
        $out .= &tab . "&tar(*$fh, \$name)";
        $flushall .= "&tflushall;\n";
        $initfile .= "open($fh, " . &quote('> ' . $file) .
d236 1
a236 1
        $out .= &tab . "&cpio(*$fh, \$name, '$1')";
d238 3
a240 2
        $flushall .= "&cflushall;\n";
        $initfile .= "open($fh, " . &quote('> ' . $file) .
d249 1
a249 1
            { local($statdone) = 1; $out .= "\n" . &tab . "||\n"; }
d279 2
a282 1

d354 1
a354 1
sub doexec {
d356 2
a357 1
    for my $word (@@_)
d362 1
a362 1
        print "@@_";
d367 1
a367 1
    system @@_;
d383 1
a383 1
sub ls {
d531 1
a531 1
sub cflushall {
d533 1
a533 1
        &cpio($fh, undef, $nc{$fh});
d635 1
a635 1
sub tflushall {
d652 1
a652 1
sub tab {
d675 1
a675 1
sub fileglob_to_re {
d677 1
a677 1
    $x =~ s#([./^\$()])#\\$1#g;
d682 1
a682 1
sub n {
d689 1
a689 1
sub quote {
d844 1
a844 1
exec() the arguments in OPTIONS in a subprocess; any occurence of {} in
@


1.5
log
@perl-5.6.0 + local changes
@
text
@d32 3
a34 1
my \$perlpath = "$Config{perlpath}";
d42 1
d63 1
a63 1
@@roots = ('.') unless @@roots;
d339 2
a340 4
BEGIN {
    require Cwd;
    my $cwd = Cwd::cwd();
}
d678 1
@


1.4
log
@Need to check for the c suffix on args to the -size switch.  Patch sent to perl maintainers.
@
text
@d32 1
a32 2
\$startperl = "$Config{startperl}";
\$perlpath = "$Config{perlpath}";
d38 3
d42 1
a42 1
# 
d46 1
a46 1
# 
d50 5
a54 1
# 
d56 1
d61 2
a62 2
for (@@roots) { $_ = &quote($_); }
$roots = join(',', @@roots);
d64 10
a73 3
$indent = 1;
$stat = 'lstat';
$decl = '';
d79 152
a230 182
	$out .= &tab . "(\n";
	$indent++;
	next;
    }
    elsif ($_ eq ')') {
	$indent--;
	$out .= &tab . ")";
    }
    elsif ($_ eq 'follow') {
	$stat = 'stat';
	$decl = '%already_seen = ();';
	$out .= &tab . '(not $already_seen{"$dev,$ino"}) &&';
	$out .= "\n" . &tab . '(($already_seen{"$dev,$ino"} = !(-d _)) || 1)';
    }
    elsif ($_ eq '!') {
	$out .= &tab . "!";
	next;
    }
    elsif ($_ eq 'name') {
	$out .= &tab;
	$pat = &fileglob_to_re(shift);
	$out .= '/' . $pat . "/";
    }
    elsif ($_ eq 'perm') {
	$onum = shift;
	die "Malformed -perm argument: $onum\n" unless $onum =~ /^-?[0-7]+$/;
	if ($onum =~ s/^-//) {
	    $onum = '0' . sprintf("%o", oct($onum) & 017777);	# s/b 07777 ?
	    $out .= &tab . "((\$mode & $onum) == $onum)";
	}
	else {
	    $onum = '0' . $onum unless $onum =~ /^0/;
	    $out .= &tab . "((\$mode & 0777) == $onum)";
	}
    }
    elsif ($_ eq 'type') {
	($filetest = shift) =~ tr/s/S/;
	$out .= &tab . "-$filetest _";
    }
    elsif ($_ eq 'print') {
	$out .= &tab . 'print("$name\n")';
    }
    elsif ($_ eq 'print0') {
	$out .= &tab . 'print("$name\0")';
    }
    elsif ($_ eq 'fstype') {
	$out .= &tab;
	$type = shift;
	if ($type eq 'nfs')
	    { $out .= '($dev < 0)'; }
	else
	    { $out .= '($dev >= 0)'; }
    }
    elsif ($_ eq 'user') {
	$uname = shift;
	$out .= &tab . "(\$uid == \$uid{'$uname'})";
	$inituser++;
    }
    elsif ($_ eq 'group') {
	$gname = shift;
	$out .= &tab . "(\$gid == \$gid{'$gname'})";
	$initgroup++;
    }
    elsif ($_ eq 'nouser') {
	$out .= &tab . '!defined $uid{$uid}';
	$inituser++;
    }
    elsif ($_ eq 'nogroup') {
	$out .= &tab . '!defined $gid{$gid}';
	$initgroup++;
    }
    elsif ($_ eq 'links') {
	$out .= &tab . '($nlink ' . &n(shift);
    }
    elsif ($_ eq 'inum') {
	$out .= &tab . '($ino ' . &n(shift);
    }
    elsif ($_ eq 'size') {
	$_ = shift;
	if (s/c$//) {
	    $out .= &tab . '(int(-s _) ' . &n($_);
	} else {
	    $out .= &tab . '(int(((-s _) + 511) / 512) ' . &n($_);
	}
    }
    elsif ($_ eq 'atime') {
	$out .= &tab . '(int(-A _) ' . &n(shift);
    }
    elsif ($_ eq 'mtime') {
	$out .= &tab . '(int(-M _) ' . &n(shift);
    }
    elsif ($_ eq 'ctime') {
	$out .= &tab . '(int(-C _) ' . &n(shift);
    }
    elsif ($_ eq 'exec') {
	for (@@cmd = (); @@ARGV && $ARGV[0] ne ';'; push(@@cmd,shift)) { }
	shift;
	$_ = "@@cmd";
	if (m#^(/bin/)?rm -f {}$#) {
	    if (!@@ARGV) {
		$out .= &tab . 'unlink($_)';
	    }
	    else {
		$out .= &tab . '(unlink($_) || 1)';
	    }
	}
	elsif (m#^(/bin/)?rm {}$#) {
	    $out .= &tab . '(unlink($_) || warn "$name: $!\n")';
	}
	else {
	    for (@@cmd) { s/'/\\'/g; }
	    $" = "','";
	    $out .= &tab . "&exec(0, '@@cmd')";
	    $" = ' ';
	    $initexec++;
	}
    }
    elsif ($_ eq 'ok') {
	for (@@cmd = (); @@ARGV && $ARGV[0] ne ';'; push(@@cmd,shift)) { }
	shift;
	for (@@cmd) { s/'/\\'/g; }
	$" = "','";
	$out .= &tab . "&exec(1, '@@cmd')";
	$" = ' ';
	$initexec++;
    }
    elsif ($_ eq 'prune') {
	$out .= &tab . '($prune = 1)';
    }
    elsif ($_ eq 'xdev') {
	$out .= &tab . '!($prune |= ($dev != $topdev))';
    }
    elsif ($_ eq 'newer') {
	$out .= &tab;
	$file = shift;
	$newername = 'AGE_OF' . $file;
	$newername =~ s/[^\w]/_/g;
	$newername = "\$$newername";
	$out .= "(-M _ < $newername)";
	$initnewer .= "$newername = -M " . &quote($file) . ";\n";
    }
    elsif ($_ eq 'eval') {
	$prog = &quote(shift);
	$out .= &tab . "eval $prog";
    }
    elsif ($_ eq 'depth') {
	$depth++;
	next;
    }
    elsif ($_ eq 'ls') {
	$out .= &tab . "&ls";
	$initls++;
    }
    elsif ($_ eq 'tar') {
	$out .= &tab;
	die "-tar must have a filename argument\n" unless @@ARGV;
	$file = shift;
	$fh = 'FH' . $file;
	$fh =~ s/[^\w]/_/g;
	$out .= "&tar($fh)";
	$file = '>' . $file;
	$initfile .= "open($fh, " . &quote($file) .
	  qq{) || die "Can't open $fh: \$!\\n";\n};
	$inittar++;
	$flushall = "\n&tflushall;\n";
    }
    elsif (/^n?cpio$/) {
	$depth++;
	$out .= &tab;
	die "-$_ must have a filename argument\n" unless @@ARGV;
	$file = shift;
	$fh = 'FH' . $file;
	$fh =~ s/[^\w]/_/g;
	$out .= "&cpio('" . substr($_,0,1) . "', $fh)";
	$file = '>' . $file;
	$initfile .= "open($fh, " . &quote($file) .
	  qq{) || die "Can't open $fh: \$!\\n";\n};
	$initcpio++;
	$flushall = "\n&flushall;\n";
    }
    else {
	die "Unrecognized switch: -$_\n";
d232 1
d234 10
a243 11
	if ($ARGV[0] eq '-o') {
	    { local($statdone) = 1; $out .= "\n" . &tab . "||\n"; }
	    $statdone = 0 if $indent == 1 && $delayedstat;
	    $saw_or++;
	    shift;
	}
	else {
	    $out .= " &&" unless $ARGV[0] eq ')';
	    $out .= "\n";
	    shift if $ARGV[0] eq '-a';
	}
d247 1
d251 13
a263 1
	if \$running_under_some_shell;
d267 2
a268 1
if ($initls) {
d270 2
a271 2
@@rwx = ('---','--x','-w-','-wx','r--','r-x','rw-','rwx');
@@moname = (Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec);
d276 7
a282 4
if ($inituser || $initls) {
    print 'while (($name, $pw, $uid) = getpwent) {', "\n";
    print '    $uid{$name} = $uid{$uid} = $uid;', "\n" if $inituser;
    print '    $user{$uid} = $name unless $user{$uid};', "\n" if $initls;
d286 7
a292 4
if ($initgroup || $initls) {
    print 'while (($name, $pw, $gid) = getgrent) {', "\n";
    print '    $gid{$name} = $gid{$gid} = $gid;', "\n" if $initgroup;
    print '    $group{$gid} = $name unless $group{$gid};', "\n" if $initls;
d296 6
a301 1
print $initnewer, "\n" if $initnewer;
d303 2
a304 1
print $initfile, "\n" if $initfile;
d306 2
a307 1
$find = $depth ? "finddepth" : "find";
d309 4
a312 1
require "$find.pl";
d314 3
a316 1
# Traverse desired filesystems
d318 3
d322 2
a323 1
&$find($roots);
d325 1
a325 1
exit;
d331 1
d333 1
a333 1
if ($initexec) {
d335 10
a344 5
sub exec {
    local($ok, @@cmd) = @@_;
    foreach $word (@@cmd) {
	$word =~ s#{}#$name#g;
    }
d346 9
a354 9
	local($old) = select(STDOUT);
	$| = 1;
	print "@@cmd";
	select($old);
	return 0 unless <STDIN> =~ /^y/;
    }
    chdir $cwd;		# sigh
    system @@cmd;
    chdir $dir;
d361 8
a368 2
if ($initls) {
    print <<"INTERP", <<'END';
d370 25
a394 31
    (\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid,\$rdev,\$sizemm,
      \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat\(_\);
INTERP

    $pname = $name;

    if (defined $blocks) {
	$blocks = int(($blocks + 1) / 2);
    }
    else {
	$blocks = int(($size + 1023) / 1024);
    }

    if    (-f _) { $perms = '-'; }
    elsif (-d _) { $perms = 'd'; }
    elsif (-c _) { $perms = 'c'; $sizemm = &sizemm; }
    elsif (-b _) { $perms = 'b'; $sizemm = &sizemm; }
    elsif (-p _) { $perms = 'p'; }
    elsif (-S _) { $perms = 's'; }
    else         { $perms = 'l'; $pname .= ' -> ' . readlink($_); }

    $tmpmode = $mode;
    $tmp = $rwx[$tmpmode & 7];
    $tmpmode >>= 3;
    $tmp = $rwx[$tmpmode & 7] . $tmp;
    $tmpmode >>= 3;
    $tmp = $rwx[$tmpmode & 7] . $tmp;
    substr($tmp,2,1) =~ tr/-x/Ss/ if -u _;
    substr($tmp,5,1) =~ tr/-x/Ss/ if -g _;
    substr($tmp,8,1) =~ tr/-x/Tt/ if -k _;
    $perms .= $tmp;
d396 2
a397 2
    $user = $user{$uid} || $uid;
    $group = $group{$gid} || $gid;
d399 1
a399 2
    ($sec,$min,$hour,$mday,$mon,$year) = localtime($mtime);
    $moname = $moname[$mon];
d401 19
a419 5
	$timeyear = $year + 1900;
    }
    else {
	$timeyear = sprintf("%02d:%02d", $hour, $min);
    }
d421 1
a421 13
    printf "%5lu %4ld %-10s %2d %-8s %-8s %8s %s %2d %5s %s\n",
	    $ino,
		 $blocks,
		      $perms,
			    $nlink,
				$user,
				     $group,
					  $sizemm,
					      $moname,
						 $mday,
						     $timeyear,
							 $pname;
    1;
d424 15
a438 2
sub sizemm {
    sprintf("%3d, %3d", ($rdev >> 8) & 255, $rdev & 255);
d444 7
a450 2
if ($initcpio) {
print <<'START', <<"INTERP", <<'END';
d452 24
a475 22
    local($nc,$fh) = @@_;
    local($text);

    if ($name eq 'TRAILER!!!') {
	$text = '';
	$size = 0;
    }
    else {
START
	(\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid,\$rdev,\$size,
	  \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat\(_\);
INTERP
	if (-f _) {
	    open(IN, "./$_\0") || do {
		warn "Couldn't open $name: $!\n";
		return;
	    };
	}
	else {
	    $text = readlink($_);
	    $size = 0 unless defined $text;
	}
d478 1
a478 1
    ($nm = $name) =~ s#^\./##;
d481 20
a500 20
	$cpout{$fh} .=
	  sprintf("%06o%06o%06o%06o%06o%06o%06o%06o%011lo%06o%011lo%s\0",
	    070707,
	    $dev & 0777777,
	    $ino & 0777777,
	    $mode & 0777777,
	    $uid & 0777777,
	    $gid & 0777777,
	    $nlink & 0777777,
	    $rdev & 0177777,
	    $mtime,
	    length($nm)+1,
	    $size,
	    $nm);
    }
    else {
	$cpout{$fh} .= "\0" if length($cpout{$fh}) & 1;
	$cpout{$fh} .= pack("SSSSSSSSLSLa*",
	    070707, $dev, $ino, $mode, $uid, $gid, $nlink, $rdev, $mtime,
	    length($nm)+1, $size, $nm . (length($nm) & 1 ? "\0" : "\0\0"));
d502 1
d504 10
a513 1
	$cpout{$fh} .= $text;
a514 8
    elsif ($size) {
	&flush($fh) while ($l = length($cpout{$fh})) >= 5120;
	while (sysread(IN, $cpout{$fh}, 5120 - $l, $l)) {
	    &flush($fh);
	    $l = length($cpout{$fh});
	}
    }
    close IN;
d517 6
a522 7
sub flush {
    local($fh) = @@_;

    while (length($cpout{$fh}) >= 5120) {
	syswrite($fh,$cpout{$fh},5120);
	++$blocks{$fh};
	substr($cpout{$fh}, 0, 5120) = '';
d526 1
a526 8
sub flushall {
    $name = 'TRAILER!!!';
    foreach $fh (keys %cpout) {
	&cpio($nc{$fh},$fh);
	$cpout{$fh} .= "0" x (5120 - length($cpout{$fh}));
	&flush($fh);
	print $blocks{$fh} * 10, " blocks\n";
    }
d529 5
a533 2
END
}
a534 2
if ($inittar) {
print <<'START', <<"INTERP", <<'END';
d536 10
a545 9
    local($fh) = @@_;
    local($linkname,$header,$l,$slop);
    local($linkflag) = "\0";

START
    (\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid,\$rdev,\$size,
      \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat\(_\);
INTERP
    $nm = $name;
d547 58
a604 34
	if ($linkname = $linkseen{$fh,$dev,$ino}) {
	    $linkflag = 1;
	}
	else {
	    $linkseen{$fh,$dev,$ino} = $nm;
	}
    }
    if (-f _) {
	open(IN, "./$_\0") || do {
	    warn "Couldn't open $name: $!\n";
	    return;
	};
	$size = 0 if $linkflag ne "\0";
    }
    else {
	$linkname = readlink($_);
	$linkflag = 2 if defined $linkname;
	$nm .= '/' if -d _;
	$size = 0;
    }

    $header = pack("a100a8a8a8a12a12a8a1a100",
	$nm,
	sprintf("%6o ", $mode & 0777),
	sprintf("%6o ", $uid & 0777777),
	sprintf("%6o ", $gid & 0777777),
	sprintf("%11o ", $size),
	sprintf("%11o ", $mtime),
	"        ",
	$linkflag,
	$linkname);
    $l = length($header) % 512;
    substr($header, 148, 6) = sprintf("%6o", unpack("%16C*", $header));
    substr($header, 154, 1) = "\0";  # blech
d607 1
d609 9
a617 18
	&tflush($fh) while ($l = length($tarout{$fh})) >= 10240;
	while (sysread(IN, $tarout{$fh}, 10240 - $l, $l)) {
	    $slop = length($tarout{$fh}) % 512;
	    $tarout{$fh} .= "\0" x (512 - $slop) if $slop;
	    &tflush($fh);
	    $l = length($tarout{$fh});
	}
    }
    close IN;
}

sub tflush {
    local($fh) = @@_;

    while (length($tarout{$fh}) >= 10240) {
	syswrite($fh,$tarout{$fh},10240);
	++$blocks{$fh};
	substr($tarout{$fh}, 0, 10240) = '';
d622 6
a627 7
    local($len);

    foreach $fh (keys %tarout) {
	$len = 10240 - length($tarout{$fh});
	$len += 10240 if $len < 1024;
	$tarout{$fh} .= "\0" x $len;
	&tflush($fh);
d639 1
a639 1
    local($tabstring);
d641 1
a641 1
    $tabstring = "\t" x ($indent / 2) . ' ' x ($indent % 2 * 4);
d643 13
a655 16
	if ($_ =~ /^(name|print|prune|exec|ok|\(|\))/) {
	    $delayedstat++;
	}
	else {
	    if ($saw_or) {
		$tabstring .= <<"ENDOFSTAT" . $tabstring;
(\$nlink || ((\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid) = $stat\(\$_\))) &&
ENDOFSTAT
	    }
	    else {
		$tabstring .= <<"ENDOFSTAT" . $tabstring;
((\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid) = $stat\(\$_\)) &&
ENDOFSTAT
	    }
	    $statdone = 1;
	}
d662 4
a665 5
    local($tmp) = @@_;

    $tmp =~ s#([./^\$()])#\\$1#g;
    $tmp =~ s/([?*])/.$1/g;
    "^$tmp\$";
d669 1
a669 2
    local($n) = @@_;

d672 1
a672 1
    $n . ')';
d676 2
a677 2
    local($string) = @@_;
    $string =~ s/'/\\'/;
d680 198
@


1.3
log
@perl5.005_03 (stock)
@
text
@d143 6
a148 1
	$out .= &tab . '(int(((-s _) + 511) / 512) ' . &n(shift);
@


1.2
log
@perl 5.004_04
@
text
@d5 1
d16 1
d31 1
a31 1
	if \$running_under_some_shell;
d39 1
d44 5
d58 2
d73 6
d197 1
a197 1
	$newername = '$' . $newername;
d297 1
a300 1

d331 1
a331 1
    print <<'END';
d333 3
a335 2
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$sizemm,
      $atime,$mtime,$ctime,$blksize,$blocks) = lstat(_);
d400 1
a400 1
print <<'END';
d410 4
a413 2
	($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	  $atime,$mtime,$ctime,$blksize,$blocks) = lstat(_);
d487 1
a487 1
print <<'END';
d493 4
a496 2
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
      $atime,$mtime,$ctime,$blksize,$blocks) = lstat(_);
d585 2
a586 2
		$tabstring .= <<'ENDOFSTAT' . $tabstring;
($nlink || (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_))) &&
d590 2
a591 2
		$tabstring .= <<'ENDOFSTAT' . $tabstring;
(($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
d627 1
@


1.1
log
@Initial revision
@
text
@d15 3
a17 4
chdir(dirname($0));
($file = basename($0)) =~ s/\.PL$//;
$file =~ s/\.pl$//
	if ($^O eq 'VMS' or $^O eq 'os2');  # "case-forgiving"
d27 3
a29 3
$Config{'startperl'}
    eval 'exec perl -S \$0 "\$@@"'
	if 0;
d31 1
d244 1
a244 2

eval 'exec perl -S \$0 \${1+"\$@@"}'
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a4 1
use Cwd;
d15 4
a18 4
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';
d28 3
a30 3
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
      if \$running_under_some_shell;
a31 1
\$perlpath = "$Config{perlpath}";
a36 1

a40 5
# 
# Modified April 7, 1998 with nasty hacks to implement the troublesome -follow
#  Billy Constantine <wdconsta@@cs.adelaide.edu.au> <billy@@smug.adelaide.edu.au>
#  University of Adelaide, Adelaide, South Australia
# 
a49 2
$stat = 'lstat';
$decl = '';
a62 6
    elsif ($_ eq 'follow') {
	$stat = 'stat';
	$decl = '%already_seen = ();';
	$out .= &tab . '(not $already_seen{"$dev,$ino"}) &&';
	$out .= "\n" . &tab . '(($already_seen{"$dev,$ino"} = !(-d _)) || 1)';
    }
d181 1
a181 1
	$newername = "\$$newername";
d244 2
a245 1
    eval 'exec $perlpath -S \$0 \${1+"\$@@"}'
a281 1
$decl
d285 1
d316 1
a316 1
    print <<"INTERP", <<'END';
d318 2
a319 3
    (\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid,\$rdev,\$sizemm,
      \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat\(_\);
INTERP
d384 1
a384 1
print <<'START', <<"INTERP", <<'END';
d394 2
a395 4
START
	(\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid,\$rdev,\$size,
	  \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat\(_\);
INTERP
d469 1
a469 1
print <<'START', <<"INTERP", <<'END';
d475 2
a476 4
START
    (\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid,\$rdev,\$size,
      \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat\(_\);
INTERP
d565 2
a566 2
		$tabstring .= <<"ENDOFSTAT" . $tabstring;
(\$nlink || ((\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid) = $stat\(\$_\))) &&
d570 2
a571 2
		$tabstring .= <<"ENDOFSTAT" . $tabstring;
((\$dev,\$ino,\$mode,\$nlink,\$uid,\$gid) = $stat\(\$_\)) &&
a606 1
chdir $origdir;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d32 2
a33 1
my \$perlpath = "$Config{perlpath}";
a38 3
use strict;
use vars qw/$statdone/;
my $startperl = "#! $perlpath -w";
d40 1
a40 1
#
d44 1
a44 1
#
d48 1
a48 5
#
# Modified 1999-06-10, 1999-07-07 to migrate to cleaner perl5 usage
#   Ken Pizzini <ken@@halcyon.com>
#
# Modified 2000-01-28 to use the 'follow' option of File::Find
a49 1
my @@roots = ();
d54 2
a55 2
for (@@roots) { $_ = &quote($_) }
my $roots = join(', ', @@roots);
d57 3
a59 10
my $find = "find";
my $indent_depth = 1;
my $stat = 'lstat';
my $decl = '';
my $flushall = '';
my $initfile = '';
my $initnewer = '';
my $out = '';
my %init = ();
my ($follow_in_effect,$Skip_And) = (0,0);
d65 177
a241 152
        $out .= &tab . "(\n";
        $indent_depth++;
        next;
    } elsif ($_ eq ')') {
        --$indent_depth;
        $out .= &tab . ")";
    } elsif ($_ eq 'follow') {
        $follow_in_effect= 1;
        $stat = 'stat';
        $Skip_And= 1;
    } elsif ($_ eq '!') {
        $out .= &tab . "!";
        next;
    } elsif ($_ eq 'name') {
        $out .= &tab . '/' . &fileglob_to_re(shift) . "/s";
    } elsif ($_ eq 'perm') {
        my $onum = shift;
        $onum =~ /^-?[0-7]+$/
            || die "Malformed -perm argument: $onum\n";
        $out .= &tab;
        if ($onum =~ s/^-//) {
            $onum = sprintf("0%o", oct($onum) & 07777);
            $out .= "((\$mode & $onum) == $onum)";
        } else {
            $onum =~ s/^0*/0/;
            $out .= "((\$mode & 0777) == $onum)";
        }
    } elsif ($_ eq 'type') {
        (my $filetest = shift) =~ tr/s/S/;
        $out .= &tab . "-$filetest _";
    } elsif ($_ eq 'print') {
        $out .= &tab . 'print("$name\n")';
    } elsif ($_ eq 'print0') {
        $out .= &tab . 'print("$name\0")';
    } elsif ($_ eq 'fstype') {
        my $type = shift;
        $out .= &tab;
        if ($type eq 'nfs') {
            $out .= '($dev < 0)';
        } else {
            $out .= '($dev >= 0)'; #XXX
        }
    } elsif ($_ eq 'user') {
        my $uname = shift;
        $out .= &tab . "(\$uid == \$uid{'$uname'})";
        $init{user} = 1;
    } elsif ($_ eq 'group') {
        my $gname = shift;
        $out .= &tab . "(\$gid == \$gid{'$gname'})";
        $init{group} = 1;
    } elsif ($_ eq 'nouser') {
        $out .= &tab . '!exists $uid{$uid}';
        $init{user} = 1;
    } elsif ($_ eq 'nogroup') {
        $out .= &tab . '!exists $gid{$gid}';
        $init{group} = 1;
    } elsif ($_ eq 'links') {
        $out .= &tab . &n('$nlink', shift);
    } elsif ($_ eq 'inum') {
        $out .= &tab . &n('$ino', shift);
    } elsif ($_ eq 'size') {
        $_ = shift;
        my $n = 'int(((-s _) + 511) / 512)';
        if (s/c\z//) {
            $n = 'int(-s _)';
        } elsif (s/k\z//) {
            $n = 'int(((-s _) + 1023) / 1024)';
        }
        $out .= &tab . &n($n, $_);
    } elsif ($_ eq 'atime') {
        $out .= &tab . &n('int(-A _)', shift);
    } elsif ($_ eq 'mtime') {
        $out .= &tab . &n('int(-M _)', shift);
    } elsif ($_ eq 'ctime') {
        $out .= &tab . &n('int(-C _)', shift);
    } elsif ($_ eq 'exec') {
        my @@cmd = ();
        while (@@ARGV && $ARGV[0] ne ';')
            { push(@@cmd, shift) }
        shift;
        $out .= &tab;
        if ($cmd[0] =~m#^(?:(?:/usr)?/bin/)?rm$#
                && $cmd[$#cmd] eq '{}'
                && (@@cmd == 2 || (@@cmd == 3 && $cmd[1] eq '-f'))) {
            if (@@cmd == 2) {
                $out .= '(unlink($_) || warn "$name: $!\n")';
            } elsif (!@@ARGV) {
                $out .= 'unlink($_)';
            } else {
                $out .= '(unlink($_) || 1)';
            }
        } else {
            for (@@cmd)
                { s/'/\\'/g }
            { local $" = "','"; $out .= "&doexec(0, '@@cmd')"; }
            $init{doexec} = 1;
        }
    } elsif ($_ eq 'ok') {
        my @@cmd = ();
        while (@@ARGV && $ARGV[0] ne ';')
            { push(@@cmd, shift) }
        shift;
        $out .= &tab;
        for (@@cmd)
            { s/'/\\'/g }
        { local $" = "','"; $out .= "&doexec(0, '@@cmd')"; }
        $init{doexec} = 1;
    } elsif ($_ eq 'prune') {
        $out .= &tab . '($File::Find::prune = 1)';
    } elsif ($_ eq 'xdev') {
        $out .= &tab . '!($File::Find::prune |= ($dev != $File::Find::topdev))'
;
    } elsif ($_ eq 'newer') {
        my $file = shift;
        my $newername = 'AGE_OF' . $file;
        $newername =~ s/\W/_/g;
        $newername = '$' . $newername;
        $out .= &tab . "(-M _ < $newername)";
        $initnewer .= "my $newername = -M " . &quote($file) . ";\n";
    } elsif ($_ eq 'eval') {
        my $prog = shift;
        $prog =~ s/'/\\'/g;
        $out .= &tab . "eval {$prog}";
    } elsif ($_ eq 'depth') {
        $find = 'finddepth';
        next;
    } elsif ($_ eq 'ls') {
        $out .= &tab . "&ls";
        $init{ls} = 1;
    } elsif ($_ eq 'tar') {
        die "-tar must have a filename argument\n" unless @@ARGV;
        my $file = shift;
        my $fh = 'FH' . $file;
        $fh =~ s/\W/_/g;
        $out .= &tab . "&tar(*$fh, \$name)";
        $flushall .= "&tflushall;\n";
        $initfile .= "open($fh, " . &quote('> ' . $file) .
                     qq{) || die "Can't open $fh: \$!\\n";\n};
        $init{tar} = 1;
    } elsif (/^(n?)cpio\z/) {
        die "-$_ must have a filename argument\n" unless @@ARGV;
        my $file = shift;
        my $fh = 'FH' . $file;
        $fh =~ s/\W/_/g;
        $out .= &tab . "&cpio(*$fh, \$name, '$1')";
        $find = 'finddepth';
        $flushall .= "&cflushall;\n";
        $initfile .= "open($fh, " . &quote('> ' . $file) .
                     qq{) || die "Can't open $fh: \$!\\n";\n};
        $init{cpio} = 1;
    } else {
        die "Unrecognized switch: -$_\n";
a242 1

d244 11
a254 10
        if ($ARGV[0] eq '-o') {
            { local($statdone) = 1; $out .= "\n" . &tab . "||\n"; }
            $statdone = 0 if $indent_depth == 1 && exists $init{delayedstat};
            $init{saw_or} = 1;
            shift;
        } else {
            $out .= " &&" unless $Skip_And || $ARGV[0] eq ')';
            $out .= "\n";
            shift if $ARGV[0] eq '-a';
        }
a257 1

d261 1
a261 13
        if 0; #\$running_under_some_shell

use strict;
use File::Find ();

# Set the variable \$File::Find::dont_use_nlink if you're using AFS,
# since AFS cheats.

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;
d265 1
a265 2

if (exists $init{ls}) {
d267 2
a268 2
my @@rwx = qw(--- --x -w- -wx r-- r-x rw- rwx);
my @@moname = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
d273 4
a276 7
if (exists $init{user} || exists $init{ls} || exists $init{tar}) {
    print "my (%uid, %user);\n";
    print "while (my (\$name, \$pw, \$uid) = getpwent) {\n";
    print '    $uid{$name} = $uid{$uid} = $uid;', "\n"
        if exists $init{user};
    print '    $user{$uid} = $name unless exists $user{$uid};', "\n"
        if exists $init{ls} || exists $init{tar};
d280 4
a283 7
if (exists $init{group} || exists $init{ls} || exists $init{tar}) {
    print "my (%gid, %group);\n";
    print "while (my (\$name, \$pw, \$gid) = getgrent) {\n";
    print '    $gid{$name} = $gid{$gid} = $gid;', "\n"
        if exists $init{group};
    print '    $group{$gid} = $name unless exists $group{$gid};', "\n"
        if exists $init{ls} || exists $init{tar};
d287 1
a287 6
print $initnewer, "\n" if $initnewer ne '';
print $initfile, "\n" if $initfile ne '';
$flushall .= "exit;\n";
if (exists $init{declarestat}) {
    $out = <<'END' . $out;
    my ($dev,$ino,$mode,$nlink,$uid,$gid);
d289 1
a289 2
END
}
d291 1
a291 2
if ( $follow_in_effect ) {
$out =~ s/lstat\(\$_\)/lstat(_)/;
d293 2
a294 1
$decl
a295 2
File::Find::$find( {wanted => \\&wanted, follow => 1}, $roots);
$flushall
a296 7
sub wanted {
$out;
}

END
} else {
print <<"END";
d298 1
a298 2
# Traverse desired filesystems
File::Find::$find({wanted => \\&wanted}, $roots);
d300 1
a300 1

a305 1
}
d307 1
a307 1
if (exists $init{doexec}) {
d309 5
a313 10

BEGIN {
    require Cwd;
    my $cwd = Cwd::cwd();
}

sub doexec {
    my $ok = shift;
    for my $word (@@_)
        { $word =~ s#{}#$name#g }
d315 9
a323 9
        my $old = select(STDOUT);
        $| = 1;
        print "@@_";
        select($old);
        return 0 unless <STDIN> =~ /^y/;
    }
    chdir $cwd; #sigh
    system @@_;
    chdir $File::Find::dir;
d330 2
a331 8
if (exists $init{ls}) {
    print <<'INTRO', <<"SUB", <<'END';

sub sizemm {
    my $rdev = shift;
    sprintf("%3d, %3d", ($rdev >> 8) & 0xff, $rdev & 0xff);
}

d333 31
a363 25
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
INTRO
        \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat(_);
SUB
    my $pname = $name;

    $blocks
        or $blocks = int(($size + 1023) / 1024);

    my $perms = $rwx[$mode & 7];
    $mode >>= 3;
    $perms = $rwx[$mode & 7] . $perms;
    $mode >>= 3;
    $perms = $rwx[$mode & 7] . $perms;
    substr($perms, 2, 1) =~ tr/-x/Ss/ if -u _;
    substr($perms, 5, 1) =~ tr/-x/Ss/ if -g _;
    substr($perms, 8, 1) =~ tr/-x/Tt/ if -k _;
    if    (-f _) { $perms = '-' . $perms; }
    elsif (-d _) { $perms = 'd' . $perms; }
    elsif (-l _) { $perms = 'l' . $perms; $pname .= ' -> ' . readlink($_); }
    elsif (-c _) { $perms = 'c' . $perms; $size = sizemm($rdev); }
    elsif (-b _) { $perms = 'b' . $perms; $size = sizemm($rdev); }
    elsif (-p _) { $perms = 'p' . $perms; }
    elsif (-S _) { $perms = 's' . $perms; }
    else         { $perms = '?' . $perms; }
d365 2
a366 2
    my $user = $user{$uid} || $uid;
    my $group = $group{$gid} || $gid;
d368 2
a369 1
    my ($sec,$min,$hour,$mday,$mon,$timeyear) = localtime($mtime);
d371 18
a388 17
        $timeyear += 1900;
    } else {
        $timeyear = sprintf("%02d:%02d", $hour, $min);
    }

    printf "%5lu %4ld %-10s %3d %-8s %-8s %8s %s %2d %5s %s\n",
            $ino,
                 $blocks,
                      $perms,
                            $nlink,
                                $user,
                                     $group,
                                          $size,
                                              $moname[$mon],
                                                 $mday,
                                                     $timeyear,
                                                         $pname;
d392 2
a393 18
END
}


if (exists $init{cpio} || exists $init{tar}) {
print <<'END';

my %blocks = ();

sub flush {
    my ($fh, $varref, $blksz) = @@_;

    while (length($$varref) >= $blksz) {
        no strict qw/refs/;
        syswrite($fh, $$varref, $blksz);
        substr($$varref, 0, $blksz) = '';
        ++$blocks{$fh};
    }
d399 5
d405 19
a423 31
if (exists $init{cpio}) {
    print <<'INTRO', <<"SUB", <<'END';

my %cpout = ();
my %nc = ();

sub cpio {
    my ($fh, $fname, $nc) = @@_;
    my $text = '';
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
        $atime,$mtime,$ctime,$blksize,$blocks);
    local (*IN);

    if ( ! defined $fname ) {
        $fname = 'TRAILER!!!';
        ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
          $atime,$mtime,$ctime,$blksize,$blocks) = (0) x 13;
    } else {
        ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
INTRO
          \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat(_);
SUB
        if (-f _) {
            open(IN, "./$_\0") || do {
                warn "Couldn't open $fname: $!\n";
                return;
            }
        } else {
            $text = readlink($_);
            $size = 0 unless defined $text;
        }
d426 1
a426 1
    $fname =~ s#^\./##;
d429 30
a458 20
        $cpout{$fh} .=
          sprintf("%06o%06o%06o%06o%06o%06o%06o%06o%011lo%06o%011lo%s\0",
            070707,
            $dev & 0777777,
            $ino & 0777777,
            $mode & 0777777,
            $uid & 0777777,
            $gid & 0777777,
            $nlink & 0777777,
            $rdev & 0177777,
            $mtime,
            length($fname)+1,
            $size,
            $fname);
    } else {
        $cpout{$fh} .= "\0" if length($cpout{$fh}) & 1;
        $cpout{$fh} .= pack("SSSSSSSSLSLa*",
            070707, $dev, $ino, $mode, $uid, $gid, $nlink, $rdev, $mtime,
            length($fname)+1, $size,
            $fname . (length($fname) & 1 ? "\0" : "\0\0"));
d460 5
d466 4
a469 11
    if ($text ne '') {
        $cpout{$fh} .= $text;
    } elsif ($size) {
        my $l;
        flush($fh, \$cpout{$fh}, 5120)
            while ($l = length($cpout{$fh})) >= 5120;
        while (sysread(IN, $cpout{$fh}, 5120 - $l, $l)) {
            flush($fh, \$cpout{$fh}, 5120);
            $l = length($cpout{$fh});
        }
        close IN;
d473 7
a479 6
sub cflushall {
    for my $fh (keys %cpout) {
        &cpio($fh, undef, $nc{$fh});
        $cpout{$fh} .= "0" x (5120 - length($cpout{$fh}));
        flush($fh, \$cpout{$fh}, 5120);
        print $blocks{$fh} * 10, " blocks\n";
d486 2
a487 6
if (exists $init{tar}) {
    print <<'INTRO', <<"SUB", <<'END';

my %tarout = ();
my %linkseen = ();

d489 9
a497 10
    my ($fh, $fname) = @@_;
    my $prefix = '';
    my $typeflag = '0';
    my $linkname;
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
INTRO
        \$atime,\$mtime,\$ctime,\$blksize,\$blocks) = $stat(_);
SUB
    local (*IN);

d499 34
a532 58
        if ($linkname = $linkseen{$fh, $dev, $ino}) {
            if (length($linkname) > 100) {
                warn "$0: omitting file with linkname ",
                     "too long for tar output: $linkname\n";
                return;
            }
            $typeflag = '1';
            $size = 0;
        } else {
            $linkseen{$fh, $dev, $ino} = $fname;
        }
    }
    if ($typeflag eq '0') {
        if (-f _) {
            open(IN, "./$_\0") || do {
                warn "Couldn't open $fname: $!\n";
                return;
            }
        } else {
            $linkname = readlink($_);
            if (defined $linkname) { $typeflag = '2' }
            elsif (-c _) { $typeflag = '3' }
            elsif (-b _) { $typeflag = '4' }
            elsif (-d _) { $typeflag = '5' }
            elsif (-p _) { $typeflag = '6' }
        }
    }

    if (length($fname) > 100) {
        ($prefix, $fname) = ($fname =~ m#\A(.*?)/(.{,100})\Z(?!\n)#);
        if (!defined($fname) || length($prefix) > 155) {
            warn "$0: omitting file with name too long for tar output: ",
                 $fname, "\n";
            return;
        }
    }

    $size = 0 if $typeflag ne '0';
    my $header = pack("a100a8a8a8a12a12a8a1a100a6a2a32a32a8a8a155",
                        $fname,
                        sprintf("%7o ", $mode &    0777),
                        sprintf("%7o ", $uid  & 0777777),
                        sprintf("%7o ", $gid  & 0777777),
                        sprintf("%11o ", $size),
                        sprintf("%11o ", $mtime),
                        ' 'x8,
                        $typeflag,
                        defined $linkname ? $linkname : '',
                        "ustar\0",
                        "00",
                        $user{$uid},
                        $group{$gid},
                        ($rdev >> 8) & 0xff,
                        $rdev & 0xff,
                        $prefix,
                     );
    substr($header, 148, 8) = sprintf("%7o ", unpack("%16C*", $header));
    my $l = length($header) % 512;
a534 1

d536 18
a553 9
        flush($fh, \$tarout{$fh}, 10240)
            while ($l = length($tarout{$fh})) >= 10240;
        while (sysread(IN, $tarout{$fh}, 10240 - $l, $l)) {
            my $slop = length($tarout{$fh}) % 512;
            $tarout{$fh} .= "\0" x (512 - $slop) if $slop;
            flush($fh, \$tarout{$fh}, 10240);
            $l = length($tarout{$fh});
        }
        close IN;
d558 7
a564 6
    my $len;
    for my $fh (keys %tarout) {
        $len = 10240 - length($tarout{$fh});
        $len += 10240 if $len < 1024;
        $tarout{$fh} .= "\0" x $len;
        flush($fh, \$tarout{$fh}, 10240);
d576 1
a576 1
    my $tabstring;
d578 1
a578 1
    $tabstring = "\t" x ($indent_depth/2) . ' ' x ($indent_depth%2 * 4);
d580 16
a595 13
        if ($_ =~ /^(?:name|print|prune|exec|ok|\(|\))/) {
            $init{delayedstat} = 1;
        } else {
            my $statcall = '(($dev,$ino,$mode,$nlink,$uid,$gid) = '
                         . $stat . '($_))';
            if (exists $init{saw_or}) {
                $tabstring .= "(\$nlink || $statcall) &&\n" . $tabstring;
            } else {
                $tabstring .= "$statcall &&\n" . $tabstring;
            }
            $statdone = 1;
            $init{declarestat} = 1;
        }
d602 5
a606 4
    my $x = shift;
    $x =~ s#([./^\$()])#\\$1#g;
    $x =~ s#([?*])#.$1#g;
    "^$x\\z";
d610 2
a611 1
    my ($pre, $n) = @@_;
d614 1
a614 1
    "($pre $n)";
d618 2
a619 2
    my $string = shift;
    $string =~ s/'/\\'/g;
a621 198

__END__

=head1 NAME

find2perl - translate find command lines to Perl code

=head1 SYNOPSIS

	find2perl [paths] [predicates] | perl

=head1 DESCRIPTION

find2perl is a little translator to convert find command lines to
equivalent Perl code.  The resulting code is typically faster than
running find itself.

"paths" are a set of paths where find2perl will start its searches and
"predicates" are taken from the following list.

=over 4

=item C<! PREDICATE>

Negate the sense of the following predicate.  The C<!> must be passed as
a distinct argument, so it may need to be surrounded by whitespace and/or
quoted from interpretation by the shell using a backslash (just as with
using C<find(1)>).

=item C<( PREDICATES )>

Group the given PREDICATES.  The parentheses must be passed as distinct
arguments, so they may need to be surrounded by whitespace and/or
quoted from interpretation by the shell using a backslash (just as with
using C<find(1)>).

=item C<PREDICATE1 PREDICATE2>

True if _both_ PREDICATE1 and PREDICATE2 are true; PREDICATE2 is not
evaluated if PREDICATE1 is false.

=item C<PREDICATE1 -o PREDICATE2>

True if either one of PREDICATE1 or PREDICATE2 is true; PREDICATE2 is
not evaluated if PREDICATE1 is true.

=item C<-follow>

Follow (dereference) symlinks.  The checking of file attributes depends
on the position of the C<-follow> option. If it precedes the file
check option, an C<stat> is done which means the file check applies to the
file the symbolic link is pointing to. If C<-follow> option follows the
file check option, this now applies to the symbolic link itself, i.e.
an C<lstat> is done.

=item C<-depth>

Change directory traversal algorithm from breadth-first to depth-first.

=item C<-prune>

Do not descend into the directory currently matched.

=item C<-xdev>

Do not traverse mount points (prunes search at mount-point directories).

=item C<-name GLOB>

File name matches specified GLOB wildcard pattern.  GLOB may need to be
quoted to avoid interpretation by the shell (just as with using
C<find(1)>).

=item C<-perm PERM>

Low-order 9 bits of permission match octal value PERM.

=item C<-perm -PERM>

The bits specified in PERM are all set in file's permissions.

=item C<-type X>

The file's type matches perl's C<-X> operator.

=item C<-fstype TYPE>

Filesystem of current path is of type TYPE (only NFS/non-NFS distinction
is implemented).

=item C<-user USER>

True if USER is owner of file.

=item C<-group GROUP>

True if file's group is GROUP.

=item C<-nouser>

True if file's owner is not in password database.

=item C<-nogroup>

True if file's group is not in group database.

=item C<-inum INUM>

True file's inode number is INUM.

=item C<-links N>

True if (hard) link count of file matches N (see below).

=item C<-size N>

True if file's size matches N (see below) N is normally counted in
512-byte blocks, but a suffix of "c" specifies that size should be
counted in characters (bytes) and a suffix of "k" specifes that
size should be counted in 1024-byte blocks.

=item C<-atime N>

True if last-access time of file matches N (measured in days) (see
below).

=item C<-ctime N>

True if last-changed time of file's inode matches N (measured in days,
see below).

=item C<-mtime N>

True if last-modified time of file matches N (measured in days, see below).

=item C<-newer FILE>

True if last-modified time of file matches N.

=item C<-print>

Print out path of file (always true).

=item C<-print0>

Like -print, but terminates with \0 instead of \n.

=item C<-exec OPTIONS ;>

exec() the arguments in OPTIONS in a subprocess; any occurence of {} in
OPTIONS will first be substituted with the path of the current
file.  Note that the command "rm" has been special-cased to use perl's
unlink() function instead (as an optimization).  The C<;> must be passed as
a distinct argument, so it may need to be surrounded by whitespace and/or
quoted from interpretation by the shell using a backslash (just as with
using C<find(1)>).

=item C<-ok OPTIONS ;>

Like -exec, but first prompts user; if user's response does not begin
with a y, skip the exec.  The C<;> must be passed as
a distinct argument, so it may need to be surrounded by whitespace and/or
quoted from interpretation by the shell using a backslash (just as with
using C<find(1)>).

=item C<-eval EXPR>

Has the perl script eval() the EXPR.  

=item C<-ls>

Simulates C<-exec ls -dils {} ;>

=item C<-tar FILE>

Adds current output to tar-format FILE.

=item C<-cpio FILE>

Adds current output to old-style cpio-format FILE.

=item C<-ncpio FILE>

Adds current output to "new"-style cpio-format FILE.

=back

Predicates which take a numeric argument N can come in three forms:

   * N is prefixed with a +: match values greater than N
   * N is prefixed with a -: match values less than N
   * N is not prefixed with either + or -: match only values equal to N

=head1 SEE ALSO

find

=cut
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d32 1
a32 3
(my \$perlpath = <<'/../') =~ s/\\s*\\z//;
$Config{perlpath}
/../
a39 1
use File::Spec::Functions 'curdir';
d60 1
a60 1
@@roots = (curdir()) unless @@roots;
d336 4
a339 2
use Cwd ();
my $cwd = Cwd::cwd();
a676 1
    $string =~ s/\\/\\\\/g;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a58 5
sub tab ();
sub n ($$);
sub fileglob_to_re ($);
sub quote ($);

d64 1
a64 1
for (@@roots) { $_ = quote($_) }
a74 1
my $declaresubs = "sub wanted;\n";
d82 1
a82 1
        $out .= tab . "(\n";
d87 1
a87 1
        $out .= tab . ")";
d93 1
a93 1
        $out .= tab . "!";
d96 1
a96 1
        $out .= tab . '/' . fileglob_to_re(shift) . "/s";
d101 1
a101 1
        $out .= tab;
d111 1
a111 1
        $out .= tab . "-$filetest _";
d113 1
a113 1
        $out .= tab . 'print("$name\n")';
d115 1
a115 1
        $out .= tab . 'print("$name\0")';
d118 1
a118 1
        $out .= tab;
d126 1
a126 1
        $out .= tab . "(\$uid == \$uid{'$uname'})";
d130 1
a130 1
        $out .= tab . "(\$gid == \$gid{'$gname'})";
d133 1
a133 1
        $out .= tab . '!exists $uid{$uid}';
d136 1
a136 1
        $out .= tab . '!exists $gid{$gid}';
d139 1
a139 1
        $out .= tab . n('$nlink', shift);
d141 1
a141 1
        $out .= tab . n('$ino', shift);
d150 1
a150 1
        $out .= tab . n($n, $_);
d152 1
a152 1
        $out .= tab . n('int(-A _)', shift);
d154 1
a154 1
        $out .= tab . n('int(-M _)', shift);
d156 1
a156 1
        $out .= tab . n('int(-C _)', shift);
d162 1
a162 1
        $out .= tab;
d176 1
a176 2
            { local $" = "','"; $out .= "doexec(0, '@@cmd')"; }
            $declaresubs .= "sub doexec (\$\@@);\n";
d184 1
a184 1
        $out .= tab;
d187 1
a187 2
        { local $" = "','"; $out .= "doexec(0, '@@cmd')"; }
        $declaresubs .= "sub doexec (\$\@@);\n";
d190 1
a190 1
        $out .= tab . '($File::Find::prune = 1)';
d192 1
a192 1
        $out .= tab . '!($File::Find::prune |= ($dev != $File::Find::topdev))'
d199 2
a200 2
        $out .= tab . "(-M _ < $newername)";
        $initnewer .= "my $newername = -M " . quote($file) . ";\n";
d204 1
a204 1
        $out .= tab . "eval {$prog}";
d209 1
a209 2
        $out .= tab . "ls";
        $declaresubs .= "sub ls ();\n";
d216 3
a218 4
        $out .= tab . "tar(*$fh, \$name)";
        $flushall .= "tflushall;\n";
        $declaresubs .= "sub tar;\nsub tflushall ();\n";
        $initfile .= "open($fh, " . quote('> ' . $file) .
d226 1
a226 1
        $out .= tab . "cpio(*$fh, \$name, '$1')";
d228 2
a229 3
        $flushall .= "cflushall;\n";
        $declaresubs .= "sub cpio;\nsub cflushall ();\n";
        $initfile .= "open($fh, " . quote('> ' . $file) .
d238 1
a238 1
            { local($statdone) = 1; $out .= "\n" . tab . "||\n"; }
d268 1
a268 1
$declaresubs
a269 1
END
d342 1
a342 1
sub doexec ($@@) {
d344 1
a344 2
    my @@command = @@_; # copy so we don't try to s/// aliases to constants
    for my $word (@@command)
d349 1
a349 1
        print "@@command";
d354 1
a354 1
    system @@command;
d370 1
a370 1
sub ls () {
d518 1
a518 1
sub cflushall () {
d520 1
a520 1
        cpio($fh, undef, $nc{$fh});
d622 1
a622 1
sub tflushall () {
d639 1
a639 1
sub tab () {
d662 1
a662 1
sub fileglob_to_re ($) {
d664 1
a664 1
    $x =~ s#([./^\$()+])#\\$1#g;
d669 1
a669 1
sub n ($$) {
d676 1
a676 1
sub quote ($) {
d831 1
a831 1
exec() the arguments in OPTIONS in a subprocess; any occurrence of {} in
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d194 1
a194 1
        { local $" = "','"; $out .= "doexec(1, '@@cmd')"; }
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a82 1
my $print_needed = 1;
a119 1
	$print_needed = 0;
a121 1
	$print_needed = 0;
a185 1
	$print_needed = 0;
a196 1
	$print_needed = 0;
a219 1
	$print_needed = 0;
a260 4
if ($print_needed) {
    $out .= "\n" . tab . '&& print("$name\n")';
}

d836 1
a836 3
Print out path of file (always true). If none of C<-exec>, C<-ls>,
C<-print0>, or C<-ok> is specified, then C<-print> will be added
implicitly.
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@a217 1
	$print_needed = 0;
d268 1
a268 3
    my $t = tab;
    if ($t !~ /&&\s*$/) { $t .= '&& ' }
    $out .= "\n" . $t . 'print("$name\n")';
a292 8
if (exists $init{doexec}) {
    print <<'END';
use Cwd ();
my $cwd = Cwd::cwd();

END
}  

d360 3
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d102 2
a103 4
    } elsif (/^(i)?name$/) {
        $out .= tab . '/' . fileglob_to_re(shift) . "/s$1";
    } elsif (/^(i)?path$/) {
        $out .= tab . '$File::Find::name =~ /' . fileglob_to_re(shift) . "/s$1";
a784 12

=item C<-iname GLOB>

Like C<-name>, but the match is case insensitive.

=item C<-path GLOB>

Path name matches specified GLOB wildcard pattern.

=item C<-ipath GLOB>

Like C<-path>, but the match is case insensitive.
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d845 1
a845 1
counted in characters (bytes) and a suffix of "k" specifies that
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d45 14
d924 1
a924 1
find, File::Find.
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d684 1
a684 2
    $x =~ s#\*#.*#g;
    $x =~ s#\?#.#g;
@


