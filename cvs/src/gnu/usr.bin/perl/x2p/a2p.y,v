head	1.11;
access;
symbols
	OPENBSD_6_0:1.11.0.26
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.20
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.22
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.11.0.14
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.11.0.18
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.16
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.12
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.11
date	2010.09.24.15.07.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.23;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.09.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.07.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.34;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.34;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.42.24;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.11.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.21;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.14;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.39;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.49;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.18.31;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.50.02;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@%{
/* $RCSfile: a2p.y,v $$Revision: 4.1 $$Date: 92/08/07 18:29:12 $
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1996, 1997, 1999, 2000,
 *    by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * $Log:	a2p.y,v $
 */

#include "INTERN.h"
#include "a2p.h"

int root;
int begins = Nullop;
int ends = Nullop;

%}
%token BEGIN END
%token REGEX
%token SEMINEW NEWLINE COMMENT
%token FUN1 FUNN GRGR
%token PRINT PRINTF SPRINTF_OLD SPRINTF_NEW SPLIT
%token IF ELSE WHILE FOR IN
%token EXIT NEXT BREAK CONTINUE RET
%token GETLINE DO SUB GSUB MATCH
%token FUNCTION USERFUN DELETE

%right ASGNOP
%right '?' ':'
%left OROR
%left ANDAND
%left IN
%left NUMBER VAR SUBSTR INDEX
%left MATCHOP
%left RELOP '<' '>'
%left OR
%left STRING
%left '+' '-'
%left '*' '/' '%'
%right UMINUS
%left NOT
%right '^'
%left INCR DECR
%left FIELD VFIELD SVFIELD

%%

program	: junk hunks
		{ root = oper4(OPROG,$1,begins,$2,ends); }
	;

begin	: BEGIN '{' maybe states '}' junk
		{ begins = oper4(OJUNK,begins,$3,$4,$6); in_begin = FALSE;
		    $$ = Nullop; }
	;

end	: END '{' maybe states '}'
		{ ends = oper3(OJUNK,ends,$3,$4); $$ = Nullop; }
	| end NEWLINE
		{ $$ = $1; }
	;

hunks	: hunks hunk junk
		{ $$ = oper3(OHUNKS,$1,$2,$3); }
	| /* NULL */
		{ $$ = Nullop; }
	;

hunk	: patpat
		{ $$ = oper1(OHUNK,$1); need_entire = TRUE; }
	| patpat '{' maybe states '}'
		{ $$ = oper2(OHUNK,$1,oper2(OJUNK,$3,$4)); }
	| FUNCTION USERFUN '(' arg_list ')' maybe '{' maybe states '}'
		{ fixfargs($2,$4,0); $$ = oper5(OUSERDEF,$2,$4,$6,$8,$9); }
	| '{' maybe states '}'
		{ $$ = oper2(OHUNK,Nullop,oper2(OJUNK,$2,$3)); }
	| begin
	| end
	;

arg_list: expr_list
		{ $$ = rememberargs($$); }
	;

patpat	: cond
		{ $$ = oper1(OPAT,$1); }
	| cond ',' cond
		{ $$ = oper2(ORANGE,$1,$3); }
	;

cond	: expr
	| match
	| rel
	| compound_cond
	| cond '?' expr ':' expr
		{ $$ = oper3(OCOND,$1,$3,$5); }
	;

compound_cond
	: '(' compound_cond ')'
		{ $$ = oper1(OCPAREN,$2); }
	| cond ANDAND maybe cond
		{ $$ = oper3(OCANDAND,$1,$3,$4); }
	| cond OROR maybe cond
		{ $$ = oper3(OCOROR,$1,$3,$4); }
	| NOT cond
		{ $$ = oper1(OCNOT,$2); }
	;

rel	: expr RELOP expr
		{ $$ = oper3(ORELOP,$2,$1,$3); }
	| expr '>' expr
		{ $$ = oper3(ORELOP,string(">",1),$1,$3); }
	| expr '<' expr
		{ $$ = oper3(ORELOP,string("<",1),$1,$3); }
	| '(' rel ')'
		{ $$ = oper1(ORPAREN,$2); }
	;

match	: expr MATCHOP expr
		{ $$ = oper3(OMATCHOP,$2,$1,$3); }
	| expr MATCHOP REGEX
		{ $$ = oper3(OMATCHOP,$2,$1,oper1(OREGEX,$3)); }
	| REGEX		%prec MATCHOP
		{ $$ = oper1(OREGEX,$1); }
	| '(' match ')'
		{ $$ = oper1(OMPAREN,$2); }
	;

expr	: term
		{ $$ = $1; }
	| expr term
		{ $$ = oper2(OCONCAT,$1,$2); }
	| expr '?' expr ':' expr
		{ $$ = oper3(OCOND,$1,$3,$5); }
	| variable ASGNOP cond
		{
		    $$ = oper3(OASSIGN,$2,$1,$3);
		    if ((ops[$1].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$1].ival & 255) == OVFLD)
			lval_field = TRUE;
		}
	;

sprintf	: SPRINTF_NEW
	| SPRINTF_OLD ;

term	: variable
		{ $$ = $1; }
	| NUMBER
		{ $$ = oper1(ONUM,$1); }
	| STRING
		{ $$ = oper1(OSTR,$1); }
	| term '+' term
		{ $$ = oper2(OADD,$1,$3); }
	| term '-' term
		{ $$ = oper2(OSUBTRACT,$1,$3); }
	| term '*' term
		{ $$ = oper2(OMULT,$1,$3); }
	| term '/' term
		{ $$ = oper2(ODIV,$1,$3); }
	| term '%' term
		{ $$ = oper2(OMOD,$1,$3); }
	| term '^' term
		{ $$ = oper2(OPOW,$1,$3); }
	| term IN VAR
		{ $$ = oper2(ODEFINED,aryrefarg($3),$1); }
	| variable INCR
		{
		    $$ = oper1(OPOSTINCR,$1);
		    if ((ops[$1].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$1].ival & 255) == OVFLD)
			lval_field = TRUE;
		}
	| variable DECR
		{
		    $$ = oper1(OPOSTDECR,$1);
		    if ((ops[$1].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$1].ival & 255) == OVFLD)
			lval_field = TRUE;
		}
	| INCR variable
		{
		    $$ = oper1(OPREINCR,$2);
		    if ((ops[$2].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$2].ival & 255) == OVFLD)
			lval_field = TRUE;
		}
	| DECR variable
		{
		    $$ = oper1(OPREDECR,$2);
		    if ((ops[$2].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$2].ival & 255) == OVFLD)
			lval_field = TRUE;
		}
	| '-' term %prec UMINUS
		{ $$ = oper1(OUMINUS,$2); }
	| '+' term %prec UMINUS
		{ $$ = oper1(OUPLUS,$2); }
	| '(' cond ')'
		{ $$ = oper1(OPAREN,$2); }
	| GETLINE
		{ $$ = oper0(OGETLINE); }
	| GETLINE variable
		{ $$ = oper1(OGETLINE,$2); }
	| GETLINE '<' expr
		{ $$ = oper3(OGETLINE,Nullop,string("<",1),$3);
		    if (ops[$3].ival != OSTR + (1<<8)) do_fancy_opens = TRUE; }
	| GETLINE variable '<' expr
		{ $$ = oper3(OGETLINE,$2,string("<",1),$4);
		    if (ops[$4].ival != OSTR + (1<<8)) do_fancy_opens = TRUE; }
	| term 'p' GETLINE
		{ $$ = oper3(OGETLINE,Nullop,string("|",1),$1);
		    if (ops[$1].ival != OSTR + (1<<8)) do_fancy_opens = TRUE; }
	| term 'p' GETLINE variable
		{ $$ = oper3(OGETLINE,$4,string("|",1),$1);
		    if (ops[$1].ival != OSTR + (1<<8)) do_fancy_opens = TRUE; }
	| FUN1
		{ $$ = oper0($1); need_entire = do_chop = TRUE; }
	| FUN1 '(' ')'
		{ $$ = oper1($1,Nullop); need_entire = do_chop = TRUE; }
	| FUN1 '(' expr ')'
		{ $$ = oper1($1,$3); }
	| FUNN '(' expr_list ')'
		{ $$ = oper1($1,$3); }
	| USERFUN '(' expr_list ')'
		{ $$ = oper2(OUSERFUN,$1,$3); }
	| SPRINTF_NEW '(' expr_list ')'
		{ $$ = oper1(OSPRINTF,$3); }
	| sprintf expr_list
		{ $$ = oper1(OSPRINTF,$2); }
	| SUBSTR '(' expr ',' expr ',' expr ')'
		{ $$ = oper3(OSUBSTR,$3,$5,$7); }
	| SUBSTR '(' expr ',' expr ')'
		{ $$ = oper2(OSUBSTR,$3,$5); }
	| SPLIT '(' expr ',' VAR ',' expr ')'
		{ $$ = oper3(OSPLIT,$3,aryrefarg(numary($5)),$7); }
	| SPLIT '(' expr ',' VAR ',' REGEX ')'
		{ $$ = oper3(OSPLIT,$3,aryrefarg(numary($5)),oper1(OREGEX,$7));}
	| SPLIT '(' expr ',' VAR ')'
		{ $$ = oper2(OSPLIT,$3,aryrefarg(numary($5))); }
	| INDEX '(' expr ',' expr ')'
		{ $$ = oper2(OINDEX,$3,$5); }
	| MATCH '(' expr ',' REGEX ')'
		{ $$ = oper2(OMATCH,$3,oper1(OREGEX,$5)); }
	| MATCH '(' expr ',' expr ')'
		{ $$ = oper2(OMATCH,$3,$5); }
	| SUB '(' expr ',' expr ')'
		{ $$ = oper2(OSUB,$3,$5); }
	| SUB '(' REGEX ',' expr ')'
		{ $$ = oper2(OSUB,oper1(OREGEX,$3),$5); }
	| GSUB '(' expr ',' expr ')'
		{ $$ = oper2(OGSUB,$3,$5); }
	| GSUB '(' REGEX ',' expr ')'
		{ $$ = oper2(OGSUB,oper1(OREGEX,$3),$5); }
	| SUB '(' expr ',' expr ',' expr ')'
		{ $$ = oper3(OSUB,$3,$5,$7); }
	| SUB '(' REGEX ',' expr ',' expr ')'
		{ $$ = oper3(OSUB,oper1(OREGEX,$3),$5,$7); }
	| GSUB '(' expr ',' expr ',' expr ')'
		{ $$ = oper3(OGSUB,$3,$5,$7); }
	| GSUB '(' REGEX ',' expr ',' expr ')'
		{ $$ = oper3(OGSUB,oper1(OREGEX,$3),$5,$7); }
	;

variable: VAR
		{ $$ = oper1(OVAR,$1); }
	| VAR '[' expr_list ']'
		{ $$ = oper2(OVAR,aryrefarg($1),$3); }
	| FIELD
		{ $$ = oper1(OFLD,$1); }
	| SVFIELD
		{ $$ = oper1(OVFLD,oper1(OVAR,$1)); }
	| VFIELD term
		{ $$ = oper1(OVFLD,$2); }
	;

expr_list
	: expr
	| clist
	| /* NULL */
		{ $$ = Nullop; }
	;

clist	: expr ',' maybe expr
		{ $$ = oper3(OCOMMA,$1,$3,$4); }
	| clist ',' maybe expr
		{ $$ = oper3(OCOMMA,$1,$3,$4); }
	| '(' clist ')'		/* these parens are invisible */
		{ $$ = $2; }
	;

junk	: junk hunksep
		{ $$ = oper2(OJUNK,$1,$2); }
	| /* NULL */
		{ $$ = Nullop; }
	;

hunksep : ';'
		{ $$ = oper2(OJUNK,oper0(OSEMICOLON),oper0(ONEWLINE)); }
	| SEMINEW
		{ $$ = oper2(OJUNK,oper0(OSEMICOLON),oper0(ONEWLINE)); }
	| NEWLINE
		{ $$ = oper0(ONEWLINE); }
	| COMMENT
		{ $$ = oper1(OCOMMENT,$1); }
	;

maybe	: maybe nlstuff
		{ $$ = oper2(OJUNK,$1,$2); }
	| /* NULL */
		{ $$ = Nullop; }
	;

nlstuff : NEWLINE
		{ $$ = oper0(ONEWLINE); }
	| COMMENT
		{ $$ = oper1(OCOMMENT,$1); }
	;

separator
	: ';' maybe
		{ $$ = oper2(OJUNK,oper0(OSEMICOLON),$2); }
	| SEMINEW maybe
		{ $$ = oper2(OJUNK,oper0(OSNEWLINE),$2); }
	| NEWLINE maybe
		{ $$ = oper2(OJUNK,oper0(OSNEWLINE),$2); }
	| COMMENT maybe
		{ $$ = oper2(OJUNK,oper1(OSCOMMENT,$1),$2); }
	;

states	: states statement
		{ $$ = oper2(OSTATES,$1,$2); }
	| /* NULL */
		{ $$ = Nullop; }
	;

statement
	: simple separator maybe
		{ $$ = oper2(OJUNK,oper2(OSTATE,$1,$2),$3); }
	| ';' maybe
		{ $$ = oper2(OSTATE,Nullop,oper2(OJUNK,oper0(OSEMICOLON),$2)); }
	| SEMINEW maybe
		{ $$ = oper2(OSTATE,Nullop,oper2(OJUNK,oper0(OSNEWLINE),$2)); }
	| compound
	;

simpnull: simple
	| /* NULL */
		{ $$ = Nullop; }
	;

simple
	: expr
	| PRINT expr_list redir expr
		{ $$ = oper3(OPRINT,$2,$3,$4);
		    do_opens = TRUE;
		    saw_ORS = saw_OFS = TRUE;
		    if (!$2) need_entire = TRUE;
		    if (ops[$4].ival != OSTR + (1<<8)) do_fancy_opens = TRUE; }
	| PRINT expr_list
		{ $$ = oper1(OPRINT,$2);
		    if (!$2) need_entire = TRUE;
		    saw_ORS = saw_OFS = TRUE;
		}
	| PRINTF expr_list redir expr
		{ $$ = oper3(OPRINTF,$2,$3,$4);
		    do_opens = TRUE;
		    if (!$2) need_entire = TRUE;
		    if (ops[$4].ival != OSTR + (1<<8)) do_fancy_opens = TRUE; }
	| PRINTF expr_list
		{ $$ = oper1(OPRINTF,$2);
		    if (!$2) need_entire = TRUE;
		}
	| BREAK
		{ $$ = oper0(OBREAK); }
	| NEXT
		{ $$ = oper0(ONEXT); }
	| EXIT
		{ $$ = oper0(OEXIT); }
	| EXIT expr
		{ $$ = oper1(OEXIT,$2); }
	| CONTINUE
		{ $$ = oper0(OCONTINUE); }
	| RET
		{ $$ = oper0(ORETURN); }
	| RET expr
		{ $$ = oper1(ORETURN,$2); }
	| DELETE VAR '[' expr_list ']'
		{ $$ = oper2(ODELETE,aryrefarg($2),$4); }
	;

redir	: '>'	%prec FIELD
		{ $$ = oper1(OREDIR,string(">",1)); }
	| GRGR
		{ $$ = oper1(OREDIR,string(">>",2)); }
	| '|'
		{ $$ = oper1(OREDIR,string("|",1)); }
	;

compound
	: IF '(' cond ')' maybe statement
		{ $$ = oper2(OIF,$3,bl($6,$5)); }
	| IF '(' cond ')' maybe statement ELSE maybe statement
		{ $$ = oper3(OIF,$3,bl($6,$5),bl($9,$8)); }
	| WHILE '(' cond ')' maybe statement
		{ $$ = oper2(OWHILE,$3,bl($6,$5)); }
	| DO maybe statement WHILE '(' cond ')'
		{ $$ = oper2(ODO,bl($3,$2),$6); }
	| FOR '(' simpnull ';' cond ';' simpnull ')' maybe statement
		{ $$ = oper4(OFOR,$3,$5,$7,bl($10,$9)); }
	| FOR '(' simpnull ';'  ';' simpnull ')' maybe statement
		{ $$ = oper4(OFOR,$3,string("",0),$6,bl($9,$8)); }
	| FOR '(' expr ')' maybe statement
		{ $$ = oper2(OFORIN,$3,bl($6,$5)); }
	| '{' maybe states '}' maybe
		{ $$ = oper3(OBLOCK,oper2(OJUNK,$2,$3),Nullop,$5); }
	;

%%

int yyparse (void);

#include "a2py.c"
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.8
log
@merge in perl 5.8.8
@
text
@d2 1
a2 1
/* $RCSfile: a2p.y,v $$Revision: 1.7 $$Date: 2003/12/03 03:02:53 $
d10 1
a10 4
 * $Log: a2p.y,v $
 * Revision 1.7  2003/12/03 03:02:53  millert
 * Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
 *
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d2 1
a2 1
/* $RCSfile: a2p.y,v $$Revision: 4.1 $$Date: 92/08/07 18:29:12 $
d10 4
a13 1
 * $Log:	a2p.y,v $
d50 1
a50 1
%left FIELD VFIELD
d143 6
a148 5
		{ $$ = oper3(OASSIGN,$2,$1,$3);
			if ((ops[$1].ival & 255) == OFLD)
			    lval_field = TRUE;
			if ((ops[$1].ival & 255) == OVFLD)
			    lval_field = TRUE;
d176 7
a182 1
		{ $$ = oper1(OPOSTINCR,$1); }
d184 7
a190 1
		{ $$ = oper1(OPOSTDECR,$1); }
d192 7
a198 1
		{ $$ = oper1(OPREINCR,$2); }
d200 7
a206 1
		{ $$ = oper1(OPREDECR,$2); }
d283 2
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d4 2
a5 1
 *    Copyright (c) 1991-2002, Larry Wall
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d4 1
a4 1
 *    Copyright (c) 1991-2001, Larry Wall
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d4 1
a4 1
 *    Copyright (c) 1991-1997, Larry Wall
@


1.3
log
@perl5.005_03 (stock)
@
text
@d24 1
a24 1
%token PRINT PRINTF SPRINTF SPLIT
d147 3
d210 3
a212 1
	| SPRINTF expr_list
d402 1
a402 1
int yyparse _((void));
@


1.2
log
@perl 5.004_04
@
text
@@


1.1
log
@Initial revision
@
text
@d4 1
a4 1
 *    Copyright (c) 1991, Larry Wall
d136 2
a166 2
	| cond '?' expr ':' expr
		{ $$ = oper3(OCOND,$1,$3,$5); }
d396 3
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d4 1
a4 1
 *    Copyright (c) 1991-1997, Larry Wall
a135 2
	| expr '?' expr ':' expr
		{ $$ = oper3(OCOND,$1,$3,$5); }
d165 2
a395 3

int yyparse _((void));

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d24 1
a24 1
%token PRINT PRINTF SPRINTF_OLD SPRINTF_NEW SPLIT
a146 3
sprintf	: SPRINTF_NEW
	| SPRINTF_OLD ;

d207 1
a207 3
	| SPRINTF_NEW '(' expr_list ')'
		{ $$ = oper1(OSPRINTF,$3); }
	| sprintf expr_list
d397 1
a397 1
int yyparse (void);
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d4 1
a4 1
 *    Copyright (c) 1991-2001, Larry Wall
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d4 1
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d4 1
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1996, 1997, 1999, 2000,
 *    by Larry Wall and others
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d2 1
a2 1
/* $RCSfile: a2p.y,v $$Revision: 1.7 $$Date: 2003/12/03 03:02:53 $
d10 1
a10 4
 * $Log: a2p.y,v $
 * Revision 1.7  2003/12/03 03:02:53  millert
 * Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
 *
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d2 1
a2 1
/* $RCSfile: a2p.y,v $$Revision: 4.1 $$Date: 92/08/07 18:29:12 $
d10 4
a13 1
 * $Log:	a2p.y,v $
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d47 1
a47 1
%left FIELD VFIELD SVFIELD
d140 5
a144 6
		{
		    $$ = oper3(OASSIGN,$2,$1,$3);
		    if ((ops[$1].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$1].ival & 255) == OVFLD)
			lval_field = TRUE;
d172 1
a172 7
		{
		    $$ = oper1(OPOSTINCR,$1);
		    if ((ops[$1].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$1].ival & 255) == OVFLD)
			lval_field = TRUE;
		}
d174 1
a174 7
		{
		    $$ = oper1(OPOSTDECR,$1);
		    if ((ops[$1].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$1].ival & 255) == OVFLD)
			lval_field = TRUE;
		}
d176 1
a176 7
		{
		    $$ = oper1(OPREINCR,$2);
		    if ((ops[$2].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$2].ival & 255) == OVFLD)
			lval_field = TRUE;
		}
d178 1
a178 7
		{
		    $$ = oper1(OPREDECR,$2);
		    if ((ops[$2].ival & 255) == OFLD)
			lval_field = TRUE;
		    else if ((ops[$2].ival & 255) == OVFLD)
			lval_field = TRUE;
		}
a254 2
	| SVFIELD
		{ $$ = oper1(OVFLD,oper1(OVAR,$1)); }
@


