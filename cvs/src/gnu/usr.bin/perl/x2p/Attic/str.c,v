head	1.15;
access;
symbols
	OPENBSD_6_0:1.14.0.12
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.6
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.8
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.11
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2017.02.05.00.32.22;	author afresh1;	state dead;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2014.07.14.05.54.19;	author guenther;	state Exp;
branches;
next	1.13;
commitid	Ai9ib7HbOcehZqJn;

1.13
date	2014.03.24.15.05.34;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.25.20.41.01;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.25.15.12.01;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.24;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.09.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.59;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.07.09;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.36;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.36;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.42.26;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.26.23;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.14;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.40;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.50;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.18.33;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.50.03;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.41;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.13;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.21;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    str.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
 *    2001, 2002, 2005 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */

#include "EXTERN.h"
#include "a2p.h"
#include "util.h"

void
str_numset(STR *str, double num)
{
    str->str_nval = num;
    str->str_pok = 0;		/* invalidate pointer */
    str->str_nok = 1;		/* validate number */
}

char *
str_2ptr(STR *str)
{
    char *s;

    if (!str)
	return (char *)"";	/* probably safe - won't be written to */
    GROWSTR(&(str->str_ptr), &(str->str_len), 24);
    s = str->str_ptr;
    if (str->str_nok) {
	sprintf(s,"%.20g",str->str_nval);
	while (*s) s++;
    }
    *s = '\0';
    str->str_cur = s - str->str_ptr;
    str->str_pok = 1;
#ifdef DEBUGGING
    if (debug & 32)
	fprintf(stderr,"0x%lx ptr(%s)\n",(unsigned long)str,str->str_ptr);
#endif
    return str->str_ptr;
}

void
str_sset(STR *dstr, STR *sstr)
{
    if (!sstr)
	str_nset(dstr,No,0);
    else if (sstr->str_nok)
	str_numset(dstr,sstr->str_nval);
    else if (sstr->str_pok)
	str_nset(dstr,sstr->str_ptr,sstr->str_cur);
    else
	str_nset(dstr,"",0);
}

void
str_nset(STR *str, const char *ptr, int len)
{
    GROWSTR(&(str->str_ptr), &(str->str_len), len + 1);
    memcpy(str->str_ptr,ptr,len);
    str->str_cur = len;
    *(str->str_ptr+str->str_cur) = '\0';
    str->str_nok = 0;		/* invalidate number */
    str->str_pok = 1;		/* validate pointer */
}

void
str_set(STR *str, const char *ptr)
{
    int len;

    if (!ptr)
	ptr = "";
    len = strlen(ptr);
    GROWSTR(&(str->str_ptr), &(str->str_len), len + 1);
    memcpy(str->str_ptr,ptr,len+1);
    str->str_cur = len;
    str->str_nok = 0;		/* invalidate number */
    str->str_pok = 1;		/* validate pointer */
}

void
str_ncat(STR *str, const char *ptr, int len)
{
    if (!(str->str_pok))
	str_2ptr(str);
    GROWSTR(&(str->str_ptr), &(str->str_len), str->str_cur + len + 1);
    memcpy(str->str_ptr+str->str_cur, ptr, len);
    str->str_cur += len;
    *(str->str_ptr+str->str_cur) = '\0';
    str->str_nok = 0;		/* invalidate number */
    str->str_pok = 1;		/* validate pointer */
}

void
str_scat(STR *dstr, STR *sstr)
{
    if (!(sstr->str_pok))
	str_2ptr(sstr);
    if (sstr)
	str_ncat(dstr,sstr->str_ptr,sstr->str_cur);
}

void
str_cat(STR *str, const char *ptr)
{
    int len;

    if (!ptr)
	return;
    if (!(str->str_pok))
	str_2ptr(str);
    len = strlen(ptr);
    GROWSTR(&(str->str_ptr), &(str->str_len), str->str_cur + len + 1);
    memcpy(str->str_ptr+str->str_cur, ptr, len+1);
    str->str_cur += len;
    str->str_nok = 0;		/* invalidate number */
    str->str_pok = 1;		/* validate pointer */
}

STR *
str_new(int len)
{
    STR *str;
    
    if (freestrroot) {
	str = freestrroot;
	freestrroot = str->str_link.str_next;
    }
    else {
	str = (STR *) safemalloc(sizeof(STR));
	memset((char*)str,0,sizeof(STR));
    }
    if (len)
	GROWSTR(&(str->str_ptr), &(str->str_len), len + 1);
    return str;
}

/* make str point to what nstr did */

void
str_free(STR *str)
{
    if (!str)
	return;
    if (str->str_len)
	str->str_ptr[0] = '\0';
    str->str_cur = 0;
    str->str_nok = 0;
    str->str_pok = 0;
    str->str_link.str_next = freestrroot;
    freestrroot = str;
}

int
str_len(STR *str)
{
    if (!str)
	return 0;
    if (!(str->str_pok))
	str_2ptr(str);
    if (str->str_len)
	return str->str_cur;
    else
	return 0;
}

char *
str_gets(STR *str, FILE *fp)
{
#if defined(USE_STDIO_PTR) && defined(STDIO_PTR_LVALUE) && defined(STDIO_CNT_LVALUE)
    /* Here is some breathtakingly efficient cheating */

    char *bp;		/* we're going to steal some values */
    int cnt;		/*  from the stdio struct and put EVERYTHING */
    STDCHAR *ptr;	/*   in the innermost loop into registers */
    char newline = '\n';	/* (assuming at least 6 registers) */
    int i;
    int bpx;

#if defined(VMS)
    /* An ungetc()d char is handled separately from the regular
     * buffer, so we getc() it back out and stuff it in the buffer.
     */
    i = getc(fp);
    if (i == EOF) return NULL;
    *(--((*fp)->_ptr)) = (unsigned char) i;
    (*fp)->_cnt++;
#endif

    cnt = FILE_cnt(fp);			/* get count into register */
    str->str_nok = 0;			/* invalidate number */
    str->str_pok = 1;			/* validate pointer */
    if (str->str_len <= cnt)		/* make sure we have the room */
	GROWSTR(&(str->str_ptr), &(str->str_len), cnt+1);
    bp = str->str_ptr;			/* move these two too to registers */
    ptr = (STDCHAR*)FILE_ptr(fp);
    for (;;) {
	while (--cnt >= 0) {
	    if ((*bp++ = *ptr++) == newline) {
		if (bp <= str->str_ptr + 1 || bp[-2] != '\\')
		    goto thats_all_folks;
		else {
		    line++;
		    bp -= 2;
		}
	    }
	}
	
	FILE_cnt(fp) = cnt;		/* deregisterize cnt and ptr */
	FILE_ptr(fp) = ptr;
	i = getc(fp);		/* get more characters */
	cnt = FILE_cnt(fp);
	ptr = (STDCHAR*)FILE_ptr(fp);		/* reregisterize cnt and ptr */

	bpx = bp - str->str_ptr;	/* prepare for possible relocation */
	GROWSTR(&(str->str_ptr), &(str->str_len), str->str_cur + cnt + 1);
	bp = str->str_ptr + bpx;	/* reconstitute our pointer */

	if (i == newline) {		/* all done for now? */
	    *bp++ = i;
	    goto thats_all_folks;
	}
	else if (i == EOF)		/* all done for ever? */
	    goto thats_all_folks;
	*bp++ = i;			/* now go back to screaming loop */
    }

thats_all_folks:
    FILE_cnt(fp) = cnt;			/* put these back or we're in trouble */
    FILE_ptr(fp) = ptr;
    *bp = '\0';
    str->str_cur = bp - str->str_ptr;	/* set length */

#else /* USE_STDIO_PTR && STDIO_PTR_LVALUE && STDIO_CNT_LVALUE */
    /* The big, slow, and stupid way */

    static char buf[4192];

    if (fgets(buf, sizeof buf, fp) != NULL)
	str_set(str, buf);
    else
	str_set(str, No);

#endif /* USE_STDIO_PTR && STDIO_PTR_LVALUE && STDIO_CNT_LVALUE */

    return str->str_cur ? str->str_ptr : NULL;
}

STR *
str_make(const char *s)
{
    STR *str = str_new(0);

    str_set(str,s);
    return str;
}

@


1.14
log
@Fix an off-by-one error that's already been accepted upstream
@
text
@@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d203 1
a203 1
		if (bp <= str->str_ptr || bp[-2] != '\\')
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d15 1
a15 1
str_numset(register STR *str, double num)
d23 1
a23 1
str_2ptr(register STR *str)
d25 1
a25 1
    register char *s;
d46 1
a46 1
str_sset(STR *dstr, register STR *sstr)
d59 1
a59 1
str_nset(register STR *str, register const char *ptr, register int len)
d70 1
a70 1
str_set(register STR *str, register const char *ptr)
d72 1
a72 1
    register int len;
d85 1
a85 1
str_ncat(register STR *str, register const char *ptr, register int len)
d98 1
a98 1
str_scat(STR *dstr, register STR *sstr)
d107 1
a107 1
str_cat(register STR *str, register const char *ptr)
d109 1
a109 1
    register int len;
d126 1
a126 1
    register STR *str;
d144 1
a144 1
str_free(register STR *str)
d158 1
a158 1
str_len(register STR *str)
d171 1
a171 1
str_gets(register STR *str, register FILE *fp)
d176 4
a179 4
    register char *bp;		/* we're going to steal some values */
    register int cnt;		/*  from the stdio struct and put EVERYTHING */
    register STDCHAR *ptr;	/*   in the innermost loop into registers */
    register char newline = '\n';	/* (assuming at least 6 registers) */
d213 1
a213 1
	FILE_ptr(fp) = (void*)ptr; /* LHS STDCHAR* cast non-portable */
d233 1
a233 1
    FILE_ptr(fp) = (void*)ptr; /* LHS STDCHAR* cast non-portable */
d255 1
a255 1
    register STR *str = str_new(0);
@


1.11
log
@Use snprintf() not sprintf()
@
text
@d32 1
a32 1
	snprintf(s,str->str_len,"%.20g",str->str_nval);
@


1.10
log
@Merge in perl 5.10.1; part two
@
text
@d32 1
a32 1
	sprintf(s,"%.20g",str->str_nval);
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d28 1
a28 1
	return "";
d59 1
a59 1
str_nset(register STR *str, register char *ptr, register int len)
d70 1
a70 1
str_set(register STR *str, register char *ptr)
d85 1
a85 1
str_ncat(register STR *str, register char *ptr, register int len)
d107 1
a107 1
str_cat(register STR *str, register char *ptr)
d188 1
a188 1
    if (i == EOF) return Nullch;
d242 1
a242 1
    if (fgets(buf, sizeof buf, fp) != Nullch)
d249 1
a249 1
    return str->str_cur ? str->str_ptr : Nullch;
d253 1
a253 1
str_make(char *s)
@


1.8
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2001, 2002, by Larry Wall and others
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d1 1
a1 1
/* $RCSfile: str.c,v $$Revision: 4.1 $$Date: 92/08/07 18:29:26 $
a7 2
 *
 * $Log:	str.c,v $
a44 17
double
str_2num(register STR *str)
{
    if (!str)
	return 0.0;
    if (str->str_len && str->str_pok)
	str->str_nval = atof(str->str_ptr);
    else
	str->str_nval = 0.0;
    str->str_nok = 1;
#ifdef DEBUGGING
    if (debug & 32)
	fprintf(stderr,"0x%lx num(%g)\n",(unsigned long)str,str->str_nval);
#endif
    return str->str_nval;
}

a84 13
str_chop(register STR *str, register char *ptr)	/* like set but assuming ptr is in str */
                  
                   
{
    if (!(str->str_pok))
	str_2ptr(str);
    str->str_cur -= (ptr - str->str_ptr);
    memcpy(str->str_ptr, ptr, str->str_cur + 1);
    str->str_nok = 0;		/* invalidate number */
    str->str_pok = 1;		/* validate pointer */
}

void
a122 35
char *
str_append_till(register STR *str, register char *from, register int delim, char *keeplist)
{
    register char *to;
    register int len;

    if (!from)
	return Nullch;
    len = strlen(from);
    GROWSTR(&(str->str_ptr), &(str->str_len), str->str_cur + len + 1);
    str->str_nok = 0;		/* invalidate number */
    str->str_pok = 1;		/* validate pointer */
    to = str->str_ptr+str->str_cur;
    for (; *from; from++,to++) {
	if (*from == '\\' && from[1] && delim != '\\') {
	    if (!keeplist) {
		if (from[1] == delim || from[1] == '\\')
		    from++;
		else
		    *to++ = *from++;
	    }
	    else if (strchr(keeplist,from[1]))
		*to++ = *from++;
	    else
		from++;
	}
	else if (*from == delim)
	    break;
	*to = *from;
    }
    *to = '\0';
    str->str_cur = to - str->str_ptr;
    return from;
}

a140 7
void
str_grow(register STR *str, int len)
{
    if (len && str)
	GROWSTR(&(str->str_ptr), &(str->str_len), len + 1);
}

a143 13
str_replace(register STR *str, register STR *nstr)
{
    safefree(str->str_ptr);
    str->str_ptr = nstr->str_ptr;
    str->str_len = nstr->str_len;
    str->str_cur = nstr->str_cur;
    str->str_pok = nstr->str_pok;
    if ((str->str_nok = nstr->str_nok))
	str->str_nval = nstr->str_nval;
    safefree((char*)nstr);
}

void
a251 89
void
str_inc(register STR *str)
{
    register char *d;

    if (!str)
	return;
    if (str->str_nok) {
	str->str_nval += 1.0;
	str->str_pok = 0;
	return;
    }
    if (!str->str_pok) {
	str->str_nval = 1.0;
	str->str_nok = 1;
	return;
    }
    for (d = str->str_ptr; *d && *d != '.'; d++) ;
    d--;
    if (!isDIGIT(*str->str_ptr) || !isDIGIT(*d) ) {
        str_numset(str,atof(str->str_ptr) + 1.0);  /* punt */
	return;
    }
    while (d >= str->str_ptr) {
	if (++*d <= '9')
	    return;
	*(d--) = '0';
    }
    /* oh,oh, the number grew */
    GROWSTR(&(str->str_ptr), &(str->str_len), str->str_cur + 2);
    str->str_cur++;
    for (d = str->str_ptr + str->str_cur; d > str->str_ptr; d--)
	*d = d[-1];
    *d = '1';
}

void
str_dec(register STR *str)
{
    register char *d;

    if (!str)
	return;
    if (str->str_nok) {
	str->str_nval -= 1.0;
	str->str_pok = 0;
	return;
    }
    if (!str->str_pok) {
	str->str_nval = -1.0;
	str->str_nok = 1;
	return;
    }
    for (d = str->str_ptr; *d && *d != '.'; d++) ;
    d--;
    if (!isDIGIT(*str->str_ptr) || !isDIGIT(*d) || (*d == '0' && d == str->str_ptr)) {
        str_numset(str,atof(str->str_ptr) - 1.0);  /* punt */
	return;
    }
    while (d >= str->str_ptr) {
	if (--*d >= '0')
	    return;
	*(d--) = '9';
    }
}

/* make a string that will exist for the duration of the expression eval */

STR *
str_mortal(STR *oldstr)
{
    register STR *str = str_new(0);
    static long tmps_size = -1;

    str_sset(str,oldstr);
    if (++tmps_max > tmps_size) {
	tmps_size = tmps_max;
	if (!(tmps_size & 127)) {
	    if (tmps_size)
		tmps_list = (STR**)saferealloc((char*)tmps_list,
		    (tmps_size + 128) * sizeof(STR*) );
	    else
		tmps_list = (STR**)safemalloc(128 * sizeof(char*));
	}
    }
    tmps_list[tmps_max] = str;
    return str;
}

a260 8
STR *
str_nmake(double n)
{
    register STR *str = str_new(0);

    str_numset(str,n);
    return str;
}
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d303 1
a303 1
	ptr = FILE_ptr(fp);		/* reregisterize cnt and ptr */
d320 1
a320 1
    FILE_ptr(fp) = (STDCHAR*)ptr;
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d80 1
a80 1
    bcopy(ptr,str->str_ptr,len);
d96 1
a96 1
    bcopy(ptr,str->str_ptr,len+1);
d110 1
a110 1
    bcopy(ptr,str->str_ptr, str->str_cur + 1);
d121 1
a121 1
    bcopy(ptr,str->str_ptr+str->str_cur,len);
d148 1
a148 1
    bcopy(ptr,str->str_ptr+str->str_cur,len+1);
d200 1
a200 1
	bzero((char*)str,sizeof(STR));
d224 1
a224 1
    if (str->str_nok = nstr->str_nok)
d285 1
a285 1
    ptr = FILE_ptr(fp);
d288 1
a288 1
	    if ((*bp++ = *ptr++) == newline)
d295 1
d299 1
a299 1
	FILE_ptr(fp) = ptr;
d319 1
a319 1
    FILE_ptr(fp) = ptr;
d357 1
a357 1
    if (!isdigit(*str->str_ptr) || !isdigit(*d) ) {
d393 1
a393 1
    if (!isdigit(*str->str_ptr) || !isdigit(*d) || (*d == '0' && d == str->str_ptr)) {
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
@


1.3
log
@perl5.005_03 (stock)
@
text
@@


1.2
log
@perl 5.004_04
@
text
@d16 1
a16 3
str_numset(str,num)
register STR *str;
double num;
d24 1
a24 2
str_2ptr(str)
register STR *str;
d47 1
a47 2
str_2num(str)
register STR *str;
d64 1
a64 3
str_sset(dstr,sstr)
STR *dstr;
register STR *sstr;
d77 1
a77 4
str_nset(str,ptr,len)
register STR *str;
register char *ptr;
register int len;
d88 1
a88 3
str_set(str,ptr)
register STR *str;
register char *ptr;
d103 3
a105 3
str_chop(str,ptr)	/* like set but assuming ptr is in str */
register STR *str;
register char *ptr;
d116 1
a116 4
str_ncat(str,ptr,len)
register STR *str;
register char *ptr;
register int len;
d129 1
a129 3
str_scat(dstr,sstr)
STR *dstr;
register STR *sstr;
d138 1
a138 3
str_cat(str,ptr)
register STR *str;
register char *ptr;
d155 1
a155 5
str_append_till(str,from,delim,keeplist)
register STR *str;
register char *from;
register int delim;
char *keeplist;
d190 1
a190 2
str_new(len)
int len;
d208 1
a208 3
str_grow(str,len)
register STR *str;
int len;
d217 1
a217 3
str_replace(str,nstr)
register STR *str;
register STR *nstr;
d219 1
a219 1
    Safefree(str->str_ptr);
d230 1
a230 2
str_free(str)
register STR *str;
d244 1
a244 2
str_len(str)
register STR *str;
d257 1
a257 3
str_gets(str,fp)
register STR *str;
register FILE *fp;
d338 1
a338 2
str_inc(str)
register STR *str;
d374 1
a374 2
str_dec(str)
register STR *str;
d406 1
a406 2
str_mortal(oldstr)
STR *oldstr;
d427 1
a427 2
str_make(s)
char *s;
d436 1
a436 2
str_nmake(n)
double n;
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991, Larry Wall
d44 1
a44 1
	fprintf(stderr,"0x%lx ptr(%s)\n",str,str->str_ptr);
d62 1
a62 1
	fprintf(stderr,"0x%lx num(%g)\n",str,str->str_nval);
d300 10
d330 1
a330 1
	i = _filbuf(fp);		/* get more characters */
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d16 3
a18 1
str_numset(register STR *str, double num)
d26 2
a27 1
str_2ptr(register STR *str)
d44 1
a44 1
	fprintf(stderr,"0x%lx ptr(%s)\n",(unsigned long)str,str->str_ptr);
d50 2
a51 1
str_2num(register STR *str)
d62 1
a62 1
	fprintf(stderr,"0x%lx num(%g)\n",(unsigned long)str,str->str_nval);
d68 3
a70 1
str_sset(STR *dstr, register STR *sstr)
d83 4
a86 1
str_nset(register STR *str, register char *ptr, register int len)
d97 3
a99 1
str_set(register STR *str, register char *ptr)
d114 3
a116 3
str_chop(register STR *str, register char *ptr)	/* like set but assuming ptr is in str */
                  
                   
d127 4
a130 1
str_ncat(register STR *str, register char *ptr, register int len)
d143 3
a145 1
str_scat(STR *dstr, register STR *sstr)
d154 3
a156 1
str_cat(register STR *str, register char *ptr)
d173 5
a177 1
str_append_till(register STR *str, register char *from, register int delim, char *keeplist)
d212 2
a213 1
str_new(int len)
d231 3
a233 1
str_grow(register STR *str, int len)
d242 3
a244 1
str_replace(register STR *str, register STR *nstr)
d246 1
a246 1
    safefree(str->str_ptr);
d257 2
a258 1
str_free(register STR *str)
d272 2
a273 1
str_len(register STR *str)
d286 3
a288 1
str_gets(register STR *str, register FILE *fp)
a299 10
#if defined(VMS)
    /* An ungetc()d char is handled separately from the regular
     * buffer, so we getc() it back out and stuff it in the buffer.
     */
    i = getc(fp);
    if (i == EOF) return Nullch;
    *(--((*fp)->_ptr)) = (unsigned char) i;
    (*fp)->_cnt++;
#endif

d320 1
a320 1
	i = getc(fp);		/* get more characters */
d359 2
a360 1
str_inc(register STR *str)
d396 2
a397 1
str_dec(register STR *str)
d429 2
a430 1
str_mortal(STR *oldstr)
d451 2
a452 1
str_make(char *s)
d461 2
a462 1
str_nmake(double n)
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d80 1
a80 1
    memcpy(str->str_ptr,ptr,len);
d96 1
a96 1
    memcpy(str->str_ptr,ptr,len+1);
d110 1
a110 1
    memcpy(str->str_ptr, ptr, str->str_cur + 1);
d121 1
a121 1
    memcpy(str->str_ptr+str->str_cur, ptr, len);
d148 1
a148 1
    memcpy(str->str_ptr+str->str_cur, ptr, len+1);
d200 1
a200 1
	memset((char*)str,0,sizeof(STR));
d224 1
a224 1
    if ((str->str_nok = nstr->str_nok))
d285 1
a285 1
    ptr = (STDCHAR*)FILE_ptr(fp);
d288 1
a288 1
	    if ((*bp++ = *ptr++) == newline) {
a294 1
	    }
d298 1
a298 1
	FILE_ptr(fp) = (void*)ptr; /* LHS STDCHAR* cast non-portable */
d318 1
a318 1
    FILE_ptr(fp) = (STDCHAR*)ptr;
d356 1
a356 1
    if (!isDIGIT(*str->str_ptr) || !isDIGIT(*d) ) {
d392 1
a392 1
    if (!isDIGIT(*str->str_ptr) || !isDIGIT(*d) || (*d == '0' && d == str->str_ptr)) {
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
 *    2001, 2002, by Larry Wall and others
d302 1
a302 1
	ptr = (STDCHAR*)FILE_ptr(fp);		/* reregisterize cnt and ptr */
d319 1
a319 1
    FILE_ptr(fp) = (void*)ptr; /* LHS STDCHAR* cast non-portable */
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d1 1
a1 1
/* $RCSfile: str.c,v $$Revision: 1.7 $$Date: 2003/12/03 03:02:53 $
d9 1
a9 4
 * $Log: str.c,v $
 * Revision 1.7  2003/12/03 03:02:53  millert
 * Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
 *
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d1 1
a1 1
/* $RCSfile: str.c,v $$Revision: 4.1 $$Date: 92/08/07 18:29:26 $
d9 4
a12 1
 * $Log:	str.c,v $
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d1 1
a1 1
/*    str.c
d4 1
a4 1
 *    2001, 2002, 2005 by Larry Wall and others
d8 2
d47 17
d104 13
d155 35
d208 7
d218 13
d339 89
d437 8
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d28 1
a28 1
	return (char *)"";	/* probably safe - won't be written to */
d59 1
a59 1
str_nset(register STR *str, register const char *ptr, register int len)
d70 1
a70 1
str_set(register STR *str, register const char *ptr)
d85 1
a85 1
str_ncat(register STR *str, register const char *ptr, register int len)
d107 1
a107 1
str_cat(register STR *str, register const char *ptr)
d188 1
a188 1
    if (i == EOF) return NULL;
d242 1
a242 1
    if (fgets(buf, sizeof buf, fp) != NULL)
d249 1
a249 1
    return str->str_cur ? str->str_ptr : NULL;
d253 1
a253 1
str_make(const char *s)
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d15 1
a15 1
str_numset(STR *str, double num)
d23 1
a23 1
str_2ptr(STR *str)
d25 1
a25 1
    char *s;
d46 1
a46 1
str_sset(STR *dstr, STR *sstr)
d59 1
a59 1
str_nset(STR *str, const char *ptr, int len)
d70 1
a70 1
str_set(STR *str, const char *ptr)
d72 1
a72 1
    int len;
d85 1
a85 1
str_ncat(STR *str, const char *ptr, int len)
d98 1
a98 1
str_scat(STR *dstr, STR *sstr)
d107 1
a107 1
str_cat(STR *str, const char *ptr)
d109 1
a109 1
    int len;
d126 1
a126 1
    STR *str;
d144 1
a144 1
str_free(STR *str)
d158 1
a158 1
str_len(STR *str)
d171 1
a171 1
str_gets(STR *str, FILE *fp)
d176 4
a179 4
    char *bp;		/* we're going to steal some values */
    int cnt;		/*  from the stdio struct and put EVERYTHING */
    STDCHAR *ptr;	/*   in the innermost loop into registers */
    char newline = '\n';	/* (assuming at least 6 registers) */
d213 1
a213 1
	FILE_ptr(fp) = ptr;
d233 1
a233 1
    FILE_ptr(fp) = ptr;
d255 1
a255 1
    STR *str = str_new(0);
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@d203 1
a203 1
		if (bp <= str->str_ptr + 1 || bp[-2] != '\\')
@


