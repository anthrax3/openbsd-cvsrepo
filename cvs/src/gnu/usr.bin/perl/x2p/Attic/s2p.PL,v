head	1.12;
access;
symbols
	OPENBSD_6_0:1.11.0.4
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.10.0.10
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.12
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.18
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.16
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.14
	OPENBSD_5_0:1.9.0.12
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.10
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.22;	author afresh1;	state dead;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2016.07.25.10.53.04;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	FHUgABTHZQuYQh2B;

1.10
date	2013.03.25.20.41.01;	author sthen;	state Exp;
branches
	1.10.10.1
	1.10.12.1;
next	1.9;

1.9
date	2008.09.29.17.36.24;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.09.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.07.08;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.36;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.36;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.42.26;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.11.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.23;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.14;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.40;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.50.03;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.19.07;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.45;	author sthen;	state Exp;
branches;
next	;

1.10.10.1
date	2016.08.05.01.01.40;	author afresh1;	state Exp;
branches;
next	;
commitid	HjAJx2yjL4A8HWon;

1.10.12.1
date	2016.08.05.01.00.56;	author afresh1;	state Exp;
branches;
next	;
commitid	wK3bUiy9jNch0Key;


desc
@@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!/usr/bin/perl

BEGIN { pop @@INC if $INC[-1] eq '.' }
use Config;
use File::Basename qw(&basename &dirname);
use Cwd;
use subs qw(link);

sub link { # This is a cut-down version of installperl:link().
    my($from,$to) = @@_;
    my($success) = 0;

    eval {
	CORE::link($from, $to)
	    ? $success++
	    : ($from =~ m#^/afs/# || $to =~ m#^/afs/#)
	      ? die "AFS"  # okay inside eval {}
	      : die "Couldn't link $from to $to: $!\n";
    };
    if ($@@) {
	require File::Copy;
	File::Copy::copy($from, $to)
	    ? $success++
	    : warn "Couldn't copy $from to $to: $!\n";
    }
    $success;
}

# List explicitly here the variables you want Configure to
# generate.  Metaconfig only looks for shell variables, so you
# have to mention them as if they were shell variables, not
# %Config entries.  Thus you write
#  $startperl
# to ensure Configure will look for $Config{startperl}.

# This forces PL files to create target in same directory as PL file.
# This is so that make depend always knows where to find PL derivatives.
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';

open OUT,">$file" or die "Can't create $file: $!";

print "Extracting $file (with variable substitutions)\n";

# In this section, perl variables will be expanded during extraction.
# You can use $Config{...} to use Configure variables.

print OUT <<"!GROK!THIS!";
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
my \$startperl;
my \$perlpath;
(\$startperl = <<'/../') =~ s/\\s*\\z//;
$Config{startperl}
/../
(\$perlpath = <<'/../') =~ s/\\s*\\z//;
$Config{perlpath}
/../
!GROK!THIS!

# In the following, perl variables are not expanded during extraction.

print OUT <<'!NO!SUBS!';

$0 =~ s/^.*?(\w+)[\.\w]*$/$1/;

# (p)sed - a stream editor
# History:  Aug 12 2000: Original version.
#           Mar 25 2002: Rearrange generated Perl program.
#           Jul 23 2007: Fix bug in regex stripping (M.Thorland)

use strict;
use integer;
use Symbol;

=head1 NAME

psed - a stream editor

=head1 SYNOPSIS

   psed [-an] script [file ...]
   psed [-an] [-e script] [-f script-file] [file ...]

   s2p  [-an] [-e script] [-f script-file]

=head1 DESCRIPTION

A stream editor reads the input stream consisting of the specified files
(or standard input, if none are given), processes is line by line by
applying a script consisting of edit commands, and writes resulting lines
to standard output. The filename 'C<->' may be used to read standard input.

The edit script is composed from arguments of B<-e> options and
script-files, in the given order. A single script argument may be specified
as the first parameter.

If this program is invoked with the name F<s2p>, it will act as a
sed-to-Perl translator. See L<"SED SCRIPT TRANSLATION">.

B<sed> returns an exit code of 0 on success or >0 if an error occurred.

=head1 OPTIONS

=over 4

=item B<-a>

A file specified as argument to the B<w> edit command is by default
opened before input processing starts. Using B<-a>, opening of such
files is delayed until the first line is actually written to the file.

=item B<-e> I<script>

The editing commands defined by I<script> are appended to the script.
Multiple commands must be separated by newlines.

=item B<-f> I<script-file>

Editing commands from the specified I<script-file> are read and appended
to the script.

=item B<-n>

By default, a line is written to standard output after the editing script
has been applied to it. The B<-n> option suppresses automatic printing.

=back

=head1 COMMANDS

B<sed> command syntax is defined as

Z<> Z<> Z<> Z<>[I<address>[B<,>I<address>]][B<!>]I<function>[I<argument>]

with whitespace being permitted before or after addresses, and between
the function character and the argument. The I<address>es and the
address inverter (C<!>) are used to restrict the application of a
command to the selected line(s) of input.

Each command must be on a line of its own, except where noted in
the synopses below.

The edit cycle performed on each input line consist of reading the line
(without its trailing newline character) into the I<pattern space>,
applying the applicable commands of the edit script, writing the final
contents of the pattern space and a newline to the standard output.
A I<hold space> is provided for saving the contents of the
pattern space for later use.

=head2 Addresses

A sed address is either a line number or a pattern, which may be combined
arbitrarily to construct ranges. Lines are numbered across all input files.

Any address may be followed by an exclamation mark ('C<!>'), selecting
all lines not matching that address.

=over 4

=item I<number>

The line with the given number is selected.

=item B<$>

A dollar sign (C<$>) is the line number of the last line of the input stream.

=item B</>I<regular expression>B</>

A pattern address is a basic regular expression (see 
L<"BASIC REGULAR EXPRESSIONS">), between the delimiting character C</>.
Any other character except C<\> or newline may be used to delimit a
pattern address when the initial delimiter is prefixed with a
backslash ('C<\>').

=back

If no address is given, the command selects every line.

If one address is given, it selects the line (or lines) matching the
address.

Two addresses select a range that begins whenever the first address
matches, and ends (including that line) when the second address matches.
If the first (second) address is a matching pattern, the second 
address is not applied to the very same line to determine the end of
the range. Likewise, if the second address is a matching pattern, the
first address is not applied to the very same line to determine the
begin of another range. If both addresses are line numbers,
and the second line number is less than the first line number, then
only the first line is selected.


=head2 Functions

The maximum permitted number of addresses is indicated with each
function synopsis below.

The argument I<text> consists of one or more lines following the command.
Embedded newlines in I<text> must be preceded with a backslash.  Other
backslashes in I<text> are deleted and the following character is taken
literally.

=over 4

=cut

my %ComTab;
my %GenKey;
#--------------------------------------------------------------------------
$ComTab{'a'}=[ 1, 'txt', \&Emit,       '{ push( @@Q, <<'."'TheEnd' ) }\n" ]; #ok

=item [1addr]B<a\> I<text>

Write I<text> (which must start on the line following the command)
to standard output immediately before reading the next line
of input, either by executing the B<N> function or by beginning a new cycle.

=cut

#--------------------------------------------------------------------------
$ComTab{'b'}=[ 2, 'str', \&Branch,     '{ goto XXX; }'                   ]; #ok

=item [2addr]B<b> [I<label>]

Branch to the B<:> function with the specified I<label>. If no label
is given, branch to the end of the script.

=cut

#--------------------------------------------------------------------------
$ComTab{'c'}=[ 2, 'txt', \&Change,     <<'-X-'                           ]; #ok
{ print <<'TheEnd'; } $doPrint = 0; goto EOS;
-X-
### continue OK => next CYCLE;

=item [2addr]B<c\> I<text>

The line, or range of lines, selected by the address is deleted. 
The I<text> (which must start on the line following the command)
is written to standard output. With an address range, this occurs at
the end of the range.

=cut

#--------------------------------------------------------------------------
$ComTab{'d'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ $doPrint = 0;
  goto EOS;
}
-X-
### continue OK => next CYCLE;

=item [2addr]B<d>

Deletes the pattern space and starts the next cycle.

=cut

#--------------------------------------------------------------------------
$ComTab{'D'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ s/^.*\n?//;
  if(length($_)){ goto BOS } else { goto EOS }
}
-X-
### continue OK => next CYCLE;

=item [2addr]B<D>

Deletes the pattern space through the first embedded newline or to the end.
If the pattern space becomes empty, a new cycle is started, otherwise
execution of the script is restarted.

=cut

#--------------------------------------------------------------------------
$ComTab{'g'}=[ 2, '',    \&Emit,       '{ $_ = $Hold };'                 ]; #ok

=item [2addr]B<g>

Replace the contents of the pattern space with the hold space.

=cut

#--------------------------------------------------------------------------
$ComTab{'G'}=[ 2, '',    \&Emit,       '{ $_ .= "\n"; $_ .= $Hold };'    ]; #ok

=item [2addr]B<G>

Append a newline and the contents of the hold space to the pattern space.

=cut

#--------------------------------------------------------------------------
$ComTab{'h'}=[ 2, '',    \&Emit,       '{ $Hold = $_ }'                  ]; #ok

=item [2addr]B<h>

Replace the contents of the hold space with the pattern space.

=cut

#--------------------------------------------------------------------------
$ComTab{'H'}=[ 2, '',    \&Emit,       '{ $Hold .= "\n"; $Hold .= $_; }' ]; #ok

=item [2addr]B<H>

Append a newline and the contents of the pattern space to the hold space.

=cut

#--------------------------------------------------------------------------
$ComTab{'i'}=[ 1, 'txt', \&Emit,       '{ print <<'."'TheEnd' }\n"       ]; #ok

=item [1addr]B<i\> I<text>

Write the I<text> (which must start on the line following the command)
to standard output.

=cut

#--------------------------------------------------------------------------
$ComTab{'l'}=[ 2, '',    \&Emit,       '{ _l() }'                        ]; #okUTF8

=item [2addr]B<l>

Print the contents of the pattern space: non-printable characters are
shown in C-style escaped form; long lines are split and have a trailing
^'C<\>' at the point of the split; the true end of a line is marked with
a 'C<$>'. Escapes are: '\a', '\t', '\n', '\f', '\r', '\e' for
BEL, HT, LF, FF, CR, ESC, respectively, and '\' followed by a three-digit
octal number for all other non-printable characters.

=cut

#--------------------------------------------------------------------------
$ComTab{'n'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ print $_, "\n" if $doPrint;
  printQ() if @@Q;
  $CondReg = 0;
  last CYCLE unless getsARGV();
  chomp();
}
-X-

=item [2addr]B<n>

If automatic printing is enabled, write the pattern space to the standard
output. Replace the pattern space with the next line of input. If
there is no more input, processing is terminated.

=cut

#--------------------------------------------------------------------------
$ComTab{'N'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ printQ() if @@Q;
  $CondReg = 0;
  last CYCLE unless getsARGV( $h );
  chomp( $h );
  $_ .= "\n$h";
}
-X-

=item [2addr]B<N>

Append a newline and the next line of input to the pattern space. If
there is no more input, processing is terminated.

=cut

#--------------------------------------------------------------------------
$ComTab{'p'}=[ 2, '',    \&Emit,       '{ print $_, "\n"; }'             ]; #ok

=item [2addr]B<p>

Print the pattern space to the standard output. (Use the B<-n> option
to suppress automatic printing at the end of a cycle if you want to
avoid double printing of lines.)

=cut

#--------------------------------------------------------------------------
$ComTab{'P'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ if( /^(.*)/ ){ print $1, "\n"; } }
-X-

=item [2addr]B<P>

Prints the pattern space through the first embedded newline or to the end.

=cut

#--------------------------------------------------------------------------
$ComTab{'q'}=[ 1, '',    \&Emit,       <<'-X-'                           ]; #ok
{ print $_, "\n" if $doPrint;
  last CYCLE;
}
-X-

=item [1addr]B<q>

Branch to the end of the script and quit without starting a new cycle.

=cut

#--------------------------------------------------------------------------
$ComTab{'r'}=[ 1, 'str', \&Emit,       "{ _r( '-X-' ) }"                 ]; #ok

=item [1addr]B<r> I<file>

Copy the contents of the I<file> to standard output immediately before
the next attempt to read a line of input. Any error encountered while
reading I<file> is silently ignored.

=cut

#--------------------------------------------------------------------------
$ComTab{'s'}=[ 2, 'sub', \&Emit,       ''                                ]; #ok

=item [2addr]B<s/>I<regular expression>B</>I<replacement>B</>I<flags>

Substitute the I<replacement> string for the first substring in
the pattern space that matches the I<regular expression>.
Any character other than backslash or newline can be used instead of a 
slash to delimit the regular expression and the replacement.
To use the delimiter as a literal character within the regular expression
and the replacement, precede the character by a backslash ('C<\>').

Literal newlines may be embedded in the replacement string by
preceding a newline with a backslash.

Within the replacement, an ampersand ('C<&>') is replaced by the string
matching the regular expression. The strings 'C<\1>' through 'C<\9>' are
replaced by the corresponding subpattern (see L<"BASIC REGULAR EXPRESSIONS">).
To get a literal 'C<&>' or 'C<\>' in the replacement text, precede it
by a backslash.

The following I<flags> modify the behaviour of the B<s> command:

=over 8

=item B<g>

The replacement is performed for all matching, non-overlapping substrings
of the pattern space.

=item B<1>..B<9>

Replace only the n-th matching substring of the pattern space.

=item B<p>

If the substitution was made, print the new value of the pattern space.

=item B<w> I<file>

If the substitution was made, write the new value of the pattern space
to the specified file.

=back

=cut

#--------------------------------------------------------------------------
$ComTab{'t'}=[ 2, 'str', \&Branch,     '{ goto XXX if _t() }'            ]; #ok

=item [2addr]B<t> [I<label>]

Branch to the B<:> function with the specified I<label> if any B<s>
substitutions have been made since the most recent reading of an input line
or execution of a B<t> function. If no label is given, branch to the end of
the script. 


=cut

#--------------------------------------------------------------------------
$ComTab{'w'}=[ 2, 'str', \&Write,      "{ _w( '-X-' ) }"                 ]; #ok

=item [2addr]B<w> I<file>

The contents of the pattern space are written to the I<file>.

=cut

#--------------------------------------------------------------------------
$ComTab{'x'}=[ 2, '',    \&Emit,       '{ ($Hold, $_) = ($_, $Hold) }'   ]; #ok

=item [2addr]B<x>

Swap the contents of the pattern space and the hold space.

=cut

#--------------------------------------------------------------------------
$ComTab{'y'}=[ 2, 'tra', \&Emit,       ''                                ]; #ok

=item [2addr]B<y>B</>I<string1>B</>I<string2>B</>

In the pattern space, replace all characters occurring in I<string1> by the
character at the corresponding position in I<string2>. It is possible
to use any character (other than a backslash or newline) instead of a
slash to delimit the strings.  Within I<string1> and I<string2>, a
backslash followed by any character other than a newline is that literal
character, and a backslash followed by an 'n' is replaced by a newline
character.

=cut

#--------------------------------------------------------------------------
$ComTab{'='}=[ 1, '',    \&Emit,       '{ print "$.\n" }'                ]; #ok

=item [1addr]B<=>

Prints the current line number on the standard output.

=cut

#--------------------------------------------------------------------------
$ComTab{':'}=[ 0, 'str', \&Label,      ''                                ]; #ok

=item [0addr]B<:> [I<label>]

The command specifies the position of the I<label>. It has no other effect.

=cut

#--------------------------------------------------------------------------
$ComTab{'{'}=[ 2, '',    \&BeginBlock, '{'                               ]; #ok
$ComTab{'}'}=[ 0, '',    \&EndBlock,   ';}'                              ]; #ok
# ';' to avoid warning on empty {}-block

=item [2addr]B<{> [I<command>]

=item [0addr]B<}>

These two commands begin and end a command list. The first command may
be given on the same line as the opening B<{> command. The commands
within the list are jointly selected by the address(es) given on the
B<{> command (but may still have individual addresses).

=cut

#--------------------------------------------------------------------------
$ComTab{'#'}=[ 0, 'str', \&Comment,    ''                                ]; #ok

=item [0addr]B<#> [I<comment>]

The entire line is ignored (treated as a comment). If, however, the first
two characters in the script are 'C<#n>', automatic printing of output is
suppressed, as if the B<-n> option were given on the command line.

=back

=cut

use vars qw{ $isEOF $Hold %wFiles @@Q $CondReg $doPrint };

my $useDEBUG    = exists( $ENV{PSEDDEBUG} );
my $useEXTBRE   = $ENV{PSEDEXTBRE} || '';
$useEXTBRE =~ s/[^<>wWyB]//g; # gawk RE's handle these

my $doAutoPrint = 1;          # automatic printing of pattern space (-n => 0)
my $doOpenWrite = 1;          # open w command output files at start (-a => 0)
my $svOpenWrite = 0;          # save $doOpenWrite

# lower case $0 below as a VMSism.  The VMS build procedure creates the
# s2p file traditionally in upper case on the disk.  When VMS is in a
# case preserved or case sensitive mode, $0 will be returned in the exact
# case which will be on the disk, and that is not predictable at this time.

my $doGenerate  = lc($0) eq 's2p';

# Collected and compiled script
#
my( @@Commands, %Defined, @@BlockStack, %Label, $labNum, $Code, $Func );
$Code = '';

##################
#  Compile Time
#
# Labels
# 
# Error handling
#
sub Warn($;$){
    my( $msg, $loc ) = @@_;
    $loc ||= '';
    $loc .= ': ' if length( $loc );
    warn( "$0: $loc$msg\n" );
}

$labNum = 0;
sub newLabel(){
    return 'L_'.++$labNum;
}

# safeHere: create safe here delimiter and  modify opcode and argument
#
sub safeHere($$){
    my( $codref, $argref ) = @@_;
    my $eod = 'EOD000';
    while( $$argref =~ /^$eod$/m ){
        $eod++;
    }
    $$codref =~ s/TheEnd/$eod/e;
    $$argref .= "$eod\n"; 
}

# Emit: create address logic and emit command
#
sub Emit($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
    my $cond = '';
    if( defined( $addr1 ) ){
        if( defined( $addr2 ) ){
	    $addr1 .= $addr2 =~ /^\d+$/ ? "..$addr2" : "...$addr2";
        } else {
	    $addr1 .= ' == $.' if $addr1 =~ /^\d+$/;
	}
	$cond = $negated ? "unless( $addr1 )\n" : "if( $addr1 )\n";
    }

    if( $opcode eq '' ){
	$Code .= "$cond$arg\n";

    } elsif( $opcode =~ s/-X-/$arg/e ){
	$Code .= "$cond$opcode\n";

    } elsif( $opcode =~ /TheEnd/ ){
	safeHere( \$opcode, \$arg );
	$Code .= "$cond$opcode$arg";

    } else {
	$Code .= "$cond$opcode\n";
    }
    0;
}

# Write (w command, w flag): store pathname
#
sub Write($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $path, $fl ) = @@_;
    $wFiles{$path} = '';
    Emit( $addr1, $addr2, $negated, $opcode, $path, $fl );
}


# Label (: command): label definition
#
sub Label($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $lab, $fl ) = @@_;
    my $rc = 0;
    $lab =~ s/\s+//;
    if( length( $lab ) ){
	my $h;
	if( ! exists( $Label{$lab} ) ){
	    $h = $Label{$lab}{name} = newLabel();
        } else {
	    $h = $Label{$lab}{name};
	    if( exists( $Label{$lab}{defined} ) ){
		my $dl = $Label{$lab}{defined};
		Warn( "duplicate label $lab (first defined at $dl)", $fl );
		$rc = 1;
	    }
	}
        $Label{$lab}{defined} = $fl;
	$Code .= "$h:;\n";
    }
    $rc;
}

# BeginBlock ({ command): push block start
#
sub BeginBlock($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
    push( @@BlockStack, [ $fl, $addr1, $addr2, $negated ] );
    Emit( $addr1, $addr2, $negated, $opcode, $arg, $fl );
}

# EndBlock (} command): check proper nesting
#
sub EndBlock($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
    my $rc;
    my $jcom = pop( @@BlockStack );
    if( defined( $jcom ) ){
	$rc = Emit( $addr1, $addr2, $negated, $opcode, $arg, $fl );
    } else {
	Warn( "unexpected '}'", $fl );
	$rc = 1;
    }
    $rc;
}

# Branch (t, b commands): check or create label, substitute default
#
sub Branch($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $lab, $fl ) = @@_;
    $lab =~ s/\s+//; # no spaces at end
    my $h;
    if( length( $lab ) ){
	if( ! exists( $Label{$lab} ) ){
	    $h = $Label{$lab}{name} = newLabel();
        } else {
	    $h = $Label{$lab}{name};
	}
	push( @@{$Label{$lab}{used}}, $fl );
    } else {
	$h = 'EOS';
    }
    $opcode =~ s/XXX/$h/e;
    Emit( $addr1, $addr2, $negated, $opcode, '', $fl );
}

# Change (c command): is special due to range end watching
#
sub Change($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
    my $kwd = $negated ? 'unless' : 'if';
    if( defined( $addr2 ) ){
        $addr1 .= $addr2 =~ /^\d+$/ ? "..$addr2" : "...$addr2";
	if( ! $negated ){
	    $addr1  = '$icnt = ('.$addr1.')';
	    $opcode = 'if( $icnt =~ /E0$/ )' . $opcode;
	}
    } else {
	$addr1 .= ' == $.' if $addr1 =~ /^\d+$/;
    }
    safeHere( \$opcode, \$arg );
    $Code .= "$kwd( $addr1 ){\n  $opcode$arg}\n";
    0;
}


# Comment (# command): A no-op. Who would've thought that!
#
sub Comment($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
### $Code .= "# $arg\n";
    0;
}

# stripRegex from the current command. If we're in the first
# part of s///, trailing spaces have to be kept as the initial
# part of the replacement string.
#
sub stripRegex($$;$){
    my( $del, $sref, $sub ) = @@_;
    my $regex = $del;
    print "stripRegex:$del:$$sref:\n" if $useDEBUG;
    while( $$sref =~ s{^(.*?)(\\*)\Q$del\E(\s*)}{}s ){
        my $sl = $2;
	$regex .= $1.$sl.$del;
	if( length( $sl ) % 2 == 0 ){
            if( $sub && (length( $3 ) > 0) ){
                $$sref = $3 . $$sref;
	    }
	    return $regex;
	}
	$regex .= $3;
    }
    undef();
}

# stripTrans: take a <del> terminated string from y command
#   honoring and cleaning up of \-escaped <del>'s
#
sub stripTrans($$){
    my( $del, $sref ) = @@_;
    my $t = '';
    print "stripTrans:$del:$$sref:\n" if $useDEBUG;
    while( $$sref =~ s{^(.*?)(\\*)\Q$del\E}{}s ){
        my $sl = $2;
	$t .= $1;
	if( length( $sl ) % 2 == 0 ){
	    $t .= $sl;
	    $t =~ s/\\\\/\\/g;
	    return $t;
	}
	chop( $sl );
	$t .= $sl.$del.$3;
    }
    undef();
}

# makey - construct Perl y/// from sed y///
#
sub makey($$$){
    my( $fr, $to, $fl ) = @@_;
    my $error = 0;

    # Ensure that any '-' is up front.
    # Diagnose duplicate contradicting mappings
    my %tr;
    for( my $i = 0; $i < length($fr); $i++ ){
	my $fc = substr($fr,$i,1);
	my $tc = substr($to,$i,1);
	if( exists( $tr{$fc} ) && $tr{$fc} ne $tc ){
	    Warn( "ambiguous translation for character '$fc' in 'y' command",
		  $fl );
	    $error++;
	}
	$tr{$fc} = $tc;
    }
    $fr = $to = '';
    if( exists( $tr{'-'} ) ){
	( $fr, $to ) = ( '-', $tr{'-'} );
	delete( $tr{'-'} );
    } else {
	$fr = $to = '';
    }
    # might just as well sort it...
    for my $fc ( sort keys( %tr ) ){
	$fr .= $fc;
	$to .= $tr{$fc};
    }
    # make embedded delimiters and newlines safe
    $fr =~ s/([{}])/\$1/g;
    $to =~ s/([{}])/\$1/g;
    $fr =~ s/\n/\\n/g;
    $to =~ s/\n/\\n/g;
    return $error ? undef() : "{ y{$fr}{$to}; }";
}

######
# makes - construct Perl s/// from sed s///
#
sub makes($$$$$$$){
    my( $regex, $subst, $path, $global, $print, $nmatch, $fl ) = @@_;

    # make embedded newlines safe
    $regex =~ s/\n/\\n/g;
    $subst =~ s/\n/\\n/g;
 
    my $code;
    # n-th occurrence
    #
    if( length( $nmatch ) ){
	$code = <<TheEnd;
{ \$n = $nmatch;
  while( --\$n && ( \$s = m ${regex}g ) ){}
  \$s = ( substr( \$_, pos() ) =~ s ${regex}${subst}s ) if \$s;
  \$CondReg ||= \$s;
TheEnd
    } else {
        $code = <<TheEnd;
{ \$s = s ${regex}${subst}s${global};
  \$CondReg ||= \$s;
TheEnd
    }
    if( $print ){
        $code .= '  print $_, "\n" if $s;'."\n";
    }
    if( defined( $path ) ){
        $wFiles{$path} = '';
	$code .= " _w( '$path' ) if \$s;\n";
        $GenKey{'w'} = 1;
    }
    $code .= "}";
}

=head1 BASIC REGULAR EXPRESSIONS

A I<Basic Regular Expression> (BRE), as defined in POSIX 1003.2, consists
of I<atoms>, for matching parts of a string, and I<bounds>, specifying
repetitions of a preceding atom.

=head2 Atoms

The possible atoms of a BRE are: B<.>, matching any single character;
B<^> and B<$>, matching the null string at the beginning or end
of a string, respectively; a I<bracket expressions>, enclosed
in B<[> and B<]> (see below); and any single character with no
other significance (matching that character). A B<\> before one
of: B<.>, B<^>, B<$>, B<[>, B<*>, B<\>, matching the character
after the backslash. A sequence of atoms enclosed in B<\(> and B<\)>
becomes an atom and establishes the target for a I<backreference>,
consisting of the substring that actually matches the enclosed atoms.
Finally, B<\> followed by one of the digits B<0> through B<9> is a
backreference.

A B<^> that is not first, or a B<$> that is not last does not have
a special significance and need not be preceded by a backslash to
become literal. The same is true for a B<]>, that does not terminate
a bracket expression.

An unescaped backslash cannot be last in a BRE.

=head2 Bounds

The BRE bounds are: B<*>, specifying 0 or more matches of the preceding
atom; B<\{>I<count>B<\}>, specifying that many repetitions;
B<\{>I<minimum>B<,\}>, giving a lower limit; and
B<\{>I<minimum>B<,>I<maximum>B<\}> finally defines a lower and upper
bound. 

A bound appearing as the first item in a BRE is taken literally.

=head2 Bracket Expressions

A I<bracket expression> is a list of characters, character ranges
and character classes enclosed in B<[> and B<]> and matches any
single character from the represented set of characters.

A character range is written as two characters separated by B<-> and
represents all characters (according to the character collating sequence)
that are not less than the first and not greater than the second.
(Ranges are very collating-sequence-dependent, and portable programs
should avoid relying on them.)

A character class is one of the class names

   alnum     digit     punct
   alpha     graph     space
   blank     lower     upper
   cntrl     print     xdigit

enclosed in B<[:> and B<:]> and represents the set of characters
as defined in ctype(3).

If the first character after B<[> is B<^>, the sense of matching is
inverted.

To include a literal 'C<^>', place it anywhere else but first. To
include a literal 'C<]>' place it first or immediately after an
initial B<^>. To include a literal 'C<->' make it the first (or
second after B<^>) or last character, or the second endpoint of
a range.

The special bracket expression constructs C<[[:E<lt>:]]> and C<[[:E<gt>:]]> 
match the null string at the beginning and end of a word respectively.
(Note that neither is identical to Perl's '\b' atom.)

=head2 Additional Atoms

Since some sed implementations provide additional regular expression
atoms (not defined in POSIX 1003.2), B<psed> is capable of translating
the following backslash escapes:

=over 4

=item B<\E<lt>> This is the same as C<[[:E<gt>:]]>.

=item B<\E<gt>> This is the same as C<[[:E<lt>:]]>.

=item B<\w> This is an abbreviation for C<[[:alnum:]_]>.

=item B<\W> This is an abbreviation for C<[^[:alnum:]_]>.

=item B<\y> Match the empty string at a word boundary.

=item B<\B> Match the empty string between any two either word or non-word characters.

=back

To enable this feature, the environment variable PSEDEXTBRE must be set
to a string containing the requested characters, e.g.:
C<PSEDEXTBRE='E<lt>E<gt>wW'>.

=cut

#####
# bre2p - convert BRE to Perl RE
#
sub peek(\$$){
    my( $pref, $ic ) = @@_;
    $ic < length($$pref)-1 ? substr( $$pref, $ic+1, 1 ) : '';
}

sub bre2p($$$){
    my( $del, $pat, $fl ) = @@_;
    my $led = $del;
    $led =~ tr/{([</})]>/;
    $led = '' if $led eq $del;

    $pat = substr( $pat, 1, length($pat) - 2 );
    my $res = '';
    my $bracklev = 0;
    my $backref  = 0;
    my $parlev = 0;
    for( my $ic = 0; $ic < length( $pat ); $ic++ ){
        my $c = substr( $pat, $ic, 1 );
        if( $c eq '\\' ){
	    ### backslash escapes
            my $nc = peek($pat,$ic);
            if( $nc eq '' ){
                Warn( "'\\' cannot be last in pattern", $fl );
                return undef();
            }
	    $ic++;
            if( $nc eq $del ){ ## \<pattern del> => \<pattern del>
                $res .= "\\$del";

	    } elsif( $nc =~ /([[.*\\n])/ ){
		## check for \-escaped magics and \n:
		## \[ \. \* \\ \n stay as they are
                $res .= '\\'.$nc;

            } elsif( $nc eq '(' ){ ## \( => (
                $parlev++;
                $res .= '(';

            } elsif( $nc eq ')' ){ ## \) => )
                $parlev--;
		$backref++;
                if( $parlev < 0 ){
                    Warn( "unmatched '\\)'", $fl );
                    return undef();
                }
                $res .= ')';

            } elsif( $nc eq '{' ){ ## repetition factor \{<i>[,[<j>]]\}
                my $endpos = index( $pat, '\\}', $ic );
                if( $endpos < 0 ){
                    Warn( "unmatched '\\{'", $fl );
                    return undef();
                }
                my $rep = substr( $pat, $ic+1, $endpos-($ic+1) );
                $ic = $endpos + 1;

  	        if( $res =~ /^\^?$/ ){
		    $res .= "\\{$rep\}";
                } elsif( $rep =~ /^(\d+)(,?)(\d*)?$/ ){
                    my $min = $1;
                    my $com = $2 || '';
                    my $max = $3;
                    if( length( $max ) ){
                        if( $max < $min ){
                            Warn( "maximum less than minimum in '\\{$rep\\}'",
				  $fl );
                            return undef();
                        }
                    } else {
                        $max = '';
                    }
		    # simplify some
		    if( $min == 0 && $max eq '1' ){
			$res .= '?';
		    } elsif( $min == 1 && "$com$max" eq ',' ){
			$res .= '+';
		    } elsif( $min == 0 && "$com$max" eq ',' ){
			$res .= '*';
		    } else {
			$res .= "{$min$com$max}";
		    }
                } else {
                    Warn( "invalid repeat clause '\\{$rep\\}'", $fl );
                    return undef();
                }

            } elsif( $nc =~ /^[1-9]$/ ){
		## \1 .. \9 => \1 .. \9, but check for a following digit
		if( $nc > $backref ){
                    Warn( "invalid backreference ($nc)", $fl );
                    return undef();
		}
                $res .= "\\$nc";
		if( peek($pat,$ic) =~ /[0-9]/ ){
		    $res .= '(?:)';
		}

            } elsif( $useEXTBRE && ( $nc =~ /[$useEXTBRE]/ ) ){
		## extensions - at most <>wWyB - not in POSIX
                if(      $nc eq '<' ){ ## \< => \b(?=\w), be precise
                    $res .= '\\b(?<=\\W)';
                } elsif( $nc eq '>' ){ ## \> => \b(?=\W), be precise
                    $res .= '\\b(?=\\W)';
                } elsif( $nc eq 'y' ){ ## \y => \b
                    $res .= '\\b';
                } else {               ## \B, \w, \W remain the same
                    $res .= "\\$nc";
                } 
	    } elsif( $nc eq $led ){
		## \<closing bracketing-delimiter> - keep '\'
		$res .= "\\$nc";

            } else { ## \ <char> => <char> ("as if '\' were not present")
                $res .= $nc;
            }

        } elsif( $c eq '.' ){ ## . => .
            $res .= $c;

	} elsif( $c eq '*' ){ ## * => * but \* if there's nothing preceding it
	    if( $res =~ /^\^?$/ ){
                $res .= '\\*';
            } elsif( substr( $res, -1, 1 ) ne '*' ){
		$res .= $c;
	    }

        } elsif( $c eq '[' ){
	    ## parse []: [^...] [^]...] [-...]
	    my $add = '[';
	    if( peek($pat,$ic) eq '^' ){
		$ic++;
		$add .= '^';
	    }
	    my $nc = peek($pat,$ic);
  	    if( $nc eq ']' || $nc eq '-' ){
		$add .= $nc;
                $ic++;
	    }
	    # check that [ is not trailing
	    if( $ic >= length( $pat ) - 1 ){
		Warn( "unmatched '['", $fl );
		return undef();
	    }
	    # look for [:...:] and x-y
	    my $rstr = substr( $pat, $ic+1 );
	    if( $rstr =~ /^((?:\[:\(\w+|[><]\):\]|[^]-](?:-[^]])?)*)/ ){
 	        my $cnt = $1;
		$ic += length( $cnt );
		$cnt =~ s/([\\\$])/\\$1/g; # '\', '$' are magic in Perl []
		# try some simplifications
 	        my $red = $cnt;
		if( $red =~ s/0-9// ){
		    $cnt = $red.'\d';
		    if( $red =~ s/A-Z// && $red =~ s/a-z// && $red =~ s/_// ){
			$cnt = $red.'\w';
                    }
		}
		$add .= $cnt;

		# POSIX 1003.2 has this (optional) for begin/end word
		$add = '\\b(?=\\W)'  if $add eq '[[:<:]]';
		$add = '\\b(?<=\\W)' if $add eq '[[:>:]]';

	    }

	    ## may have a trailing '-' before ']'
	    if( $ic < length($pat) - 1 &&
                substr( $pat, $ic+1 ) =~ /^(-?])/ ){
		$ic += length( $1 );
		$add .= $1;
		# another simplification
		$add =~ s/^\[(\^?)(\\[dw])]$/ $1 eq '^' ? uc($2) : $2 /e;
		$res .= $add;
	    } else {
		Warn( "unmatched '['", $fl );
		return undef();
	    }

        } elsif( $c eq $led ){ ## unescaped <closing bracketing-delimiter>
            $res .= "\\$c";

        } elsif( $c eq ']' ){ ## unmatched ] is not magic
            $res .= ']';

        } elsif( $c =~ /[|+?{}()]/ ){ ## not magic in BRE, but in Perl: \-quote
            $res .= "\\$c";

        } elsif( $c eq '^' ){ ## not magic unless 1st, but in Perl: \-quote
            $res .= length( $res ) ? '\\^' : '^';

        } elsif( $c eq '$' ){ ## not magic unless last, but in Perl: \-quote
            $res .= $ic == length( $pat ) - 1 ? '$' : '\\$';

        } else {
            $res .= $c;
        }
    }

    if( $parlev ){
       Warn( "unmatched '\\('", $fl );
       return undef();
    }

    # final cleanup: eliminate raw HTs
    $res =~ s/\t/\\t/g;
    return $del . $res . ( $led ? $led : $del );
}


#####
# sub2p - convert sed substitution to Perl substitution
#
sub sub2p($$$){
    my( $del, $subst, $fl ) = @@_;
    my $led = $del;
    $led =~ tr/{([</})]>/;
    $led = '' if $led eq $del;

    $subst = substr( $subst, 1, length($subst) - 2 );
    my $res = '';
 
    for( my $ic = 0; $ic < length( $subst ); $ic++ ){
        my $c = substr( $subst, $ic, 1 );
        if( $c eq '\\' ){
	    ### backslash escapes
            my $nc = peek($subst,$ic);
            if( $nc eq '' ){
                Warn( "'\\' cannot be last in substitution", $fl );
                return undef();
            }
	    $ic++;
	    if( $nc =~ /[\\$del$led]/ ){ ## \ and delimiter
		$res .= '\\' . $nc;
            } elsif( $nc =~ /[1-9]/ ){ ## \1 - \9 => ${1} - ${9}
                $res .= '${' . $nc . '}';
	    } else { ## everything else (includes &): omit \
		$res .= $nc;
	    }
        } elsif( $c eq '&' ){ ## & => $&
            $res .= '$&';
	} elsif( $c =~ /[\$\@@$led]/ ){ ## magic in Perl's substitution string
	    $res .= '\\' . $c;
        } else {
	    $res .= $c;
	}
    }

    # final cleanup: eliminate raw HTs
    $res =~ s/\t/\\t/g;
    return ( $led ? $del : $led ) . $res . ( $led ? $led : $del );
}


sub Parse(){
    my $error = 0;
    my( $pdef, $pfil, $plin );
    for( my $icom = 0; $icom < @@Commands; $icom++ ){
	my $cmd = $Commands[$icom];
	print "Parse:$cmd:\n" if $useDEBUG;
	$cmd =~ s/^\s+//;
	next unless length( $cmd );
	my $scom = $icom;
	if( exists( $Defined{$icom} ) ){
	    $pdef = $Defined{$icom};
	    if( $pdef =~ /^ #(\d+)/ ){
		$pfil = 'expression #';
		$plin = $1;
	    } else {
		$pfil = "$pdef l.";
		$plin = 1;
            }
        } else {
	    $plin++;
        }
        my $fl = "$pfil$plin";

        # insert command as comment in gnerated code
	#
	$Code .= "# $cmd\n" if $doGenerate;

	# The Address(es)
	#
	my( $negated, $naddr, $addr1, $addr2 );
	$naddr = 0;
	if(      $cmd =~ s/^(\d+)\s*// ){
	    $addr1 = "$1"; $naddr++;
	} elsif( $cmd =~ s/^\$\s*// ){
	    $addr1 = 'eofARGV()'; $naddr++;
	} elsif( $cmd =~ s{^(/)}{} || $cmd =~ s{^\\(.)}{} ){
	    my $del = $1;
	    my $regex = stripRegex( $del, \$cmd );
	    if( defined( $regex ) ){
		$addr1 = 'm '.bre2p( $del, $regex, $fl ).'s';
		$naddr++;
	    } else {
		Warn( "malformed regex, 1st address", $fl );
		$error++;
		next;
	    }
        }
        if( defined( $addr1 ) && $cmd =~ s/,\s*// ){
 	    if(      $cmd =~ s/^(\d+)\s*// ){
	        $addr2 = "$1"; $naddr++;
	    } elsif( $cmd =~ s/^\$\s*// ){
	        $addr2 = 'eofARGV()'; $naddr++;
	    } elsif( $cmd =~ s{^(/)}{} || $cmd =~ s{^\\(.)}{} ){
		my $del = $1;
	        my $regex = stripRegex( $del, \$cmd );
		if( defined( $regex ) ){
		    $addr2 = 'm '. bre2p( $del, $regex, $fl ).'s';
		    $naddr++;
		} else {
		    Warn( "malformed regex, 2nd address", $fl );
		    $error++;
		    next;
		}
            } else {
		Warn( "invalid address after ','", $fl );
		$error++;
		next;
            }
        }

        # address modifier '!'
        #
        $negated = $cmd =~ s/^!\s*//;
	if( defined( $addr1 ) ){
	    print "Parse: addr1=$addr1" if $useDEBUG;
	    if( defined( $addr2 ) ){
		print ", addr2=$addr2 " if $useDEBUG;
		# both numeric and addr1 > addr2 => eliminate addr2
		undef( $addr2 ) if $addr1 =~ /^\d+$/ &&
                                   $addr2 =~ /^\d+$/ && $addr1 > $addr2;
	    }
	}
	print 'negated' if $useDEBUG && $negated;
	print " command:$cmd\n" if $useDEBUG;

	# The Command
	#
        if( $cmd !~ s/^([:#={}abcdDgGhHilnNpPqrstwxy])\s*// ){
	    my $h = substr( $cmd, 0, 1 );
 	    Warn( "unknown command '$h'", $fl );
	    $error++;
	    next;
	}
        my $key = $1;

	my $tabref = $ComTab{$key};
	$GenKey{$key} = 1;
	if( $naddr > $tabref->[0] ){
	    Warn( "excess address(es)", $fl );
	    $error++;
	    next;
	}

	my $arg = '';
	if(      $tabref->[1] eq 'str' ){
	    # take remainder - don't care if it is empty
	    $arg = $cmd;
            $cmd = '';

	} elsif( $tabref->[1] eq 'txt' ){
	    # multi-line text
	    my $goon = $cmd =~ /(.*)\\$/;
	    if( length( $1 ) ){
		Warn( "extra characters after command ($cmd)", $fl );
		$error++;
	    }
	    while( $goon ){
		$icom++;
		if( $icom > $#Commands ){
		    Warn( "unexpected end of script", $fl );
		    $error++;
		    last;
		}
		$cmd = $Commands[$icom];
		$Code .= "# $cmd\n" if $doGenerate;
		$goon = $cmd =~ s/\\$//;
		$cmd =~ s/\\(.)/$1/g;
		$arg .= "\n" if length( $arg );
		$arg .= $cmd;
	    }
	    $arg .= "\n" if length( $arg );
	    $cmd = '';

	} elsif( $tabref->[1] eq 'sub' ){
	    # s///
	    if( ! length( $cmd ) ){
		Warn( "'s' command requires argument", $fl );
		$error++;
		next;
	    }
	    if( $cmd =~ s{^([^\\\n])}{} ){
		my $del = $1;
		my $regex = stripRegex( $del, \$cmd, "s" );
		if( ! defined( $regex ) ){
		    Warn( "malformed regular expression", $fl );
		    $error++;
		    next;
		}
		$regex = bre2p( $del, $regex, $fl );

		# a trailing \ indicates embedded NL (in replacement string)
		while( $cmd =~ s/(?<!\\)\\$/\n/ ){
		    $icom++;
		    if( $icom > $#Commands ){
			Warn( "unexpected end of script", $fl );
			$error++;
			last;
		    }
		    $cmd .= $Commands[$icom];
	            $Code .= "# $Commands[$icom]\n" if $doGenerate;
		}

		my $subst = stripRegex( $del, \$cmd );
		if( ! defined( $regex ) ){
		    Warn( "malformed substitution expression", $fl );
		    $error++;
		    next;
		}
		$subst = sub2p( $del, $subst, $fl );

		# parse s/// modifier: g|p|0-9|w <file>
		my( $global, $nmatch, $print, $write ) =
		  ( '',      '',      0,      undef );
		while( $cmd =~ s/^([gp0-9])// ){
		    $1 eq 'g' ? ( $global = 'g' ) :
  		    $1 eq 'p' ? ( $print  = $1  ) : ( $nmatch .= $1 );
                }
		$write = $1 if $cmd =~ s/w\s*(.*)$//;
  	        ### $nmatch =~ s/^(\d)\1*$/$1/; ### may be dangerous?
		if( $global && length( $nmatch ) || length( $nmatch ) > 1 ){
		    Warn( "conflicting flags '$global$nmatch'", $fl );
		    $error++;
		    next;
		}

		$arg = makes( $regex, $subst,
			      $write, $global, $print, $nmatch, $fl );
		if( ! defined( $arg ) ){
		    $error++;
		    next;
		}

            } else {
		Warn( "improper delimiter in s command", $fl );
		$error++;
		next;
            }

	} elsif( $tabref->[1] eq 'tra' ){
	    # y///
	    # a trailing \ indicates embedded newline
	    while( $cmd =~ s/(?<!\\)\\$/\n/ ){
		$icom++;
		if( $icom > $#Commands ){
		    Warn( "unexpected end of script", $fl );
		    $error++;
		    last;
		}
		$cmd .= $Commands[$icom];
                $Code .= "# $Commands[$icom]\n" if $doGenerate;
	    }
	    if( ! length( $cmd ) ){
		Warn( "'y' command requires argument", $fl );
		$error++;
		next;
	    }
	    my $d = substr( $cmd, 0, 1 ); $cmd = substr( $cmd, 1 );
	    if( $d eq '\\' ){
		Warn( "'\\' not valid as delimiter in 'y' command", $fl );
		$error++;
		next;
	    }
	    my $fr = stripTrans( $d, \$cmd );
	    if( ! defined( $fr ) || ! length( $cmd ) ){
		Warn( "malformed 'y' command argument", $fl );
		$error++;
		next;
	    }
	    my $to = stripTrans( $d, \$cmd );
	    if( ! defined( $to ) ){
		Warn( "malformed 'y' command argument", $fl );
		$error++;
		next;
	    }
	    if( length($fr) != length($to) ){
		Warn( "string lengths in 'y' command differ", $fl );
		$error++;
		next;
	    }
	    if( ! defined( $arg = makey( $fr, $to, $fl ) ) ){
		$error++;
		next;
	    }

	}

	# $cmd must be now empty - exception is {
	if( $cmd !~ /^\s*$/ ){
	    if( $key eq '{' ){
		# dirty hack to process command on '{' line
		$Commands[$icom--] = $cmd;
	    } else {
		Warn( "extra characters after command ($cmd)", $fl );
		$error++;
		next;
	    }
	}

	# Make Code
        #
	if( &{$tabref->[2]}( $addr1, $addr2, $negated,
                             $tabref->[3], $arg, $fl ) ){
	    $error++;
	}
    }

    while( @@BlockStack ){
	my $bl = pop( @@BlockStack );
	Warn( "start of unterminated '{'", $bl );
        $error++;
    }

    for my $lab ( keys( %Label ) ){
	if( ! exists( $Label{$lab}{defined} ) ){
	    for my $used ( @@{$Label{$lab}{used}} ){
 	        Warn( "undefined label '$lab'", $used );
	        $error++;
	    }
	}
    }

    exit( 1 ) if $error;
}


##############
#### MAIN ####
##############

sub usage(){
    print STDERR "Usage: sed [-an] command [file...]\n";
    print STDERR "           [-an] [-e command] [-f script-file] [file...]\n";
}

###################
# Here we go again...
#
my $expr = 0;
while( @@ARGV && $ARGV[0] =~ /^-(.)(.*)$/ ){
    my $opt = $1;
    my $arg = $2;
    shift( @@ARGV );
    if(      $opt eq 'e' ){
        if( length( $arg ) ){
	    push( @@Commands, split( "\n", $arg ) );
        } elsif( @@ARGV ){
	    push( @@Commands, shift( @@ARGV ) ); 
        } else {
            Warn( "option -e requires an argument" );
            usage();
            exit( 1 );
        }
	$expr++;
        $Defined{$#Commands} = " #$expr";
	next;
    }
    if( $opt eq 'f' ){
        my $path;
        if( length( $arg ) ){
	    $path = $arg;
        } elsif( @@ARGV ){
	    $path = shift( @@ARGV ); 
        } else {
            Warn( "option -f requires an argument" );
            usage();
            exit( 1 );
        }
	my $fst = $#Commands + 1;
        open( SCRIPT, "<$path" ) || die( "$0: $path: could not open ($!)\n" );
        my $cmd;
        while( defined( $cmd = <SCRIPT> ) ){
            chomp( $cmd );
            push( @@Commands, $cmd );
        }
        close( SCRIPT );
	if( $#Commands >= $fst ){
	    $Defined{$fst} = "$path";
	}
	next;
    }
    if( $opt eq '-' && $arg eq '' ){
	last;
    }
    if( $opt eq 'h' || $opt eq '?' ){
        usage();
        exit( 0 );
    }
    if( $opt eq 'n' ){
	$doAutoPrint = 0;
    } elsif( $opt eq 'a' ){
	$doOpenWrite = 0;
    } else {
        Warn( "illegal option '$opt'" );
        usage();
        exit( 1 );
    }
    if( length( $arg ) ){
	unshift( @@ARGV, "-$arg" );
    }
}

# A singleton command may be the 1st argument when there are no options.
#
if( @@Commands == 0 ){
    if( @@ARGV == 0 ){
        Warn( "no script command given" );
        usage();
        exit( 1 );
    }
    push( @@Commands, split( "\n", shift( @@ARGV ) ) );
    $Defined{0} = ' #1';
}

print STDERR "Files: @@ARGV\n" if $useDEBUG;

# generate leading code
#
$Func = <<'[TheEnd]';

# openARGV: open 1st input file
#
sub openARGV(){
    unshift( @@ARGV, '-' ) unless @@ARGV;
    my $file = shift( @@ARGV );
    open( ARG, "<$file" )
    || die( "$0: can't open $file for reading ($!)\n" );
    $isEOF = 0;
}

# getsARGV: Read another input line into argument (default: $_).
#           Move on to next input file, and reset EOF flag $isEOF.
sub getsARGV(;\$){
    my $argref = @@_ ? shift() : \$_; 
    while( $isEOF || ! defined( $$argref = <ARG> ) ){
	close( ARG );
	return 0 unless @@ARGV;
	my $file = shift( @@ARGV );
	open( ARG, "<$file" )
	|| die( "$0: can't open $file for reading ($!)\n" );
	$isEOF = 0;
    }
    1;
}

# eofARGV: end-of-file test
#
sub eofARGV(){
    return @@ARGV == 0 && ( $isEOF = eof( ARG ) );
}

# makeHandle: Generates another file handle for some file (given by its path)
#             to be written due to a w command or an s command's w flag.
sub makeHandle($){
    my( $path ) = @@_;
    my $handle;
    if( ! exists( $wFiles{$path} ) || $wFiles{$path} eq '' ){
        $handle = $wFiles{$path} = gensym();
	if( $doOpenWrite ){
	    if( ! open( $handle, ">$path" ) ){
		die( "$0: can't open $path for writing: ($!)\n" );
	    }
	}
    } else {
        $handle = $wFiles{$path};
    }
    return $handle;
}

# printQ: Print queued output which is either a string or a reference
#         to a pathname.
sub printQ(){
    for my $q ( @@Q ){
	if( ref( $q ) ){
            # flush open w files so that reading this file gets it all
	    if( exists( $wFiles{$$q} ) && $wFiles{$$q} ne '' ){
		open( $wFiles{$$q}, ">>$$q" );
	    }
            # copy file to stdout: slow, but safe
	    if( open( RF, "<$$q" ) ){
		while( defined( my $line = <RF> ) ){
		    print $line;
		}
		close( RF );
	    }
	} else {
	    print $q;
	}
    }
    undef( @@Q );
}

[TheEnd]

# generate the sed loop
#
$Code .= <<'[TheEnd]';
sub openARGV();
sub getsARGV(;\$);
sub eofARGV();
sub printQ();

# Run: the sed loop reading input and applying the script
#
sub Run(){
    my( $h, $icnt, $s, $n );
    # hack (not unbreakable :-/) to avoid // matching an empty string
    my $z = "\000"; $z =~ /$z/;
    # Initialize.
    openARGV();
    $Hold    = '';
    $CondReg = 0;
    $doPrint = $doAutoPrint;
CYCLE:
    while( getsARGV() ){
	chomp();
	$CondReg = 0;   # cleared on t
BOS:;
[TheEnd]

    # parse - avoid opening files when doing s2p
    #
    ( $svOpenWrite, $doOpenWrite ) = (  $doOpenWrite, $svOpenWrite )
      if $doGenerate;
    Parse();
    ( $svOpenWrite, $doOpenWrite ) = (  $doOpenWrite, $svOpenWrite )
      if $doGenerate;

    # append trailing code
    #
    $Code .= <<'[TheEnd]';
EOS:    if( $doPrint ){
            print $_, "\n";
        } else {
	    $doPrint = $doAutoPrint;
	}
        printQ() if @@Q;
    }

    exit( 0 );
}
[TheEnd]


# append optional functions, prepend prototypes
#
my $Proto = "# prototypes\n";
if( $GenKey{'l'} ){
    $Proto .= "sub _l();\n";
    $Func .= <<'[TheEnd]';
# _l: l command processing
#
sub _l(){        
    my $h = $_;
    my $mcpl = 70;
    # transform non printing chars into escape notation
    $h =~ s/\\/\\\\/g;
    if( $h =~ /[^[:print:]]/ ){
	$h =~ s/\a/\\a/g;
	$h =~ s/\f/\\f/g;
	$h =~ s/\n/\\n/g;
	$h =~ s/\t/\\t/g;
	$h =~ s/\r/\\r/g;
	$h =~ s/\e/\\e/g;
        $h =~ s/([^[:print:]])/sprintf("\\%03o", ord($1))/ge;
    }
    # split into lines of length $mcpl
    while( length( $h ) > $mcpl ){
	my $l = substr( $h, 0, $mcpl-1 );
	$h = substr( $h, $mcpl );
	# remove incomplete \-escape from end of line
	if( $l =~ s/(?<!\\)(\\[0-7]{0,2})$// ){
	    $h = $1 . $h;
	}
	print $l, "\\\n";
    }
    print "$h\$\n";
}

[TheEnd]
}

if( $GenKey{'r'} ){
    $Proto .= "sub _r(\$);\n";
    $Func .= <<'[TheEnd]';
# _r: r command processing: Save a reference to the pathname.
#
sub _r($){
    my $path = shift();
    push( @@Q, \$path );
}

[TheEnd]
}

if( $GenKey{'t'} ){
    $Proto .= "sub _t();\n";
    $Func .= <<'[TheEnd]';
# _t: t command - condition register test/reset
#
sub _t(){
    my $res = $CondReg;
    $CondReg = 0;
    $res;
}

[TheEnd]
}

if( $GenKey{'w'} ){
    $Proto .= "sub _w(\$);\n";
    $Func .= <<'[TheEnd]';
# _w: w command and s command's w flag - write to file 
#
sub _w($){
    my $path   = shift();
    my $handle = $wFiles{$path};
    if( ! $doOpenWrite && ! defined( fileno( $handle ) ) ){
	open( $handle, ">$path" )
	|| die( "$0: $path: cannot open ($!)\n" );
    }
    print $handle $_, "\n";
}

[TheEnd]
}

$Code = $Proto . $Code;

# magic "#n" - same as -n option
#
$doAutoPrint = 0 if substr( $Commands[0], 0, 2 ) eq '#n';

# eval code - check for errors
#
print "Code:\n$Code$Func" if $useDEBUG;
eval $Code . $Func;
if( $@@ ){
    print "Code:\n$Code$Func";
    die( "$0: internal error - generated incorrect Perl code: $@@\n" );
}

if( $doGenerate ){

    # write full Perl program
    #
 
    # bang line, declarations, prototypes
    print <<TheEnd;
#!$perlpath -w
eval 'exec $perlpath -S \$0 \${1+"\$@@"}'
  if 0;
\$0 =~ s/^.*?(\\w+)\[\\.\\w+\]*\$/\$1/;

use strict;
use Symbol;
use vars qw{ \$isEOF \$Hold \%wFiles \@@Q \$CondReg
	     \$doAutoPrint \$doOpenWrite \$doPrint };
\$doAutoPrint = $doAutoPrint;
\$doOpenWrite = $doOpenWrite;
TheEnd

    my $wf = "'" . join( "', '",  keys( %wFiles ) ) . "'";
    if( $wf ne "''" ){
	print <<TheEnd;
sub makeHandle(\$);
for my \$p ( $wf ){
   exit( 1 ) unless makeHandle( \$p );
}
TheEnd
   }

   print $Code;
   print "Run();\n";
   print $Func;
   exit( 0 );

} else {

    # execute: make handles (and optionally open) all w files; run!
    for my $p ( keys( %wFiles ) ){
        exit( 1 ) unless makeHandle( $p );
    }
    Run();
}


=head1 ENVIRONMENT

The environment variable C<PSEDEXTBRE> may be set to extend BREs.
See L<"Additional Atoms">.

=head1 DIAGNOSTICS

=over 4

=item ambiguous translation for character '%s' in 'y' command

The indicated character appears twice, with different translations.

=item '[' cannot be last in pattern

A '[' in a BRE indicates the beginning of a I<bracket expression>.

=item '\' cannot be last in pattern

A '\' in a BRE is used to make the subsequent character literal.

=item '\' cannot be last in substitution

A '\' in a substitution string is used to make the subsequent character literal.

=item conflicting flags '%s'

In an B<s> command, either the 'g' flag and an n-th occurrence flag, or
multiple n-th occurrence flags are specified. Note that only the digits
^'1' through '9' are permitted.

=item duplicate label %s (first defined at %s)

=item excess address(es)

The command has more than the permitted number of addresses.

=item extra characters after command (%s)

=item illegal option '%s'

=item improper delimiter in s command

The BRE and substitution may not be delimited with '\' or newline.

=item invalid address after ','

=item invalid backreference (%s)

The specified backreference number exceeds the number of backreferences
in the BRE.

=item invalid repeat clause '\{%s\}'

The repeat clause does not contain a valid integer value, or pair of
values.

=item malformed regex, 1st address

=item malformed regex, 2nd address

=item malformed regular expression

=item malformed substitution expression

=item malformed 'y' command argument

The first or second string of a B<y> command  is syntactically incorrect.

=item maximum less than minimum in '\{%s\}'

=item no script command given

There must be at least one B<-e> or one B<-f> option specifying a
script or script file.

=item '\' not valid as delimiter in 'y' command

=item option -e requires an argument

=item option -f requires an argument

=item 's' command requires argument

=item start of unterminated '{'

=item string lengths in 'y' command differ

The translation table strings in a B<y> command must have equal lengths.

=item undefined label '%s'

=item unexpected '}'

A B<}> command without a preceding B<{> command was encountered.

=item unexpected end of script

The end of the script was reached although a text line after a
B<a>, B<c> or B<i> command indicated another line.

=item unknown command '%s'

=item unterminated '['

A BRE contains an unterminated bracket expression.

=item unterminated '\('

A BRE contains an unterminated backreference.

=item '\{' without closing '\}'

A BRE contains an unterminated bounds specification.

=item '\)' without preceding '\('

=item 'y' command requires argument

=back

=head1 EXAMPLE

The basic material for the preceding section was generated by running
the sed script

   #no autoprint
   s/^.*Warn( *"\([^"]*\)".*$/\1/
   t process
   b
   :process
   s/$!/%s/g
   s/$[_[:alnum:]]\{1,\}/%s/g
   s/\\\\/\\/g
   s/^/=item /
   p

on the program's own text, and piping the output into C<sort -u>.


=head1 SED SCRIPT TRANSLATION

If this program is invoked with the name F<s2p> it will act as a
sed-to-Perl translator. After option processing (all other
arguments are ignored), a Perl program is printed on standard
output, which will process the input stream (as read from all
arguments) in the way defined by the sed script and the option setting
used for the translation.

=head1 SEE ALSO

perl(1), re_format(7)

=head1 BUGS

The B<l> command will show escape characters (ESC) as 'C<\e>', but
a vertical tab (VT) in octal.

Trailing spaces are truncated from labels in B<:>, B<t> and B<b> commands.

The meaning of an empty regular expression ('C<//>'), as defined by B<sed>,
is "the last pattern used, at run time". This deviates from the Perl
interpretation, which will re-use the "last last successfully executed
regular expression". Since keeping track of pattern usage would create
terribly cluttered code, and differences would only appear in obscure
context (where other B<sed> implementations appear to deviate, too),
the Perl semantics was adopted. Note that common usage of this feature,
such as in C</abc/s//xyz/>, will work as expected.

Collating elements (of bracket expressions in BREs) are not implemented.

=head1 STANDARDS

This B<sed> implementation conforms to the IEEE Std1003.2-1992 ("POSIX.2")
definition of B<sed>, and is compatible with the I<OpenBSD>
implementation, except where otherwise noted (see L<"BUGS">).

=head1 AUTHOR

This Perl implementation of I<sed> was written by Wolfgang Laun,
I<Wolfgang.Laun@@alcatel.at>.

=head1 COPYRIGHT and LICENSE

This program is free and open software. You may use, modify,
distribute, and sell this program (and any modified variants) in any
way you wish, provided you do not restrict others from doing the same.

=cut

!NO!SUBS!

close OUT or die "Can't close $file: $!";
chmod 0755, $file or die "Can't reset permissions for $file: $!\n";
unlink 'psed';
print "Linking $file to psed.\n";
if (defined $Config{d_link}) {
  link $file, 'psed';
} else {
  unshift @@INC, '../lib';
  require File::Copy;
  File::Copy::syscopy('s2p', 'psed');
}
exec("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
chdir $origdir;
@


1.11
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.


ok deraadt@@
@
text
@@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d3 1
@


1.10.10.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a2 1
BEGIN { pop @@INC if $INC[-1] eq '.' }
@


1.10.12.1
log
@Patch perl CVE-2016-1238

The problem relates to Perl 5 ("perl") loading modules from the
includes directory array ("@@INC") in which the last element is the
current directory (".").  That means that, when "perl" wants to
load a module (during first compilation or during lazy loading of
a module in run-time), perl will look for the module in the current
directory at the end, since '.' is the last include directory in
its array of include directories to seek. The issue is with requiring
libraries that are in "." but are not otherwise installed.

The major problem with this behavior is that it unexpectedly puts
a user at risk whenever they execute any Perl scripts from a directory
that is writable by other accounts on the system. For instance, if
a user is logged in as root and changes directory into /tmp or an
account's home directory, it is possible to now run any shell
commands that are written in C, Python or Ruby without fear.

The same isn't true for any shell commands that are written in Perl,
since a significant proportion of Perl scripts will execute code
in the current working directory whenever they are run. For example,
if a user on a shared system creates the file /tmp/Pod/Perldoc/Toterm.pm,
and then I log in as root, change directory to /tmp, and run "perldoc
perlrun", it will execute the code they have placed in the file.
@
text
@a2 1
BEGIN { pop @@INC if $INC[-1] eq '.' }
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d94 1
a94 1
to standard output. The filename `C<->' may be used to read standard input.
d101 1
a101 1
sed-to-Perl translator. See L<"sed Script Translation">.
d158 1
a158 1
Any address may be followed by an exclamation mark (`C<!>'), selecting
d174 1
a174 1
L<"Basic Regular Expressions">), between the delimiting character C</>.
d177 1
a177 1
backslash (`C<\>').
d332 3
a334 3
`C<\>' at the point of the split; the true end of a line is marked with
a `C<$>'. Escapes are: `\a', `\t', `\n', `\f', `\r', `\e' for
BEL, HT, LF, FF, CR, ESC, respectively, and `\' followed by a three-digit
d430 1
a430 1
and the replacement, precede the character by a backslash (`C<\>').
d435 4
a438 4
Within the replacement, an ampersand (`C<&>') is replaced by the string
matching the regular expression. The strings `C<\1>' through `C<\9>' are
replaced by the corresponding subpattern (see L<"Basic Regular Expressions">).
To get a literal `C<&>' or `C<\>' in the replacement text, precede it
d500 1
d503 1
a503 1
In the pattern space, replace all characters occuring in I<string1> by the
d508 1
a508 1
character, and a backslash followed by an `n' is replaced by a newline
d524 1
a524 1
 
d553 1
a553 1
two characters in the script are `C<#n>', automatic printing of output is
d693 1
a693 1
	Warn( "unexpected `}'", $fl );
d803 1
a803 1
	    Warn( "ambiguous translation for character `$fc' in `y' command",
d928 1
a928 1
To include a literal `C<^>', place it anywhere else but first. To
d930 1
a930 1
initial B<^>. To include a literal `C<->' make it the first (or
d936 1
a936 1
(Note that neither is identical to Perl's `\b' atom.)
d991 1
a991 1
                Warn( "`\\' cannot be last in pattern", $fl );
d1011 1
a1011 1
                    Warn( "unmatched `\\)'", $fl );
d1019 1
a1019 1
                    Warn( "unmatched `\\{'", $fl );
d1033 1
a1033 1
                            Warn( "maximum less than minimum in `\\{$rep\\}'",
d1051 1
a1051 1
                    Warn( "invalid repeat clause `\\{$rep\\}'", $fl );
d1081 1
a1081 1
            } else { ## \ <char> => <char> ("as if `\' were not present")
d1109 1
a1109 1
		Warn( "unmatched `['", $fl );
d1117 1
a1117 1
		$cnt =~ s/([\\\$])/\\$1/g; # `\', `$' are magic in Perl []
d1134 1
a1134 1
	    ## may have a trailing `-' before `]'
d1143 1
a1143 1
		Warn( "unmatched `['", $fl );
d1168 1
a1168 1
       Warn( "unmatched `\\('", $fl );
d1196 1
a1196 1
                Warn( "`\\' cannot be last in substitution", $fl );
d1286 1
a1286 1
		Warn( "invalid address after `,'", $fl );
d1292 1
a1292 1
        # address modifier `!'
d1311 1
a1311 1
 	    Warn( "unknown command `$h'", $fl );
d1358 1
a1358 1
		Warn( "`s' command requires argument", $fl );
d1402 1
a1402 1
		    Warn( "conflicting flags `$global$nmatch'", $fl );
d1434 1
a1434 1
		Warn( "`y' command requires argument", $fl );
d1440 1
a1440 1
		Warn( "`\\' not valid as delimiter in `y' command", $fl );
d1446 1
a1446 1
		Warn( "malformed `y' command argument", $fl );
d1452 1
a1452 1
		Warn( "malformed `y' command argument", $fl );
d1457 1
a1457 1
		Warn( "string lengths in `y' command differ", $fl );
d1490 1
a1490 1
	Warn( "start of unterminated `{'", $bl );
d1497 1
a1497 1
 	        Warn( "undefined label `$lab'", $used );
d1574 1
a1574 1
        Warn( "illegal option `$opt'" );
d1877 1
a1877 1
=item ambiguous translation for character `%s' in `y' command
d1881 1
a1881 1
=item `[' cannot be last in pattern
d1883 1
a1883 1
A `[' in a BRE indicates the beginning of a I<bracket expression>.
d1885 1
a1885 1
=item `\' cannot be last in pattern
d1887 1
a1887 1
A `\' in a BRE is used to make the subsequent character literal.
d1889 1
a1889 1
=item `\' cannot be last in substitution
d1891 1
a1891 1
A `\' in a subsitution string is used to make the subsequent character literal.
d1893 1
a1893 1
=item conflicting flags `%s'
d1895 1
a1895 1
In an B<s> command, either the `g' flag and an n-th occurrence flag, or
d1897 1
a1897 1
`1' through `9' are permitted.
d1907 1
a1907 1
=item illegal option `%s'
d1911 1
a1911 1
The BRE and substitution may not be delimited with `\' or newline.
d1913 1
a1913 1
=item invalid address after `,'
d1920 1
a1920 1
=item invalid repeat clause `\{%s\}'
d1933 1
a1933 1
=item malformed `y' command argument
d1937 1
a1937 1
=item maximum less than minimum in `\{%s\}'
d1944 1
a1944 1
=item `\' not valid as delimiter in `y' command
d1950 1
a1950 1
=item `s' command requires argument
d1952 1
a1952 1
=item start of unterminated `{'
d1954 1
a1954 1
=item string lengths in `y' command differ
d1958 1
a1958 1
=item undefined label `%s'
d1960 1
a1960 1
=item unexpected `}'
d1969 1
a1969 1
=item unknown command `%s'
d1971 1
a1971 1
=item unterminated `['
d1975 1
a1975 1
=item unterminated `\('
d1979 1
a1979 1
=item `\{' without closing `\}'
d1983 1
a1983 1
=item `\)' without preceding `\('
d1985 1
a1985 1
=item `y' command requires argument
d2023 1
a2023 1
The B<l> command will show escape characters (ESC) as `C<\e>', but
d2028 1
a2028 1
The meaning of an empty regular expression (`C<//>'), as defined by B<sed>,
@


1.8
log
@merge in perl 5.8.8
@
text
@d72 1
d746 6
a751 3

sub stripRegex($$){
    my( $del, $sref ) = @@_;
d758 3
d1363 1
a1363 1
		my $regex = stripRegex( $del, \$cmd );
d1955 1
a1955 1
The translation table strings in a B<y> commanf must have equal lengths.
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d567 7
a573 1
my $doGenerate  = $0 eq 's2p';
d2055 1
a2055 1
print "Linking s2p to psed.\n";
d2057 1
a2057 1
  link 's2p', 'psed';
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d789 1
a789 1
	    Warn( "ambiguos translation for character `$fc' in `y' command",
d1863 1
a1863 1
=item ambiguos translation for character `%s' in `y' command
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 1
a1 1
#!/usr/local/bin/perl
d6 21
d53 2
d67 9
a75 3
# $RCSfile: s2p.SH,v $$Revision: 4.1 $$Date: 92/08/07 18:29:23 $
#
# $Log:	s2p.SH,v $
d79 1
a79 1
s2p - Sed to Perl translator
d83 4
a86 1
B<s2p [options] filename>
d90 11
a100 3
I<s2p> takes a sed script specified on the command line (or from
standard input) and produces a comparable I<perl> script on the
standard output.
d102 1
a102 1
=head2 Options
d104 1
a104 1
Options include:
d106 1
a106 1
=over 5
d108 1
a108 1
=item B<-DE<lt>numberE<gt>>
d110 13
a122 1
sets debugging flags.
d126 8
a133 2
specifies that this sed script was always invoked with a B<sed -n>.
Otherwise a switch parser is prepended to the front of the script.
d135 1
a135 1
=item B<-p>
d137 40
a176 2
specifies that this sed script was never invoked with a B<sed -n>.
Otherwise a switch parser is prepended to the front of the script.
d180 175
a354 1
=head2 Considerations
d356 9
a364 11
The perl script produced looks very sed-ish, and there may very well
be better ways to express what you want to do in perl.  For instance,
s2p does not make any use of the split operator, but you might want
to.

The perl script you end up with may be either faster or slower than
the original sed script.  If you're only interested in speed you'll
just have to try it both ways.  Of course, if you want to do something
sed doesn't do, you have no choice.  It's often possible to speed up
the perl script by various methods, such as deleting all references to
$\ and chop.
d366 1
a366 1
=head1 ENVIRONMENT
d368 2
a369 1
s2p uses no environment variables.
d371 1
a371 1
=head1 AUTHOR
d373 2
a374 1
Larry Wall E<lt>F<larry@@wall.org>E<gt>
d376 1
a376 1
=head1 FILES
d378 3
a380 1
=head1 SEE ALSO
d382 1
a382 1
 perl	The perl compiler/interpreter
d384 4
a387 1
 a2p	awk to perl translator
d389 1
a389 1
=head1 DIAGNOSTICS
d391 1
a391 1
=head1 BUGS
d395 4
a398 21
$indent = 4;
$shiftwidth = 4;
$l = '{'; $r = '}';

while ($ARGV[0] =~ /^-/) {
    $_ = shift;
  last if /^--/;
    if (/^-D/) {
	$debug++;
	open(BODY,'>-');
	next;
    }
    if (/^-n/) {
	$assumen++;
	next;
    }
    if (/^-p/) {
	$assumep++;
	next;
    }
    die "I don't recognize this switch: $_\n";
d400 48
d449 41
a489 74
unless ($debug) {
    open(BODY,"+>/tmp/sperl$$") ||
      &Die("Can't open temp file: $!\n");
}

if (!$assumen && !$assumep) {
    print BODY &q(<<'EOT');
:	while ($ARGV[0] =~ /^-/) {
:	    $_ = shift;
:	  last if /^--/;
:	    if (/^-n/) {
:		$nflag++;
:		next;
:	    }
:	    die "I don't recognize this switch: $_\\n";
:	}
:	
EOT
}

print BODY &q(<<'EOT');
:	#ifdef PRINTIT
:	#ifdef ASSUMEP
:	$printit++;
:	#else
:	$printit++ unless $nflag;
:	#endif
:	#endif
:	<><>
:	$\ = "\n";		# automatically add newline on print
:	<><>
:	#ifdef TOPLABEL
:	LINE:
:	while (chop($_ = <>)) {
:	#else
:	LINE:
:	while (<>) {
:	    chop;
:	#endif
EOT

LINE:
while (<>) {

    # Wipe out surrounding whitespace.

    s/[ \t]*(.*)\n$/$1/;

    # Perhaps it's a label/comment.

    if (/^:/) {
	s/^:[ \t]*//;
	$label = &make_label($_);
	if ($. == 1) {
	    $toplabel = $label;
	    if (/^(top|(re)?start|redo|begin(ning)|again|input)$/i) {
		$_ = <>;
		redo LINE; # Never referenced, so delete it if not a comment.
	    }
	}
	$_ = "$label:";
	if ($lastlinewaslabel++) {
	    $indent += 4;
	    print BODY &tab, ";\n";
	    $indent -= 4;
	}
	if ($indent >= 2) {
	    $indent -= 2;
	    $indmod = 2;
	}
	next;
    } else {
	$lastlinewaslabel = '';
    }
d491 1
a491 1
    # Look for one or two address clauses
d493 1
a493 29
    $addr1 = '';
    $addr2 = '';
    if (s/^([0-9]+)//) {
	$addr1 = "$1";
	$addr1 = "\$. == $addr1" unless /^,/;
    }
    elsif (s/^\$//) {
	$addr1 = 'eof()';
    }
    elsif (s|^/||) {
	$addr1 = &fetchpat('/');
    }
    if (s/^,//) {
	if (s/^([0-9]+)//) {
	    $addr2 = "$1";
	} elsif (s/^\$//) {
	    $addr2 = "eof()";
	} elsif (s|^/||) {
	    $addr2 = &fetchpat('/');
	} else {
	    &Die("Invalid second address at line $.\n");
	}
	if ($addr2 =~ /^\d+$/) {
	    $addr1 .= "..$addr2";
	}
	else {
	    $addr1 .= "...$addr2";
	}
    }
d495 1
a495 2
    # Now we check for metacommands {, }, and ! and worry
    # about indentation.
d497 11
a507 27
    s/^[ \t]+//;
    # a { to keep vi happy
    if ($_ eq '}') {
	$indent -= 4;
	next;
    }
    if (s/^!//) {
	$if = 'unless';
	$else = "$r else $l\n";
    } else {
	$if = 'if';
	$else = '';
    }
    if (s/^{//) {	# a } to keep vi happy
	$indmod = 4;
	$redo = $_;
	$_ = '';
	$rmaybe = '';
    } else {
	$rmaybe = "\n$r";
	if ($addr2 || $addr1) {
	    $space = ' ' x $shiftwidth;
	} else {
	    $space = '';
	}
	$_ = &transmogrify();
    }
d509 1
a509 1
    # See if we can optimize to modifier form.
d511 2
a512 149
    if ($addr1) {
	if ($_ !~ /[\n{}]/ && $rmaybe && !$change &&
	  $_ !~ / if / && $_ !~ / unless /) {
	    s/;$/ $if $addr1;/;
	    $_ = substr($_,$shiftwidth,1000);
	} else {
	    $_ = "$if ($addr1) $l\n$change$_$rmaybe";
	}
	$change = '';
	next LINE;
    }
} continue {
    @@lines = split(/\n/,$_);
    for (@@lines) {
	unless (s/^ *<<--//) {
	    print BODY &tab;
	}
	print BODY $_, "\n";
    }
    $indent += $indmod;
    $indmod = 0;
    if ($redo) {
	$_ = $redo;
	$redo = '';
	redo LINE;
    }
}
if ($lastlinewaslabel++) {
    $indent += 4;
    print BODY &tab, ";\n";
    $indent -= 4;
}

if ($appendseen || $tseen || !$assumen) {
    $printit++ if $dseen || (!$assumen && !$assumep);
    print BODY &q(<<'EOT');
:	#ifdef SAWNEXT
:	}
:	continue {
:	#endif
:	#ifdef PRINTIT
:	#ifdef DSEEN
:	#ifdef ASSUMEP
:	    print if $printit++;
:	#else
:	    if ($printit)
:		{ print; }
:	    else
:		{ $printit++ unless $nflag; }
:	#endif
:	#else
:	    print if $printit;
:	#endif
:	#else
:	    print;
:	#endif
:	#ifdef TSEEN
:	    $tflag = 0;
:	#endif
:	#ifdef APPENDSEEN
:	    if ($atext) { chop $atext; print $atext; $atext = ''; }
:	#endif
EOT
}

print BODY &q(<<'EOT');
:	}
EOT

unless ($debug) {

    print &q(<<"EOT");
:	$startperl
:	eval 'exec $perlpath -S \$0 \${1+"\$@@"}'
:		if \$running_under_some_shell;
:	
EOT
    print"$opens\n" if $opens;
    seek(BODY, 0, 0) || die "Can't rewind temp file: $!\n";
    while (<BODY>) {
	/^[ \t]*$/ && next;
	/^#ifdef (\w+)/ && ((${lc $1} || &skip), next);
	/^#else/ && (&skip, next);
	/^#endif/ && next;
	s/^<><>//;
	print;
    }
}

&Cleanup;
exit;

sub Cleanup {
    unlink "/tmp/sperl$$";
}
sub Die {
    &Cleanup;
    die $_[0];
}
sub tab {
    "\t" x ($indent / 8) . ' ' x ($indent % 8);
}
sub make_filehandle {
    local($_) = $_[0];
    local($fname) = $_;
    if (!$seen{$fname}) {
	$_ = "FH_" . $_ if /^\d/;
	s/[^a-zA-Z0-9]/_/g;
	s/^_*//;
	$_ = "\U$_";
	if ($fhseen{$_}) {
	    for ($tmp = "a"; $fhseen{"$_$tmp"}; $a++) {}
	    $_ .= $tmp;
	}
	$fhseen{$_} = 1;
	$opens .= &q(<<"EOT");
:	open($_, '>$fname') || die "Can't create $fname: \$!";
EOT
	$seen{$fname} = $_;
    }
    $seen{$fname};
}

sub make_label {
    local($label) = @@_;
    $label =~ s/[^a-zA-Z0-9]/_/g;
    if ($label =~ /^[0-9_]/) { $label = 'L' . $label; }
    $label = substr($label,0,8);

    # Could be a reserved word, so capitalize it.
    substr($label,0,1) =~ y/a-z/A-Z/
      if $label =~ /^[a-z]/;

    $label;
}

sub transmogrify {
    {	# case
	if (/^d/) {
	    $dseen++;
	    chop($_ = &q(<<'EOT'));
:	<<--#ifdef PRINTIT
:	$printit = 0;
:	<<--#endif
:	next LINE;
EOT
	    $sawnext++;
	    next;
	}
d514 1
a514 29
	if (/^n/) {
	    chop($_ = &q(<<'EOT'));
:	<<--#ifdef PRINTIT
:	<<--#ifdef DSEEN
:	<<--#ifdef ASSUMEP
:	print if $printit++;
:	<<--#else
:	if ($printit)
:	    { print; }
:	else
:	    { $printit++ unless $nflag; }
:	<<--#endif
:	<<--#else
:	print if $printit;
:	<<--#endif
:	<<--#else
:	print;
:	<<--#endif
:	<<--#ifdef APPENDSEEN
:	if ($atext) {chop $atext; print $atext; $atext = '';}
:	<<--#endif
:	$_ = <>;
:	chop;
:	<<--#ifdef TSEEN
:	$tflag = 0;
:	<<--#endif
EOT
	    next;
	}
d516 1
a516 165
	if (/^a/) {
	    $appendseen++;
	    $command = $space . "\$atext .= <<'End_Of_Text';\n<<--";
	    $lastline = 0;
	    while (<>) {
		s/^[ \t]*//;
		s/^[\\]//;
		unless (s|\\$||) { $lastline = 1;}
		s/^([ \t]*\n)/<><>$1/;
		$command .= $_;
		$command .= '<<--';
		last if $lastline;
	    }
	    $_ = $command . "End_Of_Text";
	    last;
	}

	if (/^[ic]/) {
	    if (/^c/) { $change = 1; }
	    $addr1 = 1 if $addr1 eq '';
	    $addr1 = '$iter = (' . $addr1 . ')';
	    $command = $space .
	      "    if (\$iter == 1) { print <<'End_Of_Text'; }\n<<--";
	    $lastline = 0;
	    while (<>) {
		s/^[ \t]*//;
		s/^[\\]//;
		unless (s/\\$//) { $lastline = 1;}
		s/'/\\'/g;
		s/^([ \t]*\n)/<><>$1/;
		$command .= $_;
		$command .= '<<--';
		last if $lastline;
	    }
	    $_ = $command . "End_Of_Text";
	    if ($change) {
		$dseen++;
		$change = "$_\n";
		chop($_ = &q(<<"EOT"));
:	<<--#ifdef PRINTIT
:	$space\$printit = 0;
:	<<--#endif
:	${space}next LINE;
EOT
		$sawnext++;
	    }
	    last;
	}

	if (/^s/) {
	    $delim = substr($_,1,1);
	    $len = length($_);
	    $repl = $end = 0;
	    $inbracket = 0;
	    for ($i = 2; $i < $len; $i++) {
		$c = substr($_,$i,1);
		if ($c eq $delim) {
		    if ($inbracket) {
			substr($_, $i, 0) = '\\';
			$i++;
			$len++;
		    }
		    else {
			if ($repl) {
			    $end = $i;
			    last;
			} else {
			    $repl = $i;
			}
		    }
		}
		elsif ($c eq '\\') {
		    $i++;
		    if ($i >= $len) {
			$_ .= 'n';
			$_ .= <>;
			$len = length($_);
			$_ = substr($_,0,--$len);
		    }
		    elsif (substr($_,$i,1) =~ /^[n]$/) {
			;
		    }
		    elsif (!$repl &&
		      substr($_,$i,1) =~ /^[(){}\w]$/) {
			$i--;
			$len--;
			substr($_, $i, 1) = '';
		    }
		    elsif (!$repl &&
		      substr($_,$i,1) =~ /^[<>]$/) {
			substr($_,$i,1) = 'b';
		    }
		    elsif ($repl && substr($_,$i,1) =~ /^\d$/) {
			substr($_,$i-1,1) = '$';
		    }
		}
		elsif ($c eq '@@') {
		    substr($_, $i, 0) = '\\';
		    $i++;
		    $len++;
		}
		elsif ($c eq '&' && $repl) {
		    substr($_, $i, 0) = '$';
		    $i++;
		    $len++;
		}
		elsif ($c eq '$' && $repl) {
		    substr($_, $i, 0) = '\\';
		    $i++;
		    $len++;
		}
		elsif ($c eq '[' && !$repl) {
		    $i++ if substr($_,$i,1) eq '^';
		    $i++ if substr($_,$i,1) eq ']';
		    $inbracket = 1;
		}
		elsif ($c eq ']') {
		    $inbracket = 0;
		}
		elsif ($c eq "\t") {
		    substr($_, $i, 1) = '\\t';
		    $i++;
		    $len++;
		}
		elsif (!$repl && index("()+",$c) >= 0) {
		    substr($_, $i, 0) = '\\';
		    $i++;
		    $len++;
		}
	    }
	    &Die("Malformed substitution at line $.\n")
	      unless $end;
	    $pat = substr($_, 0, $repl + 1);
	    $repl = substr($_, $repl+1, $end-$repl-1);
	    $end = substr($_, $end + 1, 1000);
	    &simplify($pat);
	    $subst = "$pat$repl$delim";
	    $cmd = '';
	    while ($end) {
		if ($end =~ s/^g//) {
		    $subst .= 'g';
		    next;
		}
		if ($end =~ s/^p//) {
		    $cmd .= ' && (print)';
		    next;
		}
		if ($end =~ s/^w[ \t]*//) {
		    $fh = &make_filehandle($end);
		    $cmd .= " && (print $fh \$_)";
		    $end = '';
		    next;
		}
		&Die("Unrecognized substitution command".
		  "($end) at line $.\n");
	    }
	    chop ($_ = &q(<<"EOT"));
:	<<--#ifdef TSEEN
:	$subst && \$tflag++$cmd;
:	<<--#else
:	$subst$cmd;
:	<<--#endif
EOT
	    next;
	}
d518 1
a518 4
	if (/^p/) {
	    $_ = 'print;';
	    next;
	}
d520 4
a523 6
	if (/^w/) {
	    s/^w[ \t]*//;
	    $fh = &make_filehandle($_);
	    $_ = "print $fh \$_;";
	    next;
	}
d525 1
a525 7
	if (/^r/) {
	    $appendseen++;
	    s/^r[ \t]*//;
	    $file = $_;
	    $_ = "\$atext .= `cat $file 2>/dev/null`;";
	    next;
	}
d527 1
a527 4
	if (/^P/) {
	    $_ = 'print $1 if /^(.*)/;';
	    next;
	}
d529 13
a541 9
	if (/^D/) {
	    chop($_ = &q(<<'EOT'));
:	s/^.*\n?//;
:	redo LINE if $_;
:	next LINE;
EOT
	    $sawnext++;
	    next;
	}
d543 1
a543 12
	if (/^N/) {
	    chop($_ = &q(<<'EOT'));
:	$_ .= "\n";
:	$len1 = length;
:	$_ .= <>;
:	chop if $len1 < length;
:	<<--#ifdef TSEEN
:	$tflag = 0;
:	<<--#endif
EOT
	    next;
	}
d545 2
a546 4
	if (/^h/) {
	    $_ = '$hold = $_;';
	    next;
	}
d548 1
a548 4
	if (/^H/) {
	    $_ = '$hold .= "\n", $hold .= $_;';
	    next;
	}
d550 3
a552 4
	if (/^g/) {
	    $_ = '$_ = $hold;';
	    next;
	}
d554 1
a554 4
	if (/^G/) {
	    $_ = '$_ .= "\n", $_ .= $hold;';
	    next;
	}
d556 1
a556 4
	if (/^x/) {
	    $_ = '($_, $hold) = ($hold, $_);';
	    next;
	}
d558 1
a558 5
	if (/^b$/) {
	    $_ = 'next LINE;';
	    $sawnext++;
	    next;
	}
d560 8
a567 10
	if (/^b/) {
	    s/^b[ \t]*//;
	    $lab = &make_label($_);
	    if ($lab eq $toplabel) {
		$_ = 'redo LINE;';
	    } else {
		$_ = "goto $lab;";
	    }
	    next;
	}
d569 4
a572 6
	if (/^t$/) {
	    $_ = 'next LINE if $tflag;';
	    $sawnext++;
	    $tseen++;
	    next;
	}
d574 13
a586 12
	if (/^t/) {
	    s/^t[ \t]*//;
	    $lab = &make_label($_);
	    $_ = q/if ($tflag) {$tflag = 0; /;
	    if ($lab eq $toplabel) {
		$_ .= 'redo LINE;}';
	    } else {
		$_ .= "goto $lab;}";
	    }
	    $tseen++;
	    next;
	}
d588 4
a591 9
	if (/^y/) {
	    s/abcdefghijklmnopqrstuvwxyz/a-z/g;
	    s/ABCDEFGHIJKLMNOPQRSTUVWXYZ/A-Z/g;
	    s/abcdef/a-f/g;
	    s/ABCDEF/A-F/g;
	    s/0123456789/0-9/g;
	    s/01234567/0-7/g;
	    $_ .= ';';
	}
d593 11
a603 4
	if (/^=/) {
	    $_ = 'print $.;';
	    next;
	}
d605 10
a614 8
	if (/^q/) {
	    chop($_ = &q(<<'EOT'));
:	close(ARGV);
:	@@ARGV = ();
:	next LINE;
EOT
	    $sawnext++;
	    next;
d616 1
a616 6
    } continue {
	if ($space) {
	    s/^/$space/;
	    s/(\n)(.)/$1$space$2/g;
	}
	last;
a617 2
    $_;
}
d619 12
a630 76
sub fetchpat {
    local($outer) = @@_;
    local($addr) = $outer;
    local($inbracket);
    local($prefix,$delim,$ch);

    # Process pattern one potential delimiter at a time.

    DELIM: while (s#^([^\]+(|)[\\/]*)([]+(|)[\\/])##) {
	$prefix = $1;
	$delim = $2;
	if ($delim eq '\\') {
	    s/(.)//;
	    $ch = $1;
	    $delim = '' if $ch =~ /^[(){}A-Za-mo-z]$/;
	    $ch = 'b' if $ch =~ /^[<>]$/;
	    $delim .= $ch;
	}
	elsif ($delim eq '[') {
	    $inbracket = 1;
	    s/^\^// && ($delim .= '^');
	    s/^]// && ($delim .= ']');
	}
	elsif ($delim eq ']') {
	    $inbracket = 0;
	}
	elsif ($inbracket || $delim ne $outer) {
	    $delim = '\\' . $delim;
	}
	$addr .= $prefix;
	$addr .= $delim;
	if ($delim eq $outer && !$inbracket) {
	    last DELIM;
	}
    }
    $addr =~ s/\t/\\t/g;
    $addr =~ s/\@@/\\@@/g;
    &simplify($addr);
    $addr;
}

sub q {
    local($string) = @@_;
    local($*) = 1;
    $string =~ s/^:\t?//g;
    $string;
}

sub simplify {
    $_[0] =~ s/_a-za-z0-9/\\w/ig;
    $_[0] =~ s/a-z_a-z0-9/\\w/ig;
    $_[0] =~ s/a-za-z_0-9/\\w/ig;
    $_[0] =~ s/a-za-z0-9_/\\w/ig;
    $_[0] =~ s/_0-9a-za-z/\\w/ig;
    $_[0] =~ s/0-9_a-za-z/\\w/ig;
    $_[0] =~ s/0-9a-z_a-z/\\w/ig;
    $_[0] =~ s/0-9a-za-z_/\\w/ig;
    $_[0] =~ s/\[\\w\]/\\w/g;
    $_[0] =~ s/\[^\\w\]/\\W/g;
    $_[0] =~ s/\[0-9\]/\\d/g;
    $_[0] =~ s/\[^0-9\]/\\D/g;
    $_[0] =~ s/\\d\\d\*/\\d+/g;
    $_[0] =~ s/\\D\\D\*/\\D+/g;
    $_[0] =~ s/\\w\\w\*/\\w+/g;
    $_[0] =~ s/\\t\\t\*/\\t+/g;
    $_[0] =~ s/(\[.[^]]*\])\1\*/$1+/g;
    $_[0] =~ s/([\w\s!@@#%^&-=,:;'"])\1\*/$1+/g;
}

sub skip {
    local($level) = 0;

    while(<BODY>) {
	/^#ifdef/ && $level++;
	/^#else/  && !$level && return;
	/^#endif/ && !$level-- && return;
d632 2
d635 6
a640 1
    die "Unterminated `#ifdef' conditional\n";
d642 1403
a2044 1
!NO!SUBS!
d2048 9
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d32 6
a37 2
\$startperl = "$Config{startperl}";
\$perlpath = "$Config{perlpath}";
@


1.3
log
@perl5.005_03 (stock)
@
text
@d54 1
a54 1
I<S2p> takes a sed script specified on the command line (or from
d96 1
a96 1
S2p uses no environment variables.
d107 1
a107 1
 
d342 1
a346 1
}
d555 5
d805 1
@


1.2
log
@perl 5.004_04
@
text
@d5 1
d16 1
d140 1
a140 1
    open(BODY,">/tmp/sperl$$") ||
a347 2
close BODY;

a348 17
    open(HEAD,">/tmp/sperl2$$.c")
      || &Die("Can't open temp file 2: $!\n");
    print HEAD "#define PRINTIT\n"	if $printit;
    print HEAD "#define APPENDSEEN\n"	if $appendseen;
    print HEAD "#define TSEEN\n"	if $tseen;
    print HEAD "#define DSEEN\n"	if $dseen;
    print HEAD "#define ASSUMEN\n"	if $assumen;
    print HEAD "#define ASSUMEP\n"	if $assumep;
    print HEAD "#define TOPLABEL\n"	if $toplabel;
    print HEAD "#define SAWNEXT\n"	if $sawnext;
    if ($opens) {print HEAD "$opens\n";}
    open(BODY,"/tmp/sperl$$")
      || &Die("Can't reopen temp file: $!\n");
    while (<BODY>) {
	print HEAD $_;
    }
    close HEAD;
d356 2
a357 2
    open(BODY,"cc -E /tmp/sperl2$$.c |") ||
	&Die("Can't reopen temp file: $!\n");
a358 1
	/^# [0-9]/ && next;
d360 3
d372 1
a372 2
    chdir "/tmp";
    unlink "sperl$$", "sperl2$$", "sperl2$$.c";
a589 1
	    $dol = '$';
d674 1
a674 1
	    $_ = '$hold .= "\n"; $hold .= $_;';
d684 1
a684 1
	    $_ = '$_ .= "\n"; $_ .= $hold;';
d832 11
d848 1
@


1.1
log
@Initial revision
@
text
@d15 3
a17 4
chdir(dirname($0));
($file = basename($0)) =~ s/\.PL$//;
$file =~ s/\.pl$//
	if ($^O eq 'VMS' or $^O eq 'os2');  # "case-forgiving"
d27 3
a29 3
$Config{'startperl'}
    eval 'exec perl -S \$0 "\$@@"'
	if 0;
d31 1
d42 72
d369 1
a369 1
:	eval 'exec perl -S \$0 \${1+"\$@@"}'
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a4 1
use Cwd;
d15 4
a18 4
$origdir = cwd;
chdir dirname($0);
$file = basename($0, '.PL');
$file .= '.com' if $^O eq 'VMS';
d28 3
a30 3
$Config{startperl}
    eval 'exec $Config{perlpath} -S \$0 \${1+"\$@@"}'
	if \$running_under_some_shell;
a31 1
\$perlpath = "$Config{perlpath}";
a41 72
=head1 NAME

s2p - Sed to Perl translator

=head1 SYNOPSIS

B<s2p [options] filename>

=head1 DESCRIPTION

I<S2p> takes a sed script specified on the command line (or from
standard input) and produces a comparable I<perl> script on the
standard output.

=head2 Options

Options include:

=over 5

=item B<-DE<lt>numberE<gt>>

sets debugging flags.

=item B<-n>

specifies that this sed script was always invoked with a B<sed -n>.
Otherwise a switch parser is prepended to the front of the script.

=item B<-p>

specifies that this sed script was never invoked with a B<sed -n>.
Otherwise a switch parser is prepended to the front of the script.

=back

=head2 Considerations

The perl script produced looks very sed-ish, and there may very well
be better ways to express what you want to do in perl.  For instance,
s2p does not make any use of the split operator, but you might want
to.

The perl script you end up with may be either faster or slower than
the original sed script.  If you're only interested in speed you'll
just have to try it both ways.  Of course, if you want to do something
sed doesn't do, you have no choice.  It's often possible to speed up
the perl script by various methods, such as deleting all references to
$\ and chop.

=head1 ENVIRONMENT

S2p uses no environment variables.

=head1 AUTHOR

Larry Wall E<lt>F<larry@@wall.org>E<gt>

=head1 FILES

=head1 SEE ALSO

 perl	The perl compiler/interpreter
 
 a2p	awk to perl translator

=head1 DIAGNOSTICS

=head1 BUGS

=cut

d66 1
a66 1
    open(BODY,"+>/tmp/sperl$$") ||
d274 2
d277 17
d297 1
a297 1
:	eval 'exec $perlpath -S \$0 \${1+"\$@@"}'
d301 2
a302 2
    print"$opens\n" if $opens;
    seek(BODY, 0, 0) || die "Can't rewind temp file: $!\n";
d304 1
a305 3
	/^#ifdef (\w+)/ && ((${lc $1} || &skip), next);
	/^#else/ && (&skip, next);
	/^#endif/ && next;
d315 2
a316 1
    unlink "/tmp/sperl$$";
d534 1
d619 1
a619 1
	    $_ = '$hold .= "\n", $hold .= $_;';
d629 1
a629 1
	    $_ = '$_ .= "\n", $_ .= $hold;';
a776 11
sub skip {
    local($level) = 0;

    while(<BODY>) {
	/^#ifdef/ && $level++;
	/^#else/  && !$level && return;
	/^#endif/ && !$level-- && return;
    }

    die "Unterminated `#ifdef' conditional\n";
}
a781 1
chdir $origdir;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d54 1
a54 1
I<s2p> takes a sed script specified on the command line (or from
d96 1
a96 1
s2p uses no environment variables.
d107 1
a107 1

a341 1
}
d346 1
a554 5
		elsif ($c eq '@@') {
		    substr($_, $i, 0) = '\\';
		    $i++;
		    $len++;
		}
a799 1
    $addr =~ s/\@@/\\@@/g;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d32 2
a33 6
(\$startperl = <<'/../') =~ s/\\s*\\z//;
$Config{startperl}
/../
(\$perlpath = <<'/../') =~ s/\\s*\\z//;
$Config{perlpath}
/../
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d1 1
a1 1
#!/usr/bin/perl
a5 21
use subs qw(link);

sub link { # This is a cut-down version of installperl:link().
    my($from,$to) = @@_;
    my($success) = 0;

    eval {
	CORE::link($from, $to)
	    ? $success++
	    : ($from =~ m#^/afs/# || $to =~ m#^/afs/#)
	      ? die "AFS"  # okay inside eval {}
	      : die "Couldn't link $from to $to: $!\n";
    };
    if ($@@) {
	require File::Copy;
	File::Copy::copy($from, $to)
	    ? $success++
	    : warn "Couldn't copy $from to $to: $!\n";
    }
    $success;
}
a31 2
my \$startperl;
my \$perlpath;
d44 3
a46 9
$0 =~ s/^.*?(\w+)[\.\w]*$/$1/;

# (p)sed - a stream editor
# History:  Aug 12 2000: Original version.
#           Mar 25 2002: Rearrange generated Perl program.

use strict;
use integer;
use Symbol;
d50 1
a50 1
psed - a stream editor
d54 1
a54 4
   psed [-an] script [file ...]
   psed [-an] [-e script] [-f script-file] [file ...]

   s2p  [-an] [-e script] [-f script-file]
d58 3
a60 11
A stream editor reads the input stream consisting of the specified files
(or standard input, if none are given), processes is line by line by
applying a script consisting of edit commands, and writes resulting lines
to standard output. The filename `C<->' may be used to read standard input.

The edit script is composed from arguments of B<-e> options and
script-files, in the given order. A single script argument may be specified
as the first parameter.

If this program is invoked with the name F<s2p>, it will act as a
sed-to-Perl translator. See L<"sed Script Translation">.
d62 1
a62 1
B<sed> returns an exit code of 0 on success or >0 if an error occurred.
d64 1
a64 1
=head1 OPTIONS
d66 1
a66 1
=over 4
d68 1
a68 1
=item B<-a>
d70 1
a70 13
A file specified as argument to the B<w> edit command is by default
opened before input processing starts. Using B<-a>, opening of such
files is delayed until the first line is actually written to the file.

=item B<-e> I<script>

The editing commands defined by I<script> are appended to the script.
Multiple commands must be separated by newlines.

=item B<-f> I<script-file>

Editing commands from the specified I<script-file> are read and appended
to the script.
d74 2
a75 8
By default, a line is written to standard output after the editing script
has been applied to it. The B<-n> option suppresses automatic printing.

=back

=head1 COMMANDS

B<sed> command syntax is defined as
d77 1
a77 1
Z<> Z<> Z<> Z<>[I<address>[B<,>I<address>]][B<!>]I<function>[I<argument>]
d79 2
a80 40
with whitespace being permitted before or after addresses, and between
the function character and the argument. The I<address>es and the
address inverter (C<!>) are used to restrict the application of a
command to the selected line(s) of input.

Each command must be on a line of its own, except where noted in
the synopses below.

The edit cycle performed on each input line consist of reading the line
(without its trailing newline character) into the I<pattern space>,
applying the applicable commands of the edit script, writing the final
contents of the pattern space and a newline to the standard output.
A I<hold space> is provided for saving the contents of the
pattern space for later use.

=head2 Addresses

A sed address is either a line number or a pattern, which may be combined
arbitrarily to construct ranges. Lines are numbered across all input files.

Any address may be followed by an exclamation mark (`C<!>'), selecting
all lines not matching that address.

=over 4

=item I<number>

The line with the given number is selected.

=item B<$>

A dollar sign (C<$>) is the line number of the last line of the input stream.

=item B</>I<regular expression>B</>

A pattern address is a basic regular expression (see 
L<"Basic Regular Expressions">), between the delimiting character C</>.
Any other character except C<\> or newline may be used to delimit a
pattern address when the initial delimiter is prefixed with a
backslash (`C<\>').
d84 1
a84 1
If no address is given, the command selects every line.
d86 11
a96 2
If one address is given, it selects the line (or lines) matching the
address.
d98 1
a98 9
Two addresses select a range that begins whenever the first address
matches, and ends (including that line) when the second address matches.
If the first (second) address is a matching pattern, the second 
address is not applied to the very same line to determine the end of
the range. Likewise, if the second address is a matching pattern, the
first address is not applied to the very same line to determine the
begin of another range. If both addresses are line numbers,
and the second line number is less than the first line number, then
only the first line is selected.
d100 1
d102 1
a102 1
=head2 Functions
d104 1
a104 2
The maximum permitted number of addresses is indicated with each
function synopsis below.
d106 1
a106 4
The argument I<text> consists of one or more lines following the command.
Embedded newlines in I<text> must be preceded with a backslash.  Other
backslashes in I<text> are deleted and the following character is taken
literally.
d108 1
a108 3
=over 4

=cut
d110 1
a110 10
my %ComTab;
my %GenKey;
#--------------------------------------------------------------------------
$ComTab{'a'}=[ 1, 'txt', \&Emit,       '{ push( @@Q, <<'."'TheEnd' ) }\n" ]; #ok

=item [1addr]B<a\> I<text>

Write I<text> (which must start on the line following the command)
to standard output immediately before reading the next line
of input, either by executing the B<N> function or by beginning a new cycle.
d112 1
a112 1
=cut
d114 1
a114 2
#--------------------------------------------------------------------------
$ComTab{'b'}=[ 2, 'str', \&Branch,     '{ goto XXX; }'                   ]; #ok
d116 1
a116 4
=item [2addr]B<b> [I<label>]

Branch to the B<:> function with the specified I<label>. If no label
is given, branch to the end of the script.
d120 21
a140 19
#--------------------------------------------------------------------------
$ComTab{'c'}=[ 2, 'txt', \&Change,     <<'-X-'                           ]; #ok
{ print <<'TheEnd'; } $doPrint = 0; goto EOS;
-X-
### continue OK => next CYCLE;

=item [2addr]B<c\> I<text>

The line, or range of lines, selected by the address is deleted. 
The I<text> (which must start on the line following the command)
is written to standard output. With an address range, this occurs at
the end of the range.

=cut

#--------------------------------------------------------------------------
$ComTab{'d'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ $doPrint = 0;
  goto EOS;
a141 2
-X-
### continue OK => next CYCLE;
d143 74
a216 1
=item [2addr]B<d>
d218 1
a218 1
Deletes the pattern space and starts the next cycle.
d220 29
a248 1
=cut
d250 2
a251 7
#--------------------------------------------------------------------------
$ComTab{'D'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ s/^.*\n?//;
  if(length($_)){ goto BOS } else { goto EOS }
}
-X-
### continue OK => next CYCLE;
d253 27
a279 1
=item [2addr]B<D>
d281 1
a281 3
Deletes the pattern space through the first embedded newline or to the end.
If the pattern space becomes empty, a new cycle is started, otherwise
execution of the script is restarted.
d283 149
a431 1
=cut
d433 29
a461 2
#--------------------------------------------------------------------------
$ComTab{'g'}=[ 2, '',    \&Emit,       '{ $_ = $Hold };'                 ]; #ok
d463 165
a627 1
=item [2addr]B<g>
d629 4
a632 1
Replace the contents of the pattern space with the hold space.
d634 6
a639 1
=cut
d641 7
a647 2
#--------------------------------------------------------------------------
$ComTab{'G'}=[ 2, '',    \&Emit,       '{ $_ .= "\n"; $_ .= $Hold };'    ]; #ok
d649 4
a652 1
=item [2addr]B<G>
d654 9
a662 1
Append a newline and the contents of the hold space to the pattern space.
d664 12
a675 1
=cut
d677 4
a680 2
#--------------------------------------------------------------------------
$ComTab{'h'}=[ 2, '',    \&Emit,       '{ $Hold = $_ }'                  ]; #ok
d682 4
a685 1
=item [2addr]B<h>
d687 4
a690 1
Replace the contents of the hold space with the pattern space.
d692 4
a695 1
=cut
d697 4
a700 2
#--------------------------------------------------------------------------
$ComTab{'H'}=[ 2, '',    \&Emit,       '{ $Hold .= "\n"; $Hold .= $_; }' ]; #ok
d702 5
a706 1
=item [2addr]B<H>
d708 10
a717 1
Append a newline and the contents of the pattern space to the hold space.
d719 6
a724 1
=cut
d726 12
a737 2
#--------------------------------------------------------------------------
$ComTab{'i'}=[ 1, 'txt', \&Emit,       '{ print <<'."'TheEnd' }\n"       ]; #ok
d739 9
a747 1
=item [1addr]B<i\> I<text>
d749 4
a752 2
Write the I<text> (which must start on the line following the command)
to standard output.
d754 15
a768 278
=cut

#--------------------------------------------------------------------------
$ComTab{'l'}=[ 2, '',    \&Emit,       '{ _l() }'                        ]; #okUTF8

=item [2addr]B<l>

Print the contents of the pattern space: non-printable characters are
shown in C-style escaped form; long lines are split and have a trailing
`C<\>' at the point of the split; the true end of a line is marked with
a `C<$>'. Escapes are: `\a', `\t', `\n', `\f', `\r', `\e' for
BEL, HT, LF, FF, CR, ESC, respectively, and `\' followed by a three-digit
octal number for all other non-printable characters.

=cut

#--------------------------------------------------------------------------
$ComTab{'n'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ print $_, "\n" if $doPrint;
  printQ() if @@Q;
  $CondReg = 0;
  last CYCLE unless getsARGV();
  chomp();
}
-X-

=item [2addr]B<n>

If automatic printing is enabled, write the pattern space to the standard
output. Replace the pattern space with the next line of input. If
there is no more input, processing is terminated.

=cut

#--------------------------------------------------------------------------
$ComTab{'N'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ printQ() if @@Q;
  $CondReg = 0;
  last CYCLE unless getsARGV( $h );
  chomp( $h );
  $_ .= "\n$h";
}
-X-

=item [2addr]B<N>

Append a newline and the next line of input to the pattern space. If
there is no more input, processing is terminated.

=cut

#--------------------------------------------------------------------------
$ComTab{'p'}=[ 2, '',    \&Emit,       '{ print $_, "\n"; }'             ]; #ok

=item [2addr]B<p>

Print the pattern space to the standard output. (Use the B<-n> option
to suppress automatic printing at the end of a cycle if you want to
avoid double printing of lines.)

=cut

#--------------------------------------------------------------------------
$ComTab{'P'}=[ 2, '',    \&Emit,       <<'-X-'                           ]; #ok
{ if( /^(.*)/ ){ print $1, "\n"; } }
-X-

=item [2addr]B<P>

Prints the pattern space through the first embedded newline or to the end.

=cut

#--------------------------------------------------------------------------
$ComTab{'q'}=[ 1, '',    \&Emit,       <<'-X-'                           ]; #ok
{ print $_, "\n" if $doPrint;
  last CYCLE;
}
-X-

=item [1addr]B<q>

Branch to the end of the script and quit without starting a new cycle.

=cut

#--------------------------------------------------------------------------
$ComTab{'r'}=[ 1, 'str', \&Emit,       "{ _r( '-X-' ) }"                 ]; #ok

=item [1addr]B<r> I<file>

Copy the contents of the I<file> to standard output immediately before
the next attempt to read a line of input. Any error encountered while
reading I<file> is silently ignored.

=cut

#--------------------------------------------------------------------------
$ComTab{'s'}=[ 2, 'sub', \&Emit,       ''                                ]; #ok

=item [2addr]B<s/>I<regular expression>B</>I<replacement>B</>I<flags>

Substitute the I<replacement> string for the first substring in
the pattern space that matches the I<regular expression>.
Any character other than backslash or newline can be used instead of a 
slash to delimit the regular expression and the replacement.
To use the delimiter as a literal character within the regular expression
and the replacement, precede the character by a backslash (`C<\>').

Literal newlines may be embedded in the replacement string by
preceding a newline with a backslash.

Within the replacement, an ampersand (`C<&>') is replaced by the string
matching the regular expression. The strings `C<\1>' through `C<\9>' are
replaced by the corresponding subpattern (see L<"Basic Regular Expressions">).
To get a literal `C<&>' or `C<\>' in the replacement text, precede it
by a backslash.

The following I<flags> modify the behaviour of the B<s> command:

=over 8

=item B<g>

The replacement is performed for all matching, non-overlapping substrings
of the pattern space.

=item B<1>..B<9>

Replace only the n-th matching substring of the pattern space.

=item B<p>

If the substitution was made, print the new value of the pattern space.

=item B<w> I<file>

If the substitution was made, write the new value of the pattern space
to the specified file.

=back

=cut

#--------------------------------------------------------------------------
$ComTab{'t'}=[ 2, 'str', \&Branch,     '{ goto XXX if _t() }'            ]; #ok

=item [2addr]B<t> [I<label>]

Branch to the B<:> function with the specified I<label> if any B<s>
substitutions have been made since the most recent reading of an input line
or execution of a B<t> function. If no label is given, branch to the end of
the script. 


=cut

#--------------------------------------------------------------------------
$ComTab{'w'}=[ 2, 'str', \&Write,      "{ _w( '-X-' ) }"                 ]; #ok

=item [2addr]B<w> I<file>

The contents of the pattern space are written to the I<file>.

=cut

#--------------------------------------------------------------------------
$ComTab{'x'}=[ 2, '',    \&Emit,       '{ ($Hold, $_) = ($_, $Hold) }'   ]; #ok

=item [2addr]B<x>

Swap the contents of the pattern space and the hold space.

=cut

#--------------------------------------------------------------------------
$ComTab{'y'}=[ 2, 'tra', \&Emit,       ''                                ]; #ok
=item [2addr]B<y>B</>I<string1>B</>I<string2>B</>

In the pattern space, replace all characters occuring in I<string1> by the
character at the corresponding position in I<string2>. It is possible
to use any character (other than a backslash or newline) instead of a
slash to delimit the strings.  Within I<string1> and I<string2>, a
backslash followed by any character other than a newline is that literal
character, and a backslash followed by an `n' is replaced by a newline
character.

=cut

#--------------------------------------------------------------------------
$ComTab{'='}=[ 1, '',    \&Emit,       '{ print "$.\n" }'                ]; #ok

=item [1addr]B<=>

Prints the current line number on the standard output.

=cut

#--------------------------------------------------------------------------
$ComTab{':'}=[ 0, 'str', \&Label,      ''                                ]; #ok
 
=item [0addr]B<:> [I<label>]

The command specifies the position of the I<label>. It has no other effect.

=cut

#--------------------------------------------------------------------------
$ComTab{'{'}=[ 2, '',    \&BeginBlock, '{'                               ]; #ok
$ComTab{'}'}=[ 0, '',    \&EndBlock,   ';}'                              ]; #ok
# ';' to avoid warning on empty {}-block

=item [2addr]B<{> [I<command>]

=item [0addr]B<}>

These two commands begin and end a command list. The first command may
be given on the same line as the opening B<{> command. The commands
within the list are jointly selected by the address(es) given on the
B<{> command (but may still have individual addresses).

=cut

#--------------------------------------------------------------------------
$ComTab{'#'}=[ 0, 'str', \&Comment,    ''                                ]; #ok

=item [0addr]B<#> [I<comment>]

The entire line is ignored (treated as a comment). If, however, the first
two characters in the script are `C<#n>', automatic printing of output is
suppressed, as if the B<-n> option were given on the command line.

=back

=cut

use vars qw{ $isEOF $Hold %wFiles @@Q $CondReg $doPrint };

my $useDEBUG    = exists( $ENV{PSEDDEBUG} );
my $useEXTBRE   = $ENV{PSEDEXTBRE} || '';
$useEXTBRE =~ s/[^<>wWyB]//g; # gawk RE's handle these

my $doAutoPrint = 1;          # automatic printing of pattern space (-n => 0)
my $doOpenWrite = 1;          # open w command output files at start (-a => 0)
my $svOpenWrite = 0;          # save $doOpenWrite
my $doGenerate  = $0 eq 's2p';

# Collected and compiled script
#
my( @@Commands, %Defined, @@BlockStack, %Label, $labNum, $Code, $Func );
$Code = '';

##################
#  Compile Time
#
# Labels
# 
# Error handling
#
sub Warn($;$){
    my( $msg, $loc ) = @@_;
    $loc ||= '';
    $loc .= ': ' if length( $loc );
    warn( "$0: $loc$msg\n" );
}

$labNum = 0;
sub newLabel(){
    return 'L_'.++$labNum;
}

# safeHere: create safe here delimiter and  modify opcode and argument
#
sub safeHere($$){
    my( $codref, $argref ) = @@_;
    my $eod = 'EOD000';
    while( $$argref =~ /^$eod$/m ){
        $eod++;
d770 1
a770 2
    $$codref =~ s/TheEnd/$eod/e;
    $$argref .= "$eod\n"; 
d773 76
a848 12
# Emit: create address logic and emit command
#
sub Emit($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
    my $cond = '';
    if( defined( $addr1 ) ){
        if( defined( $addr2 ) ){
	    $addr1 .= $addr2 =~ /^\d+$/ ? "..$addr2" : "...$addr2";
        } else {
	    $addr1 .= ' == $.' if $addr1 =~ /^\d+$/;
	}
	$cond = $negated ? "unless( $addr1 )\n" : "if( $addr1 )\n";
d851 1
a851 14
    if( $opcode eq '' ){
	$Code .= "$cond$arg\n";

    } elsif( $opcode =~ s/-X-/$arg/e ){
	$Code .= "$cond$opcode\n";

    } elsif( $opcode =~ /TheEnd/ ){
	safeHere( \$opcode, \$arg );
	$Code .= "$cond$opcode$arg";

    } else {
	$Code .= "$cond$opcode\n";
    }
    0;
d853 1
d855 2
a856 1422
# Write (w command, w flag): store pathname
#
sub Write($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $path, $fl ) = @@_;
    $wFiles{$path} = '';
    Emit( $addr1, $addr2, $negated, $opcode, $path, $fl );
}


# Label (: command): label definition
#
sub Label($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $lab, $fl ) = @@_;
    my $rc = 0;
    $lab =~ s/\s+//;
    if( length( $lab ) ){
	my $h;
	if( ! exists( $Label{$lab} ) ){
	    $h = $Label{$lab}{name} = newLabel();
        } else {
	    $h = $Label{$lab}{name};
	    if( exists( $Label{$lab}{defined} ) ){
		my $dl = $Label{$lab}{defined};
		Warn( "duplicate label $lab (first defined at $dl)", $fl );
		$rc = 1;
	    }
	}
        $Label{$lab}{defined} = $fl;
	$Code .= "$h:;\n";
    }
    $rc;
}

# BeginBlock ({ command): push block start
#
sub BeginBlock($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
    push( @@BlockStack, [ $fl, $addr1, $addr2, $negated ] );
    Emit( $addr1, $addr2, $negated, $opcode, $arg, $fl );
}

# EndBlock (} command): check proper nesting
#
sub EndBlock($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
    my $rc;
    my $jcom = pop( @@BlockStack );
    if( defined( $jcom ) ){
	$rc = Emit( $addr1, $addr2, $negated, $opcode, $arg, $fl );
    } else {
	Warn( "unexpected `}'", $fl );
	$rc = 1;
    }
    $rc;
}

# Branch (t, b commands): check or create label, substitute default
#
sub Branch($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $lab, $fl ) = @@_;
    $lab =~ s/\s+//; # no spaces at end
    my $h;
    if( length( $lab ) ){
	if( ! exists( $Label{$lab} ) ){
	    $h = $Label{$lab}{name} = newLabel();
        } else {
	    $h = $Label{$lab}{name};
	}
	push( @@{$Label{$lab}{used}}, $fl );
    } else {
	$h = 'EOS';
    }
    $opcode =~ s/XXX/$h/e;
    Emit( $addr1, $addr2, $negated, $opcode, '', $fl );
}

# Change (c command): is special due to range end watching
#
sub Change($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
    my $kwd = $negated ? 'unless' : 'if';
    if( defined( $addr2 ) ){
        $addr1 .= $addr2 =~ /^\d+$/ ? "..$addr2" : "...$addr2";
	if( ! $negated ){
	    $addr1  = '$icnt = ('.$addr1.')';
	    $opcode = 'if( $icnt =~ /E0$/ )' . $opcode;
	}
    } else {
	$addr1 .= ' == $.' if $addr1 =~ /^\d+$/;
    }
    safeHere( \$opcode, \$arg );
    $Code .= "$kwd( $addr1 ){\n  $opcode$arg}\n";
    0;
}


# Comment (# command): A no-op. Who would've thought that!
#
sub Comment($$$$$$){
    my( $addr1, $addr2, $negated, $opcode, $arg, $fl ) = @@_;
### $Code .= "# $arg\n";
    0;
}


sub stripRegex($$){
    my( $del, $sref ) = @@_;
    my $regex = $del;
    print "stripRegex:$del:$$sref:\n" if $useDEBUG;
    while( $$sref =~ s{^(.*?)(\\*)\Q$del\E(\s*)}{}s ){
        my $sl = $2;
	$regex .= $1.$sl.$del;
	if( length( $sl ) % 2 == 0 ){
	    return $regex;
	}
	$regex .= $3;
    }
    undef();
}

# stripTrans: take a <del> terminated string from y command
#   honoring and cleaning up of \-escaped <del>'s
#
sub stripTrans($$){
    my( $del, $sref ) = @@_;
    my $t = '';
    print "stripTrans:$del:$$sref:\n" if $useDEBUG;
    while( $$sref =~ s{^(.*?)(\\*)\Q$del\E}{}s ){
        my $sl = $2;
	$t .= $1;
	if( length( $sl ) % 2 == 0 ){
	    $t .= $sl;
	    $t =~ s/\\\\/\\/g;
	    return $t;
	}
	chop( $sl );
	$t .= $sl.$del.$3;
    }
    undef();
}

# makey - construct Perl y/// from sed y///
#
sub makey($$$){
    my( $fr, $to, $fl ) = @@_;
    my $error = 0;

    # Ensure that any '-' is up front.
    # Diagnose duplicate contradicting mappings
    my %tr;
    for( my $i = 0; $i < length($fr); $i++ ){
	my $fc = substr($fr,$i,1);
	my $tc = substr($to,$i,1);
	if( exists( $tr{$fc} ) && $tr{$fc} ne $tc ){
	    Warn( "ambiguos translation for character `$fc' in `y' command",
		  $fl );
	    $error++;
	}
	$tr{$fc} = $tc;
    }
    $fr = $to = '';
    if( exists( $tr{'-'} ) ){
	( $fr, $to ) = ( '-', $tr{'-'} );
	delete( $tr{'-'} );
    } else {
	$fr = $to = '';
    }
    # might just as well sort it...
    for my $fc ( sort keys( %tr ) ){
	$fr .= $fc;
	$to .= $tr{$fc};
    }
    # make embedded delimiters and newlines safe
    $fr =~ s/([{}])/\$1/g;
    $to =~ s/([{}])/\$1/g;
    $fr =~ s/\n/\\n/g;
    $to =~ s/\n/\\n/g;
    return $error ? undef() : "{ y{$fr}{$to}; }";
}

######
# makes - construct Perl s/// from sed s///
#
sub makes($$$$$$$){
    my( $regex, $subst, $path, $global, $print, $nmatch, $fl ) = @@_;

    # make embedded newlines safe
    $regex =~ s/\n/\\n/g;
    $subst =~ s/\n/\\n/g;
 
    my $code;
    # n-th occurrence
    #
    if( length( $nmatch ) ){
	$code = <<TheEnd;
{ \$n = $nmatch;
  while( --\$n && ( \$s = m ${regex}g ) ){}
  \$s = ( substr( \$_, pos() ) =~ s ${regex}${subst}s ) if \$s;
  \$CondReg ||= \$s;
TheEnd
    } else {
        $code = <<TheEnd;
{ \$s = s ${regex}${subst}s${global};
  \$CondReg ||= \$s;
TheEnd
    }
    if( $print ){
        $code .= '  print $_, "\n" if $s;'."\n";
    }
    if( defined( $path ) ){
        $wFiles{$path} = '';
	$code .= " _w( '$path' ) if \$s;\n";
        $GenKey{'w'} = 1;
    }
    $code .= "}";
}

=head1 BASIC REGULAR EXPRESSIONS

A I<Basic Regular Expression> (BRE), as defined in POSIX 1003.2, consists
of I<atoms>, for matching parts of a string, and I<bounds>, specifying
repetitions of a preceding atom.

=head2 Atoms

The possible atoms of a BRE are: B<.>, matching any single character;
B<^> and B<$>, matching the null string at the beginning or end
of a string, respectively; a I<bracket expressions>, enclosed
in B<[> and B<]> (see below); and any single character with no
other significance (matching that character). A B<\> before one
of: B<.>, B<^>, B<$>, B<[>, B<*>, B<\>, matching the character
after the backslash. A sequence of atoms enclosed in B<\(> and B<\)>
becomes an atom and establishes the target for a I<backreference>,
consisting of the substring that actually matches the enclosed atoms.
Finally, B<\> followed by one of the digits B<0> through B<9> is a
backreference.

A B<^> that is not first, or a B<$> that is not last does not have
a special significance and need not be preceded by a backslash to
become literal. The same is true for a B<]>, that does not terminate
a bracket expression.

An unescaped backslash cannot be last in a BRE.

=head2 Bounds

The BRE bounds are: B<*>, specifying 0 or more matches of the preceding
atom; B<\{>I<count>B<\}>, specifying that many repetitions;
B<\{>I<minimum>B<,\}>, giving a lower limit; and
B<\{>I<minimum>B<,>I<maximum>B<\}> finally defines a lower and upper
bound. 

A bound appearing as the first item in a BRE is taken literally.

=head2 Bracket Expressions

A I<bracket expression> is a list of characters, character ranges
and character classes enclosed in B<[> and B<]> and matches any
single character from the represented set of characters.

A character range is written as two characters separated by B<-> and
represents all characters (according to the character collating sequence)
that are not less than the first and not greater than the second.
(Ranges are very collating-sequence-dependent, and portable programs
should avoid relying on them.)

A character class is one of the class names

   alnum     digit     punct
   alpha     graph     space
   blank     lower     upper
   cntrl     print     xdigit

enclosed in B<[:> and B<:]> and represents the set of characters
as defined in ctype(3).

If the first character after B<[> is B<^>, the sense of matching is
inverted.

To include a literal `C<^>', place it anywhere else but first. To
include a literal 'C<]>' place it first or immediately after an
initial B<^>. To include a literal `C<->' make it the first (or
second after B<^>) or last character, or the second endpoint of
a range.

The special bracket expression constructs C<[[:E<lt>:]]> and C<[[:E<gt>:]]> 
match the null string at the beginning and end of a word respectively.
(Note that neither is identical to Perl's `\b' atom.)

=head2 Additional Atoms

Since some sed implementations provide additional regular expression
atoms (not defined in POSIX 1003.2), B<psed> is capable of translating
the following backslash escapes:

=over 4

=item B<\E<lt>> This is the same as C<[[:E<gt>:]]>.

=item B<\E<gt>> This is the same as C<[[:E<lt>:]]>.

=item B<\w> This is an abbreviation for C<[[:alnum:]_]>.

=item B<\W> This is an abbreviation for C<[^[:alnum:]_]>.

=item B<\y> Match the empty string at a word boundary.

=item B<\B> Match the empty string between any two either word or non-word characters.

=back

To enable this feature, the environment variable PSEDEXTBRE must be set
to a string containing the requested characters, e.g.:
C<PSEDEXTBRE='E<lt>E<gt>wW'>.

=cut

#####
# bre2p - convert BRE to Perl RE
#
sub peek(\$$){
    my( $pref, $ic ) = @@_;
    $ic < length($$pref)-1 ? substr( $$pref, $ic+1, 1 ) : '';
}

sub bre2p($$$){
    my( $del, $pat, $fl ) = @@_;
    my $led = $del;
    $led =~ tr/{([</})]>/;
    $led = '' if $led eq $del;

    $pat = substr( $pat, 1, length($pat) - 2 );
    my $res = '';
    my $bracklev = 0;
    my $backref  = 0;
    my $parlev = 0;
    for( my $ic = 0; $ic < length( $pat ); $ic++ ){
        my $c = substr( $pat, $ic, 1 );
        if( $c eq '\\' ){
	    ### backslash escapes
            my $nc = peek($pat,$ic);
            if( $nc eq '' ){
                Warn( "`\\' cannot be last in pattern", $fl );
                return undef();
            }
	    $ic++;
            if( $nc eq $del ){ ## \<pattern del> => \<pattern del>
                $res .= "\\$del";

	    } elsif( $nc =~ /([[.*\\n])/ ){
		## check for \-escaped magics and \n:
		## \[ \. \* \\ \n stay as they are
                $res .= '\\'.$nc;

            } elsif( $nc eq '(' ){ ## \( => (
                $parlev++;
                $res .= '(';

            } elsif( $nc eq ')' ){ ## \) => )
                $parlev--;
		$backref++;
                if( $parlev < 0 ){
                    Warn( "unmatched `\\)'", $fl );
                    return undef();
                }
                $res .= ')';

            } elsif( $nc eq '{' ){ ## repetition factor \{<i>[,[<j>]]\}
                my $endpos = index( $pat, '\\}', $ic );
                if( $endpos < 0 ){
                    Warn( "unmatched `\\{'", $fl );
                    return undef();
                }
                my $rep = substr( $pat, $ic+1, $endpos-($ic+1) );
                $ic = $endpos + 1;

  	        if( $res =~ /^\^?$/ ){
		    $res .= "\\{$rep\}";
                } elsif( $rep =~ /^(\d+)(,?)(\d*)?$/ ){
                    my $min = $1;
                    my $com = $2 || '';
                    my $max = $3;
                    if( length( $max ) ){
                        if( $max < $min ){
                            Warn( "maximum less than minimum in `\\{$rep\\}'",
				  $fl );
                            return undef();
                        }
                    } else {
                        $max = '';
                    }
		    # simplify some
		    if( $min == 0 && $max eq '1' ){
			$res .= '?';
		    } elsif( $min == 1 && "$com$max" eq ',' ){
			$res .= '+';
		    } elsif( $min == 0 && "$com$max" eq ',' ){
			$res .= '*';
		    } else {
			$res .= "{$min$com$max}";
		    }
                } else {
                    Warn( "invalid repeat clause `\\{$rep\\}'", $fl );
                    return undef();
                }

            } elsif( $nc =~ /^[1-9]$/ ){
		## \1 .. \9 => \1 .. \9, but check for a following digit
		if( $nc > $backref ){
                    Warn( "invalid backreference ($nc)", $fl );
                    return undef();
		}
                $res .= "\\$nc";
		if( peek($pat,$ic) =~ /[0-9]/ ){
		    $res .= '(?:)';
		}

            } elsif( $useEXTBRE && ( $nc =~ /[$useEXTBRE]/ ) ){
		## extensions - at most <>wWyB - not in POSIX
                if(      $nc eq '<' ){ ## \< => \b(?=\w), be precise
                    $res .= '\\b(?<=\\W)';
                } elsif( $nc eq '>' ){ ## \> => \b(?=\W), be precise
                    $res .= '\\b(?=\\W)';
                } elsif( $nc eq 'y' ){ ## \y => \b
                    $res .= '\\b';
                } else {               ## \B, \w, \W remain the same
                    $res .= "\\$nc";
                } 
	    } elsif( $nc eq $led ){
		## \<closing bracketing-delimiter> - keep '\'
		$res .= "\\$nc";

            } else { ## \ <char> => <char> ("as if `\' were not present")
                $res .= $nc;
            }

        } elsif( $c eq '.' ){ ## . => .
            $res .= $c;

	} elsif( $c eq '*' ){ ## * => * but \* if there's nothing preceding it
	    if( $res =~ /^\^?$/ ){
                $res .= '\\*';
            } elsif( substr( $res, -1, 1 ) ne '*' ){
		$res .= $c;
	    }

        } elsif( $c eq '[' ){
	    ## parse []: [^...] [^]...] [-...]
	    my $add = '[';
	    if( peek($pat,$ic) eq '^' ){
		$ic++;
		$add .= '^';
	    }
	    my $nc = peek($pat,$ic);
  	    if( $nc eq ']' || $nc eq '-' ){
		$add .= $nc;
                $ic++;
	    }
	    # check that [ is not trailing
	    if( $ic >= length( $pat ) - 1 ){
		Warn( "unmatched `['", $fl );
		return undef();
	    }
	    # look for [:...:] and x-y
	    my $rstr = substr( $pat, $ic+1 );
	    if( $rstr =~ /^((?:\[:\(\w+|[><]\):\]|[^]-](?:-[^]])?)*)/ ){
 	        my $cnt = $1;
		$ic += length( $cnt );
		$cnt =~ s/([\\\$])/\\$1/g; # `\', `$' are magic in Perl []
		# try some simplifications
 	        my $red = $cnt;
		if( $red =~ s/0-9// ){
		    $cnt = $red.'\d';
		    if( $red =~ s/A-Z// && $red =~ s/a-z// && $red =~ s/_// ){
			$cnt = $red.'\w';
                    }
		}
		$add .= $cnt;

		# POSIX 1003.2 has this (optional) for begin/end word
		$add = '\\b(?=\\W)'  if $add eq '[[:<:]]';
		$add = '\\b(?<=\\W)' if $add eq '[[:>:]]';

	    }

	    ## may have a trailing `-' before `]'
	    if( $ic < length($pat) - 1 &&
                substr( $pat, $ic+1 ) =~ /^(-?])/ ){
		$ic += length( $1 );
		$add .= $1;
		# another simplification
		$add =~ s/^\[(\^?)(\\[dw])]$/ $1 eq '^' ? uc($2) : $2 /e;
		$res .= $add;
	    } else {
		Warn( "unmatched `['", $fl );
		return undef();
	    }

        } elsif( $c eq $led ){ ## unescaped <closing bracketing-delimiter>
            $res .= "\\$c";

        } elsif( $c eq ']' ){ ## unmatched ] is not magic
            $res .= ']';

        } elsif( $c =~ /[|+?{}()]/ ){ ## not magic in BRE, but in Perl: \-quote
            $res .= "\\$c";

        } elsif( $c eq '^' ){ ## not magic unless 1st, but in Perl: \-quote
            $res .= length( $res ) ? '\\^' : '^';

        } elsif( $c eq '$' ){ ## not magic unless last, but in Perl: \-quote
            $res .= $ic == length( $pat ) - 1 ? '$' : '\\$';

        } else {
            $res .= $c;
        }
    }

    if( $parlev ){
       Warn( "unmatched `\\('", $fl );
       return undef();
    }

    # final cleanup: eliminate raw HTs
    $res =~ s/\t/\\t/g;
    return $del . $res . ( $led ? $led : $del );
}


#####
# sub2p - convert sed substitution to Perl substitution
#
sub sub2p($$$){
    my( $del, $subst, $fl ) = @@_;
    my $led = $del;
    $led =~ tr/{([</})]>/;
    $led = '' if $led eq $del;

    $subst = substr( $subst, 1, length($subst) - 2 );
    my $res = '';
 
    for( my $ic = 0; $ic < length( $subst ); $ic++ ){
        my $c = substr( $subst, $ic, 1 );
        if( $c eq '\\' ){
	    ### backslash escapes
            my $nc = peek($subst,$ic);
            if( $nc eq '' ){
                Warn( "`\\' cannot be last in substitution", $fl );
                return undef();
            }
	    $ic++;
	    if( $nc =~ /[\\$del$led]/ ){ ## \ and delimiter
		$res .= '\\' . $nc;
            } elsif( $nc =~ /[1-9]/ ){ ## \1 - \9 => ${1} - ${9}
                $res .= '${' . $nc . '}';
	    } else { ## everything else (includes &): omit \
		$res .= $nc;
	    }
        } elsif( $c eq '&' ){ ## & => $&
            $res .= '$&';
	} elsif( $c =~ /[\$\@@$led]/ ){ ## magic in Perl's substitution string
	    $res .= '\\' . $c;
        } else {
	    $res .= $c;
	}
    }

    # final cleanup: eliminate raw HTs
    $res =~ s/\t/\\t/g;
    return ( $led ? $del : $led ) . $res . ( $led ? $led : $del );
}


sub Parse(){
    my $error = 0;
    my( $pdef, $pfil, $plin );
    for( my $icom = 0; $icom < @@Commands; $icom++ ){
	my $cmd = $Commands[$icom];
	print "Parse:$cmd:\n" if $useDEBUG;
	$cmd =~ s/^\s+//;
	next unless length( $cmd );
	my $scom = $icom;
	if( exists( $Defined{$icom} ) ){
	    $pdef = $Defined{$icom};
	    if( $pdef =~ /^ #(\d+)/ ){
		$pfil = 'expression #';
		$plin = $1;
	    } else {
		$pfil = "$pdef l.";
		$plin = 1;
            }
        } else {
	    $plin++;
        }
        my $fl = "$pfil$plin";

        # insert command as comment in gnerated code
	#
	$Code .= "# $cmd\n" if $doGenerate;

	# The Address(es)
	#
	my( $negated, $naddr, $addr1, $addr2 );
	$naddr = 0;
	if(      $cmd =~ s/^(\d+)\s*// ){
	    $addr1 = "$1"; $naddr++;
	} elsif( $cmd =~ s/^\$\s*// ){
	    $addr1 = 'eofARGV()'; $naddr++;
	} elsif( $cmd =~ s{^(/)}{} || $cmd =~ s{^\\(.)}{} ){
	    my $del = $1;
	    my $regex = stripRegex( $del, \$cmd );
	    if( defined( $regex ) ){
		$addr1 = 'm '.bre2p( $del, $regex, $fl ).'s';
		$naddr++;
	    } else {
		Warn( "malformed regex, 1st address", $fl );
		$error++;
		next;
	    }
        }
        if( defined( $addr1 ) && $cmd =~ s/,\s*// ){
 	    if(      $cmd =~ s/^(\d+)\s*// ){
	        $addr2 = "$1"; $naddr++;
	    } elsif( $cmd =~ s/^\$\s*// ){
	        $addr2 = 'eofARGV()'; $naddr++;
	    } elsif( $cmd =~ s{^(/)}{} || $cmd =~ s{^\\(.)}{} ){
		my $del = $1;
	        my $regex = stripRegex( $del, \$cmd );
		if( defined( $regex ) ){
		    $addr2 = 'm '. bre2p( $del, $regex, $fl ).'s';
		    $naddr++;
		} else {
		    Warn( "malformed regex, 2nd address", $fl );
		    $error++;
		    next;
		}
            } else {
		Warn( "invalid address after `,'", $fl );
		$error++;
		next;
            }
        }

        # address modifier `!'
        #
        $negated = $cmd =~ s/^!\s*//;
	if( defined( $addr1 ) ){
	    print "Parse: addr1=$addr1" if $useDEBUG;
	    if( defined( $addr2 ) ){
		print ", addr2=$addr2 " if $useDEBUG;
		# both numeric and addr1 > addr2 => eliminate addr2
		undef( $addr2 ) if $addr1 =~ /^\d+$/ &&
                                   $addr2 =~ /^\d+$/ && $addr1 > $addr2;
	    }
	}
	print 'negated' if $useDEBUG && $negated;
	print " command:$cmd\n" if $useDEBUG;

	# The Command
	#
        if( $cmd !~ s/^([:#={}abcdDgGhHilnNpPqrstwxy])\s*// ){
	    my $h = substr( $cmd, 0, 1 );
 	    Warn( "unknown command `$h'", $fl );
	    $error++;
	    next;
	}
        my $key = $1;

	my $tabref = $ComTab{$key};
	$GenKey{$key} = 1;
	if( $naddr > $tabref->[0] ){
	    Warn( "excess address(es)", $fl );
	    $error++;
	    next;
	}

	my $arg = '';
	if(      $tabref->[1] eq 'str' ){
	    # take remainder - don't care if it is empty
	    $arg = $cmd;
            $cmd = '';

	} elsif( $tabref->[1] eq 'txt' ){
	    # multi-line text
	    my $goon = $cmd =~ /(.*)\\$/;
	    if( length( $1 ) ){
		Warn( "extra characters after command ($cmd)", $fl );
		$error++;
	    }
	    while( $goon ){
		$icom++;
		if( $icom > $#Commands ){
		    Warn( "unexpected end of script", $fl );
		    $error++;
		    last;
		}
		$cmd = $Commands[$icom];
		$Code .= "# $cmd\n" if $doGenerate;
		$goon = $cmd =~ s/\\$//;
		$cmd =~ s/\\(.)/$1/g;
		$arg .= "\n" if length( $arg );
		$arg .= $cmd;
	    }
	    $arg .= "\n" if length( $arg );
	    $cmd = '';

	} elsif( $tabref->[1] eq 'sub' ){
	    # s///
	    if( ! length( $cmd ) ){
		Warn( "`s' command requires argument", $fl );
		$error++;
		next;
	    }
	    if( $cmd =~ s{^([^\\\n])}{} ){
		my $del = $1;
		my $regex = stripRegex( $del, \$cmd );
		if( ! defined( $regex ) ){
		    Warn( "malformed regular expression", $fl );
		    $error++;
		    next;
		}
		$regex = bre2p( $del, $regex, $fl );

		# a trailing \ indicates embedded NL (in replacement string)
		while( $cmd =~ s/(?<!\\)\\$/\n/ ){
		    $icom++;
		    if( $icom > $#Commands ){
			Warn( "unexpected end of script", $fl );
			$error++;
			last;
		    }
		    $cmd .= $Commands[$icom];
	            $Code .= "# $Commands[$icom]\n" if $doGenerate;
		}

		my $subst = stripRegex( $del, \$cmd );
		if( ! defined( $regex ) ){
		    Warn( "malformed substitution expression", $fl );
		    $error++;
		    next;
		}
		$subst = sub2p( $del, $subst, $fl );

		# parse s/// modifier: g|p|0-9|w <file>
		my( $global, $nmatch, $print, $write ) =
		  ( '',      '',      0,      undef );
		while( $cmd =~ s/^([gp0-9])// ){
		    $1 eq 'g' ? ( $global = 'g' ) :
  		    $1 eq 'p' ? ( $print  = $1  ) : ( $nmatch .= $1 );
                }
		$write = $1 if $cmd =~ s/w\s*(.*)$//;
  	        ### $nmatch =~ s/^(\d)\1*$/$1/; ### may be dangerous?
		if( $global && length( $nmatch ) || length( $nmatch ) > 1 ){
		    Warn( "conflicting flags `$global$nmatch'", $fl );
		    $error++;
		    next;
		}

		$arg = makes( $regex, $subst,
			      $write, $global, $print, $nmatch, $fl );
		if( ! defined( $arg ) ){
		    $error++;
		    next;
		}

            } else {
		Warn( "improper delimiter in s command", $fl );
		$error++;
		next;
            }

	} elsif( $tabref->[1] eq 'tra' ){
	    # y///
	    # a trailing \ indicates embedded newline
	    while( $cmd =~ s/(?<!\\)\\$/\n/ ){
		$icom++;
		if( $icom > $#Commands ){
		    Warn( "unexpected end of script", $fl );
		    $error++;
		    last;
		}
		$cmd .= $Commands[$icom];
                $Code .= "# $Commands[$icom]\n" if $doGenerate;
	    }
	    if( ! length( $cmd ) ){
		Warn( "`y' command requires argument", $fl );
		$error++;
		next;
	    }
	    my $d = substr( $cmd, 0, 1 ); $cmd = substr( $cmd, 1 );
	    if( $d eq '\\' ){
		Warn( "`\\' not valid as delimiter in `y' command", $fl );
		$error++;
		next;
	    }
	    my $fr = stripTrans( $d, \$cmd );
	    if( ! defined( $fr ) || ! length( $cmd ) ){
		Warn( "malformed `y' command argument", $fl );
		$error++;
		next;
	    }
	    my $to = stripTrans( $d, \$cmd );
	    if( ! defined( $to ) ){
		Warn( "malformed `y' command argument", $fl );
		$error++;
		next;
	    }
	    if( length($fr) != length($to) ){
		Warn( "string lengths in `y' command differ", $fl );
		$error++;
		next;
	    }
	    if( ! defined( $arg = makey( $fr, $to, $fl ) ) ){
		$error++;
		next;
	    }

	}

	# $cmd must be now empty - exception is {
	if( $cmd !~ /^\s*$/ ){
	    if( $key eq '{' ){
		# dirty hack to process command on '{' line
		$Commands[$icom--] = $cmd;
	    } else {
		Warn( "extra characters after command ($cmd)", $fl );
		$error++;
		next;
	    }
	}

	# Make Code
        #
	if( &{$tabref->[2]}( $addr1, $addr2, $negated,
                             $tabref->[3], $arg, $fl ) ){
	    $error++;
	}
    }

    while( @@BlockStack ){
	my $bl = pop( @@BlockStack );
	Warn( "start of unterminated `{'", $bl );
        $error++;
    }

    for my $lab ( keys( %Label ) ){
	if( ! exists( $Label{$lab}{defined} ) ){
	    for my $used ( @@{$Label{$lab}{used}} ){
 	        Warn( "undefined label `$lab'", $used );
	        $error++;
	    }
	}
    }

    exit( 1 ) if $error;
}


##############
#### MAIN ####
##############

sub usage(){
    print STDERR "Usage: sed [-an] command [file...]\n";
    print STDERR "           [-an] [-e command] [-f script-file] [file...]\n";
}

###################
# Here we go again...
#
my $expr = 0;
while( @@ARGV && $ARGV[0] =~ /^-(.)(.*)$/ ){
    my $opt = $1;
    my $arg = $2;
    shift( @@ARGV );
    if(      $opt eq 'e' ){
        if( length( $arg ) ){
	    push( @@Commands, split( "\n", $arg ) );
        } elsif( @@ARGV ){
	    push( @@Commands, shift( @@ARGV ) ); 
        } else {
            Warn( "option -e requires an argument" );
            usage();
            exit( 1 );
        }
	$expr++;
        $Defined{$#Commands} = " #$expr";
	next;
    }
    if( $opt eq 'f' ){
        my $path;
        if( length( $arg ) ){
	    $path = $arg;
        } elsif( @@ARGV ){
	    $path = shift( @@ARGV ); 
        } else {
            Warn( "option -f requires an argument" );
            usage();
            exit( 1 );
        }
	my $fst = $#Commands + 1;
        open( SCRIPT, "<$path" ) || die( "$0: $path: could not open ($!)\n" );
        my $cmd;
        while( defined( $cmd = <SCRIPT> ) ){
            chomp( $cmd );
            push( @@Commands, $cmd );
        }
        close( SCRIPT );
	if( $#Commands >= $fst ){
	    $Defined{$fst} = "$path";
	}
	next;
    }
    if( $opt eq '-' && $arg eq '' ){
	last;
    }
    if( $opt eq 'h' || $opt eq '?' ){
        usage();
        exit( 0 );
    }
    if( $opt eq 'n' ){
	$doAutoPrint = 0;
    } elsif( $opt eq 'a' ){
	$doOpenWrite = 0;
    } else {
        Warn( "illegal option `$opt'" );
        usage();
        exit( 1 );
    }
    if( length( $arg ) ){
	unshift( @@ARGV, "-$arg" );
    }
}

# A singleton command may be the 1st argument when there are no options.
#
if( @@Commands == 0 ){
    if( @@ARGV == 0 ){
        Warn( "no script command given" );
        usage();
        exit( 1 );
    }
    push( @@Commands, split( "\n", shift( @@ARGV ) ) );
    $Defined{0} = ' #1';
}

print STDERR "Files: @@ARGV\n" if $useDEBUG;

# generate leading code
#
$Func = <<'[TheEnd]';

# openARGV: open 1st input file
#
sub openARGV(){
    unshift( @@ARGV, '-' ) unless @@ARGV;
    my $file = shift( @@ARGV );
    open( ARG, "<$file" )
    || die( "$0: can't open $file for reading ($!)\n" );
    $isEOF = 0;
}

# getsARGV: Read another input line into argument (default: $_).
#           Move on to next input file, and reset EOF flag $isEOF.
sub getsARGV(;\$){
    my $argref = @@_ ? shift() : \$_; 
    while( $isEOF || ! defined( $$argref = <ARG> ) ){
	close( ARG );
	return 0 unless @@ARGV;
	my $file = shift( @@ARGV );
	open( ARG, "<$file" )
	|| die( "$0: can't open $file for reading ($!)\n" );
	$isEOF = 0;
    }
    1;
}

# eofARGV: end-of-file test
#
sub eofARGV(){
    return @@ARGV == 0 && ( $isEOF = eof( ARG ) );
}

# makeHandle: Generates another file handle for some file (given by its path)
#             to be written due to a w command or an s command's w flag.
sub makeHandle($){
    my( $path ) = @@_;
    my $handle;
    if( ! exists( $wFiles{$path} ) || $wFiles{$path} eq '' ){
        $handle = $wFiles{$path} = gensym();
	if( $doOpenWrite ){
	    if( ! open( $handle, ">$path" ) ){
		die( "$0: can't open $path for writing: ($!)\n" );
	    }
	}
    } else {
        $handle = $wFiles{$path};
    }
    return $handle;
}

# printQ: Print queued output which is either a string or a reference
#         to a pathname.
sub printQ(){
    for my $q ( @@Q ){
	if( ref( $q ) ){
            # flush open w files so that reading this file gets it all
	    if( exists( $wFiles{$$q} ) && $wFiles{$$q} ne '' ){
		open( $wFiles{$$q}, ">>$$q" );
	    }
            # copy file to stdout: slow, but safe
	    if( open( RF, "<$$q" ) ){
		while( defined( my $line = <RF> ) ){
		    print $line;
		}
		close( RF );
	    }
	} else {
	    print $q;
	}
    }
    undef( @@Q );
}

[TheEnd]

# generate the sed loop
#
$Code .= <<'[TheEnd]';
sub openARGV();
sub getsARGV(;\$);
sub eofARGV();
sub printQ();

# Run: the sed loop reading input and applying the script
#
sub Run(){
    my( $h, $icnt, $s, $n );
    # hack (not unbreakable :-/) to avoid // matching an empty string
    my $z = "\000"; $z =~ /$z/;
    # Initialize.
    openARGV();
    $Hold    = '';
    $CondReg = 0;
    $doPrint = $doAutoPrint;
CYCLE:
    while( getsARGV() ){
	chomp();
	$CondReg = 0;   # cleared on t
BOS:;
[TheEnd]

    # parse - avoid opening files when doing s2p
    #
    ( $svOpenWrite, $doOpenWrite ) = (  $doOpenWrite, $svOpenWrite )
      if $doGenerate;
    Parse();
    ( $svOpenWrite, $doOpenWrite ) = (  $doOpenWrite, $svOpenWrite )
      if $doGenerate;

    # append trailing code
    #
    $Code .= <<'[TheEnd]';
EOS:    if( $doPrint ){
            print $_, "\n";
        } else {
	    $doPrint = $doAutoPrint;
	}
        printQ() if @@Q;
    }

    exit( 0 );
}
[TheEnd]


# append optional functions, prepend prototypes
#
my $Proto = "# prototypes\n";
if( $GenKey{'l'} ){
    $Proto .= "sub _l();\n";
    $Func .= <<'[TheEnd]';
# _l: l command processing
#
sub _l(){        
    my $h = $_;
    my $mcpl = 70;
    # transform non printing chars into escape notation
    $h =~ s/\\/\\\\/g;
    if( $h =~ /[^[:print:]]/ ){
	$h =~ s/\a/\\a/g;
	$h =~ s/\f/\\f/g;
	$h =~ s/\n/\\n/g;
	$h =~ s/\t/\\t/g;
	$h =~ s/\r/\\r/g;
	$h =~ s/\e/\\e/g;
        $h =~ s/([^[:print:]])/sprintf("\\%03o", ord($1))/ge;
    }
    # split into lines of length $mcpl
    while( length( $h ) > $mcpl ){
	my $l = substr( $h, 0, $mcpl-1 );
	$h = substr( $h, $mcpl );
	# remove incomplete \-escape from end of line
	if( $l =~ s/(?<!\\)(\\[0-7]{0,2})$// ){
	    $h = $1 . $h;
	}
	print $l, "\\\n";
    }
    print "$h\$\n";
}

[TheEnd]
}

if( $GenKey{'r'} ){
    $Proto .= "sub _r(\$);\n";
    $Func .= <<'[TheEnd]';
# _r: r command processing: Save a reference to the pathname.
#
sub _r($){
    my $path = shift();
    push( @@Q, \$path );
}

[TheEnd]
}

if( $GenKey{'t'} ){
    $Proto .= "sub _t();\n";
    $Func .= <<'[TheEnd]';
# _t: t command - condition register test/reset
#
sub _t(){
    my $res = $CondReg;
    $CondReg = 0;
    $res;
}

[TheEnd]
}

if( $GenKey{'w'} ){
    $Proto .= "sub _w(\$);\n";
    $Func .= <<'[TheEnd]';
# _w: w command and s command's w flag - write to file 
#
sub _w($){
    my $path   = shift();
    my $handle = $wFiles{$path};
    if( ! $doOpenWrite && ! defined( fileno( $handle ) ) ){
	open( $handle, ">$path" )
	|| die( "$0: $path: cannot open ($!)\n" );
    }
    print $handle $_, "\n";
}

[TheEnd]
}

$Code = $Proto . $Code;

# magic "#n" - same as -n option
#
$doAutoPrint = 0 if substr( $Commands[0], 0, 2 ) eq '#n';

# eval code - check for errors
#
print "Code:\n$Code$Func" if $useDEBUG;
eval $Code . $Func;
if( $@@ ){
    print "Code:\n$Code$Func";
    die( "$0: internal error - generated incorrect Perl code: $@@\n" );
}

if( $doGenerate ){

    # write full Perl program
    #
 
    # bang line, declarations, prototypes
    print <<TheEnd;
#!$perlpath -w
eval 'exec $perlpath -S \$0 \${1+"\$@@"}'
  if 0;
\$0 =~ s/^.*?(\\w+)\[\\.\\w+\]*\$/\$1/;

use strict;
use Symbol;
use vars qw{ \$isEOF \$Hold \%wFiles \@@Q \$CondReg
	     \$doAutoPrint \$doOpenWrite \$doPrint };
\$doAutoPrint = $doAutoPrint;
\$doOpenWrite = $doOpenWrite;
TheEnd

    my $wf = "'" . join( "', '",  keys( %wFiles ) ) . "'";
    if( $wf ne "''" ){
	print <<TheEnd;
sub makeHandle(\$);
for my \$p ( $wf ){
   exit( 1 ) unless makeHandle( \$p );
}
TheEnd
   }

   print $Code;
   print "Run();\n";
   print $Func;
   exit( 0 );

} else {

    # execute: make handles (and optionally open) all w files; run!
    for my $p ( keys( %wFiles ) ){
        exit( 1 ) unless makeHandle( $p );
    }
    Run();
}


=head1 ENVIRONMENT

The environment variable C<PSEDEXTBRE> may be set to extend BREs.
See L<"Additional Atoms">.

=head1 DIAGNOSTICS

=over 4

=item ambiguos translation for character `%s' in `y' command

The indicated character appears twice, with different translations.

=item `[' cannot be last in pattern

A `[' in a BRE indicates the beginning of a I<bracket expression>.

=item `\' cannot be last in pattern

A `\' in a BRE is used to make the subsequent character literal.

=item `\' cannot be last in substitution

A `\' in a subsitution string is used to make the subsequent character literal.

=item conflicting flags `%s'

In an B<s> command, either the `g' flag and an n-th occurrence flag, or
multiple n-th occurrence flags are specified. Note that only the digits
`1' through `9' are permitted.

=item duplicate label %s (first defined at %s)

=item excess address(es)

The command has more than the permitted number of addresses.

=item extra characters after command (%s)

=item illegal option `%s'

=item improper delimiter in s command

The BRE and substitution may not be delimited with `\' or newline.

=item invalid address after `,'

=item invalid backreference (%s)

The specified backreference number exceeds the number of backreferences
in the BRE.

=item invalid repeat clause `\{%s\}'

The repeat clause does not contain a valid integer value, or pair of
values.

=item malformed regex, 1st address

=item malformed regex, 2nd address

=item malformed regular expression

=item malformed substitution expression

=item malformed `y' command argument

The first or second string of a B<y> command  is syntactically incorrect.

=item maximum less than minimum in `\{%s\}'

=item no script command given

There must be at least one B<-e> or one B<-f> option specifying a
script or script file.

=item `\' not valid as delimiter in `y' command

=item option -e requires an argument

=item option -f requires an argument

=item `s' command requires argument

=item start of unterminated `{'

=item string lengths in `y' command differ

The translation table strings in a B<y> commanf must have equal lengths.

=item undefined label `%s'

=item unexpected `}'

A B<}> command without a preceding B<{> command was encountered.

=item unexpected end of script

The end of the script was reached although a text line after a
B<a>, B<c> or B<i> command indicated another line.

=item unknown command `%s'

=item unterminated `['

A BRE contains an unterminated bracket expression.

=item unterminated `\('

A BRE contains an unterminated backreference.

=item `\{' without closing `\}'

A BRE contains an unterminated bounds specification.

=item `\)' without preceding `\('

=item `y' command requires argument

=back

=head1 EXAMPLE

The basic material for the preceding section was generated by running
the sed script

   #no autoprint
   s/^.*Warn( *"\([^"]*\)".*$/\1/
   t process
   b
   :process
   s/$!/%s/g
   s/$[_[:alnum:]]\{1,\}/%s/g
   s/\\\\/\\/g
   s/^/=item /
   p

on the program's own text, and piping the output into C<sort -u>.


=head1 SED SCRIPT TRANSLATION

If this program is invoked with the name F<s2p> it will act as a
sed-to-Perl translator. After option processing (all other
arguments are ignored), a Perl program is printed on standard
output, which will process the input stream (as read from all
arguments) in the way defined by the sed script and the option setting
used for the translation.

=head1 SEE ALSO

perl(1), re_format(7)

=head1 BUGS

The B<l> command will show escape characters (ESC) as `C<\e>', but
a vertical tab (VT) in octal.

Trailing spaces are truncated from labels in B<:>, B<t> and B<b> commands.

The meaning of an empty regular expression (`C<//>'), as defined by B<sed>,
is "the last pattern used, at run time". This deviates from the Perl
interpretation, which will re-use the "last last successfully executed
regular expression". Since keeping track of pattern usage would create
terribly cluttered code, and differences would only appear in obscure
context (where other B<sed> implementations appear to deviate, too),
the Perl semantics was adopted. Note that common usage of this feature,
such as in C</abc/s//xyz/>, will work as expected.

Collating elements (of bracket expressions in BREs) are not implemented.

=head1 STANDARDS

This B<sed> implementation conforms to the IEEE Std1003.2-1992 ("POSIX.2")
definition of B<sed>, and is compatible with the I<OpenBSD>
implementation, except where otherwise noted (see L<"BUGS">).

=head1 AUTHOR

This Perl implementation of I<sed> was written by Wolfgang Laun,
I<Wolfgang.Laun@@alcatel.at>.

=head1 COPYRIGHT and LICENSE

This program is free and open software. You may use, modify,
distribute, and sell this program (and any modified variants) in any
way you wish, provided you do not restrict others from doing the same.

=cut

!NO!SUBS!

close OUT or die "Can't close $file: $!";
chmod 0755, $file or die "Can't reset permissions for $file: $!\n";
unlink 'psed';
print "Linking s2p to psed.\n";
if (defined $Config{d_link}) {
  link 's2p', 'psed';
} else {
  unshift @@INC, '../lib';
  require File::Copy;
  File::Copy::syscopy('s2p', 'psed');
}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d789 1
a789 1
	    Warn( "ambiguous translation for character `$fc' in `y' command",
d1863 1
a1863 1
=item ambiguous translation for character `%s' in `y' command
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d567 1
a567 7

# lower case $0 below as a VMSism.  The VMS build procedure creates the
# s2p file traditionally in upper case on the disk.  When VMS is in a
# case preserved or case sensitive mode, $0 will be returned in the exact
# case which will be on the disk, and that is not predictable at this time.

my $doGenerate  = lc($0) eq 's2p';
d2049 1
a2049 1
print "Linking $file to psed.\n";
d2051 1
a2051 1
  link $file, 'psed';
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a71 1
#           Jul 23 2007: Fix bug in regex stripping (M.Thorland)
d745 3
a747 6
# stripRegex from the current command. If we're in the first
# part of s///, trailing spaces have to be kept as the initial
# part of the replacement string.
#
sub stripRegex($$;$){
    my( $del, $sref, $sub ) = @@_;
a753 3
            if( $sub && (length( $3 ) > 0) ){
                $$sref = $3 . $$sref;
	    }
d1356 1
a1356 1
		my $regex = stripRegex( $del, \$cmd, "s" );
d1948 1
a1948 1
The translation table strings in a B<y> command must have equal lengths.
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d94 1
a94 1
to standard output. The filename 'C<->' may be used to read standard input.
d101 1
a101 1
sed-to-Perl translator. See L<"SED SCRIPT TRANSLATION">.
d158 1
a158 1
Any address may be followed by an exclamation mark ('C<!>'), selecting
d174 1
a174 1
L<"BASIC REGULAR EXPRESSIONS">), between the delimiting character C</>.
d177 1
a177 1
backslash ('C<\>').
d332 3
a334 3
^'C<\>' at the point of the split; the true end of a line is marked with
a 'C<$>'. Escapes are: '\a', '\t', '\n', '\f', '\r', '\e' for
BEL, HT, LF, FF, CR, ESC, respectively, and '\' followed by a three-digit
d430 1
a430 1
and the replacement, precede the character by a backslash ('C<\>').
d435 4
a438 4
Within the replacement, an ampersand ('C<&>') is replaced by the string
matching the regular expression. The strings 'C<\1>' through 'C<\9>' are
replaced by the corresponding subpattern (see L<"BASIC REGULAR EXPRESSIONS">).
To get a literal 'C<&>' or 'C<\>' in the replacement text, precede it
a499 1

d502 1
a502 1
In the pattern space, replace all characters occurring in I<string1> by the
d507 1
a507 1
character, and a backslash followed by an 'n' is replaced by a newline
d523 1
a523 1

d552 1
a552 1
two characters in the script are 'C<#n>', automatic printing of output is
d692 1
a692 1
	Warn( "unexpected '}'", $fl );
d802 1
a802 1
	    Warn( "ambiguous translation for character '$fc' in 'y' command",
d927 1
a927 1
To include a literal 'C<^>', place it anywhere else but first. To
d929 1
a929 1
initial B<^>. To include a literal 'C<->' make it the first (or
d935 1
a935 1
(Note that neither is identical to Perl's '\b' atom.)
d990 1
a990 1
                Warn( "'\\' cannot be last in pattern", $fl );
d1010 1
a1010 1
                    Warn( "unmatched '\\)'", $fl );
d1018 1
a1018 1
                    Warn( "unmatched '\\{'", $fl );
d1032 1
a1032 1
                            Warn( "maximum less than minimum in '\\{$rep\\}'",
d1050 1
a1050 1
                    Warn( "invalid repeat clause '\\{$rep\\}'", $fl );
d1080 1
a1080 1
            } else { ## \ <char> => <char> ("as if '\' were not present")
d1108 1
a1108 1
		Warn( "unmatched '['", $fl );
d1116 1
a1116 1
		$cnt =~ s/([\\\$])/\\$1/g; # '\', '$' are magic in Perl []
d1133 1
a1133 1
	    ## may have a trailing '-' before ']'
d1142 1
a1142 1
		Warn( "unmatched '['", $fl );
d1167 1
a1167 1
       Warn( "unmatched '\\('", $fl );
d1195 1
a1195 1
                Warn( "'\\' cannot be last in substitution", $fl );
d1285 1
a1285 1
		Warn( "invalid address after ','", $fl );
d1291 1
a1291 1
        # address modifier '!'
d1310 1
a1310 1
 	    Warn( "unknown command '$h'", $fl );
d1357 1
a1357 1
		Warn( "'s' command requires argument", $fl );
d1401 1
a1401 1
		    Warn( "conflicting flags '$global$nmatch'", $fl );
d1433 1
a1433 1
		Warn( "'y' command requires argument", $fl );
d1439 1
a1439 1
		Warn( "'\\' not valid as delimiter in 'y' command", $fl );
d1445 1
a1445 1
		Warn( "malformed 'y' command argument", $fl );
d1451 1
a1451 1
		Warn( "malformed 'y' command argument", $fl );
d1456 1
a1456 1
		Warn( "string lengths in 'y' command differ", $fl );
d1489 1
a1489 1
	Warn( "start of unterminated '{'", $bl );
d1496 1
a1496 1
 	        Warn( "undefined label '$lab'", $used );
d1573 1
a1573 1
        Warn( "illegal option '$opt'" );
d1876 1
a1876 1
=item ambiguous translation for character '%s' in 'y' command
d1880 1
a1880 1
=item '[' cannot be last in pattern
d1882 1
a1882 1
A '[' in a BRE indicates the beginning of a I<bracket expression>.
d1884 1
a1884 1
=item '\' cannot be last in pattern
d1886 1
a1886 1
A '\' in a BRE is used to make the subsequent character literal.
d1888 1
a1888 1
=item '\' cannot be last in substitution
d1890 1
a1890 1
A '\' in a substitution string is used to make the subsequent character literal.
d1892 1
a1892 1
=item conflicting flags '%s'
d1894 1
a1894 1
In an B<s> command, either the 'g' flag and an n-th occurrence flag, or
d1896 1
a1896 1
^'1' through '9' are permitted.
d1906 1
a1906 1
=item illegal option '%s'
d1910 1
a1910 1
The BRE and substitution may not be delimited with '\' or newline.
d1912 1
a1912 1
=item invalid address after ','
d1919 1
a1919 1
=item invalid repeat clause '\{%s\}'
d1932 1
a1932 1
=item malformed 'y' command argument
d1936 1
a1936 1
=item maximum less than minimum in '\{%s\}'
d1943 1
a1943 1
=item '\' not valid as delimiter in 'y' command
d1949 1
a1949 1
=item 's' command requires argument
d1951 1
a1951 1
=item start of unterminated '{'
d1953 1
a1953 1
=item string lengths in 'y' command differ
d1957 1
a1957 1
=item undefined label '%s'
d1959 1
a1959 1
=item unexpected '}'
d1968 1
a1968 1
=item unknown command '%s'
d1970 1
a1970 1
=item unterminated '['
d1974 1
a1974 1
=item unterminated '\('
d1978 1
a1978 1
=item '\{' without closing '\}'
d1982 1
a1982 1
=item '\)' without preceding '\('
d1984 1
a1984 1
=item 'y' command requires argument
d2022 1
a2022 1
The B<l> command will show escape characters (ESC) as 'C<\e>', but
d2027 1
a2027 1
The meaning of an empty regular expression ('C<//>'), as defined by B<sed>,
@


