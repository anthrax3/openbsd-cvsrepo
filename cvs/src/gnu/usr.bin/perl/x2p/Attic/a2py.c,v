head	1.13;
access;
symbols
	OPENBSD_6_0:1.12.0.10
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.4
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	PERL_5_20_2:1.1.1.13
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.16
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.12
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.8.0.16
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.12
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.13
date	2017.02.05.00.32.22;	author afresh1;	state dead;
branches;
next	1.12;
commitid	cxJ08BvJA9Pt2PTM;

1.12
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2014.03.24.15.05.34;	author afresh1;	state Exp;
branches;
next	1.10;

1.10
date	2010.09.24.15.07.12;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.15;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.53;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.36.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.09.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.58;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.08.07.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.13.35;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.13.35;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.42.24;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.11.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.26.21;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.14;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.39;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.50;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.18.32;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.50.02;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.41;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.49.20;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.59.13;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.53.21;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.13
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    a2py.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */

#if defined(OS2) || defined(WIN32) || defined(NETWARE)
#if defined(WIN32)
#include <io.h>
#endif
#if defined(NETWARE)
#include "../netware/clibstuf.h"
#endif
#include "../patchlevel.h"
#endif
#include "util.h"
#include "../unicode_constants.h"
#define DELETE_CHAR DEL_NATIVE

const char *filename;
const char *myname;

int checkers = 0;

int oper0(int type);
int oper1(int type, int arg1);
int oper2(int type, int arg1, int arg2);
int oper3(int type, int arg1, int arg2, int arg3);
int oper4(int type, int arg1, int arg2, int arg3, int arg4);
int oper5(int type, int arg1, int arg2, int arg3, int arg4, int arg5);
STR *walk(int useval, int level, int node, int *numericptr, int minprec);
#ifdef NETWARE
char *savestr(char *str);
char *cpy2(char *to, char *from, int delim);
#endif

#if defined(OS2) || defined(WIN32) || defined(NETWARE)
static void usage(void);

static void
usage()
{
    printf("\nThis is the AWK to PERL translator, revision %d.0, version %d\n", PERL_REVISION, PERL_VERSION);
    printf("\nUsage: %s [-D<number>] [-F<char>] [-n<fieldlist>] [-<number>] filename\n", myname);
    printf("\n  -D<number>      sets debugging flags."
           "\n  -F<character>   the awk script to translate is always invoked with"
           "\n                  this -F switch."
           "\n  -n<fieldlist>   specifies the names of the input fields if input does"
           "\n                  not have to be split into an array."
           "\n  -<number>       causes a2p to assume that input will always have that"
           "\n                  many fields.\n");
    exit(1);
}
#endif

int
main(int argc, const char **argv)
{
    STR *str;
    int i;
    STR *tmpstr;
    /* char *namelist;    */

	#ifdef NETWARE
		fnInitGpfGlobals();	/* For importing the CLIB calls in place of Watcom calls */
	#endif	/* NETWARE */

    myname = argv[0];
    linestr = str_new(80);
    str = str_new(0);		/* first used for -I flags */
    for (argc--,argv++; argc; argc--,argv++) {
	if (argv[0][0] != '-' || !argv[0][1])
	    break;
	switch (argv[0][1]) {
#ifdef DEBUGGING
	case 'D':
	    debug = atoi(argv[0]+2);
#if YYDEBUG
	    yydebug = (debug & 1);
#endif
	    break;
#endif
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
	    maxfld = atoi(argv[0]+1);
	    absmaxfld = TRUE;
	    break;
	case 'F':
	    fswitch = argv[0][2];
	    break;
	case 'n':
	    namelist = savestr(argv[0]+2);
	    break;
	case 'o':
	    old_awk = TRUE;
	    break;
	case '-':
	    argc--,argv++;
	    goto switch_end;
	case 0:
	    break;
	default:
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
	    fprintf(stderr, "Unrecognized switch: %s\n",argv[0]);
            usage();
#else
	    fatal("Unrecognized switch: %s\n",argv[0]);
#endif
	}
    }
  switch_end:

    /* open script */

    if (argv[0] == NULL) {
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
	if ( isatty(fileno(stdin)) )
	    usage();
#endif
        argv[0] = "-";
    }
    filename = savestr(argv[0]);

    if (strEQ(filename,"-"))
	argv[0] = "";
    if (!*argv[0])
	rsfp = stdin;
    else
	rsfp = fopen(argv[0],"r");
    if (rsfp == NULL)
	fatal("Awk script \"%s\" doesn't seem to exist.\n",filename);

    /* init tokener */

    bufptr = str_get(linestr);
    symtab = hnew();
    curarghash = hnew();

    /* now parse the report spec */

    if (yyparse())
	fatal("Translation aborted due to syntax errors.\n");

#ifdef DEBUGGING
    if (debug & 2) {
	int type, len;

	for (i=1; i<mop;) {
	    type = ops[i].ival;
	    len = type >> 8;
	    type &= 255;
	    printf("%d\t%d\t%d\t%-10s",i++,type,len,opname[type]);
	    if (type == OSTRING)
		printf("\t\"%s\"\n",ops[i].cval),i++;
	    else {
		while (len--) {
		    printf("\t%d",ops[i].ival),i++;
		}
		putchar('\n');
	    }
	}
    }
    if (debug & 8)
	dump(root);
#endif

    /* first pass to look for numeric variables */

    prewalk(0,0,root,&i);

    /* second pass to produce new program */

    tmpstr = walk(0,0,root,&i,P_MIN);
    str = str_make(STARTPERL);
    str_cat(str, "\neval 'exec ");
    str_cat(str, BIN);
    str_cat(str, "/perl -S $0 ${1+\"$@@\"}'\n\
    if $running_under_some_shell;\n\
			# this emulates #! processing on NIH machines.\n\
			# (remove #! line above if indigestible)\n\n");
    str_cat(str,
      "eval '$'.$1.'$2;' while $ARGV[0] =~ /^([A-Za-z_0-9]+=)(.*)/ && shift;\n");
    str_cat(str,
      "			# process any FOO=bar switches\n\n");
    if (do_opens && opens) {
	str_scat(str,opens);
	str_free(opens);
	str_cat(str,"\n");
    }
    str_scat(str,tmpstr);
    str_free(tmpstr);
#ifdef DEBUGGING
    if (!(debug & 16))
#endif
    fixup(str);
    putlines(str);
    if (checkers) {
	fprintf(stderr,
	  "Please check my work on the %d line%s I've marked with \"#???\".\n",
		checkers, checkers == 1 ? "" : "s" );
	fprintf(stderr,
	  "The operation I've selected may be wrong for the operand types.\n");
    }
    exit(0);
    /* by ANSI specs return is needed. This also shuts up VC++ and his warnings */
    return(0);
}

#define RETURN(retval) return (bufptr = s,retval)
#define XTERM(retval) return (expectterm = TRUE,bufptr = s,retval)
#define XOP(retval) return (expectterm = FALSE,bufptr = s,retval)
#define ID(x) return (yylval=string(x,0),expectterm = FALSE,bufptr = s,idtype)

int idtype;

int
yylex(void)
{
    char *s = bufptr;
    char *d;
    int tmp;

  retry:
#if YYDEBUG
    if (yydebug) {
	if (strchr(s,'\n'))
	    fprintf(stderr,"Tokener at %s",s);
	else
	    fprintf(stderr,"Tokener at %s\n",s);
    }
#endif
    switch (*s) {
    default:
	fprintf(stderr,
	    "Unrecognized character %c in file %s line %d--ignoring.\n",
	     *s++,filename,line);
	goto retry;
    case '\\':
	s++;
	if (*s && *s != '\n') {
	    yyerror("Ignoring spurious backslash");
	    goto retry;
	}
	/*FALLSTHROUGH*/
    case 0:
	s = str_get(linestr);
	*s = '\0';
	if (!rsfp)
	    RETURN(0);
	line++;
	if ((s = str_gets(linestr, rsfp)) == NULL) {
	    if (rsfp != stdin)
		fclose(rsfp);
	    rsfp = NULL;
	    s = str_get(linestr);
	    RETURN(0);
	}
	goto retry;
    case ' ': case '\t':
	s++;
	goto retry;
    case '\n':
	*s = '\0';
	XTERM(NEWLINE);
    case '#':
	yylval = string(s,0);
	*s = '\0';
	XTERM(COMMENT);
    case ';':
	tmp = *s++;
	if (*s == '\n') {
	    s++;
	    XTERM(SEMINEW);
	}
	XTERM(tmp);
    case '(':
	tmp = *s++;
	XTERM(tmp);
    case '{':
    case '[':
    case ')':
    case ']':
    case '?':
    case ':':
	tmp = *s++;
	XOP(tmp);
    case DELETE_CHAR:
	s++;
	XTERM('}');
    case '}':
	for (d = s + 1; isSPACE(*d); d++) ;
	if (!*d)
	    s = d - 1;
	*s = 127;
	XTERM(';');
    case ',':
	tmp = *s++;
	XTERM(tmp);
    case '~':
	s++;
	yylval = string("~",1);
	XTERM(MATCHOP);
    case '+':
    case '-':
	if (s[1] == *s) {
	    s++;
	    if (*s++ == '+')
		XTERM(INCR);
	    else
		XTERM(DECR);
	}
	/* FALL THROUGH */
    case '*':
    case '%':
    case '^':
	tmp = *s++;
	if (*s == '=') {
	    if (tmp == '^')
		yylval = string("**=",3);
	    else
		yylval = string(s-1,2);
	    s++;
	    XTERM(ASGNOP);
	}
	XTERM(tmp);
    case '&':
	s++;
	tmp = *s++;
	if (tmp == '&')
	    XTERM(ANDAND);
	s--;
	XTERM('&');
    case '|':
	s++;
	tmp = *s++;
	if (tmp == '|')
	    XTERM(OROR);
	s--;
	while (*s == ' ' || *s == '\t')
	    s++;
	if (strnEQ(s,"getline",7))
	    XTERM('p');
	else
	    XTERM('|');
    case '=':
	s++;
	tmp = *s++;
	if (tmp == '=') {
	    yylval = string("==",2);
	    XTERM(RELOP);
	}
	s--;
	yylval = string("=",1);
	XTERM(ASGNOP);
    case '!':
	s++;
	tmp = *s++;
	if (tmp == '=') {
	    yylval = string("!=",2);
	    XTERM(RELOP);
	}
	if (tmp == '~') {
	    yylval = string("!~",2);
	    XTERM(MATCHOP);
	}
	s--;
	XTERM(NOT);
    case '<':
	s++;
	tmp = *s++;
	if (tmp == '=') {
	    yylval = string("<=",2);
	    XTERM(RELOP);
	}
	s--;
	XTERM('<');
    case '>':
	s++;
	tmp = *s++;
	if (tmp == '>') {
	    yylval = string(">>",2);
	    XTERM(GRGR);
	}
	if (tmp == '=') {
	    yylval = string(">=",2);
	    XTERM(RELOP);
	}
	s--;
	XTERM('>');

#define SNARFWORD \
	d = tokenbuf; \
	while (isWORDCHAR(*s)) \
	    *d++ = *s++; \
	*d = '\0'; \
	d = tokenbuf; \
	if (*s == '(') \
	    idtype = USERFUN; \
	else \
	    idtype = VAR;

    case '$':
	s++;
	if (*s == '0') {
	    s++;
	    do_chop = TRUE;
	    need_entire = TRUE;
	    idtype = VAR;
	    ID("0");
	}
	do_split = TRUE;
	if (isDIGIT(*s)) {
	    for (d = s; isDIGIT(*s); s++) ;
	    yylval = string(d,s-d);
	    tmp = atoi(d);
	    if (tmp > maxfld)
		maxfld = tmp;
	    XOP(FIELD);
	}
	for (d = s; isWORDCHAR(*s); )
	    s++;
	split_to_array = TRUE;
	if (d != s)
	{
	    yylval = string(d,s-d);
	    XTERM(SVFIELD);
	}
	XOP(VFIELD);

    case '/':			/* may either be division or pattern */
	if (expectterm) {
	    s = scanpat(s);
	    XTERM(REGEX);
	}
	tmp = *s++;
	if (*s == '=') {
	    yylval = string("/=",2);
	    s++;
	    XTERM(ASGNOP);
	}
	XTERM(tmp);

    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9': case '.':
	s = scannum(s);
	XOP(NUMBER);
    case '"':
	s++;
	s = cpy2(tokenbuf,s,s[-1]);
	if (!*s)
	    fatal("String not terminated:\n%s",str_get(linestr));
	s++;
	yylval = string(tokenbuf,0);
	XOP(STRING);

    case 'a': case 'A':
	SNARFWORD;
	if (strEQ(d,"ARGV")) {
	    yylval=numary(string("ARGV",0));
	    XOP(VAR);
	}
	if (strEQ(d,"atan2")) {
	    yylval = OATAN2;
	    XTERM(FUNN);
	}
	ID(d);
    case 'b': case 'B':
	SNARFWORD;
	if (strEQ(d,"break"))
	    XTERM(BREAK);
	if (strEQ(d,"BEGIN"))
	    XTERM(BEGIN);
	ID(d);
    case 'c': case 'C':
	SNARFWORD;
	if (strEQ(d,"continue"))
	    XTERM(CONTINUE);
	if (strEQ(d,"cos")) {
	    yylval = OCOS;
	    XTERM(FUN1);
	}
	if (strEQ(d,"close")) {
	    do_fancy_opens = 1;
	    yylval = OCLOSE;
	    XTERM(FUN1);
	}
	if (strEQ(d,"chdir"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"crypt"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"chop"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"chmod"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"chown"))
	    *d = toUPPER(*d);
	ID(d);
    case 'd': case 'D':
	SNARFWORD;
	if (strEQ(d,"do"))
	    XTERM(DO);
	if (strEQ(d,"delete"))
	    XTERM(DELETE);
	if (strEQ(d,"die"))
	    *d = toUPPER(*d);
	ID(d);
    case 'e': case 'E':
	SNARFWORD;
	if (strEQ(d,"END"))
	    XTERM(END);
	if (strEQ(d,"else"))
	    XTERM(ELSE);
	if (strEQ(d,"exit")) {
	    saw_line_op = TRUE;
	    XTERM(EXIT);
	}
	if (strEQ(d,"exp")) {
	    yylval = OEXP;
	    XTERM(FUN1);
	}
	if (strEQ(d,"elsif"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"eq"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"eval"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"eof"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"each"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"exec"))
	    *d = toUPPER(*d);
	ID(d);
    case 'f': case 'F':
	SNARFWORD;
	if (strEQ(d,"FS")) {
	    saw_FS++;
	    if (saw_FS == 1 && in_begin) {
		for (d = s; *d && isSPACE(*d); d++) ;
		if (*d == '=') {
		    for (d++; *d && isSPACE(*d); d++) ;
		    if (*d == '"' && d[2] == '"')
			const_FS = d[1];
		}
	    }
	    ID(tokenbuf);
	}
	if (strEQ(d,"for"))
	    XTERM(FOR);
	else if (strEQ(d,"function"))
	    XTERM(FUNCTION);
	if (strEQ(d,"FILENAME"))
	    ID("ARGV");
	if (strEQ(d,"foreach"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"format"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"fork"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"fh"))
	    *d = toUPPER(*d);
	ID(d);
    case 'g': case 'G':
	SNARFWORD;
	if (strEQ(d,"getline"))
	    XTERM(GETLINE);
	if (strEQ(d,"gsub"))
	    XTERM(GSUB);
	if (strEQ(d,"ge"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"gt"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"goto"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"gmtime"))
	    *d = toUPPER(*d);
	ID(d);
    case 'h': case 'H':
	SNARFWORD;
	if (strEQ(d,"hex"))
	    *d = toUPPER(*d);
	ID(d);
    case 'i': case 'I':
	SNARFWORD;
	if (strEQ(d,"if"))
	    XTERM(IF);
	if (strEQ(d,"in"))
	    XTERM(IN);
	if (strEQ(d,"index")) {
	    XTERM(INDEX);
	}
	if (strEQ(d,"int")) {
	    yylval = OINT;
	    XTERM(FUN1);
	}
	ID(d);
    case 'j': case 'J':
	SNARFWORD;
	if (strEQ(d,"join"))
	    *d = toUPPER(*d);
	ID(d);
    case 'k': case 'K':
	SNARFWORD;
	if (strEQ(d,"keys"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"kill"))
	    *d = toUPPER(*d);
	ID(d);
    case 'l': case 'L':
	SNARFWORD;
	if (strEQ(d,"length")) {
	    yylval = OLENGTH;
	    XTERM(FUN1);
	}
	if (strEQ(d,"log")) {
	    yylval = OLOG;
	    XTERM(FUN1);
	}
	if (strEQ(d,"last"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"local"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"lt"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"le"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"locatime"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"link"))
	    *d = toUPPER(*d);
	ID(d);
    case 'm': case 'M':
	SNARFWORD;
	if (strEQ(d,"match")) {
	    XTERM(MATCH);
	}
	if (strEQ(d,"m"))
	    *d = toUPPER(*d);
	ID(d);
    case 'n': case 'N':
	SNARFWORD;
	if (strEQ(d,"NF"))
	    do_chop = do_split = split_to_array = TRUE;
	if (strEQ(d,"next")) {
	    saw_line_op = TRUE;
	    XTERM(NEXT);
	}
	if (strEQ(d,"ne"))
	    *d = toUPPER(*d);
	ID(d);
    case 'o': case 'O':
	SNARFWORD;
	if (strEQ(d,"ORS")) {
	    saw_ORS = TRUE;
	    ID("\\");
	}
	if (strEQ(d,"OFS")) {
	    saw_OFS = TRUE;
	    ID(",");
	}
	if (strEQ(d,"OFMT")) {
	    ID("#");
	}
	if (strEQ(d,"open"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"ord"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"oct"))
	    *d = toUPPER(*d);
	ID(d);
    case 'p': case 'P':
	SNARFWORD;
	if (strEQ(d,"print")) {
	    XTERM(PRINT);
	}
	if (strEQ(d,"printf")) {
	    XTERM(PRINTF);
	}
	if (strEQ(d,"push"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"pop"))
	    *d = toUPPER(*d);
	ID(d);
    case 'q': case 'Q':
	SNARFWORD;
	ID(d);
    case 'r': case 'R':
	SNARFWORD;
	if (strEQ(d,"RS")) {
	    saw_RS = TRUE;
	    ID("/");
	}
	if (strEQ(d,"rand")) {
	    yylval = ORAND;
	    XTERM(FUN1);
	}
	if (strEQ(d,"return"))
	    XTERM(RET);
	if (strEQ(d,"reset"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"redo"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"rename"))
	    *d = toUPPER(*d);
	ID(d);
    case 's': case 'S':
	SNARFWORD;
	if (strEQ(d,"split")) {
	    XOP(SPLIT);
	}
	if (strEQ(d,"substr")) {
	    XTERM(SUBSTR);
	}
	if (strEQ(d,"sub"))
	    XTERM(SUB);
	if (strEQ(d,"sprintf")) {
            /* In old awk, { print sprintf("str%sg"),"in" } prints
             * "string"; in new awk, "in" is not considered an argument to
             * sprintf, so the statement breaks.  To support both, the
             * grammar treats arguments to SPRINTF_OLD like old awk,
             * SPRINTF_NEW like new.  Here we return the appropriate one.
             */
	    XTERM(old_awk ? SPRINTF_OLD : SPRINTF_NEW);
        }
	if (strEQ(d,"sqrt")) {
	    yylval = OSQRT;
	    XTERM(FUN1);
	}
	if (strEQ(d,"SUBSEP")) {
	    ID(";");
	}
	if (strEQ(d,"sin")) {
	    yylval = OSIN;
	    XTERM(FUN1);
	}
	if (strEQ(d,"srand")) {
	    yylval = OSRAND;
	    XTERM(FUN1);
	}
	if (strEQ(d,"system")) {
	    yylval = OSYSTEM;
	    XTERM(FUN1);
	}
	if (strEQ(d,"s"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"shift"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"select"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"seek"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"stat"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"study"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"sleep"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"symlink"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"sort"))
	    *d = toUPPER(*d);
	ID(d);
    case 't': case 'T':
	SNARFWORD;
	if (strEQ(d,"tr"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"tell"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"time"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"times"))
	    *d = toUPPER(*d);
	ID(d);
    case 'u': case 'U':
	SNARFWORD;
	if (strEQ(d,"until"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"unless"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"umask"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"unshift"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"unlink"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"utime"))
	    *d = toUPPER(*d);
	ID(d);
    case 'v': case 'V':
	SNARFWORD;
	if (strEQ(d,"values"))
	    *d = toUPPER(*d);
	ID(d);
    case 'w': case 'W':
	SNARFWORD;
	if (strEQ(d,"while"))
	    XTERM(WHILE);
	if (strEQ(d,"write"))
	    *d = toUPPER(*d);
	else if (strEQ(d,"wait"))
	    *d = toUPPER(*d);
	ID(d);
    case 'x': case 'X':
	SNARFWORD;
	if (strEQ(d,"x"))
	    *d = toUPPER(*d);
	ID(d);
    case 'y': case 'Y':
	SNARFWORD;
	if (strEQ(d,"y"))
	    *d = toUPPER(*d);
	ID(d);
    case 'z': case 'Z':
	SNARFWORD;
	ID(d);
    }
}

char *
scanpat(char *s)
{
    char *d;

    switch (*s++) {
    case '/':
	break;
    default:
	fatal("Search pattern not found:\n%s",str_get(linestr));
    }

    d = tokenbuf;
    for (; *s; s++,d++) {
	if (*s == '\\') {
	    if (s[1] == '/')
		*d++ = *s++;
	    else if (s[1] == '\\')
		*d++ = *s++;
	    else if (s[1] == '[')
		*d++ = *s++;
	}
	else if (*s == '[') {
	    *d++ = *s++;
	    do {
		if (*s == '\\' && s[1])
		    *d++ = *s++;
		if (*s == '/' || (*s == '-' && s[1] == ']'))
		    *d++ = '\\';
		*d++ = *s++;
	    } while (*s && *s != ']');
	}
	else if (*s == '/')
	    break;
	*d = *s;
    }
    *d = '\0';

    if (!*s)
	fatal("Search pattern not terminated:\n%s",str_get(linestr));
    s++;
    yylval = string(tokenbuf,0);
    return s;
}

void
yyerror(const char *s)
{
    fprintf(stderr,"%s in file %s at line %d\n",
      s,filename,line);
}

char *
scannum(char *s)
{
    char *d;

    switch (*s) {
    case '1': case '2': case '3': case '4': case '5':
    case '6': case '7': case '8': case '9': case '0' : case '.':
	d = tokenbuf;
	while (isDIGIT(*s)) {
	    *d++ = *s++;
	}
	if (*s == '.') {
	    if (isDIGIT(s[1])) {
		*d++ = *s++;
		while (isDIGIT(*s)) {
		    *d++ = *s++;
		}
	    }
	    else
		s++;
	}
	if (strchr("eE",*s) && strchr("+-0123456789",s[1])) {
	    *d++ = *s++;
	    if (*s == '+' || *s == '-')
		*d++ = *s++;
	    while (isDIGIT(*s))
		*d++ = *s++;
	}
	*d = '\0';
	yylval = string(tokenbuf,0);
	break;
    }
    return s;
}

int
string(const char *ptr, int len)
{
    int retval = mop;

    ops[mop++].ival = OSTRING + (1<<8);
    if (!len)
	len = strlen(ptr);
    ops[mop].cval = (char *) safemalloc(len+1);
    strncpy(ops[mop].cval,ptr,len);
    ops[mop++].cval[len] = '\0';
    if (mop >= OPSMAX)
	fatal("Recompile a2p with larger OPSMAX\n");
    return retval;
}

int
oper0(int type)
{
    int retval = mop;

    if (type > 255)
	fatal("type > 255 (%d)\n",type);
    ops[mop++].ival = type;
    if (mop >= OPSMAX)
	fatal("Recompile a2p with larger OPSMAX\n");
    return retval;
}

int
oper1(int type, int arg1)
{
    int retval = mop;

    if (type > 255)
	fatal("type > 255 (%d)\n",type);
    ops[mop++].ival = type + (1<<8);
    ops[mop++].ival = arg1;
    if (mop >= OPSMAX)
	fatal("Recompile a2p with larger OPSMAX\n");
    return retval;
}

int
oper2(int type, int arg1, int arg2)
{
    int retval = mop;

    if (type > 255)
	fatal("type > 255 (%d)\n",type);
    ops[mop++].ival = type + (2<<8);
    ops[mop++].ival = arg1;
    ops[mop++].ival = arg2;
    if (mop >= OPSMAX)
	fatal("Recompile a2p with larger OPSMAX\n");
    return retval;
}

int
oper3(int type, int arg1, int arg2, int arg3)
{
    int retval = mop;

    if (type > 255)
	fatal("type > 255 (%d)\n",type);
    ops[mop++].ival = type + (3<<8);
    ops[mop++].ival = arg1;
    ops[mop++].ival = arg2;
    ops[mop++].ival = arg3;
    if (mop >= OPSMAX)
	fatal("Recompile a2p with larger OPSMAX\n");
    return retval;
}

int
oper4(int type, int arg1, int arg2, int arg3, int arg4)
{
    int retval = mop;

    if (type > 255)
	fatal("type > 255 (%d)\n",type);
    ops[mop++].ival = type + (4<<8);
    ops[mop++].ival = arg1;
    ops[mop++].ival = arg2;
    ops[mop++].ival = arg3;
    ops[mop++].ival = arg4;
    if (mop >= OPSMAX)
	fatal("Recompile a2p with larger OPSMAX\n");
    return retval;
}

int
oper5(int type, int arg1, int arg2, int arg3, int arg4, int arg5)
{
    int retval = mop;

    if (type > 255)
	fatal("type > 255 (%d)\n",type);
    ops[mop++].ival = type + (5<<8);
    ops[mop++].ival = arg1;
    ops[mop++].ival = arg2;
    ops[mop++].ival = arg3;
    ops[mop++].ival = arg4;
    ops[mop++].ival = arg5;
    if (mop >= OPSMAX)
	fatal("Recompile a2p with larger OPSMAX\n");
    return retval;
}

int depth = 0;

void
dump(int branch)
{
    int type;
    int len;
    int i;

    type = ops[branch].ival;
    len = type >> 8;
    type &= 255;
    for (i=depth; i; i--)
	printf(" ");
    if (type == OSTRING) {
	printf("%-5d\"%s\"\n",branch,ops[branch+1].cval);
    }
    else {
	printf("(%-5d%s %d\n",branch,opname[type],len);
	depth++;
	for (i=1; i<=len; i++)
	    dump(ops[branch+i].ival);
	depth--;
	for (i=depth; i; i--)
	    printf(" ");
	printf(")\n");
    }
}

int
bl(int arg, int maybe)
{
    if (!arg)
	return 0;
    else if ((ops[arg].ival & 255) != OBLOCK)
	return oper2(OBLOCK,arg,maybe);
    else if ((ops[arg].ival >> 8) < 2)
	return oper2(OBLOCK,ops[arg+1].ival,maybe);
    else
	return arg;
}

void
fixup(STR *str)
{
    char *s;
    char *t;

    for (s = str->str_ptr; *s; s++) {
	if (*s == ';' && s[1] == ' ' && s[2] == '\n') {
	    strcpy(s+1,s+2);
	    s++;
	}
	else if (*s == '\n') {
	    for (t = s+1; isSPACE(*t & 127); t++) ;
	    t--;
	    while (isSPACE(*t & 127) && *t != '\n') t--;
	    if (*t == '\n' && t-s > 1) {
		if (s[-1] == '{')
		    s--;
		strcpy(s+1,t);
	    }
	    s++;
	}
    }
}

void
putlines(STR *str)
{
    char *d, *s, *t, *e;
    int pos, newpos;

    d = tokenbuf;
    pos = 0;
    for (s = str->str_ptr; *s; s++) {
	*d++ = *s;
	pos++;
	if (*s == '\n') {
	    *d = '\0';
	    d = tokenbuf;
	    pos = 0;
	    putone();
	}
	else if (*s == '\t')
	    pos += 7;
	if (pos > 78) {		/* split a long line? */
	    *d-- = '\0';
	    newpos = 0;
	    for (t = tokenbuf; isSPACE(*t & 127); t++) {
		if (*t == '\t')
		    newpos += 8;
		else
		    newpos += 1;
	    }
	    e = d;
	    while (d > tokenbuf && (*d != ' ' || d[-1] != ';'))
		d--;
	    if (d < t+10) {
		d = e;
		while (d > tokenbuf &&
		  (*d != ' ' || d[-1] != '|' || d[-2] != '|') )
		    d--;
	    }
	    if (d < t+10) {
		d = e;
		while (d > tokenbuf &&
		  (*d != ' ' || d[-1] != '&' || d[-2] != '&') )
		    d--;
	    }
	    if (d < t+10) {
		d = e;
		while (d > tokenbuf && (*d != ' ' || d[-1] != ','))
		    d--;
	    }
	    if (d < t+10) {
		d = e;
		while (d > tokenbuf && *d != ' ')
		    d--;
	    }
	    if (d > t+3) {
                char save[2048];
                strcpy(save, d);
		*d = '\n';
                d[1] = '\0';
		putone();
		putchar('\n');
		if (d[-1] != ';' && !(newpos % 4)) {
		    *t++ = ' ';
		    *t++ = ' ';
		    newpos += 2;
		}
		strcpy(t,save+1);
		newpos += strlen(t);
		d = t + strlen(t);
		pos = newpos;
	    }
	    else
		d = e + 1;
	}
    }
}

void
putone(void)
{
    char *t;

    for (t = tokenbuf; *t; t++) {
	*t &= 127;
	if (*t == 127) {
	    *t = ' ';
	    strcpy(t+strlen(t)-1, "\t#???\n");
	    checkers++;
	}
    }
    t = tokenbuf;
    if (*t == '#') {
	if (strnEQ(t,"#!/bin/awk",10) || strnEQ(t,"#! /bin/awk",11))
	    return;
	if (strnEQ(t,"#!/usr/bin/awk",14) || strnEQ(t,"#! /usr/bin/awk",15))
	    return;
    }
    fputs(tokenbuf,stdout);
}

int
numary(int arg)
{
    STR *key;
    int dummy;

    key = walk(0,0,arg,&dummy,P_MIN);
    str_cat(key,"[]");
    hstore(symtab,key->str_ptr,str_make("1"));
    str_free(key);
    return arg;
}

int
rememberargs(int arg)
{
    int type;
    STR *str;

    if (!arg)
	return arg;
    type = ops[arg].ival & 255;
    if (type == OCOMMA) {
	rememberargs(ops[arg+1].ival);
	rememberargs(ops[arg+3].ival);
    }
    else if (type == OVAR) {
	str = str_new(0);
	hstore(curarghash,ops[ops[arg+1].ival+1].cval,str);
    }
    else
	fatal("panic: unknown argument type %d, line %d\n",type,line);
    return arg;
}

int
aryrefarg(int arg)
{
    int type = ops[arg].ival & 255;
    STR *str;

    if (type != OSTRING)
	fatal("panic: aryrefarg %d, line %d\n",type,line);
    str = hfetch(curarghash,ops[arg+1].cval);
    if (str)
	str_set(str,"*");
    return arg;
}

int
fixfargs(int name, int arg, int prevargs)
{
    int type;
    STR *str;
    int numargs = 0;

    if (!arg)
	return prevargs;
    type = ops[arg].ival & 255;
    if (type == OCOMMA) {
	numargs = fixfargs(name,ops[arg+1].ival,prevargs);
	numargs = fixfargs(name,ops[arg+3].ival,numargs);
    }
    else if (type == OVAR) {
	str = hfetch(curarghash,ops[ops[arg+1].ival+1].cval);
	if (strEQ(str_get(str),"*")) {
	    char tmpbuf[128];

	    str_set(str,"");		/* in case another routine has this */
	    ops[arg].ival &= ~255;
	    ops[arg].ival |= OSTAR;
	    sprintf(tmpbuf,"%s:%d",ops[name+1].cval,prevargs);
	    fprintf(stderr,"Adding %s\n",tmpbuf);
	    str = str_new(0);
	    str_set(str,"*");
	    hstore(curarghash,tmpbuf,str);
	}
	numargs = prevargs + 1;
    }
    else
	fatal("panic: unknown argument type %d, arg %d, line %d\n",
	  type,prevargs+1,line);
    return numargs;
}

int
fixrargs(char *name, int arg, int prevargs)
{
    int type;
    STR *str;
    int numargs;

    if (!arg)
	return prevargs;
    type = ops[arg].ival & 255;
    if (type == OCOMMA) {
	numargs = fixrargs(name,ops[arg+1].ival,prevargs);
	numargs = fixrargs(name,ops[arg+3].ival,numargs);
    }
    else {
	char *tmpbuf = (char *) safemalloc(strlen(name) + (sizeof(prevargs) * 3) + 5);
	sprintf(tmpbuf,"%s:%d",name,prevargs);
	str = hfetch(curarghash,tmpbuf);
	safefree(tmpbuf);
	if (str && strEQ(str->str_ptr,"*")) {
	    if (type == OVAR || type == OSTAR) {
		ops[arg].ival &= ~255;
		ops[arg].ival |= OSTAR;
	    }
	    else
		fatal("Can't pass expression by reference as arg %d of %s\n",
		    prevargs+1, name);
	}
	numargs = prevargs + 1;
    }
    return numargs;
}
@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@@


1.11
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a58 4
#ifdef __osf__
#pragma message disable (mainparm) /* We have the envp in main(). */
#endif

d60 1
a60 1
main(int argc, const char **argv, const char **env)
@


1.10
log
@merge in perl 5.12.2 plus local changes
@
text
@d20 2
d34 1
a34 1
STR *walk(int useval, int level, register int node, int *numericptr, int minprec);
d37 1
a37 1
char *cpy2(register char *to, register char *from, register int delim);
d64 1
a64 1
main(register int argc, register const char **argv, register const char **env)
d66 1
a66 1
    register STR *str;
d226 3
a228 3
    register char *s = bufptr;
    register char *d;
    register int tmp;
d294 1
a294 5
#ifdef EBCDIC
    case 7:
#else
    case 127:
#endif
d400 1
a400 1
	while (isALPHA(*s) || isDIGIT(*s) || *s == '_') \
d427 1
a427 1
	for (d = s; isALPHA(*s) || isDIGIT(*s) || *s == '_'; )
d827 1
a827 1
scanpat(register char *s)
d829 1
a829 1
    register char *d;
d879 1
a879 1
scannum(register char *s)
d881 1
a881 1
    register char *d;
d1028 3
a1030 3
    register int type;
    register int len;
    register int i;
d1068 2
a1069 2
    register char *s;
    register char *t;
d1093 2
a1094 2
    register char *d, *s, *t, *e;
    register int pos, newpos;
d1169 1
a1169 1
    register char *t;
@


1.9
log
@Merge in perl 5.10.1; part two
@
text
@d431 1
a431 1
	split_to_array = set_array_base = TRUE;
a466 2
	if (strEQ(d,"ARGC"))
	    set_array_base = TRUE;
a598 1
	    set_array_base = TRUE;
a643 1
	    set_array_base = TRUE;
d652 1
a652 1
	    do_chop = do_split = split_to_array = set_array_base = TRUE;
a717 1
	    set_array_base = TRUE;
a720 1
	    set_array_base = TRUE;
a1200 1
    set_array_base = TRUE;
@


1.8
log
@merge in perl 5.8.8
@
text
@d21 2
a22 2
char *filename;
char *myname;
d62 1
a62 1
main(register int argc, register char **argv, register char **env)
d120 1
a120 1
    if (argv[0] == Nullch) {
a128 1
    filename = savestr(argv[0]);
d135 1
a135 1
    if (rsfp == Nullfp)
d256 1
a256 1
	if ((s = str_gets(linestr, rsfp)) == Nullch) {
d259 1
a259 1
	    rsfp = Nullfp;
d564 1
a564 1
	    d = "ARGV";
d668 1
a668 1
	    d = "\\";
d672 1
a672 1
	    d = ",";
d675 1
a675 1
	    d = "#";
a702 1
	    d = "/";
d704 1
d745 1
a745 1
	    d = ";";
d880 1
a880 1
yyerror(char *s)
d923 1
a923 1
string(char *ptr, int len)
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d1 1
a1 1
/* $RCSfile: a2py.c,v $$Revision: 4.1 $$Date: 92/08/07 18:29:14 $
a7 2
 *
 * $Log:	a2py.c,v $
d57 4
d430 2
d433 5
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-1997, Larry Wall
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d11 1
a11 1
#if defined(OS2) || defined(WIN32)
d15 3
d34 4
d39 1
a39 1
#if defined(OS2) || defined(WIN32)
d64 5
a75 1
      reswitch:
d105 1
a105 1
#if defined(OS2) || defined(WIN32)
d118 1
a118 1
#if defined(OS2) || defined(WIN32)
d208 2
d228 1
a228 1
    if (yydebug)
d233 1
d298 1
a298 1
	for (d = s + 1; isspace(*d); d++) ;
d400 1
a400 1
	while (isalpha(*s) || isdigit(*s) || *s == '_') \
d419 2
a420 2
	if (isdigit(*s)) {
	    for (d = s; isdigit(*s); s++) ;
d490 1
a490 1
	    *d = toupper(*d);
d492 1
a492 1
	    *d = toupper(*d);
d494 1
a494 1
	    *d = toupper(*d);
d496 1
a496 1
	    *d = toupper(*d);
d498 1
a498 1
	    *d = toupper(*d);
d507 1
a507 1
	    *d = toupper(*d);
d524 1
a524 1
	    *d = toupper(*d);
d526 1
a526 1
	    *d = toupper(*d);
d528 1
a528 1
	    *d = toupper(*d);
d530 1
a530 1
	    *d = toupper(*d);
d532 1
a532 1
	    *d = toupper(*d);
d534 1
a534 1
	    *d = toupper(*d);
d541 1
a541 1
		for (d = s; *d && isspace(*d); d++) ;
d543 1
a543 1
		    for (d++; *d && isspace(*d); d++) ;
d557 1
a557 1
	    *d = toupper(*d);
d559 1
a559 1
	    *d = toupper(*d);
d561 1
a561 1
	    *d = toupper(*d);
d563 1
a563 1
	    *d = toupper(*d);
d572 1
a572 1
	    *d = toupper(*d);
d574 1
a574 1
	    *d = toupper(*d);
d576 1
a576 1
	    *d = toupper(*d);
d578 1
a578 1
	    *d = toupper(*d);
d583 1
a583 1
	    *d = toupper(*d);
d603 1
a603 1
	    *d = toupper(*d);
d608 1
a608 1
	    *d = toupper(*d);
d610 1
a610 1
	    *d = toupper(*d);
d623 1
a623 1
	    *d = toupper(*d);
d625 1
a625 1
	    *d = toupper(*d);
d627 1
a627 1
	    *d = toupper(*d);
d629 1
a629 1
	    *d = toupper(*d);
d631 1
a631 1
	    *d = toupper(*d);
d633 1
a633 1
	    *d = toupper(*d);
d642 1
a642 1
	    *d = toupper(*d);
d653 1
a653 1
	    *d = toupper(*d);
d669 1
a669 1
	    *d = toupper(*d);
d671 1
a671 1
	    *d = toupper(*d);
d673 1
a673 1
	    *d = toupper(*d);
d684 1
a684 1
	    *d = toupper(*d);
d686 1
a686 1
	    *d = toupper(*d);
d704 1
a704 1
	    *d = toupper(*d);
d706 1
a706 1
	    *d = toupper(*d);
d708 1
a708 1
	    *d = toupper(*d);
d751 1
a751 1
	    *d = toupper(*d);
d753 1
a753 1
	    *d = toupper(*d);
d755 1
a755 1
	    *d = toupper(*d);
d757 1
a757 1
	    *d = toupper(*d);
d759 1
a759 1
	    *d = toupper(*d);
d761 1
a761 1
	    *d = toupper(*d);
d763 1
a763 1
	    *d = toupper(*d);
d765 1
a765 1
	    *d = toupper(*d);
d767 1
a767 1
	    *d = toupper(*d);
d772 1
a772 1
	    *d = toupper(*d);
d774 1
a774 1
	    *d = toupper(*d);
d776 1
a776 1
	    *d = toupper(*d);
d778 1
a778 1
	    *d = toupper(*d);
d783 1
a783 1
	    *d = toupper(*d);
d785 1
a785 1
	    *d = toupper(*d);
d787 1
a787 1
	    *d = toupper(*d);
d789 1
a789 1
	    *d = toupper(*d);
d791 1
a791 1
	    *d = toupper(*d);
d793 1
a793 1
	    *d = toupper(*d);
d798 1
a798 1
	    *d = toupper(*d);
d805 1
a805 1
	    *d = toupper(*d);
d807 1
a807 1
	    *d = toupper(*d);
d812 1
a812 1
	    *d = toupper(*d);
d817 1
a817 1
	    *d = toupper(*d);
d886 1
a886 1
	while (isdigit(*s)) {
d890 1
a890 1
	    if (isdigit(s[1])) {
d892 1
a892 1
		while (isdigit(*s)) {
d903 1
a903 1
	    while (isdigit(*s))
d1076 1
a1076 1
	    for (t = s+1; isspace(*t & 127); t++) ;
d1078 1
a1078 1
	    while (isspace(*t & 127) && *t != '\n') t--;
d1111 1
a1111 1
	    for (t = tokenbuf; isspace(*t & 127); t++) {
d1243 1
a1243 1
    int numargs;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
@


1.3
log
@perl5.005_03 (stock)
@
text
@d38 1
a38 1
    printf("\nThis is the AWK to PERL translator, version 5.0, patchlevel %d\n", PATCHLEVEL);
d708 9
a716 2
	if (strEQ(d,"sprintf"))
	    XTERM(SPRINTF);
@


1.2
log
@perl 5.004_04
@
text
@d11 4
a14 1
#ifdef OS2
d24 10
a33 7
int oper0();
int oper1();
int oper2();
int oper3();
int oper4();
int oper5();
STR *walk();
a34 1
#ifdef OS2
d52 1
a52 4
main(argc,argv,env)
register int argc;
register char **argv;
register char **env;
d69 1
a69 1
#ifdef YYDEBUG
d94 4
a98 2
#ifdef OS2
            usage();
d107 1
a107 1
#ifdef OS2
d207 1
a207 1
yylex()
d214 1
a214 1
#ifdef YYDEBUG
d276 3
d280 1
d805 1
a805 2
scanpat(s)
register char *s;
d850 1
a850 2
yyerror(s)
char *s;
d857 1
a857 2
scannum(s)
register char *s;
d893 1
a893 3
string(ptr,len)
char *ptr;
int len;
d900 1
a900 1
    ops[mop].cval = safemalloc(len+1);
d909 1
a909 2
oper0(type)
int type;
d922 1
a922 3
oper1(type,arg1)
int type;
int arg1;
d936 1
a936 4
oper2(type,arg1,arg2)
int type;
int arg1;
int arg2;
d951 1
a951 5
oper3(type,arg1,arg2,arg3)
int type;
int arg1;
int arg2;
int arg3;
d967 1
a967 6
oper4(type,arg1,arg2,arg3,arg4)
int type;
int arg1;
int arg2;
int arg3;
int arg4;
d984 1
a984 7
oper5(type,arg1,arg2,arg3,arg4,arg5)
int type;
int arg1;
int arg2;
int arg3;
int arg4;
int arg5;
d1004 1
a1004 2
dump(branch)
int branch;
d1031 1
a1031 3
bl(arg,maybe)
int arg;
int maybe;
d1044 1
a1044 2
fixup(str)
STR *str;
d1069 1
a1069 2
putlines(str)
STR *str;
d1145 1
a1145 1
putone()
d1168 1
a1168 2
numary(arg)
int arg;
d1182 1
a1182 2
rememberargs(arg)
int arg;
d1204 1
a1204 2
aryrefarg(arg)
int arg;
d1218 1
a1218 4
fixfargs(name,arg,prevargs)
int name;
int arg;
int prevargs;
d1254 1
a1254 4
fixrargs(name,arg,prevargs)
char *name;
int arg;
int prevargs;
d1268 1
a1268 1
	char *tmpbuf = safemalloc(strlen(name) + (sizeof(prevargs) * 3) + 5);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991, Larry Wall
d30 1
d45 2
d83 3
d163 3
a165 1
    str_cat(str, "\neval 'exec perl -S $0 \"$@@\"'\n\
d1300 1
a1300 2
	char tmpbuf[128];

d1303 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d11 1
a11 4
#if defined(OS2) || defined(WIN32)
#if defined(WIN32)
#include <io.h>
#endif
d21 7
a27 10
int oper0(int type);
int oper1(int type, int arg1);
int oper2(int type, int arg1, int arg2);
int oper3(int type, int arg1, int arg2, int arg3);
int oper4(int type, int arg1, int arg2, int arg3, int arg4);
int oper5(int type, int arg1, int arg2, int arg3, int arg4, int arg5);
STR *walk(int useval, int level, register int node, int *numericptr, int minprec);

#if defined(OS2) || defined(WIN32)
static void usage(void);
d29 1
a29 1
static void
d44 4
a47 3

int
main(register int argc, register char **argv, register char **env)
d64 1
a64 1
#if YYDEBUG
a79 3
	case 'o':
	    old_awk = TRUE;
	    break;
d86 2
a87 2
#if defined(OS2) || defined(WIN32)
	    fprintf(stderr, "Unrecognized switch: %s\n",argv[0]);
a88 2
#else
	    fatal("Unrecognized switch: %s\n",argv[0]);
d97 1
a97 1
#if defined(OS2) || defined(WIN32)
d157 1
a157 3
    str_cat(str, "\neval 'exec ");
    str_cat(str, BIN);
    str_cat(str, "/perl -S $0 ${1+\"$@@\"}'\n\
d195 1
a195 1
yylex(void)
d202 1
a202 1
#if YYDEBUG
a263 3
#ifdef EBCDIC
    case 7:
#else
a264 1
#endif
d789 2
a790 1
scanpat(register char *s)
d835 2
a836 1
yyerror(char *s)
d843 2
a844 1
scannum(register char *s)
d880 3
a882 1
string(char *ptr, int len)
d889 1
a889 1
    ops[mop].cval = (char *) safemalloc(len+1);
d898 2
a899 1
oper0(int type)
d912 3
a914 1
oper1(int type, int arg1)
d928 4
a931 1
oper2(int type, int arg1, int arg2)
d946 5
a950 1
oper3(int type, int arg1, int arg2, int arg3)
d966 6
a971 1
oper4(int type, int arg1, int arg2, int arg3, int arg4)
d988 7
a994 1
oper5(int type, int arg1, int arg2, int arg3, int arg4, int arg5)
d1014 2
a1015 1
dump(int branch)
d1042 3
a1044 1
bl(int arg, int maybe)
d1057 2
a1058 1
fixup(STR *str)
d1083 2
a1084 1
putlines(STR *str)
d1160 1
a1160 1
putone(void)
d1183 2
a1184 1
numary(int arg)
d1198 2
a1199 1
rememberargs(int arg)
d1221 2
a1222 1
aryrefarg(int arg)
d1236 4
a1239 1
fixfargs(int name, int arg, int prevargs)
d1275 4
a1278 1
fixrargs(char *name, int arg, int prevargs)
d1292 2
a1293 1
	char *tmpbuf = (char *) safemalloc(strlen(name) + (sizeof(prevargs) * 3) + 5);
a1295 1
	safefree(tmpbuf);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d38 1
a38 1
    printf("\nThis is the AWK to PERL translator, revision %d.0, version %d\n", PERL_REVISION, PERL_VERSION);
d708 2
a709 9
	if (strEQ(d,"sprintf")) {
            /* In old awk, { print sprintf("str%sg"),"in" } prints
             * "string"; in new awk, "in" is not considered an argument to
             * sprintf, so the statement breaks.  To support both, the
             * grammar treats arguments to SPRINTF_OLD like old awk,
             * SPRINTF_NEW like new.  Here we return the appropriate one.
             */
	    XTERM(old_awk ? SPRINTF_OLD : SPRINTF_NEW);
        }
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d11 1
a11 1
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
a14 3
#if defined(NETWARE)
#include "../netware/clibstuf.h"
#endif
a30 4
#ifdef NETWARE
char *savestr(char *str);
char *cpy2(register char *to, register char *from, register int delim);
#endif
d32 1
a32 1
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
a56 5
    /* char *namelist;    */

	#ifdef NETWARE
		fnInitGpfGlobals();	/* For importing the CLIB calls in place of Watcom calls */
	#endif	/* NETWARE */
d64 1
d94 1
a94 1
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
d107 1
a107 1
#if defined(OS2) || defined(WIN32) || defined(NETWARE)
a196 2
    /* by ANSI specs return is needed. This also shuts up VC++ and his warnings */
    return(0);
d215 1
a215 1
    if (yydebug) {
a219 1
    }
d284 1
a284 1
	for (d = s + 1; isSPACE(*d); d++) ;
d386 1
a386 1
	while (isALPHA(*s) || isDIGIT(*s) || *s == '_') \
d405 2
a406 2
	if (isDIGIT(*s)) {
	    for (d = s; isDIGIT(*s); s++) ;
d476 1
a476 1
	    *d = toUPPER(*d);
d478 1
a478 1
	    *d = toUPPER(*d);
d480 1
a480 1
	    *d = toUPPER(*d);
d482 1
a482 1
	    *d = toUPPER(*d);
d484 1
a484 1
	    *d = toUPPER(*d);
d493 1
a493 1
	    *d = toUPPER(*d);
d510 1
a510 1
	    *d = toUPPER(*d);
d512 1
a512 1
	    *d = toUPPER(*d);
d514 1
a514 1
	    *d = toUPPER(*d);
d516 1
a516 1
	    *d = toUPPER(*d);
d518 1
a518 1
	    *d = toUPPER(*d);
d520 1
a520 1
	    *d = toUPPER(*d);
d527 1
a527 1
		for (d = s; *d && isSPACE(*d); d++) ;
d529 1
a529 1
		    for (d++; *d && isSPACE(*d); d++) ;
d543 1
a543 1
	    *d = toUPPER(*d);
d545 1
a545 1
	    *d = toUPPER(*d);
d547 1
a547 1
	    *d = toUPPER(*d);
d549 1
a549 1
	    *d = toUPPER(*d);
d558 1
a558 1
	    *d = toUPPER(*d);
d560 1
a560 1
	    *d = toUPPER(*d);
d562 1
a562 1
	    *d = toUPPER(*d);
d564 1
a564 1
	    *d = toUPPER(*d);
d569 1
a569 1
	    *d = toUPPER(*d);
d589 1
a589 1
	    *d = toUPPER(*d);
d594 1
a594 1
	    *d = toUPPER(*d);
d596 1
a596 1
	    *d = toUPPER(*d);
d609 1
a609 1
	    *d = toUPPER(*d);
d611 1
a611 1
	    *d = toUPPER(*d);
d613 1
a613 1
	    *d = toUPPER(*d);
d615 1
a615 1
	    *d = toUPPER(*d);
d617 1
a617 1
	    *d = toUPPER(*d);
d619 1
a619 1
	    *d = toUPPER(*d);
d628 1
a628 1
	    *d = toUPPER(*d);
d639 1
a639 1
	    *d = toUPPER(*d);
d655 1
a655 1
	    *d = toUPPER(*d);
d657 1
a657 1
	    *d = toUPPER(*d);
d659 1
a659 1
	    *d = toUPPER(*d);
d670 1
a670 1
	    *d = toUPPER(*d);
d672 1
a672 1
	    *d = toUPPER(*d);
d690 1
a690 1
	    *d = toUPPER(*d);
d692 1
a692 1
	    *d = toUPPER(*d);
d694 1
a694 1
	    *d = toUPPER(*d);
d737 1
a737 1
	    *d = toUPPER(*d);
d739 1
a739 1
	    *d = toUPPER(*d);
d741 1
a741 1
	    *d = toUPPER(*d);
d743 1
a743 1
	    *d = toUPPER(*d);
d745 1
a745 1
	    *d = toUPPER(*d);
d747 1
a747 1
	    *d = toUPPER(*d);
d749 1
a749 1
	    *d = toUPPER(*d);
d751 1
a751 1
	    *d = toUPPER(*d);
d753 1
a753 1
	    *d = toUPPER(*d);
d758 1
a758 1
	    *d = toUPPER(*d);
d760 1
a760 1
	    *d = toUPPER(*d);
d762 1
a762 1
	    *d = toUPPER(*d);
d764 1
a764 1
	    *d = toUPPER(*d);
d769 1
a769 1
	    *d = toUPPER(*d);
d771 1
a771 1
	    *d = toUPPER(*d);
d773 1
a773 1
	    *d = toUPPER(*d);
d775 1
a775 1
	    *d = toUPPER(*d);
d777 1
a777 1
	    *d = toUPPER(*d);
d779 1
a779 1
	    *d = toUPPER(*d);
d784 1
a784 1
	    *d = toUPPER(*d);
d791 1
a791 1
	    *d = toUPPER(*d);
d793 1
a793 1
	    *d = toUPPER(*d);
d798 1
a798 1
	    *d = toUPPER(*d);
d803 1
a803 1
	    *d = toUPPER(*d);
d872 1
a872 1
	while (isDIGIT(*s)) {
d876 1
a876 1
	    if (isDIGIT(s[1])) {
d878 1
a878 1
		while (isDIGIT(*s)) {
d889 1
a889 1
	    while (isDIGIT(*s))
d1062 1
a1062 1
	    for (t = s+1; isSPACE(*t & 127); t++) ;
d1064 1
a1064 1
	    while (isSPACE(*t & 127) && *t != '\n') t--;
d1097 1
a1097 1
	    for (t = tokenbuf; isSPACE(*t & 127); t++) {
d1229 1
a1229 1
    int numargs = 0;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, by Larry Wall and others
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d1 1
a1 1
/* $RCSfile: a2py.c,v $$Revision: 1.7 $$Date: 2003/12/03 03:02:53 $
d9 1
a9 4
 * $Log: a2py.c,v $
 * Revision 1.7  2003/12/03 03:02:53  millert
 * Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
 *
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d1 1
a1 1
/* $RCSfile: a2py.c,v $$Revision: 4.1 $$Date: 92/08/07 18:29:14 $
d9 4
a12 1
 * $Log:	a2py.c,v $
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d1 1
a1 1
/*    a2py.c
d8 2
a58 4
#ifdef __osf__
#pragma message disable (mainparm) /* We have the envp in main(). */
#endif

a427 2
	for (d = s; isALPHA(*s) || isDIGIT(*s) || *s == '_'; )
	    s++;
a428 5
	if (d != s)
	{
	    yylval = string(d,s-d);
	    XTERM(SVFIELD);
	}
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d21 2
a22 2
const char *filename;
const char *myname;
d62 1
a62 1
main(register int argc, register const char **argv, register const char **env)
d120 1
a120 1
    if (argv[0] == NULL) {
d129 1
d136 1
a136 1
    if (rsfp == NULL)
d257 1
a257 1
	if ((s = str_gets(linestr, rsfp)) == NULL) {
d260 1
a260 1
	    rsfp = NULL;
d565 1
a565 1
	    ID("ARGV");
d669 1
a669 1
	    ID("\\");
d673 1
a673 1
	    ID(",");
d676 1
a676 1
	    ID("#");
d704 1
a705 1
	    ID("/");
d746 1
a746 1
	    ID(";");
d881 1
a881 1
yyerror(const char *s)
d924 1
a924 1
string(const char *ptr, int len)
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d431 1
a431 1
	split_to_array = TRUE;
d467 2
d601 1
d647 1
d656 1
a656 1
	    do_chop = do_split = split_to_array = TRUE;
d722 1
d726 1
d1207 1
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a19 2
#include "../unicode_constants.h"
#define DELETE_CHAR DEL_NATIVE
d32 1
a32 1
STR *walk(int useval, int level, int node, int *numericptr, int minprec);
d35 1
a35 1
char *cpy2(char *to, char *from, int delim);
d62 1
a62 1
main(int argc, const char **argv, const char **env)
d64 1
a64 1
    STR *str;
d224 3
a226 3
    char *s = bufptr;
    char *d;
    int tmp;
d292 5
a296 1
    case DELETE_CHAR:
d402 1
a402 1
	while (isWORDCHAR(*s)) \
d429 1
a429 1
	for (d = s; isWORDCHAR(*s); )
d829 1
a829 1
scanpat(char *s)
d831 1
a831 1
    char *d;
d881 1
a881 1
scannum(char *s)
d883 1
a883 1
    char *d;
d1030 3
a1032 3
    int type;
    int len;
    int i;
d1070 2
a1071 2
    char *s;
    char *t;
d1095 2
a1096 2
    char *d, *s, *t, *e;
    int pos, newpos;
d1171 1
a1171 1
    char *t;
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@d59 4
d64 1
a64 1
main(int argc, const char **argv)
@


