head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.22;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.59;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.18;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.56;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.47;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.22;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.37;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.48;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.16.36;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.47.43;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.33;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.40;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.47;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    scope.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * For the fashion of Minas Tirith was such that it was built on seven
 * levels...
 *
 *     [p.751 of _The Lord of the Rings_, V/i: "Minas Tirith"]
 */

/* This file contains functions to manipulate several of Perl's stacks;
 * in particular it contains code to push various types of things onto
 * the savestack, then to pop them off and perform the correct restorative
 * action for each one. This corresponds to the cleanup Perl does at
 * each scope exit.
 */

#include "EXTERN.h"
#define PERL_IN_SCOPE_C
#include "perl.h"

SV**
Perl_stack_grow(pTHX_ SV **sp, SV **p, SSize_t n)
{
    SSize_t extra;
    SSize_t current = (p - PL_stack_base);

    PERL_ARGS_ASSERT_STACK_GROW;

    if (UNLIKELY(n < 0))
        Perl_croak(aTHX_
            "panic: stack_grow() negative count (%"IVdf")", (IV)n);

    PL_stack_sp = sp;
    extra =
#ifdef STRESS_REALLOC
        1;
#else
        128;
#endif
    /* If the total might wrap, panic instead. This is really testing
     * that (current + n + extra < SSize_t_MAX), but done in a way that
     * can't wrap */
    if (UNLIKELY(   current         > SSize_t_MAX - extra
                 || current + extra > SSize_t_MAX - n
    ))
        /* diag_listed_as: Out of memory during %s extend */
        Perl_croak(aTHX_ "Out of memory during stack extend");

    av_extend(PL_curstack, current + n + extra);
    return PL_stack_sp;
}

#ifndef STRESS_REALLOC
#define GROW(old) ((old) * 3 / 2)
#else
#define GROW(old) ((old) + 1)
#endif

PERL_SI *
Perl_new_stackinfo(pTHX_ I32 stitems, I32 cxitems)
{
    PERL_SI *si;
    Newx(si, 1, PERL_SI);
    si->si_stack = newAV();
    AvREAL_off(si->si_stack);
    av_extend(si->si_stack, stitems > 0 ? stitems-1 : 0);
    AvALLOC(si->si_stack)[0] = &PL_sv_undef;
    AvFILLp(si->si_stack) = 0;
    si->si_prev = 0;
    si->si_next = 0;
    si->si_cxmax = cxitems - 1;
    si->si_cxix = -1;
    si->si_type = PERLSI_UNDEF;
    Newx(si->si_cxstack, cxitems, PERL_CONTEXT);
    /* Without any kind of initialising CX_PUSHSUBST()
     * in pp_subst() will read uninitialised heap. */
    PoisonNew(si->si_cxstack, cxitems, PERL_CONTEXT);
    return si;
}

I32
Perl_cxinc(pTHX)
{
    const IV old_max = cxstack_max;
    cxstack_max = GROW(cxstack_max);
    Renew(cxstack, cxstack_max + 1, PERL_CONTEXT);
    /* Without any kind of initialising deep enough recursion
     * will end up reading uninitialised PERL_CONTEXTs. */
    PoisonNew(cxstack + old_max + 1, cxstack_max - old_max, PERL_CONTEXT);
    return cxstack_ix + 1;
}

void
Perl_push_scope(pTHX)
{
    if (UNLIKELY(PL_scopestack_ix == PL_scopestack_max)) {
	PL_scopestack_max = GROW(PL_scopestack_max);
	Renew(PL_scopestack, PL_scopestack_max, I32);
#ifdef DEBUGGING
	Renew(PL_scopestack_name, PL_scopestack_max, const char*);
#endif
    }
#ifdef DEBUGGING
    PL_scopestack_name[PL_scopestack_ix] = "unknown";
#endif
    PL_scopestack[PL_scopestack_ix++] = PL_savestack_ix;

}

void
Perl_pop_scope(pTHX)
{
    const I32 oldsave = PL_scopestack[--PL_scopestack_ix];
    LEAVE_SCOPE(oldsave);
}

I32 *
Perl_markstack_grow(pTHX)
{
    const I32 oldmax = PL_markstack_max - PL_markstack;
    const I32 newmax = GROW(oldmax);

    Renew(PL_markstack, newmax, I32);
    PL_markstack_max = PL_markstack + newmax;
    PL_markstack_ptr = PL_markstack + oldmax;
    DEBUG_s(DEBUG_v(PerlIO_printf(Perl_debug_log,
            "MARK grow %p %"IVdf" by %"IVdf"\n",
            PL_markstack_ptr, (IV)*PL_markstack_ptr, (IV)oldmax)));
    return PL_markstack_ptr;
}

void
Perl_savestack_grow(pTHX)
{
    PL_savestack_max = GROW(PL_savestack_max);
    /* Note that we allocate SS_MAXPUSH slots higher than ss_max
     * so that SS_ADD_END(), SSGROW() etc can do a simper check */
    Renew(PL_savestack, PL_savestack_max + SS_MAXPUSH, ANY);
}

void
Perl_savestack_grow_cnt(pTHX_ I32 need)
{
    PL_savestack_max = PL_savestack_ix + need;
    /* Note that we allocate SS_MAXPUSH slots higher than ss_max
     * so that SS_ADD_END(), SSGROW() etc can do a simper check */
    Renew(PL_savestack, PL_savestack_max + SS_MAXPUSH, ANY);
}

#undef GROW

/*  The original function was called Perl_tmps_grow and was removed from public
    API, Perl_tmps_grow_p is the replacement and it used in public macros but
    isn't public itself.

    Perl_tmps_grow_p takes a proposed ix. A proposed ix is PL_tmps_ix + extend_by,
    where the result of (PL_tmps_ix + extend_by) is >= PL_tmps_max
    Upon return, PL_tmps_stack[ix] will be a valid address. For machine code
    optimization and register usage reasons, the proposed ix passed into
    tmps_grow is returned to the caller which the caller can then use to write
    an SV * to PL_tmps_stack[ix]. If the caller was using tmps_grow in
    pre-extend mode (EXTEND_MORTAL macro), then it ignores the return value of
    tmps_grow. Note, tmps_grow DOES NOT write ix to PL_tmps_ix, the caller
    must assign ix or ret val of tmps_grow to PL_temps_ix themselves if that is
    appropriate. The assignment to PL_temps_ix can happen before or after
    tmps_grow call since tmps_grow doesn't look at PL_tmps_ix.
 */

SSize_t
Perl_tmps_grow_p(pTHX_ SSize_t ix)
{
    SSize_t extend_to = ix;
#ifndef STRESS_REALLOC
    if (ix - PL_tmps_max < 128)
	extend_to += (PL_tmps_max < 512) ? 128 : 512;
#endif
    PL_tmps_max = extend_to + 1;
    Renew(PL_tmps_stack, PL_tmps_max, SV*);
    return ix;
}


void
Perl_free_tmps(pTHX)
{
    /* XXX should tmps_floor live in cxstack? */
    const SSize_t myfloor = PL_tmps_floor;
    while (PL_tmps_ix > myfloor) {      /* clean up after last statement */
	SV* const sv = PL_tmps_stack[PL_tmps_ix--];
#ifdef PERL_POISON
	PoisonWith(PL_tmps_stack + PL_tmps_ix + 1, 1, SV *, 0xAB);
#endif
	if (LIKELY(sv)) {
	    SvTEMP_off(sv);
	    SvREFCNT_dec_NN(sv);		/* note, can modify tmps_ix!!! */
	}
    }
}

STATIC SV *
S_save_scalar_at(pTHX_ SV **sptr, const U32 flags)
{
    SV * osv;
    SV *sv;

    PERL_ARGS_ASSERT_SAVE_SCALAR_AT;

    osv = *sptr;
    if (flags & SAVEf_KEEPOLDELEM)
        sv = osv;
    else {
        sv  = (*sptr = newSV(0));
        if (SvTYPE(osv) >= SVt_PVMG && SvMAGIC(osv))
            mg_localize(osv, sv, cBOOL(flags & SAVEf_SETMAGIC));
    }

    return sv;
}

void
Perl_save_pushptrptr(pTHX_ void *const ptr1, void *const ptr2, const int type)
{
    dSS_ADD;
    SS_ADD_PTR(ptr1);
    SS_ADD_PTR(ptr2);
    SS_ADD_UV(type);
    SS_ADD_END(3);
}

SV *
Perl_save_scalar(pTHX_ GV *gv)
{
    SV ** const sptr = &GvSVn(gv);

    PERL_ARGS_ASSERT_SAVE_SCALAR;

    if (UNLIKELY(SvGMAGICAL(*sptr))) {
        PL_localizing = 1;
        (void)mg_get(*sptr);
        PL_localizing = 0;
    }
    save_pushptrptr(SvREFCNT_inc_simple(gv), SvREFCNT_inc(*sptr), SAVEt_SV);
    return save_scalar_at(sptr, SAVEf_SETMAGIC); /* XXX - FIXME - see #60360 */
}

/* Like save_sptr(), but also SvREFCNT_dec()s the new value.  Can be used to
 * restore a global SV to its prior contents, freeing new value. */
void
Perl_save_generic_svref(pTHX_ SV **sptr)
{
    PERL_ARGS_ASSERT_SAVE_GENERIC_SVREF;

    save_pushptrptr(sptr, SvREFCNT_inc(*sptr), SAVEt_GENERIC_SVREF);
}

/* Like save_pptr(), but also Safefree()s the new value if it is different
 * from the old one.  Can be used to restore a global char* to its prior
 * contents, freeing new value. */
void
Perl_save_generic_pvref(pTHX_ char **str)
{
    PERL_ARGS_ASSERT_SAVE_GENERIC_PVREF;

    save_pushptrptr(*str, str, SAVEt_GENERIC_PVREF);
}

/* Like save_generic_pvref(), but uses PerlMemShared_free() rather than Safefree().
 * Can be used to restore a shared global char* to its prior
 * contents, freeing new value. */
void
Perl_save_shared_pvref(pTHX_ char **str)
{
    PERL_ARGS_ASSERT_SAVE_SHARED_PVREF;

    save_pushptrptr(str, *str, SAVEt_SHARED_PVREF);
}

/* set the SvFLAGS specified by mask to the values in val */

void
Perl_save_set_svflags(pTHX_ SV* sv, U32 mask, U32 val)
{
    dSS_ADD;

    PERL_ARGS_ASSERT_SAVE_SET_SVFLAGS;

    SS_ADD_PTR(sv);
    SS_ADD_INT(mask);
    SS_ADD_INT(val);
    SS_ADD_UV(SAVEt_SET_SVFLAGS);
    SS_ADD_END(4);
}

/*
=for apidoc save_gp

Saves the current GP of gv on the save stack to be restored on scope exit.

If empty is true, replace the GP with a new GP.

If empty is false, mark gv with GVf_INTRO so the next reference
assigned is localized, which is how C< local *foo = $someref; > works.

=cut
*/

void
Perl_save_gp(pTHX_ GV *gv, I32 empty)
{
    PERL_ARGS_ASSERT_SAVE_GP;

    save_pushptrptr(SvREFCNT_inc(gv), GvGP(gv), SAVEt_GP);

    if (empty) {
	GP *gp = Perl_newGP(aTHX_ gv);
	HV * const stash = GvSTASH(gv);
	bool isa_changed = 0;

	if (stash && HvENAME(stash)) {
	    if (GvNAMELEN(gv) == 3 && strnEQ(GvNAME(gv), "ISA", 3))
		isa_changed = TRUE;
	    else if (GvCVu(gv))
		/* taking a method out of circulation ("local")*/
                mro_method_changed_in(stash);
	}
	if (GvIOp(gv) && (IoFLAGS(GvIOp(gv)) & IOf_ARGV)) {
	    gp->gp_io = newIO();
	    IoFLAGS(gp->gp_io) |= IOf_ARGV|IOf_START;
	}
	GvGP_set(gv,gp);
	if (isa_changed) mro_isa_changed_in(stash);
    }
    else {
	gp_ref(GvGP(gv));
	GvINTRO_on(gv);
    }
}

AV *
Perl_save_ary(pTHX_ GV *gv)
{
    AV * const oav = GvAVn(gv);
    AV *av;

    PERL_ARGS_ASSERT_SAVE_ARY;

    if (UNLIKELY(!AvREAL(oav) && AvREIFY(oav)))
	av_reify(oav);
    save_pushptrptr(SvREFCNT_inc_simple_NN(gv), oav, SAVEt_AV);

    GvAV(gv) = NULL;
    av = GvAVn(gv);
    if (UNLIKELY(SvMAGIC(oav)))
	mg_localize(MUTABLE_SV(oav), MUTABLE_SV(av), TRUE);
    return av;
}

HV *
Perl_save_hash(pTHX_ GV *gv)
{
    HV *ohv, *hv;

    PERL_ARGS_ASSERT_SAVE_HASH;

    save_pushptrptr(
	SvREFCNT_inc_simple_NN(gv), (ohv = GvHVn(gv)), SAVEt_HV
    );

    GvHV(gv) = NULL;
    hv = GvHVn(gv);
    if (UNLIKELY(SvMAGIC(ohv)))
	mg_localize(MUTABLE_SV(ohv), MUTABLE_SV(hv), TRUE);
    return hv;
}

void
Perl_save_item(pTHX_ SV *item)
{
    SV * const sv = newSVsv(item);

    PERL_ARGS_ASSERT_SAVE_ITEM;

    save_pushptrptr(item, /* remember the pointer */
		    sv,   /* remember the value */
		    SAVEt_ITEM);
}

void
Perl_save_bool(pTHX_ bool *boolp)
{
    dSS_ADD;

    PERL_ARGS_ASSERT_SAVE_BOOL;

    SS_ADD_PTR(boolp);
    SS_ADD_UV(SAVEt_BOOL | (*boolp << 8));
    SS_ADD_END(2);
}

void
Perl_save_pushi32ptr(pTHX_ const I32 i, void *const ptr, const int type)
{
    dSS_ADD;

    SS_ADD_INT(i);
    SS_ADD_PTR(ptr);
    SS_ADD_UV(type);
    SS_ADD_END(3);
}

void
Perl_save_int(pTHX_ int *intp)
{
    const int i = *intp;
    UV type = ((UV)((UV)i << SAVE_TIGHT_SHIFT) | SAVEt_INT_SMALL);
    int size = 2;
    dSS_ADD;

    PERL_ARGS_ASSERT_SAVE_INT;

    if (UNLIKELY((int)(type >> SAVE_TIGHT_SHIFT) != i)) {
        SS_ADD_INT(i);
        type = SAVEt_INT;
        size++;
    }
    SS_ADD_PTR(intp);
    SS_ADD_UV(type);
    SS_ADD_END(size);
}

void
Perl_save_I8(pTHX_ I8 *bytep)
{
    dSS_ADD;

    PERL_ARGS_ASSERT_SAVE_I8;

    SS_ADD_PTR(bytep);
    SS_ADD_UV(SAVEt_I8 | ((UV)*bytep << 8));
    SS_ADD_END(2);
}

void
Perl_save_I16(pTHX_ I16 *intp)
{
    dSS_ADD;

    PERL_ARGS_ASSERT_SAVE_I16;

    SS_ADD_PTR(intp);
    SS_ADD_UV(SAVEt_I16 | ((UV)*intp << 8));
    SS_ADD_END(2);
}

void
Perl_save_I32(pTHX_ I32 *intp)
{
    const I32 i = *intp;
    UV type = ((I32)((U32)i << SAVE_TIGHT_SHIFT) | SAVEt_I32_SMALL);
    int size = 2;
    dSS_ADD;

    PERL_ARGS_ASSERT_SAVE_I32;

    if (UNLIKELY((I32)(type >> SAVE_TIGHT_SHIFT) != i)) {
        SS_ADD_INT(i);
        type = SAVEt_I32;
        size++;
    }
    SS_ADD_PTR(intp);
    SS_ADD_UV(type);
    SS_ADD_END(size);
}

void
Perl_save_strlen(pTHX_ STRLEN *ptr)
{
    dSS_ADD;

    PERL_ARGS_ASSERT_SAVE_STRLEN;

    SS_ADD_IV(*ptr);
    SS_ADD_PTR(ptr);
    SS_ADD_UV(SAVEt_STRLEN);
    SS_ADD_END(3);
}

/* Cannot use save_sptr() to store a char* since the SV** cast will
 * force word-alignment and we'll miss the pointer.
 */
void
Perl_save_pptr(pTHX_ char **pptr)
{
    PERL_ARGS_ASSERT_SAVE_PPTR;

    save_pushptrptr(*pptr, pptr, SAVEt_PPTR);
}

void
Perl_save_vptr(pTHX_ void *ptr)
{
    PERL_ARGS_ASSERT_SAVE_VPTR;

    save_pushptrptr(*(char**)ptr, ptr, SAVEt_VPTR);
}

void
Perl_save_sptr(pTHX_ SV **sptr)
{
    PERL_ARGS_ASSERT_SAVE_SPTR;

    save_pushptrptr(*sptr, sptr, SAVEt_SPTR);
}

void
Perl_save_padsv_and_mortalize(pTHX_ PADOFFSET off)
{
    dSS_ADD;

    ASSERT_CURPAD_ACTIVE("save_padsv");
    SS_ADD_PTR(SvREFCNT_inc_simple_NN(PL_curpad[off]));
    SS_ADD_PTR(PL_comppad);
    SS_ADD_UV((UV)off);
    SS_ADD_UV(SAVEt_PADSV_AND_MORTALIZE);
    SS_ADD_END(4);
}

void
Perl_save_hptr(pTHX_ HV **hptr)
{
    PERL_ARGS_ASSERT_SAVE_HPTR;

    save_pushptrptr(*hptr, hptr, SAVEt_HPTR);
}

void
Perl_save_aptr(pTHX_ AV **aptr)
{
    PERL_ARGS_ASSERT_SAVE_APTR;

    save_pushptrptr(*aptr, aptr, SAVEt_APTR);
}

void
Perl_save_pushptr(pTHX_ void *const ptr, const int type)
{
    dSS_ADD;
    SS_ADD_PTR(ptr);
    SS_ADD_UV(type);
    SS_ADD_END(2);
}

void
Perl_save_clearsv(pTHX_ SV **svp)
{
    const UV offset = svp - PL_curpad;
    const UV offset_shifted = offset << SAVE_TIGHT_SHIFT;

    PERL_ARGS_ASSERT_SAVE_CLEARSV;

    ASSERT_CURPAD_ACTIVE("save_clearsv");
    SvPADSTALE_off(*svp); /* mark lexical as active */
    if (UNLIKELY((offset_shifted >> SAVE_TIGHT_SHIFT) != offset)) {
	Perl_croak(aTHX_ "panic: pad offset %"UVuf" out of range (%p-%p)",
		   offset, svp, PL_curpad);
    }

    {
        dSS_ADD;
        SS_ADD_UV(offset_shifted | SAVEt_CLEARSV);
        SS_ADD_END(1);
    }
}

void
Perl_save_delete(pTHX_ HV *hv, char *key, I32 klen)
{
    PERL_ARGS_ASSERT_SAVE_DELETE;

    save_pushptri32ptr(key, klen, SvREFCNT_inc_simple(hv), SAVEt_DELETE);
}

void
Perl_save_hdelete(pTHX_ HV *hv, SV *keysv)
{
    STRLEN len;
    I32 klen;
    const char *key;

    PERL_ARGS_ASSERT_SAVE_HDELETE;

    key  = SvPV_const(keysv, len);
    klen = SvUTF8(keysv) ? -(I32)len : (I32)len;
    SvREFCNT_inc_simple_void_NN(hv);
    save_pushptri32ptr(savepvn(key, len), klen, hv, SAVEt_DELETE);
}

void
Perl_save_adelete(pTHX_ AV *av, SSize_t key)
{
    dSS_ADD;

    PERL_ARGS_ASSERT_SAVE_ADELETE;

    SvREFCNT_inc_void(av);
    SS_ADD_UV(key);
    SS_ADD_PTR(av);
    SS_ADD_IV(SAVEt_ADELETE);
    SS_ADD_END(3);
}

void
Perl_save_destructor(pTHX_ DESTRUCTORFUNC_NOCONTEXT_t f, void* p)
{
    dSS_ADD;
    PERL_ARGS_ASSERT_SAVE_DESTRUCTOR;

    SS_ADD_DPTR(f);
    SS_ADD_PTR(p);
    SS_ADD_UV(SAVEt_DESTRUCTOR);
    SS_ADD_END(3);
}

void
Perl_save_destructor_x(pTHX_ DESTRUCTORFUNC_t f, void* p)
{
    dSS_ADD;

    SS_ADD_DXPTR(f);
    SS_ADD_PTR(p);
    SS_ADD_UV(SAVEt_DESTRUCTOR_X);
    SS_ADD_END(3);
}

void
Perl_save_hints(pTHX)
{
    COPHH *save_cophh = cophh_copy(CopHINTHASH_get(&PL_compiling));
    if (PL_hints & HINT_LOCALIZE_HH) {
	HV *oldhh = GvHV(PL_hintgv);
	save_pushptri32ptr(oldhh, PL_hints, save_cophh, SAVEt_HINTS);
	GvHV(PL_hintgv) = NULL; /* in case copying dies */
	GvHV(PL_hintgv) = hv_copy_hints_hv(oldhh);
    } else {
	save_pushi32ptr(PL_hints, save_cophh, SAVEt_HINTS);
    }
}

static void
S_save_pushptri32ptr(pTHX_ void *const ptr1, const I32 i, void *const ptr2,
			const int type)
{
    dSS_ADD;
    SS_ADD_PTR(ptr1);
    SS_ADD_INT(i);
    SS_ADD_PTR(ptr2);
    SS_ADD_UV(type);
    SS_ADD_END(4);
}

void
Perl_save_aelem_flags(pTHX_ AV *av, SSize_t idx, SV **sptr,
			    const U32 flags)
{
    dSS_ADD;
    SV *sv;

    PERL_ARGS_ASSERT_SAVE_AELEM_FLAGS;

    SvGETMAGIC(*sptr);
    SS_ADD_PTR(SvREFCNT_inc_simple(av));
    SS_ADD_IV(idx);
    SS_ADD_PTR(SvREFCNT_inc(*sptr));
    SS_ADD_UV(SAVEt_AELEM);
    SS_ADD_END(4);
    /* The array needs to hold a reference count on its new element, so it
       must be AvREAL. */
    if (UNLIKELY(!AvREAL(av) && AvREIFY(av)))
	av_reify(av);
    save_scalar_at(sptr, flags); /* XXX - FIXME - see #60360 */
    if (flags & SAVEf_KEEPOLDELEM)
	return;
    sv = *sptr;
    /* If we're localizing a tied array element, this new sv
     * won't actually be stored in the array - so it won't get
     * reaped when the localize ends. Ensure it gets reaped by
     * mortifying it instead. DAPM */
    if (UNLIKELY(SvTIED_mg((const SV *)av, PERL_MAGIC_tied)))
	sv_2mortal(sv);
}

void
Perl_save_helem_flags(pTHX_ HV *hv, SV *key, SV **sptr, const U32 flags)
{
    SV *sv;

    PERL_ARGS_ASSERT_SAVE_HELEM_FLAGS;

    SvGETMAGIC(*sptr);
    {
        dSS_ADD;
        SS_ADD_PTR(SvREFCNT_inc_simple(hv));
        SS_ADD_PTR(newSVsv(key));
        SS_ADD_PTR(SvREFCNT_inc(*sptr));
        SS_ADD_UV(SAVEt_HELEM);
        SS_ADD_END(4);
    }
    save_scalar_at(sptr, flags);
    if (flags & SAVEf_KEEPOLDELEM)
	return;
    sv = *sptr;
    /* If we're localizing a tied hash element, this new sv
     * won't actually be stored in the hash - so it won't get
     * reaped when the localize ends. Ensure it gets reaped by
     * mortifying it instead. DAPM */
    if (UNLIKELY(SvTIED_mg((const SV *)hv, PERL_MAGIC_tied)))
	sv_2mortal(sv);
}

SV*
Perl_save_svref(pTHX_ SV **sptr)
{
    PERL_ARGS_ASSERT_SAVE_SVREF;

    SvGETMAGIC(*sptr);
    save_pushptrptr(sptr, SvREFCNT_inc(*sptr), SAVEt_SVREF);
    return save_scalar_at(sptr, SAVEf_SETMAGIC); /* XXX - FIXME - see #60360 */
}


void
Perl_savetmps(pTHX)
{
    dSS_ADD;
    SS_ADD_IV(PL_tmps_floor);
    PL_tmps_floor = PL_tmps_ix;
    SS_ADD_UV(SAVEt_TMPSFLOOR);
    SS_ADD_END(2);
}


I32
Perl_save_alloc(pTHX_ I32 size, I32 pad)
{
    const I32 start = pad + ((char*)&PL_savestack[PL_savestack_ix]
                          - (char*)PL_savestack);
    const UV elems = 1 + ((size + pad - 1) / sizeof(*PL_savestack));
    const UV elems_shifted = elems << SAVE_TIGHT_SHIFT;

    if (UNLIKELY((elems_shifted >> SAVE_TIGHT_SHIFT) != elems))
	Perl_croak(aTHX_
            "panic: save_alloc elems %"UVuf" out of range (%"IVdf"-%"IVdf")",
		   elems, (IV)size, (IV)pad);

    SSGROW(elems + 1);

    PL_savestack_ix += elems;
    SSPUSHUV(SAVEt_ALLOC | elems_shifted);
    return start;
}



#define ARG0_SV  MUTABLE_SV(arg0.any_ptr)
#define ARG0_AV  MUTABLE_AV(arg0.any_ptr)
#define ARG0_HV  MUTABLE_HV(arg0.any_ptr)
#define ARG0_PTR arg0.any_ptr
#define ARG0_PV  (char*)(arg0.any_ptr)
#define ARG0_PVP (char**)(arg0.any_ptr)
#define ARG0_I32 (arg0.any_i32)

#define ARG1_SV  MUTABLE_SV(arg1.any_ptr)
#define ARG1_AV  MUTABLE_AV(arg1.any_ptr)
#define ARG1_GV  MUTABLE_GV(arg1.any_ptr)
#define ARG1_SVP (SV**)(arg1.any_ptr)
#define ARG1_PVP (char**)(arg1.any_ptr)
#define ARG1_PTR arg1.any_ptr
#define ARG1_PV  (char*)(arg1.any_ptr)
#define ARG1_I32 (arg1.any_i32)

#define ARG2_SV  MUTABLE_SV(arg2.any_ptr)
#define ARG2_AV  MUTABLE_AV(arg2.any_ptr)
#define ARG2_HV  MUTABLE_HV(arg2.any_ptr)
#define ARG2_GV  MUTABLE_GV(arg2.any_ptr)
#define ARG2_PV  (char*)(arg2.any_ptr)

void
Perl_leave_scope(pTHX_ I32 base)
{
    /* Localise the effects of the TAINT_NOT inside the loop.  */
    bool was = TAINT_get;

    I32 i;
    SV *sv;

    ANY arg0, arg1, arg2;

    /* these initialisations are logically unnecessary, but they shut up
     * spurious 'may be used uninitialized' compiler warnings */
    arg0.any_ptr = NULL;
    arg1.any_ptr = NULL;
    arg2.any_ptr = NULL;

    if (UNLIKELY(base < -1))
	Perl_croak(aTHX_ "panic: corrupt saved stack index %ld", (long) base);
    DEBUG_l(Perl_deb(aTHX_ "savestack: releasing items %ld -> %ld\n",
			(long)PL_savestack_ix, (long)base));
    while (PL_savestack_ix > base) {
	UV uv;
	U8 type;

        SV *refsv;
        SV **svp;

	TAINT_NOT;

        {
            I32 ix = PL_savestack_ix - 1;
            ANY *p = &PL_savestack[ix];
            uv = p->any_uv;
            type = (U8)uv & SAVE_MASK;
            if (type > SAVEt_ARG0_MAX) {
                ANY *p0 = p;
                arg0 = *--p;
                if (type > SAVEt_ARG1_MAX) {
                    arg1 = *--p;
                    if (type > SAVEt_ARG2_MAX) {
                        arg2 = *--p;
                    }
                }
                ix -= (p0 - p);
            }
            PL_savestack_ix = ix;
        }

	switch (type) {
	case SAVEt_ITEM:			/* normal string */
	    sv_replace(ARG1_SV, ARG0_SV);
            if (UNLIKELY(SvSMAGICAL(ARG1_SV))) {
                PL_localizing = 2;
                mg_set(ARG1_SV);
                PL_localizing = 0;
            }
	    break;

	    /* This would be a mathom, but Perl_save_svref() calls a static
	       function, S_save_scalar_at(), so has to stay in this file.  */
	case SAVEt_SVREF:			/* scalar reference */
	    svp = ARG1_SVP;
	    refsv = NULL; /* what to refcnt_dec */
	    goto restore_sv;

	case SAVEt_SV:				/* scalar reference */
	    svp = &GvSV(ARG1_GV);
	    refsv = ARG1_SV; /* what to refcnt_dec */
	restore_sv:
        {
	    SV * const sv = *svp;
	    *svp = ARG0_SV;
	    SvREFCNT_dec(sv);
            if (UNLIKELY(SvSMAGICAL(ARG0_SV))) {
                /* mg_set could die, skipping the freeing of ARG0_SV and
                 * refsv; Ensure that they're always freed in that case */
                dSS_ADD;
                SS_ADD_PTR(ARG0_SV);
                SS_ADD_UV(SAVEt_FREESV);
                SS_ADD_PTR(refsv);
                SS_ADD_UV(SAVEt_FREESV);
                SS_ADD_END(4);
                PL_localizing = 2;
                mg_set(ARG0_SV);
                PL_localizing = 0;
                break;
            }
	    SvREFCNT_dec_NN(ARG0_SV);
	    SvREFCNT_dec(refsv);
	    break;
        }
	case SAVEt_GENERIC_PVREF:		/* generic pv */
	    if (*ARG0_PVP != ARG1_PV) {
		Safefree(*ARG0_PVP);
		*ARG0_PVP = ARG1_PV;
	    }
	    break;
	case SAVEt_SHARED_PVREF:		/* shared pv */
	    if (*ARG1_PVP != ARG0_PV) {
#ifdef NETWARE
		PerlMem_free(*ARG1_PVP);
#else
		PerlMemShared_free(*ARG1_PVP);
#endif
		*ARG1_PVP = ARG0_PV;
	    }
	    break;
	case SAVEt_GVSV:			/* scalar slot in GV */
	    svp = &GvSV(ARG1_GV);
	    goto restore_svp;
	case SAVEt_GENERIC_SVREF:		/* generic sv */
            svp = ARG1_SVP;
	restore_svp:
        {
	    SV * const sv = *svp;
	    *svp = ARG0_SV;
	    SvREFCNT_dec(sv);
	    SvREFCNT_dec(ARG0_SV);
	    break;
        }
	case SAVEt_GVSLOT:			/* any slot in GV */
        {
            HV *const hv = GvSTASH(ARG2_GV);
	    svp = ARG1_SVP;
	    if (hv && HvENAME(hv) && (
		    (ARG0_SV && SvTYPE(ARG0_SV) == SVt_PVCV)
		 || (*svp && SvTYPE(*svp) == SVt_PVCV)
	       ))
	    {
		if ((char *)svp < (char *)GvGP(ARG2_GV)
		 || (char *)svp > (char *)GvGP(ARG2_GV) + sizeof(struct gp)
		 || GvREFCNT(ARG2_GV) > 2) /* "> 2" to ignore savestack's ref */
		    PL_sub_generation++;
		else mro_method_changed_in(hv);
	    }
	    goto restore_svp;
        }
	case SAVEt_AV:				/* array reference */
	    SvREFCNT_dec(GvAV(ARG1_GV));
	    GvAV(ARG1_GV) = ARG0_AV;
          avhv_common:
            if (UNLIKELY(SvSMAGICAL(ARG0_SV))) {
                /* mg_set might die, so make sure ARG1 isn't leaked */
                dSS_ADD;
                SS_ADD_PTR(ARG1_SV);
                SS_ADD_UV(SAVEt_FREESV);
                SS_ADD_END(2);
                PL_localizing = 2;
                mg_set(ARG0_SV);
                PL_localizing = 0;
                break;
            }
	    SvREFCNT_dec_NN(ARG1_GV);
	    break;
	case SAVEt_HV:				/* hash reference */
	    SvREFCNT_dec(GvHV(ARG1_GV));
	    GvHV(ARG1_GV) = ARG0_HV;
            goto avhv_common;

	case SAVEt_INT_SMALL:
	    *(int*)ARG0_PTR = (int)(uv >> SAVE_TIGHT_SHIFT);
	    break;
	case SAVEt_INT:				/* int reference */
	    *(int*)ARG0_PTR = (int)ARG1_I32;
	    break;
	case SAVEt_STRLEN:			/* STRLEN/size_t ref */
	    *(STRLEN*)ARG0_PTR = (STRLEN)arg1.any_iv;
	    break;
	case SAVEt_TMPSFLOOR:			/* restore PL_tmps_floor */
	    PL_tmps_floor = (SSize_t)arg0.any_iv;
	    break;
	case SAVEt_BOOL:			/* bool reference */
	    *(bool*)ARG0_PTR = cBOOL(uv >> 8);
#ifdef NO_TAINT_SUPPORT
            PERL_UNUSED_VAR(was);
#else
	    if (UNLIKELY(ARG0_PTR == &(TAINT_get))) {
		/* If we don't update <was>, to reflect what was saved on the
		 * stack for PL_tainted, then we will overwrite this attempt to
		 * restore it when we exit this routine.  Note that this won't
		 * work if this value was saved in a wider-than necessary type,
		 * such as I32 */
		was = *(bool*)ARG0_PTR;
	    }
#endif
	    break;
	case SAVEt_I32_SMALL:
	    *(I32*)ARG0_PTR = (I32)(uv >> SAVE_TIGHT_SHIFT);
	    break;
	case SAVEt_I32:				/* I32 reference */
#ifdef PERL_DEBUG_READONLY_OPS
            if (*(I32*)ARG0_PTR != ARG1_I32)
#endif
                *(I32*)ARG0_PTR = ARG1_I32;
	    break;
	case SAVEt_SPTR:			/* SV* reference */
	    *(SV**)(ARG0_PTR)= ARG1_SV;
	    break;
	case SAVEt_VPTR:			/* random* reference */
	case SAVEt_PPTR:			/* char* reference */
	    *ARG0_PVP = ARG1_PV;
	    break;
	case SAVEt_HPTR:			/* HV* reference */
	    *(HV**)ARG0_PTR = MUTABLE_HV(ARG1_PTR);
	    break;
	case SAVEt_APTR:			/* AV* reference */
	    *(AV**)ARG0_PTR = ARG1_AV;
	    break;
	case SAVEt_GP:				/* scalar reference */
        {
            HV *hv;
            /* possibly taking a method out of circulation */	
	    const bool had_method = !!GvCVu(ARG1_GV);
	    gp_free(ARG1_GV);
	    GvGP_set(ARG1_GV, (GP*)ARG0_PTR);
	    if ((hv=GvSTASH(ARG1_GV)) && HvENAME_get(hv)) {
	        if (   GvNAMELEN(ARG1_GV) == 3
                    && strnEQ(GvNAME(ARG1_GV), "ISA", 3)
                )
	            mro_isa_changed_in(hv);
                else if (had_method || GvCVu(ARG1_GV))
                    /* putting a method back into circulation ("local")*/	
                    gv_method_changed(ARG1_GV);
	    }
	    SvREFCNT_dec_NN(ARG1_GV);
	    break;
        }
	case SAVEt_FREESV:
	    SvREFCNT_dec(ARG0_SV);
	    break;
	case SAVEt_FREEPADNAME:
	    PadnameREFCNT_dec((PADNAME *)ARG0_PTR);
	    break;
	case SAVEt_FREECOPHH:
	    cophh_free((COPHH *)ARG0_PTR);
	    break;
	case SAVEt_MORTALIZESV:
	    sv_2mortal(ARG0_SV);
	    break;
	case SAVEt_FREEOP:
	    ASSERT_CURPAD_LEGAL("SAVEt_FREEOP");
	    op_free((OP*)ARG0_PTR);
	    break;
	case SAVEt_FREEPV:
	    Safefree(ARG0_PTR);
	    break;

        case SAVEt_CLEARPADRANGE:
            i = (I32)((uv >> SAVE_TIGHT_SHIFT) & OPpPADRANGE_COUNTMASK);
	    svp = &PL_curpad[uv >>
                    (OPpPADRANGE_COUNTSHIFT + SAVE_TIGHT_SHIFT)] + i - 1;
            goto clearsv;
	case SAVEt_CLEARSV:
	    svp = &PL_curpad[uv >> SAVE_TIGHT_SHIFT];
            i = 1;
          clearsv:
            for (; i; i--, svp--) {
                sv = *svp;

                DEBUG_Xv(PerlIO_printf(Perl_debug_log,
             "Pad 0x%"UVxf"[0x%"UVxf"] clearsv: %ld sv=0x%"UVxf"<%"IVdf"> %s\n",
                    PTR2UV(PL_comppad), PTR2UV(PL_curpad),
                    (long)(svp-PL_curpad), PTR2UV(sv), (IV)SvREFCNT(sv),
                    (SvREFCNT(sv) <= 1 && !SvOBJECT(sv)) ? "clear" : "abandon"
                ));

                /* Can clear pad variable in place? */
                if (SvREFCNT(sv) == 1 && !SvOBJECT(sv)) {

                    /* these flags are the union of all the relevant flags
                     * in the individual conditions within */
                    if (UNLIKELY(SvFLAGS(sv) & (
                            SVf_READONLY|SVf_PROTECT /*for SvREADONLY_off*/
                          | (SVs_GMG|SVs_SMG|SVs_RMG) /* SvMAGICAL() */
                          | SVf_OOK
                          | SVf_THINKFIRST)))
                    {
                        /* if a my variable that was made readonly is
                         * going out of scope, we want to remove the
                         * readonlyness so that it can go out of scope
                         * quietly
                         */
                        if (SvREADONLY(sv))
                            SvREADONLY_off(sv);

                        if (SvOOK(sv)) { /* OOK or HvAUX */
                            if (SvTYPE(sv) == SVt_PVHV)
                                Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
                            else
                                sv_backoff(sv);
                        }

                        if (SvMAGICAL(sv)) {
                            /* note that backrefs (either in HvAUX or magic)
                             * must be removed before other magic */
                            sv_unmagic(sv, PERL_MAGIC_backref);
                            if (SvTYPE(sv) != SVt_PVCV)
                                mg_free(sv);
                        }
                        if (SvTHINKFIRST(sv))
                            sv_force_normal_flags(sv, SV_IMMEDIATE_UNREF
                                                     |SV_COW_DROP_PV);

                    }
                    switch (SvTYPE(sv)) {
                    case SVt_NULL:
                        break;
                    case SVt_PVAV:
                        av_clear(MUTABLE_AV(sv));
                        break;
                    case SVt_PVHV:
                        hv_clear(MUTABLE_HV(sv));
                        break;
                    case SVt_PVCV:
                    {
                        HEK *hek =
			      CvNAMED(sv)
				? CvNAME_HEK((CV *)sv)
				: GvNAME_HEK(CvGV(sv));
                        assert(hek);
                        (void)share_hek_hek(hek);
                        cv_undef((CV *)sv);
                        CvNAME_HEK_set(sv, hek);
                        CvLEXICAL_on(sv);
                        break;
                    }
                    default:
                        /* This looks odd, but these two macros are for use in
                           expressions and finish with a trailing comma, so
                           adding a ; after them would be wrong. */
                        assert_not_ROK(sv)
                        assert_not_glob(sv)
                        SvFLAGS(sv) &=~ (SVf_OK|SVf_IVisUV|SVf_UTF8);
                        break;
                    }
                    SvPADTMP_off(sv);
                    SvPADSTALE_on(sv); /* mark as no longer live */
                }
                else {	/* Someone has a claim on this, so abandon it. */
                    switch (SvTYPE(sv)) {	/* Console ourselves with a new value */
                    case SVt_PVAV:	*svp = MUTABLE_SV(newAV());	break;
                    case SVt_PVHV:	*svp = MUTABLE_SV(newHV());	break;
                    case SVt_PVCV:
                    {
                        HEK * const hek = CvNAMED(sv)
                                             ? CvNAME_HEK((CV *)sv)
                                             : GvNAME_HEK(CvGV(sv));

                        /* Create a stub */
                        *svp = newSV_type(SVt_PVCV);

                        /* Share name */
                        CvNAME_HEK_set(*svp,
                                       share_hek_hek(hek));
                        CvLEXICAL_on(*svp);
                        break;
                    }
                    default:	*svp = newSV(0);		break;
                    }
                    SvREFCNT_dec_NN(sv); /* Cast current value to the winds. */
                    /* preserve pad nature, but also mark as not live
                     * for any closure capturing */
                    SvFLAGS(*svp) |= SVs_PADSTALE;
                }
            }
	    break;
	case SAVEt_DELETE:
	    (void)hv_delete(ARG0_HV, ARG2_PV, ARG1_I32, G_DISCARD);
	    SvREFCNT_dec(ARG0_HV);
	    Safefree(arg2.any_ptr);
	    break;
	case SAVEt_ADELETE:
	    (void)av_delete(ARG0_AV, arg1.any_iv, G_DISCARD);
	    SvREFCNT_dec(ARG0_AV);
	    break;
	case SAVEt_DESTRUCTOR_X:
	    (*arg1.any_dxptr)(aTHX_ ARG0_PTR);
	    break;
	case SAVEt_REGCONTEXT:
	    /* regexp must have croaked */
	case SAVEt_ALLOC:
	    PL_savestack_ix -= uv >> SAVE_TIGHT_SHIFT;
	    break;
	case SAVEt_STACK_POS:		/* Position on Perl stack */
	    PL_stack_sp = PL_stack_base + arg0.any_i32;
	    break;
	case SAVEt_AELEM:		/* array element */
	    svp = av_fetch(ARG2_AV, arg1.any_iv, 1);
	    if (UNLIKELY(!AvREAL(ARG2_AV) && AvREIFY(ARG2_AV))) /* undo reify guard */
		SvREFCNT_dec(ARG0_SV);
	    if (LIKELY(svp)) {
		SV * const sv = *svp;
		if (LIKELY(sv && sv != &PL_sv_undef)) {
		    if (UNLIKELY(SvTIED_mg((const SV *)ARG2_AV, PERL_MAGIC_tied)))
			SvREFCNT_inc_void_NN(sv);
                    refsv = ARG2_SV;
		    goto restore_sv;
		}
	    }
	    SvREFCNT_dec(ARG2_AV);
	    SvREFCNT_dec(ARG0_SV);
	    break;
	case SAVEt_HELEM:		/* hash element */
        {
	    HE * const he = hv_fetch_ent(ARG2_HV, ARG1_SV, 1, 0);
	    SvREFCNT_dec(ARG1_SV);
	    if (LIKELY(he)) {
		const SV * const oval = HeVAL(he);
		if (LIKELY(oval && oval != &PL_sv_undef)) {
		    svp = &HeVAL(he);
		    if (UNLIKELY(SvTIED_mg((const SV *)ARG2_HV, PERL_MAGIC_tied)))
			SvREFCNT_inc_void(*svp);
		    refsv = ARG2_SV; /* what to refcnt_dec */
		    goto restore_sv;
		}
	    }
	    SvREFCNT_dec(ARG2_HV);
	    SvREFCNT_dec(ARG0_SV);
	    break;
        }
	case SAVEt_OP:
	    PL_op = (OP*)ARG0_PTR;
	    break;
	case SAVEt_HINTS:
	    if ((PL_hints & HINT_LOCALIZE_HH)) {
	      while (GvHV(PL_hintgv)) {
		HV *hv = GvHV(PL_hintgv);
		GvHV(PL_hintgv) = NULL;
		SvREFCNT_dec(MUTABLE_SV(hv));
	      }
	    }
	    cophh_free(CopHINTHASH_get(&PL_compiling));
	    CopHINTHASH_set(&PL_compiling, (COPHH*)ARG0_PTR);
	    *(I32*)&PL_hints = ARG1_I32;
	    if (PL_hints & HINT_LOCALIZE_HH) {
		SvREFCNT_dec(MUTABLE_SV(GvHV(PL_hintgv)));
		GvHV(PL_hintgv) = MUTABLE_HV(SSPOPPTR);
	    }
	    if (!GvHV(PL_hintgv)) {
		/* Need to add a new one manually, else rv2hv can
		   add one via GvHVn and it won't have the magic set.  */
		HV *const hv = newHV();
		hv_magic(hv, NULL, PERL_MAGIC_hints);
		GvHV(PL_hintgv) = hv;
	    }
	    assert(GvHV(PL_hintgv));
	    break;
	case SAVEt_COMPPAD:
	    PL_comppad = (PAD*)ARG0_PTR;
	    if (LIKELY(PL_comppad))
		PL_curpad = AvARRAY(PL_comppad);
	    else
		PL_curpad = NULL;
	    break;
	case SAVEt_PADSV_AND_MORTALIZE:
	    {
		SV **svp;
		assert (ARG1_PTR);
		svp = AvARRAY((PAD*)ARG1_PTR) + (PADOFFSET)arg0.any_uv;
                /* This mortalizing used to be done by CX_POOPLOOP() via
                   itersave.  But as we have all the information here, we
                   can do it here, save even having to have itersave in
                   the struct.
                   */
		sv_2mortal(*svp);
		*svp = ARG2_SV;
	    }
	    break;
	case SAVEt_SAVESWITCHSTACK:
	    {
		dSP;
		SWITCHSTACK(ARG0_AV, ARG1_AV);
		PL_curstackinfo->si_stack = ARG1_AV;
	    }
	    break;
	case SAVEt_SET_SVFLAGS:
            SvFLAGS(ARG2_SV) &= ~((U32)ARG1_I32);
            SvFLAGS(ARG2_SV) |= (U32)ARG0_I32;
	    break;

	    /* These are only saved in mathoms.c */
	case SAVEt_NSTAB:
	    (void)sv_clear(ARG0_SV);
	    break;
	case SAVEt_LONG:			/* long reference */
	    *(long*)ARG0_PTR = arg1.any_long;
	    break;
	case SAVEt_IV:				/* IV reference */
	    *(IV*)ARG0_PTR = arg1.any_iv;
	    break;

	case SAVEt_I16:				/* I16 reference */
	    *(I16*)ARG0_PTR = (I16)(uv >> 8);
	    break;
	case SAVEt_I8:				/* I8 reference */
	    *(I8*)ARG0_PTR = (I8)(uv >> 8);
	    break;
	case SAVEt_DESTRUCTOR:
	    (*arg1.any_dptr)(ARG0_PTR);
	    break;
	case SAVEt_COMPILE_WARNINGS:
	    if (!specialWARN(PL_compiling.cop_warnings))
		PerlMemShared_free(PL_compiling.cop_warnings);

	    PL_compiling.cop_warnings = (STRLEN*)ARG0_PTR;
	    break;
	case SAVEt_PARSER:
	    parser_free((yy_parser *) ARG0_PTR);
	    break;
	case SAVEt_READONLY_OFF:
	    SvREADONLY_off(ARG0_SV);
	    break;
	default:
	    Perl_croak(aTHX_ "panic: leave_scope inconsistency %u", type);
	}
    }

    TAINT_set(was);
}

void
Perl_cx_dump(pTHX_ PERL_CONTEXT *cx)
{
    PERL_ARGS_ASSERT_CX_DUMP;

#ifdef DEBUGGING
    PerlIO_printf(Perl_debug_log, "CX %ld = %s\n", (long)(cx - cxstack), PL_block_type[CxTYPE(cx)]);
    if (CxTYPE(cx) != CXt_SUBST) {
	const char *gimme_text;
	PerlIO_printf(Perl_debug_log, "BLK_OLDSP = %ld\n", (long)cx->blk_oldsp);
	PerlIO_printf(Perl_debug_log, "BLK_OLDCOP = 0x%"UVxf"\n",
		      PTR2UV(cx->blk_oldcop));
	PerlIO_printf(Perl_debug_log, "BLK_OLDMARKSP = %ld\n", (long)cx->blk_oldmarksp);
	PerlIO_printf(Perl_debug_log, "BLK_OLDSCOPESP = %ld\n", (long)cx->blk_oldscopesp);
	PerlIO_printf(Perl_debug_log, "BLK_OLDSAVEIX = %ld\n", (long)cx->blk_oldsaveix);
	PerlIO_printf(Perl_debug_log, "BLK_OLDPM = 0x%"UVxf"\n",
		      PTR2UV(cx->blk_oldpm));
	switch (cx->blk_gimme) {
	    case G_VOID:
		gimme_text = "VOID";
		break;
	    case G_SCALAR:
		gimme_text = "SCALAR";
		break;
	    case G_ARRAY:
		gimme_text = "LIST";
		break;
	    default:
		gimme_text = "UNKNOWN";
		break;
	}
	PerlIO_printf(Perl_debug_log, "BLK_GIMME = %s\n", gimme_text);
    }
    switch (CxTYPE(cx)) {
    case CXt_NULL:
    case CXt_BLOCK:
	break;
    case CXt_FORMAT:
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.CV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_format.cv));
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.GV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_format.gv));
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.DFOUTGV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_format.dfoutgv));
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.HASARGS = %d\n",
		      (int)CxHASARGS(cx));
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.RETOP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_format.retop));
	break;
    case CXt_SUB:
	PerlIO_printf(Perl_debug_log, "BLK_SUB.CV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.cv));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.OLDDEPTH = %ld\n",
		(long)cx->blk_sub.olddepth);
	PerlIO_printf(Perl_debug_log, "BLK_SUB.HASARGS = %d\n",
		(int)CxHASARGS(cx));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.LVAL = %d\n", (int)CxLVAL(cx));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.RETOP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.retop));
	break;
    case CXt_EVAL:
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_IN_EVAL = %ld\n",
		(long)CxOLD_IN_EVAL(cx));
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_OP_TYPE = %s (%s)\n",
		PL_op_name[CxOLD_OP_TYPE(cx)],
		PL_op_desc[CxOLD_OP_TYPE(cx)]);
	if (cx->blk_eval.old_namesv)
	    PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_NAME = %s\n",
			  SvPVX_const(cx->blk_eval.old_namesv));
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_EVAL_ROOT = 0x%"UVxf"\n",
		PTR2UV(cx->blk_eval.old_eval_root));
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.RETOP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_eval.retop));
	break;

    case CXt_LOOP_PLAIN:
    case CXt_LOOP_LAZYIV:
    case CXt_LOOP_LAZYSV:
    case CXt_LOOP_LIST:
    case CXt_LOOP_ARY:
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.LABEL = %s\n", CxLABEL(cx));
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.MY_OP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.my_op));
        if (CxTYPE(cx) != CXt_LOOP_PLAIN) {
            PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERVAR = 0x%"UVxf"\n",
                    PTR2UV(CxITERVAR(cx)));
            PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERSAVE = 0x%"UVxf"\n",
                    PTR2UV(cx->blk_loop.itersave));
            /* XXX: not accurate for LAZYSV/IV/LIST */
            PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERARY = 0x%"UVxf"\n",
                    PTR2UV(cx->blk_loop.state_u.ary.ary));
            PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERIX = %ld\n",
                    (long)cx->blk_loop.state_u.ary.ix);
        }
	break;

    case CXt_SUBST:
	PerlIO_printf(Perl_debug_log, "SB_ITERS = %ld\n",
		(long)cx->sb_iters);
	PerlIO_printf(Perl_debug_log, "SB_MAXITERS = %ld\n",
		(long)cx->sb_maxiters);
	PerlIO_printf(Perl_debug_log, "SB_RFLAGS = %ld\n",
		(long)cx->sb_rflags);
	PerlIO_printf(Perl_debug_log, "SB_ONCE = %ld\n",
		(long)CxONCE(cx));
	PerlIO_printf(Perl_debug_log, "SB_ORIG = %s\n",
		cx->sb_orig);
	PerlIO_printf(Perl_debug_log, "SB_DSTR = 0x%"UVxf"\n",
		PTR2UV(cx->sb_dstr));
	PerlIO_printf(Perl_debug_log, "SB_TARG = 0x%"UVxf"\n",
		PTR2UV(cx->sb_targ));
	PerlIO_printf(Perl_debug_log, "SB_S = 0x%"UVxf"\n",
		PTR2UV(cx->sb_s));
	PerlIO_printf(Perl_debug_log, "SB_M = 0x%"UVxf"\n",
		PTR2UV(cx->sb_m));
	PerlIO_printf(Perl_debug_log, "SB_STREND = 0x%"UVxf"\n",
		PTR2UV(cx->sb_strend));
	PerlIO_printf(Perl_debug_log, "SB_RXRES = 0x%"UVxf"\n",
		PTR2UV(cx->sb_rxres));
	break;
    }
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(cx);
#endif	/* DEBUGGING */
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d32 2
a33 1
    dVAR;
d37 4
d42 3
a44 2
#ifndef STRESS_REALLOC
    av_extend(PL_curstack, (p - PL_stack_base) + (n) + 128);
d46 1
a46 1
    av_extend(PL_curstack, (p - PL_stack_base) + (n) + 1);
d48 10
a69 1
    dVAR;
d83 1
a83 1
    /* Without any kind of initialising PUSHSUBST()
a91 1
    dVAR;
a103 1
    dVAR;
a120 1
    dVAR;
d125 1
a125 1
void
a127 1
    dVAR;
d132 1
d134 4
a137 1
    PL_markstack_max = PL_markstack + newmax;
d143 4
a146 3
    dVAR;
    PL_savestack_max = GROW(PL_savestack_max) + 4;
    Renew(PL_savestack, PL_savestack_max, ANY);
a151 1
    dVAR;
d153 3
a155 1
    Renew(PL_savestack, PL_savestack_max, ANY);
d160 19
a178 2
void
Perl_tmps_grow(pTHX_ SSize_t n)
d180 1
a180 1
    dVAR;
d182 2
a183 2
    if (n < 128)
	n = (PL_tmps_max < 512) ? 128 : 512;
d185 1
a185 1
    PL_tmps_max = PL_tmps_ix + n + 1;
d187 1
a193 1
    dVAR;
d201 1
a201 1
	if (LIKELY(sv && sv != &PL_sv_undef)) {
a210 1
    dVAR;
d217 6
a222 9
    sv  = (flags & SAVEf_KEEPOLDELEM) ? osv : (*sptr = newSV(0));

    if (SvTYPE(osv) >= SVt_PVMG && SvMAGIC(osv)) {
	if (SvGMAGICAL(osv)) {
	    SvFLAGS(osv) |= (SvFLAGS(osv) &
	       (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
	}
	if (!(flags & SAVEf_KEEPOLDELEM))
	    mg_localize(osv, sv, cBOOL(flags & SAVEf_SETMAGIC));
a230 1
    dVAR;
a240 1
    dVAR;
a258 2
    dVAR;

a269 2
    dVAR;

a280 2
    dVAR;

a290 1
    dVAR;
d302 13
a317 2
    dVAR;

a349 1
    dVAR;
a368 1
    dVAR;
a386 1
    dVAR;
a398 1
    dVAR;
a410 1
    dVAR;
a421 1
    dVAR;
a441 1
    dVAR;
a453 1
    dVAR;
a465 1
    dVAR;
a485 1
    dVAR;
a501 2
    dVAR;

a509 2
    dVAR;

a517 2
    dVAR;

a525 1
    dVAR;
a538 2
    dVAR;

a546 2
    dVAR;

a554 1
    dVAR;
a563 1
    dVAR;
a585 2
    dVAR;

a608 1
    dVAR;
a622 1
    dVAR;
a623 1

a634 1
    dVAR;
a645 1
    dVAR;
d673 1
a673 1
    dVAR; dSS_ADD;
a702 1
    dVAR;
a730 2
    dVAR;

d738 12
a752 1
    dVAR;
a797 2
    dVAR;

d801 3
d870 8
d881 1
d927 1
a927 1
		 || GvREFCNT(ARG2_GV) > 1)
d936 1
d938 5
d946 1
d953 2
a954 7
            if (UNLIKELY(SvSMAGICAL(ARG0_SV))) {
                PL_localizing = 2;
                mg_set(ARG0_SV);
                PL_localizing = 0;
            }
	    SvREFCNT_dec_NN(ARG1_GV);
	    break;
d964 3
d1026 3
a1042 5
        {
          SV **svp;
          I32 i;
          SV *sv;

a1061 2
                assert(SvPADMY(sv));

d1068 1
a1068 1
                            SVf_READONLY /* for SvREADONLY_off() */
d1078 1
a1078 1
                        if (SvREADONLY(sv) && !SvFAKE(sv))
d1111 4
a1114 1
                        HEK * const hek = CvNAME_HEK((CV *)sv);
d1116 1
a1116 1
                        share_hek_hek(hek);
d1119 1
d1131 1
a1134 2
                    assert(  SvFLAGS(sv) & SVs_PADMY);
                    assert(!(SvFLAGS(sv) & SVs_PADTMP));
d1140 4
a1147 1
                        assert(CvNAMED(sv));
d1149 2
a1150 1
                            share_hek_hek(CvNAME_HEK((CV *)sv)));
d1158 1
a1158 1
                    SvFLAGS(*svp) |= (SVs_PADMY|SVs_PADSTALE);
a1161 1
        }
d1255 5
a1259 3
		/* This mortalizing used to be done by POPLOOP() via itersave.
		   But as we have all the information here, we can do it here,
		   save even having to have itersave in the struct.  */
a1318 2
    dVAR;

d1330 1
d1391 1
d1394 2
a1395 2
    case CXt_LOOP_FOR:
    case CXt_LOOP_PLAIN:
a1396 2
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.RESETSP = %ld\n",
		(long)cx->blk_loop.resetsp);
d1399 11
a1409 7
	/* XXX: not accurate for LAZYSV/IV */
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERARY = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.state_u.ary.ary));
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERIX = %ld\n",
		(long)cx->blk_loop.state_u.ary.ix);
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERVAR = 0x%"UVxf"\n",
		PTR2UV(CxITERVAR(cx)));
a1443 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d30 1
a30 1
Perl_stack_grow(pTHX_ SV **sp, SV **p, int n)
d91 1
a91 1
    if (PL_scopestack_ix == PL_scopestack_max) {
d144 1
a144 1
Perl_tmps_grow(pTHX_ I32 n)
d161 1
a161 1
    const I32 myfloor = PL_tmps_floor;
d167 1
a167 1
	if (sv && sv != &PL_sv_undef) {
d217 1
a217 1
    if (SvGMAGICAL(*sptr)) {
d324 1
a324 1
    if (!AvREAL(oav) && AvREIFY(oav))
d330 1
a330 1
    if (SvMAGIC(oav))
d349 1
a349 1
    if (SvMAGIC(ohv))
d403 1
a403 1
    if ((int)(type >> SAVE_TIGHT_SHIFT) != i) {
d450 1
a450 1
    if ((I32)(type >> SAVE_TIGHT_SHIFT) != i) {
d460 14
d562 1
a562 1
    if ((offset_shifted >> SAVE_TIGHT_SHIFT) != offset) {
d600 1
a600 1
Perl_save_adelete(pTHX_ AV *av, I32 key)
d603 1
d608 4
a611 1
    save_pushi32ptr(key, av, SAVEt_ADELETE);
d668 2
a669 1
Perl_save_aelem_flags(pTHX_ AV *av, I32 idx, SV **sptr, const U32 flags)
d671 1
a671 1
    dVAR;
d677 5
a681 2
    save_pushptri32ptr(SvREFCNT_inc_simple(av), idx, SvREFCNT_inc(*sptr),
		       SAVEt_AELEM);
d684 1
a684 1
    if (!AvREAL(av) && AvREIFY(av))
d694 1
a694 1
    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied))
d723 1
a723 1
    if (SvTIED_mg((const SV *)hv, PERL_MAGIC_tied))
d748 1
a748 1
    if ((elems_shifted >> SAVE_TIGHT_SHIFT) != elems)
d801 1
a801 1
    if (base < -1)
d836 1
a836 1
            if (SvSMAGICAL(ARG1_SV)) {
d858 1
a858 1
            if (SvSMAGICAL(ARG0_SV)) {
d916 1
a916 1
            if (SvSMAGICAL(ARG0_SV)) {
d926 1
a926 1
            if (SvSMAGICAL(ARG0_SV)) {
d939 3
d947 1
a947 1
	    if (ARG0_PTR == &(TAINT_get)) {
d1039 2
d1042 9
a1050 15
                if (SvREFCNT(sv) <= 1 && !SvOBJECT(sv)) {
                    /*
                     * if a my variable that was made readonly is going out of
                     * scope, we want to remove the readonlyness so that it can
                     * go out of scope quietly
                     */
                    if (SvPADMY(sv) && !SvFAKE(sv))
                        SvREADONLY_off(sv);

                    if (SvTHINKFIRST(sv))
                        sv_force_normal_flags(sv, SV_IMMEDIATE_UNREF
                                                 |SV_COW_DROP_PV);
                    if (SvTYPE(sv) == SVt_PVHV)
                        Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
                    if (SvMAGICAL(sv))
d1052 26
a1077 3
                      sv_unmagic(sv, PERL_MAGIC_backref);
                      if (SvTYPE(sv) != SVt_PVCV)
                        mg_free(sv);
a1078 1

d1098 6
a1103 1
                        SvOK_off(sv);
d1141 1
a1141 1
	    (void)av_delete(ARG0_AV, ARG1_I32, G_DISCARD);
a1154 3
	case SAVEt_STACK_CXPOS:         /* blk_oldsp on context stack */
	    cxstack[ARG0_I32].blk_oldsp = ARG1_I32;
	    break;
d1156 2
a1157 2
	    svp = av_fetch(ARG2_AV, ARG1_I32, 1);
	    if (!AvREAL(ARG2_AV) && AvREIFY(ARG2_AV)) /* undo reify guard */
d1159 1
a1159 1
	    if (svp) {
d1161 2
a1162 2
		if (sv && sv != &PL_sv_undef) {
		    if (SvTIED_mg((const SV *)ARG2_AV, PERL_MAGIC_tied))
d1175 1
a1175 1
	    if (he) {
d1177 1
a1177 1
		if (oval && oval != &PL_sv_undef) {
d1179 1
a1179 1
		    if (SvTIED_mg((const SV *)ARG2_HV, PERL_MAGIC_tied))
d1218 1
a1218 1
	    if (PL_comppad)
a1272 14
	case SAVEt_RE_STATE:
	    {
		const struct re_save_state *const state
		    = (struct re_save_state *)
		    (PL_savestack + PL_savestack_ix
		     - SAVESTACK_ALLOC_FOR_RE_SAVE_STATE);
		PL_savestack_ix -= SAVESTACK_ALLOC_FOR_RE_SAVE_STATE;

		if (PL_reg_poscache != state->re_state_reg_poscache) {
		    Safefree(PL_reg_poscache);
		}
		Copy(state, &PL_reg_state, 1, struct re_save_state);
	    }
	    break;
d1275 3
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d163 4
a166 2
	SV* const sv = PL_tmps_stack[PL_tmps_ix];
	PL_tmps_stack[PL_tmps_ix--] = NULL;
d169 1
a169 1
	    SvREFCNT_dec(sv);		/* note, can modify tmps_ix!!! */
d179 1
a179 1
    register SV *sv;
d202 5
a206 4
    SSCHECK(3);
    SSPUSHPTR(ptr1);
    SSPUSHPTR(ptr2);
    SSPUSHUV(type);
d217 5
a221 3
    PL_localizing = 1;
    SvGETMAGIC(*sptr);
    PL_localizing = 0;
d270 1
d274 5
a278 5
    SSCHECK(4);
    SSPUSHPTR(sv);
    SSPUSHINT(mask);
    SSPUSHINT(val);
    SSPUSHUV(SAVEt_SET_SVFLAGS);
d292 2
d295 7
a301 2
	if (GvCVu(gv))
            mro_method_changed_in(GvSTASH(gv)); /* taking a method out of circulation ("local")*/
a305 8
#ifdef PERL_DONT_CREATE_GVSV
	if (gv == PL_errgv) {
	    /* We could scatter this logic everywhere by changing the
	       definition of ERRSV from GvSV() to GvSVn(), but it seems more
	       efficient to do this check once here.  */
	    gp->gp_sv = newSV(0);
	}
#endif
d307 1
d355 1
a355 1
Perl_save_item(pTHX_ register SV *item)
d358 1
a358 1
    register SV * const sv = newSVsv(item);
d371 1
d375 3
a377 3
    SSCHECK(2);
    SSPUSHPTR(boolp);
    SSPUSHUV(SAVEt_BOOL | (*boolp << 8));
d384 6
a389 4
    SSCHECK(3);
    SSPUSHINT(i);
    SSPUSHPTR(ptr);
    SSPUSHUV(type);
d396 4
a399 1
    const UV shifted = (UV)*intp << SAVE_TIGHT_SHIFT;
d403 8
a410 6
    if ((int)(shifted >> SAVE_TIGHT_SHIFT) == *intp) {
	SSCHECK(2);
	SSPUSHPTR(intp);
	SSPUSHUV(SAVEt_INT_SMALL | shifted);
    } else
	save_pushi32ptr(*intp, intp, SAVEt_INT);
d417 1
d421 3
a423 3
    SSCHECK(2);
    SSPUSHPTR(bytep);
    SSPUSHUV(SAVEt_I8 | ((UV)*bytep << 8));
d430 1
d434 3
a436 3
    SSCHECK(2);
    SSPUSHPTR(intp);
    SSPUSHUV(SAVEt_I16 | ((UV)*intp << 8));
d443 4
a446 1
    const UV shifted = (UV)*intp << SAVE_TIGHT_SHIFT;
d450 8
a457 6
    if ((I32)(shifted >> SAVE_TIGHT_SHIFT) == *intp) {
	SSCHECK(2);
	SSPUSHPTR(intp);
	SSPUSHUV(SAVEt_I32_SMALL | shifted);
    } else
	save_pushi32ptr(*intp, intp, SAVEt_I32);
d497 2
a498 1
    SSCHECK(4);
d500 5
a504 4
    SSPUSHPTR(SvREFCNT_inc_simple_NN(PL_curpad[off]));
    SSPUSHPTR(PL_comppad);
    SSPUSHLONG((long)off);
    SSPUSHUV(SAVEt_PADSV_AND_MORTALIZE);
d531 4
a534 3
    SSCHECK(2);
    SSPUSHPTR(ptr);
    SSPUSHUV(type);
d547 2
a548 1
    if ((offset_shifted >> SAVE_TIGHT_SHIFT) != offset)
d551 1
d553 5
a557 3
    SSCHECK(1);
    SSPUSHUV(offset_shifted | SAVEt_CLEARSV);
    SvPADSTALE_off(*svp); /* mark lexical as active */
d600 1
d604 4
a607 4
    SSCHECK(3);
    SSPUSHDPTR(f);
    SSPUSHPTR(p);
    SSPUSHUV(SAVEt_DESTRUCTOR);
d614 6
a619 4
    SSCHECK(3);
    SSPUSHDXPTR(f);
    SSPUSHPTR(p);
    SSPUSHUV(SAVEt_DESTRUCTOR_X);
d641 6
a646 5
    SSCHECK(4);
    SSPUSHPTR(ptr1);
    SSPUSHINT(i);
    SSPUSHPTR(ptr2);
    SSPUSHUV(type);
d660 2
a661 1
    /* if it gets reified later, the restore will have the wrong refcnt */
d663 1
a663 1
	SvREFCNT_inc_void(*sptr);
d685 8
a692 5
    SSCHECK(4);
    SSPUSHPTR(SvREFCNT_inc_simple(hv));
    SSPUSHPTR(newSVsv(key));
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHUV(SAVEt_HELEM);
d721 2
a722 2
    register const I32 start = pad + ((char*)&PL_savestack[PL_savestack_ix]
				- (char*)PL_savestack);
d727 3
a729 2
	Perl_croak(aTHX_ "panic: save_alloc elems %"UVuf" out of range (%ld-%ld)",
		   elems, size, pad);
d738 25
d767 1
a767 8
    register SV *sv;
    register SV *value;
    register GV *gv;
    register AV *av;
    register HV *hv;
    void* ptr;
    register char* str;
    I32 i;
d769 9
a777 1
    bool was = PL_tainted;
d784 6
a789 2
	UV uv = SSPOPUV;
	const U8 type = (U8)uv & SAVE_MASK;
d792 19
d813 6
a818 6
	    value = MUTABLE_SV(SSPOPPTR);
	    sv = MUTABLE_SV(SSPOPPTR);
	    sv_replace(sv,value);
	    PL_localizing = 2;
	    SvSETMAGIC(sv);
	    PL_localizing = 0;
d820 8
d829 2
a830 4
	    value = MUTABLE_SV(SSPOPPTR);
	    gv = MUTABLE_GV(SSPOPPTR);
	    ptr = &GvSV(gv);
	    av = MUTABLE_AV(gv); /* what to refcnt_dec */
d832 3
a834 2
	    sv = *(SV**)ptr;
	    *(SV**)ptr = value;
d836 7
a842 5
	    PL_localizing = 2;
	    SvSETMAGIC(value);
	    PL_localizing = 0;
	    SvREFCNT_dec(value);
	    SvREFCNT_dec(av); /* av may actually be an AV, HV or GV */
d844 1
d846 3
a848 5
	    ptr = SSPOPPTR;
	    str = (char*)SSPOPPTR;
	    if (*(char**)ptr != str) {
		Safefree(*(char**)ptr);
		*(char**)ptr = str;
d852 1
a852 3
	    str = (char*)SSPOPPTR;
	    ptr = SSPOPPTR;
	    if (*(char**)ptr != str) {
d854 1
a854 1
		PerlMem_free(*(char**)ptr);
d856 1
a856 1
		PerlMemShared_free(*(char**)ptr);
d858 1
a858 1
		*(char**)ptr = str;
d862 1
a862 3
	    value = MUTABLE_SV(SSPOPPTR);
	    gv = MUTABLE_GV(SSPOPPTR);
	    ptr = &GvSV(gv);
d865 1
a865 2
	    value = MUTABLE_SV(SSPOPPTR);
	    ptr = SSPOPPTR;
d867 3
a869 2
	    sv = *(SV**)ptr;
	    *(SV**)ptr = value;
d871 1
a871 1
	    SvREFCNT_dec(value);
d873 18
d892 8
a899 10
	    av = MUTABLE_AV(SSPOPPTR);
	    gv = MUTABLE_GV(SSPOPPTR);
	    SvREFCNT_dec(GvAV(gv));
	    GvAV(gv) = av;
	    if (SvMAGICAL(av)) {
		PL_localizing = 2;
		SvSETMAGIC(MUTABLE_SV(av));
		PL_localizing = 0;
	    }
	    SvREFCNT_dec(gv);
d902 8
a909 10
	    hv = MUTABLE_HV(SSPOPPTR);
	    gv = MUTABLE_GV(SSPOPPTR);
	    SvREFCNT_dec(GvHV(gv));
	    GvHV(gv) = hv;
	    if (SvMAGICAL(hv)) {
		PL_localizing = 2;
		SvSETMAGIC(MUTABLE_SV(hv));
		PL_localizing = 0;
	    }
	    SvREFCNT_dec(gv);
d912 1
a912 2
	    ptr = SSPOPPTR;
	    *(int*)ptr = (int)(uv >> SAVE_TIGHT_SHIFT);
d915 1
a915 2
	    ptr = SSPOPPTR;
	    *(int*)ptr = (int)SSPOPINT;
d918 5
a922 4
	    ptr = SSPOPPTR;
	    *(bool*)ptr = cBOOL(uv >> 8);

	    if (ptr == &PL_tainted) {
d928 1
a928 1
		was = *(bool*)ptr;
d930 1
d933 1
a933 2
	    ptr = SSPOPPTR;
	    *(I32*)ptr = (I32)(uv >> SAVE_TIGHT_SHIFT);
a935 1
	    ptr = SSPOPPTR;
d937 1
a937 7
	    {
		const I32 val = SSPOPINT;
		if (*(I32*)ptr != val)
		    *(I32*)ptr = val;
	    }
#else
	    *(I32*)ptr = (I32)SSPOPINT;
d939 1
d942 1
a942 2
	    ptr = SSPOPPTR;
	    *(SV**)ptr = MUTABLE_SV(SSPOPPTR);
d946 1
a946 2
	    ptr = SSPOPPTR;
	    *(char**)ptr = (char*)SSPOPPTR;
d949 1
a949 2
	    ptr = SSPOPPTR;
	    *(HV**)ptr = MUTABLE_HV(SSPOPPTR);
d952 1
a952 2
	    ptr = SSPOPPTR;
	    *(AV**)ptr = MUTABLE_AV(SSPOPPTR);
d955 16
a970 8
	    ptr = SSPOPPTR;
	    gv = MUTABLE_GV(SSPOPPTR);
	    gp_free(gv);
	    GvGP_set(gv, (GP*)ptr);
            /* putting a method back into circulation ("local")*/
	    if (GvCVu(gv) && (hv=GvSTASH(gv)) && HvENAME_get(hv))
                mro_method_changed_in(hv);
	    SvREFCNT_dec(gv);
d972 1
d974 1
a974 2
	    ptr = SSPOPPTR;
	    SvREFCNT_dec(MUTABLE_SV(ptr));
d977 1
a977 2
	    ptr = SSPOPPTR;
	    cophh_free((COPHH *)ptr);
d980 1
a980 2
	    ptr = SSPOPPTR;
	    sv_2mortal(MUTABLE_SV(ptr));
d983 2
a984 3
	    ptr = SSPOPPTR;
	    ASSERT_CURPAD_LEGAL("SAVEt_FREEOP"); /* XXX DAPM tmp */
	    op_free((OP*)ptr);
d987 1
a987 2
	    ptr = SSPOPPTR;
	    Safefree(ptr);
d989 11
d1001 84
a1084 58
	    ptr = (void*)&PL_curpad[uv >> SAVE_TIGHT_SHIFT];
	    sv = *(SV**)ptr;

	    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
	     "Pad 0x%"UVxf"[0x%"UVxf"] clearsv: %ld sv=0x%"UVxf"<%"IVdf"> %s\n",
		PTR2UV(PL_comppad), PTR2UV(PL_curpad),
		(long)((SV **)ptr-PL_curpad), PTR2UV(sv), (IV)SvREFCNT(sv),
		(SvREFCNT(sv) <= 1 && !SvOBJECT(sv)) ? "clear" : "abandon"
	    ));

	    /* Can clear pad variable in place? */
	    if (SvREFCNT(sv) <= 1 && !SvOBJECT(sv)) {
		/*
		 * if a my variable that was made readonly is going out of
		 * scope, we want to remove the readonlyness so that it can
		 * go out of scope quietly
		 */
		if (SvPADMY(sv) && !SvFAKE(sv))
		    SvREADONLY_off(sv);

		if (SvTHINKFIRST(sv))
		    sv_force_normal_flags(sv, SV_IMMEDIATE_UNREF);
		if (SvTYPE(sv) == SVt_PVHV)
		    Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
		if (SvMAGICAL(sv))
		    sv_unmagic(sv, PERL_MAGIC_backref),
		    mg_free(sv);

		switch (SvTYPE(sv)) {
		case SVt_NULL:
		    break;
		case SVt_PVAV:
		    av_clear(MUTABLE_AV(sv));
		    break;
		case SVt_PVHV:
		    hv_clear(MUTABLE_HV(sv));
		    break;
		case SVt_PVCV:
		    Perl_croak(aTHX_ "panic: leave_scope pad code");
		default:
		    SvOK_off(sv);
		    break;
		}
		SvPADSTALE_on(sv); /* mark as no longer live */
	    }
	    else {	/* Someone has a claim on this, so abandon it. */
		assert(  SvFLAGS(sv) & SVs_PADMY);
		assert(!(SvFLAGS(sv) & SVs_PADTMP));
		switch (SvTYPE(sv)) {	/* Console ourselves with a new value */
		case SVt_PVAV:	*(SV**)ptr = MUTABLE_SV(newAV());	break;
		case SVt_PVHV:	*(SV**)ptr = MUTABLE_SV(newHV());	break;
		default:	*(SV**)ptr = newSV(0);		break;
		}
		SvREFCNT_dec(sv);	/* Cast current value to the winds. */
		/* preserve pad nature, but also mark as not live
		 * for any closure capturing */
		SvFLAGS(*(SV**)ptr) |= (SVs_PADMY|SVs_PADSTALE);
	    }
d1086 1
d1088 3
a1090 7
	    ptr = SSPOPPTR;
	    hv = MUTABLE_HV(ptr);
	    i = SSPOPINT;
	    ptr = SSPOPPTR;
	    (void)hv_delete(hv, (char*)ptr, i, G_DISCARD);
	    SvREFCNT_dec(hv);
	    Safefree(ptr);
d1093 2
a1094 5
	    ptr = SSPOPPTR;
	    av = MUTABLE_AV(ptr);
	    i = SSPOPINT;
	    (void)av_delete(av, i, G_DISCARD);
	    SvREFCNT_dec(av);
d1097 1
a1097 2
	    ptr = SSPOPPTR;
	    (*SSPOPDXPTR)(aTHX_ ptr);
d1105 1
a1105 2
	    i = SSPOPINT;
	    PL_stack_sp = PL_stack_base + i;
d1108 1
a1108 2
	    i = SSPOPINT;
	    cxstack[i].blk_oldsp = SSPOPINT;
d1111 5
a1115 8
	    value = MUTABLE_SV(SSPOPPTR);
	    i = SSPOPINT;
	    av = MUTABLE_AV(SSPOPPTR);
	    ptr = av_fetch(av,i,1);
	    if (!AvREAL(av) && AvREIFY(av)) /* undo reify guard */
		SvREFCNT_dec(value);
	    if (ptr) {
		sv = *(SV**)ptr;
d1117 1
a1117 1
		    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied))
d1119 1
d1123 2
a1124 2
	    SvREFCNT_dec(av);
	    SvREFCNT_dec(value);
d1127 5
a1131 7
	    value = MUTABLE_SV(SSPOPPTR);
	    sv = MUTABLE_SV(SSPOPPTR);
	    hv = MUTABLE_HV(SSPOPPTR);
	    ptr = hv_fetch_ent(hv, sv, 1, 0);
	    SvREFCNT_dec(sv);
	    if (ptr) {
		const SV * const oval = HeVAL((HE*)ptr);
d1133 4
a1136 4
		    ptr = &HeVAL((HE*)ptr);
		    if (SvTIED_mg((const SV *)hv, PERL_MAGIC_tied))
			SvREFCNT_inc_void(*(SV**)ptr);
		    av = MUTABLE_AV(hv); /* what to refcnt_dec */
d1140 2
a1141 2
	    SvREFCNT_dec(hv);
	    SvREFCNT_dec(value);
d1143 1
d1145 1
a1145 1
	    PL_op = (OP*)SSPOPPTR;
d1156 2
a1157 2
	    CopHINTHASH_set(&PL_compiling, (COPHH*)SSPOPPTR);
	    *(I32*)&PL_hints = (I32)SSPOPINT;
d1163 2
a1164 15
		/* Need to add a new one manually, else gv_fetchpv() can
		   add one in this code:
		   
		   if (SvTYPE(gv) == SVt_PVGV) {
		       if (add) {
		       GvMULTI_on(gv);
		       gv_init_sv(gv, sv_type);
		       if (*name=='!' && sv_type == SVt_PVHV && len==1)
			   require_errno(gv);
		       }
		       return gv;
		   }

		   and it won't have the magic set.  */

d1172 1
a1172 1
	    PL_comppad = (PAD*)SSPOPPTR;
a1179 1
		const PADOFFSET off = (PADOFFSET)SSPOPLONG;
d1181 2
a1182 3
		ptr = SSPOPPTR;
		assert (ptr);
		svp = AvARRAY((PAD*)ptr) + off;
d1187 1
a1187 1
		*svp = MUTABLE_SV(SSPOPPTR);
d1193 2
a1194 4
		AV *const t = MUTABLE_AV(SSPOPPTR);
		AV *const f = MUTABLE_AV(SSPOPPTR);
		SWITCHSTACK(t,f);
		PL_curstackinfo->si_stack = f;
d1198 2
a1199 7
	    {
		const U32 val  = (U32)SSPOPINT;
		const U32 mask = (U32)SSPOPINT;
		sv = MUTABLE_SV(SSPOPPTR);
		SvFLAGS(sv) &= ~mask;
		SvFLAGS(sv) |= val;
	    }
a1201 8
	    /* This would be a mathom, but Perl_save_svref() calls a static
	       function, S_save_scalar_at(), so has to stay in this file.  */
	case SAVEt_SVREF:			/* scalar reference */
	    value = MUTABLE_SV(SSPOPPTR);
	    ptr = SSPOPPTR;
	    av = NULL; /* what to refcnt_dec */
	    goto restore_sv;

d1204 1
a1204 2
	    gv = MUTABLE_GV(SSPOPPTR);
	    (void)sv_clear(MUTABLE_SV(gv));
d1207 1
a1207 2
	    ptr = SSPOPPTR;
	    *(long*)ptr = (long)SSPOPLONG;
d1210 1
a1210 2
	    ptr = SSPOPPTR;
	    *(IV*)ptr = (IV)SSPOPIV;
d1214 1
a1214 2
	    ptr = SSPOPPTR;
	    *(I16*)ptr = (I16)(uv >> 8);
d1217 1
a1217 2
	    ptr = SSPOPPTR;
	    *(I8*)ptr = (I8)(uv >> 8);
d1220 1
a1220 2
	    ptr = SSPOPPTR;
	    (*SSPOPDPTR)(ptr);
a1222 2
	    ptr = SSPOPPTR;

d1226 1
a1226 1
	    PL_compiling.cop_warnings = (STRLEN*)ptr;
a1235 3
		if (PL_reg_start_tmp != state->re_state_reg_start_tmp) {
		    Safefree(PL_reg_start_tmp);
		}
d1243 1
a1243 2
	    ptr = SSPOPPTR;
	    parser_free((yy_parser *) ptr);
d1250 1
a1250 3
    PL_tainted = was;

    PERL_ASYNC_CHECK();
d1263 1
d1271 15
a1285 1
	PerlIO_printf(Perl_debug_log, "BLK_GIMME = %s\n", cx->blk_gimme ? "LIST" : "SCALAR");
d1382 1
a1382 1
 * indent-tabs-mode: t
d1385 1
a1385 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d80 1
a80 1
    Renew(cxstack, cxstack_max + 1, PERL_CONTEXT);	/* XXX should fix CXINC macro */
d184 1
a184 1
    if (SvTYPE(osv) >= SVt_PVMG && SvMAGIC(osv) && SvTYPE(osv) != SVt_PVGV) {
a185 1
	    const bool oldtainted = PL_tainted;
a187 1
	    PL_tainted = oldtainted;
d190 1
a190 1
	    mg_localize(osv, sv, (flags & SAVEf_SETMAGIC) != 0);
d203 1
a203 1
    SSPUSHINT(type);
d272 1
a272 1
    SSPUSHINT(SAVEt_SET_SVFLAGS);
d301 1
a301 1
	GvGP(gv) = gp;
d320 1
a320 1
    save_pushptrptr(gv, oav, SAVEt_AV);
d337 3
a339 1
    save_pushptrptr(gv, (ohv = GvHVn(gv)), SAVEt_HV);
d368 1
a368 2
    SSCHECK(3);
    SSPUSHBOOL(*boolp);
d370 1
a370 1
    SSPUSHINT(SAVEt_BOOL);
d380 1
a380 1
    SSPUSHINT(type);
d387 1
d391 6
a396 1
    save_pushi32ptr(*intp, intp, SAVEt_INT);
d406 3
a408 1
    save_pushi32ptr(*bytep, bytep, SAVEt_I8);
d418 3
a420 1
    save_pushi32ptr(*intp, intp, SAVEt_I16);
d427 1
d431 6
a436 1
    save_pushi32ptr(*intp, intp, SAVEt_I32);
d481 1
a481 1
    SSPUSHINT(SAVEt_PADSV_AND_MORTALIZE);
d510 1
a510 1
    SSPUSHINT(type);
d517 2
d523 6
a528 3
    SSCHECK(2);
    SSPUSHLONG((long)(svp-PL_curpad));
    SSPUSHINT(SAVEt_CLEARSV);
d578 1
a578 1
    SSPUSHINT(SAVEt_DESTRUCTOR);
d588 1
a588 1
    SSPUSHINT(SAVEt_DESTRUCTOR_X);
d595 1
a595 5
    if (PL_compiling.cop_hints_hash) {
	HINTS_REFCNT_LOCK;
	    PL_compiling.cop_hints_hash->refcounted_he_refcnt++;
	    HINTS_REFCNT_UNLOCK;
    }
d597 4
a600 3
	save_pushptri32ptr(GvHV(PL_hintgv), PL_hints,
			   PL_compiling.cop_hints_hash, SAVEt_HINTS);
	GvHV(PL_hintgv) = Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv));
d602 1
a602 1
	save_pushi32ptr(PL_hints, PL_compiling.cop_hints_hash, SAVEt_HINTS);
d614 1
a614 1
    SSPUSHINT(type);
d639 1
a639 1
    if (SvTIED_mg(sv, PERL_MAGIC_tiedelem))
d656 1
a656 1
    SSPUSHINT(SAVEt_HELEM);
d665 1
a665 1
    if (SvTIED_mg(sv, PERL_MAGIC_tiedelem))
d687 2
a688 1
    register const I32 elems = 1 + ((size + pad - 1) / sizeof(*PL_savestack));
d690 5
a694 1
    SSGROW(elems + 2);
d697 1
a697 2
    SSPUSHINT(elems);
    SSPUSHINT(SAVEt_ALLOC);
d714 1
a714 1
    const bool was = PL_tainted;
d717 3
a719 1
	Perl_croak(aTHX_ "panic: corrupt saved stack index");
d721 2
d725 1
a725 1
	switch (SSPOPINT) {
d747 1
a747 2
	    if (av) /* actually an av, hv or gv */
		SvREFCNT_dec(av);
d769 5
d777 1
d793 1
d805 5
d817 14
a830 1
	    *(bool*)ptr = (bool)SSPOPBOOL;
d865 1
a865 1
	    GvGP(gv) = (GP*)ptr;
d867 1
a867 1
	    if (GvCVu(gv) && (hv=GvSTASH(gv)) && HvNAME_get(hv))
d875 4
d893 1
a893 1
	    ptr = (void*)&PL_curpad[SSPOPLONG];
d915 2
d918 1
d939 2
a940 1
		const U32 padflags = SvFLAGS(sv) & (SVs_PADMY|SVs_PADTMP);
d949 1
a949 1
		SvFLAGS(*(SV**)ptr) |= padflags | SVs_PADSTALE;
d973 1
d975 1
a975 2
	    i = SSPOPINT;
	    PL_savestack_ix -= i;  	/* regexp must have croaked */
d1026 3
a1028 2
	    if ((PL_hints & HINT_LOCALIZE_HH) && GvHV(PL_hintgv)) {
		SvREFCNT_dec(MUTABLE_SV(GvHV(PL_hintgv)));
d1030 2
d1033 2
a1034 2
	    Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
	    PL_compiling.cop_hints_hash = (struct refcounted_he *) SSPOPPTR;
d1039 2
a1040 2
		assert(GvHV(PL_hintgv));
	    } else if (!GvHV(PL_hintgv)) {
d1126 1
a1126 1
	    *(I16*)ptr = (I16)SSPOPINT;
d1130 1
a1130 1
	    *(I8*)ptr = (I8)SSPOPINT;
a1135 5
	case SAVEt_COP_ARYBASE:
	    ptr = SSPOPPTR;
	    i = SSPOPINT;
	    CopARYBASE_set((COP *)ptr, i);
	    break;
d1166 1
a1166 1
	    Perl_croak(aTHX_ "panic: leave_scope inconsistency");
d1171 2
a1244 2
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.NEXT_OP = 0x%"UVxf"\n",
		PTR2UV(CX_LOOP_NEXTOP_GET(cx)));
@


1.12
log
@Merge in perl 5.10.1
@
text
@d94 3
d98 3
d173 1
a173 1
S_save_scalar_at(pTHX_ SV **sptr)
d176 2
a177 2
    SV * const osv = *sptr;
    register SV * const sv = *sptr = newSV(0);
d181 3
d191 2
a192 1
	mg_localize(osv, sv);
d194 1
d220 1
a220 1
    return save_scalar_at(sptr);
d327 1
a327 1
	mg_localize(MUTABLE_SV(oav), MUTABLE_SV(av));
d344 1
a344 1
	mg_localize(MUTABLE_SV(ohv), MUTABLE_SV(hv));
d523 26
d575 5
a579 1
    SSCHECK(4);
d581 2
a582 1
	SSPUSHPTR(GvHV(PL_hintgv));
d584 2
a586 8
    if (PL_compiling.cop_hints_hash) {
	HINTS_REFCNT_LOCK;
	PL_compiling.cop_hints_hash->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
    }
    SSPUSHPTR(PL_compiling.cop_hints_hash);
    SSPUSHINT(PL_hints);
    SSPUSHINT(SAVEt_HINTS);
d601 1
a601 1
Perl_save_aelem(pTHX_ AV *av, I32 idx, SV **sptr)
d606 1
a606 1
    PERL_ARGS_ASSERT_SAVE_AELEM;
d614 3
a616 1
    save_scalar_at(sptr);
d627 1
a627 1
Perl_save_helem(pTHX_ HV *hv, SV *key, SV **sptr)
d632 1
a632 1
    PERL_ARGS_ASSERT_SAVE_HELEM;
d640 3
a642 1
    save_scalar_at(sptr);
d661 1
a661 1
    return save_scalar_at(sptr);
a715 4
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
				  "restore svref: %p %p:%s -> %p:%s\n",
				  (void*)ptr, (void*)sv, SvPEEK(sv),
				  (void*)value, SvPEEK(value)));
d756 1
a756 3
	    if (GvAV(gv)) {
		SvREFCNT_dec(GvAV(gv));
	    }
d767 1
a767 3
	    if (GvHV(gv)) {
		SvREFCNT_dec(GvHV(gv));
	    }
d904 7
a972 1
	    *(I32*)&PL_hints = (I32)SSPOPINT;
d975 1
a1063 15
	    /* This case is rendered redundant by the integration of change
	       33078. See the comment near Perl_save_padsv().  */
	case SAVEt_PADSV:
	    {
		const PADOFFSET off = (PADOFFSET)SSPOPLONG;
		ptr = SSPOPPTR;
		if (ptr)
		    AvARRAY((PAD*)ptr)[off] = (SV*)SSPOPPTR;
		else {
		  /* Can we ever get here?
		     POPs must balance PUSHes.  */
		    (void) SSPOPPTR;
		}
	    }
	    break;
d1142 7
a1148 7
	PerlIO_printf(Perl_debug_log, "BLK_SUB.CV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.cv));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.GV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.gv));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.DFOUTGV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.dfoutgv));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.HASARGS = %d\n",
d1150 2
a1151 2
	PerlIO_printf(Perl_debug_log, "BLK_SUB.RETOP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.retop));
d1179 4
a1182 1
    case CXt_LOOP:
d1190 3
d1194 1
a1194 3
		(long)cx->blk_loop.iterix);
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERARY = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.iterary));
a1196 2
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERLVAL = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.iterlval));
a1227 16
}

/* This is rendered a mathom by the integration of change 33078. However, until
   we have versioned mathom logic in mathoms.c, we can't move it there for
   5.10.1, as other code in production may have linked to it.  */

void
Perl_save_padsv(pTHX_ PADOFFSET off)
{
    dVAR;
    SSCHECK(4);
    ASSERT_CURPAD_ACTIVE("save_padsv");
    SSPUSHPTR(PL_curpad[off]);
    SSPUSHPTR(PL_comppad);
    SSPUSHLONG((long)off);
    SSPUSHINT(SAVEt_PADSV);
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d12 4
a15 2
 * "For the fashion of Minas Tirith was such that it was built on seven
 * levels..."
d33 3
d173 2
d187 10
d202 3
d208 1
a208 4
    SSCHECK(3);
    SSPUSHPTR(SvREFCNT_inc_simple(gv));
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_SV);
d218 4
a221 4
    SSCHECK(3);
    SSPUSHPTR(sptr);
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_GENERIC_SVREF);
d231 4
a234 4
    SSCHECK(3);
    SSPUSHPTR(*str);
    SSPUSHPTR(str);
    SSPUSHINT(SAVEt_GENERIC_PVREF);
d244 4
a247 4
    SSCHECK(3);
    SSPUSHPTR(str);
    SSPUSHPTR(*str);
    SSPUSHINT(SAVEt_SHARED_PVREF);
d256 3
d270 4
a273 4
    SSGROW(3);
    SSPUSHPTR(SvREFCNT_inc(gv));
    SSPUSHPTR(GvGP(gv));
    SSPUSHINT(SAVEt_GP);
d307 2
d311 1
a311 4
    SSCHECK(3);
    SSPUSHPTR(gv);
    SSPUSHPTR(oav);
    SSPUSHINT(SAVEt_AV);
d316 1
a316 1
	mg_localize((SV*)oav, (SV*)av);
d326 3
a328 4
    SSCHECK(3);
    SSPUSHPTR(gv);
    SSPUSHPTR(ohv = GvHVn(gv));
    SSPUSHINT(SAVEt_HV);
d333 1
a333 1
	mg_localize((SV*)ohv, (SV*)hv);
d343 14
d358 3
a360 3
    SSPUSHPTR(item);		/* remember the pointer */
    SSPUSHPTR(sv);		/* remember the value */
    SSPUSHINT(SAVEt_ITEM);
d364 1
a364 1
Perl_save_int(pTHX_ int *intp)
d368 3
a370 3
    SSPUSHINT(*intp);
    SSPUSHPTR(intp);
    SSPUSHINT(SAVEt_INT);
d374 1
a374 1
Perl_save_bool(pTHX_ bool *boolp)
d377 4
a380 4
    SSCHECK(3);
    SSPUSHBOOL(*boolp);
    SSPUSHPTR(boolp);
    SSPUSHINT(SAVEt_BOOL);
d387 4
a390 4
    SSCHECK(3);
    SSPUSHINT(*bytep);
    SSPUSHPTR(bytep);
    SSPUSHINT(SAVEt_I8);
d397 4
a400 4
    SSCHECK(3);
    SSPUSHINT(*intp);
    SSPUSHPTR(intp);
    SSPUSHINT(SAVEt_I16);
d407 4
a410 4
    SSCHECK(3);
    SSPUSHINT(*intp);
    SSPUSHPTR(intp);
    SSPUSHINT(SAVEt_I32);
d420 4
a423 4
    SSCHECK(3);
    SSPUSHPTR(*pptr);
    SSPUSHPTR(pptr);
    SSPUSHINT(SAVEt_PPTR);
d430 4
a433 4
    SSCHECK(3);
    SSPUSHPTR(*(char**)ptr);
    SSPUSHPTR(ptr);
    SSPUSHINT(SAVEt_VPTR);
d440 4
a443 4
    SSCHECK(3);
    SSPUSHPTR(*sptr);
    SSPUSHPTR(sptr);
    SSPUSHINT(SAVEt_SPTR);
d447 1
a447 1
Perl_save_padsv(pTHX_ PADOFFSET off)
d452 1
a452 1
    SSPUSHPTR(PL_curpad[off]);
d455 1
a455 1
    SSPUSHINT(SAVEt_PADSV);
d462 4
a465 4
    SSCHECK(3);
    SSPUSHPTR(*hptr);
    SSPUSHPTR(hptr);
    SSPUSHINT(SAVEt_HPTR);
a471 5
    SSCHECK(3);
    SSPUSHPTR(*aptr);
    SSPUSHPTR(aptr);
    SSPUSHINT(SAVEt_APTR);
}
d473 3
a475 7
void
Perl_save_freesv(pTHX_ SV *sv)
{
    dVAR;
    SSCHECK(2);
    SSPUSHPTR(sv);
    SSPUSHINT(SAVEt_FREESV);
d479 1
a479 1
Perl_save_mortalizesv(pTHX_ SV *sv)
d483 2
a484 2
    SSPUSHPTR(sv);
    SSPUSHINT(SAVEt_MORTALIZESV);
d488 1
a488 1
Perl_save_freeop(pTHX_ OP *o)
a490 4
    SSCHECK(2);
    SSPUSHPTR(o);
    SSPUSHINT(SAVEt_FREEOP);
}
d492 1
a492 8
void
Perl_save_freepv(pTHX_ char *pv)
{
    dVAR;
    SSCHECK(2);
    SSPUSHPTR(pv);
    SSPUSHINT(SAVEt_FREEPV);
}
a493 4
void
Perl_save_clearsv(pTHX_ SV **svp)
{
    dVAR;
d505 4
a508 5
    SSCHECK(4);
    SSPUSHINT(klen);
    SSPUSHPTR(key);
    SSPUSHPTR(SvREFCNT_inc_simple(hv));
    SSPUSHINT(SAVEt_DELETE);
d515 3
d535 30
d569 3
d573 2
a574 5
    SSCHECK(4);
    SSPUSHPTR(SvREFCNT_inc_simple(av));
    SSPUSHINT(idx);
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_AELEM);
d593 3
d616 3
d620 1
a620 4
    SSCHECK(3);
    SSPUSHPTR(sptr);
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_SVREF);
a623 9
void
Perl_save_op(pTHX)
{
    dVAR;
    SSCHECK(2);
    SSPUSHPTR(PL_op);
    SSPUSHINT(SAVEt_OP);
}

d652 2
d658 2
d662 2
a663 2
	    value = (SV*)SSPOPPTR;
	    sv = (SV*)SSPOPPTR;
d670 2
a671 2
	    value = (SV*)SSPOPPTR;
	    gv = (GV*)SSPOPPTR;
d673 1
a673 1
	    av = (AV*)gv; /* what to refcnt_dec */
d710 1
a710 1
	    value = (SV*)SSPOPPTR;
d718 2
a719 2
	    av = (AV*)SSPOPPTR;
	    gv = (GV*)SSPOPPTR;
d726 1
a726 1
		SvSETMAGIC((SV*)av);
d731 2
a732 2
	    hv = (HV*)SSPOPPTR;
	    gv = (GV*)SSPOPPTR;
d739 1
a739 1
		SvSETMAGIC((SV*)hv);
d765 1
a765 1
	    *(SV**)ptr = (SV*)SSPOPPTR;
d774 1
a774 1
	    *(HV**)ptr = (HV*)SSPOPPTR;
d778 1
a778 1
	    *(AV**)ptr = (AV*)SSPOPPTR;
d782 1
a782 1
	    gv = (GV*)SSPOPPTR;
d792 1
a792 1
	    SvREFCNT_dec((SV*)ptr);
d796 1
a796 1
	    sv_2mortal((SV*)ptr);
d837 1
a837 1
		    av_clear((AV*)sv);
d840 1
a840 1
		    hv_clear((HV*)sv);
d853 2
a854 2
		case SVt_PVAV:	*(SV**)ptr = (SV*)newAV();	break;
		case SVt_PVHV:	*(SV**)ptr = (SV*)newHV();	break;
d865 2
a866 1
	    hv = (HV*)ptr;
d868 1
a868 1
	    (void)hv_delete(hv, (char*)ptr, (I32)SSPOPINT, G_DISCARD);
d890 1
a890 1
	    value = (SV*)SSPOPPTR;
d892 1
a892 1
	    av = (AV*)SSPOPPTR;
d899 1
a899 1
		    if (SvTIED_mg((SV*)av, PERL_MAGIC_tied))
d908 3
a910 3
	    value = (SV*)SSPOPPTR;
	    sv = (SV*)SSPOPPTR;
	    hv = (HV*)SSPOPPTR;
d912 1
d917 1
a917 1
		    if (SvTIED_mg((SV*)hv, PERL_MAGIC_tied))
d919 1
a919 2
		    SvREFCNT_dec(sv);
		    av = (AV*)hv; /* what to refcnt_dec */
a923 1
	    SvREFCNT_dec(sv);
d931 1
a931 1
		SvREFCNT_dec((SV*)GvHV(PL_hintgv));
d938 2
a939 2
		SvREFCNT_dec((SV*)GvHV(PL_hintgv));
		GvHV(PL_hintgv) = (HV*)SSPOPPTR;
d970 1
a970 1
	case SAVEt_PADSV:
d973 1
d975 7
a981 2
		if (ptr)
		    AvARRAY((PAD*)ptr)[off] = (SV*)SSPOPPTR;
d987 2
a988 2
		AV* const t = (AV*)SSPOPPTR;
		AV* const f = (AV*)SSPOPPTR;
d997 1
a997 1
		sv = (SV*)SSPOPPTR;
d1002 3
a1004 1
	    /* These are only saved in mathoms.c */
d1006 1
a1006 1
	    value = (SV*)SSPOPPTR;
d1010 6
d1020 20
a1047 8
	case SAVEt_IV:				/* IV reference */
	    ptr = SSPOPPTR;
	    *(IV*)ptr = (IV)SSPOPIV;
	    break;
	case SAVEt_NSTAB:
	    gv = (GV*)SSPOPPTR;
	    (void)sv_clear((SV*)gv);
	    break;
d1090 2
d1098 3
d1125 1
a1125 1
		(int)cx->blk_sub.hasargs);
d1135 2
a1136 3
		(int)cx->blk_sub.hasargs);
	PerlIO_printf(Perl_debug_log, "BLK_SUB.LVAL = %d\n",
		(int)cx->blk_sub.lval);
d1142 1
a1142 1
		(long)cx->blk_eval.old_in_eval);
d1144 2
a1145 2
		PL_op_name[cx->blk_eval.old_op_type],
		PL_op_desc[cx->blk_eval.old_op_type]);
d1156 1
a1156 2
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.LABEL = %s\n",
		cx->blk_loop.label);
a1168 3
	if (CxITERVAR(cx))
	    PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERSAVE = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.itersave));
d1181 1
a1181 1
		(long)cx->sb_once);
d1202 16
@


1.10
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, by Larry Wall and others
a26 31
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
void *
Perl_default_protect(pTHX_ volatile JMPENV *pcur_env, int *excpt,
		     protect_body_t body, ...)
{
    void *ret;
    va_list args;
    va_start(args, body);
    ret = vdefault_protect(pcur_env, excpt, body, &args);
    va_end(args);
    return ret;
}

void *
Perl_vdefault_protect(pTHX_ volatile JMPENV *pcur_env, int *excpt,
		      protect_body_t body, va_list *args)
{
    int ex;
    void *ret;

    JMPENV_PUSH(ex);
    if (ex)
	ret = NULL;
    else
	ret = CALL_FPTR(body)(aTHX_ *args);
    *excpt = ex;
    JMPENV_POP;
    return ret;
}
#endif

d30 1
d49 1
d65 1
a65 1
    Poison(si->si_cxstack, cxitems, PERL_CONTEXT);
d72 1
d78 1
a78 1
    Poison(cxstack + old_max + 1, cxstack_max - old_max, PERL_CONTEXT);
a82 19
Perl_push_return(pTHX_ OP *retop)
{
    if (PL_retstack_ix == PL_retstack_max) {
	PL_retstack_max = GROW(PL_retstack_max);
	Renew(PL_retstack, PL_retstack_max, OP*);
    }
    PL_retstack[PL_retstack_ix++] = retop;
}

OP *
Perl_pop_return(pTHX)
{
    if (PL_retstack_ix > 0)
	return PL_retstack[--PL_retstack_ix];
    else
	return Nullop;
}

void
d85 1
d97 1
d105 1
d117 1
d125 1
d135 1
d148 1
d153 1
a153 1
	PL_tmps_stack[PL_tmps_ix--] = Nullsv;
d164 1
d166 1
a166 1
    register SV * const sv = *sptr = NEWSV(0,0);
a168 1
	sv_upgrade(sv, SvTYPE(osv));
a169 1
	    MAGIC* mg;
a170 6
	    mg_get(osv);		/* note, can croak! */
	    if (PL_tainting && PL_tainted &&
			(mg = mg_find(osv, PERL_MAGIC_taint))) {
		SAVESPTR(mg->mg_obj);
		mg->mg_obj = osv;
	    }
d172 1
a172 1
	       (SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d175 1
a175 8
	SvMAGIC_set(sv, SvMAGIC(osv));
	SvFLAGS(sv) |= SvMAGICAL(osv);
	/* XXX SvMAGIC() is *shared* between osv and sv.  This can
	 * lead to coredumps when both SVs are destroyed without one
	 * of their SvMAGIC() slots being NULLed. */
	PL_localizing = 1;
	SvSETMAGIC(sv);
	PL_localizing = 0;
d183 5
a187 1
    SV **sptr = &GvSV(gv);
d189 1
a189 1
    SSPUSHPTR(SvREFCNT_inc(gv));
a194 10
SV*
Perl_save_svref(pTHX_ SV **sptr)
{
    SSCHECK(3);
    SSPUSHPTR(sptr);
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_SVREF);
    return save_scalar_at(sptr);
}

d200 1
d213 1
d215 1
a216 1
    SSPUSHPTR(*str);
d226 1
d233 13
d249 2
a250 6
    SSGROW(6);
    SSPUSHIV((IV)SvLEN(gv));
    SvLEN_set(gv, 0); /* forget that anything was allocated here */
    SSPUSHIV((IV)SvCUR(gv));
    SSPUSHPTR(SvPVX_const(gv));
    SvPOK_off(gv);
d256 1
a256 3
	register GP *gp;

	Newxz(gp, 1, GP);
d259 1
a259 1
	    PL_sub_generation++;	/* taking a method out of circulation */
d264 9
a272 7
	GvGP(gv) = gp_ref(gp);
	GvSV(gv) = NEWSV(72,0);
	GvLINE(gv) = CopLINE(PL_curcop);
	/* XXX Ideally this cast would be replaced with a change to const char*
	   in the struct.  */
	GvFILE(gv) = CopFILE(PL_curcop) ? CopFILE(PL_curcop) : (char *) "";
	GvEGV(gv) = gv;
d283 1
d294 1
a294 1
    GvAV(gv) = Null(AV*);
d296 2
a297 9
    if (SvMAGIC(oav)) {
	SvMAGIC_set(av, SvMAGIC(oav));
	SvFLAGS((SV*)av) |= SvMAGICAL(oav);
	SvMAGICAL_off(oav);
	SvMAGIC_set(oav, NULL);
	PL_localizing = 1;
	SvSETMAGIC((SV*)av);
	PL_localizing = 0;
    }
d304 1
d312 1
a312 1
    GvHV(gv) = Null(HV*);
d314 2
a315 9
    if (SvMAGIC(ohv)) {
	SvMAGIC_set(hv, SvMAGIC(ohv));
	SvFLAGS((SV*)hv) |= SvMAGICAL(ohv);
	SvMAGICAL_off(ohv);
	SvMAGIC_set(ohv, NULL);
	PL_localizing = 1;
	SvSETMAGIC((SV*)hv);
	PL_localizing = 0;
    }
d322 1
d334 1
a341 9
Perl_save_long(pTHX_ long int *longp)
{
    SSCHECK(3);
    SSPUSHLONG(*longp);
    SSPUSHPTR(longp);
    SSPUSHINT(SAVEt_LONG);
}

void
d344 1
d352 1
a352 1
Perl_save_I32(pTHX_ I32 *intp)
d354 1
d356 3
a358 3
    SSPUSHINT(*intp);
    SSPUSHPTR(intp);
    SSPUSHINT(SAVEt_I32);
d364 1
d372 1
a372 1
Perl_save_I8(pTHX_ I8 *bytep)
d374 1
d376 3
a378 12
    SSPUSHINT(*bytep);
    SSPUSHPTR(bytep);
    SSPUSHINT(SAVEt_I8);
}

void
Perl_save_iv(pTHX_ IV *ivp)
{
    SSCHECK(3);
    SSPUSHIV(*ivp);
    SSPUSHPTR(ivp);
    SSPUSHINT(SAVEt_IV);
d387 1
d397 1
d407 1
d417 1
a425 24
SV **
Perl_save_threadsv(pTHX_ PADOFFSET i)
{
#ifdef USE_5005THREADS
    SV **svp = &THREADSV(i);	/* XXX Change to save by offset */
    DEBUG_S(PerlIO_printf(Perl_debug_log, "save_threadsv %"UVuf": %p %p:%s\n",
			  (UV)i, svp, *svp, SvPEEK(*svp)));
    save_svref(svp);
    return svp;
#else
    Perl_croak(aTHX_ "panic: save_threadsv called in non-threaded perl");
    PERL_UNUSED_ARG(i);
    NORETURN_FUNCTION_END;
#endif /* USE_5005THREADS */
}

void
Perl_save_nogv(pTHX_ GV *gv)
{
    SSCHECK(2);
    SSPUSHPTR(gv);
    SSPUSHINT(SAVEt_NSTAB);
}

d429 1
d439 1
d449 1
d458 1
d467 1
d476 1
d485 1
d490 1
d496 1
d500 1
a500 1
    SSPUSHPTR(SvREFCNT_inc(hv));
a504 15
Perl_save_list(pTHX_ register SV **sarg, I32 maxsarg)
{
    register I32 i;

    for (i = 1; i <= maxsarg; i++) {
	register SV * const sv = NEWSV(0,0);
	sv_setsv(sv,sarg[i]);
	SSCHECK(3);
	SSPUSHPTR(sarg[i]);		/* remember the pointer */
	SSPUSHPTR(sv);			/* remember the value */
	SSPUSHINT(SAVEt_ITEM);
    }
}

void
d507 1
d517 1
d527 1
d529 1
d531 1
a531 1
    SSPUSHPTR(SvREFCNT_inc(av));
d537 1
a537 1
        (void)SvREFCNT_inc(*sptr);
d551 1
d553 1
d555 2
a556 2
    SSPUSHPTR(SvREFCNT_inc(hv));
    SSPUSHPTR(SvREFCNT_inc(key));
d569 12
d584 1
d593 1
d598 1
a598 3
    /* SSCHECK may not be good enough */
    while (PL_savestack_ix + elems + 2 > PL_savestack_max)
	savestack_grow();
d609 1
d615 1
a615 1
    register void* ptr;
d636 15
a650 1
	    goto restore_sv;
d652 1
a653 1
	    ptr = SSPOPPTR;
a678 42
	case SAVEt_SVREF:			/* scalar reference */
	    value = (SV*)SSPOPPTR;
	    ptr = SSPOPPTR;
	    av = Nullav; /* what to refcnt_dec */
	restore_sv:
	    sv = *(SV**)ptr;
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
				  "restore svref: %p %p:%s -> %p:%s\n",
				  ptr, sv, SvPEEK(sv), value, SvPEEK(value)));
	    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv) &&
		SvTYPE(sv) != SVt_PVGV)
	    {
		(void)SvUPGRADE(value, SvTYPE(sv));
		SvMAGIC_set(value, SvMAGIC(sv));
		SvFLAGS(value) |= SvMAGICAL(sv);
		SvMAGICAL_off(sv);
		SvMAGIC_set(sv, 0);
	    }
	    /* XXX This branch is pretty bogus.  This code irretrievably
	     * clears(!) the magic on the SV (either to avoid further
	     * croaking that might ensue when the SvSETMAGIC() below is
	     * called, or to avoid two different SVs pointing at the same
	     * SvMAGIC()).  This needs a total rethink.  --GSAR */
	    else if (SvTYPE(value) >= SVt_PVMG && SvMAGIC(value) &&
		     SvTYPE(value) != SVt_PVGV)
	    {
		SvFLAGS(value) |= (SvFLAGS(value) &
				  (SVp_NOK|SVp_POK)) >> PRIVSHIFT;
		SvMAGICAL_off(value);
		/* XXX this is a leak when we get here because the
		 * mg_get() in save_scalar_at() croaked */
		SvMAGIC_set(value, NULL);
	    }
	    *(SV**)ptr = value;
	    SvREFCNT_dec(sv);
	    PL_localizing = 2;
	    SvSETMAGIC(value);
	    PL_localizing = 0;
	    SvREFCNT_dec(value);
	    if (av) /* actually an av, hv or gv */
		SvREFCNT_dec(av);
	    break;
d683 1
a683 6
		AV * const goner = GvAV(gv);
		SvMAGIC_set(av, SvMAGIC(goner));
		SvFLAGS((SV*)av) |= SvMAGICAL(goner);
		SvMAGICAL_off(goner);
		SvMAGIC_set(goner, NULL);
		SvREFCNT_dec(goner);
d696 1
a696 6
		HV * const goner = GvHV(gv);
		SvMAGIC_set(hv, SvMAGIC(goner));
		SvFLAGS(hv) |= SvMAGICAL(goner);
		SvMAGICAL_off(goner);
		SvMAGIC_set(goner, NULL);
		SvREFCNT_dec(goner);
a708 4
	case SAVEt_LONG:			/* long reference */
	    ptr = SSPOPPTR;
	    *(long*)ptr = (long)SSPOPLONG;
	    break;
d715 7
d723 1
a723 12
	    break;
	case SAVEt_I16:				/* I16 reference */
	    ptr = SSPOPPTR;
	    *(I16*)ptr = (I16)SSPOPINT;
	    break;
	case SAVEt_I8:				/* I8 reference */
	    ptr = SSPOPPTR;
	    *(I8*)ptr = (I8)SSPOPINT;
	    break;
	case SAVEt_IV:				/* IV reference */
	    ptr = SSPOPPTR;
	    *(IV*)ptr = (IV)SSPOPIV;
a741 4
	case SAVEt_NSTAB:
	    gv = (GV*)SSPOPPTR;
	    (void)sv_clear((SV*)gv);
	    break;
a744 6
	    if (SvPVX_const(gv) && SvLEN(gv) > 0) {
		Safefree(SvPVX_mutable(gv));
	    }
	    SvPV_set(gv, (char *)SSPOPPTR);
	    SvCUR_set(gv, (STRLEN)SSPOPIV);
	    SvLEN_set(gv, (STRLEN)SSPOPIV);
d747 3
a749 2
	    if (GvCVu(gv))
		PL_sub_generation++;  /* putting a method back into circulation */
a799 15
		    /* Need to detach $#array from @@array that has just gone
		       out of scope. Otherwise the first $#array controls the
		       size of the array "newly" created the next time this
		       scope is entered.
		    */
		    if (AvARYLEN(sv)) {
			MAGIC *mg = mg_find (AvARYLEN(sv), PERL_MAGIC_arylen);

			if (mg) {
			    mg->mg_obj = 0;
			}

			SvREFCNT_dec(AvARYLEN(sv));
			AvARYLEN(sv) = 0;
		    }
d810 1
d813 1
a813 2
		const U32 padflags
		  = SvFLAGS(sv) & (SVs_PADBUSY|SVs_PADMY|SVs_PADTMP);
d817 1
a817 1
		default:	*(SV**)ptr = NEWSV(0,0);	break;
d820 3
a822 1
		SvFLAGS(*(SV**)ptr) |= padflags; /* preserve pad nature */
d829 1
a829 1
	    (void)hv_delete(hv, (char*)ptr, (U32)SSPOPINT, G_DISCARD);
a832 4
	case SAVEt_DESTRUCTOR:
	    ptr = SSPOPPTR;
	    (*SSPOPDPTR)(ptr);
	    break;
d846 4
d854 1
a856 1
	    ptr = av_fetch(av,i,1);
d861 1
a861 1
			(void)SvREFCNT_inc(sv);
d878 1
a878 1
			(void)SvREFCNT_inc(*(SV**)ptr);
d897 2
d902 20
d923 1
a923 1
		    
d930 1
a930 1
		PL_curpad = Null(SV**);
d943 2
a944 2
		AV* t = (AV*)SSPOPPTR;
		AV* f = (AV*)SSPOPPTR;
d949 73
d1031 1
a1039 1
	PerlIO_printf(Perl_debug_log, "BLK_OLDRETSP = %ld\n", (long)cx->blk_oldretsp);
d1057 2
d1069 2
d1083 2
d1092 2
a1093 2
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.REDO_OP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.redo_op));
d1095 1
a1095 3
		PTR2UV(cx->blk_loop.next_op));
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.LAST_OP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.last_op));
d1134 3
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d80 1
a80 1
    New(56, si, 1, PERL_SI);
d91 1
a91 1
    New(56, si->si_cxstack, cxitems, PERL_CONTEXT);
d101 1
a101 1
    IV old_max = cxstack_max;
d143 1
a143 1
    I32 oldsave = PL_scopestack[--PL_scopestack_ix];
d150 2
a151 2
    I32 oldmax = PL_markstack_max - PL_markstack;
    I32 newmax = GROW(oldmax);
d190 1
a190 1
    I32 myfloor = PL_tmps_floor;
d192 1
a192 1
	SV* sv = PL_tmps_stack[PL_tmps_ix];
d204 2
a205 2
    register SV *sv;
    SV *osv = *sptr;
a206 1
    sv = *sptr = NEWSV(0,0);
d211 1
a211 1
	    bool oldtainted = PL_tainted;
d222 1
a222 1
	SvMAGIC(sv) = SvMAGIC(osv);
d295 1
a295 1
    SvLEN(gv) = 0; /* forget that anything was allocated here */
d297 1
a297 1
    SSPUSHPTR(SvPVX(gv));
d306 1
a306 1
	Newz(602, gp, 1, GP);
d317 3
a319 1
	GvFILE(gv) = CopFILE(PL_curcop) ? CopFILE(PL_curcop) : "";
d331 1
a331 1
    AV *oav = GvAVn(gv);
d344 1
a344 1
	SvMAGIC(av) = SvMAGIC(oav);
d347 1
a347 1
	SvMAGIC(oav) = 0;
d368 1
a368 1
	SvMAGIC(hv) = SvMAGIC(ohv);
d371 1
a371 1
	SvMAGIC(ohv) = 0;
d382 1
a382 1
    register SV *sv = NEWSV(0,0);
a383 1
    sv_setsv(sv,item);
d505 2
a506 1
    return 0;
a589 1
    register SV *sv;
d593 1
a593 1
	sv = NEWSV(0,0);
d631 1
a631 1
	SvREFCNT_inc(*sptr);
d672 1
a672 1
    register I32 start = pad + ((char*)&PL_savestack[PL_savestack_ix]
d674 1
a674 1
    register I32 elems = 1 + ((size + pad - 1) / sizeof(*PL_savestack));
d757 1
a757 1
		SvMAGIC(value) = SvMAGIC(sv);
d760 1
a760 1
		SvMAGIC(sv) = 0;
d775 1
a775 1
		SvMAGIC(value) = 0;
d790 2
a791 2
		AV *goner = GvAV(gv);
		SvMAGIC(av) = SvMAGIC(goner);
d794 1
a794 1
		SvMAGIC(goner) = 0;
d808 2
a809 2
		HV *goner = GvHV(gv);
		SvMAGIC(hv) = SvMAGIC(goner);
d812 1
a812 1
		SvMAGIC(goner) = 0;
d874 2
a875 2
	    if (SvPVX(gv) && SvLEN(gv) > 0) {
		Safefree(SvPVX(gv));
d877 3
a879 3
	    SvPVX(gv) = (char *)SSPOPPTR;
	    SvCUR(gv) = (STRLEN)SSPOPIV;
	    SvLEN(gv) = (STRLEN)SSPOPIV;
d901 1
a901 1
	    Safefree((char*)ptr);
d934 15
d961 2
a962 1
		U32 padflags = SvFLAGS(sv) & (SVs_PADBUSY|SVs_PADMY|SVs_PADTMP);
d1021 1
a1021 1
		SV *oval = HeVAL((HE*)ptr);
d1059 1
a1059 1
		PADOFFSET off = (PADOFFSET)SSPOPLONG;
d1128 1
a1128 1
			  SvPVX(cx->blk_eval.old_namesv));
d1184 10
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d16 7
a939 5
		case SVt_RV:
		case SVt_IV:
		case SVt_NV:
		    (void)SvOK_off(sv);
		    break;
d941 1
a941 2
		    (void)SvOK_off(sv);
		    (void)SvOOK_off(sv);
d1047 9
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d622 3
d707 1
a707 1
	    SvREFCNT_dec(gv);
d740 1
d770 1
a771 1
	    *(SV**)ptr = value;
d776 2
d984 2
a991 1
		    SvREFCNT_dec(av);
a1008 1
		    SvREFCNT_dec(hv);
d1010 1
d1027 5
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d158 7
d287 1
a287 1
    SSCHECK(6);
d402 9
d480 1
d482 1
a482 1
    SSPUSHPTR(PL_curpad);
d563 1
d817 4
d883 1
a883 2
	    if (PL_comppad)
		PL_curpad = AvARRAY(PL_comppad);
d893 8
d1022 1
a1022 1
	    PL_comppad = (AV*)SSPOPPTR;
d1033 1
a1033 1
		    ((SV**)ptr)[off] = (SV*)SSPOPPTR;
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
a52 5
#if defined(DEBUGGING) && !defined(USE_THREADS)
    static int growing = 0;
    if (growing++)
      abort();
#endif
a58 3
#if defined(DEBUGGING) && !defined(USE_THREADS)
    growing--;
#endif
d84 3
d93 1
d96 3
d153 1
a153 1
    PL_savestack_max = GROW(PL_savestack_max) + 4; 
d179 1
a179 1
	if (sv) {
d199 2
a200 1
	    if (PL_tainting && PL_tainted && (mg = mg_find(osv, 't'))) {
d205 1
a205 1
		(SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d264 12
d472 1
a472 1
#ifdef USE_THREADS
d481 1
a481 1
#endif /* USE_THREADS */
d597 1
d604 7
d616 1
d623 7
d644 1
a644 1
                                - (char*)PL_savestack);
d649 1
a649 1
        savestack_grow();
d681 1
a681 1
        case SAVEt_SV:				/* scalar reference */
d687 1
a687 1
        case SAVEt_GENERIC_PVREF:		/* generic pv */
d695 13
a707 1
        case SAVEt_GENERIC_SVREF:		/* generic sv */
d715 1
a715 1
        case SAVEt_SVREF:			/* scalar reference */
d722 1
a722 1
			  	  ptr, sv, SvPEEK(sv), value, SvPEEK(value)));
d741 1
a741 1
				   (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d747 1
a747 1
            SvREFCNT_dec(sv);
d753 2
a754 2
            break;
        case SAVEt_AV:				/* array reference */
d765 1
a765 1
            GvAV(gv) = av;
d771 2
a772 2
            break;
        case SAVEt_HV:				/* hash reference */
d783 1
a783 1
            GvHV(gv) = hv;
d789 1
a789 1
            break;
d838 8
a845 8
            if (SvPVX(gv) && SvLEN(gv) > 0) {
                Safefree(SvPVX(gv));
            }
            SvPVX(gv) = (char *)SSPOPPTR;
            SvCUR(gv) = (STRLEN)SSPOPIV;
            SvLEN(gv) = (STRLEN)SSPOPIV;
            gp_free(gv);
            GvGP(gv) = (GP*)ptr;
d849 1
a849 1
            break;
d873 8
d882 1
a882 1
		    sv_force_normal(sv);
d933 1
a933 1
	    (*SSPOPDXPTR)(aTHXo_ ptr);
d952 1
a952 1
		    if (SvTIED_mg((SV*)av, 'P'))
d970 1
a970 1
		    if (SvTIED_mg((SV*)hv, 'P'))
d985 4
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a35 1
    dTHR;
a52 1
    dTHR;
a97 1
    dTHR;
a105 1
    dTHR;
a115 1
    dTHR;
a124 1
    dTHR;
a135 1
    dTHR;
a142 1
    dTHR;
a153 1
    dTHR;
a162 1
    dTHR;
a174 1
    dTHR;
a189 1
    dTHR;
d199 1
a199 1
	    mg_get(osv);
d210 3
a222 1
    dTHR;
a233 1
    dTHR;
d241 1
a241 1
/* Like save_svref(), but doesn't deal with magic.  Can be used to
a245 1
    dTHR;
d252 12
a266 1
    dTHR;
d291 1
a302 1
    dTHR;
a329 1
    dTHR;
a353 1
    dTHR;
a365 1
    dTHR;
a374 1
    dTHR;
a383 1
    dTHR;
a392 1
    dTHR;
a401 1
    dTHR;
a410 1
    dTHR;
a422 1
    dTHR;
a431 1
    dTHR;
a440 1
    dTHR;
d447 10
a460 1
    dTHR;
a474 1
    dTHR;
a482 1
    dTHR;
a491 1
    dTHR;
a500 1
    dTHR;
d507 8
a516 1
    dTHR;
a524 1
    dTHR;
a532 1
    dTHR;
a540 1
    dTHR;
a550 1
    dTHR;
a566 1
    dTHR;
a575 1
    dTHR;
a584 1
    dTHR;
a595 1
    dTHR;
a606 1
    dTHR;
a614 1
    dTHR;
a631 1
    dTHR;
d638 1
d659 8
d670 3
a672 5
	    if (ptr) {
		sv = *(SV**)ptr;
		*(SV**)ptr = value;
		SvREFCNT_dec(sv);
	    }
d692 5
d703 2
d814 4
a936 4
	    if (GvHV(PL_hintgv)) {
		SvREFCNT_dec((SV*)GvHV(PL_hintgv));
		GvHV(PL_hintgv) = NULL;
	    }
d946 8
a963 1
    dTHR;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d16 1
d19 32
d52 1
a52 1
stack_grow(SV **sp, SV **p, int n)
d79 1
a79 1
new_stackinfo(I32 stitems, I32 cxitems)
a81 1
    PERL_CONTEXT *cxt;
d98 1
a98 1
cxinc(void)
d107 1
a107 1
push_return(OP *retop)
d118 1
a118 1
pop_return(void)
d128 1
a128 1
push_scope(void)
d140 1
a140 1
pop_scope(void)
d148 1
a148 1
markstack_grow(void)
d160 1
a160 1
savestack_grow(void)
d170 14
a183 1
free_tmps(void)
d199 1
a199 1
save_scalar_at(SV **sptr)
d230 1
a230 1
save_scalar(GV *gv)
d242 1
a242 1
save_svref(SV **sptr)
d255 1
a255 1
save_generic_svref(SV **sptr)
d265 1
a265 1
save_gp(GV *gv, I32 empty)
d281 2
d285 4
a288 1
	Newz(602, gp, 1, GP);
d291 1
a291 1
	GvLINE(gv) = PL_curcop->cop_line;
d301 1
a301 1
save_ary(GV *gv)
d318 1
a318 1
	SvFLAGS(av) |= SvMAGICAL(oav);
d329 1
a329 1
save_hash(GV *gv)
d343 1
a343 1
	SvFLAGS(hv) |= SvMAGICAL(ohv);
d354 1
a354 1
save_item(register SV *item)
d367 1
a367 1
save_int(int *intp)
d377 1
a377 1
save_long(long int *longp)
d387 1
a387 1
save_I32(I32 *intp)
d397 1
a397 1
save_I16(I16 *intp)
d407 11
a417 1
save_iv(IV *ivp)
d430 1
a430 1
save_pptr(char **pptr)
d440 11
a450 1
save_sptr(SV **sptr)
d460 1
a460 1
save_threadsv(PADOFFSET i)
d465 2
a466 2
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "save_threadsv %u: %p %p:%s\n",
			  i, svp, *svp, SvPEEK(*svp)));
d470 1
a470 1
    croak("panic: save_threadsv called in non-threaded perl");
d476 1
a476 1
save_nogv(GV *gv)
d485 1
a485 1
save_hptr(HV **hptr)
d495 1
a495 1
save_aptr(AV **aptr)
d505 1
a505 1
save_freesv(SV *sv)
d514 1
a514 1
save_freeop(OP *o)
d523 1
a523 1
save_freepv(char *pv)
d532 1
a532 1
save_clearsv(SV **svp)
d541 1
a541 1
save_delete(HV *hv, char *key, I32 klen)
d552 1
a552 1
save_list(register SV **sarg, I32 maxsarg)
d569 1
a569 5
#ifdef PERL_OBJECT
save_destructor(DESTRUCTORFUNC f, void* p)
#else
save_destructor(void (*f) (void *), void *p)
#endif
d579 11
a589 1
save_aelem(AV *av, I32 idx, SV **sptr)
d601 1
a601 1
save_helem(HV *hv, SV *key, SV **sptr)
d613 1
a613 1
save_op(void)
d621 18
d640 1
a640 1
leave_scope(I32 base)
d652 1
a652 1
	croak("panic: corrupt saved stack index");
d684 1
a684 1
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
d717 1
a717 1
		SvFLAGS(av) |= SvMAGICAL(goner);
d763 4
d775 1
d826 2
a827 6
		if (SvTHINKFIRST(sv)) {
		    if (SvREADONLY(sv))
			croak("panic: leave_scope clearsv");
		    if (SvROK(sv))
			sv_unref(sv);
		}
d841 1
a841 1
		    croak("panic: leave_scope pad code");
d874 5
a878 1
	    (CALLDESTRUCTOR)(ptr);
d881 1
d936 7
d944 1
a944 1
	    croak("panic: leave_scope inconsistency");
d950 1
a950 1
cx_dump(PERL_CONTEXT *cx)
d954 1
a954 1
    PerlIO_printf(Perl_debug_log, "CX %ld = %s\n", (long)(cx - cxstack), block_type[CxTYPE(cx)]);
d957 2
a958 1
	PerlIO_printf(Perl_debug_log, "BLK_OLDCOP = 0x%lx\n", (long)cx->blk_oldcop);
d962 2
a963 1
	PerlIO_printf(Perl_debug_log, "BLK_OLDPM = 0x%lx\n", (long)cx->blk_oldpm);
d970 10
d981 2
a982 6
	PerlIO_printf(Perl_debug_log, "BLK_SUB.CV = 0x%lx\n",
		(long)cx->blk_sub.cv);
	PerlIO_printf(Perl_debug_log, "BLK_SUB.GV = 0x%lx\n",
		(long)cx->blk_sub.gv);
	PerlIO_printf(Perl_debug_log, "BLK_SUB.DFOUTGV = 0x%lx\n",
		(long)cx->blk_sub.dfoutgv);
d987 2
d994 7
a1000 6
		op_name[cx->blk_eval.old_op_type],
		op_desc[cx->blk_eval.old_op_type]);
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_NAME = %s\n",
		cx->blk_eval.old_name);
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_EVAL_ROOT = 0x%lx\n",
		(long)cx->blk_eval.old_eval_root);
d1008 6
a1013 6
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.REDO_OP = 0x%lx\n",
		(long)cx->blk_loop.redo_op);
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.NEXT_OP = 0x%lx\n",
		(long)cx->blk_loop.next_op);
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.LAST_OP = 0x%lx\n",
		(long)cx->blk_loop.last_op);
d1016 9
a1024 9
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERARY = 0x%lx\n",
		(long)cx->blk_loop.iterary);
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERVAR = 0x%lx\n",
		(long)cx->blk_loop.itervar);
	if (cx->blk_loop.itervar)
	    PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERSAVE = 0x%lx\n",
		(long)cx->blk_loop.itersave);
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERLVAL = 0x%lx\n",
		(long)cx->blk_loop.iterlval);
d1032 2
a1033 2
	PerlIO_printf(Perl_debug_log, "SB_SAFEBASE = %ld\n",
		(long)cx->sb_safebase);
d1038 12
a1049 12
	PerlIO_printf(Perl_debug_log, "SB_DSTR = 0x%lx\n",
		(long)cx->sb_dstr);
	PerlIO_printf(Perl_debug_log, "SB_TARG = 0x%lx\n",
		(long)cx->sb_targ);
	PerlIO_printf(Perl_debug_log, "SB_S = 0x%lx\n",
		(long)cx->sb_s);
	PerlIO_printf(Perl_debug_log, "SB_M = 0x%lx\n",
		(long)cx->sb_m);
	PerlIO_printf(Perl_debug_log, "SB_STREND = 0x%lx\n",
		(long)cx->sb_strend);
	PerlIO_printf(Perl_debug_log, "SB_RXRES = 0x%lx\n",
		(long)cx->sb_rxres);
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d19 44
a62 8
stack_grow(sp, p, n)
SV** sp;
SV** p;
int n;
{
    stack_sp = sp;
    av_extend(curstack, (p - stack_base) + (n) + 128);
    return stack_sp;
d66 1
a66 1
cxinc()
d68 3
a70 2
    cxstack_max = cxstack_max * 3 / 2;
    Renew(cxstack, cxstack_max + 1, CONTEXT);	/* XXX should fix CXINC macro */
d75 1
a75 2
push_return(retop)
OP *retop;
d77 4
a80 3
    if (retstack_ix == retstack_max) {
	retstack_max = retstack_max * 3 / 2;
	Renew(retstack, retstack_max, OP*);
d82 1
a82 1
    retstack[retstack_ix++] = retop;
d86 1
a86 1
pop_return()
d88 3
a90 2
    if (retstack_ix > 0)
	return retstack[--retstack_ix];
d96 1
a96 1
push_scope()
d98 4
a101 3
    if (scopestack_ix == scopestack_max) {
	scopestack_max = scopestack_max * 3 / 2;
	Renew(scopestack, scopestack_max, I32);
d103 1
a103 1
    scopestack[scopestack_ix++] = savestack_ix;
d108 1
a108 1
pop_scope()
d110 2
a111 1
    I32 oldsave = scopestack[--scopestack_ix];
d116 1
a116 1
markstack_grow()
d118 3
a120 2
    I32 oldmax = markstack_max - markstack;
    I32 newmax = oldmax * 3 / 2;
d122 3
a124 3
    Renew(markstack, newmax, I32);
    markstack_ptr = markstack + oldmax;
    markstack_max = markstack + newmax;
d128 1
a128 1
savestack_grow()
d130 3
a132 2
    savestack_max = savestack_max * 3 / 2;
    Renew(savestack, savestack_max, ANY);
d135 2
d138 1
a138 1
free_tmps()
d140 1
d142 4
a145 4
    I32 myfloor = tmps_floor;
    while (tmps_ix > myfloor) {      /* clean up after last statement */
	SV* sv = tmps_stack[tmps_ix];
	tmps_stack[tmps_ix--] = Nullsv;
a146 1
#ifdef DEBUGGING
a147 1
#endif
d153 2
a154 3
static SV *
save_scalar_at(sptr)
SV **sptr;
d156 1
d165 1
a165 1
	    bool oldtainted = tainted;
d167 1
a167 1
	    if (tainting && tainted && (mg = mg_find(osv, 't'))) {
d173 1
a173 1
	    tainted = oldtainted;
d177 1
a177 1
	localizing = 1;
d179 1
a179 1
	localizing = 0;
d185 1
a185 2
save_scalar(gv)
GV *gv;
d187 2
d190 2
a191 2
    SSPUSHPTR(gv);
    SSPUSHPTR(GvSV(gv));
d193 1
a193 1
    return save_scalar_at(&GvSV(gv));
d197 1
a197 2
save_svref(sptr)
SV **sptr;
d199 1
d202 1
a202 1
    SSPUSHPTR(*sptr);
d207 12
d220 1
a220 3
save_gp(gv, empty)
GV *gv;
I32 empty;
d222 1
d235 3
d241 1
a241 1
	GvLINE(gv) = curcop->cop_line;
d251 1
a251 2
save_ary(gv)
GV *gv;
d253 3
a255 1
    AV *oav, *av;
d257 2
d261 1
a261 1
    SSPUSHPTR(oav = GvAVn(gv));
d271 1
a271 1
	localizing = 1;
d273 1
a273 1
	localizing = 0;
d279 1
a279 2
save_hash(gv)
GV *gv;
d281 1
d296 1
a296 1
	localizing = 1;
d298 1
a298 1
	localizing = 0;
d304 1
a304 2
save_item(item)
register SV *item;
d306 2
a307 1
    register SV *sv;
d309 1
a311 2
    sv = NEWSV(0,0);
    sv_setsv(sv,item);
d317 1
a317 2
save_int(intp)
int *intp;
d319 1
d327 1
a327 2
save_long(longp)
long *longp;
d329 1
d337 1
a337 2
save_I32(intp)
I32 *intp;
d339 1
d347 1
a347 2
save_I16(intp)
I16 *intp;
d349 1
d357 1
a357 2
save_iv(ivp)
IV *ivp;
d359 1
d370 1
a370 2
save_pptr(pptr)
char **pptr;
d372 1
d380 1
a380 2
save_sptr(sptr)
SV **sptr;
d382 1
d389 16
d406 1
a406 2
save_nogv(gv)
GV *gv;
d408 1
d415 1
a415 2
save_hptr(hptr)
HV **hptr;
d417 1
d425 1
a425 2
save_aptr(aptr)
AV **aptr;
d427 1
d435 1
a435 2
save_freesv(sv)
SV *sv;
d437 1
d444 1
a444 2
save_freeop(op)
OP *op;
d446 1
d448 1
a448 1
    SSPUSHPTR(op);
d453 1
a453 2
save_freepv(pv)
char *pv;
d455 1
d462 1
a462 2
save_clearsv(svp)
SV** svp;
d464 1
d466 1
a466 1
    SSPUSHLONG((long)(svp-curpad));
d471 1
a471 4
save_delete(hv,key,klen)
HV *hv;
char *key;
I32 klen;
d473 1
d477 1
a477 1
    SSPUSHPTR(hv);
d482 1
a482 3
save_list(sarg,maxsarg)
register SV **sarg;
I32 maxsarg;
d484 1
a487 1
    SSCHECK(3 * maxsarg);
a488 1
	SSPUSHPTR(sarg[i]);		/* remember the pointer */
d491 2
d499 5
a503 3
save_destructor(f,p)
void (*f) _((void*));
void* p;
d505 1
d513 34
a546 2
leave_scope(base)
I32 base;
d548 1
d555 1
d559 1
a559 1
    while (savestack_ix > base) {
d565 1
a565 1
	    localizing = 2;
d567 1
a567 1
	    localizing = 0;
d573 1
d575 10
d590 3
d612 1
a612 1
	    localizing = 2;
d614 2
a615 1
	    localizing = 0;
d630 1
a630 1
		localizing = 2;
d632 1
a632 1
		localizing = 0;
d648 1
a648 1
		localizing = 2;
d650 1
a650 1
		localizing = 0;
d696 1
a696 3
            gp_free(gv);
            GvGP(gv) = (GP*)ptr;
            if (SvPOK(gv) && SvLEN(gv) > 0) {
d702 4
d714 2
a715 2
	    if (comppad)
		curpad = AvARRAY(comppad);
d723 1
a723 1
	    ptr = (void*)&curpad[SSPOPLONG];
a759 1
		SvREFCNT_dec(sv);	/* Cast current value to the winds. */
d765 1
d774 1
d779 1
a779 1
	    (*SSPOPDPTR)(ptr);
d782 20
a801 3
	    {
		I32 delta = SSPOPINT;
		savestack_ix -= delta;	/* regexp must have croaked */
d803 2
d806 27
a832 4
	case SAVEt_STACK_POS:		/* Position on Perl stack */
	    {
		I32 delta = SSPOPINT;
		stack_sp = stack_base + delta;
d834 1
a841 2
#ifdef DEBUGGING

d843 1
a843 2
cx_dump(cx)
CONTEXT* cx;
d845 4
a848 2
    PerlIO_printf(Perl_debug_log, "CX %ld = %s\n", (long)(cx - cxstack), block_type[cx->cx_type]);
    if (cx->cx_type != CXt_SUBST) {
d857 1
a857 1
    switch (cx->cx_type) {
d934 1
a935 1
#endif
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d25 1
a25 1
    av_extend(stack, (p - stack_base) + (n) + 128);
d110 3
a112 3
SV *
save_scalar(gv)
GV *gv;
d115 1
a115 1
    SV *osv = GvSV(gv);
d117 1
a117 6
    SSCHECK(3);
    SSPUSHPTR(gv);
    SSPUSHPTR(osv);
    SSPUSHINT(SAVEt_SV);

    sv = GvSV(gv) = NEWSV(0,0);
d141 2
a142 3
#ifdef INLINED_ELSEWHERE
void
save_gp(gv)
a144 3
    register GP *gp;
    GP *ogp = GvGP(gv);

d146 4
a149 10
    SSPUSHPTR(SvREFCNT_inc(gv));
    SSPUSHPTR(ogp);
    SSPUSHINT(SAVEt_GP);

    Newz(602,gp, 1, GP);
    GvGP(gv) = gp;
    GvREFCNT(gv) = 1;
    GvSV(gv) = NEWSV(72,0);
    GvLINE(gv) = curcop->cop_line;
    GvEGV(gv) = gv;
a150 1
#endif
a155 3
    register SV *sv;
    SV *osv = *sptr;

d157 1
a158 1
    SSPUSHPTR(sptr);
d160 17
d178 11
a188 20
    sv = *sptr = NEWSV(0,0);
    if (SvTYPE(osv) >= SVt_PVMG && SvMAGIC(osv) && SvTYPE(osv) != SVt_PVGV) {
	sv_upgrade(sv, SvTYPE(osv));
	if (SvGMAGICAL(osv)) {
	    MAGIC* mg;
	    bool oldtainted = tainted;
	    mg_get(osv);
	    if (tainting && tainted && (mg = mg_find(osv, 't'))) {
		SAVESPTR(mg->mg_obj);
		mg->mg_obj = osv;
	    }
	    SvFLAGS(osv) |= (SvFLAGS(osv) &
		(SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
	    tainted = oldtainted;
	}
	SvMAGIC(sv) = SvMAGIC(osv);
	SvFLAGS(sv) |= SvMAGICAL(osv);
	localizing = 1;
	SvSETMAGIC(sv);
	localizing = 0;
a189 1
    return sv;
d196 2
d200 1
a200 1
    SSPUSHPTR(GvAVn(gv));
d204 11
a214 1
    return GvAVn(gv);
d221 2
d225 1
a225 1
    SSPUSHPTR(GvHVn(gv));
d229 11
a239 1
    return GvHVn(gv);
d287 10
d462 2
a463 16
	    sv = GvSV(gv);
	    if (SvTYPE(sv) >= SVt_PVMG && SvMAGIC(sv) &&
		SvTYPE(sv) != SVt_PVGV)
	    {
		(void)SvUPGRADE(value, SvTYPE(sv));
		SvMAGIC(value) = SvMAGIC(sv);
		SvFLAGS(value) |= SvMAGICAL(sv);
		SvMAGICAL_off(sv);
		SvMAGIC(sv) = 0;
	    }
            SvREFCNT_dec(sv);
            GvSV(gv) = value;
	    localizing = 2;
	    SvSETMAGIC(value);
	    localizing = 0;
            break;
d465 1
d467 1
a468 1
	    value = (SV*)SSPOPPTR;
d478 8
d495 8
a502 1
            SvREFCNT_dec(GvAV(gv));
d504 5
d513 8
a520 1
            SvREFCNT_dec(GvHV(gv));
d522 5
d540 4
d566 1
a566 1
	    (void)sv_clear(gv);
d568 1
a568 1
        case SAVEt_GP:				/* scalar reference */
d573 6
d587 2
a588 1
	    curpad = AvARRAY(comppad);
d598 2
a599 1
	    if (SvREFCNT(sv) <= 1) { /* Can clear pad variable in place. */
d619 5
a623 2
		    sub_generation++;
		    cv_undef((CV*)sv);
a625 2
		    if (SvPOK(sv) && SvLEN(sv))
			(void)SvOOK_off(sv);
d627 1
d659 6
d672 1
d677 1
a677 1
    fprintf(stderr, "CX %d = %s\n", cx - cxstack, block_type[cx->cx_type]);
d679 7
a685 7
	fprintf(stderr, "BLK_OLDSP = %ld\n", (long)cx->blk_oldsp);
	fprintf(stderr, "BLK_OLDCOP = 0x%lx\n", (long)cx->blk_oldcop);
	fprintf(stderr, "BLK_OLDMARKSP = %ld\n", (long)cx->blk_oldmarksp);
	fprintf(stderr, "BLK_OLDSCOPESP = %ld\n", (long)cx->blk_oldscopesp);
	fprintf(stderr, "BLK_OLDRETSP = %ld\n", (long)cx->blk_oldretsp);
	fprintf(stderr, "BLK_OLDPM = 0x%lx\n", (long)cx->blk_oldpm);
	fprintf(stderr, "BLK_GIMME = %s\n", cx->blk_gimme ? "LIST" : "SCALAR");
d692 1
a692 1
	fprintf(stderr, "BLK_SUB.CV = 0x%lx\n",
d694 1
a694 1
	fprintf(stderr, "BLK_SUB.GV = 0x%lx\n",
d696 1
a696 1
	fprintf(stderr, "BLK_SUB.DFOUTGV = 0x%lx\n",
d698 1
a698 1
	fprintf(stderr, "BLK_SUB.OLDDEPTH = %ld\n",
d700 1
a700 1
	fprintf(stderr, "BLK_SUB.HASARGS = %d\n",
d704 1
a704 1
	fprintf(stderr, "BLK_EVAL.OLD_IN_EVAL = %ld\n",
d706 1
a706 1
	fprintf(stderr, "BLK_EVAL.OLD_OP_TYPE = %s (%s)\n",
d709 1
a709 1
	fprintf(stderr, "BLK_EVAL.OLD_NAME = %s\n",
d711 1
a711 1
	fprintf(stderr, "BLK_EVAL.OLD_EVAL_ROOT = 0x%lx\n",
d716 1
a716 1
	fprintf(stderr, "BLK_LOOP.LABEL = %s\n",
d718 1
a718 1
	fprintf(stderr, "BLK_LOOP.RESETSP = %ld\n",
d720 1
a720 1
	fprintf(stderr, "BLK_LOOP.REDO_OP = 0x%lx\n",
d722 1
a722 1
	fprintf(stderr, "BLK_LOOP.NEXT_OP = 0x%lx\n",
d724 1
a724 1
	fprintf(stderr, "BLK_LOOP.LAST_OP = 0x%lx\n",
d726 1
a726 1
	fprintf(stderr, "BLK_LOOP.ITERIX = %ld\n",
d728 1
a728 1
	fprintf(stderr, "BLK_LOOP.ITERARY = 0x%lx\n",
d730 1
a730 1
	fprintf(stderr, "BLK_LOOP.ITERVAR = 0x%lx\n",
d733 1
a733 1
	    fprintf(stderr, "BLK_LOOP.ITERSAVE = 0x%lx\n",
d735 2
d740 1
a740 1
	fprintf(stderr, "SB_ITERS = %ld\n",
d742 1
a742 1
	fprintf(stderr, "SB_MAXITERS = %ld\n",
d744 1
a744 1
	fprintf(stderr, "SB_SAFEBASE = %ld\n",
d746 1
a746 1
	fprintf(stderr, "SB_ONCE = %ld\n",
d748 1
a748 1
	fprintf(stderr, "SB_ORIG = %s\n",
d750 1
a750 1
	fprintf(stderr, "SB_DSTR = 0x%lx\n",
d752 1
a752 1
	fprintf(stderr, "SB_TARG = 0x%lx\n",
d754 1
a754 1
	fprintf(stderr, "SB_S = 0x%lx\n",
d756 1
a756 1
	fprintf(stderr, "SB_M = 0x%lx\n",
d758 1
a758 1
	fprintf(stderr, "SB_STREND = 0x%lx\n",
d760 2
a761 2
	fprintf(stderr, "SB_SUBBASE = 0x%lx\n",
		(long)cx->sb_subbase);
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d19 8
a26 44
stack_grow(SV **sp, SV **p, int n)
{
    dTHR;
#if defined(DEBUGGING) && !defined(USE_THREADS)
    static int growing = 0;
    if (growing++)
      abort();
#endif
    PL_stack_sp = sp;
#ifndef STRESS_REALLOC
    av_extend(PL_curstack, (p - PL_stack_base) + (n) + 128);
#else
    av_extend(PL_curstack, (p - PL_stack_base) + (n) + 1);
#endif
#if defined(DEBUGGING) && !defined(USE_THREADS)
    growing--;
#endif
    return PL_stack_sp;
}

#ifndef STRESS_REALLOC
#define GROW(old) ((old) * 3 / 2)
#else
#define GROW(old) ((old) + 1)
#endif

PERL_SI *
new_stackinfo(I32 stitems, I32 cxitems)
{
    PERL_SI *si;
    PERL_CONTEXT *cxt;
    New(56, si, 1, PERL_SI);
    si->si_stack = newAV();
    AvREAL_off(si->si_stack);
    av_extend(si->si_stack, stitems > 0 ? stitems-1 : 0);
    AvALLOC(si->si_stack)[0] = &PL_sv_undef;
    AvFILLp(si->si_stack) = 0;
    si->si_prev = 0;
    si->si_next = 0;
    si->si_cxmax = cxitems - 1;
    si->si_cxix = -1;
    si->si_type = PERLSI_UNDEF;
    New(56, si->si_cxstack, cxitems, PERL_CONTEXT);
    return si;
d30 1
a30 1
cxinc(void)
d32 2
a33 3
    dTHR;
    cxstack_max = GROW(cxstack_max);
    Renew(cxstack, cxstack_max + 1, PERL_CONTEXT);	/* XXX should fix CXINC macro */
d38 2
a39 1
push_return(OP *retop)
d41 3
a43 4
    dTHR;
    if (PL_retstack_ix == PL_retstack_max) {
	PL_retstack_max = GROW(PL_retstack_max);
	Renew(PL_retstack, PL_retstack_max, OP*);
d45 1
a45 1
    PL_retstack[PL_retstack_ix++] = retop;
d49 1
a49 1
pop_return(void)
d51 2
a52 3
    dTHR;
    if (PL_retstack_ix > 0)
	return PL_retstack[--PL_retstack_ix];
d58 1
a58 1
push_scope(void)
d60 3
a62 4
    dTHR;
    if (PL_scopestack_ix == PL_scopestack_max) {
	PL_scopestack_max = GROW(PL_scopestack_max);
	Renew(PL_scopestack, PL_scopestack_max, I32);
d64 1
a64 1
    PL_scopestack[PL_scopestack_ix++] = PL_savestack_ix;
d69 1
a69 1
pop_scope(void)
d71 1
a71 2
    dTHR;
    I32 oldsave = PL_scopestack[--PL_scopestack_ix];
d76 1
a76 1
markstack_grow(void)
d78 2
a79 3
    dTHR;
    I32 oldmax = PL_markstack_max - PL_markstack;
    I32 newmax = GROW(oldmax);
d81 3
a83 3
    Renew(PL_markstack, newmax, I32);
    PL_markstack_ptr = PL_markstack + oldmax;
    PL_markstack_max = PL_markstack + newmax;
d87 1
a87 1
savestack_grow(void)
d89 2
a90 3
    dTHR;
    PL_savestack_max = GROW(PL_savestack_max) + 4; 
    Renew(PL_savestack, PL_savestack_max, ANY);
a92 2
#undef GROW

d94 1
a94 1
free_tmps(void)
a95 1
    dTHR;
d97 4
a100 4
    I32 myfloor = PL_tmps_floor;
    while (PL_tmps_ix > myfloor) {      /* clean up after last statement */
	SV* sv = PL_tmps_stack[PL_tmps_ix];
	PL_tmps_stack[PL_tmps_ix--] = Nullsv;
d102 1
d104 1
d110 3
a112 2
STATIC SV *
save_scalar_at(SV **sptr)
a113 1
    dTHR;
d115 6
a120 1
    SV *osv = *sptr;
d122 1
a122 1
    sv = *sptr = NEWSV(0,0);
d127 1
a127 1
	    bool oldtainted = PL_tainted;
d129 1
a129 1
	    if (PL_tainting && PL_tainted && (mg = mg_find(osv, 't'))) {
d135 1
a135 1
	    PL_tainted = oldtainted;
d139 1
a139 1
	PL_localizing = 1;
d141 1
a141 1
	PL_localizing = 0;
d146 4
a149 2
SV *
save_scalar(GV *gv)
d151 3
a153 2
    dTHR;
    SV **sptr = &GvSV(gv);
d156 9
a164 3
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_SV);
    return save_scalar_at(sptr);
d166 1
d169 2
a170 1
save_svref(SV **sptr)
d172 3
a174 1
    dTHR;
d176 1
a177 1
    SSPUSHPTR(SvREFCNT_inc(*sptr));
a178 2
    return save_scalar_at(sptr);
}
d180 20
a199 40
/* Like save_svref(), but doesn't deal with magic.  Can be used to
 * restore a global SV to its prior contents, freeing new value. */
void
save_generic_svref(SV **sptr)
{
    dTHR;
    SSCHECK(3);
    SSPUSHPTR(sptr);
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_GENERIC_SVREF);
}

void
save_gp(GV *gv, I32 empty)
{
    dTHR;
    SSCHECK(6);
    SSPUSHIV((IV)SvLEN(gv));
    SvLEN(gv) = 0; /* forget that anything was allocated here */
    SSPUSHIV((IV)SvCUR(gv));
    SSPUSHPTR(SvPVX(gv));
    SvPOK_off(gv);
    SSPUSHPTR(SvREFCNT_inc(gv));
    SSPUSHPTR(GvGP(gv));
    SSPUSHINT(SAVEt_GP);

    if (empty) {
	register GP *gp;

	if (GvCVu(gv))
	    PL_sub_generation++;	/* taking a method out of circulation */
	Newz(602, gp, 1, GP);
	GvGP(gv) = gp_ref(gp);
	GvSV(gv) = NEWSV(72,0);
	GvLINE(gv) = PL_curcop->cop_line;
	GvEGV(gv) = gv;
    }
    else {
	gp_ref(GvGP(gv));
	GvINTRO_on(gv);
d201 1
d205 2
a206 1
save_ary(GV *gv)
a207 6
    dTHR;
    AV *oav = GvAVn(gv);
    AV *av;

    if (!AvREAL(oav) && AvREIFY(oav))
	av_reify(oav);
d210 1
a210 1
    SSPUSHPTR(oav);
d214 1
a214 11
    av = GvAVn(gv);
    if (SvMAGIC(oav)) {
	SvMAGIC(av) = SvMAGIC(oav);
	SvFLAGS(av) |= SvMAGICAL(oav);
	SvMAGICAL_off(oav);
	SvMAGIC(oav) = 0;
	PL_localizing = 1;
	SvSETMAGIC((SV*)av);
	PL_localizing = 0;
    }
    return av;
d218 2
a219 1
save_hash(GV *gv)
a220 3
    dTHR;
    HV *ohv, *hv;

d223 1
a223 1
    SSPUSHPTR(ohv = GvHVn(gv));
d227 1
a227 11
    hv = GvHVn(gv);
    if (SvMAGIC(ohv)) {
	SvMAGIC(hv) = SvMAGIC(ohv);
	SvFLAGS(hv) |= SvMAGICAL(ohv);
	SvMAGICAL_off(ohv);
	SvMAGIC(ohv) = 0;
	PL_localizing = 1;
	SvSETMAGIC((SV*)hv);
	PL_localizing = 0;
    }
    return hv;
d231 2
a232 1
save_item(register SV *item)
d234 1
a234 2
    dTHR;
    register SV *sv = NEWSV(0,0);
a235 1
    sv_setsv(sv,item);
d238 2
d245 2
a246 1
save_int(int *intp)
a247 1
    dTHR;
d255 2
a256 1
save_long(long int *longp)
a257 1
    dTHR;
d265 2
a266 1
save_I32(I32 *intp)
a267 1
    dTHR;
d275 2
a276 1
save_I16(I16 *intp)
a277 11
    dTHR;
    SSCHECK(3);
    SSPUSHINT(*intp);
    SSPUSHPTR(intp);
    SSPUSHINT(SAVEt_I16);
}

void
save_iv(IV *ivp)
{
    dTHR;
d288 2
a289 1
save_pptr(char **pptr)
a290 1
    dTHR;
d298 2
a299 1
save_sptr(SV **sptr)
a300 1
    dTHR;
a306 16
SV **
save_threadsv(PADOFFSET i)
{
#ifdef USE_THREADS
    dTHR;
    SV **svp = &THREADSV(i);	/* XXX Change to save by offset */
    DEBUG_S(PerlIO_printf(PerlIO_stderr(), "save_threadsv %u: %p %p:%s\n",
			  i, svp, *svp, SvPEEK(*svp)));
    save_svref(svp);
    return svp;
#else
    croak("panic: save_threadsv called in non-threaded perl");
    return 0;
#endif /* USE_THREADS */
}

d308 2
a309 1
save_nogv(GV *gv)
a310 1
    dTHR;
d317 2
a318 1
save_hptr(HV **hptr)
a319 1
    dTHR;
d327 2
a328 1
save_aptr(AV **aptr)
a329 1
    dTHR;
d337 2
a338 1
save_freesv(SV *sv)
a339 1
    dTHR;
d346 2
a347 1
save_freeop(OP *o)
a348 1
    dTHR;
d350 1
a350 1
    SSPUSHPTR(o);
d355 2
a356 1
save_freepv(char *pv)
a357 1
    dTHR;
d364 2
a365 1
save_clearsv(SV **svp)
a366 1
    dTHR;
d368 1
a368 1
    SSPUSHLONG((long)(svp-PL_curpad));
d373 4
a376 1
save_delete(HV *hv, char *key, I32 klen)
a377 1
    dTHR;
d381 1
a381 1
    SSPUSHPTR(SvREFCNT_inc(hv));
d386 3
a388 1
save_list(register SV **sarg, I32 maxsarg)
a389 1
    dTHR;
d393 1
d395 1
a397 2
	SSCHECK(3);
	SSPUSHPTR(sarg[i]);		/* remember the pointer */
d404 3
a406 5
#ifdef PERL_OBJECT
save_destructor(DESTRUCTORFUNC f, void* p)
#else
save_destructor(void (*f) (void *), void *p)
#endif
a407 1
    dTHR;
d415 2
a416 1
save_aelem(AV *av, I32 idx, SV **sptr)
a417 34
    dTHR;
    SSCHECK(4);
    SSPUSHPTR(SvREFCNT_inc(av));
    SSPUSHINT(idx);
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_AELEM);
    save_scalar_at(sptr);
}

void
save_helem(HV *hv, SV *key, SV **sptr)
{
    dTHR;
    SSCHECK(4);
    SSPUSHPTR(SvREFCNT_inc(hv));
    SSPUSHPTR(SvREFCNT_inc(key));
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_HELEM);
    save_scalar_at(sptr);
}

void
save_op(void)
{
    dTHR;
    SSCHECK(2);
    SSPUSHPTR(PL_op);
    SSPUSHINT(SAVEt_OP);
}

void
leave_scope(I32 base)
{
    dTHR;
a423 1
    I32 i;
d427 1
a427 1
    while (PL_savestack_ix > base) {
d433 1
a433 1
	    PL_localizing = 2;
d435 1
a435 1
	    PL_localizing = 0;
d440 9
a448 10
	    ptr = &GvSV(gv);
	    SvREFCNT_dec(gv);
	    goto restore_sv;
        case SAVEt_GENERIC_SVREF:		/* generic sv */
	    value = (SV*)SSPOPPTR;
	    ptr = SSPOPPTR;
	    if (ptr) {
		sv = *(SV**)ptr;
		*(SV**)ptr = value;
		SvREFCNT_dec(sv);
d450 6
a455 2
	    SvREFCNT_dec(value);
	    break;
a456 1
	    value = (SV*)SSPOPPTR;
a457 1
	restore_sv:
d459 1
a459 3
	    DEBUG_S(PerlIO_printf(PerlIO_stderr(),
				  "restore svref: %p %p:%s -> %p:%s\n",
			  	  ptr, sv, SvPEEK(sv), value, SvPEEK(value)));
a468 8
	    else if (SvTYPE(value) >= SVt_PVMG && SvMAGIC(value) &&
		     SvTYPE(value) != SVt_PVGV)
	    {
		SvFLAGS(value) |= (SvFLAGS(value) &
				   (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
		SvMAGICAL_off(value);
		SvMAGIC(value) = 0;
	    }
d471 1
a471 1
	    PL_localizing = 2;
d473 1
a473 2
	    PL_localizing = 0;
	    SvREFCNT_dec(value);
d478 1
a478 8
	    if (GvAV(gv)) {
		AV *goner = GvAV(gv);
		SvMAGIC(av) = SvMAGIC(goner);
		SvFLAGS(av) |= SvMAGICAL(goner);
		SvMAGICAL_off(goner);
		SvMAGIC(goner) = 0;
		SvREFCNT_dec(goner);
	    }
a479 5
	    if (SvMAGICAL(av)) {
		PL_localizing = 2;
		SvSETMAGIC((SV*)av);
		PL_localizing = 0;
	    }
d484 1
a484 8
	    if (GvHV(gv)) {
		HV *goner = GvHV(gv);
		SvMAGIC(hv) = SvMAGIC(goner);
		SvFLAGS(hv) |= SvMAGICAL(goner);
		SvMAGICAL_off(goner);
		SvMAGIC(goner) = 0;
		SvREFCNT_dec(goner);
	    }
a485 5
	    if (SvMAGICAL(hv)) {
		PL_localizing = 2;
		SvSETMAGIC((SV*)hv);
		PL_localizing = 0;
	    }
a498 4
	case SAVEt_I16:				/* I16 reference */
	    ptr = SSPOPPTR;
	    *(I16*)ptr = (I16)SSPOPINT;
	    break;
d521 1
a521 1
	    (void)sv_clear((SV*)gv);
d523 1
a523 1
	case SAVEt_GP:				/* scalar reference */
a525 6
            if (SvPVX(gv) && SvLEN(gv) > 0) {
                Safefree(SvPVX(gv));
            }
            SvPVX(gv) = (char *)SSPOPPTR;
            SvCUR(gv) = (STRLEN)SSPOPIV;
            SvLEN(gv) = (STRLEN)SSPOPIV;
a527 2
	    if (GvCVu(gv))
		PL_sub_generation++;  /* putting a method back into circulation */
d536 1
a536 2
	    if (PL_comppad)
		PL_curpad = AvARRAY(PL_comppad);
d544 1
a544 1
	    ptr = (void*)&PL_curpad[SSPOPLONG];
d546 1
a546 2
	    /* Can clear pad variable in place? */
	    if (SvREFCNT(sv) <= 1 && !SvOBJECT(sv)) {
d566 2
a567 5
		    croak("panic: leave_scope pad code");
		case SVt_RV:
		case SVt_IV:
		case SVt_NV:
		    (void)SvOK_off(sv);
d570 2
a572 1
		    (void)SvOOK_off(sv);
d578 1
a583 1
		SvREFCNT_dec(sv);	/* Cast current value to the winds. */
a591 1
	    SvREFCNT_dec(hv);
d596 1
a596 1
	    (CALLDESTRUCTOR)(ptr);
d599 3
a601 20
	    i = SSPOPINT;
	    PL_savestack_ix -= i;  	/* regexp must have croaked */
	    break;
	case SAVEt_STACK_POS:		/* Position on Perl stack */
	    i = SSPOPINT;
	    PL_stack_sp = PL_stack_base + i;
	    break;
	case SAVEt_AELEM:		/* array element */
	    value = (SV*)SSPOPPTR;
	    i = SSPOPINT;
	    av = (AV*)SSPOPPTR;
	    ptr = av_fetch(av,i,1);
	    if (ptr) {
		sv = *(SV**)ptr;
		if (sv && sv != &PL_sv_undef) {
		    if (SvTIED_mg((SV*)av, 'P'))
			(void)SvREFCNT_inc(sv);
		    SvREFCNT_dec(av);
		    goto restore_sv;
		}
a602 32
	    SvREFCNT_dec(av);
	    SvREFCNT_dec(value);
	    break;
	case SAVEt_HELEM:		/* hash element */
	    value = (SV*)SSPOPPTR;
	    sv = (SV*)SSPOPPTR;
	    hv = (HV*)SSPOPPTR;
	    ptr = hv_fetch_ent(hv, sv, 1, 0);
	    if (ptr) {
		SV *oval = HeVAL((HE*)ptr);
		if (oval && oval != &PL_sv_undef) {
		    ptr = &HeVAL((HE*)ptr);
		    if (SvTIED_mg((SV*)hv, 'P'))
			(void)SvREFCNT_inc(*(SV**)ptr);
		    SvREFCNT_dec(hv);
		    SvREFCNT_dec(sv);
		    goto restore_sv;
		}
	    }
	    SvREFCNT_dec(hv);
	    SvREFCNT_dec(sv);
	    SvREFCNT_dec(value);
	    break;
	case SAVEt_OP:
	    PL_op = (OP*)SSPOPPTR;
	    break;
	case SAVEt_HINTS:
	    if (GvHV(PL_hintgv)) {
		SvREFCNT_dec((SV*)GvHV(PL_hintgv));
		GvHV(PL_hintgv) = NULL;
	    }
	    *(I32*)&PL_hints = (I32)SSPOPINT;
d610 1
d612 2
a613 1
cx_dump(PERL_CONTEXT *cx)
d615 9
a623 11
#ifdef DEBUGGING
    dTHR;
    PerlIO_printf(Perl_debug_log, "CX %ld = %s\n", (long)(cx - cxstack), block_type[CxTYPE(cx)]);
    if (CxTYPE(cx) != CXt_SUBST) {
	PerlIO_printf(Perl_debug_log, "BLK_OLDSP = %ld\n", (long)cx->blk_oldsp);
	PerlIO_printf(Perl_debug_log, "BLK_OLDCOP = 0x%lx\n", (long)cx->blk_oldcop);
	PerlIO_printf(Perl_debug_log, "BLK_OLDMARKSP = %ld\n", (long)cx->blk_oldmarksp);
	PerlIO_printf(Perl_debug_log, "BLK_OLDSCOPESP = %ld\n", (long)cx->blk_oldscopesp);
	PerlIO_printf(Perl_debug_log, "BLK_OLDRETSP = %ld\n", (long)cx->blk_oldretsp);
	PerlIO_printf(Perl_debug_log, "BLK_OLDPM = 0x%lx\n", (long)cx->blk_oldpm);
	PerlIO_printf(Perl_debug_log, "BLK_GIMME = %s\n", cx->blk_gimme ? "LIST" : "SCALAR");
d625 1
a625 1
    switch (CxTYPE(cx)) {
d630 1
a630 1
	PerlIO_printf(Perl_debug_log, "BLK_SUB.CV = 0x%lx\n",
d632 1
a632 1
	PerlIO_printf(Perl_debug_log, "BLK_SUB.GV = 0x%lx\n",
d634 1
a634 1
	PerlIO_printf(Perl_debug_log, "BLK_SUB.DFOUTGV = 0x%lx\n",
d636 1
a636 1
	PerlIO_printf(Perl_debug_log, "BLK_SUB.OLDDEPTH = %ld\n",
d638 1
a638 1
	PerlIO_printf(Perl_debug_log, "BLK_SUB.HASARGS = %d\n",
d642 1
a642 1
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_IN_EVAL = %ld\n",
d644 1
a644 1
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_OP_TYPE = %s (%s)\n",
d647 1
a647 1
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_NAME = %s\n",
d649 1
a649 1
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_EVAL_ROOT = 0x%lx\n",
d654 1
a654 1
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.LABEL = %s\n",
d656 1
a656 1
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.RESETSP = %ld\n",
d658 1
a658 1
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.REDO_OP = 0x%lx\n",
d660 1
a660 1
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.NEXT_OP = 0x%lx\n",
d662 1
a662 1
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.LAST_OP = 0x%lx\n",
d664 1
a664 1
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERIX = %ld\n",
d666 1
a666 1
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERARY = 0x%lx\n",
d668 1
a668 1
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERVAR = 0x%lx\n",
d671 1
a671 1
	    PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERSAVE = 0x%lx\n",
a672 2
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERLVAL = 0x%lx\n",
		(long)cx->blk_loop.iterlval);
d676 1
a676 1
	PerlIO_printf(Perl_debug_log, "SB_ITERS = %ld\n",
d678 1
a678 1
	PerlIO_printf(Perl_debug_log, "SB_MAXITERS = %ld\n",
d680 1
a680 1
	PerlIO_printf(Perl_debug_log, "SB_SAFEBASE = %ld\n",
d682 1
a682 1
	PerlIO_printf(Perl_debug_log, "SB_ONCE = %ld\n",
d684 1
a684 1
	PerlIO_printf(Perl_debug_log, "SB_ORIG = %s\n",
d686 1
a686 1
	PerlIO_printf(Perl_debug_log, "SB_DSTR = 0x%lx\n",
d688 1
a688 1
	PerlIO_printf(Perl_debug_log, "SB_TARG = 0x%lx\n",
d690 1
a690 1
	PerlIO_printf(Perl_debug_log, "SB_S = 0x%lx\n",
d692 1
a692 1
	PerlIO_printf(Perl_debug_log, "SB_M = 0x%lx\n",
d694 1
a694 1
	PerlIO_printf(Perl_debug_log, "SB_STREND = 0x%lx\n",
d696 2
a697 2
	PerlIO_printf(Perl_debug_log, "SB_RXRES = 0x%lx\n",
		(long)cx->sb_rxres);
a699 1
#endif	/* DEBUGGING */
d701 1
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a15 1
#define PERL_IN_SCOPE_C
a17 32
#if defined(PERL_FLEXIBLE_EXCEPTIONS)
void *
Perl_default_protect(pTHX_ volatile JMPENV *pcur_env, int *excpt,
		     protect_body_t body, ...)
{
    void *ret;
    va_list args;
    va_start(args, body);
    ret = vdefault_protect(pcur_env, excpt, body, &args);
    va_end(args);
    return ret;
}

void *
Perl_vdefault_protect(pTHX_ volatile JMPENV *pcur_env, int *excpt,
		      protect_body_t body, va_list *args)
{
    dTHR;
    int ex;
    void *ret;

    JMPENV_PUSH(ex);
    if (ex)
	ret = NULL;
    else
	ret = CALL_FPTR(body)(aTHX_ *args);
    *excpt = ex;
    JMPENV_POP;
    return ret;
}
#endif

d19 1
a19 1
Perl_stack_grow(pTHX_ SV **sp, SV **p, int n)
d46 1
a46 1
Perl_new_stackinfo(pTHX_ I32 stitems, I32 cxitems)
d49 1
d66 1
a66 1
Perl_cxinc(pTHX)
d75 1
a75 1
Perl_push_return(pTHX_ OP *retop)
d86 1
a86 1
Perl_pop_return(pTHX)
d96 1
a96 1
Perl_push_scope(pTHX)
d108 1
a108 1
Perl_pop_scope(pTHX)
d116 1
a116 1
Perl_markstack_grow(pTHX)
d128 1
a128 1
Perl_savestack_grow(pTHX)
d138 1
a138 14
Perl_tmps_grow(pTHX_ I32 n)
{
    dTHR;
#ifndef STRESS_REALLOC
    if (n < 128)
	n = (PL_tmps_max < 512) ? 128 : 512;
#endif
    PL_tmps_max = PL_tmps_ix + n + 1;
    Renew(PL_tmps_stack, PL_tmps_max, SV*);
}


void
Perl_free_tmps(pTHX)
d154 1
a154 1
S_save_scalar_at(pTHX_ SV **sptr)
d185 1
a185 1
Perl_save_scalar(pTHX_ GV *gv)
d197 1
a197 1
Perl_save_svref(pTHX_ SV **sptr)
d210 1
a210 1
Perl_save_generic_svref(pTHX_ SV **sptr)
d220 1
a220 1
Perl_save_gp(pTHX_ GV *gv, I32 empty)
a235 2
	Newz(602, gp, 1, GP);

d238 1
a238 4
	if (GvIOp(gv) && (IoFLAGS(GvIOp(gv)) & IOf_ARGV)) {
	    gp->gp_io = newIO();
	    IoFLAGS(gp->gp_io) |= IOf_ARGV|IOf_START;
	}
d241 1
a241 1
	GvLINE(gv) = CopLINE(PL_curcop);
d251 1
a251 1
Perl_save_ary(pTHX_ GV *gv)
d268 1
a268 1
	SvFLAGS((SV*)av) |= SvMAGICAL(oav);
d279 1
a279 1
Perl_save_hash(pTHX_ GV *gv)
d293 1
a293 1
	SvFLAGS((SV*)hv) |= SvMAGICAL(ohv);
d304 1
a304 1
Perl_save_item(pTHX_ register SV *item)
d317 1
a317 1
Perl_save_int(pTHX_ int *intp)
d327 1
a327 1
Perl_save_long(pTHX_ long int *longp)
d337 1
a337 1
Perl_save_I32(pTHX_ I32 *intp)
d347 1
a347 1
Perl_save_I16(pTHX_ I16 *intp)
d357 1
a357 11
Perl_save_I8(pTHX_ I8 *bytep)
{
    dTHR;
    SSCHECK(3);
    SSPUSHINT(*bytep);
    SSPUSHPTR(bytep);
    SSPUSHINT(SAVEt_I8);
}

void
Perl_save_iv(pTHX_ IV *ivp)
d370 1
a370 1
Perl_save_pptr(pTHX_ char **pptr)
d380 1
a380 11
Perl_save_vptr(pTHX_ void *ptr)
{
    dTHR;
    SSCHECK(3);
    SSPUSHPTR(*(char**)ptr);
    SSPUSHPTR(ptr);
    SSPUSHINT(SAVEt_VPTR);
}

void
Perl_save_sptr(pTHX_ SV **sptr)
d390 1
a390 1
Perl_save_threadsv(pTHX_ PADOFFSET i)
d395 2
a396 2
    DEBUG_S(PerlIO_printf(Perl_debug_log, "save_threadsv %"UVuf": %p %p:%s\n",
			  (UV)i, svp, *svp, SvPEEK(*svp)));
d400 1
a400 1
    Perl_croak(aTHX_ "panic: save_threadsv called in non-threaded perl");
d406 1
a406 1
Perl_save_nogv(pTHX_ GV *gv)
d415 1
a415 1
Perl_save_hptr(pTHX_ HV **hptr)
d425 1
a425 1
Perl_save_aptr(pTHX_ AV **aptr)
d435 1
a435 1
Perl_save_freesv(pTHX_ SV *sv)
d444 1
a444 1
Perl_save_freeop(pTHX_ OP *o)
d453 1
a453 1
Perl_save_freepv(pTHX_ char *pv)
d462 1
a462 1
Perl_save_clearsv(pTHX_ SV **svp)
d471 1
a471 1
Perl_save_delete(pTHX_ HV *hv, char *key, I32 klen)
d482 1
a482 1
Perl_save_list(pTHX_ register SV **sarg, I32 maxsarg)
d499 5
a503 1
Perl_save_destructor(pTHX_ DESTRUCTORFUNC_NOCONTEXT_t f, void* p)
d513 1
a513 11
Perl_save_destructor_x(pTHX_ DESTRUCTORFUNC_t f, void* p)
{
    dTHR;
    SSCHECK(3);
    SSPUSHDXPTR(f);
    SSPUSHPTR(p);
    SSPUSHINT(SAVEt_DESTRUCTOR_X);
}

void
Perl_save_aelem(pTHX_ AV *av, I32 idx, SV **sptr)
d525 1
a525 1
Perl_save_helem(pTHX_ HV *hv, SV *key, SV **sptr)
d537 1
a537 1
Perl_save_op(pTHX)
a544 18
I32
Perl_save_alloc(pTHX_ I32 size, I32 pad)
{
    dTHR;
    register I32 start = pad + ((char*)&PL_savestack[PL_savestack_ix]
                                - (char*)PL_savestack);
    register I32 elems = 1 + ((size + pad - 1) / sizeof(*PL_savestack));

    /* SSCHECK may not be good enough */
    while (PL_savestack_ix + elems + 2 > PL_savestack_max)
        savestack_grow();

    PL_savestack_ix += elems;
    SSPUSHINT(elems);
    SSPUSHINT(SAVEt_ALLOC);
    return start;
}

d546 1
a546 1
Perl_leave_scope(pTHX_ I32 base)
d558 1
a558 1
	Perl_croak(aTHX_ "panic: corrupt saved stack index");
d590 1
a590 1
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
d623 1
a623 1
		SvFLAGS((SV*)av) |= SvMAGICAL(goner);
a668 4
	case SAVEt_I8:				/* I8 reference */
	    ptr = SSPOPPTR;
	    *(I8*)ptr = (I8)SSPOPINT;
	    break;
a676 1
	case SAVEt_VPTR:			/* random* reference */
d727 6
a732 2
		if (SvTHINKFIRST(sv))
		    sv_force_normal(sv);
d746 1
a746 1
		    Perl_croak(aTHX_ "panic: leave_scope pad code");
d779 1
a779 5
	    (*SSPOPDPTR)(ptr);
	    break;
	case SAVEt_DESTRUCTOR_X:
	    ptr = SSPOPPTR;
	    (*SSPOPDXPTR)(aTHXo_ ptr);
a781 1
	case SAVEt_ALLOC:
a835 7
	case SAVEt_COMPPAD:
	    PL_comppad = (AV*)SSPOPPTR;
	    if (PL_comppad)
		PL_curpad = AvARRAY(PL_comppad);
	    else
		PL_curpad = Null(SV**);
	    break;
d837 1
a837 1
	    Perl_croak(aTHX_ "panic: leave_scope inconsistency");
d843 1
a843 1
Perl_cx_dump(pTHX_ PERL_CONTEXT *cx)
d847 1
a847 1
    PerlIO_printf(Perl_debug_log, "CX %ld = %s\n", (long)(cx - cxstack), PL_block_type[CxTYPE(cx)]);
d850 1
a850 2
	PerlIO_printf(Perl_debug_log, "BLK_OLDCOP = 0x%"UVxf"\n",
		      PTR2UV(cx->blk_oldcop));
d854 1
a854 2
	PerlIO_printf(Perl_debug_log, "BLK_OLDPM = 0x%"UVxf"\n",
		      PTR2UV(cx->blk_oldpm));
a860 10
    case CXt_FORMAT:
	PerlIO_printf(Perl_debug_log, "BLK_SUB.CV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.cv));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.GV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.gv));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.DFOUTGV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.dfoutgv));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.HASARGS = %d\n",
		(int)cx->blk_sub.hasargs);
	break;
d862 6
a867 2
	PerlIO_printf(Perl_debug_log, "BLK_SUB.CV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.cv));
a871 2
	PerlIO_printf(Perl_debug_log, "BLK_SUB.LVAL = %d\n",
		(int)cx->blk_sub.lval);
d877 6
a882 7
		PL_op_name[cx->blk_eval.old_op_type],
		PL_op_desc[cx->blk_eval.old_op_type]);
	if (cx->blk_eval.old_namesv)
	    PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_NAME = %s\n",
			  SvPVX(cx->blk_eval.old_namesv));
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.OLD_EVAL_ROOT = 0x%"UVxf"\n",
		PTR2UV(cx->blk_eval.old_eval_root));
d890 6
a895 6
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.REDO_OP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.redo_op));
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.NEXT_OP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.next_op));
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.LAST_OP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.last_op));
d898 9
a906 9
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERARY = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.iterary));
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERVAR = 0x%"UVxf"\n",
		PTR2UV(CxITERVAR(cx)));
	if (CxITERVAR(cx))
	    PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERSAVE = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.itersave));
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERLVAL = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.iterlval));
d914 2
a915 2
	PerlIO_printf(Perl_debug_log, "SB_RFLAGS = %ld\n",
		(long)cx->sb_rflags);
d920 12
a931 12
	PerlIO_printf(Perl_debug_log, "SB_DSTR = 0x%"UVxf"\n",
		PTR2UV(cx->sb_dstr));
	PerlIO_printf(Perl_debug_log, "SB_TARG = 0x%"UVxf"\n",
		PTR2UV(cx->sb_targ));
	PerlIO_printf(Perl_debug_log, "SB_S = 0x%"UVxf"\n",
		PTR2UV(cx->sb_s));
	PerlIO_printf(Perl_debug_log, "SB_M = 0x%"UVxf"\n",
		PTR2UV(cx->sb_m));
	PerlIO_printf(Perl_debug_log, "SB_STREND = 0x%"UVxf"\n",
		PTR2UV(cx->sb_strend));
	PerlIO_printf(Perl_debug_log, "SB_RXRES = 0x%"UVxf"\n",
		PTR2UV(cx->sb_rxres));
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d36 1
d54 1
d100 1
d109 1
d120 1
d130 1
d142 1
d150 1
d162 1
d172 1
d185 1
d201 1
d211 1
a211 1
	    mg_get(osv);		/* note, can croak! */
a221 3
	/* XXX SvMAGIC() is *shared* between osv and sv.  This can
	 * lead to coredumps when both SVs are destroyed without one
	 * of their SvMAGIC() slots being NULLed. */
d232 1
d244 1
d252 1
a252 1
/* Like save_sptr(), but also SvREFCNT_dec()s the new value.  Can be used to
d257 1
a263 12
/* Like save_pptr(), but also Safefree()s the new value if it is different
 * from the old one.  Can be used to restore a global char* to its prior
 * contents, freeing new value. */
void
Perl_save_generic_pvref(pTHX_ char **str)
{
    SSCHECK(3);
    SSPUSHPTR(str);
    SSPUSHPTR(*str);
    SSPUSHINT(SAVEt_GENERIC_PVREF);
}

d267 1
a291 1
	GvFILE(gv) = CopFILE(PL_curcop) ? CopFILE(PL_curcop) : "";
d303 1
d331 1
d356 1
d369 1
d379 1
d389 1
d399 1
d409 1
d419 1
d432 1
d442 1
d452 1
a458 10
void
Perl_save_padsv(pTHX_ PADOFFSET off)
{
    SSCHECK(4);
    SSPUSHPTR(PL_curpad[off]);
    SSPUSHPTR(PL_curpad);
    SSPUSHLONG((long)off);
    SSPUSHINT(SAVEt_PADSV);
}

d463 1
d478 1
d487 1
d497 1
d507 1
a513 8
Perl_save_mortalizesv(pTHX_ SV *sv)
{
    SSCHECK(2);
    SSPUSHPTR(sv);
    SSPUSHINT(SAVEt_MORTALIZESV);
}

void
d516 1
d525 1
d534 1
d543 1
d554 1
d571 1
d581 1
d591 1
d603 1
d615 1
d624 1
d642 1
a648 1
    register char* str;
a668 8
        case SAVEt_GENERIC_PVREF:		/* generic pv */
	    str = (char*)SSPOPPTR;
	    ptr = SSPOPPTR;
	    if (*(char**)ptr != str) {
		Safefree(*(char**)ptr);
		*(char**)ptr = str;
	    }
	    break;
d672 5
a676 3
	    sv = *(SV**)ptr;
	    *(SV**)ptr = value;
	    SvREFCNT_dec(sv);
a695 5
	    /* XXX This branch is pretty bogus.  This code irretrievably
	     * clears(!) the magic on the SV (either to avoid further
	     * croaking that might ensue when the SvSETMAGIC() below is
	     * called, or to avoid two different SVs pointing at the same
	     * SvMAGIC()).  This needs a total rethink.  --GSAR */
a701 2
		/* XXX this is a leak when we get here because the
		 * mg_get() in save_scalar_at() croaked */
a810 4
	case SAVEt_MORTALIZESV:
	    ptr = SSPOPPTR;
	    sv_2mortal((SV*)ptr);
	    break;
d930 4
a942 8
	case SAVEt_PADSV:
	    {
		PADOFFSET off = (PADOFFSET)SSPOPLONG;
		ptr = SSPOPPTR;
		if (ptr)
		    ((SV**)ptr)[off] = (SV*)SSPOPPTR;
	    }
	    break;
d953 1
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d53 5
d64 3
a91 3
    /* Without any kind of initialising PUSHSUBST()
     * in pp_subst() will read uninitialised heap. */
    Poison(si->si_cxstack, cxitems, PERL_CONTEXT);
a97 1
    IV old_max = cxstack_max;
a99 3
    /* Without any kind of initialising deep enough recursion
     * will end up reading uninitialised PERL_CONTEXTs. */
    Poison(cxstack + old_max + 1, cxstack_max - old_max, PERL_CONTEXT);
d154 1
a154 1
    PL_savestack_max = GROW(PL_savestack_max) + 4;
d180 1
a180 1
	if (sv && sv != &PL_sv_undef) {
d200 1
a200 2
	    if (PL_tainting && PL_tainted &&
			(mg = mg_find(osv, PERL_MAGIC_taint))) {
d205 1
a205 1
	       (SVp_NOK|SVp_POK)) >> PRIVSHIFT;
a263 12
/* Like save_generic_pvref(), but uses PerlMemShared_free() rather than Safefree().
 * Can be used to restore a shared global char* to its prior
 * contents, freeing new value. */
void
Perl_save_shared_pvref(pTHX_ char **str)
{
    SSCHECK(3);
    SSPUSHPTR(str);
    SSPUSHPTR(*str);
    SSPUSHINT(SAVEt_SHARED_PVREF);
}

d460 1
a460 1
#ifdef USE_5005THREADS
d469 1
a469 1
#endif /* USE_5005THREADS */
a584 1
    SV *sv;
a590 7
    sv = *sptr;
    /* If we're localizing a tied array element, this new sv
     * won't actually be stored in the array - so it won't get
     * reaped when the localize ends. Ensure it gets reaped by
     * mortifying it instead. DAPM */
    if (SvTIED_mg(sv, PERL_MAGIC_tiedelem))
	sv_2mortal(sv);
a595 1
    SV *sv;
a601 7
    sv = *sptr;
    /* If we're localizing a tied hash element, this new sv
     * won't actually be stored in the hash - so it won't get
     * reaped when the localize ends. Ensure it gets reaped by
     * mortifying it instead. DAPM */
    if (SvTIED_mg(sv, PERL_MAGIC_tiedelem))
	sv_2mortal(sv);
d616 1
a616 1
				- (char*)PL_savestack);
d621 1
a621 1
	savestack_grow();
d653 1
a653 1
	case SAVEt_SV:				/* scalar reference */
d659 1
a659 1
	case SAVEt_GENERIC_PVREF:		/* generic pv */
d667 1
a667 13
	case SAVEt_SHARED_PVREF:		/* shared pv */
	    str = (char*)SSPOPPTR;
	    ptr = SSPOPPTR;
	    if (*(char**)ptr != str) {
#ifdef NETWARE
		PerlMem_free(*(char**)ptr);
#else
		PerlMemShared_free(*(char**)ptr);
#endif
		*(char**)ptr = str;
	    }
	    break;
	case SAVEt_GENERIC_SVREF:		/* generic sv */
d675 1
a675 1
	case SAVEt_SVREF:			/* scalar reference */
d682 1
a682 1
				  ptr, sv, SvPEEK(sv), value, SvPEEK(value)));
d701 1
a701 1
				  (SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d707 1
a707 1
	    SvREFCNT_dec(sv);
d713 2
a714 2
	    break;
	case SAVEt_AV:				/* array reference */
d725 1
a725 1
	    GvAV(gv) = av;
d731 2
a732 2
	    break;
	case SAVEt_HV:				/* hash reference */
d743 1
a743 1
	    GvHV(gv) = hv;
d749 1
a749 1
	    break;
d798 8
a805 8
	    if (SvPVX(gv) && SvLEN(gv) > 0) {
		Safefree(SvPVX(gv));
	    }
	    SvPVX(gv) = (char *)SSPOPPTR;
	    SvCUR(gv) = (STRLEN)SSPOPIV;
	    SvLEN(gv) = (STRLEN)SSPOPIV;
	    gp_free(gv);
	    GvGP(gv) = (GP*)ptr;
d809 1
a809 1
	    break;
a832 8
		/*
		 * if a my variable that was made readonly is going out of
		 * scope, we want to remove the readonlyness so that it can
		 * go out of scope quietly
		 */
		if (SvPADMY(sv) && !SvFAKE(sv))
		    SvREADONLY_off(sv);

d834 1
a834 1
		    sv_force_normal_flags(sv, SV_IMMEDIATE_UNREF);
d885 1
a885 1
	    (*SSPOPDXPTR)(aTHX_ ptr);
d904 1
a904 1
		    if (SvTIED_mg((SV*)av, PERL_MAGIC_tied))
d922 1
a922 1
		    if (SvTIED_mg((SV*)hv, PERL_MAGIC_tied))
a936 4
	    if ((PL_hints & HINT_LOCALIZE_HH) && GvHV(PL_hintgv)) {
		SvREFCNT_dec((SV*)GvHV(PL_hintgv));
		GvHV(PL_hintgv) = NULL;
	    }
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
a156 7
void
Perl_savestack_grow_cnt(pTHX_ I32 need)
{
    PL_savestack_max = PL_savestack_ix + need;
    Renew(PL_savestack, PL_savestack_max, ANY);
}

d279 1
a279 1
    SSGROW(6);
a393 9
Perl_save_bool(pTHX_ bool *boolp)
{
    SSCHECK(3);
    SSPUSHBOOL(*boolp);
    SSPUSHPTR(boolp);
    SSPUSHINT(SAVEt_BOOL);
}

void
a462 1
    ASSERT_CURPAD_ACTIVE("save_padsv");
d464 1
a464 1
    SSPUSHPTR(PL_comppad);
a544 1
    ASSERT_CURPAD_ACTIVE("save_clearsv");
a797 4
	case SAVEt_BOOL:			/* bool reference */
	    ptr = SSPOPPTR;
	    *(bool*)ptr = (bool)SSPOPBOOL;
	    break;
d860 2
a861 1
	    ASSERT_CURPAD_LEGAL("SAVEt_FREEOP"); /* XXX DAPM tmp */
a870 8

	    DEBUG_Xv(PerlIO_printf(Perl_debug_log,
	     "Pad 0x%"UVxf"[0x%"UVxf"] clearsv: %ld sv=0x%"UVxf"<%"IVdf"> %s\n",
		PTR2UV(PL_comppad), PTR2UV(PL_curpad),
		(long)((SV **)ptr-PL_curpad), PTR2UV(sv), (IV)SvREFCNT(sv),
		(SvREFCNT(sv) <= 1 && !SvOBJECT(sv)) ? "clear" : "abandon"
	    ));

d992 1
a992 1
	    PL_comppad = (PAD*)SSPOPPTR;
d1003 1
a1003 1
		    AvARRAY((PAD*)ptr)[off] = (SV*)SSPOPPTR;
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a621 3
    /* if it gets reified later, the restore will have the wrong refcnt */
    if (!AvREAL(av) && AvREIFY(av))
	SvREFCNT_inc(*sptr);
d704 1
a704 1
	    av = (AV*)gv; /* what to refcnt_dec */
a736 1
	    av = Nullav; /* what to refcnt_dec */
d766 1
a767 1
	    SvREFCNT_dec(sv);
a771 2
	    if (av) /* actually an av, hv or gv */
		SvREFCNT_dec(av);
a977 2
	    if (!AvREAL(av) && AvREIFY(av)) /* undo reify guard */
		SvREFCNT_dec(value);
d984 1
d1002 1
a1003 1
		    av = (AV*)hv; /* what to refcnt_dec */
a1019 5
	    if (PL_hints & HINT_LOCALIZE_HH) {
		SvREFCNT_dec((SV*)GvHV(PL_hintgv));
		GvHV(PL_hintgv) = (HV*)SSPOPPTR;
	    }
		    
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a15 7
/* This file contains functions to manipulate several of Perl's stacks;
 * in particular it contains code to push various types of things onto
 * the savestack, then to pop them off and perform the correct restorative
 * action for each one. This corresponds to the cleanup Perl does at
 * each scope exit.
 */

d933 5
d939 2
a940 1
		    SvOK_off(sv);
a1045 9
	    }
	    break;
	case SAVEt_SAVESWITCHSTACK:
	    {
		dSP;
		AV* t = (AV*)SSPOPPTR;
		AV* f = (AV*)SSPOPPTR;
		SWITCHSTACK(t,f);
		PL_curstackinfo->si_stack = f;
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, by Larry Wall and others
d80 1
a80 1
    Newx(si, 1, PERL_SI);
d91 1
a91 1
    Newx(si->si_cxstack, cxitems, PERL_CONTEXT);
d101 1
a101 1
    const IV old_max = cxstack_max;
d143 1
a143 1
    const I32 oldsave = PL_scopestack[--PL_scopestack_ix];
d150 2
a151 2
    const I32 oldmax = PL_markstack_max - PL_markstack;
    const I32 newmax = GROW(oldmax);
d190 1
a190 1
    const I32 myfloor = PL_tmps_floor;
d192 1
a192 1
	SV* const sv = PL_tmps_stack[PL_tmps_ix];
d204 2
a205 2
    SV * const osv = *sptr;
    register SV * const sv = *sptr = NEWSV(0,0);
d207 1
d212 1
a212 1
	    const bool oldtainted = PL_tainted;
d223 1
a223 1
	SvMAGIC_set(sv, SvMAGIC(osv));
d296 1
a296 1
    SvLEN_set(gv, 0); /* forget that anything was allocated here */
d298 1
a298 1
    SSPUSHPTR(SvPVX_const(gv));
d307 1
a307 1
	Newxz(gp, 1, GP);
d318 1
a318 3
	/* XXX Ideally this cast would be replaced with a change to const char*
	   in the struct.  */
	GvFILE(gv) = CopFILE(PL_curcop) ? CopFILE(PL_curcop) : (char *) "";
d330 1
a330 1
    AV * const oav = GvAVn(gv);
d343 1
a343 1
	SvMAGIC_set(av, SvMAGIC(oav));
d346 1
a346 1
	SvMAGIC_set(oav, NULL);
d367 1
a367 1
	SvMAGIC_set(hv, SvMAGIC(ohv));
d370 1
a370 1
	SvMAGIC_set(ohv, NULL);
d381 1
a381 1
    register SV * const sv = newSVsv(item);
d383 1
d505 1
a505 2
    PERL_UNUSED_ARG(i);
    NORETURN_FUNCTION_END;
d589 1
d593 1
a593 1
	register SV * const sv = NEWSV(0,0);
d631 1
a631 1
        (void)SvREFCNT_inc(*sptr);
d672 1
a672 1
    register const I32 start = pad + ((char*)&PL_savestack[PL_savestack_ix]
d674 1
a674 1
    register const I32 elems = 1 + ((size + pad - 1) / sizeof(*PL_savestack));
d757 1
a757 1
		SvMAGIC_set(value, SvMAGIC(sv));
d760 1
a760 1
		SvMAGIC_set(sv, 0);
d775 1
a775 1
		SvMAGIC_set(value, NULL);
d790 2
a791 2
		AV * const goner = GvAV(gv);
		SvMAGIC_set(av, SvMAGIC(goner));
d794 1
a794 1
		SvMAGIC_set(goner, NULL);
d808 2
a809 2
		HV * const goner = GvHV(gv);
		SvMAGIC_set(hv, SvMAGIC(goner));
d812 1
a812 1
		SvMAGIC_set(goner, NULL);
d874 2
a875 2
	    if (SvPVX_const(gv) && SvLEN(gv) > 0) {
		Safefree(SvPVX_mutable(gv));
d877 3
a879 3
	    SvPV_set(gv, (char *)SSPOPPTR);
	    SvCUR_set(gv, (STRLEN)SSPOPIV);
	    SvLEN_set(gv, (STRLEN)SSPOPIV);
d901 1
a901 1
	    Safefree(ptr);
a933 15
		    /* Need to detach $#array from @@array that has just gone
		       out of scope. Otherwise the first $#array controls the
		       size of the array "newly" created the next time this
		       scope is entered.
		    */
		    if (AvARYLEN(sv)) {
			MAGIC *mg = mg_find (AvARYLEN(sv), PERL_MAGIC_arylen);

			if (mg) {
			    mg->mg_obj = 0;
			}

			SvREFCNT_dec(AvARYLEN(sv));
			AvARYLEN(sv) = 0;
		    }
d946 1
a946 2
		const U32 padflags
		  = SvFLAGS(sv) & (SVs_PADBUSY|SVs_PADMY|SVs_PADTMP);
d1005 1
a1005 1
		const SV * const oval = HeVAL((HE*)ptr);
d1043 1
a1043 1
		const PADOFFSET off = (PADOFFSET)SSPOPLONG;
d1112 1
a1112 1
			  SvPVX_const(cx->blk_eval.old_namesv));
a1167 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d27 31
a60 1
    dVAR;
a78 1
    dVAR;
d94 1
a94 1
    PoisonNew(si->si_cxstack, cxitems, PERL_CONTEXT);
a100 1
    dVAR;
d106 1
a106 1
    PoisonNew(cxstack + old_max + 1, cxstack_max - old_max, PERL_CONTEXT);
d111 19
a131 1
    dVAR;
a142 1
    dVAR;
a149 1
    dVAR;
a160 1
    dVAR;
a167 1
    dVAR;
a176 1
    dVAR;
a188 1
    dVAR;
d193 1
a193 1
	PL_tmps_stack[PL_tmps_ix--] = NULL;
a203 1
    dVAR;
d205 1
a205 1
    register SV * const sv = *sptr = newSV(0);
d208 1
d210 1
d212 6
d219 1
a219 1
	       (SVp_IOK|SVp_NOK|SVp_POK)) >> PRIVSHIFT;
d222 8
a229 1
	mg_localize(osv, sv);
d237 1
a237 5
    dVAR;
    SV ** const sptr = &GvSVn(gv);
    PL_localizing = 1;
    SvGETMAGIC(*sptr);
    PL_localizing = 0;
d239 1
a239 1
    SSPUSHPTR(SvREFCNT_inc_simple(gv));
d245 10
a259 1
    dVAR;
a271 1
    dVAR;
d273 1
a274 1
    SSPUSHPTR(str);
a283 1
    dVAR;
a289 13
/* set the SvFLAGS specified by mask to the values in val */

void
Perl_save_set_svflags(pTHX_ SV* sv, U32 mask, U32 val)
{
    dVAR;
    SSCHECK(4);
    SSPUSHPTR(sv);
    SSPUSHINT(mask);
    SSPUSHINT(val);
    SSPUSHINT(SAVEt_SET_SVFLAGS);
}

d293 6
a298 2
    dVAR;
    SSGROW(3);
d304 3
a306 1
	GP *gp = Perl_newGP(aTHX_ gv);
d309 1
a309 1
            mro_method_changed_in(GvSTASH(gv)); /* taking a method out of circulation ("local")*/
d314 7
a320 9
#ifdef PERL_DONT_CREATE_GVSV
	if (gv == PL_errgv) {
	    /* We could scatter this logic everywhere by changing the
	       definition of ERRSV from GvSV() to GvSVn(), but it seems more
	       efficient to do this check once here.  */
	    gp->gp_sv = newSV(0);
	}
#endif
	GvGP(gv) = gp;
a330 1
    dVAR;
d341 1
a341 1
    GvAV(gv) = NULL;
d343 9
a351 2
    if (SvMAGIC(oav))
	mg_localize((SV*)oav, (SV*)av);
a357 1
    dVAR;
d365 1
a365 1
    GvHV(gv) = NULL;
d367 9
a375 2
    if (SvMAGIC(ohv))
	mg_localize((SV*)ohv, (SV*)hv);
a381 1
    dVAR;
a392 1
    dVAR;
d400 9
a410 1
    dVAR;
d418 1
a418 1
Perl_save_I8(pTHX_ I8 *bytep)
a419 1
    dVAR;
d421 3
a423 3
    SSPUSHINT(*bytep);
    SSPUSHPTR(bytep);
    SSPUSHINT(SAVEt_I8);
a428 1
    dVAR;
d436 10
a445 1
Perl_save_I32(pTHX_ I32 *intp)
a446 1
    dVAR;
d448 3
a450 3
    SSPUSHINT(*intp);
    SSPUSHPTR(intp);
    SSPUSHINT(SAVEt_I32);
a458 1
    dVAR;
a467 1
    dVAR;
a476 1
    dVAR;
a485 1
    dVAR;
d494 24
a520 1
    dVAR;
a529 1
    dVAR;
a538 1
    dVAR;
a546 1
    dVAR;
a554 1
    dVAR;
a562 1
    dVAR;
a570 1
    dVAR;
a574 1
    SvPADSTALE_off(*svp); /* mark lexical as active */
a579 1
    dVAR;
d583 1
a583 1
    SSPUSHPTR(SvREFCNT_inc_simple(hv));
d588 15
a604 1
    dVAR;
a613 1
    dVAR;
a622 1
    dVAR;
a623 1
    SvGETMAGIC(*sptr);
d625 1
a625 1
    SSPUSHPTR(SvREFCNT_inc_simple(av));
d631 1
a631 1
	SvREFCNT_inc_void(*sptr);
a644 1
    dVAR;
a645 1
    SvGETMAGIC(*sptr);
d647 2
a648 2
    SSPUSHPTR(SvREFCNT_inc_simple(hv));
    SSPUSHPTR(newSVsv(key));
a660 12
SV*
Perl_save_svref(pTHX_ SV **sptr)
{
    dVAR;
    SvGETMAGIC(*sptr);
    SSCHECK(3);
    SSPUSHPTR(sptr);
    SSPUSHPTR(SvREFCNT_inc(*sptr));
    SSPUSHINT(SAVEt_SVREF);
    return save_scalar_at(sptr);
}

a663 1
    dVAR;
a671 1
    dVAR;
d676 3
a678 1
    SSGROW(elems + 2);
a688 1
    dVAR;
d694 1
a694 1
    void* ptr;
d715 1
a715 15
	restore_sv:
	    sv = *(SV**)ptr;
	    DEBUG_S(PerlIO_printf(Perl_debug_log,
				  "restore svref: %p %p:%s -> %p:%s\n",
				  (void*)ptr, (void*)sv, SvPEEK(sv),
				  (void*)value, SvPEEK(value)));
	    *(SV**)ptr = value;
	    SvREFCNT_dec(sv);
	    PL_localizing = 2;
	    SvSETMAGIC(value);
	    PL_localizing = 0;
	    SvREFCNT_dec(value);
	    if (av) /* actually an av, hv or gv */
		SvREFCNT_dec(av);
	    break;
d717 1
a718 1
	    str = (char*)SSPOPPTR;
d744 42
d790 6
a795 1
		SvREFCNT_dec(GvAV(gv));
d808 6
a813 1
		SvREFCNT_dec(GvHV(gv));
d826 4
a835 7
#ifdef PERL_DEBUG_READONLY_OPS
	    {
		const I32 val = SSPOPINT;
		if (*(I32*)ptr != val)
		    *(I32*)ptr = val;
	    }
#else
d837 12
a848 1
#endif
d867 4
d874 6
d882 2
a883 3
            /* putting a method back into circulation ("local")*/
	    if (GvCVu(gv) && (hv=GvSTASH(gv)) && HvNAME_get(hv))
                mro_method_changed_in(hv);
d934 15
a958 1
		SvPADSTALE_on(sv); /* mark as no longer live */
d961 2
a962 1
		const U32 padflags = SvFLAGS(sv) & (SVs_PADMY|SVs_PADTMP);
d966 1
a966 1
		default:	*(SV**)ptr = newSV(0);		break;
d969 1
a969 3
		/* preserve pad nature, but also mark as not live
		 * for any closure capturing */
		SvFLAGS(*(SV**)ptr) |= padflags | SVs_PADSTALE;
d976 1
a976 1
	    (void)hv_delete(hv, (char*)ptr, (I32)SSPOPINT, G_DISCARD);
d980 4
a996 4
	case SAVEt_STACK_CXPOS:         /* blk_oldsp on context stack */
	    i = SSPOPINT;
	    cxstack[i].blk_oldsp = SSPOPINT;
	    break;
a1000 1
	    ptr = av_fetch(av,i,1);
d1003 1
d1008 1
a1008 1
			SvREFCNT_inc_void_NN(sv);
d1025 1
a1025 1
			SvREFCNT_inc_void(*(SV**)ptr);
a1043 2
	    Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
	    PL_compiling.cop_hints_hash = (struct refcounted_he *) SSPOPPTR;
a1046 20
		assert(GvHV(PL_hintgv));
	    } else if (!GvHV(PL_hintgv)) {
		/* Need to add a new one manually, else gv_fetchpv() can
		   add one in this code:
		   
		   if (SvTYPE(gv) == SVt_PVGV) {
		       if (add) {
		       GvMULTI_on(gv);
		       gv_init_sv(gv, sv_type);
		       if (*name=='!' && sv_type == SVt_PVHV && len==1)
			   require_errno(gv);
		       }
		       return gv;
		   }

		   and it won't have the magic set.  */

		HV *const hv = newHV();
		hv_magic(hv, NULL, PERL_MAGIC_hints);
		GvHV(PL_hintgv) = hv;
d1048 1
a1048 1
	    assert(GvHV(PL_hintgv));
d1055 1
a1055 1
		PL_curpad = NULL;
d1068 2
a1069 2
		AV* const t = (AV*)SSPOPPTR;
		AV* const f = (AV*)SSPOPPTR;
a1073 73
	case SAVEt_SET_SVFLAGS:
	    {
		const U32 val  = (U32)SSPOPINT;
		const U32 mask = (U32)SSPOPINT;
		sv = (SV*)SSPOPPTR;
		SvFLAGS(sv) &= ~mask;
		SvFLAGS(sv) |= val;
	    }
	    break;
	    /* These are only saved in mathoms.c */
	case SAVEt_SVREF:			/* scalar reference */
	    value = (SV*)SSPOPPTR;
	    ptr = SSPOPPTR;
	    av = NULL; /* what to refcnt_dec */
	    goto restore_sv;
	case SAVEt_LONG:			/* long reference */
	    ptr = SSPOPPTR;
	    *(long*)ptr = (long)SSPOPLONG;
	    break;
	case SAVEt_I16:				/* I16 reference */
	    ptr = SSPOPPTR;
	    *(I16*)ptr = (I16)SSPOPINT;
	    break;
	case SAVEt_I8:				/* I8 reference */
	    ptr = SSPOPPTR;
	    *(I8*)ptr = (I8)SSPOPINT;
	    break;
	case SAVEt_IV:				/* IV reference */
	    ptr = SSPOPPTR;
	    *(IV*)ptr = (IV)SSPOPIV;
	    break;
	case SAVEt_NSTAB:
	    gv = (GV*)SSPOPPTR;
	    (void)sv_clear((SV*)gv);
	    break;
	case SAVEt_DESTRUCTOR:
	    ptr = SSPOPPTR;
	    (*SSPOPDPTR)(ptr);
	    break;
	case SAVEt_COP_ARYBASE:
	    ptr = SSPOPPTR;
	    i = SSPOPINT;
	    CopARYBASE_set((COP *)ptr, i);
	    break;
	case SAVEt_COMPILE_WARNINGS:
	    ptr = SSPOPPTR;

	    if (!specialWARN(PL_compiling.cop_warnings))
		PerlMemShared_free(PL_compiling.cop_warnings);

	    PL_compiling.cop_warnings = (STRLEN*)ptr;
	    break;
	case SAVEt_RE_STATE:
	    {
		const struct re_save_state *const state
		    = (struct re_save_state *)
		    (PL_savestack + PL_savestack_ix
		     - SAVESTACK_ALLOC_FOR_RE_SAVE_STATE);
		PL_savestack_ix -= SAVESTACK_ALLOC_FOR_RE_SAVE_STATE;

		if (PL_reg_start_tmp != state->re_state_reg_start_tmp) {
		    Safefree(PL_reg_start_tmp);
		}
		if (PL_reg_poscache != state->re_state_reg_poscache) {
		    Safefree(PL_reg_poscache);
		}
		Copy(state, &PL_reg_state, 1, struct re_save_state);
	    }
	    break;
	case SAVEt_PARSER:
	    ptr = SSPOPPTR;
	    parser_free((yy_parser *) ptr);
	    break;
a1082 1
    dVAR;
d1091 1
a1108 2
	PerlIO_printf(Perl_debug_log, "BLK_SUB.RETOP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.retop));
a1118 2
	PerlIO_printf(Perl_debug_log, "BLK_SUB.RETOP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_sub.retop));
a1130 2
	PerlIO_printf(Perl_debug_log, "BLK_EVAL.RETOP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_eval.retop));
d1138 2
a1139 2
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.MY_OP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_loop.my_op));
d1141 3
a1143 1
		PTR2UV(CX_LOOP_NEXTOP_GET(cx)));
a1181 3
#else
    PERL_UNUSED_CONTEXT;
    PERL_UNUSED_ARG(cx);
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 2
a13 4
 * For the fashion of Minas Tirith was such that it was built on seven
 * levels...
 *
 *     [p.751 of _The Lord of the Rings_, V/i: "Minas Tirith"]
a30 3

    PERL_ARGS_ASSERT_STACK_GROW;

a167 2
    PERL_ARGS_ASSERT_SAVE_SCALAR_AT;

a179 10
void
Perl_save_pushptrptr(pTHX_ void *const ptr1, void *const ptr2, const int type)
{
    dVAR;
    SSCHECK(3);
    SSPUSHPTR(ptr1);
    SSPUSHPTR(ptr2);
    SSPUSHINT(type);
}

a184 3

    PERL_ARGS_ASSERT_SAVE_SCALAR;

d188 4
a191 1
    save_pushptrptr(SvREFCNT_inc_simple(gv), SvREFCNT_inc(*sptr), SAVEt_SV);
d201 4
a204 4

    PERL_ARGS_ASSERT_SAVE_GENERIC_SVREF;

    save_pushptrptr(sptr, SvREFCNT_inc(*sptr), SAVEt_GENERIC_SVREF);
d214 4
a217 4

    PERL_ARGS_ASSERT_SAVE_GENERIC_PVREF;

    save_pushptrptr(*str, str, SAVEt_GENERIC_PVREF);
d227 4
a230 4

    PERL_ARGS_ASSERT_SAVE_SHARED_PVREF;

    save_pushptrptr(str, *str, SAVEt_SHARED_PVREF);
a238 3

    PERL_ARGS_ASSERT_SAVE_SET_SVFLAGS;

d250 4
a253 4

    PERL_ARGS_ASSERT_SAVE_GP;

    save_pushptrptr(SvREFCNT_inc(gv), GvGP(gv), SAVEt_GP);
a286 2
    PERL_ARGS_ASSERT_SAVE_ARY;

d289 4
a292 1
    save_pushptrptr(gv, oav, SAVEt_AV);
d297 1
a297 1
	mg_localize(MUTABLE_SV(oav), MUTABLE_SV(av));
d307 4
a310 3
    PERL_ARGS_ASSERT_SAVE_HASH;

    save_pushptrptr(gv, (ohv = GvHVn(gv)), SAVEt_HV);
d315 1
a315 1
	mg_localize(MUTABLE_SV(ohv), MUTABLE_SV(hv));
d325 4
a328 5
    PERL_ARGS_ASSERT_SAVE_ITEM;

    save_pushptrptr(item, /* remember the pointer */
		    sv,   /* remember the value */
		    SAVEt_ITEM);
d332 1
a332 1
Perl_save_bool(pTHX_ bool *boolp)
a334 3

    PERL_ARGS_ASSERT_SAVE_BOOL;

d336 3
a338 3
    SSPUSHBOOL(*boolp);
    SSPUSHPTR(boolp);
    SSPUSHINT(SAVEt_BOOL);
d342 1
a342 1
Perl_save_pushi32ptr(pTHX_ const I32 i, void *const ptr, const int type)
d346 3
a348 13
    SSPUSHINT(i);
    SSPUSHPTR(ptr);
    SSPUSHINT(type);
}

void
Perl_save_int(pTHX_ int *intp)
{
    dVAR;

    PERL_ARGS_ASSERT_SAVE_INT;

    save_pushi32ptr(*intp, intp, SAVEt_INT);
d355 4
a358 4

    PERL_ARGS_ASSERT_SAVE_I8;

    save_pushi32ptr(*bytep, bytep, SAVEt_I8);
d365 4
a368 4

    PERL_ARGS_ASSERT_SAVE_I16;

    save_pushi32ptr(*intp, intp, SAVEt_I16);
d375 4
a378 4

    PERL_ARGS_ASSERT_SAVE_I32;

    save_pushi32ptr(*intp, intp, SAVEt_I32);
d388 4
a391 4

    PERL_ARGS_ASSERT_SAVE_PPTR;

    save_pushptrptr(*pptr, pptr, SAVEt_PPTR);
d398 4
a401 4

    PERL_ARGS_ASSERT_SAVE_VPTR;

    save_pushptrptr(*(char**)ptr, ptr, SAVEt_VPTR);
d408 4
a411 4

    PERL_ARGS_ASSERT_SAVE_SPTR;

    save_pushptrptr(*sptr, sptr, SAVEt_SPTR);
d415 1
a415 1
Perl_save_padsv_and_mortalize(pTHX_ PADOFFSET off)
d420 1
a420 1
    SSPUSHPTR(SvREFCNT_inc_simple_NN(PL_curpad[off]));
d423 1
a423 1
    SSPUSHINT(SAVEt_PADSV_AND_MORTALIZE);
d430 5
d436 9
a444 1
    PERL_ARGS_ASSERT_SAVE_HPTR;
d446 7
a452 1
    save_pushptrptr(*hptr, hptr, SAVEt_HPTR);
d456 1
a456 1
Perl_save_aptr(pTHX_ AV **aptr)
d459 4
d464 7
a470 3
    PERL_ARGS_ASSERT_SAVE_APTR;

    save_pushptrptr(*aptr, aptr, SAVEt_APTR);
d474 1
a474 1
Perl_save_pushptr(pTHX_ void *const ptr, const int type)
d478 2
a479 2
    SSPUSHPTR(ptr);
    SSPUSHINT(type);
a485 3

    PERL_ARGS_ASSERT_SAVE_CLEARSV;

d497 5
a501 4

    PERL_ARGS_ASSERT_SAVE_DELETE;

    save_pushptri32ptr(key, klen, SvREFCNT_inc_simple(hv), SAVEt_DELETE);
a507 3

    PERL_ARGS_ASSERT_SAVE_DESTRUCTOR;

a524 30
Perl_save_hints(pTHX)
{
    dVAR;
    SSCHECK(4);
    if (PL_hints & HINT_LOCALIZE_HH) {
	SSPUSHPTR(GvHV(PL_hintgv));
	GvHV(PL_hintgv) = Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv));
    }
    if (PL_compiling.cop_hints_hash) {
	HINTS_REFCNT_LOCK;
	PL_compiling.cop_hints_hash->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
    }
    SSPUSHPTR(PL_compiling.cop_hints_hash);
    SSPUSHINT(PL_hints);
    SSPUSHINT(SAVEt_HINTS);
}

static void
S_save_pushptri32ptr(pTHX_ void *const ptr1, const I32 i, void *const ptr2,
			const int type)
{
    SSCHECK(4);
    SSPUSHPTR(ptr1);
    SSPUSHINT(i);
    SSPUSHPTR(ptr2);
    SSPUSHINT(type);
}

void
a528 3

    PERL_ARGS_ASSERT_SAVE_AELEM;

d530 5
a534 2
    save_pushptri32ptr(SvREFCNT_inc_simple(av), idx, SvREFCNT_inc(*sptr),
		       SAVEt_AELEM);
a552 3

    PERL_ARGS_ASSERT_SAVE_HELEM;

a572 3

    PERL_ARGS_ASSERT_SAVE_SVREF;

d574 4
a577 1
    save_pushptrptr(sptr, SvREFCNT_inc(*sptr), SAVEt_SVREF);
d581 9
a617 2
    /* Localise the effects of the TAINT_NOT inside the loop.  */
    const bool was = PL_tainted;
a621 2
	TAINT_NOT;

d624 2
a625 2
	    value = MUTABLE_SV(SSPOPPTR);
	    sv = MUTABLE_SV(SSPOPPTR);
d632 2
a633 2
	    value = MUTABLE_SV(SSPOPPTR);
	    gv = MUTABLE_GV(SSPOPPTR);
d635 1
a635 1
	    av = MUTABLE_AV(gv); /* what to refcnt_dec */
d672 1
a672 1
	    value = MUTABLE_SV(SSPOPPTR);
d680 2
a681 2
	    av = MUTABLE_AV(SSPOPPTR);
	    gv = MUTABLE_GV(SSPOPPTR);
d688 1
a688 1
		SvSETMAGIC(MUTABLE_SV(av));
d693 2
a694 2
	    hv = MUTABLE_HV(SSPOPPTR);
	    gv = MUTABLE_GV(SSPOPPTR);
d701 1
a701 1
		SvSETMAGIC(MUTABLE_SV(hv));
d727 1
a727 1
	    *(SV**)ptr = MUTABLE_SV(SSPOPPTR);
d736 1
a736 1
	    *(HV**)ptr = MUTABLE_HV(SSPOPPTR);
d740 1
a740 1
	    *(AV**)ptr = MUTABLE_AV(SSPOPPTR);
d744 1
a744 1
	    gv = MUTABLE_GV(SSPOPPTR);
d754 1
a754 1
	    SvREFCNT_dec(MUTABLE_SV(ptr));
d758 1
a758 1
	    sv_2mortal(MUTABLE_SV(ptr));
d799 1
a799 1
		    av_clear(MUTABLE_AV(sv));
d802 1
a802 1
		    hv_clear(MUTABLE_HV(sv));
d815 2
a816 2
		case SVt_PVAV:	*(SV**)ptr = MUTABLE_SV(newAV());	break;
		case SVt_PVHV:	*(SV**)ptr = MUTABLE_SV(newHV());	break;
d827 1
a827 2
	    hv = MUTABLE_HV(ptr);
	    i = SSPOPINT;
d829 1
a829 1
	    (void)hv_delete(hv, (char*)ptr, i, G_DISCARD);
d851 1
a851 1
	    value = MUTABLE_SV(SSPOPPTR);
d853 1
a853 1
	    av = MUTABLE_AV(SSPOPPTR);
d860 1
a860 1
		    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied))
d869 3
a871 3
	    value = MUTABLE_SV(SSPOPPTR);
	    sv = MUTABLE_SV(SSPOPPTR);
	    hv = MUTABLE_HV(SSPOPPTR);
a872 1
	    SvREFCNT_dec(sv);
d877 1
a877 1
		    if (SvTIED_mg((const SV *)hv, PERL_MAGIC_tied))
d879 2
a880 1
		    av = MUTABLE_AV(hv); /* what to refcnt_dec */
d885 1
d893 1
a893 1
		SvREFCNT_dec(MUTABLE_SV(GvHV(PL_hintgv)));
d900 2
a901 2
		SvREFCNT_dec(MUTABLE_SV(GvHV(PL_hintgv)));
		GvHV(PL_hintgv) = MUTABLE_HV(SSPOPPTR);
d932 1
a932 1
	case SAVEt_PADSV_AND_MORTALIZE:
a934 1
		SV **svp;
d936 2
a937 7
		assert (ptr);
		svp = AvARRAY((PAD*)ptr) + off;
		/* This mortalizing used to be done by POPLOOP() via itersave.
		   But as we have all the information here, we can do it here,
		   save even having to have itersave in the struct.  */
		sv_2mortal(*svp);
		*svp = MUTABLE_SV(SSPOPPTR);
d943 2
a944 2
		AV *const t = MUTABLE_AV(SSPOPPTR);
		AV *const f = MUTABLE_AV(SSPOPPTR);
d953 1
a953 1
		sv = MUTABLE_SV(SSPOPPTR);
d958 1
a958 3

	    /* This would be a mathom, but Perl_save_svref() calls a static
	       function, S_save_scalar_at(), so has to stay in this file.  */
d960 1
a960 1
	    value = MUTABLE_SV(SSPOPPTR);
a963 6

	    /* These are only saved in mathoms.c */
	case SAVEt_NSTAB:
	    gv = MUTABLE_GV(SSPOPPTR);
	    (void)sv_clear(MUTABLE_SV(gv));
	    break;
a967 20
	case SAVEt_IV:				/* IV reference */
	    ptr = SSPOPPTR;
	    *(IV*)ptr = (IV)SSPOPIV;
	    break;

	    /* This case is rendered redundant by the integration of change
	       33078. See the comment near Perl_save_padsv().  */
	case SAVEt_PADSV:
	    {
		const PADOFFSET off = (PADOFFSET)SSPOPLONG;
		ptr = SSPOPPTR;
		if (ptr)
		    AvARRAY((PAD*)ptr)[off] = (SV*)SSPOPPTR;
		else {
		  /* Can we ever get here?
		     POPs must balance PUSHes.  */
		    (void) SSPOPPTR;
		}
	    }
	    break;
d976 8
a1025 2

    PL_tainted = was;
a1031 3

    PERL_ARGS_ASSERT_CX_DUMP;

d1056 1
a1056 1
		      (int)CxHASARGS(cx));
d1066 3
a1068 2
		(int)CxHASARGS(cx));
	PerlIO_printf(Perl_debug_log, "BLK_SUB.LVAL = %d\n", (int)CxLVAL(cx));
d1074 1
a1074 1
		(long)CxOLD_IN_EVAL(cx));
d1076 2
a1077 2
		PL_op_name[CxOLD_OP_TYPE(cx)],
		PL_op_desc[CxOLD_OP_TYPE(cx)]);
d1088 2
a1089 1
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.LABEL = %s\n", CxLABEL(cx));
d1102 3
d1117 1
a1117 1
		(long)CxONCE(cx));
a1137 16
}

/* This is rendered a mathom by the integration of change 33078. However, until
   we have versioned mathom logic in mathoms.c, we can't move it there for
   5.10.1, as other code in production may have linked to it.  */

void
Perl_save_padsv(pTHX_ PADOFFSET off)
{
    dVAR;
    SSCHECK(4);
    ASSERT_CURPAD_ACTIVE("save_padsv");
    SSPUSHPTR(PL_curpad[off]);
    SSPUSHPTR(PL_comppad);
    SSPUSHLONG((long)off);
    SSPUSHINT(SAVEt_PADSV);
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@a93 3
#ifdef DEBUGGING
	Renew(PL_scopestack_name, PL_scopestack_max, const char*);
#endif
a94 3
#ifdef DEBUGGING
    PL_scopestack_name[PL_scopestack_ix] = "unknown";
#endif
d167 1
a167 1
S_save_scalar_at(pTHX_ SV **sptr, const U32 flags)
d170 2
a171 2
    SV * osv;
    register SV *sv;
a174 3
    osv = *sptr;
    sv  = (flags & SAVEf_KEEPOLDELEM) ? osv : (*sptr = newSV(0));

d182 1
a182 2
	if (!(flags & SAVEf_KEEPOLDELEM))
	    mg_localize(osv, sv, (flags & SAVEf_SETMAGIC) != 0);
a183 1

d209 1
a209 1
    return save_scalar_at(sptr, SAVEf_SETMAGIC); /* XXX - FIXME - see #60360 */
d316 1
a316 1
	mg_localize(MUTABLE_SV(oav), MUTABLE_SV(av), TRUE);
d333 1
a333 1
	mg_localize(MUTABLE_SV(ohv), MUTABLE_SV(hv), TRUE);
a511 26
Perl_save_hdelete(pTHX_ HV *hv, SV *keysv)
{
    STRLEN len;
    I32 klen;
    const char *key;

    PERL_ARGS_ASSERT_SAVE_HDELETE;

    key  = SvPV_const(keysv, len);
    klen = SvUTF8(keysv) ? -(I32)len : (I32)len;
    SvREFCNT_inc_simple_void_NN(hv);
    save_pushptri32ptr(savepvn(key, len), klen, hv, SAVEt_DELETE);
}

void
Perl_save_adelete(pTHX_ AV *av, I32 key)
{
    dVAR;

    PERL_ARGS_ASSERT_SAVE_ADELETE;

    SvREFCNT_inc_void(av);
    save_pushi32ptr(key, av, SAVEt_ADELETE);
}

void
d538 5
d545 2
a546 9
	    PL_compiling.cop_hints_hash->refcounted_he_refcnt++;
	    HINTS_REFCNT_UNLOCK;
    }
    if (PL_hints & HINT_LOCALIZE_HH) {
	save_pushptri32ptr(GvHV(PL_hintgv), PL_hints,
			   PL_compiling.cop_hints_hash, SAVEt_HINTS);
	GvHV(PL_hintgv) = Perl_hv_copy_hints_hv(aTHX_ GvHV(PL_hintgv));
    } else {
	save_pushi32ptr(PL_hints, PL_compiling.cop_hints_hash, SAVEt_HINTS);
d548 3
d565 1
a565 1
Perl_save_aelem_flags(pTHX_ AV *av, I32 idx, SV **sptr, const U32 flags)
d570 1
a570 1
    PERL_ARGS_ASSERT_SAVE_AELEM_FLAGS;
d578 1
a578 3
    save_scalar_at(sptr, flags); /* XXX - FIXME - see #60360 */
    if (flags & SAVEf_KEEPOLDELEM)
	return;
d589 1
a589 1
Perl_save_helem_flags(pTHX_ HV *hv, SV *key, SV **sptr, const U32 flags)
d594 1
a594 1
    PERL_ARGS_ASSERT_SAVE_HELEM_FLAGS;
d602 1
a602 3
    save_scalar_at(sptr, flags);
    if (flags & SAVEf_KEEPOLDELEM)
	return;
d621 1
a621 1
    return save_scalar_at(sptr, SAVEf_SETMAGIC); /* XXX - FIXME - see #60360 */
d676 4
d720 3
a722 1
	    SvREFCNT_dec(GvAV(gv));
d733 3
a735 1
	    SvREFCNT_dec(GvHV(gv));
a871 7
	case SAVEt_ADELETE:
	    ptr = SSPOPPTR;
	    av = MUTABLE_AV(ptr);
	    i = SSPOPINT;
	    (void)av_delete(av, i, G_DISCARD);
	    SvREFCNT_dec(av);
	    break;
d934 1
a936 1
	    *(I32*)&PL_hints = (I32)SSPOPINT;
d1025 15
d1118 7
a1124 7
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.CV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_format.cv));
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.GV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_format.gv));
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.DFOUTGV = 0x%"UVxf"\n",
		PTR2UV(cx->blk_format.dfoutgv));
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.HASARGS = %d\n",
d1126 2
a1127 2
	PerlIO_printf(Perl_debug_log, "BLK_FORMAT.RETOP = 0x%"UVxf"\n",
		PTR2UV(cx->blk_format.retop));
d1155 1
a1155 4
    case CXt_LOOP_LAZYIV:
    case CXt_LOOP_LAZYSV:
    case CXt_LOOP_FOR:
    case CXt_LOOP_PLAIN:
d1163 2
a1164 1
	/* XXX: not accurate for LAZYSV/IV */
d1166 1
a1166 3
		PTR2UV(cx->blk_loop.state_u.ary.ary));
	PerlIO_printf(Perl_debug_log, "BLK_LOOP.ITERIX = %ld\n",
		(long)cx->blk_loop.state_u.ary.ix);
d1169 2
d1202 16
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d80 1
a80 1
    Renew(cxstack, cxstack_max + 1, PERL_CONTEXT);
d184 1
a184 1
    if (SvTYPE(osv) >= SVt_PVMG && SvMAGIC(osv)) {
d186 1
d189 1
d192 1
a192 1
	    mg_localize(osv, sv, cBOOL(flags & SAVEf_SETMAGIC));
d205 1
a205 1
    SSPUSHUV(type);
d274 1
a274 1
    SSPUSHUV(SAVEt_SET_SVFLAGS);
d303 1
a303 1
	GvGP_set(gv,gp);
d322 1
a322 1
    save_pushptrptr(SvREFCNT_inc_simple_NN(gv), oav, SAVEt_AV);
d339 1
a339 3
    save_pushptrptr(
	SvREFCNT_inc_simple_NN(gv), (ohv = GvHVn(gv)), SAVEt_HV
    );
d368 2
a369 1
    SSCHECK(2);
d371 1
a371 1
    SSPUSHUV(SAVEt_BOOL | (*boolp << 8));
d381 1
a381 1
    SSPUSHUV(type);
a387 1
    const UV shifted = (UV)*intp << SAVE_TIGHT_SHIFT;
d391 1
a391 6
    if ((int)(shifted >> SAVE_TIGHT_SHIFT) == *intp) {
	SSCHECK(2);
	SSPUSHPTR(intp);
	SSPUSHUV(SAVEt_INT_SMALL | shifted);
    } else
	save_pushi32ptr(*intp, intp, SAVEt_INT);
d401 1
a401 3
    SSCHECK(2);
    SSPUSHPTR(bytep);
    SSPUSHUV(SAVEt_I8 | ((UV)*bytep << 8));
d411 1
a411 3
    SSCHECK(2);
    SSPUSHPTR(intp);
    SSPUSHUV(SAVEt_I16 | ((UV)*intp << 8));
a417 1
    const UV shifted = (UV)*intp << SAVE_TIGHT_SHIFT;
d421 1
a421 6
    if ((I32)(shifted >> SAVE_TIGHT_SHIFT) == *intp) {
	SSCHECK(2);
	SSPUSHPTR(intp);
	SSPUSHUV(SAVEt_I32_SMALL | shifted);
    } else
	save_pushi32ptr(*intp, intp, SAVEt_I32);
d466 1
a466 1
    SSPUSHUV(SAVEt_PADSV_AND_MORTALIZE);
d495 1
a495 1
    SSPUSHUV(type);
a501 2
    const UV offset = svp - PL_curpad;
    const UV offset_shifted = offset << SAVE_TIGHT_SHIFT;
d506 3
a508 6
    if ((offset_shifted >> SAVE_TIGHT_SHIFT) != offset)
	Perl_croak(aTHX_ "panic: pad offset %"UVuf" out of range (%p-%p)",
		   offset, svp, PL_curpad);

    SSCHECK(1);
    SSPUSHUV(offset_shifted | SAVEt_CLEARSV);
d558 1
a558 1
    SSPUSHUV(SAVEt_DESTRUCTOR);
d568 1
a568 1
    SSPUSHUV(SAVEt_DESTRUCTOR_X);
d575 5
a579 1
    COPHH *save_cophh = cophh_copy(CopHINTHASH_get(&PL_compiling));
d581 3
a583 4
	HV *oldhh = GvHV(PL_hintgv);
	save_pushptri32ptr(oldhh, PL_hints, save_cophh, SAVEt_HINTS);
	GvHV(PL_hintgv) = NULL; /* in case copying dies */
	GvHV(PL_hintgv) = hv_copy_hints_hv(oldhh);
d585 1
a585 1
	save_pushi32ptr(PL_hints, save_cophh, SAVEt_HINTS);
d597 1
a597 1
    SSPUSHUV(type);
d622 1
a622 1
    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied))
d639 1
a639 1
    SSPUSHUV(SAVEt_HELEM);
d648 1
a648 1
    if (SvTIED_mg((const SV *)hv, PERL_MAGIC_tied))
d670 1
a670 2
    const UV elems = 1 + ((size + pad - 1) / sizeof(*PL_savestack));
    const UV elems_shifted = elems << SAVE_TIGHT_SHIFT;
d672 1
a672 5
    if ((elems_shifted >> SAVE_TIGHT_SHIFT) != elems)
	Perl_croak(aTHX_ "panic: save_alloc elems %"UVuf" out of range (%ld-%ld)",
		   elems, size, pad);

    SSGROW(elems + 1);
d675 2
a676 1
    SSPUSHUV(SAVEt_ALLOC | elems_shifted);
d693 1
a693 1
    bool was = PL_tainted;
d696 1
a696 3
	Perl_croak(aTHX_ "panic: corrupt saved stack index %ld", (long) base);
    DEBUG_l(Perl_deb(aTHX_ "savestack: releasing items %ld -> %ld\n",
			(long)PL_savestack_ix, (long)base));
a697 2
	UV uv = SSPOPUV;
	const U8 type = (U8)uv & SAVE_MASK;
d700 1
a700 1
	switch (type) {
d722 2
a723 1
	    SvREFCNT_dec(av); /* av may actually be an AV, HV or GV */
a744 5
	case SAVEt_GVSV:			/* scalar slot in GV */
	    value = MUTABLE_SV(SSPOPPTR);
	    gv = MUTABLE_GV(SSPOPPTR);
	    ptr = &GvSV(gv);
	    goto restore_svp;
a747 1
	restore_svp:
a762 1
	    SvREFCNT_dec(gv);
a773 5
	    SvREFCNT_dec(gv);
	    break;
	case SAVEt_INT_SMALL:
	    ptr = SSPOPPTR;
	    *(int*)ptr = (int)(uv >> SAVE_TIGHT_SHIFT);
d781 1
a781 14
	    *(bool*)ptr = cBOOL(uv >> 8);

	    if (ptr == &PL_tainted) {
		/* If we don't update <was>, to reflect what was saved on the
		 * stack for PL_tainted, then we will overwrite this attempt to
		 * restore it when we exit this routine.  Note that this won't
		 * work if this value was saved in a wider-than necessary type,
		 * such as I32 */
		was = *(bool*)ptr;
	    }
	    break;
	case SAVEt_I32_SMALL:
	    ptr = SSPOPPTR;
	    *(I32*)ptr = (I32)(uv >> SAVE_TIGHT_SHIFT);
d816 1
a816 1
	    GvGP_set(gv, (GP*)ptr);
d818 1
a818 1
	    if (GvCVu(gv) && (hv=GvSTASH(gv)) && HvENAME_get(hv))
a825 4
	case SAVEt_FREECOPHH:
	    ptr = SSPOPPTR;
	    cophh_free((COPHH *)ptr);
	    break;
d840 1
a840 1
	    ptr = (void*)&PL_curpad[uv >> SAVE_TIGHT_SHIFT];
a861 2
		if (SvTYPE(sv) == SVt_PVHV)
		    Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
a862 1
		    sv_unmagic(sv, PERL_MAGIC_backref),
d883 1
a883 2
		assert(  SvFLAGS(sv) & SVs_PADMY);
		assert(!(SvFLAGS(sv) & SVs_PADTMP));
d892 1
a892 1
		SvFLAGS(*(SV**)ptr) |= (SVs_PADMY|SVs_PADSTALE);
a915 1
	    /* regexp must have croaked */
d917 2
a918 1
	    PL_savestack_ix -= uv >> SAVE_TIGHT_SHIFT;
d969 2
a970 3
	    if ((PL_hints & HINT_LOCALIZE_HH)) {
	      while (GvHV(PL_hintgv)) {
		HV *hv = GvHV(PL_hintgv);
a971 2
		SvREFCNT_dec(MUTABLE_SV(hv));
	      }
d973 2
a974 2
	    cophh_free(CopHINTHASH_get(&PL_compiling));
	    CopHINTHASH_set(&PL_compiling, (COPHH*)SSPOPPTR);
d979 2
a980 2
	    }
	    if (!GvHV(PL_hintgv)) {
d1066 1
a1066 1
	    *(I16*)ptr = (I16)(uv >> 8);
d1070 1
a1070 1
	    *(I8*)ptr = (I8)(uv >> 8);
d1076 5
d1111 1
a1111 1
	    Perl_croak(aTHX_ "panic: leave_scope inconsistency %u", type);
a1115 2

    PERL_ASYNC_CHECK();
d1188 2
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d163 2
a164 4
	SV* const sv = PL_tmps_stack[PL_tmps_ix--];
#ifdef PERL_POISON
	PoisonWith(PL_tmps_stack + PL_tmps_ix + 1, 1, SV *, 0xAB);
#endif
d167 1
a167 1
	    SvREFCNT_dec_NN(sv);		/* note, can modify tmps_ix!!! */
d177 1
a177 1
    SV *sv;
d200 4
a203 5
    dSS_ADD;
    SS_ADD_PTR(ptr1);
    SS_ADD_PTR(ptr2);
    SS_ADD_UV(type);
    SS_ADD_END(3);
d214 3
a216 5
    if (SvGMAGICAL(*sptr)) {
        PL_localizing = 1;
        (void)mg_get(*sptr);
        PL_localizing = 0;
    }
a264 1
    dSS_ADD;
d268 5
a272 5
    SS_ADD_PTR(sv);
    SS_ADD_INT(mask);
    SS_ADD_INT(val);
    SS_ADD_UV(SAVEt_SET_SVFLAGS);
    SS_ADD_END(4);
a285 2
	HV * const stash = GvSTASH(gv);
	bool isa_changed = 0;
d287 2
a288 7
	if (stash && HvENAME(stash)) {
	    if (GvNAMELEN(gv) == 3 && strnEQ(GvNAME(gv), "ISA", 3))
		isa_changed = TRUE;
	    else if (GvCVu(gv))
		/* taking a method out of circulation ("local")*/
                mro_method_changed_in(stash);
	}
d293 8
a301 1
	if (isa_changed) mro_isa_changed_in(stash);
d349 1
a349 1
Perl_save_item(pTHX_ SV *item)
d352 1
a352 1
    SV * const sv = newSVsv(item);
a364 1
    dSS_ADD;
d368 3
a370 3
    SS_ADD_PTR(boolp);
    SS_ADD_UV(SAVEt_BOOL | (*boolp << 8));
    SS_ADD_END(2);
d377 4
a380 6
    dSS_ADD;

    SS_ADD_INT(i);
    SS_ADD_PTR(ptr);
    SS_ADD_UV(type);
    SS_ADD_END(3);
d387 1
a387 4
    const int i = *intp;
    UV type = ((UV)((UV)i << SAVE_TIGHT_SHIFT) | SAVEt_INT_SMALL);
    int size = 2;
    dSS_ADD;
d391 6
a396 8
    if ((int)(type >> SAVE_TIGHT_SHIFT) != i) {
        SS_ADD_INT(i);
        type = SAVEt_INT;
        size++;
    }
    SS_ADD_PTR(intp);
    SS_ADD_UV(type);
    SS_ADD_END(size);
a402 1
    dSS_ADD;
d406 3
a408 3
    SS_ADD_PTR(bytep);
    SS_ADD_UV(SAVEt_I8 | ((UV)*bytep << 8));
    SS_ADD_END(2);
a414 1
    dSS_ADD;
d418 3
a420 3
    SS_ADD_PTR(intp);
    SS_ADD_UV(SAVEt_I16 | ((UV)*intp << 8));
    SS_ADD_END(2);
d427 1
a427 4
    const I32 i = *intp;
    UV type = ((I32)((U32)i << SAVE_TIGHT_SHIFT) | SAVEt_I32_SMALL);
    int size = 2;
    dSS_ADD;
d431 6
a436 8
    if ((I32)(type >> SAVE_TIGHT_SHIFT) != i) {
        SS_ADD_INT(i);
        type = SAVEt_I32;
        size++;
    }
    SS_ADD_PTR(intp);
    SS_ADD_UV(type);
    SS_ADD_END(size);
d476 1
a476 2
    dSS_ADD;

d478 4
a481 5
    SS_ADD_PTR(SvREFCNT_inc_simple_NN(PL_curpad[off]));
    SS_ADD_PTR(PL_comppad);
    SS_ADD_UV((UV)off);
    SS_ADD_UV(SAVEt_PADSV_AND_MORTALIZE);
    SS_ADD_END(4);
d508 3
a510 4
    dSS_ADD;
    SS_ADD_PTR(ptr);
    SS_ADD_UV(type);
    SS_ADD_END(2);
d523 1
a523 2
    SvPADSTALE_off(*svp); /* mark lexical as active */
    if ((offset_shifted >> SAVE_TIGHT_SHIFT) != offset) {
a525 1
    }
d527 3
a529 5
    {
        dSS_ADD;
        SS_ADD_UV(offset_shifted | SAVEt_CLEARSV);
        SS_ADD_END(1);
    }
a571 1
    dSS_ADD;
d575 4
a578 4
    SS_ADD_DPTR(f);
    SS_ADD_PTR(p);
    SS_ADD_UV(SAVEt_DESTRUCTOR);
    SS_ADD_END(3);
d585 4
a588 6
    dSS_ADD;

    SS_ADD_DXPTR(f);
    SS_ADD_PTR(p);
    SS_ADD_UV(SAVEt_DESTRUCTOR_X);
    SS_ADD_END(3);
d610 5
a614 6
    dSS_ADD;
    SS_ADD_PTR(ptr1);
    SS_ADD_INT(i);
    SS_ADD_PTR(ptr2);
    SS_ADD_UV(type);
    SS_ADD_END(4);
d628 1
a628 2
    /* The array needs to hold a reference count on its new element, so it
       must be AvREAL. */
d630 1
a630 1
	av_reify(av);
d652 5
a656 8
    {
        dSS_ADD;
        SS_ADD_PTR(SvREFCNT_inc_simple(hv));
        SS_ADD_PTR(newSVsv(key));
        SS_ADD_PTR(SvREFCNT_inc(*sptr));
        SS_ADD_UV(SAVEt_HELEM);
        SS_ADD_END(4);
    }
d685 2
a686 2
    const I32 start = pad + ((char*)&PL_savestack[PL_savestack_ix]
                          - (char*)PL_savestack);
d691 2
a692 3
	Perl_croak(aTHX_
            "panic: save_alloc elems %"UVuf" out of range (%"IVdf"-%"IVdf")",
		   elems, (IV)size, (IV)pad);
a700 25


#define ARG0_SV  MUTABLE_SV(arg0.any_ptr)
#define ARG0_AV  MUTABLE_AV(arg0.any_ptr)
#define ARG0_HV  MUTABLE_HV(arg0.any_ptr)
#define ARG0_PTR arg0.any_ptr
#define ARG0_PV  (char*)(arg0.any_ptr)
#define ARG0_PVP (char**)(arg0.any_ptr)
#define ARG0_I32 (arg0.any_i32)

#define ARG1_SV  MUTABLE_SV(arg1.any_ptr)
#define ARG1_AV  MUTABLE_AV(arg1.any_ptr)
#define ARG1_GV  MUTABLE_GV(arg1.any_ptr)
#define ARG1_SVP (SV**)(arg1.any_ptr)
#define ARG1_PVP (char**)(arg1.any_ptr)
#define ARG1_PTR arg1.any_ptr
#define ARG1_PV  (char*)(arg1.any_ptr)
#define ARG1_I32 (arg1.any_i32)

#define ARG2_SV  MUTABLE_SV(arg2.any_ptr)
#define ARG2_AV  MUTABLE_AV(arg2.any_ptr)
#define ARG2_HV  MUTABLE_HV(arg2.any_ptr)
#define ARG2_GV  MUTABLE_GV(arg2.any_ptr)
#define ARG2_PV  (char*)(arg2.any_ptr)

d705 8
a712 1

d714 1
a714 9
    bool was = TAINT_get;

    ANY arg0, arg1, arg2;

    /* these initialisations are logically unnecessary, but they shut up
     * spurious 'may be used uninitialized' compiler warnings */
    arg0.any_ptr = NULL;
    arg1.any_ptr = NULL;
    arg2.any_ptr = NULL;
d721 2
a722 6
	UV uv;
	U8 type;

        SV *refsv;
        SV **svp;

a724 19
        {
            I32 ix = PL_savestack_ix - 1;
            ANY *p = &PL_savestack[ix];
            uv = p->any_uv;
            type = (U8)uv & SAVE_MASK;
            if (type > SAVEt_ARG0_MAX) {
                ANY *p0 = p;
                arg0 = *--p;
                if (type > SAVEt_ARG1_MAX) {
                    arg1 = *--p;
                    if (type > SAVEt_ARG2_MAX) {
                        arg2 = *--p;
                    }
                }
                ix -= (p0 - p);
            }
            PL_savestack_ix = ix;
        }

d727 6
a732 6
	    sv_replace(ARG1_SV, ARG0_SV);
            if (SvSMAGICAL(ARG1_SV)) {
                PL_localizing = 2;
                mg_set(ARG1_SV);
                PL_localizing = 0;
            }
a733 8

	    /* This would be a mathom, but Perl_save_svref() calls a static
	       function, S_save_scalar_at(), so has to stay in this file.  */
	case SAVEt_SVREF:			/* scalar reference */
	    svp = ARG1_SVP;
	    refsv = NULL; /* what to refcnt_dec */
	    goto restore_sv;

d735 4
a738 2
	    svp = &GvSV(ARG1_GV);
	    refsv = ARG1_SV; /* what to refcnt_dec */
d740 2
a741 3
        {
	    SV * const sv = *svp;
	    *svp = ARG0_SV;
d743 5
a747 7
            if (SvSMAGICAL(ARG0_SV)) {
                PL_localizing = 2;
                mg_set(ARG0_SV);
                PL_localizing = 0;
            }
	    SvREFCNT_dec_NN(ARG0_SV);
	    SvREFCNT_dec(refsv);
a748 1
        }
d750 5
a754 3
	    if (*ARG0_PVP != ARG1_PV) {
		Safefree(*ARG0_PVP);
		*ARG0_PVP = ARG1_PV;
d758 3
a760 1
	    if (*ARG1_PVP != ARG0_PV) {
d762 1
a762 1
		PerlMem_free(*ARG1_PVP);
d764 1
a764 1
		PerlMemShared_free(*ARG1_PVP);
d766 1
a766 1
		*ARG1_PVP = ARG0_PV;
d770 3
a772 1
	    svp = &GvSV(ARG1_GV);
d775 2
a776 1
            svp = ARG1_SVP;
d778 2
a779 3
        {
	    SV * const sv = *svp;
	    *svp = ARG0_SV;
d781 1
a781 1
	    SvREFCNT_dec(ARG0_SV);
d783 9
a791 15
        }
	case SAVEt_GVSLOT:			/* any slot in GV */
        {
            HV *const hv = GvSTASH(ARG2_GV);
	    svp = ARG1_SVP;
	    if (hv && HvENAME(hv) && (
		    (ARG0_SV && SvTYPE(ARG0_SV) == SVt_PVCV)
		 || (*svp && SvTYPE(*svp) == SVt_PVCV)
	       ))
	    {
		if ((char *)svp < (char *)GvGP(ARG2_GV)
		 || (char *)svp > (char *)GvGP(ARG2_GV) + sizeof(struct gp)
		 || GvREFCNT(ARG2_GV) > 1)
		    PL_sub_generation++;
		else mro_method_changed_in(hv);
d793 1
a793 11
	    goto restore_svp;
        }
	case SAVEt_AV:				/* array reference */
	    SvREFCNT_dec(GvAV(ARG1_GV));
	    GvAV(ARG1_GV) = ARG0_AV;
            if (SvSMAGICAL(ARG0_SV)) {
                PL_localizing = 2;
                mg_set(ARG0_SV);
                PL_localizing = 0;
            }
	    SvREFCNT_dec_NN(ARG1_GV);
d796 10
a805 8
	    SvREFCNT_dec(GvHV(ARG1_GV));
	    GvHV(ARG1_GV) = ARG0_HV;
            if (SvSMAGICAL(ARG0_SV)) {
                PL_localizing = 2;
                mg_set(ARG0_SV);
                PL_localizing = 0;
            }
	    SvREFCNT_dec_NN(ARG1_GV);
d808 2
a809 1
	    *(int*)ARG0_PTR = (int)(uv >> SAVE_TIGHT_SHIFT);
d812 2
a813 1
	    *(int*)ARG0_PTR = (int)ARG1_I32;
d816 4
a819 5
	    *(bool*)ARG0_PTR = cBOOL(uv >> 8);
#ifdef NO_TAINT_SUPPORT
            PERL_UNUSED_VAR(was);
#else
	    if (ARG0_PTR == &(TAINT_get)) {
d825 1
a825 1
		was = *(bool*)ARG0_PTR;
a826 1
#endif
d829 2
a830 1
	    *(I32*)ARG0_PTR = (I32)(uv >> SAVE_TIGHT_SHIFT);
d833 1
d835 7
a841 1
            if (*(I32*)ARG0_PTR != ARG1_I32)
a842 1
                *(I32*)ARG0_PTR = ARG1_I32;
d845 2
a846 1
	    *(SV**)(ARG0_PTR)= ARG1_SV;
d850 2
a851 1
	    *ARG0_PVP = ARG1_PV;
d854 2
a855 1
	    *(HV**)ARG0_PTR = MUTABLE_HV(ARG1_PTR);
d858 2
a859 1
	    *(AV**)ARG0_PTR = ARG1_AV;
d862 8
a869 16
        {
            HV *hv;
            /* possibly taking a method out of circulation */	
	    const bool had_method = !!GvCVu(ARG1_GV);
	    gp_free(ARG1_GV);
	    GvGP_set(ARG1_GV, (GP*)ARG0_PTR);
	    if ((hv=GvSTASH(ARG1_GV)) && HvENAME_get(hv)) {
	        if (   GvNAMELEN(ARG1_GV) == 3
                    && strnEQ(GvNAME(ARG1_GV), "ISA", 3)
                )
	            mro_isa_changed_in(hv);
                else if (had_method || GvCVu(ARG1_GV))
                    /* putting a method back into circulation ("local")*/	
                    gv_method_changed(ARG1_GV);
	    }
	    SvREFCNT_dec_NN(ARG1_GV);
a870 1
        }
d872 2
a873 1
	    SvREFCNT_dec(ARG0_SV);
d876 2
a877 1
	    cophh_free((COPHH *)ARG0_PTR);
d880 2
a881 1
	    sv_2mortal(ARG0_SV);
d884 3
a886 2
	    ASSERT_CURPAD_LEGAL("SAVEt_FREEOP");
	    op_free((OP*)ARG0_PTR);
d889 2
a890 1
	    Safefree(ARG0_PTR);
d892 3
d896 55
a950 95
        {
          SV **svp;
          I32 i;
          SV *sv;

        case SAVEt_CLEARPADRANGE:
            i = (I32)((uv >> SAVE_TIGHT_SHIFT) & OPpPADRANGE_COUNTMASK);
	    svp = &PL_curpad[uv >>
                    (OPpPADRANGE_COUNTSHIFT + SAVE_TIGHT_SHIFT)] + i - 1;
            goto clearsv;
	case SAVEt_CLEARSV:
	    svp = &PL_curpad[uv >> SAVE_TIGHT_SHIFT];
            i = 1;
          clearsv:
            for (; i; i--, svp--) {
                sv = *svp;

                DEBUG_Xv(PerlIO_printf(Perl_debug_log,
             "Pad 0x%"UVxf"[0x%"UVxf"] clearsv: %ld sv=0x%"UVxf"<%"IVdf"> %s\n",
                    PTR2UV(PL_comppad), PTR2UV(PL_curpad),
                    (long)(svp-PL_curpad), PTR2UV(sv), (IV)SvREFCNT(sv),
                    (SvREFCNT(sv) <= 1 && !SvOBJECT(sv)) ? "clear" : "abandon"
                ));

                /* Can clear pad variable in place? */
                if (SvREFCNT(sv) <= 1 && !SvOBJECT(sv)) {
                    /*
                     * if a my variable that was made readonly is going out of
                     * scope, we want to remove the readonlyness so that it can
                     * go out of scope quietly
                     */
                    if (SvPADMY(sv) && !SvFAKE(sv))
                        SvREADONLY_off(sv);

                    if (SvTHINKFIRST(sv))
                        sv_force_normal_flags(sv, SV_IMMEDIATE_UNREF
                                                 |SV_COW_DROP_PV);
                    if (SvTYPE(sv) == SVt_PVHV)
                        Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
                    if (SvMAGICAL(sv))
                    {
                      sv_unmagic(sv, PERL_MAGIC_backref);
                      if (SvTYPE(sv) != SVt_PVCV)
                        mg_free(sv);
                    }

                    switch (SvTYPE(sv)) {
                    case SVt_NULL:
                        break;
                    case SVt_PVAV:
                        av_clear(MUTABLE_AV(sv));
                        break;
                    case SVt_PVHV:
                        hv_clear(MUTABLE_HV(sv));
                        break;
                    case SVt_PVCV:
                    {
                        HEK * const hek = CvNAME_HEK((CV *)sv);
                        assert(hek);
                        share_hek_hek(hek);
                        cv_undef((CV *)sv);
                        CvNAME_HEK_set(sv, hek);
                        break;
                    }
                    default:
                        SvOK_off(sv);
                        break;
                    }
                    SvPADSTALE_on(sv); /* mark as no longer live */
                }
                else {	/* Someone has a claim on this, so abandon it. */
                    assert(  SvFLAGS(sv) & SVs_PADMY);
                    assert(!(SvFLAGS(sv) & SVs_PADTMP));
                    switch (SvTYPE(sv)) {	/* Console ourselves with a new value */
                    case SVt_PVAV:	*svp = MUTABLE_SV(newAV());	break;
                    case SVt_PVHV:	*svp = MUTABLE_SV(newHV());	break;
                    case SVt_PVCV:
                    {
                        /* Create a stub */
                        *svp = newSV_type(SVt_PVCV);

                        /* Share name */
                        assert(CvNAMED(sv));
                        CvNAME_HEK_set(*svp,
                            share_hek_hek(CvNAME_HEK((CV *)sv)));
                        break;
                    }
                    default:	*svp = newSV(0);		break;
                    }
                    SvREFCNT_dec_NN(sv); /* Cast current value to the winds. */
                    /* preserve pad nature, but also mark as not live
                     * for any closure capturing */
                    SvFLAGS(*svp) |= (SVs_PADMY|SVs_PADSTALE);
                }
            }
a951 1
        }
d953 7
a959 3
	    (void)hv_delete(ARG0_HV, ARG2_PV, ARG1_I32, G_DISCARD);
	    SvREFCNT_dec(ARG0_HV);
	    Safefree(arg2.any_ptr);
d962 5
a966 2
	    (void)av_delete(ARG0_AV, ARG1_I32, G_DISCARD);
	    SvREFCNT_dec(ARG0_AV);
d969 2
a970 1
	    (*arg1.any_dxptr)(aTHX_ ARG0_PTR);
d978 2
a979 1
	    PL_stack_sp = PL_stack_base + arg0.any_i32;
d982 2
a983 1
	    cxstack[ARG0_I32].blk_oldsp = ARG1_I32;
d986 8
a993 5
	    svp = av_fetch(ARG2_AV, ARG1_I32, 1);
	    if (!AvREAL(ARG2_AV) && AvREIFY(ARG2_AV)) /* undo reify guard */
		SvREFCNT_dec(ARG0_SV);
	    if (svp) {
		SV * const sv = *svp;
d995 1
a995 1
		    if (SvTIED_mg((const SV *)ARG2_AV, PERL_MAGIC_tied))
a996 1
                    refsv = ARG2_SV;
d1000 2
a1001 2
	    SvREFCNT_dec(ARG2_AV);
	    SvREFCNT_dec(ARG0_SV);
d1004 7
a1010 5
        {
	    HE * const he = hv_fetch_ent(ARG2_HV, ARG1_SV, 1, 0);
	    SvREFCNT_dec(ARG1_SV);
	    if (he) {
		const SV * const oval = HeVAL(he);
d1012 4
a1015 4
		    svp = &HeVAL(he);
		    if (SvTIED_mg((const SV *)ARG2_HV, PERL_MAGIC_tied))
			SvREFCNT_inc_void(*svp);
		    refsv = ARG2_SV; /* what to refcnt_dec */
d1019 2
a1020 2
	    SvREFCNT_dec(ARG2_HV);
	    SvREFCNT_dec(ARG0_SV);
a1021 1
        }
d1023 1
a1023 1
	    PL_op = (OP*)ARG0_PTR;
d1034 2
a1035 2
	    CopHINTHASH_set(&PL_compiling, (COPHH*)ARG0_PTR);
	    *(I32*)&PL_hints = ARG1_I32;
d1041 15
a1055 2
		/* Need to add a new one manually, else rv2hv can
		   add one via GvHVn and it won't have the magic set.  */
d1063 1
a1063 1
	    PL_comppad = (PAD*)ARG0_PTR;
d1071 1
d1073 3
a1075 2
		assert (ARG1_PTR);
		svp = AvARRAY((PAD*)ARG1_PTR) + (PADOFFSET)arg0.any_uv;
d1080 1
a1080 1
		*svp = ARG2_SV;
d1086 4
a1089 2
		SWITCHSTACK(ARG0_AV, ARG1_AV);
		PL_curstackinfo->si_stack = ARG1_AV;
d1093 7
a1099 2
            SvFLAGS(ARG2_SV) &= ~((U32)ARG1_I32);
            SvFLAGS(ARG2_SV) |= (U32)ARG0_I32;
d1102 8
d1112 2
a1113 1
	    (void)sv_clear(ARG0_SV);
d1116 2
a1117 1
	    *(long*)ARG0_PTR = arg1.any_long;
d1120 2
a1121 1
	    *(IV*)ARG0_PTR = arg1.any_iv;
d1125 2
a1126 1
	    *(I16*)ARG0_PTR = (I16)(uv >> 8);
d1129 2
a1130 1
	    *(I8*)ARG0_PTR = (I8)(uv >> 8);
d1133 2
a1134 1
	    (*arg1.any_dptr)(ARG0_PTR);
d1137 2
d1142 1
a1142 1
	    PL_compiling.cop_warnings = (STRLEN*)ARG0_PTR;
d1152 3
d1162 2
a1163 1
	    parser_free((yy_parser *) ARG0_PTR);
d1170 3
a1172 1
    TAINT_set(was);
a1184 1
	const char *gimme_text;
d1192 1
a1192 15
	switch (cx->blk_gimme) {
	    case G_VOID:
		gimme_text = "VOID";
		break;
	    case G_SCALAR:
		gimme_text = "SCALAR";
		break;
	    case G_ARRAY:
		gimme_text = "LIST";
		break;
	    default:
		gimme_text = "UNKNOWN";
		break;
	}
	PerlIO_printf(Perl_debug_log, "BLK_GIMME = %s\n", gimme_text);
d1289 1
a1289 1
 * indent-tabs-mode: nil
d1292 1
a1292 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d30 1
a30 1
Perl_stack_grow(pTHX_ SV **sp, SV **p, SSize_t n)
d91 1
a91 1
    if (UNLIKELY(PL_scopestack_ix == PL_scopestack_max)) {
d144 1
a144 1
Perl_tmps_grow(pTHX_ SSize_t n)
d161 1
a161 1
    const SSize_t myfloor = PL_tmps_floor;
d167 1
a167 1
	if (LIKELY(sv && sv != &PL_sv_undef)) {
d217 1
a217 1
    if (UNLIKELY(SvGMAGICAL(*sptr))) {
d324 1
a324 1
    if (UNLIKELY(!AvREAL(oav) && AvREIFY(oav)))
d330 1
a330 1
    if (UNLIKELY(SvMAGIC(oav)))
d349 1
a349 1
    if (UNLIKELY(SvMAGIC(ohv)))
d403 1
a403 1
    if (UNLIKELY((int)(type >> SAVE_TIGHT_SHIFT) != i)) {
d450 1
a450 1
    if (UNLIKELY((I32)(type >> SAVE_TIGHT_SHIFT) != i)) {
a459 14
void
Perl_save_strlen(pTHX_ STRLEN *ptr)
{
    dVAR;
    dSS_ADD;

    PERL_ARGS_ASSERT_SAVE_STRLEN;

    SS_ADD_IV(*ptr);
    SS_ADD_PTR(ptr);
    SS_ADD_UV(SAVEt_STRLEN);
    SS_ADD_END(3);
}

d548 1
a548 1
    if (UNLIKELY((offset_shifted >> SAVE_TIGHT_SHIFT) != offset)) {
d586 1
a586 1
Perl_save_adelete(pTHX_ AV *av, SSize_t key)
a588 1
    dSS_ADD;
d593 1
a593 4
    SS_ADD_UV(key);
    SS_ADD_PTR(av);
    SS_ADD_IV(SAVEt_ADELETE);
    SS_ADD_END(3);
d650 1
a650 2
Perl_save_aelem_flags(pTHX_ AV *av, SSize_t idx, SV **sptr,
			    const U32 flags)
d652 1
a652 1
    dVAR; dSS_ADD;
d658 2
a659 5
    SS_ADD_PTR(SvREFCNT_inc_simple(av));
    SS_ADD_IV(idx);
    SS_ADD_PTR(SvREFCNT_inc(*sptr));
    SS_ADD_UV(SAVEt_AELEM);
    SS_ADD_END(4);
d662 1
a662 1
    if (UNLIKELY(!AvREAL(av) && AvREIFY(av)))
d672 1
a672 1
    if (UNLIKELY(SvTIED_mg((const SV *)av, PERL_MAGIC_tied)))
d701 1
a701 1
    if (UNLIKELY(SvTIED_mg((const SV *)hv, PERL_MAGIC_tied)))
d726 1
a726 1
    if (UNLIKELY((elems_shifted >> SAVE_TIGHT_SHIFT) != elems))
d779 1
a779 1
    if (UNLIKELY(base < -1))
d814 1
a814 1
            if (UNLIKELY(SvSMAGICAL(ARG1_SV))) {
d836 1
a836 1
            if (UNLIKELY(SvSMAGICAL(ARG0_SV))) {
d894 1
a894 1
            if (UNLIKELY(SvSMAGICAL(ARG0_SV))) {
d904 1
a904 1
            if (UNLIKELY(SvSMAGICAL(ARG0_SV))) {
a916 3
	case SAVEt_STRLEN:			/* STRLEN/size_t ref */
	    *(STRLEN*)ARG0_PTR = (STRLEN)arg1.any_iv;
	    break;
d922 1
a922 1
	    if (UNLIKELY(ARG0_PTR == &(TAINT_get))) {
a1013 2
                assert(SvPADMY(sv));

d1015 15
a1029 9
                if (SvREFCNT(sv) == 1 && !SvOBJECT(sv)) {

                    /* these flags are the union of all the relevant flags
                     * in the individual conditions within */
                    if (UNLIKELY(SvFLAGS(sv) & (
                            SVf_READONLY /* for SvREADONLY_off() */
                          | (SVs_GMG|SVs_SMG|SVs_RMG) /* SvMAGICAL() */
                          | SVf_OOK
                          | SVf_THINKFIRST)))
d1031 4
a1034 25
                        /* if a my variable that was made readonly is
                         * going out of scope, we want to remove the
                         * readonlyness so that it can go out of scope
                         * quietly
                         */
                        if (SvREADONLY(sv) && !SvFAKE(sv))
                            SvREADONLY_off(sv);

                        if (SvOOK(sv)) { /* OOK or HvAUX */
                            if (SvTYPE(sv) == SVt_PVHV)
                                Perl_hv_kill_backrefs(aTHX_ MUTABLE_HV(sv));
                            else
                                sv_backoff(sv);
                        }

                        if (SvMAGICAL(sv)) {
                            /* note that backrefs (either in HvAUX or magic)
                             * must be removed before other magic */
                            sv_unmagic(sv, PERL_MAGIC_backref);
                            if (SvTYPE(sv) != SVt_PVCV)
                                mg_free(sv);
                        }
                        if (SvTHINKFIRST(sv))
                            sv_force_normal_flags(sv, SV_IMMEDIATE_UNREF
                                                     |SV_COW_DROP_PV);
a1035 1
                    }
d1055 1
a1055 6
                        /* This looks odd, but these two macros are for use in
                           expressions and finish with a trailing comma, so
                           adding a ; after them would be wrong. */
                        assert_not_ROK(sv)
                        assert_not_glob(sv)
                        SvFLAGS(sv) &=~ (SVf_OK|SVf_IVisUV|SVf_UTF8);
d1093 1
a1093 1
	    (void)av_delete(ARG0_AV, arg1.any_iv, G_DISCARD);
d1107 3
d1111 2
a1112 2
	    svp = av_fetch(ARG2_AV, arg1.any_iv, 1);
	    if (UNLIKELY(!AvREAL(ARG2_AV) && AvREIFY(ARG2_AV))) /* undo reify guard */
d1114 1
a1114 1
	    if (LIKELY(svp)) {
d1116 2
a1117 2
		if (LIKELY(sv && sv != &PL_sv_undef)) {
		    if (UNLIKELY(SvTIED_mg((const SV *)ARG2_AV, PERL_MAGIC_tied)))
d1130 1
a1130 1
	    if (LIKELY(he)) {
d1132 1
a1132 1
		if (LIKELY(oval && oval != &PL_sv_undef)) {
d1134 1
a1134 1
		    if (UNLIKELY(SvTIED_mg((const SV *)ARG2_HV, PERL_MAGIC_tied)))
d1173 1
a1173 1
	    if (LIKELY(PL_comppad))
d1228 14
a1243 3
	    break;
	case SAVEt_READONLY_OFF:
	    SvREADONLY_off(ARG0_SV);
@


