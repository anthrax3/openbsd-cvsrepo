head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.6
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.11
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.10.0.10
	OPENBSD_6_0_BASE:1.1.1.10
	OPENBSD_5_9:1.1.1.10.0.4
	OPENBSD_5_9_BASE:1.1.1.10
	OPENBSD_5_8:1.1.1.10.0.6
	OPENBSD_5_8_BASE:1.1.1.10
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.1.1.10.0.2
	OPENBSD_5_7_BASE:1.1.1.10
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.1.1.9.0.4
	OPENBSD_5_6_BASE:1.1.1.9
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.8.0.6
	OPENBSD_5_5_BASE:1.1.1.8
	OPENBSD_5_4:1.1.1.8.0.2
	OPENBSD_5_4_BASE:1.1.1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.8
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.4
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.14
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.12
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.10
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.8
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.6
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	99.04.29.22.37.55;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.37.55;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.08.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.22.22;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.47.43;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.17;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.06.40;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.58.47;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	1.1.1.11;
commitid	B31cAbBIXiCqnL97;

1.1.1.11
date	2017.08.14.13.45.30;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regen/regcomp.pl from regcomp.sym.
   Any changes made here will be lost!
 */

/* Regops and State definitions */

#define REGNODE_MAX           	92
#define REGMATCH_STATE_MAX    	132

#define	END                   	0	/* 0000 End of program. */
#define	SUCCEED               	1	/* 0x01 Return from a subroutine, basically. */
#define	SBOL                  	2	/* 0x02 Match "" at beginning of line: /^/, /\A/ */
#define	BOL                   	2	/* 0x02 type alias */
#define	MBOL                  	3	/* 0x03 Same, assuming multiline: /^/m */
#define	SEOL                  	4	/* 0x04 Match "" at end of line: /$/ */
#define	EOL                   	4	/* 0x04 type alias */
#define	MEOL                  	5	/* 0x05 Same, assuming multiline: /$/m */
#define	EOS                   	6	/* 0x06 Match "" at end of string: /\z/ */
#define	GPOS                  	7	/* 0x07 Matches where last m//g left off. */
#define	BOUND                 	8	/* 0x08 Like BOUNDA for non-utf8, otherwise match "" between any Unicode \w\W or \W\w */
#define	BOUNDL                	9	/* 0x09 Like BOUND/BOUNDU, but \w and \W are defined by current locale */
#define	BOUNDU                	10	/* 0x0a Match "" at any boundary of a given type using Unicode rules */
#define	BOUNDA                	11	/* 0x0b Match "" at any boundary between \w\W or \W\w, where \w is [_a-zA-Z0-9] */
#define	NBOUND                	12	/* 0x0c Like NBOUNDA for non-utf8, otherwise match "" between any Unicode \w\w or \W\W */
#define	NBOUNDL               	13	/* 0x0d Like NBOUND/NBOUNDU, but \w and \W are defined by current locale */
#define	NBOUNDU               	14	/* 0x0e Match "" at any non-boundary of a given type using using Unicode rules */
#define	NBOUNDA               	15	/* 0x0f Match "" betweeen any \w\w or \W\W, where \w is [_a-zA-Z0-9] */
#define	REG_ANY               	16	/* 0x10 Match any one character (except newline). */
#define	SANY                  	17	/* 0x11 Match any one character. */
#define	ANYOF                 	18	/* 0x12 Match character in (or not in) this class, single char match only */
#define	ANYOFD                	19	/* 0x13 Like ANYOF, but /d is in effect */
#define	ANYOFL                	20	/* 0x14 Like ANYOF, but /l is in effect */
#define	POSIXD                	21	/* 0x15 Some [[:class:]] under /d; the FLAGS field gives which one */
#define	POSIXL                	22	/* 0x16 Some [[:class:]] under /l; the FLAGS field gives which one */
#define	POSIXU                	23	/* 0x17 Some [[:class:]] under /u; the FLAGS field gives which one */
#define	POSIXA                	24	/* 0x18 Some [[:class:]] under /a; the FLAGS field gives which one */
#define	NPOSIXD               	25	/* 0x19 complement of POSIXD, [[:^class:]] */
#define	NPOSIXL               	26	/* 0x1a complement of POSIXL, [[:^class:]] */
#define	NPOSIXU               	27	/* 0x1b complement of POSIXU, [[:^class:]] */
#define	NPOSIXA               	28	/* 0x1c complement of POSIXA, [[:^class:]] */
#define	CLUMP                 	29	/* 0x1d Match any extended grapheme cluster sequence */
#define	BRANCH                	30	/* 0x1e Match this alternative, or the next... */
#define	EXACT                 	31	/* 0x1f Match this string (preceded by length). */
#define	EXACTL                	32	/* 0x20 Like EXACT, but /l is in effect (used so locale-related warnings can be checked for). */
#define	EXACTF                	33	/* 0x21 Match this non-UTF-8 string (not guaranteed to be folded) using /id rules (w/len). */
#define	EXACTFL               	34	/* 0x22 Match this string (not guaranteed to be folded) using /il rules (w/len). */
#define	EXACTFU               	35	/* 0x23 Match this string (folded iff in UTF-8, length in folding doesn't change if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFA               	36	/* 0x24 Match this string (not guaranteed to be folded) using /iaa rules (w/len). */
#define	EXACTFU_SS            	37	/* 0x25 Match this string (folded iff in UTF-8, length in folding may change even if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFLU8             	38	/* 0x26 Rare cirucmstances: like EXACTFU, but is under /l, UTF-8, folded, and everything in it is above 255. */
#define	EXACTFA_NO_TRIE       	39	/* 0x27 Match this string (which is not trie-able; not guaranteed to be folded) using /iaa rules (w/len). */
#define	NOTHING               	40	/* 0x28 Match empty string. */
#define	TAIL                  	41	/* 0x29 Match empty string. Can jump here from outside. */
#define	STAR                  	42	/* 0x2a Match this (simple) thing 0 or more times. */
#define	PLUS                  	43	/* 0x2b Match this (simple) thing 1 or more times. */
#define	CURLY                 	44	/* 0x2c Match this simple thing {n,m} times. */
#define	CURLYN                	45	/* 0x2d Capture next-after-this simple thing */
#define	CURLYM                	46	/* 0x2e Capture this medium-complex thing {n,m} times. */
#define	CURLYX                	47	/* 0x2f Match this complex thing {n,m} times. */
#define	WHILEM                	48	/* 0x30 Do curly processing and see if rest matches. */
#define	OPEN                  	49	/* 0x31 Mark this point in input as start of #n. */
#define	CLOSE                 	50	/* 0x32 Analogous to OPEN. */
#define	REF                   	51	/* 0x33 Match some already matched string */
#define	REFF                  	52	/* 0x34 Match already matched string, folded using native charset rules for non-utf8 */
#define	REFFL                 	53	/* 0x35 Match already matched string, folded in loc. */
#define	REFFU                 	54	/* 0x36 Match already matched string, folded using unicode rules for non-utf8 */
#define	REFFA                 	55	/* 0x37 Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII */
#define	NREF                  	56	/* 0x38 Match some already matched string */
#define	NREFF                 	57	/* 0x39 Match already matched string, folded using native charset rules for non-utf8 */
#define	NREFFL                	58	/* 0x3a Match already matched string, folded in loc. */
#define	NREFFU                	59	/* 0x3b Match already matched string, folded using unicode rules for non-utf8 */
#define	NREFFA                	60	/* 0x3c Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII */
#define	LONGJMP               	61	/* 0x3d Jump far away. */
#define	BRANCHJ               	62	/* 0x3e BRANCH with long offset. */
#define	IFMATCH               	63	/* 0x3f Succeeds if the following matches. */
#define	UNLESSM               	64	/* 0x40 Fails if the following matches. */
#define	SUSPEND               	65	/* 0x41 "Independent" sub-RE. */
#define	IFTHEN                	66	/* 0x42 Switch, should be preceded by switcher. */
#define	GROUPP                	67	/* 0x43 Whether the group matched. */
#define	EVAL                  	68	/* 0x44 Execute some Perl code. */
#define	MINMOD                	69	/* 0x45 Next operator is not greedy. */
#define	LOGICAL               	70	/* 0x46 Next opcode should set the flag only. */
#define	RENUM                 	71	/* 0x47 Group with independently numbered parens. */
#define	TRIE                  	72	/* 0x48 Match many EXACT(F[ALU]?)? at once. flags==type */
#define	TRIEC                 	73	/* 0x49 Same as TRIE, but with embedded charclass data */
#define	AHOCORASICK           	74	/* 0x4a Aho Corasick stclass. flags==type */
#define	AHOCORASICKC          	75	/* 0x4b Same as AHOCORASICK, but with embedded charclass data */
#define	GOSUB                 	76	/* 0x4c recurse to paren arg1 at (signed) ofs arg2 */
#define	NGROUPP               	77	/* 0x4d Whether the group matched. */
#define	INSUBP                	78	/* 0x4e Whether we are in a specific recurse. */
#define	DEFINEP               	79	/* 0x4f Never execute directly. */
#define	ENDLIKE               	80	/* 0x50 Used only for the type field of verbs */
#define	OPFAIL                	81	/* 0x51 Same as (?!), but with verb arg */
#define	ACCEPT                	82	/* 0x52 Accepts the current matched string, with verbar */
#define	VERB                  	83	/* 0x53 Used only for the type field of verbs */
#define	PRUNE                 	84	/* 0x54 Pattern fails at this startpoint if no-backtracking through this */
#define	MARKPOINT             	85	/* 0x55 Push the current location for rollback by cut. */
#define	SKIP                  	86	/* 0x56 On failure skip forward (to the mark) before retrying */
#define	COMMIT                	87	/* 0x57 Pattern fails outright if backtracking through this */
#define	CUTGROUP              	88	/* 0x58 On failure go to the next alternation in the group */
#define	KEEPS                 	89	/* 0x59 $& begins here. */
#define	LNBREAK               	90	/* 0x5a generic newline pattern */
#define	OPTIMIZED             	91	/* 0x5b Placeholder for dump. */
#define	PSEUDO                	92	/* 0x5c Pseudo opcode for internal use. */
	/* ------------ States ------------- */
#define	TRIE_next             	(REGNODE_MAX + 1)	/* state for TRIE */
#define	TRIE_next_fail        	(REGNODE_MAX + 2)	/* state for TRIE */
#define	EVAL_AB               	(REGNODE_MAX + 3)	/* state for EVAL */
#define	EVAL_AB_fail          	(REGNODE_MAX + 4)	/* state for EVAL */
#define	CURLYX_end            	(REGNODE_MAX + 5)	/* state for CURLYX */
#define	CURLYX_end_fail       	(REGNODE_MAX + 6)	/* state for CURLYX */
#define	WHILEM_A_pre          	(REGNODE_MAX + 7)	/* state for WHILEM */
#define	WHILEM_A_pre_fail     	(REGNODE_MAX + 8)	/* state for WHILEM */
#define	WHILEM_A_min          	(REGNODE_MAX + 9)	/* state for WHILEM */
#define	WHILEM_A_min_fail     	(REGNODE_MAX + 10)	/* state for WHILEM */
#define	WHILEM_A_max          	(REGNODE_MAX + 11)	/* state for WHILEM */
#define	WHILEM_A_max_fail     	(REGNODE_MAX + 12)	/* state for WHILEM */
#define	WHILEM_B_min          	(REGNODE_MAX + 13)	/* state for WHILEM */
#define	WHILEM_B_min_fail     	(REGNODE_MAX + 14)	/* state for WHILEM */
#define	WHILEM_B_max          	(REGNODE_MAX + 15)	/* state for WHILEM */
#define	WHILEM_B_max_fail     	(REGNODE_MAX + 16)	/* state for WHILEM */
#define	BRANCH_next           	(REGNODE_MAX + 17)	/* state for BRANCH */
#define	BRANCH_next_fail      	(REGNODE_MAX + 18)	/* state for BRANCH */
#define	CURLYM_A              	(REGNODE_MAX + 19)	/* state for CURLYM */
#define	CURLYM_A_fail         	(REGNODE_MAX + 20)	/* state for CURLYM */
#define	CURLYM_B              	(REGNODE_MAX + 21)	/* state for CURLYM */
#define	CURLYM_B_fail         	(REGNODE_MAX + 22)	/* state for CURLYM */
#define	IFMATCH_A             	(REGNODE_MAX + 23)	/* state for IFMATCH */
#define	IFMATCH_A_fail        	(REGNODE_MAX + 24)	/* state for IFMATCH */
#define	CURLY_B_min_known     	(REGNODE_MAX + 25)	/* state for CURLY */
#define	CURLY_B_min_known_fail	(REGNODE_MAX + 26)	/* state for CURLY */
#define	CURLY_B_min           	(REGNODE_MAX + 27)	/* state for CURLY */
#define	CURLY_B_min_fail      	(REGNODE_MAX + 28)	/* state for CURLY */
#define	CURLY_B_max           	(REGNODE_MAX + 29)	/* state for CURLY */
#define	CURLY_B_max_fail      	(REGNODE_MAX + 30)	/* state for CURLY */
#define	COMMIT_next           	(REGNODE_MAX + 31)	/* state for COMMIT */
#define	COMMIT_next_fail      	(REGNODE_MAX + 32)	/* state for COMMIT */
#define	MARKPOINT_next        	(REGNODE_MAX + 33)	/* state for MARKPOINT */
#define	MARKPOINT_next_fail   	(REGNODE_MAX + 34)	/* state for MARKPOINT */
#define	SKIP_next             	(REGNODE_MAX + 35)	/* state for SKIP */
#define	SKIP_next_fail        	(REGNODE_MAX + 36)	/* state for SKIP */
#define	CUTGROUP_next         	(REGNODE_MAX + 37)	/* state for CUTGROUP */
#define	CUTGROUP_next_fail    	(REGNODE_MAX + 38)	/* state for CUTGROUP */
#define	KEEPS_next            	(REGNODE_MAX + 39)	/* state for KEEPS */
#define	KEEPS_next_fail       	(REGNODE_MAX + 40)	/* state for KEEPS */

/* PL_regkind[] What type of regop or state is this. */

#ifndef DOINIT
EXTCONST U8 PL_regkind[];
#else
EXTCONST U8 PL_regkind[] = {
	END,      	/* END                    */
	END,      	/* SUCCEED                */
	BOL,      	/* SBOL                   */
	BOL,      	/* MBOL                   */
	EOL,      	/* SEOL                   */
	EOL,      	/* MEOL                   */
	EOL,      	/* EOS                    */
	GPOS,     	/* GPOS                   */
	BOUND,    	/* BOUND                  */
	BOUND,    	/* BOUNDL                 */
	BOUND,    	/* BOUNDU                 */
	BOUND,    	/* BOUNDA                 */
	NBOUND,   	/* NBOUND                 */
	NBOUND,   	/* NBOUNDL                */
	NBOUND,   	/* NBOUNDU                */
	NBOUND,   	/* NBOUNDA                */
	REG_ANY,  	/* REG_ANY                */
	REG_ANY,  	/* SANY                   */
	ANYOF,    	/* ANYOF                  */
	ANYOF,    	/* ANYOFD                 */
	ANYOF,    	/* ANYOFL                 */
	POSIXD,   	/* POSIXD                 */
	POSIXD,   	/* POSIXL                 */
	POSIXD,   	/* POSIXU                 */
	POSIXD,   	/* POSIXA                 */
	NPOSIXD,  	/* NPOSIXD                */
	NPOSIXD,  	/* NPOSIXL                */
	NPOSIXD,  	/* NPOSIXU                */
	NPOSIXD,  	/* NPOSIXA                */
	CLUMP,    	/* CLUMP                  */
	BRANCH,   	/* BRANCH                 */
	EXACT,    	/* EXACT                  */
	EXACT,    	/* EXACTL                 */
	EXACT,    	/* EXACTF                 */
	EXACT,    	/* EXACTFL                */
	EXACT,    	/* EXACTFU                */
	EXACT,    	/* EXACTFA                */
	EXACT,    	/* EXACTFU_SS             */
	EXACT,    	/* EXACTFLU8              */
	EXACT,    	/* EXACTFA_NO_TRIE        */
	NOTHING,  	/* NOTHING                */
	NOTHING,  	/* TAIL                   */
	STAR,     	/* STAR                   */
	PLUS,     	/* PLUS                   */
	CURLY,    	/* CURLY                  */
	CURLY,    	/* CURLYN                 */
	CURLY,    	/* CURLYM                 */
	CURLY,    	/* CURLYX                 */
	WHILEM,   	/* WHILEM                 */
	OPEN,     	/* OPEN                   */
	CLOSE,    	/* CLOSE                  */
	REF,      	/* REF                    */
	REF,      	/* REFF                   */
	REF,      	/* REFFL                  */
	REF,      	/* REFFU                  */
	REF,      	/* REFFA                  */
	REF,      	/* NREF                   */
	REF,      	/* NREFF                  */
	REF,      	/* NREFFL                 */
	REF,      	/* NREFFU                 */
	REF,      	/* NREFFA                 */
	LONGJMP,  	/* LONGJMP                */
	BRANCHJ,  	/* BRANCHJ                */
	BRANCHJ,  	/* IFMATCH                */
	BRANCHJ,  	/* UNLESSM                */
	BRANCHJ,  	/* SUSPEND                */
	BRANCHJ,  	/* IFTHEN                 */
	GROUPP,   	/* GROUPP                 */
	EVAL,     	/* EVAL                   */
	MINMOD,   	/* MINMOD                 */
	LOGICAL,  	/* LOGICAL                */
	BRANCHJ,  	/* RENUM                  */
	TRIE,     	/* TRIE                   */
	TRIE,     	/* TRIEC                  */
	TRIE,     	/* AHOCORASICK            */
	TRIE,     	/* AHOCORASICKC           */
	GOSUB,    	/* GOSUB                  */
	NGROUPP,  	/* NGROUPP                */
	INSUBP,   	/* INSUBP                 */
	DEFINEP,  	/* DEFINEP                */
	ENDLIKE,  	/* ENDLIKE                */
	ENDLIKE,  	/* OPFAIL                 */
	ENDLIKE,  	/* ACCEPT                 */
	VERB,     	/* VERB                   */
	VERB,     	/* PRUNE                  */
	VERB,     	/* MARKPOINT              */
	VERB,     	/* SKIP                   */
	VERB,     	/* COMMIT                 */
	VERB,     	/* CUTGROUP               */
	KEEPS,    	/* KEEPS                  */
	LNBREAK,  	/* LNBREAK                */
	NOTHING,  	/* OPTIMIZED              */
	PSEUDO,   	/* PSEUDO                 */
	/* ------------ States ------------- */
	TRIE,     	/* TRIE_next              */
	TRIE,     	/* TRIE_next_fail         */
	EVAL,     	/* EVAL_AB                */
	EVAL,     	/* EVAL_AB_fail           */
	CURLYX,   	/* CURLYX_end             */
	CURLYX,   	/* CURLYX_end_fail        */
	WHILEM,   	/* WHILEM_A_pre           */
	WHILEM,   	/* WHILEM_A_pre_fail      */
	WHILEM,   	/* WHILEM_A_min           */
	WHILEM,   	/* WHILEM_A_min_fail      */
	WHILEM,   	/* WHILEM_A_max           */
	WHILEM,   	/* WHILEM_A_max_fail      */
	WHILEM,   	/* WHILEM_B_min           */
	WHILEM,   	/* WHILEM_B_min_fail      */
	WHILEM,   	/* WHILEM_B_max           */
	WHILEM,   	/* WHILEM_B_max_fail      */
	BRANCH,   	/* BRANCH_next            */
	BRANCH,   	/* BRANCH_next_fail       */
	CURLYM,   	/* CURLYM_A               */
	CURLYM,   	/* CURLYM_A_fail          */
	CURLYM,   	/* CURLYM_B               */
	CURLYM,   	/* CURLYM_B_fail          */
	IFMATCH,  	/* IFMATCH_A              */
	IFMATCH,  	/* IFMATCH_A_fail         */
	CURLY,    	/* CURLY_B_min_known      */
	CURLY,    	/* CURLY_B_min_known_fail */
	CURLY,    	/* CURLY_B_min            */
	CURLY,    	/* CURLY_B_min_fail       */
	CURLY,    	/* CURLY_B_max            */
	CURLY,    	/* CURLY_B_max_fail       */
	COMMIT,   	/* COMMIT_next            */
	COMMIT,   	/* COMMIT_next_fail       */
	MARKPOINT,	/* MARKPOINT_next         */
	MARKPOINT,	/* MARKPOINT_next_fail    */
	SKIP,     	/* SKIP_next              */
	SKIP,     	/* SKIP_next_fail         */
	CUTGROUP, 	/* CUTGROUP_next          */
	CUTGROUP, 	/* CUTGROUP_next_fail     */
	KEEPS,    	/* KEEPS_next             */
	KEEPS,    	/* KEEPS_next_fail        */
};
#endif

#ifdef REG_COMP_C

/* regarglen[] - How large is the argument part of the node (in regnodes) */

static const U8 regarglen[] = {
	0,                                   	/* END          */
	0,                                   	/* SUCCEED      */
	0,                                   	/* SBOL         */
	0,                                   	/* MBOL         */
	0,                                   	/* SEOL         */
	0,                                   	/* MEOL         */
	0,                                   	/* EOS          */
	0,                                   	/* GPOS         */
	0,                                   	/* BOUND        */
	0,                                   	/* BOUNDL       */
	0,                                   	/* BOUNDU       */
	0,                                   	/* BOUNDA       */
	0,                                   	/* NBOUND       */
	0,                                   	/* NBOUNDL      */
	0,                                   	/* NBOUNDU      */
	0,                                   	/* NBOUNDA      */
	0,                                   	/* REG_ANY      */
	0,                                   	/* SANY         */
	EXTRA_SIZE(struct regnode_1),        	/* ANYOF        */
	EXTRA_SIZE(struct regnode_1),        	/* ANYOFD       */
	EXTRA_SIZE(struct regnode_1),        	/* ANYOFL       */
	0,                                   	/* POSIXD       */
	0,                                   	/* POSIXL       */
	0,                                   	/* POSIXU       */
	0,                                   	/* POSIXA       */
	0,                                   	/* NPOSIXD      */
	0,                                   	/* NPOSIXL      */
	0,                                   	/* NPOSIXU      */
	0,                                   	/* NPOSIXA      */
	0,                                   	/* CLUMP        */
	0,                                   	/* BRANCH       */
	0,                                   	/* EXACT        */
	0,                                   	/* EXACTL       */
	0,                                   	/* EXACTF       */
	0,                                   	/* EXACTFL      */
	0,                                   	/* EXACTFU      */
	0,                                   	/* EXACTFA      */
	0,                                   	/* EXACTFU_SS   */
	0,                                   	/* EXACTFLU8    */
	0,                                   	/* EXACTFA_NO_TRIE */
	0,                                   	/* NOTHING      */
	0,                                   	/* TAIL         */
	0,                                   	/* STAR         */
	0,                                   	/* PLUS         */
	EXTRA_SIZE(struct regnode_2),        	/* CURLY        */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYN       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYM       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYX       */
	0,                                   	/* WHILEM       */
	EXTRA_SIZE(struct regnode_1),        	/* OPEN         */
	EXTRA_SIZE(struct regnode_1),        	/* CLOSE        */
	EXTRA_SIZE(struct regnode_1),        	/* REF          */
	EXTRA_SIZE(struct regnode_1),        	/* REFF         */
	EXTRA_SIZE(struct regnode_1),        	/* REFFL        */
	EXTRA_SIZE(struct regnode_1),        	/* REFFU        */
	EXTRA_SIZE(struct regnode_1),        	/* REFFA        */
	EXTRA_SIZE(struct regnode_1),        	/* NREF         */
	EXTRA_SIZE(struct regnode_1),        	/* NREFF        */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFL       */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFU       */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFA       */
	EXTRA_SIZE(struct regnode_1),        	/* LONGJMP      */
	EXTRA_SIZE(struct regnode_1),        	/* BRANCHJ      */
	EXTRA_SIZE(struct regnode_1),        	/* IFMATCH      */
	EXTRA_SIZE(struct regnode_1),        	/* UNLESSM      */
	EXTRA_SIZE(struct regnode_1),        	/* SUSPEND      */
	EXTRA_SIZE(struct regnode_1),        	/* IFTHEN       */
	EXTRA_SIZE(struct regnode_1),        	/* GROUPP       */
	EXTRA_SIZE(struct regnode_2L),       	/* EVAL         */
	0,                                   	/* MINMOD       */
	0,                                   	/* LOGICAL      */
	EXTRA_SIZE(struct regnode_1),        	/* RENUM        */
	EXTRA_SIZE(struct regnode_1),        	/* TRIE         */
	EXTRA_SIZE(struct regnode_charclass),	/* TRIEC        */
	EXTRA_SIZE(struct regnode_1),        	/* AHOCORASICK  */
	EXTRA_SIZE(struct regnode_charclass),	/* AHOCORASICKC */
	EXTRA_SIZE(struct regnode_2L),       	/* GOSUB        */
	EXTRA_SIZE(struct regnode_1),        	/* NGROUPP      */
	EXTRA_SIZE(struct regnode_1),        	/* INSUBP       */
	EXTRA_SIZE(struct regnode_1),        	/* DEFINEP      */
	0,                                   	/* ENDLIKE      */
	EXTRA_SIZE(struct regnode_1),        	/* OPFAIL       */
	EXTRA_SIZE(struct regnode_2L),       	/* ACCEPT       */
	EXTRA_SIZE(struct regnode_1),        	/* VERB         */
	EXTRA_SIZE(struct regnode_1),        	/* PRUNE        */
	EXTRA_SIZE(struct regnode_1),        	/* MARKPOINT    */
	EXTRA_SIZE(struct regnode_1),        	/* SKIP         */
	EXTRA_SIZE(struct regnode_1),        	/* COMMIT       */
	EXTRA_SIZE(struct regnode_1),        	/* CUTGROUP     */
	0,                                   	/* KEEPS        */
	0,                                   	/* LNBREAK      */
	0,                                   	/* OPTIMIZED    */
	0,                                   	/* PSEUDO       */
};

/* reg_off_by_arg[] - Which argument holds the offset to the next node */

static const char reg_off_by_arg[] = {
	0,	/* END          */
	0,	/* SUCCEED      */
	0,	/* SBOL         */
	0,	/* MBOL         */
	0,	/* SEOL         */
	0,	/* MEOL         */
	0,	/* EOS          */
	0,	/* GPOS         */
	0,	/* BOUND        */
	0,	/* BOUNDL       */
	0,	/* BOUNDU       */
	0,	/* BOUNDA       */
	0,	/* NBOUND       */
	0,	/* NBOUNDL      */
	0,	/* NBOUNDU      */
	0,	/* NBOUNDA      */
	0,	/* REG_ANY      */
	0,	/* SANY         */
	0,	/* ANYOF        */
	0,	/* ANYOFD       */
	0,	/* ANYOFL       */
	0,	/* POSIXD       */
	0,	/* POSIXL       */
	0,	/* POSIXU       */
	0,	/* POSIXA       */
	0,	/* NPOSIXD      */
	0,	/* NPOSIXL      */
	0,	/* NPOSIXU      */
	0,	/* NPOSIXA      */
	0,	/* CLUMP        */
	0,	/* BRANCH       */
	0,	/* EXACT        */
	0,	/* EXACTL       */
	0,	/* EXACTF       */
	0,	/* EXACTFL      */
	0,	/* EXACTFU      */
	0,	/* EXACTFA      */
	0,	/* EXACTFU_SS   */
	0,	/* EXACTFLU8    */
	0,	/* EXACTFA_NO_TRIE */
	0,	/* NOTHING      */
	0,	/* TAIL         */
	0,	/* STAR         */
	0,	/* PLUS         */
	0,	/* CURLY        */
	0,	/* CURLYN       */
	0,	/* CURLYM       */
	0,	/* CURLYX       */
	0,	/* WHILEM       */
	0,	/* OPEN         */
	0,	/* CLOSE        */
	0,	/* REF          */
	0,	/* REFF         */
	0,	/* REFFL        */
	0,	/* REFFU        */
	0,	/* REFFA        */
	0,	/* NREF         */
	0,	/* NREFF        */
	0,	/* NREFFL       */
	0,	/* NREFFU       */
	0,	/* NREFFA       */
	1,	/* LONGJMP      */
	1,	/* BRANCHJ      */
	2,	/* IFMATCH      */
	2,	/* UNLESSM      */
	1,	/* SUSPEND      */
	1,	/* IFTHEN       */
	0,	/* GROUPP       */
	0,	/* EVAL         */
	0,	/* MINMOD       */
	0,	/* LOGICAL      */
	1,	/* RENUM        */
	0,	/* TRIE         */
	0,	/* TRIEC        */
	0,	/* AHOCORASICK  */
	0,	/* AHOCORASICKC */
	0,	/* GOSUB        */
	0,	/* NGROUPP      */
	0,	/* INSUBP       */
	0,	/* DEFINEP      */
	0,	/* ENDLIKE      */
	0,	/* OPFAIL       */
	0,	/* ACCEPT       */
	0,	/* VERB         */
	0,	/* PRUNE        */
	0,	/* MARKPOINT    */
	0,	/* SKIP         */
	0,	/* COMMIT       */
	0,	/* CUTGROUP     */
	0,	/* KEEPS        */
	0,	/* LNBREAK      */
	0,	/* OPTIMIZED    */
	0,	/* PSEUDO       */
};

#endif /* REG_COMP_C */


/* reg_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_name[];
#else
EXTCONST char * const PL_reg_name[] = {
	"END",                   	/* 0000 */
	"SUCCEED",               	/* 0x01 */
	"SBOL",                  	/* 0x02 */
	"MBOL",                  	/* 0x03 */
	"SEOL",                  	/* 0x04 */
	"MEOL",                  	/* 0x05 */
	"EOS",                   	/* 0x06 */
	"GPOS",                  	/* 0x07 */
	"BOUND",                 	/* 0x08 */
	"BOUNDL",                	/* 0x09 */
	"BOUNDU",                	/* 0x0a */
	"BOUNDA",                	/* 0x0b */
	"NBOUND",                	/* 0x0c */
	"NBOUNDL",               	/* 0x0d */
	"NBOUNDU",               	/* 0x0e */
	"NBOUNDA",               	/* 0x0f */
	"REG_ANY",               	/* 0x10 */
	"SANY",                  	/* 0x11 */
	"ANYOF",                 	/* 0x12 */
	"ANYOFD",                	/* 0x13 */
	"ANYOFL",                	/* 0x14 */
	"POSIXD",                	/* 0x15 */
	"POSIXL",                	/* 0x16 */
	"POSIXU",                	/* 0x17 */
	"POSIXA",                	/* 0x18 */
	"NPOSIXD",               	/* 0x19 */
	"NPOSIXL",               	/* 0x1a */
	"NPOSIXU",               	/* 0x1b */
	"NPOSIXA",               	/* 0x1c */
	"CLUMP",                 	/* 0x1d */
	"BRANCH",                	/* 0x1e */
	"EXACT",                 	/* 0x1f */
	"EXACTL",                	/* 0x20 */
	"EXACTF",                	/* 0x21 */
	"EXACTFL",               	/* 0x22 */
	"EXACTFU",               	/* 0x23 */
	"EXACTFA",               	/* 0x24 */
	"EXACTFU_SS",            	/* 0x25 */
	"EXACTFLU8",             	/* 0x26 */
	"EXACTFA_NO_TRIE",       	/* 0x27 */
	"NOTHING",               	/* 0x28 */
	"TAIL",                  	/* 0x29 */
	"STAR",                  	/* 0x2a */
	"PLUS",                  	/* 0x2b */
	"CURLY",                 	/* 0x2c */
	"CURLYN",                	/* 0x2d */
	"CURLYM",                	/* 0x2e */
	"CURLYX",                	/* 0x2f */
	"WHILEM",                	/* 0x30 */
	"OPEN",                  	/* 0x31 */
	"CLOSE",                 	/* 0x32 */
	"REF",                   	/* 0x33 */
	"REFF",                  	/* 0x34 */
	"REFFL",                 	/* 0x35 */
	"REFFU",                 	/* 0x36 */
	"REFFA",                 	/* 0x37 */
	"NREF",                  	/* 0x38 */
	"NREFF",                 	/* 0x39 */
	"NREFFL",                	/* 0x3a */
	"NREFFU",                	/* 0x3b */
	"NREFFA",                	/* 0x3c */
	"LONGJMP",               	/* 0x3d */
	"BRANCHJ",               	/* 0x3e */
	"IFMATCH",               	/* 0x3f */
	"UNLESSM",               	/* 0x40 */
	"SUSPEND",               	/* 0x41 */
	"IFTHEN",                	/* 0x42 */
	"GROUPP",                	/* 0x43 */
	"EVAL",                  	/* 0x44 */
	"MINMOD",                	/* 0x45 */
	"LOGICAL",               	/* 0x46 */
	"RENUM",                 	/* 0x47 */
	"TRIE",                  	/* 0x48 */
	"TRIEC",                 	/* 0x49 */
	"AHOCORASICK",           	/* 0x4a */
	"AHOCORASICKC",          	/* 0x4b */
	"GOSUB",                 	/* 0x4c */
	"NGROUPP",               	/* 0x4d */
	"INSUBP",                	/* 0x4e */
	"DEFINEP",               	/* 0x4f */
	"ENDLIKE",               	/* 0x50 */
	"OPFAIL",                	/* 0x51 */
	"ACCEPT",                	/* 0x52 */
	"VERB",                  	/* 0x53 */
	"PRUNE",                 	/* 0x54 */
	"MARKPOINT",             	/* 0x55 */
	"SKIP",                  	/* 0x56 */
	"COMMIT",                	/* 0x57 */
	"CUTGROUP",              	/* 0x58 */
	"KEEPS",                 	/* 0x59 */
	"LNBREAK",               	/* 0x5a */
	"OPTIMIZED",             	/* 0x5b */
	"PSEUDO",                	/* 0x5c */
	/* ------------ States ------------- */
	"TRIE_next",             	/* REGNODE_MAX +0x01 */
	"TRIE_next_fail",        	/* REGNODE_MAX +0x02 */
	"EVAL_AB",               	/* REGNODE_MAX +0x03 */
	"EVAL_AB_fail",          	/* REGNODE_MAX +0x04 */
	"CURLYX_end",            	/* REGNODE_MAX +0x05 */
	"CURLYX_end_fail",       	/* REGNODE_MAX +0x06 */
	"WHILEM_A_pre",          	/* REGNODE_MAX +0x07 */
	"WHILEM_A_pre_fail",     	/* REGNODE_MAX +0x08 */
	"WHILEM_A_min",          	/* REGNODE_MAX +0x09 */
	"WHILEM_A_min_fail",     	/* REGNODE_MAX +0x0a */
	"WHILEM_A_max",          	/* REGNODE_MAX +0x0b */
	"WHILEM_A_max_fail",     	/* REGNODE_MAX +0x0c */
	"WHILEM_B_min",          	/* REGNODE_MAX +0x0d */
	"WHILEM_B_min_fail",     	/* REGNODE_MAX +0x0e */
	"WHILEM_B_max",          	/* REGNODE_MAX +0x0f */
	"WHILEM_B_max_fail",     	/* REGNODE_MAX +0x10 */
	"BRANCH_next",           	/* REGNODE_MAX +0x11 */
	"BRANCH_next_fail",      	/* REGNODE_MAX +0x12 */
	"CURLYM_A",              	/* REGNODE_MAX +0x13 */
	"CURLYM_A_fail",         	/* REGNODE_MAX +0x14 */
	"CURLYM_B",              	/* REGNODE_MAX +0x15 */
	"CURLYM_B_fail",         	/* REGNODE_MAX +0x16 */
	"IFMATCH_A",             	/* REGNODE_MAX +0x17 */
	"IFMATCH_A_fail",        	/* REGNODE_MAX +0x18 */
	"CURLY_B_min_known",     	/* REGNODE_MAX +0x19 */
	"CURLY_B_min_known_fail",	/* REGNODE_MAX +0x1a */
	"CURLY_B_min",           	/* REGNODE_MAX +0x1b */
	"CURLY_B_min_fail",      	/* REGNODE_MAX +0x1c */
	"CURLY_B_max",           	/* REGNODE_MAX +0x1d */
	"CURLY_B_max_fail",      	/* REGNODE_MAX +0x1e */
	"COMMIT_next",           	/* REGNODE_MAX +0x1f */
	"COMMIT_next_fail",      	/* REGNODE_MAX +0x20 */
	"MARKPOINT_next",        	/* REGNODE_MAX +0x21 */
	"MARKPOINT_next_fail",   	/* REGNODE_MAX +0x22 */
	"SKIP_next",             	/* REGNODE_MAX +0x23 */
	"SKIP_next_fail",        	/* REGNODE_MAX +0x24 */
	"CUTGROUP_next",         	/* REGNODE_MAX +0x25 */
	"CUTGROUP_next_fail",    	/* REGNODE_MAX +0x26 */
	"KEEPS_next",            	/* REGNODE_MAX +0x27 */
	"KEEPS_next_fail",       	/* REGNODE_MAX +0x28 */
};
#endif /* DOINIT */

/* PL_reg_extflags_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_extflags_name[];
#else
EXTCONST char * const PL_reg_extflags_name[] = {
	/* Bits in extflags defined: 11111111111111110000111111111111 */
	"MULTILINE",        /* 0x00000001 */
	"SINGLELINE",       /* 0x00000002 */
	"FOLD",             /* 0x00000004 */
	"EXTENDED",         /* 0x00000008 */
	"EXTENDED_MORE",    /* 0x00000010 */
	"NOCAPTURE",        /* 0x00000020 */
	"KEEPCOPY",         /* 0x00000040 */
	"CHARSET0",         /* 0x00000080 : "CHARSET" - 0x00000380 */
	"CHARSET1",         /* 0x00000100 : "CHARSET" - 0x00000380 */
	"CHARSET2",         /* 0x00000200 : "CHARSET" - 0x00000380 */
	"STRICT",           /* 0x00000400 */
	"SPLIT",            /* 0x00000800 */
	"UNUSED_BIT_12",    /* 0x00001000 */
	"UNUSED_BIT_13",    /* 0x00002000 */
	"UNUSED_BIT_14",    /* 0x00004000 */
	"UNUSED_BIT_15",    /* 0x00008000 */
	"NO_INPLACE_SUBST", /* 0x00010000 */
	"EVAL_SEEN",        /* 0x00020000 */
	"UNBOUNDED_QUANTIFIER_SEEN",/* 0x00040000 */
	"CHECK_ALL",        /* 0x00080000 */
	"MATCH_UTF8",       /* 0x00100000 */
	"USE_INTUIT_NOML",  /* 0x00200000 */
	"USE_INTUIT_ML",    /* 0x00400000 */
	"INTUIT_TAIL",      /* 0x00800000 */
	"IS_ANCHORED",      /* 0x01000000 */
	"COPY_DONE",        /* 0x02000000 */
	"TAINTED_SEEN",     /* 0x04000000 */
	"TAINTED",          /* 0x08000000 */
	"START_ONLY",       /* 0x10000000 */
	"SKIPWHITE",        /* 0x20000000 */
	"WHITE",            /* 0x40000000 */
	"NULL",             /* 0x80000000 */
};
#endif /* DOINIT */

#ifdef DEBUGGING
#  define REG_EXTFLAGS_NAME_SIZE 32
#endif

/* PL_reg_intflags_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_intflags_name[];
#else
EXTCONST char * const PL_reg_intflags_name[] = {
	"SKIP",                       /* 0x00000001 - PREGf_SKIP */
	"IMPLICIT",                   /* 0x00000002 - PREGf_IMPLICIT -  Converted .* to ^.*  */
	"NAUGHTY",                    /* 0x00000004 - PREGf_NAUGHTY -  how exponential is this pattern?  */
	"VERBARG_SEEN",               /* 0x00000008 - PREGf_VERBARG_SEEN */
	"CUTGROUP_SEEN",              /* 0x00000010 - PREGf_CUTGROUP_SEEN */
	"USE_RE_EVAL",                /* 0x00000020 - PREGf_USE_RE_EVAL -  compiled with "use re 'eval'"  */
	"NOSCAN",                     /* 0x00000040 - PREGf_NOSCAN */
	"GPOS_SEEN",                  /* 0x00000100 - PREGf_GPOS_SEEN */
	"GPOS_FLOAT",                 /* 0x00000200 - PREGf_GPOS_FLOAT */
	"ANCH_MBOL",                  /* 0x00000400 - PREGf_ANCH_MBOL */
	"ANCH_SBOL",                  /* 0x00000800 - PREGf_ANCH_SBOL */
	"ANCH_GPOS",                  /* 0x00001000 - PREGf_ANCH_GPOS */
	"RECURSE_SEEN",               /* 0x00002000 - PREGf_RECURSE_SEEN */
};
#endif /* DOINIT */

#ifdef DEBUGGING
#  define REG_INTFLAGS_NAME_SIZE 13
#endif

/* The following have no fixed length. U8 so we can do strchr() on it. */
#define REGNODE_VARIES(node) (PL_varies_bitmask[(node) >> 3] & (1 << ((node) & 7)))

#ifndef DOINIT
EXTCONST U8 PL_varies[] __attribute__deprecated__;
#else
EXTCONST U8 PL_varies[] __attribute__deprecated__ = {
    CLUMP, BRANCH, STAR, PLUS, CURLY, CURLYN, CURLYM, CURLYX, WHILEM, REF,
    REFF, REFFL, REFFU, REFFA, NREF, NREFF, NREFFL, NREFFU, NREFFA,
    BRANCHJ, SUSPEND, IFTHEN,
    0
};
#endif /* DOINIT */

#ifndef DOINIT
EXTCONST U8 PL_varies_bitmask[];
#else
EXTCONST U8 PL_varies_bitmask[] = {
    0x00, 0x00, 0x00, 0x60, 0x00, 0xFC, 0xF9, 0x5F, 0x06, 0x00, 0x00, 0x00
};
#endif /* DOINIT */

/* The following always have a length of 1. U8 we can do strchr() on it. */
/* (Note that length 1 means "one character" under UTF8, not "one octet".) */
#define REGNODE_SIMPLE(node) (PL_simple_bitmask[(node) >> 3] & (1 << ((node) & 7)))

#ifndef DOINIT
EXTCONST U8 PL_simple[] __attribute__deprecated__;
#else
EXTCONST U8 PL_simple[] __attribute__deprecated__ = {
    REG_ANY, SANY, ANYOF, ANYOFD, ANYOFL, POSIXD, POSIXL, POSIXU, POSIXA,
    NPOSIXD, NPOSIXL, NPOSIXU, NPOSIXA,
    0
};
#endif /* DOINIT */

#ifndef DOINIT
EXTCONST U8 PL_simple_bitmask[];
#else
EXTCONST U8 PL_simple_bitmask[] = {
    0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
#endif /* DOINIT */

/* ex: set ro: */
@


1.1
log
@Initial revision
@
text
@d1 3
a3 2
/* !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
   This file is built by regcomp.pl from regcomp.sym.  
d5 1
a5 1
*/
d7 282
a288 121
#define	END	0	/*    0 End of program. */
#define	SUCCEED	1	/*  0x1 Return from a subroutine, basically. */
#define	BOL	2	/*  0x2 Match "" at beginning of line. */
#define	MBOL	3	/*  0x3 Same, assuming multiline. */
#define	SBOL	4	/*  0x4 Same, assuming singleline. */
#define	EOS	5	/*  0x5 Match "" at end of string. */
#define	EOL	6	/*  0x6 Match "" at end of line. */
#define	MEOL	7	/*  0x7 Same, assuming multiline. */
#define	SEOL	8	/*  0x8 Same, assuming singleline. */
#define	BOUND	9	/*  0x9 Match "" at any word boundary */
#define	BOUNDL	10	/*  0xa Match "" at any word boundary */
#define	NBOUND	11	/*  0xb Match "" at any word non-boundary */
#define	NBOUNDL	12	/*  0xc Match "" at any word non-boundary */
#define	GPOS	13	/*  0xd Matches where last m//g left off. */
#define	ANY	14	/*  0xe Match any one character (except newline). */
#define	SANY	15	/*  0xf Match any one character. */
#define	ANYOF	16	/* 0x10 Match character in (or not in) this class. */
#define	ALNUM	17	/* 0x11 Match any alphanumeric character */
#define	ALNUML	18	/* 0x12 Match any alphanumeric char in locale */
#define	NALNUM	19	/* 0x13 Match any non-alphanumeric character */
#define	NALNUML	20	/* 0x14 Match any non-alphanumeric char in locale */
#define	SPACE	21	/* 0x15 Match any whitespace character */
#define	SPACEL	22	/* 0x16 Match any whitespace char in locale */
#define	NSPACE	23	/* 0x17 Match any non-whitespace character */
#define	NSPACEL	24	/* 0x18 Match any non-whitespace char in locale */
#define	DIGIT	25	/* 0x19 Match any numeric character */
#define	NDIGIT	26	/* 0x1a Match any non-numeric character */
#define	BRANCH	27	/* 0x1b Match this alternative, or the next... */
#define	BACK	28	/* 0x1c Match "", "next" ptr points backward. */
#define	EXACT	29	/* 0x1d Match this string (preceded by length). */
#define	EXACTF	30	/* 0x1e Match this string, folded (prec. by length). */
#define	EXACTFL	31	/* 0x1f Match this string, folded in locale (w/len). */
#define	NOTHING	32	/* 0x20 Match empty string. */
#define	TAIL	33	/* 0x21 Match empty string. Can jump here from outside. */
#define	STAR	34	/* 0x22 Match this (simple) thing 0 or more times. */
#define	PLUS	35	/* 0x23 Match this (simple) thing 1 or more times. */
#define	CURLY	36	/* 0x24 Match this simple thing {n,m} times. */
#define	CURLYN	37	/* 0x25 Match next-after-this simple thing  */
#define	CURLYM	38	/* 0x26 Match this medium-complex thing {n,m} times. */
#define	CURLYX	39	/* 0x27 Match this complex thing {n,m} times. */
#define	WHILEM	40	/* 0x28 Do curly processing and see if rest matches. */
#define	OPEN	41	/* 0x29 Mark this point in input as start of #n. */
#define	CLOSE	42	/* 0x2a Analogous to OPEN. */
#define	REF	43	/* 0x2b Match some already matched string */
#define	REFF	44	/* 0x2c Match already matched string, folded */
#define	REFFL	45	/* 0x2d Match already matched string, folded in loc. */
#define	IFMATCH	46	/* 0x2e Succeeds if the following matches. */
#define	UNLESSM	47	/* 0x2f Fails if the following matches. */
#define	SUSPEND	48	/* 0x30 "Independent" sub-RE. */
#define	IFTHEN	49	/* 0x31 Switch, should be preceeded by switcher . */
#define	GROUPP	50	/* 0x32 Whether the group matched. */
#define	LONGJMP	51	/* 0x33 Jump far away. */
#define	BRANCHJ	52	/* 0x34 BRANCH with long offset. */
#define	EVAL	53	/* 0x35 Execute some Perl code. */
#define	MINMOD	54	/* 0x36 Next operator is not greedy. */
#define	LOGICAL	55	/* 0x37 Next opcode should set the flag only. */
#define	RENUM	56	/* 0x38 Group with independently numbered parens. */
#define	OPTIMIZED	57	/* 0x39 Placeholder for dump. */

#ifndef DOINIT
EXTCONST U8 regkind[];
#else
EXTCONST U8 regkind[] = {
	END,		/* END */
	END,		/* SUCCEED */
	BOL,		/* BOL */
	BOL,		/* MBOL */
	BOL,		/* SBOL */
	EOL,		/* EOS */
	EOL,		/* EOL */
	EOL,		/* MEOL */
	EOL,		/* SEOL */
	BOUND,		/* BOUND */
	BOUND,		/* BOUNDL */
	NBOUND,		/* NBOUND */
	NBOUND,		/* NBOUNDL */
	GPOS,		/* GPOS */
	ANY,		/* ANY */
	ANY,		/* SANY */
	ANYOF,		/* ANYOF */
	ALNUM,		/* ALNUM */
	ALNUM,		/* ALNUML */
	NALNUM,		/* NALNUM */
	NALNUM,		/* NALNUML */
	SPACE,		/* SPACE */
	SPACE,		/* SPACEL */
	NSPACE,		/* NSPACE */
	NSPACE,		/* NSPACEL */
	DIGIT,		/* DIGIT */
	NDIGIT,		/* NDIGIT */
	BRANCH,		/* BRANCH */
	BACK,		/* BACK */
	EXACT,		/* EXACT */
	EXACT,		/* EXACTF */
	EXACT,		/* EXACTFL */
	NOTHING,		/* NOTHING */
	NOTHING,		/* TAIL */
	STAR,		/* STAR */
	PLUS,		/* PLUS */
	CURLY,		/* CURLY */
	CURLY,		/* CURLYN */
	CURLY,		/* CURLYM */
	CURLY,		/* CURLYX */
	WHILEM,		/* WHILEM */
	OPEN,		/* OPEN */
	CLOSE,		/* CLOSE */
	REF,		/* REF */
	REF,		/* REFF */
	REF,		/* REFFL */
	BRANCHJ,		/* IFMATCH */
	BRANCHJ,		/* UNLESSM */
	BRANCHJ,		/* SUSPEND */
	BRANCHJ,		/* IFTHEN */
	GROUPP,		/* GROUPP */
	LONGJMP,		/* LONGJMP */
	BRANCHJ,		/* BRANCHJ */
	EVAL,		/* EVAL */
	MINMOD,		/* MINMOD */
	LOGICAL,		/* LOGICAL */
	BRANCHJ,		/* RENUM */
	NOTHING,		/* OPTIMIZED */
d292 1
d294 194
a487 121
#ifdef REG_COMP_C
const static U8 regarglen[] = {
	0,		/* END */
	0,		/* SUCCEED */
	0,		/* BOL */
	0,		/* MBOL */
	0,		/* SBOL */
	0,		/* EOS */
	0,		/* EOL */
	0,		/* MEOL */
	0,		/* SEOL */
	0,		/* BOUND */
	0,		/* BOUNDL */
	0,		/* NBOUND */
	0,		/* NBOUNDL */
	0,		/* GPOS */
	0,		/* ANY */
	0,		/* SANY */
	0,		/* ANYOF */
	0,		/* ALNUM */
	0,		/* ALNUML */
	0,		/* NALNUM */
	0,		/* NALNUML */
	0,		/* SPACE */
	0,		/* SPACEL */
	0,		/* NSPACE */
	0,		/* NSPACEL */
	0,		/* DIGIT */
	0,		/* NDIGIT */
	0,		/* BRANCH */
	0,		/* BACK */
	0,		/* EXACT */
	0,		/* EXACTF */
	0,		/* EXACTFL */
	0,		/* NOTHING */
	0,		/* TAIL */
	0,		/* STAR */
	0,		/* PLUS */
	EXTRA_SIZE(struct regnode_2),		/* CURLY */
	EXTRA_SIZE(struct regnode_2),		/* CURLYN */
	EXTRA_SIZE(struct regnode_2),		/* CURLYM */
	EXTRA_SIZE(struct regnode_2),		/* CURLYX */
	0,		/* WHILEM */
	EXTRA_SIZE(struct regnode_1),		/* OPEN */
	EXTRA_SIZE(struct regnode_1),		/* CLOSE */
	EXTRA_SIZE(struct regnode_1),		/* REF */
	EXTRA_SIZE(struct regnode_1),		/* REFF */
	EXTRA_SIZE(struct regnode_1),		/* REFFL */
	EXTRA_SIZE(struct regnode_1),		/* IFMATCH */
	EXTRA_SIZE(struct regnode_1),		/* UNLESSM */
	EXTRA_SIZE(struct regnode_1),		/* SUSPEND */
	EXTRA_SIZE(struct regnode_1),		/* IFTHEN */
	EXTRA_SIZE(struct regnode_1),		/* GROUPP */
	EXTRA_SIZE(struct regnode_1),		/* LONGJMP */
	EXTRA_SIZE(struct regnode_1),		/* BRANCHJ */
	EXTRA_SIZE(struct regnode_1),		/* EVAL */
	0,		/* MINMOD */
	0,		/* LOGICAL */
	EXTRA_SIZE(struct regnode_1),		/* RENUM */
	0,		/* OPTIMIZED */
};

const static char reg_off_by_arg[] = {
	0,		/* END */
	0,		/* SUCCEED */
	0,		/* BOL */
	0,		/* MBOL */
	0,		/* SBOL */
	0,		/* EOS */
	0,		/* EOL */
	0,		/* MEOL */
	0,		/* SEOL */
	0,		/* BOUND */
	0,		/* BOUNDL */
	0,		/* NBOUND */
	0,		/* NBOUNDL */
	0,		/* GPOS */
	0,		/* ANY */
	0,		/* SANY */
	0,		/* ANYOF */
	0,		/* ALNUM */
	0,		/* ALNUML */
	0,		/* NALNUM */
	0,		/* NALNUML */
	0,		/* SPACE */
	0,		/* SPACEL */
	0,		/* NSPACE */
	0,		/* NSPACEL */
	0,		/* DIGIT */
	0,		/* NDIGIT */
	0,		/* BRANCH */
	0,		/* BACK */
	0,		/* EXACT */
	0,		/* EXACTF */
	0,		/* EXACTFL */
	0,		/* NOTHING */
	0,		/* TAIL */
	0,		/* STAR */
	0,		/* PLUS */
	0,		/* CURLY */
	0,		/* CURLYN */
	0,		/* CURLYM */
	0,		/* CURLYX */
	0,		/* WHILEM */
	0,		/* OPEN */
	0,		/* CLOSE */
	0,		/* REF */
	0,		/* REFF */
	0,		/* REFFL */
	2,		/* IFMATCH */
	2,		/* UNLESSM */
	1,		/* SUSPEND */
	1,		/* IFTHEN */
	0,		/* GROUPP */
	1,		/* LONGJMP */
	1,		/* BRANCHJ */
	0,		/* EVAL */
	0,		/* MINMOD */
	0,		/* LOGICAL */
	1,		/* RENUM */
	0,		/* OPTIMIZED */
d489 1
d492 261
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d2 1
a2 1
   This file is built by regcomp.pl from regcomp.sym.
d16 48
a63 70
#define	BOUNDUTF8	10	/*  0xa Match "" at any word boundary */
#define	BOUNDL	11	/*  0xb Match "" at any word boundary */
#define	BOUNDLUTF8	12	/*  0xc Match "" at any word boundary */
#define	NBOUND	13	/*  0xd Match "" at any word non-boundary */
#define	NBOUNDUTF8	14	/*  0xe Match "" at any word non-boundary */
#define	NBOUNDL	15	/*  0xf Match "" at any word non-boundary */
#define	NBOUNDLUTF8	16	/* 0x10 Match "" at any word non-boundary */
#define	GPOS	17	/* 0x11 Matches where last m//g left off. */
#define	REG_ANY	18	/* 0x12 Match any one character (except newline). */
#define	ANYUTF8	19	/* 0x13 Match any one Unicode character (except newline). */
#define	SANY	20	/* 0x14 Match any one character. */
#define	SANYUTF8	21	/* 0x15 Match any one Unicode character. */
#define	ANYOF	22	/* 0x16 Match character in (or not in) this class. */
#define	ANYOFUTF8	23	/* 0x17 Match character in (or not in) this class. */
#define	ALNUM	24	/* 0x18 Match any alphanumeric character */
#define	ALNUMUTF8	25	/* 0x19 Match any alphanumeric character in utf8 */
#define	ALNUML	26	/* 0x1a Match any alphanumeric char in locale */
#define	ALNUMLUTF8	27	/* 0x1b Match any alphanumeric char in locale+utf8 */
#define	NALNUM	28	/* 0x1c Match any non-alphanumeric character */
#define	NALNUMUTF8	29	/* 0x1d Match any non-alphanumeric character in utf8 */
#define	NALNUML	30	/* 0x1e Match any non-alphanumeric char in locale */
#define	NALNUMLUTF8	31	/* 0x1f Match any non-alphanumeric char in locale+utf8 */
#define	SPACE	32	/* 0x20 Match any whitespace character */
#define	SPACEUTF8	33	/* 0x21 Match any whitespace character in utf8 */
#define	SPACEL	34	/* 0x22 Match any whitespace char in locale */
#define	SPACELUTF8	35	/* 0x23 Match any whitespace char in locale+utf8 */
#define	NSPACE	36	/* 0x24 Match any non-whitespace character */
#define	NSPACEUTF8	37	/* 0x25 Match any non-whitespace character in utf8 */
#define	NSPACEL	38	/* 0x26 Match any non-whitespace char in locale */
#define	NSPACELUTF8	39	/* 0x27 Match any non-whitespace char in locale+utf8 */
#define	DIGIT	40	/* 0x28 Match any numeric character */
#define	DIGITUTF8	41	/* 0x29 Match any numeric character in utf8 */
#define	DIGITL	42	/* 0x2a Match any numeric character in locale */
#define	DIGITLUTF8	43	/* 0x2b Match any numeric character in locale+utf8 */
#define	NDIGIT	44	/* 0x2c Match any non-numeric character */
#define	NDIGITUTF8	45	/* 0x2d Match any non-numeric character in utf8 */
#define	NDIGITL	46	/* 0x2e Match any non-numeric character in locale */
#define	NDIGITLUTF8	47	/* 0x2f Match any non-numeric character in locale+utf8 */
#define	CLUMP	48	/* 0x30 Match any combining character sequence */
#define	BRANCH	49	/* 0x31 Match this alternative, or the next... */
#define	BACK	50	/* 0x32 Match "", "next" ptr points backward. */
#define	EXACT	51	/* 0x33 Match this string (preceded by length). */
#define	EXACTF	52	/* 0x34 Match this string, folded (prec. by length). */
#define	EXACTFL	53	/* 0x35 Match this string, folded in locale (w/len). */
#define	NOTHING	54	/* 0x36 Match empty string. */
#define	TAIL	55	/* 0x37 Match empty string. Can jump here from outside. */
#define	STAR	56	/* 0x38 Match this (simple) thing 0 or more times. */
#define	PLUS	57	/* 0x39 Match this (simple) thing 1 or more times. */
#define	CURLY	58	/* 0x3a Match this simple thing {n,m} times. */
#define	CURLYN	59	/* 0x3b Match next-after-this simple thing  */
#define	CURLYM	60	/* 0x3c Match this medium-complex thing {n,m} times. */
#define	CURLYX	61	/* 0x3d Match this complex thing {n,m} times. */
#define	WHILEM	62	/* 0x3e Do curly processing and see if rest matches. */
#define	OPEN	63	/* 0x3f Mark this point in input as start of #n. */
#define	CLOSE	64	/* 0x40 Analogous to OPEN. */
#define	REF	65	/* 0x41 Match some already matched string */
#define	REFF	66	/* 0x42 Match already matched string, folded */
#define	REFFL	67	/* 0x43 Match already matched string, folded in loc. */
#define	IFMATCH	68	/* 0x44 Succeeds if the following matches. */
#define	UNLESSM	69	/* 0x45 Fails if the following matches. */
#define	SUSPEND	70	/* 0x46 "Independent" sub-RE. */
#define	IFTHEN	71	/* 0x47 Switch, should be preceeded by switcher . */
#define	GROUPP	72	/* 0x48 Whether the group matched. */
#define	LONGJMP	73	/* 0x49 Jump far away. */
#define	BRANCHJ	74	/* 0x4a BRANCH with long offset. */
#define	EVAL	75	/* 0x4b Execute some Perl code. */
#define	MINMOD	76	/* 0x4c Next operator is not greedy. */
#define	LOGICAL	77	/* 0x4d Next opcode should set the flag only. */
#define	RENUM	78	/* 0x4e Group with independently numbered parens. */
#define	OPTIMIZED	79	/* 0x4f Placeholder for dump. */
d66 1
a66 1
EXTCONST U8 PL_regkind[];
d68 1
a68 1
EXTCONST U8 PL_regkind[] = {
a78 1
	BOUND,		/* BOUNDUTF8 */
a79 1
	BOUND,		/* BOUNDLUTF8 */
a80 1
	NBOUND,		/* NBOUNDUTF8 */
a81 1
	NBOUND,		/* NBOUNDLUTF8 */
d83 2
a84 4
	REG_ANY,		/* REG_ANY */
	REG_ANY,		/* ANYUTF8 */
	REG_ANY,		/* SANY */
	REG_ANY,		/* SANYUTF8 */
a85 1
	ANYOF,		/* ANYOFUTF8 */
a86 1
	ALNUM,		/* ALNUMUTF8 */
a87 1
	ALNUM,		/* ALNUMLUTF8 */
a88 1
	NALNUM,		/* NALNUMUTF8 */
a89 1
	NALNUM,		/* NALNUMLUTF8 */
a90 1
	SPACE,		/* SPACEUTF8 */
a91 1
	SPACE,		/* SPACELUTF8 */
a92 1
	NSPACE,		/* NSPACEUTF8 */
a93 1
	NSPACE,		/* NSPACELUTF8 */
a94 3
	DIGIT,		/* DIGITUTF8 */
	DIGIT,		/* DIGITL */
	DIGIT,		/* DIGITLUTF8 */
a95 4
	NDIGIT,		/* NDIGITUTF8 */
	NDIGIT,		/* NDIGITL */
	NDIGIT,		/* NDIGITLUTF8 */
	CLUMP,		/* CLUMP */
a142 1
	0,		/* BOUNDUTF8 */
a143 1
	0,		/* BOUNDLUTF8 */
a144 1
	0,		/* NBOUNDUTF8 */
a145 1
	0,		/* NBOUNDLUTF8 */
d147 1
a147 2
	0,		/* REG_ANY */
	0,		/* ANYUTF8 */
a148 1
	0,		/* SANYUTF8 */
a149 1
	EXTRA_SIZE(struct regnode_1),		/* ANYOFUTF8 */
a150 1
	0,		/* ALNUMUTF8 */
a151 1
	0,		/* ALNUMLUTF8 */
a152 1
	0,		/* NALNUMUTF8 */
a153 1
	0,		/* NALNUMLUTF8 */
a154 1
	0,		/* SPACEUTF8 */
a155 1
	0,		/* SPACELUTF8 */
a156 1
	0,		/* NSPACEUTF8 */
a157 1
	0,		/* NSPACELUTF8 */
a158 3
	0,		/* DIGITUTF8 */
	0,		/* DIGITL */
	0,		/* DIGITLUTF8 */
a159 4
	0,		/* NDIGITUTF8 */
	0,		/* NDIGITL */
	0,		/* NDIGITLUTF8 */
	0,		/* CLUMP */
a203 1
	0,		/* BOUNDUTF8 */
a204 1
	0,		/* BOUNDLUTF8 */
a205 1
	0,		/* NBOUNDUTF8 */
a206 1
	0,		/* NBOUNDLUTF8 */
d208 1
a208 2
	0,		/* REG_ANY */
	0,		/* ANYUTF8 */
a209 1
	0,		/* SANYUTF8 */
a210 1
	0,		/* ANYOFUTF8 */
a211 1
	0,		/* ALNUMUTF8 */
a212 1
	0,		/* ALNUMLUTF8 */
a213 1
	0,		/* NALNUMUTF8 */
a214 1
	0,		/* NALNUMLUTF8 */
a215 1
	0,		/* SPACEUTF8 */
a216 1
	0,		/* SPACELUTF8 */
a217 1
	0,		/* NSPACEUTF8 */
a218 1
	0,		/* NSPACELUTF8 */
a219 3
	0,		/* DIGITUTF8 */
	0,		/* DIGITL */
	0,		/* DIGITLUTF8 */
a220 4
	0,		/* NDIGITUTF8 */
	0,		/* NDIGITL */
	0,		/* NDIGITLUTF8 */
	0,		/* CLUMP */
a252 88

#ifdef DEBUGGING
const static char * const reg_name[] = {
	"END",		/*    0 */
	"SUCCEED",		/*  0x1 */
	"BOL",		/*  0x2 */
	"MBOL",		/*  0x3 */
	"SBOL",		/*  0x4 */
	"EOS",		/*  0x5 */
	"EOL",		/*  0x6 */
	"MEOL",		/*  0x7 */
	"SEOL",		/*  0x8 */
	"BOUND",		/*  0x9 */
	"BOUNDUTF8",		/*  0xa */
	"BOUNDL",		/*  0xb */
	"BOUNDLUTF8",		/*  0xc */
	"NBOUND",		/*  0xd */
	"NBOUNDUTF8",		/*  0xe */
	"NBOUNDL",		/*  0xf */
	"NBOUNDLUTF8",		/* 0x10 */
	"GPOS",		/* 0x11 */
	"REG_ANY",		/* 0x12 */
	"ANYUTF8",		/* 0x13 */
	"SANY",		/* 0x14 */
	"SANYUTF8",		/* 0x15 */
	"ANYOF",		/* 0x16 */
	"ANYOFUTF8",		/* 0x17 */
	"ALNUM",		/* 0x18 */
	"ALNUMUTF8",		/* 0x19 */
	"ALNUML",		/* 0x1a */
	"ALNUMLUTF8",		/* 0x1b */
	"NALNUM",		/* 0x1c */
	"NALNUMUTF8",		/* 0x1d */
	"NALNUML",		/* 0x1e */
	"NALNUMLUTF8",		/* 0x1f */
	"SPACE",		/* 0x20 */
	"SPACEUTF8",		/* 0x21 */
	"SPACEL",		/* 0x22 */
	"SPACELUTF8",		/* 0x23 */
	"NSPACE",		/* 0x24 */
	"NSPACEUTF8",		/* 0x25 */
	"NSPACEL",		/* 0x26 */
	"NSPACELUTF8",		/* 0x27 */
	"DIGIT",		/* 0x28 */
	"DIGITUTF8",		/* 0x29 */
	"DIGITL",		/* 0x2a */
	"DIGITLUTF8",		/* 0x2b */
	"NDIGIT",		/* 0x2c */
	"NDIGITUTF8",		/* 0x2d */
	"NDIGITL",		/* 0x2e */
	"NDIGITLUTF8",		/* 0x2f */
	"CLUMP",		/* 0x30 */
	"BRANCH",		/* 0x31 */
	"BACK",		/* 0x32 */
	"EXACT",		/* 0x33 */
	"EXACTF",		/* 0x34 */
	"EXACTFL",		/* 0x35 */
	"NOTHING",		/* 0x36 */
	"TAIL",		/* 0x37 */
	"STAR",		/* 0x38 */
	"PLUS",		/* 0x39 */
	"CURLY",		/* 0x3a */
	"CURLYN",		/* 0x3b */
	"CURLYM",		/* 0x3c */
	"CURLYX",		/* 0x3d */
	"WHILEM",		/* 0x3e */
	"OPEN",		/* 0x3f */
	"CLOSE",		/* 0x40 */
	"REF",		/* 0x41 */
	"REFF",		/* 0x42 */
	"REFFL",		/* 0x43 */
	"IFMATCH",		/* 0x44 */
	"UNLESSM",		/* 0x45 */
	"SUSPEND",		/* 0x46 */
	"IFTHEN",		/* 0x47 */
	"GROUPP",		/* 0x48 */
	"LONGJMP",		/* 0x49 */
	"BRANCHJ",		/* 0x4a */
	"EVAL",		/* 0x4b */
	"MINMOD",		/* 0x4c */
	"LOGICAL",		/* 0x4d */
	"RENUM",		/* 0x4e */
	"OPTIMIZED",		/* 0x4f */
};

const static int reg_num = 80;

#endif /* DEBUGGING */
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d176 1
a176 1
static const U8 regarglen[] = {
d259 1
a259 1
static const char reg_off_by_arg[] = {
d343 1
a343 1
static const char * const reg_name[] = {
d426 1
a426 1
static const int reg_num = 80;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d16 70
a85 52
#define	BOUNDL	10	/*  0xa Match "" at any word boundary */
#define	NBOUND	11	/*  0xb Match "" at any word non-boundary */
#define	NBOUNDL	12	/*  0xc Match "" at any word non-boundary */
#define	GPOS	13	/*  0xd Matches where last m//g left off. */
#define	REG_ANY	14	/*  0xe Match any one character (except newline). */
#define	SANY	15	/*  0xf Match any one character. */
#define	CANY	16	/* 0x10 Match any one byte. */
#define	ANYOF	17	/* 0x11 Match character in (or not in) this class. */
#define	ALNUM	18	/* 0x12 Match any alphanumeric character */
#define	ALNUML	19	/* 0x13 Match any alphanumeric char in locale */
#define	NALNUM	20	/* 0x14 Match any non-alphanumeric character */
#define	NALNUML	21	/* 0x15 Match any non-alphanumeric char in locale */
#define	SPACE	22	/* 0x16 Match any whitespace character */
#define	SPACEL	23	/* 0x17 Match any whitespace char in locale */
#define	NSPACE	24	/* 0x18 Match any non-whitespace character */
#define	NSPACEL	25	/* 0x19 Match any non-whitespace char in locale */
#define	DIGIT	26	/* 0x1a Match any numeric character */
#define	DIGITL	27	/* 0x1b Match any numeric character in locale */
#define	NDIGIT	28	/* 0x1c Match any non-numeric character */
#define	NDIGITL	29	/* 0x1d Match any non-numeric character in locale */
#define	CLUMP	30	/* 0x1e Match any combining character sequence */
#define	BRANCH	31	/* 0x1f Match this alternative, or the next... */
#define	BACK	32	/* 0x20 Match "", "next" ptr points backward. */
#define	EXACT	33	/* 0x21 Match this string (preceded by length). */
#define	EXACTF	34	/* 0x22 Match this string, folded (prec. by length). */
#define	EXACTFL	35	/* 0x23 Match this string, folded in locale (w/len). */
#define	NOTHING	36	/* 0x24 Match empty string. */
#define	TAIL	37	/* 0x25 Match empty string. Can jump here from outside. */
#define	STAR	38	/* 0x26 Match this (simple) thing 0 or more times. */
#define	PLUS	39	/* 0x27 Match this (simple) thing 1 or more times. */
#define	CURLY	40	/* 0x28 Match this simple thing {n,m} times. */
#define	CURLYN	41	/* 0x29 Match next-after-this simple thing  */
#define	CURLYM	42	/* 0x2a Match this medium-complex thing {n,m} times. */
#define	CURLYX	43	/* 0x2b Match this complex thing {n,m} times. */
#define	WHILEM	44	/* 0x2c Do curly processing and see if rest matches. */
#define	OPEN	45	/* 0x2d Mark this point in input as start of #n. */
#define	CLOSE	46	/* 0x2e Analogous to OPEN. */
#define	REF	47	/* 0x2f Match some already matched string */
#define	REFF	48	/* 0x30 Match already matched string, folded */
#define	REFFL	49	/* 0x31 Match already matched string, folded in loc. */
#define	IFMATCH	50	/* 0x32 Succeeds if the following matches. */
#define	UNLESSM	51	/* 0x33 Fails if the following matches. */
#define	SUSPEND	52	/* 0x34 "Independent" sub-RE. */
#define	IFTHEN	53	/* 0x35 Switch, should be preceeded by switcher . */
#define	GROUPP	54	/* 0x36 Whether the group matched. */
#define	LONGJMP	55	/* 0x37 Jump far away. */
#define	BRANCHJ	56	/* 0x38 BRANCH with long offset. */
#define	EVAL	57	/* 0x39 Execute some Perl code. */
#define	MINMOD	58	/* 0x3a Next operator is not greedy. */
#define	LOGICAL	59	/* 0x3b Next opcode should set the flag only. */
#define	RENUM	60	/* 0x3c Group with independently numbered parens. */
#define	OPTIMIZED	61	/* 0x3d Placeholder for dump. */
d101 1
d103 1
d105 1
d107 1
d110 1
d112 1
a112 1
	REG_ANY,		/* CANY */
d114 1
d116 1
d118 1
d120 1
d122 1
d124 1
d126 1
d128 1
d130 1
d132 1
d134 1
d136 1
d138 1
d187 1
d189 1
d191 1
d193 1
d196 1
d198 1
a198 1
	0,		/* CANY */
d200 1
d202 1
d204 1
d206 1
d208 1
d210 1
d212 1
d214 1
d216 1
d218 1
d220 1
d222 1
d224 1
d270 1
d272 1
d274 1
d276 1
d279 1
d281 1
a281 1
	0,		/* CANY */
d283 1
d285 1
d287 1
d289 1
d291 1
d293 1
d295 1
d297 1
d299 1
d301 1
d303 1
d305 1
d307 1
d354 70
a423 52
	"BOUNDL",		/*  0xa */
	"NBOUND",		/*  0xb */
	"NBOUNDL",		/*  0xc */
	"GPOS",		/*  0xd */
	"REG_ANY",		/*  0xe */
	"SANY",		/*  0xf */
	"CANY",		/* 0x10 */
	"ANYOF",		/* 0x11 */
	"ALNUM",		/* 0x12 */
	"ALNUML",		/* 0x13 */
	"NALNUM",		/* 0x14 */
	"NALNUML",		/* 0x15 */
	"SPACE",		/* 0x16 */
	"SPACEL",		/* 0x17 */
	"NSPACE",		/* 0x18 */
	"NSPACEL",		/* 0x19 */
	"DIGIT",		/* 0x1a */
	"DIGITL",		/* 0x1b */
	"NDIGIT",		/* 0x1c */
	"NDIGITL",		/* 0x1d */
	"CLUMP",		/* 0x1e */
	"BRANCH",		/* 0x1f */
	"BACK",		/* 0x20 */
	"EXACT",		/* 0x21 */
	"EXACTF",		/* 0x22 */
	"EXACTFL",		/* 0x23 */
	"NOTHING",		/* 0x24 */
	"TAIL",		/* 0x25 */
	"STAR",		/* 0x26 */
	"PLUS",		/* 0x27 */
	"CURLY",		/* 0x28 */
	"CURLYN",		/* 0x29 */
	"CURLYM",		/* 0x2a */
	"CURLYX",		/* 0x2b */
	"WHILEM",		/* 0x2c */
	"OPEN",		/* 0x2d */
	"CLOSE",		/* 0x2e */
	"REF",		/* 0x2f */
	"REFF",		/* 0x30 */
	"REFFL",		/* 0x31 */
	"IFMATCH",		/* 0x32 */
	"UNLESSM",		/* 0x33 */
	"SUSPEND",		/* 0x34 */
	"IFTHEN",		/* 0x35 */
	"GROUPP",		/* 0x36 */
	"LONGJMP",		/* 0x37 */
	"BRANCHJ",		/* 0x38 */
	"EVAL",		/* 0x39 */
	"MINMOD",		/* 0x3a */
	"LOGICAL",		/* 0x3b */
	"RENUM",		/* 0x3c */
	"OPTIMIZED",		/* 0x3d */
d426 1
a426 1
static const int reg_num = 62;
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d1 1
a1 2
/* -*- buffer-read-only: t -*-
   !!!!!!!   DO NOT EDIT THIS FILE   !!!!!!!
a340 1
/* ex: set ro: */
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d7 62
a68 139
/* Regops and State definitions */

#define REGNODE_MAX           	90
#define REGMATCH_STATE_MAX    	130

#define	END                   	0	/* 0000 End of program. */
#define	SUCCEED               	1	/* 0x01 Return from a subroutine, basically. */
#define	BOL                   	2	/* 0x02 Match "" at beginning of line. */
#define	MBOL                  	3	/* 0x03 Same, assuming multiline. */
#define	SBOL                  	4	/* 0x04 Same, assuming singleline. */
#define	EOS                   	5	/* 0x05 Match "" at end of string. */
#define	EOL                   	6	/* 0x06 Match "" at end of line. */
#define	MEOL                  	7	/* 0x07 Same, assuming multiline. */
#define	SEOL                  	8	/* 0x08 Same, assuming singleline. */
#define	BOUND                 	9	/* 0x09 Match "" at any word boundary */
#define	BOUNDL                	10	/* 0x0a Match "" at any word boundary */
#define	NBOUND                	11	/* 0x0b Match "" at any word non-boundary */
#define	NBOUNDL               	12	/* 0x0c Match "" at any word non-boundary */
#define	GPOS                  	13	/* 0x0d Matches where last m//g left off. */
#define	REG_ANY               	14	/* 0x0e Match any one character (except newline). */
#define	SANY                  	15	/* 0x0f Match any one character. */
#define	CANY                  	16	/* 0x10 Match any one byte. */
#define	ANYOF                 	17	/* 0x11 Match character in (or not in) this class. */
#define	ALNUM                 	18	/* 0x12 Match any alphanumeric character */
#define	ALNUML                	19	/* 0x13 Match any alphanumeric char in locale */
#define	NALNUM                	20	/* 0x14 Match any non-alphanumeric character */
#define	NALNUML               	21	/* 0x15 Match any non-alphanumeric char in locale */
#define	SPACE                 	22	/* 0x16 Match any whitespace character */
#define	SPACEL                	23	/* 0x17 Match any whitespace char in locale */
#define	NSPACE                	24	/* 0x18 Match any non-whitespace character */
#define	NSPACEL               	25	/* 0x19 Match any non-whitespace char in locale */
#define	DIGIT                 	26	/* 0x1a Match any numeric character */
#define	DIGITL                	27	/* 0x1b Match any numeric character in locale */
#define	NDIGIT                	28	/* 0x1c Match any non-numeric character */
#define	NDIGITL               	29	/* 0x1d Match any non-numeric character in locale */
#define	CLUMP                 	30	/* 0x1e Match any combining character sequence */
#define	BRANCH                	31	/* 0x1f Match this alternative, or the next... */
#define	BACK                  	32	/* 0x20 Match "", "next" ptr points backward. */
#define	EXACT                 	33	/* 0x21 Match this string (preceded by length). */
#define	EXACTF                	34	/* 0x22 Match this string, folded (prec. by length). */
#define	EXACTFL               	35	/* 0x23 Match this string, folded in locale (w/len). */
#define	NOTHING               	36	/* 0x24 Match empty string. */
#define	TAIL                  	37	/* 0x25 Match empty string. Can jump here from outside. */
#define	STAR                  	38	/* 0x26 Match this (simple) thing 0 or more times. */
#define	PLUS                  	39	/* 0x27 Match this (simple) thing 1 or more times. */
#define	CURLY                 	40	/* 0x28 Match this simple thing {n,m} times. */
#define	CURLYN                	41	/* 0x29 Capture next-after-this simple thing */
#define	CURLYM                	42	/* 0x2a Capture this medium-complex thing {n,m} times. */
#define	CURLYX                	43	/* 0x2b Match this complex thing {n,m} times. */
#define	WHILEM                	44	/* 0x2c Do curly processing and see if rest matches. */
#define	OPEN                  	45	/* 0x2d Mark this point in input as start of */
#define	CLOSE                 	46	/* 0x2e Analogous to OPEN. */
#define	REF                   	47	/* 0x2f Match some already matched string */
#define	REFF                  	48	/* 0x30 Match already matched string, folded */
#define	REFFL                 	49	/* 0x31 Match already matched string, folded in loc. */
#define	IFMATCH               	50	/* 0x32 Succeeds if the following matches. */
#define	UNLESSM               	51	/* 0x33 Fails if the following matches. */
#define	SUSPEND               	52	/* 0x34 "Independent" sub-RE. */
#define	IFTHEN                	53	/* 0x35 Switch, should be preceeded by switcher . */
#define	GROUPP                	54	/* 0x36 Whether the group matched. */
#define	LONGJMP               	55	/* 0x37 Jump far away. */
#define	BRANCHJ               	56	/* 0x38 BRANCH with long offset. */
#define	EVAL                  	57	/* 0x39 Execute some Perl code. */
#define	MINMOD                	58	/* 0x3a Next operator is not greedy. */
#define	LOGICAL               	59	/* 0x3b Next opcode should set the flag only. */
#define	RENUM                 	60	/* 0x3c Group with independently numbered parens. */
#define	TRIE                  	61	/* 0x3d Match many EXACT(FL?)? at once. flags==type */
#define	TRIEC                 	62	/* 0x3e Same as TRIE, but with embedded charclass data */
#define	AHOCORASICK           	63	/* 0x3f Aho Corasick stclass. flags==type */
#define	AHOCORASICKC          	64	/* 0x40 Same as AHOCORASICK, but with embedded charclass data */
#define	GOSUB                 	65	/* 0x41 recurse to paren arg1 at (signed) ofs arg2 */
#define	GOSTART               	66	/* 0x42 recurse to start of pattern */
#define	NREF                  	67	/* 0x43 Match some already matched string */
#define	NREFF                 	68	/* 0x44 Match already matched string, folded */
#define	NREFFL                	69	/* 0x45 Match already matched string, folded in loc. */
#define	NGROUPP               	70	/* 0x46 Whether the group matched. */
#define	INSUBP                	71	/* 0x47 Whether we are in a specific recurse. */
#define	DEFINEP               	72	/* 0x48 Never execute directly. */
#define	ENDLIKE               	73	/* 0x49 Used only for the type field of verbs */
#define	OPFAIL                	74	/* 0x4a Same as (?!) */
#define	ACCEPT                	75	/* 0x4b Accepts the current matched string. */
#define	VERB                  	76	/* 0x4c    no-sv 1	Used only for the type field of verbs */
#define	PRUNE                 	77	/* 0x4d Pattern fails at this startpoint if no-backtracking through this */
#define	MARKPOINT             	78	/* 0x4e Push the current location for rollback by cut. */
#define	SKIP                  	79	/* 0x4f On failure skip forward (to the mark) before retrying */
#define	COMMIT                	80	/* 0x50 Pattern fails outright if backtracking through this */
#define	CUTGROUP              	81	/* 0x51 On failure go to the next alternation in the group */
#define	KEEPS                 	82	/* 0x52 $& begins here. */
#define	LNBREAK               	83	/* 0x53 generic newline pattern */
#define	VERTWS                	84	/* 0x54 vertical whitespace         (Perl 6) */
#define	NVERTWS               	85	/* 0x55 not vertical whitespace     (Perl 6) */
#define	HORIZWS               	86	/* 0x56 horizontal whitespace       (Perl 6) */
#define	NHORIZWS              	87	/* 0x57 not horizontal whitespace   (Perl 6) */
#define	FOLDCHAR              	88	/* 0x58 codepoint with tricky case folding properties. */
#define	OPTIMIZED             	89	/* 0x59 Placeholder for dump. */
#define	PSEUDO                	90	/* 0x5a Pseudo opcode for internal use. */
	/* ------------ States ------------- */
#define	TRIE_next             	(REGNODE_MAX + 1)	/* state for TRIE */
#define	TRIE_next_fail        	(REGNODE_MAX + 2)	/* state for TRIE */
#define	EVAL_AB               	(REGNODE_MAX + 3)	/* state for EVAL */
#define	EVAL_AB_fail          	(REGNODE_MAX + 4)	/* state for EVAL */
#define	CURLYX_end            	(REGNODE_MAX + 5)	/* state for CURLYX */
#define	CURLYX_end_fail       	(REGNODE_MAX + 6)	/* state for CURLYX */
#define	WHILEM_A_pre          	(REGNODE_MAX + 7)	/* state for WHILEM */
#define	WHILEM_A_pre_fail     	(REGNODE_MAX + 8)	/* state for WHILEM */
#define	WHILEM_A_min          	(REGNODE_MAX + 9)	/* state for WHILEM */
#define	WHILEM_A_min_fail     	(REGNODE_MAX + 10)	/* state for WHILEM */
#define	WHILEM_A_max          	(REGNODE_MAX + 11)	/* state for WHILEM */
#define	WHILEM_A_max_fail     	(REGNODE_MAX + 12)	/* state for WHILEM */
#define	WHILEM_B_min          	(REGNODE_MAX + 13)	/* state for WHILEM */
#define	WHILEM_B_min_fail     	(REGNODE_MAX + 14)	/* state for WHILEM */
#define	WHILEM_B_max          	(REGNODE_MAX + 15)	/* state for WHILEM */
#define	WHILEM_B_max_fail     	(REGNODE_MAX + 16)	/* state for WHILEM */
#define	BRANCH_next           	(REGNODE_MAX + 17)	/* state for BRANCH */
#define	BRANCH_next_fail      	(REGNODE_MAX + 18)	/* state for BRANCH */
#define	CURLYM_A              	(REGNODE_MAX + 19)	/* state for CURLYM */
#define	CURLYM_A_fail         	(REGNODE_MAX + 20)	/* state for CURLYM */
#define	CURLYM_B              	(REGNODE_MAX + 21)	/* state for CURLYM */
#define	CURLYM_B_fail         	(REGNODE_MAX + 22)	/* state for CURLYM */
#define	IFMATCH_A             	(REGNODE_MAX + 23)	/* state for IFMATCH */
#define	IFMATCH_A_fail        	(REGNODE_MAX + 24)	/* state for IFMATCH */
#define	CURLY_B_min_known     	(REGNODE_MAX + 25)	/* state for CURLY */
#define	CURLY_B_min_known_fail	(REGNODE_MAX + 26)	/* state for CURLY */
#define	CURLY_B_min           	(REGNODE_MAX + 27)	/* state for CURLY */
#define	CURLY_B_min_fail      	(REGNODE_MAX + 28)	/* state for CURLY */
#define	CURLY_B_max           	(REGNODE_MAX + 29)	/* state for CURLY */
#define	CURLY_B_max_fail      	(REGNODE_MAX + 30)	/* state for CURLY */
#define	COMMIT_next           	(REGNODE_MAX + 31)	/* state for COMMIT */
#define	COMMIT_next_fail      	(REGNODE_MAX + 32)	/* state for COMMIT */
#define	MARKPOINT_next        	(REGNODE_MAX + 33)	/* state for MARKPOINT */
#define	MARKPOINT_next_fail   	(REGNODE_MAX + 34)	/* state for MARKPOINT */
#define	SKIP_next             	(REGNODE_MAX + 35)	/* state for SKIP */
#define	SKIP_next_fail        	(REGNODE_MAX + 36)	/* state for SKIP */
#define	CUTGROUP_next         	(REGNODE_MAX + 37)	/* state for CUTGROUP */
#define	CUTGROUP_next_fail    	(REGNODE_MAX + 38)	/* state for CUTGROUP */
#define	KEEPS_next            	(REGNODE_MAX + 39)	/* state for KEEPS */
#define	KEEPS_next_fail       	(REGNODE_MAX + 40)	/* state for KEEPS */

/* PL_regkind[] What type of regop or state is this. */
d74 62
a135 132
	END,      	/* END                    */
	END,      	/* SUCCEED                */
	BOL,      	/* BOL                    */
	BOL,      	/* MBOL                   */
	BOL,      	/* SBOL                   */
	EOL,      	/* EOS                    */
	EOL,      	/* EOL                    */
	EOL,      	/* MEOL                   */
	EOL,      	/* SEOL                   */
	BOUND,    	/* BOUND                  */
	BOUND,    	/* BOUNDL                 */
	NBOUND,   	/* NBOUND                 */
	NBOUND,   	/* NBOUNDL                */
	GPOS,     	/* GPOS                   */
	REG_ANY,  	/* REG_ANY                */
	REG_ANY,  	/* SANY                   */
	REG_ANY,  	/* CANY                   */
	ANYOF,    	/* ANYOF                  */
	ALNUM,    	/* ALNUM                  */
	ALNUM,    	/* ALNUML                 */
	NALNUM,   	/* NALNUM                 */
	NALNUM,   	/* NALNUML                */
	SPACE,    	/* SPACE                  */
	SPACE,    	/* SPACEL                 */
	NSPACE,   	/* NSPACE                 */
	NSPACE,   	/* NSPACEL                */
	DIGIT,    	/* DIGIT                  */
	DIGIT,    	/* DIGITL                 */
	NDIGIT,   	/* NDIGIT                 */
	NDIGIT,   	/* NDIGITL                */
	CLUMP,    	/* CLUMP                  */
	BRANCH,   	/* BRANCH                 */
	BACK,     	/* BACK                   */
	EXACT,    	/* EXACT                  */
	EXACT,    	/* EXACTF                 */
	EXACT,    	/* EXACTFL                */
	NOTHING,  	/* NOTHING                */
	NOTHING,  	/* TAIL                   */
	STAR,     	/* STAR                   */
	PLUS,     	/* PLUS                   */
	CURLY,    	/* CURLY                  */
	CURLY,    	/* CURLYN                 */
	CURLY,    	/* CURLYM                 */
	CURLY,    	/* CURLYX                 */
	WHILEM,   	/* WHILEM                 */
	OPEN,     	/* OPEN                   */
	CLOSE,    	/* CLOSE                  */
	REF,      	/* REF                    */
	REF,      	/* REFF                   */
	REF,      	/* REFFL                  */
	BRANCHJ,  	/* IFMATCH                */
	BRANCHJ,  	/* UNLESSM                */
	BRANCHJ,  	/* SUSPEND                */
	BRANCHJ,  	/* IFTHEN                 */
	GROUPP,   	/* GROUPP                 */
	LONGJMP,  	/* LONGJMP                */
	BRANCHJ,  	/* BRANCHJ                */
	EVAL,     	/* EVAL                   */
	MINMOD,   	/* MINMOD                 */
	LOGICAL,  	/* LOGICAL                */
	BRANCHJ,  	/* RENUM                  */
	TRIE,     	/* TRIE                   */
	TRIE,     	/* TRIEC                  */
	TRIE,     	/* AHOCORASICK            */
	TRIE,     	/* AHOCORASICKC           */
	GOSUB,    	/* GOSUB                  */
	GOSTART,  	/* GOSTART                */
	REF,      	/* NREF                   */
	REF,      	/* NREFF                  */
	REF,      	/* NREFFL                 */
	NGROUPP,  	/* NGROUPP                */
	INSUBP,   	/* INSUBP                 */
	DEFINEP,  	/* DEFINEP                */
	ENDLIKE,  	/* ENDLIKE                */
	ENDLIKE,  	/* OPFAIL                 */
	ENDLIKE,  	/* ACCEPT                 */
	VERB,     	/* VERB                   */
	VERB,     	/* PRUNE                  */
	VERB,     	/* MARKPOINT              */
	VERB,     	/* SKIP                   */
	VERB,     	/* COMMIT                 */
	VERB,     	/* CUTGROUP               */
	KEEPS,    	/* KEEPS                  */
	LNBREAK,  	/* LNBREAK                */
	VERTWS,   	/* VERTWS                 */
	NVERTWS,  	/* NVERTWS                */
	HORIZWS,  	/* HORIZWS                */
	NHORIZWS, 	/* NHORIZWS               */
	FOLDCHAR, 	/* FOLDCHAR               */
	NOTHING,  	/* OPTIMIZED              */
	PSEUDO,   	/* PSEUDO                 */
	/* ------------ States ------------- */
	TRIE,     	/* TRIE_next              */
	TRIE,     	/* TRIE_next_fail         */
	EVAL,     	/* EVAL_AB                */
	EVAL,     	/* EVAL_AB_fail           */
	CURLYX,   	/* CURLYX_end             */
	CURLYX,   	/* CURLYX_end_fail        */
	WHILEM,   	/* WHILEM_A_pre           */
	WHILEM,   	/* WHILEM_A_pre_fail      */
	WHILEM,   	/* WHILEM_A_min           */
	WHILEM,   	/* WHILEM_A_min_fail      */
	WHILEM,   	/* WHILEM_A_max           */
	WHILEM,   	/* WHILEM_A_max_fail      */
	WHILEM,   	/* WHILEM_B_min           */
	WHILEM,   	/* WHILEM_B_min_fail      */
	WHILEM,   	/* WHILEM_B_max           */
	WHILEM,   	/* WHILEM_B_max_fail      */
	BRANCH,   	/* BRANCH_next            */
	BRANCH,   	/* BRANCH_next_fail       */
	CURLYM,   	/* CURLYM_A               */
	CURLYM,   	/* CURLYM_A_fail          */
	CURLYM,   	/* CURLYM_B               */
	CURLYM,   	/* CURLYM_B_fail          */
	IFMATCH,  	/* IFMATCH_A              */
	IFMATCH,  	/* IFMATCH_A_fail         */
	CURLY,    	/* CURLY_B_min_known      */
	CURLY,    	/* CURLY_B_min_known_fail */
	CURLY,    	/* CURLY_B_min            */
	CURLY,    	/* CURLY_B_min_fail       */
	CURLY,    	/* CURLY_B_max            */
	CURLY,    	/* CURLY_B_max_fail       */
	COMMIT,   	/* COMMIT_next            */
	COMMIT,   	/* COMMIT_next_fail       */
	MARKPOINT,	/* MARKPOINT_next         */
	MARKPOINT,	/* MARKPOINT_next_fail    */
	SKIP,     	/* SKIP_next              */
	SKIP,     	/* SKIP_next_fail         */
	CUTGROUP, 	/* CUTGROUP_next          */
	CUTGROUP, 	/* CUTGROUP_next_fail     */
	KEEPS,    	/* KEEPS_next             */
	KEEPS,    	/* KEEPS_next_fail        */
a138 1
/* regarglen[] - How large is the argument part of the node (in regnodes) */
d142 62
a203 91
	0,                                   	/* END          */
	0,                                   	/* SUCCEED      */
	0,                                   	/* BOL          */
	0,                                   	/* MBOL         */
	0,                                   	/* SBOL         */
	0,                                   	/* EOS          */
	0,                                   	/* EOL          */
	0,                                   	/* MEOL         */
	0,                                   	/* SEOL         */
	0,                                   	/* BOUND        */
	0,                                   	/* BOUNDL       */
	0,                                   	/* NBOUND       */
	0,                                   	/* NBOUNDL      */
	0,                                   	/* GPOS         */
	0,                                   	/* REG_ANY      */
	0,                                   	/* SANY         */
	0,                                   	/* CANY         */
	0,                                   	/* ANYOF        */
	0,                                   	/* ALNUM        */
	0,                                   	/* ALNUML       */
	0,                                   	/* NALNUM       */
	0,                                   	/* NALNUML      */
	0,                                   	/* SPACE        */
	0,                                   	/* SPACEL       */
	0,                                   	/* NSPACE       */
	0,                                   	/* NSPACEL      */
	0,                                   	/* DIGIT        */
	0,                                   	/* DIGITL       */
	0,                                   	/* NDIGIT       */
	0,                                   	/* NDIGITL      */
	0,                                   	/* CLUMP        */
	0,                                   	/* BRANCH       */
	0,                                   	/* BACK         */
	0,                                   	/* EXACT        */
	0,                                   	/* EXACTF       */
	0,                                   	/* EXACTFL      */
	0,                                   	/* NOTHING      */
	0,                                   	/* TAIL         */
	0,                                   	/* STAR         */
	0,                                   	/* PLUS         */
	EXTRA_SIZE(struct regnode_2),        	/* CURLY        */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYN       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYM       */
	EXTRA_SIZE(struct regnode_2),        	/* CURLYX       */
	0,                                   	/* WHILEM       */
	EXTRA_SIZE(struct regnode_1),        	/* OPEN         */
	EXTRA_SIZE(struct regnode_1),        	/* CLOSE        */
	EXTRA_SIZE(struct regnode_1),        	/* REF          */
	EXTRA_SIZE(struct regnode_1),        	/* REFF         */
	EXTRA_SIZE(struct regnode_1),        	/* REFFL        */
	EXTRA_SIZE(struct regnode_1),        	/* IFMATCH      */
	EXTRA_SIZE(struct regnode_1),        	/* UNLESSM      */
	EXTRA_SIZE(struct regnode_1),        	/* SUSPEND      */
	EXTRA_SIZE(struct regnode_1),        	/* IFTHEN       */
	EXTRA_SIZE(struct regnode_1),        	/* GROUPP       */
	EXTRA_SIZE(struct regnode_1),        	/* LONGJMP      */
	EXTRA_SIZE(struct regnode_1),        	/* BRANCHJ      */
	EXTRA_SIZE(struct regnode_1),        	/* EVAL         */
	0,                                   	/* MINMOD       */
	0,                                   	/* LOGICAL      */
	EXTRA_SIZE(struct regnode_1),        	/* RENUM        */
	EXTRA_SIZE(struct regnode_1),        	/* TRIE         */
	EXTRA_SIZE(struct regnode_charclass),	/* TRIEC        */
	EXTRA_SIZE(struct regnode_1),        	/* AHOCORASICK  */
	EXTRA_SIZE(struct regnode_charclass),	/* AHOCORASICKC */
	EXTRA_SIZE(struct regnode_2L),       	/* GOSUB        */
	0,                                   	/* GOSTART      */
	EXTRA_SIZE(struct regnode_1),        	/* NREF         */
	EXTRA_SIZE(struct regnode_1),        	/* NREFF        */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFL       */
	EXTRA_SIZE(struct regnode_1),        	/* NGROUPP      */
	EXTRA_SIZE(struct regnode_1),        	/* INSUBP       */
	EXTRA_SIZE(struct regnode_1),        	/* DEFINEP      */
	0,                                   	/* ENDLIKE      */
	0,                                   	/* OPFAIL       */
	EXTRA_SIZE(struct regnode_1),        	/* ACCEPT       */
	0,                                   	/* VERB         */
	EXTRA_SIZE(struct regnode_1),        	/* PRUNE        */
	EXTRA_SIZE(struct regnode_1),        	/* MARKPOINT    */
	EXTRA_SIZE(struct regnode_1),        	/* SKIP         */
	EXTRA_SIZE(struct regnode_1),        	/* COMMIT       */
	EXTRA_SIZE(struct regnode_1),        	/* CUTGROUP     */
	0,                                   	/* KEEPS        */
	0,                                   	/* LNBREAK      */
	0,                                   	/* VERTWS       */
	0,                                   	/* NVERTWS      */
	0,                                   	/* HORIZWS      */
	0,                                   	/* NHORIZWS     */
	EXTRA_SIZE(struct regnode_1),        	/* FOLDCHAR     */
	0,                                   	/* OPTIMIZED    */
	0,                                   	/* PSEUDO       */
a205 2
/* reg_off_by_arg[] - Which argument holds the offset to the next node */

d207 62
a268 91
	0,	/* END          */
	0,	/* SUCCEED      */
	0,	/* BOL          */
	0,	/* MBOL         */
	0,	/* SBOL         */
	0,	/* EOS          */
	0,	/* EOL          */
	0,	/* MEOL         */
	0,	/* SEOL         */
	0,	/* BOUND        */
	0,	/* BOUNDL       */
	0,	/* NBOUND       */
	0,	/* NBOUNDL      */
	0,	/* GPOS         */
	0,	/* REG_ANY      */
	0,	/* SANY         */
	0,	/* CANY         */
	0,	/* ANYOF        */
	0,	/* ALNUM        */
	0,	/* ALNUML       */
	0,	/* NALNUM       */
	0,	/* NALNUML      */
	0,	/* SPACE        */
	0,	/* SPACEL       */
	0,	/* NSPACE       */
	0,	/* NSPACEL      */
	0,	/* DIGIT        */
	0,	/* DIGITL       */
	0,	/* NDIGIT       */
	0,	/* NDIGITL      */
	0,	/* CLUMP        */
	0,	/* BRANCH       */
	0,	/* BACK         */
	0,	/* EXACT        */
	0,	/* EXACTF       */
	0,	/* EXACTFL      */
	0,	/* NOTHING      */
	0,	/* TAIL         */
	0,	/* STAR         */
	0,	/* PLUS         */
	0,	/* CURLY        */
	0,	/* CURLYN       */
	0,	/* CURLYM       */
	0,	/* CURLYX       */
	0,	/* WHILEM       */
	0,	/* OPEN         */
	0,	/* CLOSE        */
	0,	/* REF          */
	0,	/* REFF         */
	0,	/* REFFL        */
	2,	/* IFMATCH      */
	2,	/* UNLESSM      */
	1,	/* SUSPEND      */
	1,	/* IFTHEN       */
	0,	/* GROUPP       */
	1,	/* LONGJMP      */
	1,	/* BRANCHJ      */
	0,	/* EVAL         */
	0,	/* MINMOD       */
	0,	/* LOGICAL      */
	1,	/* RENUM        */
	0,	/* TRIE         */
	0,	/* TRIEC        */
	0,	/* AHOCORASICK  */
	0,	/* AHOCORASICKC */
	0,	/* GOSUB        */
	0,	/* GOSTART      */
	0,	/* NREF         */
	0,	/* NREFF        */
	0,	/* NREFFL       */
	0,	/* NGROUPP      */
	0,	/* INSUBP       */
	0,	/* DEFINEP      */
	0,	/* ENDLIKE      */
	0,	/* OPFAIL       */
	0,	/* ACCEPT       */
	0,	/* VERB         */
	0,	/* PRUNE        */
	0,	/* MARKPOINT    */
	0,	/* SKIP         */
	0,	/* COMMIT       */
	0,	/* CUTGROUP     */
	0,	/* KEEPS        */
	0,	/* LNBREAK      */
	0,	/* VERTWS       */
	0,	/* NVERTWS      */
	0,	/* HORIZWS      */
	0,	/* NHORIZWS     */
	0,	/* FOLDCHAR     */
	0,	/* OPTIMIZED    */
	0,	/* PSEUDO       */
d271 64
a334 140
#endif /* REG_COMP_C */

/* reg_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_name[];
#else
EXTCONST char * const PL_reg_name[] = {
	"END",                   	/* 0000 */
	"SUCCEED",               	/* 0x01 */
	"BOL",                   	/* 0x02 */
	"MBOL",                  	/* 0x03 */
	"SBOL",                  	/* 0x04 */
	"EOS",                   	/* 0x05 */
	"EOL",                   	/* 0x06 */
	"MEOL",                  	/* 0x07 */
	"SEOL",                  	/* 0x08 */
	"BOUND",                 	/* 0x09 */
	"BOUNDL",                	/* 0x0a */
	"NBOUND",                	/* 0x0b */
	"NBOUNDL",               	/* 0x0c */
	"GPOS",                  	/* 0x0d */
	"REG_ANY",               	/* 0x0e */
	"SANY",                  	/* 0x0f */
	"CANY",                  	/* 0x10 */
	"ANYOF",                 	/* 0x11 */
	"ALNUM",                 	/* 0x12 */
	"ALNUML",                	/* 0x13 */
	"NALNUM",                	/* 0x14 */
	"NALNUML",               	/* 0x15 */
	"SPACE",                 	/* 0x16 */
	"SPACEL",                	/* 0x17 */
	"NSPACE",                	/* 0x18 */
	"NSPACEL",               	/* 0x19 */
	"DIGIT",                 	/* 0x1a */
	"DIGITL",                	/* 0x1b */
	"NDIGIT",                	/* 0x1c */
	"NDIGITL",               	/* 0x1d */
	"CLUMP",                 	/* 0x1e */
	"BRANCH",                	/* 0x1f */
	"BACK",                  	/* 0x20 */
	"EXACT",                 	/* 0x21 */
	"EXACTF",                	/* 0x22 */
	"EXACTFL",               	/* 0x23 */
	"NOTHING",               	/* 0x24 */
	"TAIL",                  	/* 0x25 */
	"STAR",                  	/* 0x26 */
	"PLUS",                  	/* 0x27 */
	"CURLY",                 	/* 0x28 */
	"CURLYN",                	/* 0x29 */
	"CURLYM",                	/* 0x2a */
	"CURLYX",                	/* 0x2b */
	"WHILEM",                	/* 0x2c */
	"OPEN",                  	/* 0x2d */
	"CLOSE",                 	/* 0x2e */
	"REF",                   	/* 0x2f */
	"REFF",                  	/* 0x30 */
	"REFFL",                 	/* 0x31 */
	"IFMATCH",               	/* 0x32 */
	"UNLESSM",               	/* 0x33 */
	"SUSPEND",               	/* 0x34 */
	"IFTHEN",                	/* 0x35 */
	"GROUPP",                	/* 0x36 */
	"LONGJMP",               	/* 0x37 */
	"BRANCHJ",               	/* 0x38 */
	"EVAL",                  	/* 0x39 */
	"MINMOD",                	/* 0x3a */
	"LOGICAL",               	/* 0x3b */
	"RENUM",                 	/* 0x3c */
	"TRIE",                  	/* 0x3d */
	"TRIEC",                 	/* 0x3e */
	"AHOCORASICK",           	/* 0x3f */
	"AHOCORASICKC",          	/* 0x40 */
	"GOSUB",                 	/* 0x41 */
	"GOSTART",               	/* 0x42 */
	"NREF",                  	/* 0x43 */
	"NREFF",                 	/* 0x44 */
	"NREFFL",                	/* 0x45 */
	"NGROUPP",               	/* 0x46 */
	"INSUBP",                	/* 0x47 */
	"DEFINEP",               	/* 0x48 */
	"ENDLIKE",               	/* 0x49 */
	"OPFAIL",                	/* 0x4a */
	"ACCEPT",                	/* 0x4b */
	"VERB",                  	/* 0x4c */
	"PRUNE",                 	/* 0x4d */
	"MARKPOINT",             	/* 0x4e */
	"SKIP",                  	/* 0x4f */
	"COMMIT",                	/* 0x50 */
	"CUTGROUP",              	/* 0x51 */
	"KEEPS",                 	/* 0x52 */
	"LNBREAK",               	/* 0x53 */
	"VERTWS",                	/* 0x54 */
	"NVERTWS",               	/* 0x55 */
	"HORIZWS",               	/* 0x56 */
	"NHORIZWS",              	/* 0x57 */
	"FOLDCHAR",              	/* 0x58 */
	"OPTIMIZED",             	/* 0x59 */
	"PSEUDO",                	/* 0x5a */
	/* ------------ States ------------- */
	"TRIE_next",             	/* REGNODE_MAX +0x01 */
	"TRIE_next_fail",        	/* REGNODE_MAX +0x02 */
	"EVAL_AB",               	/* REGNODE_MAX +0x03 */
	"EVAL_AB_fail",          	/* REGNODE_MAX +0x04 */
	"CURLYX_end",            	/* REGNODE_MAX +0x05 */
	"CURLYX_end_fail",       	/* REGNODE_MAX +0x06 */
	"WHILEM_A_pre",          	/* REGNODE_MAX +0x07 */
	"WHILEM_A_pre_fail",     	/* REGNODE_MAX +0x08 */
	"WHILEM_A_min",          	/* REGNODE_MAX +0x09 */
	"WHILEM_A_min_fail",     	/* REGNODE_MAX +0x0a */
	"WHILEM_A_max",          	/* REGNODE_MAX +0x0b */
	"WHILEM_A_max_fail",     	/* REGNODE_MAX +0x0c */
	"WHILEM_B_min",          	/* REGNODE_MAX +0x0d */
	"WHILEM_B_min_fail",     	/* REGNODE_MAX +0x0e */
	"WHILEM_B_max",          	/* REGNODE_MAX +0x0f */
	"WHILEM_B_max_fail",     	/* REGNODE_MAX +0x10 */
	"BRANCH_next",           	/* REGNODE_MAX +0x11 */
	"BRANCH_next_fail",      	/* REGNODE_MAX +0x12 */
	"CURLYM_A",              	/* REGNODE_MAX +0x13 */
	"CURLYM_A_fail",         	/* REGNODE_MAX +0x14 */
	"CURLYM_B",              	/* REGNODE_MAX +0x15 */
	"CURLYM_B_fail",         	/* REGNODE_MAX +0x16 */
	"IFMATCH_A",             	/* REGNODE_MAX +0x17 */
	"IFMATCH_A_fail",        	/* REGNODE_MAX +0x18 */
	"CURLY_B_min_known",     	/* REGNODE_MAX +0x19 */
	"CURLY_B_min_known_fail",	/* REGNODE_MAX +0x1a */
	"CURLY_B_min",           	/* REGNODE_MAX +0x1b */
	"CURLY_B_min_fail",      	/* REGNODE_MAX +0x1c */
	"CURLY_B_max",           	/* REGNODE_MAX +0x1d */
	"CURLY_B_max_fail",      	/* REGNODE_MAX +0x1e */
	"COMMIT_next",           	/* REGNODE_MAX +0x1f */
	"COMMIT_next_fail",      	/* REGNODE_MAX +0x20 */
	"MARKPOINT_next",        	/* REGNODE_MAX +0x21 */
	"MARKPOINT_next_fail",   	/* REGNODE_MAX +0x22 */
	"SKIP_next",             	/* REGNODE_MAX +0x23 */
	"SKIP_next_fail",        	/* REGNODE_MAX +0x24 */
	"CUTGROUP_next",         	/* REGNODE_MAX +0x25 */
	"CUTGROUP_next_fail",    	/* REGNODE_MAX +0x26 */
	"KEEPS_next",            	/* REGNODE_MAX +0x27 */
	"KEEPS_next_fail",       	/* REGNODE_MAX +0x28 */
a335 1
#endif /* DOINIT */
d337 1
a337 1
/* PL_reg_extflags_name[] - Opcode/state names in string form, for debugging */
d339 2
a340 39
#ifndef DOINIT
EXTCONST char * PL_reg_extflags_name[];
#else
EXTCONST char * const PL_reg_extflags_name[] = {
	/* Bits in extflags defined: 11111111111111111111111100111111 */
	"ANCH_BOL",         /* 0x00000001 */
	"ANCH_MBOL",        /* 0x00000002 */
	"ANCH_SBOL",        /* 0x00000004 */
	"ANCH_GPOS",        /* 0x00000008 */
	"GPOS_SEEN",        /* 0x00000010 */
	"GPOS_FLOAT",       /* 0x00000020 */
	"UNUSED_BIT_6",     /* 0x00000040 */
	"UNUSED_BIT_7",     /* 0x00000080 */
	"SKIPWHITE",        /* 0x00000100 */
	"START_ONLY",       /* 0x00000200 */
	"WHITE",            /* 0x00000400 */
	"LOCALE",           /* 0x00000800 */
	"MULTILINE",        /* 0x00001000 */
	"SINGLELINE",       /* 0x00002000 */
	"FOLD",             /* 0x00004000 */
	"EXTENDED",         /* 0x00008000 */
	"KEEPCOPY",         /* 0x00010000 */
	"LOOKBEHIND_SEEN",  /* 0x00020000 */
	"EVAL_SEEN",        /* 0x00040000 */
	"CANY_SEEN",        /* 0x00080000 */
	"NOSCAN",           /* 0x00100000 */
	"CHECK_ALL",        /* 0x00200000 */
	"UTF8",             /* 0x00400000 */
	"MATCH_UTF8",       /* 0x00800000 */
	"USE_INTUIT_NOML",  /* 0x01000000 */
	"USE_INTUIT_ML",    /* 0x02000000 */
	"INTUIT_TAIL",      /* 0x04000000 */
	"SPLIT",            /* 0x08000000 */
	"COPY_DONE",        /* 0x10000000 */
	"TAINTED_SEEN",     /* 0x20000000 */
	"NULL",             /* 0x40000000 */
	"TAINTED",          /* 0x80000000 */
};
#endif /* DOINIT */
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d628 7
a634 7
	/* Bits in extflags defined: 11111111111101111111111100111111 */
	"MULTILINE",        /* 0x00000001 */
	"SINGLELINE",       /* 0x00000002 */
	"FOLD",             /* 0x00000004 */
	"EXTENDED",         /* 0x00000008 */
	"KEEPCOPY",         /* 0x00000010 */
	"LOCALE",           /* 0x00000020 */
d637 24
a660 24
	"ANCH_BOL",         /* 0x00000100 */
	"ANCH_MBOL",        /* 0x00000200 */
	"ANCH_SBOL",        /* 0x00000400 */
	"ANCH_GPOS",        /* 0x00000800 */
	"GPOS_SEEN",        /* 0x00001000 */
	"GPOS_FLOAT",       /* 0x00002000 */
	"LOOKBEHIND_SEEN",  /* 0x00004000 */
	"EVAL_SEEN",        /* 0x00008000 */
	"CANY_SEEN",        /* 0x00010000 */
	"NOSCAN",           /* 0x00020000 */
	"CHECK_ALL",        /* 0x00040000 */
	"UNUSED_BIT_19",    /* 0x00080000 */
	"MATCH_UTF8",       /* 0x00100000 */
	"USE_INTUIT_NOML",  /* 0x00200000 */
	"USE_INTUIT_ML",    /* 0x00400000 */
	"INTUIT_TAIL",      /* 0x00800000 */
	"SPLIT",            /* 0x01000000 */
	"COPY_DONE",        /* 0x02000000 */
	"TAINTED_SEEN",     /* 0x04000000 */
	"TAINTED",          /* 0x08000000 */
	"START_ONLY",       /* 0x10000000 */
	"SKIPWHITE",        /* 0x20000000 */
	"WHITE",            /* 0x40000000 */
	"NULL",             /* 0x80000000 */
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
   This file is built by regen/regcomp.pl from regcomp.sym.
d5 1
a5 1
 */
d9 2
a10 2
#define REGNODE_MAX           	112
#define REGMATCH_STATE_MAX    	152
d21 82
a102 104
#define	BOUND                 	9	/* 0x09 Match "" at any word boundary using native charset semantics for non-utf8 */
#define	BOUNDL                	10	/* 0x0a Match "" at any locale word boundary */
#define	BOUNDU                	11	/* 0x0b Match "" at any word boundary using Unicode semantics */
#define	BOUNDA                	12	/* 0x0c Match "" at any word boundary using ASCII semantics */
#define	NBOUND                	13	/* 0x0d Match "" at any word non-boundary using native charset semantics for non-utf8 */
#define	NBOUNDL               	14	/* 0x0e Match "" at any locale word non-boundary */
#define	NBOUNDU               	15	/* 0x0f Match "" at any word non-boundary using Unicode semantics */
#define	NBOUNDA               	16	/* 0x10 Match "" at any word non-boundary using ASCII semantics */
#define	GPOS                  	17	/* 0x11 Matches where last m//g left off. */
#define	REG_ANY               	18	/* 0x12 Match any one character (except newline). */
#define	SANY                  	19	/* 0x13 Match any one character. */
#define	CANY                  	20	/* 0x14 Match any one byte. */
#define	ANYOF                 	21	/* 0x15 Match character in (or not in) this class, single char match only */
#define	ANYOFV                	22	/* 0x16 Match character in (or not in) this class, can match-multiple chars */
#define	ALNUM                 	23	/* 0x17 Match any alphanumeric character using native charset semantics for non-utf8 */
#define	ALNUML                	24	/* 0x18 Match any alphanumeric char in locale */
#define	ALNUMU                	25	/* 0x19 Match any alphanumeric char using Unicode semantics */
#define	ALNUMA                	26	/* 0x1a Match [A-Za-z_0-9] */
#define	NALNUM                	27	/* 0x1b Match any non-alphanumeric character using native charset semantics for non-utf8 */
#define	NALNUML               	28	/* 0x1c Match any non-alphanumeric char in locale */
#define	NALNUMU               	29	/* 0x1d Match any non-alphanumeric char using Unicode semantics */
#define	NALNUMA               	30	/* 0x1e Match [^A-Za-z_0-9] */
#define	SPACE                 	31	/* 0x1f Match any whitespace character using native charset semantics for non-utf8 */
#define	SPACEL                	32	/* 0x20 Match any whitespace char in locale */
#define	SPACEU                	33	/* 0x21 Match any whitespace char using Unicode semantics */
#define	SPACEA                	34	/* 0x22 Match [ \t\n\f\r] */
#define	NSPACE                	35	/* 0x23 Match any non-whitespace character using native charset semantics for non-utf8 */
#define	NSPACEL               	36	/* 0x24 Match any non-whitespace char in locale */
#define	NSPACEU               	37	/* 0x25 Match any non-whitespace char using Unicode semantics */
#define	NSPACEA               	38	/* 0x26 Match [^ \t\n\f\r] */
#define	DIGIT                 	39	/* 0x27 Match any numeric character using native charset semantics for non-utf8 */
#define	DIGITL                	40	/* 0x28 Match any numeric character in locale */
#define	DIGITA                	41	/* 0x29 Match [0-9] */
#define	NDIGIT                	42	/* 0x2a Match any non-numeric character using native charset semantics for non-utf8 */
#define	NDIGITL               	43	/* 0x2b Match any non-numeric character in locale */
#define	NDIGITA               	44	/* 0x2c Match [^0-9] */
#define	CLUMP                 	45	/* 0x2d Match any extended grapheme cluster sequence */
#define	BRANCH                	46	/* 0x2e Match this alternative, or the next... */
#define	BACK                  	47	/* 0x2f Match "", "next" ptr points backward. */
#define	EXACT                 	48	/* 0x30 Match this string (preceded by length). */
#define	EXACTF                	49	/* 0x31 Match this non-UTF-8 string (not guaranteed to be folded) using /id rules (w/len). */
#define	EXACTFL               	50	/* 0x32 Match this string (not guaranteed to be folded) using /il rules (w/len). */
#define	EXACTFU               	51	/* 0x33 Match this string (folded iff in UTF-8, length in folding doesn't change if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFU_SS            	52	/* 0x34 Match this string (folded iff in UTF-8, length in folding may change even if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFU_TRICKYFOLD    	53	/* 0x35 Match this folded UTF-8 string using /iu rules */
#define	EXACTFA               	54	/* 0x36 Match this string (not guaranteed to be folded) using /iaa rules (w/len). */
#define	NOTHING               	55	/* 0x37 Match empty string. */
#define	TAIL                  	56	/* 0x38 Match empty string. Can jump here from outside. */
#define	STAR                  	57	/* 0x39 Match this (simple) thing 0 or more times. */
#define	PLUS                  	58	/* 0x3a Match this (simple) thing 1 or more times. */
#define	CURLY                 	59	/* 0x3b Match this simple thing {n,m} times. */
#define	CURLYN                	60	/* 0x3c Capture next-after-this simple thing */
#define	CURLYM                	61	/* 0x3d Capture this medium-complex thing {n,m} times. */
#define	CURLYX                	62	/* 0x3e Match this complex thing {n,m} times. */
#define	WHILEM                	63	/* 0x3f Do curly processing and see if rest matches. */
#define	OPEN                  	64	/* 0x40 Mark this point in input as start of */
#define	CLOSE                 	65	/* 0x41 Analogous to OPEN. */
#define	REF                   	66	/* 0x42 Match some already matched string */
#define	REFF                  	67	/* 0x43 Match already matched string, folded using native charset semantics for non-utf8 */
#define	REFFL                 	68	/* 0x44 Match already matched string, folded in loc. */
#define	REFFU                 	69	/* 0x45 Match already matched string, folded using unicode semantics for non-utf8 */
#define	REFFA                 	70	/* 0x46 Match already matched string, folded using unicode semantics for non-utf8, no mixing ASCII, non-ASCII */
#define	NREF                  	71	/* 0x47 Match some already matched string */
#define	NREFF                 	72	/* 0x48 Match already matched string, folded using native charset semantics for non-utf8 */
#define	NREFFL                	73	/* 0x49 Match already matched string, folded in loc. */
#define	NREFFU                	74	/* 0x4a Match already matched string, folded using unicode semantics for non-utf8 */
#define	NREFFA                	75	/* 0x4b Match already matched string, folded using unicode semantics for non-utf8, no mixing ASCII, non-ASCII */
#define	IFMATCH               	76	/* 0x4c Succeeds if the following matches. */
#define	UNLESSM               	77	/* 0x4d Fails if the following matches. */
#define	SUSPEND               	78	/* 0x4e "Independent" sub-RE. */
#define	IFTHEN                	79	/* 0x4f Switch, should be preceded by switcher . */
#define	GROUPP                	80	/* 0x50 Whether the group matched. */
#define	LONGJMP               	81	/* 0x51 Jump far away. */
#define	BRANCHJ               	82	/* 0x52 BRANCH with long offset. */
#define	EVAL                  	83	/* 0x53 Execute some Perl code. */
#define	MINMOD                	84	/* 0x54 Next operator is not greedy. */
#define	LOGICAL               	85	/* 0x55 Next opcode should set the flag only. */
#define	RENUM                 	86	/* 0x56 Group with independently numbered parens. */
#define	TRIE                  	87	/* 0x57 Match many EXACT(F[ALU]?)? at once. flags==type */
#define	TRIEC                 	88	/* 0x58 Same as TRIE, but with embedded charclass data */
#define	AHOCORASICK           	89	/* 0x59 Aho Corasick stclass. flags==type */
#define	AHOCORASICKC          	90	/* 0x5a Same as AHOCORASICK, but with embedded charclass data */
#define	GOSUB                 	91	/* 0x5b recurse to paren arg1 at (signed) ofs arg2 */
#define	GOSTART               	92	/* 0x5c recurse to start of pattern */
#define	NGROUPP               	93	/* 0x5d Whether the group matched. */
#define	INSUBP                	94	/* 0x5e Whether we are in a specific recurse. */
#define	DEFINEP               	95	/* 0x5f Never execute directly. */
#define	ENDLIKE               	96	/* 0x60 Used only for the type field of verbs */
#define	OPFAIL                	97	/* 0x61 Same as (?!) */
#define	ACCEPT                	98	/* 0x62 Accepts the current matched string. */
#define	VERB                  	99	/* 0x63 Used only for the type field of verbs */
#define	PRUNE                 	100	/* 0x64 Pattern fails at this startpoint if no-backtracking through this */
#define	MARKPOINT             	101	/* 0x65 Push the current location for rollback by cut. */
#define	SKIP                  	102	/* 0x66 On failure skip forward (to the mark) before retrying */
#define	COMMIT                	103	/* 0x67 Pattern fails outright if backtracking through this */
#define	CUTGROUP              	104	/* 0x68 On failure go to the next alternation in the group */
#define	KEEPS                 	105	/* 0x69 $& begins here. */
#define	LNBREAK               	106	/* 0x6a generic newline pattern */
#define	VERTWS                	107	/* 0x6b vertical whitespace         (Perl 6) */
#define	NVERTWS               	108	/* 0x6c not vertical whitespace     (Perl 6) */
#define	HORIZWS               	109	/* 0x6d horizontal whitespace       (Perl 6) */
#define	NHORIZWS              	110	/* 0x6e not horizontal whitespace   (Perl 6) */
#define	OPTIMIZED             	111	/* 0x6f Placeholder for dump. */
#define	PSEUDO                	112	/* 0x70 Pseudo opcode for internal use. */
a161 2
	BOUND,    	/* BOUNDU                 */
	BOUND,    	/* BOUNDA                 */
a163 2
	NBOUND,   	/* NBOUNDU                */
	NBOUND,   	/* NBOUNDA                */
a168 1
	ANYOF,    	/* ANYOFV                 */
a170 2
	ALNUM,    	/* ALNUMU                 */
	ALNUM,    	/* ALNUMA                 */
a172 2
	NALNUM,   	/* NALNUMU                */
	NALNUM,   	/* NALNUMA                */
a174 2
	SPACE,    	/* SPACEU                 */
	SPACE,    	/* SPACEA                 */
a176 2
	NSPACE,   	/* NSPACEU                */
	NSPACE,   	/* NSPACEA                */
a178 1
	DIGIT,    	/* DIGITA                 */
a180 1
	NDIGIT,   	/* NDIGITA                */
a186 4
	EXACT,    	/* EXACTFU                */
	EXACT,    	/* EXACTFU_SS             */
	EXACT,    	/* EXACTFU_TRICKYFOLD     */
	EXACT,    	/* EXACTFA                */
a200 7
	REF,      	/* REFFU                  */
	REF,      	/* REFFA                  */
	REF,      	/* NREF                   */
	REF,      	/* NREFF                  */
	REF,      	/* NREFFL                 */
	REF,      	/* NREFFU                 */
	REF,      	/* NREFFA                 */
d218 3
d239 1
a300 2
	0,                                   	/* BOUNDU       */
	0,                                   	/* BOUNDA       */
a302 2
	0,                                   	/* NBOUNDU      */
	0,                                   	/* NBOUNDA      */
a307 1
	0,                                   	/* ANYOFV       */
a309 2
	0,                                   	/* ALNUMU       */
	0,                                   	/* ALNUMA       */
a311 2
	0,                                   	/* NALNUMU      */
	0,                                   	/* NALNUMA      */
a313 2
	0,                                   	/* SPACEU       */
	0,                                   	/* SPACEA       */
a315 2
	0,                                   	/* NSPACEU      */
	0,                                   	/* NSPACEA      */
a317 1
	0,                                   	/* DIGITA       */
a319 1
	0,                                   	/* NDIGITA      */
a325 4
	0,                                   	/* EXACTFU      */
	0,                                   	/* EXACTFU_SS   */
	0,                                   	/* EXACTFU_TRICKYFOLD */
	0,                                   	/* EXACTFA      */
a339 7
	EXTRA_SIZE(struct regnode_1),        	/* REFFU        */
	EXTRA_SIZE(struct regnode_1),        	/* REFFA        */
	EXTRA_SIZE(struct regnode_1),        	/* NREF         */
	EXTRA_SIZE(struct regnode_1),        	/* NREFF        */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFL       */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFU       */
	EXTRA_SIZE(struct regnode_1),        	/* NREFFA       */
d357 3
d366 1
a366 1
	EXTRA_SIZE(struct regnode_1),        	/* VERB         */
d378 1
a396 2
	0,	/* BOUNDU       */
	0,	/* BOUNDA       */
a398 2
	0,	/* NBOUNDU      */
	0,	/* NBOUNDA      */
a403 1
	0,	/* ANYOFV       */
a405 2
	0,	/* ALNUMU       */
	0,	/* ALNUMA       */
a407 2
	0,	/* NALNUMU      */
	0,	/* NALNUMA      */
a409 2
	0,	/* SPACEU       */
	0,	/* SPACEA       */
a411 2
	0,	/* NSPACEU      */
	0,	/* NSPACEA      */
a413 1
	0,	/* DIGITA       */
a415 1
	0,	/* NDIGITA      */
a421 4
	0,	/* EXACTFU      */
	0,	/* EXACTFU_SS   */
	0,	/* EXACTFU_TRICKYFOLD */
	0,	/* EXACTFA      */
a435 7
	0,	/* REFFU        */
	0,	/* REFFA        */
	0,	/* NREF         */
	0,	/* NREFF        */
	0,	/* NREFFL       */
	0,	/* NREFFU       */
	0,	/* NREFFA       */
d453 3
d474 1
d498 80
a577 102
	"BOUNDU",                	/* 0x0b */
	"BOUNDA",                	/* 0x0c */
	"NBOUND",                	/* 0x0d */
	"NBOUNDL",               	/* 0x0e */
	"NBOUNDU",               	/* 0x0f */
	"NBOUNDA",               	/* 0x10 */
	"GPOS",                  	/* 0x11 */
	"REG_ANY",               	/* 0x12 */
	"SANY",                  	/* 0x13 */
	"CANY",                  	/* 0x14 */
	"ANYOF",                 	/* 0x15 */
	"ANYOFV",                	/* 0x16 */
	"ALNUM",                 	/* 0x17 */
	"ALNUML",                	/* 0x18 */
	"ALNUMU",                	/* 0x19 */
	"ALNUMA",                	/* 0x1a */
	"NALNUM",                	/* 0x1b */
	"NALNUML",               	/* 0x1c */
	"NALNUMU",               	/* 0x1d */
	"NALNUMA",               	/* 0x1e */
	"SPACE",                 	/* 0x1f */
	"SPACEL",                	/* 0x20 */
	"SPACEU",                	/* 0x21 */
	"SPACEA",                	/* 0x22 */
	"NSPACE",                	/* 0x23 */
	"NSPACEL",               	/* 0x24 */
	"NSPACEU",               	/* 0x25 */
	"NSPACEA",               	/* 0x26 */
	"DIGIT",                 	/* 0x27 */
	"DIGITL",                	/* 0x28 */
	"DIGITA",                	/* 0x29 */
	"NDIGIT",                	/* 0x2a */
	"NDIGITL",               	/* 0x2b */
	"NDIGITA",               	/* 0x2c */
	"CLUMP",                 	/* 0x2d */
	"BRANCH",                	/* 0x2e */
	"BACK",                  	/* 0x2f */
	"EXACT",                 	/* 0x30 */
	"EXACTF",                	/* 0x31 */
	"EXACTFL",               	/* 0x32 */
	"EXACTFU",               	/* 0x33 */
	"EXACTFU_SS",            	/* 0x34 */
	"EXACTFU_TRICKYFOLD",    	/* 0x35 */
	"EXACTFA",               	/* 0x36 */
	"NOTHING",               	/* 0x37 */
	"TAIL",                  	/* 0x38 */
	"STAR",                  	/* 0x39 */
	"PLUS",                  	/* 0x3a */
	"CURLY",                 	/* 0x3b */
	"CURLYN",                	/* 0x3c */
	"CURLYM",                	/* 0x3d */
	"CURLYX",                	/* 0x3e */
	"WHILEM",                	/* 0x3f */
	"OPEN",                  	/* 0x40 */
	"CLOSE",                 	/* 0x41 */
	"REF",                   	/* 0x42 */
	"REFF",                  	/* 0x43 */
	"REFFL",                 	/* 0x44 */
	"REFFU",                 	/* 0x45 */
	"REFFA",                 	/* 0x46 */
	"NREF",                  	/* 0x47 */
	"NREFF",                 	/* 0x48 */
	"NREFFL",                	/* 0x49 */
	"NREFFU",                	/* 0x4a */
	"NREFFA",                	/* 0x4b */
	"IFMATCH",               	/* 0x4c */
	"UNLESSM",               	/* 0x4d */
	"SUSPEND",               	/* 0x4e */
	"IFTHEN",                	/* 0x4f */
	"GROUPP",                	/* 0x50 */
	"LONGJMP",               	/* 0x51 */
	"BRANCHJ",               	/* 0x52 */
	"EVAL",                  	/* 0x53 */
	"MINMOD",                	/* 0x54 */
	"LOGICAL",               	/* 0x55 */
	"RENUM",                 	/* 0x56 */
	"TRIE",                  	/* 0x57 */
	"TRIEC",                 	/* 0x58 */
	"AHOCORASICK",           	/* 0x59 */
	"AHOCORASICKC",          	/* 0x5a */
	"GOSUB",                 	/* 0x5b */
	"GOSTART",               	/* 0x5c */
	"NGROUPP",               	/* 0x5d */
	"INSUBP",                	/* 0x5e */
	"DEFINEP",               	/* 0x5f */
	"ENDLIKE",               	/* 0x60 */
	"OPFAIL",                	/* 0x61 */
	"ACCEPT",                	/* 0x62 */
	"VERB",                  	/* 0x63 */
	"PRUNE",                 	/* 0x64 */
	"MARKPOINT",             	/* 0x65 */
	"SKIP",                  	/* 0x66 */
	"COMMIT",                	/* 0x67 */
	"CUTGROUP",              	/* 0x68 */
	"KEEPS",                 	/* 0x69 */
	"LNBREAK",               	/* 0x6a */
	"VERTWS",                	/* 0x6b */
	"NVERTWS",               	/* 0x6c */
	"HORIZWS",               	/* 0x6d */
	"NHORIZWS",              	/* 0x6e */
	"OPTIMIZED",             	/* 0x6f */
	"PSEUDO",                	/* 0x70 */
d628 1
a628 1
	/* Bits in extflags defined: 11111111111111111111111011111111 */
d634 15
a648 15
	"CHARSET",          /* 0x000000e0 */
	"CHARSET",          /* 0x000000e0 */
	"CHARSET",          /* 0x000000e0 */
	"UNUSED_BIT_8",     /* 0x00000100 */
	"ANCH_BOL",         /* 0x00000200 */
	"ANCH_MBOL",        /* 0x00000400 */
	"ANCH_SBOL",        /* 0x00000800 */
	"ANCH_GPOS",        /* 0x00001000 */
	"GPOS_SEEN",        /* 0x00002000 */
	"GPOS_FLOAT",       /* 0x00004000 */
	"LOOKBEHIND_SEEN",  /* 0x00008000 */
	"EVAL_SEEN",        /* 0x00010000 */
	"CANY_SEEN",        /* 0x00020000 */
	"NOSCAN",           /* 0x00040000 */
	"CHECK_ALL",        /* 0x00080000 */
a660 46
};
#endif /* DOINIT */

/* The following have no fixed length. U8 so we can do strchr() on it. */
#define REGNODE_VARIES(node) (PL_varies_bitmask[(node) >> 3] & (1 << ((node) & 7)))

#ifndef DOINIT
EXTCONST U8 PL_varies[] __attribute__deprecated__;
#else
EXTCONST U8 PL_varies[] __attribute__deprecated__ = {
    ANYOFV, CLUMP, BRANCH, BACK, STAR, PLUS, CURLY, CURLYN, CURLYM, CURLYX,
    WHILEM, REF, REFF, REFFL, REFFU, REFFA, NREF, NREFF, NREFFL, NREFFU,
    NREFFA, SUSPEND, IFTHEN, BRANCHJ,
    0
};
#endif /* DOINIT */

#ifndef DOINIT
EXTCONST U8 PL_varies_bitmask[];
#else
EXTCONST U8 PL_varies_bitmask[] = {
    0x00, 0x00, 0x40, 0x00, 0x00, 0xE0, 0x00, 0xFE, 0xFC, 0xCF, 0x04, 0x00, 0x00, 0x00, 0x00
};
#endif /* DOINIT */

/* The following always have a length of 1. U8 we can do strchr() on it. */
/* (Note that length 1 means "one character" under UTF8, not "one octet".) */
#define REGNODE_SIMPLE(node) (PL_simple_bitmask[(node) >> 3] & (1 << ((node) & 7)))

#ifndef DOINIT
EXTCONST U8 PL_simple[] __attribute__deprecated__;
#else
EXTCONST U8 PL_simple[] __attribute__deprecated__ = {
    REG_ANY, SANY, CANY, ANYOF, ALNUM, ALNUML, ALNUMU, ALNUMA, NALNUM,
    NALNUML, NALNUMU, NALNUMA, SPACE, SPACEL, SPACEU, SPACEA, NSPACE,
    NSPACEL, NSPACEU, NSPACEA, DIGIT, DIGITL, DIGITA, NDIGIT, NDIGITL,
    NDIGITA, VERTWS, NVERTWS, HORIZWS, NHORIZWS,
    0
};
#endif /* DOINIT */

#ifndef DOINIT
EXTCONST U8 PL_simple_bitmask[];
#else
EXTCONST U8 PL_simple_bitmask[] = {
    0x00, 0x00, 0xBC, 0xFF, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x00
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d9 2
a10 2
#define REGNODE_MAX           	95
#define REGMATCH_STATE_MAX    	135
d34 91
a124 74
#define	ANYOF_WARN_SUPER      	22	/* 0x16 Match character in (or not in) this class, warn (if enabled) upon matching a char above Unicode max; */
#define	ANYOF_SYNTHETIC       	23	/* 0x17 Synthetic start class */
#define	POSIXD                	24	/* 0x18 Some [[:class:]] under /d; the FLAGS field gives which one */
#define	POSIXL                	25	/* 0x19 Some [[:class:]] under /l; the FLAGS field gives which one */
#define	POSIXU                	26	/* 0x1a Some [[:class:]] under /u; the FLAGS field gives which one */
#define	POSIXA                	27	/* 0x1b Some [[:class:]] under /a; the FLAGS field gives which one */
#define	NPOSIXD               	28	/* 0x1c complement of POSIXD, [[:^class:]] */
#define	NPOSIXL               	29	/* 0x1d complement of POSIXL, [[:^class:]] */
#define	NPOSIXU               	30	/* 0x1e complement of POSIXU, [[:^class:]] */
#define	NPOSIXA               	31	/* 0x1f complement of POSIXA, [[:^class:]] */
#define	CLUMP                 	32	/* 0x20 Match any extended grapheme cluster sequence */
#define	BRANCH                	33	/* 0x21 Match this alternative, or the next... */
#define	BACK                  	34	/* 0x22 Match "", "next" ptr points backward. */
#define	EXACT                 	35	/* 0x23 Match this string (preceded by length). */
#define	EXACTF                	36	/* 0x24 Match this non-UTF-8 string (not guaranteed to be folded) using /id rules (w/len). */
#define	EXACTFL               	37	/* 0x25 Match this string (not guaranteed to be folded) using /il rules (w/len). */
#define	EXACTFU               	38	/* 0x26 Match this string (folded iff in UTF-8, length in folding doesn't change if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFA               	39	/* 0x27 Match this string (not guaranteed to be folded) using /iaa rules (w/len). */
#define	EXACTFU_SS            	40	/* 0x28 Match this string (folded iff in UTF-8, length in folding may change even if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFU_TRICKYFOLD    	41	/* 0x29 Match this folded UTF-8 string using /iu rules */
#define	NOTHING               	42	/* 0x2a Match empty string. */
#define	TAIL                  	43	/* 0x2b Match empty string. Can jump here from outside. */
#define	STAR                  	44	/* 0x2c Match this (simple) thing 0 or more times. */
#define	PLUS                  	45	/* 0x2d Match this (simple) thing 1 or more times. */
#define	CURLY                 	46	/* 0x2e Match this simple thing {n,m} times. */
#define	CURLYN                	47	/* 0x2f Capture next-after-this simple thing */
#define	CURLYM                	48	/* 0x30 Capture this medium-complex thing {n,m} times. */
#define	CURLYX                	49	/* 0x31 Match this complex thing {n,m} times. */
#define	WHILEM                	50	/* 0x32 Do curly processing and see if rest matches. */
#define	OPEN                  	51	/* 0x33 Mark this point in input as start of #n. */
#define	CLOSE                 	52	/* 0x34 Analogous to OPEN. */
#define	REF                   	53	/* 0x35 Match some already matched string */
#define	REFF                  	54	/* 0x36 Match already matched string, folded using native charset semantics for non-utf8 */
#define	REFFL                 	55	/* 0x37 Match already matched string, folded in loc. */
#define	REFFU                 	56	/* 0x38 Match already matched string, folded using unicode semantics for non-utf8 */
#define	REFFA                 	57	/* 0x39 Match already matched string, folded using unicode semantics for non-utf8, no mixing ASCII, non-ASCII */
#define	NREF                  	58	/* 0x3a Match some already matched string */
#define	NREFF                 	59	/* 0x3b Match already matched string, folded using native charset semantics for non-utf8 */
#define	NREFFL                	60	/* 0x3c Match already matched string, folded in loc. */
#define	NREFFU                	61	/* 0x3d Match already matched string, folded using unicode semantics for non-utf8 */
#define	NREFFA                	62	/* 0x3e Match already matched string, folded using unicode semantics for non-utf8, no mixing ASCII, non-ASCII */
#define	IFMATCH               	63	/* 0x3f Succeeds if the following matches. */
#define	UNLESSM               	64	/* 0x40 Fails if the following matches. */
#define	SUSPEND               	65	/* 0x41 "Independent" sub-RE. */
#define	IFTHEN                	66	/* 0x42 Switch, should be preceded by switcher. */
#define	GROUPP                	67	/* 0x43 Whether the group matched. */
#define	LONGJMP               	68	/* 0x44 Jump far away. */
#define	BRANCHJ               	69	/* 0x45 BRANCH with long offset. */
#define	EVAL                  	70	/* 0x46 Execute some Perl code. */
#define	MINMOD                	71	/* 0x47 Next operator is not greedy. */
#define	LOGICAL               	72	/* 0x48 Next opcode should set the flag only. */
#define	RENUM                 	73	/* 0x49 Group with independently numbered parens. */
#define	TRIE                  	74	/* 0x4a Match many EXACT(F[ALU]?)? at once. flags==type */
#define	TRIEC                 	75	/* 0x4b Same as TRIE, but with embedded charclass data */
#define	AHOCORASICK           	76	/* 0x4c Aho Corasick stclass. flags==type */
#define	AHOCORASICKC          	77	/* 0x4d Same as AHOCORASICK, but with embedded charclass data */
#define	GOSUB                 	78	/* 0x4e recurse to paren arg1 at (signed) ofs arg2 */
#define	GOSTART               	79	/* 0x4f recurse to start of pattern */
#define	NGROUPP               	80	/* 0x50 Whether the group matched. */
#define	INSUBP                	81	/* 0x51 Whether we are in a specific recurse. */
#define	DEFINEP               	82	/* 0x52 Never execute directly. */
#define	ENDLIKE               	83	/* 0x53 Used only for the type field of verbs */
#define	OPFAIL                	84	/* 0x54 Same as (?!) */
#define	ACCEPT                	85	/* 0x55 Accepts the current matched string. */
#define	VERB                  	86	/* 0x56 Used only for the type field of verbs */
#define	PRUNE                 	87	/* 0x57 Pattern fails at this startpoint if no-backtracking through this */
#define	MARKPOINT             	88	/* 0x58 Push the current location for rollback by cut. */
#define	SKIP                  	89	/* 0x59 On failure skip forward (to the mark) before retrying */
#define	COMMIT                	90	/* 0x5a Pattern fails outright if backtracking through this */
#define	CUTGROUP              	91	/* 0x5b On failure go to the next alternation in the group */
#define	KEEPS                 	92	/* 0x5c $& begins here. */
#define	LNBREAK               	93	/* 0x5d generic newline pattern */
#define	OPTIMIZED             	94	/* 0x5e Placeholder for dump. */
#define	PSEUDO                	95	/* 0x5f Pseudo opcode for internal use. */
d195 23
a217 10
	ANYOF,    	/* ANYOF_WARN_SUPER       */
	ANYOF,    	/* ANYOF_SYNTHETIC        */
	POSIXD,   	/* POSIXD                 */
	POSIXD,   	/* POSIXL                 */
	POSIXD,   	/* POSIXU                 */
	POSIXD,   	/* POSIXA                 */
	NPOSIXD,  	/* NPOSIXD                */
	NPOSIXD,  	/* NPOSIXL                */
	NPOSIXD,  	/* NPOSIXU                */
	NPOSIXD,  	/* NPOSIXA                */
a224 1
	EXACT,    	/* EXACTFA                */
d227 1
d280 4
d356 23
a378 10
	0,                                   	/* ANYOF_WARN_SUPER */
	0,                                   	/* ANYOF_SYNTHETIC */
	0,                                   	/* POSIXD       */
	0,                                   	/* POSIXL       */
	0,                                   	/* POSIXU       */
	0,                                   	/* POSIXA       */
	0,                                   	/* NPOSIXD      */
	0,                                   	/* NPOSIXL      */
	0,                                   	/* NPOSIXU      */
	0,                                   	/* NPOSIXA      */
a385 1
	0,                                   	/* EXACTFA      */
d388 1
d441 4
d474 23
a496 10
	0,	/* ANYOF_WARN_SUPER */
	0,	/* ANYOF_SYNTHETIC */
	0,	/* POSIXD       */
	0,	/* POSIXL       */
	0,	/* POSIXU       */
	0,	/* POSIXA       */
	0,	/* NPOSIXD      */
	0,	/* NPOSIXL      */
	0,	/* NPOSIXU      */
	0,	/* NPOSIXA      */
a503 1
	0,	/* EXACTFA      */
d506 1
d559 4
d597 91
a687 74
	"ANYOF_WARN_SUPER",      	/* 0x16 */
	"ANYOF_SYNTHETIC",       	/* 0x17 */
	"POSIXD",                	/* 0x18 */
	"POSIXL",                	/* 0x19 */
	"POSIXU",                	/* 0x1a */
	"POSIXA",                	/* 0x1b */
	"NPOSIXD",               	/* 0x1c */
	"NPOSIXL",               	/* 0x1d */
	"NPOSIXU",               	/* 0x1e */
	"NPOSIXA",               	/* 0x1f */
	"CLUMP",                 	/* 0x20 */
	"BRANCH",                	/* 0x21 */
	"BACK",                  	/* 0x22 */
	"EXACT",                 	/* 0x23 */
	"EXACTF",                	/* 0x24 */
	"EXACTFL",               	/* 0x25 */
	"EXACTFU",               	/* 0x26 */
	"EXACTFA",               	/* 0x27 */
	"EXACTFU_SS",            	/* 0x28 */
	"EXACTFU_TRICKYFOLD",    	/* 0x29 */
	"NOTHING",               	/* 0x2a */
	"TAIL",                  	/* 0x2b */
	"STAR",                  	/* 0x2c */
	"PLUS",                  	/* 0x2d */
	"CURLY",                 	/* 0x2e */
	"CURLYN",                	/* 0x2f */
	"CURLYM",                	/* 0x30 */
	"CURLYX",                	/* 0x31 */
	"WHILEM",                	/* 0x32 */
	"OPEN",                  	/* 0x33 */
	"CLOSE",                 	/* 0x34 */
	"REF",                   	/* 0x35 */
	"REFF",                  	/* 0x36 */
	"REFFL",                 	/* 0x37 */
	"REFFU",                 	/* 0x38 */
	"REFFA",                 	/* 0x39 */
	"NREF",                  	/* 0x3a */
	"NREFF",                 	/* 0x3b */
	"NREFFL",                	/* 0x3c */
	"NREFFU",                	/* 0x3d */
	"NREFFA",                	/* 0x3e */
	"IFMATCH",               	/* 0x3f */
	"UNLESSM",               	/* 0x40 */
	"SUSPEND",               	/* 0x41 */
	"IFTHEN",                	/* 0x42 */
	"GROUPP",                	/* 0x43 */
	"LONGJMP",               	/* 0x44 */
	"BRANCHJ",               	/* 0x45 */
	"EVAL",                  	/* 0x46 */
	"MINMOD",                	/* 0x47 */
	"LOGICAL",               	/* 0x48 */
	"RENUM",                 	/* 0x49 */
	"TRIE",                  	/* 0x4a */
	"TRIEC",                 	/* 0x4b */
	"AHOCORASICK",           	/* 0x4c */
	"AHOCORASICKC",          	/* 0x4d */
	"GOSUB",                 	/* 0x4e */
	"GOSTART",               	/* 0x4f */
	"NGROUPP",               	/* 0x50 */
	"INSUBP",                	/* 0x51 */
	"DEFINEP",               	/* 0x52 */
	"ENDLIKE",               	/* 0x53 */
	"OPFAIL",                	/* 0x54 */
	"ACCEPT",                	/* 0x55 */
	"VERB",                  	/* 0x56 */
	"PRUNE",                 	/* 0x57 */
	"MARKPOINT",             	/* 0x58 */
	"SKIP",                  	/* 0x59 */
	"COMMIT",                	/* 0x5a */
	"CUTGROUP",              	/* 0x5b */
	"KEEPS",                 	/* 0x5c */
	"LNBREAK",               	/* 0x5d */
	"OPTIMIZED",             	/* 0x5e */
	"PSEUDO",                	/* 0x5f */
d738 1
a738 1
	/* Bits in extflags defined: 11111110111111111111111111111111 */
d744 4
a747 4
	"CHARSET0",         /* 0x00000020 : "CHARSET" - 0x000000e0 */
	"CHARSET1",         /* 0x00000040 : "CHARSET" - 0x000000e0 */
	"CHARSET2",         /* 0x00000080 : "CHARSET" - 0x000000e0 */
	"SPLIT",            /* 0x00000100 */
d754 1
a754 1
	"NO_INPLACE_SUBST", /* 0x00008000 */
d763 1
a763 1
	"UNUSED_BIT_24",    /* 0x01000000 */
d781 3
a783 3
    CLUMP, BRANCH, BACK, STAR, PLUS, CURLY, CURLYN, CURLYM, CURLYX, WHILEM,
    REF, REFF, REFFL, REFFU, REFFA, NREF, NREFF, NREFFL, NREFFU, NREFFA,
    SUSPEND, IFTHEN, BRANCHJ,
d792 1
a792 1
    0x00, 0x00, 0x00, 0x00, 0x07, 0xF0, 0xE7, 0x7F, 0x26, 0x00, 0x00, 0x00
d804 4
a807 2
    REG_ANY, SANY, CANY, ANYOF, ANYOF_WARN_SUPER, ANYOF_SYNTHETIC, POSIXD,
    POSIXL, POSIXU, POSIXA, NPOSIXD, NPOSIXL, NPOSIXU, NPOSIXA,
d816 1
a816 1
    0x00, 0x00, 0xFC, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
@


1.1.1.10
log
@Import perl-5.20.1
@
text
@d9 2
a10 2
#define REGNODE_MAX           	93
#define REGMATCH_STATE_MAX    	133
d21 1
a21 1
#define	BOUND                 	9	/* 0x09 Match "" at any word boundary using native charset rules for non-utf8 */
d23 3
a25 3
#define	BOUNDU                	11	/* 0x0b Match "" at any word boundary using Unicode rules */
#define	BOUNDA                	12	/* 0x0c Match "" at any word boundary using ASCII rules */
#define	NBOUND                	13	/* 0x0d Match "" at any word non-boundary using native charset rules for non-utf8 */
d27 2
a28 2
#define	NBOUNDU               	15	/* 0x0f Match "" at any word non-boundary using Unicode rules */
#define	NBOUNDA               	16	/* 0x10 Match "" at any word non-boundary using ASCII rules */
d34 74
a107 72
#define	POSIXD                	22	/* 0x16 Some [[:class:]] under /d; the FLAGS field gives which one */
#define	POSIXL                	23	/* 0x17 Some [[:class:]] under /l; the FLAGS field gives which one */
#define	POSIXU                	24	/* 0x18 Some [[:class:]] under /u; the FLAGS field gives which one */
#define	POSIXA                	25	/* 0x19 Some [[:class:]] under /a; the FLAGS field gives which one */
#define	NPOSIXD               	26	/* 0x1a complement of POSIXD, [[:^class:]] */
#define	NPOSIXL               	27	/* 0x1b complement of POSIXL, [[:^class:]] */
#define	NPOSIXU               	28	/* 0x1c complement of POSIXU, [[:^class:]] */
#define	NPOSIXA               	29	/* 0x1d complement of POSIXA, [[:^class:]] */
#define	CLUMP                 	30	/* 0x1e Match any extended grapheme cluster sequence */
#define	BRANCH                	31	/* 0x1f Match this alternative, or the next... */
#define	BACK                  	32	/* 0x20 Match "", "next" ptr points backward. */
#define	EXACT                 	33	/* 0x21 Match this string (preceded by length). */
#define	EXACTF                	34	/* 0x22 Match this non-UTF-8 string (not guaranteed to be folded) using /id rules (w/len). */
#define	EXACTFL               	35	/* 0x23 Match this string (not guaranteed to be folded) using /il rules (w/len). */
#define	EXACTFU               	36	/* 0x24 Match this string (folded iff in UTF-8, length in folding doesn't change if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFA               	37	/* 0x25 Match this string (not guaranteed to be folded) using /iaa rules (w/len). */
#define	EXACTFU_SS            	38	/* 0x26 Match this string (folded iff in UTF-8, length in folding may change even if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFA_NO_TRIE       	39	/* 0x27 Match this string (which is not trie-able; not guaranteed to be folded) using /iaa rules (w/len). */
#define	NOTHING               	40	/* 0x28 Match empty string. */
#define	TAIL                  	41	/* 0x29 Match empty string. Can jump here from outside. */
#define	STAR                  	42	/* 0x2a Match this (simple) thing 0 or more times. */
#define	PLUS                  	43	/* 0x2b Match this (simple) thing 1 or more times. */
#define	CURLY                 	44	/* 0x2c Match this simple thing {n,m} times. */
#define	CURLYN                	45	/* 0x2d Capture next-after-this simple thing */
#define	CURLYM                	46	/* 0x2e Capture this medium-complex thing {n,m} times. */
#define	CURLYX                	47	/* 0x2f Match this complex thing {n,m} times. */
#define	WHILEM                	48	/* 0x30 Do curly processing and see if rest matches. */
#define	OPEN                  	49	/* 0x31 Mark this point in input as start of #n. */
#define	CLOSE                 	50	/* 0x32 Analogous to OPEN. */
#define	REF                   	51	/* 0x33 Match some already matched string */
#define	REFF                  	52	/* 0x34 Match already matched string, folded using native charset rules for non-utf8 */
#define	REFFL                 	53	/* 0x35 Match already matched string, folded in loc. */
#define	REFFU                 	54	/* 0x36 Match already matched string, folded using unicode rules for non-utf8 */
#define	REFFA                 	55	/* 0x37 Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII */
#define	NREF                  	56	/* 0x38 Match some already matched string */
#define	NREFF                 	57	/* 0x39 Match already matched string, folded using native charset rules for non-utf8 */
#define	NREFFL                	58	/* 0x3a Match already matched string, folded in loc. */
#define	NREFFU                	59	/* 0x3b Match already matched string, folded using unicode rules for non-utf8 */
#define	NREFFA                	60	/* 0x3c Match already matched string, folded using unicode rules for non-utf8, no mixing ASCII, non-ASCII */
#define	IFMATCH               	61	/* 0x3d Succeeds if the following matches. */
#define	UNLESSM               	62	/* 0x3e Fails if the following matches. */
#define	SUSPEND               	63	/* 0x3f "Independent" sub-RE. */
#define	IFTHEN                	64	/* 0x40 Switch, should be preceded by switcher. */
#define	GROUPP                	65	/* 0x41 Whether the group matched. */
#define	LONGJMP               	66	/* 0x42 Jump far away. */
#define	BRANCHJ               	67	/* 0x43 BRANCH with long offset. */
#define	EVAL                  	68	/* 0x44 Execute some Perl code. */
#define	MINMOD                	69	/* 0x45 Next operator is not greedy. */
#define	LOGICAL               	70	/* 0x46 Next opcode should set the flag only. */
#define	RENUM                 	71	/* 0x47 Group with independently numbered parens. */
#define	TRIE                  	72	/* 0x48 Match many EXACT(F[ALU]?)? at once. flags==type */
#define	TRIEC                 	73	/* 0x49 Same as TRIE, but with embedded charclass data */
#define	AHOCORASICK           	74	/* 0x4a Aho Corasick stclass. flags==type */
#define	AHOCORASICKC          	75	/* 0x4b Same as AHOCORASICK, but with embedded charclass data */
#define	GOSUB                 	76	/* 0x4c recurse to paren arg1 at (signed) ofs arg2 */
#define	GOSTART               	77	/* 0x4d recurse to start of pattern */
#define	NGROUPP               	78	/* 0x4e Whether the group matched. */
#define	INSUBP                	79	/* 0x4f Whether we are in a specific recurse. */
#define	DEFINEP               	80	/* 0x50 Never execute directly. */
#define	ENDLIKE               	81	/* 0x51 Used only for the type field of verbs */
#define	OPFAIL                	82	/* 0x52 Same as (?!) */
#define	ACCEPT                	83	/* 0x53 Accepts the current matched string. */
#define	VERB                  	84	/* 0x54 Used only for the type field of verbs */
#define	PRUNE                 	85	/* 0x55 Pattern fails at this startpoint if no-backtracking through this */
#define	MARKPOINT             	86	/* 0x56 Push the current location for rollback by cut. */
#define	SKIP                  	87	/* 0x57 On failure skip forward (to the mark) before retrying */
#define	COMMIT                	88	/* 0x58 Pattern fails outright if backtracking through this */
#define	CUTGROUP              	89	/* 0x59 On failure go to the next alternation in the group */
#define	KEEPS                 	90	/* 0x5a $& begins here. */
#define	LNBREAK               	91	/* 0x5b generic newline pattern */
#define	OPTIMIZED             	92	/* 0x5c Placeholder for dump. */
#define	PSEUDO                	93	/* 0x5d Pseudo opcode for internal use. */
d178 2
d197 1
a197 1
	EXACT,    	/* EXACTFA_NO_TRIE        */
d322 2
d341 1
a341 1
	0,                                   	/* EXACTFA_NO_TRIE */
d423 2
d442 1
a442 1
	0,	/* EXACTFA_NO_TRIE */
d529 74
a602 72
	"POSIXD",                	/* 0x16 */
	"POSIXL",                	/* 0x17 */
	"POSIXU",                	/* 0x18 */
	"POSIXA",                	/* 0x19 */
	"NPOSIXD",               	/* 0x1a */
	"NPOSIXL",               	/* 0x1b */
	"NPOSIXU",               	/* 0x1c */
	"NPOSIXA",               	/* 0x1d */
	"CLUMP",                 	/* 0x1e */
	"BRANCH",                	/* 0x1f */
	"BACK",                  	/* 0x20 */
	"EXACT",                 	/* 0x21 */
	"EXACTF",                	/* 0x22 */
	"EXACTFL",               	/* 0x23 */
	"EXACTFU",               	/* 0x24 */
	"EXACTFA",               	/* 0x25 */
	"EXACTFU_SS",            	/* 0x26 */
	"EXACTFA_NO_TRIE",       	/* 0x27 */
	"NOTHING",               	/* 0x28 */
	"TAIL",                  	/* 0x29 */
	"STAR",                  	/* 0x2a */
	"PLUS",                  	/* 0x2b */
	"CURLY",                 	/* 0x2c */
	"CURLYN",                	/* 0x2d */
	"CURLYM",                	/* 0x2e */
	"CURLYX",                	/* 0x2f */
	"WHILEM",                	/* 0x30 */
	"OPEN",                  	/* 0x31 */
	"CLOSE",                 	/* 0x32 */
	"REF",                   	/* 0x33 */
	"REFF",                  	/* 0x34 */
	"REFFL",                 	/* 0x35 */
	"REFFU",                 	/* 0x36 */
	"REFFA",                 	/* 0x37 */
	"NREF",                  	/* 0x38 */
	"NREFF",                 	/* 0x39 */
	"NREFFL",                	/* 0x3a */
	"NREFFU",                	/* 0x3b */
	"NREFFA",                	/* 0x3c */
	"IFMATCH",               	/* 0x3d */
	"UNLESSM",               	/* 0x3e */
	"SUSPEND",               	/* 0x3f */
	"IFTHEN",                	/* 0x40 */
	"GROUPP",                	/* 0x41 */
	"LONGJMP",               	/* 0x42 */
	"BRANCHJ",               	/* 0x43 */
	"EVAL",                  	/* 0x44 */
	"MINMOD",                	/* 0x45 */
	"LOGICAL",               	/* 0x46 */
	"RENUM",                 	/* 0x47 */
	"TRIE",                  	/* 0x48 */
	"TRIEC",                 	/* 0x49 */
	"AHOCORASICK",           	/* 0x4a */
	"AHOCORASICKC",          	/* 0x4b */
	"GOSUB",                 	/* 0x4c */
	"GOSTART",               	/* 0x4d */
	"NGROUPP",               	/* 0x4e */
	"INSUBP",                	/* 0x4f */
	"DEFINEP",               	/* 0x50 */
	"ENDLIKE",               	/* 0x51 */
	"OPFAIL",                	/* 0x52 */
	"ACCEPT",                	/* 0x53 */
	"VERB",                  	/* 0x54 */
	"PRUNE",                 	/* 0x55 */
	"MARKPOINT",             	/* 0x56 */
	"SKIP",                  	/* 0x57 */
	"COMMIT",                	/* 0x58 */
	"CUTGROUP",              	/* 0x59 */
	"KEEPS",                 	/* 0x5a */
	"LNBREAK",               	/* 0x5b */
	"OPTIMIZED",             	/* 0x5c */
	"PSEUDO",                	/* 0x5d */
d663 6
a668 6
	"IS_ANCHORED",      /* 0x00000200 */
	"UNUSED1",          /* 0x00000400 */
	"UNUSED2",          /* 0x00000800 */
	"UNUSED3",          /* 0x00001000 */
	"UNUSED4",          /* 0x00002000 */
	"UNUSED5",          /* 0x00004000 */
d671 2
a672 2
	"UNUSED8",          /* 0x00020000 */
	"UNBOUNDED_QUANTIFIER_SEEN",/* 0x00040000 */
a688 31
#ifdef DEBUGGING
#  define REG_EXTFLAGS_NAME_SIZE 32
#endif

/* PL_reg_intflags_name[] - Opcode/state names in string form, for debugging */

#ifndef DOINIT
EXTCONST char * PL_reg_intflags_name[];
#else
EXTCONST char * const PL_reg_intflags_name[] = {
	"SKIP",                       /* 0x00000001 - PREGf_SKIP */
	"IMPLICIT",                   /* 0x00000002 - PREGf_IMPLICIT -  Converted .* to ^.*  */
	"NAUGHTY",                    /* 0x00000004 - PREGf_NAUGHTY -  how exponential is this pattern?  */
	"VERBARG_SEEN",               /* 0x00000008 - PREGf_VERBARG_SEEN */
	"CUTGROUP_SEEN",              /* 0x00000010 - PREGf_CUTGROUP_SEEN */
	"USE_RE_EVAL",                /* 0x00000020 - PREGf_USE_RE_EVAL -  compiled with "use re 'eval'"  */
	"NOSCAN",                     /* 0x00000040 - PREGf_NOSCAN */
	"CANY_SEEN",                  /* 0x00000080 - PREGf_CANY_SEEN */
	"GPOS_SEEN",                  /* 0x00000100 - PREGf_GPOS_SEEN */
	"GPOS_FLOAT",                 /* 0x00000200 - PREGf_GPOS_FLOAT */
	"ANCH_BOL",                   /* 0x00000400 - PREGf_ANCH_BOL */
	"ANCH_MBOL",                  /* 0x00000800 - PREGf_ANCH_MBOL */
	"ANCH_SBOL",                  /* 0x00001000 - PREGf_ANCH_SBOL */
	"ANCH_GPOS",                  /* 0x00002000 - PREGf_ANCH_GPOS */
};
#endif /* DOINIT */

#ifdef DEBUGGING
#  define REG_INTFLAGS_NAME_SIZE 14
#endif

d707 1
a707 1
    0x00, 0x00, 0x00, 0xC0, 0x01, 0xFC, 0xF9, 0x9F, 0x09, 0x00, 0x00, 0x00
d719 2
a720 2
    REG_ANY, SANY, CANY, ANYOF, POSIXD, POSIXL, POSIXU, POSIXA, NPOSIXD,
    NPOSIXL, NPOSIXU, NPOSIXA,
d729 1
a729 1
    0x00, 0x00, 0xFC, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
@


1.1.1.11
log
@Import perl-5.24.2
@
text
@d9 2
a10 2
#define REGNODE_MAX           	92
#define REGMATCH_STATE_MAX    	132
d14 37
a50 39
#define	SBOL                  	2	/* 0x02 Match "" at beginning of line: /^/, /\A/ */
#define	BOL                   	2	/* 0x02 type alias */
#define	MBOL                  	3	/* 0x03 Same, assuming multiline: /^/m */
#define	SEOL                  	4	/* 0x04 Match "" at end of line: /$/ */
#define	EOL                   	4	/* 0x04 type alias */
#define	MEOL                  	5	/* 0x05 Same, assuming multiline: /$/m */
#define	EOS                   	6	/* 0x06 Match "" at end of string: /\z/ */
#define	GPOS                  	7	/* 0x07 Matches where last m//g left off. */
#define	BOUND                 	8	/* 0x08 Like BOUNDA for non-utf8, otherwise match "" between any Unicode \w\W or \W\w */
#define	BOUNDL                	9	/* 0x09 Like BOUND/BOUNDU, but \w and \W are defined by current locale */
#define	BOUNDU                	10	/* 0x0a Match "" at any boundary of a given type using Unicode rules */
#define	BOUNDA                	11	/* 0x0b Match "" at any boundary between \w\W or \W\w, where \w is [_a-zA-Z0-9] */
#define	NBOUND                	12	/* 0x0c Like NBOUNDA for non-utf8, otherwise match "" between any Unicode \w\w or \W\W */
#define	NBOUNDL               	13	/* 0x0d Like NBOUND/NBOUNDU, but \w and \W are defined by current locale */
#define	NBOUNDU               	14	/* 0x0e Match "" at any non-boundary of a given type using using Unicode rules */
#define	NBOUNDA               	15	/* 0x0f Match "" betweeen any \w\w or \W\W, where \w is [_a-zA-Z0-9] */
#define	REG_ANY               	16	/* 0x10 Match any one character (except newline). */
#define	SANY                  	17	/* 0x11 Match any one character. */
#define	ANYOF                 	18	/* 0x12 Match character in (or not in) this class, single char match only */
#define	ANYOFD                	19	/* 0x13 Like ANYOF, but /d is in effect */
#define	ANYOFL                	20	/* 0x14 Like ANYOF, but /l is in effect */
#define	POSIXD                	21	/* 0x15 Some [[:class:]] under /d; the FLAGS field gives which one */
#define	POSIXL                	22	/* 0x16 Some [[:class:]] under /l; the FLAGS field gives which one */
#define	POSIXU                	23	/* 0x17 Some [[:class:]] under /u; the FLAGS field gives which one */
#define	POSIXA                	24	/* 0x18 Some [[:class:]] under /a; the FLAGS field gives which one */
#define	NPOSIXD               	25	/* 0x19 complement of POSIXD, [[:^class:]] */
#define	NPOSIXL               	26	/* 0x1a complement of POSIXL, [[:^class:]] */
#define	NPOSIXU               	27	/* 0x1b complement of POSIXU, [[:^class:]] */
#define	NPOSIXA               	28	/* 0x1c complement of POSIXA, [[:^class:]] */
#define	CLUMP                 	29	/* 0x1d Match any extended grapheme cluster sequence */
#define	BRANCH                	30	/* 0x1e Match this alternative, or the next... */
#define	EXACT                 	31	/* 0x1f Match this string (preceded by length). */
#define	EXACTL                	32	/* 0x20 Like EXACT, but /l is in effect (used so locale-related warnings can be checked for). */
#define	EXACTF                	33	/* 0x21 Match this non-UTF-8 string (not guaranteed to be folded) using /id rules (w/len). */
#define	EXACTFL               	34	/* 0x22 Match this string (not guaranteed to be folded) using /il rules (w/len). */
#define	EXACTFU               	35	/* 0x23 Match this string (folded iff in UTF-8, length in folding doesn't change if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFA               	36	/* 0x24 Match this string (not guaranteed to be folded) using /iaa rules (w/len). */
#define	EXACTFU_SS            	37	/* 0x25 Match this string (folded iff in UTF-8, length in folding may change even if not in UTF-8) using /iu rules (w/len). */
#define	EXACTFLU8             	38	/* 0x26 Rare cirucmstances: like EXACTFU, but is under /l, UTF-8, folded, and everything in it is above 255. */
d73 7
a79 7
#define	LONGJMP               	61	/* 0x3d Jump far away. */
#define	BRANCHJ               	62	/* 0x3e BRANCH with long offset. */
#define	IFMATCH               	63	/* 0x3f Succeeds if the following matches. */
#define	UNLESSM               	64	/* 0x40 Fails if the following matches. */
#define	SUSPEND               	65	/* 0x41 "Independent" sub-RE. */
#define	IFTHEN                	66	/* 0x42 Switch, should be preceded by switcher. */
#define	GROUPP                	67	/* 0x43 Whether the group matched. */
d89 17
a105 16
#define	NGROUPP               	77	/* 0x4d Whether the group matched. */
#define	INSUBP                	78	/* 0x4e Whether we are in a specific recurse. */
#define	DEFINEP               	79	/* 0x4f Never execute directly. */
#define	ENDLIKE               	80	/* 0x50 Used only for the type field of verbs */
#define	OPFAIL                	81	/* 0x51 Same as (?!), but with verb arg */
#define	ACCEPT                	82	/* 0x52 Accepts the current matched string, with verbar */
#define	VERB                  	83	/* 0x53 Used only for the type field of verbs */
#define	PRUNE                 	84	/* 0x54 Pattern fails at this startpoint if no-backtracking through this */
#define	MARKPOINT             	85	/* 0x55 Push the current location for rollback by cut. */
#define	SKIP                  	86	/* 0x56 On failure skip forward (to the mark) before retrying */
#define	COMMIT                	87	/* 0x57 Pattern fails outright if backtracking through this */
#define	CUTGROUP              	88	/* 0x58 On failure go to the next alternation in the group */
#define	KEEPS                 	89	/* 0x59 $& begins here. */
#define	LNBREAK               	90	/* 0x5a generic newline pattern */
#define	OPTIMIZED             	91	/* 0x5b Placeholder for dump. */
#define	PSEUDO                	92	/* 0x5c Pseudo opcode for internal use. */
d156 2
d159 3
a161 1
	BOL,      	/* MBOL                   */
a162 3
	EOL,      	/* MEOL                   */
	EOL,      	/* EOS                    */
	GPOS,     	/* GPOS                   */
d171 1
d174 1
a175 2
	ANYOF,    	/* ANYOFD                 */
	ANYOF,    	/* ANYOFL                 */
d186 1
a187 1
	EXACT,    	/* EXACTL                 */
a192 1
	EXACT,    	/* EXACTFLU8              */
a214 2
	LONGJMP,  	/* LONGJMP                */
	BRANCHJ,  	/* BRANCHJ                */
d220 2
d231 1
a291 2
#ifdef REG_COMP_C

d294 1
d298 2
d301 3
a303 1
	0,                                   	/* MBOL         */
a304 3
	0,                                   	/* MEOL         */
	0,                                   	/* EOS          */
	0,                                   	/* GPOS         */
d313 1
d316 2
a317 3
	EXTRA_SIZE(struct regnode_1),        	/* ANYOF        */
	EXTRA_SIZE(struct regnode_1),        	/* ANYOFD       */
	EXTRA_SIZE(struct regnode_1),        	/* ANYOFL       */
d328 1
a329 1
	0,                                   	/* EXACTL       */
a334 1
	0,                                   	/* EXACTFLU8    */
a356 2
	EXTRA_SIZE(struct regnode_1),        	/* LONGJMP      */
	EXTRA_SIZE(struct regnode_1),        	/* BRANCHJ      */
d362 3
a364 1
	EXTRA_SIZE(struct regnode_2L),       	/* EVAL         */
d373 1
d378 2
a379 2
	EXTRA_SIZE(struct regnode_1),        	/* OPFAIL       */
	EXTRA_SIZE(struct regnode_2L),       	/* ACCEPT       */
d397 2
d400 3
a402 1
	0,	/* MBOL         */
a403 3
	0,	/* MEOL         */
	0,	/* EOS          */
	0,	/* GPOS         */
d412 1
d415 1
a416 2
	0,	/* ANYOFD       */
	0,	/* ANYOFL       */
d427 1
a428 1
	0,	/* EXACTL       */
a433 1
	0,	/* EXACTFLU8    */
a455 2
	1,	/* LONGJMP      */
	1,	/* BRANCHJ      */
d461 2
d472 1
a492 1

d501 1
a501 1
	"SBOL",                  	/* 0x02 */
d503 35
a537 35
	"SEOL",                  	/* 0x04 */
	"MEOL",                  	/* 0x05 */
	"EOS",                   	/* 0x06 */
	"GPOS",                  	/* 0x07 */
	"BOUND",                 	/* 0x08 */
	"BOUNDL",                	/* 0x09 */
	"BOUNDU",                	/* 0x0a */
	"BOUNDA",                	/* 0x0b */
	"NBOUND",                	/* 0x0c */
	"NBOUNDL",               	/* 0x0d */
	"NBOUNDU",               	/* 0x0e */
	"NBOUNDA",               	/* 0x0f */
	"REG_ANY",               	/* 0x10 */
	"SANY",                  	/* 0x11 */
	"ANYOF",                 	/* 0x12 */
	"ANYOFD",                	/* 0x13 */
	"ANYOFL",                	/* 0x14 */
	"POSIXD",                	/* 0x15 */
	"POSIXL",                	/* 0x16 */
	"POSIXU",                	/* 0x17 */
	"POSIXA",                	/* 0x18 */
	"NPOSIXD",               	/* 0x19 */
	"NPOSIXL",               	/* 0x1a */
	"NPOSIXU",               	/* 0x1b */
	"NPOSIXA",               	/* 0x1c */
	"CLUMP",                 	/* 0x1d */
	"BRANCH",                	/* 0x1e */
	"EXACT",                 	/* 0x1f */
	"EXACTL",                	/* 0x20 */
	"EXACTF",                	/* 0x21 */
	"EXACTFL",               	/* 0x22 */
	"EXACTFU",               	/* 0x23 */
	"EXACTFA",               	/* 0x24 */
	"EXACTFU_SS",            	/* 0x25 */
	"EXACTFLU8",             	/* 0x26 */
d560 7
a566 7
	"LONGJMP",               	/* 0x3d */
	"BRANCHJ",               	/* 0x3e */
	"IFMATCH",               	/* 0x3f */
	"UNLESSM",               	/* 0x40 */
	"SUSPEND",               	/* 0x41 */
	"IFTHEN",                	/* 0x42 */
	"GROUPP",                	/* 0x43 */
d576 17
a592 16
	"NGROUPP",               	/* 0x4d */
	"INSUBP",                	/* 0x4e */
	"DEFINEP",               	/* 0x4f */
	"ENDLIKE",               	/* 0x50 */
	"OPFAIL",                	/* 0x51 */
	"ACCEPT",                	/* 0x52 */
	"VERB",                  	/* 0x53 */
	"PRUNE",                 	/* 0x54 */
	"MARKPOINT",             	/* 0x55 */
	"SKIP",                  	/* 0x56 */
	"COMMIT",                	/* 0x57 */
	"CUTGROUP",              	/* 0x58 */
	"KEEPS",                 	/* 0x59 */
	"LNBREAK",               	/* 0x5a */
	"OPTIMIZED",             	/* 0x5b */
	"PSEUDO",                	/* 0x5c */
d643 1
a643 1
	/* Bits in extflags defined: 11111111111111110000111111111111 */
d648 14
a661 14
	"EXTENDED_MORE",    /* 0x00000010 */
	"NOCAPTURE",        /* 0x00000020 */
	"KEEPCOPY",         /* 0x00000040 */
	"CHARSET0",         /* 0x00000080 : "CHARSET" - 0x00000380 */
	"CHARSET1",         /* 0x00000100 : "CHARSET" - 0x00000380 */
	"CHARSET2",         /* 0x00000200 : "CHARSET" - 0x00000380 */
	"STRICT",           /* 0x00000400 */
	"SPLIT",            /* 0x00000800 */
	"UNUSED_BIT_12",    /* 0x00001000 */
	"UNUSED_BIT_13",    /* 0x00002000 */
	"UNUSED_BIT_14",    /* 0x00004000 */
	"UNUSED_BIT_15",    /* 0x00008000 */
	"NO_INPLACE_SUBST", /* 0x00010000 */
	"EVAL_SEEN",        /* 0x00020000 */
d668 1
a668 1
	"IS_ANCHORED",      /* 0x01000000 */
d696 1
d699 4
a702 4
	"ANCH_MBOL",                  /* 0x00000400 - PREGf_ANCH_MBOL */
	"ANCH_SBOL",                  /* 0x00000800 - PREGf_ANCH_SBOL */
	"ANCH_GPOS",                  /* 0x00001000 - PREGf_ANCH_GPOS */
	"RECURSE_SEEN",               /* 0x00002000 - PREGf_RECURSE_SEEN */
d707 1
a707 1
#  define REG_INTFLAGS_NAME_SIZE 13
d717 3
a719 3
    CLUMP, BRANCH, STAR, PLUS, CURLY, CURLYN, CURLYM, CURLYX, WHILEM, REF,
    REFF, REFFL, REFFU, REFFA, NREF, NREFF, NREFFL, NREFFU, NREFFA,
    BRANCHJ, SUSPEND, IFTHEN,
d728 1
a728 1
    0x00, 0x00, 0x00, 0x60, 0x00, 0xFC, 0xF9, 0x5F, 0x06, 0x00, 0x00, 0x00
d740 2
a741 2
    REG_ANY, SANY, ANYOF, ANYOFD, ANYOFL, POSIXD, POSIXL, POSIXU, POSIXA,
    NPOSIXD, NPOSIXL, NPOSIXU, NPOSIXA,
d750 1
a750 1
    0x00, 0x00, 0xFF, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
@


