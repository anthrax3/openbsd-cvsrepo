head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.2
	OPENBSD_6_2_BASE:1.17
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.3.0.2
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.22;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.00;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.22;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.23;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.18.34.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.06.17.04.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.04.29.22.51.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	98.12.31.04.07.29;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.21;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.50;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.50;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.38.02;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.48;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.24;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.16.37;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.46;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.30;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.06.41;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.58.48;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.52.40;	author afresh1;	state Exp;
branches;
next	1.1.1.15;
commitid	B31cAbBIXiCqnL97;

1.1.1.15
date	2017.08.14.13.45.30;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    taint.c
 *
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * '...we will have peace, when you and all your works have perished--and
 *  the works of your dark master to whom you would deliver us.  You are a
 *  liar, Saruman, and a corrupter of men's hearts.'       --Th√©oden
 *
 *     [p.580 of _The Lord of the Rings_, III/x: "The Voice of Saruman"]
 */

/* This file contains a few functions for handling data tainting in Perl
 */

#include "EXTERN.h"
#define PERL_IN_TAINT_C
#include "perl.h"

void
Perl_taint_proper(pTHX_ const char *f, const char *const s)
{
#if defined(HAS_SETEUID) && defined(DEBUGGING)
    PERL_ARGS_ASSERT_TAINT_PROPER;

    {
	const Uid_t  uid = PerlProc_getuid();
	const Uid_t euid = PerlProc_geteuid();

#if Uid_t_sign == 1 /* uid_t is unsigned. */
	DEBUG_u(PerlIO_printf(Perl_debug_log,
                              "%s %d %"UVuf" %"UVuf"\n",
                              s, TAINT_get, (UV)uid, (UV)euid));
#else /* uid_t is signed (Uid_t_sign == -1), or don't know. */
	DEBUG_u(PerlIO_printf(Perl_debug_log,
                              "%s %d %"IVdf" %"IVdf"\n",
                              s, TAINT_get, (IV)uid, (IV)euid));
#endif
    }
#endif

    if (TAINT_get) {
	const char *ug;

	if (!f)
	    f = PL_no_security;
	if (PerlProc_getuid() != PerlProc_geteuid())
	    ug = " while running setuid";
	else if (PerlProc_getgid() != PerlProc_getegid())
	    ug = " while running setgid";
	else if (TAINT_WARN_get)
            ug = " while running with -t switch";
        else
	    ug = " while running with -T switch";

        /* XXX because taint_proper adds extra format args, we can't
         * get the caller to check properly; o we just silence the warning
         * and hope the callers aren't naughty */
        GCC_DIAG_IGNORE(-Wformat-nonliteral);
	if (PL_unsafe || TAINT_WARN_get) {
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_TAINT), f, s, ug);
        }
        else {
            Perl_croak(aTHX_ f, s, ug);
        }
        GCC_DIAG_RESTORE;

    }
}

void
Perl_taint_env(pTHX)
{
    SV** svp;
    MAGIC* mg;
    const char* const *e;
    static const char* const misc_env[] = {
	"IFS",		/* most shells' inter-field separators */
	"CDPATH",	/* ksh dain bramage #1 */
	"ENV",		/* ksh dain bramage #2 */
	"BASH_ENV",	/* bash dain bramage -- I guess it's contagious */
#ifdef WIN32
	"PERL5SHELL",	/* used for system() on Windows */
#endif
	NULL
    };

    /* Don't bother if there's no *ENV glob */
    if (!PL_envgv)
	return;
    /* If there's no %ENV hash or if it's not magical, croak, because
     * it probably doesn't reflect the actual environment */
    if (!GvHV(PL_envgv) || !(SvRMAGICAL(GvHV(PL_envgv))
	    && mg_find((const SV *)GvHV(PL_envgv), PERL_MAGIC_env))) {
	const bool was_tainted = TAINT_get;
	const char * const name = GvENAME(PL_envgv);
	TAINT;
	if (strEQ(name,"ENV"))
	    /* hash alias */
	    taint_proper("%%ENV is aliased to %s%s", "another variable");
	else
	    /* glob alias: report it in the error message */
	    taint_proper("%%ENV is aliased to %%%s%s", name);
	/* this statement is reached under -t or -U */
	TAINT_set(was_tainted);
#ifdef NO_TAINT_SUPPORT
        PERL_UNUSED_VAR(was_tainted);
#endif
    }

#ifdef VMS
    {
    int i = 0;
    char name[10 + TYPE_DIGITS(int)] = "DCL$PATH";
    STRLEN len = 8; /* strlen(name)  */

    while (1) {
	if (i)
	    len = my_sprintf(name,"DCL$PATH;%d", i);
	svp = hv_fetch(GvHVn(PL_envgv), name, len, FALSE);
	if (!svp || *svp == &PL_sv_undef)
	    break;
	if (SvTAINTED(*svp)) {
	    TAINT;
	    taint_proper("Insecure %s%s", "$ENV{DCL$PATH}");
	}
	if ((mg = mg_find(*svp, PERL_MAGIC_envelem)) && MgTAINTEDDIR(mg)) {
	    TAINT;
	    taint_proper("Insecure directory in %s%s", "$ENV{DCL$PATH}");
	}
	i++;
    }
  }
#endif /* VMS */

    svp = hv_fetchs(GvHVn(PL_envgv),"PATH",FALSE);
    if (svp && *svp) {
	if (SvTAINTED(*svp)) {
	    TAINT;
	    taint_proper("Insecure %s%s", "$ENV{PATH}");
	}
	if ((mg = mg_find(*svp, PERL_MAGIC_envelem)) && MgTAINTEDDIR(mg)) {
	    TAINT;
	    taint_proper("Insecure directory in %s%s", "$ENV{PATH}");
	}
    }

#ifndef VMS
    /* tainted $TERM is okay if it contains no metachars */
    svp = hv_fetchs(GvHVn(PL_envgv),"TERM",FALSE);
    if (svp && *svp && SvTAINTED(*svp)) {
	STRLEN len;
	const bool was_tainted = TAINT_get;
	const char *t = SvPV_const(*svp, len);
	const char * const e = t + len;

	TAINT_set(was_tainted);
#ifdef NO_TAINT_SUPPORT
        PERL_UNUSED_VAR(was_tainted);
#endif
	if (t < e && isWORDCHAR(*t))
	    t++;
	while (t < e && (isWORDCHAR(*t) || strchr("-_.+", *t)))
	    t++;
	if (t < e) {
	    TAINT;
	    taint_proper("Insecure $ENV{%s}%s", "TERM");
	}
    }
#endif /* !VMS */

    for (e = misc_env; *e; e++) {
	SV * const * const svp = hv_fetch(GvHVn(PL_envgv), *e, strlen(*e), FALSE);
	if (svp && *svp != &PL_sv_undef && SvTAINTED(*svp)) {
	    TAINT;
	    taint_proper("Insecure $ENV{%s}%s", *e);
	}
    }
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a29 2
    dVAR;

d36 5
d42 3
a44 2
			       "%s %d %"Uid_t_f" %"Uid_t_f"\n",
			       s, TAINT_get, uid, euid));
a79 1
    dVAR;
a187 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a33 1
#   if Uid_t_size == 1
d35 2
a36 2
	const UV  uid = PerlProc_getuid();
	const UV euid = PerlProc_geteuid();
d39 1
a39 1
			       "%s %d %"UVuf" %"UVuf"\n",
a41 10
#   else
    {
	const IV  uid = PerlProc_getuid();
	const IV euid = PerlProc_geteuid();

	DEBUG_u(PerlIO_printf(Perl_debug_log,
			       "%s %d %"IVdf" %"IVdf"\n",
			       s, TAINT_get, uid, euid));
    }
#   endif
d57 5
d68 2
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d41 1
a41 1
			       s, PL_tainted, uid, euid));
d50 1
a50 1
			       s, PL_tainted, uid, euid));
d55 1
a55 1
    if (PL_tainted) {
d64 1
a64 1
	else if (PL_taint_warn)
d68 1
a68 1
	if (PL_unsafe || PL_taint_warn) {
d98 1
a98 1
    /* If there's no %ENV hash of if it's not magical, croak, because
d102 1
a102 1
	const bool was_tainted = PL_tainted;
d104 1
a104 1
	PL_tainted = TRUE;
d112 4
a115 1
	PL_tainted = was_tainted;
d160 1
a160 1
	const bool was_tainted = PL_tainted;
d163 6
a168 2
	PL_tainted = was_tainted;
	if (t < e && isALNUM(*t))
d170 1
a170 1
	while (t < e && (isALNUM(*t) || strchr("-_.+", *t)))
d192 1
a192 1
 * indent-tabs-mode: t
d195 1
a195 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d14 1
a14 1
 *  liar, Saruman, and a corrupter of men's hearts.'       --ThÈoden
d36 2
a37 2
	const UV  uid = PL_uid;
	const UV euid = PL_euid;
d45 2
a46 2
	const IV  uid = PL_uid;
	const IV euid = PL_euid;
d60 1
a60 1
	if (PL_euid != PL_uid)
d62 1
a62 1
	else if (PL_egid != PL_gid)
@


1.12
log
@Merge in perl 5.10.1
@
text
@d27 1
a27 1
Perl_taint_proper(pTHX_ const char *f, const char *s)
d69 1
a69 2
            if(ckWARN_d(WARN_TAINT))
                Perl_warner(aTHX_ packWARN(WARN_TAINT), f, s, ug);
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
a4 1
 *    2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 5
a16 3
 * "...we will have peace, when you and all your works have perished--and
 * the works of your dark master to whom you would deliver us.  You are a
 * liar, Saruman, and a corrupter of men's hearts."  --Theoden
d31 3
d102 1
a102 1
	    && mg_find((SV*)GvHV(PL_envgv), PERL_MAGIC_env))) {
@


1.10
log
@merge in perl 5.8.8
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, by Larry Wall and others
d28 1
d64 1
a64 1
            if(ckWARN(WARN_TAINT))
d76 1
d85 3
d115 1
d119 2
a120 2
	    (void)sprintf(name,"DCL$PATH;%d", i);
	svp = hv_fetch(GvHVn(PL_envgv), name, strlen(name), FALSE);
d136 1
a136 1
    svp = hv_fetch(GvHVn(PL_envgv),"PATH",4,FALSE);
d150 1
a150 1
    svp = hv_fetch(GvHVn(PL_envgv),"TERM",4,FALSE);
d169 1
a169 1
	SV ** const svp = hv_fetch(GvHVn(PL_envgv), *e, strlen(*e), FALSE);
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@a26 2
    char *ug;

d30 2
a31 2
	 UV  uid = PL_uid;
	 UV euid = PL_euid;
d33 1
a33 1
	 DEBUG_u(PerlIO_printf(Perl_debug_log,
d39 2
a40 2
	 IV  uid = PL_uid;
	 IV euid = PL_euid;
d42 1
a42 1
	 DEBUG_u(PerlIO_printf(Perl_debug_log,
d50 2
d77 2
a78 2
    char** e;
    static char* misc_env[] = {
d86 1
d89 16
d146 4
a149 4
	STRLEN n_a;
	bool was_tainted = PL_tainted;
	char *t = SvPV(*svp, n_a);
	char *e = t + n_a;
d163 1
a163 1
	svp = hv_fetch(GvHVn(PL_envgv), *e, strlen(*e), FALSE);
d170 10
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d17 3
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1997-2002, Larry Wall
d133 1
a133 1
	while (t < e && (isALNUM(*t) || *t == '-' || *t == ':'))
@


1.6
log
@merge in perl 5.6.1 with our local changes
@
text
@d1 9
d25 20
a44 3
#ifdef HAS_SETEUID
    DEBUG_u(PerlIO_printf(Perl_debug_log,
            "%s %d %"Uid_t_f" %"Uid_t_f"\n", s, PL_tainted, PL_uid, PL_euid));
d54 3
a56 1
	else
d58 7
a64 4
	if (!PL_unsafe)
	    Perl_croak(aTHX_ f, s, ug);
	else if (ckWARN(WARN_TAINT))
	    Perl_warner(aTHX_ WARN_TAINT, f, s, ug);
d100 1
a100 1
	if ((mg = mg_find(*svp, 'e')) && MgTAINTEDDIR(mg)) {
d115 1
a115 1
	if ((mg = mg_find(*svp, 'e')) && MgTAINTEDDIR(mg)) {
@


1.5
log
@perl-5.6.0 + local changes
@
text
@a13 1
    dTHR;	/* just for taint */
a65 1
	    dTHR;
a69 1
	    dTHR;
a80 1
	    dTHR;
a84 1
	    dTHR;
a93 1
    	dTHR;	/* just for taint */
a112 1
	    dTHR;	/* just for taint */
@


1.4
log
@perl5.005_03 (stock)
@
text
@d8 1
d12 1
a12 1
taint_proper(const char *f, char *s)
d17 1
d19 2
a20 1
            "%s %d %d %d\n", s, PL_tainted, PL_uid, PL_euid));
d24 1
a24 1
	    f = no_security;
d32 3
a34 3
	    croak(f, s, ug);
	else if (PL_dowarn)
	    warn(f, s, ug);
d39 1
a39 1
taint_env(void)
d52 1
a52 1
    if(!PL_envgv)
@


1.3
log
@keep 'perl -T -P' from dumping core
@
text
@d11 1
a11 3
taint_proper(f, s)
const char *f;
char *s;
d13 1
d17 1
a17 1
            "%s %d %d %d\n", s, tainted, uid, euid));
d19 4
a22 2
    if (tainted) {
	if (euid != uid)
d24 1
a24 1
	else if (egid != gid)
d28 1
a28 1
	if (!unsafe)
d30 1
a30 1
	else if (dowarn)
d36 1
a36 1
taint_env()
d49 1
a49 1
    if (!envgv)
d53 1
d60 2
a61 2
	svp = hv_fetch(GvHVn(envgv), name, strlen(name), FALSE);
	if (!svp || *svp == &sv_undef)
d64 1
d69 1
d75 1
d78 1
a78 1
    svp = hv_fetch(GvHVn(envgv),"PATH",4,FALSE);
d81 1
d86 1
d94 1
a94 1
    svp = hv_fetch(GvHVn(envgv),"TERM",4,FALSE);
d96 6
a101 4
	bool was_tainted = tainted;
	char *t = SvPV(*svp, na);
	char *e = t + na;
	tainted = was_tainted;
d114 3
a116 2
	svp = hv_fetch(GvHVn(envgv), *e, strlen(*e), FALSE);
	if (svp && *svp != &sv_undef && SvTAINTED(*svp)) {
@


1.2
log
@perl 5.004_04
@
text
@d48 3
@


1.1
log
@Initial revision
@
text
@d11 2
a12 1
taint_not(s)
d15 4
a18 5
    if (euid != uid)
        croak("No %s allowed while running setuid", s);
    if (egid != gid)
        croak("No %s allowed while running setgid", s);
}
d20 11
a30 22
void
taint_proper(f, s)
char *f;
char *s;
{
    if (tainting) {
	DEBUG_u(fprintf(stderr,"%s %d %d %d\n",s,tainted,uid, euid));
	if (tainted) {
	    char *ug = 0;
	    if (euid != uid)
		ug = " while running setuid";
	    else if (egid != gid)
		ug = " while running setgid";
	    else if (tainting)
		ug = " while running with -T switch";
	    if (ug) {
		if (!unsafe)
		    croak(f, s, ug);
		else if (dowarn)
		    warn(f, s, ug);
	    }
	}
d38 13
d52 54
a105 18
    if (tainting) {
	MAGIC *mg = 0;
	svp = hv_fetch(GvHVn(envgv),"PATH",4,FALSE);
	if (!svp || *svp == &sv_undef ||
	  ((mg = mg_find(*svp, 't')) && mg->mg_len & 1))
	{
	    tainted = TRUE;
	    if (mg && MgTAINTEDDIR(mg))
		taint_proper("Insecure directory in %s%s", "$ENV{PATH}");
	    else
		taint_proper("Insecure %s%s", "$ENV{PATH}");
	}
	svp = hv_fetch(GvHVn(envgv),"IFS",3,FALSE);
	if (svp && *svp != &sv_undef &&
	  (mg = mg_find(*svp, 't')) && mg->mg_len & 1)
	{
	    tainted = TRUE;
	    taint_proper("Insecure %s%s", "$ENV{IFS}");
a108 1

@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d11 2
a12 1
taint_proper(const char *f, char *s)
d14 5
a18 2
    dTHR;	/* just for taint */
    char *ug;
d20 22
a41 16
    DEBUG_u(PerlIO_printf(Perl_debug_log,
            "%s %d %d %d\n", s, PL_tainted, PL_uid, PL_euid));

    if (PL_tainted) {
	if (!f)
	    f = no_security;
	if (PL_euid != PL_uid)
	    ug = " while running setuid";
	else if (PL_egid != PL_gid)
	    ug = " while running setgid";
	else
	    ug = " while running with -T switch";
	if (!PL_unsafe)
	    croak(f, s, ug);
	else if (PL_dowarn)
	    warn(f, s, ug);
d46 1
a46 1
taint_env(void)
a48 9
    MAGIC* mg;
    char** e;
    static char* misc_env[] = {
	"IFS",		/* most shells' inter-field separators */
	"CDPATH",	/* ksh dain bramage #1 */
	"ENV",		/* ksh dain bramage #2 */
	"BASH_ENV",	/* bash dain bramage -- I guess it's contagious */
	NULL
    };
d50 18
a67 23
    if(!PL_envgv)
	return;

#ifdef VMS
    {
    int i = 0;
    char name[10 + TYPE_DIGITS(int)] = "DCL$PATH";

    while (1) {
	if (i)
	    (void)sprintf(name,"DCL$PATH;%d", i);
	svp = hv_fetch(GvHVn(PL_envgv), name, strlen(name), FALSE);
	if (!svp || *svp == &PL_sv_undef)
	    break;
	if (SvTAINTED(*svp)) {
	    dTHR;
	    TAINT;
	    taint_proper("Insecure %s%s", "$ENV{DCL$PATH}");
	}
	if ((mg = mg_find(*svp, 'e')) && MgTAINTEDDIR(mg)) {
	    dTHR;
	    TAINT;
	    taint_proper("Insecure directory in %s%s", "$ENV{DCL$PATH}");
a68 1
	i++;
d70 1
a70 2
  }
#endif /* VMS */
a71 44
    svp = hv_fetch(GvHVn(PL_envgv),"PATH",4,FALSE);
    if (svp && *svp) {
	if (SvTAINTED(*svp)) {
	    dTHR;
	    TAINT;
	    taint_proper("Insecure %s%s", "$ENV{PATH}");
	}
	if ((mg = mg_find(*svp, 'e')) && MgTAINTEDDIR(mg)) {
	    dTHR;
	    TAINT;
	    taint_proper("Insecure directory in %s%s", "$ENV{PATH}");
	}
    }

#ifndef VMS
    /* tainted $TERM is okay if it contains no metachars */
    svp = hv_fetch(GvHVn(PL_envgv),"TERM",4,FALSE);
    if (svp && *svp && SvTAINTED(*svp)) {
    	dTHR;	/* just for taint */
	STRLEN n_a;
	bool was_tainted = PL_tainted;
	char *t = SvPV(*svp, n_a);
	char *e = t + n_a;
	PL_tainted = was_tainted;
	if (t < e && isALNUM(*t))
	    t++;
	while (t < e && (isALNUM(*t) || *t == '-' || *t == ':'))
	    t++;
	if (t < e) {
	    TAINT;
	    taint_proper("Insecure $ENV{%s}%s", "TERM");
	}
    }
#endif /* !VMS */

    for (e = misc_env; *e; e++) {
	svp = hv_fetch(GvHVn(PL_envgv), *e, strlen(*e), FALSE);
	if (svp && *svp != &PL_sv_undef && SvTAINTED(*svp)) {
	    dTHR;	/* just for taint */
	    TAINT;
	    taint_proper("Insecure $ENV{%s}%s", *e);
	}
    }
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a7 1
#define PERL_IN_TAINT_C
d11 1
a11 1
Perl_taint_proper(pTHX_ const char *f, const char *s)
a15 1
#ifdef HAS_SETEUID
d17 1
a17 2
            "%s %d %"Uid_t_f" %"Uid_t_f"\n", s, PL_tainted, PL_uid, PL_euid));
#endif
d21 1
a21 1
	    f = PL_no_security;
d29 3
a31 3
	    Perl_croak(aTHX_ f, s, ug);
	else if (ckWARN(WARN_TAINT))
	    Perl_warner(aTHX_ WARN_TAINT, f, s, ug);
d36 1
a36 1
Perl_taint_env(pTHX)
d49 1
a49 1
    if (!PL_envgv)
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d14 1
d67 1
d72 1
d84 1
d89 1
d99 1
d119 1
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a0 9
/*    taint.c
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

d16 3
a18 20
#if defined(HAS_SETEUID) && defined(DEBUGGING)
#   if Uid_t_size == 1
    {
	 UV  uid = PL_uid;
	 UV euid = PL_euid;

	 DEBUG_u(PerlIO_printf(Perl_debug_log,
			       "%s %d %"UVuf" %"UVuf"\n",
			       s, PL_tainted, uid, euid));
    }
#   else
    {
	 IV  uid = PL_uid;
	 IV euid = PL_euid;

	 DEBUG_u(PerlIO_printf(Perl_debug_log,
			       "%s %d %"IVdf" %"IVdf"\n",
			       s, PL_tainted, uid, euid));
    }
#   endif
d28 1
a28 3
	else if (PL_taint_warn)
            ug = " while running with -t switch";
        else
d30 4
a33 7
	if (PL_unsafe || PL_taint_warn) {
            if(ckWARN(WARN_TAINT))
                Perl_warner(aTHX_ packWARN(WARN_TAINT), f, s, ug);
        }
        else {
            Perl_croak(aTHX_ f, s, ug);
        }
d69 1
a69 1
	if ((mg = mg_find(*svp, PERL_MAGIC_envelem)) && MgTAINTEDDIR(mg)) {
d84 1
a84 1
	if ((mg = mg_find(*svp, PERL_MAGIC_envelem)) && MgTAINTEDDIR(mg)) {
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, by Larry Wall and others
d132 1
a132 1
	while (t < e && (isALNUM(*t) || strchr("-_.+", *t)))
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@a16 3
/* This file contains a few functions for handling data tainting in Perl
 */

@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d27 2
d32 2
a33 2
	const UV  uid = PL_uid;
	const UV euid = PL_euid;
d35 1
a35 1
	DEBUG_u(PerlIO_printf(Perl_debug_log,
d41 2
a42 2
	const IV  uid = PL_uid;
	const IV euid = PL_euid;
d44 1
a44 1
	DEBUG_u(PerlIO_printf(Perl_debug_log,
a51 2
	const char *ug;

d77 2
a78 2
    const char* const *e;
    static const char* const misc_env[] = {
a85 1
    /* Don't bother if there's no *ENV glob */
a87 16
    /* If there's no %ENV hash of if it's not magical, croak, because
     * it probably doesn't reflect the actual environment */
    if (!GvHV(PL_envgv) || !(SvRMAGICAL(GvHV(PL_envgv))
	    && mg_find((SV*)GvHV(PL_envgv), PERL_MAGIC_env))) {
	const bool was_tainted = PL_tainted;
	const char * const name = GvENAME(PL_envgv);
	PL_tainted = TRUE;
	if (strEQ(name,"ENV"))
	    /* hash alias */
	    taint_proper("%%ENV is aliased to %s%s", "another variable");
	else
	    /* glob alias: report it in the error message */
	    taint_proper("%%ENV is aliased to %%%s%s", name);
	/* this statement is reached under -t or -U */
	PL_tainted = was_tainted;
    }
d129 4
a132 4
	STRLEN len;
	const bool was_tainted = PL_tainted;
	const char *t = SvPV_const(*svp, len);
	const char * const e = t + len;
d146 1
a146 1
	SV ** const svp = hv_fetch(GvHVn(PL_envgv), *e, strlen(*e), FALSE);
a152 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a4 2
 *    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a27 1
    dVAR;
d63 1
a63 1
            if(ckWARN_d(WARN_TAINT))
a74 1
    dVAR;
a82 3
#ifdef WIN32
	"PERL5SHELL",	/* used for system() on Windows */
#endif
a109 1
    STRLEN len = 8; /* strlen(name)  */
d113 2
a114 2
	    len = my_sprintf(name,"DCL$PATH;%d", i);
	svp = hv_fetch(GvHVn(PL_envgv), name, len, FALSE);
d130 1
a130 1
    svp = hv_fetchs(GvHVn(PL_envgv),"PATH",FALSE);
d144 1
a144 1
    svp = hv_fetchs(GvHVn(PL_envgv),"TERM",FALSE);
d163 1
a163 1
	SV * const * const svp = hv_fetch(GvHVn(PL_envgv), *e, strlen(*e), FALSE);
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d4 1
a4 1
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 3
a14 5
 * '...we will have peace, when you and all your works have perished--and
 *  the works of your dark master to whom you would deliver us.  You are a
 *  liar, Saruman, and a corrupter of men's hearts.'       --ThÈoden
 *
 *     [p.580 of _The Lord of the Rings_, III/x: "The Voice of Saruman"]
a28 3

    PERL_ARGS_ASSERT_TAINT_PROPER;

d97 1
a97 1
	    && mg_find((const SV *)GvHV(PL_envgv), PERL_MAGIC_env))) {
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d27 1
a27 1
Perl_taint_proper(pTHX_ const char *f, const char *const s)
d69 2
a70 1
	    Perl_ck_warner_d(aTHX_ packWARN(WARN_TAINT), f, s, ug);
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d14 1
a14 1
 *  liar, Saruman, and a corrupter of men's hearts.'       --Th√©oden
d36 2
a37 2
	const UV  uid = PerlProc_getuid();
	const UV euid = PerlProc_geteuid();
d45 2
a46 2
	const IV  uid = PerlProc_getuid();
	const IV euid = PerlProc_geteuid();
d60 1
a60 1
	if (PerlProc_getuid() != PerlProc_geteuid())
d62 1
a62 1
	else if (PerlProc_getgid() != PerlProc_getegid())
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d41 1
a41 1
			       s, TAINT_get, uid, euid));
d50 1
a50 1
			       s, TAINT_get, uid, euid));
d55 1
a55 1
    if (TAINT_get) {
d64 1
a64 1
	else if (TAINT_WARN_get)
d68 1
a68 1
	if (PL_unsafe || TAINT_WARN_get) {
d98 1
a98 1
    /* If there's no %ENV hash or if it's not magical, croak, because
d102 1
a102 1
	const bool was_tainted = TAINT_get;
d104 1
a104 1
	TAINT;
d112 1
a112 4
	TAINT_set(was_tainted);
#ifdef NO_TAINT_SUPPORT
        PERL_UNUSED_VAR(was_tainted);
#endif
d157 1
a157 1
	const bool was_tainted = TAINT_get;
d160 2
a161 6

	TAINT_set(was_tainted);
#ifdef NO_TAINT_SUPPORT
        PERL_UNUSED_VAR(was_tainted);
#endif
	if (t < e && isWORDCHAR(*t))
d163 1
a163 1
	while (t < e && (isWORDCHAR(*t) || strchr("-_.+", *t)))
d185 1
a185 1
 * indent-tabs-mode: nil
d188 1
a188 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d34 1
d36 2
a37 2
	const Uid_t  uid = PerlProc_getuid();
	const Uid_t euid = PerlProc_geteuid();
d40 1
a40 1
			       "%s %d %"Uid_t_f" %"Uid_t_f"\n",
d43 10
a67 5

        /* XXX because taint_proper adds extra format args, we can't
         * get the caller to check properly; o we just silence the warning
         * and hope the callers aren't naughty */
        GCC_DIAG_IGNORE(-Wformat-nonliteral);
a73 2
        GCC_DIAG_RESTORE;

@


1.1.1.15
log
@Import perl-5.24.2
@
text
@d30 2
a37 5
#if Uid_t_sign == 1 /* uid_t is unsigned. */
	DEBUG_u(PerlIO_printf(Perl_debug_log,
                              "%s %d %"UVuf" %"UVuf"\n",
                              s, TAINT_get, (UV)uid, (UV)euid));
#else /* uid_t is signed (Uid_t_sign == -1), or don't know. */
d39 2
a40 3
                              "%s %d %"IVdf" %"IVdf"\n",
                              s, TAINT_get, (IV)uid, (IV)euid));
#endif
d76 1
d185 6
@


