head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.2
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.13
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	QP75iYx42Uo7mMxO;

1.13
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2010.09.24.15.06.43;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.35.59;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.22.59;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.19;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.57;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.22;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.15;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.49;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.52;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.20;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.50;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.36;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.47.42;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.10;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.33;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.48.31;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.06.39;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.03.24.14.58.47;	author afresh1;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.52.39;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    regcomp.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2005, 2006, 2007, by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */
#include "regcharclass.h"

/* Convert branch sequences to more efficient trie ops? */
#define PERL_ENABLE_TRIE_OPTIMISATION 1

/* Be really aggressive about optimising patterns with trie sequences? */
#define PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION 1

/* Should the optimiser take positive assertions into account? */
#define PERL_ENABLE_POSITIVE_ASSERTION_STUDY 0

/* Not for production use: */
#define PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS 0

/* Activate offsets code - set to if 1 to enable */
#ifdef DEBUGGING
#define RE_TRACK_PATTERN_OFFSETS
#endif

/*
 * The "internal use only" fields in regexp.h are present to pass info from
 * compile to execute that permits the execute phase to run lots faster on
 * simple cases.  They are:
 *
 * regstart	sv that must begin a match; NULL if none obvious
 * reganch	is the match anchored (at beginning-of-line only)?
 * regmust	string (pointer into program) that match must include, or NULL
 *  [regmust changed to SV* for bminstr()--law]
 * regmlen	length of regmust string
 *  [regmlen not used currently]
 *
 * Regstart and reganch permit very fast decisions on suitable starting points
 * for a match, cutting down the work a lot.  Regmust permits fast rejection
 * of lines that cannot possibly match.  The regmust tests are costly enough
 * that pregcomp() supplies a regmust only if the r.e. contains something
 * potentially expensive (at present, the only such thing detected is * or +
 * at the start of the r.e., which can involve a lot of backup).  Regmlen is
 * supplied because the test in pregexec() needs it and pregcomp() is computing
 * it anyway.
 * [regmust is now supplied always.  The tests that use regmust have a
 * heuristic that disables the test if it usually matches.]
 *
 * [In fact, we now use regmust in many cases to locate where the search
 * starts in the string, so if regback is >= 0, the regmust search is never
 * wasted effort.  The regback variable says how many characters back from
 * where regmust matched is the earliest possible start of the match.
 * For instance, /[a-z].foo/ has a regmust of 'foo' and a regback of 2.]
 */

/*
 * Structure for regexp "program".  This is essentially a linear encoding
 * of a nondeterministic finite-state machine (aka syntax charts or
 * "railroad normal form" in parsing technology).  Each node is an opcode
 * plus a "next" pointer, possibly plus an operand.  "Next" pointers of
 * all nodes except BRANCH implement concatenation; a "next" pointer with
 * a BRANCH on both ends of it is connecting two alternatives.  (Here we
 * have one of the subtle syntax dependencies:  an individual BRANCH (as
 * opposed to a collection of them) is never concatenated with anything
 * because of operator precedence.)  The operand of some types of node is
 * a literal string; for others, it is a node leading into a sub-FSM.  In
 * particular, the operand of a BRANCH node is the first node of the branch.
 * (NB this is *not* a tree structure:  the tail of the branch connects
 * to the thing following the set of BRANCHes.)  The opcodes are defined
 * in regnodes.h which is generated from regcomp.sym by regcomp.pl.
 */

/*
 * A node is one char of opcode followed by two chars of "next" pointer.
 * "Next" pointers are stored as two 8-bit pieces, high order first.  The
 * value is a positive offset from the opcode of the node containing it.
 * An operand, if any, simply follows the node.  (Note that much of the
 * code generation knows about this implicit relationship.)
 *
 * Using two bytes for the "next" pointer is vast overkill for most things,
 * but allows patterns to get big without disasters.
 *
 * [The "next" pointer is always aligned on an even
 * boundary, and reads the offset directly as a short.]
 */

/* This is the stuff that used to live in regexp.h that was truly
   private to the engine itself. It now lives here. */

 typedef struct regexp_internal {
        int name_list_idx;	/* Optional data index of an array of paren names */
        union {
	    U32 *offsets;           /* offset annotations 20001228 MJD
                                       data about mapping the program to the
                                       string -
                                       offsets[0] is proglen when this is used
                                       */
            U32 proglen;
        } u;

        regnode *regstclass;    /* Optional startclass as identified or constructed
                                   by the optimiser */
        struct reg_data *data;	/* Additional miscellaneous data used by the program.
                                   Used to make it easier to clone and free arbitrary
                                   data that the regops need. Often the ARG field of
                                   a regop is an index into this structure */
	struct reg_code_block *code_blocks;/* positions of literal (?{}) */
	int num_code_blocks;	/* size of code_blocks[] */
	regnode program[1];	/* Unwarranted chumminess with compiler. */
} regexp_internal;

#define RXi_SET(x,y) (x)->pprivate = (void*)(y)   
#define RXi_GET(x)   ((regexp_internal *)((x)->pprivate))
#define RXi_GET_DECL(r,ri) regexp_internal *ri = RXi_GET(r)
/*
 * Flags stored in regexp->intflags
 * These are used only internally to the regexp engine
 *
 * See regexp.h for flags used externally to the regexp engine
 */
#define RXp_INTFLAGS(rx)        ((rx)->intflags)
#define RX_INTFLAGS(prog)        RXp_INTFLAGS(ReANY(prog))

#define PREGf_SKIP		0x00000001
#define PREGf_IMPLICIT		0x00000002 /* Converted .* to ^.* */
#define PREGf_NAUGHTY		0x00000004 /* how exponential is this pattern? */
#define PREGf_VERBARG_SEEN	0x00000008
#define PREGf_CUTGROUP_SEEN	0x00000010
#define PREGf_USE_RE_EVAL	0x00000020 /* compiled with "use re 'eval'" */
/* these used to be extflags, but are now intflags */
#define PREGf_NOSCAN            0x00000040
                                /* spare */
#define PREGf_GPOS_SEEN         0x00000100
#define PREGf_GPOS_FLOAT        0x00000200

#define PREGf_ANCH_MBOL         0x00000400
#define PREGf_ANCH_SBOL         0x00000800
#define PREGf_ANCH_GPOS         0x00001000
#define PREGf_RECURSE_SEEN      0x00002000

#define PREGf_ANCH              \
    ( PREGf_ANCH_SBOL | PREGf_ANCH_GPOS | PREGf_ANCH_MBOL )

/* this is where the old regcomp.h started */

struct regnode_string {
    U8	str_len;
    U8  type;
    U16 next_off;
    char string[1];
};

/* Argument bearing node - workhorse, 
   arg1 is often for the data field */
struct regnode_1 {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
};

/* Similar to a regnode_1 but with an extra signed argument */
struct regnode_2L {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
    I32 arg2;
};

/* 'Two field' -- Two 16 bit unsigned args */
struct regnode_2 {
    U8	flags;
    U8  type;
    U16 next_off;
    U16 arg1;
    U16 arg2;
};

/* This give the number of code points that can be in the bitmap of an ANYOF
 * node.  The shift number must currently be one of: 8..12.  It can't be less
 * than 8 (256) because some code relies on it being at least that.  Above 12
 * (4096), and you start running into warnings that some data structure widths
 * have been exceeded, though the test suite as of this writing still passes
 * for up through 16, which is as high as anyone would ever want to go,
 * encompassing all of the Unicode BMP, and thus including all the economically
 * important world scripts.  At 12 most of them are: including Arabic,
 * Cyrillic, Greek, Hebrew, Indian subcontinent, Latin, and Thai; but not Han,
 * Japanese, nor Korean.  (The regarglen structure in regnodes.h is a U8, and
 * the trie types TRIEC and AHOCORASICKC are larger than U8 for shift values
 * below above 12.)  Be sure to benchmark before changing, as larger sizes do
 * significantly slow down the test suite */
#define NUM_ANYOF_CODE_POINTS   (1 << 8)

#define ANYOF_BITMAP_SIZE	(NUM_ANYOF_CODE_POINTS / 8)   /* 8 bits/Byte */

/* Note that these form structs which are supersets of the next smaller one, by
 * appending fields.  Alignment problems can occur if one of those optional
 * fields requires stricter alignment than the base struct.  And formal
 * parameters that can really be two or more of the structs should be
 * declared as the smallest one it could be.  See commit message for
 * 7dcac5f6a5195002b55c935ee1d67f67e1df280b.  Regnode allocation is done
 * without regard to alignment, and changing it to would also require changing
 * the code that inserts and deletes regnodes.  The basic single-argument
 * regnode has a U32, which is what reganode() allocates as a unit.  Therefore
 * no field can require stricter alignment than U32. */

/* also used by trie */
struct regnode_charclass {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;                           /* set by set_ANYOF_arg() */
    char bitmap[ANYOF_BITMAP_SIZE];	/* only compile-time */
};

/* has runtime (locale) \d, \w, ..., [:posix:] classes */
struct regnode_charclass_class {
    U8	flags;                      /* ANYOF_MATCHES_POSIXL bit must go here */
    U8  type;
    U16 next_off;
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];		/* both compile-time ... */
    U32 classflags;	                        /* and run-time */
};

/* A synthetic start class (SSC); is a regnode_charclass_posixl_fold, plus an
 * extra SV*, used only during its construction and which is not used by
 * regexec.c.  Note that the 'next_off' field is unused, as the SSC stands
 * alone, so there is never a next node.  Also, there is no alignment issue,
 * because these are declared or allocated as a complete unit so the compiler
 * takes care of alignment.  This is unlike the other regnodes which are
 * allocated in terms of multiples of a single-argument regnode.  SSC nodes can
 * have a pointer field because there is no alignment issue, and because it is
 * set to NULL after construction, before any cloning of the pattern */
struct regnode_ssc {
    U8	flags;                      /* ANYOF_MATCHES_POSIXL bit must go here */
    U8  type;
    U16 next_off;
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];	/* both compile-time ... */
    U32 classflags;	                /* ... and run-time */

    /* Auxiliary, only used during construction; NULL afterwards: list of code
     * points matched */
    SV* invlist;
};

/*  We take advantage of 'next_off' not otherwise being used in the SSC by
 *  actually using it: by setting it to 1.  This allows us to test and
 *  distinguish between an SSC and other ANYOF node types, as 'next_off' cannot
 *  otherwise be 1, because it is the offset to the next regnode expressed in
 *  units of regnodes.  Since an ANYOF node contains extra fields, it adds up
 *  to 12 regnode units on 32-bit systems, (hence the minimum this can be (if
 *  not 0) is 11 there.  Even if things get tightly packed on a 64-bit system,
 *  it still would be more than 1. */
#define set_ANYOF_SYNTHETIC(n) STMT_START{ OP(n) = ANYOF;              \
                                           NEXT_OFF(n) = 1;            \
                               } STMT_END
#define is_ANYOF_SYNTHETIC(n) (PL_regkind[OP(n)] == ANYOF && NEXT_OFF(n) == 1)

/* XXX fix this description.
   Impose a limit of REG_INFTY on various pattern matching operations
   to limit stack growth and to avoid "infinite" recursions.
*/
/* The default size for REG_INFTY is I16_MAX, which is the same as
   SHORT_MAX (see perl.h).  Unfortunately I16 isn't necessarily 16 bits
   (see handy.h).  On the Cray C90, sizeof(short)==4 and hence I16_MAX is
   ((1<<31)-1), while on the Cray T90, sizeof(short)==8 and I16_MAX is
   ((1<<63)-1).  To limit stack growth to reasonable sizes, supply a
   smaller default.
	--Andy Dougherty  11 June 1998
*/
#if SHORTSIZE > 2
#  ifndef REG_INFTY
#    define REG_INFTY ((1<<15)-1)
#  endif
#endif

#ifndef REG_INFTY
#  define REG_INFTY I16_MAX
#endif

#define ARG_VALUE(arg) (arg)
#define ARG__SET(arg,val) ((arg) = (val))

#undef ARG
#undef ARG1
#undef ARG2

#define ARG(p) ARG_VALUE(ARG_LOC(p))
#define ARG1(p) ARG_VALUE(ARG1_LOC(p))
#define ARG2(p) ARG_VALUE(ARG2_LOC(p))
#define ARG2L(p) ARG_VALUE(ARG2L_LOC(p))

#define ARG_SET(p, val) ARG__SET(ARG_LOC(p), (val))
#define ARG1_SET(p, val) ARG__SET(ARG1_LOC(p), (val))
#define ARG2_SET(p, val) ARG__SET(ARG2_LOC(p), (val))
#define ARG2L_SET(p, val) ARG__SET(ARG2L_LOC(p), (val))

#undef NEXT_OFF
#undef NODE_ALIGN

#define NEXT_OFF(p) ((p)->next_off)
#define NODE_ALIGN(node)
/* the following define was set to 0xde in 075abff3
 * as part of some linting logic. I have set it to 0
 * as otherwise in every place where we /might/ set flags
 * we have to set it 0 explicitly, which duplicates
 * assignments and IMO adds an unacceptable level of
 * surprise to working in the regex engine. If this
 * is changed from 0 then at the very least make sure
 * that SBOL for /^/ sets the flags to 0 explicitly.
 * -- Yves */
#define NODE_ALIGN_FILL(node) ((node)->flags = 0)

#define SIZE_ALIGN NODE_ALIGN

#undef OP
#undef OPERAND
#undef MASK
#undef STRING

#define	OP(p)		((p)->type)
#define FLAGS(p)	((p)->flags)	/* Caution: Doesn't apply to all      \
					   regnode types.  For some, it's the \
					   character set of the regnode */
#define	OPERAND(p)	(((struct regnode_string *)p)->string)
#define MASK(p)		((char*)OPERAND(p))
#define	STR_LEN(p)	(((struct regnode_string *)p)->str_len)
#define	STRING(p)	(((struct regnode_string *)p)->string)
#define STR_SZ(l)	((l + sizeof(regnode) - 1) / sizeof(regnode))
#define NODE_SZ_STR(p)	(STR_SZ(STR_LEN(p))+1)

#undef NODE_ALIGN
#undef ARG_LOC
#undef NEXTOPER
#undef PREVOPER

#define	NODE_ALIGN(node)
#define	ARG_LOC(p)	(((struct regnode_1 *)p)->arg1)
#define	ARG1_LOC(p)	(((struct regnode_2 *)p)->arg1)
#define	ARG2_LOC(p)	(((struct regnode_2 *)p)->arg2)
#define ARG2L_LOC(p)	(((struct regnode_2L *)p)->arg2)

#define NODE_STEP_REGNODE	1	/* sizeof(regnode)/sizeof(regnode) */
#define EXTRA_STEP_2ARGS	EXTRA_SIZE(struct regnode_2)

#define NODE_STEP_B	4

#define	NEXTOPER(p)	((p) + NODE_STEP_REGNODE)
#define	PREVOPER(p)	((p) - NODE_STEP_REGNODE)

#define FILL_ADVANCE_NODE(ptr, op) STMT_START { \
    (ptr)->type = op;    (ptr)->next_off = 0;   (ptr)++; } STMT_END
#define FILL_ADVANCE_NODE_ARG(ptr, op, arg) STMT_START { \
    ARG_SET(ptr, arg);  FILL_ADVANCE_NODE(ptr, op); (ptr) += 1; } STMT_END
#define FILL_ADVANCE_NODE_2L_ARG(ptr, op, arg1, arg2)               \
                STMT_START {                                        \
                    ARG_SET(ptr, arg1);                             \
                    ARG2L_SET(ptr, arg2);                           \
                    FILL_ADVANCE_NODE(ptr, op);                     \
                    (ptr) += 2;                                     \
                } STMT_END

#define REG_MAGIC 0234

#define SIZE_ONLY cBOOL(RExC_emit == (regnode *) & RExC_emit_dummy)
#define PASS1 SIZE_ONLY
#define PASS2 (! SIZE_ONLY)

/* An ANYOF node is basically a bitmap with the index being a code point.  If
 * the bit for that code point is 1, the code point matches;  if 0, it doesn't
 * match (complemented if inverted).  There is an additional mechanism to deal
 * with cases where the bitmap is insufficient in and of itself.  This #define
 * indicates if the bitmap does fully represent what this ANYOF node can match.
 * The ARG is set to this special value (since 0, 1, ... are legal, but will
 * never reach this high). */
#define ANYOF_ONLY_HAS_BITMAP	((U32) -1)

/* When the bimap isn't completely sufficient for handling the ANYOF node,
 * flags (in node->flags of the ANYOF node) get set to indicate this.  These
 * are perennially in short supply.  Beyond several cases where warnings need
 * to be raised under certain circumstances, currently, there are six cases
 * where the bitmap alone isn't sufficient.  We could use six flags to
 * represent the 6 cases, but to save flags bits, we play some games.  The
 * cases are:
 *
 *  1)  The bitmap has a compiled-in very finite size.  So something else needs
 *      to be used to specify if a code point that is too large for the bitmap
 *      actually matches.  The mechanism currently is a swash or inversion
 *      list.  ANYOF_ONLY_HAS_BITMAP, described above, being TRUE indicates
 *      there are no matches of too-large code points.  But if it is FALSE,
 *      then almost certainly there are matches too large for the bitmap.  (The
 *      other cases, described below, either imply this one or are extremely
 *      rare in practice.)  So we can just assume that a too-large code point
 *      will need something beyond the bitmap if ANYOF_ONLY_HAS_BITMAP is
 *      FALSE, instead of having a separate flag for this.
 *  2)  A subset of item 1) is if all possible code points outside the bitmap
 *      match.  This is a common occurrence when the class is complemented,
 *      like /[^ij]/.  Therefore a bit is reserved to indicate this,
 *      rather than having an expensive swash created,
 *      ANYOF_MATCHES_ALL_ABOVE_BITMAP.
 *  3)  Under /d rules, it can happen that code points that are in the upper
 *      latin1 range (\x80-\xFF or their equivalents on EBCDIC platforms) match
 *      only if the runtime target string being matched against is UTF-8.  For
 *      example /[\w[:punct:]]/d.  This happens only for posix classes (with a
 *      couple of exceptions, like \d where it doesn't happen), and all such
 *      ones also have above-bitmap matches.  Thus, 3) implies 1) as well.
 *      Note that /d rules are no longer encouraged; 'use 5.14' or higher
 *      deselects them.  But a flag is required so that they can be properly
 *      handled.  But it can be a shared flag: see 5) below.
 *  4)  Also under /d rules, something like /[\Wfoo]/ will match everything in
 *      the \x80-\xFF range, unless the string being matched against is UTF-8.
 *      A swash could be created for this case, but this is relatively common,
 *      and it turns out that it's all or nothing:  if any one of these code
 *      points matches, they all do.  Hence a single bit suffices.  We use a
 *      shared flag that doesn't take up space by itself:
 *      ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER.
 *      This also implies 1), with one exception: [:^cntrl:].
 *  5)  A user-defined \p{} property may not have been defined by the time the
 *      regex is compiled.  In this case, we don't know until runtime what it
 *      will match, so we have to assume it could match anything, including
 *      code points that ordinarily would be in the bitmap.  A flag bit is
 *      necessary to indicate this , though it can be shared with the item 3)
 *      flag, as that only occurs under /d, and this only occurs under non-d.
 *      This case is quite uncommon in the field, and the /(?[ ...])/ construct
 *      is a better way to accomplish what this feature does.  This case also
 *      implies 1).
 *      ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP
 *      is the shared flag.
 *  6)  /[foo]/il may have folds that are only valid if the runtime locale is a
 *      UTF-8 one.  These are quite rare, so it would be good to avoid the
 *      expense of looking for them.  But /l matching is slow anyway, and we've
 *      traditionally not worried too much about its performance.  And this
 *      condition requires the ANYOFL_FOLD flag to be set, so testing for
 *      that flag would be sufficient to rule out most cases of this.  So it is
 *      unclear if this should have a flag or not.  But, this flag can be
 *      shared with another, so it doesn't occupy extra space.
 *
 * At the moment, there is one spare bit, but this could be increased by
 * various tricks.
 *
 * If just one more bit is needed, at this writing it seems to khw that the
 * best choice would be to make ANYOF_MATCHES_ALL_ABOVE_BITMAP not a flag, but
 * something like
 *
 *      #define ANYOF_MATCHES_ALL_ABOVE_BITMAP      ((U32) -2)
 *
 * and access it through the ARG like ANYOF_ONLY_HAS_BITMAP is.  This flag is
 * used by all ANYOF node types, and it could be used to avoid calling the
 * handler function, as the macro REGINCLASS in regexec.c does now for other
 * cases.
 *
 * Another possibility is to instead (or additionally) rename the ANYOF_POSIXL
 * flag to be ANYOFL_LARGE, to mean that the ANYOF node has an extra 32 bits
 * beyond what a regular one does.  That's what it effectively means now, with
 * the extra space all for the POSIX class flags.  But those classes actually
 * only occupy 30 bits, so the ANYOFL_FOLD and
 * ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD flags could be moved
 * to that extra space.  The 30 bits in the extra word would indicate if a
 * posix class should be looked up or not.  The downside of this is that ANYOFL
 * nodes with folding would always have to have the extra space allocated, even
 * if they didn't use the 30 posix bits.  There isn't an SSC problem as all
 * SSCs are this large anyway.
 *
 * One could completely remove ANYOFL_LARGE and make all ANYOFL nodes large.
 * REGINCLASS would have to be modified so that if the node type were this, it
 * would call reginclass(), as the flag bit that indicates to do this now would
 * be gone.
 *
 * All told, 5 bits could be available for other uses if all of the above were
 * done.
 *
 * Some flags are not used in synthetic start class (SSC) nodes, so could be
 * shared should new flags be needed for SSCs, like SSC_MATCHES_EMPTY_STRING
 * now. */

/* If this is set, the result of the match should be complemented.  regexec.c
 * is expecting this to be in the low bit.  Never in an SSC */
#define ANYOF_INVERT		                0x01

/* For the SSC node only, which cannot be inverted, so is shared with that bit.
 * This is used only during regex compilation. */
#define SSC_MATCHES_EMPTY_STRING                ANYOF_INVERT

/* Set if this is a regnode_charclass_posixl vs a regnode_charclass.  This
 * is used for runtime \d, \w, [:posix:], ..., which are used only in locale
 * and the optimizer's synthetic start class.  Non-locale \d, etc are resolved
 * at compile-time.  Only set under /l; can be in SSC */
#define ANYOF_MATCHES_POSIXL                    0x02

/* The fold is calculated and stored in the bitmap where possible at compile
 * time.  However under locale, the actual folding varies depending on
 * what the locale is at the time of execution, so it has to be deferred until
 * then.  Only set under /l; never in an SSC  */
#define ANYOFL_FOLD                             0x04

/* Shared bit set only with ANYOFL and SSC nodes:
 *    If ANYOFL_FOLD is set, this means there are potential matches valid
 *       only if the locale is a UTF-8 one.
 *    If ANYOFL_FOLD is NOT set, this means to warn if the runtime locale
 *       isn't a UTF-8 one (and the generated node assumes a UTF-8 locale).
 *       None of INVERT, POSIXL,
 *       ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP
 *       can be set.  */
#define ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD        0x08

/* Convenience macros for teasing apart the meanings when reading the above bit
 * */
#define ANYOFL_SOME_FOLDS_ONLY_IN_UTF8_LOCALE(flags)                        \
    ((flags & ( ANYOFL_FOLD /* Both bits are set */                         \
               |ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD))   \
             == ( ANYOFL_FOLD                                               \
                 |ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD))

#define  ANYOFL_UTF8_LOCALE_REQD(flags)                                     \
    ((flags & ( ANYOFL_FOLD /* Only REQD bit is set */                      \
               |ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD))   \
             == ANYOFL_SHARED_UTF8_LOCALE_fold_HAS_MATCHES_nonfold_REQD)

/* Spare:                                       0x10 */

/* If set, the node matches every code point NUM_ANYOF_CODE_POINTS and above.
 * Can be in an SSC */
#define ANYOF_MATCHES_ALL_ABOVE_BITMAP          0x20

/* Shared bit:
 *      Under /d it means the ANYOFD node matches more things if the target
 *          string is encoded in UTF-8; any such things will be non-ASCII,
 *          characters that are < 256, and can be accessed via the swash.
 *      When not under /d, it means the ANYOF node contains a user-defined
 *      property that wasn't yet defined at the time the regex was compiled,
 *      and so must be looked up at runtime, by creating a swash
 * (These uses are mutually exclusive because a user-defined property is
 * specified by \p{}, and \p{} implies /u which deselects /d).  The long macro
 * name is to make sure that you are cautioned about its shared nature.  Only
 * the non-/d meaning can be in an SSC */
#define ANYOF_SHARED_d_UPPER_LATIN1_UTF8_STRING_MATCHES_non_d_RUNTIME_USER_PROP  0x40

/* Shared bit:
 *      Under /d it means the ANYOFD node matches all non-ASCII Latin1
 *          characters when the target string is not in utf8.
 *      When not under /d, it means the ANYOF node should raise a warning if
 *          matching against an above-Unicode code point.
 * (These uses are mutually exclusive because the warning requires a \p{}, and
 * \p{} implies /u which deselects /d).  An SSC node only has this bit set if
 * what is meant is the warning.  The long macro name is to make sure that you
 * are cautioned about its shared nature */
#define ANYOF_SHARED_d_MATCHES_ALL_NON_UTF8_NON_ASCII_non_d_WARN_SUPER 0x80

#define ANYOF_FLAGS_ALL		(0xff & ~0x10)

#define ANYOF_LOCALE_FLAGS (ANYOFL_FOLD | ANYOF_MATCHES_POSIXL)

/* These are the flags that apply to both regular ANYOF nodes and synthetic
 * start class nodes during construction of the SSC.  During finalization of
 * the SSC, other of the flags may get added to it */
#define ANYOF_COMMON_FLAGS      0

/* Character classes for node->classflags of ANYOF */
/* Should be synchronized with a table in regprop() */
/* 2n should be the normal one, paired with its complement at 2n+1 */

#define ANYOF_ALPHA    ((_CC_ALPHA) * 2)
#define ANYOF_NALPHA   ((ANYOF_ALPHA) + 1)
#define ANYOF_ALPHANUMERIC   ((_CC_ALPHANUMERIC) * 2)    /* [[:alnum:]] isalnum(3), utf8::IsAlnum */
#define ANYOF_NALPHANUMERIC  ((ANYOF_ALPHANUMERIC) + 1)
#define ANYOF_ASCII    ((_CC_ASCII) * 2)
#define ANYOF_NASCII   ((ANYOF_ASCII) + 1)
#define ANYOF_BLANK    ((_CC_BLANK) * 2)     /* GNU extension: space and tab: non-vertical space */
#define ANYOF_NBLANK   ((ANYOF_BLANK) + 1)
#define ANYOF_CASED    ((_CC_CASED) * 2)    /* Pseudo class for [:lower:] or
                                               [:upper:] under /i */
#define ANYOF_NCASED   ((ANYOF_CASED) + 1)
#define ANYOF_CNTRL    ((_CC_CNTRL) * 2)
#define ANYOF_NCNTRL   ((ANYOF_CNTRL) + 1)
#define ANYOF_DIGIT    ((_CC_DIGIT) * 2)     /* \d */
#define ANYOF_NDIGIT   ((ANYOF_DIGIT) + 1)
#define ANYOF_GRAPH    ((_CC_GRAPH) * 2)
#define ANYOF_NGRAPH   ((ANYOF_GRAPH) + 1)
#define ANYOF_LOWER    ((_CC_LOWER) * 2)
#define ANYOF_NLOWER   ((ANYOF_LOWER) + 1)
#define ANYOF_PRINT    ((_CC_PRINT) * 2)
#define ANYOF_NPRINT   ((ANYOF_PRINT) + 1)
#define ANYOF_PUNCT    ((_CC_PUNCT) * 2)
#define ANYOF_NPUNCT   ((ANYOF_PUNCT) + 1)
#define ANYOF_SPACE    ((_CC_SPACE) * 2)     /* \s */
#define ANYOF_NSPACE   ((ANYOF_SPACE) + 1)
#define ANYOF_UPPER    ((_CC_UPPER) * 2)
#define ANYOF_NUPPER   ((ANYOF_UPPER) + 1)
#define ANYOF_WORDCHAR ((_CC_WORDCHAR) * 2)  /* \w, PL_utf8_alnum, utf8::IsWord, ALNUM */
#define ANYOF_NWORDCHAR   ((ANYOF_WORDCHAR) + 1)
#define ANYOF_XDIGIT   ((_CC_XDIGIT) * 2)
#define ANYOF_NXDIGIT  ((ANYOF_XDIGIT) + 1)

/* pseudo classes below this, not stored in the class bitmap, but used as flags
   during compilation of char classes */

#define ANYOF_VERTWS    ((_CC_VERTSPACE) * 2)
#define ANYOF_NVERTWS   ((ANYOF_VERTWS)+1)

/* It is best if this is the last one, as all above it are stored as bits in a
 * bitmap, and it isn't part of that bitmap */
#if _CC_VERTSPACE != _HIGHEST_REGCOMP_DOT_H_SYNC
#   error Problem with handy.h _HIGHEST_REGCOMP_DOT_H_SYNC #define
#endif

#define ANYOF_POSIXL_MAX (ANYOF_VERTWS) /* So upper loop limit is written:
                                         *       '< ANYOF_MAX'
                                         * Hence doesn't include VERTWS, as that
                                         * is a pseudo class */
#define ANYOF_MAX      ANYOF_POSIXL_MAX

#if (ANYOF_POSIXL_MAX > 32)   /* Must fit in 32-bit word */
#   error Problem with handy.h _CC_foo #defines
#endif

#define ANYOF_HORIZWS	((ANYOF_POSIXL_MAX)+2) /* = (ANYOF_NVERTWS + 1) */
#define ANYOF_NHORIZWS	((ANYOF_POSIXL_MAX)+3)

#define ANYOF_UNIPROP   ((ANYOF_POSIXL_MAX)+4)  /* Used to indicate a Unicode
                                                   property: \p{} or \P{} */

/* Backward source code compatibility. */

#define ANYOF_ALNUML	 ANYOF_ALNUM
#define ANYOF_NALNUML	 ANYOF_NALNUM
#define ANYOF_SPACEL	 ANYOF_SPACE
#define ANYOF_NSPACEL	 ANYOF_NSPACE
#define ANYOF_ALNUM ANYOF_WORDCHAR
#define ANYOF_NALNUM ANYOF_NWORDCHAR

/* Utility macros for the bitmap and classes of ANYOF */

#define ANYOF_FLAGS(p)		((p)->flags)

#define ANYOF_BIT(c)		(1U << ((c) & 7))

#define ANYOF_POSIXL_SET(p, c)	(((regnode_charclass_posixl*) (p))->classflags |= (1U << (c)))
#define ANYOF_CLASS_SET(p, c)	ANYOF_POSIXL_SET((p), (c))

#define ANYOF_POSIXL_CLEAR(p, c) (((regnode_charclass_posixl*) (p))->classflags &= ~ (1U <<(c)))
#define ANYOF_CLASS_CLEAR(p, c)	ANYOF_POSIXL_CLEAR((p), (c))

#define ANYOF_POSIXL_TEST(p, c)	(((regnode_charclass_posixl*) (p))->classflags & (1U << (c)))
#define ANYOF_CLASS_TEST(p, c)	ANYOF_POSIXL_TEST((p), (c))

#define ANYOF_POSIXL_ZERO(ret)	STMT_START { ((regnode_charclass_posixl*) (ret))->classflags = 0; } STMT_END
#define ANYOF_CLASS_ZERO(ret)	ANYOF_POSIXL_ZERO(ret)

/* Shifts a bit to get, eg. 0x4000_0000, then subtracts 1 to get 0x3FFF_FFFF */
#define ANYOF_POSIXL_SETALL(ret) STMT_START { ((regnode_charclass_posixl*) (ret))->classflags = ((1U << ((ANYOF_POSIXL_MAX) - 1))) - 1; } STMT_END
#define ANYOF_CLASS_SETALL(ret) ANYOF_POSIXL_SETALL(ret)

#define ANYOF_POSIXL_TEST_ANY_SET(p)                               \
        ((ANYOF_FLAGS(p) & ANYOF_MATCHES_POSIXL)                           \
	 && (((regnode_charclass_posixl*)(p))->classflags))
#define ANYOF_CLASS_TEST_ANY_SET(p) ANYOF_POSIXL_TEST_ANY_SET(p)

/* Since an SSC always has this field, we don't have to test for that; nor do
 * we want to because the bit isn't set for SSC during its construction */
#define ANYOF_POSIXL_SSC_TEST_ANY_SET(p)                               \
                            cBOOL(((regnode_ssc*)(p))->classflags)
#define ANYOF_POSIXL_SSC_TEST_ALL_SET(p) /* Are all bits set? */       \
        (((regnode_ssc*) (p))->classflags                              \
                        == ((1U << ((ANYOF_POSIXL_MAX) - 1))) - 1)

#define ANYOF_POSIXL_TEST_ALL_SET(p)                                   \
        ((ANYOF_FLAGS(p) & ANYOF_MATCHES_POSIXL)                               \
         && ((regnode_charclass_posixl*) (p))->classflags              \
                        == ((1U << ((ANYOF_POSIXL_MAX) - 1))) - 1)

#define ANYOF_POSIXL_OR(source, dest) STMT_START { (dest)->classflags |= (source)->classflags ; } STMT_END
#define ANYOF_CLASS_OR(source, dest) ANYOF_POSIXL_OR((source), (dest))

#define ANYOF_POSIXL_AND(source, dest) STMT_START { (dest)->classflags &= (source)->classflags ; } STMT_END

#define ANYOF_BITMAP_ZERO(ret)	Zero(((regnode_charclass*)(ret))->bitmap, ANYOF_BITMAP_SIZE, char)
#define ANYOF_BITMAP(p)		((regnode_charclass*)(p))->bitmap
#define ANYOF_BITMAP_BYTE(p, c)	BITMAP_BYTE(ANYOF_BITMAP(p), c)
#define ANYOF_BITMAP_SET(p, c)	(ANYOF_BITMAP_BYTE(p, c) |=  ANYOF_BIT(c))
#define ANYOF_BITMAP_CLEAR(p,c)	(ANYOF_BITMAP_BYTE(p, c) &= ~ANYOF_BIT(c))
#define ANYOF_BITMAP_TEST(p, c)	cBOOL(ANYOF_BITMAP_BYTE(p, c) &   ANYOF_BIT(c))

#define ANYOF_BITMAP_SETALL(p)		\
	memset (ANYOF_BITMAP(p), 255, ANYOF_BITMAP_SIZE)
#define ANYOF_BITMAP_CLEARALL(p)	\
	Zero (ANYOF_BITMAP(p), ANYOF_BITMAP_SIZE)

#define ANYOF_SKIP		EXTRA_SIZE(regnode_charclass)
#define ANYOF_POSIXL_SKIP	EXTRA_SIZE(regnode_charclass_posixl)

/*
 * Utility definitions.
 */
#ifndef CHARMASK
#  define UCHARAT(p)	((int)*(const U8*)(p))
#else
#  define UCHARAT(p)	((int)*(p)&CHARMASK)
#endif

#define EXTRA_SIZE(guy) ((sizeof(guy)-1)/sizeof(struct regnode))

#define REG_ZERO_LEN_SEEN                   0x00000001
#define REG_LOOKBEHIND_SEEN                 0x00000002
#define REG_GPOS_SEEN                       0x00000004
/* spare */
#define REG_RECURSE_SEEN                    0x00000020
#define REG_TOP_LEVEL_BRANCHES_SEEN         0x00000040
#define REG_VERBARG_SEEN                    0x00000080
#define REG_CUTGROUP_SEEN                   0x00000100
#define REG_RUN_ON_COMMENT_SEEN             0x00000200
#define REG_UNFOLDED_MULTI_SEEN             0x00000400
/* spare */
#define REG_UNBOUNDED_QUANTIFIER_SEEN       0x00001000


START_EXTERN_C

#ifdef PLUGGABLE_RE_EXTENSION
#include "re_nodes.h"
#else
#include "regnodes.h"
#endif

#ifndef PLUGGABLE_RE_EXTENSION
#ifndef DOINIT
EXTCONST regexp_engine PL_core_reg_engine;
#else /* DOINIT */
EXTCONST regexp_engine PL_core_reg_engine = { 
        Perl_re_compile,
        Perl_regexec_flags,
        Perl_re_intuit_start,
        Perl_re_intuit_string, 
        Perl_regfree_internal,
        Perl_reg_numbered_buff_fetch,
        Perl_reg_numbered_buff_store,
        Perl_reg_numbered_buff_length,
        Perl_reg_named_buff,
        Perl_reg_named_buff_iter,
        Perl_reg_qr_package,
#if defined(USE_ITHREADS)        
        Perl_regdupe_internal,
#endif        
        Perl_re_op_compile
};
#endif /* DOINIT */
#endif /* PLUGGABLE_RE_EXTENSION */


END_EXTERN_C


/* .what is a character array with one character for each member of .data
 * The character describes the function of the corresponding .data item:
 *   a - AV for paren_name_list under DEBUGGING
 *   f - start-class data for regstclass optimization
 *   l - start op for literal (?{EVAL}) item
 *   L - start op for literal (?{EVAL}) item, with separate CV (qr//)
 *   r - pointer to an embedded code-containing qr, e.g. /ab$qr/
 *   s - swash for Unicode-style character class, and the multicharacter
 *       strings resulting from casefolding the single-character entries
 *       in the character class
 *   t - trie struct
 *   u - trie struct's widecharmap (a HV, so can't share, must dup)
 *       also used for revcharmap and words under DEBUGGING
 *   T - aho-trie struct
 *   S - sv for named capture lookup
 * 20010712 mjd@@plover.com
 * (Remember to update re_dup() and pregfree() if you add any items.)
 */
struct reg_data {
    U32 count;
    U8 *what;
    void* data[1];
};

/* Code in S_to_utf8_substr() and S_to_byte_substr() in regexec.c accesses
   anchored* and float* via array indexes 0 and 1.  */
#define anchored_substr substrs->data[0].substr
#define anchored_utf8 substrs->data[0].utf8_substr
#define anchored_offset substrs->data[0].min_offset
#define anchored_end_shift substrs->data[0].end_shift

#define float_substr substrs->data[1].substr
#define float_utf8 substrs->data[1].utf8_substr
#define float_min_offset substrs->data[1].min_offset
#define float_max_offset substrs->data[1].max_offset
#define float_end_shift substrs->data[1].end_shift

#define check_substr substrs->data[2].substr
#define check_utf8 substrs->data[2].utf8_substr
#define check_offset_min substrs->data[2].min_offset
#define check_offset_max substrs->data[2].max_offset
#define check_end_shift substrs->data[2].end_shift

#define RX_ANCHORED_SUBSTR(rx)	(ReANY(rx)->anchored_substr)
#define RX_ANCHORED_UTF8(rx)	(ReANY(rx)->anchored_utf8)
#define RX_FLOAT_SUBSTR(rx)	(ReANY(rx)->float_substr)
#define RX_FLOAT_UTF8(rx)	(ReANY(rx)->float_utf8)

/* trie related stuff */

/* a transition record for the state machine. the
   check field determines which state "owns" the
   transition. the char the transition is for is
   determined by offset from the owning states base
   field.  the next field determines which state
   is to be transitioned to if any.
*/
struct _reg_trie_trans {
  U32 next;
  U32 check;
};

/* a transition list element for the list based representation */
struct _reg_trie_trans_list_elem {
    U16 forid;
    U32 newstate;
};
typedef struct _reg_trie_trans_list_elem reg_trie_trans_le;

/* a state for compressed nodes. base is an offset
  into an array of reg_trie_trans array. If wordnum is
  nonzero the state is accepting. if base is zero then
  the state has no children (and will be accepting)
*/
struct _reg_trie_state {
  U16 wordnum;
  union {
    U32                base;
    reg_trie_trans_le* list;
  } trans;
};

/* info per word; indexed by wordnum */
typedef struct {
    U16  prev;	/* previous word in acceptance chain; eg in
		 * zzz|abc|ab/ after matching the chars abc, the
		 * accepted word is #2, and the previous accepted
		 * word is #3 */
    U32 len;	/* how many chars long is this word? */
    U32 accept;	/* accept state for this word */
} reg_trie_wordinfo;


typedef struct _reg_trie_state    reg_trie_state;
typedef struct _reg_trie_trans    reg_trie_trans;


/* anything in here that needs to be freed later
   should be dealt with in pregfree.
   refcount is first in both this and _reg_ac_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_trie_data {
    U32             refcount;        /* number of times this trie is referenced */
    U32             lasttrans;       /* last valid transition element */
    U16             *charmap;        /* byte to charid lookup array */
    reg_trie_state  *states;         /* state data */
    reg_trie_trans  *trans;          /* array of transition elements */
    char            *bitmap;         /* stclass bitmap */
    U16 	    *jump;           /* optional 1 indexed array of offsets before tail 
                                        for the node following a given word. */
    reg_trie_wordinfo *wordinfo;     /* array of info per word */
    U16             uniquecharcount; /* unique chars in trie (width of trans table) */
    U32             startstate;      /* initial state - used for common prefix optimisation */
    STRLEN          minlen;          /* minimum length of words in trie - build/opt only? */
    STRLEN          maxlen;          /* maximum length of words in trie - build/opt only? */
    U32             prefixlen;       /* #chars in common prefix */
    U32             statecount;      /* Build only - number of states in the states array 
                                        (including the unused zero state) */
    U32             wordcount;       /* Build only */
#ifdef DEBUGGING
    STRLEN          charcount;       /* Build only */
#endif
};
/* There is one (3 under DEBUGGING) pointers that logically belong in this
   structure, but are held outside as they need duplication on thread cloning,
   whereas the rest of the structure can be read only:
    HV              *widecharmap;    code points > 255 to charid
#ifdef DEBUGGING
    AV              *words;          Array of words contained in trie, for dumping
    AV              *revcharmap;     Map of each charid back to its character representation
#endif
*/

#define TRIE_WORDS_OFFSET 2

typedef struct _reg_trie_data reg_trie_data;

/* refcount is first in both this and _reg_trie_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_ac_data {
    U32              refcount;
    U32              trie;
    U32              *fail;
    reg_trie_state   *states;
};
typedef struct _reg_ac_data reg_ac_data;

/* ANY_BIT doesn't use the structure, so we can borrow it here.
   This is simpler than refactoring all of it as wed end up with
   three different sets... */

#define TRIE_BITMAP(p)		(((reg_trie_data *)(p))->bitmap)
#define TRIE_BITMAP_BYTE(p, c)	BITMAP_BYTE(TRIE_BITMAP(p), c)
#define TRIE_BITMAP_SET(p, c)	(TRIE_BITMAP_BYTE(p, c) |=  ANYOF_BIT((U8)c))
#define TRIE_BITMAP_CLEAR(p,c)	(TRIE_BITMAP_BYTE(p, c) &= ~ANYOF_BIT((U8)c))
#define TRIE_BITMAP_TEST(p, c)	(TRIE_BITMAP_BYTE(p, c) &   ANYOF_BIT((U8)c))

#define IS_ANYOF_TRIE(op) ((op)==TRIEC || (op)==AHOCORASICKC)
#define IS_TRIE_AC(op) ((op)>=AHOCORASICK)


#define BITMAP_BYTE(p, c)	(( (U8*) p) [ ( ( (UV) (c)) >> 3) ] )
#define BITMAP_TEST(p, c)	(BITMAP_BYTE(p, c) &   ANYOF_BIT((U8)c))

/* these defines assume uniquecharcount is the correct variable, and state may be evaluated twice */
#define TRIE_NODENUM(state) (((state)-1)/(trie->uniquecharcount)+1)
#define SAFE_TRIE_NODENUM(state) ((state) ? (((state)-1)/(trie->uniquecharcount)+1) : (state))
#define TRIE_NODEIDX(state) ((state) ? (((state)-1)*(trie->uniquecharcount)+1) : (state))

#ifdef DEBUGGING
#define TRIE_CHARCOUNT(trie) ((trie)->charcount)
#else
#define TRIE_CHARCOUNT(trie) (trie_charcount)
#endif

#define RE_TRIE_MAXBUF_INIT 65536
#define RE_TRIE_MAXBUF_NAME "\022E_TRIE_MAXBUF"
#define RE_DEBUG_FLAGS "\022E_DEBUG_FLAGS"

/*

RE_DEBUG_FLAGS is used to control what debug output is emitted
its divided into three groups of options, some of which interact.
The three groups are: Compile, Execute, Extra. There is room for a
further group, as currently only the low three bytes are used.

    Compile Options:
    
    PARSE
    PEEP
    TRIE
    PROGRAM
    OFFSETS

    Execute Options:

    INTUIT
    MATCH
    TRIE

    Extra Options

    TRIE
    OFFSETS

If you modify any of these make sure you make corresponding changes to
re.pm, especially to the documentation.

*/


/* Compile */
#define RE_DEBUG_COMPILE_MASK      0x0000FF
#define RE_DEBUG_COMPILE_PARSE     0x000001
#define RE_DEBUG_COMPILE_OPTIMISE  0x000002
#define RE_DEBUG_COMPILE_TRIE      0x000004
#define RE_DEBUG_COMPILE_DUMP      0x000008
#define RE_DEBUG_COMPILE_FLAGS     0x000010
#define RE_DEBUG_COMPILE_TEST      0x000020

/* Execute */
#define RE_DEBUG_EXECUTE_MASK      0x00FF00
#define RE_DEBUG_EXECUTE_INTUIT    0x000100
#define RE_DEBUG_EXECUTE_MATCH     0x000200
#define RE_DEBUG_EXECUTE_TRIE      0x000400

/* Extra */
#define RE_DEBUG_EXTRA_MASK        0xFF0000
#define RE_DEBUG_EXTRA_TRIE        0x010000
#define RE_DEBUG_EXTRA_OFFSETS     0x020000
#define RE_DEBUG_EXTRA_OFFDEBUG    0x040000
#define RE_DEBUG_EXTRA_STATE       0x080000
#define RE_DEBUG_EXTRA_OPTIMISE    0x100000
#define RE_DEBUG_EXTRA_BUFFERS     0x400000
#define RE_DEBUG_EXTRA_GPOS        0x800000
/* combined */
#define RE_DEBUG_EXTRA_STACK       0x280000

#define RE_DEBUG_FLAG(x) (re_debug_flags & x)
/* Compile */
#define DEBUG_COMPILE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_MASK) x  )
#define DEBUG_PARSE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_PARSE) x  )
#define DEBUG_OPTIMISE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_OPTIMISE) x  )
#define DEBUG_PARSE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_PARSE) x  )
#define DEBUG_DUMP_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_DUMP) x  )
#define DEBUG_TRIE_COMPILE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_TRIE) x )
#define DEBUG_FLAGS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_FLAGS) x )
#define DEBUG_TEST_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_TEST) x )
/* Execute */
#define DEBUG_EXECUTE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_MASK) x  )
#define DEBUG_INTUIT_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_INTUIT) x  )
#define DEBUG_MATCH_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_MATCH) x  )
#define DEBUG_TRIE_EXECUTE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_TRIE) x )

/* Extra */
#define DEBUG_EXTRA_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_MASK) x  )
#define DEBUG_OFFSETS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_OFFSETS) x  )
#define DEBUG_STATE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_STATE) x )
#define DEBUG_STACK_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_STACK) x )
#define DEBUG_BUFFERS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_BUFFERS) x )

#define DEBUG_OPTIMISE_MORE_r(x) DEBUG_r( \
    if ((RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE) == \
         (re_debug_flags & (RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE)) ) x )
#define MJD_OFFSET_DEBUG(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_OFFDEBUG) \
        Perl_warn_nocontext x )
#define DEBUG_TRIE_COMPILE_MORE_r(x) DEBUG_TRIE_COMPILE_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_TRIE) x )
#define DEBUG_TRIE_EXECUTE_MORE_r(x) DEBUG_TRIE_EXECUTE_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_TRIE) x )

#define DEBUG_TRIE_r(x) DEBUG_r( \
    if (re_debug_flags & (RE_DEBUG_COMPILE_TRIE \
        | RE_DEBUG_EXECUTE_TRIE )) x )
#define DEBUG_GPOS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_GPOS) x )

/* initialization */
/* get_sv() can return NULL during global destruction. */
#define GET_RE_DEBUG_FLAGS DEBUG_r({ \
        SV * re_debug_flags_sv = NULL; \
        re_debug_flags_sv = PL_curcop ? get_sv(RE_DEBUG_FLAGS, 1) : NULL; \
        if (re_debug_flags_sv) { \
            if (!SvIOK(re_debug_flags_sv)) \
                sv_setuv(re_debug_flags_sv, RE_DEBUG_COMPILE_DUMP | RE_DEBUG_EXECUTE_MASK ); \
            re_debug_flags=SvIV(re_debug_flags_sv); \
        }\
})

#ifdef DEBUGGING

#define GET_RE_DEBUG_FLAGS_DECL VOL IV re_debug_flags  = 0; \
        PERL_UNUSED_VAR(re_debug_flags); GET_RE_DEBUG_FLAGS;

#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2) \
    const char * const rpv =                                 \
        pv_pretty((dsv), (pv), (l),                          \
            (PL_dump_re_max_len) ? PL_dump_re_max_len : (m), \
            PL_colors[(c1)],PL_colors[(c2)],                 \
            PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII |((isuni) ? PERL_PV_ESCAPE_UNI : 0) );         \
    const int rlen = SvCUR(dsv)

#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m)                        \
    const char * const rpv =                                    \
        pv_pretty((dsv), (SvPV_nolen_const(sv)), (SvCUR(sv)),   \
            (PL_dump_re_max_len) ? PL_dump_re_max_len : (m),    \
            PL_colors[(c1)],PL_colors[(c2)],                    \
            PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII |((isuni) ? PERL_PV_ESCAPE_UNI : 0) )

#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)                    \
    const char * const rpv =                                       \
        pv_pretty((dsv), (pv), (l),                                \
            (PL_dump_re_max_len) ? PL_dump_re_max_len : (m),       \
            PL_colors[0], PL_colors[1],                            \
            ( PERL_PV_PRETTY_QUOTE | PERL_PV_ESCAPE_RE | PERL_PV_ESCAPE_NONASCII | PERL_PV_PRETTY_ELLIPSES | \
              ((isuni) ? PERL_PV_ESCAPE_UNI : 0))                  \
        )

#define RE_SV_DUMPLEN(ItEm) (SvCUR(ItEm) - (SvTAIL(ItEm)!=0))
#define RE_SV_TAIL(ItEm) (SvTAIL(ItEm) ? "$" : "")
    
#else /* if not DEBUGGING */

#define GET_RE_DEBUG_FLAGS_DECL
#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2)
#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m)
#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)
#define RE_SV_DUMPLEN(ItEm)
#define RE_SV_TAIL(ItEm)

#endif /* DEBUG RELATED DEFINES */

typedef enum {
	TRADITIONAL_BOUND = _CC_WORDCHAR,
	GCB_BOUND,
	LB_BOUND,
	SB_BOUND,
	WB_BOUND
} bound_type;

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.14
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d87 1
a87 3
 * boundary, and reads the offset directly as a short.  Also, there is no
 * special test to reverse the sign of BACK pointers since the offset is
 * stored negative.]
a92 2


d135 1
a135 1
#define PREGf_CANY_SEEN         0x00000080
d139 4
a142 4
#define PREGf_ANCH_BOL          0x00000400
#define PREGf_ANCH_MBOL         0x00000800
#define PREGf_ANCH_SBOL         0x00001000
#define PREGf_ANCH_GPOS         0x00002000
d144 2
a145 2
#define PREGf_ANCH              (PREGf_ANCH_SBOL | PREGf_ANCH_GPOS | \
                                 PREGf_ANCH_MBOL | PREGf_ANCH_BOL )
d183 14
d198 1
a198 1
#define ANYOF_BITMAP_SIZE	(256 / 8)   /* 8 bits/Byte */
d216 1
a216 1
    U32 arg1;
d222 1
a222 1
    U8	flags;				/* ANYOF_POSIXL bit must go here */
d226 1
a226 1
    char bitmap[ANYOF_BITMAP_SIZE];		/* both compile-time */
d234 1
a234 1
 * becase these are declared or allocated as a complete unit so the compiler
d240 1
a240 1
    U8	flags;				/* ANYOF_POSIXL bit must go here */
d244 2
a245 2
    char bitmap[ANYOF_BITMAP_SIZE];	/* both compile-time */
    U32 classflags;	                /* and run-time */
d263 1
a263 1
#define is_ANYOF_SYNTHETIC(n) (OP(n) == ANYOF && NEXT_OFF(n) == 1)
d309 10
a318 1
#define NODE_ALIGN_FILL(node) ((node)->flags = 0xde) /* deadbeef */
d361 7
d371 1
a371 1
#define SIZE_ONLY (RExC_emit == (regnode *) & RExC_emit_dummy)
d375 110
a484 19
/* If the bitmap doesn't fully represent what this ANYOF node can match, the
 * ARG is set to this special value (since 0, 1, ... are legal, but will never
 * reach this high). */
#define ANYOF_NONBITMAP_EMPTY	((U32) -1)

/* Flags for node->flags of ANYOF.  These are in short supply, with none
 * currently available.  The ABOVE_LATIN1_ALL bit could be freed up
 * by resorting to creating a swash containing everything above 255.  This
 * introduces a performance penalty.  An option that wouldn't slow things down
 * would be to split one of the two LOC flags out into a separate
 * node, like what was done with ANYOF_NON_UTF8_NON_ASCII_ALL in commit
 * 34fdef848b1687b91892ba55e9e0c3430e0770f6 (but which was reverted because it
 * wasn't the best option available at the time), and using a LOC flag is
 * probably better than that commit anyway.  But it could be reinstated if we
 * need a bit.  The LOC flags are only for /l nodes; the reverted commit was
 * only for /d, so there are no combinatorial issues.  The LOC flag to use is
 * probably the POSIXL one.
 * Several flags are not used in synthetic start class (SSC) nodes, so could be
 * shared should new flags be needed for SSCs, like ANYOF_EMPTY_STRING now. */
d486 3
a488 2
/* regexec.c is expecting this to be in the low bit */
#define ANYOF_INVERT		 0x01
d490 5
a494 8
/* For the SSC node only, which cannot be inverted, so is shared with that bit.
 * This means "Does this SSC match an empty string?"  This is used only during
 * regex compilation. */
#define ANYOF_EMPTY_STRING       ANYOF_INVERT

/* Are there things that will match only if the target string is encoded in
 * UTF-8?  (This is not set if ANYOF_AOVE_LATIN1_ALL is set) */
#define ANYOF_UTF8               0x02
d499 2
a500 2
 * then */
#define ANYOF_LOC_FOLD           0x04
d502 9
a510 7
/* Set if this is a regnode_charclass_posixl vs a regnode_charclass.  This
 * is used for runtime \d, \w, [:posix:], ..., which are used only in locale
 * and the optimizer's synthetic start class.  Non-locale \d, etc are resolved
 * at compile-time */
#define ANYOF_POSIXL	         0x08
#define ANYOF_CLASS	         ANYOF_POSIXL
#define ANYOF_LARGE              ANYOF_POSIXL
d512 1
a512 1
/* Should we raise a warning if matching against an above-Unicode code point?
d514 40
a553 4
#define ANYOF_WARN_SUPER        0x10

/* Can match something outside the bitmap that isn't in utf8 */
#define ANYOF_NONBITMAP_NON_UTF8 0x20
d555 1
a555 3
/* Matches every code point 0x100 and above*/
#define ANYOF_ABOVE_LATIN1_ALL	 0x40
#define ANYOF_UNICODE_ALL	 ANYOF_ABOVE_LATIN1_ALL
d557 1
a557 7
/* Match all Latin1 characters that aren't ASCII when the target string is not
 * in utf8. */
#define ANYOF_NON_UTF8_NON_ASCII_ALL 0x80

#define ANYOF_FLAGS_ALL		(0xff)

#define ANYOF_LOCALE_FLAGS (ANYOF_LOC_FOLD | ANYOF_POSIXL)
d561 2
a562 2
 * the SSC, other of the flags could be added to it */
#define ANYOF_COMMON_FLAGS    (ANYOF_WARN_SUPER|ANYOF_UTF8)
a588 2
#define ANYOF_PSXSPC   ((_CC_PSXSPC) * 2)    /* POSIX space: \s plus the vertical tab */
#define ANYOF_NPSXSPC  ((ANYOF_PSXSPC) + 1)
a638 4
#define ANYOF_SIZE		(sizeof(struct regnode_charclass))
#define ANYOF_POSIXL_SIZE	(sizeof(regnode_charclass_posixl))
#define ANYOF_CLASS_SIZE	ANYOF_POSIXL_SIZE

d641 1
a641 1
#define ANYOF_BIT(c)		(1 << ((c) & 7))
d660 1
a660 1
        ((ANYOF_FLAGS(p) & ANYOF_POSIXL)                           \
d673 1
a673 1
        ((ANYOF_FLAGS(p) & ANYOF_POSIXL)                               \
d682 3
a684 3
#define ANYOF_BITMAP_ZERO(ret)	Zero(((struct regnode_charclass*)(ret))->bitmap, ANYOF_BITMAP_SIZE, char)
#define ANYOF_BITMAP(p)		(((struct regnode_charclass*)(p))->bitmap)
#define ANYOF_BITMAP_BYTE(p, c)	(ANYOF_BITMAP(p)[(((U8)(c)) >> 3) & 31])
d687 1
a687 1
#define ANYOF_BITMAP_TEST(p, c)	(ANYOF_BITMAP_BYTE(p, c) &   ANYOF_BIT(c))
d693 3
a695 7
/* Check that all 256 bits are all set.  Used in S_cl_is_anything()  */
#define ANYOF_BITMAP_TESTALLSET(p)	/* Assumes sizeof(p) == 32 */     \
	memEQ (ANYOF_BITMAP(p), "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377", ANYOF_BITMAP_SIZE)

#define ANYOF_SKIP		((ANYOF_SIZE - 1)/sizeof(regnode))
#define ANYOF_POSIXL_SKIP	((ANYOF_POSIXL_SIZE - 1)/sizeof(regnode))
#define ANYOF_CLASS_SKIP	ANYOF_POSIXL_SKIP
a711 1
#define REG_CANY_SEEN                       0x00000010
d718 1
a718 1
#define REG_GOSTART_SEEN                    0x00000800
d910 1
a910 1
#define TRIE_BITMAP_BYTE(p, c)	(TRIE_BITMAP(p)[(((U8)(c)) >> 3) & 31])
d919 1
a919 1
#define BITMAP_BYTE(p, c)	(((U8*)p)[(((U8)(c)) >> 3) & 31])
d976 1
d1012 2
d1057 1
a1057 1
        re_debug_flags_sv = get_sv(RE_DEBUG_FLAGS, 1); \
d1071 4
a1074 3
    const char * const rpv =                          \
        pv_pretty((dsv), (pv), (l), (m), \
            PL_colors[(c1)],PL_colors[(c2)], \
d1078 5
a1082 4
#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m) \
    const char * const rpv =                          \
        pv_pretty((dsv), (SvPV_nolen_const(sv)), (SvCUR(sv)), (m), \
            PL_colors[(c1)],PL_colors[(c2)], \
d1087 3
a1089 2
        pv_pretty((dsv), (pv), (l), (m), \
            PL_colors[0], PL_colors[1], \
d1108 8
a1116 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.13
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@a28 7
/* Unless the next line is uncommented it is illegal to combine lazy 
   matching with possessive matching. Frankly it doesn't make much sense 
   to allow it as X*?+ matches nothing, X+?+ matches a single char only, 
   and X{min,max}?+ matches min times only.
 */
/* #define REG_ALLOW_MINMOD_SUSPEND */

d128 3
d137 10
d148 2
d188 12
a199 1
#define ANYOF_BITMAP_SIZE	32	/* 256 b/(8 b/B) */
d206 1
a206 1
    U32 arg1;				/* used as ptr in S_regclass */
d212 1
a212 1
    U8	flags;				/* ANYOF_CLASS bit must go here */
d215 1
a215 1
    U32 arg1;					/* used as ptr in S_regclass */
d220 35
d345 3
a347 1
#define SIZE_ONLY (RExC_emit == &PL_regdummy)
d354 26
a379 23
/* The information used to be stored as as combination of the ANYOF_UTF8 and
 * ANYOF_NONBITMAP_NON_UTF8 bits in the flags field, but was moved out of there
 * to free up a bit for other uses.  This tries to hide the change from
 * existing code as much as possible.  Now, the data structure that goes in ARG
 * is not allocated unless it is needed, and that is what is used to determine
 * if there is something outside the bitmap.  The code now assumes that if
 * that structure exists, that any UTF-8 encoded string should be tried against
 * it, but a non-UTF8-encoded string will be tried only if the
 * ANYOF_NONBITMAP_NON_UTF8 bit is also set. */
#define ANYOF_NONBITMAP(node)	(ARG(node) != ANYOF_NONBITMAP_EMPTY)

/* Flags for node->flags of ANYOF.  These are in short supply, but there is one
 * currently available.  If more than this are needed, the ANYOF_LOCALE and
 * ANYOF_CLASS bits could be shared, making a space penalty for all locale nodes.
 * Also, the UNICODE_ALL bit could be freed up by resorting to creating a swash
 * containing everything above 255.  This introduces a performance penalty.
 * Better would be to split it off into a separate node, which actually would
 * improve performance a bit by allowing regexec.c to test for a UTF-8
 * character being above 255 without having to call a function nor calculate
 * its code point value.  However, this solution might need to have a second
 * node type, ANYOF_SYNTHETIC_ABOVE_LATIN1_ALL */

#define ANYOF_LOCALE		 0x01	    /* /l modifier */
d385 1
a385 3
#define ANYOF_LOC_FOLD           0x02

#define ANYOF_INVERT		 0x04
d387 1
a387 1
/* Set if this is a struct regnode_charclass_class vs a regnode_charclass.  This
d390 4
a393 4
 * at compile-time.  Could be shared with ANYOF_LOCALE, forcing all locale
 * nodes to be large */
#define ANYOF_CLASS	         0x08
#define ANYOF_LARGE       ANYOF_CLASS   /* Same; name retained for back compat */
d395 3
a397 1
/* Unused: 0x10.  When using, be sure to change ANYOF_FLAGS_ALL below */
d403 2
a404 1
#define ANYOF_UNICODE_ALL	0x40
d408 3
a410 1
#define ANYOF_NON_UTF8_LATIN1_ALL 0x80
d412 1
a412 1
#define ANYOF_FLAGS_ALL		(0xff & ~0x10)
d414 4
a417 8
/* These are the flags that ANYOF_INVERT being set or not doesn't affect
 * whether they are operative or not.  e.g., the node still has LOCALE
 * regardless of being inverted; whereas ANYOF_UNICODE_ALL means something
 * different if inverted */
#define INVERSION_UNAFFECTED_FLAGS (ANYOF_LOCALE                        \
	                           |ANYOF_LOC_FOLD                      \
	                           |ANYOF_CLASS                         \
	                           |ANYOF_NONBITMAP_NON_UTF8)
d469 7
a475 5
#define ANYOF_MAX      (ANYOF_VERTWS) /* So upper loop limit is written:
                                       *       '< ANYOF_MAX'
                                       * Hence doesn't include VERTWS, as that
                                       * is a pseudo class */
#if (ANYOF_MAX > 32)   /* Must fit in 32-bit word */
d479 2
a480 2
#define ANYOF_HORIZWS	((ANYOF_MAX)+2) /* = (ANYOF_NVERTWS + 1) */
#define ANYOF_NHORIZWS	((ANYOF_MAX)+3)
d482 2
a483 2
#define ANYOF_UNIPROP   ((ANYOF_MAX)+4)  /* Used to indicate a Unicode
                                            property: \p{} or \P{} */
d497 2
a498 1
#define ANYOF_CLASS_SIZE	(sizeof(struct regnode_charclass_class))
d504 8
a511 3
#define ANYOF_CLASS_SET(p, c)	(((struct regnode_charclass_class*) (p))->classflags |= (1U << (c)))
#define ANYOF_CLASS_CLEAR(p, c)	(((struct regnode_charclass_class*) (p))->classflags &= ~ (1U <<(c)))
#define ANYOF_CLASS_TEST(p, c)	(((struct regnode_charclass_class*) (p))->classflags & (1U << (c)))
d513 2
a514 1
#define ANYOF_CLASS_ZERO(ret)	STMT_START { ((struct regnode_charclass_class*) (ret))->classflags = 0; } STMT_END
d517 2
a518 1
#define ANYOF_CLASS_SETALL(ret) STMT_START { ((struct regnode_charclass_class*) (ret))->classflags = ((1U << ((ANYOF_MAX) - 1))) - 1; } STMT_END
d520 22
a541 1
#define ANYOF_CLASS_OR(source, dest) STMT_START { (dest)->classflags |= source->classflags ; } STMT_END
d559 2
a560 8
#define ANYOF_CLASS_SKIP	((ANYOF_CLASS_SIZE - 1)/sizeof(regnode))

#define ANYOF_CLASS_TEST_ANY_SET(p)                               \
        ((ANYOF_FLAGS(p) & ANYOF_CLASS)                           \
	 && (((struct regnode_charclass_class*)(p))->classflags))
/*#define ANYOF_CLASS_ADD_SKIP	(ANYOF_CLASS_SKIP - ANYOF_SKIP)
 * */

d573 3
a575 3
#define REG_SEEN_ZERO_LEN	0x00000001
#define REG_SEEN_LOOKBEHIND	0x00000002
#define REG_SEEN_GPOS		0x00000004
d577 10
a586 8
#define REG_SEEN_CANY		0x00000010
#define REG_SEEN_SANY		REG_SEEN_CANY /* src bckwrd cmpt */
#define REG_SEEN_RECURSE        0x00000020
#define REG_TOP_LEVEL_BRANCHES  0x00000040
#define REG_SEEN_VERBARG        0x00000080
#define REG_SEEN_CUTGROUP       0x00000100
#define REG_SEEN_RUN_ON_COMMENT 0x00000200
#define REG_SEEN_EXACTF_SHARP_S 0x00000400
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a11 3
typedef OP OP_4tree;			/* Will be redefined later. */


d121 2
d140 1
a180 1
#define ANYOF_CLASSBITMAP_SIZE	 4	/* up to 32 (8*4) named classes */
d198 1
a198 1
    char classflags[ANYOF_CLASSBITMAP_SIZE];	/* and run-time */
d309 10
a318 11
/* Flags for node->flags of ANYOF.  These are in short supply, so some games
 * are done to share them, as described below.  If necessary, the ANYOF_LOCALE
 * and ANYOF_CLASS bits could be shared with a space penalty for locale nodes,
 * but this isn't quite so easy, as the optimizer also uses ANYOF_CLASS.
 * Another option would be to push them into new nodes.  E.g. there could be an
 * ANYOF_LOCALE node that would be in place of the flag of the same name.
 * Once the planned change to compile all the above-latin1 code points is done,
 * then the UNICODE_ALL bit can be freed up, with a small performance penalty.
 * If flags need to be added that are applicable to the synthetic start class
 * only, with some work, they could be put in the next-node field, or in an
 * unused bit of the classflags field. */
d323 4
a326 7
 * time.  However there are two cases where it isn't possible.  These share
 * this bit:  1) under locale, where the actual folding varies depending on
 * what the locale is at the time of execution; and 2) where the folding is
 * specified in a swash, not the bitmap, such as characters which aren't
 * specified in the bitmap, or properties that aren't looked at at compile time
 */
#define ANYOF_LOC_NONBITMAP_FOLD 0x02
d333 6
a338 16
 * at compile-time */
#define ANYOF_CLASS	 0x08
#define ANYOF_LARGE      ANYOF_CLASS    /* Same; name retained for back compat */

/* EOS, meaning that it can match an empty string too, is used for the
 * synthetic start class only. */
#define ANYOF_EOS		0x10

/* ? Is this node the synthetic start class (ssc).  This bit is shared with
 * ANYOF_EOS, as the latter is used only for the ssc, and then not used by
 * regexec.c.  And, the code is structured so that if it is set, the ssc is
 * not used, so it is guaranteed to be 0 for the ssc by the time regexec.c
 * gets executed, and 0 for a non-ssc ANYOF node, as it only ever gets set for
 * a potential ssc candidate.  Thus setting it to 1 after it has been
 * determined that the ssc will be used is not ambiguous */
#define ANYOF_IS_SYNTHETIC	ANYOF_EOS
d350 1
a350 1
#define ANYOF_FLAGS_ALL		0xff
d357 1
a357 1
	                           |ANYOF_LOC_NONBITMAP_FOLD            \
a358 1
	                           |ANYOF_EOS                           \
d363 1
a363 1
/* 2n should pair with 2n+1 */
d365 33
a397 30
#define ANYOF_ALNUM	 0	/* \w, PL_utf8_alnum, utf8::IsWord, ALNUM */
#define ANYOF_NALNUM	 1
#define ANYOF_SPACE	 2	/* \s */
#define ANYOF_NSPACE	 3
#define ANYOF_DIGIT	 4	/* \d */
#define ANYOF_NDIGIT	 5
#define ANYOF_ALNUMC	 6	/* [[:alnum:]] isalnum(3), utf8::IsAlnum, ALNUMC */
#define ANYOF_NALNUMC	 7
#define ANYOF_ALPHA	 8
#define ANYOF_NALPHA	 9
#define ANYOF_ASCII	10
#define ANYOF_NASCII	11
#define ANYOF_CNTRL	12
#define ANYOF_NCNTRL	13
#define ANYOF_GRAPH	14
#define ANYOF_NGRAPH	15
#define ANYOF_LOWER	16
#define ANYOF_NLOWER	17
#define ANYOF_PRINT	18
#define ANYOF_NPRINT	19
#define ANYOF_PUNCT	20
#define ANYOF_NPUNCT	21
#define ANYOF_UPPER	22
#define ANYOF_NUPPER	23
#define ANYOF_XDIGIT	24
#define ANYOF_NXDIGIT	25
#define ANYOF_PSXSPC	26	/* POSIX space: \s plus the vertical tab */
#define ANYOF_NPSXSPC	27
#define ANYOF_BLANK	28	/* GNU extension: space and tab: non-vertical space */
#define ANYOF_NBLANK	29
d399 2
a400 1
#define ANYOF_MAX	32
d402 19
a420 2
/* pseudo classes, not stored in the class bitmap, but used as flags
   during compilation of char classes */
d422 2
a423 4
#define ANYOF_VERTWS	(ANYOF_MAX+1)
#define ANYOF_NVERTWS	(ANYOF_MAX+2)
#define ANYOF_HORIZWS	(ANYOF_MAX+3)
#define ANYOF_NHORIZWS	(ANYOF_MAX+4)
d431 2
d443 11
a453 8
#define ANYOF_CLASS_BYTE(p, c)	(((struct regnode_charclass_class*)(p))->classflags[((c) >> 3) & 3])
#define ANYOF_CLASS_SET(p, c)	(ANYOF_CLASS_BYTE(p, c) |=  ANYOF_BIT(c))
#define ANYOF_CLASS_CLEAR(p, c)	(ANYOF_CLASS_BYTE(p, c) &= ~ANYOF_BIT(c))
#define ANYOF_CLASS_TEST(p, c)	(ANYOF_CLASS_BYTE(p, c) &   ANYOF_BIT(c))

#define ANYOF_CLASS_ZERO(ret)	Zero(((struct regnode_charclass_class*)(ret))->classflags, ANYOF_CLASSBITMAP_SIZE, char)
#define ANYOF_CLASS_SETALL(ret)		\
	memset (((struct regnode_charclass_class*)(ret))->classflags, 255, ANYOF_CLASSBITMAP_SIZE)
a454 1

d472 3
a474 6
#if ANYOF_CLASSBITMAP_SIZE != 4
#   error ANYOF_CLASSBITMAP_SIZE is expected to be 4
#endif
#define ANYOF_CLASS_TEST_ANY_SET(p) ((ANYOF_FLAGS(p) & ANYOF_CLASS)         \
	&& memNE (((struct regnode_charclass_class*)(p))->classflags,	    \
		    "\0\0\0\0", ANYOF_CLASSBITMAP_SIZE))
d493 1
a493 1
#define REG_SEEN_EVAL		0x00000008
d528 1
a528 1
        Perl_regdupe_internal
d530 1
d543 3
a545 3
 *   n - Root of op tree for (?{EVAL}) item
 *   o - Start op for (?{EVAL}) item
 *   p - Pad for (?{EVAL}) item
d582 4
a585 4
#define RX_ANCHORED_SUBSTR(rx)	(((struct regexp *)SvANY(rx))->anchored_substr)
#define RX_ANCHORED_UTF8(rx)	(((struct regexp *)SvANY(rx))->anchored_utf8)
#define RX_FLOAT_SUBSTR(rx)	(((struct regexp *)SvANY(rx))->float_substr)
#define RX_FLOAT_UTF8(rx)	(((struct regexp *)SvANY(rx))->float_utf8)
d832 1
a832 2
/* get_sv() can return NULL during global destruction.  re_debug_flags can get
 * clobbered by a longjmp, so must be initialized */
a834 1
        re_debug_flags = 0;            \
d845 2
a846 2
#define GET_RE_DEBUG_FLAGS_DECL VOL IV re_debug_flags \
	PERL_UNUSED_DECL = 0; GET_RE_DEBUG_FLAGS;
d887 1
a887 1
 * indent-tabs-mode: t
d890 1
a890 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@d18 1
a18 1
/* Be really agressive about optimising patterns with trie sequences? */
a20 19
/* Use old style unicode mappings for perl and posix character classes
 *
 * NOTE: Enabling this essentially breaks character class matching against unicode 
 * strings, so that POSIX char classes match when they shouldn't, and \d matches 
 * way more than 10 characters, and sometimes a charclass and its complement either
 * both match or neither match.
 * NOTE: Disabling this will cause various backwards compatibility issues to rear 
 * their head, and tests to fail. However it will make the charclass behaviour 
 * consistant regardless of internal string type, and make character class inversions
 * consistant. The tests that fail in the regex engine are basically broken tests.
 *
 * Personally I think 5.12 should disable this for sure. Its a bit more debatable for
 * 5.10, so for now im leaving it enabled.
 * XXX: It is now enabled for 5.11/5.12
 *
 * -demerphq
 */
#define PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS 1

d188 1
a188 1
    U32 arg1;
d192 3
a194 2
struct regnode_charclass_class {	/* has [[:blah:]] classes */
    U8	flags;				/* should have ANYOF_CLASS here */
d197 1
a197 1
    U32 arg1;
d256 3
d294 38
a331 1
/* Flags for node->flags of ANYOF */
d333 1
a333 4
#define ANYOF_CLASS		0x08	/* has [[:blah:]] classes */
#define ANYOF_INVERT		0x04
#define ANYOF_FOLD		0x02
#define ANYOF_LOCALE		0x01
d335 29
a363 2
/* Used for regstclass only */
#define ANYOF_EOS		0x10		/* Can match an empty string too */
d365 1
a365 3
/* There is a character or a range past 0xff */
#define ANYOF_UNICODE		0x20
#define ANYOF_UNICODE_ALL	0x40	/* Can match any char past 0xff */
d367 9
a375 7
/* size of node is large (includes class pointer) */
#define ANYOF_LARGE 		0x80

/* Are there any runtime flags on in this node? */
#define ANYOF_RUNTIME(s)	(ANYOF_FLAGS(s) & 0x0f)

#define ANYOF_FLAGS_ALL		0xff
d444 2
d459 1
a459 1
#define ANYOF_BITMAP_TESTALLSET(p)	\
d464 9
a472 1
#define ANYOF_CLASS_ADD_SKIP	(ANYOF_CLASS_SKIP - ANYOF_SKIP)
d497 1
a506 31
/* The following have no fixed length. U8 so we can do strchr() on it. */
#ifndef DOINIT
EXTCONST U8 PL_varies[];
#else
EXTCONST U8 PL_varies[] = {
    BRANCH, BACK, STAR, PLUS, CURLY, CURLYX, REF, REFF, REFFL,
    WHILEM, CURLYM, CURLYN, BRANCHJ, IFTHEN, SUSPEND, CLUMP,
    NREF, NREFF, NREFFL,
    0
};
#endif

/* The following always have a length of 1. U8 we can do strchr() on it. */
/* (Note that length 1 means "one character" under UTF8, not "one octet".) */
#ifndef DOINIT
EXTCONST U8 PL_simple[];
#else
EXTCONST U8 PL_simple[] = {
    REG_ANY,	SANY,	CANY,
    ANYOF,
    ALNUM,	ALNUML,
    NALNUM,	NALNUML,
    SPACE,	SPACEL,
    NSPACE,	NSPACEL,
    DIGIT,	NDIGIT,
    VERTWS,     NVERTWS,
    HORIZWS,    NHORIZWS,
    0
};
#endif

d536 1
d616 9
a641 1
    U32             *wordlen;        /* array of lengths of words */
d644 1
a644 2
    U16	            *nextword;       /* optional 1 indexed array to support linked list
                                        of duplicate wordnums */
d649 1
d681 1
a681 1
/* ANY_BIT doesnt use the structure, so we can borrow it here.
d827 2
a828 1
/* get_sv() can return NULL during global destruction. */
d831 1
d842 2
a843 1
#define GET_RE_DEBUG_FLAGS_DECL IV re_debug_flags = 0; GET_RE_DEBUG_FLAGS;
d849 1
a849 1
            PERL_PV_ESCAPE_RE |((isuni) ? PERL_PV_ESCAPE_UNI : 0) );         \
d856 1
a856 1
            PERL_PV_ESCAPE_RE |((isuni) ? PERL_PV_ESCAPE_UNI : 0) )
d862 1
a862 1
            ( PERL_PV_PRETTY_QUOTE | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_ELLIPSES | \
@


1.10
log
@Merge in perl 5.10.1
@
text
@d34 1
d200 1
a200 1
#define ANYOF_CLASSBITMAP_SIZE	 4	/* up to 40 (8*5) named classes */
d550 4
a553 4
#define RX_ANCHORED_SUBSTR(rx)	((rx)->anchored_substr)
#define RX_ANCHORED_UTF8(rx)	((rx)->anchored_utf8)
#define RX_FLOAT_SUBSTR(rx)	((rx)->float_substr)
#define RX_FLOAT_UTF8(rx)	((rx)->float_utf8)
d732 1
d788 2
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d21 18
d338 1
a338 1
#define ANYOF_DIGIT	 4
d340 1
a340 1
#define ANYOF_ALNUMC	 6	/* isalnum(3), utf8::IsAlnum, ALNUMC */
d549 4
a552 1

d838 9
a846 2


@


1.8
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2005 by Larry Wall and others
d10 1
d14 25
d44 1
a44 1
 * regstart	sv that must begin a match; Nullch if none obvious
d82 2
a83 1
 * to the thing following the set of BRANCHes.)  The opcodes are:
d102 43
d152 2
d161 10
d179 1
d181 1
a181 1
#define ANYOF_CLASSBITMAP_SIZE	 4	/* up to 32 (8*4) named classes */
d183 1
d233 2
d238 1
d271 2
d349 8
d382 1
a382 1
#define ANYOF_BITMAP_BYTE(p, c)	(ANYOF_BITMAP(p)[((c) >> 3) & 31])
d399 1
d411 5
a415 5
#define REG_SEEN_ZERO_LEN	 1
#define REG_SEEN_LOOKBEHIND	 2
#define REG_SEEN_GPOS		 4
#define REG_SEEN_EVAL		 8
#define REG_SEEN_CANY		16
d417 5
d425 3
d429 1
d436 4
a439 2
    BRANCH, BACK, STAR, PLUS, CURLY, CURLYX, REF, REFF, REFFL, 
    WHILEM, CURLYM, CURLYN, BRANCHJ, IFTHEN, SUSPEND, CLUMP, 0
d456 2
d462 24
a487 5
typedef struct re_scream_pos_data_s
{
    char **scream_olds;		/* match pos */
    I32 *scream_pos;		/* Internal iterator of scream. */
} re_scream_pos_data;
d491 1
a491 1
 *   f - start-class data for regstclass optimization  
d494 2
a495 2
 *   p - Pad for (?{EVAL} item
 *   s - swash for unicode-style character class, and the multicharacter
d498 5
d512 2
a513 11
struct reg_substr_datum {
    I32 min_offset;
    I32 max_offset;
    SV *substr;		/* non-utf8 variant */
    SV *utf8_substr;	/* utf8 variant */
};

struct reg_substr_data {
    struct reg_substr_datum data[3];	/* Actual array */
};

d517 2
d523 2
d529 290
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d156 3
a158 9
#ifndef lint
#  define NEXT_OFF(p) ((p)->next_off)
#  define NODE_ALIGN(node)
#  define NODE_ALIGN_FILL(node) ((node)->flags = 0xde) /* deadbeef */
#else /* lint */
#  define NEXT_OFF(p) 0
#  define NODE_ALIGN(node)
#  define NODE_ALIGN_FILL(node)
#endif /* lint */
a304 1
#ifndef lint
d306 1
a306 1
#define	UCHARAT(p)	((int)*(U8*)(p))
d308 1
a308 1
#define	UCHARAT(p)	((int)*(p)&CHARMASK)
a309 3
#else /* lint */
#define UCHARAT(p)	PL_regdummy
#endif /* lint */
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1997-2002, Larry Wall
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 6
d97 1
a97 1
#define ANYOF_CLASSBITMAP_SIZE	 4
d103 2
a104 1
    char bitmap[ANYOF_BITMAP_SIZE];
d107 2
a108 2
struct regnode_charclass_class {
    U8	flags;
d111 3
a113 2
    char bitmap[ANYOF_BITMAP_SIZE];
    char classflags[ANYOF_CLASSBITMAP_SIZE];
d141 4
d152 3
d167 5
d180 5
d204 1
a204 1
#define SIZE_ONLY (PL_regcode == &PL_regdummy)
d208 4
a211 4
#define ANYOF_CLASS	0x08
#define ANYOF_INVERT	0x04
#define ANYOF_FOLD	0x02
#define ANYOF_LOCALE	0x01
d214 13
a226 1
#define ANYOF_EOS	0x10		/* Can match an empty string too */
d260 1
a260 1
#define ANYOF_BLANK	28	/* GNU extension: space and tab */
a277 1
#define ANYOF_FLAGS_ALL		0xff
d295 8
d322 6
a327 4
#define REG_SEEN_ZERO_LEN	1
#define REG_SEEN_LOOKBEHIND	2
#define REG_SEEN_GPOS		4
#define REG_SEEN_EVAL		8
d349 8
a356 6
    REG_ANY, ANYUTF8, SANY, SANYUTF8, ANYOF, ANYOFUTF8,
    ALNUM, ALNUMUTF8, ALNUML, ALNUMLUTF8,
    NALNUM, NALNUMUTF8, NALNUML, NALNUMLUTF8,
    SPACE, SPACEUTF8, SPACEL, SPACELUTF8,
    NSPACE, NSPACEUTF8, NSPACEL, NSPACELUTF8,
    DIGIT, DIGITUTF8, NDIGIT, NDIGITUTF8, 0
d368 12
d389 2
a390 1
    SV *substr;
d398 1
d401 1
d405 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d195 1
a195 1
#define ANYOF_ALNUM	 0	/* \w, utf8::IsWord, isALNUM() */
d197 1
a197 1
#define ANYOF_SPACE	 2
d201 1
a201 1
#define ANYOF_ALNUMC	 6	/* isalnum(3), utf8::IsAlnum, isALNUMC() */
d221 4
d226 1
a226 1
#define ANYOF_MAX	31
a274 14

#define	FAIL(m) \
    STMT_START {							\
	if (!SIZE_ONLY)							\
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);		\
	Perl_croak(aTHX_ "/%.127s/: %s",  PL_regprecomp,m);		\
    } STMT_END

#define	FAIL2(pat,m) \
    STMT_START {							\
	if (!SIZE_ONLY)							\
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);		\
	S_re_croak2(aTHX_ "/%.127s/: ",pat,PL_regprecomp,m);		\
    } STMT_END
@


1.3
log
@perl5.005_03 (stock)
@
text
@d69 1
a69 1
    U8	flags;
d72 1
a72 1
    U8 string[1];
d90 18
d154 6
d177 1
a177 1
#define MAGIC 0234
d181 1
a181 16
/* Flags for first parameter byte of ANYOF */
#define ANYOF_INVERT	0x40
#define ANYOF_FOLD	0x20
#define ANYOF_LOCALE	0x10
#define ANYOF_ISA	0x0F
#define ANYOF_ALNUML	 0x08
#define ANYOF_NALNUML	 0x04
#define ANYOF_SPACEL	 0x02
#define ANYOF_NSPACEL	 0x01

/* Utility macros for bitmap of ANYOF */
#define ANYOF_BYTE(p,c)     (p)[1 + (((c) >> 3) & 31)]
#define ANYOF_BIT(c)        (1 << ((c) & 7))
#define ANYOF_SET(p,c)      (ANYOF_BYTE(p,c) |=  ANYOF_BIT(c))
#define ANYOF_CLEAR(p,c)    (ANYOF_BYTE(p,c) &= ~ANYOF_BIT(c))
#define ANYOF_TEST(p,c)     (ANYOF_BYTE(p,c) &   ANYOF_BIT(c))
d183 75
a257 1
#define ANY_SKIP ((33 - 1)/sizeof(regnode) + 1)
d264 1
a264 1
#define	UCHARAT(p)	((int)*(unsigned char *)(p))
d272 13
a284 2
#define	FAIL(m)		croak    ("/%.127s/: %s",  PL_regprecomp,m)
#define	FAIL2(pat,m)	re_croak2("/%.127s/: ",pat,PL_regprecomp,m)
d293 2
d297 1
a297 1
/* The following have no fixed length. char* since we do strchr on it. */
d299 1
a299 1
EXTCONST char varies[];
d301 1
a301 1
EXTCONST char varies[] = {
d303 1
a303 1
    WHILEM, CURLYM, CURLYN, BRANCHJ, IFTHEN, SUSPEND, 0
d307 2
a308 1
/* The following always have a length of 1. char* since we do strchr on it. */
d310 1
a310 1
EXTCONST char simple[];
d312 7
a318 5
EXTCONST char simple[] = {
    ANY, SANY, ANYOF,
    ALNUM, ALNUML, NALNUM, NALNUML,
    SPACE, SPACEL, NSPACE, NSPACEL,
    DIGIT, NDIGIT, 0
d322 32
@


1.2
log
@perl 5.004_04
@
text
@d4 2
a51 156
/* definition	number	opnd?	meaning */
#define	END	 0	/* no	End of program. */
#define	BOL	 1	/* no	Match "" at beginning of line. */
#define MBOL	 2	/* no	Same, assuming multiline. */
#define SBOL	 3	/* no	Same, assuming singleline. */
#define	EOL	 4	/* no	Match "" at end of line. */
#define MEOL	 5	/* no	Same, assuming multiline. */
#define SEOL	 6	/* no	Same, assuming singleline. */
#define	ANY	 7	/* no	Match any one character (except newline). */
#define	SANY	 8	/* no	Match any one character. */
#define	ANYOF	 9	/* sv	Match character in (or not in) this class. */
#define	CURLY	10	/* sv	Match this simple thing {n,m} times. */
#define	CURLYX	11	/* sv	Match this complex thing {n,m} times. */
#define	BRANCH	12	/* node	Match this alternative, or the next... */
#define	BACK	13	/* no	Match "", "next" ptr points backward. */
#define	EXACT	14	/* sv	Match this string (preceded by length). */
#define	EXACTF	15	/* sv	Match this string, folded (prec. by length). */
#define	EXACTFL	16	/* sv	Match this string, folded in locale (w/len). */
#define	NOTHING	17	/* no	Match empty string. */
#define	STAR	18	/* node	Match this (simple) thing 0 or more times. */
#define	PLUS	19	/* node	Match this (simple) thing 1 or more times. */
#define BOUND	20	/* no	Match "" at any word boundary */
#define BOUNDL	21	/* no	Match "" at any word boundary */
#define NBOUND	22	/* no	Match "" at any word non-boundary */
#define NBOUNDL	23	/* no	Match "" at any word non-boundary */
#define REF	24	/* num	Match already matched string */
#define REFF	25	/* num	Match already matched string, folded */
#define REFFL	26	/* num	Match already matched string, folded in loc. */
#define	OPEN	27	/* num	Mark this point in input as start of #n. */
#define	CLOSE	28	/* num	Analogous to OPEN. */
#define MINMOD	29	/* no	Next operator is not greedy. */
#define GPOS	30	/* no	Matches where last m//g left off. */
#define IFMATCH	31	/* no	Succeeds if the following matches. */
#define UNLESSM	32	/* no	Fails if the following matches. */
#define SUCCEED	33	/* no	Return from a subroutine, basically. */
#define WHILEM	34	/* no	Do curly processing and see if rest matches. */
#define ALNUM	35	/* no	Match any alphanumeric character */
#define ALNUML	36 	/* no	Match any alphanumeric char in locale */
#define NALNUM	37	/* no	Match any non-alphanumeric character */
#define NALNUML	38	/* no	Match any non-alphanumeric char in locale */
#define SPACE	39	/* no	Match any whitespace character */
#define SPACEL	40	/* no	Match any whitespace char in locale */
#define NSPACE	41	/* no	Match any non-whitespace character */
#define NSPACEL	42	/* no	Match any non-whitespace char in locale */
#define DIGIT	43	/* no	Match any numeric character */
#define NDIGIT	44	/* no	Match any non-numeric character */

/*
 * Opcode notes:
 *
 * BRANCH	The set of branches constituting a single choice are hooked
 *		together with their "next" pointers, since precedence prevents
 *		anything being concatenated to any individual branch.  The
 *		"next" pointer of the last BRANCH in a choice points to the
 *		thing following the whole choice.  This is also where the
 *		final "next" pointer of each individual branch points; each
 *		branch starts with the operand node of a BRANCH node.
 *
 * BACK		Normal "next" pointers all implicitly point forward; BACK
 *		exists to make loop structures possible.
 *
 * STAR,PLUS	'?', and complex '*' and '+', are implemented as circular
 *		BRANCH structures using BACK.  Simple cases (one character
 *		per match) are implemented with STAR and PLUS for speed
 *		and to minimize recursive plunges.
 *
 * OPEN,CLOSE	...are numbered at compile time.
 */

#ifndef DOINIT
EXT char regarglen[];
#else
EXT char regarglen[] = {
    0,0,0,0,0,0,0,0,0,0,
    /*CURLY*/ 4, /*CURLYX*/ 4,
    0,0,0,0,0,0,0,0,0,0,0,0,
    /*REF*/ 2, 2, 2, /*OPEN*/ 2, /*CLOSE*/ 2,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
};
#endif

#ifndef DOINIT
EXT char regkind[];
#else
EXT char regkind[] = {
	END,
	BOL,
	BOL,
	BOL,
	EOL,
	EOL,
	EOL,
	ANY,
	ANY,
	ANYOF,
	CURLY,
	CURLY,
	BRANCH,
	BACK,
	EXACT,
	EXACT,
	EXACT,
	NOTHING,
	STAR,
	PLUS,
	BOUND,
	BOUND,
	NBOUND,
	NBOUND,
	REF,
	REF,
	REF,
	OPEN,
	CLOSE,
	MINMOD,
	GPOS,
	BRANCH,
	BRANCH,
	END,
	WHILEM,
	ALNUM,
	ALNUM,
	NALNUM,
	NALNUM,
	SPACE,
	SPACE,
	NSPACE,
	NSPACE,
	DIGIT,
	NDIGIT,
};
#endif

/* The following have no fixed length. */
#ifndef DOINIT
EXT char varies[];
#else
EXT char varies[] = {
    BRANCH, BACK, STAR, PLUS, CURLY, CURLYX, REF, REFF, REFFL, WHILEM, 0
};
#endif

/* The following always have a length of 1. */
#ifndef DOINIT
EXT char simple[];
#else
EXT char simple[] = {
    ANY, SANY, ANYOF,
    ALNUM, ALNUML, NALNUM, NALNUML,
    SPACE, SPACEL, NSPACE, NSPACEL,
    DIGIT, NDIGIT, 0
};
#endif

EXT char regdummy;

d62 1
a62 1
 * [If REGALIGN is defined, the "next" pointer is always aligned on an even
d68 21
a88 7
#ifndef gould
#ifndef cray
#ifndef eta10
#define REGALIGN
#endif
#endif
#endif
d90 31
a120 1
#define	OP(p)	(*(p))
d123 3
a125 9
#ifdef REGALIGN
#define NEXT(p) (*(short*)(p+1))
#define ARG1(p) (*(unsigned short*)(p+3))
#define ARG2(p) (*(unsigned short*)(p+5))
#else
#define	NEXT(p)	(((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
#define	ARG1(p)	(((*((p)+3)&0377)<<8) + (*((p)+4)&0377))
#define	ARG2(p)	(((*((p)+5)&0377)<<8) + (*((p)+6)&0377))
#endif
d127 3
a129 1
#define NEXT(p) 0
d132 1
a132 1
#define	OPERAND(p)	((p) + 3)
d134 18
a151 7
#ifdef REGALIGN
#define	NEXTOPER(p)	((p) + 4)
#define	PREVOPER(p)	((p) - 4)
#else
#define	NEXTOPER(p)	((p) + 3)
#define	PREVOPER(p)	((p) - 3)
#endif
d155 2
d167 9
d186 1
a186 1
#define UCHARAT(p)	regdummy
d189 34
a222 1
#define	FAIL(m)	croak("/%.127s/: %s",regprecomp,m)
@


1.1
log
@Initial revision
@
text
@d51 10
a60 10
#define	END	0	/* no	End of program. */
#define	BOL	1	/* no	Match "" at beginning of line. */
#define MBOL	2	/* no	Same, assuming multiline. */
#define SBOL	3	/* no	Same, assuming singleline. */
#define	EOL	4	/* no	Match "" at end of line. */
#define MEOL	5	/* no	Same, assuming multiline. */
#define SEOL	6	/* no	Same, assuming singleline. */
#define	ANY	7	/* no	Match any one character (except newline). */
#define	SANY	8	/* no	Match any one character. */
#define	ANYOF	9	/* sv	Match character in (or not in) this class. */
d65 6
a70 6
#define	EXACTLY	14	/* sv	Match this string (preceded by length). */
#define	NOTHING	15	/* no	Match empty string. */
#define	STAR	16	/* node	Match this (simple) thing 0 or more times. */
#define	PLUS	17	/* node	Match this (simple) thing 1 or more times. */
#define ALNUM	18	/* no	Match any alphanumeric character */
#define NALNUM	19	/* no	Match any non-alphanumeric character */
d72 6
a77 6
#define NBOUND	21	/* no	Match "" at any word non-boundary */
#define SPACE	22	/* no	Match any whitespace character */
#define NSPACE	23	/* no	Match any non-whitespace character */
#define DIGIT	24	/* no	Match any numeric character */
#define NDIGIT	25	/* no	Match any non-numeric character */
#define REF	26	/* num	Match some already matched string */
d81 1
a81 1
#define GBOL	30	/* no	Matches where last m//g left off. */
d86 10
d122 7
a128 1
EXT char regarglen[] = {0,0,0,0,0,0,0,0,0,0,4,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,2,0,0,0,0,0};
d149 3
a151 1
	EXACTLY,
d155 1
a155 2
	ALNUM,
	NALNUM,
d158 3
a160 4
	SPACE,
	NSPACE,
	DIGIT,
	NDIGIT,
d165 1
a165 1
	BOL,
d169 11
a179 1
	WHILEM
d187 3
a189 1
EXT char varies[] = {BRANCH,BACK,STAR,PLUS,CURLY,CURLYX,REF,WHILEM,0};
d196 6
a201 1
EXT char simple[] = {ANY,SANY,ANYOF,ALNUM,NALNUM,SPACE,NSPACE,DIGIT,NDIGIT,0};
d257 10
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a3 2
typedef OP OP_4tree;			/* Will be redefined later. */

d50 123
d183 1
a183 1
 * [The "next" pointer is always aligned on an even
d189 7
a195 21
struct regnode_string {
    U8	flags;
    U8  type;
    U16 next_off;
    U8 string[1];
};

struct regnode_1 {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
};

struct regnode_2 {
    U8	flags;
    U8  type;
    U16 next_off;
    U16 arg1;
    U16 arg2;
};
d197 1
a197 31
/* XXX fix this description.
   Impose a limit of REG_INFTY on various pattern matching operations
   to limit stack growth and to avoid "infinite" recursions.
*/
/* The default size for REG_INFTY is I16_MAX, which is the same as
   SHORT_MAX (see perl.h).  Unfortunately I16 isn't necessarily 16 bits
   (see handy.h).  On the Cray C90, sizeof(short)==4 and hence I16_MAX is
   ((1<<31)-1), while on the Cray T90, sizeof(short)==8 and I16_MAX is
   ((1<<63)-1).  To limit stack growth to reasonable sizes, supply a
   smaller default.
	--Andy Dougherty  11 June 1998
*/
#if SHORTSIZE > 2
#  ifndef REG_INFTY
#    define REG_INFTY ((1<<15)-1)
#  endif
#endif

#ifndef REG_INFTY
#  define REG_INFTY I16_MAX
#endif

#define ARG_VALUE(arg) (arg)
#define ARG__SET(arg,val) ((arg) = (val))

#define ARG(p) ARG_VALUE(ARG_LOC(p))
#define ARG1(p) ARG_VALUE(ARG1_LOC(p))
#define ARG2(p) ARG_VALUE(ARG2_LOC(p))
#define ARG_SET(p, val) ARG__SET(ARG_LOC(p), (val))
#define ARG1_SET(p, val) ARG__SET(ARG1_LOC(p), (val))
#define ARG2_SET(p, val) ARG__SET(ARG2_LOC(p), (val))
d200 9
a208 3
#  define NEXT_OFF(p) ((p)->next_off)
#  define NODE_ALIGN(node)
#  define NODE_ALIGN_FILL(node) ((node)->flags = 0xde) /* deadbeef */
d210 1
a210 3
#  define NEXT_OFF(p) 0
#  define NODE_ALIGN(node)
#  define NODE_ALIGN_FILL(node)
d213 1
a213 1
#define SIZE_ALIGN NODE_ALIGN
d215 7
a221 18
#define	OP(p)		((p)->type)
#define	OPERAND(p)	(((struct regnode_string *)p)->string)
#define	NODE_ALIGN(node)
#define	ARG_LOC(p)	(((struct regnode_1 *)p)->arg1)
#define	ARG1_LOC(p)	(((struct regnode_2 *)p)->arg1)
#define	ARG2_LOC(p)	(((struct regnode_2 *)p)->arg2)
#define NODE_STEP_REGNODE	1	/* sizeof(regnode)/sizeof(regnode) */
#define EXTRA_STEP_2ARGS	EXTRA_SIZE(struct regnode_2)

#define NODE_STEP_B	4

#define	NEXTOPER(p)	((p) + NODE_STEP_REGNODE)
#define	PREVOPER(p)	((p) - NODE_STEP_REGNODE)

#define FILL_ADVANCE_NODE(ptr, op) STMT_START { \
    (ptr)->type = op;    (ptr)->next_off = 0;   (ptr)++; } STMT_END
#define FILL_ADVANCE_NODE_ARG(ptr, op, arg) STMT_START { \
    ARG_SET(ptr, arg);  FILL_ADVANCE_NODE(ptr, op); (ptr) += 1; } STMT_END
a224 21
#define SIZE_ONLY (PL_regcode == &PL_regdummy)

/* Flags for first parameter byte of ANYOF */
#define ANYOF_INVERT	0x40
#define ANYOF_FOLD	0x20
#define ANYOF_LOCALE	0x10
#define ANYOF_ISA	0x0F
#define ANYOF_ALNUML	 0x08
#define ANYOF_NALNUML	 0x04
#define ANYOF_SPACEL	 0x02
#define ANYOF_NSPACEL	 0x01

/* Utility macros for bitmap of ANYOF */
#define ANYOF_BYTE(p,c)     (p)[1 + (((c) >> 3) & 31)]
#define ANYOF_BIT(c)        (1 << ((c) & 7))
#define ANYOF_SET(p,c)      (ANYOF_BYTE(p,c) |=  ANYOF_BIT(c))
#define ANYOF_CLEAR(p,c)    (ANYOF_BYTE(p,c) &= ~ANYOF_BIT(c))
#define ANYOF_TEST(p,c)     (ANYOF_BYTE(p,c) &   ANYOF_BIT(c))

#define ANY_SKIP ((33 - 1)/sizeof(regnode) + 1)

d235 1
a235 1
#define UCHARAT(p)	PL_regdummy
d238 1
a238 34
#define	FAIL(m)		croak    ("/%.127s/: %s",  PL_regprecomp,m)
#define	FAIL2(pat,m)	re_croak2("/%.127s/: ",pat,PL_regprecomp,m)

#define EXTRA_SIZE(guy) ((sizeof(guy)-1)/sizeof(struct regnode))

#define REG_SEEN_ZERO_LEN	1
#define REG_SEEN_LOOKBEHIND	2
#define REG_SEEN_GPOS		4
#define REG_SEEN_EVAL		8

#include "regnodes.h"

/* The following have no fixed length. char* since we do strchr on it. */
#ifndef DOINIT
EXTCONST char varies[];
#else
EXTCONST char varies[] = {
    BRANCH, BACK, STAR, PLUS, CURLY, CURLYX, REF, REFF, REFFL, 
    WHILEM, CURLYM, CURLYN, BRANCHJ, IFTHEN, SUSPEND, 0
};
#endif

/* The following always have a length of 1. char* since we do strchr on it. */
#ifndef DOINIT
EXTCONST char simple[];
#else
EXTCONST char simple[] = {
    ANY, SANY, ANYOF,
    ALNUM, ALNUML, NALNUM, NALNUML,
    SPACE, SPACEL, NSPACE, NSPACEL,
    DIGIT, NDIGIT, 0
};
#endif

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d69 1
a69 1
    U8	str_len;
d72 1
a72 1
    char string[1];
a89 18
#define ANYOF_BITMAP_SIZE	32	/* 256 b/(8 b/B) */
#define ANYOF_CLASSBITMAP_SIZE	 4

struct regnode_charclass {
    U8	flags;
    U8  type;
    U16 next_off;
    char bitmap[ANYOF_BITMAP_SIZE];
};

struct regnode_charclass_class {
    U8	flags;
    U8  type;
    U16 next_off;
    char bitmap[ANYOF_BITMAP_SIZE];
    char classflags[ANYOF_CLASSBITMAP_SIZE];
};

a135 6
#define MASK(p)		((char*)OPERAND(p))
#define	STR_LEN(p)	(((struct regnode_string *)p)->str_len)
#define	STRING(p)	(((struct regnode_string *)p)->string)
#define STR_SZ(l)	((l + sizeof(regnode) - 1) / sizeof(regnode))
#define NODE_SZ_STR(p)	(STR_SZ(STR_LEN(p))+1)

d153 1
a153 1
#define REG_MAGIC 0234
d157 16
a172 1
/* Flags for node->flags of ANYOF */
d174 1
a174 75
#define ANYOF_CLASS	0x08
#define ANYOF_INVERT	0x04
#define ANYOF_FOLD	0x02
#define ANYOF_LOCALE	0x01

/* Used for regstclass only */
#define ANYOF_EOS	0x10		/* Can match an empty string too */

/* Character classes for node->classflags of ANYOF */
/* Should be synchronized with a table in regprop() */
/* 2n should pair with 2n+1 */

#define ANYOF_ALNUM	 0	/* \w, utf8::IsWord, isALNUM() */
#define ANYOF_NALNUM	 1
#define ANYOF_SPACE	 2
#define ANYOF_NSPACE	 3
#define ANYOF_DIGIT	 4
#define ANYOF_NDIGIT	 5
#define ANYOF_ALNUMC	 6	/* isalnum(3), utf8::IsAlnum, isALNUMC() */
#define ANYOF_NALNUMC	 7
#define ANYOF_ALPHA	 8
#define ANYOF_NALPHA	 9
#define ANYOF_ASCII	10
#define ANYOF_NASCII	11
#define ANYOF_CNTRL	12
#define ANYOF_NCNTRL	13
#define ANYOF_GRAPH	14
#define ANYOF_NGRAPH	15
#define ANYOF_LOWER	16
#define ANYOF_NLOWER	17
#define ANYOF_PRINT	18
#define ANYOF_NPRINT	19
#define ANYOF_PUNCT	20
#define ANYOF_NPUNCT	21
#define ANYOF_UPPER	22
#define ANYOF_NUPPER	23
#define ANYOF_XDIGIT	24
#define ANYOF_NXDIGIT	25

#define ANYOF_MAX	31

/* Backward source code compatibility. */

#define ANYOF_ALNUML	 ANYOF_ALNUM
#define ANYOF_NALNUML	 ANYOF_NALNUM
#define ANYOF_SPACEL	 ANYOF_SPACE
#define ANYOF_NSPACEL	 ANYOF_NSPACE

/* Utility macros for the bitmap and classes of ANYOF */

#define ANYOF_SIZE		(sizeof(struct regnode_charclass))
#define ANYOF_CLASS_SIZE	(sizeof(struct regnode_charclass_class))

#define ANYOF_FLAGS(p)		((p)->flags)
#define ANYOF_FLAGS_ALL		0xff

#define ANYOF_BIT(c)		(1 << ((c) & 7))

#define ANYOF_CLASS_BYTE(p, c)	(((struct regnode_charclass_class*)(p))->classflags[((c) >> 3) & 3])
#define ANYOF_CLASS_SET(p, c)	(ANYOF_CLASS_BYTE(p, c) |=  ANYOF_BIT(c))
#define ANYOF_CLASS_CLEAR(p, c)	(ANYOF_CLASS_BYTE(p, c) &= ~ANYOF_BIT(c))
#define ANYOF_CLASS_TEST(p, c)	(ANYOF_CLASS_BYTE(p, c) &   ANYOF_BIT(c))

#define ANYOF_CLASS_ZERO(ret)	Zero(((struct regnode_charclass_class*)(ret))->classflags, ANYOF_CLASSBITMAP_SIZE, char)
#define ANYOF_BITMAP_ZERO(ret)	Zero(((struct regnode_charclass*)(ret))->bitmap, ANYOF_BITMAP_SIZE, char)

#define ANYOF_BITMAP(p)		(((struct regnode_charclass*)(p))->bitmap)
#define ANYOF_BITMAP_BYTE(p, c)	(ANYOF_BITMAP(p)[((c) >> 3) & 31])
#define ANYOF_BITMAP_SET(p, c)	(ANYOF_BITMAP_BYTE(p, c) |=  ANYOF_BIT(c))
#define ANYOF_BITMAP_CLEAR(p,c)	(ANYOF_BITMAP_BYTE(p, c) &= ~ANYOF_BIT(c))
#define ANYOF_BITMAP_TEST(p, c)	(ANYOF_BITMAP_BYTE(p, c) &   ANYOF_BIT(c))

#define ANYOF_SKIP		((ANYOF_SIZE - 1)/sizeof(regnode))
#define ANYOF_CLASS_SKIP	((ANYOF_CLASS_SIZE - 1)/sizeof(regnode))
#define ANYOF_CLASS_ADD_SKIP	(ANYOF_CLASS_SKIP - ANYOF_SKIP)
d181 1
a181 1
#define	UCHARAT(p)	((int)*(U8*)(p))
d189 2
a190 13
#define	FAIL(m) \
    STMT_START {							\
	if (!SIZE_ONLY)							\
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);		\
	Perl_croak(aTHX_ "/%.127s/: %s",  PL_regprecomp,m);		\
    } STMT_END

#define	FAIL2(pat,m) \
    STMT_START {							\
	if (!SIZE_ONLY)							\
	    SAVEDESTRUCTOR_X(clear_re,(void*)PL_regcomp_rx);		\
	S_re_croak2(aTHX_ "/%.127s/: ",pat,PL_regprecomp,m);		\
    } STMT_END
a198 2
START_EXTERN_C

d201 1
a201 1
/* The following have no fixed length. U8 so we can do strchr() on it. */
d203 1
a203 1
EXTCONST U8 PL_varies[];
d205 1
a205 1
EXTCONST U8 PL_varies[] = {
d207 1
a207 1
    WHILEM, CURLYM, CURLYN, BRANCHJ, IFTHEN, SUSPEND, CLUMP, 0
d211 1
a211 2
/* The following always have a length of 1. U8 we can do strchr() on it. */
/* (Note that length 1 means "one character" under UTF8, not "one octet".) */
d213 1
a213 1
EXTCONST U8 PL_simple[];
d215 5
a219 7
EXTCONST U8 PL_simple[] = {
    REG_ANY, ANYUTF8, SANY, SANYUTF8, ANYOF, ANYOFUTF8,
    ALNUM, ALNUMUTF8, ALNUML, ALNUMLUTF8,
    NALNUM, NALNUMUTF8, NALNUML, NALNUMLUTF8,
    SPACE, SPACEUTF8, SPACEL, SPACELUTF8,
    NSPACE, NSPACEUTF8, NSPACEL, NSPACELUTF8,
    DIGIT, DIGITUTF8, NDIGIT, NDIGITUTF8, 0
a222 32
END_EXTERN_C

typedef struct re_scream_pos_data_s
{
    char **scream_olds;		/* match pos */
    I32 *scream_pos;		/* Internal iterator of scream. */
} re_scream_pos_data;

struct reg_data {
    U32 count;
    U8 *what;
    void* data[1];
};

struct reg_substr_datum {
    I32 min_offset;
    I32 max_offset;
    SV *substr;
};

struct reg_substr_data {
    struct reg_substr_datum data[3];	/* Actual array */
};

#define anchored_substr substrs->data[0].substr
#define anchored_offset substrs->data[0].min_offset
#define float_substr substrs->data[1].substr
#define float_min_offset substrs->data[1].min_offset
#define float_max_offset substrs->data[1].max_offset
#define check_substr substrs->data[2].substr
#define check_offset_min substrs->data[2].min_offset
#define check_offset_max substrs->data[2].max_offset
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d195 1
a195 1
#define ANYOF_ALNUM	 0	/* \w, PL_utf8_alnum, utf8::IsWord, ALNUM */
d197 1
a197 1
#define ANYOF_SPACE	 2	/* \s */
d201 1
a201 1
#define ANYOF_ALNUMC	 6	/* isalnum(3), utf8::IsAlnum, ALNUMC */
a220 4
#define ANYOF_PSXSPC	26	/* POSIX space: \s plus the vertical tab */
#define ANYOF_NPSXSPC	27
#define ANYOF_BLANK	28	/* GNU extension: space and tab */
#define ANYOF_NBLANK	29
d222 1
a222 1
#define ANYOF_MAX	32
d271 14
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a1 6
 *
 *    Copyright (c) 1997-2002, Larry Wall
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
d91 1
a91 1
#define ANYOF_CLASSBITMAP_SIZE	 4	/* up to 32 (8*4) named classes */
d97 1
a97 2
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];	/* only compile-time */
d100 2
a101 2
struct regnode_charclass_class {	/* has [[:blah:]] classes */
    U8	flags;				/* should have ANYOF_CLASS here */
d104 2
a105 3
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];		/* both compile-time */
    char classflags[ANYOF_CLASSBITMAP_SIZE];	/* and run-time */
a132 4
#undef ARG
#undef ARG1
#undef ARG2

a139 3
#undef NEXT_OFF
#undef NODE_ALIGN

a151 5
#undef OP
#undef OPERAND
#undef MASK
#undef STRING

a159 5
#undef NODE_ALIGN
#undef ARG_LOC
#undef NEXTOPER
#undef PREVOPER

d179 1
a179 1
#define SIZE_ONLY (RExC_emit == &PL_regdummy)
d183 4
a186 4
#define ANYOF_CLASS		0x08	/* has [[:blah:]] classes */
#define ANYOF_INVERT		0x04
#define ANYOF_FOLD		0x02
#define ANYOF_LOCALE		0x01
d189 1
a189 13
#define ANYOF_EOS		0x10		/* Can match an empty string too */

/* There is a character or a range past 0xff */
#define ANYOF_UNICODE		0x20
#define ANYOF_UNICODE_ALL	0x40	/* Can match any char past 0xff */

/* size of node is large (includes class pointer) */
#define ANYOF_LARGE 		0x80

/* Are there any runtime flags on in this node? */
#define ANYOF_RUNTIME(s)	(ANYOF_FLAGS(s) & 0x0f)

#define ANYOF_FLAGS_ALL		0xff
d223 1
a223 1
#define ANYOF_BLANK	28	/* GNU extension: space and tab: non-vertical space */
d241 1
a258 8
#define ANYOF_BITMAP_SETALL(p)		\
	memset (ANYOF_BITMAP(p), 255, ANYOF_BITMAP_SIZE)
#define ANYOF_BITMAP_CLEARALL(p)	\
	Zero (ANYOF_BITMAP(p), ANYOF_BITMAP_SIZE)
/* Check that all 256 bits are all set.  Used in S_cl_is_anything()  */
#define ANYOF_BITMAP_TESTALLSET(p)	\
	memEQ (ANYOF_BITMAP(p), "\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377\377", ANYOF_BITMAP_SIZE)

d278 4
a281 6
#define REG_SEEN_ZERO_LEN	 1
#define REG_SEEN_LOOKBEHIND	 2
#define REG_SEEN_GPOS		 4
#define REG_SEEN_EVAL		 8
#define REG_SEEN_CANY		16
#define REG_SEEN_SANY		REG_SEEN_CANY /* src bckwrd cmpt */
d303 6
a308 8
    REG_ANY,	SANY,	CANY,
    ANYOF,
    ALNUM,	ALNUML,
    NALNUM,	NALNUML,
    SPACE,	SPACEL,
    NSPACE,	NSPACEL,
    DIGIT,	NDIGIT,
    0
a319 12
/* .what is a character array with one character for each member of .data
 * The character describes the function of the corresponding .data item:
 *   f - start-class data for regstclass optimization  
 *   n - Root of op tree for (?{EVAL}) item
 *   o - Start op for (?{EVAL}) item
 *   p - Pad for (?{EVAL} item
 *   s - swash for unicode-style character class, and the multicharacter
 *       strings resulting from casefolding the single-character entries
 *       in the character class
 * 20010712 mjd@@plover.com
 * (Remember to update re_dup() and pregfree() if you add any items.)
 */
d329 1
a329 2
    SV *substr;		/* non-utf8 variant */
    SV *utf8_substr;	/* utf8 variant */
a336 1
#define anchored_utf8 substrs->data[0].utf8_substr
a338 1
#define float_utf8 substrs->data[1].utf8_substr
a341 1
#define check_utf8 substrs->data[2].utf8_substr
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2005 by Larry Wall and others
d156 9
a164 3
#define NEXT_OFF(p) ((p)->next_off)
#define NODE_ALIGN(node)
#define NODE_ALIGN_FILL(node) ((node)->flags = 0xde) /* deadbeef */
d311 1
d313 1
a313 1
#  define UCHARAT(p)	((int)*(const U8*)(p))
d315 1
a315 1
#  define UCHARAT(p)	((int)*(p)&CHARMASK)
d317 3
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2005, 2006, 2007, by Larry Wall and others
a9 1
#include "regcharclass.h"
a12 25

/* Convert branch sequences to more efficient trie ops? */
#define PERL_ENABLE_TRIE_OPTIMISATION 1

/* Be really agressive about optimising patterns with trie sequences? */
#define PERL_ENABLE_EXTENDED_TRIE_OPTIMISATION 1

/* Should the optimiser take positive assertions into account? */
#define PERL_ENABLE_POSITIVE_ASSERTION_STUDY 0

/* Not for production use: */
#define PERL_ENABLE_EXPERIMENTAL_REGEX_OPTIMISATIONS 0

/* Activate offsets code - set to if 1 to enable */
#ifdef DEBUGGING
#define RE_TRACK_PATTERN_OFFSETS
#endif

/* Unless the next line is uncommented it is illegal to combine lazy 
   matching with possessive matching. Frankly it doesn't make much sense 
   to allow it as X*?+ matches nothing, X+?+ matches a single char only, 
   and X{min,max}?+ matches min times only.
 */
/* #define REG_ALLOW_MINMOD_SUSPEND */

d18 1
a18 1
 * regstart	sv that must begin a match; NULL if none obvious
d56 1
a56 2
 * to the thing following the set of BRANCHes.)  The opcodes are defined
 * in regnodes.h which is generated from regcomp.sym by regcomp.pl.
a74 43
/* This is the stuff that used to live in regexp.h that was truly
   private to the engine itself. It now lives here. */



 typedef struct regexp_internal {
        int name_list_idx;	/* Optional data index of an array of paren names */
        union {
	    U32 *offsets;           /* offset annotations 20001228 MJD
                                       data about mapping the program to the
                                       string -
                                       offsets[0] is proglen when this is used
                                       */
            U32 proglen;
        } u;

        regnode *regstclass;    /* Optional startclass as identified or constructed
                                   by the optimiser */
        struct reg_data *data;	/* Additional miscellaneous data used by the program.
                                   Used to make it easier to clone and free arbitrary
                                   data that the regops need. Often the ARG field of
                                   a regop is an index into this structure */
	regnode program[1];	/* Unwarranted chumminess with compiler. */
} regexp_internal;

#define RXi_SET(x,y) (x)->pprivate = (void*)(y)   
#define RXi_GET(x)   ((regexp_internal *)((x)->pprivate))
#define RXi_GET_DECL(r,ri) regexp_internal *ri = RXi_GET(r)
/*
 * Flags stored in regexp->intflags
 * These are used only internally to the regexp engine
 *
 * See regexp.h for flags used externally to the regexp engine
 */
#define PREGf_SKIP		0x00000001
#define PREGf_IMPLICIT		0x00000002 /* Converted .* to ^.* */
#define PREGf_NAUGHTY		0x00000004 /* how exponential is this pattern? */
#define PREGf_VERBARG_SEEN	0x00000008
#define PREGf_CUTGROUP_SEEN	0x00000010


/* this is where the old regcomp.h started */

a81 2
/* Argument bearing node - workhorse, 
   arg1 is often for the data field */
a88 10
/* Similar to a regnode_1 but with an extra signed argument */
struct regnode_2L {
    U8	flags;
    U8  type;
    U16 next_off;
    U32 arg1;
    I32 arg2;
};

/* 'Two field' -- Two 16 bit unsigned args */
a96 1

d98 1
a98 1
#define ANYOF_CLASSBITMAP_SIZE	 4	/* up to 40 (8*5) named classes */
a99 1
/* also used by trie */
a148 2
#define ARG2L(p) ARG_VALUE(ARG2L_LOC(p))

a151 1
#define ARG2L_SET(p, val) ARG__SET(ARG2L_LOC(p), (val))
a183 2
#define ARG2L_LOC(p)	(((struct regnode_2L *)p)->arg2)

a259 8
/* pseudo classes, not stored in the class bitmap, but used as flags
   during compilation of char classes */

#define ANYOF_VERTWS	(ANYOF_MAX+1)
#define ANYOF_NVERTWS	(ANYOF_MAX+2)
#define ANYOF_HORIZWS	(ANYOF_MAX+3)
#define ANYOF_NHORIZWS	(ANYOF_MAX+4)

d285 1
a285 1
#define ANYOF_BITMAP_BYTE(p, c)	(ANYOF_BITMAP(p)[(((U8)(c)) >> 3) & 31])
a301 1

d313 5
a317 5
#define REG_SEEN_ZERO_LEN	0x00000001
#define REG_SEEN_LOOKBEHIND	0x00000002
#define REG_SEEN_GPOS		0x00000004
#define REG_SEEN_EVAL		0x00000008
#define REG_SEEN_CANY		0x00000010
a318 5
#define REG_SEEN_RECURSE        0x00000020
#define REG_TOP_LEVEL_BRANCHES  0x00000040
#define REG_SEEN_VERBARG        0x00000080
#define REG_SEEN_CUTGROUP       0x00000100
#define REG_SEEN_RUN_ON_COMMENT 0x00000200
a321 3
#ifdef PLUGGABLE_RE_EXTENSION
#include "re_nodes.h"
#else
a322 1
#endif
d329 2
a330 4
    BRANCH, BACK, STAR, PLUS, CURLY, CURLYX, REF, REFF, REFFL,
    WHILEM, CURLYM, CURLYN, BRANCHJ, IFTHEN, SUSPEND, CLUMP,
    NREF, NREFF, NREFFL,
    0
a346 2
    VERTWS,     NVERTWS,
    HORIZWS,    NHORIZWS,
a350 24
#ifndef PLUGGABLE_RE_EXTENSION
#ifndef DOINIT
EXTCONST regexp_engine PL_core_reg_engine;
#else /* DOINIT */
EXTCONST regexp_engine PL_core_reg_engine = { 
        Perl_re_compile,
        Perl_regexec_flags,
        Perl_re_intuit_start,
        Perl_re_intuit_string, 
        Perl_regfree_internal,
        Perl_reg_numbered_buff_fetch,
        Perl_reg_numbered_buff_store,
        Perl_reg_numbered_buff_length,
        Perl_reg_named_buff,
        Perl_reg_named_buff_iter,
        Perl_reg_qr_package,
#if defined(USE_ITHREADS)        
        Perl_regdupe_internal
#endif        
};
#endif /* DOINIT */
#endif /* PLUGGABLE_RE_EXTENSION */


d353 5
d361 1
a361 1
 *   f - start-class data for regstclass optimization
d364 2
a365 2
 *   p - Pad for (?{EVAL}) item
 *   s - swash for Unicode-style character class, and the multicharacter
a367 5
 *   t - trie struct
 *   u - trie struct's widecharmap (a HV, so can't share, must dup)
 *       also used for revcharmap and words under DEBUGGING
 *   T - aho-trie struct
 *   S - sv for named capture lookup
d377 11
a387 2
/* Code in S_to_utf8_substr() and S_to_byte_substr() in regexec.c accesses
   anchored* and float* via array indexes 0 and 1.  */
a390 2
#define anchored_end_shift substrs->data[0].end_shift

a394 2
#define float_end_shift substrs->data[1].end_shift

a398 290
#define check_end_shift substrs->data[2].end_shift



/* trie related stuff */

/* a transition record for the state machine. the
   check field determines which state "owns" the
   transition. the char the transition is for is
   determined by offset from the owning states base
   field.  the next field determines which state
   is to be transitioned to if any.
*/
struct _reg_trie_trans {
  U32 next;
  U32 check;
};

/* a transition list element for the list based representation */
struct _reg_trie_trans_list_elem {
    U16 forid;
    U32 newstate;
};
typedef struct _reg_trie_trans_list_elem reg_trie_trans_le;

/* a state for compressed nodes. base is an offset
  into an array of reg_trie_trans array. If wordnum is
  nonzero the state is accepting. if base is zero then
  the state has no children (and will be accepting)
*/
struct _reg_trie_state {
  U16 wordnum;
  union {
    U32                base;
    reg_trie_trans_le* list;
  } trans;
};



typedef struct _reg_trie_state    reg_trie_state;
typedef struct _reg_trie_trans    reg_trie_trans;


/* anything in here that needs to be freed later
   should be dealt with in pregfree.
   refcount is first in both this and _reg_ac_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_trie_data {
    U32             refcount;        /* number of times this trie is referenced */
    U32             lasttrans;       /* last valid transition element */
    U16             *charmap;        /* byte to charid lookup array */
    reg_trie_state  *states;         /* state data */
    reg_trie_trans  *trans;          /* array of transition elements */
    char            *bitmap;         /* stclass bitmap */
    U32             *wordlen;        /* array of lengths of words */
    U16 	    *jump;           /* optional 1 indexed array of offsets before tail 
                                        for the node following a given word. */
    U16	            *nextword;       /* optional 1 indexed array to support linked list
                                        of duplicate wordnums */
    U16             uniquecharcount; /* unique chars in trie (width of trans table) */
    U32             startstate;      /* initial state - used for common prefix optimisation */
    STRLEN          minlen;          /* minimum length of words in trie - build/opt only? */
    STRLEN          maxlen;          /* maximum length of words in trie - build/opt only? */
    U32             statecount;      /* Build only - number of states in the states array 
                                        (including the unused zero state) */
    U32             wordcount;       /* Build only */
#ifdef DEBUGGING
    STRLEN          charcount;       /* Build only */
#endif
};
/* There is one (3 under DEBUGGING) pointers that logically belong in this
   structure, but are held outside as they need duplication on thread cloning,
   whereas the rest of the structure can be read only:
    HV              *widecharmap;    code points > 255 to charid
#ifdef DEBUGGING
    AV              *words;          Array of words contained in trie, for dumping
    AV              *revcharmap;     Map of each charid back to its character representation
#endif
*/

#define TRIE_WORDS_OFFSET 2

typedef struct _reg_trie_data reg_trie_data;

/* refcount is first in both this and _reg_trie_data to allow a space
   optimisation in Perl_regdupe.  */
struct _reg_ac_data {
    U32              refcount;
    U32              trie;
    U32              *fail;
    reg_trie_state   *states;
};
typedef struct _reg_ac_data reg_ac_data;

/* ANY_BIT doesnt use the structure, so we can borrow it here.
   This is simpler than refactoring all of it as wed end up with
   three different sets... */

#define TRIE_BITMAP(p)		(((reg_trie_data *)(p))->bitmap)
#define TRIE_BITMAP_BYTE(p, c)	(TRIE_BITMAP(p)[(((U8)(c)) >> 3) & 31])
#define TRIE_BITMAP_SET(p, c)	(TRIE_BITMAP_BYTE(p, c) |=  ANYOF_BIT((U8)c))
#define TRIE_BITMAP_CLEAR(p,c)	(TRIE_BITMAP_BYTE(p, c) &= ~ANYOF_BIT((U8)c))
#define TRIE_BITMAP_TEST(p, c)	(TRIE_BITMAP_BYTE(p, c) &   ANYOF_BIT((U8)c))

#define IS_ANYOF_TRIE(op) ((op)==TRIEC || (op)==AHOCORASICKC)
#define IS_TRIE_AC(op) ((op)>=AHOCORASICK)


#define BITMAP_BYTE(p, c)	(((U8*)p)[(((U8)(c)) >> 3) & 31])
#define BITMAP_TEST(p, c)	(BITMAP_BYTE(p, c) &   ANYOF_BIT((U8)c))

/* these defines assume uniquecharcount is the correct variable, and state may be evaluated twice */
#define TRIE_NODENUM(state) (((state)-1)/(trie->uniquecharcount)+1)
#define SAFE_TRIE_NODENUM(state) ((state) ? (((state)-1)/(trie->uniquecharcount)+1) : (state))
#define TRIE_NODEIDX(state) ((state) ? (((state)-1)*(trie->uniquecharcount)+1) : (state))

#ifdef DEBUGGING
#define TRIE_CHARCOUNT(trie) ((trie)->charcount)
#else
#define TRIE_CHARCOUNT(trie) (trie_charcount)
#endif

#define RE_TRIE_MAXBUF_INIT 65536
#define RE_TRIE_MAXBUF_NAME "\022E_TRIE_MAXBUF"
#define RE_DEBUG_FLAGS "\022E_DEBUG_FLAGS"

/*

RE_DEBUG_FLAGS is used to control what debug output is emitted
its divided into three groups of options, some of which interact.
The three groups are: Compile, Execute, Extra. There is room for a
further group, as currently only the low three bytes are used.

    Compile Options:
    
    PARSE
    PEEP
    TRIE
    PROGRAM
    OFFSETS

    Execute Options:

    INTUIT
    MATCH
    TRIE

    Extra Options

    TRIE
    OFFSETS

If you modify any of these make sure you make corresponding changes to
re.pm, especially to the documentation.

*/


/* Compile */
#define RE_DEBUG_COMPILE_MASK      0x0000FF
#define RE_DEBUG_COMPILE_PARSE     0x000001
#define RE_DEBUG_COMPILE_OPTIMISE  0x000002
#define RE_DEBUG_COMPILE_TRIE      0x000004
#define RE_DEBUG_COMPILE_DUMP      0x000008
#define RE_DEBUG_COMPILE_FLAGS     0x000010

/* Execute */
#define RE_DEBUG_EXECUTE_MASK      0x00FF00
#define RE_DEBUG_EXECUTE_INTUIT    0x000100
#define RE_DEBUG_EXECUTE_MATCH     0x000200
#define RE_DEBUG_EXECUTE_TRIE      0x000400

/* Extra */
#define RE_DEBUG_EXTRA_MASK        0xFF0000
#define RE_DEBUG_EXTRA_TRIE        0x010000
#define RE_DEBUG_EXTRA_OFFSETS     0x020000
#define RE_DEBUG_EXTRA_OFFDEBUG    0x040000
#define RE_DEBUG_EXTRA_STATE       0x080000
#define RE_DEBUG_EXTRA_OPTIMISE    0x100000
#define RE_DEBUG_EXTRA_BUFFERS     0x400000
/* combined */
#define RE_DEBUG_EXTRA_STACK       0x280000

#define RE_DEBUG_FLAG(x) (re_debug_flags & x)
/* Compile */
#define DEBUG_COMPILE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_MASK) x  )
#define DEBUG_PARSE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_PARSE) x  )
#define DEBUG_OPTIMISE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_OPTIMISE) x  )
#define DEBUG_PARSE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_PARSE) x  )
#define DEBUG_DUMP_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_DUMP) x  )
#define DEBUG_TRIE_COMPILE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_TRIE) x )
#define DEBUG_FLAGS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_COMPILE_FLAGS) x )
/* Execute */
#define DEBUG_EXECUTE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_MASK) x  )
#define DEBUG_INTUIT_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_INTUIT) x  )
#define DEBUG_MATCH_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_MATCH) x  )
#define DEBUG_TRIE_EXECUTE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXECUTE_TRIE) x )

/* Extra */
#define DEBUG_EXTRA_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_MASK) x  )
#define DEBUG_OFFSETS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_OFFSETS) x  )
#define DEBUG_STATE_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_STATE) x )
#define DEBUG_STACK_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_STACK) x )
#define DEBUG_BUFFERS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_BUFFERS) x )

#define DEBUG_OPTIMISE_MORE_r(x) DEBUG_r( \
    if ((RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE) == \
         (re_debug_flags & (RE_DEBUG_EXTRA_OPTIMISE|RE_DEBUG_COMPILE_OPTIMISE)) ) x )
#define MJD_OFFSET_DEBUG(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_OFFDEBUG) \
        Perl_warn_nocontext x )
#define DEBUG_TRIE_COMPILE_MORE_r(x) DEBUG_TRIE_COMPILE_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_TRIE) x )
#define DEBUG_TRIE_EXECUTE_MORE_r(x) DEBUG_TRIE_EXECUTE_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_TRIE) x )

#define DEBUG_TRIE_r(x) DEBUG_r( \
    if (re_debug_flags & (RE_DEBUG_COMPILE_TRIE \
        | RE_DEBUG_EXECUTE_TRIE )) x )

/* initialization */
/* get_sv() can return NULL during global destruction. */
#define GET_RE_DEBUG_FLAGS DEBUG_r({ \
        SV * re_debug_flags_sv = NULL; \
        re_debug_flags_sv = get_sv(RE_DEBUG_FLAGS, 1); \
        if (re_debug_flags_sv) { \
            if (!SvIOK(re_debug_flags_sv)) \
                sv_setuv(re_debug_flags_sv, RE_DEBUG_COMPILE_DUMP | RE_DEBUG_EXECUTE_MASK ); \
            re_debug_flags=SvIV(re_debug_flags_sv); \
        }\
})

#ifdef DEBUGGING

#define GET_RE_DEBUG_FLAGS_DECL IV re_debug_flags = 0; GET_RE_DEBUG_FLAGS;

#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2) \
    const char * const rpv =                          \
        pv_pretty((dsv), (pv), (l), (m), \
            PL_colors[(c1)],PL_colors[(c2)], \
            PERL_PV_ESCAPE_RE |((isuni) ? PERL_PV_ESCAPE_UNI : 0) );         \
    const int rlen = SvCUR(dsv)

#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m) \
    const char * const rpv =                          \
        pv_pretty((dsv), (SvPV_nolen_const(sv)), (SvCUR(sv)), (m), \
            PL_colors[(c1)],PL_colors[(c2)], \
            PERL_PV_ESCAPE_RE |((isuni) ? PERL_PV_ESCAPE_UNI : 0) )

#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)                    \
    const char * const rpv =                                       \
        pv_pretty((dsv), (pv), (l), (m), \
            PL_colors[0], PL_colors[1], \
            ( PERL_PV_PRETTY_QUOTE | PERL_PV_ESCAPE_RE | PERL_PV_PRETTY_ELLIPSES | \
              ((isuni) ? PERL_PV_ESCAPE_UNI : 0))                  \
        )

#define RE_SV_DUMPLEN(ItEm) (SvCUR(ItEm) - (SvTAIL(ItEm)!=0))
#define RE_SV_TAIL(ItEm) (SvTAIL(ItEm) ? "$" : "")
    
#else /* if not DEBUGGING */

#define GET_RE_DEBUG_FLAGS_DECL
#define RE_PV_COLOR_DECL(rpv,rlen,isuni,dsv,pv,l,m,c1,c2)
#define RE_SV_ESCAPE(rpv,isuni,dsv,sv,m)
#define RE_PV_QUOTED_DECL(rpv,isuni,dsv,pv,l,m)
#define RE_SV_DUMPLEN(ItEm)
#define RE_SV_TAIL(ItEm)

#endif /* DEBUG RELATED DEFINES */



@


1.1.1.9
log
@import perl 5.10.1
@
text
@a20 18
/* Use old style unicode mappings for perl and posix character classes
 *
 * NOTE: Enabling this essentially breaks character class matching against unicode 
 * strings, so that POSIX char classes match when they shouldn't, and \d matches 
 * way more than 10 characters, and sometimes a charclass and its complement either
 * both match or neither match.
 * NOTE: Disabling this will cause various backwards compatibility issues to rear 
 * their head, and tests to fail. However it will make the charclass behaviour 
 * consistant regardless of internal string type, and make character class inversions
 * consistant. The tests that fail in the regex engine are basically broken tests.
 *
 * Personally I think 5.12 should disable this for sure. Its a bit more debatable for
 * 5.10, so for now im leaving it enabled.
 *
 * -demerphq
 */
#define PERL_LEGACY_UNICODE_CHARCLASS_MAPPINGS 1

d320 1
a320 1
#define ANYOF_DIGIT	 4	/* \d */
d322 1
a322 1
#define ANYOF_ALNUMC	 6	/* [[:alnum:]] isalnum(3), utf8::IsAlnum, ALNUMC */
d531 1
a531 4
#define RX_ANCHORED_SUBSTR(rx)	((rx)->anchored_substr)
#define RX_ANCHORED_UTF8(rx)	((rx)->anchored_utf8)
#define RX_FLOAT_SUBSTR(rx)	((rx)->float_substr)
#define RX_FLOAT_UTF8(rx)	((rx)->float_utf8)
d817 2
a818 9
/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@a33 1
 * XXX: It is now enabled for 5.11/5.12
d199 1
a199 1
#define ANYOF_CLASSBITMAP_SIZE	 4	/* up to 32 (8*4) named classes */
d549 4
a552 4
#define RX_ANCHORED_SUBSTR(rx)	(((struct regexp *)SvANY(rx))->anchored_substr)
#define RX_ANCHORED_UTF8(rx)	(((struct regexp *)SvANY(rx))->anchored_utf8)
#define RX_FLOAT_SUBSTR(rx)	(((struct regexp *)SvANY(rx))->float_substr)
#define RX_FLOAT_UTF8(rx)	(((struct regexp *)SvANY(rx))->float_utf8)
a730 1
#define RE_DEBUG_EXTRA_GPOS        0x800000
a785 2
#define DEBUG_GPOS_r(x) DEBUG_r( \
    if (re_debug_flags & RE_DEBUG_EXTRA_GPOS) x )
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d18 1
a18 1
/* Be really aggressive about optimising patterns with trie sequences? */
d21 19
d207 1
a207 1
    U32 arg1;				/* used as ptr in S_regclass */
d211 2
a212 3
/* has runtime (locale) \d, \w, ..., [:posix:] classes */
struct regnode_charclass_class {
    U8	flags;				/* ANYOF_CLASS bit must go here */
d215 1
a215 1
    U32 arg1;					/* used as ptr in S_regclass */
a273 3
#define FLAGS(p)	((p)->flags)	/* Caution: Doesn't apply to all      \
					   regnode types.  For some, it's the \
					   character set of the regnode */
d309 13
a321 38
/* If the bitmap doesn't fully represent what this ANYOF node can match, the
 * ARG is set to this special value (since 0, 1, ... are legal, but will never
 * reach this high). */
#define ANYOF_NONBITMAP_EMPTY	((U32) -1)

/* The information used to be stored as as combination of the ANYOF_UTF8 and
 * ANYOF_NONBITMAP_NON_UTF8 bits in the flags field, but was moved out of there
 * to free up a bit for other uses.  This tries to hide the change from
 * existing code as much as possible.  Now, the data structure that goes in ARG
 * is not allocated unless it is needed, and that is what is used to determine
 * if there is something outside the bitmap.  The code now assumes that if
 * that structure exists, that any UTF-8 encoded string should be tried against
 * it, but a non-UTF8-encoded string will be tried only if the
 * ANYOF_NONBITMAP_NON_UTF8 bit is also set. */
#define ANYOF_NONBITMAP(node)	(ARG(node) != ANYOF_NONBITMAP_EMPTY)

/* Flags for node->flags of ANYOF.  These are in short supply, so some games
 * are done to share them, as described below.  If necessary, the ANYOF_LOCALE
 * and ANYOF_CLASS bits could be shared with a space penalty for locale nodes,
 * but this isn't quite so easy, as the optimizer also uses ANYOF_CLASS.
 * Another option would be to push them into new nodes.  E.g. there could be an
 * ANYOF_LOCALE node that would be in place of the flag of the same name.
 * Once the planned change to compile all the above-latin1 code points is done,
 * then the UNICODE_ALL bit can be freed up, with a small performance penalty.
 * If flags need to be added that are applicable to the synthetic start class
 * only, with some work, they could be put in the next-node field, or in an
 * unused bit of the classflags field. */

#define ANYOF_LOCALE		 0x01	    /* /l modifier */

/* The fold is calculated and stored in the bitmap where possible at compile
 * time.  However there are two cases where it isn't possible.  These share
 * this bit:  1) under locale, where the actual folding varies depending on
 * what the locale is at the time of execution; and 2) where the folding is
 * specified in a swash, not the bitmap, such as characters which aren't
 * specified in the bitmap, or properties that aren't looked at at compile time
 */
#define ANYOF_LOC_NONBITMAP_FOLD 0x02
d323 2
a324 1
#define ANYOF_INVERT		 0x04
d326 2
a327 29
/* Set if this is a struct regnode_charclass_class vs a regnode_charclass.  This
 * is used for runtime \d, \w, [:posix:], ..., which are used only in locale
 * and the optimizer's synthetic start class.  Non-locale \d, etc are resolved
 * at compile-time */
#define ANYOF_CLASS	 0x08
#define ANYOF_LARGE      ANYOF_CLASS    /* Same; name retained for back compat */

/* EOS, meaning that it can match an empty string too, is used for the
 * synthetic start class only. */
#define ANYOF_EOS		0x10

/* ? Is this node the synthetic start class (ssc).  This bit is shared with
 * ANYOF_EOS, as the latter is used only for the ssc, and then not used by
 * regexec.c.  And, the code is structured so that if it is set, the ssc is
 * not used, so it is guaranteed to be 0 for the ssc by the time regexec.c
 * gets executed, and 0 for a non-ssc ANYOF node, as it only ever gets set for
 * a potential ssc candidate.  Thus setting it to 1 after it has been
 * determined that the ssc will be used is not ambiguous */
#define ANYOF_IS_SYNTHETIC	ANYOF_EOS

/* Can match something outside the bitmap that isn't in utf8 */
#define ANYOF_NONBITMAP_NON_UTF8 0x20

/* Matches every code point 0x100 and above*/
#define ANYOF_UNICODE_ALL	0x40

/* Match all Latin1 characters that aren't ASCII when the target string is not
 * in utf8. */
#define ANYOF_NON_UTF8_LATIN1_ALL 0x80
a330 10
/* These are the flags that ANYOF_INVERT being set or not doesn't affect
 * whether they are operative or not.  e.g., the node still has LOCALE
 * regardless of being inverted; whereas ANYOF_UNICODE_ALL means something
 * different if inverted */
#define INVERSION_UNAFFECTED_FLAGS (ANYOF_LOCALE                        \
	                           |ANYOF_LOC_NONBITMAP_FOLD            \
	                           |ANYOF_CLASS                         \
	                           |ANYOF_EOS                           \
	                           |ANYOF_NONBITMAP_NON_UTF8)

a397 2
#define ANYOF_CLASS_SETALL(ret)		\
	memset (((struct regnode_charclass_class*)(ret))->classflags, 255, ANYOF_CLASSBITMAP_SIZE)
d411 1
a411 1
#define ANYOF_BITMAP_TESTALLSET(p)	/* Assumes sizeof(p) == 32 */     \
d416 1
a416 9

#if ANYOF_CLASSBITMAP_SIZE != 4
#   error ANYOF_CLASSBITMAP_SIZE is expected to be 4
#endif
#define ANYOF_CLASS_TEST_ANY_SET(p) ((ANYOF_FLAGS(p) & ANYOF_CLASS)         \
	&& memNE (((struct regnode_charclass_class*)(p))->classflags,	    \
		    "\0\0\0\0", ANYOF_CLASSBITMAP_SIZE))
/*#define ANYOF_CLASS_ADD_SKIP	(ANYOF_CLASS_SKIP - ANYOF_SKIP)
 * */
a440 1
#define REG_SEEN_EXACTF_SHARP_S 0x00000400
d450 31
a509 1
 *   a - AV for paren_name_list under DEBUGGING
a588 9
/* info per word; indexed by wordnum */
typedef struct {
    U16  prev;	/* previous word in acceptance chain; eg in
		 * zzz|abc|ab/ after matching the chars abc, the
		 * accepted word is #2, and the previous accepted
		 * word is #3 */
    U32 len;	/* how many chars long is this word? */
    U32 accept;	/* accept state for this word */
} reg_trie_wordinfo;
d606 1
d609 2
a610 1
    reg_trie_wordinfo *wordinfo;     /* array of info per word */
a614 1
    U32             prefixlen;       /* #chars in common prefix */
d646 1
a646 1
/* ANY_BIT doesn't use the structure, so we can borrow it here.
d792 1
a792 2
/* get_sv() can return NULL during global destruction.  re_debug_flags can get
 * clobbered by a longjmp, so must be initialized */
a794 1
        re_debug_flags = 0;            \
d805 1
a805 2
#define GET_RE_DEBUG_FLAGS_DECL VOL IV re_debug_flags \
	PERL_UNUSED_DECL = 0; GET_RE_DEBUG_FLAGS;
d811 1
a811 1
            PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII |((isuni) ? PERL_PV_ESCAPE_UNI : 0) );         \
d818 1
a818 1
            PERL_PV_ESCAPE_RE|PERL_PV_ESCAPE_NONASCII |((isuni) ? PERL_PV_ESCAPE_UNI : 0) )
d824 1
a824 1
            ( PERL_PV_PRETTY_QUOTE | PERL_PV_ESCAPE_RE | PERL_PV_ESCAPE_NONASCII | PERL_PV_PRETTY_ELLIPSES | \
@


1.1.1.12
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d12 3
a123 2
	struct reg_code_block *code_blocks;/* positions of literal (?{}) */
	int num_code_blocks;	/* size of code_blocks[] */
a140 1
#define PREGf_USE_RE_EVAL	0x00000020 /* compiled with "use re 'eval'" */
d181 1
d199 1
a199 1
    U32 classflags;	                        /* and run-time */
d310 11
a320 10
/* Flags for node->flags of ANYOF.  These are in short supply, but there is one
 * currently available.  If more than this are needed, the ANYOF_LOCALE and
 * ANYOF_CLASS bits could be shared, making a space penalty for all locale nodes.
 * Also, the UNICODE_ALL bit could be freed up by resorting to creating a swash
 * containing everything above 255.  This introduces a performance penalty.
 * Better would be to split it off into a separate node, which actually would
 * improve performance a bit by allowing regexec.c to test for a UTF-8
 * character being above 255 without having to call a function nor calculate
 * its code point value.  However, this solution might need to have a second
 * node type, ANYOF_SYNTHETIC_ABOVE_LATIN1_ALL */
d325 7
a331 4
 * time.  However under locale, the actual folding varies depending on
 * what the locale is at the time of execution, so it has to be deferred until
 * then */
#define ANYOF_LOC_FOLD           0x02
d338 16
a353 6
 * at compile-time.  Could be shared with ANYOF_LOCALE, forcing all locale
 * nodes to be large */
#define ANYOF_CLASS	         0x08
#define ANYOF_LARGE       ANYOF_CLASS   /* Same; name retained for back compat */

/* Unused: 0x10.  When using, be sure to change ANYOF_FLAGS_ALL below */
d365 1
a365 1
#define ANYOF_FLAGS_ALL		(0xff & ~0x10)
d372 1
a372 1
	                           |ANYOF_LOC_FOLD                      \
d374 1
d379 32
a410 1
/* 2n should be the normal one, paired with its complement at 2n+1 */
d412 1
a412 33
#define ANYOF_ALPHA    ((_CC_ALPHA) * 2)
#define ANYOF_NALPHA   ((ANYOF_ALPHA) + 1)
#define ANYOF_ALPHANUMERIC   ((_CC_ALPHANUMERIC) * 2)    /* [[:alnum:]] isalnum(3), utf8::IsAlnum */
#define ANYOF_NALPHANUMERIC  ((ANYOF_ALPHANUMERIC) + 1)
#define ANYOF_ASCII    ((_CC_ASCII) * 2)
#define ANYOF_NASCII   ((ANYOF_ASCII) + 1)
#define ANYOF_BLANK    ((_CC_BLANK) * 2)     /* GNU extension: space and tab: non-vertical space */
#define ANYOF_NBLANK   ((ANYOF_BLANK) + 1)
#define ANYOF_CASED    ((_CC_CASED) * 2)    /* Pseudo class for [:lower:] or
                                               [:upper:] under /i */
#define ANYOF_NCASED   ((ANYOF_CASED) + 1)
#define ANYOF_CNTRL    ((_CC_CNTRL) * 2)
#define ANYOF_NCNTRL   ((ANYOF_CNTRL) + 1)
#define ANYOF_DIGIT    ((_CC_DIGIT) * 2)     /* \d */
#define ANYOF_NDIGIT   ((ANYOF_DIGIT) + 1)
#define ANYOF_GRAPH    ((_CC_GRAPH) * 2)
#define ANYOF_NGRAPH   ((ANYOF_GRAPH) + 1)
#define ANYOF_LOWER    ((_CC_LOWER) * 2)
#define ANYOF_NLOWER   ((ANYOF_LOWER) + 1)
#define ANYOF_PRINT    ((_CC_PRINT) * 2)
#define ANYOF_NPRINT   ((ANYOF_PRINT) + 1)
#define ANYOF_PSXSPC   ((_CC_PSXSPC) * 2)    /* POSIX space: \s plus the vertical tab */
#define ANYOF_NPSXSPC  ((ANYOF_PSXSPC) + 1)
#define ANYOF_PUNCT    ((_CC_PUNCT) * 2)
#define ANYOF_NPUNCT   ((ANYOF_PUNCT) + 1)
#define ANYOF_SPACE    ((_CC_SPACE) * 2)     /* \s */
#define ANYOF_NSPACE   ((ANYOF_SPACE) + 1)
#define ANYOF_UPPER    ((_CC_UPPER) * 2)
#define ANYOF_NUPPER   ((ANYOF_UPPER) + 1)
#define ANYOF_WORDCHAR ((_CC_WORDCHAR) * 2)  /* \w, PL_utf8_alnum, utf8::IsWord, ALNUM */
#define ANYOF_NWORDCHAR   ((ANYOF_WORDCHAR) + 1)
#define ANYOF_XDIGIT   ((_CC_XDIGIT) * 2)
#define ANYOF_NXDIGIT  ((ANYOF_XDIGIT) + 1)
d414 1
a414 1
/* pseudo classes below this, not stored in the class bitmap, but used as flags
d417 4
a420 22
#define ANYOF_VERTWS    ((_CC_VERTSPACE) * 2)
#define ANYOF_NVERTWS   ((ANYOF_VERTWS)+1)

/* It is best if this is the last one, as all above it are stored as bits in a
 * bitmap, and it isn't part of that bitmap */
#if _CC_VERTSPACE != _HIGHEST_REGCOMP_DOT_H_SYNC
#   error Problem with handy.h _HIGHEST_REGCOMP_DOT_H_SYNC #define
#endif

#define ANYOF_MAX      (ANYOF_VERTWS) /* So upper loop limit is written:
                                       *       '< ANYOF_MAX'
                                       * Hence doesn't include VERTWS, as that
                                       * is a pseudo class */
#if (ANYOF_MAX > 32)   /* Must fit in 32-bit word */
#   error Problem with handy.h _CC_foo #defines
#endif

#define ANYOF_HORIZWS	((ANYOF_MAX)+2) /* = (ANYOF_NVERTWS + 1) */
#define ANYOF_NHORIZWS	((ANYOF_MAX)+3)

#define ANYOF_UNIPROP   ((ANYOF_MAX)+4)  /* Used to indicate a Unicode
                                            property: \p{} or \P{} */
a427 2
#define ANYOF_ALNUM ANYOF_WORDCHAR
#define ANYOF_NALNUM ANYOF_NWORDCHAR
d438 9
a446 5
#define ANYOF_CLASS_SET(p, c)	(((struct regnode_charclass_class*) (p))->classflags |= (1U << (c)))
#define ANYOF_CLASS_CLEAR(p, c)	(((struct regnode_charclass_class*) (p))->classflags &= ~ (1U <<(c)))
#define ANYOF_CLASS_TEST(p, c)	(((struct regnode_charclass_class*) (p))->classflags & (1U << (c)))

#define ANYOF_CLASS_ZERO(ret)	STMT_START { ((struct regnode_charclass_class*) (ret))->classflags = 0; } STMT_END
a447 6
/* Shifts a bit to get, eg. 0x4000_0000, then subtracts 1 to get 0x3FFF_FFFF */
#define ANYOF_CLASS_SETALL(ret) STMT_START { ((struct regnode_charclass_class*) (ret))->classflags = ((1U << ((ANYOF_MAX) - 1))) - 1; } STMT_END

#define ANYOF_CLASS_OR(source, dest) STMT_START { (dest)->classflags |= source->classflags ; } STMT_END

#define ANYOF_BITMAP_ZERO(ret)	Zero(((struct regnode_charclass*)(ret))->bitmap, ANYOF_BITMAP_SIZE, char)
d465 6
a470 3
#define ANYOF_CLASS_TEST_ANY_SET(p)                               \
        ((ANYOF_FLAGS(p) & ANYOF_CLASS)                           \
	 && (((struct regnode_charclass_class*)(p))->classflags))
d489 1
a489 1
/* spare */
d524 1
a524 1
        Perl_regdupe_internal,
a525 1
        Perl_re_op_compile
d538 3
a540 3
 *   l - start op for literal (?{EVAL}) item
 *   L - start op for literal (?{EVAL}) item, with separate CV (qr//)
 *   r - pointer to an embedded code-containing qr, e.g. /ab$qr/
d577 4
a580 4
#define RX_ANCHORED_SUBSTR(rx)	(ReANY(rx)->anchored_substr)
#define RX_ANCHORED_UTF8(rx)	(ReANY(rx)->anchored_utf8)
#define RX_FLOAT_SUBSTR(rx)	(ReANY(rx)->float_substr)
#define RX_FLOAT_UTF8(rx)	(ReANY(rx)->float_utf8)
d827 2
a828 1
/* get_sv() can return NULL during global destruction. */
d831 1
d842 2
a843 2
#define GET_RE_DEBUG_FLAGS_DECL VOL IV re_debug_flags  = 0; \
        PERL_UNUSED_VAR(re_debug_flags); GET_RE_DEBUG_FLAGS;
d884 1
a884 1
 * indent-tabs-mode: nil
d887 1
a887 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@d29 7
a134 3
#define RXp_INTFLAGS(rx)        ((rx)->intflags)
#define RX_INTFLAGS(prog)        RXp_INTFLAGS(ReANY(prog))

a140 10
/* these used to be extflags, but are now intflags */
#define PREGf_NOSCAN            0x00000040
#define PREGf_CANY_SEEN         0x00000080
#define PREGf_GPOS_SEEN         0x00000100
#define PREGf_GPOS_FLOAT        0x00000200

#define PREGf_ANCH_BOL          0x00000400
#define PREGf_ANCH_MBOL         0x00000800
#define PREGf_ANCH_SBOL         0x00001000
#define PREGf_ANCH_GPOS         0x00002000
a141 2
#define PREGf_ANCH              (PREGf_ANCH_SBOL | PREGf_ANCH_GPOS | \
                                 PREGf_ANCH_MBOL | PREGf_ANCH_BOL )
d180 1
a180 12
#define ANYOF_BITMAP_SIZE	(256 / 8)   /* 8 bits/Byte */

/* Note that these form structs which are supersets of the next smaller one, by
 * appending fields.  Alignment problems can occur if one of those optional
 * fields requires stricter alignment than the base struct.  And formal
 * parameters that can really be two or more of the structs should be
 * declared as the smallest one it could be.  See commit message for
 * 7dcac5f6a5195002b55c935ee1d67f67e1df280b.  Regnode allocation is done
 * without regard to alignment, and changing it to would also require changing
 * the code that inserts and deletes regnodes.  The basic single-argument
 * regnode has a U32, which is what reganode() allocates as a unit.  Therefore
 * no field can require stricter alignment than U32. */
d187 1
a187 1
    U32 arg1;
d193 1
a193 1
    U8	flags;				/* ANYOF_POSIXL bit must go here */
d196 1
a196 1
    U32 arg1;
a200 35
/* A synthetic start class (SSC); is a regnode_charclass_posixl_fold, plus an
 * extra SV*, used only during its construction and which is not used by
 * regexec.c.  Note that the 'next_off' field is unused, as the SSC stands
 * alone, so there is never a next node.  Also, there is no alignment issue,
 * becase these are declared or allocated as a complete unit so the compiler
 * takes care of alignment.  This is unlike the other regnodes which are
 * allocated in terms of multiples of a single-argument regnode.  SSC nodes can
 * have a pointer field because there is no alignment issue, and because it is
 * set to NULL after construction, before any cloning of the pattern */
struct regnode_ssc {
    U8	flags;				/* ANYOF_POSIXL bit must go here */
    U8  type;
    U16 next_off;
    U32 arg1;
    char bitmap[ANYOF_BITMAP_SIZE];	/* both compile-time */
    U32 classflags;	                /* and run-time */

    /* Auxiliary, only used during construction; NULL afterwards: list of code
     * points matched */
    SV* invlist;
};

/*  We take advantage of 'next_off' not otherwise being used in the SSC by
 *  actually using it: by setting it to 1.  This allows us to test and
 *  distinguish between an SSC and other ANYOF node types, as 'next_off' cannot
 *  otherwise be 1, because it is the offset to the next regnode expressed in
 *  units of regnodes.  Since an ANYOF node contains extra fields, it adds up
 *  to 12 regnode units on 32-bit systems, (hence the minimum this can be (if
 *  not 0) is 11 there.  Even if things get tightly packed on a 64-bit system,
 *  it still would be more than 1. */
#define set_ANYOF_SYNTHETIC(n) STMT_START{ OP(n) = ANYOF;              \
                                           NEXT_OFF(n) = 1;            \
                               } STMT_END
#define is_ANYOF_SYNTHETIC(n) (OP(n) == ANYOF && NEXT_OFF(n) == 1)

d291 1
a291 3
#define SIZE_ONLY (RExC_emit == (regnode *) & RExC_emit_dummy)
#define PASS1 SIZE_ONLY
#define PASS2 (! SIZE_ONLY)
d298 23
a320 26
/* Flags for node->flags of ANYOF.  These are in short supply, with none
 * currently available.  The ABOVE_LATIN1_ALL bit could be freed up
 * by resorting to creating a swash containing everything above 255.  This
 * introduces a performance penalty.  An option that wouldn't slow things down
 * would be to split one of the two LOC flags out into a separate
 * node, like what was done with ANYOF_NON_UTF8_NON_ASCII_ALL in commit
 * 34fdef848b1687b91892ba55e9e0c3430e0770f6 (but which was reverted because it
 * wasn't the best option available at the time), and using a LOC flag is
 * probably better than that commit anyway.  But it could be reinstated if we
 * need a bit.  The LOC flags are only for /l nodes; the reverted commit was
 * only for /d, so there are no combinatorial issues.  The LOC flag to use is
 * probably the POSIXL one.
 * Several flags are not used in synthetic start class (SSC) nodes, so could be
 * shared should new flags be needed for SSCs, like ANYOF_EMPTY_STRING now. */

/* regexec.c is expecting this to be in the low bit */
#define ANYOF_INVERT		 0x01

/* For the SSC node only, which cannot be inverted, so is shared with that bit.
 * This means "Does this SSC match an empty string?"  This is used only during
 * regex compilation. */
#define ANYOF_EMPTY_STRING       ANYOF_INVERT

/* Are there things that will match only if the target string is encoded in
 * UTF-8?  (This is not set if ANYOF_AOVE_LATIN1_ALL is set) */
#define ANYOF_UTF8               0x02
d326 3
a328 1
#define ANYOF_LOC_FOLD           0x04
d330 1
a330 1
/* Set if this is a regnode_charclass_posixl vs a regnode_charclass.  This
d333 4
a336 4
 * at compile-time */
#define ANYOF_POSIXL	         0x08
#define ANYOF_CLASS	         ANYOF_POSIXL
#define ANYOF_LARGE              ANYOF_POSIXL
d338 1
a338 3
/* Should we raise a warning if matching against an above-Unicode code point?
 * */
#define ANYOF_WARN_SUPER        0x10
d344 1
a344 2
#define ANYOF_ABOVE_LATIN1_ALL	 0x40
#define ANYOF_UNICODE_ALL	 ANYOF_ABOVE_LATIN1_ALL
d348 1
a348 3
#define ANYOF_NON_UTF8_NON_ASCII_ALL 0x80

#define ANYOF_FLAGS_ALL		(0xff)
d350 1
a350 1
#define ANYOF_LOCALE_FLAGS (ANYOF_LOC_FOLD | ANYOF_POSIXL)
d352 8
a359 4
/* These are the flags that apply to both regular ANYOF nodes and synthetic
 * start class nodes during construction of the SSC.  During finalization of
 * the SSC, other of the flags could be added to it */
#define ANYOF_COMMON_FLAGS    (ANYOF_WARN_SUPER|ANYOF_UTF8)
d411 5
a415 7
#define ANYOF_POSIXL_MAX (ANYOF_VERTWS) /* So upper loop limit is written:
                                         *       '< ANYOF_MAX'
                                         * Hence doesn't include VERTWS, as that
                                         * is a pseudo class */
#define ANYOF_MAX      ANYOF_POSIXL_MAX

#if (ANYOF_POSIXL_MAX > 32)   /* Must fit in 32-bit word */
d419 2
a420 2
#define ANYOF_HORIZWS	((ANYOF_POSIXL_MAX)+2) /* = (ANYOF_NVERTWS + 1) */
#define ANYOF_NHORIZWS	((ANYOF_POSIXL_MAX)+3)
d422 2
a423 2
#define ANYOF_UNIPROP   ((ANYOF_POSIXL_MAX)+4)  /* Used to indicate a Unicode
                                                   property: \p{} or \P{} */
d437 1
a437 2
#define ANYOF_POSIXL_SIZE	(sizeof(regnode_charclass_posixl))
#define ANYOF_CLASS_SIZE	ANYOF_POSIXL_SIZE
d443 3
a445 8
#define ANYOF_POSIXL_SET(p, c)	(((regnode_charclass_posixl*) (p))->classflags |= (1U << (c)))
#define ANYOF_CLASS_SET(p, c)	ANYOF_POSIXL_SET((p), (c))

#define ANYOF_POSIXL_CLEAR(p, c) (((regnode_charclass_posixl*) (p))->classflags &= ~ (1U <<(c)))
#define ANYOF_CLASS_CLEAR(p, c)	ANYOF_POSIXL_CLEAR((p), (c))

#define ANYOF_POSIXL_TEST(p, c)	(((regnode_charclass_posixl*) (p))->classflags & (1U << (c)))
#define ANYOF_CLASS_TEST(p, c)	ANYOF_POSIXL_TEST((p), (c))
d447 1
a447 2
#define ANYOF_POSIXL_ZERO(ret)	STMT_START { ((regnode_charclass_posixl*) (ret))->classflags = 0; } STMT_END
#define ANYOF_CLASS_ZERO(ret)	ANYOF_POSIXL_ZERO(ret)
d450 1
a450 2
#define ANYOF_POSIXL_SETALL(ret) STMT_START { ((regnode_charclass_posixl*) (ret))->classflags = ((1U << ((ANYOF_POSIXL_MAX) - 1))) - 1; } STMT_END
#define ANYOF_CLASS_SETALL(ret) ANYOF_POSIXL_SETALL(ret)
d452 1
a452 22
#define ANYOF_POSIXL_TEST_ANY_SET(p)                               \
        ((ANYOF_FLAGS(p) & ANYOF_POSIXL)                           \
	 && (((regnode_charclass_posixl*)(p))->classflags))
#define ANYOF_CLASS_TEST_ANY_SET(p) ANYOF_POSIXL_TEST_ANY_SET(p)

/* Since an SSC always has this field, we don't have to test for that; nor do
 * we want to because the bit isn't set for SSC during its construction */
#define ANYOF_POSIXL_SSC_TEST_ANY_SET(p)                               \
                            cBOOL(((regnode_ssc*)(p))->classflags)
#define ANYOF_POSIXL_SSC_TEST_ALL_SET(p) /* Are all bits set? */       \
        (((regnode_ssc*) (p))->classflags                              \
                        == ((1U << ((ANYOF_POSIXL_MAX) - 1))) - 1)

#define ANYOF_POSIXL_TEST_ALL_SET(p)                                   \
        ((ANYOF_FLAGS(p) & ANYOF_POSIXL)                               \
         && ((regnode_charclass_posixl*) (p))->classflags              \
                        == ((1U << ((ANYOF_POSIXL_MAX) - 1))) - 1)

#define ANYOF_POSIXL_OR(source, dest) STMT_START { (dest)->classflags |= (source)->classflags ; } STMT_END
#define ANYOF_CLASS_OR(source, dest) ANYOF_POSIXL_OR((source), (dest))

#define ANYOF_POSIXL_AND(source, dest) STMT_START { (dest)->classflags &= (source)->classflags ; } STMT_END
d470 8
a477 2
#define ANYOF_POSIXL_SKIP	((ANYOF_POSIXL_SIZE - 1)/sizeof(regnode))
#define ANYOF_CLASS_SKIP	ANYOF_POSIXL_SKIP
d490 3
a492 3
#define REG_ZERO_LEN_SEEN                   0x00000001
#define REG_LOOKBEHIND_SEEN                 0x00000002
#define REG_GPOS_SEEN                       0x00000004
d494 8
a501 10
#define REG_CANY_SEEN                       0x00000010
#define REG_RECURSE_SEEN                    0x00000020
#define REG_TOP_LEVEL_BRANCHES_SEEN         0x00000040
#define REG_VERBARG_SEEN                    0x00000080
#define REG_CUTGROUP_SEEN                   0x00000100
#define REG_RUN_ON_COMMENT_SEEN             0x00000200
#define REG_UNFOLDED_MULTI_SEEN             0x00000400
#define REG_GOSTART_SEEN                    0x00000800
#define REG_UNBOUNDED_QUANTIFIER_SEEN       0x00001000

@


