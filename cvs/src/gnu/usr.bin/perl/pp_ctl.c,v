head	1.19;
access;
symbols
	OPENBSD_6_2_BASE:1.19
	PERL_5_24_2:1.1.1.18
	OPENBSD_6_1:1.19.0.4
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.18.0.8
	OPENBSD_6_0_BASE:1.18
	OPENBSD_5_9:1.18.0.2
	OPENBSD_5_9_BASE:1.18
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	PERL_5_20_2:1.1.1.17
	OPENBSD_5_7:1.17.0.2
	OPENBSD_5_7_BASE:1.17
	PERL_5_20_1:1.1.1.16
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	PERL_5_18_2:1.1.1.15
	PERL:1.1.1
	OPENBSD_5_5:1.15.0.6
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.2
	OPENBSD_5_4_BASE:1.15
	PERL_5_16_3:1.1.1.14
	OPENBSD_5_3:1.14.0.10
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.8
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.4
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	PERL_5_12_2:1.1.1.13
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.19
date	2017.02.05.00.31.53;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	cxJ08BvJA9Pt2PTM;

1.18
date	2015.04.25.19.14.37;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	XRK22kO4se3v2i2I;

1.17
date	2014.11.17.20.56.48;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	QP75iYx42Uo7mMxO;

1.16
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.25.20.40.45;	author sthen;	state Exp;
branches;
next	1.14;

1.14
date	2010.09.24.15.06.42;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.35.58;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.22.58;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.08.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.00;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.22;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.18;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.55;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.04.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.49.10;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.47;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.47;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.44;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.17;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.49;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.12.53;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.45.45;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.16.31;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.47.37;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.08;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.37;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2010.09.24.14.48.28;	author millert;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2013.03.25.20.06.32;	author sthen;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.03.24.14.58.46;	author afresh1;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	2014.11.17.20.52.38;	author afresh1;	state Exp;
branches;
next	1.1.1.17;
commitid	B31cAbBIXiCqnL97;

1.1.1.17
date	2015.04.25.19.10.11;	author afresh1;	state Exp;
branches;
next	1.1.1.18;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.18
date	2017.08.14.13.45.28;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.19
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    pp_ctl.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 *      Now far ahead the Road has gone,
 *          And I must follow, if I can,
 *      Pursuing it with eager feet,
 *          Until it joins some larger way
 *      Where many paths and errands meet.
 *          And whither then?  I cannot say.
 *
 *     [Bilbo on p.35 of _The Lord of the Rings_, I/i: "A Long-Expected Party"]
 */

/* This file contains control-oriented pp ("push/pop") functions that
 * execute the opcodes that make up a perl program. A typical pp function
 * expects to find its arguments on the stack, and usually pushes its
 * results onto the stack, hence the 'pp' terminology. Each OP structure
 * contains a pointer to the relevant pp_foo() function.
 *
 * Control-oriented means things like pp_enteriter() and pp_next(), which
 * alter the flow of control of the program.
 */


#include "EXTERN.h"
#define PERL_IN_PP_CTL_C
#include "perl.h"

#define DOCATCH(o) ((CATCH_GET == TRUE) ? docatch(o) : (o))

#define dopoptosub(plop)	dopoptosub_at(cxstack, (plop))

PP(pp_wantarray)
{
    dSP;
    I32 cxix;
    const PERL_CONTEXT *cx;
    EXTEND(SP, 1);

    if (PL_op->op_private & OPpOFFBYONE) {
	if (!(cx = caller_cx(1,NULL))) RETPUSHUNDEF;
    }
    else {
      cxix = dopoptosub(cxstack_ix);
      if (cxix < 0)
	RETPUSHUNDEF;
      cx = &cxstack[cxix];
    }

    switch (cx->blk_gimme) {
    case G_ARRAY:
	RETPUSHYES;
    case G_SCALAR:
	RETPUSHNO;
    default:
	RETPUSHUNDEF;
    }
}

PP(pp_regcreset)
{
    TAINT_NOT;
    return NORMAL;
}

PP(pp_regcomp)
{
    dSP;
    PMOP *pm = (PMOP*)cLOGOP->op_other;
    SV **args;
    int nargs;
    REGEXP *re = NULL;
    REGEXP *new_re;
    const regexp_engine *eng;
    bool is_bare_re= FALSE;

    if (PL_op->op_flags & OPf_STACKED) {
	dMARK;
	nargs = SP - MARK;
	args  = ++MARK;
    }
    else {
	nargs = 1;
	args  = SP;
    }

    /* prevent recompiling under /o and ithreads. */
#if defined(USE_ITHREADS)
    if (pm->op_pmflags & PMf_KEEP && PM_GETRE(pm)) {
	SP = args-1;
	RETURN;
    }
#endif

    re = PM_GETRE(pm);
    assert (re != (REGEXP*) &PL_sv_undef);
    eng = re ? RX_ENGINE(re) : current_re_engine();

    /*
     In the below logic: these are basically the same - check if this regcomp is part of a split.

    (PL_op->op_pmflags & PMf_split )
    (PL_op->op_next->op_type == OP_PUSHRE)

    We could add a new mask for this and copy the PMf_split, if we did
    some bit definition fiddling first.

    For now we leave this
    */

    new_re = (eng->op_comp
		    ? eng->op_comp
		    : &Perl_re_op_compile
	    )(aTHX_ args, nargs, pm->op_code_list, eng, re,
		&is_bare_re,
                (pm->op_pmflags & RXf_PMf_FLAGCOPYMASK),
		pm->op_pmflags |
		    (PL_op->op_flags & OPf_SPECIAL ? PMf_USE_RE_EVAL : 0));

    if (pm->op_pmflags & PMf_HAS_CV)
	ReANY(new_re)->qr_anoncv
			= (CV*) SvREFCNT_inc(PAD_SV(PL_op->op_targ));

    if (is_bare_re) {
	REGEXP *tmp;
	/* The match's LHS's get-magic might need to access this op's regexp
	   (e.g. $' =~ /$re/ while foo; see bug 70764).  So we must call
	   get-magic now before we replace the regexp. Hopefully this hack can
	   be replaced with the approach described at
	   http://www.nntp.perl.org/group/perl.perl5.porters/2007/03/msg122415.html
	   some day. */
	if (pm->op_type == OP_MATCH) {
	    SV *lhs;
	    const bool was_tainted = TAINT_get;
	    if (pm->op_flags & OPf_STACKED)
		lhs = args[-1];
	    else if (pm->op_targ)
		lhs = PAD_SV(pm->op_targ);
	    else lhs = DEFSV;
	    SvGETMAGIC(lhs);
	    /* Restore the previous value of PL_tainted (which may have been
	       modified by get-magic), to avoid incorrectly setting the
	       RXf_TAINTED flag with RX_TAINT_on further down. */
	    TAINT_set(was_tainted);
#ifdef NO_TAINT_SUPPORT
            PERL_UNUSED_VAR(was_tainted);
#endif
	}
	tmp = reg_temp_copy(NULL, new_re);
	ReREFCNT_dec(new_re);
	new_re = tmp;
    }

    if (re != new_re) {
	ReREFCNT_dec(re);
	PM_SETRE(pm, new_re);
    }


    assert(TAINTING_get || !TAINT_get);
    if (TAINT_get) {
	SvTAINTED_on((SV*)new_re);
        RX_TAINT_on(new_re);
    }

#if !defined(USE_ITHREADS)
    /* can't change the optree at runtime either */
    /* PMf_KEEP is handled differently under threads to avoid these problems */
    if (!RX_PRELEN(PM_GETRE(pm)) && PL_curpm)
	pm = PL_curpm;
    if (pm->op_pmflags & PMf_KEEP) {
	pm->op_private &= ~OPpRUNTIME;	/* no point compiling again */
	cLOGOP->op_first->op_next = PL_op->op_next;
    }
#endif

    SP = args-1;
    RETURN;
}


PP(pp_substcont)
{
    dSP;
    PERL_CONTEXT *cx = CX_CUR();
    PMOP * const pm = (PMOP*) cLOGOP->op_other;
    SV * const dstr = cx->sb_dstr;
    char *s = cx->sb_s;
    char *m = cx->sb_m;
    char *orig = cx->sb_orig;
    REGEXP * const rx = cx->sb_rx;
    SV *nsv = NULL;
    REGEXP *old = PM_GETRE(pm);

    PERL_ASYNC_CHECK();

    if(old != rx) {
	if(old)
	    ReREFCNT_dec(old);
	PM_SETRE(pm,ReREFCNT_inc(rx));
    }

    rxres_restore(&cx->sb_rxres, rx);

    if (cx->sb_iters++) {
	const SSize_t saviters = cx->sb_iters;
	if (cx->sb_iters > cx->sb_maxiters)
	    DIE(aTHX_ "Substitution loop");

	SvGETMAGIC(TOPs); /* possibly clear taint on $1 etc: #67962 */

    	/* See "how taint works" above pp_subst() */
	if (SvTAINTED(TOPs))
	    cx->sb_rxtainted |= SUBST_TAINT_REPL;
	sv_catsv_nomg(dstr, POPs);
	if (CxONCE(cx) || s < orig ||
                !CALLREGEXEC(rx, s, cx->sb_strend, orig,
			     (s == m), cx->sb_targ, NULL,
                    (REXEC_IGNOREPOS|REXEC_NOT_FIRST|REXEC_FAIL_ON_UNDERFLOW)))
	{
	    SV *targ = cx->sb_targ;

	    assert(cx->sb_strend >= s);
	    if(cx->sb_strend > s) {
		 if (DO_UTF8(dstr) && !SvUTF8(targ))
		      sv_catpvn_nomg_utf8_upgrade(dstr, s, cx->sb_strend - s, nsv);
		 else
		      sv_catpvn_nomg(dstr, s, cx->sb_strend - s);
	    }
	    if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
		cx->sb_rxtainted |= SUBST_TAINT_PAT;

	    if (pm->op_pmflags & PMf_NONDESTRUCT) {
		PUSHs(dstr);
		/* From here on down we're using the copy, and leaving the
		   original untouched.  */
		targ = dstr;
	    }
	    else {
		SV_CHECK_THINKFIRST_COW_DROP(targ);
		if (isGV(targ)) Perl_croak_no_modify();
		SvPV_free(targ);
		SvPV_set(targ, SvPVX(dstr));
		SvCUR_set(targ, SvCUR(dstr));
		SvLEN_set(targ, SvLEN(dstr));
		if (DO_UTF8(dstr))
		    SvUTF8_on(targ);
		SvPV_set(dstr, NULL);

		PL_tainted = 0;
		mPUSHi(saviters - 1);

		(void)SvPOK_only_UTF8(targ);
	    }

	    /* update the taint state of various various variables in
	     * preparation for final exit.
	     * See "how taint works" above pp_subst() */
	    if (TAINTING_get) {
		if ((cx->sb_rxtainted & SUBST_TAINT_PAT) ||
		    ((cx->sb_rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
				    == (SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
		)
		    (RX_MATCH_TAINTED_on(rx)); /* taint $1 et al */

		if (!(cx->sb_rxtainted & SUBST_TAINT_BOOLRET)
		    && (cx->sb_rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_PAT))
		)
		    SvTAINTED_on(TOPs);  /* taint return value */
		/* needed for mg_set below */
		TAINT_set(
                    cBOOL(cx->sb_rxtainted &
			  (SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL))
                );
		SvTAINT(TARG);
	    }
	    /* PL_tainted must be correctly set for this mg_set */
	    SvSETMAGIC(TARG);
	    TAINT_NOT;

	    CX_LEAVE_SCOPE(cx);
	    CX_POPSUBST(cx);
            CX_POP(cx);

	    PERL_ASYNC_CHECK();
	    RETURNOP(pm->op_next);
	    NOT_REACHED; /* NOTREACHED */
	}
	cx->sb_iters = saviters;
    }
    if (RX_MATCH_COPIED(rx) && RX_SUBBEG(rx) != orig) {
	m = s;
	s = orig;
        assert(!RX_SUBOFFSET(rx));
	cx->sb_orig = orig = RX_SUBBEG(rx);
	s = orig + (m - s);
	cx->sb_strend = s + (cx->sb_strend - m);
    }
    cx->sb_m = m = RX_OFFS(rx)[0].start + orig;
    if (m > s) {
	if (DO_UTF8(dstr) && !SvUTF8(cx->sb_targ))
	    sv_catpvn_nomg_utf8_upgrade(dstr, s, m - s, nsv);
	else
	    sv_catpvn_nomg(dstr, s, m-s);
    }
    cx->sb_s = RX_OFFS(rx)[0].end + orig;
    { /* Update the pos() information. */
	SV * const sv
	    = (pm->op_pmflags & PMf_NONDESTRUCT) ? cx->sb_dstr : cx->sb_targ;
	MAGIC *mg;

        /* the string being matched against may no longer be a string,
         * e.g. $_=0; s/.../$_++/ge */

        if (!SvPOK(sv))
            SvPV_force_nomg_nolen(sv);

	if (!(mg = mg_find_mglob(sv))) {
	    mg = sv_magicext_mglob(sv);
	}
	MgBYTEPOS_set(mg, sv, SvPVX(sv), m - orig);
    }
    if (old != rx)
	(void)ReREFCNT_inc(rx);
    /* update the taint state of various various variables in preparation
     * for calling the code block.
     * See "how taint works" above pp_subst() */
    if (TAINTING_get) {
	if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
	    cx->sb_rxtainted |= SUBST_TAINT_PAT;

	if ((cx->sb_rxtainted & SUBST_TAINT_PAT) ||
	    ((cx->sb_rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
			    == (SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
	)
	    (RX_MATCH_TAINTED_on(rx)); /* taint $1 et al */

	if (cx->sb_iters > 1 && (cx->sb_rxtainted & 
			(SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL)))
	    SvTAINTED_on((pm->op_pmflags & PMf_NONDESTRUCT)
			 ? cx->sb_dstr : cx->sb_targ);
	TAINT_NOT;
    }
    rxres_save(&cx->sb_rxres, rx);
    PL_curpm = pm;
    RETURNOP(pm->op_pmstashstartu.op_pmreplstart);
}

void
Perl_rxres_save(pTHX_ void **rsp, REGEXP *rx)
{
    UV *p = (UV*)*rsp;
    U32 i;

    PERL_ARGS_ASSERT_RXRES_SAVE;
    PERL_UNUSED_CONTEXT;

    if (!p || p[1] < RX_NPARENS(rx)) {
#ifdef PERL_ANY_COW
	i = 7 + (RX_NPARENS(rx)+1) * 2;
#else
	i = 6 + (RX_NPARENS(rx)+1) * 2;
#endif
	if (!p)
	    Newx(p, i, UV);
	else
	    Renew(p, i, UV);
	*rsp = (void*)p;
    }

    /* what (if anything) to free on croak */
    *p++ = PTR2UV(RX_MATCH_COPIED(rx) ? RX_SUBBEG(rx) : NULL);
    RX_MATCH_COPIED_off(rx);
    *p++ = RX_NPARENS(rx);

#ifdef PERL_ANY_COW
    *p++ = PTR2UV(RX_SAVED_COPY(rx));
    RX_SAVED_COPY(rx) = NULL;
#endif

    *p++ = PTR2UV(RX_SUBBEG(rx));
    *p++ = (UV)RX_SUBLEN(rx);
    *p++ = (UV)RX_SUBOFFSET(rx);
    *p++ = (UV)RX_SUBCOFFSET(rx);
    for (i = 0; i <= RX_NPARENS(rx); ++i) {
	*p++ = (UV)RX_OFFS(rx)[i].start;
	*p++ = (UV)RX_OFFS(rx)[i].end;
    }
}

static void
S_rxres_restore(pTHX_ void **rsp, REGEXP *rx)
{
    UV *p = (UV*)*rsp;
    U32 i;

    PERL_ARGS_ASSERT_RXRES_RESTORE;
    PERL_UNUSED_CONTEXT;

    RX_MATCH_COPY_FREE(rx);
    RX_MATCH_COPIED_set(rx, *p);
    *p++ = 0;
    RX_NPARENS(rx) = *p++;

#ifdef PERL_ANY_COW
    if (RX_SAVED_COPY(rx))
	SvREFCNT_dec (RX_SAVED_COPY(rx));
    RX_SAVED_COPY(rx) = INT2PTR(SV*,*p);
    *p++ = 0;
#endif

    RX_SUBBEG(rx) = INT2PTR(char*,*p++);
    RX_SUBLEN(rx) = (I32)(*p++);
    RX_SUBOFFSET(rx) = (I32)*p++;
    RX_SUBCOFFSET(rx) = (I32)*p++;
    for (i = 0; i <= RX_NPARENS(rx); ++i) {
	RX_OFFS(rx)[i].start = (I32)(*p++);
	RX_OFFS(rx)[i].end = (I32)(*p++);
    }
}

static void
S_rxres_free(pTHX_ void **rsp)
{
    UV * const p = (UV*)*rsp;

    PERL_ARGS_ASSERT_RXRES_FREE;
    PERL_UNUSED_CONTEXT;

    if (p) {
	void *tmp = INT2PTR(char*,*p);
#ifdef PERL_POISON
#ifdef PERL_ANY_COW
	U32 i = 9 + p[1] * 2;
#else
	U32 i = 8 + p[1] * 2;
#endif
#endif

#ifdef PERL_ANY_COW
        SvREFCNT_dec (INT2PTR(SV*,p[2]));
#endif
#ifdef PERL_POISON
        PoisonFree(p, i, sizeof(UV));
#endif

	Safefree(tmp);
	Safefree(p);
	*rsp = NULL;
    }
}

#define FORM_NUM_BLANK (1<<30)
#define FORM_NUM_POINT (1<<29)

PP(pp_formline)
{
    dSP; dMARK; dORIGMARK;
    SV * const tmpForm = *++MARK;
    SV *formsv;		    /* contains text of original format */
    U32 *fpc;	    /* format ops program counter */
    char *t;	    /* current append position in target string */
    const char *f;	    /* current position in format string */
    I32 arg;
    SV *sv = NULL; /* current item */
    const char *item = NULL;/* string value of current item */
    I32 itemsize  = 0;	    /* length (chars) of item, possibly truncated */
    I32 itembytes = 0;	    /* as itemsize, but length in bytes */
    I32 fieldsize = 0;	    /* width of current field */
    I32 lines = 0;	    /* number of lines that have been output */
    bool chopspace = (strchr(PL_chopset, ' ') != NULL); /* does $: have space */
    const char *chophere = NULL; /* where to chop current item */
    STRLEN linemark = 0;    /* pos of start of line in output */
    NV value;
    bool gotsome = FALSE;   /* seen at least one non-blank item on this line */
    STRLEN len;             /* length of current sv */
    STRLEN linemax;	    /* estimate of output size in bytes */
    bool item_is_utf8 = FALSE;
    bool targ_is_utf8 = FALSE;
    const char *fmt;
    MAGIC *mg = NULL;
    U8 *source;		    /* source of bytes to append */
    STRLEN to_copy;	    /* how may bytes to append */
    char trans;		    /* what chars to translate */

    mg = doparseform(tmpForm);

    fpc = (U32*)mg->mg_ptr;
    /* the actual string the format was compiled from.
     * with overload etc, this may not match tmpForm */
    formsv = mg->mg_obj;


    SvPV_force(PL_formtarget, len);
    if (SvTAINTED(tmpForm) || SvTAINTED(formsv))
	SvTAINTED_on(PL_formtarget);
    if (DO_UTF8(PL_formtarget))
	targ_is_utf8 = TRUE;
    linemax = (SvCUR(formsv) * (IN_BYTES ? 1 : 3) + 1);
    t = SvGROW(PL_formtarget, len + linemax + 1);
    /* XXX from now onwards, SvCUR(PL_formtarget) is invalid */
    t += len;
    f = SvPV_const(formsv, len);

    for (;;) {
	DEBUG_f( {
	    const char *name = "???";
	    arg = -1;
	    switch (*fpc) {
	    case FF_LITERAL:	arg = fpc[1]; name = "LITERAL";	break;
	    case FF_BLANK:	arg = fpc[1]; name = "BLANK";	break;
	    case FF_SKIP:	arg = fpc[1]; name = "SKIP";	break;
	    case FF_FETCH:	arg = fpc[1]; name = "FETCH";	break;
	    case FF_DECIMAL:	arg = fpc[1]; name = "DECIMAL";	break;

	    case FF_CHECKNL:	name = "CHECKNL";	break;
	    case FF_CHECKCHOP:	name = "CHECKCHOP";	break;
	    case FF_SPACE:	name = "SPACE";		break;
	    case FF_HALFSPACE:	name = "HALFSPACE";	break;
	    case FF_ITEM:	name = "ITEM";		break;
	    case FF_CHOP:	name = "CHOP";		break;
	    case FF_LINEGLOB:	name = "LINEGLOB";	break;
	    case FF_NEWLINE:	name = "NEWLINE";	break;
	    case FF_MORE:	name = "MORE";		break;
	    case FF_LINEMARK:	name = "LINEMARK";	break;
	    case FF_END:	name = "END";		break;
	    case FF_0DECIMAL:	name = "0DECIMAL";	break;
	    case FF_LINESNGL:	name = "LINESNGL";	break;
	    }
	    if (arg >= 0)
		PerlIO_printf(Perl_debug_log, "%-16s%ld\n", name, (long) arg);
	    else
		PerlIO_printf(Perl_debug_log, "%-16s\n", name);
	} );
	switch (*fpc++) {
	case FF_LINEMARK: /* start (or end) of a line */
	    linemark = t - SvPVX(PL_formtarget);
	    lines++;
	    gotsome = FALSE;
	    break;

	case FF_LITERAL: /* append <arg> literal chars */
	    to_copy = *fpc++;
	    source = (U8 *)f;
	    f += to_copy;
	    trans = '~';
	    item_is_utf8 = targ_is_utf8 ? !!DO_UTF8(formsv) : !!SvUTF8(formsv);
	    goto append;

	case FF_SKIP: /* skip <arg> chars in format */
	    f += *fpc++;
	    break;

	case FF_FETCH: /* get next item and set field size to <arg> */
	    arg = *fpc++;
	    f += arg;
	    fieldsize = arg;

	    if (MARK < SP)
		sv = *++MARK;
	    else {
		sv = &PL_sv_no;
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "Not enough format arguments");
	    }
	    if (SvTAINTED(sv))
		SvTAINTED_on(PL_formtarget);
	    break;

	case FF_CHECKNL: /* find max len of item (up to \n) that fits field */
	    {
		const char *s = item = SvPV_const(sv, len);
		const char *send = s + len;

                itemsize = 0;
		item_is_utf8 = DO_UTF8(sv);
                while (s < send) {
                    if (!isCNTRL(*s))
                        gotsome = TRUE;
                    else if (*s == '\n')
                        break;

                    if (item_is_utf8)
                        s += UTF8SKIP(s);
                    else
                        s++;
                    itemsize++;
                    if (itemsize == fieldsize)
                        break;
                }
                itembytes = s - item;
                chophere = s;
		break;
	    }

	case FF_CHECKCHOP: /* like CHECKNL, but up to highest split point */
	    {
		const char *s = item = SvPV_const(sv, len);
		const char *send = s + len;
                I32 size = 0;

                chophere = NULL;
		item_is_utf8 = DO_UTF8(sv);
                while (s < send) {
                    /* look for a legal split position */
                    if (isSPACE(*s)) {
                        if (*s == '\r') {
                            chophere = s;
                            itemsize = size;
                            break;
                        }
                        if (chopspace) {
                            /* provisional split point */
                            chophere = s;
                            itemsize = size;
                        }
                        /* we delay testing fieldsize until after we've
                         * processed the possible split char directly
                         * following the last field char; so if fieldsize=3
                         * and item="a b cdef", we consume "a b", not "a".
                         * Ditto further down.
                         */
                        if (size == fieldsize)
                            break;
                    }
                    else {
                        if (strchr(PL_chopset, *s)) {
                            /* provisional split point */
                            /* for a non-space split char, we include
                             * the split char; hence the '+1' */
                            chophere = s + 1;
                            itemsize = size;
                        }
                        if (size == fieldsize)
                            break;
                        if (!isCNTRL(*s))
                            gotsome = TRUE;
                    }

                    if (item_is_utf8)
                        s += UTF8SKIP(s);
                    else
                        s++;
                    size++;
                }
                if (!chophere || s == send) {
                    chophere = s;
                    itemsize = size;
                }
                itembytes = chophere - item;

		break;
	    }

	case FF_SPACE: /* append padding space (diff of field, item size) */
	    arg = fieldsize - itemsize;
	    if (arg) {
		fieldsize -= arg;
		while (arg-- > 0)
		    *t++ = ' ';
	    }
	    break;

	case FF_HALFSPACE: /* like FF_SPACE, but only append half as many */
	    arg = fieldsize - itemsize;
	    if (arg) {
		arg /= 2;
		fieldsize -= arg;
		while (arg-- > 0)
		    *t++ = ' ';
	    }
	    break;

	case FF_ITEM: /* append a text item, while blanking ctrl chars */
	    to_copy = itembytes;
	    source = (U8 *)item;
	    trans = 1;
	    goto append;

	case FF_CHOP: /* (for ^*) chop the current item */
	    if (sv != &PL_sv_no) {
		const char *s = chophere;
		if (chopspace) {
		    while (isSPACE(*s))
			s++;
		}
                if (SvPOKp(sv))
                    sv_chop(sv,s);
                else
                    /* tied, overloaded or similar strangeness.
                     * Do it the hard way */
                    sv_setpvn(sv, s, len - (s-item));
		SvSETMAGIC(sv);
		break;
	    }

	case FF_LINESNGL: /* process ^*  */
	    chopspace = 0;
            /* FALLTHROUGH */

	case FF_LINEGLOB: /* process @@*  */
	    {
		const bool oneline = fpc[-1] == FF_LINESNGL;
		const char *s = item = SvPV_const(sv, len);
		const char *const send = s + len;

		item_is_utf8 = DO_UTF8(sv);
		chophere = s + len;
		if (!len)
		    break;
		trans = 0;
		gotsome = TRUE;
		source = (U8 *) s;
		to_copy = len;
		while (s < send) {
		    if (*s++ == '\n') {
			if (oneline) {
			    to_copy = s - item - 1;
			    chophere = s;
			    break;
			} else {
			    if (s == send) {
				to_copy--;
			    } else
				lines++;
			}
		    }
		}
	    }

	append:
	    /* append to_copy bytes from source to PL_formstring.
	     * item_is_utf8 implies source is utf8.
	     * if trans, translate certain characters during the copy */
	    {
		U8 *tmp = NULL;
		STRLEN grow = 0;

		SvCUR_set(PL_formtarget,
			  t - SvPVX_const(PL_formtarget));

		if (targ_is_utf8 && !item_is_utf8) {
		    source = tmp = bytes_to_utf8(source, &to_copy);
		} else {
		    if (item_is_utf8 && !targ_is_utf8) {
			U8 *s;
			/* Upgrade targ to UTF8, and then we reduce it to
			   a problem we have a simple solution for.
			   Don't need get magic.  */
			sv_utf8_upgrade_nomg(PL_formtarget);
			targ_is_utf8 = TRUE;
			/* re-calculate linemark */
			s = (U8*)SvPVX(PL_formtarget);
			/* the bytes we initially allocated to append the
			 * whole line may have been gobbled up during the
			 * upgrade, so allocate a whole new line's worth
			 * for safety */
			grow = linemax;
			while (linemark--)
			    s += UTF8SKIP(s);
			linemark = s - (U8*)SvPVX(PL_formtarget);
		    }
		    /* Easy. They agree.  */
		    assert (item_is_utf8 == targ_is_utf8);
		}
		if (!trans)
		    /* @@* and ^* are the only things that can exceed
		     * the linemax, so grow by the output size, plus
		     * a whole new form's worth in case of any further
		     * output */
		    grow = linemax + to_copy;
		if (grow)
		    SvGROW(PL_formtarget, SvCUR(PL_formtarget) + grow + 1);
		t = SvPVX(PL_formtarget) + SvCUR(PL_formtarget);

		Copy(source, t, to_copy, char);
		if (trans) {
		    /* blank out ~ or control chars, depending on trans.
		     * works on bytes not chars, so relies on not
		     * matching utf8 continuation bytes */
		    U8 *s = (U8*)t;
		    U8 *send = s + to_copy;
		    while (s < send) {
			const int ch = *s;
			if (trans == '~' ? (ch == '~') : isCNTRL(ch))
			    *s = ' ';
			s++;
		    }
		}

		t += to_copy;
		SvCUR_set(PL_formtarget, SvCUR(PL_formtarget) + to_copy);
		if (tmp)
		    Safefree(tmp);
		break;
	    }

	case FF_0DECIMAL: /* like FF_DECIMAL but for 0### */
	    arg = *fpc++;
	    fmt = (const char *)
		((arg & FORM_NUM_POINT) ? "%#0*.*" NVff : "%0*.*" NVff);
	    goto ff_dec;

	case FF_DECIMAL: /* do @@##, ^##, where <arg>=(precision|flags) */
	    arg = *fpc++;
 	    fmt = (const char *)
		((arg & FORM_NUM_POINT) ? "%#*.*" NVff : "%*.*" NVff);
	ff_dec:
	    /* If the field is marked with ^ and the value is undefined,
	       blank it out. */
	    if ((arg & FORM_NUM_BLANK) && !SvOK(sv)) {
		arg = fieldsize;
		while (arg--)
		    *t++ = ' ';
		break;
	    }
	    gotsome = TRUE;
	    value = SvNV(sv);
	    /* overflow evidence */
	    if (num_overflow(value, fieldsize, arg)) {
	        arg = fieldsize;
		while (arg--)
		    *t++ = '#';
		break;
	    }
	    /* Formats aren't yet marked for locales, so assume "yes". */
	    {
                Size_t max = SvLEN(PL_formtarget) - (t - SvPVX(PL_formtarget));
                int len;
                DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
                STORE_LC_NUMERIC_SET_TO_NEEDED();
                arg &= ~(FORM_NUM_POINT|FORM_NUM_BLANK);
#ifdef USE_QUADMATH
                {
                    const char* qfmt = quadmath_format_single(fmt);
                    int len;
                    if (!qfmt)
                        Perl_croak_nocontext("panic: quadmath invalid format \"%s\"", fmt);
                    len = quadmath_snprintf(t, max, qfmt, (int) fieldsize, (int) arg, value);
                    if (len == -1)
                        Perl_croak_nocontext("panic: quadmath_snprintf failed, format \"%s\"", qfmt);
                    if (qfmt != fmt)
                        Safefree(fmt);
                }
#else
                /* we generate fmt ourselves so it is safe */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
                len = my_snprintf(t, max, fmt, (int) fieldsize, (int) arg, value);
                GCC_DIAG_RESTORE;
#endif
                PERL_MY_SNPRINTF_POST_GUARD(len, max);
                RESTORE_LC_NUMERIC();
	    }
	    t += fieldsize;
	    break;

	case FF_NEWLINE: /* delete trailing spaces, then append \n */
	    f++;
	    while (t-- > (SvPVX(PL_formtarget) + linemark) && *t == ' ') ;
	    t++;
	    *t++ = '\n';
	    break;

	case FF_BLANK: /* for arg==0: do '~'; for arg>0 : do '~~' */
	    arg = *fpc++;
	    if (gotsome) {
		if (arg) {		/* repeat until fields exhausted? */
		    fpc--;
		    goto end;
		}
	    }
	    else {
		t = SvPVX(PL_formtarget) + linemark;
		lines--;
	    }
	    break;

	case FF_MORE: /* replace long end of string with '...' */
	    {
		const char *s = chophere;
		const char *send = item + len;
		if (chopspace) {
		    while (isSPACE(*s) && (s < send))
			s++;
		}
		if (s < send) {
		    char *s1;
		    arg = fieldsize - itemsize;
		    if (arg) {
			fieldsize -= arg;
			while (arg-- > 0)
			    *t++ = ' ';
		    }
		    s1 = t - 3;
		    if (strnEQ(s1,"   ",3)) {
			while (s1 > SvPVX_const(PL_formtarget) && isSPACE(s1[-1]))
			    s1--;
		    }
		    *s1++ = '.';
		    *s1++ = '.';
		    *s1++ = '.';
		}
		break;
	    }

	case FF_END: /* tidy up, then return */
	end:
	    assert(t < SvPVX_const(PL_formtarget) + SvLEN(PL_formtarget));
	    *t = '\0';
	    SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
	    if (targ_is_utf8)
		SvUTF8_on(PL_formtarget);
	    FmLINES(PL_formtarget) += lines;
	    SP = ORIGMARK;
	    if (fpc[-1] == FF_BLANK)
		RETURNOP(cLISTOP->op_first);
	    else
		RETPUSHYES;
	}
    }
}

PP(pp_grepstart)
{
    dSP;
    SV *src;

    if (PL_stack_base + TOPMARK == SP) {
	(void)POPMARK;
	if (GIMME_V == G_SCALAR)
	    mXPUSHi(0);
	RETURNOP(PL_op->op_next->op_next);
    }
    PL_stack_sp = PL_stack_base + TOPMARK + 1;
    Perl_pp_pushmark(aTHX);				/* push dst */
    Perl_pp_pushmark(aTHX);				/* push src */
    ENTER_with_name("grep");					/* enter outer scope */

    SAVETMPS;
    SAVE_DEFSV;
    ENTER_with_name("grep_item");					/* enter inner scope */
    SAVEVPTR(PL_curpm);

    src = PL_stack_base[TOPMARK];
    if (SvPADTMP(src)) {
	src = PL_stack_base[TOPMARK] = sv_mortalcopy(src);
	PL_tmps_floor++;
    }
    SvTEMP_off(src);
    DEFSV_set(src);

    PUTBACK;
    if (PL_op->op_type == OP_MAPSTART)
	Perl_pp_pushmark(aTHX);			/* push top */
    return ((LOGOP*)PL_op->op_next)->op_other;
}

PP(pp_mapwhile)
{
    dSP;
    const U8 gimme = GIMME_V;
    I32 items = (SP - PL_stack_base) - TOPMARK; /* how many new items */
    I32 count;
    I32 shift;
    SV** src;
    SV** dst;

    /* first, move source pointer to the next item in the source list */
    ++PL_markstack_ptr[-1];

    /* if there are new items, push them into the destination list */
    if (items && gimme != G_VOID) {
	/* might need to make room back there first */
	if (items > PL_markstack_ptr[-1] - PL_markstack_ptr[-2]) {
	    /* XXX this implementation is very pessimal because the stack
	     * is repeatedly extended for every set of items.  Is possible
	     * to do this without any stack extension or copying at all
	     * by maintaining a separate list over which the map iterates
	     * (like foreach does). --gsar */

	    /* everything in the stack after the destination list moves
	     * towards the end the stack by the amount of room needed */
	    shift = items - (PL_markstack_ptr[-1] - PL_markstack_ptr[-2]);

	    /* items to shift up (accounting for the moved source pointer) */
	    count = (SP - PL_stack_base) - (PL_markstack_ptr[-1] - 1);

	    /* This optimization is by Ben Tilly and it does
	     * things differently from what Sarathy (gsar)
	     * is describing.  The downside of this optimization is
	     * that leaves "holes" (uninitialized and hopefully unused areas)
	     * to the Perl stack, but on the other hand this
	     * shouldn't be a problem.  If Sarathy's idea gets
	     * implemented, this optimization should become
	     * irrelevant.  --jhi */
            if (shift < count)
                shift = count; /* Avoid shifting too often --Ben Tilly */

	    EXTEND(SP,shift);
	    src = SP;
	    dst = (SP += shift);
	    PL_markstack_ptr[-1] += shift;
	    *PL_markstack_ptr += shift;
	    while (count--)
		*dst-- = *src--;
	}
	/* copy the new items down to the destination list */
	dst = PL_stack_base + (PL_markstack_ptr[-2] += items) - 1;
	if (gimme == G_ARRAY) {
	    /* add returned items to the collection (making mortal copies
	     * if necessary), then clear the current temps stack frame
	     * *except* for those items. We do this splicing the items
	     * into the start of the tmps frame (so some items may be on
	     * the tmps stack twice), then moving PL_tmps_floor above
	     * them, then freeing the frame. That way, the only tmps that
	     * accumulate over iterations are the return values for map.
	     * We have to do to this way so that everything gets correctly
	     * freed if we die during the map.
	     */
	    I32 tmpsbase;
	    I32 i = items;
	    /* make space for the slice */
	    EXTEND_MORTAL(items);
	    tmpsbase = PL_tmps_floor + 1;
	    Move(PL_tmps_stack + tmpsbase,
		 PL_tmps_stack + tmpsbase + items,
		 PL_tmps_ix - PL_tmps_floor,
		 SV*);
	    PL_tmps_ix += items;

	    while (i-- > 0) {
		SV *sv = POPs;
		if (!SvTEMP(sv))
		    sv = sv_mortalcopy(sv);
		*dst-- = sv;
		PL_tmps_stack[tmpsbase++] = SvREFCNT_inc_simple(sv);
	    }
	    /* clear the stack frame except for the items */
	    PL_tmps_floor += items;
	    FREETMPS;
	    /* FREETMPS may have cleared the TEMP flag on some of the items */
	    i = items;
	    while (i-- > 0)
		SvTEMP_on(PL_tmps_stack[--tmpsbase]);
	}
	else {
	    /* scalar context: we don't care about which values map returns
	     * (we use undef here). And so we certainly don't want to do mortal
	     * copies of meaningless values. */
	    while (items-- > 0) {
		(void)POPs;
		*dst-- = &PL_sv_undef;
	    }
	    FREETMPS;
	}
    }
    else {
	FREETMPS;
    }
    LEAVE_with_name("grep_item");					/* exit inner scope */

    /* All done yet? */
    if (PL_markstack_ptr[-1] > TOPMARK) {

	(void)POPMARK;				/* pop top */
	LEAVE_with_name("grep");					/* exit outer scope */
	(void)POPMARK;				/* pop src */
	items = --*PL_markstack_ptr - PL_markstack_ptr[-1];
	(void)POPMARK;				/* pop dst */
	SP = PL_stack_base + POPMARK;		/* pop original mark */
	if (gimme == G_SCALAR) {
		dTARGET;
		XPUSHi(items);
	}
	else if (gimme == G_ARRAY)
	    SP += items;
	RETURN;
    }
    else {
	SV *src;

	ENTER_with_name("grep_item");					/* enter inner scope */
	SAVEVPTR(PL_curpm);

	/* set $_ to the new source item */
	src = PL_stack_base[PL_markstack_ptr[-1]];
	if (SvPADTMP(src)) {
            src = sv_mortalcopy(src);
        }
	SvTEMP_off(src);
	DEFSV_set(src);

	RETURNOP(cLOGOP->op_other);
    }
}

/* Range stuff. */

PP(pp_range)
{
    if (GIMME_V == G_ARRAY)
	return NORMAL;
    if (SvTRUEx(PAD_SV(PL_op->op_targ)))
	return cLOGOP->op_other;
    else
	return NORMAL;
}

PP(pp_flip)
{
    dSP;

    if (GIMME_V == G_ARRAY) {
	RETURNOP(((LOGOP*)cUNOP->op_first)->op_other);
    }
    else {
	dTOPss;
	SV * const targ = PAD_SV(PL_op->op_targ);
	int flip = 0;

	if (PL_op->op_private & OPpFLIP_LINENUM) {
	    if (GvIO(PL_last_in_gv)) {
		flip = SvIV(sv) == (IV)IoLINES(GvIOp(PL_last_in_gv));
	    }
	    else {
		GV * const gv = gv_fetchpvs(".", GV_ADD|GV_NOTQUAL, SVt_PV);
		if (gv && GvSV(gv))
		    flip = SvIV(sv) == SvIV(GvSV(gv));
	    }
	} else {
	    flip = SvTRUE(sv);
	}
	if (flip) {
	    sv_setiv(PAD_SV(cUNOP->op_first->op_targ), 1);
	    if (PL_op->op_flags & OPf_SPECIAL) {
		sv_setiv(targ, 1);
		SETs(targ);
		RETURN;
	    }
	    else {
		sv_setiv(targ, 0);
		SP--;
		RETURNOP(((LOGOP*)cUNOP->op_first)->op_other);
	    }
	}
	sv_setpvs(TARG, "");
	SETs(targ);
	RETURN;
    }
}

/* This code tries to decide if "$left .. $right" should use the
   magical string increment, or if the range is numeric (we make
   an exception for .."0" [#18165]). AMS 20021031. */

#define RANGE_IS_NUMERIC(left,right) ( \
	SvNIOKp(left)  || (SvOK(left)  && !SvPOKp(left))  || \
	SvNIOKp(right) || (SvOK(right) && !SvPOKp(right)) || \
	(((!SvOK(left) && SvOK(right)) || ((!SvOK(left) || \
          looks_like_number(left)) && SvPOKp(left) && *SvPVX_const(left) != '0')) \
         && (!SvOK(right) || looks_like_number(right))))

PP(pp_flop)
{
    dSP;

    if (GIMME_V == G_ARRAY) {
	dPOPPOPssrl;

	SvGETMAGIC(left);
	SvGETMAGIC(right);

	if (RANGE_IS_NUMERIC(left,right)) {
	    IV i, j, n;
	    if ((SvOK(left) && !SvIOK(left) && SvNV_nomg(left) < IV_MIN) ||
		(SvOK(right) && (SvIOK(right)
				 ? SvIsUV(right) && SvUV(right) > IV_MAX
				 : SvNV_nomg(right) > IV_MAX)))
		DIE(aTHX_ "Range iterator outside integer range");
	    i = SvIV_nomg(left);
	    j = SvIV_nomg(right);
	    if (j >= i) {
                /* Dance carefully around signed max. */
                bool overflow = (i <= 0 && j > SSize_t_MAX + i - 1);
                if (!overflow) {
                    n = j - i + 1;
                    /* The wraparound of signed integers is undefined
                     * behavior, but here we aim for count >=1, and
                     * negative count is just wrong. */
                    if (n < 1
#if IVSIZE > Size_t_size
                        || n > SSize_t_MAX
#endif
                        )
                        overflow = TRUE;
                }
                if (overflow)
                    Perl_croak(aTHX_ "Out of memory during list extend");
		EXTEND_MORTAL(n);
		EXTEND(SP, n);
	    }
	    else
		n = 0;
	    while (n--) {
		SV * const sv = sv_2mortal(newSViv(i));
		PUSHs(sv);
                if (n) /* avoid incrementing above IV_MAX */
                    i++;
	    }
	}
	else {
	    STRLEN len, llen;
	    const char * const lpv = SvPV_nomg_const(left, llen);
	    const char * const tmps = SvPV_nomg_const(right, len);

	    SV *sv = newSVpvn_flags(lpv, llen, SvUTF8(left)|SVs_TEMP);
	    while (!SvNIOKp(sv) && SvCUR(sv) <= len) {
		XPUSHs(sv);
	        if (strEQ(SvPVX_const(sv),tmps))
	            break;
		sv = sv_2mortal(newSVsv(sv));
		sv_inc(sv);
	    }
	}
    }
    else {
	dTOPss;
	SV * const targ = PAD_SV(cUNOP->op_first->op_targ);
	int flop = 0;
	sv_inc(targ);

	if (PL_op->op_private & OPpFLIP_LINENUM) {
	    if (GvIO(PL_last_in_gv)) {
		flop = SvIV(sv) == (IV)IoLINES(GvIOp(PL_last_in_gv));
	    }
	    else {
		GV * const gv = gv_fetchpvs(".", GV_ADD|GV_NOTQUAL, SVt_PV);
		if (gv && GvSV(gv)) flop = SvIV(sv) == SvIV(GvSV(gv));
	    }
	}
	else {
	    flop = SvTRUE(sv);
	}

	if (flop) {
	    sv_setiv(PAD_SV(((UNOP*)cUNOP->op_first)->op_first->op_targ), 0);
	    sv_catpvs(targ, "E0");
	}
	SETs(targ);
    }

    RETURN;
}

/* Control. */

static const char * const context_name[] = {
    "pseudo-block",
    NULL, /* CXt_WHEN never actually needs "block" */
    NULL, /* CXt_BLOCK never actually needs "block" */
    NULL, /* CXt_GIVEN never actually needs "block" */
    NULL, /* CXt_LOOP_PLAIN never actually needs "loop" */
    NULL, /* CXt_LOOP_LAZYIV never actually needs "loop" */
    NULL, /* CXt_LOOP_LAZYSV never actually needs "loop" */
    NULL, /* CXt_LOOP_LIST never actually needs "loop" */
    NULL, /* CXt_LOOP_ARY never actually needs "loop" */
    "subroutine",
    "format",
    "eval",
    "substitution",
};

STATIC I32
S_dopoptolabel(pTHX_ const char *label, STRLEN len, U32 flags)
{
    I32 i;

    PERL_ARGS_ASSERT_DOPOPTOLABEL;

    for (i = cxstack_ix; i >= 0; i--) {
	const PERL_CONTEXT * const cx = &cxstack[i];
	switch (CxTYPE(cx)) {
	case CXt_SUBST:
	case CXt_SUB:
	case CXt_FORMAT:
	case CXt_EVAL:
	case CXt_NULL:
	    /* diag_listed_as: Exiting subroutine via %s */
	    Perl_ck_warner(aTHX_ packWARN(WARN_EXITING), "Exiting %s via %s",
			   context_name[CxTYPE(cx)], OP_NAME(PL_op));
	    if (CxTYPE(cx) == CXt_NULL) /* sort BLOCK */
		return -1;
	    break;
	case CXt_LOOP_PLAIN:
	case CXt_LOOP_LAZYIV:
	case CXt_LOOP_LAZYSV:
	case CXt_LOOP_LIST:
	case CXt_LOOP_ARY:
	  {
            STRLEN cx_label_len = 0;
            U32 cx_label_flags = 0;
	    const char *cx_label = CxLABEL_len_flags(cx, &cx_label_len, &cx_label_flags);
	    if (!cx_label || !(
                    ( (cx_label_flags & SVf_UTF8) != (flags & SVf_UTF8) ) ?
                        (flags & SVf_UTF8)
                            ? (bytes_cmp_utf8(
                                        (const U8*)cx_label, cx_label_len,
                                        (const U8*)label, len) == 0)
                            : (bytes_cmp_utf8(
                                        (const U8*)label, len,
                                        (const U8*)cx_label, cx_label_len) == 0)
                    : (len == cx_label_len && ((cx_label == label)
                                    || memEQ(cx_label, label, len))) )) {
		DEBUG_l(Perl_deb(aTHX_ "(poptolabel(): skipping label at cx=%ld %s)\n",
			(long)i, cx_label));
		continue;
	    }
	    DEBUG_l( Perl_deb(aTHX_ "(poptolabel(): found label at cx=%ld %s)\n", (long)i, label));
	    return i;
	  }
	}
    }
    return i;
}



U8
Perl_dowantarray(pTHX)
{
    const U8 gimme = block_gimme();
    return (gimme == G_VOID) ? G_SCALAR : gimme;
}

U8
Perl_block_gimme(pTHX)
{
    const I32 cxix = dopoptosub(cxstack_ix);
    U8 gimme;
    if (cxix < 0)
	return G_VOID;

    gimme = (cxstack[cxix].blk_gimme & G_WANT);
    if (!gimme)
	Perl_croak(aTHX_ "panic: bad gimme: %d\n", gimme);
    return gimme;
}


I32
Perl_is_lvalue_sub(pTHX)
{
    const I32 cxix = dopoptosub(cxstack_ix);
    assert(cxix >= 0);  /* We should only be called from inside subs */

    if (CxLVAL(cxstack + cxix) && CvLVALUE(cxstack[cxix].blk_sub.cv))
	return CxLVAL(cxstack + cxix);
    else
	return 0;
}

/* only used by cx_pushsub() */
I32
Perl_was_lvalue_sub(pTHX)
{
    const I32 cxix = dopoptosub(cxstack_ix-1);
    assert(cxix >= 0);  /* We should only be called from inside subs */

    if (CxLVAL(cxstack + cxix) && CvLVALUE(cxstack[cxix].blk_sub.cv))
	return CxLVAL(cxstack + cxix);
    else
	return 0;
}

STATIC I32
S_dopoptosub_at(pTHX_ const PERL_CONTEXT *cxstk, I32 startingblock)
{
    I32 i;

    PERL_ARGS_ASSERT_DOPOPTOSUB_AT;
#ifndef DEBUGGING
    PERL_UNUSED_CONTEXT;
#endif

    for (i = startingblock; i >= 0; i--) {
	const PERL_CONTEXT * const cx = &cxstk[i];
	switch (CxTYPE(cx)) {
	default:
	    continue;
	case CXt_SUB:
            /* in sub foo { /(?{...})/ }, foo ends up on the CX stack
             * twice; the first for the normal foo() call, and the second
             * for a faked up re-entry into the sub to execute the
             * code block. Hide this faked entry from the world. */
            if (cx->cx_type & CXp_SUB_RE_FAKE)
                continue;
            /* FALLTHROUGH */
	case CXt_EVAL:
	case CXt_FORMAT:
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptosub_at(): found sub at cx=%ld)\n", (long)i));
	    return i;
	}
    }
    return i;
}

STATIC I32
S_dopoptoeval(pTHX_ I32 startingblock)
{
    I32 i;
    for (i = startingblock; i >= 0; i--) {
	const PERL_CONTEXT *cx = &cxstack[i];
	switch (CxTYPE(cx)) {
	default:
	    continue;
	case CXt_EVAL:
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptoeval(): found eval at cx=%ld)\n", (long)i));
	    return i;
	}
    }
    return i;
}

STATIC I32
S_dopoptoloop(pTHX_ I32 startingblock)
{
    I32 i;
    for (i = startingblock; i >= 0; i--) {
	const PERL_CONTEXT * const cx = &cxstack[i];
	switch (CxTYPE(cx)) {
	case CXt_SUBST:
	case CXt_SUB:
	case CXt_FORMAT:
	case CXt_EVAL:
	case CXt_NULL:
	    /* diag_listed_as: Exiting subroutine via %s */
	    Perl_ck_warner(aTHX_ packWARN(WARN_EXITING), "Exiting %s via %s",
			   context_name[CxTYPE(cx)], OP_NAME(PL_op));
	    if ((CxTYPE(cx)) == CXt_NULL) /* sort BLOCK */
		return -1;
	    break;
	case CXt_LOOP_PLAIN:
	case CXt_LOOP_LAZYIV:
	case CXt_LOOP_LAZYSV:
	case CXt_LOOP_LIST:
	case CXt_LOOP_ARY:
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptoloop(): found loop at cx=%ld)\n", (long)i));
	    return i;
	}
    }
    return i;
}

/* find the next GIVEN or FOR (with implicit $_) loop context block */

STATIC I32
S_dopoptogivenfor(pTHX_ I32 startingblock)
{
    I32 i;
    for (i = startingblock; i >= 0; i--) {
	const PERL_CONTEXT *cx = &cxstack[i];
	switch (CxTYPE(cx)) {
	default:
	    continue;
	case CXt_GIVEN:
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptogivenfor(): found given at cx=%ld)\n", (long)i));
	    return i;
	case CXt_LOOP_PLAIN:
            assert(!(cx->cx_type & CXp_FOR_DEF));
	    break;
	case CXt_LOOP_LAZYIV:
	case CXt_LOOP_LAZYSV:
	case CXt_LOOP_LIST:
	case CXt_LOOP_ARY:
            if (cx->cx_type & CXp_FOR_DEF) {
		DEBUG_l( Perl_deb(aTHX_ "(dopoptogivenfor(): found foreach at cx=%ld)\n", (long)i));
		return i;
	    }
	}
    }
    return i;
}

STATIC I32
S_dopoptowhen(pTHX_ I32 startingblock)
{
    I32 i;
    for (i = startingblock; i >= 0; i--) {
	const PERL_CONTEXT *cx = &cxstack[i];
	switch (CxTYPE(cx)) {
	default:
	    continue;
	case CXt_WHEN:
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptowhen(): found when at cx=%ld)\n", (long)i));
	    return i;
	}
    }
    return i;
}

/* dounwind(): pop all contexts above (but not including) cxix.
 * Note that it clears the savestack frame associated with each popped
 * context entry, but doesn't free any temps.
 * It does a cx_popblock() of the last frame that it pops, and leaves
 * cxstack_ix equal to cxix.
 */

void
Perl_dounwind(pTHX_ I32 cxix)
{
    if (!PL_curstackinfo) /* can happen if die during thread cloning */
	return;

    while (cxstack_ix > cxix) {
        PERL_CONTEXT *cx = CX_CUR();

	CX_DEBUG(cx, "UNWIND");
	/* Note: we don't need to restore the base context info till the end. */

        CX_LEAVE_SCOPE(cx);

	switch (CxTYPE(cx)) {
	case CXt_SUBST:
	    CX_POPSUBST(cx);
	    break;
	case CXt_SUB:
	    cx_popsub(cx);
	    break;
	case CXt_EVAL:
	    cx_popeval(cx);
	    break;
	case CXt_LOOP_PLAIN:
	case CXt_LOOP_LAZYIV:
	case CXt_LOOP_LAZYSV:
	case CXt_LOOP_LIST:
	case CXt_LOOP_ARY:
	    cx_poploop(cx);
	    break;
	case CXt_WHEN:
	    cx_popwhen(cx);
	    break;
	case CXt_GIVEN:
	    cx_popgiven(cx);
	    break;
	case CXt_BLOCK:
	case CXt_NULL:
            /* these two don't have a POPFOO() */
	    break;
	case CXt_FORMAT:
	    cx_popformat(cx);
	    break;
	}
        if (cxstack_ix == cxix + 1) {
            cx_popblock(cx);
        }
	cxstack_ix--;
    }

}

void
Perl_qerror(pTHX_ SV *err)
{
    PERL_ARGS_ASSERT_QERROR;

    if (PL_in_eval) {
	if (PL_in_eval & EVAL_KEEPERR) {
		Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "\t(in cleanup) %"SVf,
                                                    SVfARG(err));
	}
	else
	    sv_catsv(ERRSV, err);
    }
    else if (PL_errors)
	sv_catsv(PL_errors, err);
    else
	Perl_warn(aTHX_ "%"SVf, SVfARG(err));
    if (PL_parser)
	++PL_parser->error_count;
}



/* undef or delete the $INC{namesv} entry, then croak.
 * require0 indicates that the require didn't return a true value */

static void
S_undo_inc_then_croak(pTHX_ SV *namesv, SV *err, bool require0)
{
    const char *fmt;
    HV *inc_hv = GvHVn(PL_incgv);
    I32  klen  = SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv);
    const char *key = SvPVX_const(namesv);

    if (require0) {
	(void)hv_delete(inc_hv, key, klen, G_DISCARD);
	fmt = "%"SVf" did not return a true value";
        err = namesv;
    }
    else {
        (void)hv_store(inc_hv, key, klen, &PL_sv_undef, 0);
        fmt = "%"SVf"Compilation failed in require";
        err = err ? err : newSVpvs_flags("Unknown error\n", SVs_TEMP);
    }

    Perl_croak(aTHX_ fmt, SVfARG(err));
}


void
Perl_die_unwind(pTHX_ SV *msv)
{
    SV *exceptsv = sv_mortalcopy(msv);
    U8 in_eval = PL_in_eval;
    PERL_ARGS_ASSERT_DIE_UNWIND;

    if (in_eval) {
	I32 cxix;

	/*
	 * Historically, perl used to set ERRSV ($@@) early in the die
	 * process and rely on it not getting clobbered during unwinding.
	 * That sucked, because it was liable to get clobbered, so the
	 * setting of ERRSV used to emit the exception from eval{} has
	 * been moved to much later, after unwinding (see just before
	 * JMPENV_JUMP below).	However, some modules were relying on the
	 * early setting, by examining $@@ during unwinding to use it as
	 * a flag indicating whether the current unwinding was caused by
	 * an exception.  It was never a reliable flag for that purpose,
	 * being totally open to false positives even without actual
	 * clobberage, but was useful enough for production code to
	 * semantically rely on it.
	 *
	 * We'd like to have a proper introspective interface that
	 * explicitly describes the reason for whatever unwinding
	 * operations are currently in progress, so that those modules
	 * work reliably and $@@ isn't further overloaded.  But we don't
	 * have one yet.  In its absence, as a stopgap measure, ERRSV is
	 * now *additionally* set here, before unwinding, to serve as the
	 * (unreliable) flag that it used to.
	 *
	 * This behaviour is temporary, and should be removed when a
	 * proper way to detect exceptional unwinding has been developed.
	 * As of 2010-12, the authors of modules relying on the hack
	 * are aware of the issue, because the modules failed on
	 * perls 5.13.{1..7} which had late setting of $@@ without this
	 * early-setting hack.
	 */
	if (!(in_eval & EVAL_KEEPERR)) {
	    SvTEMP_off(exceptsv);
	    sv_setsv(ERRSV, exceptsv);
	}

	if (in_eval & EVAL_KEEPERR) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "\t(in cleanup) %"SVf,
			   SVfARG(exceptsv));
	}

	while ((cxix = dopoptoeval(cxstack_ix)) < 0
	       && PL_curstackinfo->si_prev)
	{
	    dounwind(-1);
	    POPSTACK;
	}

	if (cxix >= 0) {
            SV *namesv = NULL;
	    PERL_CONTEXT *cx;
	    SV **oldsp;
            U8 gimme;
	    JMPENV *restartjmpenv;
	    OP *restartop;

	    if (cxix < cxstack_ix)
		dounwind(cxix);

            cx = CX_CUR();
            assert(CxTYPE(cx) == CXt_EVAL);

            /* return false to the caller of eval */
            oldsp = PL_stack_base + cx->blk_oldsp;
            gimme = cx->blk_gimme;
	    if (gimme == G_SCALAR)
		*++oldsp = &PL_sv_undef;
	    PL_stack_sp = oldsp;

            CX_LEAVE_SCOPE(cx);
	    cx_popeval(cx);
	    cx_popblock(cx);
	    restartjmpenv = cx->blk_eval.cur_top_env;
	    restartop = cx->blk_eval.retop;
            if (CxOLD_OP_TYPE(cx) == OP_REQUIRE)
                namesv = cx->blk_eval.old_namesv;
            CX_POP(cx);

            if (namesv) {
                /* note that unlike pp_entereval, pp_require isn't
                 * supposed to trap errors. So now that we've popped the
                 * EVAL that pp_require pushed, process the error message
                 * and rethrow the error */
                S_undo_inc_then_croak(aTHX_ namesv, exceptsv, FALSE);
                NOT_REACHED; /* NOTREACHED */
            }

	    if (!(in_eval & EVAL_KEEPERR))
		sv_setsv(ERRSV, exceptsv);
	    PL_restartjmpenv = restartjmpenv;
	    PL_restartop = restartop;
	    JMPENV_JUMP(3);
	    NOT_REACHED; /* NOTREACHED */
	}
    }

    write_to_stderr(exceptsv);
    my_failure_exit();
    NOT_REACHED; /* NOTREACHED */
}

PP(pp_xor)
{
    dSP; dPOPTOPssrl;
    if (SvTRUE(left) != SvTRUE(right))
	RETSETYES;
    else
	RETSETNO;
}

/*

=head1 CV Manipulation Functions

=for apidoc caller_cx

The XSUB-writer's equivalent of L<caller()|perlfunc/caller>.  The
returned C<PERL_CONTEXT> structure can be interrogated to find all the
information returned to Perl by C<caller>.  Note that XSUBs don't get a
stack frame, so C<caller_cx(0, NULL)> will return information for the
immediately-surrounding Perl code.

This function skips over the automatic calls to C<&DB::sub> made on the
behalf of the debugger.  If the stack frame requested was a sub called by
C<DB::sub>, the return value will be the frame for the call to
C<DB::sub>, since that has the correct line number/etc. for the call
site.  If I<dbcxp> is non-C<NULL>, it will be set to a pointer to the
frame for the sub call itself.

=cut
*/

const PERL_CONTEXT *
Perl_caller_cx(pTHX_ I32 count, const PERL_CONTEXT **dbcxp)
{
    I32 cxix = dopoptosub(cxstack_ix);
    const PERL_CONTEXT *cx;
    const PERL_CONTEXT *ccstack = cxstack;
    const PERL_SI *top_si = PL_curstackinfo;

    for (;;) {
	/* we may be in a higher stacklevel, so dig down deeper */
	while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {
	    top_si = top_si->si_prev;
	    ccstack = top_si->si_cxstack;
	    cxix = dopoptosub_at(ccstack, top_si->si_cxix);
	}
	if (cxix < 0)
	    return NULL;
	/* caller() should not report the automatic calls to &DB::sub */
	if (PL_DBsub && GvCV(PL_DBsub) && cxix >= 0 &&
		ccstack[cxix].blk_sub.cv == GvCV(PL_DBsub))
	    count++;
	if (!count--)
	    break;
	cxix = dopoptosub_at(ccstack, cxix - 1);
    }

    cx = &ccstack[cxix];
    if (dbcxp) *dbcxp = cx;

    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
        const I32 dbcxix = dopoptosub_at(ccstack, cxix - 1);
	/* We expect that ccstack[dbcxix] is CXt_SUB, anyway, the
	   field below is defined for any cx. */
	/* caller() should not report the automatic calls to &DB::sub */
	if (PL_DBsub && GvCV(PL_DBsub) && dbcxix >= 0 && ccstack[dbcxix].blk_sub.cv == GvCV(PL_DBsub))
	    cx = &ccstack[dbcxix];
    }

    return cx;
}

PP(pp_caller)
{
    dSP;
    const PERL_CONTEXT *cx;
    const PERL_CONTEXT *dbcx;
    U8 gimme = GIMME_V;
    const HEK *stash_hek;
    I32 count = 0;
    bool has_arg = MAXARG && TOPs;
    const COP *lcop;

    if (MAXARG) {
      if (has_arg)
	count = POPi;
      else (void)POPs;
    }

    cx = caller_cx(count + !!(PL_op->op_private & OPpOFFBYONE), &dbcx);
    if (!cx) {
	if (gimme != G_ARRAY) {
	    EXTEND(SP, 1);
	    RETPUSHUNDEF;
	}
	RETURN;
    }

    CX_DEBUG(cx, "CALLER");
    assert(CopSTASH(cx->blk_oldcop));
    stash_hek = SvTYPE(CopSTASH(cx->blk_oldcop)) == SVt_PVHV
      ? HvNAME_HEK((HV*)CopSTASH(cx->blk_oldcop))
      : NULL;
    if (gimme != G_ARRAY) {
        EXTEND(SP, 1);
	if (!stash_hek)
	    PUSHs(&PL_sv_undef);
	else {
	    dTARGET;
	    sv_sethek(TARG, stash_hek);
	    PUSHs(TARG);
	}
	RETURN;
    }

    EXTEND(SP, 11);

    if (!stash_hek)
	PUSHs(&PL_sv_undef);
    else {
	dTARGET;
	sv_sethek(TARG, stash_hek);
	PUSHTARG;
    }
    mPUSHs(newSVpv(OutCopFILE(cx->blk_oldcop), 0));
    lcop = closest_cop(cx->blk_oldcop, OpSIBLING(cx->blk_oldcop),
		       cx->blk_sub.retop, TRUE);
    if (!lcop)
	lcop = cx->blk_oldcop;
    mPUSHu(CopLINE(lcop));
    if (!has_arg)
	RETURN;
    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
	/* So is ccstack[dbcxix]. */
	if (CvHASGV(dbcx->blk_sub.cv)) {
	    PUSHs(cv_name(dbcx->blk_sub.cv, 0, 0));
	    PUSHs(boolSV(CxHASARGS(cx)));
	}
	else {
	    PUSHs(newSVpvs_flags("(unknown)", SVs_TEMP));
	    PUSHs(boolSV(CxHASARGS(cx)));
	}
    }
    else {
	PUSHs(newSVpvs_flags("(eval)", SVs_TEMP));
	mPUSHi(0);
    }
    gimme = cx->blk_gimme;
    if (gimme == G_VOID)
	PUSHs(&PL_sv_undef);
    else
	PUSHs(boolSV((gimme & G_WANT) == G_ARRAY));
    if (CxTYPE(cx) == CXt_EVAL) {
	/* eval STRING */
	if (CxOLD_OP_TYPE(cx) == OP_ENTEREVAL) {
            SV *cur_text = cx->blk_eval.cur_text;
            if (SvCUR(cur_text) >= 2) {
                PUSHs(newSVpvn_flags(SvPVX(cur_text), SvCUR(cur_text)-2,
                                     SvUTF8(cur_text)|SVs_TEMP));
            }
            else {
                /* I think this is will always be "", but be sure */
                PUSHs(sv_2mortal(newSVsv(cur_text)));
            }

	    PUSHs(&PL_sv_no);
	}
	/* require */
	else if (cx->blk_eval.old_namesv) {
	    mPUSHs(newSVsv(cx->blk_eval.old_namesv));
	    PUSHs(&PL_sv_yes);
	}
	/* eval BLOCK (try blocks have old_namesv == 0) */
	else {
	    PUSHs(&PL_sv_undef);
	    PUSHs(&PL_sv_undef);
	}
    }
    else {
	PUSHs(&PL_sv_undef);
	PUSHs(&PL_sv_undef);
    }
    if (CxTYPE(cx) == CXt_SUB && CxHASARGS(cx)
	&& CopSTASH_eq(PL_curcop, PL_debstash))
    {
        /* slot 0 of the pad contains the original @@_ */
	AV * const ary = MUTABLE_AV(AvARRAY(MUTABLE_AV(
                            PadlistARRAY(CvPADLIST(cx->blk_sub.cv))[
                                cx->blk_sub.olddepth+1]))[0]);
	const SSize_t off = AvARRAY(ary) - AvALLOC(ary);

	Perl_init_dbargs(aTHX);

	if (AvMAX(PL_dbargs) < AvFILLp(ary) + off)
	    av_extend(PL_dbargs, AvFILLp(ary) + off);
	Copy(AvALLOC(ary), AvARRAY(PL_dbargs), AvFILLp(ary) + 1 + off, SV*);
	AvFILLp(PL_dbargs) = AvFILLp(ary) + off;
    }
    mPUSHi(CopHINTS_get(cx->blk_oldcop));
    {
	SV * mask ;
	STRLEN * const old_warnings = cx->blk_oldcop->cop_warnings ;

	if  (old_warnings == pWARN_NONE)
            mask = newSVpvn(WARN_NONEstring, WARNsize) ;
	else if (old_warnings == pWARN_STD && (PL_dowarn & G_WARN_ON) == 0)
            mask = &PL_sv_undef ;
        else if (old_warnings == pWARN_ALL ||
		  (old_warnings == pWARN_STD && PL_dowarn & G_WARN_ON)) {
	    /* Get the bit mask for $warnings::Bits{all}, because
	     * it could have been extended by warnings::register */
	    SV **bits_all;
	    HV * const bits = get_hv("warnings::Bits", 0);
	    if (bits && (bits_all=hv_fetchs(bits, "all", FALSE))) {
		mask = newSVsv(*bits_all);
	    }
	    else {
		mask = newSVpvn(WARN_ALLstring, WARNsize) ;
	    }
	}
        else
            mask = newSVpvn((char *) (old_warnings + 1), old_warnings[0]);
        mPUSHs(mask);
    }

    PUSHs(cx->blk_oldcop->cop_hints_hash ?
	  sv_2mortal(newRV_noinc(MUTABLE_SV(cop_hints_2hv(cx->blk_oldcop, 0))))
	  : &PL_sv_undef);
    RETURN;
}

PP(pp_reset)
{
    dSP;
    const char * tmps;
    STRLEN len = 0;
    if (MAXARG < 1 || (!TOPs && !POPs))
	tmps = NULL, len = 0;
    else
	tmps = SvPVx_const(POPs, len);
    sv_resetpvn(tmps, len, CopSTASH(PL_curcop));
    PUSHs(&PL_sv_yes);
    RETURN;
}

/* like pp_nextstate, but used instead when the debugger is active */

PP(pp_dbstate)
{
    PL_curcop = (COP*)PL_op;
    TAINT_NOT;		/* Each statement is presumed innocent */
    PL_stack_sp = PL_stack_base + CX_CUR()->blk_oldsp;
    FREETMPS;

    PERL_ASYNC_CHECK();

    if (PL_op->op_flags & OPf_SPECIAL /* breakpoint */
	    || PL_DBsingle_iv || PL_DBsignal_iv || PL_DBtrace_iv)
    {
	dSP;
	PERL_CONTEXT *cx;
	const U8 gimme = G_ARRAY;
	GV * const gv = PL_DBgv;
	CV * cv = NULL;

        if (gv && isGV_with_GP(gv))
            cv = GvCV(gv);

	if (!cv || (!CvROOT(cv) && !CvXSUB(cv)))
	    DIE(aTHX_ "No DB::DB routine defined");

	if (CvDEPTH(cv) >= 1 && !(PL_debug & DEBUG_DB_RECURSE_FLAG))
	    /* don't do recursive DB::DB call */
	    return NORMAL;

	if (CvISXSUB(cv)) {
            ENTER;
            SAVEI32(PL_debug);
            PL_debug = 0;
            SAVESTACK_POS();
            SAVETMPS;
	    PUSHMARK(SP);
	    (void)(*CvXSUB(cv))(aTHX_ cv);
	    FREETMPS;
	    LEAVE;
	    return NORMAL;
	}
	else {
	    cx = cx_pushblock(CXt_SUB, gimme, SP, PL_savestack_ix);
	    cx_pushsub(cx, cv, PL_op->op_next, 0);
            /* OP_DBSTATE's op_private holds hint bits rather than
             * the lvalue-ish flags seen in OP_ENTERSUB. So cancel
             * any CxLVAL() flags that have now been mis-calculated */
            cx->blk_u16 = 0;

            SAVEI32(PL_debug);
            PL_debug = 0;
            SAVESTACK_POS();
	    CvDEPTH(cv)++;
	    if (CvDEPTH(cv) >= 2)
		pad_push(CvPADLIST(cv), CvDEPTH(cv));
	    PAD_SET_CUR_NOSAVE(CvPADLIST(cv), CvDEPTH(cv));
	    RETURNOP(CvSTART(cv));
	}
    }
    else
	return NORMAL;
}


PP(pp_enter)
{
    U8 gimme = GIMME_V;

    (void)cx_pushblock(CXt_BLOCK, gimme, PL_stack_sp, PL_savestack_ix);
    return NORMAL;
}


PP(pp_leave)
{
    PERL_CONTEXT *cx;
    SV **oldsp;
    U8 gimme;

    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_BLOCK);

    if (PL_op->op_flags & OPf_SPECIAL)
        /* fake block should preserve $1 et al; e.g.  /(...)/ while ...; */
	cx->blk_oldpm = PL_curpm;

    oldsp = PL_stack_base + cx->blk_oldsp;
    gimme = cx->blk_gimme;

    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme,
                                PL_op->op_private & OPpLVALUE ? 3 : 1);

    CX_LEAVE_SCOPE(cx);
    cx_popblock(cx);
    CX_POP(cx);

    return NORMAL;
}

static bool
S_outside_integer(pTHX_ SV *sv)
{
  if (SvOK(sv)) {
    const NV nv = SvNV_nomg(sv);
    if (Perl_isinfnan(nv))
      return TRUE;
#ifdef NV_PRESERVES_UV
    if (nv < (NV)IV_MIN || nv > (NV)IV_MAX)
      return TRUE;
#else
    if (nv <= (NV)IV_MIN)
      return TRUE;
    if ((nv > 0) &&
        ((nv > (NV)UV_MAX ||
          SvUV_nomg(sv) > (UV)IV_MAX)))
      return TRUE;
#endif
  }
  return FALSE;
}

PP(pp_enteriter)
{
    dSP; dMARK;
    PERL_CONTEXT *cx;
    const U8 gimme = GIMME_V;
    void *itervarp; /* GV or pad slot of the iteration variable */
    SV   *itersave; /* the old var in the iterator var slot */
    U8 cxflags = 0;

    if (PL_op->op_targ) {			 /* "my" variable */
	itervarp = &PAD_SVl(PL_op->op_targ);
        itersave = *(SV**)itervarp;
        assert(itersave);
	if (PL_op->op_private & OPpLVAL_INTRO) {        /* for my $x (...) */
            /* the SV currently in the pad slot is never live during
             * iteration (the slot is always aliased to one of the items)
             * so it's always stale */
	    SvPADSTALE_on(itersave);
	}
        SvREFCNT_inc_simple_void_NN(itersave);
	cxflags = CXp_FOR_PAD;
    }
    else {
	SV * const sv = POPs;
	itervarp = (void *)sv;
        if (LIKELY(isGV(sv))) {		/* symbol table variable */
            itersave = GvSV(sv);
            SvREFCNT_inc_simple_void(itersave);
            cxflags = CXp_FOR_GV;
            if (PL_op->op_private & OPpITER_DEF)
                cxflags |= CXp_FOR_DEF;
        }
        else {                          /* LV ref: for \$foo (...) */
            assert(SvTYPE(sv) == SVt_PVMG);
            assert(SvMAGIC(sv));
            assert(SvMAGIC(sv)->mg_type == PERL_MAGIC_lvref);
            itersave = NULL;
            cxflags = CXp_FOR_LVREF;
        }
    }
    /* OPpITER_DEF (implicit $_) should only occur with a GV iter var */
    assert((cxflags & CXp_FOR_GV) || !(PL_op->op_private & OPpITER_DEF));

    /* Note that this context is initially set as CXt_NULL. Further on
     * down it's changed to one of the CXt_LOOP_*. Before it's changed,
     * there mustn't be anything in the blk_loop substruct that requires
     * freeing or undoing, in case we die in the meantime. And vice-versa.
     */
    cx = cx_pushblock(cxflags, gimme, MARK, PL_savestack_ix);
    cx_pushloop_for(cx, itervarp, itersave);

    if (PL_op->op_flags & OPf_STACKED) {
        /* OPf_STACKED implies either a single array: for(@@), with a
         * single AV on the stack, or a range: for (1..5), with 1 and 5 on
         * the stack */
	SV *maybe_ary = POPs;
	if (SvTYPE(maybe_ary) != SVt_PVAV) {
            /* range */
	    dPOPss;
	    SV * const right = maybe_ary;
	    if (UNLIKELY(cxflags & CXp_FOR_LVREF))
		DIE(aTHX_ "Assigned value is not a reference");
	    SvGETMAGIC(sv);
	    SvGETMAGIC(right);
	    if (RANGE_IS_NUMERIC(sv,right)) {
		cx->cx_type |= CXt_LOOP_LAZYIV;
		if (S_outside_integer(aTHX_ sv) ||
                    S_outside_integer(aTHX_ right))
		    DIE(aTHX_ "Range iterator outside integer range");
		cx->blk_loop.state_u.lazyiv.cur = SvIV_nomg(sv);
		cx->blk_loop.state_u.lazyiv.end = SvIV_nomg(right);
	    }
	    else {
		cx->cx_type |= CXt_LOOP_LAZYSV;
		cx->blk_loop.state_u.lazysv.cur = newSVsv(sv);
		cx->blk_loop.state_u.lazysv.end = right;
		SvREFCNT_inc_simple_void_NN(right);
		(void) SvPV_force_nolen(cx->blk_loop.state_u.lazysv.cur);
		/* This will do the upgrade to SVt_PV, and warn if the value
		   is uninitialised.  */
		(void) SvPV_nolen_const(right);
		/* Doing this avoids a check every time in pp_iter in pp_hot.c
		   to replace !SvOK() with a pointer to "".  */
		if (!SvOK(right)) {
		    SvREFCNT_dec(right);
		    cx->blk_loop.state_u.lazysv.end = &PL_sv_no;
		}
	    }
	}
	else /* SvTYPE(maybe_ary) == SVt_PVAV */ {
            /* for (@@array) {} */
            cx->cx_type |= CXt_LOOP_ARY;
	    cx->blk_loop.state_u.ary.ary = MUTABLE_AV(maybe_ary);
	    SvREFCNT_inc_simple_void_NN(maybe_ary);
	    cx->blk_loop.state_u.ary.ix =
		(PL_op->op_private & OPpITER_REVERSED) ?
		AvFILL(cx->blk_loop.state_u.ary.ary) + 1 :
		-1;
	}
        /* EXTEND(SP, 1) not needed in this branch because we just did POPs */
    }
    else { /* iterating over items on the stack */
        cx->cx_type |= CXt_LOOP_LIST;
        cx->blk_oldsp = SP - PL_stack_base;
	cx->blk_loop.state_u.stack.basesp = MARK - PL_stack_base;
        cx->blk_loop.state_u.stack.ix =
            (PL_op->op_private & OPpITER_REVERSED)
                ? cx->blk_oldsp + 1
                : cx->blk_loop.state_u.stack.basesp;
        /* pre-extend stack so pp_iter doesn't have to check every time
         * it pushes yes/no */
        EXTEND(SP, 1);
    }

    RETURN;
}

PP(pp_enterloop)
{
    PERL_CONTEXT *cx;
    const U8 gimme = GIMME_V;

    cx = cx_pushblock(CXt_LOOP_PLAIN, gimme, PL_stack_sp, PL_savestack_ix);
    cx_pushloop_plain(cx);
    return NORMAL;
}


PP(pp_leaveloop)
{
    PERL_CONTEXT *cx;
    U8 gimme;
    SV **oldsp;
    SV **mark;

    cx = CX_CUR();
    assert(CxTYPE_is_LOOP(cx));
    mark = PL_stack_base + cx->blk_oldsp;
    oldsp = CxTYPE(cx) == CXt_LOOP_LIST
                ? PL_stack_base + cx->blk_loop.state_u.stack.basesp
                : mark;
    gimme = cx->blk_gimme;

    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(MARK, oldsp, gimme,
                                PL_op->op_private & OPpLVALUE ? 3 : 1);

    CX_LEAVE_SCOPE(cx);
    cx_poploop(cx);	/* Stack values are safe: release loop vars ... */
    cx_popblock(cx);
    CX_POP(cx);

    return NORMAL;
}


/* This duplicates most of pp_leavesub, but with additional code to handle
 * return args in lvalue context. It was forked from pp_leavesub to
 * avoid slowing down that function any further.
 *
 * Any changes made to this function may need to be copied to pp_leavesub
 * and vice-versa.
 *
 * also tail-called by pp_return
 */

PP(pp_leavesublv)
{
    U8 gimme;
    PERL_CONTEXT *cx;
    SV **oldsp;
    OP *retop;

    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_SUB);

    if (CxMULTICALL(cx)) {
        /* entry zero of a stack is always PL_sv_undef, which
         * simplifies converting a '()' return into undef in scalar context */
        assert(PL_stack_sp > PL_stack_base || *PL_stack_base == &PL_sv_undef);
	return 0;
    }

    gimme = cx->blk_gimme;
    oldsp = PL_stack_base + cx->blk_oldsp; /* last arg of previous frame */

    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else {
        U8   lval    = CxLVAL(cx);
        bool is_lval = (lval && !(lval & OPpENTERSUB_INARGS));
        const char *what = NULL;

        if (gimme == G_SCALAR) {
            if (is_lval) {
                /* check for bad return arg */
                if (oldsp < PL_stack_sp) {
                    SV *sv = *PL_stack_sp;
                    if ((SvPADTMP(sv) || SvREADONLY(sv))) {
                        what =
                            SvREADONLY(sv) ? (sv == &PL_sv_undef) ? "undef"
                            : "a readonly value" : "a temporary";
                    }
                    else goto ok;
                }
                else {
                    /* sub:lvalue{} will take us here. */
                    what = "undef";
                }
              croak:
                Perl_croak(aTHX_
                          "Can't return %s from lvalue subroutine", what);
            }

          ok:
            leave_adjust_stacks(oldsp, oldsp, gimme, is_lval ? 3 : 2);

            if (lval & OPpDEREF) {
                /* lval_sub()->{...} and similar */
                dSP;
                SvGETMAGIC(TOPs);
                if (!SvOK(TOPs)) {
                    TOPs = vivify_ref(TOPs, CxLVAL(cx) & OPpDEREF);
                }
                PUTBACK;
            }
        }
        else {
            assert(gimme == G_ARRAY);
            assert (!(lval & OPpDEREF));

            if (is_lval) {
                /* scan for bad return args */
                SV **p;
                for (p = PL_stack_sp; p > oldsp; p--) {
                    SV *sv = *p;
                    /* the PL_sv_undef exception is to allow things like
                     * this to work, where PL_sv_undef acts as 'skip'
                     * placeholder on the LHS of list assigns:
                     *    sub foo :lvalue { undef }
                     *    ($a, undef, foo(), $b) = 1..4;
                     */
                    if (sv != &PL_sv_undef && (SvPADTMP(sv) || SvREADONLY(sv)))
                    {
                        /* Might be flattened array after $#array =  */
                        what = SvREADONLY(sv)
                                ? "a readonly value" : "a temporary";
                        goto croak;
                    }
                }
            }

            leave_adjust_stacks(oldsp, oldsp, gimme, is_lval ? 3 : 2);
        }
    }

    CX_LEAVE_SCOPE(cx);
    cx_popsub(cx);	/* Stack values are safe: release CV and @@_ ... */
    cx_popblock(cx);
    retop =  cx->blk_sub.retop;
    CX_POP(cx);

    return retop;
}


PP(pp_return)
{
    dSP; dMARK;
    PERL_CONTEXT *cx;
    const I32 cxix = dopoptosub(cxstack_ix);

    assert(cxstack_ix >= 0);
    if (cxix < cxstack_ix) {
        if (cxix < 0) {
            if (!(       PL_curstackinfo->si_type == PERLSI_SORT
                  || (   PL_curstackinfo->si_type == PERLSI_MULTICALL
                      && (cxstack[0].cx_type & CXp_SUB_RE_FAKE))
                 )
            )
                DIE(aTHX_ "Can't return outside a subroutine");
            /* We must be in:
             *  a sort block, which is a CXt_NULL not a CXt_SUB;
             *  or a /(?{...})/ block.
             * Handle specially. */
            assert(CxTYPE(&cxstack[0]) == CXt_NULL
                    || (   CxTYPE(&cxstack[0]) == CXt_SUB
                        && (cxstack[0].cx_type & CXp_SUB_RE_FAKE)));
            if (cxstack_ix > 0) {
                /* See comment below about context popping. Since we know
                 * we're scalar and not lvalue, we can preserve the return
                 * value in a simpler fashion than there. */
                SV *sv = *SP;
                assert(cxstack[0].blk_gimme == G_SCALAR);
                if (   (sp != PL_stack_base)
                    && !(SvFLAGS(sv) & (SVs_TEMP|SVs_PADTMP))
                )
                    *SP = sv_mortalcopy(sv);
                dounwind(0);
            }
            /* caller responsible for popping cxstack[0] */
            return 0;
        }

        /* There are contexts that need popping. Doing this may free the
         * return value(s), so preserve them first: e.g. popping the plain
         * loop here would free $x:
         *     sub f {  { my $x = 1; return $x } }
         * We may also need to shift the args down; for example,
         *    for (1,2) { return 3,4 }
         * leaves 1,2,3,4 on the stack. Both these actions will be done by
         * leave_adjust_stacks(), along with freeing any temps. Note that
         * whoever we tail-call (e.g. pp_leaveeval) will also call
         * leave_adjust_stacks(); however, the second call is likely to
         * just see a bunch of SvTEMPs with a ref count of 1, and so just
         * pass them through, rather than copying them again. So this
         * isn't as inefficient as it sounds.
         */
        cx = &cxstack[cxix];
        PUTBACK;
        if (cx->blk_gimme != G_VOID)
            leave_adjust_stacks(MARK, PL_stack_base + cx->blk_oldsp,
                    cx->blk_gimme,
                    CxTYPE(cx) == CXt_SUB && CvLVALUE(cx->blk_sub.cv)
                        ? 3 : 0);
        SPAGAIN;
	dounwind(cxix);
        cx = &cxstack[cxix]; /* CX stack may have been realloced */
    }
    else {
        /* Like in the branch above, we need to handle any extra junk on
         * the stack. But because we're not also popping extra contexts, we
         * don't have to worry about prematurely freeing args. So we just
         * need to do the bare minimum to handle junk, and leave the main
         * arg processing in the function we tail call, e.g. pp_leavesub.
         * In list context we have to splice out the junk; in scalar
         * context we can leave as-is (pp_leavesub will later return the
         * top stack element). But for an  empty arg list, e.g.
         *    for (1,2) { return }
         * we need to set sp = oldsp so that pp_leavesub knows to push
         * &PL_sv_undef onto the stack.
         */
        SV **oldsp;
        cx = &cxstack[cxix];
        oldsp = PL_stack_base + cx->blk_oldsp;
        if (oldsp != MARK) {
            SSize_t nargs = SP - MARK;
            if (nargs) {
                if (cx->blk_gimme == G_ARRAY) {
                    /* shift return args to base of call stack frame */
                    Move(MARK + 1, oldsp + 1, nargs, SV*);
                    PL_stack_sp  = oldsp + nargs;
                }
            }
            else
                PL_stack_sp  = oldsp;
        }
    }

    /* fall through to a normal exit */
    switch (CxTYPE(cx)) {
    case CXt_EVAL:
        return CxTRYBLOCK(cx)
            ? Perl_pp_leavetry(aTHX)
            : Perl_pp_leaveeval(aTHX);
    case CXt_SUB:
        return CvLVALUE(cx->blk_sub.cv)
            ? Perl_pp_leavesublv(aTHX)
            : Perl_pp_leavesub(aTHX);
    case CXt_FORMAT:
        return Perl_pp_leavewrite(aTHX);
    default:
	DIE(aTHX_ "panic: return, type=%u", (unsigned) CxTYPE(cx));
    }
}

/* find the enclosing loop or labelled loop and dounwind() back to it. */

static PERL_CONTEXT *
S_unwind_loop(pTHX)
{
    I32 cxix;
    if (PL_op->op_flags & OPf_SPECIAL) {
	cxix = dopoptoloop(cxstack_ix);
	if (cxix < 0)
	    /* diag_listed_as: Can't "last" outside a loop block */
	    Perl_croak(aTHX_ "Can't \"%s\" outside a loop block",
                OP_NAME(PL_op));
    }
    else {
	dSP;
	STRLEN label_len;
	const char * const label =
	    PL_op->op_flags & OPf_STACKED
		? SvPV(TOPs,label_len)
		: (label_len = strlen(cPVOP->op_pv), cPVOP->op_pv);
	const U32 label_flags =
	    PL_op->op_flags & OPf_STACKED
		? SvUTF8(POPs)
		: (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0;
	PUTBACK;
        cxix = dopoptolabel(label, label_len, label_flags);
	if (cxix < 0)
	    /* diag_listed_as: Label not found for "last %s" */
	    Perl_croak(aTHX_ "Label not found for \"%s %"SVf"\"",
				       OP_NAME(PL_op),
                                       SVfARG(PL_op->op_flags & OPf_STACKED
                                              && !SvGMAGICAL(TOPp1s)
                                              ? TOPp1s
                                              : newSVpvn_flags(label,
                                                    label_len,
                                                    label_flags | SVs_TEMP)));
    }
    if (cxix < cxstack_ix)
	dounwind(cxix);
    return &cxstack[cxix];
}


PP(pp_last)
{
    PERL_CONTEXT *cx;
    OP* nextop;

    cx = S_unwind_loop(aTHX);

    assert(CxTYPE_is_LOOP(cx));
    PL_stack_sp = PL_stack_base
                + (CxTYPE(cx) == CXt_LOOP_LIST
                    ?  cx->blk_loop.state_u.stack.basesp
                    : cx->blk_oldsp
                );

    TAINT_NOT;

    /* Stack values are safe: */
    CX_LEAVE_SCOPE(cx);
    cx_poploop(cx);	/* release loop vars ... */
    cx_popblock(cx);
    nextop = cx->blk_loop.my_op->op_lastop->op_next;
    CX_POP(cx);

    return nextop;
}

PP(pp_next)
{
    PERL_CONTEXT *cx;

    /* if not a bare 'next' in the main scope, search for it */
    cx = CX_CUR();
    if (!((PL_op->op_flags & OPf_SPECIAL) && CxTYPE_is_LOOP(cx)))
        cx = S_unwind_loop(aTHX);

    cx_topblock(cx);
    PL_curcop = cx->blk_oldcop;
    PERL_ASYNC_CHECK();
    return (cx)->blk_loop.my_op->op_nextop;
}

PP(pp_redo)
{
    PERL_CONTEXT *cx = S_unwind_loop(aTHX);
    OP* redo_op = cx->blk_loop.my_op->op_redoop;

    if (redo_op->op_type == OP_ENTER) {
	/* pop one less context to avoid $x being freed in while (my $x..) */
	cxstack_ix++;
        cx = CX_CUR();
	assert(CxTYPE(cx) == CXt_BLOCK);
	redo_op = redo_op->op_next;
    }

    FREETMPS;
    CX_LEAVE_SCOPE(cx);
    cx_topblock(cx);
    PL_curcop = cx->blk_oldcop;
    PERL_ASYNC_CHECK();
    return redo_op;
}

STATIC OP *
S_dofindlabel(pTHX_ OP *o, const char *label, STRLEN len, U32 flags, OP **opstack, OP **oplimit)
{
    OP **ops = opstack;
    static const char* const too_deep = "Target of goto is too deeply nested";

    PERL_ARGS_ASSERT_DOFINDLABEL;

    if (ops >= oplimit)
	Perl_croak(aTHX_ "%s", too_deep);
    if (o->op_type == OP_LEAVE ||
	o->op_type == OP_SCOPE ||
	o->op_type == OP_LEAVELOOP ||
	o->op_type == OP_LEAVESUB ||
	o->op_type == OP_LEAVETRY)
    {
	*ops++ = cUNOPo->op_first;
	if (ops >= oplimit)
	    Perl_croak(aTHX_ "%s", too_deep);
    }
    *ops = 0;
    if (o->op_flags & OPf_KIDS) {
	OP *kid;
	/* First try all the kids at this level, since that's likeliest. */
	for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid)) {
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) {
                STRLEN kid_label_len;
                U32 kid_label_flags;
		const char *kid_label = CopLABEL_len_flags(kCOP,
                                                    &kid_label_len, &kid_label_flags);
		if (kid_label && (
                    ( (kid_label_flags & SVf_UTF8) != (flags & SVf_UTF8) ) ?
                        (flags & SVf_UTF8)
                            ? (bytes_cmp_utf8(
                                        (const U8*)kid_label, kid_label_len,
                                        (const U8*)label, len) == 0)
                            : (bytes_cmp_utf8(
                                        (const U8*)label, len,
                                        (const U8*)kid_label, kid_label_len) == 0)
                    : ( len == kid_label_len && ((kid_label == label)
                                    || memEQ(kid_label, label, len)))))
		    return kid;
	    }
	}
	for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid)) {
	    if (kid == PL_lastgotoprobe)
		continue;
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) {
	        if (ops == opstack)
		    *ops++ = kid;
		else if (ops[-1]->op_type == OP_NEXTSTATE ||
		         ops[-1]->op_type == OP_DBSTATE)
		    ops[-1] = kid;
		else
		    *ops++ = kid;
	    }
	    if ((o = dofindlabel(kid, label, len, flags, ops, oplimit)))
		return o;
	}
    }
    *ops = 0;
    return 0;
}


/* also used for: pp_dump() */

PP(pp_goto)
{
    dVAR; dSP;
    OP *retop = NULL;
    I32 ix;
    PERL_CONTEXT *cx;
#define GOTO_DEPTH 64
    OP *enterops[GOTO_DEPTH];
    const char *label = NULL;
    STRLEN label_len = 0;
    U32 label_flags = 0;
    const bool do_dump = (PL_op->op_type == OP_DUMP);
    static const char* const must_have_label = "goto must have label";

    if (PL_op->op_flags & OPf_STACKED) {
        /* goto EXPR  or  goto &foo */

	SV * const sv = POPs;
	SvGETMAGIC(sv);

	if (SvROK(sv) && SvTYPE(SvRV(sv)) == SVt_PVCV) {
            /* This egregious kludge implements goto &subroutine */
	    I32 cxix;
	    PERL_CONTEXT *cx;
	    CV *cv = MUTABLE_CV(SvRV(sv));
	    AV *arg = GvAV(PL_defgv);

	    while (!CvROOT(cv) && !CvXSUB(cv)) {
		const GV * const gv = CvGV(cv);
		if (gv) {
		    GV *autogv;
		    SV *tmpstr;
		    /* autoloaded stub? */
		    if (cv != GvCV(gv) && (cv = GvCV(gv)))
			continue;
		    autogv = gv_autoload_pvn(GvSTASH(gv), GvNAME(gv),
					  GvNAMELEN(gv),
                                          GvNAMEUTF8(gv) ? SVf_UTF8 : 0);
		    if (autogv && (cv = GvCV(autogv)))
			continue;
		    tmpstr = sv_newmortal();
		    gv_efullname3(tmpstr, gv, NULL);
		    DIE(aTHX_ "Goto undefined subroutine &%"SVf"", SVfARG(tmpstr));
		}
		DIE(aTHX_ "Goto undefined subroutine");
	    }

	    cxix = dopoptosub(cxstack_ix);
            if (cxix < 0) {
                DIE(aTHX_ "Can't goto subroutine outside a subroutine");
            }
            cx  = &cxstack[cxix];
	    /* ban goto in eval: see <20050521150056.GC20213@@iabyn.com> */
	    if (CxTYPE(cx) == CXt_EVAL) {
		if (CxREALEVAL(cx))
		/* diag_listed_as: Can't goto subroutine from an eval-%s */
		    DIE(aTHX_ "Can't goto subroutine from an eval-string");
		else
		/* diag_listed_as: Can't goto subroutine from an eval-%s */
		    DIE(aTHX_ "Can't goto subroutine from an eval-block");
	    }
	    else if (CxMULTICALL(cx))
		DIE(aTHX_ "Can't goto subroutine from a sort sub (or similar callback)");

	    /* First do some returnish stuff. */

	    SvREFCNT_inc_simple_void(cv); /* avoid premature free during unwind */
	    FREETMPS;
	    if (cxix < cxstack_ix) {
		dounwind(cxix);
            }
            cx = CX_CUR();
	    cx_topblock(cx);
	    SPAGAIN;

            /* protect @@_ during save stack unwind. */
            if (arg)
                SvREFCNT_inc_NN(sv_2mortal(MUTABLE_SV(arg)));

	    assert(PL_scopestack_ix == cx->blk_oldscopesp);
            CX_LEAVE_SCOPE(cx);

	    if (CxTYPE(cx) == CXt_SUB && CxHASARGS(cx)) {
                /* this is part of cx_popsub_args() */
		AV* av = MUTABLE_AV(PAD_SVl(0));
                assert(AvARRAY(MUTABLE_AV(
                    PadlistARRAY(CvPADLIST(cx->blk_sub.cv))[
                            CvDEPTH(cx->blk_sub.cv)])) == PL_curpad);

                /* we are going to donate the current @@_ from the old sub
                 * to the new sub. This first part of the donation puts a
                 * new empty AV in the pad[0] slot of the old sub,
                 * unless pad[0] and @@_ differ (e.g. if the old sub did
                 * local *_ = []); in which case clear the old pad[0]
                 * array in the usual way */
		if (av == arg || AvREAL(av))
                    clear_defarray(av, av == arg);
		else CLEAR_ARGARRAY(av);
	    }

            /* don't restore PL_comppad here. It won't be needed if the
             * sub we're going to is non-XS, but restoring it early then
             * croaking (e.g. the "Goto undefined subroutine" below)
             * means the CX block gets processed again in dounwind,
             * but this time with the wrong PL_comppad */

	    /* A destructor called during LEAVE_SCOPE could have undefined
	     * our precious cv.  See bug #99850. */
	    if (!CvROOT(cv) && !CvXSUB(cv)) {
		const GV * const gv = CvGV(cv);
		if (gv) {
		    SV * const tmpstr = sv_newmortal();
		    gv_efullname3(tmpstr, gv, NULL);
		    DIE(aTHX_ "Goto undefined subroutine &%"SVf"",
			       SVfARG(tmpstr));
		}
		DIE(aTHX_ "Goto undefined subroutine");
	    }

	    if (CxTYPE(cx) == CXt_SUB) {
		CvDEPTH(cx->blk_sub.cv) = cx->blk_sub.olddepth;
                SvREFCNT_dec_NN(cx->blk_sub.cv);
            }

	    /* Now do some callish stuff. */
	    if (CvISXSUB(cv)) {
		const SSize_t items = arg ? AvFILL(arg) + 1 : 0;
		const bool m = arg ? cBOOL(SvRMAGICAL(arg)) : 0;
		SV** mark;

                ENTER;
                SAVETMPS;
                SAVEFREESV(cv); /* later, undo the 'avoid premature free' hack */

		/* put GvAV(defgv) back onto stack */
		if (items) {
		    EXTEND(SP, items+1); /* @@_ could have been extended. */
		}
		mark = SP;
		if (items) {
		    SSize_t index;
		    bool r = cBOOL(AvREAL(arg));
		    for (index=0; index<items; index++)
		    {
			SV *sv;
			if (m) {
			    SV ** const svp = av_fetch(arg, index, 0);
			    sv = svp ? *svp : NULL;
			}
			else sv = AvARRAY(arg)[index];
			SP[index+1] = sv
			    ? r ? SvREFCNT_inc_NN(sv_2mortal(sv)) : sv
			    : sv_2mortal(newSVavdefelem(arg, index, 1));
		    }
		}
		SP += items;
		if (CxTYPE(cx) == CXt_SUB && CxHASARGS(cx)) {
		    /* Restore old @@_ */
                    CX_POP_SAVEARRAY(cx);
		}

		retop = cx->blk_sub.retop;
                PL_comppad = cx->blk_sub.prevcomppad;
                PL_curpad = LIKELY(PL_comppad) ? AvARRAY(PL_comppad) : NULL;

		/* XS subs don't have a CXt_SUB, so pop it;
                 * this is a cx_popblock(), less all the stuff we already did
                 * for cx_topblock() earlier */
                PL_curcop = cx->blk_oldcop;
                CX_POP(cx);

		/* Push a mark for the start of arglist */
		PUSHMARK(mark);
		PUTBACK;
		(void)(*CvXSUB(cv))(aTHX_ cv);
		LEAVE;
		goto _return;
	    }
	    else {
		PADLIST * const padlist = CvPADLIST(cv);

                SAVEFREESV(cv); /* later, undo the 'avoid premature free' hack */

                /* partial unrolled cx_pushsub(): */

		cx->blk_sub.cv = cv;
		cx->blk_sub.olddepth = CvDEPTH(cv);

		CvDEPTH(cv)++;
                SvREFCNT_inc_simple_void_NN(cv);
		if (CvDEPTH(cv) > 1) {
		    if (CvDEPTH(cv) == PERL_SUB_DEPTH_WARN && ckWARN(WARN_RECURSION))
			sub_crush_depth(cv);
		    pad_push(padlist, CvDEPTH(cv));
		}
		PL_curcop = cx->blk_oldcop;
		PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));
		if (CxHASARGS(cx))
		{
                    /* second half of donating @@_ from the old sub to the
                     * new sub: abandon the original pad[0] AV in the
                     * new sub, and replace it with the donated @@_.
                     * pad[0] takes ownership of the extra refcount
                     * we gave arg earlier */
		    if (arg) {
			SvREFCNT_dec(PAD_SVl(0));
			PAD_SVl(0) = (SV *)arg;
                        SvREFCNT_inc_simple_void_NN(arg);
		    }

		    /* GvAV(PL_defgv) might have been modified on scope
		       exit, so point it at arg again. */
		    if (arg != GvAV(PL_defgv)) {
			AV * const av = GvAV(PL_defgv);
			GvAV(PL_defgv) = (AV *)SvREFCNT_inc_simple(arg);
			SvREFCNT_dec(av);
		    }
		}

		if (PERLDB_SUB) {	/* Checking curstash breaks DProf. */
		    Perl_get_db_sub(aTHX_ NULL, cv);
		    if (PERLDB_GOTO) {
			CV * const gotocv = get_cvs("DB::goto", 0);
			if (gotocv) {
			    PUSHMARK( PL_stack_sp );
			    call_sv(MUTABLE_SV(gotocv), G_SCALAR | G_NODEBUG);
			    PL_stack_sp--;
			}
		    }
		}
		retop = CvSTART(cv);
		goto putback_return;
	    }
	}
	else {
            /* goto EXPR */
	    label       = SvPV_nomg_const(sv, label_len);
            label_flags = SvUTF8(sv);
	}
    }
    else if (!(PL_op->op_flags & OPf_SPECIAL)) {
        /* goto LABEL  or  dump LABEL */
 	label       = cPVOP->op_pv;
        label_flags = (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0;
        label_len   = strlen(label);
    }
    if (!(do_dump || label_len)) DIE(aTHX_ "%s", must_have_label);

    PERL_ASYNC_CHECK();

    if (label_len) {
	OP *gotoprobe = NULL;
	bool leaving_eval = FALSE;
	bool in_block = FALSE;
	PERL_CONTEXT *last_eval_cx = NULL;

	/* find label */

	PL_lastgotoprobe = NULL;
	*enterops = 0;
	for (ix = cxstack_ix; ix >= 0; ix--) {
	    cx = &cxstack[ix];
	    switch (CxTYPE(cx)) {
	    case CXt_EVAL:
		leaving_eval = TRUE;
                if (!CxTRYBLOCK(cx)) {
		    gotoprobe = (last_eval_cx ?
				last_eval_cx->blk_eval.old_eval_root :
				PL_eval_root);
		    last_eval_cx = cx;
		    break;
                }
                /* else fall through */
            case CXt_LOOP_PLAIN:
            case CXt_LOOP_LAZYIV:
            case CXt_LOOP_LAZYSV:
            case CXt_LOOP_LIST:
            case CXt_LOOP_ARY:
	    case CXt_GIVEN:
	    case CXt_WHEN:
		gotoprobe = OpSIBLING(cx->blk_oldcop);
		break;
	    case CXt_SUBST:
		continue;
	    case CXt_BLOCK:
		if (ix) {
		    gotoprobe = OpSIBLING(cx->blk_oldcop);
		    in_block = TRUE;
		} else
		    gotoprobe = PL_main_root;
		break;
	    case CXt_SUB:
		if (CvDEPTH(cx->blk_sub.cv) && !CxMULTICALL(cx)) {
		    gotoprobe = CvROOT(cx->blk_sub.cv);
		    break;
		}
		/* FALLTHROUGH */
	    case CXt_FORMAT:
	    case CXt_NULL:
		DIE(aTHX_ "Can't \"goto\" out of a pseudo block");
	    default:
		if (ix)
		    DIE(aTHX_ "panic: goto, type=%u, ix=%ld",
			CxTYPE(cx), (long) ix);
		gotoprobe = PL_main_root;
		break;
	    }
	    if (gotoprobe) {
                OP *sibl1, *sibl2;

		retop = dofindlabel(gotoprobe, label, label_len, label_flags,
				    enterops, enterops + GOTO_DEPTH);
		if (retop)
		    break;
		if ( (sibl1 = OpSIBLING(gotoprobe)) &&
		     sibl1->op_type == OP_UNSTACK &&
		     (sibl2 = OpSIBLING(sibl1)))
                {
		    retop = dofindlabel(sibl2,
					label, label_len, label_flags, enterops,
					enterops + GOTO_DEPTH);
		    if (retop)
			break;
		}
	    }
	    PL_lastgotoprobe = gotoprobe;
	}
	if (!retop)
	    DIE(aTHX_ "Can't find label %"UTF8f, 
		       UTF8fARG(label_flags, label_len, label));

	/* if we're leaving an eval, check before we pop any frames
           that we're not going to punt, otherwise the error
	   won't be caught */

	if (leaving_eval && *enterops && enterops[1]) {
	    I32 i;
            for (i = 1; enterops[i]; i++)
                if (enterops[i]->op_type == OP_ENTERITER)
                    DIE(aTHX_ "Can't \"goto\" into the middle of a foreach loop");
	}

	if (*enterops && enterops[1]) {
	    I32 i = enterops[1]->op_type == OP_ENTER && in_block ? 2 : 1;
	    if (enterops[i])
		deprecate("\"goto\" to jump into a construct");
	}

	/* pop unwanted frames */

	if (ix < cxstack_ix) {
	    if (ix < 0)
		DIE(aTHX_ "panic: docatch: illegal ix=%ld", (long)ix);
	    dounwind(ix);
            cx = CX_CUR();
	    cx_topblock(cx);
	}

	/* push wanted frames */

	if (*enterops && enterops[1]) {
	    OP * const oldop = PL_op;
	    ix = enterops[1]->op_type == OP_ENTER && in_block ? 2 : 1;
	    for (; enterops[ix]; ix++) {
		PL_op = enterops[ix];
		/* Eventually we may want to stack the needed arguments
		 * for each op.  For now, we punt on the hard ones. */
		if (PL_op->op_type == OP_ENTERITER)
		    DIE(aTHX_ "Can't \"goto\" into the middle of a foreach loop");
		PL_op->op_ppaddr(aTHX);
	    }
	    PL_op = oldop;
	}
    }

    if (do_dump) {
#ifdef VMS
	if (!retop) retop = PL_main_start;
#endif
	PL_restartop = retop;
	PL_do_undump = TRUE;

	my_unexec();

	PL_restartop = 0;		/* hmm, must be GNU unexec().. */
	PL_do_undump = FALSE;
    }

    putback_return:
    PL_stack_sp = sp;
    _return:
    PERL_ASYNC_CHECK();
    return retop;
}

PP(pp_exit)
{
    dSP;
    I32 anum;

    if (MAXARG < 1)
	anum = 0;
    else if (!TOPs) {
	anum = 0; (void)POPs;
    }
    else {
	anum = SvIVx(POPs);
#ifdef VMS
	if (anum == 1
	 && SvTRUE(cop_hints_fetch_pvs(PL_curcop, "vmsish_exit", 0)))
	    anum = 0;
        VMSISH_HUSHED  =
            VMSISH_HUSHED || (PL_curcop->op_private & OPpHUSH_VMSISH);
#endif
    }
    PL_exit_flags |= PERL_EXIT_EXPECTED;
    my_exit(anum);
    PUSHs(&PL_sv_undef);
    RETURN;
}

/* Eval. */

STATIC void
S_save_lines(pTHX_ AV *array, SV *sv)
{
    const char *s = SvPVX_const(sv);
    const char * const send = SvPVX_const(sv) + SvCUR(sv);
    I32 line = 1;

    PERL_ARGS_ASSERT_SAVE_LINES;

    while (s && s < send) {
	const char *t;
	SV * const tmpstr = newSV_type(SVt_PVMG);

	t = (const char *)memchr(s, '\n', send - s);
	if (t)
	    t++;
	else
	    t = send;

	sv_setpvn(tmpstr, s, t - s);
	av_store(array, line++, tmpstr);
	s = t;
    }
}

/*
=for apidoc docatch

Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.

0 is used as continue inside eval,

3 is used for a die caught by an inner eval - continue inner loop

See F<cop.h>: je_mustcatch, when set at any runlevel to TRUE, means eval ops must
establish a local jmpenv to handle exception traps.

=cut
*/
STATIC OP *
S_docatch(pTHX_ OP *o)
{
    int ret;
    OP * const oldop = PL_op;
    dJMPENV;

#ifdef DEBUGGING
    assert(CATCH_GET == TRUE);
#endif
    PL_op = o;

    JMPENV_PUSH(ret);
    switch (ret) {
    case 0:
	assert(cxstack_ix >= 0);
	assert(CxTYPE(CX_CUR()) == CXt_EVAL);
        CX_CUR()->blk_eval.cur_top_env = PL_top_env;
 redo_body:
	CALLRUNOPS(aTHX);
	break;
    case 3:
	/* die caught by an inner eval - continue inner loop */
	if (PL_restartop && PL_restartjmpenv == PL_top_env) {
	    PL_restartjmpenv = NULL;
	    PL_op = PL_restartop;
	    PL_restartop = 0;
	    goto redo_body;
	}
	/* FALLTHROUGH */
    default:
	JMPENV_POP;
	PL_op = oldop;
	JMPENV_JUMP(ret);
	NOT_REACHED; /* NOTREACHED */
    }
    JMPENV_POP;
    PL_op = oldop;
    return NULL;
}


/*
=for apidoc find_runcv

Locate the CV corresponding to the currently executing sub or eval.
If C<db_seqp> is non_null, skip CVs that are in the DB package and populate
C<*db_seqp> with the cop sequence number at the point that the DB:: code was
entered.  (This allows debuggers to eval in the scope of the breakpoint
rather than in the scope of the debugger itself.)

=cut
*/

CV*
Perl_find_runcv(pTHX_ U32 *db_seqp)
{
    return Perl_find_runcv_where(aTHX_ 0, 0, db_seqp);
}

/* If this becomes part of the API, it might need a better name. */
CV *
Perl_find_runcv_where(pTHX_ U8 cond, IV arg, U32 *db_seqp)
{
    PERL_SI	 *si;
    int		 level = 0;

    if (db_seqp)
	*db_seqp =
            PL_curcop == &PL_compiling
                ? PL_cop_seqmax
                : PL_curcop->cop_seq;

    for (si = PL_curstackinfo; si; si = si->si_prev) {
        I32 ix;
	for (ix = si->si_cxix; ix >= 0; ix--) {
	    const PERL_CONTEXT *cx = &(si->si_cxstack[ix]);
	    CV *cv = NULL;
	    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
		cv = cx->blk_sub.cv;
		/* skip DB:: code */
		if (db_seqp && PL_debstash && CvSTASH(cv) == PL_debstash) {
		    *db_seqp = cx->blk_oldcop->cop_seq;
		    continue;
		}
                if (cx->cx_type & CXp_SUB_RE)
                    continue;
	    }
	    else if (CxTYPE(cx) == CXt_EVAL && !CxTRYBLOCK(cx))
		cv = cx->blk_eval.cv;
	    if (cv) {
		switch (cond) {
		case FIND_RUNCV_padid_eq:
		    if (!CvPADLIST(cv)
		     || CvPADLIST(cv)->xpadl_id != (U32)arg)
			continue;
		    return cv;
		case FIND_RUNCV_level_eq:
		    if (level++ != arg) continue;
		    /* GERONIMO! */
		default:
		    return cv;
		}
	    }
	}
    }
    return cond == FIND_RUNCV_padid_eq ? NULL : PL_main_cv;
}


/* Run yyparse() in a setjmp wrapper. Returns:
 *   0: yyparse() successful
 *   1: yyparse() failed
 *   3: yyparse() died
 */
STATIC int
S_try_yyparse(pTHX_ int gramtype)
{
    int ret;
    dJMPENV;

    assert(CxTYPE(CX_CUR()) == CXt_EVAL);
    JMPENV_PUSH(ret);
    switch (ret) {
    case 0:
	ret = yyparse(gramtype) ? 1 : 0;
	break;
    case 3:
	break;
    default:
	JMPENV_POP;
	JMPENV_JUMP(ret);
	NOT_REACHED; /* NOTREACHED */
    }
    JMPENV_POP;
    return ret;
}


/* Compile a require/do or an eval ''.
 *
 * outside is the lexically enclosing CV (if any) that invoked us.
 * seq     is the current COP scope value.
 * hh      is the saved hints hash, if any.
 *
 * Returns a bool indicating whether the compile was successful; if so,
 * PL_eval_start contains the first op of the compiled code; otherwise,
 * pushes undef.
 *
 * This function is called from two places: pp_require and pp_entereval.
 * These can be distinguished by whether PL_op is entereval.
 */

STATIC bool
S_doeval_compile(pTHX_ U8 gimme, CV* outside, U32 seq, HV *hh)
{
    dSP;
    OP * const saveop = PL_op;
    bool clear_hints = saveop->op_type != OP_ENTEREVAL;
    COP * const oldcurcop = PL_curcop;
    bool in_require = (saveop->op_type == OP_REQUIRE);
    int yystatus;
    CV *evalcv;

    PL_in_eval = (in_require
		  ? (EVAL_INREQUIRE | (PL_in_eval & EVAL_INEVAL))
		  : (EVAL_INEVAL |
                        ((PL_op->op_private & OPpEVAL_RE_REPARSING)
                            ? EVAL_RE_REPARSING : 0)));

    PUSHMARK(SP);

    evalcv = MUTABLE_CV(newSV_type(SVt_PVCV));
    CvEVAL_on(evalcv);
    assert(CxTYPE(CX_CUR()) == CXt_EVAL);
    CX_CUR()->blk_eval.cv = evalcv;
    CX_CUR()->blk_gimme = gimme;

    CvOUTSIDE_SEQ(evalcv) = seq;
    CvOUTSIDE(evalcv) = MUTABLE_CV(SvREFCNT_inc_simple(outside));

    /* set up a scratch pad */

    CvPADLIST_set(evalcv, pad_new(padnew_SAVE));
    PL_op = NULL; /* avoid PL_op and PL_curpad referring to different CVs */


    SAVEMORTALIZESV(evalcv);	/* must remain until end of current statement */

    /* make sure we compile in the right package */

    if (CopSTASH_ne(PL_curcop, PL_curstash)) {
	SAVEGENERICSV(PL_curstash);
	PL_curstash = (HV *)CopSTASH(PL_curcop);
	if (SvTYPE(PL_curstash) != SVt_PVHV) PL_curstash = NULL;
	else SvREFCNT_inc_simple_void(PL_curstash);
    }
    /* XXX:ajgo do we really need to alloc an AV for begin/checkunit */
    SAVESPTR(PL_beginav);
    PL_beginav = newAV();
    SAVEFREESV(PL_beginav);
    SAVESPTR(PL_unitcheckav);
    PL_unitcheckav = newAV();
    SAVEFREESV(PL_unitcheckav);


    ENTER_with_name("evalcomp");
    SAVESPTR(PL_compcv);
    PL_compcv = evalcv;

    /* try to compile it */

    PL_eval_root = NULL;
    PL_curcop = &PL_compiling;
    if ((saveop->op_type != OP_REQUIRE) && (saveop->op_flags & OPf_SPECIAL))
	PL_in_eval |= EVAL_KEEPERR;
    else
	CLEAR_ERRSV();

    SAVEHINTS();
    if (clear_hints) {
	PL_hints = 0;
	hv_clear(GvHV(PL_hintgv));
    }
    else {
	PL_hints = saveop->op_private & OPpEVAL_COPHH
		     ? oldcurcop->cop_hints : saveop->op_targ;

        /* making 'use re eval' not be in scope when compiling the
         * qr/mabye_has_runtime_code_block/ ensures that we don't get
         * infinite recursion when S_has_runtime_code() gives a false
         * positive: the second time round, HINT_RE_EVAL isn't set so we
         * don't bother calling S_has_runtime_code() */
        if (PL_in_eval & EVAL_RE_REPARSING)
            PL_hints &= ~HINT_RE_EVAL;

	if (hh) {
	    /* SAVEHINTS created a new HV in PL_hintgv, which we need to GC */
	    SvREFCNT_dec(GvHV(PL_hintgv));
	    GvHV(PL_hintgv) = hh;
	}
    }
    SAVECOMPILEWARNINGS();
    if (clear_hints) {
	if (PL_dowarn & G_WARN_ALL_ON)
	    PL_compiling.cop_warnings = pWARN_ALL ;
	else if (PL_dowarn & G_WARN_ALL_OFF)
	    PL_compiling.cop_warnings = pWARN_NONE ;
	else
	    PL_compiling.cop_warnings = pWARN_STD ;
    }
    else {
	PL_compiling.cop_warnings =
	    DUP_WARNINGS(oldcurcop->cop_warnings);
	cophh_free(CopHINTHASH_get(&PL_compiling));
	if (Perl_cop_fetch_label(aTHX_ oldcurcop, NULL, NULL)) {
	    /* The label, if present, is the first entry on the chain. So rather
	       than writing a blank label in front of it (which involves an
	       allocation), just use the next entry in the chain.  */
	    PL_compiling.cop_hints_hash
		= cophh_copy(oldcurcop->cop_hints_hash->refcounted_he_next);
	    /* Check the assumption that this removed the label.  */
	    assert(Perl_cop_fetch_label(aTHX_ &PL_compiling, NULL, NULL) == NULL);
	}
	else
	    PL_compiling.cop_hints_hash = cophh_copy(oldcurcop->cop_hints_hash);
    }

    CALL_BLOCK_HOOKS(bhk_eval, saveop);

    /* note that yyparse() may raise an exception, e.g. C<BEGIN{die}>,
     * so honour CATCH_GET and trap it here if necessary */


    /* compile the code */
    yystatus = (!in_require && CATCH_GET) ? S_try_yyparse(aTHX_ GRAMPROG) : yyparse(GRAMPROG);

    if (yystatus || PL_parser->error_count || !PL_eval_root) {
        SV *namesv = NULL; /* initialise  to avoid compiler warning */
	PERL_CONTEXT *cx;
        SV *errsv;

	PL_op = saveop;
	/* note that if yystatus == 3, then the require/eval died during
         * compilation, so the EVAL CX block has already been popped, and
         * various vars restored */
	if (yystatus != 3) {
	    if (PL_eval_root) {
		op_free(PL_eval_root);
		PL_eval_root = NULL;
	    }
	    SP = PL_stack_base + POPMARK;	/* pop original mark */
            cx = CX_CUR();
            CX_LEAVE_SCOPE(cx);
	    cx_popeval(cx);
	    cx_popblock(cx);
            if (in_require)
                namesv = cx->blk_eval.old_namesv;
            CX_POP(cx);
	}

	errsv = ERRSV;
	if (in_require) {
            if (yystatus == 3) {
                cx = CX_CUR();
                assert(CxTYPE(cx) == CXt_EVAL);
                namesv = cx->blk_eval.old_namesv;
            }
            S_undo_inc_then_croak(aTHX_ namesv, errsv, FALSE);
            NOT_REACHED; /* NOTREACHED */
	}

        if (!*(SvPV_nolen_const(errsv)))
            sv_setpvs(errsv, "Compilation error");

	if (gimme != G_ARRAY) PUSHs(&PL_sv_undef);
	PUTBACK;
	return FALSE;
    }

    /* Compilation successful. Now clean up */

    LEAVE_with_name("evalcomp");

    CopLINE_set(&PL_compiling, 0);
    SAVEFREEOP(PL_eval_root);
    cv_forget_slab(evalcv);

    DEBUG_x(dump_eval());

    /* Register with debugger: */
    if (PERLDB_INTER && saveop->op_type == OP_REQUIRE) {
	CV * const cv = get_cvs("DB::postponed", 0);
	if (cv) {
	    dSP;
	    PUSHMARK(SP);
	    XPUSHs(MUTABLE_SV(CopFILEGV(&PL_compiling)));
	    PUTBACK;
	    call_sv(MUTABLE_SV(cv), G_DISCARD);
	}
    }

    if (PL_unitcheckav) {
	OP *es = PL_eval_start;
	call_list(PL_scopestack_ix, PL_unitcheckav);
	PL_eval_start = es;
    }

    CvDEPTH(evalcv) = 1;
    SP = PL_stack_base + POPMARK;		/* pop original mark */
    PL_op = saveop;			/* The caller may need it. */
    PL_parser->lex_state = LEX_NOTPARSING;	/* $^S needs this. */

    PUTBACK;
    return TRUE;
}


STATIC PerlIO *
S_check_type_and_open(pTHX_ SV *name)
{
    Stat_t st;
    STRLEN len;
    PerlIO * retio;
    const char *p = SvPV_const(name, len);
    int st_rc;

    PERL_ARGS_ASSERT_CHECK_TYPE_AND_OPEN;

    /* checking here captures a reasonable error message when
     * PERL_DISABLE_PMC is true, but when PMC checks are enabled, the
     * user gets a confusing message about looking for the .pmc file
     * rather than for the .pm file so do the check in S_doopen_pm when
     * PMC is on instead of here. S_doopen_pm calls this func.
     * This check prevents a \0 in @@INC causing problems.
     */
#ifdef PERL_DISABLE_PMC
    if (!IS_SAFE_PATHNAME(p, len, "require"))
        return NULL;
#endif

    /* on Win32 stat is expensive (it does an open() and close() twice and
       a couple other IO calls), the open will fail with a dir on its own with
       errno EACCES, so only do a stat to separate a dir from a real EACCES
       caused by user perms */
#ifndef WIN32
    /* we use the value of errno later to see how stat() or open() failed.
     * We don't want it set if the stat succeeded but we still failed,
     * such as if the name exists, but is a directory */
    errno = 0;

    st_rc = PerlLIO_stat(p, &st);

    if (st_rc < 0 || S_ISDIR(st.st_mode) || S_ISBLK(st.st_mode)) {
	return NULL;
    }
#endif

    retio = PerlIO_openn(aTHX_ ":", PERL_SCRIPT_MODE, -1, 0, 0, NULL, 1, &name);
#ifdef WIN32
    /* EACCES stops the INC search early in pp_require to implement
       feature RT #113422 */
    if(!retio && errno == EACCES) { /* exists but probably a directory */
	int eno;
	st_rc = PerlLIO_stat(p, &st);
	if (st_rc >= 0) {
	    if(S_ISDIR(st.st_mode) || S_ISBLK(st.st_mode))
		eno = 0;
	    else
		eno = EACCES;
	    errno = eno;
	}
    }
#endif
    return retio;
}

#ifndef PERL_DISABLE_PMC
STATIC PerlIO *
S_doopen_pm(pTHX_ SV *name)
{
    STRLEN namelen;
    const char *p = SvPV_const(name, namelen);

    PERL_ARGS_ASSERT_DOOPEN_PM;

    /* check the name before trying for the .pmc name to avoid the
     * warning referring to the .pmc which the user probably doesn't
     * know or care about
     */
    if (!IS_SAFE_PATHNAME(p, namelen, "require"))
        return NULL;

    if (namelen > 3 && memEQs(p + namelen - 3, 3, ".pm")) {
	SV *const pmcsv = sv_newmortal();
	PerlIO * pmcio;

	SvSetSV_nosteal(pmcsv,name);
	sv_catpvs(pmcsv, "c");

	pmcio = check_type_and_open(pmcsv);
	if (pmcio)
	    return pmcio;
    }
    return check_type_and_open(name);
}
#else
#  define doopen_pm(name) check_type_and_open(name)
#endif /* !PERL_DISABLE_PMC */

/* require doesn't search for absolute names, or when the name is
   explicitly relative the current directory */
PERL_STATIC_INLINE bool
S_path_is_searchable(const char *name)
{
    PERL_ARGS_ASSERT_PATH_IS_SEARCHABLE;

    if (PERL_FILE_IS_ABSOLUTE(name)
#ifdef WIN32
	|| (*name == '.' && ((name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/'))
			 || (name[1] == '\\' ||
			     ( name[1] == '.' && name[2] == '\\')))
	    )
#else
	|| (*name == '.' && (name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/')))
#endif
	 )
    {
	return FALSE;
    }
    else
	return TRUE;
}


/* also used for: pp_dofile() */

PP(pp_require)
{
    dSP;
    PERL_CONTEXT *cx;
    SV *sv;
    const char *name;
    STRLEN len;
    char * unixname;
    STRLEN unixlen;
#ifdef VMS
    int vms_unixname = 0;
    char *unixdir;
#endif
    const char *tryname = NULL;
    SV *namesv = NULL;
    const U8 gimme = GIMME_V;
    int filter_has_file = 0;
    PerlIO *tryrsfp = NULL;
    SV *filter_cache = NULL;
    SV *filter_state = NULL;
    SV *filter_sub = NULL;
    SV *hook_sv = NULL;
    OP *op;
    int saved_errno;
    bool path_searchable;
    I32 old_savestack_ix;

    sv = POPs;
    SvGETMAGIC(sv);
    if ( (SvNIOKp(sv) || SvVOK(sv)) && PL_op->op_type != OP_DOFILE) {
	sv = sv_2mortal(new_version(sv));
	if (!Perl_sv_derived_from_pvn(aTHX_ PL_patchlevel, STR_WITH_LEN("version"), 0))
	    upg_version(PL_patchlevel, TRUE);
	if (cUNOP->op_first->op_type == OP_CONST && cUNOP->op_first->op_private & OPpCONST_NOVER) {
	    if ( vcmp(sv,PL_patchlevel) <= 0 )
		DIE(aTHX_ "Perls since %"SVf" too modern--this is %"SVf", stopped",
		    SVfARG(sv_2mortal(vnormal(sv))),
		    SVfARG(sv_2mortal(vnormal(PL_patchlevel)))
		);
	}
	else {
	    if ( vcmp(sv,PL_patchlevel) > 0 ) {
		I32 first = 0;
		AV *lav;
		SV * const req = SvRV(sv);
		SV * const pv = *hv_fetchs(MUTABLE_HV(req), "original", FALSE);

		/* get the left hand term */
		lav = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(req), "version", FALSE)));

		first  = SvIV(*av_fetch(lav,0,0));
		if (   first > (int)PERL_REVISION    /* probably 'use 6.0' */
		    || hv_exists(MUTABLE_HV(req), "qv", 2 ) /* qv style */
		    || av_tindex(lav) > 1            /* FP with > 3 digits */
		    || strstr(SvPVX(pv),".0")        /* FP with leading 0 */
		   ) {
		    DIE(aTHX_ "Perl %"SVf" required--this is only "
		    	"%"SVf", stopped",
			SVfARG(sv_2mortal(vnormal(req))),
			SVfARG(sv_2mortal(vnormal(PL_patchlevel)))
		    );
		}
		else { /* probably 'use 5.10' or 'use 5.8' */
		    SV *hintsv;
		    I32 second = 0;

		    if (av_tindex(lav)>=1)
			second = SvIV(*av_fetch(lav,1,0));

		    second /= second >= 600  ? 100 : 10;
		    hintsv = Perl_newSVpvf(aTHX_ "v%d.%d.0",
					   (int)first, (int)second);
		    upg_version(hintsv, TRUE);

		    DIE(aTHX_ "Perl %"SVf" required (did you mean %"SVf"?)"
		    	"--this is only %"SVf", stopped",
			SVfARG(sv_2mortal(vnormal(req))),
			SVfARG(sv_2mortal(vnormal(sv_2mortal(hintsv)))),
			SVfARG(sv_2mortal(vnormal(PL_patchlevel)))
		    );
		}
	    }
	}

	RETPUSHYES;
    }
    if (!SvOK(sv))
        DIE(aTHX_ "Missing or undefined argument to require");
    name = SvPV_nomg_const(sv, len);
    if (!(name && len > 0 && *name))
        DIE(aTHX_ "Missing or undefined argument to require");

    if (!IS_SAFE_PATHNAME(name, len, "require")) {
        DIE(aTHX_ "Can't locate %s:   %s",
            pv_escape(newSVpvs_flags("",SVs_TEMP),SvPVX(sv),SvCUR(sv),
                      SvCUR(sv)*2,NULL, SvUTF8(sv)?PERL_PV_ESCAPE_UNI:0),
            Strerror(ENOENT));
    }
    TAINT_PROPER("require");

    path_searchable = path_is_searchable(name);

#ifdef VMS
    /* The key in the %ENV hash is in the syntax of file passed as the argument
     * usually this is in UNIX format, but sometimes in VMS format, which
     * can result in a module being pulled in more than once.
     * To prevent this, the key must be stored in UNIX format if the VMS
     * name can be translated to UNIX.
     */
    
    if ((unixname =
	  tounixspec(name, SvPVX(sv_2mortal(newSVpv("", VMS_MAXRSS-1)))))
	 != NULL) {
	unixlen = strlen(unixname);
	vms_unixname = 1;
    }
    else
#endif
    {
        /* if not VMS or VMS name can not be translated to UNIX, pass it
	 * through.
	 */
	unixname = (char *) name;
	unixlen = len;
    }
    if (PL_op->op_type == OP_REQUIRE) {
	SV * const * const svp = hv_fetch(GvHVn(PL_incgv),
					  unixname, unixlen, 0);
	if ( svp ) {
	    if (*svp != &PL_sv_undef)
		RETPUSHYES;
	    else
		DIE(aTHX_ "Attempt to reload %s aborted.\n"
			    "Compilation failed in require", unixname);
	}
    }

    PERL_DTRACE_PROBE_FILE_LOADING(unixname);

    /* prepare to compile file */

    if (!path_searchable) {
	/* At this point, name is SvPVX(sv)  */
	tryname = name;
	tryrsfp = doopen_pm(sv);
    }
    if (!tryrsfp && !(errno == EACCES && !path_searchable)) {
	AV * const ar = GvAVn(PL_incgv);
	SSize_t i;
#ifdef VMS
	if (vms_unixname)
#endif
	{
	    SV *nsv = sv;
	    namesv = newSV_type(SVt_PV);
	    for (i = 0; i <= AvFILL(ar); i++) {
		SV * const dirsv = *av_fetch(ar, i, TRUE);

		SvGETMAGIC(dirsv);
		if (SvROK(dirsv)) {
		    int count;
		    SV **svp;
		    SV *loader = dirsv;

		    if (SvTYPE(SvRV(loader)) == SVt_PVAV
			&& !SvOBJECT(SvRV(loader)))
		    {
			loader = *av_fetch(MUTABLE_AV(SvRV(loader)), 0, TRUE);
			SvGETMAGIC(loader);
		    }

		    Perl_sv_setpvf(aTHX_ namesv, "/loader/0x%"UVxf"/%s",
				   PTR2UV(SvRV(dirsv)), name);
		    tryname = SvPVX_const(namesv);
		    tryrsfp = NULL;

		    if (SvPADTMP(nsv)) {
			nsv = sv_newmortal();
			SvSetSV_nosteal(nsv,sv);
		    }

		    ENTER_with_name("call_INC");
		    SAVETMPS;
		    EXTEND(SP, 2);

		    PUSHMARK(SP);
		    PUSHs(dirsv);
		    PUSHs(nsv);
		    PUTBACK;
		    if (SvGMAGICAL(loader)) {
			SV *l = sv_newmortal();
			sv_setsv_nomg(l, loader);
			loader = l;
		    }
		    if (sv_isobject(loader))
			count = call_method("INC", G_ARRAY);
		    else
			count = call_sv(loader, G_ARRAY);
		    SPAGAIN;

		    if (count > 0) {
			int i = 0;
			SV *arg;

			SP -= count - 1;
			arg = SP[i++];

			if (SvROK(arg) && (SvTYPE(SvRV(arg)) <= SVt_PVLV)
			    && !isGV_with_GP(SvRV(arg))) {
			    filter_cache = SvRV(arg);

			    if (i < count) {
				arg = SP[i++];
			    }
			}

			if (SvROK(arg) && isGV_with_GP(SvRV(arg))) {
			    arg = SvRV(arg);
			}

			if (isGV_with_GP(arg)) {
			    IO * const io = GvIO((const GV *)arg);

			    ++filter_has_file;

			    if (io) {
				tryrsfp = IoIFP(io);
				if (IoOFP(io) && IoOFP(io) != IoIFP(io)) {
				    PerlIO_close(IoOFP(io));
				}
				IoIFP(io) = NULL;
				IoOFP(io) = NULL;
			    }

			    if (i < count) {
				arg = SP[i++];
			    }
			}

			if (SvROK(arg) && SvTYPE(SvRV(arg)) == SVt_PVCV) {
			    filter_sub = arg;
			    SvREFCNT_inc_simple_void_NN(filter_sub);

			    if (i < count) {
				filter_state = SP[i];
				SvREFCNT_inc_simple_void(filter_state);
			    }
			}

			if (!tryrsfp && (filter_cache || filter_sub)) {
			    tryrsfp = PerlIO_open(BIT_BUCKET,
						  PERL_SCRIPT_MODE);
			}
			SP--;
		    }

		    /* FREETMPS may free our filter_cache */
		    SvREFCNT_inc_simple_void(filter_cache);

		    PUTBACK;
		    FREETMPS;
		    LEAVE_with_name("call_INC");

		    /* Now re-mortalize it. */
		    sv_2mortal(filter_cache);

		    /* Adjust file name if the hook has set an %INC entry.
		       This needs to happen after the FREETMPS above.  */
		    svp = hv_fetch(GvHVn(PL_incgv), name, len, 0);
		    if (svp)
			tryname = SvPV_nolen_const(*svp);

		    if (tryrsfp) {
			hook_sv = dirsv;
			break;
		    }

		    filter_has_file = 0;
		    filter_cache = NULL;
		    if (filter_state) {
			SvREFCNT_dec_NN(filter_state);
			filter_state = NULL;
		    }
		    if (filter_sub) {
			SvREFCNT_dec_NN(filter_sub);
			filter_sub = NULL;
		    }
		}
		else {
		  if (path_searchable) {
		    const char *dir;
		    STRLEN dirlen;

		    if (SvOK(dirsv)) {
			dir = SvPV_nomg_const(dirsv, dirlen);
		    } else {
			dir = "";
			dirlen = 0;
		    }

		    if (!IS_SAFE_SYSCALL(dir, dirlen, "@@INC entry", "require"))
			continue;
#ifdef VMS
		    if ((unixdir =
			  tounixpath(dir, SvPVX(sv_2mortal(newSVpv("", VMS_MAXRSS-1)))))
			 == NULL)
			continue;
		    sv_setpv(namesv, unixdir);
		    sv_catpv(namesv, unixname);
#else
#  ifdef __SYMBIAN32__
		    if (PL_origfilename[0] &&
			PL_origfilename[1] == ':' &&
			!(dir[0] && dir[1] == ':'))
		        Perl_sv_setpvf(aTHX_ namesv,
				       "%c:%s\\%s",
				       PL_origfilename[0],
				       dir, name);
		    else
		        Perl_sv_setpvf(aTHX_ namesv,
				       "%s\\%s",
				       dir, name);
#  else
		    /* The equivalent of		    
		       Perl_sv_setpvf(aTHX_ namesv, "%s/%s", dir, name);
		       but without the need to parse the format string, or
		       call strlen on either pointer, and with the correct
		       allocation up front.  */
		    {
			char *tmp = SvGROW(namesv, dirlen + len + 2);

			memcpy(tmp, dir, dirlen);
			tmp +=dirlen;

			/* Avoid '<dir>//<file>' */
			if (!dirlen || *(tmp-1) != '/') {
			    *tmp++ = '/';
			} else {
			    /* So SvCUR_set reports the correct length below */
			    dirlen--;
			}

			/* name came from an SV, so it will have a '\0' at the
			   end that we can copy as part of this memcpy().  */
			memcpy(tmp, name, len + 1);

			SvCUR_set(namesv, dirlen + len + 1);
			SvPOK_on(namesv);
		    }
#  endif
#endif
		    TAINT_PROPER("require");
		    tryname = SvPVX_const(namesv);
		    tryrsfp = doopen_pm(namesv);
		    if (tryrsfp) {
			if (tryname[0] == '.' && tryname[1] == '/') {
			    ++tryname;
			    while (*++tryname == '/') {}
			}
			break;
		    }
                    else if (errno == EMFILE || errno == EACCES) {
                        /* no point in trying other paths if out of handles;
                         * on the other hand, if we couldn't open one of the
                         * files, then going on with the search could lead to
                         * unexpected results; see perl #113422
                         */
                        break;
                    }
		  }
		}
	    }
	}
    }
    saved_errno = errno; /* sv_2mortal can realloc things */
    sv_2mortal(namesv);
    if (!tryrsfp) {
	if (PL_op->op_type == OP_REQUIRE) {
	    if(saved_errno == EMFILE || saved_errno == EACCES) {
		/* diag_listed_as: Can't locate %s */
		DIE(aTHX_ "Can't locate %s:   %s: %s",
		    name, tryname, Strerror(saved_errno));
	    } else {
	        if (namesv) {			/* did we lookup @@INC? */
		    AV * const ar = GvAVn(PL_incgv);
		    SSize_t i;
		    SV *const msg = newSVpvs_flags("", SVs_TEMP);
		    SV *const inc = newSVpvs_flags("", SVs_TEMP);
		    for (i = 0; i <= AvFILL(ar); i++) {
			sv_catpvs(inc, " ");
			sv_catsv(inc, *av_fetch(ar, i, TRUE));
		    }
		    if (len >= 4 && memEQ(name + len - 3, ".pm", 4)) {
			const char *c, *e = name + len - 3;
			sv_catpv(msg, " (you may need to install the ");
			for (c = name; c < e; c++) {
			    if (*c == '/') {
				sv_catpvs(msg, "::");
			    }
			    else {
				sv_catpvn(msg, c, 1);
			    }
			}
			sv_catpv(msg, " module)");
		    }
		    else if (len >= 2 && memEQ(name + len - 2, ".h", 3)) {
			sv_catpv(msg, " (change .h to .ph maybe?) (did you run h2ph?)");
		    }
		    else if (len >= 3 && memEQ(name + len - 3, ".ph", 4)) {
			sv_catpv(msg, " (did you run h2ph?)");
		    }

		    /* diag_listed_as: Can't locate %s */
		    DIE(aTHX_
			"Can't locate %s in @@INC%" SVf " (@@INC contains:%" SVf ")",
			name, msg, inc);
		}
	    }
	    DIE(aTHX_ "Can't locate %s", name);
	}

	CLEAR_ERRSV();
	RETPUSHUNDEF;
    }
    else
	SETERRNO(0, SS_NORMAL);

    /* Assume success here to prevent recursive requirement. */
    /* name is never assigned to again, so len is still strlen(name)  */
    /* Check whether a hook in @@INC has already filled %INC */
    if (!hook_sv) {
	(void)hv_store(GvHVn(PL_incgv),
		       unixname, unixlen, newSVpv(tryname,0),0);
    } else {
	SV** const svp = hv_fetch(GvHVn(PL_incgv), unixname, unixlen, 0);
	if (!svp)
	    (void)hv_store(GvHVn(PL_incgv),
			   unixname, unixlen, SvREFCNT_inc_simple(hook_sv), 0 );
    }

    old_savestack_ix = PL_savestack_ix;
    SAVECOPFILE_FREE(&PL_compiling);
    CopFILE_set(&PL_compiling, tryname);
    lex_start(NULL, tryrsfp, 0);

    if (filter_sub || filter_cache) {
	/* We can use the SvPV of the filter PVIO itself as our cache, rather
	   than hanging another SV from it. In turn, filter_add() optionally
	   takes the SV to use as the filter (or creates a new SV if passed
	   NULL), so simply pass in whatever value filter_cache has.  */
	SV * const fc = filter_cache ? newSV(0) : NULL;
	SV *datasv;
	if (fc) sv_copypv(fc, filter_cache);
	datasv = filter_add(S_run_user_filter, fc);
	IoLINES(datasv) = filter_has_file;
	IoTOP_GV(datasv) = MUTABLE_GV(filter_state);
	IoBOTTOM_GV(datasv) = MUTABLE_GV(filter_sub);
    }

    /* switch to eval mode */
    cx = cx_pushblock(CXt_EVAL, gimme, SP, old_savestack_ix);
    cx_pusheval(cx, PL_op->op_next, newSVpv(name, 0));

    SAVECOPLINE(&PL_compiling);
    CopLINE_set(&PL_compiling, 0);

    PUTBACK;

    if (doeval_compile(gimme, NULL, PL_curcop->cop_seq, NULL))
	op = DOCATCH(PL_eval_start);
    else
	op = PL_op->op_next;

    PERL_DTRACE_PROBE_FILE_LOADED(unixname);

    return op;
}

/* This is a op added to hold the hints hash for
   pp_entereval. The hash can be modified by the code
   being eval'ed, so we return a copy instead. */

PP(pp_hintseval)
{
    dSP;
    mXPUSHs(MUTABLE_SV(hv_copy_hints_hv(MUTABLE_HV(cSVOP_sv))));
    RETURN;
}


PP(pp_entereval)
{
    dSP;
    PERL_CONTEXT *cx;
    SV *sv;
    const U8 gimme = GIMME_V;
    const U32 was = PL_breakable_sub_gen;
    char tbuf[TYPE_DIGITS(long) + 12];
    bool saved_delete = FALSE;
    char *tmpbuf = tbuf;
    STRLEN len;
    CV* runcv;
    U32 seq, lex_flags = 0;
    HV *saved_hh = NULL;
    const bool bytes = PL_op->op_private & OPpEVAL_BYTES;
    I32 old_savestack_ix;

    if (PL_op->op_private & OPpEVAL_HAS_HH) {
	saved_hh = MUTABLE_HV(SvREFCNT_inc(POPs));
    }
    else if (PL_hints & HINT_LOCALIZE_HH || (
	        PL_op->op_private & OPpEVAL_COPHH
	     && PL_curcop->cop_hints & HINT_LOCALIZE_HH
	    )) {
	saved_hh = cop_hints_2hv(PL_curcop, 0);
	hv_magic(saved_hh, NULL, PERL_MAGIC_hints);
    }
    sv = POPs;
    if (!SvPOK(sv)) {
	/* make sure we've got a plain PV (no overload etc) before testing
	 * for taint. Making a copy here is probably overkill, but better
	 * safe than sorry */
	STRLEN len;
	const char * const p = SvPV_const(sv, len);

	sv = newSVpvn_flags(p, len, SVs_TEMP | SvUTF8(sv));
	lex_flags |= LEX_START_COPIED;

	if (bytes && SvUTF8(sv))
	    SvPVbyte_force(sv, len);
    }
    else if (bytes && SvUTF8(sv)) {
	/* Don't modify someone else's scalar */
	STRLEN len;
	sv = newSVsv(sv);
	(void)sv_2mortal(sv);
	SvPVbyte_force(sv,len);
	lex_flags |= LEX_START_COPIED;
    }

    TAINT_IF(SvTAINTED(sv));
    TAINT_PROPER("eval");

    old_savestack_ix = PL_savestack_ix;

    lex_start(sv, NULL, lex_flags | (PL_op->op_private & OPpEVAL_UNICODE
			   ? LEX_IGNORE_UTF8_HINTS
			   : bytes ? LEX_EVALBYTES : LEX_START_SAME_FILTER
			)
	     );

    /* switch to eval mode */

    if (PERLDB_NAMEEVAL && CopLINE(PL_curcop)) {
	SV * const temp_sv = sv_newmortal();
	Perl_sv_setpvf(aTHX_ temp_sv, "_<(eval %lu)[%s:%"IVdf"]",
		       (unsigned long)++PL_evalseq,
		       CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
	tmpbuf = SvPVX(temp_sv);
	len = SvCUR(temp_sv);
    }
    else
	len = my_snprintf(tmpbuf, sizeof(tbuf), "_<(eval %lu)", (unsigned long)++PL_evalseq);
    SAVECOPFILE_FREE(&PL_compiling);
    CopFILE_set(&PL_compiling, tmpbuf+2);
    SAVECOPLINE(&PL_compiling);
    CopLINE_set(&PL_compiling, 1);
    /* special case: an eval '' executed within the DB package gets lexically
     * placed in the first non-DB CV rather than the current CV - this
     * allows the debugger to execute code, find lexicals etc, in the
     * scope of the code being debugged. Passing &seq gets find_runcv
     * to do the dirty work for us */
    runcv = find_runcv(&seq);

    cx = cx_pushblock((CXt_EVAL|CXp_REAL), gimme, SP, old_savestack_ix);
    cx_pusheval(cx, PL_op->op_next, NULL);

    /* prepare to compile string */

    if (PERLDB_LINE_OR_SAVESRC && PL_curstash != PL_debstash)
	save_lines(CopFILEAV(&PL_compiling), PL_parser->linestr);
    else {
	/* XXX For C<eval "...">s within BEGIN {} blocks, this ends up
	   deleting the eval's FILEGV from the stash before gv_check() runs
	   (i.e. before run-time proper). To work around the coredump that
	   ensues, we always turn GvMULTI_on for any globals that were
	   introduced within evals. See force_ident(). GSAR 96-10-12 */
	char *const safestr = savepvn(tmpbuf, len);
	SAVEDELETE(PL_defstash, safestr, len);
	saved_delete = TRUE;
    }
    
    PUTBACK;

    if (doeval_compile(gimme, runcv, seq, saved_hh)) {
	if (was != PL_breakable_sub_gen /* Some subs defined here. */
	    ?  PERLDB_LINE_OR_SAVESRC
	    :  PERLDB_SAVESRC_NOSUBS) {
	    /* Retain the filegv we created.  */
	} else if (!saved_delete) {
	    char *const safestr = savepvn(tmpbuf, len);
	    SAVEDELETE(PL_defstash, safestr, len);
	}
	return DOCATCH(PL_eval_start);
    } else {
	/* We have already left the scope set up earlier thanks to the LEAVE
	   in doeval_compile().  */
	if (was != PL_breakable_sub_gen /* Some subs defined here. */
	    ?  PERLDB_LINE_OR_SAVESRC
	    :  PERLDB_SAVESRC_INVALID) {
	    /* Retain the filegv we created.  */
	} else if (!saved_delete) {
	    (void)hv_delete(PL_defstash, tmpbuf, len, G_DISCARD);
	}
	return PL_op->op_next;
    }
}


/* also tail-called by pp_return */

PP(pp_leaveeval)
{
    SV **oldsp;
    U8 gimme;
    PERL_CONTEXT *cx;
    OP *retop;
    SV *namesv = NULL;
    CV *evalcv;
    /* grab this value before cx_popeval restores old PL_in_eval */
    bool keep = cBOOL(PL_in_eval & EVAL_KEEPERR);

    PERL_ASYNC_CHECK();

    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_EVAL);

    oldsp = PL_stack_base + cx->blk_oldsp;
    gimme = cx->blk_gimme;

    /* did require return a false value? */
    if (       CxOLD_OP_TYPE(cx) == OP_REQUIRE
            && !(gimme == G_SCALAR
                    ? SvTRUE(*PL_stack_sp)
                : PL_stack_sp > oldsp)
    )
        namesv = cx->blk_eval.old_namesv;

    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 0);

    /* the cx_popeval does a leavescope, which frees the optree associated
     * with eval, which if it frees the nextstate associated with
     * PL_curcop, sets PL_curcop to NULL. Which can mess up freeing a
     * regex when running under 'use re Debug' because it needs PL_curcop
     * to get the current hints. So restore it early.
     */
    PL_curcop = cx->blk_oldcop;

    CX_LEAVE_SCOPE(cx);
    cx_popeval(cx);
    cx_popblock(cx);
    retop = cx->blk_eval.retop;
    evalcv = cx->blk_eval.cv;
    CX_POP(cx);

#ifdef DEBUGGING
    assert(CvDEPTH(evalcv) == 1);
#endif
    CvDEPTH(evalcv) = 0;

    if (namesv) { /* require returned false */
	/* Unassume the success we assumed earlier. */
        S_undo_inc_then_croak(aTHX_ namesv, NULL, TRUE);
        NOT_REACHED; /* NOTREACHED */
    }

    if (!keep)
        CLEAR_ERRSV();

    return retop;
}

/* Common code for Perl_call_sv and Perl_fold_constants, put here to keep it
   close to the related Perl_create_eval_scope.  */
void
Perl_delete_eval_scope(pTHX)
{
    PERL_CONTEXT *cx;
	
    cx = CX_CUR();
    CX_LEAVE_SCOPE(cx);
    cx_popeval(cx);
    cx_popblock(cx);
    CX_POP(cx);
}

/* Common-ish code salvaged from Perl_call_sv and pp_entertry, because it was
   also needed by Perl_fold_constants.  */
void
Perl_create_eval_scope(pTHX_ OP *retop, U32 flags)
{
    PERL_CONTEXT *cx;
    const U8 gimme = GIMME_V;
	
    cx = cx_pushblock((CXt_EVAL|CXp_TRYBLOCK), gimme,
                    PL_stack_sp, PL_savestack_ix);
    cx_pusheval(cx, retop, NULL);

    PL_in_eval = EVAL_INEVAL;
    if (flags & G_KEEPERR)
	PL_in_eval |= EVAL_KEEPERR;
    else
	CLEAR_ERRSV();
    if (flags & G_FAKINGEVAL) {
	PL_eval_root = PL_op; /* Only needed so that goto works right. */
    }
}
    
PP(pp_entertry)
{
    create_eval_scope(cLOGOP->op_other->op_next, 0);
    return DOCATCH(PL_op->op_next);
}


/* also tail-called by pp_return */

PP(pp_leavetry)
{
    SV **oldsp;
    U8 gimme;
    PERL_CONTEXT *cx;
    OP *retop;

    PERL_ASYNC_CHECK();

    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_EVAL);
    oldsp = PL_stack_base + cx->blk_oldsp;
    gimme = cx->blk_gimme;

    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 1);
    CX_LEAVE_SCOPE(cx);
    cx_popeval(cx);
    cx_popblock(cx);
    retop = cx->blk_eval.retop;
    CX_POP(cx);

    CLEAR_ERRSV();
    return retop;
}

PP(pp_entergiven)
{
    dSP;
    PERL_CONTEXT *cx;
    const U8 gimme = GIMME_V;
    SV *origsv = DEFSV;
    SV *newsv = POPs;
    
    assert(!PL_op->op_targ); /* used to be set for lexical $_ */
    GvSV(PL_defgv) = SvREFCNT_inc(newsv);

    cx = cx_pushblock(CXt_GIVEN, gimme, SP, PL_savestack_ix);
    cx_pushgiven(cx, origsv);

    RETURN;
}

PP(pp_leavegiven)
{
    PERL_CONTEXT *cx;
    U8 gimme;
    SV **oldsp;
    PERL_UNUSED_CONTEXT;

    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_GIVEN);
    oldsp = PL_stack_base + cx->blk_oldsp;
    gimme = cx->blk_gimme;

    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 1);

    CX_LEAVE_SCOPE(cx);
    cx_popgiven(cx);
    cx_popblock(cx);
    CX_POP(cx);

    return NORMAL;
}

/* Helper routines used by pp_smartmatch */
STATIC PMOP *
S_make_matcher(pTHX_ REGEXP *re)
{
    PMOP *matcher = (PMOP *) newPMOP(OP_MATCH, OPf_WANT_SCALAR | OPf_STACKED);

    PERL_ARGS_ASSERT_MAKE_MATCHER;

    PM_SETRE(matcher, ReREFCNT_inc(re));

    SAVEFREEOP((OP *) matcher);
    ENTER_with_name("matcher"); SAVETMPS;
    SAVEOP();
    return matcher;
}

STATIC bool
S_matcher_matches_sv(pTHX_ PMOP *matcher, SV *sv)
{
    dSP;
    bool result;

    PERL_ARGS_ASSERT_MATCHER_MATCHES_SV;
    
    PL_op = (OP *) matcher;
    XPUSHs(sv);
    PUTBACK;
    (void) Perl_pp_match(aTHX);
    SPAGAIN;
    result = SvTRUEx(POPs);
    PUTBACK;

    return result;
}

STATIC void
S_destroy_matcher(pTHX_ PMOP *matcher)
{
    PERL_ARGS_ASSERT_DESTROY_MATCHER;
    PERL_UNUSED_ARG(matcher);

    FREETMPS;
    LEAVE_with_name("matcher");
}

/* Do a smart match */
PP(pp_smartmatch)
{
    DEBUG_M(Perl_deb(aTHX_ "Starting smart match resolution\n"));
    return do_smartmatch(NULL, NULL, 0);
}

/* This version of do_smartmatch() implements the
 * table of smart matches that is found in perlsyn.
 */
STATIC OP *
S_do_smartmatch(pTHX_ HV *seen_this, HV *seen_other, const bool copied)
{
    dSP;
    
    bool object_on_left = FALSE;
    SV *e = TOPs;	/* e is for 'expression' */
    SV *d = TOPm1s;	/* d is for 'default', as in PL_defgv */

    /* Take care only to invoke mg_get() once for each argument.
     * Currently we do this by copying the SV if it's magical. */
    if (d) {
	if (!copied && SvGMAGICAL(d))
	    d = sv_mortalcopy(d);
    }
    else
	d = &PL_sv_undef;

    assert(e);
    if (SvGMAGICAL(e))
	e = sv_mortalcopy(e);

    /* First of all, handle overload magic of the rightmost argument */
    if (SvAMAGIC(e)) {
	SV * tmpsv;
	DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Object\n"));
	DEBUG_M(Perl_deb(aTHX_ "        attempting overload\n"));

	tmpsv = amagic_call(d, e, smart_amg, AMGf_noleft);
	if (tmpsv) {
	    SPAGAIN;
	    (void)POPs;
	    SETs(tmpsv);
	    RETURN;
	}
	DEBUG_M(Perl_deb(aTHX_ "        failed to run overload method; continuing...\n"));
    }

    SP -= 2;	/* Pop the values */
    PUTBACK;

    /* ~~ undef */
    if (!SvOK(e)) {
	DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-undef\n"));
	if (SvOK(d))
	    RETPUSHNO;
	else
	    RETPUSHYES;
    }

    if (SvROK(e) && SvOBJECT(SvRV(e)) && (SvTYPE(SvRV(e)) != SVt_REGEXP)) {
	DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Object\n"));
	Perl_croak(aTHX_ "Smart matching a non-overloaded object breaks encapsulation");
    }
    if (SvROK(d) && SvOBJECT(SvRV(d)) && (SvTYPE(SvRV(d)) != SVt_REGEXP))
	object_on_left = TRUE;

    /* ~~ sub */
    if (SvROK(e) && SvTYPE(SvRV(e)) == SVt_PVCV) {
	I32 c;
	if (object_on_left) {
	    goto sm_any_sub; /* Treat objects like scalars */
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVHV) {
	    /* Test sub truth for each key */
	    HE *he;
	    bool andedresults = TRUE;
	    HV *hv = (HV*) SvRV(d);
	    I32 numkeys = hv_iterinit(hv);
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Hash-CodeRef\n"));
	    if (numkeys == 0)
		RETPUSHYES;
	    while ( (he = hv_iternext(hv)) ) {
		DEBUG_M(Perl_deb(aTHX_ "        testing hash key...\n"));
		ENTER_with_name("smartmatch_hash_key_test");
		SAVETMPS;
		PUSHMARK(SP);
		PUSHs(hv_iterkeysv(he));
		PUTBACK;
		c = call_sv(e, G_SCALAR);
		SPAGAIN;
		if (c == 0)
		    andedresults = FALSE;
		else
		    andedresults = SvTRUEx(POPs) && andedresults;
		FREETMPS;
		LEAVE_with_name("smartmatch_hash_key_test");
	    }
	    if (andedresults)
		RETPUSHYES;
	    else
		RETPUSHNO;
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVAV) {
	    /* Test sub truth for each element */
	    SSize_t i;
	    bool andedresults = TRUE;
	    AV *av = (AV*) SvRV(d);
	    const I32 len = av_tindex(av);
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Array-CodeRef\n"));
	    if (len == -1)
		RETPUSHYES;
	    for (i = 0; i <= len; ++i) {
		SV * const * const svp = av_fetch(av, i, FALSE);
		DEBUG_M(Perl_deb(aTHX_ "        testing array element...\n"));
		ENTER_with_name("smartmatch_array_elem_test");
		SAVETMPS;
		PUSHMARK(SP);
		if (svp)
		    PUSHs(*svp);
		PUTBACK;
		c = call_sv(e, G_SCALAR);
		SPAGAIN;
		if (c == 0)
		    andedresults = FALSE;
		else
		    andedresults = SvTRUEx(POPs) && andedresults;
		FREETMPS;
		LEAVE_with_name("smartmatch_array_elem_test");
	    }
	    if (andedresults)
		RETPUSHYES;
	    else
		RETPUSHNO;
	}
	else {
	  sm_any_sub:
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-CodeRef\n"));
	    ENTER_with_name("smartmatch_coderef");
	    SAVETMPS;
	    PUSHMARK(SP);
	    PUSHs(d);
	    PUTBACK;
	    c = call_sv(e, G_SCALAR);
	    SPAGAIN;
	    if (c == 0)
		PUSHs(&PL_sv_no);
	    else if (SvTEMP(TOPs))
		SvREFCNT_inc_void(TOPs);
	    FREETMPS;
	    LEAVE_with_name("smartmatch_coderef");
	    RETURN;
	}
    }
    /* ~~ %hash */
    else if (SvROK(e) && SvTYPE(SvRV(e)) == SVt_PVHV) {
	if (object_on_left) {
	    goto sm_any_hash; /* Treat objects like scalars */
	}
	else if (!SvOK(d)) {
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Hash ($a undef)\n"));
	    RETPUSHNO;
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVHV) {
	    /* Check that the key-sets are identical */
	    HE *he;
	    HV *other_hv = MUTABLE_HV(SvRV(d));
	    bool tied;
	    bool other_tied;
	    U32 this_key_count  = 0,
	        other_key_count = 0;
	    HV *hv = MUTABLE_HV(SvRV(e));

	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Hash-Hash\n"));
	    /* Tied hashes don't know how many keys they have. */
	    tied = cBOOL(SvTIED_mg((SV*)hv, PERL_MAGIC_tied));
	    other_tied = cBOOL(SvTIED_mg((const SV *)other_hv, PERL_MAGIC_tied));
	    if (!tied ) {
		if(other_tied) {
		    /* swap HV sides */
		    HV * const temp = other_hv;
		    other_hv = hv;
		    hv = temp;
		    tied = TRUE;
		    other_tied = FALSE;
		}
		else if(HvUSEDKEYS((const HV *) hv) != HvUSEDKEYS(other_hv))
		    RETPUSHNO;
	    }

	    /* The hashes have the same number of keys, so it suffices
	       to check that one is a subset of the other. */
	    (void) hv_iterinit(hv);
	    while ( (he = hv_iternext(hv)) ) {
		SV *key = hv_iterkeysv(he);

		DEBUG_M(Perl_deb(aTHX_ "        comparing hash key...\n"));
	    	++ this_key_count;
	    	
	    	if(!hv_exists_ent(other_hv, key, 0)) {
	    	    (void) hv_iterinit(hv);	/* reset iterator */
		    RETPUSHNO;
	    	}
	    }
	    
	    if (other_tied) {
		(void) hv_iterinit(other_hv);
		while ( hv_iternext(other_hv) )
		    ++other_key_count;
	    }
	    else
		other_key_count = HvUSEDKEYS(other_hv);
	    
	    if (this_key_count != other_key_count)
		RETPUSHNO;
	    else
		RETPUSHYES;
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVAV) {
	    AV * const other_av = MUTABLE_AV(SvRV(d));
	    const SSize_t other_len = av_tindex(other_av) + 1;
	    SSize_t i;
	    HV *hv = MUTABLE_HV(SvRV(e));

	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Array-Hash\n"));
	    for (i = 0; i < other_len; ++i) {
		SV ** const svp = av_fetch(other_av, i, FALSE);
		DEBUG_M(Perl_deb(aTHX_ "        checking for key existence...\n"));
		if (svp) {	/* ??? When can this not happen? */
		    if (hv_exists_ent(hv, *svp, 0))
		        RETPUSHYES;
		}
	    }
	    RETPUSHNO;
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_REGEXP) {
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Regex-Hash\n"));
	  sm_regex_hash:
	    {
		PMOP * const matcher = make_matcher((REGEXP*) SvRV(d));
		HE *he;
		HV *hv = MUTABLE_HV(SvRV(e));

		(void) hv_iterinit(hv);
		while ( (he = hv_iternext(hv)) ) {
		    DEBUG_M(Perl_deb(aTHX_ "        testing key against pattern...\n"));
                    PUTBACK;
		    if (matcher_matches_sv(matcher, hv_iterkeysv(he))) {
                        SPAGAIN;
			(void) hv_iterinit(hv);
			destroy_matcher(matcher);
			RETPUSHYES;
		    }
                    SPAGAIN;
		}
		destroy_matcher(matcher);
		RETPUSHNO;
	    }
	}
	else {
	  sm_any_hash:
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Hash\n"));
	    if (hv_exists_ent(MUTABLE_HV(SvRV(e)), d, 0))
		RETPUSHYES;
	    else
		RETPUSHNO;
	}
    }
    /* ~~ @@array */
    else if (SvROK(e) && SvTYPE(SvRV(e)) == SVt_PVAV) {
	if (object_on_left) {
	    goto sm_any_array; /* Treat objects like scalars */
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVHV) {
	    AV * const other_av = MUTABLE_AV(SvRV(e));
	    const SSize_t other_len = av_tindex(other_av) + 1;
	    SSize_t i;

	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Hash-Array\n"));
	    for (i = 0; i < other_len; ++i) {
		SV ** const svp = av_fetch(other_av, i, FALSE);

		DEBUG_M(Perl_deb(aTHX_ "        testing for key existence...\n"));
		if (svp) {	/* ??? When can this not happen? */
		    if (hv_exists_ent(MUTABLE_HV(SvRV(d)), *svp, 0))
		        RETPUSHYES;
		}
	    }
	    RETPUSHNO;
	}
	if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVAV) {
	    AV *other_av = MUTABLE_AV(SvRV(d));
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Array-Array\n"));
	    if (av_tindex(MUTABLE_AV(SvRV(e))) != av_tindex(other_av))
		RETPUSHNO;
	    else {
	    	SSize_t i;
                const SSize_t other_len = av_tindex(other_av);

		if (NULL == seen_this) {
		    seen_this = newHV();
		    (void) sv_2mortal(MUTABLE_SV(seen_this));
		}
		if (NULL == seen_other) {
		    seen_other = newHV();
		    (void) sv_2mortal(MUTABLE_SV(seen_other));
		}
		for(i = 0; i <= other_len; ++i) {
		    SV * const * const this_elem = av_fetch(MUTABLE_AV(SvRV(e)), i, FALSE);
		    SV * const * const other_elem = av_fetch(other_av, i, FALSE);

		    if (!this_elem || !other_elem) {
			if ((this_elem && SvOK(*this_elem))
				|| (other_elem && SvOK(*other_elem)))
			    RETPUSHNO;
		    }
		    else if (hv_exists_ent(seen_this,
				sv_2mortal(newSViv(PTR2IV(*this_elem))), 0) ||
			    hv_exists_ent(seen_other,
				sv_2mortal(newSViv(PTR2IV(*other_elem))), 0))
		    {
			if (*this_elem != *other_elem)
			    RETPUSHNO;
		    }
		    else {
			(void)hv_store_ent(seen_this,
				sv_2mortal(newSViv(PTR2IV(*this_elem))),
				&PL_sv_undef, 0);
			(void)hv_store_ent(seen_other,
				sv_2mortal(newSViv(PTR2IV(*other_elem))),
				&PL_sv_undef, 0);
			PUSHs(*other_elem);
			PUSHs(*this_elem);
			
			PUTBACK;
			DEBUG_M(Perl_deb(aTHX_ "        recursively comparing array element...\n"));
			(void) do_smartmatch(seen_this, seen_other, 0);
			SPAGAIN;
			DEBUG_M(Perl_deb(aTHX_ "        recursion finished\n"));
			
			if (!SvTRUEx(POPs))
			    RETPUSHNO;
		    }
		}
		RETPUSHYES;
	    }
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_REGEXP) {
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Regex-Array\n"));
	  sm_regex_array:
	    {
		PMOP * const matcher = make_matcher((REGEXP*) SvRV(d));
		const SSize_t this_len = av_tindex(MUTABLE_AV(SvRV(e)));
		SSize_t i;

		for(i = 0; i <= this_len; ++i) {
		    SV * const * const svp = av_fetch(MUTABLE_AV(SvRV(e)), i, FALSE);
		    DEBUG_M(Perl_deb(aTHX_ "        testing element against pattern...\n"));
                    PUTBACK;
		    if (svp && matcher_matches_sv(matcher, *svp)) {
                        SPAGAIN;
			destroy_matcher(matcher);
			RETPUSHYES;
		    }
                    SPAGAIN;
		}
		destroy_matcher(matcher);
		RETPUSHNO;
	    }
	}
	else if (!SvOK(d)) {
	    /* undef ~~ array */
	    const SSize_t this_len = av_tindex(MUTABLE_AV(SvRV(e)));
	    SSize_t i;

	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Undef-Array\n"));
	    for (i = 0; i <= this_len; ++i) {
		SV * const * const svp = av_fetch(MUTABLE_AV(SvRV(e)), i, FALSE);
		DEBUG_M(Perl_deb(aTHX_ "        testing for undef element...\n"));
		if (!svp || !SvOK(*svp))
		    RETPUSHYES;
	    }
	    RETPUSHNO;
	}
	else {
	  sm_any_array:
	    {
		SSize_t i;
		const SSize_t this_len = av_tindex(MUTABLE_AV(SvRV(e)));

		DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Array\n"));
		for (i = 0; i <= this_len; ++i) {
		    SV * const * const svp = av_fetch(MUTABLE_AV(SvRV(e)), i, FALSE);
		    if (!svp)
			continue;

		    PUSHs(d);
		    PUSHs(*svp);
		    PUTBACK;
		    /* infinite recursion isn't supposed to happen here */
		    DEBUG_M(Perl_deb(aTHX_ "        recursively testing array element...\n"));
		    (void) do_smartmatch(NULL, NULL, 1);
		    SPAGAIN;
		    DEBUG_M(Perl_deb(aTHX_ "        recursion finished\n"));
		    if (SvTRUEx(POPs))
			RETPUSHYES;
		}
		RETPUSHNO;
	    }
	}
    }
    /* ~~ qr// */
    else if (SvROK(e) && SvTYPE(SvRV(e)) == SVt_REGEXP) {
	if (!object_on_left && SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVHV) {
	    SV *t = d; d = e; e = t;
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Hash-Regex\n"));
	    goto sm_regex_hash;
	}
	else if (!object_on_left && SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVAV) {
	    SV *t = d; d = e; e = t;
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Array-Regex\n"));
	    goto sm_regex_array;
	}
	else {
	    PMOP * const matcher = make_matcher((REGEXP*) SvRV(e));
            bool result;

	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Regex\n"));
	    PUTBACK;
	    result = matcher_matches_sv(matcher, d);
            SPAGAIN;
	    PUSHs(result ? &PL_sv_yes : &PL_sv_no);
	    destroy_matcher(matcher);
	    RETURN;
	}
    }
    /* ~~ scalar */
    /* See if there is overload magic on left */
    else if (object_on_left && SvAMAGIC(d)) {
	SV *tmpsv;
	DEBUG_M(Perl_deb(aTHX_ "    applying rule Object-Any\n"));
	DEBUG_M(Perl_deb(aTHX_ "        attempting overload\n"));
	PUSHs(d); PUSHs(e);
	PUTBACK;
	tmpsv = amagic_call(d, e, smart_amg, AMGf_noright);
	if (tmpsv) {
	    SPAGAIN;
	    (void)POPs;
	    SETs(tmpsv);
	    RETURN;
	}
	SP -= 2;
	DEBUG_M(Perl_deb(aTHX_ "        failed to run overload method; falling back...\n"));
	goto sm_any_scalar;
    }
    else if (!SvOK(d)) {
	/* undef ~~ scalar ; we already know that the scalar is SvOK */
	DEBUG_M(Perl_deb(aTHX_ "    applying rule undef-Any\n"));
	RETPUSHNO;
    }
    else
  sm_any_scalar:
    if (SvNIOK(e) || (SvPOK(e) && looks_like_number(e) && SvNIOK(d))) {
	DEBUG_M(if (SvNIOK(e))
		    Perl_deb(aTHX_ "    applying rule Any-Num\n");
		else
		    Perl_deb(aTHX_ "    applying rule Num-numish\n");
	);
	/* numeric comparison */
	PUSHs(d); PUSHs(e);
	PUTBACK;
	if (CopHINTS_get(PL_curcop) & HINT_INTEGER)
	    (void) Perl_pp_i_eq(aTHX);
	else
	    (void) Perl_pp_eq(aTHX);
	SPAGAIN;
	if (SvTRUEx(POPs))
	    RETPUSHYES;
	else
	    RETPUSHNO;
    }
    
    /* As a last resort, use string comparison */
    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Any\n"));
    PUSHs(d); PUSHs(e);
    PUTBACK;
    return Perl_pp_seq(aTHX);
}

PP(pp_enterwhen)
{
    dSP;
    PERL_CONTEXT *cx;
    const U8 gimme = GIMME_V;

    /* This is essentially an optimization: if the match
       fails, we don't want to push a context and then
       pop it again right away, so we skip straight
       to the op that follows the leavewhen.
       RETURNOP calls PUTBACK which restores the stack pointer after the POPs.
    */
    if (!(PL_op->op_flags & OPf_SPECIAL) && !SvTRUEx(POPs))
	RETURNOP(cLOGOP->op_other->op_next);

    cx = cx_pushblock(CXt_WHEN, gimme, SP, PL_savestack_ix);
    cx_pushwhen(cx);

    RETURN;
}

PP(pp_leavewhen)
{
    I32 cxix;
    PERL_CONTEXT *cx;
    U8 gimme;
    SV **oldsp;

    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_WHEN);
    gimme = cx->blk_gimme;

    cxix = dopoptogivenfor(cxstack_ix);
    if (cxix < 0)
	/* diag_listed_as: Can't "when" outside a topicalizer */
	DIE(aTHX_ "Can't \"%s\" outside a topicalizer",
	           PL_op->op_flags & OPf_SPECIAL ? "default" : "when");

    oldsp = PL_stack_base + cx->blk_oldsp;
    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 1);

    /* pop the WHEN, BLOCK and anything else before the GIVEN/FOR */
    assert(cxix < cxstack_ix);
    dounwind(cxix);

    cx = &cxstack[cxix];

    if (CxFOREACH(cx)) {
        /* emulate pp_next. Note that any stack(s) cleanup will be
         * done by the pp_unstack which op_nextop should point to */
        cx = CX_CUR();
	cx_topblock(cx);
	PL_curcop = cx->blk_oldcop;
	return cx->blk_loop.my_op->op_nextop;
    }
    else {
	PERL_ASYNC_CHECK();
        assert(cx->blk_givwhen.leave_op->op_type == OP_LEAVEGIVEN);
	return cx->blk_givwhen.leave_op;
    }
}

PP(pp_continue)
{
    I32 cxix;
    PERL_CONTEXT *cx;
    OP *nextop;
    
    cxix = dopoptowhen(cxstack_ix); 
    if (cxix < 0)   
	DIE(aTHX_ "Can't \"continue\" outside a when block");

    if (cxix < cxstack_ix)
        dounwind(cxix);
    
    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_WHEN);
    PL_stack_sp = PL_stack_base + cx->blk_oldsp;
    CX_LEAVE_SCOPE(cx);
    cx_popwhen(cx);
    cx_popblock(cx);
    nextop = cx->blk_givwhen.leave_op->op_next;
    CX_POP(cx);

    return nextop;
}

PP(pp_break)
{
    I32 cxix;
    PERL_CONTEXT *cx;

    cxix = dopoptogivenfor(cxstack_ix);
    if (cxix < 0)
	DIE(aTHX_ "Can't \"break\" outside a given block");

    cx = &cxstack[cxix];
    if (CxFOREACH(cx))
	DIE(aTHX_ "Can't \"break\" in a loop topicalizer");

    if (cxix < cxstack_ix)
        dounwind(cxix);

    /* Restore the sp at the time we entered the given block */
    cx = CX_CUR();
    PL_stack_sp = PL_stack_base + cx->blk_oldsp;

    return cx->blk_givwhen.leave_op;
}

static MAGIC *
S_doparseform(pTHX_ SV *sv)
{
    STRLEN len;
    char *s = SvPV(sv, len);
    char *send;
    char *base = NULL; /* start of current field */
    I32 skipspaces = 0; /* number of contiguous spaces seen */
    bool noblank   = FALSE; /* ~ or ~~ seen on this line */
    bool repeat    = FALSE; /* ~~ seen on this line */
    bool postspace = FALSE; /* a text field may need right padding */
    U32 *fops;
    U32 *fpc;
    U32 *linepc = NULL;	    /* position of last FF_LINEMARK */
    I32 arg;
    bool ischop;	    /* it's a ^ rather than a @@ */
    bool unchopnum = FALSE; /* at least one @@ (i.e. non-chop) num field seen */
    int maxops = 12; /* FF_LINEMARK + FF_END + 10 (\0 without preceding \n) */
    MAGIC *mg = NULL;
    SV *sv_copy;

    PERL_ARGS_ASSERT_DOPARSEFORM;

    if (len == 0)
	Perl_croak(aTHX_ "Null picture in formline");

    if (SvTYPE(sv) >= SVt_PVMG) {
	/* This might, of course, still return NULL.  */
	mg = mg_find(sv, PERL_MAGIC_fm);
    } else {
	sv_upgrade(sv, SVt_PVMG);
    }

    if (mg) {
	/* still the same as previously-compiled string? */
	SV *old = mg->mg_obj;
	if ( !(!!SvUTF8(old) ^ !!SvUTF8(sv))
	      && len == SvCUR(old)
	      && strnEQ(SvPVX(old), SvPVX(sv), len)
	) {
	    DEBUG_f(PerlIO_printf(Perl_debug_log,"Re-using compiled format\n"));
	    return mg;
	}

	DEBUG_f(PerlIO_printf(Perl_debug_log, "Re-compiling format\n"));
	Safefree(mg->mg_ptr);
	mg->mg_ptr = NULL;
	SvREFCNT_dec(old);
	mg->mg_obj = NULL;
    }
    else {
	DEBUG_f(PerlIO_printf(Perl_debug_log, "Compiling format\n"));
	mg = sv_magicext(sv, NULL, PERL_MAGIC_fm, &PL_vtbl_fm, NULL, 0);
    }

    sv_copy = newSVpvn_utf8(s, len, SvUTF8(sv));
    s = SvPV(sv_copy, len); /* work on the copy, not the original */
    send = s + len;


    /* estimate the buffer size needed */
    for (base = s; s <= send; s++) {
	if (*s == '\n' || *s == '@@' || *s == '^')
	    maxops += 10;
    }
    s = base;
    base = NULL;

    Newx(fops, maxops, U32);
    fpc = fops;

    if (s < send) {
	linepc = fpc;
	*fpc++ = FF_LINEMARK;
	noblank = repeat = FALSE;
	base = s;
    }

    while (s <= send) {
	switch (*s++) {
	default:
	    skipspaces = 0;
	    continue;

	case '~':
	    if (*s == '~') {
		repeat = TRUE;
		skipspaces++;
		s++;
	    }
	    noblank = TRUE;
	    /* FALLTHROUGH */
	case ' ': case '\t':
	    skipspaces++;
	    continue;
        case 0:
	    if (s < send) {
	        skipspaces = 0;
                continue;
            } /* else FALL THROUGH */
	case '\n':
	    arg = s - base;
	    skipspaces++;
	    arg -= skipspaces;
	    if (arg) {
		if (postspace)
		    *fpc++ = FF_SPACE;
		*fpc++ = FF_LITERAL;
		*fpc++ = (U32)arg;
	    }
	    postspace = FALSE;
	    if (s <= send)
		skipspaces--;
	    if (skipspaces) {
		*fpc++ = FF_SKIP;
		*fpc++ = (U32)skipspaces;
	    }
	    skipspaces = 0;
	    if (s <= send)
		*fpc++ = FF_NEWLINE;
	    if (noblank) {
		*fpc++ = FF_BLANK;
		if (repeat)
		    arg = fpc - linepc + 1;
		else
		    arg = 0;
		*fpc++ = (U32)arg;
	    }
	    if (s < send) {
		linepc = fpc;
		*fpc++ = FF_LINEMARK;
		noblank = repeat = FALSE;
		base = s;
	    }
	    else
		s++;
	    continue;

	case '@@':
	case '^':
	    ischop = s[-1] == '^';

	    if (postspace) {
		*fpc++ = FF_SPACE;
		postspace = FALSE;
	    }
	    arg = (s - base) - 1;
	    if (arg) {
		*fpc++ = FF_LITERAL;
		*fpc++ = (U32)arg;
	    }

	    base = s - 1;
	    *fpc++ = FF_FETCH;
	    if (*s == '*') { /*  @@* or ^*  */
		s++;
		*fpc++ = 2;  /* skip the @@* or ^* */
		if (ischop) {
		    *fpc++ = FF_LINESNGL;
		    *fpc++ = FF_CHOP;
		} else
		    *fpc++ = FF_LINEGLOB;
	    }
	    else if (*s == '#' || (*s == '.' && s[1] == '#')) { /* @@###, ^### */
		arg = ischop ? FORM_NUM_BLANK : 0;
		base = s - 1;
		while (*s == '#')
		    s++;
		if (*s == '.') {
                    const char * const f = ++s;
		    while (*s == '#')
			s++;
		    arg |= FORM_NUM_POINT + (s - f);
		}
		*fpc++ = s - base;		/* fieldsize for FETCH */
		*fpc++ = FF_DECIMAL;
                *fpc++ = (U32)arg;
                unchopnum |= ! ischop;
            }
            else if (*s == '0' && s[1] == '#') {  /* Zero padded decimals */
                arg = ischop ? FORM_NUM_BLANK : 0;
		base = s - 1;
                s++;                                /* skip the '0' first */
                while (*s == '#')
                    s++;
                if (*s == '.') {
                    const char * const f = ++s;
                    while (*s == '#')
                        s++;
                    arg |= FORM_NUM_POINT + (s - f);
                }
                *fpc++ = s - base;                /* fieldsize for FETCH */
                *fpc++ = FF_0DECIMAL;
		*fpc++ = (U32)arg;
                unchopnum |= ! ischop;
	    }
	    else {				/* text field */
		I32 prespace = 0;
		bool ismore = FALSE;

		if (*s == '>') {
		    while (*++s == '>') ;
		    prespace = FF_SPACE;
		}
		else if (*s == '|') {
		    while (*++s == '|') ;
		    prespace = FF_HALFSPACE;
		    postspace = TRUE;
		}
		else {
		    if (*s == '<')
			while (*++s == '<') ;
		    postspace = TRUE;
		}
		if (*s == '.' && s[1] == '.' && s[2] == '.') {
		    s += 3;
		    ismore = TRUE;
		}
		*fpc++ = s - base;		/* fieldsize for FETCH */

		*fpc++ = ischop ? FF_CHECKCHOP : FF_CHECKNL;

		if (prespace)
		    *fpc++ = (U32)prespace; /* add SPACE or HALFSPACE */
		*fpc++ = FF_ITEM;
		if (ismore)
		    *fpc++ = FF_MORE;
		if (ischop)
		    *fpc++ = FF_CHOP;
	    }
	    base = s;
	    skipspaces = 0;
	    continue;
	}
    }
    *fpc++ = FF_END;

    assert (fpc <= fops + maxops); /* ensure our buffer estimate was valid */
    arg = fpc - fops;

    mg->mg_ptr = (char *) fops;
    mg->mg_len = arg * sizeof(U32);
    mg->mg_obj = sv_copy;
    mg->mg_flags |= MGf_REFCOUNTED;

    if (unchopnum && repeat)
        Perl_die(aTHX_ "Repeated format line will never terminate (~~ and @@#)");

    return mg;
}


STATIC bool
S_num_overflow(NV value, I32 fldsize, I32 frcsize)
{
    /* Can value be printed in fldsize chars, using %*.*f ? */
    NV pwr = 1;
    NV eps = 0.5;
    bool res = FALSE;
    int intsize = fldsize - (value < 0 ? 1 : 0);

    if (frcsize & FORM_NUM_POINT)
        intsize--;
    frcsize &= ~(FORM_NUM_POINT|FORM_NUM_BLANK);
    intsize -= frcsize;

    while (intsize--) pwr *= 10.0;
    while (frcsize--) eps /= 10.0;

    if( value >= 0 ){
        if (value + eps >= pwr)
	    res = TRUE;
    } else {
        if (value - eps <= -pwr)
	    res = TRUE;
    }
    return res;
}

static I32
S_run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)
{
    SV * const datasv = FILTER_DATA(idx);
    const int filter_has_file = IoLINES(datasv);
    SV * const filter_state = MUTABLE_SV(IoTOP_GV(datasv));
    SV * const filter_sub = MUTABLE_SV(IoBOTTOM_GV(datasv));
    int status = 0;
    SV *upstream;
    STRLEN got_len;
    char *got_p = NULL;
    char *prune_from = NULL;
    bool read_from_cache = FALSE;
    STRLEN umaxlen;
    SV *err = NULL;

    PERL_ARGS_ASSERT_RUN_USER_FILTER;

    assert(maxlen >= 0);
    umaxlen = maxlen;

    /* I was having segfault trouble under Linux 2.2.5 after a
       parse error occurred.  (Had to hack around it with a test
       for PL_parser->error_count == 0.)  Solaris doesn't segfault --
       not sure where the trouble is yet.  XXX */

    {
	SV *const cache = datasv;
	if (SvOK(cache)) {
	    STRLEN cache_len;
	    const char *cache_p = SvPV(cache, cache_len);
	    STRLEN take = 0;

	    if (umaxlen) {
		/* Running in block mode and we have some cached data already.
		 */
		if (cache_len >= umaxlen) {
		    /* In fact, so much data we don't even need to call
		       filter_read.  */
		    take = umaxlen;
		}
	    } else {
		const char *const first_nl =
		    (const char *)memchr(cache_p, '\n', cache_len);
		if (first_nl) {
		    take = first_nl + 1 - cache_p;
		}
	    }
	    if (take) {
		sv_catpvn(buf_sv, cache_p, take);
		sv_chop(cache, cache_p + take);
		/* Definitely not EOF  */
		return 1;
	    }

	    sv_catsv(buf_sv, cache);
	    if (umaxlen) {
		umaxlen -= cache_len;
	    }
	    SvOK_off(cache);
	    read_from_cache = TRUE;
	}
    }

    /* Filter API says that the filter appends to the contents of the buffer.
       Usually the buffer is "", so the details don't matter. But if it's not,
       then clearly what it contains is already filtered by this filter, so we
       don't want to pass it in a second time.
       I'm going to use a mortal in case the upstream filter croaks.  */
    upstream = ((SvOK(buf_sv) && sv_len(buf_sv)) || SvGMAGICAL(buf_sv))
	? sv_newmortal() : buf_sv;
    SvUPGRADE(upstream, SVt_PV);
	
    if (filter_has_file) {
	status = FILTER_READ(idx+1, upstream, 0);
    }

    if (filter_sub && status >= 0) {
	dSP;
	int count;

	ENTER_with_name("call_filter_sub");
	SAVE_DEFSV;
	SAVETMPS;
	EXTEND(SP, 2);

	DEFSV_set(upstream);
	PUSHMARK(SP);
	mPUSHi(0);
	if (filter_state) {
	    PUSHs(filter_state);
	}
	PUTBACK;
	count = call_sv(filter_sub, G_SCALAR|G_EVAL);
	SPAGAIN;

	if (count > 0) {
	    SV *out = POPs;
	    SvGETMAGIC(out);
	    if (SvOK(out)) {
		status = SvIV(out);
	    }
            else {
                SV * const errsv = ERRSV;
                if (SvTRUE_NN(errsv))
                    err = newSVsv(errsv);
            }
	}

	PUTBACK;
	FREETMPS;
	LEAVE_with_name("call_filter_sub");
    }

    if (SvGMAGICAL(upstream)) {
	mg_get(upstream);
	if (upstream == buf_sv) mg_free(buf_sv);
    }
    if (SvIsCOW(upstream)) sv_force_normal(upstream);
    if(!err && SvOK(upstream)) {
	got_p = SvPV_nomg(upstream, got_len);
	if (umaxlen) {
	    if (got_len > umaxlen) {
		prune_from = got_p + umaxlen;
	    }
	} else {
	    char *const first_nl = (char *)memchr(got_p, '\n', got_len);
	    if (first_nl && first_nl + 1 < got_p + got_len) {
		/* There's a second line here... */
		prune_from = first_nl + 1;
	    }
	}
    }
    if (!err && prune_from) {
	/* Oh. Too long. Stuff some in our cache.  */
	STRLEN cached_len = got_p + got_len - prune_from;
	SV *const cache = datasv;

	if (SvOK(cache)) {
	    /* Cache should be empty.  */
	    assert(!SvCUR(cache));
	}

	sv_setpvn(cache, prune_from, cached_len);
	/* If you ask for block mode, you may well split UTF-8 characters.
	   "If it breaks, you get to keep both parts"
	   (Your code is broken if you  don't put them back together again
	   before something notices.) */
	if (SvUTF8(upstream)) {
	    SvUTF8_on(cache);
	}
	if (SvPOK(upstream)) SvCUR_set(upstream, got_len - cached_len);
	else
	    /* Cannot just use sv_setpvn, as that could free the buffer
	       before we have a chance to assign it. */
	    sv_usepvn(upstream, savepvn(got_p, got_len - cached_len),
		      got_len - cached_len);
	*prune_from = 0;
	/* Can't yet be EOF  */
	if (status == 0)
	    status = 1;
    }

    /* If they are at EOF but buf_sv has something in it, then they may never
       have touched the SV upstream, so it may be undefined.  If we naively
       concatenate it then we get a warning about use of uninitialised value.
    */
    if (!err && upstream != buf_sv &&
        SvOK(upstream)) {
	sv_catsv_nomg(buf_sv, upstream);
    }
    else if (SvOK(upstream)) (void)SvPV_force_nolen(buf_sv);

    if (status <= 0) {
	IoLINES(datasv) = 0;
	if (filter_state) {
	    SvREFCNT_dec(filter_state);
	    IoTOP_GV(datasv) = NULL;
	}
	if (filter_sub) {
	    SvREFCNT_dec(filter_sub);
	    IoBOTTOM_GV(datasv) = NULL;
	}
	filter_del(S_run_user_filter);
    }

    if (err)
        croak_sv(err);

    if (status == 0 && read_from_cache) {
	/* If we read some data from the cache (and by getting here it implies
	   that we emptied the cache) then we aren't yet at EOF, and mustn't
	   report that to our caller.  */
	return 1;
    }
    return status;
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.18
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@a42 1
    dVAR;
a69 1
    dVAR;
a75 1
    dVAR;
d145 1
a145 1
	    else if (pm->op_private & OPpTARGET_MY)
d168 2
a169 1
    if (TAINTING_get && TAINT_get) {
a191 1
    dVAR;
d193 1
a193 1
    PERL_CONTEXT *cx = &cxstack[cxstack_ix];
d214 1
a214 1
	const I32 saviters = cx->sb_iters;
d288 5
a292 2
	    LEAVE_SCOPE(cx->sb_oldsave);
	    POPSUBST(cx);
d295 1
a295 1
	    assert(0); /* NOTREACHED */
d319 7
a328 1
	assert(SvPOK(sv));
d466 1
a466 1
    dVAR; dSP; dMARK; dORIGMARK;
d706 1
a806 5
#if defined(USE_LONG_DOUBLE)
	    fmt = (const char *)
		((arg & FORM_NUM_POINT) ?
		 "%#0*.*" PERL_PRIfldbl : "%0*.*" PERL_PRIfldbl);
#else
d808 1
a808 3
		((arg & FORM_NUM_POINT) ?
		 "%#0*.*f"              : "%0*.*f");
#endif
a812 1
#if defined(USE_LONG_DOUBLE)
d814 1
a814 5
		((arg & FORM_NUM_POINT) ? "%#*.*" PERL_PRIfldbl : "%*.*" PERL_PRIfldbl);
#else
            fmt = (const char *)
		((arg & FORM_NUM_POINT) ? "%#*.*f"              : "%*.*f");
#endif
d835 18
a852 2
                DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED();
		arg &= ~(FORM_NUM_POINT|FORM_NUM_BLANK);
d855 1
a855 1
		my_snprintf(t, SvLEN(PL_formtarget) - (t - SvPVX(PL_formtarget)), fmt, (int) fieldsize, (int) arg, value);
d857 2
d932 1
a932 1
    dVAR; dSP;
d935 1
a935 1
    if (PL_stack_base + *PL_markstack_ptr == SP) {
d941 1
a941 1
    PL_stack_sp = PL_stack_base + *PL_markstack_ptr + 1;
d947 1
a947 4
    if (PL_op->op_private & OPpGREP_LEX)
	SAVESPTR(PAD_SVl(PL_op->op_targ));
    else
	SAVE_DEFSV;
d951 1
a951 1
    src = PL_stack_base[*PL_markstack_ptr];
d953 1
a953 2
        assert(!IS_PADGV(src));
	src = PL_stack_base[*PL_markstack_ptr] = sv_mortalcopy(src);
d957 1
a957 4
    if (PL_op->op_private & OPpGREP_LEX)
	PAD_SVl(PL_op->op_targ) = src;
    else
	DEFSV_set(src);
d967 3
a969 3
    dVAR; dSP;
    const I32 gimme = GIMME_V;
    I32 items = (SP - PL_stack_base) - *PL_markstack_ptr; /* how many new items */
d1070 1
a1070 1
    if (PL_markstack_ptr[-1] > *PL_markstack_ptr) {
a1078 6
	    if (PL_op->op_private & OPpGREP_LEX) {
		SV* sv = sv_newmortal();
		sv_setiv(sv, items);
		PUSHs(sv);
	    }
	    else {
a1080 1
	    }
a1094 1
            assert(!IS_PADGV(src));
d1098 1
a1098 4
	if (PL_op->op_private & OPpGREP_LEX)
	    PAD_SVl(PL_op->op_targ) = src;
	else
	    DEFSV_set(src);
d1108 1
a1108 2
    dVAR;
    if (GIMME == G_ARRAY)
a1117 1
    dVAR;
d1120 1
a1120 1
    if (GIMME == G_ARRAY) {
d1172 1
a1172 1
    dVAR; dSP;
d1174 1
a1174 1
    if (GIMME == G_ARRAY) {
d1181 1
a1181 2
	    IV i, j;
	    IV max;
d1188 20
a1207 7
	    max = SvIV_nomg(right);
	    if (max >= i) {
		j = max - i + 1;
		if (j > SSize_t_MAX)
		    Perl_croak(aTHX_ "Out of memory during list extend");
		EXTEND_MORTAL(j);
		EXTEND(SP, j);
d1210 3
a1212 3
		j = 0;
	    while (j--) {
		SV * const sv = sv_2mortal(newSViv(i++));
d1214 2
a1268 1
    NULL, /* CXt_LOOP_FOR never actually needs "loop" */
d1270 1
d1272 2
a1273 1
    NULL, /* CXt_LOOP_LAZYIV never actually needs "loop" */
a1282 1
    dVAR;
d1298 1
a1298 1
	    if (CxTYPE(cx) == CXt_NULL)
d1301 1
d1304 2
a1305 2
	case CXt_LOOP_FOR:
	case CXt_LOOP_PLAIN:
d1335 1
a1335 1
I32
d1338 1
a1338 2
    dVAR;
    const I32 gimme = block_gimme();
d1342 1
a1342 1
I32
a1344 1
    dVAR;
d1346 1
d1350 4
a1353 12
    switch (cxstack[cxix].blk_gimme) {
    case G_VOID:
	return G_VOID;
    case G_SCALAR:
	return G_SCALAR;
    case G_ARRAY:
	return G_ARRAY;
    default:
	Perl_croak(aTHX_ "panic: bad gimme: %d\n", cxstack[cxix].blk_gimme);
	assert(0); /* NOTREACHED */
	return 0;
    }
d1356 1
a1359 1
    dVAR;
d1369 1
a1369 1
/* only used by PUSHSUB */
a1372 1
    dVAR;
a1384 1
    dVAR;
d1388 3
d1404 1
a1416 1
    dVAR;
a1433 1
    dVAR;
d1446 1
a1446 1
	    if ((CxTYPE(cx)) == CXt_NULL)
d1449 1
d1452 2
a1453 2
	case CXt_LOOP_FOR:
	case CXt_LOOP_PLAIN:
d1461 2
d1464 1
a1464 1
S_dopoptogiven(pTHX_ I32 startingblock)
a1465 1
    dVAR;
d1473 1
a1473 1
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptogiven(): found given at cx=%ld)\n", (long)i));
d1476 1
a1476 1
	    assert(!CxFOREACHDEF(cx));
d1480 4
a1483 3
	case CXt_LOOP_FOR:
	    if (CxFOREACHDEF(cx)) {
		DEBUG_l( Perl_deb(aTHX_ "(dopoptogiven(): found foreach at cx=%ld)\n", (long)i));
a1493 1
    dVAR;
d1508 7
a1517 3
    dVAR;
    I32 optype;

d1522 3
a1524 3
	SV *sv;
        PERL_CONTEXT *cx = &cxstack[cxstack_ix];
	DEBUG_CX("UNWIND");						\
d1526 3
d1531 2
a1532 2
	    POPSUBST(cx);
	    continue;  /* not break */
d1534 1
a1534 2
	    POPSUB(cx,sv);
	    LEAVESUB(sv);
d1537 1
a1537 1
	    POPEVAL(cx);
d1539 1
d1542 9
a1550 3
	case CXt_LOOP_FOR:
	case CXt_LOOP_PLAIN:
	    POPLOOP(cx);
d1552 1
d1554 1
d1557 1
a1557 1
	    POPFORMAT(cx);
d1560 3
d1565 1
a1565 1
    PERL_UNUSED_VAR(optype);
a1570 2
    dVAR;

d1589 28
a1619 1
    dVAR;
a1625 1
	I32 gimme;
d1674 1
a1674 2
	    I32 optype;
	    SV *namesv;
d1676 2
a1677 2
	    SV **newsp;
	    COP *oldcop;
d1684 2
a1685 13
	    POPBLOCK(cx,PL_curpm);
	    if (CxTYPE(cx) != CXt_EVAL) {
		STRLEN msglen;
		const char* message = SvPVx_const(exceptsv, msglen);
		PerlIO_write(Perl_error_log, (const char *)"panic: die ", 11);
		PerlIO_write(Perl_error_log, message, msglen);
		my_exit(1);
	    }
	    POPEVAL(cx);
	    namesv = cx->blk_eval.old_namesv;
	    oldcop = cx->blk_oldcop;
	    restartjmpenv = cx->blk_eval.cur_top_env;
	    restartop = cx->blk_eval.retop;
d1687 3
d1691 2
a1692 2
		*++newsp = &PL_sv_undef;
	    PL_stack_sp = newsp;
d1694 17
a1710 1
	    LEAVE;
a1711 19
	    /* LEAVE could clobber PL_curcop (see save_re_context())
	     * XXX it might be better to find a way to avoid messing with
	     * PL_curcop in save_re_context() instead, but this is a more
	     * minimal fix --GSAR */
	    PL_curcop = oldcop;

	    if (optype == OP_REQUIRE) {
                (void)hv_store(GvHVn(PL_incgv),
                               SvPVX_const(namesv),
                               SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv),
                               &PL_sv_undef, 0);
		/* note that unlike pp_entereval, pp_require isn't
		 * supposed to trap errors. So now that we've popped the
		 * EVAL that pp_require pushed, and processed the error
		 * message, rethrow the error */
		Perl_croak(aTHX_ "%"SVf"Compilation failed in require",
			   SVfARG(exceptsv ? exceptsv : newSVpvs_flags("Unknown error\n",
                                                                    SVs_TEMP)));
	    }
d1717 1
a1717 1
	    assert(0); /* NOTREACHED */
d1723 1
a1723 1
    assert(0); /* NOTREACHED */
d1728 1
a1728 1
    dVAR; dSP; dPOPTOPssrl;
d1736 3
a1799 1
    dVAR;
d1803 1
a1803 1
    I32 gimme;
d1817 1
a1817 1
	if (GIMME != G_ARRAY) {
d1824 1
a1824 1
    DEBUG_CX("CALLER");
d1829 1
a1829 1
    if (GIMME != G_ARRAY) {
d1851 1
a1851 1
    lcop = closest_cop(cx->blk_oldcop, cx->blk_oldcop->op_sibling,
d1855 1
a1855 1
    mPUSHi((I32)CopLINE(lcop));
a1858 1
	GV * const cvgv = CvGV(dbcx->blk_sub.cv);
d1860 2
a1861 4
	if (cvgv && isGV(cvgv)) {
	    SV * const sv = newSV(0);
	    gv_efullname3(sv, cvgv, NULL);
	    mPUSHs(sv);
d1873 1
a1873 1
    gimme = (I32)cx->blk_gimme;
d1911 4
a1914 1
	AV * const ary = cx->blk_sub.argarray;
a1958 1
    dVAR;
a1974 1
    dVAR;
d1977 1
a1977 1
    PL_stack_sp = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;
d1983 1
a1983 1
	    || SvIV(PL_DBsingle) || SvIV(PL_DBsignal) || SvIV(PL_DBtrace))
d1987 1
a1987 2
	const I32 gimme = G_ARRAY;
	U8 hasargs;
a2000 9
	ENTER;
	SAVETMPS;

	SAVEI32(PL_debug);
	SAVESTACK_POS();
	PL_debug = 0;
	hasargs = 0;
	SPAGAIN;

d2002 5
d2014 10
a2023 3
	    PUSHBLOCK(cx, CXt_SUB, SP);
	    PUSHSUB_DB(cx);
	    cx->blk_sub.retop = PL_op->op_next;
d2025 1
a2025 2
	    if (CvDEPTH(cv) >= 2) {
		PERL_STACK_OVERFLOW_CHECK();
a2026 2
	    }
	    SAVECOMPPAD();
a2034 48
/* SVs on the stack that have any of the flags passed in are left as is.
   Other SVs are protected via the mortals stack if lvalue is true, and
   copied otherwise. */

STATIC SV **
S_adjust_stack_on_leave(pTHX_ SV **newsp, SV **sp, SV **mark, I32 gimme,
			      U32 flags, bool lvalue)
{
    bool padtmp = 0;
    PERL_ARGS_ASSERT_ADJUST_STACK_ON_LEAVE;

    if (flags & SVs_PADTMP) {
	flags &= ~SVs_PADTMP;
	padtmp = 1;
    }
    if (gimme == G_SCALAR) {
	if (MARK < SP)
	    *++newsp = ((SvFLAGS(*SP) & flags) || (padtmp && SvPADTMP(*SP)))
			    ? *SP
			    : lvalue
				? sv_2mortal(SvREFCNT_inc_simple_NN(*SP))
				: sv_mortalcopy(*SP);
	else {
	    /* MEXTEND() only updates MARK, so reuse it instead of newsp. */
	    MARK = newsp;
	    MEXTEND(MARK, 1);
	    *++MARK = &PL_sv_undef;
	    return MARK;
	}
    }
    else if (gimme == G_ARRAY) {
	/* in case LEAVE wipes old return values */
	while (++MARK <= SP) {
	    if ((SvFLAGS(*MARK) & flags) || (padtmp && SvPADTMP(*MARK)))
		*++newsp = *MARK;
	    else {
		*++newsp = lvalue
			    ? sv_2mortal(SvREFCNT_inc_simple_NN(*MARK))
			    : sv_mortalcopy(*MARK);
		TAINT_NOT;	/* Each item is independent */
	    }
	}
	/* When this function was called with MARK == newsp, we reach this
	 * point with SP == newsp. */
    }

    return newsp;
}
d2038 1
a2038 3
    dVAR; dSP;
    PERL_CONTEXT *cx;
    I32 gimme = GIMME_V;
d2040 3
a2042 4
    ENTER_with_name("block");

    SAVETMPS;
    PUSHBLOCK(cx, CXt_BLOCK, SP);
a2043 2
    RETURN;
}
a2046 1
    dVAR; dSP;
d2048 2
a2049 3
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
d2051 2
a2052 4
    if (PL_op->op_flags & OPf_SPECIAL) {
	cx = &cxstack[cxstack_ix];
	cx->blk_oldpm = PL_curpm;	/* fake block should preserve $1 et al */
    }
d2054 3
a2056 1
    POPBLOCK(cx,newpm);
d2058 2
a2059 1
    gimme = OP_GIMME(PL_op, (cxstack_ix >= 0) ? gimme : G_SCALAR);
d2061 5
a2065 4
    TAINT_NOT;
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP,
			       PL_op->op_private & OPpLVALUE);
    PL_curpm = newpm;	/* Don't pop $1 et al till now */
d2067 3
a2069 1
    LEAVE_with_name("block");
d2071 23
a2093 1
    RETURN;
d2098 1
a2098 1
    dVAR; dSP; dMARK;
d2100 4
a2103 6
    const I32 gimme = GIMME_V;
    void *itervar; /* location of the iteration variable */
    U8 cxtype = CXt_LOOP_FOR;

    ENTER_with_name("loop1");
    SAVETMPS;
d2106 3
d2110 7
a2116 10
	    SvPADSTALE_off(PAD_SVl(PL_op->op_targ));
	    SAVESETSVFLAGS(PAD_SVl(PL_op->op_targ),
		    SVs_PADSTALE, SVs_PADSTALE);
	}
	SAVEPADSVANDMORTALIZE(PL_op->op_targ);
#ifdef USE_ITHREADS
	itervar = PL_comppad;
#else
	itervar = &PAD_SVl(PL_op->op_targ);
#endif
d2118 17
a2134 6
    else {					/* symbol table variable */
	GV * const gv = MUTABLE_GV(POPs);
	SV** svp = &GvSV(gv);
	save_pushptrptr(gv, SvREFCNT_inc(*svp), SAVEt_GVSV);
	*svp = newSV(0);
	itervar = (void *)gv;
d2136 2
d2139 7
a2145 4
    if (PL_op->op_private & OPpITER_DEF)
	cxtype |= CXp_FOR_DEF;

    ENTER_with_name("loop2");
a2146 2
    PUSHBLOCK(cx, cxtype, SP);
    PUSHLOOP_FOR(cx, itervar, MARK);
d2148 3
d2153 1
d2156 2
a2160 1
		cx->cx_type &= ~CXTYPEMASK;
d2162 2
a2163 23
		/* Make sure that no-one re-orders cop.h and breaks our
		   assumptions */
		assert(CxTYPE(cx) == CXt_LOOP_LAZYIV);
#ifdef NV_PRESERVES_UV
		if ((SvOK(sv) && ((SvNV_nomg(sv) < (NV)IV_MIN) ||
				  (SvNV_nomg(sv) > (NV)IV_MAX)))
			||
		    (SvOK(right) && ((SvNV_nomg(right) > (NV)IV_MAX) ||
				     (SvNV_nomg(right) < (NV)IV_MIN))))
#else
		if ((SvOK(sv) && ((SvNV_nomg(sv) <= (NV)IV_MIN)
				  ||
		                  ((SvNV_nomg(sv) > 0) &&
					((SvUV_nomg(sv) > (UV)IV_MAX) ||
					 (SvNV_nomg(sv) > (NV)UV_MAX)))))
			||
		    (SvOK(right) && ((SvNV_nomg(right) <= (NV)IV_MIN)
				     ||
				     ((SvNV_nomg(right) > 0) &&
					((SvUV_nomg(right) > (UV)IV_MAX) ||
					 (SvNV_nomg(right) > (NV)UV_MAX))
				     ))))
#endif
a2166 4
#ifdef DEBUGGING
		/* for correct -Dstv display */
		cx->blk_oldsp = sp - PL_stack_base;
#endif
a2168 1
		cx->cx_type &= ~CXTYPEMASK;
a2169 3
		/* Make sure that no-one re-orders cop.h and breaks our
		   assumptions */
		assert(CxTYPE(cx) == CXt_LOOP_LAZYSV);
d2172 1
a2172 1
		SvREFCNT_inc(right);
d2186 2
d2189 1
a2189 1
	    SvREFCNT_inc(maybe_ary);
d2195 1
d2198 10
a2207 7
	cx->blk_loop.state_u.ary.ary = NULL; /* means to use the stack */
	if (PL_op->op_private & OPpITER_REVERSED) {
	    cx->blk_loop.state_u.ary.ix = cx->blk_oldsp + 1;
	}
	else {
	    cx->blk_loop.state_u.ary.ix = MARK - PL_stack_base;
	}
a2214 1
    dVAR; dSP;
d2216 1
a2216 1
    const I32 gimme = GIMME_V;
d2218 4
a2221 6
    ENTER_with_name("loop1");
    SAVETMPS;
    ENTER_with_name("loop2");

    PUSHBLOCK(cx, CXt_LOOP_PLAIN, SP);
    PUSHLOOP_PLAIN(cx, SP);
a2222 2
    RETURN;
}
a2225 1
    dVAR; dSP;
d2227 2
a2228 3
    I32 gimme;
    SV **newsp;
    PMOP *newpm;
d2231 1
a2231 1
    POPBLOCK(cx,newpm);
d2233 5
a2237 2
    mark = newsp;
    newsp = PL_stack_base + cx->blk_loop.resetsp;
d2239 5
a2243 4
    TAINT_NOT;
    SP = adjust_stack_on_leave(newsp, SP, MARK, gimme, 0,
			       PL_op->op_private & OPpLVALUE);
    PUTBACK;
d2245 4
a2248 5
    POPLOOP(cx);	/* Stack values are safe: release loop vars ... */
    PL_curpm = newpm;	/* ... and pop $1 et al */

    LEAVE_with_name("loop2");
    LEAVE_with_name("loop1");
a2252 109
STATIC void
S_return_lvalues(pTHX_ SV **mark, SV **sp, SV **newsp, I32 gimme,
                       PERL_CONTEXT *cx, PMOP *newpm)
{
    const bool ref = !!(CxLVAL(cx) & OPpENTERSUB_INARGS);
    if (gimme == G_SCALAR) {
	if (CxLVAL(cx) && !ref) {     /* Leave it as it is if we can. */
	    SV *sv;
	    const char *what = NULL;
	    if (MARK < SP) {
		assert(MARK+1 == SP);
		if ((SvPADTMP(TOPs) ||
		     (SvFLAGS(TOPs) & (SVf_READONLY | SVf_FAKE))
		       == SVf_READONLY
		    ) &&
		    !SvSMAGICAL(TOPs)) {
		    what =
			SvREADONLY(TOPs) ? (TOPs == &PL_sv_undef) ? "undef"
			: "a readonly value" : "a temporary";
		}
		else goto copy_sv;
	    }
	    else {
		/* sub:lvalue{} will take us here. */
		what = "undef";
	    }
	    LEAVE;
	    cxstack_ix--;
	    POPSUB(cx,sv);
	    PL_curpm = newpm;
	    LEAVESUB(sv);
	    Perl_croak(aTHX_
	              "Can't return %s from lvalue subroutine", what
	    );
	}
	if (MARK < SP) {
	      copy_sv:
		if (cx->blk_sub.cv && CvDEPTH(cx->blk_sub.cv) > 1) {
		    if (!SvPADTMP(*SP)) {
			*++newsp = SvREFCNT_inc(*SP);
			FREETMPS;
			sv_2mortal(*newsp);
		    }
		    else {
			/* FREETMPS could clobber it */
			SV *sv = SvREFCNT_inc(*SP);
			FREETMPS;
			*++newsp = sv_mortalcopy(sv);
			SvREFCNT_dec(sv);
		    }
		}
		else
		    *++newsp =
		      SvPADTMP(*SP)
		       ? sv_mortalcopy(*SP)
		       : !SvTEMP(*SP)
		          ? sv_2mortal(SvREFCNT_inc_simple_NN(*SP))
		          : *SP;
	}
	else {
	    EXTEND(newsp,1);
	    *++newsp = &PL_sv_undef;
	}
	if (CxLVAL(cx) & OPpDEREF) {
	    SvGETMAGIC(TOPs);
	    if (!SvOK(TOPs)) {
		TOPs = vivify_ref(TOPs, CxLVAL(cx) & OPpDEREF);
	    }
	}
    }
    else if (gimme == G_ARRAY) {
	assert (!(CxLVAL(cx) & OPpDEREF));
	if (ref || !CxLVAL(cx))
	    while (++MARK <= SP)
		*++newsp =
		       SvFLAGS(*MARK) & SVs_PADTMP
		           ? sv_mortalcopy(*MARK)
		     : SvTEMP(*MARK)
		           ? *MARK
		           : sv_2mortal(SvREFCNT_inc_simple_NN(*MARK));
	else while (++MARK <= SP) {
	    if (*MARK != &PL_sv_undef
		    && (SvPADTMP(*MARK)
		       || (SvFLAGS(*MARK) & (SVf_READONLY|SVf_FAKE))
		             == SVf_READONLY
		       )
	    ) {
		    SV *sv;
		    /* Might be flattened array after $#array =  */
		    PUTBACK;
		    LEAVE;
		    cxstack_ix--;
		    POPSUB(cx,sv);
		    PL_curpm = newpm;
		    LEAVESUB(sv);
	       /* diag_listed_as: Can't return %s from lvalue subroutine */
		    Perl_croak(aTHX_
			"Can't return a %s from lvalue subroutine",
			SvREADONLY(TOPs) ? "readonly value" : "temporary");
	    }
	    else
		*++newsp =
		    SvTEMP(*MARK)
		       ? *MARK
		       : sv_2mortal(SvREFCNT_inc_simple_NN(*MARK));
	}
    }
    PL_stack_sp = newsp;
}
d2254 11
a2264 1
PP(pp_return)
d2266 1
a2266 1
    dVAR; dSP; dMARK;
d2268 2
a2269 12
    bool popsub2 = FALSE;
    bool clear_errsv = FALSE;
    bool lval = FALSE;
    I32 gimme;
    SV **newsp;
    PMOP *newpm;
    I32 optype = 0;
    SV *namesv;
    SV *sv;
    OP *retop = NULL;

    const I32 cxix = dopoptosub(cxstack_ix);
d2271 2
a2272 14
    if (cxix < 0) {
	if (CxMULTICALL(cxstack)) { /* In this case we must be in a
				     * sort block, which is a CXt_NULL
				     * not a CXt_SUB */
	    dounwind(0);
	    PL_stack_base[1] = *PL_stack_sp;
	    PL_stack_sp = PL_stack_base + 1;
	    return 0;
	}
	else
	    DIE(aTHX_ "Can't return outside a subroutine");
    }
    if (cxix < cxstack_ix)
	dounwind(cxix);
d2274 4
a2277 8
    if (CxMULTICALL(&cxstack[cxix])) {
	gimme = cxstack[cxix].blk_gimme;
	if (gimme == G_VOID)
	    PL_stack_sp = PL_stack_base;
	else if (gimme == G_SCALAR) {
	    PL_stack_base[1] = *PL_stack_sp;
	    PL_stack_sp = PL_stack_base + 1;
	}
d2281 2
a2282 34
    POPBLOCK(cx,newpm);
    switch (CxTYPE(cx)) {
    case CXt_SUB:
	popsub2 = TRUE;
	lval = !!CvLVALUE(cx->blk_sub.cv);
	retop = cx->blk_sub.retop;
	cxstack_ix++; /* preserve cx entry on stack for use by POPSUB */
	break;
    case CXt_EVAL:
	if (!(PL_in_eval & EVAL_KEEPERR))
	    clear_errsv = TRUE;
	POPEVAL(cx);
	namesv = cx->blk_eval.old_namesv;
	retop = cx->blk_eval.retop;
	if (CxTRYBLOCK(cx))
	    break;
	if (optype == OP_REQUIRE &&
	    (MARK == SP || (gimme == G_SCALAR && !SvTRUE(*SP))) )
	{
	    /* Unassume the success we assumed earlier. */
	    (void)hv_delete(GvHVn(PL_incgv),
			    SvPVX_const(namesv),
                            SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv),
			    G_DISCARD);
	    DIE(aTHX_ "%"SVf" did not return a true value", SVfARG(namesv));
	}
	break;
    case CXt_FORMAT:
	retop = cx->blk_sub.retop;
	POPFORMAT(cx);
	break;
    default:
	DIE(aTHX_ "panic: return, type=%u", (unsigned) CxTYPE(cx));
    }
d2284 2
a2285 2
    TAINT_NOT;
    if (lval) S_return_lvalues(aTHX_ MARK, SP, newsp, gimme, cx, newpm);
d2287 65
a2351 39
      if (gimme == G_SCALAR) {
	if (MARK < SP) {
	    if (popsub2) {
		if (cx->blk_sub.cv && CvDEPTH(cx->blk_sub.cv) > 1) {
		    if (SvTEMP(TOPs) && SvREFCNT(TOPs) == 1
			 && !SvMAGICAL(TOPs)) {
			*++newsp = SvREFCNT_inc(*SP);
			FREETMPS;
			sv_2mortal(*newsp);
		    }
		    else {
			sv = SvREFCNT_inc(*SP);	/* FREETMPS could clobber it */
			FREETMPS;
			*++newsp = sv_mortalcopy(sv);
			SvREFCNT_dec(sv);
		    }
		}
		else if (SvTEMP(*SP) && SvREFCNT(*SP) == 1
			  && !SvMAGICAL(*SP)) {
		    *++newsp = *SP;
		}
		else
		    *++newsp = sv_mortalcopy(*SP);
	    }
	    else
		*++newsp = sv_mortalcopy(*SP);
	}
	else
	    *++newsp = &PL_sv_undef;
      }
      else if (gimme == G_ARRAY) {
	while (++MARK <= SP) {
	    *++newsp = popsub2 && SvTEMP(*MARK) && SvREFCNT(*MARK) == 1
			       && !SvGMAGICAL(*MARK)
			? *MARK : sv_mortalcopy(*MARK);
	    TAINT_NOT;		/* Each item is independent */
	}
      }
      PL_stack_sp = newsp;
d2354 5
a2358 9
    LEAVE;
    /* Stack values are safe: */
    if (popsub2) {
	cxstack_ix--;
	POPSUB(cx,sv);	/* release CV and @@_ ... */
    }
    else
	sv = NULL;
    PL_curpm = newpm;	/* ... and pop $1 et al */
a2359 4
    LEAVESUB(sv);
    if (clear_errsv) {
	CLEAR_ERRSV();
    }
d2363 2
a2364 3
/* This duplicates parts of pp_leavesub, so that it can share code with
 * pp_return */
PP(pp_leavesublv)
d2366 1
a2366 4
    dVAR; dSP;
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
d2368 1
a2368 1
    SV *sv;
d2370 31
a2400 2
    if (CxMULTICALL(&cxstack[cxstack_ix]))
	return 0;
d2402 54
a2455 2
    POPBLOCK(cx,newpm);
    cxstack_ix++; /* temporarily protect top context */
d2457 16
a2472 1
    TAINT_NOT;
d2474 1
a2474 1
    S_return_lvalues(aTHX_ newsp, SP, newsp, gimme, cx, newpm);
d2476 2
a2477 11
    LEAVE;
    POPSUB(cx,sv);	/* Stack values are safe: release CV and @@_ ... */
    cxstack_ix--;
    PL_curpm = newpm;	/* ... and pop $1 et al */

    LEAVESUB(sv);
    return cx->blk_sub.retop;
}

static I32
S_unwind_loop(pTHX_ const char * const opname)
a2478 1
    dVAR;
d2484 2
a2485 1
	    Perl_croak(aTHX_ "Can't \"%s\" outside a loop block", opname);
d2503 1
a2503 1
				       opname,
d2513 1
a2513 1
    return cxix;
d2516 1
a2518 1
    dVAR;
d2520 1
a2520 7
    I32 pop2 = 0;
    I32 gimme;
    I32 optype;
    OP *nextop = NULL;
    SV **newsp;
    PMOP *newpm;
    SV *sv = NULL;
d2522 1
a2522 1
    S_unwind_loop(aTHX_ "last");
d2524 6
a2529 26
    POPBLOCK(cx,newpm);
    cxstack_ix++; /* temporarily protect top context */
    switch (CxTYPE(cx)) {
    case CXt_LOOP_LAZYIV:
    case CXt_LOOP_LAZYSV:
    case CXt_LOOP_FOR:
    case CXt_LOOP_PLAIN:
	pop2 = CxTYPE(cx);
	newsp = PL_stack_base + cx->blk_loop.resetsp;
	nextop = cx->blk_loop.my_op->op_lastop->op_next;
	break;
    case CXt_SUB:
	pop2 = CXt_SUB;
	nextop = cx->blk_sub.retop;
	break;
    case CXt_EVAL:
	POPEVAL(cx);
	nextop = cx->blk_eval.retop;
	break;
    case CXt_FORMAT:
	POPFORMAT(cx);
	nextop = cx->blk_sub.retop;
	break;
    default:
	DIE(aTHX_ "panic: last, type=%u", (unsigned) CxTYPE(cx));
    }
a2531 1
    PL_stack_sp = newsp;
a2532 2
    LEAVE;
    cxstack_ix--;
d2534 5
a2538 13
    switch (pop2) {
    case CXt_LOOP_LAZYIV:
    case CXt_LOOP_PLAIN:
    case CXt_LOOP_LAZYSV:
    case CXt_LOOP_FOR:
	POPLOOP(cx);	/* release loop vars ... */
	LEAVE;
	break;
    case CXt_SUB:
	POPSUB(cx,sv);	/* release CV and @@_ ... */
	break;
    }
    PL_curpm = newpm;	/* ... and pop $1 et al */
a2539 3
    LEAVESUB(sv);
    PERL_UNUSED_VAR(optype);
    PERL_UNUSED_VAR(gimme);
a2544 1
    dVAR;
a2545 1
    const I32 inner = PL_scopestack_ix;
d2547 4
a2550 1
    S_unwind_loop(aTHX_ "next");
d2552 1
a2552 5
    /* clear off anything above the scope we're re-entering, but
     * save the rest until after a possible continue block */
    TOPBLOCK(cx);
    if (PL_scopestack_ix < inner)
	leave_scope(PL_scopestack[PL_scopestack_ix]);
d2560 2
a2561 5
    dVAR;
    const I32 cxix = S_unwind_loop(aTHX_ "redo");
    PERL_CONTEXT *cx;
    I32 oldsave;
    OP* redo_op = cxstack[cxix].blk_loop.my_op->op_redoop;
d2566 2
a2567 1
	assert(CxTYPE(&cxstack[cxstack_ix]) == CXt_BLOCK);
a2570 3
    TOPBLOCK(cx);
    oldsave = PL_scopestack[PL_scopestack_ix - 1];
    LEAVE_SCOPE(oldsave);
d2572 2
a2581 1
    dVAR;
d2603 1
a2603 1
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling) {
d2623 1
a2623 1
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling) {
d2643 4
a2646 1
PP(pp_goto) /* also pp_dump */
a2665 1
	/* This egregious kludge implements goto &subroutine */
d2667 1
a2671 1
	    I32 oldsave;
d2673 1
a2673 2
	retry:
	    if (!CvROOT(cv) && !CvXSUB(cv)) {
d2680 1
a2680 1
			goto retry;
d2685 1
a2685 1
			goto retry;
a2692 3
	    /* First do some returnish stuff. */
	    SvREFCNT_inc_simple_void(cv); /* avoid premature free during unwind */
	    FREETMPS;
d2694 2
a2695 6
	    if (cxix < cxstack_ix) {
                if (cxix < 0) {
                    SvREFCNT_dec(cv);
                    DIE(aTHX_ "Can't goto subroutine outside a subroutine");
                }
		dounwind(cxix);
d2697 1
a2697 2
	    TOPBLOCK(cx);
	    SPAGAIN;
a2699 1
		SvREFCNT_dec(cv);
a2707 2
	    {
		SvREFCNT_dec(cv);
d2709 19
a2727 1
	    }
d2729 14
a2742 10
		AV* av = cx->blk_sub.argarray;

		/* abandon the original @@_ if it got reified or if it is
		   the same as the current @@_ */
		if (AvREAL(av) || av == arg) {
		    SvREFCNT_dec(av);
		    av = newAV();
		    AvREIFY_only(av);
		    PAD_SVl(0) = MUTABLE_SV(cx->blk_sub.argarray = av);
		}
d2745 6
a2750 7
	    /* We donate this refcount later to the callee’s pad. */
	    SvREFCNT_inc_simple_void(arg);
	    if (CxTYPE(cx) == CXt_SUB &&
		!(CvDEPTH(cx->blk_sub.cv) = cx->blk_sub.olddepth))
		SvREFCNT_dec(cx->blk_sub.cv);
	    oldsave = PL_scopestack[PL_scopestack_ix - 1];
	    LEAVE_SCOPE(oldsave);
a2755 1
		SvREFCNT_dec(arg);
d2765 5
a2770 2
	    SAVETMPS;
	    SAVEFREESV(cv); /* later, undo the 'avoid premature free' hack */
a2771 3
		OP* const retop = cx->blk_sub.retop;
		SV **newsp;
		I32 gimme;
d2776 3
a2778 2
                PERL_UNUSED_VAR(newsp);
                PERL_UNUSED_VAR(gimme);
a2801 1
		SvREFCNT_dec(arg);
d2804 1
a2804 3
		    arg = GvAV(PL_defgv);
		    GvAV(PL_defgv) = cx->blk_sub.savearray;
		    SvREFCNT_dec(arg);
d2807 10
a2816 2
		/* XS subs don't have a CxSUB, so pop it */
		POPBLOCK(cx, PL_curpm);
d2822 1
a2822 2
		PERL_ASYNC_CHECK();
		return retop;
d2826 5
d2835 2
a2836 3
		if (CvDEPTH(cv) < 2)
		    SvREFCNT_inc_simple_void_NN(cv);
		else {
a2841 1
		SAVECOMPPAD();
d2845 5
a2849 8
		    CX_CURPAD_SAVE(cx->blk_sub);

		    /* cx->blk_sub.argarray has no reference count, so we
		       need something to hang on to our argument array so
		       that cx->blk_sub.argarray does not end up pointing
		       to freed memory as the result of undef *_.  So put
		       it in the callee’s pad, donating our refer-
		       ence count. */
d2852 2
a2853 1
			PAD_SVl(0) = (SV *)(cx->blk_sub.argarray = arg);
d2857 1
a2857 1
		       exit, so restore it. */
d2864 1
a2864 1
		else SvREFCNT_dec(arg);
d2876 2
a2877 2
		PERL_ASYNC_CHECK();
		RETURNOP(CvSTART(cv));
d2919 5
a2923 4
	    case CXt_LOOP_LAZYIV:
	    case CXt_LOOP_LAZYSV:
	    case CXt_LOOP_FOR:
	    case CXt_LOOP_PLAIN:
d2926 1
a2926 1
		gotoprobe = cx->blk_oldcop->op_sibling;
d2932 1
a2932 1
		    gotoprobe = cx->blk_oldcop->op_sibling;
d2942 1
a2942 1
		/* FALL THROUGH */
d2954 2
d2960 5
a2964 4
		if (gotoprobe->op_sibling &&
			gotoprobe->op_sibling->op_type == OP_UNSTACK &&
			gotoprobe->op_sibling->op_sibling) {
		    retop = dofindlabel(gotoprobe->op_sibling->op_sibling,
a2996 2
	    I32 oldsave;

d2998 1
a2998 1
		ix = 0;
d3000 2
a3001 3
	    TOPBLOCK(cx);
	    oldsave = PL_scopestack[PL_scopestack_ix];
	    LEAVE_SCOPE(oldsave);
d3034 3
d3038 1
a3038 1
    RETURNOP(retop);
a3042 1
    dVAR;
a3061 5
#ifdef PERL_MAD
    /* KLUDGE: disable exit 0 in BEGIN blocks when we're just compiling */
    if (anum || !(PL_minus_c && PL_madskills))
	my_exit(anum);
#else
a3062 1
#endif
d3103 1
a3103 1
See cop.h: je_mustcatch, when set at any runlevel to TRUE, means eval ops must
a3110 1
    dVAR;
d3124 2
a3125 2
	assert(CxTYPE(&cxstack[cxstack_ix]) == CXt_EVAL);
	cxstack[cxstack_ix].blk_eval.cur_top_env = PL_top_env;
d3137 1
a3137 1
	/* FALL THROUGH */
d3142 1
a3142 1
	assert(0); /* NOTREACHED */
d3154 2
a3155 2
If db_seqp is non_null, skip CVs that are in the DB package and populate
*db_seqp with the cop sequence number at the point that the DB:: code was
a3171 1
    dVAR;
d3202 1
a3202 1
		     || PadlistNAMES(CvPADLIST(cv)) != INT2PTR(PADNAMELIST *, arg))
d3229 1
a3229 1
    assert(CxTYPE(&cxstack[cxstack_ix]) == CXt_EVAL);
d3240 1
a3240 1
	assert(0); /* NOTREACHED */
d3262 1
a3262 1
S_doeval(pTHX_ int gimme, CV* outside, U32 seq, HV *hh)
d3264 1
a3264 1
    dVAR; dSP;
d3282 3
a3284 3
    assert(CxTYPE(&cxstack[cxstack_ix]) == CXt_EVAL);
    cxstack[cxstack_ix].blk_eval.cv = evalcv;
    cxstack[cxstack_ix].blk_gimme = gimme;
d3291 1
a3291 1
    CvPADLIST(evalcv) = pad_new(padnew_SAVE);
d3295 1
a3295 2
    if (!PL_madskills)
	SAVEMORTALIZESV(evalcv);	/* must remain until end of current statement */
a3312 4
#ifdef PERL_MAD
    SAVEBOOL(PL_madskills);
    PL_madskills = 0;
#endif
d3381 2
d3386 1
a3386 1
	SV **newsp;			/* Used by POPBLOCK. */
d3388 1
a3388 8
	I32 optype;			/* Used by POPEVAL. */
	SV *namesv;
        SV *errsv = NULL;

	cx = NULL;
	namesv = NULL;
	PERL_UNUSED_VAR(newsp);
	PERL_UNUSED_VAR(optype);
a3389 2
	/* note that if yystatus == 3, then the EVAL CX block has already
	 * been popped, and various vars restored */
d3391 3
d3400 7
a3406 5
	    POPBLOCK(cx,PL_curpm);
	    POPEVAL(cx);
	    namesv = cx->blk_eval.old_namesv;
	    /* POPBLOCK renders LEAVE_with_name("evalcomp") unnecessary. */
	    LEAVE_with_name("eval"); /* pp_entereval knows about this LEAVE.  */
d3411 7
a3417 20
	    if (!cx) {
		/* If cx is still NULL, it means that we didn't go in the
		 * POPEVAL branch. */
		cx = &cxstack[cxstack_ix];
		assert(CxTYPE(cx) == CXt_EVAL);
		namesv = cx->blk_eval.old_namesv;
	    }
	    (void)hv_store(GvHVn(PL_incgv),
			   SvPVX_const(namesv),
                           SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv),
			   &PL_sv_undef, 0);
	    Perl_croak(aTHX_ "%"SVf"Compilation failed in require",
		       SVfARG(errsv
                                ? errsv
                                : newSVpvs_flags("Unknown error\n", SVs_TEMP)));
	}
	else {
	    if (!*(SvPV_nolen_const(errsv))) {
	        sv_setpvs(errsv, "Compilation error");
	    }
d3419 4
d3427 4
a3430 2
    else
	LEAVE_with_name("evalcomp");
a3455 2
    /* compiled okay, so do it */

d3465 1
d3471 1
d3480 2
a3481 1
     * rather than for the .pm file.
d3484 1
d3487 1
d3489 5
d3504 1
d3506 15
a3520 4
#if !defined(PERLIO_IS_STDIO)
    return PerlIO_openn(aTHX_ ":", PERL_SCRIPT_MODE, -1, 0, 0, NULL, 1, &name);
#else
    return PerlIO_open(p, PERL_SCRIPT_MODE);
d3522 1
d3543 1
a3543 1
	Stat_t pmcstat;
d3546 1
a3546 1
	sv_catpvn(pmcsv, "c", 1);
d3548 3
a3550 2
	if (PerlLIO_stat(SvPV_nolen_const(pmcsv), &pmcstat) >= 0)
	    return check_type_and_open(pmcsv);
d3559 1
a3559 1
   explicity relative the current directory */
d3584 3
d3589 1
a3589 1
    dVAR; dSP;
d3602 1
a3602 1
    const I32 gimme = GIMME_V;
a3608 1
    SV *encoding;
d3612 1
d3615 1
d3673 3
a3675 1
    name = SvPV_const(sv, len);
d3677 2
a3678 1
	DIE(aTHX_ "Null filename used");
d3724 1
a3724 1
    LOADING_FILE_PROBE(unixname);
d3867 1
a3867 1
			SvREFCNT_dec(filter_state);
d3871 1
a3871 1
			SvREFCNT_dec(filter_sub);
d3967 2
a3968 1
		DIE(aTHX_ "Can't locate %s:   %s", name, Strerror(saved_errno));
d3984 1
a3984 1
				sv_catpvn(msg, "::", 2);
d4027 1
a4027 2
    ENTER_with_name("eval");
    SAVETMPS;
d4047 2
a4048 3
    PUSHBLOCK(cx, CXt_EVAL, SP);
    PUSHEVAL(cx, name);
    cx->blk_eval.retop = PL_op->op_next;
d4055 1
a4055 5
    /* Store and reset encoding. */
    encoding = PL_encoding;
    PL_encoding = NULL;

    if (doeval(gimme, NULL, PL_curcop->cop_seq, NULL))
d4060 1
a4060 4
    /* Restore encoding. */
    PL_encoding = encoding;

    LOADED_FILE_PROBE(unixname);
a4070 1
    dVAR;
d4079 1
a4079 1
    dVAR; dSP;
d4082 1
a4082 1
    const I32 gimme = GIMME_V;
d4092 1
d4130 2
a4131 1
    ENTER_with_name("eval");
a4136 1
    SAVETMPS;
d4161 2
a4162 3
    PUSHBLOCK(cx, (CXt_EVAL|CXp_REAL), SP);
    PUSHEVAL(cx, 0);
    cx->blk_eval.retop = PL_op->op_next;
d4166 1
a4166 1
    if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
d4181 1
a4181 1
    if (doeval(gimme, runcv, seq, saved_hh)) {
d4183 1
a4183 1
	    ? (PERLDB_LINE || PERLDB_SAVESRC)
d4193 1
a4193 1
	   in doeval().  */
d4195 1
a4195 1
	    ? (PERLDB_LINE || PERLDB_SAVESRC)
d4205 3
d4210 2
a4211 4
    dVAR; dSP;
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
d4214 1
a4214 3
    const U8 save_flags = PL_op -> op_flags;
    I32 optype;
    SV *namesv;
d4216 2
d4220 31
a4250 3
    POPBLOCK(cx,newpm);
    POPEVAL(cx);
    namesv = cx->blk_eval.old_namesv;
d4253 1
a4253 5

    TAINT_NOT;
    SP = adjust_stack_on_leave((gimme == G_VOID) ? SP : newsp, SP, newsp,
				gimme, SVs_TEMP, FALSE);
    PL_curpm = newpm;	/* Don't pop $1 et al till now */
d4260 1
a4260 3
    if (optype == OP_REQUIRE &&
	!(gimme == G_SCALAR ? SvTRUE(*SP) : SP > newsp))
    {
d4262 2
a4263 13
	(void)hv_delete(GvHVn(PL_incgv),
			SvPVX_const(namesv),
                        SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv),
			G_DISCARD);
	retop = Perl_die(aTHX_ "%"SVf" did not return a true value",
			       SVfARG(namesv));
	/* die_unwind() did LEAVE, or we won't be here */
    }
    else {
	LEAVE_with_name("eval");
	if (!(save_flags & OPf_SPECIAL)) {
	    CLEAR_ERRSV();
	}
d4266 4
a4269 1
    RETURNOP(retop);
a4276 3
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
a4277 1
    I32 optype;
d4279 5
a4283 7
    POPBLOCK(cx,newpm);
    POPEVAL(cx);
    PL_curpm = newpm;
    LEAVE_with_name("eval_scope");
    PERL_UNUSED_VAR(newsp);
    PERL_UNUSED_VAR(gimme);
    PERL_UNUSED_VAR(optype);
d4288 2
a4289 2
PERL_CONTEXT *
Perl_create_eval_scope(pTHX_ U32 flags)
d4292 1
a4292 1
    const I32 gimme = GIMME_V;
d4294 3
a4296 5
    ENTER_with_name("eval_scope");
    SAVETMPS;

    PUSHBLOCK(cx, (CXt_EVAL|CXp_TRYBLOCK), PL_stack_sp);
    PUSHEVAL(cx, 0);
a4305 1
    return cx;
d4310 1
a4310 3
    dVAR;
    PERL_CONTEXT * const cx = create_eval_scope(0);
    cx->blk_eval.retop = cLOGOP->op_other->op_next;
d4314 3
d4319 2
a4320 4
    dVAR; dSP;
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
d4322 1
a4322 1
    I32 optype;
a4324 3
    POPBLOCK(cx,newpm);
    POPEVAL(cx);
    PERL_UNUSED_VAR(optype);
d4326 14
a4339 4
    TAINT_NOT;
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme,
			       SVs_PADTMP|SVs_TEMP, FALSE);
    PL_curpm = newpm;	/* Don't pop $1 et al till now */
a4340 1
    LEAVE_with_name("eval_scope");
d4342 1
a4342 1
    RETURN;
d4347 1
a4347 1
    dVAR; dSP;
d4349 3
a4351 1
    const I32 gimme = GIMME_V;
d4353 2
a4354 12
    ENTER_with_name("given");
    SAVETMPS;

    if (PL_op->op_targ) {
	SAVEPADSVANDMORTALIZE(PL_op->op_targ);
	SvREFCNT_dec(PAD_SVl(PL_op->op_targ));
	PAD_SVl(PL_op->op_targ) = SvREFCNT_inc_NN(POPs);
    }
    else {
	SAVE_DEFSV;
	DEFSV_set(POPs);
    }
d4356 2
a4357 2
    PUSHBLOCK(cx, CXt_GIVEN, SP);
    PUSHGIVEN(cx);
a4363 1
    dVAR; dSP;
d4365 2
a4366 3
    I32 gimme;
    SV **newsp;
    PMOP *newpm;
d4369 1
a4369 1
    POPBLOCK(cx,newpm);
d4371 7
d4379 4
a4382 4
    TAINT_NOT;
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme,
			       SVs_PADTMP|SVs_TEMP, FALSE);
    PL_curpm = newpm;	/* Don't pop $1 et al till now */
d4384 1
a4384 2
    LEAVE_with_name("given");
    RETURN;
a4390 1
    dVAR;
a4405 1
    dVAR;
d4407 1
d4416 4
a4419 1
    return (SvTRUEx(POPs));
a4424 2
    dVAR;

a4444 1
    dVAR;
d4481 1
a4481 1

d4492 1
a4492 1
    if (sv_isobject(e) && (SvTYPE(SvRV(e)) != SVt_REGEXP)) {
d4496 1
a4496 1
    if (sv_isobject(d) && (SvTYPE(SvRV(d)) != SVt_REGEXP))
d4678 1
d4680 1
d4685 1
d4790 1
d4792 1
d4796 1
d4857 1
d4861 3
a4863 3
	    PUSHs(matcher_matches_sv(matcher, d)
		    ? &PL_sv_yes
		    : &PL_sv_no);
d4923 1
a4923 1
    dVAR; dSP;
d4925 1
a4925 1
    const I32 gimme = GIMME_V;
d4933 1
a4933 1
    if ((0 == (PL_op->op_flags & OPf_SPECIAL)) && !SvTRUEx(POPs))
d4936 2
a4937 5
    ENTER_with_name("when");
    SAVETMPS;

    PUSHBLOCK(cx, CXt_WHEN, SP);
    PUSHWHEN(cx);
a4943 1
    dVAR; dSP;
d4946 2
a4947 3
    I32 gimme;
    SV **newsp;
    PMOP *newpm;
d4949 5
a4953 1
    cxix = dopoptogiven(cxstack_ix);
d4959 5
a4963 7
    POPBLOCK(cx,newpm);
    assert(CxTYPE(cx) == CXt_WHEN);

    TAINT_NOT;
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme,
			       SVs_PADTMP|SVs_TEMP, FALSE);
    PL_curpm = newpm;   /* pop $1 et al */
d4965 3
a4967 4
    LEAVE_with_name("when");

    if (cxix < cxstack_ix)
        dounwind(cxix);
d4972 4
a4975 6
	/* clear off anything above the scope we're re-entering */
	I32 inner = PL_scopestack_ix;

	TOPBLOCK(cx);
	if (PL_scopestack_ix < inner)
	    leave_scope(PL_scopestack[PL_scopestack_ix]);
a4976 2

	PERL_ASYNC_CHECK();
d4981 2
a4982 1
	RETURNOP(cx->blk_givwhen.leave_op);
a4987 1
    dVAR; dSP;
d4990 1
a4990 5
    I32 gimme;
    SV **newsp;
    PMOP *newpm;

    PERL_UNUSED_VAR(gimme);
d4999 1
a4999 1
    POPBLOCK(cx,newpm);
d5001 6
d5008 1
a5008 5
    SP = newsp;
    PL_curpm = newpm;   /* pop $1 et al */

    LEAVE_with_name("when");
    RETURNOP(cx->blk_givwhen.leave_op->op_next);
a5012 1
    dVAR;   
d5016 1
a5016 1
    cxix = dopoptogiven(cxstack_ix); 
d5028 2
a5029 1
    TOPBLOCK(cx);
d5125 1
a5125 1
	    /* FALL THROUGH */
a5315 1
    dVAR;
d5335 1
a5335 1
       parse error occured.  (Had to hack around it with a test
a5511 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.17
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d593 1
d682 1
a682 1
	    {
d708 1
a712 1
		chophere = s + len;
@


1.16
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d156 1
a156 1
#if NO_TAINT_SUPPORT
a170 1
#ifndef INCOMPLETE_TAINTS
a174 1
#endif
a214 1
    RX_MATCH_UTF8_set(rx, DO_UTF8(cx->sb_targ));
a226 4
	/* XXX: adjust for positive offsets of \G for instance s/(.)\G//g with positive pos() */
	s -= RX_GOFS(rx);

	/* Are we done */
d228 3
a230 3
		!CALLREGEXEC(rx, s, cx->sb_strend, orig,
			     (s == m) + RX_GOFS(rx), cx->sb_targ, NULL,
                                (REXEC_IGNOREPOS|REXEC_NOT_FIRST)))
d251 3
a253 6
		if (SvIsCOW(targ)) {
		    sv_force_normal_flags(targ, SV_COW_DROP_PV);
		} else
		{
		    SvPV_free(targ);
		}
d319 2
a320 8
	SvUPGRADE(sv, SVt_PVMG);
	if (!(mg = mg_find(sv, PERL_MAGIC_regex_global))) {
#ifdef PERL_OLD_COPY_ON_WRITE
	    if (SvIsCOW(sv))
		sv_force_normal_flags(sv, 0);
#endif
	    mg = sv_magicext(sv, NULL, PERL_MAGIC_regex_global, &PL_vtbl_mglob,
			     NULL, 0);
d322 2
a323 1
	mg->mg_len = m - orig;
d469 2
a470 1
    I32 itemsize  = 0;	    /* length of current item, possibly truncated */
d478 1
a478 1
    STRLEN len;
d538 1
a538 1
	case FF_LINEMARK:
d544 1
a544 1
	case FF_LITERAL:
d552 1
a552 1
	case FF_SKIP:
d556 1
a556 1
	case FF_FETCH:
d571 1
a571 1
	case FF_CHECKNL:
a572 1
		const char *send;
d574 19
a592 38
		itemsize = len;
		if (DO_UTF8(sv)) {
		    itemsize = sv_len_utf8(sv);
		    if (itemsize != (I32)len) {
			I32 itembytes;
			if (itemsize > fieldsize) {
			    itemsize = fieldsize;
			    itembytes = itemsize;
			    sv_pos_u2b(sv, &itembytes, 0);
			}
			else
			    itembytes = len;
			send = chophere = s + itembytes;
			while (s < send) {
			    if (*s & ~31)
				gotsome = TRUE;
			    else if (*s == '\n')
				break;
			    s++;
			}
			item_is_utf8 = TRUE;
			itemsize = s - item;
			sv_pos_b2u(sv, &itemsize);
			break;
		    }
		}
		item_is_utf8 = FALSE;
		if (itemsize > fieldsize)
		    itemsize = fieldsize;
		send = chophere = s + itemsize;
		while (s < send) {
		    if (*s & ~31)
			gotsome = TRUE;
		    else if (*s == '\n')
			break;
		    s++;
		}
		itemsize = s - item;
d596 1
a596 1
	case FF_CHECKCHOP:
d599 53
a651 79
		itemsize = len;
		if (DO_UTF8(sv)) {
		    itemsize = sv_len_utf8(sv);
		    if (itemsize != (I32)len) {
			I32 itembytes;
			if (itemsize <= fieldsize) {
			    const char *send = chophere = s + itemsize;
			    while (s < send) {
				if (*s == '\r') {
				    itemsize = s - item;
				    chophere = s;
				    break;
				}
				if (*s++ & ~31)
				    gotsome = TRUE;
			    }
			}
			else {
			    const char *send;
			    itemsize = fieldsize;
			    itembytes = itemsize;
			    sv_pos_u2b(sv, &itembytes, 0);
			    send = chophere = s + itembytes;
			    while (s < send || (s == send && isSPACE(*s))) {
				if (isSPACE(*s)) {
				    if (chopspace)
					chophere = s;
				    if (*s == '\r')
					break;
				}
				else {
				    if (*s & ~31)
					gotsome = TRUE;
				    if (strchr(PL_chopset, *s))
					chophere = s + 1;
				}
				s++;
			    }
			    itemsize = chophere - item;
			    sv_pos_b2u(sv, &itemsize);
			}
			item_is_utf8 = TRUE;
			break;
		    }
		}
		item_is_utf8 = FALSE;
		if (itemsize <= fieldsize) {
		    const char *const send = chophere = s + itemsize;
		    while (s < send) {
			if (*s == '\r') {
			    itemsize = s - item;
			    chophere = s;
			    break;
			}
			if (*s++ & ~31)
			    gotsome = TRUE;
		    }
		}
		else {
		    const char *send;
		    itemsize = fieldsize;
		    send = chophere = s + itemsize;
		    while (s < send || (s == send && isSPACE(*s))) {
			if (isSPACE(*s)) {
			    if (chopspace)
				chophere = s;
			    if (*s == '\r')
				break;
			}
			else {
			    if (*s & ~31)
				gotsome = TRUE;
			    if (strchr(PL_chopset, *s))
				chophere = s + 1;
			}
			s++;
		    }
		    itemsize = chophere - item;
		}
d655 1
a655 1
	case FF_SPACE:
d664 1
a664 1
	case FF_HALFSPACE:
d674 2
a675 2
	case FF_ITEM:
	    to_copy = itemsize;
a677 7
	    if (item_is_utf8) {
		/* convert to_copy from chars to bytes */
		U8 *s = source;
		while (to_copy--)
		   s += UTF8SKIP(s);
		to_copy = s - source;
	    }
d680 1
a680 1
	case FF_CHOP:
d687 6
a692 1
		sv_chop(sv,s);
d697 1
a697 1
	case FF_LINESNGL:
d699 2
a700 1
	case FF_LINEGLOB:
d717 1
a717 1
			    to_copy = s - SvPVX_const(sv) - 1;
d784 1
a784 7
			if (trans == '~' ? (ch == '~') :
#ifdef EBCDIC
			       iscntrl(ch)
#else
			       (!(ch & ~31))
#endif
			)
d797 1
a797 1
	case FF_0DECIMAL:
d809 2
a810 1
	case FF_DECIMAL:
d839 1
a839 1
		STORE_NUMERIC_STANDARD_SET_LOCAL();
d841 2
d844 2
a845 1
		RESTORE_NUMERIC_STANDARD();
d850 1
a850 1
	case FF_NEWLINE:
d857 1
a857 1
	case FF_BLANK:
d871 1
a871 1
	case FF_MORE:
d898 2
a899 1
	case FF_END:
d941 5
d1094 4
d1189 4
a1192 2
	    if ((SvOK(left) && SvNV_nomg(left) < IV_MIN) ||
		(SvOK(right) && SvNV_nomg(right) > IV_MAX))
d1198 2
d1706 1
a1706 1
The XSUB-writer's equivalent of L<caller()|perlfunc/caller>. The
d1708 1
a1708 1
information returned to Perl by C<caller>. Note that XSUBs don't get a
d1713 1
a1713 1
behalf of the debugger. If the stack frame requested was a sub called by
d1716 1
a1716 1
site. If I<dbcxp> is non-C<NULL>, it will be set to a pointer to the
d1773 1
d1817 5
a1821 1
    mPUSHi((I32)CopLINE(cx->blk_oldcop));
d1850 10
a1859 3
	    PUSHs(newSVpvn_flags(SvPVX(cx->blk_eval.cur_text),
				 SvCUR(cx->blk_eval.cur_text)-2,
				 SvUTF8(cx->blk_eval.cur_text)|SVs_TEMP));
d1881 1
a1881 1
	const int off = AvARRAY(ary) - AvALLOC(ary);
d2004 4
d2009 2
a2010 1
S_adjust_stack_on_leave(pTHX_ SV **newsp, SV **sp, SV **mark, I32 gimme, U32 flags)
d2022 4
a2025 1
			    ? *SP : sv_mortalcopy(*SP);
d2040 3
a2042 1
		*++newsp = sv_mortalcopy(*MARK);
d2085 2
a2086 1
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP);
d2248 2
a2249 1
    SP = adjust_stack_on_leave(newsp, SP, MARK, gimme, 0);
d2442 1
a2443 1
	retop = cx->blk_sub.retop;
d2532 1
a2533 1
    POPSUB(cx,sv);	/* Stack values are safe: release CV and @@_ ... */
a2589 1
    SV **mark;
a2595 1
    mark = newsp;
d2622 1
a2622 2
    PL_stack_sp = adjust_stack_on_leave(newsp, PL_stack_sp, MARK, gimme,
				pop2 == CXt_SUB ? SVs_TEMP : 0);
d2754 1
a2754 1
PP(pp_goto)
d2769 2
d2873 2
a2874 1
		const SSize_t items = AvFILLp(arg) + 1;
d2881 3
a2883 2
		EXTEND(SP, items+1); /* @@_ could have been extended. */
		Copy(AvARRAY(arg), SP + 1, items, SV*);
d2885 3
a2887 3
		SP += items;
		if (AvREAL(arg)) {
		    I32 index;
d2889 11
a2899 1
			SvREFCNT_inc_void(sv_2mortal(SP[-index]));
d2901 1
d2946 4
a2949 2
		    SvREFCNT_dec(PAD_SVl(0));
		    PAD_SVl(0) = (SV *)(cx->blk_sub.argarray = arg);
d2976 1
d2982 1
d3065 2
a3066 3
	    DIE(aTHX_ "Can't find label %"SVf,
                            SVfARG(newSVpvn_flags(label, label_len,
                                        SVs_TEMP | label_flags)));
d3146 2
a3147 1
        if (anum == 1 && (PL_op->op_private & OPpEXIT_VMSISH))
d3149 2
a3150 1
        VMSISH_HUSHED  = VMSISH_HUSHED || (PL_op->op_private & OPpHUSH_VMSISH);
d3255 2
a3256 2
entered. (allows debuggers to eval in the scope of the breakpoint rather
than in the scope of the debugger itself).
d3402 3
a3404 1
	PL_curstash = (HV *)SvREFCNT_inc_simple(CopSTASH(PL_curcop));
d3585 3
a3587 2
    const char *p = SvPV_nolen_const(name);
    const int st_rc = PerlLIO_stat(p, &st);
d3591 16
d3611 1
a3611 1
#if !defined(PERLIO_IS_STDIO) && !defined(USE_SFIO)
d3627 7
d3650 26
a3686 1
    char *unixnamebuf;
a3687 1
    char *unixdirbuf;
d3701 1
d3728 1
a3728 1
		    || av_len(lav) > 1               /* FP with > 3 digits */
d3741 1
a3741 1
		    if (av_len(lav)>=1) 
d3764 6
d3772 1
d3782 3
a3784 2
    if ((unixnamebuf = SvPVX(sv_2mortal(newSVpv("", VMS_MAXRSS-1))))
        && (unixname = tounixspec(name, unixnamebuf)) != NULL) {
d3813 1
a3813 1
    if (path_is_absolute(name)) {
d3818 1
a3818 1
    if (!tryrsfp && !(errno == EACCES && path_is_absolute(name))) {
d3820 1
a3820 1
	I32 i;
d3825 1
d3830 1
a3830 2
		if (SvTIED_mg((const SV *)ar, PERL_MAGIC_tied))
		    mg_get(dirsv);
d3837 1
a3837 1
			&& !sv_isobject(loader))
d3840 1
d3848 5
d3859 1
a3859 1
		    PUSHs(sv);
d3861 5
a3881 1
			    SvREFCNT_inc_simple_void_NN(filter_cache);
d3928 3
d3935 3
d3950 1
a3950 4
		    if (filter_cache) {
			SvREFCNT_dec(filter_cache);
			filter_cache = NULL;
		    }
d3961 1
a3961 2
		  if (!path_is_absolute(name)
		  ) {
d3966 1
a3966 1
			dir = SvPV_const(dirsv, dirlen);
d3972 2
d3975 3
a3977 2
		    if (((unixdirbuf = SvPVX(sv_2mortal(newSVpv("", VMS_MAXRSS-1)))) == NULL)
			|| ((unixdir = tounixpath(dir, unixdirbuf)) == NULL))
d4009 3
d4056 1
a4056 1
		    I32 i;
d4122 4
a4125 1
	SV * const datasv = filter_add(S_run_user_filter, filter_cache);
d4321 1
a4321 1
				gimme, SVs_TEMP);
d4419 2
a4420 1
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP);
d4466 2
a4467 1
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP);
d4625 1
a4625 1
	    I32 i;
d4628 1
a4628 1
	    const I32 len = av_len(av);
d4687 2
a4688 2
	    bool tied = FALSE;
	    bool other_tied = FALSE;
d4695 13
a4707 2
	    if (SvTIED_mg((SV*)hv, PERL_MAGIC_tied)) {
		tied = TRUE;
a4708 11
	    else if (SvTIED_mg((const SV *)other_hv, PERL_MAGIC_tied)) {
		HV * const temp = other_hv;
		other_hv = hv;
		hv = temp;
		tied = TRUE;
	    }
	    if (SvTIED_mg((const SV *)other_hv, PERL_MAGIC_tied))
		other_tied = TRUE;
	    
	    if (!tied && HvUSEDKEYS((const HV *) hv) != HvUSEDKEYS(other_hv))
	    	RETPUSHNO;
d4740 2
a4741 2
	    const I32 other_len = av_len(other_av) + 1;
	    I32 i;
d4792 2
a4793 2
	    const I32 other_len = av_len(other_av) + 1;
	    I32 i;
d4810 1
a4810 1
	    if (av_len(MUTABLE_AV(SvRV(e))) != av_len(other_av))
d4813 2
a4814 2
	    	I32 i;
	    	const I32 other_len = av_len(other_av);
d4869 2
a4870 2
		const I32 this_len = av_len(MUTABLE_AV(SvRV(e)));
		I32 i;
d4886 2
a4887 2
	    const I32 this_len = av_len(MUTABLE_AV(SvRV(e)));
	    I32 i;
d4901 2
a4902 2
		I32 i;
		const I32 this_len = av_len(MUTABLE_AV(SvRV(e)));
d5045 2
a5046 1
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP);
d5503 1
d5519 4
d5525 1
a5525 1
	got_p = SvPV(upstream, got_len);
d5556 6
a5561 1
	SvCUR_set(upstream, got_len - cached_len);
d5573 2
a5574 2
        (SvOK(upstream) || SvGMAGICAL(upstream))) {
	sv_catsv(buf_sv, upstream);
d5576 1
a5600 26
}

/* perhaps someone can come up with a better name for
   this?  it is not really "absolute", per se ... */
static bool
S_path_is_absolute(const char *name)
{
    PERL_ARGS_ASSERT_PATH_IS_ABSOLUTE;

    if (PERL_FILE_IS_ABSOLUTE(name)
#ifdef WIN32
	|| (*name == '.' && ((name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/'))
			 || (name[1] == '\\' ||
			     ( name[1] == '.' && name[2] == '\\')))
	    )
#else
	|| (*name == '.' && (name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/')))
#endif
	 )
    {
	return TRUE;
    }
    else
    	return FALSE;
@


1.15
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a71 3
    /* XXXX Should store the old value to allow for tie/overload - and
       restore in regcomp, where marked with XXXX. */
    PL_reginterp_cnt = 0;
d80 3
a82 2
    register PMOP *pm = (PMOP*)cLOGOP->op_other;
    SV *tmpstr;
d84 13
d101 1
a101 6
	if (PL_op->op_flags & OPf_STACKED) {
	    dMARK;
	    SP = MARK;
	}
	else
	    (void)POPs;
d106 3
a108 15
#define tryAMAGICregexp(rx)			\
    STMT_START {				\
	SvGETMAGIC(rx);				\
	if (SvROK(rx) && SvAMAGIC(rx)) {	\
	    SV *sv = AMG_CALLunary(rx, regexp_amg); \
	    if (sv) {				\
		if (SvROK(sv))			\
		    sv = SvRV(sv);		\
		if (SvTYPE(sv) != SVt_REGEXP)	\
		    Perl_croak(aTHX_ "Overloaded qr did not return a REGEXP"); \
		rx = sv;			\
	    }					\
	}					\
    } STMT_END
	    
d110 2
a111 8
    if (PL_op->op_flags & OPf_STACKED) {
	/* multiple args; concatenate them */
	dMARK; dORIGMARK;
	tmpstr = PAD_SV(ARGTARG);
	sv_setpvs(tmpstr, "");
	while (++MARK <= SP) {
	    SV *msv = *MARK;
	    SV *sv;
d113 2
a114 1
	    tryAMAGICregexp(msv);
d116 2
a117 6
	    if ((SvAMAGIC(tmpstr) || SvAMAGIC(msv)) &&
		(sv = amagic_call(tmpstr, msv, concat_amg, AMGf_assign)))
	    {
	       sv_setsv(tmpstr, sv);
	       continue;
	    }
d119 2
a120 5
	    if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP) {
		msv = SvRV(msv);
		PL_reginterp_cnt +=
		    RX_SEEN_EVALS((REGEXP *)MUTABLE_PTR(msv));
	    }
d122 37
a158 1
	    sv_catsv_nomg(tmpstr, msv);
d160 3
a162 2
    	SvSETMAGIC(tmpstr);
	SP = ORIGMARK;
a163 6
    else {
	tmpstr = POPs;
	tryAMAGICregexp(tmpstr);
    }

#undef tryAMAGICregexp
d165 3
a167 33
    if (SvROK(tmpstr)) {
	SV * const sv = SvRV(tmpstr);
	if (SvTYPE(sv) == SVt_REGEXP)
	    re = (REGEXP*) sv;
    }
    else if (SvTYPE(tmpstr) == SVt_REGEXP)
	re = (REGEXP*) tmpstr;

    if (re) {
	/* The match's LHS's get-magic might need to access this op's reg-
	   exp (as is sometimes the case with $';  see bug 70764).  So we
	   must call get-magic now before we replace the regexp. Hopeful-
	   ly this hack can be replaced with the approach described at
	   http://www.nntp.perl.org/group/perl.perl5.porters/2007/03
	   /msg122415.html some day. */
	if(pm->op_type == OP_MATCH) {
	 SV *lhs;
	 const bool was_tainted = PL_tainted;
	 if (pm->op_flags & OPf_STACKED)
	    lhs = TOPs;
	 else if (pm->op_private & OPpTARGET_MY)
	    lhs = PAD_SV(pm->op_targ);
	 else lhs = DEFSV;
	 SvGETMAGIC(lhs);
	 /* Restore the previous value of PL_tainted (which may have been
	    modified by get-magic), to avoid incorrectly setting the
	    RXf_TAINTED flag further down. */
	 PL_tainted = was_tainted;
	}

	re = reg_temp_copy(NULL, re);
	ReREFCNT_dec(PM_GETRE(pm));
	PM_SETRE(pm, re);
a168 42
    else {
	STRLEN len = 0;
	const char *t = SvOK(tmpstr) ? SvPV_nomg_const(tmpstr, len) : "";

	re = PM_GETRE(pm);
	assert (re != (REGEXP*) &PL_sv_undef);

	/* Check against the last compiled regexp. */
	if (!re || !RX_PRECOMP(re) || RX_PRELEN(re) != len ||
	    memNE(RX_PRECOMP(re), t, len))
	{
	    const regexp_engine *eng = re ? RX_ENGINE(re) : NULL;
            U32 pm_flags = pm->op_pmflags & RXf_PMf_COMPILETIME;
	    if (re) {
	        ReREFCNT_dec(re);
#ifdef USE_ITHREADS
		PM_SETRE(pm, (REGEXP*) &PL_sv_undef);
#else
		PM_SETRE(pm, NULL);	/* crucial if regcomp aborts */
#endif
	    } else if (PL_curcop->cop_hints_hash) {
	        SV *ptr = cop_hints_fetch_pvs(PL_curcop, "regcomp", 0);
                if (ptr && SvIOK(ptr) && SvIV(ptr))
                    eng = INT2PTR(regexp_engine*,SvIV(ptr));
	    }

	    if (PL_op->op_flags & OPf_SPECIAL)
		PL_reginterp_cnt = I32_MAX; /* Mark as safe.  */

	    if (!DO_UTF8(tmpstr) && SvUTF8(tmpstr)) {
		/* Not doing UTF-8, despite what the SV says. Is this only if
		   we're trapped in use 'bytes'?  */
		/* Make a copy of the octet sequence, but without the flag on,
		   as the compiler now honours the SvUTF8 flag on tmpstr.  */
		STRLEN len;
		const char *const p = SvPV(tmpstr, len);
		tmpstr = newSVpvn_flags(p, len, SVs_TEMP);
	    }
	    else if (SvAMAGIC(tmpstr) || SvGMAGICAL(tmpstr)) {
		/* make a copy to avoid extra stringifies */
		tmpstr = newSVpvn_flags(t, len, SVs_TEMP | SvUTF8(tmpstr));
	    }
a169 11
	    if (eng)
	        PM_SETRE(pm, CALLREGCOMP_ENG(eng, tmpstr, pm_flags));
	    else
	        PM_SETRE(pm, CALLREGCOMP(tmpstr, pm_flags));

	    PL_reginterp_cnt = 0;	/* XXXX Be extra paranoid - needed
					   inside tie/overload accessors.  */
	}
    }
    
    re = PM_GETRE(pm);
d172 3
a174 5
    if (PL_tainting) {
	if (PL_tainted) {
	    SvTAINTED_on((SV*)re);
	    RX_EXTFLAGS(re) |= RXf_TAINTED;
	}
a177 4
    if (!RX_PRELEN(PM_GETRE(pm)) && PL_curpm)
	pm = PL_curpm;


d181 2
d188 2
d193 1
d198 5
a202 5
    register PERL_CONTEXT *cx = &cxstack[cxstack_ix];
    register PMOP * const pm = (PMOP*) cLOGOP->op_other;
    register SV * const dstr = cx->sb_dstr;
    register char *s = cx->sb_s;
    register char *m = cx->sb_m;
d204 1
a204 1
    register REGEXP * const rx = cx->sb_rx;
a233 7
	/* I believe that we can't set REXEC_SCREAM here if
	   SvSCREAM(cx->sb_targ) is true because SvPVX(cx->sb_targ) isn't always
	   equal to s.  [See the comment before Perl_re_intuit_start(), which is
	   called from Perl_regexec_flags(), which says that it should be when
	   SvSCREAM() is true.]  s, cx->sb_strend and orig will be consistent
	   with SvPVX(cx->sb_targ), as substconst doesn't modify cx->sb_targ
	   during the match.  */
d237 1
a237 3
			     ((cx->sb_rflags & REXEC_COPY_STR)
			      ? (REXEC_IGNOREPOS|REXEC_NOT_FIRST)
			      : (REXEC_COPY_STR|REXEC_IGNOREPOS|REXEC_NOT_FIRST))))
d244 1
a244 1
		      sv_catpvn_utf8_upgrade(dstr, s, cx->sb_strend - s, nsv);
d246 1
a246 1
		      sv_catpvn(dstr, s, cx->sb_strend - s);
d271 1
d280 1
a280 1
	    if (PL_tainting) {
d292 4
a295 2
		PL_tainted = cBOOL(cx->sb_rxtainted &
			    (SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL));
d303 1
d305 1
a305 1
	    /* NOTREACHED */
d312 1
d320 1
a320 1
	    sv_catpvn_utf8_upgrade(dstr, s, m - s, nsv);
d322 1
a322 1
	    sv_catpvn(dstr, s, m-s);
d345 1
a345 1
    if (PL_tainting) {
d376 2
a377 2
#ifdef PERL_OLD_COPY_ON_WRITE
	i = 7 + RX_NPARENS(rx) * 2;
d379 1
a379 1
	i = 6 + RX_NPARENS(rx) * 2;
d388 1
d391 1
d393 1
a393 1
#ifdef PERL_OLD_COPY_ON_WRITE
a397 2
    *p++ = RX_NPARENS(rx);

d400 2
d420 1
d422 1
a422 1
#ifdef PERL_OLD_COPY_ON_WRITE
a428 2
    RX_NPARENS(rx) = *p++;

d431 2
d448 1
d450 2
a451 4
	void *tmp = INT2PTR(char*,*p);
	Safefree(tmp);
	if (*p)
	    PoisonFree(*p, 1, sizeof(*p));
d453 2
a454 1
	Safefree(INT2PTR(char*,*p));
d456 6
a461 4
#ifdef PERL_OLD_COPY_ON_WRITE
	if (p[1]) {
	    SvREFCNT_dec (INT2PTR(SV*,p[1]));
	}
d463 2
d476 1
a476 1
    register SV * const tmpForm = *++MARK;
d478 2
a479 2
    register U32 *fpc;	    /* format ops program counter */
    register char *t;	    /* current append position in target string */
d481 2
a482 2
    register I32 arg;
    register SV *sv = NULL; /* current item */
d1240 1
a1240 1
	    register IV i, j;
d1324 1
a1324 1
    register I32 i;
d1329 1
a1329 1
	register const PERL_CONTEXT * const cx = &cxstack[i];
d1400 1
a1400 1
	/* NOTREACHED */
d1441 1
a1441 1
	register const PERL_CONTEXT * const cx = &cxstk[i];
d1445 7
a1452 1
	case CXt_SUB:
d1467 1
a1467 1
	register const PERL_CONTEXT *cx = &cxstack[i];
d1485 1
a1485 1
	register const PERL_CONTEXT * const cx = &cxstack[i];
d1515 1
a1515 1
	register const PERL_CONTEXT *cx = &cxstack[i];
d1543 1
a1543 1
	register const PERL_CONTEXT *cx = &cxstack[i];
d1566 1
a1566 1
        register PERL_CONTEXT *cx = &cxstack[cxstack_ix];
d1666 5
d1681 1
a1681 1
	    register PERL_CONTEXT *cx;
d1729 1
a1729 5
	    if (in_eval & EVAL_KEEPERR) {
		Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "\t(in cleanup) %"SVf,
			       SVfARG(exceptsv));
	    }
	    else {
a1730 1
	    }
d1734 1
a1734 1
	    /* NOTREACHED */
d1740 1
a1740 1
    /* NOTREACHED */
d1774 3
a1776 3
    register I32 cxix = dopoptosub(cxstack_ix);
    register const PERL_CONTEXT *cx;
    register const PERL_CONTEXT *ccstack = cxstack;
d1816 1
a1816 1
    register const PERL_CONTEXT *cx;
d1838 5
a1842 1
    stash_hek = HvNAME_HEK((HV*)CopSTASH(cx->blk_oldcop));
d1871 1
a1871 1
	if (isGV(cvgv)) {
d1894 3
a1896 1
	    PUSHs(cx->blk_eval.cur_text);
a1926 3
    /* XXX only hints propagated via op_private are currently
     * visible (others are not easily accessible, since they
     * use the global PL_hints) */
d1932 1
a1932 2
	if  (old_warnings == pWARN_NONE ||
		(old_warnings == pWARN_STD && (PL_dowarn & G_WARN_ON) == 0))
d1934 2
d1964 7
a1970 3
    const char * const tmps =
	(MAXARG < 1 || (!TOPs && !POPs)) ? (const char *)"" : POPpconstx;
    sv_reset(tmps, CopSTASH(PL_curcop));
d1991 1
a1991 1
	register PERL_CONTEXT *cx;
d1995 1
a1995 1
	register CV * const cv = GvCV(gv);
d1997 4
a2000 1
	if (!cv)
a2016 1
	    CvDEPTH(cv)++;
a2018 1
	    CvDEPTH(cv)--;
d2028 4
d2033 1
a2033 1
	    PAD_SET_CUR_NOSAVE(CvPADLIST(cv), 1);
d2083 1
a2083 1
    register PERL_CONTEXT *cx;
d2097 1
a2097 1
    register PERL_CONTEXT *cx;
d2123 1
a2123 1
    register PERL_CONTEXT *cx;
d2246 1
a2246 1
    register PERL_CONTEXT *cx;
d2262 1
a2262 1
    register PERL_CONTEXT *cx;
d2399 1
a2399 1
    register PERL_CONTEXT *cx;
d2543 1
a2543 1
    register PERL_CONTEXT *cx;
d2565 40
d2607 2
a2608 3
    dVAR; dSP;
    I32 cxix;
    register PERL_CONTEXT *cx;
d2618 1
a2618 18

    if (PL_op->op_flags & OPf_SPECIAL) {
	cxix = dopoptoloop(cxstack_ix);
	if (cxix < 0)
	    DIE(aTHX_ "Can't \"last\" outside a loop block");
    }
    else {
        cxix = dopoptolabel(cPVOP->op_pv, strlen(cPVOP->op_pv),
                           (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0);
	if (cxix < 0)
	    DIE(aTHX_ "Label not found for \"last %"SVf"\"",
                                        SVfARG(newSVpvn_flags(cPVOP->op_pv,
                                                    strlen(cPVOP->op_pv),
                                                    ((cPVOP->op_private & OPpPV_IS_UTF8)
                                                    ? SVf_UTF8 : 0) | SVs_TEMP)));
    }
    if (cxix < cxstack_ix)
	dounwind(cxix);
d2649 1
a2649 1
    SP = adjust_stack_on_leave(newsp, SP, MARK, gimme,
a2650 1
    PUTBACK;
d2678 2
a2679 3
    I32 cxix;
    register PERL_CONTEXT *cx;
    I32 inner;
d2681 1
a2681 17
    if (PL_op->op_flags & OPf_SPECIAL) {
	cxix = dopoptoloop(cxstack_ix);
	if (cxix < 0)
	    DIE(aTHX_ "Can't \"next\" outside a loop block");
    }
    else {
	cxix = dopoptolabel(cPVOP->op_pv, strlen(cPVOP->op_pv),
                           (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0);
 	if (cxix < 0)
	    DIE(aTHX_ "Label not found for \"next %"SVf"\"",
                                        SVfARG(newSVpvn_flags(cPVOP->op_pv, 
                                                    strlen(cPVOP->op_pv),
                                                    ((cPVOP->op_private & OPpPV_IS_UTF8)
                                                    ? SVf_UTF8 : 0) | SVs_TEMP)));
    }
    if (cxix < cxstack_ix)
	dounwind(cxix);
a2684 1
    inner = PL_scopestack_ix;
d2689 1
d2696 2
a2697 2
    I32 cxix;
    register PERL_CONTEXT *cx;
d2699 1
a2699 19
    OP* redo_op;

    if (PL_op->op_flags & OPf_SPECIAL) {
	cxix = dopoptoloop(cxstack_ix);
	if (cxix < 0)
	    DIE(aTHX_ "Can't \"redo\" outside a loop block");
    }
    else {
	cxix = dopoptolabel(cPVOP->op_pv, strlen(cPVOP->op_pv),
                           (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0);
 	if (cxix < 0)
	    DIE(aTHX_ "Label not found for \"redo %"SVf"\"",
                                        SVfARG(newSVpvn_flags(cPVOP->op_pv,
                                                    strlen(cPVOP->op_pv),
                                                    ((cPVOP->op_private & OPpPV_IS_UTF8)
                                                    ? SVf_UTF8 : 0) | SVs_TEMP)));
    }
    if (cxix < cxstack_ix)
	dounwind(cxix);
a2700 1
    redo_op = cxstack[cxix].blk_loop.my_op->op_redoop;
d2713 1
d2722 1
a2722 1
    static const char too_deep[] = "Target of goto is too deeply nested";
d2727 1
a2727 1
	Perl_croak(aTHX_ too_deep);
d2736 1
a2736 1
	    Perl_croak(aTHX_ too_deep);
d2787 1
a2787 1
    register PERL_CONTEXT *cx;
d2794 1
a2794 1
    static const char must_have_label[] = "goto must have label";
d2798 1
d2803 1
a2803 1
	    register PERL_CONTEXT *cx;
d2805 1
a2805 2
	    SV** mark;
	    I32 items = 0;
a2806 1
	    bool reified = 0;
d2833 5
a2837 3
	    if (cxix < 0)
		DIE(aTHX_ "Can't goto subroutine outside a subroutine");
	    if (cxix < cxstack_ix)
d2839 1
d2844 1
d2853 2
d2856 1
a2857 1
		/* put @@_ back onto stack */
d2860 3
a2862 9
		items = AvFILLp(av) + 1;
		EXTEND(SP, items+1); /* @@_ could have been extended. */
		Copy(AvARRAY(av), SP + 1, items, SV*);
		SvREFCNT_dec(GvAV(PL_defgv));
		GvAV(PL_defgv) = cx->blk_sub.savearray;
		CLEAR_ARGARRAY(av);
		/* abandon @@_ if it got reified */
		if (AvREAL(av)) {
		    reified = 1;
a2864 1
		    av_extend(av, items-1);
d2868 1
d2870 2
a2871 8
	    else if (CvISXSUB(cv)) {	/* put GvAV(defgv) back onto stack */
		AV* const av = GvAV(PL_defgv);
		items = AvFILLp(av) + 1;
		EXTEND(SP, items+1); /* @@_ could have been extended. */
		Copy(AvARRAY(av), SP + 1, items, SV*);
	    }
	    mark = SP;
	    SP += items;
d2882 1
d2897 14
a2910 3
		SV **newsp PERL_UNUSED_DECL;
		I32 gimme PERL_UNUSED_DECL;
		if (reified) {
d2913 8
a2920 1
			sv_2mortal(SP[-index]);
d2930 1
d2934 1
a2934 6
		AV* const padlist = CvPADLIST(cv);
		if (CxTYPE(cx) == CXt_EVAL) {
		    PL_in_eval = CxOLD_IN_EVAL(cx);
		    PL_eval_root = cx->blk_eval.old_eval_root;
		    cx->cx_type = CXt_SUB;
		}
a2950 4
		    AV *const av = MUTABLE_AV(PAD_SVl(0));

		    cx->blk_sub.savearray = GvAV(PL_defgv);
		    GvAV(PL_defgv) = MUTABLE_AV(SvREFCNT_inc_simple(av));
a2951 1
		    cx->blk_sub.argarray = av;
d2953 15
a2967 26
		    if (items >= AvMAX(av) + 1) {
			SV **ary = AvALLOC(av);
			if (AvARRAY(av) != ary) {
			    AvMAX(av) += AvARRAY(av) - AvALLOC(av);
			    AvARRAY(av) = ary;
			}
			if (items >= AvMAX(av) + 1) {
			    AvMAX(av) = items - 1;
			    Renew(ary,items+1,SV*);
			    AvALLOC(av) = ary;
			    AvARRAY(av) = ary;
			}
		    }
		    ++mark;
		    Copy(mark,AvARRAY(av),items,SV*);
		    AvFILLp(av) = items - 1;
		    assert(!AvREAL(av));
		    if (reified) {
			/* transfer 'ownership' of refcnts to new @@_ */
			AvREAL_on(av);
			AvREIFY_off(av);
		    }
		    while (items--) {
			if (*mark)
			    SvTEMP_off(*mark);
			mark++;
d2970 1
d2982 1
d2987 1
a2987 1
	    label       = SvPV_const(sv, label_len);
a2988 2
	    if (!(do_dump || *label))
		DIE(aTHX_ must_have_label);
d2991 1
a2991 5
    else if (PL_op->op_flags & OPf_SPECIAL) {
	if (! do_dump)
	    DIE(aTHX_ must_have_label);
    }
    else {
d2996 1
d3000 1
a3000 1
    if (label && *label) {
d3138 1
d3249 1
a3249 1
	/* NOTREACHED */
a3255 136
/* James Bond: Do you expect me to talk?
   Auric Goldfinger: No, Mr. Bond. I expect you to die.

   This code is an ugly hack, doesn't work with lexicals in subroutines that are
   called more than once, and is only used by regcomp.c, for (?{}) blocks.

   Currently it is not used outside the core code. Best if it stays that way.

   Hence it's now deprecated, and will be removed.
*/
OP *
Perl_sv_compile_2op(pTHX_ SV *sv, OP** startop, const char *code, PAD** padp)
/* sv Text to convert to OP tree. */
/* startop op_free() this to undo. */
/* code Short string id of the caller. */
{
    PERL_ARGS_ASSERT_SV_COMPILE_2OP;
    return Perl_sv_compile_2op_is_broken(aTHX_ sv, startop, code, padp);
}

/* Don't use this. It will go away without warning once the regexp engine is
   refactored not to use it.  */
OP *
Perl_sv_compile_2op_is_broken(pTHX_ SV *sv, OP **startop, const char *code,
			      PAD **padp)
{
    dVAR; dSP;				/* Make POPBLOCK work. */
    PERL_CONTEXT *cx;
    SV **newsp;
    I32 gimme = G_VOID;
    I32 optype;
    OP dummy;
    char tbuf[TYPE_DIGITS(long) + 12 + 10];
    char *tmpbuf = tbuf;
    char *safestr;
    int runtime;
    CV* runcv = NULL;	/* initialise to avoid compiler warnings */
    STRLEN len;
    bool need_catch;

    PERL_ARGS_ASSERT_SV_COMPILE_2OP_IS_BROKEN;

    ENTER_with_name("eval");
    lex_start(sv, NULL, LEX_START_SAME_FILTER);
    SAVETMPS;
    /* switch to eval mode */

    if (IN_PERL_COMPILETIME) {
	SAVECOPSTASH_FREE(&PL_compiling);
	CopSTASH_set(&PL_compiling, PL_curstash);
    }
    if (PERLDB_NAMEEVAL && CopLINE(PL_curcop)) {
	SV * const sv = sv_newmortal();
	Perl_sv_setpvf(aTHX_ sv, "_<(%.10seval %lu)[%s:%"IVdf"]",
		       code, (unsigned long)++PL_evalseq,
		       CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
	tmpbuf = SvPVX(sv);
	len = SvCUR(sv);
    }
    else
	len = my_snprintf(tmpbuf, sizeof(tbuf), "_<(%.10s_eval %lu)", code,
			  (unsigned long)++PL_evalseq);
    SAVECOPFILE_FREE(&PL_compiling);
    CopFILE_set(&PL_compiling, tmpbuf+2);
    SAVECOPLINE(&PL_compiling);
    CopLINE_set(&PL_compiling, 1);
    /* XXX For C<eval "...">s within BEGIN {} blocks, this ends up
       deleting the eval's FILEGV from the stash before gv_check() runs
       (i.e. before run-time proper). To work around the coredump that
       ensues, we always turn GvMULTI_on for any globals that were
       introduced within evals. See force_ident(). GSAR 96-10-12 */
    safestr = savepvn(tmpbuf, len);
    SAVEDELETE(PL_defstash, safestr, len);
    SAVEHINTS();
#ifdef OP_IN_REGISTER
    PL_opsave = op;
#else
    SAVEVPTR(PL_op);
#endif

    /* we get here either during compilation, or via pp_regcomp at runtime */
    runtime = IN_PERL_RUNTIME;
    if (runtime)
    {
	runcv = find_runcv(NULL);

	/* At run time, we have to fetch the hints from PL_curcop. */
	PL_hints = PL_curcop->cop_hints;
	if (PL_hints & HINT_LOCALIZE_HH) {
	    /* SAVEHINTS created a new HV in PL_hintgv, which we
	       need to GC */
	    SvREFCNT_dec(GvHV(PL_hintgv));
	    GvHV(PL_hintgv) =
	     refcounted_he_chain_2hv(PL_curcop->cop_hints_hash, 0);
	    hv_magic(GvHV(PL_hintgv), NULL, PERL_MAGIC_hints);
	}
	SAVECOMPILEWARNINGS();
	PL_compiling.cop_warnings = DUP_WARNINGS(PL_curcop->cop_warnings);
	cophh_free(CopHINTHASH_get(&PL_compiling));
	/* XXX Does this need to avoid copying a label? */
	PL_compiling.cop_hints_hash
	 = cophh_copy(PL_curcop->cop_hints_hash);
    }

    PL_op = &dummy;
    PL_op->op_type = OP_ENTEREVAL;
    PL_op->op_flags = 0;			/* Avoid uninit warning. */
    PUSHBLOCK(cx, CXt_EVAL|(IN_PERL_COMPILETIME ? 0 : CXp_REAL), SP);
    PUSHEVAL(cx, 0);
    need_catch = CATCH_GET;
    CATCH_SET(TRUE);

    if (runtime)
	(void) doeval(G_SCALAR, startop, runcv, PL_curcop->cop_seq, NULL);
    else
	(void) doeval(G_SCALAR, startop, PL_compcv, PL_cop_seqmax, NULL);
    CATCH_SET(need_catch);
    POPBLOCK(cx,PL_curpm);
    POPEVAL(cx);

    (*startop)->op_type = OP_NULL;
    (*startop)->op_ppaddr = PL_ppaddr[OP_NULL];
    /* XXX DAPM do this properly one year */
    *padp = MUTABLE_AV(SvREFCNT_inc_simple(PL_comppad));
    LEAVE_with_name("eval");
    if (IN_PERL_COMPILETIME)
	CopHINTS_set(&PL_compiling, PL_hints);
#ifdef OP_IN_REGISTER
    op = PL_opsave;
#endif
    PERL_UNUSED_VAR(newsp);
    PERL_UNUSED_VAR(optype);

    return PL_eval_start;
}

d3272 7
d3281 1
d3284 5
a3288 1
	*db_seqp = PL_curcop->cop_seq;
d3293 1
d3295 1
a3295 1
		CV * const cv = cx->blk_sub.cv;
d3301 2
a3302 1
		return cv;
d3305 15
a3319 1
		return cx->blk_eval.cv;
d3322 1
a3322 1
    return PL_main_cv;
d3348 1
a3348 1
	/* NOTREACHED */
d3355 2
a3356 3
/* Compile a require/do, an eval '', or a /(?{...})/.
 * In the last case, startop is non-null, and contains the address of
 * a pointer that should be set to the just-compiled code.
d3358 3
d3362 5
a3366 9
 * PL_eval_start contains the first op of the compiled ocde; otherwise,
 * pushes undef (also croaks if startop != NULL).
 */

/* This function is called from three places, sv_compile_2op, pp_require
 * and pp_entereval.  These can be distinguished as follows:
 *    sv_compile_2op - startop is non-null
 *    pp_require     - startop is null; saveop is not entereval
 *    pp_entereval   - startop is null; saveop is entereval
d3370 1
a3370 1
S_doeval(pTHX_ int gimme, OP** startop, CV* outside, U32 seq, HV *hh)
d3374 1
d3376 1
a3376 1
    bool in_require = (saveop && saveop->op_type == OP_REQUIRE);
d3382 3
a3384 1
		  : EVAL_INEVAL);
d3425 1
a3425 1
    if (!startop) ENTER_with_name("evalcomp");
d3433 1
a3433 1
    if (saveop && (saveop->op_type != OP_REQUIRE) && (saveop->op_flags & OPf_SPECIAL))
d3438 21
a3458 6
    if (!startop) {
	bool clear_hints = saveop->op_type != OP_ENTEREVAL;
	SAVEHINTS();
	if (clear_hints) {
	    PL_hints = 0;
	    hv_clear(GvHV(PL_hintgv));
d3460 22
a3481 33
	else {
	    PL_hints = saveop->op_private & OPpEVAL_COPHH
			 ? oldcurcop->cop_hints : saveop->op_targ;
	    if (hh) {
		/* SAVEHINTS created a new HV in PL_hintgv, which we need to GC */
		SvREFCNT_dec(GvHV(PL_hintgv));
		GvHV(PL_hintgv) = hh;
	    }
	}
	SAVECOMPILEWARNINGS();
	if (clear_hints) {
	    if (PL_dowarn & G_WARN_ALL_ON)
	        PL_compiling.cop_warnings = pWARN_ALL ;
	    else if (PL_dowarn & G_WARN_ALL_OFF)
	        PL_compiling.cop_warnings = pWARN_NONE ;
	    else
	        PL_compiling.cop_warnings = pWARN_STD ;
	}
	else {
	    PL_compiling.cop_warnings =
		DUP_WARNINGS(oldcurcop->cop_warnings);
	    cophh_free(CopHINTHASH_get(&PL_compiling));
	    if (Perl_cop_fetch_label(aTHX_ oldcurcop, NULL, NULL)) {
		/* The label, if present, is the first entry on the chain. So rather
		   than writing a blank label in front of it (which involves an
		   allocation), just use the next entry in the chain.  */
		PL_compiling.cop_hints_hash
		    = cophh_copy(oldcurcop->cop_hints_hash->refcounted_he_next);
		/* Check the assumption that this removed the label.  */
		assert(Perl_cop_fetch_label(aTHX_ &PL_compiling, NULL, NULL) == NULL);
	    }
	    else
		PL_compiling.cop_hints_hash = cophh_copy(oldcurcop->cop_hints_hash);
d3483 2
d3499 1
d3515 3
a3517 5
	    if (!startop) {
		POPBLOCK(cx,PL_curpm);
		POPEVAL(cx);
		namesv = cx->blk_eval.old_namesv;
	    }
d3522 1
d3536 2
a3537 12
		       SVfARG(ERRSV
                                ? ERRSV
                                : newSVpvs_flags("Unknown error\n", SVs_TEMP)));
	}
	else if (startop) {
	    if (yystatus != 3) {
		POPBLOCK(cx,PL_curpm);
		POPEVAL(cx);
	    }
	    Perl_croak(aTHX_ "%"SVf"Compilation failed in regexp",
		       SVfARG(ERRSV
                                ? ERRSV
d3541 2
a3542 2
	    if (!*(SvPVx_nolen_const(ERRSV))) {
	        sv_setpvs(ERRSV, "Compilation error");
d3549 3
a3551 1
    else if (!startop) LEAVE_with_name("evalcomp");
d3553 2
a3554 4
    if (startop) {
	*startop = PL_eval_root;
    } else
	SAVEFREEOP(PL_eval_root);
d3559 1
a3559 1
    if (PERLDB_INTER && saveop && saveop->op_type == OP_REQUIRE) {
d3635 1
a3635 1
    register PERL_CONTEXT *cx;
d3643 3
d3658 1
d3663 1
a3663 1
	if (!sv_derived_from(PL_patchlevel, "version"))
d3731 3
a3733 1
    if ((unixname = tounixspec(name, NULL)) != NULL) {
d3758 2
d3767 1
a3767 1
    if (!tryrsfp) {
d3910 2
a3911 2
		    char *unixdir;
		    if ((unixdir = tounixpath(dir, NULL)) == NULL)
d3939 6
a3944 1
			*tmp++ = '/';
d3960 1
a3960 1
			    while (*++tryname == '/');
d3964 8
a3971 3
		    else if (errno == EMFILE)
			/* no point in trying other paths if out of handles */
			break;
d3977 1
d3981 1
a3981 1
	    if(errno == EMFILE) {
d3983 1
a3983 1
		DIE(aTHX_ "Can't locate %s:   %s", name, Strerror(errno));
d3988 1
d3994 19
d4016 2
a4017 8
			"Can't locate %s in @@INC%s%s (@@INC contains:%" SVf ")",
			name,
			(memEQ(name + len - 2, ".h", 3)
			 ? " (change .h to .ph maybe?) (did you run h2ph?)" : ""),
			(memEQ(name + len - 3, ".ph", 4)
			 ? " (did you run h2ph?)" : ""),
			inc
			);
d4023 1
d4073 1
a4073 1
    if (doeval(gimme, NULL, NULL, PL_curcop->cop_seq, NULL))
d4081 2
d4102 1
a4102 1
    register PERL_CONTEXT *cx;
d4203 1
a4203 1
    if (doeval(gimme, NULL, runcv, seq, saved_hh)) {
d4233 1
a4233 1
    register PERL_CONTEXT *cx;
d4287 1
a4287 1
    register PERL_CONTEXT *cx;
d4338 1
a4338 1
    register PERL_CONTEXT *cx;
d4358 1
a4358 1
    register PERL_CONTEXT *cx;
d4364 9
a4372 2
    SAVECLEARSV(PAD_SVl(PL_op->op_targ));
    sv_setsv_mg(PAD_SV(PL_op->op_targ), POPs);
d4383 1
a4383 1
    register PERL_CONTEXT *cx;
d4931 1
a4931 1
    register PERL_CONTEXT *cx;
d4956 1
a4956 1
    register PERL_CONTEXT *cx;
d4990 1
d4993 2
a4994 1
    else
d4996 1
d5003 1
a5003 1
    register PERL_CONTEXT *cx;
d5031 1
a5031 1
    register PERL_CONTEXT *cx;
d5054 4
a5057 4
    register char *s = SvPV(sv, len);
    register char *send;
    register char *base = NULL; /* start of current field */
    register I32 skipspaces = 0; /* number of contiguous spaces seen */
d5062 1
a5062 1
    register U32 *fpc;
d5064 1
a5064 1
    register I32 arg;
d5344 1
d5423 1
a5423 1
	count = call_sv(filter_sub, G_SCALAR);
d5431 5
d5443 2
a5444 1
    if(SvOK(upstream)) {
d5458 1
a5458 1
    if (prune_from) {
d5487 2
a5488 1
    if (upstream != buf_sv && (SvOK(upstream) || SvGMAGICAL(upstream))) {
d5504 4
d5547 1
a5547 1
 * indent-tabs-mode: t
d5550 1
a5550 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.14
log
@merge in perl 5.12.2 plus local changes
@
text
@a36 4
#ifndef WORD_ALIGN
#define WORD_ALIGN sizeof(U32)
#endif

d46 1
d49 6
a54 2
    cxix = dopoptosub(cxstack_ix);
    if (cxix < 0)
d56 2
d59 1
a59 1
    switch (cxstack[cxix].blk_gimme) {
d102 1
d104 1
a104 1
	    SV *sv = AMG_CALLun(rx, regexp);	\
d117 1
a117 1
	/* multiple args; concatentate them */
d123 3
a125 2
	    if (PL_amagic_generation) {
		SV *sv;
d127 6
a132 1
		tryAMAGICregexp(msv);
d134 4
a137 6
		if ((SvAMAGIC(tmpstr) || SvAMAGIC(msv)) &&
		    (sv = amagic_call(tmpstr, msv, concat_amg, AMGf_assign)))
		{
		   sv_setsv(tmpstr, sv);
		   continue;
		}
d139 2
a140 1
	    sv_catsv(tmpstr, msv);
d187 3
a189 2
	STRLEN len;
	const char *t = SvOK(tmpstr) ? SvPV_const(tmpstr, len) : "";
d198 1
a198 1
            U32 pm_flags = pm->op_pmflags & PMf_COMPILETIME;
d207 1
a207 2
	        SV *ptr = Perl_refcounted_he_fetch(aTHX_ PL_curcop->cop_hints_hash, 0,
				       "regcomp", 7, 0, 0);
d215 1
a215 3
	    if (DO_UTF8(tmpstr)) {
		assert (SvUTF8(tmpstr));
	    } else if (SvUTF8(tmpstr)) {
d224 4
d229 1
a229 1
 		if (eng) 
d231 1
a231 1
		else
d243 2
a244 1
	if (PL_tainted)
d246 1
a246 2
	else
	    RX_EXTFLAGS(re) &= ~RXf_TAINTED;
d278 3
d295 6
a300 3
	if (!(cx->sb_rxtainted & 2) && SvTAINTED(TOPs))
	    cx->sb_rxtainted |= 2;
	sv_catsv(dstr, POPs);
d305 7
d319 1
a319 1
	    SV * const targ = cx->sb_targ;
d328 2
a329 1
	    cx->sb_rxtainted |= RX_MATCH_TAINTED(rx);
d331 5
a335 7
#ifdef PERL_OLD_COPY_ON_WRITE
	    if (SvIsCOW(targ)) {
		sv_force_normal_flags(targ, SV_COW_DROP_PV);
	    } else
#endif
	    {
		SvPV_free(targ);
d337 41
a377 15
	    SvPV_set(targ, SvPVX(dstr));
	    SvCUR_set(targ, SvCUR(dstr));
	    SvLEN_set(targ, SvLEN(dstr));
	    if (DO_UTF8(dstr))
		SvUTF8_on(targ);
	    SvPV_set(dstr, NULL);

	    TAINT_IF(cx->sb_rxtainted & 1);
	    mPUSHi(saviters - 1);

	    (void)SvPOK_only_UTF8(targ);
	    TAINT_IF(cx->sb_rxtainted);
	    SvSETMAGIC(targ);
	    SvTAINT(targ);

d381 1
d401 2
a402 1
	SV * const sv = cx->sb_targ;
d417 19
a435 1
    cx->sb_rxtainted |= RX_MATCH_TAINTED(rx);
d437 1
d538 3
d545 4
a548 3
    register U32 *fpc;
    register char *t;
    const char *f;
d550 8
a557 8
    register SV *sv = NULL;
    const char *item = NULL;
    I32 itemsize  = 0;
    I32 fieldsize = 0;
    I32 lines = 0;
    bool chopspace = (strchr(PL_chopset, ' ') != NULL);
    const char *chophere = NULL;
    char *linemark = NULL;
d559 1
a559 1
    bool gotsome = FALSE;
d561 1
a561 2
    const STRLEN fudge = SvPOK(tmpForm)
			? (SvCUR(tmpForm) * (IN_BYTES ? 1 : 3) + 1) : 0;
a563 2
    SV * nsv = NULL;
    OP * parseres = NULL;
d565 12
a577 11
    if (!SvMAGICAL(tmpForm) || !SvCOMPILED(tmpForm)) {
	if (SvREADONLY(tmpForm)) {
	    SvREADONLY_off(tmpForm);
	    parseres = doparseform(tmpForm);
	    SvREADONLY_on(tmpForm);
	}
	else
	    parseres = doparseform(tmpForm);
	if (parseres)
	    return parseres;
    }
d579 2
d583 3
a585 1
    t = SvGROW(PL_formtarget, len + fudge + 1);  /* XXX SvCUR bad */
d587 1
a587 3
    f = SvPV_const(tmpForm, len);
    /* need to jump to the next word */
    fpc = (U32*)(f + len + WORD_ALIGN - SvCUR(tmpForm) % WORD_ALIGN);
d621 1
a621 1
	    linemark = t;
d627 6
a632 19
	    arg = *fpc++;
	    if (targ_is_utf8 && !SvUTF8(tmpForm)) {
		SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
		*t = '\0';
		sv_catpvn_utf8_upgrade(PL_formtarget, f, arg, nsv);
		t = SvEND(PL_formtarget);
		f += arg;
		break;
	    }
	    if (!targ_is_utf8 && DO_UTF8(tmpForm)) {
		SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
		*t = '\0';
		sv_utf8_upgrade_flags_grow(PL_formtarget, SV_GMAGIC, fudge + 1);
		t = SvEND(PL_formtarget);
		targ_is_utf8 = TRUE;
	    }
	    while (arg--)
		*t++ = *f++;
	    break;
d649 2
d803 9
a811 62
	    {
		const char *s = item;
		arg = itemsize;
		if (item_is_utf8) {
		    if (!targ_is_utf8) {
			SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
			*t = '\0';
			sv_utf8_upgrade_flags_grow(PL_formtarget, SV_GMAGIC,
								    fudge + 1);
			t = SvEND(PL_formtarget);
			targ_is_utf8 = TRUE;
		    }
		    while (arg--) {
			if (UTF8_IS_CONTINUED(*s)) {
			    STRLEN skip = UTF8SKIP(s);
			    switch (skip) {
			    default:
				Move(s,t,skip,char);
				s += skip;
				t += skip;
				break;
			    case 7: *t++ = *s++;
			    case 6: *t++ = *s++;
			    case 5: *t++ = *s++;
			    case 4: *t++ = *s++;
			    case 3: *t++ = *s++;
			    case 2: *t++ = *s++;
			    case 1: *t++ = *s++;
			    }
			}
			else {
			    if ( !((*t++ = *s++) & ~31) )
				t[-1] = ' ';
			}
		    }
		    break;
		}
		if (targ_is_utf8 && !item_is_utf8) {
		    SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
		    *t = '\0';
		    sv_catpvn_utf8_upgrade(PL_formtarget, s, arg, nsv);
		    for (; t < SvEND(PL_formtarget); t++) {
#ifdef EBCDIC
			const int ch = *t;
			if (iscntrl(ch))
#else
			    if (!(*t & ~31))
#endif
				*t = ' ';
		    }
		    break;
		}
		while (arg--) {
#ifdef EBCDIC
		    const int ch = *t++ = *s++;
		    if (iscntrl(ch))
#else
			if ( !((*t++ = *s++) & ~31) )
#endif
			    t[-1] = ' ';
		}
		break;
d813 1
d833 2
d836 18
a853 22
		itemsize = len;
		if (itemsize) {
		    STRLEN to_copy = itemsize;
		    const char *const send = s + len;
		    const U8 *source = (const U8 *) s;
		    U8 *tmp = NULL;

		    gotsome = TRUE;
		    chophere = s + itemsize;
		    while (s < send) {
			if (*s++ == '\n') {
			    if (oneline) {
				to_copy = s - SvPVX_const(sv) - 1;
				chophere = s;
				break;
			    } else {
				if (s == send) {
				    itemsize--;
				    to_copy--;
				} else
				    lines++;
			    }
d856 13
a868 17
		    if (targ_is_utf8 && !item_is_utf8) {
			source = tmp = bytes_to_utf8(source, &to_copy);
			SvCUR_set(PL_formtarget,
				  t - SvPVX_const(PL_formtarget));
		    } else {
			if (item_is_utf8 && !targ_is_utf8) {
			    /* Upgrade targ to UTF8, and then we reduce it to
			       a problem we have a simple solution for.  */
			    SvCUR_set(PL_formtarget,
				      t - SvPVX_const(PL_formtarget));
			    targ_is_utf8 = TRUE;
			    /* Don't need get magic.  */
			    sv_utf8_upgrade_nomg(PL_formtarget);
			} else {
			    SvCUR_set(PL_formtarget,
				      t - SvPVX_const(PL_formtarget));
			}
d870 20
a889 2
			/* Easy. They agree.  */
			assert (item_is_utf8 == targ_is_utf8);
d891 31
a921 19
		    SvGROW(PL_formtarget,
			   SvCUR(PL_formtarget) + to_copy + fudge + 1);
		    t = SvPVX(PL_formtarget) + SvCUR(PL_formtarget);

		    Copy(source, t, to_copy, char);
		    t += to_copy;
		    SvCUR_set(PL_formtarget, SvCUR(PL_formtarget) + to_copy);
		    if (item_is_utf8) {
			if (SvGMAGICAL(sv)) {
			    /* Mustn't call sv_pos_b2u() as it does a second
			       mg_get(). Is this a bug? Do we need a _flags()
			       variant? */
			    itemsize = utf8_length(source, source + itemsize);
			} else {
			    sv_pos_b2u(sv, &itemsize);
			}
			assert(!tmp);
		    } else if (tmp) {
			Safefree(tmp);
d924 5
d936 1
a936 1
		((arg & 256) ?
d940 1
a940 1
		((arg & 256) ?
d948 1
a948 1
		((arg & 256) ? "%#*.*" PERL_PRIfldbl : "%*.*" PERL_PRIfldbl);
d951 1
a951 1
		((arg & 256) ? "%#*.*f"              : "%*.*f");
d956 1
a956 1
	    if ((arg & 512) && !SvOK(sv)) {
d974 2
a975 1
		my_snprintf(t, SvLEN(PL_formtarget) - (t - SvPVX(PL_formtarget)), fmt, (int) fieldsize, (int) arg & 255, value);
d983 1
a983 1
	    while (t-- > linemark && *t == ' ') ;
d992 2
a993 8
		    *t = '\0';
		    SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
		    lines += FmLINES(PL_formtarget);
		    if (targ_is_utf8)
			SvUTF8_on(PL_formtarget);
		    FmLINES(PL_formtarget) = lines;
		    SP = ORIGMARK;
		    RETURNOP(cLISTOP->op_first);
d997 1
a997 1
		t = linemark;
d1030 2
d1038 4
a1041 1
	    RETPUSHYES;
d1058 2
a1059 2
    pp_pushmark();				/* push dst */
    pp_pushmark();				/* push src */
d1079 1
a1079 1
	pp_pushmark();			/* push top */
d1135 35
a1169 2
	    while (items-- > 0)
		*dst-- = SvTEMP(TOPs) ? POPs : sv_mortalcopy(POPs);
d1179 1
d1182 3
d1310 2
a1311 2
	    if ((SvOK(left) && SvNV(left) < IV_MIN) ||
		(SvOK(right) && SvNV(right) > IV_MAX))
d1313 2
a1314 2
	    i = SvIV(left);
	    max = SvIV(right);
d1328 3
a1330 3
	    SV * const final = sv_mortalcopy(right);
	    STRLEN len;
	    const char * const tmps = SvPV_const(final, len);
d1332 1
a1332 2
	    SV *sv = sv_mortalcopy(left);
	    SvPV_force_nolen(sv);
d1389 1
a1389 1
S_dopoptolabel(pTHX_ const char *label)
d1404 1
d1415 15
a1429 3
	    const char *cx_label = CxLABEL(cx);
	    if (!cx_label || strNE(label, cx_label) ) {
		DEBUG_l(Perl_deb(aTHX_ "(Skipping label #%ld %s)\n",
d1433 1
a1433 1
	    DEBUG_l( Perl_deb(aTHX_ "(Found label #%ld %s)\n", (long)i, label));
d1486 14
d1516 1
a1516 1
	    DEBUG_l( Perl_deb(aTHX_ "(Found sub #%ld)\n", (long)i));
d1534 1
a1534 1
	    DEBUG_l( Perl_deb(aTHX_ "(Found eval #%ld)\n", (long)i));
d1554 1
d1564 1
a1564 1
	    DEBUG_l( Perl_deb(aTHX_ "(Found loop #%ld)\n", (long)i));
d1582 1
a1582 1
	    DEBUG_l( Perl_deb(aTHX_ "(Found given #%ld)\n", (long)i));
d1591 1
a1591 1
		DEBUG_l( Perl_deb(aTHX_ "(Found foreach #%ld)\n", (long)i));
d1610 1
a1610 1
	    DEBUG_l( Perl_deb(aTHX_ "(Found when #%ld)\n", (long)i));
d1623 3
d1629 1
a1629 2
	DEBUG_l(PerlIO_printf(Perl_debug_log, "Unwinding block %ld, type %s\n",
			      (long) cxstack_ix, PL_block_type[CxTYPE(cx)]));
d1666 8
a1673 2
    if (PL_in_eval)
	sv_catsv(ERRSV, err);
d1683 1
a1683 1
Perl_die_where(pTHX_ SV *msv)
d1686 3
d1690 1
a1690 1
    if (PL_in_eval) {
d1694 32
a1725 32
	if (msv) {
	    if (PL_in_eval & EVAL_KEEPERR) {
                static const char prefix[] = "\t(in cleanup) ";
		SV * const err = ERRSV;
		const char *e = NULL;
		if (!SvPOK(err))
		    sv_setpvs(err,"");
		else if (SvCUR(err) >= sizeof(prefix)+SvCUR(msv)-1) {
		    STRLEN len;
		    STRLEN msglen;
		    const char* message = SvPV_const(msv, msglen);
		    e = SvPV_const(err, len);
		    e += len - msglen;
		    if (*e != *message || strNE(e,message))
			e = NULL;
		}
		if (!e) {
		    STRLEN start;
		    SvGROW(err, SvCUR(err)+sizeof(prefix)+SvCUR(msv));
		    sv_catpvn(err, prefix, sizeof(prefix)-1);
		    sv_catsv(err, msv);
		    start = SvCUR(err)-SvCUR(msv)-sizeof(prefix)+1;
		    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "%s",
				   SvPVX_const(err)+start);
		}
	    }
	    else {
		STRLEN msglen;
		const char* message = SvPV_const(msv, msglen);
		sv_setpvn(ERRSV, message, msglen);
		SvFLAGS(ERRSV) |= SvFLAGS(msv) & SVf_UTF8;
	    }
d1740 3
d1750 1
a1750 1
		const char* message = SvPVx_const( msv ? msv : ERRSV, msglen);
d1757 3
d1771 1
a1771 1
	    PL_curcop = cx->blk_oldcop;
a1773 1
                const char* const msg = SvPVx_nolen_const(ERRSV);
d1775 2
a1776 1
                               SvPVX_const(namesv), SvCUR(namesv),
d1778 11
a1788 2
		DIE(aTHX_ "%sCompilation failed in require",
		    *msg ? msg : "Unknown error\n");
d1790 5
a1794 2
	    assert(CxTYPE(cx) == CXt_EVAL);
	    PL_restartop = cx->blk_eval.retop;
d1800 1
a1800 1
    write_to_stderr( msv ? msv : ERRSV );
d1814 21
a1834 1
PP(pp_caller)
a1835 2
    dVAR;
    dSP;
a1839 6
    I32 gimme;
    const char *stashname;
    I32 count = 0;

    if (MAXARG)
	count = POPi;
d1848 2
a1849 7
	if (cxix < 0) {
	    if (GIMME != G_ARRAY) {
		EXTEND(SP, 1);
		RETPUSHUNDEF;
            }
	    RETURN;
	}
d1860 2
d1871 30
a1900 1
    stashname = CopSTASHPV(cx->blk_oldcop);
d1903 1
a1903 1
	if (!stashname)
d1907 1
a1907 1
	    sv_setpv(TARG, stashname);
d1915 1
a1915 1
    if (!stashname)
d1917 5
a1921 2
    else
	mPUSHs(newSVpv(stashname, 0));
d1924 1
a1924 1
    if (!MAXARG)
d1927 1
a1927 1
	GV * const cvgv = CvGV(ccstack[cxix].blk_sub.cv);
d1976 1
a1976 2
	if (!PL_dbargs)
	    Perl_init_dbargs(aTHX);
d2013 1
a2013 3
	  sv_2mortal(newRV_noinc(
				 MUTABLE_SV(Perl_refcounted_he_chain_2hv(aTHX_
					      cx->blk_oldcop->cop_hints_hash))))
d2022 2
a2023 1
    const char * const tmps = (MAXARG < 1) ? (const char *)"" : POPpconstx;
d2039 2
d2090 79
d2174 1
a2174 1
    SV **svp;
a2175 3
#ifdef USE_ITHREADS
    PAD *iterdata;
#endif
d2180 2
a2181 2
    if (PL_op->op_targ) {
	if (PL_op->op_private & OPpLVAL_INTRO) { /* for my $x (...) */
d2187 2
a2188 2
#ifndef USE_ITHREADS
	svp = &PAD_SVl(PL_op->op_targ);		/* "my" variable */
d2190 1
a2190 1
	iterdata = NULL;
d2193 1
a2193 1
    else {
d2195 2
a2196 2
	svp = &GvSV(gv);			/* symbol table variable */
	SAVEGENERICSV(*svp);
d2198 1
a2198 3
#ifdef USE_ITHREADS
	iterdata = (PAD*)gv;
#endif
d2207 1
a2207 5
#ifdef USE_ITHREADS
    PUSHLOOP_FOR(cx, iterdata, MARK, PL_op->op_targ);
#else
    PUSHLOOP_FOR(cx, svp, MARK, 0);
#endif
d2222 2
a2223 2
		if ((SvOK(sv) && ((SvNV(sv) < (NV)IV_MIN) ||
				  (SvNV(sv) > (NV)IV_MAX)))
d2225 2
a2226 2
		    (SvOK(right) && ((SvNV(right) > (NV)IV_MAX) ||
				     (SvNV(right) < (NV)IV_MIN))))
d2228 1
a2228 1
		if ((SvOK(sv) && ((SvNV(sv) <= (NV)IV_MIN)
d2230 3
a2232 3
		                  ((SvNV(sv) > 0) &&
					((SvUV(sv) > (UV)IV_MAX) ||
					 (SvNV(sv) > (NV)UV_MAX)))))
d2234 1
a2234 1
		    (SvOK(right) && ((SvNV(right) <= (NV)IV_MIN)
d2236 4
a2239 3
				     ((SvNV(right) > 0) &&
					((SvUV(right) > (UV)IV_MAX) ||
					 (SvNV(right) > (NV)UV_MAX))))))
d2242 2
a2243 2
		cx->blk_loop.state_u.lazyiv.cur = SvIV(sv);
		cx->blk_loop.state_u.lazyiv.end = SvIV(right);
d2323 1
a2323 15
    if (gimme == G_VOID)
	NOOP;
    else if (gimme == G_SCALAR) {
	if (mark < SP)
	    *++newsp = sv_mortalcopy(*SP);
	else
	    *++newsp = &PL_sv_undef;
    }
    else {
	while (mark < SP) {
	    *++newsp = sv_mortalcopy(*++mark);
	    TAINT_NOT;		/* Each item is independent */
	}
    }
    SP = newsp;
d2335 110
d2451 1
d2492 1
a2503 1
	lex_end();
d2509 2
a2510 1
			    SvPVX_const(namesv), SvCUR(namesv),
d2520 1
a2520 1
	DIE(aTHX_ "panic: return");
d2524 3
a2526 1
    if (gimme == G_SCALAR) {
d2530 2
a2531 1
		    if (SvTEMP(TOPs)) {
d2543 4
d2548 1
a2548 1
		    *++newsp = (SvTEMP(*SP)) ? *SP : sv_mortalcopy(*SP);
d2555 2
a2556 2
    }
    else if (gimme == G_ARRAY) {
d2558 2
a2559 1
	    *++newsp = (popsub2 && SvTEMP(*MARK))
d2563 2
a2565 1
    PL_stack_sp = newsp;
d2584 30
d2635 2
a2636 1
	cxix = dopoptolabel(cPVOP->op_pv);
d2638 5
a2642 1
	    DIE(aTHX_ "Label not found for \"last %s\"", cPVOP->op_pv);
d2672 1
a2672 1
	DIE(aTHX_ "panic: last");
d2676 2
a2677 15
    if (gimme == G_SCALAR) {
	if (MARK < SP)
	    *++newsp = ((pop2 == CXt_SUB) && SvTEMP(*SP))
			? *SP : sv_mortalcopy(*SP);
	else
	    *++newsp = &PL_sv_undef;
    }
    else if (gimme == G_ARRAY) {
	while (++MARK <= SP) {
	    *++newsp = ((pop2 == CXt_SUB) && SvTEMP(*MARK))
			? *MARK : sv_mortalcopy(*MARK);
	    TAINT_NOT;		/* Each item is independent */
	}
    }
    SP = newsp;
d2716 8
a2723 3
	cxix = dopoptolabel(cPVOP->op_pv);
	if (cxix < 0)
	    DIE(aTHX_ "Label not found for \"next %s\"", cPVOP->op_pv);
d2735 1
a2735 1
    return CX_LOOP_NEXTOP_GET(cx);
d2752 8
a2759 3
	cxix = dopoptolabel(cPVOP->op_pv);
	if (cxix < 0)
	    DIE(aTHX_ "Label not found for \"redo %s\"", cPVOP->op_pv);
d2781 1
a2781 1
S_dofindlabel(pTHX_ OP *o, const char *label, OP **opstack, OP **oplimit)
d2807 15
a2821 2
		const char *kid_label = CopLABEL(kCOP);
		if (kid_label && strEQ(kid_label, label))
d2837 1
a2837 1
	    if ((o = dofindlabel(kid, label, ops, oplimit)))
d2854 2
d2881 3
a2883 2
		    autogv = gv_autoload4(GvSTASH(gv), GvNAME(gv),
					  GvNAMELEN(gv), FALSE);
d2906 1
d2909 1
d2948 13
d2966 2
a2967 2
		SV **newsp;
		I32 gimme;
d3001 1
d3056 2
a3057 1
	    label = SvPV_nolen_const(sv);
d3066 7
a3072 2
    else
	label = cPVOP->op_pv;
d3125 2
a3126 1
		    DIE(aTHX_ "panic: goto");
d3131 1
a3131 1
		retop = dofindlabel(gotoprobe, label,
d3135 9
d3148 3
a3150 1
	    DIE(aTHX_ "Can't find label %s", label);
d3193 1
a3193 1
		CALL_FPTR(PL_op->op_ppaddr)(aTHX);
d3223 3
d3311 2
a3312 11

	/* NB XXX we rely on the old popped CxEVAL still being at the top
	 * of the stack; the way die_where() currently works, this
	 * assumption is valid. In theory The cur_top_env value should be
	 * returned in another global, the way retop (aka PL_restartop)
	 * is. */
	assert(CxTYPE(&cxstack[cxstack_ix+1]) == CXt_EVAL);

	if (PL_restartop
	    && cxstack[cxstack_ix+1].blk_eval.cur_top_env == PL_top_env)
	{
d3336 2
d3345 10
d3367 1
d3369 1
a3369 1
    PERL_ARGS_ASSERT_SV_COMPILE_2OP;
d3372 1
a3372 1
    lex_start(sv, NULL, FALSE);
d3412 1
d3415 18
d3438 2
d3442 1
a3442 1
	(void) doeval(G_SCALAR, startop, runcv, PL_curcop->cop_seq);
d3444 2
a3445 1
	(void) doeval(G_SCALAR, startop, PL_compcv, PL_cop_seqmax);
a3450 1
    lex_end();
d3500 1
a3500 1
		return PL_compcv;
d3507 29
d3545 7
d3553 1
a3553 1
S_doeval(pTHX_ int gimme, OP** startop, CV* outside, U32 seq)
d3557 4
d3562 1
a3562 1
    PL_in_eval = ((saveop && saveop->op_type == OP_REQUIRE)
d3568 2
a3569 3
    SAVESPTR(PL_compcv);
    PL_compcv = MUTABLE_CV(newSV_type(SVt_PVCV));
    CvEVAL_on(PL_compcv);
d3571 2
a3572 1
    cxstack[cxstack_ix].blk_eval.cv = PL_compcv;
d3574 2
a3575 2
    CvOUTSIDE_SEQ(PL_compcv) = seq;
    CvOUTSIDE(PL_compcv) = MUTABLE_CV(SvREFCNT_inc_simple(outside));
d3579 1
a3579 1
    CvPADLIST(PL_compcv) = pad_new(padnew_SAVE);
d3584 1
a3584 1
	SAVEMORTALIZESV(PL_compcv);	/* must remain until end of current statement */
d3589 2
a3590 2
	SAVESPTR(PL_curstash);
	PL_curstash = CopSTASH(PL_curcop);
d3605 4
a3612 1
    CopARYBASE_set(PL_curcop, 0);
d3617 52
a3668 1
    if (yyparse() || PL_parser->error_count || !PL_eval_root) {
d3670 8
a3677 4
	PERL_CONTEXT *cx = NULL;
	I32 optype = 0;			/* Might be reset by POPEVAL. */
	SV *namesv = NULL;
	const char *msg;
d3679 2
d3682 13
a3694 9
	if (PL_eval_root) {
	    op_free(PL_eval_root);
	    PL_eval_root = NULL;
	}
	SP = PL_stack_base + POPMARK;		/* pop original mark */
	if (!startop) {
	    POPBLOCK(cx,PL_curpm);
	    POPEVAL(cx);
	    namesv = cx->blk_eval.old_namesv;
a3695 2
	lex_end();
	LEAVE_with_name("eval"); /* pp_entereval knows about this LEAVE.  */
d3697 1
a3697 2
	msg = SvPVx_nolen_const(ERRSV);
	if (optype == OP_REQUIRE) {
d3706 2
a3707 1
			   SvPVX_const(namesv), SvCUR(namesv),
d3709 4
a3712 2
	    Perl_croak(aTHX_ "%sCompilation failed in require",
		       *msg ? msg : "Unknown error\n");
d3715 8
a3722 4
	    POPBLOCK(cx,PL_curpm);
	    POPEVAL(cx);
	    Perl_croak(aTHX_ "%sCompilation failed in regexp",
		       (*msg ? msg : "Unknown error\n"));
d3725 1
a3725 1
	    if (!*msg) {
d3729 1
a3729 2
	PERL_UNUSED_VAR(newsp);
	PUSHs(&PL_sv_undef);
d3733 1
a3739 9
    /* Set the context for this new optree.
     * Propagate the context from the eval(). */
    if ((gimme & G_WANT) == G_VOID)
	scalarvoid(PL_eval_root);
    else if ((gimme & G_WANT) == G_ARRAY)
	list(PL_eval_root);
    else
	scalar(PL_eval_root);

d3754 2
a3755 1
    if (PL_unitcheckav)
d3757 2
d3762 1
a3762 1
    CvDEPTH(PL_compcv) = 1;
d3772 1
a3772 1
S_check_type_and_open(pTHX_ const char *name)
d3775 2
a3776 1
    const int st_rc = PerlLIO_stat(name, &st);
d3784 5
a3788 1
    return PerlIO_open(name, PERL_SCRIPT_MODE);
d3793 1
a3793 1
S_doopen_pm(pTHX_ const char *name, const STRLEN namelen)
d3795 2
a3796 1
    PerlIO *fp;
d3800 2
a3801 3
    if (namelen > 3 && memEQs(name + namelen - 3, 3, ".pm")) {
	SV *const pmcsv = newSV(namelen + 2);
	char *const pmc = SvPVX(pmcsv);
d3804 2
a3805 3
	memcpy(pmc, name, namelen);
	pmc[namelen] = 'c';
	pmc[namelen + 1] = '\0';
d3807 2
a3808 7
	if (PerlLIO_stat(pmc, &pmcstat) < 0) {
	    fp = check_type_and_open(name);
	}
	else {
	    fp = check_type_and_open(pmc);
	}
	SvREFCNT_dec(pmcsv);
d3810 1
a3810 4
    else {
	fp = check_type_and_open(name);
    }
    return fp;
d3813 1
a3813 1
#  define doopen_pm(name, namelen) check_type_and_open(name)
d3842 1
a3842 1
	sv = new_version(sv);
d3848 3
a3850 1
		    SVfARG(vnormal(sv)), SVfARG(vnormal(PL_patchlevel)));
d3869 4
a3872 2
		    	"%"SVf", stopped", SVfARG(vnormal(req)),
			SVfARG(vnormal(PL_patchlevel)));
d3888 4
a3891 3
			SVfARG(vnormal(req)),
			SVfARG(vnormal(sv_2mortal(hintsv))),
			SVfARG(vnormal(PL_patchlevel)));
a3895 17
	/* We do this only with "use", not "require" or "no". */
	if (PL_compcv && !(cUNOP->op_first->op_private & OPpCONST_NOVER)) {
	    /* If we request a version >= 5.9.5, load feature.pm with the
	     * feature bundle that corresponds to the required version. */
	    if (vcmp(sv, sv_2mortal(upg_version(newSVnv(5.009005), FALSE))) >= 0) {
		SV *const importsv = vnormal(sv);
		*SvPVX_mutable(importsv) = ':';
		ENTER_with_name("load_feature");
		Perl_load_module(aTHX_ 0, newSVpvs("feature"), NULL, importsv, NULL);
		LEAVE_with_name("load_feature");
	    }
	    /* If a version >= 5.11.0 is requested, strictures are on by default! */
	    if (vcmp(sv, sv_2mortal(upg_version(newSVnv(5.011000), FALSE))) >= 0) {
		PL_hints |= (HINT_STRICT_REFS | HINT_STRICT_SUBS | HINT_STRICT_VARS);
	    }
	}

d3939 1
d3941 1
a3941 1
	tryrsfp = doopen_pm(name, len);
d4121 1
a4121 3

			/* Don't even actually have to turn SvPOK_on() as we
			   access it directly with SvPVX() below.  */
d4127 1
a4127 1
		    tryrsfp = doopen_pm(tryname, SvCUR(namesv));
d4143 1
a4143 3
    SAVECOPFILE_FREE(&PL_compiling);
    CopFILE_set(&PL_compiling, tryrsfp ? tryname : name);
    SvREFCNT_dec(namesv);
a4145 1
	    const char *msgstr = name;
d4147 2
a4148 4
		SV * const msg
		    = sv_2mortal(Perl_newSVpvf(aTHX_ "%s:   %s", msgstr,
					       Strerror(errno)));
		msgstr = SvPV_nolen_const(msg);
d4153 1
a4153 9
		    SV * const msg = sv_2mortal(Perl_newSVpvf(aTHX_ 
			"%s in @@INC%s%s (@@INC contains:",
			msgstr,
			(instr(msgstr, ".h ")
			 ? " (change .h to .ph maybe?)" : ""),
			(instr(msgstr, ".ph ")
			 ? " (did you run h2ph?)" : "")
							      ));
		    
d4155 2
a4156 2
			sv_catpvs(msg, " ");
			sv_catsv(msg, *av_fetch(ar, i, TRUE));
d4158 12
a4169 3
		    sv_catpvs(msg, ")");
		    msgstr = SvPV_nolen_const(msg);
		}    
d4171 1
a4171 1
	    DIE(aTHX_ "Can't locate %s", msgstr);
d4184 1
a4184 1
		       unixname, unixlen, newSVpv(CopFILE(&PL_compiling),0),0);
d4194 3
a4196 13
    lex_start(NULL, tryrsfp, TRUE);

    SAVEHINTS();
    PL_hints = 0;
    hv_clear(GvHV(PL_hintgv));

    SAVECOMPILEWARNINGS();
    if (PL_dowarn & G_WARN_ALL_ON)
        PL_compiling.cop_warnings = pWARN_ALL ;
    else if (PL_dowarn & G_WARN_ALL_OFF)
        PL_compiling.cop_warnings = pWARN_NONE ;
    else
        PL_compiling.cop_warnings = pWARN_STD ;
d4223 1
a4223 1
    if (doeval(gimme, NULL, NULL, PL_curcop->cop_seq))
d4242 1
a4242 1
    mXPUSHs(MUTABLE_SV(Perl_hv_copy_hints_hv(aTHX_ MUTABLE_HV(cSVOP_sv))));
d4255 1
d4259 1
a4259 1
    U32 seq;
d4261 1
d4266 7
d4274 21
d4300 5
a4304 1
    lex_start(sv, NULL, FALSE);
a4322 34
    /* XXX For C<eval "...">s within BEGIN {} blocks, this ends up
       deleting the eval's FILEGV from the stash before gv_check() runs
       (i.e. before run-time proper). To work around the coredump that
       ensues, we always turn GvMULTI_on for any globals that were
       introduced within evals. See force_ident(). GSAR 96-10-12 */
    SAVEHINTS();
    PL_hints = PL_op->op_targ;
    if (saved_hh) {
	/* SAVEHINTS created a new HV in PL_hintgv, which we need to GC */
	SvREFCNT_dec(GvHV(PL_hintgv));
	GvHV(PL_hintgv) = saved_hh;
    }
    SAVECOMPILEWARNINGS();
    PL_compiling.cop_warnings = DUP_WARNINGS(PL_curcop->cop_warnings);
    if (PL_compiling.cop_hints_hash) {
	Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
    }
    if (Perl_fetch_cop_label(aTHX_ PL_curcop->cop_hints_hash, NULL, NULL)) {
	/* The label, if present, is the first entry on the chain. So rather
	   than writing a blank label in front of it (which involves an
	   allocation), just use the next entry in the chain.  */
	PL_compiling.cop_hints_hash
	    = PL_curcop->cop_hints_hash->refcounted_he_next;
	/* Check the assumption that this removed the label.  */
	assert(Perl_fetch_cop_label(aTHX_ PL_compiling.cop_hints_hash, NULL,
				    NULL) == NULL);
    }
    else
	PL_compiling.cop_hints_hash = PL_curcop->cop_hints_hash;
    if (PL_compiling.cop_hints_hash) {
	HINTS_REFCNT_LOCK;
	PL_compiling.cop_hints_hash->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
    }
d4338 11
d4351 1
a4351 1
    if (doeval(gimme, NULL, runcv, seq)) {
d4356 1
a4356 1
	} else {
d4362 1
a4362 1
	/* We have already left the scope set up earler thanks to the LEAVE
d4368 1
a4368 1
	} else {
a4377 1
    register SV **mark;
d4386 1
d4388 1
d4393 1
d4396 2
a4397 25
    if (gimme == G_VOID)
	MARK = newsp;
    else if (gimme == G_SCALAR) {
	MARK = newsp + 1;
	if (MARK <= SP) {
	    if (SvFLAGS(TOPs) & SVs_TEMP)
		*MARK = TOPs;
	    else
		*MARK = sv_mortalcopy(TOPs);
	}
	else {
	    MEXTEND(mark,0);
	    *MARK = &PL_sv_undef;
	}
	SP = MARK;
    }
    else {
	/* in case LEAVE wipes old return values */
	for (mark = newsp + 1; mark <= SP; mark++) {
	    if (!(SvFLAGS(*mark) & SVs_TEMP)) {
		*mark = sv_mortalcopy(*mark);
		TAINT_NOT;	/* Each item is independent */
	    }
	}
    }
d4401 1
a4401 1
    assert(CvDEPTH(PL_compcv) == 1);
d4403 1
a4403 2
    CvDEPTH(PL_compcv) = 0;
    lex_end();
d4410 2
a4411 1
			SvPVX_const(namesv), SvCUR(namesv),
d4414 2
a4415 2
			 SVfARG(namesv));
	/* die_where() did LEAVE, or we won't be here */
d4489 1
d4495 1
a4495 27
    if (gimme == G_VOID)
	SP = newsp;
    else if (gimme == G_SCALAR) {
	register SV **mark;
	MARK = newsp + 1;
	if (MARK <= SP) {
	    if (SvFLAGS(TOPs) & (SVs_PADTMP|SVs_TEMP))
		*MARK = TOPs;
	    else
		*MARK = sv_mortalcopy(TOPs);
	}
	else {
	    MEXTEND(mark,0);
	    *MARK = &PL_sv_undef;
	}
	SP = MARK;
    }
    else {
	/* in case LEAVE wipes old return values */
	register SV **mark;
	for (mark = newsp + 1; mark <= SP; mark++) {
	    if (!(SvFLAGS(*mark) & (SVs_PADTMP|SVs_TEMP))) {
		*mark = sv_mortalcopy(*mark);
		TAINT_NOT;	/* Each item is independent */
	    }
	}
    }
d4512 2
a4513 1
    sv_setsv(PAD_SV(PL_op->op_targ), POPs);
d4533 3
a4535 4
    SP = newsp;
    PUTBACK;

    PL_curpm = newpm;   /* pop $1 et al */
d4538 1
a4538 2

    return NORMAL;
d4569 1
a4569 1
    (void) pp_match();
d4590 1
a4590 1
    return do_smartmatch(NULL, NULL);
d4597 1
a4597 1
S_do_smartmatch(pTHX_ HV *seen_this, HV *seen_other)
d4606 13
d4625 1
a4625 1
	tmpsv = amagic_call(d, e, smart_amg, 0);
a4636 12
    /* Take care only to invoke mg_get() once for each argument. 
     * Currently we do this by copying the SV if it's magical. */
    if (d) {
	if (SvGMAGICAL(d))
	    d = sv_mortalcopy(d);
    }
    else
	d = &PL_sv_undef;

    assert(e);
    if (SvGMAGICAL(e))
	e = sv_mortalcopy(e);
d4920 1
a4920 1
			(void) do_smartmatch(seen_this, seen_other);
d4982 1
a4982 1
		    (void) do_smartmatch(NULL, NULL);
d5052 1
a5052 1
	    (void) pp_i_eq();
d5054 1
a5054 1
	    (void) pp_eq();
d5066 1
a5066 1
    return pp_seq();
d5079 1
d5082 1
a5082 1
	return cLOGOP->op_other->op_next;
d5084 1
a5084 1
    ENTER_with_name("eval");
d5096 1
d5102 6
d5111 10
a5120 2
    SP = newsp;
    PUTBACK;
d5122 8
a5129 1
    PL_curpm = newpm;   /* pop $1 et al */
d5131 4
a5134 2
    LEAVE_with_name("eval");
    return NORMAL;
d5139 1
a5139 1
    dVAR;   
d5142 5
a5146 1
    I32 inner;
d5151 1
d5155 8
a5162 7
    /* clear off anything above the scope we're re-entering */
    inner = PL_scopestack_ix;
    TOPBLOCK(cx);
    if (PL_scopestack_ix < inner)
        leave_scope(PL_scopestack[PL_scopestack_ix]);
    PL_curcop = cx->blk_oldcop;
    return cx->blk_givwhen.leave_op;
d5170 1
a5170 2
    I32 inner;
    
d5172 5
a5176 7
    if (cxix < 0) {
	if (PL_op->op_flags & OPf_SPECIAL)
	    DIE(aTHX_ "Can't use when() outside a topicalizer");
	else
	    DIE(aTHX_ "Can't \"break\" outside a given block");
    }
    if (CxFOREACH(&cxstack[cxix]) && (0 == (PL_op->op_flags & OPf_SPECIAL)))
d5181 2
a5182 3
    
    /* clear off anything above the scope we're re-entering */
    inner = PL_scopestack_ix;
a5183 3
    if (PL_scopestack_ix < inner)
        leave_scope(PL_scopestack[PL_scopestack_ix]);
    PL_curcop = cx->blk_oldcop;
d5185 1
a5185 4
    if (CxFOREACH(cx))
	return CX_LOOP_NEXTOP_GET(cx);
    else
	return cx->blk_givwhen.leave_op;
d5188 1
a5188 1
STATIC OP *
d5192 7
a5198 7
    register char *s = SvPV_force(sv, len);
    register char * const send = s + len;
    register char *base = NULL;
    register I32 skipspaces = 0;
    bool noblank   = FALSE;
    bool repeat    = FALSE;
    bool postspace = FALSE;
d5201 1
a5201 1
    U32 *linepc = NULL;
d5203 2
a5204 2
    bool ischop;
    bool unchopnum = FALSE;
d5206 2
d5214 34
d5275 2
a5276 1
		*s = ' ';
a5278 1
	    s[-1] = ' ';
d5296 1
a5296 1
		*fpc++ = (U16)arg;
d5303 1
a5303 1
		*fpc++ = (U16)skipspaces;
d5314 1
a5314 1
		*fpc++ = (U16)arg;
d5337 1
a5337 1
		*fpc++ = (U16)arg;
d5342 1
a5342 1
	    if (*s == '*') {
d5351 2
a5352 2
	    else if (*s == '#' || (*s == '.' && s[1] == '#')) {
		arg = ischop ? 512 : 0;
d5360 1
a5360 1
		    arg |= 256 + (s - f);
d5364 1
a5364 1
                *fpc++ = (U16)arg;
d5368 1
a5368 1
                arg = ischop ? 512 : 0;
d5377 1
a5377 1
                    arg |= 256 + (s - f);
d5381 1
a5381 1
		*fpc++ = (U16)arg;
d5384 1
a5384 1
	    else {
d5411 1
a5411 1
		    *fpc++ = (U16)prespace;
d5427 5
a5431 10
    { /* need to jump to the next word */
        int z;
	z = WORD_ALIGN - SvCUR(sv) % WORD_ALIGN;
	SvGROW(sv, SvCUR(sv) + z + arg * sizeof(U32) + 4);
	s = SvPVX(sv) + SvCUR(sv) + z;
    }
    Copy(fops, s, arg, U32);
    Safefree(fops);
    sv_magic(sv, NULL, PERL_MAGIC_fm, NULL, 0);
    SvCOMPILED_on(sv);
d5434 3
a5436 2
        DIE(aTHX_ "Repeated format line will never terminate (~~ and @@#)");
    return 0;
d5449 1
a5449 1
    if (frcsize & 256)
d5451 1
a5451 1
    frcsize &= 255;
d5518 1
a5518 1
		/* Definately not EOF  */
@


1.13
log
@Merge in perl 5.10.1
@
text
@d82 1
a82 2
    MAGIC *mg = NULL;
    REGEXP * re;
d96 16
d118 1
d121 5
a125 2
		if ((SvAMAGIC(tmpstr) || SvAMAGIC(*MARK)) &&
		    (sv = amagic_call(tmpstr, *MARK, concat_amg, AMGf_assign)))
d131 1
a131 1
	    sv_catsv(tmpstr, *MARK);
d136 1
a136 1
    else
d138 4
d145 2
a146 2
	if(SvMAGICAL(sv))
	    mg = mg_find(sv, PERL_MAGIC_qr);
d148 26
a173 2
    if (mg) {
	regexp * const re = reg_temp_copy((regexp *)mg->mg_obj);
d181 1
d184 1
a184 1
	if (!re || !RX_PRECOMP(re) || RX_PRELEN(re) != (I32)len ||
d191 3
d195 1
d206 11
a216 2
	    if (DO_UTF8(tmpstr))
		pm_flags |= RXf_UTF8;
d284 2
d288 6
a293 5
	if (CxONCE(cx) || !CALLREGEXEC(rx, s, cx->sb_strend, orig,
				     s == m, cx->sb_targ, NULL,
				     ((cx->sb_rflags & REXEC_COPY_STR)
				      ? (REXEC_IGNOREPOS|REXEC_NOT_FIRST)
				      : (REXEC_COPY_STR|REXEC_IGNOREPOS|REXEC_NOT_FIRST))))
d397 2
a398 2
    *p++ = PTR2UV(rx->saved_copy);
    rx->saved_copy = NULL;
d411 2
a412 2
void
Perl_rxres_restore(pTHX_ void **rsp, REGEXP *rx)
d425 3
a427 3
    if (rx->saved_copy)
	SvREFCNT_dec (rx->saved_copy);
    rx->saved_copy = INT2PTR(SV*,*p);
d441 2
a442 2
void
Perl_rxres_free(pTHX_ void **rsp)
d565 1
a565 2
		sv_utf8_upgrade(PL_formtarget);
		SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
d586 1
a586 2
		if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Not enough format arguments");
d747 2
a748 2
			sv_utf8_upgrade(PL_formtarget);
			SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
d859 1
a859 1
			    sv_utf8_upgrade_flags(PL_formtarget, 0);
a953 5
		    if (lines == 200) {
			arg = t - linemark;
			if (strnEQ(linemark, linemark - arg, arg))
			    DIE(aTHX_ "Runaway format");
		    }
d1020 1
a1020 1
    ENTER;					/* enter outer scope */
d1027 1
a1027 1
    ENTER;					/* enter inner scope */
d1108 1
a1108 1
    LEAVE;					/* exit inner scope */
d1114 1
a1114 1
	LEAVE;					/* exit outer scope */
d1137 1
a1137 1
	ENTER;					/* enter inner scope */
d1299 7
d1307 1
a1308 1
    "loop",
a1309 4
    "block",
    "format",
    "given",
    "when"
d1328 2
a1329 3
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting %s via %s",
			context_name[CxTYPE(cx)], OP_NAME(PL_op));
d1333 7
a1339 2
	case CXt_LOOP:
	    if ( !cx->blk_loop.label || strNE(label, cx->blk_loop.label) ) {
d1341 1
a1341 1
			(long)i, cx->blk_loop.label));
d1346 1
d1451 2
a1452 3
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting %s via %s",
			context_name[CxTYPE(cx)], OP_NAME(PL_op));
d1456 4
a1459 1
	case CXt_LOOP:
d1480 6
a1485 1
	case CXt_LOOP:
d1536 4
a1539 1
	case CXt_LOOP:
d1570 2
a1571 2
OP *
Perl_die_where(pTHX_ const char *message, STRLEN msglen)
d1579 1
a1579 1
	if (message) {
d1586 1
a1586 1
		else if (SvCUR(err) >= sizeof(prefix)+msglen-1) {
d1588 2
d1596 2
a1597 1
		    SvGROW(err, SvCUR(err)+sizeof(prefix)+msglen);
d1599 4
a1602 6
		    sv_catpvn(err, message, msglen);
		    if (ckWARN(WARN_MISC)) {
			const STRLEN start = SvCUR(err)-msglen-sizeof(prefix)+1;
			Perl_warner(aTHX_ packWARN(WARN_MISC), "%s",
				SvPVX_const(err)+start);
		    }
d1606 2
d1609 1
d1622 1
d1631 2
a1632 2
		if (!message)
		    message = SvPVx_const(ERRSV, msglen);
d1638 1
d1654 2
a1655 2
		SV * const nsv = cx->blk_eval.old_namesv;
                (void)hv_store(GvHVn(PL_incgv), SvPVX_const(nsv), SvCUR(nsv),
d1661 3
a1663 1
	    return cx->blk_eval.retop;
a1665 2
    if (!message)
	message = SvPVx_const(ERRSV, msglen);
d1667 1
a1667 1
    write_to_stderr(message, msglen);
a1669 1
    return 0;
d1759 1
a1759 1
	    mPUSHi((I32)CxHASARGS(cx));
d1763 1
a1763 1
	    mPUSHi((I32)CxHASARGS(cx));
d1774 1
a1774 1
	mPUSHi(gimme & G_ARRAY);
d1802 2
a1803 6
	if (!PL_dbargs) {
	    GV* const tmpgv = gv_fetchpvs("DB::args", GV_ADD, SVt_PVAV);
	    PL_dbargs = GvAV(gv_AVadd(tmpgv));
	    GvMULTI_on(tmpgv);
	    AvREAL_off(PL_dbargs);	/* XXX should be REIFY (see av.h) */
	}
d1922 1
a1922 1
    U16 cxtype = CXt_LOOP | CXp_FOREACH;
d1924 1
a1924 1
    void *iterdata;
d1927 1
a1927 1
    ENTER;
d1940 1
a1940 2
	iterdata = INT2PTR(void*, PL_op->op_targ);
	cxtype |= CXp_PADVAR;
d1949 1
a1949 1
	iterdata = (void*)gv;
d1956 1
a1956 1
    ENTER;
d1960 1
a1960 1
    PUSHLOOP(cx, iterdata, MARK);
d1962 1
a1962 1
    PUSHLOOP(cx, svp, MARK);
d1965 2
a1966 2
	cx->blk_loop.iterary = (AV*)SvREFCNT_inc(POPs);
	if (SvTYPE(cx->blk_loop.iterary) != SVt_PVAV) {
d1968 1
a1968 1
	    SV * const right = (SV*)cx->blk_loop.iterary;
d1972 5
d1997 2
a1998 2
		cx->blk_loop.iterix = SvIV(sv);
		cx->blk_loop.itermax = SvIV(right);
d2005 9
a2013 2
		cx->blk_loop.iterlval = newSVsv(sv);
		(void) SvPV_force_nolen(cx->blk_loop.iterlval);
d2021 1
a2021 1
		    cx->blk_loop.iterary = (AV*) &PL_sv_no;
d2025 7
a2031 4
	else if (PL_op->op_private & OPpITER_REVERSED) {
	    cx->blk_loop.itermax = 0;
	    cx->blk_loop.iterix = AvFILL(cx->blk_loop.iterary) + 1;

d2034 2
a2035 2
    else {
	cx->blk_loop.iterary = PL_curstack;
d2037 1
a2037 2
	    cx->blk_loop.itermax = MARK - PL_stack_base + 1;
	    cx->blk_loop.iterix = cx->blk_oldsp + 1;
d2040 1
a2040 1
	    cx->blk_loop.iterix = MARK - PL_stack_base;
d2053 1
a2053 1
    ENTER;
d2055 1
a2055 1
    ENTER;
d2057 2
a2058 2
    PUSHBLOCK(cx, CXt_LOOP, SP);
    PUSHLOOP(cx, 0, SP);
d2073 1
a2073 1
    assert(CxTYPE(cx) == CXt_LOOP);
d2098 2
a2099 2
    LEAVE;
    LEAVE;
d2114 1
d2116 1
a2116 1
    OP *retop;
d2157 1
d2166 4
a2169 3
	    SV * const nsv = cx->blk_eval.old_namesv;
	    (void)hv_delete(GvHVn(PL_incgv), SvPVX_const(nsv), SvCUR(nsv), G_DISCARD);
	    DIE(aTHX_ "%"SVf" did not return a true value", SVfARG(nsv));
d2240 1
a2240 1
    OP *nextop;
d2264 5
a2268 2
    case CXt_LOOP:
	pop2 = CXt_LOOP;
d2310 4
a2313 1
    case CXt_LOOP:
d2422 5
a2426 3
	    if ((kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) &&
		    CopLABEL(kCOP) && strEQ(CopLABEL(kCOP), label))
		return kid;
a2573 1
		    cx->blk_sub.hasargs = 0;
d2628 1
a2628 1
			CV * const gotocv = get_cv("DB::goto", 0);
d2675 6
a2680 1
	    case CXt_LOOP:
d2729 6
d2836 14
d2901 8
a2914 1
    /* FIXME - how much of this code is common with pp_entereval?  */
d2930 1
a2930 1
    ENTER;
d2977 1
a2977 1
    PUSHEVAL(cx, 0, NULL);
d2991 1
a2991 1
    LEAVE;
d3114 1
a3114 1
	PERL_CONTEXT *cx = &cxstack[cxstack_ix];
d3116 1
d3128 1
d3131 1
a3131 1
	LEAVE;
d3135 10
a3144 3
	    const SV * const nsv = cx->blk_eval.old_namesv;
	    (void)hv_store(GvHVn(PL_incgv), SvPVX_const(nsv), SvCUR(nsv),
                          &PL_sv_undef, 0);
d3171 2
a3172 8
     * If the last op is an OP_REQUIRE, force scalar context.
     * Otherwise, propagate the context from the eval(). */
    if (PL_eval_root->op_type == OP_LEAVEEVAL
	    && cUNOPx(PL_eval_root)->op_first->op_type == OP_LINESEQ
	    && cLISTOPx(cUNOPx(PL_eval_root)->op_first)->op_last->op_type
	    == OP_REQUIRE)
	scalar(PL_eval_root);
    else if ((gimme & G_WANT) == G_VOID)
d3183 1
a3183 1
	CV * const cv = get_cv("DB::postponed", 0);
d3311 1
a3311 1
		    SV * hintsv = newSV(0);
d3318 2
a3319 2
		    hintsv = Perl_newSVpvf(aTHX_ "v%d.%d.%d",
		    	(int)first, (int)second,0);
d3325 1
a3325 1
			SVfARG(vnormal(hintsv)),
d3331 15
a3345 10
        /* We do this only with use, not require. */
	if (PL_compcv &&
	  /* If we request a version >= 5.9.5, load feature.pm with the
	   * feature bundle that corresponds to the required version. */
		vcmp(sv, sv_2mortal(upg_version(newSVnv(5.009005), FALSE))) >= 0) {
	    SV *const importsv = vnormal(sv);
	    *SvPVX_mutable(importsv) = ':';
	    ENTER;
	    Perl_load_module(aTHX_ 0, newSVpvs("feature"), NULL, importsv, NULL);
	    LEAVE;
a3393 11
#ifdef MACOS_TRADITIONAL
    if (!tryrsfp) {
	char newname[256];

	MacPerl_CanonDir(name, newname, 1);
	if (path_is_absolute(newname)) {
	    tryname = newname;
	    tryrsfp = doopen_pm(newname, strlen(newname));
	}
    }
#endif
d3423 1
a3423 1
		    ENTER;
a3436 5
		    /* Adjust file name if the hook has set an %INC entry */
		    svp = hv_fetch(GvHVn(PL_incgv), name, len, 0);
		    if (svp)
			tryname = SvPVX_const(*svp);

d3496 7
a3502 1
		    LEAVE;
a3524 6
#ifdef MACOS_TRADITIONAL
			/* We consider paths of the form :a:b ambiguous and interpret them first
			   as global then as local
			*/
			|| (*name == ':' && name[1] != ':' && strchr(name+2, ':'))
#endif
d3536 1
a3536 8
#ifdef MACOS_TRADITIONAL
		    char buf1[256];
		    char buf2[256];

		    MacPerl_CanonDir(name, buf2, 1);
		    Perl_sv_setpvf(aTHX_ namesv, "%s%s", MacPerl_CanonDir(dir, buf1, 0), buf2+(buf2[0] == ':'));
#else
#  ifdef VMS
d3542 2
a3543 2
#  else
#    ifdef __SYMBIAN32__
d3555 1
a3555 1
#    else
a3575 1
#    endif
d3582 4
a3585 2
			if (tryname[0] == '.' && tryname[1] == '/')
			    tryname += 2;
d3649 1
a3649 1
    ENTER;
d3655 1
a3655 4
    if (PL_compiling.cop_hints_hash) {
	Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
	PL_compiling.cop_hints_hash = NULL;
    }
d3666 5
a3670 1
	SV * const datasv = filter_add(S_run_user_filter, NULL);
a3673 1
	IoFMT_GV(datasv) = MUTABLE_GV(filter_cache);
d3678 1
a3678 1
    PUSHEVAL(cx, name, NULL);
d3701 13
a3722 1
    char *safestr;
a3723 1
    bool ok;
d3727 1
a3727 3
    const char * const fakestr = "_<(eval )";
    const int fakelen = 9 + 1;
    
d3736 1
a3736 1
    ENTER;
a3760 2
    safestr = savepvn(tmpbuf, len);
    SAVEDELETE(PL_defstash, safestr, len);
d3773 12
a3784 1
    PL_compiling.cop_hints_hash = PL_curcop->cop_hints_hash;
d3798 1
a3798 1
    PUSHEVAL(cx, 0, NULL);
d3806 22
a3827 16
    ok = doeval(gimme, NULL, runcv, seq);
    if (ok ? (was != PL_breakable_sub_gen /* Some subs defined here. */
	      ? (PERLDB_LINE || PERLDB_SAVESRC)
	      :  PERLDB_SAVESRC_NOSUBS)
	: 0 /* PERLDB_SAVESRC_INVALID */
	/* Much that I'd like to think that it was this trivial to add this
	   feature, it's not, due to
	       lex_end();
	       LEAVE;
	   in S_doeval() for the failure case. So really we want a more
	   sophisticated way of (optionally) clearing the source code.
	   Particularly as the current way is buggy, as a syntactically
	   invalid eval string can still define a subroutine that is retained,
	   and the user may wish to breakpoint. */) {
	/* Copy in anything fake and short. */
	my_strlcpy(safestr, fakestr, fakelen);
a3828 1
    return ok ? DOCATCH(PL_eval_start) : PL_op->op_next;
d3842 1
d3846 1
d3887 5
a3891 3
	SV * const nsv = cx->blk_eval.old_namesv;
	(void)hv_delete(GvHVn(PL_incgv), SvPVX_const(nsv), SvCUR(nsv), G_DISCARD);
	retop = Perl_die(aTHX_ "%"SVf" did not return a true value", SVfARG(nsv));
d3895 1
a3895 1
	LEAVE;
d3918 1
a3918 1
    LEAVE;
d3932 1
a3932 1
    ENTER;
d3936 1
a3936 1
    PUSHEVAL(cx, 0, 0);
d4000 1
a4000 1
    LEAVE;
d4011 1
a4011 1
    ENTER;
d4014 1
a4014 7
    if (PL_op->op_targ == 0) {
	SV ** const defsv_p = &GvSV(PL_defgv);
	*defsv_p = newSVsv(POPs);
	SAVECLEARSV(*defsv_p);
    }
    else
    	sv_setsv(PAD_SV(PL_op->op_targ), POPs);
d4039 1
a4039 1
    LEAVE;
d4056 1
a4056 1
    ENTER; SAVETMPS;
d4086 1
a4086 1
    LEAVE;
d4092 1
a4107 5
    MAGIC *mg;

#   define SM_ISREGEX(x) \
	(SvROK(x) && SvMAGICAL(SvRV(x)) \
	&& (mg = mg_find(SvRV(x), PERL_MAGIC_qr)))
d4111 5
a4115 1
	SV * const tmpsv = amagic_call(d, e, smart_amg, 0);
d4122 1
d4142 1
d4149 2
a4150 1
    if (sv_isobject(e) && !SM_ISREGEX(e))
d4152 2
a4153 1
    if (sv_isobject(d) && !SM_ISREGEX(d))
d4168 1
d4172 2
a4173 1
		ENTER;
d4185 1
a4185 1
		LEAVE;
d4198 1
d4203 2
a4204 1
		ENTER;
d4217 1
a4217 1
		LEAVE;
d4226 2
a4227 1
	    ENTER;
d4239 1
a4239 1
	    LEAVE;
d4249 1
d4261 2
a4262 1
	    
d4284 2
a4285 1
	    	
d4313 1
d4316 1
d4324 2
a4325 1
	else if (SM_ISREGEX(d)) {
d4328 1
a4328 8
#ifdef DEBUGGING
		/* if arrive via goto, no guarantee mg is from d */
		MAGIC* old_mg = mg;
		assert(SM_ISREGEX(d) && old_mg == mg);
		{
#endif
		PMOP * const matcher = make_matcher((REGEXP*) mg->mg_obj);

d4334 1
a4342 3
#ifdef DEBUGGING
		}
#endif
d4347 1
d4364 1
d4367 2
d4378 1
d4390 1
a4390 1
		    seen_this = newHV();
d4398 2
a4399 1
			if (this_elem || other_elem)
d4421 1
d4424 1
d4433 2
a4434 1
	else if (SM_ISREGEX(d)) {
d4437 1
a4437 7
#ifdef DEBUGGING
		/* if arrive via goto, no guarantee mg is from d */
		MAGIC* old_mg = mg;
		assert(SM_ISREGEX(d) && old_mg == mg);
		{
#endif
		PMOP * const matcher = make_matcher((REGEXP*) mg->mg_obj);
d4443 1
a4450 3
#ifdef DEBUGGING
		}
#endif
d4458 1
d4461 1
d4473 1
d4483 1
d4486 1
d4495 1
a4495 1
    else if (SM_ISREGEX(e)) {
d4498 1
d4503 1
d4507 1
a4507 1
	    PMOP * const matcher = make_matcher((REGEXP*) mg->mg_obj);
d4509 1
d4522 2
d4534 1
d4539 1
d4545 5
d4565 1
a4569 1
#undef SM_ISREGEX
d4585 1
a4585 1
    ENTER;
d4610 1
a4610 1
    LEAVE;
d4927 2
a4928 2
    const char *got_p = NULL;
    const char *prune_from = NULL;
d4942 2
a4943 2
    if (IoFMT_GV(datasv)) {
	SV *const cache = MUTABLE_SV(IoFMT_GV(datasv));
d4997 1
a4997 1
	ENTER;
d5021 1
a5021 1
	LEAVE;
d5031 1
a5031 2
	    const char *const first_nl =
		(const char *)memchr(got_p, '\n', got_len);
d5041 1
a5041 1
	SV *cache = MUTABLE_SV(IoFMT_GV(datasv));
d5043 1
a5043 3
	if (!cache) {
	    IoFMT_GV(datasv) = MUTABLE_GV((cache = newSV(got_len - umaxlen)));
	} else if (SvOK(cache)) {
d5057 1
a5072 1
	SvREFCNT_dec(IoFMT_GV(datasv));
a5099 3
#ifdef MACOS_TRADITIONAL
	|| (*name == ':')
#endif
d5101 5
a5105 5
 || (*name == '.' && ((name[1] == '/' ||
 (name[1] == '.' && name[2] == '/'))
 || (name[1] == '\\' ||
 ( name[1] == '.' && name[2] == '\\')))
 )
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d12 8
a19 6
 * Now far ahead the Road has gone,
 * And I must follow, if I can,
 * Pursuing it with eager feet,
 * Until it joins some larger way
 * Where many paths and errands meet.
 * And whither then?  I cannot say.
d83 1
a83 1
    regexp * re;
d101 1
a101 1
	sv_setpvn(tmpstr, "", 0);
d136 2
a137 2
	if (!re || !re->precomp || re->prelen != (I32)len ||
	    memNE(re->precomp, t, len))
d139 1
a139 1
	    const regexp_engine *eng = re ? re->engine : NULL;
d172 1
a172 1
	    re->extflags |= RXf_TAINTED;
d174 1
a174 1
	    re->extflags &= ~RXf_TAINTED;
d178 1
a178 1
    if (!PM_GETRE(pm)->prelen && PL_curpm)
a222 1
	FREETMPS; /* Prevent excess tmp stack */
d225 1
a225 1
	if (cx->sb_once || !CALLREGEXEC(rx, s, cx->sb_strend, orig,
d258 1
a258 1
	    PUSHs(sv_2mortal(newSViv(saviters - 1)));
d271 1
a271 1
    if (RX_MATCH_COPIED(rx) && rx->subbeg != orig) {
d274 1
a274 1
	cx->sb_orig = orig = rx->subbeg;
d278 1
a278 1
    cx->sb_m = m = rx->offs[0].start + orig;
d285 1
a285 1
    cx->sb_s = rx->offs[0].end + orig;
a288 1
	I32 i;
d298 1
a298 4
	i = m - orig;
	if (DO_UTF8(sv))
	    sv_pos_b2u(sv, &i);
	mg->mg_len = i;
d312 2
d316 1
a316 1
    if (!p || p[1] < rx->nparens) {
d318 1
a318 1
	i = 7 + rx->nparens * 2;
d320 1
a320 1
	i = 6 + rx->nparens * 2;
d329 1
a329 1
    *p++ = PTR2UV(RX_MATCH_COPIED(rx) ? rx->subbeg : NULL);
d337 1
a337 1
    *p++ = rx->nparens;
d339 5
a343 5
    *p++ = PTR2UV(rx->subbeg);
    *p++ = (UV)rx->sublen;
    for (i = 0; i <= rx->nparens; ++i) {
	*p++ = (UV)rx->offs[i].start;
	*p++ = (UV)rx->offs[i].end;
d352 2
d367 1
a367 1
    rx->nparens = *p++;
d369 5
a373 5
    rx->subbeg = INT2PTR(char*,*p++);
    rx->sublen = (I32)(*p++);
    for (i = 0; i <= rx->nparens; ++i) {
	rx->offs[i].start = (I32)(*p++);
	rx->offs[i].end = (I32)(*p++);
d381 2
a429 1
    bool oneline;
d495 1
a755 2
	    oneline = TRUE;
	    goto ff_line;
a756 2
	    oneline = FALSE;
	ff_line:
d758 1
d760 1
a761 2
		if ((item_is_utf8 = DO_UTF8(sv)))
		    itemsize = sv_len_utf8(sv);
d763 1
a763 1
		    bool chopped = FALSE;
d765 3
d773 1
a773 1
				chopped = TRUE;
d779 1
a779 1
				    chopped = TRUE;
d785 23
a807 12
		    SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
		    if (targ_is_utf8)
			SvUTF8_on(PL_formtarget);
		    if (oneline) {
			SvCUR_set(sv, chophere - item);
			sv_catsv(PL_formtarget, sv);
			SvCUR_set(sv, itemsize);
		    } else
			sv_catsv(PL_formtarget, sv);
		    if (chopped)
			SvCUR_set(PL_formtarget, SvCUR(PL_formtarget) - 1);
		    SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
d809 17
a825 2
		    if (item_is_utf8)
			targ_is_utf8 = TRUE;
d957 1
a957 1
	    XPUSHs(sv_2mortal(newSViv(0)));
d978 1
a978 1
	DEFSV = src;
d1089 1
a1089 1
	    DEFSV = src;
d1146 1
a1146 1
	sv_setpvn(TARG, "", 0);
d1258 2
a1267 2
	case CXt_GIVEN:
	case CXt_WHEN:
d1326 2
a1327 2
    if (cxstack[cxix].blk_sub.lval && CvLVALUE(cxstack[cxix].blk_sub.cv))
	return cxstack[cxix].blk_sub.lval;
d1337 3
d1482 3
d1510 1
a1510 1
		    sv_setpvn(err,"",0);
d1524 2
a1525 1
			Perl_warner(aTHX_ packWARN(WARN_MISC), SvPVX_const(err)+start);
d1667 3
a1669 3
	PUSHs(sv_2mortal(newSVpv(stashname, 0)));
    PUSHs(sv_2mortal(newSVpv(OutCopFILE(cx->blk_oldcop), 0)));
    PUSHs(sv_2mortal(newSViv((I32)CopLINE(cx->blk_oldcop))));
d1678 2
a1679 2
	    PUSHs(sv_2mortal(sv));
	    PUSHs(sv_2mortal(newSViv((I32)cx->blk_sub.hasargs)));
d1682 2
a1683 2
	    PUSHs(sv_2mortal(newSVpvs("(unknown)")));
	    PUSHs(sv_2mortal(newSViv((I32)cx->blk_sub.hasargs)));
d1687 2
a1688 2
	PUSHs(sv_2mortal(newSVpvs("(eval)")));
	PUSHs(sv_2mortal(newSViv(0)));
d1694 1
a1694 1
	PUSHs(sv_2mortal(newSViv(gimme & G_ARRAY)));
d1697 1
a1697 1
	if (cx->blk_eval.old_op_type == OP_ENTEREVAL) {
d1703 1
a1703 1
	    PUSHs(sv_2mortal(newSVsv(cx->blk_eval.old_namesv)));
d1716 1
a1716 1
    if (CxTYPE(cx) == CXt_SUB && cx->blk_sub.hasargs
d1737 1
a1737 1
    PUSHs(sv_2mortal(newSViv(CopHINTS_get(cx->blk_oldcop))));
d1750 1
a1750 1
	    HV * const bits = get_hv("warnings::Bits", FALSE);
d1760 1
a1760 1
        PUSHs(sv_2mortal(mask));
d1765 2
a1766 2
	    (SV*)Perl_refcounted_he_chain_2hv(aTHX_
					      cx->blk_oldcop->cop_hints_hash)))
d1860 1
a1862 1
	SAVESPTR(*svp);
a1863 1
	SAVEPADSV(PL_op->op_targ);
d1869 1
a1869 1
	GV * const gv = (GV*)POPs;
d1897 19
a1915 2
		if ((SvOK(sv) && SvNV(sv) < IV_MIN) ||
		    (SvOK(right) && SvNV(right) >= IV_MAX))
d1927 2
d1930 6
a1945 1
	AvFILLp(PL_curstack) = SP - PL_stack_base;
d2134 3
a2136 2
    if (clear_errsv)
	sv_setpvn(ERRSV,"",0);
d2305 2
d2325 1
a2325 1
		    kCOP->cop_label && strEQ(kCOP->cop_label, label))
d2367 1
a2367 1
	    CV* cv = (CV*)SvRV(sv);
d2412 1
a2412 1
	    if (CxTYPE(cx) == CXt_SUB && cx->blk_sub.hasargs) {
d2429 1
a2429 1
		    PAD_SVl(0) = (SV*)(cx->blk_sub.argarray = av);
d2471 1
a2471 1
		    PL_in_eval = cx->blk_eval.old_in_eval;
d2483 1
a2483 1
		    if (CvDEPTH(cv) == 100 && ckWARN(WARN_RECURSION))
d2489 1
a2489 1
		if (cx->blk_sub.hasargs)
d2491 1
a2491 1
		    AV* const av = (AV*)PAD_SVl(0);
d2494 1
a2494 1
		    GvAV(PL_defgv) = (AV*)SvREFCNT_inc_simple(av);
d2529 1
a2529 1
			CV * const gotocv = get_cv("DB::goto", FALSE);
d2532 1
a2532 1
			    call_sv((SV*)gotocv, G_SCALAR | G_NODEBUG);
d2708 2
d2714 1
a2714 1
	t = strchr(s, '\n');
d2797 2
d2859 1
a2859 1
    *padp = (AV*)SvREFCNT_inc_simple(PL_comppad);
d2936 1
a2936 1
    PL_compcv = (CV*)newSV_type(SVt_PVCV);
d2942 1
a2942 1
    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc_simple(outside);
d2980 1
a2980 1
	sv_setpvn(ERRSV,"",0);
d3038 1
a3038 1
    else if (gimme & G_VOID)
d3040 1
a3040 1
    else if (gimme & G_ARRAY)
d3049 1
a3049 1
	CV * const cv = get_cv("DB::postponed", FALSE);
d3053 1
a3053 1
	    XPUSHs((SV*)CopFILEGV(&PL_compiling));
d3055 1
a3055 1
	    call_sv((SV*)cv, G_DISCARD);
d3079 2
d3094 2
a3147 8
	if ( SvVOK(sv) && ckWARN(WARN_PORTABLE) ) {	/* require v5.6.1 */
	    HV * hinthv = GvHV(PL_hintgv);
	    SV ** ptr = NULL;
	    if (hinthv) ptr = hv_fetchs(hinthv, "v_string", FALSE);
	    if ( !(ptr && *ptr && SvIOK(*ptr) && SvIV(*ptr)) )
		Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
                        "v-string in use/require non-portable");
	}
d3161 1
a3161 1
		SV * const pv = *hv_fetchs((HV*)req, "original", FALSE);
d3164 1
a3164 1
		lav = (AV *)SvRV(*hv_fetchs((HV*)req, "version", FALSE));
d3168 1
a3168 1
		    || hv_exists((HV*)req, "qv", 2 ) /* qv style */
a3198 11
	  /* If we request a version >= 5.6.0, then v-string are OK
	     so set $^H{v_string} to suppress the v-string warning */
	    vcmp(sv, sv_2mortal(upg_version(newSVnv(5.006), FALSE))) >= 0) {
	  HV * hinthv = GvHV(PL_hintgv);
	  if( hinthv ) {
	      SV *hint = newSViv(1);
	      (void)hv_stores(hinthv, "v_string", hint);
	      /* This will call through to Perl_magic_sethint() which in turn
		 sets PL_hints correctly.  */
	      SvSETMAGIC(hint);
	  }
d3201 1
a3201 1
	  if (vcmp(sv, sv_2mortal(upg_version(newSVnv(5.009005), FALSE))) >= 0) {
a3206 1
	  }
d3273 1
a3273 2
	    namesv = newSV(0);
	    sv_upgrade(namesv, SVt_PV);
d3277 1
a3277 1
		if (SvTIED_mg((SV*)ar, PERL_MAGIC_tied))
d3287 1
a3287 1
			loader = *av_fetch((AV *)SvRV(loader), 0, TRUE);
d3331 1
a3331 1
			if (SvROK(arg) && SvTYPE(SvRV(arg)) == SVt_PVGV) {
d3335 2
a3336 2
			if (SvTYPE(arg) == SVt_PVGV) {
			    IO * const io = GvIO((GV *)arg);
d3538 5
d3554 3
a3556 3
	IoTOP_GV(datasv) = (GV *)filter_state;
	IoBOTTOM_GV(datasv) = (GV *)filter_sub;
	IoFMT_GV(datasv) = (GV *)filter_cache;
d3590 1
a3590 1
    const I32 was = PL_sub_generation;
d3603 1
a3603 1
	saved_hh = (HV*) SvREFCNT_inc(POPs);
d3639 3
a3641 1
    if (saved_hh)
d3643 1
d3668 1
a3668 1
    if (PERLDB_LINE && PL_curstash != PL_debstash)
d3672 13
a3684 2
    if (PERLDB_INTER && was != (I32)PL_sub_generation /* Some subs defined here. */
	&& ok) {
d3752 3
a3754 2
	if (!(save_flags & OPf_SPECIAL))
	    sv_setpvn(ERRSV,"",0);
d3798 1
a3798 1
	sv_setpvn(ERRSV,"",0);
d3857 1
a3857 1
    sv_setpvn(ERRSV,"",0);
d3908 1
a3908 1
S_make_matcher(pTHX_ regexp *re)
d3912 3
d3916 1
a3916 1
    
d3928 2
d3943 2
d3946 1
d3966 1
a3968 1
    SV *This, *Other;	/* 'This' (and Other to match) to play with C++ */
a3969 1
    regexp *this_regex, *other_regex;
d3971 14
a3984 31
#   define NOT_EMPTY_PROTO(cv) (!SvPOK(cv) || SvCUR(cv) == 0)

#   define SM_REF(type) ( \
	   (SvROK(d) && (SvTYPE(This = SvRV(d)) == SVt_##type) && (Other = e)) \
	|| (SvROK(e) && (SvTYPE(This = SvRV(e)) == SVt_##type) && (Other = d)))

#   define SM_CV_NEP   /* Find a code ref without an empty prototype */ \
	((SvROK(d) && (SvTYPE(This = SvRV(d)) == SVt_PVCV)		\
	    && NOT_EMPTY_PROTO(This) && (Other = e))			\
	|| (SvROK(e) && (SvTYPE(This = SvRV(e)) == SVt_PVCV)		\
	    && NOT_EMPTY_PROTO(This) && (Other = d)))

#   define SM_REGEX ( \
	   (SvROK(d) && SvMAGICAL(This = SvRV(d))			\
	&& (mg = mg_find(This, PERL_MAGIC_qr))				\
	&& (this_regex = (regexp *)mg->mg_obj)				\
	&& (Other = e))							\
    ||									\
	   (SvROK(e) && SvMAGICAL(This = SvRV(e))			\
	&& (mg = mg_find(This, PERL_MAGIC_qr))				\
	&& (this_regex = (regexp *)mg->mg_obj)				\
	&& (Other = d))	)
	

#   define SM_OTHER_REF(type) \
	(SvROK(Other) && SvTYPE(SvRV(Other)) == SVt_##type)

#   define SM_OTHER_REGEX (SvROK(Other) && SvMAGICAL(SvRV(Other))	\
	&& (mg = mg_find(SvRV(Other), PERL_MAGIC_qr))			\
	&& (other_regex = (regexp *)mg->mg_obj))
	
a3985 8
#   define SM_SEEN_THIS(sv) hv_exists_ent(seen_this, \
	sv_2mortal(newSViv(PTR2IV(sv))), 0)

#   define SM_SEEN_OTHER(sv) hv_exists_ent(seen_other, \
	sv_2mortal(newSViv(PTR2IV(sv))), 0)

    tryAMAGICbinSET(smart, 0);
    
d4001 15
a4015 1
    if (SM_CV_NEP) {
d4017 57
a4073 4
	
	if ( SM_OTHER_REF(PVCV) && NOT_EMPTY_PROTO(SvRV(Other)) )
	{
	    if (This == SvRV(Other))
d4078 17
a4094 15
	
	ENTER;
	SAVETMPS;
	PUSHMARK(SP);
	PUSHs(Other);
	PUTBACK;
	c = call_sv(This, G_SCALAR);
	SPAGAIN;
	if (c == 0)
	    PUSHs(&PL_sv_no);
	else if (SvTEMP(TOPs))
	    SvREFCNT_inc_void(TOPs);
	FREETMPS;
	LEAVE;
	RETURN;
d4096 9
a4104 2
    else if (SM_REF(PVHV)) {
	if (SM_OTHER_REF(PVHV)) {
d4107 1
a4107 1
	    HV *other_hv = (HV *) SvRV(Other);
d4112 1
d4115 1
a4115 1
	    if (SvTIED_mg(This, PERL_MAGIC_tied)) {
d4118 1
a4118 1
	    else if (SvTIED_mg((SV *) other_hv, PERL_MAGIC_tied)) {
d4120 2
a4121 2
		other_hv = (HV *) This;
		This  = (SV *) temp;
d4124 1
a4124 1
	    if (SvTIED_mg((SV *) other_hv, PERL_MAGIC_tied))
d4127 1
a4127 1
	    if (!tied && HvUSEDKEYS((HV *) This) != HvUSEDKEYS(other_hv))
d4132 3
a4134 4
	    (void) hv_iterinit((HV *) This);
	    while ( (he = hv_iternext((HV *) This)) ) {
	    	I32 key_len;
		char * const key = hv_iterkey(he, &key_len);
d4138 2
a4139 2
	    	if(!hv_exists(other_hv, key, key_len)) {
	    	    (void) hv_iterinit((HV *) This);	/* reset iterator */
d4157 2
a4158 2
	else if (SM_OTHER_REF(PVAV)) {
	    AV * const other_av = (AV *) SvRV(Other);
d4161 1
a4164 3
		char *key;
		STRLEN key_len;

d4166 1
a4166 2
		    key = SvPV(*svp, key_len);
		    if (hv_exists((HV *) This, key, key_len))
d4172 13
a4184 3
	else if (SM_OTHER_REGEX) {
	    PMOP * const matcher = make_matcher(other_regex);
	    HE *he;
d4186 11
a4196 6
	    (void) hv_iterinit((HV *) This);
	    while ( (he = hv_iternext((HV *) This)) ) {
		if (matcher_matches_sv(matcher, hv_iterkeysv(he))) {
		    (void) hv_iterinit((HV *) This);
		    destroy_matcher(matcher);
		    RETPUSHYES;
d4198 1
a4199 2
	    destroy_matcher(matcher);
	    RETPUSHNO;
d4202 2
a4203 1
	    if (hv_exists_ent((HV *) This, Other, 0))
d4209 22
a4230 4
    else if (SM_REF(PVAV)) {
	if (SM_OTHER_REF(PVAV)) {
	    AV *other_av = (AV *) SvRV(Other);
	    if (av_len((AV *) This) != av_len(other_av))
d4238 1
a4238 1
		    (void) sv_2mortal((SV *) seen_this);
d4242 1
a4242 1
		    (void) sv_2mortal((SV *) seen_other);
d4245 1
a4245 1
		    SV * const * const this_elem = av_fetch((AV *)This, i, FALSE);
d4252 4
a4255 2
		    else if (SM_SEEN_THIS(*this_elem)
			 || SM_SEEN_OTHER(*other_elem))
d4267 1
a4268 1
			PUSHs(*other_elem);
d4281 23
a4303 10
	else if (SM_OTHER_REGEX) {
	    PMOP * const matcher = make_matcher(other_regex);
	    const I32 this_len = av_len((AV *) This);
	    I32 i;

	    for(i = 0; i <= this_len; ++i) {
		SV * const * const svp = av_fetch((AV *)This, i, FALSE);
		if (svp && matcher_matches_sv(matcher, *svp)) {
		    destroy_matcher(matcher);
		    RETPUSHYES;
d4305 1
a4306 2
	    destroy_matcher(matcher);
	    RETPUSHNO;
d4308 3
a4310 1
	else if (SvIOK(Other) || SvNOK(Other)) {
d4313 3
a4315 14
	    for(i = 0; i <= AvFILL((AV *) This); ++i) {
		SV * const * const svp = av_fetch((AV *)This, i, FALSE);
		if (!svp)
		    continue;
		
		PUSHs(Other);
		PUSHs(*svp);
		PUTBACK;
		if (CopHINTS_get(PL_curcop) & HINT_INTEGER)
		    (void) pp_i_eq();
		else
		    (void) pp_eq();
		SPAGAIN;
		if (SvTRUEx(POPs))
d4320 10
a4329 3
	else if (SvPOK(Other)) {
	    const I32 this_len = av_len((AV *) This);
	    I32 i;
d4331 10
a4340 12
	    for(i = 0; i <= this_len; ++i) {
		SV * const * const svp = av_fetch((AV *)This, i, FALSE);
		if (!svp)
		    continue;
		
		PUSHs(Other);
		PUSHs(*svp);
		PUTBACK;
		(void) pp_seq();
		SPAGAIN;
		if (SvTRUEx(POPs))
		    RETPUSHYES;
a4341 1
	    RETPUSHNO;
d4344 12
a4355 8
    else if (!SvOK(d) || !SvOK(e)) {
	if (!SvOK(d) && !SvOK(e))
	    RETPUSHYES;
	else
	    RETPUSHNO;
    }
    else if (SM_REGEX) {
	PMOP * const matcher = make_matcher(this_regex);
d4357 7
a4363 6
	PUTBACK;
	PUSHs(matcher_matches_sv(matcher, Other)
	    ? &PL_sv_yes
	    : &PL_sv_no);
	destroy_matcher(matcher);
	RETURN;
d4365 5
a4369 8
    else if (SM_REF(PVCV)) {
	I32 c;
	/* This must be a null-prototyped sub, because we
	   already checked for the other kind. */
	
	ENTER;
	SAVETMPS;
	PUSHMARK(SP);
d4371 2
a4372 12
	c = call_sv(This, G_SCALAR);
	SPAGAIN;
	if (c == 0)
	    PUSHs(&PL_sv_undef);
	else if (SvTEMP(TOPs))
	    SvREFCNT_inc_void(TOPs);

	if (SM_OTHER_REF(PVCV)) {
	    /* This one has to be null-proto'd too.
	       Call both of 'em, and compare the results */
	    PUSHMARK(SP);
	    c = call_sv(SvRV(Other), G_SCALAR);
d4374 3
a4376 8
	    if (c == 0)
		PUSHs(&PL_sv_undef);
	    else if (SvTEMP(TOPs))
		SvREFCNT_inc_void(TOPs);
	    FREETMPS;
	    LEAVE;
	    PUTBACK;
	    return pp_eq();
d4378 6
a4383 4
	
	FREETMPS;
	LEAVE;
	RETURN;
d4385 4
a4388 10
    else if ( ((SvIOK(d) || SvNOK(d)) && (This = d) && (Other = e))
         ||   ((SvIOK(e) || SvNOK(e)) && (This = e) && (Other = d)) )
    {
	if (SvPOK(Other) && !looks_like_number(Other)) {
	    /* String comparison */
	    PUSHs(d); PUSHs(e);
	    PUTBACK;
	    return pp_seq();
	}
	/* Otherwise, numeric comparison */
d4407 1
d4526 2
d4760 2
a4761 2
    SV * const filter_state = (SV *)IoTOP_GV(datasv);
    SV * const filter_sub = (SV *)IoBOTTOM_GV(datasv);
d4770 2
d4781 1
a4781 1
	SV *const cache = (SV *)IoFMT_GV(datasv);
d4840 1
a4840 1
	DEFSV = upstream;
d4842 1
a4842 1
	PUSHs(sv_2mortal(newSViv(0)));
d4880 1
a4880 1
	SV *cache = (SV *)IoFMT_GV(datasv);
d4883 1
a4883 1
	    IoFMT_GV(datasv) = (GV*) (cache = newSV(got_len - umaxlen));
d4938 2
d4943 7
@


1.11
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d41 1
a41 1
static I32 run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen);
d45 1
a63 5
PP(pp_regcmaybe)
{
    return NORMAL;
}

d66 1
d76 1
d80 2
a81 3
    MAGIC *mg = Null(MAGIC*);

    tmpstr = POPs;
d84 10
a93 3
#if defined(USE_ITHREADS) || defined(USE_5005THREADS)
    if (pm->op_pmflags & PMf_KEEP && PM_GETRE(pm))
	 RETURN;
d95 22
d119 1
a119 1
	SV *sv = SvRV(tmpstr);
d124 1
a124 1
	regexp * const re = (regexp *)mg->mg_obj;
d126 1
a126 1
	PM_SETRE(pm, ReREFCNT_inc(re));
d130 2
a131 1
	const char *t = SvPV_const(tmpstr, len);
d134 2
a135 3
	if (!PM_GETRE(pm) || !PM_GETRE(pm)->precomp ||
	    PM_GETRE(pm)->prelen != (I32)len ||
	    memNE(PM_GETRE(pm)->precomp, t, len))
d137 10
a146 3
	    if (PM_GETRE(pm)) {
	        ReREFCNT_dec(PM_GETRE(pm));
		PM_SETRE(pm, Null(REGEXP*));	/* crucial if regcomp aborts */
d148 1
a151 1
	    pm->op_pmflags = pm->op_pmpermflags;	/* reset case sensitivity */
d153 7
a159 9
		pm->op_pmdynflags |= PMdf_DYN_UTF8;
	    else {
		pm->op_pmdynflags &= ~PMdf_DYN_UTF8;
		if (pm->op_pmdynflags & PMdf_UTF8)
		    t = (char*)bytes_to_utf8((U8*)t, &len);
	    }
	    PM_SETRE(pm, CALLREGCOMP(aTHX_ (char *)t, (char *)t + len, pm));
	    if (!DO_UTF8(tmpstr) && (pm->op_pmdynflags & PMdf_UTF8))
		Safefree(t);
d164 2
d170 1
a170 1
	    pm->op_pmdynflags |= PMdf_TAINTED;
d172 1
a172 1
	    pm->op_pmdynflags &= ~PMdf_TAINTED;
a177 4
    else if (strEQ("\\s+", PM_GETRE(pm)->precomp))
	pm->op_pmflags |= PMf_WHITE;
    else
	pm->op_pmflags &= ~PMf_WHITE;
d179 4
a182 1
    /* XXX runtime compiled output needs to move to the pad */
a184 2
#if !defined(USE_ITHREADS) && !defined(USE_5005THREADS)
	/* XXX can't change the optree at runtime either */
d186 1
a187 1
    }
d193 1
d202 1
a202 1
    SV *nsv = Nullsv;
d207 1
a207 1
	PM_SETRE(pm,rx);
d221 1
d224 1
a224 1
	if (cx->sb_once || !CALLREGEXEC(aTHX_ rx, s, cx->sb_strend, orig,
d241 8
a248 1
	    SvPV_free(targ);
d254 1
a254 2
	    SvPV_set(dstr, (char*)0);
	    sv_free(dstr);
a264 1
	    ReREFCNT_dec(rx);
d277 1
a277 1
    cx->sb_m = m = rx->startp[0] + orig;
d284 1
a284 1
    cx->sb_s = rx->endp[0] + orig;
d289 1
a289 2
	if (SvTYPE(sv) < SVt_PVMG)
	    (void)SvUPGRADE(sv, SVt_PVMG);
d291 6
a296 2
	    sv_magic(sv, Nullsv, PERL_MAGIC_regex_global, Nullch, 0);
	    mg = mg_find(sv, PERL_MAGIC_regex_global);
d307 1
a307 1
    RETURNOP(pm->op_pmreplstart);
d315 1
d318 3
d322 1
d330 1
a330 1
    *p++ = PTR2UV(RX_MATCH_COPIED(rx) ? rx->subbeg : Nullch);
d333 5
d343 2
a344 2
	*p++ = (UV)rx->startp[i];
	*p++ = (UV)rx->endp[i];
d353 1
d355 1
a355 2
    if (RX_MATCH_COPIED(rx))
	Safefree(rx->subbeg);
d359 7
d371 2
a372 2
	rx->startp[i] = (I32)(*p++);
	rx->endp[i] = (I32)(*p++);
d380 1
d387 1
a387 1
	    Poison(*p, 1, sizeof(*p));
d391 5
d397 1
a397 1
	*rsp = Null(void*);
d403 1
a403 1
    dSP; dMARK; dORIGMARK;
d409 2
a410 2
    register SV *sv = Nullsv;
    const char *item = Nullch;
d414 3
a416 3
    bool chopspace = (strchr(PL_chopset, ' ') != Nullch);
    const char *chophere = Nullch;
    char *linemark = Nullch;
d424 2
a425 2
    SV * nsv = Nullsv;
    OP * parseres = 0;
d743 1
a743 1
		    while (*s && isSPACE(*s))
d746 1
a746 1
		sv_chop(sv,(char *)s);
d805 3
a807 1
	    fmt = (arg & 256) ? "%#0*.*" PERL_PRIfldbl : "%0*.*" PERL_PRIfldbl;
d809 3
a811 1
	    fmt = (arg & 256) ? "%#0*.*f"              : "%0*.*f";
d817 2
a818 1
 	    fmt = (arg & 256) ? "%#*.*" PERL_PRIfldbl : "%*.*" PERL_PRIfldbl;
d820 2
a821 1
            fmt = (arg & 256) ? "%#*.*f"              : "%*.*f";
d844 1
a844 1
		sprintf(t, fmt, (int) fieldsize, (int) arg & 255, value);
d887 1
a887 1
		    while (*s && isSPACE(*s) && s < send)
d923 1
a923 1
    dSP;
d938 4
a941 2
    /* SAVE_DEFSV does *not* suffice here for USE_5005THREADS */
    SAVESPTR(DEFSV);
d947 4
a950 1
    DEFSV = src;
a957 5
PP(pp_mapstart)
{
    DIE(aTHX_ "panic: mapstart");	/* uses grepstart */
}

d960 1
a960 1
    dSP;
d1035 9
a1043 2
	    dTARGET;
	    XPUSHi(items);
d1058 4
a1061 1
	DEFSV = src;
d1071 1
d1082 1
d1098 1
a1098 1
		GV * const gv = gv_fetchpv(".", TRUE, SVt_PV);
d1137 1
a1137 1
    dSP;
d1142 2
a1143 4
	if (SvGMAGICAL(left))
	    mg_get(left);
	if (SvGMAGICAL(right))
	    mg_get(right);
d1192 1
a1192 1
		GV * const gv = gv_fetchpv(".", TRUE, SVt_PV);
d1202 1
a1202 1
	    sv_catpvn(targ, "E0", 2);
d1219 3
a1221 1
    "format"
d1227 1
d1238 2
d1259 2
d1264 1
d1272 1
d1294 1
a1304 6
S_dopoptosub(pTHX_ I32 startingblock)
{
    return dopoptosub_at(cxstack, startingblock);
}

STATIC I32
d1307 1
d1327 1
d1345 1
d1369 41
d1413 1
d1450 1
d1456 3
a1458 2
	Perl_warn(aTHX_ "%"SVf, err);
    ++PL_error_count;
d1462 1
a1462 1
Perl_die_where(pTHX_ char *message, STRLEN msglen)
d1464 2
d1474 1
a1474 1
                const char *e = Nullch;
d1482 1
a1482 1
			e = Nullch;
d1517 2
a1518 2
		    message = (char *)SvPVx_const(ERRSV, msglen);
		PerlIO_write(Perl_error_log, "panic: die ", 11);
d1537 4
a1540 1
		const char* msg = SvPVx_nolen_const(ERRSV);
d1544 2
a1545 1
	    return pop_return();
d1549 1
a1549 1
	message = (char *)SvPVx_const(ERRSV, msglen);
d1559 1
a1559 1
    dSP; dPOPTOPssrl;
a1565 18
PP(pp_andassign)
{
    dSP;
    if (!SvTRUE(TOPs))
	RETURN;
    else
	RETURNOP(cLOGOP->op_other);
}

PP(pp_orassign)
{
    dSP;
    if (SvTRUE(TOPs))
	RETURN;
    else
	RETURNOP(cLOGOP->op_other);
}
	
d1568 1
d1627 1
a1627 1
    EXTEND(SP, 10);
d1638 1
a1638 1
	GV *cvgv = CvGV(ccstack[cxix].blk_sub.cv);
d1641 2
a1642 2
	    SV * const sv = NEWSV(49, 0);
	    gv_efullname3(sv, cvgv, Nullch);
d1647 1
a1647 1
	    PUSHs(sv_2mortal(newSVpvn("(unknown)",9)));
d1652 1
a1652 1
	PUSHs(sv_2mortal(newSVpvn("(eval)",6)));
d1688 2
a1689 3
	    GV* tmpgv;
	    PL_dbargs = GvAV(gv_AVadd(tmpgv = gv_fetchpv("DB::args", TRUE,
				SVt_PVAV)));
d1702 1
a1702 2
    PUSHs(sv_2mortal(newSViv((I32)cx->blk_oldcop->op_private &
			     HINT_PRIVATE_MASK)));
d1705 1
a1705 1
	SV * old_warnings = cx->blk_oldcop->cop_warnings ;
d1715 2
a1716 2
	    HV *bits = get_hv("warnings::Bits", FALSE);
	    if (bits && (bits_all=hv_fetch(bits, "all", 3, FALSE))) {
d1724 1
a1724 1
            mask = newSVsv(old_warnings);
d1727 6
d1738 1
d1740 2
a1741 7
    const char *tmps;

    if (MAXARG < 1)
	tmps = "";
    else
	tmps = POPpconstx;
    sv_reset((char *)tmps, CopSTASH(PL_curcop));
a1745 5
PP(pp_lineseq)
{
    return NORMAL;
}

d1750 1
a1759 1
	register CV *cv;
d1763 2
a1764 1
	GV *gv;
a1765 2
	gv = PL_DBgv;
	cv = GvCV(gv);
d1782 1
a1782 1
	if (CvXSUB(cv)) {
a1785 1

d1790 2
a1791 2
	} else {
	    push_return(PL_op->op_next);
d1794 1
a1804 5
PP(pp_scope)
{
    return NORMAL;
}

d1807 1
a1807 1
    dSP; dMARK;
d1811 1
a1811 1
    U32 cxtype = CXt_LOOP;
a1818 8
#ifdef USE_5005THREADS
    if (PL_op->op_flags & OPf_SPECIAL) {
	svp = &THREADSV(PL_op->op_targ);	/* per-thread variable */
	SAVEGENERICSV(*svp);
	*svp = NEWSV(0,0);
    }
    else
#endif /* USE_5005THREADS */
d1820 5
d1835 1
a1835 1
	GV *gv = (GV*)POPs;
d1838 1
a1838 1
	*svp = NEWSV(0,0);
d1844 3
d1859 1
a1859 1
	    SV *right = (SV*)cx->blk_loop.iterary;
d1902 1
a1902 1
    dSP;
d1918 1
a1918 1
    dSP;
d1932 1
a1932 1
	; /* do nothing */
d1959 1
a1959 2
    dSP; dMARK;
    I32 cxix;
d1968 3
d1972 6
a1977 7
    if (PL_curstackinfo->si_type == PERLSI_SORT) {
	if (cxstack_ix == PL_sortcxix
	    || dopoptosub(cxstack_ix) <= PL_sortcxix)
	{
	    if (cxstack_ix > PL_sortcxix)
		dounwind(PL_sortcxix);
	    AvARRAY(PL_curstack)[1] = *SP;
d1981 2
a1983 4

    cxix = dopoptosub(cxstack_ix);
    if (cxix < 0)
	DIE(aTHX_ "Can't return outside a subroutine");
d1987 11
d2002 1
d2009 1
d2019 1
a2019 1
	    DIE(aTHX_ "%"SVf" did not return a true value", nsv);
d2024 1
d2072 1
a2072 1
	sv = Nullsv;
d2078 1
a2078 1
    return pop_return();
d2083 1
a2083 1
    dSP;
d2093 1
a2093 1
    SV *sv = Nullsv;
d2116 1
a2116 1
	nextop = cx->blk_loop.last_op->op_next;
d2120 1
a2120 1
	nextop = pop_return();
d2124 1
a2124 1
	nextop = pop_return();
d2128 1
a2128 1
	nextop = pop_return();
d2174 1
d2199 1
a2199 1
    return cx->blk_loop.next_op;
d2204 1
d2208 1
d2223 8
d2236 1
a2236 1
    return cx->blk_loop.redo_op;
d2242 1
a2286 6
PP(pp_dump)
{
    return pp_goto();
    /*NOTREACHED*/
}

d2289 2
a2290 2
    dSP;
    OP *retop = 0;
d2295 1
a2295 1
    const char *label = 0;
d2326 2
a2327 2
		    gv_efullname3(tmpstr, (GV *) gv, Nullch);
		    DIE(aTHX_ "Goto undefined subroutine &%"SVf"",tmpstr);
d2333 1
a2333 1
	    (void)SvREFCNT_inc(cv); /* avoid premature free during unwind */
d2342 1
d2349 2
a2357 1
#ifndef USE_5005THREADS
a2359 1
#endif /* USE_5005THREADS */
d2367 1
a2367 1
		    AvFLAGS(av) = AVf_REIFY;
d2371 1
a2371 4
	    else if (CvXSUB(cv)) {	/* put GvAV(defgv) back onto stack */
#ifdef USE_5005THREADS
		AV* const av = (AV*)PAD_SVl(0);
#else
a2372 1
#endif
d2388 4
a2391 1
	    if (CvXSUB(cv)) {
a2396 18
#ifdef PERL_XSUB_OLDSTYLE
		if (CvOLDSTYLE(cv)) {
		    I32 (*fp3)(int,int,int);
		    while (SP > mark) {
			SP[1] = SP[0];
			SP--;
		    }
		    fp3 = (I32(*)(int,int,int))CvXSUB(cv);
		    items = (*fp3)(CvXSUBANY(cv).any_i32,
		                   mark - PL_stack_base + 1,
				   items);
		    SP = PL_stack_base + items;
		}
		else
#endif /* PERL_XSUB_OLDSTYLE */
		{
		    SV **newsp;
		    I32 gimme;
d2398 6
a2403 13
		    /* Push a mark for the start of arglist */
		    PUSHMARK(mark);
		    PUTBACK;
		    (void)(*CvXSUB(cv))(aTHX_ cv);

		    /* Pop the current context like a decent sub should */
		    POPBLOCK(cx, PL_curpm);
		    /* Do _not_ use PUTBACK, keep the XSUB's return stack! */

		    /* Put these at the bottom since the vars are set but not used */
		    PERL_UNUSED_VAR(newsp);
		    PERL_UNUSED_VAR(gimme);
		}
d2405 1
a2405 1
		return pop_return();
d2408 1
a2408 1
		AV* padlist = CvPADLIST(cv);
d2416 1
a2416 1
		cx->blk_sub.olddepth = (U16)CvDEPTH(cv);
d2420 1
a2420 1
		    (void)SvREFCNT_inc(cv);
d2424 1
a2424 14
		    pad_push(padlist, CvDEPTH(cv), 1);
		}
#ifdef USE_5005THREADS
		if (!cx->blk_sub.hasargs) {
		    AV* av = (AV*)PAD_SVl(0);
		
		    items = AvFILLp(av) + 1;
		    if (items) {
			/* Mark is at the end of the stack. */
			EXTEND(SP, items);
			Copy(AvARRAY(av), SP + 1, items, SV*);
			SP += items;
			PUTBACK ;		
		    }
a2425 1
#endif /* USE_5005THREADS */
a2427 1
#ifndef USE_5005THREADS
a2428 1
#endif /* USE_5005THREADS */
d2430 1
a2430 2
		    AV* av = (AV*)PAD_SVl(0);
		    SV** ary;
a2431 1
#ifndef USE_5005THREADS
d2433 1
a2433 2
		    GvAV(PL_defgv) = (AV*)SvREFCNT_inc(av);
#endif /* USE_5005THREADS */
d2438 1
a2438 1
			ary = AvALLOC(av);
d2441 1
a2441 1
			    SvPV_set(av, (char*)ary);
d2447 1
a2447 1
			    SvPV_set(av, (char*)ary);
d2466 8
a2473 22
		    /*
		     * We do not care about using sv to call CV;
		     * it's for informational purposes only.
		     */
		    SV * const sv = GvSV(PL_DBsub);
		    CV *gotocv;

		    save_item(sv);
		    if (PERLDB_SUB_NN) {
			const int type = SvTYPE(sv);
			if (type < SVt_PVIV && type != SVt_IV)
			    sv_upgrade(sv, SVt_PVIV);
			(void)SvIOK_on(sv);
			SvIV_set(sv, PTR2IV(cv)); /* Do it the quickest way */
		    } else {
			gv_efullname3(sv, CvGV(cv), Nullch);
		    }
		    if (  PERLDB_GOTO
			  && (gotocv = get_cv("DB::goto", FALSE)) ) {
			PUSHMARK( PL_stack_sp );
			call_sv((SV*)gotocv, G_SCALAR | G_NODEBUG);
			PL_stack_sp--;
d2493 1
a2493 1
	OP *gotoprobe = 0;
d2496 1
a2496 1
        PERL_CONTEXT *last_eval_cx = 0;
d2500 1
a2500 1
	PL_lastgotoprobe = 0;
d2528 1
a2528 1
		if (CvDEPTH(cx->blk_sub.cv)) {
d2580 1
a2580 1
	    OP *oldop = PL_op;
d2612 1
d2627 5
d2633 1
a2637 40
#ifdef NOTYET
PP(pp_nswitch)
{
    dSP;
    const NV value = SvNVx(GvSV(cCOP->cop_gv));
    register I32 match = I_32(value);

    if (value < 0.0) {
	if (((NV)match) > value)
	    --match;		/* was fractional--truncate other way */
    }
    match -= cCOP->uop.scop.scop_offset;
    if (match < 0)
	match = 0;
    else if (match > cCOP->uop.scop.scop_max)
	match = cCOP->uop.scop.scop_max;
    PL_op = cCOP->uop.scop.scop_next[match];
    RETURNOP(PL_op);
}

PP(pp_cswitch)
{
    dSP;
    register I32 match;

    if (PL_multiline)
	PL_op = PL_op->op_next;			/* can't assume anything */
    else {
	match = *(SvPVx_nolen_const(GvSV(cCOP->cop_gv))) & 255;
	match -= cCOP->uop.scop.scop_offset;
	if (match < 0)
	    match = 0;
	else if (match > cCOP->uop.scop.scop_max)
	    match = cCOP->uop.scop.scop_max;
	PL_op = cCOP->uop.scop.scop_next[match];
    }
    RETURNOP(PL_op);
}
#endif

d2649 1
a2649 1
	SV * const tmpstr = NEWSV(85,0);
a2650 1
	sv_upgrade(tmpstr, SVt_PVMG);
a2662 15
#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_docatch_body(pTHX_ va_list args)
{
    return docatch_body();
}
#endif

STATIC void
S_docatch_body(pTHX)
{
    CALLRUNOPS(aTHX);
    return;
}

d2666 1
a2668 2
    OP *retop;
    volatile PERL_SI *cursi = PL_curstackinfo;
a2675 12
    /* Normally, the leavetry at the end of this block of ops will
     * pop an op off the return stack and continue there. By setting
     * the op to Nullop, we force an exit from the inner runops()
     * loop. DAPM.
     */
    retop = pop_return();
    push_return(Nullop);

#ifdef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
    CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_docatch_body));
#else
a2676 1
#endif
d2679 3
a2681 1
#ifndef PERL_FLEXIBLE_EXCEPTIONS
d2683 1
a2683 2
	docatch_body();
#endif
d2687 11
a2697 1
	if (PL_restartop && cursi == PL_curstackinfo) {
a2701 3
	/* a die in this eval - continue in outer loop */
	if (!PL_restartop)
	    break;
d2711 1
a2711 1
    return retop;
d2715 1
a2715 1
Perl_sv_compile_2op(pTHX_ SV *sv, OP** startop, char *code, PAD** padp)
d2720 2
a2721 1
    dSP;				/* Make POPBLOCK work. */
a2726 1
    OP *rop;
d2731 2
a2732 1
    CV* runcv = Nullcv;	/* initialise to avoid compiler warnings */
d2735 1
a2735 1
    lex_start(sv);
d2749 1
d2752 2
a2753 1
	sprintf(tmpbuf, "_<(%.10s_eval %lu)", code, (unsigned long)++PL_evalseq);
d2763 2
a2764 2
    safestr = savepv(tmpbuf);
    SAVEDELETE(PL_defstash, safestr, strlen(safestr));
d2781 1
a2781 1
    PUSHEVAL(cx, 0, Nullgv);
d2784 1
a2784 1
	rop = doeval(G_SCALAR, startop, runcv, PL_curcop->cop_seq);
d2786 1
a2786 1
	rop = doeval(G_SCALAR, startop, PL_compcv, PL_cop_seqmax);
d2794 1
a2794 1
    *padp = (AV*)SvREFCNT_inc(PL_comppad);
d2797 1
a2797 1
	PL_compiling.op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d2804 1
a2804 1
    return rop;
d2823 1
d2853 3
d2858 1
a2858 2
/* With USE_5005THREADS, eval_owner must be held on entry to doeval */
STATIC OP *
d2861 1
a2861 1
    dSP;
d2871 1
a2871 2
    PL_compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)PL_compcv, SVt_PVCV);
a2875 6
#ifdef USE_5005THREADS
    CvOWNER(PL_compcv) = 0;
    New(666, CvMUTEXP(PL_compcv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(PL_compcv));
#endif /* USE_5005THREADS */

d2877 1
a2877 1
    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc(outside);
d2882 1
d2885 2
a2886 1
    SAVEMORTALIZESV(PL_compcv);	/* must remain until end of current statement */
d2894 1
d2898 8
a2905 1
    SAVEI32(PL_error_count);
d2909 1
a2909 2
    PL_eval_root = Nullop;
    PL_error_count = 0;
d2911 2
a2912 2
    PL_curcop->cop_arybase = 0;
    if (saveop && saveop->op_flags & OPf_SPECIAL)
d2916 1
a2916 1
    if (yyparse() || PL_error_count || !PL_eval_root) {
d2918 1
a2918 1
	PERL_CONTEXT *cx;
d2925 1
a2925 1
	    PL_eval_root = Nullop;
a2930 1
	    pop_return();
d2937 5
a2941 3
            const char* const msg = SvPVx_nolen_const(ERRSV);
	    DIE(aTHX_ "%sCompilation failed in require",
		*msg ? msg : "Unknown error\n");
d2951 1
a2951 1
	        sv_setpv(ERRSV, "Compilation error");
a2953 6
#ifdef USE_5005THREADS
	MUTEX_LOCK(&PL_eval_mutex);
	PL_eval_owner = 0;
	COND_SIGNAL(&PL_eval_cond);
	MUTEX_UNLOCK(&PL_eval_mutex);
#endif /* USE_5005THREADS */
d2955 3
a2957 1
	RETPUSHUNDEF;
d2983 1
a2983 1
    if (PERLDB_INTER && saveop->op_type == OP_REQUIRE) {
d2994 3
d3002 1
a3002 7
    PL_lex_state = LEX_NOTPARSING;	/* $^S needs this. */
#ifdef USE_5005THREADS
    MUTEX_LOCK(&PL_eval_mutex);
    PL_eval_owner = 0;
    COND_SIGNAL(&PL_eval_cond);
    MUTEX_UNLOCK(&PL_eval_mutex);
#endif /* USE_5005THREADS */
d3004 2
a3005 1
    RETURNOP(PL_eval_start);
d3009 1
a3009 1
S_check_type_and_open(pTHX_ const char *name, const char *mode)
d3012 4
a3015 4
    int st_rc;
    st_rc = PerlLIO_stat(name, &st);
    if (st_rc < 0) {
       return Nullfp;
d3018 1
a3018 5
    if(S_ISDIR(st.st_mode) || S_ISBLK(st.st_mode)) {
       Perl_die(aTHX_ "%s %s not allowed in require",
           S_ISDIR(st.st_mode) ? "Directory" : "Block device", name);
    }
    return PerlIO_open(name, mode);
d3021 1
d3023 1
a3023 1
S_doopen_pm(pTHX_ const char *name, const char *mode)
a3024 2
#ifndef PERL_DISABLE_PMC
    const STRLEN namelen = strlen(name);
d3027 3
a3029 3
    if (namelen > 3 && strEQ(name + namelen - 3, ".pm")) {
	SV * const pmcsv = Perl_newSVpvf(aTHX_ "%s%c", name, 'c');
	const char * const pmc = SvPV_nolen_const(pmcsv);
d3031 5
d3037 1
a3037 1
	    fp = check_type_and_open(name, mode);
d3040 1
a3040 9
	    Stat_t pmstat;
	    if (PerlLIO_stat(name, &pmstat) < 0 ||
	        pmstat.st_mtime < pmcstat.st_mtime)
	    {
		fp = check_type_and_open(pmc, mode);
	    }
	    else {
		fp = check_type_and_open(name, mode);
	    }
d3045 1
a3045 1
	fp = check_type_and_open(name, mode);
d3048 1
d3050 1
a3050 1
    return check_type_and_open(name, mode);
a3051 1
}
d3055 1
a3055 1
    dSP;
d3060 7
a3066 3
    const char *tryname = Nullch;
    SV *namesv = Nullsv;
    SV** svp;
a3067 1
    PerlIO *tryrsfp = 0;
d3069 5
a3073 4
    GV *filter_child_proc = 0;
    SV *filter_state = 0;
    SV *filter_sub = 0;
    SV *hook_sv = 0;
d3078 16
a3093 27
    if (SvNIOKp(sv) && PL_op->op_type != OP_DOFILE) {
	if (SvPOK(sv) && SvNOK(sv) && SvNV(sv)) {		/* require v5.6.1 */
	    UV rev = 0, ver = 0, sver = 0;
	    STRLEN len;
	    U8 *s = (U8*)SvPVX(sv);
	    U8 *end = (U8*)SvPVX(sv) + SvCUR(sv);
	    if (s < end) {
		rev = utf8n_to_uvchr(s, end - s, &len, 0);
		s += len;
		if (s < end) {
		    ver = utf8n_to_uvchr(s, end - s, &len, 0);
		    s += len;
		    if (s < end)
			sver = utf8n_to_uvchr(s, end - s, &len, 0);
		}
	    }
	    if (PERL_REVISION < rev
		|| (PERL_REVISION == rev
		    && (PERL_VERSION < ver
			|| (PERL_VERSION == ver
			    && PERL_SUBVERSION < sver))))
	    {
		DIE(aTHX_ "Perl v%"UVuf".%"UVuf".%"UVuf" required--this is only "
		    "v%d.%d.%d, stopped", rev, ver, sver, PERL_REVISION,
		    PERL_VERSION, PERL_SUBVERSION);
	    }
	    RETPUSHYES;
d3095 19
a3113 19
	else if (!SvPOKp(sv)) {			/* require 5.005_03 */
	    if ((NV)PERL_REVISION + ((NV)PERL_VERSION/(NV)1000)
		+ ((NV)PERL_SUBVERSION/(NV)1000000)
		+ 0.00000099 < SvNV(sv))
	    {
		NV nrev = SvNV(sv);
		UV rev = (UV)nrev;
		NV nver = (nrev - rev) * 1000;
		UV ver = (UV)(nver + 0.0009);
		NV nsver = (nver - ver) * 1000;
		UV sver = (UV)(nsver + 0.0009);

		/* help out with the "use 5.6" confusion */
		if (sver == 0 && (rev > 5 || (rev == 5 && ver >= 100))) {
		    DIE(aTHX_ "Perl v%"UVuf".%"UVuf".%"UVuf" required"
			" (did you mean v%"UVuf".%03"UVuf"?)--"
			"this is only v%d.%d.%d, stopped",
			rev, ver, sver, rev, ver/100,
			PERL_REVISION, PERL_VERSION, PERL_SUBVERSION);
d3115 17
a3131 5
		else {
		    DIE(aTHX_ "Perl v%"UVuf".%"UVuf".%"UVuf" required--"
			"this is only v%d.%d.%d, stopped",
			rev, ver, sver, PERL_REVISION, PERL_VERSION,
			PERL_SUBVERSION);
a3133 1
	    RETPUSHYES;
d3135 26
d3166 33
a3198 4
    if (PL_op->op_type == OP_REQUIRE &&
      (svp = hv_fetch(GvHVn(PL_incgv), name, len, 0)) &&
      *svp != &PL_sv_undef)
	RETPUSHYES;
d3204 1
a3204 1
	tryrsfp = doopen_pm(name,PERL_SCRIPT_MODE);
d3213 1
a3213 1
	    tryrsfp = doopen_pm(newname,PERL_SCRIPT_MODE);
d3221 1
a3221 2
	char *unixname;
	if ((unixname = tounixspec((char *)name, Nullch)) != Nullch)
d3224 2
a3225 1
	    namesv = NEWSV(806, 0);
d3227 1
a3227 1
		SV *dirsv = *av_fetch(ar, i, TRUE);
d3229 2
d3233 1
d3245 1
a3245 1
		    tryrsfp = 0;
d3261 5
d3273 10
d3288 1
a3288 1
			    IO *io = GvIO((GV *)arg);
d3294 2
a3295 16
				if (IoTYPE(io) == IoTYPE_PIPE) {
				    /* reading from a child process doesn't
				       nest -- when returning from reading
				       the inner module, the outer one is
				       unreadable (closed?)  I've tried to
				       save the gv to manage the lifespan of
				       the pipe, but this didn't help. XXX */
				    filter_child_proc = (GV *)arg;
				    (void)SvREFCNT_inc(filter_child_proc);
				}
				else {
				    if (IoOFP(io) && IoOFP(io) != IoIFP(io)) {
					PerlIO_close(IoOFP(io));
				    }
				    IoIFP(io) = Nullfp;
				    IoOFP(io) = Nullfp;
d3297 2
d3308 1
a3308 1
			    (void)SvREFCNT_inc(filter_sub);
d3312 1
a3312 1
				(void)SvREFCNT_inc(filter_state);
d3314 1
d3316 3
a3318 4
			    if (tryrsfp == 0) {
				tryrsfp = PerlIO_open("/dev/null",
						      PERL_SCRIPT_MODE);
			    }
d3333 3
a3335 3
		    if (filter_child_proc) {
			SvREFCNT_dec(filter_child_proc);
			filter_child_proc = 0;
d3339 1
a3339 1
			filter_state = 0;
d3343 1
a3343 1
			filter_sub = 0;
d3355 10
a3364 1
		    const char *dir = SvPVx_nolen_const(dirsv);
d3374 1
a3374 1
		    if ((unixdir = tounixpath((char *)dir, Nullch)) == Nullch)
d3379 1
a3379 1
#    ifdef SYMBIAN
d3392 20
a3411 1
		    Perl_sv_setpvf(aTHX_ namesv, "%s/%s", dir, name);
d3417 1
a3417 1
		    tryrsfp = doopen_pm(tryname, PERL_SCRIPT_MODE);
d3423 3
d3438 3
a3440 3
		SV * const msg = sv_2mortal(newSVpv(msgstr,0));
		sv_catpv(msg, ":  "); 
		sv_catpv(msg, Strerror(errno));
a3443 2
		    SV * const msg = sv_2mortal(newSVpv(msgstr,0));
		    SV * const dirmsgsv = NEWSV(0, 0);
d3446 9
a3454 6
		    sv_catpvn(msg, " in @@INC", 8);
		    if (instr(SvPVX_const(msg), ".h "))
		        sv_catpv(msg, " (change .h to .ph maybe?)");
		    if (instr(SvPVX_const(msg), ".ph "))
		        sv_catpv(msg, " (did you run h2ph?)");
		    sv_catpv(msg, " (@@INC contains:");
d3456 2
a3457 3
		        const char *dir = SvPVx_nolen_const(*av_fetch(ar, i, TRUE));
		        Perl_sv_setpvf(aTHX_ dirmsgsv, " %s", dir);
		        sv_catsv(msg, dirmsgsv);
d3459 1
a3459 2
		    sv_catpvn(msg, ")", 1);
		    SvREFCNT_dec(dirmsgsv);
d3472 1
a3472 1
    len = strlen(name);
d3475 2
a3476 1
	(void)hv_store(GvHVn(PL_incgv), name, len, newSVpv(CopFILE(&PL_compiling),0),0);
d3478 1
a3478 1
	SV** const svp = hv_fetch(GvHVn(PL_incgv), name, len, 0);
d3480 2
a3481 1
	    (void)hv_store(GvHVn(PL_incgv), name, len, SvREFCNT_inc(hook_sv), 0 );
d3486 1
a3486 3
    lex_start(sv_2mortal(newSVpvn("",0)));
    SAVEGENERICSV(PL_rsfp_filters);
    PL_rsfp_filters = Nullav;
a3487 1
    PL_rsfp = tryrsfp;
d3490 1
a3490 1
    SAVESPTR(PL_compiling.cop_warnings);
a3494 2
    else if (PL_taint_warn)
        PL_compiling.cop_warnings = newSVpvn(WARN_TAINTstring, WARNsize);
a3496 2
    SAVESPTR(PL_compiling.cop_io);
    PL_compiling.cop_io = Nullsv;
d3498 2
a3499 2
    if (filter_sub || filter_child_proc) {
	SV * const datasv = filter_add(run_user_filter, Nullsv);
a3500 1
	IoFMT_GV(datasv) = (GV *)filter_child_proc;
d3503 1
a3506 1
    push_return(PL_op->op_next);
d3508 2
a3509 1
    PUSHEVAL(cx, name, Nullgv);
a3514 8
#ifdef USE_5005THREADS
    MUTEX_LOCK(&PL_eval_mutex);
    if (PL_eval_owner && PL_eval_owner != thr)
	while (PL_eval_owner)
	    COND_WAIT(&PL_eval_cond, &PL_eval_mutex);
    PL_eval_owner = thr;
    MUTEX_UNLOCK(&PL_eval_mutex);
#endif /* USE_5005THREADS */
d3518 1
a3518 1
    PL_encoding = Nullsv;
d3520 4
a3523 1
    op = DOCATCH(doeval(gimme, NULL, Nullcv, PL_curcop->cop_seq));
a3530 5
PP(pp_dofile)
{
    return pp_require();
}

d3533 1
a3533 1
    dSP;
d3535 1
a3535 1
    dPOPss;
d3542 1
a3542 1
    OP *ret;
d3545 8
d3554 1
a3554 2
    if (!SvPV_const(sv,len))
	RETPUSHUNDEF;
d3558 1
a3558 1
    lex_start(sv);
d3564 2
a3565 2
	SV * const sv = sv_newmortal();
	Perl_sv_setpvf(aTHX_ sv, "_<(eval %lu)[%s:%"IVdf"]",
d3568 2
a3569 1
	tmpbuf = SvPVX(sv);
d3572 1
a3572 1
	sprintf(tmpbuf, "_<(eval %lu)", (unsigned long)++PL_evalseq);
d3582 2
a3583 2
    safestr = savepv(tmpbuf);
    SAVEDELETE(PL_defstash, safestr, strlen(safestr));
d3586 12
a3597 13
    SAVESPTR(PL_compiling.cop_warnings);
    if (specialWARN(PL_curcop->cop_warnings))
        PL_compiling.cop_warnings = PL_curcop->cop_warnings;
    else {
        PL_compiling.cop_warnings = newSVsv(PL_curcop->cop_warnings);
        SAVEFREESV(PL_compiling.cop_warnings);
    }
    SAVESPTR(PL_compiling.cop_io);
    if (specialCopIO(PL_curcop->cop_io))
        PL_compiling.cop_io = PL_curcop->cop_io;
    else {
        PL_compiling.cop_io = newSVsv(PL_curcop->cop_io);
        SAVEFREESV(PL_compiling.cop_io);
a3605 1
    push_return(PL_op->op_next);
d3607 2
a3608 1
    PUSHEVAL(cx, 0, Nullgv);
d3613 1
a3613 1
	save_lines(CopFILEAV(&PL_compiling), PL_linestr);
d3615 1
a3615 9
#ifdef USE_5005THREADS
    MUTEX_LOCK(&PL_eval_mutex);
    if (PL_eval_owner && PL_eval_owner != thr)
	while (PL_eval_owner)
	    COND_WAIT(&PL_eval_cond, &PL_eval_mutex);
    PL_eval_owner = thr;
    MUTEX_UNLOCK(&PL_eval_mutex);
#endif /* USE_5005THREADS */
    ret = doeval(gimme, NULL, runcv, seq);
d3617 3
a3619 2
	&& ret != PL_op->op_next) {	/* Successive compilation. */
	strcpy(safestr, "_<(eval )");	/* Anything fake and short. */
d3621 1
a3621 1
    return DOCATCH(ret);
d3626 1
a3626 1
    dSP;
d3638 1
a3638 1
    retop = pop_return();
d3680 1
a3680 1
	retop = Perl_die(aTHX_ "%"SVf" did not return a true value", nsv);
d3692 4
a3695 1
PP(pp_entertry)
d3697 3
a3699 1
    dSP;
d3701 17
d3719 1
a3719 1

d3723 1
a3723 2
    push_return(cLOGOP->op_other->op_next);
    PUSHBLOCK(cx, (CXt_EVAL|CXp_TRYBLOCK), SP);
d3727 15
a3741 2
    sv_setpvn(ERRSV,"",0);
    PUTBACK;
d3747 1
a3747 2
    dSP;
    register SV **mark;
a3749 1
    OP* retop;
a3755 1
    retop = pop_return();
d3762 1
d3778 1
d3790 566
a4355 1
    RETURNOP(retop);
d4363 2
a4364 2
    register char *send = s + len;
    register char *base = Nullch;
d4371 1
a4371 1
    U32 *linepc = 0;
d4386 1
a4386 1
    base = Nullch;
d4567 1
a4567 1
    sv_magic(sv, Nullsv, PERL_MAGIC_fm, Nullch, 0);
d4604 1
a4604 1
run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)
d4606 2
a4607 1
    SV *datasv = FILTER_DATA(idx);
d4609 12
a4620 4
    GV *filter_child_proc = (GV *)IoFMT_GV(datasv);
    SV *filter_state = (SV *)IoTOP_GV(datasv);
    SV *filter_sub = (SV *)IoBOTTOM_GV(datasv);
    int len = 0;
d4624 1
a4624 1
       for PL_error_count == 0.)  Solaris doesn't segfault --
d4627 47
d4675 1
a4675 1
	len = FILTER_READ(idx+1, buf_sv, maxlen);
d4678 1
a4678 1
    if (filter_sub && len >= 0) {
d4687 1
a4687 1
	DEFSV = buf_sv;
d4689 1
a4689 1
	PUSHs(sv_2mortal(newSViv(maxlen)));
d4700 1
a4700 1
		len = SvIV(out);
d4709 50
a4758 1
    if (len <= 0) {
d4760 1
a4760 4
	if (filter_child_proc) {
	    SvREFCNT_dec(filter_child_proc);
	    IoFMT_GV(datasv) = Nullgv;
	}
d4763 1
a4763 1
	    IoTOP_GV(datasv) = Nullgv;
d4767 1
a4767 1
	    IoBOTTOM_GV(datasv) = Nullgv;
d4769 1
a4769 1
	filter_del(run_user_filter);
d4771 7
a4777 2

    return len;
d4783 1
a4783 1
S_path_is_absolute(pTHX_ const char *name)
d4787 1
a4787 1
	|| (*name == ':'))
d4790 1
a4790 1
			     (name[1] == '.' && name[2] == '/'))))
d4792 1
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a80 1
    register char *t;
a81 1
    STRLEN len;
d83 1
a83 1
    
d98 1
a98 1
	regexp *re = (regexp *)mg->mg_obj;
d103 2
a104 1
	t = SvPV(tmpstr, len);
d126 1
a126 1
	    PM_SETRE(pm, CALLREGCOMP(aTHX_ t, t + len, pm));
a163 1
    register PMOP *pm = (PMOP*) cLOGOP->op_other;
d165 2
a166 1
    register SV *dstr = cx->sb_dstr;
d170 1
a170 1
    register REGEXP *rx = cx->sb_rx;
d174 1
a174 1
	if(old) 
d180 1
a180 1
    RX_MATCH_UTF8_set(rx, SvUTF8(cx->sb_targ));
d183 1
a183 1
	I32 saviters = cx->sb_iters;
d198 1
a198 1
	    SV *targ = cx->sb_targ;
d209 2
a210 4
	    SvOOK_off(targ);
	    if (SvLEN(targ))
		Safefree(SvPVX(targ));
	    SvPVX(targ) = SvPVX(dstr);
d215 1
a215 1
	    SvPVX(dstr) = 0;
d242 1
a242 1
	if (DO_UTF8(dstr) && !SvUTF8(cx->sb_targ)) 
d249 1
a249 1
	SV *sv = cx->sb_targ;
d264 1
a264 1
	ReREFCNT_inc(rx);
d279 1
a279 1
	    New(501, p, i, UV);
d322 1
a322 1
    UV *p = (UV*)*rsp;
d325 6
d332 1
d341 1
a341 1
    register SV *tmpForm = *++MARK;
d344 1
a344 3
    register char *f;
    register char *s;
    register char *send;
d347 1
a347 1
    char *item = Nullch;
d352 1
a352 1
    char *chophere = Nullch;
d357 1
a357 1
    STRLEN fudge = SvPOK(tmpForm)
d363 1
a363 1
    char *fmt;
d382 1
a382 1
    f = SvPV(tmpForm, len);
d384 1
a384 3
    s = f + len + WORD_ALIGN - SvCUR(tmpForm) % WORD_ALIGN;

    fpc = (U32*)s;
d388 1
a388 1
	    char *name = "???";
d408 1
a408 1
            case FF_0DECIMAL:	name = "0DECIMAL";	break;
d426 1
a426 1
		SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
d433 1
a433 1
		SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
d463 27
a489 10
	    item = s = SvPV(sv, len);
	    itemsize = len;
	    if (DO_UTF8(sv)) {
		itemsize = sv_len_utf8(sv);
		if (itemsize != (I32)len) {
		    I32 itembytes;
		    if (itemsize > fieldsize) {
			itemsize = fieldsize;
			itembytes = itemsize;
			sv_pos_u2b(sv, &itembytes, 0);
a490 14
		    else
			itembytes = len;
		    send = chophere = s + itembytes;
		    while (s < send) {
			if (*s & ~31)
			    gotsome = TRUE;
			else if (*s == '\n')
			    break;
			s++;
		    }
		    item_is_utf8 = TRUE;
		    itemsize = s - item;
		    sv_pos_b2u(sv, &itemsize);
		    break;
d492 13
a505 13
	    item_is_utf8 = FALSE;
	    if (itemsize > fieldsize)
		itemsize = fieldsize;
	    send = chophere = s + itemsize;
	    while (s < send) {
		if (*s & ~31)
		    gotsome = TRUE;
		else if (*s == '\n')
		    break;
		s++;
	    }
	    itemsize = s - item;
	    break;
d508 12
a519 26
	    item = s = SvPV(sv, len);
	    itemsize = len;
	    if (DO_UTF8(sv)) {
		itemsize = sv_len_utf8(sv);
		if (itemsize != (I32)len) {
		    I32 itembytes;
		    if (itemsize <= fieldsize) {
			send = chophere = s + itemsize;
			while (s < send) {
			    if (*s == '\r') {
				itemsize = s - item;
				chophere = s;
				break;
			    }
			    if (*s++ & ~31)
				gotsome = TRUE;
			}
		    }
		    else {
			itemsize = fieldsize;
			itembytes = itemsize;
			sv_pos_u2b(sv, &itembytes, 0);
			send = chophere = s + itembytes;
			while (s < send || (s == send && isSPACE(*s))) {
			    if (isSPACE(*s)) {
				if (chopspace)
a520 1
				if (*s == '\r')
d522 3
d526 21
a546 5
			    else {
				if (*s & ~31)
				    gotsome = TRUE;
				if (strchr(PL_chopset, *s))
				    chophere = s + 1;
d548 2
a549 1
			    s++;
d551 1
a551 14
			itemsize = chophere - item;
			sv_pos_b2u(sv, &itemsize);
		    }
		    item_is_utf8 = TRUE;
		    break;
		}
	    }
	    item_is_utf8 = FALSE;
	    if (itemsize <= fieldsize) {
		send = chophere = s + itemsize;
		while (s < send) {
		    if (*s == '\r') {
			itemsize = s - item;
			chophere = s;
a553 2
		    if (*s++ & ~31)
			gotsome = TRUE;
d555 6
a560 7
	    }
	    else {
		itemsize = fieldsize;
		send = chophere = s + itemsize;
		while (s < send || (s == send && isSPACE(*s))) {
		    if (isSPACE(*s)) {
			if (chopspace)
a561 1
			if (*s == '\r')
d563 3
d567 19
a585 5
		    else {
			if (*s & ~31)
			    gotsome = TRUE;
			if (strchr(PL_chopset, *s))
			    chophere = s + 1;
d587 1
a587 1
		    s++;
d589 1
a589 1
		itemsize = chophere - item;
a590 1
	    break;
d612 33
a644 27
	    arg = itemsize;
	    s = item;
	    if (item_is_utf8) {
		if (!targ_is_utf8) {
		    SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
		    *t = '\0';
		    sv_utf8_upgrade(PL_formtarget);
		    SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
		    t = SvEND(PL_formtarget);
		    targ_is_utf8 = TRUE;
		}
		while (arg--) {
		    if (UTF8_IS_CONTINUED(*s)) {
			STRLEN skip = UTF8SKIP(s);
			switch (skip) {
			default:
			    Move(s,t,skip,char);
			    s += skip;
			    t += skip;
			    break;
			case 7: *t++ = *s++;
			case 6: *t++ = *s++;
			case 5: *t++ = *s++;
			case 4: *t++ = *s++;
			case 3: *t++ = *s++;
			case 2: *t++ = *s++;
			case 1: *t++ = *s++;
d647 14
a660 3
		    else {
			if ( !((*t++ = *s++) & ~31) )
			    t[-1] = ' ';
d662 1
d664 1
a664 7
		break;
	    }
	    if (targ_is_utf8 && !item_is_utf8) {
		SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
		*t = '\0';
		sv_catpvn_utf8_upgrade(PL_formtarget, s, arg, nsv);
		for (; t < SvEND(PL_formtarget); t++) {
d666 1
a666 1
		    int ch = *t;
d669 1
a669 1
		    if (!(*t & ~31))
d671 1
a671 1
			*t = ' ';
a674 10
	    while (arg--) {
#ifdef EBCDIC
		int ch = *t++ = *s++;
		if (iscntrl(ch))
#else
		if ( !((*t++ = *s++) & ~31) )
#endif
		    t[-1] = ' ';
	    }
	    break;
d677 9
a685 4
	    s = chophere;
	    if (chopspace) {
		while (*s && isSPACE(*s))
		    s++;
a686 3
	    sv_chop(sv,s);
	    SvSETMAGIC(sv);
	    break;
d695 23
a717 21
	    item = s = SvPV(sv, len);
	    itemsize = len;
	    if ((item_is_utf8 = DO_UTF8(sv)))
		itemsize = sv_len_utf8(sv);	    
	    if (itemsize) {
		bool chopped = FALSE;
		gotsome = TRUE;
		send = s + len;
		chophere = s + itemsize;
		while (s < send) {
		    if (*s++ == '\n') {
		        if (oneline) {
			    chopped = TRUE;
			    chophere = s;
			    break;
			} else {
			    if (s == send) {
			        itemsize--;
			        chopped = TRUE;
			    } else
			        lines++;
d720 15
d736 1
a736 15
		SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
		if (targ_is_utf8)
		    SvUTF8_on(PL_formtarget);
		if (oneline) {
		    SvCUR_set(sv, chophere - item);
		    sv_catsv(PL_formtarget, sv);
		    SvCUR_set(sv, itemsize);
		} else
		    sv_catsv(PL_formtarget, sv);
		if (chopped)
		    SvCUR_set(PL_formtarget, SvCUR(PL_formtarget) - 1);
		SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
		t = SvPVX(PL_formtarget) + SvCUR(PL_formtarget);
		if (item_is_utf8)
		    targ_is_utf8 = TRUE;
a737 1
	    break;
d766 1
a766 1
	    if (num_overflow(value, fieldsize, arg)) { 
d793 1
a793 1
		    SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
d814 25
a838 5
	    s = chophere;
	    send = item + len;
	    if (chopspace) {
		while (*s && isSPACE(*s) && s < send)
		    s++;
a839 18
	    if (s < send) {
		arg = fieldsize - itemsize;
		if (arg) {
		    fieldsize -= arg;
		    while (arg-- > 0)
			*t++ = ' ';
		}
		s = t - 3;
		if (strnEQ(s,"   ",3)) {
		    while (s > SvPVX(PL_formtarget) && isSPACE(s[-1]))
			s--;
		}
		*s++ = '.';
		*s++ = '.';
		*s++ = '.';
	    }
	    break;

d842 1
a842 1
	    SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
d892 1
a892 1
    I32 gimme = GIMME_V;
d929 1
a929 1
	
d944 1
a944 1
	else { 
d1009 2
a1010 2
	SV *targ = PAD_SV(PL_op->op_targ);
 	int flip = 0;
d1012 1
a1012 1
 	if (PL_op->op_private & OPpFLIP_LINENUM) {
d1017 3
a1019 2
		GV *gv = gv_fetchpv(".", TRUE, SVt_PV);
		if (gv && GvSV(gv)) flip = SvIV(sv) == SvIV(GvSV(gv));
d1021 4
a1024 4
 	} else {
 	    flip = SvTRUE(sv);
 	}
 	if (flip) {
d1037 1
a1037 1
	sv_setpv(TARG, "");
d1051 1
a1051 1
          looks_like_number(left)) && SvPOKp(left) && *SvPVX(left) != '0')) \
a1059 3
	register IV i, j;
	register SV *sv;
	IV max;
d1067 2
d1082 1
a1082 1
		sv = sv_2mortal(newSViv(i++));
d1087 3
a1089 3
	    SV *final = sv_mortalcopy(right);
	    STRLEN len, n_a;
	    char *tmps = SvPV(final, len);
d1091 2
a1092 2
	    sv = sv_mortalcopy(left);
	    SvPV_force(sv,n_a);
d1095 1
a1095 1
	        if (strEQ(SvPVX(sv),tmps))
d1104 1
a1104 1
	SV *targ = PAD_SV(cUNOP->op_first->op_targ);
d1113 1
a1113 1
		GV *gv = gv_fetchpv(".", TRUE, SVt_PV);
d1123 1
a1123 1
	    sv_catpv(targ, "E0");
d1133 1
a1133 1
static char *context_name[] = {
d1144 1
a1144 1
S_dopoptolabel(pTHX_ char *label)
a1146 1
    register PERL_CONTEXT *cx;
d1149 1
a1149 1
	cx = &cxstack[i];
d1163 1
a1163 2
	    if (!cx->blk_loop.label ||
	      strNE(label, cx->blk_loop.label) ) {
d1178 1
a1178 1
    I32 gimme = block_gimme();
d1185 1
a1185 3
    I32 cxix;

    cxix = dopoptosub(cxstack_ix);
d1206 1
a1206 3
    I32 cxix;

    cxix = dopoptosub(cxstack_ix);
d1222 1
a1222 1
S_dopoptosub_at(pTHX_ PERL_CONTEXT *cxstk, I32 startingblock)
a1224 1
    register PERL_CONTEXT *cx;
d1226 1
a1226 1
	cx = &cxstk[i];
a1243 1
    register PERL_CONTEXT *cx;
d1245 1
a1245 1
	cx = &cxstack[i];
a1260 1
    register PERL_CONTEXT *cx;
d1262 1
a1262 1
	cx = &cxstack[i];
a1285 1
    register PERL_CONTEXT *cx;
d1290 1
a1290 1
	cx = &cxstack[cxstack_ix];
d1316 1
a1333 2
    STRLEN n_a;

a1335 1
	register PERL_CONTEXT *cx;
a1336 1
	SV **newsp;
d1340 3
a1342 3
		static char prefix[] = "\t(in cleanup) ";
		SV *err = ERRSV;
		char *e = Nullch;
d1344 1
a1344 1
		    sv_setpv(err,"");
d1346 3
a1348 2
		    e = SvPV(err, n_a);
		    e += n_a - msglen;
d1357 2
a1358 2
			STRLEN start = SvCUR(err)-msglen-sizeof(prefix)+1;
			Perl_warner(aTHX_ packWARN(WARN_MISC), SvPVX(err)+start);
d1376 2
d1385 1
a1385 1
		    message = SvPVx(ERRSV, msglen);
d1405 1
a1405 1
		char* msg = SvPVx(ERRSV, n_a);
d1413 1
a1413 1
	message = SvPVx(ERRSV, msglen);
d1452 3
a1454 4
    register PERL_CONTEXT *cx;
    register PERL_CONTEXT *ccstack = cxstack;
    PERL_SI *top_si = PL_curstackinfo;
    I32 dbcxix;
d1456 1
a1456 2
    char *stashname;
    SV *sv;
d1476 2
a1477 1
	if (PL_DBsub && cxix >= 0 &&
d1487 1
a1487 1
        dbcxix = dopoptosub_at(ccstack, cxix - 1);
d1490 2
a1491 1
	if (PL_DBsub && dbcxix >= 0 && ccstack[dbcxix].blk_sub.cv == GvCV(PL_DBsub))
d1522 1
a1522 1
	    sv = NEWSV(49, 0);
d1565 2
a1566 2
	AV *ary = cx->blk_sub.argarray;
	int off = AvARRAY(ary) - AvALLOC(ary);
d1594 12
a1605 2
		  (old_warnings == pWARN_STD && PL_dowarn & G_WARN_ON))
            mask = newSVpvn(WARN_ALLstring, WARNsize) ;
d1616 1
a1616 2
    char *tmps;
    STRLEN n_a;
d1621 2
a1622 2
	tmps = POPpx;
    sv_reset(tmps, CopSTASH(PL_curcop));
d1647 1
a1647 1
	I32 gimme = G_ARRAY;
d1669 18
a1686 6
	push_return(PL_op->op_next);
	PUSHBLOCK(cx, CXt_SUB, SP);
	PUSHSUB_DB(cx);
	CvDEPTH(cv)++;
	PAD_SET_CUR(CvPADLIST(cv),1);
	RETURNOP(CvSTART(cv));
d1701 1
a1701 1
    I32 gimme = GIMME_V;
d1752 2
d1760 4
a1765 1
		STRLEN n_a;
d1767 2
a1768 2
		(void) SvPV_force(cx->blk_loop.iterlval,n_a);
		(void) SvPV(right,n_a);
d1772 2
a1773 2
	    cx->blk_loop.itermax = -1;
	    cx->blk_loop.iterix = AvFILL(cx->blk_loop.iterary);
d1781 2
a1782 2
	    cx->blk_loop.itermax = MARK - PL_stack_base;
	    cx->blk_loop.iterix = cx->blk_oldsp;
d1796 1
a1796 1
    I32 gimme = GIMME_V;
d1818 1
d1897 2
a1898 2
	    SV *nsv = cx->blk_eval.old_namesv;
	    (void)hv_delete(GvHVn(PL_incgv), SvPVX(nsv), SvCUR(nsv), G_DISCARD);
d1956 1
a1956 1
	sv_setpv(ERRSV,"");
d1974 1
d2046 2
d2076 1
d2103 1
d2108 1
a2108 1
S_dofindlabel(pTHX_ OP *o, char *label, OP **opstack, OP **oplimit)
a2109 1
    OP *kid = Nullop;
d2111 1
a2111 1
    static char too_deep[] = "Target of goto is too deeply nested";
d2127 1
d2168 3
a2170 3
    char *label;
    int do_dump = (PL_op->op_type == OP_DUMP);
    static char must_have_label[] = "goto must have label";
a2171 1
    label = 0;
d2173 1
a2173 2
	SV *sv = POPs;
	STRLEN n_a;
d2187 1
a2187 2
		GV *gv = CvGV(cv);
		GV *autogv;
d2189 1
d2199 1
a2199 1
		    gv_efullname3(tmpstr, gv, Nullch);
d2206 1
a2206 1
	    SvREFCNT_inc(cv); /* avoid premature free during unwind */
d2214 7
a2220 2
	    if (CxREALEVAL(cx))
		DIE(aTHX_ "Can't goto subroutine from an eval-string");
d2224 1
a2224 1
		
a2243 1
		AV* av;
d2245 1
a2245 1
		av = (AV*)PAD_SVl(0);
d2247 1
a2247 1
		av = GvAV(PL_defgv);
d2293 1
d2297 4
d2338 2
a2339 1
		PAD_SET_CUR(padlist, CvDEPTH(cv));
d2358 1
a2358 1
			    SvPVX(av) = (char*)ary;
d2364 1
a2364 1
			    SvPVX(av) = (char*)ary;
d2387 1
a2387 1
		    SV *sv = GvSV(PL_DBsub);
d2389 2
a2390 1
		
d2392 3
a2394 1
			(void)SvUPGRADE(sv, SVt_PVIV);
d2396 1
a2396 2
			SAVEIV(SvIVX(sv));
			SvIVX(sv) = PTR2IV(cv); /* Do it the quickest way */
a2397 1
			save_item(sv);
d2411 1
a2411 1
	    label = SvPV(sv,n_a);
d2566 1
a2566 1
    NV value = SvNVx(GvSV(cCOP->cop_gv));
d2590 1
a2590 2
	STRLEN n_a;
	match = *(SvPVx(GvSV(cCOP->cop_gv), n_a)) & 255;
d2607 3
a2609 4
    register char *s = SvPVX(sv);
    register char *send = SvPVX(sv) + SvCUR(sv);
    register char *t;
    register I32 line = 1;
d2612 2
a2613 1
	SV *tmpstr = NEWSV(85,0);
d2636 1
a2636 1
STATIC void *
d2640 1
a2640 1
    return NULL;
d2647 1
a2647 1
    OP *oldop = PL_op;
d2709 1
a2709 1
    I32 gimme = 0;   /* SUSPECT - INITIALZE TO WHAT?  NI-S */
d2729 1
a2729 1
	SV *sv = sv_newmortal();
d2784 3
d2798 1
a2798 1
than in in the scope of the debugger itself).
a2805 1
    I32		 ix;
a2806 1
    PERL_CONTEXT *cx;
d2811 1
d2813 1
a2813 1
	    cx = &(si->si_cxstack[ix]);
d2815 1
a2815 1
		CV *cv = cx->blk_sub.cv;
d2842 1
a2842 1
    OP *saveop = PL_op;
d2893 1
a2893 1
	sv_setpv(ERRSV,"");
d2898 2
a2899 2
	STRLEN n_a;
	
d2913 2
d2916 1
a2916 1
	    char* msg = SvPVx(ERRSV, n_a);
a2920 2
	    char* msg = SvPVx(ERRSV, n_a);

a2926 1
	    char* msg = SvPVx(ERRSV, n_a);
d2937 1
d2965 1
a2965 1
	CV *cv = get_cv("DB::postponed", FALSE);
d2992 17
d3012 1
a3012 1
    STRLEN namelen = strlen(name);
d3016 2
a3017 3
	SV *pmcsv = Perl_newSVpvf(aTHX_ "%s%c", name, 'c');
	char *pmc = SvPV_nolen(pmcsv);
	Stat_t pmstat;
d3020 1
a3020 1
	    fp = PerlIO_open(name, mode);
d3023 1
d3027 1
a3027 1
		fp = PerlIO_open(pmc, mode);
d3030 1
a3030 1
		fp = PerlIO_open(name, mode);
d3036 1
a3036 1
	fp = PerlIO_open(name, mode);
d3040 1
a3040 1
    return PerlIO_open(name, mode);
d3049 1
a3049 1
    char *name;
d3051 1
a3051 1
    char *tryname = Nullch;
d3054 1
a3054 1
    I32 gimme = GIMME_V;
a3055 1
    STRLEN n_a;
d3123 1
a3123 1
    name = SvPV(sv, len);
d3150 1
a3150 1
	AV *ar = GvAVn(PL_incgv);
d3154 1
a3154 1
	if ((unixname = tounixspec(name, Nullch)) != Nullch)
d3173 1
a3173 1
		    tryname = SvPVX(namesv);
d3281 1
a3281 1
		    char *dir = SvPVx(dirsv, n_a);
d3289 1
a3289 1
#ifdef VMS
d3291 1
a3291 1
		    if ((unixdir = tounixpath(dir, Nullch)) == Nullch)
d3295 14
a3308 1
#else
d3310 2
a3311 1
#endif
d3314 1
a3314 1
		    tryname = SvPVX(namesv);
d3331 27
a3357 20
	    char *msgstr = name;
	    if (namesv) {			/* did we lookup @@INC? */
		SV *msg = sv_2mortal(newSVpv(msgstr,0));
		SV *dirmsgsv = NEWSV(0, 0);
		AV *ar = GvAVn(PL_incgv);
		I32 i;
		sv_catpvn(msg, " in @@INC", 8);
		if (instr(SvPVX(msg), ".h "))
		    sv_catpv(msg, " (change .h to .ph maybe?)");
		if (instr(SvPVX(msg), ".ph "))
		    sv_catpv(msg, " (did you run h2ph?)");
		sv_catpv(msg, " (@@INC contains:");
		for (i = 0; i <= AvFILL(ar); i++) {
		    char *dir = SvPVx(*av_fetch(ar, i, TRUE), n_a);
		    Perl_sv_setpvf(aTHX_ dirmsgsv, " %s", dir);
		    sv_catsv(msg, dirmsgsv);
		}
		sv_catpvn(msg, ")", 1);
		SvREFCNT_dec(dirmsgsv);
		msgstr = SvPV_nolen(msg);
d3370 6
a3375 5
    if (!hook_sv || !(svp = hv_fetch(GvHVn(PL_incgv), name, len, 0))) {
	(void)hv_store(GvHVn(PL_incgv), name, len,
		       (hook_sv ? SvREFCNT_inc(hook_sv)
				: newSVpv(CopFILE(&PL_compiling), 0)),
		       0 );
d3400 1
a3400 1
	SV *datasv = filter_add(run_user_filter, Nullsv);
d3430 1
a3430 1
    
d3447 2
a3448 1
    I32 gimme = GIMME_V, was = PL_sub_generation;
d3457 1
a3457 1
    if (!SvPV(sv,len))
d3468 1
a3468 1
	SV *sv = sv_newmortal();
d3544 1
a3544 1
    U8 save_flags = PL_op -> op_flags;
d3589 2
a3590 2
	SV *nsv = cx->blk_eval.old_namesv;
	(void)hv_delete(GvHVn(PL_incgv), SvPVX(nsv), SvCUR(nsv), G_DISCARD);
d3597 1
a3597 1
	    sv_setpv(ERRSV,"");
d3607 1
a3607 1
    I32 gimme = GIMME_V;
d3617 1
a3617 1
    sv_setpv(ERRSV,"");
d3636 1
d3667 1
a3667 1
    sv_setpv(ERRSV,"");
d3701 1
a3701 1
    New(804, fops, maxops, U32);
d3802 1
a3802 3
		    char *f;
		    s++;
		    f = s;
d3819 1
a3819 3
                    char *f;
                    s++;
                    f = s;
d3883 1
a3883 1
    if (unchopnum && repeat) 
d3920 1
a3920 1
    int filter_has_file = IoLINES(datasv);
d3989 1
a3989 1
S_path_is_absolute(pTHX_ char *name)
d4004 10
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d20 11
d201 7
a207 4
	    if (DO_UTF8(dstr) && !SvUTF8(targ))
		sv_catpvn_utf8_upgrade(dstr, s, cx->sb_strend - s, nsv);
	    else
		sv_catpvn(dstr, s, cx->sb_strend - s);
d210 1
a210 1
	    (void)SvOOK_off(targ);
d355 2
a356 1
    STRLEN fudge = SvCUR(tmpForm) * (IN_BYTES ? 1 : 3) + 1;
d1740 5
d1749 7
a1755 1
	cx->blk_loop.iterix = MARK - PL_stack_base;
a2133 1
    AV *oldav = Nullav;
d2148 1
a2180 1
	    mark = PL_stack_sp;
d2186 2
a2187 4
		PL_stack_sp++;
		EXTEND(PL_stack_sp, items); /* @@_ could have been extended. */
		Copy(AvARRAY(av), PL_stack_sp, items, SV*);
		PL_stack_sp += items;
d2192 1
d2195 2
a2196 1
		    oldav = av;	/* delay until return */
a2201 2
		else
		    CLEAR_ARGARRAY(av);
d2211 2
a2212 4
		PL_stack_sp++;
		EXTEND(PL_stack_sp, items); /* @@_ could have been extended. */
		Copy(AvARRAY(av), PL_stack_sp, items, SV*);
		PL_stack_sp += items;
d2214 2
a2223 3
	    /* For reified @@_, delay freeing till return from new sub */
	    if (oldav)
		SAVEFREESV((SV*)oldav);
d2226 5
a2249 1
		    PL_stack_sp--;		/* There is no cv arg. */
d2252 1
a2307 1
		    ++mark;
d2322 1
d2326 5
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d345 3
d352 1
a352 1
	    doparseform(tmpForm);
d356 3
a358 1
	    doparseform(tmpForm);
d394 1
d501 1
d541 1
d632 1
a632 1
		    int ch = *t++ = *s++;
d662 4
d667 2
d677 1
d680 1
a680 2
			if (s == send) {
			    itemsize--;
d682 8
a690 2
			else
			    lines++;
d696 6
a701 1
		sv_catsv(PL_formtarget, sv);
d711 8
a719 2
	    /* If the field is marked with ^ and the value is undefined,
	       blank it out. */
a720 11
	    if ((arg & 512) && !SvOK(sv)) {
		arg = fieldsize;
		while (arg--)
		    *t++ = ' ';
		break;
	    }
	    gotsome = TRUE;
	    value = SvNV(sv);
	    /* Formats aren't yet marked for locales, so assume "yes". */
	    {
		STORE_NUMERIC_STANDARD_SET_LOCAL();
d722 1
a722 6
		if (arg & 256) {
		    sprintf(t, "%#*.*" PERL_PRIfldbl,
			    (int) fieldsize, (int) arg & 255, value);
		} else {
		    sprintf(t, "%*.0" PERL_PRIfldbl, (int) fieldsize, value);
		}
d724 1
a724 7
		if (arg & 256) {
		    sprintf(t, "%#*.*f",
			    (int) fieldsize, (int) arg & 255, value);
		} else {
		    sprintf(t, "%*.0f",
			    (int) fieldsize, value);
		}
d726 1
a726 6
		RESTORE_NUMERIC_STANDARD();
	    }
	    t += fieldsize;
	    break;

	case FF_0DECIMAL:
a728 1
	    arg = *fpc++;
d737 7
d747 1
a747 17
#if defined(USE_LONG_DOUBLE)
		if (arg & 256) {
		    sprintf(t, "%#0*.*" PERL_PRIfldbl,
			    (int) fieldsize, (int) arg & 255, value);
/* is this legal? I don't have long doubles */
		} else {
		    sprintf(t, "%0*.0" PERL_PRIfldbl, (int) fieldsize, value);
		}
#else
		if (arg & 256) {
		    sprintf(t, "%#0*.*f",
			    (int) fieldsize, (int) arg & 255, value);
		} else {
		    sprintf(t, "%0*.0f",
			    (int) fieldsize, value);
		}
#endif
d752 1
a752 1
	
d910 13
a922 2
	while (items-- > 0)
	    *dst-- = SvTEMP(TOPs) ? POPs : sv_mortalcopy(POPs);
d1019 3
a1021 2
	(looks_like_number(left) && SvPOKp(left) && *SvPVX(left) != '0' && \
	 looks_like_number(right)))
d1029 1
a1029 1
	register I32 i, j;
d1031 1
a1031 1
	I32 max;
d1039 2
a1040 1
	    if (SvNV(left) < IV_MIN || SvNV(right) > IV_MAX)
a1643 1
	(void)SvREFCNT_inc(cv);
d1710 7
a1716 6
	    if (RANGE_IS_NUMERIC(sv,(SV*)cx->blk_loop.iterary)) {
		 if (SvNV(sv) < IV_MIN ||
		     SvNV((SV*)cx->blk_loop.iterary) >= IV_MAX)
		     DIE(aTHX_ "Range iterator outside integer range");
		 cx->blk_loop.iterix = SvIV(sv);
		 cx->blk_loop.itermax = SvIV((SV*)cx->blk_loop.iterary);
d1718 2
a1719 1
	    else
d1721 3
d1826 1
d1886 1
d1889 1
a1895 1
    LEAVE;
d1930 1
d1972 2
a1985 1
    LEAVE;
d2040 1
d2108 1
d2171 1
a2171 1
		    (void)sv_2mortal((SV*)av);	/* delay until return */
d2201 3
d2253 1
a2253 1
		    pad_push(padlist, CvDEPTH(cv), cx->blk_sub.hasargs);
a2678 1
    PL_hints &= HINT_UTF8;
d2720 1
a2720 1
than in in the scope of the debuger itself).
d3554 1
a3554 1
STATIC void
d3570 2
a3571 1
    int maxops = 2; /* FF_LINEMARK + FF_END) */
d3578 1
a3578 1
	if (*s == '\n' || *s == '\0' || *s == '@@' || *s == '^')
d3611 6
a3616 2
	
	case '\n': case 0:
d3672 6
a3677 2
		*fpc++ = 0;
		*fpc++ = FF_LINEGLOB;
d3695 1
d3714 1
d3769 32
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d62 1
d162 2
a163 4

    { 
      REGEXP *old = PM_GETRE(pm);
      if(old != rx) {
d165 1
a165 1
	  ReREFCNT_dec(old);
a166 1
      }
d252 2
a253 1
    ReREFCNT_inc(rx);
d1007 10
d1032 1
a1032 9
	/* This code tries to decide if "$left .. $right" should use the
	   magical string increment, or if the range is numeric (we make
	   an exception for .."0" [#18165]). AMS 20021031. */

	if (SvNIOKp(left) || !SvPOKp(left) ||
	    SvNIOKp(right) || !SvPOKp(right) ||
	    (looks_like_number(left) && *SvPVX(left) != '0' &&
	     looks_like_number(right)))
	{
d1704 1
a1704 6
	    /* See comment in pp_flop() */
	    if (SvNIOKp(sv) || !SvPOKp(sv) ||
		SvNIOKp(cx->blk_loop.iterary) || !SvPOKp(cx->blk_loop.iterary) ||
		(looks_like_number(sv) && *SvPVX(sv) != '0' &&
		 looks_like_number((SV*)cx->blk_loop.iterary)))
	    {
d3558 1
a3558 1
	if (*s == '\n' || *s == '@@' || *s == '^')
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d25 1
a25 1
#define WORD_ALIGN sizeof(U16)
d101 1
a101 1
		ReREFCNT_dec(PM_GETRE(pm));
d160 10
d172 1
a172 1
    PL_reg_match_utf8 = SvUTF8(cx->sb_targ) ? 1 : 0;
d192 4
a195 1
	    sv_catpvn(dstr, s, cx->sb_strend - s);
d199 2
a200 1
	    Safefree(SvPVX(targ));
d210 1
a210 1
	    PUSHs(sv_2mortal(newSViv((I32)cx->sb_iters - 1)));
d218 1
d232 6
a237 2
    if (m > s)
	sv_catpvn(dstr, s, m-s);
d254 1
d325 1
a325 1
    register U16 *fpc;
d343 3
a345 1
    bool item_is_utf = FALSE;
a355 1

d357 2
d365 1
a365 1
    fpc = (U16*)s;
d405 15
d464 1
a464 1
		    item_is_utf = TRUE;
d470 1
a470 1
	    item_is_utf = FALSE;
d525 1
a525 1
		    item_is_utf = TRUE;
d529 1
a529 1
	    item_is_utf = FALSE;
d585 9
a593 1
	    if (item_is_utf) {
d619 15
d652 1
d658 2
a659 1
	    item_is_utf = FALSE;		/* XXX is this correct? */
d661 1
d663 1
a663 1
		send = s + itemsize;
d666 1
a666 1
			if (s == send)
d668 2
d675 5
a679 1
		sv_catpvn(PL_formtarget, item, itemsize);
d682 2
d779 2
d820 2
d869 1
d880 1
a880 1
    if (items) {
d917 1
a917 1
	while (items--)
a923 1
	I32 gimme = GIMME_V;
d1023 4
d1030 1
a1030 1
	     looks_like_number(right) && *SvPVX(right) != '0'))
d1095 10
a1114 4
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting substitution via %s",
			OP_NAME(PL_op));
	    break;
a1115 4
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting subroutine via %s",
			OP_NAME(PL_op));
	    break;
a1116 4
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting format via %s",
			OP_NAME(PL_op));
	    break;
d1118 1
d1120 4
a1123 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting eval via %s",
			OP_NAME(PL_op));
a1124 5
	case CXt_NULL:
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting pseudo-block via %s",
			OP_NAME(PL_op));
	    return -1;
a1235 4
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting substitution via %s",
			OP_NAME(PL_op));
	    break;
a1236 4
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting subroutine via %s",
			OP_NAME(PL_op));
	    break;
a1237 4
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting format via %s",
			OP_NAME(PL_op));
	    break;
d1239 1
d1241 4
a1244 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting eval via %s",
			OP_NAME(PL_op));
a1245 5
	case CXt_NULL:
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting pseudo-block via %s",
			OP_NAME(PL_op));
	    return -1;
a1305 2
    IO *io;
    MAGIC *mg;
a1339 2
	else
	    message = SvPVx(ERRSV, msglen);
d1356 2
d1387 1
a1387 24
    /* if STDERR is tied, print to it instead */
    if (PL_stderrgv && (io = GvIOp(PL_stderrgv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
	dSP; ENTER;
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	XPUSHs(sv_2mortal(newSVpvn(message, msglen)));
	PUTBACK;
	call_method("PRINT", G_SCALAR);
	LEAVE;
    }
    else {
#ifdef USE_SFIO
	/* SFIO can really mess with your errno */
	int e = errno;
#endif
	PerlIO *serr = Perl_error_log;

	PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
	(void)PerlIO_flush(serr);
#ifdef USE_SFIO
	errno = e;
#endif
    }
d1595 2
d1604 2
a1605 1
    if (PL_op->op_private || SvIV(PL_DBsingle) || SvIV(PL_DBsignal) || SvIV(PL_DBtrace))
d1634 1
a1634 1
	PUSHSUB(cx);
d1637 1
a1637 2
	SAVEVPTR(PL_curpad);
	PL_curpad = AvARRAY((AV*)*av_fetch(CvPADLIST(cv),1,FALSE));
d1673 1
a1673 1
	svp = &PL_curpad[PL_op->op_targ];		/* "my" variable */
d1703 1
d1707 1
a1707 2
		 looks_like_number((SV*)cx->blk_loop.iterary) &&
		 *SvPVX(cx->blk_loop.iterary) != '0'))
d1833 1
a1833 1
	    DIE(aTHX_ "%s did not return a true value", SvPVX(nsv));
d2044 1
d2062 9
a2070 5
	    if ((kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) &&
		(ops == opstack ||
		 (ops[-1]->op_type != OP_NEXTSTATE &&
		  ops[-1]->op_type != OP_DBSTATE)))
		*ops++ = kid;
d2126 1
a2126 1
		    DIE(aTHX_ "Goto undefined subroutine &%s",SvPVX(tmpstr));
d2132 2
d2162 1
a2162 1
		    PL_curpad[0] = (SV*)(cx->blk_sub.argarray = av);
d2164 2
d2170 1
a2170 1
		av = (AV*)PL_curpad[0];
d2188 1
a2221 1
		SV** svp = AvARRAY(padlist);
d2230 1
d2234 1
a2234 1
		else {	/* save temporaries on recursion? */
d2237 1
a2237 44
		    if (CvDEPTH(cv) > AvFILLp(padlist)) {
			AV *newpad = newAV();
			SV **oldpad = AvARRAY(svp[CvDEPTH(cv)-1]);
			I32 ix = AvFILLp((AV*)svp[1]);
			I32 names_fill = AvFILLp((AV*)svp[0]);
			svp = AvARRAY(svp[0]);
			for ( ;ix > 0; ix--) {
			    if (names_fill >= ix && svp[ix] != &PL_sv_undef) {
				char *name = SvPVX(svp[ix]);
				if ((SvFLAGS(svp[ix]) & SVf_FAKE)
				    || *name == '&')
				{
				    /* outer lexical or anon code */
				    av_store(newpad, ix,
					SvREFCNT_inc(oldpad[ix]) );
				}
				else {		/* our own lexical */
				    if (*name == '@@')
					av_store(newpad, ix, sv = (SV*)newAV());
				    else if (*name == '%')
					av_store(newpad, ix, sv = (SV*)newHV());
				    else
					av_store(newpad, ix, sv = NEWSV(0,0));
				    SvPADMY_on(sv);
				}
			    }
			    else if (IS_PADGV(oldpad[ix]) || IS_PADCONST(oldpad[ix])) {
				av_store(newpad, ix, sv = SvREFCNT_inc(oldpad[ix]));
			    }
			    else {
				av_store(newpad, ix, sv = NEWSV(0,0));
				SvPADTMP_on(sv);
			    }
			}
			if (cx->blk_sub.hasargs) {
			    AV* av = newAV();
			    av_extend(av, 0);
			    av_store(newpad, 0, (SV*)av);
			    AvFLAGS(av) = AVf_REIFY;
			}
			av_store(padlist, CvDEPTH(cv), (SV*)newpad);
			AvFILLp(padlist) = CvDEPTH(cv);
			svp = AvARRAY(padlist);
		    }
d2241 1
a2241 1
		    AV* av = (AV*)PL_curpad[0];
d2252 2
a2253 3
#endif /* USE_5005THREADS */		
		SAVEVPTR(PL_curpad);
		PL_curpad = AvARRAY((AV*)svp[CvDEPTH(cv)]);
d2258 1
a2258 1
		    AV* av = (AV*)PL_curpad[0];
d2265 1
a2265 1
		    cx->blk_sub.oldcurpad = PL_curpad;
d2300 4
a2303 1
			SvIVX(sv) = PTR2IV(cv); /* Already upgraded, saved */
d2334 1
d2346 1
a2346 1
                if (CxREALEVAL(cx)) {
d2360 1
a2360 1
		if (ix)
d2362 2
a2363 1
		else
d2420 2
a2421 1
	    for (ix = 1; enterops[ix]; ix++) {
d2610 1
a2610 1
Perl_sv_compile_2op(pTHX_ SV *sv, OP** startop, char *code, AV** avp)
d2625 2
d2633 1
a2633 1
    if (PL_curcop == &PL_compiling) {
d2665 5
d2673 1
a2673 1
    PUSHBLOCK(cx, CXt_EVAL|(PL_curcop == &PL_compiling ? 0 : CXp_REAL), SP);
d2675 5
a2679 1
    rop = doeval(G_SCALAR, startop);
d2686 2
a2687 1
    *avp = (AV*)SvREFCNT_inc(PL_comppad);
d2689 1
a2689 1
    if (PL_curcop == &PL_compiling)
d2697 48
d2747 1
a2747 1
S_doeval(pTHX_ int gimme, OP** startop)
a2750 3
    CV *caller;
    AV* comppadlist;
    I32 i;
a2757 21
    /* set up a scratch pad */

    SAVEI32(PL_padix);
    SAVEVPTR(PL_curpad);
    SAVESPTR(PL_comppad);
    SAVESPTR(PL_comppad_name);
    SAVEI32(PL_comppad_name_fill);
    SAVEI32(PL_min_intro_pending);
    SAVEI32(PL_max_intro_pending);

    caller = PL_compcv;
    for (i = cxstack_ix - 1; i >= 0; i--) {
	PERL_CONTEXT *cx = &cxstack[i];
	if (CxTYPE(cx) == CXt_EVAL)
	    break;
	else if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
	    caller = cx->blk_sub.cv;
	    break;
	}
    }

d2771 4
a2774 12
    PL_comppad = newAV();
    av_push(PL_comppad, Nullsv);
    PL_curpad = AvARRAY(PL_comppad);
    PL_comppad_name = newAV();
    PL_comppad_name_fill = 0;
    PL_min_intro_pending = 0;
    PL_padix = 0;
#ifdef USE_5005THREADS
    av_store(PL_comppad_name, 0, newSVpvn("@@_", 2));
    PL_curpad[0] = (SV*)newAV();
    SvPADMY_on(PL_curpad[0]);	/* XXX Needed? */
#endif /* USE_5005THREADS */
d2776 1
a2776 5
    comppadlist = newAV();
    AvREAL_off(comppadlist);
    av_store(comppadlist, 0, (SV*)PL_comppad_name);
    av_store(comppadlist, 1, (SV*)PL_comppad);
    CvPADLIST(PL_compcv) = comppadlist;
a2777 5
    if (!saveop ||
	(saveop->op_type != OP_REQUIRE && saveop->op_type != OP_DOFILE))
    {
	CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc(caller);
    }
d2803 1
a2803 2
	SV **newsp;
	I32 gimme;
d2834 6
a2850 2
	SvREFCNT_dec(CvOUTSIDE(PL_compcv));
	CvOUTSIDE(PL_compcv) = Nullcv;
d2853 10
a2862 1
    if (gimme & G_VOID)
d2900 1
a2900 1
S_doopen_pmc(pTHX_ const char *name, const char *mode)
d2902 1
d2930 3
a2982 3
	    if (ckWARN(WARN_PORTABLE))
		Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
                        "v-string in use/require non-portable");
d3028 1
a3028 1
	tryrsfp = doopen_pmc(name,PERL_SCRIPT_MODE);
d3037 1
a3037 1
	    tryrsfp = doopen_pmc(newname,PERL_SCRIPT_MODE);
d3138 1
d3193 1
a3193 1
		    tryrsfp = doopen_pmc(tryname, PERL_SCRIPT_MODE);
d3236 1
a3236 1
	SETERRNO(0, SS$_NORMAL);
d3299 1
a3299 1
    op = DOCATCH(doeval(gimme, NULL));
d3323 2
d3372 6
d3396 1
a3396 1
    ret = doeval(gimme, NULL);
d3460 1
a3460 1
	retop = Perl_die(aTHX_ "%s did not return a true value", SvPVX(nsv));
d3550 3
a3552 3
    U16 *fops;
    register U16 *fpc;
    U16 *linepc = 0;
d3555 1
d3560 9
a3568 1
    New(804, fops, (send - s)*3+10, U16);    /* Almost certainly too long... */
d3731 1
d3736 1
a3736 1
	SvGROW(sv, SvCUR(sv) + z + arg * sizeof(U16) + 4);
d3739 1
a3739 1
    Copy(fops, s, arg, U16);
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d29 1
a29 18
static I32 sortcv(pTHXo_ SV *a, SV *b);
static I32 sortcv_stacked(pTHXo_ SV *a, SV *b);
static I32 sortcv_xsub(pTHXo_ SV *a, SV *b);
static I32 sv_ncmp(pTHXo_ SV *a, SV *b);
static I32 sv_i_ncmp(pTHXo_ SV *a, SV *b);
static I32 amagic_ncmp(pTHXo_ SV *a, SV *b);
static I32 amagic_i_ncmp(pTHXo_ SV *a, SV *b);
static I32 amagic_cmp(pTHXo_ SV *a, SV *b);
static I32 amagic_cmp_locale(pTHXo_ SV *a, SV *b);
static I32 run_user_filter(pTHXo_ int idx, SV *buf_sv, int maxlen);

#ifdef PERL_OBJECT
static I32 sv_cmp_static(pTHXo_ SV *a, SV *b);
static I32 sv_cmp_locale_static(pTHXo_ SV *a, SV *b);
#else
#define sv_cmp_static Perl_sv_cmp
#define sv_cmp_locale_static Perl_sv_cmp_locale
#endif
d72 8
a80 1
    tmpstr = POPs;
d84 1
a84 1
	    mg = mg_find(sv, 'r');
d88 2
a89 2
	ReREFCNT_dec(pm->op_pmregexp);
	pm->op_pmregexp = ReREFCNT_inc(re);
d95 3
a97 3
	if (!pm->op_pmregexp || !pm->op_pmregexp->precomp ||
	    pm->op_pmregexp->prelen != len ||
	    memNE(pm->op_pmregexp->precomp, t, len))
d99 3
a101 3
	    if (pm->op_pmregexp) {
		ReREFCNT_dec(pm->op_pmregexp);
		pm->op_pmregexp = Null(REGEXP*);	/* crucial if regcomp aborts */
d108 10
a117 3
		pm->op_pmdynflags |= PMdf_UTF8;
	    pm->op_pmregexp = CALLREGCOMP(aTHX_ t, t + len, pm);
	    PL_reginterp_cnt = 0;		/* XXXX Be extra paranoid - needed
d131 1
a131 1
    if (!pm->op_pmregexp->prelen && PL_curpm)
d133 1
a133 1
    else if (strEQ("\\s+", pm->op_pmregexp->precomp))
d135 2
d141 1
a141 1
#if !defined(USE_ITHREADS) && !defined(USE_THREADS)
d161 1
d164 1
a179 1
	    bool isutf8;
d189 2
a190 1
	    isutf8 = DO_UTF8(dstr);
d197 1
a197 3
	    (void)SvPOK_only(targ);
	    if (isutf8)
		SvUTF8_on(targ);
d206 1
d216 2
a217 1
    sv_catpvn(dstr, s, m-s);
d224 4
a227 4
	    SvUPGRADE(sv, SVt_PVMG);
	if (!(mg = mg_find(sv, 'g'))) {
	    sv_magic(sv, Nullsv, 'g', Nullch, 0);
	    mg = mg_find(sv, 'g');
d310 4
a313 4
    register SV *sv;
    char *item;
    I32 itemsize;
    I32 fieldsize;
d316 2
a317 2
    char *chophere;
    char *linemark;
d319 1
a319 1
    bool gotsome;
d321 1
a321 1
    STRLEN fudge = SvCUR(tmpForm) * (IN_BYTE ? 1 : 3) + 1;
d365 1
d371 1
a371 1
	} )
d399 1
a399 1
		    Perl_warner(aTHX_ WARN_SYNTAX, "Not enough format arguments");
d408 1
a408 1
		if (itemsize != len) {
d450 1
a450 1
		if (itemsize != len) {
d549 7
a555 1
			switch (UTF8SKIP(s)) {
d650 37
d769 1
a769 1
    /* SAVE_DEFSV does *not* suffice here for USE_THREADS */
d796 1
a796 1
    SV** dst; 
d828 1
a828 1
	    
d838 1
a838 1
	dst = PL_stack_base + (PL_markstack_ptr[-2] += items) - 1; 
d840 1
a840 1
	    *dst-- = SvTEMP(TOPs) ? POPs : sv_mortalcopy(POPs); 
a876 173
PP(pp_sort)
{
    dSP; dMARK; dORIGMARK;
    register SV **up;
    SV **myorigmark = ORIGMARK;
    register I32 max;
    HV *stash;
    GV *gv;
    CV *cv;
    I32 gimme = GIMME;
    OP* nextop = PL_op->op_next;
    I32 overloading = 0;
    bool hasargs = FALSE;
    I32 is_xsub = 0;

    if (gimme != G_ARRAY) {
	SP = MARK;
	RETPUSHUNDEF;
    }

    ENTER;
    SAVEVPTR(PL_sortcop);
    if (PL_op->op_flags & OPf_STACKED) {
	if (PL_op->op_flags & OPf_SPECIAL) {
	    OP *kid = cLISTOP->op_first->op_sibling;	/* pass pushmark */
	    kid = kUNOP->op_first;			/* pass rv2gv */
	    kid = kUNOP->op_first;			/* pass leave */
	    PL_sortcop = kid->op_next;
	    stash = CopSTASH(PL_curcop);
	}
	else {
	    cv = sv_2cv(*++MARK, &stash, &gv, 0);
	    if (cv && SvPOK(cv)) {
		STRLEN n_a;
		char *proto = SvPV((SV*)cv, n_a);
		if (proto && strEQ(proto, "$$")) {
		    hasargs = TRUE;
		}
	    }
	    if (!(cv && CvROOT(cv))) {
		if (cv && CvXSUB(cv)) {
		    is_xsub = 1;
		}
		else if (gv) {
		    SV *tmpstr = sv_newmortal();
		    gv_efullname3(tmpstr, gv, Nullch);
		    DIE(aTHX_ "Undefined sort subroutine \"%s\" called",
			SvPVX(tmpstr));
		}
		else {
		    DIE(aTHX_ "Undefined subroutine in sort");
		}
	    }

	    if (is_xsub)
		PL_sortcop = (OP*)cv;
	    else {
		PL_sortcop = CvSTART(cv);
		SAVEVPTR(CvROOT(cv)->op_ppaddr);
		CvROOT(cv)->op_ppaddr = PL_ppaddr[OP_NULL];

		SAVEVPTR(PL_curpad);
		PL_curpad = AvARRAY((AV*)AvARRAY(CvPADLIST(cv))[1]);
            }
	}
    }
    else {
	PL_sortcop = Nullop;
	stash = CopSTASH(PL_curcop);
    }

    up = myorigmark + 1;
    while (MARK < SP) {	/* This may or may not shift down one here. */
	/*SUPPRESS 560*/
	if ((*up = *++MARK)) {			/* Weed out nulls. */
	    SvTEMP_off(*up);
	    if (!PL_sortcop && !SvPOK(*up)) {
		STRLEN n_a;
	        if (SvAMAGIC(*up))
	            overloading = 1;
	        else
		    (void)sv_2pv(*up, &n_a);
	    }
	    up++;
	}
    }
    max = --up - myorigmark;
    if (PL_sortcop) {
	if (max > 1) {
	    PERL_CONTEXT *cx;
	    SV** newsp;
	    bool oldcatch = CATCH_GET;

	    SAVETMPS;
	    SAVEOP();

	    CATCH_SET(TRUE);
	    PUSHSTACKi(PERLSI_SORT);
	    if (!hasargs && !is_xsub) {
		if (PL_sortstash != stash || !PL_firstgv || !PL_secondgv) {
		    SAVESPTR(PL_firstgv);
		    SAVESPTR(PL_secondgv);
		    PL_firstgv = gv_fetchpv("a", TRUE, SVt_PV);
		    PL_secondgv = gv_fetchpv("b", TRUE, SVt_PV);
		    PL_sortstash = stash;
		}
#ifdef USE_THREADS
		sv_lock((SV *)PL_firstgv);
		sv_lock((SV *)PL_secondgv);
#endif
		SAVESPTR(GvSV(PL_firstgv));
		SAVESPTR(GvSV(PL_secondgv));
	    }

	    PUSHBLOCK(cx, CXt_NULL, PL_stack_base);
	    if (!(PL_op->op_flags & OPf_SPECIAL)) {
		cx->cx_type = CXt_SUB;
		cx->blk_gimme = G_SCALAR;
		PUSHSUB(cx);
		if (!CvDEPTH(cv))
		    (void)SvREFCNT_inc(cv); /* in preparation for POPSUB */
	    }
	    PL_sortcxix = cxstack_ix;

	    if (hasargs && !is_xsub) {
		/* This is mostly copied from pp_entersub */
		AV *av = (AV*)PL_curpad[0];

#ifndef USE_THREADS
		cx->blk_sub.savearray = GvAV(PL_defgv);
		GvAV(PL_defgv) = (AV*)SvREFCNT_inc(av);
#endif /* USE_THREADS */
		cx->blk_sub.oldcurpad = PL_curpad;
		cx->blk_sub.argarray = av;
	    }
	    qsortsv((myorigmark+1), max,
		    is_xsub ? sortcv_xsub : hasargs ? sortcv_stacked : sortcv);

	    POPBLOCK(cx,PL_curpm);
	    PL_stack_sp = newsp;
	    POPSTACK;
	    CATCH_SET(oldcatch);
	}
    }
    else {
	if (max > 1) {
	    MEXTEND(SP, 20);	/* Can't afford stack realloc on signal. */
	    qsortsv(ORIGMARK+1, max,
 		    (PL_op->op_private & OPpSORT_NUMERIC)
			? ( (PL_op->op_private & OPpSORT_INTEGER)
			    ? ( overloading ? amagic_i_ncmp : sv_i_ncmp)
			    : ( overloading ? amagic_ncmp : sv_ncmp))
			: ( (PL_op->op_private & OPpLOCALE)
			    ? ( overloading
				? amagic_cmp_locale
				: sv_cmp_locale_static)
			    : ( overloading ? amagic_cmp : sv_cmp_static)));
	    if (PL_op->op_private & OPpSORT_REVERSE) {
		SV **p = ORIGMARK+1;
		SV **q = ORIGMARK+max;
		while (p < q) {
		    SV *tmp = *p;
		    *p++ = *q;
		    *q-- = tmp;
		}
	    }
	}
    }
    LEAVE;
    PL_stack_sp = ORIGMARK + max;
    return nextop;
}

d899 1
a899 1
 	int flip;
d902 7
a908 4
 	    struct io *gp_io;
 	    flip = PL_last_in_gv
 		&& (gp_io = GvIOp(PL_last_in_gv))
 		&& SvIV(sv) == (IV)IoLINES(gp_io);
d986 1
d988 15
a1002 3
	if ((PL_op->op_private & OPpFLIP_LINENUM)
	  ? (PL_last_in_gv && SvIV(sv) == (IV)IoLINES(GvIOp(PL_last_in_gv)))
	  : SvTRUE(sv) ) {
d1025 2
a1026 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting substitution via %s", 
			PL_op_name[PL_op->op_type]);
d1030 2
a1031 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting subroutine via %s", 
			PL_op_name[PL_op->op_type]);
d1035 2
a1036 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting format via %s", 
			PL_op_name[PL_op->op_type]);
d1040 2
a1041 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting eval via %s", 
			PL_op_name[PL_op->op_type]);
d1045 2
a1046 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting pseudo-block via %s", 
			PL_op_name[PL_op->op_type]);
d1160 2
a1161 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting substitution via %s", 
			PL_op_name[PL_op->op_type]);
d1165 2
a1166 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting subroutine via %s", 
			PL_op_name[PL_op->op_type]);
d1170 2
a1171 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting format via %s", 
			PL_op_name[PL_op->op_type]);
d1175 2
a1176 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting eval via %s", 
			PL_op_name[PL_op->op_type]);
d1180 2
a1181 2
		Perl_warner(aTHX_ WARN_EXITING, "Exiting pseudo-block via %s", 
			PL_op_name[PL_op->op_type]);
d1243 3
d1271 1
a1271 1
			Perl_warner(aTHX_ WARN_MISC, SvPVX(err)+start);
d1275 1
a1275 1
	    else
d1277 1
d1325 13
a1337 1
    {
d1344 1
a1344 1
	PerlIO_write(serr, message, msglen);
d1397 1
a1397 1
    EXTEND(SP, 10);
d1406 2
a1407 1
	    if (GIMME != G_ARRAY)
d1409 1
d1431 1
d1442 2
d1448 1
a1448 1
    PUSHs(sv_2mortal(newSVpv(CopFILE(cx->blk_oldcop), 0)));
d1453 1
d1455 10
a1464 4
	sv = NEWSV(49, 0);
	gv_efullname3(sv, CvGV(ccstack[cxix].blk_sub.cv), Nullch);
	PUSHs(sv_2mortal(sv));
	PUSHs(sv_2mortal(newSViv((I32)cx->blk_sub.hasargs)));
d1524 1
a1524 1
	if  (old_warnings == pWARN_NONE || 
d1527 1
a1527 1
        else if (old_warnings == pWARN_ALL || 
d1570 1
a1570 1
	I32 hasargs;
d1578 2
a1579 1
	if (CvDEPTH(cv) >= 1 && !(PL_debug & (1<<30))) /* don't do recursive DB::DB call */
d1623 1
a1623 1
#ifdef USE_THREADS
d1630 1
a1630 1
#endif /* USE_THREADS */
d1637 1
a1637 1
	iterdata = (void*)PL_op->op_targ;
d1995 1
a1995 1
    OP *kid;
d2093 1
a2093 1
	    if (CxTYPE(cx) == CXt_EVAL && cx->blk_eval.old_op_type == OP_ENTEREVAL) 
d2105 1
a2105 1
#ifndef USE_THREADS
d2108 1
a2108 1
#endif /* USE_THREADS */
d2120 1
a2120 1
#ifdef USE_THREADS
d2161 2
a2162 2
		    PUSHMARK(mark); 
		    (void)(*CvXSUB(cv))(aTHXo_ cv);
d2180 1
a2180 1
		cx->blk_sub.olddepth = CvDEPTH(cv);
d2232 1
a2232 1
#ifdef USE_THREADS
d2235 1
a2235 1
		    
d2242 1
a2242 1
			PUTBACK ;		    
d2245 1
a2245 1
#endif /* USE_THREADS */		
d2248 1
a2248 1
#ifndef USE_THREADS
d2250 1
a2250 1
#endif /* USE_THREADS */
d2255 1
a2255 1
#ifndef USE_THREADS
d2258 1
a2258 1
#endif /* USE_THREADS */
d2292 1
a2292 1
		    
d2324 2
d2335 9
a2343 2
		gotoprobe = PL_eval_root; /* XXX not good for nested eval */
		break;
d2381 11
d2449 1
d2545 1
d2553 9
d2576 1
d2582 3
d2594 1
a2594 1
    return Nullop;
d2649 1
a2649 1
    PL_hints = 0;
d2666 1
a2666 1
	PL_compiling.op_private = PL_hints;
d2673 1
a2673 1
/* With USE_THREADS, eval_owner must be held on entry to doeval */
d2714 4
a2717 1
#ifdef USE_THREADS
d2721 1
a2721 1
#endif /* USE_THREADS */
d2730 1
a2730 1
#ifdef USE_THREADS
d2734 1
a2734 1
#endif /* USE_THREADS */
a2766 2
    SvREFCNT_dec(PL_rs);
    PL_rs = newSVpvn("\n", 1);
d2804 1
a2804 3
	SvREFCNT_dec(PL_rs);
	PL_rs = SvREFCNT_inc(PL_nrs);
#ifdef USE_THREADS
d2809 1
a2809 1
#endif /* USE_THREADS */
a2811 2
    SvREFCNT_dec(PL_rs);
    PL_rs = SvREFCNT_inc(PL_nrs);
d2846 1
a2846 1
#ifdef USE_THREADS
d2851 1
a2851 1
#endif /* USE_THREADS */
d2895 1
a2895 1
    char *tryname;
d2898 1
a2898 1
    I32 gimme = G_SCALAR;
d2905 3
d2910 2
a2911 2
    if (SvNIOKp(sv)) {
	if (SvPOK(sv) && SvNOK(sv)) {		/* require v5.6.1 */
d2917 1
a2917 1
		rev = utf8_to_uv(s, end - s, &len, 0);
d2920 1
a2920 1
		    ver = utf8_to_uv(s, end - s, &len, 0);
d2923 1
a2923 1
			sver = utf8_to_uv(s, end - s, &len, 0);
d2936 3
d2955 5
a2959 5
		    DIE(aTHX_ "Perl v%"UVuf".%"UVuf".%"UVuf" required--"
			"this is only v%d.%d.%d, stopped"
			" (did you mean v%"UVuf".%"UVuf".0?)",
			rev, ver, sver, PERL_REVISION, PERL_VERSION,
			PERL_SUBVERSION, rev, ver/100);
d2982 1
a2982 4
#ifdef MACOS_TRADITIONAL
    if (PERL_FILE_IS_ABSOLUTE(name)
	|| (*name == ':' && name[1] != ':' && strchr(name+2, ':')))
    {
a2984 5
	/* We consider paths of the form :a:b ambiguous and interpret them first
	   as global then as local
	*/
    	if (!tryrsfp && *name == ':' && name[1] != ':' && strchr(name+2, ':'))
	    goto trylocal;
d2986 9
a2994 9
    else 
trylocal: {
#else
    if (PERL_FILE_IS_ABSOLUTE(name)
	|| (*name == '.' && (name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/'))))
    {
	tryname = name;
	tryrsfp = doopen_pmc(name,PERL_SCRIPT_MODE);
a2995 1
    else {
d2997 1
d3013 3
a3015 1
		    if (SvTYPE(SvRV(loader)) == SVt_PVAV) {
d3020 1
a3020 1
				   PTR2UV(SvANY(loader)), name);
d3101 1
d3120 8
d3130 5
a3134 2
		    char buf[256];
		    Perl_sv_setpvf(aTHX_ namesv, "%s%s", MacPerl_CanonDir(dir, buf), name+(name[0] == ':'));
a3147 8
#ifdef MACOS_TRADITIONAL
		    {
		    	/* Convert slashes in the name part, but not the directory part, to colons */
		    	char * colon;
		    	for (colon = tryname+strlen(dir); colon = strchr(colon, '/'); )
			    *colon++ = ':';
		    }
#endif
d3154 1
d3194 8
a3201 2
    (void)hv_store(GvHVn(PL_incgv), name, strlen(name),
		   newSVpv(CopFILE(&PL_compiling), 0), 0 );
d3217 3
a3219 1
    else 
d3221 2
d3241 1
a3241 1
#ifdef USE_THREADS
d3248 12
a3259 2
#endif /* USE_THREADS */
    return DOCATCH(doeval(G_SCALAR, NULL));
d3279 1
a3279 1
    if (!SvPV(sv,len) || !len)
d3286 1
a3286 1
 
d3318 7
d3335 1
a3335 1
#ifdef USE_THREADS
d3342 1
a3342 1
#endif /* USE_THREADS */
d3344 1
a3344 1
    if (PERLDB_INTER && was != PL_sub_generation /* Some subs defined here. */
a3430 1
    PL_eval_root = PL_op;		/* Only needed so that goto works right. */
d3444 1
d3451 1
a3451 1
    pop_return();
d3483 1
a3483 1
    RETURN;
d3492 1
a3492 1
    register char *base;
d3494 2
a3495 2
    bool noblank;
    bool repeat;
d3499 1
a3499 1
    U16 *linepc;
d3505 1
a3505 1
    
d3533 1
a3533 1
	    
d3542 1
a3542 1
		*fpc++ = arg;
d3549 1
a3549 1
		*fpc++ = skipspaces;
d3560 1
a3560 1
		*fpc++ = arg;
d3583 1
a3583 1
		*fpc++ = arg;
d3608 19
a3626 1
		*fpc++ = arg;
d3655 1
a3655 1
		    *fpc++ = prespace;
d3678 1
a3678 1
    sv_magic(sv, Nullsv, 'f', Nullch, 0);
a3681 755
/*
 * The rest of this file was derived from source code contributed
 * by Tom Horsley.
 *
 * NOTE: this code was derived from Tom Horsley's qsort replacement
 * and should not be confused with the original code.
 */

/* Copyright (C) Tom Horsley, 1997. All rights reserved.

   Permission granted to distribute under the same terms as perl which are
   (briefly):

    This program is free software; you can redistribute it and/or modify
    it under the terms of either:

	a) the GNU General Public License as published by the Free
	Software Foundation; either version 1, or (at your option) any
	later version, or

	b) the "Artistic License" which comes with this Kit.

   Details on the perl license can be found in the perl source code which
   may be located via the www.perl.com web page.

   This is the most wonderfulest possible qsort I can come up with (and
   still be mostly portable) My (limited) tests indicate it consistently
   does about 20% fewer calls to compare than does the qsort in the Visual
   C++ library, other vendors may vary.

   Some of the ideas in here can be found in "Algorithms" by Sedgewick,
   others I invented myself (or more likely re-invented since they seemed
   pretty obvious once I watched the algorithm operate for a while).

   Most of this code was written while watching the Marlins sweep the Giants
   in the 1997 National League Playoffs - no Braves fans allowed to use this
   code (just kidding :-).

   I realize that if I wanted to be true to the perl tradition, the only
   comment in this file would be something like:

   ...they shuffled back towards the rear of the line. 'No, not at the
   rear!'  the slave-driver shouted. 'Three files up. And stay there...

   However, I really needed to violate that tradition just so I could keep
   track of what happens myself, not to mention some poor fool trying to
   understand this years from now :-).
*/

/* ********************************************************** Configuration */

#ifndef QSORT_ORDER_GUESS
#define QSORT_ORDER_GUESS 2	/* Select doubling version of the netBSD trick */
#endif

/* QSORT_MAX_STACK is the largest number of partitions that can be stacked up for
   future processing - a good max upper bound is log base 2 of memory size
   (32 on 32 bit machines, 64 on 64 bit machines, etc). In reality can
   safely be smaller than that since the program is taking up some space and
   most operating systems only let you grab some subset of contiguous
   memory (not to mention that you are normally sorting data larger than
   1 byte element size :-).
*/
#ifndef QSORT_MAX_STACK
#define QSORT_MAX_STACK 32
#endif

/* QSORT_BREAK_EVEN is the size of the largest partition we should insertion sort.
   Anything bigger and we use qsort. If you make this too small, the qsort
   will probably break (or become less efficient), because it doesn't expect
   the middle element of a partition to be the same as the right or left -
   you have been warned).
*/
#ifndef QSORT_BREAK_EVEN
#define QSORT_BREAK_EVEN 6
#endif

/* ************************************************************* Data Types */

/* hold left and right index values of a partition waiting to be sorted (the
   partition includes both left and right - right is NOT one past the end or
   anything like that).
*/
struct partition_stack_entry {
   int left;
   int right;
#ifdef QSORT_ORDER_GUESS
   int qsort_break_even;
#endif
};

/* ******************************************************* Shorthand Macros */

/* Note that these macros will be used from inside the qsort function where
   we happen to know that the variable 'elt_size' contains the size of an
   array element and the variable 'temp' points to enough space to hold a
   temp element and the variable 'array' points to the array being sorted
   and 'compare' is the pointer to the compare routine.

   Also note that there are very many highly architecture specific ways
   these might be sped up, but this is simply the most generally portable
   code I could think of.
*/

/* Return < 0 == 0 or > 0 as the value of elt1 is < elt2, == elt2, > elt2
*/
#define qsort_cmp(elt1, elt2) \
   ((*compare)(aTHXo_ array[elt1], array[elt2]))

#ifdef QSORT_ORDER_GUESS
#define QSORT_NOTICE_SWAP swapped++;
#else
#define QSORT_NOTICE_SWAP
#endif

/* swaps contents of array elements elt1, elt2.
*/
#define qsort_swap(elt1, elt2) \
   STMT_START { \
      QSORT_NOTICE_SWAP \
      temp = array[elt1]; \
      array[elt1] = array[elt2]; \
      array[elt2] = temp; \
   } STMT_END

/* rotate contents of elt1, elt2, elt3 such that elt1 gets elt2, elt2 gets
   elt3 and elt3 gets elt1.
*/
#define qsort_rotate(elt1, elt2, elt3) \
   STMT_START { \
      QSORT_NOTICE_SWAP \
      temp = array[elt1]; \
      array[elt1] = array[elt2]; \
      array[elt2] = array[elt3]; \
      array[elt3] = temp; \
   } STMT_END

/* ************************************************************ Debug stuff */

#ifdef QSORT_DEBUG

static void
break_here()
{
   return; /* good place to set a breakpoint */
}

#define qsort_assert(t) (void)( (t) || (break_here(), 0) )

static void
doqsort_all_asserts(
   void * array,
   size_t num_elts,
   size_t elt_size,
   int (*compare)(const void * elt1, const void * elt2),
   int pc_left, int pc_right, int u_left, int u_right)
{
   int i;

   qsort_assert(pc_left <= pc_right);
   qsort_assert(u_right < pc_left);
   qsort_assert(pc_right < u_left);
   for (i = u_right + 1; i < pc_left; ++i) {
      qsort_assert(qsort_cmp(i, pc_left) < 0);
   }
   for (i = pc_left; i < pc_right; ++i) {
      qsort_assert(qsort_cmp(i, pc_right) == 0);
   }
   for (i = pc_right + 1; i < u_left; ++i) {
      qsort_assert(qsort_cmp(pc_right, i) < 0);
   }
}

#define qsort_all_asserts(PC_LEFT, PC_RIGHT, U_LEFT, U_RIGHT) \
   doqsort_all_asserts(array, num_elts, elt_size, compare, \
                 PC_LEFT, PC_RIGHT, U_LEFT, U_RIGHT)

#else

#define qsort_assert(t) ((void)0)

#define qsort_all_asserts(PC_LEFT, PC_RIGHT, U_LEFT, U_RIGHT) ((void)0)

#endif

/* ****************************************************************** qsort */

STATIC void
S_qsortsv(pTHX_ SV ** array, size_t num_elts, SVCOMPARE_t compare)
{
   register SV * temp;

   struct partition_stack_entry partition_stack[QSORT_MAX_STACK];
   int next_stack_entry = 0;

   int part_left;
   int part_right;
#ifdef QSORT_ORDER_GUESS
   int qsort_break_even;
   int swapped;
#endif

   /* Make sure we actually have work to do.
   */
   if (num_elts <= 1) {
      return;
   }

   /* Setup the initial partition definition and fall into the sorting loop
   */
   part_left = 0;
   part_right = (int)(num_elts - 1);
#ifdef QSORT_ORDER_GUESS
   qsort_break_even = QSORT_BREAK_EVEN;
#else
#define qsort_break_even QSORT_BREAK_EVEN
#endif
   for ( ; ; ) {
      if ((part_right - part_left) >= qsort_break_even) {
         /* OK, this is gonna get hairy, so lets try to document all the
            concepts and abbreviations and variables and what they keep
            track of:

            pc: pivot chunk - the set of array elements we accumulate in the
                middle of the partition, all equal in value to the original
                pivot element selected. The pc is defined by:

                pc_left - the leftmost array index of the pc
                pc_right - the rightmost array index of the pc

                we start with pc_left == pc_right and only one element
                in the pivot chunk (but it can grow during the scan).

            u:  uncompared elements - the set of elements in the partition
                we have not yet compared to the pivot value. There are two
                uncompared sets during the scan - one to the left of the pc
                and one to the right.

                u_right - the rightmost index of the left side's uncompared set
                u_left - the leftmost index of the right side's uncompared set

                The leftmost index of the left sides's uncompared set
                doesn't need its own variable because it is always defined
                by the leftmost edge of the whole partition (part_left). The
                same goes for the rightmost edge of the right partition
                (part_right).

                We know there are no uncompared elements on the left once we
                get u_right < part_left and no uncompared elements on the
                right once u_left > part_right. When both these conditions
                are met, we have completed the scan of the partition.

                Any elements which are between the pivot chunk and the
                uncompared elements should be less than the pivot value on
                the left side and greater than the pivot value on the right
                side (in fact, the goal of the whole algorithm is to arrange
                for that to be true and make the groups of less-than and
                greater-then elements into new partitions to sort again).

            As you marvel at the complexity of the code and wonder why it
            has to be so confusing. Consider some of the things this level
            of confusion brings:

            Once I do a compare, I squeeze every ounce of juice out of it. I
            never do compare calls I don't have to do, and I certainly never
            do redundant calls.

            I also never swap any elements unless I can prove there is a
            good reason. Many sort algorithms will swap a known value with
            an uncompared value just to get things in the right place (or
            avoid complexity :-), but that uncompared value, once it gets
            compared, may then have to be swapped again. A lot of the
            complexity of this code is due to the fact that it never swaps
            anything except compared values, and it only swaps them when the
            compare shows they are out of position.
         */
         int pc_left, pc_right;
         int u_right, u_left;

         int s;

         pc_left = ((part_left + part_right) / 2);
         pc_right = pc_left;
         u_right = pc_left - 1;
         u_left = pc_right + 1;

         /* Qsort works best when the pivot value is also the median value
            in the partition (unfortunately you can't find the median value
            without first sorting :-), so to give the algorithm a helping
            hand, we pick 3 elements and sort them and use the median value
            of that tiny set as the pivot value.

            Some versions of qsort like to use the left middle and right as
            the 3 elements to sort so they can insure the ends of the
            partition will contain values which will stop the scan in the
            compare loop, but when you have to call an arbitrarily complex
            routine to do a compare, its really better to just keep track of
            array index values to know when you hit the edge of the
            partition and avoid the extra compare. An even better reason to
            avoid using a compare call is the fact that you can drop off the
            edge of the array if someone foolishly provides you with an
            unstable compare function that doesn't always provide consistent
            results.

            So, since it is simpler for us to compare the three adjacent
            elements in the middle of the partition, those are the ones we
            pick here (conveniently pointed at by u_right, pc_left, and
            u_left). The values of the left, center, and right elements
            are refered to as l c and r in the following comments.
         */

#ifdef QSORT_ORDER_GUESS
         swapped = 0;
#endif
         s = qsort_cmp(u_right, pc_left);
         if (s < 0) {
            /* l < c */
            s = qsort_cmp(pc_left, u_left);
            /* if l < c, c < r - already in order - nothing to do */
            if (s == 0) {
               /* l < c, c == r - already in order, pc grows */
               ++pc_right;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            } else if (s > 0) {
               /* l < c, c > r - need to know more */
               s = qsort_cmp(u_right, u_left);
               if (s < 0) {
                  /* l < c, c > r, l < r - swap c & r to get ordered */
                  qsort_swap(pc_left, u_left);
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               } else if (s == 0) {
                  /* l < c, c > r, l == r - swap c&r, grow pc */
                  qsort_swap(pc_left, u_left);
                  --pc_left;
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               } else {
                  /* l < c, c > r, l > r - make lcr into rlc to get ordered */
                  qsort_rotate(pc_left, u_right, u_left);
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               }
            }
         } else if (s == 0) {
            /* l == c */
            s = qsort_cmp(pc_left, u_left);
            if (s < 0) {
               /* l == c, c < r - already in order, grow pc */
               --pc_left;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            } else if (s == 0) {
               /* l == c, c == r - already in order, grow pc both ways */
               --pc_left;
               ++pc_right;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            } else {
               /* l == c, c > r - swap l & r, grow pc */
               qsort_swap(u_right, u_left);
               ++pc_right;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            }
         } else {
            /* l > c */
            s = qsort_cmp(pc_left, u_left);
            if (s < 0) {
               /* l > c, c < r - need to know more */
               s = qsort_cmp(u_right, u_left);
               if (s < 0) {
                  /* l > c, c < r, l < r - swap l & c to get ordered */
                  qsort_swap(u_right, pc_left);
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               } else if (s == 0) {
                  /* l > c, c < r, l == r - swap l & c, grow pc */
                  qsort_swap(u_right, pc_left);
                  ++pc_right;
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               } else {
                  /* l > c, c < r, l > r - rotate lcr into crl to order */
                  qsort_rotate(u_right, pc_left, u_left);
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               }
            } else if (s == 0) {
               /* l > c, c == r - swap ends, grow pc */
               qsort_swap(u_right, u_left);
               --pc_left;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            } else {
               /* l > c, c > r - swap ends to get in order */
               qsort_swap(u_right, u_left);
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            }
         }
         /* We now know the 3 middle elements have been compared and
            arranged in the desired order, so we can shrink the uncompared
            sets on both sides
         */
         --u_right;
         ++u_left;
         qsort_all_asserts(pc_left, pc_right, u_left, u_right);

         /* The above massive nested if was the simple part :-). We now have
            the middle 3 elements ordered and we need to scan through the
            uncompared sets on either side, swapping elements that are on
            the wrong side or simply shuffling equal elements around to get
            all equal elements into the pivot chunk.
         */

         for ( ; ; ) {
            int still_work_on_left;
            int still_work_on_right;

            /* Scan the uncompared values on the left. If I find a value
               equal to the pivot value, move it over so it is adjacent to
               the pivot chunk and expand the pivot chunk. If I find a value
               less than the pivot value, then just leave it - its already
               on the correct side of the partition. If I find a greater
               value, then stop the scan.
            */
            while ((still_work_on_left = (u_right >= part_left))) {
               s = qsort_cmp(u_right, pc_left);
               if (s < 0) {
                  --u_right;
               } else if (s == 0) {
                  --pc_left;
                  if (pc_left != u_right) {
                     qsort_swap(u_right, pc_left);
                  }
                  --u_right;
               } else {
                  break;
               }
               qsort_assert(u_right < pc_left);
               qsort_assert(pc_left <= pc_right);
               qsort_assert(qsort_cmp(u_right + 1, pc_left) <= 0);
               qsort_assert(qsort_cmp(pc_left, pc_right) == 0);
            }

            /* Do a mirror image scan of uncompared values on the right
            */
            while ((still_work_on_right = (u_left <= part_right))) {
               s = qsort_cmp(pc_right, u_left);
               if (s < 0) {
                  ++u_left;
               } else if (s == 0) {
                  ++pc_right;
                  if (pc_right != u_left) {
                     qsort_swap(pc_right, u_left);
                  }
                  ++u_left;
               } else {
                  break;
               }
               qsort_assert(u_left > pc_right);
               qsort_assert(pc_left <= pc_right);
               qsort_assert(qsort_cmp(pc_right, u_left - 1) <= 0);
               qsort_assert(qsort_cmp(pc_left, pc_right) == 0);
            }

            if (still_work_on_left) {
               /* I know I have a value on the left side which needs to be
                  on the right side, but I need to know more to decide
                  exactly the best thing to do with it.
               */
               if (still_work_on_right) {
                  /* I know I have values on both side which are out of
                     position. This is a big win because I kill two birds
                     with one swap (so to speak). I can advance the
                     uncompared pointers on both sides after swapping both
                     of them into the right place.
                  */
                  qsort_swap(u_right, u_left);
                  --u_right;
                  ++u_left;
                  qsort_all_asserts(pc_left, pc_right, u_left, u_right);
               } else {
                  /* I have an out of position value on the left, but the
                     right is fully scanned, so I "slide" the pivot chunk
                     and any less-than values left one to make room for the
                     greater value over on the right. If the out of position
                     value is immediately adjacent to the pivot chunk (there
                     are no less-than values), I can do that with a swap,
                     otherwise, I have to rotate one of the less than values
                     into the former position of the out of position value
                     and the right end of the pivot chunk into the left end
                     (got all that?).
                  */
                  --pc_left;
                  if (pc_left == u_right) {
                     qsort_swap(u_right, pc_right);
                     qsort_all_asserts(pc_left, pc_right-1, u_left, u_right-1);
                  } else {
                     qsort_rotate(u_right, pc_left, pc_right);
                     qsort_all_asserts(pc_left, pc_right-1, u_left, u_right-1);
                  }
                  --pc_right;
                  --u_right;
               }
            } else if (still_work_on_right) {
               /* Mirror image of complex case above: I have an out of
                  position value on the right, but the left is fully
                  scanned, so I need to shuffle things around to make room
                  for the right value on the left.
               */
               ++pc_right;
               if (pc_right == u_left) {
                  qsort_swap(u_left, pc_left);
                  qsort_all_asserts(pc_left+1, pc_right, u_left+1, u_right);
               } else {
                  qsort_rotate(pc_right, pc_left, u_left);
                  qsort_all_asserts(pc_left+1, pc_right, u_left+1, u_right);
               }
               ++pc_left;
               ++u_left;
            } else {
               /* No more scanning required on either side of partition,
                  break out of loop and figure out next set of partitions
               */
               break;
            }
         }

         /* The elements in the pivot chunk are now in the right place. They
            will never move or be compared again. All I have to do is decide
            what to do with the stuff to the left and right of the pivot
            chunk.

            Notes on the QSORT_ORDER_GUESS ifdef code:

            1. If I just built these partitions without swapping any (or
               very many) elements, there is a chance that the elements are
               already ordered properly (being properly ordered will
               certainly result in no swapping, but the converse can't be
               proved :-).

            2. A (properly written) insertion sort will run faster on
               already ordered data than qsort will.

            3. Perhaps there is some way to make a good guess about
               switching to an insertion sort earlier than partition size 6
               (for instance - we could save the partition size on the stack
               and increase the size each time we find we didn't swap, thus
               switching to insertion sort earlier for partitions with a
               history of not swapping).

            4. Naturally, if I just switch right away, it will make
               artificial benchmarks with pure ascending (or descending)
               data look really good, but is that a good reason in general?
               Hard to say...
         */

#ifdef QSORT_ORDER_GUESS
         if (swapped < 3) {
#if QSORT_ORDER_GUESS == 1
            qsort_break_even = (part_right - part_left) + 1;
#endif
#if QSORT_ORDER_GUESS == 2
            qsort_break_even *= 2;
#endif
#if QSORT_ORDER_GUESS == 3
            int prev_break = qsort_break_even;
            qsort_break_even *= qsort_break_even;
            if (qsort_break_even < prev_break) {
               qsort_break_even = (part_right - part_left) + 1;
            }
#endif
         } else {
            qsort_break_even = QSORT_BREAK_EVEN;
         }
#endif

         if (part_left < pc_left) {
            /* There are elements on the left which need more processing.
               Check the right as well before deciding what to do.
            */
            if (pc_right < part_right) {
               /* We have two partitions to be sorted. Stack the biggest one
                  and process the smallest one on the next iteration. This
                  minimizes the stack height by insuring that any additional
                  stack entries must come from the smallest partition which
                  (because it is smallest) will have the fewest
                  opportunities to generate additional stack entries.
               */
               if ((part_right - pc_right) > (pc_left - part_left)) {
                  /* stack the right partition, process the left */
                  partition_stack[next_stack_entry].left = pc_right + 1;
                  partition_stack[next_stack_entry].right = part_right;
#ifdef QSORT_ORDER_GUESS
                  partition_stack[next_stack_entry].qsort_break_even = qsort_break_even;
#endif
                  part_right = pc_left - 1;
               } else {
                  /* stack the left partition, process the right */
                  partition_stack[next_stack_entry].left = part_left;
                  partition_stack[next_stack_entry].right = pc_left - 1;
#ifdef QSORT_ORDER_GUESS
                  partition_stack[next_stack_entry].qsort_break_even = qsort_break_even;
#endif
                  part_left = pc_right + 1;
               }
               qsort_assert(next_stack_entry < QSORT_MAX_STACK);
               ++next_stack_entry;
            } else {
               /* The elements on the left are the only remaining elements
                  that need sorting, arrange for them to be processed as the
                  next partition.
               */
               part_right = pc_left - 1;
            }
         } else if (pc_right < part_right) {
            /* There is only one chunk on the right to be sorted, make it
               the new partition and loop back around.
            */
            part_left = pc_right + 1;
         } else {
            /* This whole partition wound up in the pivot chunk, so
               we need to get a new partition off the stack.
            */
            if (next_stack_entry == 0) {
               /* the stack is empty - we are done */
               break;
            }
            --next_stack_entry;
            part_left = partition_stack[next_stack_entry].left;
            part_right = partition_stack[next_stack_entry].right;
#ifdef QSORT_ORDER_GUESS
            qsort_break_even = partition_stack[next_stack_entry].qsort_break_even;
#endif
         }
      } else {
         /* This partition is too small to fool with qsort complexity, just
            do an ordinary insertion sort to minimize overhead.
         */
         int i;
         /* Assume 1st element is in right place already, and start checking
            at 2nd element to see where it should be inserted.
         */
         for (i = part_left + 1; i <= part_right; ++i) {
            int j;
            /* Scan (backwards - just in case 'i' is already in right place)
               through the elements already sorted to see if the ith element
               belongs ahead of one of them.
            */
            for (j = i - 1; j >= part_left; --j) {
               if (qsort_cmp(i, j) >= 0) {
                  /* i belongs right after j
                  */
                  break;
               }
            }
            ++j;
            if (j != i) {
               /* Looks like we really need to move some things
               */
	       int k;
	       temp = array[i];
	       for (k = i - 1; k >= j; --k)
		  array[k + 1] = array[k];
               array[j] = temp;
            }
         }

         /* That partition is now sorted, grab the next one, or get out
            of the loop if there aren't any more.
         */

         if (next_stack_entry == 0) {
            /* the stack is empty - we are done */
            break;
         }
         --next_stack_entry;
         part_left = partition_stack[next_stack_entry].left;
         part_right = partition_stack[next_stack_entry].right;
#ifdef QSORT_ORDER_GUESS
         qsort_break_even = partition_stack[next_stack_entry].qsort_break_even;
#endif
      }
   }

   /* Believe it or not, the array is sorted at this point! */
}


#ifdef PERL_OBJECT
#undef this
#define this pPerl
#include "XSUB.h"
#endif


static I32
sortcv(pTHXo_ SV *a, SV *b)
{
    I32 oldsaveix = PL_savestack_ix;
    I32 oldscopeix = PL_scopestack_ix;
    I32 result;
    GvSV(PL_firstgv) = a;
    GvSV(PL_secondgv) = b;
    PL_stack_sp = PL_stack_base;
    PL_op = PL_sortcop;
    CALLRUNOPS(aTHX);
    if (PL_stack_sp != PL_stack_base + 1)
	Perl_croak(aTHX_ "Sort subroutine didn't return single value");
    if (!SvNIOKp(*PL_stack_sp))
	Perl_croak(aTHX_ "Sort subroutine didn't return a numeric value");
    result = SvIV(*PL_stack_sp);
    while (PL_scopestack_ix > oldscopeix) {
	LEAVE;
    }
    leave_scope(oldsaveix);
    return result;
}

static I32
sortcv_stacked(pTHXo_ SV *a, SV *b)
{
    I32 oldsaveix = PL_savestack_ix;
    I32 oldscopeix = PL_scopestack_ix;
    I32 result;
    AV *av;

#ifdef USE_THREADS
    av = (AV*)PL_curpad[0];
#else
    av = GvAV(PL_defgv);
#endif

    if (AvMAX(av) < 1) {
	SV** ary = AvALLOC(av);
	if (AvARRAY(av) != ary) {
	    AvMAX(av) += AvARRAY(av) - AvALLOC(av);
	    SvPVX(av) = (char*)ary;
	}
	if (AvMAX(av) < 1) {
	    AvMAX(av) = 1;
	    Renew(ary,2,SV*);
	    SvPVX(av) = (char*)ary;
	}
    }
    AvFILLp(av) = 1;

    AvARRAY(av)[0] = a;
    AvARRAY(av)[1] = b;
    PL_stack_sp = PL_stack_base;
    PL_op = PL_sortcop;
    CALLRUNOPS(aTHX);
    if (PL_stack_sp != PL_stack_base + 1)
	Perl_croak(aTHX_ "Sort subroutine didn't return single value");
    if (!SvNIOKp(*PL_stack_sp))
	Perl_croak(aTHX_ "Sort subroutine didn't return a numeric value");
    result = SvIV(*PL_stack_sp);
    while (PL_scopestack_ix > oldscopeix) {
	LEAVE;
    }
    leave_scope(oldsaveix);
    return result;
}

d3683 1
a3683 144
sortcv_xsub(pTHXo_ SV *a, SV *b)
{
    dSP;
    I32 oldsaveix = PL_savestack_ix;
    I32 oldscopeix = PL_scopestack_ix;
    I32 result;
    CV *cv=(CV*)PL_sortcop;

    SP = PL_stack_base;
    PUSHMARK(SP);
    EXTEND(SP, 2);
    *++SP = a;
    *++SP = b;
    PUTBACK;
    (void)(*CvXSUB(cv))(aTHXo_ cv);
    if (PL_stack_sp != PL_stack_base + 1)
	Perl_croak(aTHX_ "Sort subroutine didn't return single value");
    if (!SvNIOKp(*PL_stack_sp))
	Perl_croak(aTHX_ "Sort subroutine didn't return a numeric value");
    result = SvIV(*PL_stack_sp);
    while (PL_scopestack_ix > oldscopeix) {
	LEAVE;
    }
    leave_scope(oldsaveix);
    return result;
}


static I32
sv_ncmp(pTHXo_ SV *a, SV *b)
{
    NV nv1 = SvNV(a);
    NV nv2 = SvNV(b);
    return nv1 < nv2 ? -1 : nv1 > nv2 ? 1 : 0;
}

static I32
sv_i_ncmp(pTHXo_ SV *a, SV *b)
{
    IV iv1 = SvIV(a);
    IV iv2 = SvIV(b);
    return iv1 < iv2 ? -1 : iv1 > iv2 ? 1 : 0;
}
#define tryCALL_AMAGICbin(left,right,meth,svp) STMT_START { \
	  *svp = Nullsv;				\
          if (PL_amagic_generation) { \
	    if (SvAMAGIC(left)||SvAMAGIC(right))\
		*svp = amagic_call(left, \
				   right, \
				   CAT2(meth,_amg), \
				   0); \
	  } \
	} STMT_END

static I32
amagic_ncmp(pTHXo_ register SV *a, register SV *b)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(a,b,ncmp,&tmpsv);
    if (tmpsv) {
    	NV d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
     }
     return sv_ncmp(aTHXo_ a, b);
}

static I32
amagic_i_ncmp(pTHXo_ register SV *a, register SV *b)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(a,b,ncmp,&tmpsv);
    if (tmpsv) {
    	NV d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_i_ncmp(aTHXo_ a, b);
}

static I32
amagic_cmp(pTHXo_ register SV *str1, register SV *str2)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(str1,str2,scmp,&tmpsv);
    if (tmpsv) {
    	NV d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_cmp(str1, str2);
}

static I32
amagic_cmp_locale(pTHXo_ register SV *str1, register SV *str2)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(str1,str2,scmp,&tmpsv);
    if (tmpsv) {
    	NV d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_cmp_locale(str1, str2);
}

static I32
run_user_filter(pTHXo_ int idx, SV *buf_sv, int maxlen)
d3752 4
a3755 4
#ifdef PERL_OBJECT

static I32
sv_cmp_locale_static(pTHXo_ register SV *str1, register SV *str2)
d3757 12
a3768 1
    return sv_cmp_locale(str1, str2);
a3769 8

static I32
sv_cmp_static(pTHXo_ register SV *str1, register SV *str2)
{
    return sv_cmp(str1, str2);
}

#endif /* PERL_OBJECT */
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d50 1
a50 1
    djSP;
d83 1
a83 1
    djSP;
d152 1
a152 1
    djSP;
d179 2
a181 1

d189 1
d197 2
d218 15
d301 1
a301 1
    djSP; dMARK; dORIGMARK;
d546 1
a546 1
		    if (*s & 0x80) {
d620 1
a620 1
		RESTORE_NUMERIC_LOCAL();
d709 1
a709 1
    djSP;
d746 2
a747 2
    djSP;
    I32 diff = (SP - PL_stack_base) - *PL_markstack_ptr;
d753 1
d755 28
a782 4
    if (diff) {
	if (diff > PL_markstack_ptr[-1] - PL_markstack_ptr[-2]) {
	    shift = diff - (PL_markstack_ptr[-1] - PL_markstack_ptr[-2]);
	    count = (SP - PL_stack_base) - PL_markstack_ptr[-1] + 2;
d789 1
a789 1
	    while (--count)
d792 3
a794 3
	dst = PL_stack_base + (PL_markstack_ptr[-2] += diff) - 1; 
	++diff;
	while (--diff)
a800 1
	I32 items;
d823 1
d834 1
a834 1
    djSP; dMARK; dORIGMARK;
d930 14
a943 4
	    if (PL_sortstash != stash) {
		PL_firstgv = gv_fetchpv("a", TRUE, SVt_PV);
		PL_secondgv = gv_fetchpv("b", TRUE, SVt_PV);
		PL_sortstash = stash;
a945 3
	    SAVESPTR(GvSV(PL_firstgv));
	    SAVESPTR(GvSV(PL_secondgv));

d964 1
d1019 1
a1019 1
    djSP;
d1027 1
d1029 9
a1037 3
	if ((PL_op->op_private & OPpFLIP_LINENUM)
	  ? (PL_last_in_gv && SvIV(sv) == (IV)IoLINES(GvIOp(PL_last_in_gv)))
	  : SvTRUE(sv) ) {
d1058 1
a1058 1
    djSP;
a1128 1
    dTHR;
a1183 1
    dTHR;
d1204 14
a1220 1
    dTHR;
a1226 1
    dTHR;
a1246 1
    dTHR;
a1264 1
    dTHR;
a1305 1
    dTHR;
a1338 36
/*
 * Closures mentioned at top level of eval cannot be referenced
 * again, and their presence indirectly causes a memory leak.
 * (Note that the fact that compcv and friends are still set here
 * is, AFAIK, an accident.)  --Chip
 *
 * XXX need to get comppad et al from eval's cv rather than
 * relying on the incidental global values.
 */
STATIC void
S_free_closures(pTHX)
{
    dTHR;
    SV **svp = AvARRAY(PL_comppad_name);
    I32 ix;
    for (ix = AvFILLp(PL_comppad_name); ix >= 0; ix--) {
	SV *sv = svp[ix];
	if (sv && sv != &PL_sv_undef && *SvPVX(sv) == '&') {
	    SvREFCNT_dec(sv);
	    svp[ix] = &PL_sv_undef;

	    sv = PL_curpad[ix];
	    if (CvCLONE(sv)) {
		SvREFCNT_dec(CvOUTSIDE(sv));
		CvOUTSIDE(sv) = Nullcv;
	    }
	    else {
		SvREFCNT_dec(sv);
		sv = NEWSV(0,0);
		SvPADTMP_on(sv);
		PL_curpad[ix] = sv;
	    }
	}
    }
}

d1417 6
d1453 1
a1453 1
    djSP; dPOPTOPssrl;
d1462 1
a1462 1
    djSP;
d1471 1
a1471 1
    djSP;
d1480 1
a1480 1
    djSP;
d1560 1
d1565 1
a1565 1
	/* try blocks have old_namesv == 0 */
d1570 5
d1591 1
a1591 1
	    AvREAL_off(PL_dbargs);		/* XXX Should be REIFY */
d1607 3
a1609 1
	if  (old_warnings == pWARN_NONE || old_warnings == pWARN_STD)
d1611 2
a1612 1
        else if (old_warnings == pWARN_ALL)
d1623 1
a1623 1
    djSP;
d1650 1
a1650 1
	djSP;
d1694 1
a1694 1
    djSP; dMARK;
a1707 1
	dTHR;
d1715 1
d1718 2
a1719 1
#ifdef USE_ITHREADS
d1773 1
a1773 1
    djSP;
d1789 1
a1789 1
    djSP;
d1829 1
a1829 1
    djSP; dMARK;
a1868 2
	if (AvFILLp(PL_comppad_name) >= 0)
	    free_closures();
d1938 1
a1938 1
    djSP;
d2026 1
a2026 1
    I32 oldsave;
d2041 3
d2045 2
a2046 6

    /* clean scope, but only if there's no continue block */
    if (!(cx->blk_loop.last_op->op_private & OPpLOOP_CONTINUE)) {
	oldsave = PL_scopestack[PL_scopestack_ix - 1];
	LEAVE_SCOPE(oldsave);
    }
a2094 1
	dTHR;
d2125 1
a2125 1
    djSP;
d2342 1
d2502 1
a2502 1
    djSP;
d2523 1
a2523 1
    djSP;
d2542 1
a2542 1
    djSP;
a2604 1
    dTHR;
d2668 1
a2668 1
	SAVECOPSTASH(&PL_compiling);
a2670 2
    SAVECOPFILE(&PL_compiling);
    SAVECOPLINE(&PL_compiling);
d2680 1
d2682 1
d2702 1
a2702 1
    PUSHBLOCK(cx, CXt_EVAL, SP);
d2731 3
a2733 1
    PL_in_eval = EVAL_INEVAL;
d2793 1
a2793 1
    SAVEFREESV(PL_compcv);
d2804 1
d2896 1
d2941 1
a2941 1
    djSP;
d2959 3
a2961 3
	UV rev, ver, sver;
	if (SvPOKp(sv)) {		/* require v5.6.1 */
	    I32 len;
d2965 1
a2965 1
		rev = utf8_to_uv(s, &len);
d2968 1
a2968 1
		    ver = utf8_to_uv(s, &len);
d2971 1
a2971 3
			sver = utf8_to_uv(s, &len);
		    else
			sver = 0;
a2972 2
		else
		    ver = 0;
a2973 2
	    else
		rev = 0;
d2984 1
d3013 1
a3014 1
	RETPUSHYES;
d3027 15
d3050 1
d3083 4
a3086 1
		    count = call_sv(loader, G_ARRAY);
d3107 1
a3107 1
				if (IoTYPE(io) == '|') {
d3171 4
d3184 1
d3187 8
d3205 1
a3205 1
    SAVECOPFILE(&PL_compiling);
d3295 1
a3295 1
    djSP;
a3314 1
    SAVECOPFILE(&PL_compiling);
d3324 1
d3326 1
d3338 5
a3342 3
    if (!specialWARN(PL_compiling.cop_warnings)) {
        PL_compiling.cop_warnings = newSVsv(PL_compiling.cop_warnings) ;
        SAVEFREESV(PL_compiling.cop_warnings) ;
d3372 1
a3372 1
    djSP;
a3413 3
    if (AvFILLp(PL_comppad_name) >= 0)
	free_closures();

d3440 1
a3440 1
    djSP;
d3460 1
a3460 1
    djSP;
a4372 1
    dTHR;
a4395 1
    dTHR;
d4601 1
a4601 1
	djSP;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d20 1
d29 11
d41 2
a42 1
#define CALLOP this->*PL_op
d44 2
a45 13
#define CALLOP *PL_op
static OP *docatch _((OP *o));
static OP *dofindlabel _((OP *o, char *label, OP **opstack, OP **oplimit));
static void doparseform _((SV *sv));
static I32 dopoptoeval _((I32 startingblock));
static I32 dopoptolabel _((char *label));
static I32 dopoptoloop _((I32 startingblock));
static I32 dopoptosub _((I32 startingblock));
static I32 dopoptosub_at _((PERL_CONTEXT *cxstk, I32 startingblock));
static void save_lines _((AV *array, SV *sv));
static I32 sortcv _((SV *a, SV *b));
static void qsortsv _((SV **array, size_t num_elts, I32 (*fun)(SV *a, SV *b)));
static OP *doeval _((int gimme, OP** startop));
d117 3
a119 1
	    pm->op_pmregexp = CALLREGCOMP(t, t + len, pm);
d139 1
d142 2
d145 1
d165 1
a165 1
	    DIE("Substitution loop");
d172 5
a176 3
	if (cx->sb_once || !CALLREGEXEC(rx, s, cx->sb_strend, orig,
				     s == m, Nullsv, NULL,
				     cx->sb_safebase ? 0 : REXEC_COPY_STR))
d204 1
a204 1
    if (rx->subbase && rx->subbase != orig) {
d207 1
a207 1
	cx->sb_orig = orig = rx->subbase;
d211 1
a211 1
    cx->sb_m = m = rx->startp[0];
d213 1
a213 1
    cx->sb_s = rx->endp[0];
d220 1
a220 1
rxres_save(void **rsp, REGEXP *rx)
d234 2
a235 2
    *p++ = (UV)rx->subbase;
    rx->subbase = Nullch;
d239 2
a240 2
    *p++ = (UV)rx->subbeg;
    *p++ = (UV)rx->subend;
d248 1
a248 1
rxres_restore(void **rsp, REGEXP *rx)
d253 3
a255 2
    Safefree(rx->subbase);
    rx->subbase = (char*)(*p);
d260 2
a261 2
    rx->subbeg = (char*)(*p++);
    rx->subend = (char*)(*p++);
d263 2
a264 2
	rx->startp[i] = (char*)(*p++);
	rx->endp[i] = (char*)(*p++);
d269 1
a269 1
rxres_free(void **rsp)
d274 1
a274 1
	Safefree((char*)(*p));
d298 1
a298 1
    double value;
d301 2
d305 7
a311 2
	SvREADONLY_off(tmpForm);
	doparseform(tmpForm);
d315 1
a315 1
    t = SvGROW(PL_formtarget, len + SvCUR(tmpForm) + 1);  /* XXX SvCUR bad */
d347 1
a347 1
		PerlIO_printf(PerlIO_stderr(), "%-16s%ld\n", name, (long) arg);
d349 1
a349 1
		PerlIO_printf(PerlIO_stderr(), "%-16s\n", name);
d377 2
a378 2
		if (PL_dowarn)
		    warn("Not enough format arguments");
d385 26
d427 43
d525 20
d568 1
d582 1
a582 1
		SvGROW(PL_formtarget, SvCUR(PL_formtarget) + SvCUR(tmpForm) + 1);
d600 19
a618 5
	    SET_NUMERIC_LOCAL();
	    if (arg & 256) {
		sprintf(t, "%#*.*f", (int) fieldsize, (int) arg & 255, value);
	    } else {
		sprintf(t, "%*.0f", (int) fieldsize, value);
d640 1
a640 1
			    DIE("Runaway format");
d696 1
a696 1
	    XPUSHs(&PL_sv_no);
d700 2
a701 2
    pp_pushmark(ARGS);				/* push dst */
    pp_pushmark(ARGS);				/* push src */
d705 2
a706 6
#ifdef USE_THREADS
    /* SAVE_DEFSV does *not* suffice here */
    save_sptr(&THREADSV(0));
#else
    SAVESPTR(GvSV(PL_defgv));
#endif /* USE_THREADS */
d708 1
a708 1
    SAVESPTR(PL_curpm);
d716 1
a716 1
	pp_pushmark(ARGS);			/* push top */
d722 1
a722 1
    DIE("panic: mapstart");	/* uses grepstart */
d778 1
a778 1
	SAVESPTR(PL_curpm);
a787 55
#define tryCALL_AMAGICbin(left,right,meth,svp) STMT_START { \
	  *svp = Nullsv;				\
          if (PL_amagic_generation) { \
	    if (SvAMAGIC(left)||SvAMAGIC(right))\
		*svp = amagic_call(left, \
				   right, \
				   CAT2(meth,_amg), \
				   0); \
	  } \
	} STMT_END

STATIC I32
amagic_cmp(register SV *str1, register SV *str2)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(str1,str2,scmp,&tmpsv);
    if (tmpsv) {
    	double d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_cmp(str1, str2);
}

STATIC I32
amagic_cmp_locale(register SV *str1, register SV *str2)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(str1,str2,scmp,&tmpsv);
    if (tmpsv) {
    	double d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_cmp_locale(str1, str2);
}

d800 2
d809 1
a809 1
    SAVEPPTR(PL_sortcop);
d816 1
a816 1
	    stash = PL_curcop->cop_stash;
d820 7
d828 4
a831 1
		if (gv) {
d834 1
a834 3
		    if (cv && CvXSUB(cv))
			DIE("Xsub \"%s\" called in sort", SvPVX(tmpstr));
		    DIE("Undefined sort subroutine \"%s\" called",
d837 11
a847 10
		if (cv) {
		    if (CvXSUB(cv))
			DIE("Xsub called in sort");
		    DIE("Undefined subroutine in sort");
		}
		DIE("Not a CODE reference in sort");
	    }
	    PL_sortcop = CvSTART(cv);
	    SAVESPTR(CvROOT(cv)->op_ppaddr);
	    CvROOT(cv)->op_ppaddr = ppaddr[OP_NULL];
d849 3
a851 2
	    SAVESPTR(PL_curpad);
	    PL_curpad = AvARRAY((AV*)AvARRAY(CvPADLIST(cv))[1]);
d856 1
a856 1
	stash = PL_curcop->cop_stash;
d862 1
a862 1
	if (*up = *++MARK) {			/* Weed out nulls. */
d865 1
d868 1
a868 2
	        else {
		    STRLEN n_a;
a869 1
		}
a896 1
		bool hasargs = FALSE;
d904 13
a916 1
	    qsortsv((myorigmark+1), max, FUNC_NAME_TO_PTR(sortcv));
d919 1
d928 18
a945 7
		    (PL_op->op_private & OPpLOCALE)
		    ? ( overloading
		        ? FUNC_NAME_TO_PTR(amagic_cmp_locale)
		        : FUNC_NAME_TO_PTR(sv_cmp_locale))
		    : ( overloading 
		        ? FUNC_NAME_TO_PTR(amagic_cmp)
		        : FUNC_NAME_TO_PTR(sv_cmp) ));
d958 5
a962 2
	return cCONDOP->op_true;
    return SvTRUEx(PAD_SV(PL_op->op_targ)) ? cCONDOP->op_false : cCONDOP->op_true;
d970 1
a970 1
	RETURNOP(((CONDOP*)cUNOP->op_first)->op_false);
d988 1
a988 1
		RETURNOP(((CONDOP*)cUNOP->op_first)->op_false);
d1007 5
d1013 3
a1015 1
	  (looks_like_number(left) && *SvPVX(left) != '0') )
d1018 1
a1018 1
		croak("Range iterator outside integer range");
d1035 1
a1035 2
	    STRLEN len;
	    STRLEN n_a;
d1068 1
a1068 1
dopoptolabel(char *label)
d1078 3
a1080 2
	    if (PL_dowarn)
		warn("Exiting substitution via %s", op_name[PL_op->op_type]);
d1083 8
a1090 2
	    if (PL_dowarn)
		warn("Exiting subroutine via %s", op_name[PL_op->op_type]);
d1093 3
a1095 2
	    if (PL_dowarn)
		warn("Exiting eval via %s", op_name[PL_op->op_type]);
d1098 3
a1100 2
	    if (PL_dowarn)
		warn("Exiting pseudo-block via %s", op_name[PL_op->op_type]);
d1105 1
a1105 1
		DEBUG_l(deb("(Skipping label #%ld %s)\n",
d1109 1
a1109 1
	    DEBUG_l( deb("(Found label #%ld %s)\n", (long)i, label));
d1117 1
a1117 1
dowantarray(void)
d1124 1
a1124 1
block_gimme(void)
d1141 1
a1141 1
	croak("panic: bad gimme: %d\n", cxstack[cxix].blk_gimme);
d1148 1
a1148 1
dopoptosub(I32 startingblock)
d1155 1
a1155 1
dopoptosub_at(PERL_CONTEXT *cxstk, I32 startingblock)
d1167 2
a1168 1
	    DEBUG_l( deb("(Found sub #%ld)\n", (long)i));
d1176 1
a1176 1
dopoptoeval(I32 startingblock)
d1187 1
a1187 1
	    DEBUG_l( deb("(Found eval #%ld)\n", (long)i));
d1195 1
a1195 1
dopoptoloop(I32 startingblock)
d1204 3
a1206 2
	    if (PL_dowarn)
		warn("Exiting substitution via %s", op_name[PL_op->op_type]);
d1209 8
a1216 2
	    if (PL_dowarn)
		warn("Exiting subroutine via %s", op_name[PL_op->op_type]);
d1219 3
a1221 2
	    if (PL_dowarn)
		warn("Exiting eval via %s", op_name[PL_op->op_type]);
d1224 3
a1226 2
	    if (PL_dowarn)
		warn("Exiting pseudo-block via %s", op_name[PL_op->op_type]);
d1229 1
a1229 1
	    DEBUG_l( deb("(Found loop #%ld)\n", (long)i));
d1237 1
a1237 1
dounwind(I32 cxix)
a1240 1
    SV **newsp;
d1244 1
d1247 1
a1247 1
			      (long) cxstack_ix, block_type[CxTYPE(cx)]));
d1254 2
a1255 1
	    POPSUB(cx);
d1265 3
d1273 48
d1322 1
a1322 1
die_where(char *message)
a1323 1
    dSP;
d1332 19
a1350 16
	    if (PL_in_eval & 4) {
		SV **svp;
		STRLEN klen = strlen(message);
		
		svp = hv_fetch(ERRHV, message, klen, TRUE);
		if (svp) {
		    if (!SvIOK(*svp)) {
			static char prefix[] = "\t(in cleanup) ";
			SV *err = ERRSV;
			sv_upgrade(*svp, SVt_IV);
			(void)SvIOK_only(*svp);
			if (!SvPOK(err))
			    sv_setpv(err,"");
			SvGROW(err, SvCUR(err)+sizeof(prefix)+klen);
			sv_catpvn(err, prefix, sizeof(prefix)-1);
			sv_catpvn(err, message, klen);
a1351 1
		    sv_inc(*svp);
d1355 1
a1355 1
		sv_setpv(ERRSV, message);
d1358 1
a1358 1
	    message = SvPVx(ERRSV, n_a);
d1360 3
a1362 1
	while ((cxix = dopoptoeval(cxstack_ix)) < 0 && PL_curstackinfo->si_prev) {
d1375 2
a1376 1
		PerlIO_printf(PerlIO_stderr(), "panic: die %s", message);
d1389 2
a1390 1
		DIE("%s", *msg ? msg : "Compilation failed in require");
d1395 15
a1409 4
    if(!message)
	message = SvPVx(ERRSV, n_a);
    PerlIO_printf(PerlIO_stderr(), "%s",message);
    PerlIO_flush(PerlIO_stderr());
d1451 1
a1451 1
    HV *hv;
d1457 1
a1457 1
    EXTEND(SP, 6);
d1479 1
a1479 1
    if (CxTYPE(cx) == CXt_SUB) {
d1487 1
d1489 1
a1489 2
	hv = cx->blk_oldcop->cop_stash;
	if (!hv)
d1493 1
a1493 1
	    sv_setpv(TARG, HvNAME(hv));
d1499 1
a1499 2
    hv = cx->blk_oldcop->cop_stash;
    if (!hv)
d1502 3
a1504 3
	PUSHs(sv_2mortal(newSVpv(HvNAME(hv), 0)));
    PUSHs(sv_2mortal(newSVpv(SvPVX(GvSV(cx->blk_oldcop->cop_filegv)), 0)));
    PUSHs(sv_2mortal(newSViv((I32)cx->blk_oldcop->cop_line)));
d1507 2
a1508 1
    if (CxTYPE(cx) == CXt_SUB) { /* So is ccstack[dbcxix]. */
d1515 1
a1515 1
	PUSHs(sv_2mortal(newSVpv("(eval)",0)));
d1527 4
a1530 4
	} 
	else if (cx->blk_eval.old_name) { /* Try blocks have old_name == 0. */
	    /* Require, put the name. */
	    PUSHs(sv_2mortal(newSVpv(cx->blk_eval.old_name, 0)));
d1534 6
a1539 3
    else if (CxTYPE(cx) == CXt_SUB &&
	    cx->blk_sub.hasargs &&
	    PL_curcop->cop_stash == PL_debstash)
d1557 16
a1575 24
STATIC I32
sortcv(SV *a, SV *b)
{
    dTHR;
    I32 oldsaveix = PL_savestack_ix;
    I32 oldscopeix = PL_scopestack_ix;
    I32 result;
    GvSV(PL_firstgv) = a;
    GvSV(PL_secondgv) = b;
    PL_stack_sp = PL_stack_base;
    PL_op = PL_sortcop;
    CALLRUNOPS();
    if (PL_stack_sp != PL_stack_base + 1)
	croak("Sort subroutine didn't return single value");
    if (!SvNIOKp(*PL_stack_sp))
	croak("Sort subroutine didn't return a numeric value");
    result = SvIV(*PL_stack_sp);
    while (PL_scopestack_ix > oldscopeix) {
	LEAVE;
    }
    leave_scope(oldsaveix);
    return result;
}

d1586 1
a1586 1
    sv_reset(tmps, PL_curcop->cop_stash);
d1615 1
a1615 1
	    DIE("No DB::DB routine defined");
d1634 1
a1634 1
	SAVESPTR(PL_curpad);
d1653 4
d1673 4
d1679 2
a1680 1
	svp = &GvSV((GV*)POPs);			/* symbol table variable */
d1683 3
d1690 4
a1693 1
    PUSHBLOCK(cx, CXt_LOOP, SP);
d1695 1
d1701 5
a1705 1
		(looks_like_number(sv) && *SvPVX(sv) != '0')) {
d1708 1
a1708 1
		     croak("Range iterator outside integer range");
a1744 1
    struct block_loop cxloop;
d1752 1
a1752 1
    POPLOOP1(cx);	/* Delay POPLOOP2 until stack values are safe */
d1772 1
a1772 1
    POPLOOP2();		/* Stack values are safe: release loop vars ... */
a1785 1
    struct block_sub cxsub;
d1787 1
d1792 1
d1795 3
a1797 1
	if (cxstack_ix == PL_sortcxix || dopoptosub(cxstack_ix) <= PL_sortcxix) {
d1808 1
a1808 1
	DIE("Can't return outside a subroutine");
a1814 1
	POPSUB1(cx);	/* Delay POPSUB2 until stack values are safe */
d1818 2
d1821 5
d1830 3
a1832 3
	    char *name = cx->blk_eval.old_name;
	    (void)hv_delete(GvHVn(PL_incgv), name, strlen(name), G_DISCARD);
	    DIE("%s did not return a true value", name);
d1835 3
d1839 1
a1839 1
	DIE("panic: return");
d1846 1
a1846 1
		if (cxsub.cv && CvDEPTH(cxsub.cv) > 1) {
d1851 3
a1853 1
		    } else {
d1855 2
a1856 1
			*++newsp = sv_mortalcopy(*SP);
d1858 2
a1859 1
		} else
d1861 2
a1862 1
	    } else
d1864 2
a1865 1
	} else
d1879 1
a1879 1
	POPSUB2();	/* release CV and @@_ ... */
d1881 2
d1886 3
a1896 2
    struct block_loop cxloop;
    struct block_sub cxsub;
d1903 2
a1904 1
    SV **mark = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;
d1909 1
a1909 1
	    DIE("Can't \"last\" outside a block");
d1914 1
a1914 1
	    DIE("Label not found for \"last %s\"", cPVOP->op_pv);
d1920 1
a1922 1
	POPLOOP1(cx);	/* Delay POPLOOP2 until stack values are safe */
d1924 2
a1925 1
	nextop = cxloop.last_op->op_next;
a1927 1
	POPSUB1(cx);	/* Delay POPSUB2 until stack values are safe */
d1935 4
d1940 1
a1940 1
	DIE("panic: last");
d1964 1
a1964 1
	POPLOOP2();	/* release loop vars ... */
d1968 1
a1968 1
	POPSUB2();	/* release CV and @@_ ... */
d1974 1
d1987 1
a1987 1
	    DIE("Can't \"next\" outside a block");
d1992 1
a1992 1
	    DIE("Label not found for \"next %s\"", cPVOP->op_pv);
d1998 6
a2003 2
    oldsave = PL_scopestack[PL_scopestack_ix - 1];
    LEAVE_SCOPE(oldsave);
d2016 1
a2016 1
	    DIE("Can't \"redo\" outside a block");
d2021 1
a2021 1
	    DIE("Label not found for \"redo %s\"", cPVOP->op_pv);
d2033 1
a2033 1
dofindlabel(OP *o, char *label, OP **opstack, OP **oplimit)
d2040 1
a2040 1
	croak(too_deep);
d2048 1
a2048 1
	    croak(too_deep);
d2067 1
a2067 1
	    if (o = dofindlabel(kid, label, ops, oplimit))
d2077 1
a2077 1
    return pp_goto(ARGS);
d2091 1
a2105 1
	    int arg_was_real = 0;
d2122 1
a2122 1
		    DIE("Goto undefined subroutine &%s",SvPVX(tmpstr));
d2124 1
a2124 1
		DIE("Goto undefined subroutine");
d2130 1
a2130 1
		DIE("Can't goto subroutine outside a subroutine");
d2135 1
a2135 1
		DIE("Can't goto subroutine from an eval-string");
d2137 2
a2138 2
	    if (CxTYPE(cx) == CXt_SUB &&
		cx->blk_sub.hasargs) {   /* put @@_ back onto stack */
d2150 1
d2152 5
a2156 2
		    arg_was_real = 1;
		    AvREAL_off(av);	/* so av_clear() won't clobber elts */
a2157 1
		av_clear(av);
a2160 1
		int i;
d2181 1
d2183 1
a2183 1
		    I32 (*fp3)_((int,int,int));
d2188 1
a2188 1
		    fp3 = (I32(*)_((int,int,int)))CvXSUB(cv);
d2194 3
a2196 1
		else {
d2203 1
a2203 1
		    (void)(*CvXSUB(cv))(cv _PERL_OBJECT_THIS);
d2226 1
a2226 1
		    if (CvDEPTH(cv) == 100 && PL_dowarn)
d2232 1
d2235 1
a2235 1
			    if (svp[ix] != &PL_sv_undef) {
d2254 3
d2287 1
a2287 1
		SAVESPTR(PL_curpad);
d2318 1
a2318 5
		    /* preserve @@_ nature */
		    if (arg_was_real) {
			AvREIFY_off(av);
			AvREAL_on(av);
		    }
d2334 1
a2334 1
			SvIVX(sv) = (IV)cv; /* Already upgraded, saved */
d2340 1
a2340 1
			  && (gotocv = perl_get_cv("DB::goto", FALSE)) ) {
d2342 1
a2342 1
			perl_call_sv((SV*)gotocv, G_SCALAR | G_NODEBUG);
d2349 1
a2349 1
	else
d2351 3
d2357 1
a2357 1
	    DIE("goto must have label");
d2392 1
d2394 1
a2394 1
		DIE("Can't \"goto\" outside a block");
d2397 1
a2397 1
		    DIE("panic: goto");
d2401 6
a2406 4
	    retop = dofindlabel(gotoprobe, label,
				enterops, enterops + GOTO_DEPTH);
	    if (retop)
		break;
d2410 1
a2410 1
	    DIE("Can't find label %s", label);
d2434 2
a2435 3
		    DIE("Can't \"goto\" into the middle of a foreach loop",
			label);
		(CALLOP->op_ppaddr)(ARGS);
d2466 2
a2467 2
#ifdef VMSISH_EXIT
	if (anum == 1 && VMSISH_EXIT)
d2471 1
d2481 1
a2481 1
    double value = SvNVx(GvSV(cCOP->cop_gv));
d2485 1
a2485 1
	if (((double)match) > value)
d2521 1
a2521 1
save_lines(AV *array, SV *sv)
d2544 15
d2560 1
a2560 1
docatch(OP *o)
d2565 1
a2567 1
    PL_op = o;
a2569 1
    DEBUG_l(deb("Setting up local jumplevel %p, was %p\n", &cur_env, PL_top_env));
d2571 5
d2577 1
d2579 14
a2592 2
    default:				/* topmost level handles it */
pass_the_buck:
a2596 9
    case 3:
	if (!PL_restartop)
	    goto pass_the_buck;
	PL_op = PL_restartop;
	PL_restartop = 0;
	/* FALL THROUGH */
    case 0:
        CALLRUNOPS();
	break;
d2604 1
a2604 1
sv_compile_2op(SV *sv, OP** startop, char *code, AV** avp)
d2615 3
a2617 2
    OP *oop = PL_op, *rop;
    char tmpbuf[TYPE_DIGITS(long) + 12 + 10];
d2626 2
a2627 2
	SAVESPTR(PL_compiling.cop_stash);
	PL_compiling.cop_stash = PL_curstash;
d2629 13
a2641 5
    SAVESPTR(PL_compiling.cop_filegv);
    SAVEI16(PL_compiling.cop_line);
    sprintf(tmpbuf, "_<(%.10s_eval %lu)", code, (unsigned long)++PL_evalseq);
    PL_compiling.cop_filegv = gv_fetchfile(tmpbuf+2);
    PL_compiling.cop_line = 1;
d2653 1
a2653 1
    SAVEPPTR(PL_op);
d2658 1
a2658 1
    PL_op->op_type = 0;			/* Avoid uninit warning. */
d2661 1
a2661 1
    PUSHEVAL(cx, 0, PL_compiling.cop_filegv);
d2667 1
a2667 1
    (*startop)->op_ppaddr = ppaddr[OP_NULL];
d2671 2
d2681 1
a2681 1
doeval(int gimme, OP** startop)
a2684 1
    HV *newstash;
d2689 1
a2689 1
    PL_in_eval = 1;
d2696 1
a2696 1
    SAVESPTR(PL_curpad);
d2708 1
a2708 1
	else if (CxTYPE(cx) == CXt_SUB) {
d2732 1
a2732 1
    av_store(PL_comppad_name, 0, newSVpv("@@_", 2));
d2743 3
a2745 1
    if (!saveop || saveop->op_type != OP_REQUIRE)
d2747 1
d2753 1
a2753 2
    newstash = PL_curcop->cop_stash;
    if (PL_curstash != newstash) {
d2755 1
a2755 1
	PL_curstash = newstash;
d2768 1
a2768 1
    PL_rs = newSVpv("\n", 1);
d2770 1
a2770 1
	PL_in_eval |= 4;
d2779 1
a2779 1

d2795 4
a2798 2
	    DIE("%s", *msg ? msg : "Compilation failed in require");
	} else if (startop) {
d2803 2
a2804 1
	    croak("%sCompilation failed in regexp", (*msg ? msg : "Unknown error\n"));
d2818 1
a2818 1
    PL_compiling.cop_line = 0;
d2836 1
a2836 1
	CV *cv = perl_get_cv("DB::postponed", FALSE);
d2840 1
a2840 1
	    XPUSHs((SV*)PL_compiling.cop_filegv);
d2842 1
a2842 1
	    perl_call_sv((SV*)cv, G_DISCARD);
d2861 33
a2893 1
PP(pp_require)
d2906 4
d2912 61
a2972 5
    if (SvNIOKp(sv) && !SvPOKp(sv)) {
	SET_NUMERIC_STANDARD();
	if (atof(PL_patchlevel) + 0.00000999 < SvNV(sv))
	    DIE("Perl %s required--this is only version %s, stopped",
		SvPV(sv,n_a),PL_patchlevel);
d2977 1
a2977 1
	DIE("Null filename used");
d2986 3
a2988 15
    if (*name == '/' ||
	(*name == '.' && 
	    (name[1] == '/' ||
	     (name[1] == '.' && name[2] == '/')))
#ifdef DOSISH
      || (name[0] && name[1] == ':')
#endif
#ifdef WIN32
      || (name[0] == '\\' && name[1] == '\\')	/* UNC path */
#endif
#ifdef VMS
	|| (strchr(name,':')  || ((*name == '[' || *name == '<') &&
	    (isALNUM(name[1]) || strchr("$-_]>",name[1]))))
#endif
    )
d2991 1
a2991 1
	tryrsfp = PerlIO_open(name,PERL_SCRIPT_MODE);
d3003 108
a3110 1
		char *dir = SvPVx(*av_fetch(ar, i, TRUE), n_a);
d3112 5
a3116 5
		char *unixdir;
		if ((unixdir = tounixpath(dir, Nullch)) == Nullch)
		    continue;
		sv_setpv(namesv, unixdir);
		sv_catpv(namesv, unixname);
d3118 1
a3118 1
		sv_setpvf(namesv, "%s/%s", dir, name);
d3120 8
a3127 7
		TAINT_PROPER("require");
		tryname = SvPVX(namesv);
		tryrsfp = PerlIO_open(tryname, PERL_SCRIPT_MODE);
		if (tryrsfp) {
		    if (tryname[0] == '.' && tryname[1] == '/')
			tryname += 2;
		    break;
d3132 2
a3133 2
    SAVESPTR(PL_compiling.cop_filegv);
    PL_compiling.cop_filegv = gv_fetchfile(tryrsfp ? tryname : name);
d3137 22
a3158 17
	    SV *msg = sv_2mortal(newSVpvf("Can't locate %s in @@INC", name));
	    SV *dirmsgsv = NEWSV(0, 0);
	    AV *ar = GvAVn(PL_incgv);
	    I32 i;
	    if (instr(SvPVX(msg), ".h "))
		sv_catpv(msg, " (change .h to .ph maybe?)");
	    if (instr(SvPVX(msg), ".ph "))
		sv_catpv(msg, " (did you run h2ph?)");
	    sv_catpv(msg, " (@@INC contains:");
	    for (i = 0; i <= AvFILL(ar); i++) {
		char *dir = SvPVx(*av_fetch(ar, i, TRUE), n_a);
		sv_setpvf(dirmsgsv, " %s", dir);
	        sv_catsv(msg, dirmsgsv);
	    }
	    sv_catpvn(msg, ")", 1);
    	    SvREFCNT_dec(dirmsgsv);
	    DIE("%_", msg);
d3168 1
a3168 1
	newSVsv(GvSV(PL_compiling.cop_filegv)), 0 );
d3172 1
a3172 1
    lex_start(sv_2mortal(newSVpv("",0)));
a3176 2
    name = savepv(name);
    SAVEFREEPV(name);
d3179 16
a3194 1
 
a3195 1

d3198 1
a3198 1
    PUSHEVAL(cx, name, PL_compiling.cop_filegv);
d3200 2
a3201 2
    SAVEI16(PL_compiling.cop_line);
    PL_compiling.cop_line = 0;
d3217 1
a3217 1
    return pp_require(ARGS);
d3226 2
a3227 1
    char tmpbuf[TYPE_DIGITS(long) + 12];
d3242 12
a3253 4
    SAVESPTR(PL_compiling.cop_filegv);
    sprintf(tmpbuf, "_<(eval %lu)", (unsigned long)++PL_evalseq);
    PL_compiling.cop_filegv = gv_fetchfile(tmpbuf+2);
    PL_compiling.cop_line = 1;
d3263 5
d3271 1
a3271 1
    PUSHEVAL(cx, 0, PL_compiling.cop_filegv);
d3276 1
a3276 1
	save_lines(GvAV(PL_compiling.cop_filegv), PL_linestr);
d3325 1
d3338 2
a3339 29
    /*
     * Closures mentioned at top level of eval cannot be referenced
     * again, and their presence indirectly causes a memory leak.
     * (Note that the fact that compcv and friends are still set here
     * is, AFAIK, an accident.)  --Chip
     */
    if (AvFILLp(PL_comppad_name) >= 0) {
	SV **svp = AvARRAY(PL_comppad_name);
	I32 ix;
	for (ix = AvFILLp(PL_comppad_name); ix >= 0; ix--) {
	    SV *sv = svp[ix];
	    if (sv && sv != &PL_sv_undef && *SvPVX(sv) == '&') {
		SvREFCNT_dec(sv);
		svp[ix] = &PL_sv_undef;

		sv = PL_curpad[ix];
		if (CvCLONE(sv)) {
		    SvREFCNT_dec(CvOUTSIDE(sv));
		    CvOUTSIDE(sv) = Nullcv;
		}
		else {
		    SvREFCNT_dec(sv);
		    sv = NEWSV(0,0);
		    SvPADTMP_on(sv);
		    PL_curpad[ix] = sv;
		}
	    }
	}
    }
d3351 3
a3353 3
	char *name = cx->blk_eval.old_name;
	(void)hv_delete(GvHVn(PL_incgv), name, strlen(name), G_DISCARD);
	retop = die("%s did not return a true value", name);
d3375 1
a3375 1
    PUSHBLOCK(cx, CXt_EVAL, SP);
d3379 1
a3379 1
    PL_in_eval = 1;
d3433 1
a3433 1
doparseform(SV *sv)
d3450 1
a3450 1
	croak("Null picture in formline");
a3715 1
#ifdef PERL_OBJECT
d3717 1
a3717 5
   ((this->*compare)(array[elt1], array[elt2]))
#else
#define qsort_cmp(elt1, elt2) \
   ((*compare)(array[elt1], array[elt2]))
#endif
d3798 1
a3798 8
#ifdef PERL_OBJECT
qsortsv(SV ** array, size_t num_elts, SVCOMPARE compare)
#else
qsortsv(
   SV ** array,
   size_t num_elts,
   I32 (*compare)(SV *a, SV *b))
#endif
d4026 1
a4026 1
            while (still_work_on_left = (u_right >= part_left)) {
d4047 1
a4047 1
            while (still_work_on_right = (u_left <= part_right)) {
d4288 307
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d28 4
d33 1
a33 2
static OP *doeval _((int gimme));
static OP *dofindlabel _((OP *op, char *label, OP **opstack, OP **oplimit));
d39 1
d41 4
a44 5
static int sortcv _((const void *, const void *));
static int sortcmp _((const void *, const void *));
static int sortcmp_locale _((const void *, const void *));

static I32 sortcxix;
d48 1
a48 1
    dSP;
d71 11
a81 2
PP(pp_regcomp) {
    dSP;
d86 1
d89 24
a112 1
    t = SvPV(tmpstr, len);
d114 4
a117 7
    /* JMR: Check against the last compiled regexp */
    if ( ! pm->op_pmregexp  || ! pm->op_pmregexp->precomp
	|| strnNE(pm->op_pmregexp->precomp, t, len) 
	|| pm->op_pmregexp->precomp[len]) {
	if (pm->op_pmregexp) {
	    pregfree(pm->op_pmregexp);
	    pm->op_pmregexp = Null(REGEXP*);	/* crucial if regcomp aborts */
d119 1
d121 6
a126 2
	pm->op_pmflags = pm->op_pmpermflags;	/* reset case sensitivity */
	pm->op_pmregexp = pregcomp(t, t + len, pm);
d128 1
d130 2
a131 2
    if (!pm->op_pmregexp->prelen && curpm)
	pm = curpm;
d137 1
a137 2
	hoistmust(pm);
	cLOGOP->op_first->op_next = op->op_next;
d144 1
a144 1
    dSP;
d146 1
a146 1
    register CONTEXT *cx = &cxstack[cxstack_ix];
d159 2
a160 2
	if (!cx->sb_rxtainted)
	    cx->sb_rxtainted = SvTAINTED(TOPs);
d164 3
a166 2
	if (cx->sb_once || !pregexec(rx, s, cx->sb_strend, orig,
				s == m, Nullsv, cx->sb_safebase))
d171 1
a171 1
	    TAINT_IF(cx->sb_rxtainted || rx->exec_tainted);
d180 4
d185 1
a188 1
	    PUSHs(sv_2mortal(newSViv((I32)cx->sb_iters - 1)));
d204 1
a204 1
    cx->sb_rxtainted |= rx->exec_tainted;
d210 1
a210 3
rxres_save(rsp, rx)
void **rsp;
REGEXP *rx;
d238 1
a238 3
rxres_restore(rsp, rx)
void **rsp;
REGEXP *rx;
d258 1
a258 2
rxres_free(rsp)
void **rsp;
d271 2
a272 2
    dSP; dMARK; dORIGMARK;
    register SV *form = *++MARK;
d284 1
a284 1
    bool chopspace = (strchr(chopset, ' ') != Nullch);
d291 3
a293 3
    if (!SvMAGICAL(form) || !SvCOMPILED(form)) {
	SvREADONLY_off(form);
	doparseform(form);
d296 2
a297 2
    SvPV_force(formtarget, len);
    t = SvGROW(formtarget, len + SvCUR(form) + 1);  /* XXX SvCUR bad */
d299 1
a299 1
    f = SvPV(form, len);
d301 1
a301 1
    s = f + len + WORD_ALIGN - SvCUR(form) % WORD_ALIGN;
d358 2
a359 2
		sv = &sv_no;
		if (dowarn)
d407 1
a407 1
			if (strchr(chopset, *s))
d439 1
a439 1
#if 'z' - 'a' != 25
d441 1
a441 2
		if (!iscntrl(ch))
		    t[-1] = ' ';
d444 1
a445 2
#endif

d472 4
a475 4
		SvCUR_set(formtarget, t - SvPVX(formtarget));
		sv_catpvn(formtarget, item, itemsize);
		SvGROW(formtarget, SvCUR(formtarget) + SvCUR(form) + 1);
		t = SvPVX(formtarget) + SvCUR(formtarget);
d513 2
a514 2
		    SvCUR_set(formtarget, t - SvPVX(formtarget));
		    lines += FmLINES(formtarget);
d520 1
a520 1
		    FmLINES(formtarget) = lines;
d532 7
a538 1
	    if (itemsize) {
d547 1
a547 1
		    while (s > SvPVX(formtarget) && isSPACE(s[-1]))
d558 2
a559 2
	    SvCUR_set(formtarget, t - SvPVX(formtarget));
	    FmLINES(formtarget) += lines;
d568 1
a568 1
    dSP;
d571 1
a571 1
    if (stack_base + *markstack_ptr == sp) {
d574 2
a575 2
	    XPUSHs(&sv_no);
	RETURNOP(op->op_next->op_next);
d577 3
a579 3
    stack_sp = stack_base + *markstack_ptr + 1;
    pp_pushmark();				/* push dst */
    pp_pushmark();				/* push src */
d583 6
a588 2
    SAVESPTR(GvSV(defgv));

d590 1
a590 1
    SAVESPTR(curpm);
d592 1
a592 1
    src = stack_base[*markstack_ptr];
d594 1
a594 1
    GvSV(defgv) = src;
d597 3
a599 3
    if (op->op_type == OP_MAPSTART)
	pp_pushmark();				/* push top */
    return ((LOGOP*)op->op_next)->op_other;
d609 2
a610 2
    dSP;
    I32 diff = (sp - stack_base) - *markstack_ptr;
d616 1
a616 1
    ++markstack_ptr[-1];
d618 3
a620 3
	if (diff > markstack_ptr[-1] - markstack_ptr[-2]) {
	    shift = diff - (markstack_ptr[-1] - markstack_ptr[-2]);
	    count = (sp - stack_base) - markstack_ptr[-1] + 2;
d622 5
a626 5
	    EXTEND(sp,shift);
	    src = sp;
	    dst = (sp += shift);
	    markstack_ptr[-1] += shift;
	    *markstack_ptr += shift;
d630 1
a630 1
	dst = stack_base + (markstack_ptr[-2] += diff) - 1; 
d638 1
a638 1
    if (markstack_ptr[-1] > *markstack_ptr) {
d645 1
a645 1
	items = --*markstack_ptr - markstack_ptr[-1];
d647 1
a647 1
	SP = stack_base + POPMARK;		/* pop original mark */
d660 1
a660 1
	SAVESPTR(curpm);
d662 1
a662 1
	src = stack_base[markstack_ptr[-1]];
d664 1
a664 1
	GvSV(defgv) = src;
d670 54
d727 1
a727 1
    dSP; dMARK; dORIGMARK;
d735 2
a736 1
    OP* nextop = op->op_next;
d743 4
a746 3
    if (op->op_flags & OPf_STACKED) {
	ENTER;
	if (op->op_flags & OPf_SPECIAL) {
d750 2
a751 2
	    sortcop = kid->op_next;
	    stash = curcop->cop_stash;
d771 1
a771 1
	    sortcop = CvSTART(cv);
d775 2
a776 2
	    SAVESPTR(curpad);
	    curpad = AvARRAY((AV*)AvARRAY(CvPADLIST(cv))[1]);
d780 2
a781 2
	sortcop = Nullop;
	stash = curcop->cop_stash;
d789 8
a796 2
	    if (!sortcop && !SvPOK(*up))
		(void)sv_2pv(*up, &na);
d801 1
a801 1
    if (sortcop) {
d803 1
a803 2
	    AV *oldstack;
	    CONTEXT *cx;
d808 1
a808 1
	    SAVESPTR(op);
a809 6
	    oldstack = curstack;
	    if (!sortstack) {
		sortstack = newAV();
		AvREAL_off(sortstack);
		av_extend(sortstack, 32);
	    }
d811 5
a815 5
	    SWITCHSTACK(curstack, sortstack);
	    if (sortstash != stash) {
		firstgv = gv_fetchpv("a", TRUE, SVt_PV);
		secondgv = gv_fetchpv("b", TRUE, SVt_PV);
		sortstash = stash;
d818 2
a819 2
	    SAVESPTR(GvSV(firstgv));
	    SAVESPTR(GvSV(secondgv));
d821 2
a822 2
	    PUSHBLOCK(cx, CXt_NULL, stack_base);
	    if (!(op->op_flags & OPf_SPECIAL)) {
d830 2
a831 1
	    sortcxix = cxstack_ix;
d833 2
a834 4
	    qsort((char*)(myorigmark+1), max, sizeof(SV*), sortcv);

	    POPBLOCK(cx,curpm);
	    SWITCHSTACK(sortstack, oldstack);
a836 1
	LEAVE;
d841 8
a848 2
	    qsort((char*)(ORIGMARK+1), max, sizeof(SV*),
		  (op->op_private & OPpLOCALE) ? sortcmp_locale : sortcmp);
d851 2
a852 1
    stack_sp = ORIGMARK + max;
d862 1
a862 1
    return SvTRUEx(PAD_SV(op->op_targ)) ? cCONDOP->op_false : cCONDOP->op_true;
d867 1
a867 1
    dSP;
d874 1
a874 1
	SV *targ = PAD_SV(op->op_targ);
d876 2
a877 2
	if ((op->op_private & OPpFLIP_LINENUM)
	  ? last_in_gv && SvIV(sv) == IoLINES(GvIOp(last_in_gv))
d880 1
a880 1
	    if (op->op_flags & OPf_SPECIAL) {
d887 1
a887 1
		sp--;
d899 1
a899 1
    dSP;
d903 1
a903 1
	register I32 i;
d910 2
d915 3
a917 2
		EXTEND_MORTAL(max - i + 1);
		EXTEND(SP, max - i + 1);
d919 3
a921 1
	    while (i <= max) {
d929 1
d933 2
a934 2
	    while (!SvNIOKp(sv) && SvCUR(sv) <= len &&
		strNE(SvPVX(sv),tmps) ) {
d936 2
a940 2
	    if (strEQ(SvPVX(sv),tmps))
		XPUSHs(sv);
d947 2
a948 2
	if ((op->op_private & OPpFLIP_LINENUM)
	  ? last_in_gv && SvIV(sv) == IoLINES(GvIOp(last_in_gv))
d961 2
a962 3
static I32
dopoptolabel(label)
char *label;
d964 1
d966 1
a966 1
    register CONTEXT *cx;
d970 1
a970 1
	switch (cx->cx_type) {
d972 2
a973 2
	    if (dowarn)
		warn("Exiting substitution via %s", op_name[op->op_type]);
d976 2
a977 2
	    if (dowarn)
		warn("Exiting subroutine via %s", op_name[op->op_type]);
d980 2
a981 2
	    if (dowarn)
		warn("Exiting eval via %s", op_name[op->op_type]);
d984 2
a985 2
	    if (dowarn)
		warn("Exiting pseudo-block via %s", op_name[op->op_type]);
d1002 1
a1002 1
dowantarray()
d1009 1
a1009 1
block_gimme()
d1011 1
d1027 2
d1032 9
a1040 3
static I32
dopoptosub(startingblock)
I32 startingblock;
d1042 1
d1044 1
a1044 1
    register CONTEXT *cx;
d1046 2
a1047 2
	cx = &cxstack[i];
	switch (cx->cx_type) {
d1059 2
a1060 3
static I32
dopoptoeval(startingblock)
I32 startingblock;
d1062 1
d1064 1
a1064 1
    register CONTEXT *cx;
d1067 1
a1067 1
	switch (cx->cx_type) {
d1078 2
a1079 3
static I32
dopoptoloop(startingblock)
I32 startingblock;
d1081 1
d1083 1
a1083 1
    register CONTEXT *cx;
d1086 1
a1086 1
	switch (cx->cx_type) {
d1088 2
a1089 2
	    if (dowarn)
		warn("Exiting substitution via %s", op_name[op->op_type]);
d1092 2
a1093 2
	    if (dowarn)
		warn("Exiting subroutine via %s", op_name[op->op_type]);
d1096 2
a1097 2
	    if (dowarn)
		warn("Exiting eval via %s", op_name[op->op_type]);
d1100 2
a1101 2
	    if (dowarn)
		warn("Exiting pseudo-block via %s", op_name[op->op_type]);
d1112 1
a1112 2
dounwind(cxix)
I32 cxix;
d1114 2
a1115 1
    register CONTEXT *cx;
d1122 1
a1122 1
			      (long) cxstack_ix+1, block_type[cx->cx_type]));
d1124 1
a1124 1
	switch (cx->cx_type) {
d1145 1
a1145 2
die_where(message)
char *message;
d1147 3
a1149 1
    if (in_eval) {
d1151 1
a1151 1
	register CONTEXT *cx;
d1155 19
a1173 13
	if (in_eval & 4) {
	    SV **svp;
	    STRLEN klen = strlen(message);
	    
	    svp = hv_fetch(GvHV(errgv), message, klen, TRUE);
	    if (svp) {
		if (!SvIOK(*svp)) {
		    static char prefix[] = "\t(in cleanup) ";
		    sv_upgrade(*svp, SVt_IV);
		    (void)SvIOK_only(*svp);
		    SvGROW(GvSV(errgv), SvCUR(GvSV(errgv))+sizeof(prefix)+klen);
		    sv_catpvn(GvSV(errgv), prefix, sizeof(prefix)-1);
		    sv_catpvn(GvSV(errgv), message, klen);
a1174 1
		sv_inc(*svp);
d1176 2
d1180 7
a1186 3
	    sv_setpv(GvSV(errgv), message);
	
	cxix = dopoptoeval(cxstack_ix);
d1193 2
a1194 2
	    POPBLOCK(cx,curpm);
	    if (cx->cx_type != CXt_EVAL) {
d1201 2
a1202 2
		*++newsp = &sv_undef;
	    stack_sp = newsp;
d1207 1
a1207 1
		char* msg = SvPVx(GvSV(errgv), na);
d1213 2
d1224 1
a1224 1
    dSP; dPOPTOPssrl;
d1233 1
a1233 1
    dSP;
d1242 1
a1242 1
    dSP;
a1248 15
#ifdef DEPRECATED
PP(pp_entersubr)
{
    dSP;
    SV** mark = (stack_base + *markstack_ptr + 1);
    SV* cv = *mark;
    while (mark < sp) {	/* emulate old interface */
	*mark = mark[1];
	mark++;
    }
    *sp = cv;
    return pp_entersub();
}
#endif

d1251 1
a1251 1
    dSP;
d1253 3
a1255 1
    register CONTEXT *cx;
d1258 1
d1266 6
d1277 2
a1278 2
	if (DBsub && cxix >= 0 &&
		cxstack[cxix].blk_sub.cv == GvCV(DBsub))
d1282 1
a1282 1
	cxix = dopoptosub(cxix - 1);
d1284 5
a1288 4
    cx = &cxstack[cxix];
    if (cxstack[cxix].cx_type == CXt_SUB) {
        dbcxix = dopoptosub(cxix - 1);
	/* We expect that cxstack[dbcxix] is CXt_SUB, anyway, the
d1290 2
a1291 2
	if (DBsub && dbcxix >= 0 && cxstack[dbcxix].blk_sub.cv == GvCV(DBsub))
	    cx = &cxstack[dbcxix];
d1295 8
a1302 4
	dTARGET;

	sv_setpv(TARG, HvNAME(cx->blk_oldcop->cop_stash));
	PUSHs(TARG);
d1306 5
a1310 1
    PUSHs(sv_2mortal(newSVpv(HvNAME(cx->blk_oldcop->cop_stash), 0)));
d1315 1
a1315 1
    if (cx->cx_type == CXt_SUB) { /* So is cxstack[dbcxix]. */
d1317 1
a1317 1
	gv_efullname3(sv, CvGV(cxstack[cxix].blk_sub.cv), Nullch);
d1327 1
a1327 1
	PUSHs(&sv_undef);
d1330 1
a1330 1
    if (cx->cx_type == CXt_EVAL) {
d1333 1
a1333 1
	    PUSHs(&sv_no);
d1338 1
a1338 1
	    PUSHs(&sv_yes);
d1341 1
a1341 1
    else if (cx->cx_type == CXt_SUB &&
d1343 1
a1343 1
	    curcop->cop_stash == debstash)
d1348 1
a1348 1
	if (!dbargs) {
d1350 1
a1350 1
	    dbargs = GvAV(gv_AVadd(tmpgv = gv_fetchpv("DB::args", TRUE,
d1353 1
a1353 1
	    AvREAL_off(dbargs);		/* XXX Should be REIFY */
d1356 4
a1359 4
	if (AvMAX(dbargs) < AvFILL(ary) + off)
	    av_extend(dbargs, AvFILL(ary) + off);
	Copy(AvALLOC(ary), AvARRAY(dbargs), AvFILL(ary) + 1 + off, SV*);
	AvFILL(dbargs) = AvFILL(ary) + off;
d1364 6
a1369 9
static int
sortcv(a, b)
const void *a;
const void *b;
{
    SV * const *str1 = (SV * const *)a;
    SV * const *str2 = (SV * const *)b;
    I32 oldsaveix = savestack_ix;
    I32 oldscopeix = scopestack_ix;
d1371 6
a1376 6
    GvSV(firstgv) = *str1;
    GvSV(secondgv) = *str2;
    stack_sp = stack_base;
    op = sortcop;
    runops();
    if (stack_sp != stack_base + 1)
d1378 1
a1378 1
    if (!SvNIOKp(*stack_sp))
d1380 2
a1381 2
    result = SvIV(*stack_sp);
    while (scopestack_ix > oldscopeix) {
a1387 16
static int
sortcmp(a, b)
const void *a;
const void *b;
{
    return sv_cmp(*(SV * const *)a, *(SV * const *)b);
}

static int
sortcmp_locale(a, b)
const void *a;
const void *b;
{
    return sv_cmp_locale(*(SV * const *)a, *(SV * const *)b);
}

d1390 1
a1390 1
    dSP;
d1392 1
d1397 3
a1399 3
	tmps = POPp;
    sv_reset(tmps, curcop->cop_stash);
    PUSHs(&sv_yes);
d1410 1
a1410 1
    curcop = (COP*)op;
d1412 1
a1412 1
    stack_sp = stack_base + cxstack[cxstack_ix].blk_oldsp;
d1415 1
a1415 1
    if (op->op_private || SvIV(DBsingle) || SvIV(DBsignal) || SvIV(DBtrace))
d1417 1
a1417 1
	SV **sp;
d1419 1
a1419 1
	register CONTEXT *cx;
d1424 1
a1424 1
	gv = DBgv;
d1429 1
a1429 1
	if (CvDEPTH(cv) >= 1 && !(debug & (1<<30))) /* don't do recursive DB::DB call */
d1435 1
a1435 1
	SAVEI32(debug);
d1437 1
a1437 1
	debug = 0;
d1439 1
a1439 1
	sp = stack_sp;
d1441 2
a1442 2
	push_return(op->op_next);
	PUSHBLOCK(cx, CXt_SUB, sp);
d1446 2
a1447 2
	SAVESPTR(curpad);
	curpad = AvARRAY((AV*)*av_fetch(CvPADLIST(cv),1,FALSE));
d1461 2
a1462 2
    dSP; dMARK;
    register CONTEXT *cx;
d1469 7
a1475 2
    if (op->op_targ)
	svp = &curpad[op->op_targ];		/* "my" variable */
d1477 6
d1484 3
a1486 2

    SAVESPTR(*svp);
d1492 1
a1492 1
    if (op->op_flags & OPf_STACKED)
d1494 14
d1509 3
a1511 3
	cx->blk_loop.iterary = curstack;
	AvFILL(curstack) = sp - stack_base;
	cx->blk_loop.iterix = MARK - stack_base;
d1519 2
a1520 2
    dSP;
    register CONTEXT *cx;
d1535 2
a1536 2
    dSP;
    register CONTEXT *cx;
d1554 1
a1554 1
	    *++newsp = &sv_undef;
d1566 1
a1566 1
    curpm = newpm;	/* ... and pop $1 et al */
d1576 1
a1576 1
    dSP; dMARK;
d1578 1
a1578 1
    register CONTEXT *cx;
d1586 6
a1591 6
    if (curstack == sortstack) {
	if (cxstack_ix == sortcxix || dopoptosub(cxstack_ix) <= sortcxix) {
	    if (cxstack_ix > sortcxix)
		dounwind(sortcxix);
	    AvARRAY(curstack)[1] = *SP;
	    stack_sp = stack_base + 1;
d1603 1
a1603 1
    switch (cx->cx_type) {
d1615 1
a1615 1
	    (void)hv_delete(GvHVn(incgv), name, strlen(name), G_DISCARD);
d1625 17
a1641 5
	if (MARK < SP)
	    *++newsp = (popsub2 && SvTEMP(*SP))
			? *SP : sv_mortalcopy(*SP);
	else
	    *++newsp = &sv_undef;
d1650 1
a1650 1
    stack_sp = newsp;
d1656 1
a1656 1
    curpm = newpm;	/* ... and pop $1 et al */
d1664 1
a1664 1
    dSP;
d1666 1
a1666 1
    register CONTEXT *cx;
d1675 1
a1675 1
    SV **mark = stack_base + cxstack[cxstack_ix].blk_oldsp;
d1677 1
a1677 1
    if (op->op_flags & OPf_SPECIAL) {
d1691 1
a1691 1
    switch (cx->cx_type) {
d1716 1
a1716 1
	    *++newsp = &sv_undef;
d1738 1
a1738 1
    curpm = newpm;	/* ... and pop $1 et al */
d1747 1
a1747 1
    register CONTEXT *cx;
d1750 1
a1750 1
    if (op->op_flags & OPf_SPECIAL) {
d1764 1
a1764 1
    oldsave = scopestack[scopestack_ix - 1];
d1772 1
a1772 1
    register CONTEXT *cx;
d1775 1
a1775 1
    if (op->op_flags & OPf_SPECIAL) {
d1789 1
a1789 1
    oldsave = scopestack[scopestack_ix - 1];
d1794 2
a1795 8
static OP* lastgotoprobe;

static OP *
dofindlabel(op,label,opstack,oplimit)
OP *op;
char *label;
OP **opstack;
OP **oplimit;
d1803 4
a1806 4
    if (op->op_type == OP_LEAVE ||
	op->op_type == OP_SCOPE ||
	op->op_type == OP_LEAVELOOP ||
	op->op_type == OP_LEAVETRY)
d1808 1
a1808 1
	*ops++ = cUNOP->op_first;
d1813 2
a1814 1
    if (op->op_flags & OPf_KIDS) {
d1816 1
a1816 1
	for (kid = cUNOP->op_first; kid; kid = kid->op_sibling) {
d1821 2
a1822 2
	for (kid = cUNOP->op_first; kid; kid = kid->op_sibling) {
	    if (kid == lastgotoprobe)
d1829 2
a1830 2
	    if (op = dofindlabel(kid, label, ops, oplimit))
		return op;
d1845 1
a1845 1
    dSP;
d1848 1
a1848 1
    register CONTEXT *cx;
d1852 1
a1852 1
    int do_dump = (op->op_type == OP_DUMP);
d1855 1
a1855 1
    if (op->op_flags & OPf_STACKED) {
d1857 1
d1862 1
a1862 1
	    register CONTEXT *cx;
d1867 1
d1869 1
d1871 13
a1883 3
		if (CvGV(cv)) {
		    SV *tmpstr = sv_newmortal();
		    gv_efullname3(tmpstr, CvGV(cv), Nullch);
d1896 5
a1900 2
	    mark = stack_sp;
	    if (cx->blk_sub.hasargs) {   /* put @@_ back onto stack */
d1903 13
a1915 8
		items = AvFILL(av) + 1;
		stack_sp++;
		EXTEND(stack_sp, items); /* @@_ could have been extended. */
		Copy(AvARRAY(av), stack_sp, items, SV*);
		stack_sp += items;
		SvREFCNT_dec(GvAV(defgv));
		GvAV(defgv) = cx->blk_sub.savearray;
		AvREAL_off(av);
d1918 16
a1933 1
	    if (!(CvDEPTH(cx->blk_sub.cv) = cx->blk_sub.olddepth))
d1935 1
a1935 1
	    oldsave = scopestack[scopestack_ix - 1];
d1943 3
a1945 3
		    while (sp > mark) {
			sp[1] = sp[0];
			sp--;
d1949 1
a1949 1
		                   mark - stack_base + 1,
d1951 1
a1951 1
		    sp = stack_base + items;
d1954 10
a1963 2
		    stack_sp--;		/* There is no cv arg. */
		    (void)(*CvXSUB(cv))(cv);
d1971 6
d1983 1
a1983 1
		    if (CvDEPTH(cv) == 100 && dowarn)
d1985 1
a1985 1
		    if (CvDEPTH(cv) > AvFILL(padlist)) {
d1988 1
a1988 1
			I32 ix = AvFILL((AV*)svp[1]);
d1991 1
a1991 1
			    if (svp[ix] != &sv_undef) {
d2022 1
a2022 1
			AvFILL(padlist) = CvDEPTH(cv);
d2026 21
a2046 4
		SAVESPTR(curpad);
		curpad = AvARRAY((AV*)svp[CvDEPTH(cv)]);
		if (cx->blk_sub.hasargs) {
		    AV* av = (AV*)curpad[0];
d2049 4
a2052 1
		    cx->blk_sub.savearray = GvAV(defgv);
a2053 1
		    GvAV(defgv) = (AV*)SvREFCNT_inc(av);
d2070 6
a2075 2
		    AvFILL(av) = items - 1;
		    
d2082 1
a2082 1
		if (PERLDB_SUB && curstash != debstash) {
d2087 15
a2101 3
		    SV *sv = GvSV(DBsub);
		    save_item(sv);
		    gv_efullname3(sv, CvGV(cv), Nullch);
d2107 1
a2107 1
	    label = SvPV(sv,na);
d2109 1
a2109 1
    else if (op->op_flags & OPf_SPECIAL) {
d2121 1
a2121 1
	lastgotoprobe = 0;
d2125 1
a2125 1
	    switch (cx->cx_type) {
d2127 1
a2127 1
		gotoprobe = eval_root; /* XXX not good for nested eval */
d2138 1
a2138 1
		    gotoprobe = main_root;
d2151 1
a2151 1
		gotoprobe = main_root;
d2158 1
a2158 1
	    lastgotoprobe = gotoprobe;
d2172 1
a2172 1
	    oldsave = scopestack[scopestack_ix];
d2179 1
a2179 1
	    OP *oldop = op;
d2181 1
a2181 1
		op = enterops[ix];
d2184 1
a2184 1
		if (op->op_type == OP_ENTERITER)
d2187 1
a2187 1
		(*op->op_ppaddr)();
d2189 1
a2189 1
	    op = oldop;
d2195 1
a2195 1
	if (!retop) retop = main_start;
d2197 2
a2198 2
	restartop = retop;
	do_undump = TRUE;
d2202 2
a2203 7
	restartop = 0;		/* hmm, must be GNU unexec().. */
	do_undump = FALSE;
    }

    if (curstack == signalstack) {
        restartop = retop;
        JMPENV_JUMP(3);
d2211 1
a2211 1
    dSP;
d2224 1
a2224 1
    PUSHs(&sv_undef);
d2231 1
a2231 1
    dSP;
d2244 2
a2245 2
    op = cCOP->uop.scop.scop_next[match];
    RETURNOP(op);
d2250 1
a2250 1
    dSP;
d2253 2
a2254 2
    if (multiline)
	op = op->op_next;			/* can't assume anything */
d2256 2
a2257 1
	match = *(SvPVx(GvSV(cCOP->cop_gv), na)) & 255;
d2263 1
a2263 1
	op = cCOP->uop.scop.scop_next[match];
d2265 1
a2265 1
    RETURNOP(op);
d2271 2
a2272 4
static void
save_lines(array, sv)
AV *array;
SV *sv;
d2295 2
a2296 3
static OP *
docatch(o)
OP *o;
d2298 1
d2300 1
a2300 2
    I32 oldrunlevel = runlevel;
    OP *oldop = op;
d2303 1
a2303 1
    op = o;
d2306 1
a2306 1
    DEBUG_l(deb("(Setting up local jumplevel, runlevel = %ld)\n", (long)runlevel+1));
d2311 1
d2313 1
a2313 2
	runlevel = oldrunlevel;
	op = oldop;
d2317 4
a2320 6
	if (!restartop) {
	    PerlIO_printf(PerlIO_stderr(), "panic: restartop\n");
	    break;
	}
	op = restartop;
	restartop = 0;
d2323 1
a2323 1
        runops();
d2327 1
a2327 2
    runlevel = oldrunlevel;
    op = oldop;
d2331 68
a2398 3
static OP *
doeval(gimme)
int gimme;
d2401 1
a2401 1
    OP *saveop = op;
d2405 1
d2407 1
a2407 1
    in_eval = 1;
d2413 41
a2453 21
    SAVEI32(padix);
    SAVESPTR(curpad);
    SAVESPTR(comppad);
    SAVESPTR(comppad_name);
    SAVEI32(comppad_name_fill);
    SAVEI32(min_intro_pending);
    SAVEI32(max_intro_pending);

    caller = compcv;
    SAVESPTR(compcv);
    compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)compcv, SVt_PVCV);
    CvUNIQUE_on(compcv);

    comppad = newAV();
    comppad_name = newAV();
    comppad_name_fill = 0;
    min_intro_pending = 0;
    av_push(comppad, Nullsv);
    curpad = AvARRAY(comppad);
    padix = 0;
d2457 3
a2459 3
    av_store(comppadlist, 0, (SV*)comppad_name);
    av_store(comppadlist, 1, (SV*)comppad);
    CvPADLIST(compcv) = comppadlist;
d2461 2
a2462 2
    if (saveop->op_type != OP_REQUIRE)
	CvOUTSIDE(compcv) = (CV*)SvREFCNT_inc(caller);
d2464 1
a2464 1
    SAVEFREESV(compcv);
d2468 8
a2475 8
    newstash = curcop->cop_stash;
    if (curstash != newstash) {
	SAVESPTR(curstash);
	curstash = newstash;
    }
    SAVESPTR(beginav);
    beginav = newAV();
    SAVEFREESV(beginav);
d2479 8
a2486 8
    eval_root = Nullop;
    error_count = 0;
    curcop = &compiling;
    curcop->cop_arybase = 0;
    SvREFCNT_dec(rs);
    rs = newSVpv("\n", 1);
    if (saveop->op_flags & OPf_SPECIAL)
	in_eval |= 4;
d2488 2
a2489 2
	sv_setpv(GvSV(errgv),"");
    if (yyparse() || error_count || !eval_root) {
d2492 14
a2505 7
	CONTEXT *cx;
	I32 optype;

	op = saveop;
	if (eval_root) {
	    op_free(eval_root);
	    eval_root = Nullop;
a2506 4
	SP = stack_base + POPMARK;		/* pop original mark */
	POPBLOCK(cx,curpm);
	POPEVAL(cx);
	pop_return();
d2510 1
a2510 1
	    char* msg = SvPVx(GvSV(errgv), na);
d2512 6
d2519 8
a2526 2
	SvREFCNT_dec(rs);
	rs = SvREFCNT_inc(nrs);
d2529 9
a2537 4
    SvREFCNT_dec(rs);
    rs = SvREFCNT_inc(nrs);
    compiling.cop_line = 0;
    SAVEFREEOP(eval_root);
d2539 1
a2539 1
	scalarvoid(eval_root);
d2541 1
a2541 1
	list(eval_root);
d2543 1
a2543 1
	scalar(eval_root);
d2552 2
a2553 2
	    PUSHMARK(sp);
	    XPUSHs((SV*)compiling.cop_filegv);
d2561 9
a2569 1
    CvDEPTH(compcv) = 1;
d2571 1
a2571 3
    SP = stack_base + POPMARK;		/* pop original mark */
    op = saveop;					/* The caller may need it. */
    RETURNOP(eval_start);
d2576 2
a2577 2
    dSP;
    register CONTEXT *cx;
d2580 1
d2586 1
d2591 1
a2591 1
	if (atof(patchlevel) + 0.00000999 < SvNV(sv))
d2593 1
a2593 1
		SvPV(sv,na),patchlevel);
d2596 2
a2597 2
    name = SvPV(sv, na);
    if (!*name)
d2600 3
a2602 3
    if (op->op_type == OP_REQUIRE &&
      (svp = hv_fetch(GvHVn(incgv), name, SvCUR(sv), 0)) &&
      *svp != &sv_undef)
d2624 1
a2624 1
	tryrsfp = PerlIO_open(name,"r");
d2627 1
a2627 1
	AV *ar = GvAVn(incgv);
d2636 1
a2636 1
		char *dir = SvPVx(*av_fetch(ar, i, TRUE), na);
d2646 1
d2648 1
a2648 1
		tryrsfp = PerlIO_open(tryname, "r");
d2657 2
a2658 2
    SAVESPTR(compiling.cop_filegv);
    compiling.cop_filegv = gv_fetchfile(tryrsfp ? tryname : name);
d2661 1
a2661 1
	if (op->op_type == OP_REQUIRE) {
d2664 1
a2664 1
	    AV *ar = GvAVn(incgv);
d2672 1
a2672 1
		char *dir = SvPVx(*av_fetch(ar, i, TRUE), na);
d2683 2
d2687 2
a2688 2
    (void)hv_store(GvHVn(incgv), name, strlen(name),
	newSVsv(GvSV(compiling.cop_filegv)), 0 );
d2693 2
a2694 4
    if (rsfp_filters){
 	save_aptr(&rsfp_filters);
	rsfp_filters = NULL;
    }
d2696 1
a2696 1
    rsfp = tryrsfp;
d2699 2
a2700 2
    SAVEI32(hints);
    hints = 0;
d2704 1
a2704 1
    push_return(op->op_next);
d2706 1
a2706 1
    PUSHEVAL(cx, name, compiling.cop_filegv);
d2708 2
a2709 1
    compiling.cop_line = 0;
d2712 9
a2720 1
    return DOCATCH(doeval(G_SCALAR));
d2730 2
a2731 2
    dSP;
    register CONTEXT *cx;
d2733 1
a2733 1
    I32 gimme = GIMME_V, was = sub_generation;
d2749 4
a2752 4
    SAVESPTR(compiling.cop_filegv);
    sprintf(tmpbuf, "_<(eval %lu)", (unsigned long)++evalseq);
    compiling.cop_filegv = gv_fetchfile(tmpbuf+2);
    compiling.cop_line = 1;
d2759 7
a2765 7
    SAVEDELETE(defstash, safestr, strlen(safestr));
    SAVEI32(hints);
    hints = op->op_targ;

    push_return(op->op_next);
    PUSHBLOCK(cx, CXt_EVAL, SP);
    PUSHEVAL(cx, 0, compiling.cop_filegv);
d2769 2
a2770 2
    if (PERLDB_LINE && curstash != debstash)
	save_lines(GvAV(compiling.cop_filegv), linestr);
d2772 11
a2782 3
    ret = doeval(gimme);
    if (PERLDB_INTER && was != sub_generation /* Some subs defined here. */
	&& ret != op->op_next) {	/* Successive compilation. */
d2790 1
a2790 1
    dSP;
d2795 1
a2795 1
    register CONTEXT *cx;
d2797 1
a2797 1
    U8 save_flags = op -> op_flags;
d2817 1
a2817 1
	    *MARK = &sv_undef;
d2829 1
a2829 1
    curpm = newpm;	/* Don't pop $1 et al till now */
d2837 2
a2838 2
    if (AvFILL(comppad_name) >= 0) {
	SV **svp = AvARRAY(comppad_name);
d2840 1
a2840 1
	for (ix = AvFILL(comppad_name); ix >= 0; ix--) {
d2842 1
a2842 1
	    if (sv && sv != &sv_undef && *SvPVX(sv) == '&') {
d2844 1
a2844 1
		svp[ix] = &sv_undef;
d2846 1
a2846 1
		sv = curpad[ix];
d2855 1
a2855 1
		    curpad[ix] = sv;
d2862 1
a2862 1
    assert(CvDEPTH(compcv) == 1);
d2864 2
a2865 1
    CvDEPTH(compcv) = 0;
d2868 1
a2868 1
	!(gimme == G_SCALAR ? SvTRUE(*sp) : sp > newsp))
d2872 1
a2872 1
	(void)hv_delete(GvHVn(incgv), name, strlen(name), G_DISCARD);
d2874 6
a2881 6
    lex_end();
    LEAVE;

    if (!(save_flags & OPf_SPECIAL))
	sv_setpv(GvSV(errgv),"");

d2887 2
a2888 2
    dSP;
    register CONTEXT *cx;
d2897 1
a2897 1
    eval_root = op;		/* Only needed so that goto works right. */
d2899 2
a2900 2
    in_eval = 1;
    sv_setpv(GvSV(errgv),"");
d2902 1
a2902 1
    return DOCATCH(op->op_next);
d2907 1
a2907 1
    dSP;
d2912 1
a2912 1
    register CONTEXT *cx;
d2932 1
a2932 1
	    *MARK = &sv_undef;
d2945 1
a2945 1
    curpm = newpm;	/* Don't pop $1 et al till now */
d2948 1
a2948 1
    sv_setpv(GvSV(errgv),"");
d2952 2
a2953 3
static void
doparseform(sv)
SV *sv;
d3128 691
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d26 3
d30 1
a30 1
static OP *dofindlabel _((OP *op, char *label, OP **opstack));
d37 1
d39 1
a39 1
static int sortcv _((const void *, const void *));
d53 2
a54 1
    if (cxstack[cxix].blk_gimme == G_ARRAY)
d56 1
a56 1
    else
d58 3
d97 1
a97 1
	pm->op_pmflags &= ~PMf_RUNTIME;	/* no point compiling again */
d115 2
d121 2
a123 3
	if (rx->subbase)
	    Safefree(rx->subbase);
	rx->subbase = cx->sb_subbase;
d132 2
a140 1

d143 2
d161 62
a222 1
    cx->sb_subbase = rx->subbase;
d224 5
a228 2
    rx->subbase = Nullch;	/* so recursion works */
    RETURNOP(pm->op_pmreplstart);
d253 1
a253 1
    if (!SvCOMPILED(form)) {
d291 1
a291 1
		fprintf(stderr, "%-16s%ld\n", name, (long) arg);
d293 1
a293 1
		fprintf(stderr, "%-16s\n", name);
d455 2
d531 1
a531 1
	if (GIMME != G_ARRAY)
d594 1
d602 1
a602 1
	if (GIMME != G_ARRAY) {
a604 1
	    RETURN;
d606 2
a607 1
	SP += items;
d656 1
a656 1
		    gv_efullname(tmpstr, gv);
d672 1
a672 1
	    
d686 2
a687 1
	    if (!SvPOK(*up))
a688 2
	    else
		SvTEMP_off(*up);
d698 1
d703 1
a703 1
	    oldstack = stack;
d709 2
a710 1
	    SWITCHSTACK(stack, sortstack);
d719 10
a728 1
	    PUSHBLOCK(cx, CXt_LOOP, stack_base);
d735 1
d742 2
a743 1
	    qsort((char*)(ORIGMARK+1), max, sizeof(SV*), sortcmp);
d776 1
d802 2
a803 1
	  (looks_like_number(left) && *SvPVX(left) != '0') ) {
d806 2
a807 1
	    if (max > i)
d809 1
d811 1
a811 2
		sv = sv_mortalcopy(&sv_no);
		sv_setiv(sv,i++);
d871 4
d878 2
a879 2
		DEBUG_l(deb("(Skipping label #%d %s)\n",
			i, cx->blk_loop.label));
d882 1
a882 1
	    DEBUG_l( deb("(Found label #%d %s)\n", i, label));
d892 7
d903 6
d910 1
a910 2

    if (cxstack[cxix].blk_gimme == G_ARRAY)
d912 3
a914 2
    else
	return G_SCALAR;
d930 1
a930 1
	    DEBUG_l( deb("(Found sub #%d)\n", i));
d949 1
a949 1
	    DEBUG_l( deb("(Found eval #%d)\n", i));
d967 1
a967 1
		warn("Exiting substitition via %s", op_name[op->op_type]);
d977 4
d982 1
a982 1
	    DEBUG_l( deb("(Found loop #%d)\n", i));
d998 3
a1000 3
	cx = &cxstack[cxstack_ix--];
	DEBUG_l(fprintf(stderr, "Unwinding block %ld, type %s\n", (long) cxstack_ix+1,
		    block_type[cx->cx_type]));
d1003 3
d1015 1
a1015 1
	case CXt_SUBST:
d1018 1
a1021 41
#ifdef I_STDARG
OP *
die(char* pat, ...)
#else
/*VARARGS0*/
OP *
die(pat, va_alist)
    char *pat;
    va_dcl
#endif
{
    va_list args;
    char *message;
    int oldrunlevel = runlevel;
    int was_in_eval = in_eval;
    HV *stash;
    GV *gv;
    CV *cv;

#ifdef I_STDARG
    va_start(args, pat);
#else
    va_start(args);
#endif
    message = mess(pat, &args);
    va_end(args);
    if (diehook && (cv = sv_2cv(diehook, &stash, &gv, 0)) && !CvDEPTH(cv)) {
	dSP;

	PUSHMARK(sp);
	EXTEND(sp, 1);
	PUSHs(sv_2mortal(newSVpv(message,0)));
	PUTBACK;
	perl_call_sv((SV*)cv, G_DISCARD);
    }
    restartop = die_where(message);
    if ((!restartop && was_in_eval) || oldrunlevel > 1)
	Siglongjmp(top_env, 3);
    return restartop;
}

d1061 1
a1061 1
		fprintf(stderr, "panic: die %s", message);
d1072 4
a1075 2
	    if (optype == OP_REQUIRE)
		DIE("%s", SvPVx(GvSV(errgv), na));
d1079 4
a1082 17
    fputs(message, stderr);
    (void)Fflush(stderr);
    if (e_tmpname) {
	if (e_fp) {
	    fclose(e_fp);
	    e_fp = Nullfp;
	}
	(void)UNLINK(e_tmpname);
	Safefree(e_tmpname);
	e_tmpname = Nullch;
    }
    statusvalue = SHIFTSTATUS(statusvalue);
#ifdef VMS
    my_exit((U32)vaxc$errno?vaxc$errno:errno?errno:statusvalue?statusvalue:SS$_ABORT);
#else
    my_exit((I32)((errno&255)?errno:((statusvalue&255)?statusvalue:255)));
#endif
d1134 1
d1178 1
a1178 1
	gv_efullname(sv, CvGV(cxstack[cxix].blk_sub.cv));
d1186 5
a1190 1
    PUSHs(sv_2mortal(newSViv((I32)cx->blk_gimme)));
d1230 2
a1231 2
    SV **str1 = (SV **) a;
    SV **str2 = (SV **) b;
d1257 2
a1258 3
    register SV *str1 = *(SV **) a;
    register SV *str2 = *(SV **) b;
    I32 retval;
d1260 6
a1265 23
    if (!SvPOKp(str1)) {
	if (!SvPOKp(str2))
	    return 0;
	else
	    return -1;
    }
    if (!SvPOKp(str2))
	return 1;

    if (SvCUR(str1) < SvCUR(str2)) {
	/*SUPPRESS 560*/
	if (retval = memcmp(SvPVX(str1), SvPVX(str2), SvCUR(str1)))
	    return retval;
	else
	    return -1;
    }
    /*SUPPRESS 560*/
    else if (retval = memcmp(SvPVX(str1), SvPVX(str2), SvCUR(str2)))
	return retval;
    else if (SvCUR(str1) == SvCUR(str2))
	return 0;
    else
	return 1;
d1315 1
a1315 1
	SAVESPTR(stack_sp);
d1342 1
a1342 1
    I32 gimme = GIMME;
d1359 2
a1360 5
    if (op->op_flags & OPf_STACKED) {
	AV* av = (AV*)POPs;
	cx->blk_loop.iterary = av;
	cx->blk_loop.iterix = -1;
    }
d1362 2
a1363 2
	cx->blk_loop.iterary = stack;
	AvFILL(stack) = sp - stack_base;
d1374 1
a1374 1
    I32 gimme = GIMME;
d1390 1
d1398 10
a1407 10
    POPLOOP(cx);
    if (gimme == G_SCALAR) {
	if (op->op_private & OPpLEAVE_VOID)
	    ;
	else {
	    if (mark < SP)
		*++newsp = sv_mortalcopy(*SP);
	    else
		*++newsp = &sv_undef;
	}
d1410 1
a1410 1
	while (mark < SP)
d1412 2
d1415 6
a1420 2
    curpm = newpm;	/* Don't pop $1 et al till now */
    sp = newsp;
d1424 1
a1424 1
    RETURN;
d1432 2
d1439 2
a1440 2
    if (stack == sortstack) {
	if (cxstack_ix == sortcxix || dopoptosub(cxstack_ix) < sortcxix) {
d1443 1
a1443 1
	    AvARRAY(stack)[1] = *SP;
d1458 2
a1459 1
	POPSUB(cx);
d1466 1
a1473 1
	break;
d1476 1
d1479 2
a1480 1
	    *++newsp = sv_mortalcopy(*SP);
d1484 6
a1489 3
    else {
	while (MARK < SP)
	    *++newsp = sv_mortalcopy(*++MARK);
a1490 1
    curpm = newpm;	/* Don't pop $1 et al till now */
d1493 6
d1508 3
d1534 8
a1541 3
	POPLOOP(cx);
	nextop = cx->blk_loop.last_op->op_next;
	LEAVE;
a1546 4
    case CXt_SUB:
	POPSUB(cx);
	nextop = pop_return();
	break;
a1548 1
	break;
d1551 1
d1553 3
a1555 2
	if (mark < SP)
	    *++newsp = sv_mortalcopy(*SP);
d1559 19
a1577 3
    else {
	while (mark < SP)
	    *++newsp = sv_mortalcopy(*++mark);
d1579 1
a1579 2
    curpm = newpm;	/* Don't pop $1 et al till now */
    sp = newsp;
d1582 1
a1582 1
    RETURNOP(nextop);
d1638 1
a1638 1
dofindlabel(op,label,opstack)
d1642 1
d1646 1
d1648 2
d1654 5
a1658 1
	    *ops++ = cUNOP->op_first;
d1670 6
a1675 9
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) {
		if (ops > opstack &&
		  (ops[-1]->op_type == OP_NEXTSTATE ||
		   ops[-1]->op_type == OP_DBSTATE))
		    *ops = kid;
		else
		    *ops++ = kid;
	    }
	    if (op = dofindlabel(kid,label,ops))
d1695 2
a1696 1
    OP *enterops[64];
d1716 1
a1716 1
		    gv_efullname(tmpstr, CvGV(cv));
d1734 3
a1736 1
		Copy(AvARRAY(av), ++stack_sp, items, SV*);
d1738 1
d1764 1
d1780 1
a1780 2
			warn("Deep recursion on subroutine \"%s\"",
			    GvENAME(CvGV(cv)));
d1789 4
a1792 2
				if (SvFLAGS(svp[ix]) & SVf_FAKE) {
				    /* outer lexical? */
d1830 1
a1830 1
		    GvAV(defgv) = cx->blk_sub.argarray;
d1855 9
a1886 3
	    case CXt_SUB:
		gotoprobe = CvROOT(cx->blk_sub.cv);
		break;
d1901 8
d1912 1
a1912 2
		else
		    gotoprobe = main_root;
d1915 2
a1916 1
	    retop = dofindlabel(gotoprobe, label, enterops);
d1943 5
d1967 1
a1967 1
    if (stack == signalstack) {
d1969 1
a1969 1
        Siglongjmp(top_env, 3);
d1982 1
a1982 1
    else
d1984 5
d2063 40
d2109 1
d2114 2
d2118 1
a2118 1
    SAVEINT(padix);
d2122 3
a2124 3
    SAVEINT(comppad_name_fill);
    SAVEINT(min_intro_pending);
    SAVEINT(max_intro_pending);
d2126 1
d2130 1
d2145 4
d2170 4
a2173 1
    sv_setpv(GvSV(errgv),"");
d2185 1
d2191 4
a2194 2
	if (optype == OP_REQUIRE)
	    DIE("%s", SvPVx(GvSV(errgv), na));
d2203 3
a2205 1
    if (gimme & G_ARRAY)
d2212 12
d2226 4
d2239 2
a2240 1
    char *tmpname;
d2243 1
a2243 1
    FILE *tryrsfp = 0;
d2247 1
d2264 4
a2267 5
    tmpname = savepv(name);
    if (*tmpname == '/' ||
	(*tmpname == '.' && 
	    (tmpname[1] == '/' ||
	     (tmpname[1] == '.' && tmpname[2] == '/')))
d2269 4
a2272 1
      || (tmpname[0] && tmpname[1] == ':')
d2275 2
a2276 2
	|| (strchr(tmpname,':') || ((*tmpname == '[' || *tmpname == '<') &&
	    (tmpname[1] == '-' || tmpname[1] == ']' || tmpname[1] == '>')))
d2280 2
a2281 1
	tryrsfp = fopen(tmpname,"r");
a2285 2

	for (i = 0; i <= AvFILL(ar); i++) {
d2287 13
a2299 3
	    if (tounixpath_ts(SvPVx(*av_fetch(ar, i, TRUE), na),buf) == NULL)
		continue;
	    strcat(buf,name);
d2301 1
a2301 2
	    (void)sprintf(buf, "%s/%s",
		SvPVx(*av_fetch(ar, i, TRUE), na), name);
d2303 7
a2309 9
	    tryrsfp = fopen(buf, "r");
	    if (tryrsfp) {
		char *s = buf;

		if (*s == '.' && s[1] == '/')
		    s += 2;
		Safefree(tmpname);
		tmpname = savepv(s);
		break;
d2314 2
a2315 3
    compiling.cop_filegv = gv_fetchfile(tmpname);
    Safefree(tmpname);
    tmpname = Nullch;
d2318 17
a2334 6
	    sprintf(tokenbuf,"Can't locate %s in @@INC", name);
	    if (instr(tokenbuf,".h "))
		strcat(tokenbuf," (change .h to .ph maybe?)");
	    if (instr(tokenbuf,".ph "))
		strcat(tokenbuf," (did you run h2ph?)");
	    DIE("%s",tokenbuf);
d2367 1
a2367 1
    return doeval(G_SCALAR);
d2380 3
a2382 2
    I32 gimme = GIMME;
    char tmpbuf[32];
d2384 1
d2397 1
a2397 1
    sprintf(tmpbuf, "_<(eval %d)", ++evalseq);
d2400 7
a2406 1
    SAVEDELETE(defstash, savepv(tmpbuf), strlen(tmpbuf));
d2416 1
a2416 1
    if (perldb && curstash != debstash)
d2419 6
a2424 1
    return doeval(gimme);
d2436 1
d2443 11
a2453 3
    if (gimme == G_SCALAR) {
	if (op->op_private & OPpLEAVE_VOID)
	    MARK = newsp;
d2455 2
a2456 11
	    MARK = newsp + 1;
	    if (MARK <= SP) {
		if (SvFLAGS(TOPs) & SVs_TEMP)
		    *MARK = TOPs;
		else
		    *MARK = sv_mortalcopy(TOPs);
	    }
	    else {
		MEXTEND(mark,0);
		*MARK = &sv_undef;
	    }
a2457 1
	SP = MARK;
d2460 3
a2462 2
	for (mark = newsp + 1; mark <= SP; mark++)
	    if (!(SvFLAGS(TOPs) & SVs_TEMP))
d2464 3
a2466 1
		/* in case LEAVE wipes old return values */
d2470 29
a2498 2
    if (optype != OP_ENTEREVAL) {
	char *name = cx->blk_eval.old_name;
d2500 4
a2503 3
	if (!(gimme == G_SCALAR ? SvTRUE(*sp) : sp > newsp)) {
	    /* Unassume the success we assumed earlier. */
	    (void)hv_delete(GvHVn(incgv), name, strlen(name), G_DISCARD);
d2505 7
a2511 3
	    if (optype == OP_REQUIRE)
		retop = die("%s did not return a true value", name);
	}
d2516 3
a2518 1
    sv_setpv(GvSV(errgv),"");
d2527 1
a2527 1
    I32 gimme = GIMME;
d2539 2
a2540 1
    RETURN;
d2557 11
a2567 3
    if (gimme == G_SCALAR) {
	if (op->op_private & OPpLEAVE_VOID)
	    MARK = newsp;
d2569 2
a2570 11
	    MARK = newsp + 1;
	    if (MARK <= SP) {
		if (SvFLAGS(TOPs) & (SVs_PADTMP|SVs_TEMP))
		    *MARK = TOPs;
		else
		    *MARK = sv_mortalcopy(TOPs);
	    }
	    else {
		MEXTEND(mark,0);
		*MARK = &sv_undef;
	    }
d2575 3
a2577 2
	for (mark = newsp + 1; mark <= SP; mark++)
	    if (!(SvFLAGS(TOPs) & (SVs_PADTMP|SVs_TEMP)))
d2579 3
a2581 1
		/* in case LEAVE wipes old return values */
d2608 4
a2611 1
    New(804, fops, (send - s)*3+2, U16);    /* Almost certainly too long... */
d2644 1
a2644 1
		if (postspace) {
a2645 2
		    postspace = FALSE;
		}
d2649 1
d2765 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d26 2
a27 8
#define DOCATCH(o) ((CATCH_GET == TRUE) ? docatch(o) : (o))

#ifdef PERL_OBJECT
#define CALLOP this->*PL_op
#else
#define CALLOP *PL_op
static OP *docatch _((OP *o));
static OP *dofindlabel _((OP *o, char *label, OP **opstack, OP **oplimit));
a32 1
static I32 dopoptosub_at _((PERL_CONTEXT *cxstk, I32 startingblock));
d34 4
a37 4
static I32 sortcv _((SV *a, SV *b));
static void qsortsv _((SV **array, size_t num_elts, I32 (*fun)(SV *a, SV *b)));
static OP *doeval _((int gimme, OP** startop));
#endif
d41 1
a41 1
    djSP;
d49 1
a49 2
    switch (cxstack[cxix].blk_gimme) {
    case G_ARRAY:
d51 1
a51 1
    case G_SCALAR:
a52 3
    default:
	RETPUSHUNDEF;
    }
d60 2
a61 11
PP(pp_regcreset)
{
    /* XXXX Should store the old value to allow for tie/overload - and
       restore in regcomp, where marked with XXXX. */
    PL_reginterp_cnt = 0;
    return NORMAL;
}

PP(pp_regcomp)
{
    djSP;
a65 1
    MAGIC *mg = Null(MAGIC*);
d68 1
a68 12
    if (SvROK(tmpstr)) {
	SV *sv = SvRV(tmpstr);
	if(SvMAGICAL(sv))
	    mg = mg_find(sv, 'r');
    }
    if (mg) {
	regexp *re = (regexp *)mg->mg_obj;
	ReREFCNT_dec(pm->op_pmregexp);
	pm->op_pmregexp = ReREFCNT_inc(re);
    }
    else {
	t = SvPV(tmpstr, len);
d70 7
a76 16
	/* Check against the last compiled regexp. */
	if (!pm->op_pmregexp || !pm->op_pmregexp->precomp ||
	    pm->op_pmregexp->prelen != len ||
	    memNE(pm->op_pmregexp->precomp, t, len))
	{
	    if (pm->op_pmregexp) {
		ReREFCNT_dec(pm->op_pmregexp);
		pm->op_pmregexp = Null(REGEXP*);	/* crucial if regcomp aborts */
	    }
	    if (PL_op->op_flags & OPf_SPECIAL)
		PL_reginterp_cnt = I32_MAX; /* Mark as safe.  */

	    pm->op_pmflags = pm->op_pmpermflags;	/* reset case sensitivity */
	    pm->op_pmregexp = CALLREGCOMP(t, t + len, pm);
	    PL_reginterp_cnt = 0;		/* XXXX Be extra paranoid - needed
					   inside tie/overload accessors.  */
a77 1
    }
d79 2
a80 6
#ifndef INCOMPLETE_TAINTS
    if (PL_tainting) {
	if (PL_tainted)
	    pm->op_pmdynflags |= PMdf_TAINTED;
	else
	    pm->op_pmdynflags &= ~PMdf_TAINTED;
a81 1
#endif
d83 2
a84 2
    if (!pm->op_pmregexp->prelen && PL_curpm)
	pm = PL_curpm;
d89 3
a91 2
	pm->op_private &= ~OPpRUNTIME;	/* no point compiling again */
	cLOGOP->op_first->op_next = PL_op->op_next;
d98 1
a98 1
    djSP;
d100 1
a100 1
    register PERL_CONTEXT *cx = &cxstack[cxstack_ix];
a106 2
    rxres_restore(&cx->sb_rxres, rx);

a110 2
	if (!(cx->sb_rxtainted & 2) && SvTAINTED(TOPs))
	    cx->sb_rxtainted |= 2;
d112 3
d117 2
a118 3
	if (cx->sb_once || !CALLREGEXEC(rx, s, cx->sb_strend, orig,
				     s == m, Nullsv, NULL,
				     cx->sb_safebase ? 0 : REXEC_COPY_STR))
a122 2
	    cx->sb_rxtainted |= RX_MATCH_TAINTED(rx);

a130 3
	    TAINT_IF(cx->sb_rxtainted & 1);
	    PUSHs(sv_2mortal(newSViv((I32)cx->sb_iters - 1)));

a131 1
	    TAINT_IF(cx->sb_rxtainted);
d133 1
a133 2
	    SvTAINT(targ);

d149 3
a151 2
    cx->sb_rxtainted |= RX_MATCH_TAINTED(rx);
    rxres_save(&cx->sb_rxres, rx);
a154 60
void
rxres_save(void **rsp, REGEXP *rx)
{
    UV *p = (UV*)*rsp;
    U32 i;

    if (!p || p[1] < rx->nparens) {
	i = 6 + rx->nparens * 2;
	if (!p)
	    New(501, p, i, UV);
	else
	    Renew(p, i, UV);
	*rsp = (void*)p;
    }

    *p++ = (UV)rx->subbase;
    rx->subbase = Nullch;

    *p++ = rx->nparens;

    *p++ = (UV)rx->subbeg;
    *p++ = (UV)rx->subend;
    for (i = 0; i <= rx->nparens; ++i) {
	*p++ = (UV)rx->startp[i];
	*p++ = (UV)rx->endp[i];
    }
}

void
rxres_restore(void **rsp, REGEXP *rx)
{
    UV *p = (UV*)*rsp;
    U32 i;

    Safefree(rx->subbase);
    rx->subbase = (char*)(*p);
    *p++ = 0;

    rx->nparens = *p++;

    rx->subbeg = (char*)(*p++);
    rx->subend = (char*)(*p++);
    for (i = 0; i <= rx->nparens; ++i) {
	rx->startp[i] = (char*)(*p++);
	rx->endp[i] = (char*)(*p++);
    }
}

void
rxres_free(void **rsp)
{
    UV *p = (UV*)*rsp;

    if (p) {
	Safefree((char*)(*p));
	Safefree(p);
	*rsp = Null(void*);
    }
}

d157 2
a158 2
    djSP; dMARK; dORIGMARK;
    register SV *tmpForm = *++MARK;
d170 1
a170 1
    bool chopspace = (strchr(PL_chopset, ' ') != Nullch);
d177 3
a179 3
    if (!SvMAGICAL(tmpForm) || !SvCOMPILED(tmpForm)) {
	SvREADONLY_off(tmpForm);
	doparseform(tmpForm);
d182 2
a183 2
    SvPV_force(PL_formtarget, len);
    t = SvGROW(PL_formtarget, len + SvCUR(tmpForm) + 1);  /* XXX SvCUR bad */
d185 1
a185 1
    f = SvPV(tmpForm, len);
d187 1
a187 1
    s = f + len + WORD_ALIGN - SvCUR(tmpForm) % WORD_ALIGN;
d215 1
a215 1
		PerlIO_printf(PerlIO_stderr(), "%-16s%ld\n", name, (long) arg);
d217 1
a217 1
		PerlIO_printf(PerlIO_stderr(), "%-16s\n", name);
d244 2
a245 2
		sv = &PL_sv_no;
		if (PL_dowarn)
d293 1
a293 1
			if (strchr(PL_chopset, *s))
d325 1
a325 1
#ifdef EBCDIC
d327 2
a328 1
		if (iscntrl(ch))
d331 1
d333 1
a333 1
		    t[-1] = ' ';
d360 4
a363 4
		SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
		sv_catpvn(PL_formtarget, item, itemsize);
		SvGROW(PL_formtarget, SvCUR(PL_formtarget) + SvCUR(tmpForm) + 1);
		t = SvPVX(PL_formtarget) + SvCUR(PL_formtarget);
a378 2
	    /* Formats aren't yet marked for locales, so assume "yes". */
	    SET_NUMERIC_LOCAL();
d399 2
a400 2
		    SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
		    lines += FmLINES(PL_formtarget);
d406 1
a406 1
		    FmLINES(PL_formtarget) = lines;
d418 1
a418 7
	    s = chophere;
	    send = item + len;
	    if (chopspace) {
		while (*s && isSPACE(*s) && s < send)
		    s++;
	    }
	    if (s < send) {
d427 1
a427 1
		    while (s > SvPVX(PL_formtarget) && isSPACE(s[-1]))
d438 2
a439 2
	    SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
	    FmLINES(PL_formtarget) += lines;
d448 1
a448 1
    djSP;
d451 1
a451 1
    if (PL_stack_base + *PL_markstack_ptr == SP) {
d453 7
a459 7
	if (GIMME_V == G_SCALAR)
	    XPUSHs(&PL_sv_no);
	RETURNOP(PL_op->op_next->op_next);
    }
    PL_stack_sp = PL_stack_base + *PL_markstack_ptr + 1;
    pp_pushmark(ARGS);				/* push dst */
    pp_pushmark(ARGS);				/* push src */
d463 2
a464 6
#ifdef USE_THREADS
    /* SAVE_DEFSV does *not* suffice here */
    save_sptr(&THREADSV(0));
#else
    SAVESPTR(GvSV(PL_defgv));
#endif /* USE_THREADS */
d466 1
a466 1
    SAVESPTR(PL_curpm);
d468 1
a468 1
    src = PL_stack_base[*PL_markstack_ptr];
d470 1
a470 1
    DEFSV = src;
d473 3
a475 3
    if (PL_op->op_type == OP_MAPSTART)
	pp_pushmark(ARGS);			/* push top */
    return ((LOGOP*)PL_op->op_next)->op_other;
d485 2
a486 2
    djSP;
    I32 diff = (SP - PL_stack_base) - *PL_markstack_ptr;
d492 1
a492 1
    ++PL_markstack_ptr[-1];
d494 3
a496 3
	if (diff > PL_markstack_ptr[-1] - PL_markstack_ptr[-2]) {
	    shift = diff - (PL_markstack_ptr[-1] - PL_markstack_ptr[-2]);
	    count = (SP - PL_stack_base) - PL_markstack_ptr[-1] + 2;
d498 5
a502 5
	    EXTEND(SP,shift);
	    src = SP;
	    dst = (SP += shift);
	    PL_markstack_ptr[-1] += shift;
	    *PL_markstack_ptr += shift;
d506 1
a506 1
	dst = PL_stack_base + (PL_markstack_ptr[-2] += diff) - 1; 
d514 1
a514 1
    if (PL_markstack_ptr[-1] > *PL_markstack_ptr) {
a515 1
	I32 gimme = GIMME_V;
d520 1
a520 1
	items = --*PL_markstack_ptr - PL_markstack_ptr[-1];
d522 2
a523 2
	SP = PL_stack_base + POPMARK;		/* pop original mark */
	if (gimme == G_SCALAR) {
d526 1
d528 1
a528 2
	else if (gimme == G_ARRAY)
	    SP += items;
d535 1
a535 1
	SAVESPTR(PL_curpm);
d537 1
a537 1
	src = PL_stack_base[PL_markstack_ptr[-1]];
d539 1
a539 1
	DEFSV = src;
a544 54
#define tryCALL_AMAGICbin(left,right,meth,svp) STMT_START { \
	  *svp = Nullsv;				\
          if (PL_amagic_generation) { \
	    if (SvAMAGIC(left)||SvAMAGIC(right))\
		*svp = amagic_call(left, \
				   right, \
				   CAT2(meth,_amg), \
				   0); \
	  } \
	} STMT_END

STATIC I32
amagic_cmp(register SV *str1, register SV *str2)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(str1,str2,scmp,&tmpsv);
    if (tmpsv) {
    	double d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_cmp(str1, str2);
}

STATIC I32
amagic_cmp_locale(register SV *str1, register SV *str2)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(str1,str2,scmp,&tmpsv);
    if (tmpsv) {
    	double d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_cmp_locale(str1, str2);
}
d548 1
a548 1
    djSP; dMARK; dORIGMARK;
d556 1
a556 2
    OP* nextop = PL_op->op_next;
    I32 overloading = 0;
d563 3
a565 4
    ENTER;
    SAVEPPTR(PL_sortcop);
    if (PL_op->op_flags & OPf_STACKED) {
	if (PL_op->op_flags & OPf_SPECIAL) {
d569 2
a570 2
	    PL_sortcop = kid->op_next;
	    stash = PL_curcop->cop_stash;
d577 1
a577 1
		    gv_efullname3(tmpstr, gv, Nullch);
d590 1
a590 1
	    PL_sortcop = CvSTART(cv);
d593 3
a595 3

	    SAVESPTR(PL_curpad);
	    PL_curpad = AvARRAY((AV*)AvARRAY(CvPADLIST(cv))[1]);
d599 2
a600 2
	PL_sortcop = Nullop;
	stash = PL_curcop->cop_stash;
d607 4
a610 9
	    SvTEMP_off(*up);
	    if (!PL_sortcop && !SvPOK(*up)) {
	        if (SvAMAGIC(*up))
	            overloading = 1;
	        else {
		    STRLEN n_a;
		    (void)sv_2pv(*up, &n_a);
		}
	    }
d615 1
a615 1
    if (PL_sortcop) {
d617 2
a618 1
	    PERL_CONTEXT *cx;
a619 1
	    bool oldcatch = CATCH_GET;
d622 1
a622 1
	    SAVEOP();
d624 22
a645 26
	    CATCH_SET(TRUE);
	    PUSHSTACKi(PERLSI_SORT);
	    if (PL_sortstash != stash) {
		PL_firstgv = gv_fetchpv("a", TRUE, SVt_PV);
		PL_secondgv = gv_fetchpv("b", TRUE, SVt_PV);
		PL_sortstash = stash;
	    }

	    SAVESPTR(GvSV(PL_firstgv));
	    SAVESPTR(GvSV(PL_secondgv));

	    PUSHBLOCK(cx, CXt_NULL, PL_stack_base);
	    if (!(PL_op->op_flags & OPf_SPECIAL)) {
		bool hasargs = FALSE;
		cx->cx_type = CXt_SUB;
		cx->blk_gimme = G_SCALAR;
		PUSHSUB(cx);
		if (!CvDEPTH(cv))
		    (void)SvREFCNT_inc(cv); /* in preparation for POPSUB */
	    }
	    PL_sortcxix = cxstack_ix;
	    qsortsv((myorigmark+1), max, FUNC_NAME_TO_PTR(sortcv));

	    POPBLOCK(cx,PL_curpm);
	    POPSTACK;
	    CATCH_SET(oldcatch);
d647 1
d652 1
a652 8
	    qsortsv(ORIGMARK+1, max,
		    (PL_op->op_private & OPpLOCALE)
		    ? ( overloading
		        ? FUNC_NAME_TO_PTR(amagic_cmp_locale)
		        : FUNC_NAME_TO_PTR(sv_cmp_locale))
		    : ( overloading 
		        ? FUNC_NAME_TO_PTR(amagic_cmp)
		        : FUNC_NAME_TO_PTR(sv_cmp) ));
d655 1
a655 2
    LEAVE;
    PL_stack_sp = ORIGMARK + max;
d665 1
a665 1
    return SvTRUEx(PAD_SV(PL_op->op_targ)) ? cCONDOP->op_false : cCONDOP->op_true;
d670 1
a670 1
    djSP;
d677 1
a677 1
	SV *targ = PAD_SV(PL_op->op_targ);
d679 2
a680 2
	if ((PL_op->op_private & OPpFLIP_LINENUM)
	  ? (PL_last_in_gv && SvIV(sv) == (IV)IoLINES(GvIOp(PL_last_in_gv)))
d683 1
a683 1
	    if (PL_op->op_flags & OPf_SPECIAL) {
a684 1
		SETs(targ);
d689 1
a689 1
		SP--;
d701 1
a701 1
    djSP;
d705 1
a705 1
	register I32 i, j;
d710 1
a710 4
	  (looks_like_number(left) && *SvPVX(left) != '0') )
	{
	    if (SvNV(left) < IV_MIN || SvNV(right) > IV_MAX)
		croak("Range iterator outside integer range");
d713 5
a717 9
	    if (max >= i) {
		j = max - i + 1;
		EXTEND_MORTAL(j);
		EXTEND(SP, j);
	    }
	    else
		j = 0;
	    while (j--) {
		sv = sv_2mortal(newSViv(i++));
a723 1
	    STRLEN n_a;
d727 2
a728 2
	    SvPV_force(sv,n_a);
	    while (!SvNIOKp(sv) && SvCUR(sv) <= len) {
a729 2
	        if (strEQ(SvPVX(sv),tmps))
	            break;
d733 2
d741 2
a742 2
	if ((PL_op->op_private & OPpFLIP_LINENUM)
	  ? (PL_last_in_gv && SvIV(sv) == (IV)IoLINES(GvIOp(PL_last_in_gv)))
d755 3
a757 2
STATIC I32
dopoptolabel(char *label)
a758 1
    dTHR;
d760 1
a760 1
    register PERL_CONTEXT *cx;
d764 1
a764 1
	switch (CxTYPE(cx)) {
d766 2
a767 2
	    if (PL_dowarn)
		warn("Exiting substitution via %s", op_name[PL_op->op_type]);
d770 2
a771 2
	    if (PL_dowarn)
		warn("Exiting subroutine via %s", op_name[PL_op->op_type]);
d774 2
a775 2
	    if (PL_dowarn)
		warn("Exiting eval via %s", op_name[PL_op->op_type]);
a776 4
	case CXt_NULL:
	    if (PL_dowarn)
		warn("Exiting pseudo-block via %s", op_name[PL_op->op_type]);
	    return -1;
d780 2
a781 2
		DEBUG_l(deb("(Skipping label #%ld %s)\n",
			(long)i, cx->blk_loop.label));
d784 1
a784 1
	    DEBUG_l( deb("(Found label #%ld %s)\n", (long)i, label));
d792 1
a792 8
dowantarray(void)
{
    I32 gimme = block_gimme();
    return (gimme == G_VOID) ? G_SCALAR : gimme;
}

I32
block_gimme(void)
a793 1
    dTHR;
d798 1
a798 1
	return G_VOID;
d800 3
a802 4
    switch (cxstack[cxix].blk_gimme) {
    case G_VOID:
	return G_VOID;
    case G_SCALAR:
a803 14
    case G_ARRAY:
	return G_ARRAY;
    default:
	croak("panic: bad gimme: %d\n", cxstack[cxix].blk_gimme);
	/* NOTREACHED */
	return 0;
    }
}

STATIC I32
dopoptosub(I32 startingblock)
{
    dTHR;
    return dopoptosub_at(cxstack, startingblock);
d806 3
a808 2
STATIC I32
dopoptosub_at(PERL_CONTEXT *cxstk, I32 startingblock)
a809 1
    dTHR;
d811 1
a811 1
    register PERL_CONTEXT *cx;
d813 2
a814 2
	cx = &cxstk[i];
	switch (CxTYPE(cx)) {
d819 1
a819 1
	    DEBUG_l( deb("(Found sub #%ld)\n", (long)i));
d826 3
a828 2
STATIC I32
dopoptoeval(I32 startingblock)
a829 1
    dTHR;
d831 1
a831 1
    register PERL_CONTEXT *cx;
d834 1
a834 1
	switch (CxTYPE(cx)) {
d838 1
a838 1
	    DEBUG_l( deb("(Found eval #%ld)\n", (long)i));
d845 3
a847 2
STATIC I32
dopoptoloop(I32 startingblock)
a848 1
    dTHR;
d850 1
a850 1
    register PERL_CONTEXT *cx;
d853 1
a853 1
	switch (CxTYPE(cx)) {
d855 2
a856 2
	    if (PL_dowarn)
		warn("Exiting substitution via %s", op_name[PL_op->op_type]);
d859 2
a860 2
	    if (PL_dowarn)
		warn("Exiting subroutine via %s", op_name[PL_op->op_type]);
d863 2
a864 2
	    if (PL_dowarn)
		warn("Exiting eval via %s", op_name[PL_op->op_type]);
a865 4
	case CXt_NULL:
	    if (PL_dowarn)
		warn("Exiting pseudo-block via %s", op_name[PL_op->op_type]);
	    return -1;
d867 1
a867 1
	    DEBUG_l( deb("(Found loop #%ld)\n", (long)i));
d875 2
a876 1
dounwind(I32 cxix)
d878 1
a878 2
    dTHR;
    register PERL_CONTEXT *cx;
d883 3
a885 3
	cx = &cxstack[cxstack_ix];
	DEBUG_l(PerlIO_printf(Perl_debug_log, "Unwinding block %ld, type %s\n",
			      (long) cxstack_ix, block_type[CxTYPE(cx)]));
d887 1
a887 4
	switch (CxTYPE(cx)) {
	case CXt_SUBST:
	    POPSUBST(cx);
	    continue;  /* not break */
d897 1
a897 1
	case CXt_NULL:
a899 1
	cxstack_ix--;
d903 41
d945 2
a946 1
die_where(char *message)
d948 1
a948 3
    dSP;
    STRLEN n_a;
    if (PL_in_eval) {
d950 1
a950 1
	register PERL_CONTEXT *cx;
d954 13
a966 19
	if (message) {
	    if (PL_in_eval & 4) {
		SV **svp;
		STRLEN klen = strlen(message);
		
		svp = hv_fetch(ERRHV, message, klen, TRUE);
		if (svp) {
		    if (!SvIOK(*svp)) {
			static char prefix[] = "\t(in cleanup) ";
			SV *err = ERRSV;
			sv_upgrade(*svp, SVt_IV);
			(void)SvIOK_only(*svp);
			if (!SvPOK(err))
			    sv_setpv(err,"");
			SvGROW(err, SvCUR(err)+sizeof(prefix)+klen);
			sv_catpvn(err, prefix, sizeof(prefix)-1);
			sv_catpvn(err, message, klen);
		    }
		    sv_inc(*svp);
d968 1
a969 2
	    else
		sv_setpv(ERRSV, message);
d972 3
a974 7
	    message = SvPVx(ERRSV, n_a);

	while ((cxix = dopoptoeval(cxstack_ix)) < 0 && PL_curstackinfo->si_prev) {
	    dounwind(-1);
	    POPSTACK;
	}

d981 3
a983 3
	    POPBLOCK(cx,PL_curpm);
	    if (CxTYPE(cx) != CXt_EVAL) {
		PerlIO_printf(PerlIO_stderr(), "panic: die %s", message);
d989 2
a990 2
		*++newsp = &PL_sv_undef;
	    PL_stack_sp = newsp;
d994 2
a995 4
	    if (optype == OP_REQUIRE) {
		char* msg = SvPVx(ERRSV, n_a);
		DIE("%s", *msg ? msg : "Compilation failed in require");
	    }
d999 17
a1015 6
    if(!message)
	message = SvPVx(ERRSV, n_a);
    PerlIO_printf(PerlIO_stderr(), "%s",message);
    PerlIO_flush(PerlIO_stderr());
    my_failure_exit();
    /* NOTREACHED */
d1021 1
a1021 1
    djSP; dPOPTOPssrl;
d1030 1
a1030 1
    djSP;
d1039 1
a1039 1
    djSP;
d1046 15
d1063 1
a1063 1
    djSP;
d1065 1
a1065 3
    register PERL_CONTEXT *cx;
    register PERL_CONTEXT *ccstack = cxstack;
    PERL_SI *top_si = PL_curstackinfo;
a1066 2
    I32 gimme;
    HV *hv;
a1073 6
	/* we may be in a higher stacklevel, so dig down deeper */
	while (cxix < 0 && top_si->si_type != PERLSI_MAIN) {
	    top_si = top_si->si_prev;
	    ccstack = top_si->si_cxstack;
	    cxix = dopoptosub_at(ccstack, top_si->si_cxix);
	}
d1079 2
a1080 2
	if (PL_DBsub && cxix >= 0 &&
		ccstack[cxix].blk_sub.cv == GvCV(PL_DBsub))
d1084 1
a1084 1
	cxix = dopoptosub_at(ccstack, cxix - 1);
d1086 4
a1089 5

    cx = &ccstack[cxix];
    if (CxTYPE(cx) == CXt_SUB) {
        dbcxix = dopoptosub_at(ccstack, cxix - 1);
	/* We expect that ccstack[dbcxix] is CXt_SUB, anyway, the
d1091 2
a1092 2
	if (PL_DBsub && dbcxix >= 0 && ccstack[dbcxix].blk_sub.cv == GvCV(PL_DBsub))
	    cx = &ccstack[dbcxix];
d1096 4
a1099 8
	hv = cx->blk_oldcop->cop_stash;
	if (!hv)
	    PUSHs(&PL_sv_undef);
	else {
	    dTARGET;
	    sv_setpv(TARG, HvNAME(hv));
	    PUSHs(TARG);
	}
d1103 1
a1103 5
    hv = cx->blk_oldcop->cop_stash;
    if (!hv)
	PUSHs(&PL_sv_undef);
    else
	PUSHs(sv_2mortal(newSVpv(HvNAME(hv), 0)));
d1108 1
a1108 1
    if (CxTYPE(cx) == CXt_SUB) { /* So is ccstack[dbcxix]. */
d1110 1
a1110 1
	gv_efullname3(sv, CvGV(ccstack[cxix].blk_sub.cv), Nullch);
d1118 2
a1119 6
    gimme = (I32)cx->blk_gimme;
    if (gimme == G_VOID)
	PUSHs(&PL_sv_undef);
    else
	PUSHs(sv_2mortal(newSViv(gimme & G_ARRAY)));
    if (CxTYPE(cx) == CXt_EVAL) {
d1122 1
a1122 1
	    PUSHs(&PL_sv_no);
d1127 1
a1127 1
	    PUSHs(&PL_sv_yes);
d1130 1
a1130 1
    else if (CxTYPE(cx) == CXt_SUB &&
d1132 1
a1132 1
	    PL_curcop->cop_stash == PL_debstash)
d1137 1
a1137 1
	if (!PL_dbargs) {
d1139 1
a1139 1
	    PL_dbargs = GvAV(gv_AVadd(tmpgv = gv_fetchpv("DB::args", TRUE,
d1142 1
a1142 1
	    AvREAL_off(PL_dbargs);		/* XXX Should be REIFY */
d1145 4
a1148 4
	if (AvMAX(PL_dbargs) < AvFILLp(ary) + off)
	    av_extend(PL_dbargs, AvFILLp(ary) + off);
	Copy(AvALLOC(ary), AvARRAY(PL_dbargs), AvFILLp(ary) + 1 + off, SV*);
	AvFILLp(PL_dbargs) = AvFILLp(ary) + off;
d1153 9
a1161 6
STATIC I32
sortcv(SV *a, SV *b)
{
    dTHR;
    I32 oldsaveix = PL_savestack_ix;
    I32 oldscopeix = PL_scopestack_ix;
d1163 6
a1168 6
    GvSV(PL_firstgv) = a;
    GvSV(PL_secondgv) = b;
    PL_stack_sp = PL_stack_base;
    PL_op = PL_sortcop;
    CALLRUNOPS();
    if (PL_stack_sp != PL_stack_base + 1)
d1170 1
a1170 1
    if (!SvNIOKp(*PL_stack_sp))
d1172 2
a1173 2
    result = SvIV(*PL_stack_sp);
    while (PL_scopestack_ix > oldscopeix) {
d1180 34
d1216 1
a1216 1
    djSP;
a1217 1
    STRLEN n_a;
d1222 3
a1224 3
	tmps = POPpx;
    sv_reset(tmps, PL_curcop->cop_stash);
    PUSHs(&PL_sv_yes);
d1235 1
a1235 1
    PL_curcop = (COP*)PL_op;
d1237 1
a1237 1
    PL_stack_sp = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;
d1240 1
a1240 1
    if (PL_op->op_private || SvIV(PL_DBsingle) || SvIV(PL_DBsignal) || SvIV(PL_DBtrace))
d1242 1
a1242 1
	djSP;
d1244 1
a1244 1
	register PERL_CONTEXT *cx;
d1249 1
a1249 1
	gv = PL_DBgv;
d1254 1
a1254 1
	if (CvDEPTH(cv) >= 1 && !(PL_debug & (1<<30))) /* don't do recursive DB::DB call */
d1260 3
a1262 3
	SAVEI32(PL_debug);
	SAVESTACK_POS();
	PL_debug = 0;
d1264 1
a1264 1
	SPAGAIN;
d1266 2
a1267 2
	push_return(PL_op->op_next);
	PUSHBLOCK(cx, CXt_SUB, SP);
d1271 2
a1272 2
	SAVESPTR(PL_curpad);
	PL_curpad = AvARRAY((AV*)*av_fetch(CvPADLIST(cv),1,FALSE));
d1286 3
a1288 3
    djSP; dMARK;
    register PERL_CONTEXT *cx;
    I32 gimme = GIMME_V;
d1294 2
a1295 7
#ifdef USE_THREADS
    if (PL_op->op_flags & OPf_SPECIAL) {
	dTHR;
	svp = &THREADSV(PL_op->op_targ);	/* per-thread variable */
	SAVEGENERICSV(*svp);
	*svp = NEWSV(0,0);
    }
a1296 6
#endif /* USE_THREADS */
    if (PL_op->op_targ) {
	svp = &PL_curpad[PL_op->op_targ];		/* "my" variable */
	SAVESPTR(*svp);
    }
    else {
d1298 2
a1299 3
	SAVEGENERICSV(*svp);
	*svp = NEWSV(0,0);
    }
d1305 4
a1308 15
    if (PL_op->op_flags & OPf_STACKED) {
	cx->blk_loop.iterary = (AV*)SvREFCNT_inc(POPs);
	if (SvTYPE(cx->blk_loop.iterary) != SVt_PVAV) {
	    dPOPss;
	    if (SvNIOKp(sv) || !SvPOKp(sv) ||
		(looks_like_number(sv) && *SvPVX(sv) != '0')) {
		 if (SvNV(sv) < IV_MIN ||
		     SvNV((SV*)cx->blk_loop.iterary) >= IV_MAX)
		     croak("Range iterator outside integer range");
		 cx->blk_loop.iterix = SvIV(sv);
		 cx->blk_loop.itermax = SvIV((SV*)cx->blk_loop.iterary);
	    }
	    else
		cx->blk_loop.iterlval = newSVsv(sv);
	}
d1311 3
a1313 3
	cx->blk_loop.iterary = PL_curstack;
	AvFILLp(PL_curstack) = SP - PL_stack_base;
	cx->blk_loop.iterix = MARK - PL_stack_base;
d1321 3
a1323 3
    djSP;
    register PERL_CONTEXT *cx;
    I32 gimme = GIMME_V;
d1337 2
a1338 3
    djSP;
    register PERL_CONTEXT *cx;
    struct block_loop cxloop;
d1346 10
a1355 10
    POPLOOP1(cx);	/* Delay POPLOOP2 until stack values are safe */

    TAINT_NOT;
    if (gimme == G_VOID)
	; /* do nothing */
    else if (gimme == G_SCALAR) {
	if (mark < SP)
	    *++newsp = sv_mortalcopy(*SP);
	else
	    *++newsp = &PL_sv_undef;
d1358 1
a1358 1
	while (mark < SP) {
a1359 2
	    TAINT_NOT;		/* Each item is independent */
	}
d1361 2
a1362 6
    SP = newsp;
    PUTBACK;

    POPLOOP2();		/* Stack values are safe: release loop vars ... */
    PL_curpm = newpm;	/* ... and pop $1 et al */

d1366 1
a1366 1
    return NORMAL;
d1371 1
a1371 1
    djSP; dMARK;
d1373 1
a1373 3
    register PERL_CONTEXT *cx;
    struct block_sub cxsub;
    bool popsub2 = FALSE;
d1379 6
a1384 6
    if (PL_curstackinfo->si_type == PERLSI_SORT) {
	if (cxstack_ix == PL_sortcxix || dopoptosub(cxstack_ix) <= PL_sortcxix) {
	    if (cxstack_ix > PL_sortcxix)
		dounwind(PL_sortcxix);
	    AvARRAY(PL_curstack)[1] = *SP;
	    PL_stack_sp = PL_stack_base + 1;
d1396 1
a1396 1
    switch (CxTYPE(cx)) {
d1398 1
a1398 2
	POPSUB1(cx);	/* Delay POPSUB2 until stack values are safe */
	popsub2 = TRUE;
a1404 1
	    /* Unassume the success we assumed earlier. */
d1406 1
a1406 1
	    (void)hv_delete(GvHVn(PL_incgv), name, strlen(name), G_DISCARD);
d1412 1
a1414 1
    TAINT_NOT;
d1416 4
a1419 17
	if (MARK < SP) {
	    if (popsub2) {
		if (cxsub.cv && CvDEPTH(cxsub.cv) > 1) {
		    if (SvTEMP(TOPs)) {
			*++newsp = SvREFCNT_inc(*SP);
			FREETMPS;
			sv_2mortal(*newsp);
		    } else {
			FREETMPS;
			*++newsp = sv_mortalcopy(*SP);
		    }
		} else
		    *++newsp = (SvTEMP(*SP)) ? *SP : sv_mortalcopy(*SP);
	    } else
		*++newsp = sv_mortalcopy(*SP);
	} else
	    *++newsp = &PL_sv_undef;
d1421 3
a1423 6
    else if (gimme == G_ARRAY) {
	while (++MARK <= SP) {
	    *++newsp = (popsub2 && SvTEMP(*MARK))
			? *MARK : sv_mortalcopy(*MARK);
	    TAINT_NOT;		/* Each item is independent */
	}
d1425 2
a1426 7
    PL_stack_sp = newsp;

    /* Stack values are safe: */
    if (popsub2) {
	POPSUB2();	/* release CV and @@_ ... */
    }
    PL_curpm = newpm;	/* ... and pop $1 et al */
d1434 1
a1434 1
    djSP;
d1436 1
a1436 4
    register PERL_CONTEXT *cx;
    struct block_loop cxloop;
    struct block_sub cxsub;
    I32 pop2 = 0;
d1442 1
a1442 1
    SV **mark = PL_stack_base + cxstack[cxstack_ix].blk_oldsp;
d1444 1
a1444 1
    if (PL_op->op_flags & OPf_SPECIAL) {
d1458 1
a1458 1
    switch (CxTYPE(cx)) {
d1460 3
a1462 3
	POPLOOP1(cx);	/* Delay POPLOOP2 until stack values are safe */
	pop2 = CXt_LOOP;
	nextop = cxloop.last_op->op_next;
d1464 2
a1465 3
    case CXt_SUB:
	POPSUB1(cx);	/* Delay POPSUB2 until stack values are safe */
	pop2 = CXt_SUB;
d1468 2
a1469 2
    case CXt_EVAL:
	POPEVAL(cx);
d1474 1
a1476 1
    TAINT_NOT;
d1478 2
a1479 3
	if (MARK < SP)
	    *++newsp = ((pop2 == CXt_SUB) && SvTEMP(*SP))
			? *SP : sv_mortalcopy(*SP);
d1481 1
a1481 1
	    *++newsp = &PL_sv_undef;
d1483 3
a1485 19
    else if (gimme == G_ARRAY) {
	while (++MARK <= SP) {
	    *++newsp = ((pop2 == CXt_SUB) && SvTEMP(*MARK))
			? *MARK : sv_mortalcopy(*MARK);
	    TAINT_NOT;		/* Each item is independent */
	}
    }
    SP = newsp;
    PUTBACK;

    /* Stack values are safe: */
    switch (pop2) {
    case CXt_LOOP:
	POPLOOP2();	/* release loop vars ... */
	LEAVE;
	break;
    case CXt_SUB:
	POPSUB2();	/* release CV and @@_ ... */
	break;
d1487 2
a1488 1
    PL_curpm = newpm;	/* ... and pop $1 et al */
d1491 1
a1491 1
    return nextop;
d1497 1
a1497 1
    register PERL_CONTEXT *cx;
d1500 1
a1500 1
    if (PL_op->op_flags & OPf_SPECIAL) {
d1514 1
a1514 1
    oldsave = PL_scopestack[PL_scopestack_ix - 1];
d1522 1
a1522 1
    register PERL_CONTEXT *cx;
d1525 1
a1525 1
    if (PL_op->op_flags & OPf_SPECIAL) {
d1539 1
a1539 1
    oldsave = PL_scopestack[PL_scopestack_ix - 1];
d1544 7
a1550 2
STATIC OP *
dofindlabel(OP *o, char *label, OP **opstack, OP **oplimit)
a1553 1
    static char too_deep[] = "Target of goto is too deeply nested";
d1555 5
a1559 11
    if (ops >= oplimit)
	croak(too_deep);
    if (o->op_type == OP_LEAVE ||
	o->op_type == OP_SCOPE ||
	o->op_type == OP_LEAVELOOP ||
	o->op_type == OP_LEAVETRY)
    {
	*ops++ = cUNOPo->op_first;
	if (ops >= oplimit)
	    croak(too_deep);
    }
d1561 1
a1561 2
    if (o->op_flags & OPf_KIDS) {
	dTHR;
d1563 1
a1563 1
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling) {
d1568 2
a1569 2
	for (kid = cUNOPo->op_first; kid; kid = kid->op_sibling) {
	    if (kid == PL_lastgotoprobe)
d1571 10
a1580 7
	    if ((kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) &&
		(ops == opstack ||
		 (ops[-1]->op_type != OP_NEXTSTATE &&
		  ops[-1]->op_type != OP_DBSTATE)))
		*ops++ = kid;
	    if (o = dofindlabel(kid, label, ops, oplimit))
		return o;
d1595 1
a1595 1
    djSP;
d1598 2
a1599 3
    register PERL_CONTEXT *cx;
#define GOTO_DEPTH 64
    OP *enterops[GOTO_DEPTH];
d1601 1
a1601 1
    int do_dump = (PL_op->op_type == OP_DUMP);
d1604 1
a1604 1
    if (PL_op->op_flags & OPf_STACKED) {
a1605 1
	STRLEN n_a;
d1610 1
a1610 1
	    register PERL_CONTEXT *cx;
a1614 1
	    int arg_was_real = 0;
a1615 1
	retry:
d1617 3
a1619 13
		GV *gv = CvGV(cv);
		GV *autogv;
		if (gv) {
		    SV *tmpstr;
		    /* autoloaded stub? */
		    if (cv != GvCV(gv) && (cv = GvCV(gv)))
			goto retry;
		    autogv = gv_autoload4(GvSTASH(gv), GvNAME(gv),
					  GvNAMELEN(gv), FALSE);
		    if (autogv && (cv = GvCV(autogv)))
			goto retry;
		    tmpstr = sv_newmortal();
		    gv_efullname3(tmpstr, gv, Nullch);
d1632 2
a1633 5
	    if (CxTYPE(cx) == CXt_EVAL && cx->blk_eval.old_op_type == OP_ENTEREVAL) 
		DIE("Can't goto subroutine from an eval-string");
	    mark = PL_stack_sp;
	    if (CxTYPE(cx) == CXt_SUB &&
		cx->blk_sub.hasargs) {   /* put @@_ back onto stack */
d1636 5
a1640 13
		items = AvFILLp(av) + 1;
		PL_stack_sp++;
		EXTEND(PL_stack_sp, items); /* @@_ could have been extended. */
		Copy(AvARRAY(av), PL_stack_sp, items, SV*);
		PL_stack_sp += items;
#ifndef USE_THREADS
		SvREFCNT_dec(GvAV(PL_defgv));
		GvAV(PL_defgv) = cx->blk_sub.savearray;
#endif /* USE_THREADS */
		if (AvREAL(av)) {
		    arg_was_real = 1;
		    AvREAL_off(av);	/* so av_clear() won't clobber elts */
		}
d1643 1
a1643 16
	    else if (CvXSUB(cv)) {	/* put GvAV(defgv) back onto stack */
		AV* av;
		int i;
#ifdef USE_THREADS
		av = (AV*)PL_curpad[0];
#else
		av = GvAV(PL_defgv);
#endif
		items = AvFILLp(av) + 1;
		PL_stack_sp++;
		EXTEND(PL_stack_sp, items); /* @@_ could have been extended. */
		Copy(AvARRAY(av), PL_stack_sp, items, SV*);
		PL_stack_sp += items;
	    }
	    if (CxTYPE(cx) == CXt_SUB &&
		!(CvDEPTH(cx->blk_sub.cv) = cx->blk_sub.olddepth))
d1645 1
a1645 1
	    oldsave = PL_scopestack[PL_scopestack_ix - 1];
d1653 3
a1655 3
		    while (SP > mark) {
			SP[1] = SP[0];
			SP--;
d1659 1
a1659 1
		                   mark - PL_stack_base + 1,
d1661 1
a1661 1
		    SP = PL_stack_base + items;
d1664 1
a1664 10
		    SV **newsp;
		    I32 gimme;

		    PL_stack_sp--;		/* There is no cv arg. */
		    /* Push a mark for the start of arglist */
		    PUSHMARK(mark); 
		    (void)(*CvXSUB(cv))(cv _PERL_OBJECT_THIS);
		    /* Pop the current context like a decent sub should */
		    POPBLOCK(cx, PL_curpm);
		    /* Do _not_ use PUTBACK, keep the XSUB's return stack! */
a1671 6
		if (CxTYPE(cx) == CXt_EVAL) {
		    PL_in_eval = cx->blk_eval.old_in_eval;
		    PL_eval_root = cx->blk_eval.old_eval_root;
		    cx->cx_type = CXt_SUB;
		    cx->blk_sub.hasargs = 0;
		}
d1678 4
a1681 3
		    if (CvDEPTH(cv) == 100 && PL_dowarn)
			sub_crush_depth(cv);
		    if (CvDEPTH(cv) > AvFILLp(padlist)) {
d1684 1
a1684 1
			I32 ix = AvFILLp((AV*)svp[1]);
d1687 1
a1687 1
			    if (svp[ix] != &PL_sv_undef) {
d1689 2
a1690 4
				if ((SvFLAGS(svp[ix]) & SVf_FAKE)
				    || *name == '&')
				{
				    /* outer lexical or anon code */
d1716 1
a1716 1
			AvFILLp(padlist) = CvDEPTH(cv);
d1720 4
a1723 21
#ifdef USE_THREADS
		if (!cx->blk_sub.hasargs) {
		    AV* av = (AV*)PL_curpad[0];
		    
		    items = AvFILLp(av) + 1;
		    if (items) {
			/* Mark is at the end of the stack. */
			EXTEND(SP, items);
			Copy(AvARRAY(av), SP + 1, items, SV*);
			SP += items;
			PUTBACK ;		    
		    }
		}
#endif /* USE_THREADS */		
		SAVESPTR(PL_curpad);
		PL_curpad = AvARRAY((AV*)svp[CvDEPTH(cv)]);
#ifndef USE_THREADS
		if (cx->blk_sub.hasargs)
#endif /* USE_THREADS */
		{
		    AV* av = (AV*)PL_curpad[0];
d1726 1
a1726 4
#ifndef USE_THREADS
		    cx->blk_sub.savearray = GvAV(PL_defgv);
		    GvAV(PL_defgv) = (AV*)SvREFCNT_inc(av);
#endif /* USE_THREADS */
d1728 1
d1745 2
a1746 6
		    AvFILLp(av) = items - 1;
		    /* preserve @@_ nature */
		    if (arg_was_real) {
			AvREIFY_off(av);
			AvREAL_on(av);
		    }
a1752 21
		if (PERLDB_SUB) {	/* Checking curstash breaks DProf. */
		    /*
		     * We do not care about using sv to call CV;
		     * it's for informational purposes only.
		     */
		    SV *sv = GvSV(PL_DBsub);
		    CV *gotocv;
		    
		    if (PERLDB_SUB_NN) {
			SvIVX(sv) = (IV)cv; /* Already upgraded, saved */
		    } else {
			save_item(sv);
			gv_efullname3(sv, CvGV(cv), Nullch);
		    }
		    if (  PERLDB_GOTO
			  && (gotocv = perl_get_cv("DB::goto", FALSE)) ) {
			PUSHMARK( PL_stack_sp );
			perl_call_sv((SV*)gotocv, G_SCALAR | G_NODEBUG);
			PL_stack_sp--;
		    }
		}
d1757 1
a1757 1
	    label = SvPV(sv,n_a);
d1759 1
a1759 1
    else if (PL_op->op_flags & OPf_SPECIAL) {
d1771 1
a1771 1
	PL_lastgotoprobe = 0;
d1775 4
a1778 1
	    switch (CxTYPE(cx)) {
d1780 1
a1780 1
		gotoprobe = PL_eval_root; /* XXX not good for nested eval */
d1791 1
a1791 1
		    gotoprobe = PL_main_root;
a1792 8
	    case CXt_SUB:
		if (CvDEPTH(cx->blk_sub.cv)) {
		    gotoprobe = CvROOT(cx->blk_sub.cv);
		    break;
		}
		/* FALL THROUGH */
	    case CXt_NULL:
		DIE("Can't \"goto\" outside a block");
d1796 2
a1797 1
		gotoprobe = PL_main_root;
d1800 1
a1800 2
	    retop = dofindlabel(gotoprobe, label,
				enterops, enterops + GOTO_DEPTH);
d1803 1
a1803 1
	    PL_lastgotoprobe = gotoprobe;
d1817 1
a1817 1
	    oldsave = PL_scopestack[PL_scopestack_ix];
d1824 1
a1824 1
	    OP *oldop = PL_op;
d1826 2
a1827 7
		PL_op = enterops[ix];
		/* Eventually we may want to stack the needed arguments
		 * for each op.  For now, we punt on the hard ones. */
		if (PL_op->op_type == OP_ENTERITER)
		    DIE("Can't \"goto\" into the middle of a foreach loop",
			label);
		(CALLOP->op_ppaddr)(ARGS);
d1829 1
a1829 1
	    PL_op = oldop;
d1835 1
a1835 1
	if (!retop) retop = PL_main_start;
d1837 2
a1838 2
	PL_restartop = retop;
	PL_do_undump = TRUE;
d1842 7
a1848 2
	PL_restartop = 0;		/* hmm, must be GNU unexec().. */
	PL_do_undump = FALSE;
d1856 1
a1856 1
    djSP;
d1861 1
a1861 1
    else {
a1862 5
#ifdef VMSISH_EXIT
	if (anum == 1 && VMSISH_EXIT)
	    anum = 0;
#endif
    }
d1864 1
a1864 1
    PUSHs(&PL_sv_undef);
d1871 1
a1871 1
    djSP;
d1884 2
a1885 2
    PL_op = cCOP->uop.scop.scop_next[match];
    RETURNOP(PL_op);
d1890 1
a1890 1
    djSP;
d1893 2
a1894 2
    if (PL_multiline)
	PL_op = PL_op->op_next;			/* can't assume anything */
d1896 1
a1896 2
	STRLEN n_a;
	match = *(SvPVx(GvSV(cCOP->cop_gv), n_a)) & 255;
d1902 1
a1902 1
	PL_op = cCOP->uop.scop.scop_next[match];
d1904 1
a1904 1
    RETURNOP(PL_op);
d1910 4
a1913 2
STATIC void
save_lines(AV *array, SV *sv)
d1936 3
a1938 104
STATIC OP *
docatch(OP *o)
{
    dTHR;
    int ret;
    OP *oldop = PL_op;
    dJMPENV;

    PL_op = o;
#ifdef DEBUGGING
    assert(CATCH_GET == TRUE);
    DEBUG_l(deb("Setting up local jumplevel %p, was %p\n", &cur_env, PL_top_env));
#endif
    JMPENV_PUSH(ret);
    switch (ret) {
    default:				/* topmost level handles it */
pass_the_buck:
	JMPENV_POP;
	PL_op = oldop;
	JMPENV_JUMP(ret);
	/* NOTREACHED */
    case 3:
	if (!PL_restartop)
	    goto pass_the_buck;
	PL_op = PL_restartop;
	PL_restartop = 0;
	/* FALL THROUGH */
    case 0:
        CALLRUNOPS();
	break;
    }
    JMPENV_POP;
    PL_op = oldop;
    return Nullop;
}

OP *
sv_compile_2op(SV *sv, OP** startop, char *code, AV** avp)
/* sv Text to convert to OP tree. */
/* startop op_free() this to undo. */
/* code Short string id of the caller. */
{
    dSP;				/* Make POPBLOCK work. */
    PERL_CONTEXT *cx;
    SV **newsp;
    I32 gimme = 0;   /* SUSPECT - INITIALZE TO WHAT?  NI-S */
    I32 optype;
    OP dummy;
    OP *oop = PL_op, *rop;
    char tmpbuf[TYPE_DIGITS(long) + 12 + 10];
    char *safestr;

    ENTER;
    lex_start(sv);
    SAVETMPS;
    /* switch to eval mode */

    if (PL_curcop == &PL_compiling) {
	SAVESPTR(PL_compiling.cop_stash);
	PL_compiling.cop_stash = PL_curstash;
    }
    SAVESPTR(PL_compiling.cop_filegv);
    SAVEI16(PL_compiling.cop_line);
    sprintf(tmpbuf, "_<(%.10s_eval %lu)", code, (unsigned long)++PL_evalseq);
    PL_compiling.cop_filegv = gv_fetchfile(tmpbuf+2);
    PL_compiling.cop_line = 1;
    /* XXX For C<eval "...">s within BEGIN {} blocks, this ends up
       deleting the eval's FILEGV from the stash before gv_check() runs
       (i.e. before run-time proper). To work around the coredump that
       ensues, we always turn GvMULTI_on for any globals that were
       introduced within evals. See force_ident(). GSAR 96-10-12 */
    safestr = savepv(tmpbuf);
    SAVEDELETE(PL_defstash, safestr, strlen(safestr));
    SAVEHINTS();
#ifdef OP_IN_REGISTER
    PL_opsave = op;
#else
    SAVEPPTR(PL_op);
#endif
    PL_hints = 0;

    PL_op = &dummy;
    PL_op->op_type = 0;			/* Avoid uninit warning. */
    PL_op->op_flags = 0;			/* Avoid uninit warning. */
    PUSHBLOCK(cx, CXt_EVAL, SP);
    PUSHEVAL(cx, 0, PL_compiling.cop_filegv);
    rop = doeval(G_SCALAR, startop);
    POPBLOCK(cx,PL_curpm);
    POPEVAL(cx);

    (*startop)->op_type = OP_NULL;
    (*startop)->op_ppaddr = ppaddr[OP_NULL];
    lex_end();
    *avp = (AV*)SvREFCNT_inc(PL_comppad);
    LEAVE;
#ifdef OP_IN_REGISTER
    op = PL_opsave;
#endif
    return rop;
}

/* With USE_THREADS, eval_owner must be held on entry to doeval */
STATIC OP *
doeval(int gimme, OP** startop)
d1941 1
a1941 1
    OP *saveop = PL_op;
a1942 1
    CV *caller;
a1943 1
    I32 i;
d1945 1
a1945 3
    PL_in_eval = 1;

    PUSHMARK(SP);
d1949 19
a1967 41
    SAVEI32(PL_padix);
    SAVESPTR(PL_curpad);
    SAVESPTR(PL_comppad);
    SAVESPTR(PL_comppad_name);
    SAVEI32(PL_comppad_name_fill);
    SAVEI32(PL_min_intro_pending);
    SAVEI32(PL_max_intro_pending);

    caller = PL_compcv;
    for (i = cxstack_ix - 1; i >= 0; i--) {
	PERL_CONTEXT *cx = &cxstack[i];
	if (CxTYPE(cx) == CXt_EVAL)
	    break;
	else if (CxTYPE(cx) == CXt_SUB) {
	    caller = cx->blk_sub.cv;
	    break;
	}
    }

    SAVESPTR(PL_compcv);
    PL_compcv = (CV*)NEWSV(1104,0);
    sv_upgrade((SV *)PL_compcv, SVt_PVCV);
    CvEVAL_on(PL_compcv);
#ifdef USE_THREADS
    CvOWNER(PL_compcv) = 0;
    New(666, CvMUTEXP(PL_compcv), 1, perl_mutex);
    MUTEX_INIT(CvMUTEXP(PL_compcv));
#endif /* USE_THREADS */

    PL_comppad = newAV();
    av_push(PL_comppad, Nullsv);
    PL_curpad = AvARRAY(PL_comppad);
    PL_comppad_name = newAV();
    PL_comppad_name_fill = 0;
    PL_min_intro_pending = 0;
    PL_padix = 0;
#ifdef USE_THREADS
    av_store(PL_comppad_name, 0, newSVpv("@@_", 2));
    PL_curpad[0] = (SV*)newAV();
    SvPADMY_on(PL_curpad[0]);	/* XXX Needed? */
#endif /* USE_THREADS */
d1971 4
a1974 8
    av_store(comppadlist, 0, (SV*)PL_comppad_name);
    av_store(comppadlist, 1, (SV*)PL_comppad);
    CvPADLIST(PL_compcv) = comppadlist;

    if (!saveop || saveop->op_type != OP_REQUIRE)
	CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc(caller);

    SAVEFREESV(PL_compcv);
d1978 8
a1985 8
    newstash = PL_curcop->cop_stash;
    if (PL_curstash != newstash) {
	SAVESPTR(PL_curstash);
	PL_curstash = newstash;
    }
    SAVESPTR(PL_beginav);
    PL_beginav = newAV();
    SAVEFREESV(PL_beginav);
d1989 8
a1996 11
    PL_eval_root = Nullop;
    PL_error_count = 0;
    PL_curcop = &PL_compiling;
    PL_curcop->cop_arybase = 0;
    SvREFCNT_dec(PL_rs);
    PL_rs = newSVpv("\n", 1);
    if (saveop && saveop->op_flags & OPf_SPECIAL)
	PL_in_eval |= 4;
    else
	sv_setpv(ERRSV,"");
    if (yyparse() || PL_error_count || !PL_eval_root) {
d1999 7
a2005 14
	PERL_CONTEXT *cx;
	I32 optype = 0;			/* Might be reset by POPEVAL. */
	STRLEN n_a;

	PL_op = saveop;
	if (PL_eval_root) {
	    op_free(PL_eval_root);
	    PL_eval_root = Nullop;
	}
	SP = PL_stack_base + POPMARK;		/* pop original mark */
	if (!startop) {
	    POPBLOCK(cx,PL_curpm);
	    POPEVAL(cx);
	    pop_return();
d2007 3
d2012 4
a2015 18
	if (optype == OP_REQUIRE) {
	    char* msg = SvPVx(ERRSV, n_a);
	    DIE("%s", *msg ? msg : "Compilation failed in require");
	} else if (startop) {
	    char* msg = SvPVx(ERRSV, n_a);

	    POPBLOCK(cx,PL_curpm);
	    POPEVAL(cx);
	    croak("%sCompilation failed in regexp", (*msg ? msg : "Unknown error\n"));
	}
	SvREFCNT_dec(PL_rs);
	PL_rs = SvREFCNT_inc(PL_nrs);
#ifdef USE_THREADS
	MUTEX_LOCK(&PL_eval_mutex);
	PL_eval_owner = 0;
	COND_SIGNAL(&PL_eval_cond);
	MUTEX_UNLOCK(&PL_eval_mutex);
#endif /* USE_THREADS */
d2018 6
a2023 13
    SvREFCNT_dec(PL_rs);
    PL_rs = SvREFCNT_inc(PL_nrs);
    PL_compiling.cop_line = 0;
    if (startop) {
	*startop = PL_eval_root;
	SvREFCNT_dec(CvOUTSIDE(PL_compcv));
	CvOUTSIDE(PL_compcv) = Nullcv;
    } else
	SAVEFREEOP(PL_eval_root);
    if (gimme & G_VOID)
	scalarvoid(PL_eval_root);
    else if (gimme & G_ARRAY)
	list(PL_eval_root);
d2025 1
a2025 1
	scalar(PL_eval_root);
a2028 12
    /* Register with debugger: */
    if (PERLDB_INTER && saveop->op_type == OP_REQUIRE) {
	CV *cv = perl_get_cv("DB::postponed", FALSE);
	if (cv) {
	    dSP;
	    PUSHMARK(SP);
	    XPUSHs((SV*)PL_compiling.cop_filegv);
	    PUTBACK;
	    perl_call_sv((SV*)cv, G_DISCARD);
	}
    }

d2031 1
a2031 11
    CvDEPTH(PL_compcv) = 1;
    SP = PL_stack_base + POPMARK;		/* pop original mark */
    PL_op = saveop;			/* The caller may need it. */
#ifdef USE_THREADS
    MUTEX_LOCK(&PL_eval_mutex);
    PL_eval_owner = 0;
    COND_SIGNAL(&PL_eval_cond);
    MUTEX_UNLOCK(&PL_eval_mutex);
#endif /* USE_THREADS */

    RETURNOP(PL_eval_start);
d2036 2
a2037 2
    djSP;
    register PERL_CONTEXT *cx;
d2040 1
a2040 3
    STRLEN len;
    char *tryname;
    SV *namesv = Nullsv;
d2043 1
a2043 2
    PerlIO *tryrsfp = 0;
    STRLEN n_a;
d2047 1
a2047 2
	SET_NUMERIC_STANDARD();
	if (atof(PL_patchlevel) + 0.00000999 < SvNV(sv))
d2049 1
a2049 1
		SvPV(sv,n_a),PL_patchlevel);
d2052 2
a2053 2
    name = SvPV(sv, len);
    if (!(name && len > 0 && *name))
d2056 3
a2058 3
    if (PL_op->op_type == OP_REQUIRE &&
      (svp = hv_fetch(GvHVn(PL_incgv), name, len, 0)) &&
      *svp != &PL_sv_undef)
d2063 5
a2067 4
    if (*name == '/' ||
	(*name == '.' && 
	    (name[1] == '/' ||
	     (name[1] == '.' && name[2] == '/')))
d2069 1
a2069 4
      || (name[0] && name[1] == ':')
#endif
#ifdef WIN32
      || (name[0] == '\\' && name[1] == '\\')	/* UNC path */
d2072 2
a2073 2
	|| (strchr(name,':')  || ((*name == '[' || *name == '<') &&
	    (isALNUM(name[1]) || strchr("$-_]>",name[1]))))
d2077 1
a2077 2
	tryname = name;
	tryrsfp = PerlIO_open(name,PERL_SCRIPT_MODE);
d2080 1
a2080 1
	AV *ar = GvAVn(PL_incgv);
d2082 2
d2085 3
a2087 13
	char *unixname;
	if ((unixname = tounixspec(name, Nullch)) != Nullch)
#endif
	{
	    namesv = NEWSV(806, 0);
	    for (i = 0; i <= AvFILL(ar); i++) {
		char *dir = SvPVx(*av_fetch(ar, i, TRUE), n_a);
#ifdef VMS
		char *unixdir;
		if ((unixdir = tounixpath(dir, Nullch)) == Nullch)
		    continue;
		sv_setpv(namesv, unixdir);
		sv_catpv(namesv, unixname);
d2089 2
a2090 1
		sv_setpvf(namesv, "%s/%s", dir, name);
d2092 9
a2100 8
		TAINT_PROPER("require");
		tryname = SvPVX(namesv);
		tryrsfp = PerlIO_open(tryname, PERL_SCRIPT_MODE);
		if (tryrsfp) {
		    if (tryname[0] == '.' && tryname[1] == '/')
			tryname += 2;
		    break;
		}
d2104 4
a2107 3
    SAVESPTR(PL_compiling.cop_filegv);
    PL_compiling.cop_filegv = gv_fetchfile(tryrsfp ? tryname : name);
    SvREFCNT_dec(namesv);
d2109 7
a2115 18
	if (PL_op->op_type == OP_REQUIRE) {
	    SV *msg = sv_2mortal(newSVpvf("Can't locate %s in @@INC", name));
	    SV *dirmsgsv = NEWSV(0, 0);
	    AV *ar = GvAVn(PL_incgv);
	    I32 i;
	    if (instr(SvPVX(msg), ".h "))
		sv_catpv(msg, " (change .h to .ph maybe?)");
	    if (instr(SvPVX(msg), ".ph "))
		sv_catpv(msg, " (did you run h2ph?)");
	    sv_catpv(msg, " (@@INC contains:");
	    for (i = 0; i <= AvFILL(ar); i++) {
		char *dir = SvPVx(*av_fetch(ar, i, TRUE), n_a);
		sv_setpvf(dirmsgsv, " %s", dir);
	        sv_catsv(msg, dirmsgsv);
	    }
	    sv_catpvn(msg, ")", 1);
    	    SvREFCNT_dec(dirmsgsv);
	    DIE("%_", msg);
a2119 2
    else
	SETERRNO(0, SS$_NORMAL);
d2122 2
a2123 2
    (void)hv_store(GvHVn(PL_incgv), name, strlen(name),
	newSVsv(GvSV(PL_compiling.cop_filegv)), 0 );
d2128 4
a2131 2
    SAVEGENERICSV(PL_rsfp_filters);
    PL_rsfp_filters = Nullav;
d2133 1
a2133 1
    PL_rsfp = tryrsfp;
d2136 2
a2137 2
    SAVEHINTS();
    PL_hints = 0;
d2141 1
a2141 1
    push_return(PL_op->op_next);
d2143 1
a2143 1
    PUSHEVAL(cx, name, PL_compiling.cop_filegv);
d2145 1
a2145 2
    SAVEI16(PL_compiling.cop_line);
    PL_compiling.cop_line = 0;
d2148 1
a2148 9
#ifdef USE_THREADS
    MUTEX_LOCK(&PL_eval_mutex);
    if (PL_eval_owner && PL_eval_owner != thr)
	while (PL_eval_owner)
	    COND_WAIT(&PL_eval_cond, &PL_eval_mutex);
    PL_eval_owner = thr;
    MUTEX_UNLOCK(&PL_eval_mutex);
#endif /* USE_THREADS */
    return DOCATCH(doeval(G_SCALAR, NULL));
d2158 2
a2159 2
    djSP;
    register PERL_CONTEXT *cx;
d2161 2
a2162 3
    I32 gimme = GIMME_V, was = PL_sub_generation;
    char tmpbuf[TYPE_DIGITS(long) + 12];
    char *safestr;
a2163 1
    OP *ret;
d2175 11
a2185 17
    SAVESPTR(PL_compiling.cop_filegv);
    sprintf(tmpbuf, "_<(eval %lu)", (unsigned long)++PL_evalseq);
    PL_compiling.cop_filegv = gv_fetchfile(tmpbuf+2);
    PL_compiling.cop_line = 1;
    /* XXX For C<eval "...">s within BEGIN {} blocks, this ends up
       deleting the eval's FILEGV from the stash before gv_check() runs
       (i.e. before run-time proper). To work around the coredump that
       ensues, we always turn GvMULTI_on for any globals that were
       introduced within evals. See force_ident(). GSAR 96-10-12 */
    safestr = savepv(tmpbuf);
    SAVEDELETE(PL_defstash, safestr, strlen(safestr));
    SAVEHINTS();
    PL_hints = PL_op->op_targ;

    push_return(PL_op->op_next);
    PUSHBLOCK(cx, (CXt_EVAL|CXp_REAL), SP);
    PUSHEVAL(cx, 0, PL_compiling.cop_filegv);
d2189 2
a2190 2
    if (PERLDB_LINE && PL_curstash != PL_debstash)
	save_lines(GvAV(PL_compiling.cop_filegv), PL_linestr);
d2192 1
a2192 14
#ifdef USE_THREADS
    MUTEX_LOCK(&PL_eval_mutex);
    if (PL_eval_owner && PL_eval_owner != thr)
	while (PL_eval_owner)
	    COND_WAIT(&PL_eval_cond, &PL_eval_mutex);
    PL_eval_owner = thr;
    MUTEX_UNLOCK(&PL_eval_mutex);
#endif /* USE_THREADS */
    ret = doeval(gimme, NULL);
    if (PERLDB_INTER && was != PL_sub_generation /* Some subs defined here. */
	&& ret != PL_op->op_next) {	/* Successive compilation. */
	strcpy(safestr, "_<(eval )");	/* Anything fake and short. */
    }
    return DOCATCH(ret);
d2197 1
a2197 1
    djSP;
d2202 1
a2202 1
    register PERL_CONTEXT *cx;
a2203 1
    U8 save_flags = PL_op -> op_flags;
d2210 3
a2212 11
    TAINT_NOT;
    if (gimme == G_VOID)
	MARK = newsp;
    else if (gimme == G_SCALAR) {
	MARK = newsp + 1;
	if (MARK <= SP) {
	    if (SvFLAGS(TOPs) & SVs_TEMP)
		*MARK = TOPs;
	    else
		*MARK = sv_mortalcopy(TOPs);
	}
d2214 11
a2224 2
	    MEXTEND(mark,0);
	    *MARK = &PL_sv_undef;
d2226 1
d2229 2
a2230 3
	/* in case LEAVE wipes old return values */
	for (mark = newsp + 1; mark <= SP; mark++) {
	    if (!(SvFLAGS(*mark) & SVs_TEMP)) {
d2232 1
a2232 3
		TAINT_NOT;	/* Each item is independent */
	    }
	}
d2234 1
a2234 1
    PL_curpm = newpm;	/* Don't pop $1 et al till now */
d2236 9
a2244 27
    /*
     * Closures mentioned at top level of eval cannot be referenced
     * again, and their presence indirectly causes a memory leak.
     * (Note that the fact that compcv and friends are still set here
     * is, AFAIK, an accident.)  --Chip
     */
    if (AvFILLp(PL_comppad_name) >= 0) {
	SV **svp = AvARRAY(PL_comppad_name);
	I32 ix;
	for (ix = AvFILLp(PL_comppad_name); ix >= 0; ix--) {
	    SV *sv = svp[ix];
	    if (sv && sv != &PL_sv_undef && *SvPVX(sv) == '&') {
		SvREFCNT_dec(sv);
		svp[ix] = &PL_sv_undef;

		sv = PL_curpad[ix];
		if (CvCLONE(sv)) {
		    SvREFCNT_dec(CvOUTSIDE(sv));
		    CvOUTSIDE(sv) = Nullcv;
		}
		else {
		    SvREFCNT_dec(sv);
		    sv = NEWSV(0,0);
		    SvPADTMP_on(sv);
		    PL_curpad[ix] = sv;
		}
	    }
a2247 4
#ifdef DEBUGGING
    assert(CvDEPTH(PL_compcv) == 1);
#endif
    CvDEPTH(PL_compcv) = 0;
d2249 2
a2250 15

    if (optype == OP_REQUIRE &&
	!(gimme == G_SCALAR ? SvTRUE(*SP) : SP > newsp))
    {
	/* Unassume the success we assumed earlier. */
	char *name = cx->blk_eval.old_name;
	(void)hv_delete(GvHVn(PL_incgv), name, strlen(name), G_DISCARD);
	retop = die("%s did not return a true value", name);
	/* die_where() did LEAVE, or we won't be here */
    }
    else {
	LEAVE;
	if (!(save_flags & OPf_SPECIAL))
	    sv_setpv(ERRSV,"");
    }
d2257 3
a2259 3
    djSP;
    register PERL_CONTEXT *cx;
    I32 gimme = GIMME_V;
d2267 1
a2267 1
    PL_eval_root = PL_op;		/* Only needed so that goto works right. */
d2269 3
a2271 4
    PL_in_eval = 1;
    sv_setpv(ERRSV,"");
    PUTBACK;
    return DOCATCH(PL_op->op_next);
d2276 1
a2276 1
    djSP;
d2281 1
a2281 1
    register PERL_CONTEXT *cx;
d2288 3
a2290 11
    TAINT_NOT;
    if (gimme == G_VOID)
	SP = newsp;
    else if (gimme == G_SCALAR) {
	MARK = newsp + 1;
	if (MARK <= SP) {
	    if (SvFLAGS(TOPs) & (SVs_PADTMP|SVs_TEMP))
		*MARK = TOPs;
	    else
		*MARK = sv_mortalcopy(TOPs);
	}
d2292 11
a2302 2
	    MEXTEND(mark,0);
	    *MARK = &PL_sv_undef;
d2307 2
a2308 3
	/* in case LEAVE wipes old return values */
	for (mark = newsp + 1; mark <= SP; mark++) {
	    if (!(SvFLAGS(*mark) & (SVs_PADTMP|SVs_TEMP))) {
d2310 1
a2310 3
		TAINT_NOT;	/* Each item is independent */
	    }
	}
d2312 1
a2312 1
    PL_curpm = newpm;	/* Don't pop $1 et al till now */
d2315 1
a2315 1
    sv_setpv(ERRSV,"");
d2319 3
a2321 2
STATIC void
doparseform(SV *sv)
d2337 1
a2337 4
    if (len == 0)
	croak("Null picture in formline");
    
    New(804, fops, (send - s)*3+10, U16);    /* Almost certainly too long... */
d2370 1
a2370 1
		if (postspace)
d2372 2
a2376 1
	    postspace = FALSE;
a2491 1
    sv_magic(sv, Nullsv, 'f', Nullch, 0);
a2492 691
}

/*
 * The rest of this file was derived from source code contributed
 * by Tom Horsley.
 *
 * NOTE: this code was derived from Tom Horsley's qsort replacement
 * and should not be confused with the original code.
 */

/* Copyright (C) Tom Horsley, 1997. All rights reserved.

   Permission granted to distribute under the same terms as perl which are
   (briefly):

    This program is free software; you can redistribute it and/or modify
    it under the terms of either:

	a) the GNU General Public License as published by the Free
	Software Foundation; either version 1, or (at your option) any
	later version, or

	b) the "Artistic License" which comes with this Kit.

   Details on the perl license can be found in the perl source code which
   may be located via the www.perl.com web page.

   This is the most wonderfulest possible qsort I can come up with (and
   still be mostly portable) My (limited) tests indicate it consistently
   does about 20% fewer calls to compare than does the qsort in the Visual
   C++ library, other vendors may vary.

   Some of the ideas in here can be found in "Algorithms" by Sedgewick,
   others I invented myself (or more likely re-invented since they seemed
   pretty obvious once I watched the algorithm operate for a while).

   Most of this code was written while watching the Marlins sweep the Giants
   in the 1997 National League Playoffs - no Braves fans allowed to use this
   code (just kidding :-).

   I realize that if I wanted to be true to the perl tradition, the only
   comment in this file would be something like:

   ...they shuffled back towards the rear of the line. 'No, not at the
   rear!'  the slave-driver shouted. 'Three files up. And stay there...

   However, I really needed to violate that tradition just so I could keep
   track of what happens myself, not to mention some poor fool trying to
   understand this years from now :-).
*/

/* ********************************************************** Configuration */

#ifndef QSORT_ORDER_GUESS
#define QSORT_ORDER_GUESS 2	/* Select doubling version of the netBSD trick */
#endif

/* QSORT_MAX_STACK is the largest number of partitions that can be stacked up for
   future processing - a good max upper bound is log base 2 of memory size
   (32 on 32 bit machines, 64 on 64 bit machines, etc). In reality can
   safely be smaller than that since the program is taking up some space and
   most operating systems only let you grab some subset of contiguous
   memory (not to mention that you are normally sorting data larger than
   1 byte element size :-).
*/
#ifndef QSORT_MAX_STACK
#define QSORT_MAX_STACK 32
#endif

/* QSORT_BREAK_EVEN is the size of the largest partition we should insertion sort.
   Anything bigger and we use qsort. If you make this too small, the qsort
   will probably break (or become less efficient), because it doesn't expect
   the middle element of a partition to be the same as the right or left -
   you have been warned).
*/
#ifndef QSORT_BREAK_EVEN
#define QSORT_BREAK_EVEN 6
#endif

/* ************************************************************* Data Types */

/* hold left and right index values of a partition waiting to be sorted (the
   partition includes both left and right - right is NOT one past the end or
   anything like that).
*/
struct partition_stack_entry {
   int left;
   int right;
#ifdef QSORT_ORDER_GUESS
   int qsort_break_even;
#endif
};

/* ******************************************************* Shorthand Macros */

/* Note that these macros will be used from inside the qsort function where
   we happen to know that the variable 'elt_size' contains the size of an
   array element and the variable 'temp' points to enough space to hold a
   temp element and the variable 'array' points to the array being sorted
   and 'compare' is the pointer to the compare routine.

   Also note that there are very many highly architecture specific ways
   these might be sped up, but this is simply the most generally portable
   code I could think of.
*/

/* Return < 0 == 0 or > 0 as the value of elt1 is < elt2, == elt2, > elt2
*/
#ifdef PERL_OBJECT
#define qsort_cmp(elt1, elt2) \
   ((this->*compare)(array[elt1], array[elt2]))
#else
#define qsort_cmp(elt1, elt2) \
   ((*compare)(array[elt1], array[elt2]))
#endif

#ifdef QSORT_ORDER_GUESS
#define QSORT_NOTICE_SWAP swapped++;
#else
#define QSORT_NOTICE_SWAP
#endif

/* swaps contents of array elements elt1, elt2.
*/
#define qsort_swap(elt1, elt2) \
   STMT_START { \
      QSORT_NOTICE_SWAP \
      temp = array[elt1]; \
      array[elt1] = array[elt2]; \
      array[elt2] = temp; \
   } STMT_END

/* rotate contents of elt1, elt2, elt3 such that elt1 gets elt2, elt2 gets
   elt3 and elt3 gets elt1.
*/
#define qsort_rotate(elt1, elt2, elt3) \
   STMT_START { \
      QSORT_NOTICE_SWAP \
      temp = array[elt1]; \
      array[elt1] = array[elt2]; \
      array[elt2] = array[elt3]; \
      array[elt3] = temp; \
   } STMT_END

/* ************************************************************ Debug stuff */

#ifdef QSORT_DEBUG

static void
break_here()
{
   return; /* good place to set a breakpoint */
}

#define qsort_assert(t) (void)( (t) || (break_here(), 0) )

static void
doqsort_all_asserts(
   void * array,
   size_t num_elts,
   size_t elt_size,
   int (*compare)(const void * elt1, const void * elt2),
   int pc_left, int pc_right, int u_left, int u_right)
{
   int i;

   qsort_assert(pc_left <= pc_right);
   qsort_assert(u_right < pc_left);
   qsort_assert(pc_right < u_left);
   for (i = u_right + 1; i < pc_left; ++i) {
      qsort_assert(qsort_cmp(i, pc_left) < 0);
   }
   for (i = pc_left; i < pc_right; ++i) {
      qsort_assert(qsort_cmp(i, pc_right) == 0);
   }
   for (i = pc_right + 1; i < u_left; ++i) {
      qsort_assert(qsort_cmp(pc_right, i) < 0);
   }
}

#define qsort_all_asserts(PC_LEFT, PC_RIGHT, U_LEFT, U_RIGHT) \
   doqsort_all_asserts(array, num_elts, elt_size, compare, \
                 PC_LEFT, PC_RIGHT, U_LEFT, U_RIGHT)

#else

#define qsort_assert(t) ((void)0)

#define qsort_all_asserts(PC_LEFT, PC_RIGHT, U_LEFT, U_RIGHT) ((void)0)

#endif

/* ****************************************************************** qsort */

STATIC void
#ifdef PERL_OBJECT
qsortsv(SV ** array, size_t num_elts, SVCOMPARE compare)
#else
qsortsv(
   SV ** array,
   size_t num_elts,
   I32 (*compare)(SV *a, SV *b))
#endif
{
   register SV * temp;

   struct partition_stack_entry partition_stack[QSORT_MAX_STACK];
   int next_stack_entry = 0;

   int part_left;
   int part_right;
#ifdef QSORT_ORDER_GUESS
   int qsort_break_even;
   int swapped;
#endif

   /* Make sure we actually have work to do.
   */
   if (num_elts <= 1) {
      return;
   }

   /* Setup the initial partition definition and fall into the sorting loop
   */
   part_left = 0;
   part_right = (int)(num_elts - 1);
#ifdef QSORT_ORDER_GUESS
   qsort_break_even = QSORT_BREAK_EVEN;
#else
#define qsort_break_even QSORT_BREAK_EVEN
#endif
   for ( ; ; ) {
      if ((part_right - part_left) >= qsort_break_even) {
         /* OK, this is gonna get hairy, so lets try to document all the
            concepts and abbreviations and variables and what they keep
            track of:

            pc: pivot chunk - the set of array elements we accumulate in the
                middle of the partition, all equal in value to the original
                pivot element selected. The pc is defined by:

                pc_left - the leftmost array index of the pc
                pc_right - the rightmost array index of the pc

                we start with pc_left == pc_right and only one element
                in the pivot chunk (but it can grow during the scan).

            u:  uncompared elements - the set of elements in the partition
                we have not yet compared to the pivot value. There are two
                uncompared sets during the scan - one to the left of the pc
                and one to the right.

                u_right - the rightmost index of the left side's uncompared set
                u_left - the leftmost index of the right side's uncompared set

                The leftmost index of the left sides's uncompared set
                doesn't need its own variable because it is always defined
                by the leftmost edge of the whole partition (part_left). The
                same goes for the rightmost edge of the right partition
                (part_right).

                We know there are no uncompared elements on the left once we
                get u_right < part_left and no uncompared elements on the
                right once u_left > part_right. When both these conditions
                are met, we have completed the scan of the partition.

                Any elements which are between the pivot chunk and the
                uncompared elements should be less than the pivot value on
                the left side and greater than the pivot value on the right
                side (in fact, the goal of the whole algorithm is to arrange
                for that to be true and make the groups of less-than and
                greater-then elements into new partitions to sort again).

            As you marvel at the complexity of the code and wonder why it
            has to be so confusing. Consider some of the things this level
            of confusion brings:

            Once I do a compare, I squeeze every ounce of juice out of it. I
            never do compare calls I don't have to do, and I certainly never
            do redundant calls.

            I also never swap any elements unless I can prove there is a
            good reason. Many sort algorithms will swap a known value with
            an uncompared value just to get things in the right place (or
            avoid complexity :-), but that uncompared value, once it gets
            compared, may then have to be swapped again. A lot of the
            complexity of this code is due to the fact that it never swaps
            anything except compared values, and it only swaps them when the
            compare shows they are out of position.
         */
         int pc_left, pc_right;
         int u_right, u_left;

         int s;

         pc_left = ((part_left + part_right) / 2);
         pc_right = pc_left;
         u_right = pc_left - 1;
         u_left = pc_right + 1;

         /* Qsort works best when the pivot value is also the median value
            in the partition (unfortunately you can't find the median value
            without first sorting :-), so to give the algorithm a helping
            hand, we pick 3 elements and sort them and use the median value
            of that tiny set as the pivot value.

            Some versions of qsort like to use the left middle and right as
            the 3 elements to sort so they can insure the ends of the
            partition will contain values which will stop the scan in the
            compare loop, but when you have to call an arbitrarily complex
            routine to do a compare, its really better to just keep track of
            array index values to know when you hit the edge of the
            partition and avoid the extra compare. An even better reason to
            avoid using a compare call is the fact that you can drop off the
            edge of the array if someone foolishly provides you with an
            unstable compare function that doesn't always provide consistent
            results.

            So, since it is simpler for us to compare the three adjacent
            elements in the middle of the partition, those are the ones we
            pick here (conveniently pointed at by u_right, pc_left, and
            u_left). The values of the left, center, and right elements
            are refered to as l c and r in the following comments.
         */

#ifdef QSORT_ORDER_GUESS
         swapped = 0;
#endif
         s = qsort_cmp(u_right, pc_left);
         if (s < 0) {
            /* l < c */
            s = qsort_cmp(pc_left, u_left);
            /* if l < c, c < r - already in order - nothing to do */
            if (s == 0) {
               /* l < c, c == r - already in order, pc grows */
               ++pc_right;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            } else if (s > 0) {
               /* l < c, c > r - need to know more */
               s = qsort_cmp(u_right, u_left);
               if (s < 0) {
                  /* l < c, c > r, l < r - swap c & r to get ordered */
                  qsort_swap(pc_left, u_left);
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               } else if (s == 0) {
                  /* l < c, c > r, l == r - swap c&r, grow pc */
                  qsort_swap(pc_left, u_left);
                  --pc_left;
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               } else {
                  /* l < c, c > r, l > r - make lcr into rlc to get ordered */
                  qsort_rotate(pc_left, u_right, u_left);
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               }
            }
         } else if (s == 0) {
            /* l == c */
            s = qsort_cmp(pc_left, u_left);
            if (s < 0) {
               /* l == c, c < r - already in order, grow pc */
               --pc_left;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            } else if (s == 0) {
               /* l == c, c == r - already in order, grow pc both ways */
               --pc_left;
               ++pc_right;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            } else {
               /* l == c, c > r - swap l & r, grow pc */
               qsort_swap(u_right, u_left);
               ++pc_right;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            }
         } else {
            /* l > c */
            s = qsort_cmp(pc_left, u_left);
            if (s < 0) {
               /* l > c, c < r - need to know more */
               s = qsort_cmp(u_right, u_left);
               if (s < 0) {
                  /* l > c, c < r, l < r - swap l & c to get ordered */
                  qsort_swap(u_right, pc_left);
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               } else if (s == 0) {
                  /* l > c, c < r, l == r - swap l & c, grow pc */
                  qsort_swap(u_right, pc_left);
                  ++pc_right;
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               } else {
                  /* l > c, c < r, l > r - rotate lcr into crl to order */
                  qsort_rotate(u_right, pc_left, u_left);
                  qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
               }
            } else if (s == 0) {
               /* l > c, c == r - swap ends, grow pc */
               qsort_swap(u_right, u_left);
               --pc_left;
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            } else {
               /* l > c, c > r - swap ends to get in order */
               qsort_swap(u_right, u_left);
               qsort_all_asserts(pc_left, pc_right, u_left + 1, u_right - 1);
            }
         }
         /* We now know the 3 middle elements have been compared and
            arranged in the desired order, so we can shrink the uncompared
            sets on both sides
         */
         --u_right;
         ++u_left;
         qsort_all_asserts(pc_left, pc_right, u_left, u_right);

         /* The above massive nested if was the simple part :-). We now have
            the middle 3 elements ordered and we need to scan through the
            uncompared sets on either side, swapping elements that are on
            the wrong side or simply shuffling equal elements around to get
            all equal elements into the pivot chunk.
         */

         for ( ; ; ) {
            int still_work_on_left;
            int still_work_on_right;

            /* Scan the uncompared values on the left. If I find a value
               equal to the pivot value, move it over so it is adjacent to
               the pivot chunk and expand the pivot chunk. If I find a value
               less than the pivot value, then just leave it - its already
               on the correct side of the partition. If I find a greater
               value, then stop the scan.
            */
            while (still_work_on_left = (u_right >= part_left)) {
               s = qsort_cmp(u_right, pc_left);
               if (s < 0) {
                  --u_right;
               } else if (s == 0) {
                  --pc_left;
                  if (pc_left != u_right) {
                     qsort_swap(u_right, pc_left);
                  }
                  --u_right;
               } else {
                  break;
               }
               qsort_assert(u_right < pc_left);
               qsort_assert(pc_left <= pc_right);
               qsort_assert(qsort_cmp(u_right + 1, pc_left) <= 0);
               qsort_assert(qsort_cmp(pc_left, pc_right) == 0);
            }

            /* Do a mirror image scan of uncompared values on the right
            */
            while (still_work_on_right = (u_left <= part_right)) {
               s = qsort_cmp(pc_right, u_left);
               if (s < 0) {
                  ++u_left;
               } else if (s == 0) {
                  ++pc_right;
                  if (pc_right != u_left) {
                     qsort_swap(pc_right, u_left);
                  }
                  ++u_left;
               } else {
                  break;
               }
               qsort_assert(u_left > pc_right);
               qsort_assert(pc_left <= pc_right);
               qsort_assert(qsort_cmp(pc_right, u_left - 1) <= 0);
               qsort_assert(qsort_cmp(pc_left, pc_right) == 0);
            }

            if (still_work_on_left) {
               /* I know I have a value on the left side which needs to be
                  on the right side, but I need to know more to decide
                  exactly the best thing to do with it.
               */
               if (still_work_on_right) {
                  /* I know I have values on both side which are out of
                     position. This is a big win because I kill two birds
                     with one swap (so to speak). I can advance the
                     uncompared pointers on both sides after swapping both
                     of them into the right place.
                  */
                  qsort_swap(u_right, u_left);
                  --u_right;
                  ++u_left;
                  qsort_all_asserts(pc_left, pc_right, u_left, u_right);
               } else {
                  /* I have an out of position value on the left, but the
                     right is fully scanned, so I "slide" the pivot chunk
                     and any less-than values left one to make room for the
                     greater value over on the right. If the out of position
                     value is immediately adjacent to the pivot chunk (there
                     are no less-than values), I can do that with a swap,
                     otherwise, I have to rotate one of the less than values
                     into the former position of the out of position value
                     and the right end of the pivot chunk into the left end
                     (got all that?).
                  */
                  --pc_left;
                  if (pc_left == u_right) {
                     qsort_swap(u_right, pc_right);
                     qsort_all_asserts(pc_left, pc_right-1, u_left, u_right-1);
                  } else {
                     qsort_rotate(u_right, pc_left, pc_right);
                     qsort_all_asserts(pc_left, pc_right-1, u_left, u_right-1);
                  }
                  --pc_right;
                  --u_right;
               }
            } else if (still_work_on_right) {
               /* Mirror image of complex case above: I have an out of
                  position value on the right, but the left is fully
                  scanned, so I need to shuffle things around to make room
                  for the right value on the left.
               */
               ++pc_right;
               if (pc_right == u_left) {
                  qsort_swap(u_left, pc_left);
                  qsort_all_asserts(pc_left+1, pc_right, u_left+1, u_right);
               } else {
                  qsort_rotate(pc_right, pc_left, u_left);
                  qsort_all_asserts(pc_left+1, pc_right, u_left+1, u_right);
               }
               ++pc_left;
               ++u_left;
            } else {
               /* No more scanning required on either side of partition,
                  break out of loop and figure out next set of partitions
               */
               break;
            }
         }

         /* The elements in the pivot chunk are now in the right place. They
            will never move or be compared again. All I have to do is decide
            what to do with the stuff to the left and right of the pivot
            chunk.

            Notes on the QSORT_ORDER_GUESS ifdef code:

            1. If I just built these partitions without swapping any (or
               very many) elements, there is a chance that the elements are
               already ordered properly (being properly ordered will
               certainly result in no swapping, but the converse can't be
               proved :-).

            2. A (properly written) insertion sort will run faster on
               already ordered data than qsort will.

            3. Perhaps there is some way to make a good guess about
               switching to an insertion sort earlier than partition size 6
               (for instance - we could save the partition size on the stack
               and increase the size each time we find we didn't swap, thus
               switching to insertion sort earlier for partitions with a
               history of not swapping).

            4. Naturally, if I just switch right away, it will make
               artificial benchmarks with pure ascending (or descending)
               data look really good, but is that a good reason in general?
               Hard to say...
         */

#ifdef QSORT_ORDER_GUESS
         if (swapped < 3) {
#if QSORT_ORDER_GUESS == 1
            qsort_break_even = (part_right - part_left) + 1;
#endif
#if QSORT_ORDER_GUESS == 2
            qsort_break_even *= 2;
#endif
#if QSORT_ORDER_GUESS == 3
            int prev_break = qsort_break_even;
            qsort_break_even *= qsort_break_even;
            if (qsort_break_even < prev_break) {
               qsort_break_even = (part_right - part_left) + 1;
            }
#endif
         } else {
            qsort_break_even = QSORT_BREAK_EVEN;
         }
#endif

         if (part_left < pc_left) {
            /* There are elements on the left which need more processing.
               Check the right as well before deciding what to do.
            */
            if (pc_right < part_right) {
               /* We have two partitions to be sorted. Stack the biggest one
                  and process the smallest one on the next iteration. This
                  minimizes the stack height by insuring that any additional
                  stack entries must come from the smallest partition which
                  (because it is smallest) will have the fewest
                  opportunities to generate additional stack entries.
               */
               if ((part_right - pc_right) > (pc_left - part_left)) {
                  /* stack the right partition, process the left */
                  partition_stack[next_stack_entry].left = pc_right + 1;
                  partition_stack[next_stack_entry].right = part_right;
#ifdef QSORT_ORDER_GUESS
                  partition_stack[next_stack_entry].qsort_break_even = qsort_break_even;
#endif
                  part_right = pc_left - 1;
               } else {
                  /* stack the left partition, process the right */
                  partition_stack[next_stack_entry].left = part_left;
                  partition_stack[next_stack_entry].right = pc_left - 1;
#ifdef QSORT_ORDER_GUESS
                  partition_stack[next_stack_entry].qsort_break_even = qsort_break_even;
#endif
                  part_left = pc_right + 1;
               }
               qsort_assert(next_stack_entry < QSORT_MAX_STACK);
               ++next_stack_entry;
            } else {
               /* The elements on the left are the only remaining elements
                  that need sorting, arrange for them to be processed as the
                  next partition.
               */
               part_right = pc_left - 1;
            }
         } else if (pc_right < part_right) {
            /* There is only one chunk on the right to be sorted, make it
               the new partition and loop back around.
            */
            part_left = pc_right + 1;
         } else {
            /* This whole partition wound up in the pivot chunk, so
               we need to get a new partition off the stack.
            */
            if (next_stack_entry == 0) {
               /* the stack is empty - we are done */
               break;
            }
            --next_stack_entry;
            part_left = partition_stack[next_stack_entry].left;
            part_right = partition_stack[next_stack_entry].right;
#ifdef QSORT_ORDER_GUESS
            qsort_break_even = partition_stack[next_stack_entry].qsort_break_even;
#endif
         }
      } else {
         /* This partition is too small to fool with qsort complexity, just
            do an ordinary insertion sort to minimize overhead.
         */
         int i;
         /* Assume 1st element is in right place already, and start checking
            at 2nd element to see where it should be inserted.
         */
         for (i = part_left + 1; i <= part_right; ++i) {
            int j;
            /* Scan (backwards - just in case 'i' is already in right place)
               through the elements already sorted to see if the ith element
               belongs ahead of one of them.
            */
            for (j = i - 1; j >= part_left; --j) {
               if (qsort_cmp(i, j) >= 0) {
                  /* i belongs right after j
                  */
                  break;
               }
            }
            ++j;
            if (j != i) {
               /* Looks like we really need to move some things
               */
	       int k;
	       temp = array[i];
	       for (k = i - 1; k >= j; --k)
		  array[k + 1] = array[k];
               array[j] = temp;
            }
         }

         /* That partition is now sorted, grab the next one, or get out
            of the loop if there aren't any more.
         */

         if (next_stack_entry == 0) {
            /* the stack is empty - we are done */
            break;
         }
         --next_stack_entry;
         part_left = partition_stack[next_stack_entry].left;
         part_right = partition_stack[next_stack_entry].right;
#ifdef QSORT_ORDER_GUESS
         qsort_break_even = partition_stack[next_stack_entry].qsort_break_even;
#endif
      }
   }

   /* Believe it or not, the array is sorted at this point! */
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a19 1
#define PERL_IN_PP_CTL_C
a27 11
static I32 sortcv(pTHXo_ SV *a, SV *b);
static I32 sortcv_stacked(pTHXo_ SV *a, SV *b);
static I32 sortcv_xsub(pTHXo_ SV *a, SV *b);
static I32 sv_ncmp(pTHXo_ SV *a, SV *b);
static I32 sv_i_ncmp(pTHXo_ SV *a, SV *b);
static I32 amagic_ncmp(pTHXo_ SV *a, SV *b);
static I32 amagic_i_ncmp(pTHXo_ SV *a, SV *b);
static I32 amagic_cmp(pTHXo_ SV *a, SV *b);
static I32 amagic_cmp_locale(pTHXo_ SV *a, SV *b);
static I32 run_user_filter(pTHXo_ int idx, SV *buf_sv, int maxlen);

d29 1
a29 2
static I32 sv_cmp_static(pTHXo_ SV *a, SV *b);
static I32 sv_cmp_locale_static(pTHXo_ SV *a, SV *b);
d31 13
a43 2
#define sv_cmp_static Perl_sv_cmp
#define sv_cmp_locale_static Perl_sv_cmp_locale
d115 1
a115 3
	    if (DO_UTF8(tmpstr))
		pm->op_pmdynflags |= PMdf_UTF8;
	    pm->op_pmregexp = CALLREGCOMP(aTHX_ t, t + len, pm);
a134 1
    /* XXX runtime compiled output needs to move to the pad */
a136 2
#if !defined(USE_ITHREADS) && !defined(USE_THREADS)
	/* XXX can't change the optree at runtime either */
a137 1
#endif
d157 1
a157 1
	    DIE(aTHX_ "Substitution loop");
d164 3
a166 5
	if (cx->sb_once || !CALLREGEXEC(aTHX_ rx, s, cx->sb_strend, orig,
				     s == m, cx->sb_targ, NULL,
				     ((cx->sb_rflags & REXEC_COPY_STR)
				      ? (REXEC_IGNOREPOS|REXEC_NOT_FIRST)
				      : (REXEC_COPY_STR|REXEC_IGNOREPOS|REXEC_NOT_FIRST))))
d194 1
a194 1
    if (RX_MATCH_COPIED(rx) && rx->subbeg != orig) {
d197 1
a197 1
	cx->sb_orig = orig = rx->subbeg;
d201 1
a201 1
    cx->sb_m = m = rx->startp[0] + orig;
d203 1
a203 1
    cx->sb_s = rx->endp[0] + orig;
d210 1
a210 1
Perl_rxres_save(pTHX_ void **rsp, REGEXP *rx)
d224 2
a225 2
    *p++ = PTR2UV(RX_MATCH_COPIED(rx) ? rx->subbeg : Nullch);
    RX_MATCH_COPIED_off(rx);
d229 2
a230 2
    *p++ = PTR2UV(rx->subbeg);
    *p++ = (UV)rx->sublen;
d238 1
a238 1
Perl_rxres_restore(pTHX_ void **rsp, REGEXP *rx)
d243 2
a244 3
    if (RX_MATCH_COPIED(rx))
	Safefree(rx->subbeg);
    RX_MATCH_COPIED_set(rx, *p);
d249 2
a250 2
    rx->subbeg = INT2PTR(char*,*p++);
    rx->sublen = (I32)(*p++);
d252 2
a253 2
	rx->startp[i] = (I32)(*p++);
	rx->endp[i] = (I32)(*p++);
d258 1
a258 1
Perl_rxres_free(pTHX_ void **rsp)
d263 1
a263 1
	Safefree(INT2PTR(char*,*p));
d287 1
a287 1
    NV value;
a289 2
    STRLEN fudge = SvCUR(tmpForm) * (IN_BYTE ? 1 : 3) + 1;
    bool item_is_utf = FALSE;
d292 2
a293 7
	if (SvREADONLY(tmpForm)) {
	    SvREADONLY_off(tmpForm);
	    doparseform(tmpForm);
	    SvREADONLY_on(tmpForm);
	}
	else
	    doparseform(tmpForm);
d297 1
a297 1
    t = SvGROW(PL_formtarget, len + fudge + 1);  /* XXX SvCUR bad */
d329 1
a329 1
		PerlIO_printf(Perl_debug_log, "%-16s%ld\n", name, (long) arg);
d331 1
a331 1
		PerlIO_printf(Perl_debug_log, "%-16s\n", name);
d359 2
a360 2
		if (ckWARN(WARN_SYNTAX))
		    Perl_warner(aTHX_ WARN_SYNTAX, "Not enough format arguments");
a366 26
	    if (DO_UTF8(sv)) {
		itemsize = sv_len_utf8(sv);
		if (itemsize != len) {
		    I32 itembytes;
		    if (itemsize > fieldsize) {
			itemsize = fieldsize;
			itembytes = itemsize;
			sv_pos_u2b(sv, &itembytes, 0);
		    }
		    else
			itembytes = len;
		    send = chophere = s + itembytes;
		    while (s < send) {
			if (*s & ~31)
			    gotsome = TRUE;
			else if (*s == '\n')
			    break;
			s++;
		    }
		    item_is_utf = TRUE;
		    itemsize = s - item;
		    sv_pos_b2u(sv, &itemsize);
		    break;
		}
	    }
	    item_is_utf = FALSE;
a382 43
	    if (DO_UTF8(sv)) {
		itemsize = sv_len_utf8(sv);
		if (itemsize != len) {
		    I32 itembytes;
		    if (itemsize <= fieldsize) {
			send = chophere = s + itemsize;
			while (s < send) {
			    if (*s == '\r') {
				itemsize = s - item;
				break;
			    }
			    if (*s++ & ~31)
				gotsome = TRUE;
			}
		    }
		    else {
			itemsize = fieldsize;
			itembytes = itemsize;
			sv_pos_u2b(sv, &itembytes, 0);
			send = chophere = s + itembytes;
			while (s < send || (s == send && isSPACE(*s))) {
			    if (isSPACE(*s)) {
				if (chopspace)
				    chophere = s;
				if (*s == '\r')
				    break;
			    }
			    else {
				if (*s & ~31)
				    gotsome = TRUE;
				if (strchr(PL_chopset, *s))
				    chophere = s + 1;
			    }
			    s++;
			}
			itemsize = chophere - item;
			sv_pos_b2u(sv, &itemsize);
		    }
		    item_is_utf = TRUE;
		    break;
		}
	    }
	    item_is_utf = FALSE;
a437 20
	    if (item_is_utf) {
		while (arg--) {
		    if (*s & 0x80) {
			switch (UTF8SKIP(s)) {
			case 7: *t++ = *s++;
			case 6: *t++ = *s++;
			case 5: *t++ = *s++;
			case 4: *t++ = *s++;
			case 3: *t++ = *s++;
			case 2: *t++ = *s++;
			case 1: *t++ = *s++;
			}
		    }
		    else {
			if ( !((*t++ = *s++) & ~31) )
			    t[-1] = ' ';
		    }
		}
		break;
	    }
a460 1
	    item_is_utf = FALSE;		/* XXX is this correct? */
d474 1
a474 1
		SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
d492 5
a496 19
	    {
		RESTORE_NUMERIC_LOCAL();
#if defined(USE_LONG_DOUBLE)
		if (arg & 256) {
		    sprintf(t, "%#*.*" PERL_PRIfldbl,
			    (int) fieldsize, (int) arg & 255, value);
		} else {
		    sprintf(t, "%*.0" PERL_PRIfldbl, (int) fieldsize, value);
		}
#else
		if (arg & 256) {
		    sprintf(t, "%#*.*f",
			    (int) fieldsize, (int) arg & 255, value);
		} else {
		    sprintf(t, "%*.0f",
			    (int) fieldsize, value);
		}
#endif
		RESTORE_NUMERIC_STANDARD();
d518 1
a518 1
			    DIE(aTHX_ "Runaway format");
d574 1
a574 1
	    XPUSHs(sv_2mortal(newSViv(0)));
d578 2
a579 2
    pp_pushmark();				/* push dst */
    pp_pushmark();				/* push src */
d583 6
a588 2
    /* SAVE_DEFSV does *not* suffice here for USE_THREADS */
    SAVESPTR(DEFSV);
d590 1
a590 1
    SAVEVPTR(PL_curpm);
d598 1
a598 1
	pp_pushmark();			/* push top */
d604 1
a604 1
    DIE(aTHX_ "panic: mapstart");	/* uses grepstart */
d660 1
a660 1
	SAVEVPTR(PL_curpm);
d670 55
a736 2
    bool hasargs = FALSE;
    I32 is_xsub = 0;
d744 1
a744 1
    SAVEVPTR(PL_sortcop);
d751 1
a751 1
	    stash = CopSTASH(PL_curcop);
a754 7
	    if (cv && SvPOK(cv)) {
		STRLEN n_a;
		char *proto = SvPV((SV*)cv, n_a);
		if (proto && strEQ(proto, "$$")) {
		    hasargs = TRUE;
		}
	    }
d756 1
a756 4
		if (cv && CvXSUB(cv)) {
		    is_xsub = 1;
		}
		else if (gv) {
d759 3
a761 1
		    DIE(aTHX_ "Undefined sort subroutine \"%s\" called",
d764 10
a773 11
		else {
		    DIE(aTHX_ "Undefined subroutine in sort");
		}
	    }

	    if (is_xsub)
		PL_sortcop = (OP*)cv;
	    else {
		PL_sortcop = CvSTART(cv);
		SAVEVPTR(CvROOT(cv)->op_ppaddr);
		CvROOT(cv)->op_ppaddr = PL_ppaddr[OP_NULL];
d775 2
a776 3
		SAVEVPTR(PL_curpad);
		PL_curpad = AvARRAY((AV*)AvARRAY(CvPADLIST(cv))[1]);
            }
d781 1
a781 1
	stash = CopSTASH(PL_curcop);
d787 1
a787 1
	if ((*up = *++MARK)) {			/* Weed out nulls. */
a789 1
		STRLEN n_a;
d792 2
a793 1
	        else
d795 1
d823 1
d831 1
a831 13

	    if (hasargs && !is_xsub) {
		/* This is mostly copied from pp_entersub */
		AV *av = (AV*)PL_curpad[0];

#ifndef USE_THREADS
		cx->blk_sub.savearray = GvAV(PL_defgv);
		GvAV(PL_defgv) = (AV*)SvREFCNT_inc(av);
#endif /* USE_THREADS */
		cx->blk_sub.argarray = av;
	    }
	    qsortsv((myorigmark+1), max,
		    is_xsub ? sortcv_xsub : hasargs ? sortcv_stacked : sortcv);
a833 1
	    PL_stack_sp = newsp;
d842 7
a848 18
 		    (PL_op->op_private & OPpSORT_NUMERIC)
			? ( (PL_op->op_private & OPpSORT_INTEGER)
			    ? ( overloading ? amagic_i_ncmp : sv_i_ncmp)
			    : ( overloading ? amagic_ncmp : sv_ncmp))
			: ( (PL_op->op_private & OPpLOCALE)
			    ? ( overloading
				? amagic_cmp_locale
				: sv_cmp_locale_static)
			    : ( overloading ? amagic_cmp : sv_cmp_static)));
	    if (PL_op->op_private & OPpSORT_REVERSE) {
		SV **p = ORIGMARK+1;
		SV **q = ORIGMARK+max;
		while (p < q) {
		    SV *tmp = *p;
		    *p++ = *q;
		    *q-- = tmp;
		}
	    }
d861 2
a862 5
	return NORMAL;
    if (SvTRUEx(PAD_SV(PL_op->op_targ)))
	return cLOGOP->op_other;
    else
	return NORMAL;
d870 1
a870 1
	RETURNOP(((LOGOP*)cUNOP->op_first)->op_other);
d888 1
a888 1
		RETURNOP(((LOGOP*)cUNOP->op_first)->op_other);
a906 5
	if (SvGMAGICAL(left))
	    mg_get(left);
	if (SvGMAGICAL(right))
	    mg_get(right);

d908 1
a908 3
	    SvNIOKp(right) || !SvPOKp(right) ||
	    (looks_like_number(left) && *SvPVX(left) != '0' &&
	     looks_like_number(right) && *SvPVX(right) != '0'))
d911 1
a911 1
		DIE(aTHX_ "Range iterator outside integer range");
d928 2
a929 1
	    STRLEN len, n_a;
d962 1
a962 1
S_dopoptolabel(pTHX_ char *label)
d972 2
a973 3
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting substitution via %s", 
			PL_op_name[PL_op->op_type]);
d976 2
a977 8
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting subroutine via %s", 
			PL_op_name[PL_op->op_type]);
	    break;
	case CXt_FORMAT:
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting format via %s", 
			PL_op_name[PL_op->op_type]);
d980 2
a981 3
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting eval via %s", 
			PL_op_name[PL_op->op_type]);
d984 2
a985 3
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting pseudo-block via %s", 
			PL_op_name[PL_op->op_type]);
d990 1
a990 1
		DEBUG_l(Perl_deb(aTHX_ "(Skipping label #%ld %s)\n",
d994 1
a994 1
	    DEBUG_l( Perl_deb(aTHX_ "(Found label #%ld %s)\n", (long)i, label));
d1002 1
a1002 1
Perl_dowantarray(pTHX)
d1009 1
a1009 1
Perl_block_gimme(pTHX)
d1026 1
a1026 1
	Perl_croak(aTHX_ "panic: bad gimme: %d\n", cxstack[cxix].blk_gimme);
d1033 1
a1033 1
S_dopoptosub(pTHX_ I32 startingblock)
d1040 1
a1040 1
S_dopoptosub_at(pTHX_ PERL_CONTEXT *cxstk, I32 startingblock)
d1052 1
a1052 2
	case CXt_FORMAT:
	    DEBUG_l( Perl_deb(aTHX_ "(Found sub #%ld)\n", (long)i));
d1060 1
a1060 1
S_dopoptoeval(pTHX_ I32 startingblock)
d1071 1
a1071 1
	    DEBUG_l( Perl_deb(aTHX_ "(Found eval #%ld)\n", (long)i));
d1079 1
a1079 1
S_dopoptoloop(pTHX_ I32 startingblock)
d1088 2
a1089 3
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting substitution via %s", 
			PL_op_name[PL_op->op_type]);
d1092 2
a1093 8
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting subroutine via %s", 
			PL_op_name[PL_op->op_type]);
	    break;
	case CXt_FORMAT:
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting format via %s", 
			PL_op_name[PL_op->op_type]);
d1096 2
a1097 3
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting eval via %s", 
			PL_op_name[PL_op->op_type]);
d1100 2
a1101 3
	    if (ckWARN(WARN_EXITING))
		Perl_warner(aTHX_ WARN_EXITING, "Exiting pseudo-block via %s", 
			PL_op_name[PL_op->op_type]);
d1104 1
a1104 1
	    DEBUG_l( Perl_deb(aTHX_ "(Found loop #%ld)\n", (long)i));
d1112 1
a1112 1
Perl_dounwind(pTHX_ I32 cxix)
d1116 1
a1119 1
	SV *sv;
d1122 1
a1122 1
			      (long) cxstack_ix, PL_block_type[CxTYPE(cx)]));
d1129 1
a1129 2
	    POPSUB(cx,sv);
	    LEAVESUB(sv);
a1138 3
	case CXt_FORMAT:
	    POPFORMAT(cx);
	    break;
a1143 48
/*
 * Closures mentioned at top level of eval cannot be referenced
 * again, and their presence indirectly causes a memory leak.
 * (Note that the fact that compcv and friends are still set here
 * is, AFAIK, an accident.)  --Chip
 *
 * XXX need to get comppad et al from eval's cv rather than
 * relying on the incidental global values.
 */
STATIC void
S_free_closures(pTHX)
{
    dTHR;
    SV **svp = AvARRAY(PL_comppad_name);
    I32 ix;
    for (ix = AvFILLp(PL_comppad_name); ix >= 0; ix--) {
	SV *sv = svp[ix];
	if (sv && sv != &PL_sv_undef && *SvPVX(sv) == '&') {
	    SvREFCNT_dec(sv);
	    svp[ix] = &PL_sv_undef;

	    sv = PL_curpad[ix];
	    if (CvCLONE(sv)) {
		SvREFCNT_dec(CvOUTSIDE(sv));
		CvOUTSIDE(sv) = Nullcv;
	    }
	    else {
		SvREFCNT_dec(sv);
		sv = NEWSV(0,0);
		SvPADTMP_on(sv);
		PL_curpad[ix] = sv;
	    }
	}
    }
}

void
Perl_qerror(pTHX_ SV *err)
{
    if (PL_in_eval)
	sv_catsv(ERRSV, err);
    else if (PL_errors)
	sv_catsv(PL_errors, err);
    else
	Perl_warn(aTHX_ "%"SVf, err);
    ++PL_error_count;
}

d1145 1
a1145 1
Perl_die_where(pTHX_ char *message, STRLEN msglen)
d1147 1
d1156 16
a1171 19
	    if (PL_in_eval & EVAL_KEEPERR) {
		static char prefix[] = "\t(in cleanup) ";
		SV *err = ERRSV;
		char *e = Nullch;
		if (!SvPOK(err))
		    sv_setpv(err,"");
		else if (SvCUR(err) >= sizeof(prefix)+msglen-1) {
		    e = SvPV(err, n_a);
		    e += n_a - msglen;
		    if (*e != *message || strNE(e,message))
			e = Nullch;
		}
		if (!e) {
		    SvGROW(err, SvCUR(err)+sizeof(prefix)+msglen);
		    sv_catpvn(err, prefix, sizeof(prefix)-1);
		    sv_catpvn(err, message, msglen);
		    if (ckWARN(WARN_MISC)) {
			STRLEN start = SvCUR(err)-msglen-sizeof(prefix)+1;
			Perl_warner(aTHX_ WARN_MISC, SvPVX(err)+start);
d1173 1
d1177 1
a1177 1
		sv_setpvn(ERRSV, message, msglen);
d1180 1
a1180 1
	    message = SvPVx(ERRSV, msglen);
d1182 1
a1182 3
	while ((cxix = dopoptoeval(cxstack_ix)) < 0
	       && PL_curstackinfo->si_prev)
	{
d1195 1
a1195 2
		PerlIO_write(Perl_error_log, "panic: die ", 11);
		PerlIO_write(Perl_error_log, message, msglen);
d1208 1
a1208 2
		DIE(aTHX_ "%sCompilation failed in require",
		    *msg ? msg : "Unknown error\n");
d1213 4
a1216 15
    if (!message)
	message = SvPVx(ERRSV, msglen);
    {
#ifdef USE_SFIO
	/* SFIO can really mess with your errno */
	int e = errno;
#endif
	PerlIO *serr = Perl_error_log;

	PerlIO_write(serr, message, msglen);
	(void)PerlIO_flush(serr);
#ifdef USE_SFIO
	errno = e;
#endif
    }
d1258 1
a1258 1
    char *stashname;
d1264 1
a1264 1
    EXTEND(SP, 10);
d1286 1
a1286 1
    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
a1293 1
    stashname = CopSTASHPV(cx->blk_oldcop);
d1295 2
a1296 1
	if (!stashname)
d1300 1
a1300 1
	    sv_setpv(TARG, stashname);
d1306 2
a1307 1
    if (!stashname)
d1310 3
a1312 3
	PUSHs(sv_2mortal(newSVpv(stashname, 0)));
    PUSHs(sv_2mortal(newSVpv(CopFILE(cx->blk_oldcop), 0)));
    PUSHs(sv_2mortal(newSViv((I32)CopLINE(cx->blk_oldcop))));
d1315 1
a1315 2
    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
	/* So is ccstack[dbcxix]. */
d1322 1
a1322 1
	PUSHs(sv_2mortal(newSVpvn("(eval)",6)));
d1334 4
a1337 4
	}
	/* try blocks have old_namesv == 0 */
	else if (cx->blk_eval.old_namesv) {
	    PUSHs(sv_2mortal(newSVsv(cx->blk_eval.old_namesv)));
d1341 3
a1343 6
    else {
	PUSHs(&PL_sv_undef);
	PUSHs(&PL_sv_undef);
    }
    if (CxTYPE(cx) == CXt_SUB && cx->blk_sub.hasargs
	&& CopSTASH_eq(PL_curcop, PL_debstash))
d1361 22
a1382 15
    /* XXX only hints propagated via op_private are currently
     * visible (others are not easily accessible, since they
     * use the global PL_hints) */
    PUSHs(sv_2mortal(newSViv((I32)cx->blk_oldcop->op_private &
			     HINT_PRIVATE_MASK)));
    {
	SV * mask ;
	SV * old_warnings = cx->blk_oldcop->cop_warnings ;
	if  (old_warnings == pWARN_NONE || old_warnings == pWARN_STD)
            mask = newSVpvn(WARN_NONEstring, WARNsize) ;
        else if (old_warnings == pWARN_ALL)
            mask = newSVpvn(WARN_ALLstring, WARNsize) ;
        else
            mask = newSVsv(old_warnings);
        PUSHs(sv_2mortal(mask));
d1384 2
a1385 1
    RETURN;
d1398 1
a1398 1
    sv_reset(tmps, CopSTASH(PL_curcop));
d1427 1
a1427 1
	    DIE(aTHX_ "No DB::DB routine defined");
d1446 1
a1446 1
	SAVEVPTR(PL_curpad);
a1464 4
    U32 cxtype = CXt_LOOP;
#ifdef USE_ITHREADS
    void *iterdata;
#endif
a1480 4
#ifdef USE_ITHREADS
	iterdata = (void*)PL_op->op_targ;
	cxtype |= CXp_PADVAR;
#endif
d1483 1
a1483 2
	GV *gv = (GV*)POPs;
	svp = &GvSV(gv);			/* symbol table variable */
a1485 3
#ifdef USE_ITHREADS
	iterdata = (void*)gv;
#endif
d1490 1
a1490 4
    PUSHBLOCK(cx, cxtype, SP);
#ifdef USE_ITHREADS
    PUSHLOOP(cx, iterdata, MARK);
#else
a1491 1
#endif
d1497 1
a1497 5
		SvNIOKp(cx->blk_loop.iterary) || !SvPOKp(cx->blk_loop.iterary) ||
		(looks_like_number(sv) && *SvPVX(sv) != '0' &&
		 looks_like_number((SV*)cx->blk_loop.iterary) &&
		 *SvPVX(cx->blk_loop.iterary) != '0'))
	    {
d1500 1
a1500 1
		     DIE(aTHX_ "Range iterator outside integer range");
d1537 1
d1545 1
a1545 1
    newsp = PL_stack_base + cx->blk_loop.resetsp;
d1565 1
a1565 1
    POPLOOP(cx);	/* Stack values are safe: release loop vars ... */
d1579 1
a1580 1
    bool clear_errsv = FALSE;
a1584 1
    SV *sv;
d1587 1
a1587 3
	if (cxstack_ix == PL_sortcxix
	    || dopoptosub(cxstack_ix) <= PL_sortcxix)
	{
d1598 1
a1598 1
	DIE(aTHX_ "Can't return outside a subroutine");
d1605 1
a1608 2
	if (!(PL_in_eval & EVAL_KEEPERR))
	    clear_errsv = TRUE;
a1609 5
	if (CxTRYBLOCK(cx))
	    break;
	if (AvFILLp(PL_comppad_name) >= 0)
	    free_closures();
	lex_end();
d1614 3
a1616 3
	    SV *nsv = cx->blk_eval.old_namesv;
	    (void)hv_delete(GvHVn(PL_incgv), SvPVX(nsv), SvCUR(nsv), G_DISCARD);
	    DIE(aTHX_ "%s did not return a true value", SvPVX(nsv));
a1618 3
    case CXt_FORMAT:
	POPFORMAT(cx);
	break;
d1620 1
a1620 1
	DIE(aTHX_ "panic: return");
d1627 1
a1627 1
		if (cx->blk_sub.cv && CvDEPTH(cx->blk_sub.cv) > 1) {
d1632 1
a1632 3
		    }
		    else {
			sv = SvREFCNT_inc(*SP);	/* FREETMPS could clobber it */
d1634 1
a1634 2
			*++newsp = sv_mortalcopy(sv);
			SvREFCNT_dec(sv);
d1636 1
a1636 2
		}
		else
d1638 1
a1638 2
	    }
	    else
d1640 1
a1640 2
	}
	else
d1654 1
a1654 1
	POPSUB(cx,sv);	/* release CV and @@_ ... */
a1655 2
    else
	sv = Nullsv;
a1658 3
    LEAVESUB(sv);
    if (clear_errsv)
	sv_setpv(ERRSV,"");
d1667 2
d1675 1
a1675 2
    SV **mark;
    SV *sv = Nullsv;
d1680 1
a1680 1
	    DIE(aTHX_ "Can't \"last\" outside a loop block");
d1685 1
a1685 1
	    DIE(aTHX_ "Label not found for \"last %s\"", cPVOP->op_pv);
a1690 1
    mark = newsp;
d1693 1
d1695 1
a1695 2
	newsp = PL_stack_base + cx->blk_loop.resetsp;
	nextop = cx->blk_loop.last_op->op_next;
d1698 1
a1705 4
    case CXt_FORMAT:
	POPFORMAT(cx);
	nextop = pop_return();
	break;
d1707 1
a1707 1
	DIE(aTHX_ "panic: last");
d1731 1
a1731 1
	POPLOOP(cx);	/* release loop vars ... */
d1735 1
a1735 1
	POPSUB(cx,sv);	/* release CV and @@_ ... */
a1740 1
    LEAVESUB(sv);
d1753 1
a1753 1
	    DIE(aTHX_ "Can't \"next\" outside a loop block");
d1758 1
a1758 1
	    DIE(aTHX_ "Label not found for \"next %s\"", cPVOP->op_pv);
d1764 2
a1765 6

    /* clean scope, but only if there's no continue block */
    if (!(cx->blk_loop.last_op->op_private & OPpLOOP_CONTINUE)) {
	oldsave = PL_scopestack[PL_scopestack_ix - 1];
	LEAVE_SCOPE(oldsave);
    }
d1778 1
a1778 1
	    DIE(aTHX_ "Can't \"redo\" outside a loop block");
d1783 1
a1783 1
	    DIE(aTHX_ "Label not found for \"redo %s\"", cPVOP->op_pv);
d1795 1
a1795 1
S_dofindlabel(pTHX_ OP *o, char *label, OP **opstack, OP **oplimit)
d1802 1
a1802 1
	Perl_croak(aTHX_ too_deep);
d1810 1
a1810 1
	    Perl_croak(aTHX_ too_deep);
d1829 1
a1829 1
	    if ((o = dofindlabel(kid, label, ops, oplimit)))
d1839 1
a1839 1
    return pp_goto();
a1852 1
    static char must_have_label[] = "goto must have label";
d1867 1
d1884 1
a1884 1
		    DIE(aTHX_ "Goto undefined subroutine &%s",SvPVX(tmpstr));
d1886 1
a1886 1
		DIE(aTHX_ "Goto undefined subroutine");
d1892 1
a1892 1
		DIE(aTHX_ "Can't goto subroutine outside a subroutine");
d1897 1
a1897 1
		DIE(aTHX_ "Can't goto subroutine from an eval-string");
d1899 2
a1900 2
	    if (CxTYPE(cx) == CXt_SUB && cx->blk_sub.hasargs) {
		/* put @@_ back onto stack */
a1911 1
		/* abandon @@_ if it got reified */
d1913 2
a1914 5
		    (void)sv_2mortal((SV*)av);	/* delay until return */
		    av = newAV();
		    av_extend(av, items-1);
		    AvFLAGS(av) = AVf_REIFY;
		    PL_curpad[0] = (SV*)(cx->blk_sub.argarray = av);
d1916 1
d1920 1
a1940 1
#ifdef PERL_XSUB_OLDSTYLE
d1942 1
a1942 1
		    I32 (*fp3)(int,int,int);
d1947 1
a1947 1
		    fp3 = (I32(*)(int,int,int))CvXSUB(cv);
d1953 1
a1953 3
		else
#endif /* PERL_XSUB_OLDSTYLE */
		{
d1960 1
a1960 1
		    (void)(*CvXSUB(cv))(aTHXo_ cv);
d1983 1
a1983 1
		    if (CvDEPTH(cv) == 100 && ckWARN(WARN_RECURSION))
a1988 1
			I32 names_fill = AvFILLp((AV*)svp[0]);
d1991 1
a1991 1
			    if (names_fill >= ix && svp[ix] != &PL_sv_undef) {
a2009 3
			    else if (IS_PADGV(oldpad[ix]) || IS_PADCONST(oldpad[ix])) {
				av_store(newpad, ix, sv = SvREFCNT_inc(oldpad[ix]));
			    }
d2040 1
a2040 1
		SAVEVPTR(PL_curpad);
d2071 5
a2075 1
		    assert(!AvREAL(av));
d2091 1
a2091 1
			SvIVX(sv) = PTR2IV(cv); /* Already upgraded, saved */
d2097 1
a2097 1
			  && (gotocv = get_cv("DB::goto", FALSE)) ) {
d2099 1
a2099 1
			call_sv((SV*)gotocv, G_SCALAR | G_NODEBUG);
d2106 1
a2106 1
	else {
a2107 3
	    if (!(do_dump || *label))
		DIE(aTHX_ must_have_label);
	}
d2111 1
a2111 1
	    DIE(aTHX_ must_have_label);
a2145 1
	    case CXt_FORMAT:
d2147 1
a2147 1
		DIE(aTHX_ "Can't \"goto\" out of a pseudo block");
d2150 1
a2150 1
		    DIE(aTHX_ "panic: goto");
d2154 4
a2157 6
	    if (gotoprobe) {
		retop = dofindlabel(gotoprobe, label,
				    enterops, enterops + GOTO_DEPTH);
		if (retop)
		    break;
	    }
d2161 1
a2161 1
	    DIE(aTHX_ "Can't find label %s", label);
d2185 3
a2187 2
		    DIE(aTHX_ "Can't \"goto\" into the middle of a foreach loop");
		CALL_FPTR(PL_op->op_ppaddr)(aTHX);
d2218 2
a2219 2
#ifdef VMS
        if (anum == 1 && (PL_op->op_private & OPpEXIT_VMSISH))
a2222 1
    PL_exit_flags |= PERL_EXIT_EXPECTED;
d2232 1
a2232 1
    NV value = SvNVx(GvSV(cCOP->cop_gv));
d2236 1
a2236 1
	if (((NV)match) > value)
d2272 1
a2272 1
S_save_lines(pTHX_ AV *array, SV *sv)
a2294 15
#ifdef PERL_FLEXIBLE_EXCEPTIONS
STATIC void *
S_docatch_body(pTHX_ va_list args)
{
    return docatch_body();
}
#endif

STATIC void *
S_docatch_body(pTHX)
{
    CALLRUNOPS(aTHX);
    return NULL;
}

d2296 1
a2296 1
S_docatch(pTHX_ OP *o)
a2300 1
    volatile PERL_SI *cursi = PL_curstackinfo;
d2303 1
d2306 1
a2307 5
    PL_op = o;
#ifdef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
    CALLPROTECT(aTHX_ pcur_env, &ret, MEMBER_TO_FPTR(S_docatch_body));
#else
a2308 1
#endif
d2310 2
a2311 14
    case 0:
#ifndef PERL_FLEXIBLE_EXCEPTIONS
 redo_body:
	docatch_body();
#endif
	break;
    case 3:
	if (PL_restartop && cursi == PL_curstackinfo) {
	    PL_op = PL_restartop;
	    PL_restartop = 0;
	    goto redo_body;
	}
	/* FALL THROUGH */
    default:
d2316 9
d2332 1
a2332 1
Perl_sv_compile_2op(pTHX_ SV *sv, OP** startop, char *code, AV** avp)
d2343 2
a2344 3
    OP *rop;
    char tbuf[TYPE_DIGITS(long) + 12 + 10];
    char *tmpbuf = tbuf;
d2353 2
a2354 2
	SAVECOPSTASH(&PL_compiling);
	CopSTASH_set(&PL_compiling, PL_curstash);
d2356 5
a2360 13
    SAVECOPFILE(&PL_compiling);
    SAVECOPLINE(&PL_compiling);
    if (PERLDB_NAMEEVAL && CopLINE(PL_curcop)) {
	SV *sv = sv_newmortal();
	Perl_sv_setpvf(aTHX_ sv, "_<(%.10seval %lu)[%s:%"IVdf"]",
		       code, (unsigned long)++PL_evalseq,
		       CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
	tmpbuf = SvPVX(sv);
    }
    else
	sprintf(tmpbuf, "_<(%.10s_eval %lu)", code, (unsigned long)++PL_evalseq);
    CopFILE_set(&PL_compiling, tmpbuf+2);
    CopLINE_set(&PL_compiling, 1);
d2372 1
a2372 1
    SAVEVPTR(PL_op);
d2377 1
a2377 1
    PL_op->op_type = OP_ENTEREVAL;
d2380 1
a2380 1
    PUSHEVAL(cx, 0, Nullgv);
d2386 1
a2386 1
    (*startop)->op_ppaddr = PL_ppaddr[OP_NULL];
a2389 2
    if (PL_curcop == &PL_compiling)
	PL_compiling.op_private = PL_hints;
d2398 1
a2398 1
S_doeval(pTHX_ int gimme, OP** startop)
d2402 1
d2407 1
a2407 1
    PL_in_eval = EVAL_INEVAL;
d2414 1
a2414 1
    SAVEVPTR(PL_curpad);
d2426 1
a2426 1
	else if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
d2450 1
a2450 1
    av_store(PL_comppad_name, 0, newSVpvn("@@_", 2));
d2461 1
a2461 3
    if (!saveop ||
	(saveop->op_type != OP_REQUIRE && saveop->op_type != OP_DOFILE))
    {
a2462 1
    }
d2468 2
a2469 1
    if (CopSTASH_ne(PL_curcop, PL_curstash)) {
d2471 1
a2471 1
	PL_curstash = CopSTASH(PL_curcop);
d2484 1
a2484 1
    PL_rs = newSVpvn("\n", 1);
d2486 1
a2486 1
	PL_in_eval |= EVAL_KEEPERR;
d2495 1
a2495 1
	
d2511 2
a2512 4
	    DIE(aTHX_ "%sCompilation failed in require",
		*msg ? msg : "Unknown error\n");
	}
	else if (startop) {
d2517 1
a2517 2
	    Perl_croak(aTHX_ "%sCompilation failed in regexp",
		       (*msg ? msg : "Unknown error\n"));
d2531 1
a2531 1
    CopLINE_set(&PL_compiling, 0);
d2549 1
a2549 1
	CV *cv = get_cv("DB::postponed", FALSE);
d2553 1
a2553 1
	    XPUSHs((SV*)CopFILEGV(&PL_compiling));
d2555 1
a2555 1
	    call_sv((SV*)cv, G_DISCARD);
d2574 1
a2574 2
STATIC PerlIO *
S_doopen_pmc(pTHX_ const char *name, const char *mode)
d2576 10
a2585 41
    STRLEN namelen = strlen(name);
    PerlIO *fp;

    if (namelen > 3 && strEQ(name + namelen - 3, ".pm")) {
	SV *pmcsv = Perl_newSVpvf(aTHX_ "%s%c", name, 'c');
	char *pmc = SvPV_nolen(pmcsv);
	Stat_t pmstat;
	Stat_t pmcstat;
	if (PerlLIO_stat(pmc, &pmcstat) < 0) {
	    fp = PerlIO_open(name, mode);
	}
	else {
	    if (PerlLIO_stat(name, &pmstat) < 0 ||
	        pmstat.st_mtime < pmcstat.st_mtime)
	    {
		fp = PerlIO_open(pmc, mode);
	    }
	    else {
		fp = PerlIO_open(name, mode);
	    }
	}
	SvREFCNT_dec(pmcsv);
    }
    else {
	fp = PerlIO_open(name, mode);
    }
    return fp;
}

PP(pp_require)
{
    djSP;
    register PERL_CONTEXT *cx;
    SV *sv;
    char *name;
    STRLEN len;
    char *tryname;
    SV *namesv = Nullsv;
    SV** svp;
    I32 gimme = G_SCALAR;
    PerlIO *tryrsfp = 0;
a2586 4
    int filter_has_file = 0;
    GV *filter_child_proc = 0;
    SV *filter_state = 0;
    SV *filter_sub = 0;
d2589 5
a2593 61
    if (SvNIOKp(sv)) {
	UV rev, ver, sver;
	if (SvPOKp(sv)) {		/* require v5.6.1 */
	    I32 len;
	    U8 *s = (U8*)SvPVX(sv);
	    U8 *end = (U8*)SvPVX(sv) + SvCUR(sv);
	    if (s < end) {
		rev = utf8_to_uv(s, &len);
		s += len;
		if (s < end) {
		    ver = utf8_to_uv(s, &len);
		    s += len;
		    if (s < end)
			sver = utf8_to_uv(s, &len);
		    else
			sver = 0;
		}
		else
		    ver = 0;
	    }
	    else
		rev = 0;
	    if (PERL_REVISION < rev
		|| (PERL_REVISION == rev
		    && (PERL_VERSION < ver
			|| (PERL_VERSION == ver
			    && PERL_SUBVERSION < sver))))
	    {
		DIE(aTHX_ "Perl v%"UVuf".%"UVuf".%"UVuf" required--this is only "
		    "v%d.%d.%d, stopped", rev, ver, sver, PERL_REVISION,
		    PERL_VERSION, PERL_SUBVERSION);
	    }
	}
	else if (!SvPOKp(sv)) {			/* require 5.005_03 */
	    if ((NV)PERL_REVISION + ((NV)PERL_VERSION/(NV)1000)
		+ ((NV)PERL_SUBVERSION/(NV)1000000)
		+ 0.00000099 < SvNV(sv))
	    {
		NV nrev = SvNV(sv);
		UV rev = (UV)nrev;
		NV nver = (nrev - rev) * 1000;
		UV ver = (UV)(nver + 0.0009);
		NV nsver = (nver - ver) * 1000;
		UV sver = (UV)(nsver + 0.0009);

		/* help out with the "use 5.6" confusion */
		if (sver == 0 && (rev > 5 || (rev == 5 && ver >= 100))) {
		    DIE(aTHX_ "Perl v%"UVuf".%"UVuf".%"UVuf" required--"
			"this is only v%d.%d.%d, stopped"
			" (did you mean v%"UVuf".%"UVuf".0?)",
			rev, ver, sver, PERL_REVISION, PERL_VERSION,
			PERL_SUBVERSION, rev, ver/100);
		}
		else {
		    DIE(aTHX_ "Perl v%"UVuf".%"UVuf".%"UVuf" required--"
			"this is only v%d.%d.%d, stopped",
			rev, ver, sver, PERL_REVISION, PERL_VERSION,
			PERL_SUBVERSION);
		}
	    }
	}
d2598 1
a2598 1
	DIE(aTHX_ "Null filename used");
d2607 15
a2621 3
    if (PERL_FILE_IS_ABSOLUTE(name)
	|| (*name == '.' && (name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/'))))
d2624 1
a2624 1
	tryrsfp = doopen_pmc(name,PERL_SCRIPT_MODE);
d2636 1
a2636 108
		SV *dirsv = *av_fetch(ar, i, TRUE);

		if (SvROK(dirsv)) {
		    int count;
		    SV *loader = dirsv;

		    if (SvTYPE(SvRV(loader)) == SVt_PVAV) {
			loader = *av_fetch((AV *)SvRV(loader), 0, TRUE);
		    }

		    Perl_sv_setpvf(aTHX_ namesv, "/loader/0x%"UVxf"/%s",
				   PTR2UV(SvANY(loader)), name);
		    tryname = SvPVX(namesv);
		    tryrsfp = 0;

		    ENTER;
		    SAVETMPS;
		    EXTEND(SP, 2);

		    PUSHMARK(SP);
		    PUSHs(dirsv);
		    PUSHs(sv);
		    PUTBACK;
		    count = call_sv(loader, G_ARRAY);
		    SPAGAIN;

		    if (count > 0) {
			int i = 0;
			SV *arg;

			SP -= count - 1;
			arg = SP[i++];

			if (SvROK(arg) && SvTYPE(SvRV(arg)) == SVt_PVGV) {
			    arg = SvRV(arg);
			}

			if (SvTYPE(arg) == SVt_PVGV) {
			    IO *io = GvIO((GV *)arg);

			    ++filter_has_file;

			    if (io) {
				tryrsfp = IoIFP(io);
				if (IoTYPE(io) == '|') {
				    /* reading from a child process doesn't
				       nest -- when returning from reading
				       the inner module, the outer one is
				       unreadable (closed?)  I've tried to
				       save the gv to manage the lifespan of
				       the pipe, but this didn't help. XXX */
				    filter_child_proc = (GV *)arg;
				    (void)SvREFCNT_inc(filter_child_proc);
				}
				else {
				    if (IoOFP(io) && IoOFP(io) != IoIFP(io)) {
					PerlIO_close(IoOFP(io));
				    }
				    IoIFP(io) = Nullfp;
				    IoOFP(io) = Nullfp;
				}
			    }

			    if (i < count) {
				arg = SP[i++];
			    }
			}

			if (SvROK(arg) && SvTYPE(SvRV(arg)) == SVt_PVCV) {
			    filter_sub = arg;
			    (void)SvREFCNT_inc(filter_sub);

			    if (i < count) {
				filter_state = SP[i];
				(void)SvREFCNT_inc(filter_state);
			    }

			    if (tryrsfp == 0) {
				tryrsfp = PerlIO_open("/dev/null",
						      PERL_SCRIPT_MODE);
			    }
			}
		    }

		    PUTBACK;
		    FREETMPS;
		    LEAVE;

		    if (tryrsfp) {
			break;
		    }

		    filter_has_file = 0;
		    if (filter_child_proc) {
			SvREFCNT_dec(filter_child_proc);
			filter_child_proc = 0;
		    }
		    if (filter_state) {
			SvREFCNT_dec(filter_state);
			filter_state = 0;
		    }
		    if (filter_sub) {
			SvREFCNT_dec(filter_sub);
			filter_sub = 0;
		    }
		}
		else {
		    char *dir = SvPVx(dirsv, n_a);
d2638 5
a2642 5
		    char *unixdir;
		    if ((unixdir = tounixpath(dir, Nullch)) == Nullch)
			continue;
		    sv_setpv(namesv, unixdir);
		    sv_catpv(namesv, unixname);
d2644 1
a2644 1
		    Perl_sv_setpvf(aTHX_ namesv, "%s/%s", dir, name);
d2646 7
a2652 8
		    TAINT_PROPER("require");
		    tryname = SvPVX(namesv);
		    tryrsfp = doopen_pmc(tryname, PERL_SCRIPT_MODE);
		    if (tryrsfp) {
			if (tryname[0] == '.' && tryname[1] == '/')
			    tryname += 2;
			break;
		    }
d2657 2
a2658 2
    SAVECOPFILE(&PL_compiling);
    CopFILE_set(&PL_compiling, tryrsfp ? tryname : name);
d2662 17
a2678 22
	    char *msgstr = name;
	    if (namesv) {			/* did we lookup @@INC? */
		SV *msg = sv_2mortal(newSVpv(msgstr,0));
		SV *dirmsgsv = NEWSV(0, 0);
		AV *ar = GvAVn(PL_incgv);
		I32 i;
		sv_catpvn(msg, " in @@INC", 8);
		if (instr(SvPVX(msg), ".h "))
		    sv_catpv(msg, " (change .h to .ph maybe?)");
		if (instr(SvPVX(msg), ".ph "))
		    sv_catpv(msg, " (did you run h2ph?)");
		sv_catpv(msg, " (@@INC contains:");
		for (i = 0; i <= AvFILL(ar); i++) {
		    char *dir = SvPVx(*av_fetch(ar, i, TRUE), n_a);
		    Perl_sv_setpvf(aTHX_ dirmsgsv, " %s", dir);
		    sv_catsv(msg, dirmsgsv);
		}
		sv_catpvn(msg, ")", 1);
		SvREFCNT_dec(dirmsgsv);
		msgstr = SvPV_nolen(msg);
	    }
	    DIE(aTHX_ "Can't locate %s", msgstr);
d2688 1
a2688 1
		   newSVpv(CopFILE(&PL_compiling), 0), 0 );
d2692 1
a2692 1
    lex_start(sv_2mortal(newSVpvn("",0)));
d2697 2
d2701 2
a2702 15
    SAVESPTR(PL_compiling.cop_warnings);
    if (PL_dowarn & G_WARN_ALL_ON)
        PL_compiling.cop_warnings = pWARN_ALL ;
    else if (PL_dowarn & G_WARN_ALL_OFF)
        PL_compiling.cop_warnings = pWARN_NONE ;
    else 
        PL_compiling.cop_warnings = pWARN_STD ;

    if (filter_sub || filter_child_proc) {
	SV *datasv = filter_add(run_user_filter, Nullsv);
	IoLINES(datasv) = filter_has_file;
	IoFMT_GV(datasv) = (GV *)filter_child_proc;
	IoTOP_GV(datasv) = (GV *)filter_state;
	IoBOTTOM_GV(datasv) = (GV *)filter_sub;
    }
a2703 1
    /* switch to eval mode */
d2706 1
a2706 1
    PUSHEVAL(cx, name, Nullgv);
d2708 2
a2709 2
    SAVECOPLINE(&PL_compiling);
    CopLINE_set(&PL_compiling, 0);
d2725 1
a2725 1
    return pp_require();
d2734 1
a2734 2
    char tbuf[TYPE_DIGITS(long) + 12];
    char *tmpbuf = tbuf;
d2749 4
a2752 12
    SAVECOPFILE(&PL_compiling);
    if (PERLDB_NAMEEVAL && CopLINE(PL_curcop)) {
	SV *sv = sv_newmortal();
	Perl_sv_setpvf(aTHX_ sv, "_<(eval %lu)[%s:%"IVdf"]",
		       (unsigned long)++PL_evalseq,
		       CopFILE(PL_curcop), (IV)CopLINE(PL_curcop));
	tmpbuf = SvPVX(sv);
    }
    else
	sprintf(tmpbuf, "_<(eval %lu)", (unsigned long)++PL_evalseq);
    CopFILE_set(&PL_compiling, tmpbuf+2);
    CopLINE_set(&PL_compiling, 1);
a2761 5
    SAVESPTR(PL_compiling.cop_warnings);
    if (!specialWARN(PL_compiling.cop_warnings)) {
        PL_compiling.cop_warnings = newSVsv(PL_compiling.cop_warnings) ;
        SAVEFREESV(PL_compiling.cop_warnings) ;
    }
d2765 1
a2765 1
    PUSHEVAL(cx, 0, Nullgv);
d2770 1
a2770 1
	save_lines(CopFILEAV(&PL_compiling), PL_linestr);
a2818 1
	SP = MARK;
d2831 29
a2859 2
    if (AvFILLp(PL_comppad_name) >= 0)
	free_closures();
d2871 3
a2873 3
	SV *nsv = cx->blk_eval.old_namesv;
	(void)hv_delete(GvHVn(PL_incgv), SvPVX(nsv), SvCUR(nsv), G_DISCARD);
	retop = Perl_die(aTHX_ "%s did not return a true value", SvPVX(nsv));
d2895 1
a2895 1
    PUSHBLOCK(cx, (CXt_EVAL|CXp_TRYBLOCK), SP);
d2899 1
a2899 1
    PL_in_eval = EVAL_INEVAL;
d2953 1
a2953 1
S_doparseform(pTHX_ SV *sv)
d2970 1
a2970 1
	Perl_croak(aTHX_ "Null picture in formline");
d3236 4
d3241 2
a3242 1
   ((*compare)(aTHXo_ array[elt1], array[elt2]))
d3323 8
a3330 1
S_qsortsv(pTHX_ SV ** array, size_t num_elts, SVCOMPARE_t compare)
d3558 1
a3558 1
            while ((still_work_on_left = (u_right >= part_left))) {
d3579 1
a3579 1
            while ((still_work_on_right = (u_left <= part_right))) {
a3819 307


#ifdef PERL_OBJECT
#undef this
#define this pPerl
#include "XSUB.h"
#endif


static I32
sortcv(pTHXo_ SV *a, SV *b)
{
    dTHR;
    I32 oldsaveix = PL_savestack_ix;
    I32 oldscopeix = PL_scopestack_ix;
    I32 result;
    GvSV(PL_firstgv) = a;
    GvSV(PL_secondgv) = b;
    PL_stack_sp = PL_stack_base;
    PL_op = PL_sortcop;
    CALLRUNOPS(aTHX);
    if (PL_stack_sp != PL_stack_base + 1)
	Perl_croak(aTHX_ "Sort subroutine didn't return single value");
    if (!SvNIOKp(*PL_stack_sp))
	Perl_croak(aTHX_ "Sort subroutine didn't return a numeric value");
    result = SvIV(*PL_stack_sp);
    while (PL_scopestack_ix > oldscopeix) {
	LEAVE;
    }
    leave_scope(oldsaveix);
    return result;
}

static I32
sortcv_stacked(pTHXo_ SV *a, SV *b)
{
    dTHR;
    I32 oldsaveix = PL_savestack_ix;
    I32 oldscopeix = PL_scopestack_ix;
    I32 result;
    AV *av;

#ifdef USE_THREADS
    av = (AV*)PL_curpad[0];
#else
    av = GvAV(PL_defgv);
#endif

    if (AvMAX(av) < 1) {
	SV** ary = AvALLOC(av);
	if (AvARRAY(av) != ary) {
	    AvMAX(av) += AvARRAY(av) - AvALLOC(av);
	    SvPVX(av) = (char*)ary;
	}
	if (AvMAX(av) < 1) {
	    AvMAX(av) = 1;
	    Renew(ary,2,SV*);
	    SvPVX(av) = (char*)ary;
	}
    }
    AvFILLp(av) = 1;

    AvARRAY(av)[0] = a;
    AvARRAY(av)[1] = b;
    PL_stack_sp = PL_stack_base;
    PL_op = PL_sortcop;
    CALLRUNOPS(aTHX);
    if (PL_stack_sp != PL_stack_base + 1)
	Perl_croak(aTHX_ "Sort subroutine didn't return single value");
    if (!SvNIOKp(*PL_stack_sp))
	Perl_croak(aTHX_ "Sort subroutine didn't return a numeric value");
    result = SvIV(*PL_stack_sp);
    while (PL_scopestack_ix > oldscopeix) {
	LEAVE;
    }
    leave_scope(oldsaveix);
    return result;
}

static I32
sortcv_xsub(pTHXo_ SV *a, SV *b)
{
    dSP;
    I32 oldsaveix = PL_savestack_ix;
    I32 oldscopeix = PL_scopestack_ix;
    I32 result;
    CV *cv=(CV*)PL_sortcop;

    SP = PL_stack_base;
    PUSHMARK(SP);
    EXTEND(SP, 2);
    *++SP = a;
    *++SP = b;
    PUTBACK;
    (void)(*CvXSUB(cv))(aTHXo_ cv);
    if (PL_stack_sp != PL_stack_base + 1)
	Perl_croak(aTHX_ "Sort subroutine didn't return single value");
    if (!SvNIOKp(*PL_stack_sp))
	Perl_croak(aTHX_ "Sort subroutine didn't return a numeric value");
    result = SvIV(*PL_stack_sp);
    while (PL_scopestack_ix > oldscopeix) {
	LEAVE;
    }
    leave_scope(oldsaveix);
    return result;
}


static I32
sv_ncmp(pTHXo_ SV *a, SV *b)
{
    NV nv1 = SvNV(a);
    NV nv2 = SvNV(b);
    return nv1 < nv2 ? -1 : nv1 > nv2 ? 1 : 0;
}

static I32
sv_i_ncmp(pTHXo_ SV *a, SV *b)
{
    IV iv1 = SvIV(a);
    IV iv2 = SvIV(b);
    return iv1 < iv2 ? -1 : iv1 > iv2 ? 1 : 0;
}
#define tryCALL_AMAGICbin(left,right,meth,svp) STMT_START { \
	  *svp = Nullsv;				\
          if (PL_amagic_generation) { \
	    if (SvAMAGIC(left)||SvAMAGIC(right))\
		*svp = amagic_call(left, \
				   right, \
				   CAT2(meth,_amg), \
				   0); \
	  } \
	} STMT_END

static I32
amagic_ncmp(pTHXo_ register SV *a, register SV *b)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(a,b,ncmp,&tmpsv);
    if (tmpsv) {
    	NV d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
     }
     return sv_ncmp(aTHXo_ a, b);
}

static I32
amagic_i_ncmp(pTHXo_ register SV *a, register SV *b)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(a,b,ncmp,&tmpsv);
    if (tmpsv) {
    	NV d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_i_ncmp(aTHXo_ a, b);
}

static I32
amagic_cmp(pTHXo_ register SV *str1, register SV *str2)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(str1,str2,scmp,&tmpsv);
    if (tmpsv) {
    	NV d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_cmp(str1, str2);
}

static I32
amagic_cmp_locale(pTHXo_ register SV *str1, register SV *str2)
{
    SV *tmpsv;
    tryCALL_AMAGICbin(str1,str2,scmp,&tmpsv);
    if (tmpsv) {
    	NV d;
    	
        if (SvIOK(tmpsv)) {
            I32 i = SvIVX(tmpsv);
            if (i > 0)
               return 1;
            return i? -1 : 0;
        }
        d = SvNV(tmpsv);
        if (d > 0)
           return 1;
        return d? -1 : 0;
    }
    return sv_cmp_locale(str1, str2);
}

static I32
run_user_filter(pTHXo_ int idx, SV *buf_sv, int maxlen)
{
    SV *datasv = FILTER_DATA(idx);
    int filter_has_file = IoLINES(datasv);
    GV *filter_child_proc = (GV *)IoFMT_GV(datasv);
    SV *filter_state = (SV *)IoTOP_GV(datasv);
    SV *filter_sub = (SV *)IoBOTTOM_GV(datasv);
    int len = 0;

    /* I was having segfault trouble under Linux 2.2.5 after a
       parse error occured.  (Had to hack around it with a test
       for PL_error_count == 0.)  Solaris doesn't segfault --
       not sure where the trouble is yet.  XXX */

    if (filter_has_file) {
	len = FILTER_READ(idx+1, buf_sv, maxlen);
    }

    if (filter_sub && len >= 0) {
	djSP;
	int count;

	ENTER;
	SAVE_DEFSV;
	SAVETMPS;
	EXTEND(SP, 2);

	DEFSV = buf_sv;
	PUSHMARK(SP);
	PUSHs(sv_2mortal(newSViv(maxlen)));
	if (filter_state) {
	    PUSHs(filter_state);
	}
	PUTBACK;
	count = call_sv(filter_sub, G_SCALAR);
	SPAGAIN;

	if (count > 0) {
	    SV *out = POPs;
	    if (SvOK(out)) {
		len = SvIV(out);
	    }
	}

	PUTBACK;
	FREETMPS;
	LEAVE;
    }

    if (len <= 0) {
	IoLINES(datasv) = 0;
	if (filter_child_proc) {
	    SvREFCNT_dec(filter_child_proc);
	    IoFMT_GV(datasv) = Nullgv;
	}
	if (filter_state) {
	    SvREFCNT_dec(filter_state);
	    IoTOP_GV(datasv) = Nullgv;
	}
	if (filter_sub) {
	    SvREFCNT_dec(filter_sub);
	    IoBOTTOM_GV(datasv) = Nullgv;
	}
	filter_del(run_user_filter);
    }

    return len;
}

#ifdef PERL_OBJECT

static I32
sv_cmp_locale_static(pTHXo_ register SV *str1, register SV *str2)
{
    return sv_cmp_locale(str1, str2);
}

static I32
sv_cmp_static(pTHXo_ register SV *str1, register SV *str2)
{
    return sv_cmp(str1, str2);
}

#endif /* PERL_OBJECT */
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d50 1
a50 1
    dSP;
d83 1
a83 1
    dSP;
d152 1
a152 1
    dSP;
d179 1
a179 1
	    bool isutf8;
a180 1
	    sv_catpvn(dstr, s, cx->sb_strend - s);
a187 1
	    isutf8 = DO_UTF8(dstr);
a194 2
	    if (isutf8)
		SvUTF8_on(targ);
a213 15
    { /* Update the pos() information. */
	SV *sv = cx->sb_targ;
	MAGIC *mg;
	I32 i;
	if (SvTYPE(sv) < SVt_PVMG)
	    SvUPGRADE(sv, SVt_PVMG);
	if (!(mg = mg_find(sv, 'g'))) {
	    sv_magic(sv, Nullsv, 'g', Nullch, 0);
	    mg = mg_find(sv, 'g');
	}
	i = m - orig;
	if (DO_UTF8(sv))
	    sv_pos_b2u(sv, &i);
	mg->mg_len = i;
    }
d282 1
a282 1
    dSP; dMARK; dORIGMARK;
d527 1
a527 1
		    if (UTF8_IS_CONTINUED(*s)) {
d601 1
a601 1
		STORE_NUMERIC_STANDARD_SET_LOCAL();
d690 1
a690 1
    dSP;
d727 2
a728 2
    dSP;
    I32 items = (SP - PL_stack_base) - *PL_markstack_ptr; /* how many new items */
a733 1
    /* first, move source pointer to the next item in the source list */
d735 4
a738 28

    /* if there are new items, push them into the destination list */
    if (items) {
	/* might need to make room back there first */
	if (items > PL_markstack_ptr[-1] - PL_markstack_ptr[-2]) {
	    /* XXX this implementation is very pessimal because the stack
	     * is repeatedly extended for every set of items.  Is possible
	     * to do this without any stack extension or copying at all
	     * by maintaining a separate list over which the map iterates
	     * (like foreach does). --gsar */

	    /* everything in the stack after the destination list moves
	     * towards the end the stack by the amount of room needed */
	    shift = items - (PL_markstack_ptr[-1] - PL_markstack_ptr[-2]);

	    /* items to shift up (accounting for the moved source pointer) */
	    count = (SP - PL_stack_base) - (PL_markstack_ptr[-1] - 1);

	    /* This optimization is by Ben Tilly and it does
	     * things differently from what Sarathy (gsar)
	     * is describing.  The downside of this optimization is
	     * that leaves "holes" (uninitialized and hopefully unused areas)
	     * to the Perl stack, but on the other hand this
	     * shouldn't be a problem.  If Sarathy's idea gets
	     * implemented, this optimization should become
	     * irrelevant.  --jhi */
            if (shift < count)
                shift = count; /* Avoid shifting too often --Ben Tilly */
d745 1
a745 1
	    while (count--)
d748 3
a750 3
	/* copy the new items down to the destination list */
	dst = PL_stack_base + (PL_markstack_ptr[-2] += items) - 1; 
	while (items--)
d757 1
a779 1
	/* set $_ to the new source item */
d790 1
a790 1
    dSP; dMARK; dORIGMARK;
d886 4
a889 14
	    if (!hasargs && !is_xsub) {
		if (PL_sortstash != stash || !PL_firstgv || !PL_secondgv) {
		    SAVESPTR(PL_firstgv);
		    SAVESPTR(PL_secondgv);
		    PL_firstgv = gv_fetchpv("a", TRUE, SVt_PV);
		    PL_secondgv = gv_fetchpv("b", TRUE, SVt_PV);
		    PL_sortstash = stash;
		}
#ifdef USE_THREADS
		sv_lock((SV *)PL_firstgv);
		sv_lock((SV *)PL_secondgv);
#endif
		SAVESPTR(GvSV(PL_firstgv));
		SAVESPTR(GvSV(PL_secondgv));
d892 3
a912 1
		cx->blk_sub.oldcurpad = PL_curpad;
d967 1
a967 1
    dSP;
a974 1
 	int flip;
d976 3
a978 9
 	if (PL_op->op_private & OPpFLIP_LINENUM) {
 	    struct io *gp_io;
 	    flip = PL_last_in_gv
 		&& (gp_io = GvIOp(PL_last_in_gv))
 		&& SvIV(sv) == (IV)IoLINES(gp_io);
 	} else {
 	    flip = SvTRUE(sv);
 	}
 	if (flip) {
d999 1
a999 1
    dSP;
d1070 1
d1126 1
a1146 14
I32
Perl_is_lvalue_sub(pTHX)
{
    I32 cxix;

    cxix = dopoptosub(cxstack_ix);
    assert(cxix >= 0);  /* We should only be called from inside subs */

    if (cxstack[cxix].blk_sub.lval && CvLVALUE(cxstack[cxix].blk_sub.cv))
	return cxstack[cxix].blk_sub.lval;
    else
	return 0;
}

d1150 1
d1157 1
d1178 1
d1197 1
d1239 1
d1273 36
a1386 6
	    /* LEAVE could clobber PL_curcop (see save_re_context())
	     * XXX it might be better to find a way to avoid messing with
	     * PL_curcop in save_re_context() instead, but this is a more
	     * minimal fix --GSAR */
	    PL_curcop = cx->blk_oldcop;

d1417 1
a1417 1
    dSP; dPOPTOPssrl;
d1426 1
a1426 1
    dSP;
d1435 1
a1435 1
    dSP;
d1444 1
a1444 1
    dSP;
a1523 1
	/* eval STRING */
d1528 1
a1528 1
	/* require */
a1532 5
	/* eval BLOCK (try blocks have old_namesv == 0) */
	else {
	    PUSHs(&PL_sv_undef);
	    PUSHs(&PL_sv_undef);
	}
d1549 1
a1549 1
	    AvREAL_off(PL_dbargs);	/* XXX should be REIFY (see av.h) */
d1565 1
a1565 3

	if  (old_warnings == pWARN_NONE || 
		(old_warnings == pWARN_STD && (PL_dowarn & G_WARN_ON) == 0))
d1567 1
a1567 2
        else if (old_warnings == pWARN_ALL || 
		  (old_warnings == pWARN_STD && PL_dowarn & G_WARN_ON))
d1578 1
a1578 1
    dSP;
d1605 1
a1605 1
	dSP;
d1649 1
a1649 1
    dSP; dMARK;
d1663 1
a1670 1
#ifndef USE_ITHREADS
d1673 1
a1673 2
#else
	SAVEPADSV(PL_op->op_targ);
d1727 1
a1727 1
    dSP;
d1743 1
a1743 1
    dSP;
d1783 1
a1783 1
    dSP; dMARK;
d1823 2
d1894 1
a1894 1
    dSP;
d1982 1
a1982 1
    I32 inner;
a1996 3
    /* clear off anything above the scope we're re-entering, but
     * save the rest until after a possible continue block */
    inner = PL_scopestack_ix;
d1998 6
a2003 2
    if (PL_scopestack_ix < inner)
	leave_scope(PL_scopestack[PL_scopestack_ix]);
d2052 1
d2083 1
a2083 1
    dSP;
a2299 1
		    cx->blk_sub.oldcurpad = PL_curpad;
d2459 1
a2459 1
    dSP;
d2480 1
a2480 1
    dSP;
d2499 1
a2499 1
    dSP;
d2562 1
d2626 1
a2626 1
	SAVECOPSTASH_FREE(&PL_compiling);
d2629 2
a2639 1
    SAVECOPFILE_FREE(&PL_compiling);
a2640 1
    SAVECOPLINE(&PL_compiling);
d2660 1
a2660 1
    PUSHBLOCK(cx, CXt_EVAL|(PL_curcop == &PL_compiling ? 0 : CXp_REAL), SP);
d2689 1
a2689 3
    PL_in_eval = ((saveop && saveop->op_type == OP_REQUIRE)
		  ? (EVAL_INREQUIRE | (PL_in_eval & EVAL_INEVAL))
		  : EVAL_INEVAL);
d2749 1
a2749 1
    SAVEMORTALIZESV(PL_compcv);	/* must remain until end of current statement */
a2759 1
    SAVEI32(PL_error_count);
a2850 1
    PL_lex_state = LEX_NOTPARSING;	/* $^S needs this. */
d2895 1
a2895 1
    dSP;
d2913 3
a2915 3
	if (SvPOK(sv) && SvNOK(sv)) {		/* require v5.6.1 */
	    UV rev = 0, ver = 0, sver = 0;
	    STRLEN len;
d2919 1
a2919 1
		rev = utf8_to_uv(s, end - s, &len, 0);
d2922 1
a2922 1
		    ver = utf8_to_uv(s, end - s, &len, 0);
d2925 3
a2927 1
			sver = utf8_to_uv(s, end - s, &len, 0);
d2929 2
d2932 2
a2943 1
	    RETPUSHYES;
a2971 1
	    RETPUSHYES;
d2973 1
a2985 15
#ifdef MACOS_TRADITIONAL
    if (PERL_FILE_IS_ABSOLUTE(name)
	|| (*name == ':' && name[1] != ':' && strchr(name+2, ':')))
    {
	tryname = name;
	tryrsfp = doopen_pmc(name,PERL_SCRIPT_MODE);
	/* We consider paths of the form :a:b ambiguous and interpret them first
	   as global then as local
	*/
    	if (!tryrsfp && *name == ':' && name[1] != ':' && strchr(name+2, ':'))
	    goto trylocal;
    }
    else 
trylocal: {
#else
a2993 1
#endif
d3026 1
a3026 4
		    if (sv_isobject(loader))
			count = call_method("INC", G_ARRAY);
		    else
			count = call_sv(loader, G_ARRAY);
d3047 1
a3047 1
				if (IoTYPE(io) == IoTYPE_PIPE) {
a3110 4
#ifdef MACOS_TRADITIONAL
		    char buf[256];
		    Perl_sv_setpvf(aTHX_ namesv, "%s%s", MacPerl_CanonDir(dir, buf), name+(name[0] == ':'));
#else
a3119 1
#endif
a3121 8
#ifdef MACOS_TRADITIONAL
		    {
		    	/* Convert slashes in the name part, but not the directory part, to colons */
		    	char * colon;
		    	for (colon = tryname+strlen(dir); colon = strchr(colon, '/'); )
			    *colon++ = ':';
		    }
#endif
d3132 1
a3132 1
    SAVECOPFILE_FREE(&PL_compiling);
d3222 1
a3222 1
    dSP;
d3242 1
a3251 1
    SAVECOPFILE_FREE(&PL_compiling);
a3252 1
    SAVECOPLINE(&PL_compiling);
d3264 3
a3266 5
    if (specialWARN(PL_curcop->cop_warnings))
        PL_compiling.cop_warnings = PL_curcop->cop_warnings;
    else {
        PL_compiling.cop_warnings = newSVsv(PL_curcop->cop_warnings);
        SAVEFREESV(PL_compiling.cop_warnings);
d3296 1
a3296 1
    dSP;
d3338 3
d3367 1
a3367 1
    dSP;
d3387 1
a3387 1
    dSP;
d4300 1
d4324 1
d4530 1
a4530 1
	dSP;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d29 18
a46 1
static I32 run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen);
d89 1
a89 1
    
a90 7

    /* prevent recompiling under /o and ithreads. */
#if defined(USE_ITHREADS) || defined(USE_5005THREADS)
    if (pm->op_pmflags & PMf_KEEP && PM_GETRE(pm))
	 RETURN;
#endif

d94 1
a94 1
	    mg = mg_find(sv, PERL_MAGIC_qr);
d98 2
a99 2
	ReREFCNT_dec(PM_GETRE(pm));
	PM_SETRE(pm, ReREFCNT_inc(re));
d105 3
a107 3
	if (!PM_GETRE(pm) || !PM_GETRE(pm)->precomp ||
	    PM_GETRE(pm)->prelen != (I32)len ||
	    memNE(PM_GETRE(pm)->precomp, t, len))
d109 3
a111 3
	    if (PM_GETRE(pm)) {
		ReREFCNT_dec(PM_GETRE(pm));
		PM_SETRE(pm, Null(REGEXP*));	/* crucial if regcomp aborts */
d118 3
a120 10
		pm->op_pmdynflags |= PMdf_DYN_UTF8;
	    else {
		pm->op_pmdynflags &= ~PMdf_DYN_UTF8;
		if (pm->op_pmdynflags & PMdf_UTF8)
		    t = (char*)bytes_to_utf8((U8*)t, &len);
	    }
	    PM_SETRE(pm, CALLREGCOMP(aTHX_ t, t + len, pm));
	    if (!DO_UTF8(tmpstr) && (pm->op_pmdynflags & PMdf_UTF8))
		Safefree(t);
	    PL_reginterp_cnt = 0;	/* XXXX Be extra paranoid - needed
d134 1
a134 1
    if (!PM_GETRE(pm)->prelen && PL_curpm)
d136 1
a136 1
    else if (strEQ("\\s+", PM_GETRE(pm)->precomp))
a137 2
    else
	pm->op_pmflags &= ~PMf_WHITE;
d142 1
a142 1
#if !defined(USE_ITHREADS) && !defined(USE_5005THREADS)
a161 1
    PL_reg_match_utf8 = SvUTF8(cx->sb_targ) ? 1 : 0;
a163 1
	I32 saviters = cx->sb_iters;
d179 1
d189 1
a189 2
	    if (DO_UTF8(dstr))
		SvUTF8_on(targ);
d196 3
a198 1
	    (void)SvPOK_only_UTF8(targ);
a206 1
	cx->sb_iters = saviters;
d216 1
a216 2
    if (m > s)
	sv_catpvn(dstr, s, m-s);
d223 4
a226 4
	    (void)SvUPGRADE(sv, SVt_PVMG);
	if (!(mg = mg_find(sv, PERL_MAGIC_regex_global))) {
	    sv_magic(sv, Nullsv, PERL_MAGIC_regex_global, Nullch, 0);
	    mg = mg_find(sv, PERL_MAGIC_regex_global);
d309 4
a312 4
    register SV *sv = Nullsv;
    char *item = Nullch;
    I32 itemsize  = 0;
    I32 fieldsize = 0;
d315 2
a316 2
    char *chophere = Nullch;
    char *linemark = Nullch;
d318 1
a318 1
    bool gotsome = FALSE;
d320 1
a320 1
    STRLEN fudge = SvCUR(tmpForm) * (IN_BYTES ? 1 : 3) + 1;
a363 1
            case FF_0DECIMAL:	name = "0DECIMAL";	break;
d369 1
a369 1
	} );
d397 1
a397 1
		    Perl_warner(aTHX_ packWARN(WARN_SYNTAX), "Not enough format arguments");
d406 1
a406 1
		if (itemsize != (I32)len) {
d448 1
a448 1
		if (itemsize != (I32)len) {
d547 1
a547 7
			STRLEN skip = UTF8SKIP(s);
			switch (skip) {
			default:
			    Move(s,t,skip,char);
			    s += skip;
			    t += skip;
			    break;
a641 37
	case FF_0DECIMAL:
	    /* If the field is marked with ^ and the value is undefined,
	       blank it out. */
	    arg = *fpc++;
	    if ((arg & 512) && !SvOK(sv)) {
		arg = fieldsize;
		while (arg--)
		    *t++ = ' ';
		break;
	    }
	    gotsome = TRUE;
	    value = SvNV(sv);
	    /* Formats aren't yet marked for locales, so assume "yes". */
	    {
		STORE_NUMERIC_STANDARD_SET_LOCAL();
#if defined(USE_LONG_DOUBLE)
		if (arg & 256) {
		    sprintf(t, "%#0*.*" PERL_PRIfldbl,
			    (int) fieldsize, (int) arg & 255, value);
/* is this legal? I don't have long doubles */
		} else {
		    sprintf(t, "%0*.0" PERL_PRIfldbl, (int) fieldsize, value);
		}
#else
		if (arg & 256) {
		    sprintf(t, "%#0*.*f",
			    (int) fieldsize, (int) arg & 255, value);
		} else {
		    sprintf(t, "%0*.0f",
			    (int) fieldsize, value);
		}
#endif
		RESTORE_NUMERIC_STANDARD();
	    }
	    t += fieldsize;
	    break;
	
d724 1
a724 1
    /* SAVE_DEFSV does *not* suffice here for USE_5005THREADS */
d751 1
a751 1
    SV** dst;
d783 1
a783 1
	
d793 1
a793 1
	dst = PL_stack_base + (PL_markstack_ptr[-2] += items) - 1;
d795 1
a795 1
	    *dst-- = SvTEMP(TOPs) ? POPs : sv_mortalcopy(POPs);
d832 173
d1027 1
a1027 1
 	int flip = 0;
d1030 4
a1033 7
	    if (GvIO(PL_last_in_gv)) {
		flip = SvIV(sv) == (IV)IoLINES(GvIOp(PL_last_in_gv));
	    }
	    else {
		GV *gv = gv_fetchpv(".", TRUE, SVt_PV);
		if (gv && GvSV(gv)) flip = SvIV(sv) == SvIV(GvSV(gv));
	    }
a1110 1
	int flop = 0;
d1112 3
a1114 15

	if (PL_op->op_private & OPpFLIP_LINENUM) {
	    if (GvIO(PL_last_in_gv)) {
		flop = SvIV(sv) == (IV)IoLINES(GvIOp(PL_last_in_gv));
	    }
	    else {
		GV *gv = gv_fetchpv(".", TRUE, SVt_PV);
		if (gv && GvSV(gv)) flop = SvIV(sv) == SvIV(GvSV(gv));
	    }
	}
	else {
	    flop = SvTRUE(sv);
	}

	if (flop) {
d1137 2
a1138 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting substitution via %s",
			OP_NAME(PL_op));
d1142 2
a1143 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting subroutine via %s",
			OP_NAME(PL_op));
d1147 2
a1148 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting format via %s",
			OP_NAME(PL_op));
d1152 2
a1153 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting eval via %s",
			OP_NAME(PL_op));
d1157 2
a1158 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting pseudo-block via %s",
			OP_NAME(PL_op));
d1272 2
a1273 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting substitution via %s",
			OP_NAME(PL_op));
d1277 2
a1278 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting subroutine via %s",
			OP_NAME(PL_op));
d1282 2
a1283 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting format via %s",
			OP_NAME(PL_op));
d1287 2
a1288 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting eval via %s",
			OP_NAME(PL_op));
d1292 2
a1293 2
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting pseudo-block via %s",
			OP_NAME(PL_op));
a1354 3
    IO *io;
    MAGIC *mg;

d1380 1
a1380 1
			Perl_warner(aTHX_ packWARN(WARN_MISC), SvPVX(err)+start);
d1384 1
a1384 1
	    else {
a1385 1
	    }
d1433 1
a1433 13

    /* if STDERR is tied, print to it instead */
    if (PL_stderrgv && (io = GvIOp(PL_stderrgv))
	&& (mg = SvTIED_mg((SV*)io, PERL_MAGIC_tiedscalar))) {
	dSP; ENTER;
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)io, mg));
	XPUSHs(sv_2mortal(newSVpvn(message, msglen)));
	PUTBACK;
	call_method("PRINT", G_SCALAR);
	LEAVE;
    }
    else {
d1440 1
a1440 1
	PERL_WRITE_MSG_TO_CONSOLE(serr, message, msglen);
d1493 1
a1493 1

d1502 1
a1502 2
	    if (GIMME != G_ARRAY) {
		EXTEND(SP, 1);
a1503 1
            }
a1524 1
        EXTEND(SP, 1);
a1534 2
    EXTEND(SP, 10);

d1539 1
a1539 1
    PUSHs(sv_2mortal(newSVpv(OutCopFILE(cx->blk_oldcop), 0)));
a1543 1
	GV *cvgv = CvGV(ccstack[cxix].blk_sub.cv);
d1545 4
a1548 10
	if (isGV(cvgv)) {
	    sv = NEWSV(49, 0);
	    gv_efullname3(sv, cvgv, Nullch);
	    PUSHs(sv_2mortal(sv));
	    PUSHs(sv_2mortal(newSViv((I32)cx->blk_sub.hasargs)));
	}
	else {
	    PUSHs(sv_2mortal(newSVpvn("(unknown)",9)));
	    PUSHs(sv_2mortal(newSViv((I32)cx->blk_sub.hasargs)));
	}
d1608 1
a1608 1
	if  (old_warnings == pWARN_NONE ||
d1611 1
a1611 1
        else if (old_warnings == pWARN_ALL ||
d1654 1
a1654 1
	U8 hasargs;
d1662 1
a1662 2
	if (CvDEPTH(cv) >= 1 && !(PL_debug & DEBUG_DB_RECURSE_FLAG))
	    /* don't do recursive DB::DB call */
d1706 1
a1706 1
#ifdef USE_5005THREADS
d1713 1
a1713 1
#endif /* USE_5005THREADS */
d1720 1
a1720 1
	iterdata = INT2PTR(void*, PL_op->op_targ);
d2078 1
a2078 1
    OP *kid = Nullop;
d2176 1
a2176 1
	    if (CxREALEVAL(cx))
d2188 1
a2188 1
#ifndef USE_5005THREADS
d2191 1
a2191 1
#endif /* USE_5005THREADS */
d2203 1
a2203 1
#ifdef USE_5005THREADS
d2244 2
a2245 2
		    PUSHMARK(mark);
		    (void)(*CvXSUB(cv))(aTHX_ cv);
d2263 1
a2263 1
		cx->blk_sub.olddepth = (U16)CvDEPTH(cv);
d2315 1
a2315 1
#ifdef USE_5005THREADS
d2318 1
a2318 1
		
d2325 1
a2325 1
			PUTBACK ;		
d2328 1
a2328 1
#endif /* USE_5005THREADS */		
d2331 1
a2331 1
#ifndef USE_5005THREADS
d2333 1
a2333 1
#endif /* USE_5005THREADS */
d2338 1
a2338 1
#ifndef USE_5005THREADS
d2341 1
a2341 1
#endif /* USE_5005THREADS */
d2375 1
a2375 1
		
a2406 2
	bool leaving_eval = FALSE;
        PERL_CONTEXT *last_eval_cx = 0;
d2416 2
a2417 9
		leaving_eval = TRUE;
                if (CxREALEVAL(cx)) {
		    gotoprobe = (last_eval_cx ?
				last_eval_cx->blk_eval.old_eval_root :
				PL_eval_root);
		    last_eval_cx = cx;
		    break;
                }
                /* else fall through */
a2454 11
	/* if we're leaving an eval, check before we pop any frames
           that we're not going to punt, otherwise the error
	   won't be caught */

	if (leaving_eval && *enterops && enterops[1]) {
	    I32 i;
            for (i = 1; enterops[i]; i++)
                if (enterops[i]->op_type == OP_ENTERITER)
                    DIE(aTHX_ "Can't \"goto\" into the middle of a foreach loop");
	}

a2511 1
        VMSISH_HUSHED  = VMSISH_HUSHED || (PL_op->op_private & OPpHUSH_VMSISH);
a2606 1
    OP *retop;
a2613 9

    /* Normally, the leavetry at the end of this block of ops will
     * pop an op off the return stack and continue there. By setting
     * the op to Nullop, we force an exit from the inner runops()
     * loop. DAPM.
     */
    retop = pop_return();
    push_return(Nullop);

a2627 1
	/* die caught by an inner eval - continue inner loop */
a2632 3
	/* a die in this eval - continue in outer loop */
	if (!PL_restartop)
	    break;
d2642 1
a2642 1
    return retop;
d2697 1
a2697 1
    PL_hints &= HINT_UTF8;
d2714 1
a2714 1
	PL_compiling.op_private = (U8)(PL_hints & HINT_PRIVATE_MASK);
d2721 1
a2721 1
/* With USE_5005THREADS, eval_owner must be held on entry to doeval */
d2762 1
a2762 4
    assert(CxTYPE(&cxstack[cxstack_ix]) == CXt_EVAL);
    cxstack[cxstack_ix].blk_eval.cv = PL_compcv;

#ifdef USE_5005THREADS
d2766 1
a2766 1
#endif /* USE_5005THREADS */
d2775 1
a2775 1
#ifdef USE_5005THREADS
d2779 1
a2779 1
#endif /* USE_5005THREADS */
d2812 2
d2851 3
a2853 1
#ifdef USE_5005THREADS
d2858 1
a2858 1
#endif /* USE_5005THREADS */
d2861 2
d2897 1
a2897 1
#ifdef USE_5005THREADS
d2902 1
a2902 1
#endif /* USE_5005THREADS */
d2946 1
a2946 1
    char *tryname = Nullch;
d2949 1
a2949 1
    I32 gimme = GIMME_V;
a2955 3
    SV *hook_sv = 0;
    SV *encoding;
    OP *op;
d2958 2
a2959 2
    if (SvNIOKp(sv) && PL_op->op_type != OP_DOFILE) {
	if (SvPOK(sv) && SvNOK(sv) && SvNV(sv)) {		/* require v5.6.1 */
d2965 1
a2965 1
		rev = utf8n_to_uvchr(s, end - s, &len, 0);
d2968 1
a2968 1
		    ver = utf8n_to_uvchr(s, end - s, &len, 0);
d2971 1
a2971 1
			sver = utf8n_to_uvchr(s, end - s, &len, 0);
a2983 3
	    if (ckWARN(WARN_PORTABLE))
		Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
                        "v-string in use/require non-portable");
d3000 5
a3004 5
		    DIE(aTHX_ "Perl v%"UVuf".%"UVuf".%"UVuf" required"
			" (did you mean v%"UVuf".%03"UVuf"?)--"
			"this is only v%d.%d.%d, stopped",
			rev, ver, sver, rev, ver/100,
			PERL_REVISION, PERL_VERSION, PERL_SUBVERSION);
d3027 4
a3030 1
    if (path_is_absolute(name)) {
d3033 5
d3039 9
a3047 9
#ifdef MACOS_TRADITIONAL
    if (!tryrsfp) {
	char newname[256];

	MacPerl_CanonDir(name, newname, 1);
	if (path_is_absolute(newname)) {
	    tryname = newname;
	    tryrsfp = doopen_pmc(newname,PERL_SCRIPT_MODE);
	}
d3049 1
a3050 1
    if (!tryrsfp) {
d3066 1
a3066 3
		    if (SvTYPE(SvRV(loader)) == SVt_PVAV
			&& !sv_isobject(loader))
		    {
d3071 1
a3071 1
				   PTR2UV(SvRV(dirsv)), name);
a3151 1
			hook_sv = dirsv;
a3169 8
		  if (!path_is_absolute(name)
#ifdef MACOS_TRADITIONAL
			/* We consider paths of the form :a:b ambiguous and interpret them first
			   as global then as local
			*/
			|| (*name == ':' && name[1] != ':' && strchr(name+2, ':'))
#endif
		  ) {
d3172 2
a3173 5
		    char buf1[256];
		    char buf2[256];

		    MacPerl_CanonDir(name, buf2, 1);
		    Perl_sv_setpvf(aTHX_ namesv, "%s%s", MacPerl_CanonDir(dir, buf1, 0), buf2+(buf2[0] == ':'));
d3187 8
a3200 1
		  }
d3240 2
a3241 8
    len = strlen(name);
    /* Check whether a hook in @@INC has already filled %INC */
    if (!hook_sv || !(svp = hv_fetch(GvHVn(PL_incgv), name, len, 0))) {
	(void)hv_store(GvHVn(PL_incgv), name, len,
		       (hook_sv ? SvREFCNT_inc(hook_sv)
				: newSVpv(CopFILE(&PL_compiling), 0)),
		       0 );
    }
d3257 1
a3257 3
    else if (PL_taint_warn)
        PL_compiling.cop_warnings = newSVpvn(WARN_TAINTstring, WARNsize);
    else
a3258 2
    SAVESPTR(PL_compiling.cop_io);
    PL_compiling.cop_io = Nullsv;
d3277 1
a3277 1
#ifdef USE_5005THREADS
d3284 2
a3285 12
#endif /* USE_5005THREADS */

    /* Store and reset encoding. */
    encoding = PL_encoding;
    PL_encoding = Nullsv;

    op = DOCATCH(doeval(gimme, NULL));
    
    /* Restore encoding. */
    PL_encoding = encoding;

    return op;
d3305 1
a3305 1
    if (!SvPV(sv,len))
d3312 1
a3312 1

a3343 7
    SAVESPTR(PL_compiling.cop_io);
    if (specialCopIO(PL_curcop->cop_io))
        PL_compiling.cop_io = PL_curcop->cop_io;
    else {
        PL_compiling.cop_io = newSVsv(PL_curcop->cop_io);
        SAVEFREESV(PL_compiling.cop_io);
    }
d3354 1
a3354 1
#ifdef USE_5005THREADS
d3361 1
a3361 1
#endif /* USE_5005THREADS */
d3363 1
a3363 1
    if (PERLDB_INTER && was != (I32)PL_sub_generation /* Some subs defined here. */
d3450 1
a3463 1
    OP* retop;
d3470 1
a3470 1
    retop = pop_return();
d3502 1
a3502 1
    RETURNOP(retop);
d3511 1
a3511 1
    register char *base = Nullch;
d3513 2
a3514 2
    bool noblank   = FALSE;
    bool repeat    = FALSE;
d3518 1
a3518 1
    U16 *linepc = 0;
d3524 1
a3524 1

d3552 1
a3552 1
	
d3561 1
a3561 1
		*fpc++ = (U16)arg;
d3568 1
a3568 1
		*fpc++ = (U16)skipspaces;
d3579 1
a3579 1
		*fpc++ = (U16)arg;
d3602 1
a3602 1
		*fpc++ = (U16)arg;
d3627 1
a3627 19
                *fpc++ = (U16)arg;
            }
            else if (*s == '0' && s[1] == '#') {  /* Zero padded decimals */
                arg = ischop ? 512 : 0;
		base = s - 1;
                s++;                                /* skip the '0' first */
                while (*s == '#')
                    s++;
                if (*s == '.') {
                    char *f;
                    s++;
                    f = s;
                    while (*s == '#')
                        s++;
                    arg |= 256 + (s - f);
                }
                *fpc++ = s - base;                /* fieldsize for FETCH */
                *fpc++ = FF_0DECIMAL;
		*fpc++ = (U16)arg;
d3656 1
a3656 1
		    *fpc++ = (U16)prespace;
d3679 1
a3679 1
    sv_magic(sv, Nullsv, PERL_MAGIC_fm, Nullch, 0);
d3683 755
d4439 144
a4582 1
run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)
d4651 10
a4660 4
/* perhaps someone can come up with a better name for
   this?  it is not really "absolute", per se ... */
static bool
S_path_is_absolute(pTHX_ char *name)
d4662 1
a4662 12
    if (PERL_FILE_IS_ABSOLUTE(name)
#ifdef MACOS_TRADITIONAL
	|| (*name == ':'))
#else
	|| (*name == '.' && (name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/'))))
#endif
    {
	return TRUE;
    }
    else
    	return FALSE;
d4664 2
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d24 1
a24 1
#define WORD_ALIGN sizeof(U32)
d100 1
a100 1
	        ReREFCNT_dec(PM_GETRE(pm));
a158 10
    SV *nsv = Nullsv;

    { 
      REGEXP *old = PM_GETRE(pm);
      if(old != rx) {
	if(old) 
	  ReREFCNT_dec(old);
	PM_SETRE(pm,rx);
      }
    }
d161 1
a161 1
    RX_MATCH_UTF8_set(rx, SvUTF8(cx->sb_targ));
d181 1
a181 4
	    if (DO_UTF8(dstr) && !SvUTF8(targ))
		sv_catpvn_utf8_upgrade(dstr, s, cx->sb_strend - s, nsv);
	    else
		sv_catpvn(dstr, s, cx->sb_strend - s);
d185 1
a185 2
	    if (SvLEN(targ))
		Safefree(SvPVX(targ));
d195 1
a195 1
	    PUSHs(sv_2mortal(newSViv(saviters - 1)));
a202 1
	    ReREFCNT_dec(rx);
d216 2
a217 6
    if (m > s) {
	if (DO_UTF8(dstr) && !SvUTF8(cx->sb_targ)) 
	    sv_catpvn_utf8_upgrade(dstr, s, m - s, nsv);
	else
	    sv_catpvn(dstr, s, m-s);
    }
a233 1
    ReREFCNT_inc(rx);
d304 1
a304 1
    register U32 *fpc;
d322 1
a322 3
    bool item_is_utf8 = FALSE;
    bool targ_is_utf8 = FALSE;
    SV * nsv = Nullsv;
d333 1
a334 2
    if (DO_UTF8(PL_formtarget))
	targ_is_utf8 = TRUE;
d341 1
a341 1
    fpc = (U32*)s;
a380 15
	    if (targ_is_utf8 && !SvUTF8(tmpForm)) {
		SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
		*t = '\0';
		sv_catpvn_utf8_upgrade(PL_formtarget, f, arg, nsv);
		t = SvEND(PL_formtarget);
		break;
	    }
	    if (!targ_is_utf8 && DO_UTF8(tmpForm)) {
		SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
		*t = '\0';
		sv_utf8_upgrade(PL_formtarget);
		SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
		t = SvEND(PL_formtarget);
		targ_is_utf8 = TRUE;
	    }
d425 1
a425 1
		    item_is_utf8 = TRUE;
d431 1
a431 1
	    item_is_utf8 = FALSE;
d486 1
a486 1
		    item_is_utf8 = TRUE;
d490 1
a490 1
	    item_is_utf8 = FALSE;
d546 1
a546 9
	    if (item_is_utf8) {
		if (!targ_is_utf8) {
		    SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
		    *t = '\0';
		    sv_utf8_upgrade(PL_formtarget);
		    SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
		    t = SvEND(PL_formtarget);
		    targ_is_utf8 = TRUE;
		}
a571 15
	    if (targ_is_utf8 && !item_is_utf8) {
		SvCUR_set(PL_formtarget, t - SvPVX(PL_formtarget));
		*t = '\0';
		sv_catpvn_utf8_upgrade(PL_formtarget, s, arg, nsv);
		for (; t < SvEND(PL_formtarget); t++) {
#ifdef EBCDIC
		    int ch = *t++ = *s++;
		    if (iscntrl(ch))
#else
		    if (!(*t & ~31))
#endif
			*t = ' ';
		}
		break;
	    }
a589 1
	    SvSETMAGIC(sv);
d595 1
a595 2
	    if ((item_is_utf8 = DO_UTF8(sv)))
		itemsize = sv_len_utf8(sv);	    
a596 1
		bool chopped = FALSE;
d598 1
a598 1
		send = s + len;
d601 1
a601 1
			if (s == send) {
a602 2
			    chopped = TRUE;
			}
d608 1
a608 5
		if (targ_is_utf8)
		    SvUTF8_on(PL_formtarget);
		sv_catsv(PL_formtarget, sv);
		if (chopped)
		    SvCUR_set(PL_formtarget, SvCUR(PL_formtarget) - 1);
a610 2
		if (item_is_utf8)
		    targ_is_utf8 = TRUE;
a705 2
		    if (targ_is_utf8)
			SvUTF8_on(PL_formtarget);
a744 2
	    if (targ_is_utf8)
		SvUTF8_on(PL_formtarget);
a791 1
    I32 gimme = GIMME_V;
d802 1
a802 1
    if (items && gimme != G_VOID) {
d839 1
a839 1
	while (items-- > 0)
d846 1
a945 4
	/* This code tries to decide if "$left .. $right" should use the
	   magical string increment, or if the range is numeric (we make
	   an exception for .."0" [#18165]). AMS 20021031. */

d949 1
a949 1
	     looks_like_number(right)))
a1013 10
static char *context_name[] = {
    "pseudo-block",
    "subroutine",
    "eval",
    "loop",
    "substitution",
    "block",
    "format"
};

d1024 4
d1029 4
d1034 4
d1039 4
d1045 3
a1047 5
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting %s via %s",
			context_name[CxTYPE(cx)], OP_NAME(PL_op));
	    if (CxTYPE(cx) == CXt_NULL)
		return -1;
	    break;
d1159 4
d1164 4
d1169 4
d1174 4
d1180 3
a1182 5
		Perl_warner(aTHX_ packWARN(WARN_EXITING), "Exiting %s via %s",
			context_name[CxTYPE(cx)], OP_NAME(PL_op));
	    if ((CxTYPE(cx)) == CXt_NULL)
		return -1;
	    break;
d1243 2
d1279 2
a1296 2
		if (!message)
		    message = SvPVx(ERRSV, msglen);
d1326 24
a1349 1
    write_to_stderr(message, msglen);
a1556 2
/* like pp_nextstate, but used instead when the debugger is active */

d1564 1
a1564 2
    if (PL_op->op_flags & OPf_SPECIAL /* breakpoint */
	    || SvIV(PL_DBsingle) || SvIV(PL_DBsignal) || SvIV(PL_DBtrace))
d1593 1
a1593 1
	PUSHSUB_DB(cx);
d1596 2
a1597 1
	PAD_SET_CUR(CvPADLIST(cv),1);
d1633 1
a1633 1
	svp = &PAD_SVl(PL_op->op_targ);		/* "my" variable */
a1662 1
	    /* See comment in pp_flop() */
d1666 2
a1667 1
		 looks_like_number((SV*)cx->blk_loop.iterary)))
d1793 1
a1793 1
	    DIE(aTHX_ "%"SVf" did not return a true value", nsv);
a2003 1
	o->op_type == OP_LEAVESUB ||
d2021 5
a2025 9
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) {
	        if (ops == opstack)
		    *ops++ = kid;
		else if (ops[-1]->op_type == OP_NEXTSTATE ||
		         ops[-1]->op_type == OP_DBSTATE)
		    ops[-1] = kid;
		else
		    *ops++ = kid;
	    }
d2081 1
a2081 1
		    DIE(aTHX_ "Goto undefined subroutine &%"SVf"",tmpstr);
a2086 2
	    SvREFCNT_inc(cv); /* avoid premature free during unwind */
	    FREETMPS;
d2115 1
a2115 1
		    PAD_SVl(0) = (SV*)(cx->blk_sub.argarray = av);
a2116 2
		else
		    CLEAR_ARGARRAY(av);
d2121 1
a2121 1
		av = (AV*)PAD_SVl(0);
a2138 1
	    SAVEFREESV(cv); /* later, undo the 'avoid premature free' hack */
d2172 1
a2180 1

d2184 1
a2184 1
		else {
d2187 44
a2230 1
		    pad_push(padlist, CvDEPTH(cv), cx->blk_sub.hasargs);
d2234 1
a2234 1
		    AV* av = (AV*)PAD_SVl(0);
d2245 3
a2247 2
#endif /* USE_5005THREADS */
		PAD_SET_CUR(padlist, CvDEPTH(cv));
d2252 1
a2252 1
		    AV* av = (AV*)PAD_SVl(0);
d2259 1
a2259 1
		    CX_CURPAD_SAVE(cx->blk_sub);
d2294 1
a2294 4
			(void)SvUPGRADE(sv, SVt_PVIV);
			(void)SvIOK_on(sv);
			SAVEIV(SvIVX(sv));
			SvIVX(sv) = PTR2IV(cv); /* Do it the quickest way */
a2324 1
	bool in_block = FALSE;
d2336 1
a2336 1
                if (!CxTRYBLOCK(cx)) {
d2350 1
a2350 1
		if (ix) {
d2352 1
a2352 2
		    in_block = TRUE;
		} else
d2409 1
a2409 2
	    ix = enterops[1]->op_type == OP_ENTER && in_block ? 2 : 1;
	    for (; enterops[ix]; ix++) {
d2598 1
a2598 1
Perl_sv_compile_2op(pTHX_ SV *sv, OP** startop, char *code, PAD** padp)
a2612 2
    int runtime;
    CV* runcv = Nullcv;	/* initialise to avoid compiler warnings */
d2619 1
a2619 1
    if (IN_PERL_COMPILETIME) {
a2650 5
    /* we get here either during compilation, or via pp_regcomp at runtime */
    runtime = IN_PERL_RUNTIME;
    if (runtime)
	runcv = find_runcv(NULL);

d2654 1
a2654 1
    PUSHBLOCK(cx, CXt_EVAL|(IN_PERL_COMPILETIME ? 0 : CXp_REAL), SP);
d2656 1
a2656 5

    if (runtime)
	rop = doeval(G_SCALAR, startop, runcv, PL_curcop->cop_seq);
    else
	rop = doeval(G_SCALAR, startop, PL_compcv, PL_cop_seqmax);
d2663 1
a2663 2
    /* XXX DAPM do this properly one year */
    *padp = (AV*)SvREFCNT_inc(PL_comppad);
d2665 1
a2665 1
    if (IN_PERL_COMPILETIME)
a2672 48

/*
=for apidoc find_runcv

Locate the CV corresponding to the currently executing sub or eval.
If db_seqp is non_null, skip CVs that are in the DB package and populate
*db_seqp with the cop sequence number at the point that the DB:: code was
entered. (allows debuggers to eval in the scope of the breakpoint rather
than in in the scope of the debuger itself).

=cut
*/

CV*
Perl_find_runcv(pTHX_ U32 *db_seqp)
{
    I32		 ix;
    PERL_SI	 *si;
    PERL_CONTEXT *cx;

    if (db_seqp)
	*db_seqp = PL_curcop->cop_seq;
    for (si = PL_curstackinfo; si; si = si->si_prev) {
	for (ix = si->si_cxix; ix >= 0; ix--) {
	    cx = &(si->si_cxstack[ix]);
	    if (CxTYPE(cx) == CXt_SUB || CxTYPE(cx) == CXt_FORMAT) {
		CV *cv = cx->blk_sub.cv;
		/* skip DB:: code */
		if (db_seqp && PL_debstash && CvSTASH(cv) == PL_debstash) {
		    *db_seqp = cx->blk_oldcop->cop_seq;
		    continue;
		}
		return cv;
	    }
	    else if (CxTYPE(cx) == CXt_EVAL && !CxTRYBLOCK(cx))
		return PL_compcv;
	}
    }
    return PL_main_cv;
}


/* Compile a require/do, an eval '', or a /(?{...})/.
 * In the last case, startop is non-null, and contains the address of
 * a pointer that should be set to the just-compiled code.
 * outside is the lexically enclosing CV (if any) that invoked us.
 */

d2675 1
a2675 1
S_doeval(pTHX_ int gimme, OP** startop, CV* outside, U32 seq)
d2679 3
d2689 21
d2723 12
a2734 2
    CvOUTSIDE_SEQ(PL_compcv) = seq;
    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc(outside);
d2736 5
a2740 3
    /* set up a scratch pad */

    CvPADLIST(PL_compcv) = pad_new(padnew_SAVE);
d2742 5
d2772 2
a2773 1
	SV **newsp;			/* Used by POPBLOCK. */
a2803 6
	else {
	    char* msg = SvPVx(ERRSV, n_a);
	    if (!*msg) {
	        sv_setpv(ERRSV, "Compilation error");
	    }
	}
d2815 2
d2819 1
a2819 10

    /* Set the context for this new optree.
     * If the last op is an OP_REQUIRE, force scalar context.
     * Otherwise, propagate the context from the eval(). */
    if (PL_eval_root->op_type == OP_LEAVEEVAL
	    && cUNOPx(PL_eval_root)->op_first->op_type == OP_LINESEQ
	    && cLISTOPx(cUNOPx(PL_eval_root)->op_first)->op_last->op_type
	    == OP_REQUIRE)
	scalar(PL_eval_root);
    else if (gimme & G_VOID)
d2857 1
a2857 1
S_doopen_pm(pTHX_ const char *name, const char *mode)
a2858 1
#ifndef PERL_DISABLE_PMC
a2885 3
#else
    return PerlIO_open(name, mode);
#endif /* !PERL_DISABLE_PMC */
d2936 3
d2984 1
a2984 1
	tryrsfp = doopen_pm(name,PERL_SCRIPT_MODE);
d2993 1
a2993 1
	    tryrsfp = doopen_pm(newname,PERL_SCRIPT_MODE);
a3093 1
			SP--;
d3148 1
a3148 1
		    tryrsfp = doopen_pm(tryname, PERL_SCRIPT_MODE);
d3191 1
a3191 1
	SETERRNO(0, SS_NORMAL);
d3254 1
a3254 1
    op = DOCATCH(doeval(gimme, NULL, Nullcv, PL_curcop->cop_seq));
a3277 2
    CV* runcv;
    U32 seq;
a3324 6
    /* special case: an eval '' executed within the DB package gets lexically
     * placed in the first non-DB CV rather than the current CV - this
     * allows the debugger to execute code, find lexicals etc, in the
     * scope of the code being debugged. Passing &seq gets find_runcv
     * to do the dirty work for us */
    runcv = find_runcv(&seq);
d3343 1
a3343 1
    ret = doeval(gimme, NULL, runcv, seq);
d3407 1
a3407 1
	retop = Perl_die(aTHX_ "%"SVf" did not return a true value", nsv);
d3497 3
a3499 3
    U32 *fops;
    register U32 *fpc;
    U32 *linepc = 0;
a3501 1
    int maxops = 2; /* FF_LINEMARK + FF_END) */
d3506 1
a3506 9
    /* estimate the buffer size needed */
    for (base = s; s <= send; s++) {
	if (*s == '\n' || *s == '@@' || *s == '^')
	    maxops += 10;
    }
    s = base;
    base = Nullch;

    New(804, fops, maxops, U32);
a3668 1
    assert (fpc <= fops + maxops); /* ensure our buffer estimate was valid */
d3673 1
a3673 1
	SvGROW(sv, SvCUR(sv) + z + arg * sizeof(U32) + 4);
d3676 1
a3676 1
    Copy(fops, s, arg, U32);
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@a61 1
    TAINT_NOT;
d161 4
a164 2
    REGEXP *old = PM_GETRE(pm);
    if(old != rx) {
d166 1
a166 1
	    ReREFCNT_dec(old);
d168 1
d254 1
a254 2
    if (old != rx)
	ReREFCNT_inc(rx);
a1007 10
/* This code tries to decide if "$left .. $right" should use the
   magical string increment, or if the range is numeric (we make
   an exception for .."0" [#18165]). AMS 20021031. */

#define RANGE_IS_NUMERIC(left,right) ( \
	SvNIOKp(left)  || (SvOK(left)  && !SvPOKp(left))  || \
	SvNIOKp(right) || (SvOK(right) && !SvPOKp(right)) || \
	(looks_like_number(left) && SvPOKp(left) && *SvPVX(left) != '0' && \
	 looks_like_number(right)))

d1023 9
a1031 1
	if (RANGE_IS_NUMERIC(left,right)) {
d1703 6
a1708 1
	    if (RANGE_IS_NUMERIC(sv,(SV*)cx->blk_loop.iterary)) {
d3562 1
a3562 1
	if (*s == '\n' || *s == '\0' || *s == '@@' || *s == '^')
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
a344 3
    OP * parseres = 0;
    char *fmt;
    bool oneline;
d349 1
a349 1
	    parseres = doparseform(tmpForm);
d353 1
a353 3
	    parseres = doparseform(tmpForm);
	if (parseres)
	    return parseres;
a388 1
	    case FF_LINESNGL:	name = "LINESNGL";	break;
a494 1
				chophere = s;
a533 1
			chophere = s;
d624 1
a624 1
		    int ch = *t;
a653 4
	case FF_LINESNGL:
	    chopspace = 0;
	    oneline = TRUE;
	    goto ff_line;
a654 2
	    oneline = FALSE;
	ff_line:
a662 1
		chophere = s + itemsize;
d665 2
a666 1
		        if (oneline) {
a667 8
			    chophere = s;
			    break;
			} else {
			    if (s == send) {
			        itemsize--;
			        chopped = TRUE;
			    } else
			        lines++;
d669 2
d676 1
a676 6
		if (oneline) {
		    SvCUR_set(sv, chophere - item);
		    sv_catsv(PL_formtarget, sv);
		    SvCUR_set(sv, itemsize);
		} else
		    sv_catsv(PL_formtarget, sv);
a685 8
	case FF_0DECIMAL:
	    arg = *fpc++;
#if defined(USE_LONG_DOUBLE)
	    fmt = (arg & 256) ? "%#0*.*" PERL_PRIfldbl : "%0*.*" PERL_PRIfldbl;
#else
	    fmt = (arg & 256) ? "%#0*.*f"              : "%0*.*f";
#endif
	    goto ff_dec;
d687 2
d690 11
d702 6
a707 1
 	    fmt = (arg & 256) ? "%#*.*" PERL_PRIfldbl : "%*.*" PERL_PRIfldbl;
d709 7
a715 1
            fmt = (arg & 256) ? "%#*.*f"              : "%*.*f";
d717 6
a722 1
	ff_dec:
d725 1
a733 7
	    /* overflow evidence */
	    if (num_overflow(value, fieldsize, arg)) { 
	        arg = fieldsize;
		while (arg--)
		    *t++ = '#';
		break;
	    }
d737 17
a753 1
		sprintf(t, fmt, (int) fieldsize, (int) arg & 255, value);
d758 1
a758 1

d916 2
a917 13
	if (gimme == G_ARRAY) {
	    while (items-- > 0)
		*dst-- = SvTEMP(TOPs) ? POPs : sv_mortalcopy(POPs);
	}
	else { 
	    /* scalar context: we don't care about which values map returns
	     * (we use undef here). And so we certainly don't want to do mortal
	     * copies of meaningless values. */
	    while (items-- > 0) {
		(void)POPs;
		*dst-- = &PL_sv_undef;
	    }
	}
d1014 2
a1015 3
	(((!SvOK(left) && SvOK(right)) || ((!SvOK(left) || \
          looks_like_number(left)) && SvPOKp(left) && *SvPVX(left) != '0')) \
         && (!SvOK(right) || looks_like_number(right))))
d1023 1
a1023 1
	register IV i, j;
d1025 1
a1025 1
	IV max;
d1033 1
a1033 2
	    if ((SvOK(left) && SvNV(left) < IV_MIN) ||
		(SvOK(right) && SvNV(right) > IV_MAX))
d1637 1
d1704 6
a1709 7
	    SV *right = (SV*)cx->blk_loop.iterary;
	    if (RANGE_IS_NUMERIC(sv,right)) {
		if ((SvOK(sv) && SvNV(sv) < IV_MIN) ||
		    (SvOK(right) && SvNV(right) >= IV_MAX))
		    DIE(aTHX_ "Range iterator outside integer range");
		cx->blk_loop.iterix = SvIV(sv);
		cx->blk_loop.itermax = SvIV(right);
d1711 1
a1711 2
	    else {
		STRLEN n_a;
a1712 3
		(void) SvPV_force(cx->blk_loop.iterlval,n_a);
		(void) SvPV(right,n_a);
	    }
a1814 1
	cxstack_ix++; /* preserve cx entry on stack for use by POPSUB */
a1873 1
    LEAVE;
a1875 1
	cxstack_ix--;
d1882 1
a1916 1
    cxstack_ix++; /* temporarily protect top context */
a1957 2
    LEAVE;
    cxstack_ix--;
d1970 1
a2024 1
    FREETMPS;
a2091 1
    AV *oldav = Nullav;
d2154 1
a2154 1
		    oldav = av;	/* delay until return */
a2183 3
	    /* For reified @@_, delay freeing till return from new sub */
	    if (oldav)
		SAVEFREESV((SV*)oldav);
d2233 1
a2233 1
		    pad_push(padlist, CvDEPTH(cv), 1);
d2659 1
d2701 1
a2701 1
than in in the scope of the debugger itself).
d3535 1
a3535 1
STATIC OP *
d3551 1
a3551 2
    bool unchopnum = FALSE;
    int maxops = 12; /* FF_LINEMARK + FF_END + 10 (\0 without preceding \n) */
d3558 1
a3558 1
	if (*s == '\n' || *s == '@@' || *s == '^')
d3591 2
a3592 6
        case 0:
	    if (s < send) {
	        skipspaces = 0;
                continue;
            } /* else FALL THROUGH */
	case '\n':
d3648 2
a3649 6
		*fpc++ = 2;  /* skip the @@* or ^* */
		if (ischop) {
		    *fpc++ = FF_LINESNGL;
		    *fpc++ = FF_CHOP;
		} else
		    *fpc++ = FF_LINEGLOB;
a3666 1
                unchopnum |= ! ischop;
a3684 1
                unchopnum |= ! ischop;
a3738 32

    if (unchopnum && repeat) 
        DIE(aTHX_ "Repeated format line will never terminate (~~ and @@#)");
    return 0;
}


STATIC bool
S_num_overflow(NV value, I32 fldsize, I32 frcsize)
{
    /* Can value be printed in fldsize chars, using %*.*f ? */
    NV pwr = 1;
    NV eps = 0.5;
    bool res = FALSE;
    int intsize = fldsize - (value < 0 ? 1 : 0);

    if (frcsize & 256)
        intsize--;
    frcsize &= 255;
    intsize -= frcsize;

    while (intsize--) pwr *= 10.0;
    while (frcsize--) eps /= 10.0;

    if( value >= 0 ){
        if (value + eps >= pwr)
	    res = TRUE;
    } else {
        if (value - eps <= -pwr)
	    res = TRUE;
    }
    return res;
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a19 11
/* This file contains control-oriented pp ("push/pop") functions that
 * execute the opcodes that make up a perl program. A typical pp function
 * expects to find its arguments on the stack, and usually pushes its
 * results onto the stack, hence the 'pp' terminology. Each OP structure
 * contains a pointer to the relevant pp_foo() function.
 *
 * Control-oriented means things like pp_enteriter() and pp_next(), which
 * alter the flow of control of the program.
 */


d190 4
a193 7
	    assert(cx->sb_strend >= s);
	    if(cx->sb_strend > s) {
		 if (DO_UTF8(dstr) && !SvUTF8(targ))
		      sv_catpvn_utf8_upgrade(dstr, s, cx->sb_strend - s, nsv);
		 else
		      sv_catpvn(dstr, s, cx->sb_strend - s);
	    }
d196 1
a196 1
	    SvOOK_off(targ);
d341 1
a341 2
    STRLEN fudge = SvPOK(tmpForm)
			? (SvCUR(tmpForm) * (IN_BYTES ? 1 : 3) + 1) : 0;
a1724 5
	else if (PL_op->op_private & OPpITER_REVERSED) {
	    cx->blk_loop.itermax = -1;
	    cx->blk_loop.iterix = AvFILL(cx->blk_loop.iterary);

	}
d1729 1
a1729 7
	if (PL_op->op_private & OPpITER_REVERSED) {
	    cx->blk_loop.itermax = MARK - PL_stack_base;
	    cx->blk_loop.iterix = cx->blk_oldsp;
	}
	else {
	    cx->blk_loop.iterix = MARK - PL_stack_base;
	}
d2108 1
a2122 1
	    bool reified = 0;
d2155 1
d2161 4
a2164 2
		EXTEND(SP, items+1); /* @@_ could have been extended. */
		Copy(AvARRAY(av), SP + 1, items, SV*);
a2168 1
		CLEAR_ARGARRAY(av);
d2171 1
a2171 2
		    reified = 1;
		    SvREFCNT_dec(av);
d2177 2
d2188 4
a2191 2
		EXTEND(SP, items+1); /* @@_ could have been extended. */
		Copy(AvARRAY(av), SP + 1, items, SV*);
a2192 2
	    mark = SP;
	    SP += items;
d2201 3
a2205 5
		if (reified) {
		    I32 index;
		    for (index=0; index<items; index++)
			sv_2mortal(SP[-index]);
		}
d2225 1
a2227 1
		    PUTBACK;
d2283 1
a2297 1
		    ++mark;
a2300 5
		    if (reified) {
			/* transfer 'ownership' of refcnts to new @@_ */
			AvREAL_on(av);
			AvREIFY_off(av);
		    }
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d81 1
d83 1
d85 1
a85 1

d100 1
a100 1
	regexp * const re = (regexp *)mg->mg_obj;
d105 1
a105 2
	STRLEN len;
	const char *t = SvPV_const(tmpstr, len);
d127 1
a127 1
	    PM_SETRE(pm, CALLREGCOMP(aTHX_ (char *)t, (char *)t + len, pm));
d165 1
d167 1
a167 2
    register PMOP * const pm = (PMOP*) cLOGOP->op_other;
    register SV * const dstr = cx->sb_dstr;
d171 1
a171 1
    register REGEXP * const rx = cx->sb_rx;
d175 1
a175 1
	if(old)
d181 1
a181 1
    RX_MATCH_UTF8_set(rx, DO_UTF8(cx->sb_targ));
d184 1
a184 1
	const I32 saviters = cx->sb_iters;
d199 1
a199 1
	    SV * const targ = cx->sb_targ;
d210 4
a213 2
	    SvPV_free(targ);
	    SvPV_set(targ, SvPVX(dstr));
d218 1
a218 1
	    SvPV_set(dstr, (char*)0);
d245 1
a245 1
	if (DO_UTF8(dstr) && !SvUTF8(cx->sb_targ))
d252 1
a252 1
	SV * const sv = cx->sb_targ;
d267 1
a267 1
	(void)ReREFCNT_inc(rx);
d282 1
a282 1
	    Newx(p, i, UV);
d325 1
a325 1
    UV * const p = (UV*)*rsp;
a327 6
#ifdef PERL_POISON
	void *tmp = INT2PTR(char*,*p);
	Safefree(tmp);
	if (*p)
	    Poison(*p, 1, sizeof(*p));
#else
a328 1
#endif
d337 1
a337 1
    register SV * const tmpForm = *++MARK;
d340 3
a342 1
    const char *f;
d345 1
a345 1
    const char *item = Nullch;
d350 1
a350 1
    const char *chophere = Nullch;
d355 1
a355 1
    const STRLEN fudge = SvPOK(tmpForm)
d361 1
a361 1
    const char *fmt;
d380 1
a380 1
    f = SvPV_const(tmpForm, len);
d382 3
a384 1
    fpc = (U32*)(f + len + WORD_ALIGN - SvCUR(tmpForm) % WORD_ALIGN);
d388 1
a388 1
	    const char *name = "???";
d408 1
a408 1
	    case FF_0DECIMAL:	name = "0DECIMAL";	break;
d426 1
a426 1
		SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
d433 1
a433 1
		SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
d463 20
a482 27
	    {
		const char *send;
		const char *s = item = SvPV_const(sv, len);
		itemsize = len;
		if (DO_UTF8(sv)) {
		    itemsize = sv_len_utf8(sv);
		    if (itemsize != (I32)len) {
			I32 itembytes;
			if (itemsize > fieldsize) {
			    itemsize = fieldsize;
			    itembytes = itemsize;
			    sv_pos_u2b(sv, &itembytes, 0);
			}
			else
			    itembytes = len;
			send = chophere = s + itembytes;
			while (s < send) {
			    if (*s & ~31)
				gotsome = TRUE;
			    else if (*s == '\n')
				break;
			    s++;
			}
			item_is_utf8 = TRUE;
			itemsize = s - item;
			sv_pos_b2u(sv, &itemsize);
			break;
d484 4
a488 13
		item_is_utf8 = FALSE;
		if (itemsize > fieldsize)
		    itemsize = fieldsize;
		send = chophere = s + itemsize;
		while (s < send) {
		    if (*s & ~31)
			gotsome = TRUE;
		    else if (*s == '\n')
			break;
		    s++;
		}
		itemsize = s - item;
		break;
d490 13
d505 26
a530 12
	    {
		const char *s = item = SvPV_const(sv, len);
		itemsize = len;
		if (DO_UTF8(sv)) {
		    itemsize = sv_len_utf8(sv);
		    if (itemsize != (I32)len) {
			I32 itembytes;
			if (itemsize <= fieldsize) {
			    const char *send = chophere = s + itemsize;
			    while (s < send) {
				if (*s == '\r') {
				    itemsize = s - item;
d532 1
d534 3
a536 2
				}
				if (*s++ & ~31)
d538 2
d541 1
d543 14
a556 25
			else {
			    const char *send;
			    itemsize = fieldsize;
			    itembytes = itemsize;
			    sv_pos_u2b(sv, &itembytes, 0);
			    send = chophere = s + itembytes;
			    while (s < send || (s == send && isSPACE(*s))) {
				if (isSPACE(*s)) {
				    if (chopspace)
					chophere = s;
				    if (*s == '\r')
					break;
				}
				else {
				    if (*s & ~31)
					gotsome = TRUE;
				    if (strchr(PL_chopset, *s))
					chophere = s + 1;
				}
				s++;
			    }
			    itemsize = chophere - item;
			    sv_pos_b2u(sv, &itemsize);
			}
			item_is_utf8 = TRUE;
d559 2
d562 7
a568 6
		item_is_utf8 = FALSE;
		if (itemsize <= fieldsize) {
		    const char *const send = chophere = s + itemsize;
		    while (s < send) {
			if (*s == '\r') {
			    itemsize = s - item;
d570 1
d572 3
a574 2
			}
			if (*s++ & ~31)
d576 2
d579 1
d581 1
a581 22
		else {
		    const char *send;
		    itemsize = fieldsize;
		    send = chophere = s + itemsize;
		    while (s < send || (s == send && isSPACE(*s))) {
			if (isSPACE(*s)) {
			    if (chopspace)
				chophere = s;
			    if (*s == '\r')
				break;
			}
			else {
			    if (*s & ~31)
				gotsome = TRUE;
			    if (strchr(PL_chopset, *s))
				chophere = s + 1;
			}
			s++;
		    }
		    itemsize = chophere - item;
		}
		break;
d583 1
d605 27
a631 33
	    {
		const char *s = item;
		arg = itemsize;
		if (item_is_utf8) {
		    if (!targ_is_utf8) {
			SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
			*t = '\0';
			sv_utf8_upgrade(PL_formtarget);
			SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
			t = SvEND(PL_formtarget);
			targ_is_utf8 = TRUE;
		    }
		    while (arg--) {
			if (UTF8_IS_CONTINUED(*s)) {
			    STRLEN skip = UTF8SKIP(s);
			    switch (skip) {
			    default:
				Move(s,t,skip,char);
				s += skip;
				t += skip;
				break;
			    case 7: *t++ = *s++;
			    case 6: *t++ = *s++;
			    case 5: *t++ = *s++;
			    case 4: *t++ = *s++;
			    case 3: *t++ = *s++;
			    case 2: *t++ = *s++;
			    case 1: *t++ = *s++;
			    }
			}
			else {
			    if ( !((*t++ = *s++) & ~31) )
				t[-1] = ' ';
d634 4
a637 1
		    break;
d639 7
a645 5
		if (targ_is_utf8 && !item_is_utf8) {
		    SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
		    *t = '\0';
		    sv_catpvn_utf8_upgrade(PL_formtarget, s, arg, nsv);
		    for (; t < SvEND(PL_formtarget); t++) {
d647 2
a648 2
			const int ch = *t;
			if (iscntrl(ch))
d650 1
a650 1
			    if (!(*t & ~31))
d652 1
a652 3
				*t = ' ';
		    }
		    break;
d654 3
a656 1
		while (arg--) {
d658 2
a659 2
		    const int ch = *t++ = *s++;
		    if (iscntrl(ch))
d661 1
a661 1
			if ( !((*t++ = *s++) & ~31) )
d663 1
a663 3
			    t[-1] = ' ';
		}
		break;
d665 1
d668 4
a671 9
	    {
		const char *s = chophere;
		if (chopspace) {
		    while (*s && isSPACE(*s))
			s++;
		}
		sv_chop(sv,(char *)s);
		SvSETMAGIC(sv);
		break;
d673 3
d684 21
a704 23
	    {
		const char *s = item = SvPV_const(sv, len);
		itemsize = len;
		if ((item_is_utf8 = DO_UTF8(sv)))
		    itemsize = sv_len_utf8(sv);
		if (itemsize) {
		    bool chopped = FALSE;
		    const char *const send = s + len;
		    gotsome = TRUE;
		    chophere = s + itemsize;
		    while (s < send) {
			if (*s++ == '\n') {
			    if (oneline) {
				chopped = TRUE;
				chophere = s;
				break;
			    } else {
				if (s == send) {
				    itemsize--;
				    chopped = TRUE;
				} else
				    lines++;
			    }
a706 15
		    SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
		    if (targ_is_utf8)
			SvUTF8_on(PL_formtarget);
		    if (oneline) {
			SvCUR_set(sv, chophere - item);
			sv_catsv(PL_formtarget, sv);
			SvCUR_set(sv, itemsize);
		    } else
			sv_catsv(PL_formtarget, sv);
		    if (chopped)
			SvCUR_set(PL_formtarget, SvCUR(PL_formtarget) - 1);
		    SvGROW(PL_formtarget, SvCUR(PL_formtarget) + fudge + 1);
		    t = SvPVX(PL_formtarget) + SvCUR(PL_formtarget);
		    if (item_is_utf8)
			targ_is_utf8 = TRUE;
d708 15
a722 1
		break;
d724 1
d753 1
a753 1
	    if (num_overflow(value, fieldsize, arg)) {
d780 1
a780 1
		    SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
d801 21
a821 25
	    {
		const char *s = chophere;
		const char *send = item + len;
		if (chopspace) {
		    while (*s && isSPACE(*s) && s < send)
			s++;
		}
		if (s < send) {
		    char *s1;
		    arg = fieldsize - itemsize;
		    if (arg) {
			fieldsize -= arg;
			while (arg-- > 0)
			    *t++ = ' ';
		    }
		    s1 = t - 3;
		    if (strnEQ(s1,"   ",3)) {
			while (s1 > SvPVX_const(PL_formtarget) && isSPACE(s1[-1]))
			    s1--;
		    }
		    *s1++ = '.';
		    *s1++ = '.';
		    *s1++ = '.';
		}
		break;
d823 2
d827 1
a827 1
	    SvCUR_set(PL_formtarget, t - SvPVX_const(PL_formtarget));
d877 1
a877 1
    const I32 gimme = GIMME_V;
d914 1
a914 1

d929 1
a929 1
	else {
d994 2
a995 2
	SV * const targ = PAD_SV(PL_op->op_targ);
	int flip = 0;
d997 1
a997 1
	if (PL_op->op_private & OPpFLIP_LINENUM) {
d1002 2
a1003 3
		GV * const gv = gv_fetchpv(".", TRUE, SVt_PV);
		if (gv && GvSV(gv))
		    flip = SvIV(sv) == SvIV(GvSV(gv));
d1005 4
a1008 4
	} else {
	    flip = SvTRUE(sv);
	}
	if (flip) {
d1021 1
a1021 1
	sv_setpvn(TARG, "", 0);
d1035 1
a1035 1
          looks_like_number(left)) && SvPOKp(left) && *SvPVX_const(left) != '0')) \
d1044 3
a1053 2
	    register IV i, j;
	    IV max;
d1067 1
a1067 1
		SV * const sv = sv_2mortal(newSViv(i++));
d1072 3
a1074 3
	    SV * const final = sv_mortalcopy(right);
	    STRLEN len;
	    const char * const tmps = SvPV_const(final, len);
d1076 2
a1077 2
	    SV *sv = sv_mortalcopy(left);
	    SvPV_force_nolen(sv);
d1080 1
a1080 1
	        if (strEQ(SvPVX_const(sv),tmps))
d1089 1
a1089 1
	SV * const targ = PAD_SV(cUNOP->op_first->op_targ);
d1098 1
a1098 1
		GV * const gv = gv_fetchpv(".", TRUE, SVt_PV);
d1108 1
a1108 1
	    sv_catpvn(targ, "E0", 2);
d1118 1
a1118 1
static const char * const context_name[] = {
d1129 1
a1129 1
S_dopoptolabel(pTHX_ const char *label)
d1132 1
d1135 1
a1135 1
	register const PERL_CONTEXT * const cx = &cxstack[i];
d1149 2
a1150 1
	    if ( !cx->blk_loop.label || strNE(label, cx->blk_loop.label) ) {
d1165 1
a1165 1
    const I32 gimme = block_gimme();
d1172 3
a1174 1
    const I32 cxix = dopoptosub(cxstack_ix);
d1195 3
a1197 1
    const I32 cxix = dopoptosub(cxstack_ix);
d1213 1
a1213 1
S_dopoptosub_at(pTHX_ const PERL_CONTEXT *cxstk, I32 startingblock)
d1216 1
d1218 1
a1218 1
	register const PERL_CONTEXT * const cx = &cxstk[i];
d1236 1
d1238 1
a1238 1
	register const PERL_CONTEXT *cx = &cxstack[i];
d1254 1
d1256 1
a1256 1
	register const PERL_CONTEXT * const cx = &cxstack[i];
d1280 1
d1285 1
a1285 1
        register PERL_CONTEXT *cx = &cxstack[cxstack_ix];
a1310 1
    PERL_UNUSED_VAR(optype);
d1328 2
d1332 1
d1334 1
d1338 3
a1340 3
                static const char prefix[] = "\t(in cleanup) ";
		SV * const err = ERRSV;
                const char *e = Nullch;
d1342 1
a1342 1
		    sv_setpvn(err,"",0);
d1344 2
a1345 3
		    STRLEN len;
		    e = SvPV_const(err, len);
		    e += len - msglen;
d1354 2
a1355 2
			const STRLEN start = SvCUR(err)-msglen-sizeof(prefix)+1;
			Perl_warner(aTHX_ packWARN(WARN_MISC), SvPVX_const(err)+start);
a1372 2
	    register PERL_CONTEXT *cx;
	    SV **newsp;
d1380 1
a1380 1
		    message = (char *)SvPVx_const(ERRSV, msglen);
d1400 1
a1400 1
		const char* msg = SvPVx_nolen_const(ERRSV);
d1408 1
a1408 1
	message = (char *)SvPVx_const(ERRSV, msglen);
d1447 4
a1450 3
    register const PERL_CONTEXT *cx;
    register const PERL_CONTEXT *ccstack = cxstack;
    const PERL_SI *top_si = PL_curstackinfo;
d1452 2
a1453 1
    const char *stashname;
d1473 1
a1473 2
	/* caller() should not report the automatic calls to &DB::sub */
	if (PL_DBsub && GvCV(PL_DBsub) && cxix >= 0 &&
d1483 1
a1483 1
        const I32 dbcxix = dopoptosub_at(ccstack, cxix - 1);
d1486 1
a1486 2
	/* caller() should not report the automatic calls to &DB::sub */
	if (PL_DBsub && GvCV(PL_DBsub) && dbcxix >= 0 && ccstack[dbcxix].blk_sub.cv == GvCV(PL_DBsub))
d1517 1
a1517 1
	    SV * const sv = NEWSV(49, 0);
d1560 2
a1561 2
	AV * const ary = cx->blk_sub.argarray;
	const int off = AvARRAY(ary) - AvALLOC(ary);
d1589 2
a1590 12
		  (old_warnings == pWARN_STD && PL_dowarn & G_WARN_ON)) {
	    /* Get the bit mask for $warnings::Bits{all}, because
	     * it could have been extended by warnings::register */
	    SV **bits_all;
	    HV *bits = get_hv("warnings::Bits", FALSE);
	    if (bits && (bits_all=hv_fetch(bits, "all", 3, FALSE))) {
		mask = newSVsv(*bits_all);
	    }
	    else {
		mask = newSVpvn(WARN_ALLstring, WARNsize) ;
	    }
	}
d1601 2
a1602 1
    const char *tmps;
d1607 2
a1608 2
	tmps = POPpconstx;
    sv_reset((char *)tmps, CopSTASH(PL_curcop));
d1633 1
a1633 1
	const I32 gimme = G_ARRAY;
d1655 6
a1660 18
	if (CvXSUB(cv)) {
	    CvDEPTH(cv)++;
	    PUSHMARK(SP);
	    (void)(*CvXSUB(cv))(aTHX_ cv);

	    CvDEPTH(cv)--;
	    FREETMPS;
	    LEAVE;
	    return NORMAL;
	} else {
	    push_return(PL_op->op_next);
	    PUSHBLOCK(cx, CXt_SUB, SP);
	    PUSHSUB_DB(cx);
	    CvDEPTH(cv)++;
	    SAVECOMPPAD();
	    PAD_SET_CUR_NOSAVE(CvPADLIST(cv), 1);
	    RETURNOP(CvSTART(cv));
	}
d1675 1
a1675 1
    const I32 gimme = GIMME_V;
a1725 2
	    SvGETMAGIC(sv);
	    SvGETMAGIC(right);
a1731 4
#ifdef DEBUGGING
		/* for correct -Dstv display */
		cx->blk_oldsp = sp - PL_stack_base;
#endif
d1734 1
d1736 2
a1737 2
		(void) SvPV_force_nolen(cx->blk_loop.iterlval);
		(void) SvPV_nolen_const(right);
d1741 2
a1742 2
	    cx->blk_loop.itermax = 0;
	    cx->blk_loop.iterix = AvFILL(cx->blk_loop.iterary) + 1;
d1750 2
a1751 2
	    cx->blk_loop.itermax = MARK - PL_stack_base + 1;
	    cx->blk_loop.iterix = cx->blk_oldsp + 1;
d1765 1
a1765 1
    const I32 gimme = GIMME_V;
a1786 1
    assert(CxTYPE(cx) == CXt_LOOP);
d1865 2
a1866 2
	    SV * const nsv = cx->blk_eval.old_namesv;
	    (void)hv_delete(GvHVn(PL_incgv), SvPVX_const(nsv), SvCUR(nsv), G_DISCARD);
d1924 1
a1924 1
	sv_setpvn(ERRSV,"",0);
a1941 1

a2012 2
    PERL_UNUSED_VAR(optype);
    PERL_UNUSED_VAR(gimme);
a2040 1
    PL_curcop = cx->blk_oldcop;
a2066 1
    PL_curcop = cx->blk_oldcop;
d2071 1
a2071 1
S_dofindlabel(pTHX_ OP *o, const char *label, OP **opstack, OP **oplimit)
d2073 1
d2075 1
a2075 1
    static const char too_deep[] = "Target of goto is too deeply nested";
a2090 1
	OP *kid;
d2131 3
a2133 3
    const char *label = 0;
    const bool do_dump = (PL_op->op_type == OP_DUMP);
    static const char must_have_label[] = "goto must have label";
d2135 1
d2137 2
a2138 1
	SV * const sv = POPs;
d2152 2
a2153 1
		const GV * const gv = CvGV(cv);
a2154 1
		    GV *autogv;
d2164 1
a2164 1
		    gv_efullname3(tmpstr, (GV *) gv, Nullch);
d2171 1
a2171 1
	    (void)SvREFCNT_inc(cv); /* avoid premature free during unwind */
d2179 2
a2180 7
	    SPAGAIN;
	    if (CxTYPE(cx) == CXt_EVAL) {
		if (CxREALEVAL(cx))
		    DIE(aTHX_ "Can't goto subroutine from an eval-string");
		else
		    DIE(aTHX_ "Can't goto subroutine from an eval-block");
	    }
d2184 1
a2184 1

d2204 1
d2206 1
a2206 1
		AV* const av = (AV*)PAD_SVl(0);
d2208 1
a2208 1
		AV* const av = GvAV(PL_defgv);
a2253 1

a2256 4

		    /* Put these at the bottom since the vars are set but not used */
		    PERL_UNUSED_VAR(newsp);
		    PERL_UNUSED_VAR(gimme);
d2294 1
a2294 2
		SAVECOMPPAD();
		PAD_SET_CUR_NOSAVE(padlist, CvDEPTH(cv));
d2313 1
a2313 1
			    SvPV_set(av, (char*)ary);
d2319 1
a2319 1
			    SvPV_set(av, (char*)ary);
d2342 1
a2342 1
		    SV * const sv = GvSV(PL_DBsub);
d2344 1
a2344 2

		    save_item(sv);
d2346 1
a2346 3
			const int type = SvTYPE(sv);
			if (type < SVt_PVIV && type != SVt_IV)
			    sv_upgrade(sv, SVt_PVIV);
d2348 2
a2349 1
			SvIV_set(sv, PTR2IV(cv)); /* Do it the quickest way */
d2351 1
d2365 1
a2365 1
	    label = SvPV_nolen_const(sv);
d2520 1
a2520 1
    const NV value = SvNVx(GvSV(cCOP->cop_gv));
d2544 2
a2545 1
	match = *(SvPVx_nolen_const(GvSV(cCOP->cop_gv))) & 255;
d2562 4
a2565 3
    const char *s = SvPVX_const(sv);
    const char * const send = SvPVX_const(sv) + SvCUR(sv);
    I32 line = 1;
d2568 1
a2568 2
	const char *t;
	SV * const tmpstr = NEWSV(85,0);
d2591 1
a2591 1
STATIC void
d2595 1
a2595 1
    return;
d2602 1
a2602 1
    OP * const oldop = PL_op;
d2664 1
a2664 1
    I32 gimme = G_VOID;
d2684 1
a2684 1
	SV * const sv = sv_newmortal();
a2738 3
    PERL_UNUSED_VAR(newsp);
    PERL_UNUSED_VAR(optype);

d2750 1
a2750 1
than in the scope of the debugger itself).
d2758 1
d2760 1
a2764 1
        I32 ix;
d2766 1
a2766 1
	    const PERL_CONTEXT *cx = &(si->si_cxstack[ix]);
d2768 1
a2768 1
		CV * const cv = cx->blk_sub.cv;
d2795 1
a2795 1
    OP * const saveop = PL_op;
d2846 1
a2846 1
	sv_setpvn(ERRSV,"",0);
d2851 2
a2852 2
	const char *msg;

a2865 2

	msg = SvPVx_nolen_const(ERRSV);
d2867 1
a2867 1
            const char* const msg = SvPVx_nolen_const(ERRSV);
d2872 2
d2880 1
a2890 1
	PERL_UNUSED_VAR(newsp);
d2918 1
a2918 1
	CV * const cv = get_cv("DB::postponed", FALSE);
a2944 17
S_check_type_and_open(pTHX_ const char *name, const char *mode)
{
    Stat_t st;
    int st_rc;
    st_rc = PerlLIO_stat(name, &st);
    if (st_rc < 0) {
       return Nullfp;
    }

    if(S_ISDIR(st.st_mode) || S_ISBLK(st.st_mode)) {
       Perl_die(aTHX_ "%s %s not allowed in require",
           S_ISDIR(st.st_mode) ? "Directory" : "Block device", name);
    }
    return PerlIO_open(name, mode);
}

STATIC PerlIO *
d2948 1
a2948 1
    const STRLEN namelen = strlen(name);
d2952 3
a2954 2
	SV * const pmcsv = Perl_newSVpvf(aTHX_ "%s%c", name, 'c');
	const char * const pmc = SvPV_nolen_const(pmcsv);
d2957 1
a2957 1
	    fp = check_type_and_open(name, mode);
a2959 1
	    Stat_t pmstat;
d2963 1
a2963 1
		fp = check_type_and_open(pmc, mode);
d2966 1
a2966 1
		fp = check_type_and_open(name, mode);
d2972 1
a2972 1
	fp = check_type_and_open(name, mode);
d2976 1
a2976 1
    return check_type_and_open(name, mode);
d2985 1
a2985 1
    const char *name;
d2987 1
a2987 1
    const char *tryname = Nullch;
d2990 1
a2990 1
    const I32 gimme = GIMME_V;
d2992 1
d3060 1
a3060 1
    name = SvPV_const(sv, len);
d3087 1
a3087 1
	AV * const ar = GvAVn(PL_incgv);
d3091 1
a3091 1
	if ((unixname = tounixspec((char *)name, Nullch)) != Nullch)
d3110 1
a3110 1
		    tryname = SvPVX_const(namesv);
d3218 1
a3218 1
		    const char *dir = SvPVx_nolen_const(dirsv);
d3226 1
a3226 1
#  ifdef VMS
d3228 1
a3228 1
		    if ((unixdir = tounixpath((char *)dir, Nullch)) == Nullch)
d3232 1
a3232 14
#  else
#    ifdef SYMBIAN
		    if (PL_origfilename[0] &&
			PL_origfilename[1] == ':' &&
			!(dir[0] && dir[1] == ':'))
		        Perl_sv_setpvf(aTHX_ namesv,
				       "%c:%s\\%s",
				       PL_origfilename[0],
				       dir, name);
		    else
		        Perl_sv_setpvf(aTHX_ namesv,
				       "%s\\%s",
				       dir, name);
#    else
d3234 1
a3234 2
#    endif
#  endif
d3237 1
a3237 1
		    tryname = SvPVX_const(namesv);
d3254 20
a3273 27
	    const char *msgstr = name;
	    if(errno == EMFILE) {
		SV * const msg = sv_2mortal(newSVpv(msgstr,0));
		sv_catpv(msg, ":  "); 
		sv_catpv(msg, Strerror(errno));
		msgstr = SvPV_nolen_const(msg);
	    } else {
	        if (namesv) {			/* did we lookup @@INC? */
		    SV * const msg = sv_2mortal(newSVpv(msgstr,0));
		    SV * const dirmsgsv = NEWSV(0, 0);
		    AV * const ar = GvAVn(PL_incgv);
		    I32 i;
		    sv_catpvn(msg, " in @@INC", 8);
		    if (instr(SvPVX_const(msg), ".h "))
		        sv_catpv(msg, " (change .h to .ph maybe?)");
		    if (instr(SvPVX_const(msg), ".ph "))
		        sv_catpv(msg, " (did you run h2ph?)");
		    sv_catpv(msg, " (@@INC contains:");
		    for (i = 0; i <= AvFILL(ar); i++) {
		        const char *dir = SvPVx_nolen_const(*av_fetch(ar, i, TRUE));
		        Perl_sv_setpvf(aTHX_ dirmsgsv, " %s", dir);
		        sv_catsv(msg, dirmsgsv);
		    }
		    sv_catpvn(msg, ")", 1);
		    SvREFCNT_dec(dirmsgsv);
		    msgstr = SvPV_nolen_const(msg);
		}    
d3286 5
a3290 6
    if (!hook_sv) {
	(void)hv_store(GvHVn(PL_incgv), name, len, newSVpv(CopFILE(&PL_compiling),0),0);
    } else {
	SV** const svp = hv_fetch(GvHVn(PL_incgv), name, len, 0);
	if (!svp)
	    (void)hv_store(GvHVn(PL_incgv), name, len, SvREFCNT_inc(hook_sv), 0 );
d3315 1
a3315 1
	SV * const datasv = filter_add(run_user_filter, Nullsv);
d3345 1
a3345 1

d3362 1
a3362 2
    const I32 gimme = GIMME_V;
    const I32 was = PL_sub_generation;
d3371 1
a3371 1
    if (!SvPV_const(sv,len))
d3382 1
a3382 1
	SV * const sv = sv_newmortal();
d3458 1
a3458 1
    const U8 save_flags = PL_op -> op_flags;
d3503 2
a3504 2
	SV * const nsv = cx->blk_eval.old_namesv;
	(void)hv_delete(GvHVn(PL_incgv), SvPVX_const(nsv), SvCUR(nsv), G_DISCARD);
d3511 1
a3511 1
	    sv_setpvn(ERRSV,"",0);
d3521 1
a3521 1
    const I32 gimme = GIMME_V;
d3531 1
a3531 1
    sv_setpvn(ERRSV,"",0);
a3549 1
    PERL_UNUSED_VAR(optype);
d3580 1
a3580 1
    sv_setpvn(ERRSV,"",0);
d3614 1
a3614 1
    Newx(fops, maxops, U32);
d3715 3
a3717 1
                    const char * const f = ++s;
d3734 3
a3736 1
                    const char * const f = ++s;
d3800 1
a3800 1
    if (unchopnum && repeat)
d3837 1
a3837 1
    const int filter_has_file = IoLINES(datasv);
d3906 1
a3906 1
S_path_is_absolute(pTHX_ const char *name)
a3920 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007 by Larry Wall and others
d41 1
a41 1
#define dopoptosub(plop)	dopoptosub_at(cxstack, (plop))
a44 1
    dVAR;
d63 5
a69 1
    dVAR;
a78 1
    dVAR;
d82 3
a84 2
    MAGIC *mg = NULL;
    regexp * re;
d87 3
a89 10
#if defined(USE_ITHREADS)
    if (pm->op_pmflags & PMf_KEEP && PM_GETRE(pm)) {
	if (PL_op->op_flags & OPf_STACKED) {
	    dMARK;
	    SP = MARK;
	}
	else
	    (void)POPs;
	RETURN;
    }
a90 22
    if (PL_op->op_flags & OPf_STACKED) {
	/* multiple args; concatentate them */
	dMARK; dORIGMARK;
	tmpstr = PAD_SV(ARGTARG);
	sv_setpvn(tmpstr, "", 0);
	while (++MARK <= SP) {
	    if (PL_amagic_generation) {
		SV *sv;
		if ((SvAMAGIC(tmpstr) || SvAMAGIC(*MARK)) &&
		    (sv = amagic_call(tmpstr, *MARK, concat_amg, AMGf_assign)))
		{
		   sv_setsv(tmpstr, sv);
		   continue;
		}
	    }
	    sv_catsv(tmpstr, *MARK);
	}
    	SvSETMAGIC(tmpstr);
	SP = ORIGMARK;
    }
    else
	tmpstr = POPs;
d93 1
a93 1
	SV * const sv = SvRV(tmpstr);
d98 1
a98 1
	regexp * const re = reg_temp_copy((regexp *)mg->mg_obj);
d100 1
a100 1
	PM_SETRE(pm, re);
d104 1
a104 2
	const char *t = SvOK(tmpstr) ? SvPV_const(tmpstr, len) : "";
	re = PM_GETRE(pm);
d107 3
a109 2
	if (!re || !re->precomp || re->prelen != (I32)len ||
	    memNE(re->precomp, t, len))
d111 3
a113 10
	    const regexp_engine *eng = re ? re->engine : NULL;
            U32 pm_flags = pm->op_pmflags & PMf_COMPILETIME;
	    if (re) {
	        ReREFCNT_dec(re);
		PM_SETRE(pm, NULL);	/* crucial if regcomp aborts */
	    } else if (PL_curcop->cop_hints_hash) {
	        SV *ptr = Perl_refcounted_he_fetch(aTHX_ PL_curcop->cop_hints_hash, 0,
				       "regcomp", 7, 0, 0);
                if (ptr && SvIOK(ptr) && SvIV(ptr))
                    eng = INT2PTR(regexp_engine*,SvIV(ptr));
a114 1

d118 1
d120 9
a128 7
		pm_flags |= RXf_UTF8;

 		if (eng) 
	        PM_SETRE(pm, CALLREGCOMP_ENG(eng, tmpstr, pm_flags));
		else
	        PM_SETRE(pm, CALLREGCOMP(tmpstr, pm_flags));

a132 2
    
    re = PM_GETRE(pm);
d137 1
a137 1
	    re->extflags |= RXf_TAINTED;
d139 1
a139 1
	    re->extflags &= ~RXf_TAINTED;
d145 4
d150 1
a150 4

#if !defined(USE_ITHREADS)
    /* can't change the optree at runtime either */
    /* PMf_KEEP is handled differently under threads to avoid these problems */
d153 2
d156 1
a157 1
#endif
a162 1
    dVAR;
d171 1
a171 1
    SV *nsv = NULL;
d176 1
a176 1
	PM_SETRE(pm,ReREFCNT_inc(rx));
a189 1
	FREETMPS; /* Prevent excess tmp stack */
d192 1
a192 1
	if (cx->sb_once || !CALLREGEXEC(rx, s, cx->sb_strend, orig,
d209 1
a209 8
#ifdef PERL_OLD_COPY_ON_WRITE
	    if (SvIsCOW(targ)) {
		sv_force_normal_flags(targ, SV_COW_DROP_PV);
	    } else
#endif
	    {
		SvPV_free(targ);
	    }
d215 2
a216 1
	    SvPV_set(dstr, NULL);
d227 1
d240 1
a240 1
    cx->sb_m = m = rx->offs[0].start + orig;
d247 1
a247 1
    cx->sb_s = rx->offs[0].end + orig;
d252 2
a253 1
	SvUPGRADE(sv, SVt_PVMG);
d255 2
a256 6
#ifdef PERL_OLD_COPY_ON_WRITE
	    if (SvIsCOW(sv))
		sv_force_normal_flags(sv, 0);
#endif
	    mg = sv_magicext(sv, NULL, PERL_MAGIC_regex_global, &PL_vtbl_mglob,
			     NULL, 0);
d267 1
a267 1
    RETURNOP(pm->op_pmstashstartu.op_pmreplstart);
a274 1
    PERL_UNUSED_CONTEXT;
a276 3
#ifdef PERL_OLD_COPY_ON_WRITE
	i = 7 + rx->nparens * 2;
#else
a277 1
#endif
d285 1
a285 1
    *p++ = PTR2UV(RX_MATCH_COPIED(rx) ? rx->subbeg : NULL);
a287 5
#ifdef PERL_OLD_COPY_ON_WRITE
    *p++ = PTR2UV(rx->saved_copy);
    rx->saved_copy = NULL;
#endif

d293 2
a294 2
	*p++ = (UV)rx->offs[i].start;
	*p++ = (UV)rx->offs[i].end;
a302 1
    PERL_UNUSED_CONTEXT;
d304 2
a305 1
    RX_MATCH_COPY_FREE(rx);
a308 7
#ifdef PERL_OLD_COPY_ON_WRITE
    if (rx->saved_copy)
	SvREFCNT_dec (rx->saved_copy);
    rx->saved_copy = INT2PTR(SV*,*p);
    *p++ = 0;
#endif

d314 2
a315 2
	rx->offs[i].start = (I32)(*p++);
	rx->offs[i].end = (I32)(*p++);
a322 1
    PERL_UNUSED_CONTEXT;
d329 1
a329 1
	    PoisonFree(*p, 1, sizeof(*p));
a332 5
#ifdef PERL_OLD_COPY_ON_WRITE
	if (p[1]) {
	    SvREFCNT_dec (INT2PTR(SV*,p[1]));
	}
#endif
d334 1
a334 1
	*rsp = NULL;
d340 1
a340 1
    dVAR; dSP; dMARK; dORIGMARK;
d346 2
a347 2
    register SV *sv = NULL;
    const char *item = NULL;
d351 3
a353 3
    bool chopspace = (strchr(PL_chopset, ' ') != NULL);
    const char *chophere = NULL;
    char *linemark = NULL;
d361 2
a362 2
    SV * nsv = NULL;
    OP * parseres = NULL;
d680 1
a680 1
		    while (isSPACE(*s))
d683 1
a683 1
		sv_chop(sv,s);
d742 1
a742 3
	    fmt = (const char *)
		((arg & 256) ?
		 "%#0*.*" PERL_PRIfldbl : "%0*.*" PERL_PRIfldbl);
d744 1
a744 3
	    fmt = (const char *)
		((arg & 256) ?
		 "%#0*.*f"              : "%0*.*f");
d750 1
a750 2
 	    fmt = (const char *)
		((arg & 256) ? "%#*.*" PERL_PRIfldbl : "%*.*" PERL_PRIfldbl);
d752 1
a752 2
            fmt = (const char *)
		((arg & 256) ? "%#*.*f"              : "%*.*f");
d775 1
a775 1
		my_snprintf(t, SvLEN(PL_formtarget) - (t - SvPVX(PL_formtarget)), fmt, (int) fieldsize, (int) arg & 255, value);
d818 1
a818 1
		    while (isSPACE(*s) && (s < send))
d854 1
a854 1
    dVAR; dSP;
d869 2
a870 4
    if (PL_op->op_private & OPpGREP_LEX)
	SAVESPTR(PAD_SVl(PL_op->op_targ));
    else
	SAVE_DEFSV;
d876 1
a876 4
    if (PL_op->op_private & OPpGREP_LEX)
	PAD_SVl(PL_op->op_targ) = src;
    else
	DEFSV = src;
d884 5
d891 1
a891 1
    dVAR; dSP;
d966 2
a967 9
	    if (PL_op->op_private & OPpGREP_LEX) {
		SV* sv = sv_newmortal();
		sv_setiv(sv, items);
		PUSHs(sv);
	    }
	    else {
		dTARGET;
		XPUSHi(items);
	    }
d982 1
a982 4
	if (PL_op->op_private & OPpGREP_LEX)
	    PAD_SVl(PL_op->op_targ) = src;
	else
	    DEFSV = src;
a991 1
    dVAR;
a1001 1
    dVAR;
d1017 1
a1017 1
		GV * const gv = gv_fetchpvs(".", GV_ADD|GV_NOTQUAL, SVt_PV);
d1056 1
a1056 1
    dVAR; dSP;
d1061 4
a1064 2
	SvGETMAGIC(left);
	SvGETMAGIC(right);
d1113 1
a1113 1
		GV * const gv = gv_fetchpvs(".", GV_ADD|GV_NOTQUAL, SVt_PV);
d1123 1
a1123 1
	    sv_catpvs(targ, "E0");
d1140 1
a1140 3
    "format",
    "given",
    "when"
a1145 1
    dVAR;
a1155 2
	case CXt_GIVEN:
	case CXt_WHEN:
a1174 2


a1177 1
    dVAR;
a1184 1
    dVAR;
a1205 1
    dVAR;
d1216 6
a1223 1
    dVAR;
a1242 1
    dVAR;
a1259 1
    dVAR;
a1282 41
STATIC I32
S_dopoptogiven(pTHX_ I32 startingblock)
{
    dVAR;
    I32 i;
    for (i = startingblock; i >= 0; i--) {
	register const PERL_CONTEXT *cx = &cxstack[i];
	switch (CxTYPE(cx)) {
	default:
	    continue;
	case CXt_GIVEN:
	    DEBUG_l( Perl_deb(aTHX_ "(Found given #%ld)\n", (long)i));
	    return i;
	case CXt_LOOP:
	    if (CxFOREACHDEF(cx)) {
		DEBUG_l( Perl_deb(aTHX_ "(Found foreach #%ld)\n", (long)i));
		return i;
	    }
	}
    }
    return i;
}

STATIC I32
S_dopoptowhen(pTHX_ I32 startingblock)
{
    dVAR;
    I32 i;
    for (i = startingblock; i >= 0; i--) {
	register const PERL_CONTEXT *cx = &cxstack[i];
	switch (CxTYPE(cx)) {
	default:
	    continue;
	case CXt_WHEN:
	    DEBUG_l( Perl_deb(aTHX_ "(Found when #%ld)\n", (long)i));
	    return i;
	}
    }
    return i;
}

a1285 1
    dVAR;
a1321 1
    dVAR;
d1327 2
a1328 3
	Perl_warn(aTHX_ "%"SVf, SVfARG(err));
    if (PL_parser)
	++PL_parser->error_count;
d1332 1
a1332 1
Perl_die_where(pTHX_ const char *message, STRLEN msglen)
a1333 2
    dVAR;

d1342 1
a1342 1
		const char *e = NULL;
d1350 1
a1350 1
			e = NULL;
d1385 2
a1386 2
		    message = SvPVx_const(ERRSV, msglen);
		PerlIO_write(Perl_error_log, (const char *)"panic: die ", 11);
d1405 1
a1405 4
                const char* const msg = SvPVx_nolen_const(ERRSV);
		SV * const nsv = cx->blk_eval.old_namesv;
                (void)hv_store(GvHVn(PL_incgv), SvPVX_const(nsv), SvCUR(nsv),
                               &PL_sv_undef, 0);
d1409 1
a1409 2
	    assert(CxTYPE(cx) == CXt_EVAL);
	    return cx->blk_eval.retop;
d1413 1
a1413 1
	message = SvPVx_const(ERRSV, msglen);
d1423 1
a1423 1
    dVAR; dSP; dPOPTOPssrl;
d1430 18
a1449 1
    dVAR;
d1508 1
a1508 1
    EXTEND(SP, 11);
d1519 1
a1519 1
	GV * const cvgv = CvGV(ccstack[cxix].blk_sub.cv);
d1522 2
a1523 2
	    SV * const sv = newSV(0);
	    gv_efullname3(sv, cvgv, NULL);
d1528 1
a1528 1
	    PUSHs(sv_2mortal(newSVpvs("(unknown)")));
d1533 1
a1533 1
	PUSHs(sv_2mortal(newSVpvs("(eval)")));
d1569 3
a1571 2
	    GV* const tmpgv = gv_fetchpvs("DB::args", GV_ADD, SVt_PVAV);
	    PL_dbargs = GvAV(gv_AVadd(tmpgv));
d1584 2
a1585 1
    PUSHs(sv_2mortal(newSViv(CopHINTS_get(cx->blk_oldcop))));
d1588 1
a1588 1
	STRLEN * const old_warnings = cx->blk_oldcop->cop_warnings ;
d1598 2
a1599 2
	    HV * const bits = get_hv("warnings::Bits", FALSE);
	    if (bits && (bits_all=hv_fetchs(bits, "all", FALSE))) {
d1607 1
a1607 1
            mask = newSVpvn((char *) (old_warnings + 1), old_warnings[0]);
a1609 6

    PUSHs(cx->blk_oldcop->cop_hints_hash ?
	  sv_2mortal(newRV_noinc(
	    (SV*)Perl_refcounted_he_chain_2hv(aTHX_
					      cx->blk_oldcop->cop_hints_hash)))
	  : &PL_sv_undef);
a1614 1
    dVAR;
d1616 7
a1622 2
    const char * const tmps = (MAXARG < 1) ? (const char *)"" : POPpconstx;
    sv_reset(tmps, CopSTASH(PL_curcop));
d1627 5
a1635 1
    dVAR;
d1645 1
d1649 1
a1649 2
	GV * const gv = PL_DBgv;
	register CV * const cv = GvCV(gv);
d1651 2
d1669 1
a1669 1
	if (CvISXSUB(cv)) {
d1673 1
d1678 2
a1679 2
	}
	else {
a1681 1
	    cx->blk_sub.retop = PL_op->op_next;
d1692 5
d1699 1
a1699 1
    dVAR; dSP; dMARK;
d1703 1
a1703 1
    U16 cxtype = CXt_LOOP | CXp_FOREACH;
d1711 8
a1719 5
	if (PL_op->op_private & OPpLVAL_INTRO) { /* for my $x (...) */
	    SvPADSTALE_off(PAD_SVl(PL_op->op_targ));
	    SAVESETSVFLAGS(PAD_SVl(PL_op->op_targ),
		    SVs_PADSTALE, SVs_PADSTALE);
	}
d1730 1
a1730 1
	GV * const gv = (GV*)POPs;
d1733 1
a1733 1
	*svp = newSV(0);
a1738 3
    if (PL_op->op_private & OPpITER_DEF)
	cxtype |= CXp_FOR_DEF;

d1751 1
a1751 1
	    SV * const right = (SV*)cx->blk_loop.iterary;
d1794 1
a1794 1
    dVAR; dSP;
d1810 1
a1810 1
    dVAR; dSP;
d1824 1
a1824 1
	NOOP;
d1851 2
a1852 1
    dVAR; dSP; dMARK;
a1860 1
    OP *retop;
d1862 7
a1868 8
    const I32 cxix = dopoptosub(cxstack_ix);

    if (cxix < 0) {
	if (CxMULTICALL(cxstack)) { /* In this case we must be in a
				     * sort block, which is a CXt_NULL
				     * not a CXt_SUB */
	    dounwind(0);
	    PL_stack_base[1] = *PL_stack_sp;
a1871 2
	else
	    DIE(aTHX_ "Can't return outside a subroutine");
d1873 4
a1879 11
    if (CxMULTICALL(&cxstack[cxix])) {
	gimme = cxstack[cxix].blk_gimme;
	if (gimme == G_VOID)
	    PL_stack_sp = PL_stack_base;
	else if (gimme == G_SCALAR) {
	    PL_stack_base[1] = *PL_stack_sp;
	    PL_stack_sp = PL_stack_base + 1;
	}
	return 0;
    }

a1883 1
	retop = cx->blk_sub.retop;
a1889 1
	retop = cx->blk_eval.retop;
d1899 1
a1899 1
	    DIE(aTHX_ "%"SVf" did not return a true value", SVfARG(nsv));
a1903 1
	retop = cx->blk_sub.retop;
d1951 1
a1951 1
	sv = NULL;
d1957 1
a1957 1
    return retop;
d1962 1
a1962 1
    dVAR; dSP;
d1972 1
a1972 1
    SV *sv = NULL;
d1995 1
a1995 1
	nextop = cx->blk_loop.my_op->op_lastop->op_next;
d1999 1
a1999 1
	nextop = cx->blk_sub.retop;
d2003 1
a2003 1
	nextop = cx->blk_eval.retop;
d2007 1
a2007 1
	nextop = cx->blk_sub.retop;
a2052 1
    dVAR;
d2077 1
a2077 1
    return CX_LOOP_NEXTOP_GET(cx);
a2081 1
    dVAR;
a2084 1
    OP* redo_op;
a2098 8
    redo_op = cxstack[cxix].blk_loop.my_op->op_redoop;
    if (redo_op->op_type == OP_ENTER) {
	/* pop one less context to avoid $x being freed in while (my $x..) */
	cxstack_ix++;
	assert(CxTYPE(&cxstack[cxstack_ix]) == CXt_BLOCK);
	redo_op = redo_op->op_next;
    }

d2104 1
a2104 1
    return redo_op;
a2109 1
    dVAR;
d2154 6
d2162 2
a2163 2
    dVAR; dSP;
    OP *retop = NULL;
d2168 1
a2168 1
    const char *label = NULL;
d2199 2
a2200 2
		    gv_efullname3(tmpstr, gv, NULL);
		    DIE(aTHX_ "Goto undefined subroutine &%"SVf"", SVfARG(tmpstr));
d2206 1
a2206 1
	    SvREFCNT_inc_simple_void(cv); /* avoid premature free during unwind */
a2214 1
	    /* ban goto in eval: see <20050521150056.GC20213@@iabyn.com> */
a2220 2
	    else if (CxMULTICALL(cx))
		DIE(aTHX_ "Can't goto subroutine from a sort sub (or similar callback)");
d2228 1
d2231 1
d2239 1
a2239 1
		    AvREIFY_only(av);
d2243 4
a2246 1
	    else if (CvISXSUB(cv)) {	/* put GvAV(defgv) back onto stack */
d2248 1
d2264 1
a2264 4
	    if (CvISXSUB(cv)) {
		OP* const retop = cx->blk_sub.retop;
		SV **newsp;
		I32 gimme;
d2270 18
d2289 13
a2301 6
		/* XS subs don't have a CxSUB, so pop it */
		POPBLOCK(cx, PL_curpm);
		/* Push a mark for the start of arglist */
		PUSHMARK(mark);
		PUTBACK;
		(void)(*CvXSUB(cv))(aTHX_ cv);
d2303 1
a2303 1
		return retop;
d2306 1
a2306 1
		AV* const padlist = CvPADLIST(cv);
d2314 1
a2314 1
		cx->blk_sub.olddepth = CvDEPTH(cv);
d2318 1
a2318 1
		    SvREFCNT_inc_simple_void_NN(cv);
d2322 14
a2335 1
		    pad_push(padlist, CvDEPTH(cv));
d2337 1
d2340 1
d2342 1
d2344 2
a2345 1
		    AV* const av = (AV*)PAD_SVl(0);
d2347 1
d2349 2
a2350 1
		    GvAV(PL_defgv) = (AV*)SvREFCNT_inc_simple(av);
d2355 1
a2355 1
			SV **ary = AvALLOC(av);
d2358 1
a2358 1
			    AvARRAY(av) = ary;
d2364 1
a2364 1
			    AvARRAY(av) = ary;
d2383 22
a2404 8
		    Perl_get_db_sub(aTHX_ NULL, cv);
		    if (PERLDB_GOTO) {
			CV * const gotocv = get_cv("DB::goto", FALSE);
			if (gotocv) {
			    PUSHMARK( PL_stack_sp );
			    call_sv((SV*)gotocv, G_SCALAR | G_NODEBUG);
			    PL_stack_sp--;
			}
d2424 1
a2424 1
	OP *gotoprobe = NULL;
d2427 1
a2427 1
	PERL_CONTEXT *last_eval_cx = NULL;
d2431 1
a2431 1
	PL_lastgotoprobe = NULL;
d2459 1
a2459 1
		if (CvDEPTH(cx->blk_sub.cv) && !CxMULTICALL(cx)) {
d2511 1
a2511 1
	    OP * const oldop = PL_op;
a2542 1
    dVAR;
a2556 5
#ifdef PERL_MAD
    /* KLUDGE: disable exit 0 in BEGIN blocks when we're just compiling */
    if (anum || !(PL_minus_c && PL_madskills))
	my_exit(anum);
#else
a2557 1
#endif
d2562 40
d2613 1
a2613 1
	SV * const tmpstr = newSV_type(SVt_PVMG);
d2615 1
d2628 15
a2645 1
    dVAR;
d2648 2
d2657 12
d2670 1
d2673 1
a2673 3
	assert(cxstack_ix >= 0);
	assert(CxTYPE(&cxstack[cxstack_ix]) == CXt_EVAL);
	cxstack[cxstack_ix].blk_eval.cur_top_env = PL_top_env;
d2675 2
a2676 1
	CALLRUNOPS(aTHX);
d2680 1
a2680 11

	/* NB XXX we rely on the old popped CxEVAL still being at the top
	 * of the stack; the way die_where() currently works, this
	 * assumption is valid. In theory The cur_top_env value should be
	 * returned in another global, the way retop (aka PL_restartop)
	 * is. */
	assert(CxTYPE(&cxstack[cxstack_ix+1]) == CXt_EVAL);

	if (PL_restartop
	    && cxstack[cxstack_ix+1].blk_eval.cur_top_env == PL_top_env)
	{
d2685 3
d2697 1
a2697 1
    return NULL;
d2701 1
a2701 1
Perl_sv_compile_2op(pTHX_ SV *sv, OP** startop, const char *code, PAD** padp)
d2706 1
a2706 2
    /* FIXME - how much of this code is common with pp_entereval?  */
    dVAR; dSP;				/* Make POPBLOCK work. */
d2712 1
d2717 1
a2717 2
    CV* runcv = NULL;	/* initialise to avoid compiler warnings */
    STRLEN len;
d2720 1
a2720 1
    lex_start(sv, NULL, FALSE);
a2733 1
	len = SvCUR(sv);
d2736 1
a2736 2
	len = my_snprintf(tmpbuf, sizeof(tbuf), "_<(%.10s_eval %lu)", code,
			  (unsigned long)++PL_evalseq);
d2746 2
a2747 2
    safestr = savepvn(tmpbuf, len);
    SAVEDELETE(PL_defstash, safestr, len);
d2764 1
a2764 1
    PUSHEVAL(cx, 0, NULL);
d2767 1
a2767 1
	(void) doeval(G_SCALAR, startop, runcv, PL_curcop->cop_seq);
d2769 1
a2769 1
	(void) doeval(G_SCALAR, startop, PL_compcv, PL_cop_seqmax);
d2777 1
a2777 1
    *padp = (AV*)SvREFCNT_inc_simple(PL_comppad);
d2780 1
a2780 1
	CopHINTS_set(&PL_compiling, PL_hints);
d2787 1
a2787 1
    return PL_eval_start;
a2805 1
    dVAR;
a2834 3
 * Returns a bool indicating whether the compile was successful; if so,
 * PL_eval_start contains the first op of the compiled ocde; otherwise,
 * pushes undef (also croaks if startop != NULL).
d2837 2
a2838 1
STATIC bool
d2841 1
a2841 1
    dVAR; dSP;
d2851 2
a2852 1
    PL_compcv = (CV*)newSV_type(SVt_PVCV);
d2857 6
d2864 1
a2864 1
    CvOUTSIDE(PL_compcv) = (CV*)SvREFCNT_inc_simple(outside);
a2868 1
    PL_op = NULL; /* avoid PL_op and PL_curpad referring to different CVs */
d2871 1
a2871 2
    if (!PL_madskills)
	SAVEMORTALIZESV(PL_compcv);	/* must remain until end of current statement */
a2878 1
    /* XXX:ajgo do we really need to alloc an AV for begin/checkunit */
d2882 1
a2882 8
    SAVESPTR(PL_unitcheckav);
    PL_unitcheckav = newAV();
    SAVEFREESV(PL_unitcheckav);

#ifdef PERL_MAD
    SAVEBOOL(PL_madskills);
    PL_madskills = 0;
#endif
d2886 2
a2887 1
    PL_eval_root = NULL;
d2889 2
a2890 2
    CopARYBASE_set(PL_curcop, 0);
    if (saveop && (saveop->op_type != OP_REQUIRE) && (saveop->op_flags & OPf_SPECIAL))
d2894 1
a2894 1
    if (yyparse() || PL_parser->error_count || !PL_eval_root) {
d2896 1
a2896 1
	PERL_CONTEXT *cx = &cxstack[cxstack_ix];
d2903 1
a2903 1
	    PL_eval_root = NULL;
d2909 1
d2916 3
a2918 5
	    const SV * const nsv = cx->blk_eval.old_namesv;
	    (void)hv_store(GvHVn(PL_incgv), SvPVX_const(nsv), SvCUR(nsv),
                          &PL_sv_undef, 0);
	    Perl_croak(aTHX_ "%sCompilation failed in require",
		       *msg ? msg : "Unknown error\n");
d2928 1
a2928 1
	        sv_setpvs(ERRSV, "Compilation error");
d2931 6
d2938 1
a2938 3
	PUSHs(&PL_sv_undef);
	PUTBACK;
	return FALSE;
d2964 1
a2964 1
    if (PERLDB_INTER && saveop && saveop->op_type == OP_REQUIRE) {
a2974 3
    if (PL_unitcheckav)
	call_list(PL_scopestack_ix, PL_unitcheckav);

d2980 7
a2986 1
    PL_parser->lex_state = LEX_NOTPARSING;	/* $^S needs this. */
d2988 1
a2988 2
    PUTBACK;
    return TRUE;
d2992 1
a2992 1
S_check_type_and_open(pTHX_ const char *name)
d2995 5
a2999 1
    const int st_rc = PerlLIO_stat(name, &st);
d3001 3
a3003 2
    if (st_rc < 0 || S_ISDIR(st.st_mode) || S_ISBLK(st.st_mode)) {
	return NULL;
d3005 1
a3005 2

    return PerlIO_open(name, PERL_SCRIPT_MODE);
a3007 1
#ifndef PERL_DISABLE_PMC
d3009 1
a3009 1
S_doopen_pm(pTHX_ const char *name, const STRLEN namelen)
d3011 2
d3015 3
a3017 3
    if (namelen > 3 && memEQs(name + namelen - 3, 3, ".pm")) {
	SV *const pmcsv = newSV(namelen + 2);
	char *const pmc = SvPVX(pmcsv);
a3018 5

	memcpy(pmc, name, namelen);
	pmc[namelen] = 'c';
	pmc[namelen + 1] = '\0';

d3020 1
a3020 1
	    fp = check_type_and_open(name);
d3023 9
a3031 1
	    fp = check_type_and_open(pmc);
d3036 1
a3036 1
	fp = check_type_and_open(name);
a3038 1
}
d3040 1
a3040 1
#  define doopen_pm(name, namelen) check_type_and_open(name)
d3042 1
d3046 1
a3046 1
    dVAR; dSP;
d3051 3
a3053 7
    char * unixname;
    STRLEN unixlen;
#ifdef VMS
    int vms_unixname = 0;
#endif
    const char *tryname = NULL;
    SV *namesv = NULL;
d3055 1
d3057 4
a3060 5
    PerlIO *tryrsfp = NULL;
    SV *filter_cache = NULL;
    SV *filter_state = NULL;
    SV *filter_sub = NULL;
    SV *hook_sv = NULL;
d3065 27
a3091 16
    if ( (SvNIOKp(sv) || SvVOK(sv)) && PL_op->op_type != OP_DOFILE) {
	if ( SvVOK(sv) && ckWARN(WARN_PORTABLE) ) {	/* require v5.6.1 */
	    HV * hinthv = GvHV(PL_hintgv);
	    SV ** ptr = NULL;
	    if (hinthv) ptr = hv_fetchs(hinthv, "v_string", FALSE);
	    if ( !(ptr && *ptr && SvIOK(*ptr) && SvIV(*ptr)) )
		Perl_warner(aTHX_ packWARN(WARN_PORTABLE),
                        "v-string in use/require non-portable");
	}
	sv = new_version(sv);
	if (!sv_derived_from(PL_patchlevel, "version"))
	    upg_version(PL_patchlevel, TRUE);
	if (cUNOP->op_first->op_type == OP_CONST && cUNOP->op_first->op_private & OPpCONST_NOVER) {
	    if ( vcmp(sv,PL_patchlevel) <= 0 )
		DIE(aTHX_ "Perls since %"SVf" too modern--this is %"SVf", stopped",
		    SVfARG(vnormal(sv)), SVfARG(vnormal(PL_patchlevel)));
d3093 19
a3111 19
	else {
	    if ( vcmp(sv,PL_patchlevel) > 0 ) {
		I32 first = 0;
		AV *lav;
		SV * const req = SvRV(sv);
		SV * const pv = *hv_fetchs((HV*)req, "original", FALSE);

		/* get the left hand term */
		lav = (AV *)SvRV(*hv_fetchs((HV*)req, "version", FALSE));

		first  = SvIV(*av_fetch(lav,0,0));
		if (   first > (int)PERL_REVISION    /* probably 'use 6.0' */
		    || hv_exists((HV*)req, "qv", 2 ) /* qv style */
		    || av_len(lav) > 1               /* FP with > 3 digits */
		    || strstr(SvPVX(pv),".0")        /* FP with leading 0 */
		   ) {
		    DIE(aTHX_ "Perl %"SVf" required--this is only "
		    	"%"SVf", stopped", SVfARG(vnormal(req)),
			SVfARG(vnormal(PL_patchlevel)));
d3113 5
a3117 17
		else { /* probably 'use 5.10' or 'use 5.8' */
		    SV * hintsv = newSV(0);
		    I32 second = 0;

		    if (av_len(lav)>=1) 
			second = SvIV(*av_fetch(lav,1,0));

		    second /= second >= 600  ? 100 : 10;
		    hintsv = Perl_newSVpvf(aTHX_ "v%d.%d.%d",
		    	(int)first, (int)second,0);
		    upg_version(hintsv, TRUE);

		    DIE(aTHX_ "Perl %"SVf" required (did you mean %"SVf"?)"
		    	"--this is only %"SVf", stopped",
			SVfARG(vnormal(req)),
			SVfARG(vnormal(hintsv)),
			SVfARG(vnormal(PL_patchlevel)));
d3120 1
a3121 26

        /* We do this only with use, not require. */
	if (PL_compcv &&
	  /* If we request a version >= 5.6.0, then v-string are OK
	     so set $^H{v_string} to suppress the v-string warning */
	    vcmp(sv, sv_2mortal(upg_version(newSVnv(5.006), FALSE))) >= 0) {
	  HV * hinthv = GvHV(PL_hintgv);
	  if( hinthv ) {
	      SV *hint = newSViv(1);
	      (void)hv_stores(hinthv, "v_string", hint);
	      /* This will call through to Perl_magic_sethint() which in turn
		 sets PL_hints correctly.  */
	      SvSETMAGIC(hint);
	  }
	  /* If we request a version >= 5.9.5, load feature.pm with the
	   * feature bundle that corresponds to the required version. */
	  if (vcmp(sv, sv_2mortal(upg_version(newSVnv(5.009005), FALSE))) >= 0) {
	    SV *const importsv = vnormal(sv);
	    *SvPVX_mutable(importsv) = ':';
	    ENTER;
	    Perl_load_module(aTHX_ 0, newSVpvs("feature"), NULL, importsv, NULL);
	    LEAVE;
	  }
	}

	RETPUSHYES;
d3127 4
a3130 33


#ifdef VMS
    /* The key in the %ENV hash is in the syntax of file passed as the argument
     * usually this is in UNIX format, but sometimes in VMS format, which
     * can result in a module being pulled in more than once.
     * To prevent this, the key must be stored in UNIX format if the VMS
     * name can be translated to UNIX.
     */
    if ((unixname = tounixspec(name, NULL)) != NULL) {
	unixlen = strlen(unixname);
	vms_unixname = 1;
    }
    else
#endif
    {
        /* if not VMS or VMS name can not be translated to UNIX, pass it
	 * through.
	 */
	unixname = (char *) name;
	unixlen = len;
    }
    if (PL_op->op_type == OP_REQUIRE) {
	SV * const * const svp = hv_fetch(GvHVn(PL_incgv),
					  unixname, unixlen, 0);
	if ( svp ) {
	    if (*svp != &PL_sv_undef)
		RETPUSHYES;
	    else
		DIE(aTHX_ "Attempt to reload %s aborted.\n"
			    "Compilation failed in require", unixname);
	}
    }
d3136 1
a3136 1
	tryrsfp = doopen_pm(name, len);
d3145 1
a3145 1
	    tryrsfp = doopen_pm(newname, strlen(newname));
d3153 2
a3154 1
	if (vms_unixname)
d3157 1
a3157 2
	    namesv = newSV(0);
	    sv_upgrade(namesv, SVt_PV);
d3159 1
a3159 1
		SV * const dirsv = *av_fetch(ar, i, TRUE);
a3160 2
		if (SvTIED_mg((SV*)ar, PERL_MAGIC_tied))
		    mg_get(dirsv);
a3162 1
		    SV **svp;
d3174 1
a3174 1
		    tryrsfp = NULL;
a3189 5
		    /* Adjust file name if the hook has set an %INC entry */
		    svp = hv_fetch(GvHVn(PL_incgv), name, len, 0);
		    if (svp)
			tryname = SvPVX_const(*svp);

a3196 10
			if (SvROK(arg) && (SvTYPE(SvRV(arg)) <= SVt_PVLV)
			    && !isGV_with_GP(SvRV(arg))) {
			    filter_cache = SvRV(arg);
			    SvREFCNT_inc_simple_void_NN(filter_cache);

			    if (i < count) {
				arg = SP[i++];
			    }
			}

d3202 1
a3202 1
			    IO * const io = GvIO((GV *)arg);
d3208 16
a3223 2
				if (IoOFP(io) && IoOFP(io) != IoIFP(io)) {
				    PerlIO_close(IoOFP(io));
a3224 2
				IoIFP(io) = NULL;
				IoOFP(io) = NULL;
d3234 1
a3234 1
			    SvREFCNT_inc_simple_void_NN(filter_sub);
d3238 1
a3238 1
				SvREFCNT_inc_simple_void(filter_state);
a3239 1
			}
d3241 4
a3244 3
			if (!tryrsfp && (filter_cache || filter_sub)) {
			    tryrsfp = PerlIO_open(BIT_BUCKET,
						  PERL_SCRIPT_MODE);
d3259 3
a3261 3
		    if (filter_cache) {
			SvREFCNT_dec(filter_cache);
			filter_cache = NULL;
d3265 1
a3265 1
			filter_state = NULL;
d3269 1
a3269 1
			filter_sub = NULL;
d3281 1
a3281 10
		    const char *dir;
		    STRLEN dirlen;

		    if (SvOK(dirsv)) {
			dir = SvPV_const(dirsv, dirlen);
		    } else {
			dir = "";
			dirlen = 0;
		    }

d3291 1
a3291 1
		    if ((unixdir = tounixpath(dir, NULL)) == NULL)
d3296 1
a3296 1
#    ifdef __SYMBIAN32__
d3309 1
a3309 20
		    /* The equivalent of		    
		       Perl_sv_setpvf(aTHX_ namesv, "%s/%s", dir, name);
		       but without the need to parse the format string, or
		       call strlen on either pointer, and with the correct
		       allocation up front.  */
		    {
			char *tmp = SvGROW(namesv, dirlen + len + 2);

			memcpy(tmp, dir, dirlen);
			tmp +=dirlen;
			*tmp++ = '/';
			/* name came from an SV, so it will have a '\0' at the
			   end that we can copy as part of this memcpy().  */
			memcpy(tmp, name, len + 1);

			SvCUR_set(namesv, dirlen + len + 1);

			/* Don't even actually have to turn SvPOK_on() as we
			   access it directly with SvPVX() below.  */
		    }
d3315 1
a3315 1
		    tryrsfp = doopen_pm(tryname, SvCUR(namesv));
a3320 3
		    else if (errno == EMFILE)
			/* no point in trying other paths if out of handles */
			break;
d3333 3
a3335 3
		SV * const msg
		    = sv_2mortal(Perl_newSVpvf(aTHX_ "%s:   %s", msgstr,
					       Strerror(errno)));
d3339 2
d3343 6
a3348 9
		    SV * const msg = sv_2mortal(Perl_newSVpvf(aTHX_ 
			"%s in @@INC%s%s (@@INC contains:",
			msgstr,
			(instr(msgstr, ".h ")
			 ? " (change .h to .ph maybe?)" : ""),
			(instr(msgstr, ".ph ")
			 ? " (did you run h2ph?)" : "")
							      ));
		    
d3350 3
a3352 2
			sv_catpvs(msg, " ");
			sv_catsv(msg, *av_fetch(ar, i, TRUE));
d3354 2
a3355 1
		    sv_catpvs(msg, ")");
d3368 1
a3368 1
    /* name is never assigned to again, so len is still strlen(name)  */
d3371 1
a3371 2
	(void)hv_store(GvHVn(PL_incgv),
		       unixname, unixlen, newSVpv(CopFILE(&PL_compiling),0),0);
d3373 1
a3373 1
	SV** const svp = hv_fetch(GvHVn(PL_incgv), unixname, unixlen, 0);
d3375 1
a3375 2
	    (void)hv_store(GvHVn(PL_incgv),
			   unixname, unixlen, SvREFCNT_inc_simple(hook_sv), 0 );
d3380 3
a3382 1
    lex_start(NULL, tryrsfp, TRUE);
d3384 1
d3387 1
a3387 1
    SAVECOMPILEWARNINGS();
d3392 2
d3396 2
d3399 2
a3400 2
    if (filter_sub || filter_cache) {
	SV * const datasv = filter_add(S_run_user_filter, NULL);
d3402 1
a3404 1
	IoFMT_GV(datasv) = (GV *)filter_cache;
d3408 1
d3410 1
a3410 2
    PUSHEVAL(cx, name, NULL);
    cx->blk_eval.retop = PL_op->op_next;
d3416 8
d3427 1
a3427 1
    PL_encoding = NULL;
d3429 1
a3429 4
    if (doeval(gimme, NULL, NULL, PL_curcop->cop_seq))
	op = DOCATCH(PL_eval_start);
    else
	op = PL_op->op_next;
d3437 5
d3444 1
a3444 1
    dVAR; dSP;
d3446 1
a3446 1
    SV *sv;
d3453 1
a3453 1
    bool ok;
a3455 8
    HV *saved_hh = NULL;
    const char * const fakestr = "_<(eval )";
    const int fakelen = 9 + 1;
    
    if (PL_op->op_private & OPpEVAL_HAS_HH) {
	saved_hh = (HV*) SvREFCNT_inc(POPs);
    }
    sv = POPs;
d3457 2
a3458 1
    TAINT_IF(SvTAINTED(sv));
d3462 1
a3462 1
    lex_start(sv, NULL, FALSE);
d3468 2
a3469 2
	SV * const temp_sv = sv_newmortal();
	Perl_sv_setpvf(aTHX_ temp_sv, "_<(eval %lu)[%s:%"IVdf"]",
d3472 1
a3472 2
	tmpbuf = SvPVX(temp_sv);
	len = SvCUR(temp_sv);
d3475 1
a3475 1
	len = my_snprintf(tmpbuf, sizeof(tbuf), "_<(eval %lu)", (unsigned long)++PL_evalseq);
d3485 2
a3486 2
    safestr = savepvn(tmpbuf, len);
    SAVEDELETE(PL_defstash, safestr, len);
d3489 13
a3501 12
    if (saved_hh)
	GvHV(PL_hintgv) = saved_hh;
    SAVECOMPILEWARNINGS();
    PL_compiling.cop_warnings = DUP_WARNINGS(PL_curcop->cop_warnings);
    if (PL_compiling.cop_hints_hash) {
	Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
    }
    PL_compiling.cop_hints_hash = PL_curcop->cop_hints_hash;
    if (PL_compiling.cop_hints_hash) {
	HINTS_REFCNT_LOCK;
	PL_compiling.cop_hints_hash->refcounted_he_refcnt++;
	HINTS_REFCNT_UNLOCK;
d3510 1
d3512 1
a3512 2
    PUSHEVAL(cx, 0, NULL);
    cx->blk_eval.retop = PL_op->op_next;
d3517 1
a3517 1
	save_lines(CopFILEAV(&PL_compiling), PL_parser->linestr);
d3519 9
a3527 1
    ok = doeval(gimme, NULL, runcv, seq);
d3529 2
a3530 3
	&& ok) {
	/* Copy in anything fake and short. */
	my_strlcpy(safestr, fakestr, fakelen);
d3532 1
a3532 1
    return ok ? DOCATCH(PL_eval_start) : PL_op->op_next;
d3537 1
a3537 1
    dVAR; dSP;
d3549 1
a3549 1
    retop = cx->blk_eval.retop;
d3591 1
a3591 1
	retop = Perl_die(aTHX_ "%"SVf" did not return a true value", SVfARG(nsv));
d3603 1
a3603 4
/* Common code for Perl_call_sv and Perl_fold_constants, put here to keep it
   close to the related Perl_create_eval_scope.  */
void
Perl_delete_eval_scope(pTHX)
d3605 1
a3605 3
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
d3607 1
a3607 10
    I32 optype;
	
    POPBLOCK(cx,newpm);
    POPEVAL(cx);
    PL_curpm = newpm;
    LEAVE;
    PERL_UNUSED_VAR(newsp);
    PERL_UNUSED_VAR(gimme);
    PERL_UNUSED_VAR(optype);
}
a3608 8
/* Common-ish code salvaged from Perl_call_sv and pp_entertry, because it was
   also needed by Perl_fold_constants.  */
PERL_CONTEXT *
Perl_create_eval_scope(pTHX_ U32 flags)
{
    PERL_CONTEXT *cx;
    const I32 gimme = GIMME_V;
	
d3612 2
a3613 1
    PUSHBLOCK(cx, (CXt_EVAL|CXp_TRYBLOCK), PL_stack_sp);
d3617 2
a3618 15
    if (flags & G_KEEPERR)
	PL_in_eval |= EVAL_KEEPERR;
    else
	sv_setpvn(ERRSV,"",0);
    if (flags & G_FAKINGEVAL) {
	PL_eval_root = PL_op; /* Only needed so that goto works right. */
    }
    return cx;
}
    
PP(pp_entertry)
{
    dVAR;
    PERL_CONTEXT * const cx = create_eval_scope(0);
    cx->blk_eval.retop = cLOGOP->op_other->op_next;
d3624 2
a3625 1
    dVAR; dSP;
d3628 1
d3635 1
a3641 1
	register SV **mark;
a3656 1
	register SV **mark;
d3668 1
a3668 566
    RETURN;
}

PP(pp_entergiven)
{
    dVAR; dSP;
    register PERL_CONTEXT *cx;
    const I32 gimme = GIMME_V;
    
    ENTER;
    SAVETMPS;

    if (PL_op->op_targ == 0) {
	SV ** const defsv_p = &GvSV(PL_defgv);
	*defsv_p = newSVsv(POPs);
	SAVECLEARSV(*defsv_p);
    }
    else
    	sv_setsv(PAD_SV(PL_op->op_targ), POPs);

    PUSHBLOCK(cx, CXt_GIVEN, SP);
    PUSHGIVEN(cx);

    RETURN;
}

PP(pp_leavegiven)
{
    dVAR; dSP;
    register PERL_CONTEXT *cx;
    I32 gimme;
    SV **newsp;
    PMOP *newpm;
    PERL_UNUSED_CONTEXT;

    POPBLOCK(cx,newpm);
    assert(CxTYPE(cx) == CXt_GIVEN);

    SP = newsp;
    PUTBACK;

    PL_curpm = newpm;   /* pop $1 et al */

    LEAVE;

    return NORMAL;
}

/* Helper routines used by pp_smartmatch */
STATIC PMOP *
S_make_matcher(pTHX_ regexp *re)
{
    dVAR;
    PMOP *matcher = (PMOP *) newPMOP(OP_MATCH, OPf_WANT_SCALAR | OPf_STACKED);
    PM_SETRE(matcher, ReREFCNT_inc(re));
    
    SAVEFREEOP((OP *) matcher);
    ENTER; SAVETMPS;
    SAVEOP();
    return matcher;
}

STATIC bool
S_matcher_matches_sv(pTHX_ PMOP *matcher, SV *sv)
{
    dVAR;
    dSP;
    
    PL_op = (OP *) matcher;
    XPUSHs(sv);
    PUTBACK;
    (void) pp_match();
    SPAGAIN;
    return (SvTRUEx(POPs));
}

STATIC void
S_destroy_matcher(pTHX_ PMOP *matcher)
{
    dVAR;
    PERL_UNUSED_ARG(matcher);
    FREETMPS;
    LEAVE;
}

/* Do a smart match */
PP(pp_smartmatch)
{
    return do_smartmatch(NULL, NULL);
}

/* This version of do_smartmatch() implements the
 * table of smart matches that is found in perlsyn.
 */
STATIC OP *
S_do_smartmatch(pTHX_ HV *seen_this, HV *seen_other)
{
    dVAR;
    dSP;
    
    SV *e = TOPs;	/* e is for 'expression' */
    SV *d = TOPm1s;	/* d is for 'default', as in PL_defgv */
    SV *This, *Other;	/* 'This' (and Other to match) to play with C++ */
    MAGIC *mg;
    regexp *this_regex, *other_regex;

#   define NOT_EMPTY_PROTO(cv) (!SvPOK(cv) || SvCUR(cv) == 0)

#   define SM_REF(type) ( \
	   (SvROK(d) && (SvTYPE(This = SvRV(d)) == SVt_##type) && (Other = e)) \
	|| (SvROK(e) && (SvTYPE(This = SvRV(e)) == SVt_##type) && (Other = d)))

#   define SM_CV_NEP   /* Find a code ref without an empty prototype */ \
	((SvROK(d) && (SvTYPE(This = SvRV(d)) == SVt_PVCV)		\
	    && NOT_EMPTY_PROTO(This) && (Other = e))			\
	|| (SvROK(e) && (SvTYPE(This = SvRV(e)) == SVt_PVCV)		\
	    && NOT_EMPTY_PROTO(This) && (Other = d)))

#   define SM_REGEX ( \
	   (SvROK(d) && SvMAGICAL(This = SvRV(d))			\
	&& (mg = mg_find(This, PERL_MAGIC_qr))				\
	&& (this_regex = (regexp *)mg->mg_obj)				\
	&& (Other = e))							\
    ||									\
	   (SvROK(e) && SvMAGICAL(This = SvRV(e))			\
	&& (mg = mg_find(This, PERL_MAGIC_qr))				\
	&& (this_regex = (regexp *)mg->mg_obj)				\
	&& (Other = d))	)
	

#   define SM_OTHER_REF(type) \
	(SvROK(Other) && SvTYPE(SvRV(Other)) == SVt_##type)

#   define SM_OTHER_REGEX (SvROK(Other) && SvMAGICAL(SvRV(Other))	\
	&& (mg = mg_find(SvRV(Other), PERL_MAGIC_qr))			\
	&& (other_regex = (regexp *)mg->mg_obj))
	

#   define SM_SEEN_THIS(sv) hv_exists_ent(seen_this, \
	sv_2mortal(newSViv(PTR2IV(sv))), 0)

#   define SM_SEEN_OTHER(sv) hv_exists_ent(seen_other, \
	sv_2mortal(newSViv(PTR2IV(sv))), 0)

    tryAMAGICbinSET(smart, 0);
    
    SP -= 2;	/* Pop the values */

    /* Take care only to invoke mg_get() once for each argument. 
     * Currently we do this by copying the SV if it's magical. */
    if (d) {
	if (SvGMAGICAL(d))
	    d = sv_mortalcopy(d);
    }
    else
	d = &PL_sv_undef;

    assert(e);
    if (SvGMAGICAL(e))
	e = sv_mortalcopy(e);

    if (SM_CV_NEP) {
	I32 c;
	
	if ( SM_OTHER_REF(PVCV) && NOT_EMPTY_PROTO(SvRV(Other)) )
	{
	    if (This == SvRV(Other))
		RETPUSHYES;
	    else
		RETPUSHNO;
	}
	
	ENTER;
	SAVETMPS;
	PUSHMARK(SP);
	PUSHs(Other);
	PUTBACK;
	c = call_sv(This, G_SCALAR);
	SPAGAIN;
	if (c == 0)
	    PUSHs(&PL_sv_no);
	else if (SvTEMP(TOPs))
	    SvREFCNT_inc_void(TOPs);
	FREETMPS;
	LEAVE;
	RETURN;
    }
    else if (SM_REF(PVHV)) {
	if (SM_OTHER_REF(PVHV)) {
	    /* Check that the key-sets are identical */
	    HE *he;
	    HV *other_hv = (HV *) SvRV(Other);
	    bool tied = FALSE;
	    bool other_tied = FALSE;
	    U32 this_key_count  = 0,
	        other_key_count = 0;
	    
	    /* Tied hashes don't know how many keys they have. */
	    if (SvTIED_mg(This, PERL_MAGIC_tied)) {
		tied = TRUE;
	    }
	    else if (SvTIED_mg((SV *) other_hv, PERL_MAGIC_tied)) {
		HV * const temp = other_hv;
		other_hv = (HV *) This;
		This  = (SV *) temp;
		tied = TRUE;
	    }
	    if (SvTIED_mg((SV *) other_hv, PERL_MAGIC_tied))
		other_tied = TRUE;
	    
	    if (!tied && HvUSEDKEYS((HV *) This) != HvUSEDKEYS(other_hv))
	    	RETPUSHNO;

	    /* The hashes have the same number of keys, so it suffices
	       to check that one is a subset of the other. */
	    (void) hv_iterinit((HV *) This);
	    while ( (he = hv_iternext((HV *) This)) ) {
	    	I32 key_len;
		char * const key = hv_iterkey(he, &key_len);
	    	
	    	++ this_key_count;
	    	
	    	if(!hv_exists(other_hv, key, key_len)) {
	    	    (void) hv_iterinit((HV *) This);	/* reset iterator */
		    RETPUSHNO;
	    	}
	    }
	    
	    if (other_tied) {
		(void) hv_iterinit(other_hv);
		while ( hv_iternext(other_hv) )
		    ++other_key_count;
	    }
	    else
		other_key_count = HvUSEDKEYS(other_hv);
	    
	    if (this_key_count != other_key_count)
		RETPUSHNO;
	    else
		RETPUSHYES;
	}
	else if (SM_OTHER_REF(PVAV)) {
	    AV * const other_av = (AV *) SvRV(Other);
	    const I32 other_len = av_len(other_av) + 1;
	    I32 i;

	    for (i = 0; i < other_len; ++i) {
		SV ** const svp = av_fetch(other_av, i, FALSE);
		char *key;
		STRLEN key_len;

		if (svp) {	/* ??? When can this not happen? */
		    key = SvPV(*svp, key_len);
		    if (hv_exists((HV *) This, key, key_len))
		        RETPUSHYES;
		}
	    }
	    RETPUSHNO;
	}
	else if (SM_OTHER_REGEX) {
	    PMOP * const matcher = make_matcher(other_regex);
	    HE *he;

	    (void) hv_iterinit((HV *) This);
	    while ( (he = hv_iternext((HV *) This)) ) {
		if (matcher_matches_sv(matcher, hv_iterkeysv(he))) {
		    (void) hv_iterinit((HV *) This);
		    destroy_matcher(matcher);
		    RETPUSHYES;
		}
	    }
	    destroy_matcher(matcher);
	    RETPUSHNO;
	}
	else {
	    if (hv_exists_ent((HV *) This, Other, 0))
		RETPUSHYES;
	    else
		RETPUSHNO;
	}
    }
    else if (SM_REF(PVAV)) {
	if (SM_OTHER_REF(PVAV)) {
	    AV *other_av = (AV *) SvRV(Other);
	    if (av_len((AV *) This) != av_len(other_av))
		RETPUSHNO;
	    else {
	    	I32 i;
	    	const I32 other_len = av_len(other_av);

		if (NULL == seen_this) {
		    seen_this = newHV();
		    (void) sv_2mortal((SV *) seen_this);
		}
		if (NULL == seen_other) {
		    seen_this = newHV();
		    (void) sv_2mortal((SV *) seen_other);
		}
		for(i = 0; i <= other_len; ++i) {
		    SV * const * const this_elem = av_fetch((AV *)This, i, FALSE);
		    SV * const * const other_elem = av_fetch(other_av, i, FALSE);

		    if (!this_elem || !other_elem) {
			if (this_elem || other_elem)
			    RETPUSHNO;
		    }
		    else if (SM_SEEN_THIS(*this_elem)
			 || SM_SEEN_OTHER(*other_elem))
		    {
			if (*this_elem != *other_elem)
			    RETPUSHNO;
		    }
		    else {
			(void)hv_store_ent(seen_this,
				sv_2mortal(newSViv(PTR2IV(*this_elem))),
				&PL_sv_undef, 0);
			(void)hv_store_ent(seen_other,
				sv_2mortal(newSViv(PTR2IV(*other_elem))),
				&PL_sv_undef, 0);
			PUSHs(*this_elem);
			PUSHs(*other_elem);
			
			PUTBACK;
			(void) do_smartmatch(seen_this, seen_other);
			SPAGAIN;
			
			if (!SvTRUEx(POPs))
			    RETPUSHNO;
		    }
		}
		RETPUSHYES;
	    }
	}
	else if (SM_OTHER_REGEX) {
	    PMOP * const matcher = make_matcher(other_regex);
	    const I32 this_len = av_len((AV *) This);
	    I32 i;

	    for(i = 0; i <= this_len; ++i) {
		SV * const * const svp = av_fetch((AV *)This, i, FALSE);
		if (svp && matcher_matches_sv(matcher, *svp)) {
		    destroy_matcher(matcher);
		    RETPUSHYES;
		}
	    }
	    destroy_matcher(matcher);
	    RETPUSHNO;
	}
	else if (SvIOK(Other) || SvNOK(Other)) {
	    I32 i;

	    for(i = 0; i <= AvFILL((AV *) This); ++i) {
		SV * const * const svp = av_fetch((AV *)This, i, FALSE);
		if (!svp)
		    continue;
		
		PUSHs(Other);
		PUSHs(*svp);
		PUTBACK;
		if (CopHINTS_get(PL_curcop) & HINT_INTEGER)
		    (void) pp_i_eq();
		else
		    (void) pp_eq();
		SPAGAIN;
		if (SvTRUEx(POPs))
		    RETPUSHYES;
	    }
	    RETPUSHNO;
	}
	else if (SvPOK(Other)) {
	    const I32 this_len = av_len((AV *) This);
	    I32 i;

	    for(i = 0; i <= this_len; ++i) {
		SV * const * const svp = av_fetch((AV *)This, i, FALSE);
		if (!svp)
		    continue;
		
		PUSHs(Other);
		PUSHs(*svp);
		PUTBACK;
		(void) pp_seq();
		SPAGAIN;
		if (SvTRUEx(POPs))
		    RETPUSHYES;
	    }
	    RETPUSHNO;
	}
    }
    else if (!SvOK(d) || !SvOK(e)) {
	if (!SvOK(d) && !SvOK(e))
	    RETPUSHYES;
	else
	    RETPUSHNO;
    }
    else if (SM_REGEX) {
	PMOP * const matcher = make_matcher(this_regex);

	PUTBACK;
	PUSHs(matcher_matches_sv(matcher, Other)
	    ? &PL_sv_yes
	    : &PL_sv_no);
	destroy_matcher(matcher);
	RETURN;
    }
    else if (SM_REF(PVCV)) {
	I32 c;
	/* This must be a null-prototyped sub, because we
	   already checked for the other kind. */
	
	ENTER;
	SAVETMPS;
	PUSHMARK(SP);
	PUTBACK;
	c = call_sv(This, G_SCALAR);
	SPAGAIN;
	if (c == 0)
	    PUSHs(&PL_sv_undef);
	else if (SvTEMP(TOPs))
	    SvREFCNT_inc_void(TOPs);

	if (SM_OTHER_REF(PVCV)) {
	    /* This one has to be null-proto'd too.
	       Call both of 'em, and compare the results */
	    PUSHMARK(SP);
	    c = call_sv(SvRV(Other), G_SCALAR);
	    SPAGAIN;
	    if (c == 0)
		PUSHs(&PL_sv_undef);
	    else if (SvTEMP(TOPs))
		SvREFCNT_inc_void(TOPs);
	    FREETMPS;
	    LEAVE;
	    PUTBACK;
	    return pp_eq();
	}
	
	FREETMPS;
	LEAVE;
	RETURN;
    }
    else if ( ((SvIOK(d) || SvNOK(d)) && (This = d) && (Other = e))
         ||   ((SvIOK(e) || SvNOK(e)) && (This = e) && (Other = d)) )
    {
	if (SvPOK(Other) && !looks_like_number(Other)) {
	    /* String comparison */
	    PUSHs(d); PUSHs(e);
	    PUTBACK;
	    return pp_seq();
	}
	/* Otherwise, numeric comparison */
	PUSHs(d); PUSHs(e);
	PUTBACK;
	if (CopHINTS_get(PL_curcop) & HINT_INTEGER)
	    (void) pp_i_eq();
	else
	    (void) pp_eq();
	SPAGAIN;
	if (SvTRUEx(POPs))
	    RETPUSHYES;
	else
	    RETPUSHNO;
    }
    
    /* As a last resort, use string comparison */
    PUSHs(d); PUSHs(e);
    PUTBACK;
    return pp_seq();
}

PP(pp_enterwhen)
{
    dVAR; dSP;
    register PERL_CONTEXT *cx;
    const I32 gimme = GIMME_V;

    /* This is essentially an optimization: if the match
       fails, we don't want to push a context and then
       pop it again right away, so we skip straight
       to the op that follows the leavewhen.
    */
    if ((0 == (PL_op->op_flags & OPf_SPECIAL)) && !SvTRUEx(POPs))
	return cLOGOP->op_other->op_next;

    ENTER;
    SAVETMPS;

    PUSHBLOCK(cx, CXt_WHEN, SP);
    PUSHWHEN(cx);

    RETURN;
}

PP(pp_leavewhen)
{
    dVAR; dSP;
    register PERL_CONTEXT *cx;
    I32 gimme;
    SV **newsp;
    PMOP *newpm;

    POPBLOCK(cx,newpm);
    assert(CxTYPE(cx) == CXt_WHEN);

    SP = newsp;
    PUTBACK;

    PL_curpm = newpm;   /* pop $1 et al */

    LEAVE;
    return NORMAL;
}

PP(pp_continue)
{
    dVAR;   
    I32 cxix;
    register PERL_CONTEXT *cx;
    I32 inner;
    
    cxix = dopoptowhen(cxstack_ix); 
    if (cxix < 0)   
	DIE(aTHX_ "Can't \"continue\" outside a when block");
    if (cxix < cxstack_ix)
        dounwind(cxix);
    
    /* clear off anything above the scope we're re-entering */
    inner = PL_scopestack_ix;
    TOPBLOCK(cx);
    if (PL_scopestack_ix < inner)
        leave_scope(PL_scopestack[PL_scopestack_ix]);
    PL_curcop = cx->blk_oldcop;
    return cx->blk_givwhen.leave_op;
}

PP(pp_break)
{
    dVAR;   
    I32 cxix;
    register PERL_CONTEXT *cx;
    I32 inner;
    
    cxix = dopoptogiven(cxstack_ix); 
    if (cxix < 0) {
	if (PL_op->op_flags & OPf_SPECIAL)
	    DIE(aTHX_ "Can't use when() outside a topicalizer");
	else
	    DIE(aTHX_ "Can't \"break\" outside a given block");
    }
    if (CxFOREACH(&cxstack[cxix]) && (0 == (PL_op->op_flags & OPf_SPECIAL)))
	DIE(aTHX_ "Can't \"break\" in a loop topicalizer");

    if (cxix < cxstack_ix)
        dounwind(cxix);
    
    /* clear off anything above the scope we're re-entering */
    inner = PL_scopestack_ix;
    TOPBLOCK(cx);
    if (PL_scopestack_ix < inner)
        leave_scope(PL_scopestack[PL_scopestack_ix]);
    PL_curcop = cx->blk_oldcop;

    if (CxFOREACH(cx))
	return CX_LOOP_NEXTOP_GET(cx);
    else
	return cx->blk_givwhen.leave_op;
d3676 2
a3677 2
    register char * const send = s + len;
    register char *base = NULL;
d3684 1
a3684 1
    U32 *linepc = NULL;
d3699 1
a3699 1
    base = NULL;
d3880 1
a3880 1
    sv_magic(sv, NULL, PERL_MAGIC_fm, NULL, 0);
d3917 1
a3917 1
S_run_user_filter(pTHX_ int idx, SV *buf_sv, int maxlen)
d3919 1
a3919 2
    dVAR;
    SV * const datasv = FILTER_DATA(idx);
d3921 4
a3924 12
    SV * const filter_state = (SV *)IoTOP_GV(datasv);
    SV * const filter_sub = (SV *)IoBOTTOM_GV(datasv);
    int status = 0;
    SV *upstream;
    STRLEN got_len;
    const char *got_p = NULL;
    const char *prune_from = NULL;
    bool read_from_cache = FALSE;
    STRLEN umaxlen;

    assert(maxlen >= 0);
    umaxlen = maxlen;
d3928 1
a3928 1
       for PL_parser->error_count == 0.)  Solaris doesn't segfault --
a3930 47
    if (IoFMT_GV(datasv)) {
	SV *const cache = (SV *)IoFMT_GV(datasv);
	if (SvOK(cache)) {
	    STRLEN cache_len;
	    const char *cache_p = SvPV(cache, cache_len);
	    STRLEN take = 0;

	    if (umaxlen) {
		/* Running in block mode and we have some cached data already.
		 */
		if (cache_len >= umaxlen) {
		    /* In fact, so much data we don't even need to call
		       filter_read.  */
		    take = umaxlen;
		}
	    } else {
		const char *const first_nl =
		    (const char *)memchr(cache_p, '\n', cache_len);
		if (first_nl) {
		    take = first_nl + 1 - cache_p;
		}
	    }
	    if (take) {
		sv_catpvn(buf_sv, cache_p, take);
		sv_chop(cache, cache_p + take);
		/* Definately not EOF  */
		return 1;
	    }

	    sv_catsv(buf_sv, cache);
	    if (umaxlen) {
		umaxlen -= cache_len;
	    }
	    SvOK_off(cache);
	    read_from_cache = TRUE;
	}
    }

    /* Filter API says that the filter appends to the contents of the buffer.
       Usually the buffer is "", so the details don't matter. But if it's not,
       then clearly what it contains is already filtered by this filter, so we
       don't want to pass it in a second time.
       I'm going to use a mortal in case the upstream filter croaks.  */
    upstream = ((SvOK(buf_sv) && sv_len(buf_sv)) || SvGMAGICAL(buf_sv))
	? sv_newmortal() : buf_sv;
    SvUPGRADE(upstream, SVt_PV);
	
d3932 1
a3932 1
	status = FILTER_READ(idx+1, upstream, 0);
d3935 1
a3935 1
    if (filter_sub && status >= 0) {
d3944 1
a3944 1
	DEFSV = upstream;
d3946 1
a3946 1
	PUSHs(sv_2mortal(newSViv(0)));
d3957 1
a3957 1
		status = SvIV(out);
d3966 5
a3970 25
    if(SvOK(upstream)) {
	got_p = SvPV(upstream, got_len);
	if (umaxlen) {
	    if (got_len > umaxlen) {
		prune_from = got_p + umaxlen;
	    }
	} else {
	    const char *const first_nl =
		(const char *)memchr(got_p, '\n', got_len);
	    if (first_nl && first_nl + 1 < got_p + got_len) {
		/* There's a second line here... */
		prune_from = first_nl + 1;
	    }
	}
    }
    if (prune_from) {
	/* Oh. Too long. Stuff some in our cache.  */
	STRLEN cached_len = got_p + got_len - prune_from;
	SV *cache = (SV *)IoFMT_GV(datasv);

	if (!cache) {
	    IoFMT_GV(datasv) = (GV*) (cache = newSV(got_len - umaxlen));
	} else if (SvOK(cache)) {
	    /* Cache should be empty.  */
	    assert(!SvCUR(cache));
a3971 26

	sv_setpvn(cache, prune_from, cached_len);
	/* If you ask for block mode, you may well split UTF-8 characters.
	   "If it breaks, you get to keep both parts"
	   (Your code is broken if you  don't put them back together again
	   before something notices.) */
	if (SvUTF8(upstream)) {
	    SvUTF8_on(cache);
	}
	SvCUR_set(upstream, got_len - cached_len);
	/* Can't yet be EOF  */
	if (status == 0)
	    status = 1;
    }

    /* If they are at EOF but buf_sv has something in it, then they may never
       have touched the SV upstream, so it may be undefined.  If we naively
       concatenate it then we get a warning about use of uninitialised value.
    */
    if (upstream != buf_sv && (SvOK(upstream) || SvGMAGICAL(upstream))) {
	sv_catsv(buf_sv, upstream);
    }

    if (status <= 0) {
	IoLINES(datasv) = 0;
	SvREFCNT_dec(IoFMT_GV(datasv));
d3974 1
a3974 1
	    IoTOP_GV(datasv) = NULL;
d3978 1
a3978 1
	    IoBOTTOM_GV(datasv) = NULL;
d3980 1
a3980 1
	filter_del(S_run_user_filter);
d3982 2
a3983 7
    if (status == 0 && read_from_cache) {
	/* If we read some data from the cache (and by getting here it implies
	   that we emptied the cache) then we aren't yet at EOF, and mustn't
	   report that to our caller.  */
	return 1;
    }
    return status;
d3989 1
a3989 1
S_path_is_absolute(const char *name)
d3993 1
a3993 1
	|| (*name == ':')
d3996 1
a3996 1
			     (name[1] == '.' && name[2] == '/')))
a3997 1
	 )
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 6
a17 8
 *      Now far ahead the Road has gone,
 *          And I must follow, if I can,
 *      Pursuing it with eager feet,
 *          Until it joins some larger way
 *      Where many paths and errands meet.
 *          And whither then?  I cannot say.
 *
 *     [Bilbo on p.35 of _The Lord of the Rings_, I/i: "A Long-Expected Party"]
d81 1
a81 1
    REGEXP * re;
d99 1
a99 1
	sv_setpvs(tmpstr, "");
d134 2
a135 2
	if (!re || !RX_PRECOMP(re) || RX_PRELEN(re) != (I32)len ||
	    memNE(RX_PRECOMP(re), t, len))
d137 1
a137 1
	    const regexp_engine *eng = re ? RX_ENGINE(re) : NULL;
d170 1
a170 1
	    RX_EXTFLAGS(re) |= RXf_TAINTED;
d172 1
a172 1
	    RX_EXTFLAGS(re) &= ~RXf_TAINTED;
d176 1
a176 1
    if (!RX_PRELEN(PM_GETRE(pm)) && PL_curpm)
d221 1
d224 1
a224 1
	if (CxONCE(cx) || !CALLREGEXEC(rx, s, cx->sb_strend, orig,
d257 1
a257 1
	    mPUSHi(saviters - 1);
d270 1
a270 1
    if (RX_MATCH_COPIED(rx) && RX_SUBBEG(rx) != orig) {
d273 1
a273 1
	cx->sb_orig = orig = RX_SUBBEG(rx);
d277 1
a277 1
    cx->sb_m = m = RX_OFFS(rx)[0].start + orig;
d284 1
a284 1
    cx->sb_s = RX_OFFS(rx)[0].end + orig;
d288 1
d298 4
a301 1
	mg->mg_len = m - orig;
a314 2

    PERL_ARGS_ASSERT_RXRES_SAVE;
d317 1
a317 1
    if (!p || p[1] < RX_NPARENS(rx)) {
d319 1
a319 1
	i = 7 + RX_NPARENS(rx) * 2;
d321 1
a321 1
	i = 6 + RX_NPARENS(rx) * 2;
d330 1
a330 1
    *p++ = PTR2UV(RX_MATCH_COPIED(rx) ? RX_SUBBEG(rx) : NULL);
d338 1
a338 1
    *p++ = RX_NPARENS(rx);
d340 5
a344 5
    *p++ = PTR2UV(RX_SUBBEG(rx));
    *p++ = (UV)RX_SUBLEN(rx);
    for (i = 0; i <= RX_NPARENS(rx); ++i) {
	*p++ = (UV)RX_OFFS(rx)[i].start;
	*p++ = (UV)RX_OFFS(rx)[i].end;
a352 2

    PERL_ARGS_ASSERT_RXRES_RESTORE;
d366 1
a366 1
    RX_NPARENS(rx) = *p++;
d368 5
a372 5
    RX_SUBBEG(rx) = INT2PTR(char*,*p++);
    RX_SUBLEN(rx) = (I32)(*p++);
    for (i = 0; i <= RX_NPARENS(rx); ++i) {
	RX_OFFS(rx)[i].start = (I32)(*p++);
	RX_OFFS(rx)[i].end = (I32)(*p++);
a379 2

    PERL_ARGS_ASSERT_RXRES_FREE;
d427 1
a492 1
		f += arg;
d753 2
d756 2
a758 1
		const bool oneline = fpc[-1] == FF_LINESNGL;
a759 1
		item_is_utf8 = DO_UTF8(sv);
d761 2
d764 1
a764 1
		    STRLEN to_copy = itemsize;
a765 3
		    const U8 *source = (const U8 *) s;
		    U8 *tmp = NULL;

d771 1
a771 1
				to_copy = s - SvPVX_const(sv) - 1;
d777 1
a777 1
				    to_copy--;
d783 12
a794 23
		    if (targ_is_utf8 && !item_is_utf8) {
			source = tmp = bytes_to_utf8(source, &to_copy);
			SvCUR_set(PL_formtarget,
				  t - SvPVX_const(PL_formtarget));
		    } else {
			if (item_is_utf8 && !targ_is_utf8) {
			    /* Upgrade targ to UTF8, and then we reduce it to
			       a problem we have a simple solution for.  */
			    SvCUR_set(PL_formtarget,
				      t - SvPVX_const(PL_formtarget));
			    targ_is_utf8 = TRUE;
			    /* Don't need get magic.  */
			    sv_utf8_upgrade_flags(PL_formtarget, 0);
			} else {
			    SvCUR_set(PL_formtarget,
				      t - SvPVX_const(PL_formtarget));
			}

			/* Easy. They agree.  */
			assert (item_is_utf8 == targ_is_utf8);
		    }
		    SvGROW(PL_formtarget,
			   SvCUR(PL_formtarget) + to_copy + fudge + 1);
d796 2
a797 17

		    Copy(source, t, to_copy, char);
		    t += to_copy;
		    SvCUR_set(PL_formtarget, SvCUR(PL_formtarget) + to_copy);
		    if (item_is_utf8) {
			if (SvGMAGICAL(sv)) {
			    /* Mustn't call sv_pos_b2u() as it does a second
			       mg_get(). Is this a bug? Do we need a _flags()
			       variant? */
			    itemsize = utf8_length(source, source + itemsize);
			} else {
			    sv_pos_b2u(sv, &itemsize);
			}
			assert(!tmp);
		    } else if (tmp) {
			Safefree(tmp);
		    }
d929 1
a929 1
	    mXPUSHi(0);
d950 1
a950 1
	DEFSV_set(src);
d1061 1
a1061 1
	    DEFSV_set(src);
d1118 1
a1118 1
	sv_setpvs(TARG, "");
a1229 2
    PERL_ARGS_ASSERT_DOPOPTOLABEL;

d1238 2
d1298 2
a1299 2
    if (CxLVAL(cxstack + cxix) && CvLVALUE(cxstack[cxix].blk_sub.cv))
	return CxLVAL(cxstack + cxix);
a1308 3

    PERL_ARGS_ASSERT_DOPOPTOSUB_AT;

a1450 3

    PERL_ARGS_ASSERT_QERROR;

d1476 1
a1476 1
		    sv_setpvs(err,"");
d1490 1
a1490 2
			Perl_warner(aTHX_ packWARN(WARN_MISC), "%s",
				SvPVX_const(err)+start);
d1632 3
a1634 3
	mPUSHs(newSVpv(stashname, 0));
    mPUSHs(newSVpv(OutCopFILE(cx->blk_oldcop), 0));
    mPUSHi((I32)CopLINE(cx->blk_oldcop));
d1643 2
a1644 2
	    mPUSHs(sv);
	    mPUSHi((I32)CxHASARGS(cx));
d1647 2
a1648 2
	    PUSHs(newSVpvs_flags("(unknown)", SVs_TEMP));
	    mPUSHi((I32)CxHASARGS(cx));
d1652 2
a1653 2
	PUSHs(newSVpvs_flags("(eval)", SVs_TEMP));
	mPUSHi(0);
d1659 1
a1659 1
	mPUSHi(gimme & G_ARRAY);
d1662 1
a1662 1
	if (CxOLD_OP_TYPE(cx) == OP_ENTEREVAL) {
d1668 1
a1668 1
	    mPUSHs(newSVsv(cx->blk_eval.old_namesv));
d1681 1
a1681 1
    if (CxTYPE(cx) == CXt_SUB && CxHASARGS(cx)
d1702 1
a1702 1
    mPUSHi(CopHINTS_get(cx->blk_oldcop));
d1715 1
a1715 1
	    HV * const bits = get_hv("warnings::Bits", 0);
d1725 1
a1725 1
        mPUSHs(mask);
d1730 2
a1731 2
				 MUTABLE_SV(Perl_refcounted_he_chain_2hv(aTHX_
					      cx->blk_oldcop->cop_hints_hash))))
a1824 1
	SAVEPADSVANDMORTALIZE(PL_op->op_targ);
d1827 1
d1829 1
d1835 1
a1835 1
	GV * const gv = MUTABLE_GV(POPs);
d1863 2
a1864 19
#ifdef NV_PRESERVES_UV
		if ((SvOK(sv) && ((SvNV(sv) < (NV)IV_MIN) ||
				  (SvNV(sv) > (NV)IV_MAX)))
			||
		    (SvOK(right) && ((SvNV(right) > (NV)IV_MAX) ||
				     (SvNV(right) < (NV)IV_MIN))))
#else
		if ((SvOK(sv) && ((SvNV(sv) <= (NV)IV_MIN)
				  ||
		                  ((SvNV(sv) > 0) &&
					((SvUV(sv) > (UV)IV_MAX) ||
					 (SvNV(sv) > (NV)UV_MAX)))))
			||
		    (SvOK(right) && ((SvNV(right) <= (NV)IV_MIN)
				     ||
				     ((SvNV(right) > 0) &&
					((SvUV(right) > (UV)IV_MAX) ||
					 (SvNV(right) > (NV)UV_MAX))))))
#endif
a1875 2
		/* This will do the upgrade to SVt_PV, and warn if the value
		   is uninitialised.  */
a1876 6
		/* Doing this avoids a check every time in pp_iter in pp_hot.c
		   to replace !SvOK() with a pointer to "".  */
		if (!SvOK(right)) {
		    SvREFCNT_dec(right);
		    cx->blk_loop.iterary = (AV*) &PL_sv_no;
		}
d1887 1
d2076 2
a2077 3
    if (clear_errsv) {
	CLEAR_ERRSV();
    }
a2245 2
    PERL_ARGS_ASSERT_DOFINDLABEL;

d2264 1
a2264 1
		    CopLABEL(kCOP) && strEQ(CopLABEL(kCOP), label))
d2306 1
a2306 1
	    CV *cv = MUTABLE_CV(SvRV(sv));
d2351 1
a2351 1
	    if (CxTYPE(cx) == CXt_SUB && CxHASARGS(cx)) {
d2368 1
a2368 1
		    PAD_SVl(0) = MUTABLE_SV(cx->blk_sub.argarray = av);
d2410 1
a2410 1
		    PL_in_eval = CxOLD_IN_EVAL(cx);
d2422 1
a2422 1
		    if (CvDEPTH(cv) == PERL_SUB_DEPTH_WARN && ckWARN(WARN_RECURSION))
d2428 1
a2428 1
		if (CxHASARGS(cx))
d2430 1
a2430 1
		    AV *const av = MUTABLE_AV(PAD_SVl(0));
d2433 1
a2433 1
		    GvAV(PL_defgv) = MUTABLE_AV(SvREFCNT_inc_simple(av));
d2468 1
a2468 1
			CV * const gotocv = get_cv("DB::goto", 0);
d2471 1
a2471 1
			    call_sv(MUTABLE_SV(gotocv), G_SCALAR | G_NODEBUG);
a2646 2
    PERL_ARGS_ASSERT_SAVE_LINES;

d2651 1
a2651 1
	t = (const char *)memchr(s, '\n', send - s);
a2733 2
    PERL_ARGS_ASSERT_SV_COMPILE_2OP;

d2794 1
a2794 1
    *padp = MUTABLE_AV(SvREFCNT_inc_simple(PL_comppad));
d2871 1
a2871 1
    PL_compcv = MUTABLE_CV(newSV_type(SVt_PVCV));
d2877 1
a2877 1
    CvOUTSIDE(PL_compcv) = MUTABLE_CV(SvREFCNT_inc_simple(outside));
d2915 1
a2915 1
	CLEAR_ERRSV();
d2973 1
a2973 1
    else if ((gimme & G_WANT) == G_VOID)
d2975 1
a2975 1
    else if ((gimme & G_WANT) == G_ARRAY)
d2984 1
a2984 1
	CV * const cv = get_cv("DB::postponed", 0);
d2988 1
a2988 1
	    XPUSHs(MUTABLE_SV(CopFILEGV(&PL_compiling)));
d2990 1
a2990 1
	    call_sv(MUTABLE_SV(cv), G_DISCARD);
a3013 2
    PERL_ARGS_ASSERT_CHECK_TYPE_AND_OPEN;

a3026 2
    PERL_ARGS_ASSERT_DOOPEN_PM;

d3079 8
d3100 1
a3100 1
		SV * const pv = *hv_fetchs(MUTABLE_HV(req), "original", FALSE);
d3103 1
a3103 1
		lav = MUTABLE_AV(SvRV(*hv_fetchs(MUTABLE_HV(req), "version", FALSE)));
d3107 1
a3107 1
		    || hv_exists(MUTABLE_HV(req), "qv", 2 ) /* qv style */
d3138 11
d3151 1
a3151 1
		vcmp(sv, sv_2mortal(upg_version(newSVnv(5.009005), FALSE))) >= 0) {
d3157 1
d3224 2
a3225 1
	    namesv = newSV_type(SVt_PV);
d3229 1
a3229 1
		if (SvTIED_mg((const SV *)ar, PERL_MAGIC_tied))
d3239 1
a3239 1
			loader = *av_fetch(MUTABLE_AV(SvRV(loader)), 0, TRUE);
d3283 1
a3283 1
			if (SvROK(arg) && isGV_with_GP(SvRV(arg))) {
d3287 2
a3288 2
			if (isGV_with_GP(arg)) {
			    IO * const io = GvIO((const GV *)arg);
a3489 5
    if (PL_compiling.cop_hints_hash) {
	Perl_refcounted_he_free(aTHX_ PL_compiling.cop_hints_hash);
	PL_compiling.cop_hints_hash = NULL;
    }

d3501 3
a3503 3
	IoTOP_GV(datasv) = MUTABLE_GV(filter_state);
	IoBOTTOM_GV(datasv) = MUTABLE_GV(filter_sub);
	IoFMT_GV(datasv) = MUTABLE_GV(filter_cache);
d3537 1
a3537 1
    const U32 was = PL_breakable_sub_gen;
d3550 1
a3550 1
	saved_hh = MUTABLE_HV(SvREFCNT_inc(POPs));
d3586 1
a3586 3
    if (saved_hh) {
	/* SAVEHINTS created a new HV in PL_hintgv, which we need to GC */
	SvREFCNT_dec(GvHV(PL_hintgv));
a3587 1
    }
d3612 1
a3612 1
    if ((PERLDB_LINE || PERLDB_SAVESRC) && PL_curstash != PL_debstash)
d3616 2
a3617 13
    if (ok ? (was != PL_breakable_sub_gen /* Some subs defined here. */
	      ? (PERLDB_LINE || PERLDB_SAVESRC)
	      :  PERLDB_SAVESRC_NOSUBS)
	: 0 /* PERLDB_SAVESRC_INVALID */
	/* Much that I'd like to think that it was this trivial to add this
	   feature, it's not, due to
	       lex_end();
	       LEAVE;
	   in S_doeval() for the failure case. So really we want a more
	   sophisticated way of (optionally) clearing the source code.
	   Particularly as the current way is buggy, as a syntactically
	   invalid eval string can still define a subroutine that is retained,
	   and the user may wish to breakpoint. */) {
d3685 2
a3686 3
	if (!(save_flags & OPf_SPECIAL)) {
	    CLEAR_ERRSV();
	}
d3730 1
a3730 1
	CLEAR_ERRSV();
d3789 1
a3789 1
    CLEAR_ERRSV();
d3840 1
a3840 1
S_make_matcher(pTHX_ REGEXP *re)
a3843 3

    PERL_ARGS_ASSERT_MAKE_MATCHER;

d3845 1
a3845 1

a3856 2

    PERL_ARGS_ASSERT_MATCHER_MATCHES_SV;
a3869 2

    PERL_ARGS_ASSERT_DESTROY_MATCHER;
a3870 1

a3889 1
    bool object_on_left = FALSE;
d3892 1
d3894 33
d3928 5
a3932 14
#   define SM_ISREGEX(x) \
	(SvROK(x) && SvMAGICAL(SvRV(x)) \
	&& (mg = mg_find(SvRV(x), PERL_MAGIC_qr)))

    /* First of all, handle overload magic of the rightmost argument */
    if (SvAMAGIC(e)) {
	SV * const tmpsv = amagic_call(d, e, smart_amg, 0);
	if (tmpsv) {
	    SPAGAIN;
	    (void)POPs;
	    SETs(tmpsv);
	    RETURN;
	}
    }
d3934 2
d3951 1
a3951 15
    /* ~~ undef */
    if (!SvOK(e)) {
	if (SvOK(d))
	    RETPUSHNO;
	else
	    RETPUSHYES;
    }

    if (sv_isobject(e) && !SM_ISREGEX(e))
	Perl_croak(aTHX_ "Smart matching a non-overloaded object breaks encapsulation");
    if (sv_isobject(d) && !SM_ISREGEX(d))
	object_on_left = TRUE;

    /* ~~ sub */
    if (SvROK(e) && SvTYPE(SvRV(e)) == SVt_PVCV) {
d3953 4
a3956 27
	if (object_on_left) {
	    goto sm_any_sub; /* Treat objects like scalars */
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVHV) {
	    /* Test sub truth for each key */
	    HE *he;
	    bool andedresults = TRUE;
	    HV *hv = (HV*) SvRV(d);
	    I32 numkeys = hv_iterinit(hv);
	    if (numkeys == 0)
		RETPUSHYES;
	    while ( (he = hv_iternext(hv)) ) {
		ENTER;
		SAVETMPS;
		PUSHMARK(SP);
		PUSHs(hv_iterkeysv(he));
		PUTBACK;
		c = call_sv(e, G_SCALAR);
		SPAGAIN;
		if (c == 0)
		    andedresults = FALSE;
		else
		    andedresults = SvTRUEx(POPs) && andedresults;
		FREETMPS;
		LEAVE;
	    }
	    if (andedresults)
d3961 15
a3975 47
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVAV) {
	    /* Test sub truth for each element */
	    I32 i;
	    bool andedresults = TRUE;
	    AV *av = (AV*) SvRV(d);
	    const I32 len = av_len(av);
	    if (len == -1)
		RETPUSHYES;
	    for (i = 0; i <= len; ++i) {
		SV * const * const svp = av_fetch(av, i, FALSE);
		ENTER;
		SAVETMPS;
		PUSHMARK(SP);
		if (svp)
		    PUSHs(*svp);
		PUTBACK;
		c = call_sv(e, G_SCALAR);
		SPAGAIN;
		if (c == 0)
		    andedresults = FALSE;
		else
		    andedresults = SvTRUEx(POPs) && andedresults;
		FREETMPS;
		LEAVE;
	    }
	    if (andedresults)
		RETPUSHYES;
	    else
		RETPUSHNO;
	}
	else {
	  sm_any_sub:
	    ENTER;
	    SAVETMPS;
	    PUSHMARK(SP);
	    PUSHs(d);
	    PUTBACK;
	    c = call_sv(e, G_SCALAR);
	    SPAGAIN;
	    if (c == 0)
		PUSHs(&PL_sv_no);
	    else if (SvTEMP(TOPs))
		SvREFCNT_inc_void(TOPs);
	    FREETMPS;
	    LEAVE;
	    RETURN;
	}
d3977 2
a3978 9
    /* ~~ %hash */
    else if (SvROK(e) && SvTYPE(SvRV(e)) == SVt_PVHV) {
	if (object_on_left) {
	    goto sm_any_hash; /* Treat objects like scalars */
	}
	else if (!SvOK(d)) {
	    RETPUSHNO;
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVHV) {
d3981 1
a3981 1
	    HV *other_hv = MUTABLE_HV(SvRV(d));
a3985 1
	    HV *hv = MUTABLE_HV(SvRV(e));
d3988 1
a3988 1
	    if (SvTIED_mg((SV*)hv, PERL_MAGIC_tied)) {
d3991 1
a3991 1
	    else if (SvTIED_mg((const SV *)other_hv, PERL_MAGIC_tied)) {
d3993 2
a3994 2
		other_hv = hv;
		hv = temp;
d3997 1
a3997 1
	    if (SvTIED_mg((const SV *)other_hv, PERL_MAGIC_tied))
d4000 1
a4000 1
	    if (!tied && HvUSEDKEYS((const HV *) hv) != HvUSEDKEYS(other_hv))
d4005 4
a4008 3
	    (void) hv_iterinit(hv);
	    while ( (he = hv_iternext(hv)) ) {
		SV *key = hv_iterkeysv(he);
d4012 2
a4013 2
	    	if(!hv_exists_ent(other_hv, key, 0)) {
	    	    (void) hv_iterinit(hv);	/* reset iterator */
d4031 2
a4032 2
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVAV) {
	    AV * const other_av = MUTABLE_AV(SvRV(d));
a4034 1
	    HV *hv = MUTABLE_HV(SvRV(e));
d4038 3
d4042 2
a4043 1
		    if (hv_exists_ent(hv, *svp, 0))
d4049 3
a4051 10
	else if (SM_ISREGEX(d)) {
	  sm_regex_hash:
	    {
#ifdef DEBUGGING
		/* if arrive via goto, no guarantee mg is from d */
		MAGIC* old_mg = mg;
		assert(SM_ISREGEX(d) && old_mg == mg);
		{
#endif
		PMOP * const matcher = make_matcher((REGEXP*) mg->mg_obj);
d4053 6
a4058 10
		HE *he;
		HV *hv = MUTABLE_HV(SvRV(e));

		(void) hv_iterinit(hv);
		while ( (he = hv_iternext(hv)) ) {
		    if (matcher_matches_sv(matcher, hv_iterkeysv(he))) {
			(void) hv_iterinit(hv);
			destroy_matcher(matcher);
			RETPUSHYES;
		    }
a4059 5
		destroy_matcher(matcher);
		RETPUSHNO;
#ifdef DEBUGGING
		}
#endif
d4061 2
d4065 1
a4065 2
	  sm_any_hash:
	    if (hv_exists_ent(MUTABLE_HV(SvRV(e)), d, 0))
d4071 4
a4074 22
    /* ~~ @@array */
    else if (SvROK(e) && SvTYPE(SvRV(e)) == SVt_PVAV) {
	if (object_on_left) {
	    goto sm_any_array; /* Treat objects like scalars */
	}
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVHV) {
	    AV * const other_av = MUTABLE_AV(SvRV(e));
	    const I32 other_len = av_len(other_av) + 1;
	    I32 i;

	    for (i = 0; i < other_len; ++i) {
		SV ** const svp = av_fetch(other_av, i, FALSE);
		if (svp) {	/* ??? When can this not happen? */
		    if (hv_exists_ent(MUTABLE_HV(SvRV(d)), *svp, 0))
		        RETPUSHYES;
		}
	    }
	    RETPUSHNO;
	}
	if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVAV) {
	    AV *other_av = MUTABLE_AV(SvRV(d));
	    if (av_len(MUTABLE_AV(SvRV(e))) != av_len(other_av))
d4082 1
a4082 1
		    (void) sv_2mortal(MUTABLE_SV(seen_this));
d4086 1
a4086 1
		    (void) sv_2mortal(MUTABLE_SV(seen_other));
d4089 1
a4089 1
		    SV * const * const this_elem = av_fetch(MUTABLE_AV(SvRV(e)), i, FALSE);
d4096 2
a4097 4
		    else if (hv_exists_ent(seen_this,
				sv_2mortal(newSViv(PTR2IV(*this_elem))), 0) ||
			    hv_exists_ent(seen_other,
				sv_2mortal(newSViv(PTR2IV(*other_elem))), 0))
d4109 1
a4110 1
			PUSHs(*this_elem);
d4123 10
a4132 19
	else if (SM_ISREGEX(d)) {
	  sm_regex_array:
	    {
#ifdef DEBUGGING
		/* if arrive via goto, no guarantee mg is from d */
		MAGIC* old_mg = mg;
		assert(SM_ISREGEX(d) && old_mg == mg);
		{
#endif
		PMOP * const matcher = make_matcher((REGEXP*) mg->mg_obj);
		const I32 this_len = av_len(MUTABLE_AV(SvRV(e)));
		I32 i;

		for(i = 0; i <= this_len; ++i) {
		    SV * const * const svp = av_fetch(MUTABLE_AV(SvRV(e)), i, FALSE);
		    if (svp && matcher_matches_sv(matcher, *svp)) {
			destroy_matcher(matcher);
			RETPUSHYES;
		    }
a4133 5
		destroy_matcher(matcher);
		RETPUSHNO;
#ifdef DEBUGGING
		}
#endif
d4135 2
d4138 1
a4138 3
	else if (!SvOK(d)) {
	    /* undef ~~ array */
	    const I32 this_len = av_len(MUTABLE_AV(SvRV(e)));
d4141 14
a4154 3
	    for (i = 0; i <= this_len; ++i) {
		SV * const * const svp = av_fetch(MUTABLE_AV(SvRV(e)), i, FALSE);
		if (!svp || !SvOK(*svp))
d4159 3
a4161 5
	else {
	  sm_any_array:
	    {
		I32 i;
		const I32 this_len = av_len(MUTABLE_AV(SvRV(e)));
d4163 12
a4174 15
		for (i = 0; i <= this_len; ++i) {
		    SV * const * const svp = av_fetch(MUTABLE_AV(SvRV(e)), i, FALSE);
		    if (!svp)
			continue;

		    PUSHs(d);
		    PUSHs(*svp);
		    PUTBACK;
		    /* infinite recursion isn't supposed to happen here */
		    (void) do_smartmatch(NULL, NULL);
		    SPAGAIN;
		    if (SvTRUEx(POPs))
			RETPUSHYES;
		}
		RETPUSHNO;
d4176 1
d4179 8
a4186 12
    /* ~~ qr// */
    else if (SM_ISREGEX(e)) {
	if (!object_on_left && SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVHV) {
	    SV *t = d; d = e; e = t;
	    goto sm_regex_hash;
	}
	else if (!object_on_left && SvROK(d) && SvTYPE(SvRV(d)) == SVt_PVAV) {
	    SV *t = d; d = e; e = t;
	    goto sm_regex_array;
	}
	else {
	    PMOP * const matcher = make_matcher((REGEXP*) mg->mg_obj);
d4188 6
a4193 7
	    PUTBACK;
	    PUSHs(matcher_matches_sv(matcher, d)
		    ? &PL_sv_yes
		    : &PL_sv_no);
	    destroy_matcher(matcher);
	    RETURN;
	}
d4195 8
a4202 5
    /* ~~ scalar */
    /* See if there is overload magic on left */
    else if (object_on_left && SvAMAGIC(d)) {
	SV *tmpsv;
	PUSHs(d); PUSHs(e);
d4204 12
a4215 2
	tmpsv = amagic_call(d, e, smart_amg, AMGf_noright);
	if (tmpsv) {
d4217 8
a4224 3
	    (void)POPs;
	    SETs(tmpsv);
	    RETURN;
d4226 4
a4229 2
	SP -= 2;
	goto sm_any_scalar;
d4231 10
a4240 8
    else if (!SvOK(d)) {
	/* undef ~~ scalar ; we already know that the scalar is SvOK */
	RETPUSHNO;
    }
    else
  sm_any_scalar:
    if (SvNIOK(e) || (SvPOK(e) && looks_like_number(e) && SvNIOK(d))) {
	/* numeric comparison */
a4258 1
#undef SM_ISREGEX
a4376 2
    PERL_ARGS_ASSERT_DOPARSEFORM;

d4609 2
a4610 2
    SV * const filter_state = MUTABLE_SV(IoTOP_GV(datasv));
    SV * const filter_sub = MUTABLE_SV(IoBOTTOM_GV(datasv));
a4618 2
    PERL_ARGS_ASSERT_RUN_USER_FILTER;

d4628 1
a4628 1
	SV *const cache = MUTABLE_SV(IoFMT_GV(datasv));
d4687 1
a4687 1
	DEFSV_set(upstream);
d4689 1
a4689 1
	mPUSHi(0);
d4727 1
a4727 1
	SV *cache = MUTABLE_SV(IoFMT_GV(datasv));
d4730 1
a4730 1
	    IoFMT_GV(datasv) = MUTABLE_GV((cache = newSV(got_len - umaxlen)));
a4784 2
    PERL_ARGS_ASSERT_PATH_IS_ABSOLUTE;

a4787 7
#endif
#ifdef WIN32
 || (*name == '.' && ((name[1] == '/' ||
 (name[1] == '.' && name[2] == '/'))
 || (name[1] == '\\' ||
 ( name[1] == '.' && name[2] == '\\')))
 )
@


1.1.1.13
log
@Perl 5.12.2 from CPAN
@
text
@d82 2
a83 1
    REGEXP *re = NULL;
a96 16

#define tryAMAGICregexp(rx)			\
    STMT_START {				\
	if (SvROK(rx) && SvAMAGIC(rx)) {	\
	    SV *sv = AMG_CALLun(rx, regexp);	\
	    if (sv) {				\
		if (SvROK(sv))			\
		    sv = SvRV(sv);		\
		if (SvTYPE(sv) != SVt_REGEXP)	\
		    Perl_croak(aTHX_ "Overloaded qr did not return a REGEXP"); \
		rx = sv;			\
	    }					\
	}					\
    } STMT_END
	    

a102 1
	    SV *msv = *MARK;
d105 2
a106 5

		tryAMAGICregexp(msv);

		if ((SvAMAGIC(tmpstr) || SvAMAGIC(msv)) &&
		    (sv = amagic_call(tmpstr, msv, concat_amg, AMGf_assign)))
d112 1
a112 1
	    sv_catsv(tmpstr, msv);
d117 1
a117 1
    else {
a118 4
	tryAMAGICregexp(tmpstr);
    }

#undef tryAMAGICregexp
d122 2
a123 2
	if (SvTYPE(sv) == SVt_REGEXP)
	    re = (REGEXP*) sv;
d125 2
a126 26
    else if (SvTYPE(tmpstr) == SVt_REGEXP)
	re = (REGEXP*) tmpstr;

    if (re) {
	/* The match's LHS's get-magic might need to access this op's reg-
	   exp (as is sometimes the case with $';  see bug 70764).  So we
	   must call get-magic now before we replace the regexp. Hopeful-
	   ly this hack can be replaced with the approach described at
	   http://www.nntp.perl.org/group/perl.perl5.porters/2007/03
	   /msg122415.html some day. */
	if(pm->op_type == OP_MATCH) {
	 SV *lhs;
	 const bool was_tainted = PL_tainted;
	 if (pm->op_flags & OPf_STACKED)
	    lhs = TOPs;
	 else if (pm->op_private & OPpTARGET_MY)
	    lhs = PAD_SV(pm->op_targ);
	 else lhs = DEFSV;
	 SvGETMAGIC(lhs);
	 /* Restore the previous value of PL_tainted (which may have been
	    modified by get-magic), to avoid incorrectly setting the
	    RXf_TAINTED flag further down. */
	 PL_tainted = was_tainted;
	}

	re = reg_temp_copy(NULL, re);
a133 1
	assert (re != (REGEXP*) &PL_sv_undef);
d136 1
a136 1
	if (!re || !RX_PRECOMP(re) || RX_PRELEN(re) != len ||
a142 3
#ifdef USE_ITHREADS
		PM_SETRE(pm, (REGEXP*) &PL_sv_undef);
#else
a143 1
#endif
d154 2
a155 11
	    if (DO_UTF8(tmpstr)) {
		assert (SvUTF8(tmpstr));
	    } else if (SvUTF8(tmpstr)) {
		/* Not doing UTF-8, despite what the SV says. Is this only if
		   we're trapped in use 'bytes'?  */
		/* Make a copy of the octet sequence, but without the flag on,
		   as the compiler now honours the SvUTF8 flag on tmpstr.  */
		STRLEN len;
		const char *const p = SvPV(tmpstr, len);
		tmpstr = newSVpvn_flags(p, len, SVs_TEMP);
	    }
a222 2
	/* XXX: adjust for positive offsets of \G for instance s/(.)\G//g with positive pos() */
	s -= RX_GOFS(rx);
d225 5
a229 6
	if (CxONCE(cx) || s < orig ||
		!CALLREGEXEC(rx, s, cx->sb_strend, orig,
			     (s == m) + RX_GOFS(rx), cx->sb_targ, NULL,
			     ((cx->sb_rflags & REXEC_COPY_STR)
			      ? (REXEC_IGNOREPOS|REXEC_NOT_FIRST)
			      : (REXEC_COPY_STR|REXEC_IGNOREPOS|REXEC_NOT_FIRST))))
d333 2
a334 2
    *p++ = PTR2UV(RX_SAVED_COPY(rx));
    RX_SAVED_COPY(rx) = NULL;
d347 2
a348 2
static void
S_rxres_restore(pTHX_ void **rsp, REGEXP *rx)
d361 3
a363 3
    if (RX_SAVED_COPY(rx))
	SvREFCNT_dec (RX_SAVED_COPY(rx));
    RX_SAVED_COPY(rx) = INT2PTR(SV*,*p);
d377 2
a378 2
static void
S_rxres_free(pTHX_ void **rsp)
d501 2
a502 1
		sv_utf8_upgrade_flags_grow(PL_formtarget, SV_GMAGIC, fudge + 1);
d523 2
a524 1
		Perl_ck_warner(aTHX_ packWARN(WARN_SYNTAX), "Not enough format arguments");
d685 2
a686 2
			sv_utf8_upgrade_flags_grow(PL_formtarget, SV_GMAGIC,
								    fudge + 1);
d797 1
a797 1
			    sv_utf8_upgrade_nomg(PL_formtarget);
d892 5
d963 1
a963 1
    ENTER_with_name("grep");					/* enter outer scope */
d970 1
a970 1
    ENTER_with_name("grep_item");					/* enter inner scope */
d1051 1
a1051 1
    LEAVE_with_name("grep_item");					/* exit inner scope */
d1057 1
a1057 1
	LEAVE_with_name("grep");					/* exit outer scope */
d1080 1
a1080 1
	ENTER_with_name("grep_item");					/* enter inner scope */
a1241 7
    NULL, /* CXt_WHEN never actually needs "block" */
    NULL, /* CXt_BLOCK never actually needs "block" */
    NULL, /* CXt_GIVEN never actually needs "block" */
    NULL, /* CXt_LOOP_FOR never actually needs "loop" */
    NULL, /* CXt_LOOP_PLAIN never actually needs "loop" */
    NULL, /* CXt_LOOP_LAZYSV never actually needs "loop" */
    NULL, /* CXt_LOOP_LAZYIV never actually needs "loop" */
a1242 1
    "format",
d1244 1
d1246 4
d1268 3
a1270 2
	    Perl_ck_warner(aTHX_ packWARN(WARN_EXITING), "Exiting %s via %s",
			   context_name[CxTYPE(cx)], OP_NAME(PL_op));
d1274 2
a1275 7
	case CXt_LOOP_LAZYIV:
	case CXt_LOOP_LAZYSV:
	case CXt_LOOP_FOR:
	case CXt_LOOP_PLAIN:
	  {
	    const char *cx_label = CxLABEL(cx);
	    if (!cx_label || strNE(label, cx_label) ) {
d1277 1
a1277 1
			(long)i, cx_label));
a1281 1
	  }
d1386 3
a1388 2
	    Perl_ck_warner(aTHX_ packWARN(WARN_EXITING), "Exiting %s via %s",
			   context_name[CxTYPE(cx)], OP_NAME(PL_op));
d1392 1
a1392 4
	case CXt_LOOP_LAZYIV:
	case CXt_LOOP_LAZYSV:
	case CXt_LOOP_FOR:
	case CXt_LOOP_PLAIN:
d1413 1
a1413 6
	case CXt_LOOP_PLAIN:
	    assert(!CxFOREACHDEF(cx));
	    break;
	case CXt_LOOP_LAZYIV:
	case CXt_LOOP_LAZYSV:
	case CXt_LOOP_FOR:
d1464 1
a1464 4
	case CXt_LOOP_LAZYIV:
	case CXt_LOOP_LAZYSV:
	case CXt_LOOP_FOR:
	case CXt_LOOP_PLAIN:
d1495 2
a1496 2
void
Perl_die_where(pTHX_ SV *msv)
d1504 1
a1504 1
	if (msv) {
d1511 1
a1511 1
		else if (SvCUR(err) >= sizeof(prefix)+SvCUR(msv)-1) {
a1512 2
		    STRLEN msglen;
		    const char* message = SvPV_const(msv, msglen);
d1519 1
a1519 2
		    STRLEN start;
		    SvGROW(err, SvCUR(err)+sizeof(prefix)+SvCUR(msv));
d1521 6
a1526 4
		    sv_catsv(err, msv);
		    start = SvCUR(err)-SvCUR(msv)-sizeof(prefix)+1;
		    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "%s",
				   SvPVX_const(err)+start);
a1529 2
		STRLEN msglen;
		const char* message = SvPV_const(msv, msglen);
a1530 1
		SvFLAGS(ERRSV) |= SvFLAGS(msv) & SVf_UTF8;
a1542 1
	    SV *namesv;
d1551 2
a1552 2
		STRLEN msglen;
		const char* message = SvPVx_const( msv ? msv : ERRSV, msglen);
a1557 1
	    namesv = cx->blk_eval.old_namesv;
d1573 2
a1574 2
                (void)hv_store(GvHVn(PL_incgv),
                               SvPVX_const(namesv), SvCUR(namesv),
d1580 1
a1580 3
	    PL_restartop = cx->blk_eval.retop;
	    JMPENV_JUMP(3);
	    /* NOTREACHED */
d1583 2
d1586 1
a1586 1
    write_to_stderr( msv ? msv : ERRSV );
d1589 1
d1679 1
a1679 1
	    PUSHs(boolSV(CxHASARGS(cx)));
d1683 1
a1683 1
	    PUSHs(boolSV(CxHASARGS(cx)));
d1694 1
a1694 1
	PUSHs(boolSV((gimme & G_WANT) == G_ARRAY));
d1722 6
a1727 2
	if (!PL_dbargs)
	    Perl_init_dbargs(aTHX);
d1846 1
a1846 1
    U8 cxtype = CXt_LOOP_FOR;
d1848 1
a1848 1
    PAD *iterdata;
d1851 1
a1851 1
    ENTER_with_name("loop1");
d1864 2
a1865 1
	iterdata = NULL;
d1874 1
a1874 1
	iterdata = (PAD*)gv;
d1881 1
a1881 1
    ENTER_with_name("loop2");
d1885 1
a1885 1
    PUSHLOOP_FOR(cx, iterdata, MARK, PL_op->op_targ);
d1887 1
a1887 1
    PUSHLOOP_FOR(cx, svp, MARK, 0);
d1890 2
a1891 2
	SV *maybe_ary = POPs;
	if (SvTYPE(maybe_ary) != SVt_PVAV) {
d1893 1
a1893 1
	    SV * const right = maybe_ary;
a1896 5
		cx->cx_type &= ~CXTYPEMASK;
		cx->cx_type |= CXt_LOOP_LAZYIV;
		/* Make sure that no-one re-orders cop.h and breaks our
		   assumptions */
		assert(CxTYPE(cx) == CXt_LOOP_LAZYIV);
d1917 2
a1918 2
		cx->blk_loop.state_u.lazyiv.cur = SvIV(sv);
		cx->blk_loop.state_u.lazyiv.end = SvIV(right);
d1925 2
a1926 9
		cx->cx_type &= ~CXTYPEMASK;
		cx->cx_type |= CXt_LOOP_LAZYSV;
		/* Make sure that no-one re-orders cop.h and breaks our
		   assumptions */
		assert(CxTYPE(cx) == CXt_LOOP_LAZYSV);
		cx->blk_loop.state_u.lazysv.cur = newSVsv(sv);
		cx->blk_loop.state_u.lazysv.end = right;
		SvREFCNT_inc(right);
		(void) SvPV_force_nolen(cx->blk_loop.state_u.lazysv.cur);
d1934 1
a1934 1
		    cx->blk_loop.state_u.lazysv.end = &PL_sv_no;
d1938 4
a1941 7
	else /* SvTYPE(maybe_ary) == SVt_PVAV */ {
	    cx->blk_loop.state_u.ary.ary = MUTABLE_AV(maybe_ary);
	    SvREFCNT_inc(maybe_ary);
	    cx->blk_loop.state_u.ary.ix =
		(PL_op->op_private & OPpITER_REVERSED) ?
		AvFILL(cx->blk_loop.state_u.ary.ary) + 1 :
		-1;
d1944 2
a1945 2
    else { /* iterating over items on the stack */
	cx->blk_loop.state_u.ary.ary = NULL; /* means to use the stack */
d1947 2
a1948 1
	    cx->blk_loop.state_u.ary.ix = cx->blk_oldsp + 1;
d1951 1
a1951 1
	    cx->blk_loop.state_u.ary.ix = MARK - PL_stack_base;
d1964 1
a1964 1
    ENTER_with_name("loop1");
d1966 1
a1966 1
    ENTER_with_name("loop2");
d1968 2
a1969 2
    PUSHBLOCK(cx, CXt_LOOP_PLAIN, SP);
    PUSHLOOP_PLAIN(cx, SP);
d1984 1
a1984 1
    assert(CxTYPE_is_LOOP(cx));
d2009 2
a2010 2
    LEAVE_with_name("loop2");
    LEAVE_with_name("loop1");
a2024 1
    SV *namesv;
d2026 1
a2026 1
    OP *retop = NULL;
a2066 1
	namesv = cx->blk_eval.old_namesv;
d2075 3
a2077 4
	    (void)hv_delete(GvHVn(PL_incgv),
			    SvPVX_const(namesv), SvCUR(namesv),
			    G_DISCARD);
	    DIE(aTHX_ "%"SVf" did not return a true value", SVfARG(namesv));
d2148 1
a2148 1
    OP *nextop = NULL;
d2172 2
a2173 5
    case CXt_LOOP_LAZYIV:
    case CXt_LOOP_LAZYSV:
    case CXt_LOOP_FOR:
    case CXt_LOOP_PLAIN:
	pop2 = CxTYPE(cx);
d2215 1
a2215 4
    case CXt_LOOP_LAZYIV:
    case CXt_LOOP_PLAIN:
    case CXt_LOOP_LAZYSV:
    case CXt_LOOP_FOR:
d2324 3
a2326 5
	    if (kid->op_type == OP_NEXTSTATE || kid->op_type == OP_DBSTATE) {
		const char *kid_label = CopLABEL(kCOP);
		if (kid_label && strEQ(kid_label, label))
		    return kid;
	    }
d2474 1
d2529 1
a2529 1
			CV * const gotocv = get_cvs("DB::goto", 0);
d2576 1
a2576 6
	    case CXt_LOOP_LAZYIV:
	    case CXt_LOOP_LAZYSV:
	    case CXt_LOOP_FOR:
	    case CXt_LOOP_PLAIN:
	    case CXt_GIVEN:
	    case CXt_WHEN:
a2624 6
	if (*enterops && enterops[1]) {
	    I32 i = enterops[1]->op_type == OP_ENTER && in_block ? 2 : 1;
	    if (enterops[i])
		deprecate("\"goto\" to jump into a construct");
	}

a2725 14
/*
=for apidoc docatch

Check for the cases 0 or 3 of cur_env.je_ret, only used inside an eval context.

0 is used as continue inside eval,

3 is used for a die caught by an inner eval - continue inner loop

See cop.h: je_mustcatch, when set at any runlevel to TRUE, means eval ops must
establish a local jmpenv to handle exception traps.

=cut
*/
a2776 8
/* James Bond: Do you expect me to talk?
   Auric Goldfinger: No, Mr. Bond. I expect you to die.

   This code is an ugly hack, doesn't work with lexicals in subroutines that are
   called more than once, and is only used by regcomp.c, for (?{}) blocks.

   Currently it is not used outside the core code. Best if it stays that way.
*/
d2783 1
d2799 1
a2799 1
    ENTER_with_name("eval");
d2846 1
a2846 1
    PUSHEVAL(cx, 0);
d2860 1
a2860 1
    LEAVE_with_name("eval");
d2983 1
a2983 1
	PERL_CONTEXT *cx = NULL;
a2984 1
	SV *namesv = NULL;
a2995 1
	    namesv = cx->blk_eval.old_namesv;
d2998 1
a2998 1
	LEAVE_with_name("eval"); /* pp_entereval knows about this LEAVE.  */
d3002 3
a3004 10
	    if (!cx) {
		/* If cx is still NULL, it means that we didn't go in the
		 * POPEVAL branch. */
		cx = &cxstack[cxstack_ix];
		assert(CxTYPE(cx) == CXt_EVAL);
		namesv = cx->blk_eval.old_namesv;
	    }
	    (void)hv_store(GvHVn(PL_incgv),
			   SvPVX_const(namesv), SvCUR(namesv),
			   &PL_sv_undef, 0);
d3031 8
a3038 2
     * Propagate the context from the eval(). */
    if ((gimme & G_WANT) == G_VOID)
d3049 1
a3049 1
	CV * const cv = get_cvs("DB::postponed", 0);
d3177 1
a3177 1
		    SV *hintsv;
d3184 2
a3185 2
		    hintsv = Perl_newSVpvf(aTHX_ "v%d.%d.0",
					   (int)first, (int)second);
d3191 1
a3191 1
			SVfARG(vnormal(sv_2mortal(hintsv))),
d3197 10
a3206 15
	/* We do this only with "use", not "require" or "no". */
	if (PL_compcv && !(cUNOP->op_first->op_private & OPpCONST_NOVER)) {
	    /* If we request a version >= 5.9.5, load feature.pm with the
	     * feature bundle that corresponds to the required version. */
	    if (vcmp(sv, sv_2mortal(upg_version(newSVnv(5.009005), FALSE))) >= 0) {
		SV *const importsv = vnormal(sv);
		*SvPVX_mutable(importsv) = ':';
		ENTER_with_name("load_feature");
		Perl_load_module(aTHX_ 0, newSVpvs("feature"), NULL, importsv, NULL);
		LEAVE_with_name("load_feature");
	    }
	    /* If a version >= 5.11.0 is requested, strictures are on by default! */
	    if (vcmp(sv, sv_2mortal(upg_version(newSVnv(5.011000), FALSE))) >= 0) {
		PL_hints |= (HINT_STRICT_REFS | HINT_STRICT_SUBS | HINT_STRICT_VARS);
	    }
d3255 11
d3295 1
a3295 1
		    ENTER_with_name("call_INC");
d3309 5
d3373 1
a3373 7
		    LEAVE_with_name("call_INC");

		    /* Adjust file name if the hook has set an %INC entry.
		       This needs to happen after the FREETMPS above.  */
		    svp = hv_fetch(GvHVn(PL_incgv), name, len, 0);
		    if (svp)
			tryname = SvPV_nolen_const(*svp);
d3396 6
d3413 8
a3420 1
#ifdef VMS
d3426 2
a3427 2
#else
#  ifdef __SYMBIAN32__
d3439 1
a3439 1
#  else
d3460 1
d3467 2
a3468 4
			if (tryname[0] == '.' && tryname[1] == '/') {
			    ++tryname;
			    while (*++tryname == '/');
			}
d3532 1
a3532 1
    ENTER_with_name("eval");
d3538 4
a3541 1
    hv_clear(GvHV(PL_hintgv));
d3552 1
a3552 5
	/* We can use the SvPV of the filter PVIO itself as our cache, rather
	   than hanging another SV from it. In turn, filter_add() optionally
	   takes the SV to use as the filter (or creates a new SV if passed
	   NULL), so simply pass in whatever value filter_cache has.  */
	SV * const datasv = filter_add(S_run_user_filter, filter_cache);
d3556 1
d3561 1
a3561 1
    PUSHEVAL(cx, name);
a3583 13
/* This is a op added to hold the hints hash for
   pp_entereval. The hash can be modified by the code
   being eval'ed, so we return a copy instead. */

PP(pp_hintseval)
{
    dVAR;
    dSP;
    mXPUSHs(MUTABLE_SV(Perl_hv_copy_hints_hv(aTHX_ MUTABLE_HV(cSVOP_sv))));
    RETURN;
}


d3593 1
d3595 1
d3599 3
a3601 1

d3610 1
a3610 1
    ENTER_with_name("eval");
d3635 2
d3649 1
a3649 12
    if (Perl_fetch_cop_label(aTHX_ PL_curcop->cop_hints_hash, NULL, NULL)) {
	/* The label, if present, is the first entry on the chain. So rather
	   than writing a blank label in front of it (which involves an
	   allocation), just use the next entry in the chain.  */
	PL_compiling.cop_hints_hash
	    = PL_curcop->cop_hints_hash->refcounted_he_next;
	/* Check the assumption that this removed the label.  */
	assert(Perl_fetch_cop_label(aTHX_ PL_compiling.cop_hints_hash, NULL,
				    NULL) == NULL);
    }
    else
	PL_compiling.cop_hints_hash = PL_curcop->cop_hints_hash;
d3663 1
a3663 1
    PUSHEVAL(cx, 0);
d3671 16
a3686 22

    if (doeval(gimme, NULL, runcv, seq)) {
	if (was != PL_breakable_sub_gen /* Some subs defined here. */
	    ? (PERLDB_LINE || PERLDB_SAVESRC)
	    :  PERLDB_SAVESRC_NOSUBS) {
	    /* Retain the filegv we created.  */
	} else {
	    char *const safestr = savepvn(tmpbuf, len);
	    SAVEDELETE(PL_defstash, safestr, len);
	}
	return DOCATCH(PL_eval_start);
    } else {
	/* We have already left the scope set up earler thanks to the LEAVE
	   in doeval().  */
	if (was != PL_breakable_sub_gen /* Some subs defined here. */
	    ? (PERLDB_LINE || PERLDB_SAVESRC)
	    :  PERLDB_SAVESRC_INVALID) {
	    /* Retain the filegv we created.  */
	} else {
	    (void)hv_delete(PL_defstash, tmpbuf, len, G_DISCARD);
	}
	return PL_op->op_next;
d3688 1
a3701 1
    SV *namesv;
a3704 1
    namesv = cx->blk_eval.old_namesv;
d3745 3
a3747 5
	(void)hv_delete(GvHVn(PL_incgv),
			SvPVX_const(namesv), SvCUR(namesv),
			G_DISCARD);
	retop = Perl_die(aTHX_ "%"SVf" did not return a true value",
			 SVfARG(namesv));
d3751 1
a3751 1
	LEAVE_with_name("eval");
d3774 1
a3774 1
    LEAVE_with_name("eval_scope");
d3788 1
a3788 1
    ENTER_with_name("eval_scope");
d3792 1
a3792 1
    PUSHEVAL(cx, 0);
d3856 1
a3856 1
    LEAVE_with_name("eval_scope");
d3867 1
a3867 1
    ENTER_with_name("given");
d3870 7
a3876 1
    sv_setsv(PAD_SV(PL_op->op_targ), POPs);
d3901 1
a3901 1
    LEAVE_with_name("given");
d3918 1
a3918 1
    ENTER_with_name("matcher"); SAVETMPS;
d3948 1
a3948 1
    LEAVE_with_name("matcher");
a3953 1
    DEBUG_M(Perl_deb(aTHX_ "Starting smart match resolution\n"));
d3969 5
d3977 1
a3977 5
	SV * tmpsv;
	DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Object\n"));
	DEBUG_M(Perl_deb(aTHX_ "        attempting overload\n"));

	tmpsv = amagic_call(d, e, smart_amg, 0);
a3983 1
	DEBUG_M(Perl_deb(aTHX_ "        failed to run overload method; continuing...\n"));
a4002 1
	DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-undef\n"));
d4009 1
a4009 2
    if (sv_isobject(e) && (SvTYPE(SvRV(e)) != SVt_REGEXP)) {
	DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Object\n"));
d4011 1
a4011 2
    }
    if (sv_isobject(d) && (SvTYPE(SvRV(d)) != SVt_REGEXP))
a4025 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Hash-CodeRef\n"));
d4029 1
a4029 2
		DEBUG_M(Perl_deb(aTHX_ "        testing hash key...\n"));
		ENTER_with_name("smartmatch_hash_key_test");
d4041 1
a4041 1
		LEAVE_with_name("smartmatch_hash_key_test");
a4053 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Array-CodeRef\n"));
d4058 1
a4058 2
		DEBUG_M(Perl_deb(aTHX_ "        testing array element...\n"));
		ENTER_with_name("smartmatch_array_elem_test");
d4071 1
a4071 1
		LEAVE_with_name("smartmatch_array_elem_test");
d4080 1
a4080 2
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-CodeRef\n"));
	    ENTER_with_name("smartmatch_coderef");
d4092 1
a4092 1
	    LEAVE_with_name("smartmatch_coderef");
a4101 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Hash ($a undef)\n"));
d4113 1
a4113 2

	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Hash-Hash\n"));
d4135 1
a4135 2

		DEBUG_M(Perl_deb(aTHX_ "        comparing hash key...\n"));
a4162 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Array-Hash\n"));
a4164 1
		DEBUG_M(Perl_deb(aTHX_ "        checking for key existence...\n"));
d4172 1
a4172 2
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_REGEXP) {
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Regex-Hash\n"));
d4175 8
a4182 1
		PMOP * const matcher = make_matcher((REGEXP*) SvRV(d));
a4187 1
		    DEBUG_M(Perl_deb(aTHX_ "        testing key against pattern...\n"));
d4196 3
a4202 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Hash\n"));
a4218 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Hash-Array\n"));
a4220 2

		DEBUG_M(Perl_deb(aTHX_ "        testing for key existence...\n"));
a4229 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Array-Array\n"));
d4241 1
a4241 1
		    seen_other = newHV();
d4249 1
a4249 2
			if ((this_elem && SvOK(*this_elem))
				|| (other_elem && SvOK(*other_elem)))
a4270 1
			DEBUG_M(Perl_deb(aTHX_ "        recursively comparing array element...\n"));
a4272 1
			DEBUG_M(Perl_deb(aTHX_ "        recursion finished\n"));
d4281 1
a4281 2
	else if (SvROK(d) && SvTYPE(SvRV(d)) == SVt_REGEXP) {
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Regex-Array\n"));
d4284 7
a4290 1
		PMOP * const matcher = make_matcher((REGEXP*) SvRV(d));
a4295 1
		    DEBUG_M(Perl_deb(aTHX_ "        testing element against pattern...\n"));
d4303 3
a4312 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Undef-Array\n"));
a4314 1
		DEBUG_M(Perl_deb(aTHX_ "        testing for undef element...\n"));
a4325 1
		DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Array\n"));
a4334 1
		    DEBUG_M(Perl_deb(aTHX_ "        recursively testing array element...\n"));
a4336 1
		    DEBUG_M(Perl_deb(aTHX_ "        recursion finished\n"));
d4345 1
a4345 1
    else if (SvROK(e) && SvTYPE(SvRV(e)) == SVt_REGEXP) {
a4347 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Hash-Regex\n"));
a4351 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Array-Regex\n"));
d4355 1
a4355 1
	    PMOP * const matcher = make_matcher((REGEXP*) SvRV(e));
a4356 1
	    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Regex\n"));
a4368 2
	DEBUG_M(Perl_deb(aTHX_ "    applying rule Object-Any\n"));
	DEBUG_M(Perl_deb(aTHX_ "        attempting overload\n"));
a4378 1
	DEBUG_M(Perl_deb(aTHX_ "        failed to run overload method; falling back...\n"));
a4382 1
	DEBUG_M(Perl_deb(aTHX_ "    applying rule undef-Any\n"));
a4387 5
	DEBUG_M(if (SvNIOK(e))
		    Perl_deb(aTHX_ "    applying rule Any-Num\n");
		else
		    Perl_deb(aTHX_ "    applying rule Num-numish\n");
	);
a4402 1
    DEBUG_M(Perl_deb(aTHX_ "    applying rule Any-Any\n"));
d4407 1
d4423 1
a4423 1
    ENTER_with_name("eval");
d4448 1
a4448 1
    LEAVE_with_name("eval");
d4765 2
a4766 2
    char *got_p = NULL;
    char *prune_from = NULL;
d4780 2
a4781 2
    {
	SV *const cache = datasv;
d4835 1
a4835 1
	ENTER_with_name("call_filter_sub");
d4859 1
a4859 1
	LEAVE_with_name("call_filter_sub");
d4869 2
a4870 1
	    char *const first_nl = (char *)memchr(got_p, '\n', got_len);
d4880 1
a4880 1
	SV *const cache = datasv;
d4882 3
a4884 1
	if (SvOK(cache)) {
a4897 1
	*prune_from = 0;
d4913 1
d4941 3
d4945 5
a4949 5
	|| (*name == '.' && ((name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/'))
			 || (name[1] == '\\' ||
			     ( name[1] == '.' && name[2] == '\\')))
	    )
@


1.1.1.14
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d37 4
a49 1
    const PERL_CONTEXT *cx;
d52 2
a53 6
    if (PL_op->op_private & OPpOFFBYONE) {
	if (!(cx = caller_cx(1,NULL))) RETPUSHUNDEF;
    }
    else {
      cxix = dopoptosub(cxstack_ix);
      if (cxix < 0)
a54 2
      cx = &cxstack[cxix];
    }
d56 1
a56 1
    switch (cx->blk_gimme) {
a98 1
	SvGETMAGIC(rx);				\
d100 1
a100 1
	    SV *sv = AMG_CALLunary(rx, regexp_amg); \
d113 1
a113 1
	/* multiple args; concatenate them */
d119 2
a120 1
	    SV *sv;
d122 1
a122 1
	    tryAMAGICregexp(msv);
d124 6
a129 5
	    if ((SvAMAGIC(tmpstr) || SvAMAGIC(msv)) &&
		(sv = amagic_call(tmpstr, msv, concat_amg, AMGf_assign)))
	    {
	       sv_setsv(tmpstr, sv);
	       continue;
d131 1
a131 8

	    if (SvROK(msv) && SvTYPE(SvRV(msv)) == SVt_REGEXP) {
		msv = SvRV(msv);
		PL_reginterp_cnt +=
		    RX_SEEN_EVALS((REGEXP *)MUTABLE_PTR(msv));
	    }

	    sv_catsv_nomg(tmpstr, msv);
d178 2
a179 3
	STRLEN len = 0;
	const char *t = SvOK(tmpstr) ? SvPV_nomg_const(tmpstr, len) : "";

d188 1
a188 1
            U32 pm_flags = pm->op_pmflags & RXf_PMf_COMPILETIME;
d197 2
a198 1
	        SV *ptr = cop_hints_fetch_pvs(PL_curcop, "regcomp", 0);
d206 3
a208 1
	    if (!DO_UTF8(tmpstr) && SvUTF8(tmpstr)) {
a216 4
	    else if (SvAMAGIC(tmpstr) || SvGMAGICAL(tmpstr)) {
		/* make a copy to avoid extra stringifies */
		tmpstr = newSVpvn_flags(t, len, SVs_TEMP | SvUTF8(tmpstr));
	    }
d218 1
a218 1
	    if (eng)
d220 1
a220 1
	    else
d232 1
a232 2
	if (PL_tainted) {
	    SvTAINTED_on((SV*)re);
d234 2
a235 1
	}
a266 3

    PERL_ASYNC_CHECK();

d281 3
a283 6
	SvGETMAGIC(TOPs); /* possibly clear taint on $1 etc: #67962 */

    	/* See "how taint works" above pp_subst() */
	if (SvTAINTED(TOPs))
	    cx->sb_rxtainted |= SUBST_TAINT_REPL;
	sv_catsv_nomg(dstr, POPs);
a287 7
	/* I believe that we can't set REXEC_SCREAM here if
	   SvSCREAM(cx->sb_targ) is true because SvPVX(cx->sb_targ) isn't always
	   equal to s.  [See the comment before Perl_re_intuit_start(), which is
	   called from Perl_regexec_flags(), which says that it should be when
	   SvSCREAM() is true.]  s, cx->sb_strend and orig will be consistent
	   with SvPVX(cx->sb_targ), as substconst doesn't modify cx->sb_targ
	   during the match.  */
d295 1
a295 1
	    SV *targ = cx->sb_targ;
d304 1
a304 2
	    if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
		cx->sb_rxtainted |= SUBST_TAINT_PAT;
d306 7
a312 5
	    if (pm->op_pmflags & PMf_NONDESTRUCT) {
		PUSHs(dstr);
		/* From here on down we're using the copy, and leaving the
		   original untouched.  */
		targ = dstr;
d314 15
a328 41
	    else {
		if (SvIsCOW(targ)) {
		    sv_force_normal_flags(targ, SV_COW_DROP_PV);
		} else
		{
		    SvPV_free(targ);
		}
		SvPV_set(targ, SvPVX(dstr));
		SvCUR_set(targ, SvCUR(dstr));
		SvLEN_set(targ, SvLEN(dstr));
		if (DO_UTF8(dstr))
		    SvUTF8_on(targ);
		SvPV_set(dstr, NULL);

		mPUSHi(saviters - 1);

		(void)SvPOK_only_UTF8(targ);
	    }

	    /* update the taint state of various various variables in
	     * preparation for final exit.
	     * See "how taint works" above pp_subst() */
	    if (PL_tainting) {
		if ((cx->sb_rxtainted & SUBST_TAINT_PAT) ||
		    ((cx->sb_rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
				    == (SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
		)
		    (RX_MATCH_TAINTED_on(rx)); /* taint $1 et al */

		if (!(cx->sb_rxtainted & SUBST_TAINT_BOOLRET)
		    && (cx->sb_rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_PAT))
		)
		    SvTAINTED_on(TOPs);  /* taint return value */
		/* needed for mg_set below */
		PL_tainted = cBOOL(cx->sb_rxtainted &
			    (SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL));
		SvTAINT(TARG);
	    }
	    /* PL_tainted must be correctly set for this mg_set */
	    SvSETMAGIC(TARG);
	    TAINT_NOT;
a331 1
	    /* NOTREACHED */
d351 1
a351 2
	SV * const sv
	    = (pm->op_pmflags & PMf_NONDESTRUCT) ? cx->sb_dstr : cx->sb_targ;
d366 1
a366 19
    /* update the taint state of various various variables in preparation
     * for calling the code block.
     * See "how taint works" above pp_subst() */
    if (PL_tainting) {
	if (RX_MATCH_TAINTED(rx)) /* run time pattern taint, eg locale */
	    cx->sb_rxtainted |= SUBST_TAINT_PAT;

	if ((cx->sb_rxtainted & SUBST_TAINT_PAT) ||
	    ((cx->sb_rxtainted & (SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
			    == (SUBST_TAINT_STR|SUBST_TAINT_RETAINT))
	)
	    (RX_MATCH_TAINTED_on(rx)); /* taint $1 et al */

	if (cx->sb_iters > 1 && (cx->sb_rxtainted & 
			(SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL)))
	    SvTAINTED_on((pm->op_pmflags & PMf_NONDESTRUCT)
			 ? cx->sb_dstr : cx->sb_targ);
	TAINT_NOT;
    }
a367 1
    PL_curpm = pm;
a467 3
#define FORM_NUM_BLANK (1<<30)
#define FORM_NUM_POINT (1<<29)

d472 3
a474 4
    SV *formsv;		    /* contains text of original format */
    register U32 *fpc;	    /* format ops program counter */
    register char *t;	    /* current append position in target string */
    const char *f;	    /* current position in format string */
d476 8
a483 8
    register SV *sv = NULL; /* current item */
    const char *item = NULL;/* string value of current item */
    I32 itemsize  = 0;	    /* length of current item, possibly truncated */
    I32 fieldsize = 0;	    /* width of current field */
    I32 lines = 0;	    /* number of lines that have been output */
    bool chopspace = (strchr(PL_chopset, ' ') != NULL); /* does $: have space */
    const char *chophere = NULL; /* where to chop current item */
    STRLEN linemark = 0;    /* pos of start of line in output */
d485 1
a485 1
    bool gotsome = FALSE;   /* seen at least one non-blank item on this line */
d487 2
a488 1
    STRLEN linemax;	    /* estimate of output size in bytes */
d491 2
a493 12
    MAGIC *mg = NULL;
    U8 *source;		    /* source of bytes to append */
    STRLEN to_copy;	    /* how may bytes to append */
    char trans;		    /* what chars to translate */

    mg = doparseform(tmpForm);

    fpc = (U32*)mg->mg_ptr;
    /* the actual string the format was compiled from.
     * with overload etc, this may not match tmpForm */
    formsv = mg->mg_obj;

d495 11
a506 2
    if (SvTAINTED(tmpForm) || SvTAINTED(formsv))
	SvTAINTED_on(PL_formtarget);
d509 1
a509 3
    linemax = (SvCUR(formsv) * (IN_BYTES ? 1 : 3) + 1);
    t = SvGROW(PL_formtarget, len + linemax + 1);
    /* XXX from now onwards, SvCUR(PL_formtarget) is invalid */
d511 3
a513 1
    f = SvPV_const(formsv, len);
d547 1
a547 1
	    linemark = t - SvPVX(PL_formtarget);
d553 19
a571 6
	    to_copy = *fpc++;
	    source = (U8 *)f;
	    f += to_copy;
	    trans = '~';
	    item_is_utf8 = targ_is_utf8 ? !!DO_UTF8(formsv) : !!SvUTF8(formsv);
	    goto append;
a587 2
	    if (SvTAINTED(sv))
		SvTAINTED_on(PL_formtarget);
d740 62
a801 9
	    to_copy = itemsize;
	    source = (U8 *)item;
	    trans = 1;
	    if (item_is_utf8) {
		/* convert to_copy from chars to bytes */
		U8 *s = source;
		while (to_copy--)
		   s += UTF8SKIP(s);
		to_copy = s - source;
a802 1
	    goto append;
d822 7
a828 1
		const char *const send = s + len;
d830 30
a859 14
		item_is_utf8 = DO_UTF8(sv);
		if (!len)
		    break;
		trans = 0;
		gotsome = TRUE;
		chophere = s + len;
		source = (U8 *) s;
		to_copy = len;
		while (s < send) {
		    if (*s++ == '\n') {
			if (oneline) {
			    to_copy = s - SvPVX_const(sv) - 1;
			    chophere = s;
			    break;
d861 2
a862 4
			    if (s == send) {
				to_copy--;
			    } else
				lines++;
a863 3
		    }
		}
	    }
d865 2
a866 31
	append:
	    /* append to_copy bytes from source to PL_formstring.
	     * item_is_utf8 implies source is utf8.
	     * if trans, translate certain characters during the copy */
	    {
		U8 *tmp = NULL;
		STRLEN grow = 0;

		SvCUR_set(PL_formtarget,
			  t - SvPVX_const(PL_formtarget));

		if (targ_is_utf8 && !item_is_utf8) {
		    source = tmp = bytes_to_utf8(source, &to_copy);
		} else {
		    if (item_is_utf8 && !targ_is_utf8) {
			U8 *s;
			/* Upgrade targ to UTF8, and then we reduce it to
			   a problem we have a simple solution for.
			   Don't need get magic.  */
			sv_utf8_upgrade_nomg(PL_formtarget);
			targ_is_utf8 = TRUE;
			/* re-calculate linemark */
			s = (U8*)SvPVX(PL_formtarget);
			/* the bytes we initially allocated to append the
			 * whole line may have been gobbled up during the
			 * upgrade, so allocate a whole new line's worth
			 * for safety */
			grow = linemax;
			while (linemark--)
			    s += UTF8SKIP(s);
			linemark = s - (U8*)SvPVX(PL_formtarget);
d868 19
a886 31
		    /* Easy. They agree.  */
		    assert (item_is_utf8 == targ_is_utf8);
		}
		if (!trans)
		    /* @@* and ^* are the only things that can exceed
		     * the linemax, so grow by the output size, plus
		     * a whole new form's worth in case of any further
		     * output */
		    grow = linemax + to_copy;
		if (grow)
		    SvGROW(PL_formtarget, SvCUR(PL_formtarget) + grow + 1);
		t = SvPVX(PL_formtarget) + SvCUR(PL_formtarget);

		Copy(source, t, to_copy, char);
		if (trans) {
		    /* blank out ~ or control chars, depending on trans.
		     * works on bytes not chars, so relies on not
		     * matching utf8 continuation bytes */
		    U8 *s = (U8*)t;
		    U8 *send = s + to_copy;
		    while (s < send) {
			const int ch = *s;
			if (trans == '~' ? (ch == '~') :
#ifdef EBCDIC
			       iscntrl(ch)
#else
			       (!(ch & ~31))
#endif
			)
			    *s = ' ';
			s++;
a888 5

		t += to_copy;
		SvCUR_set(PL_formtarget, SvCUR(PL_formtarget) + to_copy);
		if (tmp)
		    Safefree(tmp);
d896 1
a896 1
		((arg & FORM_NUM_POINT) ?
d900 1
a900 1
		((arg & FORM_NUM_POINT) ?
d908 1
a908 1
		((arg & FORM_NUM_POINT) ? "%#*.*" PERL_PRIfldbl : "%*.*" PERL_PRIfldbl);
d911 1
a911 1
		((arg & FORM_NUM_POINT) ? "%#*.*f"              : "%*.*f");
d916 1
a916 1
	    if ((arg & FORM_NUM_BLANK) && !SvOK(sv)) {
d934 1
a934 2
		arg &= ~(FORM_NUM_POINT|FORM_NUM_BLANK);
		my_snprintf(t, SvLEN(PL_formtarget) - (t - SvPVX(PL_formtarget)), fmt, (int) fieldsize, (int) arg, value);
d942 1
a942 1
	    while (t-- > (SvPVX(PL_formtarget) + linemark) && *t == ' ') ;
d951 8
a958 2
		    fpc--;
		    goto end;
d962 1
a962 1
		t = SvPVX(PL_formtarget) + linemark;
a994 2
	end:
	    assert(t < SvPVX_const(PL_formtarget) + SvLEN(PL_formtarget));
d1001 1
a1001 4
	    if (fpc[-1] == FF_BLANK)
		RETURNOP(cLISTOP->op_first);
	    else
		RETPUSHYES;
d1018 2
a1019 2
    Perl_pp_pushmark(aTHX);				/* push dst */
    Perl_pp_pushmark(aTHX);				/* push src */
d1039 1
a1039 1
	Perl_pp_pushmark(aTHX);			/* push top */
d1095 2
a1096 35
	    /* add returned items to the collection (making mortal copies
	     * if necessary), then clear the current temps stack frame
	     * *except* for those items. We do this splicing the items
	     * into the start of the tmps frame (so some items may be on
	     * the tmps stack twice), then moving PL_tmps_floor above
	     * them, then freeing the frame. That way, the only tmps that
	     * accumulate over iterations are the return values for map.
	     * We have to do to this way so that everything gets correctly
	     * freed if we die during the map.
	     */
	    I32 tmpsbase;
	    I32 i = items;
	    /* make space for the slice */
	    EXTEND_MORTAL(items);
	    tmpsbase = PL_tmps_floor + 1;
	    Move(PL_tmps_stack + tmpsbase,
		 PL_tmps_stack + tmpsbase + items,
		 PL_tmps_ix - PL_tmps_floor,
		 SV*);
	    PL_tmps_ix += items;

	    while (i-- > 0) {
		SV *sv = POPs;
		if (!SvTEMP(sv))
		    sv = sv_mortalcopy(sv);
		*dst-- = sv;
		PL_tmps_stack[tmpsbase++] = SvREFCNT_inc_simple(sv);
	    }
	    /* clear the stack frame except for the items */
	    PL_tmps_floor += items;
	    FREETMPS;
	    /* FREETMPS may have cleared the TEMP flag on some of the items */
	    i = items;
	    while (i-- > 0)
		SvTEMP_on(PL_tmps_stack[--tmpsbase]);
a1105 1
	    FREETMPS;
a1107 3
    else {
	FREETMPS;
    }
d1233 2
a1234 2
	    if ((SvOK(left) && SvNV_nomg(left) < IV_MIN) ||
		(SvOK(right) && SvNV_nomg(right) > IV_MAX))
d1236 2
a1237 2
	    i = SvIV_nomg(left);
	    max = SvIV_nomg(right);
d1251 3
a1253 3
	    STRLEN len, llen;
	    const char * const lpv = SvPV_nomg_const(left, llen);
	    const char * const tmps = SvPV_nomg_const(right, len);
d1255 2
a1256 1
	    SV *sv = newSVpvn_flags(lpv, llen, SvUTF8(left)|SVs_TEMP);
d1313 1
a1313 1
S_dopoptolabel(pTHX_ const char *label, STRLEN len, U32 flags)
a1327 1
	    /* diag_listed_as: Exiting subroutine via %s */
d1338 3
a1340 15
            STRLEN cx_label_len = 0;
            U32 cx_label_flags = 0;
	    const char *cx_label = CxLABEL_len_flags(cx, &cx_label_len, &cx_label_flags);
	    if (!cx_label || !(
                    ( (cx_label_flags & SVf_UTF8) != (flags & SVf_UTF8) ) ?
                        (flags & SVf_UTF8)
                            ? (bytes_cmp_utf8(
                                        (const U8*)cx_label, cx_label_len,
                                        (const U8*)label, len) == 0)
                            : (bytes_cmp_utf8(
                                        (const U8*)label, len,
                                        (const U8*)cx_label, cx_label_len) == 0)
                    : (len == cx_label_len && ((cx_label == label)
                                    || memEQ(cx_label, label, len))) )) {
		DEBUG_l(Perl_deb(aTHX_ "(poptolabel(): skipping label at cx=%ld %s)\n",
d1344 1
a1344 1
	    DEBUG_l( Perl_deb(aTHX_ "(poptolabel(): found label at cx=%ld %s)\n", (long)i, label));
a1396 14
/* only used by PUSHSUB */
I32
Perl_was_lvalue_sub(pTHX)
{
    dVAR;
    const I32 cxix = dopoptosub(cxstack_ix-1);
    assert(cxix >= 0);  /* We should only be called from inside subs */

    if (CxLVAL(cxstack + cxix) && CvLVALUE(cxstack[cxix].blk_sub.cv))
	return CxLVAL(cxstack + cxix);
    else
	return 0;
}

d1413 1
a1413 1
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptosub_at(): found sub at cx=%ld)\n", (long)i));
d1431 1
a1431 1
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptoeval(): found eval at cx=%ld)\n", (long)i));
a1450 1
	    /* diag_listed_as: Exiting subroutine via %s */
d1460 1
a1460 1
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptoloop(): found loop at cx=%ld)\n", (long)i));
d1478 1
a1478 1
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptogiven(): found given at cx=%ld)\n", (long)i));
d1487 1
a1487 1
		DEBUG_l( Perl_deb(aTHX_ "(dopoptogiven(): found foreach at cx=%ld)\n", (long)i));
d1506 1
a1506 1
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptowhen(): found when at cx=%ld)\n", (long)i));
a1518 3
    if (!PL_curstackinfo) /* can happen if die during thread cloning */
	return;

d1522 2
a1523 1
	DEBUG_CX("UNWIND");						\
d1560 2
a1561 8
    if (PL_in_eval) {
	if (PL_in_eval & EVAL_KEEPERR) {
		Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "\t(in cleanup) %"SVf,
                                                    SVfARG(err));
	}
	else
	    sv_catsv(ERRSV, err);
    }
d1571 1
a1571 1
Perl_die_unwind(pTHX_ SV *msv)
a1573 3
    SV *exceptsv = sv_mortalcopy(msv);
    U8 in_eval = PL_in_eval;
    PERL_ARGS_ASSERT_DIE_UNWIND;
d1575 1
a1575 1
    if (in_eval) {
d1579 32
a1610 32
	/*
	 * Historically, perl used to set ERRSV ($@@) early in the die
	 * process and rely on it not getting clobbered during unwinding.
	 * That sucked, because it was liable to get clobbered, so the
	 * setting of ERRSV used to emit the exception from eval{} has
	 * been moved to much later, after unwinding (see just before
	 * JMPENV_JUMP below).	However, some modules were relying on the
	 * early setting, by examining $@@ during unwinding to use it as
	 * a flag indicating whether the current unwinding was caused by
	 * an exception.  It was never a reliable flag for that purpose,
	 * being totally open to false positives even without actual
	 * clobberage, but was useful enough for production code to
	 * semantically rely on it.
	 *
	 * We'd like to have a proper introspective interface that
	 * explicitly describes the reason for whatever unwinding
	 * operations are currently in progress, so that those modules
	 * work reliably and $@@ isn't further overloaded.  But we don't
	 * have one yet.  In its absence, as a stopgap measure, ERRSV is
	 * now *additionally* set here, before unwinding, to serve as the
	 * (unreliable) flag that it used to.
	 *
	 * This behaviour is temporary, and should be removed when a
	 * proper way to detect exceptional unwinding has been developed.
	 * As of 2010-12, the authors of modules relying on the hack
	 * are aware of the issue, because the modules failed on
	 * perls 5.13.{1..7} which had late setting of $@@ without this
	 * early-setting hack.
	 */
	if (!(in_eval & EVAL_KEEPERR)) {
	    SvTEMP_off(exceptsv);
	    sv_setsv(ERRSV, exceptsv);
a1624 3
	    COP *oldcop;
	    JMPENV *restartjmpenv;
	    OP *restartop;
d1632 1
a1632 1
		const char* message = SvPVx_const(exceptsv, msglen);
a1638 3
	    oldcop = cx->blk_oldcop;
	    restartjmpenv = cx->blk_eval.cur_top_env;
	    restartop = cx->blk_eval.retop;
d1650 1
a1650 1
	    PL_curcop = oldcop;
d1653 1
d1655 1
a1655 2
                               SvPVX_const(namesv),
                               SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv),
d1657 2
a1658 11
		/* note that unlike pp_entereval, pp_require isn't
		 * supposed to trap errors. So now that we've popped the
		 * EVAL that pp_require pushed, and processed the error
		 * message, rethrow the error */
		Perl_croak(aTHX_ "%"SVf"Compilation failed in require",
			   SVfARG(exceptsv ? exceptsv : newSVpvs_flags("Unknown error\n",
                                                                    SVs_TEMP)));
	    }
	    if (in_eval & EVAL_KEEPERR) {
		Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "\t(in cleanup) %"SVf,
			       SVfARG(exceptsv));
d1660 2
a1661 5
	    else {
		sv_setsv(ERRSV, exceptsv);
	    }
	    PL_restartjmpenv = restartjmpenv;
	    PL_restartop = restartop;
d1667 1
a1667 1
    write_to_stderr(exceptsv);
d1681 1
a1681 21
/*
=for apidoc caller_cx

The XSUB-writer's equivalent of L<caller()|perlfunc/caller>. The
returned C<PERL_CONTEXT> structure can be interrogated to find all the
information returned to Perl by C<caller>. Note that XSUBs don't get a
stack frame, so C<caller_cx(0, NULL)> will return information for the
immediately-surrounding Perl code.

This function skips over the automatic calls to C<&DB::sub> made on the
behalf of the debugger. If the stack frame requested was a sub called by
C<DB::sub>, the return value will be the frame for the call to
C<DB::sub>, since that has the correct line number/etc. for the call
site. If I<dbcxp> is non-C<NULL>, it will be set to a pointer to the
frame for the sub call itself.

=cut
*/

const PERL_CONTEXT *
Perl_caller_cx(pTHX_ I32 count, const PERL_CONTEXT **dbcxp)
d1683 2
d1689 6
d1703 7
a1709 2
	if (cxix < 0)
	    return NULL;
a1719 2
    if (dbcxp) *dbcxp = cx;

d1729 1
a1729 30
    return cx;
}

PP(pp_caller)
{
    dVAR;
    dSP;
    register const PERL_CONTEXT *cx;
    const PERL_CONTEXT *dbcx;
    I32 gimme;
    const HEK *stash_hek;
    I32 count = 0;
    bool has_arg = MAXARG && TOPs;

    if (MAXARG) {
      if (has_arg)
	count = POPi;
      else (void)POPs;
    }

    cx = caller_cx(count + !!(PL_op->op_private & OPpOFFBYONE), &dbcx);
    if (!cx) {
	if (GIMME != G_ARRAY) {
	    EXTEND(SP, 1);
	    RETPUSHUNDEF;
	}
	RETURN;
    }

    stash_hek = HvNAME_HEK((HV*)CopSTASH(cx->blk_oldcop));
d1732 1
a1732 1
	if (!stash_hek)
d1736 1
a1736 1
	    sv_sethek(TARG, stash_hek);
d1744 1
a1744 1
    if (!stash_hek)
d1746 2
a1747 5
    else {
	dTARGET;
	sv_sethek(TARG, stash_hek);
	PUSHTARG;
    }
d1750 1
a1750 1
    if (!has_arg)
d1753 1
a1753 1
	GV * const cvgv = CvGV(dbcx->blk_sub.cv);
d1802 2
a1803 1
	Perl_init_dbargs(aTHX);
d1840 3
a1842 1
	  sv_2mortal(newRV_noinc(MUTABLE_SV(cop_hints_2hv(cx->blk_oldcop, 0))))
d1851 1
a1851 2
    const char * const tmps =
	(MAXARG < 1 || (!TOPs && !POPs)) ? (const char *)"" : POPpconstx;
a1866 2
    PERL_ASYNC_CHECK();

a1915 79
STATIC SV **
S_adjust_stack_on_leave(pTHX_ SV **newsp, SV **sp, SV **mark, I32 gimme, U32 flags)
{
    bool padtmp = 0;
    PERL_ARGS_ASSERT_ADJUST_STACK_ON_LEAVE;

    if (flags & SVs_PADTMP) {
	flags &= ~SVs_PADTMP;
	padtmp = 1;
    }
    if (gimme == G_SCALAR) {
	if (MARK < SP)
	    *++newsp = ((SvFLAGS(*SP) & flags) || (padtmp && SvPADTMP(*SP)))
			    ? *SP : sv_mortalcopy(*SP);
	else {
	    /* MEXTEND() only updates MARK, so reuse it instead of newsp. */
	    MARK = newsp;
	    MEXTEND(MARK, 1);
	    *++MARK = &PL_sv_undef;
	    return MARK;
	}
    }
    else if (gimme == G_ARRAY) {
	/* in case LEAVE wipes old return values */
	while (++MARK <= SP) {
	    if ((SvFLAGS(*MARK) & flags) || (padtmp && SvPADTMP(*MARK)))
		*++newsp = *MARK;
	    else {
		*++newsp = sv_mortalcopy(*MARK);
		TAINT_NOT;	/* Each item is independent */
	    }
	}
	/* When this function was called with MARK == newsp, we reach this
	 * point with SP == newsp. */
    }

    return newsp;
}

PP(pp_enter)
{
    dVAR; dSP;
    register PERL_CONTEXT *cx;
    I32 gimme = GIMME_V;

    ENTER_with_name("block");

    SAVETMPS;
    PUSHBLOCK(cx, CXt_BLOCK, SP);

    RETURN;
}

PP(pp_leave)
{
    dVAR; dSP;
    register PERL_CONTEXT *cx;
    SV **newsp;
    PMOP *newpm;
    I32 gimme;

    if (PL_op->op_flags & OPf_SPECIAL) {
	cx = &cxstack[cxstack_ix];
	cx->blk_oldpm = PL_curpm;	/* fake block should preserve $1 et al */
    }

    POPBLOCK(cx,newpm);

    gimme = OP_GIMME(PL_op, (cxstack_ix >= 0) ? gimme : G_SCALAR);

    TAINT_NOT;
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP);
    PL_curpm = newpm;	/* Don't pop $1 et al till now */

    LEAVE_with_name("block");

    RETURN;
}

d1921 1
a1921 1
    void *itervar; /* location of the iteration variable */
d1923 3
d1930 2
a1931 2
    if (PL_op->op_targ) {			 /* "my" variable */
	if (PL_op->op_private & OPpLVAL_INTRO) {        /* for my $x (...) */
d1937 2
a1938 2
#ifdef USE_ITHREADS
	itervar = PL_comppad;
d1940 1
a1940 1
	itervar = &PAD_SVl(PL_op->op_targ);
d1943 1
a1943 1
    else {					/* symbol table variable */
d1945 2
a1946 2
	SV** svp = &GvSV(gv);
	save_pushptrptr(gv, SvREFCNT_inc(*svp), SAVEt_GVSV);
d1948 3
a1950 1
	itervar = (void *)gv;
d1959 5
a1963 1
    PUSHLOOP_FOR(cx, itervar, MARK);
d1978 2
a1979 2
		if ((SvOK(sv) && ((SvNV_nomg(sv) < (NV)IV_MIN) ||
				  (SvNV_nomg(sv) > (NV)IV_MAX)))
d1981 2
a1982 2
		    (SvOK(right) && ((SvNV_nomg(right) > (NV)IV_MAX) ||
				     (SvNV_nomg(right) < (NV)IV_MIN))))
d1984 1
a1984 1
		if ((SvOK(sv) && ((SvNV_nomg(sv) <= (NV)IV_MIN)
d1986 3
a1988 3
		                  ((SvNV_nomg(sv) > 0) &&
					((SvUV_nomg(sv) > (UV)IV_MAX) ||
					 (SvNV_nomg(sv) > (NV)UV_MAX)))))
d1990 1
a1990 1
		    (SvOK(right) && ((SvNV_nomg(right) <= (NV)IV_MIN)
d1992 3
a1994 4
				     ((SvNV_nomg(right) > 0) &&
					((SvUV_nomg(right) > (UV)IV_MAX) ||
					 (SvNV_nomg(right) > (NV)UV_MAX))
				     ))))
d1997 2
a1998 2
		cx->blk_loop.state_u.lazyiv.cur = SvIV_nomg(sv);
		cx->blk_loop.state_u.lazyiv.end = SvIV_nomg(right);
d2078 15
a2092 1
    SP = adjust_stack_on_leave(newsp, SP, MARK, gimme, 0);
a2103 110
STATIC void
S_return_lvalues(pTHX_ SV **mark, SV **sp, SV **newsp, I32 gimme,
                       PERL_CONTEXT *cx, PMOP *newpm)
{
    const bool ref = !!(CxLVAL(cx) & OPpENTERSUB_INARGS);
    if (gimme == G_SCALAR) {
	if (CxLVAL(cx) && !ref) {     /* Leave it as it is if we can. */
	    SV *sv;
	    const char *what = NULL;
	    if (MARK < SP) {
		assert(MARK+1 == SP);
		if ((SvPADTMP(TOPs) ||
		     (SvFLAGS(TOPs) & (SVf_READONLY | SVf_FAKE))
		       == SVf_READONLY
		    ) &&
		    !SvSMAGICAL(TOPs)) {
		    what =
			SvREADONLY(TOPs) ? (TOPs == &PL_sv_undef) ? "undef"
			: "a readonly value" : "a temporary";
		}
		else goto copy_sv;
	    }
	    else {
		/* sub:lvalue{} will take us here. */
		what = "undef";
	    }
	    LEAVE;
	    cxstack_ix--;
	    POPSUB(cx,sv);
	    PL_curpm = newpm;
	    LEAVESUB(sv);
	    Perl_croak(aTHX_
	              "Can't return %s from lvalue subroutine", what
	    );
	}
	if (MARK < SP) {
	      copy_sv:
		if (cx->blk_sub.cv && CvDEPTH(cx->blk_sub.cv) > 1) {
		    if (!SvPADTMP(*SP)) {
			*++newsp = SvREFCNT_inc(*SP);
			FREETMPS;
			sv_2mortal(*newsp);
		    }
		    else {
			/* FREETMPS could clobber it */
			SV *sv = SvREFCNT_inc(*SP);
			FREETMPS;
			*++newsp = sv_mortalcopy(sv);
			SvREFCNT_dec(sv);
		    }
		}
		else
		    *++newsp =
		      SvPADTMP(*SP)
		       ? sv_mortalcopy(*SP)
		       : !SvTEMP(*SP)
		          ? sv_2mortal(SvREFCNT_inc_simple_NN(*SP))
		          : *SP;
	}
	else {
	    EXTEND(newsp,1);
	    *++newsp = &PL_sv_undef;
	}
	if (CxLVAL(cx) & OPpDEREF) {
	    SvGETMAGIC(TOPs);
	    if (!SvOK(TOPs)) {
		TOPs = vivify_ref(TOPs, CxLVAL(cx) & OPpDEREF);
	    }
	}
    }
    else if (gimme == G_ARRAY) {
	assert (!(CxLVAL(cx) & OPpDEREF));
	if (ref || !CxLVAL(cx))
	    while (++MARK <= SP)
		*++newsp =
		       SvFLAGS(*MARK) & SVs_PADTMP
		           ? sv_mortalcopy(*MARK)
		     : SvTEMP(*MARK)
		           ? *MARK
		           : sv_2mortal(SvREFCNT_inc_simple_NN(*MARK));
	else while (++MARK <= SP) {
	    if (*MARK != &PL_sv_undef
		    && (SvPADTMP(*MARK)
		       || (SvFLAGS(*MARK) & (SVf_READONLY|SVf_FAKE))
		             == SVf_READONLY
		       )
	    ) {
		    SV *sv;
		    /* Might be flattened array after $#array =  */
		    PUTBACK;
		    LEAVE;
		    cxstack_ix--;
		    POPSUB(cx,sv);
		    PL_curpm = newpm;
		    LEAVESUB(sv);
	       /* diag_listed_as: Can't return %s from lvalue subroutine */
		    Perl_croak(aTHX_
			"Can't return a %s from lvalue subroutine",
			SvREADONLY(TOPs) ? "readonly value" : "temporary");
	    }
	    else
		*++newsp =
		    SvTEMP(*MARK)
		       ? *MARK
		       : sv_2mortal(SvREFCNT_inc_simple_NN(*MARK));
	}
    }
    PL_stack_sp = newsp;
}

a2109 1
    bool lval = FALSE;
a2149 1
	lval = !!CvLVALUE(cx->blk_sub.cv);
d2161 1
d2167 1
a2167 2
			    SvPVX_const(namesv),
                            SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv),
d2177 1
a2177 1
	DIE(aTHX_ "panic: return, type=%u", (unsigned) CxTYPE(cx));
d2181 1
a2181 3
    if (lval) S_return_lvalues(aTHX_ MARK, SP, newsp, gimme, cx, newpm);
    else {
      if (gimme == G_SCALAR) {
d2185 1
a2185 2
		    if (SvTEMP(TOPs) && SvREFCNT(TOPs) == 1
			 && !SvMAGICAL(TOPs)) {
a2196 4
		else if (SvTEMP(*SP) && SvREFCNT(*SP) == 1
			  && !SvMAGICAL(*SP)) {
		    *++newsp = *SP;
		}
d2198 1
a2198 1
		    *++newsp = sv_mortalcopy(*SP);
d2205 2
a2206 2
      }
      else if (gimme == G_ARRAY) {
d2208 1
a2208 2
	    *++newsp = popsub2 && SvTEMP(*MARK) && SvREFCNT(*MARK) == 1
			       && !SvGMAGICAL(*MARK)
a2211 2
      }
      PL_stack_sp = newsp;
d2213 1
a2231 30
/* This duplicates parts of pp_leavesub, so that it can share code with
 * pp_return */
PP(pp_leavesublv)
{
    dVAR; dSP;
    SV **newsp;
    PMOP *newpm;
    I32 gimme;
    register PERL_CONTEXT *cx;
    SV *sv;

    if (CxMULTICALL(&cxstack[cxstack_ix]))
	return 0;

    POPBLOCK(cx,newpm);
    cxstack_ix++; /* temporarily protect top context */

    TAINT_NOT;

    S_return_lvalues(aTHX_ newsp, SP, newsp, gimme, cx, newpm);

    LEAVE;
    cxstack_ix--;
    POPSUB(cx,sv);	/* Stack values are safe: release CV and @@_ ... */
    PL_curpm = newpm;	/* ... and pop $1 et al */

    LEAVESUB(sv);
    return cx->blk_sub.retop;
}

d2253 1
a2253 2
        cxix = dopoptolabel(cPVOP->op_pv, strlen(cPVOP->op_pv),
                           (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0);
d2255 1
a2255 5
	    DIE(aTHX_ "Label not found for \"last %"SVf"\"",
                                        SVfARG(newSVpvn_flags(cPVOP->op_pv,
                                                    strlen(cPVOP->op_pv),
                                                    ((cPVOP->op_private & OPpPV_IS_UTF8)
                                                    ? SVf_UTF8 : 0) | SVs_TEMP)));
d2285 17
a2301 1
	DIE(aTHX_ "panic: last, type=%u", (unsigned) CxTYPE(cx));
d2303 1
a2303 4

    TAINT_NOT;
    SP = adjust_stack_on_leave(newsp, SP, MARK, gimme,
				pop2 == CXt_SUB ? SVs_TEMP : 0);
d2342 3
a2344 8
	cxix = dopoptolabel(cPVOP->op_pv, strlen(cPVOP->op_pv),
                           (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0);
 	if (cxix < 0)
	    DIE(aTHX_ "Label not found for \"next %"SVf"\"",
                                        SVfARG(newSVpvn_flags(cPVOP->op_pv, 
                                                    strlen(cPVOP->op_pv),
                                                    ((cPVOP->op_private & OPpPV_IS_UTF8)
                                                    ? SVf_UTF8 : 0) | SVs_TEMP)));
d2356 1
a2356 1
    return (cx)->blk_loop.my_op->op_nextop;
d2373 3
a2375 8
	cxix = dopoptolabel(cPVOP->op_pv, strlen(cPVOP->op_pv),
                           (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0);
 	if (cxix < 0)
	    DIE(aTHX_ "Label not found for \"redo %"SVf"\"",
                                        SVfARG(newSVpvn_flags(cPVOP->op_pv,
                                                    strlen(cPVOP->op_pv),
                                                    ((cPVOP->op_private & OPpPV_IS_UTF8)
                                                    ? SVf_UTF8 : 0) | SVs_TEMP)));
d2397 1
a2397 1
S_dofindlabel(pTHX_ OP *o, const char *label, STRLEN len, U32 flags, OP **opstack, OP **oplimit)
d2423 2
a2424 15
                STRLEN kid_label_len;
                U32 kid_label_flags;
		const char *kid_label = CopLABEL_len_flags(kCOP,
                                                    &kid_label_len, &kid_label_flags);
		if (kid_label && (
                    ( (kid_label_flags & SVf_UTF8) != (flags & SVf_UTF8) ) ?
                        (flags & SVf_UTF8)
                            ? (bytes_cmp_utf8(
                                        (const U8*)kid_label, kid_label_len,
                                        (const U8*)label, len) == 0)
                            : (bytes_cmp_utf8(
                                        (const U8*)label, len,
                                        (const U8*)kid_label, kid_label_len) == 0)
                    : ( len == kid_label_len && ((kid_label == label)
                                    || memEQ(kid_label, label, len)))))
d2440 1
a2440 1
	    if ((o = dofindlabel(kid, label, len, flags, ops, oplimit)))
a2456 2
    STRLEN label_len = 0;
    U32 label_flags = 0;
d2482 2
a2483 3
		    autogv = gv_autoload_pvn(GvSTASH(gv), GvNAME(gv),
					  GvNAMELEN(gv),
                                          GvNAMEUTF8(gv) ? SVf_UTF8 : 0);
a2505 1
		/* diag_listed_as: Can't goto subroutine from an eval-%s */
a2507 1
		/* diag_listed_as: Can't goto subroutine from an eval-%s */
a2545 13
	    /* A destructor called during LEAVE_SCOPE could have undefined
	     * our precious cv.  See bug #99850. */
	    if (!CvROOT(cv) && !CvXSUB(cv)) {
		const GV * const gv = CvGV(cv);
		if (gv) {
		    SV * const tmpstr = sv_newmortal();
		    gv_efullname3(tmpstr, gv, NULL);
		    DIE(aTHX_ "Goto undefined subroutine &%"SVf"",
			       SVfARG(tmpstr));
		}
		DIE(aTHX_ "Goto undefined subroutine");
	    }

d2551 2
a2552 2
		SV **newsp PERL_UNUSED_DECL;
		I32 gimme PERL_UNUSED_DECL;
a2585 1
		PL_curcop = cx->blk_oldcop;
d2640 1
a2640 2
	    label       = SvPV_const(sv, label_len);
            label_flags = SvUTF8(sv);
d2649 2
a2650 7
    else {
 	label       = cPVOP->op_pv;
        label_flags = (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0;
        label_len   = strlen(label);
    }

    PERL_ASYNC_CHECK();
d2703 1
a2703 2
		    DIE(aTHX_ "panic: goto, type=%u, ix=%ld",
			CxTYPE(cx), (long) ix);
d2708 1
a2708 1
		retop = dofindlabel(gotoprobe, label, label_len, label_flags,
a2711 9
		if (gotoprobe->op_sibling &&
			gotoprobe->op_sibling->op_type == OP_UNSTACK &&
			gotoprobe->op_sibling->op_sibling) {
		    retop = dofindlabel(gotoprobe->op_sibling->op_sibling,
					label, label_len, label_flags, enterops,
					enterops + GOTO_DEPTH);
		    if (retop)
			break;
		}
d2716 1
a2716 3
	    DIE(aTHX_ "Can't find label %"SVf,
                            SVfARG(newSVpvn_flags(label, label_len,
                                        SVs_TEMP | label_flags)));
d2759 1
a2759 1
		PL_op->op_ppaddr(aTHX);
a2788 3
    else if (!TOPs) {
	anum = 0; (void)POPs;
    }
d2874 11
a2884 2
	if (PL_restartop && PL_restartjmpenv == PL_top_env) {
	    PL_restartjmpenv = NULL;
a2907 2

   Hence it's now deprecated, and will be removed.
a2914 10
    PERL_ARGS_ASSERT_SV_COMPILE_2OP;
    return Perl_sv_compile_2op_is_broken(aTHX_ sv, startop, code, padp);
}

/* Don't use this. It will go away without warning once the regexp engine is
   refactored not to use it.  */
OP *
Perl_sv_compile_2op_is_broken(pTHX_ SV *sv, OP **startop, const char *code,
			      PAD **padp)
{
a2926 1
    bool need_catch;
d2928 1
a2928 1
    PERL_ARGS_ASSERT_SV_COMPILE_2OP_IS_BROKEN;
d2931 1
a2931 1
    lex_start(sv, NULL, LEX_START_SAME_FILTER);
a2970 1
    {
a2972 18
	/* At run time, we have to fetch the hints from PL_curcop. */
	PL_hints = PL_curcop->cop_hints;
	if (PL_hints & HINT_LOCALIZE_HH) {
	    /* SAVEHINTS created a new HV in PL_hintgv, which we
	       need to GC */
	    SvREFCNT_dec(GvHV(PL_hintgv));
	    GvHV(PL_hintgv) =
	     refcounted_he_chain_2hv(PL_curcop->cop_hints_hash, 0);
	    hv_magic(GvHV(PL_hintgv), NULL, PERL_MAGIC_hints);
	}
	SAVECOMPILEWARNINGS();
	PL_compiling.cop_warnings = DUP_WARNINGS(PL_curcop->cop_warnings);
	cophh_free(CopHINTHASH_get(&PL_compiling));
	/* XXX Does this need to avoid copying a label? */
	PL_compiling.cop_hints_hash
	 = cophh_copy(PL_curcop->cop_hints_hash);
    }

a2977 2
    need_catch = CATCH_GET;
    CATCH_SET(TRUE);
d2980 1
a2980 1
	(void) doeval(G_SCALAR, startop, runcv, PL_curcop->cop_seq, NULL);
d2982 1
a2982 2
	(void) doeval(G_SCALAR, startop, PL_compcv, PL_cop_seqmax, NULL);
    CATCH_SET(need_catch);
d2988 1
d3038 1
a3038 1
		return cx->blk_eval.cv;
a3044 29
/* Run yyparse() in a setjmp wrapper. Returns:
 *   0: yyparse() successful
 *   1: yyparse() failed
 *   3: yyparse() died
 */
STATIC int
S_try_yyparse(pTHX_ int gramtype)
{
    int ret;
    dJMPENV;

    assert(CxTYPE(&cxstack[cxstack_ix]) == CXt_EVAL);
    JMPENV_PUSH(ret);
    switch (ret) {
    case 0:
	ret = yyparse(gramtype) ? 1 : 0;
	break;
    case 3:
	break;
    default:
	JMPENV_POP;
	JMPENV_JUMP(ret);
	/* NOTREACHED */
    }
    JMPENV_POP;
    return ret;
}


a3053 7
/* This function is called from three places, sv_compile_2op, pp_require
 * and pp_entereval.  These can be distinguished as follows:
 *    sv_compile_2op - startop is non-null
 *    pp_require     - startop is null; saveop is not entereval
 *    pp_entereval   - startop is null; saveop is entereval
 */

d3055 1
a3055 1
S_doeval(pTHX_ int gimme, OP** startop, CV* outside, U32 seq, HV *hh)
a3058 4
    COP * const oldcurcop = PL_curcop;
    bool in_require = (saveop && saveop->op_type == OP_REQUIRE);
    int yystatus;
    CV *evalcv;
d3060 1
a3060 1
    PL_in_eval = (in_require
d3066 3
a3068 2
    evalcv = MUTABLE_CV(newSV_type(SVt_PVCV));
    CvEVAL_on(evalcv);
d3070 1
a3070 2
    cxstack[cxstack_ix].blk_eval.cv = evalcv;
    cxstack[cxstack_ix].blk_gimme = gimme;
d3072 2
a3073 2
    CvOUTSIDE_SEQ(evalcv) = seq;
    CvOUTSIDE(evalcv) = MUTABLE_CV(SvREFCNT_inc_simple(outside));
d3077 1
a3077 1
    CvPADLIST(evalcv) = pad_new(padnew_SAVE);
d3082 1
a3082 1
	SAVEMORTALIZESV(evalcv);	/* must remain until end of current statement */
d3087 2
a3088 2
	SAVEGENERICSV(PL_curstash);
	PL_curstash = (HV *)SvREFCNT_inc_simple(CopSTASH(PL_curcop));
a3102 4
    if (!startop) ENTER_with_name("evalcomp");
    SAVESPTR(PL_compcv);
    PL_compcv = evalcv;

d3107 1
d3112 1
a3112 52

    if (!startop) {
	bool clear_hints = saveop->op_type != OP_ENTEREVAL;
	SAVEHINTS();
	if (clear_hints) {
	    PL_hints = 0;
	    hv_clear(GvHV(PL_hintgv));
	}
	else {
	    PL_hints = saveop->op_private & OPpEVAL_COPHH
			 ? oldcurcop->cop_hints : saveop->op_targ;
	    if (hh) {
		/* SAVEHINTS created a new HV in PL_hintgv, which we need to GC */
		SvREFCNT_dec(GvHV(PL_hintgv));
		GvHV(PL_hintgv) = hh;
	    }
	}
	SAVECOMPILEWARNINGS();
	if (clear_hints) {
	    if (PL_dowarn & G_WARN_ALL_ON)
	        PL_compiling.cop_warnings = pWARN_ALL ;
	    else if (PL_dowarn & G_WARN_ALL_OFF)
	        PL_compiling.cop_warnings = pWARN_NONE ;
	    else
	        PL_compiling.cop_warnings = pWARN_STD ;
	}
	else {
	    PL_compiling.cop_warnings =
		DUP_WARNINGS(oldcurcop->cop_warnings);
	    cophh_free(CopHINTHASH_get(&PL_compiling));
	    if (Perl_cop_fetch_label(aTHX_ oldcurcop, NULL, NULL)) {
		/* The label, if present, is the first entry on the chain. So rather
		   than writing a blank label in front of it (which involves an
		   allocation), just use the next entry in the chain.  */
		PL_compiling.cop_hints_hash
		    = cophh_copy(oldcurcop->cop_hints_hash->refcounted_he_next);
		/* Check the assumption that this removed the label.  */
		assert(Perl_cop_fetch_label(aTHX_ &PL_compiling, NULL, NULL) == NULL);
	    }
	    else
		PL_compiling.cop_hints_hash = cophh_copy(oldcurcop->cop_hints_hash);
	}
    }

    CALL_BLOCK_HOOKS(bhk_eval, saveop);

    /* note that yyparse() may raise an exception, e.g. C<BEGIN{die}>,
     * so honour CATCH_GET and trap it here if necessary */

    yystatus = (!in_require && CATCH_GET) ? S_try_yyparse(aTHX_ GRAMPROG) : yyparse(GRAMPROG);

    if (yystatus || PL_parser->error_count || !PL_eval_root) {
d3114 4
a3117 8
	PERL_CONTEXT *cx;
	I32 optype;			/* Used by POPEVAL. */
	SV *namesv;

	cx = NULL;
	namesv = NULL;
	PERL_UNUSED_VAR(newsp);
	PERL_UNUSED_VAR(optype);
a3118 2
	/* note that if yystatus == 3, then the EVAL CX block has already
	 * been popped, and various vars restored */
d3120 9
a3128 13
	if (yystatus != 3) {
	    if (PL_eval_root) {
		op_free(PL_eval_root);
		PL_eval_root = NULL;
	    }
	    SP = PL_stack_base + POPMARK;	/* pop original mark */
	    if (!startop) {
		POPBLOCK(cx,PL_curpm);
		POPEVAL(cx);
		namesv = cx->blk_eval.old_namesv;
	    }
	    /* POPBLOCK renders LEAVE_with_name("evalcomp") unnecessary. */
	    LEAVE_with_name("eval"); /* pp_entereval knows about this LEAVE.  */
d3130 2
d3133 2
a3134 1
	if (in_require) {
d3143 1
a3143 2
			   SvPVX_const(namesv),
                           SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv),
d3145 2
a3146 4
	    Perl_croak(aTHX_ "%"SVf"Compilation failed in require",
		       SVfARG(ERRSV
                                ? ERRSV
                                : newSVpvs_flags("Unknown error\n", SVs_TEMP)));
d3149 4
a3152 8
	    if (yystatus != 3) {
		POPBLOCK(cx,PL_curpm);
		POPEVAL(cx);
	    }
	    Perl_croak(aTHX_ "%"SVf"Compilation failed in regexp",
		       SVfARG(ERRSV
                                ? ERRSV
                                : newSVpvs_flags("Unknown error\n", SVs_TEMP)));
d3155 1
a3155 1
	    if (!*(SvPVx_nolen_const(ERRSV))) {
d3159 2
a3160 1
	if (gimme != G_ARRAY) PUSHs(&PL_sv_undef);
a3163 1
    else if (!startop) LEAVE_with_name("evalcomp");
d3170 9
d3193 1
a3193 2
    if (PL_unitcheckav) {
	OP *es = PL_eval_start;
a3194 2
	PL_eval_start = es;
    }
d3198 1
a3198 1
    CvDEPTH(evalcv) = 1;
d3208 1
a3208 1
S_check_type_and_open(pTHX_ SV *name)
d3211 1
a3211 2
    const char *p = SvPV_nolen_const(name);
    const int st_rc = PerlLIO_stat(p, &st);
d3219 1
a3219 5
#if !defined(PERLIO_IS_STDIO) && !defined(USE_SFIO)
    return PerlIO_openn(aTHX_ ":", PERL_SCRIPT_MODE, -1, 0, 0, NULL, 1, &name);
#else
    return PerlIO_open(p, PERL_SCRIPT_MODE);
#endif
d3224 1
a3224 1
S_doopen_pm(pTHX_ SV *name)
d3226 1
a3226 2
    STRLEN namelen;
    const char *p = SvPV_const(name, namelen);
d3230 3
a3232 2
    if (namelen > 3 && memEQs(p + namelen - 3, 3, ".pm")) {
	SV *const pmcsv = sv_newmortal();
d3235 3
a3237 2
	SvSetSV_nosteal(pmcsv,name);
	sv_catpvn(pmcsv, "c", 1);
d3239 7
a3245 2
	if (PerlLIO_stat(SvPV_nolen_const(pmcsv), &pmcstat) >= 0)
	    return check_type_and_open(pmcsv);
d3247 4
a3250 1
    return check_type_and_open(name);
d3253 1
a3253 1
#  define doopen_pm(name) check_type_and_open(name)
d3282 1
a3282 1
	sv = sv_2mortal(new_version(sv));
d3288 1
a3288 3
		    SVfARG(sv_2mortal(vnormal(sv))),
		    SVfARG(sv_2mortal(vnormal(PL_patchlevel)))
		);
d3307 2
a3308 4
		    	"%"SVf", stopped",
			SVfARG(sv_2mortal(vnormal(req))),
			SVfARG(sv_2mortal(vnormal(PL_patchlevel)))
		    );
d3324 3
a3326 4
			SVfARG(sv_2mortal(vnormal(req))),
			SVfARG(sv_2mortal(vnormal(sv_2mortal(hintsv)))),
			SVfARG(sv_2mortal(vnormal(PL_patchlevel)))
		    );
d3331 17
a3390 1
	/* At this point, name is SvPVX(sv)  */
d3392 1
a3392 1
	tryrsfp = doopen_pm(sv);
d3572 3
a3574 1
			SvPOK_on(namesv);
d3580 1
a3580 1
		    tryrsfp = doopen_pm(namesv);
d3596 3
a3598 1
    sv_2mortal(namesv);
d3601 1
d3603 4
a3606 2
		/* diag_listed_as: Can't locate %s */
		DIE(aTHX_ "Can't locate %s:   %s", name, Strerror(errno));
d3611 9
a3619 1
		    SV *const inc = newSVpvs_flags("", SVs_TEMP);
d3621 2
a3622 2
			sv_catpvs(inc, " ");
			sv_catsv(inc, *av_fetch(ar, i, TRUE));
d3624 3
a3626 12

		    /* diag_listed_as: Can't locate %s */
		    DIE(aTHX_
			"Can't locate %s in @@INC%s%s (@@INC contains:%" SVf ")",
			name,
			(memEQ(name + len - 2, ".h", 3)
			 ? " (change .h to .ph maybe?) (did you run h2ph?)" : ""),
			(memEQ(name + len - 3, ".ph", 4)
			 ? " (did you run h2ph?)" : ""),
			inc
			);
		}
d3628 1
a3628 1
	    DIE(aTHX_ "Can't locate %s", name);
d3641 1
a3641 1
		       unixname, unixlen, newSVpv(tryname,0),0);
d3651 13
a3663 3
    SAVECOPFILE_FREE(&PL_compiling);
    CopFILE_set(&PL_compiling, tryname);
    lex_start(NULL, tryrsfp, 0);
d3690 1
a3690 1
    if (doeval(gimme, NULL, NULL, PL_curcop->cop_seq, NULL))
d3709 1
a3709 1
    mXPUSHs(MUTABLE_SV(hv_copy_hints_hv(MUTABLE_HV(cSVOP_sv))));
a3721 1
    bool saved_delete = FALSE;
d3725 1
a3725 1
    U32 seq, lex_flags = 0;
a3726 1
    const bool bytes = PL_op->op_private & OPpEVAL_BYTES;
a3730 7
    else if (PL_hints & HINT_LOCALIZE_HH || (
	        PL_op->op_private & OPpEVAL_COPHH
	     && PL_curcop->cop_hints & HINT_LOCALIZE_HH
	    )) {
	saved_hh = cop_hints_2hv(PL_curcop, 0);
	hv_magic(saved_hh, NULL, PERL_MAGIC_hints);
    }
a3731 21
    if (!SvPOK(sv)) {
	/* make sure we've got a plain PV (no overload etc) before testing
	 * for taint. Making a copy here is probably overkill, but better
	 * safe than sorry */
	STRLEN len;
	const char * const p = SvPV_const(sv, len);

	sv = newSVpvn_flags(p, len, SVs_TEMP | SvUTF8(sv));
	lex_flags |= LEX_START_COPIED;

	if (bytes && SvUTF8(sv))
	    SvPVbyte_force(sv, len);
    }
    else if (bytes && SvUTF8(sv)) {
	/* Don't modify someone else's scalar */
	STRLEN len;
	sv = newSVsv(sv);
	(void)sv_2mortal(sv);
	SvPVbyte_force(sv,len);
	lex_flags |= LEX_START_COPIED;
    }
d3737 1
a3737 5
    lex_start(sv, NULL, lex_flags | (PL_op->op_private & OPpEVAL_UNICODE
			   ? LEX_IGNORE_UTF8_HINTS
			   : bytes ? LEX_EVALBYTES : LEX_START_SAME_FILTER
			)
	     );
d3756 34
a3804 11
    else {
	/* XXX For C<eval "...">s within BEGIN {} blocks, this ends up
	   deleting the eval's FILEGV from the stash before gv_check() runs
	   (i.e. before run-time proper). To work around the coredump that
	   ensues, we always turn GvMULTI_on for any globals that were
	   introduced within evals. See force_ident(). GSAR 96-10-12 */
	char *const safestr = savepvn(tmpbuf, len);
	SAVEDELETE(PL_defstash, safestr, len);
	saved_delete = TRUE;
    }
    
d3807 1
a3807 1
    if (doeval(gimme, NULL, runcv, seq, saved_hh)) {
d3812 1
a3812 1
	} else if (!saved_delete) {
d3818 1
a3818 1
	/* We have already left the scope set up earlier thanks to the LEAVE
d3824 1
a3824 1
	} else if (!saved_delete) {
d3834 1
a3842 1
    CV *evalcv;
a3843 1
    PERL_ASYNC_CHECK();
a3847 1
    evalcv = cx->blk_eval.cv;
d3850 25
a3874 2
    SP = adjust_stack_on_leave((gimme == G_VOID) ? SP : newsp, SP, newsp,
				gimme, SVs_TEMP);
d3878 1
a3878 1
    assert(CvDEPTH(evalcv) == 1);
d3880 2
a3881 1
    CvDEPTH(evalcv) = 0;
d3888 1
a3888 2
			SvPVX_const(namesv),
                        SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv),
d3891 2
a3892 2
			       SVfARG(namesv));
	/* die_unwind() did LEAVE, or we won't be here */
a3965 1
    PERL_ASYNC_CHECK();
d3971 27
a3997 1
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP);
d4014 1
a4014 2
    SAVECLEARSV(PAD_SVl(PL_op->op_targ));
    sv_setsv_mg(PAD_SV(PL_op->op_targ), POPs);
d4034 4
a4037 3
    TAINT_NOT;
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP);
    PL_curpm = newpm;	/* Don't pop $1 et al till now */
d4040 2
a4041 1
    RETURN;
d4072 1
a4072 1
    (void) Perl_pp_match(aTHX);
d4093 1
a4093 1
    return do_smartmatch(NULL, NULL, 0);
d4100 1
a4100 1
S_do_smartmatch(pTHX_ HV *seen_this, HV *seen_other, const bool copied)
a4108 13
    /* Take care only to invoke mg_get() once for each argument.
     * Currently we do this by copying the SV if it's magical. */
    if (d) {
	if (!copied && SvGMAGICAL(d))
	    d = sv_mortalcopy(d);
    }
    else
	d = &PL_sv_undef;

    assert(e);
    if (SvGMAGICAL(e))
	e = sv_mortalcopy(e);

d4115 1
a4115 1
	tmpsv = amagic_call(d, e, smart_amg, AMGf_noleft);
d4127 12
d4422 1
a4422 1
			(void) do_smartmatch(seen_this, seen_other, 0);
d4484 1
a4484 1
		    (void) do_smartmatch(NULL, NULL, 1);
d4554 1
a4554 1
	    (void) Perl_pp_i_eq(aTHX);
d4556 1
a4556 1
	    (void) Perl_pp_eq(aTHX);
d4568 1
a4568 1
    return Perl_pp_seq(aTHX);
a4580 1
       RETURNOP calls PUTBACK which restores the stack pointer after the POPs.
d4583 1
a4583 1
	RETURNOP(cLOGOP->op_other->op_next);
d4585 1
a4585 1
    ENTER_with_name("when");
a4596 1
    I32 cxix;
a4601 6
    cxix = dopoptogiven(cxstack_ix);
    if (cxix < 0)
	/* diag_listed_as: Can't "when" outside a topicalizer */
	DIE(aTHX_ "Can't \"%s\" outside a topicalizer",
	           PL_op->op_flags & OPf_SPECIAL ? "default" : "when");

d4605 3
a4607 2
    TAINT_NOT;
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP);
d4610 2
a4611 20
    LEAVE_with_name("when");

    if (cxix < cxstack_ix)
        dounwind(cxix);

    cx = &cxstack[cxix];

    if (CxFOREACH(cx)) {
	/* clear off anything above the scope we're re-entering */
	I32 inner = PL_scopestack_ix;

	TOPBLOCK(cx);
	if (PL_scopestack_ix < inner)
	    leave_scope(PL_scopestack[PL_scopestack_ix]);
	PL_curcop = cx->blk_oldcop;

	return cx->blk_loop.my_op->op_nextop;
    }
    else
	RETURNOP(cx->blk_givwhen.leave_op);
d4616 1
a4616 1
    dVAR; dSP;
d4619 1
a4619 5
    I32 gimme;
    SV **newsp;
    PMOP *newpm;

    PERL_UNUSED_VAR(gimme);
a4623 1

d4627 7
a4633 8
    POPBLOCK(cx,newpm);
    assert(CxTYPE(cx) == CXt_WHEN);

    SP = newsp;
    PL_curpm = newpm;   /* pop $1 et al */

    LEAVE_with_name("when");
    RETURNOP(cx->blk_givwhen.leave_op->op_next);
d4641 2
a4642 1

d4644 7
a4650 5
    if (cxix < 0)
	DIE(aTHX_ "Can't \"break\" outside a given block");

    cx = &cxstack[cxix];
    if (CxFOREACH(cx))
d4655 3
a4657 2

    /* Restore the sp at the time we entered the given block */
d4659 3
d4663 4
a4666 1
    return cx->blk_givwhen.leave_op;
d4669 1
a4669 1
static MAGIC *
d4673 7
a4679 7
    register char *s = SvPV(sv, len);
    register char *send;
    register char *base = NULL; /* start of current field */
    register I32 skipspaces = 0; /* number of contiguous spaces seen */
    bool noblank   = FALSE; /* ~ or ~~ seen on this line */
    bool repeat    = FALSE; /* ~~ seen on this line */
    bool postspace = FALSE; /* a text field may need right padding */
d4682 1
a4682 1
    U32 *linepc = NULL;	    /* position of last FF_LINEMARK */
d4684 2
a4685 2
    bool ischop;	    /* it's a ^ rather than a @@ */
    bool unchopnum = FALSE; /* at least one @@ (i.e. non-chop) num field seen */
a4686 2
    MAGIC *mg = NULL;
    SV *sv_copy;
a4692 34
    if (SvTYPE(sv) >= SVt_PVMG) {
	/* This might, of course, still return NULL.  */
	mg = mg_find(sv, PERL_MAGIC_fm);
    } else {
	sv_upgrade(sv, SVt_PVMG);
    }

    if (mg) {
	/* still the same as previously-compiled string? */
	SV *old = mg->mg_obj;
	if ( !(!!SvUTF8(old) ^ !!SvUTF8(sv))
	      && len == SvCUR(old)
	      && strnEQ(SvPVX(old), SvPVX(sv), len)
	) {
	    DEBUG_f(PerlIO_printf(Perl_debug_log,"Re-using compiled format\n"));
	    return mg;
	}

	DEBUG_f(PerlIO_printf(Perl_debug_log, "Re-compiling format\n"));
	Safefree(mg->mg_ptr);
	mg->mg_ptr = NULL;
	SvREFCNT_dec(old);
	mg->mg_obj = NULL;
    }
    else {
	DEBUG_f(PerlIO_printf(Perl_debug_log, "Compiling format\n"));
	mg = sv_magicext(sv, NULL, PERL_MAGIC_fm, &PL_vtbl_fm, NULL, 0);
    }

    sv_copy = newSVpvn_utf8(s, len, SvUTF8(sv));
    s = SvPV(sv_copy, len); /* work on the copy, not the original */
    send = s + len;


d4720 1
a4720 2
		skipspaces++;
		s++;
d4723 1
d4741 1
a4741 1
		*fpc++ = (U32)arg;
d4748 1
a4748 1
		*fpc++ = (U32)skipspaces;
d4759 1
a4759 1
		*fpc++ = (U32)arg;
d4782 1
a4782 1
		*fpc++ = (U32)arg;
d4787 1
a4787 1
	    if (*s == '*') { /*  @@* or ^*  */
d4796 2
a4797 2
	    else if (*s == '#' || (*s == '.' && s[1] == '#')) { /* @@###, ^### */
		arg = ischop ? FORM_NUM_BLANK : 0;
d4805 1
a4805 1
		    arg |= FORM_NUM_POINT + (s - f);
d4809 1
a4809 1
                *fpc++ = (U32)arg;
d4813 1
a4813 1
                arg = ischop ? FORM_NUM_BLANK : 0;
d4822 1
a4822 1
                    arg |= FORM_NUM_POINT + (s - f);
d4826 1
a4826 1
		*fpc++ = (U32)arg;
d4829 1
a4829 1
	    else {				/* text field */
d4856 1
a4856 1
		    *fpc++ = (U32)prespace; /* add SPACE or HALFSPACE */
d4872 10
a4881 5

    mg->mg_ptr = (char *) fops;
    mg->mg_len = arg * sizeof(U32);
    mg->mg_obj = sv_copy;
    mg->mg_flags |= MGf_REFCOUNTED;
d4884 2
a4885 3
        Perl_die(aTHX_ "Repeated format line will never terminate (~~ and @@#)");

    return mg;
d4898 1
a4898 1
    if (frcsize & FORM_NUM_POINT)
d4900 1
a4900 1
    frcsize &= ~(FORM_NUM_POINT|FORM_NUM_BLANK);
d4967 1
a4967 1
		/* Definitely not EOF  */
@


1.1.1.15
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d72 3
d83 2
a84 3
    PMOP *pm = (PMOP*)cLOGOP->op_other;
    SV **args;
    int nargs;
a85 13
    REGEXP *new_re;
    const regexp_engine *eng;
    bool is_bare_re= FALSE;

    if (PL_op->op_flags & OPf_STACKED) {
	dMARK;
	nargs = SP - MARK;
	args  = ++MARK;
    }
    else {
	nargs = 1;
	args  = SP;
    }
d90 6
a95 1
	SP = args-1;
d100 15
a114 3
    re = PM_GETRE(pm);
    assert (re != (REGEXP*) &PL_sv_undef);
    eng = re ? RX_ENGINE(re) : current_re_engine();
d116 8
a123 2
    /*
     In the below logic: these are basically the same - check if this regcomp is part of a split.
d125 1
a125 2
    (PL_op->op_pmflags & PMf_split )
    (PL_op->op_next->op_type == OP_PUSHRE)
d127 6
a132 2
    We could add a new mask for this and copy the PMf_split, if we did
    some bit definition fiddling first.
d134 5
a138 2
    For now we leave this
    */
d140 1
a140 37
    new_re = (eng->op_comp
		    ? eng->op_comp
		    : &Perl_re_op_compile
	    )(aTHX_ args, nargs, pm->op_code_list, eng, re,
		&is_bare_re,
                (pm->op_pmflags & RXf_PMf_FLAGCOPYMASK),
		pm->op_pmflags |
		    (PL_op->op_flags & OPf_SPECIAL ? PMf_USE_RE_EVAL : 0));

    if (pm->op_pmflags & PMf_HAS_CV)
	ReANY(new_re)->qr_anoncv
			= (CV*) SvREFCNT_inc(PAD_SV(PL_op->op_targ));

    if (is_bare_re) {
	REGEXP *tmp;
	/* The match's LHS's get-magic might need to access this op's regexp
	   (e.g. $' =~ /$re/ while foo; see bug 70764).  So we must call
	   get-magic now before we replace the regexp. Hopefully this hack can
	   be replaced with the approach described at
	   http://www.nntp.perl.org/group/perl.perl5.porters/2007/03/msg122415.html
	   some day. */
	if (pm->op_type == OP_MATCH) {
	    SV *lhs;
	    const bool was_tainted = TAINT_get;
	    if (pm->op_flags & OPf_STACKED)
		lhs = args[-1];
	    else if (pm->op_private & OPpTARGET_MY)
		lhs = PAD_SV(pm->op_targ);
	    else lhs = DEFSV;
	    SvGETMAGIC(lhs);
	    /* Restore the previous value of PL_tainted (which may have been
	       modified by get-magic), to avoid incorrectly setting the
	       RXf_TAINTED flag with RX_TAINT_on further down. */
	    TAINT_set(was_tainted);
#if NO_TAINT_SUPPORT
            PERL_UNUSED_VAR(was_tainted);
#endif
d142 2
a143 3
	tmp = reg_temp_copy(NULL, new_re);
	ReREFCNT_dec(new_re);
	new_re = tmp;
d145 6
d152 33
a184 3
    if (re != new_re) {
	ReREFCNT_dec(re);
	PM_SETRE(pm, new_re);
d186 42
d229 11
d242 5
a246 3
    if (TAINTING_get && TAINT_get) {
	SvTAINTED_on((SV*)new_re);
        RX_TAINT_on(new_re);
d250 4
a256 2
    if (!RX_PRELEN(PM_GETRE(pm)) && PL_curpm)
	pm = PL_curpm;
a261 2

    SP = args-1;
a264 1

d269 5
a273 5
    PERL_CONTEXT *cx = &cxstack[cxstack_ix];
    PMOP * const pm = (PMOP*) cLOGOP->op_other;
    SV * const dstr = cx->sb_dstr;
    char *s = cx->sb_s;
    char *m = cx->sb_m;
d275 1
a275 1
    REGEXP * const rx = cx->sb_rx;
d305 7
d315 3
a317 1
                                (REXEC_IGNOREPOS|REXEC_NOT_FIRST)))
d324 1
a324 1
		      sv_catpvn_nomg_utf8_upgrade(dstr, s, cx->sb_strend - s, nsv);
d326 1
a326 1
		      sv_catpvn_nomg(dstr, s, cx->sb_strend - s);
a350 1
		PL_tainted = 0;
d359 1
a359 1
	    if (TAINTING_get) {
d371 2
a372 4
		TAINT_set(
                    cBOOL(cx->sb_rxtainted &
			  (SUBST_TAINT_STR|SUBST_TAINT_PAT|SUBST_TAINT_REPL))
                );
a379 1
	    PERL_ASYNC_CHECK();
d381 1
a381 1
	    assert(0); /* NOTREACHED */
a387 1
        assert(!RX_SUBOFFSET(rx));
d395 1
a395 1
	    sv_catpvn_nomg_utf8_upgrade(dstr, s, m - s, nsv);
d397 1
a397 1
	    sv_catpvn_nomg(dstr, s, m-s);
d420 1
a420 1
    if (TAINTING_get) {
d451 2
a452 2
#ifdef PERL_ANY_COW
	i = 7 + (RX_NPARENS(rx)+1) * 2;
d454 1
a454 1
	i = 6 + (RX_NPARENS(rx)+1) * 2;
a462 1
    /* what (if anything) to free on croak */
a464 1
    *p++ = RX_NPARENS(rx);
d466 1
a466 1
#ifdef PERL_ANY_COW
d471 2
a474 2
    *p++ = (UV)RX_SUBOFFSET(rx);
    *p++ = (UV)RX_SUBCOFFSET(rx);
a492 1
    RX_NPARENS(rx) = *p++;
d494 1
a494 1
#ifdef PERL_ANY_COW
d501 2
a504 2
    RX_SUBOFFSET(rx) = (I32)*p++;
    RX_SUBCOFFSET(rx) = (I32)*p++;
d520 1
d522 3
a524 3
#ifdef PERL_POISON
#ifdef PERL_ANY_COW
	U32 i = 9 + p[1] * 2;
d526 1
a526 1
	U32 i = 8 + p[1] * 2;
d528 4
a532 9

#ifdef PERL_ANY_COW
        SvREFCNT_dec (INT2PTR(SV*,p[2]));
#endif
#ifdef PERL_POISON
        PoisonFree(p, i, sizeof(UV));
#endif

	Safefree(tmp);
d544 1
a544 1
    SV * const tmpForm = *++MARK;
d546 2
a547 2
    U32 *fpc;	    /* format ops program counter */
    char *t;	    /* current append position in target string */
d549 2
a550 2
    I32 arg;
    SV *sv = NULL; /* current item */
d1308 1
a1308 1
	    IV i, j;
d1392 1
a1392 1
    I32 i;
d1397 1
a1397 1
	const PERL_CONTEXT * const cx = &cxstack[i];
d1468 1
a1468 1
	assert(0); /* NOTREACHED */
d1509 1
a1509 1
	const PERL_CONTEXT * const cx = &cxstk[i];
d1513 1
a1514 7
            /* in sub foo { /(?{...})/ }, foo ends up on the CX stack
             * twice; the first for the normal foo() call, and the second
             * for a faked up re-entry into the sub to execute the
             * code block. Hide this faked entry from the world. */
            if (cx->cx_type & CXp_SUB_RE_FAKE)
                continue;
	case CXt_EVAL:
d1529 1
a1529 1
	const PERL_CONTEXT *cx = &cxstack[i];
d1547 1
a1547 1
	const PERL_CONTEXT * const cx = &cxstack[i];
d1577 1
a1577 1
	const PERL_CONTEXT *cx = &cxstack[i];
d1605 1
a1605 1
	const PERL_CONTEXT *cx = &cxstack[i];
d1628 1
a1628 1
        PERL_CONTEXT *cx = &cxstack[cxstack_ix];
a1727 5
	if (in_eval & EVAL_KEEPERR) {
	    Perl_ck_warner(aTHX_ packWARN(WARN_MISC), "\t(in cleanup) %"SVf,
			   SVfARG(exceptsv));
	}

d1738 1
a1738 1
	    PERL_CONTEXT *cx;
d1786 5
a1790 1
	    if (!(in_eval & EVAL_KEEPERR))
d1792 1
d1796 1
a1796 1
	    assert(0); /* NOTREACHED */
d1802 1
a1802 1
    assert(0); /* NOTREACHED */
d1836 3
a1838 3
    I32 cxix = dopoptosub(cxstack_ix);
    const PERL_CONTEXT *cx;
    const PERL_CONTEXT *ccstack = cxstack;
d1878 1
a1878 1
    const PERL_CONTEXT *cx;
d1900 1
a1900 5
    DEBUG_CX("CALLER");
    assert(CopSTASH(cx->blk_oldcop));
    stash_hek = SvTYPE(CopSTASH(cx->blk_oldcop)) == SVt_PVHV
      ? HvNAME_HEK((HV*)CopSTASH(cx->blk_oldcop))
      : NULL;
d1929 1
a1929 1
	if (cvgv && isGV(cvgv)) {
d1952 1
a1952 3
	    PUSHs(newSVpvn_flags(SvPVX(cx->blk_eval.cur_text),
				 SvCUR(cx->blk_eval.cur_text)-2,
				 SvUTF8(cx->blk_eval.cur_text)|SVs_TEMP));
d1983 3
d1991 2
a1992 1
	if  (old_warnings == pWARN_NONE)
a1993 2
	else if (old_warnings == pWARN_STD && (PL_dowarn & G_WARN_ON) == 0)
            mask = &PL_sv_undef ;
d2022 3
a2024 7
    const char * tmps;
    STRLEN len = 0;
    if (MAXARG < 1 || (!TOPs && !POPs))
	tmps = NULL, len = 0;
    else
	tmps = SvPVx_const(POPs, len);
    sv_resetpvn(tmps, len, CopSTASH(PL_curcop));
d2045 1
a2045 1
	PERL_CONTEXT *cx;
d2049 1
a2049 1
	CV * cv = NULL;
d2051 1
a2051 4
        if (gv && isGV_with_GP(gv))
            cv = GvCV(gv);

	if (!cv || (!CvROOT(cv) && !CvXSUB(cv)))
d2068 1
d2071 1
a2080 4
	    if (CvDEPTH(cv) >= 2) {
		PERL_STACK_OVERFLOW_CHECK();
		pad_push(CvPADLIST(cv), CvDEPTH(cv));
	    }
d2082 1
a2082 1
	    PAD_SET_CUR_NOSAVE(CvPADLIST(cv), CvDEPTH(cv));
d2132 1
a2132 1
    PERL_CONTEXT *cx;
d2146 1
a2146 1
    PERL_CONTEXT *cx;
d2172 1
a2172 1
    PERL_CONTEXT *cx;
d2295 1
a2295 1
    PERL_CONTEXT *cx;
d2311 1
a2311 1
    PERL_CONTEXT *cx;
d2448 1
a2448 1
    PERL_CONTEXT *cx;
d2592 1
a2592 1
    PERL_CONTEXT *cx;
d2614 1
a2614 2
static I32
S_unwind_loop(pTHX_ const char * const opname)
d2616 1
a2616 1
    dVAR;
d2618 11
d2632 1
a2632 2
	    /* diag_listed_as: Can't "last" outside a loop block */
	    Perl_croak(aTHX_ "Can't \"%s\" outside a loop block", opname);
d2635 2
a2636 12
	dSP;
	STRLEN label_len;
	const char * const label =
	    PL_op->op_flags & OPf_STACKED
		? SvPV(TOPs,label_len)
		: (label_len = strlen(cPVOP->op_pv), cPVOP->op_pv);
	const U32 label_flags =
	    PL_op->op_flags & OPf_STACKED
		? SvUTF8(POPs)
		: (cPVOP->op_private & OPpPV_IS_UTF8) ? SVf_UTF8 : 0;
	PUTBACK;
        cxix = dopoptolabel(label, label_len, label_flags);
d2638 5
a2642 9
	    /* diag_listed_as: Label not found for "last %s" */
	    Perl_croak(aTHX_ "Label not found for \"%s %"SVf"\"",
				       opname,
                                       SVfARG(PL_op->op_flags & OPf_STACKED
                                              && !SvGMAGICAL(TOPp1s)
                                              ? TOPp1s
                                              : newSVpvn_flags(label,
                                                    label_len,
                                                    label_flags | SVs_TEMP)));
a2645 17
    return cxix;
}

PP(pp_last)
{
    dVAR;
    PERL_CONTEXT *cx;
    I32 pop2 = 0;
    I32 gimme;
    I32 optype;
    OP *nextop = NULL;
    SV **newsp;
    PMOP *newpm;
    SV **mark;
    SV *sv = NULL;

    S_unwind_loop(aTHX_ "last");
d2676 1
a2676 1
    PL_stack_sp = adjust_stack_on_leave(newsp, PL_stack_sp, MARK, gimme,
d2678 1
d2706 3
a2708 2
    PERL_CONTEXT *cx;
    const I32 inner = PL_scopestack_ix;
d2710 17
a2726 1
    S_unwind_loop(aTHX_ "next");
d2730 1
a2734 1
    PERL_ASYNC_CHECK();
d2741 2
a2742 2
    const I32 cxix = S_unwind_loop(aTHX_ "redo");
    PERL_CONTEXT *cx;
d2744 19
a2762 1
    OP* redo_op = cxstack[cxix].blk_loop.my_op->op_redoop;
d2764 1
a2776 1
    PERL_ASYNC_CHECK();
d2785 1
a2785 1
    static const char* const too_deep = "Target of goto is too deeply nested";
d2790 1
a2790 1
	Perl_croak(aTHX_ "%s", too_deep);
d2799 1
a2799 1
	    Perl_croak(aTHX_ "%s", too_deep);
d2850 1
a2850 1
    PERL_CONTEXT *cx;
d2857 1
a2857 1
    static const char* const must_have_label = "goto must have label";
a2860 1
	SvGETMAGIC(sv);
d2865 1
a2865 1
	    PERL_CONTEXT *cx;
d2867 2
a2868 1
	    AV *arg = GvAV(PL_defgv);
d2870 1
d2897 3
a2899 5
	    if (cxix < cxstack_ix) {
                if (cxix < 0) {
                    SvREFCNT_dec(cv);
                    DIE(aTHX_ "Can't goto subroutine outside a subroutine");
                }
a2900 1
            }
a2904 1
		SvREFCNT_dec(cv);
a2912 2
	    {
		SvREFCNT_dec(cv);
a2913 1
	    }
d2915 1
d2918 9
a2926 3
		/* abandon the original @@_ if it got reified or if it is
		   the same as the current @@_ */
		if (AvREAL(av) || av == arg) {
d2929 1
a2932 1
		else CLEAR_ARGARRAY(av);
d2934 8
a2941 2
	    /* We donate this refcount later to the callee’s pad. */
	    SvREFCNT_inc_simple_void(arg);
a2951 1
		SvREFCNT_dec(arg);
d2966 3
a2968 14
		SV **newsp;
		I32 gimme;
		const SSize_t items = AvFILLp(arg) + 1;
		SV** mark;

                PERL_UNUSED_VAR(newsp);
                PERL_UNUSED_VAR(gimme);

		/* put GvAV(defgv) back onto stack */
		EXTEND(SP, items+1); /* @@_ could have been extended. */
		Copy(AvARRAY(arg), SP + 1, items, SV*);
		mark = SP;
		SP += items;
		if (AvREAL(arg)) {
d2971 1
a2971 8
			SvREFCNT_inc_void(sv_2mortal(SP[-index]));
		}
		SvREFCNT_dec(arg);
		if (CxTYPE(cx) == CXt_SUB && CxHASARGS(cx)) {
		    /* Restore old @@_ */
		    arg = GvAV(PL_defgv);
		    GvAV(PL_defgv) = cx->blk_sub.savearray;
		    SvREFCNT_dec(arg);
a2980 1
		PERL_ASYNC_CHECK();
d2984 6
a2989 1
		PADLIST * const padlist = CvPADLIST(cv);
d3006 4
d3011 1
d3013 26
a3038 15
		    /* cx->blk_sub.argarray has no reference count, so we
		       need something to hang on to our argument array so
		       that cx->blk_sub.argarray does not end up pointing
		       to freed memory as the result of undef *_.  So put
		       it in the callee’s pad, donating our refer-
		       ence count. */
		    SvREFCNT_dec(PAD_SVl(0));
		    PAD_SVl(0) = (SV *)(cx->blk_sub.argarray = arg);

		    /* GvAV(PL_defgv) might have been modified on scope
		       exit, so restore it. */
		    if (arg != GvAV(PL_defgv)) {
			AV * const av = GvAV(PL_defgv);
			GvAV(PL_defgv) = (AV *)SvREFCNT_inc_simple(arg);
			SvREFCNT_dec(av);
a3040 1
		else SvREFCNT_dec(arg);
a3051 1
		PERL_ASYNC_CHECK();
d3056 1
a3056 1
	    label       = SvPV_nomg_const(sv, label_len);
d3058 2
d3062 5
a3066 1
    else if (!(PL_op->op_flags & OPf_SPECIAL)) {
a3070 1
    if (!(do_dump || label_len)) DIE(aTHX_ "%s", must_have_label);
d3074 1
a3074 1
    if (label_len) {
a3211 1
    PERL_ASYNC_CHECK();
d3322 1
a3322 1
	assert(0); /* NOTREACHED */
d3329 136
a3480 7
    return Perl_find_runcv_where(aTHX_ 0, 0, db_seqp);
}

/* If this becomes part of the API, it might need a better name. */
CV *
Perl_find_runcv_where(pTHX_ U8 cond, IV arg, U32 *db_seqp)
{
a3482 1
    int		 level = 0;
d3485 1
a3485 5
	*db_seqp =
            PL_curcop == &PL_compiling
                ? PL_cop_seqmax
                : PL_curcop->cop_seq;

a3489 1
	    CV *cv = NULL;
d3491 1
a3491 1
		cv = cx->blk_sub.cv;
d3497 1
a3497 2
                if (cx->cx_type & CXp_SUB_RE)
                    continue;
d3500 1
a3500 15
		cv = cx->blk_eval.cv;
	    if (cv) {
		switch (cond) {
		case FIND_RUNCV_padid_eq:
		    if (!CvPADLIST(cv)
		     || PadlistNAMES(CvPADLIST(cv)) != INT2PTR(PADNAMELIST *, arg))
			continue;
		    return cv;
		case FIND_RUNCV_level_eq:
		    if (level++ != arg) continue;
		    /* GERONIMO! */
		default:
		    return cv;
		}
	    }
d3503 1
a3503 1
    return cond == FIND_RUNCV_padid_eq ? NULL : PL_main_cv;
d3529 1
a3529 1
	assert(0); /* NOTREACHED */
d3536 3
a3538 2
/* Compile a require/do or an eval ''.
 *
a3539 3
 * seq     is the current COP scope value.
 * hh      is the saved hints hash, if any.
 *
d3541 9
a3549 5
 * PL_eval_start contains the first op of the compiled code; otherwise,
 * pushes undef.
 *
 * This function is called from two places: pp_require and pp_entereval.
 * These can be distinguished by whether PL_op is entereval.
d3553 1
a3553 1
S_doeval(pTHX_ int gimme, CV* outside, U32 seq, HV *hh)
a3556 1
    bool clear_hints = saveop->op_type != OP_ENTEREVAL;
d3558 1
a3558 1
    bool in_require = (saveop->op_type == OP_REQUIRE);
d3564 1
a3564 3
		  : (EVAL_INEVAL |
                        ((PL_op->op_private & OPpEVAL_RE_REPARSING)
                            ? EVAL_RE_REPARSING : 0)));
d3605 1
a3605 1
    ENTER_with_name("evalcomp");
d3613 1
a3613 1
    if ((saveop->op_type != OP_REQUIRE) && (saveop->op_flags & OPf_SPECIAL))
d3618 24
a3641 21
    SAVEHINTS();
    if (clear_hints) {
	PL_hints = 0;
	hv_clear(GvHV(PL_hintgv));
    }
    else {
	PL_hints = saveop->op_private & OPpEVAL_COPHH
		     ? oldcurcop->cop_hints : saveop->op_targ;

        /* making 'use re eval' not be in scope when compiling the
         * qr/mabye_has_runtime_code_block/ ensures that we don't get
         * infinite recursion when S_has_runtime_code() gives a false
         * positive: the second time round, HINT_RE_EVAL isn't set so we
         * don't bother calling S_has_runtime_code() */
        if (PL_in_eval & EVAL_RE_REPARSING)
            PL_hints &= ~HINT_RE_EVAL;

	if (hh) {
	    /* SAVEHINTS created a new HV in PL_hintgv, which we need to GC */
	    SvREFCNT_dec(GvHV(PL_hintgv));
	    GvHV(PL_hintgv) = hh;
d3643 15
a3657 22
    }
    SAVECOMPILEWARNINGS();
    if (clear_hints) {
	if (PL_dowarn & G_WARN_ALL_ON)
	    PL_compiling.cop_warnings = pWARN_ALL ;
	else if (PL_dowarn & G_WARN_ALL_OFF)
	    PL_compiling.cop_warnings = pWARN_NONE ;
	else
	    PL_compiling.cop_warnings = pWARN_STD ;
    }
    else {
	PL_compiling.cop_warnings =
	    DUP_WARNINGS(oldcurcop->cop_warnings);
	cophh_free(CopHINTHASH_get(&PL_compiling));
	if (Perl_cop_fetch_label(aTHX_ oldcurcop, NULL, NULL)) {
	    /* The label, if present, is the first entry on the chain. So rather
	       than writing a blank label in front of it (which involves an
	       allocation), just use the next entry in the chain.  */
	    PL_compiling.cop_hints_hash
		= cophh_copy(oldcurcop->cop_hints_hash->refcounted_he_next);
	    /* Check the assumption that this removed the label.  */
	    assert(Perl_cop_fetch_label(aTHX_ &PL_compiling, NULL, NULL) == NULL);
a3658 2
	else
	    PL_compiling.cop_hints_hash = cophh_copy(oldcurcop->cop_hints_hash);
a3672 1
        SV *errsv = NULL;
d3688 5
a3692 3
	    POPBLOCK(cx,PL_curpm);
	    POPEVAL(cx);
	    namesv = cx->blk_eval.old_namesv;
a3696 1
	errsv = ERRSV;
d3710 12
a3721 2
		       SVfARG(errsv
                                ? errsv
d3725 2
a3726 2
	    if (!*(SvPV_nolen_const(errsv))) {
	        sv_setpvs(errsv, "Compilation error");
d3733 1
a3733 3
    else
	LEAVE_with_name("evalcomp");

d3735 4
a3738 2
    SAVEFREEOP(PL_eval_root);
    cv_forget_slab(evalcv);
d3743 1
a3743 1
    if (PERLDB_INTER && saveop->op_type == OP_REQUIRE) {
d3819 1
a3819 1
    PERL_CONTEXT *cx;
a3826 3
    char *unixnamebuf;
    char *unixdir;
    char *unixdirbuf;
a3838 1
    int saved_errno;
d3843 1
a3843 1
	if (!Perl_sv_derived_from_pvn(aTHX_ PL_patchlevel, STR_WITH_LEN("version"), 0))
d3911 1
a3911 3
    
    if ((unixnamebuf = SvPVX(sv_2mortal(newSVpv("", VMS_MAXRSS-1))))
        && (unixname = tounixspec(name, unixnamebuf)) != NULL) {
a3935 2
    LOADING_FILE_PROBE(unixname);

d3943 1
a3943 1
    if (!tryrsfp && !(errno == EACCES && path_is_absolute(name))) {
d4086 2
a4087 2
		    if (((unixdirbuf = SvPVX(sv_2mortal(newSVpv("", VMS_MAXRSS-1)))) == NULL)
			|| ((unixdir = tounixpath(dir, unixdirbuf)) == NULL))
d4115 1
a4115 6

			/* Avoid '<dir>//<file>' */
			if (!dirlen || *(tmp-1) != '/') {
			    *tmp++ = '/';
			}

d4131 1
a4131 1
			    while (*++tryname == '/') {}
d4135 3
a4137 8
                    else if (errno == EMFILE || errno == EACCES) {
                        /* no point in trying other paths if out of handles;
                         * on the other hand, if we couldn't open one of the
                         * files, then going on with the search could lead to
                         * unexpected results; see perl #113422
                         */
                        break;
                    }
a4142 1
    saved_errno = errno; /* sv_2mortal can realloc things */
d4146 1
a4146 1
	    if(saved_errno == EMFILE || saved_errno == EACCES) {
d4148 1
a4148 1
		DIE(aTHX_ "Can't locate %s:   %s", name, Strerror(saved_errno));
a4152 1
		    SV *const msg = newSVpvs_flags("", SVs_TEMP);
a4157 19
		    if (len >= 4 && memEQ(name + len - 3, ".pm", 4)) {
			const char *c, *e = name + len - 3;
			sv_catpv(msg, " (you may need to install the ");
			for (c = name; c < e; c++) {
			    if (*c == '/') {
				sv_catpvn(msg, "::", 2);
			    }
			    else {
				sv_catpvn(msg, c, 1);
			    }
			}
			sv_catpv(msg, " module)");
		    }
		    else if (len >= 2 && memEQ(name + len - 2, ".h", 3)) {
			sv_catpv(msg, " (change .h to .ph maybe?) (did you run h2ph?)");
		    }
		    else if (len >= 3 && memEQ(name + len - 3, ".ph", 4)) {
			sv_catpv(msg, " (did you run h2ph?)");
		    }
d4161 8
a4168 2
			"Can't locate %s in @@INC%" SVf " (@@INC contains:%" SVf ")",
			name, msg, inc);
a4173 1
	CLEAR_ERRSV();
d4223 1
a4223 1
    if (doeval(gimme, NULL, PL_curcop->cop_seq, NULL))
a4230 2
    LOADED_FILE_PROBE(unixname);

d4250 1
a4250 1
    PERL_CONTEXT *cx;
d4351 1
a4351 1
    if (doeval(gimme, runcv, seq, saved_hh)) {
d4381 1
a4381 1
    PERL_CONTEXT *cx;
d4435 1
a4435 1
    PERL_CONTEXT *cx;
d4486 1
a4486 1
    PERL_CONTEXT *cx;
d4506 1
a4506 1
    PERL_CONTEXT *cx;
d4512 2
a4513 9
    if (PL_op->op_targ) {
	SAVEPADSVANDMORTALIZE(PL_op->op_targ);
	SvREFCNT_dec(PAD_SVl(PL_op->op_targ));
	PAD_SVl(PL_op->op_targ) = SvREFCNT_inc_NN(POPs);
    }
    else {
	SAVE_DEFSV;
	DEFSV_set(POPs);
    }
d4524 1
a4524 1
    PERL_CONTEXT *cx;
d5072 1
a5072 1
    PERL_CONTEXT *cx;
d5097 1
a5097 1
    PERL_CONTEXT *cx;
a5130 1
	PERL_ASYNC_CHECK();
d5133 1
a5133 2
    else {
	PERL_ASYNC_CHECK();
a5134 1
    }
d5141 1
a5141 1
    PERL_CONTEXT *cx;
d5169 1
a5169 1
    PERL_CONTEXT *cx;
d5192 4
a5195 4
    char *s = SvPV(sv, len);
    char *send;
    char *base = NULL; /* start of current field */
    I32 skipspaces = 0; /* number of contiguous spaces seen */
d5200 1
a5200 1
    U32 *fpc;
d5202 1
a5202 1
    I32 arg;
a5481 1
    SV *err = NULL;
d5560 1
a5560 1
	count = call_sv(filter_sub, G_SCALAR|G_EVAL);
a5567 5
            else {
                SV * const errsv = ERRSV;
                if (SvTRUE_NN(errsv))
                    err = newSVsv(errsv);
            }
d5575 1
a5575 2
    if (SvIsCOW(upstream)) sv_force_normal(upstream);
    if(!err && SvOK(upstream)) {
d5589 1
a5589 1
    if (!err && prune_from) {
d5618 1
a5618 2
    if (!err && upstream != buf_sv &&
        (SvOK(upstream) || SvGMAGICAL(upstream))) {
a5633 4

    if (err)
        croak_sv(err);

d5673 1
a5673 1
 * indent-tabs-mode: nil
d5676 1
a5676 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.16
log
@Import perl-5.20.1
@
text
@d156 1
a156 1
#ifdef NO_TAINT_SUPPORT
d171 1
d176 1
d217 1
d230 4
d235 3
a237 3
                !CALLREGEXEC(rx, s, cx->sb_strend, orig,
			     (s == m), cx->sb_targ, NULL,
                    (REXEC_IGNOREPOS|REXEC_NOT_FIRST|REXEC_FAIL_ON_UNDERFLOW)))
d258 6
a263 3
		SV_CHECK_THINKFIRST_COW_DROP(targ);
		if (isGV(targ)) Perl_croak_no_modify();
		SvPV_free(targ);
d329 8
a336 2
	if (!(mg = mg_find_mglob(sv))) {
	    mg = sv_magicext_mglob(sv);
d338 1
a338 2
	assert(SvPOK(sv));
	MgBYTEPOS_set(mg, sv, SvPVX(sv), m - orig);
d484 1
a484 2
    I32 itemsize  = 0;	    /* length (chars) of item, possibly truncated */
    I32 itembytes = 0;	    /* as itemsize, but length in bytes */
d492 1
a492 1
    STRLEN len;             /* length of current sv */
d552 1
a552 1
	case FF_LINEMARK: /* start (or end) of a line */
d558 1
a558 1
	case FF_LITERAL: /* append <arg> literal chars */
d566 1
a566 1
	case FF_SKIP: /* skip <arg> chars in format */
d570 1
a570 1
	case FF_FETCH: /* get next item and set field size to <arg> */
d585 1
a585 1
	case FF_CHECKNL: /* find max len of item (up to \n) that fits field */
d587 1
d589 38
a626 19
		const char *send = s + len;

                itemsize = 0;
		item_is_utf8 = DO_UTF8(sv);
                while (s < send) {
                    if (!isCNTRL(*s))
                        gotsome = TRUE;
                    else if (*s == '\n')
                        break;

                    if (item_is_utf8)
                        s += UTF8SKIP(s);
                    else
                        s++;
                    itemsize++;
                    if (itemsize == fieldsize)
                        break;
                }
                itembytes = s - item;
d630 1
a630 1
	case FF_CHECKCHOP: /* like CHECKNL, but up to highest split point */
d633 79
a711 53
		const char *send = s + len;
                I32 size = 0;

                chophere = NULL;
		item_is_utf8 = DO_UTF8(sv);
                while (s < send) {
                    /* look for a legal split position */
                    if (isSPACE(*s)) {
                        if (*s == '\r') {
                            chophere = s;
                            itemsize = size;
                            break;
                        }
                        if (chopspace) {
                            /* provisional split point */
                            chophere = s;
                            itemsize = size;
                        }
                        /* we delay testing fieldsize until after we've
                         * processed the possible split char directly
                         * following the last field char; so if fieldsize=3
                         * and item="a b cdef", we consume "a b", not "a".
                         * Ditto further down.
                         */
                        if (size == fieldsize)
                            break;
                    }
                    else {
                        if (strchr(PL_chopset, *s)) {
                            /* provisional split point */
                            /* for a non-space split char, we include
                             * the split char; hence the '+1' */
                            chophere = s + 1;
                            itemsize = size;
                        }
                        if (size == fieldsize)
                            break;
                        if (!isCNTRL(*s))
                            gotsome = TRUE;
                    }

                    if (item_is_utf8)
                        s += UTF8SKIP(s);
                    else
                        s++;
                    size++;
                }
                if (!chophere || s == send) {
                    chophere = s;
                    itemsize = size;
                }
                itembytes = chophere - item;

d715 1
a715 1
	case FF_SPACE: /* append padding space (diff of field, item size) */
d724 1
a724 1
	case FF_HALFSPACE: /* like FF_SPACE, but only append half as many */
d734 2
a735 2
	case FF_ITEM: /* append a text item, while blanking ctrl chars */
	    to_copy = itembytes;
d738 7
d747 1
a747 1
	case FF_CHOP: /* (for ^*) chop the current item */
d754 1
a754 6
                if (SvPOKp(sv))
                    sv_chop(sv,s);
                else
                    /* tied, overloaded or similar strangeness.
                     * Do it the hard way */
                    sv_setpvn(sv, s, len - (s-item));
d759 1
a759 1
	case FF_LINESNGL: /* process ^*  */
d761 1
a761 2

	case FF_LINEGLOB: /* process @@*  */
d778 1
a778 1
			    to_copy = s - item - 1;
d845 7
a851 1
			if (trans == '~' ? (ch == '~') : isCNTRL(ch))
d864 1
a864 1
	case FF_0DECIMAL: /* like FF_DECIMAL but for 0### */
d876 1
a876 2

	case FF_DECIMAL: /* do @@##, ^##, where <arg>=(precision|flags) */
d905 1
a905 1
                DECLARE_STORE_LC_NUMERIC_SET_TO_NEEDED();
a906 2
                /* we generate fmt ourselves so it is safe */
                GCC_DIAG_IGNORE(-Wformat-nonliteral);
d908 1
a908 2
                GCC_DIAG_RESTORE;
                RESTORE_LC_NUMERIC();
d913 1
a913 1
	case FF_NEWLINE: /* delete trailing spaces, then append \n */
d920 1
a920 1
	case FF_BLANK: /* for arg==0: do '~'; for arg>0 : do '~~' */
d934 1
a934 1
	case FF_MORE: /* replace long end of string with '...' */
d961 1
a961 2

	case FF_END: /* tidy up, then return */
a1002 5
    if (SvPADTMP(src)) {
        assert(!IS_PADGV(src));
	src = PL_stack_base[*PL_markstack_ptr] = sv_mortalcopy(src);
	PL_tmps_floor++;
    }
a1150 4
	if (SvPADTMP(src)) {
            assert(!IS_PADGV(src));
            src = sv_mortalcopy(src);
        }
d1242 2
a1243 4
	    if ((SvOK(left) && !SvIOK(left) && SvNV_nomg(left) < IV_MIN) ||
		(SvOK(right) && (SvIOK(right)
				 ? SvIsUV(right) && SvUV(right) > IV_MAX
				 : SvNV_nomg(right) > IV_MAX)))
a1248 2
		if (j > SSize_t_MAX)
		    Perl_croak(aTHX_ "Out of memory during list extend");
d1755 1
a1755 1
The XSUB-writer's equivalent of L<caller()|perlfunc/caller>.  The
d1757 1
a1757 1
information returned to Perl by C<caller>.  Note that XSUBs don't get a
d1762 1
a1762 1
behalf of the debugger.  If the stack frame requested was a sub called by
d1765 1
a1765 1
site.  If I<dbcxp> is non-C<NULL>, it will be set to a pointer to the
a1821 1
    const COP *lcop;
d1865 1
a1865 5
    lcop = closest_cop(cx->blk_oldcop, cx->blk_oldcop->op_sibling,
		       cx->blk_sub.retop, TRUE);
    if (!lcop)
	lcop = cx->blk_oldcop;
    mPUSHi((I32)CopLINE(lcop));
d1894 3
a1896 10
            SV *cur_text = cx->blk_eval.cur_text;
            if (SvCUR(cur_text) >= 2) {
                PUSHs(newSVpvn_flags(SvPVX(cur_text), SvCUR(cur_text)-2,
                                     SvUTF8(cur_text)|SVs_TEMP));
            }
            else {
                /* I think this is will always be "", but be sure */
                PUSHs(sv_2mortal(newSVsv(cur_text)));
            }

d1918 1
a1918 1
	const SSize_t off = AvARRAY(ary) - AvALLOC(ary);
a2040 4
/* SVs on the stack that have any of the flags passed in are left as is.
   Other SVs are protected via the mortals stack if lvalue is true, and
   copied otherwise. */

d2042 1
a2042 2
S_adjust_stack_on_leave(pTHX_ SV **newsp, SV **sp, SV **mark, I32 gimme,
			      U32 flags, bool lvalue)
d2054 1
a2054 4
			    ? *SP
			    : lvalue
				? sv_2mortal(SvREFCNT_inc_simple_NN(*SP))
				: sv_mortalcopy(*SP);
d2069 1
a2069 3
		*++newsp = lvalue
			    ? sv_2mortal(SvREFCNT_inc_simple_NN(*MARK))
			    : sv_mortalcopy(*MARK);
d2112 1
a2112 2
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme, SVs_PADTMP|SVs_TEMP,
			       PL_op->op_private & OPpLVALUE);
d2274 1
a2274 2
    SP = adjust_stack_on_leave(newsp, SP, MARK, gimme, 0,
			       PL_op->op_private & OPpLVALUE);
d2467 1
a2468 1
	POPFORMAT(cx);
d2557 1
a2558 1
    cxstack_ix--;
d2615 1
d2622 1
d2649 2
a2650 1
    PL_stack_sp = newsp;
d2782 1
a2782 1
PP(pp_goto) /* also pp_dump */
a2796 2
        /* goto EXPR  or  goto &foo */

d2899 1
a2899 2
		const SSize_t items = arg ? AvFILL(arg) + 1 : 0;
		const bool m = arg ? cBOOL(SvRMAGICAL(arg)) : 0;
d2906 2
a2907 3
		if (items) {
		    EXTEND(SP, items+1); /* @@_ could have been extended. */
		}
d2909 3
a2911 3
		if (items) {
		    SSize_t index;
		    bool r = cBOOL(AvREAL(arg));
d2913 1
a2913 11
		    {
			SV *sv;
			if (m) {
			    SV ** const svp = av_fetch(arg, index, 0);
			    sv = svp ? *svp : NULL;
			}
			else sv = AvARRAY(arg)[index];
			SP[index+1] = sv
			    ? r ? SvREFCNT_inc_NN(sv_2mortal(sv)) : sv
			    : sv_2mortal(newSVavdefelem(arg, index, 1));
		    }
a2914 1
		SP += items;
d2959 2
a2960 4
		    if (arg) {
			SvREFCNT_dec(PAD_SVl(0));
			PAD_SVl(0) = (SV *)(cx->blk_sub.argarray = arg);
		    }
a2986 1
            /* goto EXPR */
a2991 1
        /* goto LABEL  or  dump LABEL */
d3074 3
a3076 2
	    DIE(aTHX_ "Can't find label %"UTF8f, 
		       UTF8fARG(label_flags, label_len, label));
d3156 1
a3156 2
	if (anum == 1
	 && SvTRUE(cop_hints_fetch_pvs(PL_curcop, "vmsish_exit", 0)))
d3158 1
a3158 2
        VMSISH_HUSHED  =
            VMSISH_HUSHED || (PL_curcop->op_private & OPpHUSH_VMSISH);
d3263 2
a3264 2
entered.  (This allows debuggers to eval in the scope of the breakpoint
rather than in the scope of the debugger itself.)
d3410 1
a3410 3
	PL_curstash = (HV *)CopSTASH(PL_curcop);
	if (SvTYPE(PL_curstash) != SVt_PVHV) PL_curstash = NULL;
	else SvREFCNT_inc_simple_void(PL_curstash);
d3591 2
a3592 3
    STRLEN len;
    const char *p = SvPV_const(name, len);
    int st_rc;
a3595 16
    /* checking here captures a reasonable error message when
     * PERL_DISABLE_PMC is true, but when PMC checks are enabled, the
     * user gets a confusing message about looking for the .pmc file
     * rather than for the .pm file.
     * This check prevents a \0 in @@INC causing problems.
     */
    if (!IS_SAFE_PATHNAME(p, len, "require"))
        return NULL;

    /* we use the value of errno later to see how stat() or open() failed.
     * We don't want it set if the stat succeeded but we still failed,
     * such as if the name exists, but is a directory */
    errno = 0;

    st_rc = PerlLIO_stat(p, &st);

d3600 1
a3600 1
#if !defined(PERLIO_IS_STDIO)
a3615 7
    /* check the name before trying for the .pmc name to avoid the
     * warning referring to the .pmc which the user probably doesn't
     * know or care about
     */
    if (!IS_SAFE_PATHNAME(p, namelen, "require"))
        return NULL;

a3631 26
/* require doesn't search for absolute names, or when the name is
   explicity relative the current directory */
PERL_STATIC_INLINE bool
S_path_is_searchable(const char *name)
{
    PERL_ARGS_ASSERT_PATH_IS_SEARCHABLE;

    if (PERL_FILE_IS_ABSOLUTE(name)
#ifdef WIN32
	|| (*name == '.' && ((name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/'))
			 || (name[1] == '\\' ||
			     ( name[1] == '.' && name[2] == '\\')))
	    )
#else
	|| (*name == '.' && (name[1] == '/' ||
			     (name[1] == '.' && name[2] == '/')))
#endif
	 )
    {
	return FALSE;
    }
    else
	return TRUE;
}

d3643 1
d3645 1
a3658 1
    bool path_searchable;
d3685 1
a3685 1
		    || av_tindex(lav) > 1            /* FP with > 3 digits */
d3698 1
a3698 1
		    if (av_tindex(lav)>=1)
a3720 6
    if (!IS_SAFE_PATHNAME(name, len, "require")) {
        DIE(aTHX_ "Can't locate %s:   %s",
            pv_escape(newSVpvs_flags("",SVs_TEMP),SvPVX(sv),SvCUR(sv),
                      SvCUR(sv)*2,NULL, SvUTF8(sv)?PERL_PV_ESCAPE_UNI:0),
            Strerror(ENOENT));
    }
a3722 1
    path_searchable = path_is_searchable(name);
d3732 2
a3733 3
    if ((unixname =
	  tounixspec(name, SvPVX(sv_2mortal(newSVpv("", VMS_MAXRSS-1)))))
	 != NULL) {
d3762 1
a3762 1
    if (!path_searchable) {
d3767 1
a3767 1
    if (!tryrsfp && !(errno == EACCES && !path_searchable)) {
d3769 1
a3769 1
	SSize_t i;
a3773 1
	    SV *nsv = sv;
d3778 2
a3779 1
		SvGETMAGIC(dirsv);
d3786 1
a3786 1
			&& !SvOBJECT(SvRV(loader)))
a3788 1
			SvGETMAGIC(loader);
a3795 5
		    if (SvPADTMP(nsv)) {
			nsv = sv_newmortal();
			SvSetSV_nosteal(nsv,sv);
		    }

d3802 1
a3802 1
		    PUSHs(nsv);
a3803 5
		    if (SvGMAGICAL(loader)) {
			SV *l = sv_newmortal();
			sv_setsv_nomg(l, loader);
			loader = l;
		    }
d3820 1
a3866 3
		    /* FREETMPS may free our filter_cache */
		    SvREFCNT_inc_simple_void(filter_cache);

a3870 3
		    /* Now re-mortalize it. */
		    sv_2mortal(filter_cache);

d3883 4
a3886 1
		    filter_cache = NULL;
d3897 2
a3898 1
		  if (path_searchable) {
d3903 1
a3903 1
			dir = SvPV_nomg_const(dirsv, dirlen);
a3908 2
		    if (!IS_SAFE_SYSCALL(dir, dirlen, "@@INC entry", "require"))
			continue;
d3910 2
a3911 3
		    if ((unixdir =
			  tounixpath(dir, SvPVX(sv_2mortal(newSVpv("", VMS_MAXRSS-1)))))
			 == NULL)
a3942 3
			} else {
			    /* So SvCUR_set reports the correct length below */
			    dirlen--;
d3987 1
a3987 1
		    SSize_t i;
d4053 1
a4053 4
	SV * const fc = filter_cache ? newSV(0) : NULL;
	SV *datasv;
	if (fc) sv_copypv(fc, filter_cache);
	datasv = filter_add(S_run_user_filter, fc);
d4249 1
a4249 1
				gimme, SVs_TEMP, FALSE);
d4347 1
a4347 2
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme,
			       SVs_PADTMP|SVs_TEMP, FALSE);
d4393 1
a4393 2
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme,
			       SVs_PADTMP|SVs_TEMP, FALSE);
d4551 1
a4551 1
	    SSize_t i;
d4554 1
a4554 1
	    const I32 len = av_tindex(av);
d4613 2
a4614 2
	    bool tied;
	    bool other_tied;
d4621 8
a4628 13
	    tied = cBOOL(SvTIED_mg((SV*)hv, PERL_MAGIC_tied));
	    other_tied = cBOOL(SvTIED_mg((const SV *)other_hv, PERL_MAGIC_tied));
	    if (!tied ) {
		if(other_tied) {
		    /* swap HV sides */
		    HV * const temp = other_hv;
		    other_hv = hv;
		    hv = temp;
		    tied = TRUE;
		    other_tied = FALSE;
		}
		else if(HvUSEDKEYS((const HV *) hv) != HvUSEDKEYS(other_hv))
		    RETPUSHNO;
d4630 5
d4666 2
a4667 2
	    const SSize_t other_len = av_tindex(other_av) + 1;
	    SSize_t i;
d4718 2
a4719 2
	    const SSize_t other_len = av_tindex(other_av) + 1;
	    SSize_t i;
d4736 1
a4736 1
	    if (av_tindex(MUTABLE_AV(SvRV(e))) != av_tindex(other_av))
d4739 2
a4740 2
	    	SSize_t i;
                const SSize_t other_len = av_tindex(other_av);
d4795 2
a4796 2
		const SSize_t this_len = av_tindex(MUTABLE_AV(SvRV(e)));
		SSize_t i;
d4812 2
a4813 2
	    const SSize_t this_len = av_tindex(MUTABLE_AV(SvRV(e)));
	    SSize_t i;
d4827 2
a4828 2
		SSize_t i;
		const SSize_t this_len = av_tindex(MUTABLE_AV(SvRV(e)));
d4971 1
a4971 2
    SP = adjust_stack_on_leave(newsp, SP, newsp, gimme,
			       SVs_PADTMP|SVs_TEMP, FALSE);
a5427 1
	    SvGETMAGIC(out);
a5442 4
    if (SvGMAGICAL(upstream)) {
	mg_get(upstream);
	if (upstream == buf_sv) mg_free(buf_sv);
    }
d5445 1
a5445 1
	got_p = SvPV_nomg(upstream, got_len);
d5476 1
a5476 6
	if (SvPOK(upstream)) SvCUR_set(upstream, got_len - cached_len);
	else
	    /* Cannot just use sv_setpvn, as that could free the buffer
	       before we have a chance to assign it. */
	    sv_usepvn(upstream, savepvn(got_p, got_len - cached_len),
		      got_len - cached_len);
d5488 2
a5489 2
        SvOK(upstream)) {
	sv_catsv_nomg(buf_sv, upstream);
a5490 1
    else if (SvOK(upstream)) (void)SvPV_force_nolen(buf_sv);
d5515 26
@


1.1.1.17
log
@Import perl-5.20.2
@
text
@a592 1
                chophere = s;
d681 1
a681 1
	    if (sv != &PL_sv_no) {
a706 1
		chophere = s + len;
d711 1
@


1.1.1.18
log
@Import perl-5.24.2
@
text
@d43 1
d71 1
d78 1
d148 1
a148 1
	    else if (pm->op_targ)
d171 1
a171 2
    assert(TAINTING_get || !TAINT_get);
    if (TAINT_get) {
d194 1
d196 1
a196 1
    PERL_CONTEXT *cx = CX_CUR();
d217 1
a217 1
	const SSize_t saviters = cx->sb_iters;
d291 2
a292 5

	    CX_LEAVE_SCOPE(cx);
	    CX_POPSUBST(cx);
            CX_POP(cx);

d295 1
a295 1
	    NOT_REACHED; /* NOTREACHED */
a318 7

        /* the string being matched against may no longer be a string,
         * e.g. $_=0; s/.../$_++/ge */

        if (!SvPOK(sv))
            SvPV_force_nomg_nolen(sv);

d322 1
d460 1
a460 1
    dSP; dMARK; dORIGMARK;
a699 1
            /* FALLTHROUGH */
d800 5
d806 3
a808 1
		((arg & FORM_NUM_POINT) ? "%#0*.*" NVff : "%0*.*" NVff);
d813 1
d815 5
a819 1
		((arg & FORM_NUM_POINT) ? "%#*.*" NVff : "%*.*" NVff);
d840 2
a841 18
                Size_t max = SvLEN(PL_formtarget) - (t - SvPVX(PL_formtarget));
                int len;
                DECLARATION_FOR_LC_NUMERIC_MANIPULATION;
                STORE_LC_NUMERIC_SET_TO_NEEDED();
                arg &= ~(FORM_NUM_POINT|FORM_NUM_BLANK);
#ifdef USE_QUADMATH
                {
                    const char* qfmt = quadmath_format_single(fmt);
                    int len;
                    if (!qfmt)
                        Perl_croak_nocontext("panic: quadmath invalid format \"%s\"", fmt);
                    len = quadmath_snprintf(t, max, qfmt, (int) fieldsize, (int) arg, value);
                    if (len == -1)
                        Perl_croak_nocontext("panic: quadmath_snprintf failed, format \"%s\"", qfmt);
                    if (qfmt != fmt)
                        Safefree(fmt);
                }
#else
d844 1
a844 1
                len = my_snprintf(t, max, fmt, (int) fieldsize, (int) arg, value);
a845 2
#endif
                PERL_MY_SNPRINTF_POST_GUARD(len, max);
d919 1
a919 1
    dSP;
d922 1
a922 1
    if (PL_stack_base + TOPMARK == SP) {
d928 1
a928 1
    PL_stack_sp = PL_stack_base + TOPMARK + 1;
d934 4
a937 1
    SAVE_DEFSV;
d941 1
a941 1
    src = PL_stack_base[TOPMARK];
d943 2
a944 1
	src = PL_stack_base[TOPMARK] = sv_mortalcopy(src);
d948 4
a951 1
    DEFSV_set(src);
d961 3
a963 3
    dSP;
    const U8 gimme = GIMME_V;
    I32 items = (SP - PL_stack_base) - TOPMARK; /* how many new items */
d1064 1
a1064 1
    if (PL_markstack_ptr[-1] > TOPMARK) {
d1073 6
d1081 1
d1096 1
d1100 4
a1103 1
	DEFSV_set(src);
d1113 2
a1114 1
    if (GIMME_V == G_ARRAY)
d1124 1
d1127 1
a1127 1
    if (GIMME_V == G_ARRAY) {
d1179 1
a1179 1
    dSP;
d1181 1
a1181 1
    if (GIMME_V == G_ARRAY) {
d1188 2
a1189 1
	    IV i, j, n;
d1196 7
a1202 20
	    j = SvIV_nomg(right);
	    if (j >= i) {
                /* Dance carefully around signed max. */
                bool overflow = (i <= 0 && j > SSize_t_MAX + i - 1);
                if (!overflow) {
                    n = j - i + 1;
                    /* The wraparound of signed integers is undefined
                     * behavior, but here we aim for count >=1, and
                     * negative count is just wrong. */
                    if (n < 1
#if IVSIZE > Size_t_size
                        || n > SSize_t_MAX
#endif
                        )
                        overflow = TRUE;
                }
                if (overflow)
                    Perl_croak(aTHX_ "Out of memory during list extend");
		EXTEND_MORTAL(n);
		EXTEND(SP, n);
d1205 3
a1207 3
		n = 0;
	    while (n--) {
		SV * const sv = sv_2mortal(newSViv(i));
a1208 2
                if (n) /* avoid incrementing above IV_MAX */
                    i++;
d1262 1
d1264 1
a1265 3
    NULL, /* CXt_LOOP_LAZYSV never actually needs "loop" */
    NULL, /* CXt_LOOP_LIST never actually needs "loop" */
    NULL, /* CXt_LOOP_ARY never actually needs "loop" */
d1275 1
d1291 1
a1291 1
	    if (CxTYPE(cx) == CXt_NULL) /* sort BLOCK */
a1293 1
	case CXt_LOOP_PLAIN:
d1296 2
a1297 2
	case CXt_LOOP_LIST:
	case CXt_LOOP_ARY:
d1327 1
a1327 1
U8
d1330 2
a1331 1
    const U8 gimme = block_gimme();
d1335 1
a1335 1
U8
d1338 1
a1339 1
    U8 gimme;
d1343 12
a1354 4
    gimme = (cxstack[cxix].blk_gimme & G_WANT);
    if (!gimme)
	Perl_croak(aTHX_ "panic: bad gimme: %d\n", gimme);
    return gimme;
a1356 1

d1360 1
d1370 1
a1370 1
/* only used by cx_pushsub() */
d1374 1
d1387 1
a1390 3
#ifndef DEBUGGING
    PERL_UNUSED_CONTEXT;
#endif
a1403 1
            /* FALLTHROUGH */
d1416 1
d1434 1
d1447 1
a1447 1
	    if ((CxTYPE(cx)) == CXt_NULL) /* sort BLOCK */
a1449 1
	case CXt_LOOP_PLAIN:
d1452 2
a1453 2
	case CXt_LOOP_LIST:
	case CXt_LOOP_ARY:
a1460 2
/* find the next GIVEN or FOR (with implicit $_) loop context block */

d1462 1
a1462 1
S_dopoptogivenfor(pTHX_ I32 startingblock)
d1464 1
d1472 1
a1472 1
	    DEBUG_l( Perl_deb(aTHX_ "(dopoptogivenfor(): found given at cx=%ld)\n", (long)i));
d1475 1
a1475 1
            assert(!(cx->cx_type & CXp_FOR_DEF));
d1479 3
a1481 4
	case CXt_LOOP_LIST:
	case CXt_LOOP_ARY:
            if (cx->cx_type & CXp_FOR_DEF) {
		DEBUG_l( Perl_deb(aTHX_ "(dopoptogivenfor(): found foreach at cx=%ld)\n", (long)i));
d1492 1
a1506 7
/* dounwind(): pop all contexts above (but not including) cxix.
 * Note that it clears the savestack frame associated with each popped
 * context entry, but doesn't free any temps.
 * It does a cx_popblock() of the last frame that it pops, and leaves
 * cxstack_ix equal to cxix.
 */

d1510 3
d1517 3
a1519 3
        PERL_CONTEXT *cx = CX_CUR();

	CX_DEBUG(cx, "UNWIND");
a1520 3

        CX_LEAVE_SCOPE(cx);

d1523 2
a1524 2
	    CX_POPSUBST(cx);
	    break;
d1526 2
a1527 1
	    cx_popsub(cx);
d1530 1
a1530 1
	    cx_popeval(cx);
a1531 1
	case CXt_LOOP_PLAIN:
d1534 3
a1536 6
	case CXt_LOOP_LIST:
	case CXt_LOOP_ARY:
	    cx_poploop(cx);
	    break;
	case CXt_WHEN:
	    cx_popwhen(cx);
a1537 4
	case CXt_GIVEN:
	    cx_popgiven(cx);
	    break;
	case CXt_BLOCK:
a1538 1
            /* these two don't have a POPFOO() */
d1541 1
a1541 1
	    cx_popformat(cx);
a1543 3
        if (cxstack_ix == cxix + 1) {
            cx_popblock(cx);
        }
d1546 1
a1546 1

d1552 2
a1571 28


/* undef or delete the $INC{namesv} entry, then croak.
 * require0 indicates that the require didn't return a true value */

static void
S_undo_inc_then_croak(pTHX_ SV *namesv, SV *err, bool require0)
{
    const char *fmt;
    HV *inc_hv = GvHVn(PL_incgv);
    I32  klen  = SvUTF8(namesv) ? -(I32)SvCUR(namesv) : (I32)SvCUR(namesv);
    const char *key = SvPVX_const(namesv);

    if (require0) {
	(void)hv_delete(inc_hv, key, klen, G_DISCARD);
	fmt = "%"SVf" did not return a true value";
        err = namesv;
    }
    else {
        (void)hv_store(inc_hv, key, klen, &PL_sv_undef, 0);
        fmt = "%"SVf"Compilation failed in require";
        err = err ? err : newSVpvs_flags("Unknown error\n", SVs_TEMP);
    }

    Perl_croak(aTHX_ fmt, SVfARG(err));
}


d1575 1
d1582 1
d1631 2
a1632 1
            SV *namesv = NULL;
d1634 2
a1635 2
	    SV **oldsp;
            U8 gimme;
d1642 13
a1654 2
            cx = CX_CUR();
            assert(CxTYPE(cx) == CXt_EVAL);
a1655 3
            /* return false to the caller of eval */
            oldsp = PL_stack_base + cx->blk_oldsp;
            gimme = cx->blk_gimme;
d1657 2
a1658 2
		*++oldsp = &PL_sv_undef;
	    PL_stack_sp = oldsp;
d1660 1
a1660 17
            CX_LEAVE_SCOPE(cx);
	    cx_popeval(cx);
	    cx_popblock(cx);
	    restartjmpenv = cx->blk_eval.cur_top_env;
	    restartop = cx->blk_eval.retop;
            if (CxOLD_OP_TYPE(cx) == OP_REQUIRE)
                namesv = cx->blk_eval.old_namesv;
            CX_POP(cx);

            if (namesv) {
                /* note that unlike pp_entereval, pp_require isn't
                 * supposed to trap errors. So now that we've popped the
                 * EVAL that pp_require pushed, process the error message
                 * and rethrow the error */
                S_undo_inc_then_croak(aTHX_ namesv, exceptsv, FALSE);
                NOT_REACHED; /* NOTREACHED */
            }
d1662 19
d1686 1
a1686 1
	    NOT_REACHED; /* NOTREACHED */
d1692 1
a1692 1
    NOT_REACHED; /* NOTREACHED */
d1697 1
a1697 1
    dSP; dPOPTOPssrl;
a1704 3

=head1 CV Manipulation Functions

d1766 1
d1770 1
a1770 1
    U8 gimme = GIMME_V;
d1784 1
a1784 1
	if (gimme != G_ARRAY) {
d1791 1
a1791 1
    CX_DEBUG(cx, "CALLER");
d1796 1
a1796 1
    if (gimme != G_ARRAY) {
d1818 1
a1818 1
    lcop = closest_cop(cx->blk_oldcop, OpSIBLING(cx->blk_oldcop),
d1822 1
a1822 1
    mPUSHu(CopLINE(lcop));
d1826 1
d1828 4
a1831 2
	if (CvHASGV(dbcx->blk_sub.cv)) {
	    PUSHs(cv_name(dbcx->blk_sub.cv, 0, 0));
d1843 1
a1843 1
    gimme = cx->blk_gimme;
d1881 1
a1881 4
        /* slot 0 of the pad contains the original @@_ */
	AV * const ary = MUTABLE_AV(AvARRAY(MUTABLE_AV(
                            PadlistARRAY(CvPADLIST(cx->blk_sub.cv))[
                                cx->blk_sub.olddepth+1]))[0]);
d1926 1
d1943 1
d1946 1
a1946 1
    PL_stack_sp = PL_stack_base + CX_CUR()->blk_oldsp;
d1952 1
a1952 1
	    || PL_DBsingle_iv || PL_DBsignal_iv || PL_DBtrace_iv)
d1956 2
a1957 1
	const U8 gimme = G_ARRAY;
d1971 9
a1980 5
            ENTER;
            SAVEI32(PL_debug);
            PL_debug = 0;
            SAVESTACK_POS();
            SAVETMPS;
d1988 3
a1990 10
	    cx = cx_pushblock(CXt_SUB, gimme, SP, PL_savestack_ix);
	    cx_pushsub(cx, cv, PL_op->op_next, 0);
            /* OP_DBSTATE's op_private holds hint bits rather than
             * the lvalue-ish flags seen in OP_ENTERSUB. So cancel
             * any CxLVAL() flags that have now been mis-calculated */
            cx->blk_u16 = 0;

            SAVEI32(PL_debug);
            PL_debug = 0;
            SAVESTACK_POS();
d1992 2
a1993 1
	    if (CvDEPTH(cv) >= 2)
d1995 2
d2005 48
d2056 8
a2063 1
    U8 gimme = GIMME_V;
d2065 1
a2065 2
    (void)cx_pushblock(CXt_BLOCK, gimme, PL_stack_sp, PL_savestack_ix);
    return NORMAL;
a2067 1

d2070 1
d2072 3
a2074 2
    SV **oldsp;
    U8 gimme;
d2076 4
a2079 2
    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_BLOCK);
d2081 1
a2081 3
    if (PL_op->op_flags & OPf_SPECIAL)
        /* fake block should preserve $1 et al; e.g.  /(...)/ while ...; */
	cx->blk_oldpm = PL_curpm;
d2083 1
a2083 2
    oldsp = PL_stack_base + cx->blk_oldsp;
    gimme = cx->blk_gimme;
d2085 4
a2088 5
    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme,
                                PL_op->op_private & OPpLVALUE ? 3 : 1);
d2090 1
a2090 3
    CX_LEAVE_SCOPE(cx);
    cx_popblock(cx);
    CX_POP(cx);
d2092 1
a2092 23
    return NORMAL;
}

static bool
S_outside_integer(pTHX_ SV *sv)
{
  if (SvOK(sv)) {
    const NV nv = SvNV_nomg(sv);
    if (Perl_isinfnan(nv))
      return TRUE;
#ifdef NV_PRESERVES_UV
    if (nv < (NV)IV_MIN || nv > (NV)IV_MAX)
      return TRUE;
#else
    if (nv <= (NV)IV_MIN)
      return TRUE;
    if ((nv > 0) &&
        ((nv > (NV)UV_MAX ||
          SvUV_nomg(sv) > (UV)IV_MAX)))
      return TRUE;
#endif
  }
  return FALSE;
d2097 1
a2097 1
    dSP; dMARK;
d2099 6
a2104 4
    const U8 gimme = GIMME_V;
    void *itervarp; /* GV or pad slot of the iteration variable */
    SV   *itersave; /* the old var in the iterator var slot */
    U8 cxflags = 0;
a2106 3
	itervarp = &PAD_SVl(PL_op->op_targ);
        itersave = *(SV**)itervarp;
        assert(itersave);
d2108 10
a2117 7
            /* the SV currently in the pad slot is never live during
             * iteration (the slot is always aliased to one of the items)
             * so it's always stale */
	    SvPADSTALE_on(itersave);
	}
        SvREFCNT_inc_simple_void_NN(itersave);
	cxflags = CXp_FOR_PAD;
d2119 6
a2124 17
    else {
	SV * const sv = POPs;
	itervarp = (void *)sv;
        if (LIKELY(isGV(sv))) {		/* symbol table variable */
            itersave = GvSV(sv);
            SvREFCNT_inc_simple_void(itersave);
            cxflags = CXp_FOR_GV;
            if (PL_op->op_private & OPpITER_DEF)
                cxflags |= CXp_FOR_DEF;
        }
        else {                          /* LV ref: for \$foo (...) */
            assert(SvTYPE(sv) == SVt_PVMG);
            assert(SvMAGIC(sv));
            assert(SvMAGIC(sv)->mg_type == PERL_MAGIC_lvref);
            itersave = NULL;
            cxflags = CXp_FOR_LVREF;
        }
a2125 2
    /* OPpITER_DEF (implicit $_) should only occur with a GV iter var */
    assert((cxflags & CXp_FOR_GV) || !(PL_op->op_private & OPpITER_DEF));
d2127 4
a2130 7
    /* Note that this context is initially set as CXt_NULL. Further on
     * down it's changed to one of the CXt_LOOP_*. Before it's changed,
     * there mustn't be anything in the blk_loop substruct that requires
     * freeing or undoing, in case we die in the meantime. And vice-versa.
     */
    cx = cx_pushblock(cxflags, gimme, MARK, PL_savestack_ix);
    cx_pushloop_for(cx, itervarp, itersave);
d2132 2
a2134 3
        /* OPf_STACKED implies either a single array: for(@@), with a
         * single AV on the stack, or a range: for (1..5), with 1 and 5 on
         * the stack */
a2136 1
            /* range */
a2138 2
	    if (UNLIKELY(cxflags & CXp_FOR_LVREF))
		DIE(aTHX_ "Assigned value is not a reference");
d2142 1
d2144 23
a2166 2
		if (S_outside_integer(aTHX_ sv) ||
                    S_outside_integer(aTHX_ right))
d2170 4
d2176 1
d2178 3
d2183 1
a2183 1
		SvREFCNT_inc_simple_void_NN(right);
a2196 2
            /* for (@@array) {} */
            cx->cx_type |= CXt_LOOP_ARY;
d2198 1
a2198 1
	    SvREFCNT_inc_simple_void_NN(maybe_ary);
a2203 1
        /* EXTEND(SP, 1) not needed in this branch because we just did POPs */
d2206 7
a2212 10
        cx->cx_type |= CXt_LOOP_LIST;
        cx->blk_oldsp = SP - PL_stack_base;
	cx->blk_loop.state_u.stack.basesp = MARK - PL_stack_base;
        cx->blk_loop.state_u.stack.ix =
            (PL_op->op_private & OPpITER_REVERSED)
                ? cx->blk_oldsp + 1
                : cx->blk_loop.state_u.stack.basesp;
        /* pre-extend stack so pp_iter doesn't have to check every time
         * it pushes yes/no */
        EXTEND(SP, 1);
d2220 1
d2222 1
a2222 1
    const U8 gimme = GIMME_V;
d2224 8
a2231 3
    cx = cx_pushblock(CXt_LOOP_PLAIN, gimme, PL_stack_sp, PL_savestack_ix);
    cx_pushloop_plain(cx);
    return NORMAL;
a2233 1

d2236 1
d2238 3
a2240 2
    U8 gimme;
    SV **oldsp;
d2243 1
a2243 1
    cx = CX_CUR();
d2245 2
a2246 5
    mark = PL_stack_base + cx->blk_oldsp;
    oldsp = CxTYPE(cx) == CXt_LOOP_LIST
                ? PL_stack_base + cx->blk_loop.state_u.stack.basesp
                : mark;
    gimme = cx->blk_gimme;
d2248 7
a2254 5
    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(MARK, oldsp, gimme,
                                PL_op->op_private & OPpLVALUE ? 3 : 1);
d2256 2
a2257 4
    CX_LEAVE_SCOPE(cx);
    cx_poploop(cx);	/* Stack values are safe: release loop vars ... */
    cx_popblock(cx);
    CX_POP(cx);
d2262 109
d2372 1
a2372 11
/* This duplicates most of pp_leavesub, but with additional code to handle
 * return args in lvalue context. It was forked from pp_leavesub to
 * avoid slowing down that function any further.
 *
 * Any changes made to this function may need to be copied to pp_leavesub
 * and vice-versa.
 *
 * also tail-called by pp_return
 */

PP(pp_leavesublv)
d2374 1
a2374 1
    U8 gimme;
d2376 12
a2387 2
    SV **oldsp;
    OP *retop;
d2389 14
a2402 2
    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_SUB);
d2404 8
a2411 4
    if (CxMULTICALL(cx)) {
        /* entry zero of a stack is always PL_sv_undef, which
         * simplifies converting a '()' return into undef in scalar context */
        assert(PL_stack_sp > PL_stack_base || *PL_stack_base == &PL_sv_undef);
d2415 34
a2448 2
    gimme = cx->blk_gimme;
    oldsp = PL_stack_base + cx->blk_oldsp; /* last arg of previous frame */
d2450 2
a2451 2
    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
d2453 40
a2492 24
        U8   lval    = CxLVAL(cx);
        bool is_lval = (lval && !(lval & OPpENTERSUB_INARGS));
        const char *what = NULL;

        if (gimme == G_SCALAR) {
            if (is_lval) {
                /* check for bad return arg */
                if (oldsp < PL_stack_sp) {
                    SV *sv = *PL_stack_sp;
                    if ((SvPADTMP(sv) || SvREADONLY(sv))) {
                        what =
                            SvREADONLY(sv) ? (sv == &PL_sv_undef) ? "undef"
                            : "a readonly value" : "a temporary";
                    }
                    else goto ok;
                }
                else {
                    /* sub:lvalue{} will take us here. */
                    what = "undef";
                }
              croak:
                Perl_croak(aTHX_
                          "Can't return %s from lvalue subroutine", what);
            }
d2494 9
a2502 2
          ok:
            leave_adjust_stacks(oldsp, oldsp, gimme, is_lval ? 3 : 2);
d2504 3
a2506 37
            if (lval & OPpDEREF) {
                /* lval_sub()->{...} and similar */
                dSP;
                SvGETMAGIC(TOPs);
                if (!SvOK(TOPs)) {
                    TOPs = vivify_ref(TOPs, CxLVAL(cx) & OPpDEREF);
                }
                PUTBACK;
            }
        }
        else {
            assert(gimme == G_ARRAY);
            assert (!(lval & OPpDEREF));

            if (is_lval) {
                /* scan for bad return args */
                SV **p;
                for (p = PL_stack_sp; p > oldsp; p--) {
                    SV *sv = *p;
                    /* the PL_sv_undef exception is to allow things like
                     * this to work, where PL_sv_undef acts as 'skip'
                     * placeholder on the LHS of list assigns:
                     *    sub foo :lvalue { undef }
                     *    ($a, undef, foo(), $b) = 1..4;
                     */
                    if (sv != &PL_sv_undef && (SvPADTMP(sv) || SvREADONLY(sv)))
                    {
                        /* Might be flattened array after $#array =  */
                        what = SvREADONLY(sv)
                                ? "a readonly value" : "a temporary";
                        goto croak;
                    }
                }
            }

            leave_adjust_stacks(oldsp, oldsp, gimme, is_lval ? 3 : 2);
        }
a2507 7

    CX_LEAVE_SCOPE(cx);
    cx_popsub(cx);	/* Stack values are safe: release CV and @@_ ... */
    cx_popblock(cx);
    retop =  cx->blk_sub.retop;
    CX_POP(cx);

d2511 3
a2513 2

PP(pp_return)
d2515 4
a2518 1
    dSP; dMARK;
d2520 9
a2528 1
    const I32 cxix = dopoptosub(cxstack_ix);
d2530 1
a2530 31
    assert(cxstack_ix >= 0);
    if (cxix < cxstack_ix) {
        if (cxix < 0) {
            if (!(       PL_curstackinfo->si_type == PERLSI_SORT
                  || (   PL_curstackinfo->si_type == PERLSI_MULTICALL
                      && (cxstack[0].cx_type & CXp_SUB_RE_FAKE))
                 )
            )
                DIE(aTHX_ "Can't return outside a subroutine");
            /* We must be in:
             *  a sort block, which is a CXt_NULL not a CXt_SUB;
             *  or a /(?{...})/ block.
             * Handle specially. */
            assert(CxTYPE(&cxstack[0]) == CXt_NULL
                    || (   CxTYPE(&cxstack[0]) == CXt_SUB
                        && (cxstack[0].cx_type & CXp_SUB_RE_FAKE)));
            if (cxstack_ix > 0) {
                /* See comment below about context popping. Since we know
                 * we're scalar and not lvalue, we can preserve the return
                 * value in a simpler fashion than there. */
                SV *sv = *SP;
                assert(cxstack[0].blk_gimme == G_SCALAR);
                if (   (sp != PL_stack_base)
                    && !(SvFLAGS(sv) & (SVs_TEMP|SVs_PADTMP))
                )
                    *SP = sv_mortalcopy(sv);
                dounwind(0);
            }
            /* caller responsible for popping cxstack[0] */
            return 0;
        }
d2532 4
a2535 54
        /* There are contexts that need popping. Doing this may free the
         * return value(s), so preserve them first: e.g. popping the plain
         * loop here would free $x:
         *     sub f {  { my $x = 1; return $x } }
         * We may also need to shift the args down; for example,
         *    for (1,2) { return 3,4 }
         * leaves 1,2,3,4 on the stack. Both these actions will be done by
         * leave_adjust_stacks(), along with freeing any temps. Note that
         * whoever we tail-call (e.g. pp_leaveeval) will also call
         * leave_adjust_stacks(); however, the second call is likely to
         * just see a bunch of SvTEMPs with a ref count of 1, and so just
         * pass them through, rather than copying them again. So this
         * isn't as inefficient as it sounds.
         */
        cx = &cxstack[cxix];
        PUTBACK;
        if (cx->blk_gimme != G_VOID)
            leave_adjust_stacks(MARK, PL_stack_base + cx->blk_oldsp,
                    cx->blk_gimme,
                    CxTYPE(cx) == CXt_SUB && CvLVALUE(cx->blk_sub.cv)
                        ? 3 : 0);
        SPAGAIN;
	dounwind(cxix);
        cx = &cxstack[cxix]; /* CX stack may have been realloced */
    }
    else {
        /* Like in the branch above, we need to handle any extra junk on
         * the stack. But because we're not also popping extra contexts, we
         * don't have to worry about prematurely freeing args. So we just
         * need to do the bare minimum to handle junk, and leave the main
         * arg processing in the function we tail call, e.g. pp_leavesub.
         * In list context we have to splice out the junk; in scalar
         * context we can leave as-is (pp_leavesub will later return the
         * top stack element). But for an  empty arg list, e.g.
         *    for (1,2) { return }
         * we need to set sp = oldsp so that pp_leavesub knows to push
         * &PL_sv_undef onto the stack.
         */
        SV **oldsp;
        cx = &cxstack[cxix];
        oldsp = PL_stack_base + cx->blk_oldsp;
        if (oldsp != MARK) {
            SSize_t nargs = SP - MARK;
            if (nargs) {
                if (cx->blk_gimme == G_ARRAY) {
                    /* shift return args to base of call stack frame */
                    Move(MARK + 1, oldsp + 1, nargs, SV*);
                    PL_stack_sp  = oldsp + nargs;
                }
            }
            else
                PL_stack_sp  = oldsp;
        }
    }
d2537 2
a2538 15
    /* fall through to a normal exit */
    switch (CxTYPE(cx)) {
    case CXt_EVAL:
        return CxTRYBLOCK(cx)
            ? Perl_pp_leavetry(aTHX)
            : Perl_pp_leaveeval(aTHX);
    case CXt_SUB:
        return CvLVALUE(cx->blk_sub.cv)
            ? Perl_pp_leavesublv(aTHX)
            : Perl_pp_leavesub(aTHX);
    case CXt_FORMAT:
        return Perl_pp_leavewrite(aTHX);
    default:
	DIE(aTHX_ "panic: return, type=%u", (unsigned) CxTYPE(cx));
    }
d2541 2
a2542 4
/* find the enclosing loop or labelled loop and dounwind() back to it. */

static PERL_CONTEXT *
S_unwind_loop(pTHX)
d2544 1
d2550 1
a2550 2
	    Perl_croak(aTHX_ "Can't \"%s\" outside a loop block",
                OP_NAME(PL_op));
d2568 1
a2568 1
				       OP_NAME(PL_op),
d2578 1
a2578 1
    return &cxstack[cxix];
a2580 1

d2583 1
d2585 7
a2591 1
    OP* nextop;
d2593 1
a2593 1
    cx = S_unwind_loop(aTHX);
d2595 26
a2620 6
    assert(CxTYPE_is_LOOP(cx));
    PL_stack_sp = PL_stack_base
                + (CxTYPE(cx) == CXt_LOOP_LIST
                    ?  cx->blk_loop.state_u.stack.basesp
                    : cx->blk_oldsp
                );
d2623 1
d2625 2
d2628 13
a2640 5
    CX_LEAVE_SCOPE(cx);
    cx_poploop(cx);	/* release loop vars ... */
    cx_popblock(cx);
    nextop = cx->blk_loop.my_op->op_lastop->op_next;
    CX_POP(cx);
d2642 3
d2650 1
d2652 1
d2654 1
a2654 4
    /* if not a bare 'next' in the main scope, search for it */
    cx = CX_CUR();
    if (!((PL_op->op_flags & OPf_SPECIAL) && CxTYPE_is_LOOP(cx)))
        cx = S_unwind_loop(aTHX);
d2656 5
a2660 1
    cx_topblock(cx);
d2668 5
a2672 2
    PERL_CONTEXT *cx = S_unwind_loop(aTHX);
    OP* redo_op = cx->blk_loop.my_op->op_redoop;
d2677 1
a2677 2
        cx = CX_CUR();
	assert(CxTYPE(cx) == CXt_BLOCK);
d2681 3
a2684 2
    CX_LEAVE_SCOPE(cx);
    cx_topblock(cx);
d2693 1
d2715 1
a2715 1
	for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid)) {
d2735 1
a2735 1
	for (kid = cUNOPo->op_first; kid; kid = OpSIBLING(kid)) {
d2755 1
a2755 4

/* also used for: pp_dump() */

PP(pp_goto)
d2775 1
a2776 1
            /* This egregious kludge implements goto &subroutine */
d2781 1
d2783 2
a2784 1
	    while (!CvROOT(cv) && !CvXSUB(cv)) {
d2791 1
a2791 1
			continue;
d2796 1
a2796 1
			continue;
d2804 3
d2808 6
a2813 2
            if (cxix < 0) {
                DIE(aTHX_ "Can't goto subroutine outside a subroutine");
d2815 2
a2816 1
            cx  = &cxstack[cxix];
d2819 1
d2828 2
d2831 3
d2835 8
a2842 33
	    /* First do some returnish stuff. */

	    SvREFCNT_inc_simple_void(cv); /* avoid premature free during unwind */
	    FREETMPS;
	    if (cxix < cxstack_ix) {
		dounwind(cxix);
            }
            cx = CX_CUR();
	    cx_topblock(cx);
	    SPAGAIN;

            /* protect @@_ during save stack unwind. */
            if (arg)
                SvREFCNT_inc_NN(sv_2mortal(MUTABLE_SV(arg)));

	    assert(PL_scopestack_ix == cx->blk_oldscopesp);
            CX_LEAVE_SCOPE(cx);

	    if (CxTYPE(cx) == CXt_SUB && CxHASARGS(cx)) {
                /* this is part of cx_popsub_args() */
		AV* av = MUTABLE_AV(PAD_SVl(0));
                assert(AvARRAY(MUTABLE_AV(
                    PadlistARRAY(CvPADLIST(cx->blk_sub.cv))[
                            CvDEPTH(cx->blk_sub.cv)])) == PL_curpad);

                /* we are going to donate the current @@_ from the old sub
                 * to the new sub. This first part of the donation puts a
                 * new empty AV in the pad[0] slot of the old sub,
                 * unless pad[0] and @@_ differ (e.g. if the old sub did
                 * local *_ = []); in which case clear the old pad[0]
                 * array in the usual way */
		if (av == arg || AvREAL(av))
                    clear_defarray(av, av == arg);
d2845 7
a2851 6

            /* don't restore PL_comppad here. It won't be needed if the
             * sub we're going to is non-XS, but restoring it early then
             * croaking (e.g. the "Goto undefined subroutine" below)
             * means the CX block gets processed again in dounwind,
             * but this time with the wrong PL_comppad */
d2857 1
a2866 5
	    if (CxTYPE(cx) == CXt_SUB) {
		CvDEPTH(cx->blk_sub.cv) = cx->blk_sub.olddepth;
                SvREFCNT_dec_NN(cx->blk_sub.cv);
            }

d2868 2
d2871 3
d2878 2
a2879 3
                ENTER;
                SAVETMPS;
                SAVEFREESV(cv); /* later, undo the 'avoid premature free' hack */
d2903 1
d2906 3
a2908 1
                    CX_POP_SAVEARRAY(cx);
d2911 2
a2912 10
		retop = cx->blk_sub.retop;
                PL_comppad = cx->blk_sub.prevcomppad;
                PL_curpad = LIKELY(PL_comppad) ? AvARRAY(PL_comppad) : NULL;

		/* XS subs don't have a CXt_SUB, so pop it;
                 * this is a cx_popblock(), less all the stuff we already did
                 * for cx_topblock() earlier */
                PL_curcop = cx->blk_oldcop;
                CX_POP(cx);

d2918 2
a2919 1
		goto _return;
a2922 5

                SAVEFREESV(cv); /* later, undo the 'avoid premature free' hack */

                /* partial unrolled cx_pushsub(): */

d2927 3
a2929 2
                SvREFCNT_inc_simple_void_NN(cv);
		if (CvDEPTH(cv) > 1) {
d2935 1
d2939 8
a2946 5
                    /* second half of donating @@_ from the old sub to the
                     * new sub: abandon the original pad[0] AV in the
                     * new sub, and replace it with the donated @@_.
                     * pad[0] takes ownership of the extra refcount
                     * we gave arg earlier */
d2949 1
a2949 2
			PAD_SVl(0) = (SV *)arg;
                        SvREFCNT_inc_simple_void_NN(arg);
d2953 1
a2953 1
		       exit, so point it at arg again. */
d2960 1
a2960 1

d2972 2
a2973 2
		retop = CvSTART(cv);
		goto putback_return;
d3015 4
a3018 5
            case CXt_LOOP_PLAIN:
            case CXt_LOOP_LAZYIV:
            case CXt_LOOP_LAZYSV:
            case CXt_LOOP_LIST:
            case CXt_LOOP_ARY:
d3021 1
a3021 1
		gotoprobe = OpSIBLING(cx->blk_oldcop);
d3027 1
a3027 1
		    gotoprobe = OpSIBLING(cx->blk_oldcop);
d3037 1
a3037 1
		/* FALLTHROUGH */
a3048 2
                OP *sibl1, *sibl2;

d3053 4
a3056 5
		if ( (sibl1 = OpSIBLING(gotoprobe)) &&
		     sibl1->op_type == OP_UNSTACK &&
		     (sibl2 = OpSIBLING(sibl1)))
                {
		    retop = dofindlabel(sibl2,
d3089 2
d3092 1
a3092 1
		DIE(aTHX_ "panic: docatch: illegal ix=%ld", (long)ix);
d3094 3
a3096 2
            cx = CX_CUR();
	    cx_topblock(cx);
a3128 3
    putback_return:
    PL_stack_sp = sp;
    _return:
d3130 1
a3130 1
    return retop;
d3135 1
d3155 5
d3161 1
d3202 1
a3202 1
See F<cop.h>: je_mustcatch, when set at any runlevel to TRUE, means eval ops must
d3210 1
d3224 2
a3225 2
	assert(CxTYPE(CX_CUR()) == CXt_EVAL);
        CX_CUR()->blk_eval.cur_top_env = PL_top_env;
d3237 1
a3237 1
	/* FALLTHROUGH */
d3242 1
a3242 1
	NOT_REACHED; /* NOTREACHED */
d3254 2
a3255 2
If C<db_seqp> is non_null, skip CVs that are in the DB package and populate
C<*db_seqp> with the cop sequence number at the point that the DB:: code was
d3272 1
d3303 1
a3303 1
		     || CvPADLIST(cv)->xpadl_id != (U32)arg)
d3330 1
a3330 1
    assert(CxTYPE(CX_CUR()) == CXt_EVAL);
d3341 1
a3341 1
	NOT_REACHED; /* NOTREACHED */
d3363 1
a3363 1
S_doeval_compile(pTHX_ U8 gimme, CV* outside, U32 seq, HV *hh)
d3365 1
a3365 1
    dSP;
d3383 3
a3385 3
    assert(CxTYPE(CX_CUR()) == CXt_EVAL);
    CX_CUR()->blk_eval.cv = evalcv;
    CX_CUR()->blk_gimme = gimme;
d3392 1
a3392 1
    CvPADLIST_set(evalcv, pad_new(padnew_SAVE));
d3396 2
a3397 1
    SAVEMORTALIZESV(evalcv);	/* must remain until end of current statement */
d3415 4
a3486 2

    /* compile the code */
d3490 1
a3490 1
        SV *namesv = NULL; /* initialise  to avoid compiler warning */
d3492 8
a3499 1
        SV *errsv;
d3501 2
a3503 3
	/* note that if yystatus == 3, then the require/eval died during
         * compilation, so the EVAL CX block has already been popped, and
         * various vars restored */
d3510 5
a3514 7
            cx = CX_CUR();
            CX_LEAVE_SCOPE(cx);
	    cx_popeval(cx);
	    cx_popblock(cx);
            if (in_require)
                namesv = cx->blk_eval.old_namesv;
            CX_POP(cx);
d3519 20
a3538 7
            if (yystatus == 3) {
                cx = CX_CUR();
                assert(CxTYPE(cx) == CXt_EVAL);
                namesv = cx->blk_eval.old_namesv;
            }
            S_undo_inc_then_croak(aTHX_ namesv, errsv, FALSE);
            NOT_REACHED; /* NOTREACHED */
a3539 4

        if (!*(SvPV_nolen_const(errsv)))
            sv_setpvs(errsv, "Compilation error");

d3544 2
a3545 4

    /* Compilation successful. Now clean up */

    LEAVE_with_name("evalcomp");
d3571 2
a3581 1

a3586 1
    PerlIO * retio;
d3595 1
a3595 2
     * rather than for the .pm file so do the check in S_doopen_pm when
     * PMC is on instead of here. S_doopen_pm calls this func.
a3597 1
#ifdef PERL_DISABLE_PMC
a3599 1
#endif
a3600 5
    /* on Win32 stat is expensive (it does an open() and close() twice and
       a couple other IO calls), the open will fail with a dir on its own with
       errno EACCES, so only do a stat to separate a dir from a real EACCES
       caused by user perms */
#ifndef WIN32
a3610 1
#endif
d3612 4
a3615 15
    retio = PerlIO_openn(aTHX_ ":", PERL_SCRIPT_MODE, -1, 0, 0, NULL, 1, &name);
#ifdef WIN32
    /* EACCES stops the INC search early in pp_require to implement
       feature RT #113422 */
    if(!retio && errno == EACCES) { /* exists but probably a directory */
	int eno;
	st_rc = PerlLIO_stat(p, &st);
	if (st_rc >= 0) {
	    if(S_ISDIR(st.st_mode) || S_ISBLK(st.st_mode))
		eno = 0;
	    else
		eno = EACCES;
	    errno = eno;
	}
    }
a3616 1
    return retio;
d3637 1
a3637 1
	PerlIO * pmcio;
d3640 1
a3640 1
	sv_catpvs(pmcsv, "c");
d3642 2
a3643 3
	pmcio = check_type_and_open(pmcsv);
	if (pmcio)
	    return pmcio;
d3652 1
a3652 1
   explicitly relative the current directory */
a3676 3

/* also used for: pp_dofile() */

d3679 1
a3679 1
    dSP;
d3692 1
a3692 1
    const U8 gimme = GIMME_V;
d3699 1
a3702 1
    I32 old_savestack_ix;
a3704 1
    SvGETMAGIC(sv);
d3762 1
a3762 3
    if (!SvOK(sv))
        DIE(aTHX_ "Missing or undefined argument to require");
    name = SvPV_nomg_const(sv, len);
d3764 1
a3764 2
        DIE(aTHX_ "Missing or undefined argument to require");

d3810 1
a3810 1
    PERL_DTRACE_PROBE_FILE_LOADING(unixname);
d3953 1
a3953 1
			SvREFCNT_dec_NN(filter_state);
d3957 1
a3957 1
			SvREFCNT_dec_NN(filter_sub);
d4053 1
a4053 2
		DIE(aTHX_ "Can't locate %s:   %s: %s",
		    name, tryname, Strerror(saved_errno));
d4069 1
a4069 1
				sv_catpvs(msg, "::");
d4112 2
a4113 1
    old_savestack_ix = PL_savestack_ix;
d4133 3
a4135 2
    cx = cx_pushblock(CXt_EVAL, gimme, SP, old_savestack_ix);
    cx_pusheval(cx, PL_op->op_next, newSVpv(name, 0));
d4142 5
a4146 1
    if (doeval_compile(gimme, NULL, PL_curcop->cop_seq, NULL))
d4151 4
a4154 1
    PERL_DTRACE_PROBE_FILE_LOADED(unixname);
d4165 1
d4174 1
a4174 1
    dSP;
d4177 1
a4177 1
    const U8 gimme = GIMME_V;
a4186 1
    I32 old_savestack_ix;
d4224 1
a4224 2
    old_savestack_ix = PL_savestack_ix;

d4230 1
d4255 3
a4257 2
    cx = cx_pushblock((CXt_EVAL|CXp_REAL), gimme, SP, old_savestack_ix);
    cx_pusheval(cx, PL_op->op_next, NULL);
d4261 1
a4261 1
    if (PERLDB_LINE_OR_SAVESRC && PL_curstash != PL_debstash)
d4276 1
a4276 1
    if (doeval_compile(gimme, runcv, seq, saved_hh)) {
d4278 1
a4278 1
	    ?  PERLDB_LINE_OR_SAVESRC
d4288 1
a4288 1
	   in doeval_compile().  */
d4290 1
a4290 1
	    ?  PERLDB_LINE_OR_SAVESRC
a4299 3

/* also tail-called by pp_return */

d4302 4
a4305 2
    SV **oldsp;
    U8 gimme;
d4308 3
a4310 1
    SV *namesv = NULL;
a4311 2
    /* grab this value before cx_popeval restores old PL_in_eval */
    bool keep = cBOOL(PL_in_eval & EVAL_KEEPERR);
d4314 3
a4316 31

    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_EVAL);

    oldsp = PL_stack_base + cx->blk_oldsp;
    gimme = cx->blk_gimme;

    /* did require return a false value? */
    if (       CxOLD_OP_TYPE(cx) == OP_REQUIRE
            && !(gimme == G_SCALAR
                    ? SvTRUE(*PL_stack_sp)
                : PL_stack_sp > oldsp)
    )
        namesv = cx->blk_eval.old_namesv;

    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 0);

    /* the cx_popeval does a leavescope, which frees the optree associated
     * with eval, which if it frees the nextstate associated with
     * PL_curcop, sets PL_curcop to NULL. Which can mess up freeing a
     * regex when running under 'use re Debug' because it needs PL_curcop
     * to get the current hints. So restore it early.
     */
    PL_curcop = cx->blk_oldcop;

    CX_LEAVE_SCOPE(cx);
    cx_popeval(cx);
    cx_popblock(cx);
d4319 5
a4323 1
    CX_POP(cx);
d4330 3
a4332 1
    if (namesv) { /* require returned false */
d4334 13
a4346 2
        S_undo_inc_then_croak(aTHX_ namesv, NULL, TRUE);
        NOT_REACHED; /* NOTREACHED */
d4349 1
a4349 4
    if (!keep)
        CLEAR_ERRSV();

    return retop;
d4357 3
d4361 1
d4363 7
a4369 5
    cx = CX_CUR();
    CX_LEAVE_SCOPE(cx);
    cx_popeval(cx);
    cx_popblock(cx);
    CX_POP(cx);
d4374 2
a4375 2
void
Perl_create_eval_scope(pTHX_ OP *retop, U32 flags)
d4378 1
a4378 1
    const U8 gimme = GIMME_V;
d4380 5
a4384 3
    cx = cx_pushblock((CXt_EVAL|CXp_TRYBLOCK), gimme,
                    PL_stack_sp, PL_savestack_ix);
    cx_pusheval(cx, retop, NULL);
d4394 1
d4399 3
a4401 1
    create_eval_scope(cLOGOP->op_other->op_next, 0);
a4404 3

/* also tail-called by pp_return */

d4407 4
a4410 2
    SV **oldsp;
    U8 gimme;
d4412 1
a4412 1
    OP *retop;
d4415 3
d4419 4
a4422 14
    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_EVAL);
    oldsp = PL_stack_base + cx->blk_oldsp;
    gimme = cx->blk_gimme;

    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 1);
    CX_LEAVE_SCOPE(cx);
    cx_popeval(cx);
    cx_popblock(cx);
    retop = cx->blk_eval.retop;
    CX_POP(cx);
d4424 1
d4426 1
a4426 1
    return retop;
d4431 1
a4431 1
    dSP;
d4433 1
a4433 3
    const U8 gimme = GIMME_V;
    SV *origsv = DEFSV;
    SV *newsv = POPs;
d4435 12
a4446 2
    assert(!PL_op->op_targ); /* used to be set for lexical $_ */
    GvSV(PL_defgv) = SvREFCNT_inc(newsv);
d4448 2
a4449 2
    cx = cx_pushblock(CXt_GIVEN, gimme, SP, PL_savestack_ix);
    cx_pushgiven(cx, origsv);
d4456 1
d4458 3
a4460 2
    U8 gimme;
    SV **oldsp;
d4463 1
a4463 1
    cx = CX_CUR();
a4464 2
    oldsp = PL_stack_base + cx->blk_oldsp;
    gimme = cx->blk_gimme;
d4466 4
a4469 4
    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 1);
d4471 2
a4472 6
    CX_LEAVE_SCOPE(cx);
    cx_popgiven(cx);
    cx_popblock(cx);
    CX_POP(cx);

    return NORMAL;
d4479 1
d4495 1
a4496 1
    bool result;
d4505 1
a4505 4
    result = SvTRUEx(POPs);
    PUTBACK;

    return result;
d4511 2
d4533 1
d4570 1
a4570 1
    PUTBACK;
d4581 1
a4581 1
    if (SvROK(e) && SvOBJECT(SvRV(e)) && (SvTYPE(SvRV(e)) != SVt_REGEXP)) {
d4585 1
a4585 1
    if (SvROK(d) && SvOBJECT(SvRV(d)) && (SvTYPE(SvRV(d)) != SVt_REGEXP))
a4766 1
                    PUTBACK;
a4767 1
                        SPAGAIN;
a4771 1
                    SPAGAIN;
a4875 1
                    PUTBACK;
a4876 1
                        SPAGAIN;
a4879 1
                    SPAGAIN;
a4939 1
            bool result;
d4943 3
a4945 3
	    result = matcher_matches_sv(matcher, d);
            SPAGAIN;
	    PUSHs(result ? &PL_sv_yes : &PL_sv_no);
d5005 1
a5005 1
    dSP;
d5007 1
a5007 1
    const U8 gimme = GIMME_V;
d5015 1
a5015 1
    if (!(PL_op->op_flags & OPf_SPECIAL) && !SvTRUEx(POPs))
d5018 5
a5022 2
    cx = cx_pushblock(CXt_WHEN, gimme, SP, PL_savestack_ix);
    cx_pushwhen(cx);
d5029 1
d5032 3
a5034 2
    U8 gimme;
    SV **oldsp;
d5036 1
a5036 5
    cx = CX_CUR();
    assert(CxTYPE(cx) == CXt_WHEN);
    gimme = cx->blk_gimme;

    cxix = dopoptogivenfor(cxstack_ix);
d5042 7
a5048 5
    oldsp = PL_stack_base + cx->blk_oldsp;
    if (gimme == G_VOID)
        PL_stack_sp = oldsp;
    else
        leave_adjust_stacks(oldsp, oldsp, gimme, 1);
d5050 4
a5053 3
    /* pop the WHEN, BLOCK and anything else before the GIVEN/FOR */
    assert(cxix < cxstack_ix);
    dounwind(cxix);
d5058 6
a5063 4
        /* emulate pp_next. Note that any stack(s) cleanup will be
         * done by the pp_unstack which op_nextop should point to */
        cx = CX_CUR();
	cx_topblock(cx);
d5065 2
d5071 1
a5071 2
        assert(cx->blk_givwhen.leave_op->op_type == OP_LEAVEGIVEN);
	return cx->blk_givwhen.leave_op;
d5077 1
d5080 5
a5084 1
    OP *nextop;
d5093 1
a5093 1
    cx = CX_CUR();
a5094 6
    PL_stack_sp = PL_stack_base + cx->blk_oldsp;
    CX_LEAVE_SCOPE(cx);
    cx_popwhen(cx);
    cx_popblock(cx);
    nextop = cx->blk_givwhen.leave_op->op_next;
    CX_POP(cx);
d5096 5
a5100 1
    return nextop;
d5105 1
d5109 1
a5109 1
    cxix = dopoptogivenfor(cxstack_ix);
d5121 1
a5121 2
    cx = CX_CUR();
    PL_stack_sp = PL_stack_base + cx->blk_oldsp;
d5217 1
a5217 1
	    /* FALLTHROUGH */
d5408 1
d5428 1
a5428 1
       parse error occurred.  (Had to hack around it with a test
d5605 6
@


