head	1.17;
access;
symbols
	PERL_5_24_2:1.1.1.16
	OPENBSD_6_1:1.17.0.4
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.17
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.43;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.39;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.22.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.18;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.19;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.45;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.43;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.18;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.36;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.36;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.02;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.32;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.55;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.39;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.04;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.52;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.15.37;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.46.11;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.36;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.17;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.06.16;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.58.42;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.52.31;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2017.08.14.13.45.22;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    av.c
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/*
 * '...for the Entwives desired order, and plenty, and peace (by which they
 *  meant that things should remain where they had set them).' --Treebeard
 *
 *     [p.476 of _The Lord of the Rings_, III/iv: "Treebeard"]
 */

/*
=head1 Array Manipulation Functions
*/

#include "EXTERN.h"
#define PERL_IN_AV_C
#include "perl.h"

void
Perl_av_reify(pTHX_ AV *av)
{
    SSize_t key;

    PERL_ARGS_ASSERT_AV_REIFY;
    assert(SvTYPE(av) == SVt_PVAV);

    if (AvREAL(av))
	return;
#ifdef DEBUGGING
    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied))
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING), "av_reify called on tied array");
#endif
    key = AvMAX(av) + 1;
    while (key > AvFILLp(av) + 1)
	AvARRAY(av)[--key] = NULL;
    while (key) {
	SV * const sv = AvARRAY(av)[--key];
	if (sv != &PL_sv_undef)
	    SvREFCNT_inc_simple_void(sv);
    }
    key = AvARRAY(av) - AvALLOC(av);
    while (key)
	AvALLOC(av)[--key] = NULL;
    AvREIFY_off(av);
    AvREAL_on(av);
}

/*
=for apidoc av_extend

Pre-extend an array.  The C<key> is the index to which the array should be
extended.

=cut
*/

void
Perl_av_extend(pTHX_ AV *av, SSize_t key)
{
    MAGIC *mg;

    PERL_ARGS_ASSERT_AV_EXTEND;
    assert(SvTYPE(av) == SVt_PVAV);

    mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied);
    if (mg) {
	SV *arg1 = sv_newmortal();
	sv_setiv(arg1, (IV)(key + 1));
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(EXTEND), G_DISCARD, 1,
			    arg1);
	return;
    }
    av_extend_guts(av,key,&AvMAX(av),&AvALLOC(av),&AvARRAY(av));
}    

/* The guts of av_extend.  *Not* for general use! */
void
Perl_av_extend_guts(pTHX_ AV *av, SSize_t key, SSize_t *maxp, SV ***allocp,
			  SV ***arrayp)
{
    PERL_ARGS_ASSERT_AV_EXTEND_GUTS;

    if (key < -1) /* -1 is legal */
        Perl_croak(aTHX_
            "panic: av_extend_guts() negative count (%"IVdf")", (IV)key);

    if (key > *maxp) {
	SV** ary;
	SSize_t tmp;
	SSize_t newmax;

	if (av && *allocp != *arrayp) {
	    ary = *allocp + AvFILLp(av) + 1;
	    tmp = *arrayp - *allocp;
	    Move(*arrayp, *allocp, AvFILLp(av)+1, SV*);
	    *maxp += tmp;
	    *arrayp = *allocp;
	    if (AvREAL(av)) {
		while (tmp)
		    ary[--tmp] = NULL;
	    }
	    if (key > *maxp - 10) {
		newmax = key + *maxp;
		goto resize;
	    }
	}
	else {
	    if (*allocp) {

#ifdef Perl_safesysmalloc_size
		/* Whilst it would be quite possible to move this logic around
		   (as I did in the SV code), so as to set AvMAX(av) early,
		   based on calling Perl_safesysmalloc_size() immediately after
		   allocation, I'm not convinced that it is a great idea here.
		   In an array we have to loop round setting everything to
		   NULL, which means writing to memory, potentially lots
		   of it, whereas for the SV buffer case we don't touch the
		   "bonus" memory. So there there is no cost in telling the
		   world about it, whereas here we have to do work before we can
		   tell the world about it, and that work involves writing to
		   memory that might never be read. So, I feel, better to keep
		   the current lazy system of only writing to it if our caller
		   has a need for more space. NWC  */
		newmax = Perl_safesysmalloc_size((void*)*allocp) /
		    sizeof(const SV *) - 1;

		if (key <= newmax) 
		    goto resized;
#endif 
                /* overflow-safe version of newmax = key + *maxp/5 */
		newmax = *maxp / 5;
                newmax = (key > SSize_t_MAX - newmax)
                            ? SSize_t_MAX : key + newmax;
	      resize:
		{
#ifdef PERL_MALLOC_WRAP /* Duplicated in pp_hot.c */
		    static const char oom_array_extend[] =
			"Out of memory during array extend";
#endif
                    /* it should really be newmax+1 here, but if newmax
                     * happens to equal SSize_t_MAX, then newmax+1 is
                     * undefined. This means technically we croak one
                     * index lower than we should in theory; in practice
                     * its unlikely the system has SSize_t_MAX/sizeof(SV*)
                     * bytes to spare! */
		    MEM_WRAP_CHECK_1(newmax, SV*, oom_array_extend);
		}
#ifdef STRESS_REALLOC
		{
		    SV ** const old_alloc = *allocp;
		    Newx(*allocp, newmax+1, SV*);
		    Copy(old_alloc, *allocp, *maxp + 1, SV*);
		    Safefree(old_alloc);
		}
#else
		Renew(*allocp,newmax+1, SV*);
#endif
#ifdef Perl_safesysmalloc_size
	      resized:
#endif
		ary = *allocp + *maxp + 1;
		tmp = newmax - *maxp;
		if (av == PL_curstack) {	/* Oops, grew stack (via av_store()?) */
		    PL_stack_sp = *allocp + (PL_stack_sp - PL_stack_base);
		    PL_stack_base = *allocp;
		    PL_stack_max = PL_stack_base + newmax;
		}
	    }
	    else {
		newmax = key < 3 ? 3 : key;
		{
#ifdef PERL_MALLOC_WRAP /* Duplicated in pp_hot.c */
		    static const char oom_array_extend[] =
			"Out of memory during array extend";
#endif
                    /* see comment above about newmax+1*/
		    MEM_WRAP_CHECK_1(newmax, SV*, oom_array_extend);
		}
		Newx(*allocp, newmax+1, SV*);
		ary = *allocp + 1;
		tmp = newmax;
		*allocp[0] = NULL;	/* For the stacks */
	    }
	    if (av && AvREAL(av)) {
		while (tmp)
		    ary[--tmp] = NULL;
	    }
	    
	    *arrayp = *allocp;
	    *maxp = newmax;
	}
    }
}

/*
=for apidoc av_fetch

Returns the SV at the specified index in the array.  The C<key> is the
index.  If lval is true, you are guaranteed to get a real SV back (in case
it wasn't real before), which you can then modify.  Check that the return
value is non-null before dereferencing it to a C<SV*>.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for
more information on how to use this function on tied arrays. 

The rough perl equivalent is C<$myarray[$idx]>.

=cut
*/

static bool
S_adjust_index(pTHX_ AV *av, const MAGIC *mg, SSize_t *keyp)
{
    bool adjust_index = 1;
    if (mg) {
	/* Handle negative array indices 20020222 MJD */
	SV * const ref = SvTIED_obj(MUTABLE_SV(av), mg);
	SvGETMAGIC(ref);
	if (SvROK(ref) && SvOBJECT(SvRV(ref))) {
	    SV * const * const negative_indices_glob =
		hv_fetchs(SvSTASH(SvRV(ref)), NEGATIVE_INDICES_VAR, 0);

	    if (negative_indices_glob && isGV(*negative_indices_glob)
	     && SvTRUE(GvSV(*negative_indices_glob)))
		adjust_index = 0;
	}
    }

    if (adjust_index) {
	*keyp += AvFILL(av) + 1;
	if (*keyp < 0)
	    return FALSE;
    }
    return TRUE;
}

SV**
Perl_av_fetch(pTHX_ AV *av, SSize_t key, I32 lval)
{
    PERL_ARGS_ASSERT_AV_FETCH;
    assert(SvTYPE(av) == SVt_PVAV);

    if (SvRMAGICAL(av)) {
        const MAGIC * const tied_magic
	    = mg_find((const SV *)av, PERL_MAGIC_tied);
        if (tied_magic || mg_find((const SV *)av, PERL_MAGIC_regdata)) {
	    SV *sv;
	    if (key < 0) {
		if (!S_adjust_index(aTHX_ av, tied_magic, &key))
			return NULL;
	    }

            sv = sv_newmortal();
	    sv_upgrade(sv, SVt_PVLV);
	    mg_copy(MUTABLE_SV(av), sv, 0, key);
	    if (!tied_magic) /* for regdata, force leavesub to make copies */
		SvTEMP_off(sv);
	    LvTYPE(sv) = 't';
	    LvTARG(sv) = sv; /* fake (SV**) */
	    return &(LvTARG(sv));
        }
    }

    if (key < 0) {
	key += AvFILL(av) + 1;
	if (key < 0)
	    return NULL;
    }

    if (key > AvFILLp(av) || !AvARRAY(av)[key]) {
      emptyness:
	return lval ? av_store(av,key,newSV(0)) : NULL;
    }

    if (AvREIFY(av)
	     && (!AvARRAY(av)[key]	/* eg. @@_ could have freed elts */
		 || SvIS_FREED(AvARRAY(av)[key]))) {
	AvARRAY(av)[key] = NULL;	/* 1/2 reify */
	goto emptyness;
    }
    return &AvARRAY(av)[key];
}

/*
=for apidoc av_store

Stores an SV in an array.  The array index is specified as C<key>.  The
return value will be C<NULL> if the operation failed or if the value did not
need to be actually stored within the array (as in the case of tied
arrays).  Otherwise, it can be dereferenced
to get the C<SV*> that was stored
there (= C<val>)).

Note that the caller is responsible for suitably incrementing the reference
count of C<val> before the call, and decrementing it if the function
returned C<NULL>.

Approximate Perl equivalent: C<$myarray[$key] = $val;>.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for
more information on how to use this function on tied arrays.

=cut
*/

SV**
Perl_av_store(pTHX_ AV *av, SSize_t key, SV *val)
{
    SV** ary;

    PERL_ARGS_ASSERT_AV_STORE;
    assert(SvTYPE(av) == SVt_PVAV);

    /* S_regclass relies on being able to pass in a NULL sv
       (unicode_alternate may be NULL).
    */

    if (SvRMAGICAL(av)) {
        const MAGIC * const tied_magic = mg_find((const SV *)av, PERL_MAGIC_tied);
        if (tied_magic) {
            if (key < 0) {
		if (!S_adjust_index(aTHX_ av, tied_magic, &key))
                        return 0;
            }
	    if (val) {
		mg_copy(MUTABLE_SV(av), val, 0, key);
	    }
	    return NULL;
        }
    }


    if (key < 0) {
	key += AvFILL(av) + 1;
	if (key < 0)
	    return NULL;
    }

    if (SvREADONLY(av) && key >= AvFILL(av))
	Perl_croak_no_modify();

    if (!AvREAL(av) && AvREIFY(av))
	av_reify(av);
    if (key > AvMAX(av))
	av_extend(av,key);
    ary = AvARRAY(av);
    if (AvFILLp(av) < key) {
	if (!AvREAL(av)) {
	    if (av == PL_curstack && key > PL_stack_sp - PL_stack_base)
		PL_stack_sp = PL_stack_base + key;	/* XPUSH in disguise */
	    do {
		ary[++AvFILLp(av)] = NULL;
	    } while (AvFILLp(av) < key);
	}
	AvFILLp(av) = key;
    }
    else if (AvREAL(av))
	SvREFCNT_dec(ary[key]);
    ary[key] = val;
    if (SvSMAGICAL(av)) {
	const MAGIC *mg = SvMAGIC(av);
	bool set = TRUE;
	for (; mg; mg = mg->mg_moremagic) {
	  if (!isUPPER(mg->mg_type)) continue;
	  if (val) {
	    sv_magic(val, MUTABLE_SV(av), toLOWER(mg->mg_type), 0, key);
	  }
	  if (PL_delaymagic && mg->mg_type == PERL_MAGIC_isa) {
	    PL_delaymagic |= DM_ARRAY_ISA;
	    set = FALSE;
	  }
	}
	if (set)
	   mg_set(MUTABLE_SV(av));
    }
    return &ary[key];
}

/*
=for apidoc av_make

Creates a new AV and populates it with a list of SVs.  The SVs are copied
into the array, so they may be freed after the call to C<av_make>.  The new AV
will have a reference count of 1.

Perl equivalent: C<my @@new_array = ($scalar1, $scalar2, $scalar3...);>

=cut
*/

AV *
Perl_av_make(pTHX_ SSize_t size, SV **strp)
{
    AV * const av = MUTABLE_AV(newSV_type(SVt_PVAV));
    /* sv_upgrade does AvREAL_only()  */
    PERL_ARGS_ASSERT_AV_MAKE;
    assert(SvTYPE(av) == SVt_PVAV);

    if (size) {		/* "defined" was returning undef for size==0 anyway. */
        SV** ary;
        SSize_t i;
	Newx(ary,size,SV*);
	AvALLOC(av) = ary;
	AvARRAY(av) = ary;
	AvMAX(av) = size - 1;
	AvFILLp(av) = -1;
	ENTER;
	SAVEFREESV(av);
	for (i = 0; i < size; i++) {
	    assert (*strp);

	    /* Don't let sv_setsv swipe, since our source array might
	       have multiple references to the same temp scalar (e.g.
	       from a list slice) */

	    SvGETMAGIC(*strp); /* before newSV, in case it dies */
	    AvFILLp(av)++;
	    ary[i] = newSV(0);
	    sv_setsv_flags(ary[i], *strp,
			   SV_DO_COW_SVSETSV|SV_NOSTEAL);
	    strp++;
	}
	SvREFCNT_inc_simple_void_NN(av);
	LEAVE;
    }
    return av;
}

/*
=for apidoc av_clear

Frees the all the elements of an array, leaving it empty.
The XS equivalent of C<@@array = ()>.  See also L</av_undef>.

Note that it is possible that the actions of a destructor called directly
or indirectly by freeing an element of the array could cause the reference
count of the array itself to be reduced (e.g. by deleting an entry in the
symbol table). So it is a possibility that the AV could have been freed
(or even reallocated) on return from the call unless you hold a reference
to it.

=cut
*/

void
Perl_av_clear(pTHX_ AV *av)
{
    SSize_t extra;
    bool real;

    PERL_ARGS_ASSERT_AV_CLEAR;
    assert(SvTYPE(av) == SVt_PVAV);

#ifdef DEBUGGING
    if (SvREFCNT(av) == 0) {
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING), "Attempt to clear deleted array");
    }
#endif

    if (SvREADONLY(av))
	Perl_croak_no_modify();

    /* Give any tie a chance to cleanup first */
    if (SvRMAGICAL(av)) {
	const MAGIC* const mg = SvMAGIC(av);
	if (PL_delaymagic && mg && mg->mg_type == PERL_MAGIC_isa)
	    PL_delaymagic |= DM_ARRAY_ISA;
        else
	    mg_clear(MUTABLE_SV(av)); 
    }

    if (AvMAX(av) < 0)
	return;

    if ((real = !!AvREAL(av))) {
	SV** const ary = AvARRAY(av);
	SSize_t index = AvFILLp(av) + 1;
	ENTER;
	SAVEFREESV(SvREFCNT_inc_simple_NN(av));
	while (index) {
	    SV * const sv = ary[--index];
	    /* undef the slot before freeing the value, because a
	     * destructor might try to modify this array */
	    ary[index] = NULL;
	    SvREFCNT_dec(sv);
	}
    }
    extra = AvARRAY(av) - AvALLOC(av);
    if (extra) {
	AvMAX(av) += extra;
	AvARRAY(av) = AvALLOC(av);
    }
    AvFILLp(av) = -1;
    if (real) LEAVE;
}

/*
=for apidoc av_undef

Undefines the array. The XS equivalent of C<undef(@@array)>.

As well as freeing all the elements of the array (like C<av_clear()>), this
also frees the memory used by the av to store its list of scalars.

See L</av_clear> for a note about the array possibly being invalid on
return.

=cut
*/

void
Perl_av_undef(pTHX_ AV *av)
{
    bool real;

    PERL_ARGS_ASSERT_AV_UNDEF;
    assert(SvTYPE(av) == SVt_PVAV);

    /* Give any tie a chance to cleanup first */
    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied)) 
	av_fill(av, -1);

    if ((real = !!AvREAL(av))) {
	SSize_t key = AvFILLp(av) + 1;
	ENTER;
	SAVEFREESV(SvREFCNT_inc_simple_NN(av));
	while (key)
	    SvREFCNT_dec(AvARRAY(av)[--key]);
    }

    Safefree(AvALLOC(av));
    AvALLOC(av) = NULL;
    AvARRAY(av) = NULL;
    AvMAX(av) = AvFILLp(av) = -1;

    if(SvRMAGICAL(av)) mg_clear(MUTABLE_SV(av));
    if(real) LEAVE;
}

/*

=for apidoc av_create_and_push

Push an SV onto the end of the array, creating the array if necessary.
A small internal helper function to remove a commonly duplicated idiom.

=cut
*/

void
Perl_av_create_and_push(pTHX_ AV **const avp, SV *const val)
{
    PERL_ARGS_ASSERT_AV_CREATE_AND_PUSH;

    if (!*avp)
	*avp = newAV();
    av_push(*avp, val);
}

/*
=for apidoc av_push

Pushes an SV (transferring control of one reference count) onto the end of the
array.  The array will grow automatically to accommodate the addition.

Perl equivalent: C<push @@myarray, $elem;>.

=cut
*/

void
Perl_av_push(pTHX_ AV *av, SV *val)
{             
    MAGIC *mg;

    PERL_ARGS_ASSERT_AV_PUSH;
    assert(SvTYPE(av) == SVt_PVAV);

    if (SvREADONLY(av))
	Perl_croak_no_modify();

    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(PUSH), G_DISCARD, 1,
			    val);
	return;
    }
    av_store(av,AvFILLp(av)+1,val);
}

/*
=for apidoc av_pop

Removes one SV from the end of the array, reducing its size by one and
returning the SV (transferring control of one reference count) to the
caller.  Returns C<&PL_sv_undef> if the array is empty.

Perl equivalent: C<pop(@@myarray);>

=cut
*/

SV *
Perl_av_pop(pTHX_ AV *av)
{
    SV *retval;
    MAGIC* mg;

    PERL_ARGS_ASSERT_AV_POP;
    assert(SvTYPE(av) == SVt_PVAV);

    if (SvREADONLY(av))
	Perl_croak_no_modify();
    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
	retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(POP), 0, 0);
	if (retval)
	    retval = newSVsv(retval);
	return retval;
    }
    if (AvFILL(av) < 0)
	return &PL_sv_undef;
    retval = AvARRAY(av)[AvFILLp(av)];
    AvARRAY(av)[AvFILLp(av)--] = NULL;
    if (SvSMAGICAL(av))
	mg_set(MUTABLE_SV(av));
    return retval ? retval : &PL_sv_undef;
}

/*

=for apidoc av_create_and_unshift_one

Unshifts an SV onto the beginning of the array, creating the array if
necessary.
A small internal helper function to remove a commonly duplicated idiom.

=cut
*/

SV **
Perl_av_create_and_unshift_one(pTHX_ AV **const avp, SV *const val)
{
    PERL_ARGS_ASSERT_AV_CREATE_AND_UNSHIFT_ONE;

    if (!*avp)
	*avp = newAV();
    av_unshift(*avp, 1);
    return av_store(*avp, 0, val);
}

/*
=for apidoc av_unshift

Unshift the given number of C<undef> values onto the beginning of the
array.  The array will grow automatically to accommodate the addition.  You
must then use C<av_store> to assign values to these new elements.

Perl equivalent: S<C<unshift @@myarray, ( (undef) x $n );>>

=cut
*/

void
Perl_av_unshift(pTHX_ AV *av, SSize_t num)
{
    SSize_t i;
    MAGIC* mg;

    PERL_ARGS_ASSERT_AV_UNSHIFT;
    assert(SvTYPE(av) == SVt_PVAV);

    if (SvREADONLY(av))
	Perl_croak_no_modify();

    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(UNSHIFT),
			    G_DISCARD | G_UNDEF_FILL, num);
	return;
    }

    if (num <= 0)
      return;
    if (!AvREAL(av) && AvREIFY(av))
	av_reify(av);
    i = AvARRAY(av) - AvALLOC(av);
    if (i) {
	if (i > num)
	    i = num;
	num -= i;
    
	AvMAX(av) += i;
	AvFILLp(av) += i;
	AvARRAY(av) = AvARRAY(av) - i;
    }
    if (num) {
	SV **ary;
	const SSize_t i = AvFILLp(av);
	/* Create extra elements */
	const SSize_t slide = i > 0 ? i : 0;
	num += slide;
	av_extend(av, i + num);
	AvFILLp(av) += num;
	ary = AvARRAY(av);
	Move(ary, ary + num, i + 1, SV*);
	do {
	    ary[--num] = NULL;
	} while (num);
	/* Make extra elements into a buffer */
	AvMAX(av) -= slide;
	AvFILLp(av) -= slide;
	AvARRAY(av) = AvARRAY(av) + slide;
    }
}

/*
=for apidoc av_shift

Removes one SV from the start of the array, reducing its size by one and
returning the SV (transferring control of one reference count) to the
caller.  Returns C<&PL_sv_undef> if the array is empty.

Perl equivalent: C<shift(@@myarray);>

=cut
*/

SV *
Perl_av_shift(pTHX_ AV *av)
{
    SV *retval;
    MAGIC* mg;

    PERL_ARGS_ASSERT_AV_SHIFT;
    assert(SvTYPE(av) == SVt_PVAV);

    if (SvREADONLY(av))
	Perl_croak_no_modify();
    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
	retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(SHIFT), 0, 0);
	if (retval)
	    retval = newSVsv(retval);
	return retval;
    }
    if (AvFILL(av) < 0)
      return &PL_sv_undef;
    retval = *AvARRAY(av);
    if (AvREAL(av))
	*AvARRAY(av) = NULL;
    AvARRAY(av) = AvARRAY(av) + 1;
    AvMAX(av)--;
    AvFILLp(av)--;
    if (SvSMAGICAL(av))
	mg_set(MUTABLE_SV(av));
    return retval ? retval : &PL_sv_undef;
}

/*
=for apidoc av_top_index

Returns the highest index in the array.  The number of elements in the
array is S<C<av_top_index(av) + 1>>.  Returns -1 if the array is empty.

The Perl equivalent for this is C<$#myarray>.

(A slightly shorter form is C<av_tindex>.)

=for apidoc av_len

Same as L</av_top_index>.  Note that, unlike what the name implies, it returns
the highest index in the array, so to get the size of the array you need to use
S<C<av_len(av) + 1>>.  This is unlike L</sv_len>, which returns what you would
expect.

=cut
*/

SSize_t
Perl_av_len(pTHX_ AV *av)
{
    PERL_ARGS_ASSERT_AV_LEN;

    return av_top_index(av);
}

/*
=for apidoc av_fill

Set the highest index in the array to the given number, equivalent to
Perl's S<C<$#array = $fill;>>.

The number of elements in the array will be S<C<fill + 1>> after
C<av_fill()> returns.  If the array was previously shorter, then the
additional elements appended are set to NULL.  If the array
was longer, then the excess elements are freed.  S<C<av_fill(av, -1)>> is
the same as C<av_clear(av)>.

=cut
*/
void
Perl_av_fill(pTHX_ AV *av, SSize_t fill)
{
    MAGIC *mg;

    PERL_ARGS_ASSERT_AV_FILL;
    assert(SvTYPE(av) == SVt_PVAV);

    if (fill < 0)
	fill = -1;
    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
	SV *arg1 = sv_newmortal();
	sv_setiv(arg1, (IV)(fill + 1));
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(STORESIZE), G_DISCARD,
			    1, arg1);
	return;
    }
    if (fill <= AvMAX(av)) {
	SSize_t key = AvFILLp(av);
	SV** const ary = AvARRAY(av);

	if (AvREAL(av)) {
	    while (key > fill) {
		SvREFCNT_dec(ary[key]);
		ary[key--] = NULL;
	    }
	}
	else {
	    while (key < fill)
		ary[++key] = NULL;
	}
	    
	AvFILLp(av) = fill;
	if (SvSMAGICAL(av))
	    mg_set(MUTABLE_SV(av));
    }
    else
	(void)av_store(av,fill,NULL);
}

/*
=for apidoc av_delete

Deletes the element indexed by C<key> from the array, makes the element mortal,
and returns it.  If C<flags> equals C<G_DISCARD>, the element is freed and null
is returned.  Perl equivalent: S<C<my $elem = delete($myarray[$idx]);>> for the
non-C<G_DISCARD> version and a void-context S<C<delete($myarray[$idx]);>> for the
C<G_DISCARD> version.

=cut
*/
SV *
Perl_av_delete(pTHX_ AV *av, SSize_t key, I32 flags)
{
    SV *sv;

    PERL_ARGS_ASSERT_AV_DELETE;
    assert(SvTYPE(av) == SVt_PVAV);

    if (SvREADONLY(av))
	Perl_croak_no_modify();

    if (SvRMAGICAL(av)) {
        const MAGIC * const tied_magic
	    = mg_find((const SV *)av, PERL_MAGIC_tied);
        if ((tied_magic || mg_find((const SV *)av, PERL_MAGIC_regdata))) {
            SV **svp;
            if (key < 0) {
		if (!S_adjust_index(aTHX_ av, tied_magic, &key))
			return NULL;
            }
            svp = av_fetch(av, key, TRUE);
            if (svp) {
                sv = *svp;
                mg_clear(sv);
                if (mg_find(sv, PERL_MAGIC_tiedelem)) {
                    sv_unmagic(sv, PERL_MAGIC_tiedelem); /* No longer an element */
                    return sv;
                }
		return NULL;
            }
        }
    }

    if (key < 0) {
	key += AvFILL(av) + 1;
	if (key < 0)
	    return NULL;
    }

    if (key > AvFILLp(av))
	return NULL;
    else {
	if (!AvREAL(av) && AvREIFY(av))
	    av_reify(av);
	sv = AvARRAY(av)[key];
	AvARRAY(av)[key] = NULL;
	if (key == AvFILLp(av)) {
	    do {
		AvFILLp(av)--;
	    } while (--key >= 0 && !AvARRAY(av)[key]);
	}
	if (SvSMAGICAL(av))
	    mg_set(MUTABLE_SV(av));
    }
    if(sv != NULL) {
	if (flags & G_DISCARD) {
	    SvREFCNT_dec_NN(sv);
	    return NULL;
	}
	else if (AvREAL(av))
	    sv_2mortal(sv);
    }
    return sv;
}

/*
=for apidoc av_exists

Returns true if the element indexed by C<key> has been initialized.

This relies on the fact that uninitialized array elements are set to
C<NULL>.

Perl equivalent: C<exists($myarray[$key])>.

=cut
*/
bool
Perl_av_exists(pTHX_ AV *av, SSize_t key)
{
    PERL_ARGS_ASSERT_AV_EXISTS;
    assert(SvTYPE(av) == SVt_PVAV);

    if (SvRMAGICAL(av)) {
        const MAGIC * const tied_magic
	    = mg_find((const SV *)av, PERL_MAGIC_tied);
        const MAGIC * const regdata_magic
            = mg_find((const SV *)av, PERL_MAGIC_regdata);
        if (tied_magic || regdata_magic) {
            MAGIC *mg;
            /* Handle negative array indices 20020222 MJD */
            if (key < 0) {
		if (!S_adjust_index(aTHX_ av, tied_magic, &key))
                        return FALSE;
            }

            if(key >= 0 && regdata_magic) {
                if (key <= AvFILL(av))
                    return TRUE;
                else
                    return FALSE;
            }
	    {
		SV * const sv = sv_newmortal();
		mg_copy(MUTABLE_SV(av), sv, 0, key);
		mg = mg_find(sv, PERL_MAGIC_tiedelem);
		if (mg) {
		    magic_existspack(sv, mg);
		    {
			I32 retbool = SvTRUE_nomg_NN(sv);
			return cBOOL(retbool);
		    }
		}
	    }
        }
    }

    if (key < 0) {
	key += AvFILL(av) + 1;
	if (key < 0)
	    return FALSE;
    }

    if (key <= AvFILLp(av) && AvARRAY(av)[key])
    {
	return TRUE;
    }
    else
	return FALSE;
}

static MAGIC *
S_get_aux_mg(pTHX_ AV *av) {
    MAGIC *mg;

    PERL_ARGS_ASSERT_GET_AUX_MG;
    assert(SvTYPE(av) == SVt_PVAV);

    mg = mg_find((const SV *)av, PERL_MAGIC_arylen_p);

    if (!mg) {
	mg = sv_magicext(MUTABLE_SV(av), 0, PERL_MAGIC_arylen_p,
			 &PL_vtbl_arylen_p, 0, 0);
	assert(mg);
	/* sv_magicext won't set this for us because we pass in a NULL obj  */
	mg->mg_flags |= MGf_REFCOUNTED;
    }
    return mg;
}

SV **
Perl_av_arylen_p(pTHX_ AV *av) {
    MAGIC *const mg = get_aux_mg(av);

    PERL_ARGS_ASSERT_AV_ARYLEN_P;
    assert(SvTYPE(av) == SVt_PVAV);

    return &(mg->mg_obj);
}

IV *
Perl_av_iter_p(pTHX_ AV *av) {
    MAGIC *const mg = get_aux_mg(av);

    PERL_ARGS_ASSERT_AV_ITER_P;
    assert(SvTYPE(av) == SVt_PVAV);

#if IVSIZE == I32SIZE
    return (IV *)&(mg->mg_len);
#else
    if (!mg->mg_ptr) {
	IV *temp;
	mg->mg_len = IVSIZE;
	Newxz(temp, 1, IV);
	mg->mg_ptr = (char *) temp;
    }
    return (IV *)mg->mg_ptr;
#endif
}

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a28 1
    dVAR;
a66 1
    dVAR;
d88 1
a88 1
    dVAR;
d90 3
a92 1
    PERL_ARGS_ASSERT_AV_EXTEND_GUTS;
d137 4
a140 1
		newmax = key + *maxp / 5;
d147 7
a153 1
		    MEM_WRAP_CHECK_1(newmax+1, SV*, oom_array_extend);
d183 2
a184 1
		    MEM_WRAP_CHECK_1(newmax+1, SV*, oom_array_extend);
a246 2
    dVAR;

d295 1
a295 1
return value will be NULL if the operation failed or if the value did not
d303 1
a303 1
returned NULL.
a315 1
    dVAR;
d390 1
a390 1
into the array, so they may be freed after the call to av_make.  The new AV
d439 2
a440 3
Clears an array, making it empty.  Does not free the memory the av uses to
store its list of scalars.  If any destructors are triggered as a result,
the av itself may be freed when this function returns.
d442 6
a447 1
Perl equivalent: C<@@myarray = ();>.
a454 1
    dVAR;
d507 7
a513 3
Undefines the array.  Frees the memory used by the av to store its list of
scalars.  If any destructors are triggered as a result, the av itself may
be freed.
d570 2
a571 2
Pushes an SV onto the end of the array.  The array will grow automatically
to accommodate the addition.  This takes ownership of one reference count.
a580 1
    dVAR;
a611 1
    dVAR;
d664 1
a664 1
Perl equivalent: C<unshift @@myarray, ( (undef) x $n );>
a671 1
    dVAR;
a735 1
    dVAR;
d767 1
a767 1
array is C<av_top_index(av) + 1>.  Returns -1 if the array is empty.
a772 4
=for apidoc av_tindex

Same as L</av_top_index>.

d795 1
a795 1
Perl's C<$#array = $fill;>.
d797 2
a798 2
The number of elements in the array will be C<fill + 1> after
av_fill() returns.  If the array was previously shorter, then the
d800 1
a800 1
was longer, then the excess elements are freed.  C<av_fill(av, -1)> is
a807 1
    dVAR;
d850 2
a851 2
is returned.  Perl equivalent: C<my $elem = delete($myarray[$idx]);> for the
non-C<G_DISCARD> version and a void-context C<delete($myarray[$idx]);> for the
a858 1
    dVAR;
d901 1
a902 1
	    AvARRAY(av)[key] = NULL;
a906 2
	else
	    AvARRAY(av)[key] = NULL;
d910 7
a916 3
    if (flags & G_DISCARD) {
	SvREFCNT_dec(sv);
	sv = NULL;
a917 2
    else if (AvREAL(av))
	sv = sv_2mortal(sv);
d927 1
a927 1
NULL.
a935 1
    dVAR;
a988 1
    dVAR;
a1036 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d30 1
a30 1
    I32 key;
d43 1
a43 1
	AvARRAY(av)[--key] = &PL_sv_undef;
a45 1
	assert(sv);
d47 1
a47 1
	    SvREFCNT_inc_simple_void_NN(sv);
d51 1
a51 1
	AvALLOC(av)[--key] = &PL_sv_undef;
d66 1
a66 1
Perl_av_extend(pTHX_ AV *av, I32 key)
d78 1
a78 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "EXTEND", G_DISCARD, 1,
d87 1
a87 1
Perl_av_extend_guts(pTHX_ AV *av, I32 key, SSize_t *maxp, SV ***allocp,
d96 2
a97 2
	I32 tmp;
	I32 newmax;
d107 1
a107 1
		    ary[--tmp] = &PL_sv_undef;
a114 5
#ifdef PERL_MALLOC_WRAP
	    static const char oom_array_extend[] =
	      "Out of memory during array extend"; /* Duplicated in pp_hot.c */
#endif

d123 1
a123 1
		   &PL_sv_undef, which means writing to memory, potentially lots
d139 15
a153 1
		MEM_WRAP_CHECK_1(newmax+1, SV*, oom_array_extend);
d155 1
d169 7
a175 1
		MEM_WRAP_CHECK_1(newmax+1, SV*, oom_array_extend);
d179 1
a179 1
		*allocp[0] = &PL_sv_undef;	/* For the stacks */
d183 1
a183 1
		    ary[--tmp] = &PL_sv_undef;
d209 1
a209 1
S_adjust_index(pTHX_ AV *av, const MAGIC *mg, I32 *keyp)
d220 2
a221 1
	    if (negative_indices_glob && SvTRUE(GvSV(*negative_indices_glob)))
d235 1
a235 1
Perl_av_fetch(pTHX_ AV *av, I32 key, I32 lval)
d269 1
a269 1
    if (key > AvFILLp(av) || AvARRAY(av)[key] == &PL_sv_undef) {
d277 1
a277 1
	AvARRAY(av)[key] = &PL_sv_undef;	/* 1/2 reify */
d289 1
a289 1
arrays). Otherwise, it can be dereferenced
d306 1
a306 1
Perl_av_store(pTHX_ AV *av, I32 key, SV *val)
a317 3
    if (!val)
	val = &PL_sv_undef;

d325 1
a325 1
	    if (val != &PL_sv_undef) {
d352 1
a352 1
		ary[++AvFILLp(av)] = &PL_sv_undef;
d365 1
a365 1
	  if (val != &PL_sv_undef) {
d392 1
a392 1
Perl_av_make(pTHX_ I32 size, SV **strp)
d401 1
a401 1
        I32 i;
d445 1
a445 1
    I32 extra;
d474 1
a474 1
	I32 index = AvFILLp(av) + 1;
d481 1
a481 1
	    ary[index] = &PL_sv_undef;
d517 1
a517 1
	I32 key = AvFILLp(av) + 1;
d577 1
a577 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "PUSH", G_DISCARD, 1,
d609 1
a609 1
	retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "POP", 0, 0);
d617 1
a617 1
    AvARRAY(av)[AvFILLp(av)--] = &PL_sv_undef;
d620 1
a620 1
    return retval;
d658 1
a658 1
Perl_av_unshift(pTHX_ AV *av, I32 num)
d661 1
a661 1
    I32 i;
d671 1
a671 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "UNSHIFT",
d692 1
a692 1
	const I32 i = AvFILLp(av);
d694 1
a694 1
	const I32 slide = i > 0 ? i : 0;
d701 1
a701 1
	    ary[--num] = &PL_sv_undef;
d713 3
a715 3
Shifts an SV off the beginning of the
array.  Returns C<&PL_sv_undef> if the 
array is empty.
d735 1
a735 1
	retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "SHIFT", 0, 0);
d744 1
a744 1
	*AvARRAY(av) = &PL_sv_undef;
d750 1
a750 1
    return retval;
d763 4
d769 4
a772 3
Same as L</av_top_index>.  Returns the highest index in the array.  Note that the
return value is +1 what its name implies it returns; and hence differs in
meaning from what the similarly named L</sv_len> returns.
d777 1
a777 1
I32
d791 1
a791 1
The number of elements in the an array will be C<fill + 1> after
d793 1
a793 1
additional elements appended are set to C<PL_sv_undef>.  If the array
d800 1
a800 1
Perl_av_fill(pTHX_ AV *av, I32 fill)
d813 1
a813 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "STORESIZE", G_DISCARD,
d818 1
a818 1
	I32 key = AvFILLp(av);
d824 1
a824 1
		ary[key--] = &PL_sv_undef;
d829 1
a829 1
		ary[++key] = &PL_sv_undef;
d837 1
a837 1
	(void)av_store(av,fill,&PL_sv_undef);
d852 1
a852 1
Perl_av_delete(pTHX_ AV *av, I32 key, I32 flags)
d898 1
a898 1
	    AvARRAY(av)[key] = &PL_sv_undef;
d901 1
a901 1
	    } while (--key >= 0 && AvARRAY(av)[key] == &PL_sv_undef);
d904 1
a904 1
	    AvARRAY(av)[key] = &PL_sv_undef;
d923 1
a923 1
C<&PL_sv_undef>.
d930 1
a930 1
Perl_av_exists(pTHX_ AV *av, I32 key)
d976 1
a976 2
    if (key <= AvFILLp(av) && AvARRAY(av)[key] != &PL_sv_undef
	&& AvARRAY(av)[key])
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d83 13
a95 1
    if (key > AvMAX(av)) {
d100 6
a105 6
	if (AvALLOC(av) != AvARRAY(av)) {
	    ary = AvALLOC(av) + AvFILLp(av) + 1;
	    tmp = AvARRAY(av) - AvALLOC(av);
	    Move(AvARRAY(av), AvALLOC(av), AvFILLp(av)+1, SV*);
	    AvMAX(av) += tmp;
	    AvARRAY(av) = AvALLOC(av);
d110 2
a111 2
	    if (key > AvMAX(av) - 10) {
		newmax = key + AvMAX(av);
d121 1
a121 5
	    if (AvALLOC(av)) {
#if !defined(STRANGE_MALLOC) && !defined(MYMALLOC)
		MEM_SIZE bytes;
		IV itmp;
#endif
d137 1
a137 1
		newmax = Perl_safesysmalloc_size((void*)AvALLOC(av)) /
d143 1
a143 1
		newmax = key + AvMAX(av) / 5;
d146 1
a146 18
#if defined(STRANGE_MALLOC) || defined(MYMALLOC)
		Renew(AvALLOC(av),newmax+1, SV*);
#else
		bytes = (newmax + 1) * sizeof(const SV *);
#define MALLOC_OVERHEAD 16
		itmp = MALLOC_OVERHEAD;
		while ((MEM_SIZE)(itmp - MALLOC_OVERHEAD) < bytes)
		    itmp += itmp;
		itmp -= MALLOC_OVERHEAD;
		itmp /= sizeof(const SV *);
		assert(itmp > newmax);
		newmax = itmp - 1;
		assert(newmax >= AvMAX(av));
		Newx(ary, newmax+1, SV*);
		Copy(AvALLOC(av), ary, AvMAX(av)+1, SV*);
		Safefree(AvALLOC(av));
		AvALLOC(av) = ary;
#endif
d150 2
a151 2
		ary = AvALLOC(av) + AvMAX(av) + 1;
		tmp = newmax - AvMAX(av);
d153 2
a154 2
		    PL_stack_sp = AvALLOC(av) + (PL_stack_sp - PL_stack_base);
		    PL_stack_base = AvALLOC(av);
d161 2
a162 2
		Newx(AvALLOC(av), newmax+1, SV*);
		ary = AvALLOC(av) + 1;
d164 1
a164 1
		AvALLOC(av)[0] = &PL_sv_undef;	/* For the stacks */
d166 1
a166 1
	    if (AvREAL(av)) {
d171 2
a172 2
	    AvARRAY(av) = AvALLOC(av);
	    AvMAX(av) = newmax;
d193 25
d219 1
a219 1
Perl_av_fetch(pTHX_ register AV *av, I32 key, I32 lval)
d232 1
a232 15
		I32 adjust_index = 1;
		if (tied_magic) {
		    /* Handle negative array indices 20020222 MJD */
		    SV * const * const negative_indices_glob =
			hv_fetch(SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(av),
							 tied_magic))),
				NEGATIVE_INDICES_VAR, 16, 0);

		    if (negative_indices_glob && SvTRUE(GvSV(*negative_indices_glob)))
			adjust_index = 0;
		}

		if (adjust_index) {
		    key += AvFILL(av) + 1;
		    if (key < 0)
a233 1
		}
d290 1
a290 1
Perl_av_store(pTHX_ register AV *av, I32 key, SV *val)
a307 1
            /* Handle negative array indices 20020222 MJD */
d309 1
a309 11
		bool adjust_index = 1;
		SV * const * const negative_indices_glob =
                    hv_fetch(SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(av), 
                                                     tied_magic))), 
                             NEGATIVE_INDICES_VAR, 16, 0);
                if (negative_indices_glob
                    && SvTRUE(GvSV(*negative_indices_glob)))
                    adjust_index = 0;
                if (adjust_index) {
                    key += AvFILL(av) + 1;
                    if (key < 0)
a310 1
                }
d327 1
a327 1
	Perl_croak_no_modify(aTHX);
d379 1
a379 1
Perl_av_make(pTHX_ register I32 size, register SV **strp)
d381 1
a381 1
    register AV * const av = MUTABLE_AV(newSV_type(SVt_PVAV));
d387 2
a388 2
        register SV** ary;
        register I32 i;
d392 4
a395 1
	AvFILLp(av) = AvMAX(av) = size - 1;
d403 2
d407 1
a407 1
			   SV_GMAGIC|SV_DO_COW_SVSETSV|SV_NOSTEAL);
d410 2
d429 1
a429 1
Perl_av_clear(pTHX_ register AV *av)
d445 1
a445 1
	Perl_croak_no_modify(aTHX);
d492 1
a492 1
Perl_av_undef(pTHX_ register AV *av)
d504 1
a504 1
	register I32 key = AvFILLp(av) + 1;
d552 1
a552 1
Perl_av_push(pTHX_ register AV *av, SV *val)
d561 1
a561 1
	Perl_croak_no_modify(aTHX);
d574 3
a576 2
Pops an SV off the end of the array.  Returns C<&PL_sv_undef> if the array
is empty.
d584 1
a584 1
Perl_av_pop(pTHX_ register AV *av)
d594 1
a594 1
	Perl_croak_no_modify(aTHX);
d640 1
a640 1
    
d645 1
a645 1
Perl_av_unshift(pTHX_ register AV *av, register I32 num)
d648 1
a648 1
    register I32 i;
d655 1
a655 1
	Perl_croak_no_modify(aTHX);
d678 1
a678 1
	register SV **ary;
d710 1
a710 1
Perl_av_shift(pTHX_ register AV *av)
d720 1
a720 1
	Perl_croak_no_modify(aTHX);
d741 1
a741 1
=for apidoc av_len
d744 1
a744 1
array is C<av_len(av) + 1>.  Returns -1 if the array is empty.
d748 8
a762 1
    assert(SvTYPE(av) == SVt_PVAV);
d764 1
a764 1
    return AvFILL(av);
d782 1
a782 1
Perl_av_fill(pTHX_ register AV *av, I32 fill)
d843 1
a843 1
	Perl_croak_no_modify(aTHX);
a848 1
            /* Handle negative array indices 20020222 MJD */
d851 1
a851 13
                unsigned adjust_index = 1;
                if (tied_magic) {
		    SV * const * const negative_indices_glob =
                        hv_fetch(SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(av), 
                                                         tied_magic))), 
                                 NEGATIVE_INDICES_VAR, 16, 0);
                    if (negative_indices_glob
                        && SvTRUE(GvSV(*negative_indices_glob)))
                        adjust_index = 0;
                }
                if (adjust_index) {
                    key += AvFILL(av) + 1;
                    if (key < 0)
a852 1
                }
a923 1
	    SV * const sv = sv_newmortal();
d927 1
a927 13
                unsigned adjust_index = 1;
                if (tied_magic) {
		    SV * const * const negative_indices_glob =
                        hv_fetch(SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(av), 
                                                         tied_magic))), 
                                 NEGATIVE_INDICES_VAR, 16, 0);
                    if (negative_indices_glob
                        && SvTRUE(GvSV(*negative_indices_glob)))
                        adjust_index = 0;
                }
                if (adjust_index) {
                    key += AvFILL(av) + 1;
                    if (key < 0)
a928 3
                    else
                        return TRUE;
                }
d937 12
a948 8

            mg_copy(MUTABLE_SV(av), sv, 0, key);
            mg = mg_find(sv, PERL_MAGIC_tiedelem);
            if (mg) {
                magic_existspack(sv, mg);
                return cBOOL(SvTRUE(sv));
            }

d1021 1
a1021 1
 * indent-tabs-mode: t
d1024 1
a1024 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d77 4
a80 13
	dSP;
	ENTER;
	SAVETMPS;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,2);
	PUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
	mPUSHi(key + 1);
        PUTBACK;
	call_method("EXTEND", G_SCALAR|G_DISCARD);
	POPSTACK;
	FREETMPS;
	LEAVE;
d153 1
a153 5
		if (AvMAX(av) > 64)
		    offer_nice_chunk(AvALLOC(av),
				     (AvMAX(av)+1) * sizeof(const SV *));
		else
		    Safefree(AvALLOC(av));
d190 3
a192 2
index.  If C<lval> is set then the fetch will be part of a store.  Check
that the return value is non-null before dereferencing it to a C<SV*>.
d197 2
d238 2
d252 3
a254 4
    if (key > AvFILLp(av)) {
	if (!lval)
	    return NULL;
	return av_store(av,key,newSV(0));
d256 2
a257 7
    if (AvARRAY(av)[key] == &PL_sv_undef) {
    emptyness:
	if (lval)
	    return av_store(av,key,newSV(0));
	return NULL;
    }
    else if (AvREIFY(av)
d272 5
a276 2
arrays). Otherwise it can be dereferenced to get the original C<SV*>.  Note
that the caller is responsible for suitably incrementing the reference
d280 2
d338 1
a338 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d359 5
a363 2
	const MAGIC* const mg = SvMAGIC(av);
	if (val != &PL_sv_undef) {
d365 5
d371 1
a371 3
	if (PL_delaymagic && mg->mg_type == PERL_MAGIC_isa)
	    PL_delaymagic |= DM_ARRAY;
	else
d384 2
d423 5
a427 2
Clears an array, making it empty.  Does not free the memory used by the
array itself.
d437 1
d449 1
a449 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d455 1
a455 1
	    PL_delaymagic |= DM_ARRAY;
d463 1
a463 1
    if (AvREAL(av)) {
d466 2
d482 1
a482 1

d488 3
a490 1
Undefines the array.  Frees the memory used by the array itself.
d498 2
d507 1
a507 1
    if (AvREAL(av)) {
d509 2
d521 1
d548 3
a550 2
to accommodate the addition. Like C<av_store>, this takes ownership of one
reference count.
d565 1
a565 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d568 2
a569 11
	dSP;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,2);
	PUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
	PUSHs(val);
	PUTBACK;
	ENTER;
	call_method("PUSH", G_SCALAR|G_DISCARD);
	LEAVE;
	POPSTACK;
d581 2
d597 1
a597 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d599 3
a601 13
	dSP;    
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
	PUTBACK;
	ENTER;
	if (call_method("POP", G_SCALAR)) {
	    retval = newSVsv(*PL_stack_sp--);    
	} else {    
	    retval = &PL_sv_undef;
	}
	LEAVE;
	POPSTACK;
d642 2
d658 1
a658 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d661 2
a662 13
	dSP;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,1+num);
	PUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
	while (num-- > 0) {
	    PUSHs(&PL_sv_undef);
	}
	PUTBACK;
	ENTER;
	call_method("UNSHIFT", G_SCALAR|G_DISCARD);
	LEAVE;
	POPSTACK;
d703 2
a704 1
Shifts an SV off the beginning of the array. Returns C<&PL_sv_undef> if the 
d707 2
d723 1
a723 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d725 3
a727 13
	dSP;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
	PUTBACK;
	ENTER;
	if (call_method("SHIFT", G_SCALAR)) {
	    retval = newSVsv(*PL_stack_sp--);            
	} else {    
	    retval = &PL_sv_undef;
	}     
	LEAVE;
	POPSTACK;
d749 2
d770 1
a770 1
av_fill() returns.  If the array was previously shorter then the
d789 4
a792 13
	dSP;            
	ENTER;
	SAVETMPS;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,2);
	PUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
	mPUSHi(fill + 1);
	PUTBACK;
	call_method("STORESIZE", G_SCALAR|G_DISCARD);
	POPSTACK;
	FREETMPS;
	LEAVE;
d821 5
a825 3
Deletes the element indexed by C<key> from the array.  Returns the
deleted element. If C<flags> equals C<G_DISCARD>, the element is freed
and null is returned.
d839 1
a839 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d917 2
d931 3
a933 1
        if (tied_magic || mg_find((const SV *)av, PERL_MAGIC_regdata)) {
d952 2
d957 7
d968 1
a968 1
                return (bool)SvTRUE(sv);
@


1.12
log
@Merge in perl 5.10.1
@
text
@d38 2
a39 2
    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied) && ckWARN_d(WARN_DEBUGGING))
	Perl_warner(aTHX_ packWARN(WARN_DEBUGGING), "av_reify called on tied array");
d407 5
d413 2
a414 1
	    sv_setsv(ary[i], *strp);
d440 2
a441 2
    if (SvREFCNT(av) == 0 && ckWARN_d(WARN_DEBUGGING)) {
	Perl_warner(aTHX_ packWARN(WARN_DEBUGGING), "Attempt to clear deleted array");
d592 1
a592 1
    if ((mg = SvTIED_mg((const SV*)av, PERL_MAGIC_tied))) {
d734 1
a734 1
    if ((mg = SvTIED_mg((const SV*)av, PERL_MAGIC_tied))) {
d773 1
a773 1
Perl_av_len(pTHX_ register const AV *av)
d1001 2
a1002 2
SV **
Perl_av_arylen_p(pTHX_ AV *av) {
d1006 1
a1006 1
    PERL_ARGS_ASSERT_AV_ARYLEN_P;
d1018 10
d1029 20
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d12 4
a15 2
 * "...for the Entwives desired order, and plenty, and peace (by which they
 * meant that things should remain where they had set them)." --Treebeard
d32 2
a33 1
    assert(av);
d38 1
a38 1
    if (SvTIED_mg((SV*)av, PERL_MAGIC_tied) && ckWARN_d(WARN_DEBUGGING))
d72 2
a73 1
    assert(av);
d75 1
a75 1
    mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied);
d83 2
a84 2
	PUSHs(SvTIED_obj((SV*)av, mg));
	PUSHs(sv_2mortal(newSViv(key+1)));
d124 16
a139 2
#ifdef MYMALLOC
		newmax = malloced_size((void*)AvALLOC(av))/sizeof(SV*) - 1;
d150 1
a150 1
		bytes = (newmax + 1) * sizeof(SV*);
d156 1
a156 1
		itmp /= sizeof(SV*);
d163 2
a164 1
		    offer_nice_chunk(AvALLOC(av), (AvMAX(av)+1) * sizeof(SV*));
d169 1
a169 1
#ifdef MYMALLOC
d217 2
a218 1
    assert(av);
d221 3
a223 2
        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
        if (tied_magic || mg_find((SV*)av, PERL_MAGIC_regdata)) {
d230 2
a231 1
			hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, tied_magic))),
d247 1
a247 1
	    mg_copy((SV*)av, sv, 0, key);
d303 2
a304 1
    assert(av);
d314 1
a314 1
        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
d320 1
a320 1
                    hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, 
d333 1
a333 1
		mg_copy((SV*)av, val, 0, key);
d347 1
a347 1
	Perl_croak(aTHX_ PL_no_modify);
d370 1
a370 1
	    sv_magic(val, (SV*)av, toLOWER(mg->mg_type), 0, key);
d375 1
a375 1
	   mg_set((SV*)av);
a380 19
=for apidoc newAV

Creates a new AV.  The reference count is set to 1.

=cut
*/

AV *
Perl_newAV(pTHX)
{
    register AV * const av = (AV*)newSV_type(SVt_PVAV);
    /* sv_upgrade does AvREAL_only()  */
    AvALLOC(av) = 0;
    AvARRAY(av) = NULL;
    AvMAX(av) = AvFILLp(av) = -1;
    return av;
}

/*
d393 1
a393 1
    register AV * const av = (AV*)newSV_type(SVt_PVAV);
d395 3
d430 3
a432 1
    assert(av);
d440 1
a440 1
	Perl_croak(aTHX_ PL_no_modify);
d445 1
a445 1
	if (PL_delaymagic && mg->mg_type == PERL_MAGIC_isa)
d448 1
a448 1
	    mg_clear((SV*)av); 
d485 2
a486 1
    assert(av);
d489 1
a489 1
    if (SvTIED_mg((SV*)av, PERL_MAGIC_tied)) 
d503 1
a503 1
    if(SvRMAGICAL(av)) mg_clear((SV*)av);
d519 2
d530 2
a531 1
to accommodate the addition.
d541 3
a543 1
    assert(av);
d546 1
a546 1
	Perl_croak(aTHX_ PL_no_modify);
d548 1
a548 1
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
d553 1
a553 1
	PUSHs(SvTIED_obj((SV*)av, mg));
d581 2
a582 1
    assert(av);
d585 2
a586 2
	Perl_croak(aTHX_ PL_no_modify);
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
d590 1
a590 1
	XPUSHs(SvTIED_obj((SV*)av, mg));
d607 1
a607 1
	mg_set((SV*)av);
d625 2
d650 2
a651 1
    assert(av);
d654 1
a654 1
	Perl_croak(aTHX_ PL_no_modify);
d656 1
a656 1
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
d661 1
a661 1
	PUSHs(SvTIED_obj((SV*)av, mg));
d710 2
a711 1
Shifts an SV off the beginning of the array.
d723 2
a724 1
    assert(av);
d727 2
a728 2
	Perl_croak(aTHX_ PL_no_modify);
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
d732 1
a732 1
	XPUSHs(SvTIED_obj((SV*)av, mg));
d753 1
a753 1
	mg_set((SV*)av);
d769 3
a771 1
    assert(av);
d795 2
a796 1
    assert(av);
d800 1
a800 1
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
d807 2
a808 2
	PUSHs(SvTIED_obj((SV*)av, mg));
	PUSHs(sv_2mortal(newSViv(fill+1)));
d833 1
a833 1
	    mg_set((SV*)av);
d854 2
a855 1
    assert(av);
d858 1
a858 1
	Perl_croak(aTHX_ PL_no_modify);
d861 3
a863 2
        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
        if ((tied_magic || mg_find((SV*)av, PERL_MAGIC_regdata))) {
d870 1
a870 1
                        hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, 
d917 1
a917 1
	    mg_set((SV*)av);
d942 2
a943 1
    assert(av);
d946 3
a948 2
        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
        if (tied_magic || mg_find((SV*)av, PERL_MAGIC_regdata)) {
d956 1
a956 1
                        hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, 
d970 1
a970 1
            mg_copy((SV*)av, sv, 0, key);
d1000 2
a1001 1
    assert(av);
d1003 1
a1003 1
    mg = mg_find((SV*)av, PERL_MAGIC_arylen_p);
d1006 2
a1007 2
	mg = sv_magicext((SV*)av, 0, PERL_MAGIC_arylen_p, &PL_vtbl_arylen_p,
			 0, 0);
@


1.10
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d27 1
d30 2
d45 1
a45 1
	    (void)SvREFCNT_inc(sv);
d66 6
a71 1
    MAGIC * const mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied);
d98 1
a98 1
	    SvPV_set(av, (char*)AvALLOC(av));
d174 1
a174 1
	    SvPV_set(av, (char*)AvALLOC(av));
d196 1
a196 1
    SV *sv;
d198 1
a198 2
    if (!av)
	return 0;
d203 8
a210 1
            U32 adjust_index = 1;
d212 3
a214 6
            if (tied_magic && key < 0) {
                /* Handle negative array indices 20020222 MJD */
		SV * const * const negative_indices_glob =
                    hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, 
                                                     tied_magic))), 
                             NEGATIVE_INDICES_VAR, 16, 0);
d216 6
a221 10
                if (negative_indices_glob
                    && SvTRUE(GvSV(*negative_indices_glob)))
                    adjust_index = 0;
            }

            if (key < 0 && adjust_index) {
                key += AvFILL(av) + 1;
                if (key < 0)
                    return 0;
            }
d235 1
a235 1
	    return 0;
d240 2
a241 3
	    return 0;
	sv = NEWSV(5,0);
	return av_store(av,key,sv);
d245 3
a247 5
	if (lval) {
	    sv = NEWSV(6,0);
	    return av_store(av,key,sv);
	}
	return 0;
d251 1
a251 1
		 || SvTYPE(AvARRAY(av)[key]) == SVTYPEMASK)) {
d278 1
d281 6
a286 2
    if (!av)
	return 0;
d295 1
a295 1
                unsigned adjust_index = 1;
d312 1
a312 1
	    return 0;
d320 1
a320 1
	    return 0;
d335 1
a335 1
	    do
d337 1
a337 1
	    while (AvFILLp(av) < key);
d345 1
a346 1
	    MAGIC* mg = SvMAGIC(av);
d349 4
a352 1
	mg_set((SV*)av);
d368 1
a368 3
    register AV * const av = (AV*)NEWSV(3,0);

    sv_upgrade((SV *)av, SVt_PVAV);
d371 1
a371 1
    SvPV_set(av, (char*)0);
d389 1
a389 3
    register AV * const av = (AV*)NEWSV(8,0);

    sv_upgrade((SV *) av,SVt_PVAV);
d396 2
a397 3
	SvPV_set(av, (char*)ary);
	AvFILLp(av) = size - 1;
	AvMAX(av) = size - 1;
d400 1
a400 1
	    ary[i] = NEWSV(7,0);
a407 22
AV *
Perl_av_fake(pTHX_ register I32 size, register SV **strp)
{
    register SV** ary;
    register AV * const av = (AV*)NEWSV(9,0);

    sv_upgrade((SV *)av, SVt_PVAV);
    Newx(ary,size+1,SV*);
    AvALLOC(av) = ary;
    Copy(strp,ary,size,SV*);
    AvFLAGS(av) = AVf_REIFY;
    SvPV_set(av, (char*)ary);
    AvFILLp(av) = size - 1;
    AvMAX(av) = size - 1;
    while (size--) {
	assert (*strp);
	SvTEMP_off(*strp);
	strp++;
    }
    return av;
}

d420 2
a421 1
    register I32 key;
d423 1
a428 2
    if (!av)
	return;
d434 7
a440 2
    if (SvRMAGICAL(av))
	mg_clear((SV*)av); 
d447 3
a449 3
	key = AvFILLp(av) + 1;
	while (key) {
	    SV * const sv = ary[--key];
d451 2
a452 2
	     * destructor might try to modify this arrray */
	    ary[key] = &PL_sv_undef;
d456 4
a459 3
    if ((key = AvARRAY(av) - AvALLOC(av))) {
	AvMAX(av) += key;
	SvPV_set(av, (char*)AvALLOC(av));
d476 1
a476 2
    if (!av)
	return;
d480 1
a480 1
	av_fill(av, -1);   /* mg_clear() ? */
d487 1
d489 2
a490 2
    AvALLOC(av) = 0;
    SvPV_set(av, (char*)0);
a491 16
    /* Need to check SvMAGICAL, as during global destruction it may be that
       AvARYLEN(av) has been freed before av, and hence the SvANY() pointer
       is now part of the linked list of SV heads, rather than pointing to
       the original body.  */
    /* FIXME - audit the code for other bugs like this one.  */
    if (AvARYLEN(av) && SvMAGICAL(AvARYLEN(av))) {
	MAGIC *mg = mg_find (AvARYLEN(av), PERL_MAGIC_arylen);

	if (mg) {
	    /* arylen scalar holds a pointer back to the array, but doesn't
	       own a reference. Hence the we (the array) are about to go away
	       with it still pointing at us. Clear its pointer, else it would
	       be pointing at free memory. See the comment in sv_magic about
	       reference loops, and why it can't own a reference to us.  */
	    mg->mg_obj = 0;
	}
d493 19
a511 3
	SvREFCNT_dec(AvARYLEN(av));
	AvARYLEN(av) = 0;
    }
d526 1
d528 2
a529 2
    if (!av)
	return;
d562 1
d566 2
a567 2
    if (!av)
      return &PL_sv_undef;
d596 20
d628 1
d632 2
a633 2
    if (!av)
	return;
d666 1
a666 1
	SvPV_set(av, (char*)(AvARRAY(av) - i));
d670 1
a670 2
	I32 slide;
	i = AvFILLp(av);
d672 1
a672 1
	slide = i > 0 ? i : 0;
d684 1
a684 1
	SvPV_set(av, (char*)(AvARRAY(av) + slide));
d699 1
d703 2
a704 2
    if (!av)
	return &PL_sv_undef;
d728 1
a728 1
    SvPV_set(av, (char*)(AvARRAY(av) + 1));
d739 2
a740 2
Returns the highest index in the array.  Returns -1 if the array is
empty.
d746 1
a746 1
Perl_av_len(pTHX_ register AV *av)
d748 1
d755 1
a755 1
Ensure than an array has a given number of elements, equivalent to
d758 6
d769 1
d771 3
a773 2
    if (!av)
	Perl_croak(aTHX_ "panic: null array");
d794 1
a794 1
	SV** ary = AvARRAY(av);
d827 1
d830 2
a831 2
    if (!av)
	return Nullsv;
d854 1
a854 1
                        return Nullsv;
d865 1
a865 1
                return Nullsv;     
d873 1
a873 1
	    return Nullsv;
d877 1
a877 1
	return Nullsv;
d895 1
a895 1
	sv = Nullsv;
d915 2
a916 3
    if (!av)
	return FALSE;

d921 1
a921 1
            SV *sv = sv_newmortal();
d967 4
a970 4
/* AVHV: Support for treating arrays as if they were hashes.  The
 * first element of the array should be a hash reference that maps
 * hash keys to array indices.
 */
d972 1
a972 8
STATIC I32
S_avhv_index_sv(pTHX_ SV* sv)
{
    I32 index = SvIV(sv);
    if (index < 1)
	Perl_croak(aTHX_ "Bad index while coercing array into hash");
    return index;    
}
d974 1
a974 13
STATIC I32
S_avhv_index(pTHX_ AV *av, SV *keysv, U32 hash)
{
    HV *keys;
    HE *he;
    STRLEN n_a;

    keys = avhv_keys(av);
    he = hv_fetch_ent(keys, keysv, FALSE, hash);
    if (!he)
        Perl_croak(aTHX_ "No such pseudo-hash field \"%s\"", SvPV(keysv,n_a));
    return avhv_index_sv(HeVAL(he));
}
d976 6
a981 16
HV*
Perl_avhv_keys(pTHX_ AV *av)
{
    SV **keysp = av_fetch(av, 0, FALSE);
    if (keysp) {
	SV *sv = *keysp;
	if (SvGMAGICAL(sv))
	    mg_get(sv);
	if (SvROK(sv)) {
            if (ckWARN(WARN_DEPRECATED) && !sv_isa(sv, "pseudohash"))
	        Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
			    "Pseudo-hashes are deprecated");
	    sv = SvRV(sv);
	    if (SvTYPE(sv) == SVt_PVHV)
		return (HV*)sv;
	}
d983 1
a983 57
    Perl_croak(aTHX_ "Can't coerce array into hash");
    return Nullhv;
}

SV**
Perl_avhv_store_ent(pTHX_ AV *av, SV *keysv, SV *val, U32 hash)
{
    return av_store(av, avhv_index(av, keysv, hash), val);
}

SV**
Perl_avhv_fetch_ent(pTHX_ AV *av, SV *keysv, I32 lval, U32 hash)
{
    return av_fetch(av, avhv_index(av, keysv, hash), lval);
}

SV *
Perl_avhv_delete_ent(pTHX_ AV *av, SV *keysv, I32 flags, U32 hash)
{
    HV *keys = avhv_keys(av);
    HE *he;
	
    he = hv_fetch_ent(keys, keysv, FALSE, hash);
    if (!he || !SvOK(HeVAL(he)))
	return Nullsv;

    return av_delete(av, avhv_index_sv(HeVAL(he)), flags);
}

/* Check for the existence of an element named by a given key.
 *
 */
bool
Perl_avhv_exists_ent(pTHX_ AV *av, SV *keysv, U32 hash)
{
    HV *keys = avhv_keys(av);
    HE *he;
	
    he = hv_fetch_ent(keys, keysv, FALSE, hash);
    if (!he || !SvOK(HeVAL(he)))
	return FALSE;

    return av_exists(av, avhv_index_sv(HeVAL(he)));
}

HE *
Perl_avhv_iternext(pTHX_ AV *av)
{
    HV *keys = avhv_keys(av);
    return hv_iternext(keys);
}

SV *
Perl_avhv_iterval(pTHX_ AV *av, register HE *entry)
{
    SV *sv = hv_iterval(avhv_keys(av), entry);
    return *av_fetch(av, avhv_index_sv(sv), TRUE);
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
a27 1
    SV* sv;
d39 1
a39 1
	sv = AvARRAY(av)[--key];
d63 2
a64 2
    MAGIC *mg;
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
d90 1
a90 1
	    SvPVX(av) = (char*)AvALLOC(av);
a94 1
	    
d134 1
a134 1
		New(2,ary, newmax+1, SV*);
d156 1
a156 1
		New(2,AvALLOC(av), newmax+1, SV*);
d166 1
a166 1
	    SvPVX(av) = (char*)AvALLOC(av);
d194 1
a194 1
        MAGIC *tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
d200 1
a200 1
                SV **negative_indices_glob = 
d282 1
a282 1
        MAGIC *tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
d287 1
a287 1
                SV **negative_indices_glob = 
d356 1
a356 1
    register AV *av;
a357 1
    av = (AV*)NEWSV(3,0);
d359 1
a359 1
    AvREAL_on(av);
d361 1
a361 1
    SvPVX(av) = 0;
d379 1
a379 3
    register AV *av;
    register I32 i;
    register SV** ary;
a380 1
    av = (AV*)NEWSV(8,0);
d382 5
a386 3
    AvFLAGS(av) = AVf_REAL;
    if (size) {		/* `defined' was returning undef for size==0 anyway. */
	New(4,ary,size,SV*);
d388 1
a388 1
	SvPVX(av) = (char*)ary;
a403 1
    register AV *av;
d405 1
a406 1
    av = (AV*)NEWSV(9,0);
d408 1
a408 1
    New(4,ary,size+1,SV*);
d412 1
a412 1
    SvPVX(av) = (char*)ary;
a435 1
    SV** ary;
a443 1
    /*SUPPRESS 560*/
d456 1
a456 1
	ary = AvARRAY(av);
d459 1
a459 1
	    SV * sv = ary[--key];
d468 1
a468 1
	SvPVX(av) = (char*)AvALLOC(av);
a484 2
    register I32 key;

a486 1
    /*SUPPRESS 560*/
d493 1
a493 1
	key = AvFILLp(av) + 1;
d499 1
a499 1
    SvPVX(av) = 0;
d501 17
a517 1
    if (AvARYLEN(av)) {
a615 1
    register SV **ary;
a616 1
    I32 slide;
d652 1
a652 1
	SvPVX(av) = (char*)(AvARRAY(av) - i);
d655 2
d671 1
a671 1
	SvPVX(av) = (char*)(AvARRAY(av) + slide);
d714 1
a714 1
    SvPVX(av) = (char*)(AvARRAY(av) + 1);
d812 1
a812 2
        MAGIC *tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
        SV **svp;
d815 1
d819 1
a819 1
                    SV **negative_indices_glob = 
d896 1
a896 1
        MAGIC *tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
d904 1
a904 1
                    SV **negative_indices_glob = 
d1047 10
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d867 2
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d103 5
d122 1
d157 1
d790 2
a791 1
deleted element. C<flags> is currently ignored.
d849 2
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d109 1
a109 1
#if defined(MYMALLOC) && !defined(LEAKTEST)
d138 1
a138 1
#if defined(MYMALLOC) && !defined(LEAKTEST)
d188 32
a225 11
    if (SvRMAGICAL(av)) {
	if (mg_find((SV*)av, PERL_MAGIC_tied) ||
		mg_find((SV*)av, PERL_MAGIC_regdata))
	{
	    sv = sv_newmortal();
	    mg_copy((SV*)av, sv, 0, key);
	    PL_av_fetch_sv = sv;
	    return &PL_av_fetch_sv;
	}
    }

d276 27
a311 9
    if (SvRMAGICAL(av)) {
	if (mg_find((SV*)av, PERL_MAGIC_tied)) {
	    if (val != &PL_sv_undef) {
		mg_copy((SV*)av, val, 0, key);
	    }
	    return 0;
	}
    }

d459 3
a461 1
	    SvREFCNT_dec(ary[--key]);
d463 1
d796 36
d837 1
a837 15
    if (SvRMAGICAL(av)) {
	SV **svp;
	if ((mg_find((SV*)av, PERL_MAGIC_tied) ||
		mg_find((SV*)av, PERL_MAGIC_regdata))
	    && (svp = av_fetch(av, key, TRUE)))
	{
	    sv = *svp;
	    mg_clear(sv);
	    if (mg_find(sv, PERL_MAGIC_tiedelem)) {
		sv_unmagic(sv, PERL_MAGIC_tiedelem);	/* No longer an element */
		return sv;
	    }
	    return Nullsv;			/* element cannot be deleted */
	}
    }
d875 36
a915 6
    if (SvRMAGICAL(av)) {
	if (mg_find((SV*)av, PERL_MAGIC_tied) ||
		mg_find((SV*)av, PERL_MAGIC_regdata))
	{
	    SV *sv = sv_newmortal();
	    MAGIC *mg;
a916 8
	    mg_copy((SV*)av, sv, 0, key);
	    mg = mg_find(sv, PERL_MAGIC_tiedelem);
	    if (mg) {
		magic_existspack(sv, mg);
		return (bool)SvTRUE(sv);
	    }
	}
    }
d963 3
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d15 4
d32 2
a33 2
    if (SvTIED_mg((SV*)av, 'P') && ckWARN_d(WARN_DEBUGGING))
	Perl_warner(aTHX_ WARN_DEBUGGING, "av_reify called on tied array");
d64 1
a64 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d103 1
a103 1
#ifndef STRANGE_MALLOC
d122 1
a122 1
		while (itmp - MALLOC_OVERHEAD < bytes)
d137 1
d139 1
d194 3
a196 1
	if (mg_find((SV*)av,'P') || mg_find((SV*)av,'D')) {
d264 1
a264 1
	if (mg_find((SV*)av,'P')) {
d398 1
a398 1
	Perl_warner(aTHX_ WARN_DEBUGGING, "Attempt to clear deleted array");
d449 1
a449 1
    if (SvTIED_mg((SV*)av, 'P')) 
d485 1
a485 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d517 2
a518 2
    if (!av || AvFILL(av) < 0)
	return &PL_sv_undef;
d521 1
a521 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d537 2
d564 1
a564 1
    if (!av || num <= 0)
d569 1
a569 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d586 2
d633 1
a633 1
    if (!av || AvFILL(av) < 0)
d637 1
a637 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d653 2
d697 1
a697 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d760 2
a761 1
	if ((mg_find((SV*)av,'P') || mg_find((SV*)av,'D'))
d766 2
a767 2
	    if (mg_find(sv, 'p')) {
		sv_unmagic(sv, 'p');		/* No longer an element */
d778 1
d816 3
a818 1
	if (mg_find((SV*)av,'P') || mg_find((SV*)av,'D')) {
d823 1
a823 1
	    mg = mg_find(sv, 'p');
d826 1
a826 1
		return SvTRUE(sv);
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d37 1
a37 2
	if (sv != &PL_sv_undef) {
	    dTHR;
a38 1
	}
a58 1
    dTHR;			/* only necessary if we have to extend stack */
a188 1
	    dTHR;
a270 1
	    dTHR;
d552 1
d590 3
d600 4
d667 8
d722 8
d780 6
a785 3
 * This relies on the fact that uninitialized array elements
 * are set to &PL_sv_undef.
 */
d787 2
d802 2
d805 5
a809 2
	    magic_existspack(sv, mg_find(sv, 'p'));
	    return SvTRUE(sv);
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d16 1
d20 1
a20 1
av_reify(AV *av)
d28 2
a29 2
    if (SvTIED_mg((SV*)av, 'P'))
	warn("av_reify called on tied array");
d49 9
d59 1
a59 1
av_extend(AV *av, I32 key)
d63 1
a63 1
    if (mg = SvTIED_mg((SV*)av, 'P')) {
d73 1
a73 1
	perl_call_method("EXTEND", G_SCALAR|G_DISCARD);
d103 2
a104 1
		U32 bytes;
d107 1
a107 1
#if defined(MYMALLOC) && !defined(PURIFY) && !defined(LEAKTEST)
d120 8
a127 7
		tmp = MALLOC_OVERHEAD;
		while (tmp - MALLOC_OVERHEAD < bytes)
		    tmp += tmp;
		tmp -= MALLOC_OVERHEAD;
		tmp /= sizeof(SV*);
		assert(tmp > newmax);
		newmax = tmp - 1;
d163 13
d177 1
a177 1
av_fetch(register AV *av, I32 key, I32 lval)
d191 1
a191 1
	if (mg_find((SV*)av,'P')) {
d223 17
d241 1
a241 1
av_store(register AV *av, I32 key, SV *val)
a243 2
    U32  fill;

d257 1
a257 1
	croak(no_modify);
d297 8
d306 1
a306 1
newAV(void)
d319 10
d330 1
a330 1
av_make(register I32 size, register SV **strp)
d356 1
a356 1
av_fake(register I32 size, register SV **strp)
d378 9
d388 1
a388 1
av_clear(register AV *av)
d394 2
a395 2
    if (SvREFCNT(av) <= 0) {
	warn("Attempt to clear deleted array");
d403 1
a403 1
	croak(no_modify);
d420 1
a420 1
    if (key = AvARRAY(av) - AvALLOC(av)) {
d428 8
d437 1
a437 1
av_undef(register AV *av)
d464 9
d474 1
a474 1
av_push(register AV *av, SV *val)
d480 1
a480 1
	croak(no_modify);
d482 1
a482 1
    if (mg = SvTIED_mg((SV*)av, 'P')) {
d491 1
a491 1
	perl_call_method("PUSH", G_SCALAR|G_DISCARD);
d499 9
d509 1
a509 1
av_pop(register AV *av)
d517 2
a518 2
	croak(no_modify);
    if (mg = SvTIED_mg((SV*)av, 'P')) {
d525 1
a525 1
	if (perl_call_method("POP", G_SCALAR)) {
d541 10
d552 1
a552 1
av_unshift(register AV *av, register I32 num)
d561 1
a561 1
	croak(no_modify);
d563 1
a563 1
    if (mg = SvTIED_mg((SV*)av, 'P')) {
d574 1
a574 1
	perl_call_method("UNSHIFT", G_SCALAR|G_DISCARD);
d604 8
d613 1
a613 1
av_shift(register AV *av)
d621 2
a622 2
	croak(no_modify);
    if (mg = SvTIED_mg((SV*)av, 'P')) {
d629 1
a629 1
	if (perl_call_method("SHIFT", G_SCALAR)) {
d649 9
d659 1
a659 1
av_len(register AV *av)
d665 1
a665 1
av_fill(register AV *av, I32 fill)
d669 1
a669 1
	croak("panic: null array");
d672 1
a672 1
    if (mg = SvTIED_mg((SV*)av, 'P')) {
d682 1
a682 1
	perl_call_method("STORESIZE", G_SCALAR|G_DISCARD);
d711 80
d798 1
a798 1
avhv_index_sv(SV* sv)
d802 1
a802 1
	croak("Bad index while coercing array into hash");
d806 14
d821 1
a821 1
avhv_keys(AV *av)
d834 1
a834 1
    croak("Can't coerce array into hash");
d839 13
a851 1
avhv_fetch_ent(AV *av, SV *keysv, I32 lval, U32 hash)
a852 1
    SV **indsvp;
d855 1
a855 1
    
d857 4
a860 3
    if (!he)
        croak("No such array field");
    return av_fetch(av, avhv_index_sv(HeVAL(he)), lval);
d863 3
d867 1
a867 1
avhv_exists_ent(AV *av, SV *keysv, U32 hash)
d870 7
a876 1
    return hv_exists_ent(keys, keysv, hash);
d880 1
a880 1
avhv_iternext(AV *av)
d887 1
a887 1
avhv_iterval(AV *av, register HE *entry)
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d19 1
a19 2
av_reify(av)
AV* av;
d26 4
d31 2
a32 2
    while (key > AvFILL(av) + 1)
	AvARRAY(av)[--key] = &sv_undef;
d36 2
a37 1
	if (sv != &sv_undef)
d39 1
d43 2
a44 1
	AvALLOC(av)[--key] = &sv_undef;
d49 1
a49 3
av_extend(av,key)
AV *av;
I32 key;
d51 18
d75 1
a75 1
	    ary = AvALLOC(av) + AvFILL(av) + 1;
d77 1
a77 1
	    Move(AvARRAY(av), AvALLOC(av), AvFILL(av)+1, SV*);
d82 1
a82 1
		    ary[--tmp] = &sv_undef;
d96 6
d104 1
a104 1
#ifdef STRANGE_MALLOC
d118 2
a119 4
		if (AvMAX(av) > 64 && !nice_chunk) {
		    nice_chunk = (char*)AvALLOC(av);
		    nice_chunk_size = (AvMAX(av) + 1) * sizeof(SV*);
		}
d124 1
d127 4
a130 4
		if (av == curstack) {	/* Oops, grew stack (via av_store()?) */
		    stack_sp = AvALLOC(av) + (stack_sp - stack_base);
		    stack_base = AvALLOC(av);
		    stack_max = stack_base + newmax;
d134 1
a134 1
		newmax = key < 4 ? 4 : key;
d138 1
a138 1
		AvALLOC(av)[0] = &sv_undef;	/* For the stacks */
d142 1
a142 1
		    ary[--tmp] = &sv_undef;
d152 1
a152 4
av_fetch(av,key,lval)
register AV *av;
I32 key;
I32 lval;
d159 6
d167 1
d170 2
a171 2
	    Sv = sv;
	    return &Sv;
d175 1
a175 6
    if (key < 0) {
	key += AvFILL(av) + 1;
	if (key < 0)
	    return 0;
    }
    else if (key > AvFILL(av)) {
d178 1
a178 4
	if (AvREALISH(av))
	    sv = NEWSV(5,0);
	else
	    sv = sv_newmortal();
d181 1
a181 1
    if (AvARRAY(av)[key] == &sv_undef) {
d192 1
a192 1
	AvARRAY(av)[key] = &sv_undef;	/* 1/2 reify */
d199 1
a199 4
av_store(av,key,val)
register AV *av;
I32 key;
SV *val;
d202 2
d208 10
a217 1
	val = &sv_undef;
d221 1
a221 1
	    if (val != &sv_undef)
d223 1
a227 7
    if (key < 0) {
	key += AvFILL(av) + 1;
	if (key < 0)
	    return 0;
    }
    if (SvREADONLY(av) && key >= AvFILL(av))
	croak(no_modify);
d233 1
a233 1
    if (AvFILL(av) < key) {
d235 3
a237 2
	    if (av == curstack && key > stack_sp - stack_base)
		stack_sp = stack_base + key;	/* XPUSH in disguise */
d239 2
a240 2
		ary[++AvFILL(av)] = &sv_undef;
	    while (AvFILL(av) < key);
d242 1
a242 1
	AvFILL(av) = key;
d248 1
a248 1
	if (val != &sv_undef) {
d258 1
a258 1
newAV()
d267 1
a267 1
    AvMAX(av) = AvFILL(av) = -1;
d272 1
a272 3
av_make(size,strp)
register I32 size;
register SV **strp;
d285 1
a285 1
	AvFILL(av) = size - 1;
d298 1
a298 3
av_fake(size,strp)
register I32 size;
register SV **strp;
d310 1
a310 1
    AvFILL(av) = size - 1;
d321 1
a321 2
av_clear(av)
register AV *av;
d331 1
a331 1
    if (!av || AvMAX(av) < 0)
d335 10
d347 1
a347 1
	key = AvFILL(av) + 1;
d350 1
a350 1
	    ary[key] = &sv_undef;
d357 1
a357 1
    AvFILL(av) = -1;
a358 2
    if (SvRMAGICAL(av))
	mg_clear((SV*)av); 
d362 1
a362 2
av_undef(av)
register AV *av;
d369 5
d375 1
a375 1
	key = AvFILL(av) + 1;
d382 1
a382 1
    AvMAX(av) = AvFILL(av) = -1;
d390 3
a392 4
av_push(av,val)
register AV *av;
SV *val;
{
d395 18
a412 1
    av_store(av,AvFILL(av)+1,val);
d416 1
a416 2
av_pop(av)
register AV *av;
d419 1
d422 1
a422 1
	return &sv_undef;
d425 18
a442 2
    retval = AvARRAY(av)[AvFILL(av)];
    AvARRAY(av)[AvFILL(av)--] = &sv_undef;
d449 1
a449 3
av_unshift(av,num)
register AV *av;
register I32 num;
d452 2
a453 1
    register SV **sstr,**dstr;
d459 18
d486 1
a486 1
	AvFILL(av) += i;
d490 8
a497 15
	av_extend(av,AvFILL(av)+num);
	AvFILL(av) += num;
	dstr = AvARRAY(av) + AvFILL(av);
	sstr = dstr - num;
#ifdef BUGGY_MSC5
 # pragma loop_opt(off)	/* don't loop-optimize the following code */
#endif /* BUGGY_MSC5 */
	for (i = AvFILL(av) - num; i >= 0; --i) {
	    *dstr-- = *sstr--;
#ifdef BUGGY_MSC5
 # pragma loop_opt()	/* loop-optimization back to command-line setting */
#endif /* BUGGY_MSC5 */
	}
	while (num)
	    AvARRAY(av)[--num] = &sv_undef;
d502 1
a502 2
av_shift(av)
register AV *av;
d505 1
d508 1
a508 1
	return &sv_undef;
d511 16
d529 1
a529 1
	*AvARRAY(av) = &sv_undef;
d532 1
a532 1
    AvFILL(av)--;
d539 1
a539 2
av_len(av)
register AV *av;
d545 1
a545 3
av_fill(av, fill)
register AV *av;
I32 fill;
d547 1
d552 16
d569 1
a569 1
	I32 key = AvFILL(av);
d575 1
a575 1
		ary[key--] = &sv_undef;
d580 1
a580 1
		ary[++key] = &sv_undef;
d583 1
a583 1
	AvFILL(av) = fill;
d588 68
a655 1
	(void)av_store(av,fill,&sv_undef);
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d18 1
a18 3
static void	av_reify _((AV* av));

static void
d24 3
a26 1
    
d36 3
d100 1
a100 1
		if (av == stack) {	/* Oops, grew stack (via av_store()?) */
d159 1
d166 6
d185 2
d190 2
a191 1
	    mg_copy((SV*)av, val, 0, key);
d201 4
a204 3
    if (!val)
	val = &sv_undef;

a206 3
    if (AvREIFY(av))
	av_reify(av);

d210 1
a210 1
	    if (av == stack && key > stack_sp - stack_base)
a255 2
    New(4,ary,size+1,SV*);
    AvALLOC(av) = ary;
d257 12
a268 8
    SvPVX(av) = (char*)ary;
    AvFILL(av) = size - 1;
    AvMAX(av) = size - 1;
    for (i = 0; i < size; i++) {
	assert (*strp);
	ary[i] = NEWSV(7,0);
	sv_setsv(ary[i], *strp);
	strp++;
d305 5
d327 3
a345 4
    if (key = AvARRAY(av) - AvALLOC(av)) {
	AvMAX(av) += key;
	SvPVX(av) = (char*)AvALLOC(av);
    }
d374 2
d393 4
a396 6
    if (!AvREAL(av)) {
	if (AvREIFY(av))
	    av_reify(av);
	else
	    croak("Can't unshift");
    }
d434 2
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d18 5
a22 2
void
av_reify(AV *av)
d26 1
a26 7

    if (AvREAL(av))
	return;
#ifdef DEBUGGING
    if (SvTIED_mg((SV*)av, 'P'))
	warn("av_reify called on tied array");
#endif
d28 2
a29 2
    while (key > AvFILLp(av) + 1)
	AvARRAY(av)[--key] = &PL_sv_undef;
d33 1
a33 2
	if (sv != &PL_sv_undef) {
	    dTHR;
a34 1
	}
a35 4
    key = AvARRAY(av) - AvALLOC(av);
    while (key)
	AvALLOC(av)[--key] = &PL_sv_undef;
    AvREIFY_off(av);
d40 3
a42 1
av_extend(AV *av, I32 key)
a43 18
    dTHR;			/* only necessary if we have to extend stack */
    MAGIC *mg;
    if (mg = SvTIED_mg((SV*)av, 'P')) {
	dSP;
	ENTER;
	SAVETMPS;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,2);
	PUSHs(SvTIED_obj((SV*)av, mg));
	PUSHs(sv_2mortal(newSViv(key+1)));
        PUTBACK;
	perl_call_method("EXTEND", G_SCALAR|G_DISCARD);
	POPSTACK;
	FREETMPS;
	LEAVE;
	return;
    }
d50 1
a50 1
	    ary = AvALLOC(av) + AvFILLp(av) + 1;
d52 1
a52 1
	    Move(AvARRAY(av), AvALLOC(av), AvFILLp(av)+1, SV*);
d57 1
a57 1
		    ary[--tmp] = &PL_sv_undef;
a70 6
#if defined(MYMALLOC) && !defined(PURIFY) && !defined(LEAKTEST)
		newmax = malloced_size((void*)AvALLOC(av))/sizeof(SV*) - 1;

		if (key <= newmax) 
		    goto resized;
#endif 
d73 1
a73 1
#if defined(STRANGE_MALLOC) || defined(MYMALLOC)
d87 4
a90 2
		if (AvMAX(av) > 64)
		    offer_nice_chunk(AvALLOC(av), (AvMAX(av)+1) * sizeof(SV*));
a94 1
	      resized:
d97 4
a100 4
		if (av == PL_curstack) {	/* Oops, grew stack (via av_store()?) */
		    PL_stack_sp = AvALLOC(av) + (PL_stack_sp - PL_stack_base);
		    PL_stack_base = AvALLOC(av);
		    PL_stack_max = PL_stack_base + newmax;
d104 1
a104 1
		newmax = key < 3 ? 3 : key;
d108 1
a108 1
		AvALLOC(av)[0] = &PL_sv_undef;	/* For the stacks */
d112 1
a112 1
		    ary[--tmp] = &PL_sv_undef;
d122 4
a125 1
av_fetch(register AV *av, I32 key, I32 lval)
a131 6
    if (key < 0) {
	key += AvFILL(av) + 1;
	if (key < 0)
	    return 0;
    }

a133 1
	    dTHR;
d136 2
a137 2
	    PL_av_fetch_sv = sv;
	    return &PL_av_fetch_sv;
d141 6
a146 1
    if (key > AvFILLp(av)) {
d149 4
a152 1
	sv = NEWSV(5,0);
d155 1
a155 2
    if (AvARRAY(av)[key] == &PL_sv_undef) {
    emptyness:
a161 6
    else if (AvREIFY(av)
	     && (!AvARRAY(av)[key]	/* eg. @@_ could have freed elts */
		 || SvTYPE(AvARRAY(av)[key]) == SVTYPEMASK)) {
	AvARRAY(av)[key] = &PL_sv_undef;	/* 1/2 reify */
	goto emptyness;
    }
d166 4
a169 1
av_store(register AV *av, I32 key, SV *val)
a171 2
    U32  fill;

d175 7
a181 2
    if (!val)
	val = &PL_sv_undef;
d188 2
a190 14
    if (SvREADONLY(av) && key >= AvFILL(av))
	croak(no_modify);

    if (SvRMAGICAL(av)) {
	if (mg_find((SV*)av,'P')) {
	    if (val != &PL_sv_undef) {
		mg_copy((SV*)av, val, 0, key);
	    }
	    return 0;
	}
    }

    if (!AvREAL(av) && AvREIFY(av))
	av_reify(av);
d193 3
d197 1
a197 1
    if (AvFILLp(av) < key) {
d199 2
a200 3
	    dTHR;
	    if (av == PL_curstack && key > PL_stack_sp - PL_stack_base)
		PL_stack_sp = PL_stack_base + key;	/* XPUSH in disguise */
d202 2
a203 2
		ary[++AvFILLp(av)] = &PL_sv_undef;
	    while (AvFILLp(av) < key);
d205 1
a205 1
	AvFILLp(av) = key;
d211 1
a211 1
	if (val != &PL_sv_undef) {
d221 1
a221 1
newAV(void)
d230 1
a230 1
    AvMAX(av) = AvFILLp(av) = -1;
d235 3
a237 1
av_make(register I32 size, register SV **strp)
d245 2
d248 8
a255 12
    if (size) {		/* `defined' was returning undef for size==0 anyway. */
	New(4,ary,size,SV*);
	AvALLOC(av) = ary;
	SvPVX(av) = (char*)ary;
	AvFILLp(av) = size - 1;
	AvMAX(av) = size - 1;
	for (i = 0; i < size; i++) {
	    assert (*strp);
	    ary[i] = NEWSV(7,0);
	    sv_setsv(ary[i], *strp);
	    strp++;
	}
d261 3
a263 1
av_fake(register I32 size, register SV **strp)
d275 1
a275 1
    AvFILLp(av) = size - 1;
d286 2
a287 1
av_clear(register AV *av)
d292 1
a292 6
#ifdef DEBUGGING
    if (SvREFCNT(av) <= 0) {
	warn("Attempt to clear deleted array");
    }
#endif
    if (!av)
a295 10
    if (SvREADONLY(av))
	croak(no_modify);

    /* Give any tie a chance to cleanup first */
    if (SvRMAGICAL(av))
	mg_clear((SV*)av); 

    if (AvMAX(av) < 0)
	return;

d298 1
a298 1
	key = AvFILLp(av) + 1;
d301 1
a301 1
	    ary[key] = &PL_sv_undef;
d308 1
a308 2
    AvFILLp(av) = -1;

d312 2
a313 1
av_undef(register AV *av)
a319 5

    /* Give any tie a chance to cleanup first */
    if (SvTIED_mg((SV*)av, 'P')) 
	av_fill(av, -1);   /* mg_clear() ? */

d321 1
a321 1
	key = AvFILLp(av) + 1;
d325 4
d332 1
a332 1
    AvMAX(av) = AvFILLp(av) = -1;
d340 4
a343 3
av_push(register AV *av, SV *val)
{             
    MAGIC *mg;
d346 1
a346 18
    if (SvREADONLY(av))
	croak(no_modify);

    if (mg = SvTIED_mg((SV*)av, 'P')) {
	dSP;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,2);
	PUSHs(SvTIED_obj((SV*)av, mg));
	PUSHs(val);
	PUTBACK;
	ENTER;
	perl_call_method("PUSH", G_SCALAR|G_DISCARD);
	LEAVE;
	POPSTACK;
	return;
    }
    av_store(av,AvFILLp(av)+1,val);
d350 2
a351 1
av_pop(register AV *av)
a353 1
    MAGIC* mg;
d356 3
a358 21
	return &PL_sv_undef;
    if (SvREADONLY(av))
	croak(no_modify);
    if (mg = SvTIED_mg((SV*)av, 'P')) {
	dSP;    
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)av, mg));
	PUTBACK;
	ENTER;
	if (perl_call_method("POP", G_SCALAR)) {
	    retval = newSVsv(*PL_stack_sp--);    
	} else {    
	    retval = &PL_sv_undef;
	}
	LEAVE;
	POPSTACK;
	return retval;
    }
    retval = AvARRAY(av)[AvFILLp(av)];
    AvARRAY(av)[AvFILLp(av)--] = &PL_sv_undef;
d365 3
a367 1
av_unshift(register AV *av, register I32 num)
d370 1
a370 2
    register SV **ary;
    MAGIC* mg;
d374 5
a378 18
    if (SvREADONLY(av))
	croak(no_modify);

    if (mg = SvTIED_mg((SV*)av, 'P')) {
	dSP;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,1+num);
	PUSHs(SvTIED_obj((SV*)av, mg));
	while (num-- > 0) {
	    PUSHs(&PL_sv_undef);
	}
	PUTBACK;
	ENTER;
	perl_call_method("UNSHIFT", G_SCALAR|G_DISCARD);
	LEAVE;
	POPSTACK;
	return;
a379 3

    if (!AvREAL(av) && AvREIFY(av))
	av_reify(av);
d387 1
a387 1
	AvFILLp(av) += i;
d391 15
a405 8
	i = AvFILLp(av);
	av_extend(av, i + num);
	AvFILLp(av) += num;
	ary = AvARRAY(av);
	Move(ary, ary + num, i + 1, SV*);
	do {
	    ary[--num] = &PL_sv_undef;
	} while (num);
d410 2
a411 1
av_shift(register AV *av)
a413 1
    MAGIC* mg;
d416 1
a416 19
	return &PL_sv_undef;
    if (SvREADONLY(av))
	croak(no_modify);
    if (mg = SvTIED_mg((SV*)av, 'P')) {
	dSP;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	XPUSHs(SvTIED_obj((SV*)av, mg));
	PUTBACK;
	ENTER;
	if (perl_call_method("SHIFT", G_SCALAR)) {
	    retval = newSVsv(*PL_stack_sp--);            
	} else {    
	    retval = &PL_sv_undef;
	}     
	LEAVE;
	POPSTACK;
	return retval;
    }
d419 1
a419 1
	*AvARRAY(av) = &PL_sv_undef;
d422 1
a422 1
    AvFILLp(av)--;
d429 2
a430 1
av_len(register AV *av)
d436 3
a438 1
av_fill(register AV *av, I32 fill)
a439 1
    MAGIC *mg;
a443 16
    if (mg = SvTIED_mg((SV*)av, 'P')) {
	dSP;            
	ENTER;
	SAVETMPS;
	PUSHSTACKi(PERLSI_MAGIC);
	PUSHMARK(SP);
	EXTEND(SP,2);
	PUSHs(SvTIED_obj((SV*)av, mg));
	PUSHs(sv_2mortal(newSViv(fill+1)));
	PUTBACK;
	perl_call_method("STORESIZE", G_SCALAR|G_DISCARD);
	POPSTACK;
	FREETMPS;
	LEAVE;
	return;
    }
d445 1
a445 1
	I32 key = AvFILLp(av);
d451 1
a451 1
		ary[key--] = &PL_sv_undef;
d456 1
a456 1
		ary[++key] = &PL_sv_undef;
d459 1
a459 1
	AvFILLp(av) = fill;
d464 1
a464 68
	(void)av_store(av,fill,&PL_sv_undef);
}


/* AVHV: Support for treating arrays as if they were hashes.  The
 * first element of the array should be a hash reference that maps
 * hash keys to array indices.
 */

STATIC I32
avhv_index_sv(SV* sv)
{
    I32 index = SvIV(sv);
    if (index < 1)
	croak("Bad index while coercing array into hash");
    return index;    
}

HV*
avhv_keys(AV *av)
{
    SV **keysp = av_fetch(av, 0, FALSE);
    if (keysp) {
	SV *sv = *keysp;
	if (SvGMAGICAL(sv))
	    mg_get(sv);
	if (SvROK(sv)) {
	    sv = SvRV(sv);
	    if (SvTYPE(sv) == SVt_PVHV)
		return (HV*)sv;
	}
    }
    croak("Can't coerce array into hash");
    return Nullhv;
}

SV**
avhv_fetch_ent(AV *av, SV *keysv, I32 lval, U32 hash)
{
    SV **indsvp;
    HV *keys = avhv_keys(av);
    HE *he;
    
    he = hv_fetch_ent(keys, keysv, FALSE, hash);
    if (!he)
        croak("No such array field");
    return av_fetch(av, avhv_index_sv(HeVAL(he)), lval);
}

bool
avhv_exists_ent(AV *av, SV *keysv, U32 hash)
{
    HV *keys = avhv_keys(av);
    return hv_exists_ent(keys, keysv, hash);
}

HE *
avhv_iternext(AV *av)
{
    HV *keys = avhv_keys(av);
    return hv_iternext(keys);
}

SV *
avhv_iterval(AV *av, register HE *entry)
{
    SV *sv = hv_iterval(avhv_keys(av), entry);
    return *av_fetch(av, avhv_index_sv(sv), TRUE);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
a15 1
#define PERL_IN_AV_C
d19 1
a19 1
Perl_av_reify(pTHX_ AV *av)
d27 2
a28 2
    if (SvTIED_mg((SV*)av, 'P') && ckWARN_d(WARN_DEBUGGING))
	Perl_warner(aTHX_ WARN_DEBUGGING, "av_reify called on tied array");
a47 9
/*
=for apidoc av_extend

Pre-extend an array.  The C<key> is the index to which the array should be
extended.

=cut
*/

d49 1
a49 1
Perl_av_extend(pTHX_ AV *av, I32 key)
d53 1
a53 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d63 1
a63 1
	call_method("EXTEND", G_SCALAR|G_DISCARD);
d93 1
a93 2
		MEM_SIZE bytes;
		IV itmp;
d96 1
a96 1
#if defined(MYMALLOC) && !defined(LEAKTEST)
d109 7
a115 8
		itmp = MALLOC_OVERHEAD;
		while (itmp - MALLOC_OVERHEAD < bytes)
		    itmp += itmp;
		itmp -= MALLOC_OVERHEAD;
		itmp /= sizeof(SV*);
		assert(itmp > newmax);
		newmax = itmp - 1;
		assert(newmax >= AvMAX(av));
a150 13
/*
=for apidoc av_fetch

Returns the SV at the specified index in the array.  The C<key> is the
index.  If C<lval> is set then the fetch will be part of a store.  Check
that the return value is non-null before dereferencing it to a C<SV*>.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for
more information on how to use this function on tied arrays. 

=cut
*/

d152 1
a152 1
Perl_av_fetch(pTHX_ register AV *av, I32 key, I32 lval)
d166 1
a166 1
	if (mg_find((SV*)av,'P') || mg_find((SV*)av,'D')) {
a197 17
/*
=for apidoc av_store

Stores an SV in an array.  The array index is specified as C<key>.  The
return value will be NULL if the operation failed or if the value did not
need to be actually stored within the array (as in the case of tied
arrays). Otherwise it can be dereferenced to get the original C<SV*>.  Note
that the caller is responsible for suitably incrementing the reference
count of C<val> before the call, and decrementing it if the function
returned NULL.

See L<perlguts/"Understanding the Magic of Tied Hashes and Arrays"> for
more information on how to use this function on tied arrays.

=cut
*/

d199 1
a199 1
Perl_av_store(pTHX_ register AV *av, I32 key, SV *val)
d202 2
d217 1
a217 1
	Perl_croak(aTHX_ PL_no_modify);
a256 8
/*
=for apidoc newAV

Creates a new AV.  The reference count is set to 1.

=cut
*/

d258 1
a258 1
Perl_newAV(pTHX)
a270 10
/*
=for apidoc av_make

Creates a new AV and populates it with a list of SVs.  The SVs are copied
into the array, so they may be freed after the call to av_make.  The new AV
will have a reference count of 1.

=cut
*/

d272 1
a272 1
Perl_av_make(pTHX_ register I32 size, register SV **strp)
d298 1
a298 1
Perl_av_fake(pTHX_ register I32 size, register SV **strp)
a319 9
/*
=for apidoc av_clear

Clears an array, making it empty.  Does not free the memory used by the
array itself.

=cut
*/

d321 1
a321 1
Perl_av_clear(pTHX_ register AV *av)
d327 2
a328 2
    if (SvREFCNT(av) == 0 && ckWARN_d(WARN_DEBUGGING)) {
	Perl_warner(aTHX_ WARN_DEBUGGING, "Attempt to clear deleted array");
d336 1
a336 1
	Perl_croak(aTHX_ PL_no_modify);
d353 1
a353 1
    if ((key = AvARRAY(av) - AvALLOC(av))) {
a360 8
/*
=for apidoc av_undef

Undefines the array.  Frees the memory used by the array itself.

=cut
*/

d362 1
a362 1
Perl_av_undef(pTHX_ register AV *av)
a388 9
/*
=for apidoc av_push

Pushes an SV onto the end of the array.  The array will grow automatically
to accommodate the addition.

=cut
*/

d390 1
a390 1
Perl_av_push(pTHX_ register AV *av, SV *val)
d396 1
a396 1
	Perl_croak(aTHX_ PL_no_modify);
d398 1
a398 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d407 1
a407 1
	call_method("PUSH", G_SCALAR|G_DISCARD);
a414 9
/*
=for apidoc av_pop

Pops an SV off the end of the array.  Returns C<&PL_sv_undef> if the array
is empty.

=cut
*/

d416 1
a416 1
Perl_av_pop(pTHX_ register AV *av)
d424 2
a425 2
	Perl_croak(aTHX_ PL_no_modify);
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d432 1
a432 1
	if (call_method("POP", G_SCALAR)) {
a447 10
/*
=for apidoc av_unshift

Unshift the given number of C<undef> values onto the beginning of the
array.  The array will grow automatically to accommodate the addition.  You
must then use C<av_store> to assign values to these new elements.

=cut
*/

d449 1
a449 1
Perl_av_unshift(pTHX_ register AV *av, register I32 num)
d458 1
a458 1
	Perl_croak(aTHX_ PL_no_modify);
d460 1
a460 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d471 1
a471 1
	call_method("UNSHIFT", G_SCALAR|G_DISCARD);
a500 8
/*
=for apidoc av_shift

Shifts an SV off the beginning of the array.

=cut
*/

d502 1
a502 1
Perl_av_shift(pTHX_ register AV *av)
d510 2
a511 2
	Perl_croak(aTHX_ PL_no_modify);
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d518 1
a518 1
	if (call_method("SHIFT", G_SCALAR)) {
a537 9
/*
=for apidoc av_len

Returns the highest index in the array.  Returns -1 if the array is
empty.

=cut
*/

d539 1
a539 1
Perl_av_len(pTHX_ register AV *av)
d545 1
a545 1
Perl_av_fill(pTHX_ register AV *av, I32 fill)
d549 1
a549 1
	Perl_croak(aTHX_ "panic: null array");
d552 1
a552 1
    if ((mg = SvTIED_mg((SV*)av, 'P'))) {
d562 1
a562 1
	call_method("STORESIZE", G_SCALAR|G_DISCARD);
a590 80
SV *
Perl_av_delete(pTHX_ AV *av, I32 key, I32 flags)
{
    SV *sv;

    if (!av)
	return Nullsv;
    if (SvREADONLY(av))
	Perl_croak(aTHX_ PL_no_modify);
    if (key < 0) {
	key += AvFILL(av) + 1;
	if (key < 0)
	    return Nullsv;
    }
    if (SvRMAGICAL(av)) {
	SV **svp;
	if ((mg_find((SV*)av,'P') || mg_find((SV*)av,'D'))
	    && (svp = av_fetch(av, key, TRUE)))
	{
	    sv = *svp;
	    mg_clear(sv);
	    if (mg_find(sv, 'p')) {
		sv_unmagic(sv, 'p');		/* No longer an element */
		return sv;
	    }
	    return Nullsv;			/* element cannot be deleted */
	}
    }
    if (key > AvFILLp(av))
	return Nullsv;
    else {
	sv = AvARRAY(av)[key];
	if (key == AvFILLp(av)) {
	    do {
		AvFILLp(av)--;
	    } while (--key >= 0 && AvARRAY(av)[key] == &PL_sv_undef);
	}
	else
	    AvARRAY(av)[key] = &PL_sv_undef;
	if (SvSMAGICAL(av))
	    mg_set((SV*)av);
    }
    if (flags & G_DISCARD) {
	SvREFCNT_dec(sv);
	sv = Nullsv;
    }
    return sv;
}

/*
 * This relies on the fact that uninitialized array elements
 * are set to &PL_sv_undef.
 */

bool
Perl_av_exists(pTHX_ AV *av, I32 key)
{
    if (!av)
	return FALSE;
    if (key < 0) {
	key += AvFILL(av) + 1;
	if (key < 0)
	    return FALSE;
    }
    if (SvRMAGICAL(av)) {
	if (mg_find((SV*)av,'P') || mg_find((SV*)av,'D')) {
	    SV *sv = sv_newmortal();
	    mg_copy((SV*)av, sv, 0, key);
	    magic_existspack(sv, mg_find(sv, 'p'));
	    return SvTRUE(sv);
	}
    }
    if (key <= AvFILLp(av) && AvARRAY(av)[key] != &PL_sv_undef
	&& AvARRAY(av)[key])
    {
	return TRUE;
    }
    else
	return FALSE;
}
d598 1
a598 1
S_avhv_index_sv(pTHX_ SV* sv)
d602 1
a602 1
	Perl_croak(aTHX_ "Bad index while coercing array into hash");
a605 14
STATIC I32
S_avhv_index(pTHX_ AV *av, SV *keysv, U32 hash)
{
    HV *keys;
    HE *he;
    STRLEN n_a;

    keys = avhv_keys(av);
    he = hv_fetch_ent(keys, keysv, FALSE, hash);
    if (!he)
        Perl_croak(aTHX_ "No such pseudo-hash field \"%s\"", SvPV(keysv,n_a));
    return avhv_index_sv(HeVAL(he));
}

d607 1
a607 1
Perl_avhv_keys(pTHX_ AV *av)
d620 1
a620 1
    Perl_croak(aTHX_ "Can't coerce array into hash");
d625 1
a625 13
Perl_avhv_store_ent(pTHX_ AV *av, SV *keysv, SV *val, U32 hash)
{
    return av_store(av, avhv_index(av, keysv, hash), val);
}

SV**
Perl_avhv_fetch_ent(pTHX_ AV *av, SV *keysv, I32 lval, U32 hash)
{
    return av_fetch(av, avhv_index(av, keysv, hash), lval);
}

SV *
Perl_avhv_delete_ent(pTHX_ AV *av, SV *keysv, I32 flags, U32 hash)
d627 1
d630 1
a630 1
	
d632 3
a634 4
    if (!he || !SvOK(HeVAL(he)))
	return Nullsv;

    return av_delete(av, avhv_index_sv(HeVAL(he)), flags);
a636 3
/* Check for the existence of an element named by a given key.
 *
 */
d638 1
a638 1
Perl_avhv_exists_ent(pTHX_ AV *av, SV *keysv, U32 hash)
d641 1
a641 7
    HE *he;
	
    he = hv_fetch_ent(keys, keysv, FALSE, hash);
    if (!he || !SvOK(HeVAL(he)))
	return FALSE;

    return av_exists(av, avhv_index_sv(HeVAL(he)));
d645 1
a645 1
Perl_avhv_iternext(pTHX_ AV *av)
d652 1
a652 1
Perl_avhv_iterval(pTHX_ AV *av, register HE *entry)
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d37 2
a38 1
	if (sv != &PL_sv_undef)
d40 1
d61 1
d192 1
d275 1
a556 1
    I32 slide;
a593 3
	/* Create extra elements */
	slide = i > 0 ? i : 0;
	num += slide;
a600 4
	/* Make extra elements into a buffer */
	AvMAX(av) -= slide;
	AvFILLp(av) -= slide;
	SvPVX(av) = (char*)(AvARRAY(av) + slide);
a663 8
/*
=for apidoc av_fill

Ensure than an array has a given number of elements, equivalent to
Perl's C<$#array = $fill;>.

=cut
*/
a710 8
/*
=for apidoc av_delete

Deletes the element indexed by C<key> from the array.  Returns the
deleted element. C<flags> is currently ignored.

=cut
*/
d761 3
a763 6
=for apidoc av_exists

Returns true if the element indexed by C<key> has been initialized.

This relies on the fact that uninitialized array elements are set to
C<&PL_sv_undef>.
a764 2
=cut
*/
a777 2
	    MAGIC *mg;

d779 2
a780 5
	    mg = mg_find(sv, 'p');
	    if (mg) {
		magic_existspack(sv, mg);
		return SvTRUE(sv);
	    }
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
a14 4
/*
=head1 Array Manipulation Functions
*/

d28 2
a29 2
    if (SvTIED_mg((SV*)av, PERL_MAGIC_tied) && ckWARN_d(WARN_DEBUGGING))
	Perl_warner(aTHX_ packWARN(WARN_DEBUGGING), "av_reify called on tied array");
d60 1
a60 1
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
d99 1
a99 1
#if !defined(STRANGE_MALLOC) && !defined(MYMALLOC)
d118 1
a118 1
		while ((MEM_SIZE)(itmp - MALLOC_OVERHEAD) < bytes)
a132 1
#if defined(MYMALLOC) && !defined(LEAKTEST)
a133 1
#endif
d188 1
a188 3
	if (mg_find((SV*)av, PERL_MAGIC_tied) ||
		mg_find((SV*)av, PERL_MAGIC_regdata))
	{
d256 1
a256 1
	if (mg_find((SV*)av, PERL_MAGIC_tied)) {
d390 1
a390 1
	Perl_warner(aTHX_ packWARN(WARN_DEBUGGING), "Attempt to clear deleted array");
d441 1
a441 1
    if (SvTIED_mg((SV*)av, PERL_MAGIC_tied)) 
d477 1
a477 1
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
d509 2
a510 2
    if (!av)
      return &PL_sv_undef;
d513 1
a513 1
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
a528 2
    if (AvFILL(av) < 0)
	return &PL_sv_undef;
d554 1
a554 1
    if (!av)
d559 1
a559 1
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
a575 2
    if (num <= 0)
      return;
d621 1
a621 1
    if (!av)
d625 1
a625 1
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
a640 2
    if (AvFILL(av) < 0)
      return &PL_sv_undef;
d683 1
a683 1
    if ((mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied))) {
d746 1
a746 2
	if ((mg_find((SV*)av, PERL_MAGIC_tied) ||
		mg_find((SV*)av, PERL_MAGIC_regdata))
d751 2
a752 2
	    if (mg_find(sv, PERL_MAGIC_tiedelem)) {
		sv_unmagic(sv, PERL_MAGIC_tiedelem);	/* No longer an element */
a762 1
	    AvARRAY(av)[key] = &PL_sv_undef;
d800 1
a800 3
	if (mg_find((SV*)av, PERL_MAGIC_tied) ||
		mg_find((SV*)av, PERL_MAGIC_regdata))
	{
d805 1
a805 1
	    mg = mg_find(sv, PERL_MAGIC_tiedelem);
d808 1
a808 1
		return (bool)SvTRUE(sv);
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d108 1
a108 1
#ifdef MYMALLOC
d137 1
a137 1
#ifdef MYMALLOC
a186 32
    if (SvRMAGICAL(av)) {
        MAGIC *tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
        if (tied_magic || mg_find((SV*)av, PERL_MAGIC_regdata)) {
            U32 adjust_index = 1;

            if (tied_magic && key < 0) {
                /* Handle negative array indices 20020222 MJD */
                SV **negative_indices_glob = 
                    hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, 
                                                     tied_magic))), 
                             NEGATIVE_INDICES_VAR, 16, 0);

                if (negative_indices_glob
                    && SvTRUE(GvSV(*negative_indices_glob)))
                    adjust_index = 0;
            }

            if (key < 0 && adjust_index) {
                key += AvFILL(av) + 1;
                if (key < 0)
                    return 0;
            }

            sv = sv_newmortal();
	    sv_upgrade(sv, SVt_PVLV);
	    mg_copy((SV*)av, sv, 0, key);
	    LvTYPE(sv) = 't';
	    LvTARG(sv) = sv; /* fake (SV**) */
	    return &(LvTARG(sv));
        }
    }

d193 11
a253 27
    if (SvRMAGICAL(av)) {
        MAGIC *tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
        if (tied_magic) {
            /* Handle negative array indices 20020222 MJD */
            if (key < 0) {
                unsigned adjust_index = 1;
                SV **negative_indices_glob = 
                    hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, 
                                                     tied_magic))), 
                             NEGATIVE_INDICES_VAR, 16, 0);
                if (negative_indices_glob
                    && SvTRUE(GvSV(*negative_indices_glob)))
                    adjust_index = 0;
                if (adjust_index) {
                    key += AvFILL(av) + 1;
                    if (key < 0)
                        return 0;
                }
            }
	    if (val != &PL_sv_undef) {
		mg_copy((SV*)av, val, 0, key);
	    }
	    return 0;
        }
    }


d263 9
d419 1
a419 3
	    SV * sv = ary[--key];
	    /* undef the slot before freeing the value, because a
	     * destructor might try to modify this arrray */
a420 1
	    SvREFCNT_dec(sv);
a752 36

    if (SvRMAGICAL(av)) {
        MAGIC *tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
        SV **svp;
        if ((tied_magic || mg_find((SV*)av, PERL_MAGIC_regdata))) {
            /* Handle negative array indices 20020222 MJD */
            if (key < 0) {
                unsigned adjust_index = 1;
                if (tied_magic) {
                    SV **negative_indices_glob = 
                        hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, 
                                                         tied_magic))), 
                                 NEGATIVE_INDICES_VAR, 16, 0);
                    if (negative_indices_glob
                        && SvTRUE(GvSV(*negative_indices_glob)))
                        adjust_index = 0;
                }
                if (adjust_index) {
                    key += AvFILL(av) + 1;
                    if (key < 0)
                        return Nullsv;
                }
            }
            svp = av_fetch(av, key, TRUE);
            if (svp) {
                sv = *svp;
                mg_clear(sv);
                if (mg_find(sv, PERL_MAGIC_tiedelem)) {
                    sv_unmagic(sv, PERL_MAGIC_tiedelem); /* No longer an element */
                    return sv;
                }
                return Nullsv;     
            }
        }
    }

d758 15
a772 1

a809 36


    if (SvRMAGICAL(av)) {
        MAGIC *tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
        if (tied_magic || mg_find((SV*)av, PERL_MAGIC_regdata)) {
            SV *sv = sv_newmortal();
            MAGIC *mg;
            /* Handle negative array indices 20020222 MJD */
            if (key < 0) {
                unsigned adjust_index = 1;
                if (tied_magic) {
                    SV **negative_indices_glob = 
                        hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, 
                                                         tied_magic))), 
                                 NEGATIVE_INDICES_VAR, 16, 0);
                    if (negative_indices_glob
                        && SvTRUE(GvSV(*negative_indices_glob)))
                        adjust_index = 0;
                }
                if (adjust_index) {
                    key += AvFILL(av) + 1;
                    if (key < 0)
                        return FALSE;
                }
            }

            mg_copy((SV*)av, sv, 0, key);
            mg = mg_find(sv, PERL_MAGIC_tiedelem);
            if (mg) {
                magic_existspack(sv, mg);
                return (bool)SvTRUE(sv);
            }

        }
    }

d815 6
d822 8
a875 3
            if (ckWARN(WARN_DEPRECATED) && !sv_isa(sv, "pseudohash"))
	        Perl_warner(aTHX_ packWARN(WARN_DEPRECATED),
			    "Pseudo-hashes are deprecated");
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@a102 5
#ifdef PERL_MALLOC_WRAP
	    static const char oom_array_extend[] =
	      "Out of memory during array extend"; /* Duplicated in pp_hot.c */
#endif

a116 1
		MEM_WRAP_CHECK_1(newmax+1, SV*, oom_array_extend);
a150 1
		MEM_WRAP_CHECK_1(newmax+1, SV*, oom_array_extend);
d783 1
a783 2
deleted element. If C<flags> equals C<G_DISCARD>, the element is freed
and null is returned.
a840 2
	if (!AvREAL(av) && AvREIFY(av))
	    av_reify(av);
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@a866 2
    else if (AvREAL(av))
	sv = sv_2mortal(sv);
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, by Larry Wall and others
d28 1
d40 1
a40 1
	SV * const sv = AvARRAY(av)[--key];
d64 2
a65 2
    MAGIC * const mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied);
    if (mg) {
d91 1
a91 1
	    SvPV_set(av, (char*)AvALLOC(av));
d96 1
d136 1
a136 1
		Newx(ary, newmax+1, SV*);
d158 1
a158 1
		Newx(AvALLOC(av), newmax+1, SV*);
d168 1
a168 1
	    SvPV_set(av, (char*)AvALLOC(av));
d196 1
a196 1
        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
d202 1
a202 1
		SV * const * const negative_indices_glob =
d284 1
a284 1
        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
d289 1
a289 1
		SV * const * const negative_indices_glob =
d358 1
a358 1
    register AV * const av = (AV*)NEWSV(3,0);
d360 1
d362 1
a362 1
    /* sv_upgrade does AvREAL_only()  */
d364 1
a364 1
    SvPV_set(av, (char*)0);
d382 3
a384 1
    register AV * const av = (AV*)NEWSV(8,0);
d386 1
d388 3
a390 5
    /* sv_upgrade does AvREAL_only()  */
    if (size) {		/* "defined" was returning undef for size==0 anyway. */
        register SV** ary;
        register I32 i;
	Newx(ary,size,SV*);
d392 1
a392 1
	SvPV_set(av, (char*)ary);
d408 1
a409 1
    register AV * const av = (AV*)NEWSV(9,0);
d411 1
d413 1
a413 1
    Newx(ary,size+1,SV*);
d417 1
a417 1
    SvPV_set(av, (char*)ary);
d441 1
d450 1
d463 1
a463 1
	SV** const ary = AvARRAY(av);
d466 1
a466 1
	    SV * const sv = ary[--key];
d475 1
a475 1
	SvPV_set(av, (char*)AvALLOC(av));
d492 2
d496 1
d503 1
a503 1
	register I32 key = AvFILLp(av) + 1;
d509 1
a509 1
    SvPV_set(av, (char*)0);
d511 1
a511 17
    /* Need to check SvMAGICAL, as during global destruction it may be that
       AvARYLEN(av) has been freed before av, and hence the SvANY() pointer
       is now part of the linked list of SV heads, rather than pointing to
       the original body.  */
    /* FIXME - audit the code for other bugs like this one.  */
    if (AvARYLEN(av) && SvMAGICAL(AvARYLEN(av))) {
	MAGIC *mg = mg_find (AvARYLEN(av), PERL_MAGIC_arylen);

	if (mg) {
	    /* arylen scalar holds a pointer back to the array, but doesn't
	       own a reference. Hence the we (the array) are about to go away
	       with it still pointing at us. Clear its pointer, else it would
	       be pointing at free memory. See the comment in sv_magic about
	       reference loops, and why it can't own a reference to us.  */
	    mg->mg_obj = 0;
	}

d610 1
d612 1
d648 1
a648 1
	SvPV_set(av, (char*)(AvARRAY(av) - i));
a650 2
	register SV **ary;
	I32 slide;
d665 1
a665 1
	SvPV_set(av, (char*)(AvARRAY(av) + slide));
d708 1
a708 1
    SvPV_set(av, (char*)(AvARRAY(av) + 1));
d806 2
a807 1
        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
a809 1
            SV **svp;
d813 1
a813 1
		    SV * const * const negative_indices_glob =
d890 1
a890 1
        const MAGIC * const tied_magic = mg_find((SV*)av, PERL_MAGIC_tied);
d898 1
a898 1
		    SV * const * const negative_indices_glob =
a1040 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
a26 1
    dVAR;
a28 2
    assert(av);

d42 1
a42 1
	    SvREFCNT_inc_simple_void_NN(sv);
d63 1
a63 6
    dVAR;
    MAGIC *mg;

    assert(av);

    mg = SvTIED_mg((SV*)av, PERL_MAGIC_tied);
d90 1
a90 1
	    AvARRAY(av) = AvALLOC(av);
d166 1
a166 1
	    AvARRAY(av) = AvALLOC(av);
d188 1
a188 1
    dVAR;
d190 2
a191 1
    assert(av);
d196 8
a203 8
	    SV *sv;
	    if (key < 0) {
		I32 adjust_index = 1;
		if (tied_magic) {
		    /* Handle negative array indices 20020222 MJD */
		    SV * const * const negative_indices_glob =
			hv_fetch(SvSTASH(SvRV(SvTIED_obj((SV *)av, tied_magic))),
				NEGATIVE_INDICES_VAR, 16, 0);
d205 4
a208 3
		    if (negative_indices_glob && SvTRUE(GvSV(*negative_indices_glob)))
			adjust_index = 0;
		}
d210 5
a214 6
		if (adjust_index) {
		    key += AvFILL(av) + 1;
		    if (key < 0)
			return NULL;
		}
	    }
d228 1
a228 1
	    return NULL;
d233 3
a235 2
	    return NULL;
	return av_store(av,key,newSV(0));
d239 5
a243 3
	if (lval)
	    return av_store(av,key,newSV(0));
	return NULL;
d247 1
a247 1
		 || SvIS_FREED(AvARRAY(av)[key]))) {
a273 1
    dVAR;
d276 2
a277 6
    assert(av);

    /* S_regclass relies on being able to pass in a NULL sv
       (unicode_alternate may be NULL).
    */

d286 1
a286 1
		bool adjust_index = 1;
d303 1
a303 1
	    return NULL;
d311 1
a311 1
	    return NULL;
d326 1
a326 1
	    do {
d328 1
a328 1
	    } while (AvFILLp(av) < key);
a335 1
	const MAGIC* const mg = SvMAGIC(av);
d337 1
d340 1
a340 4
	if (PL_delaymagic && mg->mg_type == PERL_MAGIC_isa)
	    PL_delaymagic |= DM_ARRAY;
	else
	   mg_set((SV*)av);
d356 3
a358 1
    register AV * const av = (AV*)newSV_type(SVt_PVAV);
d361 1
a361 1
    AvARRAY(av) = NULL;
d379 3
a381 1
    register AV * const av = (AV*)newSV_type(SVt_PVAV);
d388 3
a390 2
	AvARRAY(av) = ary;
	AvFILLp(av) = AvMAX(av) = size - 1;
d393 1
a393 1
	    ary[i] = newSV(0);
d401 22
d435 1
a435 2
    dVAR;
    I32 extra;
a436 1
    assert(av);
d442 2
d449 2
a450 7
    if (SvRMAGICAL(av)) {
	const MAGIC* const mg = SvMAGIC(av);
	if (PL_delaymagic && mg->mg_type == PERL_MAGIC_isa)
	    PL_delaymagic |= DM_ARRAY;
        else
	    mg_clear((SV*)av); 
    }
d457 3
a459 3
	I32 index = AvFILLp(av) + 1;
	while (index) {
	    SV * const sv = ary[--index];
d461 2
a462 2
	     * destructor might try to modify this array */
	    ary[index] = &PL_sv_undef;
d466 3
a468 4
    extra = AvARRAY(av) - AvALLOC(av);
    if (extra) {
	AvMAX(av) += extra;
	AvARRAY(av) = AvALLOC(av);
d485 2
a486 1
    assert(av);
d490 1
a490 1
	av_fill(av, -1);
a496 1

d498 2
a499 2
    AvALLOC(av) = NULL;
    AvARRAY(av) = NULL;
d501 16
d518 3
a520 19
    if(SvRMAGICAL(av)) mg_clear((SV*)av);
}

/*

=for apidoc av_create_and_push

Push an SV onto the end of the array, creating the array if necessary.
A small internal helper function to remove a commonly duplicated idiom.

=cut
*/

void
Perl_av_create_and_push(pTHX_ AV **const avp, SV *const val)
{
    if (!*avp)
	*avp = newAV();
    av_push(*avp, val);
a534 1
    dVAR;
d536 2
a537 2
    assert(av);

a569 1
    dVAR;
d573 2
a574 2
    assert(av);

a602 20

=for apidoc av_create_and_unshift_one

Unshifts an SV onto the beginning of the array, creating the array if
necessary.
A small internal helper function to remove a commonly duplicated idiom.

=cut
*/

SV **
Perl_av_create_and_unshift_one(pTHX_ AV **const avp, SV *const val)
{
    if (!*avp)
	*avp = newAV();
    av_unshift(*avp, 1);
    return av_store(*avp, 0, val);
}

/*
a614 1
    dVAR;
d618 2
a619 2
    assert(av);

d652 1
a652 1
	AvARRAY(av) = AvARRAY(av) - i;
d656 2
a657 1
	const I32 i = AvFILLp(av);
d659 1
a659 1
	const I32 slide = i > 0 ? i : 0;
d671 1
a671 1
	AvARRAY(av) = AvARRAY(av) + slide;
a685 1
    dVAR;
d689 2
a690 2
    assert(av);

d714 1
a714 1
    AvARRAY(av) = AvARRAY(av) + 1;
d725 2
a726 2
Returns the highest index in the array.  The number of elements in the
array is C<av_len(av) + 1>.  Returns -1 if the array is empty.
d732 1
a732 1
Perl_av_len(pTHX_ register const AV *av)
a733 1
    assert(av);
d740 1
a740 1
Set the highest index in the array to the given number, equivalent to
a742 6
The number of elements in the an array will be C<fill + 1> after
av_fill() returns.  If the array was previously shorter then the
additional elements appended are set to C<PL_sv_undef>.  If the array
was longer, then the excess elements are freed.  C<av_fill(av, -1)> is
the same as C<av_clear(av)>.

a747 1
    dVAR;
d749 2
a750 3

    assert(av);

d771 1
a771 1
	SV** const ary = AvARRAY(av);
a803 1
    dVAR;
d806 2
a807 2
    assert(av);

d830 1
a830 1
			return NULL;
d841 1
a841 1
		return NULL;
d849 1
a849 1
	    return NULL;
d853 1
a853 1
	return NULL;
d871 1
a871 1
	sv = NULL;
d891 3
a893 2
    dVAR;
    assert(av);
d898 1
a898 1
	    SV * const sv = sv_newmortal();
d944 4
a947 4
SV **
Perl_av_arylen_p(pTHX_ AV *av) {
    dVAR;
    MAGIC *mg;
d949 8
a956 1
    assert(av);
d958 13
a970 1
    mg = mg_find((SV*)av, PERL_MAGIC_arylen_p);
d972 16
a987 6
    if (!mg) {
	mg = sv_magicext((SV*)av, 0, PERL_MAGIC_arylen_p, &PL_vtbl_arylen_p,
			 0, 0);
	assert(mg);
	/* sv_magicext won't set this for us because we pass in a NULL obj  */
	mg->mg_flags |= MGf_REFCOUNTED;
d989 57
a1045 1
    return &(mg->mg_obj);
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d12 2
a13 4
 * '...for the Entwives desired order, and plenty, and peace (by which they
 *  meant that things should remain where they had set them).' --Treebeard
 *
 *     [p.476 of _The Lord of the Rings_, III/iv: "Treebeard"]
d30 1
a30 2
    PERL_ARGS_ASSERT_AV_REIFY;
    assert(SvTYPE(av) == SVt_PVAV);
d35 1
a35 1
    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied) && ckWARN_d(WARN_DEBUGGING))
d69 1
a69 2
    PERL_ARGS_ASSERT_AV_EXTEND;
    assert(SvTYPE(av) == SVt_PVAV);
d71 1
a71 1
    mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied);
d79 2
a80 2
	PUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
	mPUSHi(key + 1);
d120 2
a121 16
#ifdef Perl_safesysmalloc_size
		/* Whilst it would be quite possible to move this logic around
		   (as I did in the SV code), so as to set AvMAX(av) early,
		   based on calling Perl_safesysmalloc_size() immediately after
		   allocation, I'm not convinced that it is a great idea here.
		   In an array we have to loop round setting everything to
		   &PL_sv_undef, which means writing to memory, potentially lots
		   of it, whereas for the SV buffer case we don't touch the
		   "bonus" memory. So there there is no cost in telling the
		   world about it, whereas here we have to do work before we can
		   tell the world about it, and that work involves writing to
		   memory that might never be read. So, I feel, better to keep
		   the current lazy system of only writing to it if our caller
		   has a need for more space. NWC  */
		newmax = Perl_safesysmalloc_size((void*)AvALLOC(av)) /
		    sizeof(const SV *) - 1;
d132 1
a132 1
		bytes = (newmax + 1) * sizeof(const SV *);
d138 1
a138 1
		itmp /= sizeof(const SV *);
d145 1
a145 2
		    offer_nice_chunk(AvALLOC(av),
				     (AvMAX(av)+1) * sizeof(const SV *));
d150 1
a150 1
#ifdef Perl_safesysmalloc_size
d198 1
a198 2
    PERL_ARGS_ASSERT_AV_FETCH;
    assert(SvTYPE(av) == SVt_PVAV);
d201 2
a202 3
        const MAGIC * const tied_magic
	    = mg_find((const SV *)av, PERL_MAGIC_tied);
        if (tied_magic || mg_find((const SV *)av, PERL_MAGIC_regdata)) {
d209 1
a209 2
			hv_fetch(SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(av),
							 tied_magic))),
d225 1
a225 1
	    mg_copy(MUTABLE_SV(av), sv, 0, key);
d281 1
a281 2
    PERL_ARGS_ASSERT_AV_STORE;
    assert(SvTYPE(av) == SVt_PVAV);
d291 1
a291 1
        const MAGIC * const tied_magic = mg_find((const SV *)av, PERL_MAGIC_tied);
d297 1
a297 1
                    hv_fetch(SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(av), 
d310 1
a310 1
		mg_copy(MUTABLE_SV(av), val, 0, key);
d324 1
a324 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d347 1
a347 1
	    sv_magic(val, MUTABLE_SV(av), toLOWER(mg->mg_type), 0, key);
d352 1
a352 1
	   mg_set(MUTABLE_SV(av));
d358 19
d389 1
a389 1
    register AV * const av = MUTABLE_AV(newSV_type(SVt_PVAV));
a390 3
    PERL_ARGS_ASSERT_AV_MAKE;
    assert(SvTYPE(av) == SVt_PVAV);

d423 1
a423 3
    PERL_ARGS_ASSERT_AV_CLEAR;
    assert(SvTYPE(av) == SVt_PVAV);

d431 1
a431 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d436 1
a436 1
	if (PL_delaymagic && mg && mg->mg_type == PERL_MAGIC_isa)
d439 1
a439 1
	    mg_clear(MUTABLE_SV(av)); 
d476 1
a476 2
    PERL_ARGS_ASSERT_AV_UNDEF;
    assert(SvTYPE(av) == SVt_PVAV);
d479 1
a479 1
    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied)) 
d493 1
a493 1
    if(SvRMAGICAL(av)) mg_clear(MUTABLE_SV(av));
a508 2
    PERL_ARGS_ASSERT_AV_CREATE_AND_PUSH;

d518 1
a518 2
to accommodate the addition. Like C<av_store>, this takes ownership of one
reference count.
d528 1
a528 3

    PERL_ARGS_ASSERT_AV_PUSH;
    assert(SvTYPE(av) == SVt_PVAV);
d531 1
a531 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d533 1
a533 1
    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
d538 1
a538 1
	PUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
d566 1
a566 2
    PERL_ARGS_ASSERT_AV_POP;
    assert(SvTYPE(av) == SVt_PVAV);
d569 2
a570 2
	Perl_croak(aTHX_ "%s", PL_no_modify);
    if ((mg = SvTIED_mg((const SV*)av, PERL_MAGIC_tied))) {
d574 1
a574 1
	XPUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
d591 1
a591 1
	mg_set(MUTABLE_SV(av));
a608 2
    PERL_ARGS_ASSERT_AV_CREATE_AND_UNSHIFT_ONE;

d632 1
a632 2
    PERL_ARGS_ASSERT_AV_UNSHIFT;
    assert(SvTYPE(av) == SVt_PVAV);
d635 1
a635 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d637 1
a637 1
    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
d642 1
a642 1
	PUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
d691 1
a691 2
Shifts an SV off the beginning of the array. Returns C<&PL_sv_undef> if the 
array is empty.
d703 1
a703 2
    PERL_ARGS_ASSERT_AV_SHIFT;
    assert(SvTYPE(av) == SVt_PVAV);
d706 2
a707 2
	Perl_croak(aTHX_ "%s", PL_no_modify);
    if ((mg = SvTIED_mg((const SV*)av, PERL_MAGIC_tied))) {
d711 1
a711 1
	XPUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
d732 1
a732 1
	mg_set(MUTABLE_SV(av));
d748 1
a748 3
    PERL_ARGS_ASSERT_AV_LEN;
    assert(SvTYPE(av) == SVt_PVAV);

d772 1
a772 2
    PERL_ARGS_ASSERT_AV_FILL;
    assert(SvTYPE(av) == SVt_PVAV);
d776 1
a776 1
    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
d783 2
a784 2
	PUSHs(SvTIED_obj(MUTABLE_SV(av), mg));
	mPUSHi(fill + 1);
d809 1
a809 1
	    mg_set(MUTABLE_SV(av));
d830 1
a830 2
    PERL_ARGS_ASSERT_AV_DELETE;
    assert(SvTYPE(av) == SVt_PVAV);
d833 1
a833 1
	Perl_croak(aTHX_ "%s", PL_no_modify);
d836 2
a837 3
        const MAGIC * const tied_magic
	    = mg_find((const SV *)av, PERL_MAGIC_tied);
        if ((tied_magic || mg_find((const SV *)av, PERL_MAGIC_regdata))) {
d844 1
a844 1
                        hv_fetch(SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(av), 
d891 1
a891 1
	    mg_set(MUTABLE_SV(av));
d916 1
a916 2
    PERL_ARGS_ASSERT_AV_EXISTS;
    assert(SvTYPE(av) == SVt_PVAV);
d919 2
a920 3
        const MAGIC * const tied_magic
	    = mg_find((const SV *)av, PERL_MAGIC_tied);
        if (tied_magic || mg_find((const SV *)av, PERL_MAGIC_regdata)) {
d928 1
a928 1
                        hv_fetch(SvSTASH(SvRV(SvTIED_obj(MUTABLE_SV(av), 
d942 1
a942 1
            mg_copy(MUTABLE_SV(av), sv, 0, key);
d972 1
a972 2
    PERL_ARGS_ASSERT_AV_ARYLEN_P;
    assert(SvTYPE(av) == SVt_PVAV);
d974 1
a974 1
    mg = mg_find((const SV *)av, PERL_MAGIC_arylen_p);
d977 2
a978 2
	mg = sv_magicext(MUTABLE_SV(av), 0, PERL_MAGIC_arylen_p,
			 &PL_vtbl_arylen_p, 0, 0);
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d38 2
a39 2
    if (SvTIED_mg((const SV *)av, PERL_MAGIC_tied))
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING), "av_reify called on tied array");
a406 5

	    /* Don't let sv_setsv swipe, since our source array might
	       have multiple references to the same temp scalar (e.g.
	       from a list slice) */

d408 1
a408 2
	    sv_setsv_flags(ary[i], *strp,
			   SV_GMAGIC|SV_DO_COW_SVSETSV|SV_NOSTEAL);
d434 2
a435 2
    if (SvREFCNT(av) == 0) {
	Perl_ck_warner_d(aTHX_ packWARN(WARN_DEBUGGING), "Attempt to clear deleted array");
d586 1
a586 1
    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
d728 1
a728 1
    if ((mg = SvTIED_mg((const SV *)av, PERL_MAGIC_tied))) {
d767 1
a767 1
Perl_av_len(pTHX_ AV *av)
d995 2
a996 2
static MAGIC *
S_get_aux_mg(pTHX_ AV *av) {
d1000 1
a1000 1
    PERL_ARGS_ASSERT_GET_AUX_MG;
a1011 10
    return mg;
}

SV **
Perl_av_arylen_p(pTHX_ AV *av) {
    MAGIC *const mg = get_aux_mg(av);

    PERL_ARGS_ASSERT_AV_ARYLEN_P;
    assert(SvTYPE(av) == SVt_PVAV);

a1012 20
}

IV *
Perl_av_iter_p(pTHX_ AV *av) {
    MAGIC *const mg = get_aux_mg(av);

    PERL_ARGS_ASSERT_AV_ITER_P;
    assert(SvTYPE(av) == SVt_PVAV);

#if IVSIZE == I32SIZE
    return (IV *)&(mg->mg_len);
#else
    if (!mg->mg_ptr) {
	IV *temp;
	mg->mg_len = IVSIZE;
	Newxz(temp, 1, IV);
	mg->mg_ptr = (char *) temp;
    }
    return (IV *)mg->mg_ptr;
#endif
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d77 13
a89 4
	SV *arg1 = sv_newmortal();
	sv_setiv(arg1, (IV)(key + 1));
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "EXTEND", G_DISCARD, 1,
			    arg1);
d162 5
a166 1
		Safefree(AvALLOC(av));
d203 2
a204 3
index.  If lval is true, you are guaranteed to get a real SV back (in case
it wasn't real before), which you can then modify.  Check that the return
value is non-null before dereferencing it to a C<SV*>.
a208 2
The rough perl equivalent is C<$myarray[$idx]>.

a247 2
	    if (!tied_magic) /* for regdata, force leavesub to make copies */
		SvTEMP_off(sv);
d260 10
a269 3
    if (key > AvFILLp(av) || AvARRAY(av)[key] == &PL_sv_undef) {
      emptyness:
	return lval ? av_store(av,key,newSV(0)) : NULL;
d271 1
a271 2

    if (AvREIFY(av)
d286 2
a287 5
arrays). Otherwise, it can be dereferenced
to get the C<SV*> that was stored
there (= C<val>)).

Note that the caller is responsible for suitably incrementing the reference
a290 2
Approximate Perl equivalent: C<$myarray[$key] = $val;>.

d347 1
a347 1
	Perl_croak_no_modify(aTHX);
d368 2
a369 5
	const MAGIC *mg = SvMAGIC(av);
	bool set = TRUE;
	for (; mg; mg = mg->mg_moremagic) {
	  if (!isUPPER(mg->mg_type)) continue;
	  if (val != &PL_sv_undef) {
a370 5
	  }
	  if (PL_delaymagic && mg->mg_type == PERL_MAGIC_isa) {
	    PL_delaymagic |= DM_ARRAY_ISA;
	    set = FALSE;
	  }
d372 3
a374 1
	if (set)
a386 2
Perl equivalent: C<my @@new_array = ($scalar1, $scalar2, $scalar3...);>

d424 2
a425 5
Clears an array, making it empty.  Does not free the memory the av uses to
store its list of scalars.  If any destructors are triggered as a result,
the av itself may be freed when this function returns.

Perl equivalent: C<@@myarray = ();>.
a434 1
    bool real;
d446 1
a446 1
	Perl_croak_no_modify(aTHX);
d452 1
a452 1
	    PL_delaymagic |= DM_ARRAY_ISA;
d460 1
a460 1
    if ((real = !!AvREAL(av))) {
a462 2
	ENTER;
	SAVEFREESV(SvREFCNT_inc_simple_NN(av));
d477 1
a477 1
    if (real) LEAVE;
d483 1
a483 3
Undefines the array.  Frees the memory used by the av to store its list of
scalars.  If any destructors are triggered as a result, the av itself may
be freed.
a490 2
    bool real;

d498 1
a498 1
    if ((real = !!AvREAL(av))) {
a499 2
	ENTER;
	SAVEFREESV(SvREFCNT_inc_simple_NN(av));
a509 1
    if(real) LEAVE;
d536 2
a537 3
to accommodate the addition.  This takes ownership of one reference count.

Perl equivalent: C<push @@myarray, $elem;>.
d552 1
a552 1
	Perl_croak_no_modify(aTHX);
d555 11
a565 2
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "PUSH", G_DISCARD, 1,
			    val);
a576 2
Perl equivalent: C<pop(@@myarray);>

d591 1
a591 1
	Perl_croak_no_modify(aTHX);
d593 13
a605 3
	retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "POP", 0, 0);
	if (retval)
	    retval = newSVsv(retval);
a645 2
Perl equivalent: C<unshift @@myarray, ( (undef) x $n );>
    
d660 1
a660 1
	Perl_croak_no_modify(aTHX);
d663 13
a675 2
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "UNSHIFT",
			    G_DISCARD | G_UNDEF_FILL, num);
d716 1
a716 2
Shifts an SV off the beginning of the
array.  Returns C<&PL_sv_undef> if the 
a718 2
Perl equivalent: C<shift(@@myarray);>

d733 1
a733 1
	Perl_croak_no_modify(aTHX);
d735 13
a747 3
	retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "SHIFT", 0, 0);
	if (retval)
	    retval = newSVsv(retval);
a768 2
The Perl equivalent for this is C<$#myarray>.

d788 1
a788 1
av_fill() returns.  If the array was previously shorter, then the
d807 13
a819 4
	SV *arg1 = sv_newmortal();
	sv_setiv(arg1, (IV)(fill + 1));
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, "STORESIZE", G_DISCARD,
			    1, arg1);
d848 3
a850 5
Deletes the element indexed by C<key> from the array, makes the element mortal,
and returns it.  If C<flags> equals C<G_DISCARD>, the element is freed and null
is returned.  Perl equivalent: C<my $elem = delete($myarray[$idx]);> for the
non-C<G_DISCARD> version and a void-context C<delete($myarray[$idx]);> for the
C<G_DISCARD> version.
d864 1
a864 1
	Perl_croak_no_modify(aTHX);
a941 2
Perl equivalent: C<exists($myarray[$key])>.

d954 1
a954 3
        const MAGIC * const regdata_magic
            = mg_find((const SV *)av, PERL_MAGIC_regdata);
        if (tied_magic || regdata_magic) {
a972 2
                    else
                        return TRUE;
a975 7
            if(key >= 0 && regdata_magic) {
                if (key <= AvFILL(av))
                    return TRUE;
                else
                    return FALSE;
            }

d980 1
a980 1
                return cBOOL(SvTRUE(sv));
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d83 1
a83 13
    av_extend_guts(av,key,&AvMAX(av),&AvALLOC(av),&AvARRAY(av));
}    

/* The guts of av_extend.  *Not* for general use! */
void
Perl_av_extend_guts(pTHX_ AV *av, I32 key, SSize_t *maxp, SV ***allocp,
			  SV ***arrayp)
{
    dVAR;

    PERL_ARGS_ASSERT_AV_EXTEND_GUTS;

    if (key > *maxp) {
d88 6
a93 6
	if (av && *allocp != *arrayp) {
	    ary = *allocp + AvFILLp(av) + 1;
	    tmp = *arrayp - *allocp;
	    Move(*arrayp, *allocp, AvFILLp(av)+1, SV*);
	    *maxp += tmp;
	    *arrayp = *allocp;
d98 2
a99 2
	    if (key > *maxp - 10) {
		newmax = key + *maxp;
d109 5
a113 1
	    if (*allocp) {
d129 1
a129 1
		newmax = Perl_safesysmalloc_size((void*)*allocp) /
d135 1
a135 1
		newmax = key + *maxp / 5;
d138 18
a155 1
		Renew(*allocp,newmax+1, SV*);
d159 2
a160 2
		ary = *allocp + *maxp + 1;
		tmp = newmax - *maxp;
d162 2
a163 2
		    PL_stack_sp = *allocp + (PL_stack_sp - PL_stack_base);
		    PL_stack_base = *allocp;
d170 2
a171 2
		Newx(*allocp, newmax+1, SV*);
		ary = *allocp + 1;
d173 1
a173 1
		*allocp[0] = &PL_sv_undef;	/* For the stacks */
d175 1
a175 1
	    if (av && AvREAL(av)) {
d180 2
a181 2
	    *arrayp = *allocp;
	    *maxp = newmax;
a201 25
static bool
S_adjust_index(pTHX_ AV *av, const MAGIC *mg, I32 *keyp)
{
    bool adjust_index = 1;
    if (mg) {
	/* Handle negative array indices 20020222 MJD */
	SV * const ref = SvTIED_obj(MUTABLE_SV(av), mg);
	SvGETMAGIC(ref);
	if (SvROK(ref) && SvOBJECT(SvRV(ref))) {
	    SV * const * const negative_indices_glob =
		hv_fetchs(SvSTASH(SvRV(ref)), NEGATIVE_INDICES_VAR, 0);

	    if (negative_indices_glob && SvTRUE(GvSV(*negative_indices_glob)))
		adjust_index = 0;
	}
    }

    if (adjust_index) {
	*keyp += AvFILL(av) + 1;
	if (*keyp < 0)
	    return FALSE;
    }
    return TRUE;
}

d203 1
a203 1
Perl_av_fetch(pTHX_ AV *av, I32 key, I32 lval)
d216 15
a230 1
		if (!S_adjust_index(aTHX_ av, tied_magic, &key))
d232 1
d289 1
a289 1
Perl_av_store(pTHX_ AV *av, I32 key, SV *val)
d307 1
d309 11
a319 1
		if (!S_adjust_index(aTHX_ av, tied_magic, &key))
d321 1
d338 1
a338 1
	Perl_croak_no_modify();
d390 1
a390 1
Perl_av_make(pTHX_ I32 size, SV **strp)
d392 1
a392 1
    AV * const av = MUTABLE_AV(newSV_type(SVt_PVAV));
d398 2
a399 2
        SV** ary;
        I32 i;
d403 1
a403 4
	AvMAX(av) = size - 1;
	AvFILLp(av) = -1;
	ENTER;
	SAVEFREESV(av);
a410 2
	    SvGETMAGIC(*strp); /* before newSV, in case it dies */
	    AvFILLp(av)++;
d413 1
a413 1
			   SV_DO_COW_SVSETSV|SV_NOSTEAL);
a415 2
	SvREFCNT_inc_simple_void_NN(av);
	LEAVE;
d433 1
a433 1
Perl_av_clear(pTHX_ AV *av)
d449 1
a449 1
	Perl_croak_no_modify();
d496 1
a496 1
Perl_av_undef(pTHX_ AV *av)
d508 1
a508 1
	I32 key = AvFILLp(av) + 1;
d556 1
a556 1
Perl_av_push(pTHX_ AV *av, SV *val)
d565 1
a565 1
	Perl_croak_no_modify();
d578 2
a579 3
Removes one SV from the end of the array, reducing its size by one and
returning the SV (transferring control of one reference count) to the
caller.  Returns C<&PL_sv_undef> if the array is empty.
d587 1
a587 1
Perl_av_pop(pTHX_ AV *av)
d597 1
a597 1
	Perl_croak_no_modify();
d643 1
a643 1

d648 1
a648 1
Perl_av_unshift(pTHX_ AV *av, I32 num)
d651 1
a651 1
    I32 i;
d658 1
a658 1
	Perl_croak_no_modify();
d681 1
a681 1
	SV **ary;
d713 1
a713 1
Perl_av_shift(pTHX_ AV *av)
d723 1
a723 1
	Perl_croak_no_modify();
d744 1
a744 1
=for apidoc av_top_index
d747 1
a747 1
array is C<av_top_index(av) + 1>.  Returns -1 if the array is empty.
a750 8
(A slightly shorter form is C<av_tindex>.)

=for apidoc av_len

Same as L</av_top_index>.  Returns the highest index in the array.  Note that the
return value is +1 what its name implies it returns; and hence differs in
meaning from what the similarly named L</sv_len> returns.

d758 1
d760 1
a760 1
    return av_top_index(av);
d778 1
a778 1
Perl_av_fill(pTHX_ AV *av, I32 fill)
d839 1
a839 1
	Perl_croak_no_modify();
d845 1
d848 13
a860 1
		if (!S_adjust_index(aTHX_ av, tied_magic, &key))
d862 1
d934 1
d938 13
a950 1
		if (!S_adjust_index(aTHX_ av, tied_magic, &key))
d952 3
d963 8
a970 12
	    {
		SV * const sv = sv_newmortal();
		mg_copy(MUTABLE_SV(av), sv, 0, key);
		mg = mg_find(sv, PERL_MAGIC_tiedelem);
		if (mg) {
		    magic_existspack(sv, mg);
		    {
			I32 retbool = SvTRUE_nomg_NN(sv);
			return cBOOL(retbool);
		    }
		}
	    }
d1043 1
a1043 1
 * indent-tabs-mode: nil
d1046 1
a1046 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d30 1
a30 1
    SSize_t key;
d43 1
a43 1
	AvARRAY(av)[--key] = NULL;
d46 1
d48 1
a48 1
	    SvREFCNT_inc_simple_void(sv);
d52 1
a52 1
	AvALLOC(av)[--key] = NULL;
d67 1
a67 1
Perl_av_extend(pTHX_ AV *av, SSize_t key)
d79 1
a79 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(EXTEND), G_DISCARD, 1,
d88 1
a88 1
Perl_av_extend_guts(pTHX_ AV *av, SSize_t key, SSize_t *maxp, SV ***allocp,
d97 2
a98 2
	SSize_t tmp;
	SSize_t newmax;
d108 1
a108 1
		    ary[--tmp] = NULL;
d116 5
d129 1
a129 1
		   NULL, which means writing to memory, potentially lots
d145 1
a145 15
		{
#ifdef PERL_MALLOC_WRAP /* Duplicated in pp_hot.c */
		    static const char oom_array_extend[] =
			"Out of memory during array extend";
#endif
		    MEM_WRAP_CHECK_1(newmax+1, SV*, oom_array_extend);
		}
#ifdef STRESS_REALLOC
		{
		    SV ** const old_alloc = *allocp;
		    Newx(*allocp, newmax+1, SV*);
		    Copy(old_alloc, *allocp, *maxp + 1, SV*);
		    Safefree(old_alloc);
		}
#else
a146 1
#endif
d160 1
a160 7
		{
#ifdef PERL_MALLOC_WRAP /* Duplicated in pp_hot.c */
		    static const char oom_array_extend[] =
			"Out of memory during array extend";
#endif
		    MEM_WRAP_CHECK_1(newmax+1, SV*, oom_array_extend);
		}
d164 1
a164 1
		*allocp[0] = NULL;	/* For the stacks */
d168 1
a168 1
		    ary[--tmp] = NULL;
d194 1
a194 1
S_adjust_index(pTHX_ AV *av, const MAGIC *mg, SSize_t *keyp)
d205 1
a205 2
	    if (negative_indices_glob && isGV(*negative_indices_glob)
	     && SvTRUE(GvSV(*negative_indices_glob)))
d219 1
a219 1
Perl_av_fetch(pTHX_ AV *av, SSize_t key, I32 lval)
d253 1
a253 1
    if (key > AvFILLp(av) || !AvARRAY(av)[key]) {
d261 1
a261 1
	AvARRAY(av)[key] = NULL;	/* 1/2 reify */
d273 1
a273 1
arrays).  Otherwise, it can be dereferenced
d290 1
a290 1
Perl_av_store(pTHX_ AV *av, SSize_t key, SV *val)
d302 3
d312 1
a312 1
	    if (val) {
d339 1
a339 1
		ary[++AvFILLp(av)] = NULL;
d352 1
a352 1
	  if (val) {
d379 1
a379 1
Perl_av_make(pTHX_ SSize_t size, SV **strp)
d388 1
a388 1
        SSize_t i;
d432 1
a432 1
    SSize_t extra;
d461 1
a461 1
	SSize_t index = AvFILLp(av) + 1;
d468 1
a468 1
	    ary[index] = NULL;
d504 1
a504 1
	SSize_t key = AvFILLp(av) + 1;
d564 1
a564 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(PUSH), G_DISCARD, 1,
d596 1
a596 1
	retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(POP), 0, 0);
d604 1
a604 1
    AvARRAY(av)[AvFILLp(av)--] = NULL;
d607 1
a607 1
    return retval ? retval : &PL_sv_undef;
d645 1
a645 1
Perl_av_unshift(pTHX_ AV *av, SSize_t num)
d648 1
a648 1
    SSize_t i;
d658 1
a658 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(UNSHIFT),
d679 1
a679 1
	const SSize_t i = AvFILLp(av);
d681 1
a681 1
	const SSize_t slide = i > 0 ? i : 0;
d688 1
a688 1
	    ary[--num] = NULL;
d700 3
a702 3
Removes one SV from the start of the array, reducing its size by one and
returning the SV (transferring control of one reference count) to the
caller.  Returns C<&PL_sv_undef> if the array is empty.
d722 1
a722 1
	retval = Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(SHIFT), 0, 0);
d731 1
a731 1
	*AvARRAY(av) = NULL;
d737 1
a737 1
    return retval ? retval : &PL_sv_undef;
a749 4
=for apidoc av_tindex

Same as L</av_top_index>.

d752 3
a754 4
Same as L</av_top_index>.  Note that, unlike what the name implies, it returns
the highest index in the array, so to get the size of the array you need to use
S<C<av_len(av) + 1>>.  This is unlike L</sv_len>, which returns what you would
expect.
d759 1
a759 1
SSize_t
d773 1
a773 1
The number of elements in the array will be C<fill + 1> after
d775 1
a775 1
additional elements appended are set to NULL.  If the array
d782 1
a782 1
Perl_av_fill(pTHX_ AV *av, SSize_t fill)
d795 1
a795 1
	Perl_magic_methcall(aTHX_ MUTABLE_SV(av), mg, SV_CONST(STORESIZE), G_DISCARD,
d800 1
a800 1
	SSize_t key = AvFILLp(av);
d806 1
a806 1
		ary[key--] = NULL;
d811 1
a811 1
		ary[++key] = NULL;
d819 1
a819 1
	(void)av_store(av,fill,NULL);
d834 1
a834 1
Perl_av_delete(pTHX_ AV *av, SSize_t key, I32 flags)
d880 1
a880 1
	    AvARRAY(av)[key] = NULL;
d883 1
a883 1
	    } while (--key >= 0 && !AvARRAY(av)[key]);
d886 1
a886 1
	    AvARRAY(av)[key] = NULL;
d905 1
a905 1
NULL.
d912 1
a912 1
Perl_av_exists(pTHX_ AV *av, SSize_t key)
d958 2
a959 1
    if (key <= AvFILLp(av) && AvARRAY(av)[key])
@


1.1.1.16
log
@Import perl-5.24.2
@
text
@d29 1
d68 1
d90 2
a93 4
    if (key < -1) /* -1 is legal */
        Perl_croak(aTHX_
            "panic: av_extend_guts() negative count (%"IVdf")", (IV)key);

d137 1
a137 4
                /* overflow-safe version of newmax = key + *maxp/5 */
		newmax = *maxp / 5;
                newmax = (key > SSize_t_MAX - newmax)
                            ? SSize_t_MAX : key + newmax;
d144 1
a144 7
                    /* it should really be newmax+1 here, but if newmax
                     * happens to equal SSize_t_MAX, then newmax+1 is
                     * undefined. This means technically we croak one
                     * index lower than we should in theory; in practice
                     * its unlikely the system has SSize_t_MAX/sizeof(SV*)
                     * bytes to spare! */
		    MEM_WRAP_CHECK_1(newmax, SV*, oom_array_extend);
d174 1
a174 2
                    /* see comment above about newmax+1*/
		    MEM_WRAP_CHECK_1(newmax, SV*, oom_array_extend);
d237 2
d287 1
a287 1
return value will be C<NULL> if the operation failed or if the value did not
d295 1
a295 1
returned C<NULL>.
d308 1
d383 1
a383 1
into the array, so they may be freed after the call to C<av_make>.  The new AV
d432 3
a434 2
Frees the all the elements of an array, leaving it empty.
The XS equivalent of C<@@array = ()>.  See also L</av_undef>.
d436 1
a436 6
Note that it is possible that the actions of a destructor called directly
or indirectly by freeing an element of the array could cause the reference
count of the array itself to be reduced (e.g. by deleting an entry in the
symbol table). So it is a possibility that the AV could have been freed
(or even reallocated) on return from the call unless you hold a reference
to it.
d444 1
d497 3
a499 7
Undefines the array. The XS equivalent of C<undef(@@array)>.

As well as freeing all the elements of the array (like C<av_clear()>), this
also frees the memory used by the av to store its list of scalars.

See L</av_clear> for a note about the array possibly being invalid on
return.
d556 2
a557 2
Pushes an SV (transferring control of one reference count) onto the end of the
array.  The array will grow automatically to accommodate the addition.
d567 1
d599 1
d652 1
a652 1
Perl equivalent: S<C<unshift @@myarray, ( (undef) x $n );>>
d660 1
d725 1
d757 1
a757 1
array is S<C<av_top_index(av) + 1>>.  Returns -1 if the array is empty.
d763 4
d789 1
a789 1
Perl's S<C<$#array = $fill;>>.
d791 2
a792 2
The number of elements in the array will be S<C<fill + 1>> after
C<av_fill()> returns.  If the array was previously shorter, then the
d794 1
a794 1
was longer, then the excess elements are freed.  S<C<av_fill(av, -1)>> is
d802 1
d845 2
a846 2
is returned.  Perl equivalent: S<C<my $elem = delete($myarray[$idx]);>> for the
non-C<G_DISCARD> version and a void-context S<C<delete($myarray[$idx]);>> for the
d854 1
a896 1
	AvARRAY(av)[key] = NULL;
d898 1
d903 2
d908 3
a910 7
    if(sv != NULL) {
	if (flags & G_DISCARD) {
	    SvREFCNT_dec_NN(sv);
	    return NULL;
	}
	else if (AvREAL(av))
	    sv_2mortal(sv);
d912 2
d923 1
a923 1
C<NULL>.
d932 1
d986 1
d1035 6
@


