head	1.2;
access;
symbols
	OPENBSD_5_5:1.1.1.1.0.48
	OPENBSD_5_5_BASE:1.1.1.1
	OPENBSD_5_4:1.1.1.1.0.44
	OPENBSD_5_4_BASE:1.1.1.1
	PERL_5_16_3:1.1.1.1
	OPENBSD_5_3:1.1.1.1.0.42
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.40
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.38
	OPENBSD_5_0:1.1.1.1.0.36
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.34
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.32
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.28
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2014.03.24.15.05.33;	author afresh1;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.11;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@/* A wrapper around strtol() and strtoul() to correct some
 * "out of bounds" cases that don't work well on at least UTS.
 * If a value is Larger than the max, strto[u]l should return
 * the max value, and set errno to ERANGE
 *  The same if a value is smaller than the min value (only
 * relevant for strtol(); not strtoul()), except the minimum
 * value is returned (and errno == ERANGE).
 */

#include	<ctype.h>
#include	<string.h>
#include	<sys/errno.h>
#include	<stdlib.h>

extern int	errno;

#undef	I32
#undef	U32

#define	I32	int
#define	U32	unsigned int

struct	base_info {
	char	*ValidChars;

	char	*Ulong_max_str;
	char	*Long_max_str;
	char	*Long_min_str;	/* Absolute value */

	int	Ulong_max_str_len;
	int	Long_max_str_len;
	int	Long_min_str_len;	/* Absolute value */

	U32	Ulong_max;
	I32	Long_max;
	I32	Long_min;	/* NOT Absolute value */
};
static struct	base_info Base_info[37];

static struct base_info Base_info_16 = {
	"0123456789abcdefABCDEF",
	"4294967295", "2147483648" /* <== ABS VAL */ , "2147483647",
	10, 10, 10,
	4294967295, 2147483647, - 2147483648,
};

static struct base_info Base_info_10 = {
	"0123456789",
	"4294967295", "2147483648" /* <== ABS VAL */ , "2147483647",
	10, 10, 10,
	4294967295, 2147483647, - 2147483648,
};

 /* Used eventually (if this is fully developed) to hold info
  * for processing bases 2-36.  So that we can just plug the
  * base in as a selector for its info, we sacrifice
  * Base_info[0] and Base_info[1] (unless they are used
  * at some point for special information).
  */

/* This may be replaced later by something more universal */
static void
init_Base_info()
{
	if(Base_info[10].ValidChars) return;
	Base_info[10] = Base_info_10;
	Base_info[16] = Base_info_16;
}

unsigned int
strtoul_wrap32(char *s, char **pEnd, int base)
{
	int	Len;
	int	isNegated = 0;
	char	*sOrig = s;

	init_Base_info();

	while(*s && isspace(*s)) ++s;

	if(*s == '-') {
		++isNegated;
		++s;
		while(*s && isspace(*s)) ++s;
	}
	if(base == 0) {
		if(*s == '0') {
			if(s[1] == 'x' || s[1] == 'X') {
				s += 2;
				base = 16;
			} else {
				++s;
				base = 8;
			}
		} else if(isdigit(*s)) {
			base = 10;
		}
	}
	if(base != 10) {
		return strtoul(sOrig, pEnd, base);
	}
	
	Len = strspn(s, Base_info[base].ValidChars);

	if(Len > Base_info[base].Ulong_max_str_len
		||
	   (Len == Base_info[base].Ulong_max_str_len
	   		&&
	    strncmp(Base_info[base].Ulong_max_str, s, Len) < 0)
	  ) {
		/* In case isNegated is set - what to do?? */
		/* Mightn't we say a negative number is ERANGE for strtoul? */
		errno = ERANGE;
		return Base_info[base].Ulong_max;
	}

	return strtoul(sOrig, pEnd, base);
}

int
strtol_wrap32(char *s, char **pEnd, int base)
{
	int	Len;
	int	isNegated = 0;
	char	*sOrig = s;

	init_Base_info();

	while(*s && isspace(*s)) ++s;

	if(*s == '-') {
		++isNegated;
		++s;
		while(*s && isspace(*s)) ++s;
	}
	if(base == 0) {
		if(*s == '0') {
			if(s[1] == 'x' || s[1] == 'X') {
				s += 2;
				base = 16;
			} else {
				++s;
				base = 8;
			}
		} else if(isdigit(*s)) {
			base = 10;
		}
	}
	if(base != 10) {
		return strtol(sOrig, pEnd, base);
	}
	
	Len = strspn(s, Base_info[base].ValidChars);

	if(Len > Base_info[base].Long_max_str_len
				||
	   (!isNegated && Len == Base_info[base].Long_max_str_len
	   	&&
	    strncmp(Base_info[base].Long_max_str, s, Len) < 0)
	    			||
	   (isNegated && Len == Base_info[base].Long_min_str_len
	   	&&
	    strncmp(Base_info[base].Long_min_str, s, Len) < 0)
	  ) {
		/* In case isNegated is set - what to do?? */
		/* Mightn't we say a negative number is ERANGE for strtol? */
		errno = ERANGE;
		return(isNegated ? Base_info[base].Long_min
					:
				   Base_info[base].Long_min);
	}

	return strtol(sOrig, pEnd, base);
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@
