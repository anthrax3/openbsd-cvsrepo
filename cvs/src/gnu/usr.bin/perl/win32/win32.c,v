head	1.18;
access;
symbols
	PERL_5_24_2:1.1.1.16
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.17.0.4
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.18
date	2017.02.05.00.32.22;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	cxJ08BvJA9Pt2PTM;

1.17
date	2016.07.03.01.08.05;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	GzHqjSTnBjdF7Wcw;

1.16
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.34;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.41.01;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.07.11;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.22;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.15;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.43;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.10.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.33.12;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.39;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.09.06;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.06.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.42.15;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.11.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.26.18;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.13;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.38;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.48;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.48.47;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.18.28;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.49.59;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.19.06;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.11.08;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.45;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.09.44;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.59.13;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.53.21;	author afresh1;	state Exp;
branches;
next	1.1.1.16;
commitid	B31cAbBIXiCqnL97;

1.1.1.16
date	2017.08.14.13.46.27;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.18
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* WIN32.C
 *
 * (c) 1995 Microsoft Corporation. All rights reserved.
 * 		Developed by hip communications inc.
 * Portions (c) 1993 Intergraph Corporation. All rights reserved.
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */
#define PERLIO_NOT_STDIO 0
#define WIN32_LEAN_AND_MEAN
#define WIN32IO_IS_STDIO
#include <tchar.h>

#ifdef __GNUC__
#  define Win32_Winsock
#endif

#ifndef _WIN32_WINNT
#  define _WIN32_WINNT 0x0500     /* needed for CreateHardlink() etc. */
#endif

#include <windows.h>

#ifndef HWND_MESSAGE
#  define HWND_MESSAGE ((HWND)-3)
#endif

#ifndef PROCESSOR_ARCHITECTURE_AMD64
#  define PROCESSOR_ARCHITECTURE_AMD64 9
#endif

#ifndef WC_NO_BEST_FIT_CHARS
#  define WC_NO_BEST_FIT_CHARS 0x00000400
#endif

#include <winnt.h>
#include <commctrl.h>
#include <tlhelp32.h>
#include <io.h>
#include <signal.h>

/* #include "config.h" */


#define PerlIO FILE

#include <sys/stat.h>
#include "EXTERN.h"
#include "perl.h"

#define NO_XSLOCKS
#define PERL_NO_GET_CONTEXT
#include "XSUB.h"

#include <fcntl.h>
#ifndef __GNUC__
/* assert.h conflicts with #define of assert in perl.h */
#  include <assert.h>
#endif

#include <string.h>
#include <stdarg.h>
#include <float.h>
#include <time.h>
#include <sys/utime.h>

#ifdef __GNUC__
/* Mingw32 defaults to globing command line
 * So we turn it off like this:
 */
int _CRT_glob = 0;
#endif

#if defined(__MINGW32__) && (__MINGW32_MAJOR_VERSION==1)	
/* Mingw32-1.1 is missing some prototypes */
START_EXTERN_C
FILE * _wfopen(LPCWSTR wszFileName, LPCWSTR wszMode);
FILE * _wfdopen(int nFd, LPCWSTR wszMode);
FILE * _freopen(LPCWSTR wszFileName, LPCWSTR wszMode, FILE * pOldStream);
int _flushall();
int _fcloseall();
END_EXTERN_C
#endif

#define EXECF_EXEC 1
#define EXECF_SPAWN 2
#define EXECF_SPAWN_NOWAIT 3

#if defined(PERL_IMPLICIT_SYS)
#  undef getlogin
#  define getlogin g_getlogin
#endif

/* VS2005 (MSC version 14) provides a mechanism to set an invalid
 * parameter handler.  This functionality is not available in the
 * 64-bit compiler from the Platform SDK, which unfortunately also
 * believes itself to be MSC version 14.
 *
 * There is no #define related to _set_invalid_parameter_handler(),
 * but we can check for one of the constants defined for
 * _set_abort_behavior(), which was introduced into stdlib.h at
 * the same time.
 */

#if _MSC_VER >= 1400 && defined(_WRITE_ABORT_MSG)
#  define SET_INVALID_PARAMETER_HANDLER
#endif

#ifdef SET_INVALID_PARAMETER_HANDLER
static BOOL	set_silent_invalid_parameter_handler(BOOL newvalue);
static void	my_invalid_parameter_handler(const wchar_t* expression,
			const wchar_t* function, const wchar_t* file,
			unsigned int line, uintptr_t pReserved);
#endif

#ifndef WIN32_NO_REGISTRY
static char*	get_regstr_from(HKEY hkey, const char *valuename, SV **svp);
static char*	get_regstr(const char *valuename, SV **svp);
#endif

static char*	get_emd_part(SV **prev_pathp, STRLEN *const len,
			char *trailing, ...);
static char*	win32_get_xlib(const char *pl,
			WIN32_NO_REGISTRY_M_(const char *xlib)
			const char *libname, STRLEN *const len);

static BOOL	has_shell_metachars(const char *ptr);
static long	tokenize(const char *str, char **dest, char ***destv);
static void	get_shell(void);
static char*	find_next_space(const char *s);
static int	do_spawn2(pTHX_ const char *cmd, int exectype);
static int	do_spawn2_handles(pTHX_ const char *cmd, int exectype,
                        const int *handles);
static int	do_spawnvp_handles(int mode, const char *cmdname,
                        const char * const *argv, const int *handles);
static PerlIO * do_popen(const char *mode, const char *command, IV narg,
			 SV **args);
static long	find_pid(pTHX_ int pid);
static void	remove_dead_process(long child);
static int	terminate_process(DWORD pid, HANDLE process_handle, int sig);
static int	my_killpg(int pid, int sig);
static int	my_kill(int pid, int sig);
static void	out_of_memory(void);
static char*	wstr_to_str(const wchar_t* wstr);
static long	filetime_to_clock(PFILETIME ft);
static BOOL	filetime_from_time(PFILETIME ft, time_t t);
static char*	create_command_line(char *cname, STRLEN clen,
				    const char * const *args);
static char*	qualified_path(const char *cmd, bool other_exts);
static void	ansify_path(void);
static LRESULT	win32_process_message(HWND hwnd, UINT msg,
			WPARAM wParam, LPARAM lParam);

#ifdef USE_ITHREADS
static long	find_pseudo_pid(pTHX_ int pid);
static void	remove_dead_pseudo_process(long child);
static HWND	get_hwnd_delay(pTHX, long child, DWORD tries);
#endif

#ifdef HAVE_INTERP_INTERN
static void	win32_csighandler(int sig);
#endif

START_EXTERN_C
HANDLE	w32_perldll_handle = INVALID_HANDLE_VALUE;
char	w32_module_name[MAX_PATH+1];
#ifdef WIN32_DYN_IOINFO_SIZE
Size_t	w32_ioinfo_size;/* avoid 0 extend op b4 mul, otherwise could be a U8 */
#endif
END_EXTERN_C

static OSVERSIONINFO g_osver = {0, 0, 0, 0, 0, ""};

#ifndef WIN32_NO_REGISTRY
/* initialized by Perl_win32_init/PERL_SYS_INIT */
static HKEY HKCU_Perl_hnd;
static HKEY HKLM_Perl_hnd;
#endif

#ifdef SET_INVALID_PARAMETER_HANDLER
static BOOL silent_invalid_parameter_handler = FALSE;

static BOOL
set_silent_invalid_parameter_handler(BOOL newvalue)
{
    BOOL oldvalue = silent_invalid_parameter_handler;
#  ifdef _DEBUG
    silent_invalid_parameter_handler = newvalue;
#  endif
    return oldvalue;
}

static void
my_invalid_parameter_handler(const wchar_t* expression,
    const wchar_t* function, 
    const wchar_t* file, 
    unsigned int line, 
    uintptr_t pReserved)
{
#  ifdef _DEBUG
    char* ansi_expression;
    char* ansi_function;
    char* ansi_file;
    if (silent_invalid_parameter_handler)
	return;
    ansi_expression = wstr_to_str(expression);
    ansi_function = wstr_to_str(function);
    ansi_file = wstr_to_str(file);
    fprintf(stderr, "Invalid parameter detected in function %s. "
                    "File: %s, line: %d\n", ansi_function, ansi_file, line);
    fprintf(stderr, "Expression: %s\n", ansi_expression);
    free(ansi_expression);
    free(ansi_function);
    free(ansi_file);
#  endif
}
#endif

EXTERN_C void
set_w32_module_name(void)
{
    /* this function may be called at DLL_PROCESS_ATTACH time */
    char* ptr;
    HMODULE module = (HMODULE)((w32_perldll_handle == INVALID_HANDLE_VALUE)
                               ? GetModuleHandle(NULL)
                               : w32_perldll_handle);

    WCHAR modulename[MAX_PATH];
    WCHAR fullname[MAX_PATH];
    char *ansi;

    DWORD (__stdcall *pfnGetLongPathNameW)(LPCWSTR, LPWSTR, DWORD) =
        (DWORD (__stdcall *)(LPCWSTR, LPWSTR, DWORD))
        GetProcAddress(GetModuleHandle("kernel32.dll"), "GetLongPathNameW");

    GetModuleFileNameW(module, modulename, sizeof(modulename)/sizeof(WCHAR));

    /* Make sure we get an absolute pathname in case the module was loaded
     * explicitly by LoadLibrary() with a relative path. */
    GetFullPathNameW(modulename, sizeof(fullname)/sizeof(WCHAR), fullname, NULL);

    /* Make sure we start with the long path name of the module because we
     * later scan for pathname components to match "5.xx" to locate
     * compatible sitelib directories, and the short pathname might mangle
     * this path segment (e.g. by removing the dot on NTFS to something
     * like "5xx~1.yy") */
    if (pfnGetLongPathNameW)
        pfnGetLongPathNameW(fullname, fullname, sizeof(fullname)/sizeof(WCHAR));

    /* remove \\?\ prefix */
    if (memcmp(fullname, L"\\\\?\\", 4*sizeof(WCHAR)) == 0)
        memmove(fullname, fullname+4, (wcslen(fullname+4)+1)*sizeof(WCHAR));

    ansi = win32_ansipath(fullname);
    my_strlcpy(w32_module_name, ansi, sizeof(w32_module_name));
    win32_free(ansi);

    /* normalize to forward slashes */
    ptr = w32_module_name;
    while (*ptr) {
	if (*ptr == '\\')
	    *ptr = '/';
	++ptr;
    }
}

#ifndef WIN32_NO_REGISTRY
/* *svp (if non-NULL) is expected to be POK (valid allocated SvPVX(*svp)) */
static char*
get_regstr_from(HKEY handle, const char *valuename, SV **svp)
{
    /* Retrieve a REG_SZ or REG_EXPAND_SZ from the registry */
    DWORD type;
    char *str = NULL;
    long retval;
    DWORD datalen;

    retval = RegQueryValueEx(handle, valuename, 0, &type, NULL, &datalen);
    if (retval == ERROR_SUCCESS
	&& (type == REG_SZ || type == REG_EXPAND_SZ))
    {
	dTHX;
	if (!*svp)
	    *svp = sv_2mortal(newSVpvs(""));
	SvGROW(*svp, datalen);
	retval = RegQueryValueEx(handle, valuename, 0, NULL,
				 (PBYTE)SvPVX(*svp), &datalen);
	if (retval == ERROR_SUCCESS) {
	    str = SvPVX(*svp);
	    SvCUR_set(*svp,datalen-1);
	}
    }
    return str;
}

/* *svp (if non-NULL) is expected to be POK (valid allocated SvPVX(*svp)) */
static char*
get_regstr(const char *valuename, SV **svp)
{
    char *str;
    if (HKCU_Perl_hnd) {
	str = get_regstr_from(HKCU_Perl_hnd, valuename, svp);
	if (!str)
	    goto try_HKLM;
    }
    else {
	try_HKLM:
	if (HKLM_Perl_hnd)
	    str = get_regstr_from(HKLM_Perl_hnd, valuename, svp);
	else
	    str = NULL;
    }
    return str;
}
#endif /* ifndef WIN32_NO_REGISTRY */

/* *prev_pathp (if non-NULL) is expected to be POK (valid allocated SvPVX(sv)) */
static char *
get_emd_part(SV **prev_pathp, STRLEN *const len, char *trailing_path, ...)
{
    char base[10];
    va_list ap;
    char mod_name[MAX_PATH+1];
    char *ptr;
    char *optr;
    char *strip;
    STRLEN baselen;

    va_start(ap, trailing_path);
    strip = va_arg(ap, char *);

    sprintf(base, "%d.%d", (int)PERL_REVISION, (int)PERL_VERSION);
    baselen = strlen(base);

    if (!*w32_module_name) {
	set_w32_module_name();
    }
    strcpy(mod_name, w32_module_name);
    ptr = strrchr(mod_name, '/');
    while (ptr && strip) {
        /* look for directories to skip back */
	optr = ptr;
	*ptr = '\0';
	ptr = strrchr(mod_name, '/');
	/* avoid stripping component if there is no slash,
	 * or it doesn't match ... */
	if (!ptr || stricmp(ptr+1, strip) != 0) {
	    /* ... but not if component matches m|5\.$patchlevel.*| */
	    if (!ptr || !(*strip == '5' && *(ptr+1) == '5'
			  && strncmp(strip, base, baselen) == 0
			  && strncmp(ptr+1, base, baselen) == 0))
	    {
		*optr = '/';
		ptr = optr;
	    }
	}
	strip = va_arg(ap, char *);
    }
    if (!ptr) {
	ptr = mod_name;
	*ptr++ = '.';
	*ptr = '/';
    }
    va_end(ap);
    strcpy(++ptr, trailing_path);

    /* only add directory if it exists */
    if (GetFileAttributes(mod_name) != (DWORD) -1) {
	/* directory exists */
	dTHX;
	if (!*prev_pathp)
	    *prev_pathp = sv_2mortal(newSVpvs(""));
	else if (SvPVX(*prev_pathp))
	    sv_catpvs(*prev_pathp, ";");
	sv_catpv(*prev_pathp, mod_name);
	if(len)
	    *len = SvCUR(*prev_pathp);
	return SvPVX(*prev_pathp);
    }

    return NULL;
}

EXTERN_C char *
win32_get_privlib(WIN32_NO_REGISTRY_M_(const char *pl) STRLEN *const len)
{
    char *stdlib = "lib";
    SV *sv = NULL;
#ifndef WIN32_NO_REGISTRY
    char buffer[MAX_PATH+1];

    /* $stdlib = $HKCU{"lib-$]"} || $HKLM{"lib-$]"} || $HKCU{"lib"} || $HKLM{"lib"} || "";  */
    sprintf(buffer, "%s-%s", stdlib, pl);
    if (!get_regstr(buffer, &sv))
	(void)get_regstr(stdlib, &sv);
#endif

    /* $stdlib .= ";$EMD/../../lib" */
    return get_emd_part(&sv, len, stdlib, ARCHNAME, "bin", NULL);
}

static char *
win32_get_xlib(const char *pl, WIN32_NO_REGISTRY_M_(const char *xlib)
	       const char *libname, STRLEN *const len)
{
#ifndef WIN32_NO_REGISTRY
    char regstr[40];
#endif
    char pathstr[MAX_PATH+1];
    SV *sv1 = NULL;
    SV *sv2 = NULL;

#ifndef WIN32_NO_REGISTRY
    /* $HKCU{"$xlib-$]"} || $HKLM{"$xlib-$]"} . ---; */
    sprintf(regstr, "%s-%s", xlib, pl);
    (void)get_regstr(regstr, &sv1);
#endif

    /* $xlib .=
     * ";$EMD/" . ((-d $EMD/../../../$]) ? "../../.." : "../.."). "/$libname/$]/lib";  */
    sprintf(pathstr, "%s/%s/lib", libname, pl);
    (void)get_emd_part(&sv1, NULL, pathstr, ARCHNAME, "bin", pl, NULL);

#ifndef WIN32_NO_REGISTRY
    /* $HKCU{$xlib} || $HKLM{$xlib} . ---; */
    (void)get_regstr(xlib, &sv2);
#endif

    /* $xlib .=
     * ";$EMD/" . ((-d $EMD/../../../$]) ? "../../.." : "../.."). "/$libname/lib";  */
    sprintf(pathstr, "%s/lib", libname);
    (void)get_emd_part(&sv2, NULL, pathstr, ARCHNAME, "bin", pl, NULL);

    if (!sv1 && !sv2)
	return NULL;
    if (!sv1) {
	sv1 = sv2;
    } else if (sv2) {
        dTHX;
	sv_catpv(sv1, ";");
	sv_catsv(sv1, sv2);
    }

    if (len)
	*len = SvCUR(sv1);
    return SvPVX(sv1);
}

EXTERN_C char *
win32_get_sitelib(const char *pl, STRLEN *const len)
{
    return win32_get_xlib(pl, WIN32_NO_REGISTRY_M_("sitelib") "site", len);
}

#ifndef PERL_VENDORLIB_NAME
#  define PERL_VENDORLIB_NAME	"vendor"
#endif

EXTERN_C char *
win32_get_vendorlib(const char *pl, STRLEN *const len)
{
    return win32_get_xlib(pl, WIN32_NO_REGISTRY_M_("vendorlib") PERL_VENDORLIB_NAME, len);
}

static BOOL
has_shell_metachars(const char *ptr)
{
    int inquote = 0;
    char quote = '\0';

    /*
     * Scan string looking for redirection (< or >) or pipe
     * characters (|) that are not in a quoted string.
     * Shell variable interpolation (%VAR%) can also happen inside strings.
     */
    while (*ptr) {
	switch(*ptr) {
	case '%':
	    return TRUE;
	case '\'':
	case '\"':
	    if (inquote) {
		if (quote == *ptr) {
		    inquote = 0;
		    quote = '\0';
		}
	    }
	    else {
		quote = *ptr;
		inquote++;
	    }
	    break;
	case '>':
	case '<':
	case '|':
	    if (!inquote)
		return TRUE;
	default:
	    break;
	}
	++ptr;
    }
    return FALSE;
}

#if !defined(PERL_IMPLICIT_SYS)
/* since the current process environment is being updated in util.c
 * the library functions will get the correct environment
 */
PerlIO *
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
{
    PERL_FLUSHALL_FOR_CHILD;
    return win32_popen(cmd, mode);
}

long
Perl_my_pclose(pTHX_ PerlIO *fp)
{
    return win32_pclose(fp);
}
#endif

DllExport unsigned long
win32_os_id(void)
{
    return (unsigned long)g_osver.dwPlatformId;
}

DllExport int
win32_getpid(void)
{
#ifdef USE_ITHREADS
    dTHX;
    if (w32_pseudo_id)
	return -((int)w32_pseudo_id);
#endif
    return _getpid();
}

/* Tokenize a string.  Words are null-separated, and the list
 * ends with a doubled null.  Any character (except null and
 * including backslash) may be escaped by preceding it with a
 * backslash (the backslash will be stripped).
 * Returns number of words in result buffer.
 */
static long
tokenize(const char *str, char **dest, char ***destv)
{
    char *retstart = NULL;
    char **retvstart = 0;
    int items = -1;
    if (str) {
	int slen = strlen(str);
	char *ret;
	char **retv;
	Newx(ret, slen+2, char);
	Newx(retv, (slen+3)/2, char*);

	retstart = ret;
	retvstart = retv;
	*retv = ret;
	items = 0;
	while (*str) {
	    *ret = *str++;
	    if (*ret == '\\' && *str)
		*ret = *str++;
	    else if (*ret == ' ') {
		while (*str == ' ')
		    str++;
		if (ret == retstart)
		    ret--;
		else {
		    *ret = '\0';
		    ++items;
		    if (*str)
			*++retv = ret+1;
		}
	    }
	    else if (!*str)
		++items;
	    ret++;
	}
	retvstart[items] = NULL;
	*ret++ = '\0';
	*ret = '\0';
    }
    *dest = retstart;
    *destv = retvstart;
    return items;
}

static void
get_shell(void)
{
    dTHX;
    if (!w32_perlshell_tokens) {
	/* we don't use COMSPEC here for two reasons:
	 *  1. the same reason perl on UNIX doesn't use SHELL--rampant and
	 *     uncontrolled unportability of the ensuing scripts.
	 *  2. PERL5SHELL could be set to a shell that may not be fit for
	 *     interactive use (which is what most programs look in COMSPEC
	 *     for).
	 */
	const char* defaultshell = "cmd.exe /x/d/c";
	const char *usershell = PerlEnv_getenv("PERL5SHELL");
	w32_perlshell_items = tokenize(usershell ? usershell : defaultshell,
				       &w32_perlshell_tokens,
				       &w32_perlshell_vec);
    }
}

int
Perl_do_aspawn(pTHX_ SV *really, SV **mark, SV **sp)
{
    char **argv;
    char *str;
    int status;
    int flag = P_WAIT;
    int index = 0;

    PERL_ARGS_ASSERT_DO_ASPAWN;

    if (sp <= mark)
	return -1;

    get_shell();
    Newx(argv, (sp - mark) + w32_perlshell_items + 2, char*);

    if (SvNIOKp(*(mark+1)) && !SvPOKp(*(mark+1))) {
	++mark;
	flag = SvIVx(*mark);
    }

    while (++mark <= sp) {
	if (*mark && (str = SvPV_nolen(*mark)))
	    argv[index++] = str;
	else
	    argv[index++] = "";
    }
    argv[index++] = 0;

    status = win32_spawnvp(flag,
			   (const char*)(really ? SvPV_nolen(really) : argv[0]),
			   (const char* const*)argv);

    if (status < 0 && (errno == ENOEXEC || errno == ENOENT)) {
	/* possible shell-builtin, invoke with shell */
	int sh_items;
	sh_items = w32_perlshell_items;
	while (--index >= 0)
	    argv[index+sh_items] = argv[index];
	while (--sh_items >= 0)
	    argv[sh_items] = w32_perlshell_vec[sh_items];

	status = win32_spawnvp(flag,
			       (const char*)(really ? SvPV_nolen(really) : argv[0]),
			       (const char* const*)argv);
    }

    if (flag == P_NOWAIT) {
	PL_statusvalue = -1;	/* >16bits hint for pp_system() */
    }
    else {
	if (status < 0) {
	    if (ckWARN(WARN_EXEC))
		Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't spawn \"%s\": %s", argv[0], strerror(errno));
	    status = 255 * 256;
	}
	else
	    status *= 256;
	PL_statusvalue = status;
    }
    Safefree(argv);
    return (status);
}

/* returns pointer to the next unquoted space or the end of the string */
static char*
find_next_space(const char *s)
{
    bool in_quotes = FALSE;
    while (*s) {
	/* ignore doubled backslashes, or backslash+quote */
	if (*s == '\\' && (s[1] == '\\' || s[1] == '"')) {
	    s += 2;
	}
	/* keep track of when we're within quotes */
	else if (*s == '"') {
	    s++;
	    in_quotes = !in_quotes;
	}
	/* break it up only at spaces that aren't in quotes */
	else if (!in_quotes && isSPACE(*s))
	    return (char*)s;
	else
	    s++;
    }
    return (char*)s;
}

static int
do_spawn2(pTHX_ const char *cmd, int exectype) {
    return do_spawn2_handles(aTHX_ cmd, exectype, NULL);
}

static int
do_spawn2_handles(pTHX_ const char *cmd, int exectype, const int *handles)
{
    char **a;
    char *s;
    char **argv;
    int status = -1;
    BOOL needToTry = TRUE;
    char *cmd2;

    /* Save an extra exec if possible. See if there are shell
     * metacharacters in it */
    if (!has_shell_metachars(cmd)) {
	Newx(argv, strlen(cmd) / 2 + 2, char*);
	Newx(cmd2, strlen(cmd) + 1, char);
	strcpy(cmd2, cmd);
	a = argv;
	for (s = cmd2; *s;) {
	    while (*s && isSPACE(*s))
		s++;
	    if (*s)
		*(a++) = s;
	    s = find_next_space(s);
	    if (*s)
		*s++ = '\0';
	}
	*a = NULL;
	if (argv[0]) {
	    switch (exectype) {
	    case EXECF_SPAWN:
		status = win32_spawnvp(P_WAIT, argv[0],
				       (const char* const*)argv);
		break;
	    case EXECF_SPAWN_NOWAIT:
		status = do_spawnvp_handles(P_NOWAIT, argv[0],
					    (const char* const*)argv, handles);
		break;
	    case EXECF_EXEC:
		status = win32_execvp(argv[0], (const char* const*)argv);
		break;
	    }
	    if (status != -1 || errno == 0)
		needToTry = FALSE;
	}
	Safefree(argv);
	Safefree(cmd2);
    }
    if (needToTry) {
	char **argv;
	int i = -1;
	get_shell();
	Newx(argv, w32_perlshell_items + 2, char*);
	while (++i < w32_perlshell_items)
	    argv[i] = w32_perlshell_vec[i];
	argv[i++] = (char *)cmd;
	argv[i] = NULL;
	switch (exectype) {
	case EXECF_SPAWN:
	    status = win32_spawnvp(P_WAIT, argv[0],
				   (const char* const*)argv);
	    break;
	case EXECF_SPAWN_NOWAIT:
	    status = do_spawnvp_handles(P_NOWAIT, argv[0],
					(const char* const*)argv, handles);
	    break;
	case EXECF_EXEC:
	    status = win32_execvp(argv[0], (const char* const*)argv);
	    break;
	}
	cmd = argv[0];
	Safefree(argv);
    }
    if (exectype == EXECF_SPAWN_NOWAIT) {
	PL_statusvalue = -1;	/* >16bits hint for pp_system() */
    }
    else {
	if (status < 0) {
	    if (ckWARN(WARN_EXEC))
		Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't %s \"%s\": %s",
		     (exectype == EXECF_EXEC ? "exec" : "spawn"),
		     cmd, strerror(errno));
	    status = 255 * 256;
	}
	else
	    status *= 256;
	PL_statusvalue = status;
    }
    return (status);
}

int
Perl_do_spawn(pTHX_ char *cmd)
{
    PERL_ARGS_ASSERT_DO_SPAWN;

    return do_spawn2(aTHX_ cmd, EXECF_SPAWN);
}

int
Perl_do_spawn_nowait(pTHX_ char *cmd)
{
    PERL_ARGS_ASSERT_DO_SPAWN_NOWAIT;

    return do_spawn2(aTHX_ cmd, EXECF_SPAWN_NOWAIT);
}

bool
Perl_do_exec(pTHX_ const char *cmd)
{
    PERL_ARGS_ASSERT_DO_EXEC;

    do_spawn2(aTHX_ cmd, EXECF_EXEC);
    return FALSE;
}

/* The idea here is to read all the directory names into a string table
 * (separated by nulls) and when one of the other dir functions is called
 * return the pointer to the current file name.
 */
DllExport DIR *
win32_opendir(const char *filename)
{
    dTHXa(NULL);
    DIR			*dirp;
    long		len;
    long		idx;
    char		scanname[MAX_PATH+3];
    WCHAR		wscanname[sizeof(scanname)];
    WIN32_FIND_DATAW	wFindData;
    char		buffer[MAX_PATH*2];
    BOOL		use_default;

    len = strlen(filename);
    if (len == 0) {
	errno = ENOENT;
	return NULL;
    }
    if (len > MAX_PATH) {
	errno = ENAMETOOLONG;
	return NULL;
    }

    /* Get us a DIR structure */
    Newxz(dirp, 1, DIR);

    /* Create the search pattern */
    strcpy(scanname, filename);

    /* bare drive name means look in cwd for drive */
    if (len == 2 && isALPHA(scanname[0]) && scanname[1] == ':') {
	scanname[len++] = '.';
	scanname[len++] = '/';
    }
    else if (scanname[len-1] != '/' && scanname[len-1] != '\\') {
	scanname[len++] = '/';
    }
    scanname[len++] = '*';
    scanname[len] = '\0';

    /* do the FindFirstFile call */
    MultiByteToWideChar(CP_ACP, 0, scanname, -1, wscanname, sizeof(wscanname)/sizeof(WCHAR));
    aTHXa(PERL_GET_THX);
    dirp->handle = FindFirstFileW(PerlDir_mapW(wscanname), &wFindData);

    if (dirp->handle == INVALID_HANDLE_VALUE) {
	DWORD err = GetLastError();
	/* FindFirstFile() fails on empty drives! */
	switch (err) {
	case ERROR_FILE_NOT_FOUND:
	    return dirp;
	case ERROR_NO_MORE_FILES:
	case ERROR_PATH_NOT_FOUND:
	    errno = ENOENT;
	    break;
	case ERROR_NOT_ENOUGH_MEMORY:
	    errno = ENOMEM;
	    break;
	default:
	    errno = EINVAL;
	    break;
	}
	Safefree(dirp);
	return NULL;
    }

    use_default = FALSE;
    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                        wFindData.cFileName, -1,
                        buffer, sizeof(buffer), NULL, &use_default);
    if (use_default && *wFindData.cAlternateFileName) {
        WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                            wFindData.cAlternateFileName, -1,
                            buffer, sizeof(buffer), NULL, NULL);
    }

    /* now allocate the first part of the string table for
     * the filenames that we find.
     */
    idx = strlen(buffer)+1;
    if (idx < 256)
	dirp->size = 256;
    else
	dirp->size = idx;
    Newx(dirp->start, dirp->size, char);
    strcpy(dirp->start, buffer);
    dirp->nfiles++;
    dirp->end = dirp->curr = dirp->start;
    dirp->end += idx;
    return dirp;
}


/* Readdir just returns the current string pointer and bumps the
 * string pointer to the nDllExport entry.
 */
DllExport struct direct *
win32_readdir(DIR *dirp)
{
    long         len;

    if (dirp->curr) {
	/* first set up the structure to return */
	len = strlen(dirp->curr);
	strcpy(dirp->dirstr.d_name, dirp->curr);
	dirp->dirstr.d_namlen = len;

	/* Fake an inode */
	dirp->dirstr.d_ino = dirp->curr - dirp->start;

	/* Now set up for the next call to readdir */
	dirp->curr += len + 1;
	if (dirp->curr >= dirp->end) {
	    BOOL res;
	    char buffer[MAX_PATH*2];

            if (dirp->handle == INVALID_HANDLE_VALUE) {
                res = 0;
            }
	    /* finding the next file that matches the wildcard
	     * (which should be all of them in this directory!).
	     */
	    else {
                WIN32_FIND_DATAW wFindData;
		res = FindNextFileW(dirp->handle, &wFindData);
		if (res) {
                    BOOL use_default = FALSE;
                    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                                        wFindData.cFileName, -1,
                                        buffer, sizeof(buffer), NULL, &use_default);
                    if (use_default && *wFindData.cAlternateFileName) {
                        WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                                            wFindData.cAlternateFileName, -1,
                                            buffer, sizeof(buffer), NULL, NULL);
                    }
                }
            }
	    if (res) {
		long endpos = dirp->end - dirp->start;
		long newsize = endpos + strlen(buffer) + 1;
		/* bump the string table size by enough for the
		 * new name and its null terminator */
		while (newsize > dirp->size) {
		    long curpos = dirp->curr - dirp->start;
		    dirp->size *= 2;
		    Renew(dirp->start, dirp->size, char);
		    dirp->curr = dirp->start + curpos;
		}
		strcpy(dirp->start + endpos, buffer);
		dirp->end = dirp->start + newsize;
		dirp->nfiles++;
	    }
	    else {
		dirp->curr = NULL;
                if (dirp->handle != INVALID_HANDLE_VALUE) {
                    FindClose(dirp->handle);
                    dirp->handle = INVALID_HANDLE_VALUE;
                }
            }
	}
	return &(dirp->dirstr);
    }
    else
	return NULL;
}

/* Telldir returns the current string pointer position */
DllExport long
win32_telldir(DIR *dirp)
{
    return dirp->curr ? (dirp->curr - dirp->start) : -1;
}


/* Seekdir moves the string pointer to a previously saved position
 * (returned by telldir).
 */
DllExport void
win32_seekdir(DIR *dirp, long loc)
{
    dirp->curr = loc == -1 ? NULL : dirp->start + loc;
}

/* Rewinddir resets the string pointer to the start */
DllExport void
win32_rewinddir(DIR *dirp)
{
    dirp->curr = dirp->start;
}

/* free the memory allocated by opendir */
DllExport int
win32_closedir(DIR *dirp)
{
    if (dirp->handle != INVALID_HANDLE_VALUE)
	FindClose(dirp->handle);
    Safefree(dirp->start);
    Safefree(dirp);
    return 1;
}

/* duplicate a open DIR* for interpreter cloning */
DllExport DIR *
win32_dirp_dup(DIR *const dirp, CLONE_PARAMS *const param)
{
    dVAR;
    PerlInterpreter *const from = param->proto_perl;
    PerlInterpreter *const to   = (PerlInterpreter *)PERL_GET_THX;

    long pos;
    DIR *dup;

    /* switch back to original interpreter because win32_readdir()
     * might Renew(dirp->start).
     */
    if (from != to) {
        PERL_SET_THX(from);
    }

    /* mark current position; read all remaining entries into the
     * cache, and then restore to current position.
     */
    pos = win32_telldir(dirp);
    while (win32_readdir(dirp)) {
        /* read all entries into cache */
    }
    win32_seekdir(dirp, pos);

    /* switch back to new interpreter to allocate new DIR structure */
    if (from != to) {
        PERL_SET_THX(to);
    }

    Newx(dup, 1, DIR);
    memcpy(dup, dirp, sizeof(DIR));

    Newx(dup->start, dirp->size, char);
    memcpy(dup->start, dirp->start, dirp->size);

    dup->end = dup->start + (dirp->end - dirp->start);
    if (dirp->curr)
        dup->curr = dup->start + (dirp->curr - dirp->start);

    return dup;
}

/*
 * various stubs
 */


/* Ownership
 *
 * Just pretend that everyone is a superuser. NT will let us know if
 * we don\'t really have permission to do something.
 */

#define ROOT_UID    ((uid_t)0)
#define ROOT_GID    ((gid_t)0)

uid_t
getuid(void)
{
    return ROOT_UID;
}

uid_t
geteuid(void)
{
    return ROOT_UID;
}

gid_t
getgid(void)
{
    return ROOT_GID;
}

gid_t
getegid(void)
{
    return ROOT_GID;
}

int
setuid(uid_t auid)
{
    return (auid == ROOT_UID ? 0 : -1);
}

int
setgid(gid_t agid)
{
    return (agid == ROOT_GID ? 0 : -1);
}

EXTERN_C char *
getlogin(void)
{
    dTHX;
    char *buf = w32_getlogin_buffer;
    DWORD size = sizeof(w32_getlogin_buffer);
    if (GetUserName(buf,&size))
	return buf;
    return (char*)NULL;
}

int
chown(const char *path, uid_t owner, gid_t group)
{
    /* XXX noop */
    return 0;
}

/*
 * XXX this needs strengthening  (for PerlIO)
 *   -- BKS, 11-11-200
*/
#if !defined(__MINGW64_VERSION_MAJOR) || __MINGW64_VERSION_MAJOR < 4
int mkstemp(const char *path)
{
    dTHX;
    char buf[MAX_PATH+1];
    int i = 0, fd = -1;

retry:
    if (i++ > 10) { /* give up */
	errno = ENOENT;
	return -1;
    }
    if (!GetTempFileNameA((LPCSTR)path, "plr", 1, buf)) {
	errno = ENOENT;
	return -1;
    }
    fd = PerlLIO_open3(buf, O_CREAT|O_RDWR|O_EXCL, 0600);
    if (fd == -1)
	goto retry;
    return fd;
}
#endif

static long
find_pid(pTHX_ int pid)
{
    long child = w32_num_children;
    while (--child >= 0) {
	if ((int)w32_child_pids[child] == pid)
	    return child;
    }
    return -1;
}

static void
remove_dead_process(long child)
{
    if (child >= 0) {
	dTHX;
	CloseHandle(w32_child_handles[child]);
	Move(&w32_child_handles[child+1], &w32_child_handles[child],
	     (w32_num_children-child-1), HANDLE);
	Move(&w32_child_pids[child+1], &w32_child_pids[child],
	     (w32_num_children-child-1), DWORD);
	w32_num_children--;
    }
}

#ifdef USE_ITHREADS
static long
find_pseudo_pid(pTHX_ int pid)
{
    long child = w32_num_pseudo_children;
    while (--child >= 0) {
	if ((int)w32_pseudo_child_pids[child] == pid)
	    return child;
    }
    return -1;
}

static void
remove_dead_pseudo_process(long child)
{
    if (child >= 0) {
	dTHX;
	CloseHandle(w32_pseudo_child_handles[child]);
	Move(&w32_pseudo_child_handles[child+1], &w32_pseudo_child_handles[child],
	     (w32_num_pseudo_children-child-1), HANDLE);
	Move(&w32_pseudo_child_pids[child+1], &w32_pseudo_child_pids[child],
	     (w32_num_pseudo_children-child-1), DWORD);
	Move(&w32_pseudo_child_message_hwnds[child+1], &w32_pseudo_child_message_hwnds[child],
	     (w32_num_pseudo_children-child-1), HWND);
	Move(&w32_pseudo_child_sigterm[child+1], &w32_pseudo_child_sigterm[child],
	     (w32_num_pseudo_children-child-1), char);
	w32_num_pseudo_children--;
    }
}

void
win32_wait_for_children(pTHX)
{
    if (w32_pseudo_children && w32_num_pseudo_children) {
        long child = 0;
        long count = 0;
        HANDLE handles[MAXIMUM_WAIT_OBJECTS];

        for (child = 0; child < w32_num_pseudo_children; ++child) {
            if (!w32_pseudo_child_sigterm[child])
                handles[count++] = w32_pseudo_child_handles[child];
        }
        /* XXX should use MsgWaitForMultipleObjects() to continue
         * XXX processing messages while we wait.
         */
        WaitForMultipleObjects(count, handles, TRUE, INFINITE);

        while (w32_num_pseudo_children)
            CloseHandle(w32_pseudo_child_handles[--w32_num_pseudo_children]);
    }
}
#endif

static int
terminate_process(DWORD pid, HANDLE process_handle, int sig)
{
    switch(sig) {
    case 0:
        /* "Does process exist?" use of kill */
        return 1;
    case 2:
        if (GenerateConsoleCtrlEvent(CTRL_C_EVENT, pid))
            return 1;
        break;
    case SIGBREAK:
    case SIGTERM:
        if (GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, pid))
            return 1;
        break;
    default: /* For now be backwards compatible with perl 5.6 */
    case 9:
        /* Note that we will only be able to kill processes owned by the
         * current process owner, even when we are running as an administrator.
         * To kill processes of other owners we would need to set the
         * 'SeDebugPrivilege' privilege before obtaining the process handle.
         */
        if (TerminateProcess(process_handle, sig))
            return 1;
        break;
    }
    return 0;
}

/* returns number of processes killed */
static int
my_killpg(int pid, int sig)
{
    HANDLE process_handle;
    HANDLE snapshot_handle;
    int killed = 0;

    process_handle = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
    if (process_handle == NULL)
        return 0;

    killed += terminate_process(pid, process_handle, sig);

    snapshot_handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot_handle != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32 entry;

        entry.dwSize = sizeof(entry);
        if (Process32First(snapshot_handle, &entry)) {
            do {
                if (entry.th32ParentProcessID == (DWORD)pid)
                    killed += my_killpg(entry.th32ProcessID, sig);
                entry.dwSize = sizeof(entry);
            }
            while (Process32Next(snapshot_handle, &entry));
        }
        CloseHandle(snapshot_handle);
    }
    CloseHandle(process_handle);
    return killed;
}

/* returns number of processes killed */
static int
my_kill(int pid, int sig)
{
    int retval = 0;
    HANDLE process_handle;

    if (sig < 0)
        return my_killpg(pid, -sig);

    process_handle = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
    /* OpenProcess() returns NULL on error, *not* INVALID_HANDLE_VALUE */
    if (process_handle != NULL) {
        retval = terminate_process(pid, process_handle, sig);
        CloseHandle(process_handle);
    }
    return retval;
}

#ifdef USE_ITHREADS
/* Get a child pseudo-process HWND, with retrying and delaying/yielding.
 * The "tries" parameter is the number of retries to make, with a Sleep(1)
 * (waiting and yielding the time slot) between each try. Specifying 0 causes
 * only Sleep(0) (no waiting and potentially no yielding) to be used, so is not
 * recommended
 * Returns an hwnd != INVALID_HANDLE_VALUE (so be aware that NULL can be
 * returned) or croaks if the child pseudo-process doesn't schedule and deliver
 * a HWND in the time period allowed.
 */
static HWND
get_hwnd_delay(pTHX, long child, DWORD tries)
{
    HWND hwnd = w32_pseudo_child_message_hwnds[child];
    if (hwnd != INVALID_HANDLE_VALUE) return hwnd;

    /* Pseudo-process has not yet properly initialized since hwnd isn't set.
     * Fast sleep: On some NT kernels/systems, a Sleep(0) won't deschedule a
     * thread 100% of the time since threads are attached to a CPU for NUMA and
     * caching reasons, and the child thread was attached to a different CPU
     * therefore there is no workload on that CPU and Sleep(0) returns control
     * without yielding the time slot.
     * https://rt.perl.org/rt3/Ticket/Display.html?id=88840
     */
    Sleep(0);
    win32_async_check(aTHX);
    hwnd = w32_pseudo_child_message_hwnds[child];
    if (hwnd != INVALID_HANDLE_VALUE) return hwnd;

    {
	unsigned int count = 0;
	/* No Sleep(1) if tries==0, just fail instead if we get this far. */
	while (count++ < tries) {
	    Sleep(1);
	    win32_async_check(aTHX);
	    hwnd = w32_pseudo_child_message_hwnds[child];
	    if (hwnd != INVALID_HANDLE_VALUE) return hwnd;
	}
    }

    Perl_croak(aTHX_ "panic: child pseudo-process was never scheduled");
}
#endif

DllExport int
win32_kill(int pid, int sig)
{
    dTHX;
    long child;
#ifdef USE_ITHREADS
    if (pid < 0) {
	/* it is a pseudo-forked child */
	child = find_pseudo_pid(aTHX_ -pid);
	if (child >= 0) {
	    HANDLE hProcess = w32_pseudo_child_handles[child];
	    switch (sig) {
		case 0:
		    /* "Does process exist?" use of kill */
		    return 0;

		case 9: {
		    /* kill -9 style un-graceful exit */
		    /* Do a wait to make sure child starts and isn't in DLL
		     * Loader Lock */
		    HWND hwnd = get_hwnd_delay(aTHX, child, 5);
		    if (TerminateThread(hProcess, sig)) {
			/* Allow the scheduler to finish cleaning up the other
			 * thread.
			 * Otherwise, if we ExitProcess() before another context
			 * switch happens we will end up with a process exit
			 * code of "sig" instead of our own exit status.
			 * https://rt.cpan.org/Ticket/Display.html?id=66016#txn-908976
			 */
			Sleep(0);
			remove_dead_pseudo_process(child);
			return 0;
		    }
		    break;
		}

		default: {
		    HWND hwnd = get_hwnd_delay(aTHX, child, 5);
		    /* We fake signals to pseudo-processes using Win32
		     * message queue. */
		    if ((hwnd != NULL && PostMessage(hwnd, WM_USER_KILL, sig, 0)) ||
			PostThreadMessage(-pid, WM_USER_KILL, sig, 0))
		    {
			/* Don't wait for child process to terminate after we send a
			 * SIGTERM because the child may be blocked in a system call
			 * and never receive the signal.
			 */
			if (sig == SIGTERM) {
			    Sleep(0);
			    w32_pseudo_child_sigterm[child] = 1;
			}
			/* It might be us ... */
			PERL_ASYNC_CHECK();
			return 0;
		    }
		    break;
		}
	    } /* switch */
	}
    }
    else
#endif
    {
	child = find_pid(aTHX_ pid);
	if (child >= 0) {
            if (my_kill(pid, sig)) {
                DWORD exitcode = 0;
                if (GetExitCodeProcess(w32_child_handles[child], &exitcode) &&
                    exitcode != STILL_ACTIVE)
                {
                    remove_dead_process(child);
                }
                return 0;
            }
	}
	else {
            if (my_kill(pid, sig))
                return 0;
	}
    }
    errno = EINVAL;
    return -1;
}

DllExport int
win32_stat(const char *path, Stat_t *sbuf)
{
    char	buffer[MAX_PATH+1];
    int		l = strlen(path);
    dTHX;
    int		res;
    int         nlink = 1;
    BOOL        expect_dir = FALSE;

    if (l > 1) {
	switch(path[l - 1]) {
	/* FindFirstFile() and stat() are buggy with a trailing
	 * slashes, except for the root directory of a drive */
	case '\\':
        case '/':
	    if (l > sizeof(buffer)) {
		errno = ENAMETOOLONG;
		return -1;
	    }
            --l;
            strncpy(buffer, path, l);
            /* remove additional trailing slashes */
            while (l > 1 && (buffer[l-1] == '/' || buffer[l-1] == '\\'))
                --l;
            /* add back slash if we otherwise end up with just a drive letter */
            if (l == 2 && isALPHA(buffer[0]) && buffer[1] == ':')
                buffer[l++] = '\\';
            buffer[l] = '\0';
            path = buffer;
            expect_dir = TRUE;
	    break;

	/* FindFirstFile() is buggy with "x:", so add a dot :-( */
	case ':':
	    if (l == 2 && isALPHA(path[0])) {
		buffer[0] = path[0];
		buffer[1] = ':';
		buffer[2] = '.';
		buffer[3] = '\0';
		l = 3;
		path = buffer;
	    }
	    break;
	}
    }

    path = PerlDir_mapA(path);
    l = strlen(path);

    if (!w32_sloppystat) {
        /* We must open & close the file once; otherwise file attribute changes  */
        /* might not yet have propagated to "other" hard links of the same file. */
        /* This also gives us an opportunity to determine the number of links.   */
        HANDLE handle = CreateFileA(path, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
        if (handle != INVALID_HANDLE_VALUE) {
            BY_HANDLE_FILE_INFORMATION bhi;
            if (GetFileInformationByHandle(handle, &bhi))
                nlink = bhi.nNumberOfLinks;
            CloseHandle(handle);
        }
	else {
	    DWORD err = GetLastError();
	    /* very common case, skip CRT stat and its also failing syscalls */
	    if(err == ERROR_FILE_NOT_FOUND) {
		errno = ENOENT;
		return -1;
	    }
	}
    }

    /* path will be mapped correctly above */
#if defined(WIN64) || defined(USE_LARGE_FILES)
    res = _stati64(path, sbuf);
#else
    res = stat(path, sbuf);
#endif
    sbuf->st_nlink = nlink;

    if (res < 0) {
	/* CRT is buggy on sharenames, so make sure it really isn't.
	 * XXX using GetFileAttributesEx() will enable us to set
	 * sbuf->st_*time (but note that's not available on the
	 * Windows of 1995) */
	DWORD r = GetFileAttributesA(path);
	if (r != 0xffffffff && (r & FILE_ATTRIBUTE_DIRECTORY)) {
	    /* sbuf may still contain old garbage since stat() failed */
	    Zero(sbuf, 1, Stat_t);
	    sbuf->st_mode = S_IFDIR | S_IREAD;
	    errno = 0;
	    if (!(r & FILE_ATTRIBUTE_READONLY))
		sbuf->st_mode |= S_IWRITE | S_IEXEC;
	    return 0;
	}
    }
    else {
	if (l == 3 && isALPHA(path[0]) && path[1] == ':'
	    && (path[2] == '\\' || path[2] == '/'))
	{
	    /* The drive can be inaccessible, some _stat()s are buggy */
	    if (!GetVolumeInformationA(path,NULL,0,NULL,NULL,NULL,NULL,0)) {
		errno = ENOENT;
		return -1;
	    }
	}
        if (expect_dir && !S_ISDIR(sbuf->st_mode)) {
            errno = ENOTDIR;
            return -1;
        }
	if (S_ISDIR(sbuf->st_mode)) {
	    /* Ensure the "write" bit is switched off in the mode for
	     * directories with the read-only attribute set. Some compilers
	     * switch it on for directories, which is technically correct
	     * (directories are indeed always writable unless denied by DACLs),
	     * but we want stat() and -w to reflect the state of the read-only
	     * attribute for symmetry with chmod(). */
	    DWORD r = GetFileAttributesA(path);
	    if (r != 0xffffffff && (r & FILE_ATTRIBUTE_READONLY)) {
		sbuf->st_mode &= ~S_IWRITE;
	    }
	}
    }
    return res;
}

#define isSLASH(c) ((c) == '/' || (c) == '\\')
#define SKIP_SLASHES(s) \
    STMT_START {				\
	while (*(s) && isSLASH(*(s)))		\
	    ++(s);				\
    } STMT_END
#define COPY_NONSLASHES(d,s) \
    STMT_START {				\
	while (*(s) && !isSLASH(*(s)))		\
	    *(d)++ = *(s)++;			\
    } STMT_END

/* Find the longname of a given path.  path is destructively modified.
 * It should have space for at least MAX_PATH characters. */
DllExport char *
win32_longpath(char *path)
{
    WIN32_FIND_DATA fdata;
    HANDLE fhand;
    char tmpbuf[MAX_PATH+1];
    char *tmpstart = tmpbuf;
    char *start = path;
    char sep;
    if (!path)
	return NULL;

    /* drive prefix */
    if (isALPHA(path[0]) && path[1] == ':') {
	start = path + 2;
	*tmpstart++ = path[0];
	*tmpstart++ = ':';
    }
    /* UNC prefix */
    else if (isSLASH(path[0]) && isSLASH(path[1])) {
	start = path + 2;
	*tmpstart++ = path[0];
	*tmpstart++ = path[1];
	SKIP_SLASHES(start);
	COPY_NONSLASHES(tmpstart,start);	/* copy machine name */
	if (*start) {
	    *tmpstart++ = *start++;
	    SKIP_SLASHES(start);
	    COPY_NONSLASHES(tmpstart,start);	/* copy share name */
	}
    }
    *tmpstart = '\0';
    while (*start) {
	/* copy initial slash, if any */
	if (isSLASH(*start)) {
	    *tmpstart++ = *start++;
	    *tmpstart = '\0';
	    SKIP_SLASHES(start);
	}

	/* FindFirstFile() expands "." and "..", so we need to pass
	 * those through unmolested */
	if (*start == '.'
	    && (!start[1] || isSLASH(start[1])
		|| (start[1] == '.' && (!start[2] || isSLASH(start[2])))))
	{
	    COPY_NONSLASHES(tmpstart,start);	/* copy "." or ".." */
	    *tmpstart = '\0';
	    continue;
	}

	/* if this is the end, bust outta here */
	if (!*start)
	    break;

	/* now we're at a non-slash; walk up to next slash */
	while (*start && !isSLASH(*start))
	    ++start;

	/* stop and find full name of component */
	sep = *start;
	*start = '\0';
	fhand = FindFirstFile(path,&fdata);
	*start = sep;
	if (fhand != INVALID_HANDLE_VALUE) {
	    STRLEN len = strlen(fdata.cFileName);
	    if ((STRLEN)(tmpbuf + sizeof(tmpbuf) - tmpstart) > len) {
		strcpy(tmpstart, fdata.cFileName);
		tmpstart += len;
		FindClose(fhand);
	    }
	    else {
		FindClose(fhand);
		errno = ERANGE;
		return NULL;
	    }
	}
	else {
	    /* failed a step, just return without side effects */
	    /*PerlIO_printf(Perl_debug_log, "Failed to find %s\n", path);*/
	    errno = EINVAL;
	    return NULL;
	}
    }
    strcpy(path,tmpbuf);
    return path;
}

static void
out_of_memory(void)
{
    if (PL_curinterp)
	croak_no_mem();
    exit(1);
}

void
win32_croak_not_implemented(const char * fname)
{
    PERL_ARGS_ASSERT_WIN32_CROAK_NOT_IMPLEMENTED;

    Perl_croak_nocontext("%s not implemented!\n", fname);
}

/* Converts a wide character (UTF-16) string to the Windows ANSI code page,
 * potentially using the system's default replacement character for any
 * unrepresentable characters. The caller must free() the returned string. */
static char*
wstr_to_str(const wchar_t* wstr)
{
    BOOL used_default = FALSE;
    size_t wlen = wcslen(wstr) + 1;
    int len = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, wstr, wlen,
                                   NULL, 0, NULL, NULL);
    char* str = (char*)malloc(len);
    if (!str)
        out_of_memory();
    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, wstr, wlen,
                        str, len, NULL, &used_default);
    return str;
}

/* The win32_ansipath() function takes a Unicode filename and converts it
 * into the current Windows codepage. If some characters cannot be mapped,
 * then it will convert the short name instead.
 *
 * The buffer to the ansi pathname must be freed with win32_free() when it
 * it no longer needed.
 *
 * The argument to win32_ansipath() must exist before this function is
 * called; otherwise there is no way to determine the short path name.
 *
 * Ideas for future refinement:
 * - Only convert those segments of the path that are not in the current
 *   codepage, but leave the other segments in their long form.
 * - If the resulting name is longer than MAX_PATH, start converting
 *   additional path segments into short names until the full name
 *   is shorter than MAX_PATH.  Shorten the filename part last!
 */
DllExport char *
win32_ansipath(const WCHAR *widename)
{
    char *name;
    BOOL use_default = FALSE;
    size_t widelen = wcslen(widename)+1;
    int len = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, widename, widelen,
                                  NULL, 0, NULL, NULL);
    name = (char*)win32_malloc(len);
    if (!name)
        out_of_memory();

    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, widename, widelen,
                        name, len, NULL, &use_default);
    if (use_default) {
        DWORD shortlen = GetShortPathNameW(widename, NULL, 0);
        if (shortlen) {
            WCHAR *shortname = (WCHAR*)win32_malloc(shortlen*sizeof(WCHAR));
            if (!shortname)
                out_of_memory();
            shortlen = GetShortPathNameW(widename, shortname, shortlen)+1;

            len = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, shortname, shortlen,
                                      NULL, 0, NULL, NULL);
            name = (char*)win32_realloc(name, len);
            if (!name)
                out_of_memory();
            WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, shortname, shortlen,
                                name, len, NULL, NULL);
            win32_free(shortname);
        }
    }
    return name;
}

/* the returned string must be freed with win32_freeenvironmentstrings which is
 * implemented as a macro
 * void win32_freeenvironmentstrings(void* block)
 */
DllExport char *
win32_getenvironmentstrings(void)
{
    LPWSTR lpWStr, lpWTmp;
    LPSTR lpStr, lpTmp;
    DWORD env_len, wenvstrings_len = 0, aenvstrings_len = 0;

    /* Get the process environment strings */
    lpWTmp = lpWStr = (LPWSTR) GetEnvironmentStringsW();
    for (wenvstrings_len = 1; *lpWTmp != '\0'; lpWTmp += env_len + 1) {
        env_len = wcslen(lpWTmp);
        /* calculate the size of the environment strings */
        wenvstrings_len += env_len + 1;
    }

    /* Get the number of bytes required to store the ACP encoded string */
    aenvstrings_len = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, 
                                          lpWStr, wenvstrings_len, NULL, 0, NULL, NULL);
    lpTmp = lpStr = (char *)win32_calloc(aenvstrings_len, sizeof(char));
    if(!lpTmp)
        out_of_memory();

    /* Convert the string from UTF-16 encoding to ACP encoding */
    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, lpWStr, wenvstrings_len, lpStr, 
                        aenvstrings_len, NULL, NULL);

    FreeEnvironmentStringsW(lpWStr);

    return(lpStr);
}

DllExport char *
win32_getenv(const char *name)
{
    dTHX;
    DWORD needlen;
    SV *curitem = NULL;
    DWORD last_err;

    needlen = GetEnvironmentVariableA(name,NULL,0);
    if (needlen != 0) {
	curitem = sv_2mortal(newSVpvs(""));
        do {
            SvGROW(curitem, needlen+1);
            needlen = GetEnvironmentVariableA(name,SvPVX(curitem),
                                              needlen);
        } while (needlen >= SvLEN(curitem));
        SvCUR_set(curitem, needlen);
    }
    else {
	last_err = GetLastError();
	if (last_err == ERROR_NOT_ENOUGH_MEMORY) {
	    /* It appears the variable is in the env, but the Win32 API
	       doesn't have a canned way of getting it.  So we fall back to
	       grabbing the whole env and pulling this value out if possible */
	    char *envv = GetEnvironmentStrings();
    	    char *cur = envv;
    	    STRLEN len;
    	    while (*cur) {
		char *end = strchr(cur,'=');
		if (end && end != cur) {
		    *end = '\0';
		    if (!strcmp(cur,name)) {
			curitem = sv_2mortal(newSVpv(end+1,0));
			*end = '=';
			break;
		    }
	    	    *end = '=';
	    	    cur = end + strlen(end+1)+2;
		}
		else if ((len = strlen(cur)))
	    	    cur += len+1;
    	    }
    	    FreeEnvironmentStrings(envv);
	}
#ifndef WIN32_NO_REGISTRY
	else {
	    /* last ditch: allow any environment variables that begin with 'PERL'
	       to be obtained from the registry, if found there */
	    if (strncmp(name, "PERL", 4) == 0)
		(void)get_regstr(name, &curitem);
	}
#endif
    }
    if (curitem && SvCUR(curitem))
	return SvPVX(curitem);

    return NULL;
}

DllExport int
win32_putenv(const char *name)
{
    char* curitem;
    char* val;
    int relval = -1;

    if (name) {
        curitem = (char *) win32_malloc(strlen(name)+1);
        strcpy(curitem, name);
        val = strchr(curitem, '=');
        if (val) {
            /* The sane way to deal with the environment.
             * Has these advantages over putenv() & co.:
             *  * enables us to store a truly empty value in the
             *    environment (like in UNIX).
             *  * we don't have to deal with RTL globals, bugs and leaks
             *    (specifically, see http://support.microsoft.com/kb/235601).
             *  * Much faster.
             * Why you may want to use the RTL environment handling
             * (previously enabled by USE_WIN32_RTL_ENV):
             *  * environ[] and RTL functions will not reflect changes,
             *    which might be an issue if extensions want to access
             *    the env. via RTL.  This cuts both ways, since RTL will
             *    not see changes made by extensions that call the Win32
             *    functions directly, either.
             * GSAR 97-06-07
             */
            *val++ = '\0';
            if (SetEnvironmentVariableA(curitem, *val ? val : NULL))
                relval = 0;
        }
        win32_free(curitem);
    }
    return relval;
}

static long
filetime_to_clock(PFILETIME ft)
{
    __int64 qw = ft->dwHighDateTime;
    qw <<= 32;
    qw |= ft->dwLowDateTime;
    qw /= 10000;  /* File time ticks at 0.1uS, clock at 1mS */
    return (long) qw;
}

DllExport int
win32_times(struct tms *timebuf)
{
    FILETIME user;
    FILETIME kernel;
    FILETIME dummy;
    clock_t process_time_so_far = clock();
    if (GetProcessTimes(GetCurrentProcess(), &dummy, &dummy,
                        &kernel,&user)) {
	timebuf->tms_utime = filetime_to_clock(&user);
	timebuf->tms_stime = filetime_to_clock(&kernel);
	timebuf->tms_cutime = 0;
	timebuf->tms_cstime = 0;
    } else {
        /* That failed - e.g. Win95 fallback to clock() */
	timebuf->tms_utime = process_time_so_far;
	timebuf->tms_stime = 0;
	timebuf->tms_cutime = 0;
	timebuf->tms_cstime = 0;
    }
    return process_time_so_far;
}

/* fix utime() so it works on directories in NT */
static BOOL
filetime_from_time(PFILETIME pFileTime, time_t Time)
{
    struct tm *pTM = localtime(&Time);
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    if (pTM == NULL)
	return FALSE;

    SystemTime.wYear   = pTM->tm_year + 1900;
    SystemTime.wMonth  = pTM->tm_mon + 1;
    SystemTime.wDay    = pTM->tm_mday;
    SystemTime.wHour   = pTM->tm_hour;
    SystemTime.wMinute = pTM->tm_min;
    SystemTime.wSecond = pTM->tm_sec;
    SystemTime.wMilliseconds = 0;

    return SystemTimeToFileTime(&SystemTime, &LocalTime) &&
           LocalFileTimeToFileTime(&LocalTime, pFileTime);
}

DllExport int
win32_unlink(const char *filename)
{
    dTHX;
    int ret;
    DWORD attrs;

    filename = PerlDir_mapA(filename);
    attrs = GetFileAttributesA(filename);
    if (attrs == 0xFFFFFFFF) {
        errno = ENOENT;
        return -1;
    }
    if (attrs & FILE_ATTRIBUTE_READONLY) {
        (void)SetFileAttributesA(filename, attrs & ~FILE_ATTRIBUTE_READONLY);
        ret = unlink(filename);
        if (ret == -1)
            (void)SetFileAttributesA(filename, attrs);
    }
    else
        ret = unlink(filename);
    return ret;
}

DllExport int
win32_utime(const char *filename, struct utimbuf *times)
{
    dTHX;
    HANDLE handle;
    FILETIME ftCreate;
    FILETIME ftAccess;
    FILETIME ftWrite;
    struct utimbuf TimeBuffer;
    int rc;

    filename = PerlDir_mapA(filename);
    rc = utime(filename, times);

    /* EACCES: path specifies directory or readonly file */
    if (rc == 0 || errno != EACCES)
	return rc;

    if (times == NULL) {
	times = &TimeBuffer;
	time(&times->actime);
	times->modtime = times->actime;
    }

    /* This will (and should) still fail on readonly files */
    handle = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
                         OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (handle == INVALID_HANDLE_VALUE)
	return rc;

    if (GetFileTime(handle, &ftCreate, &ftAccess, &ftWrite) &&
	filetime_from_time(&ftAccess, times->actime) &&
	filetime_from_time(&ftWrite, times->modtime) &&
	SetFileTime(handle, &ftCreate, &ftAccess, &ftWrite))
    {
	rc = 0;
    }

    CloseHandle(handle);
    return rc;
}

typedef union {
    unsigned __int64	ft_i64;
    FILETIME		ft_val;
} FT_t;

#ifdef __GNUC__
#define Const64(x) x##LL
#else
#define Const64(x) x##i64
#endif
/* Number of 100 nanosecond units from 1/1/1601 to 1/1/1970 */
#define EPOCH_BIAS  Const64(116444736000000000)

/* NOTE: This does not compute the timezone info (doing so can be expensive,
 * and appears to be unsupported even by glibc) */
DllExport int
win32_gettimeofday(struct timeval *tp, void *not_used)
{
    FT_t ft;

    /* this returns time in 100-nanosecond units  (i.e. tens of usecs) */
    GetSystemTimeAsFileTime(&ft.ft_val);

    /* seconds since epoch */
    tp->tv_sec = (long)((ft.ft_i64 - EPOCH_BIAS) / Const64(10000000));

    /* microseconds remaining */
    tp->tv_usec = (long)((ft.ft_i64 / Const64(10)) % Const64(1000000));

    return 0;
}

DllExport int
win32_uname(struct utsname *name)
{
    struct hostent *hep;
    STRLEN nodemax = sizeof(name->nodename)-1;

    /* sysname */
    switch (g_osver.dwPlatformId) {
    case VER_PLATFORM_WIN32_WINDOWS:
        strcpy(name->sysname, "Windows");
        break;
    case VER_PLATFORM_WIN32_NT:
        strcpy(name->sysname, "Windows NT");
        break;
    case VER_PLATFORM_WIN32s:
        strcpy(name->sysname, "Win32s");
        break;
    default:
        strcpy(name->sysname, "Win32 Unknown");
        break;
    }

    /* release */
    sprintf(name->release, "%d.%d",
            g_osver.dwMajorVersion, g_osver.dwMinorVersion);

    /* version */
    sprintf(name->version, "Build %d",
            g_osver.dwPlatformId == VER_PLATFORM_WIN32_NT
            ? g_osver.dwBuildNumber : (g_osver.dwBuildNumber & 0xffff));
    if (g_osver.szCSDVersion[0]) {
        char *buf = name->version + strlen(name->version);
        sprintf(buf, " (%s)", g_osver.szCSDVersion);
    }

    /* nodename */
    hep = win32_gethostbyname("localhost");
    if (hep) {
	STRLEN len = strlen(hep->h_name);
	if (len <= nodemax) {
	    strcpy(name->nodename, hep->h_name);
	}
	else {
	    strncpy(name->nodename, hep->h_name, nodemax);
	    name->nodename[nodemax] = '\0';
	}
    }
    else {
	DWORD sz = nodemax;
	if (!GetComputerName(name->nodename, &sz))
	    *name->nodename = '\0';
    }

    /* machine (architecture) */
    {
	SYSTEM_INFO info;
	DWORD procarch;
	char *arch;
	GetSystemInfo(&info);

#if (defined(__MINGW32__) && !defined(_ANONYMOUS_UNION) && !defined(__MINGW_EXTENSION))
	procarch = info.u.s.wProcessorArchitecture;
#else
	procarch = info.wProcessorArchitecture;
#endif
	switch (procarch) {
	case PROCESSOR_ARCHITECTURE_INTEL:
	    arch = "x86"; break;
	case PROCESSOR_ARCHITECTURE_IA64:
	    arch = "ia64"; break;
	case PROCESSOR_ARCHITECTURE_AMD64:
	    arch = "amd64"; break;
	case PROCESSOR_ARCHITECTURE_UNKNOWN:
	    arch = "unknown"; break;
	default:
	    sprintf(name->machine, "unknown(0x%x)", procarch);
	    arch = name->machine;
	    break;
	}
	if (name->machine != arch)
	    strcpy(name->machine, arch);
    }
    return 0;
}

/* Timing related stuff */

int
do_raise(pTHX_ int sig) 
{
    if (sig < SIG_SIZE) {
	Sighandler_t handler = w32_sighandler[sig];
	if (handler == SIG_IGN) {
	    return 0;
	}
	else if (handler != SIG_DFL) {
	    (*handler)(sig);
	    return 0;
	}
	else {
	    /* Choose correct default behaviour */
	    switch (sig) {
#ifdef SIGCLD
		case SIGCLD:
#endif
#ifdef SIGCHLD
		case SIGCHLD:
#endif
		case 0:
		    return 0;
		case SIGTERM:
		default:
		    break;
	    }
	}
    }
    /* Tell caller to exit thread/process as appropriate */
    return 1;
}

void
sig_terminate(pTHX_ int sig)
{
    Perl_warn(aTHX_ "Terminating on signal SIG%s(%d)\n",PL_sig_name[sig], sig);
    /* exit() seems to be safe, my_exit() or die() is a problem in ^C 
       thread 
     */
    exit(sig);
}

DllExport int
win32_async_check(pTHX)
{
    MSG msg;
    HWND hwnd = w32_message_hwnd;

    /* Reset w32_poll_count before doing anything else, incase we dispatch
     * messages that end up calling back into perl */
    w32_poll_count = 0;

    if (hwnd != INVALID_HANDLE_VALUE) {
        /* Passing PeekMessage -1 as HWND (2nd arg) only gets PostThreadMessage() messages
        * and ignores window messages - should co-exist better with windows apps e.g. Tk
        */
        if (hwnd == NULL)
            hwnd = (HWND)-1;

        while (PeekMessage(&msg, hwnd, WM_TIMER,    WM_TIMER,    PM_REMOVE|PM_NOYIELD) ||
               PeekMessage(&msg, hwnd, WM_USER_MIN, WM_USER_MAX, PM_REMOVE|PM_NOYIELD))
        {
            /* re-post a WM_QUIT message (we'll mark it as read later) */
            if(msg.message == WM_QUIT) {
                PostQuitMessage((int)msg.wParam);
                break;
            }

            if(!CallMsgFilter(&msg, MSGF_USER))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

    /* Call PeekMessage() to mark all pending messages in the queue as "old".
     * This is necessary when we are being called by win32_msgwait() to
     * make sure MsgWaitForMultipleObjects() stops reporting the same waiting
     * message over and over.  An example how this can happen is when
     * Perl is calling win32_waitpid() inside a GUI application and the GUI
     * is generating messages before the process terminated.
     */
    PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE|PM_NOYIELD);

    /* Above or other stuff may have set a signal flag */
    if (PL_sig_pending)
        despatch_signals();
    
    return 1;
}

/* This function will not return until the timeout has elapsed, or until
 * one of the handles is ready. */
DllExport DWORD
win32_msgwait(pTHX_ DWORD count, LPHANDLE handles, DWORD timeout, LPDWORD resultp)
{
    /* We may need several goes at this - so compute when we stop */
    FT_t ticks = {0};
    unsigned __int64 endtime = timeout;
    if (timeout != INFINITE) {
	GetSystemTimeAsFileTime(&ticks.ft_val);
	ticks.ft_i64 /= 10000;
	endtime += ticks.ft_i64;
    }
    /* This was a race condition. Do not let a non INFINITE timeout to
     * MsgWaitForMultipleObjects roll under 0 creating a near
     * infinity/~(UINT32)0 timeout which will appear as a deadlock to the
     * user who did a CORE perl function with a non infinity timeout,
     * sleep for example.  This is 64 to 32 truncation minefield.
     *
     * This scenario can only be created if the timespan from the return of
     * MsgWaitForMultipleObjects to GetSystemTimeAsFileTime exceeds 1 ms. To
     * generate the scenario, manual breakpoints in a C debugger are required,
     * or a context switch occurred in win32_async_check in PeekMessage, or random
     * messages are delivered to the *thread* message queue of the Perl thread
     * from another process (msctf.dll doing IPC among its instances, VS debugger
     * causes msctf.dll to be loaded into Perl by kernel), see [perl #33096].
     */
    while (ticks.ft_i64 <= endtime) {
	/* if timeout's type is lengthened, remember to split 64b timeout
	 * into multiple non-infinity runs of MWFMO */
	DWORD result = MsgWaitForMultipleObjects(count, handles, FALSE,
						(DWORD)(endtime - ticks.ft_i64),
						QS_POSTMESSAGE|QS_TIMER|QS_SENDMESSAGE);
	if (resultp)
	   *resultp = result;
	if (result == WAIT_TIMEOUT) {
	    /* Ran out of time - explicit return of zero to avoid -ve if we
	       have scheduling issues
             */
	    return 0;
	}
	if (timeout != INFINITE) {
	    GetSystemTimeAsFileTime(&ticks.ft_val);
	    ticks.ft_i64 /= 10000;
	}
	if (result == WAIT_OBJECT_0 + count) {
	    /* Message has arrived - check it */
	    (void)win32_async_check(aTHX);
	}
	else {
	   /* Not timeout or message - one of handles is ready */
	   break;
	}
    }
    /* If we are past the end say zero */
    if (!ticks.ft_i64 || ticks.ft_i64 > endtime)
	return 0;
    /* compute time left to wait */
    ticks.ft_i64 = endtime - ticks.ft_i64;
    /* if more ms than DWORD, then return max DWORD */
    return ticks.ft_i64 <= UINT_MAX ? (DWORD)ticks.ft_i64 : UINT_MAX;
}

int
win32_internal_wait(pTHX_ int *status, DWORD timeout)
{
    /* XXX this wait emulation only knows about processes
     * spawned via win32_spawnvp(P_NOWAIT, ...).
     */
    int i, retval;
    DWORD exitcode, waitcode;

#ifdef USE_ITHREADS
    if (w32_num_pseudo_children) {
	win32_msgwait(aTHX_ w32_num_pseudo_children, w32_pseudo_child_handles,
		      timeout, &waitcode);
        /* Time out here if there are no other children to wait for. */
	if (waitcode == WAIT_TIMEOUT) {
	    if (!w32_num_children) {
		return 0;
	    }
	}
	else if (waitcode != WAIT_FAILED) {
	    if (waitcode >= WAIT_ABANDONED_0
		&& waitcode < WAIT_ABANDONED_0 + w32_num_pseudo_children)
		i = waitcode - WAIT_ABANDONED_0;
	    else
		i = waitcode - WAIT_OBJECT_0;
	    if (GetExitCodeThread(w32_pseudo_child_handles[i], &exitcode)) {
		*status = (int)((exitcode & 0xff) << 8);
		retval = (int)w32_pseudo_child_pids[i];
		remove_dead_pseudo_process(i);
		return -retval;
	    }
	}
    }
#endif

    if (!w32_num_children) {
	errno = ECHILD;
	return -1;
    }

    /* if a child exists, wait for it to die */
    win32_msgwait(aTHX_ w32_num_children, w32_child_handles, timeout, &waitcode);
    if (waitcode == WAIT_TIMEOUT) {
	return 0;
    }
    if (waitcode != WAIT_FAILED) {
	if (waitcode >= WAIT_ABANDONED_0
	    && waitcode < WAIT_ABANDONED_0 + w32_num_children)
	    i = waitcode - WAIT_ABANDONED_0;
	else
	    i = waitcode - WAIT_OBJECT_0;
	if (GetExitCodeProcess(w32_child_handles[i], &exitcode) ) {
	    *status = (int)((exitcode & 0xff) << 8);
	    retval = (int)w32_child_pids[i];
	    remove_dead_process(i);
	    return retval;
	}
    }

    errno = GetLastError();
    return -1;
}

DllExport int
win32_waitpid(int pid, int *status, int flags)
{
    dTHX;
    DWORD timeout = (flags & WNOHANG) ? 0 : INFINITE;
    int retval = -1;
    long child;
    if (pid == -1)				/* XXX threadid == 1 ? */
	return win32_internal_wait(aTHX_ status, timeout);
#ifdef USE_ITHREADS
    else if (pid < 0) {
	child = find_pseudo_pid(aTHX_ -pid);
	if (child >= 0) {
	    HANDLE hThread = w32_pseudo_child_handles[child];
	    DWORD waitcode;
	    win32_msgwait(aTHX_ 1, &hThread, timeout, &waitcode);
	    if (waitcode == WAIT_TIMEOUT) {
		return 0;
	    }
	    else if (waitcode == WAIT_OBJECT_0) {
		if (GetExitCodeThread(hThread, &waitcode)) {
		    *status = (int)((waitcode & 0xff) << 8);
		    retval = (int)w32_pseudo_child_pids[child];
		    remove_dead_pseudo_process(child);
		    return -retval;
		}
	    }
	    else
		errno = ECHILD;
	}
    }
#endif
    else {
	HANDLE hProcess;
	DWORD waitcode;
	child = find_pid(aTHX_ pid);
	if (child >= 0) {
	    hProcess = w32_child_handles[child];
	    win32_msgwait(aTHX_ 1, &hProcess, timeout, &waitcode);
	    if (waitcode == WAIT_TIMEOUT) {
		return 0;
	    }
	    else if (waitcode == WAIT_OBJECT_0) {
		if (GetExitCodeProcess(hProcess, &waitcode)) {
		    *status = (int)((waitcode & 0xff) << 8);
		    retval = (int)w32_child_pids[child];
		    remove_dead_process(child);
		    return retval;
		}
	    }
	    else
		errno = ECHILD;
	}
	else {
	    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pid);
	    if (hProcess) {
		win32_msgwait(aTHX_ 1, &hProcess, timeout, &waitcode);
		if (waitcode == WAIT_TIMEOUT) {
                    CloseHandle(hProcess);
		    return 0;
		}
		else if (waitcode == WAIT_OBJECT_0) {
		    if (GetExitCodeProcess(hProcess, &waitcode)) {
			*status = (int)((waitcode & 0xff) << 8);
			CloseHandle(hProcess);
			return pid;
		    }
		}
		CloseHandle(hProcess);
	    }
	    else
		errno = ECHILD;
	}
    }
    return retval >= 0 ? pid : retval;
}

DllExport int
win32_wait(int *status)
{
    dTHX;
    return win32_internal_wait(aTHX_ status, INFINITE);
}

DllExport unsigned int
win32_sleep(unsigned int t)
{
    dTHX;
    /* Win32 times are in ms so *1000 in and /1000 out */
    if (t > UINT_MAX / 1000) {
	Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
			"sleep(%lu) too large", t);
    }
    return win32_msgwait(aTHX_ 0, NULL, t * 1000, NULL) / 1000;
}

DllExport unsigned int
win32_alarm(unsigned int sec)
{
    /*
     * the 'obvious' implentation is SetTimer() with a callback
     * which does whatever receiving SIGALRM would do
     * we cannot use SIGALRM even via raise() as it is not
     * one of the supported codes in <signal.h>
     */
    dTHX;

    if (w32_message_hwnd == INVALID_HANDLE_VALUE)
        w32_message_hwnd = win32_create_message_window();

    if (sec) {
        if (w32_message_hwnd == NULL)
            w32_timerid = SetTimer(NULL, w32_timerid, sec*1000, NULL);
        else {
  	    w32_timerid = 1;
            SetTimer(w32_message_hwnd, w32_timerid, sec*1000, NULL);
        }
    }
    else {
    	if (w32_timerid) {
            KillTimer(w32_message_hwnd, w32_timerid);
  	    w32_timerid = 0;
    	}
    }
    return 0;
}

extern char *	des_fcrypt(const char *txt, const char *salt, char *cbuf);

DllExport char *
win32_crypt(const char *txt, const char *salt)
{
    dTHX;
    return des_fcrypt(txt, salt, w32_crypt_buffer);
}

/* simulate flock by locking a range on the file */

#define LK_LEN		0xffff0000

DllExport int
win32_flock(int fd, int oper)
{
    OVERLAPPED o;
    int i = -1;
    HANDLE fh;

    fh = (HANDLE)_get_osfhandle(fd);
    if (fh == (HANDLE)-1)  /* _get_osfhandle() already sets errno to EBADF */
        return -1;

    memset(&o, 0, sizeof(o));

    switch(oper) {
    case LOCK_SH:		/* shared lock */
	if (LockFileEx(fh, 0, 0, LK_LEN, 0, &o))
            i = 0;
	break;
    case LOCK_EX:		/* exclusive lock */
	if (LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK, 0, LK_LEN, 0, &o))
            i = 0;
	break;
    case LOCK_SH|LOCK_NB:	/* non-blocking shared lock */
	if (LockFileEx(fh, LOCKFILE_FAIL_IMMEDIATELY, 0, LK_LEN, 0, &o))
            i = 0;
	break;
    case LOCK_EX|LOCK_NB:	/* non-blocking exclusive lock */
	if (LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK|LOCKFILE_FAIL_IMMEDIATELY,
		       0, LK_LEN, 0, &o))
            i = 0;
	break;
    case LOCK_UN:		/* unlock lock */
	if (UnlockFileEx(fh, 0, LK_LEN, 0, &o))
            i = 0;
	break;
    default:			/* unknown */
	errno = EINVAL;
	return -1;
    }
    if (i == -1) {
        if (GetLastError() == ERROR_LOCK_VIOLATION)
            errno = EWOULDBLOCK;
        else
            errno = EINVAL;
    }
    return i;
}

#undef LK_LEN

extern int convert_wsa_error_to_errno(int wsaerr); /* in win32sck.c */

/* Get the errno value corresponding to the given err. This function is not
 * intended to handle conversion of general GetLastError() codes. It only exists
 * to translate Windows sockets error codes from WSAGetLastError(). Such codes
 * used to be assigned to errno/$! in earlier versions of perl; this function is
 * used to catch any old Perl code which is still trying to assign such values
 * to $! and convert them to errno values instead.
 */
int
win32_get_errno(int err)
{
    return convert_wsa_error_to_errno(err);
}

/*
 *  redirected io subsystem for all XS modules
 *
 */

DllExport int *
win32_errno(void)
{
    return (&errno);
}

DllExport char ***
win32_environ(void)
{
    return (&(_environ));
}

/* the rest are the remapped stdio routines */
DllExport FILE *
win32_stderr(void)
{
    return (stderr);
}

DllExport FILE *
win32_stdin(void)
{
    return (stdin);
}

DllExport FILE *
win32_stdout(void)
{
    return (stdout);
}

DllExport int
win32_ferror(FILE *fp)
{
    return (ferror(fp));
}


DllExport int
win32_feof(FILE *fp)
{
    return (feof(fp));
}

#ifdef ERRNO_HAS_POSIX_SUPPLEMENT
extern int convert_errno_to_wsa_error(int err); /* in win32sck.c */
#endif

/*
 * Since the errors returned by the socket error function
 * WSAGetLastError() are not known by the library routine strerror
 * we have to roll our own to cover the case of socket errors
 * that could not be converted to regular errno values by
 * get_last_socket_error() in win32/win32sck.c.
 */

DllExport char *
win32_strerror(int e)
{
#if !defined __MINGW32__      /* compiler intolerance */
    extern int sys_nerr;
#endif

    if (e < 0 || e > sys_nerr) {
        dTHXa(NULL);
	if (e < 0)
	    e = GetLastError();
#ifdef ERRNO_HAS_POSIX_SUPPLEMENT
	/* VC10+ and some MinGW/gcc-4.8+ define a "POSIX supplement" of errno
	 * values ranging from EADDRINUSE (100) to EWOULDBLOCK (140), but
	 * sys_nerr is still 43 and strerror() returns "Unknown error" for them.
	 * We must therefore still roll our own messages for these codes, and
	 * additionally map them to corresponding Windows (sockets) error codes
	 * first to avoid getting the wrong system message.
	 */
	else if (e >= EADDRINUSE && e <= EWOULDBLOCK) {
	    e = convert_errno_to_wsa_error(e);
	}
#endif

	aTHXa(PERL_GET_THX);
	if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                         |FORMAT_MESSAGE_IGNORE_INSERTS, NULL, e, 0,
			  w32_strerror_buffer, sizeof(w32_strerror_buffer),
                          NULL) == 0)
        {
	    strcpy(w32_strerror_buffer, "Unknown Error");
        }
	return w32_strerror_buffer;
    }
#undef strerror
    return strerror(e);
#define strerror win32_strerror
}

DllExport void
win32_str_os_error(void *sv, DWORD dwErr)
{
    DWORD dwLen;
    char *sMsg;
    dwLen = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER
			  |FORMAT_MESSAGE_IGNORE_INSERTS
			  |FORMAT_MESSAGE_FROM_SYSTEM, NULL,
			   dwErr, 0, (char *)&sMsg, 1, NULL);
    /* strip trailing whitespace and period */
    if (0 < dwLen) {
	do {
	    --dwLen;	/* dwLen doesn't include trailing null */
	} while (0 < dwLen && isSPACE(sMsg[dwLen]));
	if ('.' != sMsg[dwLen])
	    dwLen++;
	sMsg[dwLen] = '\0';
    }
    if (0 == dwLen) {
	sMsg = (char*)LocalAlloc(0, 64/**sizeof(TCHAR)*/);
	if (sMsg)
	    dwLen = sprintf(sMsg,
			    "Unknown error #0x%lX (lookup 0x%lX)",
			    dwErr, GetLastError());
    }
    if (sMsg) {
	dTHX;
	sv_setpvn((SV*)sv, sMsg, dwLen);
	LocalFree(sMsg);
    }
}

DllExport int
win32_fprintf(FILE *fp, const char *format, ...)
{
    va_list marker;
    va_start(marker, format);     /* Initialize variable arguments. */

    return (vfprintf(fp, format, marker));
}

DllExport int
win32_printf(const char *format, ...)
{
    va_list marker;
    va_start(marker, format);     /* Initialize variable arguments. */

    return (vprintf(format, marker));
}

DllExport int
win32_vfprintf(FILE *fp, const char *format, va_list args)
{
    return (vfprintf(fp, format, args));
}

DllExport int
win32_vprintf(const char *format, va_list args)
{
    return (vprintf(format, args));
}

DllExport size_t
win32_fread(void *buf, size_t size, size_t count, FILE *fp)
{
    return fread(buf, size, count, fp);
}

DllExport size_t
win32_fwrite(const void *buf, size_t size, size_t count, FILE *fp)
{
    return fwrite(buf, size, count, fp);
}

#define MODE_SIZE 10

DllExport FILE *
win32_fopen(const char *filename, const char *mode)
{
    dTHXa(NULL);
    FILE *f;

    if (!*filename)
	return NULL;

    if (stricmp(filename, "/dev/null")==0)
	filename = "NUL";

    aTHXa(PERL_GET_THX);
    f = fopen(PerlDir_mapA(filename), mode);
    /* avoid buffering headaches for child processes */
    if (f && *mode == 'a')
	win32_fseek(f, 0, SEEK_END);
    return f;
}

DllExport FILE *
win32_fdopen(int handle, const char *mode)
{
    FILE *f;
    f = fdopen(handle, (char *) mode);
    /* avoid buffering headaches for child processes */
    if (f && *mode == 'a')
	win32_fseek(f, 0, SEEK_END);
    return f;
}

DllExport FILE *
win32_freopen(const char *path, const char *mode, FILE *stream)
{
    dTHXa(NULL);
    if (stricmp(path, "/dev/null")==0)
	path = "NUL";

    aTHXa(PERL_GET_THX);
    return freopen(PerlDir_mapA(path), mode, stream);
}

DllExport int
win32_fclose(FILE *pf)
{
#ifdef WIN32_NO_SOCKETS
    return fclose(pf);
#else
    return my_fclose(pf);	/* defined in win32sck.c */
#endif
}

DllExport int
win32_fputs(const char *s,FILE *pf)
{
    return fputs(s, pf);
}

DllExport int
win32_fputc(int c,FILE *pf)
{
    return fputc(c,pf);
}

DllExport int
win32_ungetc(int c,FILE *pf)
{
    return ungetc(c,pf);
}

DllExport int
win32_getc(FILE *pf)
{
    return getc(pf);
}

DllExport int
win32_fileno(FILE *pf)
{
    return fileno(pf);
}

DllExport void
win32_clearerr(FILE *pf)
{
    clearerr(pf);
    return;
}

DllExport int
win32_fflush(FILE *pf)
{
    return fflush(pf);
}

DllExport Off_t
win32_ftell(FILE *pf)
{
#if defined(WIN64) || defined(USE_LARGE_FILES)
    fpos_t pos;
    if (fgetpos(pf, &pos))
	return -1;
    return (Off_t)pos;
#else
    return ftell(pf);
#endif
}

DllExport int
win32_fseek(FILE *pf, Off_t offset,int origin)
{
#if defined(WIN64) || defined(USE_LARGE_FILES)
    fpos_t pos;
    switch (origin) {
    case SEEK_CUR:
	if (fgetpos(pf, &pos))
	    return -1;
	offset += pos;
	break;
    case SEEK_END:
	fseek(pf, 0, SEEK_END);
	pos = _telli64(fileno(pf));
	offset += pos;
	break;
    case SEEK_SET:
	break;
    default:
	errno = EINVAL;
	return -1;
    }
    return fsetpos(pf, &offset);
#else
    return fseek(pf, (long)offset, origin);
#endif
}

DllExport int
win32_fgetpos(FILE *pf,fpos_t *p)
{
    return fgetpos(pf, p);
}

DllExport int
win32_fsetpos(FILE *pf,const fpos_t *p)
{
    return fsetpos(pf, p);
}

DllExport void
win32_rewind(FILE *pf)
{
    rewind(pf);
    return;
}

DllExport int
win32_tmpfd(void)
{
    char prefix[MAX_PATH+1];
    char filename[MAX_PATH+1];
    DWORD len = GetTempPath(MAX_PATH, prefix);
    if (len && len < MAX_PATH) {
	if (GetTempFileName(prefix, "plx", 0, filename)) {
	    HANDLE fh = CreateFile(filename,
				   DELETE | GENERIC_READ | GENERIC_WRITE,
				   0,
				   NULL,
				   CREATE_ALWAYS,
				   FILE_ATTRIBUTE_NORMAL
				   | FILE_FLAG_DELETE_ON_CLOSE,
				   NULL);
	    if (fh != INVALID_HANDLE_VALUE) {
		int fd = win32_open_osfhandle((intptr_t)fh, 0);
		if (fd >= 0) {
		    PERL_DEB(dTHX;)
		    DEBUG_p(PerlIO_printf(Perl_debug_log,
					  "Created tmpfile=%s\n",filename));
		    return fd;
		}
	    }
	}
    }
    return -1;
}

DllExport FILE*
win32_tmpfile(void)
{
    int fd = win32_tmpfd();
    if (fd >= 0)
	return win32_fdopen(fd, "w+b");
    return NULL;
}

DllExport void
win32_abort(void)
{
    abort();
    return;
}

DllExport int
win32_fstat(int fd, Stat_t *sbufptr)
{
#if defined(WIN64) || defined(USE_LARGE_FILES)
    return _fstati64(fd, sbufptr);
#else
    return fstat(fd, sbufptr);
#endif
}

DllExport int
win32_pipe(int *pfd, unsigned int size, int mode)
{
    return _pipe(pfd, size, mode);
}

DllExport PerlIO*
win32_popenlist(const char *mode, IV narg, SV **args)
{
    get_shell();

    return do_popen(mode, NULL, narg, args);
}

STATIC PerlIO*
do_popen(const char *mode, const char *command, IV narg, SV **args) {
    int p[2];
    int handles[3];
    int parent, child;
    int stdfd;
    int ourmode;
    int childpid;
    DWORD nhandle;
    int lock_held = 0;
    const char **args_pvs = NULL;

    /* establish which ends read and write */
    if (strchr(mode,'w')) {
        stdfd = 0;		/* stdin */
        parent = 1;
        child = 0;
	nhandle = STD_INPUT_HANDLE;
    }
    else if (strchr(mode,'r')) {
        stdfd = 1;		/* stdout */
        parent = 0;
        child = 1;
	nhandle = STD_OUTPUT_HANDLE;
    }
    else
        return NULL;

    /* set the correct mode */
    if (strchr(mode,'b'))
        ourmode = O_BINARY;
    else if (strchr(mode,'t'))
        ourmode = O_TEXT;
    else
        ourmode = _fmode & (O_TEXT | O_BINARY);

    /* the child doesn't inherit handles */
    ourmode |= O_NOINHERIT;

    if (win32_pipe(p, 512, ourmode) == -1)
        return NULL;

    /* Previously this code redirected stdin/out temporarily so the
       child process inherited those handles, this caused race
       conditions when another thread was writing/reading those
       handles.

       To avoid that we just feed the handles to CreateProcess() so
       the handles are redirected only in the child.
     */
    handles[child] = p[child];
    handles[parent] = -1;
    handles[2] = -1;

    /* CreateProcess() requires inheritable handles */
    if (!SetHandleInformation((HANDLE)_get_osfhandle(p[child]), HANDLE_FLAG_INHERIT,
			      HANDLE_FLAG_INHERIT)) {
        goto cleanup;
    }

    /* start the child */
    {
	dTHX;

	if (command) {
	    if ((childpid = do_spawn2_handles(aTHX_ command, EXECF_SPAWN_NOWAIT, handles)) == -1)
	        goto cleanup;

	}
	else {
	    int i;
	    const char *exe_name;

	    Newx(args_pvs, narg + 1 + w32_perlshell_items, const char *);
	    SAVEFREEPV(args_pvs);
	    for (i = 0; i < narg; ++i)
	        args_pvs[i] = SvPV_nolen(args[i]);
	    args_pvs[i] = NULL;
	    exe_name = qualified_path(args_pvs[0], TRUE);
	    if (!exe_name)
	        /* let CreateProcess() try to find it instead */
	        exe_name = args_pvs[0];

	    if ((childpid = do_spawnvp_handles(P_NOWAIT, exe_name, args_pvs, handles)) == -1) {
	        goto cleanup;
	    }
	}

	win32_close(p[child]);

	sv_setiv(*av_fetch(w32_fdpid, p[parent], TRUE), childpid);

	/* set process id so that it can be returned by perl's open() */
	PL_forkprocess = childpid;
    }

    /* we have an fd, return a file stream */
    return (PerlIO_fdopen(p[parent], (char *)mode));

cleanup:
    /* we don't need to check for errors here */
    win32_close(p[0]);
    win32_close(p[1]);

    return (NULL);
}

/*
 * a popen() clone that respects PERL5SHELL
 *
 * changed to return PerlIO* rather than FILE * by BKS, 11-11-2000
 */

DllExport PerlIO*
win32_popen(const char *command, const char *mode)
{
#ifdef USE_RTL_POPEN
    return _popen(command, mode);
#else
    return do_popen(mode, command, 0, NULL);
#endif /* USE_RTL_POPEN */
}

/*
 * pclose() clone
 */

DllExport int
win32_pclose(PerlIO *pf)
{
#ifdef USE_RTL_POPEN
    return _pclose(pf);
#else
    dTHX;
    int childpid, status;
    SV *sv;

    sv = *av_fetch(w32_fdpid, PerlIO_fileno(pf), TRUE);

    if (SvIOK(sv))
	childpid = SvIVX(sv);
    else
	childpid = 0;

    if (!childpid) {
	errno = EBADF;
        return -1;
    }

#ifdef USE_PERLIO
    PerlIO_close(pf);
#else
    fclose(pf);
#endif
    SvIVX(sv) = 0;

    if (win32_waitpid(childpid, &status, 0) == -1)
        return -1;

    return status;

#endif /* USE_RTL_POPEN */
}

DllExport int
win32_link(const char *oldname, const char *newname)
{
    dTHXa(NULL);
    WCHAR wOldName[MAX_PATH+1];
    WCHAR wNewName[MAX_PATH+1];

    if (MultiByteToWideChar(CP_ACP, 0, oldname, -1, wOldName, MAX_PATH+1) &&
        MultiByteToWideChar(CP_ACP, 0, newname, -1, wNewName, MAX_PATH+1) &&
	((aTHXa(PERL_GET_THX)), wcscpy(wOldName, PerlDir_mapW(wOldName)),
        CreateHardLinkW(PerlDir_mapW(wNewName), wOldName, NULL)))
    {
	return 0;
    }
    /* This isn't perfect, eg. Win32 returns ERROR_ACCESS_DENIED for
       both permissions errors and if the source is a directory, while
       POSIX wants EACCES and EPERM respectively.

       Determined by experimentation on Windows 7 x64 SP1, since MS
       don't document what error codes are returned.
    */
    switch (GetLastError()) {
    case ERROR_BAD_NET_NAME:
    case ERROR_BAD_NETPATH:
    case ERROR_BAD_PATHNAME:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_FILENAME_EXCED_RANGE:
    case ERROR_INVALID_DRIVE:
    case ERROR_PATH_NOT_FOUND:
      errno = ENOENT;
      break;
    case ERROR_ALREADY_EXISTS:
      errno = EEXIST;
      break;
    case ERROR_ACCESS_DENIED:
      errno = EACCES;
      break;
    case ERROR_NOT_SAME_DEVICE:
      errno = EXDEV;
      break;
    case ERROR_DISK_FULL:
      errno = ENOSPC;
      break;
    case ERROR_NOT_ENOUGH_QUOTA:
      errno = EDQUOT;
      break;
    default:
      /* ERROR_INVALID_FUNCTION - eg. on a FAT volume */
      errno = EINVAL;
      break;
    }
    return -1;
}

DllExport int
win32_rename(const char *oname, const char *newname)
{
    char szOldName[MAX_PATH+1];
    BOOL bResult;
    DWORD dwFlags = MOVEFILE_COPY_ALLOWED;
    dTHX;

    if (stricmp(newname, oname))
        dwFlags |= MOVEFILE_REPLACE_EXISTING;
    strcpy(szOldName, PerlDir_mapA(oname));

    bResult = MoveFileExA(szOldName,PerlDir_mapA(newname), dwFlags);
    if (!bResult) {
        DWORD err = GetLastError();
        switch (err) {
        case ERROR_BAD_NET_NAME:
        case ERROR_BAD_NETPATH:
        case ERROR_BAD_PATHNAME:
        case ERROR_FILE_NOT_FOUND:
        case ERROR_FILENAME_EXCED_RANGE:
        case ERROR_INVALID_DRIVE:
        case ERROR_NO_MORE_FILES:
        case ERROR_PATH_NOT_FOUND:
            errno = ENOENT;
            break;
        case ERROR_DISK_FULL:
            errno = ENOSPC;
            break;
        case ERROR_NOT_ENOUGH_QUOTA:
            errno = EDQUOT;
            break;
        default:
            errno = EACCES;
            break;
        }
        return -1;
    }
    return 0;
}

DllExport int
win32_setmode(int fd, int mode)
{
    return setmode(fd, mode);
}

DllExport int
win32_chsize(int fd, Off_t size)
{
#if defined(WIN64) || defined(USE_LARGE_FILES)
    int retval = 0;
    Off_t cur, end, extend;

    cur = win32_tell(fd);
    if (cur < 0)
	return -1;
    end = win32_lseek(fd, 0, SEEK_END);
    if (end < 0)
	return -1;
    extend = size - end;
    if (extend == 0) {
	/* do nothing */
    }
    else if (extend > 0) {
	/* must grow the file, padding with nulls */
	char b[4096];
	int oldmode = win32_setmode(fd, O_BINARY);
	size_t count;
	memset(b, '\0', sizeof(b));
	do {
	    count = extend >= sizeof(b) ? sizeof(b) : (size_t)extend;
	    count = win32_write(fd, b, count);
	    if ((int)count < 0) {
		retval = -1;
		break;
	    }
	} while ((extend -= count) > 0);
	win32_setmode(fd, oldmode);
    }
    else {
	/* shrink the file */
	win32_lseek(fd, size, SEEK_SET);
	if (!SetEndOfFile((HANDLE)_get_osfhandle(fd))) {
	    errno = EACCES;
	    retval = -1;
	}
    }
    win32_lseek(fd, cur, SEEK_SET);
    return retval;
#else
    return chsize(fd, (long)size);
#endif
}

DllExport Off_t
win32_lseek(int fd, Off_t offset, int origin)
{
#if defined(WIN64) || defined(USE_LARGE_FILES)
    return _lseeki64(fd, offset, origin);
#else
    return lseek(fd, (long)offset, origin);
#endif
}

DllExport Off_t
win32_tell(int fd)
{
#if defined(WIN64) || defined(USE_LARGE_FILES)
    return _telli64(fd);
#else
    return tell(fd);
#endif
}

DllExport int
win32_open(const char *path, int flag, ...)
{
    dTHXa(NULL);
    va_list ap;
    int pmode;

    va_start(ap, flag);
    pmode = va_arg(ap, int);
    va_end(ap);

    if (stricmp(path, "/dev/null")==0)
	path = "NUL";

    aTHXa(PERL_GET_THX);
    return open(PerlDir_mapA(path), flag, pmode);
}

/* close() that understands socket */
extern int my_close(int);	/* in win32sck.c */

DllExport int
win32_close(int fd)
{
#ifdef WIN32_NO_SOCKETS
    return close(fd);
#else
    return my_close(fd);
#endif
}

DllExport int
win32_eof(int fd)
{
    return eof(fd);
}

DllExport int
win32_isatty(int fd)
{
    /* The Microsoft isatty() function returns true for *all*
     * character mode devices, including "nul".  Our implementation
     * should only return true if the handle has a console buffer.
     */
    DWORD mode;
    HANDLE fh = (HANDLE)_get_osfhandle(fd);
    if (fh == (HANDLE)-1) {
        /* errno is already set to EBADF */
        return 0;
    }

    if (GetConsoleMode(fh, &mode))
        return 1;

    errno = ENOTTY;
    return 0;
}

DllExport int
win32_dup(int fd)
{
    return dup(fd);
}

DllExport int
win32_dup2(int fd1,int fd2)
{
    return dup2(fd1,fd2);
}

DllExport int
win32_read(int fd, void *buf, unsigned int cnt)
{
    return read(fd, buf, cnt);
}

DllExport int
win32_write(int fd, const void *buf, unsigned int cnt)
{
    return write(fd, buf, cnt);
}

DllExport int
win32_mkdir(const char *dir, int mode)
{
    dTHX;
    return mkdir(PerlDir_mapA(dir)); /* just ignore mode */
}

DllExport int
win32_rmdir(const char *dir)
{
    dTHX;
    return rmdir(PerlDir_mapA(dir));
}

DllExport int
win32_chdir(const char *dir)
{
    if (!dir || !*dir) {
	errno = ENOENT;
	return -1;
    }
    return chdir(dir);
}

DllExport  int
win32_access(const char *path, int mode)
{
    dTHX;
    return access(PerlDir_mapA(path), mode);
}

DllExport  int
win32_chmod(const char *path, int mode)
{
    dTHX;
    return chmod(PerlDir_mapA(path), mode);
}


static char *
create_command_line(char *cname, STRLEN clen, const char * const *args)
{
    PERL_DEB(dTHX;)
    int index, argc;
    char *cmd, *ptr;
    const char *arg;
    STRLEN len = 0;
    bool bat_file = FALSE;
    bool cmd_shell = FALSE;
    bool dumb_shell = FALSE;
    bool extra_quotes = FALSE;
    bool quote_next = FALSE;

    if (!cname)
	cname = (char*)args[0];

    /* The NT cmd.exe shell has the following peculiarity that needs to be
     * worked around.  It strips a leading and trailing dquote when any
     * of the following is true:
     *    1. the /S switch was used
     *    2. there are more than two dquotes
     *    3. there is a special character from this set: &<>()@@^|
     *    4. no whitespace characters within the two dquotes
     *    5. string between two dquotes isn't an executable file
     * To work around this, we always add a leading and trailing dquote
     * to the string, if the first argument is either "cmd.exe" or "cmd",
     * and there were at least two or more arguments passed to cmd.exe
     * (not including switches).
     * XXX the above rules (from "cmd /?") don't seem to be applied
     * always, making for the convolutions below :-(
     */
    if (cname) {
	if (!clen)
	    clen = strlen(cname);

	if (clen > 4
	    && (stricmp(&cname[clen-4], ".bat") == 0
		|| (stricmp(&cname[clen-4], ".cmd") == 0)))
	{
	    bat_file = TRUE;
            len += 3;
	}
	else {
	    char *exe = strrchr(cname, '/');
	    char *exe2 = strrchr(cname, '\\');
	    if (exe2 > exe)
		exe = exe2;
	    if (exe)
		++exe;
	    else
		exe = cname;
	    if (stricmp(exe, "cmd.exe") == 0 || stricmp(exe, "cmd") == 0) {
		cmd_shell = TRUE;
		len += 3;
	    }
	    else if (stricmp(exe, "command.com") == 0
		     || stricmp(exe, "command") == 0)
	    {
		dumb_shell = TRUE;
	    }
	}
    }

    DEBUG_p(PerlIO_printf(Perl_debug_log, "Args "));
    for (index = 0; (arg = (char*)args[index]) != NULL; ++index) {
	STRLEN curlen = strlen(arg);
	if (!(arg[0] == '"' && arg[curlen-1] == '"'))
	    len += 2;	/* assume quoting needed (worst case) */
	len += curlen + 1;
	DEBUG_p(PerlIO_printf(Perl_debug_log, "[%s]",arg));
    }
    DEBUG_p(PerlIO_printf(Perl_debug_log, "\n"));

    argc = index;
    Newx(cmd, len, char);
    ptr = cmd;

    if (bat_file) {
	*ptr++ = '"';
	extra_quotes = TRUE;
    }

    for (index = 0; (arg = (char*)args[index]) != NULL; ++index) {
	bool do_quote = 0;
	STRLEN curlen = strlen(arg);

	/* we want to protect empty arguments and ones with spaces with
	 * dquotes, but only if they aren't already there */
	if (!dumb_shell) {
	    if (!curlen) {
		do_quote = 1;
	    }
	    else if (quote_next) {
		/* see if it really is multiple arguments pretending to
		 * be one and force a set of quotes around it */
		if (*find_next_space(arg))
		    do_quote = 1;
	    }
	    else if (!(arg[0] == '"' && curlen > 1 && arg[curlen-1] == '"')) {
		STRLEN i = 0;
		while (i < curlen) {
		    if (isSPACE(arg[i])) {
			do_quote = 1;
		    }
		    else if (arg[i] == '"') {
			do_quote = 0;
			break;
		    }
		    i++;
		}
	    }
	}

	if (do_quote)
	    *ptr++ = '"';

	strcpy(ptr, arg);
	ptr += curlen;

	if (do_quote)
	    *ptr++ = '"';

	if (args[index+1])
	    *ptr++ = ' ';

    	if (!extra_quotes
	    && cmd_shell
	    && curlen >= 2
	    && *arg  == '/'     /* see if arg is "/c", "/x/c", "/x/d/c" etc. */
	    && stricmp(arg+curlen-2, "/c") == 0)
	{
	    /* is there a next argument? */
	    if (args[index+1]) {
		/* are there two or more next arguments? */
		if (args[index+2]) {
		    *ptr++ = '"';
		    extra_quotes = TRUE;
		}
		else {
		    /* single argument, force quoting if it has spaces */
		    quote_next = TRUE;
		}
	    }
	}
    }

    if (extra_quotes)
	*ptr++ = '"';

    *ptr = '\0';

    return cmd;
}

static const char *exe_extensions[] =
  {
    ".exe", /* this must be first */
    ".cmd",
    ".bat"
  };

static char *
qualified_path(const char *cmd, bool other_exts)
{
    char *pathstr;
    char *fullcmd, *curfullcmd;
    STRLEN cmdlen = 0;
    int has_slash = 0;

    if (!cmd)
	return NULL;
    fullcmd = (char*)cmd;
    while (*fullcmd) {
	if (*fullcmd == '/' || *fullcmd == '\\')
	    has_slash++;
	fullcmd++;
	cmdlen++;
    }

    /* look in PATH */
    {
	dTHX;
	pathstr = PerlEnv_getenv("PATH");
    }
    /* worst case: PATH is a single directory; we need additional space
     * to append "/", ".exe" and trailing "\0" */
    Newx(fullcmd, (pathstr ? strlen(pathstr) : 0) + cmdlen + 6, char);
    curfullcmd = fullcmd;

    while (1) {
	DWORD res;

	/* start by appending the name to the current prefix */
	strcpy(curfullcmd, cmd);
	curfullcmd += cmdlen;

	/* if it doesn't end with '.', or has no extension, try adding
	 * a trailing .exe first */
	if (cmd[cmdlen-1] != '.'
	    && (cmdlen < 4 || cmd[cmdlen-4] != '.'))
	{
	    int i;
	    /* first extension is .exe */
	    int ext_limit = other_exts ? C_ARRAY_LENGTH(exe_extensions) : 1;
	    for (i = 0; i < ext_limit; ++i) {
	        strcpy(curfullcmd, exe_extensions[i]);
	        res = GetFileAttributes(fullcmd);
	        if (res != 0xFFFFFFFF && !(res & FILE_ATTRIBUTE_DIRECTORY))
		    return fullcmd;
	    }

	    *curfullcmd = '\0';
	}

	/* that failed, try the bare name */
	res = GetFileAttributes(fullcmd);
	if (res != 0xFFFFFFFF && !(res & FILE_ATTRIBUTE_DIRECTORY))
	    return fullcmd;

	/* quit if no other path exists, or if cmd already has path */
	if (!pathstr || !*pathstr || has_slash)
	    break;

	/* skip leading semis */
	while (*pathstr == ';')
	    pathstr++;

	/* build a new prefix from scratch */
	curfullcmd = fullcmd;
	while (*pathstr && *pathstr != ';') {
	    if (*pathstr == '"') {	/* foo;"baz;etc";bar */
		pathstr++;		/* skip initial '"' */
		while (*pathstr && *pathstr != '"') {
                    *curfullcmd++ = *pathstr++;
		}
		if (*pathstr)
		    pathstr++;		/* skip trailing '"' */
	    }
	    else {
                *curfullcmd++ = *pathstr++;
	    }
	}
	if (*pathstr)
	    pathstr++;			/* skip trailing semi */
	if (curfullcmd > fullcmd	/* append a dir separator */
	    && curfullcmd[-1] != '/' && curfullcmd[-1] != '\\')
	{
	    *curfullcmd++ = '\\';
	}
    }

    Safefree(fullcmd);
    return NULL;
}

/* The following are just place holders.
 * Some hosts may provide and environment that the OS is
 * not tracking, therefore, these host must provide that
 * environment and the current directory to CreateProcess
 */

DllExport void*
win32_get_childenv(void)
{
    return NULL;
}

DllExport void
win32_free_childenv(void* d)
{
}

DllExport void
win32_clearenv(void)
{
    char *envv = GetEnvironmentStrings();
    char *cur = envv;
    STRLEN len;
    while (*cur) {
	char *end = strchr(cur,'=');
	if (end && end != cur) {
	    *end = '\0';
	    SetEnvironmentVariable(cur, NULL);
	    *end = '=';
	    cur = end + strlen(end+1)+2;
	}
	else if ((len = strlen(cur)))
	    cur += len+1;
    }
    FreeEnvironmentStrings(envv);
}

DllExport char*
win32_get_childdir(void)
{
    char* ptr;
    char szfilename[MAX_PATH+1];

    GetCurrentDirectoryA(MAX_PATH+1, szfilename);
    Newx(ptr, strlen(szfilename)+1, char);
    strcpy(ptr, szfilename);
    return ptr;
}

DllExport void
win32_free_childdir(char* d)
{
    Safefree(d);
}


/* XXX this needs to be made more compatible with the spawnvp()
 * provided by the various RTLs.  In particular, searching for
 * *.{com,bat,cmd} files (as done by the RTLs) is unimplemented.
 * This doesn't significantly affect perl itself, because we
 * always invoke things using PERL5SHELL if a direct attempt to
 * spawn the executable fails.
 *
 * XXX splitting and rejoining the commandline between do_aspawn()
 * and win32_spawnvp() could also be avoided.
 */

DllExport int
win32_spawnvp(int mode, const char *cmdname, const char *const *argv)
{
#ifdef USE_RTL_SPAWNVP
    return _spawnvp(mode, cmdname, (char * const *)argv);
#else
    return do_spawnvp_handles(mode, cmdname, argv, NULL);
#endif
}

static int
do_spawnvp_handles(int mode, const char *cmdname, const char *const *argv,
                const int *handles) {
    dTHXa(NULL);
    int ret;
    void* env;
    char* dir;
    child_IO_table tbl;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    DWORD create = 0;
    char *cmd;
    char *fullcmd = NULL;
    char *cname = (char *)cmdname;
    STRLEN clen = 0;

    if (cname) {
	clen = strlen(cname);
	/* if command name contains dquotes, must remove them */
	if (strchr(cname, '"')) {
	    cmd = cname;
	    Newx(cname,clen+1,char);
	    clen = 0;
	    while (*cmd) {
		if (*cmd != '"') {
		    cname[clen] = *cmd;
		    ++clen;
		}
		++cmd;
	    }
	    cname[clen] = '\0';
	}
    }

    cmd = create_command_line(cname, clen, argv);

    aTHXa(PERL_GET_THX);
    env = PerlEnv_get_childenv();
    dir = PerlEnv_get_childdir();

    switch(mode) {
    case P_NOWAIT:	/* asynch + remember result */
	if (w32_num_children >= MAXIMUM_WAIT_OBJECTS) {
	    errno = EAGAIN;
	    ret = -1;
	    goto RETVAL;
	}
	/* Create a new process group so we can use GenerateConsoleCtrlEvent()
	 * in win32_kill()
	 */
        create |= CREATE_NEW_PROCESS_GROUP;
	/* FALL THROUGH */

    case P_WAIT:	/* synchronous execution */
	break;
    default:		/* invalid mode */
	errno = EINVAL;
	ret = -1;
	goto RETVAL;
    }

    memset(&StartupInfo,0,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    memset(&tbl,0,sizeof(tbl));
    PerlEnv_get_child_IO(&tbl);
    StartupInfo.dwFlags		= tbl.dwFlags;
    StartupInfo.dwX		= tbl.dwX;
    StartupInfo.dwY		= tbl.dwY;
    StartupInfo.dwXSize		= tbl.dwXSize;
    StartupInfo.dwYSize		= tbl.dwYSize;
    StartupInfo.dwXCountChars	= tbl.dwXCountChars;
    StartupInfo.dwYCountChars	= tbl.dwYCountChars;
    StartupInfo.dwFillAttribute	= tbl.dwFillAttribute;
    StartupInfo.wShowWindow	= tbl.wShowWindow;
    StartupInfo.hStdInput	= handles && handles[0] != -1 ?
            (HANDLE)_get_osfhandle(handles[0]) : tbl.childStdIn;
    StartupInfo.hStdOutput	= handles && handles[1] != -1 ?
            (HANDLE)_get_osfhandle(handles[1]) : tbl.childStdOut;
    StartupInfo.hStdError	= handles && handles[2] != -1 ?
	    (HANDLE)_get_osfhandle(handles[2]) : tbl.childStdErr;
    if (StartupInfo.hStdInput == INVALID_HANDLE_VALUE &&
	StartupInfo.hStdOutput == INVALID_HANDLE_VALUE &&
	StartupInfo.hStdError == INVALID_HANDLE_VALUE)
    {
	create |= CREATE_NEW_CONSOLE;
    }
    else {
	StartupInfo.dwFlags |= STARTF_USESTDHANDLES;
    }
    if (w32_use_showwindow) {
        StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow = w32_showwindow;
    }

    DEBUG_p(PerlIO_printf(Perl_debug_log, "Spawning [%s] with [%s]\n",
			  cname,cmd));
RETRY:
    if (!CreateProcess(cname,		/* search PATH to find executable */
		       cmd,		/* executable, and its arguments */
		       NULL,		/* process attributes */
		       NULL,		/* thread attributes */
		       TRUE,		/* inherit handles */
		       create,		/* creation flags */
		       (LPVOID)env,	/* inherit environment */
		       dir,		/* inherit cwd */
		       &StartupInfo,
		       &ProcessInformation))
    {
	/* initial NULL argument to CreateProcess() does a PATH
	 * search, but it always first looks in the directory
	 * where the current process was started, which behavior
	 * is undesirable for backward compatibility.  So we
	 * jump through our own hoops by picking out the path
	 * we really want it to use. */
	if (!fullcmd) {
	    fullcmd = qualified_path(cname, FALSE);
	    if (fullcmd) {
		if (cname != cmdname)
		    Safefree(cname);
		cname = fullcmd;
		DEBUG_p(PerlIO_printf(Perl_debug_log,
				      "Retrying [%s] with same args\n",
				      cname));
		goto RETRY;
	    }
	}
	errno = ENOENT;
	ret = -1;
	goto RETVAL;
    }

    if (mode == P_NOWAIT) {
	/* asynchronous spawn -- store handle, return PID */
	ret = (int)ProcessInformation.dwProcessId;

	w32_child_handles[w32_num_children] = ProcessInformation.hProcess;
	w32_child_pids[w32_num_children] = (DWORD)ret;
	++w32_num_children;
    }
    else  {
	DWORD status;
	win32_msgwait(aTHX_ 1, &ProcessInformation.hProcess, INFINITE, NULL);
	/* FIXME: if msgwait returned due to message perhaps forward the
	   "signal" to the process
         */
	GetExitCodeProcess(ProcessInformation.hProcess, &status);
	ret = (int)status;
	CloseHandle(ProcessInformation.hProcess);
    }

    CloseHandle(ProcessInformation.hThread);

RETVAL:
    PerlEnv_free_childenv(env);
    PerlEnv_free_childdir(dir);
    Safefree(cmd);
    if (cname != cmdname)
	Safefree(cname);
    return ret;
}

DllExport int
win32_execv(const char *cmdname, const char *const *argv)
{
#ifdef USE_ITHREADS
    dTHX;
    /* if this is a pseudo-forked child, we just want to spawn
     * the new program, and return */
    if (w32_pseudo_id)
	return _spawnv(P_WAIT, cmdname, argv);
#endif
    return _execv(cmdname, argv);
}

DllExport int
win32_execvp(const char *cmdname, const char *const *argv)
{
#ifdef USE_ITHREADS
    dTHX;
    /* if this is a pseudo-forked child, we just want to spawn
     * the new program, and return */
    if (w32_pseudo_id) {
	int status = win32_spawnvp(P_WAIT, cmdname, (const char *const *)argv);
	if (status != -1) {
	    my_exit(status);
	    return 0;
	}
	else
	    return status;
    }
#endif
    return _execvp(cmdname, argv);
}

DllExport void
win32_perror(const char *str)
{
    perror(str);
}

DllExport void
win32_setbuf(FILE *pf, char *buf)
{
    setbuf(pf, buf);
}

DllExport int
win32_setvbuf(FILE *pf, char *buf, int type, size_t size)
{
    return setvbuf(pf, buf, type, size);
}

DllExport int
win32_flushall(void)
{
    return flushall();
}

DllExport int
win32_fcloseall(void)
{
    return fcloseall();
}

DllExport char*
win32_fgets(char *s, int n, FILE *pf)
{
    return fgets(s, n, pf);
}

DllExport char*
win32_gets(char *s)
{
    return gets(s);
}

DllExport int
win32_fgetc(FILE *pf)
{
    return fgetc(pf);
}

DllExport int
win32_putc(int c, FILE *pf)
{
    return putc(c,pf);
}

DllExport int
win32_puts(const char *s)
{
    return puts(s);
}

DllExport int
win32_getchar(void)
{
    return getchar();
}

DllExport int
win32_putchar(int c)
{
    return putchar(c);
}

#ifdef MYMALLOC

#ifndef USE_PERL_SBRK

static char *committed = NULL;		/* XXX threadead */
static char *base      = NULL;		/* XXX threadead */
static char *reserved  = NULL;		/* XXX threadead */
static char *brk       = NULL;		/* XXX threadead */
static DWORD pagesize  = 0;		/* XXX threadead */

void *
sbrk(ptrdiff_t need)
{
 void *result;
 if (!pagesize)
  {SYSTEM_INFO info;
   GetSystemInfo(&info);
   /* Pretend page size is larger so we don't perpetually
    * call the OS to commit just one page ...
    */
   pagesize = info.dwPageSize << 3;
  }
 if (brk+need >= reserved)
  {
   DWORD size = brk+need-reserved;
   char *addr;
   char *prev_committed = NULL;
   if (committed && reserved && committed < reserved)
    {
     /* Commit last of previous chunk cannot span allocations */
     addr = (char *) VirtualAlloc(committed,reserved-committed,MEM_COMMIT,PAGE_READWRITE);
     if (addr)
      {
      /* Remember where we committed from in case we want to decommit later */
      prev_committed = committed;
      committed = reserved;
      }
    }
   /* Reserve some (more) space
    * Contiguous blocks give us greater efficiency, so reserve big blocks -
    * this is only address space not memory...
    * Note this is a little sneaky, 1st call passes NULL as reserved
    * so lets system choose where we start, subsequent calls pass
    * the old end address so ask for a contiguous block
    */
sbrk_reserve:
   if (size < 64*1024*1024)
    size = 64*1024*1024;
   size = ((size + pagesize - 1) / pagesize) * pagesize;
   addr  = (char *) VirtualAlloc(reserved,size,MEM_RESERVE,PAGE_NOACCESS);
   if (addr)
    {
     reserved = addr+size;
     if (!base)
      base = addr;
     if (!committed)
      committed = base;
     if (!brk)
      brk = committed;
    }
   else if (reserved)
    {
      /* The existing block could not be extended far enough, so decommit
       * anything that was just committed above and start anew */
      if (prev_committed)
       {
       if (!VirtualFree(prev_committed,reserved-prev_committed,MEM_DECOMMIT))
        return (void *) -1;
       }
      reserved = base = committed = brk = NULL;
      size = need;
      goto sbrk_reserve;
    }
   else
    {
     return (void *) -1;
    }
  }
 result = brk;
 brk += need;
 if (brk > committed)
  {
   DWORD size = ((brk-committed + pagesize -1)/pagesize) * pagesize;
   char *addr;
   if (committed+size > reserved)
    size = reserved-committed;
   addr = (char *) VirtualAlloc(committed,size,MEM_COMMIT,PAGE_READWRITE);
   if (addr)
    committed += size;
   else
    return (void *) -1;
  }
 return result;
}

#endif
#endif

DllExport void*
win32_malloc(size_t size)
{
    return malloc(size);
}

DllExport void*
win32_calloc(size_t numitems, size_t size)
{
    return calloc(numitems,size);
}

DllExport void*
win32_realloc(void *block, size_t size)
{
    return realloc(block,size);
}

DllExport void
win32_free(void *block)
{
    free(block);
}


DllExport int
win32_open_osfhandle(intptr_t handle, int flags)
{
    return _open_osfhandle(handle, flags);
}

DllExport intptr_t
win32_get_osfhandle(int fd)
{
    return (intptr_t)_get_osfhandle(fd);
}

DllExport FILE *
win32_fdupopen(FILE *pf)
{
    FILE* pfdup;
    fpos_t pos;
    char mode[3];
    int fileno = win32_dup(win32_fileno(pf));

    /* open the file in the same mode */
    if((pf)->_flag & _IOREAD) {
	mode[0] = 'r';
	mode[1] = 0;
    }
    else if((pf)->_flag & _IOWRT) {
	mode[0] = 'a';
	mode[1] = 0;
    }
    else if((pf)->_flag & _IORW) {
	mode[0] = 'r';
	mode[1] = '+';
	mode[2] = 0;
    }

    /* it appears that the binmode is attached to the
     * file descriptor so binmode files will be handled
     * correctly
     */
    pfdup = win32_fdopen(fileno, mode);

    /* move the file pointer to the same position */
    if (!fgetpos(pf, &pos)) {
	fsetpos(pfdup, &pos);
    }
    return pfdup;
}

DllExport void*
win32_dynaload(const char* filename)
{
    dTHXa(NULL);
    char buf[MAX_PATH+1];
    const char *first;

    /* LoadLibrary() doesn't recognize forward slashes correctly,
     * so turn 'em back. */
    first = strchr(filename, '/');
    if (first) {
	STRLEN len = strlen(filename);
	if (len <= MAX_PATH) {
	    strcpy(buf, filename);
	    filename = &buf[first - filename];
	    while (*filename) {
		if (*filename == '/')
		    *(char*)filename = '\\';
		++filename;
	    }
	    filename = buf;
	}
    }
    aTHXa(PERL_GET_THX);
    return LoadLibraryExA(PerlDir_mapA(filename), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
}

XS(w32_SetChildShowWindow)
{
    dXSARGS;
    BOOL use_showwindow = w32_use_showwindow;
    /* use "unsigned short" because Perl has redefined "WORD" */
    unsigned short showwindow = w32_showwindow;

    if (items > 1)
	croak_xs_usage(cv, "[showwindow]");

    if (items == 0 || !SvOK(ST(0)))
        w32_use_showwindow = FALSE;
    else {
        w32_use_showwindow = TRUE;
        w32_showwindow = (unsigned short)SvIV(ST(0));
    }

    EXTEND(SP, 1);
    if (use_showwindow)
        ST(0) = sv_2mortal(newSViv(showwindow));
    else
        ST(0) = &PL_sv_undef;
    XSRETURN(1);
}


#ifdef PERL_IS_MINIPERL
/* shelling out is much slower, full perl uses Win32.pm */
XS(w32_GetCwd)
{
    dXSARGS;
    /* Make the host for current directory */
    char* ptr = PerlEnv_get_childdir();
    /*
     * If ptr != Nullch
     *   then it worked, set PV valid,
     *   else return 'undef'
     */
    if (ptr) {
	SV *sv = sv_newmortal();
	sv_setpv(sv, ptr);
	PerlEnv_free_childdir(ptr);

#ifndef INCOMPLETE_TAINTS
	SvTAINTED_on(sv);
#endif

	ST(0) = sv;
	XSRETURN(1);
    }
    XSRETURN_UNDEF;
}
#endif

void
Perl_init_os_extras(void)
{
    dTHXa(NULL);
    char *file = __FILE__;

    /* Initialize Win32CORE if it has been statically linked. */
#ifndef PERL_IS_MINIPERL
    void (*pfn_init)(pTHX);
    HMODULE module = (HMODULE)((w32_perldll_handle == INVALID_HANDLE_VALUE)
                               ? GetModuleHandle(NULL)
                               : w32_perldll_handle);
    pfn_init = (void (*)(pTHX))GetProcAddress(module, "init_Win32CORE");
    aTHXa(PERL_GET_THX);
    if (pfn_init)
        pfn_init(aTHX);
#else
    aTHXa(PERL_GET_THX);
#endif

    newXS("Win32::SetChildShowWindow", w32_SetChildShowWindow, file);
#ifdef PERL_IS_MINIPERL
    newXS("Win32::GetCwd", w32_GetCwd, file);
#endif
}

void *
win32_signal_context(void)
{
    dTHX;
#ifdef MULTIPLICITY
    if (!my_perl) {
	my_perl = PL_curinterp;
	PERL_SET_THX(my_perl);
    }
    return my_perl;
#else
    return PL_curinterp;
#endif
}


BOOL WINAPI
win32_ctrlhandler(DWORD dwCtrlType)
{
#ifdef MULTIPLICITY
    dTHXa(PERL_GET_SIG_CONTEXT);

    if (!my_perl)
	return FALSE;
#endif

    switch(dwCtrlType) {
    case CTRL_CLOSE_EVENT:
     /*  A signal that the system sends to all processes attached to a console when
         the user closes the console (either by choosing the Close command from the
         console window's System menu, or by choosing the End Task command from the
         Task List
      */
	if (do_raise(aTHX_ 1))	      /* SIGHUP */
	    sig_terminate(aTHX_ 1);
	return TRUE;

    case CTRL_C_EVENT:
	/*  A CTRL+c signal was received */
	if (do_raise(aTHX_ SIGINT))
	    sig_terminate(aTHX_ SIGINT);
	return TRUE;

    case CTRL_BREAK_EVENT:
	/*  A CTRL+BREAK signal was received */
	if (do_raise(aTHX_ SIGBREAK))
	    sig_terminate(aTHX_ SIGBREAK);
	return TRUE;

    case CTRL_LOGOFF_EVENT:
      /*  A signal that the system sends to all console processes when a user is logging
          off. This signal does not indicate which user is logging off, so no
          assumptions can be made.
       */
	break;
    case CTRL_SHUTDOWN_EVENT:
      /*  A signal that the system sends to all console processes when the system is
          shutting down.
       */
	if (do_raise(aTHX_ SIGTERM))
	    sig_terminate(aTHX_ SIGTERM);
	return TRUE;
    default:
	break;
    }
    return FALSE;
}


#ifdef SET_INVALID_PARAMETER_HANDLER
#  include <crtdbg.h>
#endif

static void
ansify_path(void)
{
    size_t len;
    char *ansi_path;
    WCHAR *wide_path;
    WCHAR *wide_dir;

    /* fetch Unicode version of PATH */
    len = 2000;
    wide_path = (WCHAR*)win32_malloc(len*sizeof(WCHAR));
    while (wide_path) {
        size_t newlen = GetEnvironmentVariableW(L"PATH", wide_path, len);
        if (newlen == 0) {
            win32_free(wide_path);
            return;
        }
        if (newlen < len)
            break;
        len = newlen;
        wide_path = (WCHAR*)win32_realloc(wide_path, len*sizeof(WCHAR));
    }
    if (!wide_path)
        return;

    /* convert to ANSI pathnames */
    wide_dir = wide_path;
    ansi_path = NULL;
    while (wide_dir) {
        WCHAR *sep = wcschr(wide_dir, ';');
        char *ansi_dir;
        size_t ansi_len;
        size_t wide_len;

        if (sep)
            *sep++ = '\0';

        /* remove quotes around pathname */
        if (*wide_dir == '"')
            ++wide_dir;
        wide_len = wcslen(wide_dir);
        if (wide_len && wide_dir[wide_len-1] == '"')
            wide_dir[wide_len-1] = '\0';

        /* append ansi_dir to ansi_path */
        ansi_dir = win32_ansipath(wide_dir);
        ansi_len = strlen(ansi_dir);
        if (ansi_path) {
            size_t newlen = len + 1 + ansi_len;
            ansi_path = (char*)win32_realloc(ansi_path, newlen+1);
            if (!ansi_path)
                break;
            ansi_path[len] = ';';
            memcpy(ansi_path+len+1, ansi_dir, ansi_len+1);
            len = newlen;
        }
        else {
            len = ansi_len;
            ansi_path = (char*)win32_malloc(5+len+1);
            if (!ansi_path)
                break;
            memcpy(ansi_path, "PATH=", 5);
            memcpy(ansi_path+5, ansi_dir, len+1);
            len += 5;
        }
        win32_free(ansi_dir);
        wide_dir = sep;
    }

    if (ansi_path) {
        /* Update C RTL environ array.  This will only have full effect if
         * perl_parse() is later called with `environ` as the `env` argument.
         * Otherwise S_init_postdump_symbols() will overwrite PATH again.
         *
         * We do have to ansify() the PATH before Perl has been fully
         * initialized because S_find_script() uses the PATH when perl
         * is being invoked with the -S option.  This happens before %ENV
         * is initialized in S_init_postdump_symbols().
         *
         * XXX Is this a bug? Should S_find_script() use the environment
         * XXX passed in the `env` arg to parse_perl()?
         */
        putenv(ansi_path);
        /* Keep system environment in sync because S_init_postdump_symbols()
         * will not call mg_set() if it initializes %ENV from `environ`.
         */
        SetEnvironmentVariableA("PATH", ansi_path+5);
        win32_free(ansi_path);
    }
    win32_free(wide_path);
}

void
Perl_win32_init(int *argcp, char ***argvp)
{
#ifdef SET_INVALID_PARAMETER_HANDLER
    _invalid_parameter_handler oldHandler, newHandler;
    newHandler = my_invalid_parameter_handler;
    oldHandler = _set_invalid_parameter_handler(newHandler);
    _CrtSetReportMode(_CRT_ASSERT, 0);
#endif
    /* Disable floating point errors, Perl will trap the ones we
     * care about.  VC++ RTL defaults to switching these off
     * already, but some RTLs don't.  Since we don't
     * want to be at the vendor's whim on the default, we set
     * it explicitly here.
     */
#if !defined(__GNUC__)
    _control87(MCW_EM, MCW_EM);
#endif
    MALLOC_INIT;

    /* When the manifest resource requests Common-Controls v6 then
     * user32.dll no longer registers all the Windows classes used for
     * standard controls but leaves some of them to be registered by
     * comctl32.dll.  InitCommonControls() doesn't do anything but calling
     * it makes sure comctl32.dll gets loaded into the process and registers
     * the standard control classes.  Without this even normal Windows APIs
     * like MessageBox() can fail under some versions of Windows XP.
     */
    InitCommonControls();

    g_osver.dwOSVersionInfoSize = sizeof(g_osver);
    GetVersionEx(&g_osver);

#ifdef WIN32_DYN_IOINFO_SIZE
    {
	Size_t ioinfo_size = _msize((void*)__pioinfo[0]);;
	if((SSize_t)ioinfo_size <= 0) { /* -1 is err */
	    fprintf(stderr, "panic: invalid size for ioinfo\n"); /* no interp */
	    exit(1);
	}
	ioinfo_size /= IOINFO_ARRAY_ELTS;
	w32_ioinfo_size = ioinfo_size;
    }
#endif

    ansify_path();

#ifndef WIN32_NO_REGISTRY
    {
	LONG retval;
	retval = RegOpenKeyExW(HKEY_CURRENT_USER, L"SOFTWARE\\Perl", 0, KEY_READ, &HKCU_Perl_hnd);
	if (retval != ERROR_SUCCESS) {
	    HKCU_Perl_hnd = NULL;
	}
	retval = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Perl", 0, KEY_READ, &HKLM_Perl_hnd);
	if (retval != ERROR_SUCCESS) {
	    HKLM_Perl_hnd = NULL;
	}
    }
#endif
}

void
Perl_win32_term(void)
{
    HINTS_REFCNT_TERM;
    OP_REFCNT_TERM;
    PERLIO_TERM;
    MALLOC_TERM;
    LOCALE_TERM;
#ifndef WIN32_NO_REGISTRY
    /* handles might be NULL, RegCloseKey then returns ERROR_INVALID_HANDLE
       but no point of checking and we can't die() at this point */
    RegCloseKey(HKLM_Perl_hnd);
    RegCloseKey(HKCU_Perl_hnd);
    /* the handles are in an undefined state until the next PERL_SYS_INIT3 */
#endif
}

void
win32_get_child_IO(child_IO_table* ptbl)
{
    ptbl->childStdIn	= GetStdHandle(STD_INPUT_HANDLE);
    ptbl->childStdOut	= GetStdHandle(STD_OUTPUT_HANDLE);
    ptbl->childStdErr	= GetStdHandle(STD_ERROR_HANDLE);
}

Sighandler_t
win32_signal(int sig, Sighandler_t subcode)
{
    dTHXa(NULL);
    if (sig < SIG_SIZE) {
	int save_errno = errno;
	Sighandler_t result;
#ifdef SET_INVALID_PARAMETER_HANDLER
	/* Silence our invalid parameter handler since we expect to make some
	 * calls with invalid signal numbers giving a SIG_ERR result. */
	BOOL oldvalue = set_silent_invalid_parameter_handler(TRUE);
#endif
	result = signal(sig, subcode);
#ifdef SET_INVALID_PARAMETER_HANDLER
	set_silent_invalid_parameter_handler(oldvalue);
#endif
	aTHXa(PERL_GET_THX);
	if (result == SIG_ERR) {
	    result = w32_sighandler[sig];
	    errno = save_errno;
	}
	w32_sighandler[sig] = subcode;
	return result;
    }
    else {
	errno = EINVAL;
	return SIG_ERR;
    }
}

/* The PerlMessageWindowClass's WindowProc */
LRESULT CALLBACK
win32_message_window_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    return win32_process_message(hwnd, msg, wParam, lParam) ?
        0 : DefWindowProc(hwnd, msg, wParam, lParam);
}

/* The real message handler. Can be called with
 * hwnd == NULL to process our thread messages. Returns TRUE for any messages
 * that it processes */
static LRESULT
win32_process_message(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    /* BEWARE. The context retrieved using dTHX; is the context of the
     * 'parent' thread during the CreateWindow() phase - i.e. for all messages
     * up to and including WM_CREATE.  If it ever happens that you need the
     * 'child' context before this, then it needs to be passed into
     * win32_create_message_window(), and passed to the WM_NCCREATE handler
     * from the lparam of CreateWindow().  It could then be stored/retrieved
     * using [GS]etWindowLongPtr(... GWLP_USERDATA ...), possibly eliminating
     * the dTHX calls here. */
    /* XXX For now it is assumed that the overhead of the dTHX; for what
     * are relativley infrequent code-paths, is better than the added
     * complexity of getting the correct context passed into
     * win32_create_message_window() */
    dTHX;

    switch(msg) {

#ifdef USE_ITHREADS
        case WM_USER_MESSAGE: {
            long child = find_pseudo_pid(aTHX_ (int)wParam);
            if (child >= 0) {
                w32_pseudo_child_message_hwnds[child] = (HWND)lParam;
                return 1;
            }
            break;
        }
#endif

        case WM_USER_KILL: {
            /* We use WM_USER_KILL to fake kill() with other signals */
            int sig = (int)wParam;
            if (do_raise(aTHX_ sig))
                sig_terminate(aTHX_ sig);

            return 1;
        }

        case WM_TIMER: {
            /* alarm() is a one-shot but SetTimer() repeats so kill it */
            if (w32_timerid && w32_timerid==(UINT)wParam) {
                KillTimer(w32_message_hwnd, w32_timerid);
                w32_timerid=0;

                /* Now fake a call to signal handler */
                if (do_raise(aTHX_ 14))
                    sig_terminate(aTHX_ 14);

                return 1;
            }
            break;
        }

        default:
            break;

    } /* switch */

    /* Above or other stuff may have set a signal flag, and we may not have
     * been called from win32_async_check() (e.g. some other GUI's message
     * loop.  BUT DON'T dispatch signals here: If someone has set a SIGALRM
     * handler that die's, and the message loop that calls here is wrapped
     * in an eval, then you may well end up with orphaned windows - signals
     * are dispatched by win32_async_check() */

    return 0;
}

void
win32_create_message_window_class(void)
{
    /* create the window class for "message only" windows */
    WNDCLASS wc;

    Zero(&wc, 1, wc);
    wc.lpfnWndProc = win32_message_window_proc;
    wc.hInstance = (HINSTANCE)GetModuleHandle(NULL);
    wc.lpszClassName = "PerlMessageWindowClass";

    /* second and subsequent calls will fail, but class
     * will already be registered */
    RegisterClass(&wc);
}

HWND
win32_create_message_window(void)
{
    win32_create_message_window_class();
    return CreateWindow("PerlMessageWindowClass", "PerlMessageWindow",
                        0, 0, 0, 0, 0, HWND_MESSAGE, NULL, NULL, NULL);
}

#ifdef HAVE_INTERP_INTERN

static void
win32_csighandler(int sig)
{
#if 0
    dTHXa(PERL_GET_SIG_CONTEXT);
    Perl_warn(aTHX_ "Got signal %d",sig);
#endif
    /* Does nothing */
}

#if defined(__MINGW32__) && defined(__cplusplus)
#define CAST_HWND__(x) (HWND__*)(x)
#else
#define CAST_HWND__(x) x
#endif

void
Perl_sys_intern_init(pTHX)
{
    int i;

    w32_perlshell_tokens	= NULL;
    w32_perlshell_vec		= (char**)NULL;
    w32_perlshell_items		= 0;
    w32_fdpid			= newAV();
    Newx(w32_children, 1, child_tab);
    w32_num_children		= 0;
#  ifdef USE_ITHREADS
    w32_pseudo_id		= 0;
    Newx(w32_pseudo_children, 1, pseudo_child_tab);
    w32_num_pseudo_children	= 0;
#  endif
    w32_timerid                 = 0;
    w32_message_hwnd            = CAST_HWND__(INVALID_HANDLE_VALUE);
    w32_poll_count              = 0;
#ifdef PERL_IS_MINIPERL
    w32_sloppystat              = TRUE;
#else
    w32_sloppystat              = FALSE;
#endif
    for (i=0; i < SIG_SIZE; i++) {
    	w32_sighandler[i] = SIG_DFL;
    }
#  ifdef MULTIPLICITY
    if (my_perl == PL_curinterp) {
#  else
    {
#  endif
	/* Force C runtime signal stuff to set its console handler */
	signal(SIGINT,win32_csighandler);
	signal(SIGBREAK,win32_csighandler);

        /* We spawn asynchronous processes with the CREATE_NEW_PROCESS_GROUP
         * flag.  This has the side-effect of disabling Ctrl-C events in all
         * processes in this group.
         * We re-enable Ctrl-C handling by calling SetConsoleCtrlHandler()
         * with a NULL handler.
         */
        SetConsoleCtrlHandler(NULL,FALSE);

	/* Push our handler on top */
	SetConsoleCtrlHandler(win32_ctrlhandler,TRUE);
    }
}

void
Perl_sys_intern_clear(pTHX)
{
    Safefree(w32_perlshell_tokens);
    Safefree(w32_perlshell_vec);
    /* NOTE: w32_fdpid is freed by sv_clean_all() */
    Safefree(w32_children);
    if (w32_timerid) {
    	KillTimer(w32_message_hwnd, w32_timerid);
    	w32_timerid = 0;
    }
    if (w32_message_hwnd != NULL && w32_message_hwnd != INVALID_HANDLE_VALUE)
        DestroyWindow(w32_message_hwnd);
#  ifdef MULTIPLICITY
    if (my_perl == PL_curinterp) {
#  else
    {
#  endif
	SetConsoleCtrlHandler(win32_ctrlhandler,FALSE);
    }
#  ifdef USE_ITHREADS
    Safefree(w32_pseudo_children);
#  endif
}

#  ifdef USE_ITHREADS

void
Perl_sys_intern_dup(pTHX_ struct interp_intern *src, struct interp_intern *dst)
{
    PERL_ARGS_ASSERT_SYS_INTERN_DUP;

    dst->perlshell_tokens	= NULL;
    dst->perlshell_vec		= (char**)NULL;
    dst->perlshell_items	= 0;
    dst->fdpid			= newAV();
    Newxz(dst->children, 1, child_tab);
    dst->pseudo_id		= 0;
    Newxz(dst->pseudo_children, 1, pseudo_child_tab);
    dst->timerid                = 0;
    dst->message_hwnd		= CAST_HWND__(INVALID_HANDLE_VALUE);
    dst->poll_count             = 0;
    dst->sloppystat             = src->sloppystat;
    Copy(src->sigtable,dst->sigtable,SIG_SIZE,Sighandler_t);
}
#  endif /* USE_ITHREADS */
#endif /* HAVE_INTERP_INTERN */
@


1.17
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d45 2
a46 3
#if !defined(PERLIO_IS_STDIO)
#  define PerlIO FILE
#endif
a90 6
#  undef win32_get_privlib
#  define win32_get_privlib g_win32_get_privlib
#  undef win32_get_sitelib
#  define win32_get_sitelib g_win32_get_sitelib
#  undef win32_get_vendorlib
#  define win32_get_vendorlib g_win32_get_vendorlib
d117 1
d120 2
d124 2
a125 1
static char*	win32_get_xlib(const char *pl, const char *xlib,
d127 1
d137 2
d149 2
a150 2
			const char * const *args);
static char*	qualified_path(const char *cmd);
d175 6
d268 1
d271 1
a271 1
get_regstr_from(HKEY hkey, const char *valuename, SV **svp)
a273 1
    HKEY handle;
a274 1
    const char *subkey = "Software\\Perl";
d277 1
d279 13
a291 17
    retval = RegOpenKeyEx(hkey, subkey, 0, KEY_READ, &handle);
    if (retval == ERROR_SUCCESS) {
	DWORD datalen;
	retval = RegQueryValueEx(handle, valuename, 0, &type, NULL, &datalen);
	if (retval == ERROR_SUCCESS
	    && (type == REG_SZ || type == REG_EXPAND_SZ))
	{
	    dTHX;
	    if (!*svp)
		*svp = sv_2mortal(newSVpvn("",0));
	    SvGROW(*svp, datalen);
	    retval = RegQueryValueEx(handle, valuename, 0, NULL,
				     (PBYTE)SvPVX(*svp), &datalen);
	    if (retval == ERROR_SUCCESS) {
		str = SvPVX(*svp);
		SvCUR_set(*svp,datalen-1);
	    }
a292 1
	RegCloseKey(handle);
d301 13
a313 3
    char *str = get_regstr_from(HKEY_CURRENT_USER, valuename, svp);
    if (!str)
	str = get_regstr_from(HKEY_LOCAL_MACHINE, valuename, svp);
d316 1
d373 1
a373 1
	    *prev_pathp = sv_2mortal(newSVpvn("",0));
d375 1
a375 1
	    sv_catpvn(*prev_pathp, ";", 1);
d386 1
a386 1
win32_get_privlib(const char *pl, STRLEN *const len)
d389 2
a391 1
    SV *sv = NULL;
d397 1
d404 2
a405 2
win32_get_xlib(const char *pl, const char *xlib, const char *libname,
	       STRLEN *const len)
d407 1
d409 1
d414 1
d418 1
d425 1
d428 1
d441 1
a441 1
	sv_catpvn(sv1, ";", 1);
d453 1
a453 1
    return win32_get_xlib(pl, "sitelib", "site", len);
d463 1
a463 1
    return win32_get_xlib(pl, "vendorlib", PERL_VENDORLIB_NAME, len);
a1465 4
    GV          *gv_sloppy = gv_fetchpvs("\027IN32_SLOPPY_STAT",
                                         GV_NOTQUAL, SVt_PV);
    BOOL        sloppy = gv_sloppy && SvTRUE(GvSV(gv_sloppy));

d1506 1
a1506 1
    if (!sloppy) {
d1517 8
d1814 1
a1814 1
	curitem = sv_2mortal(newSVpvn("", 0));
d1848 1
d1855 1
d2171 1
a2171 1
    /* Tell caller to exit thread/process as approriate */
d2257 1
a2257 1
     * or a context switch occured in win32_async_check in PeekMessage, or random
d2962 3
a2964 2
 Perl_croak_nocontext("List form of pipe open not implemented");
 return NULL;
d2967 2
a2968 12
/*
 * a popen() clone that respects PERL5SHELL
 *
 * changed to return PerlIO* rather than FILE * by BKS, 11-11-2000
 */

DllExport PerlIO*
win32_popen(const char *command, const char *mode)
{
#ifdef USE_RTL_POPEN
    return _popen(command, mode);
#else
d2977 1
d3031 23
a3053 2
	if ((childpid = do_spawn2_handles(aTHX_ command, EXECF_SPAWN_NOWAIT, handles)) == -1)
	    goto cleanup;
d3072 1
d3074 13
a3272 1
finish:
d3399 1
a3399 1
    if (!dir) {
d3576 7
d3584 1
a3584 1
qualified_path(const char *cmd)
d3623 10
a3632 4
	    strcpy(curfullcmd, ".exe");
	    res = GetFileAttributes(fullcmd);
	    if (res != 0xFFFFFFFF && !(res & FILE_ATTRIBUTE_DIRECTORY))
		return fullcmd;
d3748 1
a3748 1
    return spawnvp(mode, cmdname, (char * const *)argv);
d3869 1
a3869 1
	    fullcmd = qualified_path(cname);
d3923 1
a3923 1
	return spawnv(P_WAIT, cmdname, argv);
d3925 1
a3925 1
    return execv(cmdname, argv);
d3945 1
a3945 1
    return execvp(cmdname, argv);
d4226 1
a4226 1
	Perl_croak(aTHX_ "usage: Win32::SetChildShowWindow($showwindow)");
d4243 29
d4293 3
d4458 1
a4458 7
        /* We are intentionally leaking the ansi_path string here because
         * the some runtime libraries puts it directly into the environ
         * array.  The Microsoft runtime library seems to make a copy,
         * but will leak the copy should it be replaced again later.
         * Since this code is only called once during PERL_SYS_INIT this
         * shouldn't really matter.
         */
d4509 14
d4532 8
d4721 5
d4793 1
@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d1125 1
d1146 1
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d45 1
a45 1
#if !defined(PERLIO_IS_STDIO) && !defined(USE_SFIO)
d135 4
d142 1
d168 3
d223 29
a251 48
    OSVERSIONINFO osver; /* g_osver may not yet be initialized */
    osver.dwOSVersionInfoSize = sizeof(osver);
    GetVersionEx(&osver);

    if (osver.dwMajorVersion > 4) {
        WCHAR modulename[MAX_PATH];
        WCHAR fullname[MAX_PATH];
        char *ansi;

        DWORD (__stdcall *pfnGetLongPathNameW)(LPCWSTR, LPWSTR, DWORD) =
            (DWORD (__stdcall *)(LPCWSTR, LPWSTR, DWORD))
            GetProcAddress(GetModuleHandle("kernel32.dll"), "GetLongPathNameW");

        GetModuleFileNameW(module, modulename, sizeof(modulename)/sizeof(WCHAR));

        /* Make sure we get an absolute pathname in case the module was loaded
         * explicitly by LoadLibrary() with a relative path. */
        GetFullPathNameW(modulename, sizeof(fullname)/sizeof(WCHAR), fullname, NULL);

        /* Make sure we start with the long path name of the module because we
         * later scan for pathname components to match "5.xx" to locate
         * compatible sitelib directories, and the short pathname might mangle
         * this path segment (e.g. by removing the dot on NTFS to something
         * like "5xx~1.yy") */
        if (pfnGetLongPathNameW)
            pfnGetLongPathNameW(fullname, fullname, sizeof(fullname)/sizeof(WCHAR));

        /* remove \\?\ prefix */
        if (memcmp(fullname, L"\\\\?\\", 4*sizeof(WCHAR)) == 0)
            memmove(fullname, fullname+4, (wcslen(fullname+4)+1)*sizeof(WCHAR));

        ansi = win32_ansipath(fullname);
        my_strlcpy(w32_module_name, ansi, sizeof(w32_module_name));
        win32_free(ansi);
    }
    else {
        GetModuleFileName(module, w32_module_name, sizeof(w32_module_name));

        /* remove \\?\ prefix */
        if (memcmp(w32_module_name, "\\\\?\\", 4) == 0)
            memmove(w32_module_name, w32_module_name+4, strlen(w32_module_name+4)+1);

        /* try to get full path to binary (which may be mangled when perl is
         * run from a 16-bit app) */
        /*PerlIO_printf(Perl_debug_log, "Before %s\n", w32_module_name);*/
        win32_longpath(w32_module_name);
        /*PerlIO_printf(Perl_debug_log, "After  %s\n", w32_module_name);*/
    }
d684 6
a689 1
do_spawn2(pTHX_ const char *cmd, int exectype)
d722 2
a723 2
		status = win32_spawnvp(P_NOWAIT, argv[0],
				       (const char* const*)argv);
d750 2
a751 2
	    status = win32_spawnvp(P_NOWAIT, argv[0],
				   (const char* const*)argv);
d1254 3
a1256 2
int
killpg(int pid, int sig)
d1276 1
a1276 1
                    killed += killpg(entry.th32ProcessID, sig);
d1287 1
d1295 1
a1295 1
        return killpg(pid, -sig);
d1773 2
d2514 1
a2514 1
            errno = WSAEWOULDBLOCK;
d2523 15
d2587 4
d2594 3
a2596 1
 * we have to roll our own.
d2610 12
d2951 1
d2953 1
a2953 1
    int stdfd, oldfd;
a2956 1
    HANDLE old_h;
d2989 4
a2992 5
    /* save the old std handle (this needs to happen before the
     * dup2(), since that might call SetStdHandle() too) */
    OP_REFCNT_LOCK;
    lock_held = 1;
    old_h = GetStdHandle(nhandle);
d2994 10
a3003 2
    /* save current stdfd */
    if ((oldfd = win32_dup(stdfd)) == -1)
d3005 1
a3005 11

    /* make stdfd go to child end of pipe (implicitly closes stdfd) */
    /* stdfd will be inherited by the child */
    if (win32_dup2(p[child], stdfd) == -1)
        goto cleanup;

    /* close the child end in parent */
    win32_close(p[child]);

    /* set the new std handle (in case dup2() above didn't) */
    SetStdHandle(nhandle, (HANDLE)_get_osfhandle(stdfd));
a3009 2
	if ((childpid = do_spawn_nowait((char*)command)) == -1)
	    goto cleanup;
d3011 1
a3011 2
	/* revert stdfd to whatever it was before */
	if (win32_dup2(oldfd, stdfd) == -1)
d3014 1
a3014 10
	/* close saved handle */
	win32_close(oldfd);

	/* restore the old std handle (this needs to happen after the
	 * dup2(), since that might call SetStdHandle() too */
	if (lock_held) {
	    SetStdHandle(nhandle, old_h);
	    OP_REFCNT_UNLOCK;
	    lock_held = 0;
	}
d3029 1
a3029 9
    if (oldfd != -1) {
        win32_dup2(oldfd, stdfd);
        win32_close(oldfd);
    }
    if (lock_held) {
	SetStdHandle(nhandle, old_h);
	OP_REFCNT_UNLOCK;
	lock_held = 0;
    }
d3116 6
d3156 6
d3683 7
d3747 1
d3761 6
a3766 3
    StartupInfo.hStdInput	= tbl.childStdIn;
    StartupInfo.hStdOutput	= tbl.childStdOut;
    StartupInfo.hStdError	= tbl.childStdErr;
a3845 1
#endif
d4185 4
a4188 1
    pfn_init = (void (*)(pTHX))GetProcAddress((HMODULE)w32_perldll_handle, "init_Win32CORE");
d4402 12
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d67 1
a67 6

#if defined(_MSC_VER) || defined(__MINGW32__)
#  include <sys/utime.h>
#else
#  include <utime.h>
#endif
a101 28
static void		get_shell(void);
static long		tokenize(const char *str, char **dest, char ***destv);
static int		do_spawn2(pTHX_ const char *cmd, int exectype);
static BOOL		has_shell_metachars(const char *ptr);
static long		filetime_to_clock(PFILETIME ft);
static BOOL		filetime_from_time(PFILETIME ft, time_t t);
static char *		get_emd_part(SV **leading, STRLEN *const len,
				     char *trailing, ...);
static void		remove_dead_process(long deceased);
static long		find_pid(int pid);
static char *		qualified_path(const char *cmd);
static char *		win32_get_xlib(const char *pl, const char *xlib,
				       const char *libname, STRLEN *const len);
static LRESULT  win32_process_message(HWND hwnd, UINT msg,
                       WPARAM wParam, LPARAM lParam);

#ifdef USE_ITHREADS
static void		remove_dead_pseudo_process(long child);
static long		find_pseudo_pid(int pid);
#endif

START_EXTERN_C
HANDLE	w32_perldll_handle = INVALID_HANDLE_VALUE;
char	w32_module_name[MAX_PATH+1];
END_EXTERN_C

static OSVERSIONINFO g_osver = {0, 0, 0, 0, 0, ""};

d118 64
a181 1
void my_invalid_parameter_handler(const wchar_t* expression,
d188 14
a201 3
    wprintf(L"Invalid parameter detected in function %s."
            L" File: %s Line: %d\n", function, file, line);
    wprintf(L"Expression: %s\n", expression);
d384 1
a384 1
char *
a386 1
    dTHX;
a403 1
    dTHX;
d431 1
d441 1
a441 1
char *
d451 1
a451 1
char *
a545 1
	dTHX;
d547 2
a548 2
	register char *ret;
	register char **retv;
d816 1
a816 1
    dTHX;
d855 1
a925 1
	    dTHX;
a1006 1
    dTHX;
d1020 1
a1020 1
    PerlInterpreter *const to   = PERL_GET_THX;
d1109 1
a1109 1
char *
d1153 1
a1153 1
find_pid(int pid)
a1154 1
    dTHX;
d1179 1
a1179 1
find_pseudo_pid(int pid)
a1180 1
    dTHX;
d1310 44
d1362 1
a1362 1
	child = find_pseudo_pid(-pid);
a1363 1
            HWND hwnd = w32_pseudo_child_message_hwnds[child];
d1366 3
a1368 3
	    case 0:
		/* "Does process exist?" use of kill */
		return 0;
d1370 19
a1388 14
	    case 9:
                /* kill -9 style un-graceful exit */
	    	if (TerminateThread(hProcess, sig)) {
                    /* Allow the scheduler to finish cleaning up the other thread.
                     * Otherwise, if we ExitProcess() before another context switch
                     * happens we will end up with a process exit code of "sig" instead
                     * of our own exit status.
                     * See also: https://rt.cpan.org/Ticket/Display.html?id=66016#txn-908976
                     */
                    Sleep(0);
		    remove_dead_pseudo_process(child);
		    return 0;
	    	}
		break;
d1390 22
a1411 32
	    default: {
                int count = 0;
                /* pseudo-process has not yet properly initialized if hwnd isn't set */
                while (hwnd == INVALID_HANDLE_VALUE && count < 5) {
                    /* Yield and wait for the other thread to send us its message_hwnd */
                    Sleep(0);
                    win32_async_check(aTHX);
		    hwnd = w32_pseudo_child_message_hwnds[child];
                    ++count;
                }
                if (hwnd != INVALID_HANDLE_VALUE) {
                    /* We fake signals to pseudo-processes using Win32
                     * message queue.  In Win9X the pids are negative already. */
                    if ((hwnd != NULL && PostMessage(hwnd, WM_USER_KILL, sig, 0)) ||
                        PostThreadMessage(-pid, WM_USER_KILL, sig, 0))
                    {
                        /* Don't wait for child process to terminate after we send a SIGTERM
                         * because the child may be blocked in a system call and never receive
                         * the signal.
                         */
                        if (sig == SIGTERM) {
                            Sleep(0);
                            w32_pseudo_child_sigterm[child] = 1;
                        }
                        /* It might be us ... */
                        PERL_ASYNC_CHECK();
                        return 0;
                    }
                }
		break;
            }
            } /* switch */
d1417 1
a1417 1
	child = find_pid(pid);
a1440 1
    dTHX;
d1443 1
d1664 2
a1665 7
    if (PL_curinterp) {
        dTHX;
        /* Can't use PerlIO to write as it allocates memory */
        PerlLIO_write(PerlIO_fileno(Perl_error_log),
                      PL_no_mem, strlen(PL_no_mem));
        my_exit(1);
    }
d1669 26
d1720 1
a1720 1
    name = win32_malloc(len);
d1729 1
a1729 1
            WCHAR *shortname = win32_malloc(shortlen*sizeof(WCHAR));
d1736 1
a1736 1
            name = win32_realloc(name, len);
d1747 33
a1839 1
    dTHX;
d1845 1
a1845 1
        Newx(curitem,strlen(name)+1,char);
d1869 1
a1869 1
        Safefree(curitem);
d2215 2
a2216 1
    DWORD ticks = 0;
d2218 24
a2241 5
	ticks = GetTickCount();
	timeout += ticks;
    }
    while (1) {
	DWORD result = MsgWaitForMultipleObjects(count,handles,FALSE,timeout-ticks, QS_POSTMESSAGE|QS_TIMER|QS_SENDMESSAGE);
d2251 3
a2253 2
	    ticks = GetTickCount();
        }
d2263 3
d2267 3
a2269 3
    ticks = timeout - ticks;
    /* If we are past the end say zero */
    return (ticks > 0) ? ticks : 0;
d2273 1
a2273 1
win32_internal_wait(int *status, DWORD timeout)
a2277 1
    dTHX;
d2343 1
a2343 1
	return win32_internal_wait(status, timeout);
d2346 1
a2346 1
	child = find_pseudo_pid(-pid);
d2370 1
a2370 1
	child = find_pid(pid);
d2415 2
a2416 1
    return win32_internal_wait(status, INFINITE);
d2424 5
a2428 1
    return win32_msgwait(aTHX_ 0, NULL, t*1000, NULL)/1000;
d2588 1
a2588 1
        dTHX;
d2592 1
d2686 1
a2686 1
    dTHX;
d2695 1
a2702 5
#ifndef USE_SOCKETS_AS_HANDLES
#undef fdopen
#define fdopen my_fdopen
#endif

a2705 1
    dTHX;
d2717 1
a2717 1
    dTHX;
d2721 1
d2728 3
d2732 1
a2840 1
    dTHX;
d2857 1
d2903 1
a2903 2
 dTHX;
 Perl_croak(aTHX_ "List form of pipe open not implemented");
a2918 1
    dTHX;
d3071 1
a3071 1
    dTHX;
d3077 1
a3077 1
	(wcscpy(wOldName, PerlDir_mapW(wOldName)),
d3082 31
a3112 1
    errno = (GetLastError() == ERROR_FILE_NOT_FOUND) ? ENOENT : EINVAL;
d3229 1
a3229 1
    dTHX;
d3240 1
d3250 3
d3254 1
a3324 1
    dTHX;
d3350 1
a3350 1
    dTHX;
a3504 1
    dTHX;
d3521 4
a3524 2
    pathstr = PerlEnv_getenv("PATH");

a3629 1
    dTHX;
a3641 1
    dTHX;
d3663 1
a3663 1
    dTHX;
d3696 1
d4097 1
a4097 1
    dTHX;
d4099 1
a4099 1
    char *first;
d4117 1
d4149 1
a4149 1
    dTHX;
d4153 1
d4156 1
d4159 3
d4249 1
a4249 1
    wide_path = win32_malloc(len*sizeof(WCHAR));
d4252 4
d4259 1
a4259 1
        wide_path = win32_realloc(wide_path, len*sizeof(WCHAR));
d4288 1
a4288 1
            ansi_path = win32_realloc(ansi_path, newlen+1);
d4297 1
a4297 1
            ansi_path = win32_malloc(5+len+1);
a4375 1
    dTHX;
d4393 1
a4393 1
    dTHX;
d4396 11
a4406 1
	Sighandler_t result = signal(sig, subcode);
d4446 1
d4452 1
a4452 1
            long child = find_pseudo_pid((int)wParam);
a4453 1
                dTHX;
a4461 1
            dTHX;
a4470 1
            dTHX;
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d14 1
d16 5
a20 1
#define Win32_Winsock
d22 1
d24 1
d26 1
a26 1
#  define HWND_MESSAGE     ((HWND)-3)
d28 5
d34 1
a34 1
#  define WC_NO_BEST_FIT_CHARS 0x00000400 /* requires Windows 2000 or later */
d36 1
a42 24
#define SystemProcessesAndThreadsInformation 5

/* Inline some definitions from the DDK */
typedef struct {
    USHORT	    Length;
    USHORT	    MaximumLength;
    PWSTR	    Buffer;
}   UNICODE_STRING;

typedef struct {
    ULONG           NextEntryDelta;
    ULONG	    ThreadCount;
    ULONG	    Reserved1[6];
    LARGE_INTEGER   CreateTime;
    LARGE_INTEGER   UserTime;
    LARGE_INTEGER   KernelTime;
    UNICODE_STRING  ProcessName;
    LONG	    BasePriority;
    ULONG	    ProcessId;
    ULONG	    InheritedFromProcessId;
    /* Remainder of the structure depends on the Windows version,
     * but we don't need those additional fields anyways... */
}   SYSTEM_PROCESSES;

d46 1
a46 1
#define PerlIO FILE
d60 1
a60 1
#include <assert.h>
d62 1
d67 1
d69 1
a69 1
#include <sys/utime.h>
d71 1
a71 1
#include <utime.h>
d73 1
a91 5
#if defined(__BORLANDC__)
#  define _stat stat
#  define _utimbuf utimbuf
#endif

a134 15
static HANDLE (WINAPI *pfnCreateToolhelp32Snapshot)(DWORD, DWORD) = NULL;
static BOOL   (WINAPI *pfnProcess32First)(HANDLE, PROCESSENTRY32*) = NULL;
static BOOL   (WINAPI *pfnProcess32Next)(HANDLE, PROCESSENTRY32*) = NULL;
static LONG   (WINAPI *pfnZwQuerySystemInformation)(UINT, PVOID, ULONG, PULONG);

#ifdef __BORLANDC__
/* Silence STDERR grumblings from Borland's math library. */
DllExport int
_matherr(struct _exception *a)
{
    PERL_UNUSED_VAR(a);
    return 1;
}
#endif

a164 18
int
IsWin95(void)
{
    return (g_osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
}

int
IsWinNT(void)
{
    return (g_osver.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

int
IsWin2000(void)
{
    return (g_osver.dwMajorVersion > 4);
}

a464 16
#ifdef FIXCMD
#define fixcmd(x)   {					\
			char *pspace = strchr((x),' ');	\
			if (pspace) {			\
			    char *p = (x);		\
			    while (p < pspace) {	\
				if (*p == '/')		\
				    *p = '\\';		\
				p++;			\
			    }				\
			}				\
		    }
#else
#define fixcmd(x)
#endif
    fixcmd(cmd);
a484 1
    int pid;
d490 1
a490 7
    pid = _getpid();
    /* Windows 9x appears to always reports a pid for threads and processes
     * that has the high bit set. So we treat the lower 31 bits as the
     * "real" PID for Perl's purposes. */
    if (IsWin95() && pid < 0)
	pid = -pid;
    return pid;
d558 1
a558 2
	const char* defaultshell = (IsWinNT()
				    ? "cmd.exe /x/d/c" : "command.com /c");
d782 1
a782 2
    Stat_t		sbuf;
    WIN32_FIND_DATAA	aFindData;
a783 1
    bool                using_wide;
d785 1
a785 1
    char		*ptr;
d788 2
a789 1
    if (len > MAX_PATH)
d791 3
a793 3

    /* check to see if filename is a directory */
    if (win32_stat(filename, &sbuf) < 0 || !S_ISDIR(sbuf.st_mode))
d795 1
d815 3
a817 9
    if (IsWin2000()) {
        WCHAR wscanname[sizeof(scanname)];
        MultiByteToWideChar(CP_ACP, 0, scanname, -1, wscanname, sizeof(wscanname)/sizeof(WCHAR));
	dirp->handle = FindFirstFileW(PerlDir_mapW(wscanname), &wFindData);
        using_wide = TRUE;
    }
    else {
 	dirp->handle = FindFirstFileA(PerlDir_mapA(scanname), &aFindData);
    }
d839 5
a843 2
    if (using_wide) {
        BOOL use_default = FALSE;
d845 2
a846 11
                            wFindData.cFileName, -1,
                            buffer, sizeof(buffer), NULL, &use_default);
        if (use_default && *wFindData.cAlternateFileName) {
            WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                                wFindData.cAlternateFileName, -1,
                                buffer, sizeof(buffer), NULL, NULL);
        }
        ptr = buffer;
    }
    else {
        ptr = aFindData.cFileName;
d848 1
d852 1
a852 1
    idx = strlen(ptr)+1;
d858 1
a858 1
    strcpy(dirp->start, ptr);
a887 1
            WIN32_FIND_DATAA aFindData;
a888 1
            char *ptr;
d890 3
d896 1
a896 1
	    if (IsWin2000()) {
a908 1
                    ptr = buffer;
a910 4
            else {
                res = FindNextFileA(dirp->handle, &aFindData);
                ptr = aFindData.cFileName;
            }
d913 1
a913 1
		long newsize = endpos + strlen(ptr) + 1;
d922 1
a922 1
		strcpy(dirp->start + endpos, ptr);
d926 1
a926 1
	    else
d928 5
d944 1
a944 1
    return (dirp->curr - dirp->start);
d954 1
a954 1
    dirp->curr = dirp->start + loc;
d976 44
d1165 2
d1170 22
d1224 2
a1225 3
/* Traverse process tree using ToolHelp functions */
static int
kill_process_tree_toolhelp(DWORD pid, int sig)
d1237 1
a1237 1
    snapshot_handle = pfnCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
d1242 1
a1242 1
        if (pfnProcess32First(snapshot_handle, &entry)) {
d1244 2
a1245 2
                if (entry.th32ParentProcessID == pid)
                    killed += kill_process_tree_toolhelp(entry.th32ProcessID, sig);
d1248 1
a1248 1
            while (pfnProcess32Next(snapshot_handle, &entry));
a1255 56
/* Traverse process tree using undocumented system information structures.
 * This is only necessary on Windows NT, which lacks the ToolHelp functions.
 */
static int
kill_process_tree_sysinfo(SYSTEM_PROCESSES *process_info, DWORD pid, int sig)
{
    HANDLE process_handle;
    SYSTEM_PROCESSES *p = process_info;
    int killed = 0;

    process_handle = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
    if (process_handle == NULL)
        return 0;

    killed += terminate_process(pid, process_handle, sig);

    while (1) {
        if (p->InheritedFromProcessId == (DWORD)pid)
            killed += kill_process_tree_sysinfo(process_info, p->ProcessId, sig);

        if (p->NextEntryDelta == 0)
            break;

        p = (SYSTEM_PROCESSES*)((char*)p + p->NextEntryDelta);
    }

    CloseHandle(process_handle);
    return killed;
}

int
killpg(int pid, int sig)
{
    /* Use "documented" method whenever available */
    if (pfnCreateToolhelp32Snapshot && pfnProcess32First && pfnProcess32Next) {
        return kill_process_tree_toolhelp((DWORD)pid, sig);
    }

    /* Fall back to undocumented Windows internals on Windows NT */
    if (pfnZwQuerySystemInformation) {
        dTHX;
        char *buffer;
        DWORD size = 0;

        pfnZwQuerySystemInformation(SystemProcessesAndThreadsInformation, NULL, 0, &size);
        Newx(buffer, size, char);

        if (pfnZwQuerySystemInformation(SystemProcessesAndThreadsInformation, buffer, size, NULL) >= 0) {
            int killed = kill_process_tree_sysinfo((SYSTEM_PROCESSES*)buffer, (DWORD)pid, sig);
            Safefree(buffer);
            return killed;
        }
    }
    return 0;
}

d1294 7
d1320 1
a1320 1
                        PostThreadMessage(IsWin95() ? pid : -pid, WM_USER_KILL, sig, 0))
d1322 8
a1338 4
	else if (IsWin95()) {
	    pid = -pid;
	    goto alien_process;
	}
d1356 1
a1356 2
alien_process:
            if (my_kill((IsWin95() ? -pid : pid), sig))
d1471 2
a1472 2
	     * directories with the read-only attribute set. Borland (at least)
	     * switches it on for directories, which is technically correct
a1480 23
#ifdef __BORLANDC__
	if (S_ISDIR(sbuf->st_mode)) {
	    sbuf->st_mode |= S_IEXEC;
	}
	else if (S_ISREG(sbuf->st_mode)) {
	    int perms;
	    if (l >= 4 && path[l-4] == '.') {
		const char *e = path + l - 3;
		if (strnicmp(e,"exe",3)
		    && strnicmp(e,"bat",3)
		    && strnicmp(e,"com",3)
		    && (IsWin95() || strnicmp(e,"cmd",3)))
		    sbuf->st_mode &= ~S_IEXEC;
		else
		    sbuf->st_mode |= S_IEXEC;
	    }
	    else
		sbuf->st_mode &= ~S_IEXEC;
	    /* Propagate permissions to _group_ and _others_ */
	    perms = sbuf->st_mode & (S_IREAD|S_IWRITE|S_IEXEC);
	    sbuf->st_mode |= (perms>>3) | (perms>>6);
	}
#endif
d1658 1
d1671 31
a1701 4
	/* allow any environment variables that begin with 'PERL'
	   to be stored in the registry */
	if (strncmp(name, "PERL", 4) == 0)
	    (void)get_regstr(name, &curitem);
d1842 1
a1842 1
    if (rc == 0 || errno != EACCES /* || !IsWinNT() */)
d1962 1
a1962 2
#if (defined(__BORLANDC__)&&(__BORLANDC__<=0x520)) \
 || (defined(__MINGW32__) && !defined(_ANONYMOUS_UNION) && !defined(__MINGW_EXTENSION))
a1969 15
	case PROCESSOR_ARCHITECTURE_MIPS:
	    arch = "mips"; break;
	case PROCESSOR_ARCHITECTURE_ALPHA:
	    arch = "alpha"; break;
	case PROCESSOR_ARCHITECTURE_PPC:
	    arch = "ppc"; break;
#ifdef PROCESSOR_ARCHITECTURE_SHX
	case PROCESSOR_ARCHITECTURE_SHX:
	    arch = "shx"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_ARM
	case PROCESSOR_ARCHITECTURE_ARM:
	    arch = "arm"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_IA64
a1971 10
#endif
#ifdef PROCESSOR_ARCHITECTURE_ALPHA64
	case PROCESSOR_ARCHITECTURE_ALPHA64:
	    arch = "alpha64"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_MSIL
	case PROCESSOR_ARCHITECTURE_MSIL:
	    arch = "msil"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_AMD64
a1973 6
#endif
#ifdef PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
	case PROCESSOR_ARCHITECTURE_IA32_ON_WIN64:
	    arch = "ia32-64"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_UNKNOWN
a1975 1
#endif
a2214 4
	else if (IsWin95()) {
	    pid = -pid;
	    goto alien_process;
	}
d2239 1
a2239 3
alien_process:
	    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE,
				   (IsWin95() ? -pid : pid));
a2306 1
#ifdef HAVE_DES_FCRYPT
a2307 1
#endif
a2312 1
#ifdef HAVE_DES_FCRYPT
a2313 4
#else
    Perl_croak(aTHX_ "The crypt() function is unimplemented due to excessive paranoia.");
    return NULL;
#endif
a2315 90
#ifdef USE_FIXED_OSFHANDLE

#define FOPEN			0x01	/* file handle open */
#define FNOINHERIT		0x10	/* file handle opened O_NOINHERIT */
#define FAPPEND			0x20	/* file handle opened O_APPEND */
#define FDEV			0x40	/* file handle refers to device */
#define FTEXT			0x80	/* file handle is in text mode */

/***
*int my_open_osfhandle(intptr_t osfhandle, int flags) - open C Runtime file handle
*
*Purpose:
*       This function allocates a free C Runtime file handle and associates
*       it with the Win32 HANDLE specified by the first parameter. This is a
*	temperary fix for WIN95's brain damage GetFileType() error on socket
*	we just bypass that call for socket
*
*	This works with MSVC++ 4.0+ or GCC/Mingw32
*
*Entry:
*       intptr_t osfhandle - Win32 HANDLE to associate with C Runtime file handle.
*       int flags      - flags to associate with C Runtime file handle.
*
*Exit:
*       returns index of entry in fh, if successful
*       return -1, if no free entry is found
*
*Exceptions:
*
*******************************************************************************/

/*
 * we fake up some parts of the CRT that aren't exported by MSVCRT.dll
 * this lets sockets work on Win9X with GCC and should fix the problems
 * with perl95.exe
 *	-- BKS, 1-23-2000
*/

/* create an ioinfo entry, kill its handle, and steal the entry */

static int
_alloc_osfhnd(void)
{
    HANDLE hF = CreateFile("NUL", 0, 0, NULL, OPEN_ALWAYS, 0, NULL);
    int fh = _open_osfhandle((intptr_t)hF, 0);
    CloseHandle(hF);
    if (fh == -1)
        return fh;
    EnterCriticalSection(&(_pioinfo(fh)->lock));
    return fh;
}

static int
my_open_osfhandle(intptr_t osfhandle, int flags)
{
    int fh;
    char fileflags;		/* _osfile flags */

    /* copy relevant flags from second parameter */
    fileflags = FDEV;

    if (flags & O_APPEND)
	fileflags |= FAPPEND;

    if (flags & O_TEXT)
	fileflags |= FTEXT;

    if (flags & O_NOINHERIT)
	fileflags |= FNOINHERIT;

    /* attempt to allocate a C Runtime file handle */
    if ((fh = _alloc_osfhnd()) == -1) {
	errno = EMFILE;		/* too many open files */
	_doserrno = 0L;		/* not an OS error */
	return -1;		/* return error to caller */
    }

    /* the file is open. now, set the info in _osfhnd array */
    _set_osfhnd(fh, osfhandle);

    fileflags |= FOPEN;		/* mark as open */

    _osfile(fh) = fileflags;	/* set osfile entry */
    LeaveCriticalSection(&_pioinfo(fh)->lock);

    return fh;			/* return handle */
}

#endif	/* USE_FIXED_OSFHANDLE */

a2326 5
    if (!IsWinNT()) {
	dTHX;
	Perl_croak_nocontext("flock() unimplemented on this platform");
	return -1;
    }
d2428 1
a2428 1
#if !defined __BORLANDC__ && !defined __MINGW32__      /* compiler intolerance */
a2625 3
#if defined(__BORLANDC__) /* buk */
    return win32_tell( fileno( pf ) );
#else
a2629 1
#endif
a2638 7
#if defined(__BORLANDC__) /* buk */
    return win32_lseek(
        fileno(pf),
        offset,
        origin
        );
#else
a2657 1
#endif
a2665 7
#if defined(__BORLANDC__) && defined(USE_LARGE_FILES) /* buk */
    if( win32_tell(fileno(pf)) == -1L ) {
        errno = EBADF;
        return -1;
    }
    return 0;
#else
a2666 1
#endif
a2671 3
#if defined(__BORLANDC__) && defined(USE_LARGE_FILES) /* buk */
    return win32_lseek(fileno(pf), *p, SEEK_CUR);
#else
a2672 1
#endif
a2701 3
#if defined(__BORLANDC__)
        	    setmode(fd,O_BINARY);
#endif
d2731 2
a2732 22
#ifdef __BORLANDC__
    /* A file designated by filehandle is not shown as accessible
     * for write operations, probably because it is opened for reading.
     * --Vadim Konovalov
     */
    BY_HANDLE_FILE_INFORMATION bhfi;
#if defined(WIN64) || defined(USE_LARGE_FILES)    
    /* Borland 5.5.1 has a 64-bit stat, but only a 32-bit fstat */
    struct stat tmp;
    int rc = fstat(fd,&tmp);
   
    sbufptr->st_dev   = tmp.st_dev;
    sbufptr->st_ino   = tmp.st_ino;
    sbufptr->st_mode  = tmp.st_mode;
    sbufptr->st_nlink = tmp.st_nlink;
    sbufptr->st_uid   = tmp.st_uid;
    sbufptr->st_gid   = tmp.st_gid;
    sbufptr->st_rdev  = tmp.st_rdev;
    sbufptr->st_size  = tmp.st_size;
    sbufptr->st_atime = tmp.st_atime;
    sbufptr->st_mtime = tmp.st_mtime;
    sbufptr->st_ctime = tmp.st_ctime;
d2734 1
a2734 17
    int rc = fstat(fd,sbufptr);
#endif       

    if (GetFileInformationByHandle((HANDLE)_get_osfhandle(fd), &bhfi)) {
#if defined(WIN64) || defined(USE_LARGE_FILES)    
        sbufptr->st_size = ((__int64)bhfi.nFileSizeHigh << 32) | bhfi.nFileSizeLow ;
#endif
        sbufptr->st_mode &= 0xFE00;
        if (bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            sbufptr->st_mode |= (S_IREAD + (S_IREAD >> 3) + (S_IREAD >> 6));
        else
            sbufptr->st_mode |= ((S_IREAD|S_IWRITE) + ((S_IREAD|S_IWRITE) >> 3)
              + ((S_IREAD|S_IWRITE) >> 6));
    }
    return rc;
#else
    return my_fstat(fd,sbufptr);
a2913 58
static BOOL WINAPI
Nt4CreateHardLinkW(
    LPCWSTR lpFileName,
    LPCWSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    HANDLE handle;
    WCHAR wFullName[MAX_PATH+1];
    LPVOID lpContext = NULL;
    WIN32_STREAM_ID StreamId;
    DWORD dwSize = (char*)&StreamId.cStreamName - (char*)&StreamId;
    DWORD dwWritten;
    DWORD dwLen;
    BOOL bSuccess;

    BOOL (__stdcall *pfnBackupWrite)(HANDLE, LPBYTE, DWORD, LPDWORD,
				     BOOL, BOOL, LPVOID*) =
	(BOOL (__stdcall *)(HANDLE, LPBYTE, DWORD, LPDWORD,
			    BOOL, BOOL, LPVOID*))
	GetProcAddress(GetModuleHandle("kernel32.dll"), "BackupWrite");
    if (pfnBackupWrite == NULL)
	return 0;

    dwLen = GetFullPathNameW(lpFileName, MAX_PATH, wFullName, NULL);
    if (dwLen == 0)
	return 0;
    dwLen = (dwLen+1)*sizeof(WCHAR);

    handle = CreateFileW(lpExistingFileName, FILE_WRITE_ATTRIBUTES,
			 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			 NULL, OPEN_EXISTING, 0, NULL);
    if (handle == INVALID_HANDLE_VALUE)
	return 0;

    StreamId.dwStreamId = BACKUP_LINK;
    StreamId.dwStreamAttributes = 0;
    StreamId.dwStreamNameSize = 0;
#if defined(__BORLANDC__) \
 ||(defined(__MINGW32__) && !defined(_ANONYMOUS_UNION))
    StreamId.Size.u.HighPart = 0;
    StreamId.Size.u.LowPart = dwLen;
#else
    StreamId.Size.HighPart = 0;
    StreamId.Size.LowPart = dwLen;
#endif

    bSuccess = pfnBackupWrite(handle, (LPBYTE)&StreamId, dwSize, &dwWritten,
			      FALSE, FALSE, &lpContext);
    if (bSuccess) {
	bSuccess = pfnBackupWrite(handle, (LPBYTE)wFullName, dwLen, &dwWritten,
				  FALSE, FALSE, &lpContext);
	pfnBackupWrite(handle, NULL, 0, &dwWritten, TRUE, FALSE, &lpContext);
    }

    CloseHandle(handle);
    return bSuccess;
}

a2917 1
    BOOL (__stdcall *pfnCreateHardLinkW)(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);
a2920 9
    if (IsWin95())
	Perl_croak(aTHX_ PL_no_func, "link");

    pfnCreateHardLinkW =
	(BOOL (__stdcall *)(LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES))
	GetProcAddress(GetModuleHandle("kernel32.dll"), "CreateHardLinkW");
    if (pfnCreateHardLinkW == NULL)
	pfnCreateHardLinkW = Nt4CreateHardLinkW;

d2924 1
a2924 1
        pfnCreateHardLinkW(PerlDir_mapW(wNewName), wOldName, NULL)))
a2935 1
    char szNewName[MAX_PATH+1];
d2937 1
d2940 23
a2962 102
    /* XXX despite what the documentation says about MoveFileEx(),
     * it doesn't work under Windows95!
     */
    if (IsWinNT()) {
	DWORD dwFlags = MOVEFILE_COPY_ALLOWED;
        if (stricmp(newname, oname))
            dwFlags |= MOVEFILE_REPLACE_EXISTING;
        strcpy(szOldName, PerlDir_mapA(oname));
        bResult = MoveFileExA(szOldName,PerlDir_mapA(newname), dwFlags);
	if (!bResult) {
	    DWORD err = GetLastError();
	    switch (err) {
	    case ERROR_BAD_NET_NAME:
	    case ERROR_BAD_NETPATH:
	    case ERROR_BAD_PATHNAME:
	    case ERROR_FILE_NOT_FOUND:
	    case ERROR_FILENAME_EXCED_RANGE:
	    case ERROR_INVALID_DRIVE:
	    case ERROR_NO_MORE_FILES:
	    case ERROR_PATH_NOT_FOUND:
		errno = ENOENT;
		break;
	    default:
		errno = EACCES;
		break;
	    }
	    return -1;
	}
	return 0;
    }
    else {
	int retval = 0;
	char szTmpName[MAX_PATH+1];
	char dname[MAX_PATH+1];
	char *endname = NULL;
	STRLEN tmplen = 0;
	DWORD from_attr, to_attr;

	strcpy(szOldName, PerlDir_mapA(oname));
	strcpy(szNewName, PerlDir_mapA(newname));

	/* if oname doesn't exist, do nothing */
	from_attr = GetFileAttributes(szOldName);
	if (from_attr == 0xFFFFFFFF) {
	    errno = ENOENT;
	    return -1;
	}

	/* if newname exists, rename it to a temporary name so that we
	 * don't delete it in case oname happens to be the same file
	 * (but perhaps accessed via a different path)
	 */
	to_attr = GetFileAttributes(szNewName);
	if (to_attr != 0xFFFFFFFF) {
	    /* if newname is a directory, we fail
	     * XXX could overcome this with yet more convoluted logic */
	    if (to_attr & FILE_ATTRIBUTE_DIRECTORY) {
		errno = EACCES;
		return -1;
	    }
	    tmplen = strlen(szNewName);
	    strcpy(szTmpName,szNewName);
	    endname = szTmpName+tmplen;
	    for (; endname > szTmpName ; --endname) {
		if (*endname == '/' || *endname == '\\') {
		    *endname = '\0';
		    break;
		}
	    }
	    if (endname > szTmpName)
		endname = strcpy(dname,szTmpName);
	    else
		endname = ".";

	    /* get a temporary filename in same directory
	     * XXX is this really the best we can do? */
	    if (!GetTempFileName((LPCTSTR)endname, "plr", 0, szTmpName)) {
		errno = ENOENT;
		return -1;
	    }
	    DeleteFile(szTmpName);

	    retval = rename(szNewName, szTmpName);
	    if (retval != 0) {
		errno = EACCES;
		return retval;
	    }
	}

	/* rename oname to newname */
	retval = rename(szOldName, szNewName);

	/* if we created a temporary file before ... */
	if (endname != NULL) {
	    /* ...and rename succeeded, delete temporary file/directory */
	    if (retval == 0)
		DeleteFile(szTmpName);
	    /* else restore it to what it was */
	    else
		(void)rename(szTmpName, szNewName);
	}
	return retval;
d2964 1
a3025 15
#if defined(__BORLANDC__) /* buk */
    LARGE_INTEGER pos;
    pos.QuadPart = offset;
    pos.LowPart = SetFilePointer(
        (HANDLE)_get_osfhandle(fd),
        pos.LowPart,
        &pos.HighPart,
        origin
    );
    if (pos.LowPart == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR) {
        pos.QuadPart = -1;
    }

    return pos.QuadPart;
#else
a3026 1
#endif
a3035 16
#if defined(__BORLANDC__) /* buk */
    LARGE_INTEGER pos;
    pos.QuadPart = 0;
    pos.LowPart = SetFilePointer(
        (HANDLE)_get_osfhandle(fd),
        pos.LowPart,
        &pos.HighPart,
        FILE_CURRENT
    );
    if (pos.LowPart == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR) {
        pos.QuadPart = -1;
    }

    return pos.QuadPart;
    /* return tell(fd); */
#else
a3036 1
#endif
a3106 196
#ifdef PERL_MSVCRT_READFIX

#define LF		10	/* line feed */
#define CR		13	/* carriage return */
#define CTRLZ		26      /* ctrl-z means eof for text */
#define FOPEN		0x01	/* file handle open */
#define FEOFLAG		0x02	/* end of file has been encountered */
#define FCRLF		0x04	/* CR-LF across read buffer (in text mode) */
#define FPIPE		0x08	/* file handle refers to a pipe */
#define FAPPEND		0x20	/* file handle opened O_APPEND */
#define FDEV		0x40	/* file handle refers to device */
#define FTEXT		0x80	/* file handle is in text mode */
#define MAX_DESCRIPTOR_COUNT	(64*32) /* this is the maximun that MSVCRT can handle */

int __cdecl
_fixed_read(int fh, void *buf, unsigned cnt)
{
    int bytes_read;                 /* number of bytes read */
    char *buffer;                   /* buffer to read to */
    int os_read;                    /* bytes read on OS call */
    char *p, *q;                    /* pointers into buffer */
    char peekchr;                   /* peek-ahead character */
    ULONG filepos;                  /* file position after seek */
    ULONG dosretval;                /* o.s. return value */

    /* validate handle */
    if (((unsigned)fh >= (unsigned)MAX_DESCRIPTOR_COUNT) ||
         !(_osfile(fh) & FOPEN))
    {
	/* out of range -- return error */
	errno = EBADF;
	_doserrno = 0;  /* not o.s. error */
	return -1;
    }

    /*
     * If lockinitflag is FALSE, assume fd is device
     * lockinitflag is set to TRUE by open.
     */
    if (_pioinfo(fh)->lockinitflag)
	EnterCriticalSection(&(_pioinfo(fh)->lock));  /* lock file */

    bytes_read = 0;                 /* nothing read yet */
    buffer = (char*)buf;

    if (cnt == 0 || (_osfile(fh) & FEOFLAG)) {
        /* nothing to read or at EOF, so return 0 read */
        goto functionexit;
    }

    if ((_osfile(fh) & (FPIPE|FDEV)) && _pipech(fh) != LF) {
        /* a pipe/device and pipe lookahead non-empty: read the lookahead
         * char */
        *buffer++ = _pipech(fh);
        ++bytes_read;
        --cnt;
        _pipech(fh) = LF;           /* mark as empty */
    }

    /* read the data */

    if (!ReadFile((HANDLE)_osfhnd(fh), buffer, cnt, (LPDWORD)&os_read, NULL))
    {
        /* ReadFile has reported an error. recognize two special cases.
         *
         *      1. map ERROR_ACCESS_DENIED to EBADF
         *
         *      2. just return 0 if ERROR_BROKEN_PIPE has occurred. it
         *         means the handle is a read-handle on a pipe for which
         *         all write-handles have been closed and all data has been
         *         read. */

        if ((dosretval = GetLastError()) == ERROR_ACCESS_DENIED) {
            /* wrong read/write mode should return EBADF, not EACCES */
            errno = EBADF;
            _doserrno = dosretval;
            bytes_read = -1;
	    goto functionexit;
        }
        else if (dosretval == ERROR_BROKEN_PIPE) {
            bytes_read = 0;
	    goto functionexit;
        }
        else {
            bytes_read = -1;
	    goto functionexit;
        }
    }

    bytes_read += os_read;          /* update bytes read */

    if (_osfile(fh) & FTEXT) {
        /* now must translate CR-LFs to LFs in the buffer */

        /* set CRLF flag to indicate LF at beginning of buffer */
        /* if ((os_read != 0) && (*(char *)buf == LF))   */
        /*    _osfile(fh) |= FCRLF;                      */
        /* else                                          */
        /*    _osfile(fh) &= ~FCRLF;                     */

        _osfile(fh) &= ~FCRLF;

        /* convert chars in the buffer: p is src, q is dest */
        p = q = (char*)buf;
        while (p < (char *)buf + bytes_read) {
            if (*p == CTRLZ) {
                /* if fh is not a device, set ctrl-z flag */
                if (!(_osfile(fh) & FDEV))
                    _osfile(fh) |= FEOFLAG;
                break;              /* stop translating */
            }
            else if (*p != CR)
                *q++ = *p++;
            else {
                /* *p is CR, so must check next char for LF */
                if (p < (char *)buf + bytes_read - 1) {
                    if (*(p+1) == LF) {
                        p += 2;
                        *q++ = LF;  /* convert CR-LF to LF */
                    }
                    else
                        *q++ = *p++;    /* store char normally */
                }
                else {
                    /* This is the hard part.  We found a CR at end of
                       buffer.  We must peek ahead to see if next char
                       is an LF. */
                    ++p;

                    dosretval = 0;
                    if (!ReadFile((HANDLE)_osfhnd(fh), &peekchr, 1,
                                    (LPDWORD)&os_read, NULL))
                        dosretval = GetLastError();

                    if (dosretval != 0 || os_read == 0) {
                        /* couldn't read ahead, store CR */
                        *q++ = CR;
                    }
                    else {
                        /* peekchr now has the extra character -- we now
                           have several possibilities:
                           1. disk file and char is not LF; just seek back
                              and copy CR
                           2. disk file and char is LF; store LF, don't seek back
                           3. pipe/device and char is LF; store LF.
                           4. pipe/device and char isn't LF, store CR and
                              put char in pipe lookahead buffer. */
                        if (_osfile(fh) & (FDEV|FPIPE)) {
                            /* non-seekable device */
                            if (peekchr == LF)
                                *q++ = LF;
                            else {
                                *q++ = CR;
                                _pipech(fh) = peekchr;
                            }
                        }
                        else {
                            /* disk file */
                            if (peekchr == LF) {
                                /* nothing read yet; must make some
                                   progress */
                                *q++ = LF;
                                /* turn on this flag for tell routine */
                                _osfile(fh) |= FCRLF;
                            }
                            else {
				HANDLE osHandle;        /* o.s. handle value */
                                /* seek back */
				if ((osHandle = (HANDLE)_get_osfhandle(fh)) != (HANDLE)-1)
				{
				    if ((filepos = SetFilePointer(osHandle, -1, NULL, FILE_CURRENT)) == -1)
					dosretval = GetLastError();
				}
                                if (peekchr != LF)
                                    *q++ = CR;
                            }
                        }
                    }
                }
            }
        }

        /* we now change bytes_read to reflect the true number of chars
           in the buffer */
        bytes_read = q - (char *)buf;
    }

functionexit:
    if (_pioinfo(fh)->lockinitflag)
	LeaveCriticalSection(&(_pioinfo(fh)->lock));    /* unlock file */

    return bytes_read;
}

#endif	/* PERL_MSVCRT_READFIX */

a3109 3
#ifdef PERL_MSVCRT_READFIX
    return _fixed_read(fd, buf, cnt);
#else
a3110 1
#endif
d3197 1
a3197 1
		|| (IsWinNT() && stricmp(&cname[clen-4], ".cmd") == 0)))
d3200 1
a3200 2
	    if (!IsWin95())
		len += 3;
d3237 1
a3237 1
    if (bat_file && !IsWin95()) {
a3601 2
	if (IsWin95() && ret < 0)
	    ret = -ret;
a3637 3
#  ifdef __BORLANDC__
	return spawnv(P_WAIT, cmdname, (char *const *)argv);
#  else
a3638 1
#  endif
a3639 3
#ifdef __BORLANDC__
    return execv(cmdname, (char *const *)argv);
#else
a3640 1
#endif
a3659 3
#ifdef __BORLANDC__
    return execvp(cmdname, (char *const *)argv);
#else
a3660 1
#endif
a3860 4
#ifdef USE_FIXED_OSFHANDLE
    if (IsWin95())
	return my_open_osfhandle(handle, flags);
#endif
a3878 15
#ifdef __BORLANDC__
    if((pf)->flags & _F_READ) {
	mode[0] = 'r';
	mode[1] = 0;
    }
    else if((pf)->flags & _F_WRIT) {
	mode[0] = 'a';
	mode[1] = 0;
    }
    else if((pf)->flags & _F_RDWR) {
	mode[0] = 'r';
	mode[1] = '+';
	mode[2] = 0;
    }
#else
a3891 1
#endif
a3964 4
#if defined(__BORLANDC__)
    /* makedef.pl seems to have given up on fixing this issue in the .def file */
    pfn_init = (void (*)(pTHX))GetProcAddress((HMODULE)w32_perldll_handle, "_init_Win32CORE");
#else
a3965 1
#endif
a4052 4
    /* win32_ansipath() requires Windows 2000 or later */
    if (!IsWin2000())
        return;

d4129 1
a4129 1
         * the Borland runtime library puts it directly into the environ
a4141 2
    HMODULE module;

d4150 1
a4150 1
     * already, but the Borland RTL doesn't.  Since we don't
d4154 1
a4154 1
#if !defined(_ALPHA_) && !defined(__GNUC__)
a4168 12
    module = GetModuleHandle("ntdll.dll");
    if (module) {
        *(FARPROC*)&pfnZwQuerySystemInformation = GetProcAddress(module, "ZwQuerySystemInformation");
    }

    module = GetModuleHandle("kernel32.dll");
    if (module) {
        *(FARPROC*)&pfnCreateToolhelp32Snapshot = GetProcAddress(module, "CreateToolhelp32Snapshot");
        *(FARPROC*)&pfnProcess32First           = GetProcAddress(module, "Process32First");
        *(FARPROC*)&pfnProcess32Next            = GetProcAddress(module, "Process32Next");
    }

a4220 23
/* we use a message filter hook to process thread messages, passing any
 * messages that we don't process on to the rest of the hook chain
 * Anyone else writing a message loop that wants to play nicely with perl
 * should do
 *   CallMsgFilter(&msg, MSGF_***);
 * between their GetMessage and DispatchMessage calls.  */
LRESULT CALLBACK
win32_message_filter_proc(int code, WPARAM wParam, LPARAM lParam) {
    LPMSG pmsg = (LPMSG)lParam;

    /* we'll process it if code says we're allowed, and it's a thread message */
    if (code >= 0 && pmsg->hwnd == NULL
            && win32_process_message(pmsg->hwnd, pmsg->message,
                                     pmsg->wParam, pmsg->lParam))
    {
            return TRUE;
    }

    /* XXX: MSDN says that hhk is ignored, but we should really use the
     * return value from SetWindowsHookEx() in win32_create_message_window().  */
    return CallNextHookEx(NULL, code, wParam, lParam);
}

d4314 3
a4316 34
    HWND hwnd = NULL;

    /* "message-only" windows have been implemented in Windows 2000 and later.
     * On earlier versions we'll continue to post messages to a specific
     * thread and use hwnd==NULL.  This is brittle when either an embedding
     * application or an XS module is also posting messages to hwnd=NULL
     * because once removed from the queue they cannot be delivered to the
     * "right" place with DispatchMessage() anymore, as there is no WindowProc
     * if there is no window handle.
     */
    /* Using HWND_MESSAGE appears to work under Win98, despite MSDN
     * documentation to the contrary, however, there is some evidence that
     * there may be problems with the implementation on Win98. As it is not
     * officially supported we take the cautious route and stick with thread
     * messages (hwnd == NULL) on platforms prior to Win2k.
     */
    if (IsWin2000()) {
        win32_create_message_window_class();

        hwnd = CreateWindow("PerlMessageWindowClass", "PerlMessageWindow",
                0, 0, 0, 0, 0, HWND_MESSAGE, NULL, NULL, NULL);
    }

    /* If we din't create a window for any reason, then we'll use thread
     * messages for our signalling, so we install a hook which
     * is called by CallMsgFilter in win32_async_check(), or any other
     * modal loop (e.g. Win32::MsgBox or any other GUI extention, or anything
     * that use OLE, etc. */
    if(!hwnd) {
        SetWindowsHookEx(WH_MSGFILTER, win32_message_filter_proc,
                NULL, GetCurrentThreadId());
    }
  
    return hwnd;
d4370 3
a4372 3
         * processes in this group.  At least on Windows NT and later we
         * can re-enable Ctrl-C handling by calling SetConsoleCtrlHandler()
         * with a NULL handler.  This is not valid on Windows 9X.
d4374 1
a4374 2
        if (IsWinNT())
            SetConsoleCtrlHandler(NULL,FALSE);
@


1.12
log
@Merge in perl 5.10.1; part two
@
text
@d4 1
a4 1
 * 		Developed by hip communications inc., http://info.hip.com/info/
d25 1
a67 1
#include "Win32iop.h"
d126 2
a127 1
static char *		get_emd_part(SV **leading, char *trailing, ...);
d132 1
a132 1
				       const char *libname);
d324 1
a324 1
get_emd_part(SV **prev_pathp, char *trailing_path, ...)
d381 2
d390 1
a390 1
win32_get_privlib(const char *pl)
d403 1
a403 1
    return get_emd_part(&sv, stdlib, ARCHNAME, "bin", NULL);
d407 2
a408 1
win32_get_xlib(const char *pl, const char *xlib, const char *libname)
d423 1
a423 1
    (void)get_emd_part(&sv1, pathstr, ARCHNAME, "bin", pl, NULL);
d431 1
a431 1
    (void)get_emd_part(&sv2, pathstr, ARCHNAME, "bin", pl, NULL);
d435 6
a440 7
    if (!sv1)
	return SvPVX(sv2);
    if (!sv2)
	return SvPVX(sv1);

    sv_catpvn(sv1, ";", 1);
    sv_catsv(sv1, sv2);
d442 2
d448 1
a448 1
win32_get_sitelib(const char *pl)
d450 1
a450 1
    return win32_get_xlib(pl, "sitelib", "site");
d458 1
a458 1
win32_get_vendorlib(const char *pl)
d460 1
a460 1
    return win32_get_xlib(pl, "vendorlib", PERL_VENDORLIB_NAME);
d2017 1
a2017 1
 || (defined(__MINGW32__) && !defined(_ANONYMOUS_UNION))
a2507 1
#define LK_ERR(f,i)	((f) ? (i = 0) : (errno = GetLastError()))
d2523 3
d2530 2
a2531 1
	LK_ERR(LockFileEx(fh, 0, 0, LK_LEN, 0, &o),i);
d2534 2
a2535 1
	LK_ERR(LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK, 0, LK_LEN, 0, &o),i);
d2538 2
a2539 1
	LK_ERR(LockFileEx(fh, LOCKFILE_FAIL_IMMEDIATELY, 0, LK_LEN, 0, &o),i);
d2542 3
a2544 3
	LK_ERR(LockFileEx(fh,
		       LOCKFILE_EXCLUSIVE_LOCK|LOCKFILE_FAIL_IMMEDIATELY,
		       0, LK_LEN, 0, &o),i);
d2547 2
a2548 1
	LK_ERR(UnlockFileEx(fh, 0, LK_LEN, 0, &o),i);
d2552 7
a2558 1
	break;
a2562 1
#undef LK_ERR
a2625 1
    DWORD source = 0;
d2632 5
a2636 3
	if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, &source, e, 0,
			  w32_strerror_buffer,
			  sizeof(w32_strerror_buffer), NULL) == 0)
d2638 1
a2638 1

d2641 1
d2643 1
a3103 1
	LOCK_FDPID_MUTEX;
a3104 1
	UNLOCK_FDPID_MUTEX;
a3144 1
    LOCK_FDPID_MUTEX;
a3152 1
        UNLOCK_FDPID_MUTEX;
a3162 1
    UNLOCK_FDPID_MUTEX;
d3512 21
d4841 10
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d132 2
d228 4
d238 8
d285 1
a285 1
    char *str = Nullch;
d383 1
a383 1
    return Nullch;
d392 1
a392 1
    SV *sv = Nullsv;
d400 1
a400 1
    return get_emd_part(&sv, stdlib, ARCHNAME, "bin", Nullch);
d409 2
a410 2
    SV *sv1 = Nullsv;
    SV *sv2 = Nullsv;
d419 1
a419 1
    (void)get_emd_part(&sv1, pathstr, ARCHNAME, "bin", pl, Nullch);
d427 1
a427 1
    (void)get_emd_part(&sv2, pathstr, ARCHNAME, "bin", pl, Nullch);
d430 1
a430 1
	return Nullch;
d566 1
a566 1
    char *retstart = Nullch;
d601 1
a601 1
	retvstart[items] = Nullch;
d640 2
d680 1
a680 2
	if (IsWin95())
	    PL_statusvalue = -1;	/* >16bits hint for pp_system() */
d746 1
a746 1
	*a = Nullch;
d775 1
a775 1
	argv[i] = Nullch;
d793 1
a793 2
	if (IsWin95())
	    PL_statusvalue = -1;	/* >16bits hint for pp_system() */
d813 2
d821 2
d829 2
d1523 12
d1536 3
a1538 2
	if (S_ISDIR(sbuf->st_mode))
	    sbuf->st_mode |= S_IWRITE | S_IEXEC;
d1586 1
a1586 1
	return Nullch;
d1650 1
a1650 1
		return Nullch;
d1657 1
a1657 1
	    return Nullch;
d1665 1
a1665 1
out_of_memory()
d1734 1
a1734 1
    SV *curitem = Nullsv;
d1755 1
a1755 1
    return Nullch;
d1775 2
a1776 1
             *  * we don't have to deal with RTL globals, bugs and leaks.
d1778 2
a1779 1
             * Why you may want to enable USE_WIN32_RTL_ENV:
d2120 2
d2124 22
a2145 12
    if (hwnd == INVALID_HANDLE_VALUE) {
        /* Call PeekMessage() to mark all pending messages in the queue as "old".
         * This is necessary when we are being called by win32_msgwait() to
         * make sure MsgWaitForMultipleObjects() stops reporting the same waiting
         * message over and over.  An example how this can happen is when
         * Perl is calling win32_waitpid() inside a GUI application and the GUI
         * is generating messages before the process terminated.
         */
        PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE|PM_NOYIELD);
        if (PL_sig_pending)
            despatch_signals();
        return 1;
d2148 6
a2153 2
    /* Passing PeekMessage -1 as HWND (2nd arg) only get PostThreadMessage() messages
     * and ignores window messages - should co-exist better with windows apps e.g. Tk
d2155 1
a2155 38
    if (hwnd == NULL)
        hwnd = (HWND)-1;

    while (PeekMessage(&msg, hwnd, WM_TIMER,    WM_TIMER,    PM_REMOVE|PM_NOYIELD) ||
           PeekMessage(&msg, hwnd, WM_USER_MIN, WM_USER_MAX, PM_REMOVE|PM_NOYIELD))
    {
	switch (msg.message) {
#ifdef USE_ITHREADS
        case WM_USER_MESSAGE: {
            int child = find_pseudo_pid(msg.wParam);
            if (child >= 0)
                w32_pseudo_child_message_hwnds[child] = (HWND)msg.lParam;
            break;
        }
#endif

	case WM_USER_KILL: {
            /* We use WM_USER to fake kill() with other signals */
	    int sig = msg.wParam;
	    if (do_raise(aTHX_ sig))
                sig_terminate(aTHX_ sig);
	    break;
	}

	case WM_TIMER: {
	    /* alarm() is a one-shot but SetTimer() repeats so kill it */
	    if (w32_timerid && w32_timerid==msg.wParam) {
	    	KillTimer(w32_message_hwnd, w32_timerid);
	    	w32_timerid=0;

                /* Now fake a call to signal handler */
                if (do_raise(aTHX_ 14))
                    sig_terminate(aTHX_ 14);
            }
	    break;
	}
        } /* switch */
    }
d2158 3
a2160 3
    if (PL_sig_pending) {
	despatch_signals();
    }
d2176 1
a2176 1
	DWORD result = MsgWaitForMultipleObjects(count,handles,FALSE,timeout-ticks, QS_POSTMESSAGE|QS_TIMER);
d2407 1
a2407 1
    return Nullch;
d2580 1
a2580 1
win32_stdout()
d2962 1
a2962 1
        sbufptr->st_size = (bhfi.nFileSizeHigh << 32) + bhfi.nFileSizeLow ;
d3286 1
a3286 1
	char *endname = Nullch;
d3345 1
a3345 1
	if (endname != Nullch) {
d3927 1
a3927 1
	return Nullch;
d4001 1
a4001 1
    return Nullch;
d4088 1
a4088 1
    char *fullcmd = Nullch;
d4863 121
d4985 1
a4985 1
win32_create_message_window()
d4987 2
d4997 12
a5008 2
    if (!IsWin2000())
        return NULL;
d5010 11
a5020 1
    return CreateWindow("Static", "", 0, 0, 0, 0, 0, HWND_MESSAGE, 0, 0, NULL);
d5046 1
a5046 1
    w32_perlshell_tokens	= Nullch;
d5116 3
a5118 1
    dst->perlshell_tokens	= Nullch;
@


1.10
log
@merge in perl 5.8.8
@
text
@d18 5
a22 5
/* GCC-2.95.2/Mingw32-1.1 forgot the WINAPI on CommandLineToArgvW() */
#if defined(__MINGW32__) && (__MINGW32_MAJOR_VERSION==1)	
#  include <shellapi.h>
#else
   LPWSTR* WINAPI CommandLineToArgvW(LPCWSTR lpCommandLine, int * pNumArgs);
d25 1
d29 24
d91 1
d97 1
d122 2
a123 2
static int		do_spawn2(pTHX_ char *cmd, int exectype);
static BOOL		has_shell_metachars(char *ptr);
d143 1
a143 1
static DWORD	w32_platform = (DWORD)-1;
d145 4
a148 1
#define ONE_K_BUFSIZE	1024
d160 30
d193 1
a193 1
    return (win32_os_id() == VER_PLATFORM_WIN32_WINDOWS);
d199 7
a205 1
    return (win32_os_id() == VER_PLATFORM_WIN32_NT);
d211 1
d213 40
a252 14
    GetModuleFileName((HMODULE)((w32_perldll_handle == INVALID_HANDLE_VALUE)
				? GetModuleHandle(NULL)
				: w32_perldll_handle),
		      w32_module_name, sizeof(w32_module_name));

    /* remove \\?\ prefix */
    if (memcmp(w32_module_name, "\\\\?\\", 4) == 0)
        memmove(w32_module_name, w32_module_name+4, strlen(w32_module_name+4)+1);

    /* try to get full path to binary (which may be mangled when perl is
     * run from a 16-bit app) */
    /*PerlIO_printf(Perl_debug_log, "Before %s\n", w32_module_name);*/
    (void)win32_longpath(w32_module_name);
    /*PerlIO_printf(Perl_debug_log, "After  %s\n", w32_module_name);*/
d445 1
a445 1
has_shell_metachars(char *ptr)
d490 1
a490 1
Perl_my_popen(pTHX_ char *cmd, char *mode)
d522 1
a522 9
    static OSVERSIONINFO osver;

    if (osver.dwPlatformId != w32_platform) {
	memset(&osver, 0, sizeof(OSVERSIONINFO));
	osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osver);
	w32_platform = osver.dwPlatformId;
    }
    return (unsigned long)w32_platform;
d706 1
a706 1
do_spawn2(pTHX_ char *cmd, int exectype)
d759 1
a759 1
	argv[i++] = cmd;
d809 1
a809 1
Perl_do_exec(pTHX_ char *cmd)
d820 1
a820 1
win32_opendir(char *filename)
d830 1
a830 1
    HANDLE		fh;
d832 1
a832 2
    WCHAR		wbuffer[MAX_PATH+1];
    char*		ptr;
d860 5
a864 3
    if (USING_WIDE()) {
	A2WHELPER(scanname, wbuffer, sizeof(wbuffer));
	fh = FindFirstFileW(PerlDir_mapW(wbuffer), &wFindData);
d867 1
a867 1
	fh = FindFirstFileA(PerlDir_mapA(scanname), &aFindData);
d869 1
a869 2
    dirp->handle = fh;
    if (fh == INVALID_HANDLE_VALUE) {
d890 15
a907 7
    if (USING_WIDE()) {
	W2AHELPER(wFindData.cFileName, buffer, sizeof(buffer));
	ptr = buffer;
    }
    else {
	ptr = aFindData.cFileName;
    }
d910 1
a910 1
	dirp->size = 128;
d943 4
a946 5
	    char*		ptr;
	    BOOL		res;
	    WIN32_FIND_DATAW	wFindData;
	    WIN32_FIND_DATAA	aFindData;
	    char		buffer[MAX_PATH*2];
d951 2
a952 1
	    if (USING_WIDE()) {
d955 16
a970 9
		    W2AHELPER(wFindData.cFileName, buffer, sizeof(buffer));
		    ptr = buffer;
		}
	    }
	    else {
		res = FindNextFileA(dirp->handle, &aFindData);
		if (res)
		    ptr = aFindData.cFileName;
	    }
d1174 2
d1181 137
a1321 1
    HANDLE hProcess;
a1322 1
    int retval;
d1328 2
a1329 1
	    hProcess = w32_pseudo_child_handles[child];
d1334 1
d1342 22
a1363 8
	    default:
	      /* We fake signals to pseudo-processes using Win32
	       * message queue.  In Win9X the pids are negative already. */
	      if (PostThreadMessage(IsWin95() ? pid : -pid,WM_USER,sig,0)) {
		    /* It might be us ... */
		    PERL_ASYNC_CHECK();
		    return 0;
		}
d1366 1
d1378 8
a1385 21
            hProcess = w32_child_handles[child];
	    switch(sig) {
	    case 0:
		/* "Does process exist?" use of kill */
		return 0;
	    case 2:
		if (GenerateConsoleCtrlEvent(CTRL_C_EVENT,pid))
		    return 0;
		break;
            case SIGBREAK:
            case SIGTERM:
                if (GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,pid))
                    return 0;
                break;
	    default: /* For now be backwards compatible with perl5.6 */
	    case 9:
	        if (TerminateProcess(hProcess, sig)) {
		    remove_dead_process(child);
		    return 0;
	    	}
		break;
d1390 1
a1390 27
            retval = -1;
	    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE,
				   (IsWin95() ? -pid : pid));
	    if (hProcess) {
		switch(sig) {
		case 0:
		    /* "Does process exist?" use of kill */
		    retval = 0;
                    break;
		case 2:
		    if (GenerateConsoleCtrlEvent(CTRL_C_EVENT,pid))
			retval = 0;
		    break;
                case SIGBREAK:
                case SIGTERM:
                    if (GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,pid))
                       retval = 0;
                    break;
		default: /* For now be backwards compatible with perl5.6 */
                case 9:
		    if (TerminateProcess(hProcess, sig))
			retval = 0;
                    break;
		}
	    }
            CloseHandle(hProcess);
            if (retval == 0)
a1404 3
    WCHAR	wbuffer[MAX_PATH+1];
    WCHAR*	pwbuffer;
    HANDLE      handle;
d1406 5
d1415 1
a1415 1
	 * backslash, so change it to a forward slash :-( */
d1417 2
a1418 1
	    if (l >= sizeof(buffer)) {
d1422 11
a1432 4
	    strncpy(buffer, path, l-1);
	    buffer[l - 1] = '/';
	    buffer[l] = '\0';
	    path = buffer;
d1434 1
d1449 14
a1462 18
    /* We *must* open & close the file once; otherwise file attribute changes */
    /* might not yet have propagated to "other" hard links of the same file.  */
    /* This also gives us an opportunity to determine the number of links.    */
    if (USING_WIDE()) {
	A2WHELPER(path, wbuffer, sizeof(wbuffer));
	pwbuffer = PerlDir_mapW(wbuffer);
	handle = CreateFileW(pwbuffer, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
    }
    else {
	path = PerlDir_mapA(path);
	l = strlen(path);
	handle = CreateFileA(path, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
    }
    if (handle != INVALID_HANDLE_VALUE) {
	BY_HANDLE_FILE_INFORMATION bhi;
	if (GetFileInformationByHandle(handle, &bhi))
	    nlink = bhi.nNumberOfLinks;
	CloseHandle(handle);
d1465 1
a1465 9
    /* pwbuffer or path will be mapped correctly above */
    if (USING_WIDE()) {
#if defined(WIN64) || defined(USE_LARGE_FILES)
	res = _wstati64(pwbuffer, sbuf);
#else
	res = _wstat(pwbuffer, (struct _stat*)sbuf);
#endif
    }
    else {
d1467 1
a1467 1
	res = _stati64(path, sbuf);
d1469 1
a1469 1
	res = stat(path, sbuf);
a1470 1
    }
d1478 1
a1478 7
	DWORD r;
	if (USING_WIDE()) {
	    r = GetFileAttributesW(pwbuffer);
	}
	else {
	    r = GetFileAttributesA(path);
	}
d1494 1
a1494 3
	    if (USING_WIDE()
		? !GetVolumeInformationW(pwbuffer,NULL,0,NULL,NULL,NULL,NULL,0)
		: !GetVolumeInformationA(path,NULL,0,NULL,NULL,NULL,NULL,0)) {
d1499 4
d1631 65
a1699 1
    WCHAR wBuffer[MAX_PATH+1];
d1703 1
a1703 6
    if (USING_WIDE()) {
	A2WHELPER(name, wBuffer, sizeof(wBuffer));
	needlen = GetEnvironmentVariableW(wBuffer, NULL, 0);
    }
    else
	needlen = GetEnvironmentVariableA(name,NULL,0);
d1706 6
a1711 20
	if (USING_WIDE()) {
	    SV *acuritem;
	    do {
		SvGROW(curitem, (needlen+1)*sizeof(WCHAR));
		needlen = GetEnvironmentVariableW(wBuffer,
						  (WCHAR*)SvPVX(curitem),
						  needlen);
	    } while (needlen >= SvLEN(curitem)/sizeof(WCHAR));
	    SvCUR_set(curitem, (needlen*sizeof(WCHAR))+1);
	    acuritem = sv_2mortal(newSVsv(curitem));
	    W2AHELPER((WCHAR*)SvPVX(acuritem), SvPVX(curitem), SvCUR(curitem));
	}
	else {
	    do {
		SvGROW(curitem, needlen+1);
		needlen = GetEnvironmentVariableA(name,SvPVX(curitem),
						  needlen);
	    } while (needlen >= SvLEN(curitem));
	    SvCUR_set(curitem, needlen);
	}
d1731 1
a1731 3
    WCHAR* wCuritem;
    WCHAR* wVal;
    int length, relval = -1;
d1734 23
a1756 37
	if (USING_WIDE()) {
	    length = strlen(name)+1;
	    Newx(wCuritem,length,WCHAR);
	    A2WHELPER(name, wCuritem, length*sizeof(WCHAR));
	    wVal = wcschr(wCuritem, '=');
	    if (wVal) {
		*wVal++ = '\0';
		if (SetEnvironmentVariableW(wCuritem, *wVal ? wVal : NULL))
		    relval = 0;
	    }
	    Safefree(wCuritem);
	}
	else {
	    Newx(curitem,strlen(name)+1,char);
	    strcpy(curitem, name);
	    val = strchr(curitem, '=');
	    if (val) {
		/* The sane way to deal with the environment.
		 * Has these advantages over putenv() & co.:
		 *  * enables us to store a truly empty value in the
		 *    environment (like in UNIX).
		 *  * we don't have to deal with RTL globals, bugs and leaks.
		 *  * Much faster.
		 * Why you may want to enable USE_WIN32_RTL_ENV:
		 *  * environ[] and RTL functions will not reflect changes,
		 *    which might be an issue if extensions want to access
		 *    the env. via RTL.  This cuts both ways, since RTL will
		 *    not see changes made by extensions that call the Win32
		 *    functions directly, either.
		 * GSAR 97-06-07
		 */
		*val++ = '\0';
		if (SetEnvironmentVariableA(curitem, *val ? val : NULL))
		    relval = 0;
	    }
	    Safefree(curitem);
	}
d1824 5
a1828 17
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	WCHAR* pwBuffer;

	A2WHELPER(filename, wBuffer, sizeof(wBuffer));
	pwBuffer = PerlDir_mapW(wBuffer);
	attrs = GetFileAttributesW(pwBuffer);
	if (attrs == 0xFFFFFFFF)
	    goto fail;
	if (attrs & FILE_ATTRIBUTE_READONLY) {
	    (void)SetFileAttributesW(pwBuffer, attrs & ~FILE_ATTRIBUTE_READONLY);
	    ret = _wunlink(pwBuffer);
	    if (ret == -1)
		(void)SetFileAttributesW(pwBuffer, attrs);
	}
	else
	    ret = _wunlink(pwBuffer);
d1830 5
a1834 13
    else {
	filename = PerlDir_mapA(filename);
	attrs = GetFileAttributesA(filename);
	if (attrs == 0xFFFFFFFF)
	    goto fail;
	if (attrs & FILE_ATTRIBUTE_READONLY) {
	    (void)SetFileAttributesA(filename, attrs & ~FILE_ATTRIBUTE_READONLY);
	    ret = unlink(filename);
	    if (ret == -1)
		(void)SetFileAttributesA(filename, attrs);
	}
	else
	    ret = unlink(filename);
d1836 2
a1838 3
fail:
    errno = ENOENT;
    return -1;
d1850 4
a1853 2
    WCHAR wbuffer[MAX_PATH+1];
    WCHAR* pwbuffer;
a1854 10
    int rc;
    if (USING_WIDE()) {
	A2WHELPER(filename, wbuffer, sizeof(wbuffer));
	pwbuffer = PerlDir_mapW(wbuffer);
	rc = _wutime(pwbuffer, (struct _utimbuf*)times);
    }
    else {
	filename = PerlDir_mapA(filename);
	rc = utime(filename, times);
    }
d1866 3
a1868 10
    if (USING_WIDE()) {
	handle = CreateFileW(pwbuffer, GENERIC_READ | GENERIC_WRITE,
			    FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
			    OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    }
    else {
	handle = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE,
			    FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
			    OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    }
a1920 1
    OSVERSIONINFO osver;
d1922 15
a1936 18
    memset(&osver, 0, sizeof(OSVERSIONINFO));
    osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osver)) {
	/* sysname */
	switch (osver.dwPlatformId) {
	case VER_PLATFORM_WIN32_WINDOWS:
	    strcpy(name->sysname, "Windows");
	    break;
	case VER_PLATFORM_WIN32_NT:
	    strcpy(name->sysname, "Windows NT");
	    break;
	case VER_PLATFORM_WIN32s:
	    strcpy(name->sysname, "Win32s");
	    break;
	default:
	    strcpy(name->sysname, "Win32 Unknown");
	    break;
	}
d1938 11
a1948 17
	/* release */
	sprintf(name->release, "%d.%d",
		osver.dwMajorVersion, osver.dwMinorVersion);

	/* version */
	sprintf(name->version, "Build %d",
		osver.dwPlatformId == VER_PLATFORM_WIN32_NT
		? osver.dwBuildNumber : (osver.dwBuildNumber & 0xffff));
	if (osver.szCSDVersion[0]) {
	    char *buf = name->version + strlen(name->version);
	    sprintf(buf, " (%s)", osver.szCSDVersion);
	}
    }
    else {
	*name->sysname = '\0';
	*name->version = '\0';
	*name->release = '\0';
d2083 18
a2100 1
    int ours = 1;
d2104 2
a2105 3
    while (PeekMessage(&msg, (HWND)-1, 0, 0, PM_REMOVE|PM_NOYIELD)) {
	int sig;
	switch(msg.message) {
d2107 11
a2117 8
#if 0
    /* Perhaps some other messages could map to signals ? ... */
        case WM_CLOSE:
        case WM_QUIT:
	    /* Treat WM_QUIT like SIGHUP?  */
	    sig = SIGHUP;
	    goto Raise;
	    break;
d2120 5
a2124 7
	/* We use WM_USER to fake kill() with other signals */
	case WM_USER: {
	    sig = msg.wParam;
	Raise:
	    if (do_raise(aTHX_ sig)) {
		   sig_terminate(aTHX_ sig);
	    }
d2131 1
a2131 1
	    	KillTimer(NULL,w32_timerid);
a2132 9
	    }
            else
		goto FallThrough;
	    /* Now fake a call to signal handler */
	    if (do_raise(aTHX_ 14)) {
	    	sig_terminate(aTHX_ 14);
	    }
	    break;
	}
d2134 4
a2137 6
	/* Otherwise do normal Win32 thing - in case it is useful */
	default:
	FallThrough:
	    TranslateMessage(&msg);
	    DispatchMessage(&msg);
	    ours = 0;
d2140 1
a2141 1
    w32_poll_count = 0;
d2147 1
a2147 1
    return ours;
d2162 1
a2162 1
	DWORD result = MsgWaitForMultipleObjects(count,handles,FALSE,timeout-ticks, QS_ALLEVENTS);
d2360 4
d2365 6
a2370 1
	w32_timerid = SetTimer(NULL,w32_timerid,sec*1000,NULL);
d2374 2
a2375 2
            KillTimer(NULL,w32_timerid);
  	    w32_timerid=0;
a2692 1
    WCHAR wMode[MODE_SIZE], wBuffer[MAX_PATH+1];
d2701 1
a2701 7
    if (USING_WIDE()) {
	A2WHELPER(mode, wMode, sizeof(wMode));
	A2WHELPER(filename, wBuffer, sizeof(wBuffer));
	f = _wfopen(PerlDir_mapW(wBuffer), wMode);
    }
    else
	f = fopen(PerlDir_mapA(filename), mode);
a2716 1
    WCHAR wMode[MODE_SIZE];
d2718 1
a2718 6
    if (USING_WIDE()) {
	A2WHELPER(mode, wMode, sizeof(wMode));
	f = _wfdopen(handle, wMode);
    }
    else
	f = fdopen(handle, (char *) mode);
a2728 1
    WCHAR wMode[MODE_SIZE], wBuffer[MAX_PATH+1];
a2731 5
    if (USING_WIDE()) {
	A2WHELPER(mode, wMode, sizeof(wMode));
	A2WHELPER(path, wBuffer, sizeof(wBuffer));
	return _wfreopen(PerlDir_mapW(wBuffer), wMode, stream);
    }
a3028 4
    /* save current stdfd */
    if ((oldfd = win32_dup(stdfd)) == -1)
        goto cleanup;

d3035 4
d3060 3
a3070 3
	/* close saved handle */
	win32_close(oldfd);

d3086 4
a3094 4
    if (oldfd != -1) {
        win32_dup2(oldfd, stdfd);
        win32_close(oldfd);
    }
d3123 1
d3219 2
a3220 2
    if ((A2WHELPER(oldname, wOldName, sizeof(wOldName))) &&
	(A2WHELPER(newname, wNewName, sizeof(wNewName))) &&
d3222 1
a3222 1
	pfnCreateHardLinkW(PerlDir_mapW(wNewName), wOldName, NULL)))
a3232 2
    WCHAR wOldName[MAX_PATH+1];
    WCHAR wNewName[MAX_PATH+1];
d3243 4
a3246 14
	if (USING_WIDE()) {
	    A2WHELPER(oname, wOldName, sizeof(wOldName));
	    A2WHELPER(newname, wNewName, sizeof(wNewName));
	    if (wcsicmp(wNewName, wOldName))
		dwFlags |= MOVEFILE_REPLACE_EXISTING;
	    wcscpy(wOldName, PerlDir_mapW(wOldName));
	    bResult = MoveFileExW(wOldName,PerlDir_mapW(wNewName), dwFlags);
	}
	else {
	    if (stricmp(newname, oname))
		dwFlags |= MOVEFILE_REPLACE_EXISTING;
	    strcpy(szOldName, PerlDir_mapA(oname));
	    bResult = MoveFileExA(szOldName,PerlDir_mapA(newname), dwFlags);
	}
a3456 1
    WCHAR wBuffer[MAX_PATH+1];
a3464 4
    if (USING_WIDE()) {
	A2WHELPER(path, wBuffer, sizeof(wBuffer));
	return _wopen(PerlDir_mapW(wBuffer), flag, pmode);
    }
a3710 5
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(dir, wBuffer, sizeof(wBuffer));
	return _wmkdir(PerlDir_mapW(wBuffer));
    }
a3717 5
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(dir, wBuffer, sizeof(wBuffer));
	return _wrmdir(PerlDir_mapW(wBuffer));
    }
a3728 5
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(dir, wBuffer, sizeof(wBuffer));
	return _wchdir(wBuffer);
    }
a3735 5
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(path, wBuffer, sizeof(wBuffer));
	return _waccess(PerlDir_mapW(wBuffer), mode);
    }
a3742 5
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(path, wBuffer, sizeof(wBuffer));
	return _wchmod(PerlDir_mapW(wBuffer), mode);
    }
d4032 1
a4032 9
    char szfilename[(MAX_PATH+1)*2];
    if (USING_WIDE()) {
	WCHAR wfilename[MAX_PATH+1];
	GetCurrentDirectoryW(MAX_PATH+1, wfilename);
	W2AHELPER(wfilename, szfilename, sizeof(szfilename));
    }
    else {
	GetCurrentDirectoryA(MAX_PATH+1, szfilename);
    }
d4034 1
a4532 1
    HMODULE hModule;
d4552 1
a4552 9
    if (USING_WIDE()) {
	WCHAR wfilename[MAX_PATH+1];
	A2WHELPER(filename, wfilename, sizeof(wfilename));
	hModule = LoadLibraryExW(PerlDir_mapW(wfilename), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }
    else {
	hModule = LoadLibraryExA(PerlDir_mapA(filename), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }
    return hModule;
a4554 5
/*
 * Extras.
 */

static
a4579 521
static
XS(w32_GetCwd)
{
    dXSARGS;
    /* Make the host for current directory */
    char* ptr = PerlEnv_get_childdir();
    /*
     * If ptr != Nullch
     *   then it worked, set PV valid,
     *   else return 'undef'
     */
    if (ptr) {
	SV *sv = sv_newmortal();
	sv_setpv(sv, ptr);
	PerlEnv_free_childdir(ptr);

#ifndef INCOMPLETE_TAINTS
	SvTAINTED_on(sv);
#endif

	EXTEND(SP,1);
	SvPOK_on(sv);
	ST(0) = sv;
	XSRETURN(1);
    }
    XSRETURN_UNDEF;
}

static
XS(w32_SetCwd)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::SetCurrentDirectory($cwd)");
    if (!PerlDir_chdir(SvPV_nolen(ST(0))))
	XSRETURN_YES;

    XSRETURN_NO;
}

static
XS(w32_GetNextAvailDrive)
{
    dXSARGS;
    char ix = 'C';
    char root[] = "_:\\";

    EXTEND(SP,1);
    while (ix <= 'Z') {
	root[0] = ix++;
	if (GetDriveType(root) == 1) {
	    root[2] = '\0';
	    XSRETURN_PV(root);
	}
    }
    XSRETURN_UNDEF;
}

static
XS(w32_GetLastError)
{
    dXSARGS;
    EXTEND(SP,1);
    XSRETURN_IV(GetLastError());
}

static
XS(w32_SetLastError)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::SetLastError($error)");
    SetLastError(SvIV(ST(0)));
    XSRETURN_EMPTY;
}

static
XS(w32_LoginName)
{
    dXSARGS;
    char *name = w32_getlogin_buffer;
    DWORD size = sizeof(w32_getlogin_buffer);
    EXTEND(SP,1);
    if (GetUserName(name,&size)) {
	/* size includes NULL */
	ST(0) = sv_2mortal(newSVpvn(name,size-1));
	XSRETURN(1);
    }
    XSRETURN_UNDEF;
}

static
XS(w32_NodeName)
{
    dXSARGS;
    char name[MAX_COMPUTERNAME_LENGTH+1];
    DWORD size = sizeof(name);
    EXTEND(SP,1);
    if (GetComputerName(name,&size)) {
	/* size does NOT include NULL :-( */
	ST(0) = sv_2mortal(newSVpvn(name,size));
	XSRETURN(1);
    }
    XSRETURN_UNDEF;
}


static
XS(w32_DomainName)
{
    dXSARGS;
    HINSTANCE hNetApi32 = LoadLibrary("netapi32.dll");
    DWORD (__stdcall *pfnNetApiBufferFree)(LPVOID Buffer);
    DWORD (__stdcall *pfnNetWkstaGetInfo)(LPWSTR servername, DWORD level,
					  void *bufptr);

    if (hNetApi32) {
	pfnNetApiBufferFree = (DWORD (__stdcall *)(void *))
	    GetProcAddress(hNetApi32, "NetApiBufferFree");
	pfnNetWkstaGetInfo = (DWORD (__stdcall *)(LPWSTR, DWORD, void *))
	    GetProcAddress(hNetApi32, "NetWkstaGetInfo");
    }
    EXTEND(SP,1);
    if (hNetApi32 && pfnNetWkstaGetInfo && pfnNetApiBufferFree) {
	/* this way is more reliable, in case user has a local account. */
	char dname[256];
	DWORD dnamelen = sizeof(dname);
	struct {
	    DWORD   wki100_platform_id;
	    LPWSTR  wki100_computername;
	    LPWSTR  wki100_langroup;
	    DWORD   wki100_ver_major;
	    DWORD   wki100_ver_minor;
	} *pwi;
	/* NERR_Success *is* 0*/
	if (0 == pfnNetWkstaGetInfo(NULL, 100, &pwi)) {
	    if (pwi->wki100_langroup && *(pwi->wki100_langroup)) {
		WideCharToMultiByte(CP_ACP, 0, pwi->wki100_langroup,
				    -1, (LPSTR)dname, dnamelen, NULL, NULL);
	    }
	    else {
		WideCharToMultiByte(CP_ACP, 0, pwi->wki100_computername,
				    -1, (LPSTR)dname, dnamelen, NULL, NULL);
	    }
	    pfnNetApiBufferFree(pwi);
	    FreeLibrary(hNetApi32);
	    XSRETURN_PV(dname);
	}
	FreeLibrary(hNetApi32);
    }
    else {
	/* Win95 doesn't have NetWksta*(), so do it the old way */
	char name[256];
	DWORD size = sizeof(name);
	if (hNetApi32)
	    FreeLibrary(hNetApi32);
	if (GetUserName(name,&size)) {
	    char sid[ONE_K_BUFSIZE];
	    DWORD sidlen = sizeof(sid);
	    char dname[256];
	    DWORD dnamelen = sizeof(dname);
	    SID_NAME_USE snu;
	    if (LookupAccountName(NULL, name, (PSID)&sid, &sidlen,
				  dname, &dnamelen, &snu)) {
		XSRETURN_PV(dname);		/* all that for this */
	    }
	}
    }
    XSRETURN_UNDEF;
}

static
XS(w32_FsType)
{
    dXSARGS;
    char fsname[256];
    DWORD flags, filecomplen;
    if (GetVolumeInformation(NULL, NULL, 0, NULL, &filecomplen,
			 &flags, fsname, sizeof(fsname))) {
	if (GIMME_V == G_ARRAY) {
	    XPUSHs(sv_2mortal(newSVpvn(fsname,strlen(fsname))));
	    XPUSHs(sv_2mortal(newSViv(flags)));
	    XPUSHs(sv_2mortal(newSViv(filecomplen)));
	    PUTBACK;
	    return;
	}
	EXTEND(SP,1);
	XSRETURN_PV(fsname);
    }
    XSRETURN_EMPTY;
}

static
XS(w32_GetOSVersion)
{
    dXSARGS;
    /* Use explicit struct definition because wSuiteMask and
     * wProductType are not defined in the VC++ 6.0 headers.
     * WORD type has been replaced by unsigned short because
     * WORD is already used by Perl itself.
     */
    struct {
        DWORD dwOSVersionInfoSize;
        DWORD dwMajorVersion;
        DWORD dwMinorVersion;
        DWORD dwBuildNumber;
        DWORD dwPlatformId;
        CHAR  szCSDVersion[128];
        unsigned short wServicePackMajor;
        unsigned short wServicePackMinor;
        unsigned short wSuiteMask;
        BYTE  wProductType;
        BYTE  wReserved;
    }   osver;
    BOOL bEx = TRUE;

    if (USING_WIDE()) {
        struct {
            DWORD dwOSVersionInfoSize;
            DWORD dwMajorVersion;
            DWORD dwMinorVersion;
            DWORD dwBuildNumber;
            DWORD dwPlatformId;
            WCHAR szCSDVersion[128];
            unsigned short wServicePackMajor;
            unsigned short wServicePackMinor;
            unsigned short wSuiteMask;
            BYTE  wProductType;
            BYTE  wReserved;
        } osverw;
	char szCSDVersion[sizeof(osverw.szCSDVersion)];
	osverw.dwOSVersionInfoSize = sizeof(osverw);
	if (!GetVersionExW((OSVERSIONINFOW*)&osverw)) {
            bEx = FALSE;
            osverw.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
            if (!GetVersionExW((OSVERSIONINFOW*)&osverw)) {
                XSRETURN_EMPTY;
            }
	}
	if (GIMME_V == G_SCALAR) {
	    XSRETURN_IV(osverw.dwPlatformId);
	}
	W2AHELPER(osverw.szCSDVersion, szCSDVersion, sizeof(szCSDVersion));
	XPUSHs(newSVpvn(szCSDVersion, strlen(szCSDVersion)));
        osver.dwMajorVersion    = osverw.dwMajorVersion;
        osver.dwMinorVersion    = osverw.dwMinorVersion;
        osver.dwBuildNumber     = osverw.dwBuildNumber;
        osver.dwPlatformId      = osverw.dwPlatformId;
        osver.wServicePackMajor = osverw.wServicePackMajor;
        osver.wServicePackMinor = osverw.wServicePackMinor;
        osver.wSuiteMask        = osverw.wSuiteMask;
        osver.wProductType      = osverw.wProductType;
    }
    else {
	osver.dwOSVersionInfoSize = sizeof(osver);
	if (!GetVersionExA((OSVERSIONINFOA*)&osver)) {
            bEx = FALSE;
            osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            if (!GetVersionExA((OSVERSIONINFOA*)&osver)) {
                XSRETURN_EMPTY;
            }
	}
	if (GIMME_V == G_SCALAR) {
	    XSRETURN_IV(osver.dwPlatformId);
	}
	XPUSHs(newSVpvn(osver.szCSDVersion, strlen(osver.szCSDVersion)));
    }
    XPUSHs(newSViv(osver.dwMajorVersion));
    XPUSHs(newSViv(osver.dwMinorVersion));
    XPUSHs(newSViv(osver.dwBuildNumber));
    XPUSHs(newSViv(osver.dwPlatformId));
    if (bEx) {
        XPUSHs(newSViv(osver.wServicePackMajor));
        XPUSHs(newSViv(osver.wServicePackMinor));
        XPUSHs(newSViv(osver.wSuiteMask));
        XPUSHs(newSViv(osver.wProductType));
    }
    PUTBACK;
}

static
XS(w32_IsWinNT)
{
    dXSARGS;
    EXTEND(SP,1);
    XSRETURN_IV(IsWinNT());
}

static
XS(w32_IsWin95)
{
    dXSARGS;
    EXTEND(SP,1);
    XSRETURN_IV(IsWin95());
}

static
XS(w32_FormatMessage)
{
    dXSARGS;
    DWORD source = 0;
    char msgbuf[ONE_K_BUFSIZE];

    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::FormatMessage($errno)");

    if (USING_WIDE()) {
	WCHAR wmsgbuf[ONE_K_BUFSIZE];
	if (FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
			  &source, SvIV(ST(0)), 0,
			  wmsgbuf, ONE_K_BUFSIZE-1, NULL))
	{
	    W2AHELPER(wmsgbuf, msgbuf, sizeof(msgbuf));
	    XSRETURN_PV(msgbuf);
	}
    }
    else {
	if (FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
			  &source, SvIV(ST(0)), 0,
			  msgbuf, sizeof(msgbuf)-1, NULL))
	    XSRETURN_PV(msgbuf);
    }

    XSRETURN_UNDEF;
}

static
XS(w32_Spawn)
{
    dXSARGS;
    char *cmd, *args;
    void *env;
    char *dir;
    PROCESS_INFORMATION stProcInfo;
    STARTUPINFO stStartInfo;
    BOOL bSuccess = FALSE;

    if (items != 3)
	Perl_croak(aTHX_ "usage: Win32::Spawn($cmdName, $args, $PID)");

    cmd = SvPV_nolen(ST(0));
    args = SvPV_nolen(ST(1));

    env = PerlEnv_get_childenv();
    dir = PerlEnv_get_childdir();

    memset(&stStartInfo, 0, sizeof(stStartInfo));   /* Clear the block */
    stStartInfo.cb = sizeof(stStartInfo);	    /* Set the structure size */
    stStartInfo.dwFlags = STARTF_USESHOWWINDOW;	    /* Enable wShowWindow control */
    stStartInfo.wShowWindow = SW_SHOWMINNOACTIVE;   /* Start min (normal) */

    if (CreateProcess(
		cmd,			/* Image path */
		args,	 		/* Arguments for command line */
		NULL,			/* Default process security */
		NULL,			/* Default thread security */
		FALSE,			/* Must be TRUE to use std handles */
		NORMAL_PRIORITY_CLASS,	/* No special scheduling */
		env,			/* Inherit our environment block */
		dir,			/* Inherit our currrent directory */
		&stStartInfo,		/* -> Startup info */
		&stProcInfo))		/* <- Process info (if OK) */
    {
	int pid = (int)stProcInfo.dwProcessId;
	if (IsWin95() && pid < 0)
	    pid = -pid;
	sv_setiv(ST(2), pid);
	CloseHandle(stProcInfo.hThread);/* library source code does this. */
	bSuccess = TRUE;
    }
    PerlEnv_free_childenv(env);
    PerlEnv_free_childdir(dir);
    XSRETURN_IV(bSuccess);
}

static
XS(w32_GetTickCount)
{
    dXSARGS;
    DWORD msec = GetTickCount();
    EXTEND(SP,1);
    if ((IV)msec > 0)
	XSRETURN_IV(msec);
    XSRETURN_NV(msec);
}

static
XS(w32_GetShortPathName)
{
    dXSARGS;
    SV *shortpath;
    DWORD len;

    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::GetShortPathName($longPathName)");

    shortpath = sv_mortalcopy(ST(0));
    SvUPGRADE(shortpath, SVt_PV);
    if (!SvPVX(shortpath) || !SvLEN(shortpath))
        XSRETURN_UNDEF;

    /* src == target is allowed */
    do {
	len = GetShortPathName(SvPVX(shortpath),
			       SvPVX(shortpath),
			       SvLEN(shortpath));
    } while (len >= SvLEN(shortpath) && sv_grow(shortpath,len+1));
    if (len) {
	SvCUR_set(shortpath,len);
	*SvEND(shortpath) = '\0';
	ST(0) = shortpath;
	XSRETURN(1);
    }
    XSRETURN_UNDEF;
}

static
XS(w32_GetFullPathName)
{
    dXSARGS;
    SV *filename;
    SV *fullpath;
    char *filepart;
    DWORD len;
    STRLEN filename_len;
    char *filename_p;

    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::GetFullPathName($filename)");

    filename = ST(0);
    filename_p = SvPV(filename, filename_len);
    fullpath = sv_2mortal(newSVpvn(filename_p, filename_len));
    if (!SvPVX(fullpath) || !SvLEN(fullpath))
        XSRETURN_UNDEF;

    do {
	len = GetFullPathName(SvPVX(filename),
			      SvLEN(fullpath),
			      SvPVX(fullpath),
			      &filepart);
    } while (len >= SvLEN(fullpath) && sv_grow(fullpath,len+1));
    if (len) {
	if (GIMME_V == G_ARRAY) {
	    EXTEND(SP,1);
	    if (filepart) {
		XST_mPV(1,filepart);
		len = filepart - SvPVX(fullpath);
	    }
	    else {
		XST_mPVN(1,"",0);
	    }
	    items = 2;
	}
	SvCUR_set(fullpath,len);
	*SvEND(fullpath) = '\0';
	ST(0) = fullpath;
	XSRETURN(items);
    }
    XSRETURN_EMPTY;
}

static
XS(w32_GetLongPathName)
{
    dXSARGS;
    SV *path;
    char tmpbuf[MAX_PATH+1];
    char *pathstr;
    STRLEN len;

    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::GetLongPathName($pathname)");

    path = ST(0);
    pathstr = SvPV(path,len);
    strcpy(tmpbuf, pathstr);
    pathstr = win32_longpath(tmpbuf);
    if (pathstr) {
	ST(0) = sv_2mortal(newSVpvn(pathstr, strlen(pathstr)));
	XSRETURN(1);
    }
    XSRETURN_EMPTY;
}

static
XS(w32_Sleep)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::Sleep($milliseconds)");
    Sleep(SvIV(ST(0)));
    XSRETURN_YES;
}

static
XS(w32_CopyFile)
{
    dXSARGS;
    BOOL bResult;
    if (items != 3)
	Perl_croak(aTHX_ "usage: Win32::CopyFile($from, $to, $overwrite)");
    if (USING_WIDE()) {
	WCHAR wSourceFile[MAX_PATH+1];
	WCHAR wDestFile[MAX_PATH+1];
	A2WHELPER(SvPV_nolen(ST(0)), wSourceFile, sizeof(wSourceFile));
	wcscpy(wSourceFile, PerlDir_mapW(wSourceFile));
	A2WHELPER(SvPV_nolen(ST(1)), wDestFile, sizeof(wDestFile));
	bResult = CopyFileW(wSourceFile, PerlDir_mapW(wDestFile), !SvTRUE(ST(2)));
    }
    else {
	char szSourceFile[MAX_PATH+1];
	strcpy(szSourceFile, PerlDir_mapA(SvPV_nolen(ST(0))));
	bResult = CopyFileA(szSourceFile, PerlDir_mapA(SvPV_nolen(ST(1))), !SvTRUE(ST(2)));
    }

    if (bResult)
	XSRETURN_YES;
    XSRETURN_NO;
}

a4584 1
    dXSUB_SYS;
d4586 11
a4596 21
    /* these names are Activeware compatible */
    newXS("Win32::GetCwd", w32_GetCwd, file);
    newXS("Win32::SetCwd", w32_SetCwd, file);
    newXS("Win32::GetNextAvailDrive", w32_GetNextAvailDrive, file);
    newXS("Win32::GetLastError", w32_GetLastError, file);
    newXS("Win32::SetLastError", w32_SetLastError, file);
    newXS("Win32::LoginName", w32_LoginName, file);
    newXS("Win32::NodeName", w32_NodeName, file);
    newXS("Win32::DomainName", w32_DomainName, file);
    newXS("Win32::FsType", w32_FsType, file);
    newXS("Win32::GetOSVersion", w32_GetOSVersion, file);
    newXS("Win32::IsWinNT", w32_IsWinNT, file);
    newXS("Win32::IsWin95", w32_IsWin95, file);
    newXS("Win32::FormatMessage", w32_FormatMessage, file);
    newXS("Win32::Spawn", w32_Spawn, file);
    newXS("Win32::GetTickCount", w32_GetTickCount, file);
    newXS("Win32::GetShortPathName", w32_GetShortPathName, file);
    newXS("Win32::GetFullPathName", w32_GetFullPathName, file);
    newXS("Win32::GetLongPathName", w32_GetLongPathName, file);
    newXS("Win32::CopyFile", w32_CopyFile, file);
    newXS("Win32::Sleep", w32_Sleep, file);
a4597 11

    /* XXX Bloat Alert! The following Activeware preloads really
     * ought to be part of Win32::Sys::*, so they're not included
     * here.
     */
    /* LookupAccountName
     * LookupAccountSID
     * InitiateSystemShutdown
     * AbortSystemShutdown
     * ExpandEnvrironmentStrings
     */
a4610 3
#ifdef USE_5005THREADS
    return aTHX;
#else
a4612 1
#endif
a4623 4
#else
#ifdef USE_5005THREADS
    dTHX;
#endif
d4669 102
d4774 8
d4792 17
d4814 2
d4817 1
d4849 16
a4867 1

d4878 6
d4888 1
d4897 1
a4897 1
    Newx(w32_pseudo_children, 1, child_tab);
a4899 1
    w32_init_socktype		= 0;
d4901 1
d4906 1
a4906 1
#  ifdef MULTIPLICTY
d4914 10
d4937 2
a4938 2
    	KillTimer(NULL,w32_timerid);
    	w32_timerid=0;
d4940 2
d4965 4
a4968 4
    Newxz(dst->pseudo_children, 1, child_tab);
    dst->thr_intern.Winit_socktype = 0;
    dst->timerid                 = 0;
    dst->poll_count              = 0;
a4972 29

static void
win32_free_argvw(pTHX_ void *ptr)
{
    char** argv = (char**)ptr;
    while(*argv) {
	Safefree(*argv);
	*argv++ = Nullch;
    }
}

void
win32_argv2utf8(int argc, char** argv)
{
    dTHX;
    char* psz;
    int length, wargc;
    LPWSTR* lpwStr = CommandLineToArgvW(GetCommandLineW(), &wargc);
    if (lpwStr && argc) {
	while (argc--) {
	    length = WideCharToMultiByte(CP_UTF8, 0, lpwStr[--wargc], -1, NULL, 0, NULL, NULL);
	    Newxz(psz, length, char);
	    WideCharToMultiByte(CP_UTF8, 0, lpwStr[wargc], -1, psz, length, NULL, NULL);
	    argv[argc] = psz;
	}
	call_atexit(win32_free_argvw, argv);
    }
    GlobalFree((HGLOBAL)lpwStr);
}
@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d120 10
d151 4
d270 2
a271 1
	sv_catpvn(*prev_pathp, ";", 1);
d475 2
a476 2
	New(1307, ret, slen+2, char);
	New(1308, retv, (slen+3)/2, char*);
d545 1
a545 1
    New(1306, argv, (sp - mark) + w32_perlshell_items + 2, char*);
d633 2
a634 2
	New(1301,argv, strlen(cmd) / 2 + 2, char*);
	New(1302,cmd2, strlen(cmd) + 1, char);
d671 1
a671 1
	New(1306, argv, w32_perlshell_items + 2, char*);
d759 1
a759 1
    Newz(1303, dirp, 1, DIR);
d820 1
a820 1
    New(1304, dirp->start, dirp->size, char);
d1484 1
a1484 1
	    New(1309,wCuritem,length,WCHAR);
d1495 1
a1495 1
	    New(1309,curitem,strlen(name)+1,char);
d2600 1
a2600 1
#if defined(__BORLAND__) /* buk */
d2645 1
a2645 1
    return fseek(pf, offset, origin);
d2737 18
d2756 2
a2757 1
    BY_HANDLE_FILE_INFORMATION bhfi;
d2759 3
d3217 1
a3217 1
    return chsize(fd, size);
d3243 1
a3243 1
    return lseek(fd, offset, origin);
d3676 1
a3676 1
    New(1310, cmd, len, char);
d3780 1
a3780 1
    New(0, fullcmd, (pathstr ? strlen(pathstr) : 0) + cmdlen + 6, char);
d3895 1
a3895 1
    New(0, ptr, strlen(szfilename)+1, char);
d3943 1
a3943 1
	    New(0,cname,clen+1,char);
d4089 1
d4091 3
d4095 1
d4097 3
d4119 1
d4121 3
d5166 1
a5166 1
    New(1313, w32_children, 1, child_tab);
d5170 1
a5170 1
    New(1313, w32_pseudo_children, 1, child_tab);
d5185 2
a5186 2
	signal(SIGINT,&win32_csighandler);
	signal(SIGBREAK,&win32_csighandler);
d5224 1
a5224 1
    Newz(1313, dst->children, 1, child_tab);
d5226 1
a5226 1
    Newz(1313, dst->pseudo_children, 1, child_tab);
d5255 1
a5255 1
	    Newz(0, psz, length, char);
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@a4157 1
static DWORD allocsize = 0;		/* XXX threadead */
a4169 1
   allocsize = info.dwAllocationGranularity;
a4170 4
 /* This scheme fails eventually if request for contiguous
  * block is denied so reserve big blocks - this is only
  * address space not memory ...
  */
d4173 1
a4173 1
   DWORD size = 64*1024*1024;
d4175 1
d4181 3
d4185 1
d4188 2
d4194 4
d4209 13
d4232 4
a4235 1
   char *addr = (char *) VirtualAlloc(committed,size,MEM_COMMIT,PAGE_READWRITE);
d4237 1
a4237 3
    {
     committed += size;
    }
d4829 2
d4836 2
a4837 2
    fullpath = sv_mortalcopy(filename);
    SvUPGRADE(fullpath, SVt_PV);
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d1185 4
d2585 3
d2592 1
d2602 7
d2628 1
d2637 7
d2645 1
d2651 3
d2655 1
d3188 15
d3204 1
d3214 16
d3231 1
d3604 2
a3605 1
	    len += 3;
d3642 1
a3642 1
    if (bat_file) {
d3740 4
a3743 1
    New(0, fullcmd, MAX_PATH+1, char);
d3784 1
a3784 3
		    if ((STRLEN)(curfullcmd-fullcmd) < MAX_PATH-cmdlen-5)
			*curfullcmd++ = *pathstr;
		    pathstr++;
d3790 1
a3790 3
		if ((STRLEN)(curfullcmd-fullcmd) < MAX_PATH-cmdlen-5)
		    *curfullcmd++ = *pathstr;
		pathstr++;
d4625 3
d4647 3
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3133 1
a3133 1
	    if (count < 0) {
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d18 2
a19 1
#ifndef __MINGW32__	/* GCC/Mingw32-2.95.2 forgot the WINAPI on CommandLineToArgvW() */
d64 2
a65 2
#if defined(__MINGW32__)
/* Mingw32 is missing some prototypes */
d509 1
a509 1
				    ? "cmd.exe /x/c" : "command.com /c");
d1070 1
d1118 5
d1134 1
d1141 2
a1142 1
		    return 0;
d1145 1
a1145 1
			return 0;
d1147 5
d1154 3
a1156 4
		    if (TerminateProcess(hProcess, sig)) {
			CloseHandle(hProcess);
			return 0;
		    }
d1159 3
d1902 1
a1902 1
	    if (w32_timerid) {
d1906 2
d1917 1
d1933 2
d1959 1
a1959 4
	    if (win32_async_check(aTHX)) {
		/* was one of ours */
		break;
	    }
d2100 1
d2637 2
a2638 2
DllExport FILE*
win32_tmpfile(void)
d2662 1
a2662 1
		    return fdopen(fd, "w+b");
d2667 9
d2780 6
d2794 1
a2794 4
    /* save the old std handle, and set the std handle */
    OP_REFCNT_LOCK;
    lock_held = 1;
    old_h = GetStdHandle(nhandle);
d2803 6
a2808 1
	/* restore the old std handle */
a2814 4
	/* revert stdfd to whatever it was before */
	if (win32_dup2(oldfd, stdfd) == -1)
	    goto cleanup;

d3107 49
d3630 3
a3632 1
	    && (stricmp(arg, "/x/c") == 0 || stricmp(arg, "/c") == 0))
d4004 1
a4004 1
	int status = win32_spawnvp(P_WAIT, cmdname, (char *const *)argv);
d4462 1
a4462 1
		WideCharToMultiByte(CP_ACP, NULL, pwi->wki100_langroup,
d4466 1
a4466 1
		WideCharToMultiByte(CP_ACP, NULL, pwi->wki100_computername,
d4521 19
a4539 1
    OSVERSIONINFOA osver;
d4542 13
a4554 1
	OSVERSIONINFOW osverw;
d4556 7
a4562 3
	osverw.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
	if (!GetVersionExW(&osverw)) {
	    XSRETURN_EMPTY;
d4566 8
a4573 4
	osver.dwMajorVersion = osverw.dwMajorVersion;
	osver.dwMinorVersion = osverw.dwMinorVersion;
	osver.dwBuildNumber = osverw.dwBuildNumber;
	osver.dwPlatformId = osverw.dwPlatformId;
d4576 7
a4582 3
	osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	if (!GetVersionExA(&osver)) {
	    XSRETURN_EMPTY;
d4590 6
d4728 1
d4762 7
a4768 2
	    XST_mPV(1,filepart);
	    len = filepart - SvPVX(fullpath);
d4772 1
d4970 7
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 * (c) 1995 Microsoft Corporation. All rights reserved. 
d10 1
a10 1

d25 1
a28 1
#define PERLIO_NOT_STDIO 0 
d57 1
a57 1
/* Mingw32 defaults to globing command line 
a87 2
#  undef do_spawn
#  define do_spawn g_do_spawn
a91 7
#if defined(PERL_OBJECT)
#  undef do_aspawn
#  define do_aspawn g_do_aspawn
#  undef Perl_do_exec
#  define Perl_do_exec g_do_exec
#endif

d94 1
a94 1
	int		do_spawn2(char *cmd, int exectype);
d119 1
a119 1
int 
d173 1
a173 1
	    dTHXo;
a208 1
    int oldsize, newsize;
d252 1
a252 1
	dTHXo;
d266 1
a266 1
    dTHXo;
d283 1
a283 1
    dTHXo;
a285 2
    DWORD datalen;
    int len, newsize;
d429 1
a429 1
    dTHXo;
d455 1
a455 1
	dTHXo;
d498 1
a498 1
    dTHXo;
d509 1
a509 1
	const char *usershell = getenv("PERL5SHELL");
d517 1
a517 1
do_aspawn(void *vreally, void **vmark, void **vsp)
a518 4
    dTHXo;
    SV *really = (SV*)vreally;
    SV **mark = (SV**)vmark;
    SV **sp = (SV**)vsp;
d543 1
a543 1
   
d556 1
a556 1
   
d569 1
a569 1
		Perl_warner(aTHX_ WARN_EXEC, "Can't spawn \"%s\": %s", argv[0], strerror(errno));
d580 26
a605 2
int
do_spawn2(char *cmd, int exectype)
a606 1
    dTHXo;
d626 1
a626 2
	    while (*s && !isSPACE(*s))
		s++;
d683 1
a683 1
		Perl_warner(aTHX_ WARN_EXEC, "Can't %s \"%s\": %s",
d696 1
a696 1
do_spawn(char *cmd)
d698 1
a698 1
    return do_spawn2(cmd, EXECF_SPAWN);
d702 1
a702 1
do_spawn_nowait(char *cmd)
d704 1
a704 1
    return do_spawn2(cmd, EXECF_SPAWN_NOWAIT);
d710 1
a710 1
    do_spawn2(cmd, EXECF_EXEC);
d721 1
a721 1
    dTHXo;
d726 1
a726 1
    struct stat		sbuf;
d833 1
a833 1
	    dTHXo;
d859 1
a859 1
		 * new name and it's null terminator */
d874 1
a874 1
    } 
d907 1
a907 1
    dTHXo;
d956 1
a956 1
{ 
d969 1
a969 1
    dTHXo;
d984 25
d1012 1
a1012 1
    dTHXo;
d1015 1
a1015 1
	if (w32_child_pids[child] == pid)
d1025 1
a1025 1
	dTHXo;
d1039 1
a1039 1
    dTHXo;
d1042 1
a1042 1
	if (w32_pseudo_child_pids[child] == pid)
d1052 1
a1052 1
	dTHXo;
d1066 1
a1066 1
    dTHXo;
a1073 2
	    if (!sig)
		return 0;
d1075 3
a1077 2
	    if (TerminateThread(hProcess, sig)) {
		remove_dead_pseudo_process(child);
d1079 17
a1095 1
	    }
d1107 4
a1110 1
	    if (!sig)
d1112 12
a1123 5
	    hProcess = w32_child_handles[child];
	    if (TerminateProcess(hProcess, sig)) {
		remove_dead_process(child);
		return 0;
	    }
d1130 3
a1132 4
		if (!sig)
		    return 0;
		if (TerminateProcess(hProcess, sig)) {
		    CloseHandle(hProcess);
d1134 10
a1151 11
/*
 * File system stuff
 */

DllExport unsigned int
win32_sleep(unsigned int t)
{
    Sleep(t*1000);
    return 0;
}

d1153 1
a1153 1
win32_stat(const char *path, struct stat *sbuf)
d1155 2
a1156 2
    dTHXo;
    char	buffer[MAX_PATH+1]; 
d1210 5
a1214 1
	res = _wstat(pwbuffer, (struct _stat *)sbuf);
d1217 3
d1221 1
d1239 1
a1239 1
	    Zero(sbuf, 1, struct stat);
d1285 12
d1312 1
a1312 3
    if (isALPHA(path[0]) && path[1] == ':' &&
	(path[2] == '/' || path[2] == '\\'))
    {
d1318 1
a1318 3
    else if ((path[0] == '/' || path[0] == '\\') &&
	     (path[1] == '/' || path[1] == '\\'))
    {
d1322 3
a1324 2
	/* copy machine name */
	while (*start && *start != '/' && *start != '\\')
d1326 2
a1327 6
	if (*start) {
	    *tmpstart++ = *start;
	    start++;
	    /* copy share name */
	    while (*start && *start != '/' && *start != '\\')
		*tmpstart++ = *start++;
a1329 3
    sep = *start++;
    if (sep == '/' || sep == '\\')
	*tmpstart++ = sep;
d1331 22
a1352 4
    while (sep) {
	/* walk up to slash */
	while (*start && *start != '/' && *start != '\\')
	    ++start;
d1354 2
a1355 2
	/* discard doubled slashes */
	while (*start && (start[1] == '/' || start[1] == '\\'))
a1356 1
	sep = *start;
d1359 1
d1362 1
d1364 11
a1374 7
	    strcpy(tmpstart, fdata.cFileName);
	    tmpstart += strlen(fdata.cFileName);
	    if (sep)
		*tmpstart++ = sep;
	    *tmpstart = '\0';
	    *start++ = sep;
	    FindClose(fhand);
d1379 1
a1379 1
	    *start = sep;
d1390 1
a1390 1
    dTHXo;
d1439 1
a1439 1
    dTHXo;
d1504 2
a1505 1
    if (GetProcessTimes(GetCurrentProcess(), &dummy, &dummy, 
d1511 1
a1511 2
        
    } else { 
d1513 1
a1513 2
        clock_t t = clock();
	timebuf->tms_utime = t;
d1518 1
a1518 1
    return 0;
d1547 1
a1547 1
    dTHXo;
d1592 1
a1592 1
    dTHXo;
d1647 32
d1745 1
d1749 3
a1751 2
#if (defined(__BORLANDC__)&&(__BORLANDC__<=0x520)) || defined(__MINGW32__)
	switch (info.u.s.wProcessorArchitecture) {
d1753 1
a1753 1
	switch (info.wProcessorArchitecture) {
d1755 1
d1764 32
d1797 3
a1799 1
	    arch = "unknown"; break;
d1801 2
a1802 1
	strcpy(name->machine, arch);
d1807 211
d2021 1
a2021 1
    dTHXo;
d2026 1
a2026 1
	return win32_wait(status);
d2032 2
a2033 1
	    DWORD waitcode = WaitForSingleObject(hThread, timeout);
d2037 1
a2037 1
	    else if (waitcode != WAIT_FAILED) {
d2060 1
a2060 1
	    waitcode = WaitForSingleObject(hProcess, timeout);
d2064 1
a2064 1
	    else if (waitcode != WAIT_FAILED) {
d2080 1
a2080 1
		waitcode = WaitForSingleObject(hProcess, timeout);
d2084 1
a2084 1
		else if (waitcode != WAIT_FAILED) {
d2097 1
a2097 1
    return retval >= 0 ? pid : retval;                
d2103 1
a2103 56
    /* XXX this wait emulation only knows about processes
     * spawned via win32_spawnvp(P_NOWAIT, ...).
     */
    dTHXo;
    int i, retval;
    DWORD exitcode, waitcode;

#ifdef USE_ITHREADS
    if (w32_num_pseudo_children) {
	waitcode = WaitForMultipleObjects(w32_num_pseudo_children,
					  w32_pseudo_child_handles,
					  FALSE,
					  INFINITE);
	if (waitcode != WAIT_FAILED) {
	    if (waitcode >= WAIT_ABANDONED_0
		&& waitcode < WAIT_ABANDONED_0 + w32_num_pseudo_children)
		i = waitcode - WAIT_ABANDONED_0;
	    else
		i = waitcode - WAIT_OBJECT_0;
	    if (GetExitCodeThread(w32_pseudo_child_handles[i], &exitcode)) {
		*status = (int)((exitcode & 0xff) << 8);
		retval = (int)w32_pseudo_child_pids[i];
		remove_dead_pseudo_process(i);
		return -retval;
	    }
	}
    }
#endif

    if (!w32_num_children) {
	errno = ECHILD;
	return -1;
    }

    /* if a child exists, wait for it to die */
    waitcode = WaitForMultipleObjects(w32_num_children,
				      w32_child_handles,
				      FALSE,
				      INFINITE);
    if (waitcode != WAIT_FAILED) {
	if (waitcode >= WAIT_ABANDONED_0
	    && waitcode < WAIT_ABANDONED_0 + w32_num_children)
	    i = waitcode - WAIT_ABANDONED_0;
	else
	    i = waitcode - WAIT_OBJECT_0;
	if (GetExitCodeProcess(w32_child_handles[i], &exitcode) ) {
	    *status = (int)((exitcode & 0xff) << 8);
	    retval = (int)w32_child_pids[i];
	    remove_dead_process(i);
	    return retval;
	}
    }

FAILED:
    errno = GetLastError();
    return -1;
d2106 2
a2107 5
#ifndef PERL_OBJECT

static UINT timerid = 0;

static VOID CALLBACK TimerProc(HWND win, UINT msg, UINT id, DWORD time)
d2109 3
a2111 4
    dTHXo;
    KillTimer(NULL,timerid);
    timerid=0;  
    CALL_FPTR(PL_sighandlerp)(14);
a2112 1
#endif	/* !PERL_OBJECT */
d2117 1
a2117 2
#ifndef PERL_OBJECT
    /* 
d2119 2
a2120 2
     * which does whatever receiving SIGALRM would do 
     * we cannot use SIGALRM even via raise() as it is not 
d2122 11
a2132 20
     *
     * Snag is unless something is looking at the message queue
     * nothing happens :-(
     */ 
    dTHXo;
    if (sec)
     {
      timerid = SetTimer(NULL,timerid,sec*1000,(TIMERPROC)TimerProc);
      if (!timerid)
       Perl_croak_nocontext("Cannot set timer");
     } 
    else
     {
      if (timerid)
       {
        KillTimer(NULL,timerid);
        timerid=0;  
       }
     }
#endif	/* !PERL_OBJECT */
d2143 1
a2143 1
    dTHXo;
d2161 1
a2161 1
*int my_open_osfhandle(long osfhandle, int flags) - open C Runtime file handle
d2172 1
a2172 1
*       long osfhandle - Win32 HANDLE to associate with C Runtime file handle.
d2196 1
a2196 1
    int fh = _open_osfhandle((long)hF, 0);
d2205 1
a2205 1
my_open_osfhandle(long osfhandle, int flags)
d2255 1
a2255 1
	dTHXo;
d2340 1
a2340 1
 * Since the errors returned by the socket error function 
d2346 1
a2346 1
win32_strerror(int e) 
d2348 1
a2348 1
#ifndef __BORLANDC__		/* Borland intolerance */
d2354 1
a2354 1
        dTHXo;
d2360 1
a2360 1
			  sizeof(w32_strerror_buffer), NULL) == 0) 
d2394 1
a2394 1
	dTHXo;
a2399 1

d2447 1
a2447 1
    dTHXo;
d2450 1
a2450 1
    
d2478 1
a2478 1
    dTHXo;
d2496 1
a2496 1
    dTHXo;
d2558 1
a2558 1
DllExport long
d2561 6
d2568 1
d2572 1
a2572 1
win32_fseek(FILE *pf,long offset,int origin)
d2574 21
d2596 1
d2621 28
a2648 1
    return tmpfile();
d2659 1
a2659 1
win32_fstat(int fd,struct stat *sbufptr)
d2665 1
a2665 1
     */ 
d2688 8
d2698 2
d2702 1
a2702 1
DllExport FILE*
d2708 1
d2714 3
d2723 1
d2729 1
d2745 1
a2745 1
    if (win32_pipe( p, 512, ourmode) == -1)
d2760 6
d2768 1
a2768 1
	dTHXo;
d2772 7
d2795 1
a2795 1
    return (win32_fdopen(p[parent], (char *)mode));
d2801 5
d2820 1
a2820 1
win32_pclose(FILE *pf)
d2825 1
a2825 1
    dTHXo;
d2830 1
a2830 1
    sv = *av_fetch(w32_fdpid, win32_fileno(pf), TRUE);
d2842 5
a2846 1
    win32_fclose(pf);
d2895 2
a2896 1
#if defined(__BORLANDC__) || defined(__MINGW32__)
d2919 1
a2919 1
    dTHXo;
d2952 1
a2952 1
    dTHXo;
d3075 2
a3076 2
DllExport long
win32_lseek(int fd, long offset, int origin)
d3078 3
d3082 1
d3085 1
a3085 1
DllExport long
d3088 3
d3092 1
d3098 1
a3098 1
    dTHXo;
d3117 3
d3123 1
a3123 1
    return close(fd);
d3331 1
a3331 1
functionexit:	
d3359 1
a3359 1
    dTHXo;
d3371 1
a3371 1
    dTHXo;
d3383 5
a3387 1
    dTHXo;
d3399 1
a3399 1
    dTHXo;
d3411 1
a3411 1
    dTHXo;
d3422 1
a3422 1
create_command_line(const char* command, const char * const *args)
d3424 60
a3483 4
    dTHXo;
    int index;
    char *cmd, *ptr, *arg;
    STRLEN len = strlen(command) + 1;
d3485 9
a3493 2
    for (index = 0; (ptr = (char*)args[index]) != NULL; ++index)
	len += strlen(ptr) + 1;
d3495 1
d3498 5
a3502 1
    strcpy(ptr, command);
d3505 33
a3537 2
	ptr += strlen(ptr);
	*ptr++ = ' ';
d3539 25
d3566 5
d3577 1
a3577 1
    dTHXo;
d3594 1
a3594 1
    pathstr = win32_getenv("PATH");
d3636 1
a3636 1
		    if (curfullcmd-fullcmd < MAX_PATH-cmdlen-5)
d3644 1
a3644 1
		if (curfullcmd-fullcmd < MAX_PATH-cmdlen-5)
d3657 1
a3657 1
GIVE_UP:
d3668 2
a3669 2
void*
get_childenv(void)
d3674 7
a3680 2
void
free_childenv(void* d)
d3682 15
d3699 2
a3700 2
char*
get_childdir(void)
d3702 1
a3702 1
    dTHXo;
d3719 2
a3720 2
void
free_childdir(char* d)
d3722 1
a3722 1
    dTHXo;
d3733 1
a3733 1
 * 
d3744 1
a3744 1
    dTHXo;
d3752 22
d3775 1
a3775 3
    char *cmd = create_command_line(cmdname, strcmp(cmdname, argv[0]) == 0
			     	             ? &argv[1] : argv);
    char *fullcmd = Nullch;
d3787 4
d3792 1
d3805 8
a3812 8
    StartupInfo.dwX		= tbl.dwX; 
    StartupInfo.dwY		= tbl.dwY; 
    StartupInfo.dwXSize		= tbl.dwXSize; 
    StartupInfo.dwYSize		= tbl.dwYSize; 
    StartupInfo.dwXCountChars	= tbl.dwXCountChars; 
    StartupInfo.dwYCountChars	= tbl.dwYCountChars; 
    StartupInfo.dwFillAttribute	= tbl.dwFillAttribute; 
    StartupInfo.wShowWindow	= tbl.wShowWindow; 
d3816 3
a3818 3
    if (StartupInfo.hStdInput != INVALID_HANDLE_VALUE &&
	StartupInfo.hStdOutput != INVALID_HANDLE_VALUE &&
	StartupInfo.hStdError != INVALID_HANDLE_VALUE)
d3820 3
d3825 3
a3827 2
    else {
	create |= CREATE_NEW_CONSOLE;
d3830 2
d3833 1
a3833 1
    if (!CreateProcess(cmdname,		/* search PATH to find executable */
d3851 1
a3851 1
	    fullcmd = qualified_path(cmdname);
d3853 6
a3858 1
		cmdname = fullcmd;
d3879 4
a3882 1
	WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
d3894 2
a3895 1
    Safefree(fullcmd);
d3904 1
a3904 1
    dTHXo;
d3917 1
a3917 1
    dTHXo;
d3920 9
a3928 2
    if (w32_pseudo_id)
	return win32_spawnvp(P_WAIT, cmdname, (char *const *)argv);
d4009 6
a4014 6
static char *committed = NULL;
static char *base      = NULL;
static char *reserved  = NULL;
static char *brk       = NULL;
static DWORD pagesize  = 0;
static DWORD allocsize = 0;
d4017 1
a4017 1
sbrk(int need)
d4030 1
a4030 1
  * block is denied so reserve big blocks - this is only 
d4044 1
a4044 1
   /* Reserve some (more) space 
d4109 2
a4110 2
int
win32_open_osfhandle(long handle, int flags)
d4119 1
a4119 1
long
d4122 53
a4174 1
    return _get_osfhandle(fd);
d4180 1
a4180 1
    dTHXo;
d4217 26
d4248 4
a4251 4
    /* 
     * If ptr != Nullch 
     *   then it worked, set PV valid, 
     *   else return 'undef' 
d4258 4
d4519 2
d4531 3
d4546 2
a4547 2
		NULL,			/* Inherit our environment block */
		NULL,			/* Inherit our currrent directory */
d4558 2
d4703 1
a4703 1
    dTHXo;
d4728 1
d4742 77
d4842 21
d4865 10
a4874 9
#  ifdef PERL_OBJECT
#    undef Perl_sys_intern_init
#    define Perl_sys_intern_init CPerlObj::Perl_sys_intern_init
#    undef Perl_sys_intern_dup
#    define Perl_sys_intern_dup CPerlObj::Perl_sys_intern_dup
#    undef Perl_sys_intern_clear
#    define Perl_sys_intern_clear CPerlObj::Perl_sys_intern_clear
#    define pPerl this
#  endif
d4879 1
d4892 16
d4917 11
d4946 3
a4952 5
#ifdef PERL_OBJECT
#  undef this
#  define this pPerl
#endif

d4954 1
a4954 1
win32_free_argvw(pTHXo_ void *ptr)
d4966 1
a4966 1
    dTHXo;
a4980 1

@


1.3
log
@perl-5.6.0 + local changes
@
text
@a55 1

d179 3
a181 1
	if (retval == ERROR_SUCCESS && type == REG_SZ) {
d439 1
d445 7
a451 1
    return _getpid();
d578 5
a582 1
    if (flag != P_NOWAIT) {
a583 1
    	    dTHR;
d670 5
a674 1
    if (exectype != EXECF_SPAWN_NOWAIT) {
a675 1
    	    dTHR;
d1037 1
d1041 1
a1041 1
	long child = find_pseudo_pid(-pid);
d1051 4
d1059 1
a1059 1
	long child = find_pid(pid);
d1070 3
a1072 1
	    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pid);
a1299 2
#ifndef USE_WIN32_RTL_ENV

a1400 2
#endif

d1630 1
a1630 1
#if defined(__BORLANDC__) || defined(__MINGW32__)
d1655 1
d1657 1
d1662 1
a1662 1
	long child = find_pseudo_pid(-pid);
d1665 5
a1669 2
	    DWORD waitcode = WaitForSingleObject(hThread, INFINITE);
	    if (waitcode != WAIT_FAILED) {
d1674 1
a1674 1
		    return retval;
d1680 4
d1687 3
a1689 1
	long child = find_pid(pid);
d1691 6
a1696 3
	    HANDLE hProcess = w32_child_handles[child];
	    DWORD waitcode = WaitForSingleObject(hProcess, INFINITE);
	    if (waitcode != WAIT_FAILED) {
d1708 19
a1726 6
	    retval = cwait(status, pid, WAIT_CHILD);
	    /* cwait() returns "correctly" on Borland */
#ifndef __BORLANDC__
	    if (status)
		*status *= 256;
#endif
d1758 1
a1758 1
		return retval;
d1802 1
a1802 1
    sighandler(14);
a1846 1
    dTHR;
a1853 47
/* C doesn't like repeat struct definitions */

#if defined(USE_FIXED_OSFHANDLE) || defined(PERL_MSVCRT_READFIX)

#ifndef _CRTIMP
#define _CRTIMP __declspec(dllimport)
#endif

/*
 * Control structure for lowio file handles
 */
typedef struct {
    long osfhnd;    /* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
    int lockinitflag;
    CRITICAL_SECTION lock;
} ioinfo;


/*
 * Array of arrays of control structures for lowio files.
 */
EXTERN_C _CRTIMP ioinfo* __pioinfo[];

/*
 * Definition of IOINFO_L2E, the log base 2 of the number of elements in each
 * array of ioinfo structs.
 */
#define IOINFO_L2E	    5

/*
 * Definition of IOINFO_ARRAY_ELTS, the number of elements in ioinfo array
 */
#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)

/*
 * Access macros for getting at an ioinfo struct and its fields from a
 * file handle
 */
#define _pioinfo(i) (__pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - 1)))
#define _osfhnd(i)  (_pioinfo(i)->osfhnd)
#define _osfile(i)  (_pioinfo(i)->osfile)
#define _pipech(i)  (_pioinfo(i)->pipech)

#endif

a1891 4
/* since we are not doing a dup2(), this works fine */

#define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = osfh)

d2308 19
a2326 1
    return fstat(fd,sbufptr);
d2404 1
d2406 1
d2442 1
d2444 1
d2457 1
d3277 4
d3282 1
a3282 2
	w32_child_pids[w32_num_children] = ProcessInformation.dwProcessId;
	ret = (int)ProcessInformation.dwProcessId;
d3527 19
d3861 4
a3865 1
	sv_setiv(ST(2), stProcInfo.dwProcessId);
d3894 3
d3926 3
a4014 12
    w32_perlshell_tokens = Nullch;
    w32_perlshell_items = -1;
    w32_fdpid = newAV();		/* XXX needs to be in Perl_win32_init()? */
    New(1313, w32_children, 1, child_tab);
    w32_num_children = 0;
    w32_init_socktype = 0;
#ifdef USE_ITHREADS
    w32_pseudo_id = 0;
    New(1313, w32_pseudo_children, 1, child_tab);
    w32_num_pseudo_children = 0;
#endif

d4072 1
a4072 2

#ifdef USE_ITHREADS
d4075 2
d4079 2
d4085 31
d4123 1
d4125 1
a4125 3
    dst->pseudo_id		= 0;
    dst->children->num		= 0;
    dst->thr_intern.Winit_socktype = src->thr_intern.Winit_socktype;
d4127 2
a4128 1
#endif
@


1.2
log
@perl5.005_03 (stock)
@
text
@d18 7
a24 12

#ifndef __MINGW32__
#include <lmcons.h>
#include <lmerr.h>
/* ugliness to work around a buggy struct definition in lmwksta.h */
#undef LPTSTR
#define LPTSTR LPWSTR
#include <lmwksta.h>
#undef LPTSTR
#define LPTSTR LPSTR
#include <lmapibuf.h>
#endif /* __MINGW32__ */
d33 1
a36 2
#include "patchlevel.h"

d38 1
a38 3
#ifdef PERL_OBJECT
extern CPerlObj* pPerl;
#endif
a42 1
#include <sys/stat.h>
d64 14
d82 13
d96 4
a99 12
#undef win32_get_privlib
#define win32_get_privlib g_win32_get_privlib
#undef win32_get_sitelib
#define win32_get_sitelib g_win32_get_sitelib
#undef do_aspawn
#define do_aspawn g_do_aspawn
#undef do_spawn
#define do_spawn g_do_spawn
#undef do_exec
#define do_exec g_do_exec
#undef getlogin
#define getlogin g_getlogin
a101 1
static DWORD		os_id(void);
d103 1
a103 1
static long		tokenize(char *str, char **dest, char ***destv);
d108 11
a118 2
static char *		get_emd_part(char *leading, char *trailing, ...);
static void		remove_dead_process(HANDLE deceased);
d120 1
d122 3
d127 1
a127 22
#ifdef USE_THREADS
#  ifdef USE_DECLSPEC_THREAD
__declspec(thread) char	strerror_buffer[512];
__declspec(thread) char	getlogin_buffer[128];
__declspec(thread) char	w32_perllib_root[MAX_PATH+1];
#    ifdef HAVE_DES_FCRYPT
__declspec(thread) char	crypt_buffer[30];
#    endif
#  else
#    define strerror_buffer	(thr->i.Wstrerror_buffer)
#    define getlogin_buffer	(thr->i.Wgetlogin_buffer)
#    define w32_perllib_root	(thr->i.Ww32_perllib_root)
#    define crypt_buffer	(thr->i.Wcrypt_buffer)
#  endif
#else
static char	strerror_buffer[512];
static char	getlogin_buffer[128];
static char	w32_perllib_root[MAX_PATH+1];
#  ifdef HAVE_DES_FCRYPT
static char	crypt_buffer[30];
#  endif
#endif
d130 3
a132 2
IsWin95(void) {
    return (os_id() == VER_PLATFORM_WIN32_WINDOWS);
d136 27
a162 2
IsWinNT(void) {
    return (os_id() == VER_PLATFORM_WIN32_NT);
d165 5
a169 3
char*
GetRegStrFromKey(HKEY hkey, const char *lpszValueName, char** ptr, DWORD* lpDataLen)
{   /* Retrieve a REG_SZ or REG_EXPAND_SZ from the registry */
d173 1
d177 3
a179 2
    if (retval == ERROR_SUCCESS){
	retval = RegQueryValueEx(handle, lpszValueName, 0, &type, NULL, lpDataLen);
d181 9
a189 10
	    if (*ptr) {
		Renew(*ptr, *lpDataLen, char);
	    }
	    else {
		New(1312, *ptr, *lpDataLen, char);
	    }
	    retval = RegQueryValueEx(handle, lpszValueName, 0, NULL, (PBYTE)*ptr, lpDataLen);
	    if (retval != ERROR_SUCCESS) {
		Safefree(*ptr);
		*ptr = Nullch;
d194 1
a194 1
    return *ptr;
d197 3
a199 2
char*
GetRegStr(const char *lpszValueName, char** ptr, DWORD* lpDataLen)
d201 4
a204 6
    *ptr = GetRegStrFromKey(HKEY_CURRENT_USER, lpszValueName, ptr, lpDataLen);
    if (*ptr == Nullch)
    {
	*ptr = GetRegStrFromKey(HKEY_LOCAL_MACHINE, lpszValueName, ptr, lpDataLen);
    }
    return *ptr;
d207 1
d209 1
a209 1
get_emd_part(char *prev_path, char *trailing_path, ...)
d218 1
d223 2
a224 1
    sprintf(base, "%5.3f", (double) 5 + ((double) PATCHLEVEL / (double) 1000));
d226 5
a230 4
    GetModuleFileName((HMODULE)((w32_perldll_handle == INVALID_HANDLE_VALUE)
				? GetModuleHandle(NULL) : w32_perldll_handle),
		      mod_name, sizeof(mod_name));
    ptr = strrchr(mod_name, '\\');
d235 3
a237 1
	ptr = strrchr(mod_name, '\\');
d239 6
a244 3
	    if(!(*strip == '5' && *(ptr+1) == '5' && strncmp(strip, base, 5) == 0
		    && strncmp(ptr+1, base, 5) == 0)) {
		*optr = '\\';
d253 1
a253 1
	*ptr = '\\';
d259 1
a259 1
    if(GetFileAttributes(mod_name) != (DWORD) -1) {
d261 6
a266 12
	newsize = strlen(mod_name) + 1;
	if (prev_path) {
	    oldsize = strlen(prev_path) + 1;
	    newsize += oldsize;			/* includes plus 1 for ';' */
	    Renew(prev_path, newsize, char);
	    prev_path[oldsize-1] = ';';
	    strcpy(&prev_path[oldsize], mod_name);
	}
	else {
	    New(1311, prev_path, newsize, char);
	    strcpy(prev_path, mod_name);
	}
d269 1
a269 1
    return prev_path;
d273 1
a273 1
win32_get_privlib(char *pl)
d275 1
d278 1
a278 2
    char *path = Nullch;
    DWORD datalen;
d282 2
a283 3
    path = GetRegStr(buffer, &path, &datalen);
    if (!path)
	path = GetRegStr(stdlib, &path, &datalen);
d286 1
a286 1
    return get_emd_part(path, stdlib, ARCHNAME, "bin", Nullch);
d289 2
a290 2
char *
win32_get_sitelib(char *pl)
d292 1
a292 1
    char *sitelib = "sitelib";
a295 2
    char *path1 = Nullch;
    char *path2 = Nullch;
d297 2
d300 16
a315 3
    /* $HKCU{"sitelib-$]"} || $HKLM{"sitelib-$]"} . ---; */
    sprintf(regstr, "%s-%s", sitelib, pl);
    path1 = GetRegStr(regstr, &path1, &datalen);
d317 6
a322 4
    /* $sitelib .=
     * ";$EMD/" . ((-d $EMD/../../../$]) ? "../../.." : "../.."). "/site/$]/lib";  */
    sprintf(pathstr, "site\\%s\\lib", pl);
    path1 = get_emd_part(path1, pathstr, ARCHNAME, "bin", pl, Nullch);
d324 2
a325 2
    /* $HKCU{'sitelib'} || $HKLM{'sitelib'} . ---; */
    path2 = GetRegStr(sitelib, &path2, &datalen);
d327 2
a328 3
    /* $sitelib .=
     * ";$EMD/" . ((-d $EMD/../../../$]) ? "../../.." : "../.."). "/site/lib";  */
    path2 = get_emd_part(path2, "site\\lib", ARCHNAME, "bin", pl, Nullch);
d330 5
a334 2
    if (!path1)
	return path2;
d336 3
a338 2
    if (!path2)
	return path1;
d340 4
a343 9
    len = strlen(path1);
    newsize = len + strlen(path2) + 2; /* plus one for ';' */

    Renew(path1, newsize, char);
    path1[len++] = ';';
    strcpy(&path1[len], path2);

    Safefree(path2);
    return path1;
a345 1

d387 1
a387 1
#if !defined(PERL_OBJECT)
d392 1
a392 1
my_popen(char *cmd, char *mode)
d395 11
a405 11
#define fixcmd(x)	{					\
			    char *pspace = strchr((x),' ');	\
			    if (pspace) {			\
				char *p = (x);			\
				while (p < pspace) {		\
				    if (*p == '/')		\
					*p = '\\';		\
				    p++;			\
				}				\
			    }					\
			}
d410 1
a410 2
    win32_fflush(stdout);
    win32_fflush(stderr);
d415 1
a415 1
my_pclose(PerlIO *fp)
d421 2
a422 2
static DWORD
os_id(void)
d432 12
a443 1
    return (w32_platform);
d453 1
a453 1
tokenize(char *str, char **dest, char ***destv)
d459 1
d502 1
d511 3
a513 2
	char* defaultshell = (IsWinNT() ? "cmd.exe /x/c" : "command.com /c");
	char *usershell = getenv("PERL5SHELL");
d523 1
a531 1
    STRLEN n_a;
d545 1
a545 1
	if (*mark && (str = SvPV(*mark, n_a)))
d553 1
a553 1
			   (const char*)(really ? SvPV(really,n_a) : argv[0]),
d566 1
a566 1
			       (const char*)(really ? SvPV(really,n_a) : argv[0]),
d572 3
a574 2
	    if (PL_dowarn)
		warn("Can't spawn \"%s\": %s", argv[0], strerror(errno));
d588 1
d604 1
a604 1
	    while (*s && isspace(*s))
d608 1
a608 1
	    while (*s && !isspace(*s))
d661 3
a663 2
	    if (PL_dowarn)
		warn("Can't %s \"%s\": %s",
d688 1
a688 1
do_exec(char *cmd)
d698 1
a698 1
DIR *
d701 2
a702 1
    DIR			*p;
d707 2
a708 1
    WIN32_FIND_DATA	FindData;
d710 3
d723 1
a723 3
    Newz(1303, p, 1, DIR);
    if (p == NULL)
	return NULL;
d727 7
a733 1
    if (scanname[len-1] != '/' && scanname[len-1] != '\\')
d735 1
d740 8
a747 1
    fh = FindFirstFile(scanname, &FindData);
d749 1
d751 15
a765 3
	if (GetLastError() == ERROR_FILE_NOT_FOUND)
	    return p;
	Safefree( p);
d772 18
a789 28
    idx = strlen(FindData.cFileName)+1;
    New(1304, p->start, idx, char);
    if (p->start == NULL)
	croak("opendir: malloc failed!\n");
    strcpy(p->start, FindData.cFileName);
    p->nfiles++;

    /* loop finding all the files that match the wildcard
     * (which should be all of them in this directory!).
     * the variable idx should point one past the null terminator
     * of the previous string found.
     */
    while (FindNextFile(fh, &FindData)) {
	len = strlen(FindData.cFileName);
	/* bump the string table size by enough for the
	 * new name and it's null terminator
	 */
	Renew(p->start, idx+len+1, char);
	if (p->start == NULL)
	    croak("opendir: malloc failed!\n");
	strcpy(&p->start[idx], FindData.cFileName);
	p->nfiles++;
	idx += len+1;
    }
    FindClose(fh);
    p->size = idx;
    p->curr = p->start;
    return p;
d796 1
a796 1
struct direct *
d799 1
a799 2
    int         len;
    static int  dummy = 0;
d808 1
a808 1
	dirp->dirstr.d_ino = dummy++;
d810 1
a810 1
	/* Now set up for the nDllExport call to readdir */
d812 40
a851 2
	if (dirp->curr >= (dirp->start + dirp->size)) {
	    dirp->curr = NULL;
a852 1

d860 1
a860 1
long
d863 1
a863 1
    return (long) dirp->curr;
d868 1
a868 1
 *(Saved by telldir).
d870 1
a870 1
void
d873 1
a873 1
    dirp->curr = (char *)loc;
d877 1
a877 1
void
d884 1
a884 1
int
d887 3
d949 3
a951 3
    dTHR;
    char *buf = getlogin_buffer;
    DWORD size = sizeof(getlogin_buffer);
d964 39
d1004 1
a1004 1
remove_dead_process(HANDLE deceased)
d1006 8
a1013 9
#ifndef USE_RTL_WAIT
    int child;
    for (child = 0 ; child < w32_num_children ; ++child) {
	if (w32_child_pids[child] == deceased) {
	    Copy(&w32_child_pids[child+1], &w32_child_pids[child],
		 (w32_num_children-child-1), HANDLE);
	    w32_num_children--;
	    break;
	}
d1015 1
a1016 1
}
d1021 17
a1037 4
#ifdef USE_RTL_WAIT
    HANDLE hProcess= OpenProcess(PROCESS_ALL_ACCESS, TRUE, pid);
#else
    HANDLE hProcess = (HANDLE) pid;
d1039 22
a1060 3

    if (hProcess == NULL) {
	croak("kill process failed!\n");
d1062 2
a1063 10
    else {
	if (!TerminateProcess(hProcess, sig))
	    croak("kill process failed!\n");
	CloseHandle(hProcess);

	/* WaitForMultipleObjects() on a pid that was killed returns error
	 * so if we know the pid is gone we remove it from process list */
	remove_dead_process(hProcess);
    }
    return 0;
d1078 1
a1078 1
win32_stat(const char *path, struct stat *buffer)
d1080 2
a1081 2
    char	t[MAX_PATH+1]; 
    const char	*p = path;
d1084 4
d1091 2
d1094 16
a1109 6
	case '/':
	    if (path[l - 2] != ':') {
		strncpy(t, path, l - 1);
		t[l - 1] = 0;
		p = t;
	    };
d1112 30
a1141 1
    res = stat(p,buffer);
d1145 1
a1145 1
	 * buffer->st_*time (but note that's not available on the
d1147 7
a1153 1
	DWORD r = GetFileAttributes(p);
d1155 3
a1157 1
	    buffer->st_mode |= S_IFDIR | S_IREAD;
d1160 1
a1160 1
		buffer->st_mode |= S_IWRITE | S_IEXEC;
d1165 2
a1166 2
	if (l == 3 && path[l-2] == ':'
	    && (path[l-1] == '\\' || path[l-1] == '/'))
d1169 3
a1171 1
	    if (!GetVolumeInformation(path,NULL,0,NULL,NULL,NULL,NULL,0)) {
d1177 4
a1180 3
	if (S_ISDIR(buffer->st_mode))
	    buffer->st_mode |= S_IWRITE | S_IEXEC;
	else if (S_ISREG(buffer->st_mode)) {
d1187 1
a1187 1
		    buffer->st_mode &= ~S_IEXEC;
d1189 1
a1189 1
		    buffer->st_mode |= S_IEXEC;
d1192 4
a1195 1
		buffer->st_mode &= ~S_IEXEC;
d1202 77
d1284 2
a1285 2
    static char *curitem = Nullch;	/* XXX threadead */
    static DWORD curlen = 0;		/* XXX threadead */
d1287 5
a1291 3
    if (!curitem) {
	curlen = 512;
	New(1305,curitem,curlen,char);
d1293 2
a1294 2

    needlen = GetEnvironmentVariable(name,curitem,curlen);
d1296 20
a1315 4
	while (needlen > curlen) {
	    Renew(curitem,needlen,char);
	    curlen = needlen;
	    needlen = GetEnvironmentVariable(name,curitem,curlen);
d1321 2
a1322 11
	if (curitem)
	    *curitem = '\0';

	if (strncmp(name, "PERL", 4) == 0) {
	    if (curitem) {
		Safefree(curitem);
		curitem = Nullch;
		curlen = 0;
	    }
	    curitem = GetRegStr(name, &curitem, &curlen);
	}
d1324 2
a1325 2
    if (curitem && *curitem == '\0')
	return Nullch;
d1327 1
a1327 1
    return curitem;
d1333 1
d1336 41
a1376 23
    int relval = -1;
    if(name) {
	New(1309,curitem,strlen(name)+1,char);
	strcpy(curitem, name);
	val = strchr(curitem, '=');
	if(val) {
	    /* The sane way to deal with the environment.
	     * Has these advantages over putenv() & co.:
	     *  * enables us to store a truly empty value in the
	     *    environment (like in UNIX).
	     *  * we don't have to deal with RTL globals, bugs and leaks.
	     *  * Much faster.
	     * Why you may want to enable USE_WIN32_RTL_ENV:
	     *  * environ[] and RTL functions will not reflect changes,
	     *    which might be an issue if extensions want to access
	     *    the env. via RTL.  This cuts both ways, since RTL will
	     *    not see changes made by extensions that call the Win32
	     *    functions directly, either.
	     * GSAR 97-06-07
	     */
	    *val++ = '\0';
	    if(SetEnvironmentVariable(curitem, *val ? val : NULL))
		relval = 0;
a1377 1
	Safefree(curitem);
d1387 5
a1391 5
 __int64 qw = ft->dwHighDateTime;
 qw <<= 32;
 qw |= ft->dwLowDateTime;
 qw /= 10000;  /* File time ticks at 0.1uS, clock at 1mS */
 return (long) qw;
d1418 1
a1418 3
/* fix utime() so it works on directories in NT
 * thanks to Jan Dubois <jan.dubois@@ibm.net>
 */
d1422 1
a1422 1
    struct tm *pTM = gmtime(&Time);
d1424 1
d1437 47
a1483 1
    return SystemTimeToFileTime(&SystemTime, pFileTime);
d1489 1
d1495 2
d1498 10
a1507 1
    int rc = utime(filename,times);
d1519 10
a1528 3
    handle = CreateFile(filename, GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
			OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
d1545 90
d1637 23
a1659 3
    int rc;
    if (pid == -1) 
      return win32_wait(status);
d1661 18
a1678 2
      rc = cwait(status, pid, WAIT_CHILD);
    /* cwait() returns "correctly" on Borland */
d1680 2
a1681 2
    if (status)
	*status *= 256;
d1683 1
a1683 1
      remove_dead_process((HANDLE)pid);
d1685 1
a1685 1
    return rc >= 0 ? pid : rc;                
a1690 3
#ifdef USE_RTL_WAIT
    return wait(status);
#else
d1694 1
d1698 22
d1727 1
a1727 1
				      w32_child_pids,
d1736 1
a1736 2
	if (GetExitCodeProcess(w32_child_pids[i], &exitcode) ) {
	    CloseHandle(w32_child_pids[i]);
d1739 1
a1739 3
	    Copy(&w32_child_pids[i+1], &w32_child_pids[i],
		 (w32_num_children-i-1), HANDLE);
	    w32_num_children--;
d1747 1
d1749 1
a1749 2
#endif
}
d1755 4
a1758 3
 KillTimer(NULL,timerid);
 timerid=0;  
 sighandler(14);
d1760 1
d1765 1
d1775 1
d1780 1
a1780 1
       croak("Cannot set timer");
d1790 1
a1793 1
#if defined(HAVE_DES_FCRYPT) || defined(PERL_OBJECT)
d1801 1
d1804 1
a1804 1
    return des_fcrypt(txt, salt, crypt_buffer);
d1806 1
a1806 1
    die("The crypt() function is unimplemented due to excessive paranoia.");
a1809 1
#endif
d1811 3
a1813 1
#ifdef USE_FIXED_OSFHANDLE
d1815 3
a1817 5
EXTERN_C int __cdecl _alloc_osfhnd(void);
EXTERN_C int __cdecl _set_osfhnd(int fh, long value);
EXTERN_C void __cdecl _lock_fhandle(int);
EXTERN_C void __cdecl _unlock_fhandle(int);
EXTERN_C void __cdecl _unlock(int);
d1819 4
a1822 2
#if	(_MSC_VER >= 1000)
typedef struct	{
a1825 1
#if defined (_MT) && !defined (DLL_FOR_WIN32S)
d1828 7
a1834 2
#endif  /* defined (_MT) && !defined (DLL_FOR_WIN32S) */
}	ioinfo;
d1836 5
a1840 1
EXTERN_C ioinfo * __pioinfo[];
d1842 17
a1858 8
#define IOINFO_L2E			5
#define IOINFO_ARRAY_ELTS	(1 << IOINFO_L2E)
#define _pioinfo(i)	(__pioinfo[i >> IOINFO_L2E] + (i & (IOINFO_ARRAY_ELTS - 1)))
#define _osfile(i)	(_pioinfo(i)->osfile)

#else	/* (_MSC_VER >= 1000) */
extern char _osfile[];
#endif	/* (_MSC_VER >= 1000) */
d1861 1
a1865 4
#define _STREAM_LOCKS   26		/* Table of stream locks */
#define _LAST_STREAM_LOCK  (_STREAM_LOCKS+_NSTREAM_-1)	/* Last stream lock */
#define _FH_LOCKS          (_LAST_STREAM_LOCK+1)	/* Table of fh locks */

d1872 4
a1875 2
*		temperary fix for WIN95's brain damage GetFileType() error on socket
*		we just bypass that call for socket
d1889 25
d1929 3
a1943 1
#if (_MSC_VER >= 1000)
d1945 1
a1945 5
    _unlock_fhandle(fh);
#else
    _osfile[fh] = fileflags;	/* set osfile entry */
    _unlock(fh+_FH_LOCKS);		/* unlock handle */
#endif
a1949 1
#define _open_osfhandle my_open_osfhandle
d1965 2
a1966 1
	croak("flock() unimplemented on this platform");
d2064 1
a2064 1
        dTHR;
d2069 3
a2071 2
			 strerror_buffer, sizeof(strerror_buffer), NULL) == 0) 
	    strcpy(strerror_buffer, "Unknown Error");
d2073 1
a2073 1
	return strerror_buffer;
d2087 1
d2089 3
a2091 2
	while (0 < dwLen  &&  isspace(sMsg[--dwLen]))
	    ;
d2094 1
a2094 1
	sMsg[dwLen]= '\0';
d2098 9
a2106 3
	dwLen = sprintf(sMsg,
			"Unknown error #0x%lX (lookup 0x%lX)",
			dwErr, GetLastError());
a2107 2
    sv_setpvn((SV*)sv, sMsg, dwLen);
    LocalFree(sMsg);
d2153 2
d2158 7
d2166 13
a2178 2
	return fopen("NUL", mode);
    return fopen(filename, mode);
d2187 1
a2187 1
win32_fdopen( int handle, const char *mode)
d2189 13
a2201 1
    return fdopen(handle, (char *) mode);
d2205 1
a2205 1
win32_freopen( const char *path, const char *mode, FILE *stream)
d2207 2
d2210 8
a2217 2
	return freopen("NUL", mode, stream);
    return freopen(path, mode, stream);
d2382 8
a2389 2
    if ((childpid = do_spawn_nowait((char*)command)) == -1)
        goto cleanup;
d2391 2
a2392 3
    /* revert stdfd to whatever it was before */
    if (win32_dup2(oldfd, stdfd) == -1)
        goto cleanup;
d2394 1
a2394 2
    /* close saved handle */
    win32_close(oldfd);
d2396 3
a2398 1
    sv_setiv(*av_fetch(w32_fdpid, p[parent], TRUE), childpid);
d2426 1
a2426 1

d2444 35
a2478 1
    remove_dead_process((HANDLE)childpid);
d2480 15
a2494 6
    /* wait for the child */
    if (cwait(&status, childpid, WAIT_CHILD) == -1)
        return (-1);
    /* cwait() returns "correctly" on Borland */
#ifndef __BORLANDC__
    status *= 256;
a2495 1
    return (status);
d2497 38
a2534 1
#endif /* USE_RTL_POPEN */
d2540 7
d2551 16
a2566 2
	if (!MoveFileEx(oname,newname,
			MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING)) {
d2589 1
a2589 1
	char tmpname[MAX_PATH+1];
d2595 3
d2599 1
a2599 1
	from_attr = GetFileAttributes(oname);
d2609 1
a2609 1
	to_attr = GetFileAttributes(newname);
d2617 4
a2620 4
	    tmplen = strlen(newname);
	    strcpy(tmpname,newname);
	    endname = tmpname+tmplen;
	    for (; endname > tmpname ; --endname) {
d2626 2
a2627 2
	    if (endname > tmpname)
		endname = strcpy(dname,tmpname);
d2633 1
a2633 1
	    if (!GetTempFileName((LPCTSTR)endname, "plr", 0, tmpname)) {
d2637 1
a2637 1
	    DeleteFile(tmpname);
d2639 1
a2639 1
	    retval = rename(newname, tmpname);
d2647 1
a2647 1
	retval = rename(oname, newname);
d2653 1
a2653 1
		DeleteFile(tmpname);
d2656 1
a2656 1
		(void)rename(tmpname, newname);
d2683 1
d2686 1
d2693 7
a2699 2
	return open("NUL", flag, pmode);
    return open(path,flag,pmode);
d2726 196
d2925 3
d2929 1
d2941 7
a2947 1
    return mkdir(dir); /* just ignore mode */
d2953 7
a2959 1
    return rmdir(dir);
d2965 6
d2974 193
d3170 59
a3228 1
    int status;
d3230 53
a3282 3
#ifndef USE_RTL_WAIT
    if (mode == P_NOWAIT && w32_num_children >= MAXIMUM_WAIT_OBJECTS)
	return -1;
a3283 11

    status = spawnvp(mode, cmdname, (char * const *) argv);
#ifndef USE_RTL_WAIT
    /* XXX For the P_NOWAIT case, Borland RTL returns pinfo.dwProcessId
     * while VC RTL returns pinfo.hProcess. For purposes of the custom
     * implementation of win32_wait(), we assume the latter.
     */
    if (mode == P_NOWAIT && status >= 0)
	w32_child_pids[w32_num_children++] = (HANDLE)status;
#endif
    return status;
d3289 7
d3302 7
d3491 4
d3504 16
d3528 2
a3529 6
    SV *sv = sv_newmortal();
    /* Make one call with zero size - return value is required size */
    DWORD len = GetCurrentDirectory((DWORD)0,NULL);
    SvUPGRADE(sv,SVt_PV);
    SvGROW(sv,len);
    SvCUR(sv) = GetCurrentDirectory((DWORD) SvLEN(sv), SvPVX(sv));
d3531 1
a3531 1
     * If result != 0 
d3533 1
a3533 1
     *   else leave it 'undef' 
d3535 6
a3540 1
    if (SvCUR(sv))
d3542 4
a3545 3
    EXTEND(SP,1);
    ST(0) = sv;
    XSRETURN(1);
a3551 1
    STRLEN n_a;
d3553 2
a3554 2
	croak("usage: Win32::SetCurrentDirectory($cwd)");
    if (SetCurrentDirectory(SvPV(ST(0),n_a)))
d3566 2
d3582 1
d3587 10
d3600 3
a3602 2
    char *name = getlogin_buffer;
    DWORD size = sizeof(getlogin_buffer);
d3605 1
a3605 1
	ST(0) = sv_2mortal(newSVpv(name,size-1));
d3617 1
d3620 1
a3620 1
	ST(0) = sv_2mortal(newSVpv(name,size));
d3631 14
a3644 7
#ifndef HAS_NETWKSTAGETINFO
    /* mingw32 (and Win95) don't have NetWksta*(), so do it the old way */
    char name[256];
    DWORD size = sizeof(name);
    if (GetUserName(name,&size)) {
	char sid[1024];
	DWORD sidlen = sizeof(sid);
d3647 20
a3666 4
	SID_NAME_USE snu;
	if (LookupAccountName(NULL, name, (PSID)&sid, &sidlen,
			      dname, &dnamelen, &snu)) {
	    XSRETURN_PV(dname);		/* all that for this */
d3668 1
d3670 16
a3685 11
#else
    /* this way is more reliable, in case user has a local account.
     * XXX need dynamic binding of netapi32.dll symbols or this will fail on
     * Win95. Probably makes more sense to move it into libwin32. */
    char dname[256];
    DWORD dnamelen = sizeof(dname);
    PWKSTA_INFO_100 pwi;
    if (NERR_Success == NetWkstaGetInfo(NULL, 100, (LPBYTE*)&pwi)) {
	if (pwi->wki100_langroup && *(pwi->wki100_langroup)) {
	    WideCharToMultiByte(CP_ACP, NULL, pwi->wki100_langroup,
				-1, (LPSTR)dname, dnamelen, NULL, NULL);
a3686 6
	else {
	    WideCharToMultiByte(CP_ACP, NULL, pwi->wki100_computername,
				-1, (LPSTR)dname, dnamelen, NULL, NULL);
	}
	NetApiBufferFree(pwi);
	XSRETURN_PV(dname);
a3687 1
#endif
d3699 2
a3700 2
	if (GIMME == G_ARRAY) {
	    XPUSHs(sv_2mortal(newSVpv(fsname,0)));
d3706 1
d3709 1
a3709 1
    XSRETURN_UNDEF;
d3716 1
a3716 1
    OSVERSIONINFO osver;
d3718 13
a3730 9
    osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osver)) {
	XPUSHs(newSVpv(osver.szCSDVersion, 0));
	XPUSHs(newSViv(osver.dwMajorVersion));
	XPUSHs(newSViv(osver.dwMinorVersion));
	XPUSHs(newSViv(osver.dwBuildNumber));
	XPUSHs(newSViv(osver.dwPlatformId));
	PUTBACK;
	return;
d3732 12
a3743 1
    XSRETURN_UNDEF;
d3750 1
d3758 1
d3767 1
a3767 1
    char msgbuf[1024];
d3770 1
a3770 1
	croak("usage: Win32::FormatMessage($errno)");
d3772 16
a3787 4
    if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
		      &source, SvIV(ST(0)), 0,
		      msgbuf, sizeof(msgbuf)-1, NULL))
	XSRETURN_PV(msgbuf);
a3799 1
    STRLEN n_a;
d3802 1
a3802 1
	croak("usage: Win32::Spawn($cmdName, $args, $PID)");
d3804 2
a3805 2
    cmd = SvPV(ST(0),n_a);
    args = SvPV(ST(1), n_a);
d3835 5
a3839 1
    XSRETURN_IV(GetTickCount());
d3850 1
a3850 1
	croak("usage: Win32::GetShortPathName($longPathName)");
d3863 59
d3923 1
a3923 3
    else
	ST(0) = &PL_sv_undef;
    XSRETURN(1);
d3931 1
a3931 1
	croak("usage: Win32::Sleep($milliseconds)");
d3936 26
d3963 1
a3963 1
Perl_init_os_extras()
d3965 1
d3972 1
a3972 1
#ifndef USE_RTL_WAIT
d3974 5
d3986 1
d3998 3
d4030 46
a4075 1
#ifdef USE_BINMODE_SCRIPTS
d4078 1
a4078 1
win32_strip_return(SV *sv)
d4080 12
a4091 9
 char *s = SvPVX(sv);
 char *e = s+SvCUR(sv);
 char *d = s;
 while (s < e)
  {
   if (*s == '\r' && s[1] == '\n')
    {
     *d++ = '\n';
     s += 2;
d4093 1
a4093 6
   else 
    {
     *d++ = *s++;
    }   
  }
 SvCUR_set(sv,d-SvPVX(sv)); 
a4095 1
#endif
@


1.1
log
@perl 5.004_04
@
text
@d14 3
d19 12
d40 7
d48 2
d52 2
d55 1
d59 6
d66 6
a71 2
#define CROAK croak
#define WARN warn
d77 14
a90 1
static DWORD IdOS(void);
d92 9
a100 2
extern WIN32_IOSUBSYSTEM	win32stdio;
static PWIN32_IOSUBSYSTEM pIOSubSystem = &win32stdio;
d102 2
a103 5
BOOL  ProbeEnv = FALSE;
DWORD Win32System = (DWORD)-1;
char  szShellPath[MAX_PATH+1];
char  szPerlLibRoot[MAX_PATH+1];
HANDLE PerlDllHandle = INVALID_HANDLE_VALUE;
d105 22
a126 1
static int do_spawn2(char *cmd, int exectype);
d130 1
a130 1
    return (IdOS() == VER_PLATFORM_WIN32_WINDOWS);
d135 1
a135 1
    return (IdOS() == VER_PLATFORM_WIN32_NT);
d138 23
a160 9
DllExport PWIN32_IOSUBSYSTEM
SetIOSubSystem(void *p)
{
    PWIN32_IOSUBSYSTEM old = pIOSubSystem;
    if (p) {
	PWIN32_IOSUBSYSTEM pio = (PWIN32_IOSUBSYSTEM)p;
	if (pio->signature_begin == 12345678L
	    && pio->signature_end == 87654321L) {
	    pIOSubSystem = pio;
d162 1
d164 10
a173 2
    else {
	pIOSubSystem = &win32stdio;
d175 1
a175 1
    return old;
d178 2
a179 2
DllExport PWIN32_IOSUBSYSTEM
GetIOSubSystem(void)
d181 57
a237 1
    return pIOSubSystem;
d241 1
a241 1
win32PerlLibPath(void)
d243 13
a255 12
    char *end;
    GetModuleFileName((PerlDllHandle == INVALID_HANDLE_VALUE) 
		      ? GetModuleHandle(NULL)
		      : PerlDllHandle,
		      szPerlLibRoot, 
		      sizeof(szPerlLibRoot));

    *(end = strrchr(szPerlLibRoot, '\\')) = '\0';
    if (stricmp(end-4,"\\bin") == 0)
     end -= 4;
    strcpy(end,"\\lib");
    return (szPerlLibRoot);
d259 1
a259 1
win32SiteLibPath(void)
d261 39
a299 4
    static char szPerlSiteLib[MAX_PATH+1];
    strcpy(szPerlSiteLib, win32PerlLibPath());
    strcat(szPerlSiteLib, "\\site");
    return (szPerlSiteLib);
d302 3
a304 2
BOOL
HasRedirection(char *ptr)
d311 2
a312 1
     * characters (|) that are not in a quoted string
d314 1
a314 1
    while(*ptr) {
d316 2
d320 2
a321 2
	    if(inquote) {
		if(quote == *ptr) {
d334 1
a334 1
	    if(!inquote)
d344 1
a365 5

#if 1
/* was #ifndef PERLDLL, but the #else stuff doesn't work on NT
 * GSAR 97/03/13
 */
a366 1
#ifdef __BORLANDC__ /* workaround a Borland stdio bug */
a368 1
#endif
a369 139
#else
/*
 * There seems to be some problems for the _popen call in a DLL
 * this trick at the moment seems to work but it is never test
 * on NT yet
 *
 */ 
#	ifdef __cplusplus
#define EXT_C_FUNC	extern "C"
#	else
#define EXT_C_FUNC	extern
#	endif

    EXT_C_FUNC int __cdecl _set_osfhnd(int fh, long value);
    EXT_C_FUNC void __cdecl _lock_fhandle(int);
    EXT_C_FUNC void __cdecl _unlock_fhandle(int);

    BOOL	fSuccess;
    PerlIO	*pf;		/* to store the _popen return value */
    int		tm = 0;		/* flag indicating tDllExport or binary mode */
    int		fhNeeded, fhInherited, fhDup;
    int		ineeded, iinherited;
    DWORD	dwDup;
    int		phdls[2];	/* I/O handles for pipe */
    HANDLE	hPIn, hPOut, hPErr,
		hSaveStdin, hSaveStdout, hSaveStderr,
		hPNeeded, hPInherited, hPDuped;
     
    /* first check for errors in the arguments */
    if ( (cmd == NULL) || (mode == NULL)
	 || ((*mode != 'w') && (*mode != _T('r'))) )
	goto error1;

    if ( *(mode + 1) == _T('t') )
	tm = O_TEXT;
    else if ( *(mode + 1) == _T('b') )
	tm = O_BINARY;
    else
	tm = (*mode == 'w' ? O_BINARY : O_TEXT);


    fixcmd(cmd);
    if (&win32stdio != pIOSubSystem)
	return win32_popen(cmd, mode);

#ifdef EFG
    if ( _pipe( phdls, 1024, tm ) == -1 )
#else
    if ( win32_pipe( phdls, 1024, tm ) == -1 )
#endif
	goto error1;

    /* save the current situation */
    hSaveStdin = GetStdHandle(STD_INPUT_HANDLE); 
    hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE); 
    hSaveStderr = GetStdHandle(STD_ERROR_HANDLE); 

    if (*mode == _T('w')) {
	ineeded = 1;
	dwDup	= STD_INPUT_HANDLE;
	iinherited = 0;
    }
    else {
	ineeded = 0;
	dwDup	= STD_OUTPUT_HANDLE;
	iinherited = 1;
    }

    fhNeeded = phdls[ineeded];
    fhInherited = phdls[iinherited];

    fSuccess = DuplicateHandle(GetCurrentProcess(), 
			       (HANDLE) stolen_get_osfhandle(fhNeeded), 
			       GetCurrentProcess(), 
			       &hPNeeded, 
			       0, 
			       FALSE,       /* not inherited */ 
			       DUPLICATE_SAME_ACCESS); 

    if (!fSuccess)
	goto error2;

    fhDup = stolen_open_osfhandle((long) hPNeeded, tm);
    win32_dup2(fhDup, fhNeeded);
    win32_close(fhDup);

#ifdef AAA
    /* Close the Out pipe, child won't need it */
    hPDuped = (HANDLE) stolen_get_osfhandle(fhNeeded);

    _lock_fhandle(fhNeeded);
    _set_osfhnd(fhNeeded, (long)hPNeeded); /* put in ours duplicated one */
    _unlock_fhandle(fhNeeded);

    CloseHandle(hPDuped);	/* close the handle first */
#endif

    if (!SetStdHandle(dwDup, (HANDLE) stolen_get_osfhandle(fhInherited)))
	goto error2;

    /*
     * make sure the child see the same stderr as the calling program
     */
    if (!SetStdHandle(STD_ERROR_HANDLE,
		      (HANDLE)stolen_get_osfhandle(win32_fileno(win32_stderr()))))
	goto error2;

    pf = win32_popen(cmd, mode);	/* ask _popen to do the job */

    /* restore to where we were */
    SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);
    SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout);
    SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);

    /* we don't need it any more, that's for the child */
    win32_close(fhInherited);

    if (NULL == pf) {
	/* something wrong */
	win32_close(fhNeeded);
	goto error1;
    }
    else {
	/*
	 * here we steal the file handle in pf and stuff ours in
	 */
	win32_dup2(fhNeeded, win32_fileno(pf));
	win32_close(fhNeeded);
    }
    return (pf);

error2:
    win32_close(fhNeeded);
    win32_close(fhInherited);

error1:
    return (NULL);

#endif
d377 1
d380 1
a380 1
IdOS(void)
d384 1
a384 1
    if (osver.dwPlatformId != Win32System) {
d388 1
a388 1
	Win32System = osver.dwPlatformId;
d390 1
a390 1
    return (Win32System);
d393 54
a446 2
static char *
GetShell(void)
d448 1
a448 2
    if (!ProbeEnv) {
	char* defaultshell = (IsWinNT() ? "cmd.exe" : "command.com");
d456 5
a460 4
	char *usershell = getenv("PERL5SHELL");  

	ProbeEnv = TRUE;
	strcpy(szShellPath, usershell ? usershell : defaultshell);
a461 1
    return szShellPath;
d465 1
a465 1
do_aspawn(void* really, void** mark, void** arglast)
d467 3
d471 1
a471 2
    char *strPtr;
    char *cmd;
d473 1
a473 1
    unsigned int length;
d475 4
a478 2
    SV *sv = (SV*)really;
    SV** pSv = (SV**)mark;
d480 2
a481 1
    New(1310, argv, (arglast - mark) + 4, char*);
d483 3
a485 8
    if(sv != Nullsv) {
	cmd = SvPV(sv, length);
    }
    else {
	argv[index++] = cmd = GetShell();
	if (IsWinNT())
	    argv[index++] = "/x";   /* always enable command extensions */
	argv[index++] = "/c";
d488 5
a492 5
    while(++pSv <= (SV**)arglast) {
	sv = *pSv;
	strPtr = SvPV(sv, length);
	if(strPtr != NULL && *strPtr != '\0')
	    argv[index++] = strPtr;
d496 17
a512 1
    status = win32_spawnvp(P_WAIT, cmd, (const char* const*)argv);
d514 10
a524 6

    if (status < 0) {
	if (dowarn)
	    warn("Can't spawn \"%s\": %s", cmd, strerror(errno));
	status = 255 << 8;
    }
d536 1
a536 4
    char *shell, *cmd2;

    /* save an extra exec if possible */
    shell = GetShell();
d538 3
a540 2
    /* see if there are shell metacharacters in it */
    if(!HasRedirection(cmd)) {
d550 1
a550 1
	    while(*s && !isspace(*s))
d552 1
a552 1
	    if(*s)
d556 1
a556 1
	if(argv[0]) {
d570 1
a570 1
	    if(status != -1 || errno == 0)
d576 9
a584 7
    if(needToTry) {
	char *argv[5];
	int i = 0;
	argv[i++] = shell;
	if (IsWinNT())
	    argv[i++] = "/x";
	argv[i++] = "/c"; argv[i++] = cmd; argv[i] = Nullch;
d598 2
d601 11
a611 7
    if (status < 0) {
	if (dowarn)
	    warn("Can't %s \"%s\": %s",
		 (exectype == EXECF_EXEC ? "exec" : "spawn"),
		 needToTry ? shell : argv[0],
		 strerror(errno));
	status = 255 << 8;
d622 6
a634 3

#define PATHLEN 1024

d640 1
a640 1
opendir(char *filename)
d642 11
a652 13
    DIR            *p;
    long            len;
    long            idx;
    char            scannamespc[PATHLEN];
    char       *scanname = scannamespc;
    struct stat     sbuf;
    WIN32_FIND_DATA FindData;
    HANDLE          fh;
/*  char            root[_MAX_PATH];*/
/*  char            volname[_MAX_PATH];*/
/*  DWORD           serial, maxname, flags;*/
/*  BOOL            downcase;*/
/*  char           *dummy;*/
d655 1
a655 1
    if (win32_stat(filename, &sbuf) < 0 || sbuf.st_mode & S_IFDIR == 0) {
a656 1
    }
a657 13
    /* get the file system characteristics */
/*  if(GetFullPathName(filename, MAX_PATH, root, &dummy)) {
 *	if(dummy = strchr(root, '\\'))
 *	    *++dummy = '\0';
 *	if(GetVolumeInformation(root, volname, MAX_PATH, &serial,
 *				&maxname, &flags, 0, 0)) {
 *	    downcase = !(flags & FS_CASE_IS_PRESERVED);
 *	}
 *  }
 *  else {
 *	downcase = TRUE;
 *  }
 */
d660 1
a660 1
    if(p == NULL)
d665 4
a668 5

    if(index("/\\", *(scanname + strlen(scanname) - 1)) == NULL)
	strcat(scanname, "/*");
    else
	strcat(scanname, "*");
d672 5
a676 1
    if(fh == INVALID_HANDLE_VALUE) {
d685 2
a686 3
    if(p->start == NULL) {
	CROAK("opendir: malloc failed!\n");
    }
a687 3
/*  if(downcase)
 *	strlwr(p->start);
 */
d701 2
a702 3
	if(p->start == NULL) {
	    CROAK("opendir: malloc failed!\n");
	}
d704 7
a710 10
/*	if (downcase) 
 *	    strlwr(&p->start[idx]);
 */
		p->nfiles++;
		idx += len+1;
	}
	FindClose(fh);
	p->size = idx;
	p->curr = p->start;
	return p;
d718 1
a718 1
readdir(DIR *dirp)
d746 1
a746 1
telldir(DIR *dirp)
d756 1
a756 1
seekdir(DIR *dirp, long loc)
d763 1
a763 1
rewinddir(DIR *dirp)
d770 1
a770 1
closedir(DIR *dirp)
d817 1
a817 1
setuid(uid_t uid)
d819 1
a819 1
    return (uid == ROOT_UID ? 0 : -1);
d823 1
a823 1
setgid(gid_t gid)
d825 12
a836 1
    return (gid == ROOT_GID ? 0 : -1);
a838 3
/*
 * pretended kill
 */
d840 1
a840 1
kill(int pid, int sig)
d842 24
d867 3
d872 1
a872 1
	CROAK("kill process failed!\n");
d876 1
a876 1
	    CROAK("kill process failed!\n");
d878 4
d885 1
a885 1
      
d890 2
a891 11
#if 0
int
ioctl(int i, unsigned int u, char *data)
{
    CROAK("ioctl not implemented!\n");
    return -1;
}
#endif

unsigned int
sleep(unsigned int t)
a896 13

#undef rename

int
myrename(char *OldFileName, char *newname)
{
    if(_access(newname, 0) != -1) {	/* file exists */
	_unlink(newname);
    }
    return rename(OldFileName, newname);
}


d900 1
a900 1
    char		t[MAX_PATH]; 
d916 25
a940 1
    res = pIOSubSystem->pfnstat(p,buffer);
a941 1
    if (res == 0) {
d958 1
a959 1
#endif
d968 2
a969 2
    static char *curitem = Nullch;
    static DWORD curlen = 512;
d971 2
a972 1
    if (!curitem)
d974 26
a999 1
    if (!(needlen = GetEnvironmentVariable(name,curitem,curlen)))
d1001 34
a1034 4
    while (needlen > curlen) {
	Renew(curitem,needlen,char);
	curlen = needlen;
	needlen = GetEnvironmentVariable(name,curitem,curlen);
d1036 1
a1036 1
    return curitem;
d1041 2
a1042 3
#undef times
int
mytimes(struct tms *timebuf)
d1044 6
a1049 5
    clock_t	t = clock();
    timebuf->tms_utime = t;
    timebuf->tms_stime = 0;
    timebuf->tms_cutime = 0;
    timebuf->tms_cstime = 0;
d1051 21
d1075 161
a1235 7
#undef alarm
unsigned int
myalarm(unsigned int sec)
{
    /* we warn the usuage of alarm function */
    if (sec != 0)
	WARN("dummy function alarm called, program might not function as expected\n");
d1239 166
d1413 1
a1413 1
    return (pIOSubSystem->pfnerrno());
d1419 1
a1419 1
    return (pIOSubSystem->pfnenviron());
d1426 1
a1426 1
    return (pIOSubSystem->pfnstderr());
d1432 1
a1432 1
    return (pIOSubSystem->pfnstdin());
d1438 1
a1438 1
    return (pIOSubSystem->pfnstdout());
d1444 1
a1444 1
    return (pIOSubSystem->pfnferror(fp));
d1451 1
a1451 1
    return (pIOSubSystem->pfnfeof(fp));
a1459 2
__declspec(thread) char	strerror_buffer[512];

d1468 3
a1470 2
    if(e < 0 || e > sys_nerr) {
	if(e < 0)
d1473 1
a1473 1
	if(FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, &source, e, 0,
d1479 1
a1479 1
    return pIOSubSystem->pfnstrerror(e);
d1482 27
d1515 1
a1515 1
    return (pIOSubSystem->pfnvfprintf(fp, format, marker));
d1524 1
a1524 1
    return (pIOSubSystem->pfnvprintf(format, marker));
d1530 1
a1530 1
    return (pIOSubSystem->pfnvfprintf(fp, format, args));
d1536 1
a1536 1
    return (pIOSubSystem->pfnvprintf(format, args));
d1542 1
a1542 1
    return pIOSubSystem->pfnfread(buf, size, count, fp);
d1548 1
a1548 1
    return pIOSubSystem->pfnfwrite(buf, size, count, fp);
d1555 2
a1556 2
	return pIOSubSystem->pfnfopen("NUL", mode);
    return pIOSubSystem->pfnfopen(filename, mode);
d1559 5
d1567 1
a1567 1
    return pIOSubSystem->pfnfdopen(handle, mode);
d1574 2
a1575 2
	return pIOSubSystem->pfnfreopen("NUL", mode, stream);
    return pIOSubSystem->pfnfreopen(path, mode, stream);
d1581 1
a1581 1
    return pIOSubSystem->pfnfclose(pf);
d1587 1
a1587 1
    return pIOSubSystem->pfnfputs(s, pf);
d1593 1
a1593 1
    return pIOSubSystem->pfnfputc(c,pf);
d1599 1
a1599 1
    return pIOSubSystem->pfnungetc(c,pf);
d1605 1
a1605 1
    return pIOSubSystem->pfngetc(pf);
d1611 1
a1611 1
    return pIOSubSystem->pfnfileno(pf);
d1617 1
a1617 1
    pIOSubSystem->pfnclearerr(pf);
d1624 1
a1624 1
    return pIOSubSystem->pfnfflush(pf);
d1630 1
a1630 1
    return pIOSubSystem->pfnftell(pf);
d1636 1
a1636 1
    return pIOSubSystem->pfnfseek(pf, offset, origin);
d1642 1
a1642 1
    return pIOSubSystem->pfnfgetpos(pf, p);
d1648 1
a1648 1
    return pIOSubSystem->pfnfsetpos(pf, p);
d1654 1
a1654 1
    pIOSubSystem->pfnrewind(pf);
d1661 1
a1661 1
    return pIOSubSystem->pfntmpfile();
d1667 1
a1667 1
    pIOSubSystem->pfnabort();
d1672 1
a1672 1
win32_fstat(int fd,struct stat *bufptr)
d1674 1
a1674 1
    return pIOSubSystem->pfnfstat(fd,bufptr);
d1680 1
a1680 1
    return pIOSubSystem->pfnpipe(pfd, size, mode);
d1683 4
d1690 76
a1765 1
    return pIOSubSystem->pfnpopen(command, mode);
d1768 4
d1775 134
a1908 1
    return pIOSubSystem->pfnpclose(pf);
d1914 1
a1914 1
    return pIOSubSystem->pfnsetmode(fd, mode);
d1920 1
a1920 1
    return pIOSubSystem->pfnlseek(fd, offset, origin);
d1926 1
a1926 1
    return pIOSubSystem->pfntell(fd);
d1940 2
a1941 2
	return pIOSubSystem->pfnopen("NUL", flag, pmode);
    return pIOSubSystem->pfnopen(path,flag,pmode);
d1947 1
a1947 1
    return pIOSubSystem->pfnclose(fd);
d1953 1
a1953 1
    return pIOSubSystem->pfneof(fd);
d1959 1
a1959 1
    return pIOSubSystem->pfndup(fd);
d1965 1
a1965 1
    return pIOSubSystem->pfndup2(fd1,fd2);
d1971 1
a1971 1
    return pIOSubSystem->pfnread(fd, buf, cnt);
d1977 1
a1977 1
    return pIOSubSystem->pfnwrite(fd, buf, cnt);
d1983 1
a1983 1
    return pIOSubSystem->pfnmkdir(dir); /* just ignore mode */
d1989 1
a1989 1
    return pIOSubSystem->pfnrmdir(dir);
d1995 1
a1995 1
    return pIOSubSystem->pfnchdir(dir);
d2001 23
a2023 1
    return pIOSubSystem->pfnspawnvp(mode, cmdname, argv);
d2029 1
a2029 1
    return pIOSubSystem->pfnexecvp(cmdname, argv);
d2035 1
a2035 1
    pIOSubSystem->pfnperror(str);
d2041 1
a2041 1
    pIOSubSystem->pfnsetbuf(pf, buf);
d2047 1
a2047 1
    return pIOSubSystem->pfnsetvbuf(pf, buf, type, size);
d2053 1
a2053 1
    return pIOSubSystem->pfnflushall();
d2059 1
a2059 1
    return pIOSubSystem->pfnfcloseall();
d2065 1
a2065 1
    return pIOSubSystem->pfnfgets(s, n, pf);
d2071 1
a2071 1
    return pIOSubSystem->pfngets(s);
d2077 1
a2077 1
    return pIOSubSystem->pfnfgetc(pf);
d2083 1
a2083 1
    return pIOSubSystem->pfnputc(c,pf);
d2089 1
a2089 1
    return pIOSubSystem->pfnputs(s);
d2095 1
a2095 1
    return pIOSubSystem->pfngetchar();
d2101 1
a2101 1
    return pIOSubSystem->pfnputchar(c);
d2104 79
d2186 1
a2186 1
    return pIOSubSystem->pfnmalloc(size);
d2192 1
a2192 1
    return pIOSubSystem->pfncalloc(numitems,size);
d2198 1
a2198 1
    return pIOSubSystem->pfnrealloc(block,size);
d2204 1
a2204 1
    pIOSubSystem->pfnfree(block);
d2207 1
d2209 1
a2209 1
stolen_open_osfhandle(long handle, int flags)
d2211 1
a2211 1
    return pIOSubSystem->pfn_open_osfhandle(handle, flags);
d2215 1
a2215 1
stolen_get_osfhandle(int fd)
d2217 1
a2217 1
    return pIOSubSystem->pfn_get_osfhandle(fd);
a2223 10
DllExport int
win32_flock(int fd, int oper)
{
    if (!IsWinNT()) {
	croak("flock() unimplemented on this platform");
	return -1;
    }
    return pIOSubSystem->pfnflock(fd, oper);
}

d2241 1
a2241 1
    EXTEND(sp,1);
d2250 1
d2253 1
a2253 1
    if (SetCurrentDirectory(SvPV(ST(0),na)))
d2286 2
a2287 2
    char name[256];
    DWORD size = sizeof(name);
d2315 2
d2325 1
a2325 1
	if (LookupAccountName(NULL, name, &sid, &sidlen,
d2330 20
d2432 1
d2434 1
a2434 1
    if(items != 3)
d2437 2
a2438 2
    cmd = SvPV(ST(0),na);
    args = SvPV(ST(1), na);
d2445 1
a2445 1
    if(CreateProcess(
d2478 1
a2478 1
    if(items != 1)
d2494 1
a2494 1
	ST(0) = &sv_undef;
d2498 10
d2509 1
a2509 1
init_os_extras()
d2514 6
a2519 2
    /* XXX should be removed after checking with Nick */
    newXS("Win32::GetCurrentDirectory", w32_GetCwd, file);
d2537 1
d2560 1
a2560 1
#if !defined(_ALPHA_)
d2563 24
d2588 2
@


1.1.1.1
log
@perl5.005_03
@
text
@a13 3
#ifdef __GNUC__
#define Win32_Winsock
#endif
a15 12
#ifndef __MINGW32__
#include <lmcons.h>
#include <lmerr.h>
/* ugliness to work around a buggy struct definition in lmwksta.h */
#undef LPTSTR
#define LPTSTR LPWSTR
#include <lmwksta.h>
#undef LPTSTR
#define LPTSTR LPSTR
#include <lmapibuf.h>
#endif /* __MINGW32__ */

a24 7

#include "patchlevel.h"

#define NO_XSLOCKS
#ifdef PERL_OBJECT
extern CPerlObj* pPerl;
#endif
a25 2

#include "Win32iop.h"
a27 2
#ifndef __GNUC__
/* assert.h conflicts with #define of assert in perl.h */
a28 1
#endif
a31 6
#include <time.h>
#if defined(_MSC_VER) || defined(__MINGW32__)
#include <sys/utime.h>
#else
#include <utime.h>
#endif
d33 2
a34 6
#ifdef __GNUC__
/* Mingw32 defaults to globing command line 
 * So we turn it off like this:
 */
int _CRT_glob = 0;
#endif
d40 1
a40 14
#if defined(PERL_OBJECT)
#undef win32_get_privlib
#define win32_get_privlib g_win32_get_privlib
#undef win32_get_sitelib
#define win32_get_sitelib g_win32_get_sitelib
#undef do_aspawn
#define do_aspawn g_do_aspawn
#undef do_spawn
#define do_spawn g_do_spawn
#undef do_exec
#define do_exec g_do_exec
#undef getlogin
#define getlogin g_getlogin
#endif
d42 2
a43 9
static DWORD		os_id(void);
static void		get_shell(void);
static long		tokenize(char *str, char **dest, char ***destv);
	int		do_spawn2(char *cmd, int exectype);
static BOOL		has_shell_metachars(char *ptr);
static long		filetime_to_clock(PFILETIME ft);
static BOOL		filetime_from_time(PFILETIME ft, time_t t);
static char *		get_emd_part(char *leading, char *trailing, ...);
static void		remove_dead_process(HANDLE deceased);
d45 5
a49 2
HANDLE	w32_perldll_handle = INVALID_HANDLE_VALUE;
static DWORD	w32_platform = (DWORD)-1;
d51 1
a51 22
#ifdef USE_THREADS
#  ifdef USE_DECLSPEC_THREAD
__declspec(thread) char	strerror_buffer[512];
__declspec(thread) char	getlogin_buffer[128];
__declspec(thread) char	w32_perllib_root[MAX_PATH+1];
#    ifdef HAVE_DES_FCRYPT
__declspec(thread) char	crypt_buffer[30];
#    endif
#  else
#    define strerror_buffer	(thr->i.Wstrerror_buffer)
#    define getlogin_buffer	(thr->i.Wgetlogin_buffer)
#    define w32_perllib_root	(thr->i.Ww32_perllib_root)
#    define crypt_buffer	(thr->i.Wcrypt_buffer)
#  endif
#else
static char	strerror_buffer[512];
static char	getlogin_buffer[128];
static char	w32_perllib_root[MAX_PATH+1];
#  ifdef HAVE_DES_FCRYPT
static char	crypt_buffer[30];
#  endif
#endif
d55 1
a55 1
    return (os_id() == VER_PLATFORM_WIN32_WINDOWS);
d60 1
a60 1
    return (os_id() == VER_PLATFORM_WIN32_NT);
d63 9
a71 23
char*
GetRegStrFromKey(HKEY hkey, const char *lpszValueName, char** ptr, DWORD* lpDataLen)
{   /* Retrieve a REG_SZ or REG_EXPAND_SZ from the registry */
    HKEY handle;
    DWORD type;
    const char *subkey = "Software\\Perl";
    long retval;

    retval = RegOpenKeyEx(hkey, subkey, 0, KEY_READ, &handle);
    if (retval == ERROR_SUCCESS){
	retval = RegQueryValueEx(handle, lpszValueName, 0, &type, NULL, lpDataLen);
	if (retval == ERROR_SUCCESS && type == REG_SZ) {
	    if (*ptr) {
		Renew(*ptr, *lpDataLen, char);
	    }
	    else {
		New(1312, *ptr, *lpDataLen, char);
	    }
	    retval = RegQueryValueEx(handle, lpszValueName, 0, NULL, (PBYTE)*ptr, lpDataLen);
	    if (retval != ERROR_SUCCESS) {
		Safefree(*ptr);
		*ptr = Nullch;
	    }
a72 1
	RegCloseKey(handle);
d74 2
a75 10
    return *ptr;
}

char*
GetRegStr(const char *lpszValueName, char** ptr, DWORD* lpDataLen)
{
    *ptr = GetRegStrFromKey(HKEY_CURRENT_USER, lpszValueName, ptr, lpDataLen);
    if (*ptr == Nullch)
    {
	*ptr = GetRegStrFromKey(HKEY_LOCAL_MACHINE, lpszValueName, ptr, lpDataLen);
d77 1
a77 1
    return *ptr;
d80 2
a81 2
static char *
get_emd_part(char *prev_path, char *trailing_path, ...)
d83 1
a83 57
    char base[10];
    va_list ap;
    char mod_name[MAX_PATH+1];
    char *ptr;
    char *optr;
    char *strip;
    int oldsize, newsize;

    va_start(ap, trailing_path);
    strip = va_arg(ap, char *);

    sprintf(base, "%5.3f", (double) 5 + ((double) PATCHLEVEL / (double) 1000));

    GetModuleFileName((HMODULE)((w32_perldll_handle == INVALID_HANDLE_VALUE)
				? GetModuleHandle(NULL) : w32_perldll_handle),
		      mod_name, sizeof(mod_name));
    ptr = strrchr(mod_name, '\\');
    while (ptr && strip) {
        /* look for directories to skip back */
	optr = ptr;
	*ptr = '\0';
	ptr = strrchr(mod_name, '\\');
	if (!ptr || stricmp(ptr+1, strip) != 0) {
	    if(!(*strip == '5' && *(ptr+1) == '5' && strncmp(strip, base, 5) == 0
		    && strncmp(ptr+1, base, 5) == 0)) {
		*optr = '\\';
		ptr = optr;
	    }
	}
	strip = va_arg(ap, char *);
    }
    if (!ptr) {
	ptr = mod_name;
	*ptr++ = '.';
	*ptr = '\\';
    }
    va_end(ap);
    strcpy(++ptr, trailing_path);

    /* only add directory if it exists */
    if(GetFileAttributes(mod_name) != (DWORD) -1) {
	/* directory exists */
	newsize = strlen(mod_name) + 1;
	if (prev_path) {
	    oldsize = strlen(prev_path) + 1;
	    newsize += oldsize;			/* includes plus 1 for ';' */
	    Renew(prev_path, newsize, char);
	    prev_path[oldsize-1] = ';';
	    strcpy(&prev_path[oldsize], mod_name);
	}
	else {
	    New(1311, prev_path, newsize, char);
	    strcpy(prev_path, mod_name);
	}
    }

    return prev_path;
d87 1
a87 1
win32_get_privlib(char *pl)
d89 12
a100 13
    char *stdlib = "lib";
    char buffer[MAX_PATH+1];
    char *path = Nullch;
    DWORD datalen;

    /* $stdlib = $HKCU{"lib-$]"} || $HKLM{"lib-$]"} || $HKCU{"lib"} || $HKLM{"lib"} || "";  */
    sprintf(buffer, "%s-%s", stdlib, pl);
    path = GetRegStr(buffer, &path, &datalen);
    if (!path)
	path = GetRegStr(stdlib, &path, &datalen);

    /* $stdlib .= ";$EMD/../../lib" */
    return get_emd_part(path, stdlib, ARCHNAME, "bin", Nullch);
d104 1
a104 1
win32_get_sitelib(char *pl)
d106 4
a109 39
    char *sitelib = "sitelib";
    char regstr[40];
    char pathstr[MAX_PATH+1];
    DWORD datalen;
    char *path1 = Nullch;
    char *path2 = Nullch;
    int len, newsize;

    /* $HKCU{"sitelib-$]"} || $HKLM{"sitelib-$]"} . ---; */
    sprintf(regstr, "%s-%s", sitelib, pl);
    path1 = GetRegStr(regstr, &path1, &datalen);

    /* $sitelib .=
     * ";$EMD/" . ((-d $EMD/../../../$]) ? "../../.." : "../.."). "/site/$]/lib";  */
    sprintf(pathstr, "site\\%s\\lib", pl);
    path1 = get_emd_part(path1, pathstr, ARCHNAME, "bin", pl, Nullch);

    /* $HKCU{'sitelib'} || $HKLM{'sitelib'} . ---; */
    path2 = GetRegStr(sitelib, &path2, &datalen);

    /* $sitelib .=
     * ";$EMD/" . ((-d $EMD/../../../$]) ? "../../.." : "../.."). "/site/lib";  */
    path2 = get_emd_part(path2, "site\\lib", ARCHNAME, "bin", pl, Nullch);

    if (!path1)
	return path2;

    if (!path2)
	return path1;

    len = strlen(path1);
    newsize = len + strlen(path2) + 2; /* plus one for ';' */

    Renew(path1, newsize, char);
    path1[len++] = ';';
    strcpy(&path1[len], path2);

    Safefree(path2);
    return path1;
d112 2
a113 3

static BOOL
has_shell_metachars(char *ptr)
d120 1
a120 2
     * characters (|) that are not in a quoted string.
     * Shell variable interpolation (%VAR%) can also happen inside strings.
d122 1
a122 1
    while (*ptr) {
a123 2
	case '%':
	    return TRUE;
d126 2
a127 2
	    if (inquote) {
		if (quote == *ptr) {
d140 1
a140 1
	    if (!inquote)
a149 1
#if !defined(PERL_OBJECT)
d171 5
d177 1
d180 1
d182 139
a327 1
#endif
d330 1
a330 1
os_id(void)
d334 1
a334 1
    if (osver.dwPlatformId != w32_platform) {
d338 1
a338 1
	w32_platform = osver.dwPlatformId;
d340 1
a340 1
    return (w32_platform);
d343 2
a344 8
/* Tokenize a string.  Words are null-separated, and the list
 * ends with a doubled null.  Any character (except null and
 * including backslash) may be escaped by preceding it with a
 * backslash (the backslash will be stripped).
 * Returns number of words in result buffer.
 */
static long
tokenize(char *str, char **dest, char ***destv)
d346 2
a347 47
    char *retstart = Nullch;
    char **retvstart = 0;
    int items = -1;
    if (str) {
	int slen = strlen(str);
	register char *ret;
	register char **retv;
	New(1307, ret, slen+2, char);
	New(1308, retv, (slen+3)/2, char*);

	retstart = ret;
	retvstart = retv;
	*retv = ret;
	items = 0;
	while (*str) {
	    *ret = *str++;
	    if (*ret == '\\' && *str)
		*ret = *str++;
	    else if (*ret == ' ') {
		while (*str == ' ')
		    str++;
		if (ret == retstart)
		    ret--;
		else {
		    *ret = '\0';
		    ++items;
		    if (*str)
			*++retv = ret+1;
		}
	    }
	    else if (!*str)
		++items;
	    ret++;
	}
	retvstart[items] = Nullch;
	*ret++ = '\0';
	*ret = '\0';
    }
    *dest = retstart;
    *destv = retvstart;
    return items;
}

static void
get_shell(void)
{
    if (!w32_perlshell_tokens) {
d355 4
a358 5
	char* defaultshell = (IsWinNT() ? "cmd.exe /x/c" : "command.com /c");
	char *usershell = getenv("PERL5SHELL");
	w32_perlshell_items = tokenize(usershell ? usershell : defaultshell,
				       &w32_perlshell_tokens,
				       &w32_perlshell_vec);
d360 1
d364 1
a364 1
do_aspawn(void *vreally, void **vmark, void **vsp)
a365 3
    SV *really = (SV*)vreally;
    SV **mark = (SV**)vmark;
    SV **sp = (SV**)vsp;
d367 2
a368 1
    char *str;
d370 1
a370 1
    int flag = P_WAIT;
d372 2
a373 1
    STRLEN n_a;
d375 1
a375 2
    if (sp <= mark)
	return -1;
d377 8
a384 6
    get_shell();
    New(1306, argv, (sp - mark) + w32_perlshell_items + 2, char*);

    if (SvNIOKp(*(mark+1)) && !SvPOKp(*(mark+1))) {
	++mark;
	flag = SvIVx(*mark);
d387 5
a391 5
    while (++mark <= sp) {
	if (*mark && (str = SvPV(*mark, n_a)))
	    argv[index++] = str;
	else
	    argv[index++] = "";
d395 3
a397 17
    status = win32_spawnvp(flag,
			   (const char*)(really ? SvPV(really,n_a) : argv[0]),
			   (const char* const*)argv);

    if (status < 0 && (errno == ENOEXEC || errno == ENOENT)) {
	/* possible shell-builtin, invoke with shell */
	int sh_items;
	sh_items = w32_perlshell_items;
	while (--index >= 0)
	    argv[index+sh_items] = argv[index];
	while (--sh_items >= 0)
	    argv[sh_items] = w32_perlshell_vec[sh_items];
   
	status = win32_spawnvp(flag,
			       (const char*)(really ? SvPV(really,n_a) : argv[0]),
			       (const char* const*)argv);
    }
d399 4
a402 9
    if (flag != P_NOWAIT) {
	if (status < 0) {
	    if (PL_dowarn)
		warn("Can't spawn \"%s\": %s", argv[0], strerror(errno));
	    status = 255 * 256;
	}
	else
	    status *= 256;
	PL_statusvalue = status;
a403 1
    Safefree(argv);
d415 4
a418 1
    char *cmd2;
d420 2
a421 3
    /* Save an extra exec if possible. See if there are shell
     * metacharacters in it */
    if (!has_shell_metachars(cmd)) {
d431 1
a431 1
	    while (*s && !isspace(*s))
d433 1
a433 1
	    if (*s)
d437 1
a437 1
	if (argv[0]) {
d451 1
a451 1
	    if (status != -1 || errno == 0)
d457 7
a463 9
    if (needToTry) {
	char **argv;
	int i = -1;
	get_shell();
	New(1306, argv, w32_perlshell_items + 2, char*);
	while (++i < w32_perlshell_items)
	    argv[i] = w32_perlshell_vec[i];
	argv[i++] = cmd;
	argv[i] = Nullch;
a476 2
	cmd = argv[0];
	Safefree(argv);
d478 7
a484 11
    if (exectype != EXECF_SPAWN_NOWAIT) {
	if (status < 0) {
	    if (PL_dowarn)
		warn("Can't %s \"%s\": %s",
		     (exectype == EXECF_EXEC ? "exec" : "spawn"),
		     cmd, strerror(errno));
	    status = 255 * 256;
	}
	else
	    status *= 256;
	PL_statusvalue = status;
a494 6
int
do_spawn_nowait(char *cmd)
{
    return do_spawn2(cmd, EXECF_SPAWN_NOWAIT);
}

d502 3
d510 1
a510 1
win32_opendir(char *filename)
d512 13
a524 11
    DIR			*p;
    long		len;
    long		idx;
    char		scanname[MAX_PATH+3];
    struct stat		sbuf;
    WIN32_FIND_DATA	FindData;
    HANDLE		fh;

    len = strlen(filename);
    if (len > MAX_PATH)
	return NULL;
d527 1
a527 1
    if (win32_stat(filename, &sbuf) < 0 || !S_ISDIR(sbuf.st_mode))
d529 1
d531 13
d546 1
a546 1
    if (p == NULL)
d551 5
a555 4
    if (scanname[len-1] != '/' && scanname[len-1] != '\\')
	scanname[len++] = '/';
    scanname[len++] = '*';
    scanname[len] = '\0';
d559 1
a559 5
    if (fh == INVALID_HANDLE_VALUE) {
	/* FindFirstFile() fails on empty drives! */
	if (GetLastError() == ERROR_FILE_NOT_FOUND)
	    return p;
	Safefree( p);
d568 3
a570 2
    if (p->start == NULL)
	croak("opendir: malloc failed!\n");
d572 3
d588 3
a590 2
	if (p->start == NULL)
	    croak("opendir: malloc failed!\n");
d592 10
a601 7
	p->nfiles++;
	idx += len+1;
    }
    FindClose(fh);
    p->size = idx;
    p->curr = p->start;
    return p;
d609 1
a609 1
win32_readdir(DIR *dirp)
d637 1
a637 1
win32_telldir(DIR *dirp)
d647 1
a647 1
win32_seekdir(DIR *dirp, long loc)
d654 1
a654 1
win32_rewinddir(DIR *dirp)
d661 1
a661 1
win32_closedir(DIR *dirp)
d708 1
a708 1
setuid(uid_t auid)
d710 1
a710 1
    return (auid == ROOT_UID ? 0 : -1);
d714 1
a714 1
setgid(gid_t agid)
d716 1
a716 12
    return (agid == ROOT_GID ? 0 : -1);
}

char *
getlogin(void)
{
    dTHR;
    char *buf = getlogin_buffer;
    DWORD size = sizeof(getlogin_buffer);
    if (GetUserName(buf,&size))
	return buf;
    return (char*)NULL;
d719 3
d723 1
a723 1
chown(const char *path, uid_t owner, gid_t group)
a724 24
    /* XXX noop */
    return 0;
}

static void
remove_dead_process(HANDLE deceased)
{
#ifndef USE_RTL_WAIT
    int child;
    for (child = 0 ; child < w32_num_children ; ++child) {
	if (w32_child_pids[child] == deceased) {
	    Copy(&w32_child_pids[child+1], &w32_child_pids[child],
		 (w32_num_children-child-1), HANDLE);
	    w32_num_children--;
	    break;
	}
    }
#endif
}

DllExport int
win32_kill(int pid, int sig)
{
#ifdef USE_RTL_WAIT
a725 3
#else
    HANDLE hProcess = (HANDLE) pid;
#endif
d728 1
a728 1
	croak("kill process failed!\n");
d732 1
a732 1
	    croak("kill process failed!\n");
a733 4

	/* WaitForMultipleObjects() on a pid that was killed returns error
	 * so if we know the pid is gone we remove it from process list */
	remove_dead_process(hProcess);
d737 1
a737 1

d742 11
a752 2
DllExport unsigned int
win32_sleep(unsigned int t)
d758 13
d774 1
a774 1
    char	t[MAX_PATH+1]; 
d790 1
a790 25
    res = stat(p,buffer);
    if (res < 0) {
	/* CRT is buggy on sharenames, so make sure it really isn't.
	 * XXX using GetFileAttributesEx() will enable us to set
	 * buffer->st_*time (but note that's not available on the
	 * Windows of 1995) */
	DWORD r = GetFileAttributes(p);
	if (r != 0xffffffff && (r & FILE_ATTRIBUTE_DIRECTORY)) {
	    buffer->st_mode |= S_IFDIR | S_IREAD;
	    errno = 0;
	    if (!(r & FILE_ATTRIBUTE_READONLY))
		buffer->st_mode |= S_IWRITE | S_IEXEC;
	    return 0;
	}
    }
    else {
	if (l == 3 && path[l-2] == ':'
	    && (path[l-1] == '\\' || path[l-1] == '/'))
	{
	    /* The drive can be inaccessible, some _stat()s are buggy */
	    if (!GetVolumeInformation(path,NULL,0,NULL,NULL,NULL,NULL,0)) {
		errno = ENOENT;
		return -1;
	    }
	}
d792 1
d809 1
a810 1
    }
d819 2
a820 2
    static char *curitem = Nullch;	/* XXX threadead */
    static DWORD curlen = 0;		/* XXX threadead */
d822 1
a822 2
    if (!curitem) {
	curlen = 512;
d824 6
a830 27

    needlen = GetEnvironmentVariable(name,curitem,curlen);
    if (needlen != 0) {
	while (needlen > curlen) {
	    Renew(curitem,needlen,char);
	    curlen = needlen;
	    needlen = GetEnvironmentVariable(name,curitem,curlen);
	}
    }
    else {
	/* allow any environment variables that begin with 'PERL'
	   to be stored in the registry */
	if (curitem)
	    *curitem = '\0';

	if (strncmp(name, "PERL", 4) == 0) {
	    if (curitem) {
		Safefree(curitem);
		curitem = Nullch;
		curlen = 0;
	    }
	    curitem = GetRegStr(name, &curitem, &curlen);
	}
    }
    if (curitem && *curitem == '\0')
	return Nullch;

a833 34
DllExport int
win32_putenv(const char *name)
{
    char* curitem;
    char* val;
    int relval = -1;
    if(name) {
	New(1309,curitem,strlen(name)+1,char);
	strcpy(curitem, name);
	val = strchr(curitem, '=');
	if(val) {
	    /* The sane way to deal with the environment.
	     * Has these advantages over putenv() & co.:
	     *  * enables us to store a truly empty value in the
	     *    environment (like in UNIX).
	     *  * we don't have to deal with RTL globals, bugs and leaks.
	     *  * Much faster.
	     * Why you may want to enable USE_WIN32_RTL_ENV:
	     *  * environ[] and RTL functions will not reflect changes,
	     *    which might be an issue if extensions want to access
	     *    the env. via RTL.  This cuts both ways, since RTL will
	     *    not see changes made by extensions that call the Win32
	     *    functions directly, either.
	     * GSAR 97-06-07
	     */
	    *val++ = '\0';
	    if(SetEnvironmentVariable(curitem, *val ? val : NULL))
		relval = 0;
	}
	Safefree(curitem);
    }
    return relval;
}

d836 3
a838 2
static long
filetime_to_clock(PFILETIME ft)
d840 5
a844 6
 __int64 qw = ft->dwHighDateTime;
 qw <<= 32;
 qw |= ft->dwLowDateTime;
 qw /= 10000;  /* File time ticks at 0.1uS, clock at 1mS */
 return (long) qw;
}
a845 21
DllExport int
win32_times(struct tms *timebuf)
{
    FILETIME user;
    FILETIME kernel;
    FILETIME dummy;
    if (GetProcessTimes(GetCurrentProcess(), &dummy, &dummy, 
                        &kernel,&user)) {
	timebuf->tms_utime = filetime_to_clock(&user);
	timebuf->tms_stime = filetime_to_clock(&kernel);
	timebuf->tms_cutime = 0;
	timebuf->tms_cstime = 0;
        
    } else { 
        /* That failed - e.g. Win95 fallback to clock() */
        clock_t t = clock();
	timebuf->tms_utime = t;
	timebuf->tms_stime = 0;
	timebuf->tms_cutime = 0;
	timebuf->tms_cstime = 0;
    }
d849 7
a855 161
/* fix utime() so it works on directories in NT
 * thanks to Jan Dubois <jan.dubois@@ibm.net>
 */
static BOOL
filetime_from_time(PFILETIME pFileTime, time_t Time)
{
    struct tm *pTM = gmtime(&Time);
    SYSTEMTIME SystemTime;

    if (pTM == NULL)
	return FALSE;

    SystemTime.wYear   = pTM->tm_year + 1900;
    SystemTime.wMonth  = pTM->tm_mon + 1;
    SystemTime.wDay    = pTM->tm_mday;
    SystemTime.wHour   = pTM->tm_hour;
    SystemTime.wMinute = pTM->tm_min;
    SystemTime.wSecond = pTM->tm_sec;
    SystemTime.wMilliseconds = 0;

    return SystemTimeToFileTime(&SystemTime, pFileTime);
}

DllExport int
win32_utime(const char *filename, struct utimbuf *times)
{
    HANDLE handle;
    FILETIME ftCreate;
    FILETIME ftAccess;
    FILETIME ftWrite;
    struct utimbuf TimeBuffer;

    int rc = utime(filename,times);
    /* EACCES: path specifies directory or readonly file */
    if (rc == 0 || errno != EACCES /* || !IsWinNT() */)
	return rc;

    if (times == NULL) {
	times = &TimeBuffer;
	time(&times->actime);
	times->modtime = times->actime;
    }

    /* This will (and should) still fail on readonly files */
    handle = CreateFile(filename, GENERIC_READ | GENERIC_WRITE,
			FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
			OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (handle == INVALID_HANDLE_VALUE)
	return rc;

    if (GetFileTime(handle, &ftCreate, &ftAccess, &ftWrite) &&
	filetime_from_time(&ftAccess, times->actime) &&
	filetime_from_time(&ftWrite, times->modtime) &&
	SetFileTime(handle, &ftCreate, &ftAccess, &ftWrite))
    {
	rc = 0;
    }

    CloseHandle(handle);
    return rc;
}

DllExport int
win32_waitpid(int pid, int *status, int flags)
{
    int rc;
    if (pid == -1) 
      return win32_wait(status);
    else {
      rc = cwait(status, pid, WAIT_CHILD);
    /* cwait() returns "correctly" on Borland */
#ifndef __BORLANDC__
    if (status)
	*status *= 256;
#endif
      remove_dead_process((HANDLE)pid);
    }
    return rc >= 0 ? pid : rc;                
}

DllExport int
win32_wait(int *status)
{
#ifdef USE_RTL_WAIT
    return wait(status);
#else
    /* XXX this wait emulation only knows about processes
     * spawned via win32_spawnvp(P_NOWAIT, ...).
     */
    int i, retval;
    DWORD exitcode, waitcode;

    if (!w32_num_children) {
	errno = ECHILD;
	return -1;
    }

    /* if a child exists, wait for it to die */
    waitcode = WaitForMultipleObjects(w32_num_children,
				      w32_child_pids,
				      FALSE,
				      INFINITE);
    if (waitcode != WAIT_FAILED) {
	if (waitcode >= WAIT_ABANDONED_0
	    && waitcode < WAIT_ABANDONED_0 + w32_num_children)
	    i = waitcode - WAIT_ABANDONED_0;
	else
	    i = waitcode - WAIT_OBJECT_0;
	if (GetExitCodeProcess(w32_child_pids[i], &exitcode) ) {
	    CloseHandle(w32_child_pids[i]);
	    *status = (int)((exitcode & 0xff) << 8);
	    retval = (int)w32_child_pids[i];
	    Copy(&w32_child_pids[i+1], &w32_child_pids[i],
		 (w32_num_children-i-1), HANDLE);
	    w32_num_children--;
	    return retval;
	}
    }

FAILED:
    errno = GetLastError();
    return -1;

#endif
}

static UINT timerid = 0;

static VOID CALLBACK TimerProc(HWND win, UINT msg, UINT id, DWORD time)
{
 KillTimer(NULL,timerid);
 timerid=0;  
 sighandler(14);
}

DllExport unsigned int
win32_alarm(unsigned int sec)
{
    /* 
     * the 'obvious' implentation is SetTimer() with a callback
     * which does whatever receiving SIGALRM would do 
     * we cannot use SIGALRM even via raise() as it is not 
     * one of the supported codes in <signal.h>
     *
     * Snag is unless something is looking at the message queue
     * nothing happens :-(
     */ 
    if (sec)
     {
      timerid = SetTimer(NULL,timerid,sec*1000,(TIMERPROC)TimerProc);
      if (!timerid)
       croak("Cannot set timer");
     } 
    else
     {
      if (timerid)
       {
        KillTimer(NULL,timerid);
        timerid=0;  
       }
     }
a858 166
#if defined(HAVE_DES_FCRYPT) || defined(PERL_OBJECT)
#ifdef HAVE_DES_FCRYPT
extern char *	des_fcrypt(const char *txt, const char *salt, char *cbuf);
#endif

DllExport char *
win32_crypt(const char *txt, const char *salt)
{
#ifdef HAVE_DES_FCRYPT
    dTHR;
    return des_fcrypt(txt, salt, crypt_buffer);
#else
    die("The crypt() function is unimplemented due to excessive paranoia.");
    return Nullch;
#endif
}
#endif

#ifdef USE_FIXED_OSFHANDLE

EXTERN_C int __cdecl _alloc_osfhnd(void);
EXTERN_C int __cdecl _set_osfhnd(int fh, long value);
EXTERN_C void __cdecl _lock_fhandle(int);
EXTERN_C void __cdecl _unlock_fhandle(int);
EXTERN_C void __cdecl _unlock(int);

#if	(_MSC_VER >= 1000)
typedef struct	{
    long osfhnd;    /* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
#if defined (_MT) && !defined (DLL_FOR_WIN32S)
    int lockinitflag;
    CRITICAL_SECTION lock;
#endif  /* defined (_MT) && !defined (DLL_FOR_WIN32S) */
}	ioinfo;

EXTERN_C ioinfo * __pioinfo[];

#define IOINFO_L2E			5
#define IOINFO_ARRAY_ELTS	(1 << IOINFO_L2E)
#define _pioinfo(i)	(__pioinfo[i >> IOINFO_L2E] + (i & (IOINFO_ARRAY_ELTS - 1)))
#define _osfile(i)	(_pioinfo(i)->osfile)

#else	/* (_MSC_VER >= 1000) */
extern char _osfile[];
#endif	/* (_MSC_VER >= 1000) */

#define FOPEN			0x01	/* file handle open */
#define FAPPEND			0x20	/* file handle opened O_APPEND */
#define FDEV			0x40	/* file handle refers to device */
#define FTEXT			0x80	/* file handle is in text mode */

#define _STREAM_LOCKS   26		/* Table of stream locks */
#define _LAST_STREAM_LOCK  (_STREAM_LOCKS+_NSTREAM_-1)	/* Last stream lock */
#define _FH_LOCKS          (_LAST_STREAM_LOCK+1)	/* Table of fh locks */

/***
*int my_open_osfhandle(long osfhandle, int flags) - open C Runtime file handle
*
*Purpose:
*       This function allocates a free C Runtime file handle and associates
*       it with the Win32 HANDLE specified by the first parameter. This is a
*		temperary fix for WIN95's brain damage GetFileType() error on socket
*		we just bypass that call for socket
*
*Entry:
*       long osfhandle - Win32 HANDLE to associate with C Runtime file handle.
*       int flags      - flags to associate with C Runtime file handle.
*
*Exit:
*       returns index of entry in fh, if successful
*       return -1, if no free entry is found
*
*Exceptions:
*
*******************************************************************************/

static int
my_open_osfhandle(long osfhandle, int flags)
{
    int fh;
    char fileflags;		/* _osfile flags */

    /* copy relevant flags from second parameter */
    fileflags = FDEV;

    if (flags & O_APPEND)
	fileflags |= FAPPEND;

    if (flags & O_TEXT)
	fileflags |= FTEXT;

    /* attempt to allocate a C Runtime file handle */
    if ((fh = _alloc_osfhnd()) == -1) {
	errno = EMFILE;		/* too many open files */
	_doserrno = 0L;		/* not an OS error */
	return -1;		/* return error to caller */
    }

    /* the file is open. now, set the info in _osfhnd array */
    _set_osfhnd(fh, osfhandle);

    fileflags |= FOPEN;		/* mark as open */

#if (_MSC_VER >= 1000)
    _osfile(fh) = fileflags;	/* set osfile entry */
    _unlock_fhandle(fh);
#else
    _osfile[fh] = fileflags;	/* set osfile entry */
    _unlock(fh+_FH_LOCKS);		/* unlock handle */
#endif

    return fh;			/* return handle */
}

#define _open_osfhandle my_open_osfhandle
#endif	/* USE_FIXED_OSFHANDLE */

/* simulate flock by locking a range on the file */

#define LK_ERR(f,i)	((f) ? (i = 0) : (errno = GetLastError()))
#define LK_LEN		0xffff0000

DllExport int
win32_flock(int fd, int oper)
{
    OVERLAPPED o;
    int i = -1;
    HANDLE fh;

    if (!IsWinNT()) {
	croak("flock() unimplemented on this platform");
	return -1;
    }
    fh = (HANDLE)_get_osfhandle(fd);
    memset(&o, 0, sizeof(o));

    switch(oper) {
    case LOCK_SH:		/* shared lock */
	LK_ERR(LockFileEx(fh, 0, 0, LK_LEN, 0, &o),i);
	break;
    case LOCK_EX:		/* exclusive lock */
	LK_ERR(LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK, 0, LK_LEN, 0, &o),i);
	break;
    case LOCK_SH|LOCK_NB:	/* non-blocking shared lock */
	LK_ERR(LockFileEx(fh, LOCKFILE_FAIL_IMMEDIATELY, 0, LK_LEN, 0, &o),i);
	break;
    case LOCK_EX|LOCK_NB:	/* non-blocking exclusive lock */
	LK_ERR(LockFileEx(fh,
		       LOCKFILE_EXCLUSIVE_LOCK|LOCKFILE_FAIL_IMMEDIATELY,
		       0, LK_LEN, 0, &o),i);
	break;
    case LOCK_UN:		/* unlock lock */
	LK_ERR(UnlockFileEx(fh, 0, LK_LEN, 0, &o),i);
	break;
    default:			/* unknown */
	errno = EINVAL;
	break;
    }
    return i;
}

#undef LK_ERR
#undef LK_LEN

d867 1
a867 1
    return (&errno);
d873 1
a873 1
    return (&(_environ));
d880 1
a880 1
    return (stderr);
d886 1
a886 1
    return (stdin);
d892 1
a892 1
    return (stdout);
d898 1
a898 1
    return (ferror(fp));
d905 1
a905 1
    return (feof(fp));
d914 2
d924 2
a925 3
    if (e < 0 || e > sys_nerr) {
        dTHR;
	if (e < 0)
d928 1
a928 1
	if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, &source, e, 0,
d934 1
a934 1
    return strerror(e);
a936 27
DllExport void
win32_str_os_error(void *sv, DWORD dwErr)
{
    DWORD dwLen;
    char *sMsg;
    dwLen = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER
			  |FORMAT_MESSAGE_IGNORE_INSERTS
			  |FORMAT_MESSAGE_FROM_SYSTEM, NULL,
			   dwErr, 0, (char *)&sMsg, 1, NULL);
    if (0 < dwLen) {
	while (0 < dwLen  &&  isspace(sMsg[--dwLen]))
	    ;
	if ('.' != sMsg[dwLen])
	    dwLen++;
	sMsg[dwLen]= '\0';
    }
    if (0 == dwLen) {
	sMsg = (char*)LocalAlloc(0, 64/**sizeof(TCHAR)*/);
	dwLen = sprintf(sMsg,
			"Unknown error #0x%lX (lookup 0x%lX)",
			dwErr, GetLastError());
    }
    sv_setpvn((SV*)sv, sMsg, dwLen);
    LocalFree(sMsg);
}


d943 1
a943 1
    return (vfprintf(fp, format, marker));
d952 1
a952 1
    return (vprintf(format, marker));
d958 1
a958 1
    return (vfprintf(fp, format, args));
d964 1
a964 1
    return (vprintf(format, args));
d970 1
a970 1
    return fread(buf, size, count, fp);
d976 1
a976 1
    return fwrite(buf, size, count, fp);
d983 2
a984 2
	return fopen("NUL", mode);
    return fopen(filename, mode);
a986 5
#ifndef USE_SOCKETS_AS_HANDLES
#undef fdopen
#define fdopen my_fdopen
#endif

d990 1
a990 1
    return fdopen(handle, (char *) mode);
d997 2
a998 2
	return freopen("NUL", mode, stream);
    return freopen(path, mode, stream);
d1004 1
a1004 1
    return my_fclose(pf);	/* defined in win32sck.c */
d1010 1
a1010 1
    return fputs(s, pf);
d1016 1
a1016 1
    return fputc(c,pf);
d1022 1
a1022 1
    return ungetc(c,pf);
d1028 1
a1028 1
    return getc(pf);
d1034 1
a1034 1
    return fileno(pf);
d1040 1
a1040 1
    clearerr(pf);
d1047 1
a1047 1
    return fflush(pf);
d1053 1
a1053 1
    return ftell(pf);
d1059 1
a1059 1
    return fseek(pf, offset, origin);
d1065 1
a1065 1
    return fgetpos(pf, p);
d1071 1
a1071 1
    return fsetpos(pf, p);
d1077 1
a1077 1
    rewind(pf);
d1084 1
a1084 1
    return tmpfile();
d1090 1
a1090 1
    abort();
d1095 1
a1095 1
win32_fstat(int fd,struct stat *sbufptr)
d1097 1
a1097 1
    return fstat(fd,sbufptr);
d1103 1
a1103 1
    return _pipe(pfd, size, mode);
a1105 4
/*
 * a popen() clone that respects PERL5SHELL
 */

d1109 1
a1109 76
#ifdef USE_RTL_POPEN
    return _popen(command, mode);
#else
    int p[2];
    int parent, child;
    int stdfd, oldfd;
    int ourmode;
    int childpid;

    /* establish which ends read and write */
    if (strchr(mode,'w')) {
        stdfd = 0;		/* stdin */
        parent = 1;
        child = 0;
    }
    else if (strchr(mode,'r')) {
        stdfd = 1;		/* stdout */
        parent = 0;
        child = 1;
    }
    else
        return NULL;

    /* set the correct mode */
    if (strchr(mode,'b'))
        ourmode = O_BINARY;
    else if (strchr(mode,'t'))
        ourmode = O_TEXT;
    else
        ourmode = _fmode & (O_TEXT | O_BINARY);

    /* the child doesn't inherit handles */
    ourmode |= O_NOINHERIT;

    if (win32_pipe( p, 512, ourmode) == -1)
        return NULL;

    /* save current stdfd */
    if ((oldfd = win32_dup(stdfd)) == -1)
        goto cleanup;

    /* make stdfd go to child end of pipe (implicitly closes stdfd) */
    /* stdfd will be inherited by the child */
    if (win32_dup2(p[child], stdfd) == -1)
        goto cleanup;

    /* close the child end in parent */
    win32_close(p[child]);

    /* start the child */
    if ((childpid = do_spawn_nowait((char*)command)) == -1)
        goto cleanup;

    /* revert stdfd to whatever it was before */
    if (win32_dup2(oldfd, stdfd) == -1)
        goto cleanup;

    /* close saved handle */
    win32_close(oldfd);

    sv_setiv(*av_fetch(w32_fdpid, p[parent], TRUE), childpid);

    /* we have an fd, return a file stream */
    return (win32_fdopen(p[parent], (char *)mode));

cleanup:
    /* we don't need to check for errors here */
    win32_close(p[0]);
    win32_close(p[1]);
    if (oldfd != -1) {
        win32_dup2(oldfd, stdfd);
        win32_close(oldfd);
    }
    return (NULL);

#endif /* USE_RTL_POPEN */
a1111 4
/*
 * pclose() clone
 */

d1115 1
a1115 134
#ifdef USE_RTL_POPEN
    return _pclose(pf);
#else

    int childpid, status;
    SV *sv;

    sv = *av_fetch(w32_fdpid, win32_fileno(pf), TRUE);
    if (SvIOK(sv))
	childpid = SvIVX(sv);
    else
	childpid = 0;

    if (!childpid) {
	errno = EBADF;
        return -1;
    }

    win32_fclose(pf);
    SvIVX(sv) = 0;

    remove_dead_process((HANDLE)childpid);

    /* wait for the child */
    if (cwait(&status, childpid, WAIT_CHILD) == -1)
        return (-1);
    /* cwait() returns "correctly" on Borland */
#ifndef __BORLANDC__
    status *= 256;
#endif
    return (status);

#endif /* USE_RTL_POPEN */
}

DllExport int
win32_rename(const char *oname, const char *newname)
{
    /* XXX despite what the documentation says about MoveFileEx(),
     * it doesn't work under Windows95!
     */
    if (IsWinNT()) {
	if (!MoveFileEx(oname,newname,
			MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING)) {
	    DWORD err = GetLastError();
	    switch (err) {
	    case ERROR_BAD_NET_NAME:
	    case ERROR_BAD_NETPATH:
	    case ERROR_BAD_PATHNAME:
	    case ERROR_FILE_NOT_FOUND:
	    case ERROR_FILENAME_EXCED_RANGE:
	    case ERROR_INVALID_DRIVE:
	    case ERROR_NO_MORE_FILES:
	    case ERROR_PATH_NOT_FOUND:
		errno = ENOENT;
		break;
	    default:
		errno = EACCES;
		break;
	    }
	    return -1;
	}
	return 0;
    }
    else {
	int retval = 0;
	char tmpname[MAX_PATH+1];
	char dname[MAX_PATH+1];
	char *endname = Nullch;
	STRLEN tmplen = 0;
	DWORD from_attr, to_attr;

	/* if oname doesn't exist, do nothing */
	from_attr = GetFileAttributes(oname);
	if (from_attr == 0xFFFFFFFF) {
	    errno = ENOENT;
	    return -1;
	}

	/* if newname exists, rename it to a temporary name so that we
	 * don't delete it in case oname happens to be the same file
	 * (but perhaps accessed via a different path)
	 */
	to_attr = GetFileAttributes(newname);
	if (to_attr != 0xFFFFFFFF) {
	    /* if newname is a directory, we fail
	     * XXX could overcome this with yet more convoluted logic */
	    if (to_attr & FILE_ATTRIBUTE_DIRECTORY) {
		errno = EACCES;
		return -1;
	    }
	    tmplen = strlen(newname);
	    strcpy(tmpname,newname);
	    endname = tmpname+tmplen;
	    for (; endname > tmpname ; --endname) {
		if (*endname == '/' || *endname == '\\') {
		    *endname = '\0';
		    break;
		}
	    }
	    if (endname > tmpname)
		endname = strcpy(dname,tmpname);
	    else
		endname = ".";

	    /* get a temporary filename in same directory
	     * XXX is this really the best we can do? */
	    if (!GetTempFileName((LPCTSTR)endname, "plr", 0, tmpname)) {
		errno = ENOENT;
		return -1;
	    }
	    DeleteFile(tmpname);

	    retval = rename(newname, tmpname);
	    if (retval != 0) {
		errno = EACCES;
		return retval;
	    }
	}

	/* rename oname to newname */
	retval = rename(oname, newname);

	/* if we created a temporary file before ... */
	if (endname != Nullch) {
	    /* ...and rename succeeded, delete temporary file/directory */
	    if (retval == 0)
		DeleteFile(tmpname);
	    /* else restore it to what it was */
	    else
		(void)rename(tmpname, newname);
	}
	return retval;
    }
d1121 1
a1121 1
    return setmode(fd, mode);
d1127 1
a1127 1
    return lseek(fd, offset, origin);
d1133 1
a1133 1
    return tell(fd);
d1147 2
a1148 2
	return open("NUL", flag, pmode);
    return open(path,flag,pmode);
d1154 1
a1154 1
    return close(fd);
d1160 1
a1160 1
    return eof(fd);
d1166 1
a1166 1
    return dup(fd);
d1172 1
a1172 1
    return dup2(fd1,fd2);
d1178 1
a1178 1
    return read(fd, buf, cnt);
d1184 1
a1184 1
    return write(fd, buf, cnt);
d1190 1
a1190 1
    return mkdir(dir); /* just ignore mode */
d1196 1
a1196 1
    return rmdir(dir);
d1202 1
a1202 1
    return chdir(dir);
d1208 1
a1208 23
    int status;

#ifndef USE_RTL_WAIT
    if (mode == P_NOWAIT && w32_num_children >= MAXIMUM_WAIT_OBJECTS)
	return -1;
#endif

    status = spawnvp(mode, cmdname, (char * const *) argv);
#ifndef USE_RTL_WAIT
    /* XXX For the P_NOWAIT case, Borland RTL returns pinfo.dwProcessId
     * while VC RTL returns pinfo.hProcess. For purposes of the custom
     * implementation of win32_wait(), we assume the latter.
     */
    if (mode == P_NOWAIT && status >= 0)
	w32_child_pids[w32_num_children++] = (HANDLE)status;
#endif
    return status;
}

DllExport int
win32_execv(const char *cmdname, const char *const *argv)
{
    return execv(cmdname, (char *const *)argv);
d1214 1
a1214 1
    return execvp(cmdname, (char *const *)argv);
d1220 1
a1220 1
    perror(str);
d1226 1
a1226 1
    setbuf(pf, buf);
d1232 1
a1232 1
    return setvbuf(pf, buf, type, size);
d1238 1
a1238 1
    return flushall();
d1244 1
a1244 1
    return fcloseall();
d1250 1
a1250 1
    return fgets(s, n, pf);
d1256 1
a1256 1
    return gets(s);
d1262 1
a1262 1
    return fgetc(pf);
d1268 1
a1268 1
    return putc(c,pf);
d1274 1
a1274 1
    return puts(s);
d1280 1
a1280 1
    return getchar();
d1286 1
a1286 1
    return putchar(c);
a1288 79
#ifdef MYMALLOC

#ifndef USE_PERL_SBRK

static char *committed = NULL;
static char *base      = NULL;
static char *reserved  = NULL;
static char *brk       = NULL;
static DWORD pagesize  = 0;
static DWORD allocsize = 0;

void *
sbrk(int need)
{
 void *result;
 if (!pagesize)
  {SYSTEM_INFO info;
   GetSystemInfo(&info);
   /* Pretend page size is larger so we don't perpetually
    * call the OS to commit just one page ...
    */
   pagesize = info.dwPageSize << 3;
   allocsize = info.dwAllocationGranularity;
  }
 /* This scheme fails eventually if request for contiguous
  * block is denied so reserve big blocks - this is only 
  * address space not memory ...
  */
 if (brk+need >= reserved)
  {
   DWORD size = 64*1024*1024;
   char *addr;
   if (committed && reserved && committed < reserved)
    {
     /* Commit last of previous chunk cannot span allocations */
     addr = (char *) VirtualAlloc(committed,reserved-committed,MEM_COMMIT,PAGE_READWRITE);
     if (addr)
      committed = reserved;
    }
   /* Reserve some (more) space 
    * Note this is a little sneaky, 1st call passes NULL as reserved
    * so lets system choose where we start, subsequent calls pass
    * the old end address so ask for a contiguous block
    */
   addr  = (char *) VirtualAlloc(reserved,size,MEM_RESERVE,PAGE_NOACCESS);
   if (addr)
    {
     reserved = addr+size;
     if (!base)
      base = addr;
     if (!committed)
      committed = base;
     if (!brk)
      brk = committed;
    }
   else
    {
     return (void *) -1;
    }
  }
 result = brk;
 brk += need;
 if (brk > committed)
  {
   DWORD size = ((brk-committed + pagesize -1)/pagesize) * pagesize;
   char *addr = (char *) VirtualAlloc(committed,size,MEM_COMMIT,PAGE_READWRITE);
   if (addr)
    {
     committed += size;
    }
   else
    return (void *) -1;
  }
 return result;
}

#endif
#endif

d1292 1
a1292 1
    return malloc(size);
d1298 1
a1298 1
    return calloc(numitems,size);
d1304 1
a1304 1
    return realloc(block,size);
d1310 1
a1310 1
    free(block);
a1312 1

d1314 1
a1314 1
win32_open_osfhandle(long handle, int flags)
d1316 1
a1316 1
    return _open_osfhandle(handle, flags);
d1320 1
a1320 1
win32_get_osfhandle(int fd)
d1322 1
a1322 1
    return _get_osfhandle(fd);
d1329 10
d1356 1
a1356 1
    EXTEND(SP,1);
a1364 1
    STRLEN n_a;
d1367 1
a1367 1
    if (SetCurrentDirectory(SvPV(ST(0),n_a)))
d1400 2
a1401 2
    char *name = getlogin_buffer;
    DWORD size = sizeof(getlogin_buffer);
a1428 2
#ifndef HAS_NETWKSTAGETINFO
    /* mingw32 (and Win95) don't have NetWksta*(), so do it the old way */
d1437 1
a1437 1
	if (LookupAccountName(NULL, name, (PSID)&sid, &sidlen,
a1441 20
#else
    /* this way is more reliable, in case user has a local account.
     * XXX need dynamic binding of netapi32.dll symbols or this will fail on
     * Win95. Probably makes more sense to move it into libwin32. */
    char dname[256];
    DWORD dnamelen = sizeof(dname);
    PWKSTA_INFO_100 pwi;
    if (NERR_Success == NetWkstaGetInfo(NULL, 100, (LPBYTE*)&pwi)) {
	if (pwi->wki100_langroup && *(pwi->wki100_langroup)) {
	    WideCharToMultiByte(CP_ACP, NULL, pwi->wki100_langroup,
				-1, (LPSTR)dname, dnamelen, NULL, NULL);
	}
	else {
	    WideCharToMultiByte(CP_ACP, NULL, pwi->wki100_computername,
				-1, (LPSTR)dname, dnamelen, NULL, NULL);
	}
	NetApiBufferFree(pwi);
	XSRETURN_PV(dname);
    }
#endif
a1523 1
    STRLEN n_a;
d1525 1
a1525 1
    if (items != 3)
d1528 2
a1529 2
    cmd = SvPV(ST(0),n_a);
    args = SvPV(ST(1), n_a);
d1536 1
a1536 1
    if (CreateProcess(
d1569 1
a1569 1
    if (items != 1)
d1585 1
a1585 1
	ST(0) = &PL_sv_undef;
a1588 10
static
XS(w32_Sleep)
{
    dXSARGS;
    if (items != 1)
	croak("usage: Win32::Sleep($milliseconds)");
    Sleep(SvIV(ST(0)));
    XSRETURN_YES;
}

d1590 1
a1590 1
Perl_init_os_extras()
d1595 2
a1596 6
    w32_perlshell_tokens = Nullch;
    w32_perlshell_items = -1;
    w32_fdpid = newAV();		/* XXX needs to be in Perl_win32_init()? */
#ifndef USE_RTL_WAIT
    w32_num_children = 0;
#endif
a1613 1
    newXS("Win32::Sleep", w32_Sleep, file);
d1636 1
a1636 1
#if !defined(_ALPHA_) && !defined(__GNUC__)
a1638 24
    MALLOC_INIT;
}

#ifdef USE_BINMODE_SCRIPTS

void
win32_strip_return(SV *sv)
{
 char *s = SvPVX(sv);
 char *e = s+SvCUR(sv);
 char *d = s;
 while (s < e)
  {
   if (*s == '\r' && s[1] == '\n')
    {
     *d++ = '\n';
     s += 2;
    }
   else 
    {
     *d++ = *s++;
    }   
  }
 SvCUR_set(sv,d-SvPVX(sv)); 
a1639 2

#endif
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d18 12
a29 7
#ifndef __MINGW32__	/* GCC/Mingw32-2.95.2 forgot the WINAPI on CommandLineToArgvW() */
#  include <shellapi.h>
#else
   LPWSTR* WINAPI CommandLineToArgvW(LPCWSTR lpCommandLine, int * pNumArgs);
#endif
#include <winnt.h>
#include <io.h>
a37 1
#include <sys/stat.h>
d41 2
d44 3
a46 1
#define PERL_NO_GET_CONTEXT
d51 1
a72 14
#if defined(__MINGW32__)
/* Mingw32 is missing some prototypes */
FILE * _wfopen(LPCWSTR wszFileName, LPCWSTR wszMode);
FILE * _wfdopen(int nFd, LPCWSTR wszMode);
FILE * _freopen(LPCWSTR wszFileName, LPCWSTR wszMode, FILE * pOldStream);
int _flushall();
int _fcloseall();
#endif

#if defined(__BORLANDC__)
#  define _stat stat
#  define _utimbuf utimbuf
#endif

a76 13
#if defined(PERL_IMPLICIT_SYS)
#  undef win32_get_privlib
#  define win32_get_privlib g_win32_get_privlib
#  undef win32_get_sitelib
#  define win32_get_sitelib g_win32_get_sitelib
#  undef win32_get_vendorlib
#  define win32_get_vendorlib g_win32_get_vendorlib
#  undef do_spawn
#  define do_spawn g_do_spawn
#  undef getlogin
#  define getlogin g_getlogin
#endif

d78 12
a89 4
#  undef do_aspawn
#  define do_aspawn g_do_aspawn
#  undef Perl_do_exec
#  define Perl_do_exec g_do_exec
d92 1
d94 1
a94 1
static long		tokenize(const char *str, char **dest, char ***destv);
d99 2
a100 11
static char *		get_emd_part(SV **leading, char *trailing, ...);
static void		remove_dead_process(long deceased);
static long		find_pid(int pid);
static char *		qualified_path(const char *cmd);
static char *		win32_get_xlib(const char *pl, const char *xlib,
				       const char *libname);

#ifdef USE_ITHREADS
static void		remove_dead_pseudo_process(long child);
static long		find_pseudo_pid(int pid);
#endif
a101 1
START_EXTERN_C
a102 3
char	w32_module_name[MAX_PATH+1];
END_EXTERN_C

d105 22
a126 1
#define ONE_K_BUFSIZE	1024
d129 2
a130 3
IsWin95(void)
{
    return (win32_os_id() == VER_PLATFORM_WIN32_WINDOWS);
d134 2
a135 3
IsWinNT(void)
{
    return (win32_os_id() == VER_PLATFORM_WIN32_NT);
d138 3
a140 29
EXTERN_C void
set_w32_module_name(void)
{
    char* ptr;
    GetModuleFileName((HMODULE)((w32_perldll_handle == INVALID_HANDLE_VALUE)
				? GetModuleHandle(NULL)
				: w32_perldll_handle),
		      w32_module_name, sizeof(w32_module_name));

    /* try to get full path to binary (which may be mangled when perl is
     * run from a 16-bit app) */
    /*PerlIO_printf(Perl_debug_log, "Before %s\n", w32_module_name);*/
    (void)win32_longpath(w32_module_name);
    /*PerlIO_printf(Perl_debug_log, "After  %s\n", w32_module_name);*/

    /* normalize to forward slashes */
    ptr = w32_module_name;
    while (*ptr) {
	if (*ptr == '\\')
	    *ptr = '/';
	++ptr;
    }
}

/* *svp (if non-NULL) is expected to be POK (valid allocated SvPVX(*svp)) */
static char*
get_regstr_from(HKEY hkey, const char *valuename, SV **svp)
{
    /* Retrieve a REG_SZ or REG_EXPAND_SZ from the registry */
a143 1
    char *str = Nullch;
d147 2
a148 3
    if (retval == ERROR_SUCCESS) {
	DWORD datalen;
	retval = RegQueryValueEx(handle, valuename, 0, &type, NULL, &datalen);
d150 10
a159 9
	    dTHXo;
	    if (!*svp)
		*svp = sv_2mortal(newSVpvn("",0));
	    SvGROW(*svp, datalen);
	    retval = RegQueryValueEx(handle, valuename, 0, NULL,
				     (PBYTE)SvPVX(*svp), &datalen);
	    if (retval == ERROR_SUCCESS) {
		str = SvPVX(*svp);
		SvCUR_set(*svp,datalen-1);
d164 1
a164 1
    return str;
d167 2
a168 3
/* *svp (if non-NULL) is expected to be POK (valid allocated SvPVX(*svp)) */
static char*
get_regstr(const char *valuename, SV **svp)
d170 6
a175 4
    char *str = get_regstr_from(HKEY_CURRENT_USER, valuename, svp);
    if (!str)
	str = get_regstr_from(HKEY_LOCAL_MACHINE, valuename, svp);
    return str;
a177 1
/* *prev_pathp (if non-NULL) is expected to be POK (valid allocated SvPVX(sv)) */
d179 1
a179 1
get_emd_part(SV **prev_pathp, char *trailing_path, ...)
a187 1
    STRLEN baselen;
d192 1
a192 2
    sprintf(base, "%d.%d", (int)PERL_REVISION, (int)PERL_VERSION);
    baselen = strlen(base);
d194 4
a197 5
    if (!*w32_module_name) {
	set_w32_module_name();
    }
    strcpy(mod_name, w32_module_name);
    ptr = strrchr(mod_name, '/');
d202 1
a202 3
	ptr = strrchr(mod_name, '/');
	/* avoid stripping component if there is no slash,
	 * or it doesn't match ... */
d204 3
a206 6
	    /* ... but not if component matches m|5\.$patchlevel.*| */
	    if (!ptr || !(*strip == '5' && *(ptr+1) == '5'
			  && strncmp(strip, base, baselen) == 0
			  && strncmp(ptr+1, base, baselen) == 0))
	    {
		*optr = '/';
d215 1
a215 1
	*ptr = '/';
d221 1
a221 1
    if (GetFileAttributes(mod_name) != (DWORD) -1) {
d223 12
a234 6
	dTHXo;
	if (!*prev_pathp)
	    *prev_pathp = sv_2mortal(newSVpvn("",0));
	sv_catpvn(*prev_pathp, ";", 1);
	sv_catpv(*prev_pathp, mod_name);
	return SvPVX(*prev_pathp);
d237 1
a237 1
    return Nullch;
d241 1
a241 1
win32_get_privlib(const char *pl)
a242 1
    dTHXo;
d245 2
a246 1
    SV *sv = Nullsv;
d250 3
a252 2
    if (!get_regstr(buffer, &sv))
	(void)get_regstr(stdlib, &sv);
d255 1
a255 1
    return get_emd_part(&sv, stdlib, ARCHNAME, "bin", Nullch);
d258 2
a259 2
static char *
win32_get_xlib(const char *pl, const char *xlib, const char *libname)
d261 1
a261 1
    dTHXo;
d265 2
a267 2
    SV *sv1 = Nullsv;
    SV *sv2 = Nullsv;
d269 3
a271 16
    /* $HKCU{"$xlib-$]"} || $HKLM{"$xlib-$]"} . ---; */
    sprintf(regstr, "%s-%s", xlib, pl);
    (void)get_regstr(regstr, &sv1);

    /* $xlib .=
     * ";$EMD/" . ((-d $EMD/../../../$]) ? "../../.." : "../.."). "/$libname/$]/lib";  */
    sprintf(pathstr, "%s/%s/lib", libname, pl);
    (void)get_emd_part(&sv1, pathstr, ARCHNAME, "bin", pl, Nullch);

    /* $HKCU{$xlib} || $HKLM{$xlib} . ---; */
    (void)get_regstr(xlib, &sv2);

    /* $xlib .=
     * ";$EMD/" . ((-d $EMD/../../../$]) ? "../../.." : "../.."). "/$libname/lib";  */
    sprintf(pathstr, "%s/lib", libname);
    (void)get_emd_part(&sv2, pathstr, ARCHNAME, "bin", pl, Nullch);
d273 11
a283 6
    if (!sv1 && !sv2)
	return Nullch;
    if (!sv1)
	return SvPVX(sv2);
    if (!sv2)
	return SvPVX(sv1);
d285 2
a286 2
    sv_catpvn(sv1, ";", 1);
    sv_catsv(sv1, sv2);
d288 2
a289 2
    return SvPVX(sv1);
}
d291 2
a292 5
char *
win32_get_sitelib(const char *pl)
{
    return win32_get_xlib(pl, "sitelib", "site");
}
d294 3
a296 3
#ifndef PERL_VENDORLIB_NAME
#  define PERL_VENDORLIB_NAME	"vendor"
#endif
d298 2
a299 4
char *
win32_get_vendorlib(const char *pl)
{
    return win32_get_xlib(pl, "vendorlib", PERL_VENDORLIB_NAME);
d302 1
d344 1
a344 1
#if !defined(PERL_IMPLICIT_SYS)
d349 1
a349 1
Perl_my_popen(pTHX_ char *cmd, char *mode)
d352 11
a362 11
#define fixcmd(x)   {					\
			char *pspace = strchr((x),' ');	\
			if (pspace) {			\
			    char *p = (x);		\
			    while (p < pspace) {	\
				if (*p == '/')		\
				    *p = '\\';		\
				p++;			\
			    }				\
			}				\
		    }
d367 2
a368 1
    PERL_FLUSHALL_FOR_CHILD;
d373 1
a373 1
Perl_my_pclose(pTHX_ PerlIO *fp)
d379 2
a380 2
DllExport unsigned long
win32_os_id(void)
d390 1
a390 12
    return (unsigned long)w32_platform;
}

DllExport int
win32_getpid(void)
{
#ifdef USE_ITHREADS
    dTHXo;
    if (w32_pseudo_id)
	return -((int)w32_pseudo_id);
#endif
    return _getpid();
d400 1
a400 1
tokenize(const char *str, char **dest, char ***destv)
a405 1
	dTHXo;
a447 1
    dTHXo;
d456 2
a457 3
	const char* defaultshell = (IsWinNT()
				    ? "cmd.exe /x/c" : "command.com /c");
	const char *usershell = getenv("PERL5SHELL");
a466 1
    dTHXo;
d475 1
d489 1
a489 1
	if (*mark && (str = SvPV_nolen(*mark)))
d497 1
a497 1
			   (const char*)(really ? SvPV_nolen(really) : argv[0]),
d510 1
a510 1
			       (const char*)(really ? SvPV_nolen(really) : argv[0]),
d516 2
a517 3
    	    dTHR;
	    if (ckWARN(WARN_EXEC))
		Perl_warner(aTHX_ WARN_EXEC, "Can't spawn \"%s\": %s", argv[0], strerror(errno));
a530 1
    dTHXo;
d546 1
a546 1
	    while (*s && isSPACE(*s))
d550 1
a550 1
	    while (*s && !isSPACE(*s))
d603 2
a604 3
    	    dTHR;
	    if (ckWARN(WARN_EXEC))
		Perl_warner(aTHX_ WARN_EXEC, "Can't %s \"%s\": %s",
d629 1
a629 1
Perl_do_exec(pTHX_ char *cmd)
d639 1
a639 1
DllExport DIR *
d642 1
a642 2
    dTHXo;
    DIR			*dirp;
d647 1
a647 2
    WIN32_FIND_DATAA	aFindData;
    WIN32_FIND_DATAW	wFindData;
a648 3
    char		buffer[MAX_PATH*2];
    WCHAR		wbuffer[MAX_PATH+1];
    char*		ptr;
d659 3
a661 1
    Newz(1303, dirp, 1, DIR);
d665 1
a665 7

    /* bare drive name means look in cwd for drive */
    if (len == 2 && isALPHA(scanname[0]) && scanname[1] == ':') {
	scanname[len++] = '.';
	scanname[len++] = '/';
    }
    else if (scanname[len-1] != '/' && scanname[len-1] != '\\') {
a666 1
    }
d671 1
a671 8
    if (USING_WIDE()) {
	A2WHELPER(scanname, wbuffer, sizeof(wbuffer));
	fh = FindFirstFileW(PerlDir_mapW(wbuffer), &wFindData);
    }
    else {
	fh = FindFirstFileA(PerlDir_mapA(scanname), &aFindData);
    }
    dirp->handle = fh;
a672 1
	DWORD err = GetLastError();
d674 3
a676 15
	switch (err) {
	case ERROR_FILE_NOT_FOUND:
	    return dirp;
	case ERROR_NO_MORE_FILES:
	case ERROR_PATH_NOT_FOUND:
	    errno = ENOENT;
	    break;
	case ERROR_NOT_ENOUGH_MEMORY:
	    errno = ENOMEM;
	    break;
	default:
	    errno = EINVAL;
	    break;
	}
	Safefree(dirp);
d683 28
a710 18
    if (USING_WIDE()) {
	W2AHELPER(wFindData.cFileName, buffer, sizeof(buffer));
	ptr = buffer;
    }
    else {
	ptr = aFindData.cFileName;
    }
    idx = strlen(ptr)+1;
    if (idx < 256)
	dirp->size = 128;
    else
	dirp->size = idx;
    New(1304, dirp->start, dirp->size, char);
    strcpy(dirp->start, ptr);
    dirp->nfiles++;
    dirp->end = dirp->curr = dirp->start;
    dirp->end += idx;
    return dirp;
d717 1
a717 1
DllExport struct direct *
d720 2
a721 1
    long         len;
d730 1
a730 1
	dirp->dirstr.d_ino = dirp->curr - dirp->start;
d732 1
a732 1
	/* Now set up for the next call to readdir */
d734 3
a736 7
	if (dirp->curr >= dirp->end) {
	    dTHXo;
	    char*		ptr;
	    BOOL		res;
	    WIN32_FIND_DATAW	wFindData;
	    WIN32_FIND_DATAA	aFindData;
	    char		buffer[MAX_PATH*2];
a737 33
	    /* finding the next file that matches the wildcard
	     * (which should be all of them in this directory!).
	     */
	    if (USING_WIDE()) {
		res = FindNextFileW(dirp->handle, &wFindData);
		if (res) {
		    W2AHELPER(wFindData.cFileName, buffer, sizeof(buffer));
		    ptr = buffer;
		}
	    }
	    else {
		res = FindNextFileA(dirp->handle, &aFindData);
		if (res)
		    ptr = aFindData.cFileName;
	    }
	    if (res) {
		long endpos = dirp->end - dirp->start;
		long newsize = endpos + strlen(ptr) + 1;
		/* bump the string table size by enough for the
		 * new name and it's null terminator */
		while (newsize > dirp->size) {
		    long curpos = dirp->curr - dirp->start;
		    dirp->size *= 2;
		    Renew(dirp->start, dirp->size, char);
		    dirp->curr = dirp->start + curpos;
		}
		strcpy(dirp->start + endpos, ptr);
		dirp->end = dirp->start + newsize;
		dirp->nfiles++;
	    }
	    else
		dirp->curr = NULL;
	}
d745 1
a745 1
DllExport long
d748 1
a748 1
    return (dirp->curr - dirp->start);
d753 1
a753 1
 * (returned by telldir).
d755 1
a755 1
DllExport void
d758 1
a758 1
    dirp->curr = dirp->start + loc;
d762 1
a762 1
DllExport void
d769 1
a769 1
DllExport int
a771 3
    dTHXo;
    if (dirp->handle != INVALID_HANDLE_VALUE)
	FindClose(dirp->handle);
d831 3
a833 3
    dTHXo;
    char *buf = w32_getlogin_buffer;
    DWORD size = sizeof(w32_getlogin_buffer);
a845 12
static long
find_pid(int pid)
{
    dTHXo;
    long child = w32_num_children;
    while (--child >= 0) {
	if (w32_child_pids[child] == pid)
	    return child;
    }
    return -1;
}

d847 1
a847 1
remove_dead_process(long child)
d849 9
a857 8
    if (child >= 0) {
	dTHXo;
	CloseHandle(w32_child_handles[child]);
	Move(&w32_child_handles[child+1], &w32_child_handles[child],
	     (w32_num_children-child-1), HANDLE);
	Move(&w32_child_pids[child+1], &w32_child_pids[child],
	     (w32_num_children-child-1), DWORD);
	w32_num_children--;
d859 1
d862 2
a863 3
#ifdef USE_ITHREADS
static long
find_pseudo_pid(int pid)
d865 4
a868 22
    dTHXo;
    long child = w32_num_pseudo_children;
    while (--child >= 0) {
	if (w32_pseudo_child_pids[child] == pid)
	    return child;
    }
    return -1;
}

static void
remove_dead_pseudo_process(long child)
{
    if (child >= 0) {
	dTHXo;
	CloseHandle(w32_pseudo_child_handles[child]);
	Move(&w32_pseudo_child_handles[child+1], &w32_pseudo_child_handles[child],
	     (w32_num_pseudo_children-child-1), HANDLE);
	Move(&w32_pseudo_child_pids[child+1], &w32_pseudo_child_pids[child],
	     (w32_num_pseudo_children-child-1), DWORD);
	w32_num_pseudo_children--;
    }
}
d871 2
a872 18
DllExport int
win32_kill(int pid, int sig)
{
    dTHXo;
    HANDLE hProcess;
#ifdef USE_ITHREADS
    if (pid < 0) {
	/* it is a pseudo-forked child */
	long child = find_pseudo_pid(-pid);
	if (child >= 0) {
	    if (!sig)
		return 0;
	    hProcess = w32_pseudo_child_handles[child];
	    if (TerminateThread(hProcess, sig)) {
		remove_dead_pseudo_process(child);
		return 0;
	    }
	}
d874 8
a881 24
    else
#endif
    {
	long child = find_pid(pid);
	if (child >= 0) {
	    if (!sig)
		return 0;
	    hProcess = w32_child_handles[child];
	    if (TerminateProcess(hProcess, sig)) {
		remove_dead_process(child);
		return 0;
	    }
	}
	else {
	    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pid);
	    if (hProcess) {
		if (!sig)
		    return 0;
		if (TerminateProcess(hProcess, sig)) {
		    CloseHandle(hProcess);
		    return 0;
		}
	    }
	}
d883 1
a883 2
    errno = EINVAL;
    return -1;
d898 1
a898 1
win32_stat(const char *path, struct stat *sbuf)
d900 2
a901 2
    dTHXo;
    char	buffer[MAX_PATH+1]; 
a903 4
    WCHAR	wbuffer[MAX_PATH+1];
    WCHAR*	pwbuffer;
    HANDLE      handle;
    int         nlink = 1;
a906 2
	/* FindFirstFile() and stat() are buggy with a trailing
	 * backslash, so change it to a forward slash :-( */
d908 6
a913 16
	    strncpy(buffer, path, l-1);
	    buffer[l - 1] = '/';
	    buffer[l] = '\0';
	    path = buffer;
	    break;
	/* FindFirstFile() is buggy with "x:", so add a dot :-( */
	case ':':
	    if (l == 2 && isALPHA(path[0])) {
		buffer[0] = path[0];
		buffer[1] = ':';
		buffer[2] = '.';
		buffer[3] = '\0';
		l = 3;
		path = buffer;
	    }
	    break;
d916 1
a916 30

    /* We *must* open & close the file once; otherwise file attribute changes */
    /* might not yet have propagated to "other" hard links of the same file.  */
    /* This also gives us an opportunity to determine the number of links.    */
    if (USING_WIDE()) {
	A2WHELPER(path, wbuffer, sizeof(wbuffer));
	pwbuffer = PerlDir_mapW(wbuffer);
	handle = CreateFileW(pwbuffer, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
    }
    else {
	path = PerlDir_mapA(path);
	l = strlen(path);
	handle = CreateFileA(path, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
    }
    if (handle != INVALID_HANDLE_VALUE) {
	BY_HANDLE_FILE_INFORMATION bhi;
	if (GetFileInformationByHandle(handle, &bhi))
	    nlink = bhi.nNumberOfLinks;
	CloseHandle(handle);
    }

    /* pwbuffer or path will be mapped correctly above */
    if (USING_WIDE()) {
	res = _wstat(pwbuffer, (struct _stat *)sbuf);
    }
    else {
	res = stat(path, sbuf);
    }
    sbuf->st_nlink = nlink;

d920 1
a920 1
	 * sbuf->st_*time (but note that's not available on the
d922 1
a922 7
	DWORD r;
	if (USING_WIDE()) {
	    r = GetFileAttributesW(pwbuffer);
	}
	else {
	    r = GetFileAttributesA(path);
	}
d924 1
a924 3
	    /* sbuf may still contain old garbage since stat() failed */
	    Zero(sbuf, 1, struct stat);
	    sbuf->st_mode = S_IFDIR | S_IREAD;
d927 1
a927 1
		sbuf->st_mode |= S_IWRITE | S_IEXEC;
d932 2
a933 2
	if (l == 3 && isALPHA(path[0]) && path[1] == ':'
	    && (path[2] == '\\' || path[2] == '/'))
d936 1
a936 3
	    if (USING_WIDE()
		? !GetVolumeInformationW(pwbuffer,NULL,0,NULL,NULL,NULL,NULL,0)
		: !GetVolumeInformationA(path,NULL,0,NULL,NULL,NULL,NULL,0)) {
d942 3
a944 4
	if (S_ISDIR(sbuf->st_mode))
	    sbuf->st_mode |= S_IWRITE | S_IEXEC;
	else if (S_ISREG(sbuf->st_mode)) {
	    int perms;
d951 1
a951 1
		    sbuf->st_mode &= ~S_IEXEC;
d953 1
a953 1
		    sbuf->st_mode |= S_IEXEC;
d956 1
a956 4
		sbuf->st_mode &= ~S_IEXEC;
	    /* Propagate permissions to _group_ and _others_ */
	    perms = sbuf->st_mode & (S_IREAD|S_IWRITE|S_IEXEC);
	    sbuf->st_mode |= (perms>>3) | (perms>>6);
a962 77
/* Find the longname of a given path.  path is destructively modified.
 * It should have space for at least MAX_PATH characters. */
DllExport char *
win32_longpath(char *path)
{
    WIN32_FIND_DATA fdata;
    HANDLE fhand;
    char tmpbuf[MAX_PATH+1];
    char *tmpstart = tmpbuf;
    char *start = path;
    char sep;
    if (!path)
	return Nullch;

    /* drive prefix */
    if (isALPHA(path[0]) && path[1] == ':' &&
	(path[2] == '/' || path[2] == '\\'))
    {
	start = path + 2;
	*tmpstart++ = path[0];
	*tmpstart++ = ':';
    }
    /* UNC prefix */
    else if ((path[0] == '/' || path[0] == '\\') &&
	     (path[1] == '/' || path[1] == '\\'))
    {
	start = path + 2;
	*tmpstart++ = path[0];
	*tmpstart++ = path[1];
	/* copy machine name */
	while (*start && *start != '/' && *start != '\\')
	    *tmpstart++ = *start++;
	if (*start) {
	    *tmpstart++ = *start;
	    start++;
	    /* copy share name */
	    while (*start && *start != '/' && *start != '\\')
		*tmpstart++ = *start++;
	}
    }
    sep = *start++;
    if (sep == '/' || sep == '\\')
	*tmpstart++ = sep;
    *tmpstart = '\0';
    while (sep) {
	/* walk up to slash */
	while (*start && *start != '/' && *start != '\\')
	    ++start;

	/* discard doubled slashes */
	while (*start && (start[1] == '/' || start[1] == '\\'))
	    ++start;
	sep = *start;

	/* stop and find full name of component */
	*start = '\0';
	fhand = FindFirstFile(path,&fdata);
	if (fhand != INVALID_HANDLE_VALUE) {
	    strcpy(tmpstart, fdata.cFileName);
	    tmpstart += strlen(fdata.cFileName);
	    if (sep)
		*tmpstart++ = sep;
	    *tmpstart = '\0';
	    *start++ = sep;
	    FindClose(fhand);
	}
	else {
	    /* failed a step, just return without side effects */
	    /*PerlIO_printf(Perl_debug_log, "Failed to find %s\n", path);*/
	    *start = sep;
	    return Nullch;
	}
    }
    strcpy(path,tmpbuf);
    return path;
}

d968 2
a969 2
    dTHXo;
    WCHAR wBuffer[MAX_PATH+1];
d971 4
a974 1
    SV *curitem = Nullsv;
d976 1
a976 6
    if (USING_WIDE()) {
	A2WHELPER(name, wBuffer, sizeof(wBuffer));
	needlen = GetEnvironmentVariableW(wBuffer, NULL, 0);
    }
    else
	needlen = GetEnvironmentVariableA(name,NULL,0);
d978 4
a981 20
	curitem = sv_2mortal(newSVpvn("", 0));
	if (USING_WIDE()) {
	    SV *acuritem;
	    do {
		SvGROW(curitem, (needlen+1)*sizeof(WCHAR));
		needlen = GetEnvironmentVariableW(wBuffer,
						  (WCHAR*)SvPVX(curitem),
						  needlen);
	    } while (needlen >= SvLEN(curitem)/sizeof(WCHAR));
	    SvCUR_set(curitem, (needlen*sizeof(WCHAR))+1);
	    acuritem = sv_2mortal(newSVsv(curitem));
	    W2AHELPER((WCHAR*)SvPVX(acuritem), SvPVX(curitem), SvCUR(curitem));
	}
	else {
	    do {
		SvGROW(curitem, needlen+1);
		needlen = GetEnvironmentVariableA(name,SvPVX(curitem),
						  needlen);
	    } while (needlen >= SvLEN(curitem));
	    SvCUR_set(curitem, needlen);
d987 11
a997 2
	if (strncmp(name, "PERL", 4) == 0)
	    (void)get_regstr(name, &curitem);
d999 2
a1000 2
    if (curitem && SvCUR(curitem))
	return SvPVX(curitem);
d1002 1
a1002 1
    return Nullch;
a1007 1
    dTHXo;
d1010 23
a1032 41
    WCHAR* wCuritem;
    WCHAR* wVal;
    int length, relval = -1;

    if (name) {
	if (USING_WIDE()) {
	    length = strlen(name)+1;
	    New(1309,wCuritem,length,WCHAR);
	    A2WHELPER(name, wCuritem, length*sizeof(WCHAR));
	    wVal = wcschr(wCuritem, '=');
	    if (wVal) {
		*wVal++ = '\0';
		if (SetEnvironmentVariableW(wCuritem, *wVal ? wVal : NULL))
		    relval = 0;
	    }
	    Safefree(wCuritem);
	}
	else {
	    New(1309,curitem,strlen(name)+1,char);
	    strcpy(curitem, name);
	    val = strchr(curitem, '=');
	    if (val) {
		/* The sane way to deal with the environment.
		 * Has these advantages over putenv() & co.:
		 *  * enables us to store a truly empty value in the
		 *    environment (like in UNIX).
		 *  * we don't have to deal with RTL globals, bugs and leaks.
		 *  * Much faster.
		 * Why you may want to enable USE_WIN32_RTL_ENV:
		 *  * environ[] and RTL functions will not reflect changes,
		 *    which might be an issue if extensions want to access
		 *    the env. via RTL.  This cuts both ways, since RTL will
		 *    not see changes made by extensions that call the Win32
		 *    functions directly, either.
		 * GSAR 97-06-07
		 */
		*val++ = '\0';
		if (SetEnvironmentVariableA(curitem, *val ? val : NULL))
		    relval = 0;
	    }
	    Safefree(curitem);
d1034 1
d1044 5
a1048 5
    __int64 qw = ft->dwHighDateTime;
    qw <<= 32;
    qw |= ft->dwLowDateTime;
    qw /= 10000;  /* File time ticks at 0.1uS, clock at 1mS */
    return (long) qw;
d1075 3
a1077 1
/* fix utime() so it works on directories in NT */
d1081 1
a1081 1
    struct tm *pTM = localtime(&Time);
a1082 1
    FILETIME LocalTime;
d1095 1
a1095 47
    return SystemTimeToFileTime(&SystemTime, &LocalTime) &&
           LocalFileTimeToFileTime(&LocalTime, pFileTime);
}

DllExport int
win32_unlink(const char *filename)
{
    dTHXo;
    int ret;
    DWORD attrs;

    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	WCHAR* pwBuffer;

	A2WHELPER(filename, wBuffer, sizeof(wBuffer));
	pwBuffer = PerlDir_mapW(wBuffer);
	attrs = GetFileAttributesW(pwBuffer);
	if (attrs == 0xFFFFFFFF)
	    goto fail;
	if (attrs & FILE_ATTRIBUTE_READONLY) {
	    (void)SetFileAttributesW(pwBuffer, attrs & ~FILE_ATTRIBUTE_READONLY);
	    ret = _wunlink(pwBuffer);
	    if (ret == -1)
		(void)SetFileAttributesW(pwBuffer, attrs);
	}
	else
	    ret = _wunlink(pwBuffer);
    }
    else {
	filename = PerlDir_mapA(filename);
	attrs = GetFileAttributesA(filename);
	if (attrs == 0xFFFFFFFF)
	    goto fail;
	if (attrs & FILE_ATTRIBUTE_READONLY) {
	    (void)SetFileAttributesA(filename, attrs & ~FILE_ATTRIBUTE_READONLY);
	    ret = unlink(filename);
	    if (ret == -1)
		(void)SetFileAttributesA(filename, attrs);
	}
	else
	    ret = unlink(filename);
    }
    return ret;
fail:
    errno = ENOENT;
    return -1;
a1100 1
    dTHXo;
a1105 2
    WCHAR wbuffer[MAX_PATH+1];
    WCHAR* pwbuffer;
d1107 1
a1107 10
    int rc;
    if (USING_WIDE()) {
	A2WHELPER(filename, wbuffer, sizeof(wbuffer));
	pwbuffer = PerlDir_mapW(wbuffer);
	rc = _wutime(pwbuffer, (struct _utimbuf*)times);
    }
    else {
	filename = PerlDir_mapA(filename);
	rc = utime(filename, times);
    }
d1119 3
a1121 10
    if (USING_WIDE()) {
	handle = CreateFileW(pwbuffer, GENERIC_READ | GENERIC_WRITE,
			    FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
			    OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    }
    else {
	handle = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE,
			    FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
			    OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    }
a1137 90
win32_uname(struct utsname *name)
{
    struct hostent *hep;
    STRLEN nodemax = sizeof(name->nodename)-1;
    OSVERSIONINFO osver;

    memset(&osver, 0, sizeof(OSVERSIONINFO));
    osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (GetVersionEx(&osver)) {
	/* sysname */
	switch (osver.dwPlatformId) {
	case VER_PLATFORM_WIN32_WINDOWS:
	    strcpy(name->sysname, "Windows");
	    break;
	case VER_PLATFORM_WIN32_NT:
	    strcpy(name->sysname, "Windows NT");
	    break;
	case VER_PLATFORM_WIN32s:
	    strcpy(name->sysname, "Win32s");
	    break;
	default:
	    strcpy(name->sysname, "Win32 Unknown");
	    break;
	}

	/* release */
	sprintf(name->release, "%d.%d",
		osver.dwMajorVersion, osver.dwMinorVersion);

	/* version */
	sprintf(name->version, "Build %d",
		osver.dwPlatformId == VER_PLATFORM_WIN32_NT
		? osver.dwBuildNumber : (osver.dwBuildNumber & 0xffff));
	if (osver.szCSDVersion[0]) {
	    char *buf = name->version + strlen(name->version);
	    sprintf(buf, " (%s)", osver.szCSDVersion);
	}
    }
    else {
	*name->sysname = '\0';
	*name->version = '\0';
	*name->release = '\0';
    }

    /* nodename */
    hep = win32_gethostbyname("localhost");
    if (hep) {
	STRLEN len = strlen(hep->h_name);
	if (len <= nodemax) {
	    strcpy(name->nodename, hep->h_name);
	}
	else {
	    strncpy(name->nodename, hep->h_name, nodemax);
	    name->nodename[nodemax] = '\0';
	}
    }
    else {
	DWORD sz = nodemax;
	if (!GetComputerName(name->nodename, &sz))
	    *name->nodename = '\0';
    }

    /* machine (architecture) */
    {
	SYSTEM_INFO info;
	char *arch;
	GetSystemInfo(&info);

#if defined(__BORLANDC__) || defined(__MINGW32__)
	switch (info.u.s.wProcessorArchitecture) {
#else
	switch (info.wProcessorArchitecture) {
#endif
	case PROCESSOR_ARCHITECTURE_INTEL:
	    arch = "x86"; break;
	case PROCESSOR_ARCHITECTURE_MIPS:
	    arch = "mips"; break;
	case PROCESSOR_ARCHITECTURE_ALPHA:
	    arch = "alpha"; break;
	case PROCESSOR_ARCHITECTURE_PPC:
	    arch = "ppc"; break;
	default:
	    arch = "unknown"; break;
	}
	strcpy(name->machine, arch);
    }
    return 0;
}

DllExport int
d1140 3
a1142 23
    dTHXo;
    int retval = -1;
    if (pid == -1)				/* XXX threadid == 1 ? */
	return win32_wait(status);
#ifdef USE_ITHREADS
    else if (pid < 0) {
	long child = find_pseudo_pid(-pid);
	if (child >= 0) {
	    HANDLE hThread = w32_pseudo_child_handles[child];
	    DWORD waitcode = WaitForSingleObject(hThread, INFINITE);
	    if (waitcode != WAIT_FAILED) {
		if (GetExitCodeThread(hThread, &waitcode)) {
		    *status = (int)((waitcode & 0xff) << 8);
		    retval = (int)w32_pseudo_child_pids[child];
		    remove_dead_pseudo_process(child);
		    return retval;
		}
	    }
	    else
		errno = ECHILD;
	}
    }
#endif
d1144 2
a1145 18
	long child = find_pid(pid);
	if (child >= 0) {
	    HANDLE hProcess = w32_child_handles[child];
	    DWORD waitcode = WaitForSingleObject(hProcess, INFINITE);
	    if (waitcode != WAIT_FAILED) {
		if (GetExitCodeProcess(hProcess, &waitcode)) {
		    *status = (int)((waitcode & 0xff) << 8);
		    retval = (int)w32_child_pids[child];
		    remove_dead_process(child);
		    return retval;
		}
	    }
	    else
		errno = ECHILD;
	}
	else {
	    retval = cwait(status, pid, WAIT_CHILD);
	    /* cwait() returns "correctly" on Borland */
d1147 2
a1148 2
	    if (status)
		*status *= 256;
d1150 1
a1150 1
	}
d1152 1
a1152 1
    return retval >= 0 ? pid : retval;                
d1158 3
a1163 1
    dTHXo;
d1167 3
a1169 25
#ifdef USE_ITHREADS
    if (w32_num_pseudo_children) {
	waitcode = WaitForMultipleObjects(w32_num_pseudo_children,
					  w32_pseudo_child_handles,
					  FALSE,
					  INFINITE);
	if (waitcode != WAIT_FAILED) {
	    if (waitcode >= WAIT_ABANDONED_0
		&& waitcode < WAIT_ABANDONED_0 + w32_num_pseudo_children)
		i = waitcode - WAIT_ABANDONED_0;
	    else
		i = waitcode - WAIT_OBJECT_0;
	    if (GetExitCodeThread(w32_pseudo_child_handles[i], &exitcode)) {
		*status = (int)((exitcode & 0xff) << 8);
		retval = (int)w32_pseudo_child_pids[i];
		remove_dead_pseudo_process(i);
		return retval;
	    }
	}
    }
#endif

    if (!w32_num_children) {
	errno = ECHILD;
	return -1;
d1174 1
a1174 1
				      w32_child_handles,
d1183 2
a1184 1
	if (GetExitCodeProcess(w32_child_handles[i], &exitcode) ) {
d1187 3
a1189 1
	    remove_dead_process(i);
d1197 2
a1200 2
#ifndef PERL_OBJECT

d1205 3
a1207 4
    dTHXo;
    KillTimer(NULL,timerid);
    timerid=0;  
    sighandler(14);
a1208 1
#endif	/* !PERL_OBJECT */
a1212 1
#ifndef PERL_OBJECT
a1221 1
    dTHXo;
d1226 1
a1226 1
       Perl_croak_nocontext("Cannot set timer");
a1235 1
#endif	/* !PERL_OBJECT */
d1239 1
a1246 1
    dTHXo;
d1249 1
a1249 1
    return des_fcrypt(txt, salt, w32_crypt_buffer);
d1251 1
a1251 1
    Perl_croak(aTHX_ "The crypt() function is unimplemented due to excessive paranoia.");
d1255 1
d1257 1
a1257 3
/* C doesn't like repeat struct definitions */

#if defined(USE_FIXED_OSFHANDLE) || defined(PERL_MSVCRT_READFIX)
d1259 5
a1263 3
#ifndef _CRTIMP
#define _CRTIMP __declspec(dllimport)
#endif
d1265 2
a1266 4
/*
 * Control structure for lowio file handles
 */
typedef struct {
d1270 1
d1273 2
a1274 7
} ioinfo;


/*
 * Array of arrays of control structures for lowio files.
 */
EXTERN_C _CRTIMP ioinfo* __pioinfo[];
d1276 1
a1276 5
/*
 * Definition of IOINFO_L2E, the log base 2 of the number of elements in each
 * array of ioinfo structs.
 */
#define IOINFO_L2E	    5
d1278 8
a1285 17
/*
 * Definition of IOINFO_ARRAY_ELTS, the number of elements in ioinfo array
 */
#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)

/*
 * Access macros for getting at an ioinfo struct and its fields from a
 * file handle
 */
#define _pioinfo(i) (__pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - 1)))
#define _osfhnd(i)  (_pioinfo(i)->osfhnd)
#define _osfile(i)  (_pioinfo(i)->osfile)
#define _pipech(i)  (_pioinfo(i)->pipech)

#endif

#ifdef USE_FIXED_OSFHANDLE
a1287 1
#define FNOINHERIT		0x10	/* file handle opened O_NOINHERIT */
d1292 4
d1302 2
a1303 4
*	temperary fix for WIN95's brain damage GetFileType() error on socket
*	we just bypass that call for socket
*
*	This works with MSVC++ 4.0+ or GCC/Mingw32
a1316 25
/*
 * we fake up some parts of the CRT that aren't exported by MSVCRT.dll
 * this lets sockets work on Win9X with GCC and should fix the problems
 * with perl95.exe
 *	-- BKS, 1-23-2000
*/

/* since we are not doing a dup2(), this works fine */

#define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = osfh)

/* create an ioinfo entry, kill its handle, and steal the entry */

static int
_alloc_osfhnd(void)
{
    HANDLE hF = CreateFile("NUL", 0, 0, NULL, OPEN_ALWAYS, 0, NULL);
    int fh = _open_osfhandle((long)hF, 0);
    CloseHandle(hF);
    if (fh == -1)
        return fh;
    EnterCriticalSection(&(_pioinfo(fh)->lock));
    return fh;
}

a1331 3
    if (flags & O_NOINHERIT)
	fileflags |= FNOINHERIT;

d1344 1
d1346 5
a1350 1
    LeaveCriticalSection(&_pioinfo(fh)->lock);
d1355 1
d1371 1
a1371 2
	dTHXo;
	Perl_croak_nocontext("flock() unimplemented on this platform");
d1469 1
a1469 1
        dTHXo;
d1474 2
a1475 3
			  w32_strerror_buffer,
			  sizeof(w32_strerror_buffer), NULL) == 0) 
	    strcpy(w32_strerror_buffer, "Unknown Error");
d1477 1
a1477 1
	return w32_strerror_buffer;
a1490 1
    /* strip trailing whitespace and period */
d1492 2
a1493 3
	do {
	    --dwLen;	/* dwLen doesn't include trailing null */
	} while (0 < dwLen && isSPACE(sMsg[dwLen]));
d1496 1
a1496 1
	sMsg[dwLen] = '\0';
d1500 3
a1502 9
	if (sMsg)
	    dwLen = sprintf(sMsg,
			    "Unknown error #0x%lX (lookup 0x%lX)",
			    dwErr, GetLastError());
    }
    if (sMsg) {
	dTHXo;
	sv_setpvn((SV*)sv, sMsg, dwLen);
	LocalFree(sMsg);
d1504 2
a1550 2
#define MODE_SIZE 10

a1553 7
    dTHXo;
    WCHAR wMode[MODE_SIZE], wBuffer[MAX_PATH+1];
    FILE *f;
    
    if (!*filename)
	return NULL;

d1555 2
a1556 13
	filename = "NUL";

    if (USING_WIDE()) {
	A2WHELPER(mode, wMode, sizeof(wMode));
	A2WHELPER(filename, wBuffer, sizeof(wBuffer));
	f = _wfopen(PerlDir_mapW(wBuffer), wMode);
    }
    else
	f = fopen(PerlDir_mapA(filename), mode);
    /* avoid buffering headaches for child processes */
    if (f && *mode == 'a')
	win32_fseek(f, 0, SEEK_END);
    return f;
d1565 1
a1565 1
win32_fdopen(int handle, const char *mode)
d1567 1
a1567 13
    dTHXo;
    WCHAR wMode[MODE_SIZE];
    FILE *f;
    if (USING_WIDE()) {
	A2WHELPER(mode, wMode, sizeof(wMode));
	f = _wfdopen(handle, wMode);
    }
    else
	f = fdopen(handle, (char *) mode);
    /* avoid buffering headaches for child processes */
    if (f && *mode == 'a')
	win32_fseek(f, 0, SEEK_END);
    return f;
d1571 1
a1571 1
win32_freopen(const char *path, const char *mode, FILE *stream)
a1572 2
    dTHXo;
    WCHAR wMode[MODE_SIZE], wBuffer[MAX_PATH+1];
d1574 2
a1575 8
	path = "NUL";

    if (USING_WIDE()) {
	A2WHELPER(mode, wMode, sizeof(wMode));
	A2WHELPER(path, wBuffer, sizeof(wBuffer));
	return _wfreopen(PerlDir_mapW(wBuffer), wMode, stream);
    }
    return freopen(PerlDir_mapA(path), mode, stream);
d1740 2
a1741 4
    {
	dTHXo;
	if ((childpid = do_spawn_nowait((char*)command)) == -1)
	    goto cleanup;
d1743 3
a1745 3
	/* revert stdfd to whatever it was before */
	if (win32_dup2(oldfd, stdfd) == -1)
	    goto cleanup;
d1747 2
a1748 2
	/* close saved handle */
	win32_close(oldfd);
d1750 1
a1750 5
	sv_setiv(*av_fetch(w32_fdpid, p[parent], TRUE), childpid);

	/* set process id so that it can be returned by perl's open() */
	PL_forkprocess = childpid;
    }
d1778 1
a1778 1
    dTHXo;
d1796 1
a1796 2
    if (win32_waitpid(childpid, &status, 0) == -1)
        return -1;
d1798 8
a1805 1
    return status;
a1809 85
static BOOL WINAPI
Nt4CreateHardLinkW(
    LPCWSTR lpFileName,
    LPCWSTR lpExistingFileName,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes)
{
    HANDLE handle;
    WCHAR wFullName[MAX_PATH+1];
    LPVOID lpContext = NULL;
    WIN32_STREAM_ID StreamId;
    DWORD dwSize = (char*)&StreamId.cStreamName - (char*)&StreamId;
    DWORD dwWritten;
    DWORD dwLen;
    BOOL bSuccess;

    BOOL (__stdcall *pfnBackupWrite)(HANDLE, LPBYTE, DWORD, LPDWORD,
				     BOOL, BOOL, LPVOID*) =
	(BOOL (__stdcall *)(HANDLE, LPBYTE, DWORD, LPDWORD,
			    BOOL, BOOL, LPVOID*))
	GetProcAddress(GetModuleHandle("kernel32.dll"), "BackupWrite");
    if (pfnBackupWrite == NULL)
	return 0;

    dwLen = GetFullPathNameW(lpFileName, MAX_PATH, wFullName, NULL);
    if (dwLen == 0)
	return 0;
    dwLen = (dwLen+1)*sizeof(WCHAR);

    handle = CreateFileW(lpExistingFileName, FILE_WRITE_ATTRIBUTES,
			 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
			 NULL, OPEN_EXISTING, 0, NULL);
    if (handle == INVALID_HANDLE_VALUE)
	return 0;

    StreamId.dwStreamId = BACKUP_LINK;
    StreamId.dwStreamAttributes = 0;
    StreamId.dwStreamNameSize = 0;
#if defined(__BORLANDC__) || defined(__MINGW32__)
    StreamId.Size.u.HighPart = 0;
    StreamId.Size.u.LowPart = dwLen;
#else
    StreamId.Size.HighPart = 0;
    StreamId.Size.LowPart = dwLen;
#endif

    bSuccess = pfnBackupWrite(handle, (LPBYTE)&StreamId, dwSize, &dwWritten,
			      FALSE, FALSE, &lpContext);
    if (bSuccess) {
	bSuccess = pfnBackupWrite(handle, (LPBYTE)wFullName, dwLen, &dwWritten,
				  FALSE, FALSE, &lpContext);
	pfnBackupWrite(handle, NULL, 0, &dwWritten, TRUE, FALSE, &lpContext);
    }

    CloseHandle(handle);
    return bSuccess;
}

DllExport int
win32_link(const char *oldname, const char *newname)
{
    dTHXo;
    BOOL (__stdcall *pfnCreateHardLinkW)(LPCWSTR,LPCWSTR,LPSECURITY_ATTRIBUTES);
    WCHAR wOldName[MAX_PATH+1];
    WCHAR wNewName[MAX_PATH+1];

    if (IsWin95())
	Perl_croak(aTHX_ PL_no_func, "link");

    pfnCreateHardLinkW =
	(BOOL (__stdcall *)(LPCWSTR, LPCWSTR, LPSECURITY_ATTRIBUTES))
	GetProcAddress(GetModuleHandle("kernel32.dll"), "CreateHardLinkW");
    if (pfnCreateHardLinkW == NULL)
	pfnCreateHardLinkW = Nt4CreateHardLinkW;

    if ((A2WHELPER(oldname, wOldName, sizeof(wOldName))) &&
	(A2WHELPER(newname, wNewName, sizeof(wNewName))) &&
	(wcscpy(wOldName, PerlDir_mapW(wOldName)),
	pfnCreateHardLinkW(PerlDir_mapW(wNewName), wOldName, NULL)))
    {
	return 0;
    }
    errno = (GetLastError() == ERROR_FILE_NOT_FOUND) ? ENOENT : EINVAL;
    return -1;
}

a1812 7
    WCHAR wOldName[MAX_PATH+1];
    WCHAR wNewName[MAX_PATH+1];
    char szOldName[MAX_PATH+1];
    char szNewName[MAX_PATH+1];
    BOOL bResult;
    dTHXo;

d1817 2
a1818 16
	DWORD dwFlags = MOVEFILE_COPY_ALLOWED;
	if (USING_WIDE()) {
	    A2WHELPER(oname, wOldName, sizeof(wOldName));
	    A2WHELPER(newname, wNewName, sizeof(wNewName));
	    if (wcsicmp(wNewName, wOldName))
		dwFlags |= MOVEFILE_REPLACE_EXISTING;
	    wcscpy(wOldName, PerlDir_mapW(wOldName));
	    bResult = MoveFileExW(wOldName,PerlDir_mapW(wNewName), dwFlags);
	}
	else {
	    if (stricmp(newname, oname))
		dwFlags |= MOVEFILE_REPLACE_EXISTING;
	    strcpy(szOldName, PerlDir_mapA(oname));
	    bResult = MoveFileExA(szOldName,PerlDir_mapA(newname), dwFlags);
	}
	if (!bResult) {
d1841 1
a1841 1
	char szTmpName[MAX_PATH+1];
a1846 3
	strcpy(szOldName, PerlDir_mapA(oname));
	strcpy(szNewName, PerlDir_mapA(newname));

d1848 1
a1848 1
	from_attr = GetFileAttributes(szOldName);
d1858 1
a1858 1
	to_attr = GetFileAttributes(szNewName);
d1866 4
a1869 4
	    tmplen = strlen(szNewName);
	    strcpy(szTmpName,szNewName);
	    endname = szTmpName+tmplen;
	    for (; endname > szTmpName ; --endname) {
d1875 2
a1876 2
	    if (endname > szTmpName)
		endname = strcpy(dname,szTmpName);
d1882 1
a1882 1
	    if (!GetTempFileName((LPCTSTR)endname, "plr", 0, szTmpName)) {
d1886 1
a1886 1
	    DeleteFile(szTmpName);
d1888 1
a1888 1
	    retval = rename(szNewName, szTmpName);
d1896 1
a1896 1
	retval = rename(szOldName, szNewName);
d1902 1
a1902 1
		DeleteFile(szTmpName);
d1905 1
a1905 1
		(void)rename(szTmpName, szNewName);
a1931 1
    dTHXo;
a1933 1
    WCHAR wBuffer[MAX_PATH+1];
d1940 2
a1941 7
	path = "NUL";

    if (USING_WIDE()) {
	A2WHELPER(path, wBuffer, sizeof(wBuffer));
	return _wopen(PerlDir_mapW(wBuffer), flag, pmode);
    }
    return open(PerlDir_mapA(path), flag, pmode);
a1967 196
#ifdef PERL_MSVCRT_READFIX

#define LF		10	/* line feed */
#define CR		13	/* carriage return */
#define CTRLZ		26      /* ctrl-z means eof for text */
#define FOPEN		0x01	/* file handle open */
#define FEOFLAG		0x02	/* end of file has been encountered */
#define FCRLF		0x04	/* CR-LF across read buffer (in text mode) */
#define FPIPE		0x08	/* file handle refers to a pipe */
#define FAPPEND		0x20	/* file handle opened O_APPEND */
#define FDEV		0x40	/* file handle refers to device */
#define FTEXT		0x80	/* file handle is in text mode */
#define MAX_DESCRIPTOR_COUNT	(64*32) /* this is the maximun that MSVCRT can handle */

int __cdecl
_fixed_read(int fh, void *buf, unsigned cnt)
{
    int bytes_read;                 /* number of bytes read */
    char *buffer;                   /* buffer to read to */
    int os_read;                    /* bytes read on OS call */
    char *p, *q;                    /* pointers into buffer */
    char peekchr;                   /* peek-ahead character */
    ULONG filepos;                  /* file position after seek */
    ULONG dosretval;                /* o.s. return value */

    /* validate handle */
    if (((unsigned)fh >= (unsigned)MAX_DESCRIPTOR_COUNT) ||
         !(_osfile(fh) & FOPEN))
    {
	/* out of range -- return error */
	errno = EBADF;
	_doserrno = 0;  /* not o.s. error */
	return -1;
    }

    /*
     * If lockinitflag is FALSE, assume fd is device
     * lockinitflag is set to TRUE by open.
     */
    if (_pioinfo(fh)->lockinitflag)
	EnterCriticalSection(&(_pioinfo(fh)->lock));  /* lock file */

    bytes_read = 0;                 /* nothing read yet */
    buffer = (char*)buf;

    if (cnt == 0 || (_osfile(fh) & FEOFLAG)) {
        /* nothing to read or at EOF, so return 0 read */
        goto functionexit;
    }

    if ((_osfile(fh) & (FPIPE|FDEV)) && _pipech(fh) != LF) {
        /* a pipe/device and pipe lookahead non-empty: read the lookahead
         * char */
        *buffer++ = _pipech(fh);
        ++bytes_read;
        --cnt;
        _pipech(fh) = LF;           /* mark as empty */
    }

    /* read the data */

    if (!ReadFile((HANDLE)_osfhnd(fh), buffer, cnt, (LPDWORD)&os_read, NULL))
    {
        /* ReadFile has reported an error. recognize two special cases.
         *
         *      1. map ERROR_ACCESS_DENIED to EBADF
         *
         *      2. just return 0 if ERROR_BROKEN_PIPE has occurred. it
         *         means the handle is a read-handle on a pipe for which
         *         all write-handles have been closed and all data has been
         *         read. */

        if ((dosretval = GetLastError()) == ERROR_ACCESS_DENIED) {
            /* wrong read/write mode should return EBADF, not EACCES */
            errno = EBADF;
            _doserrno = dosretval;
            bytes_read = -1;
	    goto functionexit;
        }
        else if (dosretval == ERROR_BROKEN_PIPE) {
            bytes_read = 0;
	    goto functionexit;
        }
        else {
            bytes_read = -1;
	    goto functionexit;
        }
    }

    bytes_read += os_read;          /* update bytes read */

    if (_osfile(fh) & FTEXT) {
        /* now must translate CR-LFs to LFs in the buffer */

        /* set CRLF flag to indicate LF at beginning of buffer */
        /* if ((os_read != 0) && (*(char *)buf == LF))   */
        /*    _osfile(fh) |= FCRLF;                      */
        /* else                                          */
        /*    _osfile(fh) &= ~FCRLF;                     */

        _osfile(fh) &= ~FCRLF;

        /* convert chars in the buffer: p is src, q is dest */
        p = q = (char*)buf;
        while (p < (char *)buf + bytes_read) {
            if (*p == CTRLZ) {
                /* if fh is not a device, set ctrl-z flag */
                if (!(_osfile(fh) & FDEV))
                    _osfile(fh) |= FEOFLAG;
                break;              /* stop translating */
            }
            else if (*p != CR)
                *q++ = *p++;
            else {
                /* *p is CR, so must check next char for LF */
                if (p < (char *)buf + bytes_read - 1) {
                    if (*(p+1) == LF) {
                        p += 2;
                        *q++ = LF;  /* convert CR-LF to LF */
                    }
                    else
                        *q++ = *p++;    /* store char normally */
                }
                else {
                    /* This is the hard part.  We found a CR at end of
                       buffer.  We must peek ahead to see if next char
                       is an LF. */
                    ++p;

                    dosretval = 0;
                    if (!ReadFile((HANDLE)_osfhnd(fh), &peekchr, 1,
                                    (LPDWORD)&os_read, NULL))
                        dosretval = GetLastError();

                    if (dosretval != 0 || os_read == 0) {
                        /* couldn't read ahead, store CR */
                        *q++ = CR;
                    }
                    else {
                        /* peekchr now has the extra character -- we now
                           have several possibilities:
                           1. disk file and char is not LF; just seek back
                              and copy CR
                           2. disk file and char is LF; store LF, don't seek back
                           3. pipe/device and char is LF; store LF.
                           4. pipe/device and char isn't LF, store CR and
                              put char in pipe lookahead buffer. */
                        if (_osfile(fh) & (FDEV|FPIPE)) {
                            /* non-seekable device */
                            if (peekchr == LF)
                                *q++ = LF;
                            else {
                                *q++ = CR;
                                _pipech(fh) = peekchr;
                            }
                        }
                        else {
                            /* disk file */
                            if (peekchr == LF) {
                                /* nothing read yet; must make some
                                   progress */
                                *q++ = LF;
                                /* turn on this flag for tell routine */
                                _osfile(fh) |= FCRLF;
                            }
                            else {
				HANDLE osHandle;        /* o.s. handle value */
                                /* seek back */
				if ((osHandle = (HANDLE)_get_osfhandle(fh)) != (HANDLE)-1)
				{
				    if ((filepos = SetFilePointer(osHandle, -1, NULL, FILE_CURRENT)) == -1)
					dosretval = GetLastError();
				}
                                if (peekchr != LF)
                                    *q++ = CR;
                            }
                        }
                    }
                }
            }
        }

        /* we now change bytes_read to reflect the true number of chars
           in the buffer */
        bytes_read = q - (char *)buf;
    }

functionexit:	
    if (_pioinfo(fh)->lockinitflag)
	LeaveCriticalSection(&(_pioinfo(fh)->lock));    /* unlock file */

    return bytes_read;
}

#endif	/* PERL_MSVCRT_READFIX */

a1970 3
#ifdef PERL_MSVCRT_READFIX
    return _fixed_read(fd, buf, cnt);
#else
a1971 1
#endif
d1983 1
a1983 7
    dTHXo;
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(dir, wBuffer, sizeof(wBuffer));
	return _wmkdir(PerlDir_mapW(wBuffer));
    }
    return mkdir(PerlDir_mapA(dir)); /* just ignore mode */
d1989 1
a1989 7
    dTHXo;
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(dir, wBuffer, sizeof(wBuffer));
	return _wrmdir(PerlDir_mapW(wBuffer));
    }
    return rmdir(PerlDir_mapA(dir));
a1994 6
    dTHXo;
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(dir, wBuffer, sizeof(wBuffer));
	return _wchdir(wBuffer);
    }
a1997 193
DllExport  int
win32_access(const char *path, int mode)
{
    dTHXo;
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(path, wBuffer, sizeof(wBuffer));
	return _waccess(PerlDir_mapW(wBuffer), mode);
    }
    return access(PerlDir_mapA(path), mode);
}

DllExport  int
win32_chmod(const char *path, int mode)
{
    dTHXo;
    if (USING_WIDE()) {
	WCHAR wBuffer[MAX_PATH+1];
	A2WHELPER(path, wBuffer, sizeof(wBuffer));
	return _wchmod(PerlDir_mapW(wBuffer), mode);
    }
    return chmod(PerlDir_mapA(path), mode);
}


static char *
create_command_line(const char* command, const char * const *args)
{
    dTHXo;
    int index;
    char *cmd, *ptr, *arg;
    STRLEN len = strlen(command) + 1;

    for (index = 0; (ptr = (char*)args[index]) != NULL; ++index)
	len += strlen(ptr) + 1;

    New(1310, cmd, len, char);
    ptr = cmd;
    strcpy(ptr, command);

    for (index = 0; (arg = (char*)args[index]) != NULL; ++index) {
	ptr += strlen(ptr);
	*ptr++ = ' ';
	strcpy(ptr, arg);
    }

    return cmd;
}

static char *
qualified_path(const char *cmd)
{
    dTHXo;
    char *pathstr;
    char *fullcmd, *curfullcmd;
    STRLEN cmdlen = 0;
    int has_slash = 0;

    if (!cmd)
	return Nullch;
    fullcmd = (char*)cmd;
    while (*fullcmd) {
	if (*fullcmd == '/' || *fullcmd == '\\')
	    has_slash++;
	fullcmd++;
	cmdlen++;
    }

    /* look in PATH */
    pathstr = win32_getenv("PATH");
    New(0, fullcmd, MAX_PATH+1, char);
    curfullcmd = fullcmd;

    while (1) {
	DWORD res;

	/* start by appending the name to the current prefix */
	strcpy(curfullcmd, cmd);
	curfullcmd += cmdlen;

	/* if it doesn't end with '.', or has no extension, try adding
	 * a trailing .exe first */
	if (cmd[cmdlen-1] != '.'
	    && (cmdlen < 4 || cmd[cmdlen-4] != '.'))
	{
	    strcpy(curfullcmd, ".exe");
	    res = GetFileAttributes(fullcmd);
	    if (res != 0xFFFFFFFF && !(res & FILE_ATTRIBUTE_DIRECTORY))
		return fullcmd;
	    *curfullcmd = '\0';
	}

	/* that failed, try the bare name */
	res = GetFileAttributes(fullcmd);
	if (res != 0xFFFFFFFF && !(res & FILE_ATTRIBUTE_DIRECTORY))
	    return fullcmd;

	/* quit if no other path exists, or if cmd already has path */
	if (!pathstr || !*pathstr || has_slash)
	    break;

	/* skip leading semis */
	while (*pathstr == ';')
	    pathstr++;

	/* build a new prefix from scratch */
	curfullcmd = fullcmd;
	while (*pathstr && *pathstr != ';') {
	    if (*pathstr == '"') {	/* foo;"baz;etc";bar */
		pathstr++;		/* skip initial '"' */
		while (*pathstr && *pathstr != '"') {
		    if (curfullcmd-fullcmd < MAX_PATH-cmdlen-5)
			*curfullcmd++ = *pathstr;
		    pathstr++;
		}
		if (*pathstr)
		    pathstr++;		/* skip trailing '"' */
	    }
	    else {
		if (curfullcmd-fullcmd < MAX_PATH-cmdlen-5)
		    *curfullcmd++ = *pathstr;
		pathstr++;
	    }
	}
	if (*pathstr)
	    pathstr++;			/* skip trailing semi */
	if (curfullcmd > fullcmd	/* append a dir separator */
	    && curfullcmd[-1] != '/' && curfullcmd[-1] != '\\')
	{
	    *curfullcmd++ = '\\';
	}
    }
GIVE_UP:
    Safefree(fullcmd);
    return Nullch;
}

/* The following are just place holders.
 * Some hosts may provide and environment that the OS is
 * not tracking, therefore, these host must provide that
 * environment and the current directory to CreateProcess
 */

void*
get_childenv(void)
{
    return NULL;
}

void
free_childenv(void* d)
{
}

char*
get_childdir(void)
{
    dTHXo;
    char* ptr;
    char szfilename[(MAX_PATH+1)*2];
    if (USING_WIDE()) {
	WCHAR wfilename[MAX_PATH+1];
	GetCurrentDirectoryW(MAX_PATH+1, wfilename);
	W2AHELPER(wfilename, szfilename, sizeof(szfilename));
    }
    else {
	GetCurrentDirectoryA(MAX_PATH+1, szfilename);
    }

    New(0, ptr, strlen(szfilename)+1, char);
    strcpy(ptr, szfilename);
    return ptr;
}

void
free_childdir(char* d)
{
    dTHXo;
    Safefree(d);
}


/* XXX this needs to be made more compatible with the spawnvp()
 * provided by the various RTLs.  In particular, searching for
 * *.{com,bat,cmd} files (as done by the RTLs) is unimplemented.
 * This doesn't significantly affect perl itself, because we
 * always invoke things using PERL5SHELL if a direct attempt to
 * spawn the executable fails.
 * 
 * XXX splitting and rejoining the commandline between do_aspawn()
 * and win32_spawnvp() could also be avoided.
 */

d2001 6
a2006 59
#ifdef USE_RTL_SPAWNVP
    return spawnvp(mode, cmdname, (char * const *)argv);
#else
    dTHXo;
    int ret;
    void* env;
    char* dir;
    child_IO_table tbl;
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    DWORD create = 0;

    char *cmd = create_command_line(cmdname, strcmp(cmdname, argv[0]) == 0
			     	             ? &argv[1] : argv);
    char *fullcmd = Nullch;

    env = PerlEnv_get_childenv();
    dir = PerlEnv_get_childdir();

    switch(mode) {
    case P_NOWAIT:	/* asynch + remember result */
	if (w32_num_children >= MAXIMUM_WAIT_OBJECTS) {
	    errno = EAGAIN;
	    ret = -1;
	    goto RETVAL;
	}
	/* FALL THROUGH */
    case P_WAIT:	/* synchronous execution */
	break;
    default:		/* invalid mode */
	errno = EINVAL;
	ret = -1;
	goto RETVAL;
    }
    memset(&StartupInfo,0,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    memset(&tbl,0,sizeof(tbl));
    PerlEnv_get_child_IO(&tbl);
    StartupInfo.dwFlags		= tbl.dwFlags;
    StartupInfo.dwX		= tbl.dwX; 
    StartupInfo.dwY		= tbl.dwY; 
    StartupInfo.dwXSize		= tbl.dwXSize; 
    StartupInfo.dwYSize		= tbl.dwYSize; 
    StartupInfo.dwXCountChars	= tbl.dwXCountChars; 
    StartupInfo.dwYCountChars	= tbl.dwYCountChars; 
    StartupInfo.dwFillAttribute	= tbl.dwFillAttribute; 
    StartupInfo.wShowWindow	= tbl.wShowWindow; 
    StartupInfo.hStdInput	= tbl.childStdIn;
    StartupInfo.hStdOutput	= tbl.childStdOut;
    StartupInfo.hStdError	= tbl.childStdErr;
    if (StartupInfo.hStdInput != INVALID_HANDLE_VALUE &&
	StartupInfo.hStdOutput != INVALID_HANDLE_VALUE &&
	StartupInfo.hStdError != INVALID_HANDLE_VALUE)
    {
	StartupInfo.dwFlags |= STARTF_USESTDHANDLES;
    }
    else {
	create |= CREATE_NEW_CONSOLE;
    }
d2008 8
a2015 53
RETRY:
    if (!CreateProcess(cmdname,		/* search PATH to find executable */
		       cmd,		/* executable, and its arguments */
		       NULL,		/* process attributes */
		       NULL,		/* thread attributes */
		       TRUE,		/* inherit handles */
		       create,		/* creation flags */
		       (LPVOID)env,	/* inherit environment */
		       dir,		/* inherit cwd */
		       &StartupInfo,
		       &ProcessInformation))
    {
	/* initial NULL argument to CreateProcess() does a PATH
	 * search, but it always first looks in the directory
	 * where the current process was started, which behavior
	 * is undesirable for backward compatibility.  So we
	 * jump through our own hoops by picking out the path
	 * we really want it to use. */
	if (!fullcmd) {
	    fullcmd = qualified_path(cmdname);
	    if (fullcmd) {
		cmdname = fullcmd;
		goto RETRY;
	    }
	}
	errno = ENOENT;
	ret = -1;
	goto RETVAL;
    }

    if (mode == P_NOWAIT) {
	/* asynchronous spawn -- store handle, return PID */
	w32_child_handles[w32_num_children] = ProcessInformation.hProcess;
	w32_child_pids[w32_num_children] = ProcessInformation.dwProcessId;
	ret = (int)ProcessInformation.dwProcessId;
	++w32_num_children;
    }
    else  {
	DWORD status;
	WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
	GetExitCodeProcess(ProcessInformation.hProcess, &status);
	ret = (int)status;
	CloseHandle(ProcessInformation.hProcess);
    }

    CloseHandle(ProcessInformation.hThread);

RETVAL:
    PerlEnv_free_childenv(env);
    PerlEnv_free_childdir(dir);
    Safefree(cmd);
    Safefree(fullcmd);
    return ret;
d2017 1
a2022 7
#ifdef USE_ITHREADS
    dTHXo;
    /* if this is a pseudo-forked child, we just want to spawn
     * the new program, and return */
    if (w32_pseudo_id)
	return spawnv(P_WAIT, cmdname, (char *const *)argv);
#endif
a2028 7
#ifdef USE_ITHREADS
    dTHXo;
    /* if this is a pseudo-forked child, we just want to spawn
     * the new program, and return */
    if (w32_pseudo_id)
	return win32_spawnvp(P_WAIT, cmdname, (char *const *)argv);
#endif
a2210 4
#ifdef USE_FIXED_OSFHANDLE
    if (IsWin95())
	return my_open_osfhandle(handle, flags);
#endif
a2219 16
DllExport void*
win32_dynaload(const char* filename)
{
    dTHXo;
    HMODULE hModule;
    if (USING_WIDE()) {
	WCHAR wfilename[MAX_PATH+1];
	A2WHELPER(filename, wfilename, sizeof(wfilename));
	hModule = LoadLibraryExW(PerlDir_mapW(wfilename), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }
    else {
	hModule = LoadLibraryExA(PerlDir_mapA(filename), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
    }
    return hModule;
}

d2228 6
a2233 2
    /* Make the host for current directory */
    char* ptr = PerlEnv_get_childdir();
d2235 1
a2235 1
     * If ptr != Nullch 
d2237 1
a2237 1
     *   else return 'undef' 
d2239 1
a2239 6
    if (ptr) {
	SV *sv = sv_newmortal();
	sv_setpv(sv, ptr);
	PerlEnv_free_childdir(ptr);

	EXTEND(SP,1);
d2241 3
a2243 4
	ST(0) = sv;
	XSRETURN(1);
    }
    XSRETURN_UNDEF;
d2250 1
d2252 2
a2253 2
	Perl_croak(aTHX_ "usage: Win32::SetCurrentDirectory($cwd)");
    if (!PerlDir_chdir(SvPV_nolen(ST(0))))
a2264 2

    EXTEND(SP,1);
a2278 1
    EXTEND(SP,1);
a2282 10
XS(w32_SetLastError)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::SetLastError($error)");
    SetLastError(SvIV(ST(0)));
    XSRETURN_EMPTY;
}

static
d2286 2
a2287 3
    char *name = w32_getlogin_buffer;
    DWORD size = sizeof(w32_getlogin_buffer);
    EXTEND(SP,1);
d2290 1
a2290 1
	ST(0) = sv_2mortal(newSVpvn(name,size-1));
a2301 1
    EXTEND(SP,1);
d2304 1
a2304 1
	ST(0) = sv_2mortal(newSVpvn(name,size));
d2315 7
a2321 14
    HINSTANCE hNetApi32 = LoadLibrary("netapi32.dll");
    DWORD (__stdcall *pfnNetApiBufferFree)(LPVOID Buffer);
    DWORD (__stdcall *pfnNetWkstaGetInfo)(LPWSTR servername, DWORD level,
					  void *bufptr);

    if (hNetApi32) {
	pfnNetApiBufferFree = (DWORD (__stdcall *)(void *))
	    GetProcAddress(hNetApi32, "NetApiBufferFree");
	pfnNetWkstaGetInfo = (DWORD (__stdcall *)(LPWSTR, DWORD, void *))
	    GetProcAddress(hNetApi32, "NetWkstaGetInfo");
    }
    EXTEND(SP,1);
    if (hNetApi32 && pfnNetWkstaGetInfo && pfnNetApiBufferFree) {
	/* this way is more reliable, in case user has a local account. */
d2324 4
a2327 20
	struct {
	    DWORD   wki100_platform_id;
	    LPWSTR  wki100_computername;
	    LPWSTR  wki100_langroup;
	    DWORD   wki100_ver_major;
	    DWORD   wki100_ver_minor;
	} *pwi;
	/* NERR_Success *is* 0*/
	if (0 == pfnNetWkstaGetInfo(NULL, 100, &pwi)) {
	    if (pwi->wki100_langroup && *(pwi->wki100_langroup)) {
		WideCharToMultiByte(CP_ACP, NULL, pwi->wki100_langroup,
				    -1, (LPSTR)dname, dnamelen, NULL, NULL);
	    }
	    else {
		WideCharToMultiByte(CP_ACP, NULL, pwi->wki100_computername,
				    -1, (LPSTR)dname, dnamelen, NULL, NULL);
	    }
	    pfnNetApiBufferFree(pwi);
	    FreeLibrary(hNetApi32);
	    XSRETURN_PV(dname);
a2328 1
	FreeLibrary(hNetApi32);
d2330 15
a2344 16
    else {
	/* Win95 doesn't have NetWksta*(), so do it the old way */
	char name[256];
	DWORD size = sizeof(name);
	if (hNetApi32)
	    FreeLibrary(hNetApi32);
	if (GetUserName(name,&size)) {
	    char sid[ONE_K_BUFSIZE];
	    DWORD sidlen = sizeof(sid);
	    char dname[256];
	    DWORD dnamelen = sizeof(dname);
	    SID_NAME_USE snu;
	    if (LookupAccountName(NULL, name, (PSID)&sid, &sidlen,
				  dname, &dnamelen, &snu)) {
		XSRETURN_PV(dname);		/* all that for this */
	    }
d2346 2
d2349 1
d2361 2
a2362 2
	if (GIMME_V == G_ARRAY) {
	    XPUSHs(sv_2mortal(newSVpvn(fsname,strlen(fsname))));
a2367 1
	EXTEND(SP,1);
d2370 1
a2370 1
    XSRETURN_EMPTY;
d2377 1
a2377 1
    OSVERSIONINFOA osver;
d2379 9
a2387 13
    if (USING_WIDE()) {
	OSVERSIONINFOW osverw;
	char szCSDVersion[sizeof(osverw.szCSDVersion)];
	osverw.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
	if (!GetVersionExW(&osverw)) {
	    XSRETURN_EMPTY;
	}
	W2AHELPER(osverw.szCSDVersion, szCSDVersion, sizeof(szCSDVersion));
	XPUSHs(newSVpvn(szCSDVersion, strlen(szCSDVersion)));
	osver.dwMajorVersion = osverw.dwMajorVersion;
	osver.dwMinorVersion = osverw.dwMinorVersion;
	osver.dwBuildNumber = osverw.dwBuildNumber;
	osver.dwPlatformId = osverw.dwPlatformId;
d2389 1
a2389 12
    else {
	osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	if (!GetVersionExA(&osver)) {
	    XSRETURN_EMPTY;
	}
	XPUSHs(newSVpvn(osver.szCSDVersion, strlen(osver.szCSDVersion)));
    }
    XPUSHs(newSViv(osver.dwMajorVersion));
    XPUSHs(newSViv(osver.dwMinorVersion));
    XPUSHs(newSViv(osver.dwBuildNumber));
    XPUSHs(newSViv(osver.dwPlatformId));
    PUTBACK;
a2395 1
    EXTEND(SP,1);
a2402 1
    EXTEND(SP,1);
d2411 1
a2411 1
    char msgbuf[ONE_K_BUFSIZE];
d2414 1
a2414 1
	Perl_croak(aTHX_ "usage: Win32::FormatMessage($errno)");
d2416 4
a2419 16
    if (USING_WIDE()) {
	WCHAR wmsgbuf[ONE_K_BUFSIZE];
	if (FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM,
			  &source, SvIV(ST(0)), 0,
			  wmsgbuf, ONE_K_BUFSIZE-1, NULL))
	{
	    W2AHELPER(wmsgbuf, msgbuf, sizeof(msgbuf));
	    XSRETURN_PV(msgbuf);
	}
    }
    else {
	if (FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
			  &source, SvIV(ST(0)), 0,
			  msgbuf, sizeof(msgbuf)-1, NULL))
	    XSRETURN_PV(msgbuf);
    }
d2432 1
d2435 1
a2435 1
	Perl_croak(aTHX_ "usage: Win32::Spawn($cmdName, $args, $PID)");
d2437 2
a2438 2
    cmd = SvPV_nolen(ST(0));
    args = SvPV_nolen(ST(1));
d2468 1
a2468 5
    DWORD msec = GetTickCount();
    EXTEND(SP,1);
    if ((IV)msec > 0)
	XSRETURN_IV(msec);
    XSRETURN_NV(msec);
d2479 1
a2479 1
	Perl_croak(aTHX_ "usage: Win32::GetShortPathName($longPathName)");
a2491 1
	XSRETURN(1);
d2493 3
a2495 59
    XSRETURN_UNDEF;
}

static
XS(w32_GetFullPathName)
{
    dXSARGS;
    SV *filename;
    SV *fullpath;
    char *filepart;
    DWORD len;

    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::GetFullPathName($filename)");

    filename = ST(0);
    fullpath = sv_mortalcopy(filename);
    SvUPGRADE(fullpath, SVt_PV);
    do {
	len = GetFullPathName(SvPVX(filename),
			      SvLEN(fullpath),
			      SvPVX(fullpath),
			      &filepart);
    } while (len >= SvLEN(fullpath) && sv_grow(fullpath,len+1));
    if (len) {
	if (GIMME_V == G_ARRAY) {
	    EXTEND(SP,1);
	    XST_mPV(1,filepart);
	    len = filepart - SvPVX(fullpath);
	    items = 2;
	}
	SvCUR_set(fullpath,len);
	ST(0) = fullpath;
	XSRETURN(items);
    }
    XSRETURN_EMPTY;
}

static
XS(w32_GetLongPathName)
{
    dXSARGS;
    SV *path;
    char tmpbuf[MAX_PATH+1];
    char *pathstr;
    STRLEN len;

    if (items != 1)
	Perl_croak(aTHX_ "usage: Win32::GetLongPathName($pathname)");

    path = ST(0);
    pathstr = SvPV(path,len);
    strcpy(tmpbuf, pathstr);
    pathstr = win32_longpath(tmpbuf);
    if (pathstr) {
	ST(0) = sv_2mortal(newSVpvn(pathstr, strlen(pathstr)));
	XSRETURN(1);
    }
    XSRETURN_EMPTY;
d2503 1
a2503 1
	Perl_croak(aTHX_ "usage: Win32::Sleep($milliseconds)");
a2507 26
static
XS(w32_CopyFile)
{
    dXSARGS;
    BOOL bResult;
    if (items != 3)
	Perl_croak(aTHX_ "usage: Win32::CopyFile($from, $to, $overwrite)");
    if (USING_WIDE()) {
	WCHAR wSourceFile[MAX_PATH+1];
	WCHAR wDestFile[MAX_PATH+1];
	A2WHELPER(SvPV_nolen(ST(0)), wSourceFile, sizeof(wSourceFile));
	wcscpy(wSourceFile, PerlDir_mapW(wSourceFile));
	A2WHELPER(SvPV_nolen(ST(1)), wDestFile, sizeof(wDestFile));
	bResult = CopyFileW(wSourceFile, PerlDir_mapW(wDestFile), !SvTRUE(ST(2)));
    }
    else {
	char szSourceFile[MAX_PATH+1];
	strcpy(szSourceFile, PerlDir_mapA(SvPV_nolen(ST(0))));
	bResult = CopyFileA(szSourceFile, PerlDir_mapA(SvPV_nolen(ST(1))), !SvTRUE(ST(2)));
    }

    if (bResult)
	XSRETURN_YES;
    XSRETURN_NO;
}

d2509 1
a2509 1
Perl_init_os_extras(void)
a2510 1
    dTHXo;
d2517 1
a2517 1
    New(1313, w32_children, 1, child_tab);
a2518 5
    w32_init_socktype = 0;
#ifdef USE_ITHREADS
    w32_pseudo_id = 0;
    New(1313, w32_pseudo_children, 1, child_tab);
    w32_num_pseudo_children = 0;
a2525 1
    newXS("Win32::SetLastError", w32_SetLastError, file);
a2536 3
    newXS("Win32::GetFullPathName", w32_GetFullPathName, file);
    newXS("Win32::GetLongPathName", w32_GetLongPathName, file);
    newXS("Win32::CopyFile", w32_CopyFile, file);
d2566 1
a2566 16
void
win32_get_child_IO(child_IO_table* ptbl)
{
    ptbl->childStdIn	= GetStdHandle(STD_INPUT_HANDLE);
    ptbl->childStdOut	= GetStdHandle(STD_OUTPUT_HANDLE);
    ptbl->childStdErr	= GetStdHandle(STD_ERROR_HANDLE);
}


#ifdef USE_ITHREADS

#  ifdef PERL_OBJECT
#    undef Perl_sys_intern_dup
#    define Perl_sys_intern_dup CPerlObj::Perl_sys_intern_dup
#    define pPerl this
#  endif
d2569 1
a2569 1
Perl_sys_intern_dup(pTHX_ struct interp_intern *src, struct interp_intern *dst)
d2571 16
a2586 9
    dst->perlshell_tokens	= Nullch;
    dst->perlshell_vec		= (char**)NULL;
    dst->perlshell_items	= 0;
    dst->fdpid			= newAV();
    Newz(1313, dst->children, 1, child_tab);
    Newz(1313, dst->pseudo_children, 1, child_tab);
    dst->pseudo_id		= 0;
    dst->children->num		= 0;
    dst->thr_intern.Winit_socktype = src->thr_intern.Winit_socktype;
a2587 1
#endif
a2588 3
#ifdef PERL_OBJECT
#  undef this
#  define this pPerl
a2589 30

static void
win32_free_argvw(pTHXo_ void *ptr)
{
    char** argv = (char**)ptr;
    while(*argv) {
	Safefree(*argv);
	*argv++ = Nullch;
    }
}

void
win32_argv2utf8(int argc, char** argv)
{
    dTHXo;
    char* psz;
    int length, wargc;
    LPWSTR* lpwStr = CommandLineToArgvW(GetCommandLineW(), &wargc);
    if (lpwStr && argc) {
	while (argc--) {
	    length = WideCharToMultiByte(CP_UTF8, 0, lpwStr[--wargc], -1, NULL, 0, NULL, NULL);
	    Newz(0, psz, length, char);
	    WideCharToMultiByte(CP_UTF8, 0, lpwStr[wargc], -1, psz, length, NULL, NULL);
	    argv[argc] = psz;
	}
	call_atexit(win32_free_argvw, argv);
    }
    GlobalFree((HGLOBAL)lpwStr);
}

@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d56 1
d180 1
a180 3
	if (retval == ERROR_SUCCESS
	    && (type == REG_SZ || type == REG_EXPAND_SZ))
	{
a437 1
    int pid;
d443 1
a443 7
    pid = _getpid();
    /* Windows 9x appears to always reports a pid for threads and processes
     * that has the high bit set. So we treat the lower 31 bits as the
     * "real" PID for Perl's purposes. */
    if (IsWin95() && pid < 0)
	pid = -pid;
    return pid;
d570 1
a570 5
    if (flag == P_NOWAIT) {
	if (IsWin95())
	    PL_statusvalue = -1;	/* >16bits hint for pp_system() */
    }
    else {
d572 1
d659 1
a659 5
    if (exectype == EXECF_SPAWN_NOWAIT) {
	if (IsWin95())
	    PL_statusvalue = -1;	/* >16bits hint for pp_system() */
    }
    else {
d661 1
a1022 1
    long child;
d1026 1
a1026 1
	child = find_pseudo_pid(-pid);
a1035 4
	else if (IsWin95()) {
	    pid = -pid;
	    goto alien_process;
	}
d1040 1
a1040 1
	child = find_pid(pid);
d1051 1
a1051 3
alien_process:
	    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE,
				   (IsWin95() ? -pid : pid));
d1279 2
d1382 2
d1613 1
a1613 1
#if (defined(__BORLANDC__)&&(__BORLANDC__<=0x520)) || defined(__MINGW32__)
a1637 1
    DWORD timeout = (flags & WNOHANG) ? 0 : INFINITE;
a1638 1
    long child;
d1643 1
a1643 1
	child = find_pseudo_pid(-pid);
d1646 2
a1647 5
	    DWORD waitcode = WaitForSingleObject(hThread, timeout);
	    if (waitcode == WAIT_TIMEOUT) {
		return 0;
	    }
	    else if (waitcode != WAIT_FAILED) {
d1652 1
a1652 1
		    return -retval;
a1657 4
	else if (IsWin95()) {
	    pid = -pid;
	    goto alien_process;
	}
d1661 1
a1661 3
	HANDLE hProcess;
	DWORD waitcode;
	child = find_pid(pid);
d1663 3
a1665 6
	    hProcess = w32_child_handles[child];
	    waitcode = WaitForSingleObject(hProcess, timeout);
	    if (waitcode == WAIT_TIMEOUT) {
		return 0;
	    }
	    else if (waitcode != WAIT_FAILED) {
d1677 6
a1682 19
alien_process:
	    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE,
				   (IsWin95() ? -pid : pid));
	    if (hProcess) {
		waitcode = WaitForSingleObject(hProcess, timeout);
		if (waitcode == WAIT_TIMEOUT) {
		    return 0;
		}
		else if (waitcode != WAIT_FAILED) {
		    if (GetExitCodeProcess(hProcess, &waitcode)) {
			*status = (int)((waitcode & 0xff) << 8);
			CloseHandle(hProcess);
			return pid;
		    }
		}
		CloseHandle(hProcess);
	    }
	    else
		errno = ECHILD;
d1714 1
a1714 1
		return -retval;
d1758 1
a1758 1
    CALL_FPTR(PL_sighandlerp)(14);
d1803 1
d1811 47
d1896 4
d2316 1
a2316 19
#ifdef __BORLANDC__
    /* A file designated by filehandle is not shown as accessible
     * for write operations, probably because it is opened for reading.
     * --Vadim Konovalov
     */ 
    int rc = fstat(fd,sbufptr);
    BY_HANDLE_FILE_INFORMATION bhfi;
    if (GetFileInformationByHandle((HANDLE)_get_osfhandle(fd), &bhfi)) {
        sbufptr->st_mode &= 0xFE00;
        if (bhfi.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            sbufptr->st_mode |= (S_IREAD + (S_IREAD >> 3) + (S_IREAD >> 6));
        else
            sbufptr->st_mode |= ((S_IREAD|S_IWRITE) + ((S_IREAD|S_IWRITE) >> 3)
              + ((S_IREAD|S_IWRITE) >> 6));
    }
    return rc;
#else
    return my_fstat(fd,sbufptr);
#endif
a2393 1
	LOCK_FDPID_MUTEX;
a2394 1
	UNLOCK_FDPID_MUTEX;
a2429 1
    LOCK_FDPID_MUTEX;
a2430 1

a2442 1
    UNLOCK_FDPID_MUTEX;
d3262 2
a3264 5
	if (IsWin95() && ret < 0)
	    ret = -ret;

	w32_child_handles[w32_num_children] = ProcessInformation.hProcess;
	w32_child_pids[w32_num_children] = (DWORD)ret;
a3508 19
    char buf[MAX_PATH+1];
    char *first;

    /* LoadLibrary() doesn't recognize forward slashes correctly,
     * so turn 'em back. */
    first = strchr(filename, '/');
    if (first) {
	STRLEN len = strlen(filename);
	if (len <= MAX_PATH) {
	    strcpy(buf, filename);
	    filename = &buf[first - filename];
	    while (*filename) {
		if (*filename == '/')
		    *(char*)filename = '\\';
		++filename;
	    }
	    filename = buf;
	}
    }
a3823 4
	int pid = (int)stProcInfo.dwProcessId;
	if (IsWin95() && pid < 0)
	    pid = -pid;
	sv_setiv(ST(2), pid);
d3825 1
a3853 3
    if (!SvPVX(shortpath) || !SvLEN(shortpath))
        XSRETURN_UNDEF;

a3882 3
    if (!SvPVX(fullpath) || !SvLEN(fullpath))
        XSRETURN_UNDEF;

d3969 12
d4038 2
a4039 1
#ifdef HAVE_INTERP_INTERN
a4041 2
#    undef Perl_sys_intern_init
#    define Perl_sys_intern_init CPerlObj::Perl_sys_intern_init
a4043 2
#    undef Perl_sys_intern_clear
#    define Perl_sys_intern_clear CPerlObj::Perl_sys_intern_clear
a4047 31
Perl_sys_intern_init(pTHX)
{
    w32_perlshell_tokens	= Nullch;
    w32_perlshell_vec		= (char**)NULL;
    w32_perlshell_items		= 0;
    w32_fdpid			= newAV();
    New(1313, w32_children, 1, child_tab);
    w32_num_children		= 0;
#  ifdef USE_ITHREADS
    w32_pseudo_id		= 0;
    New(1313, w32_pseudo_children, 1, child_tab);
    w32_num_pseudo_children	= 0;
#  endif
    w32_init_socktype		= 0;
}

void
Perl_sys_intern_clear(pTHX)
{
    Safefree(w32_perlshell_tokens);
    Safefree(w32_perlshell_vec);
    /* NOTE: w32_fdpid is freed by sv_clean_all() */
    Safefree(w32_children);
#  ifdef USE_ITHREADS
    Safefree(w32_pseudo_children);
#  endif
}

#  ifdef USE_ITHREADS

void
d4055 1
d4057 2
a4058 2
    Newz(1313, dst->pseudo_children, 1, child_tab);
    dst->thr_intern.Winit_socktype = 0;
d4060 1
a4060 2
#  endif /* USE_ITHREADS */
#endif /* HAVE_INTERP_INTERN */
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 * (c) 1995 Microsoft Corporation. All rights reserved.
d10 1
a10 1
#define PERLIO_NOT_STDIO 0
a24 1
#include <signal.h>
d28 1
d57 1
a57 1
/* Mingw32 defaults to globing command line
d88 2
d94 7
d103 1
a103 1
static int		do_spawn2(pTHX_ char *cmd, int exectype);
d128 1
a128 1
int
d182 1
a182 1
	    dTHX;
d218 1
d262 1
a262 1
	dTHX;
d276 1
a276 1
    dTHX;
d293 1
a293 1
    dTHX;
d296 2
d441 1
a441 1
    dTHX;
d467 1
a467 1
	dTHX;
d510 1
a510 1
    dTHX;
d521 1
a521 1
	const char *usershell = PerlEnv_getenv("PERL5SHELL");
d529 1
a529 1
Perl_do_aspawn(pTHX_ SV *really, SV **mark, SV **sp)
d531 4
d559 1
a559 1

d572 1
a572 1

d585 1
a585 1
		Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't spawn \"%s\": %s", argv[0], strerror(errno));
d596 2
a597 26
/* returns pointer to the next unquoted space or the end of the string */
static char*
find_next_space(const char *s)
{
    bool in_quotes = FALSE;
    while (*s) {
	/* ignore doubled backslashes, or backslash+quote */
	if (*s == '\\' && (s[1] == '\\' || s[1] == '"')) {
	    s += 2;
	}
	/* keep track of when we're within quotes */
	else if (*s == '"') {
	    s++;
	    in_quotes = !in_quotes;
	}
	/* break it up only at spaces that aren't in quotes */
	else if (!in_quotes && isSPACE(*s))
	    return (char*)s;
	else
	    s++;
    }
    return (char*)s;
}

static int
do_spawn2(pTHX_ char *cmd, int exectype)
d599 1
d619 2
a620 1
	    s = find_next_space(s);
d677 1
a677 1
		Perl_warner(aTHX_ packWARN(WARN_EXEC), "Can't %s \"%s\": %s",
d690 1
a690 1
Perl_do_spawn(pTHX_ char *cmd)
d692 1
a692 1
    return do_spawn2(aTHX_ cmd, EXECF_SPAWN);
d696 1
a696 1
Perl_do_spawn_nowait(pTHX_ char *cmd)
d698 1
a698 1
    return do_spawn2(aTHX_ cmd, EXECF_SPAWN_NOWAIT);
d704 1
a704 1
    do_spawn2(aTHX_ cmd, EXECF_EXEC);
d715 1
a715 1
    dTHX;
d720 1
a720 1
    Stat_t		sbuf;
d827 1
a827 1
	    dTHX;
d853 1
a853 1
		 * new name and its null terminator */
d868 1
a868 1
    }
d901 1
a901 1
    dTHX;
d950 1
a950 1
{
d963 1
a963 1
    dTHX;
a977 25
/*
 * XXX this needs strengthening  (for PerlIO)
 *   -- BKS, 11-11-200
*/
int mkstemp(const char *path)
{
    dTHX;
    char buf[MAX_PATH+1];
    int i = 0, fd = -1;

retry:
    if (i++ > 10) { /* give up */
	errno = ENOENT;
	return -1;
    }
    if (!GetTempFileNameA((LPCSTR)path, "plr", 1, buf)) {
	errno = ENOENT;
	return -1;
    }
    fd = PerlLIO_open3(buf, O_CREAT|O_RDWR|O_EXCL, 0600);
    if (fd == -1)
	goto retry;
    return fd;
}

d981 1
a981 1
    dTHX;
d984 1
a984 1
	if ((int)w32_child_pids[child] == pid)
d994 1
a994 1
	dTHX;
d1008 1
a1008 1
    dTHX;
d1011 1
a1011 1
	if ((int)w32_pseudo_child_pids[child] == pid)
d1021 1
a1021 1
	dTHX;
d1035 1
a1035 1
    dTHX;
d1043 2
d1046 2
a1047 3
	    switch (sig) {
	    case 0:
		/* "Does process exist?" use of kill */
d1049 1
a1049 17
	    case 9:
                /* kill -9 style un-graceful exit */
	    	if (TerminateThread(hProcess, sig)) {
		    remove_dead_pseudo_process(child);
		    return 0;
	    	}
		break;
	    default:
	      /* We fake signals to pseudo-processes using Win32
	       * message queue.  In Win9X the pids are negative already. */
	      if (PostThreadMessage(IsWin95() ? pid : -pid,WM_USER,sig,0)) {
		    /* It might be us ... */
		    PERL_ASYNC_CHECK();
		    return 0;
		}
		break;
            }
d1061 5
a1065 4
            hProcess = w32_child_handles[child];
	    switch(sig) {
	    case 0:
		/* "Does process exist?" use of kill */
d1067 1
a1067 12
	    case 2:
		if (GenerateConsoleCtrlEvent(CTRL_C_EVENT,pid))
		    return 0;
		break;
	    default: /* For now be backwards compatible with perl5.6 */
	    case 9:
	        if (TerminateProcess(hProcess, sig)) {
		    remove_dead_process(child);
		    return 0;
	    	}
		break;
            }
d1074 4
a1077 3
		switch(sig) {
		case 0:
		    /* "Does process exist?" use of kill */
a1078 10
		case 2:
		    if (GenerateConsoleCtrlEvent(CTRL_C_EVENT,pid))
			return 0;
		    break;
		default: /* For now be backwards compatible with perl5.6 */
                case 9:
		    if (TerminateProcess(hProcess, sig)) {
			CloseHandle(hProcess);
			return 0;
		    }
d1087 11
d1099 1
a1099 1
win32_stat(const char *path, Stat_t *sbuf)
d1101 2
a1102 2
    dTHX;
    char	buffer[MAX_PATH+1];
d1156 1
a1156 5
#if defined(WIN64) || defined(USE_LARGE_FILES)
	res = _wstati64(pwbuffer, sbuf);
#else
	res = _wstat(pwbuffer, (struct _stat*)sbuf);
#endif
a1158 3
#if defined(WIN64) || defined(USE_LARGE_FILES)
	res = _stati64(path, sbuf);
#else
a1159 1
#endif
d1177 1
a1177 1
	    Zero(sbuf, 1, Stat_t);
a1222 12
#define isSLASH(c) ((c) == '/' || (c) == '\\')
#define SKIP_SLASHES(s) \
    STMT_START {				\
	while (*(s) && isSLASH(*(s)))		\
	    ++(s);				\
    } STMT_END
#define COPY_NONSLASHES(d,s) \
    STMT_START {				\
	while (*(s) && !isSLASH(*(s)))		\
	    *(d)++ = *(s)++;			\
    } STMT_END

d1238 3
a1240 1
    if (isALPHA(path[0]) && path[1] == ':') {
d1246 3
a1248 1
    else if (isSLASH(path[0]) && isSLASH(path[1])) {
d1252 3
a1254 2
	SKIP_SLASHES(start);
	COPY_NONSLASHES(tmpstart,start);	/* copy machine name */
d1256 5
a1260 3
	    *tmpstart++ = *start++;
	    SKIP_SLASHES(start);
	    COPY_NONSLASHES(tmpstart,start);	/* copy share name */
d1263 3
d1267 4
a1270 22
    while (*start) {
	/* copy initial slash, if any */
	if (isSLASH(*start)) {
	    *tmpstart++ = *start++;
	    *tmpstart = '\0';
	    SKIP_SLASHES(start);
	}

	/* FindFirstFile() expands "." and "..", so we need to pass
	 * those through unmolested */
	if (*start == '.'
	    && (!start[1] || isSLASH(start[1])
		|| (start[1] == '.' && (!start[2] || isSLASH(start[2])))))
	{
	    COPY_NONSLASHES(tmpstart,start);	/* copy "." or ".." */
	    *tmpstart = '\0';
	    continue;
	}

	/* if this is the end, bust outta here */
	if (!*start)
	    break;
d1272 2
a1273 2
	/* now we're at a non-slash; walk up to next slash */
	while (*start && !isSLASH(*start))
d1275 1
a1277 1
	sep = *start;
a1279 1
	*start = sep;
d1281 7
a1287 11
	    STRLEN len = strlen(fdata.cFileName);
	    if ((STRLEN)(tmpbuf + sizeof(tmpbuf) - tmpstart) > len) {
		strcpy(tmpstart, fdata.cFileName);
		tmpstart += len;
		FindClose(fhand);
	    }
	    else {
		FindClose(fhand);
		errno = ERANGE;
		return Nullch;
	    }
d1292 1
a1292 1
	    errno = EINVAL;
d1303 1
a1303 1
    dTHX;
d1352 1
a1352 1
    dTHX;
d1417 1
a1417 2
    clock_t process_time_so_far = clock();
    if (GetProcessTimes(GetCurrentProcess(), &dummy, &dummy,
d1423 2
a1424 1
    } else {
d1426 2
a1427 1
	timebuf->tms_utime = process_time_so_far;
d1432 1
a1432 1
    return process_time_so_far;
d1461 1
a1461 1
    dTHX;
d1506 1
a1506 1
    dTHX;
a1560 32
typedef union {
    unsigned __int64	ft_i64;
    FILETIME		ft_val;
} FT_t;

#ifdef __GNUC__
#define Const64(x) x##LL
#else
#define Const64(x) x##i64
#endif
/* Number of 100 nanosecond units from 1/1/1601 to 1/1/1970 */
#define EPOCH_BIAS  Const64(116444736000000000)

/* NOTE: This does not compute the timezone info (doing so can be expensive,
 * and appears to be unsupported even by glibc) */
DllExport int
win32_gettimeofday(struct timeval *tp, void *not_used)
{
    FT_t ft;

    /* this returns time in 100-nanosecond units  (i.e. tens of usecs) */
    GetSystemTimeAsFileTime(&ft.ft_val);

    /* seconds since epoch */
    tp->tv_sec = (long)((ft.ft_i64 - EPOCH_BIAS) / Const64(10000000));

    /* microseconds remaining */
    tp->tv_usec = (long)((ft.ft_i64 / Const64(10)) % Const64(1000000));

    return 0;
}

a1626 1
	DWORD procarch;
d1630 2
a1631 3
#if (defined(__BORLANDC__)&&(__BORLANDC__<=0x520)) \
 || (defined(__MINGW32__) && !defined(_ANONYMOUS_UNION))
	procarch = info.u.s.wProcessorArchitecture;
d1633 1
a1633 1
	procarch = info.wProcessorArchitecture;
a1634 1
	switch (procarch) {
d1643 1
a1643 30
#ifdef PROCESSOR_ARCHITECTURE_SHX
	case PROCESSOR_ARCHITECTURE_SHX:
	    arch = "shx"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_ARM
	case PROCESSOR_ARCHITECTURE_ARM:
	    arch = "arm"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_IA64
	case PROCESSOR_ARCHITECTURE_IA64:
	    arch = "ia64"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_ALPHA64
	case PROCESSOR_ARCHITECTURE_ALPHA64:
	    arch = "alpha64"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_MSIL
	case PROCESSOR_ARCHITECTURE_MSIL:
	    arch = "msil"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_AMD64
	case PROCESSOR_ARCHITECTURE_AMD64:
	    arch = "amd64"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_IA32_ON_WIN64
	case PROCESSOR_ARCHITECTURE_IA32_ON_WIN64:
	    arch = "ia32-64"; break;
#endif
#ifdef PROCESSOR_ARCHITECTURE_UNKNOWN
	case PROCESSOR_ARCHITECTURE_UNKNOWN:
a1644 5
#endif
	default:
	    sprintf(name->machine, "unknown(0x%x)", procarch);
	    arch = name->machine;
	    break;
d1646 1
a1646 2
	if (name->machine != arch)
	    strcpy(name->machine, arch);
a1650 211
/* Timing related stuff */

int
do_raise(pTHX_ int sig) 
{
    if (sig < SIG_SIZE) {
	Sighandler_t handler = w32_sighandler[sig];
	if (handler == SIG_IGN) {
	    return 0;
	}
	else if (handler != SIG_DFL) {
	    (*handler)(sig);
	    return 0;
	}
	else {
	    /* Choose correct default behaviour */
	    switch (sig) {
#ifdef SIGCLD
		case SIGCLD:
#endif
#ifdef SIGCHLD
		case SIGCHLD:
#endif
		case 0:
		    return 0;
		case SIGTERM:
		default:
		    break;
	    }
	}
    }
    /* Tell caller to exit thread/process as approriate */
    return 1;
}

void
sig_terminate(pTHX_ int sig)
{
    Perl_warn(aTHX_ "Terminating on signal SIG%s(%d)\n",PL_sig_name[sig], sig);
    /* exit() seems to be safe, my_exit() or die() is a problem in ^C 
       thread 
     */
    exit(sig);
}

DllExport int
win32_async_check(pTHX)
{
    MSG msg;
    int ours = 1;
    /* Passing PeekMessage -1 as HWND (2nd arg) only get PostThreadMessage() messages
     * and ignores window messages - should co-exist better with windows apps e.g. Tk
     */
    while (PeekMessage(&msg, (HWND)-1, 0, 0, PM_REMOVE|PM_NOYIELD)) {
	int sig;
	switch(msg.message) {

#if 0
    /* Perhaps some other messages could map to signals ? ... */
        case WM_CLOSE:
        case WM_QUIT:
	    /* Treat WM_QUIT like SIGHUP?  */
	    sig = SIGHUP;
	    goto Raise;
	    break;
#endif

	/* We use WM_USER to fake kill() with other signals */
	case WM_USER: {
	    sig = msg.wParam;
	Raise:
	    if (do_raise(aTHX_ sig)) {
		   sig_terminate(aTHX_ sig);
	    }
	    break;
	}

	case WM_TIMER: {
	    /* alarm() is a one-shot but SetTimer() repeats so kill it */
	    if (w32_timerid) {
	    	KillTimer(NULL,w32_timerid);
	    	w32_timerid=0;
	    }
	    /* Now fake a call to signal handler */
	    if (do_raise(aTHX_ 14)) {
	    	sig_terminate(aTHX_ 14);
	    }
	    break;
	}

	/* Otherwise do normal Win32 thing - in case it is useful */
	default:
	    TranslateMessage(&msg);
	    DispatchMessage(&msg);
	    ours = 0;
	    break;
	}
    }
    w32_poll_count = 0;

    /* Above or other stuff may have set a signal flag */
    if (PL_sig_pending) {
	despatch_signals();
    }
    return ours;
}

DllExport DWORD
win32_msgwait(pTHX_ DWORD count, LPHANDLE handles, DWORD timeout, LPDWORD resultp)
{
    /* We may need several goes at this - so compute when we stop */
    DWORD ticks = 0;
    if (timeout != INFINITE) {
	ticks = GetTickCount();
	timeout += ticks;
    }
    while (1) {
	DWORD result = MsgWaitForMultipleObjects(count,handles,FALSE,timeout-ticks, QS_ALLEVENTS);
	if (resultp)
	   *resultp = result;
	if (result == WAIT_TIMEOUT) {
	    /* Ran out of time - explicit return of zero to avoid -ve if we
	       have scheduling issues
             */
	    return 0;
	}
	if (timeout != INFINITE) {
	    ticks = GetTickCount();
        }
	if (result == WAIT_OBJECT_0 + count) {
	    /* Message has arrived - check it */
	    if (win32_async_check(aTHX)) {
		/* was one of ours */
		break;
	    }
	}
	else {
	   /* Not timeout or message - one of handles is ready */
	   break;
	}
    }
    /* compute time left to wait */
    ticks = timeout - ticks;
    /* If we are past the end say zero */
    return (ticks > 0) ? ticks : 0;
}

int
win32_internal_wait(int *status, DWORD timeout)
{
    /* XXX this wait emulation only knows about processes
     * spawned via win32_spawnvp(P_NOWAIT, ...).
     */
    dTHX;
    int i, retval;
    DWORD exitcode, waitcode;

#ifdef USE_ITHREADS
    if (w32_num_pseudo_children) {
	win32_msgwait(aTHX_ w32_num_pseudo_children, w32_pseudo_child_handles,
		      timeout, &waitcode);
        /* Time out here if there are no other children to wait for. */
	if (waitcode == WAIT_TIMEOUT) {
	    if (!w32_num_children) {
		return 0;
	    }
	}
	else if (waitcode != WAIT_FAILED) {
	    if (waitcode >= WAIT_ABANDONED_0
		&& waitcode < WAIT_ABANDONED_0 + w32_num_pseudo_children)
		i = waitcode - WAIT_ABANDONED_0;
	    else
		i = waitcode - WAIT_OBJECT_0;
	    if (GetExitCodeThread(w32_pseudo_child_handles[i], &exitcode)) {
		*status = (int)((exitcode & 0xff) << 8);
		retval = (int)w32_pseudo_child_pids[i];
		remove_dead_pseudo_process(i);
		return -retval;
	    }
	}
    }
#endif

    if (!w32_num_children) {
	errno = ECHILD;
	return -1;
    }

    /* if a child exists, wait for it to die */
    win32_msgwait(aTHX_ w32_num_children, w32_child_handles, timeout, &waitcode);
    if (waitcode == WAIT_TIMEOUT) {
	return 0;
    }
    if (waitcode != WAIT_FAILED) {
	if (waitcode >= WAIT_ABANDONED_0
	    && waitcode < WAIT_ABANDONED_0 + w32_num_children)
	    i = waitcode - WAIT_ABANDONED_0;
	else
	    i = waitcode - WAIT_OBJECT_0;
	if (GetExitCodeProcess(w32_child_handles[i], &exitcode) ) {
	    *status = (int)((exitcode & 0xff) << 8);
	    retval = (int)w32_child_pids[i];
	    remove_dead_process(i);
	    return retval;
	}
    }

    errno = GetLastError();
    return -1;
}

d1654 1
a1654 1
    dTHX;
d1659 1
a1659 1
	return win32_internal_wait(status, timeout);
d1665 1
a1665 2
	    DWORD waitcode;
	    win32_msgwait(aTHX_ 1, &hThread, timeout, &waitcode);
d1669 1
a1669 1
	    else if (waitcode == WAIT_OBJECT_0) {
d1692 1
a1692 1
	    win32_msgwait(aTHX_ 1, &hProcess, timeout, &waitcode);
d1696 1
a1696 1
	    else if (waitcode == WAIT_OBJECT_0) {
d1712 1
a1712 1
		win32_msgwait(aTHX_ 1, &hProcess, timeout, &waitcode);
d1716 1
a1716 1
		else if (waitcode == WAIT_OBJECT_0) {
d1729 1
a1729 1
    return retval >= 0 ? pid : retval;
d1735 56
a1790 1
    return win32_internal_wait(status, INFINITE);
d1793 5
a1797 2
DllExport unsigned int
win32_sleep(unsigned int t)
d1799 4
a1802 3
    dTHX;
    /* Win32 times are in ms so *1000 in and /1000 out */
    return win32_msgwait(aTHX_ 0, NULL, t*1000, NULL)/1000;
d1804 1
d1809 2
a1810 1
    /*
d1812 2
a1813 2
     * which does whatever receiving SIGALRM would do
     * we cannot use SIGALRM even via raise() as it is not
d1815 20
a1834 11
     */
    dTHX;
    if (sec) {
	w32_timerid = SetTimer(NULL,w32_timerid,sec*1000,NULL);
    }
    else {
    	if (w32_timerid) {
            KillTimer(NULL,w32_timerid);
  	    w32_timerid=0;
    	}
    }
d1845 1
a1845 1
    dTHX;
d1863 1
a1863 1
*int my_open_osfhandle(intptr_t osfhandle, int flags) - open C Runtime file handle
d1874 1
a1874 1
*       intptr_t osfhandle - Win32 HANDLE to associate with C Runtime file handle.
d1898 1
a1898 1
    int fh = _open_osfhandle((intptr_t)hF, 0);
d1907 1
a1907 1
my_open_osfhandle(intptr_t osfhandle, int flags)
d1957 1
a1957 1
	dTHX;
d2042 1
a2042 1
 * Since the errors returned by the socket error function
d2048 1
a2048 1
win32_strerror(int e)
d2050 1
a2050 1
#if !defined __BORLANDC__ && !defined __MINGW32__      /* compiler intolerance */
d2056 1
a2056 1
        dTHX;
d2062 1
a2062 1
			  sizeof(w32_strerror_buffer), NULL) == 0)
d2096 1
a2096 1
	dTHX;
d2102 1
d2150 1
a2150 1
    dTHX;
d2153 1
a2153 1

d2181 1
a2181 1
    dTHX;
d2199 1
a2199 1
    dTHX;
d2261 1
a2261 1
DllExport Off_t
a2263 6
#if defined(WIN64) || defined(USE_LARGE_FILES)
    fpos_t pos;
    if (fgetpos(pf, &pos))
	return -1;
    return (Off_t)pos;
#else
a2264 1
#endif
d2268 1
a2268 1
win32_fseek(FILE *pf, Off_t offset,int origin)
a2269 21
#if defined(WIN64) || defined(USE_LARGE_FILES)
    fpos_t pos;
    switch (origin) {
    case SEEK_CUR:
	if (fgetpos(pf, &pos))
	    return -1;
	offset += pos;
	break;
    case SEEK_END:
	fseek(pf, 0, SEEK_END);
	pos = _telli64(fileno(pf));
	offset += pos;
	break;
    case SEEK_SET:
	break;
    default:
	errno = EINVAL;
	return -1;
    }
    return fsetpos(pf, &offset);
#else
a2270 1
#endif
d2295 1
a2295 28
    dTHX;
    char prefix[MAX_PATH+1];
    char filename[MAX_PATH+1];
    DWORD len = GetTempPath(MAX_PATH, prefix);
    if (len && len < MAX_PATH) {
	if (GetTempFileName(prefix, "plx", 0, filename)) {
	    HANDLE fh = CreateFile(filename,
				   DELETE | GENERIC_READ | GENERIC_WRITE,
				   0,
				   NULL,
				   CREATE_ALWAYS,
				   FILE_ATTRIBUTE_NORMAL
				   | FILE_FLAG_DELETE_ON_CLOSE,
				   NULL);
	    if (fh != INVALID_HANDLE_VALUE) {
		int fd = win32_open_osfhandle((intptr_t)fh, 0);
		if (fd >= 0) {
#if defined(__BORLANDC__)
        	    setmode(fd,O_BINARY);
#endif
		    DEBUG_p(PerlIO_printf(Perl_debug_log,
					  "Created tmpfile=%s\n",filename));
		    return fdopen(fd, "w+b");
		}
	    }
	}
    }
    return NULL;
d2306 1
a2306 1
win32_fstat(int fd, Stat_t *sbufptr)
d2312 1
a2312 1
     */
a2334 8
DllExport PerlIO*
win32_popenlist(const char *mode, IV narg, SV **args)
{
 dTHX;
 Perl_croak(aTHX_ "List form of pipe open not implemented");
 return NULL;
}

a2336 2
 *
 * changed to return PerlIO* rather than FILE * by BKS, 11-11-2000
d2339 1
a2339 1
DllExport PerlIO*
a2344 1
    dTHX;
a2349 3
    DWORD nhandle;
    HANDLE old_h;
    int lock_held = 0;
a2355 1
	nhandle = STD_INPUT_HANDLE;
a2360 1
	nhandle = STD_OUTPUT_HANDLE;
d2376 1
a2376 1
    if (win32_pipe(p, 512, ourmode) == -1)
a2390 6
    /* save the old std handle, and set the std handle */
    OP_REFCNT_LOCK;
    lock_held = 1;
    old_h = GetStdHandle(nhandle);
    SetStdHandle(nhandle, (HANDLE)_get_osfhandle(stdfd));

d2393 1
a2393 1
	dTHX;
a2396 7
	/* restore the old std handle */
	if (lock_held) {
	    SetStdHandle(nhandle, old_h);
	    OP_REFCNT_UNLOCK;
	    lock_held = 0;
	}

d2413 1
a2413 1
    return (PerlIO_fdopen(p[parent], (char *)mode));
a2418 5
    if (lock_held) {
	SetStdHandle(nhandle, old_h);
	OP_REFCNT_UNLOCK;
	lock_held = 0;
    }
d2433 1
a2433 1
win32_pclose(PerlIO *pf)
d2438 1
a2438 1
    dTHX;
d2443 1
a2443 1
    sv = *av_fetch(w32_fdpid, PerlIO_fileno(pf), TRUE);
d2455 1
a2455 5
#ifdef USE_PERLIO
    PerlIO_close(pf);
#else
    fclose(pf);
#endif
d2504 1
a2504 2
#if defined(__BORLANDC__) \
 ||(defined(__MINGW32__) && !defined(_ANONYMOUS_UNION))
d2527 1
a2527 1
    dTHX;
d2560 1
a2560 1
    dTHX;
d2683 2
a2684 2
DllExport Off_t
win32_lseek(int fd, Off_t offset, int origin)
a2685 3
#if defined(WIN64) || defined(USE_LARGE_FILES)
    return _lseeki64(fd, offset, origin);
#else
a2686 1
#endif
d2689 1
a2689 1
DllExport Off_t
a2691 3
#if defined(WIN64) || defined(USE_LARGE_FILES)
    return _telli64(fd);
#else
a2692 1
#endif
d2698 1
a2698 1
    dTHX;
a2716 3
/* close() that understands socket */
extern int my_close(int);	/* in win32sck.c */

d2720 1
a2720 1
    return my_close(fd);
d2928 1
a2928 1
functionexit:
d2956 1
a2956 1
    dTHX;
d2968 1
a2968 1
    dTHX;
d2980 1
a2980 5
    dTHX;
    if (!dir) {
	errno = ENOENT;
	return -1;
    }
d2992 1
a2992 1
    dTHX;
d3004 1
a3004 1
    dTHX;
d3015 1
a3015 1
create_command_line(char *cname, STRLEN clen, const char * const *args)
d3017 4
a3020 60
    dTHX;
    int index, argc;
    char *cmd, *ptr;
    const char *arg;
    STRLEN len = 0;
    bool bat_file = FALSE;
    bool cmd_shell = FALSE;
    bool dumb_shell = FALSE;
    bool extra_quotes = FALSE;
    bool quote_next = FALSE;

    if (!cname)
	cname = (char*)args[0];

    /* The NT cmd.exe shell has the following peculiarity that needs to be
     * worked around.  It strips a leading and trailing dquote when any
     * of the following is true:
     *    1. the /S switch was used
     *    2. there are more than two dquotes
     *    3. there is a special character from this set: &<>()@@^|
     *    4. no whitespace characters within the two dquotes
     *    5. string between two dquotes isn't an executable file
     * To work around this, we always add a leading and trailing dquote
     * to the string, if the first argument is either "cmd.exe" or "cmd",
     * and there were at least two or more arguments passed to cmd.exe
     * (not including switches).
     * XXX the above rules (from "cmd /?") don't seem to be applied
     * always, making for the convolutions below :-(
     */
    if (cname) {
	if (!clen)
	    clen = strlen(cname);

	if (clen > 4
	    && (stricmp(&cname[clen-4], ".bat") == 0
		|| (IsWinNT() && stricmp(&cname[clen-4], ".cmd") == 0)))
	{
	    bat_file = TRUE;
	    len += 3;
	}
	else {
	    char *exe = strrchr(cname, '/');
	    char *exe2 = strrchr(cname, '\\');
	    if (exe2 > exe)
		exe = exe2;
	    if (exe)
		++exe;
	    else
		exe = cname;
	    if (stricmp(exe, "cmd.exe") == 0 || stricmp(exe, "cmd") == 0) {
		cmd_shell = TRUE;
		len += 3;
	    }
	    else if (stricmp(exe, "command.com") == 0
		     || stricmp(exe, "command") == 0)
	    {
		dumb_shell = TRUE;
	    }
	}
    }
d3022 2
a3023 9
    DEBUG_p(PerlIO_printf(Perl_debug_log, "Args "));
    for (index = 0; (arg = (char*)args[index]) != NULL; ++index) {
	STRLEN curlen = strlen(arg);
	if (!(arg[0] == '"' && arg[curlen-1] == '"'))
	    len += 2;	/* assume quoting needed (worst case) */
	len += curlen + 1;
	DEBUG_p(PerlIO_printf(Perl_debug_log, "[%s]",arg));
    }
    DEBUG_p(PerlIO_printf(Perl_debug_log, "\n"));
a3024 1
    argc = index;
d3027 1
a3027 5

    if (bat_file) {
	*ptr++ = '"';
	extra_quotes = TRUE;
    }
d3030 2
a3031 33
	bool do_quote = 0;
	STRLEN curlen = strlen(arg);

	/* we want to protect empty arguments and ones with spaces with
	 * dquotes, but only if they aren't already there */
	if (!dumb_shell) {
	    if (!curlen) {
		do_quote = 1;
	    }
	    else if (quote_next) {
		/* see if it really is multiple arguments pretending to
		 * be one and force a set of quotes around it */
		if (*find_next_space(arg))
		    do_quote = 1;
	    }
	    else if (!(arg[0] == '"' && curlen > 1 && arg[curlen-1] == '"')) {
		STRLEN i = 0;
		while (i < curlen) {
		    if (isSPACE(arg[i])) {
			do_quote = 1;
		    }
		    else if (arg[i] == '"') {
			do_quote = 0;
			break;
		    }
		    i++;
		}
	    }
	}

	if (do_quote)
	    *ptr++ = '"';

a3032 25
	ptr += curlen;

	if (do_quote)
	    *ptr++ = '"';

	if (args[index+1])
	    *ptr++ = ' ';

    	if (!extra_quotes
	    && cmd_shell
	    && (stricmp(arg, "/x/c") == 0 || stricmp(arg, "/c") == 0))
	{
	    /* is there a next argument? */
	    if (args[index+1]) {
		/* are there two or more next arguments? */
		if (args[index+2]) {
		    *ptr++ = '"';
		    extra_quotes = TRUE;
		}
		else {
		    /* single argument, force quoting if it has spaces */
		    quote_next = TRUE;
		}
	    }
	}
a3034 5
    if (extra_quotes)
	*ptr++ = '"';

    *ptr = '\0';

d3041 1
a3041 1
    dTHX;
d3058 1
a3058 1
    pathstr = PerlEnv_getenv("PATH");
d3100 1
a3100 1
		    if ((STRLEN)(curfullcmd-fullcmd) < MAX_PATH-cmdlen-5)
d3108 1
a3108 1
		if ((STRLEN)(curfullcmd-fullcmd) < MAX_PATH-cmdlen-5)
d3121 1
a3121 1

d3132 2
a3133 2
DllExport void*
win32_get_childenv(void)
d3138 2
a3139 2
DllExport void
win32_free_childenv(void* d)
d3143 2
a3144 2
DllExport void
win32_clearenv(void)
d3146 1
a3146 21
    char *envv = GetEnvironmentStrings();
    char *cur = envv;
    STRLEN len;
    while (*cur) {
	char *end = strchr(cur,'=');
	if (end && end != cur) {
	    *end = '\0';
	    SetEnvironmentVariable(cur, NULL);
	    *end = '=';
	    cur = end + strlen(end+1)+2;
	}
	else if ((len = strlen(cur)))
	    cur += len+1;
    }
    FreeEnvironmentStrings(envv);
}

DllExport char*
win32_get_childdir(void)
{
    dTHX;
d3163 2
a3164 2
DllExport void
win32_free_childdir(char* d)
d3166 1
a3166 1
    dTHX;
d3177 1
a3177 1
 *
d3188 1
a3188 1
    dTHX;
d3196 3
a3198 1
    char *cmd;
a3199 22
    char *cname = (char *)cmdname;
    STRLEN clen = 0;

    if (cname) {
	clen = strlen(cname);
	/* if command name contains dquotes, must remove them */
	if (strchr(cname, '"')) {
	    cmd = cname;
	    New(0,cname,clen+1,char);
	    clen = 0;
	    while (*cmd) {
		if (*cmd != '"') {
		    cname[clen] = *cmd;
		    ++clen;
		}
		++cmd;
	    }
	    cname[clen] = '\0';
	}
    }

    cmd = create_command_line(cname, clen, argv);
a3210 4
	/* Create a new process group so we can use GenerateConsoleCtrlEvent()
	 * in win32_kill()
	 */
        create |= CREATE_NEW_PROCESS_GROUP;
a3211 1

d3224 8
a3231 8
    StartupInfo.dwX		= tbl.dwX;
    StartupInfo.dwY		= tbl.dwY;
    StartupInfo.dwXSize		= tbl.dwXSize;
    StartupInfo.dwYSize		= tbl.dwYSize;
    StartupInfo.dwXCountChars	= tbl.dwXCountChars;
    StartupInfo.dwYCountChars	= tbl.dwYCountChars;
    StartupInfo.dwFillAttribute	= tbl.dwFillAttribute;
    StartupInfo.wShowWindow	= tbl.wShowWindow;
d3235 3
a3237 3
    if (StartupInfo.hStdInput == INVALID_HANDLE_VALUE &&
	StartupInfo.hStdOutput == INVALID_HANDLE_VALUE &&
	StartupInfo.hStdError == INVALID_HANDLE_VALUE)
d3239 1
a3239 1
	create |= CREATE_NEW_CONSOLE;
d3242 1
a3242 5
	StartupInfo.dwFlags |= STARTF_USESTDHANDLES;
    }
    if (w32_use_showwindow) {
        StartupInfo.dwFlags |= STARTF_USESHOWWINDOW;
        StartupInfo.wShowWindow = w32_showwindow;
a3244 2
    DEBUG_p(PerlIO_printf(Perl_debug_log, "Spawning [%s] with [%s]\n",
			  cname,cmd));
d3246 1
a3246 1
    if (!CreateProcess(cname,		/* search PATH to find executable */
d3264 1
a3264 1
	    fullcmd = qualified_path(cname);
d3266 1
a3266 6
		if (cname != cmdname)
		    Safefree(cname);
		cname = fullcmd;
		DEBUG_p(PerlIO_printf(Perl_debug_log,
				      "Retrying [%s] with same args\n",
				      cname));
d3287 1
a3287 4
	win32_msgwait(aTHX_ 1, &ProcessInformation.hProcess, INFINITE, NULL);
	/* FIXME: if msgwait returned due to message perhaps forward the
	   "signal" to the process
         */
d3299 1
a3299 2
    if (cname != cmdname)
	Safefree(cname);
d3308 1
a3308 1
    dTHX;
d3321 1
a3321 1
    dTHX;
d3324 2
a3325 9
    if (w32_pseudo_id) {
	int status = win32_spawnvp(P_WAIT, cmdname, (char *const *)argv);
	if (status != -1) {
	    my_exit(status);
	    return 0;
	}
	else
	    return status;
    }
d3406 6
a3411 6
static char *committed = NULL;		/* XXX threadead */
static char *base      = NULL;		/* XXX threadead */
static char *reserved  = NULL;		/* XXX threadead */
static char *brk       = NULL;		/* XXX threadead */
static DWORD pagesize  = 0;		/* XXX threadead */
static DWORD allocsize = 0;		/* XXX threadead */
d3414 1
a3414 1
sbrk(ptrdiff_t need)
d3427 1
a3427 1
  * block is denied so reserve big blocks - this is only
d3441 1
a3441 1
   /* Reserve some (more) space
d3506 2
a3507 2
DllExport int
win32_open_osfhandle(intptr_t handle, int flags)
d3516 1
a3516 1
DllExport intptr_t
d3519 1
a3519 53
    return (intptr_t)_get_osfhandle(fd);
}

DllExport FILE *
win32_fdupopen(FILE *pf)
{
    FILE* pfdup;
    fpos_t pos;
    char mode[3];
    int fileno = win32_dup(win32_fileno(pf));

    /* open the file in the same mode */
#ifdef __BORLANDC__
    if((pf)->flags & _F_READ) {
	mode[0] = 'r';
	mode[1] = 0;
    }
    else if((pf)->flags & _F_WRIT) {
	mode[0] = 'a';
	mode[1] = 0;
    }
    else if((pf)->flags & _F_RDWR) {
	mode[0] = 'r';
	mode[1] = '+';
	mode[2] = 0;
    }
#else
    if((pf)->_flag & _IOREAD) {
	mode[0] = 'r';
	mode[1] = 0;
    }
    else if((pf)->_flag & _IOWRT) {
	mode[0] = 'a';
	mode[1] = 0;
    }
    else if((pf)->_flag & _IORW) {
	mode[0] = 'r';
	mode[1] = '+';
	mode[2] = 0;
    }
#endif

    /* it appears that the binmode is attached to the
     * file descriptor so binmode files will be handled
     * correctly
     */
    pfdup = win32_fdopen(fileno, mode);

    /* move the file pointer to the same position */
    if (!fgetpos(pf, &pos)) {
	fsetpos(pfdup, &pos);
    }
    return pfdup;
d3525 1
a3525 1
    dTHX;
a3561 26
XS(w32_SetChildShowWindow)
{
    dXSARGS;
    BOOL use_showwindow = w32_use_showwindow;
    /* use "unsigned short" because Perl has redefined "WORD" */
    unsigned short showwindow = w32_showwindow;

    if (items > 1)
	Perl_croak(aTHX_ "usage: Win32::SetChildShowWindow($showwindow)");

    if (items == 0 || !SvOK(ST(0)))
        w32_use_showwindow = FALSE;
    else {
        w32_use_showwindow = TRUE;
        w32_showwindow = (unsigned short)SvIV(ST(0));
    }

    EXTEND(SP, 1);
    if (use_showwindow)
        ST(0) = sv_2mortal(newSViv(showwindow));
    else
        ST(0) = &PL_sv_undef;
    XSRETURN(1);
}

static
d3567 4
a3570 4
    /*
     * If ptr != Nullch
     *   then it worked, set PV valid,
     *   else return 'undef'
a3576 4
#ifndef INCOMPLETE_TAINTS
	SvTAINTED_on(sv);
#endif

a3833 2
    void *env;
    char *dir;
a3843 3
    env = PerlEnv_get_childenv();
    dir = PerlEnv_get_childdir();

d3856 2
a3857 2
		env,			/* Inherit our environment block */
		dir,			/* Inherit our currrent directory */
a3867 2
    PerlEnv_free_childenv(env);
    PerlEnv_free_childdir(dir);
d4011 1
a4011 1
    dTHX;
a4035 1
    newXS("Win32::SetChildShowWindow", w32_SetChildShowWindow, file);
a4048 77
void *
win32_signal_context(void)
{
    dTHX;
#ifdef MULTIPLICITY
    if (!my_perl) {
	my_perl = PL_curinterp;
	PERL_SET_THX(my_perl);
    }
    return my_perl;
#else
#ifdef USE_5005THREADS
    return aTHX;
#else
    return PL_curinterp;
#endif
#endif
}


BOOL WINAPI
win32_ctrlhandler(DWORD dwCtrlType)
{
#ifdef MULTIPLICITY
    dTHXa(PERL_GET_SIG_CONTEXT);

    if (!my_perl)
	return FALSE;
#else
#ifdef USE_5005THREADS
    dTHX;
#endif
#endif

    switch(dwCtrlType) {
    case CTRL_CLOSE_EVENT:
     /*  A signal that the system sends to all processes attached to a console when
         the user closes the console (either by choosing the Close command from the
         console window's System menu, or by choosing the End Task command from the
         Task List
      */
	if (do_raise(aTHX_ 1))	      /* SIGHUP */
	    sig_terminate(aTHX_ 1);
	return TRUE;

    case CTRL_C_EVENT:
	/*  A CTRL+c signal was received */
	if (do_raise(aTHX_ SIGINT))
	    sig_terminate(aTHX_ SIGINT);
	return TRUE;

    case CTRL_BREAK_EVENT:
	/*  A CTRL+BREAK signal was received */
	if (do_raise(aTHX_ SIGBREAK))
	    sig_terminate(aTHX_ SIGBREAK);
	return TRUE;

    case CTRL_LOGOFF_EVENT:
      /*  A signal that the system sends to all console processes when a user is logging
          off. This signal does not indicate which user is logging off, so no
          assumptions can be made.
       */
	break;
    case CTRL_SHUTDOWN_EVENT:
      /*  A signal that the system sends to all console processes when the system is
          shutting down.
       */
	if (do_raise(aTHX_ SIGTERM))
	    sig_terminate(aTHX_ SIGTERM);
	return TRUE;
    default:
	break;
    }
    return FALSE;
}


a4071 21
Sighandler_t
win32_signal(int sig, Sighandler_t subcode)
{
    dTHX;
    if (sig < SIG_SIZE) {
	int save_errno = errno;
	Sighandler_t result = signal(sig, subcode);
	if (result == SIG_ERR) {
	    result = w32_sighandler[sig];
	    errno = save_errno;
	}
	w32_sighandler[sig] = subcode;
	return result;
    }
    else {
	errno = EINVAL;
	return SIG_ERR;
    }
}


d4074 9
a4082 10

static void
win32_csighandler(int sig)
{
#if 0
    dTHXa(PERL_GET_SIG_CONTEXT);
    Perl_warn(aTHX_ "Got signal %d",sig);
#endif
    /* Does nothing */
}
a4086 1
    int i;
a4098 16
    w32_timerid                 = 0;
    w32_poll_count              = 0;
    for (i=0; i < SIG_SIZE; i++) {
    	w32_sighandler[i] = SIG_DFL;
    }
#  ifdef MULTIPLICTY
    if (my_perl == PL_curinterp) {
#  else
    {
#  endif
	/* Force C runtime signal stuff to set its console handler */
	signal(SIGINT,&win32_csighandler);
	signal(SIGBREAK,&win32_csighandler);
	/* Push our handler on top */
	SetConsoleCtrlHandler(win32_ctrlhandler,TRUE);
    }
a4107 11
    if (w32_timerid) {
    	KillTimer(NULL,w32_timerid);
    	w32_timerid=0;
    }
#  ifdef MULTIPLICITY
    if (my_perl == PL_curinterp) {
#  else
    {
#  endif
	SetConsoleCtrlHandler(win32_ctrlhandler,FALSE);
    }
a4125 3
    dst->timerid                 = 0;
    dst->poll_count              = 0;
    Copy(src->sigtable,dst->sigtable,SIG_SIZE,Sighandler_t);
d4130 5
d4136 1
a4136 1
win32_free_argvw(pTHX_ void *ptr)
d4148 1
a4148 1
    dTHX;
d4163 1
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d18 1
a18 2
/* GCC-2.95.2/Mingw32-1.1 forgot the WINAPI on CommandLineToArgvW() */
#if defined(__MINGW32__) && (__MINGW32_MAJOR_VERSION==1)	
d63 2
a64 2
#if defined(__MINGW32__) && (__MINGW32_MAJOR_VERSION==1)	
/* Mingw32-1.1 is missing some prototypes */
d508 1
a508 1
				    ? "cmd.exe /x/d/c" : "command.com /c");
a1068 1
    int retval;
a1115 5
            case SIGBREAK:
            case SIGTERM:
                if (GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,pid))
                    return 0;
                break;
a1126 1
            retval = -1;
d1133 1
a1133 2
		    retval = 0;
                    break;
d1136 1
a1136 1
			retval = 0;
a1137 5
                case SIGBREAK:
                case SIGTERM:
                    if (GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT,pid))
                       retval = 0;
                    break;
d1140 4
a1143 3
		    if (TerminateProcess(hProcess, sig))
			retval = 0;
                    break;
a1145 3
            CloseHandle(hProcess);
            if (retval == 0)
                return 0;
d1886 1
a1886 1
	    if (w32_timerid && w32_timerid==msg.wParam) {
a1889 2
            else
		goto FallThrough;
a1898 1
	FallThrough:
a1913 2
/* This function will not return until the timeout has elapsed, or until
 * one of the handles is ready. */
d1938 4
a1941 1
	    (void)win32_async_check(aTHX);
a2081 1
                    CloseHandle(hProcess);
d2618 2
a2619 2
DllExport int
win32_tmpfd(void)
d2643 1
a2643 1
		    return fd;
a2647 9
    return -1;
}

DllExport FILE*
win32_tmpfile(void)
{
    int fd = win32_tmpfd();
    if (fd >= 0)
	return win32_fdopen(fd, "w+b");
a2751 6
    /* save the old std handle (this needs to happen before the
     * dup2(), since that might call SetStdHandle() too) */
    OP_REFCNT_LOCK;
    lock_held = 1;
    old_h = GetStdHandle(nhandle);

d2760 4
a2763 1
    /* set the new std handle (in case dup2() above didn't) */
d2772 1
a2772 6
	/* revert stdfd to whatever it was before */
	if (win32_dup2(oldfd, stdfd) == -1)
	    goto cleanup;

	/* restore the old std handle (this needs to happen after the
	 * dup2(), since that might call SetStdHandle() too */
d2779 4
a3074 49
DllExport int
win32_chsize(int fd, Off_t size)
{
#if defined(WIN64) || defined(USE_LARGE_FILES)
    int retval = 0;
    Off_t cur, end, extend;

    cur = win32_tell(fd);
    if (cur < 0)
	return -1;
    end = win32_lseek(fd, 0, SEEK_END);
    if (end < 0)
	return -1;
    extend = size - end;
    if (extend == 0) {
	/* do nothing */
    }
    else if (extend > 0) {
	/* must grow the file, padding with nulls */
	char b[4096];
	int oldmode = win32_setmode(fd, O_BINARY);
	size_t count;
	memset(b, '\0', sizeof(b));
	do {
	    count = extend >= sizeof(b) ? sizeof(b) : (size_t)extend;
	    count = win32_write(fd, b, count);
	    if (count < 0) {
		retval = -1;
		break;
	    }
	} while ((extend -= count) > 0);
	win32_setmode(fd, oldmode);
    }
    else {
	/* shrink the file */
	win32_lseek(fd, size, SEEK_SET);
	if (!SetEndOfFile((HANDLE)_get_osfhandle(fd))) {
	    errno = EACCES;
	    retval = -1;
	}
    }
finish:
    win32_lseek(fd, cur, SEEK_SET);
    return retval;
#else
    return chsize(fd, size);
#endif
}

d3549 1
a3549 3
	    && curlen >= 2
	    && *arg  == '/'     /* see if arg is "/c", "/x/c", "/x/d/c" etc. */
	    && stricmp(arg+curlen-2, "/c") == 0)
d3921 1
a3921 1
	int status = win32_spawnvp(P_WAIT, cmdname, (const char *const *)argv);
d4379 1
a4379 1
		WideCharToMultiByte(CP_ACP, 0, pwi->wki100_langroup,
d4383 1
a4383 1
		WideCharToMultiByte(CP_ACP, 0, pwi->wki100_computername,
d4438 1
a4438 19
    /* Use explicit struct definition because wSuiteMask and
     * wProductType are not defined in the VC++ 6.0 headers.
     * WORD type has been replaced by unsigned short because
     * WORD is already used by Perl itself.
     */
    struct {
        DWORD dwOSVersionInfoSize;
        DWORD dwMajorVersion;
        DWORD dwMinorVersion;
        DWORD dwBuildNumber;
        DWORD dwPlatformId;
        CHAR  szCSDVersion[128];
        unsigned short wServicePackMajor;
        unsigned short wServicePackMinor;
        unsigned short wSuiteMask;
        BYTE  wProductType;
        BYTE  wReserved;
    }   osver;
    BOOL bEx = TRUE;
d4441 1
a4441 13
        struct {
            DWORD dwOSVersionInfoSize;
            DWORD dwMajorVersion;
            DWORD dwMinorVersion;
            DWORD dwBuildNumber;
            DWORD dwPlatformId;
            WCHAR szCSDVersion[128];
            unsigned short wServicePackMajor;
            unsigned short wServicePackMinor;
            unsigned short wSuiteMask;
            BYTE  wProductType;
            BYTE  wReserved;
        } osverw;
d4443 3
a4445 7
	osverw.dwOSVersionInfoSize = sizeof(osverw);
	if (!GetVersionExW((OSVERSIONINFOW*)&osverw)) {
            bEx = FALSE;
            osverw.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
            if (!GetVersionExW((OSVERSIONINFOW*)&osverw)) {
                XSRETURN_EMPTY;
            }
d4449 4
a4452 8
        osver.dwMajorVersion    = osverw.dwMajorVersion;
        osver.dwMinorVersion    = osverw.dwMinorVersion;
        osver.dwBuildNumber     = osverw.dwBuildNumber;
        osver.dwPlatformId      = osverw.dwPlatformId;
        osver.wServicePackMajor = osverw.wServicePackMajor;
        osver.wServicePackMinor = osverw.wServicePackMinor;
        osver.wSuiteMask        = osverw.wSuiteMask;
        osver.wProductType      = osverw.wProductType;
d4455 3
a4457 7
	osver.dwOSVersionInfoSize = sizeof(osver);
	if (!GetVersionExA((OSVERSIONINFOA*)&osver)) {
            bEx = FALSE;
            osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            if (!GetVersionExA((OSVERSIONINFOA*)&osver)) {
                XSRETURN_EMPTY;
            }
a4464 6
    if (bEx) {
        XPUSHs(newSViv(osver.wServicePackMajor));
        XPUSHs(newSViv(osver.wServicePackMinor));
        XPUSHs(newSViv(osver.wSuiteMask));
        XPUSHs(newSViv(osver.wProductType));
    }
a4596 1
	*SvEND(shortpath) = '\0';
d4630 2
a4631 7
	    if (filepart) {
		XST_mPV(1,filepart);
		len = filepart - SvPVX(fullpath);
	    }
	    else {
		XST_mPVN(1,"",0);
	    }
a4634 1
	*SvEND(fullpath) = '\0';
a4831 7
}

void
Perl_win32_term(void)
{
    OP_REFCNT_TERM;
    MALLOC_TERM;
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d3133 1
a3133 1
	    if ((int)count < 0) {
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@a1184 4
	    if (l >= sizeof(buffer)) {
		errno = ENAMETOOLONG;
		return -1;
	    }
a2580 3
#if defined(__BORLAND__) /* buk */
    return win32_tell( fileno( pf ) );
#else
a2584 1
#endif
a2593 7
#if defined(__BORLANDC__) /* buk */
    return win32_lseek(
        fileno(pf),
        offset,
        origin
        );
#else
a2612 1
#endif
a2620 7
#if defined(__BORLANDC__) && defined(USE_LARGE_FILES) /* buk */
    if( win32_tell(fileno(pf)) == -1L ) {
        errno = EBADF;
        return -1;
    }
    return 0;
#else
a2621 1
#endif
a2626 3
#if defined(__BORLANDC__) && defined(USE_LARGE_FILES) /* buk */
    return win32_lseek(fileno(pf), *p, SEEK_CUR);
#else
a2627 1
#endif
a3159 15
#if defined(__BORLANDC__) /* buk */
    LARGE_INTEGER pos;
    pos.QuadPart = offset;
    pos.LowPart = SetFilePointer(
        (HANDLE)_get_osfhandle(fd),
        pos.LowPart,
        &pos.HighPart,
        origin
    );
    if (pos.LowPart == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR) {
        pos.QuadPart = -1;
    }

    return pos.QuadPart;
#else
a3160 1
#endif
a3169 16
#if defined(__BORLANDC__) /* buk */
    LARGE_INTEGER pos;
    pos.QuadPart = 0;
    pos.LowPart = SetFilePointer(
        (HANDLE)_get_osfhandle(fd),
        pos.LowPart,
        &pos.HighPart,
        FILE_CURRENT
    );
    if (pos.LowPart == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR) {
        pos.QuadPart = -1;
    }

    return pos.QuadPart;
    /* return tell(fd); */
#else
a3170 1
#endif
d3543 1
a3543 2
	    if (!IsWin95())
		len += 3;
d3580 1
a3580 1
    if (bat_file && !IsWin95()) {
d3678 1
a3678 4

    /* worst case: PATH is a single directory; we need additional space
     * to append "/", ".exe" and trailing "\0" */
    New(0, fullcmd, (pathstr ? strlen(pathstr) : 0) + cmdlen + 6, char);
d3719 3
a3721 1
                    *curfullcmd++ = *pathstr++;
d3727 3
a3729 1
                *curfullcmd++ = *pathstr++;
a4563 3
	if (GIMME_V == G_SCALAR) {
	    XSRETURN_IV(osverw.dwPlatformId);
	}
a4582 3
	}
	if (GIMME_V == G_SCALAR) {
	    XSRETURN_IV(osver.dwPlatformId);
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d4158 1
d4171 1
d4173 4
d4179 1
a4179 1
   DWORD size = brk+need-reserved;
a4180 1
   char *prev_committed = NULL;
a4185 3
      {
      /* Remember where we committed from in case we want to decommit later */
      prev_committed = committed;
a4186 1
      }
a4188 2
    * Contiguous blocks give us greater efficiency, so reserve big blocks -
    * this is only address space not memory...
a4192 4
sbrk_reserve:
   if (size < 64*1024*1024)
    size = 64*1024*1024;
   size = ((size + pagesize - 1) / pagesize) * pagesize;
a4203 13
   else if (reserved)
    {
      /* The existing block could not be extended far enough, so decommit
       * anything that was just committed above and start anew */
      if (prev_committed)
       {
       if (!VirtualFree(prev_committed,reserved-prev_committed,MEM_DECOMMIT))
        return (void *) -1;
       }
      reserved = base = committed = brk = NULL;
      size = need;
      goto sbrk_reserve;
    }
d4214 1
a4214 4
   char *addr;
   if (committed+size > reserved)
    size = reserved-committed;
   addr = (char *) VirtualAlloc(committed,size,MEM_COMMIT,PAGE_READWRITE);
d4216 3
a4218 1
    committed += size;
a4809 2
    STRLEN filename_len;
    char *filename_p;
d4815 2
a4816 2
    filename_p = SvPV(filename, filename_len);
    fullpath = sv_2mortal(newSVpvn(filename_p, filename_len));
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@a119 10
#ifdef __BORLANDC__
/* Silence STDERR grumblings from Borland's math library. */
DllExport int
_matherr(struct _exception *a)
{
    PERL_UNUSED_VAR(a);
    return 1;
}
#endif

a140 4
    /* remove \\?\ prefix */
    if (memcmp(w32_module_name, "\\\\?\\", 4) == 0)
        memmove(w32_module_name, w32_module_name+4, strlen(w32_module_name+4)+1);

d256 1
a256 2
	else if (SvPVX(*prev_pathp))
	    sv_catpvn(*prev_pathp, ";", 1);
d460 2
a461 2
	Newx(ret, slen+2, char);
	Newx(retv, (slen+3)/2, char*);
d530 1
a530 1
    Newx(argv, (sp - mark) + w32_perlshell_items + 2, char*);
d618 2
a619 2
	Newx(argv, strlen(cmd) / 2 + 2, char*);
	Newx(cmd2, strlen(cmd) + 1, char);
d656 1
a656 1
	Newx(argv, w32_perlshell_items + 2, char*);
d744 1
a744 1
    Newxz(dirp, 1, DIR);
d805 1
a805 1
    Newx(dirp->start, dirp->size, char);
d1469 1
a1469 1
	    Newx(wCuritem,length,WCHAR);
d1480 1
a1480 1
	    Newx(curitem,strlen(name)+1,char);
d2585 1
a2585 1
#if defined(__BORLANDC__) /* buk */
d2630 1
a2630 1
    return fseek(pf, (long)offset, origin);
d2722 1
a2723 20
#if defined(WIN64) || defined(USE_LARGE_FILES)    
    /* Borland 5.5.1 has a 64-bit stat, but only a 32-bit fstat */
    struct stat tmp;
    int rc = fstat(fd,&tmp);
   
    sbufptr->st_dev   = tmp.st_dev;
    sbufptr->st_ino   = tmp.st_ino;
    sbufptr->st_mode  = tmp.st_mode;
    sbufptr->st_nlink = tmp.st_nlink;
    sbufptr->st_uid   = tmp.st_uid;
    sbufptr->st_gid   = tmp.st_gid;
    sbufptr->st_rdev  = tmp.st_rdev;
    sbufptr->st_size  = tmp.st_size;
    sbufptr->st_atime = tmp.st_atime;
    sbufptr->st_mtime = tmp.st_mtime;
    sbufptr->st_ctime = tmp.st_ctime;
#else
    int rc = fstat(fd,sbufptr);
#endif       

a2724 3
#if defined(WIN64) || defined(USE_LARGE_FILES)    
        sbufptr->st_size = (bhfi.nFileSizeHigh << 32) + bhfi.nFileSizeLow ;
#endif
d3180 1
a3180 1
    return chsize(fd, (long)size);
d3206 1
a3206 1
    return lseek(fd, (long)offset, origin);
d3639 1
a3639 1
    Newx(cmd, len, char);
d3743 1
a3743 1
    Newx(fullcmd, (pathstr ? strlen(pathstr) : 0) + cmdlen + 6, char);
d3858 1
a3858 1
    Newx(ptr, strlen(szfilename)+1, char);
d3906 1
a3906 1
	    Newx(cname,clen+1,char);
a4051 1
#  ifdef __BORLANDC__
a4052 3
#  else
	return spawnv(P_WAIT, cmdname, argv);
#  endif
a4053 1
#ifdef __BORLANDC__
a4054 3
#else
    return execv(cmdname, argv);
#endif
a4073 1
#ifdef __BORLANDC__
a4074 3
#else
    return execvp(cmdname, argv);
#endif
d5117 1
a5117 1
    Newx(w32_children, 1, child_tab);
d5121 1
a5121 1
    Newx(w32_pseudo_children, 1, child_tab);
d5136 2
a5137 2
	signal(SIGINT,win32_csighandler);
	signal(SIGBREAK,win32_csighandler);
d5175 1
a5175 1
    Newxz(dst->children, 1, child_tab);
d5177 1
a5177 1
    Newxz(dst->pseudo_children, 1, child_tab);
d5206 1
a5206 1
	    Newxz(psz, length, char);
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d18 5
a22 5
#ifndef HWND_MESSAGE
#  define HWND_MESSAGE     ((HWND)-3)
#endif
#ifndef WC_NO_BEST_FIT_CHARS
#  define WC_NO_BEST_FIT_CHARS 0x00000400 /* requires Windows 2000 or later */
a24 1
#include <tlhelp32.h>
a27 24
#define SystemProcessesAndThreadsInformation 5

/* Inline some definitions from the DDK */
typedef struct {
    USHORT	    Length;
    USHORT	    MaximumLength;
    PWSTR	    Buffer;
}   UNICODE_STRING;

typedef struct {
    ULONG           NextEntryDelta;
    ULONG	    ThreadCount;
    ULONG	    Reserved1[6];
    LARGE_INTEGER   CreateTime;
    LARGE_INTEGER   UserTime;
    LARGE_INTEGER   KernelTime;
    UNICODE_STRING  ProcessName;
    LONG	    BasePriority;
    ULONG	    ProcessId;
    ULONG	    InheritedFromProcessId;
    /* Remainder of the structure depends on the Windows version,
     * but we don't need those additional fields anyways... */
}   SYSTEM_PROCESSES;

a65 1
START_EXTERN_C
a70 1
END_EXTERN_C
d95 2
a96 2
static int		do_spawn2(pTHX_ const char *cmd, int exectype);
static BOOL		has_shell_metachars(const char *ptr);
d116 1
a116 1
static OSVERSIONINFO g_osver = {0, 0, 0, 0, 0, ""};
d118 1
a118 4
static HANDLE (WINAPI *pfnCreateToolhelp32Snapshot)(DWORD, DWORD) = NULL;
static BOOL   (WINAPI *pfnProcess32First)(HANDLE, PROCESSENTRY32*) = NULL;
static BOOL   (WINAPI *pfnProcess32Next)(HANDLE, PROCESSENTRY32*) = NULL;
static LONG   (WINAPI *pfnZwQuerySystemInformation)(UINT, PVOID, ULONG, PULONG);
a129 30
/* VS2005 (MSC version 14) provides a mechanism to set an invalid
 * parameter handler.  This functionality is not available in the
 * 64-bit compiler from the Platform SDK, which unfortunately also
 * believes itself to be MSC version 14.
 *
 * There is no #define related to _set_invalid_parameter_handler(),
 * but we can check for one of the constants defined for
 * _set_abort_behavior(), which was introduced into stdlib.h at
 * the same time.
 */

#if _MSC_VER >= 1400 && defined(_WRITE_ABORT_MSG)
#  define SET_INVALID_PARAMETER_HANDLER
#endif

#ifdef SET_INVALID_PARAMETER_HANDLER
void my_invalid_parameter_handler(const wchar_t* expression,
    const wchar_t* function, 
    const wchar_t* file, 
    unsigned int line, 
    uintptr_t pReserved)
{
#  ifdef _DEBUG
    wprintf(L"Invalid parameter detected in function %s."
            L" File: %s Line: %d\n", function, file, line);
    wprintf(L"Expression: %s\n", expression);
#  endif
}
#endif

d133 1
a133 1
    return (g_osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
d139 1
a139 7
    return (g_osver.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

int
IsWin2000(void)
{
    return (g_osver.dwMajorVersion > 4);
a144 1
    /* this function may be called at DLL_PROCESS_ATTACH time */
d146 14
a159 40
    HMODULE module = (HMODULE)((w32_perldll_handle == INVALID_HANDLE_VALUE)
                               ? GetModuleHandle(NULL)
                               : w32_perldll_handle);

    OSVERSIONINFO osver; /* g_osver may not yet be initialized */
    osver.dwOSVersionInfoSize = sizeof(osver);
    GetVersionEx(&osver);

    if (osver.dwMajorVersion > 4) {
        WCHAR modulename[MAX_PATH];
        WCHAR fullname[MAX_PATH];
        char *ansi;

        GetModuleFileNameW(module, modulename, sizeof(modulename)/sizeof(WCHAR));

        /* Make sure we get an absolute pathname in case the module was loaded
         * explicitly by LoadLibrary() with a relative path. */
        GetFullPathNameW(modulename, sizeof(fullname)/sizeof(WCHAR), fullname, NULL);

        /* remove \\?\ prefix */
        if (memcmp(fullname, L"\\\\?\\", 4*sizeof(WCHAR)) == 0)
            memmove(fullname, fullname+4, (wcslen(fullname+4)+1)*sizeof(WCHAR));

        ansi = win32_ansipath(fullname);
        my_strlcpy(w32_module_name, ansi, sizeof(w32_module_name));
        win32_free(ansi);
    }
    else {
        GetModuleFileName(module, w32_module_name, sizeof(w32_module_name));

        /* remove \\?\ prefix */
        if (memcmp(w32_module_name, "\\\\?\\", 4) == 0)
            memmove(w32_module_name, w32_module_name+4, strlen(w32_module_name+4)+1);

        /* try to get full path to binary (which may be mangled when perl is
         * run from a 16-bit app) */
        /*PerlIO_printf(Perl_debug_log, "Before %s\n", w32_module_name);*/
        win32_longpath(w32_module_name);
        /*PerlIO_printf(Perl_debug_log, "After  %s\n", w32_module_name);*/
    }
d352 1
a352 1
has_shell_metachars(const char *ptr)
d397 1
a397 1
Perl_my_popen(pTHX_ const char *cmd, const char *mode)
d429 9
a437 1
    return (unsigned long)g_osver.dwPlatformId;
d621 1
a621 1
do_spawn2(pTHX_ const char *cmd, int exectype)
d674 1
a674 1
	argv[i++] = (char *)cmd;
d724 1
a724 1
Perl_do_exec(pTHX_ const char *cmd)
d735 1
a735 1
win32_opendir(const char *filename)
d745 1
a745 1
    bool                using_wide;
d747 2
a748 1
    char		*ptr;
d776 3
a778 5
    if (IsWin2000()) {
        WCHAR wscanname[sizeof(scanname)];
        MultiByteToWideChar(CP_ACP, 0, scanname, -1, wscanname, sizeof(wscanname)/sizeof(WCHAR));
	dirp->handle = FindFirstFileW(PerlDir_mapW(wscanname), &wFindData);
        using_wide = TRUE;
d781 1
a781 1
 	dirp->handle = FindFirstFileA(PerlDir_mapA(scanname), &aFindData);
d783 2
a784 1
    if (dirp->handle == INVALID_HANDLE_VALUE) {
d805 6
a810 11
    if (using_wide) {
        BOOL use_default = FALSE;
        WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                            wFindData.cFileName, -1,
                            buffer, sizeof(buffer), NULL, &use_default);
        if (use_default && *wFindData.cAlternateFileName) {
            WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                                wFindData.cAlternateFileName, -1,
                                buffer, sizeof(buffer), NULL, NULL);
        }
        ptr = buffer;
d813 1
a813 1
        ptr = aFindData.cFileName;
a814 3
    /* now allocate the first part of the string table for
     * the filenames that we find.
     */
d817 1
a817 1
	dirp->size = 256;
d850 5
a854 4
	    BOOL res;
            WIN32_FIND_DATAA aFindData;
	    char buffer[MAX_PATH*2];
            char *ptr;
d859 1
a859 2
	    if (IsWin2000()) {
                WIN32_FIND_DATAW wFindData;
d862 9
a870 16
                    BOOL use_default = FALSE;
                    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                                        wFindData.cFileName, -1,
                                        buffer, sizeof(buffer), NULL, &use_default);
                    if (use_default && *wFindData.cAlternateFileName) {
                        WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                                            wFindData.cAlternateFileName, -1,
                                            buffer, sizeof(buffer), NULL, NULL);
                    }
                    ptr = buffer;
                }
            }
            else {
                res = FindNextFileA(dirp->handle, &aFindData);
                ptr = aFindData.cFileName;
            }
a1073 2
	Move(&w32_pseudo_child_message_hwnds[child+1], &w32_pseudo_child_message_hwnds[child],
	     (w32_num_pseudo_children-child-1), HWND);
a1078 137
static int
terminate_process(DWORD pid, HANDLE process_handle, int sig)
{
    switch(sig) {
    case 0:
        /* "Does process exist?" use of kill */
        return 1;
    case 2:
        if (GenerateConsoleCtrlEvent(CTRL_C_EVENT, pid))
            return 1;
        break;
    case SIGBREAK:
    case SIGTERM:
        if (GenerateConsoleCtrlEvent(CTRL_BREAK_EVENT, pid))
            return 1;
        break;
    default: /* For now be backwards compatible with perl 5.6 */
    case 9:
        /* Note that we will only be able to kill processes owned by the
         * current process owner, even when we are running as an administrator.
         * To kill processes of other owners we would need to set the
         * 'SeDebugPrivilege' privilege before obtaining the process handle.
         */
        if (TerminateProcess(process_handle, sig))
            return 1;
        break;
    }
    return 0;
}

/* Traverse process tree using ToolHelp functions */
static int
kill_process_tree_toolhelp(DWORD pid, int sig)
{
    HANDLE process_handle;
    HANDLE snapshot_handle;
    int killed = 0;

    process_handle = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
    if (process_handle == NULL)
        return 0;

    killed += terminate_process(pid, process_handle, sig);

    snapshot_handle = pfnCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (snapshot_handle != INVALID_HANDLE_VALUE) {
        PROCESSENTRY32 entry;

        entry.dwSize = sizeof(entry);
        if (pfnProcess32First(snapshot_handle, &entry)) {
            do {
                if (entry.th32ParentProcessID == pid)
                    killed += kill_process_tree_toolhelp(entry.th32ProcessID, sig);
                entry.dwSize = sizeof(entry);
            }
            while (pfnProcess32Next(snapshot_handle, &entry));
        }
        CloseHandle(snapshot_handle);
    }
    CloseHandle(process_handle);
    return killed;
}

/* Traverse process tree using undocumented system information structures.
 * This is only necessary on Windows NT, which lacks the ToolHelp functions.
 */
static int
kill_process_tree_sysinfo(SYSTEM_PROCESSES *process_info, DWORD pid, int sig)
{
    HANDLE process_handle;
    SYSTEM_PROCESSES *p = process_info;
    int killed = 0;

    process_handle = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
    if (process_handle == NULL)
        return 0;

    killed += terminate_process(pid, process_handle, sig);

    while (1) {
        if (p->InheritedFromProcessId == (DWORD)pid)
            killed += kill_process_tree_sysinfo(process_info, p->ProcessId, sig);

        if (p->NextEntryDelta == 0)
            break;

        p = (SYSTEM_PROCESSES*)((char*)p + p->NextEntryDelta);
    }

    CloseHandle(process_handle);
    return killed;
}

int
killpg(int pid, int sig)
{
    /* Use "documented" method whenever available */
    if (pfnCreateToolhelp32Snapshot && pfnProcess32First && pfnProcess32Next) {
        return kill_process_tree_toolhelp((DWORD)pid, sig);
    }

    /* Fall back to undocumented Windows internals on Windows NT */
    if (pfnZwQuerySystemInformation) {
        dTHX;
        char *buffer;
        DWORD size = 0;

        pfnZwQuerySystemInformation(SystemProcessesAndThreadsInformation, NULL, 0, &size);
        Newx(buffer, size, char);

        if (pfnZwQuerySystemInformation(SystemProcessesAndThreadsInformation, buffer, size, NULL) >= 0) {
            int killed = kill_process_tree_sysinfo((SYSTEM_PROCESSES*)buffer, (DWORD)pid, sig);
            Safefree(buffer);
            return killed;
        }
    }
    return 0;
}

static int
my_kill(int pid, int sig)
{
    int retval = 0;
    HANDLE process_handle;

    if (sig < 0)
        return killpg(pid, -sig);

    process_handle = OpenProcess(PROCESS_TERMINATE, FALSE, pid);
    /* OpenProcess() returns NULL on error, *not* INVALID_HANDLE_VALUE */
    if (process_handle != NULL) {
        retval = terminate_process(pid, process_handle, sig);
        CloseHandle(process_handle);
    }
    return retval;
}

d1083 1
d1085 1
d1091 1
a1091 2
            HWND hwnd = w32_pseudo_child_message_hwnds[child];
	    HANDLE hProcess = w32_pseudo_child_handles[child];
a1095 1

d1103 8
a1110 22

	    default: {
                int count = 0;
                /* pseudo-process has not yet properly initialized if hwnd isn't set */
                while (hwnd == INVALID_HANDLE_VALUE && count < 5) {
                    /* Yield and wait for the other thread to send us its message_hwnd */
                    Sleep(0);
                    win32_async_check(aTHX);
		    hwnd = w32_pseudo_child_message_hwnds[child];
                    ++count;
                }
                if (hwnd != INVALID_HANDLE_VALUE) {
                    /* We fake signals to pseudo-processes using Win32
                     * message queue.  In Win9X the pids are negative already. */
                    if ((hwnd != NULL && PostMessage(hwnd, WM_USER_KILL, sig, 0)) ||
                        PostThreadMessage(IsWin95() ? pid : -pid, WM_USER_KILL, sig, 0))
                    {
                        /* It might be us ... */
                        PERL_ASYNC_CHECK();
                        return 0;
                    }
                }
a1112 1
            } /* switch */
d1124 21
a1144 8
            if (my_kill(pid, sig)) {
                DWORD exitcode = 0;
                if (GetExitCodeProcess(w32_child_handles[child], &exitcode) &&
                    exitcode != STILL_ACTIVE)
                {
                    remove_dead_process(child);
                }
                return 0;
d1149 27
a1175 1
            if (my_kill((IsWin95() ? -pid : pid), sig))
d1190 3
a1193 5
    BOOL        expect_dir = FALSE;

    GV          *gv_sloppy = gv_fetchpvs("\027IN32_SLOPPY_STAT",
                                         GV_NOTQUAL, SVt_PV);
    BOOL        sloppy = gv_sloppy && SvTRUE(GvSV(gv_sloppy));
d1198 1
a1198 1
	 * slashes, except for the root directory of a drive */
d1200 1
a1200 2
        case '/':
	    if (l > sizeof(buffer)) {
d1204 4
a1207 11
            --l;
            strncpy(buffer, path, l);
            /* remove additional trailing slashes */
            while (l > 1 && (buffer[l-1] == '/' || buffer[l-1] == '\\'))
                --l;
            /* add back slash if we otherwise end up with just a drive letter */
            if (l == 2 && isALPHA(buffer[0]) && buffer[1] == ':')
                buffer[l++] = '\\';
            buffer[l] = '\0';
            path = buffer;
            expect_dir = TRUE;
a1208 1

d1223 19
a1241 2
    path = PerlDir_mapA(path);
    l = strlen(path);
d1243 7
a1249 11
    if (!sloppy) {
        /* We must open & close the file once; otherwise file attribute changes  */
        /* might not yet have propagated to "other" hard links of the same file. */
        /* This also gives us an opportunity to determine the number of links.   */
        HANDLE handle = CreateFileA(path, 0, 0, NULL, OPEN_EXISTING, 0, NULL);
        if (handle != INVALID_HANDLE_VALUE) {
            BY_HANDLE_FILE_INFORMATION bhi;
            if (GetFileInformationByHandle(handle, &bhi))
                nlink = bhi.nNumberOfLinks;
            CloseHandle(handle);
        }
d1251 1
a1251 2

    /* path will be mapped correctly above */
d1253 1
a1253 1
    res = _stati64(path, sbuf);
d1255 1
a1255 1
    res = stat(path, sbuf);
d1257 1
d1265 7
a1271 1
	DWORD r = GetFileAttributesA(path);
d1287 3
a1289 1
	    if (!GetVolumeInformationA(path,NULL,0,NULL,NULL,NULL,NULL,0)) {
a1293 4
        if (expect_dir && !S_ISDIR(sbuf->st_mode)) {
            errno = ENOTDIR;
            return -1;
        }
a1421 65
static void
out_of_memory()
{
    if (PL_curinterp) {
        dTHX;
        /* Can't use PerlIO to write as it allocates memory */
        PerlLIO_write(PerlIO_fileno(Perl_error_log),
                      PL_no_mem, strlen(PL_no_mem));
        my_exit(1);
    }
    exit(1);
}

/* The win32_ansipath() function takes a Unicode filename and converts it
 * into the current Windows codepage. If some characters cannot be mapped,
 * then it will convert the short name instead.
 *
 * The buffer to the ansi pathname must be freed with win32_free() when it
 * it no longer needed.
 *
 * The argument to win32_ansipath() must exist before this function is
 * called; otherwise there is no way to determine the short path name.
 *
 * Ideas for future refinement:
 * - Only convert those segments of the path that are not in the current
 *   codepage, but leave the other segments in their long form.
 * - If the resulting name is longer than MAX_PATH, start converting
 *   additional path segments into short names until the full name
 *   is shorter than MAX_PATH.  Shorten the filename part last!
 */
DllExport char *
win32_ansipath(const WCHAR *widename)
{
    char *name;
    BOOL use_default = FALSE;
    size_t widelen = wcslen(widename)+1;
    int len = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, widename, widelen,
                                  NULL, 0, NULL, NULL);
    name = win32_malloc(len);
    if (!name)
        out_of_memory();

    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, widename, widelen,
                        name, len, NULL, &use_default);
    if (use_default) {
        DWORD shortlen = GetShortPathNameW(widename, NULL, 0);
        if (shortlen) {
            WCHAR *shortname = win32_malloc(shortlen*sizeof(WCHAR));
            if (!shortname)
                out_of_memory();
            shortlen = GetShortPathNameW(widename, shortname, shortlen)+1;

            len = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, shortname, shortlen,
                                      NULL, 0, NULL, NULL);
            name = win32_realloc(name, len);
            if (!name)
                out_of_memory();
            WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, shortname, shortlen,
                                name, len, NULL, NULL);
            win32_free(shortname);
        }
    }
    return name;
}

d1426 1
d1430 6
a1435 1
    needlen = GetEnvironmentVariableA(name,NULL,0);
d1438 20
a1457 6
        do {
            SvGROW(curitem, needlen+1);
            needlen = GetEnvironmentVariableA(name,SvPVX(curitem),
                                              needlen);
        } while (needlen >= SvLEN(curitem));
        SvCUR_set(curitem, needlen);
d1477 3
a1479 1
    int relval = -1;
d1482 37
a1518 23
        Newx(curitem,strlen(name)+1,char);
        strcpy(curitem, name);
        val = strchr(curitem, '=');
        if (val) {
            /* The sane way to deal with the environment.
             * Has these advantages over putenv() & co.:
             *  * enables us to store a truly empty value in the
             *    environment (like in UNIX).
             *  * we don't have to deal with RTL globals, bugs and leaks.
             *  * Much faster.
             * Why you may want to enable USE_WIN32_RTL_ENV:
             *  * environ[] and RTL functions will not reflect changes,
             *    which might be an issue if extensions want to access
             *    the env. via RTL.  This cuts both ways, since RTL will
             *    not see changes made by extensions that call the Win32
             *    functions directly, either.
             * GSAR 97-06-07
             */
            *val++ = '\0';
            if (SetEnvironmentVariableA(curitem, *val ? val : NULL))
                relval = 0;
        }
        Safefree(curitem);
d1586 17
a1602 5
    filename = PerlDir_mapA(filename);
    attrs = GetFileAttributesA(filename);
    if (attrs == 0xFFFFFFFF) {
        errno = ENOENT;
        return -1;
d1604 13
a1616 5
    if (attrs & FILE_ATTRIBUTE_READONLY) {
        (void)SetFileAttributesA(filename, attrs & ~FILE_ATTRIBUTE_READONLY);
        ret = unlink(filename);
        if (ret == -1)
            (void)SetFileAttributesA(filename, attrs);
a1617 2
    else
        ret = unlink(filename);
d1619 3
d1633 3
d1637 9
a1645 4

    filename = PerlDir_mapA(filename);
    rc = utime(filename, times);

d1657 10
a1666 3
    handle = CreateFileA(filename, GENERIC_READ | GENERIC_WRITE,
                         FILE_SHARE_READ | FILE_SHARE_DELETE, NULL,
                         OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
d1719 20
d1740 12
a1751 14
    /* sysname */
    switch (g_osver.dwPlatformId) {
    case VER_PLATFORM_WIN32_WINDOWS:
        strcpy(name->sysname, "Windows");
        break;
    case VER_PLATFORM_WIN32_NT:
        strcpy(name->sysname, "Windows NT");
        break;
    case VER_PLATFORM_WIN32s:
        strcpy(name->sysname, "Win32s");
        break;
    default:
        strcpy(name->sysname, "Win32 Unknown");
        break;
d1753 4
a1756 12

    /* release */
    sprintf(name->release, "%d.%d",
            g_osver.dwMajorVersion, g_osver.dwMinorVersion);

    /* version */
    sprintf(name->version, "Build %d",
            g_osver.dwPlatformId == VER_PLATFORM_WIN32_NT
            ? g_osver.dwBuildNumber : (g_osver.dwBuildNumber & 0xffff));
    if (g_osver.szCSDVersion[0]) {
        char *buf = name->version + strlen(name->version);
        sprintf(buf, " (%s)", g_osver.szCSDVersion);
d1891 1
a1891 18
    HWND hwnd = w32_message_hwnd;

    w32_poll_count = 0;

    if (hwnd == INVALID_HANDLE_VALUE) {
        /* Call PeekMessage() to mark all pending messages in the queue as "old".
         * This is necessary when we are being called by win32_msgwait() to
         * make sure MsgWaitForMultipleObjects() stops reporting the same waiting
         * message over and over.  An example how this can happen is when
         * Perl is calling win32_waitpid() inside a GUI application and the GUI
         * is generating messages before the process terminated.
         */
        PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE|PM_NOYIELD);
        if (PL_sig_pending)
            despatch_signals();
        return 1;
    }

d1895 3
a1897 2
    if (hwnd == NULL)
        hwnd = (HWND)-1;
d1899 8
a1906 11
    while (PeekMessage(&msg, hwnd, WM_TIMER,    WM_TIMER,    PM_REMOVE|PM_NOYIELD) ||
           PeekMessage(&msg, hwnd, WM_USER_MIN, WM_USER_MAX, PM_REMOVE|PM_NOYIELD))
    {
	switch (msg.message) {
#ifdef USE_ITHREADS
        case WM_USER_MESSAGE: {
            int child = find_pseudo_pid(msg.wParam);
            if (child >= 0)
                w32_pseudo_child_message_hwnds[child] = (HWND)msg.lParam;
            break;
        }
d1909 7
a1915 5
	case WM_USER_KILL: {
            /* We use WM_USER to fake kill() with other signals */
	    int sig = msg.wParam;
	    if (do_raise(aTHX_ sig))
                sig_terminate(aTHX_ sig);
d1922 1
a1922 1
	    	KillTimer(w32_message_hwnd, w32_timerid);
d1924 9
d1934 6
a1939 4
                /* Now fake a call to signal handler */
                if (do_raise(aTHX_ 14))
                    sig_terminate(aTHX_ 14);
            }
a1941 1
        } /* switch */
d1943 1
d1949 1
a1949 1
    return 1;
d1964 1
a1964 1
	DWORD result = MsgWaitForMultipleObjects(count,handles,FALSE,timeout-ticks, QS_POSTMESSAGE|QS_TIMER);
a2161 4

    if (w32_message_hwnd == INVALID_HANDLE_VALUE)
        w32_message_hwnd = win32_create_message_window();

d2163 1
a2163 6
        if (w32_message_hwnd == NULL)
            w32_timerid = SetTimer(NULL, w32_timerid, sec*1000, NULL);
        else {
  	    w32_timerid = 1;
            SetTimer(w32_message_hwnd, w32_timerid, sec*1000, NULL);
        }
d2167 2
a2168 2
            KillTimer(w32_message_hwnd, w32_timerid);
  	    w32_timerid = 0;
d2486 1
d2495 7
a2501 1
    f = fopen(PerlDir_mapA(filename), mode);
d2517 1
d2519 6
a2524 1
    f = fdopen(handle, (char *) mode);
d2535 1
d2539 5
d2841 4
a2850 4
    /* save current stdfd */
    if ((oldfd = win32_dup(stdfd)) == -1)
        goto cleanup;

a2871 3
	/* close saved handle */
	win32_close(oldfd);

d2880 3
a2897 4
    if (oldfd != -1) {
        win32_dup2(oldfd, stdfd);
        win32_close(oldfd);
    }
d2903 4
a2934 1
        UNLOCK_FDPID_MUTEX;
d3030 2
a3031 2
    if (MultiByteToWideChar(CP_ACP, 0, oldname, -1, wOldName, MAX_PATH+1) &&
        MultiByteToWideChar(CP_ACP, 0, newname, -1, wNewName, MAX_PATH+1) &&
d3033 1
a3033 1
        pfnCreateHardLinkW(PerlDir_mapW(wNewName), wOldName, NULL)))
d3044 2
d3056 14
a3069 4
        if (stricmp(newname, oname))
            dwFlags |= MOVEFILE_REPLACE_EXISTING;
        strcpy(szOldName, PerlDir_mapA(oname));
        bResult = MoveFileExA(szOldName,PerlDir_mapA(newname), dwFlags);
d3280 1
d3289 4
d3539 5
d3551 5
d3567 5
d3579 5
d3591 5
d3885 9
a3893 1
    char szfilename[MAX_PATH+1];
a3894 1
    GetCurrentDirectoryA(MAX_PATH+1, szfilename);
d4393 1
d4413 9
a4421 1
    return LoadLibraryExA(PerlDir_mapA(filename), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
d4424 5
d4454 521
d4980 1
d4982 22
a5003 10
    /* Initialize Win32CORE if it has been statically linked. */
    void (*pfn_init)(pTHX);
#if defined(__BORLANDC__)
    /* makedef.pl seems to have given up on fixing this issue in the .def file */
    pfn_init = (void (*)(pTHX))GetProcAddress((HMODULE)w32_perldll_handle, "_init_Win32CORE");
#else
    pfn_init = (void (*)(pTHX))GetProcAddress((HMODULE)w32_perldll_handle, "init_Win32CORE");
#endif
    if (pfn_init)
        pfn_init(aTHX);
d5005 10
a5014 1
    newXS("Win32::SetChildShowWindow", w32_SetChildShowWindow, file);
d5028 3
d5033 1
d5045 4
a5093 102
#ifdef SET_INVALID_PARAMETER_HANDLER
#  include <crtdbg.h>
#endif

static void
ansify_path(void)
{
    size_t len;
    char *ansi_path;
    WCHAR *wide_path;
    WCHAR *wide_dir;

    /* win32_ansipath() requires Windows 2000 or later */
    if (!IsWin2000())
        return;

    /* fetch Unicode version of PATH */
    len = 2000;
    wide_path = win32_malloc(len*sizeof(WCHAR));
    while (wide_path) {
        size_t newlen = GetEnvironmentVariableW(L"PATH", wide_path, len);
        if (newlen < len)
            break;
        len = newlen;
        wide_path = win32_realloc(wide_path, len*sizeof(WCHAR));
    }
    if (!wide_path)
        return;

    /* convert to ANSI pathnames */
    wide_dir = wide_path;
    ansi_path = NULL;
    while (wide_dir) {
        WCHAR *sep = wcschr(wide_dir, ';');
        char *ansi_dir;
        size_t ansi_len;
        size_t wide_len;

        if (sep)
            *sep++ = '\0';

        /* remove quotes around pathname */
        if (*wide_dir == '"')
            ++wide_dir;
        wide_len = wcslen(wide_dir);
        if (wide_len && wide_dir[wide_len-1] == '"')
            wide_dir[wide_len-1] = '\0';

        /* append ansi_dir to ansi_path */
        ansi_dir = win32_ansipath(wide_dir);
        ansi_len = strlen(ansi_dir);
        if (ansi_path) {
            size_t newlen = len + 1 + ansi_len;
            ansi_path = win32_realloc(ansi_path, newlen+1);
            if (!ansi_path)
                break;
            ansi_path[len] = ';';
            memcpy(ansi_path+len+1, ansi_dir, ansi_len+1);
            len = newlen;
        }
        else {
            len = ansi_len;
            ansi_path = win32_malloc(5+len+1);
            if (!ansi_path)
                break;
            memcpy(ansi_path, "PATH=", 5);
            memcpy(ansi_path+5, ansi_dir, len+1);
            len += 5;
        }
        win32_free(ansi_dir);
        wide_dir = sep;
    }

    if (ansi_path) {
        /* Update C RTL environ array.  This will only have full effect if
         * perl_parse() is later called with `environ` as the `env` argument.
         * Otherwise S_init_postdump_symbols() will overwrite PATH again.
         *
         * We do have to ansify() the PATH before Perl has been fully
         * initialized because S_find_script() uses the PATH when perl
         * is being invoked with the -S option.  This happens before %ENV
         * is initialized in S_init_postdump_symbols().
         *
         * XXX Is this a bug? Should S_find_script() use the environment
         * XXX passed in the `env` arg to parse_perl()?
         */
        putenv(ansi_path);
        /* Keep system environment in sync because S_init_postdump_symbols()
         * will not call mg_set() if it initializes %ENV from `environ`.
         */
        SetEnvironmentVariableA("PATH", ansi_path+5);
        /* We are intentionally leaking the ansi_path string here because
         * the Borland runtime library puts it directly into the environ
         * array.  The Microsoft runtime library seems to make a copy,
         * but will leak the copy should it be replaced again later.
         * Since this code is only called once during PERL_SYS_INIT this
         * shouldn't really matter.
         */
    }
    win32_free(wide_path);
}

a5096 8
    HMODULE module;

#ifdef SET_INVALID_PARAMETER_HANDLER
    _invalid_parameter_handler oldHandler, newHandler;
    newHandler = my_invalid_parameter_handler;
    oldHandler = _set_invalid_parameter_handler(newHandler);
    _CrtSetReportMode(_CRT_ASSERT, 0);
#endif
a5106 17

    module = GetModuleHandle("ntdll.dll");
    if (module) {
        *(FARPROC*)&pfnZwQuerySystemInformation = GetProcAddress(module, "ZwQuerySystemInformation");
    }

    module = GetModuleHandle("kernel32.dll");
    if (module) {
        *(FARPROC*)&pfnCreateToolhelp32Snapshot = GetProcAddress(module, "CreateToolhelp32Snapshot");
        *(FARPROC*)&pfnProcess32First           = GetProcAddress(module, "Process32First");
        *(FARPROC*)&pfnProcess32Next            = GetProcAddress(module, "Process32Next");
    }

    g_osver.dwOSVersionInfoSize = sizeof(g_osver);
    GetVersionEx(&g_osver);

    ansify_path();
a5111 2
    dTHX;
    HINTS_REFCNT_TERM;
a5112 1
    PERLIO_TERM;
a5143 13
HWND
win32_create_message_window()
{
    /* "message-only" windows have been implemented in Windows 2000 and later.
     * On earlier versions we'll continue to post messages to a specific
     * thread and use hwnd==NULL.  This is brittle when either an embedding
     * application or an XS module is also posting messages to hwnd=NULL
     * because once removed from the queue they cannot be delivered to the
     * "right" place with DispatchMessage() anymore, as there is no WindowProc
     * if there is no window handle.
     */
    if (!IsWin2000())
        return NULL;
d5145 1
a5145 2
    return CreateWindow("Static", "", 0, 0, 0, 0, 0, HWND_MESSAGE, 0, 0, NULL);
}
a5146 1
#ifdef HAVE_INTERP_INTERN
a5157 6
#if defined(__MINGW32__) && defined(__cplusplus)
#define CAST_HWND__(x) (HWND__*)(x)
#else
#define CAST_HWND__(x) x
#endif

a5161 1

d5170 1
a5170 1
    Newx(w32_pseudo_children, 1, pseudo_child_tab);
d5173 1
a5174 1
    w32_message_hwnd            = CAST_HWND__(INVALID_HANDLE_VALUE);
d5179 1
a5179 1
#  ifdef MULTIPLICITY
a5186 10

        /* We spawn asynchronous processes with the CREATE_NEW_PROCESS_GROUP
         * flag.  This has the side-effect of disabling Ctrl-C events in all
         * processes in this group.  At least on Windows NT and later we
         * can re-enable Ctrl-C handling by calling SetConsoleCtrlHandler()
         * with a NULL handler.  This is not valid on Windows 9X.
         */
        if (IsWinNT())
            SetConsoleCtrlHandler(NULL,FALSE);

d5200 2
a5201 2
    	KillTimer(w32_message_hwnd, w32_timerid);
    	w32_timerid = 0;
a5202 2
    if (w32_message_hwnd != NULL && w32_message_hwnd != INVALID_HANDLE_VALUE)
        DestroyWindow(w32_message_hwnd);
d5226 4
a5229 4
    Newxz(dst->pseudo_children, 1, pseudo_child_tab);
    dst->timerid                = 0;
    dst->message_hwnd		= CAST_HWND__(INVALID_HANDLE_VALUE);
    dst->poll_count             = 0;
d5234 29
@


1.1.1.11
log
@import perl 5.10.1
@
text
@a131 2
static LRESULT  win32_process_message(HWND hwnd, UINT msg,
                       WPARAM wParam, LPARAM lParam);
a225 4
        DWORD (__stdcall *pfnGetLongPathNameW)(LPCWSTR, LPWSTR, DWORD) =
            (DWORD (__stdcall *)(LPCWSTR, LPWSTR, DWORD))
            GetProcAddress(GetModuleHandle("kernel32.dll"), "GetLongPathNameW");

a231 8
        /* Make sure we start with the long path name of the module because we
         * later scan for pathname components to match "5.xx" to locate
         * compatible sitelib directories, and the short pathname might mangle
         * this path segment (e.g. by removing the dot on NTFS to something
         * like "5xx~1.yy") */
        if (pfnGetLongPathNameW)
            pfnGetLongPathNameW(fullname, fullname, sizeof(fullname)/sizeof(WCHAR));

d271 1
a271 1
    char *str = NULL;
d369 1
a369 1
    return NULL;
d378 1
a378 1
    SV *sv = NULL;
d386 1
a386 1
    return get_emd_part(&sv, stdlib, ARCHNAME, "bin", NULL);
d395 2
a396 2
    SV *sv1 = NULL;
    SV *sv2 = NULL;
d405 1
a405 1
    (void)get_emd_part(&sv1, pathstr, ARCHNAME, "bin", pl, NULL);
d413 1
a413 1
    (void)get_emd_part(&sv2, pathstr, ARCHNAME, "bin", pl, NULL);
d416 1
a416 1
	return NULL;
d552 1
a552 1
    char *retstart = NULL;
d587 1
a587 1
	retvstart[items] = NULL;
a625 2
    PERL_ARGS_ASSERT_DO_ASPAWN;

d664 2
a665 1
	PL_statusvalue = -1;	/* >16bits hint for pp_system() */
d731 1
a731 1
	*a = NULL;
d760 1
a760 1
	argv[i] = NULL;
d778 2
a779 1
	PL_statusvalue = -1;	/* >16bits hint for pp_system() */
a798 2
    PERL_ARGS_ASSERT_DO_SPAWN;

a804 2
    PERL_ARGS_ASSERT_DO_SPAWN_NOWAIT;

a810 2
    PERL_ARGS_ASSERT_DO_EXEC;

a1502 12
	if (S_ISDIR(sbuf->st_mode)) {
	    /* Ensure the "write" bit is switched off in the mode for
	     * directories with the read-only attribute set. Borland (at least)
	     * switches it on for directories, which is technically correct
	     * (directories are indeed always writable unless denied by DACLs),
	     * but we want stat() and -w to reflect the state of the read-only
	     * attribute for symmetry with chmod(). */
	    DWORD r = GetFileAttributesA(path);
	    if (r != 0xffffffff && (r & FILE_ATTRIBUTE_READONLY)) {
		sbuf->st_mode &= ~S_IWRITE;
	    }
	}
d1504 2
a1505 3
	if (S_ISDIR(sbuf->st_mode)) {
	    sbuf->st_mode |= S_IEXEC;
	}
d1553 1
a1553 1
	return NULL;
d1617 1
a1617 1
		return NULL;
d1624 1
a1624 1
	    return NULL;
d1632 1
a1632 1
out_of_memory(void)
d1701 1
a1701 1
    SV *curitem = NULL;
d1722 1
a1722 1
    return NULL;
d1742 1
a1742 2
             *  * we don't have to deal with RTL globals, bugs and leaks
             *    (specifically, see http://support.microsoft.com/kb/235601).
d1744 1
a1744 2
             * Why you may want to use the RTL environment handling
             * (previously enabled by USE_WIN32_RTL_ENV):
a2084 2
    /* Reset w32_poll_count before doing anything else, incase we dispatch
     * messages that end up calling back into perl */
d2087 46
a2132 15
    if (hwnd != INVALID_HANDLE_VALUE) {
        /* Passing PeekMessage -1 as HWND (2nd arg) only gets PostThreadMessage() messages
        * and ignores window messages - should co-exist better with windows apps e.g. Tk
        */
        if (hwnd == NULL)
            hwnd = (HWND)-1;

        while (PeekMessage(&msg, hwnd, WM_TIMER,    WM_TIMER,    PM_REMOVE|PM_NOYIELD) ||
               PeekMessage(&msg, hwnd, WM_USER_MIN, WM_USER_MAX, PM_REMOVE|PM_NOYIELD))
        {
            /* re-post a WM_QUIT message (we'll mark it as read later) */
            if(msg.message == WM_QUIT) {
                PostQuitMessage((int)msg.wParam);
                break;
            }
d2134 3
a2136 4
            if(!CallMsgFilter(&msg, MSGF_USER))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
d2138 3
a2140 1
        }
a2142 9
    /* Call PeekMessage() to mark all pending messages in the queue as "old".
     * This is necessary when we are being called by win32_msgwait() to
     * make sure MsgWaitForMultipleObjects() stops reporting the same waiting
     * message over and over.  An example how this can happen is when
     * Perl is calling win32_waitpid() inside a GUI application and the GUI
     * is generating messages before the process terminated.
     */
    PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE|PM_NOYIELD);

d2144 3
a2146 3
    if (PL_sig_pending)
        despatch_signals();
    
d2162 1
a2162 1
	DWORD result = MsgWaitForMultipleObjects(count,handles,FALSE,timeout-ticks, QS_POSTMESSAGE|QS_TIMER|QS_SENDMESSAGE);
d2393 1
a2393 1
    return NULL;
d2566 1
a2566 1
win32_stdout(void)
d2948 1
a2948 1
        sbufptr->st_size = ((__int64)bhfi.nFileSizeHigh << 32) | bhfi.nFileSizeLow ;
d3272 1
a3272 1
	char *endname = NULL;
d3331 1
a3331 1
	if (endname != NULL) {
d3913 1
a3913 1
	return NULL;
d3987 1
a3987 1
    return NULL;
d4074 1
a4074 1
    char *fullcmd = NULL;
a4848 121
/* The PerlMessageWindowClass's WindowProc */
LRESULT CALLBACK
win32_message_window_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    return win32_process_message(hwnd, msg, wParam, lParam) ?
        0 : DefWindowProc(hwnd, msg, wParam, lParam);
}

/* we use a message filter hook to process thread messages, passing any
 * messages that we don't process on to the rest of the hook chain
 * Anyone else writing a message loop that wants to play nicely with perl
 * should do
 *   CallMsgFilter(&msg, MSGF_***);
 * between their GetMessage and DispatchMessage calls.  */
LRESULT CALLBACK
win32_message_filter_proc(int code, WPARAM wParam, LPARAM lParam) {
    LPMSG pmsg = (LPMSG)lParam;

    /* we'll process it if code says we're allowed, and it's a thread message */
    if (code >= 0 && pmsg->hwnd == NULL
            && win32_process_message(pmsg->hwnd, pmsg->message,
                                     pmsg->wParam, pmsg->lParam))
    {
            return TRUE;
    }

    /* XXX: MSDN says that hhk is ignored, but we should really use the
     * return value from SetWindowsHookEx() in win32_create_message_window().  */
    return CallNextHookEx(NULL, code, wParam, lParam);
}

/* The real message handler. Can be called with
 * hwnd == NULL to process our thread messages. Returns TRUE for any messages
 * that it processes */
static LRESULT
win32_process_message(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    /* BEWARE. The context retrieved using dTHX; is the context of the
     * 'parent' thread during the CreateWindow() phase - i.e. for all messages
     * up to and including WM_CREATE.  If it ever happens that you need the
     * 'child' context before this, then it needs to be passed into
     * win32_create_message_window(), and passed to the WM_NCCREATE handler
     * from the lparam of CreateWindow().  It could then be stored/retrieved
     * using [GS]etWindowLongPtr(... GWLP_USERDATA ...), possibly eliminating
     * the dTHX calls here. */
    /* XXX For now it is assumed that the overhead of the dTHX; for what
     * are relativley infrequent code-paths, is better than the added
     * complexity of getting the correct context passed into
     * win32_create_message_window() */

    switch(msg) {

#ifdef USE_ITHREADS
        case WM_USER_MESSAGE: {
            long child = find_pseudo_pid((int)wParam);
            if (child >= 0) {
                dTHX;
                w32_pseudo_child_message_hwnds[child] = (HWND)lParam;
                return 1;
            }
            break;
        }
#endif

        case WM_USER_KILL: {
            dTHX;
            /* We use WM_USER_KILL to fake kill() with other signals */
            int sig = (int)wParam;
            if (do_raise(aTHX_ sig))
                sig_terminate(aTHX_ sig);

            return 1;
        }

        case WM_TIMER: {
            dTHX;
            /* alarm() is a one-shot but SetTimer() repeats so kill it */
            if (w32_timerid && w32_timerid==(UINT)wParam) {
                KillTimer(w32_message_hwnd, w32_timerid);
                w32_timerid=0;

                /* Now fake a call to signal handler */
                if (do_raise(aTHX_ 14))
                    sig_terminate(aTHX_ 14);

                return 1;
            }
            break;
        }

        default:
            break;

    } /* switch */

    /* Above or other stuff may have set a signal flag, and we may not have
     * been called from win32_async_check() (e.g. some other GUI's message
     * loop.  BUT DON'T dispatch signals here: If someone has set a SIGALRM
     * handler that die's, and the message loop that calls here is wrapped
     * in an eval, then you may well end up with orphaned windows - signals
     * are dispatched by win32_async_check() */

    return 0;
}

void
win32_create_message_window_class(void)
{
    /* create the window class for "message only" windows */
    WNDCLASS wc;

    Zero(&wc, 1, wc);
    wc.lpfnWndProc = win32_message_window_proc;
    wc.hInstance = (HINSTANCE)GetModuleHandle(NULL);
    wc.lpszClassName = "PerlMessageWindowClass";

    /* second and subsequent calls will fail, but class
     * will already be registered */
    RegisterClass(&wc);
}

d4850 1
a4850 1
win32_create_message_window(void)
a4851 2
    HWND hwnd = NULL;

d4860 2
a4861 12
    /* Using HWND_MESSAGE appears to work under Win98, despite MSDN
     * documentation to the contrary, however, there is some evidence that
     * there may be problems with the implementation on Win98. As it is not
     * officially supported we take the cautious route and stick with thread
     * messages (hwnd == NULL) on platforms prior to Win2k.
     */
    if (IsWin2000()) {
        win32_create_message_window_class();

        hwnd = CreateWindow("PerlMessageWindowClass", "PerlMessageWindow",
                0, 0, 0, 0, 0, HWND_MESSAGE, NULL, NULL, NULL);
    }
d4863 1
a4863 11
    /* If we din't create a window for any reason, then we'll use thread
     * messages for our signalling, so we install a hook which
     * is called by CallMsgFilter in win32_async_check(), or any other
     * modal loop (e.g. Win32::MsgBox or any other GUI extention, or anything
     * that use OLE, etc. */
    if(!hwnd) {
        SetWindowsHookEx(WH_MSGFILTER, win32_message_filter_proc,
                NULL, GetCurrentThreadId());
    }
  
    return hwnd;
d4889 1
a4889 1
    w32_perlshell_tokens	= NULL;
d4959 1
a4959 3
    PERL_ARGS_ASSERT_SYS_INTERN_DUP;

    dst->perlshell_tokens	= NULL;
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d4 1
a4 1
 * 		Developed by hip communications inc.
a24 1
#include <commctrl.h>
d67 1
d126 1
a126 2
static char *		get_emd_part(SV **leading, STRLEN *const len,
				     char *trailing, ...);
d131 1
a131 1
				       const char *libname, STRLEN *const len);
d323 1
a323 1
get_emd_part(SV **prev_pathp, STRLEN *const len, char *trailing_path, ...)
a379 2
	if(len)
	    *len = SvCUR(*prev_pathp);
d387 1
a387 1
win32_get_privlib(const char *pl, STRLEN *const len)
d400 1
a400 1
    return get_emd_part(&sv, len, stdlib, ARCHNAME, "bin", NULL);
d404 1
a404 2
win32_get_xlib(const char *pl, const char *xlib, const char *libname,
	       STRLEN *const len)
d419 1
a419 1
    (void)get_emd_part(&sv1, NULL, pathstr, ARCHNAME, "bin", pl, NULL);
d427 1
a427 1
    (void)get_emd_part(&sv2, NULL, pathstr, ARCHNAME, "bin", pl, NULL);
d431 7
a437 6
    if (!sv1) {
	sv1 = sv2;
    } else if (sv2) {
	sv_catpvn(sv1, ";", 1);
	sv_catsv(sv1, sv2);
    }
a438 2
    if (len)
	*len = SvCUR(sv1);
d443 1
a443 1
win32_get_sitelib(const char *pl, STRLEN *const len)
d445 1
a445 1
    return win32_get_xlib(pl, "sitelib", "site", len);
d453 1
a453 1
win32_get_vendorlib(const char *pl, STRLEN *const len)
d455 1
a455 1
    return win32_get_xlib(pl, "vendorlib", PERL_VENDORLIB_NAME, len);
d2012 1
a2012 1
 || (defined(__MINGW32__) && !defined(_ANONYMOUS_UNION) && !defined(__MINGW_EXTENSION))
d2503 1
a2518 3
    if (fh == (HANDLE)-1)  /* _get_osfhandle() already sets errno to EBADF */
        return -1;

d2523 1
a2523 2
	if (LockFileEx(fh, 0, 0, LK_LEN, 0, &o))
            i = 0;
d2526 1
a2526 2
	if (LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK, 0, LK_LEN, 0, &o))
            i = 0;
d2529 1
a2529 2
	if (LockFileEx(fh, LOCKFILE_FAIL_IMMEDIATELY, 0, LK_LEN, 0, &o))
            i = 0;
d2532 3
a2534 3
	if (LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK|LOCKFILE_FAIL_IMMEDIATELY,
		       0, LK_LEN, 0, &o))
            i = 0;
d2537 1
a2537 2
	if (UnlockFileEx(fh, 0, LK_LEN, 0, &o))
            i = 0;
d2541 1
a2541 7
	return -1;
    }
    if (i == -1) {
        if (GetLastError() == ERROR_LOCK_VIOLATION)
            errno = WSAEWOULDBLOCK;
        else
            errno = EINVAL;
d2546 1
d2610 1
d2617 3
a2619 5
	if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                         |FORMAT_MESSAGE_IGNORE_INSERTS, NULL, e, 0,
			  w32_strerror_buffer, sizeof(w32_strerror_buffer),
                          NULL) == 0)
        {
d2621 1
a2621 1
        }
a2623 1
#undef strerror
a2624 1
#define strerror win32_strerror
d3085 1
d3087 1
d3128 1
d3137 1
d3148 1
a3497 21
win32_isatty(int fd)
{
    /* The Microsoft isatty() function returns true for *all*
     * character mode devices, including "nul".  Our implementation
     * should only return true if the handle has a console buffer.
     */
    DWORD mode;
    HANDLE fh = (HANDLE)_get_osfhandle(fd);
    if (fh == (HANDLE)-1) {
        /* errno is already set to EBADF */
        return 0;
    }

    if (GetConsoleMode(fh, &mode))
        return 1;

    errno = ENOTTY;
    return 0;
}

DllExport int
a4805 10

    /* When the manifest resource requests Common-Controls v6 then
     * user32.dll no longer registers all the Windows classes used for
     * standard controls but leaves some of them to be registered by
     * comctl32.dll.  InitCommonControls() doesn't do anything but calling
     * it makes sure comctl32.dll gets loaded into the process and registers
     * the standard control classes.  Without this even normal Windows APIs
     * like MessageBox() can fail under some versions of Windows XP.
     */
    InitCommonControls();
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a13 1

d15 1
a15 5
#  define Win32_Winsock
#endif

#ifndef _WIN32_WINNT
#  define _WIN32_WINNT 0x0500     /* needed for CreateHardlink() etc. */
a16 1

a17 1

d19 1
a19 1
#  define HWND_MESSAGE ((HWND)-3)
a20 5

#ifndef PROCESSOR_ARCHITECTURE_AMD64
#  define PROCESSOR_ARCHITECTURE_AMD64 9
#endif

d22 1
a22 1
#  define WC_NO_BEST_FIT_CHARS 0x00000400
a23 1

d30 24
d57 1
a57 1
#  define PerlIO FILE
d71 1
a71 1
#  include <assert.h>
a72 1

a76 1

d78 1
a78 1
#  include <sys/utime.h>
d80 1
a80 1
#  include <utime.h>
a81 1

d100 5
d148 15
d193 18
d511 16
d547 1
d553 7
a559 1
    return _getpid();
d627 2
a628 1
	const char* defaultshell = "cmd.exe /x/d/c";
d852 2
a853 1
    WCHAR		wscanname[sizeof(scanname)];
d855 1
d857 1
a857 1
    BOOL		use_default;
d860 1
a860 2
    if (len == 0) {
	errno = ENOENT;
d862 3
a864 3
    }
    if (len > MAX_PATH) {
	errno = ENAMETOOLONG;
a865 1
    }
d885 9
a893 3
    MultiByteToWideChar(CP_ACP, 0, scanname, -1, wscanname, sizeof(wscanname)/sizeof(WCHAR));
    dirp->handle = FindFirstFileW(PerlDir_mapW(wscanname), &wFindData);

d915 2
a916 5
    use_default = FALSE;
    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS,
                        wFindData.cFileName, -1,
                        buffer, sizeof(buffer), NULL, &use_default);
    if (use_default && *wFindData.cAlternateFileName) {
d918 11
a928 2
                            wFindData.cAlternateFileName, -1,
                            buffer, sizeof(buffer), NULL, NULL);
a929 1

d933 1
a933 1
    idx = strlen(buffer)+1;
d939 1
a939 1
    strcpy(dirp->start, buffer);
d969 1
d971 1
a972 3
            if (dirp->handle == INVALID_HANDLE_VALUE) {
                res = 0;
            }
d976 1
a976 1
	    else {
d989 1
d992 4
d998 1
a998 1
		long newsize = endpos + strlen(buffer) + 1;
d1007 1
a1007 1
		strcpy(dirp->start + endpos, buffer);
d1011 1
a1011 1
	    else {
a1012 5
                if (dirp->handle != INVALID_HANDLE_VALUE) {
                    FindClose(dirp->handle);
                    dirp->handle = INVALID_HANDLE_VALUE;
                }
            }
d1024 1
a1024 1
    return dirp->curr ? (dirp->curr - dirp->start) : -1;
d1034 1
a1034 1
    dirp->curr = loc == -1 ? NULL : dirp->start + loc;
a1055 44
/* duplicate a open DIR* for interpreter cloning */
DllExport DIR *
win32_dirp_dup(DIR *const dirp, CLONE_PARAMS *const param)
{
    dVAR;
    PerlInterpreter *const from = param->proto_perl;
    PerlInterpreter *const to   = PERL_GET_THX;

    long pos;
    DIR *dup;

    /* switch back to original interpreter because win32_readdir()
     * might Renew(dirp->start).
     */
    if (from != to) {
        PERL_SET_THX(from);
    }

    /* mark current position; read all remaining entries into the
     * cache, and then restore to current position.
     */
    pos = win32_telldir(dirp);
    while (win32_readdir(dirp)) {
        /* read all entries into cache */
    }
    win32_seekdir(dirp, pos);

    /* switch back to new interpreter to allocate new DIR structure */
    if (from != to) {
        PERL_SET_THX(to);
    }

    Newx(dup, 1, DIR);
    memcpy(dup, dirp, sizeof(DIR));

    Newx(dup->start, dirp->size, char);
    memcpy(dup->start, dirp->start, dirp->size);

    dup->end = dup->start + (dirp->end - dirp->start);
    if (dirp->curr)
        dup->curr = dup->start + (dirp->curr - dirp->start);

    return dup;
}
a1200 2
	Move(&w32_pseudo_child_sigterm[child+1], &w32_pseudo_child_sigterm[child],
	     (w32_num_pseudo_children-child-1), char);
a1203 22

void
win32_wait_for_children(pTHX)
{
    if (w32_pseudo_children && w32_num_pseudo_children) {
        long child = 0;
        long count = 0;
        HANDLE handles[MAXIMUM_WAIT_OBJECTS];

        for (child = 0; child < w32_num_pseudo_children; ++child) {
            if (!w32_pseudo_child_sigterm[child])
                handles[count++] = w32_pseudo_child_handles[child];
        }
        /* XXX should use MsgWaitForMultipleObjects() to continue
         * XXX processing messages while we wait.
         */
        WaitForMultipleObjects(count, handles, TRUE, INFINITE);

        while (w32_num_pseudo_children)
            CloseHandle(w32_pseudo_child_handles[--w32_num_pseudo_children]);
    }
}
d1236 3
a1238 2
int
killpg(int pid, int sig)
d1250 1
a1250 1
    snapshot_handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
d1255 1
a1255 1
        if (Process32First(snapshot_handle, &entry)) {
d1257 2
a1258 2
                if (entry.th32ParentProcessID == (DWORD)pid)
                    killed += killpg(entry.th32ProcessID, sig);
d1261 1
a1261 1
            while (Process32Next(snapshot_handle, &entry));
d1269 56
a1362 7
                    /* Allow the scheduler to finish cleaning up the other thread.
                     * Otherwise, if we ExitProcess() before another context switch
                     * happens we will end up with a process exit code of "sig" instead
                     * of our own exit status.
                     * See also: https://rt.cpan.org/Ticket/Display.html?id=66016#txn-908976
                     */
                    Sleep(0);
d1382 1
a1382 1
                        PostThreadMessage(-pid, WM_USER_KILL, sig, 0))
a1383 8
                        /* Don't wait for child process to terminate after we send a SIGTERM
                         * because the child may be blocked in a system call and never receive
                         * the signal.
                         */
                        if (sig == SIGTERM) {
                            Sleep(0);
                            w32_pseudo_child_sigterm[child] = 1;
                        }
d1393 4
d1414 2
a1415 1
            if (my_kill(pid, sig))
d1530 2
a1531 2
	     * directories with the read-only attribute set. Some compilers
	     * switch it on for directories, which is technically correct
d1540 23
a1739 1
    DWORD last_err;
d1752 4
a1755 31
	last_err = GetLastError();
	if (last_err == ERROR_NOT_ENOUGH_MEMORY) {
	    /* It appears the variable is in the env, but the Win32 API
	       doesn't have a canned way of getting it.  So we fall back to
	       grabbing the whole env and pulling this value out if possible */
	    char *envv = GetEnvironmentStrings();
    	    char *cur = envv;
    	    STRLEN len;
    	    while (*cur) {
		char *end = strchr(cur,'=');
		if (end && end != cur) {
		    *end = '\0';
		    if (!strcmp(cur,name)) {
			curitem = sv_2mortal(newSVpv(end+1,0));
			*end = '=';
			break;
		    }
	    	    *end = '=';
	    	    cur = end + strlen(end+1)+2;
		}
		else if ((len = strlen(cur)))
	    	    cur += len+1;
    	    }
    	    FreeEnvironmentStrings(envv);
	}
	else {
	    /* last ditch: allow any environment variables that begin with 'PERL'
	       to be obtained from the registry, if found there */
	    if (strncmp(name, "PERL", 4) == 0)
		(void)get_regstr(name, &curitem);
	}
d1896 1
a1896 1
    if (rc == 0 || errno != EACCES)
d2016 2
a2017 1
#if (defined(__MINGW32__) && !defined(_ANONYMOUS_UNION) && !defined(__MINGW_EXTENSION))
d2025 15
d2042 10
d2054 6
d2062 1
d2302 4
d2330 3
a2332 1
	    hProcess = OpenProcess(PROCESS_ALL_ACCESS, TRUE, pid);
d2400 1
d2402 1
d2408 1
d2410 4
d2416 90
d2517 5
d2623 1
a2623 1
#if !defined __MINGW32__      /* compiler intolerance */
d2821 3
d2828 1
d2838 7
d2864 1
d2873 7
d2881 1
d2887 3
d2891 1
d2921 3
d2953 38
a2990 2
#if defined(WIN64) || defined(USE_LARGE_FILES)
    return _fstati64(fd, sbufptr);
d2992 1
a2992 1
    return fstat(fd, sbufptr);
d3172 58
d3234 1
d3238 9
d3250 1
a3250 1
        CreateHardLinkW(PerlDir_mapW(wNewName), wOldName, NULL)))
d3262 1
a3263 1
    DWORD dwFlags = MOVEFILE_COPY_ALLOWED;
d3266 102
a3367 23
    if (stricmp(newname, oname))
        dwFlags |= MOVEFILE_REPLACE_EXISTING;
    strcpy(szOldName, PerlDir_mapA(oname));

    bResult = MoveFileExA(szOldName,PerlDir_mapA(newname), dwFlags);
    if (!bResult) {
        DWORD err = GetLastError();
        switch (err) {
        case ERROR_BAD_NET_NAME:
        case ERROR_BAD_NETPATH:
        case ERROR_BAD_PATHNAME:
        case ERROR_FILE_NOT_FOUND:
        case ERROR_FILENAME_EXCED_RANGE:
        case ERROR_INVALID_DRIVE:
        case ERROR_NO_MORE_FILES:
        case ERROR_PATH_NOT_FOUND:
            errno = ENOENT;
            break;
        default:
            errno = EACCES;
            break;
        }
        return -1;
a3368 1
    return 0;
d3430 15
d3446 1
d3456 16
d3473 1
d3544 196
d3743 3
d3747 1
d3834 1
a3834 1
		|| (stricmp(&cname[clen-4], ".cmd") == 0)))
d3837 2
a3838 1
            len += 3;
d3875 1
a3875 1
    if (bat_file) {
d4240 2
d4278 3
d4282 1
d4284 3
d4288 1
d4308 3
d4312 1
d4513 4
d4535 15
d4563 1
d4637 4
d4642 1
d4730 4
d4810 1
a4810 1
         * the some runtime libraries puts it directly into the environ
d4823 2
d4833 1
a4833 1
     * already, but some RTLs don't.  Since we don't
d4837 1
a4837 1
#if !defined(__GNUC__)
d4852 12
d4916 23
d5032 34
a5065 3
    win32_create_message_window_class();
    return CreateWindow("PerlMessageWindowClass", "PerlMessageWindow",
                        0, 0, 0, 0, 0, HWND_MESSAGE, NULL, NULL, NULL);
d5119 3
a5121 3
         * processes in this group.
         * We re-enable Ctrl-C handling by calling SetConsoleCtrlHandler()
         * with a NULL handler.
d5123 2
a5124 1
        SetConsoleCtrlHandler(NULL,FALSE);
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d67 6
a72 1
#include <sys/utime.h>
d107 28
d151 1
a151 64
static BOOL	set_silent_invalid_parameter_handler(BOOL newvalue);
static void	my_invalid_parameter_handler(const wchar_t* expression,
			const wchar_t* function, const wchar_t* file,
			unsigned int line, uintptr_t pReserved);
#endif

static char*	get_regstr_from(HKEY hkey, const char *valuename, SV **svp);
static char*	get_regstr(const char *valuename, SV **svp);
static char*	get_emd_part(SV **prev_pathp, STRLEN *const len,
			char *trailing, ...);
static char*	win32_get_xlib(const char *pl, const char *xlib,
			const char *libname, STRLEN *const len);
static BOOL	has_shell_metachars(const char *ptr);
static long	tokenize(const char *str, char **dest, char ***destv);
static void	get_shell(void);
static char*	find_next_space(const char *s);
static int	do_spawn2(pTHX_ const char *cmd, int exectype);
static long	find_pid(pTHX_ int pid);
static void	remove_dead_process(long child);
static int	terminate_process(DWORD pid, HANDLE process_handle, int sig);
static int	my_kill(int pid, int sig);
static void	out_of_memory(void);
static char*	wstr_to_str(const wchar_t* wstr);
static long	filetime_to_clock(PFILETIME ft);
static BOOL	filetime_from_time(PFILETIME ft, time_t t);
static char*	create_command_line(char *cname, STRLEN clen,
			const char * const *args);
static char*	qualified_path(const char *cmd);
static void	ansify_path(void);
static LRESULT	win32_process_message(HWND hwnd, UINT msg,
			WPARAM wParam, LPARAM lParam);

#ifdef USE_ITHREADS
static long	find_pseudo_pid(pTHX_ int pid);
static void	remove_dead_pseudo_process(long child);
static HWND	get_hwnd_delay(pTHX, long child, DWORD tries);
#endif

#ifdef HAVE_INTERP_INTERN
static void	win32_csighandler(int sig);
#endif

START_EXTERN_C
HANDLE	w32_perldll_handle = INVALID_HANDLE_VALUE;
char	w32_module_name[MAX_PATH+1];
END_EXTERN_C

static OSVERSIONINFO g_osver = {0, 0, 0, 0, 0, ""};

#ifdef SET_INVALID_PARAMETER_HANDLER
static BOOL silent_invalid_parameter_handler = FALSE;

static BOOL
set_silent_invalid_parameter_handler(BOOL newvalue)
{
    BOOL oldvalue = silent_invalid_parameter_handler;
#  ifdef _DEBUG
    silent_invalid_parameter_handler = newvalue;
#  endif
    return oldvalue;
}

static void
my_invalid_parameter_handler(const wchar_t* expression,
d158 3
a160 14
    char* ansi_expression;
    char* ansi_function;
    char* ansi_file;
    if (silent_invalid_parameter_handler)
	return;
    ansi_expression = wstr_to_str(expression);
    ansi_function = wstr_to_str(function);
    ansi_file = wstr_to_str(file);
    fprintf(stderr, "Invalid parameter detected in function %s. "
                    "File: %s, line: %d\n", ansi_function, ansi_file, line);
    fprintf(stderr, "Expression: %s\n", ansi_expression);
    free(ansi_expression);
    free(ansi_function);
    free(ansi_file);
d343 1
a343 1
EXTERN_C char *
d346 1
d364 1
a391 1
        dTHX;
d401 1
a401 1
EXTERN_C char *
d411 1
a411 1
EXTERN_C char *
d506 1
d508 2
a509 2
	char *ret;
	char **retv;
d777 1
a777 1
    dTHXa(NULL);
a815 1
    aTHXa(PERL_GET_THX);
d886 1
d968 1
d982 1
a982 1
    PerlInterpreter *const to   = (PerlInterpreter *)PERL_GET_THX;
d1071 1
a1071 1
EXTERN_C char *
d1115 1
a1115 1
find_pid(pTHX_ int pid)
d1117 1
d1142 1
a1142 1
find_pseudo_pid(pTHX_ int pid)
d1144 1
a1273 44
#ifdef USE_ITHREADS
/* Get a child pseudo-process HWND, with retrying and delaying/yielding.
 * The "tries" parameter is the number of retries to make, with a Sleep(1)
 * (waiting and yielding the time slot) between each try. Specifying 0 causes
 * only Sleep(0) (no waiting and potentially no yielding) to be used, so is not
 * recommended
 * Returns an hwnd != INVALID_HANDLE_VALUE (so be aware that NULL can be
 * returned) or croaks if the child pseudo-process doesn't schedule and deliver
 * a HWND in the time period allowed.
 */
static HWND
get_hwnd_delay(pTHX, long child, DWORD tries)
{
    HWND hwnd = w32_pseudo_child_message_hwnds[child];
    if (hwnd != INVALID_HANDLE_VALUE) return hwnd;

    /* Pseudo-process has not yet properly initialized since hwnd isn't set.
     * Fast sleep: On some NT kernels/systems, a Sleep(0) won't deschedule a
     * thread 100% of the time since threads are attached to a CPU for NUMA and
     * caching reasons, and the child thread was attached to a different CPU
     * therefore there is no workload on that CPU and Sleep(0) returns control
     * without yielding the time slot.
     * https://rt.perl.org/rt3/Ticket/Display.html?id=88840
     */
    Sleep(0);
    win32_async_check(aTHX);
    hwnd = w32_pseudo_child_message_hwnds[child];
    if (hwnd != INVALID_HANDLE_VALUE) return hwnd;

    {
	unsigned int count = 0;
	/* No Sleep(1) if tries==0, just fail instead if we get this far. */
	while (count++ < tries) {
	    Sleep(1);
	    win32_async_check(aTHX);
	    hwnd = w32_pseudo_child_message_hwnds[child];
	    if (hwnd != INVALID_HANDLE_VALUE) return hwnd;
	}
    }

    Perl_croak(aTHX_ "panic: child pseudo-process was never scheduled");
}
#endif

d1282 1
a1282 1
	child = find_pseudo_pid(aTHX_ -pid);
d1284 1
d1287 15
a1301 2
		case 0:
		    /* "Does process exist?" use of kill */
d1303 2
d1306 32
a1337 42
		case 9: {
		    /* kill -9 style un-graceful exit */
		    /* Do a wait to make sure child starts and isn't in DLL
		     * Loader Lock */
		    HWND hwnd = get_hwnd_delay(aTHX, child, 5);
		    if (TerminateThread(hProcess, sig)) {
			/* Allow the scheduler to finish cleaning up the other
			 * thread.
			 * Otherwise, if we ExitProcess() before another context
			 * switch happens we will end up with a process exit
			 * code of "sig" instead of our own exit status.
			 * https://rt.cpan.org/Ticket/Display.html?id=66016#txn-908976
			 */
			Sleep(0);
			remove_dead_pseudo_process(child);
			return 0;
		    }
		    break;
		}

		default: {
		    HWND hwnd = get_hwnd_delay(aTHX, child, 5);
		    /* We fake signals to pseudo-processes using Win32
		     * message queue. */
		    if ((hwnd != NULL && PostMessage(hwnd, WM_USER_KILL, sig, 0)) ||
			PostThreadMessage(-pid, WM_USER_KILL, sig, 0))
		    {
			/* Don't wait for child process to terminate after we send a
			 * SIGTERM because the child may be blocked in a system call
			 * and never receive the signal.
			 */
			if (sig == SIGTERM) {
			    Sleep(0);
			    w32_pseudo_child_sigterm[child] = 1;
			}
			/* It might be us ... */
			PERL_ASYNC_CHECK();
			return 0;
		    }
		    break;
		}
	    } /* switch */
d1343 1
a1343 1
	child = find_pid(aTHX_ pid);
d1367 1
a1369 1
    dTHX;
d1590 7
a1596 2
    if (PL_curinterp)
	croak_no_mem();
a1599 26
void
win32_croak_not_implemented(const char * fname)
{
    PERL_ARGS_ASSERT_WIN32_CROAK_NOT_IMPLEMENTED;

    Perl_croak_nocontext("%s not implemented!\n", fname);
}

/* Converts a wide character (UTF-16) string to the Windows ANSI code page,
 * potentially using the system's default replacement character for any
 * unrepresentable characters. The caller must free() the returned string. */
static char*
wstr_to_str(const wchar_t* wstr)
{
    BOOL used_default = FALSE;
    size_t wlen = wcslen(wstr) + 1;
    int len = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, wstr, wlen,
                                   NULL, 0, NULL, NULL);
    char* str = (char*)malloc(len);
    if (!str)
        out_of_memory();
    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, wstr, wlen,
                        str, len, NULL, &used_default);
    return str;
}

d1625 1
a1625 1
    name = (char*)win32_malloc(len);
d1634 1
a1634 1
            WCHAR *shortname = (WCHAR*)win32_malloc(shortlen*sizeof(WCHAR));
d1641 1
a1641 1
            name = (char*)win32_realloc(name, len);
a1651 33
/* the returned string must be freed with win32_freeenvironmentstrings which is
 * implemented as a macro
 * void win32_freeenvironmentstrings(void* block)
 */
DllExport char *
win32_getenvironmentstrings(void)
{
    LPWSTR lpWStr, lpWTmp;
    LPSTR lpStr, lpTmp;
    DWORD env_len, wenvstrings_len = 0, aenvstrings_len = 0;

    /* Get the process environment strings */
    lpWTmp = lpWStr = (LPWSTR) GetEnvironmentStringsW();
    for (wenvstrings_len = 1; *lpWTmp != '\0'; lpWTmp += env_len + 1) {
        env_len = wcslen(lpWTmp);
        /* calculate the size of the environment strings */
        wenvstrings_len += env_len + 1;
    }

    /* Get the number of bytes required to store the ACP encoded string */
    aenvstrings_len = WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, 
                                          lpWStr, wenvstrings_len, NULL, 0, NULL, NULL);
    lpTmp = lpStr = (char *)win32_calloc(aenvstrings_len, sizeof(char));
    if(!lpTmp)
        out_of_memory();

    /* Convert the string from UTF-16 encoding to ACP encoding */
    WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS, lpWStr, wenvstrings_len, lpStr, 
                        aenvstrings_len, NULL, NULL);

    return(lpStr);
}

d1712 1
d1718 1
a1718 1
        curitem = (char *) win32_malloc(strlen(name)+1);
d1742 1
a1742 1
        win32_free(curitem);
d2088 1
a2088 2
    FT_t ticks = {0};
    unsigned __int64 endtime = timeout;
d2090 5
a2094 24
	GetSystemTimeAsFileTime(&ticks.ft_val);
	ticks.ft_i64 /= 10000;
	endtime += ticks.ft_i64;
    }
    /* This was a race condition. Do not let a non INFINITE timeout to
     * MsgWaitForMultipleObjects roll under 0 creating a near
     * infinity/~(UINT32)0 timeout which will appear as a deadlock to the
     * user who did a CORE perl function with a non infinity timeout,
     * sleep for example.  This is 64 to 32 truncation minefield.
     *
     * This scenario can only be created if the timespan from the return of
     * MsgWaitForMultipleObjects to GetSystemTimeAsFileTime exceeds 1 ms. To
     * generate the scenario, manual breakpoints in a C debugger are required,
     * or a context switch occured in win32_async_check in PeekMessage, or random
     * messages are delivered to the *thread* message queue of the Perl thread
     * from another process (msctf.dll doing IPC among its instances, VS debugger
     * causes msctf.dll to be loaded into Perl by kernel), see [perl #33096].
     */
    while (ticks.ft_i64 <= endtime) {
	/* if timeout's type is lengthened, remember to split 64b timeout
	 * into multiple non-infinity runs of MWFMO */
	DWORD result = MsgWaitForMultipleObjects(count, handles, FALSE,
						(DWORD)(endtime - ticks.ft_i64),
						QS_POSTMESSAGE|QS_TIMER|QS_SENDMESSAGE);
d2104 2
a2105 3
	    GetSystemTimeAsFileTime(&ticks.ft_val);
	    ticks.ft_i64 /= 10000;
	}
d2115 2
d2118 1
a2118 6
    if (!ticks.ft_i64 || ticks.ft_i64 > endtime)
	return 0;
    /* compute time left to wait */
    ticks.ft_i64 = endtime - ticks.ft_i64;
    /* if more ms than DWORD, then return max DWORD */
    return ticks.ft_i64 <= UINT_MAX ? (DWORD)ticks.ft_i64 : UINT_MAX;
d2122 1
a2122 1
win32_internal_wait(pTHX_ int *status, DWORD timeout)
d2127 1
d2193 1
a2193 1
	return win32_internal_wait(aTHX_ status, timeout);
d2196 1
a2196 1
	child = find_pseudo_pid(aTHX_ -pid);
d2220 1
a2220 1
	child = find_pid(aTHX_ pid);
d2265 1
a2265 2
    dTHX;
    return win32_internal_wait(aTHX_ status, INFINITE);
d2273 1
a2273 5
    if (t > UINT_MAX / 1000) {
	Perl_ck_warner(aTHX_ packWARN(WARN_OVERFLOW),
			"sleep(%lu) too large", t);
    }
    return win32_msgwait(aTHX_ 0, NULL, t * 1000, NULL) / 1000;
d2433 1
a2433 1
        dTHXa(NULL);
a2436 1
	aTHXa(PERL_GET_THX);
d2530 1
a2530 1
    dTHXa(NULL);
a2538 1
    aTHXa(PERL_GET_THX);
d2546 5
d2554 1
d2566 1
a2566 1
    dTHXa(NULL);
a2569 1
    aTHXa(PERL_GET_THX);
a2575 3
#ifdef WIN32_NO_SOCKETS
    return fclose(pf);
#else
a2576 1
#endif
d2685 1
a2701 1
		    PERL_DEB(dTHX;)
d2747 2
a2748 1
 Perl_croak_nocontext("List form of pipe open not implemented");
d2764 1
d2917 1
a2917 1
    dTHXa(NULL);
d2923 1
a2923 1
	((aTHXa(PERL_GET_THX)), wcscpy(wOldName, PerlDir_mapW(wOldName)),
d2928 1
a2928 31
    /* This isn't perfect, eg. Win32 returns ERROR_ACCESS_DENIED for
       both permissions errors and if the source is a directory, while
       POSIX wants EACCES and EPERM respectively.

       Determined by experimentation on Windows 7 x64 SP1, since MS
       don't document what error codes are returned.
    */
    switch (GetLastError()) {
    case ERROR_BAD_NET_NAME:
    case ERROR_BAD_NETPATH:
    case ERROR_BAD_PATHNAME:
    case ERROR_FILE_NOT_FOUND:
    case ERROR_FILENAME_EXCED_RANGE:
    case ERROR_INVALID_DRIVE:
    case ERROR_PATH_NOT_FOUND:
      errno = ENOENT;
      break;
    case ERROR_ALREADY_EXISTS:
      errno = EEXIST;
      break;
    case ERROR_ACCESS_DENIED:
      errno = EACCES;
      break;
    case ERROR_NOT_SAME_DEVICE:
      errno = EXDEV;
      break;
    default:
      /* ERROR_INVALID_FUNCTION - eg. on a FAT volume */
      errno = EINVAL;
      break;
    }
d3045 1
a3045 1
    dTHXa(NULL);
a3055 1
    aTHXa(PERL_GET_THX);
a3064 3
#ifdef WIN32_NO_SOCKETS
    return close(fd);
#else
a3065 1
#endif
d3136 1
d3162 1
a3162 1
    PERL_DEB(dTHX;)
d3317 1
d3334 2
a3335 4
    {
	dTHX;
	pathstr = PerlEnv_getenv("PATH");
    }
d3441 1
d3454 1
d3476 1
a3476 1
    dTHXa(NULL);
a3508 1
    aTHXa(PERL_GET_THX);
d3909 1
a3909 1
    dTHXa(NULL);
d3911 1
a3911 1
    const char *first;
a3928 1
    aTHXa(PERL_GET_THX);
d3960 1
a3960 1
    dTHXa(NULL);
a3963 1
#ifndef PERL_IS_MINIPERL
a3965 1
    aTHXa(PERL_GET_THX);
a3967 3
#else
    aTHXa(PERL_GET_THX);
#endif
d4055 1
a4055 1
    wide_path = (WCHAR*)win32_malloc(len*sizeof(WCHAR));
a4057 4
        if (newlen == 0) {
            win32_free(wide_path);
            return;
        }
d4061 1
a4061 1
        wide_path = (WCHAR*)win32_realloc(wide_path, len*sizeof(WCHAR));
d4090 1
a4090 1
            ansi_path = (char*)win32_realloc(ansi_path, newlen+1);
d4099 1
a4099 1
            ansi_path = (char*)win32_malloc(5+len+1);
d4178 1
d4196 1
a4196 1
    dTHXa(NULL);
d4199 1
a4199 11
	Sighandler_t result;
#ifdef SET_INVALID_PARAMETER_HANDLER
	/* Silence our invalid parameter handler since we expect to make some
	 * calls with invalid signal numbers giving a SIG_ERR result. */
	BOOL oldvalue = set_silent_invalid_parameter_handler(TRUE);
#endif
	result = signal(sig, subcode);
#ifdef SET_INVALID_PARAMETER_HANDLER
	set_silent_invalid_parameter_handler(oldvalue);
#endif
	aTHXa(PERL_GET_THX);
a4238 1
    dTHX;
d4244 1
a4244 1
            long child = find_pseudo_pid(aTHX_ (int)wParam);
d4246 1
d4255 1
d4265 1
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d45 1
a45 1
#if !defined(PERLIO_IS_STDIO)
a134 4
static int	do_spawn2_handles(pTHX_ const char *cmd, int exectype,
                        const int *handles);
static int	do_spawnvp_handles(int mode, const char *cmdname,
                        const char * const *argv, const int *handles);
a137 1
static int	my_killpg(int pid, int sig);
a162 3
#ifdef WIN32_DYN_IOINFO_SIZE
Size_t	w32_ioinfo_size;/* avoid 0 extend op b4 mul, otherwise could be a U8 */
#endif
d215 48
a262 29
    WCHAR modulename[MAX_PATH];
    WCHAR fullname[MAX_PATH];
    char *ansi;

    DWORD (__stdcall *pfnGetLongPathNameW)(LPCWSTR, LPWSTR, DWORD) =
        (DWORD (__stdcall *)(LPCWSTR, LPWSTR, DWORD))
        GetProcAddress(GetModuleHandle("kernel32.dll"), "GetLongPathNameW");

    GetModuleFileNameW(module, modulename, sizeof(modulename)/sizeof(WCHAR));

    /* Make sure we get an absolute pathname in case the module was loaded
     * explicitly by LoadLibrary() with a relative path. */
    GetFullPathNameW(modulename, sizeof(fullname)/sizeof(WCHAR), fullname, NULL);

    /* Make sure we start with the long path name of the module because we
     * later scan for pathname components to match "5.xx" to locate
     * compatible sitelib directories, and the short pathname might mangle
     * this path segment (e.g. by removing the dot on NTFS to something
     * like "5xx~1.yy") */
    if (pfnGetLongPathNameW)
        pfnGetLongPathNameW(fullname, fullname, sizeof(fullname)/sizeof(WCHAR));

    /* remove \\?\ prefix */
    if (memcmp(fullname, L"\\\\?\\", 4*sizeof(WCHAR)) == 0)
        memmove(fullname, fullname+4, (wcslen(fullname+4)+1)*sizeof(WCHAR));

    ansi = win32_ansipath(fullname);
    my_strlcpy(w32_module_name, ansi, sizeof(w32_module_name));
    win32_free(ansi);
d695 1
a695 6
do_spawn2(pTHX_ const char *cmd, int exectype) {
    return do_spawn2_handles(aTHX_ cmd, exectype, NULL);
}

static int
do_spawn2_handles(pTHX_ const char *cmd, int exectype, const int *handles)
d728 2
a729 2
		status = do_spawnvp_handles(P_NOWAIT, argv[0],
					    (const char* const*)argv, handles);
d756 2
a757 2
	    status = do_spawnvp_handles(P_NOWAIT, argv[0],
					(const char* const*)argv, handles);
d1260 2
a1261 3
/* returns number of processes killed */
static int
my_killpg(int pid, int sig)
d1281 1
a1281 1
                    killed += my_killpg(entry.th32ProcessID, sig);
a1291 1
/* returns number of processes killed */
d1299 1
a1299 1
        return my_killpg(pid, -sig);
a1776 2
    FreeEnvironmentStringsW(lpWStr);

d2516 1
a2516 1
            errno = EWOULDBLOCK;
a2524 15
extern int convert_wsa_error_to_errno(int wsaerr); /* in win32sck.c */

/* Get the errno value corresponding to the given err. This function is not
 * intended to handle conversion of general GetLastError() codes. It only exists
 * to translate Windows sockets error codes from WSAGetLastError(). Such codes
 * used to be assigned to errno/$! in earlier versions of perl; this function is
 * used to catch any old Perl code which is still trying to assign such values
 * to $! and convert them to errno values instead.
 */
int
win32_get_errno(int err)
{
    return convert_wsa_error_to_errno(err);
}

a2573 4
#ifdef ERRNO_HAS_POSIX_SUPPLEMENT
extern int convert_errno_to_wsa_error(int err); /* in win32sck.c */
#endif

d2577 1
a2577 3
 * we have to roll our own to cover the case of socket errors
 * that could not be converted to regular errno values by
 * get_last_socket_error() in win32/win32sck.c.
a2590 12
#ifdef ERRNO_HAS_POSIX_SUPPLEMENT
	/* VC10+ and some MinGW/gcc-4.8+ define a "POSIX supplement" of errno
	 * values ranging from EADDRINUSE (100) to EWOULDBLOCK (140), but
	 * sys_nerr is still 43 and strerror() returns "Unknown error" for them.
	 * We must therefore still roll our own messages for these codes, and
	 * additionally map them to corresponding Windows (sockets) error codes
	 * first to avoid getting the wrong system message.
	 */
	else if (e >= EADDRINUSE && e <= EWOULDBLOCK) {
	    e = convert_errno_to_wsa_error(e);
	}
#endif
a2919 1
    int handles[3];
d2921 1
a2921 1
    int stdfd;
d2925 1
d2958 5
a2962 4
    /* Previously this code redirected stdin/out temporarily so the
       child process inherited those handles, this caused race
       conditions when another thread was writing/reading those
       handles.
d2964 7
a2970 10
       To avoid that we just feed the handles to CreateProcess() so
       the handles are redirected only in the child.
     */
    handles[child] = p[child];
    handles[parent] = -1;
    handles[2] = -1;

    /* CreateProcess() requires inheritable handles */
    if (!SetHandleInformation((HANDLE)_get_osfhandle(p[child]), HANDLE_FLAG_INHERIT,
			      HANDLE_FLAG_INHERIT)) {
d2972 6
a2977 1
    }
d2982 2
d2985 2
a2986 1
	if ((childpid = do_spawn2_handles(aTHX_ command, EXECF_SPAWN_NOWAIT, handles)) == -1)
d2989 10
a2998 1
	win32_close(p[child]);
d3013 9
a3021 1

a3107 6
    case ERROR_DISK_FULL:
      errno = ENOSPC;
      break;
    case ERROR_NOT_ENOUGH_QUOTA:
      errno = EDQUOT;
      break;
a3141 6
        case ERROR_DISK_FULL:
            errno = ENOSPC;
            break;
        case ERROR_NOT_ENOUGH_QUOTA:
            errno = EDQUOT;
            break;
a3662 7
    return do_spawnvp_handles(mode, cmdname, argv, NULL);
#endif
}

static int
do_spawnvp_handles(int mode, const char *cmdname, const char *const *argv,
                const int *handles) {
a3719 1

d3733 3
a3735 6
    StartupInfo.hStdInput	= handles && handles[0] != -1 ?
            (HANDLE)_get_osfhandle(handles[0]) : tbl.childStdIn;
    StartupInfo.hStdOutput	= handles && handles[1] != -1 ?
            (HANDLE)_get_osfhandle(handles[1]) : tbl.childStdOut;
    StartupInfo.hStdError	= handles && handles[2] != -1 ?
	    (HANDLE)_get_osfhandle(handles[2]) : tbl.childStdErr;
d3815 1
d4155 1
a4155 4
    HMODULE module = (HMODULE)((w32_perldll_handle == INVALID_HANDLE_VALUE)
                               ? GetModuleHandle(NULL)
                               : w32_perldll_handle);
    pfn_init = (void (*)(pTHX))GetProcAddress(module, "init_Win32CORE");
a4368 12

#ifdef WIN32_DYN_IOINFO_SIZE
    {
	Size_t ioinfo_size = _msize((void*)__pioinfo[0]);;
	if((SSize_t)ioinfo_size <= 0) { /* -1 is err */
	    fprintf(stderr, "panic: invalid size for ioinfo\n"); /* no interp */
	    exit(1);
	}
	ioinfo_size /= IOINFO_ARRAY_ELTS;
	w32_ioinfo_size = ioinfo_size;
    }
#endif
@


1.1.1.16
log
@Import perl-5.24.2
@
text
@d45 3
a47 2

#define PerlIO FILE
d92 6
a123 1
#ifndef WIN32_NO_REGISTRY
a125 2
#endif

d128 1
a128 2
static char*	win32_get_xlib(const char *pl,
			WIN32_NO_REGISTRY_M_(const char *xlib)
a129 1

a138 2
static PerlIO * do_popen(const char *mode, const char *command, IV narg,
			 SV **args);
d149 2
a150 2
				    const char * const *args);
static char*	qualified_path(const char *cmd, bool other_exts);
a174 6
#ifndef WIN32_NO_REGISTRY
/* initialized by Perl_win32_init/PERL_SYS_INIT */
static HKEY HKCU_Perl_hnd;
static HKEY HKLM_Perl_hnd;
#endif

a261 1
#ifndef WIN32_NO_REGISTRY
d264 1
a264 1
get_regstr_from(HKEY handle, const char *valuename, SV **svp)
d267 1
d269 1
a271 1
    DWORD datalen;
d273 17
a289 13
    retval = RegQueryValueEx(handle, valuename, 0, &type, NULL, &datalen);
    if (retval == ERROR_SUCCESS
	&& (type == REG_SZ || type == REG_EXPAND_SZ))
    {
	dTHX;
	if (!*svp)
	    *svp = sv_2mortal(newSVpvs(""));
	SvGROW(*svp, datalen);
	retval = RegQueryValueEx(handle, valuename, 0, NULL,
				 (PBYTE)SvPVX(*svp), &datalen);
	if (retval == ERROR_SUCCESS) {
	    str = SvPVX(*svp);
	    SvCUR_set(*svp,datalen-1);
d291 1
d300 3
a302 13
    char *str;
    if (HKCU_Perl_hnd) {
	str = get_regstr_from(HKCU_Perl_hnd, valuename, svp);
	if (!str)
	    goto try_HKLM;
    }
    else {
	try_HKLM:
	if (HKLM_Perl_hnd)
	    str = get_regstr_from(HKLM_Perl_hnd, valuename, svp);
	else
	    str = NULL;
    }
a304 1
#endif /* ifndef WIN32_NO_REGISTRY */
d361 1
a361 1
	    *prev_pathp = sv_2mortal(newSVpvs(""));
d363 1
a363 1
	    sv_catpvs(*prev_pathp, ";");
d374 1
a374 1
win32_get_privlib(WIN32_NO_REGISTRY_M_(const char *pl) STRLEN *const len)
d377 1
a378 2
#ifndef WIN32_NO_REGISTRY
    char buffer[MAX_PATH+1];
a383 1
#endif
d390 2
a391 2
win32_get_xlib(const char *pl, WIN32_NO_REGISTRY_M_(const char *xlib)
	       const char *libname, STRLEN *const len)
a392 1
#ifndef WIN32_NO_REGISTRY
a393 1
#endif
a397 1
#ifndef WIN32_NO_REGISTRY
a400 1
#endif
a406 1
#ifndef WIN32_NO_REGISTRY
a408 1
#endif
d421 1
a421 1
	sv_catpv(sv1, ";");
d433 1
a433 1
    return win32_get_xlib(pl, WIN32_NO_REGISTRY_M_("sitelib") "site", len);
d443 1
a443 1
    return win32_get_xlib(pl, WIN32_NO_REGISTRY_M_("vendorlib") PERL_VENDORLIB_NAME, len);
a1124 1
#if !defined(__MINGW64_VERSION_MAJOR) || __MINGW64_VERSION_MAJOR < 4
a1144 1
#endif
d1444 4
d1488 1
a1488 1
    if (!w32_sloppystat) {
a1498 8
	else {
	    DWORD err = GetLastError();
	    /* very common case, skip CRT stat and its also failing syscalls */
	    if(err == ERROR_FILE_NOT_FOUND) {
		errno = ENOENT;
		return -1;
	    }
	}
d1788 1
a1788 1
	curitem = sv_2mortal(newSVpvs(""));
a1821 1
#ifndef WIN32_NO_REGISTRY
a1827 1
#endif
d2143 1
a2143 1
    /* Tell caller to exit thread/process as appropriate */
d2229 1
a2229 1
     * or a context switch occurred in win32_async_check in PeekMessage, or random
d2934 3
a2936 1
    get_shell();
d2938 5
a2942 2
    return do_popen(mode, NULL, narg, args);
}
d2944 6
a2949 2
STATIC PerlIO*
do_popen(const char *mode, const char *command, IV narg, SV **args) {
a2957 1
    const char **args_pvs = NULL;
d3011 2
a3012 23
	if (command) {
	    if ((childpid = do_spawn2_handles(aTHX_ command, EXECF_SPAWN_NOWAIT, handles)) == -1)
	        goto cleanup;

	}
	else {
	    int i;
	    const char *exe_name;

	    Newx(args_pvs, narg + 1 + w32_perlshell_items, const char *);
	    SAVEFREEPV(args_pvs);
	    for (i = 0; i < narg; ++i)
	        args_pvs[i] = SvPV_nolen(args[i]);
	    args_pvs[i] = NULL;
	    exe_name = qualified_path(args_pvs[0], TRUE);
	    if (!exe_name)
	        /* let CreateProcess() try to find it instead */
	        exe_name = args_pvs[0];

	    if ((childpid = do_spawnvp_handles(P_NOWAIT, exe_name, args_pvs, handles)) == -1) {
	        goto cleanup;
	    }
	}
a3030 1
}
a3031 13
/*
 * a popen() clone that respects PERL5SHELL
 *
 * changed to return PerlIO* rather than FILE * by BKS, 11-11-2000
 */

DllExport PerlIO*
win32_popen(const char *command, const char *mode)
{
#ifdef USE_RTL_POPEN
    return _popen(command, mode);
#else
    return do_popen(mode, command, 0, NULL);
d3218 1
d3345 1
a3345 1
    if (!dir || !*dir) {
a3521 7
static const char *exe_extensions[] =
  {
    ".exe", /* this must be first */
    ".cmd",
    ".bat"
  };

d3523 1
a3523 1
qualified_path(const char *cmd, bool other_exts)
d3562 4
a3565 10
	    int i;
	    /* first extension is .exe */
	    int ext_limit = other_exts ? C_ARRAY_LENGTH(exe_extensions) : 1;
	    for (i = 0; i < ext_limit; ++i) {
	        strcpy(curfullcmd, exe_extensions[i]);
	        res = GetFileAttributes(fullcmd);
	        if (res != 0xFFFFFFFF && !(res & FILE_ATTRIBUTE_DIRECTORY))
		    return fullcmd;
	    }

d3681 1
a3681 1
    return _spawnvp(mode, cmdname, (char * const *)argv);
d3802 1
a3802 1
	    fullcmd = qualified_path(cname, FALSE);
d3856 1
a3856 1
	return _spawnv(P_WAIT, cmdname, argv);
d3858 1
a3858 1
    return _execv(cmdname, argv);
d3878 1
a3878 1
    return _execvp(cmdname, argv);
d4159 1
a4159 1
	croak_xs_usage(cv, "[showwindow]");
a4175 29

#ifdef PERL_IS_MINIPERL
/* shelling out is much slower, full perl uses Win32.pm */
XS(w32_GetCwd)
{
    dXSARGS;
    /* Make the host for current directory */
    char* ptr = PerlEnv_get_childdir();
    /*
     * If ptr != Nullch
     *   then it worked, set PV valid,
     *   else return 'undef'
     */
    if (ptr) {
	SV *sv = sv_newmortal();
	sv_setpv(sv, ptr);
	PerlEnv_free_childdir(ptr);

#ifndef INCOMPLETE_TAINTS
	SvTAINTED_on(sv);
#endif

	ST(0) = sv;
	XSRETURN(1);
    }
    XSRETURN_UNDEF;
}
#endif

a4196 3
#ifdef PERL_IS_MINIPERL
    newXS("Win32::GetCwd", w32_GetCwd, file);
#endif
d4359 7
a4365 1
        win32_free(ansi_path);
a4415 14

#ifndef WIN32_NO_REGISTRY
    {
	LONG retval;
	retval = RegOpenKeyExW(HKEY_CURRENT_USER, L"SOFTWARE\\Perl", 0, KEY_READ, &HKCU_Perl_hnd);
	if (retval != ERROR_SUCCESS) {
	    HKCU_Perl_hnd = NULL;
	}
	retval = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Perl", 0, KEY_READ, &HKLM_Perl_hnd);
	if (retval != ERROR_SUCCESS) {
	    HKLM_Perl_hnd = NULL;
	}
    }
#endif
a4424 8
    LOCALE_TERM;
#ifndef WIN32_NO_REGISTRY
    /* handles might be NULL, RegCloseKey then returns ERROR_INVALID_HANDLE
       but no point of checking and we can't die() at this point */
    RegCloseKey(HKLM_Perl_hnd);
    RegCloseKey(HKCU_Perl_hnd);
    /* the handles are in an undefined state until the next PERL_SYS_INIT3 */
#endif
a4605 5
#ifdef PERL_IS_MINIPERL
    w32_sloppystat              = TRUE;
#else
    w32_sloppystat              = FALSE;
#endif
a4672 1
    dst->sloppystat             = src->sloppystat;
@


