head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.5.0.12
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.6
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.8
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.1.1.5.0.4
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.24
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.20
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.4.0.18
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.16
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.14
	OPENBSD_5_0:1.1.1.4.0.12
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.10
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.4.0.8
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.4
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.20
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.18
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.16
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.14
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.12
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.10
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.8
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.6
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.4
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.2
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.2.0.4
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.2
	OPENBSD_3_3_BASE:1.1.1.2
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.1.1.1.0.12
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	PERL_5_6_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.32.22;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.11.07;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.11.07;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.15.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.03.02.44.38;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.06;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.12;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* vmem.h
 *
 * (c) 1999 Microsoft Corporation. All rights reserved. 
 * Portions (c) 1999 ActiveState Tool Corp, http://www.ActiveState.com/
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 * Options:
 *
 * Defining _USE_MSVCRT_MEM_ALLOC will cause all memory allocations
 * to be forwarded to the compiler's MSVCR*.DLL. Defining _USE_LINKED_LIST as
 * well will track all allocations in a doubly linked list, so that the host can
 * free all memory allocated when it goes away.
 * If _USE_MSVCRT_MEM_ALLOC is not defined then Knuth's boundary tag algorithm
 * is used; defining _USE_BUDDY_BLOCKS will use Knuth's algorithm R
 * (Buddy system reservation)
 *
 */

#ifndef ___VMEM_H_INC___
#define ___VMEM_H_INC___

#ifndef UNDER_CE
#define _USE_MSVCRT_MEM_ALLOC
#endif
#define _USE_LINKED_LIST

// #define _USE_BUDDY_BLOCKS

// #define _DEBUG_MEM
#ifdef _DEBUG_MEM
#define ASSERT(f) if(!(f)) DebugBreak();

inline void MEMODS(char *str)
{
    OutputDebugString(str);
    OutputDebugString("\n");
}

inline void MEMODSlx(char *str, long x)
{
    char szBuffer[512];	
    sprintf(szBuffer, "%s %lx\n", str, x);
    OutputDebugString(szBuffer);
}

#define WALKHEAP() WalkHeap(0)
#define WALKHEAPTRACE() WalkHeap(1)

#else

#define ASSERT(f)
#define MEMODS(x)
#define MEMODSlx(x, y)
#define WALKHEAP()
#define WALKHEAPTRACE()

#endif

#ifdef _USE_MSVCRT_MEM_ALLOC

#ifndef _USE_LINKED_LIST
// #define _USE_LINKED_LIST
#endif

/* 
 * Pass all memory requests through to the compiler's msvcr*.dll.
 * Optionaly track by using a doubly linked header.
 */

#ifdef _USE_LINKED_LIST
class VMem;
typedef struct _MemoryBlockHeader* PMEMORY_BLOCK_HEADER;
typedef struct _MemoryBlockHeader {
    PMEMORY_BLOCK_HEADER    pNext;
    PMEMORY_BLOCK_HEADER    pPrev;
    VMem *owner;
} MEMORY_BLOCK_HEADER, *PMEMORY_BLOCK_HEADER;
#endif

class VMem
{
public:
    VMem();
    ~VMem();
    void* Malloc(size_t size);
    void* Realloc(void* pMem, size_t size);
    void Free(void* pMem);
    void GetLock(void);
    void FreeLock(void);
    int IsLocked(void);
    long Release(void);
    long AddRef(void);

    inline BOOL CreateOk(void)
    {
	return TRUE;
    };

protected:
#ifdef _USE_LINKED_LIST
    void LinkBlock(PMEMORY_BLOCK_HEADER ptr)
    {
	PMEMORY_BLOCK_HEADER next = m_Dummy.pNext;
	m_Dummy.pNext = ptr;
	ptr->pPrev = &m_Dummy;
	ptr->pNext = next;
        ptr->owner = this;
	next->pPrev = ptr;
    }
    void UnlinkBlock(PMEMORY_BLOCK_HEADER ptr)
    {
	PMEMORY_BLOCK_HEADER next = ptr->pNext;
	PMEMORY_BLOCK_HEADER prev = ptr->pPrev;
	prev->pNext = next;
	next->pPrev = prev;
    }

    MEMORY_BLOCK_HEADER	m_Dummy;
    CRITICAL_SECTION	m_cs;		// access lock
#endif

    long		m_lRefCount;	// number of current users
};

VMem::VMem()
{
    m_lRefCount = 1;
#ifdef _USE_LINKED_LIST
    InitializeCriticalSection(&m_cs);
    m_Dummy.pNext = m_Dummy.pPrev =  &m_Dummy;
    m_Dummy.owner = this;
#endif
}

VMem::~VMem(void)
{
#ifdef _USE_LINKED_LIST
    while (m_Dummy.pNext != &m_Dummy) {
	Free(m_Dummy.pNext+1);
    }
    DeleteCriticalSection(&m_cs);
#endif
}

void* VMem::Malloc(size_t size)
{
#ifdef _USE_LINKED_LIST
    GetLock();
    PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)malloc(size+sizeof(MEMORY_BLOCK_HEADER));
    if (!ptr) {
	FreeLock();
	return NULL;
    }
    LinkBlock(ptr);
    FreeLock();
    return (ptr+1);
#else
    return malloc(size);
#endif
}

void* VMem::Realloc(void* pMem, size_t size)
{
#ifdef _USE_LINKED_LIST
    if (!pMem)
	return Malloc(size);

    if (!size) {
	Free(pMem);
	return NULL;
    }

    GetLock();
    PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)(((char*)pMem)-sizeof(MEMORY_BLOCK_HEADER));
    UnlinkBlock(ptr);
    ptr = (PMEMORY_BLOCK_HEADER)realloc(ptr, size+sizeof(MEMORY_BLOCK_HEADER));
    if (!ptr) {
	FreeLock();
	return NULL;
    }
    LinkBlock(ptr);
    FreeLock();

    return (ptr+1);
#else
    return realloc(pMem, size);
#endif
}

void VMem::Free(void* pMem)
{
#ifdef _USE_LINKED_LIST
    if (pMem) {
	PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)(((char*)pMem)-sizeof(MEMORY_BLOCK_HEADER));
        if (ptr->owner != this) {
	    if (ptr->owner) {
#if 1
	    	int *nowhere = NULL;
	    	Perl_warn_nocontext("Free to wrong pool %p not %p",this,ptr->owner);
            	*nowhere = 0; /* this segfault is deliberate, 
            	                 so you can see the stack trace */
#else
                ptr->owner->Free(pMem);	
#endif
	    }
	    return;
        }
	GetLock();
	UnlinkBlock(ptr);
	ptr->owner = NULL;
	free(ptr);
	FreeLock();
    }
#else /*_USE_LINKED_LIST*/
    free(pMem);
#endif
}

void VMem::GetLock(void)
{
#ifdef _USE_LINKED_LIST
    EnterCriticalSection(&m_cs);
#endif
}

void VMem::FreeLock(void)
{
#ifdef _USE_LINKED_LIST
    LeaveCriticalSection(&m_cs);
#endif
}

int VMem::IsLocked(void)
{
#if 0
    /* XXX TryEnterCriticalSection() is not available in some versions
     * of Windows 95.  Since this code is not used anywhere yet, we 
     * skirt the issue for now. */
    BOOL bAccessed = TryEnterCriticalSection(&m_cs);
    if(bAccessed) {
	LeaveCriticalSection(&m_cs);
    }
    return !bAccessed;
#else
    ASSERT(0);	/* alarm bells for when somebody calls this */
    return 0;
#endif
}

long VMem::Release(void)
{
    long lCount = InterlockedDecrement(&m_lRefCount);
    if(!lCount)
	delete this;
    return lCount;
}

long VMem::AddRef(void)
{
    long lCount = InterlockedIncrement(&m_lRefCount);
    return lCount;
}

#else	/* _USE_MSVCRT_MEM_ALLOC */

/*
 * Knuth's boundary tag algorithm Vol #1, Page 440.
 *
 * Each block in the heap has tag words before and after it,
 *  TAG
 *  block
 *  TAG
 * The size is stored in these tags as a long word, and includes the 8 bytes
 * of overhead that the boundary tags consume.  Blocks are allocated on long
 * word boundaries, so the size is always multiples of long words.  When the
 * block is allocated, bit 0, (the tag bit), of the size is set to 1.  When 
 * a block is freed, it is merged with adjacent free blocks, and the tag bit
 * is set to 0.
 *
 * A linked list is used to manage the free list. The first two long words of
 * the block contain double links.  These links are only valid when the block
 * is freed, therefore space needs to be reserved for them.  Thus, the minimum
 * block size (not counting the tags) is 8 bytes.
 *
 * Since memory allocation may occur on a single threaded, explicit locks are not
 * provided.
 * 
 */

const long lAllocStart = 0x00020000; /* start at 128K */
const long minBlockSize = sizeof(void*)*2;
const long sizeofTag = sizeof(long);
const long blockOverhead = sizeofTag*2;
const long minAllocSize = minBlockSize+blockOverhead;
#ifdef _USE_BUDDY_BLOCKS
const long lSmallBlockSize = 1024;
const size_t nListEntries = ((lSmallBlockSize-minAllocSize)/sizeof(long));

inline size_t CalcEntry(size_t size)
{
    ASSERT((size&(sizeof(long)-1)) == 0);
    return ((size - minAllocSize) / sizeof(long));
}
#endif

typedef BYTE* PBLOCK;	/* pointer to a memory block */

/*
 * Macros for accessing hidden fields in a memory block:
 *
 * SIZE	    size of this block (tag bit 0 is 1 if block is allocated)
 * PSIZE    size of previous physical block
 */

#define SIZE(block)	(*(ULONG*)(((PBLOCK)(block))-sizeofTag))
#define PSIZE(block)	(*(ULONG*)(((PBLOCK)(block))-(blockOverhead)))
inline void SetTags(PBLOCK block, long size)
{
    SIZE(block) = size;
    PSIZE(block+(size&~1)) = size;
}

/*
 * Free list pointers
 * PREV	pointer to previous block
 * NEXT	pointer to next block
 */

#define PREV(block)	(*(PBLOCK*)(block))
#define NEXT(block)	(*(PBLOCK*)((block)+sizeof(PBLOCK)))
inline void SetLink(PBLOCK block, PBLOCK prev, PBLOCK next)
{
    PREV(block) = prev;
    NEXT(block) = next;
}
inline void Unlink(PBLOCK p)
{
    PBLOCK next = NEXT(p);
    PBLOCK prev = PREV(p);
    NEXT(prev) = next;
    PREV(next) = prev;
}
#ifndef _USE_BUDDY_BLOCKS
inline void AddToFreeList(PBLOCK block, PBLOCK pInList)
{
    PBLOCK next = NEXT(pInList);
    NEXT(pInList) = block;
    SetLink(block, pInList, next);
    PREV(next) = block;
}
#endif

/* Macro for rounding up to the next sizeof(long) */
#define ROUND_UP(n)	(((ULONG)(n)+sizeof(long)-1)&~(sizeof(long)-1))
#define ROUND_UP64K(n)	(((ULONG)(n)+0x10000-1)&~(0x10000-1))
#define ROUND_DOWN(n)	((ULONG)(n)&~(sizeof(long)-1))

/*
 * HeapRec - a list of all non-contiguous heap areas
 *
 * Each record in this array contains information about a non-contiguous heap area.
 */

const int maxHeaps = 32; /* 64 was overkill */
const long lAllocMax   = 0x80000000; /* max size of allocation */

#ifdef _USE_BUDDY_BLOCKS
typedef struct _FreeListEntry
{
    BYTE    Dummy[minAllocSize];	// dummy free block
} FREE_LIST_ENTRY, *PFREE_LIST_ENTRY;
#endif

#ifndef _USE_BUDDY_BLOCKS
#define USE_BIGBLOCK_ALLOC
#endif
/*
 * performance tuning
 * Use VirtualAlloc() for blocks bigger than nMaxHeapAllocSize since
 * Windows 95/98/Me have heap managers that are designed for memory 
 * blocks smaller than four megabytes.
 */

#ifdef USE_BIGBLOCK_ALLOC
const int nMaxHeapAllocSize = (1024*512);  /* don't allocate anything larger than this from the heap */
#endif

typedef struct _HeapRec
{
    PBLOCK	base;	/* base of heap area */
    ULONG	len;	/* size of heap area */
#ifdef USE_BIGBLOCK_ALLOC
    BOOL	bBigBlock;  /* was allocate using VirtualAlloc */
#endif
} HeapRec;

class VMem
{
public:
    VMem();
    ~VMem();
    void* Malloc(size_t size);
    void* Realloc(void* pMem, size_t size);
    void Free(void* pMem);
    void GetLock(void);
    void FreeLock(void);
    int IsLocked(void);
    long Release(void);
    long AddRef(void);

    inline BOOL CreateOk(void)
    {
#ifdef _USE_BUDDY_BLOCKS
	return TRUE;
#else
	return m_hHeap != NULL;
#endif
    };

    void ReInit(void);

protected:
    void Init(void);
    int Getmem(size_t size);

    int HeapAdd(void* ptr, size_t size
#ifdef USE_BIGBLOCK_ALLOC
	, BOOL bBigBlock
#endif
    );

    void* Expand(void* block, size_t size);

#ifdef _USE_BUDDY_BLOCKS
    inline PBLOCK GetFreeListLink(int index)
    {
	if (index >= nListEntries)
	    index = nListEntries-1;
	return &m_FreeList[index].Dummy[sizeofTag];
    }
    inline PBLOCK GetOverSizeFreeList(void)
    {
	return &m_FreeList[nListEntries-1].Dummy[sizeofTag];
    }
    inline PBLOCK GetEOLFreeList(void)
    {
	return &m_FreeList[nListEntries].Dummy[sizeofTag];
    }

    void AddToFreeList(PBLOCK block, size_t size)
    {
	PBLOCK pFreeList = GetFreeListLink(CalcEntry(size));
	PBLOCK next = NEXT(pFreeList);
	NEXT(pFreeList) = block;
	SetLink(block, pFreeList, next);
	PREV(next) = block;
    }
#endif
    inline size_t CalcAllocSize(size_t size)
    {
	/*
	 * Adjust the real size of the block to be a multiple of sizeof(long), and add
	 * the overhead for the boundary tags.  Disallow negative or zero sizes.
	 */
	return (size < minBlockSize) ? minAllocSize : (size_t)ROUND_UP(size) + blockOverhead;
    }

#ifdef _USE_BUDDY_BLOCKS
    FREE_LIST_ENTRY	m_FreeList[nListEntries+1];	// free list with dummy end of list entry as well
#else
    HANDLE		m_hHeap;		    // memory heap for this script
    char		m_FreeDummy[minAllocSize];  // dummy free block
    PBLOCK		m_pFreeList;		    // pointer to first block on free list
#endif
    PBLOCK		m_pRover;		    // roving pointer into the free list
    HeapRec		m_heaps[maxHeaps];	    // list of all non-contiguous heap areas 
    int			m_nHeaps;		    // no. of heaps in m_heaps 
    long		m_lAllocSize;		    // current alloc size
    long		m_lRefCount;		    // number of current users
    CRITICAL_SECTION	m_cs;			    // access lock

#ifdef _DEBUG_MEM
    void WalkHeap(int complete);
    void MemoryUsageMessage(char *str, long x, long y, int c);
    FILE*		m_pLog;
#endif
};

VMem::VMem()
{
    m_lRefCount = 1;
#ifndef _USE_BUDDY_BLOCKS
    BOOL bRet = (NULL != (m_hHeap = HeapCreate(HEAP_NO_SERIALIZE,
				lAllocStart,	/* initial size of heap */
				0)));		/* no upper limit on size of heap */
    ASSERT(bRet);
#endif

    InitializeCriticalSection(&m_cs);
#ifdef _DEBUG_MEM
    m_pLog = 0;
#endif

    Init();
}

VMem::~VMem(void)
{
#ifndef _USE_BUDDY_BLOCKS
    ASSERT(HeapValidate(m_hHeap, HEAP_NO_SERIALIZE, NULL));
#endif
    WALKHEAPTRACE();

    DeleteCriticalSection(&m_cs);
#ifdef _USE_BUDDY_BLOCKS
    for(int index = 0; index < m_nHeaps; ++index) {
	VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
    }
#else /* !_USE_BUDDY_BLOCKS */
#ifdef USE_BIGBLOCK_ALLOC
    for(int index = 0; index < m_nHeaps; ++index) {
	if (m_heaps[index].bBigBlock) {
	    VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
	}
    }
#endif
    BOOL bRet = HeapDestroy(m_hHeap);
    ASSERT(bRet);
#endif /* _USE_BUDDY_BLOCKS */
}

void VMem::ReInit(void)
{
    for(int index = 0; index < m_nHeaps; ++index) {
#ifdef _USE_BUDDY_BLOCKS
	VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
#else
#ifdef USE_BIGBLOCK_ALLOC
	if (m_heaps[index].bBigBlock) {
	    VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
	}
	else
#endif
	    HeapFree(m_hHeap, HEAP_NO_SERIALIZE, m_heaps[index].base);
#endif /* _USE_BUDDY_BLOCKS */
    }

    Init();
}

void VMem::Init(void)
{
#ifdef _USE_BUDDY_BLOCKS
    PBLOCK pFreeList;
    /*
     * Initialize the free list by placing a dummy zero-length block on it.
     * Set the end of list marker.
     * Set the number of non-contiguous heaps to zero.
     * Set the next allocation size.
     */
    for (int index = 0; index < nListEntries; ++index) {
	pFreeList = GetFreeListLink(index);
	SIZE(pFreeList) = PSIZE(pFreeList+minAllocSize) = 0;
	PREV(pFreeList) = NEXT(pFreeList) = pFreeList;
    }
    pFreeList = GetEOLFreeList();
    SIZE(pFreeList) = PSIZE(pFreeList+minAllocSize) = 0;
    PREV(pFreeList) = NEXT(pFreeList) = NULL;
    m_pRover = GetOverSizeFreeList();
#else
    /*
     * Initialize the free list by placing a dummy zero-length block on it.
     * Set the number of non-contiguous heaps to zero.
     */
    m_pFreeList = m_pRover = (PBLOCK)(&m_FreeDummy[sizeofTag]);
    PSIZE(m_pFreeList+minAllocSize) = SIZE(m_pFreeList) = 0;
    PREV(m_pFreeList) = NEXT(m_pFreeList) = m_pFreeList;
#endif

    m_nHeaps = 0;
    m_lAllocSize = lAllocStart;
}

void* VMem::Malloc(size_t size)
{
    WALKHEAP();

    PBLOCK ptr;
    size_t lsize, rem;
    /*
     * Disallow negative or zero sizes.
     */
    size_t realsize = CalcAllocSize(size);
    if((int)realsize < minAllocSize || size == 0)
	return NULL;

#ifdef _USE_BUDDY_BLOCKS
    /*
     * Check the free list of small blocks if this is free use it
     * Otherwise check the rover if it has no blocks then
     * Scan the free list entries use the first free block
     * split the block if needed, stop at end of list marker
     */
    {
	int index = CalcEntry(realsize);
	if (index < nListEntries-1) {
	    ptr = GetFreeListLink(index);
	    lsize = SIZE(ptr);
	    if (lsize >= realsize) {
		rem = lsize - realsize;
		if(rem < minAllocSize) {
		    /* Unlink the block from the free list. */
		    Unlink(ptr);
		}
		else {
		    /*
		     * split the block
		     * The remainder is big enough to split off into a new block.
		     * Use the end of the block, resize the beginning of the block
		     * no need to change the free list.
		     */
		    SetTags(ptr, rem);
		    ptr += SIZE(ptr);
		    lsize = realsize;
		}
		SetTags(ptr, lsize | 1);
		return ptr;
	    }
	    ptr = m_pRover;
	    lsize = SIZE(ptr);
	    if (lsize >= realsize) {
		rem = lsize - realsize;
		if(rem < minAllocSize) {
		    /* Unlink the block from the free list. */
		    Unlink(ptr);
		}
		else {
		    /*
		     * split the block
		     * The remainder is big enough to split off into a new block.
		     * Use the end of the block, resize the beginning of the block
		     * no need to change the free list.
		     */
		    SetTags(ptr, rem);
		    ptr += SIZE(ptr);
		    lsize = realsize;
		}
		SetTags(ptr, lsize | 1);
		return ptr;
	    }
	    ptr = GetFreeListLink(index+1);
	    while (NEXT(ptr)) {
		lsize = SIZE(ptr);
		if (lsize >= realsize) {
		    size_t rem = lsize - realsize;
		    if(rem < minAllocSize) {
			/* Unlink the block from the free list. */
			Unlink(ptr);
		    }
		    else {
			/*
			 * split the block
			 * The remainder is big enough to split off into a new block.
			 * Use the end of the block, resize the beginning of the block
			 * no need to change the free list.
			 */
			SetTags(ptr, rem);
			ptr += SIZE(ptr);
			lsize = realsize;
		    }
		    SetTags(ptr, lsize | 1);
		    return ptr;
		}
		ptr += sizeof(FREE_LIST_ENTRY);
	    }
	}
    }
#endif

    /*
     * Start searching the free list at the rover.  If we arrive back at rover without
     * finding anything, allocate some memory from the heap and try again.
     */
    ptr = m_pRover;	/* start searching at rover */
    int loops = 2;	/* allow two times through the loop  */
    for(;;) {
	lsize = SIZE(ptr);
	ASSERT((lsize&1)==0);
	/* is block big enough? */
	if(lsize >= realsize) {	
	    /* if the remainder is too small, don't bother splitting the block. */
	    rem = lsize - realsize;
	    if(rem < minAllocSize) {
		if(m_pRover == ptr)
		    m_pRover = NEXT(ptr);

		/* Unlink the block from the free list. */
		Unlink(ptr);
	    }
	    else {
		/*
		 * split the block
		 * The remainder is big enough to split off into a new block.
		 * Use the end of the block, resize the beginning of the block
		 * no need to change the free list.
		 */
		SetTags(ptr, rem);
		ptr += SIZE(ptr);
		lsize = realsize;
	    }
	    /* Set the boundary tags to mark it as allocated. */
	    SetTags(ptr, lsize | 1);
	    return ((void *)ptr);
	}

	/*
	 * This block was unsuitable.  If we've gone through this list once already without
	 * finding anything, allocate some new memory from the heap and try again.
	 */
	ptr = NEXT(ptr);
	if(ptr == m_pRover) {
	    if(!(loops-- && Getmem(realsize))) {
		return NULL;
	    }
	    ptr = m_pRover;
	}
    }
}

void* VMem::Realloc(void* block, size_t size)
{
    WALKHEAP();

    /* if size is zero, free the block. */
    if(size == 0) {
	Free(block);
	return (NULL);
    }

    /* if block pointer is NULL, do a Malloc(). */
    if(block == NULL)
	return Malloc(size);

    /*
     * Grow or shrink the block in place.
     * if the block grows then the next block will be used if free
     */
    if(Expand(block, size) != NULL)
	return block;

    size_t realsize = CalcAllocSize(size);
    if((int)realsize < minAllocSize)
	return NULL;

    /*
     * see if the previous block is free, and is it big enough to cover the new size
     * if merged with the current block.
     */
    PBLOCK ptr = (PBLOCK)block;
    size_t cursize = SIZE(ptr) & ~1;
    size_t psize = PSIZE(ptr);
    if((psize&1) == 0 && (psize + cursize) >= realsize) {
	PBLOCK prev = ptr - psize;
	if(m_pRover == prev)
	    m_pRover = NEXT(prev);

	/* Unlink the next block from the free list. */
	Unlink(prev);

	/* Copy contents of old block to new location, make it the current block. */
	memmove(prev, ptr, cursize);
	cursize += psize;	/* combine sizes */
	ptr = prev;

	size_t rem = cursize - realsize;
	if(rem >= minAllocSize) {
	    /*
	     * The remainder is big enough to be a new block.  Set boundary
	     * tags for the resized block and the new block.
	     */
	    prev = ptr + realsize;
	    /*
	     * add the new block to the free list.
	     * next block cannot be free
	     */
	    SetTags(prev, rem);
#ifdef _USE_BUDDY_BLOCKS
	    AddToFreeList(prev, rem);
#else
	    AddToFreeList(prev, m_pFreeList);
#endif
	    cursize = realsize;
        }
	/* Set the boundary tags to mark it as allocated. */
	SetTags(ptr, cursize | 1);
        return ((void *)ptr);
    }

    /* Allocate a new block, copy the old to the new, and free the old. */
    if((ptr = (PBLOCK)Malloc(size)) != NULL) {
	memmove(ptr, block, cursize-blockOverhead);
	Free(block);
    }
    return ((void *)ptr);
}

void VMem::Free(void* p)
{
    WALKHEAP();

    /* Ignore null pointer. */
    if(p == NULL)
	return;

    PBLOCK ptr = (PBLOCK)p;

    /* Check for attempt to free a block that's already free. */
    size_t size = SIZE(ptr);
    if((size&1) == 0) {
	MEMODSlx("Attempt to free previously freed block", (long)p);
	return;
    }
    size &= ~1;	/* remove allocated tag */

    /* if previous block is free, add this block to it. */
#ifndef _USE_BUDDY_BLOCKS
    int linked = FALSE;
#endif
    size_t psize = PSIZE(ptr);
    if((psize&1) == 0) {
	ptr -= psize;	/* point to previous block */
	size += psize;	/* merge the sizes of the two blocks */
#ifdef _USE_BUDDY_BLOCKS
	Unlink(ptr);
#else
	linked = TRUE;	/* it's already on the free list */
#endif
    }

    /* if the next physical block is free, merge it with this block. */
    PBLOCK next = ptr + size;	/* point to next physical block */
    size_t nsize = SIZE(next);
    if((nsize&1) == 0) {
	/* block is free move rover if needed */
	if(m_pRover == next)
	    m_pRover = NEXT(next);

	/* unlink the next block from the free list. */
	Unlink(next);

	/* merge the sizes of this block and the next block. */
	size += nsize;
    }

    /* Set the boundary tags for the block; */
    SetTags(ptr, size);

    /* Link the block to the head of the free list. */
#ifdef _USE_BUDDY_BLOCKS
	AddToFreeList(ptr, size);
#else
    if(!linked) {
	AddToFreeList(ptr, m_pFreeList);
    }
#endif
}

void VMem::GetLock(void)
{
    EnterCriticalSection(&m_cs);
}

void VMem::FreeLock(void)
{
    LeaveCriticalSection(&m_cs);
}

int VMem::IsLocked(void)
{
#if 0
    /* XXX TryEnterCriticalSection() is not available in some versions
     * of Windows 95.  Since this code is not used anywhere yet, we 
     * skirt the issue for now. */
    BOOL bAccessed = TryEnterCriticalSection(&m_cs);
    if(bAccessed) {
	LeaveCriticalSection(&m_cs);
    }
    return !bAccessed;
#else
    ASSERT(0);	/* alarm bells for when somebody calls this */
    return 0;
#endif
}


long VMem::Release(void)
{
    long lCount = InterlockedDecrement(&m_lRefCount);
    if(!lCount)
	delete this;
    return lCount;
}

long VMem::AddRef(void)
{
    long lCount = InterlockedIncrement(&m_lRefCount);
    return lCount;
}


int VMem::Getmem(size_t requestSize)
{   /* returns -1 is successful 0 if not */
#ifdef USE_BIGBLOCK_ALLOC
    BOOL bBigBlock;
#endif
    void *ptr;

    /* Round up size to next multiple of 64K. */
    size_t size = (size_t)ROUND_UP64K(requestSize);

    /*
     * if the size requested is smaller than our current allocation size
     * adjust up
     */
    if(size < (unsigned long)m_lAllocSize)
	size = m_lAllocSize;

    /* Update the size to allocate on the next request */
    if(m_lAllocSize != lAllocMax)
	m_lAllocSize <<= 2;

#ifndef _USE_BUDDY_BLOCKS
    if(m_nHeaps != 0
#ifdef USE_BIGBLOCK_ALLOC
	&& !m_heaps[m_nHeaps-1].bBigBlock
#endif
		    ) {
	/* Expand the last allocated heap */
	ptr = HeapReAlloc(m_hHeap, HEAP_REALLOC_IN_PLACE_ONLY|HEAP_NO_SERIALIZE,
		m_heaps[m_nHeaps-1].base,
		m_heaps[m_nHeaps-1].len + size);
	if(ptr != 0) {
	    HeapAdd(((char*)ptr) + m_heaps[m_nHeaps-1].len, size
#ifdef USE_BIGBLOCK_ALLOC
		, FALSE
#endif
		);
	    return -1;
	}
    }
#endif /* _USE_BUDDY_BLOCKS */

    /*
     * if we didn't expand a block to cover the requested size
     * allocate a new Heap
     * the size of this block must include the additional dummy tags at either end
     * the above ROUND_UP64K may not have added any memory to include this.
     */
    if(size == requestSize)
	size = (size_t)ROUND_UP64K(requestSize+(blockOverhead));

Restart:
#ifdef _USE_BUDDY_BLOCKS
    ptr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
#else
#ifdef USE_BIGBLOCK_ALLOC
    bBigBlock = FALSE;
    if (size >= nMaxHeapAllocSize) {
	bBigBlock = TRUE;
	ptr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
    }
    else
#endif
    ptr = HeapAlloc(m_hHeap, HEAP_NO_SERIALIZE, size);
#endif /* _USE_BUDDY_BLOCKS */

    if (!ptr) {
	/* try to allocate a smaller chunk */
	size >>= 1;
	if(size > requestSize)
	    goto Restart;
    }

    if(ptr == 0) {
	MEMODSlx("HeapAlloc failed on size!!!", size);
	return 0;
    }

#ifdef _USE_BUDDY_BLOCKS
    if (HeapAdd(ptr, size)) {
	VirtualFree(ptr, 0, MEM_RELEASE);
	return 0;
    }
#else
#ifdef USE_BIGBLOCK_ALLOC
    if (HeapAdd(ptr, size, bBigBlock)) {
	if (bBigBlock) {
	    VirtualFree(ptr, 0, MEM_RELEASE);
	}
    }
#else
    HeapAdd(ptr, size);
#endif
#endif /* _USE_BUDDY_BLOCKS */
    return -1;
}

int VMem::HeapAdd(void* p, size_t size
#ifdef USE_BIGBLOCK_ALLOC
    , BOOL bBigBlock
#endif
    )
{   /* if the block can be successfully added to the heap, returns 0; otherwise -1. */
    int index;

    /* Check size, then round size down to next long word boundary. */
    if(size < minAllocSize)
	return -1;

    size = (size_t)ROUND_DOWN(size);
    PBLOCK ptr = (PBLOCK)p;

#ifdef USE_BIGBLOCK_ALLOC
    if (!bBigBlock) {
#endif
	/*
	 * Search for another heap area that's contiguous with the bottom of this new area.
	 * (It should be extremely unusual to find one that's contiguous with the top).
	 */
	for(index = 0; index < m_nHeaps; ++index) {
	    if(ptr == m_heaps[index].base + (int)m_heaps[index].len) {
		/*
		 * The new block is contiguous with a previously allocated heap area.  Add its
		 * length to that of the previous heap.  Merge it with the dummy end-of-heap
		 * area marker of the previous heap.
		 */
		m_heaps[index].len += size;
		break;
	    }
	}
#ifdef USE_BIGBLOCK_ALLOC
    }
    else {
	index = m_nHeaps;
    }
#endif

    if(index == m_nHeaps) {
	/* The new block is not contiguous, or is BigBlock.  Add it to the heap list. */
	if(m_nHeaps == maxHeaps) {
	    return -1;	/* too many non-contiguous heaps */
	}
	m_heaps[m_nHeaps].base = ptr;
	m_heaps[m_nHeaps].len = size;
#ifdef USE_BIGBLOCK_ALLOC
	m_heaps[m_nHeaps].bBigBlock = bBigBlock;
#endif
	m_nHeaps++;

	/*
	 * Reserve the first LONG in the block for the ending boundary tag of a dummy
	 * block at the start of the heap area.
	 */
	size -= blockOverhead;
	ptr += blockOverhead;
	PSIZE(ptr) = 1;	/* mark the dummy previous block as allocated */
    }

    /*
     * Convert the heap to one large block.  Set up its boundary tags, and those of
     * marker block after it.  The marker block before the heap will already have
     * been set up if this heap is not contiguous with the end of another heap.
     */
    SetTags(ptr, size | 1);
    PBLOCK next = ptr + size;	/* point to dummy end block */
    SIZE(next) = 1;	/* mark the dummy end block as allocated */

    /*
     * Link the block to the start of the free list by calling free().
     * This will merge the block with any adjacent free blocks.
     */
    Free(ptr);
    return 0;
}


void* VMem::Expand(void* block, size_t size)
{
    /*
     * Disallow negative or zero sizes.
     */
    size_t realsize = CalcAllocSize(size);
    if((int)realsize < minAllocSize || size == 0)
	return NULL;

    PBLOCK ptr = (PBLOCK)block; 

    /* if the current size is the same as requested, do nothing. */
    size_t cursize = SIZE(ptr) & ~1;
    if(cursize == realsize) {
	return block;
    }

    /* if the block is being shrunk, convert the remainder of the block into a new free block. */
    if(realsize <= cursize) {
	size_t nextsize = cursize - realsize;	/* size of new remainder block */
	if(nextsize >= minAllocSize) {
	    /*
	     * Split the block
	     * Set boundary tags for the resized block and the new block.
	     */
	    SetTags(ptr, realsize | 1);
	    ptr += realsize;

	    /*
	     * add the new block to the free list.
	     * call Free to merge this block with next block if free
	     */
	    SetTags(ptr, nextsize | 1);
	    Free(ptr);
	}

	return block;
    }

    PBLOCK next = ptr + cursize;
    size_t nextsize = SIZE(next);

    /* Check the next block for consistency.*/
    if((nextsize&1) == 0 && (nextsize + cursize) >= realsize) {
	/*
	 * The next block is free and big enough.  Add the part that's needed
	 * to our block, and split the remainder off into a new block.
	 */
	if(m_pRover == next)
	    m_pRover = NEXT(next);

	/* Unlink the next block from the free list. */
	Unlink(next);
	cursize += nextsize;	/* combine sizes */

	size_t rem = cursize - realsize;	/* size of remainder */
	if(rem >= minAllocSize) {
	    /*
	     * The remainder is big enough to be a new block.
	     * Set boundary tags for the resized block and the new block.
	     */
	    next = ptr + realsize;
	    /*
	     * add the new block to the free list.
	     * next block cannot be free
	     */
	    SetTags(next, rem);
#ifdef _USE_BUDDY_BLOCKS
	    AddToFreeList(next, rem);
#else
	    AddToFreeList(next, m_pFreeList);
#endif
	    cursize = realsize;
        }
	/* Set the boundary tags to mark it as allocated. */
	SetTags(ptr, cursize | 1);
	return ((void *)ptr);
    }
    return NULL;
}

#ifdef _DEBUG_MEM
#define LOG_FILENAME ".\\MemLog.txt"

void VMem::MemoryUsageMessage(char *str, long x, long y, int c)
{
    char szBuffer[512];
    if(str) {
	if(!m_pLog)
	    m_pLog = fopen(LOG_FILENAME, "w");
	sprintf(szBuffer, str, x, y, c);
	fputs(szBuffer, m_pLog);
    }
    else {
	if(m_pLog) {
	    fflush(m_pLog);
	    fclose(m_pLog);
	    m_pLog = 0;
	}
    }
}

void VMem::WalkHeap(int complete)
{
    if(complete) {
	MemoryUsageMessage(NULL, 0, 0, 0);
	size_t total = 0;
	for(int i = 0; i < m_nHeaps; ++i) {
	    total += m_heaps[i].len;
	}
	MemoryUsageMessage("VMem heaps used %d. Total memory %08x\n", m_nHeaps, total, 0);

	/* Walk all the heaps - verify structures */
	for(int index = 0; index < m_nHeaps; ++index) {
	    PBLOCK ptr = m_heaps[index].base;
	    size_t size = m_heaps[index].len;
#ifndef _USE_BUDDY_BLOCKS
#ifdef USE_BIGBLOCK_ALLOC
	    if (!m_heaps[m_nHeaps].bBigBlock)
#endif
		ASSERT(HeapValidate(m_hHeap, HEAP_NO_SERIALIZE, ptr));
#endif

	    /* set over reserved header block */
	    size -= blockOverhead;
	    ptr += blockOverhead;
	    PBLOCK pLast = ptr + size;
	    ASSERT(PSIZE(ptr) == 1); /* dummy previous block is allocated */
	    ASSERT(SIZE(pLast) == 1); /* dummy next block is allocated */
	    while(ptr < pLast) {
		ASSERT(ptr > m_heaps[index].base);
		size_t cursize = SIZE(ptr) & ~1;
		ASSERT((PSIZE(ptr+cursize) & ~1) == cursize);
		MemoryUsageMessage("Memory Block %08x: Size %08x %c\n", (long)ptr, cursize, (SIZE(ptr)&1) ? 'x' : ' ');
		if(!(SIZE(ptr)&1)) {
		    /* this block is on the free list */
		    PBLOCK tmp = NEXT(ptr);
		    while(tmp != ptr) {
			ASSERT((SIZE(tmp)&1)==0);
			if(tmp == m_pFreeList)
			    break;
			ASSERT(NEXT(tmp));
			tmp = NEXT(tmp);
		    }
		    if(tmp == ptr) {
			MemoryUsageMessage("Memory Block %08x: Size %08x free but not in free list\n", (long)ptr, cursize, 0);
		    }
		}
		ptr += cursize;
	    }
	}
	MemoryUsageMessage(NULL, 0, 0, 0);
    }
}
#endif	/* _DEBUG_MEM */

#endif	/* _USE_MSVCRT_MEM_ALLOC */

#endif	/* ___VMEM_H_INC___ */
@


1.1
log
@Initial revision
@
text
@d9 1
d11 258
d287 1
a287 1
 * Since memory allocation may occur on a single threaded, explict locks are
d292 1
a292 4
#ifndef ___VMEM_H_INC___
#define ___VMEM_H_INC___

const long lAllocStart = 0x00010000; /* start at 64K */
d297 10
d318 1
a318 1
#define PSIZE(block)	(*(ULONG*)(((PBLOCK)(block))-(sizeofTag*2)))
d345 1
d353 1
a353 1

d366 1
a366 1
const int maxHeaps = 64;
d369 21
d394 3
a398 1

d404 8
a411 8
    virtual void* Malloc(size_t size);
    virtual void* Realloc(void* pMem, size_t size);
    virtual void Free(void* pMem);
    virtual void GetLock(void);
    virtual void FreeLock(void);
    virtual int IsLocked(void);
    virtual long Release(void);
    virtual long AddRef(void);
d415 3
d419 1
d427 7
a433 1
    int HeapAdd(void* ptr, size_t size);
a434 1
    void WalkHeap(void);
d436 37
d476 1
a482 1
};
a483 1
// #define _DEBUG_MEM
d485 3
a487 26
#define ASSERT(f) if(!(f)) DebugBreak();

inline void MEMODS(char *str)
{
    OutputDebugString(str);
    OutputDebugString("\n");
}

inline void MEMODSlx(char *str, long x)
{
    char szBuffer[512];	
    sprintf(szBuffer, "%s %lx\n", str, x);
    OutputDebugString(szBuffer);
}

#define WALKHEAP() WalkHeap()
#define WALKHEAPTRACE() m_pRover = NULL; WalkHeap()

#else

#define ASSERT(f)
#define MEMODS(x)
#define MEMODSlx(x, y)
#define WALKHEAP()
#define WALKHEAPTRACE()

d489 1
a489 1

d494 1
d499 1
d502 3
d511 1
d513 1
d515 1
d517 12
d531 1
d536 13
a548 2
    for(int index = 0; index < m_nHeaps; ++index)
	HeapFree(m_hHeap, HEAP_NO_SERIALIZE, m_heaps[index].base);
d554 20
a573 1
{   /*
d577 2
a578 2
    m_pFreeList = m_pRover = (PBLOCK)(&m_FreeDummy[minBlockSize]);
    PSIZE(m_pFreeList) = SIZE(m_pFreeList) = 0;
d580 1
d590 2
d593 1
a593 2
     * Adjust the real size of the block to be a multiple of sizeof(long), and add
     * the overhead for the boundary tags.  Disallow negative or zero sizes.
d595 1
a595 1
    size_t realsize = (size < blockOverhead) ? minAllocSize : (size_t)ROUND_UP(size) + minBlockSize;
d599 83
d686 2
a687 2
    PBLOCK ptr = m_pRover;	/* start searching at rover */
    int loops = 2;		/* allow two times through the loop  */
d689 1
a689 1
	size_t lsize = SIZE(ptr);
d694 1
a694 1
	    size_t rem = lsize - realsize;
d753 1
a753 5
    /*
     * adjust the real size of the block to be a multiple of sizeof(long), and add the
     * overhead for the boundary tags.  Disallow negative or zero sizes.
     */
    size_t realsize = (size < blockOverhead) ? minAllocSize : (size_t)ROUND_UP(size) + minBlockSize;
d789 3
d793 1
d803 1
a803 1
	memmove(ptr, block, cursize-minBlockSize);
d828 1
d830 1
d835 3
d839 1
d861 3
d867 1
d915 3
d922 1
a922 1
    
d932 1
a932 1
	m_lAllocSize <<= 1;
d934 6
a939 1
    if(m_nHeaps != 0) {
d941 1
a941 1
	ptr = HeapReAlloc(m_hHeap, HEAP_REALLOC_IN_PLACE_ONLY|HEAP_ZERO_MEMORY|HEAP_NO_SERIALIZE,
d945 5
a949 1
	    HeapAdd(((char*)ptr) + m_heaps[m_nHeaps-1].len, size);
d953 1
d962 23
a984 1
	size = (size_t)ROUND_UP64K(requestSize+(sizeofTag*2));
a985 1
    ptr = HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY|HEAP_NO_SERIALIZE, size);
d991 13
d1005 2
d1010 6
a1015 2
int VMem::HeapAdd(void *p, size_t size)
{   /* if the block can be succesfully added to the heap, returns 0; otherwise -1. */
d1025 17
a1041 13
    /*
     * Search for another heap area that's contiguous with the bottom of this new area.
     * (It should be extremely unusual to find one that's contiguous with the top).
     */
    for(index = 0; index < m_nHeaps; ++index) {
	if(ptr == m_heaps[index].base + (int)m_heaps[index].len) {
	    /*
	     * The new block is contiguous with a previously allocated heap area.  Add its
	     * length to that of the previous heap.  Merge it with the the dummy end-of-heap
	     * area marker of the previous heap.
	     */
	    m_heaps[index].len += size;
	    break;
d1043 1
d1045 4
d1051 1
a1051 1
	/* The new block is not contiguous.  Add it to the heap list. */
d1057 3
d1066 2
a1067 2
	size -= minBlockSize;
	ptr += minBlockSize;
d1092 1
a1092 2
     * Adjust the size of the block to be a multiple of sizeof(long), and add the
     * overhead for the boundary tags.  Disallow negative or zero sizes.
d1094 1
a1094 1
    size_t realsize = (size < blockOverhead) ? minAllocSize : (size_t)ROUND_UP(size) + minBlockSize;
d1156 3
d1160 1
d1171 1
a1171 1
#define LOG_FILENAME "P:\\Apps\\Perl\\Result.txt"
d1173 1
a1173 1
void MemoryUsageMessage(char *str, long x, long y, int c)
a1174 1
    static FILE* fp = NULL;
d1177 2
a1178 2
	if(!fp)
	    fp = fopen(LOG_FILENAME, "w");
d1180 1
a1180 1
	fputs(szBuffer, fp);
d1183 5
a1187 2
	fflush(fp);
	fclose(fp);
d1191 1
a1191 1
void VMem::WalkHeap(void)
d1193 18
a1210 3
    if(!m_pRover) {
	MemoryUsageMessage("VMem heaps used %d\n", m_nHeaps, 0, 0);
    }
d1212 24
a1235 31
    /* Walk all the heaps - verify structures */
    for(int index = 0; index < m_nHeaps; ++index) {
	PBLOCK ptr = m_heaps[index].base;
	size_t size = m_heaps[index].len;
	ASSERT(HeapValidate(m_hHeap, HEAP_NO_SERIALIZE, p));

	/* set over reserved header block */
	size -= minBlockSize;
	ptr += minBlockSize;
	PBLOCK pLast = ptr + size;
	ASSERT(PSIZE(ptr) == 1); /* dummy previous block is allocated */
	ASSERT(SIZE(pLast) == 1); /* dummy next block is allocated */
	while(ptr < pLast) {
	    ASSERT(ptr > m_heaps[index].base);
	    size_t cursize = SIZE(ptr) & ~1;
	    ASSERT((PSIZE(ptr+cursize) & ~1) == cursize);
	    if(!m_pRover) {
		MemoryUsageMessage("Memory Block %08x: Size %08x %c\n", (long)ptr, cursize, (SIZE(p)&1) ? 'x' : ' ');
	    }
	    if(!(SIZE(ptr)&1)) {
		/* this block is on the free list */
		PBLOCK tmp = NEXT(ptr);
		while(tmp != ptr) {
		    ASSERT((SIZE(tmp)&1)==0);
		    if(tmp == m_pFreeList)
			break;
		    ASSERT(NEXT(tmp));
		    tmp = NEXT(tmp);
		}
		if(tmp == ptr) {
		    MemoryUsageMessage("Memory Block %08x: Size %08x free but not in free list\n", (long)ptr, cursize, 0);
d1237 1
a1238 1
	    ptr += cursize;
a1239 2
    }
    if(!m_pRover) {
d1243 3
a1245 1
#endif
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@a8 1
 * Options:
a9 259
 * Defining _USE_MSVCRT_MEM_ALLOC will cause all memory allocations
 * to be forwarded to MSVCRT.DLL. Defining _USE_LINKED_LIST as well will
 * track all allocations in a doubly linked list, so that the host can
 * free all memory allocated when it goes away.
 * If _USE_MSVCRT_MEM_ALLOC is not defined then Knuth's boundary tag algorithm
 * is used; defining _USE_BUDDY_BLOCKS will use Knuth's algorithm R
 * (Buddy system reservation)
 *
 */

#ifndef ___VMEM_H_INC___
#define ___VMEM_H_INC___

#define _USE_MSVCRT_MEM_ALLOC
#define _USE_LINKED_LIST

// #define _USE_BUDDY_BLOCKS

// #define _DEBUG_MEM
#ifdef _DEBUG_MEM
#define ASSERT(f) if(!(f)) DebugBreak();

inline void MEMODS(char *str)
{
    OutputDebugString(str);
    OutputDebugString("\n");
}

inline void MEMODSlx(char *str, long x)
{
    char szBuffer[512];	
    sprintf(szBuffer, "%s %lx\n", str, x);
    OutputDebugString(szBuffer);
}

#define WALKHEAP() WalkHeap(0)
#define WALKHEAPTRACE() WalkHeap(1)

#else

#define ASSERT(f)
#define MEMODS(x)
#define MEMODSlx(x, y)
#define WALKHEAP()
#define WALKHEAPTRACE()

#endif

#ifdef _USE_MSVCRT_MEM_ALLOC

#ifndef _USE_LINKED_LIST
// #define _USE_LINKED_LIST
#endif

/* 
 * Pass all memory requests throught to msvcrt.dll 
 * optionaly track by using a doubly linked header
 */

typedef void (*LPFREE)(void *block);
typedef void* (*LPMALLOC)(size_t size);
typedef void* (*LPREALLOC)(void *block, size_t size);
#ifdef _USE_LINKED_LIST
class VMem;
typedef struct _MemoryBlockHeader* PMEMORY_BLOCK_HEADER;
typedef struct _MemoryBlockHeader {
    PMEMORY_BLOCK_HEADER    pNext;
    PMEMORY_BLOCK_HEADER    pPrev;
    VMem *owner;
} MEMORY_BLOCK_HEADER, *PMEMORY_BLOCK_HEADER;
#endif

class VMem
{
public:
    VMem();
    ~VMem();
    virtual void* Malloc(size_t size);
    virtual void* Realloc(void* pMem, size_t size);
    virtual void Free(void* pMem);
    virtual void GetLock(void);
    virtual void FreeLock(void);
    virtual int IsLocked(void);
    virtual long Release(void);
    virtual long AddRef(void);

    inline BOOL CreateOk(void)
    {
	return TRUE;
    };

protected:
#ifdef _USE_LINKED_LIST
    void LinkBlock(PMEMORY_BLOCK_HEADER ptr)
    {
	PMEMORY_BLOCK_HEADER next = m_Dummy.pNext;
	m_Dummy.pNext = ptr;
	ptr->pPrev = &m_Dummy;
	ptr->pNext = next;
        ptr->owner = this;
	next->pPrev = ptr;
    }
    void UnlinkBlock(PMEMORY_BLOCK_HEADER ptr)
    {
	PMEMORY_BLOCK_HEADER next = ptr->pNext;
	PMEMORY_BLOCK_HEADER prev = ptr->pPrev;
	prev->pNext = next;
	next->pPrev = prev;
    }

    MEMORY_BLOCK_HEADER	m_Dummy;
#endif

    long		m_lRefCount;	// number of current users
    CRITICAL_SECTION	m_cs;		// access lock
    HINSTANCE		m_hLib;
    LPFREE		m_pfree;
    LPMALLOC		m_pmalloc;
    LPREALLOC		m_prealloc;
};

VMem::VMem()
{
    m_lRefCount = 1;
    InitializeCriticalSection(&m_cs);
#ifdef _USE_LINKED_LIST
    m_Dummy.pNext = m_Dummy.pPrev =  &m_Dummy;
    m_Dummy.owner = this;
#endif
    m_hLib = LoadLibrary("msvcrt.dll");
    if (m_hLib) {
	m_pfree = (LPFREE)GetProcAddress(m_hLib, "free");
	m_pmalloc = (LPMALLOC)GetProcAddress(m_hLib, "malloc");
	m_prealloc = (LPREALLOC)GetProcAddress(m_hLib, "realloc");
    }
}

VMem::~VMem(void)
{
#ifdef _USE_LINKED_LIST
    while (m_Dummy.pNext != &m_Dummy) {
	Free(m_Dummy.pNext+1);
    }
#endif
    if (m_hLib)
	FreeLibrary(m_hLib);
    DeleteCriticalSection(&m_cs);
}

void* VMem::Malloc(size_t size)
{
#ifdef _USE_LINKED_LIST
    GetLock();
    PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)m_pmalloc(size+sizeof(MEMORY_BLOCK_HEADER));
    LinkBlock(ptr);
    FreeLock();
    return (ptr+1);
#else
    return m_pmalloc(size);
#endif
}

void* VMem::Realloc(void* pMem, size_t size)
{
#ifdef _USE_LINKED_LIST
    if (!pMem)
	return Malloc(size);

    if (!size) {
	Free(pMem);
	return NULL;
    }

    GetLock();
    PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)(((char*)pMem)-sizeof(MEMORY_BLOCK_HEADER));
    UnlinkBlock(ptr);
    ptr = (PMEMORY_BLOCK_HEADER)m_prealloc(ptr, size+sizeof(MEMORY_BLOCK_HEADER));
    LinkBlock(ptr);
    FreeLock();

    return (ptr+1);
#else
    return m_prealloc(pMem, size);
#endif
}

void VMem::Free(void* pMem)
{
#ifdef _USE_LINKED_LIST
    if (pMem) {
	PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)(((char*)pMem)-sizeof(MEMORY_BLOCK_HEADER));
        if (ptr->owner != this) {
	    if (ptr->owner) {
#if 1
		dTHX;
	    	int *nowhere = NULL;
	    	Perl_warn(aTHX_ "Free to wrong pool %p not %p",this,ptr->owner);
            	*nowhere = 0;
#else
                ptr->owner->Free(pMem);	
#endif
	    }
	    return;
        }
	GetLock();
	UnlinkBlock(ptr);
	ptr->owner = NULL;
	m_pfree(ptr);
	FreeLock();
    }
#else
    m_pfree(pMem);
#endif
}

void VMem::GetLock(void)
{
    EnterCriticalSection(&m_cs);
}

void VMem::FreeLock(void)
{
    LeaveCriticalSection(&m_cs);
}

int VMem::IsLocked(void)
{
#if 0
    /* XXX TryEnterCriticalSection() is not available in some versions
     * of Windows 95.  Since this code is not used anywhere yet, we 
     * skirt the issue for now. */
    BOOL bAccessed = TryEnterCriticalSection(&m_cs);
    if(bAccessed) {
	LeaveCriticalSection(&m_cs);
    }
    return !bAccessed;
#else
    ASSERT(0);	/* alarm bells for when somebody calls this */
    return 0;
#endif
}

long VMem::Release(void)
{
    long lCount = InterlockedDecrement(&m_lRefCount);
    if(!lCount)
	delete this;
    return lCount;
}

long VMem::AddRef(void)
{
    long lCount = InterlockedIncrement(&m_lRefCount);
    return lCount;
}

#else	/* _USE_MSVCRT_MEM_ALLOC */

/*
d28 1
a28 1
 * Since memory allocation may occur on a single threaded, explict locks are not
d33 4
a36 1
const long lAllocStart = 0x00020000; /* start at 128K */
a40 10
#ifdef _USE_BUDDY_BLOCKS
const long lSmallBlockSize = 1024;
const size_t nListEntries = ((lSmallBlockSize-minAllocSize)/sizeof(long));

inline size_t CalcEntry(size_t size)
{
    ASSERT((size&(sizeof(long)-1)) == 0);
    return ((size - minAllocSize) / sizeof(long));
}
#endif
d52 1
a52 1
#define PSIZE(block)	(*(ULONG*)(((PBLOCK)(block))-(blockOverhead)))
a78 1
#ifndef _USE_BUDDY_BLOCKS
d86 1
a86 1
#endif
d99 1
a99 1
const int maxHeaps = 32; /* 64 was overkill */
a101 21
#ifdef _USE_BUDDY_BLOCKS
typedef struct _FreeListEntry
{
    BYTE    Dummy[minAllocSize];	// dummy free block
} FREE_LIST_ENTRY, *PFREE_LIST_ENTRY;
#endif

#ifndef _USE_BUDDY_BLOCKS
#define USE_BIGBLOCK_ALLOC
#endif
/*
 * performance tuning
 * Use VirtualAlloc() for blocks bigger than nMaxHeapAllocSize since
 * Windows 95/98/Me have heap managers that are designed for memory 
 * blocks smaller than four megabytes.
 */

#ifdef USE_BIGBLOCK_ALLOC
const int nMaxHeapAllocSize = (1024*512);  /* don't allocate anything larger than this from the heap */
#endif

a105 3
#ifdef USE_BIGBLOCK_ALLOC
    BOOL	bBigBlock;  /* was allocate using VirtualAlloc */
#endif
d108 1
a124 3
#ifdef _USE_BUDDY_BLOCKS
	return TRUE;
#else
a125 1
#endif
d133 1
a133 7

    int HeapAdd(void* ptr, size_t size
#ifdef USE_BIGBLOCK_ALLOC
	, BOOL bBigBlock
#endif
    );

d135 1
a136 37
#ifdef _USE_BUDDY_BLOCKS
    inline PBLOCK GetFreeListLink(int index)
    {
	if (index >= nListEntries)
	    index = nListEntries-1;
	return &m_FreeList[index].Dummy[sizeofTag];
    }
    inline PBLOCK GetOverSizeFreeList(void)
    {
	return &m_FreeList[nListEntries-1].Dummy[sizeofTag];
    }
    inline PBLOCK GetEOLFreeList(void)
    {
	return &m_FreeList[nListEntries].Dummy[sizeofTag];
    }

    void AddToFreeList(PBLOCK block, size_t size)
    {
	PBLOCK pFreeList = GetFreeListLink(CalcEntry(size));
	PBLOCK next = NEXT(pFreeList);
	NEXT(pFreeList) = block;
	SetLink(block, pFreeList, next);
	PREV(next) = block;
    }
#endif
    inline size_t CalcAllocSize(size_t size)
    {
	/*
	 * Adjust the real size of the block to be a multiple of sizeof(long), and add
	 * the overhead for the boundary tags.  Disallow negative or zero sizes.
	 */
	return (size < minBlockSize) ? minAllocSize : (size_t)ROUND_UP(size) + blockOverhead;
    }

#ifdef _USE_BUDDY_BLOCKS
    FREE_LIST_ENTRY	m_FreeList[nListEntries+1];	// free list with dummy end of list entry as well
#else
a139 1
#endif
d146 1
d148 1
d150 26
a175 3
    void WalkHeap(int complete);
    void MemoryUsageMessage(char *str, long x, long y, int c);
    FILE*		m_pLog;
d177 1
a177 1
};
a181 1
#ifndef _USE_BUDDY_BLOCKS
a185 1
#endif
a187 3
#ifdef _DEBUG_MEM
    m_pLog = 0;
#endif
a193 1
#ifndef _USE_BUDDY_BLOCKS
a194 1
#endif
a195 1

a196 12
#ifdef _USE_BUDDY_BLOCKS
    for(int index = 0; index < m_nHeaps; ++index) {
	VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
    }
#else /* !_USE_BUDDY_BLOCKS */
#ifdef USE_BIGBLOCK_ALLOC
    for(int index = 0; index < m_nHeaps; ++index) {
	if (m_heaps[index].bBigBlock) {
	    VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
	}
    }
#endif
a198 1
#endif /* _USE_BUDDY_BLOCKS */
d203 2
a204 13
    for(int index = 0; index < m_nHeaps; ++index) {
#ifdef _USE_BUDDY_BLOCKS
	VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
#else
#ifdef USE_BIGBLOCK_ALLOC
	if (m_heaps[index].bBigBlock) {
	    VirtualFree(m_heaps[index].base, 0, MEM_RELEASE);
	}
	else
#endif
	    HeapFree(m_hHeap, HEAP_NO_SERIALIZE, m_heaps[index].base);
#endif /* _USE_BUDDY_BLOCKS */
    }
d210 1
a210 20
{
#ifdef _USE_BUDDY_BLOCKS
    PBLOCK pFreeList;
    /*
     * Initialize the free list by placing a dummy zero-length block on it.
     * Set the end of list marker.
     * Set the number of non-contiguous heaps to zero.
     * Set the next allocation size.
     */
    for (int index = 0; index < nListEntries; ++index) {
	pFreeList = GetFreeListLink(index);
	SIZE(pFreeList) = PSIZE(pFreeList+minAllocSize) = 0;
	PREV(pFreeList) = NEXT(pFreeList) = pFreeList;
    }
    pFreeList = GetEOLFreeList();
    SIZE(pFreeList) = PSIZE(pFreeList+minAllocSize) = 0;
    PREV(pFreeList) = NEXT(pFreeList) = NULL;
    m_pRover = GetOverSizeFreeList();
#else
    /*
d214 2
a215 2
    m_pFreeList = m_pRover = (PBLOCK)(&m_FreeDummy[sizeofTag]);
    PSIZE(m_pFreeList+minAllocSize) = SIZE(m_pFreeList) = 0;
a216 1
#endif
a225 2
    PBLOCK ptr;
    size_t lsize, rem;
d227 2
a228 1
     * Disallow negative or zero sizes.
d230 1
a230 1
    size_t realsize = CalcAllocSize(size);
a233 83
#ifdef _USE_BUDDY_BLOCKS
    /*
     * Check the free list of small blocks if this is free use it
     * Otherwise check the rover if it has no blocks then
     * Scan the free list entries use the first free block
     * split the block if needed, stop at end of list marker
     */
    {
	int index = CalcEntry(realsize);
	if (index < nListEntries-1) {
	    ptr = GetFreeListLink(index);
	    lsize = SIZE(ptr);
	    if (lsize >= realsize) {
		rem = lsize - realsize;
		if(rem < minAllocSize) {
		    /* Unlink the block from the free list. */
		    Unlink(ptr);
		}
		else {
		    /*
		     * split the block
		     * The remainder is big enough to split off into a new block.
		     * Use the end of the block, resize the beginning of the block
		     * no need to change the free list.
		     */
		    SetTags(ptr, rem);
		    ptr += SIZE(ptr);
		    lsize = realsize;
		}
		SetTags(ptr, lsize | 1);
		return ptr;
	    }
	    ptr = m_pRover;
	    lsize = SIZE(ptr);
	    if (lsize >= realsize) {
		rem = lsize - realsize;
		if(rem < minAllocSize) {
		    /* Unlink the block from the free list. */
		    Unlink(ptr);
		}
		else {
		    /*
		     * split the block
		     * The remainder is big enough to split off into a new block.
		     * Use the end of the block, resize the beginning of the block
		     * no need to change the free list.
		     */
		    SetTags(ptr, rem);
		    ptr += SIZE(ptr);
		    lsize = realsize;
		}
		SetTags(ptr, lsize | 1);
		return ptr;
	    }
	    ptr = GetFreeListLink(index+1);
	    while (NEXT(ptr)) {
		lsize = SIZE(ptr);
		if (lsize >= realsize) {
		    size_t rem = lsize - realsize;
		    if(rem < minAllocSize) {
			/* Unlink the block from the free list. */
			Unlink(ptr);
		    }
		    else {
			/*
			 * split the block
			 * The remainder is big enough to split off into a new block.
			 * Use the end of the block, resize the beginning of the block
			 * no need to change the free list.
			 */
			SetTags(ptr, rem);
			ptr += SIZE(ptr);
			lsize = realsize;
		    }
		    SetTags(ptr, lsize | 1);
		    return ptr;
		}
		ptr += sizeof(FREE_LIST_ENTRY);
	    }
	}
    }
#endif

d238 2
a239 2
    ptr = m_pRover;	/* start searching at rover */
    int loops = 2;	/* allow two times through the loop  */
d241 1
a241 1
	lsize = SIZE(ptr);
d246 1
a246 1
	    rem = lsize - realsize;
d305 5
a309 1
    size_t realsize = CalcAllocSize(size);
a344 3
#ifdef _USE_BUDDY_BLOCKS
	    AddToFreeList(prev, rem);
#else
a345 1
#endif
d355 1
a355 1
	memmove(ptr, block, cursize-blockOverhead);
a379 1
#ifndef _USE_BUDDY_BLOCKS
a380 1
#endif
a384 3
#ifdef _USE_BUDDY_BLOCKS
	Unlink(ptr);
#else
a385 1
#endif
a406 3
#ifdef _USE_BUDDY_BLOCKS
	AddToFreeList(ptr, size);
#else
a409 1
#endif
a456 3
#ifdef USE_BIGBLOCK_ALLOC
    BOOL bBigBlock;
#endif
d461 1
a461 1

d471 1
a471 1
	m_lAllocSize <<= 2;
d473 1
a473 6
#ifndef _USE_BUDDY_BLOCKS
    if(m_nHeaps != 0
#ifdef USE_BIGBLOCK_ALLOC
	&& !m_heaps[m_nHeaps-1].bBigBlock
#endif
		    ) {
d475 1
a475 1
	ptr = HeapReAlloc(m_hHeap, HEAP_REALLOC_IN_PLACE_ONLY|HEAP_NO_SERIALIZE,
d479 1
a479 5
	    HeapAdd(((char*)ptr) + m_heaps[m_nHeaps-1].len, size
#ifdef USE_BIGBLOCK_ALLOC
		, FALSE
#endif
		);
a482 1
#endif /* _USE_BUDDY_BLOCKS */
d491 1
a491 23
	size = (size_t)ROUND_UP64K(requestSize+(blockOverhead));

Restart:
#ifdef _USE_BUDDY_BLOCKS
    ptr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
#else
#ifdef USE_BIGBLOCK_ALLOC
    bBigBlock = FALSE;
    if (size >= nMaxHeapAllocSize) {
	bBigBlock = TRUE;
	ptr = VirtualAlloc(NULL, size, MEM_COMMIT, PAGE_READWRITE);
    }
    else
#endif
    ptr = HeapAlloc(m_hHeap, HEAP_NO_SERIALIZE, size);
#endif /* _USE_BUDDY_BLOCKS */

    if (!ptr) {
	/* try to allocate a smaller chunk */
	size >>= 1;
	if(size > requestSize)
	    goto Restart;
    }
d493 1
a498 13
#ifdef _USE_BUDDY_BLOCKS
    if (HeapAdd(ptr, size)) {
	VirtualFree(ptr, 0, MEM_RELEASE);
	return 0;
    }
#else
#ifdef USE_BIGBLOCK_ALLOC
    if (HeapAdd(ptr, size, bBigBlock)) {
	if (bBigBlock) {
	    VirtualFree(ptr, 0, MEM_RELEASE);
	}
    }
#else
a499 2
#endif
#endif /* _USE_BUDDY_BLOCKS */
d503 1
a503 5
int VMem::HeapAdd(void* p, size_t size
#ifdef USE_BIGBLOCK_ALLOC
    , BOOL bBigBlock
#endif
    )
d514 13
a526 17
#ifdef USE_BIGBLOCK_ALLOC
    if (!bBigBlock) {
#endif
	/*
	 * Search for another heap area that's contiguous with the bottom of this new area.
	 * (It should be extremely unusual to find one that's contiguous with the top).
	 */
	for(index = 0; index < m_nHeaps; ++index) {
	    if(ptr == m_heaps[index].base + (int)m_heaps[index].len) {
		/*
		 * The new block is contiguous with a previously allocated heap area.  Add its
		 * length to that of the previous heap.  Merge it with the the dummy end-of-heap
		 * area marker of the previous heap.
		 */
		m_heaps[index].len += size;
		break;
	    }
a527 4
#ifdef USE_BIGBLOCK_ALLOC
    }
    else {
	index = m_nHeaps;
a528 1
#endif
d531 1
a531 1
	/* The new block is not contiguous, or is BigBlock.  Add it to the heap list. */
a536 3
#ifdef USE_BIGBLOCK_ALLOC
	m_heaps[m_nHeaps].bBigBlock = bBigBlock;
#endif
d543 2
a544 2
	size -= blockOverhead;
	ptr += blockOverhead;
d569 2
a570 1
     * Disallow negative or zero sizes.
d572 1
a572 1
    size_t realsize = CalcAllocSize(size);
a633 3
#ifdef _USE_BUDDY_BLOCKS
	    AddToFreeList(next, rem);
#else
a634 1
#endif
d645 1
a645 1
#define LOG_FILENAME ".\\MemLog.txt"
d647 1
a647 1
void VMem::MemoryUsageMessage(char *str, long x, long y, int c)
d649 1
d652 2
a653 2
	if(!m_pLog)
	    m_pLog = fopen(LOG_FILENAME, "w");
d655 1
a655 1
	fputs(szBuffer, m_pLog);
d658 2
a659 5
	if(m_pLog) {
	    fflush(m_pLog);
	    fclose(m_pLog);
	    m_pLog = 0;
	}
d663 1
a663 1
void VMem::WalkHeap(int complete)
d665 3
a667 7
    if(complete) {
	MemoryUsageMessage(NULL, 0, 0, 0);
	size_t total = 0;
	for(int i = 0; i < m_nHeaps; ++i) {
	    total += m_heaps[i].len;
	}
	MemoryUsageMessage("VMem heaps used %d. Total memory %08x\n", m_nHeaps, total, 0);
d669 31
a699 35
	/* Walk all the heaps - verify structures */
	for(int index = 0; index < m_nHeaps; ++index) {
	    PBLOCK ptr = m_heaps[index].base;
	    size_t size = m_heaps[index].len;
#ifndef _USE_BUDDY_BLOCKS
#ifdef USE_BIGBLOCK_ALLOC
	    if (!m_heaps[m_nHeaps].bBigBlock)
#endif
		ASSERT(HeapValidate(m_hHeap, HEAP_NO_SERIALIZE, ptr));
#endif

	    /* set over reserved header block */
	    size -= blockOverhead;
	    ptr += blockOverhead;
	    PBLOCK pLast = ptr + size;
	    ASSERT(PSIZE(ptr) == 1); /* dummy previous block is allocated */
	    ASSERT(SIZE(pLast) == 1); /* dummy next block is allocated */
	    while(ptr < pLast) {
		ASSERT(ptr > m_heaps[index].base);
		size_t cursize = SIZE(ptr) & ~1;
		ASSERT((PSIZE(ptr+cursize) & ~1) == cursize);
		MemoryUsageMessage("Memory Block %08x: Size %08x %c\n", (long)ptr, cursize, (SIZE(ptr)&1) ? 'x' : ' ');
		if(!(SIZE(ptr)&1)) {
		    /* this block is on the free list */
		    PBLOCK tmp = NEXT(ptr);
		    while(tmp != ptr) {
			ASSERT((SIZE(tmp)&1)==0);
			if(tmp == m_pFreeList)
			    break;
			ASSERT(NEXT(tmp));
			tmp = NEXT(tmp);
		    }
		    if(tmp == ptr) {
			MemoryUsageMessage("Memory Block %08x: Size %08x free but not in free list\n", (long)ptr, cursize, 0);
		    }
a700 1
		ptr += cursize;
d702 1
d704 2
d709 1
a709 3
#endif	/* _DEBUG_MEM */

#endif	/* _USE_MSVCRT_MEM_ALLOC */
@


1.1.1.3
log
@perl 5.8.2 from CPAN
@
text
@d1037 1
a1037 1
		 * length to that of the previous heap.  Merge it with the dummy end-of-heap
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@a23 1
#ifndef UNDER_CE
a24 1
#endif
a164 4
    if (!ptr) {
	FreeLock();
	return NULL;
    }
a187 4
    if (!ptr) {
	FreeLock();
	return NULL;
    }
d208 1
a208 2
            	*nowhere = 0; /* this segfault is deliberate, 
            	                 so you can see the stack trace */
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d12 2
a13 2
 * to be forwarded to the compiler's MSVCR*.DLL. Defining _USE_LINKED_LIST as
 * well will track all allocations in a doubly linked list, so that the host can
d68 2
a69 2
 * Pass all memory requests through to the compiler's msvcr*.dll.
 * Optionaly track by using a doubly linked header.
d72 3
d90 8
a97 8
    void* Malloc(size_t size);
    void* Realloc(void* pMem, size_t size);
    void Free(void* pMem);
    void GetLock(void);
    void FreeLock(void);
    int IsLocked(void);
    long Release(void);
    long AddRef(void);
a123 1
    CRITICAL_SECTION	m_cs;		// access lock
d127 5
d137 1
a138 1
    InitializeCriticalSection(&m_cs);
d142 6
d156 3
a159 1
#endif
d166 1
a166 1
    PMEMORY_BLOCK_HEADER ptr = (PMEMORY_BLOCK_HEADER)malloc(size+sizeof(MEMORY_BLOCK_HEADER));
d175 1
a175 1
    return malloc(size);
d193 1
a193 1
    ptr = (PMEMORY_BLOCK_HEADER)realloc(ptr, size+sizeof(MEMORY_BLOCK_HEADER));
d203 1
a203 1
    return realloc(pMem, size);
d215 1
d217 1
a217 1
	    	Perl_warn_nocontext("Free to wrong pool %p not %p",this,ptr->owner);
d229 1
a229 1
	free(ptr);
d232 2
a233 2
#else /*_USE_LINKED_LIST*/
    free(pMem);
a238 1
#ifdef _USE_LINKED_LIST
a239 1
#endif
a243 1
#ifdef _USE_LINKED_LIST
a244 1
#endif
d416 8
a423 8
    void* Malloc(size_t size);
    void* Realloc(void* pMem, size_t size);
    void Free(void* pMem);
    void GetLock(void);
    void FreeLock(void);
    int IsLocked(void);
    long Release(void);
    long AddRef(void);
@


