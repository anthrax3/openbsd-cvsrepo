head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.2
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2017.02.05.00.32.22;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.34;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.41.01;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.11;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.22;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.15;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.43;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.10.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.09.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.06.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.42.16;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.11.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.26.19;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.14;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.38;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.48.47;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.18.29;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.50.00;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.19.06;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.11.08;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.42;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.09.45;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.13;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.21;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* win32sck.c
 *
 * (c) 1995 Microsoft Corporation. All rights reserved. 
 * 		Developed by hip communications inc.
 * Portions (c) 1993 Intergraph Corporation. All rights reserved.
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */

#define WIN32IO_IS_STDIO
#define WIN32SCK_IS_STDSCK
#define WIN32_LEAN_AND_MEAN
#define PERLIO_NOT_STDIO 0
#ifdef __GNUC__
#define Win32_Winsock
#endif
#include <windows.h>
#include <ws2spi.h>

#include "EXTERN.h"
#include "perl.h"

#include "Win32iop.h"
#include <sys/socket.h>
#include <fcntl.h>
#include <sys/stat.h>
#include <assert.h>
#include <io.h>

/* thanks to Beverly Brown	(beverly@@datacube.com) */
#define OPEN_SOCKET(x)	win32_open_osfhandle(x,O_RDWR|O_BINARY)
#define TO_SOCKET(x)	_get_osfhandle(x)

#define StartSockets() \
    STMT_START {					\
	if (!wsock_started)				\
	    start_sockets();				\
    } STMT_END

#define SOCKET_TEST(x, y) \
    STMT_START {					\
	StartSockets();					\
	if((x) == (y))					\
	    {						\
	    int wsaerr = WSAGetLastError();		\
	    errno = convert_wsa_error_to_errno(wsaerr);	\
	    SetLastError(wsaerr);			\
	    }						\
    } STMT_END

#define SOCKET_TEST_ERROR(x) SOCKET_TEST(x, SOCKET_ERROR)

static struct servent* win32_savecopyservent(struct servent*d,
                                             struct servent*s,
                                             const char *proto);

static int wsock_started = 0;

#ifdef WIN32_DYN_IOINFO_SIZE
EXTERN_C Size_t w32_ioinfo_size;
#endif

EXTERN_C void
EndSockets(void)
{
    if (wsock_started)
	WSACleanup();
}

/* Translate WSAExxx values to corresponding Exxx values where possible. Not all
 * WSAExxx constants have corresponding Exxx constants in <errno.h> (even in
 * VC++ 2010 and above, which have expanded <errno.h> with more values), but
 * most missing constants are provided by win32/include/sys/errno2.h. The few
 * that are not are returned unchanged.
 *
 * The list of possible WSAExxx values used here comes from the MSDN page
 * titled "Windows Sockets Error Codes".
 *
 * (Note: Only the WSAExxx values are handled here; other WSAxxx values are
 * returned unchanged. The return value normally ends up in errno/$! and at
 * the Perl code level may be tested against the Exxx constants exported by
 * the Errno and POSIX modules, which have never handled the other WSAxxx
 * values themselves, apparently without any ill effect so far.)
 */
int
convert_wsa_error_to_errno(int wsaerr)
{
    switch (wsaerr) {
    case WSAEINTR:
	return EINTR;
    case WSAEBADF:
	return EBADF;
    case WSAEACCES:
	return EACCES;
    case WSAEFAULT:
	return EFAULT;
    case WSAEINVAL:
	return EINVAL;
    case WSAEMFILE:
	return EMFILE;
    case WSAEWOULDBLOCK:
	return EWOULDBLOCK;
    case WSAEINPROGRESS:
	return EINPROGRESS;
    case WSAEALREADY:
	return EALREADY;
    case WSAENOTSOCK:
	return ENOTSOCK;
    case WSAEDESTADDRREQ:
	return EDESTADDRREQ;
    case WSAEMSGSIZE:
	return EMSGSIZE;
    case WSAEPROTOTYPE:
	return EPROTOTYPE;
    case WSAENOPROTOOPT:
	return ENOPROTOOPT;
    case WSAEPROTONOSUPPORT:
	return EPROTONOSUPPORT;
    case WSAESOCKTNOSUPPORT:
	return ESOCKTNOSUPPORT;
    case WSAEOPNOTSUPP:
	return EOPNOTSUPP;
    case WSAEPFNOSUPPORT:
	return EPFNOSUPPORT;
    case WSAEAFNOSUPPORT:
	return EAFNOSUPPORT;
    case WSAEADDRINUSE:
	return EADDRINUSE;
    case WSAEADDRNOTAVAIL:
	return EADDRNOTAVAIL;
    case WSAENETDOWN:
	return ENETDOWN;
    case WSAENETUNREACH:
	return ENETUNREACH;
    case WSAENETRESET:
	return ENETRESET;
    case WSAECONNABORTED:
	return ECONNABORTED;
    case WSAECONNRESET:
	return ECONNRESET;
    case WSAENOBUFS:
	return ENOBUFS;
    case WSAEISCONN:
	return EISCONN;
    case WSAENOTCONN:
	return ENOTCONN;
    case WSAESHUTDOWN:
	return ESHUTDOWN;
    case WSAETOOMANYREFS:
	return ETOOMANYREFS;
    case WSAETIMEDOUT:
	return ETIMEDOUT;
    case WSAECONNREFUSED:
	return ECONNREFUSED;
    case WSAELOOP:
	return ELOOP;
    case WSAENAMETOOLONG:
	return ENAMETOOLONG;
    case WSAEHOSTDOWN:
	return WSAEHOSTDOWN;		/* EHOSTDOWN is not defined */
    case WSAEHOSTUNREACH:
	return EHOSTUNREACH;
    case WSAENOTEMPTY:
	return ENOTEMPTY;
    case WSAEPROCLIM:
	return EPROCLIM;
    case WSAEUSERS:
	return EUSERS;
    case WSAEDQUOT:
	return EDQUOT;
    case WSAESTALE:
	return ESTALE;
    case WSAEREMOTE:
	return EREMOTE;
    case WSAEDISCON:
	return WSAEDISCON;		/* EDISCON is not defined */
    case WSAENOMORE:
	return WSAENOMORE;		/* ENOMORE is not defined */
#ifdef WSAECANCELLED
    case WSAECANCELLED:			/* New in WinSock2 */
	return ECANCELED;
#endif
    case WSAEINVALIDPROCTABLE:
	return WSAEINVALIDPROCTABLE;	/* EINVALIDPROCTABLE is not defined */
    case WSAEINVALIDPROVIDER:
	return WSAEINVALIDPROVIDER;	/* EINVALIDPROVIDER is not defined */
    case WSAEPROVIDERFAILEDINIT:
	return WSAEPROVIDERFAILEDINIT;	/* EPROVIDERFAILEDINIT is not defined */
    case WSAEREFUSED:
	return WSAEREFUSED;		/* EREFUSED is not defined */
    }

    return wsaerr;
}

#ifdef ERRNO_HAS_POSIX_SUPPLEMENT
/* Translate Exxx values in the POSIX supplement range defined in VC++ 2010 and
 * above (EADDRINUSE <= err <= EWOULDBLOCK) to corresponding WSAExxx values. Not
 * all such Exxx constants have corresponding WSAExxx constants in <winsock*.h>;
 * we just use ERROR_INVALID_FUNCTION for those that are missing but do not
 * really expect to encounter them anyway in the context in which this function
 * is called.
 * Some versions of MinGW/gcc-4.8 and above also define most, but not all, of
 * these extra Exxx values. The missing ones are all cases for which there is no
 * corresponding WSAExxx constant anyway, so we simply omit the cases for them
 * here.
 * Other Exxx values (err < sys_nerr) are returned unchanged.
 */
int
convert_errno_to_wsa_error(int err)
{
    switch (err) {
    case EADDRINUSE:
	return WSAEADDRINUSE;
    case EADDRNOTAVAIL:
	return WSAEADDRNOTAVAIL;
    case EAFNOSUPPORT:
	return WSAEAFNOSUPPORT;
    case EALREADY:
	return WSAEALREADY;
#ifdef EBADMSG
    case EBADMSG:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ECANCELED:
#ifdef WSAECANCELLED
	return WSAECANCELLED;		/* New in WinSock2 */
#else
	return ERROR_INVALID_FUNCTION;
#endif
    case ECONNABORTED:
	return WSAECONNABORTED;
    case ECONNREFUSED:
	return WSAECONNREFUSED;
    case ECONNRESET:
	return WSAECONNRESET;
    case EDESTADDRREQ:
	return WSAEDESTADDRREQ;
    case EHOSTUNREACH:
	return WSAEHOSTUNREACH;
#ifdef EIDRM
    case EIDRM:				/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case EINPROGRESS:
	return WSAEINPROGRESS;
    case EISCONN:
	return WSAEISCONN;
    case ELOOP:
	return WSAELOOP;
    case EMSGSIZE:
	return WSAEMSGSIZE;
    case ENETDOWN:
	return WSAENETDOWN;
    case ENETRESET:
	return WSAENETRESET;
    case ENETUNREACH:
	return WSAENETUNREACH;
    case ENOBUFS:
	return WSAENOBUFS;
#ifdef ENODATA
    case ENODATA:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
#ifdef ENOLINK
    case ENOLINK:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
#ifdef ENOMSG
    case ENOMSG:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ENOPROTOOPT:
	return WSAENOPROTOOPT;
#ifdef ENOSR
    case ENOSR:				/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
#ifdef ENOSTR
    case ENOSTR:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ENOTCONN:
	return WSAENOTCONN;
#ifdef ENOTRECOVERABLE
    case ENOTRECOVERABLE:		/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ENOTSOCK:
	return WSAENOTSOCK;
    case ENOTSUP:
	return ERROR_INVALID_FUNCTION;
    case EOPNOTSUPP:
	return WSAEOPNOTSUPP;
#ifdef EOTHER
    case EOTHER:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case EOVERFLOW:
	return ERROR_INVALID_FUNCTION;
    case EOWNERDEAD:
	return ERROR_INVALID_FUNCTION;
    case EPROTO:
	return ERROR_INVALID_FUNCTION;
    case EPROTONOSUPPORT:
	return WSAEPROTONOSUPPORT;
    case EPROTOTYPE:
	return WSAEPROTOTYPE;
#ifdef ETIME
    case ETIME:				/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ETIMEDOUT:
	return WSAETIMEDOUT;
#ifdef ETXTBSY
    case ETXTBSY:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case EWOULDBLOCK:
	return WSAEWOULDBLOCK;
    }

    return err;
}
#endif /* ERRNO_HAS_POSIX_SUPPLEMENT */

void
start_sockets(void) 
{
    unsigned short version;
    WSADATA retdata;
    int ret;

    /*
     * initalize the winsock interface and insure that it is
     * cleaned up at exit.
     */
    version = 0x2;
    if(ret = WSAStartup(version, &retdata))
	Perl_croak_nocontext("Unable to locate winsock library!\n");
    if(retdata.wVersion != version)
	Perl_croak_nocontext("Could not find version 2.0 of winsock dll\n");

    /* atexit((void (*)(void)) EndSockets); */
    wsock_started = 1;
}

/* in no sockets Win32 builds, these use the inline functions defined in
 * perl.h
 */
u_long
win32_htonl(u_long hostlong)
{
#ifndef WIN32_NO_SOCKETS
    StartSockets();
#endif
    return htonl(hostlong);
}

u_short
win32_htons(u_short hostshort)
{
#ifndef WIN32_NO_SOCKETS
    StartSockets();
#endif
    return htons(hostshort);
}

u_long
win32_ntohl(u_long netlong)
{
#ifndef WIN32_NO_SOCKETS
    StartSockets();
#endif
    return ntohl(netlong);
}

u_short
win32_ntohs(u_short netshort)
{
#ifndef WIN32_NO_SOCKETS
    StartSockets();
#endif
    return ntohs(netshort);
}



SOCKET
win32_accept(SOCKET s, struct sockaddr *addr, int *addrlen)
{
    SOCKET r;

    SOCKET_TEST((r = accept(TO_SOCKET(s), addr, addrlen)), INVALID_SOCKET);
    return OPEN_SOCKET(r);
}

int
win32_bind(SOCKET s, const struct sockaddr *addr, int addrlen)
{
    int r;

    SOCKET_TEST_ERROR(r = bind(TO_SOCKET(s), addr, addrlen));
    return r;
}

int
win32_connect(SOCKET s, const struct sockaddr *addr, int addrlen)
{
    int r;

    SOCKET_TEST_ERROR(r = connect(TO_SOCKET(s), addr, addrlen));
    return r;
}


int
win32_getpeername(SOCKET s, struct sockaddr *addr, int *addrlen)
{
    int r;

    SOCKET_TEST_ERROR(r = getpeername(TO_SOCKET(s), addr, addrlen));
    return r;
}

int
win32_getsockname(SOCKET s, struct sockaddr *addr, int *addrlen)
{
    int r;

    SOCKET_TEST_ERROR(r = getsockname(TO_SOCKET(s), addr, addrlen));
    return r;
}

int
win32_getsockopt(SOCKET s, int level, int optname, char *optval, int *optlen)
{
    int r;

    SOCKET_TEST_ERROR(r = getsockopt(TO_SOCKET(s), level, optname, optval, optlen));
    return r;
}

int
win32_ioctlsocket(SOCKET s, long cmd, u_long *argp)
{
    int r;

    SOCKET_TEST_ERROR(r = ioctlsocket(TO_SOCKET(s), cmd, argp));
    return r;
}

int
win32_listen(SOCKET s, int backlog)
{
    int r;

    SOCKET_TEST_ERROR(r = listen(TO_SOCKET(s), backlog));
    return r;
}

int
win32_recv(SOCKET s, char *buf, int len, int flags)
{
    int r;

    SOCKET_TEST_ERROR(r = recv(TO_SOCKET(s), buf, len, flags));
    return r;
}

int
win32_recvfrom(SOCKET s, char *buf, int len, int flags, struct sockaddr *from, int *fromlen)
{
    int r;
    int frombufsize = *fromlen;

    SOCKET_TEST_ERROR(r = recvfrom(TO_SOCKET(s), buf, len, flags, from, fromlen));
    /* Winsock's recvfrom() only returns a valid 'from' when the socket
     * is connectionless.  Perl expects a valid 'from' for all types
     * of sockets, so go the extra mile.
     */
    if (r != SOCKET_ERROR && frombufsize == *fromlen)
	(void)win32_getpeername(s, from, fromlen);
    return r;
}

/* select contributed by Vincent R. Slyngstad (vrs@@ibeam.intel.com) */
int
win32_select(int nfds, Perl_fd_set* rd, Perl_fd_set* wr, Perl_fd_set* ex, const struct timeval* timeout)
{
    int r;
    int i, fd, save_errno = errno;
    FD_SET nrd, nwr, nex;
    bool just_sleep = TRUE;

    StartSockets();

    FD_ZERO(&nrd);
    FD_ZERO(&nwr);
    FD_ZERO(&nex);
    for (i = 0; i < nfds; i++) {
	if (rd && PERL_FD_ISSET(i,rd)) {
	    fd = TO_SOCKET(i);
	    FD_SET((unsigned)fd, &nrd);
            just_sleep = FALSE;
	}
	if (wr && PERL_FD_ISSET(i,wr)) {
	    fd = TO_SOCKET(i);
	    FD_SET((unsigned)fd, &nwr);
            just_sleep = FALSE;
	}
	if (ex && PERL_FD_ISSET(i,ex)) {
	    fd = TO_SOCKET(i);
	    FD_SET((unsigned)fd, &nex);
            just_sleep = FALSE;
	}
    }

    /* winsock seems incapable of dealing with all three fd_sets being empty,
     * so do the (millisecond) sleep as a special case
     */
    if (just_sleep) {
	if (timeout)
	    Sleep(timeout->tv_sec  * 1000 +
		  timeout->tv_usec / 1000);	/* do the best we can */
	else
	    Sleep(UINT_MAX);
	return 0;
    }

    errno = save_errno;
    SOCKET_TEST_ERROR(r = select(nfds, &nrd, &nwr, &nex, (PTIMEVAL)timeout));
    save_errno = errno;

    for (i = 0; i < nfds; i++) {
	if (rd && PERL_FD_ISSET(i,rd)) {
	    fd = TO_SOCKET(i);
	    if (!FD_ISSET(fd, &nrd))
		PERL_FD_CLR(i,rd);
	}
	if (wr && PERL_FD_ISSET(i,wr)) {
	    fd = TO_SOCKET(i);
	    if (!FD_ISSET(fd, &nwr))
		PERL_FD_CLR(i,wr);
	}
	if (ex && PERL_FD_ISSET(i,ex)) {
	    fd = TO_SOCKET(i);
	    if (!FD_ISSET(fd, &nex))
		PERL_FD_CLR(i,ex);
	}
    }
    errno = save_errno;
    return r;
}

int
win32_send(SOCKET s, const char *buf, int len, int flags)
{
    int r;

    SOCKET_TEST_ERROR(r = send(TO_SOCKET(s), buf, len, flags));
    return r;
}

int
win32_sendto(SOCKET s, const char *buf, int len, int flags,
	     const struct sockaddr *to, int tolen)
{
    int r;

    SOCKET_TEST_ERROR(r = sendto(TO_SOCKET(s), buf, len, flags, to, tolen));
    return r;
}

int
win32_setsockopt(SOCKET s, int level, int optname, const char *optval, int optlen)
{
    int r;

    SOCKET_TEST_ERROR(r = setsockopt(TO_SOCKET(s), level, optname, optval, optlen));
    return r;
}
    
int
win32_shutdown(SOCKET s, int how)
{
    int r;

    SOCKET_TEST_ERROR(r = shutdown(TO_SOCKET(s), how));
    return r;
}

int
win32_closesocket(SOCKET s)
{
    int r;

    SOCKET_TEST_ERROR(r = closesocket(TO_SOCKET(s)));
    return r;
}

void
convert_proto_info_w2a(WSAPROTOCOL_INFOW *in, WSAPROTOCOL_INFOA *out)
{
    Copy(in, out, 1, WSAPROTOCOL_INFOA);
    wcstombs(out->szProtocol, in->szProtocol, sizeof(out->szProtocol));
}

SOCKET
open_ifs_socket(int af, int type, int protocol)
{
    dTHX;
    char *s;
    unsigned long proto_buffers_len = 0;
    int error_code;
    SOCKET out = INVALID_SOCKET;

    if ((s = PerlEnv_getenv("PERL_ALLOW_NON_IFS_LSP")) && atoi(s))
        return WSASocket(af, type, protocol, NULL, 0, 0);

    if (WSCEnumProtocols(NULL, NULL, &proto_buffers_len, &error_code) == SOCKET_ERROR
        && error_code == WSAENOBUFS)
    {
	WSAPROTOCOL_INFOW *proto_buffers;
        int protocols_available = 0;       
 
        Newx(proto_buffers, proto_buffers_len / sizeof(WSAPROTOCOL_INFOW),
            WSAPROTOCOL_INFOW);

        if ((protocols_available = WSCEnumProtocols(NULL, proto_buffers, 
            &proto_buffers_len, &error_code)) != SOCKET_ERROR)
        {
            int i;
            for (i = 0; i < protocols_available; i++)
            {
                WSAPROTOCOL_INFOA proto_info;

                if ((af != AF_UNSPEC && af != proto_buffers[i].iAddressFamily)
                    || (type != proto_buffers[i].iSocketType)
                    || (protocol != 0 && proto_buffers[i].iProtocol != 0 &&
                        protocol != proto_buffers[i].iProtocol))
                    continue;

                if ((proto_buffers[i].dwServiceFlags1 & XP1_IFS_HANDLES) == 0)
                    continue;

                convert_proto_info_w2a(&(proto_buffers[i]), &proto_info);

                out = WSASocket(af, type, protocol, &proto_info, 0, 0);
                break;
            }
        }

        Safefree(proto_buffers);
    }

    return out;
}

SOCKET
win32_socket(int af, int type, int protocol)
{
    SOCKET s;

    StartSockets();

    if((s = open_ifs_socket(af, type, protocol)) == INVALID_SOCKET)
        {
	int wsaerr = WSAGetLastError();
	errno = convert_wsa_error_to_errno(wsaerr);
	SetLastError(wsaerr);
	}
    else
	s = OPEN_SOCKET(s);

    return s;
}

/*
 * close RTL fd while respecting sockets
 * added as temporary measure until PerlIO has real
 * Win32 native layer
 *   -- BKS, 11-11-2000
*/

int my_close(int fd)
{
    int osf;
    if (!wsock_started)		/* No WinSock? */
	return(close(fd));	/* Then not a socket. */
    osf = TO_SOCKET(fd);/* Get it now before it's gone! */
    if (osf != -1) {
	int err;
	err = closesocket(osf);
	if (err == 0) {
	    assert(_osfhnd(fd) == osf); /* catch a bad ioinfo struct def */
	    /* don't close freed handle */
	    _set_osfhnd(fd, INVALID_HANDLE_VALUE);
	    return close(fd);
	}
	else if (err == SOCKET_ERROR) {
	    int wsaerr = WSAGetLastError();
	    err = convert_wsa_error_to_errno(wsaerr);
	    if (err != ENOTSOCK) {
		(void)close(fd);
		errno = err;
		SetLastError(wsaerr);
		return EOF;
	    }
	}
    }
    return close(fd);
}

#undef fclose
int
my_fclose (FILE *pf)
{
    int osf;
    if (!wsock_started)		/* No WinSock? */
	return(fclose(pf));	/* Then not a socket. */
    osf = TO_SOCKET(win32_fileno(pf));/* Get it now before it's gone! */
    if (osf != -1) {
	int err;
	win32_fflush(pf);
	err = closesocket(osf);
	if (err == 0) {
	    assert(_osfhnd(win32_fileno(pf)) == osf); /* catch a bad ioinfo struct def */
	    /* don't close freed handle */
	    _set_osfhnd(win32_fileno(pf), INVALID_HANDLE_VALUE);
	    return fclose(pf);
	}
	else if (err == SOCKET_ERROR) {
	    int wsaerr = WSAGetLastError();
	    err = convert_wsa_error_to_errno(wsaerr);
	    if (err != ENOTSOCK) {
		(void)fclose(pf);
		errno = err;
		SetLastError(wsaerr);
		return EOF;
	    }
	}
    }
    return fclose(pf);
}

struct hostent *
win32_gethostbyaddr(const char *addr, int len, int type)
{
    struct hostent *r;

    SOCKET_TEST(r = gethostbyaddr(addr, len, type), NULL);
    return r;
}

struct hostent *
win32_gethostbyname(const char *name)
{
    struct hostent *r;

    SOCKET_TEST(r = gethostbyname(name), NULL);
    return r;
}

int
win32_gethostname(char *name, int len)
{
    int r;

    SOCKET_TEST_ERROR(r = gethostname(name, len));
    return r;
}

struct protoent *
win32_getprotobyname(const char *name)
{
    struct protoent *r;

    SOCKET_TEST(r = getprotobyname(name), NULL);
    return r;
}

struct protoent *
win32_getprotobynumber(int num)
{
    struct protoent *r;

    SOCKET_TEST(r = getprotobynumber(num), NULL);
    return r;
}

struct servent *
win32_getservbyname(const char *name, const char *proto)
{
    dTHXa(NULL);    
    struct servent *r;

    SOCKET_TEST(r = getservbyname(name, proto), NULL);
    if (r) {
        aTHXa(PERL_GET_THX);
	r = win32_savecopyservent(&w32_servent, r, proto);
    }
    return r;
}

struct servent *
win32_getservbyport(int port, const char *proto)
{
    dTHXa(NULL); 
    struct servent *r;

    SOCKET_TEST(r = getservbyport(port, proto), NULL);
    if (r) {
        aTHXa(PERL_GET_THX);
	r = win32_savecopyservent(&w32_servent, r, proto);
    }
    return r;
}

int
win32_ioctl(int i, unsigned int u, char *data)
{
    u_long u_long_arg; 
    int retval;
    
    if (!wsock_started) {
	Perl_croak_nocontext("ioctl implemented only on sockets");
	/* NOTREACHED */
    }

    /* mauke says using memcpy avoids alignment issues */
    memcpy(&u_long_arg, data, sizeof u_long_arg); 
    retval = ioctlsocket(TO_SOCKET(i), (long)u, &u_long_arg);
    memcpy(data, &u_long_arg, sizeof u_long_arg);
    
    if (retval == SOCKET_ERROR) {
	int wsaerr = WSAGetLastError();
	int err = convert_wsa_error_to_errno(wsaerr);
	if (err == ENOTSOCK) {
	    Perl_croak_nocontext("ioctl implemented only on sockets");
	    /* NOTREACHED */
	}
	errno = err;
	SetLastError(wsaerr);
    }
    return retval;
}

char FAR *
win32_inet_ntoa(struct in_addr in)
{
    StartSockets();
    return inet_ntoa(in);
}

unsigned long
win32_inet_addr(const char FAR *cp)
{
    StartSockets();
    return inet_addr(cp);
}

/*
 * Networking stubs
 */

void
win32_endhostent() 
{
    win32_croak_not_implemented("endhostent");
}

void
win32_endnetent()
{
    win32_croak_not_implemented("endnetent");
}

void
win32_endprotoent()
{
    win32_croak_not_implemented("endprotoent");
}

void
win32_endservent()
{
    win32_croak_not_implemented("endservent");
}


struct netent *
win32_getnetent(void) 
{
    win32_croak_not_implemented("getnetent");
    return (struct netent *) NULL;
}

struct netent *
win32_getnetbyname(char *name) 
{
    win32_croak_not_implemented("getnetbyname");
    return (struct netent *)NULL;
}

struct netent *
win32_getnetbyaddr(long net, int type) 
{
    win32_croak_not_implemented("getnetbyaddr");
    return (struct netent *)NULL;
}

struct protoent *
win32_getprotoent(void) 
{
    win32_croak_not_implemented("getprotoent");
    return (struct protoent *) NULL;
}

struct servent *
win32_getservent(void) 
{
    win32_croak_not_implemented("getservent");
    return (struct servent *) NULL;
}

void
win32_sethostent(int stayopen)
{
    win32_croak_not_implemented("sethostent");
}


void
win32_setnetent(int stayopen)
{
    win32_croak_not_implemented("setnetent");
}


void
win32_setprotoent(int stayopen)
{
    win32_croak_not_implemented("setprotoent");
}


void
win32_setservent(int stayopen)
{
    win32_croak_not_implemented("setservent");
}

static struct servent*
win32_savecopyservent(struct servent*d, struct servent*s, const char *proto)
{
    d->s_name = s->s_name;
    d->s_aliases = s->s_aliases;
    d->s_port = s->s_port;
    if (s->s_proto && strlen(s->s_proto))
	d->s_proto = s->s_proto;
    else
    if (proto && strlen(proto))
	d->s_proto = (char *)proto;
    else
	d->s_proto = "tcp";
   
    return d;
}


@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d45 5
a49 1
	    errno = get_last_socket_error();		\
a53 1
static int get_last_socket_error(void);
a327 6
static int
get_last_socket_error(void)
{
    return convert_wsa_error_to_errno(WSAGetLastError());
}

d533 1
a533 1
    SOCKET_TEST_ERROR(r = select(nfds, &nrd, &nwr, &nex, timeout));
d669 5
a673 1
	errno = get_last_socket_error();
d703 2
a704 1
	    err = get_last_socket_error();
d708 1
d735 2
a736 1
	    err = get_last_socket_error();
d740 1
d838 2
a839 1
	int err = get_last_socket_error();
d845 1
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d45 1
a45 1
	    errno = WSAGetLastError();			\
d50 1
d57 4
d68 263
d352 2
a353 2
/* in no sockets Win32 builds, this fowards to replacements in util.c, dTHX
 * is required
d358 1
a358 3
#ifdef MYSWAP
    dTHX;
#else
d367 1
a367 3
#ifdef MYSWAP
    dTHX;
#else
d376 1
a376 3
#ifdef MYSWAP
    dTHX;
#else
d385 1
a385 3
#ifdef MYSWAP
    dTHX;
#else
d672 1
a672 1
	errno = WSAGetLastError();
d696 4
a699 2
	    (void)close(fd);	/* handle already closed, ignore error */
	    return 0;
d702 2
a703 2
	    err = WSAGetLastError();
	    if (err != WSAENOTSOCK) {
d726 4
a729 2
	    (void)fclose(pf);	/* handle already closed, ignore error */
	    return 0;
d732 2
a733 2
	    err = WSAGetLastError();
	    if (err != WSAENOTSOCK) {
d833 2
a834 1
	if (WSAGetLastError() == WSAENOTSOCK) {
d838 1
a838 1
	errno = WSAGetLastError();
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d32 2
a33 7
#ifdef USE_SOCKETS_AS_HANDLES
#	define OPEN_SOCKET(x)	win32_open_osfhandle(x,O_RDWR|O_BINARY)
#	define TO_SOCKET(x)	_get_osfhandle(x)
#else
#	define OPEN_SOCKET(x)	(x)
#	define TO_SOCKET(x)	(x)
#endif	/* USE_SOCKETS_AS_HANDLES */
a65 1
    dTHX;
d84 3
a86 38
#ifndef USE_SOCKETS_AS_HANDLES
#undef fdopen
FILE *
my_fdopen(int fd, char *mode)
{
    FILE *fp;
    char sockbuf[256];
    int optlen = sizeof(sockbuf);
    int retval;

    if (!wsock_started)
	return(fdopen(fd, mode));

    retval = getsockopt((SOCKET)fd, SOL_SOCKET, SO_TYPE, sockbuf, &optlen);
    if(retval == SOCKET_ERROR && WSAGetLastError() == WSAENOTSOCK) {
	return(fdopen(fd, mode));
    }

    /*
     * If we get here, then fd is actually a socket.
     */
    Newxz(fp, 1, FILE);	/* XXX leak, good thing this code isn't used */
    if(fp == NULL) {
	errno = ENOMEM;
	return NULL;
    }

    fp->_file = fd;
    if(*mode == 'r')
	fp->_flag = _IOREAD;
    else
	fp->_flag = _IOWRT;
   
    return fp;
}
#endif	/* USE_SOCKETS_AS_HANDLES */


d90 3
d94 1
d101 3
d105 1
d112 3
d116 1
d123 3
d127 1
a235 1
#ifdef USE_SOCKETS_AS_HANDLES
a296 3
#else
    SOCKET_TEST_ERROR(r = select(nfds, rd, wr, ex, timeout));
#endif
a345 3
#ifdef USE_SOCKETS_AS_HANDLES
#define WIN32_OPEN_SOCKET(af, type, protocol) open_ifs_socket(af, type, protocol)

a403 4
#else
#define WIN32_OPEN_SOCKET(af, type, protocol) socket(af, type, protocol)
#endif

a408 3
#ifndef USE_SOCKETS_AS_HANDLES
    SOCKET_TEST(s = socket(af, type, protocol), INVALID_SOCKET);
#else
d411 1
a411 1
    if((s = WIN32_OPEN_SOCKET(af, type, protocol)) == INVALID_SOCKET)
a414 1
#endif	/* USE_SOCKETS_AS_HANDLES */
d527 1
a527 1
    dTHX;    
d532 1
d541 1
a541 1
    dTHX; 
d546 1
a554 1
    dTHX;
d599 1
a599 2
    dTHX;
    Perl_croak_nocontext("endhostent not implemented!\n");
d605 1
a605 2
    dTHX;
    Perl_croak_nocontext("endnetent not implemented!\n");
d611 1
a611 2
    dTHX;
    Perl_croak_nocontext("endprotoent not implemented!\n");
d617 1
a617 2
    dTHX;
    Perl_croak_nocontext("endservent not implemented!\n");
d624 1
a624 2
    dTHX;
    Perl_croak_nocontext("getnetent not implemented!\n");
d631 1
a631 2
    dTHX;
    Perl_croak_nocontext("getnetbyname not implemented!\n");
d638 1
a638 2
    dTHX;
    Perl_croak_nocontext("getnetbyaddr not implemented!\n");
d645 1
a645 2
    dTHX;
    Perl_croak_nocontext("getprotoent not implemented!\n");
d652 1
a652 2
    dTHX;
    Perl_croak_nocontext("getservent not implemented!\n");
d659 1
a659 2
    dTHX;
    Perl_croak_nocontext("sethostent not implemented!\n");
d666 1
a666 2
    dTHX;
    Perl_croak_nocontext("setnetent not implemented!\n");
d673 1
a673 2
    dTHX;
    Perl_croak_nocontext("setprotoent not implemented!\n");
d680 1
a680 2
    dTHX;
    Perl_croak_nocontext("setservent not implemented!\n");
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@a475 3
#if defined(USE_FIXED_OSFHANDLE) || defined(PERL_MSVCRT_READFIX)
            _set_osfhnd(fd, INVALID_HANDLE_VALUE);
#endif
a503 3
#if defined(USE_FIXED_OSFHANDLE) || defined(PERL_MSVCRT_READFIX)
            _set_osfhnd(win32_fileno(pf), INVALID_HANDLE_VALUE);
#endif
a518 56
#undef fstat
int
my_fstat(int fd, Stat_t *sbufptr)
{
    /* This fixes a bug in fstat() on Windows 9x.  fstat() uses the
     * GetFileType() win32 syscall, which will fail on Windows 9x.
     * So if we recognize a socket on Windows 9x, we return the
     * same results as on Windows NT/2000.
     * XXX this should be extended further to set S_IFSOCK on
     * sbufptr->st_mode.
     */
    int osf;
    if (!wsock_started || IsWinNT()) {
#if defined(WIN64) || defined(USE_LARGE_FILES)
#if defined(__BORLANDC__) /* buk */
	return win32_fstat(fd, sbufptr );
#else
	return _fstati64(fd, sbufptr);
#endif
#else
	return fstat(fd, sbufptr);
#endif
    }

    osf = TO_SOCKET(fd);
    if (osf != -1) {
	char sockbuf[256];
	int optlen = sizeof(sockbuf);
	int retval;

	retval = getsockopt((SOCKET)osf, SOL_SOCKET, SO_TYPE, sockbuf, &optlen);
	if (retval != SOCKET_ERROR || WSAGetLastError() != WSAENOTSOCK) {
#if defined(__BORLANDC__)&&(__BORLANDC__<=0x520)
	    sbufptr->st_mode = S_IFIFO;
#else
	    sbufptr->st_mode = _S_IFIFO;
#endif
	    sbufptr->st_rdev = sbufptr->st_dev = (dev_t)fd;
	    sbufptr->st_nlink = 1;
	    sbufptr->st_uid = sbufptr->st_gid = sbufptr->st_ino = 0;
	    sbufptr->st_atime = sbufptr->st_mtime = sbufptr->st_ctime = 0;
	    sbufptr->st_size = (Off_t)0;
	    return 0;
	}
    }
#if defined(WIN64) || defined(USE_LARGE_FILES)
#if defined(__BORLANDC__) /* buk */
    return win32_fstat(fd, sbufptr );
#else
    return _fstati64(fd, sbufptr);
#endif
#else
    return fstat(fd, sbufptr);
#endif
}

d741 1
a741 2
#ifndef __BORLANDC__	/* Buggy on Win95 and WinNT-with-Borland-WSOCK */
    if (!IsWin95() && s->s_proto && strlen(s->s_proto))
a743 1
#endif
@


1.11
log
@Merge in perl 5.10.1; part two
@
text
@d4 1
a4 1
 * 		Developed by hip communications inc., http://info.hip.com/info/
d264 1
a265 11
    /* winsock seems incapable of dealing with all three null fd_sets,
     * so do the (millisecond) sleep as a special case
     */
    if (!(rd || wr || ex)) {
	if (timeout)
	    Sleep(timeout->tv_sec  * 1000 +
		  timeout->tv_usec / 1000);	/* do the best we can */
	else
	    Sleep(UINT_MAX);
	return 0;
    }
d275 1
d280 1
d285 1
d287 12
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a261 1
    Perl_fd_set dummy;
d263 1
a263 1
    FD_SET nrd, nwr, nex, *prd, *pwr, *pex;
a276 13
    PERL_FD_ZERO(&dummy);
    if (!rd)
	rd = &dummy, prd = NULL;
    else
	prd = &nrd;
    if (!wr)
	wr = &dummy, pwr = NULL;
    else
	pwr = &nwr;
    if (!ex)
	ex = &dummy, pex = NULL;
    else
	pex = &nex;
d282 2
a283 2
	fd = TO_SOCKET(i);
	if (PERL_FD_ISSET(i,rd))
d285 3
a287 1
	if (PERL_FD_ISSET(i,wr))
d289 3
a291 1
	if (PERL_FD_ISSET(i,ex))
d293 1
d297 1
a297 1
    SOCKET_TEST_ERROR(r = select(nfds, prd, pwr, pex, timeout));
d301 15
a315 7
	fd = TO_SOCKET(i);
	if (PERL_FD_ISSET(i,rd) && !FD_ISSET(fd, &nrd))
	    PERL_FD_CLR(i,rd);
	if (PERL_FD_ISSET(i,wr) && !FD_ISSET(fd, &nwr))
	    PERL_FD_CLR(i,wr);
	if (PERL_FD_ISSET(i,ex) && !FD_ISSET(fd, &nex))
	    PERL_FD_CLR(i,ex);
@


1.9
log
@merge in perl 5.8.8
@
text
@a39 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
a43 1
	set_socktype();                                 \
a44 9
#else
#define StartSockets() \
    STMT_START {					\
	if (!wsock_started) {				\
	    start_sockets();				\
	    set_socktype();				\
	}						\
    } STMT_END
#endif
a89 14
void
set_socktype(void)
{
#ifdef USE_SOCKETS_AS_HANDLES
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
    dTHX;
    if (!w32_init_socktype) {
	w32_init_socktype = 1;
    }
#endif
#endif	/* USE_SOCKETS_AS_HANDLES */
}


d652 1
a652 1
    u_long argp = (u_long)data;
d654 1
a654 1

d660 5
a664 1
    retval = ioctlsocket(TO_SOCKET(i), (long)u, &argp);
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d136 1
a136 1
    Newz(1310, fp, 1, FILE);	/* XXX leak, good thing this code isn't used */
d323 1
a323 1
	    FD_SET(fd, &nrd);
d325 1
a325 1
	    FD_SET(fd, &nwr);
d327 1
a327 1
	    FD_SET(fd, &nex);
d424 1
a424 1
        New(1, proto_buffers, proto_buffers_len / sizeof(WSAPROTOCOL_INFOW),
d437 2
a438 1
                    || (protocol != 0 && protocol != proto_buffers[i].iProtocol))
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d19 2
d91 1
a91 1
    version = 0x101;
d95 1
a95 1
	Perl_croak_nocontext("Could not find version 1.1 of winsock dll\n");
a107 8
#endif
	int iSockOpt = SO_SYNCHRONOUS_NONALERT;
	/*
	 * Enable the use of sockets as filehandles
	 */
	setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE,
		    (char *)&iSockOpt, sizeof(iSockOpt));
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d396 64
d469 2
a470 1
    if((s = socket(af, type, protocol)) == INVALID_SOCKET)
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d500 3
d504 1
d532 3
d536 1
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d294 1
a294 1
    int i, fd;
d336 1
d338 1
d349 1
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d14 1
a21 5
#if defined(PERL_OBJECT)
#define NO_XSLOCKS
#include "XSUB.h"
#endif

d38 1
a38 1
#if defined(USE_THREADS) || defined(USE_ITHREADS)
d80 1
a80 1
    dTHXo;
d103 2
a104 2
#if defined(USE_THREADS) || defined(USE_ITHREADS)
    dTHXo;
d113 1
a113 1
#if defined(USE_THREADS) || defined(USE_ITHREADS)
d294 1
a294 1
    int i, fd, bit, offset;
d417 35
d459 1
a459 1
    osf = TO_SOCKET(fileno(pf));/* Get it now before it's gone! */
d466 1
a466 1
            _set_osfhnd(fileno(pf), INVALID_HANDLE_VALUE);
d485 1
a485 1
my_fstat(int fd, struct stat *sbufptr)
d495 4
a498 1
    if (!wsock_started || IsWinNT())
d500 2
d520 1
a520 1
	    sbufptr->st_size = (off_t)0;
d524 3
d528 1
d579 1
a579 1
    dTHXo;    
d592 1
a592 1
    dTHXo; 
d605 1
a605 1
    dTHXo;
d646 1
a646 1
    dTHXo;
d653 1
a653 1
    dTHXo;
d660 1
a660 1
    dTHXo;
d667 1
a667 1
    dTHXo;
d675 1
a675 1
    dTHXo;
d683 1
a683 1
    dTHXo;
d691 1
a691 1
    dTHXo;
d699 1
a699 1
    dTHXo;
d707 1
a707 1
    dTHXo;
d715 1
a715 1
    dTHXo;
d723 1
a723 1
    dTHXo;
d731 1
a731 1
    dTHXo;
d739 1
a739 1
    dTHXo;
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d42 1
a42 1
#ifdef USE_THREADS
d47 1
a47 1
       set_socktype();                         \
a58 6
#define EndSockets() \
    STMT_START {					\
	if (wsock_started)				\
	    WSACleanup();				\
    } STMT_END

d74 7
d107 2
a108 2
#ifdef USE_THREADS
    dTHX;
d117 1
a117 1
#ifdef USE_THREADS
d146 1
a146 1
    Newz(1310, fp, 1, FILE);
d425 1
a425 1
    int osf, retval;
d429 58
a486 6
    retval = fclose(pf);	/* Must fclose() before closesocket() */
    if (osf != -1
	&& closesocket(osf) == SOCKET_ERROR
	&& WSAGetLastError() != WSAENOTSOCK)
    {
	return EOF;
d488 1
a488 1
    return retval;
@


1.2
log
@perl5.005_03 (stock)
@
text
@a22 1
extern CPerlObj* pPerl;
a77 12
#ifdef USE_THREADS
#ifdef USE_DECLSPEC_THREAD
__declspec(thread) struct servent myservent;
__declspec(thread) int init_socktype;
#else
#define myservent (thr->i.Wservent)
#define init_socktype (thr->i.Winit_socktype)
#endif
#else
static struct servent myservent;
#endif

d83 1
d94 1
a94 1
	croak("Unable to locate winsock library!\n");
d96 1
a96 1
	croak("Could not find version 1.1 of winsock dll\n");
d107 2
a108 2
    dTHR;
    if(!init_socktype) {
d110 6
a115 6
    int iSockOpt = SO_SYNCHRONOUS_NONALERT;
    /*
     * Enable the use of sockets as filehandles
     */
    setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE,
		(char *)&iSockOpt, sizeof(iSockOpt));
d117 1
a117 1
    init_socktype = 1;
d486 1
a487 1
    dTHR;    
d491 1
a491 1
	r = win32_savecopyservent(&myservent, r, proto);
d499 1
a500 1
    dTHR; 
d504 1
a504 1
	r = win32_savecopyservent(&myservent, r, proto);
d512 1
d517 1
a517 1
	croak("ioctl implemented only on sockets");
d524 1
a524 1
	    croak("ioctl implemented only on sockets");
d553 2
a554 1
    croak("endhostent not implemented!\n");
d560 2
a561 1
    croak("endnetent not implemented!\n");
d567 2
a568 1
    croak("endprotoent not implemented!\n");
d574 2
a575 1
    croak("endservent not implemented!\n");
d582 2
a583 1
    croak("getnetent not implemented!\n");
d590 2
a591 1
    croak("getnetbyname not implemented!\n");
d598 2
a599 1
    croak("getnetbyaddr not implemented!\n");
d606 2
a607 1
    croak("getprotoent not implemented!\n");
d614 2
a615 1
    croak("getservent not implemented!\n");
d622 2
a623 1
    croak("sethostent not implemented!\n");
d630 2
a631 1
    croak("setnetent not implemented!\n");
d638 2
a639 1
    croak("setprotoent not implemented!\n");
d646 2
a647 1
    croak("setservent not implemented!\n");
@


1.1
log
@perl 5.004_04
@
text
@d1 1
a1 1
/* NTSock.C
d11 6
a17 1
#define WIN32_LEAN_AND_MEAN
d20 8
d32 1
d34 1
a34 2
#define CROAK croak

d36 6
a41 4
/* thanks to Beverly Brown	(beverly@@datacube.com) */

#define OPEN_SOCKET(x)	_open_osfhandle(x,O_RDWR|O_BINARY)
#define TO_SOCKET(x)	_get_osfhandle(x)
d43 7
d51 8
d60 12
a71 2
#	define OPEN_SOCKET(x)	(x)
#	define TO_SOCKET(x)	(x)
d73 1
a73 1
#endif	/* USE_SOCKETS_AS_HANDLES */
a77 79
#define SOCKETAPI PASCAL 

typedef SOCKET (SOCKETAPI *LPSOCKACCEPT)(SOCKET, struct sockaddr *, int *);
typedef int (SOCKETAPI *LPSOCKBIND)(SOCKET, const struct sockaddr *, int);
typedef int (SOCKETAPI *LPSOCKCLOSESOCKET)(SOCKET);
typedef int (SOCKETAPI *LPSOCKCONNECT)(SOCKET, const struct sockaddr *, int);
typedef int (SOCKETAPI *LPSOCKIOCTLSOCKET)(SOCKET, long, u_long *);
typedef int (SOCKETAPI *LPSOCKGETPEERNAME)(SOCKET, struct sockaddr *, int *);
typedef int (SOCKETAPI *LPSOCKGETSOCKNAME)(SOCKET, struct sockaddr *, int *);
typedef int (SOCKETAPI *LPSOCKGETSOCKOPT)(SOCKET, int, int, char *, int *);
typedef u_long (SOCKETAPI *LPSOCKHTONL)(u_long);
typedef u_short (SOCKETAPI *LPSOCKHTONS)(u_short);
typedef int (SOCKETAPI *LPSOCKLISTEN)(SOCKET, int);
typedef u_long (SOCKETAPI *LPSOCKNTOHL)(u_long);
typedef u_short (SOCKETAPI *LPSOCKNTOHS)(u_short);
typedef int (SOCKETAPI *LPSOCKRECV)(SOCKET, char *, int, int);
typedef int (SOCKETAPI *LPSOCKRECVFROM)(SOCKET, char *, int, int, struct sockaddr *, int *);
typedef int (SOCKETAPI *LPSOCKSELECT)(int, fd_set *, fd_set *, fd_set *, const struct timeval *);
typedef int (SOCKETAPI *LPSOCKSEND)(SOCKET, const char *, int, int);
typedef int (SOCKETAPI *LPSOCKSENDTO)(SOCKET, const char *, int, int, const struct sockaddr *, int);
typedef int (SOCKETAPI *LPSOCKSETSOCKOPT)(SOCKET, int, int, const char *, int);
typedef int (SOCKETAPI *LPSOCKSHUTDOWN)(SOCKET, int);
typedef SOCKET (SOCKETAPI *LPSOCKSOCKET)(int, int, int);
typedef char FAR *(SOCKETAPI *LPSOCKINETNTOA)(struct in_addr in);
typedef unsigned long (SOCKETAPI *LPSOCKINETADDR)(const char FAR * cp);


/* Database function prototypes */
typedef struct hostent *(SOCKETAPI *LPSOCKGETHOSTBYADDR)(const char *, int, int);
typedef struct hostent *(SOCKETAPI *LPSOCKGETHOSTBYNAME)(const char *);
typedef int (SOCKETAPI *LPSOCKGETHOSTNAME)(char *, int);
typedef struct servent *(SOCKETAPI *LPSOCKGETSERVBYPORT)(int, const char *);
typedef struct servent *(SOCKETAPI *LPSOCKGETSERVBYNAME)(const char *, const char *);
typedef struct protoent *(SOCKETAPI *LPSOCKGETPROTOBYNUMBER)(int);
typedef struct protoent *(SOCKETAPI *LPSOCKGETPROTOBYNAME)(const char *);

/* Microsoft Windows Extension function prototypes */
typedef int (SOCKETAPI *LPSOCKWSASTARTUP)(unsigned short, LPWSADATA);
typedef int (SOCKETAPI *LPSOCKWSACLEANUP)(void);
typedef int (SOCKETAPI *LPSOCKWSAGETLASTERROR)(void);
typedef int (SOCKETAPI *LPWSAFDIsSet)(SOCKET, fd_set *);

static HINSTANCE hWinSockDll = 0;
/* extern CRITICAL_SECTION csSock; */

static LPSOCKACCEPT paccept = 0;
static LPSOCKBIND pbind = 0;
static LPSOCKCLOSESOCKET pclosesocket = 0;
static LPSOCKCONNECT pconnect = 0;
static LPSOCKIOCTLSOCKET pioctlsocket = 0;
static LPSOCKGETPEERNAME pgetpeername = 0;
static LPSOCKGETSOCKNAME pgetsockname = 0;
static LPSOCKGETSOCKOPT pgetsockopt = 0;
static LPSOCKHTONL phtonl = 0;
static LPSOCKHTONS phtons = 0;
static LPSOCKLISTEN plisten = 0;
static LPSOCKNTOHL pntohl = 0;
static LPSOCKNTOHS pntohs = 0;
static LPSOCKRECV precv = 0;
static LPSOCKRECVFROM precvfrom = 0;
static LPSOCKSELECT pselect = 0;
static LPSOCKSEND psend = 0;
static LPSOCKSENDTO psendto = 0;
static LPSOCKSETSOCKOPT psetsockopt = 0;
static LPSOCKSHUTDOWN pshutdown = 0;
static LPSOCKSOCKET psocket = 0;
static LPSOCKGETHOSTBYADDR pgethostbyaddr = 0;
static LPSOCKGETHOSTBYNAME pgethostbyname = 0;
static LPSOCKGETHOSTNAME pgethostname = 0;
static LPSOCKGETSERVBYPORT pgetservbyport = 0;
static LPSOCKGETSERVBYNAME pgetservbyname = 0;
static LPSOCKGETPROTOBYNUMBER pgetprotobynumber = 0;
static LPSOCKGETPROTOBYNAME pgetprotobyname = 0;
static LPSOCKWSASTARTUP pWSAStartup = 0;
static LPSOCKWSACLEANUP pWSACleanup = 0;
static LPSOCKWSAGETLASTERROR pWSAGetLastError = 0;
static LPWSAFDIsSet pWSAFDIsSet = 0;
static LPSOCKINETNTOA pinet_ntoa = 0;
static LPSOCKINETADDR pinet_addr = 0;
d79 2
d82 8
d91 1
a91 58

void *
GetAddress(HINSTANCE hInstance, char *lpFunctionName)
{
    FARPROC proc = GetProcAddress(hInstance, lpFunctionName);
    if(proc == 0)
	CROAK("Unable to get address of %s in WSock32.dll", lpFunctionName);
    return proc;
}

void
LoadWinSock(void)
{
/*  EnterCriticalSection(&csSock); */
    if(hWinSockDll == NULL) {
	HINSTANCE hLib = LoadLibrary("WSock32.DLL");
	if(hLib == NULL)
	    CROAK("Could not load WSock32.dll\n");

	paccept = (LPSOCKACCEPT)GetAddress(hLib, "accept");
	pbind = (LPSOCKBIND)GetAddress(hLib, "bind");
	pclosesocket = (LPSOCKCLOSESOCKET)GetAddress(hLib, "closesocket");
	pconnect = (LPSOCKCONNECT)GetAddress(hLib, "connect");
	pioctlsocket = (LPSOCKIOCTLSOCKET)GetAddress(hLib, "ioctlsocket");
	pgetpeername = (LPSOCKGETPEERNAME)GetAddress(hLib, "getpeername");
	pgetsockname = (LPSOCKGETSOCKNAME)GetAddress(hLib, "getsockname");
	pgetsockopt = (LPSOCKGETSOCKOPT)GetAddress(hLib, "getsockopt");
	phtonl = (LPSOCKHTONL)GetAddress(hLib, "htonl");
	phtons = (LPSOCKHTONS)GetAddress(hLib, "htons");
	plisten = (LPSOCKLISTEN)GetAddress(hLib, "listen");
	pntohl = (LPSOCKNTOHL)GetAddress(hLib, "ntohl");
	pntohs = (LPSOCKNTOHS)GetAddress(hLib, "ntohs");
	precv = (LPSOCKRECV)GetAddress(hLib, "recv");
	precvfrom = (LPSOCKRECVFROM)GetAddress(hLib, "recvfrom");
	pselect = (LPSOCKSELECT)GetAddress(hLib, "select");
	psend = (LPSOCKSEND)GetAddress(hLib, "send");
	psendto = (LPSOCKSENDTO)GetAddress(hLib, "sendto");
	psetsockopt = (LPSOCKSETSOCKOPT)GetAddress(hLib, "setsockopt");
	pshutdown = (LPSOCKSHUTDOWN)GetAddress(hLib, "shutdown");
	psocket = (LPSOCKSOCKET)GetAddress(hLib, "socket");
	pgethostbyaddr = (LPSOCKGETHOSTBYADDR)GetAddress(hLib, "gethostbyaddr");
	pgethostbyname = (LPSOCKGETHOSTBYNAME)GetAddress(hLib, "gethostbyname");
	pgethostname = (LPSOCKGETHOSTNAME)GetAddress(hLib, "gethostname");
	pgetservbyport = (LPSOCKGETSERVBYPORT)GetAddress(hLib, "getservbyport");
	pgetservbyname = (LPSOCKGETSERVBYNAME)GetAddress(hLib, "getservbyname");
	pgetprotobynumber = (LPSOCKGETPROTOBYNUMBER)GetAddress(hLib, "getprotobynumber");
	pgetprotobyname = (LPSOCKGETPROTOBYNAME)GetAddress(hLib, "getprotobyname");
	pWSAStartup = (LPSOCKWSASTARTUP)GetAddress(hLib, "WSAStartup");
	pWSACleanup = (LPSOCKWSACLEANUP)GetAddress(hLib, "WSACleanup");
	pWSAGetLastError = (LPSOCKWSAGETLASTERROR)GetAddress(hLib, "WSAGetLastError");
	pWSAFDIsSet = (LPWSAFDIsSet)GetAddress(hLib, "__WSAFDIsSet");
	pinet_addr = (LPSOCKINETADDR)GetAddress(hLib,"inet_addr");
	pinet_ntoa = (LPSOCKINETNTOA)GetAddress(hLib,"inet_ntoa");

	hWinSockDll = hLib;
    }
/*  LeaveCriticalSection(&csSock); */
}
d94 1
a94 11
EndSockets(void)
{
    if(hWinSockDll != NULL) {
	pWSACleanup();
	FreeLibrary(hWinSockDll);
    }
    hWinSockDll = NULL;
}

void
StartSockets(void) 
a98 1
    int iSockOpt = SO_SYNCHRONOUS_NONALERT;
a99 1
    LoadWinSock();
d105 2
a106 2
    if(ret = pWSAStartup(version, &retdata))
	CROAK("Unable to locate winsock library!\n");
d108 1
a108 1
	CROAK("Could not find version 1.1 of winsock dll\n");
d111 2
d114 3
d118 5
d126 1
a126 1
    psetsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE,
d128 4
d137 1
d139 1
a139 1
myfdopen(int fd, char *mode)
d146 1
a146 1
    if (hWinSockDll == 0)
d149 2
a150 2
    retval = pgetsockopt((SOCKET)fd, SOL_SOCKET, SO_TYPE, sockbuf, &optlen);
    if(retval == SOCKET_ERROR && pWSAGetLastError() == WSAENOTSOCK) {
d177 2
a178 4
    if(hWinSockDll == 0)
	StartSockets();

    return phtonl(hostlong);
d184 2
a185 4
    if(hWinSockDll == 0)
	StartSockets();

    return phtons(hostshort);
d191 2
a192 4
    if(hWinSockDll == 0)
	StartSockets();

    return pntohl(netlong);
d198 2
a199 4
    if(hWinSockDll == 0)
	StartSockets();

    return pntohs(netshort);
a202 4
#define SOCKET_TEST(x, y)	if(hWinSockDll == 0) StartSockets();\
				if((x) == (y)) errno = pWSAGetLastError()

#define SOCKET_TEST_ERROR(x) SOCKET_TEST(x, SOCKET_ERROR)
d209 1
a209 1
    SOCKET_TEST((r = paccept(TO_SOCKET(s), addr, addrlen)), INVALID_SOCKET);
d218 1
a218 1
    SOCKET_TEST_ERROR(r = pbind(TO_SOCKET(s), addr, addrlen));
d227 1
a227 1
    SOCKET_TEST_ERROR(r = pconnect(TO_SOCKET(s), addr, addrlen));
d237 1
a237 1
    SOCKET_TEST_ERROR(r = pgetpeername(TO_SOCKET(s), addr, addrlen));
d246 1
a246 1
    SOCKET_TEST_ERROR(r = pgetsockname(TO_SOCKET(s), addr, addrlen));
d255 1
a255 1
    SOCKET_TEST_ERROR(r = pgetsockopt(TO_SOCKET(s), level, optname, optval, optlen));
d264 1
a264 1
    SOCKET_TEST_ERROR(r = pioctlsocket(TO_SOCKET(s), cmd, argp));
d273 1
a273 1
    SOCKET_TEST_ERROR(r = plisten(TO_SOCKET(s), backlog));
d282 1
a282 1
    SOCKET_TEST_ERROR(r = precv(TO_SOCKET(s), buf, len, flags));
d290 1
d292 7
a298 1
    SOCKET_TEST_ERROR(r = precvfrom(TO_SOCKET(s), buf, len, flags, from, fromlen));
d304 1
a304 1
win32_select(int nfds, int* rd, int* wr, int* ex, const struct timeval* timeout)
d306 3
a308 2
    long r;
    int dummy = 0;
d310 1
a310 1
    FD_SET nrd, nwr, nex,*prd,*pwr,*pex;
d312 13
d343 1
a343 3
	bit = 1L<<(i % (sizeof(int)*8));
	offset = i / (sizeof(int)*8);
	if (rd[offset] & bit)
d345 1
a345 1
	if (wr[offset] & bit)
d347 1
a347 1
	if (ex[offset] & bit)
d351 1
a351 1
    SOCKET_TEST_ERROR(r = pselect(nfds, prd, pwr, pex, timeout));
d355 6
a360 14
	bit = 1L<<(i % (sizeof(int)*8));
	offset = i / (sizeof(int)*8);
	if (rd[offset] & bit) {
	    if (!pWSAFDIsSet(fd, &nrd))
		rd[offset] &= ~bit;
	}
	if (wr[offset] & bit) {
	    if (!pWSAFDIsSet(fd, &nwr))
		wr[offset] &= ~bit;
	}
	if (ex[offset] & bit) {
	    if (!pWSAFDIsSet(fd, &nex))
		ex[offset] &= ~bit;
	}
d362 3
d373 1
a373 1
    SOCKET_TEST_ERROR(r = psend(TO_SOCKET(s), buf, len, flags));
d383 1
a383 1
    SOCKET_TEST_ERROR(r = psendto(TO_SOCKET(s), buf, len, flags, to, tolen));
d392 1
a392 1
    SOCKET_TEST_ERROR(r = psetsockopt(TO_SOCKET(s), level, optname, optval, optlen));
d401 10
a410 1
    SOCKET_TEST_ERROR(r = pshutdown(TO_SOCKET(s), how));
d420 1
a420 1
    SOCKET_TEST(s = psocket(af, type, protocol), INVALID_SOCKET);
d422 3
a424 5
    if(hWinSockDll == 0)
	StartSockets();

    if((s = psocket(af, type, protocol)) == INVALID_SOCKET)
	errno = pWSAGetLastError();
d436 12
a447 10
	int osf, retval;
	if (hWinSockDll == 0)		/* No WinSockDLL? */
		return(fclose(pf));	/* Then not a socket. */
	osf = TO_SOCKET(fileno(pf));	/* Get it now before it's gone! */
	retval = fclose(pf);		/* Must fclose() before closesocket() */
	if (osf != -1
	    && pclosesocket(osf) == SOCKET_ERROR
	    && WSAGetLastError() != WSAENOTSOCK)
		retval = EOF;
	return retval;
d455 1
a455 1
    SOCKET_TEST(r = pgethostbyaddr(addr, len, type), NULL);
d464 1
a464 1
    SOCKET_TEST(r = pgethostbyname(name), NULL);
d473 1
a473 1
    SOCKET_TEST_ERROR(r = pgethostname(name, len));
d482 1
a482 1
    SOCKET_TEST(r = pgetprotobyname(name), NULL);
d491 1
a491 1
    SOCKET_TEST(r = pgetprotobynumber(num), NULL);
d499 3
a501 2
   
    SOCKET_TEST(r = pgetservbyname(name, proto), NULL);
d512 1
d514 1
a514 1
    SOCKET_TEST(r = pgetservbyport(port, proto), NULL);
d521 22
d546 2
a547 4
    if(hWinSockDll == 0)
	StartSockets();

    return pinet_ntoa(in);
d553 2
a554 5
    if(hWinSockDll == 0)
	StartSockets();

    return pinet_addr(cp);

a559 2
#undef CROAK 
#define CROAK croak
d564 1
a564 1
    CROAK("endhostent not implemented!\n");
d570 1
a570 1
    CROAK("endnetent not implemented!\n");
d576 1
a576 1
    CROAK("endprotoent not implemented!\n");
d582 1
a582 1
    CROAK("endservent not implemented!\n");
d589 1
a589 1
    CROAK("getnetent not implemented!\n");
d596 1
a596 1
    CROAK("getnetbyname not implemented!\n");
d603 1
a603 1
    CROAK("getnetbyaddr not implemented!\n");
d610 1
a610 1
    CROAK("getprotoent not implemented!\n");
d617 1
a617 1
    CROAK("getservent not implemented!\n");
d624 1
a624 1
    CROAK("sethostent not implemented!\n");
d631 1
a631 1
    CROAK("setnetent not implemented!\n");
d638 1
a638 1
    CROAK("setprotoent not implemented!\n");
d645 1
a645 1
    CROAK("setservent not implemented!\n");
a647 4
#define WIN32IO_IS_STDIO
#include <io.h>
#include "win32iop.h"

d659 1
a659 1
	if (proto && strlen(proto))
@


1.1.1.1
log
@perl5.005_03
@
text
@d1 1
a1 1
/* win32sck.c
d11 1
a11 2
#define WIN32IO_IS_STDIO
#define WIN32SCK_IS_STDSCK
a12 4
#ifdef __GNUC__
#define Win32_Winsock
#endif
#include <windows.h>
a14 8

#if defined(PERL_OBJECT)
#define NO_XSLOCKS
extern CPerlObj* pPerl;
#include "XSUB.h"
#endif

#include "Win32iop.h"
a18 1
#include <io.h>
d20 3
d24 4
a27 3
#ifdef USE_SOCKETS_AS_HANDLES
#	define OPEN_SOCKET(x)	win32_open_osfhandle(x,O_RDWR|O_BINARY)
#	define TO_SOCKET(x)	_get_osfhandle(x)
d29 1
d32 1
a34 32
#ifdef USE_THREADS
#define StartSockets() \
    STMT_START {					\
	if (!wsock_started)				\
	    start_sockets();				\
       set_socktype();                         \
    } STMT_END
#else
#define StartSockets() \
    STMT_START {					\
	if (!wsock_started) {				\
	    start_sockets();				\
	    set_socktype();				\
	}						\
    } STMT_END
#endif

#define EndSockets() \
    STMT_START {					\
	if (wsock_started)				\
	    WSACleanup();				\
    } STMT_END

#define SOCKET_TEST(x, y) \
    STMT_START {					\
	StartSockets();					\
	if((x) == (y))					\
	    errno = WSAGetLastError();			\
    } STMT_END

#define SOCKET_TEST_ERROR(x) SOCKET_TEST(x, SOCKET_ERROR)

d38 79
a117 2
#ifdef USE_THREADS
#ifdef USE_DECLSPEC_THREAD
a118 8
__declspec(thread) int init_socktype;
#else
#define myservent (thr->i.Wservent)
#define init_socktype (thr->i.Winit_socktype)
#endif
#else
static struct servent myservent;
#endif
d120 68
a187 1
static int wsock_started = 0;
d190 1
a190 1
start_sockets(void) 
d195 1
d197 1
d203 2
a204 2
    if(ret = WSAStartup(version, &retdata))
	croak("Unable to locate winsock library!\n");
d206 1
a206 1
	croak("Could not find version 1.1 of winsock dll\n");
a208 2
    wsock_started = 1;
}
a209 3
void
set_socktype(void)
{
a210 5
#ifdef USE_THREADS
    dTHR;
    if(!init_socktype) {
#endif
    int iSockOpt = SO_SYNCHRONOUS_NONALERT;
d214 1
a214 1
    setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE,
a215 4
#ifdef USE_THREADS
    init_socktype = 1;
    }
#endif
a220 1
#undef fdopen
d222 1
a222 1
my_fdopen(int fd, char *mode)
d229 1
a229 1
    if (!wsock_started)
d232 2
a233 2
    retval = getsockopt((SOCKET)fd, SOL_SOCKET, SO_TYPE, sockbuf, &optlen);
    if(retval == SOCKET_ERROR && WSAGetLastError() == WSAENOTSOCK) {
d260 4
a263 2
    StartSockets();
    return htonl(hostlong);
d269 4
a272 2
    StartSockets();
    return htons(hostshort);
d278 4
a281 2
    StartSockets();
    return ntohl(netlong);
d287 4
a290 2
    StartSockets();
    return ntohs(netshort);
d294 4
d304 1
a304 1
    SOCKET_TEST((r = accept(TO_SOCKET(s), addr, addrlen)), INVALID_SOCKET);
d313 1
a313 1
    SOCKET_TEST_ERROR(r = bind(TO_SOCKET(s), addr, addrlen));
d322 1
a322 1
    SOCKET_TEST_ERROR(r = connect(TO_SOCKET(s), addr, addrlen));
d332 1
a332 1
    SOCKET_TEST_ERROR(r = getpeername(TO_SOCKET(s), addr, addrlen));
d341 1
a341 1
    SOCKET_TEST_ERROR(r = getsockname(TO_SOCKET(s), addr, addrlen));
d350 1
a350 1
    SOCKET_TEST_ERROR(r = getsockopt(TO_SOCKET(s), level, optname, optval, optlen));
d359 1
a359 1
    SOCKET_TEST_ERROR(r = ioctlsocket(TO_SOCKET(s), cmd, argp));
d368 1
a368 1
    SOCKET_TEST_ERROR(r = listen(TO_SOCKET(s), backlog));
d377 1
a377 1
    SOCKET_TEST_ERROR(r = recv(TO_SOCKET(s), buf, len, flags));
a384 1
    int frombufsize = *fromlen;
d386 1
a386 7
    SOCKET_TEST_ERROR(r = recvfrom(TO_SOCKET(s), buf, len, flags, from, fromlen));
    /* Winsock's recvfrom() only returns a valid 'from' when the socket
     * is connectionless.  Perl expects a valid 'from' for all types
     * of sockets, so go the extra mile.
     */
    if (r != SOCKET_ERROR && frombufsize == *fromlen)
	(void)win32_getpeername(s, from, fromlen);
d392 1
a392 1
win32_select(int nfds, Perl_fd_set* rd, Perl_fd_set* wr, Perl_fd_set* ex, const struct timeval* timeout)
d394 2
a395 3
    int r;
#ifdef USE_SOCKETS_AS_HANDLES
    Perl_fd_set dummy;
d397 1
a397 1
    FD_SET nrd, nwr, nex, *prd, *pwr, *pex;
a398 13
    /* winsock seems incapable of dealing with all three null fd_sets,
     * so do the (millisecond) sleep as a special case
     */
    if (!(rd || wr || ex)) {
	if (timeout)
	    Sleep(timeout->tv_sec  * 1000 +
		  timeout->tv_usec / 1000);	/* do the best we can */
	else
	    Sleep(UINT_MAX);
	return 0;
    }
    StartSockets();
    PERL_FD_ZERO(&dummy);
d417 3
a419 1
	if (PERL_FD_ISSET(i,rd))
d421 1
a421 1
	if (PERL_FD_ISSET(i,wr))
d423 1
a423 1
	if (PERL_FD_ISSET(i,ex))
d427 1
a427 1
    SOCKET_TEST_ERROR(r = select(nfds, prd, pwr, pex, timeout));
d431 14
a444 6
	if (PERL_FD_ISSET(i,rd) && !FD_ISSET(fd, &nrd))
	    PERL_FD_CLR(i,rd);
	if (PERL_FD_ISSET(i,wr) && !FD_ISSET(fd, &nwr))
	    PERL_FD_CLR(i,wr);
	if (PERL_FD_ISSET(i,ex) && !FD_ISSET(fd, &nex))
	    PERL_FD_CLR(i,ex);
a445 3
#else
    SOCKET_TEST_ERROR(r = select(nfds, rd, wr, ex, timeout));
#endif
d454 1
a454 1
    SOCKET_TEST_ERROR(r = send(TO_SOCKET(s), buf, len, flags));
d464 1
a464 1
    SOCKET_TEST_ERROR(r = sendto(TO_SOCKET(s), buf, len, flags, to, tolen));
d473 1
a473 1
    SOCKET_TEST_ERROR(r = setsockopt(TO_SOCKET(s), level, optname, optval, optlen));
d482 1
a482 10
    SOCKET_TEST_ERROR(r = shutdown(TO_SOCKET(s), how));
    return r;
}

int
win32_closesocket(SOCKET s)
{
    int r;

    SOCKET_TEST_ERROR(r = closesocket(TO_SOCKET(s)));
d492 1
a492 1
    SOCKET_TEST(s = socket(af, type, protocol), INVALID_SOCKET);
d494 5
a498 3
    StartSockets();
    if((s = socket(af, type, protocol)) == INVALID_SOCKET)
	errno = WSAGetLastError();
d510 10
a519 12
    int osf, retval;
    if (!wsock_started)		/* No WinSock? */
	return(fclose(pf));	/* Then not a socket. */
    osf = TO_SOCKET(fileno(pf));/* Get it now before it's gone! */
    retval = fclose(pf);	/* Must fclose() before closesocket() */
    if (osf != -1
	&& closesocket(osf) == SOCKET_ERROR
	&& WSAGetLastError() != WSAENOTSOCK)
    {
	return EOF;
    }
    return retval;
d527 1
a527 1
    SOCKET_TEST(r = gethostbyaddr(addr, len, type), NULL);
d536 1
a536 1
    SOCKET_TEST(r = gethostbyname(name), NULL);
d545 1
a545 1
    SOCKET_TEST_ERROR(r = gethostname(name, len));
d554 1
a554 1
    SOCKET_TEST(r = getprotobyname(name), NULL);
d563 1
a563 1
    SOCKET_TEST(r = getprotobynumber(num), NULL);
d571 2
a572 3
    dTHR;    

    SOCKET_TEST(r = getservbyname(name, proto), NULL);
a582 1
    dTHR; 
d584 1
a584 1
    SOCKET_TEST(r = getservbyport(port, proto), NULL);
a590 22
int
win32_ioctl(int i, unsigned int u, char *data)
{
    u_long argp = (u_long)data;
    int retval;

    if (!wsock_started) {
	croak("ioctl implemented only on sockets");
	/* NOTREACHED */
    }

    retval = ioctlsocket(TO_SOCKET(i), (long)u, &argp);
    if (retval == SOCKET_ERROR) {
	if (WSAGetLastError() == WSAENOTSOCK) {
	    croak("ioctl implemented only on sockets");
	    /* NOTREACHED */
	}
	errno = WSAGetLastError();
    }
    return retval;
}

d594 4
a597 2
    StartSockets();
    return inet_ntoa(in);
d603 5
a607 2
    StartSockets();
    return inet_addr(cp);
d613 2
d619 1
a619 1
    croak("endhostent not implemented!\n");
d625 1
a625 1
    croak("endnetent not implemented!\n");
d631 1
a631 1
    croak("endprotoent not implemented!\n");
d637 1
a637 1
    croak("endservent not implemented!\n");
d644 1
a644 1
    croak("getnetent not implemented!\n");
d651 1
a651 1
    croak("getnetbyname not implemented!\n");
d658 1
a658 1
    croak("getnetbyaddr not implemented!\n");
d665 1
a665 1
    croak("getprotoent not implemented!\n");
d672 1
a672 1
    croak("getservent not implemented!\n");
d679 1
a679 1
    croak("sethostent not implemented!\n");
d686 1
a686 1
    croak("setnetent not implemented!\n");
d693 1
a693 1
    croak("setprotoent not implemented!\n");
d700 1
a700 1
    croak("setservent not implemented!\n");
d703 4
d718 1
a718 1
    if (proto && strlen(proto))
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d23 1
d79 12
a95 1
    dTHXo;
d106 1
a106 1
	Perl_croak_nocontext("Unable to locate winsock library!\n");
d108 1
a108 1
	Perl_croak_nocontext("Could not find version 1.1 of winsock dll\n");
d119 2
a120 2
    dTHX;
    if (!w32_init_socktype) {
d122 6
a127 6
	int iSockOpt = SO_SYNCHRONOUS_NONALERT;
	/*
	 * Enable the use of sockets as filehandles
	 */
	setsockopt(INVALID_SOCKET, SOL_SOCKET, SO_OPENTYPE,
		    (char *)&iSockOpt, sizeof(iSockOpt));
d129 1
a129 1
	w32_init_socktype = 1;
a497 1
    dTHXo;    
d499 1
d503 1
a503 1
	r = win32_savecopyservent(&w32_servent, r, proto);
a510 1
    dTHXo; 
d512 1
d516 1
a516 1
	r = win32_savecopyservent(&w32_servent, r, proto);
a523 1
    dTHXo;
d528 1
a528 1
	Perl_croak_nocontext("ioctl implemented only on sockets");
d535 1
a535 1
	    Perl_croak_nocontext("ioctl implemented only on sockets");
d564 1
a564 2
    dTHXo;
    Perl_croak_nocontext("endhostent not implemented!\n");
d570 1
a570 2
    dTHXo;
    Perl_croak_nocontext("endnetent not implemented!\n");
d576 1
a576 2
    dTHXo;
    Perl_croak_nocontext("endprotoent not implemented!\n");
d582 1
a582 2
    dTHXo;
    Perl_croak_nocontext("endservent not implemented!\n");
d589 1
a589 2
    dTHXo;
    Perl_croak_nocontext("getnetent not implemented!\n");
d596 1
a596 2
    dTHXo;
    Perl_croak_nocontext("getnetbyname not implemented!\n");
d603 1
a603 2
    dTHXo;
    Perl_croak_nocontext("getnetbyaddr not implemented!\n");
d610 1
a610 2
    dTHXo;
    Perl_croak_nocontext("getprotoent not implemented!\n");
d617 1
a617 2
    dTHXo;
    Perl_croak_nocontext("getservent not implemented!\n");
d624 1
a624 2
    dTHXo;
    Perl_croak_nocontext("sethostent not implemented!\n");
d631 1
a631 2
    dTHXo;
    Perl_croak_nocontext("setnetent not implemented!\n");
d638 1
a638 2
    dTHXo;
    Perl_croak_nocontext("setprotoent not implemented!\n");
d645 1
a645 2
    dTHXo;
    Perl_croak_nocontext("setservent not implemented!\n");
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d42 1
a42 1
#if defined(USE_THREADS) || defined(USE_ITHREADS)
d47 1
a47 1
	set_socktype();                                 \
d59 6
a79 7
EXTERN_C void
EndSockets(void)
{
    if (wsock_started)
	WSACleanup();
}

d106 2
a107 2
#if defined(USE_THREADS) || defined(USE_ITHREADS)
    dTHXo;
d116 1
a116 1
#if defined(USE_THREADS) || defined(USE_ITHREADS)
d145 1
a145 1
    Newz(1310, fp, 1, FILE);	/* XXX leak, good thing this code isn't used */
d424 1
a424 1
    int osf;
d428 6
a433 58
    if (osf != -1) {
	int err;
	win32_fflush(pf);
	err = closesocket(osf);
	if (err == 0) {
#if defined(USE_FIXED_OSFHANDLE) || defined(PERL_MSVCRT_READFIX)
            _set_osfhnd(fileno(pf), INVALID_HANDLE_VALUE);
#endif
	    (void)fclose(pf);	/* handle already closed, ignore error */
	    return 0;
	}
	else if (err == SOCKET_ERROR) {
	    err = WSAGetLastError();
	    if (err != WSAENOTSOCK) {
		(void)fclose(pf);
		errno = err;
		return EOF;
	    }
	}
    }
    return fclose(pf);
}

#undef fstat
int
my_fstat(int fd, struct stat *sbufptr)
{
    /* This fixes a bug in fstat() on Windows 9x.  fstat() uses the
     * GetFileType() win32 syscall, which will fail on Windows 9x.
     * So if we recognize a socket on Windows 9x, we return the
     * same results as on Windows NT/2000.
     * XXX this should be extended further to set S_IFSOCK on
     * sbufptr->st_mode.
     */
    int osf;
    if (!wsock_started || IsWinNT())
	return fstat(fd, sbufptr);

    osf = TO_SOCKET(fd);
    if (osf != -1) {
	char sockbuf[256];
	int optlen = sizeof(sockbuf);
	int retval;

	retval = getsockopt((SOCKET)osf, SOL_SOCKET, SO_TYPE, sockbuf, &optlen);
	if (retval != SOCKET_ERROR || WSAGetLastError() != WSAENOTSOCK) {
#if defined(__BORLANDC__)&&(__BORLANDC__<=0x520)
	    sbufptr->st_mode = S_IFIFO;
#else
	    sbufptr->st_mode = _S_IFIFO;
#endif
	    sbufptr->st_rdev = sbufptr->st_dev = (dev_t)fd;
	    sbufptr->st_nlink = 1;
	    sbufptr->st_uid = sbufptr->st_gid = sbufptr->st_ino = 0;
	    sbufptr->st_atime = sbufptr->st_mtime = sbufptr->st_ctime = 0;
	    sbufptr->st_size = (off_t)0;
	    return 0;
	}
d435 1
a435 1
    return fstat(fd, sbufptr);
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a13 1
#define PERLIO_NOT_STDIO 0
d21 5
d42 1
a42 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d84 1
a84 1
    dTHX;
d107 2
a108 2
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
    dTHX;
d117 1
a117 1
#if defined(USE_5005THREADS) || defined(USE_ITHREADS)
d298 1
a298 1
    int i, fd;
a420 35
/*
 * close RTL fd while respecting sockets
 * added as temporary measure until PerlIO has real
 * Win32 native layer
 *   -- BKS, 11-11-2000
*/

int my_close(int fd)
{
    int osf;
    if (!wsock_started)		/* No WinSock? */
	return(close(fd));	/* Then not a socket. */
    osf = TO_SOCKET(fd);/* Get it now before it's gone! */
    if (osf != -1) {
	int err;
	err = closesocket(osf);
	if (err == 0) {
#if defined(USE_FIXED_OSFHANDLE) || defined(PERL_MSVCRT_READFIX)
            _set_osfhnd(fd, INVALID_HANDLE_VALUE);
#endif
	    (void)close(fd);	/* handle already closed, ignore error */
	    return 0;
	}
	else if (err == SOCKET_ERROR) {
	    err = WSAGetLastError();
	    if (err != WSAENOTSOCK) {
		(void)close(fd);
		errno = err;
		return EOF;
	    }
	}
    }
    return close(fd);
}

d428 1
a428 1
    osf = TO_SOCKET(win32_fileno(pf));/* Get it now before it's gone! */
d435 1
a435 1
            _set_osfhnd(win32_fileno(pf), INVALID_HANDLE_VALUE);
d454 1
a454 1
my_fstat(int fd, Stat_t *sbufptr)
d464 1
a464 4
    if (!wsock_started || IsWinNT()) {
#if defined(WIN64) || defined(USE_LARGE_FILES)
	return _fstati64(fd, sbufptr);
#else
a465 2
#endif
    }
d484 1
a484 1
	    sbufptr->st_size = (Off_t)0;
a487 3
#if defined(WIN64) || defined(USE_LARGE_FILES)
    return _fstati64(fd, sbufptr);
#else
a488 1
#endif
d539 1
a539 1
    dTHX;    
d552 1
a552 1
    dTHX; 
d565 1
a565 1
    dTHX;
d606 1
a606 1
    dTHX;
d613 1
a613 1
    dTHX;
d620 1
a620 1
    dTHX;
d627 1
a627 1
    dTHX;
d635 1
a635 1
    dTHX;
d643 1
a643 1
    dTHX;
d651 1
a651 1
    dTHX;
d659 1
a659 1
    dTHX;
d667 1
a667 1
    dTHX;
d675 1
a675 1
    dTHX;
d683 1
a683 1
    dTHX;
d691 1
a691 1
    dTHX;
d699 1
a699 1
    dTHX;
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d294 1
a294 1
    int i, fd, save_errno = errno;
a335 1
    errno = save_errno;
a336 1
    save_errno = errno;
a346 1
    errno = save_errno;
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@a499 3
#if defined(__BORLANDC__) /* buk */
	return win32_fstat(fd, sbufptr );
#else
a500 1
#endif
a527 3
#if defined(__BORLANDC__) /* buk */
    return win32_fstat(fd, sbufptr );
#else
a528 1
#endif
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@a18 2
#include <ws2spi.h>

d89 1
a89 1
    version = 0x2;
d93 1
a93 1
	Perl_croak_nocontext("Could not find version 2.0 of winsock dll\n");
d106 8
a401 64
#ifdef USE_SOCKETS_AS_HANDLES
#define WIN32_OPEN_SOCKET(af, type, protocol) open_ifs_socket(af, type, protocol)

void
convert_proto_info_w2a(WSAPROTOCOL_INFOW *in, WSAPROTOCOL_INFOA *out)
{
    Copy(in, out, 1, WSAPROTOCOL_INFOA);
    wcstombs(out->szProtocol, in->szProtocol, sizeof(out->szProtocol));
}

SOCKET
open_ifs_socket(int af, int type, int protocol)
{
    dTHX;
    char *s;
    unsigned long proto_buffers_len = 0;
    int error_code;
    SOCKET out = INVALID_SOCKET;

    if ((s = PerlEnv_getenv("PERL_ALLOW_NON_IFS_LSP")) && atoi(s))
        return WSASocket(af, type, protocol, NULL, 0, 0);

    if (WSCEnumProtocols(NULL, NULL, &proto_buffers_len, &error_code) == SOCKET_ERROR
        && error_code == WSAENOBUFS)
    {
	WSAPROTOCOL_INFOW *proto_buffers;
        int protocols_available = 0;       
 
        New(1, proto_buffers, proto_buffers_len / sizeof(WSAPROTOCOL_INFOW),
            WSAPROTOCOL_INFOW);

        if ((protocols_available = WSCEnumProtocols(NULL, proto_buffers, 
            &proto_buffers_len, &error_code)) != SOCKET_ERROR)
        {
            int i;
            for (i = 0; i < protocols_available; i++)
            {
                WSAPROTOCOL_INFOA proto_info;

                if ((af != AF_UNSPEC && af != proto_buffers[i].iAddressFamily)
                    || (type != proto_buffers[i].iSocketType)
                    || (protocol != 0 && protocol != proto_buffers[i].iProtocol))
                    continue;

                if ((proto_buffers[i].dwServiceFlags1 & XP1_IFS_HANDLES) == 0)
                    continue;

                convert_proto_info_w2a(&(proto_buffers[i]), &proto_info);

                out = WSASocket(af, type, protocol, &proto_info, 0, 0);
                break;
            }
        }

        Safefree(proto_buffers);
    }

    return out;
}

#else
#define WIN32_OPEN_SOCKET(af, type, protocol) socket(af, type, protocol)
#endif

d411 1
a411 2

    if((s = WIN32_OPEN_SOCKET(af, type, protocol)) == INVALID_SOCKET)
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d136 1
a136 1
    Newxz(fp, 1, FILE);	/* XXX leak, good thing this code isn't used */
d323 1
a323 1
	    FD_SET((unsigned)fd, &nrd);
d325 1
a325 1
	    FD_SET((unsigned)fd, &nwr);
d327 1
a327 1
	    FD_SET((unsigned)fd, &nex);
d424 1
a424 1
        Newx(proto_buffers, proto_buffers_len / sizeof(WSAPROTOCOL_INFOW),
d437 1
a437 2
                    || (protocol != 0 && proto_buffers[i].iProtocol != 0 &&
                        protocol != proto_buffers[i].iProtocol))
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d40 1
d45 1
d47 9
d101 14
d677 1
a677 1
    u_long u_long_arg; 
d679 1
a679 1
    
d685 1
a685 5
    /* mauke says using memcpy avoids alignment issues */
    memcpy(&u_long_arg, data, sizeof u_long_arg); 
    retval = ioctlsocket(TO_SOCKET(i), (long)u, &u_long_arg);
    memcpy(data, &u_long_arg, sizeof u_long_arg);
    
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d262 1
d264 1
a264 1
    FD_SET nrd, nwr, nex;
d278 13
d296 2
a297 2
	if (rd && PERL_FD_ISSET(i,rd)) {
	    fd = TO_SOCKET(i);
d299 1
a299 3
	}
	if (wr && PERL_FD_ISSET(i,wr)) {
	    fd = TO_SOCKET(i);
d301 1
a301 3
	}
	if (ex && PERL_FD_ISSET(i,ex)) {
	    fd = TO_SOCKET(i);
a302 1
	}
d306 1
a306 1
    SOCKET_TEST_ERROR(r = select(nfds, &nrd, &nwr, &nex, timeout));
d310 7
a316 15
	if (rd && PERL_FD_ISSET(i,rd)) {
	    fd = TO_SOCKET(i);
	    if (!FD_ISSET(fd, &nrd))
		PERL_FD_CLR(i,rd);
	}
	if (wr && PERL_FD_ISSET(i,wr)) {
	    fd = TO_SOCKET(i);
	    if (!FD_ISSET(fd, &nwr))
		PERL_FD_CLR(i,wr);
	}
	if (ex && PERL_FD_ISSET(i,ex)) {
	    fd = TO_SOCKET(i);
	    if (!FD_ISSET(fd, &nex))
		PERL_FD_CLR(i,ex);
	}
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d4 1
a4 1
 * 		Developed by hip communications inc.
a263 1
    bool just_sleep = TRUE;
d265 11
a284 1
            just_sleep = FALSE;
a288 1
            just_sleep = FALSE;
a292 1
            just_sleep = FALSE;
a293 12
    }

    /* winsock seems incapable of dealing with all three fd_sets being empty,
     * so do the (millisecond) sleep as a special case
     */
    if (just_sleep) {
	if (timeout)
	    Sleep(timeout->tv_sec  * 1000 +
		  timeout->tv_usec / 1000);	/* do the best we can */
	else
	    Sleep(UINT_MAX);
	return 0;
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d476 3
d507 3
d525 56
d803 2
a804 1
    if (s->s_proto && strlen(s->s_proto))
d807 1
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d32 7
a38 2
#define OPEN_SOCKET(x)	win32_open_osfhandle(x,O_RDWR|O_BINARY)
#define TO_SOCKET(x)	_get_osfhandle(x)
d71 1
d90 38
a127 3
/* in no sockets Win32 builds, this fowards to replacements in util.c, dTHX
 * is required
 */
a130 3
#ifdef MYSWAP
    dTHX;
#else
a131 1
#endif
a137 3
#ifdef MYSWAP
    dTHX;
#else
a138 1
#endif
a144 3
#ifdef MYSWAP
    dTHX;
#else
a145 1
#endif
a151 3
#ifdef MYSWAP
    dTHX;
#else
a152 1
#endif
d261 1
d323 3
d375 3
d436 4
d445 3
d450 1
a450 1
    if((s = open_ifs_socket(af, type, protocol)) == INVALID_SOCKET)
d454 1
d567 1
a567 1
    dTHXa(NULL);    
a571 1
        aTHXa(PERL_GET_THX);
d580 1
a580 1
    dTHXa(NULL); 
a584 1
        aTHXa(PERL_GET_THX);
d593 1
d638 2
a639 1
    win32_croak_not_implemented("endhostent");
d645 2
a646 1
    win32_croak_not_implemented("endnetent");
d652 2
a653 1
    win32_croak_not_implemented("endprotoent");
d659 2
a660 1
    win32_croak_not_implemented("endservent");
d667 2
a668 1
    win32_croak_not_implemented("getnetent");
d675 2
a676 1
    win32_croak_not_implemented("getnetbyname");
d683 2
a684 1
    win32_croak_not_implemented("getnetbyaddr");
d691 2
a692 1
    win32_croak_not_implemented("getprotoent");
d699 2
a700 1
    win32_croak_not_implemented("getservent");
d707 2
a708 1
    win32_croak_not_implemented("sethostent");
d715 2
a716 1
    win32_croak_not_implemented("setnetent");
d723 2
a724 1
    win32_croak_not_implemented("setprotoent");
d731 2
a732 1
    win32_croak_not_implemented("setservent");
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d45 1
a45 1
	    errno = get_last_socket_error();		\
a49 1
static int get_last_socket_error(void);
a55 4
#ifdef WIN32_DYN_IOINFO_SIZE
EXTERN_C Size_t w32_ioinfo_size;
#endif

a62 263
/* Translate WSAExxx values to corresponding Exxx values where possible. Not all
 * WSAExxx constants have corresponding Exxx constants in <errno.h> (even in
 * VC++ 2010 and above, which have expanded <errno.h> with more values), but
 * most missing constants are provided by win32/include/sys/errno2.h. The few
 * that are not are returned unchanged.
 *
 * The list of possible WSAExxx values used here comes from the MSDN page
 * titled "Windows Sockets Error Codes".
 *
 * (Note: Only the WSAExxx values are handled here; other WSAxxx values are
 * returned unchanged. The return value normally ends up in errno/$! and at
 * the Perl code level may be tested against the Exxx constants exported by
 * the Errno and POSIX modules, which have never handled the other WSAxxx
 * values themselves, apparently without any ill effect so far.)
 */
int
convert_wsa_error_to_errno(int wsaerr)
{
    switch (wsaerr) {
    case WSAEINTR:
	return EINTR;
    case WSAEBADF:
	return EBADF;
    case WSAEACCES:
	return EACCES;
    case WSAEFAULT:
	return EFAULT;
    case WSAEINVAL:
	return EINVAL;
    case WSAEMFILE:
	return EMFILE;
    case WSAEWOULDBLOCK:
	return EWOULDBLOCK;
    case WSAEINPROGRESS:
	return EINPROGRESS;
    case WSAEALREADY:
	return EALREADY;
    case WSAENOTSOCK:
	return ENOTSOCK;
    case WSAEDESTADDRREQ:
	return EDESTADDRREQ;
    case WSAEMSGSIZE:
	return EMSGSIZE;
    case WSAEPROTOTYPE:
	return EPROTOTYPE;
    case WSAENOPROTOOPT:
	return ENOPROTOOPT;
    case WSAEPROTONOSUPPORT:
	return EPROTONOSUPPORT;
    case WSAESOCKTNOSUPPORT:
	return ESOCKTNOSUPPORT;
    case WSAEOPNOTSUPP:
	return EOPNOTSUPP;
    case WSAEPFNOSUPPORT:
	return EPFNOSUPPORT;
    case WSAEAFNOSUPPORT:
	return EAFNOSUPPORT;
    case WSAEADDRINUSE:
	return EADDRINUSE;
    case WSAEADDRNOTAVAIL:
	return EADDRNOTAVAIL;
    case WSAENETDOWN:
	return ENETDOWN;
    case WSAENETUNREACH:
	return ENETUNREACH;
    case WSAENETRESET:
	return ENETRESET;
    case WSAECONNABORTED:
	return ECONNABORTED;
    case WSAECONNRESET:
	return ECONNRESET;
    case WSAENOBUFS:
	return ENOBUFS;
    case WSAEISCONN:
	return EISCONN;
    case WSAENOTCONN:
	return ENOTCONN;
    case WSAESHUTDOWN:
	return ESHUTDOWN;
    case WSAETOOMANYREFS:
	return ETOOMANYREFS;
    case WSAETIMEDOUT:
	return ETIMEDOUT;
    case WSAECONNREFUSED:
	return ECONNREFUSED;
    case WSAELOOP:
	return ELOOP;
    case WSAENAMETOOLONG:
	return ENAMETOOLONG;
    case WSAEHOSTDOWN:
	return WSAEHOSTDOWN;		/* EHOSTDOWN is not defined */
    case WSAEHOSTUNREACH:
	return EHOSTUNREACH;
    case WSAENOTEMPTY:
	return ENOTEMPTY;
    case WSAEPROCLIM:
	return EPROCLIM;
    case WSAEUSERS:
	return EUSERS;
    case WSAEDQUOT:
	return EDQUOT;
    case WSAESTALE:
	return ESTALE;
    case WSAEREMOTE:
	return EREMOTE;
    case WSAEDISCON:
	return WSAEDISCON;		/* EDISCON is not defined */
    case WSAENOMORE:
	return WSAENOMORE;		/* ENOMORE is not defined */
#ifdef WSAECANCELLED
    case WSAECANCELLED:			/* New in WinSock2 */
	return ECANCELED;
#endif
    case WSAEINVALIDPROCTABLE:
	return WSAEINVALIDPROCTABLE;	/* EINVALIDPROCTABLE is not defined */
    case WSAEINVALIDPROVIDER:
	return WSAEINVALIDPROVIDER;	/* EINVALIDPROVIDER is not defined */
    case WSAEPROVIDERFAILEDINIT:
	return WSAEPROVIDERFAILEDINIT;	/* EPROVIDERFAILEDINIT is not defined */
    case WSAEREFUSED:
	return WSAEREFUSED;		/* EREFUSED is not defined */
    }

    return wsaerr;
}

#ifdef ERRNO_HAS_POSIX_SUPPLEMENT
/* Translate Exxx values in the POSIX supplement range defined in VC++ 2010 and
 * above (EADDRINUSE <= err <= EWOULDBLOCK) to corresponding WSAExxx values. Not
 * all such Exxx constants have corresponding WSAExxx constants in <winsock*.h>;
 * we just use ERROR_INVALID_FUNCTION for those that are missing but do not
 * really expect to encounter them anyway in the context in which this function
 * is called.
 * Some versions of MinGW/gcc-4.8 and above also define most, but not all, of
 * these extra Exxx values. The missing ones are all cases for which there is no
 * corresponding WSAExxx constant anyway, so we simply omit the cases for them
 * here.
 * Other Exxx values (err < sys_nerr) are returned unchanged.
 */
int
convert_errno_to_wsa_error(int err)
{
    switch (err) {
    case EADDRINUSE:
	return WSAEADDRINUSE;
    case EADDRNOTAVAIL:
	return WSAEADDRNOTAVAIL;
    case EAFNOSUPPORT:
	return WSAEAFNOSUPPORT;
    case EALREADY:
	return WSAEALREADY;
#ifdef EBADMSG
    case EBADMSG:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ECANCELED:
#ifdef WSAECANCELLED
	return WSAECANCELLED;		/* New in WinSock2 */
#else
	return ERROR_INVALID_FUNCTION;
#endif
    case ECONNABORTED:
	return WSAECONNABORTED;
    case ECONNREFUSED:
	return WSAECONNREFUSED;
    case ECONNRESET:
	return WSAECONNRESET;
    case EDESTADDRREQ:
	return WSAEDESTADDRREQ;
    case EHOSTUNREACH:
	return WSAEHOSTUNREACH;
#ifdef EIDRM
    case EIDRM:				/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case EINPROGRESS:
	return WSAEINPROGRESS;
    case EISCONN:
	return WSAEISCONN;
    case ELOOP:
	return WSAELOOP;
    case EMSGSIZE:
	return WSAEMSGSIZE;
    case ENETDOWN:
	return WSAENETDOWN;
    case ENETRESET:
	return WSAENETRESET;
    case ENETUNREACH:
	return WSAENETUNREACH;
    case ENOBUFS:
	return WSAENOBUFS;
#ifdef ENODATA
    case ENODATA:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
#ifdef ENOLINK
    case ENOLINK:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
#ifdef ENOMSG
    case ENOMSG:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ENOPROTOOPT:
	return WSAENOPROTOOPT;
#ifdef ENOSR
    case ENOSR:				/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
#ifdef ENOSTR
    case ENOSTR:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ENOTCONN:
	return WSAENOTCONN;
#ifdef ENOTRECOVERABLE
    case ENOTRECOVERABLE:		/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ENOTSOCK:
	return WSAENOTSOCK;
    case ENOTSUP:
	return ERROR_INVALID_FUNCTION;
    case EOPNOTSUPP:
	return WSAEOPNOTSUPP;
#ifdef EOTHER
    case EOTHER:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case EOVERFLOW:
	return ERROR_INVALID_FUNCTION;
    case EOWNERDEAD:
	return ERROR_INVALID_FUNCTION;
    case EPROTO:
	return ERROR_INVALID_FUNCTION;
    case EPROTONOSUPPORT:
	return WSAEPROTONOSUPPORT;
    case EPROTOTYPE:
	return WSAEPROTOTYPE;
#ifdef ETIME
    case ETIME:				/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case ETIMEDOUT:
	return WSAETIMEDOUT;
#ifdef ETXTBSY
    case ETXTBSY:			/* Not defined in gcc-4.8.0 */
	return ERROR_INVALID_FUNCTION;
#endif
    case EWOULDBLOCK:
	return WSAEWOULDBLOCK;
    }

    return err;
}
#endif /* ERRNO_HAS_POSIX_SUPPLEMENT */

static int
get_last_socket_error(void)
{
    return convert_wsa_error_to_errno(WSAGetLastError());
}

d84 2
a85 2
/* in no sockets Win32 builds, these use the inline functions defined in
 * perl.h
d90 3
a92 1
#ifndef WIN32_NO_SOCKETS
d101 3
a103 1
#ifndef WIN32_NO_SOCKETS
d112 3
a114 1
#ifndef WIN32_NO_SOCKETS
d123 3
a125 1
#ifndef WIN32_NO_SOCKETS
d412 1
a412 1
	errno = get_last_socket_error();
d436 2
a437 4
	    assert(_osfhnd(fd) == osf); /* catch a bad ioinfo struct def */
	    /* don't close freed handle */
	    _set_osfhnd(fd, INVALID_HANDLE_VALUE);
	    return close(fd);
d440 2
a441 2
	    err = get_last_socket_error();
	    if (err != ENOTSOCK) {
d464 2
a465 4
	    assert(_osfhnd(win32_fileno(pf)) == osf); /* catch a bad ioinfo struct def */
	    /* don't close freed handle */
	    _set_osfhnd(win32_fileno(pf), INVALID_HANDLE_VALUE);
	    return fclose(pf);
d468 2
a469 2
	    err = get_last_socket_error();
	    if (err != ENOTSOCK) {
d569 1
a569 2
	int err = get_last_socket_error();
	if (err == ENOTSOCK) {
d573 1
a573 1
	errno = err;
@


