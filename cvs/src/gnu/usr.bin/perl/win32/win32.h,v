head	1.15;
access;
symbols
	OPENBSD_6_2:1.15.0.2
	OPENBSD_6_2_BASE:1.15
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.4
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.12.0.2
	OPENBSD_5_7_BASE:1.12
	PERL_5_20_1:1.1.1.11
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2017.02.05.00.32.22;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	cxJ08BvJA9Pt2PTM;

1.14
date	2016.07.03.01.08.05;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	GzHqjSTnBjdF7Wcw;

1.13
date	2015.04.25.19.14.49;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	XRK22kO4se3v2i2I;

1.12
date	2014.11.17.20.57.08;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	QP75iYx42Uo7mMxO;

1.11
date	2014.03.24.15.05.34;	author afresh1;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.25.20.41.01;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.07.11;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.22;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.15;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.52;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.36.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.09.06;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.52.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.08.06.45;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.42.16;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.11.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.26.19;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.14;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.38;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.59;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.19.06;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.48.45;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.09.45;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.13;	author afresh1;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.11.17.20.53.21;	author afresh1;	state Exp;
branches;
next	1.1.1.12;
commitid	B31cAbBIXiCqnL97;

1.1.1.12
date	2015.04.25.19.10.51;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	Wpcs5S8qILgEZC7F;

1.1.1.13
date	2017.08.14.13.46.27;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.15
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* WIN32.H
 *
 * (c) 1995 Microsoft Corporation. All rights reserved.
 * 		Developed by hip communications inc.
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */
#ifndef  _INC_WIN32_PERL5
#define  _INC_WIN32_PERL5

#ifndef _WIN32_WINNT
#  define _WIN32_WINNT 0x0500     /* needed for CreateHardlink() etc. */
#endif

/* Win32 only optimizations for faster building */
#ifdef PERL_IS_MINIPERL
/* this macro will remove Winsock only on miniperl, PERL_IMPLICIT_SYS and
 * makedef.pl create dependencies that will keep Winsock linked in even with
 * this macro defined, even though sockets will be umimplemented from a script
 * level in full perl
 */
#  define WIN32_NO_SOCKETS
/* less I/O calls during each require */
#  define PERL_DISABLE_PMC

/* unnecessery for miniperl to lookup anything from an "installed" perl */
#  define WIN32_NO_REGISTRY

/* allow minitest to work */
#  define PERL_TEXTMODE_SCRIPTS
#endif

#ifdef WIN32_NO_SOCKETS
#  undef HAS_SOCKET
#  undef HAS_GETPROTOBYNAME
#  undef HAS_GETPROTOBYNUMBER
#  undef HAS_GETPROTOENT
#  undef HAS_GETNETBYNAME
#  undef HAS_GETNETBYADDR
#  undef HAS_GETNETENT
#  undef HAS_GETSERVBYNAME
#  undef HAS_GETSERVBYPORT
#  undef HAS_GETSERVENT
#  undef HAS_GETHOSTBYNAME
#  undef HAS_GETHOSTBYADDR
#  undef HAS_GETHOSTENT
#  undef HAS_SELECT
#  undef HAS_IOCTL
#  undef HAS_NTOHL
#  undef HAS_HTONL
#  undef HAS_HTONS
#  undef HAS_NTOHS
#  define WIN32SCK_IS_STDSCK
#endif

#if defined(PERL_IMPLICIT_SYS)
#  define DYNAMIC_ENV_FETCH
#  define HAS_GETENV_LEN
#  define prime_env_iter()
#  define WIN32IO_IS_STDIO		/* don't pull in custom stdio layer */
#  define WIN32SCK_IS_STDSCK		/* don't pull in custom wsock layer */
#  ifdef PERL_GLOBAL_STRUCT
#    error PERL_GLOBAL_STRUCT cannot be defined with PERL_IMPLICIT_SYS
#  endif
#endif

#ifdef __GNUC__
#  ifndef __int64		/* some versions seem to #define it already */
#    define __int64 long long
#  endif
#  define Win32_Winsock
#ifdef __cplusplus
/* Mingw32 gcc -xc++ objects to __attribute((unused)) at least */
#undef  PERL_UNUSED_DECL
#define PERL_UNUSED_DECL
#endif
#endif


/* Define DllExport akin to perl's EXT,
 * If we are in the DLL then Export the symbol,
 * otherwise import it.
 */

/* now even GCC supports __declspec() */
/* miniperl has no reason to export anything */
#if defined(PERL_IS_MINIPERL) && !defined(UNDER_CE) && defined(_MSC_VER)
#  define DllExport
#else
#  if defined(PERLDLL)
#    define DllExport __declspec(dllexport)
#  else
#    define DllExport __declspec(dllimport)
#  endif
#endif

/* The Perl APIs can only be called directly inside the perl5xx.dll.
 * All other code has to import them.  By declaring them as "dllimport"
 * we tell the compiler to generate an indirect call instruction and
 * avoid redirection through a call thunk.
 *
 * The XS code in the re extension is special, in that it redefines
 * core APIs locally, so don't mark them as "dllimport" because GCC
 * cannot handle this situation.
 */
#if !defined(PERLDLL) && !defined(PERL_EXT_RE_BUILD)
#  ifdef __cplusplus
#    define PERL_CALLCONV extern "C" __declspec(dllimport)
#    ifdef _MSC_VER
#      define PERL_CALLCONV_NO_RET extern "C" __declspec(dllimport) __declspec(noreturn)
#    endif
#  else
#    define PERL_CALLCONV __declspec(dllimport)
#    ifdef _MSC_VER
#      define PERL_CALLCONV_NO_RET __declspec(dllimport) __declspec(noreturn)
#    endif
#  endif
#else /* MSVC noreturn support inside the interp */
#  ifdef _MSC_VER
#    define PERL_CALLCONV_NO_RET __declspec(noreturn)
#  endif
#endif

#ifdef _MSC_VER
#  define PERL_STATIC_NO_RET __declspec(noreturn) static
#  define PERL_STATIC_INLINE_NO_RET __declspec(noreturn) PERL_STATIC_INLINE
#endif

#define  WIN32_LEAN_AND_MEAN
#include <windows.h>

/*
 * Bug in winbase.h in mingw-w64 4.4.0-1 at least... they
 * do #define GetEnvironmentStringsA GetEnvironmentStrings and fail
 * to declare GetEnvironmentStringsA.
 */
#if defined(__MINGW64__) && defined(GetEnvironmentStringsA) && !defined(UNICODE)
#ifdef __cplusplus
extern "C" {
#endif
#undef GetEnvironmentStringsA
WINBASEAPI LPCH WINAPI GetEnvironmentStringsA(VOID);
#define GetEnvironmentStrings GetEnvironmentStringsA
#ifdef __cplusplus
}
#endif
#endif

#ifdef   WIN32_LEAN_AND_MEAN		/* C file is NOT a Perl5 original. */
#define  CONTEXT	PERL_CONTEXT	/* Avoid conflict of CONTEXT defs. */
#endif /*WIN32_LEAN_AND_MEAN */

#ifndef TLS_OUT_OF_INDEXES
#define TLS_OUT_OF_INDEXES (DWORD)0xFFFFFFFF
#endif

#include <dirent.h>
#include <io.h>
#include <process.h>
#include <stdio.h>
#include <direct.h>
#include <stdlib.h>
#include <stddef.h>
#include <fcntl.h>
#ifndef EXT
#include "EXTERN.h"
#endif

struct tms {
	long	tms_utime;
	long	tms_stime;
	long	tms_cutime;
	long	tms_cstime;
};

#ifndef SYS_NMLN
#define SYS_NMLN	257
#endif

struct utsname {
    char sysname[SYS_NMLN];
    char nodename[SYS_NMLN];
    char release[SYS_NMLN];
    char version[SYS_NMLN];
    char machine[SYS_NMLN];
};

#ifndef START_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C
#  define END_EXTERN_C
#  define EXTERN_C
#endif
#endif

#define  STANDARD_C	1
#define  DOSISH		1		/* no escaping our roots */
#define  OP_BINARY	O_BINARY	/* mistake in in pp_sys.c? */

/* read() and write() aren't transparent for socket handles */
#ifndef WIN32_NO_SOCKETS
#  define PERL_SOCK_SYSREAD_IS_RECV
#  define PERL_SOCK_SYSWRITE_IS_SEND
#endif

#ifdef WIN32_NO_REGISTRY
/* the last _ in WIN32_NO_REGISTRY_M_ is like the _ in aTHX_ */
#  define WIN32_NO_REGISTRY_M_(x)
#else
#  define WIN32_NO_REGISTRY_M_(x) x,
#endif

#define PERL_NO_FORCE_LINK		/* no need for PL_force_link_funcs */

#define ENV_IS_CASELESS

#define PIPESOCK_MODE	"b"		/* pipes, sockets default to binmode */

/* access() mode bits */
#ifndef R_OK
#  define	R_OK	4
#  define	W_OK	2
#  define	X_OK	1
#  define	F_OK	0
#endif

/* for waitpid() */
#ifndef WNOHANG
#  define WNOHANG	1
#endif

#define PERL_GET_CONTEXT_DEFINED

/* Compiler-specific stuff. */

/* VC uses non-standard way to determine the size and alignment if bit-fields */
/* MinGW will compile with -mms-bitfields, so should use the same types */
#define PERL_BITFIELD8  unsigned char
#define PERL_BITFIELD16 unsigned short
#define PERL_BITFIELD32 unsigned int

#ifdef _MSC_VER			/* Microsoft Visual C++ */

#ifndef UNDER_CE
typedef long		uid_t;
typedef long		gid_t;
typedef unsigned short	mode_t;
#endif

#if _MSC_VER < 1800
#define isnan		_isnan	/* Defined already in VC++ 12.0 */
#endif
#ifdef UNDER_CE /* revisit what function this becomes celib vs corelibc, prv warning here*/
#  undef snprintf
#endif
#define snprintf	_snprintf
#define vsnprintf	_vsnprintf

/* on VC2003, msvcrt.lib is missing these symbols */
#if _MSC_VER >= 1300 && _MSC_VER < 1400
#  pragma intrinsic(_rotl64,_rotr64)
#endif

#  pragma warning(push)
#  pragma warning(disable:4756;disable:4056)
PERL_STATIC_INLINE
double S_Infinity() {
    /* this is a real C literal which can get further constant folded
       unlike using HUGE_VAL/_HUGE which are data symbol imports from the CRT
       and therefore can not by folded by VC, an example of constant
       folding INF is creating -INF */
    return (DBL_MAX+DBL_MAX);
}
#  pragma warning(pop)
#  define NV_INF S_Infinity()

/* selectany allows duplicate and unused data symbols to be removed by
   VC linker, if this were static, each translation unit will have its own,
   usually unused __PL_nan_u, if this were plain extern it will cause link
   to fail due to multiple definitions, since we dont know if we are being
   compiled as static or DLL XS, selectany simply always works, the cost of
   importing __PL_nan_u across DLL boundaries in size in the importing DLL
   will be more than the 8 bytes it will take up being in each XS DLL if
   that DLL actually uses __PL_nan_u */
extern const __declspec(selectany) union { unsigned __int64 __q; double __d; }
__PL_nan_u = { 0x7FF8000000000000UI64 };
#  define NV_NAN ((NV)__PL_nan_u.__d)

#endif /* _MSC_VER */

#ifdef __MINGW32__		/* Minimal Gnu-Win32 */

typedef long		uid_t;
typedef long		gid_t;
#ifndef _environ
#define _environ	environ
#endif
#define flushall	_flushall
#define fcloseall	_fcloseall
#ifndef isnan
#define isnan		_isnan	/* ...same libraries as MSVC */
#endif

#ifndef _O_NOINHERIT
#  define _O_NOINHERIT	0x0080
#  ifndef _NO_OLDNAMES
#    define O_NOINHERIT	_O_NOINHERIT
#  endif
#endif

/* <stdint.h>, pulled in by <io.h> as of mingw-runtime-3.3, typedef's
 * (u)intptr_t but doesn't set the _(U)INTPTR_T_DEFINED defines */
#ifdef _STDINT_H
#  ifndef _INTPTR_T_DEFINED
#    define _INTPTR_T_DEFINED
#  endif
#  ifndef _UINTPTR_T_DEFINED
#    define _UINTPTR_T_DEFINED
#  endif
#endif

#ifndef CP_UTF8
#  define CP_UTF8	65001
#endif

#endif /* __MINGW32__ */

#ifndef _INTPTR_T_DEFINED
typedef int		intptr_t;
#  define _INTPTR_T_DEFINED
#endif

#ifndef _UINTPTR_T_DEFINED
typedef unsigned int	uintptr_t;
#  define _UINTPTR_T_DEFINED
#endif

START_EXTERN_C

/* For UNIX compatibility. */

#ifdef PERL_CORE
extern  uid_t	getuid(void);
extern  gid_t	getgid(void);
extern  uid_t	geteuid(void);
extern  gid_t	getegid(void);
extern  int	setuid(uid_t uid);
extern  int	setgid(gid_t gid);
extern  int	kill(int pid, int sig);
#ifndef USE_PERL_SBRK
extern  void	*sbrk(ptrdiff_t need);
#  define HAS_SBRK_PROTO
#endif
extern	char *	getlogin(void);
extern	int	chown(const char *p, uid_t o, gid_t g);
#if !defined(__MINGW64_VERSION_MAJOR) || __MINGW64_VERSION_MAJOR < 4
extern  int	mkstemp(const char *path);
#endif
#endif

#undef	 Stat
#define  Stat		win32_stat

#undef   init_os_extras
#define  init_os_extras Perl_init_os_extras

DllExport void		Perl_win32_init(int *argcp, char ***argvp);
DllExport void		Perl_win32_term(void);
DllExport void		Perl_init_os_extras(void);
DllExport void		win32_str_os_error(void *sv, DWORD err);
DllExport int		RunPerl(int argc, char **argv, char **env);

typedef struct {
    HANDLE	childStdIn;
    HANDLE	childStdOut;
    HANDLE	childStdErr;
    /*
     * the following correspond to the fields of the same name
     * in the STARTUPINFO structure. Embedders can use these to
     * control the spawning process' look.
     * Example - to hide the window of the spawned process:
     *    dwFlags = STARTF_USESHOWWINDOW;
     *	  wShowWindow = SW_HIDE;
     */
    DWORD	dwFlags;
    DWORD	dwX;
    DWORD	dwY;
    DWORD	dwXSize;
    DWORD	dwYSize;
    DWORD	dwXCountChars;
    DWORD	dwYCountChars;
    DWORD	dwFillAttribute;
    WORD	wShowWindow;
} child_IO_table;

DllExport void		win32_get_child_IO(child_IO_table* ptr);
DllExport HWND		win32_create_message_window(void);
DllExport int		win32_async_check(pTHX);

extern int		my_fclose(FILE *);
extern char *		win32_get_privlib(WIN32_NO_REGISTRY_M_(const char *pl) STRLEN *const len);
extern char *		win32_get_sitelib(const char *pl, STRLEN *const len);
extern char *		win32_get_vendorlib(const char *pl, STRLEN *const len);

#ifdef PERL_IMPLICIT_SYS
extern void		win32_delete_internal_host(void *h);
#endif

extern int		win32_get_errno(int err);

extern const char * const		staticlinkmodules[];

END_EXTERN_C

typedef  char *		caddr_t;	/* In malloc.c (core address). */

/*
 * handle socket stuff, assuming socket is always available
 */
#include <sys/socket.h>
#include <netdb.h>

#ifdef MYMALLOC
#define EMBEDMYMALLOC	/**/
/* #define USE_PERL_SBRK	/ **/
/* #define PERL_SBRK_VIA_MALLOC	/ **/
#endif

#ifdef PERL_TEXTMODE_SCRIPTS
#  define PERL_SCRIPT_MODE		"r"
#else
#  define PERL_SCRIPT_MODE		"rb"
#endif

/*
 * Now Win32 specific per-thread data stuff
 */

/* Leave the first couple ids after WM_USER unused because they
 * might be used by an embedding application, and on Windows
 * version before 2000 we might end up eating those messages
 * if they were not meant for us.
 */
#define WM_USER_MIN     (WM_USER+30)
#define WM_USER_MESSAGE (WM_USER_MIN)
#define WM_USER_KILL    (WM_USER_MIN+1)
#define WM_USER_MAX     (WM_USER_MIN+1)

struct thread_intern {
    /* XXX can probably use one buffer instead of several */
    char		Wstrerror_buffer[512];
    struct servent	Wservent;
    char		Wgetlogin_buffer[128];
    int			Winit_socktype;
    char		Wcrypt_buffer[30];
#    ifdef USE_RTL_THREAD_API
    void *		retv;	/* slot for thread return value */
#    endif
    BOOL               Wuse_showwindow;
    WORD               Wshowwindow;
};

#define HAVE_INTERP_INTERN
typedef struct {
    long	num;
    DWORD	pids[MAXIMUM_WAIT_OBJECTS];
    HANDLE	handles[MAXIMUM_WAIT_OBJECTS];
} child_tab;

#ifdef USE_ITHREADS
typedef struct {
    long	num;
    DWORD	pids[MAXIMUM_WAIT_OBJECTS];
    HANDLE	handles[MAXIMUM_WAIT_OBJECTS];
    HWND	message_hwnds[MAXIMUM_WAIT_OBJECTS];
    char        sigterm[MAXIMUM_WAIT_OBJECTS];
} pseudo_child_tab;
#endif

#ifndef Sighandler_t
typedef Signal_t (*Sighandler_t) (int);
#define Sighandler_t	Sighandler_t
#endif

struct interp_intern {
    char *	perlshell_tokens;
    char **	perlshell_vec;
    long	perlshell_items;
    struct av *	fdpid;
    child_tab *	children;
#ifdef USE_ITHREADS
    DWORD	pseudo_id;
    pseudo_child_tab * pseudo_children;
#endif
    void *	internal_host;
    struct thread_intern	thr_intern;
    HWND        message_hwnd;
    UINT	timerid;
    unsigned 	poll_count;
    Sighandler_t sigtable[SIG_SIZE];
    bool sloppystat;
};

#define WIN32_POLL_INTERVAL 32768
#define PERL_ASYNC_CHECK() if (w32_do_async || PL_sig_pending) win32_async_check(aTHX)

#define w32_perlshell_tokens	(PL_sys_intern.perlshell_tokens)
#define w32_perlshell_vec	(PL_sys_intern.perlshell_vec)
#define w32_perlshell_items	(PL_sys_intern.perlshell_items)
#define w32_fdpid		(PL_sys_intern.fdpid)
#define w32_children		(PL_sys_intern.children)
#define w32_num_children	(w32_children->num)
#define w32_child_pids		(w32_children->pids)
#define w32_child_handles	(w32_children->handles)
#define w32_pseudo_id		(PL_sys_intern.pseudo_id)
#define w32_pseudo_children	(PL_sys_intern.pseudo_children)
#define w32_num_pseudo_children		(w32_pseudo_children->num)
#define w32_pseudo_child_pids		(w32_pseudo_children->pids)
#define w32_pseudo_child_handles	(w32_pseudo_children->handles)
#define w32_pseudo_child_message_hwnds	(w32_pseudo_children->message_hwnds)
#define w32_pseudo_child_sigterm	(w32_pseudo_children->sigterm)
#define w32_internal_host		(PL_sys_intern.internal_host)
#define w32_timerid			(PL_sys_intern.timerid)
#define w32_message_hwnd		(PL_sys_intern.message_hwnd)
#define w32_sighandler			(PL_sys_intern.sigtable)
#define w32_poll_count			(PL_sys_intern.poll_count)
#define w32_do_async			(w32_poll_count++ > WIN32_POLL_INTERVAL)
#define w32_strerror_buffer	(PL_sys_intern.thr_intern.Wstrerror_buffer)
#define w32_getlogin_buffer	(PL_sys_intern.thr_intern.Wgetlogin_buffer)
#define w32_crypt_buffer	(PL_sys_intern.thr_intern.Wcrypt_buffer)
#define w32_servent		(PL_sys_intern.thr_intern.Wservent)
#define w32_init_socktype	(PL_sys_intern.thr_intern.Winit_socktype)
#define w32_use_showwindow	(PL_sys_intern.thr_intern.Wuse_showwindow)
#define w32_showwindow	(PL_sys_intern.thr_intern.Wshowwindow)
#define w32_sloppystat	(PL_sys_intern.sloppystat)

#ifdef USE_ITHREADS
void win32_wait_for_children(pTHX);
#  define PERL_WAIT_FOR_CHILDREN win32_wait_for_children(aTHX)
#endif

#ifdef PERL_CORE
/* C doesn't like repeat struct definitions */
#if defined(__MINGW32__) && (__MINGW32_MAJOR_VERSION>=3)
#undef _CRTIMP
#endif
#ifndef _CRTIMP
#define _CRTIMP __declspec(dllimport)
#endif


/* VV 2005 has multiple ioinfo struct definitions through VC 2005's release life
 * VC 2008-2012 have been stable but do not assume future VCs will have the
 * same ioinfo struct, just because past struct stability. If research is done
 * on the CRTs of future VS, the version check can be bumped up so the newer
 * VC uses a fixed ioinfo size.
 */
#if ! (_MSC_VER < 1400 || (_MSC_VER >= 1500 && _MSC_VER <= 1700) \
  || defined(__MINGW32__))
/* size of ioinfo struct is determined at runtime */
#  define WIN32_DYN_IOINFO_SIZE
#endif

#ifndef WIN32_DYN_IOINFO_SIZE
/*
 * Control structure for lowio file handles
 */
typedef struct {
    intptr_t osfhnd;/* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
    int lockinitflag;
    CRITICAL_SECTION lock;
/* this struct definition breaks ABI compatibility with
 * not using, cl.exe's native VS version specitfic CRT. */
#  if _MSC_VER >= 1400 && _MSC_VER < 1500
#    error "This ioinfo struct is incomplete for Visual C 2005"
#  endif
/* VC 2005 CRT has at least 3 different definitions of this struct based on the
 * CRT DLL's build number. */
#  if _MSC_VER >= 1500
#    ifndef _SAFECRT_IMPL
    /* Not used in the safecrt downlevel. We do not define them, so we cannot
     * use them accidentally */
    char textmode : 7;/* __IOINFO_TM_ANSI or __IOINFO_TM_UTF8 or __IOINFO_TM_UTF16LE */
    char unicode : 1; /* Was the file opened as unicode? */
    char pipech2[2];  /* 2 more peak ahead chars for UNICODE mode */
    __int64 startpos;      /* File position that matches buffer start */
    BOOL utf8translations; /* Buffer contains translations other than CRLF*/
    char dbcsBuffer;       /* Buffer for the lead byte of dbcs when converting from dbcs to unicode */
    BOOL dbcsBufferUsed;   /* Bool for the lead byte buffer is used or not */
#    endif
#  endif
} ioinfo;
#else
typedef intptr_t ioinfo;
#endif

/*
 * Array of arrays of control structures for lowio files.
 */
EXTERN_C _CRTIMP ioinfo* __pioinfo[];

/*
 * Definition of IOINFO_L2E, the log base 2 of the number of elements in each
 * array of ioinfo structs.
 */
#define IOINFO_L2E	    5

/*
 * Definition of IOINFO_ARRAY_ELTS, the number of elements in ioinfo array
 */
#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)

/*
 * Access macros for getting at an ioinfo struct and its fields from a
 * file handle
 */
#ifdef WIN32_DYN_IOINFO_SIZE
#  define _pioinfo(i) ((intptr_t *) \
     (((Size_t)__pioinfo[(i) >> IOINFO_L2E])/* * to head of array ioinfo [] */\
      /* offset to the head of a particular ioinfo struct */ \
      + (((i) & (IOINFO_ARRAY_ELTS - 1)) * w32_ioinfo_size)) \
   )
/* first slice of ioinfo is always the OS handle */
#  define _osfhnd(i)  (*(_pioinfo(i)))
#else
#  define _pioinfo(i) (__pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - 1)))
#  define _osfhnd(i)  (_pioinfo(i)->osfhnd)
#endif

/* since we are not doing a dup2(), this works fine */
#  define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = (intptr_t)osfh)
#endif /* PERL_CORE */

/* IO.xs and POSIX.xs define PERLIO_NOT_STDIO to 1 */
#if defined(PERL_EXT_IO) || defined(PERL_EXT_POSIX)
#undef  PERLIO_NOT_STDIO
#endif
#define PERLIO_NOT_STDIO 0

#define EXEC_ARGV_CAST(x) ((const char *const *) x)

DllExport void *win32_signal_context(void);
#define PERL_GET_SIG_CONTEXT win32_signal_context()

#ifdef UNDER_CE
#define Win_GetModuleHandle   XCEGetModuleHandleA
#define Win_GetProcAddress    XCEGetProcAddressA
#define Win_GetModuleFileName XCEGetModuleFileNameA
#define Win_CreateSemaphore   CreateSemaphoreW
#else
#define Win_GetModuleHandle   GetModuleHandle
#define Win_GetProcAddress    GetProcAddress
#define Win_GetModuleFileName GetModuleFileName
#define Win_CreateSemaphore   CreateSemaphore
#endif

#endif /* _INC_WIN32_PERL5 */

@


1.14
log
@Update to perl 5.20.3

OK bluhm@@
@
text
@d26 6
a65 3
#  define win32_get_privlib PerlEnv_lib_path
#  define win32_get_sitelib PerlEnv_sitelib_path
#  define win32_get_vendorlib PerlEnv_vendorlib_path
d212 7
a255 2
#pragma  warning(disable: 4102)	/* "unreferenced label" */

d270 25
d404 1
d407 1
a407 1
extern char *		win32_get_privlib(const char *pl, STRLEN *const len);
d507 1
a509 2
DllExport int win32_async_check(pTHX);

d541 1
d580 1
a580 1
/* this struct defintion breaks ABI compatibility with
d585 1
a585 1
/* VC 2005 CRT has atleast 3 different definitions of this struct based on the
a646 8

#include "perlio.h"

/*
 * This provides a layer of functions and macros to ensure extensions will
 * get to use the same RTL functions as the core.
 */
#include "win32iop.h"
@


1.13
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d329 1
d331 1
@


1.12
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@a256 5
#ifdef USING_MSVC6
/* VC6 has broken NaN semantics: NaN == NaN returns true instead of false */
#define NAN_COMPARE_BROKEN 1
#endif

d395 2
a396 2
/* #define USE_PERL_SBRK	/**/
/* #define PERL_SBRK_VIA_MALLOC	/**/
@


1.11
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d16 1
d24 2
d248 6
a253 1
#define isnan		_isnan
d257 1
a257 1
#if _MSC_VER < 1300
d262 5
a327 1
extern  int	killpg(int pid, int sig);
d384 2
d516 94
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d16 32
d81 3
a83 4

#if defined(PERLDLL)
#define DllExport
/*#define DllExport __declspec(dllexport)*/	/* noises with VC5+sp3 */
d85 5
a89 1
#define DllExport __declspec(dllimport)
d104 3
d109 7
d119 5
a199 4
/* Define USE_SOCKETS_AS_HANDLES to enable emulation of windows sockets as
 * real filehandles. XXX Should always be defined (the other version is untested) */
#define USE_SOCKETS_AS_HANDLES

d201 4
a204 2
#define PERL_SOCK_SYSREAD_IS_RECV
#define PERL_SOCK_SYSWRITE_IS_SEND
a207 6
/* Define PERL_WIN32_SOCK_DLOAD to have Perl dynamically load the winsock
   DLL when needed. Don't use if your compiler supports delayloading (ie, VC++ 6.0)
	-- BKS 5-29-2000 */
#if !(defined(_M_IX86) && _MSC_VER >= 1200)
#define PERL_WIN32_SOCK_DLOAD
#endif
a211 8
#ifndef VER_PLATFORM_WIN32_WINDOWS	/* VC-2.0 headers don't have this */
#define VER_PLATFORM_WIN32_WINDOWS	1
#endif

#ifndef FILE_SHARE_DELETE		/* VC-4.0 headers don't have this */
#define FILE_SHARE_DELETE		0x00000004
#endif

a228 1
#if defined(_MSC_VER) || defined(__MINGW32__)
d230 4
a233 5
/* MinGW will compiler with -mms-bitfields, so should use the same types */
#  define PERL_BITFIELD8  unsigned char
#  define PERL_BITFIELD16 unsigned short
#  define PERL_BITFIELD32 unsigned int
#endif
a244 3
/* Visual C thinks that a pointer to a member variable is 16 bytes in size. */
#define PERL_MEMBER_PTR_SIZE	16

a286 3
#endif /* __MINGW32__ */

/* both GCC/Mingw32 and MSVC++ 4.0 are missing this, so we put it here */
d291 1
a291 1
/* compatibility stuff for other compilers goes here */
d307 1
d323 1
a362 3
#ifndef USE_SOCKETS_AS_HANDLES
extern FILE *		my_fdopen(int, char *);
#endif
d372 1
a372 1
extern char *		staticlinkmodules[];
a414 1
#    ifdef USE_SOCKETS_AS_HANDLES
a415 1
#    endif
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d13 1
a13 1
#  define _WIN32_WINNT 0x0400     /* needed for TryEnterCriticalSection() etc. */
d44 1
a44 2
 * If we are in the DLL or mimicing the DLL for Win95 work round
 * then Export the symbol,
d50 1
a50 1
#if defined(PERLDLL) || defined(WIN95FIX)
d57 17
a159 11
/* Define USE_FIXED_OSFHANDLE to fix MSVCRT's _open_osfhandle() on W95.
   It now uses some black magic to work seamlessly with the DLL CRT and
   works with MSVC++ 4.0+ or GCC/Mingw32
	-- BKS 1-24-2000
   Only use this fix for VC++ 6.x or earlier (and for GCC, which we assume
   uses MSVCRT.DLL). Later versions use MSVCR70.dll, MSVCR71.dll, etc, which
   do not require the fix. */
#if (defined(_M_IX86) && _MSC_VER >= 1000 && _MSC_VER <= 1200) || defined(__MINGW32__)
#define USE_FIXED_OSFHANDLE
#endif

a202 32
#ifdef __BORLANDC__		/* Borland C++ */

#if (__BORLANDC__ <= 0x520)
#define _access access
#define _chdir chdir
#endif

#define _getpid getpid
#define wcsicmp _wcsicmp
#include <sys/types.h>

#ifndef DllMain
#define DllMain DllEntryPoint
#endif

#pragma warn -8004	/* "'foo' is assigned a value that is never used" */
#pragma warn -8008	/* "condition is always true/false" */
#pragma warn -8012	/* "comparing signed and unsigned values" */
#pragma warn -8027	/* "functions containing %s are not expanded inline" */
#pragma warn -8057	/* "parameter 'foo' is never used" */
#pragma warn -8060	/* "possibly incorrect assignment" */
#pragma warn -8066	/* "unreachable code" */
#pragma warn -8071	/* "conversion may lose significant digits" */
#pragma warn -8080	/* "'foo' is declared but never used" */

/* Borland C thinks that a pointer to a member variable is 12 bytes in size. */
#define PERL_MEMBER_PTR_SIZE	12

#define isnan		_isnan

#endif

a338 1
extern int		my_fstat(int fd, Stat_t *sbufptr);
a341 2
extern int		IsWin95(void);
extern int		IsWinNT(void);
a392 1
#    ifdef HAVE_DES_FCRYPT
a393 1
#    endif
d414 1
d460 1
d476 2
a477 64
#  define PERL_WAIT_FOR_CHILDREN \
    STMT_START {							\
	if (w32_pseudo_children && w32_num_pseudo_children) {		\
	    long children = w32_num_pseudo_children;			\
	    WaitForMultipleObjects(children,				\
				   w32_pseudo_child_handles,		\
				   TRUE, INFINITE);			\
	    while (children)						\
		CloseHandle(w32_pseudo_child_handles[--children]);	\
	}								\
    } STMT_END
#endif

#if defined(USE_FIXED_OSFHANDLE) || defined(PERL_MSVCRT_READFIX)
#ifdef PERL_CORE

/* C doesn't like repeat struct definitions */
#if defined(__MINGW32__) && (__MINGW32_MAJOR_VERSION>=3)
#undef _CRTIMP
#endif
#ifndef _CRTIMP
#define _CRTIMP __declspec(dllimport)
#endif

/*
 * Control structure for lowio file handles
 */
typedef struct {
    intptr_t osfhnd;/* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
    int lockinitflag;
    CRITICAL_SECTION lock;
} ioinfo;


/*
 * Array of arrays of control structures for lowio files.
 */
EXTERN_C _CRTIMP ioinfo* __pioinfo[];

/*
 * Definition of IOINFO_L2E, the log base 2 of the number of elements in each
 * array of ioinfo structs.
 */
#define IOINFO_L2E	    5

/*
 * Definition of IOINFO_ARRAY_ELTS, the number of elements in ioinfo array
 */
#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)

/*
 * Access macros for getting at an ioinfo struct and its fields from a
 * file handle
 */
#define _pioinfo(i) (__pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - 1)))
#define _osfhnd(i)  (_pioinfo(i)->osfhnd)
#define _osfile(i)  (_pioinfo(i)->osfile)
#define _pipech(i)  (_pioinfo(i)->pipech)

/* since we are not doing a dup2(), this works fine */
#define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = (intptr_t)osfh)
#endif
a494 11

#if !defined(ECONNABORTED) && defined(WSAECONNABORTED)
#define ECONNABORTED WSAECONNABORTED
#endif
#if !defined(ECONNRESET) && defined(WSAECONNRESET)
#define ECONNRESET WSAECONNRESET
#endif
#if !defined(EAFNOSUPPORT) && defined(WSAEAFNOSUPPORT)
#define EAFNOSUPPORT WSAEAFNOSUPPORT
#endif
/* Why not needed for ECONNREFUSED? --abe */
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d4 1
a4 1
 * 		Developed by hip communications inc., http://info.hip.com/info/
d61 17
d190 8
d263 1
d265 1
d367 3
a369 3
extern char *		win32_get_privlib(const char *pl);
extern char *		win32_get_sitelib(const char *pl);
extern char *		win32_get_vendorlib(const char *pl);
@


1.7
log
@merge in perl 5.8.8
@
text
@d130 5
a134 2
	-- BKS 1-24-2000 */
#if (defined(_M_IX86) && _MSC_VER >= 1000) || defined(__MINGW32__)
d188 9
a196 8
#pragma warn -ccc	/* "condition is always true/false" */
#pragma warn -rch	/* "unreachable code" */
#pragma warn -sig	/* "conversion may lose significant digits" */
#pragma warn -pia	/* "possibly incorrect assignment" */
#pragma warn -par	/* "parameter 'foo' is never used" */
#pragma warn -aus	/* "'foo' is assigned a value that is never used" */
#pragma warn -use	/* "'foo' is declared but never used" */
#pragma warn -csu	/* "comparing signed and unsigned values" */
d207 1
d211 2
d219 7
d288 1
d333 1
a344 1
extern void		win32_argv2utf8(int argc, char** argv);
a367 4
#if defined(PERLDLL) && !defined(PERL_CORE)
#define PERL_CORE
#endif

d378 10
a405 6
#ifdef USE_5005THREADS
#  ifndef USE_DECLSPEC_THREAD
#    define HAVE_THREAD_INTERN
#  endif /* !USE_DECLSPEC_THREAD */
#endif /* USE_5005THREADS */

d413 9
d435 1
a435 1
    child_tab *	pseudo_children;
a437 1
#ifndef USE_5005THREADS
d439 1
a439 1
#endif
d463 1
d466 1
d470 7
a476 33
#ifdef USE_5005THREADS
#  define w32_strerror_buffer	(thr->i.Wstrerror_buffer)
#  define w32_getlogin_buffer	(thr->i.Wgetlogin_buffer)
#  define w32_crypt_buffer	(thr->i.Wcrypt_buffer)
#  define w32_servent		(thr->i.Wservent)
#  define w32_init_socktype	(thr->i.Winit_socktype)
#  define w32_use_showwindow	(thr->i.Wuse_showwindow)
#  define w32_showwindow	(thr->i.Wshowwindow)
#else
#  define w32_strerror_buffer	(PL_sys_intern.thr_intern.Wstrerror_buffer)
#  define w32_getlogin_buffer	(PL_sys_intern.thr_intern.Wgetlogin_buffer)
#  define w32_crypt_buffer	(PL_sys_intern.thr_intern.Wcrypt_buffer)
#  define w32_servent		(PL_sys_intern.thr_intern.Wservent)
#  define w32_init_socktype	(PL_sys_intern.thr_intern.Winit_socktype)
#  define w32_use_showwindow	(PL_sys_intern.thr_intern.Wuse_showwindow)
#  define w32_showwindow	(PL_sys_intern.thr_intern.Wshowwindow)
#endif /* USE_5005THREADS */

/* UNICODE<>ANSI translation helpers */
/* Use CP_ACP when mode is ANSI */
/* Use CP_UTF8 when mode is UTF8 */

#define A2WHELPER_LEN(lpa, alen, lpw, nBytes)\
    (lpw[0] = 0, MultiByteToWideChar((IN_BYTES) ? CP_ACP : CP_UTF8, 0, \
				    lpa, alen, lpw, (nBytes/sizeof(WCHAR))))
#define A2WHELPER(lpa, lpw, nBytes)	A2WHELPER_LEN(lpa, -1, lpw, nBytes)

#define W2AHELPER_LEN(lpw, wlen, lpa, nChars)\
    (lpa[0] = '\0', WideCharToMultiByte((IN_BYTES) ? CP_ACP : CP_UTF8, 0, \
				       lpw, wlen, (LPSTR)lpa, nChars,NULL,NULL))
#define W2AHELPER(lpw, lpa, nChars)	W2AHELPER_LEN(lpw, -1, lpa, nChars)

#define USING_WIDE() (0)
d574 12
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d233 11
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d143 2
d278 1
d466 1
a466 1
#define USING_WIDE() (PL_widesyscalls && PerlEnv_os_id() == VER_PLATFORM_WIN32_NT)
d486 3
d554 3
d560 1
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 * (c) 1995 Microsoft Corporation. All rights reserved. 
d16 1
a16 1
#if defined(PERL_OBJECT) || defined(PERL_IMPLICIT_SYS) || defined(PERL_CAPI)
a17 1
#  define ENV_HV_NAME "___ENV_HV_NAME___"
d35 5
d42 2
a43 1
/* Define DllExport akin to perl's EXT, 
d45 1
a45 1
 * then Export the symbol, 
a50 3
#if defined(PERL_OBJECT)
#define DllExport
#else
d54 1
a54 1
#else 
a56 1
#endif
d75 1
d107 2
a108 2
#  define START_EXTERN_C 
#  define END_EXTERN_C 
a191 5
/* Borland is picky about a bare member function name used as its ptr */
#ifdef PERL_OBJECT
#  define MEMBER_TO_FPTR(name)	&(name)
#endif

d204 1
a204 1
#pragma  warning(disable: 4018 4035 4101 4102 4244 4245 4761)
a223 4
#ifdef PERL_OBJECT
#  define MEMBER_TO_FPTR(name)	&(name)
#endif

d240 4
d245 4
a248 38
#if !defined(PERL_OBJECT) && defined(PERL_CAPI) && defined(PERL_MEMBER_PTR_SIZE)
#  define STRUCT_MGVTBL_DEFINITION \
struct mgvtbl {								\
    union {								\
	int	    (CPERLscope(*svt_get))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem1[PERL_MEMBER_PTR_SIZE];		\
    };									\
    union {								\
	int	    (CPERLscope(*svt_set))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem2[PERL_MEMBER_PTR_SIZE];		\
    };									\
    union {								\
	U32	    (CPERLscope(*svt_len))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem3[PERL_MEMBER_PTR_SIZE];		\
    };									\
    union {								\
	int	    (CPERLscope(*svt_clear))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem4[PERL_MEMBER_PTR_SIZE];		\
    };									\
    union {								\
	int	    (CPERLscope(*svt_free))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem5[PERL_MEMBER_PTR_SIZE];		\
    };									\
}

#  define BASEOP_DEFINITION \
    OP*		op_next;						\
    OP*		op_sibling;						\
    OP*		(CPERLscope(*op_ppaddr))(pTHX);				\
    char	handle_VC_problem[PERL_MEMBER_PTR_SIZE-sizeof(OP*)];	\
    PADOFFSET	op_targ;						\
    OPCODE	op_type;						\
    U16		op_seq;							\
    U8		op_flags;						\
    U8		op_private;

#endif /* !PERL_OBJECT && PERL_CAPI && PERL_MEMBER_PTR_SIZE */

d261 4
a264 1
extern  void	*sbrk(int need);
d267 1
d293 6
a298 6
    DWORD	dwX; 
    DWORD	dwY; 
    DWORD	dwXSize; 
    DWORD	dwYSize; 
    DWORD	dwXCountChars; 
    DWORD	dwYCountChars; 
d300 1
a300 1
    WORD	wShowWindow; 
d309 1
a309 4
extern int		my_fstat(int fd, struct stat *sbufptr);
extern int		do_aspawn(void *really, void **mark, void **sp);
extern int		do_spawn(char *cmd);
extern int		do_spawn_nowait(char *cmd);
d349 2
a350 2
/* 
 * Now Win32 specific per-thread data stuff 
d367 2
d371 1
a371 1
#ifdef USE_THREADS
d375 1
a375 1
#endif /* USE_THREADS */
d384 5
d400 1
a400 1
#ifndef USE_THREADS
d403 3
d408 4
d427 5
a431 1
#ifdef USE_THREADS
d437 2
d445 3
a447 1
#endif /* USE_THREADS */
d454 1
a454 1
    (lpw[0] = 0, MultiByteToWideChar((IN_BYTE) ? CP_ACP : CP_UTF8, 0, \
d459 1
a459 1
    (lpa[0] = '\0', WideCharToMultiByte((IN_BYTE) ? CP_ACP : CP_UTF8, 0, \
d491 1
a491 1
    long osfhnd;    /* underlying OS file HANDLE */
d525 1
a525 1
#define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = (long)osfh)
d529 8
d544 10
@


1.3
log
@perl-5.6.0 + local changes
@
text
@a124 5
/* if USE_WIN32_RTL_ENV is not defined, Perl uses direct Win32 calls
 * to read the environment, bypassing the runtime's (usually broken)
 * facilities for accessing the same.  See note in util.c/my_setenv(). */
/*#define USE_WIN32_RTL_ENV */

d133 6
d157 5
d168 1
d171 2
a188 2
#pragma warn -pro	/* "call to function with no prototype" */
#pragma warn -stu	/* "undefined structure 'foo'" */
d198 2
d212 2
d225 1
d309 1
a309 1
DllExport void		Perl_init_os_extras();
d342 1
d493 50
d548 2
@


1.2
log
@perl5.005_03 (stock)
@
text
@d12 5
a16 1
#ifdef PERL_OBJECT
d19 1
d22 1
d24 1
a24 1
#    error PERL_GLOBAL_STRUCT cannot be defined with PERL_OBJECT
d28 1
d32 3
a34 1
typedef long long __int64;
a35 10
/* GCC does not do __declspec() - render it a nop 
 * and turn on options to avoid importing data 
 */
#ifndef __declspec
#  define __declspec(x)
#endif
#  ifndef PERL_OBJECT
#    define PERL_GLOBAL_STRUCT
#    define MULTIPLICITY
#  endif
d44 2
d74 1
d86 12
d123 1
d130 5
a134 3
/* Define USE_FIXED_OSFHANDLE to fix VC's _open_osfhandle() on W95.
 * Can only enable it if not using the DLL CRT (it doesn't expose internals) */
#if defined(_MSC_VER) && !defined(_DLL) && defined(_M_IX86)
d148 10
d164 2
d181 1
a181 2

#define USE_RTL_WAIT	/* Borland has a working wait() */
d185 1
a185 1
#define FUNC_NAME_TO_PTR(name)	&(name)
d188 3
d197 1
a199 2
#ifndef PERL_OBJECT

d201 1
a201 45
#define STRUCT_MGVTBL_DEFINITION					\
struct mgvtbl {								\
    union {								\
	int	    (CPERLscope(*svt_get))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem1[16];				\
    };									\
    union {								\
	int	    (CPERLscope(*svt_set))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem2[16];				\
    };									\
    union {								\
	U32	    (CPERLscope(*svt_len))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem3[16];				\
    };									\
    union {								\
	int	    (CPERLscope(*svt_clear))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem4[16];				\
    };									\
    union {								\
	int	    (CPERLscope(*svt_free))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem5[16];				\
    };									\
}

#define BASEOP_DEFINITION		\
    OP*		op_next;		\
    OP*		op_sibling;		\
    OP*		(CPERLscope(*op_ppaddr))_((ARGSproto));		\
    char	handle_VC_problem[12];	\
    PADOFFSET	op_targ;		\
    OPCODE	op_type;		\
    U16		op_seq;			\
    U8		op_flags;		\
    U8		op_private;

#define UNION_ANY_DEFINITION union any {		\
    void*	any_ptr;				\
    I32		any_i32;				\
    IV		any_iv;					\
    long	any_long;				\
    void	(CPERLscope(*any_dptr)) _((void*));	\
    char	handle_VC_problem[16];			\
}

#endif /* PERL_OBJECT */
d216 1
a216 1
#define FUNC_NAME_TO_PTR(name)	&(name)
d226 5
a230 5
#ifndef _O_NOINHERIT
#  define _O_NOINHERIT	0x0080
#  ifndef _NO_OLDNAMES
#    define O_NOINHERIT	_O_NOINHERIT
#  endif
d233 38
a270 1
#endif /* __MINGW32__ */
d272 1
a272 1
/* compatibility stuff for other compilers goes here */
d297 1
a297 1
DllExport void		Perl_init_os_extras(void);
d299 26
d333 3
a335 3
extern char		do_exec(char *cmd);
extern char *		win32_get_privlib(char *pl);
extern char *		win32_get_sitelib(char *pl);
d338 5
d366 2
a367 3
#ifdef USE_BINMODE_SCRIPTS
#define PERL_SCRIPT_MODE "rb"
EXT void win32_strip_return(struct sv *sv);
d369 1
a369 24
#define PERL_SCRIPT_MODE "r"
#define win32_strip_return(sv) NOOP
#endif

#define HAVE_INTERP_INTERN
struct interp_intern {
    char *	w32_perlshell_tokens;
    char **	w32_perlshell_vec;
    long	w32_perlshell_items;
    struct av *	w32_fdpid;
#ifndef USE_RTL_WAIT
    long	w32_num_children;
    HANDLE	w32_child_pids[MAXIMUM_WAIT_OBJECTS];
#endif
};

#define w32_perlshell_tokens	(PL_sys_intern.w32_perlshell_tokens)
#define w32_perlshell_vec	(PL_sys_intern.w32_perlshell_vec)
#define w32_perlshell_items	(PL_sys_intern.w32_perlshell_items)
#define w32_fdpid		(PL_sys_intern.w32_fdpid)

#ifndef USE_RTL_WAIT
#  define w32_num_children	(PL_sys_intern.w32_num_children)
#  define w32_child_pids	(PL_sys_intern.w32_child_pids)
a375 4
#ifdef USE_THREADS
#  ifndef USE_DECLSPEC_THREAD
#    define HAVE_THREAD_INTERN

a380 1
    char		Ww32_perllib_root[MAX_PATH+1];
d391 4
d398 88
d487 1
@


1.1
log
@perl 5.004_04
@
text
@d12 44
a60 1
#define  index		strchr		/* Why 'index'? */
d63 4
d72 11
d84 48
a131 1
/* For UNIX compatibility. */
d133 1
a133 1
#ifdef __BORLANDC__
d143 16
a158 9
#pragma warn -ccc
#pragma warn -rch
#pragma warn -sig
#pragma warn -pia
#pragma warn -par
#pragma warn -aus
#pragma warn -use
#pragma warn -csu
#pragma warn -pro
d160 3
a162 1
#else
d166 1
d168 1
a168 1
#endif
d170 44
a213 6
extern  uid_t	getuid(void);
extern  gid_t	getgid(void);
extern  uid_t	geteuid(void);
extern  gid_t	getegid(void);
extern  int	setuid(uid_t uid);
extern  int	setgid(gid_t gid);
d215 1
a215 1
extern  int	kill(int pid, int sig);
d217 1
a217 1
extern  char	*staticlinkmodules[];
d219 1
a219 5
/* if USE_WIN32_RTL_ENV is not defined, Perl uses direct Win32 calls
 * to read the environment, bypassing the runtime's (usually broken)
 * facilities for accessing the same.  See note in util.c/my_setenv().
 */
/*#define USE_WIN32_RTL_ENV */
d221 4
a224 4
#ifndef USE_WIN32_RTL_ENV
#include <stdlib.h>
#ifndef EXT
#include "EXTERN.h"
d226 5
a230 3
#undef getenv
#define getenv win32_getenv
EXT char *win32_getenv(const char *name);
d233 6
a238 1
EXT void Perl_win32_init(int *argcp, char ***argvp);
d240 6
a245 3
#define USE_SOCKETS_AS_HANDLES
#ifndef USE_SOCKETS_AS_HANDLES
extern FILE *myfdopen(int, char *);
d247 1
a247 3
#undef fdopen
#define fdopen myfdopen
#endif	/* USE_SOCKETS_AS_HANDLES */
d249 1
a249 2
#define  STANDARD_C	1		/* Perl5 likes standard C. */
#define  DOSISH		1		/* Take advantage of DOSish code in Perl5. */
a250 1
#define  OP_BINARY	O_BINARY	/* Mistake in in pp_sys.c. */
d252 1
a252 2
#undef	 pipe
#define  pipe(fd)	win32_pipe((fd), 512, O_BINARY) /* the pipe call is a bit different */
d254 1
a254 2
#undef	 pause
#define  pause()	sleep((32767L << 16) + 32767)
d256 20
d277 12
a288 2
#undef	 times
#define  times	mytimes
d290 1
a290 9
#undef	 alarm
#define  alarm	myalarm

struct tms {
	long	tms_utime;
	long	tms_stime;
	long	tms_cutime;
	long	tms_cstime;
};
d292 1
a292 9
unsigned int sleep(unsigned int);
char *win32PerlLibPath(void);
char *win32SiteLibPath(void);
int mytimes(struct tms *timebuf);
unsigned int myalarm(unsigned int sec);
int do_aspawn(void* really, void** mark, void** arglast);
int do_spawn(char *cmd);
char do_exec(char *cmd);
void init_os_extras(void);
a296 7
 * Extension Library, only good for VC
 */

#define DllExport	__declspec(dllexport)
#define DllImport	__declspec(dllimport)

/*
a298 1

d302 4
a305 2
#ifdef _MSC_VER
#pragma  warning(disable: 4018 4035 4101 4102 4244 4245 4761)
d308 3
a310 2
int IsWin95(void);
int IsWinNT(void);
d312 28
a339 2
#ifndef VER_PLATFORM_WIN32_WINDOWS	/* VC-2.0 headers dont have this */
#define VER_PLATFORM_WIN32_WINDOWS	1
d341 27
@


1.1.1.1
log
@perl5.005_03
@
text
@a11 44
#ifdef PERL_OBJECT
#  define DYNAMIC_ENV_FETCH
#  define ENV_HV_NAME "___ENV_HV_NAME___"
#  define prime_env_iter()
#  define WIN32IO_IS_STDIO		/* don't pull in custom stdio layer */
#  ifdef PERL_GLOBAL_STRUCT
#    error PERL_GLOBAL_STRUCT cannot be defined with PERL_OBJECT
#  endif
#  define win32_get_privlib PerlEnv_lib_path
#  define win32_get_sitelib PerlEnv_sitelib_path
#endif

#ifdef __GNUC__
typedef long long __int64;
#  define Win32_Winsock
/* GCC does not do __declspec() - render it a nop 
 * and turn on options to avoid importing data 
 */
#ifndef __declspec
#  define __declspec(x)
#endif
#  ifndef PERL_OBJECT
#    define PERL_GLOBAL_STRUCT
#    define MULTIPLICITY
#  endif
#endif

/* Define DllExport akin to perl's EXT, 
 * If we are in the DLL or mimicing the DLL for Win95 work round
 * then Export the symbol, 
 * otherwise import it.
 */

#if defined(PERL_OBJECT)
#define DllExport
#else
#if defined(PERLDLL) || defined(WIN95FIX)
#define DllExport
/*#define DllExport __declspec(dllexport)*/	/* noises with VC5+sp3 */
#else 
#define DllExport __declspec(dllimport)
#endif
#endif

d17 1
a19 4
#ifndef TLS_OUT_OF_INDEXES
#define TLS_OUT_OF_INDEXES (DWORD)0xFFFFFFFF
#endif

a24 4
#include <stdlib.h>
#ifndef EXT
#include "EXTERN.h"
#endif
d26 1
a26 6
struct tms {
	long	tms_utime;
	long	tms_stime;
	long	tms_cutime;
	long	tms_cstime;
};
d28 1
a28 50
#ifndef START_EXTERN_C
#undef EXTERN_C
#ifdef __cplusplus
#  define START_EXTERN_C extern "C" {
#  define END_EXTERN_C }
#  define EXTERN_C extern "C"
#else
#  define START_EXTERN_C 
#  define END_EXTERN_C 
#  define EXTERN_C
#endif
#endif

#define  STANDARD_C	1
#define  DOSISH		1		/* no escaping our roots */
#define  OP_BINARY	O_BINARY	/* mistake in in pp_sys.c? */

/* Define USE_SOCKETS_AS_HANDLES to enable emulation of windows sockets as
 * real filehandles. XXX Should always be defined (the other version is untested) */
#define USE_SOCKETS_AS_HANDLES

/* read() and write() aren't transparent for socket handles */
#define PERL_SOCK_SYSREAD_IS_RECV
#define PERL_SOCK_SYSWRITE_IS_SEND


/* if USE_WIN32_RTL_ENV is not defined, Perl uses direct Win32 calls
 * to read the environment, bypassing the runtime's (usually broken)
 * facilities for accessing the same.  See note in util.c/my_setenv(). */
/*#define USE_WIN32_RTL_ENV */

/* Define USE_FIXED_OSFHANDLE to fix VC's _open_osfhandle() on W95.
 * Can only enable it if not using the DLL CRT (it doesn't expose internals) */
#if defined(_MSC_VER) && !defined(_DLL) && defined(_M_IX86)
#define USE_FIXED_OSFHANDLE
#endif

#define ENV_IS_CASELESS

#ifndef VER_PLATFORM_WIN32_WINDOWS	/* VC-2.0 headers don't have this */
#define VER_PLATFORM_WIN32_WINDOWS	1
#endif

#ifndef FILE_SHARE_DELETE		/* VC-4.0 headers don't have this */
#define FILE_SHARE_DELETE		0x00000004
#endif

/* Compiler-specific stuff. */

#ifdef __BORLANDC__		/* Borland C++ */
d38 9
a46 16
#pragma warn -ccc	/* "condition is always true/false" */
#pragma warn -rch	/* "unreachable code" */
#pragma warn -sig	/* "conversion may lose significant digits" */
#pragma warn -pia	/* "possibly incorrect assignment" */
#pragma warn -par	/* "parameter 'foo' is never used" */
#pragma warn -aus	/* "'foo' is assigned a value that is never used" */
#pragma warn -use	/* "'foo' is declared but never used" */
#pragma warn -csu	/* "comparing signed and unsigned values" */
#pragma warn -pro	/* "call to function with no prototype" */

#define USE_RTL_WAIT	/* Borland has a working wait() */

/* Borland is picky about a bare member function name used as its ptr */
#ifdef PERL_OBJECT
#define FUNC_NAME_TO_PTR(name)	&(name)
#endif
d48 1
a48 3
#endif

#ifdef _MSC_VER			/* Microsoft Visual C++ */
a51 1
#pragma  warning(disable: 4018 4035 4101 4102 4244 4245 4761)
d53 1
a53 1
#ifndef PERL_OBJECT
d55 6
a60 44
/* Visual C thinks that a pointer to a member variable is 16 bytes in size. */
#define STRUCT_MGVTBL_DEFINITION					\
struct mgvtbl {								\
    union {								\
	int	    (CPERLscope(*svt_get))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem1[16];				\
    };									\
    union {								\
	int	    (CPERLscope(*svt_set))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem2[16];				\
    };									\
    union {								\
	U32	    (CPERLscope(*svt_len))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem3[16];				\
    };									\
    union {								\
	int	    (CPERLscope(*svt_clear))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem4[16];				\
    };									\
    union {								\
	int	    (CPERLscope(*svt_free))	_((SV *sv, MAGIC* mg));	\
	char	    handle_VC_problem5[16];				\
    };									\
}

#define BASEOP_DEFINITION		\
    OP*		op_next;		\
    OP*		op_sibling;		\
    OP*		(CPERLscope(*op_ppaddr))_((ARGSproto));		\
    char	handle_VC_problem[12];	\
    PADOFFSET	op_targ;		\
    OPCODE	op_type;		\
    U16		op_seq;			\
    U8		op_flags;		\
    U8		op_private;

#define UNION_ANY_DEFINITION union any {		\
    void*	any_ptr;				\
    I32		any_i32;				\
    IV		any_iv;					\
    long	any_long;				\
    void	(CPERLscope(*any_dptr)) _((void*));	\
    char	handle_VC_problem[16];			\
}
d62 1
a62 1
#endif /* PERL_OBJECT */
d64 1
a64 1
#endif /* _MSC_VER */
d66 5
a70 1
#ifdef __MINGW32__		/* Minimal Gnu-Win32 */
d72 8
a79 4
typedef long		uid_t;
typedef long		gid_t;
#ifndef _environ
#define _environ	environ
a80 2
#define flushall	_flushall
#define fcloseall	_fcloseall
d82 1
a82 3
#ifdef PERL_OBJECT
#define FUNC_NAME_TO_PTR(name)	&(name)
#endif
d84 3
a86 6
#ifndef _O_NOINHERIT
#  define _O_NOINHERIT	0x0080
#  ifndef _NO_OLDNAMES
#    define O_NOINHERIT	_O_NOINHERIT
#  endif
#endif
d88 3
a90 6
#ifndef _O_NOINHERIT
#  define _O_NOINHERIT	0x0080
#  ifndef _NO_OLDNAMES
#    define O_NOINHERIT	_O_NOINHERIT
#  endif
#endif
d92 2
a93 1
#endif /* __MINGW32__ */
d95 1
a95 1
/* compatibility stuff for other compilers goes here */
d97 2
d100 2
a101 1
START_EXTERN_C
a102 1
/* For UNIX compatibility. */
d104 2
a105 20
extern  uid_t	getuid(void);
extern  gid_t	getgid(void);
extern  uid_t	geteuid(void);
extern  gid_t	getegid(void);
extern  int	setuid(uid_t uid);
extern  int	setgid(gid_t gid);
extern  int	kill(int pid, int sig);
extern  void	*sbrk(int need);
extern	char *	getlogin(void);
extern	int	chown(const char *p, uid_t o, gid_t g);

#undef	 Stat
#define  Stat		win32_stat

#undef   init_os_extras
#define  init_os_extras Perl_init_os_extras

DllExport void		Perl_win32_init(int *argcp, char ***argvp);
DllExport void		Perl_init_os_extras(void);
DllExport void		win32_str_os_error(void *sv, DWORD err);
d107 2
a108 12
#ifndef USE_SOCKETS_AS_HANDLES
extern FILE *		my_fdopen(int, char *);
#endif
extern int		my_fclose(FILE *);
extern int		do_aspawn(void *really, void **mark, void **sp);
extern int		do_spawn(char *cmd);
extern int		do_spawn_nowait(char *cmd);
extern char		do_exec(char *cmd);
extern char *		win32_get_privlib(char *pl);
extern char *		win32_get_sitelib(char *pl);
extern int		IsWin95(void);
extern int		IsWinNT(void);
d110 6
a115 1
extern char *		staticlinkmodules[];
d117 9
a125 1
END_EXTERN_C
d130 7
d139 1
d143 2
a144 4
#ifdef MYMALLOC
#define EMBEDMYMALLOC	/**/
/* #define USE_PERL_SBRK	/**/
/* #define PERL_SBRK_VIA_MALLOC	/**/
d147 2
a148 3
#if defined(PERLDLL) && !defined(PERL_CORE)
#define PERL_CORE
#endif
d150 2
a151 6
#ifdef USE_BINMODE_SCRIPTS
#define PERL_SCRIPT_MODE "rb"
EXT void win32_strip_return(struct sv *sv);
#else
#define PERL_SCRIPT_MODE "r"
#define win32_strip_return(sv) NOOP
a152 49

#define HAVE_INTERP_INTERN
struct interp_intern {
    char *	w32_perlshell_tokens;
    char **	w32_perlshell_vec;
    long	w32_perlshell_items;
    struct av *	w32_fdpid;
#ifndef USE_RTL_WAIT
    long	w32_num_children;
    HANDLE	w32_child_pids[MAXIMUM_WAIT_OBJECTS];
#endif
};

#define w32_perlshell_tokens	(PL_sys_intern.w32_perlshell_tokens)
#define w32_perlshell_vec	(PL_sys_intern.w32_perlshell_vec)
#define w32_perlshell_items	(PL_sys_intern.w32_perlshell_items)
#define w32_fdpid		(PL_sys_intern.w32_fdpid)

#ifndef USE_RTL_WAIT
#  define w32_num_children	(PL_sys_intern.w32_num_children)
#  define w32_child_pids	(PL_sys_intern.w32_child_pids)
#endif

/* 
 * Now Win32 specific per-thread data stuff 
 */

#ifdef USE_THREADS
#  ifndef USE_DECLSPEC_THREAD
#    define HAVE_THREAD_INTERN

struct thread_intern {
    /* XXX can probably use one buffer instead of several */
    char		Wstrerror_buffer[512];
    struct servent	Wservent;
    char		Wgetlogin_buffer[128];
    char		Ww32_perllib_root[MAX_PATH+1];
#    ifdef USE_SOCKETS_AS_HANDLES
    int			Winit_socktype;
#    endif
#    ifdef HAVE_DES_FCRYPT
    char		Wcrypt_buffer[30];
#    endif
#    ifdef USE_RTL_THREAD_API
    void *		retv;	/* slot for thread return value */
#    endif
};
#  endif /* !USE_DECLSPEC_THREAD */
#endif /* USE_THREADS */
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d12 1
a12 5
#ifndef _WIN32_WINNT
#  define _WIN32_WINNT 0x0400     /* needed for TryEnterCriticalSection() etc. */
#endif

#if defined(PERL_OBJECT) || defined(PERL_IMPLICIT_SYS) || defined(PERL_CAPI)
a14 1
#  define HAS_GETENV_LEN
a16 1
#  define WIN32SCK_IS_STDSCK		/* don't pull in custom wsock layer */
d18 1
a18 1
#    error PERL_GLOBAL_STRUCT cannot be defined with PERL_IMPLICIT_SYS
a21 1
#  define win32_get_vendorlib PerlEnv_vendorlib_path
d25 11
a35 2
#  ifndef __int64		/* some versions seem to #define it already */
#    define __int64 long long
a36 1
#  define Win32_Winsock
a44 2
/* now even GCC supports __declspec() */

a72 1
#include <fcntl.h>
a83 12
#ifndef SYS_NMLN
#define SYS_NMLN	257
#endif

struct utsname {
    char sysname[SYS_NMLN];
    char nodename[SYS_NMLN];
    char release[SYS_NMLN];
    char version[SYS_NMLN];
    char machine[SYS_NMLN];
};

a108 1
#define PERL_NO_FORCE_LINK		/* no need for PL_force_link_funcs */
d115 3
a117 5
/* Define USE_FIXED_OSFHANDLE to fix MSVCRT's _open_osfhandle() on W95.
   It now uses some black magic to work seamlessly with the DLL CRT and
   works with MSVC++ 4.0+ or GCC/Mingw32
	-- BKS 1-24-2000 */
#if (defined(_M_IX86) && _MSC_VER >= 1000) || defined(__MINGW32__)
a130 10
/* access() mode bits */
#ifndef R_OK
#  define	R_OK	4
#  define	W_OK	2
#  define	X_OK	1
#  define	F_OK	0
#endif

#define PERL_GET_CONTEXT_DEFINED

a136 2
#define _getpid getpid
#define wcsicmp _wcsicmp
d152 2
a153 1
#pragma warn -stu	/* "undefined structure 'foo'" */
d157 1
a157 1
#  define MEMBER_TO_FPTR(name)	&(name)
a159 3
/* Borland C thinks that a pointer to a member variable is 12 bytes in size. */
#define PERL_MEMBER_PTR_SIZE	12

a165 1
typedef unsigned short	mode_t;
d168 2
d171 45
a215 1
#define PERL_MEMBER_PTR_SIZE	16
d230 8
a237 1
#  define MEMBER_TO_FPTR(name)	&(name)
a248 5
/* both GCC/Mingw32 and MSVC++ 4.0 are missing this, so we put it here */
#ifndef CP_UTF8
#  define CP_UTF8	65001
#endif

a251 39
#if !defined(PERL_OBJECT) && defined(PERL_CAPI) && defined(PERL_MEMBER_PTR_SIZE)
#  define STRUCT_MGVTBL_DEFINITION \
struct mgvtbl {								\
    union {								\
	int	    (CPERLscope(*svt_get))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem1[PERL_MEMBER_PTR_SIZE];		\
    };									\
    union {								\
	int	    (CPERLscope(*svt_set))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem2[PERL_MEMBER_PTR_SIZE];		\
    };									\
    union {								\
	U32	    (CPERLscope(*svt_len))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem3[PERL_MEMBER_PTR_SIZE];		\
    };									\
    union {								\
	int	    (CPERLscope(*svt_clear))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem4[PERL_MEMBER_PTR_SIZE];		\
    };									\
    union {								\
	int	    (CPERLscope(*svt_free))(pTHX_ SV *sv, MAGIC* mg);	\
	char	    handle_VC_problem5[PERL_MEMBER_PTR_SIZE];		\
    };									\
}

#  define BASEOP_DEFINITION \
    OP*		op_next;						\
    OP*		op_sibling;						\
    OP*		(CPERLscope(*op_ppaddr))(pTHX);				\
    char	handle_VC_problem[PERL_MEMBER_PTR_SIZE-sizeof(OP*)];	\
    PADOFFSET	op_targ;						\
    OPCODE	op_type;						\
    U16		op_seq;							\
    U8		op_flags;						\
    U8		op_private;

#endif /* !PERL_OBJECT && PERL_CAPI && PERL_MEMBER_PTR_SIZE */


d274 1
a274 1
DllExport void		Perl_init_os_extras();
a275 26
DllExport int		RunPerl(int argc, char **argv, char **env);

typedef struct {
    HANDLE	childStdIn;
    HANDLE	childStdOut;
    HANDLE	childStdErr;
    /*
     * the following correspond to the fields of the same name
     * in the STARTUPINFO structure. Embedders can use these to
     * control the spawning process' look.
     * Example - to hide the window of the spawned process:
     *    dwFlags = STARTF_USESHOWWINDOW;
     *	  wShowWindow = SW_HIDE;
     */
    DWORD	dwFlags;
    DWORD	dwX; 
    DWORD	dwY; 
    DWORD	dwXSize; 
    DWORD	dwYSize; 
    DWORD	dwXCountChars; 
    DWORD	dwYCountChars; 
    DWORD	dwFillAttribute;
    WORD	wShowWindow; 
} child_IO_table;

DllExport void		win32_get_child_IO(child_IO_table* ptr);
d284 3
a286 3
extern char *		win32_get_privlib(const char *pl);
extern char *		win32_get_sitelib(const char *pl);
extern char *		win32_get_vendorlib(const char *pl);
a288 5
extern void		win32_argv2utf8(int argc, char** argv);

#ifdef PERL_IMPLICIT_SYS
extern void		win32_delete_internal_host(void *h);
#endif
d312 3
a314 2
#ifdef PERL_TEXTMODE_SCRIPTS
#  define PERL_SCRIPT_MODE		"r"
d316 24
a339 1
#  define PERL_SCRIPT_MODE		"rb"
d346 4
d355 1
a365 4

#ifdef USE_THREADS
#  ifndef USE_DECLSPEC_THREAD
#    define HAVE_THREAD_INTERN
a368 88
#define HAVE_INTERP_INTERN
typedef struct {
    long	num;
    DWORD	pids[MAXIMUM_WAIT_OBJECTS];
    HANDLE	handles[MAXIMUM_WAIT_OBJECTS];
} child_tab;

struct interp_intern {
    char *	perlshell_tokens;
    char **	perlshell_vec;
    long	perlshell_items;
    struct av *	fdpid;
    child_tab *	children;
#ifdef USE_ITHREADS
    DWORD	pseudo_id;
    child_tab *	pseudo_children;
#endif
    void *	internal_host;
#ifndef USE_THREADS
    struct thread_intern	thr_intern;
#endif
};


#define w32_perlshell_tokens	(PL_sys_intern.perlshell_tokens)
#define w32_perlshell_vec	(PL_sys_intern.perlshell_vec)
#define w32_perlshell_items	(PL_sys_intern.perlshell_items)
#define w32_fdpid		(PL_sys_intern.fdpid)
#define w32_children		(PL_sys_intern.children)
#define w32_num_children	(w32_children->num)
#define w32_child_pids		(w32_children->pids)
#define w32_child_handles	(w32_children->handles)
#define w32_pseudo_id		(PL_sys_intern.pseudo_id)
#define w32_pseudo_children	(PL_sys_intern.pseudo_children)
#define w32_num_pseudo_children		(w32_pseudo_children->num)
#define w32_pseudo_child_pids		(w32_pseudo_children->pids)
#define w32_pseudo_child_handles	(w32_pseudo_children->handles)
#define w32_internal_host		(PL_sys_intern.internal_host)
#ifdef USE_THREADS
#  define w32_strerror_buffer	(thr->i.Wstrerror_buffer)
#  define w32_getlogin_buffer	(thr->i.Wgetlogin_buffer)
#  define w32_crypt_buffer	(thr->i.Wcrypt_buffer)
#  define w32_servent		(thr->i.Wservent)
#  define w32_init_socktype	(thr->i.Winit_socktype)
#else
#  define w32_strerror_buffer	(PL_sys_intern.thr_intern.Wstrerror_buffer)
#  define w32_getlogin_buffer	(PL_sys_intern.thr_intern.Wgetlogin_buffer)
#  define w32_crypt_buffer	(PL_sys_intern.thr_intern.Wcrypt_buffer)
#  define w32_servent		(PL_sys_intern.thr_intern.Wservent)
#  define w32_init_socktype	(PL_sys_intern.thr_intern.Winit_socktype)
#endif /* USE_THREADS */

/* UNICODE<>ANSI translation helpers */
/* Use CP_ACP when mode is ANSI */
/* Use CP_UTF8 when mode is UTF8 */

#define A2WHELPER_LEN(lpa, alen, lpw, nBytes)\
    (lpw[0] = 0, MultiByteToWideChar((IN_BYTE) ? CP_ACP : CP_UTF8, 0, \
				    lpa, alen, lpw, (nBytes/sizeof(WCHAR))))
#define A2WHELPER(lpa, lpw, nBytes)	A2WHELPER_LEN(lpa, -1, lpw, nBytes)

#define W2AHELPER_LEN(lpw, wlen, lpa, nChars)\
    (lpa[0] = '\0', WideCharToMultiByte((IN_BYTE) ? CP_ACP : CP_UTF8, 0, \
				       lpw, wlen, (LPSTR)lpa, nChars,NULL,NULL))
#define W2AHELPER(lpw, lpa, nChars)	W2AHELPER_LEN(lpw, -1, lpa, nChars)

#define USING_WIDE() (PL_widesyscalls && PerlEnv_os_id() == VER_PLATFORM_WIN32_NT)

#ifdef USE_ITHREADS
#  define PERL_WAIT_FOR_CHILDREN \
    STMT_START {							\
	if (w32_pseudo_children && w32_num_pseudo_children) {		\
	    long children = w32_num_pseudo_children;			\
	    WaitForMultipleObjects(children,				\
				   w32_pseudo_child_handles,		\
				   TRUE, INFINITE);			\
	    while (children)						\
		CloseHandle(w32_pseudo_child_handles[--children]);	\
	}								\
    } STMT_END
#endif

/*
 * This provides a layer of functions and macros to ensure extensions will
 * get to use the same RTL functions as the core.
 */
#include "win32iop.h"

a369 1

@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d125 5
a137 6
/* Define PERL_WIN32_SOCK_DLOAD to have Perl dynamically load the winsock
   DLL when needed. Don't use if your compiler supports delayloading (ie, VC++ 6.0)
	-- BKS 5-29-2000 */
#if !(defined(_M_IX86) && _MSC_VER >= 1200)
#define PERL_WIN32_SOCK_DLOAD
#endif
a155 5
/* for waitpid() */
#ifndef WNOHANG
#  define WNOHANG	1
#endif

a161 1
#if (__BORLANDC__ <= 0x520)
a163 2
#endif

d180 2
a190 2
#define isnan		_isnan

a202 2
#define isnan		_isnan

a213 1
#define isnan		_isnan	/* ...same libraries as MSVC */
d297 1
a297 1
DllExport void		Perl_init_os_extras(void);
a329 1
extern int		my_fstat(int fd, struct stat *sbufptr);
a479 50
#if defined(USE_FIXED_OSFHANDLE) || defined(PERL_MSVCRT_READFIX)
#ifdef PERL_CORE

/* C doesn't like repeat struct definitions */
#ifndef _CRTIMP
#define _CRTIMP __declspec(dllimport)
#endif

/*
 * Control structure for lowio file handles
 */
typedef struct {
    long osfhnd;    /* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
    int lockinitflag;
    CRITICAL_SECTION lock;
} ioinfo;


/*
 * Array of arrays of control structures for lowio files.
 */
EXTERN_C _CRTIMP ioinfo* __pioinfo[];

/*
 * Definition of IOINFO_L2E, the log base 2 of the number of elements in each
 * array of ioinfo structs.
 */
#define IOINFO_L2E	    5

/*
 * Definition of IOINFO_ARRAY_ELTS, the number of elements in ioinfo array
 */
#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)

/*
 * Access macros for getting at an ioinfo struct and its fields from a
 * file handle
 */
#define _pioinfo(i) (__pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - 1)))
#define _osfhnd(i)  (_pioinfo(i)->osfhnd)
#define _osfile(i)  (_pioinfo(i)->osfile)
#define _pipech(i)  (_pioinfo(i)->pipech)

/* since we are not doing a dup2(), this works fine */
#define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = (long)osfh)
#endif
#endif

a484 2

#define EXEC_ARGV_CAST(x) ((const char *const *) x)
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 * (c) 1995 Microsoft Corporation. All rights reserved.
d16 1
a16 1
#if defined(PERL_IMPLICIT_SYS)
d18 1
a35 5
#ifdef __cplusplus
/* Mingw32 gcc -xc++ objects to __attribute((unused)) at least */
#undef  PERL_UNUSED_DECL
#define PERL_UNUSED_DECL
#endif
d38 1
a38 2

/* Define DllExport akin to perl's EXT,
d40 1
a40 1
 * then Export the symbol,
d46 3
d52 1
a52 1
#else
d55 1
a73 1
#include <stddef.h>
d105 2
a106 2
#  define START_EXTERN_C
#  define END_EXTERN_C
d190 5
d207 1
a207 1
#pragma  warning(disable: 4102)	/* "unreferenced label" */
d227 4
a246 4
#ifndef _INTPTR_T_DEFINED
typedef int		intptr_t;
#  define _INTPTR_T_DEFINED
#endif
d248 38
a285 4
#ifndef _UINTPTR_T_DEFINED
typedef unsigned int	uintptr_t;
#  define _UINTPTR_T_DEFINED
#endif
d298 1
a298 4
#ifndef USE_PERL_SBRK
extern  void	*sbrk(ptrdiff_t need);
#  define HAS_SBRK_PROTO
#endif
a300 1
extern  int	mkstemp(const char *path);
d326 6
a331 6
    DWORD	dwX;
    DWORD	dwY;
    DWORD	dwXSize;
    DWORD	dwYSize;
    DWORD	dwXCountChars;
    DWORD	dwYCountChars;
d333 1
a333 1
    WORD	wShowWindow;
d342 4
a345 1
extern int		my_fstat(int fd, Stat_t *sbufptr);
d385 2
a386 2
/*
 * Now Win32 specific per-thread data stuff
a402 2
    BOOL               Wuse_showwindow;
    WORD               Wshowwindow;
d405 1
a405 1
#ifdef USE_5005THREADS
d409 1
a409 1
#endif /* USE_5005THREADS */
a417 5
#ifndef Sighandler_t
typedef Signal_t (*Sighandler_t) (int);
#define Sighandler_t	Sighandler_t
#endif

d429 1
a429 1
#ifndef USE_5005THREADS
a431 3
    UINT	timerid;
    unsigned 	poll_count;
    Sighandler_t sigtable[SIG_SIZE];
a433 4
DllExport int win32_async_check(pTHX);

#define WIN32_POLL_INTERVAL 32768
#define PERL_ASYNC_CHECK() if (w32_do_async || PL_sig_pending) win32_async_check(aTHX)
d449 1
a449 5
#define w32_timerid			(PL_sys_intern.timerid)
#define w32_sighandler			(PL_sys_intern.sigtable)
#define w32_poll_count			(PL_sys_intern.poll_count)
#define w32_do_async			(w32_poll_count++ > WIN32_POLL_INTERVAL)
#ifdef USE_5005THREADS
a454 2
#  define w32_use_showwindow	(thr->i.Wuse_showwindow)
#  define w32_showwindow	(thr->i.Wshowwindow)
d461 1
a461 3
#  define w32_use_showwindow	(PL_sys_intern.thr_intern.Wuse_showwindow)
#  define w32_showwindow	(PL_sys_intern.thr_intern.Wshowwindow)
#endif /* USE_5005THREADS */
d468 1
a468 1
    (lpw[0] = 0, MultiByteToWideChar((IN_BYTES) ? CP_ACP : CP_UTF8, 0, \
d473 1
a473 1
    (lpa[0] = '\0', WideCharToMultiByte((IN_BYTES) ? CP_ACP : CP_UTF8, 0, \
d505 1
a505 1
    intptr_t osfhnd;/* underlying OS file HANDLE */
d539 1
a539 1
#define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = (intptr_t)osfh)
a542 8
/* IO.xs and POSIX.xs define PERLIO_NOT_STDIO to 1 */
#if defined(PERL_EXT_IO) || defined(PERL_EXT_POSIX)
#undef  PERLIO_NOT_STDIO
#endif
#define PERLIO_NOT_STDIO 0

#include "perlio.h"

a549 10

#if !defined(ECONNABORTED) && defined(WSAECONNABORTED)
#define ECONNABORTED WSAECONNABORTED
#endif
#if !defined(EAFNOSUPPORT) && defined(WSAEAFNOSUPPORT)
#define EAFNOSUPPORT WSAEAFNOSUPPORT
#endif

DllExport void *win32_signal_context(void);
#define PERL_GET_SIG_CONTEXT win32_signal_context()
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@a142 2
#define PIPESOCK_MODE	"b"		/* pipes, sockets default to binmode */

a275 1
DllExport void		Perl_win32_term(void);
d463 1
a463 1
#define USING_WIDE() (0)
a482 3
#if defined(__MINGW32__) && (__MINGW32_MAJOR_VERSION>=3)
#undef _CRTIMP
#endif
a547 3
#if !defined(ECONNRESET) && defined(WSAECONNRESET)
#define ECONNRESET WSAECONNRESET
#endif
a550 1
/* Why not needed for ECONNREFUSED? --abe */
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@a232 11
/* <stdint.h>, pulled in by <io.h> as of mingw-runtime-3.3, typedef's
 * (u)intptr_t but doesn't set the _(U)INTPTR_T_DEFINED defines */
#ifdef _STDINT_H
#  ifndef _INTPTR_T_DEFINED
#    define _INTPTR_T_DEFINED
#  endif
#  ifndef _UINTPTR_T_DEFINED
#    define _UINTPTR_T_DEFINED
#  endif
#endif

@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d130 2
a131 5
	-- BKS 1-24-2000
   Only use this fix for VC++ 6.x or earlier (and for GCC, which we assume
   uses MSVCRT.DLL). Later versions use MSVCR70.dll, MSVCR71.dll, etc, which
   do not require the fix. */
#if (defined(_M_IX86) && _MSC_VER >= 1000 && _MSC_VER <= 1200) || defined(__MINGW32__)
d185 8
a192 9
#pragma warn -8004	/* "'foo' is assigned a value that is never used" */
#pragma warn -8008	/* "condition is always true/false" */
#pragma warn -8012	/* "comparing signed and unsigned values" */
#pragma warn -8027	/* "functions containing %s are not expanded inline" */
#pragma warn -8057	/* "parameter 'foo' is never used" */
#pragma warn -8060	/* "possibly incorrect assignment" */
#pragma warn -8066	/* "unreachable code" */
#pragma warn -8071	/* "conversion may lose significant digits" */
#pragma warn -8080	/* "'foo' is declared but never used" */
a202 1
#ifndef UNDER_CE
a205 2
#endif

a211 7
#define snprintf	_snprintf
#define vsnprintf	_vsnprintf

#if _MSC_VER < 1300
/* VC6 has broken NaN semantics: NaN == NaN returns true instead of false */
#define NAN_COMPARE_BROKEN 1
#endif
a273 1
extern  int	killpg(int pid, int sig);
a317 1
DllExport HWND		win32_create_message_window(void);
d329 1
d353 4
a366 10
/* Leave the first couple ids after WM_USER unused because they
 * might be used by an embedding application, and on Windows
 * version before 2000 we might end up eating those messages
 * if they were not meant for us.
 */
#define WM_USER_MIN     (WM_USER+30)
#define WM_USER_MESSAGE (WM_USER_MIN)
#define WM_USER_KILL    (WM_USER_MIN+1)
#define WM_USER_MAX     (WM_USER_MIN+1)

d385 6
a397 9
#ifdef USE_ITHREADS
typedef struct {
    long	num;
    DWORD	pids[MAXIMUM_WAIT_OBJECTS];
    HANDLE	handles[MAXIMUM_WAIT_OBJECTS];
    HWND	message_hwnds[MAXIMUM_WAIT_OBJECTS];
} pseudo_child_tab;
#endif

d411 1
a411 1
    pseudo_child_tab * pseudo_children;
d414 1
d416 1
a416 1
    HWND        message_hwnd;
a439 1
#define w32_pseudo_child_message_hwnds	(w32_pseudo_children->message_hwnds)
a441 1
#define w32_message_hwnd		(PL_sys_intern.message_hwnd)
d445 33
a477 7
#define w32_strerror_buffer	(PL_sys_intern.thr_intern.Wstrerror_buffer)
#define w32_getlogin_buffer	(PL_sys_intern.thr_intern.Wgetlogin_buffer)
#define w32_crypt_buffer	(PL_sys_intern.thr_intern.Wcrypt_buffer)
#define w32_servent		(PL_sys_intern.thr_intern.Wservent)
#define w32_init_socktype	(PL_sys_intern.thr_intern.Winit_socktype)
#define w32_use_showwindow	(PL_sys_intern.thr_intern.Wuse_showwindow)
#define w32_showwindow	(PL_sys_intern.thr_intern.Wshowwindow)
a574 12

#ifdef UNDER_CE
#define Win_GetModuleHandle   XCEGetModuleHandleA
#define Win_GetProcAddress    XCEGetProcAddressA
#define Win_GetModuleFileName XCEGetModuleFileNameA
#define Win_CreateSemaphore   CreateSemaphoreW
#else
#define Win_GetModuleHandle   GetModuleHandle
#define Win_GetProcAddress    GetProcAddress
#define Win_GetModuleFileName GetModuleFileName
#define Win_CreateSemaphore   CreateSemaphore
#endif
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d4 1
a4 1
 * 		Developed by hip communications inc.
a60 17
/*
 * Bug in winbase.h in mingw-w64 4.4.0-1 at least... they
 * do #define GetEnvironmentStringsA GetEnvironmentStrings and fail
 * to declare GetEnvironmentStringsA.
 */
#if defined(__MINGW64__) && defined(GetEnvironmentStringsA) && !defined(UNICODE)
#ifdef __cplusplus
extern "C" {
#endif
#undef GetEnvironmentStringsA
WINBASEAPI LPCH WINAPI GetEnvironmentStringsA(VOID);
#define GetEnvironmentStrings GetEnvironmentStringsA
#ifdef __cplusplus
}
#endif
#endif

a172 8
#if defined(_MSC_VER) || defined(__MINGW32__)
/* VC uses non-standard way to determine the size and alignment if bit-fields */
/* MinGW will compiler with -mms-bitfields, so should use the same types */
#  define PERL_BITFIELD8  unsigned char
#  define PERL_BITFIELD16 unsigned short
#  define PERL_BITFIELD32 unsigned int
#endif

a237 1
#ifndef isnan
a238 1
#endif
d340 3
a342 3
extern char *		win32_get_privlib(const char *pl, STRLEN *const len);
extern char *		win32_get_sitelib(const char *pl, STRLEN *const len);
extern char *		win32_get_vendorlib(const char *pl, STRLEN *const len);
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d13 1
a13 1
#  define _WIN32_WINNT 0x0500     /* needed for CreateHardlink() etc. */
d44 2
a45 1
 * If we are in the DLL then Export the symbol,
d51 1
a51 1
#if defined(PERLDLL)
a57 17
/* The Perl APIs can only be called directly inside the perl5xx.dll.
 * All other code has to import them.  By declaring them as "dllimport"
 * we tell the compiler to generate an indirect call instruction and
 * avoid redirection through a call thunk.
 *
 * The XS code in the re extension is special, in that it redefines
 * core APIs locally, so don't mark them as "dllimport" because GCC
 * cannot handle this situation.
 */
#if !defined(PERLDLL) && !defined(PERL_EXT_RE_BUILD)
#  ifdef __cplusplus
#    define PERL_CALLCONV extern "C" __declspec(dllimport)
#  else
#    define PERL_CALLCONV __declspec(dllimport)
#  endif
#endif

d144 11
d198 32
d366 1
d370 2
d423 1
d425 1
a445 1
    char        sigterm[MAXIMUM_WAIT_OBJECTS];
a490 1
#define w32_pseudo_child_sigterm	(w32_pseudo_children->sigterm)
d506 64
a569 2
void win32_wait_for_children(pTHX);
#  define PERL_WAIT_FOR_CHILDREN win32_wait_for_children(aTHX)
d587 11
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a15 32
#ifdef PERL_IS_MINIPERL
/* this macro will remove Winsock only on miniperl, PERL_IMPLICIT_SYS and
 * makedef.pl create dependencies that will keep Winsock linked in even with
 * this macro defined, even though sockets will be umimplemented from a script
 * level in full perl
 */
#  define WIN32_NO_SOCKETS
#endif

#ifdef WIN32_NO_SOCKETS
#  undef HAS_SOCKET
#  undef HAS_GETPROTOBYNAME
#  undef HAS_GETPROTOBYNUMBER
#  undef HAS_GETPROTOENT
#  undef HAS_GETNETBYNAME
#  undef HAS_GETNETBYADDR
#  undef HAS_GETNETENT
#  undef HAS_GETSERVBYNAME
#  undef HAS_GETSERVBYPORT
#  undef HAS_GETSERVENT
#  undef HAS_GETHOSTBYNAME
#  undef HAS_GETHOSTBYADDR
#  undef HAS_GETHOSTENT
#  undef HAS_SELECT
#  undef HAS_IOCTL
#  undef HAS_NTOHL
#  undef HAS_HTONL
#  undef HAS_HTONS
#  undef HAS_NTOHS
#  define WIN32SCK_IS_STDSCK
#endif

d49 4
a52 3
/* miniperl has no reason to export anything */
#if defined(PERL_IS_MINIPERL) && !defined(UNDER_CE) && defined(_MSC_VER)
#  define DllExport
d54 1
a54 5
#  if defined(PERLDLL)
#    define DllExport __declspec(dllexport)
#  else
#    define DllExport __declspec(dllimport)
#  endif
a68 3
#    ifdef _MSC_VER
#      define PERL_CALLCONV_NO_RET extern "C" __declspec(dllimport) __declspec(noreturn)
#    endif
a70 7
#    ifdef _MSC_VER
#      define PERL_CALLCONV_NO_RET __declspec(dllimport) __declspec(noreturn)
#    endif
#  endif
#else /* MSVC noreturn support inside the interp */
#  ifdef _MSC_VER
#    define PERL_CALLCONV_NO_RET __declspec(noreturn)
a73 5
#ifdef _MSC_VER
#  define PERL_STATIC_NO_RET __declspec(noreturn) static
#  define PERL_STATIC_INLINE_NO_RET __declspec(noreturn) PERL_STATIC_INLINE
#endif

d150 4
d155 2
a156 4
#ifndef WIN32_NO_SOCKETS
#  define PERL_SOCK_SYSREAD_IS_RECV
#  define PERL_SOCK_SYSWRITE_IS_SEND
#endif
d160 6
d170 8
d195 1
d197 5
a201 4
/* MinGW will compile with -mms-bitfields, so should use the same types */
#define PERL_BITFIELD8  unsigned char
#define PERL_BITFIELD16 unsigned short
#define PERL_BITFIELD32 unsigned int
d213 3
d258 3
d265 1
a265 1
#endif /* __MINGW32__ */
a280 1
#ifdef PERL_CORE
a295 1
#endif
d335 3
d347 1
a347 1
extern const char * const		staticlinkmodules[];
d390 1
d392 1
@


1.1.1.11
log
@Import perl-5.20.1
@
text
@a15 1
/* Win32 only optimizations for faster building */
a22 2
/* less I/O calls during each require */
#  define PERL_DISABLE_PMC
d245 1
a245 6
#if _MSC_VER < 1800
#define isnan		_isnan	/* Defined already in VC++ 12.0 */
#endif
#ifdef UNDER_CE /* revisit what function this becomes celib vs corelibc, prv warning here*/
#  undef snprintf
#endif
d249 1
a249 1
#ifdef USING_MSVC6
a253 5
/* on VC2003, msvcrt.lib is missing these symbols */
#if _MSC_VER >= 1300 && _MSC_VER < 1400
#  pragma intrinsic(_rotl64,_rotr64)
#endif

d315 1
a371 2
extern int		win32_get_errno(int err);

a501 94

#ifdef PERL_CORE
/* C doesn't like repeat struct definitions */
#if defined(__MINGW32__) && (__MINGW32_MAJOR_VERSION>=3)
#undef _CRTIMP
#endif
#ifndef _CRTIMP
#define _CRTIMP __declspec(dllimport)
#endif


/* VV 2005 has multiple ioinfo struct definitions through VC 2005's release life
 * VC 2008-2012 have been stable but do not assume future VCs will have the
 * same ioinfo struct, just because past struct stability. If research is done
 * on the CRTs of future VS, the version check can be bumped up so the newer
 * VC uses a fixed ioinfo size.
 */
#if ! (_MSC_VER < 1400 || (_MSC_VER >= 1500 && _MSC_VER <= 1700) \
  || defined(__MINGW32__))
/* size of ioinfo struct is determined at runtime */
#  define WIN32_DYN_IOINFO_SIZE
#endif

#ifndef WIN32_DYN_IOINFO_SIZE
/*
 * Control structure for lowio file handles
 */
typedef struct {
    intptr_t osfhnd;/* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
    int lockinitflag;
    CRITICAL_SECTION lock;
/* this struct defintion breaks ABI compatibility with
 * not using, cl.exe's native VS version specitfic CRT. */
#  if _MSC_VER >= 1400 && _MSC_VER < 1500
#    error "This ioinfo struct is incomplete for Visual C 2005"
#  endif
/* VC 2005 CRT has atleast 3 different definitions of this struct based on the
 * CRT DLL's build number. */
#  if _MSC_VER >= 1500
#    ifndef _SAFECRT_IMPL
    /* Not used in the safecrt downlevel. We do not define them, so we cannot
     * use them accidentally */
    char textmode : 7;/* __IOINFO_TM_ANSI or __IOINFO_TM_UTF8 or __IOINFO_TM_UTF16LE */
    char unicode : 1; /* Was the file opened as unicode? */
    char pipech2[2];  /* 2 more peak ahead chars for UNICODE mode */
    __int64 startpos;      /* File position that matches buffer start */
    BOOL utf8translations; /* Buffer contains translations other than CRLF*/
    char dbcsBuffer;       /* Buffer for the lead byte of dbcs when converting from dbcs to unicode */
    BOOL dbcsBufferUsed;   /* Bool for the lead byte buffer is used or not */
#    endif
#  endif
} ioinfo;
#else
typedef intptr_t ioinfo;
#endif

/*
 * Array of arrays of control structures for lowio files.
 */
EXTERN_C _CRTIMP ioinfo* __pioinfo[];

/*
 * Definition of IOINFO_L2E, the log base 2 of the number of elements in each
 * array of ioinfo structs.
 */
#define IOINFO_L2E	    5

/*
 * Definition of IOINFO_ARRAY_ELTS, the number of elements in ioinfo array
 */
#define IOINFO_ARRAY_ELTS   (1 << IOINFO_L2E)

/*
 * Access macros for getting at an ioinfo struct and its fields from a
 * file handle
 */
#ifdef WIN32_DYN_IOINFO_SIZE
#  define _pioinfo(i) ((intptr_t *) \
     (((Size_t)__pioinfo[(i) >> IOINFO_L2E])/* * to head of array ioinfo [] */\
      /* offset to the head of a particular ioinfo struct */ \
      + (((i) & (IOINFO_ARRAY_ELTS - 1)) * w32_ioinfo_size)) \
   )
/* first slice of ioinfo is always the OS handle */
#  define _osfhnd(i)  (*(_pioinfo(i)))
#else
#  define _pioinfo(i) (__pioinfo[(i) >> IOINFO_L2E] + ((i) & (IOINFO_ARRAY_ELTS - 1)))
#  define _osfhnd(i)  (_pioinfo(i)->osfhnd)
#endif

/* since we are not doing a dup2(), this works fine */
#  define _set_osfhnd(fh, osfh) (void)(_osfhnd(fh) = (intptr_t)osfh)
#endif /* PERL_CORE */
@


1.1.1.12
log
@Import perl-5.20.2
@
text
@d257 5
d400 2
a401 2
/* #define USE_PERL_SBRK	/ **/
/* #define PERL_SBRK_VIA_MALLOC	/ **/
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@a25 6

/* unnecessery for miniperl to lookup anything from an "installed" perl */
#  define WIN32_NO_REGISTRY

/* allow minitest to work */
#  define PERL_TEXTMODE_SCRIPTS
d60 3
a208 7
#ifdef WIN32_NO_REGISTRY
/* the last _ in WIN32_NO_REGISTRY_M_ is like the _ in aTHX_ */
#  define WIN32_NO_REGISTRY_M_(x)
#else
#  define WIN32_NO_REGISTRY_M_(x) x,
#endif

d246 2
a261 25
#  pragma warning(push)
#  pragma warning(disable:4756;disable:4056)
PERL_STATIC_INLINE
double S_Infinity() {
    /* this is a real C literal which can get further constant folded
       unlike using HUGE_VAL/_HUGE which are data symbol imports from the CRT
       and therefore can not by folded by VC, an example of constant
       folding INF is creating -INF */
    return (DBL_MAX+DBL_MAX);
}
#  pragma warning(pop)
#  define NV_INF S_Infinity()

/* selectany allows duplicate and unused data symbols to be removed by
   VC linker, if this were static, each translation unit will have its own,
   usually unused __PL_nan_u, if this were plain extern it will cause link
   to fail due to multiple definitions, since we dont know if we are being
   compiled as static or DLL XS, selectany simply always works, the cost of
   importing __PL_nan_u across DLL boundaries in size in the importing DLL
   will be more than the 8 bytes it will take up being in each XS DLL if
   that DLL actually uses __PL_nan_u */
extern const __declspec(selectany) union { unsigned __int64 __q; double __d; }
__PL_nan_u = { 0x7FF8000000000000UI64 };
#  define NV_NAN ((NV)__PL_nan_u.__d)

a328 1
#if !defined(__MINGW64_VERSION_MAJOR) || __MINGW64_VERSION_MAJOR < 4
a330 1
#endif
a368 1
DllExport int		win32_async_check(pTHX);
d371 1
a371 1
extern char *		win32_get_privlib(WIN32_NO_REGISTRY_M_(const char *pl) STRLEN *const len);
a470 1
    bool sloppystat;
d473 2
a505 1
#define w32_sloppystat	(PL_sys_intern.sloppystat)
d544 1
a544 1
/* this struct definition breaks ABI compatibility with
d549 1
a549 1
/* VC 2005 CRT has at least 3 different definitions of this struct based on the
d611 8
@


