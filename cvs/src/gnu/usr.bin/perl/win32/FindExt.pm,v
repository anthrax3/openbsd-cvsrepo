head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.8
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.10
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.8
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.6
	OPENBSD_5_0:1.1.1.5.0.4
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.2
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.4.0.4
	OPENBSD_4_8_BASE:1.1.1.4
	OPENBSD_4_7:1.1.1.4.0.2
	OPENBSD_4_7_BASE:1.1.1.4
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.10
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.8
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.6
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.4
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.2
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.21;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.13;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.13;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.49.58;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.19.04;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.11.07;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2010.09.24.14.48.45;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.09.44;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.21;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package FindExt;

our $VERSION = '1.03';

use strict;
use warnings;

my $no = join('|',qw(Amiga.* GDBM_File ODBM_File NDBM_File DB_File
                     VMS.* Sys-Syslog IPC-SysV I18N-Langinfo));
$no = qr/^(?:$no)$/i;

sub apply_config {
    my ($config) = @@_;
    my @@no;

    push @@no, 'Sys-Syslog' if $^O eq 'MSWin32';

    # duplicates logic from Configure (mostly)
    push @@no, "DB_File" unless $config->{i_db};
    push @@no, "GDBM_File" unless $config->{i_gdbm};
    push @@no, "I18N-Langinfo" unless $config->{i_langinfo} && $config->{d_nl_langinfo};
    push @@no, "IPC-SysV" unless $config->{d_msg} || $config->{d_sem} || $config->{d_shm};
    push @@no, "NDBM_File" unless $config->{d_ndbm};
    push @@no, "ODBM_File"
      unless ($config->{i_dbm} || $config->{i_rpcsvcdbm}) && !$config->{d_cplusplus};
    push @@no, "Amiga.*" unless $^O eq "amigaos";
    push @@no, "VMS.*" unless $^O eq "VMS";
    push @@no, "Win32.*" unless $^O eq "MSWin32" || $^O eq "cygwin";

    $no = join('|', @@no);
    $no = qr/^(?:$no)$/i;
}

my %ext;
my %static;

sub set_static_extensions {
    # adjust results of scan_ext, and also save
    # statics in case scan_ext hasn't been called yet.
    # if '*' is passed then all XS extensions are static
    # (with possible exclusions)
    %static = ();
    my @@list = @@_;
    if (@@_ and $_[0] eq '*') {
	my %excl = map {$_=>1} map {m/^!(.*)$/} @@_[1 .. $#_];
	@@list = grep {!exists $excl{$_}} keys %ext;
    }
    for (@@list) {
        $static{$_} = 1;
        $ext{$_} = 'static' if $ext{$_} && $ext{$_} eq 'dynamic';
    }

    # Encode is a special case.  If we are building Encode as a static
    # extension, we need to explicitly list its subextensions as well.
    # For other nested extensions, this is handled automatically by
    # the appropriate Makefile.PL.
    if ($ext{Encode} && $ext{Encode} eq 'static') {
        require File::Find;
        File::Find::find({
                          no_chdir => 1,
                          wanted => sub {
                              return unless m!\b(Encode/.+)/Makefile\.PL!;
                              $static{$1} = 1;
                              $ext{$1} = 'static';
                          },
                         }, "../cpan/Encode");
    }
}

sub _ext_eq {
    my $key = shift;
    sub {
        sort grep $ext{$_} eq $key, keys %ext;
    }
}

*dynamic_ext = _ext_eq('dynamic');
*static_ext = _ext_eq('static');
*nonxs_ext = _ext_eq('nonxs');

sub extensions {
    sort grep $ext{$_} ne 'known', keys %ext;
}

sub known_extensions {
    sort keys %ext;
}

sub is_static
{
 return $ext{$_[0]} eq 'static'
}

sub has_xs_or_c {
    my $dir = shift;
    opendir my $dh, $dir or die "opendir $dir: $!";
    while (defined (my $item = readdir $dh)) {
        return 1 if $item =~ /\.xs$/;
        return 1 if $item =~ /\.c$/;
    }
    return 0;
}

# Function to find available extensions, ignoring DynaLoader
sub scan_ext
{
    my $ext_dir = shift;
    opendir my $dh, "$ext_dir";
    while (defined (my $item = readdir $dh)) {
        next if $item =~ /^\.\.?$/;
        next if $item eq "DynaLoader";
        next unless -d "$ext_dir/$item";
        my $this_ext = $item;
        my $leaf = $item;

        $this_ext =~ s!-!/!g;
        $leaf =~ s/.*-//;

        # List/Util.xs lives in Scalar-List-Utils, Cwd.xs lives in PathTools
        $this_ext = 'List/Util' if $this_ext eq 'Scalar/List/Utils';
        $this_ext = 'Cwd'       if $this_ext eq 'PathTools';

	# Temporary hack to cope with smokers that are not clearing directories:
        next if $ext{$this_ext};

        if (has_xs_or_c("$ext_dir/$item")) {
            $ext{$this_ext} = $static{$this_ext} ? 'static' : 'dynamic';
        } else {
            $ext{$this_ext} = 'nonxs';
        }
        $ext{$this_ext} = 'known' if $item =~ $no;
    }
}

1;
# ex: set ts=8 sts=4 sw=4 et:
@


1.1
log
@Initial revision
@
text
@d3 1
a3 4
our $VERSION = '1.00';

# We (probably) have not got a Config.pm yet 
BEGIN { $INC{'Config.pm'} = __FILE__ };
d6 1
a6 3
use File::Find;
use File::Basename;
use Cwd;
d8 2
a9 2
my $no = join('|',qw(DynaLoader GDBM_File ODBM_File NDBM_File DB_File
		     Syslog SysV Langinfo));
d12 22
d35 48
a82 10
my $ext;
sub scan_ext
{
 my $here = getcwd();
 my $dir  = shift;
 chdir($dir) || die "Cannot cd to $dir\n";
 ($ext = getcwd()) =~ s,/,\\,g;
 find(\&find_ext,'.');
 chdir($here) || die "Cannot cd to $here\n";
 my @@ext = extensions();
d85 2
a86 3
sub dynamic_extensions
{
 return grep $ext{$_} eq 'dynamic',keys %ext;
d89 1
a89 1
sub noxs_extensions
d91 1
a91 1
 return grep $ext{$_} eq 'nonxs',keys %ext;
d94 8
a101 3
sub extensions
{
 return keys %ext;
d104 2
a105 1
sub find_ext
d107 25
a131 18
 if (/^(.*)\.pm$/i || /^(.*)_pm\.PL$/i || /^(.*)\.xs$/i)
  {
   my $name = $1;
   return if $name =~ $no; 
   my $dir = $File::Find::dir; 
   $dir =~ s,./,,;
   return if exists $ext{$dir};
   return unless -f "$ext/$dir/Makefile.PL";
   if ($dir =~ /$name$/i)
    {
     if (-f "$ext/$dir/$name.xs")
      {
       $ext{$dir} = 'dynamic'; 
      }
     else
      {
       $ext{$dir} = 'nonxs'; 
      }
a132 1
  }
d136 1
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d3 4
a6 1
our $VERSION = '1.01';
d9 3
a11 1
use warnings;
d13 1
a13 1
my $no = join('|',qw(GDBM_File ODBM_File NDBM_File DB_File
a18 19
my %static;

sub getcwd {
    $ENV{'PWD'} = Win32::GetCwd();
    $ENV{'PWD'} =~ s:\\:/:g ;
    return $ENV{'PWD'};
}

sub set_static_extensions
{
    # adjust results of scan_ext, and also save
    # statics in case scan_ext hasn't been called yet.
    %static = ();
    for (@@_) {
        $static{$_} = 1;
        $ext{$_} = 'static' if $ext{$_} && $ext{$_} eq 'dynamic';
    }
}

d25 1
a25 1
 find_ext('');
d30 1
a30 6
sub dynamic_ext
{
 return sort grep $ext{$_} eq 'dynamic',keys %ext;
}

sub static_ext
d32 1
a32 1
 return sort grep $ext{$_} eq 'static',keys %ext;
d35 1
a35 1
sub nonxs_ext
d37 1
a37 1
 return sort grep $ext{$_} eq 'nonxs',keys %ext;
d42 1
a42 12
 return sort grep $ext{$_} ne 'known',keys %ext;
}

sub known_extensions
{
 # faithfully copy Configure in not including nonxs extensions for the nonce
 return sort grep $ext{$_} ne 'nonxs',keys %ext;
}

sub is_static
{
 return $ext{$_[0]} eq 'static'
a44 2
# Function to recursively find available extensions, ignoring DynaLoader
# NOTE: recursion limit of 10 to prevent runaway in case of symlink madness
d47 18
a64 26
    opendir my $dh, '.';
    my @@items = grep { !/^\.\.?$/ } readdir $dh;
    closedir $dh;
    for my $xxx (@@items) {
        if ($xxx ne "DynaLoader") {
            if (-f "$xxx/$xxx.xs") {
                $ext{"$_[0]$xxx"} = $static{"$_[0]$xxx"} ? 'static' : 'dynamic';
            } elsif (-f "$xxx/Makefile.PL") {
                $ext{"$_[0]$xxx"} = 'nonxs';
            } else {
                if (-d $xxx && @@_ < 10) {
                    chdir $xxx;
                    find_ext("$_[0]$xxx/", @@_);
                    chdir "..";
                }
            }
            $ext{"$_[0]$xxx"} = 'known' if $ext{"$_[0]$xxx"} && $xxx =~ $no;
        }
    }

# Special case:  Add in threads/shared since it is not picked up by the
# recursive find above (and adding in general recursive finding breaks
# SDBM_File/sdbm).  A.D.  10/25/2001.

    if (!$_[0] && -d "threads/shared") {
        $ext{"threads/shared"} = 'dynamic';
d66 1
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.02';
d17 3
a19 4
    $_ = `cd`;
    chomp;
    s:\\:/:g ;
    return $ENV{'PWD'} = $_;
d22 2
a23 1
sub set_static_extensions {
a25 2
    # if '*' is passed then all XS extensions are static
    # (with possible exclusions)
d27 1
a27 6
    my @@list = @@_;
    if ($_[0] eq '*') {
	my %excl = map {$_=>1} map {m/^!(.*)$/} @@_[1 .. $#_];
	@@list = grep {!exists $excl{$_}} keys %ext;
    }
    for (@@list) {
d84 1
a84 1
            if (-f "$xxx/$xxx.xs" || -f "$xxx/$xxx.c" ) {
d99 3
a101 5
# Special case:  Add in modules that nest beyond the first level.
# Currently threads/shared and Hash/Util/FieldHash, since they are
# not picked up by the recursive find above (and adding in general
# recursive finding breaks SDBM_File/sdbm).
# A.D. 20011025 (SDBM), ajgough 20071008 (FieldHash)
a104 3
    }
    if (!$_[0] && -d "Hash/Util/FieldHash") {
        $ext{"Hash/Util/FieldHash"} = 'dynamic';
@


1.1.1.4
log
@import perl 5.10.1
@
text
@d9 1
a9 1
                     VMS Sys-Syslog IPC-SysV I18N-Langinfo));
d13 1
d16 7
d42 12
a53 3
    my $dir  = shift;
    find_ext("$dir/");
    extensions();
d56 8
a63 5
sub _ext_eq {
    my $key = shift;
    sub {
        sort grep $ext{$_} eq $key, keys %ext;
    }
d66 3
a68 9
*dynamic_ext = _ext_eq('dynamic');
*static_ext = _ext_eq('static');
*nonxs_ext = _ext_eq('nonxs');

sub _ext_ne {
    my $key = shift;
    sub {
        sort grep $ext{$_} ne $key, keys %ext;
    }
d71 5
a75 3
*extensions = _ext_ne('known');
# faithfully copy Configure in not including nonxs extensions for the nonce
*known_extensions = _ext_ne('nonxs');
d82 2
a83 1
# Function to find available extensions, ignoring DynaLoader
d86 17
a102 16
    my $ext_dir = shift;
    opendir my $dh, "$ext_dir";
    while (defined (my $item = readdir $dh)) {
        next if $item =~ /^\.\.?$/;
        next if $item eq "DynaLoader";
        next unless -d "$ext_dir$item";
        my $this_ext = $item;
        my $leaf = $item;

        $this_ext =~ s!-!/!g;
        $leaf =~ s/.*-//;

        if (-f "$ext_dir$item/$leaf.xs" || -f "$ext_dir$item/$leaf.c" ) {
            $ext{$this_ext} = $static{$this_ext} ? 'static' : 'dynamic';
        } else {
            $ext{$this_ext} = 'nonxs';
d104 13
a116 1
        $ext{$this_ext} = 'known' if $ext{$this_ext} && $item =~ $no;
a120 6
# Local variables:
# cperl-indent-level: 4
# indent-tabs-mode: nil
# End:
#
# ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.5
log
@Perl 5.12.2 from CPAN
@
text
@d9 1
a9 1
                     VMS VMS-DCLsym VMS-Stdio Sys-Syslog IPC-SysV I18N-Langinfo));
a65 10
sub has_xs_or_c {
    my $dir = shift;
    opendir my $dh, $dir or die "opendir $dir: $!";
    while (defined (my $item = readdir $dh)) {
        return 1 if $item =~ /\.xs$/;
        return 1 if $item =~ /\.c$/;
    }
    return 0;
}

d81 1
a81 4
	# Temporary hack to cope with smokers that are not clearing directories:
        next if $ext{$this_ext};

        if (has_xs_or_c("$ext_dir$item")) {
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a11 19
sub apply_config {
    my ($config) = @@_;
    my @@no;

    # duplicates logic from Configure (mostly)
    push @@no, "DB_File" unless $config->{i_db};
    push @@no, "GDBM_File" unless $config->{i_gdbm};
    push @@no, "I18N-Langinfo" unless $config->{i_langinfo} && $config->{i_nl_langinfo};
    push @@no, "IPC-SysV" unless $config->{d_msg} || $config->{d_sem} || $config->{d_shm};
    push @@no, "NDBM_File" unless $config->{d_ndbm};
    push @@no, "ODBM_File"
      unless ($config->{i_dbm} || $config->{i_rpcsvcdbm}) && !$config->{d_cplusplus};
    push @@no, "VMS.*" unless $^O eq "VMS";
    push @@no, "Win32.*" unless $^O eq "MSWin32" || $^O eq "cygwin";

    $no = join('|', @@no);
    $no = qr/^(?:$no)$/i;
}

d22 1
a22 1
    if (@@_ and $_[0] eq '*') {
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
                     VMS.* Sys-Syslog IPC-SysV I18N-Langinfo));
a15 2
    push @@no, 'Sys-Syslog' if $^O eq 'MSWin32';

d19 1
a19 1
    push @@no, "I18N-Langinfo" unless $config->{i_langinfo} && $config->{d_nl_langinfo};
d49 1
d51 5
a55 15
    # Encode is a special case.  If we are building Encode as a static
    # extension, we need to explicitly list its subextensions as well.
    # For other nested extensions, this is handled automatically by
    # the appropriate Makefile.PL.
    if ($ext{Encode} && $ext{Encode} eq 'static') {
        require File::Find;
        File::Find::find({
                          no_chdir => 1,
                          wanted => sub {
                              return unless m!\b(Encode/.+)/Makefile\.PL!;
                              $static{$1} = 1;
                              $ext{$1} = 'static';
                          },
                         }, "../cpan/Encode");
    }
d69 5
a73 2
sub extensions {
    sort grep $ext{$_} ne 'known', keys %ext;
d76 3
a78 3
sub known_extensions {
    sort keys %ext;
}
d96 1
a96 1
sub scan_ext
d103 1
a103 1
        next unless -d "$ext_dir/$item";
a109 4
        # List/Util.xs lives in Scalar-List-Utils, Cwd.xs lives in PathTools
        $this_ext = 'List/Util' if $this_ext eq 'Scalar/List/Utils';
        $this_ext = 'Cwd'       if $this_ext eq 'PathTools';

d113 1
a113 1
        if (has_xs_or_c("$ext_dir/$item")) {
d118 1
a118 1
        $ext{$this_ext} = 'known' if $item =~ $no;
@


