head	1.8;
access;
symbols
	PERL_5_24_2:1.1.1.6
	OPENBSD_6_1:1.8.0.4
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.12
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.6
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.8
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.7.0.2
	OPENBSD_5_7_BASE:1.7
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.7.0.4
	OPENBSD_5_6_BASE:1.7
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.3.0.14
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.12
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.10
	OPENBSD_3_7_BASE:1.3
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.3.0.8
	OPENBSD_3_6_BASE:1.3
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2017.02.05.00.32.22;	author afresh1;	state Exp;
branches;
next	1.7;
commitid	cxJ08BvJA9Pt2PTM;

1.7
date	2014.03.24.15.05.34;	author afresh1;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.12.18.30.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.29.17.36.22;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.28.19.23.15;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.22.58.33;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.30.00.47.29;	author millert;	state dead;
branches;
next	1.1;

1.1
date	97.11.30.08.06.46;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.14;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2006.03.28.18.49.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.19.06;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.11.08;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.03.24.14.59.13;	author afresh1;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2017.08.14.13.46.27;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.8
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#define PERL_NO_GET_CONTEXT
#define WIN32_LEAN_AND_MEAN
#define WIN32IO_IS_STDIO
#include <tchar.h>
#ifdef __GNUC__
#define Win32_Winsock
#endif
#include <windows.h>

#include <sys/stat.h>
#include "EXTERN.h"
#include "perl.h"

#ifdef PERLIO_LAYERS

#include "perliol.h"

#define NO_XSLOCKS
#include "XSUB.h"


/* Bottom-most level for Win32 case */

typedef struct
{
 struct _PerlIO base;       /* The generic part */
 HANDLE		h;          /* OS level handle */
 IV		refcnt;     /* REFCNT for the "fd" this represents */
 int		fd;         /* UNIX like file descriptor - index into fdtable */
} PerlIOWin32;

PerlIOWin32 *fdtable[256];
IV max_open_fd = -1;

IV
PerlIOWin32_popped(pTHX_ PerlIO *f)
{
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 if (--s->refcnt > 0)
  {
   *f = PerlIOBase(f)->next;
   return 1;
  }
 fdtable[s->fd] = NULL;
 return 0;
}

IV
PerlIOWin32_fileno(pTHX_ PerlIO *f)
{
 return PerlIOSelf(f,PerlIOWin32)->fd;
}

IV
PerlIOWin32_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
{
 IV code = PerlIOBase_pushed(aTHX_ f,mode,arg,tab);
 if (*PerlIONext(f))
  {
   PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
   s->fd     = PerlIO_fileno(PerlIONext(f));
  }
 PerlIOBase(f)->flags |= PERLIO_F_OPEN;

 Perl_ck_warner_d(aTHX_
		  packWARN(WARN_EXPERIMENTAL__WIN32_PERLIO),
		  "PerlIO layer ':win32' is experimental");

 return code;
}

PerlIO *
PerlIOWin32_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *f, int narg, SV **args)
{
 const char *tmode = mode;
 HANDLE h = INVALID_HANDLE_VALUE;
 if (f)
  {
   /* Close if already open */
   if (PerlIOBase(f)->flags & PERLIO_F_OPEN)
    (*PerlIOBase(f)->tab->Close)(aTHX_ f);
  }
 if (narg > 0)
  {
   char *path = SvPV_nolen(*args);
   DWORD  access = 0;
   /* CRT uses _SH_DENYNO for open(), this the Win32 equivelent */
   DWORD  share  = FILE_SHARE_READ | FILE_SHARE_WRITE;
   DWORD  create = -1;
   DWORD  attr   = FILE_ATTRIBUTE_NORMAL;
   if (stricmp(path, "/dev/null")==0)
    path = "NUL";
   if (*mode == '#')
    {
     /* sysopen - imode is UNIX-like O_RDONLY etc.
        - do_open has converted that back to string form in mode as well
        - perm is UNIX like permissions
      */
     mode++;
    }
   else
    {
     /* Normal open - decode mode string */
    }
   switch(*mode)
    {
     case 'r':
      access  = GENERIC_READ;
      create  = OPEN_EXISTING;
      if (*++mode == '+')
       {
        access |= GENERIC_WRITE;
        create  = OPEN_ALWAYS;
        mode++;
       }
      break;

     case 'w':
      access  = GENERIC_WRITE;
      create  = TRUNCATE_EXISTING;
      if (*++mode == '+')
       {
        access |= GENERIC_READ;
        mode++;
       }
      break;

     case 'a':
      access = GENERIC_WRITE;
      create  = OPEN_ALWAYS;
      if (*++mode == '+')
       {
        access |= GENERIC_READ;
        mode++;
       }
      break;
    }
   if (*mode == 'b')
    {
     mode++;
    }
   else if (*mode == 't')
    {
     mode++;
    }
   if (*mode || create == -1)
    {
     SETERRNO(EINVAL,LIB$_INVARG);
     return NULL;
    }
   h = CreateFile(path,access,share,NULL,create,attr,NULL);
   if (h == INVALID_HANDLE_VALUE)
    {
     if (create == TRUNCATE_EXISTING)
      h = CreateFile(path,access,share,NULL,(create = OPEN_ALWAYS),attr,NULL);
    }
  }
 else
  {
   /* fd open */
   h = INVALID_HANDLE_VALUE;
   if (fd >= 0 && fd <= max_open_fd)
    {
     PerlIOWin32 *s = fdtable[fd];
     if (s)
      {
       s->refcnt++;
       if (!f)
        f = PerlIO_allocate(aTHX);
       *f = &s->base;
       return f;
      }
    }
   if (*mode == 'I')
    {
     mode++;
     switch(fd)
      {
       case 0:
        h = GetStdHandle(STD_INPUT_HANDLE);
        break;
       case 1:
        h = GetStdHandle(STD_OUTPUT_HANDLE);
        break;
       case 2:
        h = GetStdHandle(STD_ERROR_HANDLE);
        break;
      }
    }
  }
 if (h != INVALID_HANDLE_VALUE)
  fd = win32_open_osfhandle((intptr_t) h, PerlIOUnix_oflags(tmode));
 if (fd >= 0)
  {
   PerlIOWin32 *s;
   if (!f)
    f = PerlIO_allocate(aTHX);
   s = PerlIOSelf(PerlIO_push(aTHX_ f,self,tmode,PerlIOArg),PerlIOWin32);
   s->h      = h;
   s->fd     = fd;
   s->refcnt = 1;
   if (fd >= 0)
    {
     fdtable[fd] = s;
     if (fd > max_open_fd)
      max_open_fd = fd;
    }
   return f;
  }
 if (f)
  {
   /* FIXME: pop layers ??? */
  }
 return NULL;
}

SSize_t
PerlIOWin32_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
{
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 DWORD len;
 if (!(PerlIOBase(f)->flags & PERLIO_F_CANREAD))
  return 0;
 if (ReadFile(s->h,vbuf,count,&len,NULL))
  {
   return len;
  }
 else
  {
   if (GetLastError() != NO_ERROR)
    {
     PerlIOBase(f)->flags |= PERLIO_F_ERROR;
     PerlIO_save_errno(f);
     return -1;
    }
   else
    {
     if (count != 0)
      PerlIOBase(f)->flags |= PERLIO_F_EOF;
     return 0;
    }
  }
}

SSize_t
PerlIOWin32_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 DWORD len;
 if (WriteFile(s->h,vbuf,count,&len,NULL))
  {
   return len;
  }
 else
  {
   PerlIOBase(f)->flags |= PERLIO_F_ERROR;
   PerlIO_save_errno(f);
   return -1;
  }
}

IV
PerlIOWin32_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
{
 static const DWORD where[3] = { FILE_BEGIN, FILE_CURRENT, FILE_END };
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
#if Off_t_size >= 8
 DWORD high = (DWORD)(offset >> 32);
#else
 DWORD high = 0;
#endif
 DWORD low  = (DWORD) offset;
 DWORD res  = SetFilePointer(s->h,(LONG)low,(LONG *)&high,where[whence]);
 if (res != 0xFFFFFFFF || GetLastError() != NO_ERROR)
  {
   return 0;
  }
 else
  {
   return -1;
  }
}

Off_t
PerlIOWin32_tell(pTHX_ PerlIO *f)
{
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 DWORD high = 0;
 DWORD res  = SetFilePointer(s->h,0,(LONG *)&high,FILE_CURRENT);
 if (res != 0xFFFFFFFF || GetLastError() != NO_ERROR)
  {
#if Off_t_size >= 8
   return ((Off_t) high << 32) | res;
#else
   return res;
#endif
  }
 return (Off_t) -1;
}

IV
PerlIOWin32_close(pTHX_ PerlIO *f)
{
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 if (s->refcnt == 1)
  {
   IV code = 0;	
#if 0
   /* This does not do pipes etc. correctly */	
   if (!CloseHandle(s->h))
    {
     s->h = INVALID_HANDLE_VALUE;
     return -1;
    }
#else
    PerlIOBase(f)->flags &= ~PERLIO_F_OPEN;
    return win32_close(s->fd);
#endif
  }
 return 0;
}

PerlIO *
PerlIOWin32_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *params, int flags)
{
 PerlIOWin32 *os = PerlIOSelf(f,PerlIOWin32);
 HANDLE proc = GetCurrentProcess();
 HANDLE new_h;
 if (DuplicateHandle(proc, os->h, proc, &new_h, 0, FALSE,  DUPLICATE_SAME_ACCESS))
  {
   char mode[8];
   int fd = win32_open_osfhandle((intptr_t) new_h, PerlIOUnix_oflags(PerlIO_modestr(o,mode)));
   if (fd >= 0)
    {
     f = PerlIOBase_dup(aTHX_ f, o, params, flags);
     if (f)
      {
       PerlIOWin32 *fs = PerlIOSelf(f,PerlIOWin32);
       fs->h  = new_h;
       fs->fd = fd;
       fs->refcnt = 1;
       fdtable[fd] = fs;
       if (fd > max_open_fd)
        max_open_fd = fd;
      }
     else
      {
       win32_close(fd);
      }
    }
   else
    {
     CloseHandle(new_h);
    }
  }
 return f;
}

PERLIO_FUNCS_DECL(PerlIO_win32) = {
 sizeof(PerlIO_funcs),
 "win32",
 sizeof(PerlIOWin32),
 PERLIO_K_RAW,
 PerlIOWin32_pushed,
 PerlIOWin32_popped,
 PerlIOWin32_open,
 PerlIOBase_binmode,
 NULL,                 /* getarg */
 PerlIOWin32_fileno,
 PerlIOWin32_dup,
 PerlIOWin32_read,
 PerlIOBase_unread,
 PerlIOWin32_write,
 PerlIOWin32_seek,
 PerlIOWin32_tell,
 PerlIOWin32_close,
 PerlIOBase_noop_ok,   /* flush */
 PerlIOBase_noop_fail, /* fill */
 PerlIOBase_eof,
 PerlIOBase_error,
 PerlIOBase_clearerr,
 PerlIOBase_setlinebuf,
 NULL, /* get_base */
 NULL, /* get_bufsiz */
 NULL, /* get_ptr */
 NULL, /* get_cnt */
 NULL, /* set_ptrcnt */
};

#endif

@


1.7
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d64 5
d87 2
a88 1
   DWORD  share  = 0;
d91 2
a150 2
   if (!(access & GENERIC_WRITE))
    share = FILE_SHARE_READ;
d233 1
d257 1
@


1.6
log
@Merge in perl 5.10.1; part two
@
text
@d320 2
a321 2
 HANDLE new;
 if (DuplicateHandle(proc, os->h, proc, &new, 0, FALSE,  DUPLICATE_SAME_ACCESS))
d324 1
a324 1
   int fd = win32_open_osfhandle((intptr_t) new, PerlIOUnix_oflags(PerlIO_modestr(o,mode)));
d331 1
a331 1
       fs->h  = new;
d345 1
a345 1
     CloseHandle(new);
@


1.5
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d259 5
a263 1
 DWORD high = (sizeof(offset) > sizeof(DWORD)) ? (DWORD)(offset >> 32) : 0;
d284 1
d286 3
@


1.4
log
@merge in perl 5.8.8
@
text
@d343 1
a343 1
PerlIO_funcs PerlIO_win32 = {
@


1.3
log
@The 5.8.0 import didn't bring this file back to life; do it by hand.
@
text
@d261 1
a261 1
 DWORD res  = SetFilePointer(s->h,low,&high,where[whence]);
d277 1
a277 1
 DWORD res  = SetFilePointer(s->h,0,&high,FILE_CURRENT);
@


1.2
log
@more cruft
@
text
@d1 1
a1 5

#ifdef __cplusplus
extern "C" {
#endif

d4 4
a7 1
#define EXT
d9 1
a9 3
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
d11 4
a14 13
#include <sys/socket.h>
#include <fcntl.h>
#include <assert.h>
#include <errno.h>
#include <process.h>
#include <direct.h>
#include "win32iop.h"

/*
 * The following is just a basic wrapping of the stdio
 *
 *  redirected io subsystem for all XS modules
 */
d16 9
a24 2
static int *
dummy_errno(void)
d26 8
a33 2
    return (&(errno));
}
d35 2
a36 2
static char ***
dummy_environ(void)
d38 8
a45 1
    return (&(_environ));
d48 2
a49 3
/* the rest are the remapped stdio routines */
static FILE *
dummy_stderr(void)
d51 1
a51 1
    return stderr;
d54 2
a55 2
static FILE *
dummy_stdin(void)
d57 8
a64 1
    return stdin;
d67 2
a68 2
static FILE *
dummy_stdout(void)
d70 139
a208 1
    return stdout;
d211 2
a212 2
static int
dummy_globalmode(int mode)
d214 22
a235 4
    int o = _fmode;
    _fmode = mode;

    return o;
d238 14
a251 109
#if defined(_DLL) || defined(__BORLANDC__)
/* It may or may not be fixed (ok on NT), but DLL runtime
   does not export the functions used in the workround
*/
#define WIN95_OSFHANDLE_FIXED
#endif

#if defined(_WIN32) && !defined(WIN95_OSFHANDLE_FIXED) && defined(_M_IX86)

#	ifdef __cplusplus
#define EXT_C_FUNC	extern "C"
#	else
#define EXT_C_FUNC	extern
#	endif

EXT_C_FUNC int __cdecl _alloc_osfhnd(void);
EXT_C_FUNC int __cdecl _set_osfhnd(int fh, long value);
EXT_C_FUNC void __cdecl _lock_fhandle(int);
EXT_C_FUNC void __cdecl _unlock_fhandle(int);
EXT_C_FUNC void __cdecl _unlock(int);

#if	(_MSC_VER >= 1000)
typedef struct	{
    long osfhnd;    /* underlying OS file HANDLE */
    char osfile;    /* attributes of file (e.g., open in text mode?) */
    char pipech;    /* one char buffer for handles opened on pipes */
#if defined (_MT) && !defined (DLL_FOR_WIN32S)
    int lockinitflag;
    CRITICAL_SECTION lock;
#endif  /* defined (_MT) && !defined (DLL_FOR_WIN32S) */
}	ioinfo;

EXT_C_FUNC ioinfo * __pioinfo[];

#define IOINFO_L2E			5
#define IOINFO_ARRAY_ELTS	(1 << IOINFO_L2E)
#define _pioinfo(i)	(__pioinfo[i >> IOINFO_L2E] + (i & (IOINFO_ARRAY_ELTS - 1)))
#define _osfile(i)	(_pioinfo(i)->osfile)

#else	/* (_MSC_VER >= 1000) */
extern char _osfile[];
#endif	/* (_MSC_VER >= 1000) */

#define FOPEN			0x01	/* file handle open */
#define FAPPEND			0x20	/* file handle opened O_APPEND */
#define FDEV			0x40	/* file handle refers to device */
#define FTEXT			0x80	/* file handle is in text mode */

#define _STREAM_LOCKS   26		/* Table of stream locks */
#define _LAST_STREAM_LOCK  (_STREAM_LOCKS+_NSTREAM_-1)	/* Last stream lock */
#define _FH_LOCKS          (_LAST_STREAM_LOCK+1)	/* Table of fh locks */

/***
*int _patch_open_osfhandle(long osfhandle, int flags) - open C Runtime file handle
*
*Purpose:
*       This function allocates a free C Runtime file handle and associates
*       it with the Win32 HANDLE specified by the first parameter. This is a
*		temperary fix for WIN95's brain damage GetFileType() error on socket
*		we just bypass that call for socket
*
*Entry:
*       long osfhandle - Win32 HANDLE to associate with C Runtime file handle.
*       int flags      - flags to associate with C Runtime file handle.
*
*Exit:
*       returns index of entry in fh, if successful
*       return -1, if no free entry is found
*
*Exceptions:
*
*******************************************************************************/

int
my_open_osfhandle(long osfhandle, int flags)
{
    int fh;
    char fileflags;		/* _osfile flags */

    /* copy relevant flags from second parameter */
    fileflags = FDEV;

    if(flags & O_APPEND)
	fileflags |= FAPPEND;

    if(flags & O_TEXT)
	fileflags |= FTEXT;

    /* attempt to allocate a C Runtime file handle */
    if((fh = _alloc_osfhnd()) == -1) {
	errno = EMFILE;		/* too many open files */
	_doserrno = 0L;		/* not an OS error */
	return -1;		/* return error to caller */
    }

    /* the file is open. now, set the info in _osfhnd array */
    _set_osfhnd(fh, osfhandle);

    fileflags |= FOPEN;		/* mark as open */

#if (_MSC_VER >= 1000)
    _osfile(fh) = fileflags;	/* set osfile entry */
    _unlock_fhandle(fh);
#else
    _osfile[fh] = fileflags;	/* set osfile entry */
    _unlock(fh+_FH_LOCKS);		/* unlock handle */
#endif

    return fh;			/* return handle */
a252 1
#else
d254 2
a255 2
int __cdecl
my_open_osfhandle(long osfhandle, int flags)
d257 13
a269 1
    return _open_osfhandle(osfhandle, flags);
a270 1
#endif	/* _M_IX86 */
d272 2
a273 2
long
my_get_osfhandle( int filehandle )
d275 8
a282 1
    return _get_osfhandle(filehandle);
d285 17
a301 2
#ifdef __BORLANDC__
#define _chdir chdir
d303 3
d307 2
a308 8
/* simulate flock by locking a range on the file */


#define LK_ERR(f,i)	((f) ? (i = 0) : (errno = GetLastError()))
#define LK_LEN		0xffff0000

int
my_flock(int fd, int oper)
d310 28
a337 28
    OVERLAPPED o;
    int i = -1;
    HANDLE fh;

    fh = (HANDLE)my_get_osfhandle(fd);
    memset(&o, 0, sizeof(o));

    switch(oper) {
    case LOCK_SH:		/* shared lock */
	LK_ERR(LockFileEx(fh, 0, 0, LK_LEN, 0, &o),i);
	break;
    case LOCK_EX:		/* exclusive lock */
	LK_ERR(LockFileEx(fh, LOCKFILE_EXCLUSIVE_LOCK, 0, LK_LEN, 0, &o),i);
	break;
    case LOCK_SH|LOCK_NB:	/* non-blocking shared lock */
	LK_ERR(LockFileEx(fh, LOCKFILE_FAIL_IMMEDIATELY, 0, LK_LEN, 0, &o),i);
	break;
    case LOCK_EX|LOCK_NB:	/* non-blocking exclusive lock */
	LK_ERR(LockFileEx(fh,
		       LOCKFILE_EXCLUSIVE_LOCK|LOCKFILE_FAIL_IMMEDIATELY,
		       0, LK_LEN, 0, &o),i);
	break;
    case LOCK_UN:		/* unlock lock */
	LK_ERR(UnlockFileEx(fh, 0, LK_LEN, 0, &o),i);
	break;
    default:			/* unknown */
	errno = EINVAL;
	break;
d339 2
a340 1
    return i;
d343 29
a371 83
#undef LK_ERR
#undef LK_LEN

EXT int		my_fclose(FILE *pf);

#ifdef PERLDLL
__declspec(dllexport)
#endif
WIN32_IOSUBSYSTEM	win32stdio = {
    12345678L,		/* begin of structure; */
    dummy_errno,	/* (*pfunc_errno)(void); */
    dummy_environ,	/* (*pfunc_environ)(void); */
    dummy_stdin,	/* (*pfunc_stdin)(void); */
    dummy_stdout,	/* (*pfunc_stdout)(void); */
    dummy_stderr,	/* (*pfunc_stderr)(void); */
    ferror,		/* (*pfunc_ferror)(FILE *fp); */
    feof,		/* (*pfunc_feof)(FILE *fp); */
    strerror,		/* (*strerror)(int e); */
    vfprintf,		/* (*pfunc_vfprintf)(FILE *pf, const char *format, va_list arg); */
    vprintf,		/* (*pfunc_vprintf)(const char *format, va_list arg); */
    fread,		/* (*pfunc_fread)(void *buf, size_t size, size_t count, FILE *pf); */
    fwrite,		/* (*pfunc_fwrite)(void *buf, size_t size, size_t count, FILE *pf); */
    fopen,		/* (*pfunc_fopen)(const char *path, const char *mode); */
    fdopen,		/* (*pfunc_fdopen)(int fh, const char *mode); */
    freopen,		/* (*pfunc_freopen)(const char *path, const char *mode, FILE *pf); */
    my_fclose,		/* (*pfunc_fclose)(FILE *pf); */
    fputs,		/* (*pfunc_fputs)(const char *s,FILE *pf); */
    fputc,		/* (*pfunc_fputc)(int c,FILE *pf); */
    ungetc,		/* (*pfunc_ungetc)(int c,FILE *pf); */
    getc,		/* (*pfunc_getc)(FILE *pf); */
    fileno,		/* (*pfunc_fileno)(FILE *pf); */
    clearerr,		/* (*pfunc_clearerr)(FILE *pf); */
    fflush,		/* (*pfunc_fflush)(FILE *pf); */
    ftell,		/* (*pfunc_ftell)(FILE *pf); */
    fseek,		/* (*pfunc_fseek)(FILE *pf,long offset,int origin); */
    fgetpos,		/* (*pfunc_fgetpos)(FILE *pf,fpos_t *p); */
    fsetpos,		/* (*pfunc_fsetpos)(FILE *pf,fpos_t *p); */
    rewind,		/* (*pfunc_rewind)(FILE *pf); */
    tmpfile,		/* (*pfunc_tmpfile)(void); */
    abort,		/* (*pfunc_abort)(void); */
    fstat,  		/* (*pfunc_fstat)(int fd,struct stat *bufptr); */
    stat,		/* (*pfunc_stat)(const char *name,struct stat *bufptr); */
    _pipe,		/* (*pfunc_pipe)( int *phandles, unsigned int psize, int textmode ); */
    _popen,		/* (*pfunc_popen)( const char *command, const char *mode ); */
    _pclose,		/* (*pfunc_pclose)( FILE *pf); */
    setmode,		/* (*pfunc_setmode)( int fd, int mode); */
    lseek,		/* (*pfunc_lseek)( int fd, long offset, int origin); */
    tell,		/* (*pfunc_tell)( int fd); */
    dup,		/* (*pfunc_dup)( int fd); */
    dup2,		/* (*pfunc_dup2)(int h1, int h2); */
    open,		/* (*pfunc_open)(const char *path, int oflag,...); */
    close,		/* (*pfunc_close)(int fd); */
    eof,		/* (*pfunc_eof)(int fd); */
    read,		/* (*pfunc_read)(int fd, void *buf, unsigned int cnt); */
    write,		/* (*pfunc_write)(int fd, const void *buf, unsigned int cnt); */
    dummy_globalmode,	/* (*pfunc_globalmode)(int mode) */
    my_open_osfhandle,
    my_get_osfhandle,
    spawnvp,
    mkdir,
    rmdir,
    chdir,
    my_flock,		/* (*pfunc_flock)(int fd, int oper) */
    execvp,
    perror,
    setbuf,
    setvbuf,
    flushall,
    fcloseall,
    fgets,
    gets,
    fgetc,
    putc,
    puts,
    getchar,
    putchar,
    fscanf,
    scanf,
    malloc,
    calloc,
    realloc,
    free,
    87654321L,		/* end of structure */
a373 3

#ifdef __cplusplus
}
@


1.1
log
@perl 5.004_04
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@d1 5
a5 1
#define PERL_NO_GET_CONTEXT
d8 1
a8 4
#include <tchar.h>
#ifdef __GNUC__
#define Win32_Winsock
#endif
d10 3
a12 1

d14 13
a26 4
#include "EXTERN.h"
#include "perl.h"

#ifdef PERLIO_LAYERS
d28 2
a29 9
#include "perliol.h"

#define NO_XSLOCKS
#include "XSUB.h"


/* Bottom-most level for Win32 case */

typedef struct
d31 2
a32 8
 struct _PerlIO base;       /* The generic part */
 HANDLE		h;          /* OS level handle */
 IV		refcnt;     /* REFCNT for the "fd" this represents */
 int		fd;         /* UNIX like file descriptor - index into fdtable */
} PerlIOWin32;

PerlIOWin32 *fdtable[256];
IV max_open_fd = -1;
d34 2
a35 2
IV
PerlIOWin32_popped(pTHX_ PerlIO *f)
d37 1
a37 8
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 if (--s->refcnt > 0)
  {
   *f = PerlIOBase(f)->next;
   return 1;
  }
 fdtable[s->fd] = NULL;
 return 0;
d40 3
a42 2
IV
PerlIOWin32_fileno(pTHX_ PerlIO *f)
d44 1
a44 1
 return PerlIOSelf(f,PerlIOWin32)->fd;
d47 2
a48 2
IV
PerlIOWin32_pushed(pTHX_ PerlIO *f, const char *mode, SV *arg, PerlIO_funcs *tab)
d50 1
a50 8
 IV code = PerlIOBase_pushed(aTHX_ f,mode,arg,tab);
 if (*PerlIONext(f))
  {
   PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
   s->fd     = PerlIO_fileno(PerlIONext(f));
  }
 PerlIOBase(f)->flags |= PERLIO_F_OPEN;
 return code;
d53 2
a54 2
PerlIO *
PerlIOWin32_open(pTHX_ PerlIO_funcs *self, PerlIO_list_t *layers, IV n, const char *mode, int fd, int imode, int perm, PerlIO *f, int narg, SV **args)
d56 1
a56 139
 const char *tmode = mode;
 HANDLE h = INVALID_HANDLE_VALUE;
 if (f)
  {
   /* Close if already open */
   if (PerlIOBase(f)->flags & PERLIO_F_OPEN)
    (*PerlIOBase(f)->tab->Close)(aTHX_ f);
  }
 if (narg > 0)
  {
   char *path = SvPV_nolen(*args);
   DWORD  access = 0;
   DWORD  share  = 0;
   DWORD  create = -1;
   DWORD  attr   = FILE_ATTRIBUTE_NORMAL;
   if (*mode == '#')
    {
     /* sysopen - imode is UNIX-like O_RDONLY etc.
        - do_open has converted that back to string form in mode as well
        - perm is UNIX like permissions
      */
     mode++;
    }
   else
    {
     /* Normal open - decode mode string */
    }
   switch(*mode)
    {
     case 'r':
      access  = GENERIC_READ;
      create  = OPEN_EXISTING;
      if (*++mode == '+')
       {
        access |= GENERIC_WRITE;
        create  = OPEN_ALWAYS;
        mode++;
       }
      break;

     case 'w':
      access  = GENERIC_WRITE;
      create  = TRUNCATE_EXISTING;
      if (*++mode == '+')
       {
        access |= GENERIC_READ;
        mode++;
       }
      break;

     case 'a':
      access = GENERIC_WRITE;
      create  = OPEN_ALWAYS;
      if (*++mode == '+')
       {
        access |= GENERIC_READ;
        mode++;
       }
      break;
    }
   if (*mode == 'b')
    {
     mode++;
    }
   else if (*mode == 't')
    {
     mode++;
    }
   if (*mode || create == -1)
    {
     SETERRNO(EINVAL,LIB$_INVARG);
     return NULL;
    }
   if (!(access & GENERIC_WRITE))
    share = FILE_SHARE_READ;
   h = CreateFile(path,access,share,NULL,create,attr,NULL);
   if (h == INVALID_HANDLE_VALUE)
    {
     if (create == TRUNCATE_EXISTING)
      h = CreateFile(path,access,share,NULL,(create = OPEN_ALWAYS),attr,NULL);
    }
  }
 else
  {
   /* fd open */
   h = INVALID_HANDLE_VALUE;
   if (fd >= 0 && fd <= max_open_fd)
    {
     PerlIOWin32 *s = fdtable[fd];
     if (s)
      {
       s->refcnt++;
       if (!f)
        f = PerlIO_allocate(aTHX);
       *f = &s->base;
       return f;
      }
    }
   if (*mode == 'I')
    {
     mode++;
     switch(fd)
      {
       case 0:
        h = GetStdHandle(STD_INPUT_HANDLE);
        break;
       case 1:
        h = GetStdHandle(STD_OUTPUT_HANDLE);
        break;
       case 2:
        h = GetStdHandle(STD_ERROR_HANDLE);
        break;
      }
    }
  }
 if (h != INVALID_HANDLE_VALUE)
  fd = win32_open_osfhandle((intptr_t) h, PerlIOUnix_oflags(tmode));
 if (fd >= 0)
  {
   PerlIOWin32 *s;
   if (!f)
    f = PerlIO_allocate(aTHX);
   s = PerlIOSelf(PerlIO_push(aTHX_ f,self,tmode,PerlIOArg),PerlIOWin32);
   s->h      = h;
   s->fd     = fd;
   s->refcnt = 1;
   if (fd >= 0)
    {
     fdtable[fd] = s;
     if (fd > max_open_fd)
      max_open_fd = fd;
    }
   return f;
  }
 if (f)
  {
   /* FIXME: pop layers ??? */
  }
 return NULL;
d59 2
a60 2
SSize_t
PerlIOWin32_read(pTHX_ PerlIO *f, void *vbuf, Size_t count)
d62 4
a65 22
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 DWORD len;
 if (!(PerlIOBase(f)->flags & PERLIO_F_CANREAD))
  return 0;
 if (ReadFile(s->h,vbuf,count,&len,NULL))
  {
   return len;
  }
 else
  {
   if (GetLastError() != NO_ERROR)
    {
     PerlIOBase(f)->flags |= PERLIO_F_ERROR;
     return -1;
    }
   else
    {
     if (count != 0)
      PerlIOBase(f)->flags |= PERLIO_F_EOF;
     return 0;
    }
  }
d68 109
a176 14
SSize_t
PerlIOWin32_write(pTHX_ PerlIO *f, const void *vbuf, Size_t count)
{
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 DWORD len;
 if (WriteFile(s->h,vbuf,count,&len,NULL))
  {
   return len;
  }
 else
  {
   PerlIOBase(f)->flags |= PERLIO_F_ERROR;
   return -1;
  }
d178 1
d180 2
a181 2
IV
PerlIOWin32_seek(pTHX_ PerlIO *f, Off_t offset, int whence)
d183 1
a183 13
 static const DWORD where[3] = { FILE_BEGIN, FILE_CURRENT, FILE_END };
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 DWORD high = (sizeof(offset) > sizeof(DWORD)) ? (DWORD)(offset >> 32) : 0;
 DWORD low  = (DWORD) offset;
 DWORD res  = SetFilePointer(s->h,low,&high,where[whence]);
 if (res != 0xFFFFFFFF || GetLastError() != NO_ERROR)
  {
   return 0;
  }
 else
  {
   return -1;
  }
d185 1
d187 2
a188 2
Off_t
PerlIOWin32_tell(pTHX_ PerlIO *f)
d190 1
a190 8
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 DWORD high = 0;
 DWORD res  = SetFilePointer(s->h,0,&high,FILE_CURRENT);
 if (res != 0xFFFFFFFF || GetLastError() != NO_ERROR)
  {
   return ((Off_t) high << 32) | res;
  }
 return (Off_t) -1;
d193 2
a194 17
IV
PerlIOWin32_close(pTHX_ PerlIO *f)
{
 PerlIOWin32 *s = PerlIOSelf(f,PerlIOWin32);
 if (s->refcnt == 1)
  {
   IV code = 0;	
#if 0
   /* This does not do pipes etc. correctly */	
   if (!CloseHandle(s->h))
    {
     s->h = INVALID_HANDLE_VALUE;
     return -1;
    }
#else
    PerlIOBase(f)->flags &= ~PERLIO_F_OPEN;
    return win32_close(s->fd);
a195 3
  }
 return 0;
}
d197 8
a204 2
PerlIO *
PerlIOWin32_dup(pTHX_ PerlIO *f, PerlIO *o, CLONE_PARAMS *params, int flags)
d206 28
a233 28
 PerlIOWin32 *os = PerlIOSelf(f,PerlIOWin32);
 HANDLE proc = GetCurrentProcess();
 HANDLE new;
 if (DuplicateHandle(proc, os->h, proc, &new, 0, FALSE,  DUPLICATE_SAME_ACCESS))
  {
   char mode[8];
   int fd = win32_open_osfhandle((intptr_t) new, PerlIOUnix_oflags(PerlIO_modestr(o,mode)));
   if (fd >= 0)
    {
     f = PerlIOBase_dup(aTHX_ f, o, params, flags);
     if (f)
      {
       PerlIOWin32 *fs = PerlIOSelf(f,PerlIOWin32);
       fs->h  = new;
       fs->fd = fd;
       fs->refcnt = 1;
       fdtable[fd] = fs;
       if (fd > max_open_fd)
        max_open_fd = fd;
      }
     else
      {
       win32_close(fd);
      }
    }
   else
    {
     CloseHandle(new);
d235 1
a235 2
  }
 return f;
d238 83
a320 29
PerlIO_funcs PerlIO_win32 = {
 sizeof(PerlIO_funcs),
 "win32",
 sizeof(PerlIOWin32),
 PERLIO_K_RAW,
 PerlIOWin32_pushed,
 PerlIOWin32_popped,
 PerlIOWin32_open,
 PerlIOBase_binmode,
 NULL,                 /* getarg */
 PerlIOWin32_fileno,
 PerlIOWin32_dup,
 PerlIOWin32_read,
 PerlIOBase_unread,
 PerlIOWin32_write,
 PerlIOWin32_seek,
 PerlIOWin32_tell,
 PerlIOWin32_close,
 PerlIOBase_noop_ok,   /* flush */
 PerlIOBase_noop_fail, /* fill */
 PerlIOBase_eof,
 PerlIOBase_error,
 PerlIOBase_clearerr,
 PerlIOBase_setlinebuf,
 NULL, /* get_base */
 NULL, /* get_bufsiz */
 NULL, /* get_ptr */
 NULL, /* get_cnt */
 NULL, /* set_ptrcnt */
d323 3
@


1.1.1.2
log
@perl 5.8.8 import
@
text
@d261 1
a261 1
 DWORD res  = SetFilePointer(s->h,(LONG)low,(LONG *)&high,where[whence]);
d277 1
a277 1
 DWORD res  = SetFilePointer(s->h,0,(LONG *)&high,FILE_CURRENT);
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d343 1
a343 1
PERLIO_FUNCS_DECL(PerlIO_win32) = {
@


1.1.1.4
log
@import perl 5.10.1
@
text
@d259 1
a259 5
#if Off_t_size >= 8
 DWORD high = (DWORD)(offset >> 32);
#else
 DWORD high = 0;
#endif
a279 1
#if Off_t_size >= 8
a280 3
#else
   return res;
#endif
@


1.1.1.5
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d320 2
a321 2
 HANDLE new_h;
 if (DuplicateHandle(proc, os->h, proc, &new_h, 0, FALSE,  DUPLICATE_SAME_ACCESS))
d324 1
a324 1
   int fd = win32_open_osfhandle((intptr_t) new_h, PerlIOUnix_oflags(PerlIO_modestr(o,mode)));
d331 1
a331 1
       fs->h  = new_h;
d345 1
a345 1
     CloseHandle(new_h);
@


1.1.1.6
log
@Import perl-5.24.2
@
text
@a63 5

 Perl_ck_warner_d(aTHX_
		  packWARN(WARN_EXPERIMENTAL__WIN32_PERLIO),
		  "PerlIO layer ':win32' is experimental");

d82 1
a82 2
   /* CRT uses _SH_DENYNO for open(), this the Win32 equivelent */
   DWORD  share  = FILE_SHARE_READ | FILE_SHARE_WRITE;
a84 2
   if (stricmp(path, "/dev/null")==0)
    path = "NUL";
d143 2
a226 1
     PerlIO_save_errno(f);
a249 1
   PerlIO_save_errno(f);
@


