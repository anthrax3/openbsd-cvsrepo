head	1.2;
access;
symbols
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.22
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.20
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.16
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.5.0.14
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.12
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.10
	OPENBSD_5_0:1.1.1.5.0.8
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.6
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.24
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.22
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.20
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.18
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.16
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.14
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.12
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.10
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.8
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.6
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2017.02.05.00.32.22;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.11.07;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.11.07;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.26.18;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.13;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.19.06;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.11.08;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.21;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/* vdir.h
 *
 * (c) 1999 Microsoft Corporation. All rights reserved. 
 * Portions (c) 1999 ActiveState Tool Corp, http://www.ActiveState.com/
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 */

#ifndef ___VDir_H___
#define ___VDir_H___

/*
 * Allow one slot for each possible drive letter
 * and one additional slot for a UNC name
 */
const int driveCount = ('Z'-'A')+1+1;
const int driveLetterCount = ('Z'-'A')+1;

class VDir
{
public:
    VDir(int bManageDir = 1);
    ~VDir() {};

    void Init(VDir* pDir, VMem *pMem);
    void SetDefaultA(char const *pDefault);
    void SetDefaultW(WCHAR const *pDefault);
    char* MapPathA(const char *pInName);
    WCHAR* MapPathW(const WCHAR *pInName);
    int SetCurrentDirectoryA(char *lpBuffer);
    int SetCurrentDirectoryW(WCHAR *lpBuffer);
    inline int GetDefault(void) { return nDefault; };

    inline char* GetCurrentDirectoryA(int dwBufSize, char *lpBuffer)
    {
	char* ptr = dirTableA[nDefault];
	while (--dwBufSize)
	{
	    if ((*lpBuffer++ = *ptr++) == '\0')
		break;
	}
        *lpBuffer = '\0';
	return /* unused */ NULL;
    };
    inline WCHAR* GetCurrentDirectoryW(int dwBufSize, WCHAR *lpBuffer)
    {
	WCHAR* ptr = dirTableW[nDefault];
	while (--dwBufSize)
	{
	    if ((*lpBuffer++ = *ptr++) == '\0')
		break;
	}
        *lpBuffer = '\0';
	return /* unused */ NULL;
    };

    DWORD CalculateEnvironmentSpace(void);
    LPSTR BuildEnvironmentSpace(LPSTR lpStr);

protected:
    int SetDirA(char const *pPath, int index);
    int SetDirW(WCHAR const *pPath, int index);
    void FromEnvA(char *pEnv, int index);
    void FromEnvW(WCHAR *pEnv, int index);

    inline const char *GetDefaultDirA(void)
    {
	return dirTableA[nDefault];
    };
    inline void SetDefaultDirA(char const *pPath, int index)
    {
	SetDirA(pPath, index);
	nDefault = index;
    };
    inline const WCHAR *GetDefaultDirW(void)
    {
	return dirTableW[nDefault];
    };
    inline void SetDefaultDirW(WCHAR const *pPath, int index)
    {
	SetDirW(pPath, index);
	nDefault = index;
    };
    inline const char *GetDirA(int index)
    {
	char *ptr = dirTableA[index];
	if (!ptr) {
	    /* simulate the existence of this drive */
	    ptr = szLocalBufferA;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };
    inline const WCHAR *GetDirW(int index)
    {
	WCHAR *ptr = dirTableW[index];
	if (!ptr) {
	    /* simulate the existence of this drive */
	    ptr = szLocalBufferW;
	    ptr[0] = 'A' + index;
	    ptr[1] = ':';
	    ptr[2] = '\\';
	    ptr[3] = 0;
	}
	return ptr;
    };

    inline int DriveIndex(char chr)
    {
	if (chr == '\\' || chr == '/')
	    return ('Z'-'A')+1;
	return (chr | 0x20)-'a';
    };

    VMem *pMem;
    int nDefault, bManageDirectory;
    char *dirTableA[driveCount];
    char szLocalBufferA[MAX_PATH+1];
    WCHAR *dirTableW[driveCount];
    WCHAR szLocalBufferW[MAX_PATH+1];
};


VDir::VDir(int bManageDir /* = 1 */)
{
    nDefault = 0;
    bManageDirectory = bManageDir;
    memset(dirTableA, 0, sizeof(dirTableA));
    memset(dirTableW, 0, sizeof(dirTableW));
}

void VDir::Init(VDir* pDir, VMem *p)
{
    int index;

    pMem = p;
    if (pDir) {
	for (index = 0; index < driveCount; ++index) {
	    SetDirW(pDir->GetDirW(index), index);
	}
	nDefault = pDir->GetDefault();
    }
    else {
	int bSave = bManageDirectory;
	DWORD driveBits = GetLogicalDrives();

	bManageDirectory = 0;
        WCHAR szBuffer[MAX_PATH*driveCount];
        if (GetLogicalDriveStringsW(sizeof(szBuffer), szBuffer)) {
            WCHAR* pEnv = GetEnvironmentStringsW();
            WCHAR* ptr = szBuffer;
            for (index = 0; index < driveCount; ++index) {
                if (driveBits & (1<<index)) {
                    ptr += SetDirW(ptr, index) + 1;
                    FromEnvW(pEnv, index);
                }
            }
            FreeEnvironmentStringsW(pEnv);
        }
        SetDefaultW(L".");
	bManageDirectory = bSave;
  }
}

int VDir::SetDirA(char const *pPath, int index)
{
    char chr, *ptr;
    int length = 0;
    WCHAR wBuffer[MAX_PATH+1];
    if (index < driveCount && pPath != NULL) {
	length = strlen(pPath);
	pMem->Free(dirTableA[index]);
	ptr = dirTableA[index] = (char*)pMem->Malloc(length+2);
	if (ptr != NULL) {
	    strcpy(ptr, pPath);
	    ptr += length-1;
	    chr = *ptr++;
	    if (chr != '\\' && chr != '/') {
		*ptr++ = '\\';
		*ptr = '\0';
	    }
	    MultiByteToWideChar(CP_ACP, 0, dirTableA[index], -1,
		    wBuffer, (sizeof(wBuffer)/sizeof(WCHAR)));
	    length = wcslen(wBuffer);
	    pMem->Free(dirTableW[index]);
	    dirTableW[index] = (WCHAR*)pMem->Malloc((length+1)*2);
	    if (dirTableW[index] != NULL) {
		wcscpy(dirTableW[index], wBuffer);
	    }
	}
    }

    if(bManageDirectory)
	::SetCurrentDirectoryA(pPath);

    return length;
}

void VDir::FromEnvA(char *pEnv, int index)
{   /* gets the directory for index from the environment variable. */
    while (*pEnv != '\0') {
	if ((pEnv[0] == '=') && (DriveIndex(pEnv[1]) == index)) {
	    SetDirA(&pEnv[4], index);
	    break;
	}
	else
	    pEnv += strlen(pEnv)+1;
    }
}

void VDir::FromEnvW(WCHAR *pEnv, int index)
{   /* gets the directory for index from the environment variable. */
    while (*pEnv != '\0') {
	if ((pEnv[0] == '=') && (DriveIndex((char)pEnv[1]) == index)) {
	    SetDirW(&pEnv[4], index);
	    break;
	}
	else
	    pEnv += wcslen(pEnv)+1;
    }
}

void VDir::SetDefaultA(char const *pDefault)
{
    char szBuffer[MAX_PATH+1];
    char *pPtr;

    if (GetFullPathNameA(pDefault, sizeof(szBuffer), szBuffer, &pPtr)) {
        if (*pDefault != '.' && pPtr != NULL)
	    *pPtr = '\0';

	SetDefaultDirA(szBuffer, DriveIndex(szBuffer[0]));
    }
}

int VDir::SetDirW(WCHAR const *pPath, int index)
{
    WCHAR chr, *ptr;
    int length = 0;
    if (index < driveCount && pPath != NULL) {
	length = wcslen(pPath);
	pMem->Free(dirTableW[index]);
	ptr = dirTableW[index] = (WCHAR*)pMem->Malloc((length+2)*2);
	if (ptr != NULL) {
            char *ansi;
	    wcscpy(ptr, pPath);
	    ptr += length-1;
	    chr = *ptr++;
	    if (chr != '\\' && chr != '/') {
		*ptr++ = '\\';
		*ptr = '\0';
	    }
            ansi = win32_ansipath(dirTableW[index]);
	    length = strlen(ansi);
	    pMem->Free(dirTableA[index]);
	    dirTableA[index] = (char*)pMem->Malloc(length+1);
	    if (dirTableA[index] != NULL) {
		strcpy(dirTableA[index], ansi);
	    }
            win32_free(ansi);
	}
    }

    if(bManageDirectory)
	::SetCurrentDirectoryW(pPath);

    return length;
}

void VDir::SetDefaultW(WCHAR const *pDefault)
{
    WCHAR szBuffer[MAX_PATH+1];
    WCHAR *pPtr;

    if (GetFullPathNameW(pDefault, (sizeof(szBuffer)/sizeof(WCHAR)), szBuffer, &pPtr)) {
        if (*pDefault != '.' && pPtr != NULL)
	    *pPtr = '\0';

	SetDefaultDirW(szBuffer, DriveIndex((char)szBuffer[0]));
    }
}

inline BOOL IsPathSep(char ch)
{
    return (ch == '\\' || ch == '/');
}

inline void DoGetFullPathNameA(char* lpBuffer, DWORD dwSize, char* Dest)
{
    char *pPtr;

    /*
     * On WinNT GetFullPathName does not fail, (or at least always
     * succeeds when the drive is valid) WinNT does set *Dest to NULL
     * On Win98 GetFullPathName will set last error if it fails, but
     * does not touch *Dest
     */
    *Dest = '\0';
    GetFullPathNameA(lpBuffer, dwSize, Dest, &pPtr);
}

inline bool IsSpecialFileName(const char* pName)
{
    /* specical file names are devices that the system can open
     * these include AUX, CON, NUL, PRN, COMx, LPTx, CLOCK$, CONIN$, CONOUT$
     * (x is a single digit, and names are case-insensitive)
     */
    char ch = (pName[0] & ~0x20);
    switch (ch)
    {
	case 'A': /* AUX */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'X')
		&& !pName[3])
		    return true;
	    break;
	case 'C': /* CLOCK$, COMx,  CON, CONIN$ CONOUT$ */
	    ch = (pName[1] & ~0x20);
	    switch (ch)
	    {
		case 'L': /* CLOCK$ */
		    if (((pName[2] & ~0x20) == 'O')
			&& ((pName[3] & ~0x20) == 'C')
			&& ((pName[4] & ~0x20) == 'K')
			&& (pName[5] == '$')
			&& !pName[6])
			    return true;
		    break;
		case 'O': /* COMx,  CON, CONIN$ CONOUT$ */
		    if ((pName[2] & ~0x20) == 'M') {
			if ((pName[3] >= '1') && (pName[3] <= '9')
			    && !pName[4])
			    return true;
		    }
		    else if ((pName[2] & ~0x20) == 'N') {
			if (!pName[3])
			    return true;
			else if ((pName[3] & ~0x20) == 'I') {
			    if (((pName[4] & ~0x20) == 'N')
				&& (pName[5] == '$')
				&& !pName[6])
			    return true;
			}
			else if ((pName[3] & ~0x20) == 'O') {
			    if (((pName[4] & ~0x20) == 'U')
				&& ((pName[5] & ~0x20) == 'T')
				&& (pName[6] == '$')
				&& !pName[7])
			    return true;
			}
		    }
		    break;
	    }
	    break;
	case 'L': /* LPTx */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'X')
		&& (pName[3] >= '1') && (pName[3] <= '9')
		&& !pName[4])
		    return true;
	    break;
	case 'N': /* NUL */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'L')
		&& !pName[3])
		    return true;
	    break;
	case 'P': /* PRN */
	    if (((pName[1] & ~0x20) == 'R')
		&& ((pName[2] & ~0x20) == 'N')
		&& !pName[3])
		    return true;
	    break;
    }
    return false;
}

char *VDir::MapPathA(const char *pInName)
{   /*
     * possiblities -- relative path or absolute path with or without drive letter
     * OR UNC name
     */
    int driveIndex;
    char szBuffer[(MAX_PATH+1)*2];
    char szlBuf[MAX_PATH+1];
    int length = strlen(pInName);

    if (!length)
	return (char*)pInName;

    if (length > MAX_PATH) {
	strncpy(szlBuf, pInName, MAX_PATH);
	if (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   
	    /* absolute path - reduce length by 2 for drive specifier */
	    szlBuf[MAX_PATH-2] = '\0';
	}
	else
	    szlBuf[MAX_PATH] = '\0';
	pInName = szlBuf;
    }
    /* strlen(pInName) is now <= MAX_PATH */

    if (length > 1 && pInName[1] == ':') {
	/* has drive letter */
	if (length > 2 && IsPathSep(pInName[2])) {
	    /* absolute with drive letter */
	    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);
	}
	else {
	    /* relative path with drive letter */
            driveIndex = DriveIndex(*pInName);
            if (driveIndex < 0 || driveIndex >= driveLetterCount)
                return (char *)pInName;
	    strcpy(szBuffer, GetDirA(driveIndex));
	    strcat(szBuffer, &pInName[2]);
	    if(strlen(szBuffer) > MAX_PATH)
		szBuffer[MAX_PATH] = '\0';

	    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);
	}
    }
    else {
	/* no drive letter */
	if (length > 1 && IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {
	    /* UNC name */
	    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);
	}
	else {
	    strcpy(szBuffer, GetDefaultDirA());
	    if (IsPathSep(pInName[0])) {
		/* absolute path */
		strcpy(&szBuffer[2], pInName);
		DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);
	    }
	    else {
		/* relative path */
		if (IsSpecialFileName(pInName)) {
		    return (char*)pInName;
		}
		else {
		    strcat(szBuffer, pInName);
		    if (strlen(szBuffer) > MAX_PATH)
			szBuffer[MAX_PATH] = '\0';

		    DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);
		}
	    }
	}
    }

    return szLocalBufferA;
}

int VDir::SetCurrentDirectoryA(char *lpBuffer)
{
    char *pPtr;
    int length, nRet = -1;

    pPtr = MapPathA(lpBuffer);
    length = strlen(pPtr);
    if(length > 3 && IsPathSep(pPtr[length-1])) {
	/* don't remove the trailing slash from 'x:\'  */
	pPtr[length-1] = '\0';
    }

    DWORD r = GetFileAttributesA(pPtr);
    if ((r != 0xffffffff) && (r & FILE_ATTRIBUTE_DIRECTORY))
    {
	char szBuffer[(MAX_PATH+1)*2];
	DoGetFullPathNameA(pPtr, sizeof(szBuffer), szBuffer);
	SetDefaultDirA(szBuffer, DriveIndex(szBuffer[0]));
	nRet = 0;
    }

    return nRet;
}

DWORD VDir::CalculateEnvironmentSpace(void)
{   /* the current directory environment strings are stored as '=D:=d:\path' */
    int index;
    DWORD dwSize = 0;
    for (index = 0; index < driveCount; ++index) {
	if (dirTableA[index] != NULL) {
	    dwSize += strlen(dirTableA[index]) + 5;  /* add 1 for trailing NULL and 4 for '=D:=' */
	}
    }
    return dwSize;
}

LPSTR VDir::BuildEnvironmentSpace(LPSTR lpStr)
{   /* store the current directory environment strings as '=D:=d:\path' */
    int index, length;
    LPSTR lpDirStr;
    for (index = 0; index < driveCount; ++index) {
	lpDirStr = dirTableA[index];
	if (lpDirStr != NULL) {
	    lpStr[0] = '=';
	    lpStr[1] = lpDirStr[0];
	    lpStr[2] = '\0';
	    CharUpper(&lpStr[1]);
	    lpStr[2] = ':';
	    lpStr[3] = '=';
	    strcpy(&lpStr[4], lpDirStr);
	    length = strlen(lpDirStr);
	    lpStr += length + 5; /* add 1 for trailing NULL and 4 for '=D:=' */
	    if (length > 3 && IsPathSep(lpStr[-2])) {
		lpStr[-2] = '\0';   /* remove the trailing path separator */
		--lpStr;
	    }
	}
    }
    return lpStr;
}

inline BOOL IsPathSep(WCHAR ch)
{
    return (ch == '\\' || ch == '/');
}

inline void DoGetFullPathNameW(WCHAR* lpBuffer, DWORD dwSize, WCHAR* Dest)
{
    WCHAR *pPtr;

    /*
     * On WinNT GetFullPathName does not fail, (or at least always
     * succeeds when the drive is valid) WinNT does set *Dest to NULL
     * On Win98 GetFullPathName will set last error if it fails, but
     * does not touch *Dest
     */
    *Dest = '\0';
    GetFullPathNameW(lpBuffer, dwSize, Dest, &pPtr);
}

inline bool IsSpecialFileName(const WCHAR* pName)
{
    /* specical file names are devices that the system can open
     * these include AUX, CON, NUL, PRN, COMx, LPTx, CLOCK$, CONIN$, CONOUT$
     * (x is a single digit, and names are case-insensitive)
     */
    WCHAR ch = (pName[0] & ~0x20);
    switch (ch)
    {
	case 'A': /* AUX */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'X')
		&& !pName[3])
		    return true;
	    break;
	case 'C': /* CLOCK$, COMx,  CON, CONIN$ CONOUT$ */
	    ch = (pName[1] & ~0x20);
	    switch (ch)
	    {
		case 'L': /* CLOCK$ */
		    if (((pName[2] & ~0x20) == 'O')
			&& ((pName[3] & ~0x20) == 'C')
			&& ((pName[4] & ~0x20) == 'K')
			&& (pName[5] == '$')
			&& !pName[6])
			    return true;
		    break;
		case 'O': /* COMx,  CON, CONIN$ CONOUT$ */
		    if ((pName[2] & ~0x20) == 'M') {
			if ((pName[3] >= '1') && (pName[3] <= '9')
			    && !pName[4])
			    return true;
		    }
		    else if ((pName[2] & ~0x20) == 'N') {
			if (!pName[3])
			    return true;
			else if ((pName[3] & ~0x20) == 'I') {
			    if (((pName[4] & ~0x20) == 'N')
				&& (pName[5] == '$')
				&& !pName[6])
			    return true;
			}
			else if ((pName[3] & ~0x20) == 'O') {
			    if (((pName[4] & ~0x20) == 'U')
				&& ((pName[5] & ~0x20) == 'T')
				&& (pName[6] == '$')
				&& !pName[7])
			    return true;
			}
		    }
		    break;
	    }
	    break;
	case 'L': /* LPTx */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'X')
		&& (pName[3] >= '1') && (pName[3] <= '9')
		&& !pName[4])
		    return true;
	    break;
	case 'N': /* NUL */
	    if (((pName[1] & ~0x20) == 'U')
		&& ((pName[2] & ~0x20) == 'L')
		&& !pName[3])
		    return true;
	    break;
	case 'P': /* PRN */
	    if (((pName[1] & ~0x20) == 'R')
		&& ((pName[2] & ~0x20) == 'N')
		&& !pName[3])
		    return true;
	    break;
    }
    return false;
}

WCHAR* VDir::MapPathW(const WCHAR *pInName)
{   /*
     * possiblities -- relative path or absolute path with or without drive letter
     * OR UNC name
     */
    int driveIndex;
    WCHAR szBuffer[(MAX_PATH+1)*2];
    WCHAR szlBuf[MAX_PATH+1];
    int length = wcslen(pInName);

    if (!length)
	return (WCHAR*)pInName;

    if (length > MAX_PATH) {
	wcsncpy(szlBuf, pInName, MAX_PATH);
	if (IsPathSep(pInName[0]) && !IsPathSep(pInName[1])) {   
	    /* absolute path - reduce length by 2 for drive specifier */
	    szlBuf[MAX_PATH-2] = '\0';
	}
	else
	    szlBuf[MAX_PATH] = '\0';
	pInName = szlBuf;
    }
    /* strlen(pInName) is now <= MAX_PATH */

    if (length > 1 && pInName[1] == ':') {
	/* has drive letter */
	if (IsPathSep(pInName[2])) {
	    /* absolute with drive letter */
	    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
	}
	else {
	    /* relative path with drive letter */
            driveIndex = DriveIndex(*pInName);
            if (driveIndex < 0 || driveIndex >= driveLetterCount)
                return (WCHAR *)pInName;
	    wcscpy(szBuffer, GetDirW(driveIndex));
	    wcscat(szBuffer, &pInName[2]);
	    if(wcslen(szBuffer) > MAX_PATH)
		szBuffer[MAX_PATH] = '\0';

	    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
	}
    }
    else {
	/* no drive letter */
	if (length > 1 && IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {
	    /* UNC name */
	    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
	}
	else {
	    wcscpy(szBuffer, GetDefaultDirW());
	    if (IsPathSep(pInName[0])) {
		/* absolute path */
		wcscpy(&szBuffer[2], pInName);
		DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
	    }
	    else {
		/* relative path */
		if (IsSpecialFileName(pInName)) {
		    return (WCHAR*)pInName;
		}
		else {
		    wcscat(szBuffer, pInName);
		    if (wcslen(szBuffer) > MAX_PATH)
			szBuffer[MAX_PATH] = '\0';

		    DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
		}
	    }
	}
    }
    return szLocalBufferW;
}

int VDir::SetCurrentDirectoryW(WCHAR *lpBuffer)
{
    WCHAR *pPtr;
    int length, nRet = -1;

    pPtr = MapPathW(lpBuffer);
    length = wcslen(pPtr);
    if(length > 3 && IsPathSep(pPtr[length-1])) {
	/* don't remove the trailing slash from 'x:\'  */
	pPtr[length-1] = '\0';
    }

    DWORD r = GetFileAttributesW(pPtr);
    if ((r != 0xffffffff) && (r & FILE_ATTRIBUTE_DIRECTORY))
    {
	WCHAR wBuffer[(MAX_PATH+1)*2];
	DoGetFullPathNameW(pPtr, (sizeof(wBuffer)/sizeof(WCHAR)), wBuffer);
	SetDefaultDirW(wBuffer, DriveIndex((char)wBuffer[0]));
	nRet = 0;
    }

    return nRet;
}

#endif	/* ___VDir_H___ */
@


1.1
log
@Initial revision
@
text
@d13 6
a18 1
const int driveCount = 30;
d38 1
a38 1
	while (dwBufSize--)
d43 2
a44 1
	return lpBuffer;
d49 1
a49 1
	while (dwBufSize--)
d54 2
a55 1
	return lpBuffer;
a57 1

d63 1
d65 2
a70 1

a75 1
    int SetDirW(WCHAR const *pPath, int index);
a79 1

d89 1
a89 1
	    /* simulate the existance of this drive */
d102 1
a102 1
	    /* simulate the existance of this drive */
d114 2
a138 3
    DWORD driveBits;
    int nSave;
    char szBuffer[MAX_PATH*driveCount];
d148 3
a150 1
	nSave = bManageDirectory;
d152 15
a166 15
	driveBits = GetLogicalDrives();
	if (GetLogicalDriveStrings(sizeof(szBuffer), szBuffer)) {
	    char* pEnv = GetEnvironmentStrings();
	    char* ptr = szBuffer;
	    for (index = 0; index < driveCount; ++index) {
		if (driveBits & (1<<index)) {
		    ptr += SetDirA(ptr, index) + 1;
		    FromEnvA(pEnv, index);
		}
	    }
	    FreeEnvironmentStrings(pEnv);
	}
	SetDefaultA(".");
	bManageDirectory = nSave;
    }
d215 12
a242 1
    char szBuffer[MAX_PATH+1];
d249 1
d257 2
a258 2
	    WideCharToMultiByte(CP_ACP, 0, dirTableW[index], -1, szBuffer, sizeof(szBuffer), NULL, NULL);
	    length = strlen(szBuffer);
d262 1
a262 1
		strcpy(dirTableA[index], szBuffer);
d264 1
d298 1
a298 1
     * succeeds when the drive is valid) WinNT does set *Dest to Nullch
d387 1
d390 4
d395 1
a395 1
    if (strlen(pInName) > MAX_PATH) {
d407 1
a407 1
    if (pInName[1] == ':') {
d409 1
a409 1
	if (IsPathSep(pInName[2])) {
d411 1
a411 1
	    strcpy(szLocalBufferA, pInName);
d415 4
a418 1
	    strcpy(szBuffer, GetDirA(DriveIndex(*pInName)));
d428 1
a428 1
	if (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {
d430 1
a430 1
	    strcpy(szLocalBufferA, pInName);
d436 2
a437 3
		szLocalBufferA[0] = szBuffer[0];
		szLocalBufferA[1] = szBuffer[1];
		strcpy(&szLocalBufferA[2], pInName);
d460 1
a460 3
    HANDLE hHandle;
    WIN32_FIND_DATA win32FD;
    char szBuffer[MAX_PATH+1], *pPtr;
d463 5
a467 8
    GetFullPathNameA(MapPathA(lpBuffer), sizeof(szBuffer), szBuffer, &pPtr);
    /* if the last char is a '\\' or a '/' then add
     * an '*' before calling FindFirstFile
     */
    length = strlen(szBuffer);
    if(length > 0 && IsPathSep(szBuffer[length-1])) {
	szBuffer[length] = '*';
	szBuffer[length+1] = '\0';
d470 5
a474 8
    hHandle = FindFirstFileA(szBuffer, &win32FD);
    if (hHandle != INVALID_HANDLE_VALUE) {
        FindClose(hHandle);

	/* if an '*' was added remove it */
	if(szBuffer[length] == '*')
	    szBuffer[length] = '\0';

d478 1
d483 1
a483 1
{   /* the current directory environment strings are stored as '=d=d:\path' */
d488 1
a488 1
	    dwSize += strlen(dirTableA[index]) + 4;  /* add 1 for trailing NULL and 3 for '=d=' */
d495 2
a496 2
{   /* store the current directory environment strings as '=d=d:\path' */
    int index;
d503 11
a513 3
	    lpStr[2] = '=';
	    strcpy(&lpStr[3], lpDirStr);
	    lpStr += strlen(lpDirStr) + 4; /* add 1 for trailing NULL and 3 for '=d=' */
d530 1
a530 1
     * succeeds when the drive is valid) WinNT does set *Dest to Nullch
d619 1
d622 1
d624 4
a627 1
    if (wcslen(pInName) > MAX_PATH) {
d639 1
a639 1
    if (pInName[1] == ':') {
d643 1
a643 1
	    wcscpy(szLocalBufferW, pInName);
d647 4
a650 1
	    wcscpy(szBuffer, GetDirW(DriveIndex((char)*pInName)));
d660 1
a660 1
	if (IsPathSep(pInName[1]) && IsPathSep(pInName[0])) {
d662 1
a662 1
	    wcscpy(szLocalBufferW, pInName);
d668 2
a669 3
		szLocalBufferW[0] = szBuffer[0];
		szLocalBufferW[1] = szBuffer[1];
		wcscpy(&szLocalBufferW[2], pInName);
d691 1
a691 3
    HANDLE hHandle;
    WIN32_FIND_DATAW win32FD;
    WCHAR szBuffer[MAX_PATH+1], *pPtr;
d694 5
a698 8
    GetFullPathNameW(MapPathW(lpBuffer), (sizeof(szBuffer)/sizeof(WCHAR)), szBuffer, &pPtr);
    /* if the last char is a '\\' or a '/' then add
     * an '*' before calling FindFirstFile
     */
    length = wcslen(szBuffer);
    if(length > 0 && IsPathSep(szBuffer[length-1])) {
	szBuffer[length] = '*';
	szBuffer[length+1] = '\0';
d701 6
a706 9
    hHandle = FindFirstFileW(szBuffer, &win32FD);
    if (hHandle != INVALID_HANDLE_VALUE) {
        FindClose(hHandle);

	/* if an '*' was added remove it */
	if(szBuffer[length] == '*')
	    szBuffer[length] = '\0';

	SetDefaultDirW(szBuffer, DriveIndex((char)szBuffer[0]));
d709 1
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d13 1
a13 5
/*
 * Allow one slot for each possible drive letter
 * and one additional slot for a UNC name
 */
const int driveCount = ('Z'-'A')+1+1;
a107 2
	if (chr == '\\' || chr == '/')
	    return ('Z'-'A')+1;
a368 1
    int length = strlen(pInName);
d370 1
a370 4
    if (!length)
	return (char*)pInName;

    if (length > MAX_PATH) {
d433 3
a435 1
    char *pPtr;
d438 8
a445 5
    pPtr = MapPathA(lpBuffer);
    length = strlen(pPtr);
    if(length > 3 && IsPathSep(pPtr[length-1])) {
	/* don't remove the trailing slash from 'x:\'  */
	pPtr[length-1] = '\0';
d448 8
a455 5
    DWORD r = GetFileAttributesA(pPtr);
    if ((r != 0xffffffff) && (r & FILE_ATTRIBUTE_DIRECTORY))
    {
	char szBuffer[(MAX_PATH+1)*2];
	DoGetFullPathNameA(pPtr, sizeof(szBuffer), szBuffer);
a458 1

d463 1
a463 1
{   /* the current directory environment strings are stored as '=D:=d:\path' */
d468 1
a468 1
	    dwSize += strlen(dirTableA[index]) + 5;  /* add 1 for trailing NULL and 4 for '=D:=' */
d475 2
a476 2
{   /* store the current directory environment strings as '=D:=d:\path' */
    int index, length;
d483 3
a485 11
	    lpStr[2] = '\0';
	    CharUpper(&lpStr[1]);
	    lpStr[2] = ':';
	    lpStr[3] = '=';
	    strcpy(&lpStr[4], lpDirStr);
	    length = strlen(lpDirStr);
	    lpStr += length + 5; /* add 1 for trailing NULL and 4 for '=D:=' */
	    if (length > 3 && IsPathSep(lpStr[-2])) {
		lpStr[-2] = '\0';   /* remove the trailing path separator */
		--lpStr;
	    }
a592 4
    int length = wcslen(pInName);

    if (!length)
	return (WCHAR*)pInName;
d594 1
a594 1
    if (length > MAX_PATH) {
d656 3
a658 1
    WCHAR *pPtr;
d661 8
a668 5
    pPtr = MapPathW(lpBuffer);
    length = wcslen(pPtr);
    if(length > 3 && IsPathSep(pPtr[length-1])) {
	/* don't remove the trailing slash from 'x:\'  */
	pPtr[length-1] = '\0';
d671 9
a679 6
    DWORD r = GetFileAttributesW(pPtr);
    if ((r != 0xffffffff) && (r & FILE_ATTRIBUTE_DIRECTORY))
    {
	WCHAR wBuffer[(MAX_PATH+1)*2];
	DoGetFullPathNameW(pPtr, (sizeof(wBuffer)/sizeof(WCHAR)), wBuffer);
	SetDefaultDirW(wBuffer, DriveIndex((char)wBuffer[0]));
a681 1

@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d396 1
a396 1
	    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);
d412 1
a412 1
	    DoGetFullPathNameA((char*)pInName, sizeof(szLocalBufferA), szLocalBufferA);
d418 3
a420 2
		strcpy(&szBuffer[2], pInName);
		DoGetFullPathNameA(szBuffer, sizeof(szLocalBufferA), szLocalBufferA);
d625 1
a625 1
	    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
d641 1
a641 1
	    DoGetFullPathNameW((WCHAR*)pInName, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
d647 3
a649 2
		wcscpy(&szBuffer[2], pInName);
		DoGetFullPathNameW(szBuffer, (sizeof(szLocalBufferW)/sizeof(WCHAR)), szLocalBufferW);
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d37 1
a37 1
	while (--dwBufSize)
d42 1
a42 2
        *lpBuffer = '\0';
	return /* unused */ NULL;
d47 1
a47 1
	while (--dwBufSize)
d52 1
a52 2
        *lpBuffer = '\0';
	return /* unused */ NULL;
d55 1
a60 1
    int SetDirW(WCHAR const *pPath, int index);
a61 2
    void FromEnvW(WCHAR *pEnv, int index);

d66 1
d72 1
d77 1
d137 3
d149 1
a149 8
	int bSave = bManageDirectory;
	DWORD driveBits = GetLogicalDrives();
        OSVERSIONINFO osver;

        memset(&osver, 0, sizeof(osver));
        osver.dwOSVersionInfoSize = sizeof(osver);
        GetVersionEx(&osver);

d151 15
a165 32
        if (osver.dwMajorVersion < 5) {
            char szBuffer[MAX_PATH*driveCount];
            if (GetLogicalDriveStringsA(sizeof(szBuffer), szBuffer)) {
                char* pEnv = (char*)GetEnvironmentStringsA();
                char* ptr = szBuffer;
                for (index = 0; index < driveCount; ++index) {
                    if (driveBits & (1<<index)) {
                        ptr += SetDirA(ptr, index) + 1;
                        FromEnvA(pEnv, index);
                    }
                }
                FreeEnvironmentStringsA(pEnv);
            }
            SetDefaultA(".");
        }
        else { /* Windows 2000 or later */
            WCHAR szBuffer[MAX_PATH*driveCount];
            if (GetLogicalDriveStringsW(sizeof(szBuffer), szBuffer)) {
                WCHAR* pEnv = GetEnvironmentStringsW();
                WCHAR* ptr = szBuffer;
                for (index = 0; index < driveCount; ++index) {
                    if (driveBits & (1<<index)) {
                        ptr += SetDirW(ptr, index) + 1;
                        FromEnvW(pEnv, index);
                    }
                }
                FreeEnvironmentStringsW(pEnv);
            }
            SetDefaultW(L".");
        }
	bManageDirectory = bSave;
  }
a213 12
void VDir::FromEnvW(WCHAR *pEnv, int index)
{   /* gets the directory for index from the environment variable. */
    while (*pEnv != '\0') {
	if ((pEnv[0] == '=') && (DriveIndex((char)pEnv[1]) == index)) {
	    SetDirW(&pEnv[4], index);
	    break;
	}
	else
	    pEnv += wcslen(pEnv)+1;
    }
}

d230 1
a236 1
            char *ansi;
d244 2
a245 2
            ansi = win32_ansipath(dirTableW[index]);
	    length = strlen(ansi);
d249 1
a249 1
		strcpy(dirTableA[index], ansi);
a250 1
            win32_free(ansi);
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d319 1
a319 1
     * succeeds when the drive is valid) WinNT does set *Dest to NULL
d547 1
a547 1
     * succeeds when the drive is valid) WinNT does set *Dest to NULL
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d149 5
d156 25
a180 8
        WCHAR szBuffer[MAX_PATH*driveCount];
        if (GetLogicalDriveStringsW(sizeof(szBuffer), szBuffer)) {
            WCHAR* pEnv = GetEnvironmentStringsW();
            WCHAR* ptr = szBuffer;
            for (index = 0; index < driveCount; ++index) {
                if (driveBits & (1<<index)) {
                    ptr += SetDirW(ptr, index) + 1;
                    FromEnvW(pEnv, index);
d182 1
d184 1
a184 1
            FreeEnvironmentStringsW(pEnv);
a185 1
        SetDefaultW(L".");
@


