head	1.16;
access;
symbols
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.16
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.40.43;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.06.39;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.20;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.35.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.22.56;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.54;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.46;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.48;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.50.57;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.26;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.38;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.08;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.21.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.46;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.28;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.38;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.47.24;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.04;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.34;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.31;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.06.21;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.52.35;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@/*    cv.h
 *
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
 *
 *    You may distribute under the terms of either the GNU General Public
 *    License or the Artistic License, as specified in the README file.
 *
 */

/* This structure must match the beginning of XPVFM in sv.h  */

struct xpvcv {
    _XPV_HEAD;
    _XPVCV_COMMON;
};

/*
=head1 Handy Values

=for apidoc AmU||Nullcv
Null CV pointer.

(deprecated - use C<(CV *)NULL> instead)

=head1 CV Manipulation Functions

This section documents functions to manipulate CVs which are code-values,
or subroutines.  For more information, see L<perlguts>.

=for apidoc Am|HV*|CvSTASH|CV* cv
Returns the stash of the CV.  A stash is the symbol table hash, containing
the package-scoped variables in the package where the subroutine was defined.
For more information, see L<perlguts>.

This also has a special use with XS AUTOLOAD subs.
See L<perlguts/Autoloading with XSUBs>.

=cut
*/

#ifndef PERL_CORE
#  define Nullcv Null(CV*)
#endif

#define CvSTASH(sv)	(0+((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_stash)
#define CvSTASH_set(cv,st) Perl_cvstash_set(aTHX_ cv, st)
#define CvSTART(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_start_u.xcv_start
#define CvROOT(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_root_u.xcv_root
#define CvXSUB(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_root_u.xcv_xsub
#define CvXSUBANY(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_start_u.xcv_xsubany
#define CvGV(sv)	S_CvGV(aTHX_ (CV *)(sv))
#define CvGV_set(cv,gv)	Perl_cvgv_set(aTHX_ cv, gv)
#define CvHASGV(cv)	cBOOL(SvANY(cv)->xcv_gv_u.xcv_gv)
#define CvFILE(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_file
#ifdef USE_ITHREADS
#  define CvFILE_set_from_cop(sv, cop)	\
    (CvFILE(sv) = savepv(CopFILE(cop)), CvDYNFILE_on(sv))
#else
#  define CvFILE_set_from_cop(sv, cop)	\
    (CvFILE(sv) = CopFILE(cop), CvDYNFILE_off(sv))
#endif
#define CvFILEGV(sv)	(gv_fetchfile(CvFILE(sv)))
#define CvDEPTH(sv)	(*S_CvDEPTHp((const CV *)sv))
/* For use when you only have a XPVCV*, not a real CV*.
   Must be assert protected as in S_CvDEPTHp before use. */
#define CvDEPTHunsafe(sv) ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_depth

/* these CvPADLIST/CvRESERVED asserts can be reverted one day, once stabilized */
#define CvPADLIST(sv)	  (*(assert_(!CvISXSUB((CV*)(sv))) \
	&(((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_padlist_u.xcv_padlist)))
/* CvPADLIST_set is not public API, it can be removed one day, once stabilized */
#ifdef DEBUGGING
#  define CvPADLIST_set(sv, padlist) Perl_set_padlist((CV*)sv, padlist)
#else
#  define CvPADLIST_set(sv, padlist) (CvPADLIST(sv) = (padlist))
#endif
#define CvHSCXT(sv)	  *(assert_(CvISXSUB((CV*)(sv))) \
	&(((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_padlist_u.xcv_hscxt))
#ifdef DEBUGGING
#  if PTRSIZE == 8
#    define PoisonPADLIST(sv) \
        (((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_padlist_u.xcv_padlist = (PADLIST *)UINT64_C(0xEFEFEFEFEFEFEFEF))
#  elif PTRSIZE == 4
#    define PoisonPADLIST(sv) \
        (((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_padlist_u.xcv_padlist = (PADLIST *)0xEFEFEFEF)
#  else
#    error unknown pointer size
#  endif
#else
#  define PoisonPADLIST(sv) NOOP
#endif

#define CvOUTSIDE(sv)	  ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_outside
#define CvOUTSIDE_SEQ(sv) ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_outside_seq
#define CvFLAGS(sv)	  ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_flags

/* These two are sometimes called on non-CVs */
#define CvPROTO(sv)                               \
	(                                          \
	 SvPOK(sv)                                  \
	  ? SvTYPE(sv) == SVt_PVCV && CvAUTOLOAD(sv) \
	     ? SvEND(sv)+1 : SvPVX_const(sv)          \
	  : NULL                                       \
	)
#define CvPROTOLEN(sv)	                          \
	(                                          \
	 SvPOK(sv)                                  \
	  ? SvTYPE(sv) == SVt_PVCV && CvAUTOLOAD(sv) \
	     ? SvLEN(sv)-SvCUR(sv)-2                  \
	     : SvCUR(sv)                               \
	  : 0                                           \
	)

#define CVf_METHOD	0x0001	/* CV is explicitly marked as a method */
#define CVf_LVALUE	0x0002  /* CV return value can be used as lvalue */
#define CVf_CONST	0x0004  /* inlinable sub */
#define CVf_ISXSUB	0x0008	/* CV is an XSUB, not pure perl.  */

#define CVf_WEAKOUTSIDE	0x0010  /* CvOUTSIDE isn't ref counted */
#define CVf_CLONE	0x0020	/* anon CV uses external lexicals */
#define CVf_CLONED	0x0040	/* a clone of one of those */
#define CVf_ANON	0x0080	/* CV is not pointed to by a GV */
#define CVf_UNIQUE	0x0100	/* sub is only called once (eg PL_main_cv,
				 * require, eval). */
#define CVf_NODEBUG	0x0200	/* no DB::sub indirection for this CV
				   (esp. useful for special XSUBs) */
#define CVf_CVGV_RC	0x0400	/* CvGV is reference counted */
#ifdef PERL_CORE
# define CVf_SLABBED	0x0800	/* Holds refcount on op slab  */
#endif
#define CVf_DYNFILE	0x1000	/* The filename isn't static  */
#define CVf_AUTOLOAD	0x2000	/* SvPVX contains AUTOLOADed sub name  */
#define CVf_HASEVAL	0x4000	/* contains string eval  */
#define CVf_NAMED	0x8000  /* Has a name HEK */
#define CVf_LEXICAL	0x10000 /* Omit package from name */
#define CVf_ANONCONST	0x20000 /* :const - create anonconst op */

/* This symbol for optimised communication between toke.c and op.c: */
#define CVf_BUILTIN_ATTRS	(CVf_METHOD|CVf_LVALUE|CVf_ANONCONST)

#define CvCLONE(cv)		(CvFLAGS(cv) & CVf_CLONE)
#define CvCLONE_on(cv)		(CvFLAGS(cv) |= CVf_CLONE)
#define CvCLONE_off(cv)		(CvFLAGS(cv) &= ~CVf_CLONE)

#define CvCLONED(cv)		(CvFLAGS(cv) & CVf_CLONED)
#define CvCLONED_on(cv)		(CvFLAGS(cv) |= CVf_CLONED)
#define CvCLONED_off(cv)	(CvFLAGS(cv) &= ~CVf_CLONED)

#define CvANON(cv)		(CvFLAGS(cv) & CVf_ANON)
#define CvANON_on(cv)		(CvFLAGS(cv) |= CVf_ANON)
#define CvANON_off(cv)		(CvFLAGS(cv) &= ~CVf_ANON)

/* CvEVAL or CvSPECIAL */
#define CvUNIQUE(cv)		(CvFLAGS(cv) & CVf_UNIQUE)
#define CvUNIQUE_on(cv)		(CvFLAGS(cv) |= CVf_UNIQUE)
#define CvUNIQUE_off(cv)	(CvFLAGS(cv) &= ~CVf_UNIQUE)

#define CvNODEBUG(cv)		(CvFLAGS(cv) & CVf_NODEBUG)
#define CvNODEBUG_on(cv)	(CvFLAGS(cv) |= CVf_NODEBUG)
#define CvNODEBUG_off(cv)	(CvFLAGS(cv) &= ~CVf_NODEBUG)

#define CvMETHOD(cv)		(CvFLAGS(cv) & CVf_METHOD)
#define CvMETHOD_on(cv)		(CvFLAGS(cv) |= CVf_METHOD)
#define CvMETHOD_off(cv)	(CvFLAGS(cv) &= ~CVf_METHOD)

#define CvLVALUE(cv)		(CvFLAGS(cv) & CVf_LVALUE)
#define CvLVALUE_on(cv)		(CvFLAGS(cv) |= CVf_LVALUE)
#define CvLVALUE_off(cv)	(CvFLAGS(cv) &= ~CVf_LVALUE)

/* eval or PL_main_cv */
#define CvEVAL(cv)		(CvUNIQUE(cv) && !SvFAKE(cv))
#define CvEVAL_on(cv)		(CvUNIQUE_on(cv),SvFAKE_off(cv))
#define CvEVAL_off(cv)		CvUNIQUE_off(cv)

/* BEGIN|CHECK|INIT|UNITCHECK|END */
#define CvSPECIAL(cv)		(CvUNIQUE(cv) && SvFAKE(cv))
#define CvSPECIAL_on(cv)	(CvUNIQUE_on(cv),SvFAKE_on(cv))
#define CvSPECIAL_off(cv)	(CvUNIQUE_off(cv),SvFAKE_off(cv))

#define CvCONST(cv)		(CvFLAGS(cv) & CVf_CONST)
#define CvCONST_on(cv)		(CvFLAGS(cv) |= CVf_CONST)
#define CvCONST_off(cv)		(CvFLAGS(cv) &= ~CVf_CONST)

#define CvWEAKOUTSIDE(cv)	(CvFLAGS(cv) & CVf_WEAKOUTSIDE)
#define CvWEAKOUTSIDE_on(cv)	(CvFLAGS(cv) |= CVf_WEAKOUTSIDE)
#define CvWEAKOUTSIDE_off(cv)	(CvFLAGS(cv) &= ~CVf_WEAKOUTSIDE)

#define CvISXSUB(cv)		(CvFLAGS(cv) & CVf_ISXSUB)
#define CvISXSUB_on(cv)		(CvFLAGS(cv) |= CVf_ISXSUB)
#define CvISXSUB_off(cv)	(CvFLAGS(cv) &= ~CVf_ISXSUB)

#define CvCVGV_RC(cv)		(CvFLAGS(cv) & CVf_CVGV_RC)
#define CvCVGV_RC_on(cv)	(CvFLAGS(cv) |= CVf_CVGV_RC)
#define CvCVGV_RC_off(cv)	(CvFLAGS(cv) &= ~CVf_CVGV_RC)

#ifdef PERL_CORE
# define CvSLABBED(cv)		(CvFLAGS(cv) & CVf_SLABBED)
# define CvSLABBED_on(cv)	(CvFLAGS(cv) |= CVf_SLABBED)
# define CvSLABBED_off(cv)	(CvFLAGS(cv) &= ~CVf_SLABBED)
#endif

#define CvDYNFILE(cv)		(CvFLAGS(cv) & CVf_DYNFILE)
#define CvDYNFILE_on(cv)	(CvFLAGS(cv) |= CVf_DYNFILE)
#define CvDYNFILE_off(cv)	(CvFLAGS(cv) &= ~CVf_DYNFILE)

#define CvAUTOLOAD(cv)		(CvFLAGS(cv) & CVf_AUTOLOAD)
#define CvAUTOLOAD_on(cv)	(CvFLAGS(cv) |= CVf_AUTOLOAD)
#define CvAUTOLOAD_off(cv)	(CvFLAGS(cv) &= ~CVf_AUTOLOAD)

#define CvHASEVAL(cv)		(CvFLAGS(cv) & CVf_HASEVAL)
#define CvHASEVAL_on(cv)	(CvFLAGS(cv) |= CVf_HASEVAL)
#define CvHASEVAL_off(cv)	(CvFLAGS(cv) &= ~CVf_HASEVAL)

#define CvNAMED(cv)		(CvFLAGS(cv) & CVf_NAMED)
#define CvNAMED_on(cv)		(CvFLAGS(cv) |= CVf_NAMED)
#define CvNAMED_off(cv)		(CvFLAGS(cv) &= ~CVf_NAMED)

#define CvLEXICAL(cv)		(CvFLAGS(cv) & CVf_LEXICAL)
#define CvLEXICAL_on(cv)	(CvFLAGS(cv) |= CVf_LEXICAL)
#define CvLEXICAL_off(cv)	(CvFLAGS(cv) &= ~CVf_LEXICAL)

#define CvANONCONST(cv)		(CvFLAGS(cv) & CVf_ANONCONST)
#define CvANONCONST_on(cv)	(CvFLAGS(cv) |= CVf_ANONCONST)
#define CvANONCONST_off(cv)	(CvFLAGS(cv) &= ~CVf_ANONCONST)

/* Flags for newXS_flags  */
#define XS_DYNAMIC_FILENAME	0x01	/* The filename isn't static  */

PERL_STATIC_INLINE HEK *
CvNAME_HEK(CV *sv)
{
    return CvNAMED(sv)
	? ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv_u.xcv_hek
	: 0;
}
/* This lowers the refernce count of the previous value, but does *not*
   increment the reference count of the new value. */
#define CvNAME_HEK_set(cv, hek) ( \
	CvNAME_HEK((CV *)(cv))						 \
	    ? unshare_hek(SvANY((CV *)(cv))->xcv_gv_u.xcv_hek)	  \
	    : (void)0,						   \
	((XPVCV*)MUTABLE_PTR(SvANY(cv)))->xcv_gv_u.xcv_hek = (hek), \
	CvNAMED_on(cv)						     \
    )

/*
=head1 CV reference counts and CvOUTSIDE

=for apidoc m|bool|CvWEAKOUTSIDE|CV *cv

Each CV has a pointer, C<CvOUTSIDE()>, to its lexically enclosing
CV (if any).  Because pointers to anonymous sub prototypes are
stored in C<&> pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa.  To avoid the
ensuing memory leak, we do not increment the reference count of the CV
pointed to by C<CvOUTSIDE> in the I<one specific instance> that the parent
has a C<&> pad slot pointing back to us.  In this case, we set the
C<CvWEAKOUTSIDE> flag in the child.  This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.

There is a further complication with non-closure anonymous subs (i.e. those
that do not refer to any lexicals outside that sub).  In this case, the
anonymous prototype is shared rather than being cloned.  This has the
consequence that the parent may be freed while there are still active
children, I<e.g.>,

    BEGIN { $a = sub { eval '$x' } }

In this case, the BEGIN is freed immediately after execution since there
are no active references to it: the anon sub prototype has
C<CvWEAKOUTSIDE> set since it's not a closure, and $a points to the same
CV, so it doesn't contribute to BEGIN's refcount either.  When $a is
executed, the C<eval '$x'> causes the chain of C<CvOUTSIDE>s to be followed,
and the freed BEGIN is accessed.

To avoid this, whenever a CV and its associated pad is freed, any
C<&> entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's C<CvOUTSIDE> is set to point to its grandparent.  This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as C<$a> above).

One other thing to consider is that a CV may be merely undefined
rather than freed, eg C<undef &foo>.  In this case, its refcount may
not have reached zero, but we still delete its pad and its C<CvROOT> etc.
Since various children may still have their C<CvOUTSIDE> pointing at this
undefined CV, we keep its own C<CvOUTSIDE> for the time being, so that
the chain of lexical scopes is unbroken.  For example, the following
should print 123:

    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &tmp;
    print  $a->();

=cut
*/

typedef OP *(*Perl_call_checker)(pTHX_ OP *, GV *, SV *);

#define CALL_CHECKER_REQUIRE_GV	MGf_REQUIRE_GV

#define CV_NAME_NOTQUAL		1

#ifdef PERL_CORE
# define CV_UNDEF_KEEP_NAME	1
#endif

/*
 * ex: set ts=8 sts=4 sw=4 et:
 */
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d52 1
a52 1
#define CvGV(sv)	S_CvGV((const CV *)(sv))
d54 1
d65 30
a94 3
#define CvPADLIST(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_padlist
#define CvOUTSIDE(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_outside
#define CvFLAGS(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_flags
d96 1
d136 2
d140 1
a140 1
#define CVf_BUILTIN_ATTRS	(CVf_METHOD|CVf_LVALUE)
d219 8
a229 7
PERL_STATIC_INLINE GV *
S_CvGV(const CV *sv)
{
    return CvNAMED(sv)
	? 0
	: ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv_u.xcv_gv;
}
d267 1
a267 1
children, eg
d304 8
a312 6
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: nil
 * End:
 *
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d29 1
a29 1
or subroutines. For more information, see L<perlguts>.
d32 1
a32 1
Returns the stash of the CV. A stash is the symbol table hash, containing
d52 1
a52 1
#define CvGV(sv)	S_CvGV((CV *)(sv))
d192 1
a192 1
S_CvGV(CV *sv)
d221 1
a221 1
CV (if any). Because pointers to anonymous sub prototypes are
d223 1
a223 1
with the parent pointing to the child and vice-versa. To avoid the
d226 2
a227 2
has a C<&> pad slot pointing back to us. In this case, we set the
C<CvWEAKOUTSIDE> flag in the child. This allows us to determine under what
d232 2
a233 2
that do not refer to any lexicals outside that sub). In this case, the
anonymous prototype is shared rather than being cloned. This has the
d249 1
a249 1
child's C<CvOUTSIDE> is set to point to its grandparent. This will only
d254 1
a254 1
rather than freed, eg C<undef &foo>. In this case, its refcount may
d258 1
a258 1
the chain of lexical scopes is unbroken. For example, the following
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@a15 1
    I32	xcv_depth;	/* >= 2 indicates recursive call */
d52 1
a52 1
#define CvGV(sv)	(0+((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv)
d63 1
a63 8
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define CvDEPTH(sv) (*({const CV *const _cvdepth = (const CV *)sv; \
			  assert(SvTYPE(_cvdepth) == SVt_PVCV);	 \
			  &((XPVCV*)SvANY(_cvdepth))->xcv_depth; \
			}))
#else
#  define CvDEPTH(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_depth
#endif
d100 3
d105 2
d123 1
d140 1
d166 6
d180 8
d191 24
d276 1
a276 1
 * indent-tabs-mode: t
d279 1
a279 1
 * ex: set ts=8 sts=4 sw=4 noet:
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d11 1
a11 1
/* This structure must the beginning of XPVFM in sv.h  */
a14 1
    _XPVMG_HEAD;
d16 1
d29 3
d33 6
a38 1
Returns the stash of the CV.
d47 2
a48 1
#define CvSTASH(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_stash
d53 2
a54 1
#define CvGV(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv
d57 2
a58 1
#  define CvFILE_set_from_cop(sv, cop)	(CvFILE(sv) = savepv(CopFILE(cop)))
d60 2
a61 1
#  define CvFILE_set_from_cop(sv, cop)	(CvFILE(sv) = CopFILE(cop))
d67 1
a67 1
			  &((XPVCV*)SvANY(_cvdepth))->xiv_u.xivu_i32; \
d70 1
a70 1
#  define CvDEPTH(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xiv_u.xivu_i32
d77 17
d95 3
a97 1
#define CVf_LVALUE	0x0004  /* CV return value can be used as lvalue */
d102 1
a102 1
#define CVf_ANON	0x0080	/* CvGV() can't be trusted */
d107 3
a109 2
#define CVf_CONST	0x0400  /* inlinable sub */
#define CVf_ISXSUB	0x0800	/* CV is an XSUB, not pure perl.  */
d163 12
d232 2
@


1.11
log
@Merge in perl 5.10.1
@
text
@d14 3
a16 45
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
    STRLEN	xpv_cur;	/* length of xp_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;	/* depth, >= 2 indicates recursive call */
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    PADLIST *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
a18 35
typedef struct {
    STRLEN	xpv_cur;	/* length of xp_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;	/* depth, >= 2 indicates recursive call */
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    PADLIST *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
} xpvcv_allocated;

d25 2
d35 3
a37 1
#define Nullcv Null(CV*)
a65 1
#define CVf_LOCKED	0x0002	/* CV locks itself or first arg on entry */
d80 1
a80 1
#define CVf_BUILTIN_ATTRS	(CVf_METHOD|CVf_LOCKED|CVf_LVALUE)
a104 4

#define CvLOCKED(cv)		(CvFLAGS(cv) & CVf_LOCKED)
#define CvLOCKED_on(cv)		(CvFLAGS(cv) |= CVf_LOCKED)
#define CvLOCKED_off(cv)	(CvFLAGS(cv) &= ~CVf_LOCKED)
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d112 7
a118 7
#define CvSTASH(sv)	((XPVCV*)SvANY(sv))->xcv_stash
#define CvSTART(sv)	((XPVCV*)SvANY(sv))->xcv_start_u.xcv_start
#define CvROOT(sv)	((XPVCV*)SvANY(sv))->xcv_root_u.xcv_root
#define CvXSUB(sv)	((XPVCV*)SvANY(sv))->xcv_root_u.xcv_xsub
#define CvXSUBANY(sv)	((XPVCV*)SvANY(sv))->xcv_start_u.xcv_xsubany
#define CvGV(sv)	((XPVCV*)SvANY(sv))->xcv_gv
#define CvFILE(sv)	((XPVCV*)SvANY(sv))->xcv_file
d126 3
a128 4
#  define CvDEPTH(sv) (*({const CV *_cv = (CV *)sv; \
			  assert(SvTYPE(_cv) == SVt_PVCV ||	 \
				 SvTYPE(_cv) == SVt_PVFM);	 \
			  &((XPVCV*)SvANY(_cv))->xiv_u.xivu_i32; \
d131 1
a131 1
#  define CvDEPTH(sv)	((XPVCV*)SvANY(sv))->xiv_u.xivu_i32
d133 4
a136 4
#define CvPADLIST(sv)	((XPVCV*)SvANY(sv))->xcv_padlist
#define CvOUTSIDE(sv)	((XPVCV*)SvANY(sv))->xcv_outside
#define CvFLAGS(sv)	((XPVCV*)SvANY(sv))->xcv_flags
#define CvOUTSIDE_SEQ(sv) ((XPVCV*)SvANY(sv))->xcv_outside_seq
@


1.9
log
@merge in perl 5.8.8
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d11 1
a11 2
/* This structure must match XPVCV in B/C.pm and the beginning of XPVFM
 * in sv.h  */
d14 13
a26 1
    char *	xpv_pv;		/* pointer to malloced string (for prototype) */
d29 11
a39 3
    IV		xof_off;	/* integer value */
    NV		xnv_nv;		/* numeric value, if any */
    MAGIC*	xmg_magic;	/* magic for scalar array */
d43 8
a50 4
    OP *	xcv_start;
    OP *	xcv_root;
    void	(*xcv_xsub) (pTHX_ CV*);
    ANY		xcv_xsubany;
a52 1
    long	xcv_depth;	/* >= 2 indicates recursive call */
d55 3
a57 4
#ifdef USE_5005THREADS
    perl_mutex *xcv_mutexp;
    struct perl_thread *xcv_owner;	/* current owner thread */
#endif /* USE_5005THREADS */
d59 31
d93 2
a94 1
};
d113 4
a116 4
#define CvSTART(sv)	((XPVCV*)SvANY(sv))->xcv_start
#define CvROOT(sv)	((XPVCV*)SvANY(sv))->xcv_root
#define CvXSUB(sv)	((XPVCV*)SvANY(sv))->xcv_xsub
#define CvXSUBANY(sv)	((XPVCV*)SvANY(sv))->xcv_xsubany
d125 9
a133 1
#define CvDEPTH(sv)	((XPVCV*)SvANY(sv))->xcv_depth
a135 4
#ifdef USE_5005THREADS
#define CvMUTEXP(sv)	((XPVCV*)SvANY(sv))->xcv_mutexp
#define CvOWNER(sv)	((XPVCV*)SvANY(sv))->xcv_owner
#endif /* USE_5005THREADS */
d139 11
a149 9
#define CVf_CLONE	0x0001	/* anon CV uses external lexicals */
#define CVf_CLONED	0x0002	/* a clone of one of those */
#define CVf_ANON	0x0004	/* CvGV() can't be trusted */
#define CVf_OLDSTYLE	0x0008
#define CVf_UNIQUE	0x0010	/* sub is only called once (eg PL_main_cv,
				 * require, eval). Not to be confused
				 * with the GVf_UNIQUE flag associated
				 * with the :unique attribute */
#define CVf_NODEBUG	0x0020	/* no DB::sub indirection for this CV
d151 2
a152 5
#define CVf_METHOD	0x0040	/* CV is explicitly marked as a method */
#define CVf_LOCKED	0x0080	/* CV locks itself or first arg on entry */
#define CVf_LVALUE	0x0100  /* CV return value can be used as lvalue */
#define CVf_CONST	0x0200  /* inlinable sub */
#define CVf_WEAKOUTSIDE	0x0400  /* CvOUTSIDE isn't ref counted */
a168 6
#ifdef PERL_XSUB_OLDSTYLE
#define CvOLDSTYLE(cv)		(CvFLAGS(cv) & CVf_OLDSTYLE)
#define CvOLDSTYLE_on(cv)	(CvFLAGS(cv) |= CVf_OLDSTYLE)
#define CvOLDSTYLE_off(cv)	(CvFLAGS(cv) &= ~CVf_OLDSTYLE)
#endif

d193 1
a193 1
/* BEGIN|CHECK|INIT|END */
d206 6
d267 10
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d173 1
a173 1
There is a further complication with non-closure anonymous subs (ie those
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d86 4
a89 1
#define CVf_UNIQUE	0x0010	/* can't be cloned */
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 1
 *    Copyright (c) 1991-2002, Larry Wall
d11 1
a11 1
/* This structure much match XPVCV in B/C.pm and the beginning of XPVFM
d15 1
a15 1
    char *	xpv_pv;		/* pointer to malloced string */
d31 1
a31 1
    AV *	xcv_padlist;
d38 3
d80 1
d93 2
d140 1
a140 1
/* BEGIN|INIT|END */
d149 5
d155 1
a155 1
=head1 Pad Data Structures
d157 1
a157 2
=for apidoc m|AV *|CvPADLIST|CV *cv
CV's can have CvPADLIST(cv) set to point to an AV.
d159 46
a204 48
For these purposes "forms" are a kind-of CV, eval""s are too (except they're
not callable at will and are always thrown away after the eval"" is done
executing).

XSUBs don't have CvPADLIST set - dXSTARG fetches values from PL_curpad,
but that is really the callers pad (a slot of which is allocated by
every entersub).

The CvPADLIST AV has does not have AvREAL set, so REFCNT of component items
is managed "manual" (mostly in op.c) rather than normal av.c rules.
The items in the AV are not SVs as for a normal AV, but other AVs:

0'th Entry of the CvPADLIST is an AV which represents the "names" or rather
the "static type information" for lexicals.

The CvDEPTH'th entry of CvPADLIST AV is an AV which is the stack frame at that
depth of recursion into the CV.
The 0'th slot of a frame AV is an AV which is @@_.
other entries are storage for variables and op targets.

During compilation:
C<PL_comppad_name> is set the the the names AV.
C<PL_comppad> is set the the frame AV for the frame CvDEPTH == 1.
C<PL_curpad> is set the body of the frame AV (i.e. AvARRAY(PL_comppad)).

Itterating over the names AV itterates over all possible pad
items. Pad slots that are SVs_PADTMP (targets/GVs/constants) end up having
&PL_sv_undef "names" (see pad_alloc()).

Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get valid names.
The rest are op targets/GVs/constants which are statically allocated
or resolved at compile time.  These don't have names by which they
can be looked up from Perl code at run time through eval"" like
my/our variables can be.  Since they can't be looked up by "name"
but only by their index allocated at compile time (which is usually
in PL_op->op_targ), wasting a name SV for them doesn't make sense.

The SVs in the names AV have their PV being the name of the variable.
NV+1..IV inclusive is a range of cop_seq numbers for which the name is valid.
For typed lexicals name SV is SVt_PVMG and SvSTASH points at the type.

If SvFAKE is set on the name SV then slot in the frame AVs are
a REFCNT'ed references to a lexical from "outside".

If the 'name' is '&' the the corresponding entry in frame AV
is a CV representing a possible closure.
(SvFAKE and name of '&' is not a meaningful combination currently but could
become so if C<my sub foo {}> is implemented.)
a207 1

@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
d25 1
a25 1
    void	(*xcv_xsub) (pTHXo_ CV*);
d32 1
a32 1
#ifdef USE_THREADS
d35 1
a35 1
#endif /* USE_THREADS */
d40 2
d45 2
d62 6
a67 1
#define CvFILEGV(sv)	(gv_fetchfile(CvFILE(sv))
d71 1
a71 1
#ifdef USE_THREADS
d74 1
a74 1
#endif /* USE_THREADS */
d87 3
d137 63
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
d10 2
a11 1
/* This structure much match the beginning of XPVFM */
d18 1
a18 1
    double	xnv_nv;		/* numeric value, if any */
d25 1
a25 1
    void      (*xcv_xsub) _((CV* _CPERLproto));
d28 2
a29 2
    GV *	xcv_filegv;
    long	xcv_depth;		/* >= 2 indicates recursive call */
d39 10
d57 2
a58 1
#define CvFILEGV(sv)	((XPVCV*)SvANY(sv))->xcv_filegv
d77 1
d91 1
d95 1
d112 4
@


1.2
log
@perl 5.004_04
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1997, Larry Wall
d24 1
a24 1
    void      (*xcv_xsub) _((CV*));
d31 5
a35 1
    U8		xcv_flags;
d50 4
d56 6
a61 6
#define CVf_CLONE	0x01	/* anon CV uses external lexicals */
#define CVf_CLONED	0x02	/* a clone of one of those */
#define CVf_ANON	0x04	/* CvGV() can't be trusted */
#define CVf_OLDSTYLE	0x08
#define CVf_UNIQUE	0x10	/* can't be cloned */
#define CVf_NODEBUG	0x20	/* no DB::sub indirection for this CV
d63 2
d89 17
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1994, Larry Wall
d10 2
d52 3
d71 8
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-1999, Larry Wall
a9 2
/* This structure much match the beginning of XPVFM */

d22 1
a22 1
    void      (*xcv_xsub) _((CV* _CPERLproto));
d29 1
a29 5
#ifdef USE_THREADS
    perl_mutex *xcv_mutexp;
    struct perl_thread *xcv_owner;	/* current owner thread */
#endif /* USE_THREADS */
    cv_flags_t	xcv_flags;
a43 4
#ifdef USE_THREADS
#define CvMUTEXP(sv)	((XPVCV*)SvANY(sv))->xcv_mutexp
#define CvOWNER(sv)	((XPVCV*)SvANY(sv))->xcv_owner
#endif /* USE_THREADS */
d46 4
a49 9
#define CVf_CLONE	0x0001	/* anon CV uses external lexicals */
#define CVf_CLONED	0x0002	/* a clone of one of those */
#define CVf_ANON	0x0004	/* CvGV() can't be trusted */
#define CVf_OLDSTYLE	0x0008
#define CVf_UNIQUE	0x0010	/* can't be cloned */
#define CVf_NODEBUG	0x0020	/* no DB::sub indirection for this CV
				   (esp. useful for special XSUBs) */
#define CVf_METHOD	0x0040	/* CV is explicitly marked as a method */
#define CVf_LOCKED	0x0080	/* CV locks itself or first arg on entry */
a65 25

#define CvUNIQUE(cv)		(CvFLAGS(cv) & CVf_UNIQUE)
#define CvUNIQUE_on(cv)		(CvFLAGS(cv) |= CVf_UNIQUE)
#define CvUNIQUE_off(cv)	(CvFLAGS(cv) &= ~CVf_UNIQUE)

#define CvNODEBUG(cv)		(CvFLAGS(cv) & CVf_NODEBUG)
#define CvNODEBUG_on(cv)	(CvFLAGS(cv) |= CVf_NODEBUG)
#define CvNODEBUG_off(cv)	(CvFLAGS(cv) &= ~CVf_NODEBUG)

#define CvMETHOD(cv)		(CvFLAGS(cv) & CVf_METHOD)
#define CvMETHOD_on(cv)		(CvFLAGS(cv) |= CVf_METHOD)
#define CvMETHOD_off(cv)	(CvFLAGS(cv) &= ~CVf_METHOD)

#define CvLOCKED(cv)		(CvFLAGS(cv) & CVf_LOCKED)
#define CvLOCKED_on(cv)		(CvFLAGS(cv) |= CVf_LOCKED)
#define CvLOCKED_off(cv)	(CvFLAGS(cv) &= ~CVf_LOCKED)

#define CvEVAL(cv)		(CvUNIQUE(cv) && !SvFAKE(cv))
#define CvEVAL_on(cv)		(CvUNIQUE_on(cv),SvFAKE_off(cv))
#define CvEVAL_off(cv)		CvUNIQUE_off(cv)

/* BEGIN|INIT|END */
#define CvSPECIAL(cv)		(CvUNIQUE(cv) && SvFAKE(cv))
#define CvSPECIAL_on(cv)	(CvUNIQUE_on(cv),SvFAKE_on(cv))
#define CvSPECIAL_off(cv)	(CvUNIQUE_off(cv),SvFAKE_off(cv))
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2000, Larry Wall
d10 1
a10 2
/* This structure much match XPVCV in B/C.pm and the beginning of XPVFM
 * in sv.h  */
d17 1
a17 1
    NV		xnv_nv;		/* numeric value, if any */
d24 1
a24 1
    void	(*xcv_xsub) (pTHXo_ CV*);
d27 2
a28 2
    char *	xcv_file;
    long	xcv_depth;	/* >= 2 indicates recursive call */
a37 10
/*
=for apidoc AmU||Nullcv
Null CV pointer.

=for apidoc Am|HV*|CvSTASH|CV* cv
Returns the stash of the CV.

=cut
*/

d46 1
a46 2
#define CvFILE(sv)	((XPVCV*)SvANY(sv))->xcv_file
#define CvFILEGV(sv)	(gv_fetchfile(CvFILE(sv))
a64 1
#define CVf_LVALUE	0x0100  /* CV return value can be used as lvalue */
a77 1
#ifdef PERL_XSUB_OLDSTYLE
a80 1
#endif
a96 4

#define CvLVALUE(cv)		(CvFLAGS(cv) & CVf_LVALUE)
#define CvLVALUE_on(cv)		(CvFLAGS(cv) |= CVf_LVALUE)
#define CvLVALUE_off(cv)	(CvFLAGS(cv) &= ~CVf_LVALUE)
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2001, Larry Wall
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
 *    Copyright (c) 1991-2002, Larry Wall
d25 1
a25 1
    void	(*xcv_xsub) (pTHX_ CV*);
d32 1
a32 1
#ifdef USE_5005THREADS
d35 1
a35 1
#endif /* USE_5005THREADS */
a39 2
=head1 Handy Values

a42 2
=head1 CV Manipulation Functions

d58 1
a58 6
#ifdef USE_ITHREADS
#  define CvFILE_set_from_cop(sv, cop)	(CvFILE(sv) = savepv(CopFILE(cop)))
#else
#  define CvFILE_set_from_cop(sv, cop)	(CvFILE(sv) = CopFILE(cop))
#endif
#define CvFILEGV(sv)	(gv_fetchfile(CvFILE(sv)))
d62 1
a62 1
#ifdef USE_5005THREADS
d65 1
a65 1
#endif /* USE_5005THREADS */
a77 3
#define CVf_CONST	0x0200  /* inlinable sub */
/* This symbol for optimised communication between toke.c and op.c: */
#define CVf_BUILTIN_ATTRS	(CVf_METHOD|CVf_LOCKED|CVf_LVALUE)
a124 63

#define CvCONST(cv)		(CvFLAGS(cv) & CVf_CONST)
#define CvCONST_on(cv)		(CvFLAGS(cv) |= CVf_CONST)
#define CvCONST_off(cv)		(CvFLAGS(cv) &= ~CVf_CONST)

/*
=head1 Pad Data Structures

=for apidoc m|AV *|CvPADLIST|CV *cv
CV's can have CvPADLIST(cv) set to point to an AV.

For these purposes "forms" are a kind-of CV, eval""s are too (except they're
not callable at will and are always thrown away after the eval"" is done
executing).

XSUBs don't have CvPADLIST set - dXSTARG fetches values from PL_curpad,
but that is really the callers pad (a slot of which is allocated by
every entersub).

The CvPADLIST AV has does not have AvREAL set, so REFCNT of component items
is managed "manual" (mostly in op.c) rather than normal av.c rules.
The items in the AV are not SVs as for a normal AV, but other AVs:

0'th Entry of the CvPADLIST is an AV which represents the "names" or rather
the "static type information" for lexicals.

The CvDEPTH'th entry of CvPADLIST AV is an AV which is the stack frame at that
depth of recursion into the CV.
The 0'th slot of a frame AV is an AV which is @@_.
other entries are storage for variables and op targets.

During compilation:
C<PL_comppad_name> is set the the the names AV.
C<PL_comppad> is set the the frame AV for the frame CvDEPTH == 1.
C<PL_curpad> is set the body of the frame AV (i.e. AvARRAY(PL_comppad)).

Itterating over the names AV itterates over all possible pad
items. Pad slots that are SVs_PADTMP (targets/GVs/constants) end up having
&PL_sv_undef "names" (see pad_alloc()).

Only my/our variable (SVs_PADMY/SVs_PADOUR) slots get valid names.
The rest are op targets/GVs/constants which are statically allocated
or resolved at compile time.  These don't have names by which they
can be looked up from Perl code at run time through eval"" like
my/our variables can be.  Since they can't be looked up by "name"
but only by their index allocated at compile time (which is usually
in PL_op->op_targ), wasting a name SV for them doesn't make sense.

The SVs in the names AV have their PV being the name of the variable.
NV+1..IV inclusive is a range of cop_seq numbers for which the name is valid.
For typed lexicals name SV is SVt_PVMG and SvSTASH points at the type.

If SvFAKE is set on the name SV then slot in the frame AVs are
a REFCNT'ed references to a lexical from "outside".

If the 'name' is '&' the the corresponding entry in frame AV
is a CV representing a possible closure.
(SvFAKE and name of '&' is not a meaningful combination currently but could
become so if C<my sub foo {}> is implemented.)

=cut
*/

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999,
 *    2000, 2001, 2002, 2003, by Larry Wall and others
d10 1
a10 1
/* This structure must match XPVCV in B/C.pm and the beginning of XPVFM
d14 1
a14 1
    char *	xpv_pv;		/* pointer to malloced string (for prototype) */
d30 1
a30 1
    PADLIST *	xcv_padlist;
a36 3
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
a75 1
#define CvOUTSIDE_SEQ(sv) ((XPVCV*)SvANY(sv))->xcv_outside_seq
a87 2
#define CVf_WEAKOUTSIDE	0x0400  /* CvOUTSIDE isn't ref counted */

d133 1
a133 1
/* BEGIN|CHECK|INIT|END */
a141 5
#define CvWEAKOUTSIDE(cv)	(CvFLAGS(cv) & CVf_WEAKOUTSIDE)
#define CvWEAKOUTSIDE_on(cv)	(CvFLAGS(cv) |= CVf_WEAKOUTSIDE)
#define CvWEAKOUTSIDE_off(cv)	(CvFLAGS(cv) &= ~CVf_WEAKOUTSIDE)


d143 1
a143 1
=head1 CV reference counts and CvOUTSIDE
d145 2
a146 1
=for apidoc m|bool|CvWEAKOUTSIDE|CV *cv
d148 48
a195 46
Each CV has a pointer, C<CvOUTSIDE()>, to its lexically enclosing
CV (if any). Because pointers to anonymous sub prototypes are
stored in C<&> pad slots, it is a possible to get a circular reference,
with the parent pointing to the child and vice-versa. To avoid the
ensuing memory leak, we do not increment the reference count of the CV
pointed to by C<CvOUTSIDE> in the I<one specific instance> that the parent
has a C<&> pad slot pointing back to us. In this case, we set the
C<CvWEAKOUTSIDE> flag in the child. This allows us to determine under what
circumstances we should decrement the refcount of the parent when freeing
the child.

There is a further complication with non-closure anonymous subs (ie those
that do not refer to any lexicals outside that sub). In this case, the
anonymous prototype is shared rather than being cloned. This has the
consequence that the parent may be freed while there are still active
children, eg

    BEGIN { $a = sub { eval '$x' } }

In this case, the BEGIN is freed immediately after execution since there
are no active references to it: the anon sub prototype has
C<CvWEAKOUTSIDE> set since it's not a closure, and $a points to the same
CV, so it doesn't contribute to BEGIN's refcount either.  When $a is
executed, the C<eval '$x'> causes the chain of C<CvOUTSIDE>s to be followed,
and the freed BEGIN is accessed.

To avoid this, whenever a CV and its associated pad is freed, any
C<&> entries in the pad are explicitly removed from the pad, and if the
refcount of the pointed-to anon sub is still positive, then that
child's C<CvOUTSIDE> is set to point to its grandparent. This will only
occur in the single specific case of a non-closure anon prototype
having one or more active references (such as C<$a> above).

One other thing to consider is that a CV may be merely undefined
rather than freed, eg C<undef &foo>. In this case, its refcount may
not have reached zero, but we still delete its pad and its C<CvROOT> etc.
Since various children may still have their C<CvOUTSIDE> pointing at this
undefined CV, we keep its own C<CvOUTSIDE> for the time being, so that
the chain of lexical scopes is unbroken. For example, the following
should print 123:

    my $x = 123;
    sub tmp { sub { eval '$x' } }
    my $a = tmp();
    undef &tmp;
    print  $a->();
d199 1
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
 *    2000, 2001, 2002, 2003, 2004, by Larry Wall and others
d86 1
a86 4
#define CVf_UNIQUE	0x0010	/* sub is only called once (eg PL_main_cv,
				 * require, eval). Not to be confused
				 * with the GVf_UNIQUE flag associated
				 * with the :unique attribute */
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d173 1
a173 1
There is a further complication with non-closure anonymous subs (i.e. those
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000,
 *    2001, 2002, 2003, 2004, 2005, 2006, 2007, by Larry Wall and others
d11 2
a12 1
/* This structure must the beginning of XPVFM in sv.h  */
d15 1
a15 13
    union {
	NV	xnv_nv;		/* numeric value, if any */
	HV *	xgv_stash;
	struct {
	    U32	xlow;
	    U32	xhigh;
	}	xpad_cop_seq;	/* used by pad.c for cop_sequence */
	struct {
	    U32 xbm_previous;	/* how many characters in string before rare? */
	    U8	xbm_flags;
	    U8	xbm_rare;	/* rarest character in string */
	}	xbm_s;		/* fields from PVBM */
    }		xnv_u;
d18 3
a20 11
    union {
	IV	xivu_iv;
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;	/* depth, >= 2 indicates recursive call */
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
d24 4
a27 8
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
d30 1
d33 5
a40 1
    cv_flags_t	xcv_flags;
a42 35
typedef struct {
    STRLEN	xpv_cur;	/* length of xp_pv as a C string */
    STRLEN	xpv_len;	/* allocated size */
    union {
	IV	xivu_iv;
	UV	xivu_uv;
	void *	xivu_p1;
	I32	xivu_i32;	/* depth, >= 2 indicates recursive call */
	HEK *	xivu_namehek;
    }		xiv_u;
    union {
	MAGIC*	xmg_magic;	/* linked list of magicalness */
	HV*	xmg_ourstash;	/* Stash for our (when SvPAD_OUR is true) */
    } xmg_u;
    HV*		xmg_stash;	/* class package */

    HV *	xcv_stash;
    union {
	OP *	xcv_start;
	ANY	xcv_xsubany;
    }		xcv_start_u;
    union {
	OP *	xcv_root;
	void	(*xcv_xsub) (pTHX_ CV*);
    }		xcv_root_u;
    GV *	xcv_gv;
    char *	xcv_file;
    PADLIST *	xcv_padlist;
    CV *	xcv_outside;
    U32		xcv_outside_seq; /* the COP sequence (at the point of our
				  * compilation) in the lexically enclosing
				  * sub */
    cv_flags_t	xcv_flags;
} xpvcv_allocated;

d60 4
a63 4
#define CvSTART(sv)	((XPVCV*)SvANY(sv))->xcv_start_u.xcv_start
#define CvROOT(sv)	((XPVCV*)SvANY(sv))->xcv_root_u.xcv_root
#define CvXSUB(sv)	((XPVCV*)SvANY(sv))->xcv_root_u.xcv_xsub
#define CvXSUBANY(sv)	((XPVCV*)SvANY(sv))->xcv_start_u.xcv_xsubany
d72 1
a72 9
#if defined(__GNUC__) && !defined(PERL_GCC_BRACE_GROUPS_FORBIDDEN)
#  define CvDEPTH(sv) (*({const CV *_cv = (CV *)sv; \
			  assert(SvTYPE(_cv) == SVt_PVCV ||	 \
				 SvTYPE(_cv) == SVt_PVFM);	 \
			  &((XPVCV*)SvANY(_cv))->xiv_u.xivu_i32; \
			}))
#else
#  define CvDEPTH(sv)	((XPVCV*)SvANY(sv))->xiv_u.xivu_i32
#endif
d75 4
d82 9
a90 11
#define CVf_METHOD	0x0001	/* CV is explicitly marked as a method */
#define CVf_LOCKED	0x0002	/* CV locks itself or first arg on entry */
#define CVf_LVALUE	0x0004  /* CV return value can be used as lvalue */

#define CVf_WEAKOUTSIDE	0x0010  /* CvOUTSIDE isn't ref counted */
#define CVf_CLONE	0x0020	/* anon CV uses external lexicals */
#define CVf_CLONED	0x0040	/* a clone of one of those */
#define CVf_ANON	0x0080	/* CvGV() can't be trusted */
#define CVf_UNIQUE	0x0100	/* sub is only called once (eg PL_main_cv,
				 * require, eval). */
#define CVf_NODEBUG	0x0200	/* no DB::sub indirection for this CV
d92 5
a96 2
#define CVf_CONST	0x0400  /* inlinable sub */
#define CVf_ISXSUB	0x0800	/* CV is an XSUB, not pure perl.  */
d113 6
d143 1
a143 1
/* BEGIN|CHECK|INIT|UNITCHECK|END */
a155 6
#define CvISXSUB(cv)		(CvFLAGS(cv) & CVf_ISXSUB)
#define CvISXSUB_on(cv)		(CvFLAGS(cv) |= CVf_ISXSUB)
#define CvISXSUB_off(cv)	(CvFLAGS(cv) &= ~CVf_ISXSUB)

/* Flags for newXS_flags  */
#define XS_DYNAMIC_FILENAME	0x01	/* The filename isn't static  */
a210 10

/*
 * Local variables:
 * c-indentation-style: bsd
 * c-basic-offset: 4
 * indent-tabs-mode: t
 * End:
 *
 * ex: set ts=8 sts=4 sw=4 noet:
 */
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d3 2
a4 2
 *    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001,
 *    2002, 2003, 2004, 2005, 2006, 2007, 2008 by Larry Wall and others
d112 7
a118 7
#define CvSTASH(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_stash
#define CvSTART(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_start_u.xcv_start
#define CvROOT(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_root_u.xcv_root
#define CvXSUB(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_root_u.xcv_xsub
#define CvXSUBANY(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_start_u.xcv_xsubany
#define CvGV(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv
#define CvFILE(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_file
d126 4
a129 3
#  define CvDEPTH(sv) (*({const CV *const _cvdepth = (const CV *)sv; \
			  assert(SvTYPE(_cvdepth) == SVt_PVCV);	 \
			  &((XPVCV*)SvANY(_cvdepth))->xiv_u.xivu_i32; \
d132 1
a132 1
#  define CvDEPTH(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xiv_u.xivu_i32
d134 4
a137 4
#define CvPADLIST(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_padlist
#define CvOUTSIDE(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_outside
#define CvFLAGS(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_flags
#define CvOUTSIDE_SEQ(sv) ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_outside_seq
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d14 45
a58 3
    _XPV_HEAD;
    _XPVMG_HEAD;
    _XPVCV_COMMON;
d61 35
a101 2
(deprecated - use C<(CV *)NULL> instead)

d110 1
a110 3
#ifndef PERL_CORE
#  define Nullcv Null(CV*)
#endif
d139 1
d154 1
a154 1
#define CVf_BUILTIN_ATTRS	(CVf_METHOD|CVf_LVALUE)
d179 4
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d11 1
a11 1
/* This structure must match the beginning of XPVFM in sv.h  */
d15 1
a16 1
    I32	xcv_depth;	/* >= 2 indicates recursive call */
a28 3
This section documents functions to manipulate CVs which are code-values,
or subroutines. For more information, see L<perlguts>.

d30 1
a30 6
Returns the stash of the CV. A stash is the symbol table hash, containing
the package-scoped variables in the package where the subroutine was defined.
For more information, see L<perlguts>.

This also has a special use with XS AUTOLOAD subs.
See L<perlguts/Autoloading with XSUBs>.
d39 1
a39 2
#define CvSTASH(sv)	(0+((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_stash)
#define CvSTASH_set(cv,st) Perl_cvstash_set(aTHX_ cv, st)
d44 1
a44 2
#define CvGV(sv)	(0+((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv)
#define CvGV_set(cv,gv)	Perl_cvgv_set(aTHX_ cv, gv)
d47 1
a47 2
#  define CvFILE_set_from_cop(sv, cop)	\
    (CvFILE(sv) = savepv(CopFILE(cop)), CvDYNFILE_on(sv))
d49 1
a49 2
#  define CvFILE_set_from_cop(sv, cop)	\
    (CvFILE(sv) = CopFILE(cop), CvDYNFILE_off(sv))
d55 1
a55 1
			  &((XPVCV*)SvANY(_cvdepth))->xcv_depth; \
d58 1
a58 1
#  define CvDEPTH(sv)	((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_depth
a64 17
/* These two are sometimes called on non-CVs */
#define CvPROTO(sv)                               \
	(                                          \
	 SvPOK(sv)                                  \
	  ? SvTYPE(sv) == SVt_PVCV && CvAUTOLOAD(sv) \
	     ? SvEND(sv)+1 : SvPVX_const(sv)          \
	  : NULL                                       \
	)
#define CvPROTOLEN(sv)	                          \
	(                                          \
	 SvPOK(sv)                                  \
	  ? SvTYPE(sv) == SVt_PVCV && CvAUTOLOAD(sv) \
	     ? SvLEN(sv)-SvCUR(sv)-2                  \
	     : SvCUR(sv)                               \
	  : 0                                           \
	)

d66 1
a66 3
#define CVf_LVALUE	0x0002  /* CV return value can be used as lvalue */
#define CVf_CONST	0x0004  /* inlinable sub */
#define CVf_ISXSUB	0x0008	/* CV is an XSUB, not pure perl.  */
d71 1
a71 1
#define CVf_ANON	0x0080	/* CV is not pointed to by a GV */
d76 2
a77 3
#define CVf_CVGV_RC	0x0400	/* CvGV is reference counted */
#define CVf_DYNFILE	0x1000	/* The filename isn't static  */
#define CVf_AUTOLOAD	0x2000	/* SvPVX contains AUTOLOADed sub name  */
a130 12
#define CvCVGV_RC(cv)		(CvFLAGS(cv) & CVf_CVGV_RC)
#define CvCVGV_RC_on(cv)	(CvFLAGS(cv) |= CVf_CVGV_RC)
#define CvCVGV_RC_off(cv)	(CvFLAGS(cv) &= ~CVf_CVGV_RC)

#define CvDYNFILE(cv)		(CvFLAGS(cv) & CVf_DYNFILE)
#define CvDYNFILE_on(cv)	(CvFLAGS(cv) |= CVf_DYNFILE)
#define CvDYNFILE_off(cv)	(CvFLAGS(cv) &= ~CVf_DYNFILE)

#define CvAUTOLOAD(cv)		(CvFLAGS(cv) & CVf_AUTOLOAD)
#define CvAUTOLOAD_on(cv)	(CvFLAGS(cv) |= CVf_AUTOLOAD)
#define CvAUTOLOAD_off(cv)	(CvFLAGS(cv) &= ~CVf_AUTOLOAD)

a187 2

typedef OP *(*Perl_call_checker)(pTHX_ OP *, GV *, SV *);
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d16 1
d53 1
a53 1
#define CvGV(sv)	S_CvGV((CV *)(sv))
d64 8
a71 1
#define CvDEPTH(sv)	(*S_CvDEPTHp((const CV *)sv))
a107 3
#ifdef PERL_CORE
# define CVf_SLABBED	0x0800	/* Holds refcount on op slab  */
#endif
a109 2
#define CVf_HASEVAL	0x4000	/* contains string eval  */
#define CVf_NAMED	0x8000  /* Has a name HEK */
a125 1
/* CvEVAL or CvSPECIAL */
a141 1
/* eval or PL_main_cv */
a166 6
#ifdef PERL_CORE
# define CvSLABBED(cv)		(CvFLAGS(cv) & CVf_SLABBED)
# define CvSLABBED_on(cv)	(CvFLAGS(cv) |= CVf_SLABBED)
# define CvSLABBED_off(cv)	(CvFLAGS(cv) &= ~CVf_SLABBED)
#endif

a174 8
#define CvHASEVAL(cv)		(CvFLAGS(cv) & CVf_HASEVAL)
#define CvHASEVAL_on(cv)	(CvFLAGS(cv) |= CVf_HASEVAL)
#define CvHASEVAL_off(cv)	(CvFLAGS(cv) &= ~CVf_HASEVAL)

#define CvNAMED(cv)		(CvFLAGS(cv) & CVf_NAMED)
#define CvNAMED_on(cv)		(CvFLAGS(cv) |= CVf_NAMED)
#define CvNAMED_off(cv)		(CvFLAGS(cv) &= ~CVf_NAMED)

a177 24
PERL_STATIC_INLINE GV *
S_CvGV(CV *sv)
{
    return CvNAMED(sv)
	? 0
	: ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv_u.xcv_gv;
}
PERL_STATIC_INLINE HEK *
CvNAME_HEK(CV *sv)
{
    return CvNAMED(sv)
	? ((XPVCV*)MUTABLE_PTR(SvANY(sv)))->xcv_gv_u.xcv_hek
	: 0;
}
/* This lowers the refernce count of the previous value, but does *not*
   increment the reference count of the new value. */
#define CvNAME_HEK_set(cv, hek) ( \
	CvNAME_HEK((CV *)(cv))						 \
	    ? unshare_hek(SvANY((CV *)(cv))->xcv_gv_u.xcv_hek)	  \
	    : (void)0,						   \
	((XPVCV*)MUTABLE_PTR(SvANY(cv)))->xcv_gv_u.xcv_hek = (hek), \
	CvNAMED_on(cv)						     \
    )

d239 1
a239 1
 * indent-tabs-mode: nil
d242 1
a242 1
 * ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d29 1
a29 1
or subroutines.  For more information, see L<perlguts>.
d32 1
a32 1
Returns the stash of the CV.  A stash is the symbol table hash, containing
d52 1
a52 1
#define CvGV(sv)	S_CvGV((const CV *)(sv))
d192 1
a192 1
S_CvGV(const CV *sv)
d221 1
a221 1
CV (if any).  Because pointers to anonymous sub prototypes are
d223 1
a223 1
with the parent pointing to the child and vice-versa.  To avoid the
d226 2
a227 2
has a C<&> pad slot pointing back to us.  In this case, we set the
C<CvWEAKOUTSIDE> flag in the child.  This allows us to determine under what
d232 2
a233 2
that do not refer to any lexicals outside that sub).  In this case, the
anonymous prototype is shared rather than being cloned.  This has the
d249 1
a249 1
child's C<CvOUTSIDE> is set to point to its grandparent.  This will only
d254 1
a254 1
rather than freed, eg C<undef &foo>.  In this case, its refcount may
d258 1
a258 1
the chain of lexical scopes is unbroken.  For example, the following
@


