head	1.14;
access;
symbols
	OPENBSD_6_2:1.14.0.6
	OPENBSD_6_2_BASE:1.14
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.11.0.6
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.2
	OPENBSD_5_4_BASE:1.11
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.10.0.14
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.12
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.10
	OPENBSD_5_0:1.10.0.8
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.6
	OPENBSD_4_9_BASE:1.10
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.18
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.16
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2017.02.05.00.31.52;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	cxJ08BvJA9Pt2PTM;

1.13
date	2014.11.17.20.56.47;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2014.03.24.15.05.13;	author afresh1;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.25.20.40.44;	author sthen;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.21;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.35.57;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.08.55;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.20;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.17;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.34.49;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.03.57;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.00;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.48.38;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.11.40;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.37.22;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.08.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.22.04;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.47;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.30;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.45.41;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.05;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.35;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.06.25;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.58.44;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.52.36;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	B31cAbBIXiCqnL97;

1.1.1.13
date	2017.08.14.13.45.26;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.14
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    @@INC = qw(lib);

    # This needs to be at BEGIN time, before any use of Config
    # install_lib itself loads and imports Config into main::
    require './install_lib.pl';
}

use strict;

use Getopt::Long;
use ExtUtils::Packlist;
use Pod::Man;
use vars qw(%opts $packlist);

require './Porting/pod_lib.pl';
my %man1 = (map {($_->[0], $_->[1])} @@{get_pod_metadata()->{master}});

$ENV{SHELL} = 'sh' if $^O eq 'os2';

my $patchlevel = substr($],3,2);
die "Patchlevel of perl ($patchlevel)",
    "and patchlevel of config.sh ($Config{'PERL_VERSION'}) don't match\n"
	if $patchlevel != $Config{'PERL_VERSION'};

my $usage =
"Usage:  installman --man1dir=/usr/wherever --man1ext=1
                   --man3dir=/usr/wherever --man3ext=3
	           --notify --verbose --silent --help
	Defaults are:
	man1dir = $Config{'installman1dir'};
	man1ext = $Config{'man1ext'};
	man3dir = $Config{'installman3dir'};
	man3ext = $Config{'man3ext'};
	--notify  (or -n) just lists commands that would be executed.
        --verbose (or -V) report all progress.
        --silent  (or -S) be silent. Only report errors.\n";

# --strip intentionally does nothing. By permitting installman to accept it
# without error, the Makefile can pass the same options to installperl and
# installman, which permits more simplification there than this comment costs.
GetOptions( \%opts,
            qw( man1dir=s man1ext=s man3dir=s man3ext=s
                destdir:s notify|n help|h|? silent|S verbose|V strip))
	|| die $usage;
die $usage if $opts{help};
$opts{destdir} //= '';

foreach my $pre (qw(man1 man3)) {
    $opts{"${pre}dir"} //= $opts{destdir} . $Config{"install${pre}dir"};
    $opts{"${pre}ext"} //= $Config{"${pre}ext"};
}
$opts{verbose} ||= $opts{notify};

#Sanity checks

-x  "./perl$Config{exe_ext}"
  or warn "./perl$Config{exe_ext} not found!  Have you run make?\n";
-d  "$opts{destdir}$Config{'installprivlib'}"
	|| warn "Perl library directory $Config{'installprivlib'} not found.
		Have you run make install?.  (Installing anyway.)\n";
-x "t/perl$Config{exe_ext}"		|| warn "WARNING: You've never run 'make test'!!!",
	"  (Installing anyway.)\n";

$packlist = ExtUtils::Packlist->new("$opts{destdir}$Config{installarchlib}/.packlist");

# Install the main pod pages.
pod2man(\%man1, $opts{man1dir}, $opts{man1ext}, 'pod');

# Install the pods for library modules.
{
    my $found = pods_to_install();
    pod2man($found->{$_}, $opts{man3dir}, $opts{man3ext}, 'lib')
        foreach qw(MODULE PRAGMA);
}

# Install the pods embedded in the installed scripts
my $has_man1dir = $opts{man1dir} ne '' && -d $opts{man1dir};
my $fh = open_or_die('utils.lst');
while (<$fh>) {
    next if /^#/;
    chomp;
    my ($path, $leaf) = m|^(\S*/(\S+))|;
    # Have we already installed the manpage for this? (eg perldoc)
    next if $man1{$leaf};
    pod2man({$leaf, $path}, $opts{man1dir}, $opts{man1ext});
    if ($has_man1dir) {
        if (my ($link) = m|#.*link\s*=\s*\S+/(\S+)|) {
            my $old = "$opts{man1dir}/$leaf.$opts{man1ext}";
            my $new = "$opts{man1dir}/$link.$opts{man1ext}";
	    unlink($new);
	    link($old, $new);
            $old =~ s/^\Q$opts{destdir}\E// if $opts{destdir};
            $new =~ s/^\Q$opts{destdir}\E// if $opts{destdir};
            $packlist->{$new} = { from => $old, type => 'link' };
	}
    }
}
close $fh or my_die("close 'utils.lst': $!");

sub pod2man {
    my($modpods, $mandir, $manext, $where) = @@_;
    if ($mandir eq ' ' or $mandir eq '') {
        if ($where) {
            warn "Skipping installation of $where man pages.\n"
        } else {
            warn "Skipping installation of $_ man page.\n"
                foreach values %$modpods;
        }
        return;
    }

    if ($opts{verbose}) {
        if ($where) {
            print "installing from $where\n";
        } else {
            print "installing $_\n"
                foreach sort keys %$modpods;
        }
    }

    mkpath($mandir);

    foreach my $manpage (sort keys %$modpods) {
        my $mod = $modpods->{$manpage};

	# Skip files without pod docs
	my $has_pod;
        my $fh = open_or_die($mod);
        while (my $line = <$fh>) {
            if ($line =~ /^=head1\b/) {
                ++$has_pod;
                last;
            }
        }
	close $fh or my_die("close '$mod': $!");
        # Sadly it doesn't seem possible to re-use this handle for the call
        # to parse_from_file() below, as Pod::Man relies on source_filename(),
        # which Pod::Simple only sets accurately if it opens the file itself.

	unless ($has_pod)
	{
	    print "no documentation in $mod\n" if $opts{verbose};
	    next;
	}

	if ($^O eq 'os2' || $^O eq 'amigaos' || $^O eq 'uwin' || $^O eq 'cygwin') {
            $manpage =~ s#::#.#g;
	}
        my $tmp = "${mandir}/${manpage}.tmp";
	$manpage = "${mandir}/${manpage}.${manext}";

        my $parser = Pod::Man->new( section => $manext,
                                    official=> 1,
                                    center  => 'Perl Programmers Reference Guide'
                                  );
	my $xmanpage = $manpage;
	$xmanpage =~ s/^\Q$opts{'destdir'}\E// if $opts{'destdir'};
        print "  $xmanpage\n" unless $opts{silent};
        if (!$opts{notify} && $parser->parse_from_file($mod, $tmp)) {
            if (-s $tmp) {
                if (safe_rename($tmp, $manpage)) {
                    $packlist->{$xmanpage} = { type => 'file' };
                    next;
                }
            }
            unlink($tmp);
	}
    }
}

$packlist->write() unless $opts{notify};
print "  Installation complete\n" if $opts{verbose};

# ex: set ts=8 sts=4 sw=4 et:
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d86 1
a86 1
    # Have we already installed the manpage for this? (eg perldoc, a2p)
d145 1
a145 1
	    warn "no documentation in $mod\n" unless $opts{silent};
a176 5
# Local variables:
# cperl-indent-level: 4
# indent-tabs-mode: nil
# End:
#
@


1.12
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d2 1
d7 1
d10 1
a13 1
require File::Path;
d41 3
d46 1
a46 1
                destdir:s notify n help silent S verbose V))
d55 1
a55 3
$opts{silent} ||= $opts{S};
$opts{notify} ||= $opts{n};
$opts{verbose} ||= $opts{V} || $opts{notify};
d124 1
a124 1
    File::Path::mkpath($mandir, $opts{verbose}, 0777) unless $opts{notify};
d164 1
a164 1
                if (rename($tmp, $manpage)) {
a175 14

sub rename {
    my($from,$to) = @@_;
    if (-f $to and not unlink($to)) {
	my($i);
	for ($i = 1; $i < 50; $i++) {
	    last if CORE::rename($to, "$to.$i");
	}
	warn("Cannot rename to '$to.$i': $!"), return 0
	    if $i >= 50;	# Give up!
    }
    link($from,$to) || return 0;
    unlink($from);
}
@


1.11
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d142 1
a142 1
	    warn "no documentation in $mod\n";
d158 1
a158 1
        print "  $xmanpage\n";
@


1.10
log
@Merge in perl 5.10.1
@
text
@d4 1
a4 1
    
d11 1
a11 3
use File::Find;
use File::Copy;
use File::Path qw(mkpath);
d14 4
a17 2
use vars qw($Is_VMS $Is_W32 $Is_OS2 $Is_Cygwin $Is_Darwin $Is_NetWare
	    %opts $packlist);
a28 1
		   --batchlimit=40
d40 2
a41 2
            qw( man1dir=s man1ext=s man3dir=s man3ext=s batchlimit=i
                destdir:s notify n help silent S verbose V)) 
d56 1
a56 1
-x  "./perl$Config{exe_ext}" 
a65 1

d67 1
a67 1
pod2man('pod', $opts{man1dir}, $opts{man1ext});
d70 5
a74 1
pod2man('lib', $opts{man3dir}, $opts{man3ext});
d78 2
a79 2
open UTILS, "utils.lst" or die "Can't open 'utils.lst': $!";
while (<UTILS>) {
d82 4
a85 3
    $_ = $1 if /#.*pod\s*=\s*(\S+)/;
    my ($where, $what) = m|^(\S*)/(\S+)|;
    pod2man($where, $opts{man1dir}, $opts{man1ext}, $what);
d87 3
a89 3
	if (my ($where2, $what2) = m|#.*link\s*=\s*(\S+)/(\S+)|) {
	    my $old = "$opts{man1dir}/$what.$opts{man1ext}";
	    my $new = "$opts{man1dir}/$what2.$opts{man1ext}";
d92 3
a94 5
	    my $xold = $old;
	    $xold =~ s/^\Q$opts{'destdir'}\E// if $opts{'destdir'};
	    my $xnew = $new;
	    $xnew =~ s/^\Q$opts{'destdir'}\E// if $opts{'destdir'};
	    $packlist->{$xnew} = { from => $xold, type => 'link' };
d98 1
d101 1
a101 3
    # @@script is scripts names if we are installing manpages embedded 
    # in scripts, () otherwise
    my($poddir, $mandir, $manext, @@script) = @@_;
d103 16
a118 7
	if (@@script) {
	    warn "Skipping installation of $poddir/$_ man page.\n"
		foreach @@script;
	} else {
	    warn "Skipping installation of $poddir man pages.\n";
	}
	return;
d121 1
a121 1
    print "installing from $poddir\n" if $opts{verbose};
d123 2
a124 30
    mkpath($mandir, $opts{verbose}, 0777) unless $opts{notify};  # In File::Path
    # Make a list of all the .pm and .pod files in the directory.  We avoid
    # chdir because we are running with @@INC = '../lib', and modules may wish
    # to dynamically require Carp::Heavy or other diagnostics warnings.
    # Hash the names of files we find, keys are names relative to perl build
    # dir ('.'), values are names relative to $poddir.
    my %modpods;
    if (@@script) {
	%modpods = (map {+"$poddir/$_", $_} @@script);
    }
    else {
	File::Find::find({no_chdir=>1,
                          wanted => sub {
                              # $_ is $File::Find::name when using no_chdir
                              if (-f $_ and /\.p(?:m|od)$/) {
                                  my $fullname = $_;
                                  s!^\Q$poddir\E/!!;
                                  $modpods{$fullname} = $_;
                              }
                          }},
                         $poddir);
    }
    my @@to_process;
    foreach my $mod (sort keys %modpods) {
        my $manpage = $modpods{$mod};
	my $tmp;
	# Skip .pm files that have corresponding .pod files, and Functions.pm.
	next if (($tmp = $mod) =~ s/\.pm$/.pod/ && -f $tmp);
	next if $mod =~ m:/t/:; # no pods from test directories 
	next if ($manpage eq 'Pod/Functions.pm'); #### Used only by pod itself
d128 11
a138 10
	if (open T, $mod)
	{
	    local $_;
	    while (<T>)
	    {
		++$has_pod and last if /^=(?:head\d+|item|pod)\b/;
	    }

	    close T;
	}
a145 3
	# Convert name from  File/Basename.pm to File::Basename.3 format,
	# if necessary.
	$manpage =~ s#\.p(m|od)$##;
d147 1
a147 4
	  $manpage =~ s#/#.#g;
	}
	else {
	  $manpage =~ s#/#::#g;
d149 1
a149 1
	$tmp = "${mandir}/${manpage}.tmp";
a150 5
	push @@to_process, [$mod, $tmp, $manpage];
    }

    foreach my $page (@@to_process) {
	my($pod, $tmp, $manpage) = @@$page;
d159 1
a159 1
	if (!$opts{notify} && $parser->parse_from_file($pod, $tmp)) {
a173 2
exit 0;

d181 1
a181 1
	warn("Cannot rename to `$to.$i': $!"), return 0 
d187 7
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a1 3
BEGIN { @@INC = qw(lib) }
use strict;

d3 4
a6 22
    use Config;
    if ($Config{userelocatableinc}) {
	# This might be a considered a hack. Need to get information about the
	# configuration from Config.pm *before* Config.pm expands any .../
	# prefixes.
	#
	# So we set $^X to pretend that we're the already installed perl, so
	# Config.pm doesits ... expansion off that location.

	my $location = $Config{initialinstalllocation};
	die <<'OS' unless defined $location;
$Config{initialinstalllocation} is not defined - can't install a relocatable
perl without this.
OS
	$^X = "$location/perl";
	# And then remove all trace of ever having loaded Config.pm, so that
	# it will reload with the revised $^X
	undef %Config::;
	delete $INC{"Config.pm"};
	delete $INC{"Config_heavy.pl"};
	# You never saw us. We weren't here.
    }
d8 1
a9 1
use Config;
d16 2
a17 6
use subs qw(unlink chmod rename link);
use vars qw($packlist);

if ($Config{d_umask}) {
    umask(022); # umasks like 077 aren't that useful for installations
}
a20 2
my $ver = $Config{version};     # Not used presently.
my $release = substr($],0,3);   # Not used presently.
a39 1
my %opts;
d47 4
a50 8
$opts{man1dir} = "$opts{destdir}$Config{'installman1dir'}"
    unless defined($opts{man1dir}); 
$opts{man1ext} = $Config{'man1ext'}
    unless defined($opts{man1ext}); 
$opts{man3dir} = "$opts{destdir}$Config{'installman3dir'}"
    unless defined($opts{man3dir}); 
$opts{man3ext} = $Config{'man3ext'}
    unless defined($opts{man3ext}); 
a204 39
###############################################################################
# Utility subroutines from installperl

sub unlink {
    my(@@names) = @@_;
    my $cnt = 0;

    foreach my $name (@@names) {
	next unless -e $name;
	chmod 0777, $name if $^O eq 'os2';
	print "  unlink $name\n" if $opts{verbose};
	( CORE::unlink($name) and ++$cnt 
	    or warn "Couldn't unlink $name: $!\n" ) unless $opts{notify};
    }
    return $cnt;
}

sub link {
    my($from,$to) = @@_;
    my($success) = 0;

    print "  ln $from $to\n" if $opts{verbose};
    eval {
        CORE::link($from, $to)
            ? $success++
            : ($from =~ m#^/afs/# || $to =~ m#^/afs/#)
              ? die "AFS"  # okay inside eval {}
              : warn "Couldn't link $from to $to: $!\n"
          unless $opts{notify};
    };
    if ($@@) {
        File::Copy::copy($from, $to)
            ? $success++
            : warn "Couldn't copy $from to $to: $!\n"
          unless $opts{notify};
    }
    $success;
}

a216 22
}

sub chmod {
    my($mode,$name) = @@_;

    printf "  chmod %o %s\n", $mode, $name if $opts{verbose};
    CORE::chmod($mode,$name) || warn sprintf("Couldn't chmod %o %s: $!\n",$mode,$name)
	unless $opts{notify};
}

sub samepath {
    my($p1, $p2) = @@_;
    my($dev1, $ino1, $dev2, $ino2);

    if ($p1 ne $p2) {
	($dev1, $ino1) = stat($p1);
	($dev2, $ino2) = stat($p2);
	($dev1 == $dev2 && $ino1 == $ino2);
    }
    else {
	1;
    }
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d4 26
d73 1
a209 4
    my $parser = Pod::Man->new( section => $manext,
                                official=> 1,
                                center  => 'Perl Programmers Reference Guide'
                              );
d213 4
a235 1
    
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d94 5
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d44 1
a44 1
                notify n help silent S verbose V)) 
d48 1
a48 1
$opts{man1dir} = $Config{'installman1dir'}
d52 1
a52 1
$opts{man3dir} = $Config{'installman3dir'}
d64 1
a64 1
-d  $Config{'installprivlib'}
d70 1
a70 1
$packlist = ExtUtils::Packlist->new("$Config{installarchlib}/.packlist");
d145 19
d185 3
a187 1
        print "  $manpage\n";
d191 1
a191 1
                    $packlist->{$manpage} = { type => 'file' };
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 1
a2 1
BEGIN { @@INC = ('lib') }
d10 1
d12 5
a16 2
use vars qw($packlist @@modpods);
require Cwd;
a36 1
        batchlimit is maximum number of pod files per invocation of pod2man
a55 1
$opts{batchlimit} ||= 40;
d72 1
d74 1
a74 1
runpod2man('pod', $opts{man1dir}, $opts{man1ext});
d77 1
a77 1
runpod2man('lib', $opts{man3dir}, $opts{man3ext});
d80 17
a96 11
runpod2man('utils', $opts{man1dir}, $opts{man1ext}, 'c2ph', 'h2ph', 'h2xs',
	   'perlcc', 'perldoc', 'perlbug', 'pl2pm', 'splain', 'dprofpp');
runpod2man('x2p', $opts{man1dir}, $opts{man1ext}, 's2p', 'a2p.pod',
	   'find2perl');
runpod2man('pod', $opts{man1dir}, $opts{man1ext}, 'pod2man', 'pod2html',
	   'pod2text', 'pod2usage', 'podchecker', 'podselect');

# It would probably be better to have this page linked
# to the c2ph man page.  Or, this one could say ".so man1/c2ph.1",
# but then it would have to pay attention to $opts{man1dir} and $opts{man1ext}.
runpod2man('utils', $opts{man1dir}, $opts{man1ext}, 'pstruct'); 
d98 1
a98 3
runpod2man('lib/ExtUtils', $opts{man1dir}, $opts{man1ext}, 'xsubpp');

sub runpod2man {
a101 7

    my($downdir); # can't just use .. when installing xsubpp manpage

    $downdir = $poddir;
    $downdir =~ s:[^/]+:..:g;
    my($builddir) = Cwd::getcwd();

d112 1
a112 15
    print "chdir $poddir\n" if $opts{verbose};
    chdir $poddir || die "Unable to cd to $poddir directory!\n$!\n";

    # We insist on using the current version of pod2man in case there
    # are enhancements or changes from previous installed versions.
    # The error message doesn't include the '..' because the user
    # won't be aware that we've chdir to $poddir.
    -r  "$downdir/pod/pod2man" || die "Executable pod/pod2man not found.\n";

    # We want to be sure to use the current perl.  We can't rely on
    # the installed perl because it might not be actually installed
    # yet. (The user may have set the $install* Configure variables 
    # to point to some temporary home, from which the executable gets
    # installed by occult means.)
    my $pod2man = "$downdir/perl -I $downdir/lib $downdir/pod/pod2man --section=$manext --official";
d115 6
a120 3
    # Make a list of all the .pm and .pod files in the directory.  We will
    # always run pod2man from the lib directory and feed it the full pathname
    # of the pod.  This might be useful for pod2man someday.
d122 1
a122 1
	@@modpods = @@script;
d125 10
a134 2
	@@modpods = ();
	File::Find::find(\&lsmodpods, '.');
d137 2
a138 2
    foreach my $mod (@@modpods) {
	my $manpage = $mod;
d142 2
a143 1
	next if ($mod eq 'Pod/Functions.pm');	#### Used only by pod itself
d158 17
a174 16
    # Don't do all pods in same command to avoid busting command line limits
    while (my @@this_batch = splice @@to_process, 0, $opts{batchlimit}) {
	my $cmd = join " ", $pod2man, map "$$_[0] $$_[1]", @@this_batch;
	if (&cmd($cmd) == 0 && !$opts{notify}) {
	    foreach (@@this_batch) {
		my (undef, $tmp, $manpage) = @@$_;
		if (-s $tmp) {
		    if (rename($tmp, $manpage)) {
			$packlist->{$manpage} = { type => 'file' };
			next;
		    }
		}
		unless ($opts{notify}) {
		    unlink($tmp);
		}
	    }
a176 11
    chdir "$builddir" || die "Unable to cd back to $builddir directory!\n$!\n";
    print "  chdir $builddir\n" if $opts{verbose};
}

sub lsmodpods {
    my $dir  = $File::Find::dir;
    my $name = $File::Find::name;
    if (-f $_) {
        $name =~ s#^\./##;
	push(@@modpods, $name) if ($name =~ /\.p(m|od)$/);
    }
a187 15
sub cmd {
    my ($cmd) = @@_;
    print "  $cmd\n" if $opts{verbose};
    unless ($opts{notify}) {
	if ($Config{d_fork}) {
	    fork ? wait : exec $cmd;  # Allow user to ^C out of command.
	}
	else {
	    system $cmd;
	}
	warn "Command failed!!\n" if $?;
    }
    return $? != 0;
}

d206 1
a206 1
    print $opts{verbose} ? "  ln $from $to\n" : "  $to\n" unless $opts{silent};
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d1 1
a1 1
#!./perl
d3 1
d11 1
a11 1
use vars qw($packlist);
d16 3
a18 3
$ver = $Config{version};
$release = substr($],0,3);   # Not used presently.
$patchlevel = substr($],3,2);
d23 1
a23 1
$usage =
d25 3
a27 2
                    --man3dir=/usr/wherever --man3ext=3
		    --notify --help
d33 9
a41 3
	--notify (or -n) just lists commands that would be executed.\n";

GetOptions( qw( man1dir=s man1ext=s man3dir=s man3ext=s notify n help)) 
d43 1
a43 7
die $usage if $opt_help;

# These are written funny to avoid -w typo warnings.
$man1dir = defined($opt_man1dir) ? $opt_man1dir : $Config{'installman1dir'};
$man1ext = defined($opt_man1ext) ? $opt_man1ext : $Config{'man1ext'};
$man3dir = defined($opt_man3dir) ? $opt_man3dir : $Config{'installman3dir'};
$man3ext = defined($opt_man3ext) ? $opt_man3ext : $Config{'man3ext'};
d45 12
a56 1
$notify = $opt_notify || $opt_n;
d71 1
a71 1
runpod2man('pod', $man1dir, $man1ext);
d74 1
a74 1
runpod2man('lib', $man3dir, $man3ext);
d77 6
a82 18
runpod2man('utils', $man1dir, $man1ext, 'c2ph');
runpod2man('utils', $man1dir, $man1ext, 'h2ph');
runpod2man('utils', $man1dir, $man1ext, 'h2xs');
runpod2man('utils', $man1dir, $man1ext, 'perlcc');
runpod2man('utils', $man1dir, $man1ext, 'perldoc');
runpod2man('utils', $man1dir, $man1ext, 'perlbug');
runpod2man('utils', $man1dir, $man1ext, 'pl2pm');
runpod2man('utils', $man1dir, $man1ext, 'splain');
runpod2man('utils', $man1dir, $man1ext, 'dprofpp');
runpod2man('x2p', $man1dir, $man1ext, 's2p');
runpod2man('x2p', $man1dir, $man1ext, 'a2p.pod');
runpod2man('x2p', $man1dir, $man1ext, 'find2perl');
runpod2man('pod', $man1dir, $man1ext, 'pod2man');
runpod2man('pod', $man1dir, $man1ext, 'pod2html');
runpod2man('pod', $man1dir, $man1ext, 'pod2text');
runpod2man('pod', $man1dir, $man1ext, 'pod2usage');
runpod2man('pod', $man1dir, $man1ext, 'podchecker');
runpod2man('pod', $man1dir, $man1ext, 'podselect');
d86 2
a87 2
# but then it would have to pay attention to $man1dir and $man1ext.
runpod2man('utils', $man1dir, $man1ext, 'pstruct'); 
d89 1
a89 1
runpod2man('lib/ExtUtils', $man1dir, $man1ext, 'xsubpp');
d92 3
a94 3
    # $script is script name if we are installing a manpage embedded 
    # in a script, undef otherwise
    my($poddir, $mandir, $manext, $script) = @@_;
d103 6
a108 2
	print STDERR "Skipping installation of ",
	    ($script ? "$poddir/$script man page" : "$poddir man pages"), ".\n";
d112 1
a112 1
    print STDERR "chdir $poddir\n";
d126 1
a126 1
    $pod2man = "$downdir/perl -I $downdir/lib $downdir/pod/pod2man --section=$manext --official";
d128 1
a128 1
    mkpath($mandir, 1, 0777) unless $notify;  # In File::Path
d132 2
a133 2
    if ($script) {
	@@modpods = ($script);
d137 1
a137 1
	find(\&lsmodpods, '.');
d139 3
a141 2
    foreach $mod (@@modpods) {
	$manpage = $mod;
d158 17
a174 4
	if (&cmd("$pod2man $mod > $tmp") == 0 && !$notify && -s $tmp) {
	    if (rename($tmp, $manpage)) {
		$packlist->{$manpage} = { type => 'file' };
		next;
a176 3
	unless ($notify) {
	    unlink($tmp);
	}
d179 1
a179 1
    print STDERR "chdir $builddir\n";
d191 2
a192 2
$packlist->write() unless $notify;
print STDERR "  Installation complete\n";
d201 3
a203 3
    local($cmd) = @@_;
    print STDERR "  $cmd\n";
    unless ($notify) {
d216 1
a216 1
    local(@@names) = @@_;
d219 1
a219 1
    foreach $name (@@names) {
d222 1
a222 1
	print STDERR "  unlink $name\n";
d224 1
a224 1
	    or warn "Couldn't unlink $name: $!\n" ) unless $notify;
d233 1
a233 1
    print STDERR "  ln $from $to\n";
d240 1
a240 1
          unless $notify;
d246 1
a246 1
          unless $notify;
d252 1
a252 1
    local($from,$to) = @@_;
d266 1
a266 1
    local($mode,$name) = @@_;
d268 1
a268 1
    printf STDERR "  chmod %o %s\n", $mode, $name;
d270 1
a270 1
	unless $notify;
d274 2
a275 2
    local($p1, $p2) = @@_;
    local($dev1, $ino1, $dev2, $ino2);
@


1.3
log
@perl5.005_03 (stock)
@
text
@a12 1
umask 022;
d15 3
a17 3
$ver = $];
$release = substr($ver,0,3);   # Not used presently.
$patchlevel = substr($ver,3,2);
d19 2
a20 2
    "and patchlevel of config.sh ($Config{'PATCHLEVEL'}) don't match\n"
	if $patchlevel != $Config{'PATCHLEVEL'};
d67 1
d72 1
d75 1
d78 4
d129 2
a130 1
    } else {
d144 1
a144 1
	if ($^O eq 'os2' || $^O eq 'amigaos' || $^O eq 'uwin') {
d146 2
a147 1
	} else {
d153 4
a156 1
	    rename($tmp, $manpage) && next;
d159 1
a159 1
    unlink($tmp);
d204 5
a208 5
next unless -e $name;
chmod 0777, $name if $^O eq 'os2';
print STDERR "  unlink $name\n";
( CORE::unlink($name) and ++$cnt 
    or warn "Couldn't unlink $name: $!\n" ) unless $notify;
a224 1
        $packlist->{$to} = { type => 'file' };
a230 1
        $packlist->{$to} = { type => 'file' };
d238 6
a243 6
my($i);
for ($i = 1; $i < 50; $i++) {
    last if CORE::rename($to, "$to.$i");
}
warn("Cannot rename to `$to.$i': $!"), return 0 
    if $i >= 50;	# Give up!
a246 1
    $packlist->{$to} = { type => 'file' };
@


1.2
log
@perl 5.004_04
@
text
@d6 1
d8 1
d10 1
d56 2
d137 1
a137 1
	if ($^O eq 'os2' || $^O eq 'amigaos') {
d164 1
d203 2
a204 1
    local($from,$to) = @@_;
d207 17
a223 3
    eval { CORE::link($from,$to) }
|| system('cp', $from, $to) == 0
|| warn "Couldn't link $from to $to: $!\n" unless $notify;
d238 1
@


1.1
log
@Initial revision
@
text
@d59 20
d80 8
a87 1
    my($poddir, $mandir, $manext) = @@_;
d91 2
a92 1
	print STDERR "Skipping installation of $poddir man pages.\n";
d96 1
d103 1
a103 1
    -r  "../pod/pod2man" || die "Executable pod/pod2man not found.\n";
d110 1
a110 1
    $pod2man = "../perl -I ../lib ../pod/pod2man --section=$manext --official";
d112 1
a112 1
    mkpath($mandir, 1, 0777);  # In File::Path
d116 6
a121 2
    @@modpods = ();
    find(\&lsmodpods, '.');
d132 1
a132 1
	if ($^O eq 'os2') {
d147 1
d191 1
a191 1
    or warn "Couldn't unlink $name: $!\n" ) unless $nonono;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a5 1
use File::Copy;
a6 1
use ExtUtils::Packlist;
a7 1
use vars qw($packlist);
a52 2
$packlist = ExtUtils::Packlist->new("$Config{installarchlib}/.packlist");

a58 20
# Install the pods embedded in the installed scripts
runpod2man('utils', $man1dir, $man1ext, 'c2ph');
runpod2man('utils', $man1dir, $man1ext, 'h2ph');
runpod2man('utils', $man1dir, $man1ext, 'h2xs');
runpod2man('utils', $man1dir, $man1ext, 'perldoc');
runpod2man('utils', $man1dir, $man1ext, 'perlbug');
runpod2man('utils', $man1dir, $man1ext, 'pl2pm');
runpod2man('utils', $man1dir, $man1ext, 'splain');
runpod2man('x2p', $man1dir, $man1ext, 's2p');
runpod2man('x2p', $man1dir, $man1ext, 'a2p.pod');
runpod2man('pod', $man1dir, $man1ext, 'pod2man');
runpod2man('pod', $man1dir, $man1ext, 'pod2html');

# It would probably be better to have this page linked
# to the c2ph man page.  Or, this one could say ".so man1/c2ph.1",
# but then it would have to pay attention to $man1dir and $man1ext.
runpod2man('utils', $man1dir, $man1ext, 'pstruct'); 

runpod2man('lib/ExtUtils', $man1dir, $man1ext, 'xsubpp');

d60 1
a60 8
    # $script is script name if we are installing a manpage embedded 
    # in a script, undef otherwise
    my($poddir, $mandir, $manext, $script) = @@_;

    my($downdir); # can't just use .. when installing xsubpp manpage

    $downdir = $poddir;
    $downdir =~ s:[^/]+:..:g;
d64 1
a64 2
	print STDERR "Skipping installation of ",
	    ($script ? "$poddir/$script man page" : "$poddir man pages"), ".\n";
a67 1
    print STDERR "chdir $poddir\n";
d74 1
a74 1
    -r  "$downdir/pod/pod2man" || die "Executable pod/pod2man not found.\n";
d81 1
a81 1
    $pod2man = "$downdir/perl -I $downdir/lib $downdir/pod/pod2man --section=$manext --official";
d83 1
a83 1
    mkpath($mandir, 1, 0777) unless $notify;  # In File::Path
d87 2
a88 6
    if ($script) {
	@@modpods = ($script);
    } else {
	@@modpods = ();
	find(\&lsmodpods, '.');
    }
d99 1
a99 1
	if ($^O eq 'os2' || $^O eq 'amigaos' || $^O eq 'uwin') {
a113 1
    print STDERR "chdir $builddir\n";
a124 1
$packlist->write() unless $notify;
d157 1
a157 1
    or warn "Couldn't unlink $name: $!\n" ) unless $notify;
d163 1
a163 2
    my($from,$to) = @@_;
    my($success) = 0;
d166 3
a168 17
    eval {
        CORE::link($from, $to)
            ? $success++
            : ($from =~ m#^/afs/# || $to =~ m#^/afs/#)
              ? die "AFS"  # okay inside eval {}
              : warn "Couldn't link $from to $to: $!\n"
          unless $notify;
        $packlist->{$to} = { type => 'file' };
    };
    if ($@@) {
        File::Copy::copy($from, $to)
            ? $success++
            : warn "Couldn't copy $from to $to: $!\n"
          unless $notify;
        $packlist->{$to} = { type => 'file' };
    }
    $success;
a182 1
    $packlist->{$to} = { type => 'file' };
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d13 1
d16 3
a18 3
$ver = $Config{version};
$release = substr($],0,3);   # Not used presently.
$patchlevel = substr($],3,2);
d20 2
a21 2
    "and patchlevel of config.sh ($Config{'PERL_VERSION'}) don't match\n"
	if $patchlevel != $Config{'PERL_VERSION'};
a67 1
runpod2man('utils', $man1dir, $man1ext, 'perlcc');
a71 1
runpod2man('utils', $man1dir, $man1ext, 'dprofpp');
a73 1
runpod2man('x2p', $man1dir, $man1ext, 'find2perl');
a75 4
runpod2man('pod', $man1dir, $man1ext, 'pod2text');
runpod2man('pod', $man1dir, $man1ext, 'pod2usage');
runpod2man('pod', $man1dir, $man1ext, 'podchecker');
runpod2man('pod', $man1dir, $man1ext, 'podselect');
d123 1
a123 2
    }
    else {
d137 1
a137 1
	if ($^O eq 'os2' || $^O eq 'amigaos' || $^O eq 'uwin' || $^O eq 'cygwin') {
d139 1
a139 2
	}
	else {
d145 1
a145 4
	    if (rename($tmp, $manpage)) {
		$packlist->{$manpage} = { type => 'file' };
		next;
	    }
d148 1
a148 1
	    unlink($tmp);
d193 5
a197 5
	next unless -e $name;
	chmod 0777, $name if $^O eq 'os2';
	print STDERR "  unlink $name\n";
	( CORE::unlink($name) and ++$cnt 
	    or warn "Couldn't unlink $name: $!\n" ) unless $notify;
d214 1
d221 1
d229 6
a234 6
	my($i);
	for ($i = 1; $i < 50; $i++) {
	    last if CORE::rename($to, "$to.$i");
	}
	warn("Cannot rename to `$to.$i': $!"), return 0 
	    if $i >= 50;	# Give up!
d238 1
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d1 1
a1 1
#!./perl -w
a2 1
use strict;
d10 1
a10 1
use vars qw($packlist @@modpods);
d15 3
a17 3
my $ver = $Config{version};     # Not used presently.
my $release = substr($],0,3);   # Not used presently.
my $patchlevel = substr($],3,2);
d22 1
a22 1
my $usage =
d24 2
a25 3
                   --man3dir=/usr/wherever --man3ext=3
		   --batchlimit=40
	           --notify --verbose --silent --help
d31 3
a33 9
        batchlimit is maximum number of pod files per invocation of pod2man
	--notify  (or -n) just lists commands that would be executed.
        --verbose (or -V) report all progress.
        --silent  (or -S) be silent. Only report errors.\n";

my %opts;
GetOptions( \%opts,
            qw( man1dir=s man1ext=s man3dir=s man3ext=s batchlimit=i
                notify n help silent S verbose V)) 
d35 7
a41 1
die $usage if $opts{help};
d43 1
a43 12
$opts{man1dir} = $Config{'installman1dir'}
    unless defined($opts{man1dir}); 
$opts{man1ext} = $Config{'man1ext'}
    unless defined($opts{man1ext}); 
$opts{man3dir} = $Config{'installman3dir'}
    unless defined($opts{man3dir}); 
$opts{man3ext} = $Config{'man3ext'}
    unless defined($opts{man3ext}); 
$opts{batchlimit} ||= 40;
$opts{silent} ||= $opts{S};
$opts{notify} ||= $opts{n};
$opts{verbose} ||= $opts{V} || $opts{notify};
d58 1
a58 1
runpod2man('pod', $opts{man1dir}, $opts{man1ext});
d61 1
a61 1
runpod2man('lib', $opts{man3dir}, $opts{man3ext});
d64 18
a81 6
runpod2man('utils', $opts{man1dir}, $opts{man1ext}, 'c2ph', 'h2ph', 'h2xs',
	   'perlcc', 'perldoc', 'perlbug', 'pl2pm', 'splain', 'dprofpp');
runpod2man('x2p', $opts{man1dir}, $opts{man1ext}, 's2p', 'a2p.pod',
	   'find2perl');
runpod2man('pod', $opts{man1dir}, $opts{man1ext}, 'pod2man', 'pod2html',
	   'pod2text', 'pod2usage', 'podchecker', 'podselect');
d85 2
a86 2
# but then it would have to pay attention to $opts{man1dir} and $opts{man1ext}.
runpod2man('utils', $opts{man1dir}, $opts{man1ext}, 'pstruct'); 
d88 1
a88 1
runpod2man('lib/ExtUtils', $opts{man1dir}, $opts{man1ext}, 'xsubpp');
d91 3
a93 3
    # @@script is scripts names if we are installing manpages embedded 
    # in scripts, () otherwise
    my($poddir, $mandir, $manext, @@script) = @@_;
d102 2
a103 6
	if (@@script) {
	    warn "Skipping installation of $poddir/$_ man page.\n"
		foreach @@script;
	} else {
	    warn "Skipping installation of $poddir man pages.\n";
	}
d107 1
a107 1
    print "chdir $poddir\n" if $opts{verbose};
d121 1
a121 1
    my $pod2man = "$downdir/perl -I $downdir/lib $downdir/pod/pod2man --section=$manext --official";
d123 1
a123 1
    mkpath($mandir, $opts{verbose}, 0777) unless $opts{notify};  # In File::Path
d127 2
a128 2
    if (@@script) {
	@@modpods = @@script;
d132 1
a132 1
	File::Find::find(\&lsmodpods, '.');
d134 2
a135 3
    my @@to_process;
    foreach my $mod (@@modpods) {
	my $manpage = $mod;
d152 4
a155 17
	push @@to_process, [$mod, $tmp, $manpage];
    }
    # Don't do all pods in same command to avoid busting command line limits
    while (my @@this_batch = splice @@to_process, 0, $opts{batchlimit}) {
	my $cmd = join " ", $pod2man, map "$$_[0] $$_[1]", @@this_batch;
	if (&cmd($cmd) == 0 && !$opts{notify}) {
	    foreach (@@this_batch) {
		my (undef, $tmp, $manpage) = @@$_;
		if (-s $tmp) {
		    if (rename($tmp, $manpage)) {
			$packlist->{$manpage} = { type => 'file' };
			next;
		    }
		}
		unless ($opts{notify}) {
		    unlink($tmp);
		}
d158 3
d163 1
a163 1
    print "  chdir $builddir\n" if $opts{verbose};
d175 2
a176 2
$packlist->write() unless $opts{notify};
print "  Installation complete\n" if $opts{verbose};
d185 3
a187 3
    my ($cmd) = @@_;
    print "  $cmd\n" if $opts{verbose};
    unless ($opts{notify}) {
d200 1
a200 1
    my(@@names) = @@_;
d203 1
a203 1
    foreach my $name (@@names) {
d206 1
a206 1
	print "  unlink $name\n" if $opts{verbose};
d208 1
a208 1
	    or warn "Couldn't unlink $name: $!\n" ) unless $opts{notify};
d217 1
a217 1
    print $opts{verbose} ? "  ln $from $to\n" : "  $to\n" unless $opts{silent};
d224 1
a224 1
          unless $opts{notify};
d230 1
a230 1
          unless $opts{notify};
d236 1
a236 1
    my($from,$to) = @@_;
d250 1
a250 1
    my($mode,$name) = @@_;
d252 1
a252 1
    printf "  chmod %o %s\n", $mode, $name if $opts{verbose};
d254 1
a254 1
	unless $opts{notify};
d258 2
a259 2
    my($p1, $p2) = @@_;
    my($dev1, $ino1, $dev2, $ino2);
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d2 1
a2 1
BEGIN { @@INC = qw(lib) }
a9 1
use Pod::Man;
d11 2
a12 5
use vars qw($packlist);

if ($Config{d_umask}) {
    umask(022); # umasks like 077 aren't that useful for installations
}
d33 1
d53 1
a69 1

d71 1
a71 1
pod2man('pod', $opts{man1dir}, $opts{man1ext});
d74 1
a74 1
pod2man('lib', $opts{man3dir}, $opts{man3ext});
d77 13
a89 17
my $has_man1dir = $opts{man1dir} ne '' && -d $opts{man1dir};
open UTILS, "utils.lst" or die "Can't open 'utils.lst': $!";
while (<UTILS>) {
    next if /^#/;
    chomp;
    $_ = $1 if /#.*pod\s*=\s*(\S+)/;
    my ($where, $what) = m|^(\S*)/(\S+)|;
    pod2man($where, $opts{man1dir}, $opts{man1ext}, $what);
    if ($has_man1dir) {
	if (my ($where2, $what2) = m|#.*link\s*=\s*(\S+)/(\S+)|) {
	    my $old = "$opts{man1dir}/$what.$opts{man1ext}";
	    my $new = "$opts{man1dir}/$what2.$opts{man1ext}";
	    unlink($new);
	    link($old, $new);
	}
    }
}
d91 1
a91 1
sub pod2man {
d95 7
d112 15
a126 1
    print "installing from $poddir\n" if $opts{verbose};
d129 3
a131 6
    # Make a list of all the .pm and .pod files in the directory.  We avoid
    # chdir because we are running with @@INC = '../lib', and modules may wish
    # to dynamically require Carp::Heavy or other diagnostics warnings.
    # Hash the names of files we find, keys are names relative to perl build
    # dir ('.'), values are names relative to $poddir.
    my %modpods;
d133 1
a133 1
	%modpods = (map {+"$poddir/$_", $_} @@script);
d136 2
a137 10
	File::Find::find({no_chdir=>1,
                          wanted => sub {
                              # $_ is $File::Find::name when using no_chdir
                              if (-f $_ and /\.p(?:m|od)$/) {
                                  my $fullname = $_;
                                  s!^\Q$poddir\E/!!;
                                  $modpods{$fullname} = $_;
                              }
                          }},
                         $poddir);
d140 2
a141 2
    foreach my $mod (sort keys %modpods) {
        my $manpage = $modpods{$mod};
d145 1
a145 2
	next if $mod =~ m:/t/:; # no pods from test directories 
	next if ($manpage eq 'Pod/Functions.pm'); #### Used only by pod itself
d160 21
d182 6
a187 17
    my $parser = Pod::Man->new( section => $manext,
                                official=> 1,
                                center  => 'Perl Programmers Reference Guide'
                              );
    foreach my $page (@@to_process) {
	my($pod, $tmp, $manpage) = @@$page;

        print "  $manpage\n";
	if (!$opts{notify} && $parser->parse_from_file($pod, $tmp)) {
            if (-s $tmp) {
                if (rename($tmp, $manpage)) {
                    $packlist->{$manpage} = { type => 'file' };
                    next;
                }
            }
            unlink($tmp);
	}
d200 15
d233 1
a233 1
    print "  ln $from $to\n" if $opts{verbose};
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d44 1
a44 1
                destdir:s notify n help silent S verbose V)) 
d48 1
a48 1
$opts{man1dir} = "$opts{destdir}$Config{'installman1dir'}"
d52 1
a52 1
$opts{man3dir} = "$opts{destdir}$Config{'installman3dir'}"
d64 1
a64 1
-d  "$opts{destdir}$Config{'installprivlib'}"
d70 1
a70 1
$packlist = ExtUtils::Packlist->new("$opts{destdir}$Config{installarchlib}/.packlist");
a144 19
	# Skip files without pod docs
	my $has_pod;
	if (open T, $mod)
	{
	    local $_;
	    while (<T>)
	    {
		++$has_pod and last if /^=(?:head\d+|item|pod)\b/;
	    }

	    close T;
	}

	unless ($has_pod)
	{
	    warn "no documentation in $mod\n";
	    next;
	}

d166 1
a166 3
	my $xmanpage = $manpage;
	$xmanpage =~ s/^\Q$opts{'destdir'}\E// if $opts{'destdir'};
        print "  $xmanpage\n";
d170 1
a170 1
                    $packlist->{$xmanpage} = { type => 'file' };
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@a93 5
	    my $xold = $old;
	    $xold =~ s/^\Q$opts{'destdir'}\E// if $opts{'destdir'};
	    my $xnew = $new;
	    $xnew =~ s/^\Q$opts{'destdir'}\E// if $opts{'destdir'};
	    $packlist->{$xnew} = { from => $xold, type => 'link' };
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a3 26

BEGIN {
    use Config;
    if ($Config{userelocatableinc}) {
	# This might be a considered a hack. Need to get information about the
	# configuration from Config.pm *before* Config.pm expands any .../
	# prefixes.
	#
	# So we set $^X to pretend that we're the already installed perl, so
	# Config.pm doesits ... expansion off that location.

	my $location = $Config{initialinstalllocation};
	die <<'OS' unless defined $location;
$Config{initialinstalllocation} is not defined - can't install a relocatable
perl without this.
OS
	$^X = "$location/perl";
	# And then remove all trace of ever having loaded Config.pm, so that
	# it will reload with the revised $^X
	undef %Config::;
	delete $INC{"Config.pm"};
	delete $INC{"Config_heavy.pl"};
	# You never saw us. We weren't here.
    }
}

a46 1
$opts{destdir} //= '';
d183 4
a189 4
        my $parser = Pod::Man->new( section => $manext,
                                    official=> 1,
                                    center  => 'Perl Programmers Reference Guide'
                                  );
d209 1
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d2 3
d6 22
a27 4
    @@INC = qw(lib);
    
    # This needs to be at BEGIN time, before any use of Config
    require './install_lib.pl';
a28 1
use strict;
d30 1
d37 6
a42 2
use vars qw($Is_VMS $Is_W32 $Is_OS2 $Is_Cygwin $Is_Darwin $Is_NetWare
	    %opts $packlist);
d46 2
d67 1
d75 8
a82 4
foreach my $pre (qw(man1 man3)) {
    $opts{"${pre}dir"} //= $opts{destdir} . $Config{"install${pre}dir"};
    $opts{"${pre}ext"} //= $Config{"${pre}ext"};
}
d237 39
d288 22
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 1
a4 1

d11 3
a13 1
require File::Path;
d16 2
a17 4
use vars qw(%opts $packlist);

require './Porting/pod_lib.pl';
my %man1 = (map {($_->[0], $_->[1])} @@{get_pod_metadata()->{master}});
d29 1
d41 2
a42 2
            qw( man1dir=s man1ext=s man3dir=s man3ext=s
                destdir:s notify n help silent S verbose V))
d57 1
a57 1
-x  "./perl$Config{exe_ext}"
d67 1
d69 1
a69 1
pod2man(\%man1, $opts{man1dir}, $opts{man1ext}, 'pod');
d72 1
a72 5
{
    my $found = pods_to_install();
    pod2man($found->{$_}, $opts{man3dir}, $opts{man3ext}, 'lib')
        foreach qw(MODULE PRAGMA);
}
d76 2
a77 2
my $fh = open_or_die('utils.lst');
while (<$fh>) {
d80 3
a82 4
    my ($path, $leaf) = m|^(\S*/(\S+))|;
    # Have we already installed the manpage for this? (eg perldoc, a2p)
    next if $man1{$leaf};
    pod2man({$leaf, $path}, $opts{man1dir}, $opts{man1ext});
d84 3
a86 3
        if (my ($link) = m|#.*link\s*=\s*\S+/(\S+)|) {
            my $old = "$opts{man1dir}/$leaf.$opts{man1ext}";
            my $new = "$opts{man1dir}/$link.$opts{man1ext}";
d89 5
a93 3
            $old =~ s/^\Q$opts{destdir}\E// if $opts{destdir};
            $new =~ s/^\Q$opts{destdir}\E// if $opts{destdir};
            $packlist->{$new} = { from => $old, type => 'link' };
a96 1
close $fh or my_die("close 'utils.lst': $!");
d99 3
a101 1
    my($modpods, $mandir, $manext, $where) = @@_;
d103 7
a109 16
        if ($where) {
            warn "Skipping installation of $where man pages.\n"
        } else {
            warn "Skipping installation of $_ man page.\n"
                foreach values %$modpods;
        }
        return;
    }

    if ($opts{verbose}) {
        if ($where) {
            print "installing from $where\n";
        } else {
            print "installing $_\n"
                foreach sort keys %$modpods;
        }
d112 1
a112 1
    File::Path::mkpath($mandir, $opts{verbose}, 0777) unless $opts{notify};
d114 30
a143 2
    foreach my $manpage (sort keys %$modpods) {
        my $mod = $modpods->{$manpage};
d147 10
a156 11
        my $fh = open_or_die($mod);
        while (my $line = <$fh>) {
            if ($line =~ /^=head1\b/) {
                ++$has_pod;
                last;
            }
        }
	close $fh or my_die("close '$mod': $!");
        # Sadly it doesn't seem possible to re-use this handle for the call
        # to parse_from_file() below, as Pod::Man relies on source_filename(),
        # which Pod::Simple only sets accurately if it opens the file itself.
d164 3
d168 4
a171 1
            $manpage =~ s#::#.#g;
d173 1
a173 1
        my $tmp = "${mandir}/${manpage}.tmp";
d175 5
d188 1
a188 1
        if (!$opts{notify} && $parser->parse_from_file($mod, $tmp)) {
d203 2
d212 1
a212 1
	warn("Cannot rename to '$to.$i': $!"), return 0
a217 7

# Local variables:
# cperl-indent-level: 4
# indent-tabs-mode: nil
# End:
#
# ex: set ts=8 sts=4 sw=4 et:
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d142 1
a142 1
	    warn "no documentation in $mod\n" unless $opts{silent};
d158 1
a158 1
        print "  $xmanpage\n" unless $opts{silent};
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@a1 1

a5 1
    # install_lib itself loads and imports Config into main::
a7 1

d11 1
a38 3
# --strip intentionally does nothing. By permitting installman to accept it
# without error, the Makefile can pass the same options to installperl and
# installman, which permits more simplification there than this comment costs.
d41 1
a41 1
                destdir:s notify|n help|h|? silent|S verbose|V strip))
d50 3
a52 1
$opts{verbose} ||= $opts{notify};
d121 1
a121 1
    mkpath($mandir);
d161 1
a161 1
                if (safe_rename($tmp, $manpage)) {
d173 14
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@d86 1
a86 1
    # Have we already installed the manpage for this? (eg perldoc)
d145 1
a145 1
	    print "no documentation in $mod\n" if $opts{verbose};
d177 5
@


