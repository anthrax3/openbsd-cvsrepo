head	1.8;
access;
symbols
	OPENBSD_6_2:1.8.0.34
	OPENBSD_6_2_BASE:1.8
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.8.0.32
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.8.0.30
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.24
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.26
	OPENBSD_5_8_BASE:1.8
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.8.0.18
	OPENBSD_5_7_BASE:1.8
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.8.0.22
	OPENBSD_5_6_BASE:1.8
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.8.0.20
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.16
	OPENBSD_5_4_BASE:1.8
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.7.0.16
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.12
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2009.10.12.18.24.38;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.56.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.31;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.31;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.18;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.49;	author millert;	state Exp;
branches;
next	;


desc
@@


1.8
log
@Merge in perl 5.10.1
@
text
@package Symbol;

=head1 NAME

Symbol - manipulate Perl symbols and their names

=head1 SYNOPSIS

    use Symbol;

    $sym = gensym;
    open($sym, "filename");
    $_ = <$sym>;
    # etc.

    ungensym $sym;      # no effect

    # replace *FOO{IO} handle but not $FOO, %FOO, etc.
    *FOO = geniosym;

    print qualify("x"), "\n";              # "main::x"
    print qualify("x", "FOO"), "\n";       # "FOO::x"
    print qualify("BAR::x"), "\n";         # "BAR::x"
    print qualify("BAR::x", "FOO"), "\n";  # "BAR::x"
    print qualify("STDOUT", "FOO"), "\n";  # "main::STDOUT" (global)
    print qualify(\*x), "\n";              # returns \*x
    print qualify(\*x, "FOO"), "\n";       # returns \*x

    use strict refs;
    print { qualify_to_ref $fh } "foo!\n";
    $ref = qualify_to_ref $name, $pkg;

    use Symbol qw(delete_package);
    delete_package('Foo::Bar');
    print "deleted\n" unless exists $Foo::{'Bar::'};

=head1 DESCRIPTION

C<Symbol::gensym> creates an anonymous glob and returns a reference
to it.  Such a glob reference can be used as a file or directory
handle.

For backward compatibility with older implementations that didn't
support anonymous globs, C<Symbol::ungensym> is also provided.
But it doesn't do anything.

C<Symbol::geniosym> creates an anonymous IO handle.  This can be
assigned into an existing glob without affecting the non-IO portions
of the glob.

C<Symbol::qualify> turns unqualified symbol names into qualified
variable names (e.g. "myvar" -E<gt> "MyPackage::myvar").  If it is given a
second parameter, C<qualify> uses it as the default package;
otherwise, it uses the package of its caller.  Regardless, global
variable names (e.g. "STDOUT", "ENV", "SIG") are always qualified with
"main::".

Qualification applies only to symbol names (strings).  References are
left unchanged under the assumption that they are glob references,
which are qualified by their nature.

C<Symbol::qualify_to_ref> is just like C<Symbol::qualify> except that it
returns a glob ref rather than a symbol name, so you can use the result
even if C<use strict 'refs'> is in effect.

C<Symbol::delete_package> wipes out a whole package namespace.  Note
this routine is not exported by default--you may want to import it
explicitly.

=head1 BUGS

C<Symbol::delete_package> is a bit too powerful. It undefines every symbol that
lives in the specified package. Since perl, for performance reasons, does not
perform a symbol table lookup each time a function is called or a global
variable is accessed, some code that has already been loaded and that makes use
of symbols in package C<Foo> may stop working after you delete C<Foo>, even if
you reload the C<Foo> module afterwards.

=cut

BEGIN { require 5.005; }

require Exporter;
@@ISA = qw(Exporter);
@@EXPORT = qw(gensym ungensym qualify qualify_to_ref);
@@EXPORT_OK = qw(delete_package geniosym);

$VERSION = '1.07';

my $genpkg = "Symbol::";
my $genseq = 0;

my %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);

#
# Note that we never _copy_ the glob; we just make a ref to it.
# If we did copy it, then SVf_FAKE would be set on the copy, and
# glob-specific behaviors (e.g. C<*$ref = \&func>) wouldn't work.
#
sub gensym () {
    my $name = "GEN" . $genseq++;
    my $ref = \*{$genpkg . $name};
    delete $$genpkg{$name};
    $ref;
}

sub geniosym () {
    my $sym = gensym();
    # force the IO slot to be filled
    select(select $sym);
    *$sym{IO};
}

sub ungensym ($) {}

sub qualify ($;$) {
    my ($name) = @@_;
    if (!ref($name) && index($name, '::') == -1 && index($name, "'") == -1) {
	my $pkg;
	# Global names: special character, "^xyz", or other. 
	if ($name =~ /^(([^a-z])|(\^[a-z_]+))\z/i || $global{$name}) {
	    # RGS 2001-11-05 : translate leading ^X to control-char
	    $name =~ s/^\^([a-z_])/'qq(\c'.$1.')'/eei;
	    $pkg = "main";
	}
	else {
	    $pkg = (@@_ > 1) ? $_[1] : caller;
	}
	$name = $pkg . "::" . $name;
    }
    $name;
}

sub qualify_to_ref ($;$) {
    return \*{ qualify $_[0], @@_ > 1 ? $_[1] : caller };
}

#
# of Safe.pm lineage
#
sub delete_package ($) {
    my $pkg = shift;

    # expand to full symbol table name if needed

    unless ($pkg =~ /^main::.*::$/) {
        $pkg = "main$pkg"	if	$pkg =~ /^::/;
        $pkg = "main::$pkg"	unless	$pkg =~ /^main::/;
        $pkg .= '::'		unless	$pkg =~ /::$/;
    }

    my($stem, $leaf) = $pkg =~ m/(.*::)(\w+::)$/;
    my $stem_symtab = *{$stem}{HASH};
    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};


    # free all the symbols in the package

    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};
    foreach my $name (keys %$leaf_symtab) {
        undef *{$pkg . $name};
    }

    # delete the symbol table

    %$leaf_symtab = ();
    delete $stem_symtab->{$leaf};
}

1;
@


1.7
log
@merge in perl 5.8.8
@
text
@d21 2
a22 2
    print qualify("x"), "\n";              # "Test::x"
    print qualify("x", "FOO"), "\n"        # "FOO::x"
d88 1
a88 1
$VERSION = '1.06';
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d72 6
a77 7
C<Symbol::delete_package> is a bit too powerful. It undefines every symbol
that lives in the specified package and in its sub-packages. Since perl,
for performance reasons, does not perform a symbol table lookup each time
a function is called or a global variable is accessed, some code that has
already been loaded and that makes use of symbols in package C<Foo> may
stop working after you delete C<Foo>, even if you reload the C<Foo> module
afterwards.
d88 1
a88 1
$VERSION = '1.05';
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@a36 1

d70 10
d89 1
a89 1
$VERSION = 1.04;
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d18 3
d48 4
d73 1
a73 1
BEGIN { require 5.002; }
d78 1
a78 1
@@EXPORT_OK = qw(delete_package);
d80 1
a80 1
$VERSION = 1.02;
d99 7
d112 4
a115 2
	# Global names: special character, "^x", or other. 
	if ($name =~ /^([^a-z])|(\^[a-z])$/i || $global{$name}) {
@


1.3
log
@perl5.005_03 (stock)
@
text
@d132 9
a140 2
    my $leaf_glob   = $stem_symtab->{$leaf};
    my $leaf_symtab = *{$leaf_glob}{HASH};
@


1.2
log
@perl 5.004_04
@
text
@d30 5
d49 1
a49 1
variable names (e.g. "STDOUT", "ENV", "SIG") are always qualfied with
d60 4
d71 1
d112 25
@


1.1
log
@Initial revision
@
text
@d26 4
d41 1
a41 1
variable names (e.g. "myvar" -> "MyPackage::myvar").  If it is given a
d51 4
d61 1
d63 1
a63 1
@@EXPORT = qw(gensym ungensym qualify);
d68 1
a68 6
my %global;
while (<DATA>) {
    chomp;
    $global{$_} = 1;
}
close DATA;
d70 5
d77 3
a79 2
    local *{$genpkg . $name};
    \delete ${$genpkg}{$name};
d100 4
a104 10

__DATA__
ARGV
ARGVOUT
ENV
INC
SIG
STDERR
STDIN
STDOUT
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a25 9
    use strict refs;
    print { qualify_to_ref $fh } "foo!\n";
    $ref = qualify_to_ref $name, $pkg;

    use Symbol qw(delete_package);
    delete_package('Foo::Bar');
    print "deleted\n" unless exists $Foo::{'Bar::'};


d37 1
a37 1
variable names (e.g. "myvar" -E<gt> "MyPackage::myvar").  If it is given a
d40 1
a40 1
variable names (e.g. "STDOUT", "ENV", "SIG") are always qualified with
a46 8
C<Symbol::qualify_to_ref> is just like C<Symbol::qualify> except that it
returns a glob ref rather than a symbol name, so you can use the result
even if C<use strict 'refs'> is in effect.

C<Symbol::delete_package> wipes out a whole package namespace.  Note
this routine is not exported by default--you may want to import it
explicitly.

a52 2
@@EXPORT = qw(gensym ungensym qualify qualify_to_ref);
@@EXPORT_OK = qw(delete_package);
d54 1
a54 1
$VERSION = 1.02;
d59 6
a64 1
my %global = map {$_ => 1} qw(ARGV ARGVOUT ENV INC SIG STDERR STDIN STDOUT);
a65 5
#
# Note that we never _copy_ the glob; we just make a ref to it.
# If we did copy it, then SVf_FAKE would be set on the copy, and
# glob-specific behaviors (e.g. C<*$ref = \&func>) wouldn't work.
#
d68 2
a69 3
    my $ref = \*{$genpkg . $name};
    delete $$genpkg{$name};
    $ref;
d90 1
a90 3
sub qualify_to_ref ($;$) {
    return \*{ qualify $_[0], @@_ > 1 ? $_[1] : caller };
}
d92 9
a100 26
#
# of Safe.pm lineage
#
sub delete_package ($) {
    my $pkg = shift;

    # expand to full symbol table name if needed

    unless ($pkg =~ /^main::.*::$/) {
        $pkg = "main$pkg"	if	$pkg =~ /^::/;
        $pkg = "main::$pkg"	unless	$pkg =~ /^main::/;
        $pkg .= '::'		unless	$pkg =~ /::$/;
    }

    my($stem, $leaf) = $pkg =~ m/(.*::)(\w+::)$/;
    my $stem_symtab = *{$stem}{HASH};
    return unless defined $stem_symtab and exists $stem_symtab->{$leaf};

    my $leaf_glob   = $stem_symtab->{$leaf};
    my $leaf_symtab = *{$leaf_glob}{HASH};

    %$leaf_symtab = ();
    delete $stem_symtab->{$leaf};
}

1;
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d132 2
a133 9

    # free all the symbols in the package

    my $leaf_symtab = *{$stem_symtab->{$leaf}}{HASH};
    foreach my $name (keys %$leaf_symtab) {
        undef *{$pkg . $name};
    }

    # delete the symbol table
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a17 3
    # replace *FOO{IO} handle but not $FOO, %FOO, etc.
    *FOO = geniosym;

a44 4
C<Symbol::geniosym> creates an anonymous IO handle.  This can be
assigned into an existing glob without affecting the non-IO portions
of the glob.

d66 1
a66 1
BEGIN { require 5.005; }
d71 1
a71 1
@@EXPORT_OK = qw(delete_package geniosym);
d73 1
a73 1
$VERSION = 1.04;
a91 7
sub geniosym () {
    my $sym = gensym();
    # force the IO slot to be filled
    select(select $sym);
    *$sym{IO};
}

d98 2
a99 4
	# Global names: special character, "^xyz", or other. 
	if ($name =~ /^(([^a-z])|(\^[a-z_]+))\z/i || $global{$name}) {
	    # RGS 2001-11-05 : translate leading ^X to control-char
	    $name =~ s/^\^([a-z_])/'qq(\c'.$1.')'/eei;
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d37 1
a70 10
=head1 BUGS

C<Symbol::delete_package> is a bit too powerful. It undefines every symbol
that lives in the specified package and in its sub-packages. Since perl,
for performance reasons, does not perform a symbol table lookup each time
a function is called or a global variable is accessed, some code that has
already been loaded and that makes use of symbols in package C<Foo> may
stop working after you delete C<Foo>, even if you reload the C<Foo> module
afterwards.

d80 1
a80 1
$VERSION = '1.05';
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d72 7
a78 6
C<Symbol::delete_package> is a bit too powerful. It undefines every symbol that
lives in the specified package. Since perl, for performance reasons, does not
perform a symbol table lookup each time a function is called or a global
variable is accessed, some code that has already been loaded and that makes use
of symbols in package C<Foo> may stop working after you delete C<Foo>, even if
you reload the C<Foo> module afterwards.
d89 1
a89 1
$VERSION = '1.06';
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d21 2
a22 2
    print qualify("x"), "\n";              # "main::x"
    print qualify("x", "FOO"), "\n";       # "FOO::x"
d88 1
a88 1
$VERSION = '1.07';
@


