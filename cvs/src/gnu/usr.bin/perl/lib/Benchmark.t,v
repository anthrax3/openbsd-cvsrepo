head	1.2;
access;
symbols
	OPENBSD_6_2:1.2.0.2
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.6.0.10
	OPENBSD_6_0_BASE:1.1.1.6
	OPENBSD_5_9:1.1.1.6.0.4
	OPENBSD_5_9_BASE:1.1.1.6
	OPENBSD_5_8:1.1.1.6.0.6
	OPENBSD_5_8_BASE:1.1.1.6
	PERL_5_20_2:1.1.1.6
	OPENBSD_5_7:1.1.1.6.0.2
	OPENBSD_5_7_BASE:1.1.1.6
	PERL_5_20_1:1.1.1.6
	OPENBSD_5_6:1.1.1.5.0.8
	OPENBSD_5_6_BASE:1.1.1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.5.0.6
	OPENBSD_5_5_BASE:1.1.1.5
	OPENBSD_5_4:1.1.1.5.0.2
	OPENBSD_5_4_BASE:1.1.1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.1.1.4.0.10
	OPENBSD_5_3_BASE:1.1.1.4
	OPENBSD_5_2:1.1.1.4.0.8
	OPENBSD_5_2_BASE:1.1.1.4
	OPENBSD_5_1_BASE:1.1.1.4
	OPENBSD_5_1:1.1.1.4.0.6
	OPENBSD_5_0:1.1.1.4.0.4
	OPENBSD_5_0_BASE:1.1.1.4
	OPENBSD_4_9:1.1.1.4.0.2
	OPENBSD_4_9_BASE:1.1.1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.1.1.3.0.18
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.14
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.16
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.12
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.57;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.48.31;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.35;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.50;	author sthen;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2014.11.17.20.53.07;	author afresh1;	state Exp;
branches;
next	1.1.1.7;
commitid	B31cAbBIXiCqnL97;

1.1.1.7
date	2017.08.14.13.46.13;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = ('../lib');
}

use warnings;
use strict;
use vars qw($foo $bar $baz $ballast);
use Test::More tests => 213;

use Benchmark qw(:all);

my $DELTA = 0.4;

# Some timing ballast
sub fib {
  my $n = shift;
  return $n if $n < 2;
  fib($n-1) + fib($n-2);
}
$ballast = 15;

my $All_Pattern =
    qr/(\d+) +wallclock secs? +\( *(-?\d+\.\d\d) +usr +(-?\d+\.\d\d) +sys +\+ +(-?\d+\.\d\d) +cusr +(-?\d+\.\d\d) +csys += +(-?\d+\.\d\d) +CPU\)/;
my $Noc_Pattern =
    qr/(\d+) +wallclock secs? +\( *(-?\d+\.\d\d) +usr +\+ +(-?\d+\.\d\d) +sys += +(-?\d+\.\d\d) +CPU\)/;
my $Nop_Pattern =
    qr/(\d+) +wallclock secs? +\( *(-?\d+\.\d\d) +cusr +\+ +(-?\d+\.\d\d) +csys += +\d+\.\d\d +CPU\)/;
# Please don't trust the matching parentheses to be useful in this :-)
my $Default_Pattern = qr/$All_Pattern|$Noc_Pattern/;

# see if the ratio of two integer values is within (1+$delta)

sub cmp_delta {
    my ($min, $max, $delta) = @@_;
    ($min, $max) = ($max, $min) if $max < $min;
    return 0 if $min < 1; # avoid / 0
    return $max/$min <= (1+$delta);
}

my $t0 = new Benchmark;
isa_ok ($t0, 'Benchmark', "Ensure we can create a benchmark object");

# We use the benchmark object once we've done some work:

isa_ok(timeit(5, sub {++$foo}), 'Benchmark', "timeit CODEREF");
is ($foo, 5, "benchmarked code was run 5 times");

isa_ok(timeit(5, '++$bar'), 'Benchmark', "timeit eval");
is ($bar, 5, "benchmarked code was run 5 times");

# is coderef called with spurious arguments?
timeit( 1, sub { $foo = @@_ });
is ($foo, 0, "benchmarked code called without arguments");


print "# Burning CPU to benchmark things; will take time...\n";

# We need to do something fairly slow in the coderef.
# Same coderef. Same place in memory.
my $coderef = sub {$baz += fib($ballast)};

# The default is three.
$baz = 0;
my $threesecs = countit(0, $coderef);
isa_ok($threesecs, 'Benchmark', "countit 0, CODEREF");
isnt ($baz, 0, "benchmarked code was run");
my $in_threesecs = $threesecs->iters;
print "# in_threesecs=$in_threesecs iterations\n";
cmp_ok($in_threesecs, '>', 0, "iters returned positive iterations");
my $cpu3 = $threesecs->[1]; # user
my $sys3 = $threesecs->[2]; # sys
cmp_ok($cpu3+$sys3, '>=', 3.0, "3s cpu3 is at least 3s");
my $in_threesecs_adj = $in_threesecs;
$in_threesecs_adj *= (3/$cpu3); # adjust because may not have run for exactly 3s
print "# in_threesecs_adj=$in_threesecs_adj adjusted iterations\n";

my $estimate = int (100 * $in_threesecs_adj / 3) / 100;
print "# from the 3 second run estimate $estimate iterations in 1 second...\n";
$baz = 0;
my $onesec = countit(1, $coderef);
isa_ok($onesec, 'Benchmark', "countit 1, CODEREF");
isnt ($baz, 0, "benchmarked code was run");
my $in_onesec = $onesec->iters;
print "# in_onesec=$in_onesec iterations\n";
cmp_ok($in_onesec, '>',  0, "iters returned positive iterations");
my $cpu1 = $onesec->[1]; # user
my $sys1 = $onesec->[2]; # sys
cmp_ok($cpu1+$sys1, '>=', 1.0, "is cpu1 is at least 1s");
my $in_onesec_adj = $in_onesec;
$in_onesec_adj *= (1/$cpu1); # adjust because may not have run for exactly 1s
print "# in_onesec_adj=$in_onesec_adj adjusted iterations\n";


# I found that the eval'ed version was 3 times faster than the coderef.
# (now it has a different ballast value)
$baz = 0;
my $again = countit(1, '$baz += fib($ballast)');
isa_ok($onesec, 'Benchmark', "countit 1, eval");
isnt ($baz, 0, "benchmarked code was run");
my $in_again = $again->iters;
print "# $in_again iterations\n";
cmp_ok($in_again, '>', 0, "iters returned positive iterations");


my $t1 = new Benchmark;
isa_ok ($t1, 'Benchmark', "Create another benchmark object now we're finished");

my $diff = timediff ($t1, $t0);
isa_ok ($diff, 'Benchmark', "Get the time difference");
isa_ok (timesum ($t0, $t1), 'Benchmark', "check timesum");

my $default = timestr ($diff);
isnt ($default, '', 'timestr ($diff)');
my $auto = timestr ($diff, 'auto');
is ($auto, $default, 'timestr ($diff, "auto") matches timestr ($diff)');

{
    my $all = timestr ($diff, 'all');
    like ($all, $All_Pattern, 'timestr ($diff, "all")');
    print "# $all\n";

    my ($wallclock, $usr, $sys, $cusr, $csys, $cpu) = $all =~ $All_Pattern;

    is (timestr ($diff, 'none'), '', "none suppresses output");

    my $noc = timestr ($diff, 'noc');
    like ($noc, qr/$wallclock +wallclock secs? +\( *$usr +usr +\+ +$sys +sys += +\d+\.\d\d +CPU\)/, 'timestr ($diff, "noc")');

    my $nop = timestr ($diff, 'nop');
    like ($nop, qr/$wallclock +wallclock secs? +\( *$cusr +cusr +\+ +$csys +csys += +\d+\.\d\d +CPU\)/, 'timestr ($diff, "nop")');

    if ($auto eq $noc) {
        pass ('"auto" is "noc"');
    } else {
        is ($auto, $all, '"auto" isn\'t "noc", so should be eq to "all"');
    }

    like (timestr ($diff, 'all', 'E'), 
          qr/(\d+) +wallclock secs? +\( *\d\.\d+E[-+]?\d\d\d? +usr +\d\.\d+E[-+]?\d\d\d? +sys +\+ +\d\.\d+E[-+]?\d\d\d? +cusr +\d\.\d+E[-+]?\d\d\d? +csys += +\d\.\d+E[-+]?\d\d\d? +CPU\)/, 'timestr ($diff, "all", "E") [sprintf format of "E"]');
}

my $out = tie *OUT, 'TieOut';

my $iterations = 100;

$foo = 0;
select(OUT);
my $got = timethis($iterations, sub {++$foo});
select(STDOUT);
isa_ok($got, 'Benchmark', "timethis CODEREF");
is ($foo, $iterations, "benchmarked code was run $iterations times");

$got = $out->read();
like ($got, qr/^timethis $iterations/, 'default title');
like ($got, $Default_Pattern, 'default format is all or noc');

$bar = 0;
select(OUT);
$got = timethis($iterations, '++$bar');
select(STDOUT);
isa_ok($got, 'Benchmark', "timethis eval");
is ($bar, $iterations, "benchmarked code was run $iterations times");

$got = $out->read();
like ($got, qr/^timethis $iterations/, 'default title');
like ($got, $Default_Pattern, 'default format is all or noc');

my $title = 'lies, damn lies and benchmarks';
$foo = 0;
select(OUT);
$got = timethis($iterations, sub {++$foo}, $title);
select(STDOUT);
isa_ok($got, 'Benchmark', "timethis with title");
is ($foo, $iterations, "benchmarked code was run $iterations times");

$got = $out->read();
like ($got, qr/^$title:/, 'specify title');
like ($got, $Default_Pattern, 'default format is all or noc');

# default is auto, which is all or noc. nop can never match the default
$foo = 0;
select(OUT);
$got = timethis($iterations, sub {++$foo}, $title, 'nop');
select(STDOUT);
isa_ok($got, 'Benchmark', "timethis with format");
is ($foo, $iterations, "benchmarked code was run $iterations times");

$got = $out->read();
like ($got, qr/^$title:/, 'specify title');
like ($got, $Nop_Pattern, 'specify format as nop');

{
    $foo = 0;
    select(OUT);
    my $start = time;
    $got = timethis(-2, sub {$foo+= fib($ballast)}, $title, 'none');
    my $end = time;
    select(STDOUT);
    isa_ok($got, 'Benchmark',
           "timethis, at least 2 seconds with format 'none'");
    cmp_ok($foo, '>', 0, "benchmarked code was run");
    cmp_ok($end - $start, '>', 1, "benchmarked code ran for over 1 second");

    $got = $out->read();
    # Remove any warnings about having too few iterations.
    $got =~ s/\(warning:[^\)]+\)//gs;
    $got =~ s/^[ \t\n]+//s; # Remove all the whitespace from the beginning

    is ($got, '', "format 'none' should suppress output");
}

$foo = $bar = $baz = 0;
select(OUT);
$got = timethese($iterations, { Foo => sub {++$foo}, Bar => '++$bar',
                                Baz => sub {++$baz} });
select(STDOUT);
is(ref ($got), 'HASH', "timethese should return a hashref");
isa_ok($got->{Foo}, 'Benchmark', "Foo value");
isa_ok($got->{Bar}, 'Benchmark', "Bar value");
isa_ok($got->{Baz}, 'Benchmark', "Baz value");
eq_set([keys %$got], [qw(Foo Bar Baz)], 'should be exactly three objects');
is ($foo, $iterations, "Foo code was run $iterations times");
is ($bar, $iterations, "Bar code was run $iterations times");
is ($baz, $iterations, "Baz code was run $iterations times");

$got = $out->read();
# Remove any warnings about having too few iterations.
$got =~ s/\(warning:[^\)]+\)//gs;

like ($got, qr/timing $iterations iterations of\s+Bar\W+Baz\W+Foo\W*?\.\.\./s,
      'check title');
# Remove the title
$got =~ s/.*\.\.\.//s;
like ($got, qr/\bBar\b.*\bBaz\b.*\bFoo\b/s, 'check output is in sorted order');
like ($got, $Default_Pattern, 'should find default format somewhere');


{ # ensure 'use strict' does not leak from Benchmark.pm into benchmarked code
    no strict;
    select OUT;

    eval {
        timethese( 1, 
                   { undeclared_var => q{ $i++; $i-- },
                     symbolic_ref   => q{ $bar = 42;
                                          $foo = 'bar';
                                          $q = ${$foo} },
                   },
                   'none'
                  );

    };
    is( $@@, '', q{no strict leakage in name => 'code'} );

    eval {
        timethese( 1,
                   { undeclared_var => sub { $i++; $i-- },
                     symbolic_ref   => sub { $bar = 42;
                                             $foo = 'bar';
                                             return ${$foo} },
                   },
                   'none'
                 );
    };
    is( $@@, '', q{no strict leakage in name => sub { code }} );

    # clear out buffer
    $out->read;
}


my $code_to_test =  { Foo => sub {$foo+=fib($ballast-2)},
                      Bar => sub {$bar+=fib($ballast)}};
# Keep these for later.
my $results;
{
    $foo = $bar = 0;
    select(OUT);
    my $start = times;
    $results = timethese(-0.1, $code_to_test, 'none');
    my $end = times;
    select(STDOUT);

    is(ref ($results), 'HASH', "timethese should return a hashref");
    isa_ok($results->{Foo}, 'Benchmark', "Foo value");
    isa_ok($results->{Bar}, 'Benchmark', "Bar value");
    eq_set([keys %$results], [qw(Foo Bar)], 'should be exactly two objects');
    cmp_ok($foo, '>', 0, "Foo code was run");
    cmp_ok($bar, '>', 0, "Bar code was run");

    cmp_ok($end-$start, '>', 0.1, "benchmarked code ran for over 0.1 seconds");

    $got = $out->read();
    # Remove any warnings about having too few iterations.
    $got =~ s/\(warning:[^\)]+\)//gs;
    is ($got =~ tr/ \t\n//c, 0, "format 'none' should suppress output");
}
my $graph_dissassembly =
    qr!^[ \t]+(\S+)[ \t]+(\w+)[ \t]+(\w+)[ \t]*		# Title line
    \n[ \t]*(\w+)[ \t]+([0-9.]+(?:/s)?)[ \t]+(-+)[ \t]+(-?\d+%)[ \t]*
    \n[ \t]*(\w+)[ \t]+([0-9.]+(?:/s)?)[ \t]+(-?\d+%)[ \t]+(-+)[ \t]*$!xm;

sub check_graph_consistency {
    my (	$ratetext, $slowc, $fastc,
        $slowr, $slowratet, $slowslow, $slowfastt,
        $fastr, $fastratet, $fastslowt, $fastfast)
        = @@_;
    note("calling check_graph_consistency from line " . (caller(1))[2]);
    my $all_passed = 1;
    $all_passed
      &= is ($slowc, $slowr, "left col tag should be top row tag");
    $all_passed
      &= is ($fastc, $fastr, "right col tag should be bottom row tag");
    $all_passed &=
      like ($slowslow, qr/^-+/, "should be dash for comparing slow with slow");
    $all_passed
      &= is ($slowslow, $fastfast, "slow v slow should be same as fast v fast");
    my $slowrate = $slowratet;
    my $fastrate = $fastratet;
    my ($slow_is_rate, $fast_is_rate);
    unless ($slow_is_rate = $slowrate =~ s!/s!!) {
        # Slow is expressed as iters per second.
        $slowrate = 1/$slowrate if $slowrate;
    }
    unless ($fast_is_rate = $fastrate =~ s!/s!!) {
        # Fast is expressed as iters per second.
        $fastrate = 1/$fastrate if $fastrate;
    }
    if ($ratetext =~ /rate/i) {
        $all_passed
          &= ok ($slow_is_rate, "slow should be expressed as a rate");
        $all_passed
          &= ok ($fast_is_rate, "fast should be expressed as a rate");
    } else {
        $all_passed &=
          ok (!$slow_is_rate, "slow should be expressed as a iters per second");
        $all_passed &=
          ok (!$fast_is_rate, "fast should be expressed as a iters per second");
    }

    (my $slowfast = $slowfastt) =~ s!%!!;
    (my $fastslow = $fastslowt) =~ s!%!!;
    if ($slowrate < $fastrate) {
        pass ("slow rate is less than fast rate");
        unless (ok ($slowfast <= 0 && $slowfast >= -100,
                    "slowfast should be less than or equal to zero, and >= -100")) {
          diag("slowfast=$slowfast");
          $all_passed = 0;
        }
        unless (cmp_ok($fastslow, '>', 0, "fastslow should be > 0")) {
          $all_passed = 0;
        }
    } else {
        $all_passed
          &= is ($slowrate, $fastrate,
                 "slow rate isn't less than fast rate, so should be the same");
	# In OpenBSD the $slowfast is sometimes a really, really, really
	# small number less than zero, and this gets stringified as -0.
        $all_passed
          &= like ($slowfast, qr/^-?0$/, "slowfast should be zero");
        $all_passed
          &= like ($fastslow, qr/^-?0$/, "fastslow should be zero");
    }
    return $all_passed;
}

sub check_graph_vs_output {
    my ($chart, $got) = @@_;
    my (	$ratetext, $slowc, $fastc,
        $slowr, $slowratet, $slowslow, $slowfastt,
        $fastr, $fastratet, $fastslowt, $fastfast)
        = $got =~ $graph_dissassembly;
    my $all_passed
      = check_graph_consistency (        $ratetext, $slowc, $fastc,
                                 $slowr, $slowratet, $slowslow, $slowfastt,
                                 $fastr, $fastratet, $fastslowt, $fastfast);
    $all_passed
      &= is_deeply ($chart, [['', $ratetext, $slowc, $fastc],
                             [$slowr, $slowratet, $slowslow, $slowfastt],
                             [$fastr, $fastratet, $fastslowt, $fastfast]],
                    "check the chart layout matches the formatted output");
    unless ($all_passed) {
      diag("Something went wrong there. I got this chart:\n$got");
    }
}

sub check_graph {
    my ($title, $row1, $row2) = @@_;
    is (scalar @@$title, 4, "Four entries in title row");
    is (scalar @@$row1, 4, "Four entries in first row");
    is (scalar @@$row2, 4, "Four entries in second row");
    is (shift @@$title, '', "First entry of output graph should be ''");
    check_graph_consistency (@@$title, @@$row1, @@$row2);
}

{
    select(OUT);
    my $start = times;
    my $chart = cmpthese( -0.1, { a => "\$i = sqrt(\$i++) * sqrt(\$i) for 1..10",
                                  b => "\$i = sqrt(\$i++)",
                                }, "auto" ) ;
    my $end = times;
    select(STDOUT);
    cmp_ok($end - $start, '>', 0.05,
                            "benchmarked code ran for over 0.05 seconds");

    $got = $out->read();
    # Remove any warnings about having too few iterations.
    $got =~ s/\(warning:[^\)]+\)//gs;

    like ($got, qr/running\W+a\W+b.*?for at least 0\.1 CPU second/s,
          'check title');
    # Remove the title
    $got =~ s/.*\.\.\.//s;
    like ($got, $Default_Pattern, 'should find default format somewhere');
    like ($got, $graph_dissassembly, "Should find the output graph somewhere");
    check_graph_vs_output ($chart, $got);
}

# Not giving auto should suppress timethese results.
{
    select(OUT);
    my $start = times;
    my $chart = cmpthese( -0.1, { a => "\$i = sqrt(\$i++) * sqrt(\$i) for 1..10",
                                  b => "\$i = sqrt(\$i++)" });
    my $end = times;
    select(STDOUT);
    cmp_ok($end - $start, '>', 0.05,
            "benchmarked code ran for over 0.05 seconds");

    $got = $out->read();
    # Remove any warnings about having too few iterations.
    $got =~ s/\(warning:[^\)]+\)//gs;

    unlike ($got, qr/running\W+a\W+b.*?for at least 0\.1 CPU second/s,
          'should not have title');
    # Remove the title
    $got =~ s/.*\.\.\.//s;
    unlike ($got, $Default_Pattern, 'should not find default format somewhere');
    like ($got, $graph_dissassembly, "Should find the output graph somewhere");
    check_graph_vs_output ($chart, $got);
}

{
    $foo = $bar = 0;
    select(OUT);
    my $chart = cmpthese($iterations, $code_to_test, 'nop' ) ;
    select(STDOUT);
    cmp_ok($foo, '>', 0, "Foo code was run");
    cmp_ok($bar, '>', 0, "Bar code was run");

    $got = $out->read();
    # Remove any warnings about having too few iterations.
    $got =~ s/\(warning:[^\)]+\)//gs;
    like ($got, qr/timing $iterations iterations of\s+Bar\W+Foo\W*?\.\.\./s,
      'check title');
    # Remove the title
    $got =~ s/.*\.\.\.//s;
    like ($got, $Nop_Pattern, 'specify format as nop');
    like ($got, $graph_dissassembly, "Should find the output graph somewhere");
    check_graph_vs_output ($chart, $got);
}

{
    $foo = $bar = 0;
    select(OUT);
    my $chart = cmpthese($iterations, $code_to_test, 'none' ) ;
    select(STDOUT);
    cmp_ok($foo, '>', 0, "Foo code was run");
    cmp_ok($bar, '>', 0, "Bar code was run");

    $got = $out->read();
    # Remove any warnings about having too few iterations.
    $got =~ s/\(warning:[^\)]+\)//gs;
    $got =~ s/^[ \t\n]+//s; # Remove all the whitespace from the beginning
    is ($got, '', "format 'none' should suppress output");
    is (ref $chart, 'ARRAY', "output should be an array ref");
    # Some of these will go bang if the preceding test fails. There will be
    # a big clue as to why, from the previous test's diagnostic
    is (ref $chart->[0], 'ARRAY', "output should be an array of arrays");
    check_graph (@@$chart);
}

# this is a repeat of the above test, but with the timing and charting
# steps split.

{
    $foo = $bar = 0;
    select(OUT);
    my $res = timethese($iterations, $code_to_test, 'none' ) ;
    my $chart = cmpthese($res, 'none' ) ;
    select(STDOUT);
    cmp_ok($foo, '>', 0, "Foo code was run");
    cmp_ok($bar, '>', 0, "Bar code was run");

    $got = $out->read();
    # Remove any warnings about having too few iterations.
    $got =~ s/\(warning:[^\)]+\)//gs;
    $got =~ s/^[ \t\n]+//s; # Remove all the whitespace from the beginning
    is ($got, '', "format 'none' should suppress output");
    is (ref $chart, 'ARRAY', "output should be an array ref");
    # Some of these will go bang if the preceding test fails. There will be
    # a big clue as to why, from the previous test's diagnostic
    is (ref $chart->[0], 'ARRAY', "output should be an array of arrays");
    use Data::Dumper;
    check_graph(@@$chart)
        or diag(Data::Dumper->Dump([$res, $chart], ['$res', '$chart']));
}

{
    $foo = $bar = 0;
    select(OUT);
    my $chart = cmpthese( $results ) ;
    select(STDOUT);
    is ($foo, 0, "Foo code was not run");
    is ($bar, 0, "Bar code was not run");

    $got = $out->read();
    unlike($got, qr/\.\.\./s, 'check that there is no title');
    like ($got, $graph_dissassembly, "Should find the output graph somewhere");
    check_graph_vs_output ($chart, $got);
}

{
    $foo = $bar = 0;
    select(OUT);
    my $chart = cmpthese( $results, 'none' ) ;
    select(STDOUT);
    is ($foo, 0, "Foo code was not run");
    is ($bar, 0, "Bar code was not run");

    $got = $out->read();
    is ($got, '', "'none' should suppress all output");
    is (ref $chart, 'ARRAY', "output should be an array ref");
    # Some of these will go bang if the preceding test fails. There will be
    # a big clue as to why, from the previous test's diagnostic
    is (ref $chart->[0], 'ARRAY', "output should be an array of arrays");
    check_graph (@@$chart);
}

###}my $out = tie *OUT, 'TieOut'; my ($got); ###

my $debug = tie *STDERR, 'TieOut';

$bar = 0;
isa_ok(timeit(5, '++$bar'), 'Benchmark', "timeit eval");
is ($bar, 5, "benchmarked code was run 5 times");
is ($debug->read(), '', "There was no debug output");

Benchmark->debug(1);

$bar = 0;
select(OUT);
$got = timeit(5, '++$bar');
select(STDOUT);
isa_ok($got, 'Benchmark', "timeit eval");
is ($bar, 5, "benchmarked code was run 5 times");
is ($out->read(), '', "There was no STDOUT output with debug enabled");
isnt ($debug->read(), '', "There was STDERR debug output with debug enabled");

Benchmark->debug(0);

$bar = 0;
isa_ok(timeit(5, '++$bar'), 'Benchmark', "timeit eval");
is ($bar, 5, "benchmarked code was run 5 times");
is ($debug->read(), '', "There was no debug output debug disabled");

undef $debug;
untie *STDERR;

# To check the cache we are poking where we don't belong, inside the namespace.
# The way benchmark is written we can't actually check whether the cache is
# being used, merely what's become cached.

clearallcache();
my @@before_keys = keys %Benchmark::Cache;
$bar = 0;
isa_ok(timeit(5, '++$bar'), 'Benchmark', "timeit eval");
is ($bar, 5, "benchmarked code was run 5 times");
my @@after5_keys = keys %Benchmark::Cache;
$bar = 0;
isa_ok(timeit(10, '++$bar'), 'Benchmark', "timeit eval");
is ($bar, 10, "benchmarked code was run 10 times");
ok (!eq_array ([keys %Benchmark::Cache], \@@after5_keys), "10 differs from 5");

clearcache(10);
# Hash key order will be the same if there are the same keys.
is_deeply ([keys %Benchmark::Cache], \@@after5_keys,
           "cleared 10, only cached results for 5 should remain");

clearallcache();
is_deeply ([keys %Benchmark::Cache], \@@before_keys,
           "back to square 1 when we clear the cache again?");


{   # Check usage error messages
    my %usage = %Benchmark::_Usage;
    delete $usage{runloop};  # not public, not worrying about it just now

    my @@takes_no_args = qw(clearallcache disablecache enablecache);

    my %cmpthese = ('forgot {}' => 'cmpthese( 42, foo => sub { 1 } )',
                     'not result' => 'cmpthese(42)',
                     'array ref'  => 'cmpthese( 42, [ foo => sub { 1 } ] )',
                    );
    while( my($name, $code) = each %cmpthese ) {
        eval $code;
        is( $@@, $usage{cmpthese}, "cmpthese usage: $name" );
    }

    my %timethese = ('forgot {}'  => 'timethese( 42, foo => sub { 1 } )',
                       'no code'    => 'timethese(42)',
                       'array ref'  => 'timethese( 42, [ foo => sub { 1 } ] )',
                      );

    while( my($name, $code) = each %timethese ) {
        eval $code;
        is( $@@, $usage{timethese}, "timethese usage: $name" );
    }


    while( my($func, $usage) = each %usage ) {
        next if grep $func eq $_, @@takes_no_args;
        eval "$func()";
        is( $@@, $usage, "$func usage: no args" );
    }

    foreach my $func (@@takes_no_args) {
        eval "$func(42)";
        is( $@@, $usage{$func}, "$func usage: with args" );
    }
}


package TieOut;

sub TIEHANDLE {
    my $class = shift;
    bless(\( my $ref = ''), $class);
}

sub PRINT {
    my $self = shift;
    $$self .= join('', @@_);
}

sub PRINTF {
    my $self = shift;
    $$self .= sprintf shift, @@_;
}

sub read {
    my $self = shift;
    return substr($$self, 0, length($$self), '');
}
@


1.1
log
@Initial revision
@
text
@d5 1
a5 1
    @@INC = '../lib';
d11 1
a11 1
use Test::More tests => 159;
d15 1
a15 1
my $delta = 0.4;
d25 1
a25 1
my $all_pattern =
d27 1
a27 1
my $noc_pattern =
d29 1
a29 1
my $nop_pattern =
d31 11
a41 2
# Please don't trust the matching parenthises to be useful in this :-)
my $default_pattern = qr/$all_pattern|$noc_pattern/;
d54 3
a56 1
print "# Burning CPU to benchmark things will take time...\n";
d59 1
d71 8
a78 2
print "# $in_threesecs iterations\n";
ok ($in_threesecs > 0, "iters returned positive iterations");
d80 1
a80 1
my $estimate = int (100 * $in_threesecs / 3) / 100;
d87 8
a94 2
print "# $in_onesec iterations\n";
ok ($in_onesec > 0, "iters returned positive iterations");
a95 7
{
  my $difference = $in_onesec - $estimate;
  my $actual = abs ($difference / $in_onesec);
  ok ($actual < $delta, "is $in_onesec within $delta of estimate ($estimate)");
  print "# $in_onesec is between " . ($delta / 2) .
    " and $delta of estimate. Not that safe.\n" if $actual > $delta/2;
}
d105 1
a105 1
ok ($in_again > 0, "iters returned positive iterations");
d122 1
a122 1
    like ($all, $all_pattern, 'timestr ($diff, "all")');
d125 1
a125 1
    my ($wallclock, $usr, $sys, $cusr, $csys, $cpu) = $all =~ $all_pattern;
d127 1
a127 1
    is (timestr ($diff, 'none'), '', "none supresses output");
d130 1
a130 1
    like ($noc, qr/$wallclock +wallclock secs? +\( *$usr +usr +\+ +$sys +sys += +$cpu +CPU\)/, 'timestr ($diff, "noc")');
d147 1
a147 1
my $iterations = 3;
d158 1
a158 1
like ($got, $default_pattern, 'default format is all or noc');
d169 1
a169 1
like ($got, $default_pattern, 'default format is all or noc');
d181 1
a181 1
like ($got, $default_pattern, 'default format is all or noc');
d193 1
a193 1
like ($got, $nop_pattern, 'specify format as nop');
d204 2
a205 2
    ok ($foo > 0, "benchmarked code was run");
    ok ($end - $start > 1, "benchmarked code ran for over 1 second");
d238 36
a273 1
like ($got, $default_pattern, 'should find default format somewhere');
d291 2
a292 2
    ok ($foo > 0, "Foo code was run");
    ok ($bar > 0, "Bar code was run");
d294 1
a294 1
    ok (($end - $start) > 0.1, "benchmarked code ran for over 0.1 seconds");
d311 1
d348 3
a350 3
        unless (ok ($slowfast < 0 && $slowfast >= -100,
                    "slowfast should be less than zero, and >= -100")) {
          print STDERR "# slowfast $slowfast\n";
d353 1
a353 2
        unless (ok ($fastslow > 0, "fastslow should be > 0")) {
          print STDERR "# fastslow $fastslow\n";
d360 2
d363 1
a363 1
          &= is ($slowfast, 0, "slowfast should be zero");
d365 1
a365 1
          &= is ($fastslow, 0, "fastslow should be zero");
d386 1
a386 2
      print STDERR "# Something went wrong there. I got this chart:\n";
      print STDERR "# $_\n" foreach split /\n/, $got;
d402 3
a404 1
    my $chart = cmpthese( -0.1, { a => "++\$i", b => "\$i = sqrt(\$i++)" } ) ;
d407 2
a408 1
    ok (($end - $start) > 0.05, "benchmarked code ran for over 0.05 seconds");
d418 25
a442 1
    like ($got, $default_pattern, 'should find default format somewhere');
d450 1
a450 1
    my $chart = cmpthese( 10, $code_to_test, 'nop' ) ;
d452 2
a453 2
    ok ($foo > 0, "Foo code was run");
    ok ($bar > 0, "Bar code was run");
d458 1
a458 1
    like ($got, qr/timing 10 iterations of\s+Bar\W+Foo\W*?\.\.\./s,
d462 1
a462 1
    like ($got, $nop_pattern, 'specify format as nop');
d470 1
a470 1
    my $chart = cmpthese( 10, $code_to_test, 'none' ) ;
d472 2
a473 2
    ok ($foo > 0, "Foo code was run");
    ok ($bar > 0, "Bar code was run");
d487 26
d522 1
a522 1
    ok ($got !~ /\.\.\./s, 'check that there is no title');
d575 1
a575 1
# The way benchmark is written We can't actually check whehter the cache is
d579 1
a579 1
my @@before_keys = keys %Benchmark::cache;
d583 1
a583 1
my @@after5_keys = keys %Benchmark::cache;
d587 1
a587 1
ok (!eq_array ([keys %Benchmark::cache], \@@after5_keys), "10 differs from 5");
d591 1
a591 1
is_deeply ([keys %Benchmark::cache], \@@after5_keys,
d595 1
a595 1
is_deeply ([keys %Benchmark::cache], \@@before_keys,
d597 39
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d5 1
a5 1
    @@INC = ('../lib');
d11 1
a11 1
use Test::More tests => 193;
d25 1
a25 1
my $All_Pattern =
d27 1
a27 1
my $Noc_Pattern =
d29 1
a29 1
my $Nop_Pattern =
d32 1
a32 1
my $Default_Pattern = qr/$All_Pattern|$Noc_Pattern/;
d105 1
a105 1
    like ($all, $All_Pattern, 'timestr ($diff, "all")');
d108 1
a108 1
    my ($wallclock, $usr, $sys, $cusr, $csys, $cpu) = $all =~ $All_Pattern;
d141 1
a141 1
like ($got, $Default_Pattern, 'default format is all or noc');
d152 1
a152 1
like ($got, $Default_Pattern, 'default format is all or noc');
d164 1
a164 1
like ($got, $Default_Pattern, 'default format is all or noc');
d176 1
a176 1
like ($got, $Nop_Pattern, 'specify format as nop');
d221 1
a221 36
like ($got, $Default_Pattern, 'should find default format somewhere');


{ # ensure 'use strict' does not leak from Benchmark.pm into benchmarked code
    no strict;
    select OUT;

    eval {
        timethese( 1, 
                   { undeclared_var => q{ $i++; $i-- },
                     symbolic_ref   => q{ $bar = 42;
                                          $foo = 'bar';
                                          $q = ${$foo} },
                   },
                   'none'
                  );

    };
    is( $@@, '', q{no strict leakage in name => 'code'} );

    eval {
        timethese( 1,
                   { undeclared_var => sub { $i++; $i-- },
                     symbolic_ref   => sub { $bar = 42;
                                             $foo = 'bar';
                                             return ${$foo} },
                   },
                   'none'
                 );
    };
    is( $@@, '', q{no strict leakage in name => sub { code }} );

    # clear out buffer
    $out->read;
}

d295 2
a296 2
        unless (ok ($slowfast <= 0 && $slowfast >= -100,
                    "slowfast should be less than or equal to zero, and >= -100")) {
a307 2
	# In OpenBSD the $slowfast is sometimes a really, really, really
	# small number less than zero, and this gets stringified as -0.
d309 1
a309 1
          &= like ($slowfast, qr/^-?0$/, "slowfast should be zero");
d311 1
a311 1
          &= like ($fastslow, qr/^-?0$/, "fastslow should be zero");
d349 1
a349 1
    my $chart = cmpthese( -0.1, { a => "++\$i", b => "\$i = sqrt(\$i++)" }, "auto" ) ;
d362 1
a362 23
    like ($got, $Default_Pattern, 'should find default format somewhere');
    like ($got, $graph_dissassembly, "Should find the output graph somewhere");
    check_graph_vs_output ($chart, $got);
}

# Not giving auto should suppress timethese results.
{
    select(OUT);
    my $start = times;
    my $chart = cmpthese( -0.1, { a => "++\$i", b => "\$i = sqrt(\$i++)" } ) ;
    my $end = times;
    select(STDOUT);
    ok (($end - $start) > 0.05, "benchmarked code ran for over 0.05 seconds");

    $got = $out->read();
    # Remove any warnings about having too few iterations.
    $got =~ s/\(warning:[^\)]+\)//gs;

    unlike ($got, qr/running\W+a\W+b.*?for at least 0\.1 CPU second/s,
          'should not have title');
    # Remove the title
    $got =~ s/.*\.\.\.//s;
    unlike ($got, $Default_Pattern, 'should not find default format somewhere');
d382 1
a382 1
    like ($got, $Nop_Pattern, 'specify format as nop');
d473 1
a473 1
my @@before_keys = keys %Benchmark::Cache;
d477 1
a477 1
my @@after5_keys = keys %Benchmark::Cache;
d481 1
a481 1
ok (!eq_array ([keys %Benchmark::Cache], \@@after5_keys), "10 differs from 5");
d485 1
a485 1
is_deeply ([keys %Benchmark::Cache], \@@after5_keys,
d489 1
a489 1
is_deeply ([keys %Benchmark::Cache], \@@before_keys,
a490 39


{   # Check usage error messages
    my %usage = %Benchmark::_Usage;
    delete $usage{runloop};  # not public, not worrying about it just now

    my @@takes_no_args = qw(clearallcache disablecache enablecache);

    my %cmpthese = ('forgot {}' => 'cmpthese( 42, foo => sub { 1 } )',
                     'not result' => 'cmpthese(42)',
                     'array ref'  => 'cmpthese( 42, [ foo => sub { 1 } ] )',
                    );
    while( my($name, $code) = each %cmpthese ) {
        eval $code;
        is( $@@, $usage{cmpthese}, "cmpthese usage: $name" );
    }

    my %timethese = ('forgot {}'  => 'timethese( 42, foo => sub { 1 } )',
                       'no code'    => 'timethese(42)',
                       'array ref'  => 'timethese( 42, [ foo => sub { 1 } ] )',
                      );

    while( my($name, $code) = each %timethese ) {
        eval $code;
        is( $@@, $usage{timethese}, "timethese usage: $name" );
    }


    while( my($func, $usage) = each %usage ) {
        next if grep $func eq $_, @@takes_no_args;
        eval "$func()";
        is( $@@, $usage, "$func usage: no args" );
    }

    foreach my $func (@@takes_no_args) {
        eval "$func(42)";
        is( $@@, $usage{$func}, "$func usage: with args" );
    }
}
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d11 1
a11 1
use Test::More tests => 194;
a43 5

# is coderef called with spurious arguments?
timeit( 1, sub { $foo = @@_ });
is ($foo, 0, "benchmarked code called without arguments");

@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d80 3
a82 2
  cmp_ok($actual, '<=', $delta, "is $in_onesec within $delta of estimate ($estimate)")
    or diag("# $in_onesec is between " . ($delta / 2) . " and $delta of estimate. Not that safe.");
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d11 1
a11 1
use Test::More tests => 196;
d31 1
a31 1
# Please don't trust the matching parentheses to be useful in this :-)
d64 1
a64 1
print "# in_threesecs=$in_threesecs iterations\n";
a65 6
my $cpu3 = $threesecs->[1]; # user
my $sys3 = $threesecs->[2]; # sys
cmp_ok($cpu3+$sys3, '>=', 3.0, "3s cpu3 is at least 3s");
my $in_threesecs_adj = $in_threesecs;
$in_threesecs_adj *= (3/$cpu3); # adjust because may not have run for exactly 3s
print "# in_threesecs_adj=$in_threesecs_adj adjusted iterations\n";
d67 1
a67 1
my $estimate = int (100 * $in_threesecs_adj / 3) / 100;
d74 1
a74 1
print "# in_onesec=$in_onesec iterations\n";
a75 6
my $cpu1 = $onesec->[1]; # user
my $sys1 = $onesec->[2]; # sys
cmp_ok($cpu1+$sys1, '>=', 1.0, "is cpu1 is at least 1s");
my $in_onesec_adj = $in_onesec;
$in_onesec_adj *= (1/$cpu1); # adjust because may not have run for exactly 1s
print "# in_onesec_adj=$in_onesec_adj adjusted iterations\n";
d78 4
a81 14
  my $difference = $in_onesec_adj - $estimate;
  my $actual = abs ($difference / $in_onesec_adj);
  cmp_ok($actual, '<=', $delta, "is $in_onesec_adj within $delta of estimate ($estimate)")
    or do {
	diag("  in_threesecs     = $in_threesecs");
	diag("  in_threesecs_adj = $in_threesecs_adj");
	diag("  cpu3             = $cpu3");
	diag("  sys3             = $sys3");
	diag("  estimate         = $estimate");
	diag("  in_onesec        = $in_onesec");
	diag("  in_onesec_adj    = $in_onesec_adj");
	diag("  cpu1             = $cpu1");
	diag("  sys1             = $sys1");
    };
d114 1
a114 1
    is (timestr ($diff, 'none'), '', "none suppresses output");
d117 1
a117 1
    like ($noc, qr/$wallclock +wallclock secs? +\( *$usr +usr +\+ +$sys +sys += +\d+\.\d\d +CPU\)/, 'timestr ($diff, "noc")');
a297 1
    note("calling check_graph_consistency from line " . (caller(1))[2]);
d532 1
a532 1
# The way benchmark is written we can't actually check whether the cache is
@


1.1.1.6
log
@Import perl-5.20.1
@
text
@d11 1
a11 1
use Test::More tests => 195;
d15 1
a15 1
my $DELTA = 0.4;
a33 9
# see if the ratio of two integer values is within (1+$delta)

sub cmp_delta {
    my ($min, $max, $delta) = @@_;
    ($min, $max) = ($max, $min) if $max < $min;
    return 0 if $min < 1; # avoid / 0
    return $max/$min <= (1+$delta);
}

d50 3
a52 1
print "# Burning CPU to benchmark things; will take time...\n";
d89 16
d413 1
a413 3
    my $chart = cmpthese( -0.1, { a => "\$i = sqrt(\$i++) * sqrt(\$i)",
                                  b => "\$i = sqrt(\$i++)",
                                }, "auto" ) ;
d435 1
a435 2
    my $chart = cmpthese( -0.1, { a => "\$i = sqrt(\$i++) * sqrt(\$i)",
                                  b => "\$i = sqrt(\$i++)" });
@


1.1.1.7
log
@Import perl-5.24.2
@
text
@d11 1
a11 1
use Test::More tests => 213;
d72 1
a72 1
cmp_ok($in_threesecs, '>', 0, "iters returned positive iterations");
d88 1
a88 1
cmp_ok($in_onesec, '>',  0, "iters returned positive iterations");
d105 1
a105 1
cmp_ok($in_again, '>', 0, "iters returned positive iterations");
d147 1
a147 1
my $iterations = 100;
d204 2
a205 2
    cmp_ok($foo, '>', 0, "benchmarked code was run");
    cmp_ok($end - $start, '>', 1, "benchmarked code ran for over 1 second");
d291 2
a292 2
    cmp_ok($foo, '>', 0, "Foo code was run");
    cmp_ok($bar, '>', 0, "Bar code was run");
d294 1
a294 1
    cmp_ok($end-$start, '>', 0.1, "benchmarked code ran for over 0.1 seconds");
d350 1
a350 1
          diag("slowfast=$slowfast");
d353 2
a354 1
        unless (cmp_ok($fastslow, '>', 0, "fastslow should be > 0")) {
d387 2
a388 1
      diag("Something went wrong there. I got this chart:\n$got");
d404 1
a404 1
    my $chart = cmpthese( -0.1, { a => "\$i = sqrt(\$i++) * sqrt(\$i) for 1..10",
d409 1
a409 2
    cmp_ok($end - $start, '>', 0.05,
                            "benchmarked code ran for over 0.05 seconds");
d428 1
a428 1
    my $chart = cmpthese( -0.1, { a => "\$i = sqrt(\$i++) * sqrt(\$i) for 1..10",
d432 1
a432 2
    cmp_ok($end - $start, '>', 0.05,
            "benchmarked code ran for over 0.05 seconds");
d450 1
a450 1
    my $chart = cmpthese($iterations, $code_to_test, 'nop' ) ;
d452 2
a453 2
    cmp_ok($foo, '>', 0, "Foo code was run");
    cmp_ok($bar, '>', 0, "Bar code was run");
d458 1
a458 1
    like ($got, qr/timing $iterations iterations of\s+Bar\W+Foo\W*?\.\.\./s,
d470 1
a470 1
    my $chart = cmpthese($iterations, $code_to_test, 'none' ) ;
d472 2
a473 2
    cmp_ok($foo, '>', 0, "Foo code was run");
    cmp_ok($bar, '>', 0, "Bar code was run");
a486 26
# this is a repeat of the above test, but with the timing and charting
# steps split.

{
    $foo = $bar = 0;
    select(OUT);
    my $res = timethese($iterations, $code_to_test, 'none' ) ;
    my $chart = cmpthese($res, 'none' ) ;
    select(STDOUT);
    cmp_ok($foo, '>', 0, "Foo code was run");
    cmp_ok($bar, '>', 0, "Bar code was run");

    $got = $out->read();
    # Remove any warnings about having too few iterations.
    $got =~ s/\(warning:[^\)]+\)//gs;
    $got =~ s/^[ \t\n]+//s; # Remove all the whitespace from the beginning
    is ($got, '', "format 'none' should suppress output");
    is (ref $chart, 'ARRAY', "output should be an array ref");
    # Some of these will go bang if the preceding test fails. There will be
    # a big clue as to why, from the previous test's diagnostic
    is (ref $chart->[0], 'ARRAY', "output should be an array of arrays");
    use Data::Dumper;
    check_graph(@@$chart)
        or diag(Data::Dumper->Dump([$res, $chart], ['$res', '$chart']));
}

d496 1
a496 1
    unlike($got, qr/\.\.\./s, 'check that there is no title');
@


