head	1.9;
access;
symbols
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.6.0.20
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.18
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.16
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.14
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.12
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.9
date	2010.09.24.14.59.35;	author millert;	state dead;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.39;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.10;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.36;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.22;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.49;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.57.19;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.40;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.25;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.46.47;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.17.14;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.32;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.57;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@# -*- Mode: cperl; coding: utf-8; cperl-indent-level: 4 -*-
package CPAN::Mirrored::By;
use strict;

sub new {
    my($self,@@arg) = @@_;
    bless [@@arg], $self;
}
sub continent { shift->[0] }
sub country { shift->[1] }
sub url { shift->[2] }

package CPAN::FirstTime;
use strict;

use ExtUtils::MakeMaker ();
use FileHandle ();
use File::Basename ();
use File::Path ();
use File::Spec ();
use vars qw($VERSION $urllist);
$VERSION = "5.53";

=head1 NAME

CPAN::FirstTime - Utility for CPAN::Config file Initialization

=head1 SYNOPSIS

CPAN::FirstTime::init()

=head1 DESCRIPTION

The init routine asks a few questions and writes a CPAN/Config.pm or
CPAN/MyConfig.pm file (depending on what it is currently using).

In the following all questions and explanations regarding config
variables are collected.

=cut

# down until the next =back the manpage must be parsed by the program
# because the text is used in the init dialogues.

my @@podpara = split /\n\n/, <<'=back';

=over 2

=item auto_commit

Normally CPAN.pm keeps config variables in memory and changes need to
be saved in a separate 'o conf commit' command to make them permanent
between sessions. If you set the 'auto_commit' option to true, changes
to a config variable are always automatically committed to disk.

Always commit changes to config variables to disk?

=item build_cache

CPAN.pm can limit the size of the disk area for keeping the build
directories with all the intermediate files.

Cache size for build directory (in MB)?

=item build_dir

Directory where the build process takes place?

=item build_dir_reuse

Until version 1.88 CPAN.pm never trusted the contents of the build_dir
directory between sessions. Since 1.88_58 CPAN.pm has a YAML-based
mechanism that makes it possible to share the contents of the
build_dir/ directory between different sessions with the same version
of perl. People who prefer to test things several days before
installing will like this feature because it safes a lot of time.

If you say yes to the following question, CPAN will try to store
enough information about the build process so that it can pick up in
future sessions at the same state of affairs as it left a previous
session.

Store and re-use state information about distributions between
CPAN.pm sessions?

=item build_requires_install_policy

When a module declares another one as a 'build_requires' prerequisite
this means that the other module is only needed for building or
testing the module but need not be installed permanently. In this case
you may wish to install that other module nonetheless or just keep it
in the 'build_dir' directory to have it available only temporarily.
Installing saves time on future installations but makes the perl
installation bigger.

You can choose if you want to always install (yes), never install (no)
or be always asked. In the latter case you can set the default answer
for the question to yes (ask/yes) or no (ask/no).

Policy on installing 'build_requires' modules (yes, no, ask/yes,
ask/no)?

=item cache_metadata

To considerably speed up the initial CPAN shell startup, it is
possible to use Storable to create a cache of metadata. If Storable is
not available, the normal index mechanism will be used.

Note: this mechanism is not used when use_sqlite is on and SQLLite is
running.

Cache metadata (yes/no)?

=item check_sigs

CPAN packages can be digitally signed by authors and thus verified
with the security provided by strong cryptography. The exact mechanism
is defined in the Module::Signature module. While this is generally
considered a good thing, it is not always convenient to the end user
to install modules that are signed incorrectly or where the key of the
author is not available or where some prerequisite for
Module::Signature has a bug and so on.

With the check_sigs parameter you can turn signature checking on and
off. The default is off for now because the whole tool chain for the
functionality is not yet considered mature by some. The author of
CPAN.pm would recommend setting it to true most of the time and
turning it off only if it turns out to be annoying.

Note that if you do not have Module::Signature installed, no signature
checks will be performed at all.

Always try to check and verify signatures if a SIGNATURE file is in
the package and Module::Signature is installed (yes/no)?

=item colorize_output

When you have Term::ANSIColor installed, you can turn on colorized
output to have some visual differences between normal CPAN.pm output,
warnings, debugging output, and the output of the modules being
installed. Set your favorite colors after some experimenting with the
Term::ANSIColor module.

Do you want to turn on colored output?

=item colorize_print

Color for normal output?

=item colorize_warn

Color for warnings?

=item colorize_debug

Color for debugging messages?

=item commandnumber_in_prompt

The prompt of the cpan shell can contain the current command number
for easier tracking of the session or be a plain string.

Do you want the command number in the prompt (yes/no)?

=item connect_to_internet_ok

If you have never defined your own C<urllist> in your configuration
then C<CPAN.pm> will be hesitant to use the built in default sites for
downloading. It will ask you once per session if a connection to the
internet is OK and only if you say yes, it will try to connect. But to
avoid this question, you can choose your favorite download sites once
and get away with it. Or, if you have no favorite download sites
answer yes to the following question.

If no urllist has been chosen yet, would you prefer CPAN.pm to connect
to the built-in default sites without asking? (yes/no)?

=item ftp_passive

Shall we always set the FTP_PASSIVE environment variable when dealing
with ftp download (yes/no)?

=item ftpstats_period

Statistics about downloads are truncated by size and period
simultaneously.

How many days shall we keep statistics about downloads?

=item ftpstats_size

Statistics about downloads are truncated by size and period
simultaneously.

How many items shall we keep in the statistics about downloads?

=item getcwd

CPAN.pm changes the current working directory often and needs to
determine its own current working directory. Per default it uses
Cwd::cwd but if this doesn't work on your system for some reason,
alternatives can be configured according to the following table:

    cwd         Cwd::cwd
    getcwd      Cwd::getcwd
    fastcwd     Cwd::fastcwd
    backtickcwd external command cwd

Preferred method for determining the current working directory?

=item halt_on_failure

Normaly, CPAN.pm continues processing the full list of targets and
dependencies, even if one of them fails.  However, you can specify 
that CPAN should halt after the first failure. 

Do you want to halt on failure (yes/no)?

=item histfile

If you have one of the readline packages (Term::ReadLine::Perl,
Term::ReadLine::Gnu, possibly others) installed, the interactive CPAN
shell will have history support. The next two questions deal with the
filename of the history file and with its size. If you do not want to
set this variable, please hit SPACE RETURN to the following question.

File to save your history?

=item histsize

Number of lines to save?

=item inactivity_timeout

Sometimes you may wish to leave the processes run by CPAN alone
without caring about them. Because the Makefile.PL or the Build.PL
sometimes contains question you're expected to answer, you can set a
timer that will kill a 'perl Makefile.PL' process after the specified
time in seconds.

If you set this value to 0, these processes will wait forever. This is
the default and recommended setting.

Timeout for inactivity during {Makefile,Build}.PL?

=item index_expire

The CPAN indexes are usually rebuilt once or twice per hour, but the
typical CPAN mirror mirrors only once or twice per day. Depending on
the quality of your mirror and your desire to be on the bleeding edge,
you may want to set the following value to more or less than one day
(which is the default). It determines after how many days CPAN.pm
downloads new indexes.

Let the index expire after how many days?

=item inhibit_startup_message

When the CPAN shell is started it normally displays a greeting message
that contains the running version and the status of readline support.

Do you want to turn this message off?

=item keep_source_where

Unless you are accessing the CPAN on your filesystem via a file: URL,
CPAN.pm needs to keep the source files it downloads somewhere. Please
supply a directory where the downloaded files are to be kept.

Download target directory?

=item load_module_verbosity

When CPAN.pm loads a module it needs for some optional feature, it
usually reports about module name and version. Choose 'v' to get this
message, 'none' to suppress it.

Verbosity level for loading modules (none or v)?

=item makepl_arg

Every Makefile.PL is run by perl in a separate process. Likewise we
run 'make' and 'make install' in separate processes. If you have
any parameters (e.g. PREFIX, UNINST or the like) you want to
pass to the calls, please specify them here.

If you don't understand this question, just press ENTER.

Typical frequently used settings:

    PREFIX=~/perl    # non-root users (please see manual for more hints)

Parameters for the 'perl Makefile.PL' command?

=item make_arg

Parameters for the 'make' command? Typical frequently used setting:

    -j3              # dual processor system (on GNU make)

Your choice:

=item make_install_arg

Parameters for the 'make install' command?
Typical frequently used setting:

    UNINST=1         # to always uninstall potentially conflicting files

Your choice:

=item make_install_make_command

Do you want to use a different make command for 'make install'?
Cautious people will probably prefer:

    su root -c make
 or
    sudo make
 or
    /path1/to/sudo -u admin_account /path2/to/make

or some such. Your choice:

=item mbuildpl_arg

A Build.PL is run by perl in a separate process. Likewise we run
'./Build' and './Build install' in separate processes. If you have any
parameters you want to pass to the calls, please specify them here.

Typical frequently used settings:

    --install_base /home/xxx             # different installation directory

Parameters for the 'perl Build.PL' command?

=item mbuild_arg

Parameters for the './Build' command? Setting might be:

    --extra_linker_flags -L/usr/foo/lib  # non-standard library location

Your choice:

=item mbuild_install_arg

Parameters for the './Build install' command? Typical frequently used
setting:

    --uninst 1                           # uninstall conflicting files

Your choice:

=item mbuild_install_build_command

Do you want to use a different command for './Build install'? Sudo
users will probably prefer:

    su root -c ./Build
 or
    sudo ./Build
 or
    /path1/to/sudo -u admin_account ./Build

or some such. Your choice:

=item pager

What is your favorite pager program?

=item prefer_installer

When you have Module::Build installed and a module comes with both a
Makefile.PL and a Build.PL, which shall have precedence?

The main two standard installer modules are the old and well
established ExtUtils::MakeMaker (for short: EUMM) which uses the
Makefile.PL. And the next generation installer Module::Build (MB)
which works with the Build.PL (and often comes with a Makefile.PL
too). If a module comes only with one of the two we will use that one
but if both are supplied then a decision must be made between EUMM and
MB. See also http://rt.cpan.org/Ticket/Display.html?id=29235 for a
discussion about the right default.

Or, as a third option you can choose RAND which will make a random
decision (something regular CPAN testers will enjoy).

In case you can choose between running a Makefile.PL or a Build.PL,
which installer would you prefer (EUMM or MB or RAND)?

=item prefs_dir

CPAN.pm can store customized build environments based on regular
expressions for distribution names. These are YAML files where the
default options for CPAN.pm and the environment can be overridden and
dialog sequences can be stored that can later be executed by an
Expect.pm object. The CPAN.pm distribution comes with some prefab YAML
files that cover sample distributions that can be used as blueprints
to store one own prefs. Please check out the distroprefs/ directory of
the CPAN.pm distribution to get a quick start into the prefs system.

Directory where to store default options/environment/dialogs for
building modules that need some customization?

=item prerequisites_policy

The CPAN module can detect when a module which you are trying to build
depends on prerequisites. If this happens, it can build the
prerequisites for you automatically ('follow'), ask you for
confirmation ('ask'), or just ignore them ('ignore'). Please set your
policy to one of the three values.

Policy on building prerequisites (follow, ask or ignore)?

=item randomize_urllist

CPAN.pm can introduce some randomness when using hosts for download
that are configured in the urllist parameter. Enter a numeric value
between 0 and 1 to indicate how often you want to let CPAN.pm try a
random host from the urllist. A value of one specifies to always use a
random host as the first try. A value of zero means no randomness at
all. Anything in between specifies how often, on average, a random
host should be tried first.

Randomize parameter

=item scan_cache

By default, each time the CPAN module is started, cache scanning is
performed to keep the cache size in sync. To prevent this, answer
'never'.

Perform cache scanning (atstart or never)?

=item shell

What is your favorite shell?

=item show_unparsable_versions

During the 'r' command CPAN.pm finds modules without version number.
When the command finishes, it prints a report about this. If you
want this report to be very verbose, say yes to the following
variable.

Show all individual modules that have no $VERSION?

=item show_upload_date

The 'd' and the 'm' command normally only show you information they
have in their in-memory database and thus will never connect to the
internet. If you set the 'show_upload_date' variable to true, 'm' and
'd' will additionally show you the upload date of the module or
distribution. Per default this feature is off because it may require a
net connection to get at the upload date.

Always try to show upload date with 'd' and 'm' command (yes/no)?

=item show_zero_versions

During the 'r' command CPAN.pm finds modules with a version number of
zero. When the command finishes, it prints a report about this. If you
want this report to be very verbose, say yes to the following
variable.

Show all individual modules that have a $VERSION of zero?

=item tar_verbosity

When CPAN.pm uses the tar command, which switch for the verbosity
shall be used? Choose 'none' for quiet operation, 'v' for file
name listing, 'vv' for full listing.

Tar command verbosity level (none or v or vv)?

=item term_is_latin

The next option deals with the charset (aka character set) your
terminal supports. In general, CPAN is English speaking territory, so
the charset does not matter much but some CPAN have names that are
outside the ASCII range. If your terminal supports UTF-8, you should
say no to the next question. If it expects ISO-8859-1 (also known as
LATIN1) then you should say yes. If it supports neither, your answer
does not matter because you will not be able to read the names of some
authors anyway. If you answer no, names will be output in UTF-8.

Your terminal expects ISO-8859-1 (yes/no)?

=item term_ornaments

When using Term::ReadLine, you can turn ornaments on so that your
input stands out against the output from CPAN.pm.

Do you want to turn ornaments on?

=item test_report

The goal of the CPAN Testers project (http://testers.cpan.org/) is to
test as many CPAN packages as possible on as many platforms as
possible.  This provides valuable feedback to module authors and
potential users to identify bugs or platform compatibility issues and
improves the overall quality and value of CPAN.

One way you can contribute is to send test results for each module
that you install.  If you install the CPAN::Reporter module, you have
the option to automatically generate and email test reports to CPAN
Testers whenever you run tests on a CPAN package.

See the CPAN::Reporter documentation for additional details and
configuration settings.  If your firewall blocks outgoing email,
you will need to configure CPAN::Reporter before sending reports.

Email test reports if CPAN::Reporter is installed (yes/no)?

=item perl5lib_verbosity

When CPAN.pm extends @@INC via PERL5LIB, it prints a list of
directories added (or a summary of how many directories are
added).  Choose 'v' to get this message, 'none' to suppress it.

Verbosity level for PERL5LIB changes (none or v)?

=item trust_test_report_history

When a distribution has already been tested by CPAN::Reporter on
this machine, CPAN can skip the test phase and just rely on the
test report history instead.

Note that this will not apply to distributions that failed tests
because of missing dependencies.  Also, tests can be run
regardless of the history using "force".

Do you want to rely on the test report history (yes/no)?

=item use_sqlite

CPAN::SQLite is a layer between the index files that are downloaded
from the CPAN and CPAN.pm that speeds up metadata queries and reduces
memory consumption of CPAN.pm considerably.

Use CPAN::SQLite if available? (yes/no)?

=item yaml_load_code

Both YAML.pm and YAML::Syck are capable of deserialising code. As this
requires a string eval, which might be a security risk, you can use
this option to enable or disable the deserialisation of code via
CPAN::DeferredCode. (Note: This does not work under perl 5.6)

Do you want to enable code deserialisation (yes/no)?

=item yaml_module

At the time of this writing (2009-03) there are three YAML
implementations working: YAML, YAML::Syck, and YAML::XS. The latter
two are faster but need a C compiler installed on your system. There
may be more alternative YAML conforming modules. When I tried two
other players, YAML::Tiny and YAML::Perl, they seemed not powerful
enough to work with CPAN.pm. This may have changed in the meantime.

Which YAML implementation would you prefer?

=back

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

use vars qw( %prompts );

{

    my @@prompts = (

manual_config => qq[

CPAN is the world-wide archive of perl resources. It consists of about
300 sites that all replicate the same contents around the globe. Many
countries have at least one CPAN site already. The resources found on
CPAN are easily accessible with the CPAN.pm module. If you want to use
CPAN.pm, lots of things have to be configured. Fortunately, most of
them can be determined automatically. If you prefer the automatic
configuration, answer 'yes' below.

If you prefer to enter a dialog instead, you can answer 'no' to this
question and I'll let you configure in small steps one thing after the
other. (Note: you can revisit this dialog anytime later by typing 'o
conf init' at the cpan prompt.)
],

config_intro => qq{

The following questions are intended to help you with the
configuration. The CPAN module needs a directory of its own to cache
important index files and maybe keep a temporary mirror of CPAN files.
This may be a site-wide or a personal directory.

},

# cpan_home => qq{ },

cpan_home_where => qq{

First of all, I'd like to create this directory. Where?

},

external_progs => qq{

The CPAN module will need a few external programs to work properly.
Please correct me, if I guess the wrong path for a program. Don't
panic if you do not have some of them, just press ENTER for those. To
disable the use of a program, you can type a space followed by ENTER.

},

proxy_intro => qq{

If you're accessing the net via proxies, you can specify them in the
CPAN configuration or via environment variables. The variable in
the \$CPAN::Config takes precedence.

},

proxy_user => qq{

If your proxy is an authenticating proxy, you can store your username
permanently. If you do not want that, just press RETURN. You will then
be asked for your username in every future session.

},

proxy_pass => qq{

Your password for the authenticating proxy can also be stored
permanently on disk. If this violates your security policy, just press
RETURN. You will then be asked for the password in every future
session.

},

urls_intro => qq{

Now we need to know where your favorite CPAN sites are located. Push
a few sites onto the array (just in case the first on the array won\'t
work). If you are mirroring CPAN to your local workstation, specify a
file: URL.

First, pick a nearby continent and country by typing in the number(s)
in front of the item(s) you want to select. You can pick several of
each, separated by spaces. Then, you will be presented with a list of
URLs of CPAN mirrors in the countries you selected, along with
previously selected URLs. Select some of those URLs, or just keep the
old list. Finally, you will be prompted for any extra URLs -- file:,
ftp:, or http: -- that host a CPAN mirror.

},

password_warn => qq{

Warning: Term::ReadKey seems not to be available, your password will
be echoed to the terminal!

},

              );

    die "Coding error in \@@prompts declaration.  Odd number of elements, above"
        if (@@prompts % 2);

    %prompts = @@prompts;

    if (scalar(keys %prompts) != scalar(@@prompts)/2) {
        my %already;
        for my $item (0..$#prompts) {
            next if $item % 2;
            die "$prompts[$item] is duplicated\n" if $already{$prompts[$item]}++;
        }
    }

    shift @@podpara;
    while (@@podpara) {
        warn "Alert: cannot parse my own manpage for init dialog" unless $podpara[0] =~ s/^=item\s+//;
        my $name = shift @@podpara;
        my @@para;
        while (@@podpara && $podpara[0] !~ /^=item/) {
            push @@para, shift @@podpara;
        }
        $prompts{$name} = pop @@para;
        if (@@para) {
            $prompts{$name . "_intro"} = join "", map { "$_\n\n" } @@para;
        }
    }

}

sub init {
    my($configpm, %args) = @@_;
    use Config;
    # extra args after 'o conf init'
    my $matcher = $args{args} && @@{$args{args}} ? $args{args}[0] : '';
    if ($matcher =~ /^\/(.*)\/$/) {
        # case /regex/ => take the first, ignore the rest
        $matcher = $1;
        shift @@{$args{args}};
        if (@@{$args{args}}) {
            local $" = " ";
            $CPAN::Frontend->mywarn("Ignoring excessive arguments '@@{$args{args}}'");
            $CPAN::Frontend->mysleep(2);
        }
    } elsif (0 == length $matcher) {
    } elsif (0 && $matcher eq "~") { # extremely buggy, but a nice idea
        my @@unconfigured = grep { not exists $CPAN::Config->{$_}
                                      or not defined $CPAN::Config->{$_}
                                          or not length $CPAN::Config->{$_}
                                  } keys %$CPAN::Config;
        $matcher = "\\b(".join("|", @@unconfigured).")\\b";
        $CPAN::Frontend->mywarn("matcher[$matcher]");
    } else {
        # case WORD... => all arguments must be valid
        for my $arg (@@{$args{args}}) {
            unless (exists $CPAN::HandleConfig::keys{$arg}) {
                $CPAN::Frontend->mywarn("'$arg' is not a valid configuration variable\n");
                return;
            }
        }
        $matcher = "\\b(".join("|",@@{$args{args}}).")\\b";
    }
    CPAN->debug("matcher[$matcher]") if $CPAN::DEBUG;

    unless ($CPAN::VERSION) {
        require CPAN::Nox;
    }
    require CPAN::HandleConfig;
    CPAN::HandleConfig::require_myconfig_or_config();
    $CPAN::Config ||= {};
    local($/) = "\n";
    local($\) = "";
    local($|) = 1;

    my($ans,$default); # why so half global?

    #
    #= Files, directories
    #

    unless ($matcher) {
        $CPAN::Frontend->myprint($prompts{manual_config});
    }

    my $manual_conf;

    local *_real_prompt;
    if ( $args{autoconfig} ) {
        $manual_conf = "no";
    } elsif ($matcher) {
        $manual_conf = "yes";
    } else {
        my $_conf = prompt("Would you like me to configure as much as possible ".
                           "automatically?", "yes");
        $manual_conf = ($_conf and $_conf =~ /^y/i) ? "no" : "yes";
    }
    CPAN->debug("manual_conf[$manual_conf]") if $CPAN::DEBUG;
    my $fastread;
    {
        if ($manual_conf =~ /^y/i) {
            $fastread = 0;
        } else {
            $fastread = 1;
            $CPAN::Config->{urllist} ||= [];
            $CPAN::Config->{connect_to_internet_ok} ||= 1;

            local $^W = 0;
            # prototype should match that of &MakeMaker::prompt
            my $current_second = time;
            my $current_second_count = 0;
            my $i_am_mad = 0;
            *_real_prompt = sub {
                my($q,$a) = @@_;
                my($ret) = defined $a ? $a : "";
                $CPAN::Frontend->myprint(sprintf qq{%s [%s]\n\n}, $q, $ret);
                eval { require Time::HiRes };
                unless ($@@) {
                    if (time == $current_second) {
                        $current_second_count++;
                        if ($current_second_count > 20) {
                            # I don't like more than 20 prompts per second
                            $i_am_mad++;
                        }
                    } else {
                        $current_second = time;
                        $current_second_count = 0;
                        $i_am_mad-- if $i_am_mad>0;
                    }
                    if ($i_am_mad>0) {
                        #require Carp;
                        #Carp::cluck("SLEEEEEEEEPIIIIIIIIIIINGGGGGGGGGGG");
                        Time::HiRes::sleep(0.1);
                    }
                }
                $ret;
            };
        }
    }

    if (!$matcher or q{
                       build_dir
                       build_dir_reuse
                       cpan_home
                       keep_source_where
                       prefs_dir
                      } =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{config_intro});

        init_cpan_home($matcher);

        my_dflt_prompt("keep_source_where",
                       File::Spec->catdir($CPAN::Config->{cpan_home},"sources"),
                       $matcher,
                      );
        my_dflt_prompt("build_dir",
                       File::Spec->catdir($CPAN::Config->{cpan_home},"build"),
                       $matcher
                      );
        my_yn_prompt(build_dir_reuse => 0, $matcher);
        my_dflt_prompt("prefs_dir",
                       File::Spec->catdir($CPAN::Config->{cpan_home},"prefs"),
                       $matcher
                      );
    }

    #
    #= Config: auto_commit
    #

    my_yn_prompt(auto_commit => 0, $matcher);

    #
    #= Cache size, Index expire
    #
    my_dflt_prompt(build_cache => 100, $matcher);

    my_dflt_prompt(index_expire => 1, $matcher);
    my_prompt_loop(scan_cache => 'atstart', $matcher, 'atstart|never');

    #
    #= cache_metadata
    #

    my_yn_prompt(cache_metadata => 1, $matcher);
    my_yn_prompt(use_sqlite => 0, $matcher);

    #
    #= Do we follow PREREQ_PM?
    #

    my_prompt_loop(prerequisites_policy => 'ask', $matcher,
                   'follow|ask|ignore');
    my_prompt_loop(build_requires_install_policy => 'ask/yes', $matcher,
                   'yes|no|ask/yes|ask/no');

    #
    #= Module::Signature
    #
    my_yn_prompt(check_sigs => 0, $matcher);

    #
    #= CPAN::Reporter
    #
    if (!$matcher or 'test_report' =~ /$matcher/) {
        my_yn_prompt(test_report => 0, $matcher);
        if (
            $CPAN::Config->{test_report} &&
            $CPAN::META->has_inst("CPAN::Reporter") &&
            CPAN::Reporter->can('configure')
           ) {
            $CPAN::Frontend->myprint("\nProceeding to configure CPAN::Reporter.\n");
            CPAN::Reporter::configure();
            $CPAN::Frontend->myprint("\nReturning to CPAN configuration.\n");
        }
    }

    my_yn_prompt(trust_test_report_history => 0, $matcher);

    #
    #= YAML vs. YAML::Syck
    #
    if (!$matcher or "yaml_module" =~ /$matcher/) {
        my_dflt_prompt(yaml_module => "YAML", $matcher);
        unless ($CPAN::META->has_inst($CPAN::Config->{yaml_module})) {
            $CPAN::Frontend->mywarn
                ("Warning (maybe harmless): '$CPAN::Config->{yaml_module}' not installed.\n");
            $CPAN::Frontend->mysleep(3);
        }
    }

    #
    #= YAML code deserialisation
    #
    my_yn_prompt(yaml_load_code => 0, $matcher);

    #
    #= External programs
    #
    my(@@path) = split /$Config{'path_sep'}/, $ENV{'PATH'};
    _init_external_progs($matcher,\@@path);

    {
        my $path = $CPAN::Config->{'pager'} ||
            $ENV{PAGER} || find_exe("less",\@@path) ||
                find_exe("more",\@@path) || ($^O eq 'MacOS' ? $ENV{EDITOR} : 0 )
                    || "more";
        my_dflt_prompt(pager => $path, $matcher);
    }

    {
        my $path = $CPAN::Config->{'shell'};
        if ($path && File::Spec->file_name_is_absolute($path)) {
            $CPAN::Frontend->mywarn("Warning: configured $path does not exist\n")
                unless -e $path;
            $path = "";
        }
        $path ||= $ENV{SHELL};
        $path ||= $ENV{COMSPEC} if $^O eq "MSWin32";
        if ($^O eq 'MacOS') {
            $CPAN::Config->{'shell'} = 'not_here';
        } else {
            $path =~ s,\\,/,g if $^O eq 'os2'; # Cosmetic only
            my_dflt_prompt(shell => $path, $matcher);
        }
    }

    #
    # verbosity
    #

    my_prompt_loop(tar_verbosity => 'v', $matcher,
                   'none|v|vv');
    my_prompt_loop(load_module_verbosity => 'v', $matcher,
                   'none|v');
    my_prompt_loop(perl5lib_verbosity => 'v', $matcher,
                   'none|v');
    my_yn_prompt(inhibit_startup_message => 0, $matcher);

    #
    #= Installer, arguments to make etc.
    #

    my_prompt_loop(prefer_installer => 'MB', $matcher, 'MB|EUMM|RAND');

    if (!$matcher or 'makepl_arg make_arg' =~ /$matcher/) {
        my_dflt_prompt(makepl_arg => "", $matcher);
        my_dflt_prompt(make_arg => "", $matcher);
        if ( $CPAN::Config->{makepl_arg} =~ /LIBS=|INC=/ ) {
            $CPAN::Frontend->mywarn( 
                "Warning: Using LIBS or INC in makepl_arg will likely break distributions\n" . 
                "that specify their own LIBS or INC options in Makefile.PL.\n"
            );
        }

    }

    require CPAN::HandleConfig;
    if (exists $CPAN::HandleConfig::keys{make_install_make_command}) {
        # as long as Windows needs $self->_build_command, we cannot
        # support sudo on windows :-)
        my_dflt_prompt(make_install_make_command => $CPAN::Config->{make} || "",
                       $matcher);
    }

    my_dflt_prompt(make_install_arg => $CPAN::Config->{make_arg} || "",
                   $matcher);

    my_dflt_prompt(mbuildpl_arg => "", $matcher);
    my_dflt_prompt(mbuild_arg => "", $matcher);

    if (exists $CPAN::HandleConfig::keys{mbuild_install_build_command}
        and $^O ne "MSWin32") {
        # as long as Windows needs $self->_build_command, we cannot
        # support sudo on windows :-)
        my_dflt_prompt(mbuild_install_build_command => "./Build", $matcher);
    }

    my_dflt_prompt(mbuild_install_arg => "", $matcher);

    #
    #= Alarm period
    #

    my_dflt_prompt(inactivity_timeout => 0, $matcher);

    #
    #== halt_on_failure
    #
    my_yn_prompt(halt_on_failure => 0, $matcher);

    #
    #= Proxies
    #

    my @@proxy_vars = qw/ftp_proxy http_proxy no_proxy/;
    my @@proxy_user_vars = qw/proxy_user proxy_pass/;
    if (!$matcher or "@@proxy_vars @@proxy_user_vars" =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{proxy_intro});

        for (@@proxy_vars) {
            $prompts{$_} = "Your $_?";
            my_dflt_prompt($_ => $ENV{$_}||"", $matcher);
        }

        if ($CPAN::Config->{ftp_proxy} ||
            $CPAN::Config->{http_proxy}) {

            $default = $CPAN::Config->{proxy_user} || $CPAN::LWP::UserAgent::USER || "";

            $CPAN::Frontend->myprint($prompts{proxy_user});

            if ($CPAN::Config->{proxy_user} = prompt("Your proxy user id?",$default)) {
                $CPAN::Frontend->myprint($prompts{proxy_pass});

                if ($CPAN::META->has_inst("Term::ReadKey")) {
                    Term::ReadKey::ReadMode("noecho");
                } else {
                    $CPAN::Frontend->myprint($prompts{password_warn});
                }
                $CPAN::Config->{proxy_pass} = prompt_no_strip("Your proxy password?");
                if ($CPAN::META->has_inst("Term::ReadKey")) {
                    Term::ReadKey::ReadMode("restore");
                }
                $CPAN::Frontend->myprint("\n\n");
            }
        }
    }

    #
    #= how FTP works
    #

    my_yn_prompt(ftp_passive => 1, $matcher);

    #
    #= how cwd works
    #

    my_prompt_loop(getcwd => 'cwd', $matcher,
                   'cwd|getcwd|fastcwd|backtickcwd');

    #
    #= the CPAN shell itself (prompt, color)
    #

    my_yn_prompt(commandnumber_in_prompt => 1, $matcher);
    my_yn_prompt(term_ornaments => 1, $matcher);
    if ("colorize_output colorize_print colorize_warn colorize_debug" =~ $matcher) {
        my_yn_prompt(colorize_output => 0, $matcher);
        if ($CPAN::Config->{colorize_output}) {
            if ($CPAN::META->has_inst("Term::ANSIColor")) {
                my $T="gYw";
                print "                                      on_  on_y ".
                    "        on_ma           on_\n";
                print "                   on_black on_red  green ellow ".
                    "on_blue genta on_cyan white\n";

                for my $FG ("", "bold",
                            map {$_,"bold $_"} "black","red","green",
                            "yellow","blue",
                            "magenta",
                            "cyan","white") {
                    printf "%12s ", $FG;
                    for my $BG ("",map {"on_$_"} qw(black red green yellow
                                                    blue magenta cyan white)) {
                        print $FG||$BG ?
                            Term::ANSIColor::colored("  $T  ","$FG $BG") : "  $T  ";
                    }
                    print "\n";
                }
                print "\n";
            }
            for my $tuple (
                           ["colorize_print", "bold blue on_white"],
                           ["colorize_warn", "bold red on_white"],
                           ["colorize_debug", "black on_cyan"],
                          ) {
                my_dflt_prompt($tuple->[0] => $tuple->[1], $matcher);
                if ($CPAN::META->has_inst("Term::ANSIColor")) {
                    eval { Term::ANSIColor::color($CPAN::Config->{$tuple->[0]})};
                    if ($@@) {
                        $CPAN::Config->{$tuple->[0]} = $tuple->[1];
                        $CPAN::Frontend->mywarn($@@."setting to default '$tuple->[1]'\n");
                    }
                }
            }
        }
    }

    #
    #== term_is_latin
    #

    my_yn_prompt(term_is_latin => 1, $matcher);

    #
    #== save history in file 'histfile'
    #

    if (!$matcher or 'histfile histsize' =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{histfile_intro});
        defined($default = $CPAN::Config->{histfile}) or
            $default = File::Spec->catfile($CPAN::Config->{cpan_home},"histfile");
        my_dflt_prompt(histfile => $default, $matcher);

        if ($CPAN::Config->{histfile}) {
            defined($default = $CPAN::Config->{histsize}) or $default = 100;
            my_dflt_prompt(histsize => $default, $matcher);
        }
    }

    #
    #== do an ls on the m or the d command
    #
    my_yn_prompt(show_upload_date => 0, $matcher);

    #
    #== verbosity at the end of the r command
    #
    if (!$matcher
        or 'show_unparsable_versions' =~ /$matcher/
        or 'show_zero_versions' =~ /$matcher/
       ) {
        $CPAN::Frontend->myprint($prompts{show_unparsable_or_zero_versions_intro});
        my_yn_prompt(show_unparsable_versions => 0, $matcher);
        my_yn_prompt(show_zero_versions => 0, $matcher);
    }

    #
    #= MIRRORED.BY and conf_sites()
    #

    # remember, this is only triggered if no urllist is given, so 0 is
    # fair and protects the default site from being overloaded and
    # gives the user more chances to select his own urllist.
    my_yn_prompt("connect_to_internet_ok" => 0, $matcher);
    if ($matcher) {
        if ("urllist" =~ $matcher) {
            # conf_sites would go into endless loop with the smash prompt
            local *_real_prompt;
            *_real_prompt = \&CPAN::Shell::colorable_makemaker_prompt;
            conf_sites();
        }
        if ("randomize_urllist" =~ $matcher) {
            my_dflt_prompt(randomize_urllist => 0, $matcher);
        }
        if ("ftpstats_size" =~ $matcher) {
            my_dflt_prompt(ftpstats_size => 99, $matcher);
        }
        if ("ftpstats_period" =~ $matcher) {
            my_dflt_prompt(ftpstats_period => 14, $matcher);
        }
    } elsif ($fastread) {
        $CPAN::Frontend->myprint("Autoconfigured everything but 'urllist'.\n".
                                 "Please call 'o conf init urllist' to configure ".
                                 "your CPAN server(s) now!\n\n");
    } else {
        conf_sites();
    }

    $CPAN::Frontend->myprint("\n\n");
    if ($matcher && !$CPAN::Config->{auto_commit}) {
        $CPAN::Frontend->myprint("Please remember to call 'o conf commit' to ".
                                 "make the config permanent!\n\n");
    } else {
        CPAN::HandleConfig->commit($configpm);
    }
}

sub _init_external_progs {
    my($matcher,$PATH) = @@_;
    my @@external_progs = qw/bzip2 gzip tar unzip

                            make

                            curl lynx wget ncftpget ncftp ftp

                            gpg

                            patch applypatch
                            /;
    if (!$matcher or "@@external_progs" =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{external_progs});

        my $old_warn = $^W;
        local $^W if $^O eq 'MacOS';
        local $^W = $old_warn;
        my $progname;
        for $progname (@@external_progs) {
            next if $matcher && $progname !~ /$matcher/;
            if ($^O eq 'MacOS') {
                $CPAN::Config->{$progname} = 'not_here';
                next;
            }

            my $progcall = $progname;
            unless ($matcher) {
                # we really don't need ncftp if we have ncftpget, but
                # if they chose this dialog via matcher, they shall have it
                next if $progname eq "ncftp" && $CPAN::Config->{ncftpget} gt " ";
            }
            my $path = $CPAN::Config->{$progname}
                || $Config::Config{$progname}
                    || "";
            if (File::Spec->file_name_is_absolute($path)) {
                # testing existence is not good enough, some have these exe
                # extensions

                # warn "Warning: configured $path does not exist\n" unless -e $path;
                # $path = "";
            } elsif ($path =~ /^\s+$/) {
                # preserve disabled programs
            } else {
                $path = '';
            }
            unless ($path) {
                # e.g. make -> nmake
                $progcall = $Config::Config{$progname} if $Config::Config{$progname};
            }

            $path ||= find_exe($progcall,$PATH);
            unless ($path) { # not -e $path, because find_exe already checked that
                local $"=";";
                $CPAN::Frontend->mywarn("Warning: $progcall not found in PATH[@@$PATH]\n");
                if ($progname eq "make") {
                    $CPAN::Frontend->mywarn("ALERT: 'make' is an essential tool for ".
                                            "building perl Modules. Please make sure you ".
                                            "have 'make' (or some equivalent) ".
                                            "working.\n"
                                           );
                    if ($^O eq "MSWin32") {
                        $CPAN::Frontend->mywarn("
Windows users may want to follow this procedure when back in the CPAN shell:

    look YVES/scripts/alien_nmake.pl
    perl alien_nmake.pl

This will install nmake on your system which can be used as a 'make'
substitute. You can then revisit this dialog with

    o conf init make

");
                    }
                }
            }
            $prompts{$progname} = "Where is your $progname program?";
            my_dflt_prompt($progname,$path,$matcher);
        }
    }
}

sub init_cpan_home {
    my($matcher) = @@_;
    if (!$matcher or 'cpan_home' =~ /$matcher/) {
        my $cpan_home = $CPAN::Config->{cpan_home}
            || File::Spec->catdir(CPAN::HandleConfig::home(), ".cpan");

        if (-d $cpan_home) {
            $CPAN::Frontend->myprint(qq{

I see you already have a  directory
    $cpan_home
Shall we use it as the general CPAN build and cache directory?

});
        } else {
            # no cpan-home, must prompt and get one
            $CPAN::Frontend->myprint($prompts{cpan_home_where});
        }

        my $default = $cpan_home;
        my $loop = 0;
        my($last_ans,$ans);
        $CPAN::Frontend->myprint(" <cpan_home>\n");
    PROMPT: while ($ans = prompt("CPAN build and cache directory?",$default)) {
            print "\n";
            if (File::Spec->file_name_is_absolute($ans)) {
                my @@cpan_home = split /[\/\\]/, $ans;
            DIR: for my $dir (@@cpan_home) {
                    if ($dir =~ /^~/ and (!$last_ans or $ans ne $last_ans)) {
                        $CPAN::Frontend
                            ->mywarn("Warning: a tilde in the path will be ".
                                     "taken as a literal tilde. Please ".
                                     "confirm again if you want to keep it\n");
                        $last_ans = $default = $ans;
                        next PROMPT;
                    }
                }
            } else {
                require Cwd;
                my $cwd = Cwd::cwd();
                my $absans = File::Spec->catdir($cwd,$ans);
                $CPAN::Frontend->mywarn("The path '$ans' is not an ".
                                        "absolute path. Please specify ".
                                        "an absolute path\n");
                $default = $absans;
                next PROMPT;
            }
            eval { File::Path::mkpath($ans); }; # dies if it can't
            if ($@@) {
                $CPAN::Frontend->mywarn("Couldn't create directory $ans.\n".
                                        "Please retry.\n");
                next PROMPT;
            }
            if (-d $ans && -w _) {
                last PROMPT;
            } else {
                $CPAN::Frontend->mywarn("Couldn't find directory $ans\n".
                                        "or directory is not writable. Please retry.\n");
                if (++$loop > 5) {
                    $CPAN::Frontend->mydie("Giving up");
                }
            }
        }
        $CPAN::Config->{cpan_home} = $ans;
    }
}

sub my_dflt_prompt {
    my ($item, $dflt, $m) = @@_;
    my $default = $CPAN::Config->{$item} || $dflt;

    if (!$m || $item =~ /$m/) {
        if (my $intro = $prompts{$item . "_intro"}) {
            $CPAN::Frontend->myprint($intro);
        }
        $CPAN::Frontend->myprint(" <$item>\n");
        $CPAN::Config->{$item} = prompt($prompts{$item}, $default);
        print "\n";
    } else {
        $CPAN::Config->{$item} = $default;
    }
}

sub my_yn_prompt {
    my ($item, $dflt, $m) = @@_;
    my $default;
    defined($default = $CPAN::Config->{$item}) or $default = $dflt;

    # $DB::single = 1;
    if (!$m || $item =~ /$m/) {
        if (my $intro = $prompts{$item . "_intro"}) {
            $CPAN::Frontend->myprint($intro);
        }
        $CPAN::Frontend->myprint(" <$item>\n");
        my $ans = prompt($prompts{$item}, $default ? 'yes' : 'no');
        $CPAN::Config->{$item} = ($ans =~ /^[y1]/i ? 1 : 0);
        print "\n";
    } else {
        $CPAN::Config->{$item} = $default;
    }
}

sub my_prompt_loop {
    my ($item, $dflt, $m, $ok) = @@_;
    my $default = $CPAN::Config->{$item} || $dflt;
    my $ans;

    if (!$m || $item =~ /$m/) {
        $CPAN::Frontend->myprint($prompts{$item . "_intro"});
        $CPAN::Frontend->myprint(" <$item>\n");
        do { $ans = prompt($prompts{$item}, $default);
        } until $ans =~ /$ok/;
        $CPAN::Config->{$item} = $ans;
        print "\n";
    } else {
        $CPAN::Config->{$item} = $default;
    }
}


sub conf_sites {
    my $m = 'MIRRORED.BY';
    my $use_mby;
    my $mby = File::Spec->catfile($CPAN::Config->{keep_source_where},$m);
    File::Path::mkpath(File::Basename::dirname($mby));
    if (-f $mby && -f $m && -M $m < -M $mby) {
        $use_mby = 1;
        require File::Copy;
        File::Copy::copy($m,$mby) or die "Could not update $mby: $!";
    }
    local $^T = time;
    my $overwrite_local = 0;
    if ($mby && -f $mby && -M _ <= 60 && -s _ > 0) {
        $use_mby = 1;
        my $mtime = localtime((stat _)[9]);
        my $prompt = qq{Found $mby as of $mtime

I'd use that as a database of CPAN sites. If that is OK for you,
please answer 'y', but if you want me to get a new database from the
internet now, please answer 'n' to the following question.

Shall I use the local database in $mby?};
        my $ans = prompt($prompt,"y");
        if ($ans =~ /^y/i) {
            $CPAN::Config->{connect_to_internet_ok} = 1;
        } else {
            $overwrite_local = 1;
        }
    }
    local $urllist = $CPAN::Config->{urllist};
    my $better_mby;
 LOOP: while () { # multiple errors possible
        if ($use_mby
            or (defined $CPAN::Config->{connect_to_internet_ok}
                and $CPAN::Config->{connect_to_internet_ok})){
            if ($overwrite_local) {
                $CPAN::Frontend->myprint(qq{Trying to overwrite $mby\n});
                $better_mby = CPAN::FTP->localize($m,$mby,3);
                $overwrite_local = 0;
                $use_mby=1 if $mby;
            } elsif ( ! -f $mby ) {
                $CPAN::Frontend->myprint(qq{You have no $mby\n  I'm trying to fetch one\n});
                $better_mby = CPAN::FTP->localize($m,$mby,3);
                $use_mby=1 if $mby;
            } elsif ( -M $mby > 60 ) {
                $CPAN::Frontend->myprint(qq{Your $mby is older than 60 days,\n  I'm trying }.
                                         qq{to fetch a new one\n});
                $better_mby = CPAN::FTP->localize($m,$mby,3);
                $use_mby=1 if $mby;
            } elsif (-s $mby == 0) {
                $CPAN::Frontend->myprint(qq{You have an empty $mby,\n  I'm trying to fetch a better one\n});
                $better_mby = CPAN::FTP->localize($m,$mby,3);
                $use_mby=1 if $mby;
            } else {
                last LOOP;
            }
            if ($better_mby) {
                $mby = $better_mby;
            }
        } elsif (not @@{$urllist||[]}
                 and (not defined $CPAN::Config->{connect_to_internet_ok}
                      or not $CPAN::Config->{connect_to_internet_ok})) {
            $CPAN::Frontend->myprint(qq{CPAN needs access to at least one CPAN mirror.

As you did not allow me to connect to the internet you need to supply
a valid CPAN URL now.\n\n});

            my @@default = map {"file://$_"} grep {-e} "/home/ftp/pub/CPAN", "/home/ftp/pub/PAUSE";
            my $ans = prompt("Please enter the URL of your CPAN mirror",shift @@default);
            if ($ans) {
                push @@$urllist, $ans;
                next LOOP;
            }
        } else {
            last LOOP;
        }
    }
    if ($use_mby){
        read_mirrored_by($mby);
    } else {
        if (not defined $CPAN::Config->{connect_to_internet_ok}
            or not $CPAN::Config->{connect_to_internet_ok}) {
            $CPAN::Frontend->myprint("Configuration does not allow connecting to the internet.\n");
        }
        $CPAN::Frontend->myprint("Current set of CPAN URLs:\n");
        map { $CPAN::Frontend->myprint("  $_\n") } @@$urllist;
    }
    bring_your_own();
    $CPAN::Config->{urllist} = $urllist;
}

sub find_exe {
    my($exe,$path) = @@_;
    my($dir);
    #warn "in find_exe exe[$exe] path[@@$path]";
    for $dir (@@$path) {
        my $abs = File::Spec->catfile($dir,$exe);
        if (($abs = MM->maybe_command($abs))) {
            return $abs;
        }
    }
}

sub picklist {
    my($items,$prompt,$default,$require_nonempty,$empty_warning)=@@_;
    CPAN->debug("picklist('$items','$prompt','$default','$require_nonempty',".
                "'$empty_warning')") if $CPAN::DEBUG;
    $default ||= '';

    my $pos = 0;

    my @@nums;
  SELECTION: while (1) {

        # display, at most, 15 items at a time
        my $limit = $#{ $items } - $pos;
        $limit = 15 if $limit > 15;

        # show the next $limit items, get the new position
        $pos = display_some($items, $limit, $pos, $default);
        $pos = 0 if $pos >= @@$items;

        my $num = prompt($prompt,$default);

        @@nums = split (' ', $num);
        {
            my %seen;
            @@nums = grep { !$seen{$_}++ } @@nums;
        }
        my $i = scalar @@$items;
        unrangify(\@@nums);
        if (0 == @@nums) {
            # cannot allow nothing because nothing means paging!
            # return;
        } elsif (grep (/\D/ || $_ < 1 || $_ > $i, @@nums)) {
            $CPAN::Frontend->mywarn("invalid items entered, try again\n");
            if ("@@nums" =~ /\D/) {
                $CPAN::Frontend->mywarn("(we are expecting only numbers between 1 and $i)\n");
            }
            next SELECTION;
        }
        if ($require_nonempty && !@@nums) {
            $CPAN::Frontend->mywarn("$empty_warning\n");
        }
        $CPAN::Frontend->myprint("\n");

        # a blank line continues...
        unless (@@nums){
            $CPAN::Frontend->mysleep(0.1); # prevent hot spinning process on the next bug
            next SELECTION;
        }
        last;
    }
    for (@@nums) { $_-- }
    @@{$items}[@@nums];
}

sub unrangify ($) {
    my($nums) = $_[0];
    my @@nums2 = ();
    while (@@{$nums||[]}) {
        my $n = shift @@$nums;
        if ($n =~ /^(\d+)-(\d+)$/) {
            my @@range = $1 .. $2;
            # warn "range[@@range]";
            push @@nums2, @@range;
        } else {
            push @@nums2, $n;
        }
    }
    push @@$nums, @@nums2;
}

sub display_some {
    my ($items, $limit, $pos, $default) = @@_;
    $pos ||= 0;

    my @@displayable = @@$items[$pos .. ($pos + $limit)];
    for my $item (@@displayable) {
        $CPAN::Frontend->myprint(sprintf "(%d) %s\n", ++$pos, $item);
    }
    my $hit_what = $default ? "SPACE RETURN" : "RETURN";
    $CPAN::Frontend->myprint(sprintf("%d more items, hit %s to show them\n",
                                     (@@$items - $pos),
                                     $hit_what,
                                    ))
        if $pos < @@$items;
    return $pos;
}

sub read_mirrored_by {
    my $local = shift or return;
    my(%all,$url,$expected_size,$default,$ans,$host,
       $dst,$country,$continent,@@location);
    my $fh = FileHandle->new;
    $fh->open($local) or die "Couldn't open $local: $!";
    local $/ = "\012";
    while (<$fh>) {
        ($host) = /^([\w\.\-]+)/ unless defined $host;
        next unless defined $host;
        next unless /\s+dst_(dst|location)/;
        /location\s+=\s+\"([^\"]+)/ and @@location = (split /\s*,\s*/, $1) and
            ($continent, $country) = @@location[-1,-2];
        $continent =~ s/\s\(.*//;
        $continent =~ s/\W+$//; # if Jarkko doesn't know latitude/longitude
        /dst_dst\s+=\s+\"([^\"]+)/  and $dst = $1;
        next unless $host && $dst && $continent && $country;
        $all{$continent}{$country}{$dst} = CPAN::Mirrored::By->new($continent,$country,$dst);
        undef $host;
        $dst=$continent=$country="";
    }
    $fh->close;
    $CPAN::Config->{urllist} ||= [];
    my @@previous_urls = @@{$CPAN::Config->{urllist}};

    $CPAN::Frontend->myprint($prompts{urls_intro});

    my (@@cont, $cont, %cont, @@countries, @@urls, %seen);
    my $no_previous_warn =
        "Sorry! since you don't have any existing picks, you must make a\n" .
            "geographic selection.";
    my $offer_cont = [sort keys %all];
    if (@@previous_urls) {
        push @@$offer_cont, "(edit previous picks)";
        $default = @@$offer_cont;
    } else {
        # cannot allow nothing because nothing means paging!
        # push @@$offer_cont, "(none of the above)";
    }
    @@cont = picklist($offer_cont,
                     "Select your continent (or several nearby continents)",
                     $default,
                     ! @@previous_urls,
                     $no_previous_warn);
    # cannot allow nothing because nothing means paging!
    # return unless @@cont;

    foreach $cont (@@cont) {
        my @@c = sort keys %{$all{$cont}};
        @@cont{@@c} = map ($cont, 0..$#c);
        @@c = map ("$_ ($cont)", @@c) if @@cont > 1;
        push (@@countries, @@c);
    }
    if (@@previous_urls && @@countries) {
        push @@countries, "(edit previous picks)";
        $default = @@countries;
    }

    if (@@countries) {
        @@countries = picklist (\@@countries,
                               "Select your country (or several nearby countries)",
                               $default,
                               ! @@previous_urls,
                               $no_previous_warn);
        %seen = map (($_ => 1), @@previous_urls);
        # hmmm, should take list of defaults from CPAN::Config->{'urllist'}...
        foreach $country (@@countries) {
            next if $country =~ /edit previous picks/;
            (my $bare_country = $country) =~ s/ \(.*\)//;
            my @@u = sort keys %{$all{$cont{$bare_country}}{$bare_country}};
            @@u = grep (! $seen{$_}, @@u);
            @@u = map ("$_ ($bare_country)", @@u)
                if @@countries > 1;
            push (@@urls, @@u);
        }
    }
    push (@@urls, map ("$_ (previous pick)", @@previous_urls));
    my $prompt = "Select as many URLs as you like (by number),
put them on one line, separated by blanks, hyphenated ranges allowed
 e.g. '1 4 5' or '7 1-4 8'";
    if (@@previous_urls) {
        $default = join (' ', ((scalar @@urls) - (scalar @@previous_urls) + 1) ..
                         (scalar @@urls));
        $prompt .= "\n(or just hit RETURN to keep your previous picks)";
    }

    @@urls = picklist (\@@urls, $prompt, $default);
    foreach (@@urls) { s/ \(.*\)//; }
    if (@@urls) {
        $urllist = \@@urls;
    } else {
        push @@$urllist, @@urls;
    }
}

sub bring_your_own {
    my %seen = map (($_ => 1), @@$urllist);
    my($ans,@@urls);
    my $eacnt = 0; # empty answers
    do {
        my $prompt = "Enter another URL or RETURN to quit:";
        unless (%seen) {
            $prompt = qq{CPAN.pm needs at least one URL where it can fetch CPAN files from.

Please enter your CPAN site:};
        }
        $ans = prompt ($prompt, "");

        if ($ans) {
            $ans =~ s|/?\z|/|; # has to end with one slash
            $ans = "file:$ans" unless $ans =~ /:/; # without a scheme is a file:
            if ($ans =~ /^\w+:\/./) {
                push @@urls, $ans unless $seen{$ans}++;
            } else {
                $CPAN::Frontend->
                    myprint(sprintf(qq{"%s" doesn\'t look like an URL at first sight.
I\'ll ignore it for now.
You can add it to your %s
later if you\'re sure it\'s right.\n},
                                   $ans,
                                   $INC{'CPAN/MyConfig.pm'}
                                   || $INC{'CPAN/Config.pm'}
                                   || "configuration file",
                                  ));
            }
        } else {
            if (++$eacnt >= 5) {
                $CPAN::Frontend->
                    mywarn("Giving up.\n");
                $CPAN::Frontend->mysleep(5);
                return;
            }
        }
    } while $ans || !%seen;

    @@$urllist = CPAN::_uniq(@@$urllist, @@urls);
    $CPAN::Config->{urllist} = $urllist;
    # xxx delete or comment these out when you're happy that it works
    $CPAN::Frontend->myprint("New urllist\n");
    for ( @@$urllist ) { $CPAN::Frontend->myprint("  $_\n") };
}


sub _strip_spaces {
    $_[0] =~ s/^\s+//;  # no leading spaces
    $_[0] =~ s/\s+\z//; # no trailing spaces
}

sub prompt ($;$) {
    unless (defined &_real_prompt) {
        *_real_prompt = \&CPAN::Shell::colorable_makemaker_prompt;
    }
    my $ans = _real_prompt(@@_);

    _strip_spaces($ans);

    return $ans;
}


sub prompt_no_strip ($;$) {
    return _real_prompt(@@_);
}



1;
@


1.8
log
@Merge in perl 5.10.1
@
text
@@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d22 1
a22 1
$VERSION = sprintf "%.6f", substr(q$Rev: 2229 $,4)/1000000 + 5.4;
d45 2
d165 13
d183 14
d211 8
d284 1
a284 1
any parameters (e.g. PREFIX, LIB, UNINST or the like) you want to
d515 20
d545 4
a548 3
Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires
a string eval, which might be a security risk, you can use this option to
enable or disable the deserialisation of code.
d554 6
a559 5
At the time of this writing there are two competing YAML modules,
YAML.pm and YAML::Syck. The latter is faster but needs a C compiler
installed on your system. There may be more alternative YAML
conforming modules but at the time of writing a potential third
player, YAML::Tiny, seemed not powerful enough to work with CPAN.pm.
d574 126
d744 1
a744 1
    my($ans,$default);
d774 1
d818 1
a818 81
        if (!$matcher or 'cpan_home' =~ /$matcher/) {
            my $cpan_home = $CPAN::Config->{cpan_home}
                || File::Spec->catdir($ENV{HOME}, ".cpan");

            if (-d $cpan_home) {
                $CPAN::Frontend->myprint(qq{

I see you already have a  directory
    $cpan_home
Shall we use it as the general CPAN build and cache directory?

});
            } else {
                # no cpan-home, must prompt and get one
                $CPAN::Frontend->myprint($prompts{cpan_home_where});
            }

            $default = $cpan_home;
            my $loop = 0;
            my $last_ans;
            $CPAN::Frontend->myprint(" <cpan_home>\n");
          PROMPT: while ($ans = prompt("CPAN build and cache directory?",$default)) {
                print "\n";
                if (File::Spec->file_name_is_absolute($ans)) {
                    my @@cpan_home = split /[\/\\]/, $ans;
                  DIR: for my $dir (@@cpan_home) {
                        if ($dir =~ /^~/ and (!$last_ans or $ans ne $last_ans)) {
                            $CPAN::Frontend
                                ->mywarn("Warning: a tilde in the path will be ".
                                         "taken as a literal tilde. Please ".
                                         "confirm again if you want to keep it\n");
                            $last_ans = $default = $ans;
                            next PROMPT;
                        }
                    }
                } else {
                    require Cwd;
                    my $cwd = Cwd::cwd();
                    my $absans = File::Spec->catdir($cwd,$ans);
                    $CPAN::Frontend->mywarn("The path '$ans' is not an ".
                                            "absolute path. Please specify ".
                                            "an absolute path\n");
                    $default = $absans;
                    next PROMPT;
                }
                eval { File::Path::mkpath($ans); }; # dies if it can't
                if ($@@) {
                    $CPAN::Frontend->mywarn("Couldn't create directory $ans.\n".
                                            "Please retry.\n");
                    next PROMPT;
                }
                if (-d $ans && -w _) {
                    last PROMPT;
                } else {
                    $CPAN::Frontend->mywarn("Couldn't find directory $ans\n".
                                            "or directory is not writable. Please retry.\n");
                    if (++$loop > 5) {
                        $CPAN::Frontend->mydie("Giving up");
                    }
                }
            }
            $CPAN::Config->{cpan_home} = $ans;
        }

        if (!$matcher or 'keep_source_where' =~ /$matcher/) {
            my_dflt_prompt("keep_source_where",
                           File::Spec->catdir($CPAN::Config->{cpan_home},"sources"),
                           $matcher,
                          );
        }

        if (!$matcher or 'build_dir' =~ /$matcher/) {
            my_dflt_prompt("build_dir",
                           File::Spec->catdir($CPAN::Config->{cpan_home},"build"),
                           $matcher
                          );
        }

        if (!$matcher or 'build_dir_reuse' =~ /$matcher/) {
            my_yn_prompt(build_dir_reuse => 1, $matcher);
        }
d820 13
a832 6
        if (!$matcher or 'prefs_dir' =~ /$matcher/) {
            my_dflt_prompt("prefs_dir",
                           File::Spec->catdir($CPAN::Config->{cpan_home},"prefs"),
                           $matcher
                          );
        }
d844 1
d846 2
a847 12
    if (!$matcher or 'build_cache' =~ /$matcher/) {
        # large enough to build large dists like Tk
        my_dflt_prompt(build_cache => 100, $matcher);
    }

    if (!$matcher or 'index_expire' =~ /$matcher/) {
        my_dflt_prompt(index_expire => 1, $matcher);
    }

    if (!$matcher or 'scan_cache' =~ /$matcher/) {
        my_prompt_loop(scan_cache => 'atstart', $matcher, 'atstart|never');
    }
d860 4
a863 9
    if (!$matcher or 'prerequisites_policy' =~ /$matcher/) {
        my_prompt_loop(prerequisites_policy => 'ask', $matcher,
                       'follow|ask|ignore');
    }

    if (!$matcher or 'build_requires_install_policy' =~ /$matcher/) {
        my_prompt_loop(build_requires_install_policy => 'ask/yes', $matcher,
                       'yes|no|ask/yes|ask/no');
    }
d868 1
a868 3
    if (!$matcher or 'check_sigs' =~ /$matcher/) {
        my_yn_prompt(check_sigs => 0, $matcher);
    }
d886 2
d903 1
a903 3
    if (!$matcher or "yaml_load_code" =~ /$matcher/) {
        my_yn_prompt(yaml_load_code => 0, $matcher);
    }
a907 11

    my @@external_progs = qw/bzip2 gzip tar unzip

                            make

                            curl lynx wget ncftpget ncftp ftp

                            gpg

                            patch applypatch
                            /;
d909 1
a909 2
    if (!$matcher or "@@external_progs" =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{external_progs});
d911 1
a911 68
        my $old_warn = $^W;
        local $^W if $^O eq 'MacOS';
        local $^W = $old_warn;
        my $progname;
        for $progname (@@external_progs) {
            next if $matcher && $progname !~ /$matcher/;
            if ($^O eq 'MacOS') {
                $CPAN::Config->{$progname} = 'not_here';
                next;
            }

            my $progcall = $progname;
            unless ($matcher) {
                # we really don't need ncftp if we have ncftpget, but
                # if they chose this dialog via matcher, they shall have it
                next if $progname eq "ncftp" && $CPAN::Config->{ncftpget} gt " ";
            }
            my $path = $CPAN::Config->{$progname}
                || $Config::Config{$progname}
                    || "";
            if (File::Spec->file_name_is_absolute($path)) {
                # testing existence is not good enough, some have these exe
                # extensions

                # warn "Warning: configured $path does not exist\n" unless -e $path;
                # $path = "";
            } elsif ($path =~ /^\s+$/) {
                # preserve disabled programs
            } else {
                $path = '';
            }
            unless ($path) {
                # e.g. make -> nmake
                $progcall = $Config::Config{$progname} if $Config::Config{$progname};
            }

            $path ||= find_exe($progcall,\@@path);
            unless ($path) { # not -e $path, because find_exe already checked that
                local $"=";";
                $CPAN::Frontend->mywarn("Warning: $progcall not found in PATH[@@path]\n");
                if ($progname eq "make") {
                    $CPAN::Frontend->mywarn("ALERT: 'make' is an essential tool for ".
                                            "building perl Modules. Please make sure you ".
                                            "have 'make' (or some equivalent) ".
                                            "working.\n"
                                           );
                    if ($^O eq "MSWin32") {
                        $CPAN::Frontend->mywarn("
Windows users may want to follow this procedure when back in the CPAN shell:

    look YVES/scripts/alien_nmake.pl
    perl alien_nmake.pl

This will install nmake on your system which can be used as a 'make'
substitute. You can then revisit this dialog with

    o conf init make

");
                    }
                }
            }
            $prompts{$progname} = "Where is your $progname program?";
            my_dflt_prompt($progname,$path,$matcher);
        }
    }

    if (!$matcher or 'pager' =~ /$matcher/) {
d919 1
a919 1
    if (!$matcher or 'shell' =~ /$matcher/) {
d940 6
a945 10
    if (!$matcher or 'tar_verbosity' =~ /$matcher/) {
        my_prompt_loop(tar_verbosity => 'v', $matcher,
                       'none|v|vv');
    }

    if (!$matcher or 'load_module_verbosity' =~ /$matcher/) {
        my_prompt_loop(load_module_verbosity => 'v', $matcher,
                       'none|v');
    }

d952 1
a952 3
    if (!$matcher or 'prefer_installer' =~ /$matcher/) {
        my_prompt_loop(prefer_installer => 'MB', $matcher, 'MB|EUMM|RAND');
    }
d957 7
d980 2
a981 1
    if (exists $CPAN::HandleConfig::keys{mbuild_install_build_command}) {
d996 5
d1048 2
a1049 4
    if (!$matcher or 'getcwd' =~ /$matcher/) {
        my_prompt_loop(getcwd => 'cwd', $matcher,
                       'cwd|getcwd|fastcwd|backtickcwd');
    }
d1103 1
a1103 3
    if (!$matcher or 'term_is_latin' =~ /$matcher/) {
        my_yn_prompt(term_is_latin => 1, $matcher);
    }
d1142 4
d1156 6
d1165 1
a1165 1
                                 "your CPAN server(s) now!");
d1179 150
a1332 1
    $DB::single = 1;
a1368 1
    $DB::single = 1;
d1384 1
d1388 1
a1391 1
    my $loopcount = 0;
d1395 1
d1399 3
a1401 3
I\'d use that as a database of CPAN sites. If that is OK for you,
please answer 'y', but if you want me to get a new database now,
please answer 'n' to the following question.
d1405 5
a1409 1
        $overwrite_local = 1 unless $ans =~ /^y/i;
d1411 44
a1454 16
    while ($mby) {
        if ($overwrite_local) {
            $CPAN::Frontend->myprint(qq{Trying to overwrite $mby\n});
            $mby = CPAN::FTP->localize($m,$mby,3);
            $overwrite_local = 0;
        } elsif ( ! -f $mby ) {
            $CPAN::Frontend->myprint(qq{You have no $mby\n  I\'m trying to fetch one\n});
            $mby = CPAN::FTP->localize($m,$mby,3);
        } elsif (-M $mby > 60 && $loopcount == 0) {
            $CPAN::Frontend->myprint(qq{Your $mby is older than 60 days,\n  I\'m trying }.
                                     qq{to fetch one\n});
            $mby = CPAN::FTP->localize($m,$mby,3);
            $loopcount++;
        } elsif (-s $mby == 0) {
            $CPAN::Frontend->myprint(qq{You have an empty $mby,\n  I\'m trying to fetch one\n});
            $mby = CPAN::FTP->localize($m,$mby,3);
d1456 1
a1456 1
            last;
d1459 10
a1468 2
    local $urllist = [];
    read_mirrored_by($mby);
d1513 4
a1516 1
        if (grep (/\D/ || $_ < 1 || $_ > $i, @@nums)) {
d1529 4
a1532 1
        next SELECTION unless @@nums;
d1607 3
d1616 2
a1617 1

d1660 5
a1664 1
    push @@$urllist, @@urls;
d1707 2
a1708 1
    push @@$urllist, @@urls;
d1710 2
a1711 2
    $CPAN::Frontend->myprint("New set of picks:\n");
    map { $CPAN::Frontend->myprint("  $_\n") } @@$urllist;
a1736 134
BEGIN {

my @@prompts = (

manual_config => qq[

CPAN is the world-wide archive of perl resources. It consists of about
300 sites that all replicate the same contents around the globe. Many
countries have at least one CPAN site already. The resources found on
CPAN are easily accessible with the CPAN.pm module. If you want to use
CPAN.pm, lots of things have to be configured. Fortunately, most of
them can be determined automatically. If you prefer the automatic
configuration, answer 'yes' below.

If you prefer to enter a dialog instead, you can answer 'no' to this
question and I'll let you configure in small steps one thing after the
other. (Note: you can revisit this dialog anytime later by typing 'o
conf init' at the cpan prompt.)
],

config_intro => qq{

The following questions are intended to help you with the
configuration. The CPAN module needs a directory of its own to cache
important index files and maybe keep a temporary mirror of CPAN files.
This may be a site-wide or a personal directory.},

# cpan_home => qq{ },

cpan_home_where => qq{

First of all, I'd like to create this directory. Where?

},

external_progs => qq{

The CPAN module will need a few external programs to work properly.
Please correct me, if I guess the wrong path for a program. Don't
panic if you do not have some of them, just press ENTER for those. To
disable the use of a program, you can type a space followed by ENTER.

},

proxy_intro => qq{

If you're accessing the net via proxies, you can specify them in the
CPAN configuration or via environment variables. The variable in
the \$CPAN::Config takes precedence.

},

proxy_user => qq{

If your proxy is an authenticating proxy, you can store your username
permanently. If you do not want that, just press RETURN. You will then
be asked for your username in every future session.

},

proxy_pass => qq{

Your password for the authenticating proxy can also be stored
permanently on disk. If this violates your security policy, just press
RETURN. You will then be asked for the password in every future
session.

},

urls_intro => qq{

Now we need to know where your favorite CPAN sites are located. Push
a few sites onto the array (just in case the first on the array won\'t
work). If you are mirroring CPAN to your local workstation, specify a
file: URL.

First, pick a nearby continent and country by typing in the number(s)
in front of the item(s) you want to select. You can pick several of
each, separated by spaces. Then, you will be presented with a list of
URLs of CPAN mirrors in the countries you selected, along with
previously selected URLs. Select some of those URLs, or just keep the
old list. Finally, you will be prompted for any extra URLs -- file:,
ftp:, or http: -- that host a CPAN mirror.

},

password_warn => qq{

Warning: Term::ReadKey seems not to be available, your password will
be echoed to the terminal!

},

              );

die "Coding error in \@@prompts declaration.  Odd number of elements, above"
    if (@@prompts % 2);

%prompts = @@prompts;

if (scalar(keys %prompts) != scalar(@@prompts)/2) {
    my %already;
    for my $item (0..$#prompts) {
        next if $item % 2;
        die "$prompts[$item] is duplicated\n" if $already{$prompts[$item]}++;
    }
}

local *FH;
my $pmfile = __FILE__;
open FH, $pmfile or die "Could not open '$pmfile': $!";
local $/ = "";
my @@podpara;
while (<FH>) {
    next if 1 .. /^=over/;
    chomp;
    push @@podpara, $_;
    last if /^=back/;
}
pop @@podpara;
while (@@podpara) {
    warn "Alert: cannot parse my own manpage for init dialog" unless $podpara[0] =~ s/^=item\s+//;
    my $name = shift @@podpara;
    my @@para;
    while (@@podpara && $podpara[0] !~ /^=item/) {
        push @@para, shift @@podpara;
    }
    $prompts{$name} = pop @@para;
    if (@@para) {
        $prompts{$name . "_intro"} = join "", map { "$_\n\n" } @@para;
    }
}

} # EOBEGIN
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
d5 1
a5 1
sub new { 
d14 1
d16 1
a16 2
use strict;
use ExtUtils::MakeMaker qw(prompt);
d20 3
a22 3
use File::Spec;
use vars qw($VERSION);
$VERSION = substr q$Revision: 1.60 $, 10;
d34 5
a38 2
The init routine asks a few questions and writes a CPAN::Config
file. Nothing special.
d42 472
d516 1
a516 1
    my($configpm) = @@_;
d518 31
d550 1
a550 1
	require CPAN::Nox;
d552 2
a553 1
    eval {require CPAN::Config;};
d562 1
a562 1
    # Files, directories
d565 5
a569 1
    print qq[
d571 11
a581 15
CPAN is the world-wide archive of perl resources. It consists of about
100 sites that all replicate the same contents all around the globe.
Many countries have at least one CPAN site already. The resources
found on CPAN are easily accessible with the CPAN.pm module. If you
want to use CPAN.pm, you have to configure it properly.

If you do not want to enter a dialog now, you can answer 'no' to this
question and I\'ll try to autoconfigure. (Note: you can revisit this
dialog anytime later by typing 'o conf init' at the cpan prompt.)

];

    my $manual_conf =
	ExtUtils::MakeMaker::prompt("Are you ready for manual configuration?",
				    "yes");
d584 37
a620 15
      local $^W;
      if ($manual_conf =~ /^\s*y/i) {
	$fastread = 0;
	*prompt = \&ExtUtils::MakeMaker::prompt;
      } else {
	$fastread = 1;
	$CPAN::Config->{urllist} ||= [];
	# prototype should match that of &MakeMaker::prompt
	*prompt = sub ($;$) {
	  my($q,$a) = @@_;
	  my($ret) = defined $a ? $a : "";
	  printf qq{%s [%s]\n\n}, $q, $ret;
	  $ret;
	};
      }
a621 1
    print qq{
d623 12
a634 4
The following questions are intended to help you with the
configuration. The CPAN module needs a directory of its own to cache
important index files and maybe keep a temporary mirror of CPAN files.
This may be a site-wide directory or a personal directory.
d636 2
a637 5
};

    my $cpan_home = $CPAN::Config->{cpan_home} || File::Spec->catdir($ENV{HOME}, ".cpan");
    if (-d $cpan_home) {
	print qq{
d643 5
a647 3
};
    } else {
	print qq{
d649 46
a694 1
First of all, I\'d like to create this directory. Where?
d696 6
a701 2
};
    }
d703 6
a708 24
    $default = $cpan_home;
    while ($ans = prompt("CPAN build and cache directory?",$default)) {
      unless (File::Spec->file_name_is_absolute($ans)) {
        require Cwd;
        my $cwd = Cwd::cwd();
        my $absans = File::Spec->catdir($cwd,$ans);
        warn "The path '$ans' is not an absolute path. Please specify an absolute path\n";
        $default = $absans;
        next;
      }
      eval { File::Path::mkpath($ans); }; # dies if it can't
      if ($@@) {
	warn "Couldn't create directory $ans.
Please retry.\n";
	next;
      }
      if (-d $ans && -w _) {
	last;
      } else {
	warn "Couldn't find directory $ans
  or directory is not writable. Please retry.\n";
      }
    }
    $CPAN::Config->{cpan_home} = $ans;
d710 3
a712 1
    print qq{
d714 7
a720 4
If you want, I can keep the source files after a build in the cpan
home directory. If you choose so then future builds will take the
files from there. If you don\'t want to keep them, answer 0 to the
next question.
d722 3
a724 1
};
d726 1
a726 2
    $CPAN::Config->{keep_source_where} = File::Spec->catdir($CPAN::Config->{cpan_home},"sources");
    $CPAN::Config->{build_dir} = File::Spec->catdir($CPAN::Config->{cpan_home},"build");
d729 1
a729 1
    # Cache size, Index expire
d732 4
a735 1
    print qq{
d737 3
a739 2
How big should the disk cache be for keeping the build directories
with all the intermediate files\?
d741 3
a743 1
};
d745 3
a747 3
    $default = $CPAN::Config->{build_cache} || 10;
    $ans = prompt("Cache size for build directory (in MB)?", $default);
    $CPAN::Config->{build_cache} = $ans;
d749 2
a750 2
    # XXX This the time when we refetch the index files (in days)
    $CPAN::Config->{'index_expire'} = 1;
d752 3
a754 1
    print qq{
d756 4
a759 3
By default, each time the CPAN module is started, cache scanning
is performed to keep the cache size in sync. To prevent from this,
disable the cache scanning with 'never'.
d761 4
a764 1
};
d766 6
a771 5
    $default = $CPAN::Config->{scan_cache} || 'atstart';
    do {
        $ans = prompt("Perform cache scanning (atstart or never)?", $default);
    } while ($ans ne 'atstart' && $ans ne 'never');
    $CPAN::Config->{scan_cache} = $ans;
d774 1
a774 1
    # cache_metadata
d776 12
a787 1
    print qq{
d789 11
a799 3
To considerably speed up the initial CPAN shell startup, it is
possible to use Storable to create a cache of metadata. If Storable
is not available, the normal index mechanism will be used.
d801 6
a806 7
};

    defined($default = $CPAN::Config->{cache_metadata}) or $default = 1;
    do {
        $ans = prompt("Cache metadata (yes/no)?", ($default ? 'yes' : 'no'));
    } while ($ans !~ /^\s*[yn]/i);
    $CPAN::Config->{cache_metadata} = ($ans =~ /^\s*y/i ? 1 : 0);
d809 1
a809 1
    # term_is_latin
a810 1
    print qq{
d812 3
a814 9
The next option deals with the charset your terminal supports. In
general CPAN is English speaking territory, thus the charset does not
matter much, but some of the aliens out there who upload their
software to CPAN bear names that are outside the ASCII range. If your
terminal supports UTF-8, you say no to the next question, if it
supports ISO-8859-1 (also known as LATIN1) then you say yes, and if it
supports neither nor, your answer does not matter, you will not be
able to read the names of some authors anyway. If you answer no, names
will be output in UTF-8.
d816 1
a816 1
};
d818 1
a818 6
    defined($default = $CPAN::Config->{term_is_latin}) or $default = 1;
    do {
        $ans = prompt("Your terminal expects ISO-8859-1 (yes/no)?",
                      ($default ? 'yes' : 'no'));
    } while ($ans !~ /^\s*[yn]/i);
    $CPAN::Config->{term_is_latin} = ($ans =~ /^\s*y/i ? 1 : 0);
d820 5
a824 4
    #
    # save history in file histfile
    #
    print qq{
d826 10
a835 5
If you have one of the readline packages (Term::ReadLine::Perl,
Term::ReadLine::Gnu, possibly others) installed, the interactive CPAN
shell will have history support. The next two questions deal with the
filename of the history file and with its size. If you do not want to
set this variable, please hit SPACE RETURN to the following question.
d837 24
a860 1
};
d862 30
a891 6
    defined($default = $CPAN::Config->{histfile}) or
        $default = File::Spec->catfile($CPAN::Config->{cpan_home},"histfile");
    $ans = prompt("File to save your history?", $default);
    $ans =~ s/^\s+//;
    $ans =~ s/\s+\z//;
    $CPAN::Config->{histfile} = $ans;
d893 23
a915 4
    if ($CPAN::Config->{histfile}) {
      defined($default = $CPAN::Config->{histsize}) or $default = 100;
      $ans = prompt("Number of lines to save?", $default);
      $CPAN::Config->{histsize} = $ans;
d919 1
a919 2
    # prerequisites_policy
    # Do we follow PREREQ_PM?
a920 1
    print qq{
d922 4
a925 5
The CPAN module can detect when a module that which you are trying to
build depends on prerequisites. If this happens, it can build the
prerequisites for you automatically ('follow'), ask you for
confirmation ('ask'), or just ignore them ('ignore'). Please set your
policy to one of the three values.
d927 4
a930 1
};
d932 1
a932 7
    $default = $CPAN::Config->{prerequisites_policy} || 'ask';
    do {
      $ans =
	  prompt("Policy on building prerequisites (follow, ask or ignore)?",
		 $default);
    } while ($ans ne 'follow' && $ans ne 'ask' && $ans ne 'ignore');
    $CPAN::Config->{prerequisites_policy} = $ans;
d935 1
a935 1
    # External programs
d938 3
a940 1
    print qq{
d942 4
a945 7
The CPAN module will need a few external programs to work properly.
Please correct me, if I guess the wrong path for a program. Don\'t
panic if you do not have some of them, just press ENTER for those. To
disable the use of a download program, you can type a space followed
by ENTER.

};
d947 6
a952 54
    my $old_warn = $^W;
    local $^W if $^O eq 'MacOS';
    my(@@path) = split /$Config{'path_sep'}/, $ENV{'PATH'};
    local $^W = $old_warn;
    my $progname;
    for $progname (qw/gzip tar unzip make lynx wget ncftpget ncftp ftp gpg/){
      if ($^O eq 'MacOS') {
          $CPAN::Config->{$progname} = 'not_here';
          next;
      }
      my $progcall = $progname;
      # we don't need ncftp if we have ncftpget
      next if $progname eq "ncftp" && $CPAN::Config->{ncftpget} gt " ";
      my $path = $CPAN::Config->{$progname} 
	  || $Config::Config{$progname}
	      || "";
      if (File::Spec->file_name_is_absolute($path)) {
	# testing existence is not good enough, some have these exe
	# extensions

	# warn "Warning: configured $path does not exist\n" unless -e $path;
	# $path = "";
      } else {
	$path = '';
      }
      unless ($path) {
	# e.g. make -> nmake
	$progcall = $Config::Config{$progname} if $Config::Config{$progname};
      }

      $path ||= find_exe($progcall,[@@path]);
      warn "Warning: $progcall not found in PATH\n" unless
	  $path; # not -e $path, because find_exe already checked that
      $ans = prompt("Where is your $progname program?",$path) || $path;
      $CPAN::Config->{$progname} = $ans;
    }
    my $path = $CPAN::Config->{'pager'} || 
	$ENV{PAGER} || find_exe("less",[@@path]) || 
	    find_exe("more",[@@path]) || ($^O eq 'MacOS' ? $ENV{EDITOR} : 0 )
	    || "more";
    $ans = prompt("What is your favorite pager program?",$path);
    $CPAN::Config->{'pager'} = $ans;
    $path = $CPAN::Config->{'shell'};
    if (File::Spec->file_name_is_absolute($path)) {
	warn "Warning: configured $path does not exist\n" unless -e $path;
	$path = "";
    }
    $path ||= $ENV{SHELL};
    if ($^O eq 'MacOS') {
        $CPAN::Config->{'shell'} = 'not_here';
    } else {
        $path =~ s,\\,/,g if $^O eq 'os2';	# Cosmetic only
        $ans = prompt("What is your favorite shell?",$path);
        $CPAN::Config->{'shell'} = $ans;
d955 2
a956 3
    #
    # Arguments to make etc.
    #
d958 2
a959 1
    print qq{
d961 5
a965 4
Every Makefile.PL is run by perl in a separate process. Likewise we
run \'make\' and \'make install\' in processes. If you have any
parameters \(e.g. PREFIX, LIB, UNINST or the like\) you want to pass
to the calls, please specify them here.
d967 1
a967 1
If you don\'t understand this question, just press ENTER.
d969 3
a971 1
};
d973 1
a973 4
    $default = $CPAN::Config->{makepl_arg} || "";
    $CPAN::Config->{makepl_arg} =
	prompt("Parameters for the 'perl Makefile.PL' command?
Typical frequently used settings:
d975 3
a977 1
    PREFIX=~/perl       non-root users (please see manual for more hints)
d979 9
a987 4
Your choice: ",$default);
    $default = $CPAN::Config->{make_arg} || "";
    $CPAN::Config->{make_arg} = prompt("Parameters for the 'make' command?
Typical frequently used setting:
d989 2
a990 1
    -j3              dual processor system
d992 1
a992 1
Your choice: ",$default);
d994 1
a994 4
    $default = $CPAN::Config->{make_install_arg} || $CPAN::Config->{make_arg} || "";
    $CPAN::Config->{make_install_arg} =
	prompt("Parameters for the 'make install' command?
Typical frequently used setting:
d996 16
a1011 3
    UNINST=1         to always uninstall potentially conflicting files

Your choice: ",$default);
d1014 1
a1014 1
    # Alarm period
d1017 1
a1017 1
    print qq{
d1019 3
a1021 4
Sometimes you may wish to leave the processes run by CPAN alone
without caring about them. As sometimes the Makefile.PL contains
question you\'re expected to answer, you can set a timer that will
kill a 'perl Makefile.PL' process after the specified time in seconds.
d1023 4
a1026 2
If you set this value to 0, these processes will wait forever. This is
the default and recommended setting.
d1028 3
a1030 1
};
d1032 43
a1074 3
    $default = $CPAN::Config->{inactivity_timeout} || 0;
    $CPAN::Config->{inactivity_timeout} =
	prompt("Timeout for inactivity during Makefile.PL?",$default);
d1076 3
a1078 1
    # Proxies
d1080 3
a1082 1
    print qq{
d1084 3
a1086 3
If you\'re accessing the net via proxies, you can specify them in the
CPAN configuration or via environment variables. The variable in
the \$CPAN::Config takes precedence.
d1088 10
a1097 5
};

    for (qw/ftp_proxy http_proxy no_proxy/) {
	$default = $CPAN::Config->{$_} || $ENV{$_};
	$CPAN::Config->{$_} = prompt("Your $_?",$default);
d1100 4
a1103 4
    if ($CPAN::Config->{ftp_proxy} ||
        $CPAN::Config->{http_proxy}) {
        $default = $CPAN::Config->{proxy_user} || $CPAN::LWP::UserAgent::USER;
        print qq{
d1105 11
a1115 3
If your proxy is an authenticating proxy, you can store your username
permanently. If you do not want that, just press RETURN. You will then
be asked for your username in every future session.
d1117 3
a1119 3
};
        if ($CPAN::Config->{proxy_user} = prompt("Your proxy user id?",$default)) {
            print qq{
d1121 17
a1137 4
Your password for the authenticating proxy can also be stored
permanently on disk. If this violates your security policy, just press
RETURN. You will then be asked for the password in every future
session.
d1139 8
a1146 1
};
d1148 16
a1163 4
            if ($CPAN::META->has_inst("Term::ReadKey")) {
                Term::ReadKey::ReadMode("noecho");
            } else {
                print qq{
d1165 9
a1173 10
Warning: Term::ReadKey seems not to be available, your password will
be echoed to the terminal!

};
            }
            $CPAN::Config->{proxy_pass} = prompt("Your proxy password?");
            if ($CPAN::META->has_inst("Term::ReadKey")) {
                Term::ReadKey::ReadMode("restore");
            }
            $CPAN::Frontend->myprint("\n\n");
d1175 6
d1182 1
d1184 17
a1200 3
    #
    # MIRRORED.BY
    #
a1201 9
    conf_sites() unless $fastread;

    # We don't ask that now, it will be noticed in time, won't it?
    $CPAN::Config->{'inhibit_startup_message'} = 0;
    $CPAN::Config->{'getcwd'} = 'cwd';

    print "\n\n";
    CPAN::Config->commit($configpm);
}
d1204 13
a1216 13
  my $m = 'MIRRORED.BY';
  my $mby = File::Spec->catfile($CPAN::Config->{keep_source_where},$m);
  File::Path::mkpath(File::Basename::dirname($mby));
  if (-f $mby && -f $m && -M $m < -M $mby) {
    require File::Copy;
    File::Copy::copy($m,$mby) or die "Could not update $mby: $!";
  }
  my $loopcount = 0;
  local $^T = time;
  my $overwrite_local = 0;
  if ($mby && -f $mby && -M _ <= 60 && -s _ > 0) {
      my $mtime = localtime((stat _)[9]);
      my $prompt = qq{Found $mby as of $mtime
d1223 22
a1244 27
      my $ans = prompt($prompt,"y");
      $overwrite_local = 1 unless $ans =~ /^y/i;
  }
  while ($mby) {
    if ($overwrite_local) {
      print qq{Trying to overwrite $mby
};
      $mby = CPAN::FTP->localize($m,$mby,3);
      $overwrite_local = 0;
    } elsif ( ! -f $mby ){
      print qq{You have no $mby
  I\'m trying to fetch one
};
      $mby = CPAN::FTP->localize($m,$mby,3);
    } elsif (-M $mby > 60 && $loopcount == 0) {
      print qq{Your $mby is older than 60 days,
  I\'m trying to fetch one
};
      $mby = CPAN::FTP->localize($m,$mby,3);
      $loopcount++;
    } elsif (-s $mby == 0) {
      print qq{You have an empty $mby,
  I\'m trying to fetch one
};
      $mby = CPAN::FTP->localize($m,$mby,3);
    } else {
      last;
d1246 4
a1249 3
  }
  read_mirrored_by($mby);
  bring_your_own();
d1257 4
a1260 4
	my $abs = File::Spec->catfile($dir,$exe);
	if (($abs = MM->maybe_command($abs))) {
	    return $abs;
	}
d1266 2
d1273 1
a1273 1
    while (1) {
d1280 1
a1280 1
        $pos = display_some($items, $limit, $pos);
d1286 4
d1291 10
a1300 4
        (warn "invalid items entered, try again\n"), next
            if grep (/\D/ || $_ < 1 || $_ > $i, @@nums);
        if ($require_nonempty) {
            (warn "$empty_warning\n");
d1302 1
a1302 1
        print "\n";
d1305 1
a1305 1
        next unless @@nums;
d1312 16
d1329 2
a1330 2
	my ($items, $limit, $pos) = @@_;
	$pos ||= 0;
d1332 1
a1332 1
	my @@displayable = @@$items[$pos .. ($pos + $limit)];
d1334 1
a1334 1
		printf "(%d) %s\n", ++$pos, $item;
d1336 7
a1342 5
	printf("%d more items, hit SPACE RETURN to show them\n",
               (@@$items - $pos)
              )
            if $pos < @@$items;
	return $pos;
d1347 2
a1348 1
    my(%all,$url,$expected_size,$default,$ans,$host,$dst,$country,$continent,@@location);
d1353 12
a1364 12
	($host) = /^([\w\.\-]+)/ unless defined $host;
	next unless defined $host;
	next unless /\s+dst_(dst|location)/;
	/location\s+=\s+\"([^\"]+)/ and @@location = (split /\s*,\s*/, $1) and
	    ($continent, $country) = @@location[-1,-2];
	$continent =~ s/\s\(.*//;
	$continent =~ s/\W+$//; # if Jarkko doesn't know latitude/longitude
	/dst_dst\s+=\s+\"([^\"]+)/  and $dst = $1;
	next unless $host && $dst && $continent && $country;
	$all{$continent}{$country}{$dst} = CPAN::Mirrored::By->new($continent,$country,$dst);
	undef $host;
	$dst=$continent=$country="";
d1368 1
a1368 11
    my(@@previous_urls);
    if (@@previous_urls = @@{$CPAN::Config->{urllist}}) {
	$CPAN::Config->{urllist} = [];
    }

    print qq{

Now we need to know where your favorite CPAN sites are located. Push
a few sites onto the array (just in case the first on the array won\'t
work). If you are mirroring CPAN to your local workstation, specify a
file: URL.
d1370 1
a1370 9
First, pick a nearby continent and country (you can pick several of
each, separated by spaces, or none if you just want to keep your
existing selections). Then, you will be presented with a list of URLs
of CPAN mirrors in the countries you selected, along with previously
selected URLs. Select some of those URLs, or just keep the old list.
Finally, you will be prompted for any extra URLs -- file:, ftp:, or
http: -- that host a CPAN mirror.

};
d1373 9
a1381 4
    my $no_previous_warn = 
       "Sorry! since you don't have any existing picks, you must make a\n" .
       "geographic selection.";
    @@cont = picklist([sort keys %all],
d1383 1
a1383 1
                     '',
d1394 4
d1402 1
a1402 1
                               '',
d1408 1
d1413 1
a1413 1
               if @@countries > 1;
d1419 2
a1420 1
put them on one line, separated by blanks, e.g. '1 4 5'";
d1422 3
a1424 3
       $default = join (' ', ((scalar @@urls) - (scalar @@previous_urls) + 1) ..
                             (scalar @@urls));
       $prompt .= "\n(or just hit RETURN to keep your previous picks)";
d1429 1
a1429 1
    push @@{$CPAN::Config->{urllist}}, @@urls;
d1433 1
a1433 1
    my %seen = map (($_ => 1), @@{$CPAN::Config->{urllist}});
d1435 1
d1437 3
a1439 3
	my $prompt = "Enter another URL or RETURN to quit:";
	unless (%seen) {
	    $prompt = qq{CPAN.pm needs at least one URL where it can fetch CPAN files from.
d1442 1
a1442 1
	}
a1445 2
            $ans =~ s/^\s+//;  # no leading spaces
            $ans =~ s/\s+\z//; # no trailing spaces
d1451 2
a1452 1
                printf(qq{"%s" doesn\'t look like an URL at first sight.
d1456 12
a1467 3
                       $ans,
                       $INC{'CPAN/MyConfig.pm'} || $INC{'CPAN/Config.pm'} || "configuration file",
                      );
d1472 1
a1472 1
    push @@{$CPAN::Config->{urllist}}, @@urls;
d1474 145
a1618 2
    print "New set of picks:\n";
    map { print "  $_\n" } @@{$CPAN::Config->{urllist}};
d1620 15
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d21 1
a21 1
$VERSION = substr q$Revision: 1.56 $, 10;
d51 1
a51 1
    my($ans,$default,$local,$cont,$url,$expected_size);
d120 8
d229 26
d295 1
a295 1
    for $progname (qw/gzip tar unzip make lynx wget ncftpget ncftp ftp/){
d366 1
a366 2
    POLLUTE=1        increasing backwards compatibility
    LIB=~/perl       non-root users (please see manual for more hints)
a464 13
    unless (@@{$CPAN::Config->{'wait_list'}||[]}) {
	print qq{

WAIT support is available as a Plugin. You need the CPAN::WAIT module
to actually use it.  But we need to know your favorite WAIT server. If
you don\'t know a WAIT server near you, just press ENTER.

};
	$default = "wait://ls6-www.informatik.uni-dortmund.de:1404";
	$ans = prompt("Your favorite WAIT server?\n  ",$default);
	push @@{$CPAN::Config->{'wait_list'}}, $ans;
    }

d542 1
a542 1
	my $pos = 0;
d547 22
a568 22
		# display, at most, 15 items at a time
		my $limit = $#{ $items } - $pos;
		$limit = 15 if $limit > 15;

		# show the next $limit items, get the new position
		$pos = display_some($items, $limit, $pos);
		$pos = 0 if $pos >= @@$items;

		my $num = prompt($prompt,$default);
		
		@@nums = split (' ', $num);
		my $i = scalar @@$items;
		(warn "invalid items entered, try again\n"), next
		    if grep (/\D/ || $_ < 1 || $_ > $i, @@nums);
		if ($require_nonempty) {
		    (warn "$empty_warning\n");
		}
    	print "\n";

		# a blank line continues...
		next unless @@nums;
		last;
d582 4
a585 1
	printf "%d more items, hit ENTER\n", (@@$items - $pos) if $pos < @@$items;
d669 2
a670 2
    my $prompt = "Select as many URLs as you like,
put them on one line, separated by blanks";
d695 2
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d19 1
d21 1
a21 1
$VERSION = substr q$Revision: 1.53 $, 10;
d101 1
a101 1
    my $cpan_home = $CPAN::Config->{cpan_home} || MM->catdir($ENV{HOME}, ".cpan");
d144 2
a145 2
    $CPAN::Config->{keep_source_where} = MM->catdir($CPAN::Config->{cpan_home},"sources");
    $CPAN::Config->{build_dir} = MM->catdir($CPAN::Config->{cpan_home},"build");
d272 1
a272 1
      if (MM->file_name_is_absolute($path)) {
d299 1
a299 1
    if (MM->file_name_is_absolute($path)) {
d440 1
a440 1
	$default = "wait://ls6.informatik.uni-dortmund.de:1404";
d455 1
a455 1
  my $mby = MM->catfile($CPAN::Config->{keep_source_where},$m);
d511 1
a511 1
	my $abs = MM->catfile($dir,$exe);
d522 1
a522 4
    my ($item, $i);
    for $item (@@$items) {
	printf "(%d) %s\n", ++$i, $item;
    }
d526 23
a548 9
	my $num = prompt($prompt,$default);
	@@nums = split (' ', $num);
	(warn "invalid items entered, try again\n"), next
	    if grep (/\D/ || $_ < 1 || $_ > $i, @@nums);
	if ($require_nonempty) {
	    (warn "$empty_warning\n"), next
		unless @@nums;
	}
	last;
a549 1
    print "\n";
d552 12
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d1 1
d20 1
a20 1
$VERSION = substr q$Revision: 1.38 $, 10;
d153 1
a153 1
with all the intermediate files?
d179 41
d233 1
a233 1
    $default = $CPAN::Config->{prerequisites_policy} || 'follow';
d247 5
a251 4
The CPAN module will need a few external programs to work
properly. Please correct me, if I guess the wrong path for a program.
Don\'t panic if you do not have some of them, just press ENTER for
those.
d260 1
a260 1
    for $progname (qw/gzip tar unzip make lynx ncftpget ncftp ftp/){
d318 3
a320 3
run \'make\' and \'make install\' in processes. If you have any parameters
\(e.g. PREFIX, INSTALLPRIVLIB, UNINST or the like\) you want to pass to
the calls, please specify them here.
d328 7
a334 1
	prompt("Parameters for the 'perl Makefile.PL' command?",$default);
d336 6
a341 1
    $CPAN::Config->{make_arg} = prompt("Parameters for the 'make' command?",$default);
d345 6
a350 1
	prompt("Parameters for the 'make install' command?",$default);
d387 38
d461 21
a481 2
  while () {
    if ( ! -f $mby ){
d502 1
d544 1
a544 1
    my($local) = @@_;
d623 2
a624 1
    my $prompt = "Select as many URLs as you like";
d633 2
a634 1
    %seen = map (($_ => 1), @@urls);
d636 3
d640 7
a646 1
        $ans = prompt ("Enter another URL or RETURN to quit:", "");
d649 1
a649 1
            $ans =~ s|/?$|/|; # has to end with one slash
d652 9
a660 7
               push @@urls, $ans 
                  unless $seen{$ans};
            }
            else {
                print qq{"$ans" doesn\'t look like an URL at first sight.
I\'ll ignore it for now.  You can add it to $INC{'CPAN/MyConfig.pm'}
later if you\'re sure it\'s right.\n};
d663 1
a663 1
    } while $ans;
@


1.2
log
@perl5.005_03 (stock)
@
text
@d19 1
a19 1
$VERSION = substr q$Revision: 1.36 $, 10;
d80 3
a82 1
	*prompt = sub {
d363 4
a366 2
  if ( ! -f $mby ){
    print qq{You have no $mby
d369 3
a371 3
    $mby = CPAN::FTP->localize($m,$mby,3);
  } elsif (-M $mby > 30 ) {
    print qq{Your $mby is older than 30 days,
d374 10
a383 1
    $mby = CPAN::FTP->localize($m,$mby,3);
@


1.1
log
@perl 5.004_04
@
text
@d16 1
d19 1
a19 1
$VERSION = substr q$Revision: 1.21 $, 10;
d40 3
a42 1
    require CPAN::Nox;
d47 1
d50 1
a50 1
    
d55 33
d89 6
a94 3
The CPAN module needs a directory of its own to cache important
index files and maybe keep a temporary mirror of CPAN files. This may
be a site-wide directory or a personal directory.
d116 10
a125 5
	File::Path::mkpath($ans); # dies if it can't
	if (-d $ans && -w _) {
	    last;
	} else {
	    warn "Couldn't find directory $ans
d127 1
a127 1
	}
d130 1
a130 1
    
d161 36
d210 2
d213 32
a244 13
    my $prog;
    for $prog (qw/gzip tar unzip make lynx ncftp ftp/){
	my $path = $CPAN::Config->{$prog} || "";
	if (MM->file_name_is_absolute($path)) {
	    warn "Warning: configured $path does not exist\n" unless -e $path;
	    $path = "";
	} else {
	    $path = '';
	}
	$path ||= find_exe($prog,[@@path]);
	warn "Warning: $prog not found in PATH\n" unless -e $path;
	$ans = prompt("Where is your $prog program?",$path) || $path;
	$CPAN::Config->{$prog} = $ans;
d248 2
a249 1
	    find_exe("more",[@@path]) || "more";
d258 7
a264 2
    $ans = prompt("What is your favorite shell?",$path);
    $CPAN::Config->{'shell'} = $ans;
d309 9
a317 1
	prompt("Timeout for inacivity during Makefile.PL?",$default);
d319 6
d330 1
a330 39
    $local = 'MIRRORED.BY';
    $local = MM->catfile($CPAN::Config->{keep_source_where},"MIRRORED.BY") unless -f $local;
    if (@@{$CPAN::Config->{urllist}||[]}) {
	print qq{
I found a list of URLs in CPAN::Config and will use this.
You can change it later with the 'o conf urllist' command.

}
    } elsif (
	     -s $local
	     &&
	     -M $local < 30
	    ) {
	read_mirrored_by($local);
    } else {
	$CPAN::Config->{urllist} ||= [];
	while (! @@{$CPAN::Config->{urllist}}) {
	    my($input) = prompt(qq{
We need to know the URL of your favorite CPAN site.
Please enter it here:});
	    $input =~ s/\s//g;
	    next unless $input;
	    my($wanted) = "MIRRORED.BY";
	    print qq{
Testing "$input" ...
};
	    push @@{$CPAN::Config->{urllist}}, $input;
	    CPAN::FTP->localize($wanted,$local,"force");
	    if (-s $local) {
		print qq{
"$input" seems to work
};
	    } else {
		my $ans = prompt(qq{$input doesn\'t seem to work. Keep it in the list?},"n");
		last unless $ans =~ /^n/i;
		pop @@{$CPAN::Config->{urllist}};
	    }
	}
    }
a344 13
    print qq{

If you\'re accessing the net via proxies, you can specify them in the
CPAN configuration or via environment variables. The variable in
the \$CPAN::Config takes precedence.

};

    for (qw/ftp_proxy http_proxy no_proxy/) {
	$default = $CPAN::Config->{$_} || $ENV{$_};
	$CPAN::Config->{$_} = prompt("Your $_?",$default);
    }

d353 22
d381 1
a381 1
	if (MM->maybe_command($abs)) {
d387 26
d418 1
d426 1
d435 2
a436 6
    if ($expected_size = @@{$CPAN::Config->{urllist}}) {
	for $url (@@{$CPAN::Config->{urllist}}) {
	    # sanity check, scheme+colon, not "q" there:
	    next unless $url =~ /^\w+:\/./;
	    $all{"[From previous setup]"}{"found URL"}{$url}=CPAN::Mirrored::By->new('[From previous setup]','found URL',$url);
	}
a437 2
    } else {
	$expected_size = 6;
d439 1
a439 1
    
d442 1
a442 1
Now we need to know, where your favorite CPAN sites are located. Push
d447 79
a525 68
You can enter the number in front of the URL on the next screen, a
file:, ftp: or http: URL, or "q" to finish selecting.

};

    $ans = prompt("Press RETURN to continue");
    my $other;
    $ans = $other = "";
    my(%seen);
    
    my $pipe = -t *STDIN ? "| $CPAN::Config->{'pager'}" : ">/dev/null";
    while () {
	my(@@valid,$previous_best);
	my $fh = FileHandle->new;
	$fh->open($pipe);
	{
	    my($cont,$country,$url,$item);
	    my(@@cont) = sort keys %all;
	    for $cont (@@cont) {
		$fh->print("    $cont\n");
		for $country (sort {lc $a cmp lc $b} keys %{$all{$cont}}) {
		    for $url (sort {lc $a cmp lc $b} keys %{$all{$cont}{$country}}) {
			my $t = sprintf(
					"      %-18s (%2d) %s\n",
					$country,
					++$item,
					$url
				       );
			if ($cont =~ /^\[/) {
			    $previous_best ||= $item;
			}
			push @@valid, $all{$cont}{$country}{$url};
			$fh->print($t);
		    }
		}
	    }
	}
	$fh->close;
	$previous_best ||= 1;
	$default =
	    @@{$CPAN::Config->{urllist}} >= $expected_size ? "q" : $previous_best;
	$ans = prompt(
		      "\nSelect an$other ftp or file URL or a number (q to finish)",
		      $default
		     );
	my $sel;
	if ($ans =~ /^\d/) {
	    my $this = $valid[$ans-1];
	    my($con,$cou,$url) = ($this->continent,$this->country,$this->url);
	    push @@{$CPAN::Config->{urllist}}, $url unless $seen{$url}++;
	    delete $all{$con}{$cou}{$url};
	    #	    print "Was a number [$ans] con[$con] cou[$cou] url[$url]\n";
	} elsif (@@{$CPAN::Config->{urllist}} && $ans =~ /^q/i) {
	    last;
	} else {
	    $ans =~ s|/?$|/|; # has to end with one slash
	    $ans = "file:$ans" unless $ans =~ /:/; # without a scheme is a file:
	    if ($ans =~ /^\w+:\/./) {
		push @@{$CPAN::Config->{urllist}}, $ans unless $seen{$ans}++;
	    } else {
		print qq{"$ans" doesn\'t look like an URL at first sight.
I\'ll ignore it for now. You can add it to lib/CPAN/Config.pm
later and report a bug in my Makefile.PL to me (andreas koenig).
Thanks.\n};
	    }
	}
	$other ||= "other";
    }
@


1.1.1.1
log
@perl5.005_03
@
text
@a15 1
use File::Basename ();
d18 1
a18 1
$VERSION = substr q$Revision: 1.36 $, 10;
d39 1
a39 3
    unless ($CPAN::VERSION) {
	require CPAN::Nox;
    }
a43 1
    local($|) = 1;
d46 1
a46 1

a50 33
    print qq[

CPAN is the world-wide archive of perl resources. It consists of about
100 sites that all replicate the same contents all around the globe.
Many countries have at least one CPAN site already. The resources
found on CPAN are easily accessible with the CPAN.pm module. If you
want to use CPAN.pm, you have to configure it properly.

If you do not want to enter a dialog now, you can answer 'no' to this
question and I\'ll try to autoconfigure. (Note: you can revisit this
dialog anytime later by typing 'o conf init' at the cpan prompt.)

];

    my $manual_conf =
	ExtUtils::MakeMaker::prompt("Are you ready for manual configuration?",
				    "yes");
    my $fastread;
    {
      local $^W;
      if ($manual_conf =~ /^\s*y/i) {
	$fastread = 0;
	*prompt = \&ExtUtils::MakeMaker::prompt;
      } else {
	$fastread = 1;
	*prompt = sub {
	  my($q,$a) = @@_;
	  my($ret) = defined $a ? $a : "";
	  printf qq{%s [%s]\n\n}, $q, $ret;
	  $ret;
	};
      }
    }
d52 3
a54 6

The following questions are intended to help you with the
configuration. The CPAN module needs a directory of its own to cache
important index files and maybe keep a temporary mirror of CPAN files.
This may be a site-wide directory or a personal directory.

d76 5
a80 10
      eval { File::Path::mkpath($ans); }; # dies if it can't
      if ($@@) {
	warn "Couldn't create directory $ans.
Please retry.\n";
	next;
      }
      if (-d $ans && -w _) {
	last;
      } else {
	warn "Couldn't find directory $ans
d82 1
a82 1
      }
d85 1
a85 1

a115 36
    print qq{

By default, each time the CPAN module is started, cache scanning
is performed to keep the cache size in sync. To prevent from this,
disable the cache scanning with 'never'.

};

    $default = $CPAN::Config->{scan_cache} || 'atstart';
    do {
        $ans = prompt("Perform cache scanning (atstart or never)?", $default);
    } while ($ans ne 'atstart' && $ans ne 'never');
    $CPAN::Config->{scan_cache} = $ans;

    #
    # prerequisites_policy
    # Do we follow PREREQ_PM?
    #
    print qq{

The CPAN module can detect when a module that which you are trying to
build depends on prerequisites. If this happens, it can build the
prerequisites for you automatically ('follow'), ask you for
confirmation ('ask'), or just ignore them ('ignore'). Please set your
policy to one of the three values.

};

    $default = $CPAN::Config->{prerequisites_policy} || 'follow';
    do {
      $ans =
	  prompt("Policy on building prerequisites (follow, ask or ignore)?",
		 $default);
    } while ($ans ne 'follow' && $ans ne 'ask' && $ans ne 'ignore');
    $CPAN::Config->{prerequisites_policy} = $ans;

a128 2
    my $old_warn = $^W;
    local $^W if $^O eq 'MacOS';
d130 13
a142 32
    local $^W = $old_warn;
    my $progname;
    for $progname (qw/gzip tar unzip make lynx ncftpget ncftp ftp/){
      if ($^O eq 'MacOS') {
          $CPAN::Config->{$progname} = 'not_here';
          next;
      }
      my $progcall = $progname;
      # we don't need ncftp if we have ncftpget
      next if $progname eq "ncftp" && $CPAN::Config->{ncftpget} gt " ";
      my $path = $CPAN::Config->{$progname} 
	  || $Config::Config{$progname}
	      || "";
      if (MM->file_name_is_absolute($path)) {
	# testing existence is not good enough, some have these exe
	# extensions

	# warn "Warning: configured $path does not exist\n" unless -e $path;
	# $path = "";
      } else {
	$path = '';
      }
      unless ($path) {
	# e.g. make -> nmake
	$progcall = $Config::Config{$progname} if $Config::Config{$progname};
      }

      $path ||= find_exe($progcall,[@@path]);
      warn "Warning: $progcall not found in PATH\n" unless
	  $path; # not -e $path, because find_exe already checked that
      $ans = prompt("Where is your $progname program?",$path) || $path;
      $CPAN::Config->{$progname} = $ans;
d146 1
a146 2
	    find_exe("more",[@@path]) || ($^O eq 'MacOS' ? $ENV{EDITOR} : 0 )
	    || "more";
d155 2
a156 7
    if ($^O eq 'MacOS') {
        $CPAN::Config->{'shell'} = 'not_here';
    } else {
        $path =~ s,\\,/,g if $^O eq 'os2';	# Cosmetic only
        $ans = prompt("What is your favorite shell?",$path);
        $CPAN::Config->{'shell'} = $ans;
    }
d201 1
a201 9
	prompt("Timeout for inactivity during Makefile.PL?",$default);

    # Proxies

    print qq{

If you\'re accessing the net via proxies, you can specify them in the
CPAN configuration or via environment variables. The variable in
the \$CPAN::Config takes precedence.
a202 6
};

    for (qw/ftp_proxy http_proxy no_proxy/) {
	$default = $CPAN::Config->{$_} || $ENV{$_};
	$CPAN::Config->{$_} = prompt("Your $_?",$default);
    }
d208 39
a246 1
    conf_sites() unless $fastread;
d261 13
a281 22
sub conf_sites {
  my $m = 'MIRRORED.BY';
  my $mby = MM->catfile($CPAN::Config->{keep_source_where},$m);
  File::Path::mkpath(File::Basename::dirname($mby));
  if (-f $mby && -f $m && -M $m < -M $mby) {
    require File::Copy;
    File::Copy::copy($m,$mby) or die "Could not update $mby: $!";
  }
  if ( ! -f $mby ){
    print qq{You have no $mby
  I\'m trying to fetch one
};
    $mby = CPAN::FTP->localize($m,$mby,3);
  } elsif (-M $mby > 30 ) {
    print qq{Your $mby is older than 30 days,
  I\'m trying to fetch one
};
    $mby = CPAN::FTP->localize($m,$mby,3);
  }
  read_mirrored_by($mby);
}

d288 1
a288 1
	if (($abs = MM->maybe_command($abs))) {
a293 26
sub picklist {
    my($items,$prompt,$default,$require_nonempty,$empty_warning)=@@_;
    $default ||= '';

    my ($item, $i);
    for $item (@@$items) {
	printf "(%d) %s\n", ++$i, $item;
    }

    my @@nums;
    while (1) {
	my $num = prompt($prompt,$default);
	@@nums = split (' ', $num);
	(warn "invalid items entered, try again\n"), next
	    if grep (/\D/ || $_ < 1 || $_ > $i, @@nums);
	if ($require_nonempty) {
	    (warn "$empty_warning\n"), next
		unless @@nums;
	}
	last;
    }
    print "\n";
    for (@@nums) { $_-- }
    @@{$items}[@@nums];
}

a298 1
    local $/ = "\012";
a305 1
	$continent =~ s/\W+$//; # if Jarkko doesn't know latitude/longitude
d314 6
a319 2
    my(@@previous_urls);
    if (@@previous_urls = @@{$CPAN::Config->{urllist}}) {
d321 2
d324 1
a324 1

d327 1
a327 1
Now we need to know where your favorite CPAN sites are located. Push
d332 68
a399 79
First, pick a nearby continent and country (you can pick several of
each, separated by spaces, or none if you just want to keep your
existing selections). Then, you will be presented with a list of URLs
of CPAN mirrors in the countries you selected, along with previously
selected URLs. Select some of those URLs, or just keep the old list.
Finally, you will be prompted for any extra URLs -- file:, ftp:, or
http: -- that host a CPAN mirror.

};

    my (@@cont, $cont, %cont, @@countries, @@urls, %seen);
    my $no_previous_warn = 
       "Sorry! since you don't have any existing picks, you must make a\n" .
       "geographic selection.";
    @@cont = picklist([sort keys %all],
                     "Select your continent (or several nearby continents)",
                     '',
                     ! @@previous_urls,
                     $no_previous_warn);


    foreach $cont (@@cont) {
        my @@c = sort keys %{$all{$cont}};
        @@cont{@@c} = map ($cont, 0..$#c);
        @@c = map ("$_ ($cont)", @@c) if @@cont > 1;
        push (@@countries, @@c);
    }

    if (@@countries) {
        @@countries = picklist (\@@countries,
                               "Select your country (or several nearby countries)",
                               '',
                               ! @@previous_urls,
                               $no_previous_warn);
        %seen = map (($_ => 1), @@previous_urls);
        # hmmm, should take list of defaults from CPAN::Config->{'urllist'}...
        foreach $country (@@countries) {
            (my $bare_country = $country) =~ s/ \(.*\)//;
            my @@u = sort keys %{$all{$cont{$bare_country}}{$bare_country}};
            @@u = grep (! $seen{$_}, @@u);
            @@u = map ("$_ ($bare_country)", @@u)
               if @@countries > 1;
            push (@@urls, @@u);
        }
    }
    push (@@urls, map ("$_ (previous pick)", @@previous_urls));
    my $prompt = "Select as many URLs as you like";
    if (@@previous_urls) {
       $default = join (' ', ((scalar @@urls) - (scalar @@previous_urls) + 1) ..
                             (scalar @@urls));
       $prompt .= "\n(or just hit RETURN to keep your previous picks)";
    }

    @@urls = picklist (\@@urls, $prompt, $default);
    foreach (@@urls) { s/ \(.*\)//; }
    %seen = map (($_ => 1), @@urls);

    do {
        $ans = prompt ("Enter another URL or RETURN to quit:", "");

        if ($ans) {
            $ans =~ s|/?$|/|; # has to end with one slash
            $ans = "file:$ans" unless $ans =~ /:/; # without a scheme is a file:
            if ($ans =~ /^\w+:\/./) {
               push @@urls, $ans 
                  unless $seen{$ans};
            }
            else {
                print qq{"$ans" doesn\'t look like an URL at first sight.
I\'ll ignore it for now.  You can add it to $INC{'CPAN/MyConfig.pm'}
later if you\'re sure it\'s right.\n};
            }
        }
    } while $ans;

    push @@{$CPAN::Config->{urllist}}, @@urls;
    # xxx delete or comment these out when you're happy that it works
    print "New set of picks:\n";
    map { print "  $_\n" } @@{$CPAN::Config->{urllist}};
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d19 1
a19 1
$VERSION = substr q$Revision: 1.38 $, 10;
d80 1
a80 3
	$CPAN::Config->{urllist} ||= [];
	# prototype should match that of &MakeMaker::prompt
	*prompt = sub ($;$) {
d361 2
a362 4
  my $loopcount = 0;
  while () {
    if ( ! -f $mby ){
      print qq{You have no $mby
d365 3
a367 3
      $mby = CPAN::FTP->localize($m,$mby,3);
    } elsif (-M $mby > 60 && $loopcount == 0) {
      print qq{Your $mby is older than 60 days,
d370 1
a370 10
      $mby = CPAN::FTP->localize($m,$mby,3);
      $loopcount++;
    } elsif (-s $mby == 0) {
      print qq{You have an empty $mby,
  I\'m trying to fetch one
};
      $mby = CPAN::FTP->localize($m,$mby,3);
    } else {
      last;
    }
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a0 1
# -*- Mode: cperl; coding: utf-8; cperl-indent-level: 4 -*-
d19 1
a19 1
$VERSION = substr q$Revision: 1.53 $, 10;
d152 1
a152 1
with all the intermediate files\?
a177 41
    # cache_metadata
    #
    print qq{

To considerably speed up the initial CPAN shell startup, it is
possible to use Storable to create a cache of metadata. If Storable
is not available, the normal index mechanism will be used.

};

    defined($default = $CPAN::Config->{cache_metadata}) or $default = 1;
    do {
        $ans = prompt("Cache metadata (yes/no)?", ($default ? 'yes' : 'no'));
    } while ($ans !~ /^\s*[yn]/i);
    $CPAN::Config->{cache_metadata} = ($ans =~ /^\s*y/i ? 1 : 0);

    #
    # term_is_latin
    #
    print qq{

The next option deals with the charset your terminal supports. In
general CPAN is English speaking territory, thus the charset does not
matter much, but some of the aliens out there who upload their
software to CPAN bear names that are outside the ASCII range. If your
terminal supports UTF-8, you say no to the next question, if it
supports ISO-8859-1 (also known as LATIN1) then you say yes, and if it
supports neither nor, your answer does not matter, you will not be
able to read the names of some authors anyway. If you answer no, names
will be output in UTF-8.

};

    defined($default = $CPAN::Config->{term_is_latin}) or $default = 1;
    do {
        $ans = prompt("Your terminal expects ISO-8859-1 (yes/no)?",
                      ($default ? 'yes' : 'no'));
    } while ($ans !~ /^\s*[yn]/i);
    $CPAN::Config->{term_is_latin} = ($ans =~ /^\s*y/i ? 1 : 0);

    #
d191 1
a191 1
    $default = $CPAN::Config->{prerequisites_policy} || 'ask';
d205 4
a208 5
The CPAN module will need a few external programs to work properly.
Please correct me, if I guess the wrong path for a program. Don\'t
panic if you do not have some of them, just press ENTER for those. To
disable the use of a download program, you can type a space followed
by ENTER.
d217 1
a217 1
    for $progname (qw/gzip tar unzip make lynx wget ncftpget ncftp ftp/){
d275 3
a277 3
run \'make\' and \'make install\' in processes. If you have any
parameters \(e.g. PREFIX, LIB, UNINST or the like\) you want to pass
to the calls, please specify them here.
d285 1
a285 7
	prompt("Parameters for the 'perl Makefile.PL' command?
Typical frequently used settings:

    POLLUTE=1        increasing backwards compatibility
    LIB=~/perl       non-root users (please see manual for more hints)

Your choice: ",$default);
d287 1
a287 6
    $CPAN::Config->{make_arg} = prompt("Parameters for the 'make' command?
Typical frequently used setting:

    -j3              dual processor system

Your choice: ",$default);
d291 1
a291 6
	prompt("Parameters for the 'make install' command?
Typical frequently used setting:

    UNINST=1         to always uninstall potentially conflicting files

Your choice: ",$default);
a327 38
    if ($CPAN::Config->{ftp_proxy} ||
        $CPAN::Config->{http_proxy}) {
        $default = $CPAN::Config->{proxy_user} || $CPAN::LWP::UserAgent::USER;
        print qq{

If your proxy is an authenticating proxy, you can store your username
permanently. If you do not want that, just press RETURN. You will then
be asked for your username in every future session.

};
        if ($CPAN::Config->{proxy_user} = prompt("Your proxy user id?",$default)) {
            print qq{

Your password for the authenticating proxy can also be stored
permanently on disk. If this violates your security policy, just press
RETURN. You will then be asked for the password in every future
session.

};

            if ($CPAN::META->has_inst("Term::ReadKey")) {
                Term::ReadKey::ReadMode("noecho");
            } else {
                print qq{

Warning: Term::ReadKey seems not to be available, your password will
be echoed to the terminal!

};
            }
            $CPAN::Config->{proxy_pass} = prompt("Your proxy password?");
            if ($CPAN::META->has_inst("Term::ReadKey")) {
                Term::ReadKey::ReadMode("restore");
            }
            $CPAN::Frontend->myprint("\n\n");
        }
    }

d364 2
a365 21
  local $^T = time;
  my $overwrite_local = 0;
  if ($mby && -f $mby && -M _ <= 60 && -s _ > 0) {
      my $mtime = localtime((stat _)[9]);
      my $prompt = qq{Found $mby as of $mtime

I\'d use that as a database of CPAN sites. If that is OK for you,
please answer 'y', but if you want me to get a new database now,
please answer 'n' to the following question.

Shall I use the local database in $mby?};
      my $ans = prompt($prompt,"y");
      $overwrite_local = 1 unless $ans =~ /^y/i;
  }
  while ($mby) {
    if ($overwrite_local) {
      print qq{Trying to overwrite $mby
};
      $mby = CPAN::FTP->localize($m,$mby,3);
      $overwrite_local = 0;
    } elsif ( ! -f $mby ){
a385 1
  bring_your_own();
d427 1
a427 1
    my $local = shift or return;
d506 1
a506 2
    my $prompt = "Select as many URLs as you like,
put them on one line, separated by blanks";
d515 1
a515 2
    push @@{$CPAN::Config->{urllist}}, @@urls;
}
a516 3
sub bring_your_own {
    my %seen = map (($_ => 1), @@{$CPAN::Config->{urllist}});
    my($ans,@@urls);
d518 1
a518 7
	my $prompt = "Enter another URL or RETURN to quit:";
	unless (%seen) {
	    $prompt = qq{CPAN.pm needs at least one URL where it can fetch CPAN files from.

Please enter your CPAN site:};
	}
        $ans = prompt ($prompt, "");
d521 1
a521 1
            $ans =~ s|/?\z|/|; # has to end with one slash
d524 7
a530 9
                push @@urls, $ans unless $seen{$ans}++;
            } else {
                printf(qq{"%s" doesn\'t look like an URL at first sight.
I\'ll ignore it for now.
You can add it to your %s
later if you\'re sure it\'s right.\n},
                       $ans,
                       $INC{'CPAN/MyConfig.pm'} || $INC{'CPAN/Config.pm'} || "configuration file",
                      );
d533 1
a533 1
    } while $ans || !%seen;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a18 1
use File::Spec;
d20 1
a20 1
$VERSION = substr q$Revision: 1.56 $, 10;
d100 1
a100 1
    my $cpan_home = $CPAN::Config->{cpan_home} || File::Spec->catdir($ENV{HOME}, ".cpan");
d143 2
a144 2
    $CPAN::Config->{keep_source_where} = File::Spec->catdir($CPAN::Config->{cpan_home},"sources");
    $CPAN::Config->{build_dir} = File::Spec->catdir($CPAN::Config->{cpan_home},"build");
d271 1
a271 1
      if (File::Spec->file_name_is_absolute($path)) {
d298 1
a298 1
    if (File::Spec->file_name_is_absolute($path)) {
d439 1
a439 1
	$default = "wait://ls6-www.informatik.uni-dortmund.de:1404";
d454 1
a454 1
  my $mby = File::Spec->catfile($CPAN::Config->{keep_source_where},$m);
d510 1
a510 1
	my $abs = File::Spec->catfile($dir,$exe);
d521 4
a524 1
	my $pos = 0;
d528 9
a536 23

		# display, at most, 15 items at a time
		my $limit = $#{ $items } - $pos;
		$limit = 15 if $limit > 15;

		# show the next $limit items, get the new position
		$pos = display_some($items, $limit, $pos);
		$pos = 0 if $pos >= @@$items;

		my $num = prompt($prompt,$default);
		
		@@nums = split (' ', $num);
		my $i = scalar @@$items;
		(warn "invalid items entered, try again\n"), next
		    if grep (/\D/ || $_ < 1 || $_ > $i, @@nums);
		if ($require_nonempty) {
		    (warn "$empty_warning\n");
		}
    	print "\n";

		# a blank line continues...
		next unless @@nums;
		last;
d538 1
a540 12
}

sub display_some {
	my ($items, $limit, $pos) = @@_;
	$pos ||= 0;

	my @@displayable = @@$items[$pos .. ($pos + $limit)];
    for my $item (@@displayable) {
		printf "(%d) %s\n", ++$pos, $item;
    }
	printf "%d more items, hit ENTER\n", (@@$items - $pos) if $pos < @@$items;
	return $pos;
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d21 1
a21 1
$VERSION = substr q$Revision: 1.60 $, 10;
d51 1
a51 1
    my($ans,$default);
a119 8
      unless (File::Spec->file_name_is_absolute($ans)) {
        require Cwd;
        my $cwd = Cwd::cwd();
        my $absans = File::Spec->catdir($cwd,$ans);
        warn "The path '$ans' is not an absolute path. Please specify an absolute path\n";
        $default = $absans;
        next;
      }
a220 26
    # save history in file histfile
    #
    print qq{

If you have one of the readline packages (Term::ReadLine::Perl,
Term::ReadLine::Gnu, possibly others) installed, the interactive CPAN
shell will have history support. The next two questions deal with the
filename of the history file and with its size. If you do not want to
set this variable, please hit SPACE RETURN to the following question.

};

    defined($default = $CPAN::Config->{histfile}) or
        $default = File::Spec->catfile($CPAN::Config->{cpan_home},"histfile");
    $ans = prompt("File to save your history?", $default);
    $ans =~ s/^\s+//;
    $ans =~ s/\s+\z//;
    $CPAN::Config->{histfile} = $ans;

    if ($CPAN::Config->{histfile}) {
      defined($default = $CPAN::Config->{histsize}) or $default = 100;
      $ans = prompt("Number of lines to save?", $default);
      $CPAN::Config->{histsize} = $ans;
    }

    #
d261 1
a261 1
    for $progname (qw/gzip tar unzip make lynx wget ncftpget ncftp ftp gpg/){
d332 2
a333 1
    PREFIX=~/perl       non-root users (please see manual for more hints)
d432 13
d522 1
a522 1
    my $pos = 0;
d527 22
a548 22
        # display, at most, 15 items at a time
        my $limit = $#{ $items } - $pos;
        $limit = 15 if $limit > 15;

        # show the next $limit items, get the new position
        $pos = display_some($items, $limit, $pos);
        $pos = 0 if $pos >= @@$items;

        my $num = prompt($prompt,$default);

        @@nums = split (' ', $num);
        my $i = scalar @@$items;
        (warn "invalid items entered, try again\n"), next
            if grep (/\D/ || $_ < 1 || $_ > $i, @@nums);
        if ($require_nonempty) {
            (warn "$empty_warning\n");
        }
        print "\n";

        # a blank line continues...
        next unless @@nums;
        last;
d562 1
a562 4
	printf("%d more items, hit SPACE RETURN to show them\n",
               (@@$items - $pos)
              )
            if $pos < @@$items;
d646 2
a647 2
    my $prompt = "Select as many URLs as you like (by number),
put them on one line, separated by blanks, e.g. '1 4 5'";
a671 2
            $ans =~ s/^\s+//;  # no leading spaces
            $ans =~ s/\s+\z//; # no trailing spaces
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d21 1
a21 1
$VERSION = substr q$Revision: 1.6 $, 10;
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d21 1
a21 1
$VERSION = substr q$Revision: 1.60 $, 10;
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a2 1
use strict;
d4 1
a4 1
sub new {
d13 1
d15 1
a15 2

use ExtUtils::MakeMaker ();
d19 3
a21 3
use File::Spec ();
use vars qw($VERSION $urllist);
$VERSION = sprintf "%.6f", substr(q$Rev: 2229 $,4)/1000000 + 5.4;
d33 2
a34 5
The init routine asks a few questions and writes a CPAN/Config.pm or
CPAN/MyConfig.pm file (depending on what it is currently using).

In the following all questions and explanations regarding config
variables are collected.
a37 472
# down until the next =back the manpage must be parsed by the program
# because the text is used in the init dialogues.

=over 2

=item auto_commit

Normally CPAN.pm keeps config variables in memory and changes need to
be saved in a separate 'o conf commit' command to make them permanent
between sessions. If you set the 'auto_commit' option to true, changes
to a config variable are always automatically committed to disk.

Always commit changes to config variables to disk?

=item build_cache

CPAN.pm can limit the size of the disk area for keeping the build
directories with all the intermediate files.

Cache size for build directory (in MB)?

=item build_dir

Directory where the build process takes place?

=item build_dir_reuse

Until version 1.88 CPAN.pm never trusted the contents of the build_dir
directory between sessions. Since 1.88_58 CPAN.pm has a YAML-based
mechanism that makes it possible to share the contents of the
build_dir/ directory between different sessions with the same version
of perl. People who prefer to test things several days before
installing will like this feature because it safes a lot of time.

If you say yes to the following question, CPAN will try to store
enough information about the build process so that it can pick up in
future sessions at the same state of affairs as it left a previous
session.

Store and re-use state information about distributions between
CPAN.pm sessions?

=item build_requires_install_policy

When a module declares another one as a 'build_requires' prerequisite
this means that the other module is only needed for building or
testing the module but need not be installed permanently. In this case
you may wish to install that other module nonetheless or just keep it
in the 'build_dir' directory to have it available only temporarily.
Installing saves time on future installations but makes the perl
installation bigger.

You can choose if you want to always install (yes), never install (no)
or be always asked. In the latter case you can set the default answer
for the question to yes (ask/yes) or no (ask/no).

Policy on installing 'build_requires' modules (yes, no, ask/yes,
ask/no)?

=item cache_metadata

To considerably speed up the initial CPAN shell startup, it is
possible to use Storable to create a cache of metadata. If Storable is
not available, the normal index mechanism will be used.

Note: this mechanism is not used when use_sqlite is on and SQLLite is
running.

Cache metadata (yes/no)?

=item check_sigs

CPAN packages can be digitally signed by authors and thus verified
with the security provided by strong cryptography. The exact mechanism
is defined in the Module::Signature module. While this is generally
considered a good thing, it is not always convenient to the end user
to install modules that are signed incorrectly or where the key of the
author is not available or where some prerequisite for
Module::Signature has a bug and so on.

With the check_sigs parameter you can turn signature checking on and
off. The default is off for now because the whole tool chain for the
functionality is not yet considered mature by some. The author of
CPAN.pm would recommend setting it to true most of the time and
turning it off only if it turns out to be annoying.

Note that if you do not have Module::Signature installed, no signature
checks will be performed at all.

Always try to check and verify signatures if a SIGNATURE file is in
the package and Module::Signature is installed (yes/no)?

=item colorize_output

When you have Term::ANSIColor installed, you can turn on colorized
output to have some visual differences between normal CPAN.pm output,
warnings, debugging output, and the output of the modules being
installed. Set your favorite colors after some experimenting with the
Term::ANSIColor module.

Do you want to turn on colored output?

=item colorize_print

Color for normal output?

=item colorize_warn

Color for warnings?

=item colorize_debug

Color for debugging messages?

=item commandnumber_in_prompt

The prompt of the cpan shell can contain the current command number
for easier tracking of the session or be a plain string.

Do you want the command number in the prompt (yes/no)?

=item ftp_passive

Shall we always set the FTP_PASSIVE environment variable when dealing
with ftp download (yes/no)?

=item getcwd

CPAN.pm changes the current working directory often and needs to
determine its own current working directory. Per default it uses
Cwd::cwd but if this doesn't work on your system for some reason,
alternatives can be configured according to the following table:

    cwd         Cwd::cwd
    getcwd      Cwd::getcwd
    fastcwd     Cwd::fastcwd
    backtickcwd external command cwd

Preferred method for determining the current working directory?

=item histfile

If you have one of the readline packages (Term::ReadLine::Perl,
Term::ReadLine::Gnu, possibly others) installed, the interactive CPAN
shell will have history support. The next two questions deal with the
filename of the history file and with its size. If you do not want to
set this variable, please hit SPACE RETURN to the following question.

File to save your history?

=item histsize

Number of lines to save?

=item inactivity_timeout

Sometimes you may wish to leave the processes run by CPAN alone
without caring about them. Because the Makefile.PL or the Build.PL
sometimes contains question you're expected to answer, you can set a
timer that will kill a 'perl Makefile.PL' process after the specified
time in seconds.

If you set this value to 0, these processes will wait forever. This is
the default and recommended setting.

Timeout for inactivity during {Makefile,Build}.PL?

=item index_expire

The CPAN indexes are usually rebuilt once or twice per hour, but the
typical CPAN mirror mirrors only once or twice per day. Depending on
the quality of your mirror and your desire to be on the bleeding edge,
you may want to set the following value to more or less than one day
(which is the default). It determines after how many days CPAN.pm
downloads new indexes.

Let the index expire after how many days?

=item inhibit_startup_message

When the CPAN shell is started it normally displays a greeting message
that contains the running version and the status of readline support.

Do you want to turn this message off?

=item keep_source_where

Unless you are accessing the CPAN on your filesystem via a file: URL,
CPAN.pm needs to keep the source files it downloads somewhere. Please
supply a directory where the downloaded files are to be kept.

Download target directory?

=item load_module_verbosity

When CPAN.pm loads a module it needs for some optional feature, it
usually reports about module name and version. Choose 'v' to get this
message, 'none' to suppress it.

Verbosity level for loading modules (none or v)?

=item makepl_arg

Every Makefile.PL is run by perl in a separate process. Likewise we
run 'make' and 'make install' in separate processes. If you have
any parameters (e.g. PREFIX, LIB, UNINST or the like) you want to
pass to the calls, please specify them here.

If you don't understand this question, just press ENTER.

Typical frequently used settings:

    PREFIX=~/perl    # non-root users (please see manual for more hints)

Parameters for the 'perl Makefile.PL' command?

=item make_arg

Parameters for the 'make' command? Typical frequently used setting:

    -j3              # dual processor system (on GNU make)

Your choice:

=item make_install_arg

Parameters for the 'make install' command?
Typical frequently used setting:

    UNINST=1         # to always uninstall potentially conflicting files

Your choice:

=item make_install_make_command

Do you want to use a different make command for 'make install'?
Cautious people will probably prefer:

    su root -c make
 or
    sudo make
 or
    /path1/to/sudo -u admin_account /path2/to/make

or some such. Your choice:

=item mbuildpl_arg

A Build.PL is run by perl in a separate process. Likewise we run
'./Build' and './Build install' in separate processes. If you have any
parameters you want to pass to the calls, please specify them here.

Typical frequently used settings:

    --install_base /home/xxx             # different installation directory

Parameters for the 'perl Build.PL' command?

=item mbuild_arg

Parameters for the './Build' command? Setting might be:

    --extra_linker_flags -L/usr/foo/lib  # non-standard library location

Your choice:

=item mbuild_install_arg

Parameters for the './Build install' command? Typical frequently used
setting:

    --uninst 1                           # uninstall conflicting files

Your choice:

=item mbuild_install_build_command

Do you want to use a different command for './Build install'? Sudo
users will probably prefer:

    su root -c ./Build
 or
    sudo ./Build
 or
    /path1/to/sudo -u admin_account ./Build

or some such. Your choice:

=item pager

What is your favorite pager program?

=item prefer_installer

When you have Module::Build installed and a module comes with both a
Makefile.PL and a Build.PL, which shall have precedence?

The main two standard installer modules are the old and well
established ExtUtils::MakeMaker (for short: EUMM) which uses the
Makefile.PL. And the next generation installer Module::Build (MB)
which works with the Build.PL (and often comes with a Makefile.PL
too). If a module comes only with one of the two we will use that one
but if both are supplied then a decision must be made between EUMM and
MB. See also http://rt.cpan.org/Ticket/Display.html?id=29235 for a
discussion about the right default.

Or, as a third option you can choose RAND which will make a random
decision (something regular CPAN testers will enjoy).

In case you can choose between running a Makefile.PL or a Build.PL,
which installer would you prefer (EUMM or MB or RAND)?

=item prefs_dir

CPAN.pm can store customized build environments based on regular
expressions for distribution names. These are YAML files where the
default options for CPAN.pm and the environment can be overridden and
dialog sequences can be stored that can later be executed by an
Expect.pm object. The CPAN.pm distribution comes with some prefab YAML
files that cover sample distributions that can be used as blueprints
to store one own prefs. Please check out the distroprefs/ directory of
the CPAN.pm distribution to get a quick start into the prefs system.

Directory where to store default options/environment/dialogs for
building modules that need some customization?

=item prerequisites_policy

The CPAN module can detect when a module which you are trying to build
depends on prerequisites. If this happens, it can build the
prerequisites for you automatically ('follow'), ask you for
confirmation ('ask'), or just ignore them ('ignore'). Please set your
policy to one of the three values.

Policy on building prerequisites (follow, ask or ignore)?

=item randomize_urllist

CPAN.pm can introduce some randomness when using hosts for download
that are configured in the urllist parameter. Enter a numeric value
between 0 and 1 to indicate how often you want to let CPAN.pm try a
random host from the urllist. A value of one specifies to always use a
random host as the first try. A value of zero means no randomness at
all. Anything in between specifies how often, on average, a random
host should be tried first.

Randomize parameter

=item scan_cache

By default, each time the CPAN module is started, cache scanning is
performed to keep the cache size in sync. To prevent this, answer
'never'.

Perform cache scanning (atstart or never)?

=item shell

What is your favorite shell?

=item show_unparsable_versions

During the 'r' command CPAN.pm finds modules without version number.
When the command finishes, it prints a report about this. If you
want this report to be very verbose, say yes to the following
variable.

Show all individual modules that have no $VERSION?

=item show_upload_date

The 'd' and the 'm' command normally only show you information they
have in their in-memory database and thus will never connect to the
internet. If you set the 'show_upload_date' variable to true, 'm' and
'd' will additionally show you the upload date of the module or
distribution. Per default this feature is off because it may require a
net connection to get at the upload date.

Always try to show upload date with 'd' and 'm' command (yes/no)?

=item show_zero_versions

During the 'r' command CPAN.pm finds modules with a version number of
zero. When the command finishes, it prints a report about this. If you
want this report to be very verbose, say yes to the following
variable.

Show all individual modules that have a $VERSION of zero?

=item tar_verbosity

When CPAN.pm uses the tar command, which switch for the verbosity
shall be used? Choose 'none' for quiet operation, 'v' for file
name listing, 'vv' for full listing.

Tar command verbosity level (none or v or vv)?

=item term_is_latin

The next option deals with the charset (aka character set) your
terminal supports. In general, CPAN is English speaking territory, so
the charset does not matter much but some CPAN have names that are
outside the ASCII range. If your terminal supports UTF-8, you should
say no to the next question. If it expects ISO-8859-1 (also known as
LATIN1) then you should say yes. If it supports neither, your answer
does not matter because you will not be able to read the names of some
authors anyway. If you answer no, names will be output in UTF-8.

Your terminal expects ISO-8859-1 (yes/no)?

=item term_ornaments

When using Term::ReadLine, you can turn ornaments on so that your
input stands out against the output from CPAN.pm.

Do you want to turn ornaments on?

=item test_report

The goal of the CPAN Testers project (http://testers.cpan.org/) is to
test as many CPAN packages as possible on as many platforms as
possible.  This provides valuable feedback to module authors and
potential users to identify bugs or platform compatibility issues and
improves the overall quality and value of CPAN.

One way you can contribute is to send test results for each module
that you install.  If you install the CPAN::Reporter module, you have
the option to automatically generate and email test reports to CPAN
Testers whenever you run tests on a CPAN package.

See the CPAN::Reporter documentation for additional details and
configuration settings.  If your firewall blocks outgoing email,
you will need to configure CPAN::Reporter before sending reports.

Email test reports if CPAN::Reporter is installed (yes/no)?

=item use_sqlite

CPAN::SQLite is a layer between the index files that are downloaded
from the CPAN and CPAN.pm that speeds up metadata queries and reduces
memory consumption of CPAN.pm considerably.

Use CPAN::SQLite if available? (yes/no)?

=item yaml_load_code

Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires
a string eval, which might be a security risk, you can use this option to
enable or disable the deserialisation of code.

Do you want to enable code deserialisation (yes/no)?

=item yaml_module

At the time of this writing there are two competing YAML modules,
YAML.pm and YAML::Syck. The latter is faster but needs a C compiler
installed on your system. There may be more alternative YAML
conforming modules but at the time of writing a potential third
player, YAML::Tiny, seemed not powerful enough to work with CPAN.pm.

Which YAML implementation would you prefer?

=back

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

use vars qw( %prompts );
d40 1
a40 1
    my($configpm, %args) = @@_;
a41 31
    # extra args after 'o conf init'
    my $matcher = $args{args} && @@{$args{args}} ? $args{args}[0] : '';
    if ($matcher =~ /^\/(.*)\/$/) {
        # case /regex/ => take the first, ignore the rest
        $matcher = $1;
        shift @@{$args{args}};
        if (@@{$args{args}}) {
            local $" = " ";
            $CPAN::Frontend->mywarn("Ignoring excessive arguments '@@{$args{args}}'");
            $CPAN::Frontend->mysleep(2);
        }
    } elsif (0 == length $matcher) {
    } elsif (0 && $matcher eq "~") { # extremely buggy, but a nice idea
        my @@unconfigured = grep { not exists $CPAN::Config->{$_}
                                      or not defined $CPAN::Config->{$_}
                                          or not length $CPAN::Config->{$_}
                                  } keys %$CPAN::Config;
        $matcher = "\\b(".join("|", @@unconfigured).")\\b";
        $CPAN::Frontend->mywarn("matcher[$matcher]");
    } else {
        # case WORD... => all arguments must be valid
        for my $arg (@@{$args{args}}) {
            unless (exists $CPAN::HandleConfig::keys{$arg}) {
                $CPAN::Frontend->mywarn("'$arg' is not a valid configuration variable\n");
                return;
            }
        }
        $matcher = "\\b(".join("|",@@{$args{args}}).")\\b";
    }
    CPAN->debug("matcher[$matcher]") if $CPAN::DEBUG;

d43 1
a43 1
        require CPAN::Nox;
d45 1
a45 2
    require CPAN::HandleConfig;
    CPAN::HandleConfig::require_myconfig_or_config();
d54 1
a54 1
    #= Files, directories
d57 1
a57 3
    unless ($matcher) {
        $CPAN::Frontend->myprint($prompts{manual_config});
    }
d59 15
a73 13
    my $manual_conf;

    local *_real_prompt;
    if ( $args{autoconfig} ) {
        $manual_conf = "no";
    } elsif ($matcher) {
        $manual_conf = "yes";
    } else {
        my $_conf = prompt("Would you like me to configure as much as possible ".
                           "automatically?", "yes");
        $manual_conf = ($_conf and $_conf =~ /^y/i) ? "no" : "yes";
    }
    CPAN->debug("manual_conf[$manual_conf]") if $CPAN::DEBUG;
d76 15
a90 37
        if ($manual_conf =~ /^y/i) {
            $fastread = 0;
        } else {
            $fastread = 1;
            $CPAN::Config->{urllist} ||= [];

            local $^W = 0;
            # prototype should match that of &MakeMaker::prompt
            my $current_second = time;
            my $current_second_count = 0;
            my $i_am_mad = 0;
            *_real_prompt = sub {
                my($q,$a) = @@_;
                my($ret) = defined $a ? $a : "";
                $CPAN::Frontend->myprint(sprintf qq{%s [%s]\n\n}, $q, $ret);
                eval { require Time::HiRes };
                unless ($@@) {
                    if (time == $current_second) {
                        $current_second_count++;
                        if ($current_second_count > 20) {
                            # I don't like more than 20 prompts per second
                            $i_am_mad++;
                        }
                    } else {
                        $current_second = time;
                        $current_second_count = 0;
                        $i_am_mad-- if $i_am_mad>0;
                    }
                    if ($i_am_mad>0) {
                        #require Carp;
                        #Carp::cluck("SLEEEEEEEEPIIIIIIIIIIINGGGGGGGGGGG");
                        Time::HiRes::sleep(0.1);
                    }
                }
                $ret;
            };
        }
d92 1
d94 4
a97 12
    if (!$matcher or q{
                       build_dir
                       build_dir_reuse
                       cpan_home
                       keep_source_where
                       prefs_dir
                      } =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{config_intro});

        if (!$matcher or 'cpan_home' =~ /$matcher/) {
            my $cpan_home = $CPAN::Config->{cpan_home}
                || File::Spec->catdir($ENV{HOME}, ".cpan");
d99 5
a103 2
            if (-d $cpan_home) {
                $CPAN::Frontend->myprint(qq{
d109 8
a116 5
});
            } else {
                # no cpan-home, must prompt and get one
                $CPAN::Frontend->myprint($prompts{cpan_home_where});
            }
d118 24
a141 46
            $default = $cpan_home;
            my $loop = 0;
            my $last_ans;
            $CPAN::Frontend->myprint(" <cpan_home>\n");
          PROMPT: while ($ans = prompt("CPAN build and cache directory?",$default)) {
                print "\n";
                if (File::Spec->file_name_is_absolute($ans)) {
                    my @@cpan_home = split /[\/\\]/, $ans;
                  DIR: for my $dir (@@cpan_home) {
                        if ($dir =~ /^~/ and (!$last_ans or $ans ne $last_ans)) {
                            $CPAN::Frontend
                                ->mywarn("Warning: a tilde in the path will be ".
                                         "taken as a literal tilde. Please ".
                                         "confirm again if you want to keep it\n");
                            $last_ans = $default = $ans;
                            next PROMPT;
                        }
                    }
                } else {
                    require Cwd;
                    my $cwd = Cwd::cwd();
                    my $absans = File::Spec->catdir($cwd,$ans);
                    $CPAN::Frontend->mywarn("The path '$ans' is not an ".
                                            "absolute path. Please specify ".
                                            "an absolute path\n");
                    $default = $absans;
                    next PROMPT;
                }
                eval { File::Path::mkpath($ans); }; # dies if it can't
                if ($@@) {
                    $CPAN::Frontend->mywarn("Couldn't create directory $ans.\n".
                                            "Please retry.\n");
                    next PROMPT;
                }
                if (-d $ans && -w _) {
                    last PROMPT;
                } else {
                    $CPAN::Frontend->mywarn("Couldn't find directory $ans\n".
                                            "or directory is not writable. Please retry.\n");
                    if (++$loop > 5) {
                        $CPAN::Frontend->mydie("Giving up");
                    }
                }
            }
            $CPAN::Config->{cpan_home} = $ans;
        }
d143 1
a143 6
        if (!$matcher or 'keep_source_where' =~ /$matcher/) {
            my_dflt_prompt("keep_source_where",
                           File::Spec->catdir($CPAN::Config->{cpan_home},"sources"),
                           $matcher,
                          );
        }
d145 4
a148 6
        if (!$matcher or 'build_dir' =~ /$matcher/) {
            my_dflt_prompt("build_dir",
                           File::Spec->catdir($CPAN::Config->{cpan_home},"build"),
                           $matcher
                          );
        }
d150 1
a150 3
        if (!$matcher or 'build_dir_reuse' =~ /$matcher/) {
            my_yn_prompt(build_dir_reuse => 1, $matcher);
        }
d152 2
a153 7
        if (!$matcher or 'prefs_dir' =~ /$matcher/) {
            my_dflt_prompt("prefs_dir",
                           File::Spec->catdir($CPAN::Config->{cpan_home},"prefs"),
                           $matcher
                          );
        }
    }
d156 1
a156 1
    #= Config: auto_commit
d159 6
a164 1
    my_yn_prompt(auto_commit => 0, $matcher);
d166 8
a173 3
    #
    #= Cache size, Index expire
    #
d175 3
a177 4
    if (!$matcher or 'build_cache' =~ /$matcher/) {
        # large enough to build large dists like Tk
        my_dflt_prompt(build_cache => 100, $matcher);
    }
d179 1
a179 3
    if (!$matcher or 'index_expire' =~ /$matcher/) {
        my_dflt_prompt(index_expire => 1, $matcher);
    }
d181 5
a185 3
    if (!$matcher or 'scan_cache' =~ /$matcher/) {
        my_prompt_loop(scan_cache => 'atstart', $matcher, 'atstart|never');
    }
d188 1
a188 1
    #= cache_metadata
d190 5
d196 7
a202 2
    my_yn_prompt(cache_metadata => 1, $matcher);
    my_yn_prompt(use_sqlite => 0, $matcher);
d205 1
a205 1
    #= Do we follow PREREQ_PM?
d207 11
d219 1
a219 4
    if (!$matcher or 'prerequisites_policy' =~ /$matcher/) {
        my_prompt_loop(prerequisites_policy => 'ask', $matcher,
                       'follow|ask|ignore');
    }
d221 6
a226 4
    if (!$matcher or 'build_requires_install_policy' =~ /$matcher/) {
        my_prompt_loop(build_requires_install_policy => 'ask/yes', $matcher,
                       'yes|no|ask/yes|ask/no');
    }
d229 1
a229 1
    #= Module::Signature
d231 7
a237 3
    if (!$matcher or 'check_sigs' =~ /$matcher/) {
        my_yn_prompt(check_sigs => 0, $matcher);
    }
d239 1
a239 15
    #
    #= CPAN::Reporter
    #
    if (!$matcher or 'test_report' =~ /$matcher/) {
        my_yn_prompt(test_report => 0, $matcher);
        if (
            $CPAN::Config->{test_report} &&
            $CPAN::META->has_inst("CPAN::Reporter") &&
            CPAN::Reporter->can('configure')
           ) {
            $CPAN::Frontend->myprint("\nProceeding to configure CPAN::Reporter.\n");
            CPAN::Reporter::configure();
            $CPAN::Frontend->myprint("\nReturning to CPAN configuration.\n");
        }
    }
d241 6
a246 11
    #
    #= YAML vs. YAML::Syck
    #
    if (!$matcher or "yaml_module" =~ /$matcher/) {
        my_dflt_prompt(yaml_module => "YAML", $matcher);
        unless ($CPAN::META->has_inst($CPAN::Config->{yaml_module})) {
            $CPAN::Frontend->mywarn
                ("Warning (maybe harmless): '$CPAN::Config->{yaml_module}' not installed.\n");
            $CPAN::Frontend->mysleep(3);
        }
    }
d248 4
a251 5
    #
    #= YAML code deserialisation
    #
    if (!$matcher or "yaml_load_code" =~ /$matcher/) {
        my_yn_prompt(yaml_load_code => 0, $matcher);
d255 2
a256 1
    #= External programs
d258 1
d260 5
a264 1
    my @@external_progs = qw/bzip2 gzip tar unzip
d266 1
a266 1
                            make
d268 7
a274 1
                            curl lynx wget ncftpget ncftp ftp
d276 3
a278 1
                            gpg
d280 1
a280 5
                            patch applypatch
                            /;
    my(@@path) = split /$Config{'path_sep'}/, $ENV{'PATH'};
    if (!$matcher or "@@external_progs" =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{external_progs});
d282 5
a286 10
        my $old_warn = $^W;
        local $^W if $^O eq 'MacOS';
        local $^W = $old_warn;
        my $progname;
        for $progname (@@external_progs) {
            next if $matcher && $progname !~ /$matcher/;
            if ($^O eq 'MacOS') {
                $CPAN::Config->{$progname} = 'not_here';
                next;
            }
d288 1
a288 24
            my $progcall = $progname;
            unless ($matcher) {
                # we really don't need ncftp if we have ncftpget, but
                # if they chose this dialog via matcher, they shall have it
                next if $progname eq "ncftp" && $CPAN::Config->{ncftpget} gt " ";
            }
            my $path = $CPAN::Config->{$progname}
                || $Config::Config{$progname}
                    || "";
            if (File::Spec->file_name_is_absolute($path)) {
                # testing existence is not good enough, some have these exe
                # extensions

                # warn "Warning: configured $path does not exist\n" unless -e $path;
                # $path = "";
            } elsif ($path =~ /^\s+$/) {
                # preserve disabled programs
            } else {
                $path = '';
            }
            unless ($path) {
                # e.g. make -> nmake
                $progcall = $Config::Config{$progname} if $Config::Config{$progname};
            }
d290 54
a343 54
            $path ||= find_exe($progcall,\@@path);
            unless ($path) { # not -e $path, because find_exe already checked that
                local $"=";";
                $CPAN::Frontend->mywarn("Warning: $progcall not found in PATH[@@path]\n");
                if ($progname eq "make") {
                    $CPAN::Frontend->mywarn("ALERT: 'make' is an essential tool for ".
                                            "building perl Modules. Please make sure you ".
                                            "have 'make' (or some equivalent) ".
                                            "working.\n"
                                           );
                    if ($^O eq "MSWin32") {
                        $CPAN::Frontend->mywarn("
Windows users may want to follow this procedure when back in the CPAN shell:

    look YVES/scripts/alien_nmake.pl
    perl alien_nmake.pl

This will install nmake on your system which can be used as a 'make'
substitute. You can then revisit this dialog with

    o conf init make

");
                    }
                }
            }
            $prompts{$progname} = "Where is your $progname program?";
            my_dflt_prompt($progname,$path,$matcher);
        }
    }

    if (!$matcher or 'pager' =~ /$matcher/) {
        my $path = $CPAN::Config->{'pager'} ||
            $ENV{PAGER} || find_exe("less",\@@path) ||
                find_exe("more",\@@path) || ($^O eq 'MacOS' ? $ENV{EDITOR} : 0 )
                    || "more";
        my_dflt_prompt(pager => $path, $matcher);
    }

    if (!$matcher or 'shell' =~ /$matcher/) {
        my $path = $CPAN::Config->{'shell'};
        if ($path && File::Spec->file_name_is_absolute($path)) {
            $CPAN::Frontend->mywarn("Warning: configured $path does not exist\n")
                unless -e $path;
            $path = "";
        }
        $path ||= $ENV{SHELL};
        $path ||= $ENV{COMSPEC} if $^O eq "MSWin32";
        if ($^O eq 'MacOS') {
            $CPAN::Config->{'shell'} = 'not_here';
        } else {
            $path =~ s,\\,/,g if $^O eq 'os2'; # Cosmetic only
            my_dflt_prompt(shell => $path, $matcher);
        }
d347 1
a347 1
    # verbosity
d350 6
a355 4
    if (!$matcher or 'tar_verbosity' =~ /$matcher/) {
        my_prompt_loop(tar_verbosity => 'v', $matcher,
                       'none|v|vv');
    }
d357 1
a357 4
    if (!$matcher or 'load_module_verbosity' =~ /$matcher/) {
        my_prompt_loop(load_module_verbosity => 'v', $matcher,
                       'none|v');
    }
d359 1
a359 1
    my_yn_prompt(inhibit_startup_message => 0, $matcher);
d361 4
a364 3
    #
    #= Installer, arguments to make etc.
    #
d366 1
a366 3
    if (!$matcher or 'prefer_installer' =~ /$matcher/) {
        my_prompt_loop(prefer_installer => 'MB', $matcher, 'MB|EUMM|RAND');
    }
d368 4
a371 4
    if (!$matcher or 'makepl_arg make_arg' =~ /$matcher/) {
        my_dflt_prompt(makepl_arg => "", $matcher);
        my_dflt_prompt(make_arg => "", $matcher);
    }
d373 1
a373 7
    require CPAN::HandleConfig;
    if (exists $CPAN::HandleConfig::keys{make_install_make_command}) {
        # as long as Windows needs $self->_build_command, we cannot
        # support sudo on windows :-)
        my_dflt_prompt(make_install_make_command => $CPAN::Config->{make} || "",
                       $matcher);
    }
d375 1
a375 2
    my_dflt_prompt(make_install_arg => $CPAN::Config->{make_arg} || "",
                   $matcher);
d377 4
a380 2
    my_dflt_prompt(mbuildpl_arg => "", $matcher);
    my_dflt_prompt(mbuild_arg => "", $matcher);
d382 1
a382 5
    if (exists $CPAN::HandleConfig::keys{mbuild_install_build_command}) {
        # as long as Windows needs $self->_build_command, we cannot
        # support sudo on windows :-)
        my_dflt_prompt(mbuild_install_build_command => "./Build", $matcher);
    }
d384 1
a384 1
    my_dflt_prompt(mbuild_install_arg => "", $matcher);
d387 1
a387 1
    #= Alarm period
d390 1
a390 1
    my_dflt_prompt(inactivity_timeout => 0, $matcher);
d392 4
a395 3
    #
    #= Proxies
    #
d397 2
a398 12
    my @@proxy_vars = qw/ftp_proxy http_proxy no_proxy/;
    my @@proxy_user_vars = qw/proxy_user proxy_pass/;
    if (!$matcher or "@@proxy_vars @@proxy_user_vars" =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{proxy_intro});

        for (@@proxy_vars) {
            $prompts{$_} = "Your $_?";
            my_dflt_prompt($_ => $ENV{$_}||"", $matcher);
        }

        if ($CPAN::Config->{ftp_proxy} ||
            $CPAN::Config->{http_proxy}) {
d400 1
a400 1
            $default = $CPAN::Config->{proxy_user} || $CPAN::LWP::UserAgent::USER || "";
d402 3
a404 1
            $CPAN::Frontend->myprint($prompts{proxy_user});
d406 1
a406 16
            if ($CPAN::Config->{proxy_user} = prompt("Your proxy user id?",$default)) {
                $CPAN::Frontend->myprint($prompts{proxy_pass});

                if ($CPAN::META->has_inst("Term::ReadKey")) {
                    Term::ReadKey::ReadMode("noecho");
                } else {
                    $CPAN::Frontend->myprint($prompts{password_warn});
                }
                $CPAN::Config->{proxy_pass} = prompt_no_strip("Your proxy password?");
                if ($CPAN::META->has_inst("Term::ReadKey")) {
                    Term::ReadKey::ReadMode("restore");
                }
                $CPAN::Frontend->myprint("\n\n");
            }
        }
    }
d408 1
a408 3
    #
    #= how FTP works
    #
d410 3
a412 1
    my_yn_prompt(ftp_passive => 1, $matcher);
d414 1
a414 3
    #
    #= how cwd works
    #
d416 3
a418 3
    if (!$matcher or 'getcwd' =~ /$matcher/) {
        my_prompt_loop(getcwd => 'cwd', $matcher,
                       'cwd|getcwd|fastcwd|backtickcwd');
d421 4
a424 3
    #
    #= the CPAN shell itself (prompt, color)
    #
d426 3
a428 43
    my_yn_prompt(commandnumber_in_prompt => 1, $matcher);
    my_yn_prompt(term_ornaments => 1, $matcher);
    if ("colorize_output colorize_print colorize_warn colorize_debug" =~ $matcher) {
        my_yn_prompt(colorize_output => 0, $matcher);
        if ($CPAN::Config->{colorize_output}) {
            if ($CPAN::META->has_inst("Term::ANSIColor")) {
                my $T="gYw";
                print "                                      on_  on_y ".
                    "        on_ma           on_\n";
                print "                   on_black on_red  green ellow ".
                    "on_blue genta on_cyan white\n";

                for my $FG ("", "bold",
                            map {$_,"bold $_"} "black","red","green",
                            "yellow","blue",
                            "magenta",
                            "cyan","white") {
                    printf "%12s ", $FG;
                    for my $BG ("",map {"on_$_"} qw(black red green yellow
                                                    blue magenta cyan white)) {
                        print $FG||$BG ?
                            Term::ANSIColor::colored("  $T  ","$FG $BG") : "  $T  ";
                    }
                    print "\n";
                }
                print "\n";
            }
            for my $tuple (
                           ["colorize_print", "bold blue on_white"],
                           ["colorize_warn", "bold red on_white"],
                           ["colorize_debug", "black on_cyan"],
                          ) {
                my_dflt_prompt($tuple->[0] => $tuple->[1], $matcher);
                if ($CPAN::META->has_inst("Term::ANSIColor")) {
                    eval { Term::ANSIColor::color($CPAN::Config->{$tuple->[0]})};
                    if ($@@) {
                        $CPAN::Config->{$tuple->[0]} = $tuple->[1];
                        $CPAN::Frontend->mywarn($@@."setting to default '$tuple->[1]'\n");
                    }
                }
            }
        }
    }
d430 3
a432 3
    #
    #== term_is_latin
    #
d434 4
a437 3
    if (!$matcher or 'term_is_latin' =~ /$matcher/) {
        my_yn_prompt(term_is_latin => 1, $matcher);
    }
d439 1
a439 3
    #
    #== save history in file 'histfile'
    #
d441 4
a444 11
    if (!$matcher or 'histfile histsize' =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{histfile_intro});
        defined($default = $CPAN::Config->{histfile}) or
            $default = File::Spec->catfile($CPAN::Config->{cpan_home},"histfile");
        my_dflt_prompt(histfile => $default, $matcher);

        if ($CPAN::Config->{histfile}) {
            defined($default = $CPAN::Config->{histsize}) or $default = 100;
            my_dflt_prompt(histsize => $default, $matcher);
        }
    }
d446 2
a447 4
    #
    #== do an ls on the m or the d command
    #
    my_yn_prompt(show_upload_date => 0, $matcher);
d449 8
a456 10
    #
    #== verbosity at the end of the r command
    #
    if (!$matcher
        or 'show_unparsable_versions' =~ /$matcher/
        or 'show_zero_versions' =~ /$matcher/
       ) {
        $CPAN::Frontend->myprint($prompts{show_unparsable_or_zero_versions_intro});
        my_yn_prompt(show_unparsable_versions => 0, $matcher);
        my_yn_prompt(show_zero_versions => 0, $matcher);
d460 1
a460 1
    #= MIRRORED.BY and conf_sites()
d463 1
a463 17
    if ($matcher) {
        if ("urllist" =~ $matcher) {
            # conf_sites would go into endless loop with the smash prompt
            local *_real_prompt;
            *_real_prompt = \&CPAN::Shell::colorable_makemaker_prompt;
            conf_sites();
        }
        if ("randomize_urllist" =~ $matcher) {
            my_dflt_prompt(randomize_urllist => 0, $matcher);
        }
    } elsif ($fastread) {
        $CPAN::Frontend->myprint("Autoconfigured everything but 'urllist'.\n".
                                 "Please call 'o conf init urllist' to configure ".
                                 "your CPAN server(s) now!");
    } else {
        conf_sites();
    }
d465 3
a467 8
    $CPAN::Frontend->myprint("\n\n");
    if ($matcher && !$CPAN::Config->{auto_commit}) {
        $CPAN::Frontend->myprint("Please remember to call 'o conf commit' to ".
                                 "make the config permanent!\n\n");
    } else {
        CPAN::HandleConfig->commit($configpm);
    }
}
d469 2
a470 15
sub my_dflt_prompt {
    my ($item, $dflt, $m) = @@_;
    my $default = $CPAN::Config->{$item} || $dflt;

    $DB::single = 1;
    if (!$m || $item =~ /$m/) {
        if (my $intro = $prompts{$item . "_intro"}) {
            $CPAN::Frontend->myprint($intro);
        }
        $CPAN::Frontend->myprint(" <$item>\n");
        $CPAN::Config->{$item} = prompt($prompts{$item}, $default);
        print "\n";
    } else {
        $CPAN::Config->{$item} = $default;
    }
a472 38
sub my_yn_prompt {
    my ($item, $dflt, $m) = @@_;
    my $default;
    defined($default = $CPAN::Config->{$item}) or $default = $dflt;

    # $DB::single = 1;
    if (!$m || $item =~ /$m/) {
        if (my $intro = $prompts{$item . "_intro"}) {
            $CPAN::Frontend->myprint($intro);
        }
        $CPAN::Frontend->myprint(" <$item>\n");
        my $ans = prompt($prompts{$item}, $default ? 'yes' : 'no');
        $CPAN::Config->{$item} = ($ans =~ /^[y1]/i ? 1 : 0);
        print "\n";
    } else {
        $CPAN::Config->{$item} = $default;
    }
}

sub my_prompt_loop {
    my ($item, $dflt, $m, $ok) = @@_;
    my $default = $CPAN::Config->{$item} || $dflt;
    my $ans;

    $DB::single = 1;
    if (!$m || $item =~ /$m/) {
        $CPAN::Frontend->myprint($prompts{$item . "_intro"});
        $CPAN::Frontend->myprint(" <$item>\n");
        do { $ans = prompt($prompts{$item}, $default);
        } until $ans =~ /$ok/;
        $CPAN::Config->{$item} = $ans;
        print "\n";
    } else {
        $CPAN::Config->{$item} = $default;
    }
}


d474 13
a486 13
    my $m = 'MIRRORED.BY';
    my $mby = File::Spec->catfile($CPAN::Config->{keep_source_where},$m);
    File::Path::mkpath(File::Basename::dirname($mby));
    if (-f $mby && -f $m && -M $m < -M $mby) {
        require File::Copy;
        File::Copy::copy($m,$mby) or die "Could not update $mby: $!";
    }
    my $loopcount = 0;
    local $^T = time;
    my $overwrite_local = 0;
    if ($mby && -f $mby && -M _ <= 60 && -s _ > 0) {
        my $mtime = localtime((stat _)[9]);
        my $prompt = qq{Found $mby as of $mtime
d493 27
a519 2
        my $ans = prompt($prompt,"y");
        $overwrite_local = 1 unless $ans =~ /^y/i;
d521 3
a523 24
    while ($mby) {
        if ($overwrite_local) {
            $CPAN::Frontend->myprint(qq{Trying to overwrite $mby\n});
            $mby = CPAN::FTP->localize($m,$mby,3);
            $overwrite_local = 0;
        } elsif ( ! -f $mby ) {
            $CPAN::Frontend->myprint(qq{You have no $mby\n  I\'m trying to fetch one\n});
            $mby = CPAN::FTP->localize($m,$mby,3);
        } elsif (-M $mby > 60 && $loopcount == 0) {
            $CPAN::Frontend->myprint(qq{Your $mby is older than 60 days,\n  I\'m trying }.
                                     qq{to fetch one\n});
            $mby = CPAN::FTP->localize($m,$mby,3);
            $loopcount++;
        } elsif (-s $mby == 0) {
            $CPAN::Frontend->myprint(qq{You have an empty $mby,\n  I\'m trying to fetch one\n});
            $mby = CPAN::FTP->localize($m,$mby,3);
        } else {
            last;
        }
    }
    local $urllist = [];
    read_mirrored_by($mby);
    bring_your_own();
    $CPAN::Config->{urllist} = $urllist;
d531 4
a534 4
        my $abs = File::Spec->catfile($dir,$exe);
        if (($abs = MM->maybe_command($abs))) {
            return $abs;
        }
a539 2
    CPAN->debug("picklist('$items','$prompt','$default','$require_nonempty',".
                "'$empty_warning')") if $CPAN::DEBUG;
d545 1
a545 1
  SELECTION: while (1) {
d552 1
a552 1
        $pos = display_some($items, $limit, $pos, $default);
a557 4
        {
            my %seen;
            @@nums = grep { !$seen{$_}++ } @@nums;
        }
d559 4
a562 7
        unrangify(\@@nums);
        if (grep (/\D/ || $_ < 1 || $_ > $i, @@nums)) {
            $CPAN::Frontend->mywarn("invalid items entered, try again\n");
            if ("@@nums" =~ /\D/) {
                $CPAN::Frontend->mywarn("(we are expecting only numbers between 1 and $i)\n");
            }
            next SELECTION;
d564 1
a564 4
        if ($require_nonempty && !@@nums) {
            $CPAN::Frontend->mywarn("$empty_warning\n");
        }
        $CPAN::Frontend->myprint("\n");
d567 1
a567 1
        next SELECTION unless @@nums;
a573 16
sub unrangify ($) {
    my($nums) = $_[0];
    my @@nums2 = ();
    while (@@{$nums||[]}) {
        my $n = shift @@$nums;
        if ($n =~ /^(\d+)-(\d+)$/) {
            my @@range = $1 .. $2;
            # warn "range[@@range]";
            push @@nums2, @@range;
        } else {
            push @@nums2, $n;
        }
    }
    push @@$nums, @@nums2;
}

d575 2
a576 2
    my ($items, $limit, $pos, $default) = @@_;
    $pos ||= 0;
d578 1
a578 1
    my @@displayable = @@$items[$pos .. ($pos + $limit)];
d580 1
a580 1
        $CPAN::Frontend->myprint(sprintf "(%d) %s\n", ++$pos, $item);
d582 5
a586 7
    my $hit_what = $default ? "SPACE RETURN" : "RETURN";
    $CPAN::Frontend->myprint(sprintf("%d more items, hit %s to show them\n",
                                     (@@$items - $pos),
                                     $hit_what,
                                    ))
        if $pos < @@$items;
    return $pos;
d591 1
a591 2
    my(%all,$url,$expected_size,$default,$ans,$host,
       $dst,$country,$continent,@@location);
d596 12
a607 12
        ($host) = /^([\w\.\-]+)/ unless defined $host;
        next unless defined $host;
        next unless /\s+dst_(dst|location)/;
        /location\s+=\s+\"([^\"]+)/ and @@location = (split /\s*,\s*/, $1) and
            ($continent, $country) = @@location[-1,-2];
        $continent =~ s/\s\(.*//;
        $continent =~ s/\W+$//; # if Jarkko doesn't know latitude/longitude
        /dst_dst\s+=\s+\"([^\"]+)/  and $dst = $1;
        next unless $host && $dst && $continent && $country;
        $all{$continent}{$country}{$dst} = CPAN::Mirrored::By->new($continent,$country,$dst);
        undef $host;
        $dst=$continent=$country="";
d611 11
a621 1
    my @@previous_urls = @@{$CPAN::Config->{urllist}};
d623 9
a631 1
    $CPAN::Frontend->myprint($prompts{urls_intro});
d634 4
a637 9
    my $no_previous_warn =
        "Sorry! since you don't have any existing picks, you must make a\n" .
            "geographic selection.";
    my $offer_cont = [sort keys %all];
    if (@@previous_urls) {
        push @@$offer_cont, "(edit previous picks)";
        $default = @@$offer_cont;
    }
    @@cont = picklist($offer_cont,
d639 1
a639 1
                     $default,
a649 4
    if (@@previous_urls && @@countries) {
        push @@countries, "(edit previous picks)";
        $default = @@countries;
    }
d654 1
a654 1
                               $default,
a659 1
            next if $country =~ /edit previous picks/;
d664 1
a664 1
                if @@countries > 1;
d670 1
a670 2
put them on one line, separated by blanks, hyphenated ranges allowed
 e.g. '1 4 5' or '7 1-4 8'";
d672 3
a674 3
        $default = join (' ', ((scalar @@urls) - (scalar @@previous_urls) + 1) ..
                         (scalar @@urls));
        $prompt .= "\n(or just hit RETURN to keep your previous picks)";
d679 1
a679 1
    push @@$urllist, @@urls;
d683 1
a683 1
    my %seen = map (($_ => 1), @@$urllist);
a684 1
    my $eacnt = 0; # empty answers
d686 3
a688 3
        my $prompt = "Enter another URL or RETURN to quit:";
        unless (%seen) {
            $prompt = qq{CPAN.pm needs at least one URL where it can fetch CPAN files from.
d691 1
a691 1
        }
d695 2
d702 1
a702 2
                $CPAN::Frontend->
                    myprint(sprintf(qq{"%s" doesn\'t look like an URL at first sight.
d706 3
a708 12
                                   $ans,
                                   $INC{'CPAN/MyConfig.pm'}
                                   || $INC{'CPAN/Config.pm'}
                                   || "configuration file",
                                  ));
            }
        } else {
            if (++$eacnt >= 5) {
                $CPAN::Frontend->
                    mywarn("Giving up.\n");
                $CPAN::Frontend->mysleep(5);
                return;
d713 1
a713 1
    push @@$urllist, @@urls;
d715 2
a716 145
    $CPAN::Frontend->myprint("New set of picks:\n");
    map { $CPAN::Frontend->myprint("  $_\n") } @@$urllist;
}


sub _strip_spaces {
    $_[0] =~ s/^\s+//;  # no leading spaces
    $_[0] =~ s/\s+\z//; # no trailing spaces
}

sub prompt ($;$) {
    unless (defined &_real_prompt) {
        *_real_prompt = \&CPAN::Shell::colorable_makemaker_prompt;
    }
    my $ans = _real_prompt(@@_);

    _strip_spaces($ans);

    return $ans;
}


sub prompt_no_strip ($;$) {
    return _real_prompt(@@_);
}


BEGIN {

my @@prompts = (

manual_config => qq[

CPAN is the world-wide archive of perl resources. It consists of about
300 sites that all replicate the same contents around the globe. Many
countries have at least one CPAN site already. The resources found on
CPAN are easily accessible with the CPAN.pm module. If you want to use
CPAN.pm, lots of things have to be configured. Fortunately, most of
them can be determined automatically. If you prefer the automatic
configuration, answer 'yes' below.

If you prefer to enter a dialog instead, you can answer 'no' to this
question and I'll let you configure in small steps one thing after the
other. (Note: you can revisit this dialog anytime later by typing 'o
conf init' at the cpan prompt.)
],

config_intro => qq{

The following questions are intended to help you with the
configuration. The CPAN module needs a directory of its own to cache
important index files and maybe keep a temporary mirror of CPAN files.
This may be a site-wide or a personal directory.},

# cpan_home => qq{ },

cpan_home_where => qq{

First of all, I'd like to create this directory. Where?

},

external_progs => qq{

The CPAN module will need a few external programs to work properly.
Please correct me, if I guess the wrong path for a program. Don't
panic if you do not have some of them, just press ENTER for those. To
disable the use of a program, you can type a space followed by ENTER.

},

proxy_intro => qq{

If you're accessing the net via proxies, you can specify them in the
CPAN configuration or via environment variables. The variable in
the \$CPAN::Config takes precedence.

},

proxy_user => qq{

If your proxy is an authenticating proxy, you can store your username
permanently. If you do not want that, just press RETURN. You will then
be asked for your username in every future session.

},

proxy_pass => qq{

Your password for the authenticating proxy can also be stored
permanently on disk. If this violates your security policy, just press
RETURN. You will then be asked for the password in every future
session.

},

urls_intro => qq{

Now we need to know where your favorite CPAN sites are located. Push
a few sites onto the array (just in case the first on the array won\'t
work). If you are mirroring CPAN to your local workstation, specify a
file: URL.

First, pick a nearby continent and country by typing in the number(s)
in front of the item(s) you want to select. You can pick several of
each, separated by spaces. Then, you will be presented with a list of
URLs of CPAN mirrors in the countries you selected, along with
previously selected URLs. Select some of those URLs, or just keep the
old list. Finally, you will be prompted for any extra URLs -- file:,
ftp:, or http: -- that host a CPAN mirror.

},

password_warn => qq{

Warning: Term::ReadKey seems not to be available, your password will
be echoed to the terminal!

},

              );

die "Coding error in \@@prompts declaration.  Odd number of elements, above"
    if (@@prompts % 2);

%prompts = @@prompts;

if (scalar(keys %prompts) != scalar(@@prompts)/2) {
    my %already;
    for my $item (0..$#prompts) {
        next if $item % 2;
        die "$prompts[$item] is duplicated\n" if $already{$prompts[$item]}++;
    }
}

local *FH;
my $pmfile = __FILE__;
open FH, $pmfile or die "Could not open '$pmfile': $!";
local $/ = "";
my @@podpara;
while (<FH>) {
    next if 1 .. /^=over/;
    chomp;
    push @@podpara, $_;
    last if /^=back/;
a717 15
pop @@podpara;
while (@@podpara) {
    warn "Alert: cannot parse my own manpage for init dialog" unless $podpara[0] =~ s/^=item\s+//;
    my $name = shift @@podpara;
    my @@para;
    while (@@podpara && $podpara[0] !~ /^=item/) {
        push @@para, shift @@podpara;
    }
    $prompts{$name} = pop @@para;
    if (@@para) {
        $prompts{$name . "_intro"} = join "", map { "$_\n\n" } @@para;
    }
}

} # EOBEGIN
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d22 1
a22 1
$VERSION = "5.53";
a44 2
my @@podpara = split /\n\n/, <<'=back';

a162 13
=item connect_to_internet_ok

If you have never defined your own C<urllist> in your configuration
then C<CPAN.pm> will be hesitant to use the built in default sites for
downloading. It will ask you once per session if a connection to the
internet is OK and only if you say yes, it will try to connect. But to
avoid this question, you can choose your favorite download sites once
and get away with it. Or, if you have no favorite download sites
answer yes to the following question.

If no urllist has been chosen yet, would you prefer CPAN.pm to connect
to the built-in default sites without asking? (yes/no)?

a167 14
=item ftpstats_period

Statistics about downloads are truncated by size and period
simultaneously.

How many days shall we keep statistics about downloads?

=item ftpstats_size

Statistics about downloads are truncated by size and period
simultaneously.

How many items shall we keep in the statistics about downloads?

a181 8
=item halt_on_failure

Normaly, CPAN.pm continues processing the full list of targets and
dependencies, even if one of them fails.  However, you can specify 
that CPAN should halt after the first failure. 

Do you want to halt on failure (yes/no)?

d247 1
a247 1
any parameters (e.g. PREFIX, UNINST or the like) you want to
a477 20
=item perl5lib_verbosity

When CPAN.pm extends @@INC via PERL5LIB, it prints a list of
directories added (or a summary of how many directories are
added).  Choose 'v' to get this message, 'none' to suppress it.

Verbosity level for PERL5LIB changes (none or v)?

=item trust_test_report_history

When a distribution has already been tested by CPAN::Reporter on
this machine, CPAN can skip the test phase and just rely on the
test report history instead.

Note that this will not apply to distributions that failed tests
because of missing dependencies.  Also, tests can be run
regardless of the history using "force".

Do you want to rely on the test report history (yes/no)?

d488 3
a490 4
Both YAML.pm and YAML::Syck are capable of deserialising code. As this
requires a string eval, which might be a security risk, you can use
this option to enable or disable the deserialisation of code via
CPAN::DeferredCode. (Note: This does not work under perl 5.6)
d496 5
a500 6
At the time of this writing (2009-03) there are three YAML
implementations working: YAML, YAML::Syck, and YAML::XS. The latter
two are faster but need a C compiler installed on your system. There
may be more alternative YAML conforming modules. When I tried two
other players, YAML::Tiny and YAML::Perl, they seemed not powerful
enough to work with CPAN.pm. This may have changed in the meantime.
a514 126
{

    my @@prompts = (

manual_config => qq[

CPAN is the world-wide archive of perl resources. It consists of about
300 sites that all replicate the same contents around the globe. Many
countries have at least one CPAN site already. The resources found on
CPAN are easily accessible with the CPAN.pm module. If you want to use
CPAN.pm, lots of things have to be configured. Fortunately, most of
them can be determined automatically. If you prefer the automatic
configuration, answer 'yes' below.

If you prefer to enter a dialog instead, you can answer 'no' to this
question and I'll let you configure in small steps one thing after the
other. (Note: you can revisit this dialog anytime later by typing 'o
conf init' at the cpan prompt.)
],

config_intro => qq{

The following questions are intended to help you with the
configuration. The CPAN module needs a directory of its own to cache
important index files and maybe keep a temporary mirror of CPAN files.
This may be a site-wide or a personal directory.

},

# cpan_home => qq{ },

cpan_home_where => qq{

First of all, I'd like to create this directory. Where?

},

external_progs => qq{

The CPAN module will need a few external programs to work properly.
Please correct me, if I guess the wrong path for a program. Don't
panic if you do not have some of them, just press ENTER for those. To
disable the use of a program, you can type a space followed by ENTER.

},

proxy_intro => qq{

If you're accessing the net via proxies, you can specify them in the
CPAN configuration or via environment variables. The variable in
the \$CPAN::Config takes precedence.

},

proxy_user => qq{

If your proxy is an authenticating proxy, you can store your username
permanently. If you do not want that, just press RETURN. You will then
be asked for your username in every future session.

},

proxy_pass => qq{

Your password for the authenticating proxy can also be stored
permanently on disk. If this violates your security policy, just press
RETURN. You will then be asked for the password in every future
session.

},

urls_intro => qq{

Now we need to know where your favorite CPAN sites are located. Push
a few sites onto the array (just in case the first on the array won\'t
work). If you are mirroring CPAN to your local workstation, specify a
file: URL.

First, pick a nearby continent and country by typing in the number(s)
in front of the item(s) you want to select. You can pick several of
each, separated by spaces. Then, you will be presented with a list of
URLs of CPAN mirrors in the countries you selected, along with
previously selected URLs. Select some of those URLs, or just keep the
old list. Finally, you will be prompted for any extra URLs -- file:,
ftp:, or http: -- that host a CPAN mirror.

},

password_warn => qq{

Warning: Term::ReadKey seems not to be available, your password will
be echoed to the terminal!

},

              );

    die "Coding error in \@@prompts declaration.  Odd number of elements, above"
        if (@@prompts % 2);

    %prompts = @@prompts;

    if (scalar(keys %prompts) != scalar(@@prompts)/2) {
        my %already;
        for my $item (0..$#prompts) {
            next if $item % 2;
            die "$prompts[$item] is duplicated\n" if $already{$prompts[$item]}++;
        }
    }

    shift @@podpara;
    while (@@podpara) {
        warn "Alert: cannot parse my own manpage for init dialog" unless $podpara[0] =~ s/^=item\s+//;
        my $name = shift @@podpara;
        my @@para;
        while (@@podpara && $podpara[0] !~ /^=item/) {
            push @@para, shift @@podpara;
        }
        $prompts{$name} = pop @@para;
        if (@@para) {
            $prompts{$name . "_intro"} = join "", map { "$_\n\n" } @@para;
        }
    }

}

d559 1
a559 1
    my($ans,$default); # why so half global?
a588 1
            $CPAN::Config->{connect_to_internet_ok} ||= 1;
d632 81
a712 1
        init_cpan_home($matcher);
d714 6
a719 13
        my_dflt_prompt("keep_source_where",
                       File::Spec->catdir($CPAN::Config->{cpan_home},"sources"),
                       $matcher,
                      );
        my_dflt_prompt("build_dir",
                       File::Spec->catdir($CPAN::Config->{cpan_home},"build"),
                       $matcher
                      );
        my_yn_prompt(build_dir_reuse => 0, $matcher);
        my_dflt_prompt("prefs_dir",
                       File::Spec->catdir($CPAN::Config->{cpan_home},"prefs"),
                       $matcher
                      );
a730 1
    my_dflt_prompt(build_cache => 100, $matcher);
d732 12
a743 2
    my_dflt_prompt(index_expire => 1, $matcher);
    my_prompt_loop(scan_cache => 'atstart', $matcher, 'atstart|never');
d756 9
a764 4
    my_prompt_loop(prerequisites_policy => 'ask', $matcher,
                   'follow|ask|ignore');
    my_prompt_loop(build_requires_install_policy => 'ask/yes', $matcher,
                   'yes|no|ask/yes|ask/no');
d769 3
a771 1
    my_yn_prompt(check_sigs => 0, $matcher);
a788 2
    my_yn_prompt(trust_test_report_history => 0, $matcher);

d804 3
a806 1
    my_yn_prompt(yaml_load_code => 0, $matcher);
d811 11
d823 2
a824 1
    _init_external_progs($matcher,\@@path);
d826 68
a893 1
    {
d901 1
a901 1
    {
d922 10
a931 6
    my_prompt_loop(tar_verbosity => 'v', $matcher,
                   'none|v|vv');
    my_prompt_loop(load_module_verbosity => 'v', $matcher,
                   'none|v');
    my_prompt_loop(perl5lib_verbosity => 'v', $matcher,
                   'none|v');
d938 3
a940 1
    my_prompt_loop(prefer_installer => 'MB', $matcher, 'MB|EUMM|RAND');
a944 7
        if ( $CPAN::Config->{makepl_arg} =~ /LIBS=|INC=/ ) {
            $CPAN::Frontend->mywarn( 
                "Warning: Using LIBS or INC in makepl_arg will likely break distributions\n" . 
                "that specify their own LIBS or INC options in Makefile.PL.\n"
            );
        }

d961 1
a961 2
    if (exists $CPAN::HandleConfig::keys{mbuild_install_build_command}
        and $^O ne "MSWin32") {
a975 5
    #== halt_on_failure
    #
    my_yn_prompt(halt_on_failure => 0, $matcher);

    #
d1023 4
a1026 2
    my_prompt_loop(getcwd => 'cwd', $matcher,
                   'cwd|getcwd|fastcwd|backtickcwd');
d1080 3
a1082 1
    my_yn_prompt(term_is_latin => 1, $matcher);
a1120 4
    # remember, this is only triggered if no urllist is given, so 0 is
    # fair and protects the default site from being overloaded and
    # gives the user more chances to select his own urllist.
    my_yn_prompt("connect_to_internet_ok" => 0, $matcher);
a1130 6
        if ("ftpstats_size" =~ $matcher) {
            my_dflt_prompt(ftpstats_size => 99, $matcher);
        }
        if ("ftpstats_period" =~ $matcher) {
            my_dflt_prompt(ftpstats_period => 14, $matcher);
        }
d1134 1
a1134 1
                                 "your CPAN server(s) now!\n\n");
a1147 150
sub _init_external_progs {
    my($matcher,$PATH) = @@_;
    my @@external_progs = qw/bzip2 gzip tar unzip

                            make

                            curl lynx wget ncftpget ncftp ftp

                            gpg

                            patch applypatch
                            /;
    if (!$matcher or "@@external_progs" =~ /$matcher/) {
        $CPAN::Frontend->myprint($prompts{external_progs});

        my $old_warn = $^W;
        local $^W if $^O eq 'MacOS';
        local $^W = $old_warn;
        my $progname;
        for $progname (@@external_progs) {
            next if $matcher && $progname !~ /$matcher/;
            if ($^O eq 'MacOS') {
                $CPAN::Config->{$progname} = 'not_here';
                next;
            }

            my $progcall = $progname;
            unless ($matcher) {
                # we really don't need ncftp if we have ncftpget, but
                # if they chose this dialog via matcher, they shall have it
                next if $progname eq "ncftp" && $CPAN::Config->{ncftpget} gt " ";
            }
            my $path = $CPAN::Config->{$progname}
                || $Config::Config{$progname}
                    || "";
            if (File::Spec->file_name_is_absolute($path)) {
                # testing existence is not good enough, some have these exe
                # extensions

                # warn "Warning: configured $path does not exist\n" unless -e $path;
                # $path = "";
            } elsif ($path =~ /^\s+$/) {
                # preserve disabled programs
            } else {
                $path = '';
            }
            unless ($path) {
                # e.g. make -> nmake
                $progcall = $Config::Config{$progname} if $Config::Config{$progname};
            }

            $path ||= find_exe($progcall,$PATH);
            unless ($path) { # not -e $path, because find_exe already checked that
                local $"=";";
                $CPAN::Frontend->mywarn("Warning: $progcall not found in PATH[@@$PATH]\n");
                if ($progname eq "make") {
                    $CPAN::Frontend->mywarn("ALERT: 'make' is an essential tool for ".
                                            "building perl Modules. Please make sure you ".
                                            "have 'make' (or some equivalent) ".
                                            "working.\n"
                                           );
                    if ($^O eq "MSWin32") {
                        $CPAN::Frontend->mywarn("
Windows users may want to follow this procedure when back in the CPAN shell:

    look YVES/scripts/alien_nmake.pl
    perl alien_nmake.pl

This will install nmake on your system which can be used as a 'make'
substitute. You can then revisit this dialog with

    o conf init make

");
                    }
                }
            }
            $prompts{$progname} = "Where is your $progname program?";
            my_dflt_prompt($progname,$path,$matcher);
        }
    }
}

sub init_cpan_home {
    my($matcher) = @@_;
    if (!$matcher or 'cpan_home' =~ /$matcher/) {
        my $cpan_home = $CPAN::Config->{cpan_home}
            || File::Spec->catdir(CPAN::HandleConfig::home(), ".cpan");

        if (-d $cpan_home) {
            $CPAN::Frontend->myprint(qq{

I see you already have a  directory
    $cpan_home
Shall we use it as the general CPAN build and cache directory?

});
        } else {
            # no cpan-home, must prompt and get one
            $CPAN::Frontend->myprint($prompts{cpan_home_where});
        }

        my $default = $cpan_home;
        my $loop = 0;
        my($last_ans,$ans);
        $CPAN::Frontend->myprint(" <cpan_home>\n");
    PROMPT: while ($ans = prompt("CPAN build and cache directory?",$default)) {
            print "\n";
            if (File::Spec->file_name_is_absolute($ans)) {
                my @@cpan_home = split /[\/\\]/, $ans;
            DIR: for my $dir (@@cpan_home) {
                    if ($dir =~ /^~/ and (!$last_ans or $ans ne $last_ans)) {
                        $CPAN::Frontend
                            ->mywarn("Warning: a tilde in the path will be ".
                                     "taken as a literal tilde. Please ".
                                     "confirm again if you want to keep it\n");
                        $last_ans = $default = $ans;
                        next PROMPT;
                    }
                }
            } else {
                require Cwd;
                my $cwd = Cwd::cwd();
                my $absans = File::Spec->catdir($cwd,$ans);
                $CPAN::Frontend->mywarn("The path '$ans' is not an ".
                                        "absolute path. Please specify ".
                                        "an absolute path\n");
                $default = $absans;
                next PROMPT;
            }
            eval { File::Path::mkpath($ans); }; # dies if it can't
            if ($@@) {
                $CPAN::Frontend->mywarn("Couldn't create directory $ans.\n".
                                        "Please retry.\n");
                next PROMPT;
            }
            if (-d $ans && -w _) {
                last PROMPT;
            } else {
                $CPAN::Frontend->mywarn("Couldn't find directory $ans\n".
                                        "or directory is not writable. Please retry.\n");
                if (++$loop > 5) {
                    $CPAN::Frontend->mydie("Giving up");
                }
            }
        }
        $CPAN::Config->{cpan_home} = $ans;
    }
}

d1152 1
d1189 1
a1204 1
    my $use_mby;
a1207 1
        $use_mby = 1;
d1211 1
a1214 1
        $use_mby = 1;
d1218 3
a1220 3
I'd use that as a database of CPAN sites. If that is OK for you,
please answer 'y', but if you want me to get a new database from the
internet now, please answer 'n' to the following question.
d1224 1
a1224 5
        if ($ans =~ /^y/i) {
            $CPAN::Config->{connect_to_internet_ok} = 1;
        } else {
            $overwrite_local = 1;
        }
d1226 16
a1241 44
    local $urllist = $CPAN::Config->{urllist};
    my $better_mby;
 LOOP: while () { # multiple errors possible
        if ($use_mby
            or (defined $CPAN::Config->{connect_to_internet_ok}
                and $CPAN::Config->{connect_to_internet_ok})){
            if ($overwrite_local) {
                $CPAN::Frontend->myprint(qq{Trying to overwrite $mby\n});
                $better_mby = CPAN::FTP->localize($m,$mby,3);
                $overwrite_local = 0;
                $use_mby=1 if $mby;
            } elsif ( ! -f $mby ) {
                $CPAN::Frontend->myprint(qq{You have no $mby\n  I'm trying to fetch one\n});
                $better_mby = CPAN::FTP->localize($m,$mby,3);
                $use_mby=1 if $mby;
            } elsif ( -M $mby > 60 ) {
                $CPAN::Frontend->myprint(qq{Your $mby is older than 60 days,\n  I'm trying }.
                                         qq{to fetch a new one\n});
                $better_mby = CPAN::FTP->localize($m,$mby,3);
                $use_mby=1 if $mby;
            } elsif (-s $mby == 0) {
                $CPAN::Frontend->myprint(qq{You have an empty $mby,\n  I'm trying to fetch a better one\n});
                $better_mby = CPAN::FTP->localize($m,$mby,3);
                $use_mby=1 if $mby;
            } else {
                last LOOP;
            }
            if ($better_mby) {
                $mby = $better_mby;
            }
        } elsif (not @@{$urllist||[]}
                 and (not defined $CPAN::Config->{connect_to_internet_ok}
                      or not $CPAN::Config->{connect_to_internet_ok})) {
            $CPAN::Frontend->myprint(qq{CPAN needs access to at least one CPAN mirror.

As you did not allow me to connect to the internet you need to supply
a valid CPAN URL now.\n\n});

            my @@default = map {"file://$_"} grep {-e} "/home/ftp/pub/CPAN", "/home/ftp/pub/PAUSE";
            my $ans = prompt("Please enter the URL of your CPAN mirror",shift @@default);
            if ($ans) {
                push @@$urllist, $ans;
                next LOOP;
            }
d1243 1
a1243 1
            last LOOP;
d1246 2
a1247 10
    if ($use_mby){
        read_mirrored_by($mby);
    } else {
        if (not defined $CPAN::Config->{connect_to_internet_ok}
            or not $CPAN::Config->{connect_to_internet_ok}) {
            $CPAN::Frontend->myprint("Configuration does not allow connecting to the internet.\n");
        }
        $CPAN::Frontend->myprint("Current set of CPAN URLs:\n");
        map { $CPAN::Frontend->myprint("  $_\n") } @@$urllist;
    }
d1292 1
a1292 4
        if (0 == @@nums) {
            # cannot allow nothing because nothing means paging!
            # return;
        } elsif (grep (/\D/ || $_ < 1 || $_ > $i, @@nums)) {
d1305 1
a1305 4
        unless (@@nums){
            $CPAN::Frontend->mysleep(0.1); # prevent hot spinning process on the next bug
            next SELECTION;
        }
a1379 3
    } else {
        # cannot allow nothing because nothing means paging!
        # push @@$offer_cont, "(none of the above)";
d1386 1
a1386 2
    # cannot allow nothing because nothing means paging!
    # return unless @@cont;
d1429 1
a1429 5
    if (@@urls) {
        $urllist = \@@urls;
    } else {
        push @@$urllist, @@urls;
    }
d1472 1
a1472 2
    @@$urllist = CPAN::_uniq(@@$urllist, @@urls);
    $CPAN::Config->{urllist} = $urllist;
d1474 2
a1475 2
    $CPAN::Frontend->myprint("New urllist\n");
    for ( @@$urllist ) { $CPAN::Frontend->myprint("  $_\n") };
d1501 134
@


