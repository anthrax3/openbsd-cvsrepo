head	1.5;
access;
symbols
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.2.0.20
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.18
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.2.0.16
	OPENBSD_4_2_BASE:1.2
	OPENBSD_4_1:1.2.0.14
	OPENBSD_4_1_BASE:1.2
	OPENBSD_4_0:1.2.0.12
	OPENBSD_4_0_BASE:1.2
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.2.0.10
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.8
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.6
	OPENBSD_3_7_BASE:1.2
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.2.0.4
	OPENBSD_3_6_BASE:1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.2.0.2
	OPENBSD_3_5_BASE:1.2
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.5
date	2010.09.24.14.59.35;	author millert;	state dead;
branches;
next	1.4;

1.4
date	2009.10.12.18.24.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2008.09.29.17.36.10;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2003.12.03.03.02.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2003.12.03.02.44.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.44.01;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.08.09.17.46.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.17.14;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.32;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.57;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!/usr/bin/perl
# $Id: cpan,v 1.4 2009/10/12 18:24:39 millert Exp $
use strict;

=head1 NAME

cpan - easily interact with CPAN from the command line

=head1 SYNOPSIS

	# with arguments and no switches, installs specified modules
	cpan module_name [ module_name ... ]

	# with switches, installs modules with extra behavior
	cpan [-cfimt] module_name [ module_name ... ]

	# without arguments, starts CPAN.pm shell
	cpan

	# without arguments, but some switches
	cpan [-ahrvACDLO]

=head1 DESCRIPTION

This script provides a command interface (not a shell) to CPAN. At the
moment it uses CPAN.pm to do the work, but it is not a one-shot command
runner for CPAN.pm.

=head2 Meta Options

These options are mutually exclusive, and the script processes them in
this order: [hvCAar].  Once the script finds one, it ignores the others,
and then exits after it finishes the task.  The script ignores any other
command line options.

=over 4

=item -a

Creates the CPAN.pm autobundle with CPAN::Shell->autobundle.

=item -A module [ module ... ]

Shows the primary maintainers for the specified modules

=item -C module [ module ... ]

Show the C<Changes> files for the specified modules

=item -D module [ module ... ]

Show the module details. This prints one line for each out-of-date module
(meaning, modules locally installed but have newer versions on CPAN).
Each line has three columns: module name, local version, and CPAN
version.

=item -L author [ author ... ]

List the modules by the specified authors.

=item -h

Prints a help message.

=item -O

Show the out-of-date modules.

=item -r

Recompiles dynamically loaded modules with CPAN::Shell->recompile.

=item -v

Print the script version and CPAN.pm version.

=back

=head2 Module options

These options are mutually exclusive, and the script processes them in
alphabetical order. It only processes the first one it finds.

=over 4

=item c

Runs a `make clean` in the specified module's directories.

=item f

Forces the specified action, when it normally would have failed.

=item i

Installed the specified modules.

=item m

Makes the specified modules.

=item t

Runs a `make test` on the specified modules.

=back

=head2 Examples

	# print a help message
	cpan -h

	# print the version numbers
	cpan -v

	# create an autobundle
	cpan -a

	# recompile modules
	cpan -r

	# install modules ( sole -i is optional )
	cpan -i Netscape::Booksmarks Business::ISBN

	# force install modules ( must use -i )
	cpan -fi CGI::Minimal URI

=head1 TO DO


=head1 BUGS

* none noted

=head1 SEE ALSO

Most behaviour, including environment variables and configuration,
comes directly from CPAN.pm.

=head1 SOURCE AVAILABILITY

This source is part of a SourceForge project which always has the
latest sources in CVS, as well as all of the previous releases.

	http://sourceforge.net/projects/brian-d-foy/

If, for some reason, I disappear from the world, one of the other
members of the project can shepherd this module appropriately.

=head1 CREDITS

Japheth Cleaver added the bits to allow a forced install (-f).

Jim Brandt suggest and provided the initial implementation for the
up-to-date and Changes features.

Adam Kennedy pointed out that exit() causes problems on Windows
where this script ends up with a .bat extension

=head1 AUTHOR

brian d foy, C<< <bdfoy@@cpan.org> >>

=head1 COPYRIGHT

Copyright (c) 2001-2006, brian d foy, All Rights Reserved.

You may redistribute this under the same terms as Perl itself.

=cut

use CPAN ();
use Getopt::Std;

my $VERSION =
	sprintf "%d.%d", q$Revision: 1.4 $ =~ m/ (\d+) \. (\d+) /xg;

if( $ARGV[0] eq 'install' )
	{
	my @@args = @@ARGV;
	shift @@args;
	
	die <<"HERE";
It looks like you specified 'install' as an argument to cpan(1). This
script is not the CPAN.pm prompt and doesn't understand the same commands.
In fact, doesn't require the extra typing. You probably just want to
list the modules you want to install:

	cpan @@args
	
See the documentation for more details on using this script.
HERE
	}
	
if( 0 == @@ARGV ) { CPAN::shell(); exit 0 }

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# set up the order of options that we layer over CPAN::Shell
my @@META_OPTIONS = qw( h v C A D O L a r );

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# map switches to method names in CPAN::Shell
my $Default = 'default';

my %CPAN_METHODS = (
	$Default => 'install',
	'c'      => 'clean',
	'f'      => 'force',
	'i'      => 'install',
	'm'      => 'make',
	't'      => 'test',
	);
my @@CPAN_OPTIONS = grep { $_ ne $Default } sort keys %CPAN_METHODS;

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# map switches to the subroutines in this script, along with other information.
# use this stuff instead of hard-coded indices and values
my %Method_table = (
# key => [ sub ref, takes args?, exit value, description ]
	h => [ \&_print_help,        0, 0, 'Printing help'          ],
	v => [ \&_print_version,     0, 0, 'Printing version'       ],
	C => [ \&_show_Changes,      1, 0, 'Showing Changes file'   ],
	A => [ \&_show_Author,       1, 0, 'Showing Author'         ],
	D => [ \&_show_Details,      1, 0, 'Showing Details'        ],
	O => [ \&_show_out_of_date,  0, 0, 'Showing Out of date'    ],
	L => [ \&_show_author_mods,  1, 0, 'Showing author mods'    ],
	a => [ \&_create_autobundle, 0, 0, 'Creating autobundle'    ],
	r => [ \&_recompiling,       0, 0, 'Recompiling'            ],

	c => [ \&_default,           1, 0, 'Running `make clean`'   ],
	f => [ \&_default,           1, 0, 'Installing with force'  ],
	i => [ \&_default,           1, 0, 'Running `make install`' ],
   'm' => [ \&_default,          1, 0, 'Running `make`'         ],
	t => [ \&_default,           1, 0, 'Running `make test`'    ],

	);

my %Method_table_index = (
	code        => 0,
	takes_args  => 1,
	exit_value  => 2,
	description => 3,
	);
	
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# finally, do some argument processing
my @@option_order = ( @@META_OPTIONS, @@CPAN_OPTIONS );

my %options;
Getopt::Std::getopts(
	join( '', @@option_order ), \%options );

my $option_count = grep { $options{$_} } @@option_order;
$option_count -= $options{'f'}; # don't count force

# if there are no options, set -i (this line fixes RT ticket 16915)
$options{i}++ unless $option_count;

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# try each of the possible switches until we find one to handle
# print an error message if there are too many switches
# print an error message if there are arguments when there shouldn't be any
foreach my $option ( @@option_order )
	{
	next unless $options{$option};
	die unless 
		ref $Method_table{$option}[ $Method_table_index{code} ] eq ref sub {};
	
	print "$Method_table{$option}[ $Method_table_index{description} ] " .
		"-- ignoring other opitions\n" if $option_count > 1;
	print "$Method_table{$option}[ $Method_table_index{description} ] " .
		"-- ignoring other arguments\n" 
		if( @@ARGV && ! $Method_table{$option}[ $Method_table_index{takes_args} ] );
		
	$Method_table{$option}[ $Method_table_index{code} ]->( \@@ARGV );
	
	last;
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

sub _default
	{
	my $args = shift;
	
	my $switch = '';

	# choose the option that we're going to use
	# we'll deal with 'f' (force) later, so skip it
	foreach my $option ( @@CPAN_OPTIONS )
		{
		next if $option eq 'f';
		next unless $options{$option};
		$switch = $option;
		last;
		}

	# 1. with no switches, but arguments, use the default switch (install)
	# 2. with no switches and no args, start the shell
	# 3. With a switch but no args, die! These switches need arguments.
	   if( not $switch and     @@$args ) { $switch = $Default;     }
	elsif( not $switch and not @@$args ) { CPAN::shell(); return   }
	elsif(     $switch and not @@$args )
		{ die "Nothing to $CPAN_METHODS{$switch}!\n"; }

	# Get and cheeck the method from CPAN::Shell
	my $method = $CPAN_METHODS{$switch};
	die "CPAN.pm cannot $method!\n" unless CPAN::Shell->can( $method );

	# call the CPAN::Shell method, with force if specified
	foreach my $arg ( @@$args )
		{
		if( $options{f} ) { CPAN::Shell->force( $method, $arg ) }
		else              { CPAN::Shell->$method( $arg )        }
		}
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
sub _print_help
	{
	print STDERR "Use perldoc to read the documentation\n";
	exec "perldoc $0";
	}
	
sub _print_version
	{
	print STDERR "$0 script version $VERSION, CPAN.pm version " . 
		CPAN->VERSION . "\n";
	}
	
sub _create_autobundle
	{
	print "Creating autobundle in ", $CPAN::Config->{cpan_home},
		"/Bundle\n";

	CPAN::Shell->autobundle;
	}

sub _recompiling
	{
	print "Recompiling dynamically-loaded extensions\n";

	CPAN::Shell->recompile;
	}

sub _show_Changes
	{
	my $args = shift;
	
	foreach my $arg ( @@$args )
		{
		print "Checking $arg\n";
		my $module = CPAN::Shell->expand( "Module", $arg );
		
		next unless $module->inst_file;
		#next if $module->uptodate;
	
		( my $id = $module->id() ) =~ s/::/\-/;
	
		my $url = "http://search.cpan.org/~" . lc( $module->userid ) . "/" .
			$id . "-" . $module->cpan_version() . "/";
	
		#print "URL: $url\n";
		_get_changes_file($url);
		}
	}	
	
sub _get_changes_file
	{
	die "Reading Changes files requires LWP::Simple and URI\n"
		unless eval { require LWP::Simple; require URI; };
	
    my $url = shift;

    my $content = LWP::Simple::get( $url );
    print "Got $url ...\n" if defined $content;
	#print $content;
	
	my( $change_link ) = $content =~ m|<a href="(.*?)">Changes</a>|gi;
	
	my $changes_url = URI->new_abs( $change_link, $url );
 	#print "change link is: $changes_url\n";
	my $changes =  LWP::Simple::get( $changes_url );
	#print "change text is: " . $change_link->text() . "\n";
	print $changes;
	}
	
sub _show_Author
	{
	my $args = shift;
	
	foreach my $arg ( @@$args )
		{
		my $module = CPAN::Shell->expand( "Module", $arg );
		my $author = CPAN::Shell->expand( "Author", $module->userid );
	
		next unless $module->userid;
	
		printf "%-25s %-8s %-25s %s\n", 
			$arg, $module->userid, $author->email, $author->fullname;
		}
	}	

sub _show_Details
	{
	my $args = shift;
	
	foreach my $arg ( @@$args )
		{
		my $module = CPAN::Shell->expand( "Module", $arg );
		my $author = CPAN::Shell->expand( "Author", $module->userid );
	
		next unless $module->userid;
	
		print "$arg\n", "-" x 73, "\n\t";
		print join "\n\t",
			$module->description ? $module->description : "(no description)",
			$module->cpan_file,
			$module->inst_file,
			'Installed: ' . $module->inst_version,
			'CPAN:      ' . $module->cpan_version . '  ' .
				($module->uptodate ? "" : "Not ") . "up to date",
			$author->fullname . " (" . $module->userid . ")",
			$author->email;
		print "\n\n";
		
		}
	}	

sub _show_out_of_date
	{
	my @@modules = CPAN::Shell->expand( "Module", "/./" );
		
	printf "%-40s  %6s  %6s\n", "Module Name", "Local", "CPAN";
	print "-" x 73, "\n";
	
	foreach my $module ( @@modules )
		{
		next unless $module->inst_file;
		next if $module->uptodate;
		printf "%-40s  %.4f  %.4f\n",
			$module->id, 
			$module->inst_version ? $module->inst_version : '', 
			$module->cpan_version;
		}

	}

sub _show_author_mods
	{
	my $args = shift;

	my %hash = map { lc $_, 1 } @@$args;
	
	my @@modules = CPAN::Shell->expand( "Module", "/./" );
	
	foreach my $module ( @@modules )
		{
		next unless exists $hash{ lc $module->userid };
		print $module->id, "\n";
		}
	
	}
	
1;
@


1.4
log
@Merge in perl 5.10.1
@
text
@d2 1
a2 1
# $Id: cpan,v 1.9 2006/11/01 21:49:31 comdog Exp $
d176 1
a176 1
	sprintf "%d.%d", q$Revision: 1.9 $ =~ m/ (\d+) \. (\d+) /xg;
@


1.3
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d228 1
a228 1
	r => [ \&_recompile,         0, 0, 'Recompiling'            ],
d341 1
a341 1
sub _recompile
@


1.2
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d2 1
a2 1
# $Id: cpan,v 1.3 2002/08/30 08:55:15 k Exp $
d11 1
a11 1
	# with arguments, installs specified modules
d13 1
a13 1
	
d15 3
a17 3
	cpan [-cimt] module_name [ module_name ... ]
	
	# without arguments, starts CPAN shell
d19 1
a19 1
	
d21 1
a21 1
	cpan [-ahrv]
d25 3
a27 1
This script provides a command interface (not a shell) to CPAN.pm.
d31 4
a34 4
These options are mutually exclusive, and the script processes
them in this order: [ahvr].  Once the script finds one, it ignores
the others, and then exits after it finishes the task.  The script
ignores any other command line options.
d40 20
a59 1
Creates the CPAN.pm autobundle with CPAN::Shell->autobundle.  
d65 4
d81 2
a82 2
These options are mutually exclusive, and the script processes
them in alphabetical order. 
d90 4
d112 1
a112 1
	
d115 1
a115 1
	
d118 1
a118 1
	
d120 3
a122 3
	cpan -r 
	
	# install modules
d125 3
a129 2
* add options for other CPAN::Shell functions
autobundle, clean, make, recompile, test
d140 20
d162 7
a168 1
brian d foy <bdfoy@@cpan.org>
d175 25
a199 2
my $VERSION = 
	sprintf "%d.%02d", q$Revision: 1.3 $ =~ m/ (\d+) \. (\d+) /xg;
d201 2
a204 2
my $META_OPTIONS = 'ahvr';

d208 1
d213 24
d238 10
a247 1
my @@cpan_options = grep { $_ ne $Default } sort keys %CPAN_METHODS;
a248 1
my $arg_count = @@ARGV;
d250 2
d253 23
a275 2
Getopt::Std::getopts( 
	join( '', @@cpan_options, $META_OPTIONS ), \%options );
d277 8
a284 1
if( $options{h} )
d286 3
a288 2
	print STDERR "Printing help message -- ignoring other arguments\n"
		if $arg_count > 1;
d290 33
d324 1
a324 1
	exit 0;
d326 2
a327 1
elsif( $options{v} )
d329 3
a331 1
	print STDERR "Printing version message -- ignoring other arguments\n"
d333 4
a336 1
		if $arg_count > 1;
d338 1
a338 4
	my $CPAN_VERSION = CPAN->VERSION;
	print STDERR "cpan script version $VERSION\n" .
		"CPAN.pm version $CPAN_VERSION\n";
	exit 0;
d340 2
a341 1
elsif( $options{a} )
d343 1
a343 4
	print "Creating autobundle in ", $CPAN::Config->{cpan_home}, 
		"/Bundle\n";
	print STDERR "Creating autobundle -- ignoring other arguments\n"
		if $arg_count > 1;
d345 1
a345 2
	CPAN::Shell->autobundle;
	exit 0;
d347 2
a348 1
elsif( $options{r} )
d350 6
a355 2
	print STDERR "Creating autobundle -- ignoring other arguments\n"
		if $arg_count > 1;
d357 31
a387 1
	CPAN::Shell->recompile;
d389 18
a406 1
else
d408 1
a408 1
	my $switch = '';
d410 1
a410 1
	foreach my $option ( @@cpan_options )
d412 17
a428 3
		next unless $options{$option};
		$switch = $option;
		last;
d430 8
d439 15
a453 4
	   if( not $switch and     @@ARGV ) { $switch = $Default;     }
	elsif( not $switch and not @@ARGV ) { CPAN::shell(); exit 0;  }	
	elsif(     $switch and not @@ARGV ) 
		{ die "Nothing to $CPAN_METHODS{$switch}!\n"; }
d455 3
a457 2
	my $method = $CPAN_METHODS{$switch};
	die "CPAN.pm cannot $method!\n" unless CPAN::Shell->can( $method );
d459 1
a459 1
	foreach my $arg ( @@ARGV )
d461 2
a462 1
		CPAN::Shell->$method( $arg );
d464 1
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@Import of stock perl 5.8.5
@
text
@d2 1
a2 1
# $Id: cpan,v 1.2 2003/12/03 03:02:37 millert Exp $
d120 1
a120 1
	sprintf "%d.%02d", q$Revision: 1.2 $ =~ m/ (\d+) \. (\d+) /xg;
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@d2 1
a2 1
# $Id: cpan,v 1.3 2002/08/30 08:55:15 k Exp $
d120 1
a120 1
	sprintf "%d.%02d", q$Revision: 1.3 $ =~ m/ (\d+) \. (\d+) /xg;
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d2 1
a2 1
# $Id: cpan,v 1.9 2006/11/01 21:49:31 comdog Exp $
d11 1
a11 1
	# with arguments and no switches, installs specified modules
d13 1
a13 1

d15 3
a17 3
	cpan [-cfimt] module_name [ module_name ... ]

	# without arguments, starts CPAN.pm shell
d19 1
a19 1

d21 1
a21 1
	cpan [-ahrvACDLO]
d25 1
a25 3
This script provides a command interface (not a shell) to CPAN. At the
moment it uses CPAN.pm to do the work, but it is not a one-shot command
runner for CPAN.pm.
d29 4
a32 4
These options are mutually exclusive, and the script processes them in
this order: [hvCAar].  Once the script finds one, it ignores the others,
and then exits after it finishes the task.  The script ignores any other
command line options.
d38 1
a38 20
Creates the CPAN.pm autobundle with CPAN::Shell->autobundle.

=item -A module [ module ... ]

Shows the primary maintainers for the specified modules

=item -C module [ module ... ]

Show the C<Changes> files for the specified modules

=item -D module [ module ... ]

Show the module details. This prints one line for each out-of-date module
(meaning, modules locally installed but have newer versions on CPAN).
Each line has three columns: module name, local version, and CPAN
version.

=item -L author [ author ... ]

List the modules by the specified authors.
a43 4
=item -O

Show the out-of-date modules.

d56 2
a57 2
These options are mutually exclusive, and the script processes them in
alphabetical order. It only processes the first one it finds.
a64 4
=item f

Forces the specified action, when it normally would have failed.

d83 1
a83 1

d86 1
a86 1

d89 1
a89 1

d91 3
a93 3
	cpan -r

	# install modules ( sole -i is optional )
a95 3
	# force install modules ( must use -i )
	cpan -fi CGI::Minimal URI

d98 2
a109 20
=head1 SOURCE AVAILABILITY

This source is part of a SourceForge project which always has the
latest sources in CVS, as well as all of the previous releases.

	http://sourceforge.net/projects/brian-d-foy/

If, for some reason, I disappear from the world, one of the other
members of the project can shepherd this module appropriately.

=head1 CREDITS

Japheth Cleaver added the bits to allow a forced install (-f).

Jim Brandt suggest and provided the initial implementation for the
up-to-date and Changes features.

Adam Kennedy pointed out that exit() causes problems on Windows
where this script ends up with a .bat extension

d112 1
a112 7
brian d foy, C<< <bdfoy@@cpan.org> >>

=head1 COPYRIGHT

Copyright (c) 2001-2006, brian d foy, All Rights Reserved.

You may redistribute this under the same terms as Perl itself.
d119 2
a120 2
my $VERSION =
	sprintf "%d.%d", q$Revision: 1.9 $ =~ m/ (\d+) \. (\d+) /xg;
d122 1
a122 22
if( $ARGV[0] eq 'install' )
	{
	my @@args = @@ARGV;
	shift @@args;
	
	die <<"HERE";
It looks like you specified 'install' as an argument to cpan(1). This
script is not the CPAN.pm prompt and doesn't understand the same commands.
In fact, doesn't require the extra typing. You probably just want to
list the modules you want to install:

	cpan @@args
	
See the documentation for more details on using this script.
HERE
	}
	
if( 0 == @@ARGV ) { CPAN::shell(); exit 0 }

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# set up the order of options that we layer over CPAN::Shell
my @@META_OPTIONS = qw( h v C A D O L a r );
d124 1
a124 3
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# map switches to method names in CPAN::Shell
my $Default = 'default';
a128 1
	'f'      => 'force',
a132 24
my @@CPAN_OPTIONS = grep { $_ ne $Default } sort keys %CPAN_METHODS;

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# map switches to the subroutines in this script, along with other information.
# use this stuff instead of hard-coded indices and values
my %Method_table = (
# key => [ sub ref, takes args?, exit value, description ]
	h => [ \&_print_help,        0, 0, 'Printing help'          ],
	v => [ \&_print_version,     0, 0, 'Printing version'       ],
	C => [ \&_show_Changes,      1, 0, 'Showing Changes file'   ],
	A => [ \&_show_Author,       1, 0, 'Showing Author'         ],
	D => [ \&_show_Details,      1, 0, 'Showing Details'        ],
	O => [ \&_show_out_of_date,  0, 0, 'Showing Out of date'    ],
	L => [ \&_show_author_mods,  1, 0, 'Showing author mods'    ],
	a => [ \&_create_autobundle, 0, 0, 'Creating autobundle'    ],
	r => [ \&_recompile,         0, 0, 'Recompiling'            ],

	c => [ \&_default,           1, 0, 'Running `make clean`'   ],
	f => [ \&_default,           1, 0, 'Installing with force'  ],
	i => [ \&_default,           1, 0, 'Running `make install`' ],
   'm' => [ \&_default,          1, 0, 'Running `make`'         ],
	t => [ \&_default,           1, 0, 'Running `make test`'    ],

	);
d134 1
a134 10
my %Method_table_index = (
	code        => 0,
	takes_args  => 1,
	exit_value  => 2,
	description => 3,
	);
	
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# finally, do some argument processing
my @@option_order = ( @@META_OPTIONS, @@CPAN_OPTIONS );
d136 1
a137 2
Getopt::Std::getopts(
	join( '', @@option_order ), \%options );
d139 2
a140 23
my $option_count = grep { $options{$_} } @@option_order;
$option_count -= $options{'f'}; # don't count force

# if there are no options, set -i (this line fixes RT ticket 16915)
$options{i}++ unless $option_count;

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# try each of the possible switches until we find one to handle
# print an error message if there are too many switches
# print an error message if there are arguments when there shouldn't be any
foreach my $option ( @@option_order )
	{
	next unless $options{$option};
	die unless 
		ref $Method_table{$option}[ $Method_table_index{code} ] eq ref sub {};
	
	print "$Method_table{$option}[ $Method_table_index{description} ] " .
		"-- ignoring other opitions\n" if $option_count > 1;
	print "$Method_table{$option}[ $Method_table_index{description} ] " .
		"-- ignoring other arguments\n" 
		if( @@ARGV && ! $Method_table{$option}[ $Method_table_index{takes_args} ] );
		
	$Method_table{$option}[ $Method_table_index{code} ]->( \@@ARGV );
d142 1
a142 8
	last;
	}

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
 # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 

sub _default
d144 2
a145 3
	my $args = shift;
	
	my $switch = '';
d147 2
a148 28
	# choose the option that we're going to use
	# we'll deal with 'f' (force) later, so skip it
	foreach my $option ( @@CPAN_OPTIONS )
		{
		next if $option eq 'f';
		next unless $options{$option};
		$switch = $option;
		last;
		}

	# 1. with no switches, but arguments, use the default switch (install)
	# 2. with no switches and no args, start the shell
	# 3. With a switch but no args, die! These switches need arguments.
	   if( not $switch and     @@$args ) { $switch = $Default;     }
	elsif( not $switch and not @@$args ) { CPAN::shell(); return   }
	elsif(     $switch and not @@$args )
		{ die "Nothing to $CPAN_METHODS{$switch}!\n"; }

	# Get and cheeck the method from CPAN::Shell
	my $method = $CPAN_METHODS{$switch};
	die "CPAN.pm cannot $method!\n" unless CPAN::Shell->can( $method );

	# call the CPAN::Shell method, with force if specified
	foreach my $arg ( @@$args )
		{
		if( $options{f} ) { CPAN::Shell->force( $method, $arg ) }
		else              { CPAN::Shell->$method( $arg )        }
		}
d150 1
a150 3

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # 
sub _print_help
d152 1
a152 3
	print STDERR "Use perldoc to read the documentation\n";
	exec "perldoc $0";
	}
d154 6
a159 4
sub _print_version
	{
	print STDERR "$0 script version $VERSION, CPAN.pm version " . 
		CPAN->VERSION . "\n";
d161 1
a161 2
	
sub _create_autobundle
d163 1
a163 1
	print "Creating autobundle in ", $CPAN::Config->{cpan_home},
d165 2
d169 1
d171 1
a171 2

sub _recompile
d173 3
a175 2
	print "Recompiling dynamically-loaded extensions\n";

d178 1
a178 2

sub _show_Changes
d180 1
a180 1
	my $args = shift;
d182 1
a182 1
	foreach my $arg ( @@$args )
d184 3
a186 13
		print "Checking $arg\n";
		my $module = CPAN::Shell->expand( "Module", $arg );
		
		next unless $module->inst_file;
		#next if $module->uptodate;
	
		( my $id = $module->id() ) =~ s/::/\-/;
	
		my $url = "http://search.cpan.org/~" . lc( $module->userid ) . "/" .
			$id . "-" . $module->cpan_version() . "/";
	
		#print "URL: $url\n";
		_get_changes_file($url);
a187 1
	}	
d189 4
a192 6
sub _get_changes_file
	{
	die "Reading Changes files requires LWP::Simple and URI\n"
		unless eval { require LWP::Simple; require URI; };
	
    my $url = shift;
d194 2
a195 23
    my $content = LWP::Simple::get( $url );
    print "Got $url ...\n" if defined $content;
	#print $content;
	
	my( $change_link ) = $content =~ m|<a href="(.*?)">Changes</a>|gi;
	
	my $changes_url = URI->new_abs( $change_link, $url );
 	#print "change link is: $changes_url\n";
	my $changes =  LWP::Simple::get( $changes_url );
	#print "change text is: " . $change_link->text() . "\n";
	print $changes;
	}
	
sub _show_Author
	{
	my $args = shift;
	
	foreach my $arg ( @@$args )
		{
		my $module = CPAN::Shell->expand( "Module", $arg );
		my $author = CPAN::Shell->expand( "Author", $module->userid );
	
		next unless $module->userid;
d197 1
a197 10
		printf "%-25s %-8s %-25s %s\n", 
			$arg, $module->userid, $author->email, $author->fullname;
		}
	}	

sub _show_Details
	{
	my $args = shift;
	
	foreach my $arg ( @@$args )
d199 1
a199 17
		my $module = CPAN::Shell->expand( "Module", $arg );
		my $author = CPAN::Shell->expand( "Author", $module->userid );
	
		next unless $module->userid;
	
		print "$arg\n", "-" x 73, "\n\t";
		print join "\n\t",
			$module->description ? $module->description : "(no description)",
			$module->cpan_file,
			$module->inst_file,
			'Installed: ' . $module->inst_version,
			'CPAN:      ' . $module->cpan_version . '  ' .
				($module->uptodate ? "" : "Not ") . "up to date",
			$author->fullname . " (" . $module->userid . ")",
			$author->email;
		print "\n\n";
		
a200 35
	}	

sub _show_out_of_date
	{
	my @@modules = CPAN::Shell->expand( "Module", "/./" );
		
	printf "%-40s  %6s  %6s\n", "Module Name", "Local", "CPAN";
	print "-" x 73, "\n";
	
	foreach my $module ( @@modules )
		{
		next unless $module->inst_file;
		next if $module->uptodate;
		printf "%-40s  %.4f  %.4f\n",
			$module->id, 
			$module->inst_version ? $module->inst_version : '', 
			$module->cpan_version;
		}

	}

sub _show_author_mods
	{
	my $args = shift;

	my %hash = map { lc $_, 1 } @@$args;
	
	my @@modules = CPAN::Shell->expand( "Module", "/./" );
	
	foreach my $module ( @@modules )
		{
		next unless exists $hash{ lc $module->userid };
		print $module->id, "\n";
		}
	
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d228 1
a228 1
	r => [ \&_recompiling,       0, 0, 'Recompiling'            ],
d341 1
a341 1
sub _recompiling
@


