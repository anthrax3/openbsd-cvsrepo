head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.4.0.16
	OPENBSD_6_2_BASE:1.1.1.4
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.1.1.4.0.14
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.12
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.6
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.8
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.4
	OPENBSD_5_6_BASE:1.1.1.4
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.24
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.20
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.3.0.18
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.16
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.14
	OPENBSD_5_0:1.1.1.3.0.12
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.10
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.20
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.00;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.31;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@package sort;

our $VERSION = '1.01';

# Currently the hints for pp_sort are stored in the global variable
# $sort::hints. An improvement would be to store them in $^H{SORT} and have
# this information available somewhere in the listop OP_SORT, to allow lexical
# scoping of this pragma. -- rgs 2002-04-30

our $hints	       = 0;

$sort::quicksort_bit   = 0x00000001;
$sort::mergesort_bit   = 0x00000002;
$sort::sort_bits       = 0x000000FF; # allow 256 different ones
$sort::stable_bit      = 0x00000100;

use strict;

sub import {
    shift;
    if (@@_ == 0) {
	require Carp;
	Carp::croak("sort pragma requires arguments");
    }
    local $_;
    no warnings 'uninitialized';	# bitops would warn
    while ($_ = shift(@@_)) {
	if (/^_q(?:uick)?sort$/) {
	    $hints &= ~$sort::sort_bits;
	    $hints |=  $sort::quicksort_bit;
	} elsif ($_ eq '_mergesort') {
	    $hints &= ~$sort::sort_bits;
	    $hints |=  $sort::mergesort_bit;
	} elsif ($_ eq 'stable') {
	    $hints |=  $sort::stable_bit;
	} else {
	    require Carp;
	    Carp::croak("sort: unknown subpragma '$_'");
	}
    }
}

sub current {
    my @@sort;
    if ($hints) {
	push @@sort, 'quicksort' if $hints & $sort::quicksort_bit;
	push @@sort, 'mergesort' if $hints & $sort::mergesort_bit;
	push @@sort, 'stable'    if $hints & $sort::stable_bit;
    }
    push @@sort, 'mergesort' unless @@sort;
    join(' ', @@sort);
}

1;
__END__

=head1 NAME

sort - perl pragma to control sort() behaviour

=head1 SYNOPSIS

    use sort 'stable';		# guarantee stability
    use sort '_quicksort';	# use a quicksort algorithm
    use sort '_mergesort';	# use a mergesort algorithm

    use sort '_qsort';		# alias for quicksort

    my $current = sort::current();	# identify prevailing algorithm

=head1 DESCRIPTION

With the sort pragma you can control the behaviour of the builtin
sort() function.

In Perl versions 5.6 and earlier the quicksort algorithm was used to
implement sort(), but in Perl 5.8 a mergesort algorithm was also made
available, mainly to guarantee worst case O(N log N) behaviour:
the worst case of quicksort is O(N**2).  In Perl 5.8 and later,
quicksort defends against quadratic behaviour by shuffling large
arrays before sorting.

A stable sort means that for records that compare equal, the original
input ordering is preserved.  Mergesort is stable, quicksort is not.
Stability will matter only if elements that compare equal can be
distinguished in some other way.  That means that simple numerical
and lexical sorts do not profit from stability, since equal elements
are indistinguishable.  However, with a comparison such as

   { substr($a, 0, 3) cmp substr($b, 0, 3) }

stability might matter because elements that compare equal on the
first 3 characters may be distinguished based on subsequent characters.
In Perl 5.8 and later, quicksort can be stabilized, but doing so will
add overhead, so it should only be done if it matters.

The best algorithm depends on many things.  On average, mergesort
does fewer comparisons than quicksort, so it may be better when
complicated comparison routines are used.  Mergesort also takes
advantage of pre-existing order, so it would be favored for using
sort to merge several sorted arrays.  On the other hand, quicksort
is often faster for small arrays, and on platforms with small memory
caches that are much faster than main memory.  You can force the
choice of algorithm with this pragma, but this feels heavy-handed,
so the subpragmas beginning with a C<_> may not persist beyond Perl 5.8.

=head1 CAVEATS

This pragma is not lexically scoped : its effect is global to the program
it appears in.  This may change in future versions.

=cut

@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.02';
a35 24
	} elsif ($_ eq 'defaults') {
	    $hints =   0;
	} else {
	    require Carp;
	    Carp::croak("sort: unknown subpragma '$_'");
	}
    }
}

sub unimport {
    shift;
    if (@@_ == 0) {
	require Carp;
	Carp::croak("sort pragma requires arguments");
    }
    local $_;
    no warnings 'uninitialized';	# bitops would warn
    while ($_ = shift(@@_)) {
	if (/^_q(?:uick)?sort$/) {
	    $hints &= ~$sort::sort_bits;
	} elsif ($_ eq '_mergesort') {
	    $hints &= ~$sort::sort_bits;
	} elsif ($_ eq 'stable') {
	    $hints &= ~$sort::stable_bit;
a65 2
    use sort 'defaults';	# revert to default behavior
    no  sort 'stable';		# stability not important
d73 2
a74 2
With the C<sort> pragma you can control the behaviour of the builtin
C<sort()> function.
d77 1
a77 1
implement C<sort()>, but in Perl 5.8 a mergesort algorithm was also made
d101 3
a103 3
C<sort()> to merge several sorted arrays.  On the other hand, quicksort
is often faster for small arrays, and on arrays of a few distinct
values, repeated many times.  You can force the
a105 20
The default algorithm is mergesort, which will be stable even if
you do not explicitly demand it.
But the stability of the default sort is a side-effect that could
change in later versions.  If stability is important, be sure to
say so with a

  use sort 'stable';

The C<no sort> pragma doesn't
I<forbid> what follows, it just leaves the choice open.  Thus, after

  no sort qw(_mergesort stable);

a mergesort, which happens to be stable, will be employed anyway.
Note that

  no sort "_quicksort";
  no sort "_mergesort";

have exactly the same effect, leaving the choice of sort algorithm open.
d109 2
a110 44
This pragma is not lexically scoped: its effect is global to the program
it appears in.  That means the following will probably not do what you
expect, because I<both> pragmas take effect at compile time, before
I<either> C<sort()> happens.

  { use sort "_quicksort";
    print sort::current . "\n";
    @@a = sort @@b;
  }
  { use sort "stable";
    print sort::current . "\n";
    @@c = sort @@d;
  }
  # prints:
  # quicksort stable
  # quicksort stable

You can achieve the effect you probably wanted by using C<eval()>
to defer the pragmas until run time.  Use the quoted argument
form of C<eval()>, I<not> the BLOCK form, as in

  eval { use sort "_quicksort" }; # WRONG

or the effect will still be at compile time.
Reset to default options before selecting other subpragmas
(in case somebody carelessly left them on) and after sorting,
as a courtesy to others.

  { eval 'use sort qw(defaults _quicksort)'; # force quicksort
    eval 'no sort "stable"';      # stability not wanted
    print sort::current . "\n";
    @@a = sort @@b;
    eval 'use sort "defaults"';   # clean up, for others
  }
  { eval 'use sort qw(defaults stable)';     # force stability
    print sort::current . "\n";
    @@c = sort @@d;
    eval 'use sort "defaults"';   # clean up, for others
  }
  # prints:
  # quicksort
  # stable

Scoping for this pragma may change in future versions.
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '2.01';
d5 6
a10 2
# The hints for pp_sort are now stored in $^H{sort}; older versions
# of perl used the global variable $sort::hints. -- rjh 2005-12-19
d26 1
a26 1
    $^H{sort} //= 0;
d29 2
a30 2
	    $^H{sort} &= ~$sort::sort_bits;
	    $^H{sort} |=  $sort::quicksort_bit;
d32 2
a33 2
	    $^H{sort} &= ~$sort::sort_bits;
	    $^H{sort} |=  $sort::mergesort_bit;
d35 1
a35 1
	    $^H{sort} |=  $sort::stable_bit;
d37 1
a37 1
	    $^H{sort} =   0;
d55 1
a55 1
	    $^H{sort} &= ~$sort::sort_bits;
d57 1
a57 1
	    $^H{sort} &= ~$sort::sort_bits;
d59 1
a59 1
	    $^H{sort} &= ~$sort::stable_bit;
d69 4
a72 4
    if ($^H{sort}) {
	push @@sort, 'quicksort' if $^H{sort} & $sort::quicksort_bit;
	push @@sort, 'mergesort' if $^H{sort} & $sort::mergesort_bit;
	push @@sort, 'stable'    if $^H{sort} & $sort::stable_bit;
d95 1
a95 4
    my $current;
    BEGIN {
	$current = sort::current();	# identify prevailing algorithm
    }
d155 27
a181 4
As of Perl 5.10, this pragma is lexically scoped and takes effect
at compile time. In earlier versions its effect was global and took
effect at run-time; the documentation suggested using C<eval()> to
change the behaviour:
d194 3
d198 1
a198 23
Such code no longer has the desired effect, for two reasons.
Firstly, the use of C<eval()> means that the sorting algorithm
is not changed until runtime, by which time it's too late to
have any effect. Secondly, C<sort::current> is also called at
run-time, when in fact the compile-time value of C<sort::current>
is the one that matters.

So now this code would be written:

  { use sort qw(defaults _quicksort); # force quicksort
    no sort "stable";      # stability not wanted
    my $current;
    BEGIN { $current = print sort::current; }
    print "$current\n";
    @@a = sort @@b;
    # Pragmas go out of scope at the end of the block
  }
  { use sort qw(defaults stable);     # force stability
    my $current;
    BEGIN { $current = print sort::current; }
    print "$current\n";
    @@c = sort @@d;
  }
@


1.1.1.4
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d3 1
a3 1
our $VERSION = '2.02';
d183 1
a183 1
    BEGIN { $current = sort::current; }
d190 1
a190 1
    BEGIN { $current = sort::current; }
@


