head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.5
	OPENBSD_6_1:1.1.1.5.0.12
	OPENBSD_6_1_BASE:1.1.1.5
	OPENBSD_6_0:1.1.1.5.0.10
	OPENBSD_6_0_BASE:1.1.1.5
	OPENBSD_5_9:1.1.1.5.0.4
	OPENBSD_5_9_BASE:1.1.1.5
	OPENBSD_5_8:1.1.1.5.0.6
	OPENBSD_5_8_BASE:1.1.1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.1.1.5.0.2
	OPENBSD_5_7_BASE:1.1.1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.1.1.4.0.8
	OPENBSD_5_6_BASE:1.1.1.4
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.14
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.12
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.10
	OPENBSD_5_0:1.1.1.3.0.8
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.6
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.3.0.4
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.2
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.2.0.26
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.22
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.20
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2009.10.12.18.10.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.08.52;	author sthen;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2014.11.17.20.53.07;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl -i.inplace
# note the extra switch, for the test below

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

use Test::More tests => 54;

use English qw( -no_match_vars ) ;
use Config;
use Errno;

is( $PID, $$, '$PID' );

$_ = 1;
is( $ARG, $_, '$ARG' );

sub foo {
	is($ARG[0], $_[0], '@@ARG' );
}
foo(1);

"abc" =~ /b/;

ok( !$PREMATCH, '$PREMATCH undefined' );
ok( !$MATCH, '$MATCH undefined' );
ok( !$POSTMATCH, '$POSTMATCH undefined' );

$OFS = " ";
$ORS = "\n";

{
	local(*IN, *OUT);
	if ($^O ne 'dos') {
	    pipe(IN, OUT);
	} else {
	    open(OUT, ">en.tmp");
	}
	select(OUT);
	$| = 1;
	print 'ok', '7';

	# since $| is 1, this should be true
	ok( $OUTPUT_AUTOFLUSH, '$OUTPUT_AUTOFLUSH should be true' );

	my $close = close OUT;
	ok( !($close) == $CHILD_ERROR, '$CHILD_ERROR should be false' );

	open(IN, "<en.tmp") if ($^O eq 'dos');
	my $foo = <IN>;
	like( $foo, qr/ok 7/, '$OFS' );

	# chomp is true because $ORS is "\n"
	ok( chomp($foo), '$ORS should be \n' );
}

is( $FORMAT_NAME, 'OUT', '$FORMAT_NAME' );
is( $FORMAT_TOP_NAME, 'OUT_TOP', '$FORMAT_TOP_NAME' );
is( $FORMAT_FORMFEED, "\f", '$FORMAT_FORMFEED' );
is( $FORMAT_LINES_LEFT, 0, '$FORMAT_LINES_LEFT' );
is( $FORMAT_LINES_PER_PAGE, 60, '$FORMAT_LINES_PER_PAGE' );
is( $FORMAT_LINE_BREAK_CHARACTERS, " \n-", '$FORMAT_LINE_BREAK_CHARACTERS');
is( $FORMAT_PAGE_NUMBER, 0, '$FORMAT_PAGE_NUMBER' );
is( $ACCUMULATOR, $^A, '$ACCUMULATOR' );

undef $OUTPUT_FIELD_SEPARATOR;

if ($threads) { $" = "\n" } else { $LIST_SEPARATOR = "\n" };
@@foo = (8, 9);
@@foo = split(/\n/, "@@foo");
is( $foo[0], 8, '$"' );
is( $foo[1], 9, '$LIST_SEPARATOR' );

undef $OUTPUT_RECORD_SEPARATOR;

eval 'NO SUCH FUNCTION';
like( $EVAL_ERROR, qr/method/, '$EVAL_ERROR' );

is( $UID, $<, '$UID' );
is( $GID, $(, '$GID' );
is( $EUID, $>, '$EUID' );
is( $EGID, $), '$EGID' );

is( $PROGRAM_NAME, $0, '$PROGRAM_NAME' );
is( $BASETIME, $^T, '$BASETIME' );

is( $PERL_VERSION, $^V, '$PERL_VERSION' );
is( $DEBUGGING, $^D, '$DEBUGGING' );

is( $WARNING, 0, '$WARNING' );
like( $EXECUTABLE_NAME, qr/perl/i, '$EXECUTABLE_NAME' );
is( $OSNAME, $Config{osname}, '$OSNAME' );

# may be non-portable
ok( $SYSTEM_FD_MAX >= 2, '$SYSTEM_FD_MAX should be at least 2' );

is( $INPLACE_EDIT, '.inplace', '$INPLACE_EDIT' );

'aabbcc' =~ /(.{2}).+(.{2})(?{ 9 })/;
is( $LAST_PAREN_MATCH, 'cc', '$LAST_PARENT_MATCH' );
is( $LAST_REGEXP_CODE_RESULT, 9, '$LAST_REGEXP_CODE_RESULT' );

is( $LAST_MATCH_START[1], 0, '@@LAST_MATCH_START' );
is( $LAST_MATCH_END[1], 2, '@@LAST_MATCH_END' );

ok( !$PERLDB, '$PERLDB should be false' );

{
	local $INPUT_RECORD_SEPARATOR = "\n\n";
	like( <DATA>, qr/a paragraph./, '$INPUT_RECORD_SEPARATOR' );
}
like( <DATA>, qr/second paragraph..\z/s, '$INPUT_RECORD_SEPARATOR' );

is( $INPUT_LINE_NUMBER, 2, '$INPUT_LINE_NUMBER' );

my %hash;
$SUBSCRIPT_SEPARATOR = '|';
$hash{d,e,f} = 1;
$SUBSEP = ',';
$hash{'a', 'b', 'c'} = 1;
my @@keys = sort keys %hash;

is( $keys[0], 'a,b,c', '$SUBSCRIPT_SEPARATOR' );
is( $keys[1], 'd|e|f', '$SUBSCRIPT_SEPARATOR' );

eval { is( $EXCEPTIONS_BEING_CAUGHT, 1, '$EXCEPTIONS_BEING_CAUGHT' ) };
ok( !$EXCEPTIONS_BEING_CAUGHT, '$EXCEPTIONS_BEING_CAUGHT should be false' );

eval { local *F; my $f = 'asdasdasd'; ++$f while -e $f; open(F, $f); };
is( $OS_ERROR, $ERRNO, '$OS_ERROR' );
ok( $OS_ERROR{ENOENT}, '%OS_ERROR (ENOENT should be set)' );

package B;

use English;

"abc" =~ /b/;

main::is( $PREMATCH, 'a', '$PREMATCH defined' );
main::is( $MATCH, 'b', '$MATCH defined' );
main::is( $POSTMATCH, 'c', '$POSTMATCH defined' );

package C;

use English qw( -no_match_vars ) ;

"abc" =~ /b/;

main::ok( !$PREMATCH, '$PREMATCH disabled' );
main::ok( !$MATCH, '$MATCH disabled' );
main::ok( !$POSTMATCH, '$POSTMATCH disabled' );

__END__
This is a line.
This is a paragraph.

This is a second paragraph.
It has several lines.
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d9 1
a9 1
use Test::More tests => 55;
a143 6

{
    my $s = "xyz";
    $s =~ s/y/t$MATCH/;
    main::is( $s, "xtyz", '$MATCH defined in right side of s///' );
}
@


1.1.1.3
log
@import perl 5.10.1
@
text
@d102 1
a102 1
is( $LAST_PAREN_MATCH, 'cc', '$LAST_PAREN_MATCH' );
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d9 1
a9 1
use Test::More tests => 57;
a159 10


# Check that both variables change when localized.
{
    local $LIST_SEPARATOR = "wibble";
    ::is $", 'wibble', '$" changes when $LIST_SEPARATOR is localized';

    local $" = 'frooble';
    ::is $LIST_SEPARATOR, 'frooble';
}
@


1.1.1.5
log
@Import perl-5.20.1
@
text
@d9 1
a9 1
use Test::More tests => 58;
a89 1
is( $OLD_PERL_VERSION, $], '$OLD_PERL_VERSION' );
@


