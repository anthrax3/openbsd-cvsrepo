head	1.7;
access;
symbols
	OPENBSD_6_2:1.7.0.2
	OPENBSD_6_2_BASE:1.7
	PERL_5_24_2:1.1.1.8
	OPENBSD_6_1:1.7.0.4
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.6.0.8
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.4
	OPENBSD_5_8_BASE:1.6
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.4.0.2
	OPENBSD_5_7_BASE:1.4
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.2.0.8
	OPENBSD_5_6_BASE:1.2
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.18
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.14
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.16
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.12
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.7
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.6;
commitid	cxJ08BvJA9Pt2PTM;

1.6
date	2015.04.25.19.26.22;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	3qGYFVvfrExB70FB;

1.5
date	2015.04.25.19.14.46;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	XRK22kO4se3v2i2I;

1.4
date	2014.11.17.21.01.00;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	LnErp1MFKSuew5Fr;

1.3
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.2;
commitid	QP75iYx42Uo7mMxO;

1.2
date	2013.03.25.20.40.55;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.46.40;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.17.07;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.33;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.48.35;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.08.51;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2017.08.14.13.46.13;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.7
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require "./test.pl";

    plan ('no_plan');

    use_ok('Config');
}

use strict;

# Some (safe?) bets.

ok(keys %Config > 500, "Config has more than 500 entries");

my ($first) = Config::config_sh() =~ /^(\S+)=/m;
die "Can't find first entry in Config::config_sh()" unless defined $first;
print "# First entry is '$first'\n";

# It happens that the we know what the first key should be. This is somewhat
# cheating, but there was briefly a bug where the key got a bonus newline.
my ($first_each) = each %Config;
is($first_each, $first, "First key from each is correct");
ok(exists($Config{$first_each}), "First key exists");
ok(!exists($Config{"\n$first"}),
   "Check that first key with prepended newline isn't falsely existing");

is($Config{PERL_REVISION}, 5, "PERL_REVISION is 5");

# Check that old config variable names are aliased to their new ones.
my %grandfathers = ( PERL_VERSION       => 'PATCHLEVEL',
                     PERL_SUBVERSION    => 'SUBVERSION',
                     PERL_CONFIG_SH     => 'CONFIG'
                   );
while( my($new, $old) = each %grandfathers ) {
    isnt($Config{$new}, undef,       "$new is defined");
    is($Config{$new}, $Config{$old}, "$new is aliased to $old");
}

ok( exists $Config{cc},      "has cc");

ok( exists $Config{ccflags}, "has ccflags");

ok(!exists $Config{python},  "has no python");

ok( exists $Config{d_fork},  "has d_fork");

ok(!exists $Config{d_bork},  "has no d_bork");

like($Config{ivsize}, qr/^(4|8)$/, "ivsize is 4 or 8 (it is $Config{ivsize})");

# byteorder is virtual, but it has rules.

like($Config{byteorder}, qr/^(1234|4321|12345678|87654321)$/,
     "byteorder is 1234 or 4321 or 12345678 or 87654321 "
     . "(it is $Config{byteorder})");

is(length $Config{byteorder}, $Config{ivsize},
   "byteorder is as long as ivsize (which is $Config{ivsize})");

# ccflags_nolargefiles is virtual, too.

ok(exists $Config{ccflags_nolargefiles}, "has ccflags_nolargefiles");

# Utility functions.

{
    # make sure we can export what we say we can export.
    package Foo;
    my @@exports = qw(myconfig config_sh config_vars config_re);
    Config->import(@@exports);
    foreach my $func (@@exports) {
	::ok( __PACKAGE__->can($func), "$func exported" );
    }
}

like(Config::myconfig(), qr/osname=\Q$Config{osname}\E/,   "myconfig");
like(Config::config_sh(), qr/osname='\Q$Config{osname}\E'/, "config_sh");
like(Config::config_sh(), qr/byteorder='[1-8]+'/,
     "config_sh has a valid byteorder");
foreach my $line (Config::config_re('c.*')) {
  like($line,                  qr/^c.*?=.*$/,                   'config_re' );
}

my $out = tie *STDOUT, 'FakeOut';

Config::config_vars('cc');	# non-regex test of essential cfg-var
my $out1 = $$out;
$out->clear;

Config::config_vars('d_bork');	# non-regex, non-existent cfg-var
my $out2 = $$out;
$out->clear;

Config::config_vars('PERL_API_.*');	# regex, tagged multi-line answer
my $out3 = $$out;
$out->clear;

Config::config_vars('PERL_API_.*:');	# regex, tagged single-line answer
my $out4 = $$out;
$out->clear;

Config::config_vars(':PERL_API_.*:');	# regex, non-tagged single-line answer
my $out5 = $$out;
$out->clear;

Config::config_vars(':PERL_API_.*');	# regex, non-tagged multi-line answer
my $out6 = $$out;
$out->clear;

Config::config_vars('PERL_API_REVISION.*:'); # regex, tagged 
my $out7 = $$out;
$out->clear;

# regex, non-tagged multi-line answer
Config::config_vars(':PERL_API_REVISION.*');
my $out8 = $$out;
$out->clear;

Config::config_vars('PERL_EXPENSIVE_.*:'); # non-matching regex
my $out9 = $$out;
$out->clear;

Config::config_vars('?flags');	# bogus regex, no explicit warning !
my $out10 = $$out;
$out->clear;

undef $out;
untie *STDOUT;

like($out1, qr/^cc='\Q$Config{cc}\E';/, "found config_var cc");
like($out2, qr/^d_bork='UNKNOWN';/, "config_var d_bork is UNKNOWN");

# test for leading, trailing colon effects
# Split in scalar context it deprecated, and will warn.
my @@tmp;
is(scalar (@@tmp = split(/;\n/, $out3)), 3, "3 lines found");
is(scalar (@@tmp = split(/;\n/, $out6)), 3, "3 lines found");

is($out4 =~ /(;\n)/s, '', "trailing colon gives 1-line response: $out4");
is($out5 =~ /(;\n)/s, '', "trailing colon gives 1-line response: $out5");

is(scalar (@@tmp = split(/=/, $out3)), 4, "found 'tag='");
is(scalar (@@tmp = split(/=/, $out4)), 4, "found 'tag='");

my @@api;

my @@rev = @@Config{qw(PERL_API_REVISION PERL_API_VERSION PERL_API_SUBVERSION)};

print ("# test tagged responses, multi-line and single-line\n");
foreach my $api ($out3, $out4) {
    @@api = $api =~ /PERL_API_(\w+)=(.*?)(?:;\n|\s)/mg;
    is($api[0], "REVISION", "REVISION tag");
    is($api[4], "VERSION",  "VERSION tag");
    is($api[2], "SUBVERSION", "SUBVERSION tag");
    is($api[1], "'$rev[0]'", "REVISION is $rev[0]");
    is($api[5], "'$rev[1]'", "VERSION is $rev[1]");
    is($api[3], "'$rev[2]'", "SUBVERSION is $rev[2]");
}

print("# test non-tagged responses, multi-line and single-line\n");
foreach my $api ($out5, $out6) {
    @@api = split /(?: |;\n)/, $api;
    is($api[0], "'$rev[0]'", "revision is $rev[0]");
    is($api[2], "'$rev[1]'", "version is $rev[1]");
    is($api[1], "'$rev[2]'", "subversion is $rev[2]");
}

# compare to each other, the outputs for trailing, leading colon
$out7 =~ s/ $//;
is("$out7;\n", "PERL_API_REVISION=$out8", "got expected diffs");

like($out9, qr/\bnot\s+found\b/, "$out9 - perl is FREE !");
like($out10, qr/\bnot\s+found\b/, "config_vars with invalid regexp");

# Read-only.

undef $@@;
eval { $Config{d_bork} = 'borkbork' };
like($@@, qr/Config is read-only/, "no STORE");

ok(!exists $Config{d_bork}, "still no d_bork");

undef $@@;
eval { delete $Config{d_fork} };
like($@@, qr/Config is read-only/, "no DELETE");

ok( exists $Config{d_fork}, "still d_fork");

undef $@@;
eval { %Config = () };
like($@@, qr/Config is read-only/, "no CLEAR");

ok( exists $Config{d_fork}, "still d_fork");

{
    package FakeOut;

    sub TIEHANDLE {
	bless(\(my $text), $_[0]);
    }

    sub clear {
	${ $_[0] } = '';
    }

    sub PRINT {
	my $self = shift;
	$$self .= join('', @@_);
    }
}

# Signal-related variables
# (this is actually a regression test for Configure.)

is($Config{sig_num_init}  =~ tr/,/,/, $Config{sig_size}, "sig_num_init size");
is($Config{sig_name_init} =~ tr/,/,/, $Config{sig_size}, "sig_name_init size");

# Test the troublesome virtual stuff
my @@virtual = qw(byteorder ccflags_nolargefiles ldflags_nolargefiles
		 libs_nolargefiles libswanted_nolargefiles);

# Also test that the first entry in config.sh is found correctly. There was
# special casing code for this

foreach my $pain ($first, @@virtual) {
  # No config var is named with anything that is a regexp metachar
  ok(exists $Config{$pain}, "\$config('$pain') exists");

  my @@result = $Config{$pain};
  is (scalar @@result, 1, "single result for \$config('$pain')");

  @@result = Config::config_re($pain);
  is (scalar @@result, 1, "single result for config_re('$pain')");
  like ($result[0], qr/^$pain=(['"])\Q$Config{$pain}\E\1$/, # grr '
	"which is the expected result for $pain");
}

# Check that config entries appear correctly in @@INC
# TestInit.pm has probably already messed with our @@INC
# This little bit of evil is to avoid a @@ in the program, in case it confuses
# shell 1 liners. We used to use a perl 1-ism, until that was deprecated, so
# now some octal in an eval.
my ($path, $ver, @@orig_inc)
  = split /\n/,
    runperl (nolib=>1,
	     prog=>'print qq{$_\n} foreach $^X, $], eval qq{\100INC}');

die "This perl is $] at $^X; other perl is $ver (at $path) "
  . '- failed to find this perl' unless $] eq $ver;

my %orig_inc;
@@orig_inc{@@orig_inc} = ();

my $failed;
# This [used to be] the order that directories are pushed onto @@INC in perl.c:
foreach my $lib (qw(applibexp archlibexp privlibexp sitearchexp sitelibexp
		     vendorarchexp vendorlibexp)) {
  my $dir = $Config{$lib};
  SKIP: {
    skip "lib $lib not in \@@INC on Win32" if $^O eq 'MSWin32';
    skip "lib $lib not in \@@INC on os390" if $^O eq 'os390';
    skip "lib $lib not defined" unless defined $dir;
    skip "lib $lib not set" unless length $dir;
    # May be in @@INC in either Unix or VMS format on VMS.
    if ($^O eq 'VMS' && !exists($orig_inc{$dir})) {
        $dir = VMS::Filespec::unixify($dir);
        $dir =~ s|/$||;
    }
    # So we expect to find it in @@INC

    ok (exists $orig_inc{$dir}, "Expect $lib '$dir' to be in \@@INC")
      or $failed++;
  }
}
_diag ('@@INC is:', @@orig_inc) if $failed;
@


1.6
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d265 1
d275 2
a276 2
    ok (exists $orig_inc{$_}, "Expect $lib '$_' to be in \@@INC")
      or $failed++ for split ':', $dir;
@


1.5
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d274 2
a275 2
    ok (exists $orig_inc{$dir}, "Expect $lib '$dir' to be in \@@INC")
      or $failed++;
@


1.4
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d274 2
a275 2
    ok (exists $orig_inc{$_}, "Expect $lib '$_' to be in \@@INC")
      or $failed++ for split ':', $dir;
@


1.3
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d274 2
a275 2
    ok (exists $orig_inc{$dir}, "Expect $lib '$dir' to be in \@@INC")
      or $failed++;
@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d274 2
a275 2
    ok (exists $orig_inc{$_}, "Expect $lib '$_' to be in \@@INC")
      or $failed++ for split ':', $dir;
@


1.1
log
@Initial revision
@
text
@d1 2
d7 4
d13 1
a13 3
plan tests => 23;

use_ok('Config');
d19 11
a29 1
ok(each %Config);
d33 10
d53 1
a53 1
like($Config{ivsize},     qr/^(4|8)$/, "ivsize is 4 or 8 (it is $Config{ivsize})");
d55 1
a55 1
# byteorder is virtual, but it has rules. 
d57 3
a59 1
like($Config{byteorder}, qr/^(1234|4321|12345678|87654321)$/, "byteorder is 1234 or 4321 or 12345678 or 87654321 (it is $Config{byteorder})");
d61 2
a62 1
is(length $Config{byteorder}, $Config{ivsize}, "byteorder is as long as ivsize (which is $Config{ivsize})");
d70 9
a78 1
like(Config::myconfig(),  qr/cc='$Config{cc}'/, "myconfig");
d80 6
a85 3
SKIP: {
	skip "cc is tied in $^O", 1 if $^O eq 'MacOS';
	like(Config::config_sh(), qr/cc='$Config{cc}'/, "config_sh");
d90 1
a90 1
Config::config_vars('cc');
d94 1
a94 1
Config::config_vars('d_bork');
d98 34
d134 44
a177 2
like($out1, qr/^cc='$Config{cc}';/, "config_vars cc");
like($out2, qr/^d_bork='UNKNOWN';/, "config_vars d_bork is UNKNOWN");
d199 2
a200 1
package FakeOut;
d202 12
a213 2
sub TIEHANDLE {
        bless(\(my $text), $_[0]);
d216 24
a239 2
sub clear {
        ${ $_[0] } = '';
d242 35
a276 3
sub PRINT {
        my $self = shift;
        $$self .= join('', @@_);
d278 1
a278 1

@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@a0 2
#!./perl

d7 1
a7 1
plan tests => 36;
a18 10
# Check that old config variable names are aliased to their new ones.
my %grandfathers = ( PERL_VERSION       => 'PATCHLEVEL',
                     PERL_SUBVERSION    => 'SUBVERSION',
                     PERL_CONFIG_SH     => 'CONFIG'
                   );
while( my($new, $old) = each %grandfathers ) {
    isnt($Config{$new}, undef,       "$new is defined");
    is($Config{$new}, $Config{$old}, "$new is aliased to $old");
}

d43 5
a47 8
{
    # make sure we can export what we say we can export.
    package Foo;
    my @@exports = qw(myconfig config_sh config_vars config_re);
    Config->import(@@exports);
    foreach my $func (@@exports) {
	::ok( __PACKAGE__->can($func), "$func exported" );
    }
a49 5
like(Config::myconfig(),       qr/osname=\Q$Config{osname}\E/,   "myconfig");
like(Config::config_sh(),      qr/osname='\Q$Config{osname}\E'/, "config_sh");
like(join("\n", Config::config_re('c.*')),
			       qr/^c.*?=/,                   'config_re' );

d62 1
a62 1
like($out1, qr/^cc='\Q$Config{cc}\E';/, "config_vars cc");
d85 5
a89 2
{
    package FakeOut;
d91 2
a92 12
    sub TIEHANDLE {
	bless(\(my $text), $_[0]);
    }

    sub clear {
	${ $_[0] } = '';
    }

    sub PRINT {
	my $self = shift;
	$$self .= join('', @@_);
    }
d95 4
a98 2
# Signal-related variables
# (this is actually a regression test for Configure.)
a99 2
is($Config{sig_num_init}  =~ tr/,/,/, $Config{sig_size}, "sig_num_init size");
is($Config{sig_name_init} =~ tr/,/,/, $Config{sig_size}, "sig_name_init size");
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d9 1
a9 1
plan tests => 47;
d80 1
a80 11
Config::config_vars('PERL_API_.*');
my $out3 = $$out;
$out->clear;

Config::config_vars(':PERL_API_.*:');
my $out4 = $$out;
$out->clear;

Config::config_vars(':PERL_API_REVISION:');
my $out5 = $$out;
$out->clear;
a81 5
Config::config_vars('?flags');
my $out6 = $$out;
$out->clear;

untie *STDOUT;
a83 16

is(3, scalar split(/\n/, $out3), "3 PERL_API vars found");
my @@api = $out3 =~ /^PERL_API_(\w+)=(.*);/mg;
is("'5'", $api[1], "1st is 5");
is("'8'", $api[5], "2nd is 9");
is("'0'", $api[3], "3rd is 1");
@@api = split(/ /, $out4);
is(3, @@api, "trailing colon puts 3 terms on same line");
unlike($out4, qr/=/, "leading colon suppresses param names");
is("'5'", $api[0], "revision is 5");
is("'8'", $api[2], "version is 9");
is("'0'", $api[1], "subversion is 1");

is("'5' ", $out5, "leading and trailing colons return just the value");

like($out6, qr/\bnot\s+found\b/, "config_vars with invalid regexp");
@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@d9 1
a9 1
plan 'no_plan';
d43 1
a43 1
# byteorder is virtual, but it has rules.
d65 4
a68 7
like(Config::myconfig(), qr/osname=\Q$Config{osname}\E/,   "myconfig");
like(Config::config_sh(), qr/osname='\Q$Config{osname}\E'/, "config_sh");
like(Config::config_sh(), qr/byteorder='[1-8]+'/,
     "config_sh has a valid byteorder");
foreach my $line (Config::config_re('c.*')) {
  like($line,                  qr/^c.*?=.*$/,                   'config_re' );
}
d72 1
a72 1
Config::config_vars('cc');	# non-regex test of essential cfg-var
d76 1
a76 1
Config::config_vars('d_bork');	# non-regex, non-existent cfg-var
d80 1
a80 1
Config::config_vars('PERL_API_.*');	# regex, tagged multi-line answer
d84 1
a84 1
Config::config_vars('PERL_API_.*:');	# regex, tagged single-line answer
d88 1
a88 1
Config::config_vars(':PERL_API_.*:');	# regex, non-tagged single-line answer
d92 1
a92 1
Config::config_vars(':PERL_API_.*');	# regex, non-tagged multi-line answer
a95 16
Config::config_vars('PERL_API_REVISION.*:'); # regex, tagged 
my $out7 = $$out;
$out->clear;

Config::config_vars(':PERL_API_REVISION.*'); # regex, non-tagged multi-line answer
my $out8 = $$out;
$out->clear;

Config::config_vars('PERL_EXPENSIVE_.*:'); # non-matching regex
my $out9 = $$out;
$out->clear;

Config::config_vars('?flags');	# bogus regex, no explicit warning !
my $out10 = $$out;
$out->clear;

d97 2
d100 11
a110 27
like($out1, qr/^cc='\Q$Config{cc}\E';/, "found config_var cc");
like($out2, qr/^d_bork='UNKNOWN';/, "config_var d_bork is UNKNOWN");

# test for leading, trailing colon effects
is(scalar split(/;\n/, $out3), 3, "3 lines found");
is(scalar split(/;\n/, $out6), 3, "3 lines found");

is($out4 =~ /(;\n)/s, '', "trailing colon gives 1-line response: $out4");
is($out5 =~ /(;\n)/s, '', "trailing colon gives 1-line response: $out5");

is(scalar split(/=/, $out3), 4, "found 'tag='");
is(scalar split(/=/, $out4), 4, "found 'tag='");

my @@api;

my @@rev = @@Config{qw(PERL_API_REVISION PERL_API_VERSION PERL_API_SUBVERSION)};

print ("# test tagged responses, multi-line and single-line\n");
foreach $api ($out3, $out4) {
    @@api = $api =~ /PERL_API_(\w+)=(.*?)(?:;\n|\s)/mg;
    is($api[0], "REVISION", "REVISION tag");
    is($api[4], "VERSION",  "VERSION tag");
    is($api[2], "SUBVERSION", "SUBVERSION tag");
    is($api[1], "'$rev[0]'", "REVISION is $rev[0]");
    is($api[5], "'$rev[1]'", "VERSION is $rev[1]");
    is($api[3], "'$rev[2]'", "SUBVERSION is $rev[2]");
}
d112 1
a112 7
print("# test non-tagged responses, multi-line and single-line\n");
foreach $api ($out5, $out6) {
    @@api = split /(?: |;\n)/, $api;
    is($api[0], "'$rev[0]'", "revision is $rev[0]");
    is($api[2], "'$rev[1]'", "version is $rev[1]");
    is($api[1], "'$rev[2]'", "subversion is $rev[2]");
}
d114 1
a114 6
# compare to each other, the outputs for trailing, leading colon
$out7 =~ s/ $//;
is("$out7;\n", "PERL_API_REVISION=$out8", "got expected diffs");

like($out9, qr/\bnot\s+found\b/, "$out9 - perl is FREE !");
like($out10, qr/\bnot\s+found\b/, "config_vars with invalid regexp");
a157 9

# Test the troublesome virtual stuff
foreach my $pain (qw(byteorder)) {
  # No config var is named with anything that is a regexp metachar"
  my @@result = Config::config_re($pain);
  is (scalar @@result, 1, "single result for config_re('$pain')");
  like ($result[0], qr/^$pain=(['"])$Config{$pain}\1$/, # grr '
				"which is the expected result for $pain");
}
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d1 1
a1 1
#!./perl -w
d7 1
d9 1
a9 4
    plan ('no_plan');

    use_ok('Config');
}
d11 1
a11 1
use strict;
d17 1
a17 11
my ($first) = Config::config_sh() =~ /^(\S+)=/m;
die "Can't find first entry in Config::config_sh()" unless defined $first;
print "# First entry is '$first'\n";

# It happens that the we know what the first key should be. This is somewhat
# cheating, but there was briefly a bug where the key got a bonus newline.
my ($first_each) = each %Config;
is($first_each, $first, "First key from each is correct");
ok(exists($Config{$first_each}), "First key exists");
ok(!exists($Config{"\n$first"}),
   "Check that first key with prepended newline isn't falsely existing");
d41 1
a41 1
like($Config{ivsize}, qr/^(4|8)$/, "ivsize is 4 or 8 (it is $Config{ivsize})");
d45 1
a45 3
like($Config{byteorder}, qr/^(1234|4321|12345678|87654321)$/,
     "byteorder is 1234 or 4321 or 12345678 or 87654321 "
     . "(it is $Config{byteorder})");
d47 1
a47 2
is(length $Config{byteorder}, $Config{ivsize},
   "byteorder is as long as ivsize (which is $Config{ivsize})");
d103 1
a103 2
# regex, non-tagged multi-line answer
Config::config_vars(':PERL_API_REVISION.*');
a114 1
undef $out;
d121 2
a122 4
# Split in scalar context it deprecated, and will warn.
my @@tmp;
is(scalar (@@tmp = split(/;\n/, $out3)), 3, "3 lines found");
is(scalar (@@tmp = split(/;\n/, $out6)), 3, "3 lines found");
d127 2
a128 2
is(scalar (@@tmp = split(/=/, $out3)), 4, "found 'tag='");
is(scalar (@@tmp = split(/=/, $out4)), 4, "found 'tag='");
d135 1
a135 1
foreach my $api ($out3, $out4) {
d146 1
a146 1
foreach my $api ($out5, $out6) {
d204 3
a206 14
my @@virtual = qw(byteorder ccflags_nolargefiles ldflags_nolargefiles
		 libs_nolargefiles libswanted_nolargefiles);

# Also test that the first entry in config.sh is found correctly. There was
# special casing code for this

foreach my $pain ($first, @@virtual) {
  # No config var is named with anything that is a regexp metachar
  ok(exists $Config{$pain}, "\$config('$pain') exists");

  my @@result = $Config{$pain};
  is (scalar @@result, 1, "single result for \$config('$pain')");

  @@result = Config::config_re($pain);
d208 2
a209 33
  like ($result[0], qr/^$pain=(['"])\Q$Config{$pain}\E\1$/, # grr '
	"which is the expected result for $pain");
}

# Check that config entries appear correctly in @@INC
# TestInit.pm has probably already messed with our @@INC
# This little bit of evil is to avoid a @@ in the program, in case it confuses
# shell 1 liners. Perl 1 rules.
my ($path, $ver, @@orig_inc)
  = split /\n/,
    runperl (nolib=>1,
	     prog=>'print qq{$^X\n$]\n}; print qq{$_\n} while $_ = shift INC');

die "This perl is $] at $^X; other perl is $ver (at $path) "
  . '- failed to find this perl' unless $] eq $ver;

my %orig_inc;
@@orig_inc{@@orig_inc} = ();

my $failed;
# This is the order that directories are pushed onto @@INC in perl.c:
foreach my $lib (qw(applibexp archlibexp privlibexp sitearchexp sitelibexp
		     vendorarchexp vendorlibexp vendorlib_stem)) {
  my $dir = $Config{$lib};
  SKIP: {
    skip "lib $lib not in \@@INC on Win32" if $^O eq 'MSWin32';
    skip "lib $lib not defined" unless defined $dir;
    skip "lib $lib not set" unless length $dir;
    # So we expect to find it in @@INC

    ok (exists $orig_inc{$dir}, "Expect $lib '$dir' to be in \@@INC")
      or $failed++;
  }
a210 1
_diag ('@@INC is:', @@orig_inc) if $failed;
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d245 1
a245 2
# shell 1 liners. We used to use a perl 1-ism, until that was deprecated, so
# now some octal in an eval.
d249 1
a249 1
	     prog=>'print qq{$_\n} foreach $^X, $], eval qq{\100INC}');
d258 1
a258 1
# This [used to be] the order that directories are pushed onto @@INC in perl.c:
d260 1
a260 1
		     vendorarchexp vendorlibexp)) {
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a266 5
    # May be in @@INC in either Unix or VMS format on VMS.
    if ($^O eq 'VMS' && !exists($orig_inc{$dir})) {
        $dir = VMS::Filespec::unixify($dir);
        $dir =~ s|/$||;
    }
@


1.1.1.8
log
@Import perl-5.24.2
@
text
@a264 1
    skip "lib $lib not in \@@INC on os390" if $^O eq 'os390';
@


