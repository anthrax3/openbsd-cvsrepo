head	1.11;
access;
symbols
	PERL_5_24_2:1.1.1.10
	OPENBSD_6_1:1.11.0.4
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.12
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.6
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.8
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.10.0.4
	OPENBSD_5_6_BASE:1.10
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.18
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.16
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.14
	OPENBSD_5_0:1.8.0.12
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.10
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	cxJ08BvJA9Pt2PTM;

1.10
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.9;

1.9
date	2013.03.25.20.40.55;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.36;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.10;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.56.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.33;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.33;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.51;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.35;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.08.51;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2017.08.14.13.46.14;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.11
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@require 5.014;			# For more reliable $@@ after eval
package dumpvar;

# Needed for PrettyPrinter only:

# require 5.001;  # Well, it coredumps anyway undef DB in 5.000 (not now)

# translate control chars to ^X - Randal Schwartz
# Modifications to print types by Peter Gordon v1.0

# Ilya Zakharevich -- patches after 5.001 (and some before ;-)

# Won't dump symbol tables and contents of debugged files by default

$winsize = 80 unless defined $winsize;

sub ASCII { return ord('A') == 65; }


# Defaults

# $globPrint = 1;
$printUndef = 1 unless defined $printUndef;
$tick = "auto" unless defined $tick;
$unctrl = 'quote' unless defined $unctrl;
$subdump = 1;
$dumpReused = 0 unless defined $dumpReused;
$bareStringify = 1 unless defined $bareStringify;

my $APC = chr utf8::unicode_to_native(0x9F);
my $backslash_c_question = (ASCII) ? '\177' : $APC;

sub main::dumpValue {
  local %address;
  local $^W=0;
  (print "undef\n"), return unless defined $_[0];
  (print &stringify($_[0]), "\n"), return unless ref $_[0];
  push @@_, -1 if @@_ == 1;
  dumpvar::unwrap($_[0], 0, $_[1]);
}

# This one is good for variable names:

sub unctrl {
    for (my($dummy) = shift) {
	local($v) ; 

	return \$_ if ref \$_ eq "GLOB";
        s/([\000-\037])/ '^' . chr(utf8::unicode_to_native(ord($1)^64))/eg;
        s/ $backslash_c_question /^?/xg;
	return $_;
    }
}

sub uniescape {
    join("",
	 map { $_ > 255 ? sprintf("\\x{%04X}", $_) : chr($_) }
	     unpack("W*", $_[0]));
}

sub stringify {
  my $string;
  if (eval { $string = _stringify(@@_); 1 }) {
    return $string;
  }

  return "<< value could not be dumped: $@@ >>";
}

sub _stringify {
    (my $__, local $noticks) = @@_;
    for ($__) {
	local($v) ; 
	my $tick = $tick;

	return 'undef' unless defined $_ or not $printUndef;
	return $_ . "" if ref \$_ eq 'GLOB';
	$_ = &{'overload::StrVal'}($_) 
	  if $bareStringify and ref $_ 
	    and %overload:: and defined &{'overload::StrVal'};
	
	if ($tick eq 'auto') {
            if (/[^[:^cntrl:]\n]/u) {   # All controls but \n get '"'
                $tick = '"';
            } else {
                $tick = "'";
            }
	}
	if ($tick eq "'") {
	  s/([\'\\])/\\$1/g;
	} elsif ($unctrl eq 'unctrl') {
	  s/([\"\\])/\\$1/g ;
          $_ = &unctrl($_);
	  # uniescape?
	  s/([[:^ascii:]])/'\\0x'.sprintf('%2X',ord($1))/eg
	    if $quoteHighBit;
	} elsif ($unctrl eq 'quote') {
	  s/([\"\\\$\@@])/\\$1/g if $tick eq '"';
	  s/\e/\\e/g;
          s/([\000-\037$backslash_c_question])/'\\c'._escaped_ord($1)/eg;
	}
	$_ = uniescape($_);
	s/([[:^ascii:]])/'\\'.sprintf('%3o',ord($1))/eg if $quoteHighBit;
	return ($noticks || /^\d+(\.\d*)?\Z/) 
	  ? $_ 
	  : $tick . $_ . $tick;
    }
}

# Ensure a resulting \ is escaped to be \\
sub _escaped_ord {
    my $chr = shift;
    if ($chr eq $backslash_c_question) {
        $chr = '?';
    }
    else {
        $chr = chr(utf8::unicode_to_native(ord($chr)^64));
        $chr =~ s{\\}{\\\\}g;
    }
    return $chr;
}

sub ShortArray {
  my $tArrayDepth = $#{$_[0]} ; 
  $tArrayDepth = $#{$_[0]} < $arrayDepth-1 ? $#{$_[0]} : $arrayDepth-1 
    unless  $arrayDepth eq '' ; 
  my $shortmore = "";
  $shortmore = " ..." if $tArrayDepth < $#{$_[0]} ;
  if (!grep(ref $_, @@{$_[0]})) {
    $short = "0..$#{$_[0]}  '" . 
      join("' '", @@{$_[0]}[0..$tArrayDepth]) . "'$shortmore";
    return $short if length $short <= $compactDump;
  }
  undef;
}

sub DumpElem {
  my $short = &stringify($_[0], ref $_[0]);
  if ($veryCompact && ref $_[0]
      && (ref $_[0] eq 'ARRAY' and !grep(ref $_, @@{$_[0]}) )) {
    my $end = "0..$#{$v}  '" . 
      join("' '", @@{$_[0]}[0..$tArrayDepth]) . "'$shortmore";
  } elsif ($veryCompact && ref $_[0]
      && (ref $_[0] eq 'HASH') and !grep(ref $_, values %{$_[0]})) {
    my $end = 1;
	  $short = $sp . "0..$#{$v}  '" . 
	    join("' '", @@{$v}[0..$tArrayDepth]) . "'$shortmore";
  } else {
    print "$short\n";
    unwrap($_[0],$_[1],$_[2]) if ref $_[0];
  }
}

sub unwrap {
    return if $DB::signal;
    local($v) = shift ; 
    local($s) = shift ; # extra no of spaces
    local($m) = shift ; # maximum recursion depth
    return if $m == 0;
    local(%v,@@v,$sp,$value,$key,@@sortKeys,$more,$shortmore,$short) ;
    local($tHashDepth,$tArrayDepth) ;

    $sp = " " x $s ;
    $s += 3 ; 

    eval {
    # Check for reused addresses
    if (ref $v) { 
      my $val = $v;
      $val = &{'overload::StrVal'}($v) 
	if %overload:: and defined &{'overload::StrVal'};
      # Match type and address.                      
      # Unblessed references will look like TYPE(0x...)
      # Blessed references will look like Class=TYPE(0x...)
      $val =~ s/^.*=//; # suppress the Class part, just keep TYPE(0x...)
      ($item_type, $address) = 
        $val =~ /([^\(]+)        # Keep stuff that's     
                                 # not an open paren
                 \(              # Skip open paren
                 (0x[0-9a-f]+)   # Save the address
                 \)              # Skip close paren
                 $/x;            # Should be at end now

      if (!$dumpReused && defined $address) { 
	$address{$address}++ ;
	if ( $address{$address} > 1 ) { 
	  print "${sp}-> REUSED_ADDRESS\n" ; 
	  return ; 
	} 
      }
    } elsif (ref \$v eq 'GLOB') {
      # This is a raw glob. Special handling for that.
      $address = "$v" . "";	# To avoid a bug with globs
      $address{$address}++ ;
      if ( $address{$address} > 1 ) { 
	print "${sp}*DUMPED_GLOB*\n" ; 
	return ; 
      } 
    }

    if (ref $v eq 'Regexp') {
      # Reformat the regexp to look the standard way.
      my $re = "$v";
      $re =~ s,/,\\/,g;
      print "$sp-> qr/$re/\n";
      return;
    }

    if ( $item_type eq 'HASH' ) { 
        # Hash ref or hash-based object.
	my @@sortKeys = sort keys(%$v) ;
	undef $more ; 
	$tHashDepth = $#sortKeys ; 
	$tHashDepth = $#sortKeys < $hashDepth-1 ? $#sortKeys : $hashDepth-1
	  unless $hashDepth eq '' ; 
	$more = "....\n" if $tHashDepth < $#sortKeys ; 
	$shortmore = "";
	$shortmore = ", ..." if $tHashDepth < $#sortKeys ; 
	$#sortKeys = $tHashDepth ; 
	if ($compactDump && !grep(ref $_, values %{$v})) {
	  #$short = $sp . 
	  #  (join ', ', 
# Next row core dumps during require from DB on 5.000, even with map {"_"}
	  #   map {&stringify($_) . " => " . &stringify($v->{$_})} 
	  #   @@sortKeys) . "'$shortmore";
	  $short = $sp;
	  my @@keys;
	  for (@@sortKeys) {
	    push @@keys, &stringify($_) . " => " . &stringify($v->{$_});
	  }
	  $short .= join ', ', @@keys;
	  $short .= $shortmore;
	  (print "$short\n"), return if length $short <= $compactDump;
	}
	for $key (@@sortKeys) {
	    return if $DB::signal;
	    $value = $ {$v}{$key} ;
	    print "$sp", &stringify($key), " => ";
	    DumpElem $value, $s, $m-1;
	}
	print "$sp  empty hash\n" unless @@sortKeys;
	print "$sp$more" if defined $more ;
    } elsif ( $item_type eq 'ARRAY' ) { 
        # Array ref or array-based object. Also: undef.
        # See how big the array is.
	$tArrayDepth = $#{$v} ; 
	undef $more ; 
        # Bigger than the max?
	$tArrayDepth = $#{$v} < $arrayDepth-1 ? $#{$v} : $arrayDepth-1 
	  if defined $arrayDepth && $arrayDepth ne '';
        # Yep. Don't show it all.
	$more = "....\n" if $tArrayDepth < $#{$v} ; 
	$shortmore = "";
	$shortmore = " ..." if $tArrayDepth < $#{$v} ;

	if ($compactDump && !grep(ref $_, @@{$v})) {
	  if ($#$v >= 0) {
	    $short = $sp . "0..$#{$v}  " . 
	      join(" ", 
		   map {exists $v->[$_] ? stringify $v->[$_] : "empty"} (0..$tArrayDepth)
		  ) . "$shortmore";
	  } else {
	    $short = $sp . "empty array";
	  }
	  (print "$short\n"), return if length $short <= $compactDump;
	}
	#if ($compactDump && $short = ShortArray($v)) {
	#  print "$short\n";
	#  return;
	#}
	for $num (0 .. $tArrayDepth) {
	    return if $DB::signal;
	    print "$sp$num  ";
	    if (exists $v->[$num]) {
                if (defined $v->[$num]) {
	          DumpElem $v->[$num], $s, $m-1;
                } 
                else {
                  print "undef\n";
                }
	    } else {
	    	print "empty slot\n";
	    }
	}
	print "$sp  empty array\n" unless @@$v;
	print "$sp$more" if defined $more ;  
    } elsif ( $item_type eq 'SCALAR' ) { 
            unless (defined $$v) {
              print "$sp-> undef\n";
              return;
            }
	    print "$sp-> ";
	    DumpElem $$v, $s, $m-1;
    } elsif ( $item_type eq 'REF' ) { 
	    print "$sp-> $$v\n";
            return unless defined $$v;
	    unwrap($$v, $s+3, $m-1);
    } elsif ( $item_type eq 'CODE' ) { 
            # Code object or reference.
	    print "$sp-> ";
	    dumpsub (0, $v);
    } elsif ( $item_type eq 'GLOB' ) {
      # Glob object or reference.
      print "$sp-> ",&stringify($$v,1),"\n";
      if ($globPrint) {
	$s += 3;
       dumpglob($s, "{$$v}", $$v, 1, $m-1);
      } elsif (defined ($fileno = eval {fileno($v)})) {
	print( (' ' x ($s+3)) .  "FileHandle({$$v}) => fileno($fileno)\n" );
      }
    } elsif (ref \$v eq 'GLOB') {
      # Raw glob (again?)
      if ($globPrint) {
       dumpglob($s, "{$v}", $v, 1, $m-1) if $globPrint;
      } elsif (defined ($fileno = eval {fileno(\$v)})) {
	print( (' ' x $s) .  "FileHandle({$v}) => fileno($fileno)\n" );
      }
    }
    };
    if ($@@) {
      print( (' ' x $s) .  "<< value could not be dumped: $@@ >>\n");
    }

    return;
}

sub matchlex {
  (my $var = $_[0]) =~ s/.//;
  $var eq $_[1] or 
    ($_[1] =~ /^([!~])(.)([\x00-\xff]*)/) and 
      ($1 eq '!') ^ (eval { $var =~ /$2$3/ });
}

sub matchvar {
  $_[0] eq $_[1] or 
    ($_[1] =~ /^([!~])(.)([\x00-\xff]*)/) and 
      ($1 eq '!') ^ (eval {($_[2] . "::" . $_[0]) =~ /$2$3/});
}

sub compactDump {
  $compactDump = shift if @@_;
  $compactDump = 6*80-1 if $compactDump and $compactDump < 2;
  $compactDump;
}

sub veryCompact {
  $veryCompact = shift if @@_;
  compactDump(1) if !$compactDump and $veryCompact;
  $veryCompact;
}

sub unctrlSet {
  if (@@_) {
    my $in = shift;
    if ($in eq 'unctrl' or $in eq 'quote') {
      $unctrl = $in;
    } else {
      print "Unknown value for 'unctrl'.\n";
    }
  }
  $unctrl;
}

sub quote {
  if (@@_ and $_[0] eq '"') {
    $tick = '"';
    $unctrl = 'quote';
  } elsif (@@_ and $_[0] eq 'auto') {
    $tick = 'auto';
    $unctrl = 'quote';
  } elsif (@@_) {		# Need to set
    $tick = "'";
    $unctrl = 'unctrl';
  }
  $tick;
}

sub dumpglob {
    return if $DB::signal;
    my ($off,$key, $val, $all, $m) = @@_;
    local(*entry) = $val;
    my $fileno;
    if (($key !~ /^_</ or $dumpDBFiles) and defined $entry) {
      print( (' ' x $off) . "\$", &unctrl($key), " = " );
      DumpElem $entry, 3+$off, $m;
    }
    if (($key !~ /^_</ or $dumpDBFiles) and @@entry) {
      print( (' ' x $off) . "\@@$key = (\n" );
      unwrap(\@@entry,3+$off,$m) ;
      print( (' ' x $off) .  ")\n" );
    }
    if ($key ne "main::" && $key ne "DB::" && %entry
	&& ($dumpPackages or $key !~ /::$/)
	&& ($key !~ /^_</ or $dumpDBFiles)
	&& !($package eq "dumpvar" and $key eq "stab")) {
      print( (' ' x $off) . "\%$key = (\n" );
      unwrap(\%entry,3+$off,$m) ;
      print( (' ' x $off) .  ")\n" );
    }
    if (defined ($fileno = eval{fileno(*entry)})) {
      print( (' ' x $off) .  "FileHandle($key) => fileno($fileno)\n" );
    }
    if ($all) {
      if (defined &entry) {
	dumpsub($off, $key);
      }
    }
}

sub dumplex {
  return if $DB::signal;
  my ($key, $val, $m, @@vars) = @@_;
  return if @@vars && !grep( matchlex($key, $_), @@vars );
  local %address;
  my $off = 0;  # It reads better this way
  my $fileno;
  if (UNIVERSAL::isa($val,'ARRAY')) {
    print( (' ' x $off) . "$key = (\n" );
    unwrap($val,3+$off,$m) ;
    print( (' ' x $off) .  ")\n" );
  }
  elsif (UNIVERSAL::isa($val,'HASH')) {
    print( (' ' x $off) . "$key = (\n" );
    unwrap($val,3+$off,$m) ;
    print( (' ' x $off) .  ")\n" );
  }
  elsif (UNIVERSAL::isa($val,'IO')) {
    print( (' ' x $off) .  "FileHandle($key) => fileno($fileno)\n" );
  }
  #  No lexical subroutines yet...
  #  elsif (UNIVERSAL::isa($val,'CODE')) {
  #    dumpsub($off, $$val);
  #  }
  else {
    print( (' ' x $off) . &unctrl($key), " = " );
    DumpElem $$val, 3+$off, $m;
  }
}

sub CvGV_name_or_bust {
  my $in = shift;
  return if $skipCvGV;		# Backdoor to avoid problems if XS broken...
  $in = \&$in;			# Hard reference...
  eval {require Devel::Peek; 1} or return;
  my $gv = Devel::Peek::CvGV($in) or return;
  *$gv{PACKAGE} . '::' . *$gv{NAME};
}

sub dumpsub {
    my ($off,$sub) = @@_;
    my $ini = $sub;
    my $s;
    $sub = $1 if $sub =~ /^\{\*(.*)\}$/;
    my $subref = defined $1 ? \&$sub : \&$ini;
    my $place = $DB::sub{$sub} || (($s = $subs{"$subref"}) && $DB::sub{$s})
      || (($s = CvGV_name_or_bust($subref)) && $DB::sub{$s})
      || ($subdump && ($s = findsubs("$subref")) && $DB::sub{$s});
    $place = '???' unless defined $place;
    $s = $sub unless defined $s;
    print( (' ' x $off) .  "&$s in $place\n" );
}

sub findsubs {
  return undef unless %DB::sub;
  my ($addr, $name, $loc);
  while (($name, $loc) = each %DB::sub) {
    $addr = \&$name;
    $subs{"$addr"} = $name;
  }
  $subdump = 0;
  $subs{ shift() };
}

sub main::dumpvar {
    my ($package,$m,@@vars) = @@_;
    local(%address,$key,$val,$^W);
    $package .= "::" unless $package =~ /::$/;
    *stab = *{"main::"};
    while ($package =~ /(\w+?::)/g){
      *stab = $ {stab}{$1};
    }
    local $TotalStrings = 0;
    local $Strings = 0;
    local $CompleteTotal = 0;
    while (($key,$val) = each(%stab)) {
      return if $DB::signal;
      next if @@vars && !grep( matchvar($key, $_), @@vars );
      if ($usageOnly) {
	globUsage(\$val, $key)
	  if ($package ne 'dumpvar' or $key ne 'stab')
	     and ref(\$val) eq 'GLOB';
      } else {
       dumpglob(0,$key, $val, 0, $m);
      }
    }
    if ($usageOnly) {
      print "String space: $TotalStrings bytes in $Strings strings.\n";
      $CompleteTotal += $TotalStrings;
      print "Grand total = $CompleteTotal bytes (1 level deep) + overhead.\n";
    }
}

sub scalarUsage {
  my $size = length($_[0]);
  $TotalStrings += $size;
  $Strings++;
  $size;
}

sub arrayUsage {		# array ref, name
  my $size = 0;
  map {$size += scalarUsage($_)} @@{$_[0]};
  my $len = @@{$_[0]};
  print "\@@$_[1] = $len item", ($len > 1 ? "s" : ""),
    " (data: $size bytes)\n"
      if defined $_[1];
  $CompleteTotal +=  $size;
  $size;
}

sub hashUsage {		# hash ref, name
  my @@keys = keys %{$_[0]};
  my @@values = values %{$_[0]};
  my $keys = arrayUsage \@@keys;
  my $values = arrayUsage \@@values;
  my $len = @@keys;
  my $total = $keys + $values;
  print "\%$_[1] = $len item", ($len > 1 ? "s" : ""),
    " (keys: $keys; values: $values; total: $total bytes)\n"
      if defined $_[1];
  $total;
}

sub globUsage {			# glob ref, name
  local *name = *{$_[0]};
  $total = 0;
  $total += scalarUsage $name if defined $name;
  $total += arrayUsage \@@name, $_[1] if @@name;
  $total += hashUsage \%name, $_[1] if %name and $_[1] ne "main::" 
    and $_[1] ne "DB::";   #and !($package eq "dumpvar" and $key eq "stab"));
  $total;
}

sub packageUsage {
  my ($package,@@vars) = @@_;
  $package .= "::" unless $package =~ /::$/;
  local *stab = *{"main::"};
  while ($package =~ /(\w+?::)/g){
    *stab = $ {stab}{$1};
  }
  local $TotalStrings = 0;
  local $CompleteTotal = 0;
  my ($key,$val);
  while (($key,$val) = each(%stab)) {
    next if @@vars && !grep($key eq $_,@@vars);
    globUsage \$val, $key unless $package eq 'dumpvar' and $key eq 'stab';
  }
  print "String space: $TotalStrings.\n";
  $CompleteTotal += $TotalStrings;
  print "\nGrand total = $CompleteTotal bytes\n";
}

1;

@


1.10
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d17 2
d30 3
d49 2
a50 6
        if (ord('A') == 193) { # EBCDIC.
	    # EBCDIC has no concept of "\cA" or "A" being related
	    # to each other by a linear/boolean mapping.
	} else {
	    s/([\001-\037\177])/'^'.pack('c',ord($1)^64)/eg;
	}
d58 1
a58 1
	     unpack("U*", $_[0]));
d83 5
a87 13
	    if (ord('A') == 193) {
		if (/[\000-\011]/ or /[\013-\024\31-\037\177]/) {
		    $tick = '"';
		} else {
		    $tick = "'";
		}
            }  else {
		if (/[\000-\011\013-\037\177]/) {
		    $tick = '"';
		} else {
		    $tick = "'";
		}
	    }
d93 1
a93 1
	  s/([\000-\037\177])/'^'.pack('c',ord($1)^64)/eg;
d95 1
a95 1
	  s/([\200-\377])/'\\0x'.sprintf('%2X',ord($1))/eg 
d99 2
a100 6
	  s/\033/\\e/g;
	  if (ord('A') == 193) { # EBCDIC.
	      s/([\000-\037\177])/'\\c'.chr(193)/eg; # Unfinished.
	  } else {
	      s/([\000-\037\177])/'\\c'._escaped_ord($1)/eg;
	  }
d103 1
a103 1
	s/([\200-\377])/'\\'.sprintf('%3o',ord($1))/eg if $quoteHighBit;
d113 7
a119 2
    $chr = chr(ord($chr)^64);
    $chr =~ s{\\}{\\\\}g;
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d1 1
a1 1
require 5.002;			# For (defined ref)
d61 9
d172 1
d325 6
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d40 1
a40 1
	local($_) = @@_;
d50 2
a51 1
	$_;
d61 2
a62 1
	local($_,$noticks) = @@_;
d106 1
a106 1
	($noticks || /^\d+(\.\d*)?\Z/) 
d109 1
d171 1
a171 2
      ($start_part, $val) = split /=/,$val;
      $val = $start_part unless defined $val;
d256 1
a256 1
		   map {exists $v->[$_] ? stringify $v->[$_] : "empty"} ($[..$tArrayDepth)
d267 1
a267 1
	for $num ($[ .. $tArrayDepth) {
d348 1
a348 1
      print "Unknown value for `unctrl'.\n";
@


1.7
log
@merge in perl 5.8.8
@
text
@d44 6
a49 1
	s/([\001-\037\177])/'^'.pack('c',ord($1)^64)/eg;
d71 13
a83 5
	  if (/[\000-\011\013-\037\177]/) {
	    $tick = '"';
	  }else {
	    $tick = "'";
	  }
d96 5
a100 1
	  s/([\000-\037\177])/'\\c'._escaped_ord($1)/eg;
d302 1
a302 1
      } elsif (defined ($fileno = fileno($v))) {
d309 1
a309 1
      } elsif (defined ($fileno = fileno(\$v))) {
d388 1
a388 1
    if (defined ($fileno = fileno(*entry))) {
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d83 1
a83 1
	  s/([\000-\037\177])/'\\c'.chr(ord($1)^64)/eg;
d90 8
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d33 2
a34 1
  dumpvar::unwrap($_[0],0, $_[1]);
d119 1
a119 1
    unwrap($_[0],$_[1],$_[2]);
d140 13
a152 1
      ($address) = $val =~ /(0x[0-9a-f]+)\)$/ ; 
d161 1
d171 1
d178 3
a180 2
    if ( UNIVERSAL::isa($v, 'HASH') ) { 
	@@sortKeys = sort keys(%$v) ;
d212 3
a214 1
    } elsif ( UNIVERSAL::isa($v, 'ARRAY') ) { 
d217 1
d220 1
d224 1
d244 6
a249 1
	        DumpElem $v->[$num], $s, $m-1;
d256 5
a260 1
    } elsif (  UNIVERSAL::isa($v, 'SCALAR') or ref $v eq 'REF' ) { 
d263 6
a268 1
    } elsif ( UNIVERSAL::isa($v, 'CODE') ) { 
d271 2
a272 1
    } elsif ( UNIVERSAL::isa($v, 'GLOB') ) {
d281 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d33 1
a33 1
  dumpvar::unwrap($_[0],0);
d47 6
d76 1
d84 1
d118 1
a118 1
    unwrap($_[0],$_[1]);
d126 2
d192 1
a192 1
	    DumpElem $value, $s;
d200 1
a200 1
	  unless  $arrayDepth eq '' ; 
d223 1
a223 1
	        DumpElem $v->[$num], $s;
d232 1
a232 1
	    DumpElem $$v, $s;
d240 1
a240 1
	dumpglob($s, "{$$v}", $$v, 1);
d246 1
a246 1
	dumpglob($s, "{$v}", $v, 1) if $globPrint;
d253 7
d306 1
a306 1
    my ($off,$key, $val, $all) = @@_;
d311 1
a311 1
      DumpElem $entry, 3+$off;
d315 1
a315 1
      unwrap(\@@entry,3+$off) ;
d323 1
a323 1
      unwrap(\%entry,3+$off) ;
d336 30
d401 1
a401 1
    my ($package,@@vars) = @@_;
d419 1
a419 1
	dumpglob(0,$key, $val);
@


1.3
log
@perl5.005_03 (stock)
@
text
@d56 1
a56 1
	    and defined %overload:: and defined &{'overload::StrVal'};
d128 1
a128 1
	if defined %overload:: and defined &{'overload::StrVal'};
d146 7
d198 2
a199 2
		   map {stringify $_} @@{$v}[0..$tArrayDepth])
		. "$shortmore";
d212 5
a216 1
	    DumpElem $v->[$num], $s;
d296 1
a296 1
    if (($key !~ /^_</ or $dumpDBFiles) and defined @@entry) {
d301 1
a301 1
    if ($key ne "main::" && $key ne "DB::" && defined %entry
d319 9
d330 2
d333 4
a336 3
    my $subref = \&$sub;
    my $place = $DB::sub{$sub} || (($sub = $subs{"$subref"}) && $DB::sub{$sub})
      || ($subdump && ($sub = findsubs("$subref")) && $DB::sub{$sub});
d338 2
a339 1
    print( (' ' x $off) .  "&$sub in $place\n" );
d343 1
a343 1
  return undef unless defined %DB::sub;
d368 3
a370 1
	globUsage(\$val, $key) unless $package eq 'dumpvar' and $key eq 'stab';
d417 2
a418 2
  $total += arrayUsage \@@name, $_[1] if defined @@name;
  $total += hashUsage \%name, $_[1] if defined %name and $_[1] ne "main::" 
@


1.2
log
@perl 5.004_04
@
text
@d25 2
d54 4
d118 1
a118 1
    local(%v,@@v,$sp,$value,$key,$type,@@sortKeys,$more,$shortmore,$short) ;
d126 5
a130 3
      ($address) = $v =~ /(0x[0-9a-f]+)\)$/ ; 
      if (defined $address) { 
	($type) = $v =~ /=(.*?)\([^=]+$/ ;
@


1.1
log
@Initial revision
@
text
@d28 1
d120 1
a120 1
      ($address) = $v =~ /(0x[0-9a-f]+)/ ; 
d122 1
a122 1
	($type) = $v =~ /=(.*?)\(/ ;
d138 1
a138 1
    if ( ref $v eq 'HASH' or $type eq 'HASH') { 
d171 1
a171 1
    } elsif ( ref $v eq 'ARRAY' or $type eq 'ARRAY') { 
d201 1
a201 1
    } elsif ( ref $v eq 'SCALAR' or ref $v eq 'REF' or $type eq 'SCALAR' ) { 
d204 1
a204 1
    } elsif ( ref $v eq 'CODE' or $type eq 'CODE' ) { 
d207 1
a207 1
    } elsif (ref $v eq 'GLOB') {
d226 2
a227 2
    ($_[1] =~ /^([!~])(.)/) and 
      ($1 eq '!') ^ (eval {($_[2] . "::" . $_[0]) =~ /$2$'/});
d323 1
a323 1
    local(%address,$key,$val);
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a24 2
$dumpReused = 0 unless defined $dumpReused;
$bareStringify = 1 unless defined $bareStringify;
a27 1
  local $^W=0;
a50 4
	$_ = &{'overload::StrVal'}($_) 
	  if $bareStringify and ref $_ 
	    and defined %overload:: and defined &{'overload::StrVal'};
	
d111 1
a111 1
    local(%v,@@v,$sp,$value,$key,@@sortKeys,$more,$shortmore,$short) ;
d119 3
a121 5
      my $val = $v;
      $val = &{'overload::StrVal'}($v) 
	if defined %overload:: and defined &{'overload::StrVal'};
      ($address) = $val =~ /(0x[0-9a-f]+)\)$/ ; 
      if (!$dumpReused && defined $address) { 
d137 1
a137 1
    if ( UNIVERSAL::isa($v, 'HASH') ) { 
d170 1
a170 1
    } elsif ( UNIVERSAL::isa($v, 'ARRAY') ) { 
d200 1
a200 1
    } elsif (  UNIVERSAL::isa($v, 'SCALAR') or ref $v eq 'REF' ) { 
d203 1
a203 1
    } elsif ( UNIVERSAL::isa($v, 'CODE') ) { 
d206 1
a206 1
    } elsif ( UNIVERSAL::isa($v, 'GLOB') ) {
d225 2
a226 2
    ($_[1] =~ /^([!~])(.)([\x00-\xff]*)/) and 
      ($1 eq '!') ^ (eval {($_[2] . "::" . $_[0]) =~ /$2$3/});
d322 1
a322 1
    local(%address,$key,$val,$^W);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d56 1
a56 1
	    and %overload:: and defined &{'overload::StrVal'};
d128 1
a128 1
	if %overload:: and defined &{'overload::StrVal'};
a145 7
    if (ref $v eq 'Regexp') {
      my $re = "$v";
      $re =~ s,/,\\/,g;
      print "$sp-> qr/$re/\n";
      return;
    }

d191 2
a192 2
		   map {exists $v->[$_] ? stringify $v->[$_] : "empty"} ($[..$tArrayDepth)
		  ) . "$shortmore";
d205 1
a205 5
	    if (exists $v->[$num]) {
	        DumpElem $v->[$num], $s;
	    } else {
	    	print "empty slot\n";
	    }
d285 1
a285 1
    if (($key !~ /^_</ or $dumpDBFiles) and @@entry) {
d290 1
a290 1
    if ($key ne "main::" && $key ne "DB::" && %entry
a307 9
sub CvGV_name_or_bust {
  my $in = shift;
  return if $skipCvGV;		# Backdoor to avoid problems if XS broken...
  $in = \&$in;			# Hard reference...
  eval {require Devel::Peek; 1} or return;
  my $gv = Devel::Peek::CvGV($in) or return;
  *$gv{PACKAGE} . '::' . *$gv{NAME};
}

a309 2
    my $ini = $sub;
    my $s;
d311 3
a313 4
    my $subref = defined $1 ? \&$sub : \&$ini;
    my $place = $DB::sub{$sub} || (($s = $subs{"$subref"}) && $DB::sub{$s})
      || (($s = CvGV_name_or_bust($subref)) && $DB::sub{$s})
      || ($subdump && ($s = findsubs("$subref")) && $DB::sub{$s});
d315 1
a315 2
    $s = $sub unless defined $s;
    print( (' ' x $off) .  "&$s in $place\n" );
d319 1
a319 1
  return undef unless %DB::sub;
d344 1
a344 3
	globUsage(\$val, $key)
	  if ($package ne 'dumpvar' or $key ne 'stab')
	     and ref(\$val) eq 'GLOB';
d391 2
a392 2
  $total += arrayUsage \@@name, $_[1] if @@name;
  $total += hashUsage \%name, $_[1] if %name and $_[1] ne "main::" 
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d33 1
a33 1
  dumpvar::unwrap($_[0],0, $_[1]);
a46 6
sub uniescape {
    join("",
	 map { $_ > 255 ? sprintf("\\x{%04X}", $_) : chr($_) }
	     unpack("U*", $_[0]));
}

a69 1
	  # uniescape?
a76 1
	$_ = uniescape($_);
d110 1
a110 1
    unwrap($_[0],$_[1],$_[2]);
a117 2
    local($m) = shift ; # maximum recursion depth
    return if $m == 0;
d182 1
a182 1
	    DumpElem $value, $s, $m-1;
d190 1
a190 1
	  if defined $arrayDepth && $arrayDepth ne '';
d213 1
a213 1
	        DumpElem $v->[$num], $s, $m-1;
d222 1
a222 1
	    DumpElem $$v, $s, $m-1;
d230 1
a230 1
       dumpglob($s, "{$$v}", $$v, 1, $m-1);
d236 1
a236 1
       dumpglob($s, "{$v}", $v, 1, $m-1) if $globPrint;
a242 7
sub matchlex {
  (my $var = $_[0]) =~ s/.//;
  $var eq $_[1] or 
    ($_[1] =~ /^([!~])(.)([\x00-\xff]*)/) and 
      ($1 eq '!') ^ (eval { $var =~ /$2$3/ });
}

d289 1
a289 1
    my ($off,$key, $val, $all, $m) = @@_;
d294 1
a294 1
      DumpElem $entry, 3+$off, $m;
d298 1
a298 1
      unwrap(\@@entry,3+$off,$m) ;
d306 1
a306 1
      unwrap(\%entry,3+$off,$m) ;
a318 30
sub dumplex {
  return if $DB::signal;
  my ($key, $val, $m, @@vars) = @@_;
  return if @@vars && !grep( matchlex($key, $_), @@vars );
  local %address;
  my $off = 0;  # It reads better this way
  my $fileno;
  if (UNIVERSAL::isa($val,'ARRAY')) {
    print( (' ' x $off) . "$key = (\n" );
    unwrap($val,3+$off,$m) ;
    print( (' ' x $off) .  ")\n" );
  }
  elsif (UNIVERSAL::isa($val,'HASH')) {
    print( (' ' x $off) . "$key = (\n" );
    unwrap($val,3+$off,$m) ;
    print( (' ' x $off) .  ")\n" );
  }
  elsif (UNIVERSAL::isa($val,'IO')) {
    print( (' ' x $off) .  "FileHandle($key) => fileno($fileno)\n" );
  }
  #  No lexical subroutines yet...
  #  elsif (UNIVERSAL::isa($val,'CODE')) {
  #    dumpsub($off, $$val);
  #  }
  else {
    print( (' ' x $off) . &unctrl($key), " = " );
    DumpElem $$val, 3+$off, $m;
  }
}

d354 1
a354 1
    my ($package,$m,@@vars) = @@_;
d372 1
a372 1
       dumpglob(0,$key, $val, 0, $m);
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d33 1
a33 2
  push @@_, -1 if @@_ == 1;
  dumpvar::unwrap($_[0], 0, $_[1]);
d118 1
a118 1
    unwrap($_[0],$_[1],$_[2]) if ref $_[0];
d139 1
a139 13
      # Match type and address.                      
      # Unblessed references will look like TYPE(0x...)
      # Blessed references will look like Class=TYPE(0x...)
      ($start_part, $val) = split /=/,$val;
      $val = $start_part unless defined $val;
      ($item_type, $address) = 
        $val =~ /([^\(]+)        # Keep stuff that's     
                                 # not an open paren
                 \(              # Skip open paren
                 (0x[0-9a-f]+)   # Save the address
                 \)              # Skip close paren
                 $/x;            # Should be at end now

a147 1
      # This is a raw glob. Special handling for that.
a156 1
      # Reformat the regexp to look the standard way.
d163 2
a164 3
    if ( $item_type eq 'HASH' ) { 
        # Hash ref or hash-based object.
	my @@sortKeys = sort keys(%$v) ;
d196 1
a196 3
    } elsif ( $item_type eq 'ARRAY' ) { 
        # Array ref or array-based object. Also: undef.
        # See how big the array is.
a198 1
        # Bigger than the max?
a200 1
        # Yep. Don't show it all.
a203 1

d223 1
a223 6
                if (defined $v->[$num]) {
	          DumpElem $v->[$num], $s, $m-1;
                } 
                else {
                  print "undef\n";
                }
d230 1
a230 5
    } elsif ( $item_type eq 'SCALAR' ) { 
            unless (defined $$v) {
              print "$sp-> undef\n";
              return;
            }
d233 1
a233 6
    } elsif ( $item_type eq 'REF' ) { 
	    print "$sp-> $$v\n";
            return unless defined $$v;
	    unwrap($$v, $s+3, $m-1);
    } elsif ( $item_type eq 'CODE' ) { 
            # Code object or reference.
d236 1
a236 2
    } elsif ( $item_type eq 'GLOB' ) {
      # Glob object or reference.
a244 1
      # Raw glob (again?)
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d83 1
a83 1
	  s/([\000-\037\177])/'\\c'._escaped_ord($1)/eg;
a89 8
}

# Ensure a resulting \ is escaped to be \\
sub _escaped_ord {
    my $chr = shift;
    $chr = chr(ord($chr)^64);
    $chr =~ s{\\}{\\\\}g;
    return $chr;
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d44 1
a44 6
        if (ord('A') == 193) { # EBCDIC.
	    # EBCDIC has no concept of "\cA" or "A" being related
	    # to each other by a linear/boolean mapping.
	} else {
	    s/([\001-\037\177])/'^'.pack('c',ord($1)^64)/eg;
	}
d66 5
a70 13
	    if (ord('A') == 193) {
		if (/[\000-\011]/ or /[\013-\024\31-\037\177]/) {
		    $tick = '"';
		} else {
		    $tick = "'";
		}
            }  else {
		if (/[\000-\011\013-\037\177]/) {
		    $tick = '"';
		} else {
		    $tick = "'";
		}
	    }
d83 1
a83 5
	  if (ord('A') == 193) { # EBCDIC.
	      s/([\000-\037\177])/'\\c'.chr(193)/eg; # Unfinished.
	  } else {
	      s/([\000-\037\177])/'\\c'._escaped_ord($1)/eg;
	  }
d285 1
a285 1
      } elsif (defined ($fileno = eval {fileno($v)})) {
d292 1
a292 1
      } elsif (defined ($fileno = eval {fileno(\$v)})) {
d371 1
a371 1
    if (defined ($fileno = eval{fileno(*entry)})) {
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d40 1
a40 1
    for (my($dummy) = shift) {
d50 1
a50 2
	return $_;
    }
d60 1
a60 2
    (my $__, local $noticks) = @@_;
    for ($__) {
d104 1
a104 1
	return ($noticks || /^\d+(\.\d*)?\Z/) 
a106 1
    }
d168 2
a169 1
      $val =~ s/^.*=//; # suppress the Class part, just keep TYPE(0x...)
d254 1
a254 1
		   map {exists $v->[$_] ? stringify $v->[$_] : "empty"} (0..$tArrayDepth)
d265 1
a265 1
	for $num (0 .. $tArrayDepth) {
d346 1
a346 1
      print "Unknown value for 'unctrl'.\n";
@


1.1.1.9
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d1 1
a1 1
require 5.014;			# For more reliable $@@ after eval
a60 9
  my $string;
  if (eval { $string = _stringify(@@_); 1 }) {
    return $string;
  }

  return "<< value could not be dumped: $@@ >>";
}

sub _stringify {
a162 1
    eval {
a314 6
    };
    if ($@@) {
      print( (' ' x $s) .  "<< value could not be dumped: $@@ >>\n");
    }

    return;
@


1.1.1.10
log
@Import perl-5.24.2
@
text
@a16 2
sub ASCII { return ord('A') == 65; }

a27 3
my $APC = chr utf8::unicode_to_native(0x9F);
my $backslash_c_question = (ASCII) ? '\177' : $APC;

d44 6
a49 2
        s/([\000-\037])/ '^' . chr(utf8::unicode_to_native(ord($1)^64))/eg;
        s/ $backslash_c_question /^?/xg;
d57 1
a57 1
	     unpack("W*", $_[0]));
d82 13
a94 5
            if (/[^[:^cntrl:]\n]/u) {   # All controls but \n get '"'
                $tick = '"';
            } else {
                $tick = "'";
            }
d100 1
a100 1
          $_ = &unctrl($_);
d102 1
a102 1
	  s/([[:^ascii:]])/'\\0x'.sprintf('%2X',ord($1))/eg
d106 6
a111 2
	  s/\e/\\e/g;
          s/([\000-\037$backslash_c_question])/'\\c'._escaped_ord($1)/eg;
d114 1
a114 1
	s/([[:^ascii:]])/'\\'.sprintf('%3o',ord($1))/eg if $quoteHighBit;
d124 2
a125 7
    if ($chr eq $backslash_c_question) {
        $chr = '?';
    }
    else {
        $chr = chr(utf8::unicode_to_native(ord($chr)^64));
        $chr =~ s{\\}{\\\\}g;
    }
@


