head	1.5;
access;
symbols
	OPENBSD_6_0:1.5.0.30
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.24
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.26
	OPENBSD_5_8_BASE:1.5
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.5.0.18
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.5.0.22
	OPENBSD_5_6_BASE:1.5
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.5.0.20
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.16
	OPENBSD_5_4_BASE:1.5
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.4.0.6
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.2
	OPENBSD_4_5_BASE:1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.3.0.24
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.22
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.20
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.18
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.16
	OPENBSD_4_0_BASE:1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.3.0.14
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.12
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.10
	OPENBSD_3_7_BASE:1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.3.0.8
	OPENBSD_3_6_BASE:1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.0.8
	OPENBSD_2_6_BASE:1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.17.06.34;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.57.36;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.09;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.34;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.58;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.5
log
@Merge in perl 5.10.1
@
text
@package File::Compare;

use 5.006;
use strict;
use warnings;
our($VERSION, @@ISA, @@EXPORT, @@EXPORT_OK, $Too_Big);

require Exporter;

$VERSION = '1.1006';
@@ISA = qw(Exporter);
@@EXPORT = qw(compare);
@@EXPORT_OK = qw(cmp compare_text);

$Too_Big = 1024 * 1024 * 2;

sub croak {
    require Carp;
    goto &Carp::croak;
}

sub compare {
    croak("Usage: compare( file1, file2 [, buffersize]) ")
      unless(@@_ == 2 || @@_ == 3);

    my ($from,$to,$size) = @@_;
    my $text_mode = defined($size) && (ref($size) eq 'CODE' || $size < 0);

    my ($fromsize,$closefrom,$closeto);
    local (*FROM, *TO);

    croak("from undefined") unless (defined $from);
    croak("to undefined") unless (defined $to);

    if (ref($from) && 
        (UNIVERSAL::isa($from,'GLOB') || UNIVERSAL::isa($from,'IO::Handle'))) {
	*FROM = *$from;
    } elsif (ref(\$from) eq 'GLOB') {
	*FROM = $from;
    } else {
	open(FROM,"<",$from) or goto fail_open1;
	unless ($text_mode) {
	    binmode FROM;
	    $fromsize = -s FROM;
	}
	$closefrom = 1;
    }

    if (ref($to) &&
        (UNIVERSAL::isa($to,'GLOB') || UNIVERSAL::isa($to,'IO::Handle'))) {
	*TO = *$to;
    } elsif (ref(\$to) eq 'GLOB') {
	*TO = $to;
    } else {
	open(TO,"<",$to) or goto fail_open2;
	binmode TO unless $text_mode;
	$closeto = 1;
    }

    if (!$text_mode && $closefrom && $closeto) {
	# If both are opened files we know they differ if their size differ
	goto fail_inner if $fromsize != -s TO;
    }

    if ($text_mode) {
	local $/ = "\n";
	my ($fline,$tline);
	while (defined($fline = <FROM>)) {
	    goto fail_inner unless defined($tline = <TO>);
	    if (ref $size) {
		# $size contains ref to comparison function
		goto fail_inner if &$size($fline, $tline);
	    } else {
		goto fail_inner if $fline ne $tline;
	    }
	}
	goto fail_inner if defined($tline = <TO>);
    }
    else {
	unless (defined($size) && $size > 0) {
	    $size = $fromsize || -s TO || 0;
	    $size = 1024 if $size < 512;
	    $size = $Too_Big if $size > $Too_Big;
	}

	my ($fr,$tr,$fbuf,$tbuf);
	$fbuf = $tbuf = '';
	while(defined($fr = read(FROM,$fbuf,$size)) && $fr > 0) {
	    unless (defined($tr = read(TO,$tbuf,$fr)) && $tbuf eq $fbuf) {
		goto fail_inner;
	    }
	}
	goto fail_inner if defined($tr = read(TO,$tbuf,$size)) && $tr > 0;
    }

    close(TO) || goto fail_open2 if $closeto;
    close(FROM) || goto fail_open1 if $closefrom;

    return 0;
    
  # All of these contortions try to preserve error messages...
  fail_inner:
    close(TO) || goto fail_open2 if $closeto;
    close(FROM) || goto fail_open1 if $closefrom;

    return 1;

  fail_open2:
    if ($closefrom) {
	my $status = $!;
	$! = 0;
	close FROM;
	$! = $status unless $!;
    }
  fail_open1:
    return -1;
}

sub cmp;
*cmp = \&compare;

sub compare_text {
    my ($from,$to,$cmp) = @@_;
    croak("Usage: compare_text( file1, file2 [, cmp-function])")
	unless @@_ == 2 || @@_ == 3;
    croak("Third arg to compare_text() function must be a code reference")
	if @@_ == 3 && ref($cmp) ne 'CODE';

    # Using a negative buffer size puts compare into text_mode too
    $cmp = -1 unless defined $cmp;
    compare($from, $to, $cmp);
}

1;

__END__

=head1 NAME

File::Compare - Compare files or filehandles

=head1 SYNOPSIS

  	use File::Compare;

	if (compare("file1","file2") == 0) {
	    print "They're equal\n";
	}

=head1 DESCRIPTION

The File::Compare::compare function compares the contents of two
sources, each of which can be a file or a file handle.  It is exported
from File::Compare by default.

File::Compare::cmp is a synonym for File::Compare::compare.  It is
exported from File::Compare only by request.

File::Compare::compare_text does a line by line comparison of the two
files. It stops as soon as a difference is detected. compare_text()
accepts an optional third argument: This must be a CODE reference to
a line comparison function, which returns 0 when both lines are considered
equal. For example:

    compare_text($file1, $file2)

is basically equivalent to

    compare_text($file1, $file2, sub {$_[0] ne $_[1]} )

=head1 RETURN

File::Compare::compare and its sibling functions return 0 if the files
are equal, 1 if the files are unequal, or -1 if an error was encountered.

=head1 AUTHOR

File::Compare was written by Nick Ing-Simmons.
Its original documentation was written by Chip Salzenberg.

=cut

@


1.4
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d10 1
a10 1
$VERSION = '1.1005';
@


1.3
log
@Resolve conflicts, remove old files, merge local changes
@
text
@a8 1
use Carp;
d10 1
a10 1
$VERSION = '1.1003';
d17 5
d41 1
a41 1
	open(FROM,"<$from") or goto fail_open1;
d55 1
a55 1
	open(TO,"<$to") or goto fail_open2;
@


1.2
log
@perl-5.6.0 + local changes
@
text
@d3 1
a3 1
use 5.005_64;
d5 1
d11 1
a11 1
$VERSION = '1.1002';
a17 5
sub VERSION {
    # Version of File::Compare
    return $File::Compare::VERSION;
}

d169 2
a170 2
File::Compare::compare return 0 if the files are equal, 1 if the
files are unequal, or -1 if an error was encountered.
@


1.1
log
@perl 5.004_04
@
text
@d3 1
d5 1
a5 1
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK $Too_Big *FROM *TO);
d10 1
a10 1
$VERSION = '1.1001';
d13 1
a13 1
@@EXPORT_OK = qw(cmp);
d26 5
a30 7
    my $from = shift;
    my $to = shift;
    my $closefrom=0;
    my $closeto=0;
    my ($size, $fromsize, $status, $fr, $tr, $fbuf, $tbuf);
    local(*FROM, *TO);
    local($\) = '';
d42 4
a45 1
	binmode FROM;
a46 1
	$fromsize = -s FROM;
d56 1
a56 1
	binmode TO;
d60 1
a60 1
    if ($closefrom && $closeto) {
d65 13
a77 7
    if (@@_) {
	$size = shift(@@_) + 0;
	croak("Bad buffer size for compare: $size\n") unless ($size > 0);
    } else {
	$size = $fromsize;
	$size = 1024 if ($size < 512);
	$size = $Too_Big if ($size > $Too_Big);
d79 6
d86 6
a91 5
    $fbuf = '';
    $tbuf = '';
    while(defined($fr = read(FROM,$fbuf,$size)) && $fr > 0) {
	unless (defined($tr = read(TO,$tbuf,$fr)) and $tbuf eq $fbuf) {
            goto fail_inner;
d93 1
a94 1
    goto fail_inner if (defined($tr = read(TO,$tbuf,$size)) && $tr > 0);
d110 1
a110 1
	$status = $!;
d119 1
d122 12
d158 12
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a2 1
use 5.005_64;
d4 1
a4 1
our($VERSION, @@ISA, @@EXPORT, @@EXPORT_OK, $Too_Big);
d9 1
a9 1
$VERSION = '1.1002';
d12 1
a12 1
@@EXPORT_OK = qw(cmp compare_text);
d25 7
a31 5
    my ($from,$to,$size) = @@_;
    my $text_mode = defined($size) && (ref($size) eq 'CODE' || $size < 0);

    my ($fromsize,$closefrom,$closeto);
    local (*FROM, *TO);
d43 1
a43 4
	unless ($text_mode) {
	    binmode FROM;
	    $fromsize = -s FROM;
	}
d45 1
d55 1
a55 1
	binmode TO unless $text_mode;
d59 1
a59 1
    if (!$text_mode && $closefrom && $closeto) {
d64 7
a70 13
    if ($text_mode) {
	local $/ = "\n";
	my ($fline,$tline);
	while (defined($fline = <FROM>)) {
	    goto fail_inner unless defined($tline = <TO>);
	    if (ref $size) {
		# $size contains ref to comparison function
		goto fail_inner if &$size($fline, $tline);
	    } else {
		goto fail_inner if $fline ne $tline;
	    }
	}
	goto fail_inner if defined($tline = <TO>);
a71 6
    else {
	unless (defined($size) && $size > 0) {
	    $size = $fromsize || -s TO || 0;
	    $size = 1024 if $size < 512;
	    $size = $Too_Big if $size > $Too_Big;
	}
d73 5
a77 6
	my ($fr,$tr,$fbuf,$tbuf);
	$fbuf = $tbuf = '';
	while(defined($fr = read(FROM,$fbuf,$size)) && $fr > 0) {
	    unless (defined($tr = read(TO,$tbuf,$fr)) && $tbuf eq $fbuf) {
		goto fail_inner;
	    }
a78 1
	goto fail_inner if defined($tr = read(TO,$tbuf,$size)) && $tr > 0;
d80 1
d96 1
a96 1
	my $status = $!;
a104 1
sub cmp;
a106 12
sub compare_text {
    my ($from,$to,$cmp) = @@_;
    croak("Usage: compare_text( file1, file2 [, cmp-function])")
	unless @@_ == 2 || @@_ == 3;
    croak("Third arg to compare_text() function must be a code reference")
	if @@_ == 3 && ref($cmp) ne 'CODE';

    # Using a negative buffer size puts compare into text_mode too
    $cmp = -1 unless defined $cmp;
    compare($from, $to, $cmp);
}

a130 12

File::Compare::compare_text does a line by line comparison of the two
files. It stops as soon as a difference is detected. compare_text()
accepts an optional third argument: This must be a CODE reference to
a line comparison function, which returns 0 when both lines are considered
equal. For example:

    compare_text($file1, $file2)

is basically equivalent to

    compare_text($file1, $file2, sub {$_[0] ne $_[1]} )
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
use 5.006;
a4 1
use warnings;
d10 1
a10 1
$VERSION = '1.1003';
d17 5
d173 2
a174 2
File::Compare::compare and its sibling functions return 0 if the files
are equal, 1 if the files are unequal, or -1 if an error was encountered.
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d9 1
d11 1
a11 1
$VERSION = '1.1005';
a17 5
sub croak {
    require Carp;
    goto &Carp::croak;
}

d37 1
a37 1
	open(FROM,"<",$from) or goto fail_open1;
d51 1
a51 1
	open(TO,"<",$to) or goto fail_open2;
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d10 1
a10 1
$VERSION = '1.1006';
@


