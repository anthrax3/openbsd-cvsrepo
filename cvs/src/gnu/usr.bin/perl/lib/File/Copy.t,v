head	1.2;
access;
symbols
	OPENBSD_6_2_BASE:1.2
	PERL_5_24_2:1.1.1.10
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.9.0.10
	OPENBSD_6_0_BASE:1.1.1.9
	OPENBSD_5_9:1.1.1.9.0.4
	OPENBSD_5_9_BASE:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.6
	OPENBSD_5_8_BASE:1.1.1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.2
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.4
	OPENBSD_5_6_BASE:1.1.1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.8
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.6
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.4
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.2
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.04.07.21.13.17;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.48.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.34;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.59;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.48.41;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.08.54;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.08;	author afresh1;	state Exp;
branches;
next	1.1.1.10;
commitid	B31cAbBIXiCqnL97;

1.1.1.10
date	2017.08.14.13.46.14;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -w

BEGIN {
   if( $ENV{PERL_CORE} ) {
        chdir 't' if -d 't';
        @@INC = '../lib';
    }
}

use strict;
use warnings;

use Test::More;

my $TB = Test::More->builder;

plan tests => 466;

# We are going to override rename() later on but Perl has to see an override
# at compile time to honor it.
BEGIN { *CORE::GLOBAL::rename = sub { CORE::rename($_[0], $_[1]) }; }


use File::Copy qw(copy move cp);
use Config;


foreach my $code ("copy()", "copy('arg')", "copy('arg', 'arg', 'arg', 'arg')",
                  "move()", "move('arg')", "move('arg', 'arg', 'arg')"
                 )
{
    eval $code;
    like $@@, qr/^Usage: /, "'$code' is a usage error";
}


for my $cross_partition_test (0..1) {
  {
    # Simulate a cross-partition copy/move by forcing rename to
    # fail.
    no warnings 'redefine';
    *CORE::GLOBAL::rename = sub { 0 } if $cross_partition_test;
  }

  # First we create a file
  open(F, ">file-$$") or die $!;
  binmode F; # for DOSISH platforms, because test 3 copies to stdout
  printf F "ok\n";
  close F;

  copy "file-$$", "copy-$$";

  open(F, "copy-$$") or die $!;
  my $foo = <F>;
  close(F);

  is -s "file-$$", -s "copy-$$", 'copy(fn, fn): files of the same size';

  is $foo, "ok\n", 'copy(fn, fn): same contents';

  print("# next test checks copying to STDOUT\n");
  binmode STDOUT unless $^O eq 'VMS'; # Copy::copy works in binary mode
  # This outputs "ok" so its a test.
  copy "copy-$$", \*STDOUT;
  $TB->current_test($TB->current_test + 1);
  unlink "copy-$$" or die "unlink: $!";

  open(F,"file-$$");
  copy(*F, "copy-$$");
  open(R, "copy-$$") or die "open copy-$$: $!"; $foo = <R>; close(R);
  is $foo, "ok\n", 'copy(*F, fn): same contents';
  unlink "copy-$$" or die "unlink: $!";

  open(F,"file-$$");
  copy(\*F, "copy-$$");
  close(F) or die "close: $!";
  open(R, "copy-$$") or die; $foo = <R>; close(R) or die "close: $!";
  is $foo, "ok\n", 'copy(\*F, fn): same contents';
  unlink "copy-$$" or die "unlink: $!";

  require IO::File;
  my $fh = IO::File->new(">copy-$$") or die "Cannot open copy-$$:$!";
  binmode $fh or die $!;
  copy("file-$$",$fh);
  $fh->close or die "close: $!";
  open(R, "copy-$$") or die; $foo = <R>; close(R);
  is $foo, "ok\n", 'copy(fn, io): same contents';
  unlink "copy-$$" or die "unlink: $!";

  require FileHandle;
  $fh = FileHandle->new(">copy-$$") or die "Cannot open copy-$$:$!";
  binmode $fh or die $!;
  copy("file-$$",$fh);
  $fh->close;
  open(R, "copy-$$") or die $!; $foo = <R>; close(R);
  is $foo, "ok\n", 'copy(fn, fh): same contents';
  unlink "file-$$" or die "unlink: $!";

  ok !move("file-$$", "copy-$$"), "move on missing file";
  ok -e "copy-$$",                '  target still there';

  # Doesn't really matter what time it is as long as its not now.
  my $time = 1000000000;
  utime( $time, $time, "copy-$$" );

  # Recheck the mtime rather than rely on utime in case we're on a
  # system where utime doesn't work or there's no mtime at all.
  # The destination file will reflect the same difficulties.
  my $mtime = (stat("copy-$$"))[9];

  ok move("copy-$$", "file-$$"), 'move';
  ok -e "file-$$",              '  destination exists';
  ok !-e "copy-$$",              '  source does not';
  open(R, "file-$$") or die $!; $foo = <R>; close(R);
  is $foo, "ok\n", 'contents preserved';

  TODO: {
    local $TODO = 'mtime only preserved on ODS-5 with POSIX dates and DECC$EFS_FILE_TIMESTAMPS enabled' if $^O eq 'VMS';

    my $dest_mtime = (stat("file-$$"))[9];
    is $dest_mtime, $mtime,
      "mtime preserved by copy()". 
      ($cross_partition_test ? " while testing cross-partition" : "");
  }

  # trick: create lib/ if not exists - not needed in Perl core
  unless (-d 'lib') { mkdir 'lib' or die $!; }
  copy "file-$$", "lib";
  open(R, "lib/file-$$") or die $!; $foo = <R>; close(R);
  is $foo, "ok\n", 'copy(fn, dir): same contents';
  unlink "lib/file-$$" or die "unlink: $!";

  # Do it twice to ensure copying over the same file works.
  copy "file-$$", "lib";
  open(R, "lib/file-$$") or die $!; $foo = <R>; close(R);
  is $foo, "ok\n", 'copy over the same file works';
  unlink "lib/file-$$" or die "unlink: $!";

  { 
    my $warnings = '';
    local $SIG{__WARN__} = sub { $warnings .= join '', @@_ };
    ok !copy("file-$$", "file-$$"), 'copy to itself fails';

    like $warnings, qr/are identical/, 'but warns';
    ok -s "file-$$", 'contents preserved';
  }

  move "file-$$", "lib";
  open(R, "lib/file-$$") or die "open lib/file-$$: $!"; $foo = <R>; close(R);
  is $foo, "ok\n", 'move(fn, dir): same contents';
  ok !-e "file-$$", 'file moved indeed';
  unlink "lib/file-$$" or die "unlink: $!";

  SKIP: {
    skip "Testing symlinks", 3 unless $Config{d_symlink};

    open(F, ">file-$$") or die $!;
    print F "dummy content\n";
    close F;
    symlink("file-$$", "symlink-$$") or die $!;

    my $warnings = '';
    local $SIG{__WARN__} = sub { $warnings .= join '', @@_ };
    ok !copy("file-$$", "symlink-$$"), 'copy to itself (via symlink) fails';

    like $warnings, qr/are identical/, 'emits a warning';
    ok !-z "file-$$", 
      'rt.perl.org 5196: copying to itself would truncate the file';

    unlink "symlink-$$" or die $!;
    unlink "file-$$" or die $!;
  }

  SKIP: {
    skip "Testing hard links", 3 
         if !$Config{d_link} or $^O eq 'MSWin32' or $^O eq 'cygwin';

    open(F, ">file-$$") or die $!;
    print F "dummy content\n";
    close F;
    link("file-$$", "hardlink-$$") or die $!;

    my $warnings = '';
    local $SIG{__WARN__} = sub { $warnings .= join '', @@_ };
    ok !copy("file-$$", "hardlink-$$"), 'copy to itself (via hardlink) fails';

    like $warnings, qr/are identical/, 'emits a warning';
    ok ! -z "file-$$",
      'rt.perl.org 5196: copying to itself would truncate the file';

    unlink "hardlink-$$" or die $!;
    unlink "file-$$" or die $!;
  }

  open(F, ">file-$$") or die $!;
  binmode F;
  print F "this is file\n";
  close F;

  my $copy_msg = "this is copy\n";
  open(F, ">copy-$$") or die $!;
  binmode F;
  print F $copy_msg;
  close F;

  my @@warnings;
  local $SIG{__WARN__} = sub { push @@warnings, join '', @@_ };

  # pie-$$ so that we force a non-constant, else the numeric conversion (of 0)
  # is cached and we do not get a warning the second time round
  is eval { copy("file-$$", "copy-$$", "pie-$$"); 1 }, undef,
    "a bad buffer size fails to copy";
  like $@@, qr/Bad buffer size for copy/, "with a helpful error message";
  unless (is scalar @@warnings, 1, "There is 1 warning") {
    diag $_ foreach @@warnings;
  }

  is -s "copy-$$", length $copy_msg, "but does not truncate the destination";
  open(F, "copy-$$") or die $!;
  $foo = <F>;
  close(F);
  is $foo, $copy_msg, "nor change the destination's contents";

  unlink "file-$$" or die $!;
  unlink "copy-$$" or die $!;

  # RT #73714 copy to file with leading whitespace failed

  TODO: {
  local $TODO = 'spaces in filenames require DECC$EFS_CHARSET enabled' if $^O eq 'VMS';
  open(F, ">file-$$") or die $!;
  close F;
  copy "file-$$", " copy-$$";
  ok -e " copy-$$", "copy with leading whitespace";
  unlink "file-$$" or die "unlink: $!";
  unlink " copy-$$" or die "unlink: $!";
  }
}

my $can_suidp = sub {
    my $dir = "suid-$$";
    my $ok = 1;
    mkdir $dir or die "Can't mkdir($dir) for suid test";
    $ok = 0 unless chmod 2000, $dir;
    rmdir $dir;
    return $ok;
};

SKIP: {
    my @@tests = (
        [0000,  0777,  0777,  0777],
        [0000,  0751,  0751,  0644],
        [0022,  0777,  0755,  0206],
        [0022,  0415,  0415,  0666],
        [0077,  0777,  0700,  0333],
        [0027,  0755,  0750,  0251],
        [0777,  0751,  0000,  0215],
    );

    my $skips = @@tests * 6 * 8;

    my $can_suid = $can_suidp->();
    skip "Can't suid on this $^O filesystem", $skips unless $can_suid;
    skip "-- Copy preserves RMS defaults, not POSIX permissions.", $skips
          if $^O eq 'VMS';
    skip "Copy doesn't set file permissions correctly on Win32.",  $skips
          if $^O eq "MSWin32";
    skip "Copy maps POSIX permissions to VOS permissions.", $skips
          if $^O eq "vos";
    skip "There be dragons here with DragonflyBSD.", $skips
         if $^O eq 'dragonfly';


    # Just a sub to get better failure messages.
    sub __ ($) {
        my $perm   = shift;
        my $id     = 07000 & $perm;
           $id   >>= 9;
        $perm     &= 0777;
        my @@chunks = map {(qw [--- --x -w- -wx r-- r-x rw- rwx]) [$_]}
                     split // => sprintf "%03o" => $perm;
        if ($id & 4) {$chunks [0] =~ s/(.)$/$1 eq '-' ? 'S' : 's'/e;}
        if ($id & 2) {$chunks [1] =~ s/(.)$/$1 eq '-' ? 'S' : 's'/e;}
        if ($id & 1) {$chunks [2] =~ s/(.)$/$1 eq '-' ? 'T' : 't'/e;}
        join "" => @@chunks;
    }
    # Testing permission bits.
    my $src   = "file-$$";
    my $copy1 = "copy1-$$";
    my $copy2 = "copy2-$$";
    my $copy3 = "copy3-$$";
    my $copy4 = "copy4-$$";
    my $copy5 = "copy5-$$";
    my $copy6 = "copy6-$$";
    my $copyd = "copyd-$$";

    open my $fh => ">", $src   or die $!;
    close   $fh                or die $!;

    open    $fh => ">", $copy3 or die $!;
    close   $fh                or die $!;

    open    $fh => ">", $copy6 or die $!;
    close   $fh                or die $!;

    my $old_mask = umask;
    foreach my $test (@@tests) {
        foreach my $id (0 .. 7) {
            my ($umask, $s_perm, $c_perm1, $c_perm3) = @@$test;
            # Make sure the copies do not exist.
            ! -e $_ or unlink $_ or die $! for $copy1, $copy2, $copy4, $copy5;

            $s_perm  |= $id << 9;
            $c_perm1 |= $id << 9;
            diag(sprintf "Src permission: %04o; umask %03o\n", $s_perm, $umask)
                unless ($ENV{PERL_CORE});

	    # Test that we can actually set a file to the correct permission.
	    # Slightly convoluted, because some operating systems will let us
	    # set a directory, but not a file. These should all work:
	    mkdir $copyd or die "Can't mkdir $copyd: $!";
	    chmod $s_perm, $copyd
		or die sprintf "Can't chmod %o $copyd: $!", $s_perm;
	    rmdir $copyd
		or die sprintf "Can't rmdir $copyd: $!";
	    open my $fh0, '>', $copy1 or die "Can't open $copy1: $!";
	    close $fh0 or die "Can't close $copy1: $!";
	    unless (chmod $s_perm, $copy1) {
		$TB->skip(sprintf "Can't chmod $copy1 to %o: $!", $s_perm)
		    for 1..6;
		next;
	    }
            my $perm0 = (stat $copy1) [2] & 07777;
	    unless ($perm0 == $s_perm) {
		$TB->skip(sprintf "chmod %o $copy1 lies - we actually get %o",
			  $s_perm, $perm0)
		    for 1..6;
		next;
	    }
	    unlink $copy1 or die "Can't unlink $copy1: $!";

            (umask $umask) // die $!;
            chmod $s_perm  => $src   or die sprintf "$!: $src => %o", $s_perm;
            chmod $c_perm3 => $copy3 or die $!;
            chmod $c_perm3 => $copy6 or die $!;

            open my $fh => "<", $src or die $!;

            copy ($src, $copy1);
            copy ($fh,  $copy2);
            copy ($src, $copy3);
            cp   ($src, $copy4);
            cp   ($fh,  $copy5);
            cp   ($src, $copy6);

            my $permdef = 0666 & ~$umask;
            my $perm1 = (stat $copy1) [2] & 07777;
            my $perm2 = (stat $copy2) [2] & 07777;
            my $perm3 = (stat $copy3) [2] & 07777;
            my $perm4 = (stat $copy4) [2] & 07777;
            my $perm5 = (stat $copy5) [2] & 07777;
            my $perm6 = (stat $copy6) [2] & 07777;
            is (__$perm1, __$permdef, "Permission bits set correctly");
            is (__$perm2, __$permdef, "Permission bits set correctly");
            is (__$perm4, __$c_perm1, "Permission bits set correctly");
            is (__$perm5, __$c_perm1, "Permission bits set correctly");
            is (__$perm3, __$c_perm3, "Permission bits not modified");
            is (__$perm6, __$c_perm3, "Permission bits not modified");
        }
    }
    umask $old_mask or die $!;

    # Clean up.
    ! -e $_ or unlink $_ or die $! for $src, $copy1, $copy2, $copy3,
                                             $copy4, $copy5, $copy6;
}

{
    package Crash;
    # a package overloaded suspiciously like IO::Scalar
    use overload '""' => sub { ${$_[0]} };
    use overload 'bool' => sub { 1 };
    sub new {
	my ($class, $name) = @@_;
	bless \$name, $class;
    }

    package Zowie;
    # a different package overloaded suspiciously like IO::Scalar
    use overload '""' => sub { ${$_[0]} };
    use overload 'bool' => sub { 1 };
    sub new {
	my ($class, $name) = @@_;
	bless \$name, $class;
    }
}
{
    my $object = Crash->new('whack_eth');
    my %what = (plain => "$object",
		object1 => $object,
		object2 => Zowie->new('whack_eth'),
		object2 => Zowie->new('whack_eth'),
	       );

    my @@warnings;
    local $SIG{__WARN__} = sub {
	push @@warnings, @@_;
    };

    foreach my $left (qw(plain object1 object2)) {
	foreach my $right (qw(plain object1 object2)) {
	    @@warnings = ();
	    $! = 0;
	    is eval {copy $what{$left}, $what{$right}}, 0, "copy $left $right";
	    is $@@, '', 'No croaking';
	    is $!, '', 'No system call errors';
	    is @@warnings, 1, 'Exactly 1 warning';
	    like $warnings[0],
		qr/'$object' and '$object' are identical \(not copied\)/,
		    'with the text we expect';
	}
    }
}

# On Unix systems, File::Copy always returns 0 to signal failure,
# even when in list context!  On Windows, it always returns "" to signal
# failure.
#
# While returning a list containing a false value is arguably a bad
# API design, at the very least we can make sure it always returns
# the same false value.

my $NO_SUCH_FILE       = "this_file_had_better_not_exist";
my $NO_SUCH_OTHER_FILE = "my_goodness_im_sick_of_airports";

use constant EXPECTED_SCALAR => 0;
use constant EXPECTED_LIST   => [ EXPECTED_SCALAR ];

my %subs = (
    copy    =>  \&File::Copy::copy,
    cp      =>  \&File::Copy::cp,
    move    =>  \&File::Copy::move,
    mv      =>  \&File::Copy::mv,
);

SKIP: {
    skip( "Test can't run with $NO_SUCH_FILE existing", 2 * keys %subs)
        if (-e $NO_SUCH_FILE);

    foreach my $name (keys %subs) {

        my $sub = $subs{$name};

        my $scalar = $sub->( $NO_SUCH_FILE, $NO_SUCH_OTHER_FILE );
        is( $scalar, EXPECTED_SCALAR, "$name in scalar context");

        my @@array  = $sub->( $NO_SUCH_FILE, $NO_SUCH_OTHER_FILE );
        is_deeply( \@@array, EXPECTED_LIST, "$name in list context");
    }
}

SKIP: {
    skip("fork required to test pipe copying", 2)
        if (!$Config{'d_fork'});

    open(my $IN, "-|") || exec $^X, '-e', 'print "Hello, world!\n"';
    open(my $OUT, "|-") || exec $^X, '-ne', 'exit(/Hello/ ? 55 : 0)';

    ok(copy($IN, $OUT), "copy pipe to another");
    close($OUT);
    is($? >> 8, 55, "content copied through the pipes");
    close($IN);
}

use File::Temp qw(tempdir);
use File::Spec;

SKIP: {
    # RT #111126: File::Copy copy() zeros file when copying a file
    # into the same directory it is stored in

    my $temp_dir = tempdir( CLEANUP => 1 );
    my $temp_file = File::Spec->catfile($temp_dir, "somefile");

    open my $fh, ">", $temp_file
	or skip "Cannot create $temp_file: $!", 2;
    print $fh "Just some data";
    close $fh
	or skip "Cannot close $temp_file: $!", 2;

    my $warn_message = "";
    local $SIG{__WARN__} = sub { $warn_message .= "@@_" };
    ok(!copy($temp_file, $temp_dir),
       "Copy of foo/file to foo/ should fail");
    like($warn_message, qr/^\Q'$temp_file' and '$temp_file'\E are identical.*Copy\.t/i,
	 "error message should describe the problem");
    1 while unlink $temp_file;
}

{
  open(my $F, '>', "file-$$") or die $!;
  binmode $F; # for DOSISH platforms
  printf $F "ok\n";
  close $F;

  my $buffer = (1024 * 1024 * 2) + 1;
  is eval {copy "file-$$", "copy-$$", $buffer}, 1,
    "copy with buffer above normal size";
}


END {
    1 while unlink "copy-$$";
    1 while unlink "file-$$";
    1 while unlink "lib/file-$$";
}
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!./perl
d4 4
a7 3
    chdir 't' if -d 't';
    @@INC = '../lib';
    push @@INC, "::lib:$MacPerl::Architecture" if $^O eq 'MacOS';
d10 8
a17 1
$| = 1;
d19 3
a21 3
my @@pass = (0,1);
my $tests = $^O eq 'MacOS' ? 15 : 12;
printf "1..%d\n", $tests * scalar(@@pass);
a22 1
use File::Copy;
d24 12
a35 1
for my $pass (@@pass) {
d37 7
a43 1
  my $loopconst = $pass*$tests;
d46 1
a46 1
  open(F, ">file-$$") or die;
d48 1
a48 1
  printf F "ok %d\n", 3 + $loopconst;
d53 2
a54 2
  open(F, "copy-$$") or die;
  $foo = <F>;
d57 1
a57 2
  print "not " if -s "file-$$" != -s "copy-$$";
  printf "ok %d\n", 1 + $loopconst;
d59 1
a59 2
  print "not " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
  printf "ok %d\n", 2+$loopconst;
d61 1
d63 1
d65 1
d71 1
a71 2
  print "not " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
  printf "ok %d\n", 4+$loopconst;
d73 1
d78 1
a78 2
  print "not " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
  printf "ok %d\n", 5+$loopconst;
d82 2
a83 2
  $fh = IO::File->new(">copy-$$") or die "Cannot open copy-$$:$!";
  binmode $fh or die;
d87 1
a87 2
  print "# foo=`$foo'\nnot " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
  printf "ok %d\n", 6+$loopconst;
d89 1
d91 2
a92 2
  my $fh = FileHandle->new(">copy-$$") or die "Cannot open copy-$$:$!";
  binmode $fh or die;
d95 2
a96 3
  open(R, "copy-$$") or die; $foo = <R>; close(R);
  print "not " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
  printf "ok %d\n", 7+$loopconst;
d99 129
a227 67
  print "# moved missing file.\nnot " if move("file-$$", "copy-$$");
  print "# target disappeared.\nnot " if not -e "copy-$$";
  printf "ok %d\n", 8+$loopconst;

  move "copy-$$", "file-$$" or print "# move did not succeed.\n";
  print "# not moved: $!\nnot " unless -e "file-$$" and not -e "copy-$$";
  open(R, "file-$$") or die; $foo = <R>; close(R);
  print "# foo=`$foo'\nnot " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
  printf "ok %d\n", 9+$loopconst;

  if ($^O eq 'MacOS') {
	
    copy "file-$$", "lib";	
    open(R, ":lib:file-$$") or die; $foo = <R>; close(R);
    print "not " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
    printf "ok %d\n", 10+$loopconst;
    unlink ":lib:file-$$" or die "unlink: $!";
	
    copy "file-$$", ":lib";	
    open(R, ":lib:file-$$") or die; $foo = <R>; close(R);
    print "not " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
    printf "ok %d\n", 11+$loopconst;
    unlink ":lib:file-$$" or die "unlink: $!";
	
    copy "file-$$", ":lib:";	
    open(R, ":lib:file-$$") or die; $foo = <R>; close(R);
    print "not " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
    printf "ok %d\n", 12+$loopconst;
    unlink ":lib:file-$$" or die "unlink: $!";
	
    unless (-e 'lib:') { # make sure there's no volume called 'lib'
	undef $@@;
	eval { (copy "file-$$", "lib:") || die "'lib:' is not a volume name"; };
	print "# Died: $@@";
	print "not " unless ( $@@ =~ m|'lib:' is not a volume name| );
    }
    printf "ok %d\n", 13+$loopconst;

    move "file-$$", ":lib:";
    open(R, ":lib:file-$$") or die "open :lib:file-$$: $!"; $foo = <R>; close(R);
    print "not " unless $foo eq sprintf("ok %d\n", 3+$loopconst)
        and not -e "file-$$";;
    printf "ok %d\n", 14+$loopconst;

    eval { copy("copy-$$", "copy-$$") };
    printf "ok %d\n", 15+$loopconst
	unless $@@ =~ /are identical/ && -s "copy-$$";

    unlink ":lib:file-$$" or die "unlink: $!";
  
  } else {
    
    copy "file-$$", "lib";
    open(R, "lib/file-$$") or die; $foo = <R>; close(R);
    print "not " unless $foo eq sprintf "ok %d\n", 3+$loopconst;
    printf "ok %d\n", 10+$loopconst;
    unlink "lib/file-$$" or die "unlink: $!";

    move "file-$$", "lib";
    open(R, "lib/file-$$") or die "open lib/file-$$: $!"; $foo = <R>; close(R);
    print "not " unless $foo eq sprintf("ok %d\n", 3+$loopconst)
        and not -e "file-$$";;
    printf "ok %d\n", 11+$loopconst;

    eval { copy("copy-$$", "copy-$$") };
    printf "ok %d\n", 12+$loopconst
	unless $@@ =~ /are identical/ && -s "copy-$$";
d229 8
a236 2
    unlink "lib/file-$$" or die "unlink: $!";
  
d240 271
d513 1
d515 1
a515 5
    if ($^O eq 'MacOS') {
        1 while unlink ":lib:file-$$";
    } else {
        1 while unlink "lib/file-$$";
    }
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.3 from CPAN
@
text
@d12 1
a12 1
my $tests = $^O eq 'MacOS' ? 17 : 14;
a15 1
use Config;
a85 1
  my $test_i;
d125 1
a125 2

    $test_i = 15;
d145 1
a145 16

    $test_i = 12;
  }

  if ($Config{d_symlink}) {
    open(F, ">file-$$") or die $!;
    print F "dummy content\n";
    close F;
    symlink("file-$$", "symlink-$$") or die $!;
    eval { copy("file-$$", "symlink-$$") };
    print "not " if $@@ !~ /are identical/ || -z "file-$$";
    printf "ok %d\n", (++$test_i)+$loopconst;
    unlink "symlink-$$";
    unlink "file-$$";
  } else {
    printf "ok %d # Skipped: no symlinks on this platform\n", (++$test_i)+$loopconst;
a146 19

  if ($Config{d_link}) {
    if ($^O ne 'MSWin32') {
      open(F, ">file-$$") or die $!;
      print F "dummy content\n";
      close F;
      link("file-$$", "hardlink-$$") or die $!;
      eval { copy("file-$$", "hardlink-$$") };
      print "not " if $@@ !~ /are identical/ || -z "file-$$";
      printf "ok %d\n", (++$test_i)+$loopconst;
      unlink "hardlink-$$";
      unlink "file-$$";
    } else {
      printf "ok %d # Skipped: can't test hardlinks on MSWin32\n", (++$test_i)+$loopconst;
    }
  } else {
    printf "ok %d # Skipped: no hardlinks on this platform\n", (++$test_i)+$loopconst;
  }

@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d6 1
d9 1
a9 9
use Test::More;

my $TB = Test::More->builder;

plan tests => 60;

# We're going to override rename() later on but Perl has to see an override
# at compile time to honor it.
BEGIN { *CORE::GLOBAL::rename = sub { CORE::rename($_[0], $_[1]) }; }
d11 3
d18 1
d20 1
a20 16
foreach my $code ("copy()", "copy('arg')", "copy('arg', 'arg', 'arg', 'arg')",
                  "move()", "move('arg')", "move('arg', 'arg', 'arg')"
                 )
{
    eval $code;
    like $@@, qr/^Usage: /;
}


for my $cross_partition_test (0..1) {
  {
    # Simulate a cross-partition copy/move by forcing rename to
    # fail.
    no warnings 'redefine';
    *CORE::GLOBAL::rename = sub { 0 } if $cross_partition_test;
  }
d25 1
a25 1
  printf F "ok\n";
d34 2
a35 1
  is -s "file-$$", -s "copy-$$";
d37 2
a38 1
  is $foo, "ok\n";
a40 1
  # This outputs "ok" so its a test.
a41 1
  $TB->current_test($TB->current_test + 1);
d47 2
a48 1
  is $foo, "ok\n";
a49 1

d54 2
a55 1
  is $foo, "ok\n";
d64 2
a65 1
  is $foo, "ok\n";
a66 1

d73 2
a74 1
  is $foo, "ok\n";
d77 3
a79 2
  ok !move("file-$$", "copy-$$"), "move on missing file";
  ok -e "copy-$$",                '  target still there';
d81 2
a82 12
  # Doesn't really matter what time it is as long as its not now.
  my $time = 1000000000;
  utime( $time, $time, "copy-$$" );

  # Recheck the mtime rather than rely on utime in case we're on a
  # system where utime doesn't work or there's no mtime at all.
  # The destination file will reflect the same difficulties.
  my $mtime = (stat("copy-$$"))[9];

  ok move("copy-$$", "file-$$"), 'move';
  ok -e "file-$$",              '  destination exists';
  ok !-e "copy-$$",              '  source does not';
d84 2
a85 1
  is $foo, "ok\n";
d87 59
a145 2
  TODO: {
    local $TODO = 'mtime only preserved on ODS-5 with POSIX dates and DECC$EFS_FILE_TIMESTAMPS enabled' if $^O eq 'VMS';
d147 1
a147 21
    my $dest_mtime = (stat("file-$$"))[9];
    is $dest_mtime, $mtime,
      "mtime preserved by copy()". 
      ($cross_partition_test ? " while testing cross-partition" : "");
  }

  copy "file-$$", "lib";
  open(R, "lib/file-$$") or die; $foo = <R>; close(R);
  is $foo, "ok\n";
  unlink "lib/file-$$" or die "unlink: $!";

  # Do it twice to ensure copying over the same file works.
  copy "file-$$", "lib";
  open(R, "lib/file-$$") or die; $foo = <R>; close(R);
  is $foo, "ok\n";
  unlink "lib/file-$$" or die "unlink: $!";

  { 
    my $warnings = '';
    local $SIG{__WARN__} = sub { $warnings .= join '', @@_ };
    ok copy("file-$$", "file-$$");
d149 1
a149 2
    like $warnings, qr/are identical/;
    ok -s "file-$$";
d152 1
a152 9
  move "file-$$", "lib";
  open(R, "lib/file-$$") or die "open lib/file-$$: $!"; $foo = <R>; close(R);
  is $foo, "ok\n";
  ok !-e "file-$$";
  unlink "lib/file-$$" or die "unlink: $!";

  SKIP: {
    skip "Testing symlinks", 3 unless $Config{d_symlink};

d157 3
a159 9

    my $warnings = '';
    local $SIG{__WARN__} = sub { $warnings .= join '', @@_ };
    ok !copy("file-$$", "symlink-$$");

    like $warnings, qr/are identical/;
    ok !-z "file-$$", 
      'rt.perl.org 5196: copying to itself would truncate the file';

d162 2
d166 17
a182 11
  SKIP: {
    skip "Testing hard links", 3 if !$Config{d_link} or $^O eq 'MSWin32';

    open(F, ">file-$$") or die $!;
    print F "dummy content\n";
    close F;
    link("file-$$", "hardlink-$$") or die $!;

    my $warnings = '';
    local $SIG{__WARN__} = sub { $warnings .= join '', @@_ };
    ok !copy("file-$$", "hardlink-$$");
a183 7
    like $warnings, qr/are identical/;
    ok ! -z "file-$$",
      'rt.perl.org 5196: copying to itself would truncate the file';

    unlink "hardlink-$$";
    unlink "file-$$";
  }
d189 5
a193 1
    1 while unlink "lib/file-$$";
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d4 2
a5 4
   if( $ENV{PERL_CORE} ) {
        chdir 't' if -d 't';
        @@INC = '../lib';
    }
d28 1
a28 1
    like $@@, qr/^Usage: /, "'$code' is a usage error";
d52 1
a52 1
  is -s "file-$$", -s "copy-$$", 'copy(fn, fn): files of the same size';
d54 1
a54 1
  is $foo, "ok\n", 'copy(fn, fn): same contents';
a55 1
  print("# next test checks copying to STDOUT\n");
d65 1
a65 1
  is $foo, "ok\n", 'copy(*F, fn): same contents';
d72 1
a72 1
  is $foo, "ok\n", 'copy(\*F, fn): same contents';
d81 1
a81 1
  is $foo, "ok\n", 'copy(fn, io): same contents';
d90 1
a90 1
  is $foo, "ok\n", 'copy(fn, fh): same contents';
d109 1
a109 1
  is $foo, "ok\n", 'contents preserved';
a119 2
  # trick: create lib/ if not exists - not needed in Perl core
  unless (-d 'lib') { mkdir 'lib' or die; }
d121 2
a122 2
  open(R, "lib/file-$$") or die $!; $foo = <R>; close(R);
  is $foo, "ok\n", 'copy(fn, dir): same contents';
d128 1
a128 1
  is $foo, "ok\n", 'copy over the same file works';
d134 1
a134 1
    ok copy("file-$$", "file-$$"), 'copy(fn, fn) succeeds';
d136 2
a137 2
    like $warnings, qr/are identical/, 'but warns';
    ok -s "file-$$", 'contents preserved';
d142 2
a143 2
  is $foo, "ok\n", 'move(fn, dir): same contents';
  ok !-e "file-$$", 'file moved indeed';
d156 1
a156 1
    ok !copy("file-$$", "symlink-$$"), 'copy to itself (via symlink) fails';
d158 1
a158 1
    like $warnings, qr/are identical/, 'emits a warning';
d167 1
a167 2
    skip "Testing hard links", 3 
         if !$Config{d_link} or $^O eq 'MSWin32' or $^O eq 'cygwin';
d176 1
a176 1
    ok !copy("file-$$", "hardlink-$$"), 'copy to itself (via hardlink) fails';
d178 1
a178 1
    like $warnings, qr/are identical/, 'emits a warning';
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d1 1
a1 1
#!./perl -w
a9 3
use strict;
use warnings;

d14 1
a14 1
plan tests => 115;
d43 1
a43 1
  open(F, ">file-$$") or die $!;
d50 2
a51 2
  open(F, "copy-$$") or die $!;
  my $foo = <F>;
d79 2
a80 2
  my $fh = IO::File->new(">copy-$$") or die "Cannot open copy-$$:$!";
  binmode $fh or die $!;
d88 2
a89 2
  $fh = FileHandle->new(">copy-$$") or die "Cannot open copy-$$:$!";
  binmode $fh or die $!;
d92 1
a92 1
  open(R, "copy-$$") or die $!; $foo = <R>; close(R);
d111 1
a111 1
  open(R, "file-$$") or die $!; $foo = <R>; close(R);
d124 1
a124 1
  unless (-d 'lib') { mkdir 'lib' or die $!; }
d132 1
a132 1
  open(R, "lib/file-$$") or die $!; $foo = <R>; close(R);
d167 2
a168 2
    unlink "symlink-$$" or die $!;
    unlink "file-$$" or die $!;
d188 2
a189 25
    unlink "hardlink-$$" or die $!;
    unlink "file-$$" or die $!;
  }

  open(F, ">file-$$") or die $!;
  binmode F;
  print F "this is file\n";
  close F;

  my $copy_msg = "this is copy\n";
  open(F, ">copy-$$") or die $!;
  binmode F;
  print F $copy_msg;
  close F;

  my @@warnings;
  local $SIG{__WARN__} = sub { push @@warnings, join '', @@_ };

  # pie-$$ so that we force a non-constant, else the numeric conversion (of 0)
  # is cached and we don't get a warning the second time round
  is eval { copy("file-$$", "copy-$$", "pie-$$"); 1 }, undef,
    "a bad buffer size fails to copy";
  like $@@, qr/Bad buffer size for copy/, "with a helpful error message";
  unless (is scalar @@warnings, 1, "There is 1 warning") {
    diag $_ foreach @@warnings;
a190 9

  is -s "copy-$$", length $copy_msg, "but does not truncate the destination";
  open(F, "copy-$$") or die $!;
  $foo = <F>;
  close(F);
  is $foo, $copy_msg, "nor change the destination's contents";

  unlink "file-$$" or die $!;
  unlink "copy-$$" or die $!;
a192 46
{
    package Crash;
    # a package overloaded suspiciously like IO::Scalar
    use overload '""' => sub { ${$_[0]} };
    use overload 'bool' => sub { 1 };
    sub new {
	my ($class, $name) = @@_;
	bless \$name, $class;
    }

    package Zowie;
    # a different package overloaded suspiciously like IO::Scalar
    use overload '""' => sub { ${$_[0]} };
    use overload 'bool' => sub { 1 };
    sub new {
	my ($class, $name) = @@_;
	bless \$name, $class;
    }
}
{
    my $object = Crash->new('whack_eth');
    my %what = (plain => "$object",
		object1 => $object,
		object2 => Zowie->new('whack_eth'),
		object2 => Zowie->new('whack_eth'),
	       );

    my @@warnings;
    local $SIG{__WARN__} = sub {
	push @@warnings, @@_;
    };

    foreach my $left (qw(plain object1 object2)) {
	foreach my $right (qw(plain object1 object2)) {
	    @@warnings = ();
	    $! = 0;
	    is eval {copy $what{$left}, $what{$right}}, 1, "copy $left $right";
	    is $@@, '', 'No croaking';
	    is $!, '', 'No system call errors';
	    is @@warnings, 1, 'Exactly 1 warning';
	    like $warnings[0],
		qr/'$object' and '$object' are identical \(not copied\)/,
		    'with the text we expect';
	}
    }
}
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d17 1
a17 1
plan tests => 463;
d24 1
a24 1
use File::Copy qw(copy move cp);
a225 148

  # RT #73714 copy to file with leading whitespace failed

  TODO: {
  local $TODO = 'spaces in filenames require DECC$EFS_CHARSET enabled' if $^O eq 'VMS';
  open(F, ">file-$$") or die $!;
  close F;
  copy "file-$$", " copy-$$";
  ok -e " copy-$$", "copy with leading whitespace";
  unlink "file-$$" or die "unlink: $!";
  unlink " copy-$$" or die "unlink: $!";
  }
}

my $can_suidp = sub {
    my $dir = "suid-$$";
    my $ok = 1;
    mkdir $dir or die "Can't mkdir($dir) for suid test";
    $ok = 0 unless chmod 2000, $dir;
    rmdir $dir;
    return $ok;
};

SKIP: {
    my @@tests = (
        [0000,  0777,  0777,  0777],
        [0000,  0751,  0751,  0644],
        [0022,  0777,  0755,  0206],
        [0022,  0415,  0415,  0666],
        [0077,  0777,  0700,  0333],
        [0027,  0755,  0750,  0251],
        [0777,  0751,  0000,  0215],
    );

    my $skips = @@tests * 6 * 8;

    my $can_suid = $can_suidp->();
    skip "Can't suid on this $^O filesystem", $skips unless $can_suid;
    skip "-- Copy preserves RMS defaults, not POSIX permissions.", $skips
          if $^O eq 'VMS';
    skip "Copy doesn't set file permissions correctly on Win32.",  $skips
          if $^O eq "MSWin32";

    # Just a sub to get better failure messages.
    sub __ ($) {
        my $perm   = shift;
        my $id     = 07000 & $perm;
           $id   >>= 9;
        $perm     &= 0777;
        my @@chunks = map {(qw [--- --x -w- -wx r-- r-x rw- rwx]) [$_]}
                     split // => sprintf "%03o" => $perm;
        if ($id & 4) {$chunks [0] =~ s/(.)$/$1 eq '-' ? 'S' : 's'/e;}
        if ($id & 2) {$chunks [1] =~ s/(.)$/$1 eq '-' ? 'S' : 's'/e;}
        if ($id & 1) {$chunks [2] =~ s/(.)$/$1 eq '-' ? 'T' : 't'/e;}
        join "" => @@chunks;
    }
    # Testing permission bits.
    my $src   = "file-$$";
    my $copy1 = "copy1-$$";
    my $copy2 = "copy2-$$";
    my $copy3 = "copy3-$$";
    my $copy4 = "copy4-$$";
    my $copy5 = "copy5-$$";
    my $copy6 = "copy6-$$";

    open my $fh => ">", $src   or die $!;
    close   $fh                or die $!;

    open    $fh => ">", $copy3 or die $!;
    close   $fh                or die $!;

    open    $fh => ">", $copy6 or die $!;
    close   $fh                or die $!;

    my $old_mask = umask;
    foreach my $test (@@tests) {
        foreach my $id (0 .. 7) {
            my ($umask, $s_perm, $c_perm1, $c_perm3) = @@$test;
            # Make sure the copies doesn't exist.
            ! -e $_ or unlink $_ or die $! for $copy1, $copy2, $copy4, $copy5;

            $s_perm  |= $id << 9;
            $c_perm1 |= $id << 9;
            diag(sprintf "Src permission: %04o; umask %03o\n", $s_perm, $umask)
                unless ($ENV{PERL_CORE});

	    # Test that we can actually set a file to the correct permission.
	    # Slightly convoluted, because some operating systems will let us
	    # set a directory, but not a file. These should all work:
	    mkdir $copy1 or die "Can't mkdir $copy1: $!";
	    chmod $s_perm, $copy1
		or die sprintf "Can't chmod %o $copy1: $!", $s_perm;
	    rmdir $copy1
		or die sprintf "Can't rmdir $copy1: $!";
	    open my $fh0, '>', $copy1 or die "Can't open $copy1: $!";
	    close $fh0 or die "Can't close $copy1: $!";
	    unless (chmod $s_perm, $copy1) {
		$TB->skip(sprintf "Can't chmod $copy1 to %o: $!", $s_perm)
		    for 1..6;
		next;
	    }
            my $perm0 = (stat $copy1) [2] & 07777;
	    unless ($perm0 == $s_perm) {
		$TB->skip(sprintf "chmod %o $copy1 lies - we actually get %o",
			  $s_perm, $perm0)
		    for 1..6;
		next;
	    }
	    unlink $copy1 or die "Can't unlink $copy1: $!";

            (umask $umask) // die $!;
            chmod $s_perm  => $src   or die sprintf "$!: $src => %o", $s_perm;
            chmod $c_perm3 => $copy3 or die $!;
            chmod $c_perm3 => $copy6 or die $!;

            open my $fh => "<", $src or die $!;

            copy ($src, $copy1);
            copy ($fh,  $copy2);
            copy ($src, $copy3);
            cp   ($src, $copy4);
            cp   ($fh,  $copy5);
            cp   ($src, $copy6);

            my $permdef = 0666 & ~$umask;
            my $perm1 = (stat $copy1) [2] & 07777;
            my $perm2 = (stat $copy2) [2] & 07777;
            my $perm3 = (stat $copy3) [2] & 07777;
            my $perm4 = (stat $copy4) [2] & 07777;
            my $perm5 = (stat $copy5) [2] & 07777;
            my $perm6 = (stat $copy6) [2] & 07777;
            is (__$perm1, __$permdef, "Permission bits set correctly");
            is (__$perm2, __$permdef, "Permission bits set correctly");
            is (__$perm4, __$c_perm1, "Permission bits set correctly");
            is (__$perm5, __$c_perm1, "Permission bits set correctly");
            TODO: {
                local $TODO = 'Permission bits inconsistent under cygwin'
                   if $^O eq 'cygwin';
                is (__$perm3, __$c_perm3, "Permission bits not modified");
                is (__$perm6, __$c_perm3, "Permission bits not modified");
            }
        }
    }
    umask $old_mask or die $!;

    # Clean up.
    ! -e $_ or unlink $_ or die $! for $src, $copy1, $copy2, $copy3,
                                             $copy4, $copy5, $copy6;
a272 50
}

# On Unix systems, File::Copy always returns 0 to signal failure,
# even when in list context!  On Windows, it always returns "" to signal
# failure.
#
# While returning a list containing a false value is arguably a bad
# API design, at the very least we can make sure it always returns
# the same false value.

my $NO_SUCH_FILE       = "this_file_had_better_not_exist";
my $NO_SUCH_OTHER_FILE = "my_goodness_im_sick_of_airports";

use constant EXPECTED_SCALAR => 0;
use constant EXPECTED_LIST   => [ EXPECTED_SCALAR ];

my %subs = (
    copy    =>  \&File::Copy::copy,
    cp      =>  \&File::Copy::cp,
    move    =>  \&File::Copy::move,
    mv      =>  \&File::Copy::mv,
);

SKIP: {
    skip( "Test can't run with $NO_SUCH_FILE existing", 2 * keys %subs)
        if (-e $NO_SUCH_FILE);

    foreach my $name (keys %subs) {

        my $sub = $subs{$name};

        my $scalar = $sub->( $NO_SUCH_FILE, $NO_SUCH_OTHER_FILE );
        is( $scalar, EXPECTED_SCALAR, "$name in scalar context");

        my @@array  = $sub->( $NO_SUCH_FILE, $NO_SUCH_OTHER_FILE );
        is_deeply( \@@array, EXPECTED_LIST, "$name in list context");
    }
}

SKIP: {
    skip("fork required to test pipe copying", 2)
        if (!$Config{'d_fork'});

    open(my $IN, "-|") || exec $^X, '-e', 'print "Hello, world!\n"';
    open(my $OUT, "|-") || exec $^X, '-ne', 'exit(/Hello/ ? 55 : 0)';

    ok(copy($IN, $OUT), "copy pipe to another");
    close($OUT);
    is($? >> 8, 55, "content copied through the pipes");
    close($IN);
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a267 2
    skip "Copy maps POSIX permissions to VOS permissions.", $skips
          if $^O eq "vos";
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d17 1
a17 1
plan tests => 465;
d142 1
a142 1
    ok !copy("file-$$", "file-$$"), 'copy to itself fails';
a269 3
    skip "There be dragons here with DragonflyBSD.", $skips
         if $^O eq 'dragonfly';

d414 1
a414 1
	    is eval {copy $what{$left}, $what{$right}}, 0, "copy $left $right";
a472 25
}

use File::Temp qw(tempdir);
use File::Spec;

SKIP: {
    # RT #111126: File::Copy copy() zeros file when copying a file
    # into the same directory it is stored in

    my $temp_dir = tempdir( CLEANUP => 1 );
    my $temp_file = File::Spec->catfile($temp_dir, "somefile");

    open my $fh, ">", $temp_file
	or skip "Cannot create $temp_file: $!", 2;
    print $fh "Just some data";
    close $fh
	or skip "Cannot close $temp_file: $!", 2;

    my $warn_message = "";
    local $SIG{__WARN__} = sub { $warn_message .= "@@_" };
    ok(!copy($temp_file, $temp_dir),
       "Copy of foo/file to foo/ should fail");
    like($warn_message, qr/^\Q'$temp_file' and '$temp_file'\E are identical.*Copy\.t/i,
	 "error message should describe the problem");
    1 while unlink $temp_file;
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d17 1
a17 1
plan tests => 466;
d19 1
a19 1
# We are going to override rename() later on but Perl has to see an override
d210 1
a210 1
  # is cached and we do not get a warning the second time round
d309 1
a309 1
            # Make sure the copies do not exist.
a502 12
{
  open(my $F, '>', "file-$$") or die $!;
  binmode $F; # for DOSISH platforms
  printf $F "ok\n";
  close $F;

  my $buffer = (1024 * 1024 * 2) + 1;
  is eval {copy "file-$$", "copy-$$", $buffer}, 1,
    "copy with buffer above normal size";
}


a503 1
    1 while unlink "copy-$$";
@


1.1.1.10
log
@Import perl-5.24.2
@
text
@a294 1
    my $copyd = "copyd-$$";
d320 5
a324 5
	    mkdir $copyd or die "Can't mkdir $copyd: $!";
	    chmod $s_perm, $copyd
		or die sprintf "Can't chmod %o $copyd: $!", $s_perm;
	    rmdir $copyd
		or die sprintf "Can't rmdir $copyd: $!";
d366 6
a371 2
            is (__$perm3, __$c_perm3, "Permission bits not modified");
            is (__$perm6, __$c_perm3, "Permission bits not modified");
@


