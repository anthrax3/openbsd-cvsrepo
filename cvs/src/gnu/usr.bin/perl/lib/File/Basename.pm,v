head	1.14;
access;
symbols
	OPENBSD_6_1:1.14.0.8
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.10
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.4
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	PERL_5_20_2:1.1.1.13
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.13
	OPENBSD_5_6:1.13.0.8
	OPENBSD_5_6_BASE:1.13
	PERL_5_18_2:1.1.1.12
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.10
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.8
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.6
	OPENBSD_5_0:1.12.0.4
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.2
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.14
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	QP75iYx42Uo7mMxO;

1.13
date	2013.03.25.20.40.56;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2010.09.24.15.07.01;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.09.33;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.31;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.35;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.08;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.43;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.29;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.03;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.46.56;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.48.46;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.34;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.58;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2010.09.24.14.48.41;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.08.54;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.11.17.20.53.08;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.14
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@=head1 NAME

File::Basename - Parse file paths into directory, filename and suffix.

=head1 SYNOPSIS

    use File::Basename;

    ($name,$path,$suffix) = fileparse($fullname,@@suffixlist);
    $name = fileparse($fullname,@@suffixlist);

    $basename = basename($fullname,@@suffixlist);
    $dirname  = dirname($fullname);


=head1 DESCRIPTION

These routines allow you to parse file paths into their directory, filename
and suffix.

B<NOTE>: C<dirname()> and C<basename()> emulate the behaviours, and
quirks, of the shell and C functions of the same name.  See each
function's documentation for details.  If your concern is just parsing
paths it is safer to use L<File::Spec>'s C<splitpath()> and
C<splitdir()> methods.

It is guaranteed that

    # Where $path_separator is / for Unix, \ for Windows, etc...
    dirname($path) . $path_separator . basename($path);

is equivalent to the original path for all systems but VMS.


=cut


package File::Basename;

# File::Basename is used during the Perl build, when the re extension may
# not be available, but we only actually need it if running under tainting.
BEGIN {
  if (${^TAINT}) {
    require re;
    re->import('taint');
  }
}


use strict;
use 5.006;
use warnings;
our(@@ISA, @@EXPORT, $VERSION, $Fileparse_fstype, $Fileparse_igncase);
require Exporter;
@@ISA = qw(Exporter);
@@EXPORT = qw(fileparse fileparse_set_fstype basename dirname);
$VERSION = "2.85";

fileparse_set_fstype($^O);


=over 4

=item C<fileparse>
X<fileparse>

    my($filename, $dirs, $suffix) = fileparse($path);
    my($filename, $dirs, $suffix) = fileparse($path, @@suffixes);
    my $filename                  = fileparse($path, @@suffixes);

The C<fileparse()> routine divides a file path into its $dirs, $filename
and (optionally) the filename $suffix.

$dirs contains everything up to and including the last
directory separator in the $path including the volume (if applicable).
The remainder of the $path is the $filename.

     # On Unix returns ("baz", "/foo/bar/", "")
     fileparse("/foo/bar/baz");

     # On Windows returns ("baz", 'C:\foo\bar\', "")
     fileparse('C:\foo\bar\baz');

     # On Unix returns ("", "/foo/bar/baz/", "")
     fileparse("/foo/bar/baz/");

If @@suffixes are given each element is a pattern (either a string or a
C<qr//>) matched against the end of the $filename.  The matching
portion is removed and becomes the $suffix.

     # On Unix returns ("baz", "/foo/bar/", ".txt")
     fileparse("/foo/bar/baz.txt", qr/\.[^.]*/);

If type is non-Unix (see L</fileparse_set_fstype>) then the pattern
matching for suffix removal is performed case-insensitively, since
those systems are not case-sensitive when opening existing files.

You are guaranteed that C<$dirs . $filename . $suffix> will
denote the same location as the original $path.

=cut


sub fileparse {
  my($fullname,@@suffices) = @@_;

  unless (defined $fullname) {
      require Carp;
      Carp::croak("fileparse(): need a valid pathname");
  }

  my $orig_type = '';
  my($type,$igncase) = ($Fileparse_fstype, $Fileparse_igncase);

  my($taint) = substr($fullname,0,0);  # Is $fullname tainted?

  if ($type eq "VMS" and $fullname =~ m{/} ) {
    # We're doing Unix emulation
    $orig_type = $type;
    $type = 'Unix';
  }

  my($dirpath, $basename);

  if (grep { $type eq $_ } qw(MSDOS DOS MSWin32 Epoc)) {
    ($dirpath,$basename) = ($fullname =~ /^((?:.*[:\\\/])?)(.*)/s);
    $dirpath .= '.\\' unless $dirpath =~ /[\\\/]\z/;
  }
  elsif ($type eq "OS2") {
    ($dirpath,$basename) = ($fullname =~ m#^((?:.*[:\\/])?)(.*)#s);
    $dirpath = './' unless $dirpath;	# Can't be 0
    $dirpath .= '/' unless $dirpath =~ m#[\\/]\z#;
  }
  elsif ($type eq "MacOS") {
    ($dirpath,$basename) = ($fullname =~ /^(.*:)?(.*)/s);
    $dirpath = ':' unless $dirpath;
  }
  elsif ($type eq "AmigaOS") {
    ($dirpath,$basename) = ($fullname =~ /(.*[:\/])?(.*)/s);
    $dirpath = './' unless $dirpath;
  }
  elsif ($type eq 'VMS' ) {
    ($dirpath,$basename) = ($fullname =~ /^(.*[:>\]])?(.*)/s);
    $dirpath ||= '';  # should always be defined
  }
  else { # Default to Unix semantics.
    ($dirpath,$basename) = ($fullname =~ m{^(.*/)?(.*)}s);
    if ($orig_type eq 'VMS' and $fullname =~ m{^(/[^/]+/000000(/|$))(.*)}) {
      # dev:[000000] is top of VMS tree, similar to Unix '/'
      # so strip it off and treat the rest as "normal"
      my $devspec  = $1;
      my $remainder = $3;
      ($dirpath,$basename) = ($remainder =~ m{^(.*/)?(.*)}s);
      $dirpath ||= '';  # should always be defined
      $dirpath = $devspec.$dirpath;
    }
    $dirpath = './' unless $dirpath;
  }
      

  my $tail   = '';
  my $suffix = '';
  if (@@suffices) {
    foreach $suffix (@@suffices) {
      my $pat = ($igncase ? '(?i)' : '') . "($suffix)\$";
      if ($basename =~ s/$pat//s) {
        $taint .= substr($suffix,0,0);
        $tail = $1 . $tail;
      }
    }
  }

  # Ensure taint is propagated from the path to its pieces.
  $tail .= $taint;
  wantarray ? ($basename .= $taint, $dirpath .= $taint, $tail)
            : ($basename .= $taint);
}



=item C<basename>
X<basename> X<filename>

    my $filename = basename($path);
    my $filename = basename($path, @@suffixes);

This function is provided for compatibility with the Unix shell command
C<basename(1)>.  It does B<NOT> always return the file name portion of a
path as you might expect.  To be safe, if you want the file name portion of
a path use C<fileparse()>.

C<basename()> returns the last level of a filepath even if the last
level is clearly directory.  In effect, it is acting like C<pop()> for
paths.  This differs from C<fileparse()>'s behaviour.

    # Both return "bar"
    basename("/foo/bar");
    basename("/foo/bar/");

@@suffixes work as in C<fileparse()> except all regex metacharacters are
quoted.

    # These two function calls are equivalent.
    my $filename = basename("/foo/bar/baz.txt",  ".txt");
    my $filename = fileparse("/foo/bar/baz.txt", qr/\Q.txt\E/);

Also note that in order to be compatible with the shell command,
C<basename()> does not strip off a suffix if it is identical to the
remaining characters in the filename.

=cut


sub basename {
  my($path) = shift;

  # From BSD basename(1)
  # The basename utility deletes any prefix ending with the last slash '/'
  # character present in string (after first stripping trailing slashes)
  _strip_trailing_sep($path);

  my($basename, $dirname, $suffix) = fileparse( $path, map("\Q$_\E",@@_) );

  # From BSD basename(1)
  # The suffix is not stripped if it is identical to the remaining 
  # characters in string.
  if( length $suffix and !length $basename ) {
      $basename = $suffix;
  }
  
  # Ensure that basename '/' == '/'
  if( !length $basename ) {
      $basename = $dirname;
  }

  return $basename;
}



=item C<dirname>
X<dirname>

This function is provided for compatibility with the Unix shell
command C<dirname(1)> and has inherited some of its quirks.  In spite of
its name it does B<NOT> always return the directory name as you might
expect.  To be safe, if you want the directory name of a path use
C<fileparse()>.

Only on VMS (where there is no ambiguity between the file and directory
portions of a path) and AmigaOS (possibly due to an implementation quirk in
this module) does C<dirname()> work like C<fileparse($path)>, returning just the
$dirs.

    # On VMS and AmigaOS
    my $dirs = dirname($path);

When using Unix or MSDOS syntax this emulates the C<dirname(1)> shell function
which is subtly different from how C<fileparse()> works.  It returns all but
the last level of a file path even if the last level is clearly a directory.
In effect, it is not returning the directory portion but simply the path one
level up acting like C<chop()> for file paths.

Also unlike C<fileparse()>, C<dirname()> does not include a trailing slash on
its returned path.

    # returns /foo/bar.  fileparse() would return /foo/bar/
    dirname("/foo/bar/baz");

    # also returns /foo/bar despite the fact that baz is clearly a 
    # directory.  fileparse() would return /foo/bar/baz/
    dirname("/foo/bar/baz/");

    # returns '.'.  fileparse() would return 'foo/'
    dirname("foo/");

Under VMS, if there is no directory information in the $path, then the
current default device and directory is used.

=cut


sub dirname {
    my $path = shift;

    my($type) = $Fileparse_fstype;

    if( $type eq 'VMS' and $path =~ m{/} ) {
        # Parse as Unix
        local($File::Basename::Fileparse_fstype) = '';
        return dirname($path);
    }

    my($basename, $dirname) = fileparse($path);

    if ($type eq 'VMS') { 
        $dirname ||= $ENV{DEFAULT};
    }
    elsif ($type eq 'MacOS') {
	if( !length($basename) && $dirname !~ /^[^:]+:\z/) {
            _strip_trailing_sep($dirname);
	    ($basename,$dirname) = fileparse $dirname;
	}
	$dirname .= ":" unless $dirname =~ /:\z/;
    }
    elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
        _strip_trailing_sep($dirname);
        unless( length($basename) ) {
	    ($basename,$dirname) = fileparse $dirname;
	    _strip_trailing_sep($dirname);
	}
    }
    elsif ($type eq 'AmigaOS') {
        if ( $dirname =~ /:\z/) { return $dirname }
        chop $dirname;
        $dirname =~ s{[^:/]+\z}{} unless length($basename);
    }
    else {
        _strip_trailing_sep($dirname);
        unless( length($basename) ) {
	    ($basename,$dirname) = fileparse $dirname;
	    _strip_trailing_sep($dirname);
	}
    }

    $dirname;
}


# Strip the trailing path separator.
sub _strip_trailing_sep  {
    my $type = $Fileparse_fstype;

    if ($type eq 'MacOS') {
        $_[0] =~ s/([^:]):\z/$1/s;
    }
    elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
        $_[0] =~ s/([^:])[\\\/]*\z/$1/;
    }
    else {
        $_[0] =~ s{(.)/*\z}{$1}s;
    }
}


=item C<fileparse_set_fstype>
X<filesystem>

  my $type = fileparse_set_fstype();
  my $previous_type = fileparse_set_fstype($type);

Normally File::Basename will assume a file path type native to your current
operating system (ie. /foo/bar style on Unix, \foo\bar on Windows, etc...).
With this function you can override that assumption.

Valid $types are "MacOS", "VMS", "AmigaOS", "OS2", "RISCOS",
"MSWin32", "DOS" (also "MSDOS" for backwards bug compatibility),
"Epoc" and "Unix" (all case-insensitive).  If an unrecognized $type is
given "Unix" will be assumed.

If you've selected VMS syntax, and the file specification you pass to
one of these routines contains a "/", they assume you are using Unix
emulation and apply the Unix syntax rules instead, for that function
call only.

=back

=cut


BEGIN {

my @@Ignore_Case = qw(MacOS VMS AmigaOS OS2 RISCOS MSWin32 MSDOS DOS Epoc);
my @@Types = (@@Ignore_Case, qw(Unix));

sub fileparse_set_fstype {
    my $old = $Fileparse_fstype;

    if (@@_) {
        my $new_type = shift;

        $Fileparse_fstype = 'Unix';  # default
        foreach my $type (@@Types) {
            $Fileparse_fstype = $type if $new_type =~ /^$type/i;
        }

        $Fileparse_igncase = 
          (grep $Fileparse_fstype eq $_, @@Ignore_Case) ? 1 : 0;
    }

    return $old;
}

}


1;


=head1 SEE ALSO

L<dirname(1)>, L<basename(1)>, L<File::Spec>
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d57 1
a57 1
$VERSION = "2.84";
d67 3
a69 3
    my($filename, $directories, $suffix) = fileparse($path);
    my($filename, $directories, $suffix) = fileparse($path, @@suffixes);
    my $filename                         = fileparse($path, @@suffixes);
d71 1
a71 1
The C<fileparse()> routine divides a file path into its $directories, $filename
d74 1
a74 1
$directories contains everything up to and including the last
d98 1
a98 1
You are guaranteed that C<$directories . $filename . $suffix> will
d253 1
a253 1
$directories.
d256 1
a256 1
    my $directories = dirname($path);
@


1.12
log
@merge in perl 5.12.2 plus local changes
@
text
@d57 1
a57 1
$VERSION = "2.78";
d81 2
a82 2
     # On Windows returns ("baz", "C:\foo\bar\", "")
     fileparse("C:\foo\bar\baz");
d94 1
a94 1
If type is non-Unix (see C<fileparse_set_fstype()>) then the pattern
d173 1
a173 1
  # Ensure taint is propgated from the path to its pieces.
d218 1
a218 1
  # The basename utility deletes any prefix ending with the last slash `/'
@


1.11
log
@Merge in perl 5.10.1
@
text
@a39 1
# A bit of juggling to insure that C<use re 'taint';> always works, since
d41 1
a41 1
# not be available.
d43 4
a46 3
  unless (eval { require re; })
    { eval ' sub re::import { $^H |= 0x00100000; } ' } # HINT_RE_TAINT
  import re 'taint';
d57 1
a57 1
$VERSION = "2.77";
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d57 1
a57 1
$VERSION = "2.76";
d91 1
a91 1
     # On Unix returns ("baz", "/foo/bar", ".txt")
@


1.9
log
@merge in perl 5.8.8
@
text
@d57 1
a57 1
$VERSION = "2.74";
d65 1
d92 1
a92 1
     fileparse("/foo/bar/baz", qr/\.[^.]*/);
d147 2
a148 2
    ($dirpath,$basename) = ($fullname =~ m#^(.*/)?(.*)#s);
    if ($orig_type eq 'VMS' and $fullname =~ m:^(/[^/]+/000000(/|$))(.*):) {
d153 1
a153 1
      ($dirpath,$basename) = ($remainder =~ m#^(.*/)?(.*)#s);
d182 1
d187 1
a187 1
This function is provided for compatibility with the Unix shell command 
d242 1
d316 1
a316 1
        $dirname =~ s#[^:/]+\z## unless length($basename);
d347 1
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@a0 2
package File::Basename;

d3 1
a3 5
fileparse - split a pathname into pieces

basename - extract just the filename from a path

dirname - extract just the directory from a path
d11 1
a11 1
    fileparse_set_fstype($os_string);
d13 1
a13 1
    $dirname = dirname($fullname);
a14 4
    ($name,$path,$suffix) = fileparse("lib/File/Basename.pm",qr{\.pm});
    fileparse_set_fstype("VMS");
    $basename = basename("lib/File/Basename.pm",".pm");
    $dirname = dirname("lib/File/Basename.pm");
d18 2
a19 2
These routines allow you to parse file specifications into useful
pieces using the syntax of different operating systems.
d21 5
a25 1
=over 4
d27 1
a27 1
=item fileparse_set_fstype
d29 2
a30 1
You select the syntax via the routine fileparse_set_fstype().
d32 1
a32 36
If the argument passed to it contains one of the substrings
"VMS", "MSDOS", "MacOS", "AmigaOS" or "MSWin32", the file specification 
syntax of that operating system is used in future calls to 
fileparse(), basename(), and dirname().  If it contains none of
these substrings, Unix syntax is used.  This pattern matching is
case-insensitive.  If you've selected VMS syntax, and the file
specification you pass to one of these routines contains a "/",
they assume you are using Unix emulation and apply the Unix syntax
rules instead, for that function call only.

If the argument passed to it contains one of the substrings "VMS",
"MSDOS", "MacOS", "AmigaOS", "os2", "MSWin32" or "RISCOS", then the pattern
matching for suffix removal is performed without regard for case,
since those systems are not case-sensitive when opening existing files
(though some of them preserve case on file creation).

If you haven't called fileparse_set_fstype(), the syntax is chosen
by examining the builtin variable C<$^O> according to these rules.

=item fileparse

The fileparse() routine divides a file specification into three
parts: a leading B<path>, a file B<name>, and a B<suffix>.  The
B<path> contains everything up to and including the last directory
separator in the input file specification.  The remainder of the input
file specification is then divided into B<name> and B<suffix> based on
the optional patterns you specify in C<@@suffixlist>.  Each element of
this list can be a qr-quoted pattern (or a string which is interpreted
as a regular expression), and is matched
against the end of B<name>.  If this succeeds, the matching portion of
B<name> is removed and prepended to B<suffix>.  By proper use of
C<@@suffixlist>, you can remove file types or versions for examination.

You are guaranteed that if you concatenate B<path>, B<name>, and
B<suffix> together in that order, the result will denote the same
file as the input file specification.
a33 1
In scalar context, fileparse() returns only the B<name> part of the filename.
d35 1
a35 1
=back
a36 50
=head1 EXAMPLES

Using Unix file syntax:

    ($base,$path,$type) = fileparse('/virgil/aeneid/draft.book7',
				    qr{\.book\d+});

would yield

    $base eq 'draft'
    $path eq '/virgil/aeneid/',
    $type eq '.book7'

Similarly, using VMS syntax:

    ($name,$dir,$type) = fileparse('Doc_Root:[Help]Rhetoric.Rnh',
				   qr{\..*});

would yield

    $name eq 'Rhetoric'
    $dir  eq 'Doc_Root:[Help]'
    $type eq '.Rnh'

=over

=item C<basename>

The basename() routine returns the first element of the list produced
by calling fileparse() with the same arguments, except that it always
quotes metacharacters in the given suffixes.  It is provided for
programmer compatibility with the Unix shell command basename(1).

=item C<dirname>

The dirname() routine returns the directory portion of the input file
specification.  When using VMS or MacOS syntax, this is identical to the
second element of the list produced by calling fileparse() with the same
input file specification.  (Under VMS, if there is no directory information
in the input file specification, then the current default device and
directory are returned.)  When using Unix or MSDOS syntax, the return
value conforms to the behavior of the Unix shell command dirname(1).  This
is usually the same as the behavior of fileparse(), but differs in some
cases.  For example, for the input file specification F<lib/>, fileparse()
considers the directory name to be F<lib/>, while dirname() considers the
directory name to be F<.>).

=back

=cut
d38 1
a39 1
## use strict;
d50 1
a50 1

d57 12
a68 1
$VERSION = "2.73";
d70 2
d73 3
a75 5
#   fileparse_set_fstype() - specify OS-based rules used in future
#                            calls to routines in this package
#
#   Currently recognized values: VMS, MSDOS, MacOS, AmigaOS, os2, RISCOS
#       Any other name uses Unix-style rules and is case-sensitive
d77 22
a98 8
sub fileparse_set_fstype {
  my @@old = ($Fileparse_fstype, $Fileparse_igncase);
  if (@@_) {
    $Fileparse_fstype = $_[0];
    $Fileparse_igncase = ($_[0] =~ /^(?:MacOS|VMS|AmigaOS|os2|RISCOS|MSWin32|MSDOS)/i);
  }
  wantarray ? @@old : $old[0];
}
d100 1
a100 3
#   fileparse() - parse file specification
#
#   Version 2.4  27-Sep-1996  Charles Bailey  bailey@@genetics.upenn.edu
d105 1
d110 4
a113 2
  my($fstype,$igncase) = ($Fileparse_fstype, $Fileparse_igncase);
  my($dirpath,$tail,$suffix,$basename);
d116 4
a119 6
  if ($fstype =~ /^VMS/i) {
    if ($fullname =~ m#/#) { $fstype = '' }  # We're doing Unix emulation
    else {
      ($dirpath,$basename) = ($fullname =~ /^(.*[:>\]])?(.*)/s);
      $dirpath ||= '';  # should always be defined
    }
d121 4
a124 1
  if ($fstype =~ /^MS(DOS|Win32)|epoc/i) {
d128 1
a128 1
  elsif ($fstype =~ /^os2/i) {
d133 1
a133 1
  elsif ($fstype =~ /^MacOS/si) {
d137 1
a137 1
  elsif ($fstype =~ /^AmigaOS/i) {
d141 5
a145 1
  elsif ($fstype !~ /^VMS/i) {  # default to Unix
d147 1
a147 1
    if ($^O eq 'VMS' and $fullname =~ m:^(/[^/]+/000000(/|$))(.*):) {
d158 1
d160 2
a162 1
    $tail = '';
d172 2
a173 1
  $tail .= $taint if defined $tail; # avoid warning if $tail == undef
d179 32
a210 1
#   basename() - returns first element of list returned by fileparse()
d213 22
a234 2
  my($name) = shift;
  (fileparse($name, map("\Q$_\E",@@_)))[0];
d238 41
a278 6
#    dirname() - returns device and directory portion of file specification
#        Behavior matches that of Unix dirname(1) exactly for Unix and MSDOS
#        filespecs except for names ending with a separator, e.g., "/xx/yy/".
#        This differs from the second element of the list returned
#        by fileparse() in that the trailing '/' (Unix) or '\' (MSDOS) (and
#        the last directory name if the filespec ends in a '/' or '\'), is lost.
d281 9
a289 2
    my($basename,$dirname) = fileparse($_[0]);
    my($fstype) = $Fileparse_fstype;
d291 4
a294 3
    if ($fstype =~ /VMS/i) { 
        if ($_[0] =~ m#/#) { $fstype = '' }
        else { return $dirname || $ENV{DEFAULT} }
d296 1
a296 1
    if ($fstype =~ /MacOS/i) {
d298 1
a298 1
	    $dirname =~ s/([^:]):\z/$1/s;
d303 2
a304 2
    elsif ($fstype =~ /MS(DOS|Win32)|os2/i) { 
        $dirname =~ s/([^:])[\\\/]*\z/$1/;
d307 1
a307 1
	    $dirname =~ s/([^:])[\\\/]*\z/$1/;
d310 1
a310 1
    elsif ($fstype =~ /AmigaOS/i) {
d316 1
a316 1
        $dirname =~ s:(.)/*\z:$1:s;
a317 1
	    local($File::Basename::Fileparse_fstype) = $fstype;
d319 1
a319 1
	    $dirname =~ s:(.)/*\z:$1:s;
d326 66
a391 1
fileparse_set_fstype $^O;
d394 5
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d15 2
a16 1
    ($name,$path,$suffix) = fileparse($fullname,@@suffixlist)
d74 2
d148 1
a148 1
$VERSION = "2.72";
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d22 1
a22 1
    $basename = basename("lib/File/Basename.pm",qr{\.pm});
d133 1
a133 1
    { eval ' sub re::import { $^H |= 0x00100000; } ' }
d145 1
a145 1
$VERSION = "2.71";
d172 1
a172 1
      Carp::croak "fileparse(): need a valid pathname";
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d20 1
a20 1
    ($name,$path,$suffix) = fileparse("lib/File/Basename.pm","\.pm");
d22 1
a22 1
    $basename = basename("lib/File/Basename.pm",".pm");
d63 2
a64 1
this list is interpreted as a regular expression, and is matched
d80 1
a80 1
				    '\.book\d+');
d91 1
a91 1
				   '\..*');
d139 2
a140 1
use 5.005_64;
d145 1
a145 1
$VERSION = "2.6";
d170 4
d189 5
d196 1
d210 1
d228 2
a229 2
  wantarray ? ($basename . $taint, $dirpath . $taint, $tail)
            : $basename . $taint;
d263 1
a263 8
    elsif ($fstype =~ /MSDOS/i) { 
        $dirname =~ s/([^:])[\\\/]*\z/$1/;
        unless( length($basename) ) {
	    ($basename,$dirname) = fileparse $dirname;
	    $dirname =~ s/([^:])[\\\/]*\z/$1/;
	}
    }
    elsif ($fstype =~ /MSWin32/i) { 
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d179 1
a179 1
  if ($fstype =~ /^MS(DOS|Win32)/i) {
d192 1
a192 1
    if ($^O eq 'VMS' and $fullname =~ m:/[^/]+/000000/?:) {
d194 5
a198 1
      ($basename,$dirpath) = ('',$fullname);
d243 7
a249 1
    if ($fstype =~ /MacOS/i) { return $dirname }
d269 1
a269 1
    else { 
@


1.3
log
@perl5.005_03 (stock)
@
text
@d40 1
a40 1
these substrings, UNIX syntax is used.  This pattern matching is
d43 1
a43 1
they assume you are using UNIX emulation and apply the UNIX syntax
d76 1
a76 1
Using UNIX file syntax:
d105 1
a105 1
programmer compatibility with the UNIX shell command basename(1).
d114 2
a115 2
directory are returned.)  When using UNIX or MSDOS syntax, the return
value conforms to the behavior of the UNIX shell command dirname(1).  This
d127 10
a136 1
use re 'taint';
d138 2
a142 1
use vars qw($VERSION $Fileparse_fstype $Fileparse_igncase);
d175 1
a175 1
      ($dirpath,$basename) = ($fullname =~ /^(.*[:>\]])?(.*)/);
d180 2
a181 2
    ($dirpath,$basename) = ($fullname =~ /^((?:.*[:\\\/])?)(.*)/);
    $dirpath .= '.\\' unless $dirpath =~ /[\\\/]$/;
d183 2
a184 2
  elsif ($fstype =~ /^MacOS/i) {
    ($dirpath,$basename) = ($fullname =~ /^(.*:)?(.*)/);
d187 1
a187 1
    ($dirpath,$basename) = ($fullname =~ /(.*[:\/])?(.*)/);
d191 1
a191 1
    ($dirpath,$basename) = ($fullname =~ m#^(.*/)?(.*)#);
d203 1
a203 1
      if ($basename =~ s/$pat//) {
d241 1
a241 1
        $dirname =~ s/([^:])[\\\/]*$/$1/;
d244 1
a244 1
	    $dirname =~ s/([^:])[\\\/]*$/$1/;
d248 1
a248 1
        $dirname =~ s/([^:])[\\\/]*$/$1/;
d251 1
a251 1
	    $dirname =~ s/([^:])[\\\/]*$/$1/;
d255 1
a255 1
        if ( $dirname =~ /:$/) { return $dirname }
d257 1
a257 1
        $dirname =~ s#[^:/]+$## unless length($basename);
d260 1
a260 1
        $dirname =~ s:(.)/*$:$1:;
d264 1
a264 1
	    $dirname =~ s:(.)/*$:$1:;
@


1.2
log
@perl 5.004_04
@
text
@d125 4
a128 1
require 5.002;
d132 2
a133 3
#use strict;
#use vars qw($VERSION $Fileparse_fstype $Fileparse_igncase);
$VERSION = "2.5";
d146 1
a146 1
    $Fileparse_igncase = ($_[0] =~ /^(?:MacOS|VMS|AmigaOS|os2|RISCOS|MSWin32)/i);
d160 1
d166 1
d182 4
d194 1
d200 3
a202 1
  wantarray ? ($basename,$dirpath,$tail) : $basename;
@


1.1
log
@Initial revision
@
text
@a4 2
Basename - parse file specifications

d35 1
d37 4
a40 4
"VMS", "MSDOS", or "MacOS", the file specification syntax of that
operating system is used in future calls to fileparse(),
basename(), and dirname().  If it contains none of these
substrings, UNIX syntax is used.  This pattern matching is
d46 6
d69 2
a70 2
B<suffix> together in that order, the result will be identical to the
input file specification.
d78 1
a78 1
    ($base,$path,$type) = fileparse('/virgil/aeneid/draft.book7', 
d84 2
a85 2
    $path eq '/virgil/aeneid',
    $tail eq '.book7'
d98 2
d103 3
a105 2
by calling fileparse() with the same arguments.  It is provided for
compatibility with the UNIX shell command basename(1).
d112 3
a114 1
input file specification.  When using UNIX or MSDOS syntax, the return
d121 2
d129 4
d137 2
a138 2
#   Currently recognized values: VMS, MSDOS, MacOS
#       Any other name uses Unix-style rules
d141 6
a146 3
  my($old) = $Fileparse_fstype;
  $Fileparse_fstype = $_[0] if $_[0];
  $old;
d151 1
a151 37
#   calling sequence:
#     ($filename,$prefix,$tail) = &basename_pat($filespec,@@excludelist);
#     where  $filespec    is the file specification to be parsed, and
#            @@excludelist is a list of patterns which should be removed
#                         from the end of $filename.
#            $filename    is the part of $filespec after $prefix (i.e. the
#                         name of the file).  The elements of @@excludelist
#                         are compared to $filename, and if an  
#            $prefix     is the path portion $filespec, up to and including
#                        the end of the last directory name
#            $tail        any characters removed from $filename because they
#                         matched an element of @@excludelist.
#
#   fileparse() first removes the directory specification from $filespec,
#   according to the syntax of the OS (code is provided below to handle
#   VMS, Unix, MSDOS and MacOS; you can pick the one you want using
#   fileparse_set_fstype(), or you can accept the default, which is
#   based on the information in the builtin variable $^O).  It then compares
#   each element of @@excludelist to $filename, and if that element is a
#   suffix of $filename, it is removed from $filename and prepended to
#   $tail.  By specifying the elements of @@excludelist in the right order,
#   you can 'nibble back' $filename to extract the portion of interest
#   to you.
#
#   For example, on a system running Unix,
#   ($base,$path,$type) = fileparse('/virgil/aeneid/draft.book7',
#                                       '\.book\d+');
#   would yield $base == 'draft',
#               $path == '/virgil/aeneid/'  (note trailing slash)
#               $tail == '.book7'.
#   Similarly, on a system running VMS,
#   ($name,$dir,$type) = fileparse('Doc_Root:[Help]Rhetoric.Rnh','\..*');
#   would yield $name == 'Rhetoric';
#               $dir == 'Doc_Root:[Help]', and
#               $type == '.Rnh'.
#
#   Version 2.2  13-Oct-1994  Charles Bailey  bailey@@genetics.upenn.edu 
d156 2
a157 2
  my($fstype) = $Fileparse_fstype;
  my($dirpath,$tail,$suffix);
d162 1
a162 2
      ($dirpath,$basename) = ($fullname =~ /(.*[:>\]])?(.*)/);
      $dirpath = $ENV{'DEFAULT'} unless $dirpath;
d165 3
a167 3
  if ($fstype =~ /^MSDOS/i) {
    ($dirpath,$basename) = ($fullname =~ /(.*\\)?(.*)/);
    $dirpath = '.\\' unless $dirpath;
d169 6
a174 2
  elsif ($fstype =~ /^MAC/i) {
    ($dirpath,$basename) = ($fullname =~ /(.*:)?(.*)/);
d177 1
a177 1
    ($dirpath,$basename) = ($fullname =~ m#(.*/)?(.*)#);
d184 2
a185 1
      if ($basename =~ /($suffix)$/) {
a186 1
        $basename = $`;
a191 1

d201 1
a201 1
  
d216 1
a216 1
        else { return $dirname }
d220 15
a234 1
        if ( $dirname =~ /:\\$/) { return $dirname }
d236 1
a236 2
        $dirname =~ s:[^\\]+$:: unless $basename;
        $dirname = '.' unless $dirname;
d239 6
a244 4
        if ( $dirname eq '/') { return $dirname }
        chop $dirname;
        $dirname =~ s:[^/]+$:: unless $basename;
        $dirname = '.' unless $dirname;
d250 1
a250 1
$Fileparse_fstype = $^O;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d5 2
a36 1

d38 4
a41 4
"VMS", "MSDOS", "MacOS", "AmigaOS" or "MSWin32", the file specification 
syntax of that operating system is used in future calls to 
fileparse(), basename(), and dirname().  If it contains none of
these substrings, UNIX syntax is used.  This pattern matching is
a46 6
If the argument passed to it contains one of the substrings "VMS",
"MSDOS", "MacOS", "AmigaOS", "os2", "MSWin32" or "RISCOS", then the pattern
matching for suffix removal is performed without regard for case,
since those systems are not case-sensitive when opening existing files
(though some of them preserve case on file creation).

d64 2
a65 2
B<suffix> together in that order, the result will denote the same
file as the input file specification.
d73 1
a73 1
    ($base,$path,$type) = fileparse('/virgil/aeneid/draft.book7',
d79 2
a80 2
    $path eq '/virgil/aeneid/',
    $type eq '.book7'
a92 2
=over

d96 2
a97 3
by calling fileparse() with the same arguments, except that it always
quotes metacharacters in the given suffixes.  It is provided for
programmer compatibility with the UNIX shell command basename(1).
d104 1
a104 3
input file specification.  (Under VMS, if there is no directory information
in the input file specification, then the current default device and
directory are returned.)  When using UNIX or MSDOS syntax, the return
a110 2
=back

d113 1
a113 4

## use strict;
use re 'taint';

a116 3
use vars qw($VERSION $Fileparse_fstype $Fileparse_igncase);
$VERSION = "2.6";

d121 2
a122 2
#   Currently recognized values: VMS, MSDOS, MacOS, AmigaOS, os2, RISCOS
#       Any other name uses Unix-style rules and is case-sensitive
d125 3
a127 6
  my @@old = ($Fileparse_fstype, $Fileparse_igncase);
  if (@@_) {
    $Fileparse_fstype = $_[0];
    $Fileparse_igncase = ($_[0] =~ /^(?:MacOS|VMS|AmigaOS|os2|RISCOS|MSWin32|MSDOS)/i);
  }
  wantarray ? @@old : $old[0];
d132 37
a168 1
#   Version 2.4  27-Sep-1996  Charles Bailey  bailey@@genetics.upenn.edu
d173 2
a174 3
  my($fstype,$igncase) = ($Fileparse_fstype, $Fileparse_igncase);
  my($dirpath,$tail,$suffix,$basename);
  my($taint) = substr($fullname,0,0);  # Is $fullname tainted?
d179 2
a180 2
      ($dirpath,$basename) = ($fullname =~ /^(.*[:>\]])?(.*)/);
      $dirpath ||= '';  # should always be defined
d183 3
a185 3
  if ($fstype =~ /^MS(DOS|Win32)/i) {
    ($dirpath,$basename) = ($fullname =~ /^((?:.*[:\\\/])?)(.*)/);
    $dirpath .= '.\\' unless $dirpath =~ /[\\\/]$/;
d187 2
a188 6
  elsif ($fstype =~ /^MacOS/i) {
    ($dirpath,$basename) = ($fullname =~ /^(.*:)?(.*)/);
  }
  elsif ($fstype =~ /^AmigaOS/i) {
    ($dirpath,$basename) = ($fullname =~ /(.*[:\/])?(.*)/);
    $dirpath = './' unless $dirpath;
d191 1
a191 5
    ($dirpath,$basename) = ($fullname =~ m#^(.*/)?(.*)#);
    if ($^O eq 'VMS' and $fullname =~ m:/[^/]+/000000/?:) {
      # dev:[000000] is top of VMS tree, similar to Unix '/'
      ($basename,$dirpath) = ('',$fullname);
    }
d198 1
a198 3
      my $pat = ($igncase ? '(?i)' : '') . "($suffix)\$";
      if ($basename =~ s/$pat//) {
        $taint .= substr($suffix,0,0);
d200 1
d205 2
a206 3
  $tail .= $taint if defined $tail; # avoid warning if $tail == undef
  wantarray ? ($basename . $taint, $dirpath . $taint, $tail)
            : $basename . $taint;
d216 1
a216 1

d231 1
a231 1
        else { return $dirname || $ENV{DEFAULT} }
d235 1
a235 15
        $dirname =~ s/([^:])[\\\/]*$/$1/;
        unless( length($basename) ) {
	    ($basename,$dirname) = fileparse $dirname;
	    $dirname =~ s/([^:])[\\\/]*$/$1/;
	}
    }
    elsif ($fstype =~ /MSWin32/i) { 
        $dirname =~ s/([^:])[\\\/]*$/$1/;
        unless( length($basename) ) {
	    ($basename,$dirname) = fileparse $dirname;
	    $dirname =~ s/([^:])[\\\/]*$/$1/;
	}
    }
    elsif ($fstype =~ /AmigaOS/i) {
        if ( $dirname =~ /:$/) { return $dirname }
d237 2
a238 1
        $dirname =~ s#[^:/]+$## unless length($basename);
d241 4
a244 6
        $dirname =~ s:(.)/*$:$1:;
        unless( length($basename) ) {
	    local($File::Basename::Fileparse_fstype) = $fstype;
	    ($basename,$dirname) = fileparse $dirname;
	    $dirname =~ s:(.)/*$:$1:;
	}
d250 1
a250 1
fileparse_set_fstype $^O;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d40 1
a40 1
these substrings, Unix syntax is used.  This pattern matching is
d43 1
a43 1
they assume you are using Unix emulation and apply the Unix syntax
d76 1
a76 1
Using Unix file syntax:
d105 1
a105 1
programmer compatibility with the Unix shell command basename(1).
d114 2
a115 2
directory are returned.)  When using Unix or MSDOS syntax, the return
value conforms to the behavior of the Unix shell command dirname(1).  This
d127 1
a127 10
# A bit of juggling to insure that C<use re 'taint';> always works, since
# File::Basename is used during the Perl build, when the re extension may
# not be available.
BEGIN {
  unless (eval { require re; })
    { eval ' sub re::import { $^H |= 0x00100000; } ' }
  import re 'taint';
}


a128 2
use 5.005_64;
our(@@ISA, @@EXPORT, $VERSION, $Fileparse_fstype, $Fileparse_igncase);
d132 1
d165 1
a165 1
      ($dirpath,$basename) = ($fullname =~ /^(.*[:>\]])?(.*)/s);
d170 2
a171 2
    ($dirpath,$basename) = ($fullname =~ /^((?:.*[:\\\/])?)(.*)/s);
    $dirpath .= '.\\' unless $dirpath =~ /[\\\/]\z/;
d173 2
a174 2
  elsif ($fstype =~ /^MacOS/si) {
    ($dirpath,$basename) = ($fullname =~ /^(.*:)?(.*)/s);
d177 1
a177 1
    ($dirpath,$basename) = ($fullname =~ /(.*[:\/])?(.*)/s);
d181 1
a181 1
    ($dirpath,$basename) = ($fullname =~ m#^(.*/)?(.*)#s);
d193 1
a193 1
      if ($basename =~ s/$pat//s) {
d231 1
a231 1
        $dirname =~ s/([^:])[\\\/]*\z/$1/;
d234 1
a234 1
	    $dirname =~ s/([^:])[\\\/]*\z/$1/;
d238 1
a238 1
        $dirname =~ s/([^:])[\\\/]*\z/$1/;
d241 1
a241 1
	    $dirname =~ s/([^:])[\\\/]*\z/$1/;
d245 1
a245 1
        if ( $dirname =~ /:\z/) { return $dirname }
d247 1
a247 1
        $dirname =~ s#[^:/]+\z## unless length($basename);
d250 1
a250 1
        $dirname =~ s:(.)/*\z:$1:s;
d254 1
a254 1
	    $dirname =~ s:(.)/*\z:$1:s;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d179 1
a179 1
  if ($fstype =~ /^MS(DOS|Win32)|epoc/i) {
d192 1
a192 1
    if ($^O eq 'VMS' and $fullname =~ m:^(/[^/]+/000000(/|$))(.*):) {
d194 1
a194 5
      # so strip it off and treat the rest as "normal"
      my $devspec  = $1;
      my $remainder = $3;
      ($dirpath,$basename) = ($remainder =~ m#^(.*/)?(.*)#s);
      $dirpath = $devspec.$dirpath;
d239 1
a239 7
    if ($fstype =~ /MacOS/i) {
	if( !length($basename) && $dirname !~ /^[^:]+:\z/) {
	    $dirname =~ s/([^:]):\z/$1/s;
	    ($basename,$dirname) = fileparse $dirname;
	}
	$dirname .= ":" unless $dirname =~ /:\z/;
    }
d259 1
a259 1
    else {
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d20 1
a20 1
    ($name,$path,$suffix) = fileparse("lib/File/Basename.pm",qr{\.pm});
d22 1
a22 1
    $basename = basename("lib/File/Basename.pm",qr{\.pm});
d63 1
a63 2
this list can be a qr-quoted pattern (or a string which is interpreted
as a regular expression), and is matched
d79 1
a79 1
				    qr{\.book\d+});
d90 1
a90 1
				   qr{\..*});
d138 1
a138 2
use 5.006;
use warnings;
d143 1
a143 1
$VERSION = "2.71";
a167 4
  unless (defined $fullname) {
      require Carp;
      Carp::croak "fileparse(): need a valid pathname";
  }
a182 5
  elsif ($fstype =~ /^os2/i) {
    ($dirpath,$basename) = ($fullname =~ m#^((?:.*[:\\/])?)(.*)#s);
    $dirpath = './' unless $dirpath;	# Can't be 0
    $dirpath .= '/' unless $dirpath =~ m#[\\/]\z#;
  }
a184 1
    $dirpath = ':' unless $dirpath;
a197 1
      $dirpath ||= '';  # should always be defined
d215 2
a216 2
  wantarray ? ($basename .= $taint, $dirpath .= $taint, $tail)
            : ($basename .= $taint);
d250 8
a257 1
    elsif ($fstype =~ /MS(DOS|Win32)|os2/i) { 
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d22 1
a22 1
    $basename = basename("lib/File/Basename.pm",".pm");
d133 1
a133 1
    { eval ' sub re::import { $^H |= 0x00100000; } ' } # HINT_RE_TAINT
d145 1
a145 1
$VERSION = "2.72";
d172 1
a172 1
      Carp::croak("fileparse(): need a valid pathname");
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d15 1
a15 2
    ($name,$path,$suffix) = fileparse($fullname,@@suffixlist);
    $name = fileparse($fullname,@@suffixlist);
a72 2
In scalar context, fileparse() returns only the B<name> part of the filename.

d145 1
a145 1
$VERSION = "2.73";
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d1 2
d5 5
a9 1
File::Basename - Parse file paths into directory, filename and suffix.
d17 1
a17 1

d19 1
a19 1
    $dirname  = dirname($fullname);
d21 4
d28 51
a78 2
These routines allow you to parse file paths into their directory, filename
and suffix.
d80 1
a80 5
B<NOTE>: C<dirname()> and C<basename()> emulate the behaviours, and
quirks, of the shell and C functions of the same name.  See each
function's documentation for details.  If your concern is just parsing
paths it is safer to use L<File::Spec>'s C<splitpath()> and
C<splitdir()> methods.
d82 2
a83 1
It is guaranteed that
d85 1
a85 2
    # Where $path_separator is / for Unix, \ for Windows, etc...
    dirname($path) . $path_separator . basename($path);
d87 3
a89 1
is equivalent to the original path for all systems but VMS.
d91 35
d130 1
a130 2
package File::Basename;

d141 1
a141 1
use strict;
d148 1
a148 1
$VERSION = "2.74";
a149 1
fileparse_set_fstype($^O);
d151 5
d157 8
a164 30
=over 4

=item C<fileparse>

    my($filename, $directories, $suffix) = fileparse($path);
    my($filename, $directories, $suffix) = fileparse($path, @@suffixes);
    my $filename                         = fileparse($path, @@suffixes);

The C<fileparse()> routine divides a file path into its $directories, $filename
and (optionally) the filename $suffix.

$directories contains everything up to and including the last
directory separator in the $path including the volume (if applicable).
The remainder of the $path is the $filename.

     # On Unix returns ("baz", "/foo/bar/", "")
     fileparse("/foo/bar/baz");

     # On Windows returns ("baz", "C:\foo\bar\", "")
     fileparse("C:\foo\bar\baz");

     # On Unix returns ("", "/foo/bar/baz/", "")
     fileparse("/foo/bar/baz/");

If @@suffixes are given each element is a pattern (either a string or a
C<qr//>) matched against the end of the $filename.  The matching
portion is removed and becomes the $suffix.

     # On Unix returns ("baz", "/foo/bar", ".txt")
     fileparse("/foo/bar/baz", qr/\.[^.]*/);
d166 3
a168 8
If type is non-Unix (see C<fileparse_set_fstype()>) then the pattern
matching for suffix removal is performed case-insensitively, since
those systems are not case-sensitive when opening existing files.

You are guaranteed that C<$directories . $filename . $suffix> will
denote the same location as the original $path.

=cut
a172 1

d177 2
a178 4

  my $orig_type = '';
  my($type,$igncase) = ($Fileparse_fstype, $Fileparse_igncase);

d181 6
a186 4
  if ($type eq "VMS" and $fullname =~ m{/} ) {
    # We're doing Unix emulation
    $orig_type = $type;
    $type = 'Unix';
d188 1
a188 4

  my($dirpath, $basename);

  if (grep { $type eq $_ } qw(MSDOS DOS MSWin32 Epoc)) {
d192 1
a192 1
  elsif ($type eq "OS2") {
d197 1
a197 1
  elsif ($type eq "MacOS") {
d201 1
a201 1
  elsif ($type eq "AmigaOS") {
d205 1
a205 5
  elsif ($type eq 'VMS' ) {
    ($dirpath,$basename) = ($fullname =~ /^(.*[:>\]])?(.*)/s);
    $dirpath ||= '';  # should always be defined
  }
  else { # Default to Unix semantics.
d207 1
a207 1
    if ($orig_type eq 'VMS' and $fullname =~ m:^(/[^/]+/000000(/|$))(.*):) {
a217 1
      
a218 2
  my $tail   = '';
  my $suffix = '';
d220 1
d230 1
a230 2
  # Ensure taint is propgated from the path to its pieces.
  $tail .= $taint;
d236 1
a236 32

=item C<basename>

    my $filename = basename($path);
    my $filename = basename($path, @@suffixes);

This function is provided for compatibility with the Unix shell command 
C<basename(1)>.  It does B<NOT> always return the file name portion of a
path as you might expect.  To be safe, if you want the file name portion of
a path use C<fileparse()>.

C<basename()> returns the last level of a filepath even if the last
level is clearly directory.  In effect, it is acting like C<pop()> for
paths.  This differs from C<fileparse()>'s behaviour.

    # Both return "bar"
    basename("/foo/bar");
    basename("/foo/bar/");

@@suffixes work as in C<fileparse()> except all regex metacharacters are
quoted.

    # These two function calls are equivalent.
    my $filename = basename("/foo/bar/baz.txt",  ".txt");
    my $filename = fileparse("/foo/bar/baz.txt", qr/\Q.txt\E/);

Also note that in order to be compatible with the shell command,
C<basename()> does not strip off a suffix if it is identical to the
remaining characters in the filename.

=cut

d239 2
a240 22
  my($path) = shift;

  # From BSD basename(1)
  # The basename utility deletes any prefix ending with the last slash `/'
  # character present in string (after first stripping trailing slashes)
  _strip_trailing_sep($path);

  my($basename, $dirname, $suffix) = fileparse( $path, map("\Q$_\E",@@_) );

  # From BSD basename(1)
  # The suffix is not stripped if it is identical to the remaining 
  # characters in string.
  if( length $suffix and !length $basename ) {
      $basename = $suffix;
  }
  
  # Ensure that basename '/' == '/'
  if( !length $basename ) {
      $basename = $dirname;
  }

  return $basename;
d244 6
a249 41

=item C<dirname>

This function is provided for compatibility with the Unix shell
command C<dirname(1)> and has inherited some of its quirks.  In spite of
its name it does B<NOT> always return the directory name as you might
expect.  To be safe, if you want the directory name of a path use
C<fileparse()>.

Only on VMS (where there is no ambiguity between the file and directory
portions of a path) and AmigaOS (possibly due to an implementation quirk in
this module) does C<dirname()> work like C<fileparse($path)>, returning just the
$directories.

    # On VMS and AmigaOS
    my $directories = dirname($path);

When using Unix or MSDOS syntax this emulates the C<dirname(1)> shell function
which is subtly different from how C<fileparse()> works.  It returns all but
the last level of a file path even if the last level is clearly a directory.
In effect, it is not returning the directory portion but simply the path one
level up acting like C<chop()> for file paths.

Also unlike C<fileparse()>, C<dirname()> does not include a trailing slash on
its returned path.

    # returns /foo/bar.  fileparse() would return /foo/bar/
    dirname("/foo/bar/baz");

    # also returns /foo/bar despite the fact that baz is clearly a 
    # directory.  fileparse() would return /foo/bar/baz/
    dirname("/foo/bar/baz/");

    # returns '.'.  fileparse() would return 'foo/'
    dirname("foo/");

Under VMS, if there is no directory information in the $path, then the
current default device and directory is used.

=cut

d252 2
a253 9
    my $path = shift;

    my($type) = $Fileparse_fstype;

    if( $type eq 'VMS' and $path =~ m{/} ) {
        # Parse as Unix
        local($File::Basename::Fileparse_fstype) = '';
        return dirname($path);
    }
d255 3
a257 4
    my($basename, $dirname) = fileparse($path);

    if ($type eq 'VMS') { 
        $dirname ||= $ENV{DEFAULT};
d259 1
a259 1
    elsif ($type eq 'MacOS') {
d261 1
a261 1
            _strip_trailing_sep($dirname);
d266 2
a267 2
    elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
        _strip_trailing_sep($dirname);
d270 1
a270 1
	    _strip_trailing_sep($dirname);
d273 1
a273 1
    elsif ($type eq 'AmigaOS') {
d279 1
a279 1
        _strip_trailing_sep($dirname);
d281 1
d283 1
a283 1
	    _strip_trailing_sep($dirname);
d290 1
a290 66

# Strip the trailing path separator.
sub _strip_trailing_sep  {
    my $type = $Fileparse_fstype;

    if ($type eq 'MacOS') {
        $_[0] =~ s/([^:]):\z/$1/s;
    }
    elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
        $_[0] =~ s/([^:])[\\\/]*\z/$1/;
    }
    else {
        $_[0] =~ s{(.)/*\z}{$1}s;
    }
}


=item C<fileparse_set_fstype>

  my $type = fileparse_set_fstype();
  my $previous_type = fileparse_set_fstype($type);

Normally File::Basename will assume a file path type native to your current
operating system (ie. /foo/bar style on Unix, \foo\bar on Windows, etc...).
With this function you can override that assumption.

Valid $types are "MacOS", "VMS", "AmigaOS", "OS2", "RISCOS",
"MSWin32", "DOS" (also "MSDOS" for backwards bug compatibility),
"Epoc" and "Unix" (all case-insensitive).  If an unrecognized $type is
given "Unix" will be assumed.

If you've selected VMS syntax, and the file specification you pass to
one of these routines contains a "/", they assume you are using Unix
emulation and apply the Unix syntax rules instead, for that function
call only.

=back

=cut


BEGIN {

my @@Ignore_Case = qw(MacOS VMS AmigaOS OS2 RISCOS MSWin32 MSDOS DOS Epoc);
my @@Types = (@@Ignore_Case, qw(Unix));

sub fileparse_set_fstype {
    my $old = $Fileparse_fstype;

    if (@@_) {
        my $new_type = shift;

        $Fileparse_fstype = 'Unix';  # default
        foreach my $type (@@Types) {
            $Fileparse_fstype = $type if $new_type =~ /^$type/i;
        }

        $Fileparse_igncase = 
          (grep $Fileparse_fstype eq $_, @@Ignore_Case) ? 1 : 0;
    }

    return $old;
}

}

a292 5


=head1 SEE ALSO

L<dirname(1)>, L<basename(1)>, L<File::Spec>
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d57 1
a57 1
$VERSION = "2.76";
a64 1
X<fileparse>
d91 1
a91 1
     fileparse("/foo/bar/baz.txt", qr/\.[^.]*/);
d146 2
a147 2
    ($dirpath,$basename) = ($fullname =~ m{^(.*/)?(.*)}s);
    if ($orig_type eq 'VMS' and $fullname =~ m{^(/[^/]+/000000(/|$))(.*)}) {
d152 1
a152 1
      ($dirpath,$basename) = ($remainder =~ m{^(.*/)?(.*)}s);
a180 1
X<basename> X<filename>
d185 1
a185 1
This function is provided for compatibility with the Unix shell command
a239 1
X<dirname>
d313 1
a313 1
        $dirname =~ s{[^:/]+\z}{} unless length($basename);
a343 1
X<filesystem>
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d57 1
a57 1
$VERSION = "2.77";
d91 1
a91 1
     # On Unix returns ("baz", "/foo/bar/", ".txt")
@


1.1.1.11
log
@Perl 5.12.2 from CPAN
@
text
@d40 1
d42 1
a42 1
# not be available, but we only actually need it if running under tainting.
d44 3
a46 4
  if (${^TAINT}) {
    require re;
    re->import('taint');
  }
d57 1
a57 1
$VERSION = "2.78";
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d57 1
a57 1
$VERSION = "2.84";
d81 2
a82 2
     # On Windows returns ("baz", 'C:\foo\bar\', "")
     fileparse('C:\foo\bar\baz');
d94 1
a94 1
If type is non-Unix (see L</fileparse_set_fstype>) then the pattern
d173 1
a173 1
  # Ensure taint is propagated from the path to its pieces.
d218 1
a218 1
  # The basename utility deletes any prefix ending with the last slash '/'
@


1.1.1.13
log
@Import perl-5.20.1
@
text
@d57 1
a57 1
$VERSION = "2.85";
d67 3
a69 3
    my($filename, $dirs, $suffix) = fileparse($path);
    my($filename, $dirs, $suffix) = fileparse($path, @@suffixes);
    my $filename                  = fileparse($path, @@suffixes);
d71 1
a71 1
The C<fileparse()> routine divides a file path into its $dirs, $filename
d74 1
a74 1
$dirs contains everything up to and including the last
d98 1
a98 1
You are guaranteed that C<$dirs . $filename . $suffix> will
d253 1
a253 1
$dirs.
d256 1
a256 1
    my $dirs = dirname($path);
@


