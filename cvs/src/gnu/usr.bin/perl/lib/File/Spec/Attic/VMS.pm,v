head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.9.0.4
	OPENBSD_4_8_BASE:1.1.1.9
	OPENBSD_4_7:1.1.1.9.0.2
	OPENBSD_4_7_BASE:1.1.1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.1.1.8.0.6
	OPENBSD_4_6_BASE:1.1.1.8
	OPENBSD_4_5:1.1.1.8.0.2
	OPENBSD_4_5_BASE:1.1.1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.1.1.7.0.10
	OPENBSD_4_4_BASE:1.1.1.7
	OPENBSD_4_3:1.1.1.7.0.8
	OPENBSD_4_3_BASE:1.1.1.7
	OPENBSD_4_2:1.1.1.7.0.6
	OPENBSD_4_2_BASE:1.1.1.7
	OPENBSD_4_1:1.1.1.7.0.4
	OPENBSD_4_1_BASE:1.1.1.7
	OPENBSD_4_0:1.1.1.7.0.2
	OPENBSD_4_0_BASE:1.1.1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.1.1.6.0.6
	OPENBSD_3_9_BASE:1.1.1.6
	OPENBSD_3_8:1.1.1.6.0.4
	OPENBSD_3_8_BASE:1.1.1.6
	OPENBSD_3_7:1.1.1.6.0.2
	OPENBSD_3_7_BASE:1.1.1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2010.09.24.14.59.40;	author millert;	state dead;
branches;
next	1.1;

1.1
date	99.04.29.22.40.10;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.10;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.32;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.04;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.17.19;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.47;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.35;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.59;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@
package File::Spec::VMS;

use Carp qw( &carp );
use Config;
require Exporter;
use VMS::Filespec;
use File::Basename;

use File::Spec;
use vars qw($Revision);
$Revision = '5.3901 (6-Mar-1997)';

@@ISA = qw(File::Spec::Unix);

Exporter::import('File::Spec', '$Verbose');

=head1 NAME

File::Spec::VMS - methods for VMS file specs

=head1 SYNOPSIS

 use File::Spec::VMS; # Done internally by File::Spec if needed

=head1 DESCRIPTION

See File::Spec::Unix for a documentation of the methods provided
there. This package overrides the implementation of these methods, not
the semantics.

=head2 Methods always loaded

=over

=item catdir

Concatenates a list of file specifications, and returns the result as a
VMS-syntax directory specification.

=cut

sub catdir {
    my($self,@@dirs) = @@_;
    my($dir) = pop @@dirs;
    @@dirs = grep($_,@@dirs);
    my($rslt);
    if (@@dirs) {
      my($path) = (@@dirs == 1 ? $dirs[0] : $self->catdir(@@dirs));
      my($spath,$sdir) = ($path,$dir);
      $spath =~ s/.dir$//; $sdir =~ s/.dir$//; 
      $sdir = $self->eliminate_macros($sdir) unless $sdir =~ /^[\w\-]+$/;
      $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
    }
    else { 
      if ($dir =~ /^\$\([^\)]+\)$/) { $rslt = $dir; }
      else                          { $rslt = vmspath($dir); }
    }
    print "catdir(",join(',',@@_[1..$#_]),") = |$rslt|\n" if $Verbose >= 3;
    $rslt;
}

=item catfile

Concatenates a list of file specifications, and returns the result as a
VMS-syntax directory specification.

=cut

sub catfile {
    my($self,@@files) = @@_;
    my($file) = pop @@files;
    @@files = grep($_,@@files);
    my($rslt);
    if (@@files) {
      my($path) = (@@files == 1 ? $files[0] : $self->catdir(@@files));
      my($spath) = $path;
      $spath =~ s/.dir$//;
      if ( $spath =~ /^[^\)\]\/:>]+\)$/ && basename($file) eq $file) { $rslt = "$spath$file"; }
      else {
          $rslt = $self->eliminate_macros($spath);
          $rslt = vmsify($rslt.($rslt ? '/' : '').unixify($file));
      }
    }
    else { $rslt = vmsify($file); }
    print "catfile(",join(',',@@_[1..$#_]),") = |$rslt|\n" if $Verbose >= 3;
    $rslt;
}

=item curdir (override)

Returns a string representing of the current directory.

=cut

sub curdir {
    return '[]';
}

=item rootdir (override)

Returns a string representing of the root directory.

=cut

sub rootdir {
    return '';
}

=item updir (override)

Returns a string representing of the parent directory.

=cut

sub updir {
    return '[-]';
}

=item path (override)

Translate logical name DCL$PATH as a searchlist, rather than trying
to C<split> string value of C<$ENV{'PATH'}>.

=cut

sub path {
    my(@@dirs,$dir,$i);
    while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@@dirs,$dir); }
    @@dirs;
}

=item file_name_is_absolute (override)

Checks for VMS directory spec as well as Unix separators.

=cut

sub file_name_is_absolute {
    my($self,$file) = @@_;
    # If it's a logical name, expand it.
    $file = $ENV{$file} while $file =~ /^[\w\$\-]+$/ and $ENV{$file};
    $file =~ m!^/! or $file =~ m![<\[][^.\-\]>]! or $file =~ /:[^<\[]/;
}

1;
__END__

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d1 1
d4 10
a13 3
use strict;
use vars qw(@@ISA);
require File::Spec::Unix;
d16 1
a16 3
use Cwd;
use File::Basename;
use VMS::Filespec;
d24 1
a24 1
 require File::Spec::VMS; # Done internally by File::Spec if needed
a31 99
=over

=item eliminate_macros

Expands MM[KS]/Make macros in a text string, using the contents of
identically named elements of C<%$self>, and returns the result
as a file specification in Unix syntax.

=cut

sub eliminate_macros {
    my($self,$path) = @@_;
    return '' unless $path;
    $self = {} unless ref $self;
    my($npath) = unixify($path);
    my($complex) = 0;
    my($head,$macro,$tail);

    # perform m##g in scalar context so it acts as an iterator
    while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
        if ($self->{$2}) {
            ($head,$macro,$tail) = ($1,$2,$3);
            if (ref $self->{$macro}) {
                if (ref $self->{$macro} eq 'ARRAY') {
                    $macro = join ' ', @@{$self->{$macro}};
                }
                else {
                    print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                          "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                    $macro = "\cB$macro\cB";
                    $complex = 1;
                }
            }
            else { ($macro = unixify($self->{$macro})) =~ s#/\z##; }
            $npath = "$head$macro$tail";
        }
    }
    if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
    $npath;
}

=item fixpath

Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
in any directory specification, in order to avoid juxtaposing two
VMS-syntax directories when MM[SK] is run.  Also expands expressions which
are all macro, so that we can tell how long the expansion is, and avoid
overrunning DCL's command buffer when MM[KS] is running.

If optional second argument has a TRUE value, then the return string is
a VMS-syntax directory specification, if it is FALSE, the return string
is a VMS-syntax file specification, and if it is not specified, fixpath()
checks to see whether it matches the name of a directory in the current
default directory, and returns a directory or file specification accordingly.

=cut

sub fixpath {
    my($self,$path,$force_path) = @@_;
    return '' unless $path;
    $self = bless {} unless ref $self;
    my($fixedpath,$prefix,$name);

    if ($path =~ m#^\$\([^\)]+\)\z#s || $path =~ m#[/:>\]]#) { 
        if ($force_path or $path =~ /(?:DIR\)|\])\z/) {
            $fixedpath = vmspath($self->eliminate_macros($path));
        }
        else {
            $fixedpath = vmsify($self->eliminate_macros($path));
        }
    }
    elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
        my($vmspre) = $self->eliminate_macros("\$($prefix)");
        # is it a dir or just a name?
        $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\z/) ? vmspath($vmspre) : '';
        $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    else {
        $fixedpath = $path;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    # No hints, so we try to guess
    if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
        $fixedpath = vmspath($fixedpath) if -d $fixedpath;
    }

    # Trim off root dirname if it's had other dirs inserted in front of it.
    $fixedpath =~ s/\.000000([\]>])/$1/;
    # Special case for VMS absolute directory specs: these will have had device
    # prepended during trip through Unix syntax in eliminate_macros(), since
    # Unix syntax has no way to express "absolute from the top of this device's
    # directory tree".
    if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
    $fixedpath;
}

=back

a35 27
=item canonpath (override)

Removes redundant portions of file specifications according to VMS syntax.

=cut

sub canonpath {
    my($self,$path) = @@_;

    if ($path =~ m|/|) { # Fake Unix
      my $pathify = $path =~ m|/\z|;
      $path = $self->SUPER::canonpath($path);
      if ($pathify) { return vmspath($path); }
      else          { return vmsify($path);  }
    }
    else {
      $path =~ s-\]\[--g;  $path =~ s/><//g;            # foo.][bar       ==> foo.bar
      $path =~ s/([\[<])000000\./$1/;                   # [000000.foo     ==> foo
      1 while $path =~ s{([\[<-])\.-}{$1-};             # [.-.-           ==> [--
      $path =~ s/\.[^\[<\.]+\.-([\]\>])/$1/;            # bar.foo.-]      ==> bar]
      $path =~ s/([\[<])(-+)/$1 . "\cx" x length($2)/e; # encode leading '-'s
      $path =~ s/([\[<\.])([^\[<\.\cx]+)\.-\.?/$1/g;    # bar.-.foo       ==> foo
      $path =~ s/([\[<])(\cx+)/$1 . '-' x length($2)/e; # then decode
      return $path;
    }
}

d39 1
a39 2
VMS-syntax directory specification.  No check is made for "impossible"
cases (e.g. elements other than the first being absolute filespecs).
d44 2
a45 2
    my ($self,@@dirs) = @@_;
    my $dir = pop @@dirs;
d47 1
a47 1
    my $rslt;
d49 9
a57 16
	my $path = (@@dirs == 1 ? $dirs[0] : $self->catdir(@@dirs));
	my ($spath,$sdir) = ($path,$dir);
	$spath =~ s/\.dir\z//; $sdir =~ s/\.dir\z//; 
	$sdir = $self->eliminate_macros($sdir) unless $sdir =~ /^[\w\-]+\z/s;
	$rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);

	# Special case for VMS absolute directory specs: these will have had device
	# prepended during trip through Unix syntax in eliminate_macros(), since
	# Unix syntax has no way to express "absolute from the top of this device's
	# directory tree".
	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
    }
    else {
	if    (not defined $dir or not length $dir) { $rslt = ''; }
	elsif ($dir =~ /^\$\([^\)]+\)\z/s)          { $rslt = $dir; }
	else                                        { $rslt = vmspath($dir); }
d59 2
a60 1
    return $self->canonpath($rslt);
d66 1
a66 1
VMS-syntax file specification.
d71 2
a72 2
    my ($self,@@files) = @@_;
    my $file = pop @@files;
d74 1
a74 1
    my $rslt;
d76 12
a87 13
	my $path = (@@files == 1 ? $files[0] : $self->catdir(@@files));
	my $spath = $path;
	$spath =~ s/\.dir\z//;
	if ($spath =~ /^[^\)\]\/:>]+\)\z/s && basename($file) eq $file) {
	    $rslt = "$spath$file";
	}
	else {
	    $rslt = $self->eliminate_macros($spath);
	    $rslt = vmsify($rslt.($rslt ? '/' : '').unixify($file));
	}
    }
    else { $rslt = (defined($file) && length($file)) ? vmsify($file) : ''; }
    return $self->canonpath($rslt);
a89 1

d92 1
a92 1
Returns a string representation of the current directory: '[]'
a99 10
=item devnull (override)

Returns a string representation of the null device: '_NLA0:'

=cut

sub devnull {
    return "_NLA0:";
}

d102 1
a102 1
Returns a string representation of the root directory: 'SYS$DISK:[000000]'
d107 1
a107 23
    return 'SYS$DISK:[000000]';
}

=item tmpdir (override)

Returns a string representation of the first writable directory
from the following list or '' if none are writable:

    sys$scratch
    $ENV{TMPDIR}

=cut

my $tmpdir;
sub tmpdir {
    return $tmpdir if defined $tmpdir;
    foreach ('sys$scratch', $ENV{TMPDIR}) {
	next unless defined && -d && -w _;
	$tmpdir = $_;
	last;
    }
    $tmpdir = '' unless defined $tmpdir;
    return $tmpdir;
d112 1
a112 1
Returns a string representation of the parent directory: '[-]'
a119 10
=item case_tolerant (override)

VMS file specification syntax is case-tolerant.

=cut

sub case_tolerant {
    return 1;
}

d128 1
a128 1
    my (@@dirs,$dir,$i);
d130 1
a130 1
    return @@dirs;
d140 1
a140 1
    my ($self,$file) = @@_;
d142 2
a143 4
    $file = $ENV{$file} while $file =~ /^[\w\$\-]+\z/s && $ENV{$file};
    return scalar($file =~ m!^/!s             ||
		  $file =~ m![<\[][^.\-\]>]!  ||
		  $file =~ /:[^<\[]/);
d146 2
a147 58
=item splitpath (override)

Splits using VMS syntax.

=cut

sub splitpath {
    my($self,$path) = @@_;
    my($dev,$dir,$file) = ('','','');

    vmsify($path) =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
    return ($1 || '',$2 || '',$3);
}

=item splitdir (override)

Split dirspec using VMS syntax.

=cut

sub splitdir {
    my($self,$dirspec) = @@_;
    $dirspec =~ s/\]\[//g;  $dirspec =~ s/\-\-/-.-/g;
    $dirspec = "[$dirspec]" unless $dirspec =~ /[\[<]/; # make legal
    my(@@dirs) = split('\.', vmspath($dirspec));
    $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\z//s;
    @@dirs;
}


=item catpath (override)

Construct a complete filespec using VMS syntax

=cut

sub catpath {
    my($self,$dev,$dir,$file) = @@_;
    if ($dev =~ m|^/+([^/]+)|) { $dev = "$1:"; }
    else { $dev .= ':' unless $dev eq '' or $dev =~ /:\z/; }
    if (length($dev) or length($dir)) {
      $dir = "[$dir]" unless $dir =~ /[\[<\/]/;
      $dir = vmspath($dir);
    }
    "$dev$dir$file";
}

=item abs2rel (override)

Use VMS syntax when converting filespecs.

=cut

sub abs2rel {
    my $self = shift;

    return vmspath(File::Spec::Unix::abs2rel( $self, @@_ ))
        if ( join( '', @@_ ) =~ m{/} ) ;
a148 115
    my($path,$base) = @@_;

    # Note: we use '/' to glue things together here, then let canonpath()
    # clean them up at the end.

    # Clean up $path
    if ( ! $self->file_name_is_absolute( $path ) ) {
        $path = $self->rel2abs( $path ) ;
    }
    else {
        $path = $self->canonpath( $path ) ;
    }

    # Figure out the effective $base and clean it up.
    if ( !defined( $base ) || $base eq '' ) {
        $base = cwd() ;
    }
    elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
    }
    else {
        $base = $self->canonpath( $base ) ;
    }

    # Split up paths
    my ( undef, $path_directories, $path_file ) =
        $self->splitpath( $path, 1 ) ;

    $path_directories = $1
        if $path_directories =~ /^\[(.*)\]\z/s ;

    my ( undef, $base_directories, undef ) =
        $self->splitpath( $base, 1 ) ;

    $base_directories = $1
        if $base_directories =~ /^\[(.*)\]\z/s ;

    # Now, remove all leading components that are the same
    my @@pathchunks = $self->splitdir( $path_directories );
    my @@basechunks = $self->splitdir( $base_directories );

    while ( @@pathchunks && 
            @@basechunks && 
            lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
          ) {
        shift @@pathchunks ;
        shift @@basechunks ;
    }

    # @@basechunks now contains the directories to climb out of,
    # @@pathchunks now has the directories to descend in to.
    $path_directories = '-.' x @@basechunks . join( '.', @@pathchunks ) ;
    $path_directories =~ s{\.\z}{} ;
    return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
}


=item rel2abs (override)

Use VMS syntax when converting filespecs.

=cut

sub rel2abs($;$;) {
    my $self = shift ;
    return vmspath(File::Spec::Unix::rel2abs( $self, @@_ ))
        if ( join( '', @@_ ) =~ m{/} ) ;

    my ($path,$base ) = @@_;
    # Clean up and split up $path
    if ( ! $self->file_name_is_absolute( $path ) ) {
        # Figure out the effective $base and clean it up.
        if ( !defined( $base ) || $base eq '' ) {
            $base = cwd() ;
        }
        elsif ( ! $self->file_name_is_absolute( $base ) ) {
            $base = $self->rel2abs( $base ) ;
        }
        else {
            $base = $self->canonpath( $base ) ;
        }

        # Split up paths
        my ( undef, $path_directories, $path_file ) =
            $self->splitpath( $path ) ;

        my ( $base_volume, $base_directories, undef ) =
            $self->splitpath( $base ) ;

        $path_directories = '' if $path_directories eq '[]' ||
                                  $path_directories eq '<>';
        my $sep = '' ;
        $sep = '.'
            if ( $base_directories =~ m{[^.\]>]\z} &&
                 $path_directories =~ m{^[^.\[<]}s
            ) ;
        $base_directories = "$base_directories$sep$path_directories";
        $base_directories =~ s{\.?[\]>][\[<]\.?}{.};

        $path = $self->catpath( $base_volume, $base_directories, $path_file );
   }

    return $self->canonpath( $path ) ;
}


=back

=head1 SEE ALSO

L<File::Spec>

=cut

1;
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d4 1
a4 1
use vars qw(@@ISA $VERSION);
a5 3

$VERSION = '1.1';

a39 5

    if ($path =~ /\s/) {
      return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
    }

d59 1
a59 1
            else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
d89 2
a90 8
    if ($path =~ /\s/) {
      return join ' ',
             map { $self->fixpath($_,$force_path) }
	     split /\s+/, $path;
    }

    if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
        if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
d100 1
a100 1
        $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
d139 1
a139 1
      my $pathify = $path =~ m|/\Z(?!\n)|;
d172 2
a173 2
	$spath =~ s/\.dir\Z(?!\n)//; $sdir =~ s/\.dir\Z(?!\n)//; 
	$sdir = $self->eliminate_macros($sdir) unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
d184 1
a184 1
	elsif ($dir =~ /^\$\([^\)]+\)\Z(?!\n)/s)          { $rslt = $dir; }
d205 2
a206 2
	$spath =~ s/\.dir\Z(?!\n)//;
	if ($spath =~ /^[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
d254 1
a254 1
    sys$scratch:
d262 1
a262 1
    foreach ('sys$scratch:', $ENV{TMPDIR}) {
d313 1
a313 1
    $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
d344 1
a344 1
    $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
d358 1
a358 1
    else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
d403 2
a404 2
    my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
d407 1
a407 1
        if $path_directories =~ /^\[(.*)\]\Z(?!\n)/s ;
d409 2
a410 1
    my $base_directories = ($self->splitpath( $base, 1 ))[1] ;
d413 1
a413 1
        if $base_directories =~ /^\[(.*)\]\Z(?!\n)/s ;
d430 1
a430 1
    $path_directories =~ s{\.\Z(?!\n)}{} ;
d441 1
a441 1
sub rel2abs {
d461 2
a462 2
        my ( $path_directories, $path_file ) =
            ($self->splitpath( $path ))[1,2] ;
d464 1
a464 1
        my ( $base_volume, $base_directories ) =
d471 1
a471 1
            if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d7 1
a7 1
$VERSION = '1.2';
d29 1
a29 1
=over 4
d141 1
a141 1
=over 4
a158 2
      $path =~ s/([\[<])000000\./$1/g;                  # [000000.foo     ==> [foo
      $path =~ s/([^-]+)\.(\]\[|><)?000000([\]\>])/$1$3/g;  # foo.000000] ==> foo]
d160 1
a270 3
Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
is tainted, it is not used.

d276 1
a276 9
    my @@dirlist = ('sys$scratch:', $ENV{TMPDIR});
    {
	no strict 'refs';
	if (${"\cTAINT"}) { # Check for taint mode on perl >= 5.8.0
            require Scalar::Util;
	    pop @@dirlist if Scalar::Util::tainted($ENV{TMPDIR});
	}
    }
    foreach (@@dirlist) {
a407 1
        $base = $self->canonpath( $base ) ;
a429 1
    unshift(@@pathchunks,'000000') unless $pathchunks[0] eq '000000';
a430 1
    unshift(@@basechunks,'000000') unless $basechunks[0] eq '000000';
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d7 1
a7 1
$VERSION = '1.4';
d11 1
a166 1
      $path =~ s/^[\[<\]>]{2}//;                        # []foo           ==> foo
d214 1
a214 1
    my $file = $self->canonpath(pop @@files);
d280 15
a294 2
    my $self = shift;
    $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
a382 6
    
    # We look for a volume in $dev, then in $dir, but not both
    my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
    $dev = $dir_volume unless length $dev;
    $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
    
d400 1
d402 1
a402 1
        if grep m{/}, @@_;
a404 1
    $base = $self->_cwd() unless defined $base and length $base;
d406 2
a407 1
    for ($path, $base) { $_ = $self->canonpath($_) }
d409 7
a415 13
    # Are we even starting $path on the same (node::)device as $base?  Note that
    # logical paths or nodename differences may be on the "same device" 
    # but the comparison that ignores device differences so as to concatenate 
    # [---] up directory specs is not even a good idea in cases where there is 
    # a logical path difference between $path and $base nodename and/or device.
    # Hence we fall back to returning the absolute $path spec
    # if there is a case blind device (or node) difference of any sort
    # and we do not even try to call $parse() or consult %ENV for $trnlnm()
    # (this module needs to run on non VMS platforms after all).
    
    my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
    my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
    return $path unless lc($path_volume) eq lc($base_volume);
d417 23
a439 1
    for ($path, $base) { $_ = $self->rel2abs($_) }
d457 2
a458 1
    $path_directories = join '.', ('-' x @@basechunks, @@pathchunks) ;
d479 1
a479 1
            $base = $self->_cwd;
d516 1
a516 5
See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
implementation of these methods, not the semantics.

An explanation of VMS file specs can be found at
L<"http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files">.
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d158 10
a167 30
	$path =~ tr/<>/[]/;			# < and >       ==> [ and ]
	$path =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
	$path =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
	$path =~ s/\[000000\./\[/g;		# [000000.	==> [
	$path =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
	$path =~ s/\.\]\[/\./g;			# foo.][bar     ==> foo.bar
	1 while ($path =~ s/([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
						# That loop does the following
						# with any amount of dashes:
						# .-.-.		==> .--.
						# [-.-.		==> [--.
						# .-.-]		==> .--]
						# [-.-]		==> [--]
	1 while ($path =~ s/([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
						# That loop does the following
						# with any amount (minimum 2)
						# of dashes:
						# .foo.--.	==> .-.
						# .foo.--]	==> .-]
						# [foo.--.	==> [-.
						# [foo.--]	==> [-]
						#
						# And then, the remaining cases
	$path =~ s/\[\.-/[-/;			# [.-		==> [-
	$path =~ s/\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
	$path =~ s/\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
	$path =~ s/\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
	$path =~ s/\[[^\]\.]+\.-\]/\[\]/g;	# [foo.-]	==> []
	$path =~ s/\[\]//;			# []		==>
	return $path;
d354 1
a354 13
    $dirspec =~ tr/<>/[]/;			# < and >	==> [ and ]
    $dirspec =~ s/\]\[\./\.\]\[/g;		# ][.		==> .][
    $dirspec =~ s/\[000000\.\]\[/\[/g;		# [000000.][	==> [
    $dirspec =~ s/\[000000\./\[/g;		# [000000.	==> [
    $dirspec =~ s/\.\]\[000000\]/\]/g;		# .][000000]	==> ]
    $dirspec =~ s/\.\]\[/\./g;			# foo.][bar	==> foo.bar
    while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
						# That loop does the following
						# with any amount of dashes:
						# .--.		==> .-.-.
						# [--.		==> [-.-.
						# .--]		==> .-.-]
						# [--]		==> [-.-]
d446 3
a449 3
    return undef unless defined $path;
    $path = vmsify($path) if $path =~ m/\//;
    $base = vmspath($base) if defined $base && $base =~ m/\//;
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d30 112
d185 1
a185 1
	$path =~ s/\[[^\]\.]+\.-\]/\[000000\]/g;# [foo.-]       ==> [000000]
d191 1
a191 1
=item catdir (override)
d225 1
a225 1
=item catfile (override)
d300 2
a301 1
    $tmpdir = $_[0]->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
d480 1
a480 5
    if ($path =~ m/\//) {
	$path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
		   ? vmspath($path)             # whether it's a directory
		   : vmsify($path) );
    }
a518 92
# eliminate_macros() and fixpath() are MakeMaker-specific methods
# which are used inside catfile() and catdir().  MakeMaker has its own
# copies as of 6.06_03 which are the canonical ones.  We leave these
# here, in peace, so that File::Spec continues to work with MakeMakers
# prior to 6.06_03.
# 
# Please consider these two methods deprecated.  Do not patch them,
# patch the ones in ExtUtils::MM_VMS instead.
sub eliminate_macros {
    my($self,$path) = @@_;
    return '' unless $path;
    $self = {} unless ref $self;

    if ($path =~ /\s/) {
      return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
    }

    my($npath) = unixify($path);
    my($complex) = 0;
    my($head,$macro,$tail);

    # perform m##g in scalar context so it acts as an iterator
    while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
        if ($self->{$2}) {
            ($head,$macro,$tail) = ($1,$2,$3);
            if (ref $self->{$macro}) {
                if (ref $self->{$macro} eq 'ARRAY') {
                    $macro = join ' ', @@{$self->{$macro}};
                }
                else {
                    print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                          "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                    $macro = "\cB$macro\cB";
                    $complex = 1;
                }
            }
            else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
            $npath = "$head$macro$tail";
        }
    }
    if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
    $npath;
}

# Deprecated.  See the note above for eliminate_macros().
sub fixpath {
    my($self,$path,$force_path) = @@_;
    return '' unless $path;
    $self = bless {} unless ref $self;
    my($fixedpath,$prefix,$name);

    if ($path =~ /\s/) {
      return join ' ',
             map { $self->fixpath($_,$force_path) }
	     split /\s+/, $path;
    }

    if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
        if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
            $fixedpath = vmspath($self->eliminate_macros($path));
        }
        else {
            $fixedpath = vmsify($self->eliminate_macros($path));
        }
    }
    elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
        my($vmspre) = $self->eliminate_macros("\$($prefix)");
        # is it a dir or just a name?
        $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
        $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    else {
        $fixedpath = $path;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    # No hints, so we try to guess
    if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
        $fixedpath = vmspath($fixedpath) if -d $fixedpath;
    }

    # Trim off root dirname if it's had other dirs inserted in front of it.
    $fixedpath =~ s/\.000000([\]>])/$1/;
    # Special case for VMS absolute directory specs: these will have had device
    # prepended during trip through Unix syntax in eliminate_macros(), since
    # Unix syntax has no way to express "absolute from the top of this device's
    # directory tree".
    if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
    $fixedpath;
}


a519 7

=head1 COPYRIGHT

Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.

This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d7 1
a7 1
$VERSION = '3.2501';
a38 2
    return undef unless defined $path;

d74 1
a74 1
	$path =~ s/\[\]// unless $path eq '[]';	# []		==>
d88 3
a90 4
    my $self = shift;
    my $dir = pop;
    my @@dirs = grep {defined() && length()} @@_;

d121 3
a123 4
    my $self = shift;
    my $file = $self->canonpath(pop());
    my @@files = grep {defined() && length()} @@_;

d134 1
a134 1
	    $rslt = vmsify($rslt.((defined $rslt) && ($rslt ne '') ? '/' : '').unixify($file));
a260 2
    my @@dirs = ();
    return @@dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
d275 1
a275 2
    $dirspec =~ s/^(\[|<)\./$1/;
    @@dirs = split /(?<!\^)\./, vmspath($dirspec);
a337 1
    my $pathchunks = @@pathchunks;
a339 1
    my $basechunks = @@basechunks;
d352 1
a352 7
    if ((@@basechunks > 0) || ($basechunks != $pathchunks)) {
      $path_directories = join '.', ('-' x @@basechunks, @@pathchunks) ;
    }
    else {
      $path_directories = join '.', @@pathchunks;
    }
    $path_directories = '['.$path_directories.']';
d420 1
a420 1
    return '' unless (defined $path) && ($path ne '');
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d7 1
a7 2
$VERSION = '3.30';
$VERSION = eval $VERSION;
a27 29
The mode of operation of these routines depend on the VMS features that
are controlled by the DECC features C<DECC$FILENAME_REPORT_UNIX> and
C<DECC$EFS_CHARSET>.

Perl needs to be at least at 5.10 for these feature settings to work.
Use of them on older perl versions on VMS will result in unpredictable
operations.

The default and traditional mode of these routines have been to expect VMS
syntax on input and to return VMS syntax on output, even when Unix syntax was
given on input.

The default and traditional mode is also incompatible with the VMS
C<EFS>, Extended File system character set, and with running Perl scripts
under <GNV>, Gnu is not VMS, an optional Unix like runtime environment on VMS.

If the C<DECC$EFS_CHARSET> feature is enabled, These routines will now accept
either VMS or UNIX syntax.  If the input parameters are clearly VMS syntax,
the return value will be in VMS syntax.  If the input parameters are clearly
in Unix syntax, the output will be in Unix syntax.

This corresponds to the way that the VMS C library routines have always
handled filenames, and what a programmer who has not specifically read this
pod before would also expect.

If the C<DECC$FILENAME_REPORT_UNIX> feature is enabled, then if the output
syntax can not be determined from the input syntax, the output syntax will be
UNIX.  If the feature is not enabled, VMS output will be the default.

a29 38
=cut

# Need to look up the feature settings.  The preferred way is to use the
# VMS::Feature module, but that may not be available to dual life modules.

my $use_feature;
BEGIN {
    if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
        $use_feature = 1;
    }
}

# Need to look up the UNIX report mode.  This may become a dynamic mode
# in the future.
sub _unix_rpt {
    my $unix_rpt;
    if ($use_feature) {
        $unix_rpt = VMS::Feature::current("filename_unix_report");
    } else {
        my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
    }
    return $unix_rpt;
}

# Need to look up the EFS character set mode.  This may become a dynamic
# mode in the future.
sub _efs {
    my $efs;
    if ($use_feature) {
        $efs = VMS::Feature::current("efs_charset");
    } else {
        my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
        $efs = $env_efs =~ /^[ET1]/i; 
    }
    return $efs;
}

d32 1
a32 2
Removes redundant portions of file specifications according to the syntax
detected.
a35 1

a40 2
    my $efs = $self->_efs;

a43 4

      # Do not convert to VMS when EFS character sets are in use
      return $path if $efs;

a47 4

#FIXME - efs parsing has different rules.  Characters in a VMS filespec
#        are only delimiters if not preceded by '^';

d84 1
a84 1
directory specification.  No check is made for "impossible"
a91 5

    my $efs = $self->_efs;
    my $unix_rpt = $self->_unix_rpt;


a92 12
    if ($efs) {
        # Legacy mode removes blank entries.
        # But that breaks existing generic perl code that
        # uses a blank path at the beginning of the array
        # to indicate an absolute path.
        # So put it back if found.
        if (@@_) {
            if ($_[0] eq '') {
                unshift @@dirs, '';
            }
        }
    }
d98 11
a108 115

        if ($efs) {
            # Extended character set in use, go into DWIM mode.

            # Now we need to identify what the directory is in
            # of the specification in order to merge them.
            my $path_unix = 0;
            $path_unix = 1 if ($path =~ m#/#);
            $path_unix = 1 if ($path =~ /^\.\.?$/);
            my $path_vms = 0;
            $path_vms = 1 if ($path =~ m#[\[<\]]#);
            $path_vms = 1 if ($path =~ /^--?$/);
            my $dir_unix = 0;
            $dir_unix = 1 if ($dir =~ m#/#);
            $dir_unix = 1 if ($dir =~ /^\.\.?$/);
            my $dir_vms = 0;
            $dir_vms = 1 if ($dir =~ m#[\[<\]]#);
            $dir_vms = 1 if ($dir =~ /^--?$/);

            my $unix_mode = 0;
            if (($path_unix != $dir_unix) && ($path_vms != $dir_vms)) {
                # Ambiguous, so if in $unix_rpt mode then assume UNIX.
                $unix_mode = 1 if $unix_rpt;
            } else {
                $unix_mode = 1 if (!$path_vms && !$dir_vms && $unix_rpt);
                $unix_mode = 1 if ($path_unix || $dir_unix);
            }

            if ($unix_mode) {

                # Fix up mixed syntax imput as good as possible - GIGO
                $path = unixify($path) if $path_vms;
                $dir = unixify($dir) if $dir_vms;

                $rslt = $path;
                # Append a path delimiter
                $rslt .= '/' unless ($rslt =~ m#/$#);

                $rslt .= $dir;
                return $self->SUPER::canonpath($rslt);
            } else {

                #with <> posible instead of [.
                # Normalize the brackets
                # Fixme - need to not switch when preceded by ^.
                $path =~ s/</\[/g;
                $path =~ s/>/\]/g;
                $dir =~ s/</\[/g;
                $dir =~ s/>/\]/g;

                # Fix up mixed syntax imput as good as possible - GIGO
                $path = vmsify($path) if $path_unix;
                $dir = vmsify($dir) if $dir_unix;

                #Possible path values: foo: [.foo] [foo] foo, and $(foo)
                #or starting with '-', or foo.dir
                #If path is foo, it needs to be converted to [.foo]

                # Fix up a bare path name.
                unless ($path_vms) {
                    $path =~ s/\.dir\Z(?!\n)//i;
                    if (($path ne '') && ($path !~ /^-/)) {
                        # Non blank and not prefixed with '-', add a dot
                        $path = '[.' . $path;
                    } else {
                        # Just start a directory.
                        $path = '[' . $path;
                    }
                } else {
                    $path =~ s/\]$//;
                }

                #Possible dir values: [.dir] dir and $(foo)

                # No punctuation may have a trailing .dir
                unless ($dir_vms) {
                    $dir =~ s/\.dir\Z(?!\n)//i;
                } else {

                    #strip off the brackets
                    $dir =~ s/^\[//;
                    $dir =~ s/\]$//;
                }

                #strip off the leading dot if present.
                $dir =~ s/^\.//;

                # Now put the specifications together.
                if ($dir ne '') {
                    # Add a separator unless this is an absolute path
                    $path .= '.' if ($path ne '[');
                    $rslt = $path . $dir . ']';
                } else {
                    $rslt = $path . ']';
                }
            }

	} else {
	    # Traditional ODS-2 mode.
	    $spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 

	    $sdir = $self->eliminate_macros($sdir)
		unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
	    $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);

	    # Special case for VMS absolute directory specs: these will have
	    # had device prepended during trip through Unix syntax in
	    # eliminate_macros(), since Unix syntax has no way to express
	    # "absolute from the top of this device's directory tree".
	    if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
	} 
    } else {
	# Single directory, just make sure it is in directory format
	# Return an empty string on null input, and pass through macros.

d110 2
a111 28
	elsif ($dir =~ /^\$\([^\)]+\)\Z(?!\n)/s) { 
	    $rslt = $dir;
	} else {
            my $unix_mode = 0;

            if ($efs) {
                my $dir_unix = 0;
                $dir_unix = 1 if ($dir =~ m#/#);
                $dir_unix = 1 if ($dir =~ /^\.\.?$/);
                my $dir_vms = 0;
                $dir_vms = 1 if ($dir =~ m#[\[<\]]#);
                $dir_vms = 1 if ($dir =~ /^--?$/);

                if ($dir_vms == $dir_unix) {
                    # Ambiguous, so if in $unix_rpt mode then assume UNIX.
                    $unix_mode = 1 if $unix_rpt;
                } else {
                    $unix_mode = 1 if $dir_unix;
                }
            }

            if ($unix_mode) {
                return $dir;
            } else {
                # For VMS, force it to be in directory format
	 	$rslt = vmspath($dir);
	    }
	}
d118 2
a119 2
Concatenates a list of directory specifications with a filename specification
to build a path.
d125 1
a125 2
    my $tfile = pop();
    my $file = $self->canonpath($tfile);
a127 22
    my $efs = $self->_efs;
    my $unix_rpt = $self->_unix_rpt;

    # Assume VMS mode
    my $unix_mode = 0;
    my $file_unix = 0;
    my $file_vms = 0;
    if ($efs) {

        # Now we need to identify format the file is in
        # of the specification in order to merge them.
        $file_unix = 1 if ($tfile =~ m#/#);
        $file_unix = 1 if ($tfile =~ /^\.\.?$/);
        $file_vms = 1 if ($tfile =~ m#[\[<\]]#);
        $file_vms = 1 if ($tfile =~ /^--?$/);

        # We may know for sure what the format is.
        if (($file_unix != $file_vms)) {
            $unix_mode = 1 if ($file_unix && $unix_rpt);
        }
    }

d130 1
a130 29
	# concatenate the directories.
	my $path;
        if (@@files == 1) {
           $path = $files[0];
        } else {
            if ($file_vms) {
                # We need to make sure this is in VMS mode to avoid doing
                # both a vmsify and unixfy on the same path, as that may
                # lose significant data.
                my $i = @@files - 1;
                my $tdir = $files[$i];
                my $tdir_vms = 0;
                my $tdir_unix = 0;
                $tdir_vms = 1 if ($tdir =~ m#[\[<\]]#);
                $tdir_unix = 1 if ($tdir =~ m#/#);
                $tdir_unix = 1 if ($tdir =~ /^\.\.?$/);

                if (!$tdir_vms) {
                    if ($tdir_unix) { 
                        $tdir = vmspath($tdir);
                    } else {
                        $tdir =~ s/\.dir\Z(?!\n)//i;
                        $tdir = '[.' . $tdir . ']';
                    }
                    $files[$i] = $tdir;
                }
            }
            $path = $self->catdir(@@files);
        }
d132 1
a132 9

        # Some thing building a VMS path in pieces may try to pass a
        # directory name in filename format, so normalize it.
	$spath =~ s/\.dir\Z(?!\n)//i;

        # if the spath ends with a directory delimiter and the file is bare,
        # then just concat them.
        # FIX-ME: In VMS format "[]<>:" are not delimiters if preceded by '^' 
        # Quite a bit of Perl does not know that yet.
d135 4
a138 58
	} else {
            if ($efs) {

                # Now we need to identify what the directory is in
                # of the specification in order to merge them.
                my $spath_unix = 0;
                $spath_unix = 1 if ($spath =~ m#/#);
                $spath_unix = 1 if ($spath =~ /^\.\.?$/);
                my $spath_vms = 0;
                $spath_vms = 1 if ($spath =~ m#[\[<\]]#);
                $spath_vms = 1 if ($spath =~ /^--?$/);

                # Assume VMS mode
                if (($spath_unix == $spath_vms) &&
                    ($file_unix == $file_vms)) {
                     # Ambigous, so if in $unix_rpt mode then assume UNIX.
                     $unix_mode = 1 if $unix_rpt;
                } else {
                     $unix_mode = 1
                         if (($spath_unix || $file_unix) && $unix_rpt);
                }

                if (!$unix_mode) {
                    if ($spath_vms) {
                        $spath = '[' . $spath . ']' if $spath =~ /^-/;
                        $rslt = vmspath($spath);
                    } else {
                        $rslt = '[.' . $spath . ']';
                    }
                    $file = vmsify($file) if ($file_unix);
                } else {
                    $spath = unixify($spath) if ($spath_vms);
                    $rslt = $spath;
                    $file = unixify($file) if ($file_vms);

                    # Unix merge may need a directory delimitor.
                    # A null path indicates root on Unix.
                    $rslt .= '/' unless ($rslt =~ m#/$#);
                }

                $rslt .= $file;
                $rslt =~ s/\]\[//;

	    } else {
		# Traditional VMS Perl mode expects that this is done.
		# Note for future maintainers:
		# This is left here for compatibility with perl scripts
		# that have come to expect this behavior, even though
		# usually the Perl scripts ported to VMS have to be
		# patched because of it changing Unix syntax file
		# to VMS format.

		$rslt = $self->eliminate_macros($spath);


	        $rslt = vmsify($rslt.((defined $rslt) &&
		    ($rslt ne '') ? '/' : '').unixify($file));
	    }
d141 2
a142 13
    else {
        # Only passed a single file?
        my $xfile = $file;

        # Traditional VMS perl expects this conversion.
        $xfile = vmsify($file) unless ($efs);

        $rslt = (defined($file) && length($file)) ? $xfile : '';
    }
    return $self->canonpath($rslt) unless $unix_rpt;

    # In Unix report mode, do not strip off redundent path information.
    return $rslt;
d148 1
a148 1
Returns a string representation of the current directory: '[]' or '.'
a152 2
    my $self = shift @@_;
    return '.' if ($self->_unix_rpt);
d158 1
a158 1
Returns a string representation of the null device: '_NLA0:' or '/dev/null'
a162 2
    my $self = shift @@_;
    return '/dev/null' if ($self->_unix_rpt);
a168 1
or '/'
a172 14
    my $self = shift @@_;
    if ($self->_unix_rpt) {
       # Root may exist, try it first.
       my $try = '/';
       my ($dev1, $ino1) = stat('/');
       my ($dev2, $ino2) = stat('.');

       # Perl falls back to '.' if it can not determine '/'
       if (($dev1 != $dev2) || ($ino1 != $ino2)) {
           return $try;
       }
       # Fall back to UNIX format sys$disk.
       return '/sys$disk/';
    }
a180 1
    /tmp if C<DECC$FILENAME_REPORT_UNIX> is enabled.
a190 1
    my $self = shift @@_;
d192 1
a192 6
    if ($self->_unix_rpt) {
        $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
        return $tmpdir;
    }

    $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
d197 1
a197 1
Returns a string representation of the parent directory: '[-]' or '..'
a201 2
    my $self = shift @@_;
    return '..' if ($self->_unix_rpt);
d245 1
a245 7
    ($volume,$directories,$file) = File::Spec->splitpath( $path );
    ($volume,$directories,$file) = File::Spec->splitpath( $path, $no_file );

Passing a true value for C<$no_file> indicates that the path being
split only contains directory components, even on systems where you
can usually (when not supporting a foreign syntax) tell the difference
between directories and files at a glance.
d250 2
a251 13
    my($self,$path, $nofile) = @@_;
    my($dev,$dir,$file)      = ('','','');
    my $efs = $self->_efs;
    my $vmsify_path = vmsify($path);
    if ($efs) {
        my $path_vms = 0;
        $path_vms = 1 if ($path =~ m#[\[<\]]#);
        $path_vms = 1 if ($path =~ /^--?$/);
        if (!$path_vms) {
            return $self->SUPER::splitpath($path, $nofile);
        }
        $vmsify_path = $path;
    }
d253 2
a254 14
    if ( $nofile ) {
        #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
        #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
        if( $vmsify_path =~ /(.*)\](.+)/ ){
            $vmsify_path = $1.'.'.$2.']';
        }
        $vmsify_path =~ /(.+:)?(.*)/s;
        $dir = defined $2 ? $2 : ''; # dir can be '0'
        return ($1 || '',$dir,$file);
    }
    else {
        $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
        return ($1 || '',$2 || '',$3);
    }
d259 1
a259 1
Split a directory specification into the components.
a266 14

    my $efs = $self->_efs;

    my $dir_unix = 0;
    $dir_unix = 1 if ($dirspec =~ m#/#);
    $dir_unix = 1 if ($dirspec =~ /^\.\.?$/);

    # Unix filespecs in EFS mode handled by Unix routines.
    if ($efs && $dir_unix) {
        return $self->SUPER::splitdir($dirspec);
    }

    # FIX ME, only split for VMS delimiters not prefixed with '^'.

d290 1
a290 1
Construct a complete filespec.
a296 19
    my $efs = $self->_efs;
    my $unix_rpt = $self->_unix_rpt;

    my $unix_mode = 0;
    my $dir_unix = 0;
    $dir_unix = 1 if ($dir =~ m#/#);
    $dir_unix = 1 if ($dir =~ /^\.\.?$/);
    my $dir_vms = 0;
    $dir_vms = 1 if ($dir =~ m#[\[<\]]#);
    $dir_vms = 1 if ($dir =~ /^--?$/);

    if ($efs && (length($dev) == 0)) {
        if ($dir_unix == $dir_vms) {
            $unix_mode = $unix_rpt;
        } else {
            $unix_mode = $dir_unix;
        }
    } 

d298 4
a301 8
    # but only if using VMS syntax.
    if (!$unix_mode) {
        $dir = vmspath($dir) if $dir_unix;
        my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
        $dev = $dir_volume unless length $dev;
        $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) :
                                  $dir_dir;
    }
d305 2
a306 11
      if ($efs) {
          if ($unix_mode) {
              $dir .= '/' unless ($dir =~ m#/$#);
          } else {
              $dir = vmspath($dir) if (($dir =~ m#/#) || ($dir =~ /^\.\.?$/));
              $dir = "[$dir]" unless $dir =~ /^[\[<]/;
          }
      } else {
          $dir = "[$dir]" unless $dir =~ /[\[<\/]/;
          $dir = vmspath($dir);
      }
d313 1
a313 2
Attempt to convert a file specification to a relative specification.
On a system with volumes, like VMS, this may not be possible.
d319 3
d323 1
a323 83

    my $efs = $self->_efs;
    my $unix_rpt = $self->_unix_rpt;

    if (!$efs) {
        return vmspath(File::Spec::Unix::abs2rel( $self, @@_ ))
            if grep m{/}, @@_;
    }

    # We need to identify what the directory is in
    # of the specification in order to process them
    my $path_unix = 0;
    $path_unix = 1 if ($path =~ m#/#);
    $path_unix = 1 if ($path =~ /^\.\.?$/);
    my $path_vms = 0;
    $path_vms = 1 if ($path =~ m#[\[<\]]#);
    $path_vms = 1 if ($path =~ /^--?$/);

    my $unix_mode = 0;
    if ($path_vms == $path_unix) {
        $unix_mode = $unix_rpt;
    } else {
        $unix_mode = $path_unix;
    }

    my $base_unix = 0;
    my $base_vms = 0;

    if (defined $base) {
        $base_unix = 1 if ($base =~ m#/#);
        $base_unix = 1 if ($base =~ /^\.\.?$/);
        $base_vms = 1 if ($base =~ m#[\[<\]]#);
        $base_vms = 1 if ($base =~ /^--?$/);

        if ($path_vms == $path_unix) {
            if ($base_vms == $base_unix) {
                $unix_mode = $unix_rpt;
            } else {
                $unix_mode = $base_unix;
            }
        } else {
            $unix_mode = 0 if $base_vms;
        }
    }

    if ($efs) {
        if ($unix_mode) {
            # We are UNIX mode.
            $base = unixpath($base) if $base_vms;
            $base = unixify($path) if $path_vms;

            # Here VMS is different, and in order to do this right
            # we have to take the realpath for both the path and the base
            # so that we can remove the common components.

            if ($path =~ m#^/#) {
                if (defined $base) {

                    # For the shorterm, if the starting directories are
                    # common, remove them.
                    my $bq = qq($base);
                    $bq =~ s/\$/\\\$/;
                    $path =~ s/^$bq//i;
                }
                return $path;
            }

            return File::Spec::Unix::abs2rel( $self, $path, $base );

        } else {
            $base = vmspath($base) if $base_unix;
            $path = vmsify($path) if $path_unix;
        }
    }

    unless (defined $base and length $base) {
        $base = $self->_cwd();
        if ($efs) {
            $base_unix = 1 if ($base =~ m#/#);
            $base_unix = 1 if ($base =~ /^\.\.?$/);
            $base = vmspath($base) if $base_unix;
        }
    }
d374 1
a374 1
Return an absolute file specification from a relative one.
d382 4
a385 36

    my $efs = $self->_efs;
    my $unix_rpt = $self->_unix_rpt;

    # We need to identify what the directory is in
    # of the specification in order to process them
    my $path_unix = 0;
    $path_unix = 1 if ($path =~ m#/#);
    $path_unix = 1 if ($path =~ /^\.\.?$/);
    my $path_vms = 0;
    $path_vms = 1 if ($path =~ m#[\[<\]]#);
    $path_vms = 1 if ($path =~ /^--?$/);

    my $unix_mode = 0;
    if ($path_vms == $path_unix) {
        $unix_mode = $unix_rpt;
    } else {
        $unix_mode = $path_unix;
    }

    my $base_unix = 0;
    my $base_vms = 0;

    if (defined $base) {
        $base_unix = 1 if ($base =~ m#/#);
        $base_unix = 1 if ($base =~ /^\.\.?$/);
        $base_vms = 1 if ($base =~ m#[\[<\]]#);
        $base_vms = 1 if ($base =~ /^--?$/);

        # If we could not determine the path mode, see if we can find out
        # from the base.
        if ($path_vms == $path_unix) {
            if ($base_vms != $base_unix) {
                $unix_mode = $base_unix;
            }
        }
d387 1
a387 15

    if (!$efs) {
        # Legacy behavior, convert to VMS syntax.
        $unix_mode = 0;
        if (defined $base) {
            $base = vmspath($base) if $base =~ m/\//;
        }

        if ($path =~ m/\//) {
	    $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
		       ? vmspath($path)             # whether it's a directory
		       : vmsify($path) );
        }
   }

a400 14
        if ($efs) {
            # base may have changed, so need to look up format again.
            if ($unix_mode) {
                $base_vms = 1 if ($base =~ m#[\[<\]]#);
                $base_vms = 1 if ($base =~ /^--?$/);
                $base = unixpath($base) if $base_vms;
                $base .= '/' unless ($base =~ m#/$#);
            } else {
                $base_unix = 1 if ($base =~ m#/#);
                $base_unix = 1 if ($base =~ /^\.\.?$/);
                $base = vmspath($base) if $base_unix; 
            }
        }

d411 6
a416 17

        if ($efs) {
            # Merge the paths assuming that the base is absolute.
            $base_directories = $self->catdir('',
                                              $base_directories,
                                              $path_directories);
        } else {
            # Legacy behavior assumes VMS only paths
            $sep = '.'
                if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                     $path_directories =~ m{^[^.\[<]}s
                ) ;
            $base_directories = "$base_directories$sep$path_directories";
            $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
        }

        $path_file = '' if ($path_file eq '.') && $unix_mode;
a432 8
#
# Update:  MakeMaker 6.48 is still using these routines on VMS.
# so they need to be kept up to date with ExtUtils::MM_VMS.
#
# The traditional VMS mode using ODS-2 disks depends on these routines
# being here.  These routines should not be called in when the
# C<DECC$EFS_CHARSET> or C<DECC$FILENAME_REPORT_UNIX> modes are enabled.

d442 1
a442 4
    my $npath = unixify($path);
    # sometimes unixify will return a string with an off-by-one trailing null
    $npath =~ s{\0$}{};

d448 1
a448 1
        if (defined $self->{$2}) {
a469 13

# Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
# in any directory specification, in order to avoid juxtaposing two
# VMS-syntax directories when MM[SK] is run.  Also expands expressions which
# are all macro, so that we can tell how long the expansion is, and avoid
# overrunning DCL's command buffer when MM[KS] is running.

# fixpath() checks to see whether the result matches the name of a
# directory in the current default directory and returns a directory or
# file specification accordingly.  C<$is_dir> can be set to true to
# force fixpath() to consider the path to be a directory or false to force
# it to be a file.

d473 1
a473 1
    $self = bless {}, $self unless ref $self;
@


