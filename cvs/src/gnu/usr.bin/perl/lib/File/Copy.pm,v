head	1.17;
access;
symbols
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.17
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.28;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.56;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.07.01;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.09.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.31;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.09;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.44;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.30;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.03;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.17;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.46.57;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.46;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.34;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.59;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.41;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.08.54;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.53.08;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@# File/Copy.pm. Written in 1994 by Aaron Sherman <ajs@@ajs.com>. This
# source code has been placed in the public domain by the author.
# Please be kind and preserve the documentation.
#
# Additions copyright 1996 by Charles Bailey.  Permission is granted
# to distribute the revised code under the same terms as Perl itself.

package File::Copy;

use 5.006;
use strict;
use warnings; no warnings 'newline';
use File::Spec;
use Config;
# During perl build, we need File::Copy but Scalar::Util might not be built yet
# And then we need these games to avoid loading overload, as that will
# confuse miniperl during the bootstrap of perl.
my $Scalar_Util_loaded = eval q{ require Scalar::Util; require overload; 1 };
our(@@ISA, @@EXPORT, @@EXPORT_OK, $VERSION, $Too_Big, $Syscopy_is_copy);
sub copy;
sub syscopy;
sub cp;
sub mv;

$VERSION = '2.31';

require Exporter;
@@ISA = qw(Exporter);
@@EXPORT = qw(copy move);
@@EXPORT_OK = qw(cp mv);

$Too_Big = 1024 * 1024 * 2;

sub croak {
    require Carp;
    goto &Carp::croak;
}

sub carp {
    require Carp;
    goto &Carp::carp;
}

sub _catname {
    my($from, $to) = @@_;
    if (not defined &basename) {
	require File::Basename;
	import  File::Basename 'basename';
    }

    return File::Spec->catfile($to, basename($from));
}

# _eq($from, $to) tells whether $from and $to are identical
sub _eq {
    my ($from, $to) = map {
        $Scalar_Util_loaded && Scalar::Util::blessed($_)
	    && overload::Method($_, q{""})
            ? "$_"
            : $_
    } (@@_);
    return '' if ( (ref $from) xor (ref $to) );
    return $from == $to if ref $from;
    return $from eq $to;
}

sub copy {
    croak("Usage: copy(FROM, TO [, BUFFERSIZE]) ")
      unless(@@_ == 2 || @@_ == 3);

    my $from = shift;
    my $to = shift;

    my $size;
    if (@@_) {
	$size = shift(@@_) + 0;
	croak("Bad buffer size for copy: $size\n") unless ($size > 0);
    }

    my $from_a_handle = (ref($from)
			 ? (ref($from) eq 'GLOB'
			    || UNIVERSAL::isa($from, 'GLOB')
                            || UNIVERSAL::isa($from, 'IO::Handle'))
			 : (ref(\$from) eq 'GLOB'));
    my $to_a_handle =   (ref($to)
			 ? (ref($to) eq 'GLOB'
			    || UNIVERSAL::isa($to, 'GLOB')
                            || UNIVERSAL::isa($to, 'IO::Handle'))
			 : (ref(\$to) eq 'GLOB'));

    if (_eq($from, $to)) { # works for references, too
	carp("'$from' and '$to' are identical (not copied)");
        return 0;
    }

    if (!$from_a_handle && !$to_a_handle && -d $to && ! -d $from) {
	$to = _catname($from, $to);
    }

    if ((($Config{d_symlink} && $Config{d_readlink}) || $Config{d_link}) &&
	!($^O eq 'MSWin32' || $^O eq 'os2')) {
	my @@fs = stat($from);
	if (@@fs) {
	    my @@ts = stat($to);
	    if (@@ts && $fs[0] == $ts[0] && $fs[1] == $ts[1] && !-p $from) {
		carp("'$from' and '$to' are identical (not copied)");
                return 0;
	    }
	}
    }
    elsif (_eq($from, $to)) {
	carp("'$from' and '$to' are identical (not copied)");
	return 0;
    }

    if (defined &syscopy && !$Syscopy_is_copy
	&& !$to_a_handle
	&& !($from_a_handle && $^O eq 'os2' )	# OS/2 cannot handle handles
	&& !($from_a_handle && $^O eq 'MSWin32')
	&& !($from_a_handle && $^O eq 'NetWare')
       )
    {
        if ($^O eq 'VMS' && -e $from
            && ! -d $to && ! -d $from) {

            # VMS natively inherits path components from the source of a
            # copy, but we want the Unixy behavior of inheriting from
            # the current working directory.  Also, default in a trailing
            # dot for null file types.

            $to = VMS::Filespec::rmsexpand(VMS::Filespec::vmsify($to), '.');

            # Get rid of the old versions to be like UNIX
            1 while unlink $to;
        }

        return syscopy($from, $to) || 0;
    }

    my $closefrom = 0;
    my $closeto = 0;
    my ($status, $r, $buf);
    local($\) = '';

    my $from_h;
    if ($from_a_handle) {
       $from_h = $from;
    } else {
       open $from_h, "<", $from or goto fail_open1;
       binmode $from_h or die "($!,$^E)";
       $closefrom = 1;
    }

    # Seems most logical to do this here, in case future changes would want to
    # make this croak for some reason.
    unless (defined $size) {
	$size = tied(*$from_h) ? 0 : -s $from_h || 0;
	$size = 1024 if ($size < 512);
	$size = $Too_Big if ($size > $Too_Big);
    }

    my $to_h;
    if ($to_a_handle) {
       $to_h = $to;
    } else {
	$to_h = \do { local *FH }; # XXX is this line obsolete?
	open $to_h, ">", $to or goto fail_open2;
	binmode $to_h or die "($!,$^E)";
	$closeto = 1;
    }

    $! = 0;
    for (;;) {
	my ($r, $w, $t);
       defined($r = sysread($from_h, $buf, $size))
	    or goto fail_inner;
	last unless $r;
	for ($w = 0; $w < $r; $w += $t) {
           $t = syswrite($to_h, $buf, $r - $w, $w)
		or goto fail_inner;
	}
    }

    close($to_h) || goto fail_open2 if $closeto;
    close($from_h) || goto fail_open1 if $closefrom;

    # Use this idiom to avoid uninitialized value warning.
    return 1;

    # All of these contortions try to preserve error messages...
  fail_inner:
    if ($closeto) {
	$status = $!;
	$! = 0;
       close $to_h;
	$! = $status unless $!;
    }
  fail_open2:
    if ($closefrom) {
	$status = $!;
	$! = 0;
       close $from_h;
	$! = $status unless $!;
    }
  fail_open1:
    return 0;
}

sub cp {
    my($from,$to) = @@_;
    my(@@fromstat) = stat $from;
    my(@@tostat) = stat $to;
    my $perm;

    return 0 unless copy(@@_) and @@fromstat;

    if (@@tostat) {
        $perm = $tostat[2];
    } else {
        $perm = $fromstat[2] & ~(umask || 0);
	@@tostat = stat $to;
    }
    # Might be more robust to look for S_I* in Fcntl, but we're
    # trying to avoid dependence on any XS-containing modules,
    # since File::Copy is used during the Perl build.
    $perm &= 07777;
    if ($perm & 06000) {
	croak("Unable to check setuid/setgid permissions for $to: $!")
	    unless @@tostat;

	if ($perm & 04000 and                     # setuid
	    $fromstat[4] != $tostat[4]) {         # owner must match
	    $perm &= ~06000;
	}

	if ($perm & 02000 && $> != 0) {           # if not root, setgid
	    my $ok = $fromstat[5] == $tostat[5];  # group must match
	    if ($ok) {                            # and we must be in group
                $ok = grep { $_ == $fromstat[5] } split /\s+/, $)
	    }
	    $perm &= ~06000 unless $ok;
	}
    }
    return 0 unless @@tostat;
    return 1 if $perm == ($tostat[2] & 07777);
    return eval { chmod $perm, $to; } ? 1 : 0;
}

sub _move {
    croak("Usage: move(FROM, TO) ") unless @@_ == 3;

    my($from,$to,$fallback) = @@_;

    my($fromsz,$tosz1,$tomt1,$tosz2,$tomt2,$sts,$ossts);

    if (-d $to && ! -d $from) {
	$to = _catname($from, $to);
    }

    ($tosz1,$tomt1) = (stat($to))[7,9];
    $fromsz = -s $from;
    if ($^O eq 'os2' and defined $tosz1 and defined $fromsz) {
      # will not rename with overwrite
      unlink $to;
    }

    if ($^O eq 'VMS' && -e $from
        && ! -d $to && ! -d $from) {

            # VMS natively inherits path components from the source of a
            # copy, but we want the Unixy behavior of inheriting from
            # the current working directory.  Also, default in a trailing
            # dot for null file types.

            $to = VMS::Filespec::rmsexpand(VMS::Filespec::vmsify($to), '.');

            # Get rid of the old versions to be like UNIX
            1 while unlink $to;
    }

    return 1 if rename $from, $to;

    # Did rename return an error even though it succeeded, because $to
    # is on a remote NFS file system, and NFS lost the server's ack?
    return 1 if defined($fromsz) && !-e $from &&           # $from disappeared
                (($tosz2,$tomt2) = (stat($to))[7,9]) &&    # $to's there
                  ((!defined $tosz1) ||			   #  not before or
		   ($tosz1 != $tosz2 or $tomt1 != $tomt2)) &&  #   was changed
                $tosz2 == $fromsz;                         # it's all there

    ($tosz1,$tomt1) = (stat($to))[7,9];  # just in case rename did something

    {
        local $@@;
        eval {
            local $SIG{__DIE__};
            $fallback->($from,$to) or die;
            my($atime, $mtime) = (stat($from))[8,9];
            utime($atime, $mtime, $to);
            unlink($from)   or die;
        };
        return 1 unless $@@;
    }
    ($sts,$ossts) = ($! + 0, $^E + 0);

    ($tosz2,$tomt2) = ((stat($to))[7,9],0,0) if defined $tomt1;
    unlink($to) if !defined($tomt1) or $tomt1 != $tomt2 or $tosz1 != $tosz2;
    ($!,$^E) = ($sts,$ossts);
    return 0;
}

sub move { _move(@@_,\&copy); }
sub mv   { _move(@@_,\&cp);   }

# &syscopy is an XSUB under OS/2
unless (defined &syscopy) {
    if ($^O eq 'VMS') {
	*syscopy = \&rmscopy;
    } elsif ($^O eq 'MSWin32' && defined &DynaLoader::boot_DynaLoader) {
	# Win32::CopyFile() fill only work if we can load Win32.xs
	*syscopy = sub {
	    return 0 unless @@_ == 2;
	    return Win32::CopyFile(@@_, 1);
	};
    } else {
	$Syscopy_is_copy = 1;
	*syscopy = \&copy;
    }
}

1;

__END__

=head1 NAME

File::Copy - Copy files or filehandles

=head1 SYNOPSIS

	use File::Copy;

	copy("sourcefile","destinationfile") or die "Copy failed: $!";
	copy("Copy.pm",\*STDOUT);
	move("/dev1/sourcefile","/dev2/destinationfile");

	use File::Copy "cp";

	$n = FileHandle->new("/a/file","r");
	cp($n,"x");

=head1 DESCRIPTION

The File::Copy module provides two basic functions, C<copy> and
C<move>, which are useful for getting the contents of a file from
one place to another.

=over 4

=item copy
X<copy> X<cp>

The C<copy> function takes two
parameters: a file to copy from and a file to copy to. Either
argument may be a string, a FileHandle reference or a FileHandle
glob. Obviously, if the first argument is a filehandle of some
sort, it will be read from, and if it is a file I<name> it will
be opened for reading. Likewise, the second argument will be
written to. If the second argument does not exist but the parent
directory does exist, then it will be created. Trying to copy
a file into a non-existent directory is an error.
Trying to copy a file on top of itself is also an error.
C<copy> will not overwrite read-only files.

If the destination (second argument) already exists and is a directory,
and the source (first argument) is not a filehandle, then the source
file will be copied into the directory specified by the destination,
using the same base name as the source file.  It's a failure to have a
filehandle as the source when the destination is a directory.

B<Note that passing in
files as handles instead of names may lead to loss of information
on some operating systems; it is recommended that you use file
names whenever possible.>  Files are opened in binary mode where
applicable.  To get a consistent behaviour when copying from a
filehandle to a file, use C<binmode> on the filehandle.

An optional third parameter can be used to specify the buffer
size used for copying. This is the number of bytes from the
first file, that will be held in memory at any given time, before
being written to the second file. The default buffer size depends
upon the file, but will generally be the whole file (up to 2MB), or
1k for filehandles that do not reference files (eg. sockets).

You may use the syntax C<use File::Copy "cp"> to get at the C<cp>
alias for this function. The syntax is I<exactly> the same.  The
behavior is nearly the same as well: as of version 2.15, C<cp> will
preserve the source file's permission bits like the shell utility
C<cp(1)> would do, while C<copy> uses the default permissions for the
target file (which may depend on the process' C<umask>, file
ownership, inherited ACLs, etc.).  If an error occurs in setting
permissions, C<cp> will return 0, regardless of whether the file was
successfully copied.

=item move
X<move> X<mv> X<rename>

The C<move> function also takes two parameters: the current name
and the intended name of the file to be moved.  If the destination
already exists and is a directory, and the source is not a
directory, then the source file will be renamed into the directory
specified by the destination.

If possible, move() will simply rename the file.  Otherwise, it copies
the file to the new location and deletes the original.  If an error occurs
during this copy-and-delete process, you may be left with a (possibly partial)
copy of the file under the destination name.

You may use the C<mv> alias for this function in the same way that
you may use the C<cp> alias for C<copy>.

=item syscopy
X<syscopy>

File::Copy also provides the C<syscopy> routine, which copies the
file specified in the first parameter to the file specified in the
second parameter, preserving OS-specific attributes and file
structure.  For Unix systems, this is equivalent to the simple
C<copy> routine, which doesn't preserve OS-specific attributes.  For
VMS systems, this calls the C<rmscopy> routine (see below).  For OS/2
systems, this calls the C<syscopy> XSUB directly. For Win32 systems,
this calls C<Win32::CopyFile>.

B<Special behaviour if C<syscopy> is defined (OS/2, VMS and Win32)>:

If both arguments to C<copy> are not file handles,
then C<copy> will perform a "system copy" of
the input file to a new output file, in order to preserve file
attributes, indexed file structure, I<etc.>  The buffer size
parameter is ignored.  If either argument to C<copy> is a
handle to an opened file, then data is copied using Perl
operators, and no effort is made to preserve file attributes
or record structure.

The system copy routine may also be called directly under VMS and OS/2
as C<File::Copy::syscopy> (or under VMS as C<File::Copy::rmscopy>, which
is the routine that does the actual work for syscopy).

=item rmscopy($from,$to[,$date_flag])
X<rmscopy>

The first and second arguments may be strings, typeglobs, typeglob
references, or objects inheriting from IO::Handle;
they are used in all cases to obtain the
I<filespec> of the input and output files, respectively.  The
name and type of the input file are used as defaults for the
output file, if necessary.

A new version of the output file is always created, which
inherits the structure and RMS attributes of the input file,
except for owner and protections (and possibly timestamps;
see below).  All data from the input file is copied to the
output file; if either of the first two parameters to C<rmscopy>
is a file handle, its position is unchanged.  (Note that this
means a file handle pointing to the output file will be
associated with an old version of that file after C<rmscopy>
returns, not the newly created version.)

The third parameter is an integer flag, which tells C<rmscopy>
how to handle timestamps.  If it is E<lt> 0, none of the input file's
timestamps are propagated to the output file.  If it is E<gt> 0, then
it is interpreted as a bitmask: if bit 0 (the LSB) is set, then
timestamps other than the revision date are propagated; if bit 1
is set, the revision date is propagated.  If the third parameter
to C<rmscopy> is 0, then it behaves much like the DCL COPY command:
if the name or type of the output file was explicitly specified,
then no timestamps are propagated, but if they were taken implicitly
from the input filespec, then all timestamps other than the
revision date are propagated.  If this parameter is not supplied,
it defaults to 0.

Like C<copy>, C<rmscopy> returns 1 on success.  If an error occurs,
it sets C<$!>, deletes the output file, and returns 0.

=back

=head1 RETURN

All functions return 1 on success, 0 on failure.
$! will be set if an error was encountered.

=head1 NOTES

Before calling copy() or move() on a filehandle, the caller should
close or flush() the file to avoid writes being lost. Note that this
is the case even for move(), because it may actually copy the file,
depending on the OS-specific inplementation, and the underlying
filesystem(s).

=head1 AUTHOR

File::Copy was written by Aaron Sherman I<E<lt>ajs@@ajs.comE<gt>> in 1995,
and updated by Charles Bailey I<E<lt>bailey@@newman.upenn.eduE<gt>> in 1996.

=cut

@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d25 1
a25 1
$VERSION = '2.30';
d491 8
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d25 1
a25 1
$VERSION = '2.26';
a43 38
# Look up the feature settings on VMS using VMS::Feature when available.

my $use_vms_feature = 0;
BEGIN {
    if ($^O eq 'VMS') {
        if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
            $use_vms_feature = 1;
        }
    }
}

# Need to look up the UNIX report mode.  This may become a dynamic mode
# in the future.
sub _vms_unix_rpt {
    my $unix_rpt;
    if ($use_vms_feature) {
        $unix_rpt = VMS::Feature::current("filename_unix_report");
    } else {
        my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        $unix_rpt = $env_unix_rpt =~ /^[ET1]/i;
    }
    return $unix_rpt;
}

# Need to look up the EFS character set mode.  This may become a dynamic
# mode in the future.
sub _vms_efs {
    my $efs;
    if ($use_vms_feature) {
        $efs = VMS::Feature::current("efs_charset");
    } else {
        my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
        $efs = $env_efs =~ /^[ET1]/i;
    }
    return $efs;
}


d123 2
a124 1
	my $copy_to = $to;
d126 4
a129 1
        if ($^O eq 'VMS' && -e $from) {
d131 1
a131 1
            if (! -d $to && ! -d $from) {
d133 2
a134 35
                my $vms_efs = _vms_efs();
                my $unix_rpt = _vms_unix_rpt();
                my $unix_mode = 0;
                my $from_unix = 0;
                $from_unix = 1 if ($from =~ /^\.\.?$/);
                my $from_vms = 0;
                $from_vms = 1 if ($from =~ m#[\[<\]]#);

                # Need to know if we are in Unix mode.
                if ($from_vms == $from_unix) {
                    $unix_mode = $unix_rpt;
                } else {
                    $unix_mode = $from_unix;
                }

                # VMS has sticky defaults on extensions, which means that
                # if there is a null extension on the destination file, it
                # will inherit the extension of the source file
                # So add a '.' for a null extension.

                # In unix_rpt mode, the trailing dot should not be added.

                if ($vms_efs) {
                    $copy_to = $to;
                } else {
                    $copy_to = VMS::Filespec::vmsify($to);
                }
                my ($vol, $dirs, $file) = File::Spec->splitpath($copy_to);
                $file = $file . '.'
                    unless (($file =~ /(?<!\^)\./) || $unix_rpt);
                $copy_to = File::Spec->catpath($vol, $dirs, $file);

                # Get rid of the old versions to be like UNIX
                1 while unlink $copy_to;
            }
d137 1
a137 1
        return syscopy($from, $copy_to) || 0;
d267 2
a268 2
    my $rename_to = $to;
    if (-$^O eq 'VMS' && -e $from) {
d270 4
a273 1
        if (! -d $to && ! -d $from) {
d275 1
a275 31
            my $vms_efs = _vms_efs();
            my $unix_rpt = _vms_unix_rpt();
            my $unix_mode = 0;
            my $from_unix = 0;
            $from_unix = 1 if ($from =~ /^\.\.?$/);
            my $from_vms = 0;
            $from_vms = 1 if ($from =~ m#[\[<\]]#);

            # Need to know if we are in Unix mode.
            if ($from_vms == $from_unix) {
                $unix_mode = $unix_rpt;
            } else {
                $unix_mode = $from_unix;
            }

            # VMS has sticky defaults on extensions, which means that
            # if there is a null extension on the destination file, it
            # will inherit the extension of the source file
            # So add a '.' for a null extension.

            # In unix_rpt mode, the trailing dot should not be added.

            if ($vms_efs) {
                $rename_to = $to;
            } else {
                $rename_to = VMS::Filespec::vmsify($to);
            }
            my ($vol, $dirs, $file) = File::Spec->splitpath($rename_to);
            $file = $file . '.'
                unless (($file =~ /(?<!\^)\./) || $unix_rpt);
            $rename_to = File::Spec->catpath($vol, $dirs, $file);
d278 1
a278 2
            1 while unlink $rename_to;
        }
d281 1
a281 1
    return 1 if rename $from, $rename_to;
d343 1
a343 1
	copy("file1","file2") or die "Copy failed: $!";
d345 1
a345 1
	move("/dev1/fileA","/dev2/fileB");
d369 5
a373 2
written to (and created if need be).  Trying to copy a file on top
of itself is an error.
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d25 1
a25 1
$VERSION = '2.23';
d131 5
a135 3
        # The "copy" was a success as the source and destination contain
        # the same data.
        return 1;
d149 3
a151 3

    if (!$from_a_handle && !$to_a_handle && -d $to && ! -d $from) {
	$to = _catname($from, $to);
a156 1
	&& !($from_a_handle && $^O eq 'mpeix')	# and neither can MPE/iX.
a413 7
    } elsif ($^O eq 'mpeix') {
	*syscopy = sub {
	    return 0 unless @@_ == 2;
	    # Use the MPE cp program in order to
	    # preserve MPE file attributes.
	    return system('/bin/cp', '-f', $_[0], $_[1]) == 0;
	};
d465 1
a465 1
of itself is a fatal error.
d489 1
a489 1
behavior is nearly the same as well: as of version 2.15, <cp> will
d512 1
a512 1
you may use the <cp> alias for C<copy>.
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d12 1
a12 1
use warnings;
d25 1
a25 1
$VERSION = '2.18';
a43 7
my $macfiles;
if ($^O eq 'MacOS') {
	$macfiles = eval { require Mac::MoreFiles };
	warn 'Mac::MoreFiles could not be loaded; using non-native syscopy'
		if $@@ && $^W;
}

a88 5
    if ($^O eq 'MacOS') {
	# a partial dir name that's valid only in the cwd (e.g. 'tmp')
	$to = ':' . $to if $to !~ /:/;
    }

a156 1
	&& !($from_a_handle && $^O eq 'MacOS')
a425 16
    } elsif ($macfiles) {
	*syscopy = sub {
	    my($from, $to) = @@_;
	    my($dir, $toname);

	    return 0 unless -e $from;

	    if ($to =~ /(.*:)([^:]+):?$/) {
		($dir, $toname) = ($1, $2);
	    } else {
		($dir, $toname) = (":", $to);
	    }

	    unlink($to);
	    Mac::MoreFiles::FSpFileCopy($from, $dir, $toname, 1);
	};
a531 3
On Mac OS (Classic), C<syscopy> calls C<Mac::MoreFiles::FSpFileCopy>,
if available.

a588 28

=head1 NOTES

=over 4

=item *

On Mac OS (Classic), the path separator is ':', not '/', and the 
current directory is denoted as ':', not '.'. You should be careful 
about specifying relative pathnames. While a full path always begins 
with a volume name, a relative pathname should always begin with a 
':'.  If specifying a volume name only, a trailing ':' is required.

E.g.

  copy("file1", "tmp");        # creates the file 'tmp' in the current directory
  copy("file1", ":tmp:");      # creates :tmp:file1
  copy("file1", ":tmp");       # same as above
  copy("file1", "tmp");        # same as above, if 'tmp' is a directory (but don't do
                               # that, since it may cause confusion, see example #1)
  copy("file1", "tmp:file1");  # error, since 'tmp:' is not a volume
  copy("file1", ":tmp:file1"); # ok, partial path
  copy("file1", "DataHD:");    # creates DataHD:file1

  move("MacintoshHD:fileA", "DataHD:fileB"); # moves (doesn't copy) files from one
                                             # volume to another

=back
@


1.12
log
@Merge in perl 5.10.1
@
text
@d15 1
a15 4
# During perl build, we need File::Copy but Fcntl might not be built yet
# *** not needed for 2.14, only 2.15
# *** my $Fcntl_loaded = eval q{ use Fcntl qw [O_CREAT O_WRONLY O_TRUNC]; 1 };
# Similarly Scalar::Util
d25 1
a25 1
$VERSION = '2.14';
d51 38
d153 1
a153 1
	    if (@@ts && $fs[0] == $ts[0] && $fs[1] == $ts[1]) {
d179 15
d199 7
a205 1
                $copy_to = VMS::Filespec::vmsify($to);
d207 2
a208 1
                $file = $file . '.' unless ($file =~ /(?<!\^)\./);
d216 1
a216 1
        return syscopy($from, $copy_to);
a227 2
	$from = _protect($from) if $from =~ /^\s/s;
       $from_h = \do { local *FH };
d230 1
a230 1
	$closefrom = 1;
d245 3
a247 4
	$to = _protect($to) if $to =~ /^\s/s;
       $to_h = \do { local *FH };
       open $to_h, ">", $to or goto fail_open2;
       binmode $to_h or die "($!,$^E)";
d288 42
a329 2
sub move {
    croak("Usage: move(FROM, TO) ") unless @@_ == 2;
d331 1
a331 1
    my($from,$to) = @@_;
d350 16
d371 7
a377 1
            $rename_to = VMS::Filespec::vmsify($to);
d379 2
a380 1
            $file = $file . '.' unless ($file =~ /(?<!\^)\./);
d404 1
a404 1
            copy($from,$to) or die;
d419 2
a420 9
*cp = \&copy;
*mv = \&move;


if ($^O eq 'MacOS') {
    *_protect = sub { MacPerl::MakeFSSpec($_[0]) };
} else {
    *_protect = sub { "./$_[0]" };
}
d502 6
d522 9
a530 2
You may use the syntax C<use File::Copy "cp"> to get at the
"cp" alias for this function. The syntax is I<exactly> the same.
d546 2
a547 2
You may use the "mv" alias for this function in the same way that
you may use the "cp" alias for C<copy>.
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d15 7
d28 1
a28 6
# Note that this module implements only *part* of the API defined by
# the File/Copy.pm module of the File-Tools-2.0 package.  However, that
# package has not yet been updated to work with Perl 5.004, and so it
# would be a Bad Thing for the CPAN module to grab it and replace this
# module.  Therefore, we set this module's version higher than 2.0.
$VERSION = '2.11';
a69 1
# works for strings and references
d71 9
a79 3
    return $_[0] == $_[1] if ref $_[0] && ref $_[1];
    return $_[0] eq $_[1] if !ref $_[0] && !ref $_[1];
    return "";
d89 6
d164 1
a164 1
    my ($size, $status, $r, $buf);
d173 1
a173 1
       open($from_h, "< $from\0") or goto fail_open1;
d178 8
d192 1
a192 1
       open($to_h,"> $to\0") or goto fail_open2;
a194 9
    }

    if (@@_) {
	$size = shift(@@_) + 0;
	croak("Bad buffer size for copy: $size\n") unless ($size > 0);
    } else {
	$size = tied(*$from_h) ? 0 : -s $from_h || 0;
	$size = 1024 if ($size < 512);
	$size = $Too_Big if ($size > $Too_Big);
@


1.10
log
@merge in perl 5.8.8
@
text
@a12 1
use Carp;
d26 1
a26 1
$VERSION = '2.09';
d35 10
d67 8
d93 1
a93 1
    if ($from eq $to) { # works for references, too
d101 1
a101 1
	!($^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'vms')) {
d125 22
a146 1
	return syscopy($from, $to);
d239 21
a259 1
    return 1 if rename $from, $to;
d265 2
a266 1
                ($tosz1 != $tosz2 or $tomt1 != $tomt2) &&  #   and changed
d311 2
a312 1
    } elsif ($^O eq 'MSWin32') {
d368 2
a369 1
=item *
d389 1
a389 1
first file, that wil be held in memory at any given time, before
d391 1
a391 1
upon the file, but will generally be the whole file (up to 2Mb), or
d397 2
a398 1
=item *
d414 2
a415 1
=back
d429 1
a429 1
=head2 Special behaviour if C<syscopy> is defined (OS/2, VMS and Win32)
a443 2
=over 4

d445 1
d504 1
a504 1
  copy("file1", "tmp");        # same as above, if 'tmp' is a directory (but don't do   
d509 2
a510 2
  
  move("MacintoshHD:fileA", "DataHD:fileB"); # moves (don't copies) files from one 
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d27 1
a27 1
$VERSION = '2.08';
d77 4
a80 1
	croak("'$from' and '$to' are identical (not copied)");
d89 2
a90 1
		croak("'$from' and '$to' are identical (not copied)");
d185 2
d188 1
d211 12
a222 1
    return 1 if copy($from,$to) && unlink($from);
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d27 1
a27 1
$VERSION = '2.07';
d277 1
a277 2
	use POSIX;
	use File::Copy cp;
d280 1
a280 1
	cp($n,"x");'
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d27 1
a27 1
$VERSION = '2.06';
d80 4
a83 5
    if ($Config{d_symlink} && $Config{d_readlink} &&
	!($^O eq 'Win32' || $^O eq 'os2' || $^O eq 'vms')) {
	no warnings 'io'; # don't warn if -l on filehandle
	if ((-e $from && -l $from) || (-e $to && -l $to)) {
	    my @@fs = stat($from);
d85 1
a85 1
	    if (@@fs && @@ts && $fs[0] == $ts[0] && $fs[1] == $ts[1]) {
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d27 1
a27 1
$VERSION = '2.05';
d40 1
a40 1
		if $^W;
d183 1
a183 1
    my($copied,$fromsz,$tosz1,$tomt1,$tosz2,$tomt2,$sts,$ossts);
a196 1
    ($sts,$ossts) = ($! + 0, $^E + 0);
d205 2
a206 1
    return 1 if ($copied = copy($from,$to)) && unlink($from);
d272 1
a272 1
  	use File::Copy;
d274 2
a275 2
	copy("file1","file2");
  	copy("Copy.pm",\*STDOUT);'
d278 1
a278 1
  	use POSIX;
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d10 1
a10 1
use 5.005_64;
d12 1
d14 2
d27 1
a27 1
$VERSION = '2.03';
d36 8
a43 1
sub _catname { #  Will be replaced by File::Spec when it arrives
d49 7
a55 4
    if ($^O eq 'VMS')  { $to = VMS::Filespec::vmspath($to) . basename($from); }
    elsif ($^O eq 'MacOS') { $to =~ s/^([^:]+)$/:$1/; $to .= ':' . basename($from); }
    elsif ($to =~ m|\\|)   { $to .= '\\' . basename($from); }
    else                   { $to .= '/' . basename($from); }
d76 16
d102 1
a110 1
    local(*FROM, *TO);
d113 1
d115 1
a115 1
	*FROM = *$from{FILEHANDLE};
d118 3
a120 2
	open(FROM, "< $from\0") or goto fail_open1;
	binmode FROM or die "($!,$^E)";
d124 1
d126 1
a126 1
	*TO = *$to{FILEHANDLE};
d129 3
a131 2
	open(TO,"> $to\0") or goto fail_open2;
	binmode TO or die "($!,$^E)";
d139 1
a139 1
	$size = -s FROM;
d147 1
a147 1
	defined($r = sysread(FROM, $buf, $size))
d151 1
a151 1
	    $t = syswrite(TO, $buf, $r - $w, $w)
d156 2
a157 2
    close(TO) || goto fail_open2 if $closeto;
    close(FROM) || goto fail_open1 if $closefrom;
d167 1
a167 1
	close TO;
d174 1
a174 1
	close FROM;
d240 1
a240 2
    } elsif ($^O eq 'MacOS') {
	require Mac::MoreFiles;
d300 2
a301 1
written to (and created if need be).
d342 7
a348 3
C<copy> routine.  For VMS systems, this calls the C<rmscopy>
routine (see below).  For OS/2 systems, this calls the C<syscopy>
XSUB directly. For Win32 systems, this calls C<Win32::CopyFile>.
d408 28
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d40 1
a40 1
    elsif ($^O eq 'MacOS') { $to .= ':' . basename($from); }
d72 1
d87 1
a87 1
	$from = "./$from" if $from =~ /^\s/s;
d96 1
a96 1
	$to = "./$to" if $to =~ /^\s/s;
d184 7
d207 17
d249 1
a249 1
	$n=FileHandle->new("/dev/null","r");
@


1.3
log
@perl5.005_03 (stock)
@
text
@d10 1
d13 5
a17 2
use vars qw(@@ISA @@EXPORT @@EXPORT_OK $VERSION $Too_Big
	    &copy &syscopy &cp &mv);
d24 1
a24 1
$VERSION = '2.02';
d67 1
a67 1
    if (defined &syscopy && \&syscopy != \&copy
d71 2
a72 1
       )	
d86 1
a86 1
	$from = "./$from" if $from =~ /^\s/;
d90 2
a91 2
    } 
 
d94 2
a95 2
    } else {        
	$to = "./$to" if $to =~ /^\s/;
d99 1
a99 1
    }  
d127 1
a127 1
    
d170 1
a170 1
 
d173 1
a173 1
  
d194 5
d200 1
d286 1
a286 1
XSUB directly.
d288 1
a288 1
=head2 Special behaviour if C<syscopy> is defined (VMS and OS/2)
@


1.2
log
@perl 5.004_04
@
text
@d65 3
a67 1
	&& !($from_a_handle && $^O eq 'os2'))	# OS/2 cannot handle handles
d179 14
a192 1
*syscopy = ($^O eq 'VMS' ? \&rmscopy : \&copy) unless defined &syscopy;
d238 1
a238 1
applicable.  To get a consistent behavour when copying from a
d277 1
a277 1
=head2 Special behavior if C<syscopy> is defined (VMS and OS/2)
d339 1
a339 1
and updated by Charles Bailey I<E<lt>bailey@@genetics.upenn.eduE<gt>> in 1996.
@


1.1
log
@Initial revision
@
text
@d5 2
d10 1
a10 1
require Exporter;
d12 9
d22 17
a38 10
@@ISA=qw(Exporter);
@@EXPORT=qw(copy);
@@EXPORT_OK=qw(copy cp);

$File::Copy::VERSION = '1.5';
$File::Copy::Too_Big = 1024 * 1024 * 2;

sub VERSION {
    # Version of File::Copy
    return $File::Copy::VERSION;
d42 1
a42 1
    croak("Usage: copy( file1, file2 [, buffersize]) ")
a44 5
    if (($^O eq 'VMS' or $^O eq 'os2') && ref(\$to) ne 'GLOB' &&
        !(defined ref $to and (ref($to) eq 'GLOB' ||
          ref($to) eq 'FileHandle' || ref($to) eq 'VMS::Stdio')))
        { return File::Copy::syscopy($_[0],$_[1]) }

d47 25
a71 3
    my $recsep = $\;
    my $closefrom=0;
    my $closeto=0;
d74 1
d76 2
a77 8
    $\ = '';

    if (ref(\$from) eq 'GLOB') {
	*FROM = $from;
    } elsif (defined ref $from and
	     (ref($from) eq 'GLOB' || ref($from) eq 'FileHandle' ||
	      ref($from) eq 'VMS::Stdio')) {
	*FROM = *$from;
d79 3
a81 2
	open(FROM,"<$from")||goto(fail_open1);
	binmode FROM;
d83 10
a92 13
    }

    if (ref(\$to) eq 'GLOB') {
	*TO = $to;
    } elsif (defined ref $to and
	     (ref($to) eq 'GLOB' || ref($to) eq 'FileHandle' ||
	      ref($to) eq 'VMS::Stdio')) {
	*TO = *$to;
    } else {
	open(TO,">$to")||goto(fail_open2);
	binmode TO;
	$closeto=1;
    }
d100 1
a100 1
	$size = $File::Copy::Too_Big if ($size > $File::Copy::Too_Big);
d103 9
a111 4
    $buf = '';
    while(defined($r = read(FROM,$buf,$size)) && $r > 0) {
	if (syswrite (TO,$buf,$r) != $r) {
	    goto fail_inner;    
d114 1
a114 1
    goto fail_inner unless(defined($r));
d117 2
a118 1
    $\ = $recsep;
a136 1
    $\ = $recsep;
d140 32
d174 2
d177 1
a177 1
*syscopy = ($^O eq 'VMS' ? \&rmscopy : \&copy) unless $^O eq 'os2';
d193 1
d203 9
a211 1
The File::Copy module provides a basic function C<copy> which takes two
d217 3
a219 1
written to (and created if need be).  Note that passing in
d222 3
a224 1
names whenever possible.
d236 18
d262 1
a262 1
=head2 Special behavior under VMS
d264 2
a265 2
If the second argument to C<copy> is not a file handle for an
already opened file, then C<copy> will perform an RMS copy of
d268 2
a269 2
parameter is ignored.  If the second argument to C<copy> is a
Perl handle to an opened file, then data is copied using Perl
d273 5
a277 3
The RMS copy routine may also be called directly under VMS
as C<File::Copy::rmscopy> (or C<File::Copy::syscopy>, which
is just an alias for this routine).
d281 3
a283 2
The first and second arguments may be strings, typeglobs, or
typeglob references; they are used in all cases to obtain the
d299 2
a300 2
how to handle timestamps.  If it is < 0, none of the input file's
timestamps are propagated to the output file.  If it is > 0, then
d314 2
d318 2
a319 2
Returns 1 on success, 0 on failure. $! will be set if an error was
encountered.
d323 2
a324 3
File::Copy was written by Aaron Sherman I<E<lt>ajs@@ajs.comE<gt>> in 1995.
The VMS-specific code was added by Charles Bailey
I<E<lt>bailey@@genetics.upenn.eduE<gt>> in March 1996.
d327 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a4 2
# Additions copyright 1996 by Charles Bailey.  Permission is granted
# to distribute the revised code under the same terms as Perl itself.
d8 1
a8 1
use strict;
a9 9
use vars qw(@@ISA @@EXPORT @@EXPORT_OK $VERSION $Too_Big
	    &copy &syscopy &cp &mv);

# Note that this module implements only *part* of the API defined by
# the File/Copy.pm module of the File-Tools-2.0 package.  However, that
# package has not yet been updated to work with Perl 5.004, and so it
# would be a Bad Thing for the CPAN module to grab it and replace this
# module.  Therefore, we set this module's version higher than 2.0.
$VERSION = '2.02';
d11 10
a20 17
require Exporter;
@@ISA = qw(Exporter);
@@EXPORT = qw(copy move);
@@EXPORT_OK = qw(cp mv);

$Too_Big = 1024 * 1024 * 2;

sub _catname { #  Will be replaced by File::Spec when it arrives
    my($from, $to) = @@_;
    if (not defined &basename) {
	require File::Basename;
	import  File::Basename 'basename';
    }
    if ($^O eq 'VMS')  { $to = VMS::Filespec::vmspath($to) . basename($from); }
    elsif ($^O eq 'MacOS') { $to .= ':' . basename($from); }
    elsif ($to =~ m|\\|)   { $to .= '\\' . basename($from); }
    else                   { $to .= '/' . basename($from); }
d24 1
a24 1
    croak("Usage: copy(FROM, TO [, BUFFERSIZE]) ")
d27 5
d34 5
d40 1
a40 10
    my $from_a_handle = (ref($from)
			 ? (ref($from) eq 'GLOB'
			    || UNIVERSAL::isa($from, 'GLOB')
                            || UNIVERSAL::isa($from, 'IO::Handle'))
			 : (ref(\$from) eq 'GLOB'));
    my $to_a_handle =   (ref($to)
			 ? (ref($to) eq 'GLOB'
			    || UNIVERSAL::isa($to, 'GLOB')
                            || UNIVERSAL::isa($to, 'IO::Handle'))
			 : (ref(\$to) eq 'GLOB'));
d42 10
a51 2
    if (!$from_a_handle && !$to_a_handle && -d $to && ! -d $from) {
	$to = _catname($from, $to);
d54 10
a63 7
    if (defined &syscopy && \&syscopy != \&copy
	&& !$to_a_handle
	&& !($from_a_handle && $^O eq 'os2' )	# OS/2 cannot handle handles
	&& !($from_a_handle && $^O eq 'mpeix')	# and neither can MPE/iX.
       )	
    {
	return syscopy($from, $to);
a65 24
    my $closefrom = 0;
    my $closeto = 0;
    my ($size, $status, $r, $buf);
    local(*FROM, *TO);
    local($\) = '';

    if ($from_a_handle) {
	*FROM = *$from{FILEHANDLE};
    } else {
	$from = "./$from" if $from =~ /^\s/;
	open(FROM, "< $from\0") or goto fail_open1;
	binmode FROM or die "($!,$^E)";
	$closefrom = 1;
    } 
 
    if ($to_a_handle) {
	*TO = *$to{FILEHANDLE};
    } else {        
	$to = "./$to" if $to =~ /^\s/;
	open(TO,"> $to\0") or goto fail_open2;
	binmode TO or die "($!,$^E)";
	$closeto = 1;
    }  

d72 1
a72 1
	$size = $Too_Big if ($size > $Too_Big);
d75 4
a78 9
    $! = 0;
    for (;;) {
	my ($r, $w, $t);
	defined($r = sysread(FROM, $buf, $size))
	    or goto fail_inner;
	last unless $r;
	for ($w = 0; $w < $r; $w += $t) {
	    $t = syswrite(TO, $buf, $r - $w, $w)
		or goto fail_inner;
d81 1
a81 1

d84 1
a84 2

    # Use this idiom to avoid uninitialized value warning.
d103 1
a106 32
sub move {
    my($from,$to) = @@_;
    my($copied,$fromsz,$tosz1,$tomt1,$tosz2,$tomt2,$sts,$ossts);

    if (-d $to && ! -d $from) {
	$to = _catname($from, $to);
    }

    ($tosz1,$tomt1) = (stat($to))[7,9];
    $fromsz = -s $from;
    if ($^O eq 'os2' and defined $tosz1 and defined $fromsz) {
      # will not rename with overwrite
      unlink $to;
    }
    return 1 if rename $from, $to;

    ($sts,$ossts) = ($! + 0, $^E + 0);
    # Did rename return an error even though it succeeded, because $to
    # is on a remote NFS file system, and NFS lost the server's ack?
    return 1 if defined($fromsz) && !-e $from &&           # $from disappeared
                (($tosz2,$tomt2) = (stat($to))[7,9]) &&    # $to's there
                ($tosz1 != $tosz2 or $tomt1 != $tomt2) &&  #   and changed
                $tosz2 == $fromsz;                         # it's all there
 
    ($tosz1,$tomt1) = (stat($to))[7,9];  # just in case rename did something
    return 1 if ($copied = copy($from,$to)) && unlink($from);
  
    ($tosz2,$tomt2) = ((stat($to))[7,9],0,0) if defined $tomt1;
    unlink($to) if !defined($tomt1) or $tomt1 != $tomt2 or $tosz1 != $tosz2;
    ($!,$^E) = ($sts,$ossts);
    return 0;
}
a108 2
*mv = \&move;

d110 1
a110 14
unless (defined &syscopy) {
    if ($^O eq 'VMS') {
	*syscopy = \&rmscopy;
    } elsif ($^O eq 'mpeix') {
	*syscopy = sub {
	    return 0 unless @@_ == 2;
	    # Use the MPE cp program in order to
	    # preserve MPE file attributes.
	    return system('/bin/cp', '-f', $_[0], $_[1]) == 0;
	};
    } else {
	*syscopy = \&copy;
    }
}
a125 1
	move("/dev1/fileA","/dev2/fileB");
d135 1
a135 9
The File::Copy module provides two basic functions, C<copy> and
C<move>, which are useful for getting the contents of a file from
one place to another.

=over 4

=item *

The C<copy> function takes two
d141 1
a141 3
written to (and created if need be).

B<Note that passing in
d144 1
a144 3
names whenever possible.>  Files are opened in binary mode where
applicable.  To get a consistent behaviour when copying from a
filehandle to a file, use C<binmode> on the filehandle.
a155 18
=item *

The C<move> function also takes two parameters: the current name
and the intended name of the file to be moved.  If the destination
already exists and is a directory, and the source is not a
directory, then the source file will be renamed into the directory
specified by the destination.

If possible, move() will simply rename the file.  Otherwise, it copies
the file to the new location and deletes the original.  If an error occurs
during this copy-and-delete process, you may be left with a (possibly partial)
copy of the file under the destination name.

You may use the "mv" alias for this function in the same way that
you may use the "cp" alias for C<copy>.

=back

d164 1
a164 1
=head2 Special behaviour if C<syscopy> is defined (VMS and OS/2)
d166 2
a167 2
If both arguments to C<copy> are not file handles,
then C<copy> will perform a "system copy" of
d170 2
a171 2
parameter is ignored.  If either argument to C<copy> is a
handle to an opened file, then data is copied using Perl
d175 3
a177 5
The system copy routine may also be called directly under VMS and OS/2
as C<File::Copy::syscopy> (or under VMS as C<File::Copy::rmscopy>, which
is the routine that does the actual work for syscopy).

=over 4
d181 2
a182 3
The first and second arguments may be strings, typeglobs, typeglob
references, or objects inheriting from IO::Handle;
they are used in all cases to obtain the
d198 2
a199 2
how to handle timestamps.  If it is E<lt> 0, none of the input file's
timestamps are propagated to the output file.  If it is E<gt> 0, then
a212 2
=back

d215 2
a216 2
All functions return 1 on success, 0 on failure.
$! will be set if an error was encountered.
d220 3
a222 2
File::Copy was written by Aaron Sherman I<E<lt>ajs@@ajs.comE<gt>> in 1995,
and updated by Charles Bailey I<E<lt>bailey@@newman.upenn.eduE<gt>> in 1996.
a224 1

@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a9 1
use 5.005_64;
d12 2
a13 5
our(@@ISA, @@EXPORT, @@EXPORT_OK, $VERSION, $Too_Big, $Syscopy_is_copy);
sub copy;
sub syscopy;
sub cp;
sub mv;
d20 1
a20 1
$VERSION = '2.03';
d63 1
a63 1
    if (defined &syscopy && !$Syscopy_is_copy
d67 1
a67 2
	&& !($from_a_handle && $^O eq 'MSWin32')
       )
d81 1
a81 1
	$from = "./$from" if $from =~ /^\s/s;
d85 2
a86 2
    }

d89 2
a90 2
    } else {
	$to = "./$to" if $to =~ /^\s/s;
d94 1
a94 1
    }
d122 1
a122 1

d165 1
a165 1

d168 1
a168 1

a188 5
    } elsif ($^O eq 'MSWin32') {
	*syscopy = sub {
	    return 0 unless @@_ == 2;
	    return Win32::CopyFile(@@_, 1);
	};
a189 1
	$Syscopy_is_copy = 1;
d275 1
a275 1
XSUB directly. For Win32 systems, this calls C<Win32::CopyFile>.
d277 1
a277 1
=head2 Special behaviour if C<syscopy> is defined (OS/2, VMS and Win32)
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d40 1
a40 1
    elsif ($^O eq 'MacOS') { $to =~ s/^([^:]+)$/:$1/; $to .= ':' . basename($from); }
a71 1
	&& !($from_a_handle && $^O eq 'MacOS')
d86 1
a86 1
	$from = _protect($from) if $from =~ /^\s/s;
d95 1
a95 1
	$to = _protect($to) if $to =~ /^\s/s;
a182 7

if ($^O eq 'MacOS') {
    *_protect = sub { MacPerl::MakeFSSpec($_[0]) };
} else {
    *_protect = sub { "./$_[0]" };
}

a198 17
    } elsif ($^O eq 'MacOS') {
	require Mac::MoreFiles;
	*syscopy = sub {
	    my($from, $to) = @@_;
	    my($dir, $toname);

	    return 0 unless -e $from;

	    if ($to =~ /(.*:)([^:]+):?$/) {
		($dir, $toname) = ($1, $2);
	    } else {
		($dir, $toname) = (":", $to);
	    }

	    unlink($to);
	    Mac::MoreFiles::FSpFileCopy($from, $dir, $toname, 1);
	};
d224 1
a224 1
	$n = FileHandle->new("/a/file","r");
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d10 1
a10 1
use 5.006;
a11 1
use warnings;
a12 2
use File::Spec;
use Config;
d24 1
a24 1
$VERSION = '2.05';
d33 1
a33 8
my $macfiles;
if ($^O eq 'MacOS') {
	$macfiles = eval { require Mac::MoreFiles };
	warn 'Mac::MoreFiles could not be loaded; using non-native syscopy'
		if $^W;
}

sub _catname {
d39 4
a42 7

    if ($^O eq 'MacOS') {
	# a partial dir name that's valid only in the cwd (e.g. 'tmp')
	$to = ':' . $to if $to !~ /:/;
    }

    return File::Spec->catfile($to, basename($from));
a62 16
    if ($from eq $to) { # works for references, too
	croak("'$from' and '$to' are identical (not copied)");
    }

    if ($Config{d_symlink} && $Config{d_readlink} &&
	!($^O eq 'Win32' || $^O eq 'os2' || $^O eq 'vms')) {
	no warnings 'io'; # don't warn if -l on filehandle
	if ((-e $from && -l $from) || (-e $to && -l $to)) {
	    my @@fs = stat($from);
	    my @@ts = stat($to);
	    if (@@fs && @@ts && $fs[0] == $ts[0] && $fs[1] == $ts[1]) {
		croak("'$from' and '$to' are identical (not copied)");
	    }
	}
    }

a72 1
	&& !($from_a_handle && $^O eq 'NetWare')
d81 1
a83 1
    my $from_h;
d85 1
a85 1
       $from_h = $from;
d88 2
a89 3
       $from_h = \do { local *FH };
       open($from_h, "< $from\0") or goto fail_open1;
       binmode $from_h or die "($!,$^E)";
a92 1
    my $to_h;
d94 1
a94 1
       $to_h = $to;
d97 2
a98 3
       $to_h = \do { local *FH };
       open($to_h,"> $to\0") or goto fail_open2;
       binmode $to_h or die "($!,$^E)";
d106 1
a106 1
	$size = tied(*$from_h) ? 0 : -s $from_h || 0;
d114 1
a114 1
       defined($r = sysread($from_h, $buf, $size))
d118 1
a118 1
           $t = syswrite($to_h, $buf, $r - $w, $w)
d123 2
a124 2
    close($to_h) || goto fail_open2 if $closeto;
    close($from_h) || goto fail_open1 if $closefrom;
d134 1
a134 1
       close $to_h;
d141 1
a141 1
       close $from_h;
d207 2
a208 1
    } elsif ($macfiles) {
d268 1
a268 2
written to (and created if need be).  Trying to copy a file on top
of itself is a fatal error.
d309 3
a311 7
C<copy> routine, which doesn't preserve OS-specific attributes.  For
VMS systems, this calls the C<rmscopy> routine (see below).  For OS/2
systems, this calls the C<syscopy> XSUB directly. For Win32 systems,
this calls C<Win32::CopyFile>.

On Mac OS (Classic), C<syscopy> calls C<Mac::MoreFiles::FSpFileCopy>,
if available.
a370 28

=head1 NOTES

=over 4

=item *

On Mac OS (Classic), the path separator is ':', not '/', and the 
current directory is denoted as ':', not '.'. You should be careful 
about specifying relative pathnames. While a full path always begins 
with a volume name, a relative pathname should always begin with a 
':'.  If specifying a volume name only, a trailing ':' is required.

E.g.

  copy("file1", "tmp");        # creates the file 'tmp' in the current directory
  copy("file1", ":tmp:");      # creates :tmp:file1
  copy("file1", ":tmp");       # same as above
  copy("file1", "tmp");        # same as above, if 'tmp' is a directory (but don't do   
                               # that, since it may cause confusion, see example #1)
  copy("file1", "tmp:file1");  # error, since 'tmp:' is not a volume
  copy("file1", ":tmp:file1"); # ok, partial path
  copy("file1", "DataHD:");    # creates DataHD:file1
  
  move("MacintoshHD:fileA", "DataHD:fileB"); # moves (don't copies) files from one 
                                             # volume to another

=back
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d27 1
a27 1
$VERSION = '2.06';
d40 1
a40 1
		if $@@ && $^W;
d183 1
a183 1
    my($fromsz,$tosz1,$tomt1,$tosz2,$tomt2,$sts,$ossts);
d197 1
d206 1
a206 2
    return 1 if copy($from,$to) && unlink($from);
    ($sts,$ossts) = ($! + 0, $^E + 0);
d272 1
a272 1
	use File::Copy;
d274 2
a275 2
	copy("file1","file2") or die "Copy failed: $!";
	copy("Copy.pm",\*STDOUT);
d278 1
a278 1
	use POSIX;
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d27 1
a27 1
$VERSION = '2.07';
d80 5
a84 4
    if ((($Config{d_symlink} && $Config{d_readlink}) || $Config{d_link}) &&
	!($^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'vms')) {
	my @@fs = stat($from);
	if (@@fs) {
d86 1
a86 1
	    if (@@ts && $fs[0] == $ts[0] && $fs[1] == $ts[1]) {
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d27 1
a27 1
$VERSION = '2.08';
d277 2
a278 1
	use File::Copy "cp";
d281 1
a281 1
	cp($n,"x");
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d27 1
a27 1
$VERSION = '2.09';
d77 1
a77 4
	carp("'$from' and '$to' are identical (not copied)");
        # The "copy" was a success as the source and destination contain
        # the same data.
        return 1;
d86 1
a86 2
		carp("'$from' and '$to' are identical (not copied)");
                return 0;
a180 2
    croak("Usage: move(FROM, TO) ") unless @@_ == 2;

a181 1

d204 1
a204 12

    {
        local $@@;
        eval {
            local $SIG{__DIE__};
            copy($from,$to) or die;
            my($atime, $mtime) = (stat($from))[8,9];
            utime($atime, $mtime, $to);
            unlink($from)   or die;
        };
        return 1 unless $@@;
    }
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d13 1
d27 1
a27 1
$VERSION = '2.11';
a35 10
sub croak {
    require Carp;
    goto &Carp::croak;
}

sub carp {
    require Carp;
    goto &Carp::carp;
}

a57 8
# _eq($from, $to) tells whether $from and $to are identical
# works for strings and references
sub _eq {
    return $_[0] == $_[1] if ref $_[0] && ref $_[1];
    return $_[0] eq $_[1] if !ref $_[0] && !ref $_[1];
    return "";
}

d76 1
a76 1
    if (_eq($from, $to)) { # works for references, too
d84 1
a84 1
	!($^O eq 'MSWin32' || $^O eq 'os2')) {
d108 1
a108 22
	my $copy_to = $to;

        if ($^O eq 'VMS' && -e $from) {

            if (! -d $to && ! -d $from) {

                # VMS has sticky defaults on extensions, which means that
                # if there is a null extension on the destination file, it
                # will inherit the extension of the source file
                # So add a '.' for a null extension.

                $copy_to = VMS::Filespec::vmsify($to);
                my ($vol, $dirs, $file) = File::Spec->splitpath($copy_to);
                $file = $file . '.' unless ($file =~ /(?<!\^)\./);
                $copy_to = File::Spec->catpath($vol, $dirs, $file);

                # Get rid of the old versions to be like UNIX
                1 while unlink $copy_to;
            }
        }

        return syscopy($from, $copy_to);
d201 1
a201 21

    my $rename_to = $to;
    if (-$^O eq 'VMS' && -e $from) {

        if (! -d $to && ! -d $from) {
            # VMS has sticky defaults on extensions, which means that
            # if there is a null extension on the destination file, it
            # will inherit the extension of the source file
            # So add a '.' for a null extension.

            $rename_to = VMS::Filespec::vmsify($to);
            my ($vol, $dirs, $file) = File::Spec->splitpath($rename_to);
            $file = $file . '.' unless ($file =~ /(?<!\^)\./);
            $rename_to = File::Spec->catpath($vol, $dirs, $file);

            # Get rid of the old versions to be like UNIX
            1 while unlink $rename_to;
        }
    }

    return 1 if rename $from, $rename_to;
d207 1
a207 2
                  ((!defined $tosz1) ||			   #  not before or
		   ($tosz1 != $tosz2 or $tomt1 != $tomt2)) &&  #   was changed
d252 1
a252 2
    } elsif ($^O eq 'MSWin32' && defined &DynaLoader::boot_DynaLoader) {
	# Win32::CopyFile() fill only work if we can load Win32.xs
d308 1
a308 2
=item copy
X<copy> X<cp>
d328 1
a328 1
first file, that will be held in memory at any given time, before
d330 1
a330 1
upon the file, but will generally be the whole file (up to 2MB), or
d336 1
a336 2
=item move
X<move> X<mv> X<rename>
d352 1
a352 2
=item syscopy
X<syscopy>
d366 1
a366 1
B<Special behaviour if C<syscopy> is defined (OS/2, VMS and Win32)>:
d381 2
a383 1
X<rmscopy>
d442 1
a442 1
  copy("file1", "tmp");        # same as above, if 'tmp' is a directory (but don't do
d447 2
a448 2

  move("MacintoshHD:fileA", "DataHD:fileB"); # moves (doesn't copy) files from one
@


1.1.1.11
log
@import perl 5.10.1
@
text
@a14 7
# During perl build, we need File::Copy but Fcntl might not be built yet
# *** not needed for 2.14, only 2.15
# *** my $Fcntl_loaded = eval q{ use Fcntl qw [O_CREAT O_WRONLY O_TRUNC]; 1 };
# Similarly Scalar::Util
# And then we need these games to avoid loading overload, as that will
# confuse miniperl during the bootstrap of perl.
my $Scalar_Util_loaded = eval q{ require Scalar::Util; require overload; 1 };
d21 6
a26 1
$VERSION = '2.14';
d68 1
d70 3
a72 9
    my ($from, $to) = map {
        $Scalar_Util_loaded && Scalar::Util::blessed($_)
	    && overload::Method($_, q{""})
            ? "$_"
            : $_
    } (@@_);
    return '' if ( (ref $from) xor (ref $to) );
    return $from == $to if ref $from;
    return $from eq $to;
a81 6
    my $size;
    if (@@_) {
	$size = shift(@@_) + 0;
	croak("Bad buffer size for copy: $size\n") unless ($size > 0);
    }

d151 1
a151 1
    my ($status, $r, $buf);
d160 1
a160 1
       open $from_h, "<", $from or goto fail_open1;
a164 8
    # Seems most logical to do this here, in case future changes would want to
    # make this croak for some reason.
    unless (defined $size) {
	$size = tied(*$from_h) ? 0 : -s $from_h || 0;
	$size = 1024 if ($size < 512);
	$size = $Too_Big if ($size > $Too_Big);
    }

d171 1
a171 1
       open $to_h, ">", $to or goto fail_open2;
d174 9
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d15 4
a18 1
# During perl build, we need File::Copy but Scalar::Util might not be built yet
d28 1
a28 1
$VERSION = '2.18';
a53 38
# Look up the feature settings on VMS using VMS::Feature when available.

my $use_vms_feature = 0;
BEGIN {
    if ($^O eq 'VMS') {
        if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
            $use_vms_feature = 1;
        }
    }
}

# Need to look up the UNIX report mode.  This may become a dynamic mode
# in the future.
sub _vms_unix_rpt {
    my $unix_rpt;
    if ($use_vms_feature) {
        $unix_rpt = VMS::Feature::current("filename_unix_report");
    } else {
        my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        $unix_rpt = $env_unix_rpt =~ /^[ET1]/i;
    }
    return $unix_rpt;
}

# Need to look up the EFS character set mode.  This may become a dynamic
# mode in the future.
sub _vms_efs {
    my $efs;
    if ($use_vms_feature) {
        $efs = VMS::Feature::current("efs_charset");
    } else {
        my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
        $efs = $env_efs =~ /^[ET1]/i;
    }
    return $efs;
}


d118 1
a118 1
	    if (@@ts && $fs[0] == $ts[0] && $fs[1] == $ts[1] && !-p $from) {
a143 15
                my $vms_efs = _vms_efs();
                my $unix_rpt = _vms_unix_rpt();
                my $unix_mode = 0;
                my $from_unix = 0;
                $from_unix = 1 if ($from =~ /^\.\.?$/);
                my $from_vms = 0;
                $from_vms = 1 if ($from =~ m#[\[<\]]#);

                # Need to know if we are in Unix mode.
                if ($from_vms == $from_unix) {
                    $unix_mode = $unix_rpt;
                } else {
                    $unix_mode = $from_unix;
                }

d149 1
a149 7
                # In unix_rpt mode, the trailing dot should not be added.

                if ($vms_efs) {
                    $copy_to = $to;
                } else {
                    $copy_to = VMS::Filespec::vmsify($to);
                }
d151 1
a151 2
                $file = $file . '.'
                    unless (($file =~ /(?<!\^)\./) || $unix_rpt);
d159 1
a159 1
        return syscopy($from, $copy_to) || 0;
d171 2
d175 1
a175 1
       $closefrom = 1;
d190 4
a193 3
	$to_h = \do { local *FH }; # XXX is this line obsolete?
	open $to_h, ">", $to or goto fail_open2;
	binmode $to_h or die "($!,$^E)";
d234 3
a236 1
sub cp {
a237 42
    my(@@fromstat) = stat $from;
    my(@@tostat) = stat $to;
    my $perm;

    return 0 unless copy(@@_) and @@fromstat;

    if (@@tostat) {
        $perm = $tostat[2];
    } else {
        $perm = $fromstat[2] & ~(umask || 0);
	@@tostat = stat $to;
    }
    # Might be more robust to look for S_I* in Fcntl, but we're
    # trying to avoid dependence on any XS-containing modules,
    # since File::Copy is used during the Perl build.
    $perm &= 07777;
    if ($perm & 06000) {
	croak("Unable to check setuid/setgid permissions for $to: $!")
	    unless @@tostat;

	if ($perm & 04000 and                     # setuid
	    $fromstat[4] != $tostat[4]) {         # owner must match
	    $perm &= ~06000;
	}

	if ($perm & 02000 && $> != 0) {           # if not root, setgid
	    my $ok = $fromstat[5] == $tostat[5];  # group must match
	    if ($ok) {                            # and we must be in group
                $ok = grep { $_ == $fromstat[5] } split /\s+/, $)
	    }
	    $perm &= ~06000 unless $ok;
	}
    }
    return 0 unless @@tostat;
    return 1 if $perm == ($tostat[2] & 07777);
    return eval { chmod $perm, $to; } ? 1 : 0;
}

sub _move {
    croak("Usage: move(FROM, TO) ") unless @@_ == 3;

    my($from,$to,$fallback) = @@_;
a255 16

            my $vms_efs = _vms_efs();
            my $unix_rpt = _vms_unix_rpt();
            my $unix_mode = 0;
            my $from_unix = 0;
            $from_unix = 1 if ($from =~ /^\.\.?$/);
            my $from_vms = 0;
            $from_vms = 1 if ($from =~ m#[\[<\]]#);

            # Need to know if we are in Unix mode.
            if ($from_vms == $from_unix) {
                $unix_mode = $unix_rpt;
            } else {
                $unix_mode = $from_unix;
            }

d261 1
a261 7
            # In unix_rpt mode, the trailing dot should not be added.

            if ($vms_efs) {
                $rename_to = $to;
            } else {
                $rename_to = VMS::Filespec::vmsify($to);
            }
d263 1
a263 2
            $file = $file . '.'
                unless (($file =~ /(?<!\^)\./) || $unix_rpt);
d287 1
a287 1
            $fallback->($from,$to) or die;
d302 9
a310 2
sub move { _move(@@_,\&copy); }
sub mv   { _move(@@_,\&cp);   }
a391 6
If the destination (second argument) already exists and is a directory,
and the source (first argument) is not a filehandle, then the source
file will be copied into the directory specified by the destination,
using the same base name as the source file.  It's a failure to have a
filehandle as the source when the destination is a directory.

d406 2
a407 9
You may use the syntax C<use File::Copy "cp"> to get at the C<cp>
alias for this function. The syntax is I<exactly> the same.  The
behavior is nearly the same as well: as of version 2.15, <cp> will
preserve the source file's permission bits like the shell utility
C<cp(1)> would do, while C<copy> uses the default permissions for the
target file (which may depend on the process' C<umask>, file
ownership, inherited ACLs, etc.).  If an error occurs in setting
permissions, C<cp> will return 0, regardless of whether the file was
successfully copied.
d423 2
a424 2
You may use the C<mv> alias for this function in the same way that
you may use the <cp> alias for C<copy>.
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d12 1
a12 1
use warnings; no warnings 'newline';
d25 1
a25 1
$VERSION = '2.23';
d44 7
d96 5
d169 1
d439 16
d561 3
d621 28
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d25 1
a25 1
$VERSION = '2.26';
d131 3
a133 5
        return 0;
    }

    if (!$from_a_handle && !$to_a_handle && -d $to && ! -d $from) {
	$to = _catname($from, $to);
d147 3
a149 3
    elsif (_eq($from, $to)) {
	carp("'$from' and '$to' are identical (not copied)");
	return 0;
d155 1
d413 7
d471 1
a471 1
of itself is an error.
d495 1
a495 1
behavior is nearly the same as well: as of version 2.15, C<cp> will
d518 1
a518 1
you may use the C<cp> alias for C<copy>.
@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d25 1
a25 1
$VERSION = '2.30';
d44 38
d161 1
a161 2
        if ($^O eq 'VMS' && -e $from
            && ! -d $to && ! -d $from) {
d163 1
a163 4
            # VMS natively inherits path components from the source of a
            # copy, but we want the Unixy behavior of inheriting from
            # the current working directory.  Also, default in a trailing
            # dot for null file types.
d165 1
a165 1
            $to = VMS::Filespec::rmsexpand(VMS::Filespec::vmsify($to), '.');
d167 35
a201 2
            # Get rid of the old versions to be like UNIX
            1 while unlink $to;
d204 1
a204 1
        return syscopy($from, $to) || 0;
d334 2
a335 2
    if ($^O eq 'VMS' && -e $from
        && ! -d $to && ! -d $from) {
d337 1
a337 4
            # VMS natively inherits path components from the source of a
            # copy, but we want the Unixy behavior of inheriting from
            # the current working directory.  Also, default in a trailing
            # dot for null file types.
d339 31
a369 1
            $to = VMS::Filespec::rmsexpand(VMS::Filespec::vmsify($to), '.');
d372 2
a373 1
            1 while unlink $to;
d376 1
a376 1
    return 1 if rename $from, $to;
d438 1
a438 1
	copy("sourcefile","destinationfile") or die "Copy failed: $!";
d440 1
a440 1
	move("/dev1/sourcefile","/dev2/destinationfile");
d464 2
a465 5
written to. If the second argument does not exist but the parent
directory does exist, then it will be created. Trying to copy
a file into a non-existent directory is an error.
Trying to copy a file on top of itself is also an error.
C<copy> will not overwrite read-only files.
@


