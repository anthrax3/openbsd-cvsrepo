head	1.10;
access;
symbols
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2013.03.25.20.40.56;	author sthen;	state dead;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.33.06;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.31;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.36;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.09;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.44;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.04.07.21.13.17;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.34;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.59;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@package File::CheckTree;

use 5.006;
use Cwd;
use Exporter;
use File::Spec;
use warnings;
use strict;

our $VERSION = '4.4';
our @@ISA     = qw(Exporter);
our @@EXPORT  = qw(validate);

=head1 NAME

File::CheckTree - run many filetest checks on a tree

=head1 SYNOPSIS

    use File::CheckTree;

    $num_warnings = validate( q{
        /vmunix                 -e || die
        /boot                   -e || die
        /bin                    cd
            csh                 -ex
            csh                 !-ug
            sh                  -ex
            sh                  !-ug
        /usr                    -d || warn "What happened to $file?\n"
    });

=head1 DESCRIPTION

The validate() routine takes a single multiline string consisting of
directives, each containing a filename plus a file test to try on it.
(The file test may also be a "cd", causing subsequent relative filenames
to be interpreted relative to that directory.)  After the file test
you may put C<|| die> to make it a fatal error if the file test fails.
The default is C<|| warn>.  The file test may optionally have a "!' prepended
to test for the opposite condition.  If you do a cd and then list some
relative filenames, you may want to indent them slightly for readability.
If you supply your own die() or warn() message, you can use $file to
interpolate the filename.

Filetests may be bunched:  "-rwx" tests for all of C<-r>, C<-w>, and C<-x>.
Only the first failed test of the bunch will produce a warning.

The routine returns the number of warnings issued.

=head1 AUTHOR

File::CheckTree was derived from lib/validate.pl which was
written by Larry Wall.
Revised by Paul Grassie <F<grassie@@perl.com>> in 2002.

=head1 HISTORY

File::CheckTree used to not display fatal error messages.
It used to count only those warnings produced by a generic C<|| warn>
(and not those in which the user supplied the message).  In addition,
the validate() routine would leave the user program in whatever
directory was last entered through the use of "cd" directives.
These bugs were fixed during the development of perl 5.8.
The first fixed version of File::CheckTree was 4.2.

=cut

my $Warnings;

sub validate {
    my ($starting_dir, $file, $test, $cwd, $oldwarnings);

    $starting_dir = cwd;

    $cwd = "";
    $Warnings = 0;

    foreach my $check (split /\n/, $_[0]) {
        my ($testlist, @@testlist);

        # skip blanks/comments
        next if $check =~ /^\s*#/ || $check =~ /^\s*$/;

        # Todo:
        # should probably check for invalid directives and die
        # but earlier versions of File::CheckTree did not do this either

        # split a line like "/foo -r || die"
        # so that $file is "/foo", $test is "-r || die"
        # (making special allowance for quoted filenames).
        if ($check =~ m/^\s*"([^"]+)"\s+(.*?)\s*$/ or
            $check =~ m/^\s*'([^']+)'\s+(.*?)\s*$/ or
            $check =~ m/^\s*(\S+?)\s+(\S.*?)\s*$/)
        {
            ($file, $test) = ($1,$2);
        }
        else {
            die "Malformed line: '$check'";
        };

        # change a $test like "!-ug || die" to "!-Z || die",
        # capturing the bundled tests (e.g. "ug") in $2
        if ($test =~ s/ ^ (!?-) (\w{2,}) \b /$1Z/x) {
            $testlist = $2;
            # split bundled tests, e.g. "ug" to 'u', 'g'
            @@testlist = split(//, $testlist);
        }
        else {
            # put in placeholder Z for stand-alone test
            @@testlist = ('Z');
        }

        # will compare these two later to stop on 1st warning w/in a bundle
        $oldwarnings = $Warnings;

        foreach my $one (@@testlist) {
            # examples of $test: "!-Z || die" or "-w || warn"
            my $this = $test;

            # expand relative $file to full pathname if preceded by cd directive
            $file = File::Spec->catfile($cwd, $file) 
                    if $cwd && !File::Spec->file_name_is_absolute($file);

            # put filename in after the test operator
            $this =~ s/(-\w\b)/$1 "\$file"/g;

            # change the "-Z" representing a bundle with the $one test
            $this =~ s/-Z/-$one/;

            # if it's a "cd" directive...
            if ($this =~ /^cd\b/) {
                # add "|| die ..."
                $this .= ' || die "cannot cd to $file\n"';
                # expand "cd" directive with directory name
                $this =~ s/\bcd\b/chdir(\$cwd = '$file')/;
            }
            else {
                # add "|| warn" as a default disposition
                $this .= ' || warn' unless $this =~ /\|\|/; 

                # change a generic ".. || die" or ".. || warn"
                # to call valmess instead of die/warn directly
                # valmess will look up the error message from %Val_Message
                $this =~ s/ ^ ( (\S+) \s+ \S+ ) \s* \|\| \s* (die|warn) \s* $
                          /$1 || valmess('$3', '$2', \$file)/x;
            }

            {
                # count warnings, either from valmess or '-r || warn "my msg"'
                # also, call any pre-existing signal handler for __WARN__
                my $orig_sigwarn = $SIG{__WARN__};
                local $SIG{__WARN__} = sub {
                    ++$Warnings;
                    if ( $orig_sigwarn ) {
                        $orig_sigwarn->(@@_);
                    }
                    else {
                        warn "@@_";
                    }
                };

                # do the test
                eval $this;

                # re-raise an exception caused by a "... || die" test 
                if (my $err = $@@) {
                    # in case of any cd directives, return from whence we came
                    if ($starting_dir ne cwd) {
                        chdir($starting_dir) || die "$starting_dir: $!";
                    }
                    die $err;
                }
            }

            # stop on 1st warning within a bundle of tests
            last if $Warnings > $oldwarnings;
        }
    }

    # in case of any cd directives, return from whence we came
    if ($starting_dir ne cwd) {
        chdir($starting_dir) || die "chdir $starting_dir: $!";
    }

    return $Warnings;
}

my %Val_Message = (
    'r' => "is not readable by uid $>.",
    'w' => "is not writable by uid $>.",
    'x' => "is not executable by uid $>.",
    'o' => "is not owned by uid $>.",
    'R' => "is not readable by you.",
    'W' => "is not writable by you.",
    'X' => "is not executable by you.",
    'O' => "is not owned by you.",
    'e' => "does not exist.",
    'z' => "does not have zero size.",
    's' => "does not have non-zero size.",
    'f' => "is not a plain file.",
    'd' => "is not a directory.",
    'l' => "is not a symbolic link.",
    'p' => "is not a named pipe (FIFO).",
    'S' => "is not a socket.",
    'b' => "is not a block special file.",
    'c' => "is not a character special file.",
    'u' => "does not have the setuid bit set.",
    'g' => "does not have the setgid bit set.",
    'k' => "does not have the sticky bit set.",
    'T' => "is not a text file.",
    'B' => "is not a binary file."
);

sub valmess {
    my ($disposition, $test, $file) = @@_;
    my $ferror;

    if ($test =~ / ^ (!?) -(\w) \s* $ /x) {
        my ($neg, $ftype) = ($1, $2);

        $ferror = "$file $Val_Message{$ftype}";

        if ($neg eq '!') {
            $ferror =~ s/ is not / should not be / ||
            $ferror =~ s/ does not / should not / ||
            $ferror =~ s/ not / /;
        }
    }
    else {
        $ferror = "Can't do $test $file.\n";
    }

    die "$ferror\n" if $disposition eq 'die';
    warn "$ferror\n";
}

1;
@


1.9
log
@Merge in perl 5.10.1
@
text
@@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d10 1
a10 1
our $VERSION = '4.3';
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d16 1
a16 1
validate - run many filetest checks on a tree
d90 11
a100 2
        # so that $file is "/foo", $test is "-rwx || die"
        ($file, $test) = split(' ', $check, 2);   # special whitespace split
d167 1
a167 1
                if ($@@) {
d172 1
a172 1
                    die $@@ if $@@;
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d10 1
a10 1
our $VERSION = '4.2';
d53 3
a55 1
Unknown.  Revised by Paul Grassie <F<grassie@@perl.com>> in 2002.
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 11
a12 2
require 5.000;
require Exporter;
d22 9
a30 9
    $warnings += validate( q{
	/vmunix                 -e || die
	/boot                   -e || die
	/bin                    cd
	    csh                 -ex
	    csh                 !-ug
	    sh                  -ex
	    sh                  !-ug
	/usr                    -d || warn "What happened to $file?\n"
d36 2
a37 2
lines containing a filename plus a file test to try on it.  (The
file test may also be a "cd", causing subsequent relative filenames
d51 14
d67 1
a67 2
@@ISA = qw(Exporter);
@@EXPORT = qw(validate);
d69 4
a72 1
# $RCSfile: validate.pl,v $$Revision: 4.1 $$Date: 92/08/07 18:24:19 $
d74 95
a168 28
# The validate routine takes a single multiline string consisting of
# lines containing a filename plus a file test to try on it.  (The
# file test may also be a 'cd', causing subsequent relative filenames
# to be interpreted relative to that directory.)  After the file test
# you may put '|| die' to make it a fatal error if the file test fails.
# The default is '|| warn'.  The file test may optionally have a ! prepended
# to test for the opposite condition.  If you do a cd and then list some
# relative filenames, you may want to indent them slightly for readability.
# If you supply your own "die" or "warn" message, you can use $file to
# interpolate the filename.

# Filetests may be bunched:  -rwx tests for all of -r, -w and -x.
# Only the first failed test of the bunch will produce a warning.

# The routine returns the number of warnings issued.

# Usage:
#	use File::CheckTree;
#	$warnings += validate('
#	/vmunix			-e || die
#	/boot			-e || die
#	/bin			cd
#	    csh			-ex
#	    csh			!-ug
#	    sh			-ex
#	    sh			!-ug
#	/usr			-d || warn "What happened to $file?\n"
#	');
d170 3
a172 24
sub validate {
    local($file,$test,$warnings,$oldwarnings);
    foreach $check (split(/\n/,$_[0])) {
	next if $check =~ /^#/;
	next if $check =~ /^$/;
	($file,$test) = split(' ',$check,2);
	if ($test =~ s/^(!?-)(\w{2,}\b)/$1Z/) {
	    $testlist = $2;
	    @@testlist = split(//,$testlist);
	}
	else {
	    @@testlist = ('Z');
	}
	$oldwarnings = $warnings;
	foreach $one (@@testlist) {
	    $this = $test;
	    $this =~ s/(-\w\b)/$1 \$file/g;
	    $this =~ s/-Z/-$one/;
	    $this .= ' || warn' unless $this =~ /\|\|/;
	    $this =~ s/^(.*\S)\s*\|\|\s*(die|warn)$/$1 || valmess('$2','$1')/;
	    $this =~ s/\bcd\b/chdir (\$cwd = \$file)/g;
	    eval $this;
	    last if $warnings > $oldwarnings;
	}
d174 2
a175 1
    $warnings;
d178 26
d205 13
a217 33
    local($disposition,$this) = @@_;
    $file = $cwd . '/' . $file unless $file =~ m|^/|s;
    if ($this =~ /^(!?)-(\w)\s+\$file\s*$/) {
	$neg = $1;
	$tmp = $2;
	$tmp eq 'r' && ($mess = "$file is not readable by uid $>.");
	$tmp eq 'w' && ($mess = "$file is not writable by uid $>.");
	$tmp eq 'x' && ($mess = "$file is not executable by uid $>.");
	$tmp eq 'o' && ($mess = "$file is not owned by uid $>.");
	$tmp eq 'R' && ($mess = "$file is not readable by you.");
	$tmp eq 'W' && ($mess = "$file is not writable by you.");
	$tmp eq 'X' && ($mess = "$file is not executable by you.");
	$tmp eq 'O' && ($mess = "$file is not owned by you.");
	$tmp eq 'e' && ($mess = "$file does not exist.");
	$tmp eq 'z' && ($mess = "$file does not have zero size.");
	$tmp eq 's' && ($mess = "$file does not have non-zero size.");
	$tmp eq 'f' && ($mess = "$file is not a plain file.");
	$tmp eq 'd' && ($mess = "$file is not a directory.");
	$tmp eq 'l' && ($mess = "$file is not a symbolic link.");
	$tmp eq 'p' && ($mess = "$file is not a named pipe (FIFO).");
	$tmp eq 'S' && ($mess = "$file is not a socket.");
	$tmp eq 'b' && ($mess = "$file is not a block special file.");
	$tmp eq 'c' && ($mess = "$file is not a character special file.");
	$tmp eq 'u' && ($mess = "$file does not have the setuid bit set.");
	$tmp eq 'g' && ($mess = "$file does not have the setgid bit set.");
	$tmp eq 'k' && ($mess = "$file does not have the sticky bit set.");
	$tmp eq 'T' && ($mess = "$file is not a text file.");
	$tmp eq 'B' && ($mess = "$file is not a binary file.");
	if ($neg eq '!') {
	    $mess =~ s/ is not / should not be / ||
	    $mess =~ s/ does not / should not / ||
	    $mess =~ s/ not / /;
	}
d220 1
a220 2
	$this =~ s/\$file/'$file'/g;
	$mess = "Can't do $this.\n";
d222 3
a224 3
    die "$mess\n" if $disposition eq 'die';
    warn "$mess\n";
    ++$warnings;
a227 1

@


1.4
log
@perl-5.6.0 + local changes
@
text
@@


1.3
log
@perl5.005_03 (stock)
@
text
@d108 1
a108 1
    $file = $cwd . '/' . $file unless $file =~ m|^/|;
@


1.2
log
@perl 5.004_04
@
text
@a139 1
	print STDERR $mess,"\n";
d143 1
a143 1
	print STDERR "Can't do $this.\n";
d145 2
a146 1
    if ($disposition eq 'die') { exit 1; }
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d140 1
d144 1
a144 1
	$mess = "Can't do $this.\n";
d146 1
a146 2
    die "$mess\n" if $disposition eq 'die';
    warn "$mess\n";
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d108 1
a108 1
    $file = $cwd . '/' . $file unless $file =~ m|^/|s;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d2 2
a3 11

use 5.006;
use Cwd;
use Exporter;
use File::Spec;
use warnings;
use strict;

our $VERSION = '4.2';
our @@ISA     = qw(Exporter);
our @@EXPORT  = qw(validate);
d13 9
a21 9
    $num_warnings = validate( q{
        /vmunix                 -e || die
        /boot                   -e || die
        /bin                    cd
            csh                 -ex
            csh                 !-ug
            sh                  -ex
            sh                  !-ug
        /usr                    -d || warn "What happened to $file?\n"
d27 2
a28 2
directives, each containing a filename plus a file test to try on it.
(The file test may also be a "cd", causing subsequent relative filenames
d42 1
a42 3
=head1 AUTHOR

Unknown.  Revised by Paul Grassie <F<grassie@@perl.com>> in 2002.
d44 2
a45 1
=head1 HISTORY
d47 1
a47 9
File::CheckTree used to not display fatal error messages.
It used to count only those warnings produced by a generic C<|| warn>
(and not those in which the user supplied the message).  In addition,
the validate() routine would leave the user program in whatever
directory was last entered through the use of "cd" directives.
These bugs were fixed during the development of perl 5.8.
The first fixed version of File::CheckTree was 4.2.

=cut
d49 28
a76 1
my $Warnings;
d79 23
a101 98
    my ($starting_dir, $file, $test, $cwd, $oldwarnings);

    $starting_dir = cwd;

    $cwd = "";
    $Warnings = 0;

    foreach my $check (split /\n/, $_[0]) {
        my ($testlist, @@testlist);

        # skip blanks/comments
        next if $check =~ /^\s*#/ || $check =~ /^\s*$/;

        # Todo:
        # should probably check for invalid directives and die
        # but earlier versions of File::CheckTree did not do this either

        # split a line like "/foo -r || die"
        # so that $file is "/foo", $test is "-rwx || die"
        ($file, $test) = split(' ', $check, 2);   # special whitespace split

        # change a $test like "!-ug || die" to "!-Z || die",
        # capturing the bundled tests (e.g. "ug") in $2
        if ($test =~ s/ ^ (!?-) (\w{2,}) \b /$1Z/x) {
            $testlist = $2;
            # split bundled tests, e.g. "ug" to 'u', 'g'
            @@testlist = split(//, $testlist);
        }
        else {
            # put in placeholder Z for stand-alone test
            @@testlist = ('Z');
        }

        # will compare these two later to stop on 1st warning w/in a bundle
        $oldwarnings = $Warnings;

        foreach my $one (@@testlist) {
            # examples of $test: "!-Z || die" or "-w || warn"
            my $this = $test;

            # expand relative $file to full pathname if preceded by cd directive
            $file = File::Spec->catfile($cwd, $file) 
                    if $cwd && !File::Spec->file_name_is_absolute($file);

            # put filename in after the test operator
            $this =~ s/(-\w\b)/$1 "\$file"/g;

            # change the "-Z" representing a bundle with the $one test
            $this =~ s/-Z/-$one/;

            # if it's a "cd" directive...
            if ($this =~ /^cd\b/) {
                # add "|| die ..."
                $this .= ' || die "cannot cd to $file\n"';
                # expand "cd" directive with directory name
                $this =~ s/\bcd\b/chdir(\$cwd = '$file')/;
            }
            else {
                # add "|| warn" as a default disposition
                $this .= ' || warn' unless $this =~ /\|\|/; 

                # change a generic ".. || die" or ".. || warn"
                # to call valmess instead of die/warn directly
                # valmess will look up the error message from %Val_Message
                $this =~ s/ ^ ( (\S+) \s+ \S+ ) \s* \|\| \s* (die|warn) \s* $
                          /$1 || valmess('$3', '$2', \$file)/x;
            }

            {
                # count warnings, either from valmess or '-r || warn "my msg"'
                # also, call any pre-existing signal handler for __WARN__
                my $orig_sigwarn = $SIG{__WARN__};
                local $SIG{__WARN__} = sub {
                    ++$Warnings;
                    if ( $orig_sigwarn ) {
                        $orig_sigwarn->(@@_);
                    }
                    else {
                        warn "@@_";
                    }
                };

                # do the test
                eval $this;

                # re-raise an exception caused by a "... || die" test 
                if ($@@) {
                    # in case of any cd directives, return from whence we came
                    if ($starting_dir ne cwd) {
                        chdir($starting_dir) || die "$starting_dir: $!";
                    }
                    die $@@ if $@@;
                }
            }

            # stop on 1st warning within a bundle of tests
            last if $Warnings > $oldwarnings;
        }
d103 1
a103 7

    # in case of any cd directives, return from whence we came
    if ($starting_dir ne cwd) {
        chdir($starting_dir) || die "chdir $starting_dir: $!";
    }

    return $Warnings;
a105 26
my %Val_Message = (
    'r' => "is not readable by uid $>.",
    'w' => "is not writable by uid $>.",
    'x' => "is not executable by uid $>.",
    'o' => "is not owned by uid $>.",
    'R' => "is not readable by you.",
    'W' => "is not writable by you.",
    'X' => "is not executable by you.",
    'O' => "is not owned by you.",
    'e' => "does not exist.",
    'z' => "does not have zero size.",
    's' => "does not have non-zero size.",
    'f' => "is not a plain file.",
    'd' => "is not a directory.",
    'l' => "is not a symbolic link.",
    'p' => "is not a named pipe (FIFO).",
    'S' => "is not a socket.",
    'b' => "is not a block special file.",
    'c' => "is not a character special file.",
    'u' => "does not have the setuid bit set.",
    'g' => "does not have the setgid bit set.",
    'k' => "does not have the sticky bit set.",
    'T' => "is not a text file.",
    'B' => "is not a binary file."
);

d107 33
a139 13
    my ($disposition, $test, $file) = @@_;
    my $ferror;

    if ($test =~ / ^ (!?) -(\w) \s* $ /x) {
        my ($neg, $ftype) = ($1, $2);

        $ferror = "$file $Val_Message{$ftype}";

        if ($neg eq '!') {
            $ferror =~ s/ is not / should not be / ||
            $ferror =~ s/ does not / should not / ||
            $ferror =~ s/ not / /;
        }
d142 2
a143 1
        $ferror = "Can't do $test $file.\n";
d145 3
a147 3

    die "$ferror\n" if $disposition eq 'die';
    warn "$ferror\n";
d151 1
@


1.1.1.5
log
@perl 5.8.3 from CPAN
@
text
@d10 1
a10 1
our $VERSION = '4.3';
d53 1
a53 3
File::CheckTree was derived from lib/validate.pl which was
written by Larry Wall.
Revised by Paul Grassie <F<grassie@@perl.com>> in 2002.
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d16 1
a16 1
File::CheckTree - run many filetest checks on a tree
d90 2
a91 11
        # so that $file is "/foo", $test is "-r || die"
        # (making special allowance for quoted filenames).
        if ($check =~ m/^\s*"([^"]+)"\s+(.*?)\s*$/ or
            $check =~ m/^\s*'([^']+)'\s+(.*?)\s*$/ or
            $check =~ m/^\s*(\S+?)\s+(\S.*?)\s*$/)
        {
            ($file, $test) = ($1,$2);
        }
        else {
            die "Malformed line: '$check'";
        };
d158 1
a158 1
                if (my $err = $@@) {
d163 1
a163 1
                    die $err;
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d10 1
a10 1
our $VERSION = '4.4';
@


