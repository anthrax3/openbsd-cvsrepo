head	1.7;
access;
symbols
	OPENBSD_5_5:1.6.0.6
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.2
	OPENBSD_5_4_BASE:1.6
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.5.0.14
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.12
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.10
	OPENBSD_5_0:1.5.0.8
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.6
	OPENBSD_4_9_BASE:1.5
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.4.0.30
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.26
	OPENBSD_4_5_BASE:1.4
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.4.0.24
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.22
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.20
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.18
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.16
	OPENBSD_4_0_BASE:1.4
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.7
date	2014.03.24.15.05.28;	author afresh1;	state dead;
branches;
next	1.6;

1.6
date	2013.03.25.20.40.56;	author sthen;	state Exp;
branches;
next	1.5;

1.5
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.36;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.57.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.09;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.44;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.10.59;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2013.03.25.20.08.54;	author sthen;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.7
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@#!perl -w

# use strict fails
#Can't use string ("main::glob") as a symbol ref while "strict refs" in use at /usr/lib/perl5/5.005/File/DosGlob.pm line 191.

#
# Documentation at the __END__
#

package File::DosGlob;

our $VERSION = '1.06';
use strict;
use warnings;

sub doglob {
    my $cond = shift;
    my @@retval = ();
    my $fix_drive_relative_paths;
    #print "doglob: ", join('|', @@_), "\n";
  OUTER:
    for my $pat (@@_) {
	my @@matched = ();
	my @@globdirs = ();
	my $head = '.';
	my $sepchr = '/';
        my $tail;
	next OUTER unless defined $pat and $pat ne '';
	# if arg is within quotes strip em and do no globbing
	if ($pat =~ /^"(.*)"\z/s) {
	    $pat = $1;
	    if ($cond eq 'd') { push(@@retval, $pat) if -d $pat }
	    else              { push(@@retval, $pat) if -e $pat }
	    next OUTER;
	}
	# wildcards with a drive prefix such as h:*.pm must be changed
	# to h:./*.pm to expand correctly
	if ($pat =~ m|^([A-Za-z]:)[^/\\]|s) {
	    substr($pat,0,2) = $1 . "./";
	    $fix_drive_relative_paths = 1;
	}
	if ($pat =~ m|^(.*)([\\/])([^\\/]*)\z|s) {
	    ($head, $sepchr, $tail) = ($1,$2,$3);
	    #print "div: |$head|$sepchr|$tail|\n";
	    push (@@retval, $pat), next OUTER if $tail eq '';
	    if ($head =~ /[*?]/) {
		@@globdirs = doglob('d', $head);
		push(@@retval, doglob($cond, map {"$_$sepchr$tail"} @@globdirs)),
		    next OUTER if @@globdirs;
	    }
	    $head .= $sepchr if $head eq '' or $head =~ /^[A-Za-z]:\z/s;
	    $pat = $tail;
	}
	#
	# If file component has no wildcards, we can avoid opendir
	unless ($pat =~ /[*?]/) {
	    $head = '' if $head eq '.';
	    $head .= $sepchr unless $head eq '' or substr($head,-1) eq $sepchr;
	    $head .= $pat;
	    if ($cond eq 'd') { push(@@retval,$head) if -d $head }
	    else              { push(@@retval,$head) if -e $head }
	    next OUTER;
	}
	opendir(D, $head) or next OUTER;
	my @@leaves = readdir D;
	closedir D;
	$head = '' if $head eq '.';
	$head .= $sepchr unless $head eq '' or substr($head,-1) eq $sepchr;

	# escape regex metachars but not glob chars
	$pat =~ s:([].+^\-\${}()[|]):\\$1:g;
	# and convert DOS-style wildcards to regex
	$pat =~ s/\*/.*/g;
	$pat =~ s/\?/.?/g;

	#print "regex: '$pat', head: '$head'\n";
	my $matchsub = sub { $_[0] =~ m|^$pat\z|is };
      INNER:
	for my $e (@@leaves) {
	    next INNER if $e eq '.' or $e eq '..';
	    next INNER if $cond eq 'd' and ! -d "$head$e";
	    push(@@matched, "$head$e"), next INNER if &$matchsub($e);
	    #
	    # [DOS compatibility special case]
	    # Failed, add a trailing dot and try again, but only
	    # if name does not have a dot in it *and* pattern
	    # has a dot *and* name is shorter than 9 chars.
	    #
	    if (index($e,'.') == -1 and length($e) < 9
	        and index($pat,'\\.') != -1) {
		push(@@matched, "$head$e"), next INNER if &$matchsub("$e.");
	    }
	}
	push @@retval, @@matched if @@matched;
    }
    if ($fix_drive_relative_paths) {
	s|^([A-Za-z]:)\./|$1| for @@retval;
    }
    return @@retval;
}

#
# this can be used to override CORE::glob in a specific
# package by saying C<use File::DosGlob 'glob';> in that
# namespace.
#

# context (keyed by second cxix arg provided by core)
my %entries;

sub glob {
    my($pat,$cxix) = @@_;
    my @@pat;

    # glob without args defaults to $_
    $pat = $_ unless defined $pat;

    # assume global context if not provided one
    $cxix = '_G_' unless defined $cxix;

    # if we're just beginning, do it all first
    if (!$entries{$cxix}) {
      # extract patterns
      if ($pat =~ /\s/) {
	require Text::ParseWords;
	@@pat = Text::ParseWords::parse_line('\s+',0,$pat);
      }
      else {
	push @@pat, $pat;
      }

      # Mike Mestnik: made to do abc{1,2,3} == abc1 abc2 abc3.
      #   abc3 will be the original {3} (and drop the {}).
      #   abc1 abc2 will be put in @@appendpat.
      # This was just the easiest way, not nearly the best.
      REHASH: {
	my @@appendpat = ();
	for (@@pat) {
	    # There must be a "," I.E. abc{efg} is not what we want.
	    while ( /^(.*)(?<!\\)\{(.*?)(?<!\\)\,.*?(?<!\\)\}(.*)$/ ) {
		my ($start, $match, $end) = ($1, $2, $3);
		#print "Got: \n\t$start\n\t$match\n\t$end\n";
		my $tmp = "$start$match$end";
		while ( $tmp =~ s/^(.*?)(?<!\\)\{(?:.*(?<!\\)\,)?(.*\Q$match\E.*?)(?:(?<!\\)\,.*)?(?<!\\)\}(.*)$/$1$2$3/ ) {
		    #print "Striped: $tmp\n";
		    #  these expansions will be performed by the original,
		    #  when we call REHASH.
		}
		push @@appendpat, ("$tmp");
		s/^\Q$start\E(?<!\\)\{\Q$match\E(?<!\\)\,/$start\{/;
		if ( /^\Q$start\E(?<!\\)\{(?!.*?(?<!\\)\,.*?\Q$end\E$)(.*)(?<!\\)\}\Q$end\E$/ ) {
		    $match = $1;
		    #print "GOT: \n\t$start\n\t$match\n\t$end\n\n";
		    $_ = "$start$match$end";
		}
	    }
	    #print "Sould have "GOT" vs "Got"!\n";
		#FIXME: There should be checking for this.
		#  How or what should be done about failure is beond me.
	}
	if ( $#appendpat != -1
		) {
	    #print "LOOP\n";
	    #FIXME: Max loop, no way! :")
	    for ( @@appendpat ) {
	        push @@pat, $_;
	    }
	    goto REHASH;
	}
      }
      for ( @@pat ) {
	s/\\{/{/g;
	s/\\}/}/g;
	s/\\,/,/g;
      }
      #print join ("\n", @@pat). "\n";
 
      $entries{$cxix} = [doglob(1,@@pat)];
    }

    # chuck it all out, quick or slow
    if (wantarray) {
	return @@{delete $entries{$cxix}};
    }
    else {
	if (scalar @@{$entries{$cxix}}) {
	    return shift @@{$entries{$cxix}};
	}
	else {
	    # return undef for EOL
	    delete $entries{$cxix};
	    return undef;
	}
    }
}

{
    no strict 'refs';

    sub import {
    my $pkg = shift;
    return unless @@_;
    my $sym = shift;
    my $callpkg = ($sym =~ s/^GLOBAL_//s ? 'CORE::GLOBAL' : caller(0));
    *{$callpkg.'::'.$sym} = \&{$pkg.'::'.$sym} if $sym eq 'glob';
    }
}
1;

__END__

=head1 NAME

File::DosGlob - DOS like globbing and then some

=head1 SYNOPSIS

    require 5.004;

    # override CORE::glob in current package
    use File::DosGlob 'glob';

    # override CORE::glob in ALL packages (use with extreme caution!)
    use File::DosGlob 'GLOBAL_glob';

    @@perlfiles = glob  "..\\pe?l/*.p?";
    print <..\\pe?l/*.p?>;

    # from the command line (overrides only in main::)
    > perl -MFile::DosGlob=glob -e "print <../pe*/*p?>"

=head1 DESCRIPTION

A module that implements DOS-like globbing with a few enhancements.
It is largely compatible with perlglob.exe (the M$ setargv.obj
version) in all but one respect--it understands wildcards in
directory components.

For example, C<<..\\l*b\\file/*glob.p?>> will work as expected (in
that it will find something like '..\lib\File/DosGlob.pm' alright).
Note that all path components are case-insensitive, and that
backslashes and forward slashes are both accepted, and preserved.
You may have to double the backslashes if you are putting them in
literally, due to double-quotish parsing of the pattern by perl.

Spaces in the argument delimit distinct patterns, so
C<glob('*.exe *.dll')> globs all filenames that end in C<.exe>
or C<.dll>.  If you want to put in literal spaces in the glob
pattern, you can escape them with either double quotes, or backslashes.
e.g. C<glob('c:/"Program Files"/*/*.dll')>, or
C<glob('c:/Program\ Files/*/*.dll')>.  The argument is tokenized using
C<Text::ParseWords::parse_line()>, so see L<Text::ParseWords> for details
of the quoting rules used.

Extending it to csh patterns is left as an exercise to the reader.

=head1 EXPORTS (by request only)

glob()

=head1 BUGS

Should probably be built into the core, and needs to stop
pandering to DOS habits.  Needs a dose of optimizium too.

=head1 AUTHOR

Gurusamy Sarathy <gsar@@activestate.com>

=head1 HISTORY

=over 4

=item *

Support for globally overriding glob() (GSAR 3-JUN-98)

=item *

Scalar context, independent iterator context fixes (GSAR 15-SEP-97)

=item *

A few dir-vs-file optimizations result in glob importation being
10 times faster than using perlglob.exe, and using perlglob.bat is
only twice as slow as perlglob.exe (GSAR 28-MAY-97)

=item *

Several cleanups prompted by lack of compatible perlglob.exe
under Borland (GSAR 27-MAY-97)

=item *

Initial version (GSAR 20-FEB-97)

=back

=head1 SEE ALSO

perl

perlglob.bat

Text::ParseWords

=cut

@


1.6
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@@


1.5
log
@Merge in perl 5.10.1
@
text
@d12 1
a12 1
our $VERSION = '1.01';
d19 1
d40 1
d71 1
a71 1
        $pat =~ s:([].+^\-\${}[|]):\\$1:g;
d96 2
a97 110
    return @@retval;
}


#
# Do DOS-like globbing on Mac OS 
#
sub doglob_Mac {
    my $cond = shift;
    my @@retval = ();

	#print "doglob_Mac: ", join('|', @@_), "\n";
  OUTER:
    for my $arg (@@_) {
        local $_ = $arg;
	my @@matched = ();
	my @@globdirs = ();
	my $head = ':';
	my $not_esc_head = $head;
	my $sepchr = ':';	
	next OUTER unless defined $_ and $_ ne '';
	# if arg is within quotes strip em and do no globbing
	if (/^"(.*)"\z/s) {
	    $_ = $1;
		# $_ may contain escaped metachars '\*', '\?' and '\'
	        my $not_esc_arg = $_;
		$not_esc_arg =~ s/\\([*?\\])/$1/g;
	    if ($cond eq 'd') { push(@@retval, $not_esc_arg) if -d $not_esc_arg }
	    else              { push(@@retval, $not_esc_arg) if -e $not_esc_arg }
	    next OUTER;
	}

	if (m|^(.*?)(:+)([^:]*)\z|s) { # note: $1 is not greedy
	    my $tail;
	    ($head, $sepchr, $tail) = ($1,$2,$3);
	    #print "div: |$head|$sepchr|$tail|\n";
	    push (@@retval, $_), next OUTER if $tail eq '';		
		#
		# $head may contain escaped metachars '\*' and '\?'
		
		my $tmp_head = $head;
		# if a '*' or '?' is preceded by an odd count of '\', temporary delete 
		# it (and its preceding backslashes), i.e. don't treat '\*' and '\?' as 
		# wildcards
		$tmp_head =~ s/(\\*)([*?])/$2 x ((length($1) + 1) % 2)/eg;
	
		if ($tmp_head =~ /[*?]/) { # if there are wildcards ...	
		@@globdirs = doglob_Mac('d', $head);
		push(@@retval, doglob_Mac($cond, map {"$_$sepchr$tail"} @@globdirs)),
		    next OUTER if @@globdirs;
	    }
		
		$head .= $sepchr; 
		$not_esc_head = $head;
		# unescape $head for file operations
		$not_esc_head =~ s/\\([*?\\])/$1/g;
	    $_ = $tail;
	}
	#
	# If file component has no wildcards, we can avoid opendir
	
	my $tmp_tail = $_;
	# if a '*' or '?' is preceded by an odd count of '\', temporary delete 
	# it (and its preceding backslashes), i.e. don't treat '\*' and '\?' as 
	# wildcards
	$tmp_tail =~ s/(\\*)([*?])/$2 x ((length($1) + 1) % 2)/eg;
	
	unless ($tmp_tail =~ /[*?]/) { # if there are wildcards ...
	    $not_esc_head = $head = '' if $head eq ':';
	    my $not_esc_tail = $_;
	    # unescape $head and $tail for file operations
	    $not_esc_tail =~ s/\\([*?\\])/$1/g;
	    $head .= $_;
		$not_esc_head .= $not_esc_tail;
	    if ($cond eq 'd') { push(@@retval,$head) if -d $not_esc_head }
	    else              { push(@@retval,$head) if -e $not_esc_head }
	    next OUTER;
	}
	#print "opendir($not_esc_head)\n";
	opendir(D, $not_esc_head) or next OUTER;
	my @@leaves = readdir D;
	closedir D;

	# escape regex metachars but not '\' and glob chars '*', '?'
	$_ =~ s:([].+^\-\${}[|]):\\$1:g;
	# and convert DOS-style wildcards to regex,
	# but only if they are not escaped
	$_ =~ s/(\\*)([*?])/$1 . ('.' x ((length($1) + 1) % 2)) . $2/eg;

	#print "regex: '$_', head: '$head', unescaped head: '$not_esc_head'\n";
	my $matchsub = eval 'sub { $_[0] =~ m|^' . $_ . '\\z|ios }';
	warn($@@), next OUTER if $@@;
      INNER:
	for my $e (@@leaves) {
	    next INNER if $e eq '.' or $e eq '..';
	    next INNER if $cond eq 'd' and ! -d "$not_esc_head$e";
		
		if (&$matchsub($e)) {
			my $leave = (($not_esc_head eq ':') && (-f "$not_esc_head$e")) ? 
		            	"$e" : "$not_esc_head$e";
			#
			# On Mac OS, the two glob metachars '*' and '?' and the escape 
			# char '\' are valid characters for file and directory names. 
			# We have to escape and treat them specially.
			$leave =~ s|([*?\\])|\\$1|g;		
			push(@@matched, $leave);
			next INNER;
		}
	}
	push @@retval, @@matched if @@matched;
a102 90
# _expand_volume() will only be used on Mac OS (Classic): 
# Takes an array of original patterns as argument and returns an array of  
# possibly modified patterns. Each original pattern is processed like 
# that:
# + If there's a volume name in the pattern, we push a separate pattern 
#   for each mounted volume that matches (with '*', '?' and '\' escaped).  
# + If there's no volume name in the original pattern, it is pushed 
#   unchanged. 
# Note that the returned array of patterns may be empty.
#  
sub _expand_volume {
	
	require MacPerl; # to be verbose
	
	my @@pat = @@_;
	my @@new_pat = ();
	my @@FSSpec_Vols = MacPerl::Volumes();
	my @@mounted_volumes = ();

	foreach my $spec_vol (@@FSSpec_Vols) {		
		# push all mounted volumes into array
     	push @@mounted_volumes, MacPerl::MakePath($spec_vol);
	}
	#print "mounted volumes: |@@mounted_volumes|\n";
	
	while (@@pat) {
		my $pat = shift @@pat;	
		if ($pat =~ /^([^:]+:)(.*)\z/) { # match a volume name?
			my $vol_pat = $1;
			my $tail = $2;
			#
			# escape regex metachars but not '\' and glob chars '*', '?'
			$vol_pat =~ s:([].+^\-\${}[|]):\\$1:g;
			# and convert DOS-style wildcards to regex,
			# but only if they are not escaped
			$vol_pat =~ s/(\\*)([*?])/$1 . ('.' x ((length($1) + 1) % 2)) . $2/eg;
			#print "volume regex: '$vol_pat' \n";
				
			foreach my $volume (@@mounted_volumes) {
				if ($volume =~ m|^$vol_pat\z|ios) {
					#
					# On Mac OS, the two glob metachars '*' and '?' and the  
					# escape char '\' are valid characters for volume names. 
					# We have to escape and treat them specially.
					$volume =~ s|([*?\\])|\\$1|g;
					push @@new_pat, $volume . $tail;
				}
			}			
		} else { # no volume name in pattern, push original pattern
			push @@new_pat, $pat;
		}
	}
	return @@new_pat;
}


#
# _preprocess_pattern() will only be used on Mac OS (Classic): 
# Resolves any updirs in the pattern. Removes a single trailing colon 
# from the pattern, unless it's a volume name pattern like "*HD:"
#
sub _preprocess_pattern {
	my @@pat = @@_;
	
	foreach my $p (@@pat) {
		my $proceed;
		# resolve any updirs, e.g. "*HD:t?p::a*" -> "*HD:a*"
		do {
			$proceed = ($p =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);  
		} while ($proceed);
		# remove a single trailing colon, e.g. ":*:" -> ":*"
		$p =~ s/:([^:]+):\z/:$1/;
	}
	return @@pat;
}
		
		
#
# _un_escape() will only be used on Mac OS (Classic):
# Unescapes a list of arguments which may contain escaped 
# metachars '*', '?' and '\'.
#
sub _un_escape {
	foreach (@@_) {
		s/\\([*?\\])/$1/g;
	}
	return @@_;
}

#
a108 1
my %iter;
d118 7
a124 2
    # extract patterns
    if ($pat =~ /\s/) {
d127 2
a128 2
    }
    else {
d130 1
a130 1
    }
d132 5
a136 5
    # Mike Mestnik: made to do abc{1,2,3} == abc1 abc2 abc3.
    #   abc3 will be the original {3} (and drop the {}).
    #   abc1 abc2 will be put in @@appendpat.
    # This was just the esiest way, not nearly the best.
    REHASH: {
d146 1
a146 1
		    #  these expanshions will be preformed by the original,
d170 2
a171 2
    }
    for ( @@pat ) {
d175 2
a176 2
    }
    #print join ("\n", @@pat). "\n";
d178 1
a178 14
    # assume global context if not provided one
    $cxix = '_G_' unless defined $cxix;
    $iter{$cxix} = 0 unless exists $iter{$cxix};

    # if we're just beginning, do it all first
    if ($iter{$cxix} == 0) {
	if ($^O eq 'MacOS') {
		# first, take care of updirs and trailing colons
		@@pat = _preprocess_pattern(@@pat);
		# expand volume names
		@@pat = _expand_volume(@@pat);
		$entries{$cxix} = (@@pat) ? [_un_escape( doglob_Mac(1,@@pat) )] : [()];
	} else {
		$entries{$cxix} = [doglob(1,@@pat)];
a179 1
	}
a182 1
	delete $iter{$cxix};
d186 1
a186 1
	if ($iter{$cxix} = scalar @@{$entries{$cxix}}) {
a190 1
	    delete $iter{$cxix};
a255 55

=head1 NOTES

=over 4

=item *

Mac OS (Classic) users should note a few differences. The specification 
of pathnames in glob patterns adheres to the usual Mac OS conventions: 
The path separator is a colon ':', not a slash '/' or backslash '\'. A 
full path always begins with a volume name. A relative pathname on Mac 
OS must always begin with a ':', except when specifying a file or 
directory name in the current working directory, where the leading colon 
is optional. If specifying a volume name only, a trailing ':' is 
required. Due to these rules, a glob like E<lt>*:E<gt> will find all 
mounted volumes, while a glob like E<lt>*E<gt> or E<lt>:*E<gt> will find 
all files and directories in the current directory.

Note that updirs in the glob pattern are resolved before the matching begins,
i.e. a pattern like "*HD:t?p::a*" will be matched as "*HD:a*". Note also,
that a single trailing ':' in the pattern is ignored (unless it's a volume
name pattern like "*HD:"), i.e. a glob like <:*:> will find both directories 
I<and> files (and not, as one might expect, only directories). 

The metachars '*', '?' and the escape char '\' are valid characters in 
volume, directory and file names on Mac OS. Hence, if you want to match
a '*', '?' or '\' literally, you have to escape these characters. Due to 
perl's quoting rules, things may get a bit complicated, when you want to 
match a string like '\*' literally, or when you want to match '\' literally, 
but treat the immediately following character '*' as metachar. So, here's a 
rule of thumb (applies to both single- and double-quoted strings): escape 
each '*' or '?' or '\' with a backslash, if you want to treat them literally, 
and then double each backslash and your are done. E.g. 

- Match '\*' literally

   escape both '\' and '*'  : '\\\*'
   double the backslashes   : '\\\\\\*'

(Internally, the glob routine sees a '\\\*', which means that both '\' and 
'*' are escaped.)


- Match '\' literally, treat '*' as metachar

   escape '\' but not '*'   : '\\*'
   double the backslashes   : '\\\\*'

(Internally, the glob routine sees a '\\*', which means that '\' is escaped and 
'*' is not.)

Note that you also have to quote literal spaces in the glob pattern, as described
above.

=back
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d12 1
a12 1
our $VERSION = '1.00';
d38 1
a38 1
	    substr($_,0,2) = $1 . "./";
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d3 3
d12 4
d21 1
a21 2
    for my $arg (@@_) {
        local $_ = $arg;
d26 2
a27 1
	next OUTER unless defined $_ and $_ ne '';
d29 4
a32 4
	if (/^"(.*)"\z/s) {
	    $_ = $1;
	    if ($cond eq 'd') { push(@@retval, $_) if -d $_ }
	    else              { push(@@retval, $_) if -e $_ }
d37 1
a37 1
	if (m|^([A-Za-z]:)[^/\\]|s) {
d40 1
a40 2
	if (m|^(.*)([\\/])([^\\/]*)\z|s) {
	    my $tail;
d43 1
a43 1
	    push (@@retval, $_), next OUTER if $tail eq '';
d50 1
a50 1
	    $_ = $tail;
d54 1
a54 1
	unless (/[*?]/) {
d57 1
a57 1
	    $head .= $_;
d69 1
a69 1
	s:([].+^\-\${}[|]):\\$1:g;
d71 2
a72 2
	s/\*/.*/g;
	s/\?/.?/g;
d74 2
a75 3
	#print "regex: '$_', head: '$head'\n";
	my $matchsub = eval 'sub { $_[0] =~ m|^' . $_ . '\\z|ios }';
	warn($@@), next OUTER if $@@;
d88 1
a88 1
	        and index($_,'\\.') != -1) {
d97 201
d309 1
a309 2
    my $pat = shift;
    my $cxix = shift;
d324 46
d376 8
a383 1
	$entries{$cxix} = [doglob(1,@@pat)];
d385 1
d405 4
a408 1
sub import {
d414 1
a415 1

d464 55
@


1.2
log
@perl5.005_03 (stock)
@
text
@d22 1
a22 1
	if (/^"(.*)"$/) {
d28 6
a33 1
	if (m|^(.*)([\\/])([^\\/]*)$|) {
d43 1
a43 1
	    $head .= $sepchr if $head eq '' or $head =~ /^[A-Za-z]:$/;
d69 1
a69 1
	my $matchsub = eval 'sub { $_[0] =~ m|^' . $_ . '$|io }';
d150 1
a150 1
    my $callpkg = ($sym =~ s/^GLOBAL_// ? 'CORE::GLOBAL' : caller(0));
d165 1
a165 1
    
d168 1
a168 1
    
d174 1
a174 1
    
d214 1
a214 1
Gurusamy Sarathy <gsar@@umich.edu>
@


1.1
log
@perl 5.004_04
@
text
@a8 15
unless (caller) {
    $| = 1;
    while (@@ARGV) {
	#
	# We have to do this one by one for compatibility reasons.
	# If an arg doesn't match anything, we are supposed to return
	# the original arg.  I know, it stinks, eh?
	#
	my $arg = shift;
	my @@m = doglob(1,$arg);
	print (@@m ? join("\0", sort @@m) : $arg);
	print "\0" if @@ARGV;
    }
}

d100 1
d105 9
d120 1
a120 1
	$entries{$cxix} = [doglob(1,$pat)];
d143 1
a143 1
    my $callpkg = caller(0);
d145 2
a146 2
    *{$callpkg.'::'.$sym} = \&{$pkg.'::'.$sym}
	if defined($sym) and $sym eq 'glob';
a156 2
perlglob.bat - a more capable perlglob.exe replacement

d164 3
a171 2
    
    > perlglob ../pe*/*p?
d176 1
a176 2
This file is also a portable replacement for perlglob.exe.  It
is largely compatible with perlglob.exe (the M$ setargv.obj
d187 8
a194 10
When invoked as a program, it will print null-separated filenames
to standard output.

While one may replace perlglob.exe with this, usage by overriding
CORE::glob via importation should be much more efficient, because
it avoids launching a separate process, and is therefore strongly
recommended.  Note that it is currently possible to override
builtins like glob() only on a per-package basis, not "globally".
Thus, every namespace that wants to override glob() must explicitly
request the override.  See L<perlsub>.
d217 4
d243 4
@


1.1.1.1
log
@perl5.005_03
@
text
@d9 15
a114 1
    my @@pat;
a118 9
    # extract patterns
    if ($pat =~ /\s/) {
	require Text::ParseWords;
	@@pat = Text::ParseWords::parse_line('\s+',0,$pat);
    }
    else {
	push @@pat, $pat;
    }

d125 1
a125 1
	$entries{$cxix} = [doglob(1,@@pat)];
d148 1
a148 1
    return unless @@_;
d150 2
a151 2
    my $callpkg = ($sym =~ s/^GLOBAL_// ? 'CORE::GLOBAL' : caller(0));
    *{$callpkg.'::'.$sym} = \&{$pkg.'::'.$sym} if $sym eq 'glob';
d162 2
a170 3
    # override CORE::glob in ALL packages (use with extreme caution!)
    use File::DosGlob 'GLOBAL_glob';

d176 2
d182 2
a183 1
It is largely compatible with perlglob.exe (the M$ setargv.obj
d194 10
a203 8
Spaces in the argument delimit distinct patterns, so
C<glob('*.exe *.dll')> globs all filenames that end in C<.exe>
or C<.dll>.  If you want to put in literal spaces in the glob
pattern, you can escape them with either double quotes, or backslashes.
e.g. C<glob('c:/"Program Files"/*/*.dll')>, or
C<glob('c:/Program\ Files/*/*.dll')>.  The argument is tokenized using
C<Text::ParseWords::parse_line()>, so see L<Text::ParseWords> for details
of the quoting rules used.
a225 4
Support for globally overriding glob() (GSAR 3-JUN-98)

=item *

a247 4

perlglob.bat

Text::ParseWords
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d22 1
a22 1
	if (/^"(.*)"\z/s) {
d28 1
a28 6
	# wildcards with a drive prefix such as h:*.pm must be changed
	# to h:./*.pm to expand correctly
	if (m|^([A-Za-z]:)[^/\\]|s) {
	    substr($_,0,2) = $1 . "./";
	}
	if (m|^(.*)([\\/])([^\\/]*)\z|s) {
d38 1
a38 1
	    $head .= $sepchr if $head eq '' or $head =~ /^[A-Za-z]:\z/s;
d64 1
a64 1
	my $matchsub = eval 'sub { $_[0] =~ m|^' . $_ . '\\z|ios }';
d145 1
a145 1
    my $callpkg = ($sym =~ s/^GLOBAL_//s ? 'CORE::GLOBAL' : caller(0));
d160 1
a160 1

d163 1
a163 1

d169 1
a169 1

d209 1
a209 1
Gurusamy Sarathy <gsar@@activestate.com>
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a2 3
# use strict fails
#Can't use string ("main::glob") as a symbol ref while "strict refs" in use at /usr/lib/perl5/5.005/File/DosGlob.pm line 191.

a8 4
our $VERSION = '1.00';
use strict;
use warnings;

d14 2
a15 1
    for my $pat (@@_) {
d20 1
a20 2
        my $tail;
	next OUTER unless defined $pat and $pat ne '';
d22 4
a25 4
	if ($pat =~ /^"(.*)"\z/s) {
	    $pat = $1;
	    if ($cond eq 'd') { push(@@retval, $pat) if -d $pat }
	    else              { push(@@retval, $pat) if -e $pat }
d30 1
a30 1
	if ($pat =~ m|^([A-Za-z]:)[^/\\]|s) {
d33 2
a34 1
	if ($pat =~ m|^(.*)([\\/])([^\\/]*)\z|s) {
d37 1
a37 1
	    push (@@retval, $pat), next OUTER if $tail eq '';
d44 1
a44 1
	    $pat = $tail;
d48 1
a48 1
	unless ($pat =~ /[*?]/) {
d51 1
a51 1
	    $head .= $pat;
d63 1
a63 1
        $pat =~ s:([].+^\-\${}[|]):\\$1:g;
d65 2
a66 2
	$pat =~ s/\*/.*/g;
	$pat =~ s/\?/.?/g;
d68 3
a70 2
	#print "regex: '$pat', head: '$head'\n";
	my $matchsub = sub { $_[0] =~ m|^$pat\z|is };
d83 1
a83 1
	        and index($pat,'\\.') != -1) {
a91 201

#
# Do DOS-like globbing on Mac OS 
#
sub doglob_Mac {
    my $cond = shift;
    my @@retval = ();

	#print "doglob_Mac: ", join('|', @@_), "\n";
  OUTER:
    for my $arg (@@_) {
        local $_ = $arg;
	my @@matched = ();
	my @@globdirs = ();
	my $head = ':';
	my $not_esc_head = $head;
	my $sepchr = ':';	
	next OUTER unless defined $_ and $_ ne '';
	# if arg is within quotes strip em and do no globbing
	if (/^"(.*)"\z/s) {
	    $_ = $1;
		# $_ may contain escaped metachars '\*', '\?' and '\'
	        my $not_esc_arg = $_;
		$not_esc_arg =~ s/\\([*?\\])/$1/g;
	    if ($cond eq 'd') { push(@@retval, $not_esc_arg) if -d $not_esc_arg }
	    else              { push(@@retval, $not_esc_arg) if -e $not_esc_arg }
	    next OUTER;
	}

	if (m|^(.*?)(:+)([^:]*)\z|s) { # note: $1 is not greedy
	    my $tail;
	    ($head, $sepchr, $tail) = ($1,$2,$3);
	    #print "div: |$head|$sepchr|$tail|\n";
	    push (@@retval, $_), next OUTER if $tail eq '';		
		#
		# $head may contain escaped metachars '\*' and '\?'
		
		my $tmp_head = $head;
		# if a '*' or '?' is preceded by an odd count of '\', temporary delete 
		# it (and its preceding backslashes), i.e. don't treat '\*' and '\?' as 
		# wildcards
		$tmp_head =~ s/(\\*)([*?])/$2 x ((length($1) + 1) % 2)/eg;
	
		if ($tmp_head =~ /[*?]/) { # if there are wildcards ...	
		@@globdirs = doglob_Mac('d', $head);
		push(@@retval, doglob_Mac($cond, map {"$_$sepchr$tail"} @@globdirs)),
		    next OUTER if @@globdirs;
	    }
		
		$head .= $sepchr; 
		$not_esc_head = $head;
		# unescape $head for file operations
		$not_esc_head =~ s/\\([*?\\])/$1/g;
	    $_ = $tail;
	}
	#
	# If file component has no wildcards, we can avoid opendir
	
	my $tmp_tail = $_;
	# if a '*' or '?' is preceded by an odd count of '\', temporary delete 
	# it (and its preceding backslashes), i.e. don't treat '\*' and '\?' as 
	# wildcards
	$tmp_tail =~ s/(\\*)([*?])/$2 x ((length($1) + 1) % 2)/eg;
	
	unless ($tmp_tail =~ /[*?]/) { # if there are wildcards ...
	    $not_esc_head = $head = '' if $head eq ':';
	    my $not_esc_tail = $_;
	    # unescape $head and $tail for file operations
	    $not_esc_tail =~ s/\\([*?\\])/$1/g;
	    $head .= $_;
		$not_esc_head .= $not_esc_tail;
	    if ($cond eq 'd') { push(@@retval,$head) if -d $not_esc_head }
	    else              { push(@@retval,$head) if -e $not_esc_head }
	    next OUTER;
	}
	#print "opendir($not_esc_head)\n";
	opendir(D, $not_esc_head) or next OUTER;
	my @@leaves = readdir D;
	closedir D;

	# escape regex metachars but not '\' and glob chars '*', '?'
	$_ =~ s:([].+^\-\${}[|]):\\$1:g;
	# and convert DOS-style wildcards to regex,
	# but only if they are not escaped
	$_ =~ s/(\\*)([*?])/$1 . ('.' x ((length($1) + 1) % 2)) . $2/eg;

	#print "regex: '$_', head: '$head', unescaped head: '$not_esc_head'\n";
	my $matchsub = eval 'sub { $_[0] =~ m|^' . $_ . '\\z|ios }';
	warn($@@), next OUTER if $@@;
      INNER:
	for my $e (@@leaves) {
	    next INNER if $e eq '.' or $e eq '..';
	    next INNER if $cond eq 'd' and ! -d "$not_esc_head$e";
		
		if (&$matchsub($e)) {
			my $leave = (($not_esc_head eq ':') && (-f "$not_esc_head$e")) ? 
		            	"$e" : "$not_esc_head$e";
			#
			# On Mac OS, the two glob metachars '*' and '?' and the escape 
			# char '\' are valid characters for file and directory names. 
			# We have to escape and treat them specially.
			$leave =~ s|([*?\\])|\\$1|g;		
			push(@@matched, $leave);
			next INNER;
		}
	}
	push @@retval, @@matched if @@matched;
    }
    return @@retval;
}

#
# _expand_volume() will only be used on Mac OS (Classic): 
# Takes an array of original patterns as argument and returns an array of  
# possibly modified patterns. Each original pattern is processed like 
# that:
# + If there's a volume name in the pattern, we push a separate pattern 
#   for each mounted volume that matches (with '*', '?' and '\' escaped).  
# + If there's no volume name in the original pattern, it is pushed 
#   unchanged. 
# Note that the returned array of patterns may be empty.
#  
sub _expand_volume {
	
	require MacPerl; # to be verbose
	
	my @@pat = @@_;
	my @@new_pat = ();
	my @@FSSpec_Vols = MacPerl::Volumes();
	my @@mounted_volumes = ();

	foreach my $spec_vol (@@FSSpec_Vols) {		
		# push all mounted volumes into array
     	push @@mounted_volumes, MacPerl::MakePath($spec_vol);
	}
	#print "mounted volumes: |@@mounted_volumes|\n";
	
	while (@@pat) {
		my $pat = shift @@pat;	
		if ($pat =~ /^([^:]+:)(.*)\z/) { # match a volume name?
			my $vol_pat = $1;
			my $tail = $2;
			#
			# escape regex metachars but not '\' and glob chars '*', '?'
			$vol_pat =~ s:([].+^\-\${}[|]):\\$1:g;
			# and convert DOS-style wildcards to regex,
			# but only if they are not escaped
			$vol_pat =~ s/(\\*)([*?])/$1 . ('.' x ((length($1) + 1) % 2)) . $2/eg;
			#print "volume regex: '$vol_pat' \n";
				
			foreach my $volume (@@mounted_volumes) {
				if ($volume =~ m|^$vol_pat\z|ios) {
					#
					# On Mac OS, the two glob metachars '*' and '?' and the  
					# escape char '\' are valid characters for volume names. 
					# We have to escape and treat them specially.
					$volume =~ s|([*?\\])|\\$1|g;
					push @@new_pat, $volume . $tail;
				}
			}			
		} else { # no volume name in pattern, push original pattern
			push @@new_pat, $pat;
		}
	}
	return @@new_pat;
}


#
# _preprocess_pattern() will only be used on Mac OS (Classic): 
# Resolves any updirs in the pattern. Removes a single trailing colon 
# from the pattern, unless it's a volume name pattern like "*HD:"
#
sub _preprocess_pattern {
	my @@pat = @@_;
	
	foreach my $p (@@pat) {
		my $proceed;
		# resolve any updirs, e.g. "*HD:t?p::a*" -> "*HD:a*"
		do {
			$proceed = ($p =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);  
		} while ($proceed);
		# remove a single trailing colon, e.g. ":*:" -> ":*"
		$p =~ s/:([^:]+):\z/:$1/;
	}
	return @@pat;
}
		
		
#
# _un_escape() will only be used on Mac OS (Classic):
# Unescapes a list of arguments which may contain escaped 
# metachars '*', '?' and '\'.
#
sub _un_escape {
	foreach (@@_) {
		s/\\([*?\\])/$1/g;
	}
	return @@_;
}

d103 2
a104 1
    my($pat,$cxix) = @@_;
a118 46
    # Mike Mestnik: made to do abc{1,2,3} == abc1 abc2 abc3.
    #   abc3 will be the original {3} (and drop the {}).
    #   abc1 abc2 will be put in @@appendpat.
    # This was just the esiest way, not nearly the best.
    REHASH: {
	my @@appendpat = ();
	for (@@pat) {
	    # There must be a "," I.E. abc{efg} is not what we want.
	    while ( /^(.*)(?<!\\)\{(.*?)(?<!\\)\,.*?(?<!\\)\}(.*)$/ ) {
		my ($start, $match, $end) = ($1, $2, $3);
		#print "Got: \n\t$start\n\t$match\n\t$end\n";
		my $tmp = "$start$match$end";
		while ( $tmp =~ s/^(.*?)(?<!\\)\{(?:.*(?<!\\)\,)?(.*\Q$match\E.*?)(?:(?<!\\)\,.*)?(?<!\\)\}(.*)$/$1$2$3/ ) {
		    #print "Striped: $tmp\n";
		    #  these expanshions will be preformed by the original,
		    #  when we call REHASH.
		}
		push @@appendpat, ("$tmp");
		s/^\Q$start\E(?<!\\)\{\Q$match\E(?<!\\)\,/$start\{/;
		if ( /^\Q$start\E(?<!\\)\{(?!.*?(?<!\\)\,.*?\Q$end\E$)(.*)(?<!\\)\}\Q$end\E$/ ) {
		    $match = $1;
		    #print "GOT: \n\t$start\n\t$match\n\t$end\n\n";
		    $_ = "$start$match$end";
		}
	    }
	    #print "Sould have "GOT" vs "Got"!\n";
		#FIXME: There should be checking for this.
		#  How or what should be done about failure is beond me.
	}
	if ( $#appendpat != -1
		) {
	    #print "LOOP\n";
	    #FIXME: Max loop, no way! :")
	    for ( @@appendpat ) {
	        push @@pat, $_;
	    }
	    goto REHASH;
	}
    }
    for ( @@pat ) {
	s/\\{/{/g;
	s/\\}/}/g;
	s/\\,/,/g;
    }
    #print join ("\n", @@pat). "\n";
 
d125 1
a125 8
	if ($^O eq 'MacOS') {
		# first, take care of updirs and trailing colons
		@@pat = _preprocess_pattern(@@pat);
		# expand volume names
		@@pat = _expand_volume(@@pat);
		$entries{$cxix} = (@@pat) ? [_un_escape( doglob_Mac(1,@@pat) )] : [()];
	} else {
		$entries{$cxix} = [doglob(1,@@pat)];
a126 1
	}
d146 1
a146 4
{
    no strict 'refs';

    sub import {
a151 1
    }
d153 1
a201 55

=head1 NOTES

=over 4

=item *

Mac OS (Classic) users should note a few differences. The specification 
of pathnames in glob patterns adheres to the usual Mac OS conventions: 
The path separator is a colon ':', not a slash '/' or backslash '\'. A 
full path always begins with a volume name. A relative pathname on Mac 
OS must always begin with a ':', except when specifying a file or 
directory name in the current working directory, where the leading colon 
is optional. If specifying a volume name only, a trailing ':' is 
required. Due to these rules, a glob like E<lt>*:E<gt> will find all 
mounted volumes, while a glob like E<lt>*E<gt> or E<lt>:*E<gt> will find 
all files and directories in the current directory.

Note that updirs in the glob pattern are resolved before the matching begins,
i.e. a pattern like "*HD:t?p::a*" will be matched as "*HD:a*". Note also,
that a single trailing ':' in the pattern is ignored (unless it's a volume
name pattern like "*HD:"), i.e. a glob like <:*:> will find both directories 
I<and> files (and not, as one might expect, only directories). 

The metachars '*', '?' and the escape char '\' are valid characters in 
volume, directory and file names on Mac OS. Hence, if you want to match
a '*', '?' or '\' literally, you have to escape these characters. Due to 
perl's quoting rules, things may get a bit complicated, when you want to 
match a string like '\*' literally, or when you want to match '\' literally, 
but treat the immediately following character '*' as metachar. So, here's a 
rule of thumb (applies to both single- and double-quoted strings): escape 
each '*' or '?' or '\' with a backslash, if you want to treat them literally, 
and then double each backslash and your are done. E.g. 

- Match '\*' literally

   escape both '\' and '*'  : '\\\*'
   double the backslashes   : '\\\\\\*'

(Internally, the glob routine sees a '\\\*', which means that both '\' and 
'*' are escaped.)


- Match '\' literally, treat '*' as metachar

   escape '\' but not '*'   : '\\*'
   double the backslashes   : '\\\\*'

(Internally, the glob routine sees a '\\*', which means that '\' is escaped and 
'*' is not.)

Note that you also have to quote literal spaces in the glob pattern, as described
above.

=back
@


1.1.1.4
log
@import perl 5.10.1
@
text
@d12 1
a12 1
our $VERSION = '1.01';
d38 1
a38 1
	    substr($pat,0,2) = $1 . "./";
@


1.1.1.5
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d12 1
a12 1
our $VERSION = '1.06';
a18 1
    my $fix_drive_relative_paths;
a38 1
	    $fix_drive_relative_paths = 1;
d69 1
a69 1
	$pat =~ s:([].+^\-\${}()[|]):\\$1:g;
d94 110
a203 2
    if ($fix_drive_relative_paths) {
	s|^([A-Za-z]:)\./|$1| for @@retval;
d209 90
d305 1
d315 2
a316 7
    # assume global context if not provided one
    $cxix = '_G_' unless defined $cxix;

    # if we're just beginning, do it all first
    if (!$entries{$cxix}) {
      # extract patterns
      if ($pat =~ /\s/) {
d319 2
a320 2
      }
      else {
d322 1
a322 1
      }
d324 5
a328 5
      # Mike Mestnik: made to do abc{1,2,3} == abc1 abc2 abc3.
      #   abc3 will be the original {3} (and drop the {}).
      #   abc1 abc2 will be put in @@appendpat.
      # This was just the easiest way, not nearly the best.
      REHASH: {
d338 1
a338 1
		    #  these expansions will be performed by the original,
d362 2
a363 2
      }
      for ( @@pat ) {
d367 2
a368 2
      }
      #print join ("\n", @@pat). "\n";
d370 14
a383 1
      $entries{$cxix} = [doglob(1,@@pat)];
d385 1
d389 1
d393 1
a393 1
	if (scalar @@{$entries{$cxix}}) {
d398 1
d464 55
@


