head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2010.09.24.14.59.39;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.32;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.37;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.39;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.10;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.44;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.30;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.03;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.46;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.35;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.58;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package File::Path;

use 5.005_04;
use strict;

use Cwd 'getcwd';
use File::Basename ();
use File::Spec     ();

BEGIN {
    if ($] < 5.006) {
        # can't say 'opendir my $dh, $dirname'
        # need to initialise $dh
        eval "use Symbol";
    }
}

use Exporter ();
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK);
$VERSION   = '2.07_03';
@@ISA       = qw(Exporter);
@@EXPORT    = qw(mkpath rmtree);
@@EXPORT_OK = qw(make_path remove_tree);

my $Is_VMS     = $^O eq 'VMS';
my $Is_MacOS   = $^O eq 'MacOS';

# These OSes complain if you want to remove a file that you have no
# write permission to:
my $Force_Writeable = grep {$^O eq $_} qw(amigaos dos epoc MSWin32 MacOS os2);

# Unix-like systems need to stat each directory in order to detect
# race condition. MS-Windows is immune to this particular attack.
my $Need_Stat_Check = !($^O eq 'MSWin32');

sub _carp {
    require Carp;
    goto &Carp::carp;
}

sub _croak {
    require Carp;
    goto &Carp::croak;
}

sub _error {
    my $arg     = shift;
    my $message = shift;
    my $object  = shift;

    if ($arg->{error}) {
        $object = '' unless defined $object;
        $message .= ": $!" if $!;
        push @@{${$arg->{error}}}, {$object => $message};
    }
    else {
        _carp(defined($object) ? "$message for $object: $!" : "$message: $!");
    }
}

sub make_path {
    push @@_, {} unless @@_ and UNIVERSAL::isa($_[-1],'HASH');
    goto &mkpath;
}

sub mkpath {
    my $old_style = !(@@_ and UNIVERSAL::isa($_[-1],'HASH'));

    my $arg;
    my $paths;

    if ($old_style) {
        my ($verbose, $mode);
        ($paths, $verbose, $mode) = @@_;
        $paths = [$paths] unless UNIVERSAL::isa($paths,'ARRAY');
        $arg->{verbose} = $verbose;
        $arg->{mode}    = defined $mode ? $mode : 0777;
    }
    else {
        $arg = pop @@_;
        $arg->{mode}      = delete $arg->{mask} if exists $arg->{mask};
        $arg->{mode}      = 0777 unless exists $arg->{mode};
        ${$arg->{error}}  = [] if exists $arg->{error};
        $paths = [@@_];
    }
    return _mkpath($arg, $paths);
}

sub _mkpath {
    my $arg   = shift;
    my $paths = shift;

    my(@@created,$path);
    foreach $path (@@$paths) {
        next unless defined($path) and length($path);
        $path .= '/' if $^O eq 'os2' and $path =~ /^\w:\z/s; # feature of CRT 
        # Logic wants Unix paths, so go with the flow.
        if ($Is_VMS) {
            next if $path eq '/';
            $path = VMS::Filespec::unixify($path);
        }
        next if -d $path;
        my $parent = File::Basename::dirname($path);
        unless (-d $parent or $path eq $parent) {
            push(@@created,_mkpath($arg, [$parent]));
        }
        print "mkdir $path\n" if $arg->{verbose};
        if (mkdir($path,$arg->{mode})) {
            push(@@created, $path);
        }
        else {
            my $save_bang = $!;
            my ($e, $e1) = ($save_bang, $^E);
            $e .= "; $e1" if $e ne $e1;
            # allow for another process to have created it meanwhile
            if (!-d $path) {
                $! = $save_bang;
                if ($arg->{error}) {
                    push @@{${$arg->{error}}}, {$path => $e};
                }
                else {
                    _croak("mkdir $path: $e");
                }
            }
        }
    }
    return @@created;
}

sub remove_tree {
    push @@_, {} unless @@_ and UNIVERSAL::isa($_[-1],'HASH');
    goto &rmtree;
}

sub _is_subdir {
    my($dir, $test) = @@_;

    my($dv, $dd) = File::Spec->splitpath($dir, 1);
    my($tv, $td) = File::Spec->splitpath($test, 1);

    # not on same volume
    return 0 if $dv ne $tv;

    my @@d = File::Spec->splitdir($dd);
    my @@t = File::Spec->splitdir($td);

    # @@t can't be a subdir if it's shorter than @@d
    return 0 if @@t < @@d;

    return join('/', @@d) eq join('/', splice @@t, 0, +@@d);
}

sub rmtree {
    my $old_style = !(@@_ and UNIVERSAL::isa($_[-1],'HASH'));

    my $arg;
    my $paths;

    if ($old_style) {
        my ($verbose, $safe);
        ($paths, $verbose, $safe) = @@_;
        $arg->{verbose} = $verbose;
        $arg->{safe}    = defined $safe    ? $safe    : 0;

        if (defined($paths) and length($paths)) {
            $paths = [$paths] unless UNIVERSAL::isa($paths,'ARRAY');
        }
        else {
            _carp ("No root path(s) specified\n");
            return 0;
        }
    }
    else {
        $arg = pop @@_;
        ${$arg->{error}}  = [] if exists $arg->{error};
        ${$arg->{result}} = [] if exists $arg->{result};
        $paths = [@@_];
    }

    $arg->{prefix} = '';
    $arg->{depth}  = 0;

    my @@clean_path;
    $arg->{cwd} = getcwd() or do {
        _error($arg, "cannot fetch initial working directory");
        return 0;
    };
    for ($arg->{cwd}) { /\A(.*)\Z/; $_ = $1 } # untaint

    for my $p (@@$paths) {
        # need to fixup case and map \ to / on Windows
        my $ortho_root = $^O eq 'MSWin32' ? _slash_lc($p)          : $p;
        my $ortho_cwd  = $^O eq 'MSWin32' ? _slash_lc($arg->{cwd}) : $arg->{cwd};
        my $ortho_root_length = length($ortho_root);
        $ortho_root_length-- if $^O eq 'VMS'; # don't compare '.' with ']'
        if ($ortho_root_length && _is_subdir($ortho_root, $ortho_cwd)) {
            local $! = 0;
            _error($arg, "cannot remove path when cwd is $arg->{cwd}", $p);
            next;
        }

        if ($Is_MacOS) {
            $p  = ":$p" unless $p =~ /:/;
            $p .= ":"   unless $p =~ /:\z/;
        }
        elsif ($^O eq 'MSWin32') {
            $p =~ s{[/\\]\z}{};
        }
        else {
            $p =~ s{/\z}{};
        }
        push @@clean_path, $p;
    }

    @@{$arg}{qw(device inode perm)} = (lstat $arg->{cwd})[0,1] or do {
        _error($arg, "cannot stat initial working directory", $arg->{cwd});
        return 0;
    };

    return _rmtree($arg, \@@clean_path);
}

sub _rmtree {
    my $arg   = shift;
    my $paths = shift;

    my $count  = 0;
    my $curdir = File::Spec->curdir();
    my $updir  = File::Spec->updir();

    my (@@files, $root);
    ROOT_DIR:
    foreach $root (@@$paths) {
        # since we chdir into each directory, it may not be obvious
        # to figure out where we are if we generate a message about
        # a file name. We therefore construct a semi-canonical
        # filename, anchored from the directory being unlinked (as
        # opposed to being truly canonical, anchored from the root (/).

        my $canon = $arg->{prefix}
            ? File::Spec->catfile($arg->{prefix}, $root)
            : $root
        ;

        my ($ldev, $lino, $perm) = (lstat $root)[0,1,2] or next ROOT_DIR;

        if ( -d _ ) {
            $root = VMS::Filespec::pathify($root) if $Is_VMS;

            if (!chdir($root)) {
                # see if we can escalate privileges to get in
                # (e.g. funny protection mask such as -w- instead of rwx)
                $perm &= 07777;
                my $nperm = $perm | 0700;
                if (!($arg->{safe} or $nperm == $perm or chmod($nperm, $root))) {
                    _error($arg, "cannot make child directory read-write-exec", $canon);
                    next ROOT_DIR;
                }
                elsif (!chdir($root)) {
                    _error($arg, "cannot chdir to child", $canon);
                    next ROOT_DIR;
                }
            }

            my ($cur_dev, $cur_inode, $perm) = (stat $curdir)[0,1,2] or do {
                _error($arg, "cannot stat current working directory", $canon);
                next ROOT_DIR;
            };

            if ($Need_Stat_Check) {
                ($ldev eq $cur_dev and $lino eq $cur_inode)
                    or _croak("directory $canon changed before chdir, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.");
            }

            $perm &= 07777; # don't forget setuid, setgid, sticky bits
            my $nperm = $perm | 0700;

            # notabene: 0700 is for making readable in the first place,
            # it's also intended to change it to writable in case we have
            # to recurse in which case we are better than rm -rf for 
            # subtrees with strange permissions

            if (!($arg->{safe} or $nperm == $perm or chmod($nperm, $curdir))) {
                _error($arg, "cannot make directory read+writeable", $canon);
                $nperm = $perm;
            }

            my $d;
            $d = gensym() if $] < 5.006;
            if (!opendir $d, $curdir) {
                _error($arg, "cannot opendir", $canon);
                @@files = ();
            }
            else {
                no strict 'refs';
                if (!defined ${"\cTAINT"} or ${"\cTAINT"}) {
                    # Blindly untaint dir names if taint mode is
                    # active, or any perl < 5.006
                    @@files = map { /\A(.*)\z/s; $1 } readdir $d;
                }
                else {
                    @@files = readdir $d;
                }
                closedir $d;
            }

            if ($Is_VMS) {
                # Deleting large numbers of files from VMS Files-11
                # filesystems is faster if done in reverse ASCIIbetical order.
                # include '.' to '.;' from blead patch #31775
                @@files = map {$_ eq '.' ? '.;' : $_} reverse @@files;
                ($root = VMS::Filespec::unixify($root)) =~ s/\.dir\z//;
            }

            @@files = grep {$_ ne $updir and $_ ne $curdir} @@files;

            if (@@files) {
                # remove the contained files before the directory itself
                my $narg = {%$arg};
                @@{$narg}{qw(device inode cwd prefix depth)}
                    = ($cur_dev, $cur_inode, $updir, $canon, $arg->{depth}+1);
                $count += _rmtree($narg, \@@files);
            }

            # restore directory permissions of required now (in case the rmdir
            # below fails), while we are still in the directory and may do so
            # without a race via '.'
            if ($nperm != $perm and not chmod($perm, $curdir)) {
                _error($arg, "cannot reset chmod", $canon);
            }

            # don't leave the client code in an unexpected directory
            chdir($arg->{cwd})
                or _croak("cannot chdir to $arg->{cwd} from $canon: $!, aborting.");

            # ensure that a chdir upwards didn't take us somewhere other
            # than we expected (see CVE-2002-0435)
            ($cur_dev, $cur_inode) = (stat $curdir)[0,1]
                or _croak("cannot stat prior working directory $arg->{cwd}: $!, aborting.");

            if ($Need_Stat_Check) {
                ($arg->{device} eq $cur_dev and $arg->{inode} eq $cur_inode)
                    or _croak("previous directory $arg->{cwd} changed before entering $canon, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.");
            }

            if ($arg->{depth} or !$arg->{keep_root}) {
                if ($arg->{safe} &&
                    ($Is_VMS ? !&VMS::Filespec::candelete($root) : !-w $root)) {
                    print "skipped $root\n" if $arg->{verbose};
                    next ROOT_DIR;
                }
                if ($Force_Writeable and !chmod $perm | 0700, $root) {
                    _error($arg, "cannot make directory writeable", $canon);
                }
                print "rmdir $root\n" if $arg->{verbose};
                if (rmdir $root) {
                    push @@{${$arg->{result}}}, $root if $arg->{result};
                    ++$count;
                }
                else {
                    _error($arg, "cannot remove directory", $canon);
                    if ($Force_Writeable && !chmod($perm, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
                    ) {
                        _error($arg, sprintf("cannot restore permissions to 0%o",$perm), $canon);
                    }
                }
            }
        }
        else {
            # not a directory
            $root = VMS::Filespec::vmsify("./$root")
                if $Is_VMS
                   && !File::Spec->file_name_is_absolute($root)
                   && ($root !~ m/(?<!\^)[\]>]+/);  # not already in VMS syntax

            if ($arg->{safe} &&
                ($Is_VMS ? !&VMS::Filespec::candelete($root)
                         : !(-l $root || -w $root)))
            {
                print "skipped $root\n" if $arg->{verbose};
                next ROOT_DIR;
            }

            my $nperm = $perm & 07777 | 0600;
            if ($Force_Writeable and $nperm != $perm and not chmod $nperm, $root) {
                _error($arg, "cannot make file writeable", $canon);
            }
            print "unlink $canon\n" if $arg->{verbose};
            # delete all versions under VMS
            for (;;) {
                if (unlink $root) {
                    push @@{${$arg->{result}}}, $root if $arg->{result};
                }
                else {
                    _error($arg, "cannot unlink file", $canon);
                    $Force_Writeable and chmod($perm, $root) or
                        _error($arg, sprintf("cannot restore permissions to 0%o",$perm), $canon);
                    last;
                }
                ++$count;
                last unless $Is_VMS && lstat $root;
            }
        }
    }
    return $count;
}

sub _slash_lc {
    # fix up slashes and case on MSWin32 so that we can determine that
    # c:\path\to\dir is underneath C:/Path/To
    my $path = shift;
    $path =~ tr{\\}{/};
    return lc($path);
}

1;
__END__

=head1 NAME

File::Path - Create or remove directory trees

=head1 VERSION

This document describes version 2.07 of File::Path, released
2008-11-09.

=head1 SYNOPSIS

  use File::Path qw(make_path remove_tree);

  make_path('foo/bar/baz', '/zug/zwang');
  make_path('foo/bar/baz', '/zug/zwang', {
      verbose => 1,
      mode => 0711,
  });

  remove_tree('foo/bar/baz', '/zug/zwang');
  remove_tree('foo/bar/baz', '/zug/zwang', {
      verbose => 1,
      error  => \my $err_list,
  });

  # legacy (interface promoted before v2.00)
  mkpath('/foo/bar/baz');
  mkpath('/foo/bar/baz', 1, 0711);
  mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);
  rmtree('foo/bar/baz', 1, 1);
  rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);

  # legacy (interface promoted before v2.06)
  mkpath('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });
  rmtree('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });

=head1 DESCRIPTION

This module provide a convenient way to create directories of
arbitrary depth and to delete an entire directory subtree from the
filesystem.

The following functions are provided:

=over

=item make_path( $dir1, $dir2, .... )

=item make_path( $dir1, $dir2, ...., \%opts )

The C<make_path> function creates the given directories if they don't
exists before, much like the Unix command C<mkdir -p>.

The function accepts a list of directories to be created. Its
behaviour may be tuned by an optional hashref appearing as the last
parameter on the call.

The function returns the list of directories actually created during
the call; in scalar context the number of directories created.

The following keys are recognised in the option hash:

=over

=item mode => $num

The numeric permissions mode to apply to each created directory
(defaults to 0777), to be modified by the current C<umask>. If the
directory already exists (and thus does not need to be created),
the permissions will not be modified.

C<mask> is recognised as an alias for this parameter.

=item verbose => $bool

If present, will cause C<make_path> to print the name of each directory
as it is created. By default nothing is printed.

=item error => \$err

If present, it should be a reference to a scalar.
This scalar will be made to reference an array, which will
be used to store any errors that are encountered.  See the L</"ERROR
HANDLING"> section for more information.

If this parameter is not used, certain error conditions may raise
a fatal error that will cause the program will halt, unless trapped
in an C<eval> block.

=back

=item mkpath( $dir )

=item mkpath( $dir, $verbose, $mode )

=item mkpath( [$dir1, $dir2,...], $verbose, $mode )

=item mkpath( $dir1, $dir2,..., \%opt )

The mkpath() function provide the legacy interface of make_path() with
a different interpretation of the arguments passed.  The behaviour and
return value of the function is otherwise identical to make_path().

=item remove_tree( $dir1, $dir2, .... )

=item remove_tree( $dir1, $dir2, ...., \%opts )

The C<remove_tree> function deletes the given directories and any
files and subdirectories they might contain, much like the Unix
command C<rm -r> or C<del /s> on Windows.

The function accepts a list of directories to be
removed. Its behaviour may be tuned by an optional hashref
appearing as the last parameter on the call.

The functions returns the number of files successfully deleted.

The following keys are recognised in the option hash:

=over

=item verbose => $bool

If present, will cause C<remove_tree> to print the name of each file as
it is unlinked. By default nothing is printed.

=item safe => $bool

When set to a true value, will cause C<remove_tree> to skip the files
for which the process lacks the required privileges needed to delete
files, such as delete privileges on VMS. In other words, the code
will make no attempt to alter file permissions. Thus, if the process
is interrupted, no filesystem object will be left in a more
permissive mode.

=item keep_root => $bool

When set to a true value, will cause all files and subdirectories
to be removed, except the initially specified directories. This comes
in handy when cleaning out an application's scratch directory.

  remove_tree( '/tmp', {keep_root => 1} );

=item result => \$res

If present, it should be a reference to a scalar.
This scalar will be made to reference an array, which will
be used to store all files and directories unlinked
during the call. If nothing is unlinked, the array will be empty.

  remove_tree( '/tmp', {result => \my $list} );
  print "unlinked $_\n" for @@$list;

This is a useful alternative to the C<verbose> key.

=item error => \$err

If present, it should be a reference to a scalar.
This scalar will be made to reference an array, which will
be used to store any errors that are encountered.  See the L</"ERROR
HANDLING"> section for more information.

Removing things is a much more dangerous proposition than
creating things. As such, there are certain conditions that
C<remove_tree> may encounter that are so dangerous that the only
sane action left is to kill the program.

Use C<error> to trap all that is reasonable (problems with
permissions and the like), and let it die if things get out
of hand. This is the safest course of action.

=back

=item rmtree( $dir )

=item rmtree( $dir, $verbose, $safe )

=item rmtree( [$dir1, $dir2,...], $verbose, $safe )

=item rmtree( $dir1, $dir2,..., \%opt )

The rmtree() function provide the legacy interface of remove_tree()
with a different interpretation of the arguments passed. The behaviour
and return value of the function is otherwise identical to
remove_tree().

=back

=head2 ERROR HANDLING

=over 4

=item B<NOTE:>

The following error handling mechanism is considered
experimental and is subject to change pending feedback from
users.

=back

If C<make_path> or C<remove_tree> encounter an error, a diagnostic
message will be printed to C<STDERR> via C<carp> (for non-fatal
errors), or via C<croak> (for fatal errors).

If this behaviour is not desirable, the C<error> attribute may be
used to hold a reference to a variable, which will be used to store
the diagnostics. The variable is made a reference to an array of hash
references.  Each hash contain a single key/value pair where the key
is the name of the file, and the value is the error message (including
the contents of C<$!> when appropriate).  If a general error is
encountered the diagnostic key will be empty.

An example usage looks like:

  remove_tree( 'foo/bar', 'bar/rat', {error => \my $err} );
  if (@@$err) {
      for my $diag (@@$err) {
          my ($file, $message) = %$diag;
          if ($file eq '') {
              print "general error: $message\n";
          }
          else {
              print "problem unlinking $file: $message\n";
          }
      }
  }
  else {
      print "No error encountered\n";
  }

Note that if no errors are encountered, C<$err> will reference an
empty array.  This means that C<$err> will always end up TRUE; so you
need to test C<@@$err> to determine if errors occured.

=head2 NOTES

C<File::Path> blindly exports C<mkpath> and C<rmtree> into the
current namespace. These days, this is considered bad style, but
to change it now would break too much code. Nonetheless, you are
invited to specify what it is you are expecting to use:

  use File::Path 'rmtree';

The routines C<make_path> and C<remove_tree> are B<not> exported
by default. You must specify which ones you want to use.

  use File::Path 'remove_tree';

Note that a side-effect of the above is that C<mkpath> and C<rmtree>
are no longer exported at all. This is due to the way the C<Exporter>
module works. If you are migrating a codebase to use the new
interface, you will have to list everything explicitly. But that's
just good practice anyway.

  use File::Path qw(remove_tree rmtree);

=head3 SECURITY CONSIDERATIONS

There were race conditions 1.x implementations of File::Path's
C<rmtree> function (although sometimes patched depending on the OS
distribution or platform). The 2.0 version contains code to avoid the
problem mentioned in CVE-2002-0435.

See the following pages for more information:

  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=286905
  http://www.nntp.perl.org/group/perl.perl5.porters/2005/01/msg97623.html
  http://www.debian.org/security/2005/dsa-696

Additionally, unless the C<safe> parameter is set (or the
third parameter in the traditional interface is TRUE), should a
C<remove_tree> be interrupted, files that were originally in read-only
mode may now have their permissions set to a read-write (or "delete
OK") mode.

=head1 DIAGNOSTICS

FATAL errors will cause the program to halt (C<croak>), since the
problem is so severe that it would be dangerous to continue. (This
can always be trapped with C<eval>, but it's not a good idea. Under
the circumstances, dying is the best thing to do).

SEVERE errors may be trapped using the modern interface. If the
they are not trapped, or the old interface is used, such an error
will cause the program will halt.

All other errors may be trapped using the modern interface, otherwise
they will be C<carp>ed about. Program execution will not be halted.

=over 4

=item mkdir [path]: [errmsg] (SEVERE)

C<make_path> was unable to create the path. Probably some sort of
permissions error at the point of departure, or insufficient resources
(such as free inodes on Unix).

=item No root path(s) specified

C<make_path> was not given any paths to create. This message is only
emitted if the routine is called with the traditional interface.
The modern interface will remain silent if given nothing to do.

=item No such file or directory

On Windows, if C<make_path> gives you this warning, it may mean that
you have exceeded your filesystem's maximum path length.

=item cannot fetch initial working directory: [errmsg]

C<remove_tree> attempted to determine the initial directory by calling
C<Cwd::getcwd>, but the call failed for some reason. No attempt
will be made to delete anything.

=item cannot stat initial working directory: [errmsg]

C<remove_tree> attempted to stat the initial directory (after having
successfully obtained its name via C<getcwd>), however, the call
failed for some reason. No attempt will be made to delete anything.

=item cannot chdir to [dir]: [errmsg]

C<remove_tree> attempted to set the working directory in order to
begin deleting the objects therein, but was unsuccessful. This is
usually a permissions issue. The routine will continue to delete
other things, but this directory will be left intact.

=item directory [dir] changed before chdir, expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)

C<remove_tree> recorded the device and inode of a directory, and then
moved into it. It then performed a C<stat> on the current directory
and detected that the device and inode were no longer the same. As
this is at the heart of the race condition problem, the program
will die at this point.

=item cannot make directory [dir] read+writeable: [errmsg]

C<remove_tree> attempted to change the permissions on the current directory
to ensure that subsequent unlinkings would not run into problems,
but was unable to do so. The permissions remain as they were, and
the program will carry on, doing the best it can.

=item cannot read [dir]: [errmsg]

C<remove_tree> tried to read the contents of the directory in order
to acquire the names of the directory entries to be unlinked, but
was unsuccessful. This is usually a permissions issue. The
program will continue, but the files in this directory will remain
after the call.

=item cannot reset chmod [dir]: [errmsg]

C<remove_tree>, after having deleted everything in a directory, attempted
to restore its permissions to the original state but failed. The
directory may wind up being left behind.

=item cannot remove [dir] when cwd is [dir]

The current working directory of the program is F</some/path/to/here>
and you are attempting to remove an ancestor, such as F</some/path>.
The directory tree is left untouched.

The solution is to C<chdir> out of the child directory to a place
outside the directory tree to be removed.

=item cannot chdir to [parent-dir] from [child-dir]: [errmsg], aborting. (FATAL)

C<remove_tree>, after having deleted everything and restored the permissions
of a directory, was unable to chdir back to the parent. The program
halts to avoid a race condition from occurring.

=item cannot stat prior working directory [dir]: [errmsg], aborting. (FATAL)

C<remove_tree> was unable to stat the parent directory after have returned
from the child. Since there is no way of knowing if we returned to
where we think we should be (by comparing device and inode) the only
way out is to C<croak>.

=item previous directory [parent-dir] changed before entering [child-dir], expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)

When C<remove_tree> returned from deleting files in a child directory, a
check revealed that the parent directory it returned to wasn't the one
it started out from. This is considered a sign of malicious activity.

=item cannot make directory [dir] writeable: [errmsg]

Just before removing a directory (after having successfully removed
everything it contained), C<remove_tree> attempted to set the permissions
on the directory to ensure it could be removed and failed. Program
execution continues, but the directory may possibly not be deleted.

=item cannot remove directory [dir]: [errmsg]

C<remove_tree> attempted to remove a directory, but failed. This may because
some objects that were unable to be removed remain in the directory, or
a permissions issue. The directory will be left behind.

=item cannot restore permissions of [dir] to [0nnn]: [errmsg]

After having failed to remove a directory, C<remove_tree> was unable to
restore its permissions from a permissive state back to a possibly
more restrictive setting. (Permissions given in octal).

=item cannot make file [file] writeable: [errmsg]

C<remove_tree> attempted to force the permissions of a file to ensure it
could be deleted, but failed to do so. It will, however, still attempt
to unlink the file.

=item cannot unlink file [file]: [errmsg]

C<remove_tree> failed to remove a file. Probably a permissions issue.

=item cannot restore permissions of [file] to [0nnn]: [errmsg]

After having failed to remove a file, C<remove_tree> was also unable
to restore the permissions on the file to a possibly less permissive
setting. (Permissions given in octal).

=back

=head1 SEE ALSO

=over 4

=item *

L<File::Remove>

Allows files and directories to be moved to the Trashcan/Recycle
Bin (where they may later be restored if necessary) if the operating
system supports such functionality. This feature may one day be
made available directly in C<File::Path>.

=item *

L<File::Find::Rule>

When removing directory trees, if you want to examine each file to
decide whether to delete it (and possibly leaving large swathes
alone), F<File::Find::Rule> offers a convenient and flexible approach
to examining directory trees.

=back

=head1 BUGS

Please report all bugs on the RT queue:

L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=File-Path>

=head1 ACKNOWLEDGEMENTS

Paul Szabo identified the race condition originally, and Brendan
O'Dea wrote an implementation for Debian that addressed the problem.
That code was used as a basis for the current code. Their efforts
are greatly appreciated.

Gisle Aas made a number of improvements to the documentation for
2.07 and his advice and assistance is also greatly appreciated.

=head1 AUTHORS

Tim Bunce and Charles Bailey. Currently maintained by David Landgren
<F<david@@landgren.net>>.

=head1 COPYRIGHT

This module is copyright (C) Charles Bailey, Tim Bunce and
David Landgren 1995-2008. All rights reserved.

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
@


1.10
log
@Merge in perl 5.10.1
@
text
@@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d19 5
a23 4
use vars qw($VERSION @@ISA @@EXPORT);
$VERSION = '2.04';
@@ISA     = qw(Exporter);
@@EXPORT  = qw(mkpath rmtree);
d25 2
a26 2
my $Is_VMS   = $^O eq 'VMS';
my $Is_MacOS = $^O eq 'MacOS';
d32 4
d53 2
a54 1
        push @@{${$arg->{error}}}, {$object => "$message: $!"};
d61 5
d67 1
a67 8
    my $old_style = (
        UNIVERSAL::isa($_[0],'ARRAY')
        or (@@_ == 2 and (defined $_[1] ? $_[1] =~ /\A\d+\z/ : 1))
        or (@@_ == 3
            and (defined $_[1] ? $_[1] =~ /\A\d+\z/ : 1)
            and (defined $_[2] ? $_[2] =~ /\A\d+\z/ : 1)
        )
    ) ? 1 : 0;
d76 2
a77 2
        $arg->{verbose} = defined $verbose ? $verbose : 0;
        $arg->{mode}    = defined $mode    ? $mode    : 0777;
d80 4
a83 9
        if (@@_ > 0 and UNIVERSAL::isa($_[-1], 'HASH')) {
            $arg = pop @@_;
            exists $arg->{mask} and $arg->{mode} = delete $arg->{mask};
            $arg->{mode} = 0777 unless exists $arg->{mode};
            ${$arg->{error}} = [] if exists $arg->{error};
        }
        else {
            @@{$arg}{qw(verbose mode)} = (0, 0777);
        }
a92 1
    local($")=$Is_MacOS ? ":" : "/";
d95 1
a95 1
        next unless length($path);
d130 23
d154 1
a154 8
    my $old_style = (
        UNIVERSAL::isa($_[0],'ARRAY')
        or (@@_ == 2 and (defined $_[1] ? $_[1] =~ /\A\d+\z/ : 1))
        or (@@_ == 3
            and (defined $_[1] ? $_[1] =~ /\A\d+\z/ : 1)
            and (defined $_[2] ? $_[2] =~ /\A\d+\z/ : 1)
        )
    ) ? 1 : 0;
d162 1
a162 1
        $arg->{verbose} = defined $verbose ? $verbose : 0;
d174 3
a176 8
        if (@@_ > 0 and UNIVERSAL::isa($_[-1],'HASH')) {
            $arg = pop @@_;
            ${$arg->{error}}  = [] if exists $arg->{error};
            ${$arg->{result}} = [] if exists $arg->{result};
        }
        else {
            @@{$arg}{qw(verbose safe)} = (0, 0);
        }
d183 1
d190 26
a215 1
    @@{$arg}{qw(device inode)} = (stat $arg->{cwd})[0,1] or do {
d220 1
a220 1
    return _rmtree($arg, $paths);
a233 8
        if ($Is_MacOS) {
            $root  = ":$root" unless $root =~ /:/;
            $root .= ":"      unless $root =~ /:\z/;
        }
        else {
            $root =~ s{/\z}{};
        }

d249 1
d265 1
a265 1
            my ($device, $inode, $perm) = (stat $curdir)[0,1,2] or do {
d270 4
a273 2
            ($ldev eq $device and $lino eq $inode)
                or _croak("directory $canon changed before chdir, expected dev=$ldev inode=$lino, actual dev=$device ino=$inode, aborting.");
d314 1
d321 1
a321 1
                    = ($device, $inode, $updir, $canon, $arg->{depth}+1);
d338 1
a338 1
            ($device, $inode) = (stat $curdir)[0,1]
d341 4
a344 2
            ($arg->{device} eq $device and $arg->{inode} eq $inode)
                or _croak("previous directory $arg->{cwd} changed before entering $canon, expected dev=$ldev inode=$lino, actual dev=$device ino=$inode, aborting.");
d352 2
a353 4
                if (!chmod $perm | 0700, $root) {
                    if ($Force_Writeable) {
                        _error($arg, "cannot make directory writeable", $canon);
                    }
d362 1
a362 1
                    if (!chmod($perm, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
d372 1
a372 1
                if $Is_VMS 
d385 2
a386 4
            if ($nperm != $perm and not chmod $nperm, $root) {
                if ($Force_Writeable) {
                    _error($arg, "cannot make file writeable", $canon);
                }
d405 2
d408 6
a413 1
    return $count;
d425 2
a426 2
This document describes version 2.04 of File::Path, released
2007-11-13.
d430 38
a467 1
    use File::Path;
d469 2
a470 2
    # modern
    mkpath( 'foo/bar/baz', '/zug/zwang', {verbose => 1} );
d472 3
a474 8
    rmtree(
        'foo/bar/baz', '/zug/zwang',
        { verbose => 1, error  => \my $err_list }
    );

    # traditional
    mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);
    rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);
d476 2
a477 1
=head1 DESCRIPTION
d479 1
a479 28
The C<mkpath> function provides a convenient way to create directories
of arbitrary depth. Similarly, the C<rmtree> function provides a
convenient way to delete an entire directory subtree from the
filesystem, much like the Unix command C<rm -r>.

Both functions may be called in one of two ways, the traditional,
compatible with code written since the dawn of time, and modern,
that offers a more flexible and readable idiom. New code should use
the modern interface.

=head2 FUNCTIONS

The modern way of calling C<mkpath> and C<rmtree> is with a list
of directories to create, or remove, respectively, followed by an
optional hash reference containing keys to control the
function's behaviour.

=head3 C<mkpath>

The following keys are recognised as parameters to C<mkpath>.
The function returns the list of files actually created during the
call.

  my @@created = mkpath(
    qw(/tmp /flub /home/nobody),
    {verbose => 1, mode => 0750},
  );
  print "created $_\n" for @@created;
d481 1
a481 1
=over 4
d483 1
a483 1
=item mode
d492 1
a492 1
=item verbose
d494 1
a494 1
If present, will cause C<mkpath> to print the name of each directory
d497 1
a497 1
=item error
d499 4
a502 3
If present, will be interpreted as a reference to a list, and will
be used to store any errors that are encountered.  See the ERROR
HANDLING section for more information.
d510 13
a522 1
=head3 C<rmtree>
d524 15
a538 1
=over 4
d540 1
a540 1
=item verbose
d542 1
a542 1
If present, will cause C<rmtree> to print the name of each file as
d545 1
a545 1
=item safe
d547 1
a547 1
When set to a true value, will cause C<rmtree> to skip the files
d554 1
a554 1
=item keep_root
d560 1
a560 1
  rmtree( '/tmp', {keep_root => 1} );
d562 1
a562 1
=item result
d564 4
a567 4
If present, will be interpreted as a reference to a list, and will
be used to store the list of all files and directories unlinked
during the call. If nothing is unlinked, a reference to an empty
list is returned (rather than C<undef>).
d569 1
a569 1
  rmtree( '/tmp', {result => \my $list} );
d574 1
a574 1
=item error
d576 4
a579 3
If present, will be interpreted as a reference to a list,
and will be used to store any errors that are encountered.
See the ERROR HANDLING section for more information.
d583 1
a583 1
C<rmtree> may encounter that are so dangerous that the only
d592 1
a592 1
=head2 TRADITIONAL INTERFACE
d594 1
a594 18
The old interfaces of C<mkpath> and C<rmtree> take a reference to
a list of directories (to create or remove), followed by a series
of positional, numeric, modal parameters that control their behaviour.

This design made it difficult to add additional functionality, as
well as posed the problem of what to do when the calling code only
needs to set the last parameter. Even though the code doesn't care
how the initial positional parameters are set, the programmer is
forced to learn what the defaults are, and specify them.

Worse, if it turns out in the future that it would make more sense
to change the default behaviour of the first parameter (for example,
to avoid a security vulnerability), all existing code will remain
hard-wired to the wrong defaults.

Finally, a series of numeric parameters are much less self-documenting
in terms of communicating to the reader what the code is doing. Named
parameters do not have this problem.
d596 1
a596 1
In the traditional API, C<mkpath> takes three arguments:
d598 1
a598 8
=over 4

=item *

The name of the path to create, or a reference to a list of paths
to create,

=item *
d600 4
a603 7
a boolean value, which if TRUE will cause C<mkpath> to print the
name of each directory as it is created (defaults to FALSE), and

=item *

the numeric mode to use when creating the directories (defaults to
0777), to be modified by the current umask.
d607 1
a607 14
It returns a list of all directories (including intermediates, determined
using the Unix '/' separator) created.  In scalar context it returns
the number of directories created.

If a system error prevents a directory from being created, then the
C<mkpath> function throws a fatal error with C<Carp::croak>. This error
can be trapped with an C<eval> block:

  eval { mkpath($dir) };
  if ($@@) {
    print "Couldn't create $dir: $@@";
  }

In the traditional API, C<rmtree> takes three arguments:
d611 1
a611 15
=item *

the root of the subtree to delete, or a reference to a list of
roots. All of the files and directories below each root, as well
as the roots themselves, will be deleted. If you want to keep
the roots themselves, you must use the modern API.

=item *

a boolean value, which if TRUE will cause C<rmtree> to print a
message each time it examines a file, giving the name of the file,
and indicating whether it's using C<rmdir> or C<unlink> to remove
it, or that it's skipping it.  (defaults to FALSE)

=item *
d613 3
a615 5
a boolean value, which if TRUE will cause C<rmtree> to skip any
files to which you do not have delete access (if running under VMS)
or write access (if running under another OS). This will change
in the future when a criterion for 'delete permission' under OSs
other than VMS is settled.  (defaults to FALSE)
d619 3
a621 14
It returns the number of files, directories and symlinks successfully
deleted.  Symlinks are simply deleted and not followed.

Note also that the occurrence of errors in C<rmtree> using the
traditional interface can be determined I<only> by trapping diagnostic
messages using C<$SIG{__WARN__}>; it is not apparent from the return
value. (The modern interface may use the C<error> parameter to
record any problems encountered).

=head2 ERROR HANDLING

If C<mkpath> or C<rmtree> encounter an error, a diagnostic message
will be printed to C<STDERR> via C<carp> (for non-fatal errors),
or via C<croak> (for fatal errors).
d625 22
a646 9
the diagnostics. The result is a reference to a list of hash
references. For each hash reference, the key is the name of the
file, and the value is the error message (usually the contents of
C<$!>). An example usage looks like:

  rmpath( 'foo/bar', 'bar/rat', {error => \my $err} );
  for my $diag (@@$err) {
    my ($file, $message) = each %$diag;
    print "problem unlinking $file: $message\n";
d649 3
a651 13
If no errors are encountered, C<$err> will point to an empty list
(thus there is no need to test for C<undef>). If a general error
is encountered (for instance, C<rmtree> attempts to remove a directory
tree that does not exist), the diagnostic key will be empty, only
the value will be set:

  rmpath( '/no/such/path', {error => \my $err} );
  for my $diag (@@$err) {
    my ($file, $message) = each %$diag;
    if ($file eq '') {
      print "general error: $message\n";
    }
  }
d662 2
a663 18
=head3 HEURISTICS

The functions detect (as far as possible) which way they are being
called and will act appropriately. It is important to remember that
the heuristic for detecting the old style is either the presence
of an array reference, or two or three parameters total and second
and third parameters are numeric. Hence...

    mkpath 486, 487, 488;

... will not assume the modern style and create three directories, rather
it will create one directory verbosely, setting the permission to
0750 (488 being the decimal equivalent of octal 750). Here, old
style trumps new. It must, for backwards compatibility reasons.

If you want to ensure there is absolutely no ambiguity about which
way the function will behave, make sure the first parameter is a
reference to a one-element list, to force the old style interpretation:
d665 1
a665 1
    mkpath [486], 487, 488;
d667 5
a671 2
and get only one directory created. Or add a reference to an empty
parameter hash, to force the new style:
d673 1
a673 8
    mkpath 486, 487, 488, {};

... and hence create the three directories. If the empty hash
reference seems a little strange to your eyes, or you suspect a
subsequent programmer might I<helpfully> optimise it away, you
can add a parameter set to a default value:

    mkpath 486, 487, 488, {verbose => 0};
d690 1
a690 1
C<rmtree> be interrupted, files that were originally in read-only
d712 1
a712 1
C<mkpath> was unable to create the path. Probably some sort of
d718 1
a718 1
C<mkpath> was not given any paths to create. This message is only
d724 1
a724 1
On Windows, if C<mkpath> gives you this warning, it may mean that
d729 1
a729 1
C<rmtree> attempted to determine the initial directory by calling
d735 1
a735 1
C<rmtree> attempted to stat the initial directory (after having
d741 1
a741 1
C<rmtree> attempted to set the working directory in order to
d746 1
a746 1
=item directory [dir] changed before chdir, expected dev=[n] inode=[n], actual dev=[n] ino=[n], aborting. (FATAL)
d748 1
a748 1
C<rmtree> recorded the device and inode of a directory, and then
d756 1
a756 1
C<rmtree> attempted to change the permissions on the current directory
d763 1
a763 1
C<rmtree> tried to read the contents of the directory in order
d771 1
a771 1
C<rmtree>, after having deleted everything in a directory, attempted
d775 9
d786 3
a788 3
C<rmtree>, after having deleted everything and restored the permissions
of a directory, was unable to chdir back to the parent. This is usually
a sign that something evil this way comes.
d792 1
a792 1
C<rmtree> was unable to stat the parent directory after have returned
d797 1
a797 1
=item previous directory [parent-dir] changed before entering [child-dir], expected dev=[n] inode=[n], actual dev=[n] ino=[n], aborting. (FATAL)
d799 1
a799 1
When C<rmtree> returned from deleting files in a child directory, a
d806 1
a806 1
everything it contained), C<rmtree> attempted to set the permissions
d812 1
a812 1
C<rmtree> attempted to remove a directory, but failed. This may because
d818 1
a818 1
After having failed to remove a directory, C<rmtree> was unable to
d824 1
a824 1
C<rmtree> attempted to force the permissions of a file to ensure it
d830 1
a830 1
C<rmtree> failed to remove a file. Probably a permissions issue.
d834 1
a834 1
After having failed to remove a file, C<rmtree> was also unable
d877 3
d882 1
a882 2
Tim Bunce <F<Tim.Bunce@@ig.co.uk>> and Charles Bailey
<F<bailey@@newman.upenn.edu>>. Currently maintained by David Landgren
d888 1
a888 1
David Landgren 1995-2007.  All rights reserved.
@


1.8
log
@merge in perl 5.8.8
@
text
@d3 380
d385 6
a390 1
File::Path - create or remove directory trees
d396 9
d410 134
a543 3
The C<mkpath> function provides a convenient way to create directories, even
if your C<mkdir> kernel call won't create more than one level of directory at
a time.  C<mkpath> takes three arguments:
d549 2
a550 2
the name of the path to create, or a reference
to a list of paths to create,
d554 2
a555 3
a boolean value, which if TRUE will cause C<mkpath>
to print the name of each directory as it is created
(defaults to FALSE), and
d559 2
a560 2
the numeric mode to use when creating the directories
(defaults to 0777), to be modified by the current umask.
d565 2
a566 1
using the Unix '/' separator) created.
d577 1
a577 3
Similarly, the C<rmtree> function provides a convenient way to delete a
subtree from the directory structure, much like the Unix command C<rm -r>.
C<rmtree> takes three arguments:
d583 4
a586 4
the root of the subtree to delete, or a reference to
a list of roots.  All of the files and directories
below each root, as well as the roots themselves,
will be deleted.
d590 4
a593 5
a boolean value, which if TRUE will cause C<rmtree> to
print a message each time it examines a file, giving the
name of the file, and indicating whether it's using C<rmdir>
or C<unlink> to remove it, or that it's skipping it.
(defaults to FALSE)
d597 5
a601 6
a boolean value, which if TRUE will cause C<rmtree> to
skip any files to which you do not have delete access
(if running under VMS) or write access (if running
under another OS).  This will change in the future when
a criterion for 'delete permission' under OSs other
than VMS is settled.  (defaults to FALSE)
d605 74
a678 2
It returns the number of files successfully deleted.  Symlinks are
simply deleted and not followed.
d680 27
a706 14
B<NOTE:> There are race conditions internal to the implementation of
C<rmtree> making it unsafe to use on directory trees which may be
altered or moved while C<rmtree> is running, and in particular on any
directory trees with any path components or subdirectories potentially
writable by untrusted users.

Additionally, if the third parameter is not TRUE and C<rmtree> is
interrupted, it may leave files and directories with permissions altered
to allow deletion (and older versions of this module would even set
files and directories to world-read/writable!)

Note also that the occurrence of errors in C<rmtree> can be determined I<only>
by trapping diagnostic messages using C<$SIG{__WARN__}>; it is not apparent
from the return value.
d710 137
d851 15
a865 3
On Windows, if C<mkpath> gives you the warning: B<No such file or
directory>, this may mean that you've exceeded your filesystem's
maximum path length.
d869 1
a869 4
=head1 AUTHORS

Tim Bunce <F<Tim.Bunce@@ig.co.uk>> and
Charles Bailey <F<bailey@@newman.upenn.edu>>
d871 1
a871 1
=cut
d873 1
a873 6
use 5.006;
use Carp;
use File::Basename ();
use Exporter ();
use strict;
use warnings;
d875 1
a875 3
our $VERSION = "1.08";
our @@ISA = qw( Exporter );
our @@EXPORT = qw( mkpath rmtree );
d877 4
a880 2
my $Is_VMS = $^O eq 'VMS';
my $Is_MacOS = $^O eq 'MacOS';
d882 1
a882 4
# These OSes complain if you want to remove a file that you have no
# write permission to:
my $force_writeable = ($^O eq 'os2' || $^O eq 'dos' || $^O eq 'MSWin32' ||
		       $^O eq 'amigaos' || $^O eq 'MacOS' || $^O eq 'epoc');
d884 3
a886 34
sub mkpath {
    my($paths, $verbose, $mode) = @@_;
    # $paths   -- either a path string or ref to list of paths
    # $verbose -- optional print "mkdir $path" for each directory created
    # $mode    -- optional permissions, defaults to 0777
    local($")=$Is_MacOS ? ":" : "/";
    $mode = 0777 unless defined($mode);
    $paths = [$paths] unless ref $paths;
    my(@@created,$path);
    foreach $path (@@$paths) {
	$path .= '/' if $^O eq 'os2' and $path =~ /^\w:\z/s; # feature of CRT 
	# Logic wants Unix paths, so go with the flow.
	if ($Is_VMS) {
	    next if $path eq '/';
	    $path = VMS::Filespec::unixify($path);
	    if ($path =~ m:^(/[^/]+)/?\z:) {
	        $path = $1.'/000000';
	    }
	}
	next if -d $path;
	my $parent = File::Basename::dirname($path);
	unless (-d $parent or $path eq $parent) {
	    push(@@created,mkpath($parent, $verbose, $mode));
 	}
	print "mkdir $path\n" if $verbose;
	unless (mkdir($path,$mode)) {
	    my $e = $!;
	    # allow for another process to have created it meanwhile
	    $! = $e, croak ("mkdir $path: $e") unless -d $path;
	}
	push(@@created, $path);
    }
    @@created;
}
d888 1
a888 6
sub rmtree {
    my($roots, $verbose, $safe) = @@_;
    my(@@files);
    my($count) = 0;
    $verbose ||= 0;
    $safe ||= 0;
d890 2
a891 7
    if ( defined($roots) && length($roots) ) {
      $roots = [$roots] unless ref $roots;
    }
    else {
      carp "No root path(s) specified\n";
      return 0;
    }
d893 1
a893 91
    my($root);
    foreach $root (@@{$roots}) {
    	if ($Is_MacOS) {
	    $root = ":$root" if $root !~ /:/;
	    $root =~ s#([^:])\z#$1:#;
	} else {
	    $root =~ s#/\z##;
	}
	(undef, undef, my $rp) = lstat $root or next;
	$rp &= 07777;	# don't forget setuid, setgid, sticky bits
	if ( -d _ ) {
	    # notabene: 0700 is for making readable in the first place,
	    # it's also intended to change it to writable in case we have
	    # to recurse in which case we are better than rm -rf for 
	    # subtrees with strange permissions
	    chmod($rp | 0700, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
	      or carp "Can't make directory $root read+writeable: $!"
		unless $safe;

	    if (opendir my $d, $root) {
		no strict 'refs';
		if (!defined ${"\cTAINT"} or ${"\cTAINT"}) {
		    # Blindly untaint dir names
		    @@files = map { /^(.*)$/s ; $1 } readdir $d;
		} else {
		    @@files = readdir $d;
		}
		closedir $d;
	    }
	    else {
	        carp "Can't read $root: $!";
		@@files = ();
	    }

	    # Deleting large numbers of files from VMS Files-11 filesystems
	    # is faster if done in reverse ASCIIbetical order 
	    @@files = reverse @@files if $Is_VMS;
	    ($root = VMS::Filespec::unixify($root)) =~ s#\.dir\z## if $Is_VMS;
	    if ($Is_MacOS) {
		@@files = map("$root$_", @@files);
	    } else {
		@@files = map("$root/$_", grep $_!~/^\.{1,2}\z/s,@@files);
	    }
	    $count += rmtree(\@@files,$verbose,$safe);
	    if ($safe &&
		($Is_VMS ? !&VMS::Filespec::candelete($root) : !-w $root)) {
		print "skipped $root\n" if $verbose;
		next;
	    }
	    chmod $rp | 0700, $root
	      or carp "Can't make directory $root writeable: $!"
		if $force_writeable;
	    print "rmdir $root\n" if $verbose;
	    if (rmdir $root) {
		++$count;
	    }
	    else {
		carp "Can't remove directory $root: $!";
		chmod($rp, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
		    or carp("and can't restore permissions to "
		            . sprintf("0%o",$rp) . "\n");
	    }
	}
	else { 
	    if ($safe &&
		($Is_VMS ? !&VMS::Filespec::candelete($root)
		         : !(-l $root || -w $root)))
	    {
		print "skipped $root\n" if $verbose;
		next;
	    }
	    chmod $rp | 0600, $root
	      or carp "Can't make file $root writeable: $!"
		if $force_writeable;
	    print "unlink $root\n" if $verbose;
	    # delete all versions under VMS
	    for (;;) {
		unless (unlink $root) {
		    carp "Can't unlink file $root: $!";
		    if ($force_writeable) {
			chmod $rp, $root
			    or carp("and can't restore permissions to "
			            . sprintf("0%o",$rp) . "\n");
		    }
		    last;
		}
		++$count;
		last unless $Is_VMS && lstat $root;
	    }
	}
    }
d895 2
a896 2
    $count;
}
d898 1
a898 1
1;
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d36 1
a36 1
(defaults to 0777)
d87 14
a100 8
B<NOTE:> If the third parameter is not TRUE, C<rmtree> is B<unsecure>
in the face of failure or interruption.  Files and directories which
were not deleted may be left with permissions reset to allow world
read and write access.  Note also that the occurrence of errors in
rmtree can be determined I<only> by trapping diagnostic messages
using C<$SIG{__WARN__}>; it is not apparent from the return value.
Therefore, you must be extremely careful about using C<rmtree($foo,$bar,0)>
in situations where security is an issue.
d128 1
a128 1
our $VERSION = "1.06";
d168 1
a168 1
	    croak "mkdir $path: $e" unless -d $path;
d201 1
a201 1
	    # notabene: 0777 is for making readable in the first place,
d205 1
a205 1
	    chmod(0777, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
d239 1
a239 1
	    chmod 0777, $root
d261 1
a261 1
	    chmod 0666, $root
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d93 1
a93 1
Therefore, you must be extremely careful about using C<rmtree($foo,$bar,0>
d96 12
d122 1
a122 1
our $VERSION = "1.05";
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d43 9
d103 1
a103 1
use 5.005_64;
d108 1
d110 1
a110 1
our $VERSION = "1.0404";
d192 7
a198 1
		@@files = readdir $d;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d100 1
a100 1
our $VERSION = "1.0403";
d105 1
d109 2
a110 2
my $force_writeable = ($^O eq 'os2' || $^O eq 'dos' || $^O eq 'MSWin32'
		       || $^O eq 'amigaos');
d117 1
a117 1
    local($")="/";
a122 1
	next if -d $path;
d124 5
a128 6
	$path = VMS::Filespec::unixify($path) if $Is_VMS;
	my $parent = File::Basename::dirname($path);
	# Allow for creation of new logical filesystems under VMS
	if (not $Is_VMS or $parent !~ m:/[^/]+/000000/?:) {
	    unless (-d $parent or $path eq $parent) {
		push(@@created,mkpath($parent, $verbose, $mode));
d131 5
d164 6
a169 1
	$root =~ s#/\z##;
d194 5
a198 1
	    @@files = map("$root/$_", grep $_!~/^\.{1,2}\z/s,@@files);
@


1.3
log
@perl5.005_03 (stock)
@
text
@d5 1
a5 1
File::Path - create or remove a series of directories
d9 1
a9 1
C<use File::Path>
d11 2
a12 3
C<mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);>

C<rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);>
d76 1
a76 1
treated as ordinary files.
a91 4
=head1 REVISION

Current $VERSION is 1.0401.

d94 1
a96 1
use DirHandle ();
d100 3
a102 4
use vars qw( $VERSION @@ISA @@EXPORT );
$VERSION = "1.0401";
@@ISA = qw( Exporter );
@@EXPORT = qw( mkpath rmtree );
d121 1
a121 1
	$path .= '/' if $^O eq 'os2' and $path =~ /^\w:$/; # feature of CRT 
d128 3
a130 1
	    push(@@created,mkpath($parent, $verbose, $mode)) unless (-d $parent);
d134 3
a136 3
	  my $e = $!;
	  # allow for another process to have created it meanwhile
	  croak "mkdir $path: $e" unless -d $path;
a146 1
    $roots = [$roots] unless ref $roots;
d150 8
d160 1
a160 1
	$root =~ s#/$##;
d172 8
a179 4
	    my $d = DirHandle->new($root)
	      or carp "Can't read $root: $!";
	    @@files = $d->read;
	    $d->close;
d184 2
a185 2
	    ($root = VMS::Filespec::unixify($root)) =~ s#\.dir$## if $Is_VMS;
	    @@files = map("$root/$_", grep $_!~/^\.{1,2}$/,@@files);
d208 3
a210 1
		($Is_VMS ? !&VMS::Filespec::candelete($root) : !-w $root)) {
@


1.2
log
@perl 5.004_04
@
text
@d91 1
a91 1
Charles Bailey <F<bailey@@genetics.upenn.edu>>
d95 1
a95 1
Current $VERSION is 1.04.
d106 1
a106 1
$VERSION = "1.04";
d114 1
a114 1
my $force_writeable = ($^O eq 'os2' || $^O eq 'msdos' || $^O eq 'MSWin32'
d127 1
d132 4
a135 1
	push(@@created,mkpath($parent, $verbose, $mode)) unless (-d $parent);
d138 3
a140 2
	    # allow for another process to have created it meanwhile
	    croak "mkdir $path: $!" unless -d $path;
d210 2
a211 5
	    while (-e $root || -l $root) {
		if (unlink $root) {
		    ++$count;
		}
		else {
d218 1
d220 2
@


1.1
log
@Initial revision
@
text
@d17 3
a19 3
The C<mkpath> function provides a convenient way to create directories, even if
your C<mkdir> kernel call won't create more than one level of directory at a
time.  C<mkpath> takes three arguments:
d41 2
a42 2
It returns a list of all directories (including intermediates, determined using
the Unix '/' separator) created.
d72 1
a72 1
than VMS is settled. (defaults to FALSE)
d76 1
a76 1
It returns the number of files successfully deleted. Symlinks are
d79 9
d90 2
a91 2
Tim Bunce <Tim.Bunce@@ig.co.uk>
Charles Bailey <bailey@@genetics.upenn.edu>
d95 1
a95 2
This module was last revised 14-Feb-1996, for perl 5.002. $VERSION is
1.01.
d99 5
a103 1
$VERSION = "1.01"; # That's my hobby-horse, A.K.
d105 2
a106 3
require 5.000;
use Carp;
require Exporter;
d110 6
a115 1
$Is_VMS = $^O eq 'VMS';
d125 13
a137 11
    my(@@created);
    foreach $path (@@$paths){
        next if -d $path;
        my(@@p);
        foreach(split(/\//, $path)){
            push(@@p, $_);
            next if -d "@@p/";
            print "mkdir @@p\n" if $verbose;
	    mkdir("@@p",$mode) || croak "mkdir @@p: $!";
            push(@@created, "@@p");
        }
d147 2
d150 1
d152 67
a218 27
       $root =~ s#/$##;
       if (not -l $root and -d _) { 
           opendir(D,$root);
           ($root = VMS::Filespec::unixify($root)) =~ s#\.dir$## if $Is_VMS;
           @@files = map("$root/$_", grep $_!~/^\.{1,2}$/, readdir(D));
           closedir(D);
           $count += rmtree(\@@files,$verbose,$safe);
           if ($safe &&
               ($Is_VMS ? !&VMS::Filespec::candelete($root) : !-w $root)) {
               print "skipped $root\n" if $verbose;
               next;
           }
           print "rmdir $root\n" if $verbose;
           (rmdir $root && ++$count) or carp "Can't remove directory $root: $!";
        }
        else { 
           if ($safe &&
               ($Is_VMS ? !&VMS::Filespec::candelete($root) : !-w $root)) {
               print "skipped $root\n" if $verbose;
               next;
           }
           print "unlink $root\n" if $verbose;
           while (-e $root || -l $root) { # delete all versions under VMS
               (unlink($root) && ++$count)
                   or carp "Can't unlink file $root: $!";
           }
        }
a224 2

__END__
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d17 3
a19 3
The C<mkpath> function provides a convenient way to create directories, even
if your C<mkdir> kernel call won't create more than one level of directory at
a time.  C<mkpath> takes three arguments:
d41 2
a42 2
It returns a list of all directories (including intermediates, determined
using the Unix '/' separator) created.
d72 1
a72 1
than VMS is settled.  (defaults to FALSE)
d76 1
a76 1
It returns the number of files successfully deleted.  Symlinks are
a78 9
B<NOTE:> If the third parameter is not TRUE, C<rmtree> is B<unsecure>
in the face of failure or interruption.  Files and directories which
were not deleted may be left with permissions reset to allow world
read and write access.  Note also that the occurrence of errors in
rmtree can be determined I<only> by trapping diagnostic messages
using C<$SIG{__WARN__}>; it is not apparent from the return value.
Therefore, you must be extremely careful about using C<rmtree($foo,$bar,0>
in situations where security is an issue.

d81 2
a82 2
Tim Bunce <F<Tim.Bunce@@ig.co.uk>> and
Charles Bailey <F<bailey@@newman.upenn.edu>>
d86 2
a87 1
Current $VERSION is 1.0401.
d91 3
d95 1
a95 7
use File::Basename ();
use DirHandle ();
use Exporter ();
use strict;

use vars qw( $VERSION @@ISA @@EXPORT );
$VERSION = "1.0401";
d99 1
a99 6
my $Is_VMS = $^O eq 'VMS';

# These OSes complain if you want to remove a file that you have no
# write permission to:
my $force_writeable = ($^O eq 'os2' || $^O eq 'dos' || $^O eq 'MSWin32'
		       || $^O eq 'amigaos');
d109 11
a119 18
    my(@@created,$path);
    foreach $path (@@$paths) {
	$path .= '/' if $^O eq 'os2' and $path =~ /^\w:$/; # feature of CRT 
	next if -d $path;
	# Logic wants Unix paths, so go with the flow.
	$path = VMS::Filespec::unixify($path) if $Is_VMS;
	my $parent = File::Basename::dirname($path);
	# Allow for creation of new logical filesystems under VMS
	if (not $Is_VMS or $parent !~ m:/[^/]+/000000/?:) {
	    push(@@created,mkpath($parent, $verbose, $mode)) unless (-d $parent);
	}
	print "mkdir $path\n" if $verbose;
	unless (mkdir($path,$mode)) {
	  my $e = $!;
	  # allow for another process to have created it meanwhile
	  croak "mkdir $path: $e" unless -d $path;
	}
	push(@@created, $path);
a128 2
    $verbose ||= 0;
    $safe ||= 0;
a129 1
    my($root);
d131 27
a157 67
	$root =~ s#/$##;
	(undef, undef, my $rp) = lstat $root or next;
	$rp &= 07777;	# don't forget setuid, setgid, sticky bits
	if ( -d _ ) {
	    # notabene: 0777 is for making readable in the first place,
	    # it's also intended to change it to writable in case we have
	    # to recurse in which case we are better than rm -rf for 
	    # subtrees with strange permissions
	    chmod(0777, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
	      or carp "Can't make directory $root read+writeable: $!"
		unless $safe;

	    my $d = DirHandle->new($root)
	      or carp "Can't read $root: $!";
	    @@files = $d->read;
	    $d->close;

	    # Deleting large numbers of files from VMS Files-11 filesystems
	    # is faster if done in reverse ASCIIbetical order 
	    @@files = reverse @@files if $Is_VMS;
	    ($root = VMS::Filespec::unixify($root)) =~ s#\.dir$## if $Is_VMS;
	    @@files = map("$root/$_", grep $_!~/^\.{1,2}$/,@@files);
	    $count += rmtree(\@@files,$verbose,$safe);
	    if ($safe &&
		($Is_VMS ? !&VMS::Filespec::candelete($root) : !-w $root)) {
		print "skipped $root\n" if $verbose;
		next;
	    }
	    chmod 0777, $root
	      or carp "Can't make directory $root writeable: $!"
		if $force_writeable;
	    print "rmdir $root\n" if $verbose;
	    if (rmdir $root) {
		++$count;
	    }
	    else {
		carp "Can't remove directory $root: $!";
		chmod($rp, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
		    or carp("and can't restore permissions to "
		            . sprintf("0%o",$rp) . "\n");
	    }
	}
	else { 
	    if ($safe &&
		($Is_VMS ? !&VMS::Filespec::candelete($root) : !-w $root)) {
		print "skipped $root\n" if $verbose;
		next;
	    }
	    chmod 0666, $root
	      or carp "Can't make file $root writeable: $!"
		if $force_writeable;
	    print "unlink $root\n" if $verbose;
	    # delete all versions under VMS
	    for (;;) {
		unless (unlink $root) {
		    carp "Can't unlink file $root: $!";
		    if ($force_writeable) {
			chmod $rp, $root
			    or carp("and can't restore permissions to "
			            . sprintf("0%o",$rp) . "\n");
		    }
		    last;
		}
		++$count;
		last unless $Is_VMS && lstat $root;
	    }
	}
d164 2
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d5 1
a5 1
File::Path - create or remove directory trees
d9 1
a9 1
    use File::Path;
d11 3
a13 2
    mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);
    rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);
d77 1
a77 1
simply deleted and not followed.
d93 4
a98 1
use 5.005_64;
d101 1
d105 4
a108 3
our $VERSION = "1.0403";
our @@ISA = qw( Exporter );
our @@EXPORT = qw( mkpath rmtree );
d127 1
a127 1
	$path .= '/' if $^O eq 'os2' and $path =~ /^\w:\z/s; # feature of CRT 
d134 1
a134 3
	    unless (-d $parent or $path eq $parent) {
		push(@@created,mkpath($parent, $verbose, $mode));
	    }
d138 3
a140 3
	    my $e = $!;
	    # allow for another process to have created it meanwhile
	    croak "mkdir $path: $e" unless -d $path;
d151 1
a154 8
    if ( defined($roots) && length($roots) ) {
      $roots = [$roots] unless ref $roots;
    }
    else {
      carp "No root path(s) specified\n";
      return 0;
    }

d157 1
a157 1
	$root =~ s#/\z##;
d169 4
a172 8
	    if (opendir my $d, $root) {
		@@files = readdir $d;
		closedir $d;
	    }
	    else {
	        carp "Can't read $root: $!";
		@@files = ();
	    }
d177 2
a178 2
	    ($root = VMS::Filespec::unixify($root)) =~ s#\.dir\z## if $Is_VMS;
	    @@files = map("$root/$_", grep $_!~/^\.{1,2}\z/s,@@files);
d201 1
a201 3
		($Is_VMS ? !&VMS::Filespec::candelete($root)
		         : !(-l $root || -w $root)))
	    {
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d100 1
a100 1
our $VERSION = "1.0404";
a104 1
my $Is_MacOS = $^O eq 'MacOS';
d108 2
a109 2
my $force_writeable = ($^O eq 'os2' || $^O eq 'dos' || $^O eq 'MSWin32' ||
		       $^O eq 'amigaos' || $^O eq 'MacOS' || $^O eq 'epoc');
d116 1
a116 1
    local($")=$Is_MacOS ? ":" : "/";
d122 1
d124 6
a129 5
	if ($Is_VMS) {
	    next if $path eq '/';
	    $path = VMS::Filespec::unixify($path);
	    if ($path =~ m:^(/[^/]+)/?\z:) {
	        $path = $1.'/000000';
a131 5
	next if -d $path;
	my $parent = File::Basename::dirname($path);
	unless (-d $parent or $path eq $parent) {
	    push(@@created,mkpath($parent, $verbose, $mode));
 	}
d160 1
a160 6
    	if ($Is_MacOS) {
	    $root = ":$root" if $root !~ /:/;
	    $root =~ s#([^:])\z#$1:#;
	} else {
	    $root =~ s#/\z##;
	}
d185 1
a185 5
	    if ($Is_MacOS) {
		@@files = map("$root$_", @@files);
	    } else {
		@@files = map("$root/$_", grep $_!~/^\.{1,2}\z/s,@@files);
	    }
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a42 9
If a system error prevents a directory from being created, then the
C<mkpath> function throws a fatal error with C<Carp::croak>. This error
can be trapped with an C<eval> block:

  eval { mkpath($dir) };
  if ($@@) {
    print "Couldn't create $dir: $@@";
  }

d94 1
a94 1
use 5.006;
a98 1
use warnings;
d100 1
a100 1
our $VERSION = "1.05";
d182 1
a182 7
		no strict 'refs';
		if (!defined ${"\cTAINT"} or ${"\cTAINT"}) {
		    # Blindly untaint dir names
		    @@files = map { /^(.*)$/s ; $1 } readdir $d;
		} else {
		    @@files = readdir $d;
		}
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d93 1
a93 1
Therefore, you must be extremely careful about using C<rmtree($foo,$bar,0)>
a95 12
=head1 DIAGNOSTICS

=over 4

=item *

On Windows, if C<mkpath> gives you the warning: B<No such file or
directory>, this may mean that you've exceeded your filesystem's
maximum path length.

=back

d110 1
a110 1
our $VERSION = "1.06";
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d36 1
a36 1
(defaults to 0777), to be modified by the current umask.
d87 8
a94 14
B<NOTE:> There are race conditions internal to the implementation of
C<rmtree> making it unsafe to use on directory trees which may be
altered or moved while C<rmtree> is running, and in particular on any
directory trees with any path components or subdirectories potentially
writable by untrusted users.

Additionally, if the third parameter is not TRUE and C<rmtree> is
interrupted, it may leave files and directories with permissions altered
to allow deletion (and older versions of this module would even set
files and directories to world-read/writable!)

Note also that the occurrence of errors in C<rmtree> can be determined I<only>
by trapping diagnostic messages using C<$SIG{__WARN__}>; it is not apparent
from the return value.
d122 1
a122 1
our $VERSION = "1.08";
d162 1
a162 1
	    $! = $e, croak ("mkdir $path: $e") unless -d $path;
d195 1
a195 1
	    # notabene: 0700 is for making readable in the first place,
d199 1
a199 1
	    chmod($rp | 0700, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
d233 1
a233 1
	    chmod $rp | 0700, $root
d255 1
a255 1
	    chmod $rp | 0600, $root
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a2 380
use 5.005_04;
use strict;

use Cwd 'getcwd';
use File::Basename ();
use File::Spec     ();

BEGIN {
    if ($] < 5.006) {
        # can't say 'opendir my $dh, $dirname'
        # need to initialise $dh
        eval "use Symbol";
    }
}

use Exporter ();
use vars qw($VERSION @@ISA @@EXPORT);
$VERSION = '2.04';
@@ISA     = qw(Exporter);
@@EXPORT  = qw(mkpath rmtree);

my $Is_VMS   = $^O eq 'VMS';
my $Is_MacOS = $^O eq 'MacOS';

# These OSes complain if you want to remove a file that you have no
# write permission to:
my $Force_Writeable = grep {$^O eq $_} qw(amigaos dos epoc MSWin32 MacOS os2);

sub _carp {
    require Carp;
    goto &Carp::carp;
}

sub _croak {
    require Carp;
    goto &Carp::croak;
}

sub _error {
    my $arg     = shift;
    my $message = shift;
    my $object  = shift;

    if ($arg->{error}) {
        $object = '' unless defined $object;
        push @@{${$arg->{error}}}, {$object => "$message: $!"};
    }
    else {
        _carp(defined($object) ? "$message for $object: $!" : "$message: $!");
    }
}

sub mkpath {
    my $old_style = (
        UNIVERSAL::isa($_[0],'ARRAY')
        or (@@_ == 2 and (defined $_[1] ? $_[1] =~ /\A\d+\z/ : 1))
        or (@@_ == 3
            and (defined $_[1] ? $_[1] =~ /\A\d+\z/ : 1)
            and (defined $_[2] ? $_[2] =~ /\A\d+\z/ : 1)
        )
    ) ? 1 : 0;

    my $arg;
    my $paths;

    if ($old_style) {
        my ($verbose, $mode);
        ($paths, $verbose, $mode) = @@_;
        $paths = [$paths] unless UNIVERSAL::isa($paths,'ARRAY');
        $arg->{verbose} = defined $verbose ? $verbose : 0;
        $arg->{mode}    = defined $mode    ? $mode    : 0777;
    }
    else {
        if (@@_ > 0 and UNIVERSAL::isa($_[-1], 'HASH')) {
            $arg = pop @@_;
            exists $arg->{mask} and $arg->{mode} = delete $arg->{mask};
            $arg->{mode} = 0777 unless exists $arg->{mode};
            ${$arg->{error}} = [] if exists $arg->{error};
        }
        else {
            @@{$arg}{qw(verbose mode)} = (0, 0777);
        }
        $paths = [@@_];
    }
    return _mkpath($arg, $paths);
}

sub _mkpath {
    my $arg   = shift;
    my $paths = shift;

    local($")=$Is_MacOS ? ":" : "/";
    my(@@created,$path);
    foreach $path (@@$paths) {
        next unless length($path);
        $path .= '/' if $^O eq 'os2' and $path =~ /^\w:\z/s; # feature of CRT 
        # Logic wants Unix paths, so go with the flow.
        if ($Is_VMS) {
            next if $path eq '/';
            $path = VMS::Filespec::unixify($path);
        }
        next if -d $path;
        my $parent = File::Basename::dirname($path);
        unless (-d $parent or $path eq $parent) {
            push(@@created,_mkpath($arg, [$parent]));
        }
        print "mkdir $path\n" if $arg->{verbose};
        if (mkdir($path,$arg->{mode})) {
            push(@@created, $path);
        }
        else {
            my $save_bang = $!;
            my ($e, $e1) = ($save_bang, $^E);
            $e .= "; $e1" if $e ne $e1;
            # allow for another process to have created it meanwhile
            if (!-d $path) {
                $! = $save_bang;
                if ($arg->{error}) {
                    push @@{${$arg->{error}}}, {$path => $e};
                }
                else {
                    _croak("mkdir $path: $e");
                }
            }
        }
    }
    return @@created;
}

sub rmtree {
    my $old_style = (
        UNIVERSAL::isa($_[0],'ARRAY')
        or (@@_ == 2 and (defined $_[1] ? $_[1] =~ /\A\d+\z/ : 1))
        or (@@_ == 3
            and (defined $_[1] ? $_[1] =~ /\A\d+\z/ : 1)
            and (defined $_[2] ? $_[2] =~ /\A\d+\z/ : 1)
        )
    ) ? 1 : 0;

    my $arg;
    my $paths;

    if ($old_style) {
        my ($verbose, $safe);
        ($paths, $verbose, $safe) = @@_;
        $arg->{verbose} = defined $verbose ? $verbose : 0;
        $arg->{safe}    = defined $safe    ? $safe    : 0;

        if (defined($paths) and length($paths)) {
            $paths = [$paths] unless UNIVERSAL::isa($paths,'ARRAY');
        }
        else {
            _carp ("No root path(s) specified\n");
            return 0;
        }
    }
    else {
        if (@@_ > 0 and UNIVERSAL::isa($_[-1],'HASH')) {
            $arg = pop @@_;
            ${$arg->{error}}  = [] if exists $arg->{error};
            ${$arg->{result}} = [] if exists $arg->{result};
        }
        else {
            @@{$arg}{qw(verbose safe)} = (0, 0);
        }
        $paths = [@@_];
    }

    $arg->{prefix} = '';
    $arg->{depth}  = 0;

    $arg->{cwd} = getcwd() or do {
        _error($arg, "cannot fetch initial working directory");
        return 0;
    };
    for ($arg->{cwd}) { /\A(.*)\Z/; $_ = $1 } # untaint

    @@{$arg}{qw(device inode)} = (stat $arg->{cwd})[0,1] or do {
        _error($arg, "cannot stat initial working directory", $arg->{cwd});
        return 0;
    };

    return _rmtree($arg, $paths);
}

sub _rmtree {
    my $arg   = shift;
    my $paths = shift;

    my $count  = 0;
    my $curdir = File::Spec->curdir();
    my $updir  = File::Spec->updir();

    my (@@files, $root);
    ROOT_DIR:
    foreach $root (@@$paths) {
        if ($Is_MacOS) {
            $root  = ":$root" unless $root =~ /:/;
            $root .= ":"      unless $root =~ /:\z/;
        }
        else {
            $root =~ s{/\z}{};
        }

        # since we chdir into each directory, it may not be obvious
        # to figure out where we are if we generate a message about
        # a file name. We therefore construct a semi-canonical
        # filename, anchored from the directory being unlinked (as
        # opposed to being truly canonical, anchored from the root (/).

        my $canon = $arg->{prefix}
            ? File::Spec->catfile($arg->{prefix}, $root)
            : $root
        ;

        my ($ldev, $lino, $perm) = (lstat $root)[0,1,2] or next ROOT_DIR;

        if ( -d _ ) {
            $root = VMS::Filespec::pathify($root) if $Is_VMS;
            if (!chdir($root)) {
                # see if we can escalate privileges to get in
                # (e.g. funny protection mask such as -w- instead of rwx)
                $perm &= 07777;
                my $nperm = $perm | 0700;
                if (!($arg->{safe} or $nperm == $perm or chmod($nperm, $root))) {
                    _error($arg, "cannot make child directory read-write-exec", $canon);
                    next ROOT_DIR;
                }
                elsif (!chdir($root)) {
                    _error($arg, "cannot chdir to child", $canon);
                    next ROOT_DIR;
                }
            }

            my ($device, $inode, $perm) = (stat $curdir)[0,1,2] or do {
                _error($arg, "cannot stat current working directory", $canon);
                next ROOT_DIR;
            };

            ($ldev eq $device and $lino eq $inode)
                or _croak("directory $canon changed before chdir, expected dev=$ldev inode=$lino, actual dev=$device ino=$inode, aborting.");

            $perm &= 07777; # don't forget setuid, setgid, sticky bits
            my $nperm = $perm | 0700;

            # notabene: 0700 is for making readable in the first place,
            # it's also intended to change it to writable in case we have
            # to recurse in which case we are better than rm -rf for 
            # subtrees with strange permissions

            if (!($arg->{safe} or $nperm == $perm or chmod($nperm, $curdir))) {
                _error($arg, "cannot make directory read+writeable", $canon);
                $nperm = $perm;
            }

            my $d;
            $d = gensym() if $] < 5.006;
            if (!opendir $d, $curdir) {
                _error($arg, "cannot opendir", $canon);
                @@files = ();
            }
            else {
                no strict 'refs';
                if (!defined ${"\cTAINT"} or ${"\cTAINT"}) {
                    # Blindly untaint dir names if taint mode is
                    # active, or any perl < 5.006
                    @@files = map { /\A(.*)\z/s; $1 } readdir $d;
                }
                else {
                    @@files = readdir $d;
                }
                closedir $d;
            }

            if ($Is_VMS) {
                # Deleting large numbers of files from VMS Files-11
                # filesystems is faster if done in reverse ASCIIbetical order.
                # include '.' to '.;' from blead patch #31775
                @@files = map {$_ eq '.' ? '.;' : $_} reverse @@files;
                ($root = VMS::Filespec::unixify($root)) =~ s/\.dir\z//;
            }
            @@files = grep {$_ ne $updir and $_ ne $curdir} @@files;

            if (@@files) {
                # remove the contained files before the directory itself
                my $narg = {%$arg};
                @@{$narg}{qw(device inode cwd prefix depth)}
                    = ($device, $inode, $updir, $canon, $arg->{depth}+1);
                $count += _rmtree($narg, \@@files);
            }

            # restore directory permissions of required now (in case the rmdir
            # below fails), while we are still in the directory and may do so
            # without a race via '.'
            if ($nperm != $perm and not chmod($perm, $curdir)) {
                _error($arg, "cannot reset chmod", $canon);
            }

            # don't leave the client code in an unexpected directory
            chdir($arg->{cwd})
                or _croak("cannot chdir to $arg->{cwd} from $canon: $!, aborting.");

            # ensure that a chdir upwards didn't take us somewhere other
            # than we expected (see CVE-2002-0435)
            ($device, $inode) = (stat $curdir)[0,1]
                or _croak("cannot stat prior working directory $arg->{cwd}: $!, aborting.");

            ($arg->{device} eq $device and $arg->{inode} eq $inode)
                or _croak("previous directory $arg->{cwd} changed before entering $canon, expected dev=$ldev inode=$lino, actual dev=$device ino=$inode, aborting.");

            if ($arg->{depth} or !$arg->{keep_root}) {
                if ($arg->{safe} &&
                    ($Is_VMS ? !&VMS::Filespec::candelete($root) : !-w $root)) {
                    print "skipped $root\n" if $arg->{verbose};
                    next ROOT_DIR;
                }
                if (!chmod $perm | 0700, $root) {
                    if ($Force_Writeable) {
                        _error($arg, "cannot make directory writeable", $canon);
                    }
                }
                print "rmdir $root\n" if $arg->{verbose};
                if (rmdir $root) {
                    push @@{${$arg->{result}}}, $root if $arg->{result};
                    ++$count;
                }
                else {
                    _error($arg, "cannot remove directory", $canon);
                    if (!chmod($perm, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
                    ) {
                        _error($arg, sprintf("cannot restore permissions to 0%o",$perm), $canon);
                    }
                }
            }
        }
        else {
            # not a directory
            $root = VMS::Filespec::vmsify("./$root")
                if $Is_VMS 
                   && !File::Spec->file_name_is_absolute($root)
                   && ($root !~ m/(?<!\^)[\]>]+/);  # not already in VMS syntax

            if ($arg->{safe} &&
                ($Is_VMS ? !&VMS::Filespec::candelete($root)
                         : !(-l $root || -w $root)))
            {
                print "skipped $root\n" if $arg->{verbose};
                next ROOT_DIR;
            }

            my $nperm = $perm & 07777 | 0600;
            if ($nperm != $perm and not chmod $nperm, $root) {
                if ($Force_Writeable) {
                    _error($arg, "cannot make file writeable", $canon);
                }
            }
            print "unlink $canon\n" if $arg->{verbose};
            # delete all versions under VMS
            for (;;) {
                if (unlink $root) {
                    push @@{${$arg->{result}}}, $root if $arg->{result};
                }
                else {
                    _error($arg, "cannot unlink file", $canon);
                    $Force_Writeable and chmod($perm, $root) or
                        _error($arg, sprintf("cannot restore permissions to 0%o",$perm), $canon);
                    last;
                }
                ++$count;
                last unless $Is_VMS && lstat $root;
            }
        }
    }

    return $count;
}

1;
__END__

d5 1
a5 6
File::Path - Create or remove directory trees

=head1 VERSION

This document describes version 2.04 of File::Path, released
2007-11-13.
a10 9
    # modern
    mkpath( 'foo/bar/baz', '/zug/zwang', {verbose => 1} );

    rmtree(
        'foo/bar/baz', '/zug/zwang',
        { verbose => 1, error  => \my $err_list }
    );

    # traditional
d16 3
a18 134
The C<mkpath> function provides a convenient way to create directories
of arbitrary depth. Similarly, the C<rmtree> function provides a
convenient way to delete an entire directory subtree from the
filesystem, much like the Unix command C<rm -r>.

Both functions may be called in one of two ways, the traditional,
compatible with code written since the dawn of time, and modern,
that offers a more flexible and readable idiom. New code should use
the modern interface.

=head2 FUNCTIONS

The modern way of calling C<mkpath> and C<rmtree> is with a list
of directories to create, or remove, respectively, followed by an
optional hash reference containing keys to control the
function's behaviour.

=head3 C<mkpath>

The following keys are recognised as parameters to C<mkpath>.
The function returns the list of files actually created during the
call.

  my @@created = mkpath(
    qw(/tmp /flub /home/nobody),
    {verbose => 1, mode => 0750},
  );
  print "created $_\n" for @@created;

=over 4

=item mode

The numeric permissions mode to apply to each created directory
(defaults to 0777), to be modified by the current C<umask>. If the
directory already exists (and thus does not need to be created),
the permissions will not be modified.

C<mask> is recognised as an alias for this parameter.

=item verbose

If present, will cause C<mkpath> to print the name of each directory
as it is created. By default nothing is printed.

=item error

If present, will be interpreted as a reference to a list, and will
be used to store any errors that are encountered.  See the ERROR
HANDLING section for more information.

If this parameter is not used, certain error conditions may raise
a fatal error that will cause the program will halt, unless trapped
in an C<eval> block.

=back

=head3 C<rmtree>

=over 4

=item verbose

If present, will cause C<rmtree> to print the name of each file as
it is unlinked. By default nothing is printed.

=item safe

When set to a true value, will cause C<rmtree> to skip the files
for which the process lacks the required privileges needed to delete
files, such as delete privileges on VMS. In other words, the code
will make no attempt to alter file permissions. Thus, if the process
is interrupted, no filesystem object will be left in a more
permissive mode.

=item keep_root

When set to a true value, will cause all files and subdirectories
to be removed, except the initially specified directories. This comes
in handy when cleaning out an application's scratch directory.

  rmtree( '/tmp', {keep_root => 1} );

=item result

If present, will be interpreted as a reference to a list, and will
be used to store the list of all files and directories unlinked
during the call. If nothing is unlinked, a reference to an empty
list is returned (rather than C<undef>).

  rmtree( '/tmp', {result => \my $list} );
  print "unlinked $_\n" for @@$list;

This is a useful alternative to the C<verbose> key.

=item error

If present, will be interpreted as a reference to a list,
and will be used to store any errors that are encountered.
See the ERROR HANDLING section for more information.

Removing things is a much more dangerous proposition than
creating things. As such, there are certain conditions that
C<rmtree> may encounter that are so dangerous that the only
sane action left is to kill the program.

Use C<error> to trap all that is reasonable (problems with
permissions and the like), and let it die if things get out
of hand. This is the safest course of action.

=back

=head2 TRADITIONAL INTERFACE

The old interfaces of C<mkpath> and C<rmtree> take a reference to
a list of directories (to create or remove), followed by a series
of positional, numeric, modal parameters that control their behaviour.

This design made it difficult to add additional functionality, as
well as posed the problem of what to do when the calling code only
needs to set the last parameter. Even though the code doesn't care
how the initial positional parameters are set, the programmer is
forced to learn what the defaults are, and specify them.

Worse, if it turns out in the future that it would make more sense
to change the default behaviour of the first parameter (for example,
to avoid a security vulnerability), all existing code will remain
hard-wired to the wrong defaults.

Finally, a series of numeric parameters are much less self-documenting
in terms of communicating to the reader what the code is doing. Named
parameters do not have this problem.

In the traditional API, C<mkpath> takes three arguments:
d24 2
a25 2
The name of the path to create, or a reference to a list of paths
to create,
d29 3
a31 2
a boolean value, which if TRUE will cause C<mkpath> to print the
name of each directory as it is created (defaults to FALSE), and
d35 2
a36 2
the numeric mode to use when creating the directories (defaults to
0777), to be modified by the current umask.
d41 1
a41 2
using the Unix '/' separator) created.  In scalar context it returns
the number of directories created.
d52 3
a54 1
In the traditional API, C<rmtree> takes three arguments:
d60 4
a63 4
the root of the subtree to delete, or a reference to a list of
roots. All of the files and directories below each root, as well
as the roots themselves, will be deleted. If you want to keep
the roots themselves, you must use the modern API.
d67 5
a71 4
a boolean value, which if TRUE will cause C<rmtree> to print a
message each time it examines a file, giving the name of the file,
and indicating whether it's using C<rmdir> or C<unlink> to remove
it, or that it's skipping it.  (defaults to FALSE)
d75 6
a80 5
a boolean value, which if TRUE will cause C<rmtree> to skip any
files to which you do not have delete access (if running under VMS)
or write access (if running under another OS). This will change
in the future when a criterion for 'delete permission' under OSs
other than VMS is settled.  (defaults to FALSE)
d84 2
a85 74
It returns the number of files, directories and symlinks successfully
deleted.  Symlinks are simply deleted and not followed.

Note also that the occurrence of errors in C<rmtree> using the
traditional interface can be determined I<only> by trapping diagnostic
messages using C<$SIG{__WARN__}>; it is not apparent from the return
value. (The modern interface may use the C<error> parameter to
record any problems encountered).

=head2 ERROR HANDLING

If C<mkpath> or C<rmtree> encounter an error, a diagnostic message
will be printed to C<STDERR> via C<carp> (for non-fatal errors),
or via C<croak> (for fatal errors).

If this behaviour is not desirable, the C<error> attribute may be
used to hold a reference to a variable, which will be used to store
the diagnostics. The result is a reference to a list of hash
references. For each hash reference, the key is the name of the
file, and the value is the error message (usually the contents of
C<$!>). An example usage looks like:

  rmpath( 'foo/bar', 'bar/rat', {error => \my $err} );
  for my $diag (@@$err) {
    my ($file, $message) = each %$diag;
    print "problem unlinking $file: $message\n";
  }

If no errors are encountered, C<$err> will point to an empty list
(thus there is no need to test for C<undef>). If a general error
is encountered (for instance, C<rmtree> attempts to remove a directory
tree that does not exist), the diagnostic key will be empty, only
the value will be set:

  rmpath( '/no/such/path', {error => \my $err} );
  for my $diag (@@$err) {
    my ($file, $message) = each %$diag;
    if ($file eq '') {
      print "general error: $message\n";
    }
  }

=head2 NOTES

C<File::Path> blindly exports C<mkpath> and C<rmtree> into the
current namespace. These days, this is considered bad style, but
to change it now would break too much code. Nonetheless, you are
invited to specify what it is you are expecting to use:

  use File::Path 'rmtree';

=head3 HEURISTICS

The functions detect (as far as possible) which way they are being
called and will act appropriately. It is important to remember that
the heuristic for detecting the old style is either the presence
of an array reference, or two or three parameters total and second
and third parameters are numeric. Hence...

    mkpath 486, 487, 488;

... will not assume the modern style and create three directories, rather
it will create one directory verbosely, setting the permission to
0750 (488 being the decimal equivalent of octal 750). Here, old
style trumps new. It must, for backwards compatibility reasons.

If you want to ensure there is absolutely no ambiguity about which
way the function will behave, make sure the first parameter is a
reference to a one-element list, to force the old style interpretation:

    mkpath [486], 487, 488;

and get only one directory created. Or add a reference to an empty
parameter hash, to force the new style:
d87 14
a100 27
    mkpath 486, 487, 488, {};

... and hence create the three directories. If the empty hash
reference seems a little strange to your eyes, or you suspect a
subsequent programmer might I<helpfully> optimise it away, you
can add a parameter set to a default value:

    mkpath 486, 487, 488, {verbose => 0};

=head3 SECURITY CONSIDERATIONS

There were race conditions 1.x implementations of File::Path's
C<rmtree> function (although sometimes patched depending on the OS
distribution or platform). The 2.0 version contains code to avoid the
problem mentioned in CVE-2002-0435.

See the following pages for more information:

  http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=286905
  http://www.nntp.perl.org/group/perl.perl5.porters/2005/01/msg97623.html
  http://www.debian.org/security/2005/dsa-696

Additionally, unless the C<safe> parameter is set (or the
third parameter in the traditional interface is TRUE), should a
C<rmtree> be interrupted, files that were originally in read-only
mode may now have their permissions set to a read-write (or "delete
OK") mode.
a103 12
FATAL errors will cause the program to halt (C<croak>), since the
problem is so severe that it would be dangerous to continue. (This
can always be trapped with C<eval>, but it's not a good idea. Under
the circumstances, dying is the best thing to do).

SEVERE errors may be trapped using the modern interface. If the
they are not trapped, or the old interface is used, such an error
will cause the program will halt.

All other errors may be trapped using the modern interface, otherwise
they will be C<carp>ed about. Program execution will not be halted.

d106 1
a106 83
=item mkdir [path]: [errmsg] (SEVERE)

C<mkpath> was unable to create the path. Probably some sort of
permissions error at the point of departure, or insufficient resources
(such as free inodes on Unix).

=item No root path(s) specified

C<mkpath> was not given any paths to create. This message is only
emitted if the routine is called with the traditional interface.
The modern interface will remain silent if given nothing to do.

=item No such file or directory

On Windows, if C<mkpath> gives you this warning, it may mean that
you have exceeded your filesystem's maximum path length.

=item cannot fetch initial working directory: [errmsg]

C<rmtree> attempted to determine the initial directory by calling
C<Cwd::getcwd>, but the call failed for some reason. No attempt
will be made to delete anything.

=item cannot stat initial working directory: [errmsg]

C<rmtree> attempted to stat the initial directory (after having
successfully obtained its name via C<getcwd>), however, the call
failed for some reason. No attempt will be made to delete anything.

=item cannot chdir to [dir]: [errmsg]

C<rmtree> attempted to set the working directory in order to
begin deleting the objects therein, but was unsuccessful. This is
usually a permissions issue. The routine will continue to delete
other things, but this directory will be left intact.

=item directory [dir] changed before chdir, expected dev=[n] inode=[n], actual dev=[n] ino=[n], aborting. (FATAL)

C<rmtree> recorded the device and inode of a directory, and then
moved into it. It then performed a C<stat> on the current directory
and detected that the device and inode were no longer the same. As
this is at the heart of the race condition problem, the program
will die at this point.

=item cannot make directory [dir] read+writeable: [errmsg]

C<rmtree> attempted to change the permissions on the current directory
to ensure that subsequent unlinkings would not run into problems,
but was unable to do so. The permissions remain as they were, and
the program will carry on, doing the best it can.

=item cannot read [dir]: [errmsg]

C<rmtree> tried to read the contents of the directory in order
to acquire the names of the directory entries to be unlinked, but
was unsuccessful. This is usually a permissions issue. The
program will continue, but the files in this directory will remain
after the call.

=item cannot reset chmod [dir]: [errmsg]

C<rmtree>, after having deleted everything in a directory, attempted
to restore its permissions to the original state but failed. The
directory may wind up being left behind.

=item cannot chdir to [parent-dir] from [child-dir]: [errmsg], aborting. (FATAL)

C<rmtree>, after having deleted everything and restored the permissions
of a directory, was unable to chdir back to the parent. This is usually
a sign that something evil this way comes.

=item cannot stat prior working directory [dir]: [errmsg], aborting. (FATAL)

C<rmtree> was unable to stat the parent directory after have returned
from the child. Since there is no way of knowing if we returned to
where we think we should be (by comparing device and inode) the only
way out is to C<croak>.

=item previous directory [parent-dir] changed before entering [child-dir], expected dev=[n] inode=[n], actual dev=[n] ino=[n], aborting. (FATAL)

When C<rmtree> returned from deleting files in a child directory, a
check revealed that the parent directory it returned to wasn't the one
it started out from. This is considered a sign of malicious activity.
d108 3
a110 34
=item cannot make directory [dir] writeable: [errmsg]

Just before removing a directory (after having successfully removed
everything it contained), C<rmtree> attempted to set the permissions
on the directory to ensure it could be removed and failed. Program
execution continues, but the directory may possibly not be deleted.

=item cannot remove directory [dir]: [errmsg]

C<rmtree> attempted to remove a directory, but failed. This may because
some objects that were unable to be removed remain in the directory, or
a permissions issue. The directory will be left behind.

=item cannot restore permissions of [dir] to [0nnn]: [errmsg]

After having failed to remove a directory, C<rmtree> was unable to
restore its permissions from a permissive state back to a possibly
more restrictive setting. (Permissions given in octal).

=item cannot make file [file] writeable: [errmsg]

C<rmtree> attempted to force the permissions of a file to ensure it
could be deleted, but failed to do so. It will, however, still attempt
to unlink the file.

=item cannot unlink file [file]: [errmsg]

C<rmtree> failed to remove a file. Probably a permissions issue.

=item cannot restore permissions of [file] to [0nnn]: [errmsg]

After having failed to remove a file, C<rmtree> was also unable
to restore the permissions on the file to a possibly less permissive
setting. (Permissions given in octal).
d114 1
a114 1
=head1 SEE ALSO
d116 2
a117 1
=over 4
d119 1
a119 1
=item *
d121 6
a126 1
L<File::Remove>
d128 3
a130 4
Allows files and directories to be moved to the Trashcan/Recycle
Bin (where they may later be restored if necessary) if the operating
system supports such functionality. This feature may one day be
made available directly in C<File::Path>.
d132 2
a133 1
=item *
d135 4
a138 1
L<File::Find::Rule>
d140 34
a173 4
When removing directory trees, if you want to examine each file to
decide whether to delete it (and possibly leaving large swathes
alone), F<File::Find::Rule> offers a convenient and flexible approach
to examining directory trees.
d175 6
a180 1
=back
d182 7
a188 1
=head1 BUGS
d190 91
a280 1
Please report all bugs on the RT queue:
d282 2
a283 1
L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=File-Path>
d285 1
a285 24
=head1 ACKNOWLEDGEMENTS

Paul Szabo identified the race condition originally, and Brendan
O'Dea wrote an implementation for Debian that addressed the problem.
That code was used as a basis for the current code. Their efforts
are greatly appreciated.

=head1 AUTHORS

Tim Bunce <F<Tim.Bunce@@ig.co.uk>> and Charles Bailey
<F<bailey@@newman.upenn.edu>>. Currently maintained by David Landgren
<F<david@@landgren.net>>.

=head1 COPYRIGHT

This module is copyright (C) Charles Bailey, Tim Bunce and
David Landgren 1995-2007.  All rights reserved.

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=cut
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d19 4
a22 5
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK);
$VERSION   = '2.07_03';
@@ISA       = qw(Exporter);
@@EXPORT    = qw(mkpath rmtree);
@@EXPORT_OK = qw(make_path remove_tree);
d24 2
a25 2
my $Is_VMS     = $^O eq 'VMS';
my $Is_MacOS   = $^O eq 'MacOS';
a30 4
# Unix-like systems need to stat each directory in order to detect
# race condition. MS-Windows is immune to this particular attack.
my $Need_Stat_Check = !($^O eq 'MSWin32');

d48 1
a48 2
        $message .= ": $!" if $!;
        push @@{${$arg->{error}}}, {$object => $message};
a54 5
sub make_path {
    push @@_, {} unless @@_ and UNIVERSAL::isa($_[-1],'HASH');
    goto &mkpath;
}

d56 8
a63 1
    my $old_style = !(@@_ and UNIVERSAL::isa($_[-1],'HASH'));
d72 2
a73 2
        $arg->{verbose} = $verbose;
        $arg->{mode}    = defined $mode ? $mode : 0777;
d76 9
a84 4
        $arg = pop @@_;
        $arg->{mode}      = delete $arg->{mask} if exists $arg->{mask};
        $arg->{mode}      = 0777 unless exists $arg->{mode};
        ${$arg->{error}}  = [] if exists $arg->{error};
d94 1
d97 1
a97 1
        next unless defined($path) and length($path);
a131 23
sub remove_tree {
    push @@_, {} unless @@_ and UNIVERSAL::isa($_[-1],'HASH');
    goto &rmtree;
}

sub _is_subdir {
    my($dir, $test) = @@_;

    my($dv, $dd) = File::Spec->splitpath($dir, 1);
    my($tv, $td) = File::Spec->splitpath($test, 1);

    # not on same volume
    return 0 if $dv ne $tv;

    my @@d = File::Spec->splitdir($dd);
    my @@t = File::Spec->splitdir($td);

    # @@t can't be a subdir if it's shorter than @@d
    return 0 if @@t < @@d;

    return join('/', @@d) eq join('/', splice @@t, 0, +@@d);
}

d133 8
a140 1
    my $old_style = !(@@_ and UNIVERSAL::isa($_[-1],'HASH'));
d148 1
a148 1
        $arg->{verbose} = $verbose;
d160 8
a167 3
        $arg = pop @@_;
        ${$arg->{error}}  = [] if exists $arg->{error};
        ${$arg->{result}} = [] if exists $arg->{result};
a173 1
    my @@clean_path;
d180 1
a180 26
    for my $p (@@$paths) {
        # need to fixup case and map \ to / on Windows
        my $ortho_root = $^O eq 'MSWin32' ? _slash_lc($p)          : $p;
        my $ortho_cwd  = $^O eq 'MSWin32' ? _slash_lc($arg->{cwd}) : $arg->{cwd};
        my $ortho_root_length = length($ortho_root);
        $ortho_root_length-- if $^O eq 'VMS'; # don't compare '.' with ']'
        if ($ortho_root_length && _is_subdir($ortho_root, $ortho_cwd)) {
            local $! = 0;
            _error($arg, "cannot remove path when cwd is $arg->{cwd}", $p);
            next;
        }

        if ($Is_MacOS) {
            $p  = ":$p" unless $p =~ /:/;
            $p .= ":"   unless $p =~ /:\z/;
        }
        elsif ($^O eq 'MSWin32') {
            $p =~ s{[/\\]\z}{};
        }
        else {
            $p =~ s{/\z}{};
        }
        push @@clean_path, $p;
    }

    @@{$arg}{qw(device inode perm)} = (lstat $arg->{cwd})[0,1] or do {
d185 1
a185 1
    return _rmtree($arg, \@@clean_path);
d199 8
a221 1

d237 1
a237 1
            my ($cur_dev, $cur_inode, $perm) = (stat $curdir)[0,1,2] or do {
d242 2
a243 4
            if ($Need_Stat_Check) {
                ($ldev eq $cur_dev and $lino eq $cur_inode)
                    or _croak("directory $canon changed before chdir, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.");
            }
a283 1

d290 1
a290 1
                    = ($cur_dev, $cur_inode, $updir, $canon, $arg->{depth}+1);
d307 1
a307 1
            ($cur_dev, $cur_inode) = (stat $curdir)[0,1]
d310 2
a311 4
            if ($Need_Stat_Check) {
                ($arg->{device} eq $cur_dev and $arg->{inode} eq $cur_inode)
                    or _croak("previous directory $arg->{cwd} changed before entering $canon, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.");
            }
d319 4
a322 2
                if ($Force_Writeable and !chmod $perm | 0700, $root) {
                    _error($arg, "cannot make directory writeable", $canon);
d331 1
a331 1
                    if ($Force_Writeable && !chmod($perm, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
d341 1
a341 1
                if $Is_VMS
d354 4
a357 2
            if ($Force_Writeable and $nperm != $perm and not chmod $nperm, $root) {
                _error($arg, "cannot make file writeable", $canon);
d376 1
a379 8
sub _slash_lc {
    # fix up slashes and case on MSWin32 so that we can determine that
    # c:\path\to\dir is underneath C:/Path/To
    my $path = shift;
    $path =~ tr{\\}{/};
    return lc($path);
}

d389 2
a390 2
This document describes version 2.07 of File::Path, released
2008-11-09.
d394 4
a397 1
  use File::Path qw(make_path remove_tree);
d399 8
a406 22
  make_path('foo/bar/baz', '/zug/zwang');
  make_path('foo/bar/baz', '/zug/zwang', {
      verbose => 1,
      mode => 0711,
  });

  remove_tree('foo/bar/baz', '/zug/zwang');
  remove_tree('foo/bar/baz', '/zug/zwang', {
      verbose => 1,
      error  => \my $err_list,
  });

  # legacy (interface promoted before v2.00)
  mkpath('/foo/bar/baz');
  mkpath('/foo/bar/baz', 1, 0711);
  mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);
  rmtree('foo/bar/baz', 1, 1);
  rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);

  # legacy (interface promoted before v2.06)
  mkpath('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });
  rmtree('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });
d410 28
a437 3
This module provide a convenient way to create directories of
arbitrary depth and to delete an entire directory subtree from the
filesystem.
d439 1
a439 17
The following functions are provided:

=over

=item make_path( $dir1, $dir2, .... )

=item make_path( $dir1, $dir2, ...., \%opts )

The C<make_path> function creates the given directories if they don't
exists before, much like the Unix command C<mkdir -p>.

The function accepts a list of directories to be created. Its
behaviour may be tuned by an optional hashref appearing as the last
parameter on the call.

The function returns the list of directories actually created during
the call; in scalar context the number of directories created.
d441 1
a441 5
The following keys are recognised in the option hash:

=over

=item mode => $num
d450 1
a450 1
=item verbose => $bool
d452 1
a452 1
If present, will cause C<make_path> to print the name of each directory
d455 1
a455 1
=item error => \$err
d457 3
a459 4
If present, it should be a reference to a scalar.
This scalar will be made to reference an array, which will
be used to store any errors that are encountered.  See the L</"ERROR
HANDLING"> section for more information.
d467 1
a467 1
=item mkpath( $dir )
d469 1
a469 27
=item mkpath( $dir, $verbose, $mode )

=item mkpath( [$dir1, $dir2,...], $verbose, $mode )

=item mkpath( $dir1, $dir2,..., \%opt )

The mkpath() function provide the legacy interface of make_path() with
a different interpretation of the arguments passed.  The behaviour and
return value of the function is otherwise identical to make_path().

=item remove_tree( $dir1, $dir2, .... )

=item remove_tree( $dir1, $dir2, ...., \%opts )

The C<remove_tree> function deletes the given directories and any
files and subdirectories they might contain, much like the Unix
command C<rm -r> or C<del /s> on Windows.

The function accepts a list of directories to be
removed. Its behaviour may be tuned by an optional hashref
appearing as the last parameter on the call.

The functions returns the number of files successfully deleted.

The following keys are recognised in the option hash:

=over
d471 1
a471 1
=item verbose => $bool
d473 1
a473 1
If present, will cause C<remove_tree> to print the name of each file as
d476 1
a476 1
=item safe => $bool
d478 1
a478 1
When set to a true value, will cause C<remove_tree> to skip the files
d485 1
a485 1
=item keep_root => $bool
d491 1
a491 1
  remove_tree( '/tmp', {keep_root => 1} );
d493 1
a493 1
=item result => \$res
d495 4
a498 4
If present, it should be a reference to a scalar.
This scalar will be made to reference an array, which will
be used to store all files and directories unlinked
during the call. If nothing is unlinked, the array will be empty.
d500 1
a500 1
  remove_tree( '/tmp', {result => \my $list} );
d505 1
a505 1
=item error => \$err
d507 3
a509 4
If present, it should be a reference to a scalar.
This scalar will be made to reference an array, which will
be used to store any errors that are encountered.  See the L</"ERROR
HANDLING"> section for more information.
d513 1
a513 1
C<remove_tree> may encounter that are so dangerous that the only
d522 1
a522 1
=item rmtree( $dir )
d524 18
a541 1
=item rmtree( $dir, $verbose, $safe )
d543 1
a543 1
=item rmtree( [$dir1, $dir2,...], $verbose, $safe )
d545 8
a552 1
=item rmtree( $dir1, $dir2,..., \%opt )
d554 7
a560 4
The rmtree() function provide the legacy interface of remove_tree()
with a different interpretation of the arguments passed. The behaviour
and return value of the function is otherwise identical to
remove_tree().
d564 14
a577 1
=head2 ERROR HANDLING
d581 15
a595 1
=item B<NOTE:>
d597 5
a601 3
The following error handling mechanism is considered
experimental and is subject to change pending feedback from
users.
d605 14
a618 3
If C<make_path> or C<remove_tree> encounter an error, a diagnostic
message will be printed to C<STDERR> via C<carp> (for non-fatal
errors), or via C<croak> (for fatal errors).
d622 9
a630 19
the diagnostics. The variable is made a reference to an array of hash
references.  Each hash contain a single key/value pair where the key
is the name of the file, and the value is the error message (including
the contents of C<$!> when appropriate).  If a general error is
encountered the diagnostic key will be empty.

An example usage looks like:

  remove_tree( 'foo/bar', 'bar/rat', {error => \my $err} );
  if (@@$err) {
      for my $diag (@@$err) {
          my ($file, $message) = %$diag;
          if ($file eq '') {
              print "general error: $message\n";
          }
          else {
              print "problem unlinking $file: $message\n";
          }
      }
d632 13
a644 2
  else {
      print "No error encountered\n";
a646 4
Note that if no errors are encountered, C<$err> will reference an
empty array.  This means that C<$err> will always end up TRUE; so you
need to test C<@@$err> to determine if errors occured.

d656 18
a673 2
The routines C<make_path> and C<remove_tree> are B<not> exported
by default. You must specify which ones you want to use.
d675 1
a675 1
  use File::Path 'remove_tree';
d677 2
a678 5
Note that a side-effect of the above is that C<mkpath> and C<rmtree>
are no longer exported at all. This is due to the way the C<Exporter>
module works. If you are migrating a codebase to use the new
interface, you will have to list everything explicitly. But that's
just good practice anyway.
d680 8
a687 1
  use File::Path qw(remove_tree rmtree);
d704 1
a704 1
C<remove_tree> be interrupted, files that were originally in read-only
d726 1
a726 1
C<make_path> was unable to create the path. Probably some sort of
d732 1
a732 1
C<make_path> was not given any paths to create. This message is only
d738 1
a738 1
On Windows, if C<make_path> gives you this warning, it may mean that
d743 1
a743 1
C<remove_tree> attempted to determine the initial directory by calling
d749 1
a749 1
C<remove_tree> attempted to stat the initial directory (after having
d755 1
a755 1
C<remove_tree> attempted to set the working directory in order to
d760 1
a760 1
=item directory [dir] changed before chdir, expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)
d762 1
a762 1
C<remove_tree> recorded the device and inode of a directory, and then
d770 1
a770 1
C<remove_tree> attempted to change the permissions on the current directory
d777 1
a777 1
C<remove_tree> tried to read the contents of the directory in order
d785 1
a785 1
C<remove_tree>, after having deleted everything in a directory, attempted
a788 9
=item cannot remove [dir] when cwd is [dir]

The current working directory of the program is F</some/path/to/here>
and you are attempting to remove an ancestor, such as F</some/path>.
The directory tree is left untouched.

The solution is to C<chdir> out of the child directory to a place
outside the directory tree to be removed.

d791 3
a793 3
C<remove_tree>, after having deleted everything and restored the permissions
of a directory, was unable to chdir back to the parent. The program
halts to avoid a race condition from occurring.
d797 1
a797 1
C<remove_tree> was unable to stat the parent directory after have returned
d802 1
a802 1
=item previous directory [parent-dir] changed before entering [child-dir], expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)
d804 1
a804 1
When C<remove_tree> returned from deleting files in a child directory, a
d811 1
a811 1
everything it contained), C<remove_tree> attempted to set the permissions
d817 1
a817 1
C<remove_tree> attempted to remove a directory, but failed. This may because
d823 1
a823 1
After having failed to remove a directory, C<remove_tree> was unable to
d829 1
a829 1
C<remove_tree> attempted to force the permissions of a file to ensure it
d835 1
a835 1
C<remove_tree> failed to remove a file. Probably a permissions issue.
d839 1
a839 1
After having failed to remove a file, C<remove_tree> was also unable
a881 3
Gisle Aas made a number of improvements to the documentation for
2.07 and his advice and assistance is also greatly appreciated.

d884 2
a885 1
Tim Bunce and Charles Bailey. Currently maintained by David Landgren
d891 1
a891 1
David Landgren 1995-2008. All rights reserved.
@


