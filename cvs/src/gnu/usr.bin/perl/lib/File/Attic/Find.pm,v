head	1.16;
access;
symbols
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2014.11.17.20.57.06;	author afresh1;	state dead;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.28;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.56;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.07.01;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.09.33;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.31;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.38;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.43;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.10;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.44;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.30;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.03;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.18;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.46.59;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.46;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.35;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.59;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.41;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.08.54;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@package File::Find;
use 5.006;
use strict;
use warnings;
use warnings::register;
our $VERSION = '1.23';
require Exporter;
require Cwd;

#
# Modified to ensure sub-directory traversal order is not inverted by stack
# push and pops.  That is remains in the same order as in the directory file,
# or user pre-processing (EG:sorted).
#

=head1 NAME

File::Find - Traverse a directory tree.

=head1 SYNOPSIS

    use File::Find;
    find(\&wanted, @@directories_to_search);
    sub wanted { ... }

    use File::Find;
    finddepth(\&wanted, @@directories_to_search);
    sub wanted { ... }

    use File::Find;
    find({ wanted => \&process, follow => 1 }, '.');

=head1 DESCRIPTION

These are functions for searching through directory trees doing work
on each file found similar to the Unix I<find> command.  File::Find
exports two functions, C<find> and C<finddepth>.  They work similarly
but have subtle differences.

=over 4

=item B<find>

  find(\&wanted,  @@directories);
  find(\%options, @@directories);

C<find()> does a depth-first search over the given C<@@directories> in
the order they are given.  For each file or directory found, it calls
the C<&wanted> subroutine.  (See below for details on how to use the
C<&wanted> function).  Additionally, for each directory found, it will
C<chdir()> into that directory and continue the search, invoking the
C<&wanted> function on each file or subdirectory in the directory.

=item B<finddepth>

  finddepth(\&wanted,  @@directories);
  finddepth(\%options, @@directories);

C<finddepth()> works just like C<find()> except that it invokes the
C<&wanted> function for a directory I<after> invoking it for the
directory's contents.  It does a postorder traversal instead of a
preorder traversal, working from the bottom of the directory tree up
where C<find()> works from the top of the tree down.

=back

=head2 %options

The first argument to C<find()> is either a code reference to your
C<&wanted> function, or a hash reference describing the operations
to be performed for each file.  The
code reference is described in L<The wanted function> below.

Here are the possible keys for the hash:

=over 3

=item C<wanted>

The value should be a code reference.  This code reference is
described in L<The wanted function> below. The C<&wanted> subroutine is
mandatory.

=item C<bydepth>

Reports the name of a directory only AFTER all its entries
have been reported.  Entry point C<finddepth()> is a shortcut for
specifying C<< { bydepth => 1 } >> in the first argument of C<find()>.

=item C<preprocess>

The value should be a code reference. This code reference is used to
preprocess the current directory. The name of the currently processed
directory is in C<$File::Find::dir>. Your preprocessing function is
called after C<readdir()>, but before the loop that calls the C<wanted()>
function. It is called with a list of strings (actually file/directory
names) and is expected to return a list of strings. The code can be
used to sort the file/directory names alphabetically, numerically,
or to filter out directory entries based on their name alone. When
I<follow> or I<follow_fast> are in effect, C<preprocess> is a no-op.

=item C<postprocess>

The value should be a code reference. It is invoked just before leaving
the currently processed directory. It is called in void context with no
arguments. The name of the current directory is in C<$File::Find::dir>. This
hook is handy for summarizing a directory, such as calculating its disk
usage. When I<follow> or I<follow_fast> are in effect, C<postprocess> is a
no-op.

=item C<follow>

Causes symbolic links to be followed. Since directory trees with symbolic
links (followed) may contain files more than once and may even have
cycles, a hash has to be built up with an entry for each file.
This might be expensive both in space and time for a large
directory tree. See L</follow_fast> and L</follow_skip> below.
If either I<follow> or I<follow_fast> is in effect:

=over 6

=item *

It is guaranteed that an I<lstat> has been called before the user's
C<wanted()> function is called. This enables fast file checks involving S<_>.
Note that this guarantee no longer holds if I<follow> or I<follow_fast>
are not set.

=item *

There is a variable C<$File::Find::fullname> which holds the absolute
pathname of the file with all symbolic links resolved.  If the link is
a dangling symbolic link, then fullname will be set to C<undef>.

=back

This is a no-op on Win32.

=item C<follow_fast>

This is similar to I<follow> except that it may report some files more
than once.  It does detect cycles, however.  Since only symbolic links
have to be hashed, this is much cheaper both in space and time.  If
processing a file more than once (by the user's C<wanted()> function)
is worse than just taking time, the option I<follow> should be used.

This is also a no-op on Win32.

=item C<follow_skip>

C<follow_skip==1>, which is the default, causes all files which are
neither directories nor symbolic links to be ignored if they are about
to be processed a second time. If a directory or a symbolic link
are about to be processed a second time, File::Find dies.

C<follow_skip==0> causes File::Find to die if any file is about to be
processed a second time.

C<follow_skip==2> causes File::Find to ignore any duplicate files and
directories but to proceed normally otherwise.

=item C<dangling_symlinks>

If true and a code reference, will be called with the symbolic link
name and the directory it lives in as arguments.  Otherwise, if true
and warnings are on, warning "symbolic_link_name is a dangling
symbolic link\n" will be issued.  If false, the dangling symbolic link
will be silently ignored.

=item C<no_chdir>

Does not C<chdir()> to each directory as it recurses. The C<wanted()>
function will need to be aware of this, of course. In this case,
C<$_> will be the same as C<$File::Find::name>.

=item C<untaint>

If find is used in taint-mode (-T command line switch or if EUID != UID
or if EGID != GID) then internally directory names have to be untainted
before they can be chdir'ed to. Therefore they are checked against a regular
expression I<untaint_pattern>.  Note that all names passed to the user's
I<wanted()> function are still tainted. If this option is used while
not in taint-mode, C<untaint> is a no-op.

=item C<untaint_pattern>

See above. This should be set using the C<qr> quoting operator.
The default is set to  C<qr|^([-+@@\w./]+)$|>.
Note that the parentheses are vital.

=item C<untaint_skip>

If set, a directory which fails the I<untaint_pattern> is skipped,
including all its sub-directories. The default is to 'die' in such a case.

=back

=head2 The wanted function

The C<wanted()> function does whatever verifications you want on
each file and directory.  Note that despite its name, the C<wanted()>
function is a generic callback function, and does B<not> tell
File::Find if a file is "wanted" or not.  In fact, its return value
is ignored.

The wanted function takes no arguments but rather does its work
through a collection of variables.

=over 4

=item C<$File::Find::dir> is the current directory name,

=item C<$_> is the current filename within that directory

=item C<$File::Find::name> is the complete pathname to the file.

=back

The above variables have all been localized and may be changed without
affecting data outside of the wanted function.

For example, when examining the file F</some/path/foo.ext> you will have:

    $File::Find::dir  = /some/path/
    $_                = foo.ext
    $File::Find::name = /some/path/foo.ext

You are chdir()'d to C<$File::Find::dir> when the function is called,
unless C<no_chdir> was specified. Note that when changing to
directories is in effect the root directory (F</>) is a somewhat
special case inasmuch as the concatenation of C<$File::Find::dir>,
C<'/'> and C<$_> is not literally equal to C<$File::Find::name>. The
table below summarizes all variants:

              $File::Find::name  $File::Find::dir  $_
 default      /                  /                 .
 no_chdir=>0  /etc               /                 etc
              /etc/x             /etc              x

 no_chdir=>1  /                  /                 /
              /etc               /                 /etc
              /etc/x             /etc              /etc/x


When C<follow> or C<follow_fast> are in effect, there is
also a C<$File::Find::fullname>.  The function may set
C<$File::Find::prune> to prune the tree unless C<bydepth> was
specified.  Unless C<follow> or C<follow_fast> is specified, for
compatibility reasons (find.pl, find2perl) there are in addition the
following globals available: C<$File::Find::topdir>,
C<$File::Find::topdev>, C<$File::Find::topino>,
C<$File::Find::topmode> and C<$File::Find::topnlink>.

This library is useful for the C<find2perl> tool, which when fed,

    find2perl / -name .nfs\* -mtime +7 \
        -exec rm -f {} \; -o -fstype nfs -prune

produces something like:

    sub wanted {
        /^\.nfs.*\z/s &&
        (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_)) &&
        int(-M _) > 7 &&
        unlink($_)
        ||
        ($nlink || (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_))) &&
        $dev < 0 &&
        ($File::Find::prune = 1);
    }

Notice the C<_> in the above C<int(-M _)>: the C<_> is a magical
filehandle that caches the information from the preceding
C<stat()>, C<lstat()>, or filetest.

Here's another interesting wanted function.  It will find all symbolic
links that don't resolve:

    sub wanted {
         -l && !-e && print "bogus link: $File::Find::name\n";
    }

Note that you may mix directories and (non-directory) files in the list of 
directories to be searched by the C<wanted()> function.

    find(\&wanted, "./foo", "./bar", "./baz/epsilon");

In the example above, no file in F<./baz/> other than F<./baz/epsilon> will be
evaluated by C<wanted()>.

See also the script C<pfind> on CPAN for a nice application of this
module.

=head1 WARNINGS

If you run your program with the C<-w> switch, or if you use the
C<warnings> pragma, File::Find will report warnings for several weird
situations. You can disable these warnings by putting the statement

    no warnings 'File::Find';

in the appropriate scope. See L<perllexwarn> for more info about lexical
warnings.

=head1 CAVEAT

=over 2

=item $dont_use_nlink

You can set the variable C<$File::Find::dont_use_nlink> to 1, if you want to
force File::Find to always stat directories. This was used for file systems
that do not have an C<nlink> count matching the number of sub-directories.
Examples are ISO-9660 (CD-ROM), AFS, HPFS (OS/2 file system), FAT (DOS file
system) and a couple of others.

You shouldn't need to set this variable, since File::Find should now detect
such file systems on-the-fly and switch itself to using stat. This works even
for parts of your file system, like a mounted CD-ROM.

If you do set C<$File::Find::dont_use_nlink> to 1, you will notice slow-downs.

=item symlinks

Be aware that the option to follow symbolic links can be dangerous.
Depending on the structure of the directory tree (including symbolic
links to directories) you might traverse a given (physical) directory
more than once (only if C<follow_fast> is in effect).
Furthermore, deleting or changing files in a symbolically linked directory
might cause very unpleasant surprises, since you delete or change files
in an unknown directory.

=back

=head1 BUGS AND CAVEATS

Despite the name of the C<finddepth()> function, both C<find()> and
C<finddepth()> perform a depth-first search of the directory
hierarchy.

=head1 HISTORY

File::Find used to produce incorrect results if called recursively.
During the development of perl 5.8 this bug was fixed.
The first fixed version of File::Find was 1.01.

=head1 SEE ALSO

find, find2perl.

=cut

our @@ISA = qw(Exporter);
our @@EXPORT = qw(find finddepth);


use strict;
my $Is_VMS;
my $Is_Win32;

require File::Basename;
require File::Spec;

# Should ideally be my() not our() but local() currently
# refuses to operate on lexicals

our %SLnkSeen;
our ($wanted_callback, $avoid_nlink, $bydepth, $no_chdir, $follow,
    $follow_skip, $full_check, $untaint, $untaint_skip, $untaint_pat,
    $pre_process, $post_process, $dangling_symlinks);

sub contract_name {
    my ($cdir,$fn) = @@_;

    return substr($cdir,0,rindex($cdir,'/')) if $fn eq $File::Find::current_dir;

    $cdir = substr($cdir,0,rindex($cdir,'/')+1);

    $fn =~ s|^\./||;

    my $abs_name= $cdir . $fn;

    if (substr($fn,0,3) eq '../') {
       1 while $abs_name =~ s!/[^/]*/\.\./+!/!;
    }

    return $abs_name;
}

sub PathCombine($$) {
    my ($Base,$Name) = @@_;
    my $AbsName;

    if (substr($Name,0,1) eq '/') {
	$AbsName= $Name;
    }
    else {
	$AbsName= contract_name($Base,$Name);
    }

    # (simple) check for recursion
    my $newlen= length($AbsName);
    if ($newlen <= length($Base)) {
	if (($newlen == length($Base) || substr($Base,$newlen,1) eq '/')
	    && $AbsName eq substr($Base,0,$newlen))
	{
	    return undef;
	}
    }
    return $AbsName;
}

sub Follow_SymLink($) {
    my ($AbsName) = @@_;

    my ($NewName,$DEV, $INO);
    ($DEV, $INO)= lstat $AbsName;

    while (-l _) {
	if ($SLnkSeen{$DEV, $INO}++) {
	    if ($follow_skip < 2) {
		die "$AbsName is encountered a second time";
	    }
	    else {
		return undef;
	    }
	}
	$NewName= PathCombine($AbsName, readlink($AbsName));
	unless(defined $NewName) {
	    if ($follow_skip < 2) {
		die "$AbsName is a recursive symbolic link";
	    }
	    else {
		return undef;
	    }
	}
	else {
	    $AbsName= $NewName;
	}
	($DEV, $INO) = lstat($AbsName);
	return undef unless defined $DEV;  #  dangling symbolic link
    }

    if ($full_check && defined $DEV && $SLnkSeen{$DEV, $INO}++) {
	if ( ($follow_skip < 1) || ((-d _) && ($follow_skip < 2)) ) {
	    die "$AbsName encountered a second time";
	}
	else {
	    return undef;
	}
    }

    return $AbsName;
}

our($dir, $name, $fullname, $prune);
sub _find_dir_symlnk($$$);
sub _find_dir($$$);

# check whether or not a scalar variable is tainted
# (code straight from the Camel, 3rd ed., page 561)
sub is_tainted_pp {
    my $arg = shift;
    my $nada = substr($arg, 0, 0); # zero-length
    local $@@;
    eval { eval "# $nada" };
    return length($@@) != 0;
}

sub _find_opt {
    my $wanted = shift;
    die "invalid top directory" unless defined $_[0];

    # This function must local()ize everything because callbacks may
    # call find() or finddepth()

    local %SLnkSeen;
    local ($wanted_callback, $avoid_nlink, $bydepth, $no_chdir, $follow,
	$follow_skip, $full_check, $untaint, $untaint_skip, $untaint_pat,
	$pre_process, $post_process, $dangling_symlinks);
    local($dir, $name, $fullname, $prune);
    local *_ = \my $a;

    my $cwd            = $wanted->{bydepth} ? Cwd::fastcwd() : Cwd::getcwd();
    if ($Is_VMS) {
	# VMS returns this by default in VMS format which just doesn't
	# work for the rest of this module.
	$cwd = VMS::Filespec::unixpath($cwd);

	# Apparently this is not expected to have a trailing space.
	# To attempt to make VMS/UNIX conversions mostly reversable,
	# a trailing slash is needed.  The run-time functions ignore the
	# resulting double slash, but it causes the perl tests to fail.
        $cwd =~ s#/\z##;

	# This comes up in upper case now, but should be lower.
	# In the future this could be exact case, no need to change.
    }
    my $cwd_untainted  = $cwd;
    my $check_t_cwd    = 1;
    $wanted_callback   = $wanted->{wanted};
    $bydepth           = $wanted->{bydepth};
    $pre_process       = $wanted->{preprocess};
    $post_process      = $wanted->{postprocess};
    $no_chdir          = $wanted->{no_chdir};
    $full_check        = $Is_Win32 ? 0 : $wanted->{follow};
    $follow            = $Is_Win32 ? 0 :
                             $full_check || $wanted->{follow_fast};
    $follow_skip       = $wanted->{follow_skip};
    $untaint           = $wanted->{untaint};
    $untaint_pat       = $wanted->{untaint_pattern};
    $untaint_skip      = $wanted->{untaint_skip};
    $dangling_symlinks = $wanted->{dangling_symlinks};

    # for compatibility reasons (find.pl, find2perl)
    local our ($topdir, $topdev, $topino, $topmode, $topnlink);

    # a symbolic link to a directory doesn't increase the link count
    $avoid_nlink      = $follow || $File::Find::dont_use_nlink;

    my ($abs_dir, $Is_Dir);

    Proc_Top_Item:
    foreach my $TOP (@@_) {
	my $top_item = $TOP;
	$top_item = VMS::Filespec::unixify($top_item) if $Is_VMS;

	($topdev,$topino,$topmode,$topnlink) = $follow ? stat $top_item : lstat $top_item;

	if ($Is_Win32) {
	    $top_item =~ s|[/\\]\z||
	      unless $top_item =~ m{^(?:\w:)?[/\\]$};
	}
	else {
	    $top_item =~ s|/\z|| unless $top_item eq '/';
	}

	$Is_Dir= 0;

	if ($follow) {

	    if (substr($top_item,0,1) eq '/') {
		$abs_dir = $top_item;
	    }
	    elsif ($top_item eq $File::Find::current_dir) {
		$abs_dir = $cwd;
	    }
	    else {  # care about any  ../
		$top_item =~ s/\.dir\z//i if $Is_VMS;
		$abs_dir = contract_name("$cwd/",$top_item);
	    }
	    $abs_dir= Follow_SymLink($abs_dir);
	    unless (defined $abs_dir) {
		if ($dangling_symlinks) {
		    if (ref $dangling_symlinks eq 'CODE') {
			$dangling_symlinks->($top_item, $cwd);
		    } else {
			warnings::warnif "$top_item is a dangling symbolic link\n";
		    }
		}
		next Proc_Top_Item;
	    }

	    if (-d _) {
		$top_item =~ s/\.dir\z//i if $Is_VMS;
		_find_dir_symlnk($wanted, $abs_dir, $top_item);
		$Is_Dir= 1;
	    }
	}
	else { # no follow
	    $topdir = $top_item;
	    unless (defined $topnlink) {
		warnings::warnif "Can't stat $top_item: $!\n";
		next Proc_Top_Item;
	    }
	    if (-d _) {
		$top_item =~ s/\.dir\z//i if $Is_VMS;
		_find_dir($wanted, $top_item, $topnlink);
		$Is_Dir= 1;
	    }
	    else {
		$abs_dir= $top_item;
	    }
	}

	unless ($Is_Dir) {
	    unless (($_,$dir) = File::Basename::fileparse($abs_dir)) {
		($dir,$_) = ('./', $top_item);
	    }

	    $abs_dir = $dir;
	    if (( $untaint ) && (is_tainted($dir) )) {
		( $abs_dir ) = $dir =~ m|$untaint_pat|;
		unless (defined $abs_dir) {
		    if ($untaint_skip == 0) {
			die "directory $dir is still tainted";
		    }
		    else {
			next Proc_Top_Item;
		    }
		}
	    }

	    unless ($no_chdir || chdir $abs_dir) {
		warnings::warnif "Couldn't chdir $abs_dir: $!\n";
		next Proc_Top_Item;
	    }

	    $name = $abs_dir . $_; # $File::Find::name
	    $_ = $name if $no_chdir;

	    { $wanted_callback->() }; # protect against wild "next"

	}

	unless ( $no_chdir ) {
	    if ( ($check_t_cwd) && (($untaint) && (is_tainted($cwd) )) ) {
		( $cwd_untainted ) = $cwd =~ m|$untaint_pat|;
		unless (defined $cwd_untainted) {
		    die "insecure cwd in find(depth)";
		}
		$check_t_cwd = 0;
	    }
	    unless (chdir $cwd_untainted) {
		die "Can't cd to $cwd: $!\n";
	    }
	}
    }
}

# API:
#  $wanted
#  $p_dir :  "parent directory"
#  $nlink :  what came back from the stat
# preconditions:
#  chdir (if not no_chdir) to dir

sub _find_dir($$$) {
    my ($wanted, $p_dir, $nlink) = @@_;
    my ($CdLvl,$Level) = (0,0);
    my @@Stack;
    my @@filenames;
    my ($subcount,$sub_nlink);
    my $SE= [];
    my $dir_name= $p_dir;
    my $dir_pref;
    my $dir_rel = $File::Find::current_dir;
    my $tainted = 0;
    my $no_nlink;

    if ($Is_Win32) {
	$dir_pref
	  = ($p_dir =~ m{^(?:\w:[/\\]?|[/\\])$} ? $p_dir : "$p_dir/" );
    } elsif ($Is_VMS) {

	#	VMS is returning trailing .dir on directories
	#	and trailing . on files and symbolic links
	#	in UNIX syntax.
	#

	$p_dir =~ s/\.(dir)?$//i unless $p_dir eq '.';

	$dir_pref = ($p_dir =~ m/[\]>]+$/ ? $p_dir : "$p_dir/" );
    }
    else {
	$dir_pref= ( $p_dir eq '/' ? '/' : "$p_dir/" );
    }

    local ($dir, $name, $prune, *DIR);

    unless ( $no_chdir || ($p_dir eq $File::Find::current_dir)) {
	my $udir = $p_dir;
	if (( $untaint ) && (is_tainted($p_dir) )) {
	    ( $udir ) = $p_dir =~ m|$untaint_pat|;
	    unless (defined $udir) {
		if ($untaint_skip == 0) {
		    die "directory $p_dir is still tainted";
		}
		else {
		    return;
		}
	    }
	}
	unless (chdir ($Is_VMS && $udir !~ /[\/\[<]+/ ? "./$udir" : $udir)) {
	    warnings::warnif "Can't cd to $udir: $!\n";
	    return;
	}
    }

    # push the starting directory
    push @@Stack,[$CdLvl,$p_dir,$dir_rel,-1]  if  $bydepth;

    while (defined $SE) {
	unless ($bydepth) {
	    $dir= $p_dir; # $File::Find::dir
	    $name= $dir_name; # $File::Find::name
	    $_= ($no_chdir ? $dir_name : $dir_rel ); # $_
	    # prune may happen here
	    $prune= 0;
	    { $wanted_callback->() };	# protect against wild "next"
	    next if $prune;
	}

	# change to that directory
	unless ($no_chdir || ($dir_rel eq $File::Find::current_dir)) {
	    my $udir= $dir_rel;
	    if ( ($untaint) && (($tainted) || ($tainted = is_tainted($dir_rel) )) ) {
		( $udir ) = $dir_rel =~ m|$untaint_pat|;
		unless (defined $udir) {
		    if ($untaint_skip == 0) {
			die "directory (" . ($p_dir ne '/' ? $p_dir : '') . "/) $dir_rel is still tainted";
		    } else { # $untaint_skip == 1
			next;
		    }
		}
	    }
	    unless (chdir ($Is_VMS && $udir !~ /[\/\[<]+/ ? "./$udir" : $udir)) {
		warnings::warnif "Can't cd to (" .
		    ($p_dir ne '/' ? $p_dir : '') . "/) $udir: $!\n";
		next;
	    }
	    $CdLvl++;
	}

	$dir= $dir_name; # $File::Find::dir

	# Get the list of files in the current directory.
	unless (opendir DIR, ($no_chdir ? $dir_name : $File::Find::current_dir)) {
	    warnings::warnif "Can't opendir($dir_name): $!\n";
	    next;
	}
	@@filenames = readdir DIR;
	closedir(DIR);
	@@filenames = $pre_process->(@@filenames) if $pre_process;
	push @@Stack,[$CdLvl,$dir_name,"",-2]   if $post_process;

	# default: use whatever was specified
        # (if $nlink >= 2, and $avoid_nlink == 0, this will switch back)
        $no_nlink = $avoid_nlink;
        # if dir has wrong nlink count, force switch to slower stat method
        $no_nlink = 1 if ($nlink < 2);

	if ($nlink == 2 && !$no_nlink) {
	    # This dir has no subdirectories.
	    for my $FN (@@filenames) {
		if ($Is_VMS) {
		# Big hammer here - Compensate for VMS trailing . and .dir
		# No win situation until this is changed, but this
		# will handle the majority of the cases with breaking the fewest

		    $FN =~ s/\.dir\z//i;
		    $FN =~ s#\.$## if ($FN ne '.');
		}
		next if $FN =~ $File::Find::skip_pattern;
		
		$name = $dir_pref . $FN; # $File::Find::name
		$_ = ($no_chdir ? $name : $FN); # $_
		{ $wanted_callback->() }; # protect against wild "next"
	    }

	}
	else {
	    # This dir has subdirectories.
	    $subcount = $nlink - 2;

	    # HACK: insert directories at this position. so as to preserve
	    # the user pre-processed ordering of files.
	    # EG: directory traversal is in user sorted order, not at random.
            my $stack_top = @@Stack;

	    for my $FN (@@filenames) {
		next if $FN =~ $File::Find::skip_pattern;
		if ($subcount > 0 || $no_nlink) {
		    # Seen all the subdirs?
		    # check for directoriness.
		    # stat is faster for a file in the current directory
		    $sub_nlink = (lstat ($no_chdir ? $dir_pref . $FN : $FN))[3];

		    if (-d _) {
			--$subcount;
			$FN =~ s/\.dir\z//i if $Is_VMS;
			# HACK: replace push to preserve dir traversal order
			#push @@Stack,[$CdLvl,$dir_name,$FN,$sub_nlink];
			splice @@Stack, $stack_top, 0,
			         [$CdLvl,$dir_name,$FN,$sub_nlink];
		    }
		    else {
			$name = $dir_pref . $FN; # $File::Find::name
			$_= ($no_chdir ? $name : $FN); # $_
			{ $wanted_callback->() }; # protect against wild "next"
		    }
		}
		else {
		    $name = $dir_pref . $FN; # $File::Find::name
		    $_= ($no_chdir ? $name : $FN); # $_
		    { $wanted_callback->() }; # protect against wild "next"
		}
	    }
	}
    }
    continue {
	while ( defined ($SE = pop @@Stack) ) {
	    ($Level, $p_dir, $dir_rel, $nlink) = @@$SE;
	    if ($CdLvl > $Level && !$no_chdir) {
		my $tmp;
		if ($Is_VMS) {
		    $tmp = '[' . ('-' x ($CdLvl-$Level)) . ']';
		}
		else {
		    $tmp = join('/',('..') x ($CdLvl-$Level));
		}
		die "Can't cd to $tmp from $dir_name"
		    unless chdir ($tmp);
		$CdLvl = $Level;
	    }

	    if ($Is_Win32) {
		$dir_name = ($p_dir =~ m{^(?:\w:[/\\]?|[/\\])$}
		    ? "$p_dir$dir_rel" : "$p_dir/$dir_rel");
		$dir_pref = "$dir_name/";
	    }
	    elsif ($^O eq 'VMS') {
                if ($p_dir =~ m/[\]>]+$/) {
                    $dir_name = $p_dir;
                    $dir_name =~ s/([\]>]+)$/.$dir_rel$1/;
                    $dir_pref = $dir_name;
                }
                else {
                    $dir_name = "$p_dir/$dir_rel";
                    $dir_pref = "$dir_name/";
                }
	    }
	    else {
		$dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
		$dir_pref = "$dir_name/";
	    }

	    if ( $nlink == -2 ) {
		$name = $dir = $p_dir; # $File::Find::name / dir
                $_ = $File::Find::current_dir;
		$post_process->();		# End-of-directory processing
	    }
	    elsif ( $nlink < 0 ) {  # must be finddepth, report dirname now
		$name = $dir_name;
		if ( substr($name,-2) eq '/.' ) {
		    substr($name, length($name) == 2 ? -1 : -2) = '';
		}
		$dir = $p_dir;
		$_ = ($no_chdir ? $dir_name : $dir_rel );
		if ( substr($_,-2) eq '/.' ) {
		    substr($_, length($_) == 2 ? -1 : -2) = '';
		}
		{ $wanted_callback->() }; # protect against wild "next"
	     }
	     else {
		push @@Stack,[$CdLvl,$p_dir,$dir_rel,-1]  if  $bydepth;
		last;
	    }
	}
    }
}


# API:
#  $wanted
#  $dir_loc : absolute location of a dir
#  $p_dir   : "parent directory"
# preconditions:
#  chdir (if not no_chdir) to dir

sub _find_dir_symlnk($$$) {
    my ($wanted, $dir_loc, $p_dir) = @@_; # $dir_loc is the absolute directory
    my @@Stack;
    my @@filenames;
    my $new_loc;
    my $updir_loc = $dir_loc; # untainted parent directory
    my $SE = [];
    my $dir_name = $p_dir;
    my $dir_pref;
    my $loc_pref;
    my $dir_rel = $File::Find::current_dir;
    my $byd_flag; # flag for pending stack entry if $bydepth
    my $tainted = 0;
    my $ok = 1;

    $dir_pref = ( $p_dir   eq '/' ? '/' : "$p_dir/" );
    $loc_pref = ( $dir_loc eq '/' ? '/' : "$dir_loc/" );

    local ($dir, $name, $fullname, $prune, *DIR);

    unless ($no_chdir) {
	# untaint the topdir
	if (( $untaint ) && (is_tainted($dir_loc) )) {
	    ( $updir_loc ) = $dir_loc =~ m|$untaint_pat|; # parent dir, now untainted
	     # once untainted, $updir_loc is pushed on the stack (as parent directory);
	    # hence, we don't need to untaint the parent directory every time we chdir
	    # to it later
	    unless (defined $updir_loc) {
		if ($untaint_skip == 0) {
		    die "directory $dir_loc is still tainted";
		}
		else {
		    return;
		}
	    }
	}
	$ok = chdir($updir_loc) unless ($p_dir eq $File::Find::current_dir);
	unless ($ok) {
	    warnings::warnif "Can't cd to $updir_loc: $!\n";
	    return;
	}
    }

    push @@Stack,[$dir_loc,$updir_loc,$p_dir,$dir_rel,-1]  if  $bydepth;

    while (defined $SE) {

	unless ($bydepth) {
	    # change (back) to parent directory (always untainted)
	    unless ($no_chdir) {
		unless (chdir $updir_loc) {
		    warnings::warnif "Can't cd to $updir_loc: $!\n";
		    next;
		}
	    }
	    $dir= $p_dir; # $File::Find::dir
	    $name= $dir_name; # $File::Find::name
	    $_= ($no_chdir ? $dir_name : $dir_rel ); # $_
	    $fullname= $dir_loc; # $File::Find::fullname
	    # prune may happen here
	    $prune= 0;
	    lstat($_); # make sure  file tests with '_' work
	    { $wanted_callback->() }; # protect against wild "next"
	    next if $prune;
	}

	# change to that directory
	unless ($no_chdir || ($dir_rel eq $File::Find::current_dir)) {
	    $updir_loc = $dir_loc;
	    if ( ($untaint) && (($tainted) || ($tainted = is_tainted($dir_loc) )) ) {
		# untaint $dir_loc, what will be pushed on the stack as (untainted) parent dir
		( $updir_loc ) = $dir_loc =~ m|$untaint_pat|;
		unless (defined $updir_loc) {
		    if ($untaint_skip == 0) {
			die "directory $dir_loc is still tainted";
		    }
		    else {
			next;
		    }
		}
	    }
	    unless (chdir $updir_loc) {
		warnings::warnif "Can't cd to $updir_loc: $!\n";
		next;
	    }
	}

	$dir = $dir_name; # $File::Find::dir

	# Get the list of files in the current directory.
	unless (opendir DIR, ($no_chdir ? $dir_loc : $File::Find::current_dir)) {
	    warnings::warnif "Can't opendir($dir_loc): $!\n";
	    next;
	}
	@@filenames = readdir DIR;
	closedir(DIR);

	for my $FN (@@filenames) {
	    if ($Is_VMS) {
	    # Big hammer here - Compensate for VMS trailing . and .dir
	    # No win situation until this is changed, but this
	    # will handle the majority of the cases with breaking the fewest.

		$FN =~ s/\.dir\z//i;
		$FN =~ s#\.$## if ($FN ne '.');
	    }
	    next if $FN =~ $File::Find::skip_pattern;

	    # follow symbolic links / do an lstat
	    $new_loc = Follow_SymLink($loc_pref.$FN);

	    # ignore if invalid symlink
	    unless (defined $new_loc) {
	        if (!defined -l _ && $dangling_symlinks) {
	            if (ref $dangling_symlinks eq 'CODE') {
	                $dangling_symlinks->($FN, $dir_pref);
	            } else {
	                warnings::warnif "$dir_pref$FN is a dangling symbolic link\n";
	            }
	        }

	        $fullname = undef;
	        $name = $dir_pref . $FN;
	        $_ = ($no_chdir ? $name : $FN);
	        { $wanted_callback->() };
	        next;
	    }

	    if (-d _) {
		if ($Is_VMS) {
		    $FN =~ s/\.dir\z//i;
		    $FN =~ s#\.$## if ($FN ne '.');
		    $new_loc =~ s/\.dir\z//i;
		    $new_loc =~ s#\.$## if ($new_loc ne '.');
		}
		push @@Stack,[$new_loc,$updir_loc,$dir_name,$FN,1];
	    }
	    else {
		$fullname = $new_loc; # $File::Find::fullname
		$name = $dir_pref . $FN; # $File::Find::name
		$_ = ($no_chdir ? $name : $FN); # $_
		{ $wanted_callback->() }; # protect against wild "next"
	    }
	}

    }
    continue {
	while (defined($SE = pop @@Stack)) {
	    ($dir_loc, $updir_loc, $p_dir, $dir_rel, $byd_flag) = @@$SE;
	    $dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
	    $dir_pref = "$dir_name/";
	    $loc_pref = "$dir_loc/";
	    if ( $byd_flag < 0 ) {  # must be finddepth, report dirname now
		unless ($no_chdir || ($dir_rel eq $File::Find::current_dir)) {
		    unless (chdir $updir_loc) { # $updir_loc (parent dir) is always untainted
			warnings::warnif "Can't cd to $updir_loc: $!\n";
			next;
		    }
		}
		$fullname = $dir_loc; # $File::Find::fullname
		$name = $dir_name; # $File::Find::name
		if ( substr($name,-2) eq '/.' ) {
		    substr($name, length($name) == 2 ? -1 : -2) = ''; # $File::Find::name
		}
		$dir = $p_dir; # $File::Find::dir
		$_ = ($no_chdir ? $dir_name : $dir_rel); # $_
		if ( substr($_,-2) eq '/.' ) {
		    substr($_, length($_) == 2 ? -1 : -2) = '';
		}

		lstat($_); # make sure file tests with '_' work
		{ $wanted_callback->() }; # protect against wild "next"
	    }
	    else {
		push @@Stack,[$dir_loc, $updir_loc, $p_dir, $dir_rel,-1]  if  $bydepth;
		last;
	    }
	}
    }
}


sub wrap_wanted {
    my $wanted = shift;
    if ( ref($wanted) eq 'HASH' ) {
        unless( exists $wanted->{wanted} and ref( $wanted->{wanted} ) eq 'CODE' ) {
            die 'no &wanted subroutine given';
        }
	if ( $wanted->{follow} || $wanted->{follow_fast}) {
	    $wanted->{follow_skip} = 1 unless defined $wanted->{follow_skip};
	}
	if ( $wanted->{untaint} ) {
	    $wanted->{untaint_pattern} = $File::Find::untaint_pattern
		unless defined $wanted->{untaint_pattern};
	    $wanted->{untaint_skip} = 0 unless defined $wanted->{untaint_skip};
	}
	return $wanted;
    }
    elsif( ref( $wanted ) eq 'CODE' ) {
	return { wanted => $wanted };
    }
    else {
       die 'no &wanted subroutine given';
    }
}

sub find {
    my $wanted = shift;
    _find_opt(wrap_wanted($wanted), @@_);
}

sub finddepth {
    my $wanted = wrap_wanted(shift);
    $wanted->{bydepth} = 1;
    _find_opt($wanted, @@_);
}

# default
$File::Find::skip_pattern    = qr/^\.{1,2}\z/;
$File::Find::untaint_pattern = qr|^([-+@@\w./]+)$|;

# These are hard-coded for now, but may move to hint files.
if ($^O eq 'VMS') {
    $Is_VMS = 1;
    $File::Find::dont_use_nlink  = 1;
}
elsif ($^O eq 'MSWin32') {
    $Is_Win32 = 1;
}

# this _should_ work properly on all platforms
# where File::Find can be expected to work
$File::Find::current_dir = File::Spec->curdir || '.';

$File::Find::dont_use_nlink = 1
    if $^O eq 'os2' || $^O eq 'dos' || $^O eq 'amigaos' || $Is_Win32 ||
       $^O eq 'interix' || $^O eq 'cygwin' || $^O eq 'qnx' || $^O eq 'nto';

# Set dont_use_nlink in your hint file if your system's stat doesn't
# report the number of links in a directory as an indication
# of the number of files.
# See, e.g. hints/machten.sh for MachTen 2.2.
unless ($File::Find::dont_use_nlink) {
    require Config;
    $File::Find::dont_use_nlink = 1 if ($Config::Config{'dont_use_nlink'});
}

# We need a function that checks if a scalar is tainted. Either use the
# Scalar::Util module's tainted() function or our (slower) pure Perl
# fallback is_tainted_pp()
{
    local $@@;
    eval { require Scalar::Util };
    *is_tainted = $@@ ? \&is_tainted_pp : \&Scalar::Util::tainted;
}

1;
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d6 1
a6 1
our $VERSION = '1.20';
d283 8
d526 1
d1107 1
a1107 2
       $^O eq 'interix' || $^O eq 'cygwin' || $^O eq 'epoc' || $^O eq 'qnx' ||
	   $^O eq 'nto';
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d6 1
a6 1
our $VERSION = '1.15';
d11 1
a11 1
# Modified to ensure sub-directory traversal order is not inverded by stack
d117 1
a117 1
directory tree. See I<follow_fast> and I<follow_skip> below.
a326 75
=head1 NOTES

=over 4

=item *

Mac OS (Classic) users should note a few differences:

=over 4

=item *

The path separator is ':', not '/', and the current directory is denoted
as ':', not '.'. You should be careful about specifying relative pathnames.
While a full path always begins with a volume name, a relative pathname
should always begin with a ':'.  If specifying a volume name only, a
trailing ':' is required.

=item *

C<$File::Find::dir> is guaranteed to end with a ':'. If C<$_>
contains the name of a directory, that name may or may not end with a
':'. Likewise, C<$File::Find::name>, which contains the complete
pathname to that directory, and C<$File::Find::fullname>, which holds
the absolute pathname of that directory with all symbolic links resolved,
may or may not end with a ':'.

=item *

The default C<untaint_pattern> (see above) on Mac OS is set to
C<qr|^(.+)$|>. Note that the parentheses are vital.

=item *

The invisible system file "Icon\015" is ignored. While this file may
appear in every directory, there are some more invisible system files
on every volume, which are all located at the volume root level (i.e.
"MacintoshHD:"). These system files are B<not> excluded automatically.
Your filter may use the following code to recognize invisible files or
directories (requires Mac::Files):

 use Mac::Files;

 # invisible() --  returns 1 if file/directory is invisible,
 # 0 if it's visible or undef if an error occurred

 sub invisible($) {
   my $file = shift;
   my ($fileCat, $fileInfo);
   my $invisible_flag =  1 << 14;

   if ( $fileCat = FSpGetCatInfo($file) ) {
     if ($fileInfo = $fileCat->ioFlFndrInfo() ) {
       return (($fileInfo->fdFlags & $invisible_flag) && 1);
     }
   }
   return undef;
 }

Generally, invisible files are system files, unless an odd application
decides to use invisible files for its own purposes. To distinguish
such files from system files, you have to look at the B<type> and B<creator>
file attributes. The MacPerl built-in functions C<GetFileInfo(FILE)> and
C<SetFileInfo(CREATOR, TYPE, FILES)> offer access to these attributes
(see MacPerl.pm for details).

Files that appear on the desktop actually reside in an (hidden) directory
named "Desktop Folder" on the particular disk volume. Note that, although
all desktop files appear to be on the same "virtual" desktop, each disk
volume actually maintains its own "Desktop Folder" directory.

=back

=back

d351 1
a351 1
my $Is_MacOS;
a381 47
# return the absolute name of a directory or file
sub contract_name_Mac {
    my ($cdir,$fn) = @@_;
    my $abs_name;

    if ($fn =~ /^(:+)(.*)$/) { # valid pathname starting with a ':'

	my $colon_count = length ($1);
	if ($colon_count == 1) {
	    $abs_name = $cdir . $2;
	    return $abs_name;
	}
	else {
	    # need to move up the tree, but
	    # only if it's not a volume name
	    for (my $i=1; $i<$colon_count; $i++) {
		unless ($cdir =~ /^[^:]+:$/) { # volume name
		    $cdir =~ s/[^:]+:$//;
		}
		else {
		    return undef;
		}
	    }
	    $abs_name = $cdir . $2;
	    return $abs_name;
	}

    }
    else {

	# $fn may be a valid path to a directory or file or (dangling)
	# symlink, without a leading ':'
	if ( (-e $fn) || (-l $fn) ) {
	    if ($fn =~ /^[^:]+:/) { # a volume name like DataHD:*
		return $fn; # $fn is already an absolute path
	    }
	    else {
		$abs_name = $cdir . $fn;
		return $abs_name;
	    }
	}
	else { # argh!, $fn is not a valid directory/file
	     return undef;
	}
    }
}

d386 2
a387 9
    if ($Is_MacOS) {
	# $Name is the resolved symlink (always a full path on MacOS),
	# i.e. there's no need to call contract_name_Mac()
	$AbsName = $Name;

	# (simple) check for recursion
	if ( ( $Base =~ /^$AbsName/) && (-d $AbsName) ) { # recursion
	    return undef;
	}
d390 2
a391 6
	if (substr($Name,0,1) eq '/') {
	    $AbsName= $Name;
	}
	else {
	    $AbsName= contract_name($Base,$Name);
	}
d393 7
a399 8
	# (simple) check for recursion
	my $newlen= length($AbsName);
	if ($newlen <= length($Base)) {
	    if (($newlen == length($Base) || substr($Base,$newlen,1) eq '/')
		&& $AbsName eq substr($Base,0,$newlen))
	    {
		return undef;
	    }
d498 2
a499 2
    $full_check        = $^O eq 'MSWin32' ? 0 : $wanted->{follow};
    $follow            = $^O eq 'MSWin32' ? 0 :
d521 3
a523 5
	if ($Is_MacOS) {
	    $top_item = ":$top_item"
		if ( (-d _) && ( $top_item !~ /:/ ) );
	} elsif ($^O eq 'MSWin32') {
	    $top_item =~ s|/\z|| unless $top_item =~ m|\w:/$|;
d533 5
a537 14
	    if ($Is_MacOS) {
		$cwd = "$cwd:" unless ($cwd =~ /:$/); # for safety

		if ($top_item eq $File::Find::current_dir) {
		    $abs_dir = $cwd;
		}
		else {
		    $abs_dir = contract_name_Mac($cwd, $top_item);
		    unless (defined $abs_dir) {
			warnings::warnif "Can't determine absolute path for $top_item (No such file or directory)\n";
			next Proc_Top_Item;
		    }
		}

d539 3
a541 11
	    else {
		if (substr($top_item,0,1) eq '/') {
		    $abs_dir = $top_item;
		}
		elsif ($top_item eq $File::Find::current_dir) {
		    $abs_dir = $cwd;
		}
		else {  # care about any  ../
		    $top_item =~ s/\.dir\z//i if $Is_VMS;
		    $abs_dir = contract_name("$cwd/",$top_item);
		}
d579 1
a579 6
		if ($Is_MacOS) {
		    ($dir,$_) = (':', $top_item); # $File::Find::dir, $_
		}
		else {
		    ($dir,$_) = ('./', $top_item);
		}
d642 4
a645 5
    if ($Is_MacOS) {
	$dir_pref= ($p_dir =~ /:$/) ? $p_dir : "$p_dir:"; # preface
    } elsif ($^O eq 'MSWin32') {
	$dir_pref = ($p_dir =~ m|\w:/?$| ? $p_dir : "$p_dir/" );
    } elsif ($^O eq 'VMS') {
a683 4
    if ($Is_MacOS) {
	$p_dir = $dir_pref;  # ensure trailing ':'
    }

d702 1
a702 6
			if ($Is_MacOS) {
			    die "directory ($p_dir) $dir_rel is still tainted";
			}
			else {
			    die "directory (" . ($p_dir ne '/' ? $p_dir : '') . "/) $dir_rel is still tainted";
			}
d709 2
a710 7
		if ($Is_MacOS) {
		    warnings::warnif "Can't cd to ($p_dir) $udir: $!\n";
		}
		else {
		    warnings::warnif "Can't cd to (" .
			($p_dir ne '/' ? $p_dir : '') . "/) $udir: $!\n";
		}
a715 4
	if ($Is_MacOS) {
	    $dir_name = "$dir_name:" unless ($dir_name =~ /:$/);
	}

d728 1
a728 1
	# default: use whatever was specifid
d797 1
a797 4
		if ($Is_MacOS) {
		    $tmp = (':' x ($CdLvl-$Level)) . ':';
		}
		elsif ($Is_VMS) {
d808 3
a810 8
	    if ($Is_MacOS) {
		# $pdir always has a trailing ':', except for the starting dir,
		# where $dir_rel eq ':'
		$dir_name = "$p_dir$dir_rel";
		$dir_pref = "$dir_name:";
	    }
	    elsif ($^O eq 'MSWin32') {
		$dir_name = ($p_dir =~ m|\w:/?$| ? "$p_dir$dir_rel" : "$p_dir/$dir_rel");
d836 2
a837 7
		if ($Is_MacOS) {
		    if ($dir_rel eq ':') { # must be the top dir, where we started
			$name =~ s|:$||; # $File::Find::name
			$p_dir = "$p_dir:" unless ($p_dir =~ /:$/);
		    }
		    $dir = $p_dir; # $File::Find::dir
		    $_ = ($no_chdir ? $name : $dir_rel); # $_
d839 4
a842 9
		else {
		    if ( substr($name,-2) eq '/.' ) {
			substr($name, length($name) == 2 ? -1 : -2) = '';
		    }
		    $dir = $p_dir;
		    $_ = ($no_chdir ? $dir_name : $dir_rel );
		    if ( substr($_,-2) eq '/.' ) {
			substr($_, length($_) == 2 ? -1 : -2) = '';
		    }
d877 2
a878 7
    if ($Is_MacOS) {
	$dir_pref = ($p_dir =~ /:$/) ? "$p_dir" : "$p_dir:";
	$loc_pref = ($dir_loc =~ /:$/) ? "$dir_loc" : "$dir_loc:";
    } else {
	$dir_pref = ( $p_dir   eq '/' ? '/' : "$p_dir/" );
	$loc_pref = ( $dir_loc eq '/' ? '/' : "$dir_loc/" );
    }
a906 4
    if ($Is_MacOS) {
	$p_dir = $dir_pref; # ensure trailing ':'
    }

a948 4
	if ($Is_MacOS) {
	    $dir_name = "$dir_name:" unless ($dir_name =~ /:$/);
	}

d1011 3
a1013 12
	    if ($Is_MacOS) {
		# $p_dir always has a trailing ':', except for the starting dir,
		# where $dir_rel eq ':'
		$dir_name = "$p_dir$dir_rel";
		$dir_pref = "$dir_name:";
		$loc_pref = ($dir_loc =~ /:$/) ? $dir_loc : "$dir_loc:";
	    }
	    else {
		$dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
		$dir_pref = "$dir_name/";
		$loc_pref = "$dir_loc/";
	    }
d1023 2
a1024 7
		if ($Is_MacOS) {
		    if ($dir_rel eq ':') { # must be the top dir, where we started
			$name =~ s|:$||; # $File::Find::name
			$p_dir = "$p_dir:" unless ($p_dir =~ /:$/);
		    }
		    $dir = $p_dir; # $File::Find::dir
		     $_ = ($no_chdir ? $name : $dir_rel); # $_
d1026 4
a1029 9
		else {
		    if ( substr($name,-2) eq '/.' ) {
			substr($name, length($name) == 2 ? -1 : -2) = ''; # $File::Find::name
		    }
		    $dir = $p_dir; # $File::Find::dir
		    $_ = ($no_chdir ? $dir_name : $dir_rel); # $_
		    if ( substr($_,-2) eq '/.' ) {
			substr($_, length($_) == 2 ? -1 : -2) = '';
		    }
d1088 2
a1089 5
elsif ($^O eq 'MacOS') {
    $Is_MacOS = 1;
    $File::Find::dont_use_nlink  = 1;
    $File::Find::skip_pattern    = qr/^Icon\015\z/;
    $File::Find::untaint_pattern = qr|^(.+)$|;
d1097 1
a1097 1
    if $^O eq 'os2' || $^O eq 'dos' || $^O eq 'amigaos' || $^O eq 'MSWin32' ||
@


1.12
log
@Merge in perl 5.10.1
@
text
@d6 1
a6 1
our $VERSION = '1.14';
d220 1
a220 1
effecting data outside of the wanted function.
d451 1
a451 1
       1 while $abs_name =~ s!/[^/]*/\.\./!/!;
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d6 1
a6 1
our $VERSION = '1.12';
d81 2
a82 1
described in L<The wanted function> below.
d88 1
a88 1
specifying C<<{ bydepth => 1 }>> in the first argument of C<find()>.
d245 1
a245 1
When <follow> or <follow_fast> are in effect, there is
d414 4
d803 1
a803 1
	$dir_pref = ($p_dir =~ m|\w:/$| ? $p_dir : "$p_dir/" );
d995 1
a995 1
		$dir_name = ($p_dir =~ m|\w:/$| ? "$p_dir$dir_rel" : "$p_dir/$dir_rel");
d1274 3
d1287 3
d1291 1
a1291 1
	return { wanted => $wanted };
@


1.10
log
@merge in perl 5.8.8
@
text
@d6 1
a6 1
our $VERSION = '1.10';
d59 1
a59 1
C<finddepth()> works just like C<find()> except that is invokes the
d218 2
a219 1
Don't modify these variables.
d606 14
d687 1
d704 1
d799 10
d909 8
d972 3
d978 1
a978 1
		die "Can't cd to $dir_name" . $tmp
d993 11
d1163 8
d1178 1
a1178 1
	        if ($dangling_symlinks) {
d1194 6
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d6 1
a6 1
our $VERSION = '1.07';
d91 2
a92 2
The value should be a code reference. This code reference is used to 
preprocess the current directory. The name of the currently processed 
d95 4
a98 4
function. It is called with a list of strings (actually file/directory 
names) and is expected to return a list of strings. The code can be 
used to sort the file/directory names alphabetically, numerically, 
or to filter out directory entries based on their name alone. When 
d103 5
a107 5
The value should be a code reference. It is invoked just before leaving 
the currently processed directory. It is called in void context with no 
arguments. The name of the current directory is in C<$File::Find::dir>. This 
hook is handy for summarizing a directory, such as calculating its disk 
usage. When I<follow> or I<follow_fast> are in effect, C<postprocess> is a 
d124 3
a126 1
C<wanted()> function is called. This enables fast file checks involving S< _>.
d131 2
a132 1
pathname of the file with all symbolic links resolved
d136 2
d146 2
d152 1
a152 1
to be processed a second time. If a directory or a symbolic link 
d180 2
a181 2
expression I<untaint_pattern>.  Note that all names passed to the user's 
I<wanted()> function are still tainted. If this option is used while 
d187 1
a187 1
The default is set to  C<qr|^([-+@@\w./]+)$|>. 
d192 1
a192 1
If set, a directory which fails the I<untaint_pattern> is skipped, 
d226 1
a226 1
You are chdir()'d toC<$File::Find::dir> when the function is called,
d318 1
a318 1
more than once (only if C<follow_fast> is in effect). 
d335 1
a335 1
=item *   
d337 4
a340 4
The path separator is ':', not '/', and the current directory is denoted 
as ':', not '.'. You should be careful about specifying relative pathnames. 
While a full path always begins with a volume name, a relative pathname 
should always begin with a ':'.  If specifying a volume name only, a 
d343 1
a343 1
=item *   
d345 4
a348 4
C<$File::Find::dir> is guaranteed to end with a ':'. If C<$_> 
contains the name of a directory, that name may or may not end with a 
':'. Likewise, C<$File::Find::name>, which contains the complete 
pathname to that directory, and C<$File::Find::fullname>, which holds 
d352 1
a352 1
=item *   
d354 1
a354 1
The default C<untaint_pattern> (see above) on Mac OS is set to  
d357 1
a357 1
=item *   
d359 5
a363 5
The invisible system file "Icon\015" is ignored. While this file may 
appear in every directory, there are some more invisible system files 
on every volume, which are all located at the volume root level (i.e. 
"MacintoshHD:"). These system files are B<not> excluded automatically. 
Your filter may use the following code to recognize invisible files or 
d368 1
a368 1
 # invisible() --  returns 1 if file/directory is invisible,  
d371 1
a371 1
 sub invisible($) { 
d373 2
a374 2
   my ($fileCat, $fileInfo); 
   my $invisible_flag =  1 << 14; 
d384 5
a388 5
Generally, invisible files are system files, unless an odd application 
decides to use invisible files for its own purposes. To distinguish 
such files from system files, you have to look at the B<type> and B<creator> 
file attributes. The MacPerl built-in functions C<GetFileInfo(FILE)> and 
C<SetFileInfo(CREATOR, TYPE, FILES)> offer access to these attributes 
d393 1
a393 1
all desktop files appear to be on the same "virtual" desktop, each disk 
d453 1
a453 1
    my ($cdir,$fn) = @@_; 
d463 2
a464 2
	else { 
	    # need to move up the tree, but 
d492 1
a492 1
	else { # argh!, $fn is not a valid directory/file 
d505 1
a505 1
	$AbsName = $Name; 
d588 1
a588 1
} 
d612 3
a614 2
    $full_check        = $wanted->{follow};
    $follow            = $full_check || $wanted->{follow_fast};
d626 1
a626 1
    
d633 2
a635 1
	    ($topdev,$topino,$topmode,$topnlink) = $follow ? stat $top_item : lstat $top_item;
d638 2
a642 1
	    ($topdev,$topino,$topmode,$topnlink) = $follow ? stat $top_item : lstat $top_item;
d780 2
d817 2
a818 2
	    $dir= $p_dir; # $File::Find::dir 
	    $name= $dir_name; # $File::Find::name 
d840 1
a840 1
			next; 
d861 1
a861 1
	$dir= $dir_name; # $File::Find::dir 
d951 4
d1033 2
a1034 2
	    # hence, we don't need to untaint the parent directory every time we chdir 
	    # to it later 
d1082 1
a1082 1
		# untaint $dir_loc, what will be pushed on the stack as (untainted) parent dir 
d1120 15
a1134 1
	    next unless defined $new_loc;
d1140 1
a1140 1
		$fullname = $new_loc; # $File::Find::fullname 
d1165 1
a1165 1
		    unless (chdir $updir_loc) { # $updir_loc (parent dir) is always untainted 
d1210 1
a1210 1
	    $wanted->{untaint_pattern} = $File::Find::untaint_pattern  
d1254 1
a1254 1
       $^O eq 'cygwin' || $^O eq 'epoc' || $^O eq 'qnx' ||
d1266 2
a1267 2
# We need a function that checks if a scalar is tainted. Either use the 
# Scalar::Util module's tainted() function or our (slower) pure Perl 
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d6 1
a6 1
our $VERSION = '1.06';
d47 6
a52 7
C<find()> does a breadth-first search over the given C<@@directories> in the
order they are given.  In essence, it works from the top down.

For each file or directory found, the C<&wanted> subroutine is called,
with the return code ignored.  (See below for details on how to use
the C<&wanted> function).  Additionally, for each directory found,
it will go into that directory and continue the search.
d59 5
a63 2
C<finddepth()> works just like C<find()> except it does a depth-first search.
It works from the bottom of the directory tree up.
d393 6
d594 2
a595 1
    local($dir, $name, $fullname, $prune, $_);
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d6 1
a6 1
our $VERSION = '1.05';
d47 1
a47 1
find() does a breadth-first search over the given @@directories in the
d50 4
a53 3
For each file or directory found the &wanted subroutine is called (see
below for details).  Additionally, for each directory found it will go
into that directory and continue the search.
d60 1
a60 1
finddepth() works just like find() except it does a depth-first search.
d67 3
a69 2
The first argument to find() is either a hash reference describing the
operations to be performed for each file, or a code reference.  The
d84 2
a85 2
have been reported.  Entry point finddepth() is a shortcut for
specifying C<{ bydepth =E<gt> 1 }> in the first argument of find().
d90 3
a92 3
preprocess the current directory. The name of currently processed 
directory is in $File::Find::dir. Your preprocessing function is 
called after readdir() but before the loop that calls the wanted() 
d103 1
a103 1
arguments. The name of the current directory is in $File::Find::dir. This 
d122 1
a122 1
I<wanted()> function is called. This enables fast file checks involving S< _>.
d136 1
a136 1
processing a file more than once (by the user's I<wanted()> function)
d145 1
d148 1
d162 1
a162 1
Does not C<chdir()> to each directory as it recurses. The wanted()
d190 7
a196 2
The wanted() function does whatever verifications you want on each
file and directory.  It takes no arguments but rather does its work
d211 1
a211 1
For example, when examining the file /some/path/foo.ext you will have:
d263 1
a263 1
stat(), lstat(), or filetest.
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d6 1
a6 1
our $VERSION = '1.04';
d10 6
d23 1
a23 1
    find(\&wanted, @@directories_to_seach);
d48 1
a48 1
order they are given.  In essense, it works from the top down.
d577 1
a577 1
    local($dir, $name, $fullname, $prune);
d671 1
a671 1
		$top_item =~ s/\.dir\z// if $Is_VMS;
d709 1
d772 1
a772 1
	unless (chdir $udir) {
d814 1
a814 1
	    unless (chdir $udir) {
d864 5
d879 5
a883 2
			$FN =~ s/\.dir\z// if $Is_VMS;
			push @@Stack,[$CdLvl,$dir_name,$FN,$sub_nlink];
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 5
a6 1
use 5.005_64;
d12 1
a12 3
find - traverse a file tree

finddepth - traverse a directory structure depth-first
d17 1
a17 1
    find(\&wanted, '/foo', '/bar');
d21 1
a21 1
    finddepth(\&wanted, '/foo', '/bar');
d29 31
d61 2
a62 1
operations to be performed for each file, or a code reference.
d70 2
a71 2
The value should be a code reference.  This code reference is called
I<the wanted() function> below.
d77 1
a77 1
specifying C<{ bydepth => 1 }> in the first argument of find().
d81 9
a89 6
The value should be a code reference.  This code reference is used to
preprocess a directory; it is called after readdir() but before the loop that
calls the wanted() function.  It is called with a list of strings and is
expected to return a list of strings.  The code can be used to sort the
strings alphabetically, numerically, or to filter out directory entries based
on their name alone.
d93 6
a98 4
The value should be a code reference.  It is invoked just before leaving the
current directory.  It is called in void context with no arguments.  The name
of the current directory is in $File::Find::dir.  This hook is handy for
summarizing a directory, such as calculating its disk usage.
d140 3
a142 1
dirctories but to proceed normally otherwise.
d144 5
d160 4
a163 3
before they can be cd'ed to. Therefore they are checked against a regular
expression I<untaint_pattern>.  Note that all names passed to the
user's I<wanted()> function are still tainted. 
d169 1
a169 1
Note that the parantheses are vital.
d173 18
a190 2
If set, directories (subtrees) which fail the I<untaint_pattern>
are skipped. The default is to 'die' in such a case.
d194 26
a219 6
The wanted() function does whatever verifications you want.
C<$File::Find::dir> contains the current directory name, and C<$_> the
current filename within that directory.  C<$File::Find::name> contains
the complete pathname to the file. You are chdir()'d to
C<$File::Find::dir> when the function is called, unless C<no_chdir>
was specified.  When <follow> or <follow_fast> are in effect, there is
d246 3
a248 3
Set the variable C<$File::Find::dont_use_nlink> if you're using AFS,
since AFS cheats.

d250 2
a251 2
Here's another interesting wanted function.  It will find all symlinks
that don't resolve:
d260 11
d273 18
d299 82
d384 2
a385 2
@@ISA = qw(Exporter);
@@EXPORT = qw(find finddepth);
d390 1
d393 1
d395 5
a399 2
my %SLnkSeen;
my ($wanted_callback, $avoid_nlink, $bydepth, $no_chdir, $follow,
d401 1
a401 1
    $pre_process, $post_process);
d406 1
a406 1
    return substr($cdir,0,rindex($cdir,'/')) if $fn eq '.';
d415 1
a415 1
	do 1 while ($abs_name=~ s|/(?>[^/]+)/\.\./|/|);
d421 46
d472 9
a480 2
    if (substr($Name,0,1) eq '/') {
	$AbsName= $Name;
d483 6
a488 2
	$AbsName= contract_name($Base,$Name);
    }
d490 8
a497 7
    # (simple) check for recursion
    my $newlen= length($AbsName);
    if ($newlen <= length($Base)) {
	if (($newlen == length($Base) || substr($Base,$newlen,1) eq '/')
	    && $AbsName eq substr($Base,0,$newlen))
	{
	    return undef;
d534 2
a535 2
    if ($full_check && $SLnkSeen{$DEV, $INO}++) {
	if ($follow_skip < 1) {
d550 10
d564 24
a587 13
    my $cwd           = $wanted->{bydepth} ? Cwd::fastcwd() : Cwd::cwd();
    my $cwd_untainted = $cwd;
    $wanted_callback  = $wanted->{wanted};
    $bydepth          = $wanted->{bydepth};
    $pre_process      = $wanted->{preprocess};
    $post_process     = $wanted->{postprocess};
    $no_chdir         = $wanted->{no_chdir};
    $full_check       = $wanted->{follow};
    $follow           = $full_check || $wanted->{follow_fast};
    $follow_skip      = $wanted->{follow_skip};
    $untaint          = $wanted->{untaint};
    $untaint_pat      = $wanted->{untaint_pattern};
    $untaint_skip     = $wanted->{untaint_skip};
d589 2
a590 2
    # for compatability reasons (find.pl, find2perl)
    our ($topdir, $topdev, $topino, $topmode, $topnlink);
a594 5
    if ( $untaint ) {
	$cwd_untainted= $1 if $cwd_untainted =~ m|$untaint_pat|;
	die "insecure cwd in find(depth)"  unless defined($cwd_untainted);
    }
    
d599 51
a649 19
        my $top_item = $TOP;
        $top_item =~ s|/\z|| unless $top_item eq '/';
        $Is_Dir= 0;
        
        ($topdev,$topino,$topmode,$topnlink) = stat $top_item;

        if ($follow) {
            if (substr($top_item,0,1) eq '/') {
                $abs_dir = $top_item;
            }
	    elsif ($top_item eq '.') {
		$abs_dir = $cwd;
	    }
            else {  # care about any  ../
		$abs_dir = contract_name("$cwd/",$top_item); 
            }
            $abs_dir= Follow_SymLink($abs_dir);
            unless (defined $abs_dir) {
		warn "$top_item is a dangling symbolic link\n";
d651 3
a653 2
            }
            if (-d _) {
d656 2
a657 2
            }
        }
d659 6
a664 6
            $topdir = $top_item;
            unless (defined $topnlink) {
                warn "Can't stat $top_item: $!\n";
                next Proc_Top_Item;
            }
            if (-d _) {
d668 1
a668 1
            }
d671 2
a672 2
            }
        }
d674 1
a674 1
        unless ($Is_Dir) {
d676 6
a681 1
		($dir,$_) = ('./', $top_item);
d684 3
a686 4
            $abs_dir = $dir;
            if ($untaint) {
		my $abs_dir_save = $abs_dir;
		$abs_dir = $1 if $abs_dir =~ m|$untaint_pat|;
d689 1
a689 1
			die "directory $abs_dir_save is still tainted";
d695 1
a695 1
            }
d697 4
a700 4
            unless ($no_chdir or chdir $abs_dir) {
                warn "Couldn't chdir $abs_dir: $!\n";
                next Proc_Top_Item;
            }
d702 1
a702 1
            $name = $abs_dir . $_;
d704 1
a704 1
            { &$wanted_callback }; # protect against wild "next"
d706 1
a706 1
        }
d708 12
a719 1
        $no_chdir or chdir $cwd_untainted;
d738 11
a748 2
    my $dir_pref= ( $p_dir eq '/' ? '/' : "$p_dir/" );
    my $dir_rel= '.';      # directory name relative to current directory
d751 2
a752 2
     
    unless ($no_chdir or $p_dir eq '.') {
d754 2
a755 2
	if ($untaint) {
	    $udir = $1 if $p_dir =~ m|$untaint_pat|;
d766 1
a766 1
	    warn "Can't cd to $udir: $!\n";
d770 2
a771 1
    
d774 4
d780 3
a782 3
            $dir= $p_dir;
            $name= $dir_name;
            $_= ($no_chdir ? $dir_name : $dir_rel );
d784 3
a786 3
            $prune= 0;
            { &$wanted_callback }; 	# protect against wild "next"
            next if $prune;
d788 1
a788 1
      
d790 1
a790 1
	unless ($no_chdir or $dir_rel eq '.') {
d792 2
a793 2
	    if ($untaint) {
		$udir = $1 if $dir_rel =~ m|$untaint_pat|;
d796 8
a803 3
			die "directory ("
			    . ($p_dir ne '/' ? $p_dir : '')
			    . "/) $dir_rel is still tainted";
d808 7
a814 3
		warn "Can't cd to ("
		    . ($p_dir ne '/' ? $p_dir : '')
		    . "/) $udir : $!\n";
d820 5
a824 1
	$dir= $dir_name;
d827 2
a828 2
	unless (opendir DIR, ($no_chdir ? $dir_name : '.')) {
	    warn "Can't opendir($dir_name): $!\n";
d833 1
a833 1
	@@filenames = &$pre_process(@@filenames) if $pre_process;
d836 7
a842 1
	if ($nlink == 2 && !$avoid_nlink) {
d845 1
a845 1
		next if $FN =~ /^\.{1,2}\z/;
d847 3
a849 3
		$name = $dir_pref . $FN;
		$_ = ($no_chdir ? $name : $FN);
		{ &$wanted_callback }; # protect against wild "next"
d858 2
a859 2
		next if $FN =~ /^\.{1,2}\z/;
		if ($subcount > 0 || $avoid_nlink) {
d871 3
a873 3
			$name = $dir_pref . $FN;
			$_= ($no_chdir ? $name : $FN);
			{ &$wanted_callback }; # protect against wild "next"
d877 3
a879 3
		    $name = $dir_pref . $FN;
		    $_= ($no_chdir ? $name : $FN);
		    { &$wanted_callback }; # protect against wild "next"
d888 9
a896 3
                my $tmp = join('/',('..') x ($CdLvl-$Level));
                die "Can't cd to $dir_name" . $tmp
                    unless chdir ($tmp);
d899 12
a910 2
	    $dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
	    $dir_pref = "$dir_name/";
d912 30
a941 18
		$name = $dir = $p_dir;
		$_ = ".";
		&$post_process;		# End-of-directory processing
            } elsif ( $nlink < 0 ) {  # must be finddepth, report dirname now
                $name = $dir_name;
                if ( substr($name,-2) eq '/.' ) {
                  $name =~ s|/\.$||;
                }
                $dir = $p_dir;
                $_ = ($no_chdir ? $dir_name : $dir_rel );
                if ( substr($_,-2) eq '/.' ) {
                  s|/\.$||;
                }
                { &$wanted_callback }; # protect against wild "next"
            } else {
                push @@Stack,[$CdLvl,$p_dir,$dir_rel,-1]  if  $bydepth;
                last;
            }
d955 1
a955 1
    my ($wanted, $dir_loc, $p_dir) = @@_;
d959 1
a959 1
    my $pdir_loc = $dir_loc;
d962 14
a975 4
    my $dir_pref = ( $p_dir   eq '/' ? '/' : "$p_dir/" );
    my $loc_pref = ( $dir_loc eq '/' ? '/' : "$dir_loc/" );
    my $dir_rel = '.';		# directory name relative to current directory
    my $byd_flag;               # flag for pending stack entry if $bydepth
d978 9
a986 6
    
    unless ($no_chdir or $p_dir eq '.') {
	my $udir = $dir_loc;
	if ($untaint) {
	    $udir = $1 if $dir_loc =~ m|$untaint_pat|;
	    unless (defined $udir) {
d995 3
a997 2
	unless (chdir $udir) {
	    warn "Can't cd to $udir: $!\n";
d1002 5
a1006 1
    push @@Stack,[$dir_loc,$pdir_loc,$p_dir,$dir_rel,-1]  if  $bydepth;
d1011 1
a1011 1
	    # change to parent directory
d1013 2
a1014 6
		my $udir = $pdir_loc;
		if ($untaint) {
		    $udir = $1 if $pdir_loc =~ m|$untaint_pat|;
		}
		unless (chdir $udir) {
		    warn "Can't cd to $udir: $!\n";
d1018 4
a1021 4
	    $dir= $p_dir;
            $name= $dir_name;
            $_= ($no_chdir ? $dir_name : $dir_rel );
            $fullname= $dir_loc;
d1023 1
a1023 1
            $prune= 0;
d1025 2
a1026 2
            { &$wanted_callback }; # protect against wild "next"
            next if  $prune;
d1030 6
a1035 5
	unless ($no_chdir or $dir_rel eq '.') {
	    my $udir = $dir_loc;
	    if ($untaint) {
		$udir = $1 if $dir_loc =~ m|$untaint_pat|;
		unless (defined $udir ) {
d1044 2
a1045 2
	    unless (chdir $udir) {
		warn "Can't cd to $udir: $!\n";
d1050 5
a1054 1
	$dir = $dir_name;
d1057 2
a1058 2
	unless (opendir DIR, ($no_chdir ? $dir_loc : '.')) {
	    warn "Can't opendir($dir_loc): $!\n";
d1065 1
a1065 1
	    next if $FN =~ /^\.{1,2}\z/;
d1072 1
a1072 1
     
d1074 1
a1074 1
		push @@Stack,[$new_loc,$dir_loc,$dir_name,$FN,1];
d1077 4
a1080 4
		$fullname = $new_loc;
		$name = $dir_pref . $FN;
		$_ = ($no_chdir ? $name : $FN);
		{ &$wanted_callback }; # protect against wild "next"
d1087 48
a1134 32
	    ($dir_loc, $pdir_loc, $p_dir, $dir_rel, $byd_flag) = @@$SE;
	    $dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
	    $dir_pref = "$dir_name/";
	    $loc_pref = "$dir_loc/";
            if ( $byd_flag < 0 ) {  # must be finddepth, report dirname now
	        unless ($no_chdir or $dir_rel eq '.') {
	            my $udir = $pdir_loc;
	            if ($untaint) {
		        $udir = $1 if $dir_loc =~ m|$untaint_pat|;
	            }
	            unless (chdir $udir) {
		        warn "Can't cd to $udir: $!\n";
		        next;
	            }
	        }
	        $fullname = $dir_loc;
	        $name = $dir_name;
                if ( substr($name,-2) eq '/.' ) {
                  $name =~ s|/\.$||;
                }
                $dir = $p_dir;
	        $_ = ($no_chdir ? $dir_name : $dir_rel);
                if ( substr($_,-2) eq '/.' ) {
                  s|/\.$||;
                }

		lstat($_); # make sure  file tests with '_' work
	        { &$wanted_callback }; # protect against wild "next"
            } else {
                push @@Stack,[$dir_loc, $pdir_loc, $p_dir, $dir_rel,-1]  if  $bydepth;
                last;
            }
d1147 1
a1147 1
	    $wanted->{untaint_pattern} = qr|^([-+@@\w./]+)$|  
a1160 1
    %SLnkSeen= ();  # free memory
a1166 1
    %SLnkSeen= ();  # free memory
d1169 4
d1176 7
a1182 1
    $File::Find::dont_use_nlink = 1;
d1185 4
d1191 2
a1192 1
       $^O eq 'cygwin' || $^O eq 'epoc';
d1201 9
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d45 16
d74 1
a74 1
It is guarantueed that an I<lstat> has been called before the user's
d86 4
a89 5
This is similar to I<follow> except that it may report some files
more than once. It does detect cycles however.
Since only symbolic links have to be hashed, this is
much cheaper both in space and time.
If processing a file more than once (by the user's I<wanted()> function)
d115 1
a115 1
expression I<untaint_pattern>. Note, that all names passed to the
d122 1
a122 1
Note that the paranthesis which are vital.
d134 9
a142 9
the complete pathname to the file. You are chdir()'d to C<$File::Find::dir> when
the function is called, unless C<no_chdir> was specified.
When <follow> or <follow_fast> are in effect there is also a
C<$File::Find::fullname>.
The function may set C<$File::Find::prune> to prune the tree
unless C<bydepth> was specified.
Unless C<follow> or C<follow_fast> is specified, for compatibility
reasons (find.pl, find2perl) there are in addition the following globals
available: C<$File::Find::topdir>, C<$File::Find::topdev>, C<$File::Find::topino>,
d179 1
a179 1
Be aware that the option to follow symblic links can be dangerous.
d201 2
a202 1
    $follow_skip, $full_check, $untaint, $untaint_skip, $untaint_pat);
d301 2
d394 1
a394 1
            &$wanted_callback;
d450 1
a450 1
            &$wanted_callback; 
d485 2
d495 1
a495 1
		&$wanted_callback;
d519 1
a519 1
			&$wanted_callback;
d525 1
a525 1
		    &$wanted_callback;
d541 5
a545 1
            if ( $nlink < 0 ) {  # must be finddepth, report dirname now
d555 1
a555 1
                &$wanted_callback;
d611 11
d628 2
a629 1
            &$wanted_callback;
d679 1
a679 1
		&$wanted_callback;
d712 2
a713 1
	        &$wanted_callback;
d761 2
a762 1
    if $^O eq 'os2' || $^O eq 'dos' || $^O eq 'amigaos' || $^O eq 'MSWin32';
@


1.3
log
@perl5.005_03 (stock)
@
text
@d2 1
a2 1
require 5.000;
d15 1
a15 1
    find(\&wanted, '/foo','/bar');
d19 1
a19 1
    finddepth(\&wanted, '/foo','/bar');
d22 3
d28 87
a114 9
operations to be performed for each file, a code reference, or a string
that contains a subroutine name.  If it is a hash reference, then the
value for the key C<wanted> should be a code reference.  This code
reference is called I<the wanted() function> below.

Currently the only other supported key for the above hash is
C<bydepth>, in presense of which the walk over directories is
performed depth-first.  Entry point finddepth() is a shortcut for
specifying C<{ bydepth => 1}> in the first argument of find().
d117 12
a128 8
$File::Find::dir contains the current directory name, and $_ the
current filename within that directory.  $File::Find::name contains
C<"$File::Find::dir/$_">.  You are chdir()'d to $File::Find::dir when
the function is called.  The function may set $File::Find::prune to
prune the tree.

File::Find assumes that you don't alter the $_ variable.  If you do then
make sure you return it to its original value before exiting your function.
d133 1
a133 1
	-exec rm -f {} \; -o -fstype nfs -prune
d138 2
a139 2
        /^\.nfs.*$/ &&
        (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_)) &&
d143 1
a143 1
        ($nlink || (($dev,$ino,$mode,$nlink,$uid,$gid) = lstat($_))) &&
d148 1
a148 1
Set the variable $File::Find::dont_use_nlink if you're using AFS,
a150 2
C<finddepth> is just like C<find>, except that it does a depth-first
search.
d156 1
a156 1
	-l && !-e && print "bogus link: $File::Find::name\n";
d159 12
a170 1
=head1 BUGS
a171 1
There is no way to make find or finddepth follow symlinks.
d179 70
a248 29
sub find_opt {
    my $wanted = shift;
    my $bydepth = $wanted->{bydepth};
    my $cwd = $bydepth ? Cwd::fastcwd() : Cwd::cwd();
    # Localize these rather than lexicalizing them for backwards
    # compatibility.
    local($topdir,$topdev,$topino,$topmode,$topnlink);
    foreach $topdir (@@_) {
	(($topdev,$topino,$topmode,$topnlink) =
	  ($Is_VMS ? stat($topdir) : lstat($topdir)))
	  || (warn("Can't stat $topdir: $!\n"), next);
	if (-d _) {
	    if (chdir($topdir)) {
		$prune = 0;
		unless ($bydepth) {
		  ($dir,$_) = ($topdir,'.');
		  $name = $topdir;
		  $wanted->{wanted}->();
		}
		next if $prune;
		my $fixtopdir = $topdir;
		$fixtopdir =~ s,/$,, ;
		$fixtopdir =~ s/\.dir$// if $Is_VMS;
		&finddir($wanted,$fixtopdir,$topnlink, $bydepth);
		if ($bydepth) {
		  ($dir,$_) = ($fixtopdir,'.');
		  $name = $fixtopdir;
		  $wanted->{wanted}->();
		}
d251 1
a251 1
		warn "Can't cd to $topdir: $!\n";
d255 65
a319 7
	    require File::Basename;
	    unless (($_,$dir) = File::Basename::fileparse($topdir)) {
		($dir,$_) = ('.', $topdir);
	    }
	    if (chdir($dir)) {
		$name = $topdir;
		$wanted->{wanted}->();
d321 24
d346 69
a414 1
		warn "Can't cd to $dir: $!\n";
d417 4
a420 1
	chdir $cwd;
d422 35
a456 1
}
d458 1
a458 4
sub finddir {
    my($wanted, $nlink, $bydepth);
    local($dir, $name);
    ($wanted, $dir, $nlink, $bydepth) = @@_;
d460 7
a466 1
    my($dev, $ino, $mode, $subcount);
d468 9
a476 4
    # Get the list of files in the current directory.
    opendir(DIR,'.') || (warn("Can't open $dir: $!\n"), $bydepth || return);
    my(@@filenames) = readdir(DIR);
    closedir(DIR);
d478 58
a535 7
    if ($nlink == 2 && !$dont_use_nlink) {  # This dir has no subdirectories.
	for (@@filenames) {
	    next if $_ eq '.';
	    next if $_ eq '..';
	    $name = "$dir/$_";
	    $nlink = 0;
	    $wanted->{wanted}->();
d538 2
a539 10
    else {		      # This dir has subdirectories.
	$subcount = $nlink - 2;
	for (@@filenames) {
	    next if $_ eq '.';
	    next if $_ eq '..';
	    $nlink = 0;
	    $prune = 0 unless $bydepth;
	    $name = "$dir/$_";
	    $wanted->{wanted}->() unless $bydepth;
	    if ($subcount > 0 || $dont_use_nlink) {    # Seen all the subdirs?
d541 40
a580 1
		# Get link count and check for directoriness.
d582 1
a582 2
		($dev,$ino,$mode,$nlink) = ($Is_VMS ? stat($_) : lstat($_));
		    # unless ($nlink || $dont_use_nlink);
d584 1
a584 1
		if (-d _) {
d586 10
a595 1
		    # It really is a directory, so do it recursively.
d597 8
a604 8
		    --$subcount;
		    next if $prune;
		    # Untaint $_, so that we can do a chdir
		    $_ = $1 if /^(.*)/;
		    if (chdir $_) {
			$name =~ s/\.dir$// if $Is_VMS;
			&finddir($wanted,$name,$nlink, $bydepth);
			chdir '..';
d607 1
a607 1
			warn "Can't cd to $_: $!\n";
d611 70
a680 1
	    $wanted->{wanted}->() if $bydepth;
d685 1
d687 15
a701 2
  my $wanted = shift;
  ref($wanted) eq 'HASH' ? $wanted : { wanted => $wanted };
d705 3
a707 2
  my $wanted = shift;
  find_opt(wrap_wanted($wanted), @@_);
d711 4
a714 3
  my $wanted = wrap_wanted(shift);
  $wanted->{bydepth} = 1;
  find_opt($wanted, @@_);
d719 2
a720 2
  $Is_VMS = 1;
  $dont_use_nlink = 1;
d723 1
a723 1
$dont_use_nlink = 1
d730 3
a732 3
unless ($dont_use_nlink) {
  require Config;
  $dont_use_nlink = 1 if ($Config::Config{'dont_use_nlink'});
a735 1

@


1.2
log
@perl 5.004_04
@
text
@a3 1
use Config;
a4 2
require File::Basename;

d17 1
a17 1
    
d24 11
d45 1
a45 1
This library is primarily for the C<find2perl> tool, which when fed, 
d74 1
a74 1
    } 
d86 1
a86 1
sub find {
d88 2
a89 1
    my $cwd = Cwd::cwd();
a98 2
		($dir,$_) = ($topdir,'.');
		$name = $topdir;
d100 14
a113 7
		&$wanted;
		if (!$prune) {
		    my $fixtopdir = $topdir;
	            $fixtopdir =~ s,/$,, ;
		    $fixtopdir =~ s/\.dir$// if $Is_VMS;
		    $fixtopdir =~ s/\\dir$// if $Is_NT;
		    &finddir($wanted,$fixtopdir,$topnlink);
d121 1
d125 7
a131 2
	    $name = $topdir;
	    chdir $dir && &$wanted;
d138 1
a138 1
    my($wanted, $nlink);
d140 1
a140 1
    ($wanted, $dir, $nlink) = @@_;
d145 1
a145 1
    opendir(DIR,'.') || (warn "Can't open $dir: $!\n", return);
d155 1
a155 1
	    &$wanted;
d158 1
a158 1
    else {                    # This dir has subdirectories.
d163 2
a164 1
	    $nlink = $prune = 0;
d166 1
a166 1
	    &$wanted;
d173 1
a173 1
		
d178 5
a182 1
		    if (!$prune && chdir $_) {
d184 1
a184 2
			$name =~ s/\\dir$// if $Is_NT;
			&finddir($wanted,$name,$nlink);
d187 3
a189 1
		    --$subcount;
d192 1
d197 4
d202 3
a204 36
sub finddepth {
    my $wanted = shift;

    $cwd = Cwd::fastcwd();;

    # Localize these rather than lexicalizing them for backwards
    # compatibility.
    local($topdir, $topdev, $topino, $topmode, $topnlink);
    foreach $topdir (@@_) {
	(($topdev,$topino,$topmode,$topnlink) =
	  ($Is_VMS ? stat($topdir) : lstat($topdir)))
	  || (warn("Can't stat $topdir: $!\n"), next);
	if (-d _) {
	    if (chdir($topdir)) {
		my $fixtopdir = $topdir;
		$fixtopdir =~ s,/$,, ;
		$fixtopdir =~ s/\.dir$// if $Is_VMS;
		$fixtopdir =~ s/\\dir$// if $Is_NT;
		&finddepthdir($wanted,$fixtopdir,$topnlink);
		($dir,$_) = ($fixtopdir,'.');
		$name = $fixtopdir;
		&$wanted;
	    }
	    else {
		warn "Can't cd to $topdir: $!\n";
	    }
	}
	else {
	    unless (($_,$dir) = File::Basename::fileparse($topdir)) {
		($dir,$_) = ('.', $topdir);
	    }
	    $name = $topdir;
	    chdir $dir && &$wanted;
	}
	chdir $cwd;
    }
d207 4
a210 49
sub finddepthdir {
    my($wanted, $nlink);
    local($dir, $name);
    ($wanted,$dir,$nlink) = @@_;
    my($dev, $ino, $mode, $subcount);

    # Get the list of files in the current directory.
    opendir(DIR,'.') || warn "Can't open $dir: $!\n";
    my(@@filenames) = readdir(DIR);
    closedir(DIR);

    if ($nlink == 2 && !$dont_use_nlink) {   # This dir has no subdirectories.
	for (@@filenames) {
	    next if $_ eq '.';
	    next if $_ eq '..';
	    $name = "$dir/$_";
	    $nlink = 0;
	    &$wanted;
	}
    }
    else {                    # This dir has subdirectories.
	$subcount = $nlink - 2;
	for (@@filenames) {
	    next if $_ eq '.';
	    next if $_ eq '..';
	    $nlink = 0;
	    $name = "$dir/$_";
	    if ($subcount > 0 || $dont_use_nlink) {    # Seen all the subdirs?

		# Get link count and check for directoriness.

		($dev,$ino,$mode,$nlink) = ($Is_VMS ? stat($_) : lstat($_));
		
		if (-d _) {

		    # It really is a directory, so do it recursively.

		    if (chdir $_) {
			$name =~ s/\.dir$// if $Is_VMS;
			$name =~ s/\\dir$// if $Is_NT;
			&finddepthdir($wanted,$name,$nlink);
			chdir '..';
		    }
		    --$subcount;
		}
	    }
	    &$wanted;
	}
    }
a212 6
# Set dont_use_nlink in your hint file if your system's stat doesn't
# report the number of links in a directory as an indication
# of the number of files.
# See, e.g. hints/machten.sh for MachTen 2.2.
$dont_use_nlink = 1 if ($Config::Config{'dont_use_nlink'});

a217 4
if ($^O =~ m:^mswin32:i) {
  $Is_NT = 1;
  $dont_use_nlink = 1;
}
d220 10
a229 1
    if $^O eq 'os2' || $^O eq 'msdos' || $^O eq 'amigaos';
@


1.1
log
@Initial revision
@
text
@d34 3
d68 4
d80 4
a83 2
    my $cwd = Cwd::fastcwd();
    my ($topdir,$topdev,$topino,$topmode,$topnlink);
d85 2
a86 1
	(($topdev,$topino,$topmode,$topnlink) = stat($topdir))
d92 1
d94 7
a100 4
		my $fixtopdir = $topdir;
	        $fixtopdir =~ s,/$,, ;
		$fixtopdir =~ s/\.dir$// if $Is_VMS; ;
		&finddir($wanted,$fixtopdir,$topnlink);
d107 1
a107 1
	    unless (($dir,$_) = File::Basename::fileparse($topdir)) {
d159 1
d176 3
a178 1
    my($topdir, $topdev, $topino, $topmode, $topnlink);
d180 2
a181 1
	(($topdev,$topino,$topmode,$topnlink) = stat($topdir))
d188 1
d199 1
a199 1
	    unless (($dir,$_) = File::Basename::fileparse($topdir)) {
d202 1
d248 1
d271 4
d276 2
a277 2
$dont_use_nlink = 1 if $^O eq 'os2';
$dont_use_nlink = 1 if $^O =~ m:^mswin32$:i ;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d4 1
d6 2
d20 1
a20 1

a26 11
The first argument to find() is either a hash reference describing the
operations to be performed for each file, a code reference, or a string
that contains a subroutine name.  If it is a hash reference, then the
value for the key C<wanted> should be a code reference.  This code
reference is called I<the wanted() function> below.

Currently the only other supported key for the above hash is
C<bydepth>, in presense of which the walk over directories is
performed depth-first.  Entry point finddepth() is a shortcut for
specifying C<{ bydepth => 1}> in the first argument of find().

d34 1
a34 4
File::Find assumes that you don't alter the $_ variable.  If you do then
make sure you return it to its original value before exiting your function.

This library is useful for the C<find2perl> tool, which when fed,
d63 1
a63 5
    }

=head1 BUGS

There is no way to make find or finddepth follow symlinks.
d71 1
a71 1
sub find_opt {
d73 2
a74 5
    my $bydepth = $wanted->{bydepth};
    my $cwd = $bydepth ? Cwd::fastcwd() : Cwd::cwd();
    # Localize these rather than lexicalizing them for backwards
    # compatibility.
    local($topdir,$topdev,$topino,$topmode,$topnlink);
d76 1
a76 2
	(($topdev,$topino,$topmode,$topnlink) =
	  ($Is_VMS ? stat($topdir) : lstat($topdir)))
d80 3
a82 7
		$prune = 0;
		unless ($bydepth) {
		  ($dir,$_) = ($topdir,'.');
		  $name = $topdir;
		  $wanted->{wanted}->();
		}
		next if $prune;
d84 3
a86 8
		$fixtopdir =~ s,/$,, ;
		$fixtopdir =~ s/\.dir$// if $Is_VMS;
		&finddir($wanted,$fixtopdir,$topnlink, $bydepth);
		if ($bydepth) {
		  ($dir,$_) = ($fixtopdir,'.');
		  $name = $fixtopdir;
		  $wanted->{wanted}->();
		}
d93 1
a93 2
	    require File::Basename;
	    unless (($_,$dir) = File::Basename::fileparse($topdir)) {
d96 2
a97 7
	    if (chdir($dir)) {
		$name = $topdir;
		$wanted->{wanted}->();
	    }
	    else {
		warn "Can't cd to $dir: $!\n";
	    }
d104 1
a104 1
    my($wanted, $nlink, $bydepth);
d106 1
a106 1
    ($wanted, $dir, $nlink, $bydepth) = @@_;
d111 1
a111 1
    opendir(DIR,'.') || (warn("Can't open $dir: $!\n"), $bydepth || return);
d121 1
a121 1
	    $wanted->{wanted}->();
d124 1
a124 1
    else {		      # This dir has subdirectories.
d129 1
a129 2
	    $nlink = 0;
	    $prune = 0 unless $bydepth;
d131 1
a131 1
	    $wanted->{wanted}->() unless $bydepth;
d138 1
a138 1

d143 1
a143 5
		    --$subcount;
		    next if $prune;
		    # Untaint $_, so that we can do a chdir
		    $_ = $1 if /^(.*)/;
		    if (chdir $_) {
d145 1
a145 1
			&finddir($wanted,$name,$nlink, $bydepth);
d148 1
a148 3
		    else {
			warn "Can't cd to $_: $!\n";
		    }
a150 1
	    $wanted->{wanted}->() if $bydepth;
d155 32
a186 3
sub wrap_wanted {
  my $wanted = shift;
  ref($wanted) eq 'HASH' ? $wanted : { wanted => $wanted };
d189 48
a236 3
sub find {
  my $wanted = shift;
  find_opt(wrap_wanted($wanted), @@_);
d239 5
a243 5
sub finddepth {
  my $wanted = wrap_wanted(shift);
  $wanted->{bydepth} = 1;
  find_opt($wanted, @@_);
}
d251 2
a252 11
$dont_use_nlink = 1
    if $^O eq 'os2' || $^O eq 'dos' || $^O eq 'amigaos' || $^O eq 'MSWin32';

# Set dont_use_nlink in your hint file if your system's stat doesn't
# report the number of links in a directory as an indication
# of the number of files.
# See, e.g. hints/machten.sh for MachTen 2.2.
unless ($dont_use_nlink) {
  require Config;
  $dont_use_nlink = 1 if ($Config::Config{'dont_use_nlink'});
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d2 1
a2 1
use 5.005_64;
d15 1
a15 1
    find(\&wanted, '/foo', '/bar');
d19 1
a19 1
    finddepth(\&wanted, '/foo', '/bar');
a21 3
    use File::Find;
    find({ wanted => \&process, follow => 1 }, '.');

d25 9
a33 1
operations to be performed for each file, or a code reference.
d35 6
a40 48
Here are the possible keys for the hash:

=over 3

=item C<wanted>

The value should be a code reference.  This code reference is called
I<the wanted() function> below.

=item C<bydepth>

Reports the name of a directory only AFTER all its entries
have been reported.  Entry point finddepth() is a shortcut for
specifying C<{ bydepth => 1 }> in the first argument of find().

=item C<follow>

Causes symbolic links to be followed. Since directory trees with symbolic
links (followed) may contain files more than once and may even have
cycles, a hash has to be built up with an entry for each file.
This might be expensive both in space and time for a large
directory tree. See I<follow_fast> and I<follow_skip> below.
If either I<follow> or I<follow_fast> is in effect:

=over 6

=item *

It is guarantueed that an I<lstat> has been called before the user's
I<wanted()> function is called. This enables fast file checks involving S< _>.

=item *

There is a variable C<$File::Find::fullname> which holds the absolute
pathname of the file with all symbolic links resolved

=back

=item C<follow_fast>

This is similar to I<follow> except that it may report some files
more than once. It does detect cycles however.
Since only symbolic links have to be hashed, this is
much cheaper both in space and time.
If processing a file more than once (by the user's I<wanted()> function)
is worse than just taking time, the option I<follow> should be used.

=item C<follow_skip>
d42 2
a43 50
C<follow_skip==1>, which is the default, causes all files which are
neither directories nor symbolic links to be ignored if they are about
to be processed a second time. If a directory or a symbolic link 
are about to be processed a second time, File::Find dies.
C<follow_skip==0> causes File::Find to die if any file is about to be
processed a second time.
C<follow_skip==2> causes File::Find to ignore any duplicate files and
dirctories but to proceed normally otherwise.


=item C<no_chdir>

Does not C<chdir()> to each directory as it recurses. The wanted()
function will need to be aware of this, of course. In this case,
C<$_> will be the same as C<$File::Find::name>.

=item C<untaint>

If find is used in taint-mode (-T command line switch or if EUID != UID
or if EGID != GID) then internally directory names have to be untainted
before they can be cd'ed to. Therefore they are checked against a regular
expression I<untaint_pattern>. Note, that all names passed to the
user's I<wanted()> function are still tainted. 

=item C<untaint_pattern>

See above. This should be set using the C<qr> quoting operator.
The default is set to  C<qr|^([-+@@\w./]+)$|>. 
Note that the paranthesis which are vital.

=item C<untaint_skip>

If set, directories (subtrees) which fail the I<untaint_pattern>
are skipped. The default is to 'die' in such a case.

=back

The wanted() function does whatever verifications you want.
C<$File::Find::dir> contains the current directory name, and C<$_> the
current filename within that directory.  C<$File::Find::name> contains
the complete pathname to the file. You are chdir()'d to C<$File::Find::dir> when
the function is called, unless C<no_chdir> was specified.
When <follow> or <follow_fast> are in effect there is also a
C<$File::Find::fullname>.
The function may set C<$File::Find::prune> to prune the tree
unless C<bydepth> was specified.
Unless C<follow> or C<follow_fast> is specified, for compatibility
reasons (find.pl, find2perl) there are in addition the following globals
available: C<$File::Find::topdir>, C<$File::Find::topdev>, C<$File::Find::topino>,
C<$File::Find::topmode> and C<$File::Find::topnlink>.
d48 1
a48 1
        -exec rm -f {} \; -o -fstype nfs -prune
d53 2
a54 2
        /^\.nfs.*\z/s &&
        (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_)) &&
d58 1
a58 1
        ($nlink || (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_))) &&
d63 1
a63 1
Set the variable C<$File::Find::dont_use_nlink> if you're using AFS,
d66 2
d73 1
a73 1
         -l && !-e && print "bogus link: $File::Find::name\n";
d76 1
a76 12
See also the script C<pfind> on CPAN for a nice application of this
module.

=head1 CAVEAT

Be aware that the option to follow symblic links can be dangerous.
Depending on the structure of the directory tree (including symbolic
links to directories) you might traverse a given (physical) directory
more than once (only if C<follow_fast> is in effect). 
Furthermore, deleting or changing files in a symbolically linked directory
might cause very unpleasant surprises, since you delete or change files
in an unknown directory.
d78 1
d86 29
a114 61
use strict;
my $Is_VMS;

require File::Basename;

my %SLnkSeen;
my ($wanted_callback, $avoid_nlink, $bydepth, $no_chdir, $follow,
    $follow_skip, $full_check, $untaint, $untaint_skip, $untaint_pat);

sub contract_name {
    my ($cdir,$fn) = @@_;

    return substr($cdir,0,rindex($cdir,'/')) if $fn eq '.';

    $cdir = substr($cdir,0,rindex($cdir,'/')+1);

    $fn =~ s|^\./||;

    my $abs_name= $cdir . $fn;

    if (substr($fn,0,3) eq '../') {
	do 1 while ($abs_name=~ s|/(?>[^/]+)/\.\./|/|);
    }

    return $abs_name;
}


sub PathCombine($$) {
    my ($Base,$Name) = @@_;
    my $AbsName;

    if (substr($Name,0,1) eq '/') {
	$AbsName= $Name;
    }
    else {
	$AbsName= contract_name($Base,$Name);
    }

    # (simple) check for recursion
    my $newlen= length($AbsName);
    if ($newlen <= length($Base)) {
	if (($newlen == length($Base) || substr($Base,$newlen,1) eq '/')
	    && $AbsName eq substr($Base,0,$newlen))
	{
	    return undef;
	}
    }
    return $AbsName;
}

sub Follow_SymLink($) {
    my ($AbsName) = @@_;

    my ($NewName,$DEV, $INO);
    ($DEV, $INO)= lstat $AbsName;

    while (-l _) {
	if ($SLnkSeen{$DEV, $INO}++) {
	    if ($follow_skip < 2) {
		die "$AbsName is encountered a second time";
d117 1
a117 1
		return undef;
d120 8
a127 4
	$NewName= PathCombine($AbsName, readlink($AbsName));
	unless(defined $NewName) {
	    if ($follow_skip < 2) {
		die "$AbsName is a recursive symbolic link";
d130 1
a130 1
		return undef;
d133 1
a133 14
	else {
	    $AbsName= $NewName;
	}
	($DEV, $INO) = lstat($AbsName);
	return undef unless defined $DEV;  #  dangling symbolic link
    }

    if ($full_check && $SLnkSeen{$DEV, $INO}++) {
	if ($follow_skip < 1) {
	    die "$AbsName encountered a second time";
	}
	else {
	    return undef;
	}
a134 2

    return $AbsName;
d137 4
a140 3
our($dir, $name, $fullname, $prune);
sub _find_dir_symlnk($$$);
sub _find_dir($$$);
d142 1
a142 3
sub _find_opt {
    my $wanted = shift;
    die "invalid top directory" unless defined $_[0];
d144 4
a147 24
    my $cwd           = $wanted->{bydepth} ? Cwd::fastcwd() : Cwd::cwd();
    my $cwd_untainted = $cwd;
    $wanted_callback  = $wanted->{wanted};
    $bydepth          = $wanted->{bydepth};
    $no_chdir         = $wanted->{no_chdir};
    $full_check       = $wanted->{follow};
    $follow           = $full_check || $wanted->{follow_fast};
    $follow_skip      = $wanted->{follow_skip};
    $untaint          = $wanted->{untaint};
    $untaint_pat      = $wanted->{untaint_pattern};
    $untaint_skip     = $wanted->{untaint_skip};

    # for compatability reasons (find.pl, find2perl)
    our ($topdir, $topdev, $topino, $topmode, $topnlink);

    # a symbolic link to a directory doesn't increase the link count
    $avoid_nlink      = $follow || $File::Find::dont_use_nlink;
    
    if ( $untaint ) {
	$cwd_untainted= $1 if $cwd_untainted =~ m|$untaint_pat|;
	die "insecure cwd in find(depth)"  unless defined($cwd_untainted);
    }
    
    my ($abs_dir, $Is_Dir);
d149 7
a155 114
    Proc_Top_Item:
    foreach my $TOP (@@_) {
        my $top_item = $TOP;
        $top_item =~ s|/\z|| unless $top_item eq '/';
        $Is_Dir= 0;
        
        ($topdev,$topino,$topmode,$topnlink) = stat $top_item;

        if ($follow) {
            if (substr($top_item,0,1) eq '/') {
                $abs_dir = $top_item;
            }
	    elsif ($top_item eq '.') {
		$abs_dir = $cwd;
	    }
            else {  # care about any  ../
		$abs_dir = contract_name("$cwd/",$top_item); 
            }
            $abs_dir= Follow_SymLink($abs_dir);
            unless (defined $abs_dir) {
		warn "$top_item is a dangling symbolic link\n";
		next Proc_Top_Item;
            }
            if (-d _) {
		_find_dir_symlnk($wanted, $abs_dir, $top_item);
		$Is_Dir= 1;
            }
        }
	else { # no follow
            $topdir = $top_item;
            unless (defined $topnlink) {
                warn "Can't stat $top_item: $!\n";
                next Proc_Top_Item;
            }
            if (-d _) {
		$top_item =~ s/\.dir\z// if $Is_VMS;
		_find_dir($wanted, $top_item, $topnlink);
		$Is_Dir= 1;
            }
	    else {
		$abs_dir= $top_item;
            }
        }

        unless ($Is_Dir) {
	    unless (($_,$dir) = File::Basename::fileparse($abs_dir)) {
		($dir,$_) = ('./', $top_item);
	    }

            $abs_dir = $dir;
            if ($untaint) {
		my $abs_dir_save = $abs_dir;
		$abs_dir = $1 if $abs_dir =~ m|$untaint_pat|;
		unless (defined $abs_dir) {
		    if ($untaint_skip == 0) {
			die "directory $abs_dir_save is still tainted";
		    }
		    else {
			next Proc_Top_Item;
		    }
		}
            }

            unless ($no_chdir or chdir $abs_dir) {
                warn "Couldn't chdir $abs_dir: $!\n";
                next Proc_Top_Item;
            }

            $name = $abs_dir . $_;

            &$wanted_callback;

        }

        $no_chdir or chdir $cwd_untainted;
    }
}

# API:
#  $wanted
#  $p_dir :  "parent directory"
#  $nlink :  what came back from the stat
# preconditions:
#  chdir (if not no_chdir) to dir

sub _find_dir($$$) {
    my ($wanted, $p_dir, $nlink) = @@_;
    my ($CdLvl,$Level) = (0,0);
    my @@Stack;
    my @@filenames;
    my ($subcount,$sub_nlink);
    my $SE= [];
    my $dir_name= $p_dir;
    my $dir_pref= ( $p_dir eq '/' ? '/' : "$p_dir/" );
    my $dir_rel= '.';      # directory name relative to current directory

    local ($dir, $name, $prune, *DIR);
     
    unless ($no_chdir or $p_dir eq '.') {
	my $udir = $p_dir;
	if ($untaint) {
	    $udir = $1 if $p_dir =~ m|$untaint_pat|;
	    unless (defined $udir) {
		if ($untaint_skip == 0) {
		    die "directory $p_dir is still tainted";
		}
		else {
		    return;
		}
	    }
	}
	unless (chdir $udir) {
	    warn "Can't cd to $udir: $!\n";
	    return;
d158 10
a167 2
    
    push @@Stack,[$CdLvl,$p_dir,$dir_rel,-1]  if  $bydepth;
d169 1
a169 32
    while (defined $SE) {
	unless ($bydepth) {
            $dir= $p_dir;
            $name= $dir_name;
            $_= ($no_chdir ? $dir_name : $dir_rel );
	    # prune may happen here
            $prune= 0;
            &$wanted_callback; 
            next if $prune;
	}
      
	# change to that directory
	unless ($no_chdir or $dir_rel eq '.') {
	    my $udir= $dir_rel;
	    if ($untaint) {
		$udir = $1 if $dir_rel =~ m|$untaint_pat|;
		unless (defined $udir) {
		    if ($untaint_skip == 0) {
			die "directory ("
			    . ($p_dir ne '/' ? $p_dir : '')
			    . "/) $dir_rel is still tainted";
		    }
		}
	    }
	    unless (chdir $udir) {
		warn "Can't cd to ("
		    . ($p_dir ne '/' ? $p_dir : '')
		    . "/) $udir : $!\n";
		next;
	    }
	    $CdLvl++;
	}
d171 2
a172 1
	$dir= $dir_name;
d174 1
a174 7
	# Get the list of files in the current directory.
	unless (opendir DIR, ($no_chdir ? $dir_name : '.')) {
	    warn "Can't opendir($dir_name): $!\n";
	    next;
	}
	@@filenames = readdir DIR;
	closedir(DIR);
d176 1
a176 9
	if ($nlink == 2 && !$avoid_nlink) {
	    # This dir has no subdirectories.
	    for my $FN (@@filenames) {
		next if $FN =~ /^\.{1,2}\z/;
		
		$name = $dir_pref . $FN;
		$_ = ($no_chdir ? $name : $FN);
		&$wanted_callback;
	    }
d178 8
a185 17
	}
	else {
	    # This dir has subdirectories.
	    $subcount = $nlink - 2;

	    for my $FN (@@filenames) {
		next if $FN =~ /^\.{1,2}\z/;
		if ($subcount > 0 || $avoid_nlink) {
		    # Seen all the subdirs?
		    # check for directoriness.
		    # stat is faster for a file in the current directory
		    $sub_nlink = (lstat ($no_chdir ? $dir_pref . $FN : $FN))[3];

		    if (-d _) {
			--$subcount;
			$FN =~ s/\.dir\z// if $Is_VMS;
			push @@Stack,[$CdLvl,$dir_name,$FN,$sub_nlink];
d188 1
a188 3
			$name = $dir_pref . $FN;
			$_= ($no_chdir ? $name : $FN);
			&$wanted_callback;
a190 16
		else {
		    $name = $dir_pref . $FN;
		    $_= ($no_chdir ? $name : $FN);
		    &$wanted_callback;
		}
	    }
	}
    }
    continue {
	while ( defined ($SE = pop @@Stack) ) {
	    ($Level, $p_dir, $dir_rel, $nlink) = @@$SE;
	    if ($CdLvl > $Level && !$no_chdir) {
                my $tmp = join('/',('..') x ($CdLvl-$Level));
                die "Can't cd to $dir_name" . $tmp
                    unless chdir ($tmp);
		$CdLvl = $Level;
d192 1
a192 17
	    $dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
	    $dir_pref = "$dir_name/";
            if ( $nlink < 0 ) {  # must be finddepth, report dirname now
                $name = $dir_name;
                if ( substr($name,-2) eq '/.' ) {
                  $name =~ s|/\.$||;
                }
                $dir = $p_dir;
                $_ = ($no_chdir ? $dir_name : $dir_rel );
                if ( substr($_,-2) eq '/.' ) {
                  s|/\.$||;
                }
                &$wanted_callback;
            } else {
                push @@Stack,[$CdLvl,$p_dir,$dir_rel,-1]  if  $bydepth;
                last;
            }
a196 146

# API:
#  $wanted
#  $dir_loc : absolute location of a dir
#  $p_dir   : "parent directory"
# preconditions:
#  chdir (if not no_chdir) to dir

sub _find_dir_symlnk($$$) {
    my ($wanted, $dir_loc, $p_dir) = @@_;
    my @@Stack;
    my @@filenames;
    my $new_loc;
    my $pdir_loc = $dir_loc;
    my $SE = [];
    my $dir_name = $p_dir;
    my $dir_pref = ( $p_dir   eq '/' ? '/' : "$p_dir/" );
    my $loc_pref = ( $dir_loc eq '/' ? '/' : "$dir_loc/" );
    my $dir_rel = '.';		# directory name relative to current directory
    my $byd_flag;               # flag for pending stack entry if $bydepth

    local ($dir, $name, $fullname, $prune, *DIR);
    
    unless ($no_chdir or $p_dir eq '.') {
	my $udir = $dir_loc;
	if ($untaint) {
	    $udir = $1 if $dir_loc =~ m|$untaint_pat|;
	    unless (defined $udir) {
		if ($untaint_skip == 0) {
		    die "directory $dir_loc is still tainted";
		}
		else {
		    return;
		}
	    }
	}
	unless (chdir $udir) {
	    warn "Can't cd to $udir: $!\n";
	    return;
	}
    }

    push @@Stack,[$dir_loc,$pdir_loc,$p_dir,$dir_rel,-1]  if  $bydepth;

    while (defined $SE) {

	unless ($bydepth) {
	    $dir= $p_dir;
            $name= $dir_name;
            $_= ($no_chdir ? $dir_name : $dir_rel );
            $fullname= $dir_loc;
	    # prune may happen here
            $prune= 0;
            &$wanted_callback;
            next if  $prune;
	}

	# change to that directory
	unless ($no_chdir or $dir_rel eq '.') {
	    my $udir = $dir_loc;
	    if ($untaint) {
		$udir = $1 if $dir_loc =~ m|$untaint_pat|;
		unless (defined $udir ) {
		    if ($untaint_skip == 0) {
			die "directory $dir_loc is still tainted";
		    }
		    else {
			next;
		    }
		}
	    }
	    unless (chdir $udir) {
		warn "Can't cd to $udir: $!\n";
		next;
	    }
	}

	$dir = $dir_name;

	# Get the list of files in the current directory.
	unless (opendir DIR, ($no_chdir ? $dir_loc : '.')) {
	    warn "Can't opendir($dir_loc): $!\n";
	    next;
	}
	@@filenames = readdir DIR;
	closedir(DIR);

	for my $FN (@@filenames) {
	    next if $FN =~ /^\.{1,2}\z/;

	    # follow symbolic links / do an lstat
	    $new_loc = Follow_SymLink($loc_pref.$FN);

	    # ignore if invalid symlink
	    next unless defined $new_loc;
     
	    if (-d _) {
		push @@Stack,[$new_loc,$dir_loc,$dir_name,$FN,1];
	    }
	    else {
		$fullname = $new_loc;
		$name = $dir_pref . $FN;
		$_ = ($no_chdir ? $name : $FN);
		&$wanted_callback;
	    }
	}

    }
    continue {
	while (defined($SE = pop @@Stack)) {
	    ($dir_loc, $pdir_loc, $p_dir, $dir_rel, $byd_flag) = @@$SE;
	    $dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
	    $dir_pref = "$dir_name/";
	    $loc_pref = "$dir_loc/";
            if ( $byd_flag < 0 ) {  # must be finddepth, report dirname now
	        unless ($no_chdir or $dir_rel eq '.') {
	            my $udir = $pdir_loc;
	            if ($untaint) {
		        $udir = $1 if $dir_loc =~ m|$untaint_pat|;
	            }
	            unless (chdir $udir) {
		        warn "Can't cd to $udir: $!\n";
		        next;
	            }
	        }
	        $fullname = $dir_loc;
	        $name = $dir_name;
                if ( substr($name,-2) eq '/.' ) {
                  $name =~ s|/\.$||;
                }
                $dir = $p_dir;
	        $_ = ($no_chdir ? $dir_name : $dir_rel);
                if ( substr($_,-2) eq '/.' ) {
                  s|/\.$||;
                }

	        &$wanted_callback;
            } else {
                push @@Stack,[$dir_loc, $pdir_loc, $p_dir, $dir_rel,-1]  if  $bydepth;
                last;
            }
	}
    }
}


d198 2
a199 15
    my $wanted = shift;
    if ( ref($wanted) eq 'HASH' ) {
	if ( $wanted->{follow} || $wanted->{follow_fast}) {
	    $wanted->{follow_skip} = 1 unless defined $wanted->{follow_skip};
	}
	if ( $wanted->{untaint} ) {
	    $wanted->{untaint_pattern} = qr|^([-+@@\w./]+)$|  
		unless defined $wanted->{untaint_pattern};
	    $wanted->{untaint_skip} = 0 unless defined $wanted->{untaint_skip};
	}
	return $wanted;
    }
    else {
	return { wanted => $wanted };
    }
d203 2
a204 3
    my $wanted = shift;
    _find_opt(wrap_wanted($wanted), @@_);
    %SLnkSeen= ();  # free memory
d208 3
a210 4
    my $wanted = wrap_wanted(shift);
    $wanted->{bydepth} = 1;
    _find_opt($wanted, @@_);
    %SLnkSeen= ();  # free memory
d215 2
a216 2
    $Is_VMS = 1;
    $File::Find::dont_use_nlink = 1;
d219 1
a219 1
$File::Find::dont_use_nlink = 1
d226 3
a228 3
unless ($File::Find::dont_use_nlink) {
    require Config;
    $File::Find::dont_use_nlink = 1 if ($Config::Config{'dont_use_nlink'});
d232 1
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a44 16
=item C<preprocess>

The value should be a code reference.  This code reference is used to
preprocess a directory; it is called after readdir() but before the loop that
calls the wanted() function.  It is called with a list of strings and is
expected to return a list of strings.  The code can be used to sort the
strings alphabetically, numerically, or to filter out directory entries based
on their name alone.

=item C<postprocess>

The value should be a code reference.  It is invoked just before leaving the
current directory.  It is called in void context with no arguments.  The name
of the current directory is in $File::Find::dir.  This hook is handy for
summarizing a directory, such as calculating its disk usage.

d58 1
a58 1
It is guaranteed that an I<lstat> has been called before the user's
d70 5
a74 4
This is similar to I<follow> except that it may report some files more
than once.  It does detect cycles, however.  Since only symbolic links
have to be hashed, this is much cheaper both in space and time.  If
processing a file more than once (by the user's I<wanted()> function)
d100 1
a100 1
expression I<untaint_pattern>.  Note that all names passed to the
d107 1
a107 1
Note that the parantheses are vital.
d119 9
a127 9
the complete pathname to the file. You are chdir()'d to
C<$File::Find::dir> when the function is called, unless C<no_chdir>
was specified.  When <follow> or <follow_fast> are in effect, there is
also a C<$File::Find::fullname>.  The function may set
C<$File::Find::prune> to prune the tree unless C<bydepth> was
specified.  Unless C<follow> or C<follow_fast> is specified, for
compatibility reasons (find.pl, find2perl) there are in addition the
following globals available: C<$File::Find::topdir>,
C<$File::Find::topdev>, C<$File::Find::topino>,
d164 1
a164 1
Be aware that the option to follow symbolic links can be dangerous.
d186 1
a186 2
    $follow_skip, $full_check, $untaint, $untaint_skip, $untaint_pat,
    $pre_process, $post_process);
a284 2
    $pre_process      = $wanted->{preprocess};
    $post_process     = $wanted->{postprocess};
d376 1
a376 1
            { &$wanted_callback }; # protect against wild "next"
d432 1
a432 1
            { &$wanted_callback }; 	# protect against wild "next"
a466 2
	@@filenames = &$pre_process(@@filenames) if $pre_process;
	push @@Stack,[$CdLvl,$dir_name,"",-2]   if $post_process;
d475 1
a475 1
		{ &$wanted_callback }; # protect against wild "next"
d499 1
a499 1
			{ &$wanted_callback }; # protect against wild "next"
d505 1
a505 1
		    { &$wanted_callback }; # protect against wild "next"
d521 1
a521 5
	    if ( $nlink == -2 ) {
		$name = $dir = $p_dir;
		$_ = ".";
		&$post_process;		# End-of-directory processing
            } elsif ( $nlink < 0 ) {  # must be finddepth, report dirname now
d531 1
a531 1
                { &$wanted_callback }; # protect against wild "next"
a586 11
	    # change to parent directory
	    unless ($no_chdir) {
		my $udir = $pdir_loc;
		if ($untaint) {
		    $udir = $1 if $pdir_loc =~ m|$untaint_pat|;
		}
		unless (chdir $udir) {
		    warn "Can't cd to $udir: $!\n";
		    next;
		}
	    }
d593 1
a593 2
	    lstat($_); # make sure  file tests with '_' work
            { &$wanted_callback }; # protect against wild "next"
d643 1
a643 1
		{ &$wanted_callback }; # protect against wild "next"
d676 1
a676 2
		lstat($_); # make sure  file tests with '_' work
	        { &$wanted_callback }; # protect against wild "next"
d724 1
a724 2
    if $^O eq 'os2' || $^O eq 'dos' || $^O eq 'amigaos' || $^O eq 'MSWin32' ||
       $^O eq 'cygwin' || $^O eq 'epoc';
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d2 1
a2 5
use 5.006;
use strict;
use warnings;
use warnings::register;
our $VERSION = '1.04';
d8 3
a10 1
File::Find - Traverse a directory tree.
d15 1
a15 1
    find(\&wanted, @@directories_to_seach);
d19 1
a19 1
    finddepth(\&wanted, @@directories_to_search);
a26 31
These are functions for searching through directory trees doing work
on each file found similar to the Unix I<find> command.  File::Find
exports two functions, C<find> and C<finddepth>.  They work similarly
but have subtle differences.

=over 4

=item B<find>

  find(\&wanted,  @@directories);
  find(\%options, @@directories);

find() does a breadth-first search over the given @@directories in the
order they are given.  In essense, it works from the top down.

For each file or directory found the &wanted subroutine is called (see
below for details).  Additionally, for each directory found it will go
into that directory and continue the search.

=item B<finddepth>

  finddepth(\&wanted,  @@directories);
  finddepth(\%options, @@directories);

finddepth() works just like find() except it does a depth-first search.
It works from the bottom of the directory tree up.

=back

=head2 %options

d28 1
a28 2
operations to be performed for each file, or a code reference.  The
code reference is described in L<The wanted function> below.
d36 2
a37 2
The value should be a code reference.  This code reference is
described in L<The wanted function> below.
d43 1
a43 1
specifying C<{ bydepth =E<gt> 1 }> in the first argument of find().
d47 6
a52 9
The value should be a code reference. This code reference is used to 
preprocess the current directory. The name of currently processed 
directory is in $File::Find::dir. Your preprocessing function is 
called after readdir() but before the loop that calls the wanted() 
function. It is called with a list of strings (actually file/directory 
names) and is expected to return a list of strings. The code can be 
used to sort the file/directory names alphabetically, numerically, 
or to filter out directory entries based on their name alone. When 
I<follow> or I<follow_fast> are in effect, C<preprocess> is a no-op.
d56 4
a59 6
The value should be a code reference. It is invoked just before leaving 
the currently processed directory. It is called in void context with no 
arguments. The name of the current directory is in $File::Find::dir. This 
hook is handy for summarizing a directory, such as calculating its disk 
usage. When I<follow> or I<follow_fast> are in effect, C<postprocess> is a 
no-op.
d101 1
a101 3
directories but to proceed normally otherwise.

=item C<dangling_symlinks>
a102 5
If true and a code reference, will be called with the symbolic link
name and the directory it lives in as arguments.  Otherwise, if true
and warnings are on, warning "symbolic_link_name is a dangling
symbolic link\n" will be issued.  If false, the dangling symbolic link
will be silently ignored.
d114 3
a116 4
before they can be chdir'ed to. Therefore they are checked against a regular
expression I<untaint_pattern>.  Note that all names passed to the user's 
I<wanted()> function are still tainted. If this option is used while 
not in taint-mode, C<untaint> is a no-op.
d122 1
a122 1
Note that the parentheses are vital.
d126 2
a127 18
If set, a directory which fails the I<untaint_pattern> is skipped, 
including all its sub-directories. The default is to 'die' in such a case.

=back

=head2 The wanted function

The wanted() function does whatever verifications you want on each
file and directory.  It takes no arguments but rather does its work
through a collection of variables.

=over 4

=item C<$File::Find::dir> is the current directory name,

=item C<$_> is the current filename within that directory

=item C<$File::Find::name> is the complete pathname to the file.
d131 6
a136 26
Don't modify these variables.

For example, when examining the file /some/path/foo.ext you will have:

    $File::Find::dir  = /some/path/
    $_                = foo.ext
    $File::Find::name = /some/path/foo.ext

You are chdir()'d toC<$File::Find::dir> when the function is called,
unless C<no_chdir> was specified. Note that when changing to
directories is in effect the root directory (F</>) is a somewhat
special case inasmuch as the concatenation of C<$File::Find::dir>,
C<'/'> and C<$_> is not literally equal to C<$File::Find::name>. The
table below summarizes all variants:

              $File::Find::name  $File::Find::dir  $_
 default      /                  /                 .
 no_chdir=>0  /etc               /                 etc
              /etc/x             /etc              x

 no_chdir=>1  /                  /                 /
              /etc               /                 /etc
              /etc/x             /etc              /etc/x


When <follow> or <follow_fast> are in effect, there is
d163 3
a165 3
Notice the C<_> in the above C<int(-M _)>: the C<_> is a magical
filehandle that caches the information from the preceding
stat(), lstat(), or filetest.
d167 2
a168 2
Here's another interesting wanted function.  It will find all symbolic
links that don't resolve:
a176 11
=head1 WARNINGS

If you run your program with the C<-w> switch, or if you use the
C<warnings> pragma, File::Find will report warnings for several weird
situations. You can disable these warnings by putting the statement

    no warnings 'File::Find';

in the appropriate scope. See L<perllexwarn> for more info about lexical
warnings.

a178 18
=over 2

=item $dont_use_nlink

You can set the variable C<$File::Find::dont_use_nlink> to 1, if you want to
force File::Find to always stat directories. This was used for file systems
that do not have an C<nlink> count matching the number of sub-directories.
Examples are ISO-9660 (CD-ROM), AFS, HPFS (OS/2 file system), FAT (DOS file
system) and a couple of others.

You shouldn't need to set this variable, since File::Find should now detect
such file systems on-the-fly and switch itself to using stat. This works even
for parts of your file system, like a mounted CD-ROM.

If you do set C<$File::Find::dont_use_nlink> to 1, you will notice slow-downs.

=item symlinks

a186 82
=back

=head1 NOTES

=over 4

=item *

Mac OS (Classic) users should note a few differences:

=over 4

=item *   

The path separator is ':', not '/', and the current directory is denoted 
as ':', not '.'. You should be careful about specifying relative pathnames. 
While a full path always begins with a volume name, a relative pathname 
should always begin with a ':'.  If specifying a volume name only, a 
trailing ':' is required.

=item *   

C<$File::Find::dir> is guaranteed to end with a ':'. If C<$_> 
contains the name of a directory, that name may or may not end with a 
':'. Likewise, C<$File::Find::name>, which contains the complete 
pathname to that directory, and C<$File::Find::fullname>, which holds 
the absolute pathname of that directory with all symbolic links resolved,
may or may not end with a ':'.

=item *   

The default C<untaint_pattern> (see above) on Mac OS is set to  
C<qr|^(.+)$|>. Note that the parentheses are vital.

=item *   

The invisible system file "Icon\015" is ignored. While this file may 
appear in every directory, there are some more invisible system files 
on every volume, which are all located at the volume root level (i.e. 
"MacintoshHD:"). These system files are B<not> excluded automatically. 
Your filter may use the following code to recognize invisible files or 
directories (requires Mac::Files):

 use Mac::Files;

 # invisible() --  returns 1 if file/directory is invisible,  
 # 0 if it's visible or undef if an error occurred

 sub invisible($) { 
   my $file = shift;
   my ($fileCat, $fileInfo); 
   my $invisible_flag =  1 << 14; 

   if ( $fileCat = FSpGetCatInfo($file) ) {
     if ($fileInfo = $fileCat->ioFlFndrInfo() ) {
       return (($fileInfo->fdFlags & $invisible_flag) && 1);
     }
   }
   return undef;
 }

Generally, invisible files are system files, unless an odd application 
decides to use invisible files for its own purposes. To distinguish 
such files from system files, you have to look at the B<type> and B<creator> 
file attributes. The MacPerl built-in functions C<GetFileInfo(FILE)> and 
C<SetFileInfo(CREATOR, TYPE, FILES)> offer access to these attributes 
(see MacPerl.pm for details).

Files that appear on the desktop actually reside in an (hidden) directory
named "Desktop Folder" on the particular disk volume. Note that, although
all desktop files appear to be on the same "virtual" desktop, each disk 
volume actually maintains its own "Desktop Folder" directory.

=back

=back

=head1 HISTORY

File::Find used to produce incorrect results if called recursively.
During the development of perl 5.8 this bug was fixed.
The first fixed version of File::Find was 1.01.
d190 2
a191 2
our @@ISA = qw(Exporter);
our @@EXPORT = qw(find finddepth);
a195 1
my $Is_MacOS;
a197 1
require File::Spec;
d199 2
a200 5
# Should ideally be my() not our() but local() currently
# refuses to operate on lexicals

our %SLnkSeen;
our ($wanted_callback, $avoid_nlink, $bydepth, $no_chdir, $follow,
d202 1
a202 1
    $pre_process, $post_process, $dangling_symlinks);
d207 1
a207 1
    return substr($cdir,0,rindex($cdir,'/')) if $fn eq $File::Find::current_dir;
d216 1
a216 1
       1 while $abs_name =~ s!/[^/]*/\.\./!/!;
a221 46
# return the absolute name of a directory or file
sub contract_name_Mac {
    my ($cdir,$fn) = @@_; 
    my $abs_name;

    if ($fn =~ /^(:+)(.*)$/) { # valid pathname starting with a ':'

	my $colon_count = length ($1);
	if ($colon_count == 1) {
	    $abs_name = $cdir . $2;
	    return $abs_name;
	}
	else { 
	    # need to move up the tree, but 
	    # only if it's not a volume name
	    for (my $i=1; $i<$colon_count; $i++) {
		unless ($cdir =~ /^[^:]+:$/) { # volume name
		    $cdir =~ s/[^:]+:$//;
		}
		else {
		    return undef;
		}
	    }
	    $abs_name = $cdir . $2;
	    return $abs_name;
	}

    }
    else {

	# $fn may be a valid path to a directory or file or (dangling)
	# symlink, without a leading ':'
	if ( (-e $fn) || (-l $fn) ) {
	    if ($fn =~ /^[^:]+:/) { # a volume name like DataHD:*
		return $fn; # $fn is already an absolute path
	    }
	    else {
		$abs_name = $cdir . $fn;
		return $abs_name;
	    }
	}
	else { # argh!, $fn is not a valid directory/file 
	     return undef;
	}
    }
}
d227 2
a228 9
    if ($Is_MacOS) {
	# $Name is the resolved symlink (always a full path on MacOS),
	# i.e. there's no need to call contract_name_Mac()
	$AbsName = $Name; 

	# (simple) check for recursion
	if ( ( $Base =~ /^$AbsName/) && (-d $AbsName) ) { # recursion
	    return undef;
	}
d231 2
a232 6
	if (substr($Name,0,1) eq '/') {
	    $AbsName= $Name;
	}
	else {
	    $AbsName= contract_name($Base,$Name);
	}
d234 7
a240 8
	# (simple) check for recursion
	my $newlen= length($AbsName);
	if ($newlen <= length($Base)) {
	    if (($newlen == length($Base) || substr($Base,$newlen,1) eq '/')
		&& $AbsName eq substr($Base,0,$newlen))
	    {
		return undef;
	    }
d277 2
a278 2
    if ($full_check && defined $DEV && $SLnkSeen{$DEV, $INO}++) {
	if ( ($follow_skip < 1) || ((-d _) && ($follow_skip < 2)) ) {
a292 10
# check whether or not a scalar variable is tainted
# (code straight from the Camel, 3rd ed., page 561)
sub is_tainted_pp {
    my $arg = shift;
    my $nada = substr($arg, 0, 0); # zero-length
    local $@@;
    eval { eval "# $nada" };
    return length($@@) != 0;
} 

d297 13
a309 24
    # This function must local()ize everything because callbacks may
    # call find() or finddepth()

    local %SLnkSeen;
    local ($wanted_callback, $avoid_nlink, $bydepth, $no_chdir, $follow,
	$follow_skip, $full_check, $untaint, $untaint_skip, $untaint_pat,
	$pre_process, $post_process, $dangling_symlinks);
    local($dir, $name, $fullname, $prune);

    my $cwd            = $wanted->{bydepth} ? Cwd::fastcwd() : Cwd::getcwd();
    my $cwd_untainted  = $cwd;
    my $check_t_cwd    = 1;
    $wanted_callback   = $wanted->{wanted};
    $bydepth           = $wanted->{bydepth};
    $pre_process       = $wanted->{preprocess};
    $post_process      = $wanted->{postprocess};
    $no_chdir          = $wanted->{no_chdir};
    $full_check        = $wanted->{follow};
    $follow            = $full_check || $wanted->{follow_fast};
    $follow_skip       = $wanted->{follow_skip};
    $untaint           = $wanted->{untaint};
    $untaint_pat       = $wanted->{untaint_pattern};
    $untaint_skip      = $wanted->{untaint_skip};
    $dangling_symlinks = $wanted->{dangling_symlinks};
d311 2
a312 2
    # for compatibility reasons (find.pl, find2perl)
    local our ($topdir, $topdev, $topino, $topmode, $topnlink);
d317 5
d326 19
a344 51
	my $top_item = $TOP;

	if ($Is_MacOS) {
	    ($topdev,$topino,$topmode,$topnlink) = $follow ? stat $top_item : lstat $top_item;
	    $top_item = ":$top_item"
		if ( (-d _) && ( $top_item !~ /:/ ) );
	}
	else {
	    $top_item =~ s|/\z|| unless $top_item eq '/';
	    ($topdev,$topino,$topmode,$topnlink) = $follow ? stat $top_item : lstat $top_item;
	}

	$Is_Dir= 0;

	if ($follow) {

	    if ($Is_MacOS) {
		$cwd = "$cwd:" unless ($cwd =~ /:$/); # for safety

		if ($top_item eq $File::Find::current_dir) {
		    $abs_dir = $cwd;
		}
		else {
		    $abs_dir = contract_name_Mac($cwd, $top_item);
		    unless (defined $abs_dir) {
			warnings::warnif "Can't determine absolute path for $top_item (No such file or directory)\n";
			next Proc_Top_Item;
		    }
		}

	    }
	    else {
		if (substr($top_item,0,1) eq '/') {
		    $abs_dir = $top_item;
		}
		elsif ($top_item eq $File::Find::current_dir) {
		    $abs_dir = $cwd;
		}
		else {  # care about any  ../
		    $abs_dir = contract_name("$cwd/",$top_item);
		}
	    }
	    $abs_dir= Follow_SymLink($abs_dir);
	    unless (defined $abs_dir) {
		if ($dangling_symlinks) {
		    if (ref $dangling_symlinks eq 'CODE') {
			$dangling_symlinks->($top_item, $cwd);
		    } else {
			warnings::warnif "$top_item is a dangling symbolic link\n";
		    }
		}
d346 2
a347 3
	    }

	    if (-d _) {
d350 2
a351 2
	    }
	}
d353 6
a358 6
	    $topdir = $top_item;
	    unless (defined $topnlink) {
		warnings::warnif "Can't stat $top_item: $!\n";
		next Proc_Top_Item;
	    }
	    if (-d _) {
d362 1
a362 1
	    }
d365 2
a366 2
	    }
	}
d368 1
a368 1
	unless ($Is_Dir) {
d370 1
a370 6
		if ($Is_MacOS) {
		    ($dir,$_) = (':', $top_item); # $File::Find::dir, $_
		}
		else {
		    ($dir,$_) = ('./', $top_item);
		}
d373 4
a376 3
	    $abs_dir = $dir;
	    if (( $untaint ) && (is_tainted($dir) )) {
		( $abs_dir ) = $dir =~ m|$untaint_pat|;
d379 1
a379 1
			die "directory $dir is still tainted";
d385 1
a385 1
	    }
d387 4
a390 4
	    unless ($no_chdir || chdir $abs_dir) {
		warnings::warnif "Couldn't chdir $abs_dir: $!\n";
		next Proc_Top_Item;
	    }
d392 1
a392 1
	    $name = $abs_dir . $_; # $File::Find::name
d394 1
a394 1
	    { $wanted_callback->() }; # protect against wild "next"
d396 1
a396 1
	}
d398 1
a398 12
	unless ( $no_chdir ) {
	    if ( ($check_t_cwd) && (($untaint) && (is_tainted($cwd) )) ) {
		( $cwd_untainted ) = $cwd =~ m|$untaint_pat|;
		unless (defined $cwd_untainted) {
		    die "insecure cwd in find(depth)";
		}
		$check_t_cwd = 0;
	    }
	    unless (chdir $cwd_untainted) {
		die "Can't cd to $cwd: $!\n";
	    }
	}
d417 2
a418 11
    my $dir_pref;
    my $dir_rel = $File::Find::current_dir;
    my $tainted = 0;
    my $no_nlink;

    if ($Is_MacOS) {
	$dir_pref= ($p_dir =~ /:$/) ? $p_dir : "$p_dir:"; # preface
    }
    else {
	$dir_pref= ( $p_dir eq '/' ? '/' : "$p_dir/" );
    }
d421 2
a422 2

    unless ( $no_chdir || ($p_dir eq $File::Find::current_dir)) {
d424 2
a425 2
	if (( $untaint ) && (is_tainted($p_dir) )) {
	    ( $udir ) = $p_dir =~ m|$untaint_pat|;
d436 1
a436 1
	    warnings::warnif "Can't cd to $udir: $!\n";
d440 1
a440 2

    # push the starting directory
a442 4
    if ($Is_MacOS) {
	$p_dir = $dir_pref;  # ensure trailing ':'
    }

d445 3
a447 3
	    $dir= $p_dir; # $File::Find::dir 
	    $name= $dir_name; # $File::Find::name 
	    $_= ($no_chdir ? $dir_name : $dir_rel ); # $_
d449 3
a451 3
	    $prune= 0;
	    { $wanted_callback->() };	# protect against wild "next"
	    next if $prune;
d453 1
a453 1

d455 1
a455 1
	unless ($no_chdir || ($dir_rel eq $File::Find::current_dir)) {
d457 2
a458 2
	    if ( ($untaint) && (($tainted) || ($tainted = is_tainted($dir_rel) )) ) {
		( $udir ) = $dir_rel =~ m|$untaint_pat|;
d461 3
a463 8
			if ($Is_MacOS) {
			    die "directory ($p_dir) $dir_rel is still tainted";
			}
			else {
			    die "directory (" . ($p_dir ne '/' ? $p_dir : '') . "/) $dir_rel is still tainted";
			}
		    } else { # $untaint_skip == 1
			next; 
d468 3
a470 7
		if ($Is_MacOS) {
		    warnings::warnif "Can't cd to ($p_dir) $udir: $!\n";
		}
		else {
		    warnings::warnif "Can't cd to (" .
			($p_dir ne '/' ? $p_dir : '') . "/) $udir: $!\n";
		}
d476 1
a476 5
	if ($Is_MacOS) {
	    $dir_name = "$dir_name:" unless ($dir_name =~ /:$/);
	}

	$dir= $dir_name; # $File::Find::dir 
d479 2
a480 2
	unless (opendir DIR, ($no_chdir ? $dir_name : $File::Find::current_dir)) {
	    warnings::warnif "Can't opendir($dir_name): $!\n";
d485 1
a485 1
	@@filenames = $pre_process->(@@filenames) if $pre_process;
d488 1
a488 7
	# default: use whatever was specifid
        # (if $nlink >= 2, and $avoid_nlink == 0, this will switch back)
        $no_nlink = $avoid_nlink;
        # if dir has wrong nlink count, force switch to slower stat method
        $no_nlink = 1 if ($nlink < 2);

	if ($nlink == 2 && !$no_nlink) {
d491 1
a491 1
		next if $FN =~ $File::Find::skip_pattern;
d493 3
a495 3
		$name = $dir_pref . $FN; # $File::Find::name
		$_ = ($no_chdir ? $name : $FN); # $_
		{ $wanted_callback->() }; # protect against wild "next"
d504 2
a505 2
		next if $FN =~ $File::Find::skip_pattern;
		if ($subcount > 0 || $no_nlink) {
d517 3
a519 3
			$name = $dir_pref . $FN; # $File::Find::name
			$_= ($no_chdir ? $name : $FN); # $_
			{ $wanted_callback->() }; # protect against wild "next"
d523 3
a525 3
		    $name = $dir_pref . $FN; # $File::Find::name
		    $_= ($no_chdir ? $name : $FN); # $_
		    { $wanted_callback->() }; # protect against wild "next"
d534 3
a536 9
		my $tmp;
		if ($Is_MacOS) {
		    $tmp = (':' x ($CdLvl-$Level)) . ':';
		}
		else {
		    $tmp = join('/',('..') x ($CdLvl-$Level));
		}
		die "Can't cd to $dir_name" . $tmp
		    unless chdir ($tmp);
d539 2
a540 12

	    if ($Is_MacOS) {
		# $pdir always has a trailing ':', except for the starting dir,
		# where $dir_rel eq ':'
		$dir_name = "$p_dir$dir_rel";
		$dir_pref = "$dir_name:";
	    }
	    else {
		$dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
		$dir_pref = "$dir_name/";
	    }

d542 18
a559 30
		$name = $dir = $p_dir; # $File::Find::name / dir
                $_ = $File::Find::current_dir;
		$post_process->();		# End-of-directory processing
	    }
	    elsif ( $nlink < 0 ) {  # must be finddepth, report dirname now
		$name = $dir_name;
		if ($Is_MacOS) {
		    if ($dir_rel eq ':') { # must be the top dir, where we started
			$name =~ s|:$||; # $File::Find::name
			$p_dir = "$p_dir:" unless ($p_dir =~ /:$/);
		    }
		    $dir = $p_dir; # $File::Find::dir
		    $_ = ($no_chdir ? $name : $dir_rel); # $_
		}
		else {
		    if ( substr($name,-2) eq '/.' ) {
			substr($name, length($name) == 2 ? -1 : -2) = '';
		    }
		    $dir = $p_dir;
		    $_ = ($no_chdir ? $dir_name : $dir_rel );
		    if ( substr($_,-2) eq '/.' ) {
			substr($_, length($_) == 2 ? -1 : -2) = '';
		    }
		}
		{ $wanted_callback->() }; # protect against wild "next"
	     }
	     else {
		push @@Stack,[$CdLvl,$p_dir,$dir_rel,-1]  if  $bydepth;
		last;
	    }
d573 1
a573 1
    my ($wanted, $dir_loc, $p_dir) = @@_; # $dir_loc is the absolute directory
d577 1
a577 1
    my $updir_loc = $dir_loc; # untainted parent directory
d580 4
a583 14
    my $dir_pref;
    my $loc_pref;
    my $dir_rel = $File::Find::current_dir;
    my $byd_flag; # flag for pending stack entry if $bydepth
    my $tainted = 0;
    my $ok = 1;

    if ($Is_MacOS) {
	$dir_pref = ($p_dir =~ /:$/) ? "$p_dir" : "$p_dir:";
	$loc_pref = ($dir_loc =~ /:$/) ? "$dir_loc" : "$dir_loc:";
    } else {
	$dir_pref = ( $p_dir   eq '/' ? '/' : "$p_dir/" );
	$loc_pref = ( $dir_loc eq '/' ? '/' : "$dir_loc/" );
    }
d586 6
a591 9

    unless ($no_chdir) {
	# untaint the topdir
	if (( $untaint ) && (is_tainted($dir_loc) )) {
	    ( $updir_loc ) = $dir_loc =~ m|$untaint_pat|; # parent dir, now untainted
	     # once untainted, $updir_loc is pushed on the stack (as parent directory);
	    # hence, we don't need to untaint the parent directory every time we chdir 
	    # to it later 
	    unless (defined $updir_loc) {
d600 2
a601 3
	$ok = chdir($updir_loc) unless ($p_dir eq $File::Find::current_dir);
	unless ($ok) {
	    warnings::warnif "Can't cd to $updir_loc: $!\n";
d606 1
a606 5
    push @@Stack,[$dir_loc,$updir_loc,$p_dir,$dir_rel,-1]  if  $bydepth;

    if ($Is_MacOS) {
	$p_dir = $dir_pref; # ensure trailing ':'
    }
d611 1
a611 1
	    # change (back) to parent directory (always untainted)
d613 6
a618 2
		unless (chdir $updir_loc) {
		    warnings::warnif "Can't cd to $updir_loc: $!\n";
d622 4
a625 4
	    $dir= $p_dir; # $File::Find::dir
	    $name= $dir_name; # $File::Find::name
	    $_= ($no_chdir ? $dir_name : $dir_rel ); # $_
	    $fullname= $dir_loc; # $File::Find::fullname
d627 1
a627 1
	    $prune= 0;
d629 2
a630 2
	    { $wanted_callback->() }; # protect against wild "next"
	    next if $prune;
d634 5
a638 6
	unless ($no_chdir || ($dir_rel eq $File::Find::current_dir)) {
	    $updir_loc = $dir_loc;
	    if ( ($untaint) && (($tainted) || ($tainted = is_tainted($dir_loc) )) ) {
		# untaint $dir_loc, what will be pushed on the stack as (untainted) parent dir 
		( $updir_loc ) = $dir_loc =~ m|$untaint_pat|;
		unless (defined $updir_loc) {
d647 2
a648 2
	    unless (chdir $updir_loc) {
		warnings::warnif "Can't cd to $updir_loc: $!\n";
d653 1
a653 5
	if ($Is_MacOS) {
	    $dir_name = "$dir_name:" unless ($dir_name =~ /:$/);
	}

	$dir = $dir_name; # $File::Find::dir
d656 2
a657 2
	unless (opendir DIR, ($no_chdir ? $dir_loc : $File::Find::current_dir)) {
	    warnings::warnif "Can't opendir($dir_loc): $!\n";
d664 1
a664 1
	    next if $FN =~ $File::Find::skip_pattern;
d671 1
a671 1

d673 1
a673 1
		push @@Stack,[$new_loc,$updir_loc,$dir_name,$FN,1];
d676 4
a679 4
		$fullname = $new_loc; # $File::Find::fullname 
		$name = $dir_pref . $FN; # $File::Find::name
		$_ = ($no_chdir ? $name : $FN); # $_
		{ $wanted_callback->() }; # protect against wild "next"
d686 32
a717 48
	    ($dir_loc, $updir_loc, $p_dir, $dir_rel, $byd_flag) = @@$SE;
	    if ($Is_MacOS) {
		# $p_dir always has a trailing ':', except for the starting dir,
		# where $dir_rel eq ':'
		$dir_name = "$p_dir$dir_rel";
		$dir_pref = "$dir_name:";
		$loc_pref = ($dir_loc =~ /:$/) ? $dir_loc : "$dir_loc:";
	    }
	    else {
		$dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
		$dir_pref = "$dir_name/";
		$loc_pref = "$dir_loc/";
	    }
	    if ( $byd_flag < 0 ) {  # must be finddepth, report dirname now
		unless ($no_chdir || ($dir_rel eq $File::Find::current_dir)) {
		    unless (chdir $updir_loc) { # $updir_loc (parent dir) is always untainted 
			warnings::warnif "Can't cd to $updir_loc: $!\n";
			next;
		    }
		}
		$fullname = $dir_loc; # $File::Find::fullname
		$name = $dir_name; # $File::Find::name
		if ($Is_MacOS) {
		    if ($dir_rel eq ':') { # must be the top dir, where we started
			$name =~ s|:$||; # $File::Find::name
			$p_dir = "$p_dir:" unless ($p_dir =~ /:$/);
		    }
		    $dir = $p_dir; # $File::Find::dir
		     $_ = ($no_chdir ? $name : $dir_rel); # $_
		}
		else {
		    if ( substr($name,-2) eq '/.' ) {
			substr($name, length($name) == 2 ? -1 : -2) = ''; # $File::Find::name
		    }
		    $dir = $p_dir; # $File::Find::dir
		    $_ = ($no_chdir ? $dir_name : $dir_rel); # $_
		    if ( substr($_,-2) eq '/.' ) {
			substr($_, length($_) == 2 ? -1 : -2) = '';
		    }
		}

		lstat($_); # make sure file tests with '_' work
		{ $wanted_callback->() }; # protect against wild "next"
	    }
	    else {
		push @@Stack,[$dir_loc, $updir_loc, $p_dir, $dir_rel,-1]  if  $bydepth;
		last;
	    }
d730 1
a730 1
	    $wanted->{untaint_pattern} = $File::Find::untaint_pattern  
d744 1
d751 1
a753 4
# default
$File::Find::skip_pattern    = qr/^\.{1,2}\z/;
$File::Find::untaint_pattern = qr|^([-+@@\w./]+)$|;

d757 1
a757 7
    $File::Find::dont_use_nlink  = 1;
}
elsif ($^O eq 'MacOS') {
    $Is_MacOS = 1;
    $File::Find::dont_use_nlink  = 1;
    $File::Find::skip_pattern    = qr/^Icon\015\z/;
    $File::Find::untaint_pattern = qr|^(.+)$|;
a759 4
# this _should_ work properly on all platforms
# where File::Find can be expected to work
$File::Find::current_dir = File::Spec->curdir || '.';

d762 1
a762 2
       $^O eq 'cygwin' || $^O eq 'epoc' || $^O eq 'qnx' ||
	   $^O eq 'nto';
a770 9
}

# We need a function that checks if a scalar is tainted. Either use the 
# Scalar::Util module's tainted() function or our (slower) pure Perl 
# fallback is_tainted_pp()
{
    local $@@;
    eval { require Scalar::Util };
    *is_tainted = $@@ ? \&is_tainted_pp : \&Scalar::Util::tainted;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d6 1
a6 1
our $VERSION = '1.05';
a9 6
#
# Modified to ensure sub-directory traversal order is not inverded by stack
# push and pops.  That is remains in the same order as in the directory file,
# or user pre-processing (EG:sorted).
#

d17 1
a17 1
    find(\&wanted, @@directories_to_search);
d42 1
a42 1
order they are given.  In essence, it works from the top down.
d571 1
a571 1
    local($dir, $name, $fullname, $prune, $_);
d665 1
a665 1
		$top_item =~ s/\.dir\z//i if $Is_VMS;
a702 1
	    $_ = $name if $no_chdir;
d765 1
a765 1
	unless (chdir ($Is_VMS && $udir !~ /[\/\[<]+/ ? "./$udir" : $udir)) {
d807 1
a807 1
	    unless (chdir ($Is_VMS && $udir !~ /[\/\[<]+/ ? "./$udir" : $udir)) {
a856 5
	    # HACK: insert directories at this position. so as to preserve
	    # the user pre-processed ordering of files.
	    # EG: directory traversal is in user sorted order, not at random.
            my $stack_top = @@Stack;

d867 2
a868 5
			$FN =~ s/\.dir\z//i if $Is_VMS;
			# HACK: replace push to preserve dir traversal order
			#push @@Stack,[$CdLvl,$dir_name,$FN,$sub_nlink];
			splice @@Stack, $stack_top, 0,
			         [$CdLvl,$dir_name,$FN,$sub_nlink];
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d6 1
a6 1
our $VERSION = '1.06';
d47 1
a47 1
C<find()> does a breadth-first search over the given C<@@directories> in the
d50 3
a52 4
For each file or directory found, the C<&wanted> subroutine is called,
with the return code ignored.  (See below for details on how to use
the C<&wanted> function).  Additionally, for each directory found,
it will go into that directory and continue the search.
d59 1
a59 1
C<finddepth()> works just like C<find()> except it does a depth-first search.
d66 2
a67 3
The first argument to C<find()> is either a code reference to your
C<&wanted> function, or a hash reference describing the operations
to be performed for each file.  The
d82 2
a83 2
have been reported.  Entry point C<finddepth()> is a shortcut for
specifying C<<{ bydepth => 1 }>> in the first argument of C<find()>.
d88 3
a90 3
preprocess the current directory. The name of the currently processed 
directory is in C<$File::Find::dir>. Your preprocessing function is
called after C<readdir()>, but before the loop that calls the C<wanted()>
d101 1
a101 1
arguments. The name of the current directory is in C<$File::Find::dir>. This 
d120 1
a120 1
C<wanted()> function is called. This enables fast file checks involving S< _>.
d134 1
a134 1
processing a file more than once (by the user's C<wanted()> function)
a142 1

a144 1

d158 1
a158 1
Does not C<chdir()> to each directory as it recurses. The C<wanted()>
d186 2
a187 7
The C<wanted()> function does whatever verifications you want on
each file and directory.  Note that despite its name, the C<wanted()>
function is a generic callback function, and does B<not> tell
File::Find if a file is "wanted" or not.  In fact, its return value
is ignored.

The wanted function takes no arguments but rather does its work
d202 1
a202 1
For example, when examining the file F</some/path/foo.ext> you will have:
d254 1
a254 1
C<stat()>, C<lstat()>, or filetest.
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d6 1
a6 1
our $VERSION = '1.07';
d47 7
a53 6
C<find()> does a depth-first search over the given C<@@directories> in
the order they are given.  For each file or directory found, it calls
the C<&wanted> subroutine.  (See below for details on how to use the
C<&wanted> function).  Additionally, for each directory found, it will
C<chdir()> into that directory and continue the search, invoking the
C<&wanted> function on each file or subdirectory in the directory.
d60 2
a61 5
C<finddepth()> works just like C<find()> except that is invokes the
C<&wanted> function for a directory I<after> invoking it for the
directory's contents.  It does a postorder traversal instead of a
preorder traversal, working from the bottom of the directory tree up
where C<find()> works from the top of the tree down.
a390 6
=head1 BUGS AND CAVEATS

Despite the name of the C<finddepth()> function, both C<find()> and
C<finddepth()> perform a depth-first search of the directory
hierarchy.

d586 1
a586 2
    local($dir, $name, $fullname, $prune);
    local *_ = \my $a;
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d6 1
a6 1
our $VERSION = '1.10';
d91 2
a92 2
The value should be a code reference. This code reference is used to
preprocess the current directory. The name of the currently processed
d95 4
a98 4
function. It is called with a list of strings (actually file/directory
names) and is expected to return a list of strings. The code can be
used to sort the file/directory names alphabetically, numerically,
or to filter out directory entries based on their name alone. When
d103 5
a107 5
The value should be a code reference. It is invoked just before leaving
the currently processed directory. It is called in void context with no
arguments. The name of the current directory is in C<$File::Find::dir>. This
hook is handy for summarizing a directory, such as calculating its disk
usage. When I<follow> or I<follow_fast> are in effect, C<postprocess> is a
d124 1
a124 3
C<wanted()> function is called. This enables fast file checks involving S<_>.
Note that this guarantee no longer holds if I<follow> or I<follow_fast>
are not set.
d129 1
a129 2
pathname of the file with all symbolic links resolved.  If the link is
a dangling symbolic link, then fullname will be set to C<undef>.
a132 2
This is a no-op on Win32.

a140 2
This is also a no-op on Win32.

d145 1
a145 1
to be processed a second time. If a directory or a symbolic link
d173 2
a174 2
expression I<untaint_pattern>.  Note that all names passed to the user's
I<wanted()> function are still tainted. If this option is used while
d180 1
a180 1
The default is set to  C<qr|^([-+@@\w./]+)$|>.
d185 1
a185 1
If set, a directory which fails the I<untaint_pattern> is skipped,
d219 1
a219 1
You are chdir()'d to C<$File::Find::dir> when the function is called,
d311 1
a311 1
more than once (only if C<follow_fast> is in effect).
d328 1
a328 1
=item *
d330 4
a333 4
The path separator is ':', not '/', and the current directory is denoted
as ':', not '.'. You should be careful about specifying relative pathnames.
While a full path always begins with a volume name, a relative pathname
should always begin with a ':'.  If specifying a volume name only, a
d336 1
a336 1
=item *
d338 4
a341 4
C<$File::Find::dir> is guaranteed to end with a ':'. If C<$_>
contains the name of a directory, that name may or may not end with a
':'. Likewise, C<$File::Find::name>, which contains the complete
pathname to that directory, and C<$File::Find::fullname>, which holds
d345 1
a345 1
=item *
d347 1
a347 1
The default C<untaint_pattern> (see above) on Mac OS is set to
d350 1
a350 1
=item *
d352 5
a356 5
The invisible system file "Icon\015" is ignored. While this file may
appear in every directory, there are some more invisible system files
on every volume, which are all located at the volume root level (i.e.
"MacintoshHD:"). These system files are B<not> excluded automatically.
Your filter may use the following code to recognize invisible files or
d361 1
a361 1
 # invisible() --  returns 1 if file/directory is invisible,
d364 1
a364 1
 sub invisible($) {
d366 2
a367 2
   my ($fileCat, $fileInfo);
   my $invisible_flag =  1 << 14;
d377 5
a381 5
Generally, invisible files are system files, unless an odd application
decides to use invisible files for its own purposes. To distinguish
such files from system files, you have to look at the B<type> and B<creator>
file attributes. The MacPerl built-in functions C<GetFileInfo(FILE)> and
C<SetFileInfo(CREATOR, TYPE, FILES)> offer access to these attributes
d386 1
a386 1
all desktop files appear to be on the same "virtual" desktop, each disk
d446 1
a446 1
    my ($cdir,$fn) = @@_;
d456 2
a457 2
	else {
	    # need to move up the tree, but
d485 1
a485 1
	else { # argh!, $fn is not a valid directory/file
d498 1
a498 1
	$AbsName = $Name;
d581 1
a581 1
}
d605 2
a606 3
    $full_check        = $^O eq 'MSWin32' ? 0 : $wanted->{follow};
    $follow            = $^O eq 'MSWin32' ? 0 :
                             $full_check || $wanted->{follow_fast};
d618 1
a618 1

a624 2
	($topdev,$topino,$topmode,$topnlink) = $follow ? stat $top_item : lstat $top_item;

d626 1
a628 2
	} elsif ($^O eq 'MSWin32') {
	    $top_item =~ s|/\z|| unless $top_item =~ m|\w:/$|;
d632 1
a769 2
    } elsif ($^O eq 'MSWin32') {
	$dir_pref = ($p_dir =~ m|\w:/$| ? $p_dir : "$p_dir/" );
d805 2
a806 2
	    $dir= $p_dir; # $File::Find::dir
	    $name= $dir_name; # $File::Find::name
d828 1
a828 1
			next;
d849 1
a849 1
	$dir= $dir_name; # $File::Find::dir
a938 4
	    elsif ($^O eq 'MSWin32') {
		$dir_name = ($p_dir =~ m|\w:/$| ? "$p_dir$dir_rel" : "$p_dir/$dir_rel");
		$dir_pref = "$dir_name/";
	    }
d1017 2
a1018 2
	    # hence, we don't need to untaint the parent directory every time we chdir
	    # to it later
d1066 1
a1066 1
		# untaint $dir_loc, what will be pushed on the stack as (untainted) parent dir
d1104 1
a1104 15
	    unless (defined $new_loc) {
	        if ($dangling_symlinks) {
	            if (ref $dangling_symlinks eq 'CODE') {
	                $dangling_symlinks->($FN, $dir_pref);
	            } else {
	                warnings::warnif "$dir_pref$FN is a dangling symbolic link\n";
	            }
	        }

	        $fullname = undef;
	        $name = $dir_pref . $FN;
	        $_ = ($no_chdir ? $name : $FN);
	        { $wanted_callback->() };
	        next;
	    }
d1110 1
a1110 1
		$fullname = $new_loc; # $File::Find::fullname
d1135 1
a1135 1
		    unless (chdir $updir_loc) { # $updir_loc (parent dir) is always untainted
d1180 1
a1180 1
	    $wanted->{untaint_pattern} = $File::Find::untaint_pattern
d1224 1
a1224 1
       $^O eq 'interix' || $^O eq 'cygwin' || $^O eq 'epoc' || $^O eq 'qnx' ||
d1236 2
a1237 2
# We need a function that checks if a scalar is tainted. Either use the
# Scalar::Util module's tainted() function or our (slower) pure Perl
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d6 1
a6 1
our $VERSION = '1.12';
d59 1
a59 1
C<finddepth()> works just like C<find()> except that it invokes the
d218 1
a218 2
The above variables have all been localized and may be changed without
effecting data outside of the wanted function.
a604 14
    if ($Is_VMS) {
	# VMS returns this by default in VMS format which just doesn't
	# work for the rest of this module.
	$cwd = VMS::Filespec::unixpath($cwd);

	# Apparently this is not expected to have a trailing space.
	# To attempt to make VMS/UNIX conversions mostly reversable,
	# a trailing slash is needed.  The run-time functions ignore the
	# resulting double slash, but it causes the perl tests to fail.
        $cwd =~ s#/\z##;

	# This comes up in upper case now, but should be lower.
	# In the future this could be exact case, no need to change.
    }
a671 1
		    $top_item =~ s/\.dir\z//i if $Is_VMS;
a687 1
		$top_item =~ s/\.dir\z//i if $Is_VMS;
a781 10
    } elsif ($^O eq 'VMS') {

	#	VMS is returning trailing .dir on directories
	#	and trailing . on files and symbolic links
	#	in UNIX syntax.
	#

	$p_dir =~ s/\.(dir)?$//i unless $p_dir eq '.';

	$dir_pref = ($p_dir =~ m/[\]>]+$/ ? $p_dir : "$p_dir/" );
a881 8
		if ($Is_VMS) {
		# Big hammer here - Compensate for VMS trailing . and .dir
		# No win situation until this is changed, but this
		# will handle the majority of the cases with breaking the fewest

		    $FN =~ s/\.dir\z//i;
		    $FN =~ s#\.$## if ($FN ne '.');
		}
a936 3
		elsif ($Is_VMS) {
		    $tmp = '[' . ('-' x ($CdLvl-$Level)) . ']';
		}
d940 1
a940 1
		die "Can't cd to $tmp from $dir_name"
a954 11
	    elsif ($^O eq 'VMS') {
                if ($p_dir =~ m/[\]>]+$/) {
                    $dir_name = $p_dir;
                    $dir_name =~ s/([\]>]+)$/.$dir_rel$1/;
                    $dir_pref = $dir_name;
                }
                else {
                    $dir_name = "$p_dir/$dir_rel";
                    $dir_pref = "$dir_name/";
                }
	    }
a1113 8
	    if ($Is_VMS) {
	    # Big hammer here - Compensate for VMS trailing . and .dir
	    # No win situation until this is changed, but this
	    # will handle the majority of the cases with breaking the fewest.

		$FN =~ s/\.dir\z//i;
		$FN =~ s#\.$## if ($FN ne '.');
	    }
d1121 1
a1121 1
	        if (!defined -l _ && $dangling_symlinks) {
a1136 6
		if ($Is_VMS) {
		    $FN =~ s/\.dir\z//i;
		    $FN =~ s#\.$## if ($FN ne '.');
		    $new_loc =~ s/\.dir\z//i;
		    $new_loc =~ s#\.$## if ($new_loc ne '.');
		}
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d6 1
a6 1
our $VERSION = '1.14';
d81 1
a81 2
described in L<The wanted function> below. The C<&wanted> subroutine is
mandatory.
d87 1
a87 1
specifying C<< { bydepth => 1 } >> in the first argument of C<find()>.
d244 1
a244 1
When C<follow> or C<follow_fast> are in effect, there is
a412 4
=head1 SEE ALSO

find, find2perl.

d798 1
a798 1
	$dir_pref = ($p_dir =~ m|\w:/?$| ? $p_dir : "$p_dir/" );
d990 1
a990 1
		$dir_name = ($p_dir =~ m|\w:/?$| ? "$p_dir$dir_rel" : "$p_dir/$dir_rel");
a1268 3
        unless( exists $wanted->{wanted} and ref( $wanted->{wanted} ) eq 'CODE' ) {
            die 'no &wanted subroutine given';
        }
d1279 1
a1279 1
    elsif( ref( $wanted ) eq 'CODE' ) {
a1280 3
    }
    else {
       die 'no &wanted subroutine given';
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d6 1
a6 1
our $VERSION = '1.15';
d220 1
a220 1
affecting data outside of the wanted function.
d451 1
a451 1
       1 while $abs_name =~ s!/[^/]*/\.\./+!/!;
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 1
a6 1
our $VERSION = '1.20';
d11 1
a11 1
# Modified to ensure sub-directory traversal order is not inverted by stack
d117 1
a117 1
directory tree. See L</follow_fast> and L</follow_skip> below.
d327 75
d426 1
a426 1
my $Is_Win32;
d457 47
d508 9
a516 2
    if (substr($Name,0,1) eq '/') {
	$AbsName= $Name;
d519 6
a524 2
	$AbsName= contract_name($Base,$Name);
    }
d526 8
a533 7
    # (simple) check for recursion
    my $newlen= length($AbsName);
    if ($newlen <= length($Base)) {
	if (($newlen == length($Base) || substr($Base,$newlen,1) eq '/')
	    && $AbsName eq substr($Base,0,$newlen))
	{
	    return undef;
d632 2
a633 2
    $full_check        = $Is_Win32 ? 0 : $wanted->{follow};
    $follow            = $Is_Win32 ? 0 :
d655 5
a659 3
	if ($Is_Win32) {
	    $top_item =~ s|[/\\]\z||
	      unless $top_item =~ m{^(?:\w:)?[/\\]$};
d669 14
a682 2
	    if (substr($top_item,0,1) eq '/') {
		$abs_dir = $top_item;
d684 11
a694 6
	    elsif ($top_item eq $File::Find::current_dir) {
		$abs_dir = $cwd;
	    }
	    else {  # care about any  ../
		$top_item =~ s/\.dir\z//i if $Is_VMS;
		$abs_dir = contract_name("$cwd/",$top_item);
d732 6
a737 1
		($dir,$_) = ('./', $top_item);
d800 5
a804 4
    if ($Is_Win32) {
	$dir_pref
	  = ($p_dir =~ m{^(?:\w:[/\\]?|[/\\])$} ? $p_dir : "$p_dir/" );
    } elsif ($Is_VMS) {
d843 4
d865 6
a870 1
			die "directory (" . ($p_dir ne '/' ? $p_dir : '') . "/) $dir_rel is still tainted";
d877 7
a883 2
		warnings::warnif "Can't cd to (" .
		    ($p_dir ne '/' ? $p_dir : '') . "/) $udir: $!\n";
d889 4
d905 1
a905 1
	# default: use whatever was specified
d974 4
a977 1
		if ($Is_VMS) {
d988 8
a995 3
	    if ($Is_Win32) {
		$dir_name = ($p_dir =~ m{^(?:\w:[/\\]?|[/\\])$}
		    ? "$p_dir$dir_rel" : "$p_dir/$dir_rel");
d1021 7
a1027 2
		if ( substr($name,-2) eq '/.' ) {
		    substr($name, length($name) == 2 ? -1 : -2) = '';
d1029 9
a1037 4
		$dir = $p_dir;
		$_ = ($no_chdir ? $dir_name : $dir_rel );
		if ( substr($_,-2) eq '/.' ) {
		    substr($_, length($_) == 2 ? -1 : -2) = '';
d1072 7
a1078 2
    $dir_pref = ( $p_dir   eq '/' ? '/' : "$p_dir/" );
    $loc_pref = ( $dir_loc eq '/' ? '/' : "$dir_loc/" );
d1107 4
d1153 4
d1219 12
a1230 3
	    $dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
	    $dir_pref = "$dir_name/";
	    $loc_pref = "$dir_loc/";
d1240 7
a1246 2
		if ( substr($name,-2) eq '/.' ) {
		    substr($name, length($name) == 2 ? -1 : -2) = ''; # $File::Find::name
d1248 9
a1256 4
		$dir = $p_dir; # $File::Find::dir
		$_ = ($no_chdir ? $dir_name : $dir_rel); # $_
		if ( substr($_,-2) eq '/.' ) {
		    substr($_, length($_) == 2 ? -1 : -2) = '';
d1315 5
a1319 2
elsif ($^O eq 'MSWin32') {
    $Is_Win32 = 1;
d1327 1
a1327 1
    if $^O eq 'os2' || $^O eq 'dos' || $^O eq 'amigaos' || $Is_Win32 ||
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d6 1
a6 1
our $VERSION = '1.23';
a282 8
Note that you may mix directories and (non-directory) files in the list of 
directories to be searched by the C<wanted()> function.

    find(\&wanted, "./foo", "./bar", "./baz/epsilon");

In the example above, no file in F<./baz/> other than F<./baz/epsilon> will be
evaluated by C<wanted()>.

a517 1
	$top_item = VMS::Filespec::unixify($top_item) if $Is_VMS;
d1098 2
a1099 1
       $^O eq 'interix' || $^O eq 'cygwin' || $^O eq 'qnx' || $^O eq 'nto';
@


