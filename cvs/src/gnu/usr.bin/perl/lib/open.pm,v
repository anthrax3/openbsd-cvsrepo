head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_0:1.1.1.9.0.16
	OPENBSD_6_0_BASE:1.1.1.9
	OPENBSD_5_9:1.1.1.9.0.10
	OPENBSD_5_9_BASE:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.12
	OPENBSD_5_8_BASE:1.1.1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.4
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.9.0.8
	OPENBSD_5_6_BASE:1.1.1.9
	PERL_5_18_2:1.1.1.9
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.9.0.6
	OPENBSD_5_5_BASE:1.1.1.9
	OPENBSD_5_4:1.1.1.9.0.2
	OPENBSD_5_4_BASE:1.1.1.9
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.1.1.8.0.14
	OPENBSD_5_3_BASE:1.1.1.8
	OPENBSD_5_2:1.1.1.8.0.12
	OPENBSD_5_2_BASE:1.1.1.8
	OPENBSD_5_1_BASE:1.1.1.8
	OPENBSD_5_1:1.1.1.8.0.10
	OPENBSD_5_0:1.1.1.8.0.8
	OPENBSD_5_0_BASE:1.1.1.8
	OPENBSD_4_9:1.1.1.8.0.6
	OPENBSD_4_9_BASE:1.1.1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.1.1.8.0.4
	OPENBSD_4_8_BASE:1.1.1.8
	OPENBSD_4_7:1.1.1.8.0.2
	OPENBSD_4_7_BASE:1.1.1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.1.1.7.0.6
	OPENBSD_4_6_BASE:1.1.1.7
	OPENBSD_4_5:1.1.1.7.0.2
	OPENBSD_4_5_BASE:1.1.1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.2
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.2.0.4
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.2
	OPENBSD_3_3_BASE:1.1.1.2
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.1.1.1.0.12
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	PERL_5_6_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2000.04.06.16.09.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.38;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.03.02.43.59;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.46.45;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.01.15.21.17.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.36;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.49;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.08.52;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@package open;
$open::hint_bits = 0x20000;

sub import {
    shift;
    die "`use open' needs explicit list of disciplines" unless @@_;
    $^H |= $open::hint_bits;
    while (@@_) {
	my $type = shift;
	if ($type =~ /^(IN|OUT)\z/s) {
	    my $discp = shift;
	    unless ($discp =~ /^\s*:(raw|crlf)\s*\z/s) {
		die "Unknown discipline '$discp'";
	    }
	    $^H{"open_$type"} = $discp;
	}
	else {
	    die "Unknown discipline class '$type'";
	}
    }
}

1;
__END__

=head1 NAME

open - perl pragma to set default disciplines for input and output

=head1 SYNOPSIS

    use open IN => ":crlf", OUT => ":raw";

=head1 DESCRIPTION

The open pragma is used to declare one or more default disciplines for
I/O operations.  Any open() and readpipe() (aka qx//) operators found
within the lexical scope of this pragma will use the declared defaults.
Neither open() with an explicit set of disciplines, nor sysopen() are
influenced by this pragma.

Only the two pseudo-disciplines ":raw" and ":crlf" are currently
available.

The ":raw" discipline corresponds to "binary mode" and the ":crlf"
discipline corresponds to "text mode" on platforms that distinguish
between the two modes when opening files (which is many DOS-like
platforms, including Windows).  These two disciplines are currently
no-ops on platforms where binmode() is a no-op, but will be
supported everywhere in future.

=head1 UNIMPLEMENTED FUNCTIONALITY

Full-fledged support for I/O disciplines is currently unimplemented.
When they are eventually supported, this pragma will serve as one of
the interfaces to declare default disciplines for all I/O.

In future, any default disciplines declared by this pragma will be
available by the special discipline name ":DEFAULT", and could be used
within handle constructors that allow disciplines to be specified.
This would make it possible to stack new disciplines over the default
ones.

    open FH, "<:para :DEFAULT", $file or die "can't open $file: $!";

Socket and directory handles will also support disciplines in
future.

Full support for I/O disciplines will enable all of the supported
disciplines to work on all platforms.

=head1 SEE ALSO

L<perlfunc/"binmode">, L<perlfunc/"open">, L<perlunicode>

=cut
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@a1 2
use warnings;
use Carp;
a3 54
our $VERSION = '1.01';

my $locale_encoding;

sub in_locale { $^H & ($locale::hint_bits || 0)}

sub _get_locale_encoding {
    unless (defined $locale_encoding) {
	# I18N::Langinfo isn't available everywhere
	eval {
	    require I18N::Langinfo;
	    I18N::Langinfo->import(qw(langinfo CODESET));
	    $locale_encoding = langinfo(CODESET());
	};
	my $country_language;

	no warnings 'uninitialized';

        if (not $locale_encoding && in_locale()) {
	    if ($ENV{LC_ALL} =~ /^([^.]+)\.([^.]+)$/) {
		($country_language, $locale_encoding) = ($1, $2);
	    } elsif ($ENV{LANG} =~ /^([^.]+)\.([^.]+)$/) {
		($country_language, $locale_encoding) = ($1, $2);
	    }
	} elsif (not $locale_encoding) {
	    if ($ENV{LC_ALL} =~ /\butf-?8\b/i ||
		$ENV{LANG}   =~ /\butf-?8\b/i) {
		$locale_encoding = 'utf8';
	    }
	    # Could do more heuristics based on the country and language
	    # parts of LC_ALL and LANG (the parts before the dot (if any)),
	    # since we have Locale::Country and Locale::Language available.
	    # TODO: get a database of Language -> Encoding mappings
	    # (the Estonian database at http://www.eki.ee/letter/
	    # would be excellent!) --jhi
	}
	if (defined $locale_encoding &&
	    $locale_encoding eq 'euc' &&
	    defined $country_language) {
	    if ($country_language =~ /^ja_JP|japan(?:ese)?$/i) {
		$locale_encoding = 'euc-jp';
	    } elsif ($country_language =~ /^ko_KR|korean?$/i) {
		$locale_encoding = 'euc-kr';
	    } elsif ($country_language =~ /^zh_CN|chin(?:a|ese)?$/i) {
		$locale_encoding = 'euc-cn';
	    } elsif ($country_language =~ /^zh_TW|taiwan(?:ese)?$/i) {
		$locale_encoding = 'euc-tw';
	    }
	    croak "Locale encoding 'euc' too ambiguous"
		if $locale_encoding eq 'euc';
	}
    }
}

d5 2
a6 3
    my ($class,@@args) = @@_;
    croak("`use open' needs explicit list of PerlIO layers") unless @@args;
    my $std;
d8 6
a13 35
    my ($in,$out) = split(/\0/,(${^OPEN} || "\0"), -1);
    while (@@args) {
	my $type = shift(@@args);
	my $dscp;
	if ($type =~ /^:?(utf8|locale|encoding\(.+\))$/) {
	    $type = 'IO';
	    $dscp = ":$1";
	} elsif ($type eq ':std') {
	    $std = 1;
	    next;
	} else {
	    $dscp = shift(@@args) || '';
	}
	my @@val;
	foreach my $layer (split(/\s+/,$dscp)) {
            $layer =~ s/^://;
	    if ($layer eq 'locale') {
		use Encode;
		_get_locale_encoding()
		    unless defined $locale_encoding;
		(warnings::warnif("layer", "Cannot figure out an encoding to use"), last)
		    unless defined $locale_encoding;
		if ($locale_encoding =~ /^utf-?8$/i) {
		    $layer = "utf8";
		} else {
		    $layer = "encoding($locale_encoding)";
		}
		$std = 1;
	    } else {
		my $target = $layer;		# the layer name itself
		$target =~ s/^(\w+)\(.+\)$/$1/;	# strip parameters

		unless(PerlIO::Layer::->find($target)) {
		    warnings::warnif("layer", "Unknown PerlIO layer '$layer'");
		}
d15 1
a15 13
	    push(@@val,":$layer");
	    if ($layer =~ /^(crlf|raw)$/) {
		$^H{"open_$type"} = $layer;
	    }
	}
	if ($type eq 'IN') {
	    $in  = join(' ',@@val);
	}
	elsif ($type eq 'OUT') {
	    $out = join(' ',@@val);
	}
	elsif ($type eq 'IO') {
	    $in = $out = join(' ',@@val);
d18 1
a18 20
	    croak "Unknown PerlIO layer class '$type'";
	}
    }
    ${^OPEN} = join("\0",$in,$out) if $in or $out;
    if ($std) {
	if ($in) {
	    if ($in =~ /:utf8\b/) {
		    binmode(STDIN,  ":utf8");
		} elsif ($in =~ /(\w+\(.+\))/) {
		    binmode(STDIN,  ":$1");
		}
	}
	if ($out) {
	    if ($out =~ /:utf8\b/) {
		binmode(STDOUT,  ":utf8");
		binmode(STDERR,  ":utf8");
	    } elsif ($out =~ /(\w+\(.+\))/) {
		binmode(STDOUT,  ":$1");
		binmode(STDERR,  ":$1");
	    }
d28 1
a28 1
open - perl pragma to set default PerlIO layers for input and output
d32 1
a32 11
    use open IN  => ":crlf", OUT => ":bytes";
    use open OUT => ':utf8';
    use open IO  => ":encoding(iso-8859-7)";

    use open IO  => ':locale';

    use open ':utf8';
    use open ':locale';
    use open ':encoding(iso-8859-7)';

    use open ':std';
d36 5
a40 3
Full-fledged support for I/O layers is now implemented provided
Perl is configured to use PerlIO as its IO system (which is now the
default).
d42 2
a43 4
The C<open> pragma serves as one of the interfaces to declare default
"layers" (also known as "disciplines") for all I/O. Any open(),
readpipe() (aka qx//) and similar operators found within the lexical
scope of this pragma will use the declared defaults.
d45 6
a50 42
With the C<IN> subpragma you can declare the default layers
of input streams, and with the C<OUT> subpragma you can declare
the default layers of output streams.  With the C<IO>  subpragma
you can control both input and output streams simultaneously.

If you have a legacy encoding, you can use the C<:encoding(...)> tag.

if you want to set your encoding layers based on your
locale environment variables, you can use the C<:locale> tag.
For example:

    $ENV{LANG} = 'ru_RU.KOI8-R';
    # the :locale will probe the locale environment variables like LANG
    use open OUT => ':locale';
    open(O, ">koi8");
    print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8-R 0xc1
    close O;
    open(I, "<koi8");
    printf "%#x\n", ord(<I>), "\n"; # this should print 0xc1
    close I;

These are equivalent

    use open ':utf8';
    use open IO => ':utf8';

as are these

    use open ':locale';
    use open IO => ':locale';

and these

    use open ':encoding(iso-8859-7)';
    use open IO => ':encoding(iso-8859-7)';

The matching of encoding names is loose: case does not matter, and
many encodings have several aliases.  See L<Encode::Supported> for
details and the list of supported locales.

Note that C<:utf8> PerlIO layer must always be specified exactly like
that, it is not subject to the loose matching of encoding names.
d52 1
a52 2
When open() is given an explicit list of layers they are appended to
the list declared using this pragma.
d54 3
a56 9
The C<:std> subpragma on its own has no effect, but if combined with
the C<:utf8> or C<:encoding> subpragmas, it converts the standard
filehandles (STDIN, STDOUT, STDERR) to comply with encoding selected
for input/output handles.  For example, if both input and out are
chosen to be C<:utf8>, a C<:std> will mean that STDIN, STDOUT, and
STDERR are also in C<:utf8>.  On the other hand, if only output is
chosen to be in C<< :encoding(koi8r) >>, a C<:std> will cause only the
STDOUT and STDERR to be in C<koi8r>.  The C<:locale> subpragma
implicitly turns on C<:std>.
d58 5
a62 1
The logic of C<:locale> is as follows:
d64 1
a64 1
=over 4
d66 2
a67 1
=item 1.
d69 2
a70 50
If the platform supports the langinfo(CODESET) interface, the codeset
returned is used as the default encoding for the open pragma.

=item 2.

If 1. didn't work but we are under the locale pragma, the environment
variables LC_ALL and LANG (in that order) are matched for encodings
(the part after C<.>, if any), and if any found, that is used 
as the default encoding for the open pragma.

=item 3.

If 1. and 2. didn't work, the environment variables LC_ALL and LANG
(in that order) are matched for anything looking like UTF-8, and if
any found, C<:utf8> is used as the default encoding for the open
pragma.

=back

If your locale environment variables (LANGUAGE, LC_ALL, LC_CTYPE, LANG)
contain the strings 'UTF-8' or 'UTF8' (case-insensitive matching),
the default encoding of your STDIN, STDOUT, and STDERR, and of
B<any subsequent file open>, is UTF-8.

Directory handles may also support PerlIO layers in the future.

=head1 NONPERLIO FUNCTIONALITY

If Perl is not built to use PerlIO as its IO system then only the two
pseudo-layers C<:bytes> and C<:crlf> are available.

The C<:bytes> layer corresponds to "binary mode" and the C<:crlf>
layer corresponds to "text mode" on platforms that distinguish
between the two modes when opening files (which is many DOS-like
platforms, including Windows).  These two layers are no-ops on
platforms where binmode() is a no-op, but perform their functions
everywhere if PerlIO is enabled.

=head1 IMPLEMENTATION DETAILS

There is a class method in C<PerlIO::Layer> C<find> which is
implemented as XS code.  It is called by C<import> to validate the
layers:

   PerlIO::Layer::->find("perlio")

The return value (if defined) is a Perl object, of class
C<PerlIO::Layer> which is created by the C code in F<perlio.c>.  As
yet there is nothing useful you can do with the object at the perl
level.
d74 1
a74 2
L<perlfunc/"binmode">, L<perlfunc/"open">, L<perlunicode>, L<PerlIO>,
L<encoding>
@


1.1.1.3
log
@perl 5.8.2 from CPAN
@
text
@d4 1
a4 1
$open::hint_bits = 0x20000; # HINT_LOCALIZE_HH
d6 1
a6 1
our $VERSION = '1.02';
a29 1
	    # LANGUAGE affects only LC_MESSAGES only on glibc
d82 1
a82 1
		require Encode;
d97 2
a98 2
		unless(PerlIO::Layer::->find($target,1)) {
		    warnings::warnif("layer", "Unknown PerlIO layer '$target'");
d168 3
a170 6
"layers" (also known as "disciplines") for all I/O. Any two-argument
open(), readpipe() (aka qx//) and similar operators found within the
lexical scope of this pragma will use the declared defaults.
Three-argument opens are not affected by this pragma since there you
(can) explicitly specify the layers and are supposed to know what you
are doing.
d253 1
a253 1
If your locale environment variables (LC_ALL, LC_CTYPE, LANG)
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d6 1
a6 1
our $VERSION = '1.03';
d44 1
a44 1
	    lc($locale_encoding) eq 'euc' &&
a53 2
	    } else {
		croak "Locale encoding 'euc' too ambiguous";
d55 2
@


1.1.1.5
log
@perl 5.8.6 from CPAN
@
text
@d6 1
a6 3
our $VERSION = '1.04';

require 5.008001; # for PerlIO::get_layers()
d10 1
a10 4
sub _get_encname {
    return ($1, Encode::resolve_alias($1)) if $_[0] =~ /^:?encoding\((.+)\)$/;
    return;
}
d12 46
a57 35
sub _drop_oldenc {
    # If by the time we arrive here there already is at the top of the
    # perlio layer stack an encoding identical to what we would like
    # to push via this open pragma, we will pop away the old encoding
    # (+utf8) so that we can push ourselves in place (this is easier
    # than ignoring pushing ourselves because of the way how ${^OPEN}
    # works).  So we are looking for something like
    #
    #   stdio encoding(xxx) utf8
    #
    # in the existing layer stack, and in the new stack chunk for
    #
    #   :encoding(xxx)
    #
    # If we find a match, we pop the old stack (once, since
    # the utf8 is just a flag on the encoding layer)
    my ($h, @@new) = @@_;
    return unless @@new >= 1 && $new[-1] =~ /^:encoding\(.+\)$/;
    my @@old = PerlIO::get_layers($h);
    return unless @@old >= 3 &&
	          $old[-1] eq 'utf8' &&
                  $old[-2] =~ /^encoding\(.+\)$/;
    require Encode;
    my ($loname, $lcname) = _get_encname($old[-2]);
    unless (defined $lcname) { # Should we trust get_layers()?
	require Carp;
	Carp::croak("open: Unknown encoding '$loname'");
    }
    my ($voname, $vcname) = _get_encname($new[-1]);
    unless (defined $vcname) {
	require Carp;
	Carp::croak("open: Unknown encoding '$voname'");
    }
    if ($lcname eq $vcname) {
	binmode($h, ":pop"); # utf8 is part of the encoding layer
d63 1
a63 1
    croak("open: needs explicit list of PerlIO layers") unless @@args;
d84 1
a84 2
		require encoding;
		$locale_encoding = encoding::_get_locale_encoding()
d108 1
a108 2
	    _drop_oldenc(*STDIN, @@val);
	    $in  = join(' ', @@val);
d111 1
a111 2
	    _drop_oldenc(*STDOUT, @@val);
	    $out = join(' ', @@val);
d114 1
a114 3
	    _drop_oldenc(*STDIN,  @@val);
	    _drop_oldenc(*STDOUT, @@val);
	    $in = $out = join(' ', @@val);
d120 1
a120 1
    ${^OPEN} = join("\0", $in, $out);
d232 29
a260 3
The logic of C<:locale> is described in full in L</encoding>,
but in short it is first trying nl_langinfo(CODESET) and then
guessing from the LC_ALL and LANG locale environment variables.
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d6 1
a6 1
our $VERSION = '1.05';
d171 3
a173 2
Even three-argument opens may be affected by this pragma
when they don't specify IO layers in MODE.
d182 1
a182 1
If you want to set your encoding layers based on your
d218 2
a219 2
When open() is given an explicit list of layers (with the three-arg
syntax), they override the list declared using this pragma.
d231 1
a231 1
The logic of C<:locale> is described in full in L<encoding>,
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d3 2
d6 1
a6 1
our $VERSION = '1.06';
a16 4
sub croak {
    require Carp; goto &Carp::croak;
}

d42 2
a43 1
	croak("open: Unknown encoding '$loname'");
d47 2
a48 1
	croak("open: Unknown encoding '$voname'");
d59 1
d83 5
a87 1
                $layer = "encoding($locale_encoding)";
d155 1
a155 1
    use open ':encoding(utf8)';
d197 2
a198 2
    use open ':encoding(utf8)';
    use open IO => ':encoding(utf8)';
d214 3
d224 4
a227 4
chosen to be C<:encoding(utf8)>, a C<:std> will mean that STDIN, STDOUT,
and STDERR are also in C<:encoding(utf8)>.  On the other hand, if only
output is chosen to be in C<< :encoding(koi8r) >>, a C<:std> will cause
only the STDOUT and STDERR to be in C<koi8r>.  The C<:locale> subpragma
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d4 1
a4 1
our $VERSION = '1.07';
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 1
a4 1
our $VERSION = '1.10';
d98 1
a98 1
	    _drop_oldenc(*STDIN, @@val) if $std;
d102 1
a102 4
	    if ($std) {
		_drop_oldenc(*STDOUT, @@val);
		_drop_oldenc(*STDERR, @@val);
	    }
d106 2
a107 5
	    if ($std) {
		_drop_oldenc(*STDIN, @@val);
		_drop_oldenc(*STDOUT, @@val);
		_drop_oldenc(*STDERR, @@val);
	    }
d111 1
a111 1
	    croak "Unknown PerlIO layer class '$type' (need IN, OUT or IO)";
d210 1
a210 3
syntax), they override the list declared using this pragma.  open() can
also be given a single colon (:) for a layer name, to override this pragma
and use the default (C<:raw> on Unix, C<:crlf> on Windows).
@


