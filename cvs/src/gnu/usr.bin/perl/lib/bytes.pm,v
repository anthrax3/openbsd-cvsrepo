head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.26
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.20
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.22
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.14
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.7.0.18
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.16
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.12
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.8
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.4
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.10
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.8
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.6
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.4
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.23.20;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.57;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.31;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.37;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package bytes;

our $VERSION = '1.05';

$bytes::hint_bits = 0x00000008;

sub import {
    $^H |= $bytes::hint_bits;
}

sub unimport {
    $^H &= ~$bytes::hint_bits;
}

sub AUTOLOAD {
    require "bytes_heavy.pl";
    goto &$AUTOLOAD if defined &$AUTOLOAD;
    require Carp;
    Carp::croak("Undefined subroutine $AUTOLOAD called");
}

sub length (_);
sub chr (_);
sub ord (_);
sub substr ($$;$$);
sub index ($$;$);
sub rindex ($$;$);

1;
__END__

=head1 NAME

bytes - Perl pragma to expose the individual bytes of characters

=head1 NOTICE

Because the bytes pragma breaks encapsulation (i.e. it exposes the innards of
how the perl executable currently happens to store a string), the byte values
that result are in an unspecified encoding.

B<Use of this module for anything other than debugging purposes is
strongly discouraged.>  If you feel that the functions here within
might be useful for your application, this possibly indicates a
mismatch between your mental model of Perl Unicode and the current
reality. In that case, you may wish to read some of the perl Unicode
documentation: L<perluniintro>, L<perlunitut>, L<perlunifaq> and
L<perlunicode>.

=head1 SYNOPSIS

    use bytes;
    ... chr(...);       # or bytes::chr
    ... index(...);     # or bytes::index
    ... length(...);    # or bytes::length
    ... ord(...);       # or bytes::ord
    ... rindex(...);    # or bytes::rindex
    ... substr(...);    # or bytes::substr
    no bytes;


=head1 DESCRIPTION

Perl's characters are stored internally as sequences of one or more bytes.
This pragma allows for the examination of the individual bytes that together
comprise a character.

Originally the pragma was designed for the loftier goal of helping incorporate
Unicode into Perl, but the approach that used it was found to be defective,
and the one remaining legitimate use is for debugging when you need to
non-destructively examine characters' individual bytes.  Just insert this
pragma temporarily, and remove it after the debugging is finished.

The original usage can be accomplished by explicit (rather than this pragma's
implict) encoding using the L<Encode> module:

    use Encode qw/encode/;

    my $utf8_byte_string   = encode "UTF8",   $string;
    my $latin1_byte_string = encode "Latin1", $string;

Or, if performance is needed and you are only interested in the UTF-8
representation:

    use utf8;

    utf8::encode(my $utf8_byte_string = $string);

C<no bytes> can be used to reverse the effect of C<use bytes> within the
current lexical scope.

As an example, when Perl sees C<$x = chr(400)>, it encodes the character
in UTF-8 and stores it in C<$x>. Then it is marked as character data, so,
for instance, C<length $x> returns C<1>. However, in the scope of the
C<bytes> pragma, C<$x> is treated as a series of bytes - the bytes that make
up the UTF8 encoding - and C<length $x> returns C<2>:

 $x = chr(400);
 print "Length is ", length $x, "\n";     # "Length is 1"
 printf "Contents are %vd\n", $x;         # "Contents are 400"
 {
     use bytes; # or "require bytes; bytes::length()"
     print "Length is ", length $x, "\n"; # "Length is 2"
     printf "Contents are %vd\n", $x;     # "Contents are 198.144 (on
                                          # ASCII platforms)"
 }

C<chr()>, C<ord()>, C<substr()>, C<index()> and C<rindex()> behave similarly.

For more on the implications, see L<perluniintro> and L<perlunicode>.

C<bytes::length()> is admittedly handy if you need to know the
B<byte length> of a Perl scalar.  But a more modern way is:

   use Encode 'encode';
   length(encode('UTF-8', $scalar))

=head1 LIMITATIONS

C<bytes::substr()> does not work as an I<lvalue()>.

=head1 SEE ALSO

L<perluniintro>, L<perlunicode>, L<utf8>, L<Encode>

=cut
@


1.1
log
@Initial revision
@
text
@d3 2
d17 3
a19 1
    goto &$AUTOLOAD;
d22 6
a27 1
sub length ($);
d34 15
a48 1
bytes - Perl pragma to force byte semantics rather than character semantics
d53 6
d61 1
d64 53
a116 2
WARNING: The implementation of Unicode support in Perl is incomplete.
See L<perlunicode> for the exact details.
d118 1
a118 7
The C<use bytes> pragma disables character semantics for the rest of the
lexical scope in which it appears.  C<no bytes> can be used to reverse
the effect of C<use bytes> within the current lexical scope.

Perl normally assumes character semantics in the presence of
character data (i.e. data that has come from a source that has
been marked as being of a particular character encoding).
d120 1
a120 2
To understand the implications and differences between character
semantics and byte semantics, see L<perlunicode>.
d124 1
a124 1
L<perlunicode>, L<utf8>
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d41 3
a43 5
Perl normally assumes character semantics in the presence of character
data (i.e. data that has come from a source that has been marked as
being of a particular character encoding). When C<use bytes> is in
effect, the encoding is temporarily ignored, and each string is treated
as a series of bytes. 
d45 1
a45 16
As an example, when Perl sees C<$x = chr(400)>, it encodes the character
in UTF8 and stores it in $x. Then it is marked as character data, so,
for instance, C<length $x> returns C<1>. However, in the scope of the
C<bytes> pragma, $x is treated as a series of bytes - the bytes that make
up the UTF8 encoding - and C<length $x> returns C<2>:

    $x = chr(400);
    print "Length is ", length $x, "\n";     # "Length is 1"
    printf "Contents are %vd\n", $x;         # "Contents are 400"
    { 
        use bytes;
        print "Length is ", length $x, "\n"; # "Length is 2"
        printf "Contents are %vd\n", $x;     # "Contents are 198.144"
    }

For more on the implications and differences between character
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a2 2
our $VERSION = '1.00';

d34 3
d48 1
a48 1
in UTF-8 and stores it in $x. Then it is marked as character data, so,
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.01';
a20 5
sub chr ($);
sub ord ($);
sub substr ($$;$$);
sub index ($$;$);
sub rindex ($$;$);
a31 6
    ... chr(...);       # or bytes::chr
    ... index(...);     # or bytes::index
    ... length(...);    # or bytes::length
    ... ord(...);       # or bytes::ord
    ... rindex(...);    # or bytes::rindex
    ... substr(...);    # or bytes::substr
a33 1

d56 1
a56 1
        use bytes; # or "require bytes; bytes::length()"
a60 2
chr(), ord(), substr(), index() and rindex() behave similarly.

d62 1
a62 5
semantics and byte semantics, see L<perluniintro> and L<perlunicode>.

=head1 LIMITATIONS

bytes::substr() does not work as an lvalue().
d66 1
a66 1
L<perluniintro>, L<perlunicode>, L<utf8>
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
our $VERSION = '1.02';
d17 1
a17 3
    goto &$AUTOLOAD if defined &$AUTOLOAD;
    require Carp;
    Carp::croak("Undefined subroutine $AUTOLOAD called");
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.03';
d22 3
a24 3
sub length (_);
sub chr (_);
sub ord (_);
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.04';
a34 12

=head1 NOTICE

This pragma reflects early attempts to incorporate Unicode into perl and
has since been superseded. It breaks encapsulation (i.e. it exposes the
innards of how the perl executable currently happens to store a string),
and use of this module for anything other than debugging purposes is
strongly discouraged. If you feel that the functions here within might be
useful for your application, this possibly indicates a mismatch between
your mental model of Perl Unicode and the current reality. In that case,
you may wish to read some of the perl Unicode documentation:
L<perluniintro>, L<perlunitut>, L<perlunifaq> and L<perlunicode>.
@


