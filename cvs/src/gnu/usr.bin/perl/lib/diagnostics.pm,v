head	1.16;
access;
symbols
	PERL_5_24_2:1.1.1.15
	OPENBSD_6_1:1.16.0.12
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.10
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.4
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.15
	OPENBSD_5_7:1.16.0.2
	OPENBSD_5_7_BASE:1.16
	PERL_5_20_1:1.1.1.15
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	PERL_5_18_2:1.1.1.14
	PERL:1.1.1
	OPENBSD_5_5:1.14.0.6
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.2
	OPENBSD_5_4_BASE:1.14
	PERL_5_16_3:1.1.1.13
	OPENBSD_5_3:1.13.0.10
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.8
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.6
	OPENBSD_5_0:1.13.0.4
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	PERL_5_12_2:1.1.1.12
	OPENBSD_4_8:1.12.0.8
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.4
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	QP75iYx42Uo7mMxO;

1.15
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.25.20.40.55;	author sthen;	state Exp;
branches;
next	1.13;

1.13
date	2010.09.24.15.06.59;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.36.09;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.31;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.09.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.24;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.09;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.46;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.56.54;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.32;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.32;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.50;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.20;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.13;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.46.41;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.17.08;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.48.35;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2010.09.24.14.48.37;	author millert;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2013.03.25.20.08.51;	author sthen;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	2014.11.17.20.53.07;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.16
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@package diagnostics;

=head1 NAME

diagnostics, splain - produce verbose warning diagnostics

=head1 SYNOPSIS

Using the C<diagnostics> pragma:

    use diagnostics;
    use diagnostics -verbose;

    enable  diagnostics;
    disable diagnostics;

Using the C<splain> standalone filter program:

    perl program 2>diag.out
    splain [-v] [-p] diag.out

Using diagnostics to get stack traces from a misbehaving script:

    perl -Mdiagnostics=-traceonly my_script.pl

=head1 DESCRIPTION

=head2 The C<diagnostics> Pragma

This module extends the terse diagnostics normally emitted by both the
perl compiler and the perl interpreter (from running perl with a -w 
switch or C<use warnings>), augmenting them with the more
explicative and endearing descriptions found in L<perldiag>.  Like the
other pragmata, it affects the compilation phase of your program rather
than merely the execution phase.

To use in your program as a pragma, merely invoke

    use diagnostics;

at the start (or near the start) of your program.  (Note 
that this I<does> enable perl's B<-w> flag.)  Your whole
compilation will then be subject(ed :-) to the enhanced diagnostics.
These still go out B<STDERR>.

Due to the interaction between runtime and compiletime issues,
and because it's probably not a very good idea anyway,
you may not use C<no diagnostics> to turn them off at compiletime.
However, you may control their behaviour at runtime using the 
disable() and enable() methods to turn them off and on respectively.

The B<-verbose> flag first prints out the L<perldiag> introduction before
any other diagnostics.  The $diagnostics::PRETTY variable can generate nicer
escape sequences for pagers.

Warnings dispatched from perl itself (or more accurately, those that match
descriptions found in L<perldiag>) are only displayed once (no duplicate
descriptions).  User code generated warnings a la warn() are unaffected,
allowing duplicate user messages to be displayed.

This module also adds a stack trace to the error message when perl dies.
This is useful for pinpointing what
caused the death.  The B<-traceonly> (or
just B<-t>) flag turns off the explanations of warning messages leaving just
the stack traces.  So if your script is dieing, run it again with

  perl -Mdiagnostics=-traceonly my_bad_script

to see the call stack at the time of death.  By supplying the B<-warntrace>
(or just B<-w>) flag, any warnings emitted will also come with a stack
trace.

=head2 The I<splain> Program

While apparently a whole nuther program, I<splain> is actually nothing
more than a link to the (executable) F<diagnostics.pm> module, as well as
a link to the F<diagnostics.pod> documentation.  The B<-v> flag is like
the C<use diagnostics -verbose> directive.
The B<-p> flag is like the
$diagnostics::PRETTY variable.  Since you're post-processing with 
I<splain>, there's no sense in being able to enable() or disable() processing.

Output from I<splain> is directed to B<STDOUT>, unlike the pragma.

=head1 EXAMPLES

The following file is certain to trigger a few errors at both
runtime and compiletime:

    use diagnostics;
    print NOWHERE "nothing\n";
    print STDERR "\n\tThis message should be unadorned.\n";
    warn "\tThis is a user warning";
    print "\nDIAGNOSTIC TESTER: Please enter a <CR> here: ";
    my $a, $b = scalar <STDIN>;
    print "\n";
    print $x/$y;

If you prefer to run your program first and look at its problem
afterwards, do this:

    perl -w test.pl 2>test.out
    ./splain < test.out

Note that this is not in general possible in shells of more dubious heritage, 
as the theoretical 

    (perl -w test.pl >/dev/tty) >& test.out
    ./splain < test.out

Because you just moved the existing B<stdout> to somewhere else.

If you don't want to modify your source code, but still have on-the-fly
warnings, do this:

    exec 3>&1; perl -w test.pl 2>&1 1>&3 3>&- | splain 1>&2 3>&- 

Nifty, eh?

If you want to control warnings on the fly, do something like this.
Make sure you do the C<use> first, or you won't be able to get
at the enable() or disable() methods.

    use diagnostics; # checks entire compilation phase 
	print "\ntime for 1st bogus diags: SQUAWKINGS\n";
	print BOGUS1 'nada';
	print "done with 1st bogus\n";

    disable diagnostics; # only turns off runtime warnings
	print "\ntime for 2nd bogus: (squelched)\n";
	print BOGUS2 'nada';
	print "done with 2nd bogus\n";

    enable diagnostics; # turns back on runtime warnings
	print "\ntime for 3rd bogus: SQUAWKINGS\n";
	print BOGUS3 'nada';
	print "done with 3rd bogus\n";

    disable diagnostics;
	print "\ntime for 4th bogus: (squelched)\n";
	print BOGUS4 'nada';
	print "done with 4th bogus\n";

=head1 INTERNALS

Diagnostic messages derive from the F<perldiag.pod> file when available at
runtime.  Otherwise, they may be embedded in the file itself when the
splain package is built.   See the F<Makefile> for details.

If an extant $SIG{__WARN__} handler is discovered, it will continue
to be honored, but only after the diagnostics::splainthis() function 
(the module's $SIG{__WARN__} interceptor) has had its way with your
warnings.

There is a $diagnostics::DEBUG variable you may set if you're desperately
curious what sorts of things are being intercepted.

    BEGIN { $diagnostics::DEBUG = 1 } 


=head1 BUGS

Not being able to say "no diagnostics" is annoying, but may not be
insurmountable.

The C<-pretty> directive is called too late to affect matters.
You have to do this instead, and I<before> you load the module.

    BEGIN { $diagnostics::PRETTY = 1 } 

I could start up faster by delaying compilation until it should be
needed, but this gets a "panic: top_level" when using the pragma form
in Perl 5.001e.

While it's true that this documentation is somewhat subserious, if you use
a program named I<splain>, you should expect a bit of whimsy.

=head1 AUTHOR

Tom Christiansen <F<tchrist@@mox.perl.com>>, 25 June 1995.

=cut

use strict;
use 5.009001;
use Carp;
$Carp::Internal{__PACKAGE__.""}++;

our $VERSION = '1.34';
our $DEBUG;
our $VERBOSE;
our $PRETTY;
our $TRACEONLY = 0;
our $WARNTRACE = 0;

use Config;
use Text::Tabs 'expand';
my $privlib = $Config{privlibexp};
if ($^O eq 'VMS') {
    require VMS::Filespec;
    $privlib = VMS::Filespec::unixify($privlib);
}
my @@trypod = (
	   "$privlib/pod/perldiag.pod",
	   "$privlib/pods/perldiag.pod",
	  );
# handy for development testing of new warnings etc
unshift @@trypod, "./pod/perldiag.pod" if -e "pod/perldiag.pod";
(my $PODFILE) = ((grep { -e } @@trypod), $trypod[$#trypod])[0];

$DEBUG ||= 0;

local $| = 1;
local $_;
local $.;

my $standalone;
my(%HTML_2_Troff, %HTML_2_Latin_1, %HTML_2_ASCII_7);

CONFIG: {
    our $opt_p = our $opt_d = our $opt_v = our $opt_f = '';

    unless (caller) {
	$standalone++;
	require Getopt::Std;
	Getopt::Std::getopts('pdvf:')
	    or die "Usage: $0 [-v] [-p] [-f splainpod]";
	$PODFILE = $opt_f if $opt_f;
	$DEBUG = 2 if $opt_d;
	$VERBOSE = $opt_v;
	$PRETTY = $opt_p;
    }

    if (open(POD_DIAG, $PODFILE)) {
	warn "Happy happy podfile from real $PODFILE\n" if $DEBUG;
	last CONFIG;
    } 

    if (caller) {
	INCPATH: {
	    for my $file ( (map { "$_/".__PACKAGE__.".pm" } @@INC), $0) {
		warn "Checking $file\n" if $DEBUG;
		if (open(POD_DIAG, $file)) {
		    while (<POD_DIAG>) {
			next unless
			    /^__END__\s*# wish diag dbase were more accessible/;
			print STDERR "podfile is $file\n" if $DEBUG;
			last INCPATH;
		    }
		}
	    } 
	}
    } else { 
	print STDERR "podfile is <DATA>\n" if $DEBUG;
	*POD_DIAG = *main::DATA;
    }
}
if (eof(POD_DIAG)) { 
    die "couldn't find diagnostic data in $PODFILE @@INC $0";
}


%HTML_2_Troff = (
    'amp'	=>	'&',	#   ampersand
    'lt'	=>	'<',	#   left chevron, less-than
    'gt'	=>	'>',	#   right chevron, greater-than
    'quot'	=>	'"',	#   double quote

    "Aacute"	=>	"A\\*'",	#   capital A, acute accent
    # etc

);

%HTML_2_Latin_1 = (
    'amp'	=>	'&',	#   ampersand
    'lt'	=>	'<',	#   left chevron, less-than
    'gt'	=>	'>',	#   right chevron, greater-than
    'quot'	=>	'"',	#   double quote

    "Aacute"	=>	"\xC1"	#   capital A, acute accent

    # etc
);

%HTML_2_ASCII_7 = (
    'amp'	=>	'&',	#   ampersand
    'lt'	=>	'<',	#   left chevron, less-than
    'gt'	=>	'>',	#   right chevron, greater-than
    'quot'	=>	'"',	#   double quote

    "Aacute"	=>	"A"	#   capital A, acute accent
    # etc
);

our %HTML_Escapes;
*HTML_Escapes = do {
    if ($standalone) {
	$PRETTY ? \%HTML_2_Latin_1 : \%HTML_2_ASCII_7; 
    } else {
	\%HTML_2_Latin_1; 
    }
}; 

*THITHER = $standalone ? *STDOUT : *STDERR;

my %transfmt = (); 
my $transmo = <<EOFUNC;
sub transmo {
    #local \$^W = 0;  # recursive warnings we do NOT need!
EOFUNC

my %msg;
{
    print STDERR "FINISHING COMPILATION for $_\n" if $DEBUG;
    local $/ = '';
    local $_;
    my $header;
    my @@headers;
    my $for_item;
    my $seen_body;
    while (<POD_DIAG>) {

	sub _split_pod_link {
	    $_[0] =~ m'(?:([^|]*)\|)?([^/]*)(?:/("?)(.*)\3)?'s;
	    ($1,$2,$4);
	}

	unescape();
	if ($PRETTY) {
	    sub noop   { return $_[0] }  # spensive for a noop
	    sub bold   { my $str =$_[0];  $str =~ s/(.)/$1\b$1/g; return $str; } 
	    sub italic { my $str = $_[0]; $str =~ s/(.)/_\b$1/g;  return $str; } 
	    s/C<<< (.*?) >>>|C<< (.*?) >>|[BC]<(.*?)>/bold($+)/ges;
	    s/[IF]<(.*?)>/italic($1)/ges;
	    s/L<(.*?)>/
	       my($text,$page,$sect) = _split_pod_link($1);
	       defined $text
	        ? $text
	        : defined $sect
	           ? italic($sect) . ' in ' . italic($page)
	           : italic($page)
	     /ges;
	     s/S<(.*?)>/
               $1
             /ges;
	} else {
	    s/C<<< (.*?) >>>|C<< (.*?) >>|[BC]<(.*?)>/$+/gs;
	    s/[IF]<(.*?)>/$1/gs;
	    s/L<(.*?)>/
	       my($text,$page,$sect) = _split_pod_link($1);
	       defined $text
	        ? $text
	        : defined $sect
	           ? qq '"$sect" in $page'
	           : $page
	     /ges;
	    s/S<(.*?)>/
               $1
             /ges;
	} 
	unless (/^=/) {
	    if (defined $header) { 
		if ( $header eq 'DESCRIPTION' && 
		    (   /Optional warnings are enabled/ 
		     || /Some of these messages are generic./
		    ) )
		{
		    next;
		}
		$_ = expand $_;
		s/^/    /gm;
		$msg{$header} .= $_;
		for my $h(@@headers) { $msg{$h} .= $_ }
		++$seen_body;
	 	undef $for_item;	
	    }
	    next;
	} 

	# If we have not come across the body of the description yet, then
	# the previous header needs to share the same description.
	if ($seen_body) {
	    @@headers = ();
	}
	else {
	    push @@headers, $header if defined $header;
	}

	unless ( s/=item (.*?)\s*\z//s) {

	    if ( s/=head1\sDESCRIPTION//) {
		$msg{$header = 'DESCRIPTION'} = '';
		undef $for_item;
	    }
	    elsif( s/^=for\s+diagnostics\s*\n(.*?)\s*\z// ) {
		$for_item = $1;
	    }
	    elsif( /^=back/ ) { # Stop processing body here
		undef $header;
		undef $for_item;
		$seen_body = 0;
		next;
	    }
	    next;
	}

	if( $for_item ) { $header = $for_item; undef $for_item } 
	else {
	    $header = $1;

	    $header =~ s/\n/ /gs; # Allow multi-line headers
	}

	# strip formatting directives from =item line
	$header =~ s/[A-Z]<(.*?)>/$1/g;

	# Since we strip "(\.\s*)\n" when we search a warning, strip it here as well
	$header =~ s/(\.\s*)?$//;

        my @@toks = split( /(%l?[dxX]|%[ucp]|%(?:\.\d+)?[fs])/, $header );
	if (@@toks > 1) {
            my $conlen = 0;
            for my $i (0..$#toks){
                if( $i % 2 ){
                    if(      $toks[$i] eq '%c' ){
                        $toks[$i] = '.';
                    } elsif( $toks[$i] =~ /^%(?:d|u)$/ ){
                        $toks[$i] = '\d+';
                    } elsif( $toks[$i] =~ '^%(?:s|.*f)$' ){
                        $toks[$i] = $i == $#toks ? '.*' : '.*?';
                    } elsif( $toks[$i] =~ '%.(\d+)s' ){
                        $toks[$i] = ".{$1}";
                    } elsif( $toks[$i] =~ '^%l*([pxX])$' ){
                        $toks[$i] = $1 eq 'X' ? '[\dA-F]+' : '[\da-f]+';
                    }
                } elsif( length( $toks[$i] ) ){
                    $toks[$i] = quotemeta $toks[$i];
                    $conlen += length( $toks[$i] );
                }
            }  
            my $lhs = join( '', @@toks );
            $lhs =~ s/(\\\s)+/\\s+/g; # Replace lit space with multi-space match
	    $transfmt{$header}{pat} =
              "    s^\\s*$lhs\\s*\Q$header\Es\n\t&& return 1;\n";
            $transfmt{$header}{len} = $conlen;
	} else {
            my $lhs = "\Q$header\E";
            $lhs =~ s/(\\\s)+/\\s+/g; # Replace lit space with multi-space match
            $transfmt{$header}{pat} =
	      "    s^\\s*$lhs\\s*\Q$header\E\n\t && return 1;\n";
            $transfmt{$header}{len} = length( $header );
	} 

	print STDERR __PACKAGE__.": Duplicate entry: \"$header\"\n"
	    if $msg{$header};

	$msg{$header} = '';
	$seen_body = 0;
    } 


    close POD_DIAG unless *main::DATA eq *POD_DIAG;

    die "No diagnostics?" unless %msg;

    # Apply patterns in order of decreasing sum of lengths of fixed parts
    # Seems the best way of hitting the right one.
    for my $hdr ( sort { $transfmt{$b}{len} <=> $transfmt{$a}{len} }
                  keys %transfmt ){
        $transmo .= $transfmt{$hdr}{pat};
    }
    $transmo .= "    return 0;\n}\n";
    print STDERR $transmo if $DEBUG;
    eval $transmo;
    die $@@ if $@@;
}

if ($standalone) {
    if (!@@ARGV and -t STDIN) { print STDERR "$0: Reading from STDIN\n" } 
    while (defined (my $error = <>)) {
	splainthis($error) || print THITHER $error;
    } 
    exit;
} 

my $olddie;
my $oldwarn;

sub import {
    shift;
    $^W = 1; # yup, clobbered the global variable; 
	     # tough, if you want diags, you want diags.
    return if defined $SIG{__WARN__} && ($SIG{__WARN__} eq \&warn_trap);

    for (@@_) {

	/^-d(ebug)?$/ 	   	&& do {
				    $DEBUG++;
				    next;
				   };

	/^-v(erbose)?$/ 	&& do {
				    $VERBOSE++;
				    next;
				   };

	/^-p(retty)?$/ 		&& do {
				    print STDERR "$0: I'm afraid it's too late for prettiness.\n";
				    $PRETTY++;
				    next;
			       };
	# matches trace and traceonly for legacy doc mixup reasons
	/^-t(race(only)?)?$/	&& do {
				    $TRACEONLY++;
				    next;
			       };
	/^-w(arntrace)?$/ 	&& do {
				    $WARNTRACE++;
				    next;
			       };

	warn "Unknown flag: $_";
    } 

    $oldwarn = $SIG{__WARN__};
    $olddie = $SIG{__DIE__};
    $SIG{__WARN__} = \&warn_trap;
    $SIG{__DIE__} = \&death_trap;
} 

sub enable { &import }

sub disable {
    shift;
    return unless $SIG{__WARN__} eq \&warn_trap;
    $SIG{__WARN__} = $oldwarn || '';
    $SIG{__DIE__} = $olddie || '';
} 

sub warn_trap {
    my $warning = $_[0];
    if (caller eq __PACKAGE__ or !splainthis($warning)) {
	if ($WARNTRACE) {
	    print STDERR Carp::longmess($warning);
	} else {
	    print STDERR $warning;
	}
    } 
    goto &$oldwarn if defined $oldwarn and $oldwarn and $oldwarn ne \&warn_trap;
};

sub death_trap {
    my $exception = $_[0];

    # See if we are coming from anywhere within an eval. If so we don't
    # want to explain the exception because it's going to get caught.
    my $in_eval = 0;
    my $i = 0;
    while (my $caller = (caller($i++))[3]) {
      if ($caller eq '(eval)') {
	$in_eval = 1;
	last;
      }
    }

    splainthis($exception) unless $in_eval;
    if (caller eq __PACKAGE__) {
	print STDERR "INTERNAL EXCEPTION: $exception";
    } 
    &$olddie if defined $olddie and $olddie and $olddie ne \&death_trap;

    return if $in_eval;

    # We don't want to unset these if we're coming from an eval because
    # then we've turned off diagnostics.

    # Switch off our die/warn handlers so we don't wind up in our own
    # traps.
    $SIG{__DIE__} = $SIG{__WARN__} = '';

    $exception =~ s/\n(?=.)/\n\t/gas;

    die Carp::longmess("__diagnostics__")
	  =~ s/^__diagnostics__.*?line \d+\.?\n/
		  "Uncaught exception from user code:\n\t$exception"
	      /re;
	# up we go; where we stop, nobody knows, but i think we die now
	# but i'm deeply afraid of the &$olddie guy reraising and us getting
	# into an indirect recursion loop
};

my %exact_duplicate;
my %old_diag;
my $count;
my $wantspace;
sub splainthis {
  return 0 if $TRACEONLY;
  for (my $tmp = shift) {
    local $\;
    local $!;
    ### &finish_compilation unless %msg;
    s/(\.\s*)?\n+$//;
    my $orig = $_;
    # return unless defined;

    # get rid of the where-are-we-in-input part
    s/, <.*?> (?:line|chunk).*$//;

    # Discard 1st " at <file> line <no>" and all text beyond
    # but be aware of messages containing " at this-or-that"
    my $real = 0;
    my @@secs = split( / at / );
    return unless @@secs;
    $_ = $secs[0];
    for my $i ( 1..$#secs ){
        if( $secs[$i] =~ /.+? (?:line|chunk) \d+/ ){
            $real = 1;
            last;
        } else {
            $_ .= ' at ' . $secs[$i];
	}
    }

    # remove parenthesis occurring at the end of some messages 
    s/^\((.*)\)$/$1/;

    if ($exact_duplicate{$orig}++) {
	return &transmo;
    } else {
	return 0 unless &transmo;
    }

    my $short = shorten($orig);
    if ($old_diag{$_}) {
	autodescribe();
	print THITHER "$short (#$old_diag{$_})\n";
	$wantspace = 1;
    } elsif (!$msg{$_} && $orig =~ /\n./s) {
	# A multiline message, like "Attempt to reload /
	# Compilation failed"
	my $found;
	for (split /^/, $orig) {
	    splainthis($_) and $found = 1;
	}
	return $found;
    } else {
	autodescribe();
	$old_diag{$_} = ++$count;
	print THITHER "\n" if $wantspace;
	$wantspace = 0;
	print THITHER "$short (#$old_diag{$_})\n";
	if ($msg{$_}) {
	    print THITHER $msg{$_};
	} else {
	    if (0 and $standalone) { 
		print THITHER "    **** Error #$old_diag{$_} ",
			($real ? "is" : "appears to be"),
			" an unknown diagnostic message.\n\n";
	    }
	    return 0;
	} 
    }
    return 1;
  }
} 

sub autodescribe {
    if ($VERBOSE and not $count) {
	print THITHER &{$PRETTY ? \&bold : \&noop}("DESCRIPTION OF DIAGNOSTICS"),
		"\n$msg{DESCRIPTION}\n";
    } 
} 

sub unescape { 
    s {
            E<  
            ( [A-Za-z]+ )       
            >   
    } { 
         do {   
             exists $HTML_Escapes{$1}
                ? do { $HTML_Escapes{$1} }
                : do {
                    warn "Unknown escape: E<$1> in $_";
                    "E<$1>";
                } 
         } 
    }egx;
}

sub shorten {
    my $line = $_[0];
    if (length($line) > 79 and index($line, "\n") == -1) {
	my $space_place = rindex($line, ' ', 79);
	if ($space_place != -1) {
	    substr($line, $space_place, 1) = "\n\t";
	} 
    } 
    return $line;
} 


1 unless $standalone;  # or it'll complain about itself
__END__ # wish diag dbase were more accessible
@


1.15
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d189 1
a189 1
our $VERSION = '1.31';
d197 1
a211 1
my $WHOAMI = ref bless [];  # nobody's business, prolly not even mine
d241 1
a241 1
	    for my $file ( (map { "$_/$WHOAMI.pm" } @@INC), $0) {
d324 1
a324 1
	    $_[0] =~ '(?:([^|]*)\|)?([^/]*)(?:/("?)(.*)\3)?';
d370 1
d397 7
a403 1
	    } 
d454 1
a454 1
	print STDERR "$WHOAMI: Duplicate entry: \"$header\"\n"
d542 1
a542 1
    if (caller eq $WHOAMI or !splainthis($warning)) {
d567 3
a569 1
    if (caller eq $WHOAMI) { print STDERR "INTERNAL EXCEPTION: $exception"; } 
@


1.14
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d189 1
a189 1
our $VERSION = '1.28';
d388 1
a388 1
	unless ( s/=item (.*?)\s*\z//) {
d403 2
a404 4
	    while( $header =~ /[;,]\z/ ) {
		<POD_DIAG> =~ /^\s*(.*?)\s*\z/;
		$header .= ' '.$1;
	    }
d410 2
a411 2
	# Since we strip "\.\n" when we search a warning, strip it here as well
	$header =~ s/\.?$//;
d413 1
a413 1
        my @@toks = split( /(%l?[dxX]|%u|%c|%(?:\.\d+)?[fs])/, $header );
d426 2
a427 2
                    } elsif( $toks[$i] =~ '^%l*([xX])$' ){
                        $toks[$i] = $1 eq 'x' ? '[\da-f]+' : '[\dA-F]+';
d435 1
d437 1
a437 1
              "    s{^$lhs}\n     {\Q$header\E}s\n\t&& return 1;\n";
d440 2
d443 1
a443 1
	      "    m{^\Q$header\E} && return 1;\n";
d593 1
a593 1
    s/\.?\n+$//;
d614 1
a614 1
    
@


1.13
log
@merge in perl 5.12.2 plus local changes
@
text
@d62 2
a63 1
This is useful for pinpointing what caused the death. The B<-traceonly> (or
d65 1
a65 1
the stack traces. So if your script is dieing, run it again with
d69 1
a69 1
to see the call stack at the time of death. By supplying the B<-warntrace>
d189 1
a189 1
our $VERSION = '1.19';
d197 1
a197 1
my($privlib, $archlib) = @@Config{qw(privlibexp archlibexp)};
a200 1
    $archlib = VMS::Filespec::unixify($archlib);
a202 2
	   "$archlib/pod/perldiag.pod",
	   "$privlib/pod/perldiag-$Config{version}.pod",
a203 2
	   "$archlib/pods/perldiag.pod",
	   "$privlib/pods/perldiag-$Config{version}.pod",
a209 6
if ($^O eq 'MacOS') {
    # just updir one from each lib dir, we'll find it ...
    ($PODFILE) = grep { -e } map { "$_:pod:perldiag.pod" } @@INC;
}


d214 1
a214 1
my $_;
a309 1
    study;
d316 1
d318 1
d320 1
d323 5
d334 12
a345 1
	    s/[LIF]<(.*?)>/italic($1)/ges;
d348 12
a359 1
	    s/[LIF]<(.*?)>/$1/gs;
d372 2
d378 10
d412 4
a415 1
        my @@toks = split( /(%l?[dx]|%c|%(?:\.\d+)?[fs])/, $header );
d422 1
a422 1
                    } elsif( $toks[$i] eq '%d' ){
d428 3
a430 3
                     } elsif( $toks[$i] =~ '^%l*x$' ){
                        $toks[$i] = '[\da-f]+';
                   }
d450 1
d571 1
a571 2
    # Have carp skip over death_trap() when showing the stack trace.
    local($Carp::CarpLevel) = 1;
d573 4
a576 1
    confess "Uncaught exception from user code:\n\t$exception";
d587 2
a588 2
    return 0 if $TRACEONLY;
    $_ = shift;
d600 1
a600 1
    # but be aware of messsages containing " at this-or-that"
d623 1
a623 1
    $orig = shorten($orig);
d626 1
a626 1
	print THITHER "$orig (#$old_diag{$_})\n";
d628 8
d641 1
a641 1
	print THITHER "$orig (#$old_diag{$_})\n";
d654 1
@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d188 1
a188 1
our $VERSION = 1.17;
d225 1
d381 1
a381 1
        my @@toks = split( /(%l?[dx]|%c|%(?:\.\d+)?s)/, $header );
d390 1
a390 1
                    } elsif( $toks[$i] eq '%s' ){
@


1.11
log
@merge in perl 5.8.8
@
text
@d184 1
a184 1
use 5.006;
d188 1
a188 1
our $VERSION = 1.15;
d224 1
a224 1
local $_;
a325 1
    local $_;
d397 1
a397 1
                    $toks[$i] =~ s/^.*$/\Q$&\E/;
d468 2
a469 2

	/^-t(race)?$/ 		&& do {
d473 1
a473 1
	/^-w(arntrace)?$/ 		&& do {
d550 1
a550 1
    local $_ = shift;
d552 1
d565 1
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d63 1
a63 1
just B<-t>) flag turns off the explantions of warning messages leaving just
d188 1
a188 1
our $VERSION = 1.14;
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d22 4
d31 2
a32 1
perl compiler and the perl interpreter, augmenting them with the more
d61 11
d186 1
d188 1
a188 1
our $VERSION = 1.13;
d192 2
d470 9
d500 5
a504 1
	print STDERR $warning;
d506 1
a506 1
    &$oldwarn if defined $oldwarn and $oldwarn and $oldwarn ne \&warn_trap;
d516 1
a516 2
    while (1) {
      my $caller = (caller($i++))[3] or last;
d550 1
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d171 1
a171 1
our $VERSION = 1.12;
d317 1
a317 1
	    s/[BC]<(.*?)>/bold($1)/ges;
d320 1
a320 1
	    s/[BC]<(.*?)>/$1/gs;
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d5 1
a5 3
diagnostics - Perl compiler pragma to force verbose warning diagnostics

splain - filter to produce verbose descriptions of perl warning diagnostics
d9 1
a9 1
As a pragma:
d17 1
a17 1
As a program:
a21 1

d171 1
a171 1
our $VERSION = 1.11;
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d7 1
a7 1
splain - standalone program to do the same thing
d19 1
a19 1
Aa a program:
d56 1
a56 1
descriptions).  User code generated warnings ala warn() are unaffected,
d174 1
a174 1
our $VERSION = 1.1;
d299 1
d334 1
a334 1
		} 
d362 1
a362 1
	# strip formatting directives in =item line
d365 25
a389 14
	if ($header =~ /%[csd]/) {
	    my $rhs = my $lhs = $header;
	    if ($lhs =~ s/(.*?)%d(?!%d)(.*)/\Q$1\E-?\\d+\Q$2\E/g)  {
		$lhs =~ s/\\%s/.*?/g;
	    } else {
		# if i had lookbehind negations,
		# i wouldn't have to do this \377 noise
		$lhs =~ s/(.*?)%s/\Q$1\E.*?\377/g;
		$lhs =~ s/\377([^\377]*)$/\Q$1\E/;
		$lhs =~ s/\377//g;
		$lhs =~ s/\.\*\?$/.*/; # Allow %s at the end to eat it all
	    } 
	    $lhs =~ s/\\%c/./g;
	    $transmo .= "    s{^$lhs}\n     {\Q$rhs\E}s\n\t&& return 1;\n";
d391 3
a393 1
	    $transmo .= "    m{^\Q$header\E} && return 1;\n";
d407 6
d528 2
d531 16
a546 1
    my $real = s/(.*?) at .*? (?:line|chunk) \d+.*/$1/;
d548 1
d551 1
a551 2
    }
    else {
d554 1
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d171 1
a171 1
use 5.005_64;
d174 1
a174 1
our $VERSION = v1.0;
d198 6
d352 9
a361 2
	$header = $for_item || $1;
	undef $for_item;	
d414 1
a414 1
    return if $SIG{__WARN__} eq \&warn_trap;
d479 2
d482 7
a488 3
    # then we've turned off diagnostics. (Actually what does this next
    # line do?  -PSeibel)
    $SIG{__DIE__} = $SIG{__WARN__} = '' unless $in_eval;
d490 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d47 1
a47 1
However, you may control there behaviour at runtime using the 
d170 1
d174 4
a177 1
$VERSION = v1.0;
d180 1
a180 1
($privlib, $archlib) = @@Config{qw(privlibexp archlibexp)};
d186 1
a186 1
@@trypod = (
d196 1
a196 1
($PODFILE) = ((grep { -e } @@trypod), $trypod[$#trypod])[0];
d201 2
a202 1
$| = 1;
d204 2
a205 1
local $_;
d208 1
a208 3
    $opt_p = $opt_d = $opt_v = $opt_f = '';
    %HTML_2_Troff = %HTML_2_Latin_1 = %HTML_2_ASCII_7 = ();  
    %exact_duplicate = ();
d210 1
a210 1
    unless (caller) { 
d219 1
a219 1
    } 
d228 1
a228 1
	    for $file ( (map { "$_/$WHOAMI.pm" } @@INC), $0) {
d232 2
a233 1
			next unless /^__END__\s*# wish diag dbase were more accessible/;
d282 1
d293 1
a293 1
$transmo = <<EOFUNC;
d299 2
a300 1
### sub finish_compilation {  # 5.001e panic: top_level for embedded version
d302 1
a302 2
    ### local 
    $RS = '';
d304 2
a306 2
	#s/(.*)\n//;
	#$header = $1;
d330 1
d334 1
a334 1
	unless ( s/=item (.*)\s*\Z//) {
d338 1
d340 3
d347 3
a349 1
	($header = $1) =~ s/[A-Z]<(.*?)>/$1/g;
d352 2
a353 3
	    $rhs = $lhs = $header;
	    #if ($lhs =~ s/(.*?)%d(?!%d)(.*)/\Q$1\E\\d+\Q$2\E\$/g)  {
	    if ($lhs =~ s/(.*?)%d(?!%d)(.*)/\Q$1\E\\d+\Q$2\E/g)  {
d356 2
a357 1
		# if i had lookbehind negations, i wouldn't have to do this \377 noise
a358 1
		#$lhs =~ s/\377([^\377]*)$/\Q$1\E\$/;
d384 1
a384 2
    $RS = "\n";
### }
d388 1
a388 1
    while (defined ($error = <>)) {
d392 4
a395 4
} else { 
    #$old_w = 0;
    $oldwarn = ''; $olddie = '';
}
d399 2
a400 3
    #$old_w = $^W;
    $^W = 1; # yup, clobbered the global variable; tough, if you
	     # want diags, you want diags.
a433 1
    #$^W = $old_w;
d435 2
a436 2
    $SIG{__WARN__} = $oldwarn;
    $SIG{__DIE__} = $olddie;
d477 4
d489 1
a489 1
    $real = s/(.*?) at .*? (?:line|chunk) \d+.*/$1/;
a556 3

# have to do this: RS isn't set until run time, but we're executing at compiletime
$RS = "\n";
@


1.3
log
@perl5.005_03 (stock)
@
text
@d54 5
d170 1
a170 1
require 5.001;
d173 2
d182 8
a189 3
@@trypod = ("$archlib/pod/perldiag.pod",
	   "$privlib/pod/perldiag-$].pod",
	   "$privlib/pod/perldiag.pod");
d289 1
a289 1
    local \$^W = 0;  # recursive warnings we do NOT need!
d338 1
a338 1
	if ($header =~ /%[sd]/) {
d351 1
d382 2
a383 1
    $old_w = 0; $oldwarn = ''; $olddie = '';
d388 1
a388 1
    $old_w = $^W;
d424 1
a424 1
    $^W = $old_w;
a474 3
    if ($exact_duplicate{$_}++) {
	return 1;
    } 
d478 6
a483 1
    return 0 unless &transmo;
d545 1
a545 1
# have to do this: RS isn't set until run time, but we're executing at compile time
@


1.2
log
@perl 5.004_04
@
text
@d30 1
a30 1
perl compiler and the perl interpeter, augmenting them with the more
@


1.1
log
@Initial revision
@
text
@a0 11
#!/usr/local/bin/perl
eval 'exec perl -S $0  ${1+"$@@"}'
    if 0;

use Config;
if ($^O eq 'VMS') {
   $diagnostics::PODFILE = VMS::Filespec::unixify($Config{'privlib'}) .
                           '/pod/perldiag.pod';
}
else { $diagnostics::PODFILE= $Config{privlib} . "/pod/perldiag.pod"; }

a1 3
require 5.001;
use English;
use Carp;
d30 1
a30 1
perl compiler and the perl interpeter, augmenting them wtih the more
d32 1
a32 1
other pragmata, it affects to compilation phase of your program rather
d51 2
a52 2
any other diagnostics.  The $diagnostics::PRETTY can generate nicer escape
sequences for pgers.
d87 1
a87 1
as the theorectical 
d132 1
a132 1
to be honored, but only after the diagnostic::splainthis() function 
d148 1
a148 1
You have to to this instead, and I<before> you load the module.
d153 2
a154 2
needed, but this gets a "panic: top_level"
when using the pragma form in 5.001e.  
d161 1
a161 1
Tom Christiansen F<E<lt>tchrist@@mox.perl.comE<gt>>, 25 June 1995.
d165 17
d185 1
a185 1
$OUTPUT_AUTOFLUSH = 1;
d197 2
a198 1
	Getopt::Std::getopts('pdvf:') || die "Usage: $0 [-v] [-p] [-f splainpod]";
d322 3
a324 1
	$header = $1;
d337 1
d339 1
a339 1
	    $transmo .= "    s{^$lhs}\n     {\Q$rhs\E}\n\t&& return 1;\n";
d344 2
a345 1
	print STDERR "Already saw $header" if $msg{$header};
d364 1
a364 1
    while ($error = <>) {
d426 14
a439 1
    splainthis($exception);
d442 5
a446 1
    $SIG{__DIE__} = $SIG{__WARN__} = '';
d456 1
d510 1
a510 1
                    warn "Unknown escape: $& in $_";
d519 1
a519 1
    if (length $line > 79) {
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d1 11
d13 3
d44 1
a44 1
perl compiler and the perl interpreter, augmenting them with the more
d46 1
a46 1
other pragmata, it affects the compilation phase of your program rather
d65 2
a66 2
any other diagnostics.  The $diagnostics::PRETTY variable can generate nicer
escape sequences for pagers.
d101 1
a101 1
as the theoretical 
d146 1
a146 1
to be honored, but only after the diagnostics::splainthis() function 
d162 1
a162 1
You have to do this instead, and I<before> you load the module.
d167 2
a168 2
needed, but this gets a "panic: top_level" when using the pragma form
in Perl 5.001e.
d175 1
a175 1
Tom Christiansen <F<tchrist@@mox.perl.com>>, 25 June 1995.
a178 17
require 5.001;
use Carp;

use Config;
($privlib, $archlib) = @@Config{qw(privlibexp archlibexp)};
if ($^O eq 'VMS') {
    require VMS::Filespec;
    $privlib = VMS::Filespec::unixify($privlib);
    $archlib = VMS::Filespec::unixify($archlib);
}
@@trypod = ("$archlib/pod/perldiag.pod",
	   "$privlib/pod/perldiag-$].pod",
	   "$privlib/pod/perldiag.pod");
# handy for development testing of new warnings etc
unshift @@trypod, "./pod/perldiag.pod" if -e "pod/perldiag.pod";
($PODFILE) = ((grep { -e } @@trypod), $trypod[$#trypod])[0];

d182 1
a182 1
$| = 1;
d194 1
a194 2
	Getopt::Std::getopts('pdvf:')
	    or die "Usage: $0 [-v] [-p] [-f splainpod]";
d318 1
a318 3

	# strip formatting directives in =item line
	($header = $1) =~ s/[A-Z]<(.*?)>/$1/g;
a330 1
		$lhs =~ s/\.\*\?$/.*/; # Allow %s at the end to eat it all
d332 1
a332 1
	    $transmo .= "    s{^$lhs}\n     {\Q$rhs\E}s\n\t&& return 1;\n";
d337 1
a337 2
	print STDERR "$WHOAMI: Duplicate entry: \"$header\"\n"
	    if $msg{$header};
d356 1
a356 1
    while (defined ($error = <>)) {
d418 1
a418 14

    # See if we are coming from anywhere within an eval. If so we don't
    # want to explain the exception because it's going to get caught.
    my $in_eval = 0;
    my $i = 0;
    while (1) {
      my $caller = (caller($i++))[3] or last;
      if ($caller eq '(eval)') {
	$in_eval = 1;
	last;
      }
    }

    splainthis($exception) unless $in_eval;
d421 1
a421 5

    # We don't want to unset these if we're coming from an eval because
    # then we've turned off diagnostics. (Actually what does this next
    # line do?  -PSeibel)
    $SIG{__DIE__} = $SIG{__WARN__} = '' unless $in_eval;
a430 1
    local $\;
d484 1
a484 1
                    warn "Unknown escape: E<$1> in $_";
d493 1
a493 1
    if (length($line) > 79 and index($line, "\n") == -1) {
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a53 5
Warnings dispatched from perl itself (or more accurately, those that match
descriptions found in L<perldiag>) are only displayed once (no duplicate
descriptions).  User code generated warnings ala warn() are unaffected,
allowing duplicate user messages to be displayed.

d165 1
a165 1
use 5.005_64;
a167 2
$VERSION = v1.0;

d175 3
a177 8
@@trypod = (
	   "$archlib/pod/perldiag.pod",
	   "$privlib/pod/perldiag-$Config{version}.pod",
	   "$privlib/pod/perldiag.pod",
	   "$archlib/pods/perldiag.pod",
	   "$privlib/pods/perldiag-$Config{version}.pod",
	   "$privlib/pods/perldiag.pod",
	  );
d277 1
a277 1
    #local \$^W = 0;  # recursive warnings we do NOT need!
d326 1
a326 1
	if ($header =~ /%[csd]/) {
a338 1
	    $lhs =~ s/\\%c/./g;
d369 1
a369 2
    #$old_w = 0;
    $oldwarn = ''; $olddie = '';
d374 1
a374 1
    #$old_w = $^W;
d410 1
a410 1
    #$^W = $old_w;
d461 3
d467 1
a467 6
    if ($exact_duplicate{$orig}++) {
	return &transmo;
    }
    else {
	return 0 unless &transmo;
    }
d529 1
a529 1
# have to do this: RS isn't set until run time, but we're executing at compiletime
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d47 1
a47 1
However, you may control their behaviour at runtime using the 
a169 1
use strict;
d173 1
a173 4
our $VERSION = v1.0;
our $DEBUG;
our $VERBOSE;
our $PRETTY;
d176 1
a176 1
my($privlib, $archlib) = @@Config{qw(privlibexp archlibexp)};
d182 1
a182 1
my @@trypod = (
d192 1
a192 1
(my $PODFILE) = ((grep { -e } @@trypod), $trypod[$#trypod])[0];
d197 2
a198 1
local $| = 1;
a200 3
my $standalone;
my(%HTML_2_Troff, %HTML_2_Latin_1, %HTML_2_ASCII_7);

d202 3
a204 1
    our $opt_p = our $opt_d = our $opt_v = our $opt_f = '';
d206 1
a206 1
    unless (caller) {
d215 1
a215 1
    }
d224 1
a224 1
	    for my $file ( (map { "$_/$WHOAMI.pm" } @@INC), $0) {
d228 1
a228 2
			next unless
			    /^__END__\s*# wish diag dbase were more accessible/;
a276 1
our %HTML_Escapes;
d287 1
a287 1
my $transmo = <<EOFUNC;
d293 1
a293 2
my %msg;
{
d295 2
a296 1
    local $/ = '';
a297 2
    my $header;
    my $for_item;
d299 2
a323 1
	 	undef $for_item;	
d327 1
a327 1
	unless ( s/=item (.*?)\s*\z//) {
a330 1
		undef $for_item;
a331 3
	    elsif( s/^=for\s+diagnostics\s*\n(.*?)\s*\z// ) {
		$for_item = $1;
	    } 
d336 1
a336 3
	$header = $for_item || $1;
	undef $for_item;	
	$header =~ s/[A-Z]<(.*?)>/$1/g;
d339 3
a341 2
	    my $rhs = my $lhs = $header;
	    if ($lhs =~ s/(.*?)%d(?!%d)(.*)/\Q$1\E-?\\d+\Q$2\E/g)  {
d344 1
a344 2
		# if i had lookbehind negations,
		# i wouldn't have to do this \377 noise
d346 1
d372 2
a373 1
}
d377 1
a377 1
    while (defined (my $error = <>)) {
d381 4
a384 4
} 

my $olddie;
my $oldwarn;
d388 3
a390 2
    $^W = 1; # yup, clobbered the global variable; 
	     # tough, if you want diags, you want diags.
d424 1
d426 2
a427 2
    $SIG{__WARN__} = $oldwarn || '';
    $SIG{__DIE__} = $olddie || '';
a467 4
my %exact_duplicate;
my %old_diag;
my $count;
my $wantspace;
d476 1
a476 1
    my $real = s/(.*?) at .*? (?:line|chunk) \d+.*/$1/;
d544 3
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d171 1
a171 1
use 5.006;
d174 1
a174 1
our $VERSION = 1.1;
a197 6
if ($^O eq 'MacOS') {
    # just updir one from each lib dir, we'll find it ...
    ($PODFILE) = grep { -e } map { "$_:pod:perldiag.pod" } @@INC;
}


a345 9
	if( $for_item ) { $header = $for_item; undef $for_item } 
	else {
	    $header = $1;
	    while( $header =~ /[;,]\z/ ) {
		<POD_DIAG> =~ /^\s*(.*?)\s*\z/;
		$header .= ' '.$1;
	    }
	}

d347 2
d401 1
a401 1
    return if defined $SIG{__WARN__} && ($SIG{__WARN__} eq \&warn_trap);
a465 2
    return if $in_eval;

d467 3
a469 7
    # then we've turned off diagnostics.

    # Switch off our die/warn handlers so we don't wind up in our own
    # traps.
    $SIG{__DIE__} = $SIG{__WARN__} = '';

    # Have carp skip over death_trap() when showing the stack trace.
a470 1

@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d7 1
a7 1
splain - filter to produce verbose descriptions of perl warning diagnostics
d19 1
a19 1
As a program:
d56 1
a56 1
descriptions).  User code generated warnings a la warn() are unaffected,
d174 1
a174 1
our $VERSION = 1.11;
a298 1
my %transfmt = (); 
d333 1
a333 1
		}
d361 1
a361 1
	# strip formatting directives from =item line
d364 14
a377 25
        my @@toks = split( /(%l?[dx]|%c|%(?:\.\d+)?s)/, $header );
	if (@@toks > 1) {
            my $conlen = 0;
            for my $i (0..$#toks){
                if( $i % 2 ){
                    if(      $toks[$i] eq '%c' ){
                        $toks[$i] = '.';
                    } elsif( $toks[$i] eq '%d' ){
                        $toks[$i] = '\d+';
                    } elsif( $toks[$i] eq '%s' ){
                        $toks[$i] = $i == $#toks ? '.*' : '.*?';
                    } elsif( $toks[$i] =~ '%.(\d+)s' ){
                        $toks[$i] = ".{$1}";
                     } elsif( $toks[$i] =~ '^%l*x$' ){
                        $toks[$i] = '[\da-f]+';
                   }
                } elsif( length( $toks[$i] ) ){
                    $toks[$i] =~ s/^.*$/\Q$&\E/;
                    $conlen += length( $toks[$i] );
                }
            }  
            my $lhs = join( '', @@toks );
	    $transfmt{$header}{pat} =
              "    s{^$lhs}\n     {\Q$header\E}s\n\t&& return 1;\n";
            $transfmt{$header}{len} = $conlen;
d379 1
a379 3
            $transfmt{$header}{pat} =
	      "    m{^\Q$header\E} && return 1;\n";
            $transfmt{$header}{len} = length( $header );
a392 6
    # Apply patterns in order of decreasing sum of lengths of fixed parts
    # Seems the best way of hitting the right one.
    for my $hdr ( sort { $transfmt{$b}{len} <=> $transfmt{$a}{len} }
                  keys %transfmt ){
        $transmo .= $transfmt{$hdr}{pat};
    }
a507 2

    # get rid of the where-are-we-in-input part
d509 1
a509 16

    # Discard 1st " at <file> line <no>" and all text beyond
    # but be aware of messsages containing " at this-or-that"
    my $real = 0;
    my @@secs = split( / at / );
    $_ = $secs[0];
    for my $i ( 1..$#secs ){
        if( $secs[$i] =~ /.+? (?:line|chunk) \d+/ ){
            $real = 1;
            last;
        } else {
            $_ .= ' at ' . $secs[$i];
	}
    }
    
    # remove parenthesis occurring at the end of some messages 
a510 1

d513 2
a514 1
    } else {
a516 1

@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d5 3
a7 1
diagnostics, splain - produce verbose warning diagnostics
d11 1
a11 1
Using the C<diagnostics> pragma:
d19 1
a19 1
Using the C<splain> standalone filter program:
d24 1
d174 1
a174 1
our $VERSION = 1.12;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d171 1
a171 1
our $VERSION = 1.13;
d317 1
a317 1
	    s/C<<< (.*?) >>>|C<< (.*?) >>|[BC]<(.*?)>/bold($+)/ges;
d320 1
a320 1
	    s/C<<< (.*?) >>>|C<< (.*?) >>|[BC]<(.*?)>/$+/gs;
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@a21 4
Using diagnostics to get stack traces from a misbehaving script:

    perl -Mdiagnostics=-traceonly my_script.pl

d27 1
a27 2
perl compiler and the perl interpreter (from running perl with a -w 
switch or C<use warnings>), augmenting them with the more
a55 11
This module also adds a stack trace to the error message when perl dies.
This is useful for pinpointing what caused the death. The B<-traceonly> (or
just B<-t>) flag turns off the explantions of warning messages leaving just
the stack traces. So if your script is dieing, run it again with

  perl -Mdiagnostics=-traceonly my_bad_script

to see the call stack at the time of death. By supplying the B<-warntrace>
(or just B<-w>) flag, any warnings emitted will also come with a stack
trace.

a169 1
$Carp::Internal{__PACKAGE__.""}++;
d171 1
a171 1
our $VERSION = 1.14;
a174 2
our $TRACEONLY = 0;
our $WARNTRACE = 0;
a450 9
	/^-t(race)?$/ 		&& do {
				    $TRACEONLY++;
				    next;
			       };
	/^-w(arntrace)?$/ 		&& do {
				    $WARNTRACE++;
				    next;
			       };

d472 1
a472 5
	if ($WARNTRACE) {
	    print STDERR Carp::longmess($warning);
	} else {
	    print STDERR $warning;
	}
d474 1
a474 1
    goto &$oldwarn if defined $oldwarn and $oldwarn and $oldwarn ne \&warn_trap;
d484 2
a485 1
    while (my $caller = (caller($i++))[3]) {
a518 1
    return 0 if $TRACEONLY;
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d63 1
a63 1
just B<-t>) flag turns off the explanations of warning messages leaving just
d188 1
a188 1
our $VERSION = 1.15;
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d184 1
a184 1
use 5.009001;
d188 1
a188 1
our $VERSION = 1.17;
d224 1
a224 1
my $_;
d326 1
d398 1
a398 1
                    $toks[$i] = quotemeta $toks[$i];
d469 2
a470 2
	# matches trace and traceonly for legacy doc mixup reasons
	/^-t(race(only)?)?$/	&& do {
d474 1
a474 1
	/^-w(arntrace)?$/ 	&& do {
d551 1
a551 1
    $_ = shift;
a552 1
    local $!;
a564 1
    return unless @@secs;
@


1.1.1.12
log
@Perl 5.12.2 from CPAN
@
text
@d188 1
a188 1
our $VERSION = '1.19';
a224 1
local $.;
d380 1
a380 1
        my @@toks = split( /(%l?[dx]|%c|%(?:\.\d+)?[fs])/, $header );
d389 1
a389 1
                    } elsif( $toks[$i] =~ '^%(?:s|.*f)$' ){
@


1.1.1.13
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d62 1
a62 2
This is useful for pinpointing what
caused the death.  The B<-traceonly> (or
d64 1
a64 1
the stack traces.  So if your script is dieing, run it again with
d68 1
a68 1
to see the call stack at the time of death.  By supplying the B<-warntrace>
d188 1
a188 1
our $VERSION = '1.28';
d196 1
a196 1
my $privlib = $Config{privlibexp};
d200 1
d203 2
d206 2
d214 6
d224 1
a224 1
local $_;
d320 1
a326 1
    local $_;
a327 1
    my @@headers;
a328 1
    my $seen_body;
a330 5
	sub _split_pod_link {
	    $_[0] =~ '(?:([^|]*)\|)?([^/]*)(?:/("?)(.*)\3)?';
	    ($1,$2,$4);
	}

d337 1
a337 12
	    s/[IF]<(.*?)>/italic($1)/ges;
	    s/L<(.*?)>/
	       my($text,$page,$sect) = _split_pod_link($1);
	       defined $text
	        ? $text
	        : defined $sect
	           ? italic($sect) . ' in ' . italic($page)
	           : italic($page)
	     /ges;
	     s/S<(.*?)>/
               $1
             /ges;
d340 1
a340 12
	    s/[IF]<(.*?)>/$1/gs;
	    s/L<(.*?)>/
	       my($text,$page,$sect) = _split_pod_link($1);
	       defined $text
	        ? $text
	        : defined $sect
	           ? qq '"$sect" in $page'
	           : $page
	     /ges;
	    s/S<(.*?)>/
               $1
             /ges;
a352 2
		for my $h(@@headers) { $msg{$h} .= $_ }
		++$seen_body;
a356 10

	# If we have not come across the body of the description yet, then
	# the previous header needs to share the same description.
	if ($seen_body) {
	    @@headers = ();
	}
	else {
	    push @@headers, $header if defined $header;
	}

d381 1
a381 4
	# Since we strip "\.\n" when we search a warning, strip it here as well
	$header =~ s/\.?$//;

        my @@toks = split( /(%l?[dxX]|%u|%c|%(?:\.\d+)?[fs])/, $header );
d388 1
a388 1
                    } elsif( $toks[$i] =~ /^%(?:d|u)$/ ){
d394 3
a396 3
                    } elsif( $toks[$i] =~ '^%l*([xX])$' ){
                        $toks[$i] = $1 eq 'x' ? '[\da-f]+' : '[\dA-F]+';
                    }
a415 1
	$seen_body = 0;
d536 2
a537 1
    $exception =~ s/\n(?=.)/\n\t/gas;
d539 1
a539 4
    die Carp::longmess("__diagnostics__")
	  =~ s/^__diagnostics__.*?line \d+\.?\n/
		  "Uncaught exception from user code:\n\t$exception"
	      /re;
d550 2
a551 2
  return 0 if $TRACEONLY;
  for (my $tmp = shift) {
d563 1
a563 1
    # but be aware of messages containing " at this-or-that"
d586 1
a586 1
    my $short = shorten($orig);
d589 1
a589 1
	print THITHER "$short (#$old_diag{$_})\n";
a590 8
    } elsif (!$msg{$_} && $orig =~ /\n./s) {
	# A multiline message, like "Attempt to reload /
	# Compilation failed"
	my $found;
	for (split /^/, $orig) {
	    splainthis($_) and $found = 1;
	}
	return $found;
d596 1
a596 1
	print THITHER "$short (#$old_diag{$_})\n";
a608 1
  }
@


1.1.1.14
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d189 1
a189 1
our $VERSION = '1.31';
d388 1
a388 1
	unless ( s/=item (.*?)\s*\z//s) {
d403 4
a406 2

	    $header =~ s/\n/ /gs; # Allow multi-line headers
d412 2
a413 2
	# Since we strip "(\.\s*)\n" when we search a warning, strip it here as well
	$header =~ s/(\.\s*)?$//;
d415 1
a415 1
        my @@toks = split( /(%l?[dxX]|%[ucp]|%(?:\.\d+)?[fs])/, $header );
d428 2
a429 2
                    } elsif( $toks[$i] =~ '^%l*([pxX])$' ){
                        $toks[$i] = $1 eq 'X' ? '[\dA-F]+' : '[\da-f]+';
a436 1
            $lhs =~ s/(\\\s)+/\\s+/g; # Replace lit space with multi-space match
d438 1
a438 1
              "    s^\\s*$lhs\\s*\Q$header\Es\n\t&& return 1;\n";
a440 2
            my $lhs = "\Q$header\E";
            $lhs =~ s/(\\\s)+/\\s+/g; # Replace lit space with multi-space match
d442 1
a442 1
	      "    s^\\s*$lhs\\s*\Q$header\E\n\t && return 1;\n";
d592 1
a592 1
    s/(\.\s*)?\n+$//;
d613 1
a613 1

@


1.1.1.15
log
@Import perl-5.20.1
@
text
@d189 1
a189 1
our $VERSION = '1.34';
a196 1
use Text::Tabs 'expand';
d211 1
d241 1
a241 1
	    for my $file ( (map { "$_/".__PACKAGE__.".pm" } @@INC), $0) {
d324 1
a324 1
	    $_[0] =~ m'(?:([^|]*)\|)?([^/]*)(?:/("?)(.*)\3)?'s;
a369 1
		$_ = expand $_;
d396 1
a396 7
	    }
	    elsif( /^=back/ ) { # Stop processing body here
		undef $header;
		undef $for_item;
		$seen_body = 0;
		next;
	    }
d447 1
a447 1
	print STDERR __PACKAGE__.": Duplicate entry: \"$header\"\n"
d535 1
a535 1
    if (caller eq __PACKAGE__ or !splainthis($warning)) {
d560 1
a560 3
    if (caller eq __PACKAGE__) {
	print STDERR "INTERNAL EXCEPTION: $exception";
    } 
@


