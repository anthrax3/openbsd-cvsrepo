head	1.2;
access;
symbols
	OPENBSD_5_3:1.1.1.1.0.42
	OPENBSD_5_3_BASE:1.1.1.1
	OPENBSD_5_2:1.1.1.1.0.40
	OPENBSD_5_2_BASE:1.1.1.1
	OPENBSD_5_1_BASE:1.1.1.1
	OPENBSD_5_1:1.1.1.1.0.38
	OPENBSD_5_0:1.1.1.1.0.36
	OPENBSD_5_0_BASE:1.1.1.1
	OPENBSD_4_9:1.1.1.1.0.34
	OPENBSD_4_9_BASE:1.1.1.1
	PERL_5_12_2:1.1.1.1
	OPENBSD_4_8:1.1.1.1.0.32
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.28
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2013.03.25.20.40.56;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@#!./perl

$| = 1;

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

if ($^O eq 'VMS') {
    print "1..11\n";
    foreach (1..11) { print "ok $_ # skipped for VMS\n"; }
    exit 0;
}

use Env  qw(@@FOO);
use vars qw(@@BAR);

sub array_equal
{
    my ($a, $b) = @@_;
    return 0 unless scalar(@@$a) == scalar(@@$b);
    for my $i (0..scalar(@@$a) - 1) {
	return 0 unless $a->[$i] eq $b->[$i];
    }
    return 1;
}

sub test
{
    my ($desc, $code) = @@_;

    &$code;

    print "# $desc...\n";
    print "#    FOO = (", join(", ", @@FOO), ")\n";
    print "#    BAR = (", join(", ", @@BAR), ")\n";

    if (defined $check) { print "not " unless &$check; }
    else { print "not " unless array_equal(\@@FOO, \@@BAR); }

    print "ok ", ++$i, "\n";
}

print "1..11\n";

test "Assignment", sub {
    @@FOO = qw(a B c);
    @@BAR = qw(a B c);
};

test "Storing", sub {
    $FOO[1] = 'b';
    $BAR[1] = 'b';
};

test "Truncation", sub {
    $#FOO = 0;
    $#BAR = 0;
};

test "Push", sub {
    push @@FOO, 'b', 'c';
    push @@BAR, 'b', 'c';
};

test "Pop", sub {
    pop @@FOO;
    pop @@BAR;
};

test "Shift", sub {
    shift @@FOO;
    shift @@BAR;
};

test "Push", sub {
    push @@FOO, 'c';
    push @@BAR, 'c';
};

test "Unshift", sub {
    unshift @@FOO, 'a';
    unshift @@BAR, 'a';
};

test "Reverse", sub {
    @@FOO = reverse @@FOO;
    @@BAR = reverse @@BAR;
};

test "Sort", sub {
    @@FOO = sort @@FOO;
    @@BAR = sort @@BAR;
};

test "Splice", sub {
    splice @@FOO, 1, 1, 'B';
    splice @@BAR, 1, 1, 'B';
};
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@
