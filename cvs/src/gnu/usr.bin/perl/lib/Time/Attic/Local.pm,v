head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2010.09.24.14.59.55;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.46;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.14;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.09.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.58;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.11;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.52;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.52;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.20;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.11;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.47.30;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.02;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.44;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.59;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Time::Local;

require Exporter;
use Carp;
use Config;
use strict;
use integer;

use vars qw( $VERSION @@ISA @@EXPORT @@EXPORT_OK );
$VERSION   = '1.1901';

@@ISA       = qw( Exporter );
@@EXPORT    = qw( timegm timelocal );
@@EXPORT_OK = qw( timegm_nocheck timelocal_nocheck );

my @@MonthDays = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );

# Determine breakpoint for rolling century
my $ThisYear    = ( localtime() )[5];
my $Breakpoint  = ( $ThisYear + 50 ) % 100;
my $NextCentury = $ThisYear - $ThisYear % 100;
$NextCentury += 100 if $Breakpoint < 50;
my $Century = $NextCentury - 100;
my $SecOff  = 0;

my ( %Options, %Cheat );

use constant SECS_PER_MINUTE => 60;
use constant SECS_PER_HOUR   => 3600;
use constant SECS_PER_DAY    => 86400;

my $MaxInt;
if ( $^O eq 'MacOS' ) {
    # time_t is unsigned...
    $MaxInt = ( 1 << ( 8 * $Config{ivsize} ) ) - 1;
}
else {
    $MaxInt = ( ( 1 << ( 8 * $Config{ivsize} - 2 ) ) - 1 ) * 2 + 1;
}

my $MaxDay = int( ( $MaxInt - ( SECS_PER_DAY / 2 ) ) / SECS_PER_DAY ) - 1;

# Determine the EPOC day for this machine
my $Epoc = 0;
if ( $^O eq 'vos' ) {
    # work around posix-977 -- VOS doesn't handle dates in the range
    # 1970-1980.
    $Epoc = _daygm( 0, 0, 0, 1, 0, 70, 4, 0 );
}
elsif ( $^O eq 'MacOS' ) {
    $MaxDay *=2 if $^O eq 'MacOS';  # time_t unsigned ... quick hack?
    # MacOS time() is seconds since 1 Jan 1904, localtime
    # so we need to calculate an offset to apply later
    $Epoc = 693901;
    $SecOff = timelocal( localtime(0)) - timelocal( gmtime(0) ) ;
    $Epoc += _daygm( gmtime(0) );
}
else {
    $Epoc = _daygm( gmtime(0) );
}

%Cheat = ();    # clear the cache as epoc has changed

sub _daygm {

    # This is written in such a byzantine way in order to avoid
    # lexical variables and sub calls, for speed
    return $_[3] + (
        $Cheat{ pack( 'ss', @@_[ 4, 5 ] ) } ||= do {
            my $month = ( $_[4] + 10 ) % 12;
            my $year  = ( $_[5] + 1900 ) - ( $month / 10 );

            ( ( 365 * $year )
              + ( $year / 4 )
              - ( $year / 100 )
              + ( $year / 400 )
              + ( ( ( $month * 306 ) + 5 ) / 10 )
            )
            - $Epoc;
        }
    );
}

sub _timegm {
    my $sec =
        $SecOff + $_[0] + ( SECS_PER_MINUTE * $_[1] ) + ( SECS_PER_HOUR * $_[2] );

    return $sec + ( SECS_PER_DAY * &_daygm );
}

sub timegm {
    my ( $sec, $min, $hour, $mday, $month, $year ) = @@_;

    if ( $year >= 1000 ) {
        $year -= 1900;
    }
    elsif ( $year < 100 and $year >= 0 ) {
        $year += ( $year > $Breakpoint ) ? $Century : $NextCentury;
    }

    unless ( $Options{no_range_check} ) {
        croak "Month '$month' out of range 0..11"
            if $month > 11
            or $month < 0;

	my $md = $MonthDays[$month];
        ++$md
            if $month == 1 && _is_leap_year( $year + 1900 );

        croak "Day '$mday' out of range 1..$md"  if $mday > $md or $mday < 1;
        croak "Hour '$hour' out of range 0..23"  if $hour > 23  or $hour < 0;
        croak "Minute '$min' out of range 0..59" if $min > 59   or $min < 0;
        croak "Second '$sec' out of range 0..59" if $sec > 59   or $sec < 0;
    }

    my $days = _daygm( undef, undef, undef, $mday, $month, $year );

    unless ($Options{no_range_check} or abs($days) < $MaxDay) {
        my $msg = '';
        $msg .= "Day too big - $days > $MaxDay\n" if $days > $MaxDay;

	$year += 1900;
        $msg .=  "Cannot handle date ($sec, $min, $hour, $mday, $month, $year)";

	croak $msg;
    }

    return $sec
           + $SecOff
           + ( SECS_PER_MINUTE * $min )
           + ( SECS_PER_HOUR * $hour )
           + ( SECS_PER_DAY * $days );
}

sub _is_leap_year {
    return 0 if $_[0] % 4;
    return 1 if $_[0] % 100;
    return 0 if $_[0] % 400;

    return 1;
}

sub timegm_nocheck {
    local $Options{no_range_check} = 1;
    return &timegm;
}

sub timelocal {
    my $ref_t = &timegm;
    my $loc_for_ref_t = _timegm( localtime($ref_t) );

    my $zone_off = $loc_for_ref_t - $ref_t
        or return $loc_for_ref_t;

    # Adjust for timezone
    my $loc_t = $ref_t - $zone_off;

    # Are we close to a DST change or are we done
    my $dst_off = $ref_t - _timegm( localtime($loc_t) );

    # If this evaluates to true, it means that the value in $loc_t is
    # the _second_ hour after a DST change where the local time moves
    # backward.
    if ( ! $dst_off &&
         ( ( $ref_t - SECS_PER_HOUR ) - _timegm( localtime( $loc_t - SECS_PER_HOUR ) ) < 0 )
       ) {
        return $loc_t - SECS_PER_HOUR;
    }

    # Adjust for DST change
    $loc_t += $dst_off;

    return $loc_t if $dst_off > 0;

    # If the original date was a non-extent gap in a forward DST jump,
    # we should now have the wrong answer - undo the DST adjustment
    my ( $s, $m, $h ) = localtime($loc_t);
    $loc_t -= $dst_off if $s != $_[0] || $m != $_[1] || $h != $_[2];

    return $loc_t;
}

sub timelocal_nocheck {
    local $Options{no_range_check} = 1;
    return &timelocal;
}

1;

__END__

=head1 NAME

Time::Local - efficiently compute time from local and GMT time

=head1 SYNOPSIS

    $time = timelocal($sec,$min,$hour,$mday,$mon,$year);
    $time = timegm($sec,$min,$hour,$mday,$mon,$year);

=head1 DESCRIPTION

This module provides functions that are the inverse of built-in perl
functions C<localtime()> and C<gmtime()>. They accept a date as a
six-element array, and return the corresponding C<time(2)> value in
seconds since the system epoch (Midnight, January 1, 1970 GMT on Unix,
for example). This value can be positive or negative, though POSIX
only requires support for positive values, so dates before the
system's epoch may not work on all operating systems.

It is worth drawing particular attention to the expected ranges for
the values provided. The value for the day of the month is the actual
day (ie 1..31), while the month is the number of months since January
(0..11). This is consistent with the values returned from
C<localtime()> and C<gmtime()>.

=head1 FUNCTIONS

=head2 C<timelocal()> and C<timegm()>

This module exports two functions by default, C<timelocal()> and
C<timegm()>.

The C<timelocal()> and C<timegm()> functions perform range checking on
the input $sec, $min, $hour, $mday, and $mon values by default.

=head2 C<timelocal_nocheck()> and C<timegm_nocheck()>

If you are working with data you know to be valid, you can speed your
code up by using the "nocheck" variants, C<timelocal_nocheck()> and
C<timegm_nocheck()>. These variants must be explicitly imported.

    use Time::Local 'timelocal_nocheck';

    # The 365th day of 1999
    print scalar localtime timelocal_nocheck 0,0,0,365,0,99;

If you supply data which is not valid (month 27, second 1,000) the
results will be unpredictable (so don't do that).

=head2 Year Value Interpretation

Strictly speaking, the year should be specified in a form consistent
with C<localtime()>, i.e. the offset from 1900. In order to make the
interpretation of the year easier for humans, however, who are more
accustomed to seeing years as two-digit or four-digit values, the
following conventions are followed:

=over 4

=item *

Years greater than 999 are interpreted as being the actual year,
rather than the offset from 1900. Thus, 1964 would indicate the year
Martin Luther King won the Nobel prize, not the year 3864.

=item *

Years in the range 100..999 are interpreted as offset from 1900, so
that 112 indicates 2012. This rule also applies to years less than
zero (but see note below regarding date range).

=item *

Years in the range 0..99 are interpreted as shorthand for years in the
rolling "current century," defined as 50 years on either side of the
current year. Thus, today, in 1999, 0 would refer to 2000, and 45 to
2045, but 55 would refer to 1955. Twenty years from now, 55 would
instead refer to 2055. This is messy, but matches the way people
currently think about two digit dates. Whenever possible, use an
absolute four digit year instead.

=back

The scheme above allows interpretation of a wide range of dates,
particularly if 4-digit years are used.

=head2 Limits of time_t

The range of dates that can be actually be handled depends on the size
of C<time_t> (usually a signed integer) on the given
platform. Currently, this is 32 bits for most systems, yielding an
approximate range from Dec 1901 to Jan 2038.

Both C<timelocal()> and C<timegm()> croak if given dates outside the
supported range.

=head2 Ambiguous Local Times (DST)

Because of DST changes, there are many time zones where the same local
time occurs for two different GMT times on the same day. For example,
in the "Europe/Paris" time zone, the local time of 2001-10-28 02:30:00
can represent either 2001-10-28 00:30:00 GMT, B<or> 2001-10-28
01:30:00 GMT.

When given an ambiguous local time, the timelocal() function should
always return the epoch for the I<earlier> of the two possible GMT
times.

=head2 Non-Existent Local Times (DST)

When a DST change causes a locale clock to skip one hour forward,
there will be an hour's worth of local times that don't exist. Again,
for the "Europe/Paris" time zone, the local clock jumped from
2001-03-25 01:59:59 to 2001-03-25 03:00:00.

If the C<timelocal()> function is given a non-existent local time, it
will simply return an epoch value for the time one hour later.

=head2 Negative Epoch Values

Negative epoch (C<time_t>) values are not officially supported by the
POSIX standards, so this module's tests do not test them. On some
systems, they are known not to work. These include MacOS (pre-OSX) and
Win32.

On systems which do support negative epoch values, this module should
be able to cope with dates before the start of the epoch, down the
minimum value of time_t for the system.

=head1 IMPLEMENTATION

These routines are quite efficient and yet are always guaranteed to
agree with C<localtime()> and C<gmtime()>. We manage this by caching
the start times of any months we've seen before. If we know the start
time of the month, we can always calculate any time within the month.
The start times are calculated using a mathematical formula. Unlike
other algorithms that do multiple calls to C<gmtime()>.

The C<timelocal()> function is implemented using the same cache. We
just assume that we're translating a GMT time, and then fudge it when
we're done for the timezone and daylight savings arguments. Note that
the timezone is evaluated for each date because countries occasionally
change their official timezones. Assuming that C<localtime()> corrects
for these changes, this routine will also be correct.

=head1 BUGS

The whole scheme for interpreting two-digit years can be considered a
bug.

=head1 SUPPORT

Support for this module is provided via the datetime@@perl.org email
list. See http://lists.perl.org/ for more details.

Please submit bugs to the CPAN RT system at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local or via email
at bug-time-local@@rt.cpan.org.

=head1 COPYRIGHT

Copyright (c) 1997-2003 Graham Barr, 2003-2007 David Rolsky.  All
rights reserved.  This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

The full text of the license can be found in the LICENSE file included
with this module.

=head1 AUTHOR

This module is based on a Perl 4 library, timelocal.pl, that was
included with Perl 4.036, and was most likely written by Tom
Christiansen.

The current version was written by Graham Barr.

It is now being maintained separately from the Perl core by Dave
Rolsky, <autarch@@urth.org>.

=cut
@


1.10
log
@Merge in perl 5.10.1
@
text
@@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d10 1
a10 1
$VERSION   = '1.18';
d32 1
a32 3
my $MaxInt = ( ( 1 << ( 8 * $Config{intsize} - 2 ) ) -1 ) * 2 + 1;
my $MaxDay = int( ( $MaxInt - ( SECS_PER_DAY / 2 ) ) / SECS_PER_DAY ) - 1;

d35 1
a35 1
    $MaxInt = ( 1 << ( 8 * $Config{intsize} ) ) - 1;
d38 1
a38 1
    $MaxInt = ( ( 1 << ( 8 * $Config{intsize} - 2 ) ) - 1 ) * 2 + 1;
d41 2
d71 1
a71 1
            my $year  = $_[5] + 1900 - $month / 10;
a101 6
        if ( abs($year) >= 0x7fff ) {
            $year += 1900;
            croak
                "Cannot handle date ($sec, $min, $hour, $mday, $month, *$year*)";
        }

@


1.8
log
@merge in perl 5.8.8
@
text
@d10 1
a10 5
$VERSION    = '1.11';
$VERSION    = eval $VERSION;
@@ISA	= qw( Exporter );
@@EXPORT	= qw( timegm timelocal );
@@EXPORT_OK	= qw( timegm_nocheck timelocal_nocheck );
d12 5
a16 1
my @@MonthDays = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
d19 12
a30 6
my $ThisYear     = (localtime())[5];
my $Breakpoint   = ($ThisYear + 50) % 100;
my $NextCentury  = $ThisYear - $ThisYear % 100;
   $NextCentury += 100 if $Breakpoint < 50;
my $Century      = $NextCentury - 100;
my $SecOff       = 0;
d32 2
a33 2
my (%Options, %Cheat, %Min, %Max);
my ($MinInt, $MaxInt);
d35 1
a35 1
if ($^O eq 'MacOS') {
d37 4
a40 10
    $MaxInt = (1 << (8 * $Config{intsize})) - 1;
    $MinInt = 0;
} else {
    $MaxInt = ((1 << (8 * $Config{intsize} - 2))-1)*2 + 1;
    $MinInt = -$MaxInt - 1;

    # On Win32 (and others?) time_t appears to be signed, but negative
    # epochs still don't work. - XXX - this is experimental
    $MinInt = 0
        unless defined ((localtime(-1))[0]);
a42 6
$Max{Day} = ($MaxInt >> 1) / 43200;
$Min{Day} = $MinInt ? -($Max{Day} + 1) : 0;

$Max{Sec} = $MaxInt - 86400 * $Max{Day};
$Min{Sec} = $MinInt - 86400 * $Min{Day};

d45 12
a56 13
if ($^O eq 'vos') {
# work around posix-977 -- VOS doesn't handle dates in
# the range 1970-1980.
  $Epoc = _daygm((0, 0, 0, 1, 0, 70, 4, 0));
}
elsif ($^O eq 'MacOS') {
  no integer;

  # MacOS time() is seconds since 1 Jan 1904, localtime
  # so we need to calculate an offset to apply later
  $Epoc = 693901;
  $SecOff = timelocal(localtime(0)) - timelocal(gmtime(0));
  $Epoc += _daygm(gmtime(0));
d59 1
a59 1
  $Epoc = _daygm(gmtime(0));
d62 1
a62 1
%Cheat=(); # clear the cache as epoc has changed
d65 17
a81 5
    $_[3] + ($Cheat{pack("ss",@@_[4,5])} ||= do {
	my $month = ($_[4] + 10) % 12;
	my $year = $_[5] + 1900 - $month/10;
	365*$year + $year/4 - $year/100 + $year/400 + ($month*306 + 5)/10 - $Epoc
    });
a83 1

d85 2
a86 3
    my $sec = $SecOff + $_[0]  +  60 * $_[1]  +  3600 * $_[2];

    no integer;
d88 1
a88 1
    $sec +  86400 * &_daygm;
a90 12

sub _zoneadjust {
    my ($day, $sec, $time) = @@_;

    $sec = $sec + _timegm(localtime($time)) - $time;
    if ($sec >= 86400) { $day++; $sec -= 86400; }
    if ($sec <  0)     { $day--; $sec += 86400; }

    ($day, $sec);
}


d92 1
a92 1
    my ($sec,$min,$hour,$mday,$month,$year) = @@_;
d94 2
a95 2
    if ($year >= 1000) {
	$year -= 1900;
d97 2
a98 2
    elsif ($year < 100 and $year >= 0) {
	$year += ($year > $Breakpoint) ? $Century : $NextCentury;
d101 10
a110 5
    unless ($Options{no_range_check}) {
	if (abs($year) >= 0x7fff) {
	    $year += 1900;
	    croak "Cannot handle date ($sec, $min, $hour, $mday, $month, *$year*)";
	}
d112 3
a114 1
	croak "Month '$month' out of range 0..11" if $month > 11 or $month < 0;
d116 4
a119 9
	my $md = $MonthDays[$month];
#        ++$md if $month == 1 and $year % 4 == 0 and
#            ($year % 100 != 0 or ($year + 1900) % 400 == 0);
	++$md unless $month != 1 or $year % 4 or !($year % 400);

	croak "Day '$mday' out of range 1..$md"   if $mday  > $md  or $mday  < 1;
	croak "Hour '$hour' out of range 0..23"   if $hour  > 23   or $hour  < 0;
	croak "Minute '$min' out of range 0..59"  if $min   > 59   or $min   < 0;
	croak "Second '$sec' out of range 0..59"  if $sec   > 59   or $sec   < 0;
d122 5
a126 2
    my $days = _daygm(undef, undef, undef, $mday, $month, $year);
    my $xsec = $sec + $SecOff + 60*$min + 3600*$hour;
a127 8
    unless ($Options{no_range_check}
        or  ($days > $Min{Day} or $days == $Min{Day} and $xsec >= $Min{Sec})
       and  ($days < $Max{Day} or $days == $Max{Day} and $xsec <= $Max{Sec}))
    {
        warn "Day too small - $days > $Min{Day}\n" if $days < $Min{Day};
        warn "Day too big - $days > $Max{Day}\n" if $days > $Max{Day};
        warn "Sec too small - $days < $Min{Sec}\n" if $days < $Min{Sec};
        warn "Sec too big - $days > $Max{Sec}\n" if $days > $Max{Sec};
d129 3
a131 1
	croak "Cannot handle date ($sec, $min, $hour, $mday, $month, $year)";
d134 6
a139 1
    no integer;
d141 6
a146 1
    $xsec + 86400 * $days;
a148 1

d151 1
a151 1
    &timegm;
a153 1

a154 3
    # Adjust Max/Min allowed times to fit local time zone and call timegm
    local ($Max{Day}, $Max{Sec}) = _zoneadjust($Max{Day}, $Max{Sec}, $MaxInt);
    local ($Min{Day}, $Min{Sec}) = _zoneadjust($Min{Day}, $Min{Sec}, $MinInt);
d156 1
d158 2
a159 11
    # Calculate first guess with a one-day delta to avoid localtime overflow
    my $delta = ($_[5] < 100)? 86400 : -86400;
    my $loc_t = _timegm(localtime( $ref_t + $delta )) - $delta;

    # Is there a timezone offset from GMT or are we done
    my $zone_off = $ref_t - $loc_t
	or return $loc_t;

    # This hack is needed to always pick the first matching time
    # during a DST change when time would otherwise be ambiguous
    $zone_off -= 3600 if ($delta > 0 && $ref_t >= 3600);
d162 1
a162 1
    $loc_t = $ref_t + $zone_off;
d165 10
a174 2
    my $dst_off = $ref_t - _timegm(localtime($loc_t))
	or return $loc_t;
d179 1
a179 1
    return $loc_t if $dst_off >= 0;
d181 3
a183 5
    # for a negative offset from GMT, and if the original date
    # was a non-extent gap in a forward DST jump, we should
    # now have the wrong answer - undo the DST adjust;

    my ($s,$m,$h) = localtime($loc_t);
d186 1
a186 1
    $loc_t;
a188 1

d191 1
a191 1
    &timelocal;
d209 7
a215 7
These routines are the inverse of built-in perl functions localtime()
and gmtime().  They accept a date as a six-element array, and return
the corresponding time(2) value in seconds since the system epoch
(Midnight, January 1, 1970 GMT on Unix, for example).  This value can
be positive or negative, though POSIX only requires support for
positive values, so dates before the system's epoch may not work on
all operating systems.
d218 36
a253 30
the values provided.  The value for the day of the month is the actual day
(ie 1..31), while the month is the number of months since January (0..11).
This is consistent with the values returned from localtime() and gmtime().

The timelocal() and timegm() functions perform range checking on the
input $sec, $min, $hour, $mday, and $mon values by default.  If you'd
rather they didn't, you can explicitly import the timelocal_nocheck()
and timegm_nocheck() functions.

	use Time::Local 'timelocal_nocheck';

	{
	    # The 365th day of 1999
	    print scalar localtime timelocal_nocheck 0,0,0,365,0,99;

	    # The twenty thousandth day since 1970
	    print scalar localtime timelocal_nocheck 0,0,0,20000,0,70;

	    # And even the 10,000,000th second since 1999!
	    print scalar localtime timelocal_nocheck 10000000,0,0,1,0,99;
	}

Your mileage may vary when trying these with minutes and hours,
and it doesn't work at all for months.

Strictly speaking, the year should also be specified in a form consistent
with localtime(), i.e. the offset from 1900.
In order to make the interpretation of the year easier for humans,
however, who are more accustomed to seeing years as two-digit or four-digit
values, the following conventions are followed:
d260 1
a260 1
rather than the offset from 1900.  Thus, 1964 would indicate the year
d265 3
a267 3
Years in the range 100..999 are interpreted as offset from 1900, 
so that 112 indicates 2012.  This rule also applies to years less than zero
(but see note below regarding date range).
d272 6
a277 5
rolling "current century," defined as 50 years on either side of the current
year.  Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045,
but 55 would refer to 1955.  Twenty years from now, 55 would instead refer
to 2055.  This is messy, but matches the way people currently think about
two digit dates.  Whenever possible, use an absolute four digit year instead.
d281 2
a282 2
The scheme above allows interpretation of a wide range of dates, particularly
if 4-digit years are used.  
d284 1
a284 4
Please note, however, that the range of dates that can be actually be handled
depends on the size of an integer (time_t) on a given platform.  
Currently, this is 32 bits for most systems, yielding an approximate range 
from Dec 1901 to Jan 2038.
d286 7
a292 2
Both timelocal() and timegm() croak if given dates outside the supported
range.
d297 1
a297 1
time occurs for two different GMT times on the same day.  For example,
d309 1
a309 1
there will be an hour's worth of local times that don't exist.  Again,
d313 1
a313 1
If the timelocal() function is given a non-existent local time, it
d318 4
a321 4
Negative epoch (time_t) values are not officially supported by the
POSIX standards, so this module's tests do not test them.  On some
systems, they are known not to work.  These include MacOS (pre-OSX)
and Win32.
d329 13
a341 13
These routines are quite efficient and yet are always guaranteed to agree
with localtime() and gmtime().  We manage this by caching the start times
of any months we've seen before.  If we know the start time of the month,
we can always calculate any time within the month.  The start times
are calculated using a mathematical formula. Unlike other algorithms
that do multiple calls to gmtime().

timelocal() is implemented using the same cache.  We just assume that we're
translating a GMT time, and then fudge it when we're done for the timezone
and daylight savings arguments.  Note that the timezone is evaluated for
each date because countries occasionally change their official timezones.
Assuming that localtime() corrects for these changes, this routine will
also be correct.
d345 2
a346 1
The whole scheme for interpreting two-digit years can be considered a bug.
d350 8
a357 2
Support for this module is provided via the datetime@@perl.org
email list.  See http://lists.perl.org/ for more details.
d359 6
a364 2
Please submit bugs using the RT system at rt.cpan.org, or as a last
resort, to the datetime@@perl.org list.
a377 1

@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d10 1
a10 1
$VERSION    = '1.10';
d36 5
d44 1
a44 1
$Min{Day} = ($MinInt)? -($Max{Day}+1) : 0;
d46 2
a47 2
$Max{Sec} =  $MaxInt - 86400 * $Max{Day};
$Min{Sec} =  $MinInt - 86400 * $Min{Day};
d119 2
d262 2
a263 2
rather than the offset from 1900.  Thus, 1963 would indicate the year
Martin Luther King won the Nobel prize, not the year 3863.
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d10 2
a11 1
$VERSION    = '1.07';
d26 2
a27 1
my (%Options, %Cheat);
d29 14
a42 2
my $MaxInt = ((1<<(8 * $Config{intsize} - 2))-1)*2 + 1;
my $MaxDay = int(($MaxInt-43200)/86400)-1;
a53 1
  $MaxDay *=2 if $^O eq 'MacOS';  # time_t unsigned ... quick hack?
d84 11
d108 1
a108 1
	    croak "Cannot handle date ($sec, $min, $hour, $mday, $month, $year)";
d123 1
d125 8
a132 1
    unless ($Options{no_range_check} or abs($days) < $MaxDay) {
a136 2
    $sec += $SecOff + 60*$min + 3600*$hour;

d139 1
a139 1
    $sec + 86400*$days;
d150 3
a152 1
    no integer;
d154 4
a157 1
    my $loc_t = _timegm(localtime($ref_t));
d163 4
d177 2
a182 2
    return $loc_t if $zone_off <= 0;

d213 1
a213 1
(Midnight, January 1, 1970 UTC on Unix, for example).  This value can
d256 1
a256 1
Martin Luther King won the Nobel prize, not the year 2863.
d286 33
a338 2
The proclivity to croak() is probably a bug.

d341 1
a341 1
Support for this module is provided via the perl5-porters@@perl.org
d344 2
a345 2
Please submit bugs using the RT system at bugs.perl.org, the perlbug
script, or as a last resort, to the perl5-porters@@perl.org list.
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d2 1
a2 1
use 5.006;
d9 5
a13 4
our $VERSION    = '1.04';
our @@ISA	= qw( Exporter );
our @@EXPORT	= qw( timegm timelocal );
our @@EXPORT_OK	= qw( timegm_nocheck timelocal_nocheck );
d136 12
a147 1
    $loc_t + $dst_off;
d173 5
a177 2
the corresponding time(2) value in seconds since the Epoch (Midnight,
January 1, 1970).  This value can be positive or negative.
d268 19
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d2 1
a2 1
require 5.000;
d5 10
a15 9
@@ISA		= qw( Exporter );
@@EXPORT		= qw( timegm timelocal );
@@EXPORT_OK	= qw( timegm_nocheck timelocal_nocheck );

# Set up constants
    $SEC  = 1;
    $MIN  = 60 * $SEC;
    $HR   = 60 * $MIN;
    $DAY  = 24 * $HR;
d17 51
a67 4
    my $thisYear = (localtime())[5];
    $nextCentury = int($thisYear / 100) * 100;
    $breakpoint = ($thisYear + 50) % 100;
    $nextCentury += 100 if $breakpoint < 50;
a68 1
my %options;
d71 7
a77 3
    my (@@date) = @@_;
    if ($date[5] > 999) {
        $date[5] -= 1900;
d79 23
a101 3
    elsif ($date[5] >= 0 && $date[5] < 100) {
        $date[5] -= 100 if $date[5] > $breakpoint;
        $date[5] += $nextCentury;
d103 6
a108 7
    $ym = pack(C2, @@date[5,4]);
    $cheat = $cheat{$ym} || &cheat(@@date);
    $cheat
    + $date[0] * $SEC
    + $date[1] * $MIN
    + $date[2] * $HR
    + ($date[3]-1) * $DAY;
d111 1
d113 1
a113 1
    local $options{no_range_check} = 1;
d117 1
d119 14
a132 2
    my $t = &timegm;
    my $tt = $t;
d134 3
a136 11
    my (@@lt) = localtime($t);
    my (@@gt) = gmtime($t);
    if ($t < $DAY and ($lt[5] >= 70 or $gt[5] >= 70 )) {
	# Wrap error, too early a date
	# Try a safer date
	$tt += $DAY;
	@@lt = localtime($tt);
	@@gt = gmtime($tt);
    }

    my $tzsec = ($gt[1] - $lt[1]) * $MIN + ($gt[2] - $lt[2]) * $HR;
a137 17
    if($lt[5] > $gt[5]) {
	$tzsec -= $DAY;
    }
    elsif($gt[5] > $lt[5]) {
	$tzsec += $DAY;
    }
    else {
	$tzsec += ($gt[7] - $lt[7]) * $DAY;
    }

    $tzsec += $HR if($lt[8]);
    
    $time = $t + $tzsec;
    @@test = localtime($time + ($tt - $t));
    $time -= $HR if $test[2] != $_[2];
    $time;
}
d140 1
a140 1
    local $options{no_range_check} = 1;
a143 44
sub cheat {
    $year = $_[5];
    $month = $_[4];
    unless ($options{no_range_check}) {
	croak "Month '$month' out of range 0..11" if $month > 11 || $month < 0;
	croak "Day '$_[3]' out of range 1..31"	  if $_[3] > 31 || $_[3] < 1;
	croak "Hour '$_[2]' out of range 0..23"	  if $_[2] > 23 || $_[2] < 0;
	croak "Minute '$_[1]' out of range 0..59" if $_[1] > 59 || $_[1] < 0;
	croak "Second '$_[0]' out of range 0..59" if $_[0] > 59 || $_[0] < 0;
    }
    $guess = $^T;
    @@g = gmtime($guess);
    $lastguess = "";
    $counter = 0;
    while ($diff = $year - $g[5]) {
	croak "Can't handle date (".join(", ",@@_).")" if ++$counter > 255;
	$guess += $diff * (363 * $DAY);
	@@g = gmtime($guess);
	if (($thisguess = "@@g") eq $lastguess){
	    croak "Can't handle date (".join(", ",@@_).")";
	    #date beyond this machine's integer limit
	}
	$lastguess = $thisguess;
    }
    while ($diff = $month - $g[4]) {
	croak "Can't handle date (".join(", ",@@_).")" if ++$counter > 255;
	$guess += $diff * (27 * $DAY);
	@@g = gmtime($guess);
	if (($thisguess = "@@g") eq $lastguess){
	    croak "Can't handle date (".join(", ",@@_).")";
	    #date beyond this machine's integer limit
	}
	$lastguess = $thisguess;
    }
    @@gfake = gmtime($guess-1); #still being sceptic
    if ("@@gfake" eq $lastguess){
        croak "Can't handle date (".join(", ",@@_).")";
        #date beyond this machine's integer limit
    }
    $g[3]--;
    $guess -= $g[0] * $SEC + $g[1] * $MIN + $g[2] * $HR + $g[3] * $DAY;
    $cheat{$ym} = $guess;
}

d154 2
a155 2
    $time = timelocal($sec,$min,$hours,$mday,$mon,$year);
    $time = timegm($sec,$min,$hours,$mday,$mon,$year);
d159 1
a159 1
These routines are the inverse of built-in perl fuctions localtime()
d165 2
a166 2
the values provided.  While the day of the month is expected to be in
the range 1..31, the month should be in the range 0..11.  
d170 1
a170 1
input $sec, $min, $hours, $mday, and $mon values by default.  If you'd
d238 2
a239 6
themselves are guessed by successive approximation starting at the
current time, since most dates seen in practice are close to the
current date.  Unlike algorithms that do a binary search (calling gmtime
once for each bit of the time value, resulting in 32 calls), this algorithm
calls it at most 6 times, and usually only once or twice.  If you hit
the month cache, of course, it doesn't call it at all.
d246 1
a246 2
also be correct.  The daylight savings offset is currently assumed 
to be one hour.
a251 2
Note that the cache currently handles only years from 1900 through 2155.

d255 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d6 3
a8 2
@@ISA = qw(Exporter);
@@EXPORT = qw(timegm timelocal);
d10 1
a10 36
=head1 NAME

Time::Local - efficiently compute time from local and GMT time

=head1 SYNOPSIS

    $time = timelocal($sec,$min,$hours,$mday,$mon,$year);
    $time = timegm($sec,$min,$hours,$mday,$mon,$year);

=head1 DESCRIPTION

These routines are quite efficient and yet are always guaranteed to
agree with localtime() and gmtime(), the most notable points being
that year is year-1900 and month is 0..11.  We manage this by caching
the start times of any months we've seen before.  If we know the start
time of the month, we can always calculate any time within the month.
The start times themselves are guessed by successive approximation
starting at the current time, since most dates seen in practice are
close to the current date.  Unlike algorithms that do a binary search
(calling gmtime once for each bit of the time value, resulting in 32
calls), this algorithm calls it at most 6 times, and usually only once
or twice.  If you hit the month cache, of course, it doesn't call it
at all.

timelocal is implemented using the same cache.  We just assume that we're
translating a GMT time, and then fudge it when we're done for the timezone
and daylight savings arguments.  The timezone is determined by examining
the result of localtime(0) when the package is initialized.  The daylight
savings offset is currently assumed to be one hour.

Both routines return -1 if the integer limit is hit. I.e. for dates
after the 1st of January, 2038 on most machines.

=cut

BEGIN {
d15 5
a19 1
    $epoch = (localtime(2*$DAY))[5];	# Allow for bugs near localtime == 0.
d21 1
a21 1
    $YearFix = ((gmtime(946684800))[5] == 100) ? 100 : 0;
d23 16
d41 3
a43 5
sub timegm {
    $ym = pack(C2, @@_[5,4]);
    $cheat = $cheat{$ym} || &cheat;
    return -1 if $cheat<0 and $^O ne 'VMS';
    $cheat + $_[0] * $SEC + $_[1] * $MIN + $_[2] * $HR + ($_[3]-1) * $DAY;
d53 5
a57 5
      # Wrap error, too early a date
      # Try a safer date
      $tt = $DAY;
      @@lt = localtime($tt);
      @@gt = gmtime($tt);
a61 1
    my($lday,$gday) = ($lt[7],$gt[7]);
a74 1
    return -1 if $cheat<0 and $^O ne 'VMS';
d80 5
a86 2
    $year -= 1900
    	if $year > 1900;
d88 7
a94 5
    croak "Month '$month' out of range 0..11"	if $month > 11 || $month < 0;
    croak "Day '$_[3]' out of range 1..31"	if $_[3] > 31 || $_[3] < 1;
    croak "Hour '$_[2]' out of range 0..23"	if $_[2] > 23 || $_[2] < 0;
    croak "Minute '$_[1]' out of range 0..59"	if $_[1] > 59 || $_[1] < 0;
    croak "Second '$_[0]' out of range 0..59"	if $_[0] > 59 || $_[0] < 0;
a96 1
    $year += $YearFix if $year < $epoch;
d104 2
a105 1
	    return -1; #date beyond this machine's integer limit
d114 2
a115 1
	    return -1; #date beyond this machine's integer limit
d121 2
a122 1
	return -1; #date beyond this machine's integer limit
d130 117
@


1.2
log
@perl 5.004_04
@
text
@d20 12
a31 10
These routines are quite efficient and yet are always guaranteed to agree
with localtime() and gmtime().  We manage this by caching the start times
of any months we've seen before.  If we know the start time of the month,
we can always calculate any time within the month.  The start times
themselves are guessed by successive approximation starting at the
current time, since most dates seen in practice are close to the
current date.  Unlike algorithms that do a binary search (calling gmtime
once for each bit of the time value, resulting in 32 calls), this algorithm
calls it at most 6 times, and usually only once or twice.  If you hit
the month cache, of course, it doesn't call it at all.
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
Time::Local - efficiently compute tome from local and GMT time
d42 9
a50 5
@@epoch = localtime(0);
$tzmin = $epoch[2] * 60 + $epoch[1];	# minutes east of GMT
if ($tzmin > 0) {
    $tzmin = 24 * 60 - $tzmin;		# minutes west of GMT
    $tzmin -= 24 * 60 if $epoch[5] == 70;	# account for the date line
a52 6
$SEC = 1;
$MIN = 60 * $SEC;
$HR = 60 * $MIN;
$DAYS = 24 * $HR;
$YearFix = ((gmtime(946684800))[5] == 100) ? 100 : 0;

d56 2
a57 2
    return -1 if $cheat<0;
    $cheat + $_[0] * $SEC + $_[1] * $MIN + $_[2] * $HR + ($_[3]-1) * $DAYS;
d61 31
a91 3
    $time = &timegm + $tzmin*$MIN;
    return -1 if $cheat<0;
    @@test = localtime($time);
d98 2
d101 5
a105 10
    croak "Month out of range 0..11 in timelocal.pl" 
	if $month > 11 || $month < 0;
    croak "Day out of range 1..31 in timelocal.pl" 
	if $_[3] > 31 || $_[3] < 1;
    croak "Hour out of range 0..23 in timelocal.pl"
	if $_[2] > 23 || $_[2] < 0;
    croak "Minute out of range 0..59 in timelocal.pl"
	if $_[1] > 59 || $_[1] < 0;
    croak "Second out of range 0..59 in timelocal.pl"
	if $_[0] > 59 || $_[0] < 0;
d108 1
a108 1
    $year += $YearFix if $year < $epoch[5];
d110 1
d112 2
a113 1
	$guess += $diff * (363 * $DAYS);
d121 2
a122 1
	$guess += $diff * (27 * $DAYS);
d134 1
a134 1
    $guess -= $g[0] * $SEC + $g[1] * $MIN + $g[2] * $HR + $g[3] * $DAYS;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d11 1
a11 1
Time::Local - efficiently compute time from local and GMT time
d20 10
a29 12
These routines are quite efficient and yet are always guaranteed to
agree with localtime() and gmtime(), the most notable points being
that year is year-1900 and month is 0..11.  We manage this by caching
the start times of any months we've seen before.  If we know the start
time of the month, we can always calculate any time within the month.
The start times themselves are guessed by successive approximation
starting at the current time, since most dates seen in practice are
close to the current date.  Unlike algorithms that do a binary search
(calling gmtime once for each bit of the time value, resulting in 32
calls), this algorithm calls it at most 6 times, and usually only once
or twice.  If you hit the month cache, of course, it doesn't call it
at all.
d42 6
a47 8
BEGIN {
    $SEC  = 1;
    $MIN  = 60 * $SEC;
    $HR   = 60 * $MIN;
    $DAY  = 24 * $HR;
    $epoch = (localtime(2*$DAY))[5];	# Allow for bugs near localtime == 0.

    $YearFix = ((gmtime(946684800))[5] == 100) ? 100 : 0;
d49 5
a53 1
}
d58 2
a59 2
    return -1 if $cheat<0 and $^O ne 'VMS';
    $cheat + $_[0] * $SEC + $_[1] * $MIN + $_[2] * $HR + ($_[3]-1) * $DAY;
d63 3
a65 31
    my $t = &timegm;
    my $tt = $t;

    my (@@lt) = localtime($t);
    my (@@gt) = gmtime($t);
    if ($t < $DAY and ($lt[5] >= 70 or $gt[5] >= 70 )) {
      # Wrap error, too early a date
      # Try a safer date
      $tt = $DAY;
      @@lt = localtime($tt);
      @@gt = gmtime($tt);
    }

    my $tzsec = ($gt[1] - $lt[1]) * $MIN + ($gt[2] - $lt[2]) * $HR;

    my($lday,$gday) = ($lt[7],$gt[7]);
    if($lt[5] > $gt[5]) {
	$tzsec -= $DAY;
    }
    elsif($gt[5] > $lt[5]) {
	$tzsec += $DAY;
    }
    else {
	$tzsec += ($gt[7] - $lt[7]) * $DAY;
    }

    $tzsec += $HR if($lt[8]);
    
    $time = $t + $tzsec;
    return -1 if $cheat<0 and $^O ne 'VMS';
    @@test = localtime($time + ($tt - $t));
a71 2
    $year -= 1900
    	if $year > 1900;
d73 10
a82 5
    croak "Month '$month' out of range 0..11"	if $month > 11 || $month < 0;
    croak "Day '$_[3]' out of range 1..31"	if $_[3] > 31 || $_[3] < 1;
    croak "Hour '$_[2]' out of range 0..23"	if $_[2] > 23 || $_[2] < 0;
    croak "Minute '$_[1]' out of range 0..59"	if $_[1] > 59 || $_[1] < 0;
    croak "Second '$_[0]' out of range 0..59"	if $_[0] > 59 || $_[0] < 0;
d85 1
a85 1
    $year += $YearFix if $year < $epoch;
a86 1
    $counter = 0;
d88 1
a88 2
	croak "Can't handle date (".join(", ",@@_).")" if ++$counter > 255;
	$guess += $diff * (363 * $DAY);
d96 1
a96 2
	croak "Can't handle date (".join(", ",@@_).")" if ++$counter > 255;
	$guess += $diff * (27 * $DAY);
d108 1
a108 1
    $guess -= $g[0] * $SEC + $g[1] * $MIN + $g[2] * $HR + $g[3] * $DAY;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d6 2
a7 3
@@ISA		= qw( Exporter );
@@EXPORT		= qw( timegm timelocal );
@@EXPORT_OK	= qw( timegm_nocheck timelocal_nocheck );
d9 36
a44 1
# Set up constants
d49 1
a49 5
# Determine breakpoint for rolling century
    my $thisYear = (localtime())[5];
    $nextCentury = int($thisYear / 100) * 100;
    $breakpoint = ($thisYear + 50) % 100;
    $nextCentury += 100 if $breakpoint < 50;
d51 1
a51 1
my %options;
a52 16
sub timegm {
    my (@@date) = @@_;
    if ($date[5] > 999) {
        $date[5] -= 1900;
    }
    elsif ($date[5] >= 0 && $date[5] < 100) {
        $date[5] -= 100 if $date[5] > $breakpoint;
        $date[5] += $nextCentury;
    }
    $ym = pack(C2, @@date[5,4]);
    $cheat = $cheat{$ym} || &cheat(@@date);
    $cheat
    + $date[0] * $SEC
    + $date[1] * $MIN
    + $date[2] * $HR
    + ($date[3]-1) * $DAY;
d55 5
a59 3
sub timegm_nocheck {
    local $options{no_range_check} = 1;
    &timegm;
d69 5
a73 5
	# Wrap error, too early a date
	# Try a safer date
	$tt += $DAY;
	@@lt = localtime($tt);
	@@gt = gmtime($tt);
d78 1
d92 1
a97 5
sub timelocal_nocheck {
    local $options{no_range_check} = 1;
    &timelocal;
}

d100 2
d103 5
a107 7
    unless ($options{no_range_check}) {
	croak "Month '$month' out of range 0..11" if $month > 11 || $month < 0;
	croak "Day '$_[3]' out of range 1..31"	  if $_[3] > 31 || $_[3] < 1;
	croak "Hour '$_[2]' out of range 0..23"	  if $_[2] > 23 || $_[2] < 0;
	croak "Minute '$_[1]' out of range 0..59" if $_[1] > 59 || $_[1] < 0;
	croak "Second '$_[0]' out of range 0..59" if $_[0] > 59 || $_[0] < 0;
    }
d110 1
d118 1
a118 2
	    croak "Can't handle date (".join(", ",@@_).")";
	    #date beyond this machine's integer limit
d127 1
a127 2
	    croak "Can't handle date (".join(", ",@@_).")";
	    #date beyond this machine's integer limit
d133 1
a133 2
        croak "Can't handle date (".join(", ",@@_).")";
        #date beyond this machine's integer limit
a140 117

__END__

=head1 NAME

Time::Local - efficiently compute time from local and GMT time

=head1 SYNOPSIS

    $time = timelocal($sec,$min,$hours,$mday,$mon,$year);
    $time = timegm($sec,$min,$hours,$mday,$mon,$year);

=head1 DESCRIPTION

These routines are the inverse of built-in perl fuctions localtime()
and gmtime().  They accept a date as a six-element array, and return
the corresponding time(2) value in seconds since the Epoch (Midnight,
January 1, 1970).  This value can be positive or negative.

It is worth drawing particular attention to the expected ranges for
the values provided.  While the day of the month is expected to be in
the range 1..31, the month should be in the range 0..11.  
This is consistent with the values returned from localtime() and gmtime().

The timelocal() and timegm() functions perform range checking on the
input $sec, $min, $hours, $mday, and $mon values by default.  If you'd
rather they didn't, you can explicitly import the timelocal_nocheck()
and timegm_nocheck() functions.

	use Time::Local 'timelocal_nocheck';

	{
	    # The 365th day of 1999
	    print scalar localtime timelocal_nocheck 0,0,0,365,0,99;

	    # The twenty thousandth day since 1970
	    print scalar localtime timelocal_nocheck 0,0,0,20000,0,70;

	    # And even the 10,000,000th second since 1999!
	    print scalar localtime timelocal_nocheck 10000000,0,0,1,0,99;
	}

Your mileage may vary when trying these with minutes and hours,
and it doesn't work at all for months.

Strictly speaking, the year should also be specified in a form consistent
with localtime(), i.e. the offset from 1900.
In order to make the interpretation of the year easier for humans,
however, who are more accustomed to seeing years as two-digit or four-digit
values, the following conventions are followed:

=over 4

=item *

Years greater than 999 are interpreted as being the actual year,
rather than the offset from 1900.  Thus, 1963 would indicate the year
Martin Luther King won the Nobel prize, not the year 2863.

=item *

Years in the range 100..999 are interpreted as offset from 1900, 
so that 112 indicates 2012.  This rule also applies to years less than zero
(but see note below regarding date range).

=item *

Years in the range 0..99 are interpreted as shorthand for years in the
rolling "current century," defined as 50 years on either side of the current
year.  Thus, today, in 1999, 0 would refer to 2000, and 45 to 2045,
but 55 would refer to 1955.  Twenty years from now, 55 would instead refer
to 2055.  This is messy, but matches the way people currently think about
two digit dates.  Whenever possible, use an absolute four digit year instead.

=back

The scheme above allows interpretation of a wide range of dates, particularly
if 4-digit years are used.  

Please note, however, that the range of dates that can be actually be handled
depends on the size of an integer (time_t) on a given platform.  
Currently, this is 32 bits for most systems, yielding an approximate range 
from Dec 1901 to Jan 2038.

Both timelocal() and timegm() croak if given dates outside the supported
range.

=head1 IMPLEMENTATION

These routines are quite efficient and yet are always guaranteed to agree
with localtime() and gmtime().  We manage this by caching the start times
of any months we've seen before.  If we know the start time of the month,
we can always calculate any time within the month.  The start times
themselves are guessed by successive approximation starting at the
current time, since most dates seen in practice are close to the
current date.  Unlike algorithms that do a binary search (calling gmtime
once for each bit of the time value, resulting in 32 calls), this algorithm
calls it at most 6 times, and usually only once or twice.  If you hit
the month cache, of course, it doesn't call it at all.

timelocal() is implemented using the same cache.  We just assume that we're
translating a GMT time, and then fudge it when we're done for the timezone
and daylight savings arguments.  Note that the timezone is evaluated for
each date because countries occasionally change their official timezones.
Assuming that localtime() corrects for these changes, this routine will
also be correct.  The daylight savings offset is currently assumed 
to be one hour.

=head1 BUGS

The whole scheme for interpreting two-digit years can be considered a bug.

Note that the cache currently handles only years from 1900 through 2155.

The proclivity to croak() is probably a bug.

=cut
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d2 1
a2 1
use 5.006;
a4 10
use Config;
use strict;
use integer;

our $VERSION    = '1.04';
our @@ISA	= qw( Exporter );
our @@EXPORT	= qw( timegm timelocal );
our @@EXPORT_OK	= qw( timegm_nocheck timelocal_nocheck );

my @@MonthDays = (31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31);
d6 9
d16 4
a19 21
my $ThisYear     = (localtime())[5];
my $Breakpoint   = ($ThisYear + 50) % 100;
my $NextCentury  = $ThisYear - $ThisYear % 100;
   $NextCentury += 100 if $Breakpoint < 50;
my $Century      = $NextCentury - 100;
my $SecOff       = 0;

my (%Options, %Cheat);

my $MaxInt = ((1<<(8 * $Config{intsize} - 2))-1)*2 + 1;
my $MaxDay = int(($MaxInt-43200)/86400)-1;

# Determine the EPOC day for this machine
my $Epoc = 0;
if ($^O eq 'vos') {
# work around posix-977 -- VOS doesn't handle dates in
# the range 1970-1980.
  $Epoc = _daygm((0, 0, 0, 1, 0, 70, 4, 0));
}
elsif ($^O eq 'MacOS') {
  no integer;
d21 1
a21 10
  $MaxDay *=2 if $^O eq 'MacOS';  # time_t unsigned ... quick hack?
  # MacOS time() is seconds since 1 Jan 1904, localtime
  # so we need to calculate an offset to apply later
  $Epoc = 693901;
  $SecOff = timelocal(localtime(0)) - timelocal(gmtime(0));
  $Epoc += _daygm(gmtime(0));
}
else {
  $Epoc = _daygm(gmtime(0));
}
d23 16
a38 8
%Cheat=(); # clear the cache as epoc has changed

sub _daygm {
    $_[3] + ($Cheat{pack("ss",@@_[4,5])} ||= do {
	my $month = ($_[4] + 10) % 12;
	my $year = $_[5] + 1900 - $month/10;
	365*$year + $year/4 - $year/100 + $year/400 + ($month*306 + 5)/10 - $Epoc
    });
d41 3
a43 7

sub _timegm {
    my $sec = $SecOff + $_[0]  +  60 * $_[1]  +  3600 * $_[2];

    no integer;

    $sec +  86400 * &_daygm;
d46 3
d50 8
a57 8
sub timegm {
    my ($sec,$min,$hour,$mday,$month,$year) = @@_;

    if ($year >= 1000) {
	$year -= 1900;
    }
    elsif ($year < 100 and $year >= 0) {
	$year += ($year > $Breakpoint) ? $Century : $NextCentury;
d60 1
a60 5
    unless ($Options{no_range_check}) {
	if (abs($year) >= 0x7fff) {
	    $year += 1900;
	    croak "Cannot handle date ($sec, $min, $hour, $mday, $month, $year)";
	}
d62 5
a66 9
	croak "Month '$month' out of range 0..11" if $month > 11 or $month < 0;

	my $md = $MonthDays[$month];
	++$md unless $month != 1 or $year % 4 or !($year % 400);

	croak "Day '$mday' out of range 1..$md"   if $mday  > $md  or $mday  < 1;
	croak "Hour '$hour' out of range 0..23"   if $hour  > 23   or $hour  < 0;
	croak "Minute '$min' out of range 0..59"  if $min   > 59   or $min   < 0;
	croak "Second '$sec' out of range 0..59"  if $sec   > 59   or $sec   < 0;
d68 2
a69 6

    my $days = _daygm(undef, undef, undef, $mday, $month, $year);

    unless ($Options{no_range_check} or abs($days) < $MaxDay) {
	$year += 1900;
	croak "Cannot handle date ($sec, $min, $hour, $mday, $month, $year)";
d72 6
a77 5
    $sec += $SecOff + 60*$min + 3600*$hour;

    no integer;

    $sec + 86400*$days;
d80 3
a82 4

sub timegm_nocheck {
    local $Options{no_range_check} = 1;
    &timegm;
d85 42
a126 25

sub timelocal {
    no integer;
    my $ref_t = &timegm;
    my $loc_t = _timegm(localtime($ref_t));

    # Is there a timezone offset from GMT or are we done
    my $zone_off = $ref_t - $loc_t
	or return $loc_t;

    # Adjust for timezone
    $loc_t = $ref_t + $zone_off;

    # Are we close to a DST change or are we done
    my $dst_off = $ref_t - _timegm(localtime($loc_t))
	or return $loc_t;

    # Adjust for DST change
    $loc_t + $dst_off;
}


sub timelocal_nocheck {
    local $Options{no_range_check} = 1;
    &timelocal;
d139 2
a140 2
    $time = timelocal($sec,$min,$hour,$mday,$mon,$year);
    $time = timegm($sec,$min,$hour,$mday,$mon,$year);
d144 1
a144 1
These routines are the inverse of built-in perl functions localtime()
d150 2
a151 2
the values provided.  The value for the day of the month is the actual day
(ie 1..31), while the month is the number of months since January (0..11).
d155 1
a155 1
input $sec, $min, $hour, $mday, and $mon values by default.  If you'd
d223 6
a228 2
are calculated using a mathematical formula. Unlike other algorithms
that do multiple calls to gmtime().
d235 2
a236 1
also be correct.
d242 2
a246 1

@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d2 1
a2 1

d9 4
a12 5
use vars qw( $VERSION @@ISA @@EXPORT @@EXPORT_OK );
$VERSION    = '1.07';
@@ISA	= qw( Exporter );
@@EXPORT	= qw( timegm timelocal );
@@EXPORT_OK	= qw( timegm_nocheck timelocal_nocheck );
d135 1
a135 12
    $loc_t += $dst_off;

    # for a negative offset from GMT, and if the original date
    # was a non-extent gap in a forward DST jump, we should
    # now have the wrong answer - undo the DST adjust;

    return $loc_t if $zone_off <= 0;

    my ($s,$m,$h) = localtime($loc_t);
    $loc_t -= $dst_off if $s != $_[0] || $m != $_[1] || $h != $_[2];

    $loc_t;
d161 2
a162 5
the corresponding time(2) value in seconds since the system epoch
(Midnight, January 1, 1970 UTC on Unix, for example).  This value can
be positive or negative, though POSIX only requires support for
positive values, so dates before the system's epoch may not work on
all operating systems.
a252 19

=head1 SUPPORT

Support for this module is provided via the perl5-porters@@perl.org
email list.  See http://lists.perl.org/ for more details.

Please submit bugs using the RT system at bugs.perl.org, the perlbug
script, or as a last resort, to the perl5-porters@@perl.org list.

=head1 AUTHOR

This module is based on a Perl 4 library, timelocal.pl, that was
included with Perl 4.036, and was most likely written by Tom
Christiansen.

The current version was written by Graham Barr.

It is now being maintained separately from the Perl core by Dave
Rolsky, <autarch@@urth.org>.
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d10 1
a10 2
$VERSION    = '1.10';
$VERSION    = eval $VERSION;
d25 1
a25 2
my (%Options, %Cheat, %Min, %Max);
my ($MinInt, $MaxInt);
d27 2
a28 14
if ($^O eq 'MacOS') {
    # time_t is unsigned...
    $MaxInt = (1 << (8 * $Config{intsize})) - 1;
    $MinInt = 0;
} else {
    $MaxInt = ((1 << (8 * $Config{intsize} - 2))-1)*2 + 1;
    $MinInt = -$MaxInt - 1;
}

$Max{Day} = ($MaxInt >> 1) / 43200;
$Min{Day} = ($MinInt)? -($Max{Day}+1) : 0;

$Max{Sec} =  $MaxInt - 86400 * $Max{Day};
$Min{Sec} =  $MinInt - 86400 * $Min{Day};
d40 1
a70 11
sub _zoneadjust {
    my ($day, $sec, $time) = @@_;

    $sec = $sec + _timegm(localtime($time)) - $time;
    if ($sec >= 86400) { $day++; $sec -= 86400; }
    if ($sec <  0)     { $day--; $sec += 86400; }

    ($day, $sec);
}


d84 1
a84 1
	    croak "Cannot handle date ($sec, $min, $hour, $mday, $month, *$year*)";
a98 1
    my $xsec = $sec + $SecOff + 60*$min + 3600*$hour;
d100 1
a100 8
    unless ($Options{no_range_check}
        or  ($days > $Min{Day} or $days == $Min{Day} and $xsec >= $Min{Sec})
       and  ($days < $Max{Day} or $days == $Max{Day} and $xsec <= $Max{Sec}))
    {
        warn "Day too small - $days > $Min{Day}\n" if $days < $Min{Day};
        warn "Day too big - $days > $Max{Day}\n" if $days > $Max{Day};
        warn "Sec too small - $days < $Min{Sec}\n" if $days < $Min{Sec};
        warn "Sec too big - $days > $Max{Sec}\n" if $days > $Max{Sec};
d105 2
d109 1
a109 1
    $xsec + 86400 * $days;
d120 1
a120 3
    # Adjust Max/Min allowed times to fit local time zone and call timegm
    local ($Max{Day}, $Max{Sec}) = _zoneadjust($Max{Day}, $Max{Sec}, $MaxInt);
    local ($Min{Day}, $Min{Sec}) = _zoneadjust($Min{Day}, $Min{Sec}, $MinInt);
d122 1
a122 4

    # Calculate first guess with a one-day delta to avoid localtime overflow
    my $delta = ($_[5] < 100)? 86400 : -86400;
    my $loc_t = _timegm(localtime( $ref_t + $delta )) - $delta;
a127 4
    # This hack is needed to always pick the first matching time
    # during a DST change when time would otherwise be ambiguous
    $zone_off -= 3600 if ($delta > 0 && $ref_t >= 3600);

a137 2
    return $loc_t if $dst_off >= 0;

d142 2
d174 1
a174 1
(Midnight, January 1, 1970 GMT on Unix, for example).  This value can
d217 1
a217 1
Martin Luther King won the Nobel prize, not the year 3863.
a246 33
=head2 Ambiguous Local Times (DST)

Because of DST changes, there are many time zones where the same local
time occurs for two different GMT times on the same day.  For example,
in the "Europe/Paris" time zone, the local time of 2001-10-28 02:30:00
can represent either 2001-10-28 00:30:00 GMT, B<or> 2001-10-28
01:30:00 GMT.

When given an ambiguous local time, the timelocal() function should
always return the epoch for the I<earlier> of the two possible GMT
times.

=head2 Non-Existent Local Times (DST)

When a DST change causes a locale clock to skip one hour forward,
there will be an hour's worth of local times that don't exist.  Again,
for the "Europe/Paris" time zone, the local clock jumped from
2001-03-25 01:59:59 to 2001-03-25 03:00:00.

If the timelocal() function is given a non-existent local time, it
will simply return an epoch value for the time one hour later.

=head2 Negative Epoch Values

Negative epoch (time_t) values are not officially supported by the
POSIX standards, so this module's tests do not test them.  On some
systems, they are known not to work.  These include MacOS (pre-OSX)
and Win32.

On systems which do support negative epoch values, this module should
be able to cope with dates before the start of the epoch, down the
minimum value of time_t for the system.

d267 2
d271 1
a271 1
Support for this module is provided via the datetime@@perl.org
d274 2
a275 2
Please submit bugs using the RT system at rt.cpan.org, or as a last
resort, to the datetime@@perl.org list.
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d10 1
a10 1
$VERSION    = '1.11';
a35 5

    # On Win32 (and others?) time_t appears to be signed, but negative
    # epochs still don't work. - XXX - this is experimental
    $MinInt = 0
        unless defined ((localtime(-1))[0]);
d39 1
a39 1
$Min{Day} = $MinInt ? -($Max{Day} + 1) : 0;
d41 2
a42 2
$Max{Sec} = $MaxInt - 86400 * $Max{Day};
$Min{Sec} = $MinInt - 86400 * $Min{Day};
a113 2
#        ++$md if $month == 1 and $year % 4 == 0 and
#            ($year % 100 != 0 or ($year + 1900) % 400 == 0);
d255 2
a256 2
rather than the offset from 1900.  Thus, 1964 would indicate the year
Martin Luther King won the Nobel prize, not the year 3864.
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d10 5
a14 1
$VERSION   = '1.18';
d16 1
a16 5
@@ISA       = qw( Exporter );
@@EXPORT    = qw( timegm timelocal );
@@EXPORT_OK = qw( timegm_nocheck timelocal_nocheck );

my @@MonthDays = ( 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );
d19 6
a24 12
my $ThisYear    = ( localtime() )[5];
my $Breakpoint  = ( $ThisYear + 50 ) % 100;
my $NextCentury = $ThisYear - $ThisYear % 100;
$NextCentury += 100 if $Breakpoint < 50;
my $Century = $NextCentury - 100;
my $SecOff  = 0;

my ( %Options, %Cheat );

use constant SECS_PER_MINUTE => 60;
use constant SECS_PER_HOUR   => 3600;
use constant SECS_PER_DAY    => 86400;
d26 2
a27 2
my $MaxInt = ( ( 1 << ( 8 * $Config{intsize} - 2 ) ) -1 ) * 2 + 1;
my $MaxDay = int( ( $MaxInt - ( SECS_PER_DAY / 2 ) ) / SECS_PER_DAY ) - 1;
d29 1
a29 1
if ( $^O eq 'MacOS' ) {
d31 10
a40 4
    $MaxInt = ( 1 << ( 8 * $Config{intsize} ) ) - 1;
}
else {
    $MaxInt = ( ( 1 << ( 8 * $Config{intsize} - 2 ) ) - 1 ) * 2 + 1;
d42 6
d51 13
a63 12
if ( $^O eq 'vos' ) {
    # work around posix-977 -- VOS doesn't handle dates in the range
    # 1970-1980.
    $Epoc = _daygm( 0, 0, 0, 1, 0, 70, 4, 0 );
}
elsif ( $^O eq 'MacOS' ) {
    $MaxDay *=2 if $^O eq 'MacOS';  # time_t unsigned ... quick hack?
    # MacOS time() is seconds since 1 Jan 1904, localtime
    # so we need to calculate an offset to apply later
    $Epoc = 693901;
    $SecOff = timelocal( localtime(0)) - timelocal( gmtime(0) ) ;
    $Epoc += _daygm( gmtime(0) );
d66 1
a66 1
    $Epoc = _daygm( gmtime(0) );
d69 1
a69 1
%Cheat = ();    # clear the cache as epoc has changed
d72 6
d79 7
a85 16
    # This is written in such a byzantine way in order to avoid
    # lexical variables and sub calls, for speed
    return $_[3] + (
        $Cheat{ pack( 'ss', @@_[ 4, 5 ] ) } ||= do {
            my $month = ( $_[4] + 10 ) % 12;
            my $year  = $_[5] + 1900 - $month / 10;

            ( ( 365 * $year )
              + ( $year / 4 )
              - ( $year / 100 )
              + ( $year / 400 )
              + ( ( ( $month * 306 ) + 5 ) / 10 )
            )
            - $Epoc;
        }
    );
a87 3
sub _timegm {
    my $sec =
        $SecOff + $_[0] + ( SECS_PER_MINUTE * $_[1] ) + ( SECS_PER_HOUR * $_[2] );
d89 8
a96 1
    return $sec + ( SECS_PER_DAY * &_daygm );
d99 1
d101 1
a101 1
    my ( $sec, $min, $hour, $mday, $month, $year ) = @@_;
d103 2
a104 2
    if ( $year >= 1000 ) {
        $year -= 1900;
d106 2
a107 2
    elsif ( $year < 100 and $year >= 0 ) {
        $year += ( $year > $Breakpoint ) ? $Century : $NextCentury;
d110 7
a116 10
    unless ( $Options{no_range_check} ) {
        if ( abs($year) >= 0x7fff ) {
            $year += 1900;
            croak
                "Cannot handle date ($sec, $min, $hour, $mday, $month, *$year*)";
        }

        croak "Month '$month' out of range 0..11"
            if $month > 11
            or $month < 0;
d119 8
a126 7
        ++$md
            if $month == 1 && _is_leap_year( $year + 1900 );

        croak "Day '$mday' out of range 1..$md"  if $mday > $md or $mday < 1;
        croak "Hour '$hour' out of range 0..23"  if $hour > 23  or $hour < 0;
        croak "Minute '$min' out of range 0..59" if $min > 59   or $min < 0;
        croak "Second '$sec' out of range 0..59" if $sec > 59   or $sec < 0;
d129 2
a130 5
    my $days = _daygm( undef, undef, undef, $mday, $month, $year );

    unless ($Options{no_range_check} or abs($days) < $MaxDay) {
        my $msg = '';
        $msg .= "Day too big - $days > $MaxDay\n" if $days > $MaxDay;
d132 8
d141 2
a142 1
        $msg .=  "Cannot handle date ($sec, $min, $hour, $mday, $month, $year)";
d144 1
a144 2
	croak $msg;
    }
d146 1
a146 5
    return $sec
           + $SecOff
           + ( SECS_PER_MINUTE * $min )
           + ( SECS_PER_HOUR * $hour )
           + ( SECS_PER_DAY * $days );
a148 7
sub _is_leap_year {
    return 0 if $_[0] % 4;
    return 1 if $_[0] % 100;
    return 0 if $_[0] % 400;

    return 1;
}
d152 1
a152 1
    return &timegm;
d155 1
d157 3
a160 1
    my $loc_for_ref_t = _timegm( localtime($ref_t) );
d162 11
a172 2
    my $zone_off = $loc_for_ref_t - $ref_t
        or return $loc_for_ref_t;
d175 1
a175 1
    my $loc_t = $ref_t - $zone_off;
d178 2
a179 10
    my $dst_off = $ref_t - _timegm( localtime($loc_t) );

    # If this evaluates to true, it means that the value in $loc_t is
    # the _second_ hour after a DST change where the local time moves
    # backward.
    if ( ! $dst_off &&
         ( ( $ref_t - SECS_PER_HOUR ) - _timegm( localtime( $loc_t - SECS_PER_HOUR ) ) < 0 )
       ) {
        return $loc_t - SECS_PER_HOUR;
    }
d184 1
a184 1
    return $loc_t if $dst_off > 0;
d186 5
a190 3
    # If the original date was a non-extent gap in a forward DST jump,
    # we should now have the wrong answer - undo the DST adjustment
    my ( $s, $m, $h ) = localtime($loc_t);
d193 1
a193 1
    return $loc_t;
d196 1
d199 1
a199 1
    return &timelocal;
d217 7
a223 7
This module provides functions that are the inverse of built-in perl
functions C<localtime()> and C<gmtime()>. They accept a date as a
six-element array, and return the corresponding C<time(2)> value in
seconds since the system epoch (Midnight, January 1, 1970 GMT on Unix,
for example). This value can be positive or negative, though POSIX
only requires support for positive values, so dates before the
system's epoch may not work on all operating systems.
d226 30
a255 36
the values provided. The value for the day of the month is the actual
day (ie 1..31), while the month is the number of months since January
(0..11). This is consistent with the values returned from
C<localtime()> and C<gmtime()>.

=head1 FUNCTIONS

=head2 C<timelocal()> and C<timegm()>

This module exports two functions by default, C<timelocal()> and
C<timegm()>.

The C<timelocal()> and C<timegm()> functions perform range checking on
the input $sec, $min, $hour, $mday, and $mon values by default.

=head2 C<timelocal_nocheck()> and C<timegm_nocheck()>

If you are working with data you know to be valid, you can speed your
code up by using the "nocheck" variants, C<timelocal_nocheck()> and
C<timegm_nocheck()>. These variants must be explicitly imported.

    use Time::Local 'timelocal_nocheck';

    # The 365th day of 1999
    print scalar localtime timelocal_nocheck 0,0,0,365,0,99;

If you supply data which is not valid (month 27, second 1,000) the
results will be unpredictable (so don't do that).

=head2 Year Value Interpretation

Strictly speaking, the year should be specified in a form consistent
with C<localtime()>, i.e. the offset from 1900. In order to make the
interpretation of the year easier for humans, however, who are more
accustomed to seeing years as two-digit or four-digit values, the
following conventions are followed:
d262 1
a262 1
rather than the offset from 1900. Thus, 1964 would indicate the year
d267 3
a269 3
Years in the range 100..999 are interpreted as offset from 1900, so
that 112 indicates 2012. This rule also applies to years less than
zero (but see note below regarding date range).
d274 5
a278 6
rolling "current century," defined as 50 years on either side of the
current year. Thus, today, in 1999, 0 would refer to 2000, and 45 to
2045, but 55 would refer to 1955. Twenty years from now, 55 would
instead refer to 2055. This is messy, but matches the way people
currently think about two digit dates. Whenever possible, use an
absolute four digit year instead.
d282 2
a283 2
The scheme above allows interpretation of a wide range of dates,
particularly if 4-digit years are used.
d285 4
a288 1
=head2 Limits of time_t
d290 2
a291 7
The range of dates that can be actually be handled depends on the size
of C<time_t> (usually a signed integer) on the given
platform. Currently, this is 32 bits for most systems, yielding an
approximate range from Dec 1901 to Jan 2038.

Both C<timelocal()> and C<timegm()> croak if given dates outside the
supported range.
d296 1
a296 1
time occurs for two different GMT times on the same day. For example,
d308 1
a308 1
there will be an hour's worth of local times that don't exist. Again,
d312 1
a312 1
If the C<timelocal()> function is given a non-existent local time, it
d317 4
a320 4
Negative epoch (C<time_t>) values are not officially supported by the
POSIX standards, so this module's tests do not test them. On some
systems, they are known not to work. These include MacOS (pre-OSX) and
Win32.
d328 13
a340 13
These routines are quite efficient and yet are always guaranteed to
agree with C<localtime()> and C<gmtime()>. We manage this by caching
the start times of any months we've seen before. If we know the start
time of the month, we can always calculate any time within the month.
The start times are calculated using a mathematical formula. Unlike
other algorithms that do multiple calls to C<gmtime()>.

The C<timelocal()> function is implemented using the same cache. We
just assume that we're translating a GMT time, and then fudge it when
we're done for the timezone and daylight savings arguments. Note that
the timezone is evaluated for each date because countries occasionally
change their official timezones. Assuming that C<localtime()> corrects
for these changes, this routine will also be correct.
d344 1
a344 2
The whole scheme for interpreting two-digit years can be considered a
bug.
d348 2
a349 8
Support for this module is provided via the datetime@@perl.org email
list. See http://lists.perl.org/ for more details.

Please submit bugs to the CPAN RT system at
http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Time-Local or via email
at bug-time-local@@rt.cpan.org.

=head1 COPYRIGHT
d351 2
a352 6
Copyright (c) 1997-2003 Graham Barr, 2003-2007 David Rolsky.  All
rights reserved.  This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

The full text of the license can be found in the LICENSE file included
with this module.
d366 1
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d10 1
a10 1
$VERSION   = '1.1901';
d32 3
a34 1
my $MaxInt;
d37 1
a37 1
    $MaxInt = ( 1 << ( 8 * $Config{ivsize} ) ) - 1;
d40 1
a40 1
    $MaxInt = ( ( 1 << ( 8 * $Config{ivsize} - 2 ) ) - 1 ) * 2 + 1;
a42 2
my $MaxDay = int( ( $MaxInt - ( SECS_PER_DAY / 2 ) ) / SECS_PER_DAY ) - 1;

d71 1
a71 1
            my $year  = ( $_[5] + 1900 ) - ( $month / 10 );
d102 6
@


