head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.55;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.02;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.47.30;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.49.02;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.44;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.59;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

use Time::Local;

# Set up time values to test
@@time =
  (
   #year,mon,day,hour,min,sec 
   [1970,  1,  2, 00, 00, 00],
   [1980,  2, 28, 12, 00, 00],
   [1980,  2, 29, 12, 00, 00],
   [1999, 12, 31, 23, 59, 59],
   [2000,  1,  1, 00, 00, 00],
   [2010, 10, 12, 14, 13, 12],
   [2020,  2, 29, 12, 59, 59],
   [2030,  7,  4, 17, 07, 06],
# The following test fails on a surprising number of systems
# so it is commented out. The end of the Epoch for a 32-bit signed
# implementation of time_t should be Jan 19, 2038  03:14:07 UTC.
#  [2038,  1, 17, 23, 59, 59],     # last full day in any tz
  );

# use vmsish 'time' makes for oddness around the Unix epoch
if ($^O eq 'VMS') { $time[0][2]++ }

print "1..", @@time * 2 + 5, "\n";

$count = 1;
for (@@time) {
    my($year, $mon, $mday, $hour, $min, $sec) = @@$_;
    $year -= 1900;
    $mon --;
    if ($^O eq 'vos' && $count == 1) {
     print "ok $count -- skipping 1970 test on VOS.\n";
    } else {
     my $time = timelocal($sec,$min,$hour,$mday,$mon,$year);
     # print scalar(localtime($time)), "\n";
     my($s,$m,$h,$D,$M,$Y) = localtime($time);

     if ($s == $sec &&
	 $m == $min &&
	 $h == $hour &&
	 $D == $mday &&
	 $M == $mon &&
	 $Y == $year
        ) {
	 print "ok $count\n";
     } else {
      print "not ok $count\n";
     }
    }
    $count++;

    # Test gmtime function
    if ($^O eq 'vos' && $count == 2) {
        print "ok $count -- skipping 1970 test on VOS.\n";
    } else {
     $time = timegm($sec,$min,$hour,$mday,$mon,$year);
     ($s,$m,$h,$D,$M,$Y) = gmtime($time);

     if ($s == $sec &&
	 $m == $min &&
	 $h == $hour &&
	 $D == $mday &&
	 $M == $mon &&
	 $Y == $year
        ) {
	 print "ok $count\n";
     } else {
      print "not ok $count\n";
     }
    }
    $count++;
}

#print "Testing that the differences between a few dates makes sense...\n";

timelocal(0,0,1,1,0,90) - timelocal(0,0,0,1,0,90) == 3600
  or print "not ";
print "ok ", $count++, "\n";

timelocal(1,2,3,1,0,100) - timelocal(1,2,3,31,11,99) == 24 * 3600 
  or print "not ";
print "ok ", $count++, "\n";

# Diff beween Jan 1, 1980 and Mar 1, 1980 = (31 + 29 = 60 days)
timegm(0,0,0, 1, 2, 80) - timegm(0,0,0, 1, 0, 80) == 60 * 24 * 3600
  or print "not ";
print "ok ", $count++, "\n";


#print "Testing timelocal.pl module too...\n";
package test;
require 'timelocal.pl';
timegm(0,0,0,1,0,80) == main::timegm(0,0,0,1,0,80) or print "not ";
print "ok ", $main::count++, "\n";

timelocal(1,2,3,4,5,88) == main::timelocal(1,2,3,4,5,88) or print "not ";
print "ok ", $main::count++, "\n";
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d4 2
a5 4
  if ($ENV{PERL_CORE}){
    chdir('t') if -d 't';
    @@INC = ('.', '../lib');
  }
d31 1
a31 4
my $tests = @@time * 2 + 4;
$tests += 2 if $ENV{PERL_CORE};

print "1..$tests\n";
a95 12
# bugid #19393
# At a DST transition, the clock skips forward, eg from 01:59:59 to
# 03:00:00. In this case, 02:00:00 is an invalid time, and should be
# treated like 03:00:00 rather than 01:00:00 - negative zone offsets used
# to do the latter
{
    my $hour = (localtime(timelocal(0, 0, 2, 7, 3, 102)))[2];
    # testers in US/Pacific should get 3,
    # other testers should get 2
    print "not " unless $hour == 2 || $hour == 3;
    print "ok ", $main::count++, "\n";
}
d97 5
a101 6
if ($ENV{PERL_CORE}) {
  #print "Testing timelocal.pl module too...\n";
  package test;
  require 'timelocal.pl';
  timegm(0,0,0,1,0,80) == main::timegm(0,0,0,1,0,80) or print "not ";
  print "ok ", $main::count++, "\n";
d103 2
a104 3
  timelocal(1,2,3,4,5,88) == main::timelocal(1,2,3,4,5,88) or print "not ";
  print "ok ", $main::count++, "\n";
}
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@a9 4
use strict;

use Config;
use Test;
d13 1
a13 1
my @@time =
d15 1
a15 1
   #year,mon,day,hour,min,sec
d33 1
a33 1
my $tests = (@@time * 12) + 6;
a34 1
$tests += 5 if $ENV{MAINTAINER};
d36 1
a36 1
plan tests => $tests;
d38 1
d42 3
a44 4
    $mon--;

    if ($^O eq 'vos' && $year == 70) {
        skip(1, "skipping 1970 test on VOS.\n") for 1..6;
d46 15
a60 10
        my $time = timelocal($sec,$min,$hour,$mday,$mon,$year);

        my($s,$m,$h,$D,$M,$Y) = localtime($time);

        ok($s, $sec, 'second');
        ok($m, $min, 'minute');
        ok($h, $hour, 'hour');
        ok($D, $mday, 'day');
        ok($M, $mon, 'month');
        ok($Y, $year, 'year');
d62 1
d64 3
a66 2
    if ($^O eq 'vos' && $year == 70) {
        skip(1, "skipping 1970 test on VOS.\n") for 1..6;
d68 2
a69 1
        my $time = timegm($sec,$min,$hour,$mday,$mon,$year);
d71 11
a81 8
        my($s,$m,$h,$D,$M,$Y) = gmtime($time);

        ok($s, $sec, 'second');
        ok($m, $min, 'minute');
        ok($h, $hour, 'hour');
        ok($D, $mday, 'day');
        ok($M, $mon, 'month');
        ok($Y, $year, 'year');
d83 1
d86 1
a86 2
ok(timelocal(0,0,1,1,0,90) - timelocal(0,0,0,1,0,90), 3600,
   'one hour difference between two calls to timelocal');
d88 7
a94 2
ok(timelocal(1,2,3,1,0,100) - timelocal(1,2,3,31,11,99), 24 * 3600,
   'one day difference between two calls to timelocal');
d97 3
a99 2
ok(timegm(0,0,0, 1, 2, 80) - timegm(0,0,0, 1, 0, 80), 60 * 24 * 3600,
   '60 day difference between two calls to timegm');
d110 2
a111 56
    ok($hour == 2 || $hour == 3, 1, 'hour should be 2 or 3');
}

# round trip was broken for edge cases
if ($^O eq "aix" && $Config{osvers} =~ m/^4\.3\./) {
    skip( 1, "No fix expected for edge case test for $_ on AIX 4.3") for qw( timegm timelocal );
} else {
    ok(sprintf('%x', timegm(gmtime(0x7fffffff))), sprintf('%x', 0x7fffffff),
       '0x7fffffff round trip through gmtime then timegm');

    ok(sprintf('%x', timelocal(localtime(0x7fffffff))), sprintf('%x', 0x7fffffff),
       '0x7fffffff round trip through localtime then timelocal');
}

if ($ENV{MAINTAINER}) {
    eval { require POSIX; POSIX::tzset() };
    if ($@@) {
        skip( 1, "Cannot call POSIX::tzset() on this platform\n" ) for 1..3;
    }
    else {
        local $ENV{TZ} = 'Europe/Vienna';
        POSIX::tzset();

        # 2001-10-28 02:30:00 - could be either summer or standard time,
        # prefer earlier of the two, in this case summer
        my $time = timelocal(0, 30, 2, 28, 9, 101);
        ok($time, 1004229000,
           'timelocal prefers earlier epoch in the presence of a DST change');

        local $ENV{TZ} = 'America/Chicago';
        POSIX::tzset();

        # Same local time in America/Chicago.  There is a transition
        # here as well.
        $time = timelocal(0, 30, 1, 28, 9, 101);
        ok($time, 1004250600,
           'timelocal prefers earlier epoch in the presence of a DST change');

        $time = timelocal(0, 30, 2, 1, 3, 101);
        ok($time, 986113800,
           'timelocal for non-existent time gives you the time one hour later');

        local $ENV{TZ} = 'Australia/Sydney';
        POSIX::tzset();

        # 2001-03-25 02:30:00 in Australia/Sydney.  This is the transition
        # _to_ summer time.  The southern hemisphere transitions are
        # opposite those of the northern.
        $time = timelocal(0, 30, 2, 25, 2, 101);
        ok($time, 985447800,
           'timelocal prefers earlier epoch in the presence of a DST change');

        $time = timelocal(0, 30, 2, 28, 9, 101);
        ok($time, 1004200200,
           'timelocal for non-existent time gives you the time one hour later');
    }
d115 1
d118 2
d121 2
a122 6
  # need to get ok() from main package
  ::ok(timegm(0,0,0,1,0,80), main::timegm(0,0,0,1,0,80),
     'timegm in timelocal.pl');

  ::ok(timelocal(1,2,3,4,5,88), main::timelocal(1,2,3,4,5,88),
     'timelocal in timelocal.pl');
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@a25 1
   # leap day
a33 26
my @@bad_time =
    (
     # month too large
     [1995, 13, 01, 01, 01, 01],
     # day too large
     [1995, 02, 30, 01, 01, 01],
     # hour too large
     [1995, 02, 10, 25, 01, 01],
     # minute too large
     [1995, 02, 10, 01, 60, 01],
     # second too large
     [1995, 02, 10, 01, 01, 60],
    );

my @@neg_time =
    (
     # test negative epochs for systems that handle it
     [ 1969, 12, 31, 16, 59, 59 ],
     [ 1950, 04, 12, 9, 30, 31 ],
    );

# Use 3 days before the start of the epoch because with Borland on
# Win32 it will work for -3600 _if_ your time zone is +01:00 (or
# greater).
my $neg_epoch_ok = defined ((localtime(-259200))[0]) ? 1 : 0;

d35 1
a35 4
if ($^O eq 'VMS') { 
    $time[0][2]++;
    $neg_epoch_ok = 0; # time_t is unsigned
}
d37 1
a37 4
my $tests = (@@time * 12);
$tests += @@neg_time * 12;
$tests += @@bad_time;
$tests += 8;
d43 1
a43 1
for (@@time, @@neg_time) {
a49 2
    } elsif ($year < 70 && ! $neg_epoch_ok) {
        skip(1, "skipping negative epoch.\n") for 1..6;
d51 1
a51 2
        my $year_in = $year < 70 ? $year + 1900 : $year;
        my $time = timelocal($sec,$min,$hour,$mday,$mon,$year_in);
d55 6
a60 6
        ok($s, $sec, 'timelocal second');
        ok($m, $min, 'timelocal minute');
        ok($h, $hour, 'timelocal hour');
        ok($D, $mday, 'timelocal day');
        ok($M, $mon, 'timelocal month');
        ok($Y, $year, 'timelocal year');
a64 2
    } elsif ($year < 70 && ! $neg_epoch_ok) {
        skip(1, "skipping negative epoch.\n") for 1..6;
d66 1
a66 2
        my $year_in = $year < 70 ? $year + 1900 : $year;
        my $time = timegm($sec,$min,$hour,$mday,$mon,$year_in);
d70 6
a75 6
        ok($s, $sec, 'timegm second');
        ok($m, $min, 'timegm minute');
        ok($h, $hour, 'timegm hour');
        ok($D, $mday, 'timegm day');
        ok($M, $mon, 'timegm month');
        ok($Y, $year, 'timegm year');
a78 10
for (@@bad_time) {
    my($year, $mon, $mday, $hour, $min, $sec) = @@$_;
    $year -= 1900;
    $mon--;

    eval { timegm($sec,$min,$hour,$mday,$mon,$year) };

    ok($@@, qr/.*out of range.*/, 'invalid time caused an error');
}

a98 10
}

if ($neg_epoch_ok) {
    eval { timegm(0,0,0,29,1,1900) };
    ok($@@, qr/Day '29' out of range 1\.\.28/);

    eval { timegm(0,0,0,29,1,1904) };
    ok($@@, '');
} else {
    skip(1, "skipping negative epoch.\n") for 1..2;
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d12 2
a13 1
use Test::More;
a55 10
# Leap year tests
my @@years =
    (
     [ 1900 => 0 ],
     [ 1947 => 0 ],
     [ 1996 => 1 ],
     [ 2000 => 1 ],
     [ 2100 => 0 ],
    );

d62 1
a62 1
if ($^O eq 'VMS') {
d70 1
a70 2
$tests += @@years;
$tests += 10;
d72 1
a72 1
$tests += 8 if $ENV{MAINTAINER};
d81 34
a114 33
 SKIP: {
        skip '1970 test on VOS fails.', 12
            if $^O eq 'vos' && $year == 70;
        skip 'this platform does not support negative epochs.', 12
            if $year < 70 && ! $neg_epoch_ok;

        {
            my $year_in = $year < 70 ? $year + 1900 : $year;
            my $time = timelocal($sec,$min,$hour,$mday,$mon,$year_in);

            my($s,$m,$h,$D,$M,$Y) = localtime($time);

            is($s, $sec, "timelocal second for @@$_");
            is($m, $min, "timelocal minute for @@$_");
            is($h, $hour, "timelocal hour for @@$_");
            is($D, $mday, "timelocal day for @@$_");
            is($M, $mon, "timelocal month for @@$_");
            is($Y, $year, "timelocal year for @@$_");
        }

        {
            my $year_in = $year < 70 ? $year + 1900 : $year;
            my $time = timegm($sec,$min,$hour,$mday,$mon,$year_in);

            my($s,$m,$h,$D,$M,$Y) = gmtime($time);

            is($s, $sec, "timegm second for @@$_");
            is($m, $min, "timegm minute for @@$_");
            is($h, $hour, "timegm hour for @@$_");
            is($D, $mday, "timegm day for @@$_");
            is($M, $mon, "timegm month for @@$_");
            is($Y, $year, "timegm year for @@$_");
        }
d125 1
a125 1
    like($@@, qr/.*out of range.*/, 'invalid time caused an error');
d128 2
a129 3
{
    is(timelocal(0,0,1,1,0,90) - timelocal(0,0,0,1,0,90), 3600,
       'one hour difference between two calls to timelocal');
d131 2
a132 2
    is(timelocal(1,2,3,1,0,100) - timelocal(1,2,3,31,11,99), 24 * 3600,
       'one day difference between two calls to timelocal');
d134 3
a136 4
    # Diff beween Jan 1, 1980 and Mar 1, 1980 = (31 + 29 = 60 days)
    is(timegm(0,0,0, 1, 2, 80) - timegm(0,0,0, 1, 0, 80), 60 * 24 * 3600,
       '60 day difference between two calls to timegm');
}
d147 1
a147 9
    ok($hour == 2 || $hour == 3, 'hour should be 2 or 3');
}

for my $p (@@years) {
    my ( $year, $is_leap_year ) = @@$p;

    my $string = $is_leap_year ? 'is' : 'is not';
    is( Time::Local::_is_leap_year($year), $is_leap_year,
        "$year $string a leap year" );
d150 1
a150 5
SKIP:
{
    skip 'this platform does not support negative epochs.', 6
        unless $neg_epoch_ok;

d152 1
a152 9
    like($@@, qr/Day '29' out of range 1\.\.28/,
         'does not accept leap day in 1900');

    eval { timegm(0,0,0,29,1,200) };
    like($@@, qr/Day '29' out of range 1\.\.28/,
         'does not accept leap day in 2100 (year passed as 200)');

    eval { timegm(0,0,0,29,1,0) };
    is($@@, '', 'no error with leap day of 2000 (year passed as 0)');
d155 4
a158 1
    is($@@, '', 'no error with leap day of 1904');
d160 6
a165 2
    eval { timegm(0,0,0,29,1,4) };
    is($@@, '', 'no error with leap day of 2004 (year passed as 4)');
d167 2
a168 2
    eval { timegm(0,0,0,29,1,96) };
    is($@@, '', 'no error with leap day of 1996 (year passed as 96)');
d172 41
a212 51
    require POSIX;

    local $ENV{TZ} = 'Europe/Vienna';
    POSIX::tzset();

    # 2001-10-28 02:30:00 - could be either summer or standard time,
    # prefer earlier of the two, in this case summer
    my $time = timelocal(0, 30, 2, 28, 9, 101);
    is($time, 1004229000,
       'timelocal prefers earlier epoch in the presence of a DST change');

    local $ENV{TZ} = 'America/Chicago';
    POSIX::tzset();

    # Same local time in America/Chicago.  There is a transition here
    # as well.
    $time = timelocal(0, 30, 1, 28, 9, 101);
    is($time, 1004250600,
       'timelocal prefers earlier epoch in the presence of a DST change');

    $time = timelocal(0, 30, 2, 1, 3, 101);
    is($time, 986113800,
       'timelocal for non-existent time gives you the time one hour later');

    local $ENV{TZ} = 'Australia/Sydney';
    POSIX::tzset();
    # 2001-03-25 02:30:00 in Australia/Sydney.  This is the transition
    # _to_ summer time.  The southern hemisphere transitions are
    # opposite those of the northern.
    $time = timelocal(0, 30, 2, 25, 2, 101);
    is($time, 985447800,
       'timelocal prefers earlier epoch in the presence of a DST change');

    $time = timelocal(0, 30, 2, 28, 9, 101);
    is($time, 1004200200,
       'timelocal for non-existent time gives you the time one hour later');

    local $ENV{TZ} = 'Europe/London';
    POSIX::tzset();
    $time = timelocal( localtime(1111917720) );
    is($time, 1111917720,
       'timelocal for round trip bug on date of DST change for Europe/London');

    # There is no 1:00 AM on this date, as it leaps forward to
    # 2:00 on the DST change - this should return 2:00 per the
    # docs.
    is( ( localtime( timelocal( 0, 0, 1, 27, 2, 2005 ) ) )[2], 2,
        'hour is 2 when given 1:00 AM on Europe/London date change' );

    is( ( localtime( timelocal( 0, 0, 2, 27, 2, 2005 ) ) )[2], 2,
        'hour is 2 when given 2:00 AM on Europe/London date change' );
d220 1
a220 1
  ::is(timegm(0,0,0,1,0,80), main::timegm(0,0,0,1,0,80),
d223 1
a223 1
  ::is(timelocal(1,2,3,4,5,88), main::timelocal(1,2,3,4,5,88),
@


1.1.1.6
log
@import perl 5.10.1
@
text
@a11 1
use Config;
a75 2
my $epoch_is_64 = eval { $Config{ivsize} == 8 && ( gmtime 2**40 )[5] == 34912 };

d80 3
a82 1
$tests += 23;
d195 1
a195 18
SKIP:
{
    skip 'These tests require a system with 64-bit time_t.', 3
        unless $epoch_is_64;

    is( timegm( 8, 14, 3, 19, 0, ( 1900 + 138 ) ), 2**31,
        'can call timegm for 2**31 epoch seconds' );
    is( timegm( 16, 28, 6, 7, 1, ( 1900 + 206 ) ), 2**32,
        'can call timegm for 2**32 epoch seconds (on a 64-bit system)' );
    is( timegm( 16, 36, 0, 20, 1, ( 34912 + 1900 ) ), 2**40,
        'can call timegm for 2**40 epoch seconds (on a 64-bit system)' );
}

SKIP:
{
    skip 'These tests only run for the package maintainer.', 8
        unless $ENV{MAINTAINER};

d249 7
a255 12
SKIP:
{
    skip 'These tests are only run when $ENV{PERL_CORE} is true.', 2
        unless $ENV{PERL_CORE};

    {
        package test;
        require 'timelocal.pl';

        # need to get ok() from main package
        ::is(timegm(0,0,0,1,0,80), main::timegm(0,0,0,1,0,80),
             'timegm in timelocal.pl');
d257 2
a258 3
        ::is(timelocal(1,2,3,4,5,88), main::timelocal(1,2,3,4,5,88),
             'timelocal in timelocal.pl');
    }
@


