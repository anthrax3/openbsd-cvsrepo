head	1.5;
access;
symbols
	OPENBSD_6_1_BASE:1.5
	OPENBSD_6_0:1.5.0.58
	OPENBSD_6_0_BASE:1.5
	OPENBSD_5_9:1.5.0.52
	OPENBSD_5_9_BASE:1.5
	OPENBSD_5_8:1.5.0.54
	OPENBSD_5_8_BASE:1.5
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.5.0.46
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.5.0.50
	OPENBSD_5_6_BASE:1.5
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.5.0.48
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.44
	OPENBSD_5_4_BASE:1.5
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.5.0.42
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.40
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.38
	OPENBSD_5_0:1.5.0.36
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.34
	OPENBSD_4_9_BASE:1.5
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.5.0.32
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.28
	OPENBSD_4_7_BASE:1.5
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2002.10.27.22.25.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.40;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.09;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.52;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.52;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.20;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@package Tie::SubstrHash;

our $VERSION = '1.00';

=head1 NAME

Tie::SubstrHash - Fixed-table-size, fixed-key-length hashing

=head1 SYNOPSIS

    require Tie::SubstrHash;

    tie %myhash, 'Tie::SubstrHash', $key_len, $value_len, $table_size;

=head1 DESCRIPTION

The B<Tie::SubstrHash> package provides a hash-table-like interface to
an array of determinate size, with constant key size and record size.

Upon tying a new hash to this package, the developer must specify the
size of the keys that will be used, the size of the value fields that the
keys will index, and the size of the overall table (in terms of key-value
pairs, not size in hard memory). I<These values will not change for the
duration of the tied hash>. The newly-allocated hash table may now have
data stored and retrieved. Efforts to store more than C<$table_size>
elements will result in a fatal error, as will efforts to store a value
not exactly C<$value_len> characters in length, or reference through a
key not exactly C<$key_len> characters in length. While these constraints
may seem excessive, the result is a hash table using much less internal
memory than an equivalent freely-allocated hash table.

=head1 CAVEATS

Because the current implementation uses the table and key sizes for the
hashing algorithm, there is no means by which to dynamically change the
value of any of the initialization parameters.

The hash does not support exists().

=cut

use Carp;

sub TIEHASH {
    my $pack = shift;
    my ($klen, $vlen, $tsize) = @@_;
    my $rlen = 1 + $klen + $vlen;
    $tsize = [$tsize,
	      findgteprime($tsize * 1.1)]; # Allow 10% empty.
    local $self = bless ["\0", $klen, $vlen, $tsize, $rlen, 0, -1];
    $$self[0] x= $rlen * $tsize->[1];
    $self;
}

sub CLEAR {
    local($self) = @@_;
    $$self[0] = "\0" x ($$self[4] * $$self[3]->[1]);
    $$self[5] =  0;
    $$self[6] = -1;
}

sub FETCH {
    local($self,$key) = @@_;
    local($klen, $vlen, $tsize, $rlen) = @@$self[1..4];
    &hashkey;
    for (;;) {
	$offset = $hash * $rlen;
	$record = substr($$self[0], $offset, $rlen);
	if (ord($record) == 0) {
	    return undef;
	}
	elsif (ord($record) == 1) {
	}
	elsif (substr($record, 1, $klen) eq $key) {
	    return substr($record, 1+$klen, $vlen);
	}
	&rehash;
    }
}

sub STORE {
    local($self,$key,$val) = @@_;
    local($klen, $vlen, $tsize, $rlen) = @@$self[1..4];
    croak("Table is full ($tsize->[0] elements)") if $$self[5] > $tsize->[0];
    croak(qq/Value "$val" is not $vlen characters long/)
	if length($val) != $vlen;
    my $writeoffset;

    &hashkey;
    for (;;) {
	$offset = $hash * $rlen;
	$record = substr($$self[0], $offset, $rlen);
	if (ord($record) == 0) {
	    $record = "\2". $key . $val;
	    die "panic" unless length($record) == $rlen;
	    $writeoffset = $offset unless defined $writeoffset;
	    substr($$self[0], $writeoffset, $rlen) = $record;
	    ++$$self[5];
	    return;
	}
	elsif (ord($record) == 1) {
	    $writeoffset = $offset unless defined $writeoffset;
	}
	elsif (substr($record, 1, $klen) eq $key) {
	    $record = "\2". $key . $val;
	    die "panic" unless length($record) == $rlen;
	    substr($$self[0], $offset, $rlen) = $record;
	    return;
	}
	&rehash;
    }
}

sub DELETE {
    local($self,$key) = @@_;
    local($klen, $vlen, $tsize, $rlen) = @@$self[1..4];
    &hashkey;
    for (;;) {
	$offset = $hash * $rlen;
	$record = substr($$self[0], $offset, $rlen);
	if (ord($record) == 0) {
	    return undef;
	}
	elsif (ord($record) == 1) {
	}
	elsif (substr($record, 1, $klen) eq $key) {
	    substr($$self[0], $offset, 1) = "\1";
	    return substr($record, 1+$klen, $vlen);
	    --$$self[5];
	}
	&rehash;
    }
}

sub FIRSTKEY {
    local($self) = @@_;
    $$self[6] = -1;
    &NEXTKEY;
}

sub NEXTKEY {
    local($self) = @@_;
    local($klen, $vlen, $tsize, $rlen, $entries, $iterix) = @@$self[1..6];
    for (++$iterix; $iterix < $tsize->[1]; ++$iterix) {
	next unless substr($$self[0], $iterix * $rlen, 1) eq "\2";
	$$self[6] = $iterix;
	return substr($$self[0], $iterix * $rlen + 1, $klen);
    }
    $$self[6] = -1;
    undef;
}

sub EXISTS {
    croak "Tie::SubstrHash does not support exists()";
}

sub hashkey {
    croak(qq/Key "$key" is not $klen characters long/)
	if length($key) != $klen;
    $hash = 2;
    for (unpack('C*', $key)) {
	$hash = $hash * 33 + $_;
	&_hashwrap if $hash >= 1e13;
    }
    &_hashwrap if $hash >= $tsize->[1];
    $hash = 1 unless $hash;
    $hashbase = $hash;
}

sub _hashwrap {
    $hash -= int($hash / $tsize->[1]) * $tsize->[1];
}

sub rehash {
    $hash += $hashbase;
    $hash -= $tsize->[1] if $hash >= $tsize->[1];
}

# using POSIX::ceil() would be too heavy, and not all platforms have it.
sub ceil {
    my $num = shift;
    $num = int($num + 1) unless $num == int $num;
    return $num;
}

# See:
#
# http://www-groups.dcs.st-andrews.ac.uk/~history/HistTopics/Prime_numbers.html
#

sub findgteprime { # find the smallest prime integer greater than or equal to
    use integer;

    my $num = ceil(shift);
    return 2 if $num <= 2;

    $num++ unless $num % 2;
    my $i;
    my $sqrtnum = int sqrt $num;
    my $sqrtnumsquared = $sqrtnum * $sqrtnum;

  NUM:
    for (;; $num += 2) {
	if ($sqrtnumsquared < $num) {
	    $sqrtnum++;
	    $sqrtnumsquared = $sqrtnum * $sqrtnum;
	}
        for ($i = 3; $i <= $sqrtnum; $i += 2) {
            next NUM unless $num % $i;
        }
        return $num;
    }
}

1;
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 2
d50 1
a50 1
    $self = bless ["\0", $klen, $vlen, $tsize, $rlen, 0, -1];
@


1.3
log
@perl5.005_03 (stock)
@
text
@d36 2
d46 2
a47 1
    $tsize = findprime($tsize * 1.1);	# Allow 10% empty.
d49 1
a49 1
    $$self[0] x= $rlen * $tsize;
d53 7
d82 2
a83 2
    croak("Table is full") if $$self[5] == $tsize;
    croak(qq/Value "$val" is not $vlen characters long./)
d142 1
a142 1
    for (++$iterix; $iterix < $tsize; ++$iterix) {
d151 4
d156 1
a156 1
    croak(qq/Key "$key" is not $klen characters long.\n/)
d163 1
a163 1
    &_hashwrap if $hash >= $tsize;
d169 1
a169 1
    $hash -= int($hash / $tsize) * $tsize;
d174 1
a174 1
    $hash -= $tsize if $hash >= $tsize;
d177 13
a189 1
sub findprime {
d192 3
a194 1
    my $num = shift;
d196 3
a198 2

    $max = int sqrt $num;
d202 8
a209 4
	for ($i = 3; $i <= $max; $i += 2) {
	    next NUM unless $num % $i;
	}
	return $num;
@


1.2
log
@perl 5.004_04
@
text
@d72 1
a72 1
    croak("Table is full") if $self[5] == $tsize;
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
    tie %myhash, Tie::SubstrHash, $key_len, $value_len, $table_size;
d147 1
d149 1
a149 2
    $hash = $hash - int($hash / $tsize) * $tsize
	if $hash >= $tsize;
d152 4
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d11 1
a11 1
    tie %myhash, 'Tie::SubstrHash', $key_len, $value_len, $table_size;
d72 1
a72 1
    croak("Table is full") if $$self[5] == $tsize;
a146 1
	&_hashwrap if $hash >= 1e13;
d148 2
a149 1
    &_hashwrap if $hash >= $tsize;
a151 4
}

sub _hashwrap {
    $hash -= int($hash / $tsize) * $tsize;
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a35 2
The hash does not support exists().

d44 1
a44 2
    $tsize = [$tsize,
	      findgteprime($tsize * 1.1)]; # Allow 10% empty.
d46 1
a46 1
    $$self[0] x= $rlen * $tsize->[1];
a49 7
sub CLEAR {
    local($self) = @@_;
    $$self[0] = "\0" x ($$self[4] * $$self[3]->[1]);
    $$self[5] =  0;
    $$self[6] = -1;
}

d72 2
a73 2
    croak("Table is full ($tsize->[0] elements)") if $$self[5] > $tsize->[0];
    croak(qq/Value "$val" is not $vlen characters long/)
d132 1
a132 1
    for (++$iterix; $iterix < $tsize->[1]; ++$iterix) {
a140 4
sub EXISTS {
    croak "Tie::SubstrHash does not support exists()";
}

d142 1
a142 1
    croak(qq/Key "$key" is not $klen characters long/)
d149 1
a149 1
    &_hashwrap if $hash >= $tsize->[1];
d155 1
a155 1
    $hash -= int($hash / $tsize->[1]) * $tsize->[1];
d160 1
a160 1
    $hash -= $tsize->[1] if $hash >= $tsize->[1];
d163 1
a163 13
# using POSIX::ceil() would be too heavy, and not all platforms have it.
sub ceil {
    my $num = shift;
    $num = int($num + 1) unless $num == int $num;
    return $num;
}

# See:
#
# http://www-groups.dcs.st-andrews.ac.uk/~history/HistTopics/Prime_numbers.html
#

sub findgteprime { # find the smallest prime integer greater than or equal to
d166 2
a167 2
    my $num = ceil(shift);
    return 2 if $num <= 2;
d169 1
a169 4
    $num++ unless $num % 2;
    my $i;
    my $sqrtnum = int sqrt $num;
    my $sqrtnumsquared = $sqrtnum * $sqrtnum;
d173 4
a176 8
	if ($sqrtnumsquared < $num) {
	    $sqrtnum++;
	    $sqrtnumsquared = $sqrtnum * $sqrtnum;
	}
        for ($i = 3; $i <= $sqrtnum; $i += 2) {
            next NUM unless $num % $i;
        }
        return $num;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a2 2
our $VERSION = '1.00';

d48 1
a48 1
    local $self = bless ["\0", $klen, $vlen, $tsize, $rlen, 0, -1];
@


