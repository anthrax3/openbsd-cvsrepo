head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.7.0.8
	OPENBSD_6_2_BASE:1.1.1.7
	PERL_5_24_2:1.1.1.7
	OPENBSD_6_1:1.1.1.7.0.12
	OPENBSD_6_1_BASE:1.1.1.7
	OPENBSD_6_0:1.1.1.7.0.10
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.4
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.6
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.2
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.6.0.8
	OPENBSD_5_6_BASE:1.1.1.6
	PERL_5_18_2:1.1.1.6
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.6.0.6
	OPENBSD_5_5_BASE:1.1.1.6
	OPENBSD_5_4:1.1.1.6.0.2
	OPENBSD_5_4_BASE:1.1.1.6
	PERL_5_16_3:1.1.1.6
	OPENBSD_5_3:1.1.1.5.0.38
	OPENBSD_5_3_BASE:1.1.1.5
	OPENBSD_5_2:1.1.1.5.0.36
	OPENBSD_5_2_BASE:1.1.1.5
	OPENBSD_5_1_BASE:1.1.1.5
	OPENBSD_5_1:1.1.1.5.0.34
	OPENBSD_5_0:1.1.1.5.0.32
	OPENBSD_5_0_BASE:1.1.1.5
	OPENBSD_4_9:1.1.1.5.0.30
	OPENBSD_4_9_BASE:1.1.1.5
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.1.1.5.0.28
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.24
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.26
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.22
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.5.0.20
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.18
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.16
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.14
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.12
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.10
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.8
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.6
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	99.04.29.22.40.19;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.19;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.50;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.38;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.08;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2013.03.25.20.08.54;	author sthen;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2014.11.17.20.53.08;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@package Tie::Array;
use vars qw($VERSION); 
use strict;
$VERSION = '1.00';

# Pod documentation after __END__ below.

sub DESTROY { }
sub EXTEND  { }          
sub UNSHIFT { shift->SPLICE(0,0,@@_) }                 
sub SHIFT   { shift->SPLICE(0,1) }                 
sub CLEAR   { shift->STORESIZE(0) }

sub PUSH 
{  
 my $obj = shift;
 my $i   = $obj->FETCHSIZE;
 $obj->STORE($i++, shift) while (@@_);
}

sub POP 
{
 my $obj = shift;
 my $newsize = $obj->FETCHSIZE - 1;
 my $val;
 if ($newsize >= 0) 
  {
   $val = $obj->FETCH($newsize);
   $obj->STORESIZE($newsize);
  }
 $val;
}          

sub SPLICE
{
 my $obj = shift;
 my $sz  = $obj->FETCHSIZE;
 my $off = (@@_) ? shift : 0;
 $off += $sz if ($off < 0);
 my $len = (@@_) ? shift : $sz - $off;
 my @@result;
 for (my $i = 0; $i < $len; $i++)
  {
   push(@@result,$obj->FETCH($off+$i));
  }
 if (@@_ > $len)
  {                          
   # Move items up to make room
   my $d = @@_ - $len;
   my $e = $off+$len;
   $obj->EXTEND($sz+$d);
   for (my $i=$sz-1; $i >= $e; $i--)
    {
     my $val = $obj->FETCH($i);
     $obj->STORE($i+$d,$val);
    }
  }
 elsif (@@_ < $len)
  {
   # Move items down to close the gap 
   my $d = $len - @@_;
   my $e = $off+$len;
   for (my $i=$off+$len; $i < $sz; $i++)
    {
     my $val = $obj->FETCH($i);
     $obj->STORE($i-$d,$val);
    }
   $obj->STORESIZE($sz-$d);
  }
 for (my $i=0; $i < @@_; $i++)
  {
   $obj->STORE($off+$i,$_[$i]);
  }
 return @@result;
} 

package Tie::StdArray;
use vars qw(@@ISA);
@@ISA = 'Tie::Array';

sub TIEARRAY  { bless [], $_[0] }
sub FETCHSIZE { scalar @@{$_[0]} }             
sub STORESIZE { $#{$_[0]} = $_[1]-1 }  
sub STORE     { $_[0]->[$_[1]] = $_[2] }
sub FETCH     { $_[0]->[$_[1]] }
sub CLEAR     { @@{$_[0]} = () }
sub POP       { pop(@@{$_[0]}) } 
sub PUSH      { my $o = shift; push(@@$o,@@_) }
sub SHIFT     { shift(@@{$_[0]}) } 
sub UNSHIFT   { my $o = shift; unshift(@@$o,@@_) } 

sub SPLICE
{
 my $ob  = shift;                    
 my $sz  = $ob->FETCHSIZE;
 my $off = @@_ ? shift : 0;
 $off   += $sz if $off < 0;
 my $len = @@_ ? shift : $sz-$off;
 return splice(@@$ob,$off,$len,@@_);
}

1;

__END__

=head1 NAME

Tie::Array - base class for tied arrays

=head1 SYNOPSIS  

    package NewArray;
    use Tie::Array;
    @@ISA = ('Tie::Array');
                       
    # mandatory methods
    sub TIEARRAY { ... }  
    sub FETCH { ... }     
    sub FETCHSIZE { ... } 
        
    sub STORE { ... }        # mandatory if elements writeable
    sub STORESIZE { ... }    # mandatory if elements can be added/deleted
                               
    # optional methods - for efficiency
    sub CLEAR { ... }  
    sub PUSH { ... } 
    sub POP { ... } 
    sub SHIFT { ... } 
    sub UNSHIFT { ... } 
    sub SPLICE { ... } 
    sub EXTEND { ... } 
    sub DESTROY { ... }

    package NewStdArray;
    use Tie::Array;
    
    @@ISA = ('Tie::StdArray');

    # all methods provided by default

    package main;

    $object = tie @@somearray,Tie::NewArray;
    $object = tie @@somearray,Tie::StdArray;
    $object = tie @@somearray,Tie::NewStdArray;



=head1 DESCRIPTION       

This module provides methods for array-tying classes. See
L<perltie> for a list of the functions required in order to tie an array
to a package. The basic B<Tie::Array> package provides stub C<DELETE> 
and C<EXTEND> methods, and implementations of C<PUSH>, C<POP>, C<SHIFT>, 
C<UNSHIFT>, C<SPLICE> and C<CLEAR> in terms of basic C<FETCH>, C<STORE>, 
C<FETCHSIZE>, C<STORESIZE>.

The B<Tie::StdArray> package provides efficient methods required for tied arrays 
which are implemented as blessed references to an "inner" perl array.
It inherits from B<Tie::Array>, and should cause tied arrays to behave exactly 
like standard arrays, allowing for selective overloading of methods. 

For developers wishing to write their own tied arrays, the required methods
are briefly defined below. See the L<perltie> section for more detailed
descriptive, as well as example code:

=over 

=item TIEARRAY classname, LIST

The class method is invoked by the command C<tie @@array, classname>. Associates
an array instance with the specified class. C<LIST> would represent
additional arguments (along the lines of L<AnyDBM_File> and compatriots) needed
to complete the association. The method should return an object of a class which
provides the methods below. 

=item STORE this, index, value

Store datum I<value> into I<index> for the tied array associated with
object I<this>. If this makes the array larger then
class's mapping of C<undef> should be returned for new positions.

=item FETCH this, index

Retrieve the datum in I<index> for the tied array associated with
object I<this>.

=item FETCHSIZE this

Returns the total number of items in the tied array associated with
object I<this>. (Equivalent to C<scalar(@@array)>).

=item STORESIZE this, count

Sets the total number of items in the tied array associated with
object I<this> to be I<count>. If this makes the array larger then
class's mapping of C<undef> should be returned for new positions.
If the array becomes smaller then entries beyond count should be
deleted. 

=item EXTEND this, count

Informative call that array is likely to grow to have I<count> entries.
Can be used to optimize allocation. This method need do nothing.

=item CLEAR this

Clear (remove, delete, ...) all values from the tied array associated with
object I<this>.

=item DESTROY this

Normal object destructor method.

=item PUSH this, LIST 

Append elements of LIST to the array.

=item POP this

Remove last element of the array and return it.

=item SHIFT this

Remove the first element of the array (shifting other elements down)
and return it.

=item UNSHIFT this, LIST 

Insert LIST elements at the beginning of the array, moving existing elements
up to make room.

=item SPLICE this, offset, length, LIST

Perform the equivalent of C<splice> on the array. 

I<offset> is optional and defaults to zero, negative values count back 
from the end of the array. 

I<length> is optional and defaults to rest of the array.

I<LIST> may be empty.

Returns a list of the original I<length> elements at I<offset>.

=back

=head1 CAVEATS

There is no support at present for tied @@ISA. There is a potential conflict 
between magic entries needed to notice setting of @@ISA, and those needed to
implement 'tie'.   

Very little consideration has been given to the behaviour of tied arrays
when C<$[> is not default value of zero.

=head1 AUTHOR 

Nick Ing-Simmons E<lt>nik@@tiuk.ti.comE<gt>

=cut 

@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d2 1
a2 2

use 5.005_64;
d4 1
a4 2
use Carp;
our $VERSION = '1.01';
a76 10
sub EXISTS {
    my $pkg = ref $_[0];
    croak "$pkg dosn't define an EXISTS method";
}

sub DELETE {
    my $pkg = ref $_[0];
    croak "$pkg dosn't define a DELETE method";
}

a90 2
sub EXISTS    { exists $_[0]->[$_[1]] }
sub DELETE    { delete $_[0]->[$_[1]] }
d115 1
a115 1

d120 1
a120 1

d123 1
a123 3
    sub EXISTS { ... }       # mandatory if exists() expected to work
    sub DELETE { ... }       # mandatory if delete() expected to work

d136 1
a136 1

d153 3
a155 5
to a package. The basic B<Tie::Array> package provides stub C<DESTROY>,
and C<EXTEND> methods that do nothing, stub C<DELETE> and C<EXISTS>
methods that croak() if the delete() or exists() builtins are ever called
on the tied array, and implementations of C<PUSH>, C<POP>, C<SHIFT>,
C<UNSHIFT>, C<SPLICE> and C<CLEAR> in terms of basic C<FETCH>, C<STORE>,
a204 12

=item EXISTS this, key

Verify that the element at index I<key> exists in the tied array I<this>.

The B<Tie::Array> implementation is a stub that simply croaks.

=item DELETE this, key

Delete the element at index I<key> from the tied array I<this>.

The B<Tie::Array> implementation is a stub that simply croaks.
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d11 3
a13 4
sub EXTEND  { }
sub UNSHIFT { scalar shift->SPLICE(0,0,@@_) }
sub SHIFT { shift->SPLICE(0,1) }
#sub SHIFT   { (shift->SPLICE(0,1))[0] }
d16 2
a17 2
sub PUSH
{
d23 1
a23 1
sub POP
d28 1
a28 1
 if ($newsize >= 0)
d34 1
a34 1
}
d36 22
a57 10
sub SPLICE {
    my $obj = shift;
    my $sz  = $obj->FETCHSIZE;
    my $off = (@@_) ? shift : 0;
    $off += $sz if ($off < 0);
    my $len = (@@_) ? shift : $sz - $off;
    $len += $sz - $off if $len < 0;
    my @@result;
    for (my $i = 0; $i < $len; $i++) {
        push(@@result,$obj->FETCH($off+$i));
d59 10
a68 11
    $off = $sz if $off > $sz;
    $len -= $off + $len - $sz if $off + $len > $sz;
    if (@@_ > $len) {
        # Move items up to make room
        my $d = @@_ - $len;
        my $e = $off+$len;
        $obj->EXTEND($sz+$d);
        for (my $i=$sz-1; $i >= $e; $i--) {
            my $val = $obj->FETCH($i);
            $obj->STORE($i+$d,$val);
        }
d70 8
a77 15
    elsif (@@_ < $len) {
        # Move items down to close the gap
        my $d = $len - @@_;
        my $e = $off+$len;
        for (my $i=$off+$len; $i < $sz; $i++) {
            my $val = $obj->FETCH($i);
            $obj->STORE($i-$d,$val);
        }
        $obj->STORESIZE($sz-$d);
    }
    for (my $i=0; $i < @@_; $i++) {
        $obj->STORE($off+$i,$_[$i]);
    }
    return @@result;
}
d94 2
a95 2
sub FETCHSIZE { scalar @@{$_[0]} }
sub STORESIZE { $#{$_[0]} = $_[1]-1 }
d99 1
a99 1
sub POP       { pop(@@{$_[0]}) }
d101 2
a102 2
sub SHIFT     { shift(@@{$_[0]}) }
sub UNSHIFT   { my $o = shift; unshift(@@$o,@@_) }
d108 1
a108 1
 my $ob  = shift;
d124 1
a124 1
=head1 SYNOPSIS
d131 3
a133 3
    sub TIEARRAY { ... }
    sub FETCH { ... }
    sub FETCHSIZE { ... }
d141 7
a147 7
    sub CLEAR { ... }
    sub PUSH { ... }
    sub POP { ... }
    sub SHIFT { ... }
    sub UNSHIFT { ... }
    sub SPLICE { ... }
    sub EXTEND { ... }
d165 1
a165 1
=head1 DESCRIPTION
d176 1
a176 1
The B<Tie::StdArray> package provides efficient methods required for tied arrays
d178 2
a179 2
It inherits from B<Tie::Array>, and should cause tied arrays to behave exactly
like standard arrays, allowing for selective overloading of methods.
d185 1
a185 1
=over
d193 1
a193 1
provides the methods below.
d217 1
a217 1
deleted.
d245 1
a245 1
=item PUSH this, LIST
d258 1
a258 1
=item UNSHIFT this, LIST
d265 1
a265 1
Perform the equivalent of C<splice> on the array.
d267 2
a268 2
I<offset> is optional and defaults to zero, negative values count back
from the end of the array.
d280 1
a280 1
There is no support at present for tied @@ISA. There is a potential conflict
d282 1
a282 1
implement 'tie'.
d287 1
a287 1
=head1 AUTHOR
d291 2
a292 1
=cut
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
use 5.006_001;
d6 1
a6 1
our $VERSION = '1.02';
d14 1
d73 1
a73 1
    return wantarray ? @@result : pop @@result;
d123 1
a123 1
    package Tie::NewArray;
d147 1
a147 1
    package Tie::NewStdArray;
d182 1
a182 1
=over 4
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d6 1
a6 1
our $VERSION = '1.03';
d77 1
a77 1
    croak "$pkg doesn't define an EXISTS method";
d82 1
a82 1
    croak "$pkg doesn't define a DELETE method";
@


1.1.1.6
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d6 1
a6 1
our $VERSION = '1.05';
d155 3
a157 3
    $object = tie @@somearray,'Tie::NewArray';
    $object = tie @@somearray,'Tie::StdArray';
    $object = tie @@somearray,'Tie::NewStdArray';
d279 3
@


1.1.1.7
log
@Import perl-5.20.1
@
text
@d6 1
a6 1
our $VERSION = '1.06';
d131 4
a134 4
    sub STORE { ... }       # mandatory if elements writeable
    sub STORESIZE { ... }   # mandatory if elements can be added/deleted
    sub EXISTS { ... }      # mandatory if exists() expected to work
    sub DELETE { ... }      # mandatory if delete() expected to work
@


