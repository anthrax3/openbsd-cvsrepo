head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.4
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.4
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.6
	OPENBSD_5_8_BASE:1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.9.0.2
	OPENBSD_5_7_BASE:1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.8.0.18
	OPENBSD_5_6_BASE:1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.8.0.16
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.12
	OPENBSD_5_4_BASE:1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.10
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.8
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.6
	OPENBSD_5_0:1.8.0.4
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.2
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.10
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	cxJ08BvJA9Pt2PTM;

1.9
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.8;
commitid	QP75iYx42Uo7mMxO;

1.8
date	2010.09.24.15.07.02;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.12.18.24.46;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.29.17.36.14;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.09;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.52;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.52;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.20;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.39;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.44;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.55;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.48.41;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.09;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.10
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package Tie::Scalar;

our $VERSION = '1.04';

=head1 NAME

Tie::Scalar, Tie::StdScalar - base class definitions for tied scalars

=head1 SYNOPSIS

    package NewScalar;
    require Tie::Scalar;

    @@ISA = qw(Tie::Scalar);

    sub FETCH { ... }		# Provide a needed method
    sub TIESCALAR { ... }	# Overrides inherited method


    package NewStdScalar;
    require Tie::Scalar;

    @@ISA = qw(Tie::StdScalar);

    # All methods provided by default, so define
    # only what needs be overridden
    sub FETCH { ... }


    package main;

    tie $new_scalar, 'NewScalar';
    tie $new_std_scalar, 'NewStdScalar';

=head1 DESCRIPTION

This module provides some skeletal methods for scalar-tying classes. See
L<perltie> for a list of the functions required in tying a scalar to a
package. The basic B<Tie::Scalar> package provides a C<new> method, as well
as methods C<TIESCALAR>, C<FETCH> and C<STORE>. The B<Tie::StdScalar>
package provides all the methods specified in  L<perltie>. It inherits from
B<Tie::Scalar> and causes scalars tied to it to behave exactly like the
built-in scalars, allowing for selective overloading of methods. The C<new>
method is provided as a means of grandfathering, for classes that forget to
provide their own C<TIESCALAR> method.

For developers wishing to write their own tied-scalar classes, the methods
are summarized below. The L<perltie> section not only documents these, but
has sample code as well:

=over 4

=item TIESCALAR classname, LIST

The method invoked by the command C<tie $scalar, classname>. Associates a new
scalar instance with the specified class. C<LIST> would represent additional
arguments (along the lines of L<AnyDBM_File> and compatriots) needed to
complete the association.

=item FETCH this

Retrieve the value of the tied scalar referenced by I<this>.

=item STORE this, value

Store data I<value> in the tied scalar referenced by I<this>.

=item DESTROY this

Free the storage associated with the tied scalar referenced by I<this>.
This is rarely needed, as Perl manages its memory quite well. But the
option exists, should a class wish to perform specific actions upon the
destruction of an instance.

=back

=head2 Tie::Scalar vs Tie::StdScalar

C<< Tie::Scalar >> provides all the necessary methods, but one should realize
they do not do anything useful. Calling C<< Tie::Scalar::FETCH >> or 
C<< Tie::Scalar::STORE >> results in a (trappable) croak. And if you inherit
from C<< Tie::Scalar >>, you I<must> provide either a C<< new >> or a
C<< TIESCALAR >> method. 

If you are looking for a class that does everything for you you don't
define yourself, use the C<< Tie::StdScalar >> class, not the
C<< Tie::Scalar >> one.

=head1 MORE INFORMATION

The L<perltie> section uses a good example of tying scalars by associating
process IDs with priority.

=cut

use Carp;
use warnings::register;

sub new {
    my $pkg = shift;
    $pkg->TIESCALAR(@@_);
}

# "Grandfather" the new, a la Tie::Hash

sub TIESCALAR {
    my $pkg = shift;
    my $pkg_new = $pkg -> can ('new');

    if ($pkg_new and $pkg ne __PACKAGE__) {
        my $my_new = __PACKAGE__ -> can ('new');
        if ($pkg_new == $my_new) {  
            #
            # Prevent recursion
            #
            croak "$pkg must define either a TIESCALAR() or a new() method";
        }

	warnings::warnif ("WARNING: calling ${pkg}->new since " .
                          "${pkg}->TIESCALAR is missing");
	$pkg -> new (@@_);
    }
    else {
	croak "$pkg doesn't define a TIESCALAR method";
    }
}

sub FETCH {
    my $pkg = ref $_[0];
    croak "$pkg doesn't define a FETCH method";
}

sub STORE {
    my $pkg = ref $_[0];
    croak "$pkg doesn't define a STORE method";
}

#
# The Tie::StdScalar package provides scalars that behave exactly like
# Perl's built-in scalars. Good base to inherit from, if you're only going to
# tweak a small bit.
#
package Tie::StdScalar;
@@ISA = qw(Tie::Scalar);

sub TIESCALAR {
    my $class = shift;
    my $instance = @@_ ? shift : undef;
    return bless \$instance => $class;
}

sub FETCH {
    return ${$_[0]};
}

sub STORE {
    ${$_[0]} = $_[1];
}

sub DESTROY {
    undef ${$_[0]};
}

1;
@


1.9
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d3 1
a3 1
our $VERSION = '1.03';
d148 1
a148 1
    my $instance = shift || undef;
@


1.8
log
@merge in perl 5.12.2 plus local changes
@
text
@d3 1
a3 1
our $VERSION = '1.02';
d25 2
a26 1
    # All methods provided by default, so define only what needs be overridden
@


1.7
log
@Merge in perl 5.10.1
@
text
@d3 1
a3 1
our $VERSION = '1.01';
d76 12
d107 14
a120 3
	if ($pkg->can('new') and $pkg ne __PACKAGE__) {
	warnings::warnif("WARNING: calling ${pkg}->new since ${pkg}->TIESCALAR is missing");
	$pkg->new(@@_);
@


1.6
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 1
a3 1
our $VERSION = '1.00';
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d14 1
a14 1
    @@ISA = (Tie::Scalar);
d23 1
a23 1
    @@ISA = (Tie::StdScalar);
d120 1
a120 1
@@ISA = (Tie::Scalar);
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 2
d50 1
a50 1
=over
d95 1
a95 1
    if (defined &{"{$pkg}::new"}) {
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d94 1
a94 2
	warnings::warn "WARNING: calling ${pkg}->new since ${pkg}->TIESCALAR is missing"
	    if warnings::enabled();
@


1.2
log
@perl 5.004_04
@
text
@d11 1
a11 1
     
d13 1
a13 1
     
d16 2
a17 2
         
     
d20 1
a20 1
    
d22 1
a22 1
    
d25 2
a26 2
    
    
d28 1
a28 1
    
d82 1
d94 2
a95 2
	carp "WARNING: calling ${pkg}->new since ${pkg}->TIESCALAR is missing"
	    if $^W;
@


1.1
log
@Initial revision
@
text
@d29 2
a30 2
    tie $new_scalar, NewScalar;
    tie $new_std_scalar, NewStdScalar;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d29 2
a30 2
    tie $new_scalar, 'NewScalar';
    tie $new_std_scalar, 'NewStdScalar';
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d11 1
a11 1

d13 1
a13 1

d16 2
a17 2


d20 1
a20 1

d22 1
a22 1

d25 2
a26 2


d28 1
a28 1

a81 1
use warnings::register;
d93 2
a94 2
	warnings::warn "WARNING: calling ${pkg}->new since ${pkg}->TIESCALAR is missing"
	    if warnings::enabled();
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d94 2
a95 1
	warnings::warnif("WARNING: calling ${pkg}->new since ${pkg}->TIESCALAR is missing");
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a2 2
our $VERSION = '1.00';

d48 1
a48 1
=over 4
d93 1
a93 1
	if ($pkg->can('new') and $pkg ne __PACKAGE__) {
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d14 1
a14 1
    @@ISA = qw(Tie::Scalar);
d23 1
a23 1
    @@ISA = qw(Tie::StdScalar);
d120 1
a120 1
@@ISA = qw(Tie::Scalar);
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d3 1
a3 1
our $VERSION = '1.01';
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.02';
a75 12
=head2 Tie::Scalar vs Tie::StdScalar

C<< Tie::Scalar >> provides all the necessary methods, but one should realize
they do not do anything useful. Calling C<< Tie::Scalar::FETCH >> or 
C<< Tie::Scalar::STORE >> results in a (trappable) croak. And if you inherit
from C<< Tie::Scalar >>, you I<must> provide either a C<< new >> or a
C<< TIESCALAR >> method. 

If you are looking for a class that does everything for you you don't
define yourself, use the C<< Tie::StdScalar >> class, not the
C<< Tie::Scalar >> one.

d95 3
a97 14
    my $pkg_new = $pkg -> can ('new');

    if ($pkg_new and $pkg ne __PACKAGE__) {
        my $my_new = __PACKAGE__ -> can ('new');
        if ($pkg_new == $my_new) {  
            #
            # Prevent recursion
            #
            croak "$pkg must define either a TIESCALAR() or a new() method";
        }

	warnings::warnif ("WARNING: calling ${pkg}->new since " .
                          "${pkg}->TIESCALAR is missing");
	$pkg -> new (@@_);
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d3 1
a3 1
our $VERSION = '1.03';
d25 1
a25 2
    # All methods provided by default, so define
    # only what needs be overridden
@


