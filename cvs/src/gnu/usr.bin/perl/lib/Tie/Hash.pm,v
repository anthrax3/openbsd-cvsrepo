head	1.13;
access;
symbols
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.10
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.4
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.13.0.2
	OPENBSD_5_7_BASE:1.13
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.13
date	2014.11.17.20.57.07;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2013.03.25.20.40.56;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.44;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.14;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.28;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.39;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.56;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.07;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.52;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.52;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.19;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.39;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.08;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.23;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.01;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.44;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.55;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.08.55;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.08;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@package Tie::Hash;

our $VERSION = '1.05';

=head1 NAME

Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes

=head1 SYNOPSIS

    package NewHash;
    require Tie::Hash;

    @@ISA = qw(Tie::Hash);

    sub DELETE { ... }		# Provides needed method
    sub CLEAR { ... }		# Overrides inherited method


    package NewStdHash;
    require Tie::Hash;

    @@ISA = qw(Tie::StdHash);

    # All methods provided by default, define
    # only those needing overrides
    # Accessors access the storage in %{$_[0]};
    # TIEHASH should return a reference to the actual storage
    sub DELETE { ... }

    package NewExtraHash;
    require Tie::Hash;

    @@ISA = qw(Tie::ExtraHash);

    # All methods provided by default, define 
    # only those needing overrides
    # Accessors access the storage in %{$_[0][0]};
    # TIEHASH should return an array reference with the first element
    # being the reference to the actual storage 
    sub DELETE { 
      $_[0][1]->('del', $_[0][0], $_[1]); # Call the report writer
      delete $_[0][0]->{$_[1]};		  #  $_[0]->SUPER::DELETE($_[1])
    }


    package main;

    tie %new_hash, 'NewHash';
    tie %new_std_hash, 'NewStdHash';
    tie %new_extra_hash, 'NewExtraHash',
	sub {warn "Doing \U$_[1]\E of $_[2].\n"};

=head1 DESCRIPTION

This module provides some skeletal methods for hash-tying classes. See
L<perltie> for a list of the functions required in order to tie a hash
to a package. The basic B<Tie::Hash> package provides a C<new> method, as well
as methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and
B<Tie::ExtraHash> packages
provide most methods for hashes described in L<perltie> (the exceptions
are C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,
and allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the
C<new> method: it is used if C<TIEHASH> is not defined
in the case a class forgets to include a C<TIEHASH> method.

For developers wishing to write their own tied hashes, the required methods
are briefly defined below. See the L<perltie> section for more detailed
descriptive, as well as example code:

=over 4

=item TIEHASH classname, LIST

The method invoked by the command C<tie %hash, classname>. Associates a new
hash instance with the specified class. C<LIST> would represent additional
arguments (along the lines of L<AnyDBM_File> and compatriots) needed to
complete the association.

=item STORE this, key, value

Store datum I<value> into I<key> for the tied hash I<this>.

=item FETCH this, key

Retrieve the datum in I<key> for the tied hash I<this>.

=item FIRSTKEY this

Return the first key in the hash.

=item NEXTKEY this, lastkey

Return the next key in the hash.

=item EXISTS this, key

Verify that I<key> exists with the tied hash I<this>.

The B<Tie::Hash> implementation is a stub that simply croaks.

=item DELETE this, key

Delete the key I<key> from the tied hash I<this>.

=item CLEAR this

Clear all values from the tied hash I<this>.

=item SCALAR this

Returns what evaluating the hash in scalar context yields.

B<Tie::Hash> does not implement this method (but B<Tie::StdHash>
and B<Tie::ExtraHash> do).

=back

=head1 Inheriting from B<Tie::StdHash>

The accessor methods assume that the actual storage for the data in the tied
hash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten
C<TIEHASH> method should return a hash reference, and the remaining methods
should operate on the hash referenced by the first argument:

  package ReportHash;
  our @@ISA = 'Tie::StdHash';

  sub TIEHASH  {
    my $storage = bless {}, shift;
    warn "New ReportHash created, stored in $storage.\n";
    $storage
  }
  sub STORE    {
    warn "Storing data with key $_[1] at $_[0].\n";
    $_[0]{$_[1]} = $_[2]
  }


=head1 Inheriting from B<Tie::ExtraHash>

The accessor methods assume that the actual storage for the data in the tied
hash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten
C<TIEHASH> method should return an array reference with the first
element being a hash reference, and the remaining methods should operate on the
hash C<< %{ $_[0]->[0] } >>:

  package ReportHash;
  our @@ISA = 'Tie::ExtraHash';

  sub TIEHASH  {
    my $class = shift;
    my $storage = bless [{}, @@_], $class;
    warn "New ReportHash created, stored in $storage.\n";
    $storage;
  }
  sub STORE    {
    warn "Storing data with key $_[1] at $_[0].\n";
    $_[0][0]{$_[1]} = $_[2]
  }

The default C<TIEHASH> method stores "extra" arguments to tie() starting
from offset 1 in the array referenced by C<tied(%tiedhash)>; this is the
same storage algorithm as in TIEHASH subroutine above.  Hence, a typical
package inheriting from B<Tie::ExtraHash> does not need to overwrite this
method.

=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>

The methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,
B<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require
presence of these methods, but if defined, the methods will be called in
proper time, see L<perltie>.

C<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.

If needed, these methods should be defined by the package inheriting from
B<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<perltie/"SCALAR">
to find out what happens when C<SCALAR> does not exist.

=head1 MORE INFORMATION

The packages relating to various DBM-related implementations (F<DB_File>,
F<NDBM_File>, etc.) show examples of general tied hashes, as does the
L<Config> module. While these do not utilize B<Tie::Hash>, they serve as
good working examples.

=cut

use Carp;
use warnings::register;

sub new {
    my $pkg = shift;
    $pkg->TIEHASH(@@_);
}

# Grandfather "new"

sub TIEHASH {
    my $pkg = shift;
    my $pkg_new = $pkg -> can ('new');

    if ($pkg_new and $pkg ne __PACKAGE__) {
        my $my_new = __PACKAGE__ -> can ('new');
        if ($pkg_new == $my_new) {  
            #
            # Prevent recursion
            #
            croak "$pkg must define either a TIEHASH() or a new() method";
        }

	warnings::warnif ("WARNING: calling ${pkg}->new since " .
                          "${pkg}->TIEHASH is missing");
	$pkg -> new (@@_);
    }
    else {
	croak "$pkg doesn't define a TIEHASH method";
    }
}

sub EXISTS {
    my $pkg = ref $_[0];
    croak "$pkg doesn't define an EXISTS method";
}

sub CLEAR {
    my $self = shift;
    my $key = $self->FIRSTKEY(@@_);
    my @@keys;

    while (defined $key) {
	push @@keys, $key;
	$key = $self->NEXTKEY(@@_, $key);
    }
    foreach $key (@@keys) {
	$self->DELETE(@@_, $key);
    }
}

# The Tie::StdHash package implements standard perl hash behaviour.
# It exists to act as a base class for classes which only wish to
# alter some parts of their behaviour.

package Tie::StdHash;
# @@ISA = qw(Tie::Hash);		# would inherit new() only

sub TIEHASH  { bless {}, $_[0] }
sub STORE    { $_[0]->{$_[1]} = $_[2] }
sub FETCH    { $_[0]->{$_[1]} }
sub FIRSTKEY { my $a = scalar keys %{$_[0]}; each %{$_[0]} }
sub NEXTKEY  { each %{$_[0]} }
sub EXISTS   { exists $_[0]->{$_[1]} }
sub DELETE   { delete $_[0]->{$_[1]} }
sub CLEAR    { %{$_[0]} = () }
sub SCALAR   { scalar %{$_[0]} }

package Tie::ExtraHash;

sub TIEHASH  { my $p = shift; bless [{}, @@_], $p }
sub STORE    { $_[0][0]{$_[1]} = $_[2] }
sub FETCH    { $_[0][0]{$_[1]} }
sub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }
sub NEXTKEY  { each %{$_[0][0]} }
sub EXISTS   { exists $_[0][0]->{$_[1]} }
sub DELETE   { delete $_[0][0]->{$_[1]} }
sub CLEAR    { %{$_[0][0]} = () }
sub SCALAR   { scalar %{$_[0][0]} }

1;
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d3 1
a3 1
our $VERSION = '1.04';
d25 2
a26 1
    # All methods provided by default, define only those needing overrides
d36 2
a37 1
    # All methods provided by default, define only those needing overrides
d39 2
a40 2
    # TIEHASH should return an array reference with the first element being
    # the reference to the actual storage 
@


1.11
log
@Merge in perl 5.10.1
@
text
@d3 1
a3 1
our $VERSION = '1.03';
d200 14
a213 3
    if (defined &{"${pkg}::new"}) {
	warnings::warnif("WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing");
	$pkg->new(@@_);
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 1
a3 1
our $VERSION = '1.02';
d176 1
a176 1
B<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/"SCALAR">
@


1.9
log
@merge in perl 5.8.8
@
text
@d14 1
a14 1
    @@ISA = (Tie::Hash);
d23 1
a23 1
    @@ISA = (Tie::StdHash);
d33 1
a33 1
    @@ISA = (Tie::ExtraHash);
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d3 1
a3 1
our $VERSION = '1.01';
d170 1
a170 1
presense of these methods, but if defined, the methods will be called in
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
our $VERSION = '1.00';
d108 7
d141 1
a141 1
hash is in the hash referenced by C<(tied(%tiedhash))[0]>.  Thus overwritten
d166 1
a166 1
=head1 C<UNTIE> and C<DESTROY>
d173 2
d176 2
a177 1
B<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>.
d243 1
d255 1
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d27 1
a27 1
    # TIEHANDLE should return a reference to the actual storage
d37 1
a37 1
    # TIEHANDLE should return an array reference with the first element being
d41 2
a42 1
      delete $_[0][0]->{$_[1]};		  #  $_[0]->SUPER::DELETE($_[1]) }
d114 1
a114 1
C<TIEHANDLE> method should return a hash reference, and the remaining methods
d135 1
a135 1
C<TIEHANDLE> method should return an array reference with the first
d140 1
a140 1
  our @@ISA = 'Tie::StdHash';
d143 2
a144 1
    my $storage = bless {}, shift;
d146 1
a146 1
    [$storage, @@_]
d153 1
a153 1
The default C<TIEHANDLE> method stores "extra" arguments to tie() starting
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 2
d7 1
a7 1
Tie::Hash, Tie::StdHash - base class definitions for tied hashes
d13 1
a13 1
    
d15 1
a15 1
    
d18 2
a19 2
    
    
d22 1
a22 1
    
d24 1
a24 1
    
d26 2
d29 15
a43 2
    
    
d45 1
a45 1
    
d48 2
d56 7
a62 5
as methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> package
provides most methods required for hashes in L<perltie>. It inherits from
B<Tie::Hash>, and causes tied hashes to behave exactly like standard hashes,
allowing for selective overloading of methods. The C<new> method is provided
as grandfathering in the case a class forgets to include a C<TIEHASH> method.
d68 1
a68 1
=over
d87 1
a87 1
Return the (key, value) pair for the first key in the hash.
d91 1
a91 1
Return the next key for the hash.
d109 54
a162 1
=head1 CAVEATS
d164 2
a165 4
The L<perltie> documentation includes a method called C<DESTROY> as
a necessary method for tied hashes. Neither B<Tie::Hash> nor B<Tie::StdHash>
define a default for this method. This is a standard for class packages,
but may be omitted in favor of a simple default.
d221 1
a221 1
@@ISA = qw(Tie::Hash);
d231 11
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d117 1
a117 2
	warnings::warn "WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing"
	    if warnings::enabled();
@


1.3
log
@perl5.005_03 (stock)
@
text
@d76 2
d105 1
d117 2
a118 2
	carp "WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing"
	    if $^W;
@


1.2
log
@perl 5.004_04
@
text
@d70 1
a70 1
Return the next (key, value) pair for the hash.
d95 1
a95 1
The packages relating to various DBM-related implemetations (F<DB_File>,
d113 1
a113 1
    if (defined &{"{$pkg}::new"}) {
@


1.1
log
@Initial revision
@
text
@d29 2
a30 2
    tie %new_hash, NewHash;
    tie %new_std_hash, NewStdHash;
d101 1
a101 1
    
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d29 2
a30 2
    tie %new_hash, 'NewHash';
    tie %new_std_hash, 'NewStdHash';
d70 1
a70 1
Return the next key for the hash.
d95 1
a95 1
The packages relating to various DBM-related implementations (F<DB_File>,
d101 1
a101 1

d113 1
a113 1
    if (defined &{"${pkg}::new"}) {
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a75 2
The B<Tie::Hash> implementation is a stub that simply croaks.

a102 1
use warnings::register;
d114 2
a115 2
	warnings::warn "WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing"
	    if warnings::enabled();
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d117 2
a118 1
	warnings::warnif("WARNING: calling ${pkg}->new since ${pkg}->TIEHASH is missing");
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a2 2
our $VERSION = '1.00';

d5 1
a5 1
Tie::Hash, Tie::StdHash, Tie::ExtraHash - base class definitions for tied hashes
d11 1
a11 1

d13 1
a13 1

d16 2
a17 2


d20 1
a20 1

d22 1
a22 1

a23 2
    # Accessors access the storage in %{$_[0]};
    # TIEHANDLE should return a reference to the actual storage
d25 2
a26 15

    package NewExtraHash;
    require Tie::Hash;

    @@ISA = (Tie::ExtraHash);

    # All methods provided by default, define only those needing overrides
    # Accessors access the storage in %{$_[0][0]};
    # TIEHANDLE should return an array reference with the first element being
    # the reference to the actual storage 
    sub DELETE { 
      $_[0][1]->('del', $_[0][0], $_[1]); # Call the report writer
      delete $_[0][0]->{$_[1]};		  #  $_[0]->SUPER::DELETE($_[1]) }


d28 1
a28 1

a30 2
    tie %new_extra_hash, 'NewExtraHash',
	sub {warn "Doing \U$_[1]\E of $_[2].\n"};
d37 5
a41 7
as methods C<TIEHASH>, C<EXISTS> and C<CLEAR>. The B<Tie::StdHash> and
B<Tie::ExtraHash> packages
provide most methods for hashes described in L<perltie> (the exceptions
are C<UNTIE> and C<DESTROY>).  They cause tied hashes to behave exactly like standard hashes,
and allow for selective overwriting of methods.  B<Tie::Hash> grandfathers the
C<new> method: it is used if C<TIEHASH> is not defined
in the case a class forgets to include a C<TIEHASH> method.
d47 1
a47 1
=over 4
d66 1
a66 1
Return the first key in the hash.
d70 1
a70 1
Return the next key in the hash.
d88 1
a88 54
=head1 Inheriting from B<Tie::StdHash>

The accessor methods assume that the actual storage for the data in the tied
hash is in the hash referenced by C<tied(%tiedhash)>.  Thus overwritten
C<TIEHANDLE> method should return a hash reference, and the remaining methods
should operate on the hash referenced by the first argument:

  package ReportHash;
  our @@ISA = 'Tie::StdHash';

  sub TIEHASH  {
    my $storage = bless {}, shift;
    warn "New ReportHash created, stored in $storage.\n";
    $storage
  }
  sub STORE    {
    warn "Storing data with key $_[1] at $_[0].\n";
    $_[0]{$_[1]} = $_[2]
  }


=head1 Inheriting from B<Tie::ExtraHash>

The accessor methods assume that the actual storage for the data in the tied
hash is in the hash referenced by C<(tied(%tiedhash))[0]>.  Thus overwritten
C<TIEHANDLE> method should return an array reference with the first
element being a hash reference, and the remaining methods should operate on the
hash C<< %{ $_[0]->[0] } >>:

  package ReportHash;
  our @@ISA = 'Tie::StdHash';

  sub TIEHASH  {
    my $storage = bless {}, shift;
    warn "New ReportHash created, stored in $storage.\n";
    [$storage, @@_]
  }
  sub STORE    {
    warn "Storing data with key $_[1] at $_[0].\n";
    $_[0][0]{$_[1]} = $_[2]
  }

The default C<TIEHANDLE> method stores "extra" arguments to tie() starting
from offset 1 in the array referenced by C<tied(%tiedhash)>; this is the
same storage algorithm as in TIEHASH subroutine above.  Hence, a typical
package inheriting from B<Tie::ExtraHash> does not need to overwrite this
method.

=head1 C<UNTIE> and C<DESTROY>

The methods C<UNTIE> and C<DESTROY> are not defined in B<Tie::Hash>,
B<Tie::StdHash>, or B<Tie::ExtraHash>.  Tied hashes do not require
presense of these methods, but if defined, the methods will be called in
proper time, see L<perltie>.
d90 4
a93 2
If needed, these methods should be defined by the package inheriting from
B<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>.
d149 1
a149 1
# @@ISA = qw(Tie::Hash);		# would inherit new() only
a158 11

package Tie::ExtraHash;

sub TIEHASH  { my $p = shift; bless [{}, @@_], $p }
sub STORE    { $_[0][0]{$_[1]} = $_[2] }
sub FETCH    { $_[0][0]{$_[1]} }
sub FIRSTKEY { my $a = scalar keys %{$_[0][0]}; each %{$_[0][0]} }
sub NEXTKEY  { each %{$_[0][0]} }
sub EXISTS   { exists $_[0][0]->{$_[1]} }
sub DELETE   { delete $_[0][0]->{$_[1]} }
sub CLEAR    { %{$_[0][0]} = () }
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d27 1
a27 1
    # TIEHASH should return a reference to the actual storage
d37 1
a37 1
    # TIEHASH should return an array reference with the first element being
d41 1
a41 2
      delete $_[0][0]->{$_[1]};		  #  $_[0]->SUPER::DELETE($_[1])
    }
d113 1
a113 1
C<TIEHASH> method should return a hash reference, and the remaining methods
d134 1
a134 1
C<TIEHASH> method should return an array reference with the first
d139 1
a139 1
  our @@ISA = 'Tie::ExtraHash';
d142 1
a142 2
    my $class = shift;
    my $storage = bless [{}, @@_], $class;
d144 1
a144 1
    $storage;
d151 1
a151 1
The default C<TIEHASH> method stores "extra" arguments to tie() starting
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.01';
a107 7
=item SCALAR this

Returns what evaluating the hash in scalar context yields.

B<Tie::Hash> does not implement this method (but B<Tie::StdHash>
and B<Tie::ExtraHash> do).

d134 1
a134 1
hash is in the hash referenced by C<(tied(%tiedhash))-E<gt>[0]>.  Thus overwritten
d159 1
a159 1
=head1 C<SCALAR>, C<UNTIE> and C<DESTROY>
a165 2
C<SCALAR> is only defined in B<Tie::StdHash> and B<Tie::ExtraHash>.

d167 1
a167 2
B<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<pertie/"SCALAR">
to find out what happens when C<SCALAR> does not exist.
a232 1
sub SCALAR   { scalar %{$_[0]} }
a243 1
sub SCALAR   { scalar %{$_[0][0]} }
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
our $VERSION = '1.02';
d170 1
a170 1
presence of these methods, but if defined, the methods will be called in
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d14 1
a14 1
    @@ISA = qw(Tie::Hash);
d23 1
a23 1
    @@ISA = qw(Tie::StdHash);
d33 1
a33 1
    @@ISA = qw(Tie::ExtraHash);
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d3 1
a3 1
our $VERSION = '1.03';
d176 1
a176 1
B<Tie::Hash>, B<Tie::StdHash>, or B<Tie::ExtraHash>. See L<perltie/"SCALAR">
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
our $VERSION = '1.04';
d200 3
a202 14
    my $pkg_new = $pkg -> can ('new');

    if ($pkg_new and $pkg ne __PACKAGE__) {
        my $my_new = __PACKAGE__ -> can ('new');
        if ($pkg_new == $my_new) {  
            #
            # Prevent recursion
            #
            croak "$pkg must define either a TIEHASH() or a new() method";
        }

	warnings::warnif ("WARNING: calling ${pkg}->new since " .
                          "${pkg}->TIEHASH is missing");
	$pkg -> new (@@_);
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d3 1
a3 1
our $VERSION = '1.05';
d25 1
a25 2
    # All methods provided by default, define
    # only those needing overrides
d35 1
a35 2
    # All methods provided by default, define 
    # only those needing overrides
d37 2
a38 2
    # TIEHASH should return an array reference with the first element
    # being the reference to the actual storage 
@


