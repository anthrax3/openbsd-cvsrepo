head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.1.1.4.0.14
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.12
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.6
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.8
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.4.0.4
	OPENBSD_5_6_BASE:1.1.1.4
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.3.0.6
	OPENBSD_5_5_BASE:1.1.1.3
	OPENBSD_5_4:1.1.1.3.0.2
	OPENBSD_5_4_BASE:1.1.1.3
	PERL_5_16_3:1.1.1.3
	OPENBSD_5_3:1.1.1.2.0.36
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.34
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.32
	OPENBSD_5_0:1.1.1.2.0.30
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.28
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.26
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.22
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.24
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.20
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.18
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.16
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.14
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.12
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.10
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.8
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.6
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.4
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.2
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.2
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2004.08.09.17.46.41;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2013.03.25.20.08.51;	author sthen;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl -- -*- mode: cperl; cperl-indent-level: 4 -*-

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
}

use strict;

$|=1;

my @@prgs;
{
    local $/;
    @@prgs = split "########\n", <DATA>;
    close DATA;
}

use Test::More;

plan tests => scalar @@prgs;

require "dumpvar.pl";

sub unctrl    { print dumpvar::unctrl($_[0]), "\n" }
sub uniescape { print dumpvar::uniescape($_[0]), "\n" }
sub stringify { print dumpvar::stringify($_[0]), "\n" }
sub dumpvalue { 
	# Call main::dumpValue exactly as the perl5db.pl calls it.
        local $\ = '';
        local $, = '';
        local $" = ' ';
        my @@params = @@_;
        &main::dumpValue(\@@params,-1);
}

package Foo;

sub new { my $class = shift; bless [ @@_ ], $class }

package Bar;

sub new { my $class = shift; bless [ @@_ ], $class }

use overload '""' => sub { "Bar<@@{$_[0]}>" };

package main;

my $foo = Foo->new(1..5);
my $bar = Bar->new(1..5);

for (@@prgs) {
    my($prog, $expected) = split(/\nEXPECT\n?/, $_);
    # TODO: dumpvar::stringify() is controlled by a pile of package
    # dumpvar variables: $printUndef, $unctrl, $quoteHighBit, $bareStringify,
    # and so forth.  We need to test with various settings of those.
    my $out = tie *STDOUT, 'TieOut';
    eval $prog;
    my $ERR = $@@;
    untie $out;
    if ($ERR) {
        ok(0, "$prog - $ERR");
    } else {
	if ($expected =~ m:^/:) {
	    like($$out, $expected, $prog);
	} else {
	    is($$out, $expected, $prog);
	}
    }
}

package TieOut;

sub TIEHANDLE {
    bless( \(my $self), $_[0] );
}

sub PRINT {
    my $self = shift;
    $$self .= join('', @@_);
}

sub read {
    my $self = shift;
    substr( $$self, 0, length($$self), '' );
}

__END__
unctrl("A");
EXPECT
A
########
unctrl("\cA");
EXPECT
^A
########
uniescape("A");
EXPECT
A
########
uniescape("\x{100}");
EXPECT
\x{0100}
########
stringify(undef);
EXPECT
undef
########
stringify("foo");
EXPECT
'foo'
########
stringify("\cA");
EXPECT
"\cA"
########
stringify(*a);
EXPECT
*main::a
########
stringify(\undef);
EXPECT
/^'SCALAR\(0x[0-9a-f]+\)'$/i
########
stringify([]);
EXPECT
/^'ARRAY\(0x[0-9a-f]+\)'$/i
########
stringify({});
EXPECT
/^'HASH\(0x[0-9a-f]+\)'$/i
########
stringify(sub{});
EXPECT
/^'CODE\(0x[0-9a-f]+\)'$/i
########
stringify(\*a);
EXPECT
/^'GLOB\(0x[0-9a-f]+\)'$/i
########
stringify($foo);
EXPECT
/^'Foo=ARRAY\(0x[0-9a-f]+\)'$/i
########
stringify($bar);
EXPECT
/^'Bar=ARRAY\(0x[0-9a-f]+\)'$/i
########
dumpValue(undef);
EXPECT
undef
########
dumpValue(1);
EXPECT
1
########
dumpValue("\cA");
EXPECT
"\cA"
########
dumpValue("\x{100}");
EXPECT
'\x{0100}'
########
dumpValue("1\n2\n3");
EXPECT
'1
2
3'
########
dumpValue([1..3],1);
EXPECT
0  1
1  2
2  3
########
dumpValue([1..3]);
EXPECT
0  1
1  2
2  3
########
dumpValue({1..4},1);
EXPECT
1 => 2
3 => 4
########
dumpValue({1..4});
EXPECT
1 => 2
3 => 4
########
dumpValue($foo,1);
EXPECT
0  1
1  2
2  3
3  4
4  5
########
dumpValue($foo);
EXPECT
0  1
1  2
2  3
3  4
4  5
########
dumpValue($bar,1);
EXPECT
0  1
1  2
2  3
3  4
4  5
########
dumpValue($bar);
EXPECT
0  1
1  2
2  3
3  4
4  5
########
dumpvalue("a");
EXPECT
0  'a'
########
dumpvalue("\cA");
EXPECT
0  "\cA"
########
dumpvalue("\x{100}");
EXPECT
0  '\x{0100}'
########
dumpvalue(undef);
EXPECT
0  undef
########
dumpvalue("foo");
EXPECT
0  'foo'
########
dumpvalue(\undef);
EXPECT
/0  SCALAR\(0x[0-9a-f]+\)\n   -> undef\n/i
########
dumpvalue(\\undef);
EXPECT
/0  REF\(0x[0-9a-f]+\)\n   -> SCALAR\(0x[0-9a-f]+\)\n         -> undef\n/i
########
dumpvalue([]);
EXPECT
/0  ARRAY\(0x[0-9a-f]+\)\n     empty array/i
########
dumpvalue({});
EXPECT
/0  HASH\(0x[0-9a-f]+\)\n\s+empty hash/i
########
dumpvalue(sub{});
EXPECT
/0  CODE\(0x[0-9a-f]+\)\n   -> &CODE\(0x[0-9a-f]+\) in /i
########
dumpvalue(\*a);
EXPECT
/0  GLOB\(0x[0-9a-f]+\)\n   -> \*main::a\n/i
########
dumpvalue($foo);
EXPECT
/0  Foo=ARRAY\(0x[0-9a-f]+\)\n   0  1\n   1  2\n   2  3\n   3  4\n   4  5\n/i
########
dumpvalue($bar);
EXPECT
/0  Bar=ARRAY\(0x[0-9a-f]+\)\n   0  1\n   1  2\n   2  3\n   3  4\n   4  5\n/i
########
dumpvalue("1\n2\n3")
EXPECT
/0  '1\n2\n3'\n/i
########
dumpvalue([1..4]);
EXPECT
/0  ARRAY\(0x[0-9a-f]+\)\n   0  1\n   1  2\n   2  3\n   3  4\n/i
########
dumpvalue({1..4});
EXPECT
/0  HASH\(0x[0-9a-f]+\)\n   1 => 2\n   3 => 4\n/i
########
dumpvalue({1=>2,3=>4});
EXPECT
/0  HASH\(0x[0-9a-f]+\)\n   1 => 2\n   3 => 4\n/i
########
dumpvalue({a=>1,b=>2});
EXPECT
/0  HASH\(0x[0-9a-f]+\)\n   'a' => 1\n   'b' => 2\n/i
########
dumpvalue([{a=>[1,2,3],b=>{c=>1,d=>2}},{e=>{f=>1,g=>2},h=>[qw(i j k)]}]);
EXPECT
/0  ARRAY\(0x[0-9a-f]+\)\n   0  HASH\(0x[0-9a-f]+\)\n      'a' => ARRAY\(0x[0-9a-f]+\)\n         0  1\n         1  2\n         2  3\n      'b' => HASH\(0x[0-9a-f]+\)\n         'c' => 1\n         'd' => 2\n   1  HASH\(0x[0-9a-f]+\)\n      'e' => HASH\(0x[0-9a-f]+\)\n         'f' => 1\n         'g' => 2\n      'h' => ARRAY\(0x[0-9a-f]+\)\n         0  'i'\n         1  'j'\n         2  'k'/i
########
dumpvalue({reverse map {$_=>1} sort qw(the quick brown fox)})
EXPECT
/0  HASH\(0x[0-9a-f]+\)\n   1 => 'brown'\n/i
########
my @@x=qw(a b c); dumpvalue(\@@x);
EXPECT
/0  ARRAY\(0x[0-9a-f]+\)\n   0  'a'\n   1  'b'\n   2  'c'\n/i
########
my %x=(a=>1, b=>2); dumpvalue(\%x);
EXPECT
/0  HASH\(0x[0-9a-f]+\)\n   'a' => 1\n   'b' => 2\n/i
@


1.1.1.1
log
@perl 5.8.2 from CPAN
@
text
@@


1.1.1.2
log
@Import of stock perl 5.8.5
@
text
@a5 5
    require Config;
    if (($Config::Config{'extensions'} !~ m!\bList/Util\b!) ){
	print "1..0 # Skip -- Perl configured without List::Util module\n";
	exit 0;
    }
@


1.1.1.3
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a51 5
package Tyre;

sub TIESCALAR{bless[]}
# other methods intentionally omitted

a316 12
########
dumpvalue(bless[1,2,3,4],"a=b=c");
EXPECT
/0  a=b=c=ARRAY\(0x[0-9a-f]+\)\n   0  1\n   1  2\n   2  3\n   3  4\n/i
########
local *_; tie $_, 'Tyre'; stringify('');
EXPECT
''
########
local *_; tie $_, 'Tyre'; unctrl('abc');
EXPECT
abc
@


1.1.1.4
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a56 5
package Kerb;

sub TIEHASH{bless{}}
# other methods intentionally omitted

a333 4
########
tie my %h, 'Kerb'; my $v = { a => 1, b => \%h, c => 2 }; dumpvalue($v);
EXPECT
/'a' => 1\n.+Can't locate object method.+'c' => 2/s
@


