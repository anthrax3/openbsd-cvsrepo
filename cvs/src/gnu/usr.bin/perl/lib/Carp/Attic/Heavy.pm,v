head	1.2;
access;
symbols
	OPENBSD_5_3:1.1.1.7.0.10
	OPENBSD_5_3_BASE:1.1.1.7
	OPENBSD_5_2:1.1.1.7.0.8
	OPENBSD_5_2_BASE:1.1.1.7
	OPENBSD_5_1_BASE:1.1.1.7
	OPENBSD_5_1:1.1.1.7.0.6
	OPENBSD_5_0:1.1.1.7.0.4
	OPENBSD_5_0_BASE:1.1.1.7
	OPENBSD_4_9:1.1.1.7.0.2
	OPENBSD_4_9_BASE:1.1.1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.1.1.6.0.8
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.4
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.8
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.6
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.4
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.6
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2013.03.25.20.40.56;	author sthen;	state dead;
branches;
next	1.1;

1.1
date	2000.04.06.16.09.41;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.41;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.23.26;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.46.48;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.40;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.32;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.41;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@package Carp;

=head1 NAME

Carp::Heavy - Carp guts

=head1 SYNOPIS

(internal use only)

=head1 DESCRIPTION

No user-serviceable parts inside.

=cut

# This package is heavily used. Be small. Be fast. Be good.

# Comments added by Andy Wardley <abw@@kfs.org> 09-Apr-98, based on an
# _almost_ complete understanding of the package.  Corrections and
# comments are welcome.

# longmess() crawls all the way up the stack reporting on all the function
# calls made.  The error string, $error, is originally constructed from the
# arguments passed into longmess() via confess(), cluck() or shortmess().
# This gets appended with the stack trace messages which are generated for
# each function call on the stack.

sub longmess_heavy {
    return @@_ if ref $_[0];
    my $error = join '', @@_;
    my $mess = "";
    my $i = 1 + $CarpLevel;
    my ($pack,$file,$line,$sub,$hargs,$eval,$require);
    my (@@a);
    #
    # crawl up the stack....
    #
    while (do { { package DB; @@a = caller($i++) } } ) {
	# get copies of the variables returned from caller()
	($pack,$file,$line,$sub,$hargs,undef,$eval,$require) = @@a;
	#
	# if the $error error string is newline terminated then it
	# is copied into $mess.  Otherwise, $mess gets set (at the end of
	# the 'else {' section below) to one of two things.  The first time
	# through, it is set to the "$error at $file line $line" message.
	# $error is then set to 'called' which triggers subsequent loop
	# iterations to append $sub to $mess before appending the "$error
	# at $file line $line" which now actually reads "called at $file line
	# $line".  Thus, the stack trace message is constructed:
	#
	#        first time: $mess  = $error at $file line $line
	#  subsequent times: $mess .= $sub $error at $file line $line
	#                                  ^^^^^^
	#                                 "called"
	if ($error =~ m/\n$/) {
	    $mess .= $error;
	} else {
	    # Build a string, $sub, which names the sub-routine called.
	    # This may also be "require ...", "eval '...' or "eval {...}"
	    if (defined $eval) {
		if ($require) {
		    $sub = "require $eval";
		} else {
		    $eval =~ s/([\\\'])/\\$1/g;
		    if ($MaxEvalLen && length($eval) > $MaxEvalLen) {
			substr($eval,$MaxEvalLen) = '...';
		    }
		    $sub = "eval '$eval'";
		}
	    } elsif ($sub eq '(eval)') {
		$sub = 'eval {...}';
	    }
	    # if there are any arguments in the sub-routine call, format
	    # them according to the format variables defined earlier in
	    # this file and join them onto the $sub sub-routine string
	    if ($hargs) {
		# we may trash some of the args so we take a copy
		@@a = @@DB::args;	# must get local copy of args
		# don't print any more than $MaxArgNums
		if ($MaxArgNums and @@a > $MaxArgNums) {
		    # cap the length of $#a and set the last element to '...'
		    $#a = $MaxArgNums;
		    $a[$#a] = "...";
		}
		for (@@a) {
		    # set args to the string "undef" if undefined
		    $_ = "undef", next unless defined $_;
		    if (ref $_) {
			# force reference to string representation
			$_ .= '';
			s/'/\\'/g;
		    }
		    else {
			s/'/\\'/g;
			# terminate the string early with '...' if too long
			substr($_,$MaxArgLen) = '...'
			    if $MaxArgLen and $MaxArgLen < length;
		    }
		    # 'quote' arg unless it looks like a number
		    $_ = "'$_'" unless /^-?[\d.]+$/;
		    # print high-end chars as 'M-<char>'
		    s/([\200-\377])/sprintf("M-%c",ord($1)&0177)/eg;
		    # print remaining control chars as ^<char>
		    s/([\0-\37\177])/sprintf("^%c",ord($1)^64)/eg;
		}
		# append ('all', 'the', 'arguments') to the $sub string
		$sub .= '(' . join(', ', @@a) . ')';
	    }
	    # here's where the error message, $mess, gets constructed
	    $mess .= "\t$sub " if $error eq "called";
	    $mess .= "$error at $file line $line";
	    if (defined &Thread::tid) {
		my $tid = Thread->self->tid;
		$mess .= " thread $tid" if $tid;
	    }
	    $mess .= "\n";
	}
	# we don't need to print the actual error message again so we can
	# change this to "called" so that the string "$error at $file line
	# $line" makes sense as "called at $file line $line".
	$error = "called";
    }
    # this kludge circumvents die's incorrect handling of NUL
    my $msg = \($mess || $error);
    $$msg =~ tr/\0//d;
    $$msg;
}


# ancestors() returns the complete set of ancestors of a module

sub ancestors($$);

sub ancestors($$){
    my( $pack, $href ) = @@_;
    if( @@{"${pack}::ISA"} ){
	my $risa = \@@{"${pack}::ISA"};
	my %tree  = ();
	@@tree{@@$risa} = ();
	foreach my $mod ( @@$risa ){
	    # visit ancestors - if not already in the gallery
	    if( ! defined( $$href{$mod} ) ){
		my @@ancs = ancestors( $mod, $href );
		@@tree{@@ancs} = ();
	    }
	}
	return ( keys( %tree ) );
    } else {
	return ();
    }
}


# shortmess() is called by carp() and croak() to skip all the way up to
# the top-level caller's package and report the error from there.  confess()
# and cluck() generate a full stack trace so they call longmess() to
# generate that.  In verbose mode shortmess() calls longmess() so
# you always get a stack trace

sub shortmess_heavy {	# Short-circuit &longmess if called via multiple packages
    goto &longmess_heavy if $Verbose;
    return @@_ if ref $_[0];
    my $error = join '', @@_;
    my ($prevpack) = caller(1);
    my $extra = $CarpLevel;

    my @@Clans = ( $prevpack );
    my $i = 2;
    my ($pack,$file,$line);
    # when reporting an error, we want to report it from the context of the
    # calling package.  So what is the calling package?  Within a module,
    # there may be many calls between methods and perhaps between sub-classes
    # and super-classes, but the user isn't interested in what happens
    # inside the package.  We start by building a hash array which keeps
    # track of all the packages to which the calling package belongs.  We
    # do this by examining its @@ISA variable.  Any call from a base class
    # method (one of our caller's @@ISA packages) can be ignored
    my %isa;

    # merge all the caller's @@ISA packages and ancestors into %isa.
    my @@pars = ancestors( $prevpack, \%isa );
    @@isa{@@pars} = () if @@pars;
    $isa{$prevpack} = 1;

    # now we crawl up the calling stack and look at all the packages in
    # there.  For each package, we look to see if it has an @@ISA and then
    # we see if our caller features in that list.  That would imply that
    # our caller is a derived class of that package and its calls can also
    # be ignored
CALLER:
    while (($pack,$file,$line) = caller($i++)) {

        # Chances are, the caller's caller (or its caller...) is already
        # in the gallery - if so, ignore this caller.
        next if exists( $isa{$pack} );

        # no: collect this module's ancestors.
        my @@i = ancestors( $pack, \%isa );
        my %i;
        if( @@i ){
 	    @@i{@@i} = ();
            # check whether our representative of one of the clans is
            # in this family tree.
	    foreach my $cl (@@Clans){
                if( exists( $i{$cl} ) ){
    	            # yes: merge all of the family tree into %isa
	            @@isa{@@i,$pack} = ();
		    # and here's where we do some more ignoring...
		    # if the package in question is one of our caller's
		    # base or derived packages then we can ignore it (skip it)
		    # and go onto the next.
		    next CALLER if exists( $isa{$pack} );
		    last;
		}
            }
	}

	# Hey!  We've found a package that isn't one of our caller's
	# clan....but wait, $extra refers to the number of 'extra' levels
	# we should skip up.  If $extra > 0 then this is a false alarm.
	# We must merge the package into the %isa hash (so we can ignore it
	# if it pops up again), decrement $extra, and continue.
	if ($extra-- > 0) {
	    push( @@Clans, $pack );
	    @@isa{@@i,$pack} = ();
	}
	else {
	    # OK!  We've got a candidate package.  Time to construct the
	    # relevant error message and return it.   die() doesn't like
	    # to be given NUL characters (which $msg may contain) so we
	    # remove them first.
	    my $msg;
	    $msg = "$error at $file line $line";
	    if (defined &Thread::tid) {
		my $tid = Thread->self->tid;
		$mess .= " thread $tid" if $tid;
	    }
	    $msg .= "\n";
	    $msg =~ tr/\0//d;
	    return $msg;
	}
    }

    # uh-oh!  It looks like we crawled all the way up the stack and
    # never found a candidate package.  Oh well, let's call longmess
    # to generate a full stack trace.  We use the magical form of 'goto'
    # so that this shortmess() function doesn't appear on the stack
    # to further confuse longmess() about it's calling package.
    goto &longmess_heavy;
}

1;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d45 1
a45 1
	# the 'else' section below) to one of two things.  The first time
d124 4
a127 1
    $mess || $error;
d230 3
a232 1
	    # relevant error message and return it.
d237 1
a237 1
		$msg .= " thread $tid" if $tid;
d240 1
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a0 1
# Carp::Heavy uses some variables in common with Carp.
d5 1
a5 1
Carp heavy machinery - no user serviceable parts inside
d7 1
a7 1
=cut
d9 1
a9 1
# use strict; # not yet
d11 1
a11 2
# On one line so MakeMaker will see it.
use Carp;  our $VERSION = $Carp::VERSION;
d13 1
a13 1
our ($CarpLevel, $MaxArgNums, $MaxEvalLen, $MaxArgLen, $Verbose);
d15 1
a15 25
sub caller_info {
  my $i = shift(@@_) + 1;
  package DB;
  my %call_info;
  @@call_info{
    qw(pack file line sub has_args wantarray evaltext is_require)
  } = caller($i);
  
  unless (defined $call_info{pack}) {
    return ();
  }

  my $sub_name = Carp::get_subname(\%call_info);
  if ($call_info{has_args}) {
    my @@args = map {Carp::format_arg($_)} @@DB::args;
    if ($MaxArgNums and @@args > $MaxArgNums) { # More than we want to show?
      $#args = $MaxArgNums;
      push @@args, '...';
    }
    # Push the args onto the subroutine
    $sub_name .= '(' . join (',', @@args) . ')';
  }
  $call_info{sub_name} = $sub_name;
  return wantarray() ? %call_info : \%call_info;
}
d17 1
a17 21
# Transform an argument to a function into a string.
sub format_arg {
  my $arg = shift;
  if (not defined($arg)) {
    $arg = 'undef';
  }
  elsif (ref($arg)) {
      $arg = defined($overload::VERSION) ? overload::StrVal($arg) : "$arg";
  }
  $arg =~ s/'/\\'/g;
  $arg = str_len_trim($arg, $MaxArgLen);
  
  # Quote it?
  $arg = "'$arg'" unless $arg =~ /^-?[\d.]+\z/;

  # The following handling of "control chars" is direct from
  # the original code - I think it is broken on Unicode though.
  # Suggestions?
  $arg =~ s/([[:cntrl:]]|[[:^ascii:]])/sprintf("\\x{%x}",ord($1))/eg;
  return $arg;
}
d19 9
a27 10
# Takes an inheritance cache and a package and returns
# an anon hash of known inheritances and anon array of
# inheritances which consequences have not been figured
# for.
sub get_status {
    my $cache = shift;
    my $pkg = shift;
    $cache->{$pkg} ||= [{$pkg => $pkg}, [trusts_directly($pkg)]];
    return @@{$cache->{$pkg}};
}
d29 94
a122 8
# Takes the info from caller() and figures out the name of
# the sub/require/eval
sub get_subname {
  my $info = shift;
  if (defined($info->{evaltext})) {
    my $eval = $info->{evaltext};
    if ($info->{is_require}) {
      return "require $eval";
d124 1
a124 7
    else {
      $eval =~ s/([\\\'])/\\$1/g;
      return "eval '" . str_len_trim($eval, $MaxEvalLen) . "'";
    }
  }

  return ($info->{sub} eq '(eval)') ? 'eval {...}' : $info->{sub};
a126 25
# Figures out what call (from the point of view of the caller)
# the long error backtrace should start at.
sub long_error_loc {
  my $i;
  my $lvl = $CarpLevel;
  {
    my $pkg = caller(++$i);
    unless(defined($pkg)) {
      # This *shouldn't* happen.
      if (%Internal) {
        local %Internal;
        $i = long_error_loc();
        last;
      }
      else {
        # OK, now I am irritated.
        return 2;
      }
    }
    redo if $CarpInternal{$pkg};
    redo unless 0 > --$lvl;
    redo if $Internal{$pkg};
  }
  return $i - 1;
}
d128 1
d130 1
a130 5
sub longmess_heavy {
  return @@_ if ref($_[0]); # don't break references as exceptions
  my $i = long_error_loc();
  return ret_backtrace($i, @@_);
}
d132 17
a148 73
# Returns a full stack backtrace starting from where it is
# told.
sub ret_backtrace {
  my ($i, @@error) = @@_;
  my $mess;
  my $err = join '', @@error;
  $i++;

  my $tid_msg = '';
  if (defined &Thread::tid) {
    my $tid = Thread->self->tid;
    $tid_msg = " thread $tid" if $tid;
  }

  { if ($err =~ /\n$/) {	# extra block to localise $1 etc
    $mess = $err;
  }
  else {
    my %i = caller_info($i);
    $mess = "$err at $i{file} line $i{line}$tid_msg\n";
  }}

  while (my %i = caller_info(++$i)) {
      $mess .= "\t$i{sub_name} called at $i{file} line $i{line}$tid_msg\n";
  }
  
  return $mess;
}

sub ret_summary {
  my ($i, @@error) = @@_;
  my $mess;
  my $err = join '', @@error;
  $i++;

  my $tid_msg = '';
  if (defined &Thread::tid) {
    my $tid = Thread->self->tid;
    $tid_msg = " thread $tid" if $tid;
  }

  my %i = caller_info($i);
  return "$err at $i{file} line $i{line}$tid_msg\n";
}


sub short_error_loc {
  my $cache;
  my $i = 1;
  my $lvl = $CarpLevel;
  {
    my $called = caller($i++);
    my $caller = caller($i);
    return 0 unless defined($caller); # What happened?
    redo if $Internal{$caller};
    redo if $CarpInternal{$called};
    redo if trusts($called, $caller, $cache);
    redo if trusts($caller, $called, $cache);
    redo unless 0 > --$lvl;
  }
  return $i - 1;
}

sub shortmess_heavy {
  return longmess_heavy(@@_) if $Verbose;
  return @@_ if ref($_[0]); # don't break references as exceptions
  my $i = short_error_loc();
  if ($i) {
    ret_summary($i, @@_);
  }
  else {
    longmess_heavy(@@_);
  }
a150 9
# If a string is too long, trims it with ...
sub str_len_trim {
  my $str = shift;
  my $max = shift || 0;
  if (2 < $max and $max < length($str)) {
    substr($str, $max - 3) = '...';
  }
  return $str;
}
d152 85
a236 20
# Takes two packages and an optional cache.  Says whether the
# first inherits from the second.
#
# Recursive versions of this have to work to avoid certain
# possible endless loops, and when following long chains of
# inheritance are less efficient.
sub trusts {
    my $child = shift;
    my $parent = shift;
    my $cache = shift || {};
    my ($known, $partial) = get_status($cache, $child);
    # Figure out consequences until we have an answer
    while (@@$partial and not exists $known->{$parent}) {
        my $anc = shift @@$partial;
        next if exists $known->{$anc};
        $known->{$anc}++;
        my ($anc_knows, $anc_partial) = get_status($cache, $anc);
        my @@found = keys %$anc_knows;
        @@$known{@@found} = ();
        push @@$partial, @@$anc_partial;
a237 2
    return exists $known->{$parent};
}
d239 6
a244 8
# Takes a package and gives a list of those trusted directly
sub trusts_directly {
    my $class = shift;
    no strict 'refs';
    no warnings 'once'; 
    return @@{"$class\::CARP_NOT"}
      ? @@{"$class\::CARP_NOT"}
      : @@{"$class\::ISA"};
a247 1

@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d6 1
a6 1
Carp::Heavy - heavy machinery, no user serviceable parts inside
d37 1
a37 1
    $sub_name .= '(' . join (', ', @@args) . ')';
d141 7
a147 2
  my %i = caller_info($i);
  $mess = "$err at $i{file} line $i{line}$tid_msg\n";
d158 1
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d46 4
a49 1
  if (ref($arg)) {
a50 2
  }elsif (not defined($arg)) {
    $arg = 'undef';
d59 1
a59 1
  # the original code - it is broken on Unicode though.
d61 1
a61 2
  utf8::is_utf8($arg)
    or $arg =~ s/([[:cntrl:]]|[[:^ascii:]])/sprintf("\\x{%x}",ord($1))/eg;
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d10 2
a13 21
# use strict; # not yet

# 'use Carp' just installs some very lightweight stubs; the first time
# these are called, they require Carp::Heavy which installs the real
# routines.

# The members of %Internal are packages that are internal to perl.
# Carp will not report errors from within these packages if it
# can.  The members of %CarpInternal are internal to Perl's warning
# system.  Carp will not report errors from within these packages
# either, and will not report calls *to* these packages for carp and
# croak.  They replace $CarpLevel, which is deprecated.    The
# $Max(EvalLen|(Arg(Len|Nums)) variables are used to specify how the eval
# text and function arguments should be formatted when printed.

# disable these by default, so they can live w/o require Carp
$CarpInternal{Carp}++;
$CarpInternal{warnings}++;
$Internal{Exporter}++;
$Internal{'Exporter::Heavy'}++;

a16 40
# XXX longmess_real and shortmess_real should really be merged into
# XXX {long|sort}mess_heavy at some point

sub  longmess_real {
    # Icky backwards compatibility wrapper. :-(
    #
    # The story is that the original implementation hard-coded the
    # number of call levels to go back, so calls to longmess were off
    # by one.  Other code began calling longmess and expecting this
    # behaviour, so the replacement has to emulate that behaviour.
    my $call_pack = caller();
    if ($Internal{$call_pack} or $CarpInternal{$call_pack}) {
      return longmess_heavy(@@_);
    }
    else {
      local $CarpLevel = $CarpLevel + 1;
      return longmess_heavy(@@_);
    }
};

sub shortmess_real {
    # Icky backwards compatibility wrapper. :-(
    local @@CARP_NOT = caller();
    shortmess_heavy(@@_);
};

# replace the two hooks added by Carp

# aliasing the whole glob rather than just the CV slot avoids 'redefined'
# warnings, even in the presence of perl -W (as used by lib/warnings.t !)
# However it has the potential to create infinite loops, if somehow Carp
# is forcibly reloaded, but $INC{"Carp/Heavy.pm"} remains true.
# Hence the extra hack of deleting the previous typeglob first.

delete $Carp::{shortmess_jmp};
delete $Carp::{longmess_jmp};
*longmess_jmp  = *longmess_real;
*shortmess_jmp = *shortmess_real;


d48 2
d51 2
a52 3
  if (defined($arg)) {
      $arg =~ s/'/\\'/g;
      $arg = str_len_trim($arg, $MaxArgLen);
d54 2
a55 5
      # Quote it?
      $arg = "'$arg'" unless $arg =~ /^-?[\d.]+\z/;
  } else {
      $arg = 'undef';
  }
d136 2
a137 2
  if (defined &threads::tid) {
    my $tid = threads->tid;
d157 2
a158 2
  if (defined &threads::tid) {
    my $tid = threads->tid;
d168 1
a168 4
  # You have to create your (hash)ref out here, rather than defaulting it
  # inside trusts *on a lexical*, as you want it to persist across calls.
  # (You can default it on $_[2], but that gets messy)
  my $cache = {};
a173 1

a175 1
    redo if $CarpInternal{$caller};
a183 1

d215 1
a215 1
    my $cache = shift;
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d1 1
d4 6
d12 294
a308 3
# Most of the machinery of Carp used to be there.
# It has been moved in Carp.pm now, but this placeholder remains for
# the benefit of modules that like to preload Carp::Heavy directly.
@


