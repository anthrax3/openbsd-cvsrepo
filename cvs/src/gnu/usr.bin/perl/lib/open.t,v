head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.7.0.16
	OPENBSD_6_0_BASE:1.1.1.7
	OPENBSD_5_9:1.1.1.7.0.10
	OPENBSD_5_9_BASE:1.1.1.7
	OPENBSD_5_8:1.1.1.7.0.12
	OPENBSD_5_8_BASE:1.1.1.7
	PERL_5_20_2:1.1.1.7
	OPENBSD_5_7:1.1.1.7.0.4
	OPENBSD_5_7_BASE:1.1.1.7
	PERL_5_20_1:1.1.1.7
	OPENBSD_5_6:1.1.1.7.0.8
	OPENBSD_5_6_BASE:1.1.1.7
	PERL_5_18_2:1.1.1.7
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.16
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.14
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.12
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.10
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.8
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.6
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.4
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.2
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2005.01.15.21.17.10;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.49;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.48.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.08.52;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl

BEGIN {
	chdir 't' if -d 't';
	@@INC = '../lib';
	require Config; import Config;
	require './test.pl';
	require './charset_tools.pl';
}

plan 23;

# open::import expects 'open' as its first argument, but it clashes with open()
sub import {
	open::import( 'open', @@_ );
}

# can't use require_ok() here, with a name like 'open'
ok( require 'open.pm', 'requiring open' );

# this should fail
eval { import() };
like( $@@, qr/needs explicit list of PerlIO layers/,
	'import should fail without args' );

# prevent it from loading I18N::Langinfo, so we can test encoding failures
my $warn;
local $SIG{__WARN__} = sub {
	$warn .= shift;
};

# and it shouldn't be able to find this layer
$warn = '';
eval q{ no warnings 'layer'; use open IN => ':macguffin' ; };
is( $warn, '',
	'should not warn about unknown layer with bad layer provided' );

$warn = '';
eval q{ use warnings 'layer'; use open IN => ':macguffin' ; };
like( $warn, qr/Unknown PerlIO layer/,
	'should warn about unknown layer with bad layer provided' );

# open :locale logic changed since open 1.04, new logic
# difficult to test portably.

# see if it sets the magic variables appropriately
import( 'IN', ':crlf' );
is( $^H{'open_IN'}, 'crlf', 'should have set crlf layer' );

# it should reset them appropriately, too
import( 'IN', ':raw' );
is( $^H{'open_IN'}, 'raw', 'should have reset to raw layer' );

# it dies if you don't set IN, OUT, or IO
eval { import( 'sideways', ':raw' ) };
like( $@@, qr/Unknown PerlIO layer class/, 'should croak with unknown class' );

# but it handles them all so well together
import( 'IO', ':raw :crlf' );
is( ${^OPEN}, ":raw :crlf\0:raw :crlf",
	'should set multi types, multi layer' );
is( $^H{'open_IO'}, 'crlf', 'should record last layer set in %^H' );

SKIP: {
    skip("no perlio, no :utf8", 12) unless (find PerlIO::Layer 'perlio');

    eval <<EOE;
    use open ':utf8';
    open(O, ">utf8");
    print O chr(0x100);
    close O;
    open(I, "<utf8");
    is(ord(<I>), 0x100, ":utf8 single wide character round-trip");
    close I;
EOE

    open F, ">a";
    @@a = map { chr(1 << ($_ << 2)) } 0..5; # 0x1, 0x10, .., 0x100000
    unshift @@a, chr(0); # ... and a null byte in front just for fun
    print F @@a;
    close F;

    sub systell {
        use Fcntl 'SEEK_CUR';
        sysseek($_[0], 0, SEEK_CUR);
    }

    require bytes; # not use

    my $ok;

    open F, "<:utf8", "a";
    $ok = $a = 0;
    for (@@a) {
        unless (
		($c = sysread(F, $b, 1)) == 1  &&
		length($b)               == 1  &&
		ord($b)                  == ord($_) &&
		systell(F)               == ($a += bytes::length($b))
		) {
	    print '# ord($_)           == ', ord($_), "\n";
	    print '# ord($b)           == ', ord($b), "\n";
	    print '# length($b)        == ', length($b), "\n";
	    print '# bytes::length($b) == ', bytes::length($b), "\n";
	    print '# systell(F)        == ', systell(F), "\n";
	    print '# $a                == ', $a, "\n";
	    print '# $c                == ', $c, "\n";
	    last;
	}
	$ok++;
    }
    close F;
    ok($ok == @@a,
       "on :utf8 streams sysread() should work on characters, not bytes");

    sub diagnostics {
	print '# ord($_)           == ', ord($_), "\n";
	print '# bytes::length($_) == ', bytes::length($_), "\n";
	print '# systell(G)        == ', systell(G), "\n";
	print '# $a                == ', $a, "\n";
	print '# $c                == ', $c, "\n";
    }


    my %actions = (
		   syswrite => sub { syswrite G, shift; },
		   'syswrite len' => sub { syswrite G, shift, 1; },
		   'syswrite len pad' => sub {
		       my $temp = shift() . "\243";
		       syswrite G, $temp, 1; },
		   'syswrite off' => sub { 
		       my $temp = "\351" . shift();
		       syswrite G, $temp, 1, 1; },
		   'syswrite off pad' => sub { 
		       my $temp = "\351" . shift() . "\243";
		       syswrite G, $temp, 1, 1; },
		  );

    foreach my $key (sort keys %actions) {
	# syswrite() on should work on characters, not bytes
	open G, ">:utf8", "b";

	print "# $key\n";
	$ok = $a = 0;
	for (@@a) {
	    unless (
		    ($c = $actions{$key}($_)) == 1 &&
		    systell(G)                == ($a += bytes::length($_))
		   ) {
		diagnostics();
		last;
	    }
	    $ok++;
	}
	close G;
	ok($ok == @@a,
	   "on :utf8 streams syswrite() should work on characters, not bytes");

	open G, "<:utf8", "b";
	$ok = $a = 0;
	for (@@a) {
	    unless (
		    ($c = sysread(G, $b, 1)) == 1 &&
		    length($b)               == 1 &&
		    ord($b)                  == ord($_) &&
		    systell(G)               == ($a += bytes::length($_))
		   ) {
		print '# ord($_)           == ', ord($_), "\n";
		print '# ord($b)           == ', ord($b), "\n";
		print '# length($b)        == ', length($b), "\n";
		print '# bytes::length($b) == ', bytes::length($b), "\n";
		print '# systell(G)        == ', systell(G), "\n";
		print '# $a                == ', $a, "\n";
		print '# $c                == ', $c, "\n";
		last;
	    }
	    $ok++;
	}
	close G;
	ok($ok == @@a,
	   "checking syswrite() output on :utf8 streams by reading it back in");
    }
}
SKIP: {
    skip("no perlio", 1) unless (find PerlIO::Layer 'perlio');
    skip("no Encode", 1) unless $Config{extensions} =~ m{\bEncode\b};
    skip("EBCDIC platform doesnt have 'use encoding' used by open ':locale'", 1)
                                                                if $::IS_EBCDIC;

    eval q[use Encode::Alias;use open ":std", ":locale"];
    is($@@, '', 'can use :std and :locale');
}

{
    local $ENV{PERL_UNICODE};
    delete $ENV{PERL_UNICODE};
    local $TODO;
    $TODO = "Encode not working on EBCDIC" if $::IS_EBCDIC;
    is runperl(
         progs => [
            'use open q\:encoding(UTF-8)\, q-:std-;',
            'use open q\:encoding(UTF-8)\;',
            'if(($_ = <STDIN>) eq qq-\x{100}\n-) { print qq-stdin ok\n- }',
            'else { print qq-got -, join(q q q, map ord, split//), "\n" }',
            'print STDOUT qq-\x{fe}\n-;',
            'print STDERR qq-\x{fe}\n-;',
         ],
         stdin => byte_utf8a_to_utf8n("\xc4\x80") . "\n",
         stderr => 1,
       ),
       "stdin ok\n"
        . byte_utf8a_to_utf8n("\xc3\xbe")
        . "\n"
        . byte_utf8a_to_utf8n("\xc3\xbe")
        . "\n",
       "use open without :std does not affect standard handles",
    ;
}

END {
    1 while unlink "utf8";
    1 while unlink "a";
    1 while unlink "b";
}

# the test cases beyond __DATA__ need to be executed separately

__DATA__
$ENV{LC_ALL} = 'nonexistent.euc';
eval { open::_get_locale_encoding() };
like( $@@, qr/too ambiguous/, 'should die with ambiguous locale encoding' );
%%%
# the special :locale layer
$ENV{LC_ALL} = $ENV{LANG} = 'ru_RU.KOI8-R';
# the :locale will probe the locale environment variables like LANG
use open OUT => ':locale';
open(O, ">koi8");
print O chr(0x430); # Unicode CYRILLIC SMALL LETTER A = KOI8-R 0xc1
close O;
open(I, "<koi8");
printf "%#x\n", ord(<I>), "\n"; # this should print 0xc1
close I;
%%%
@


1.1
log
@Initial revision
@
text
@a5 1
	push @@INC, "::lib:$MacPerl::Architecture:" if $^O eq 'MacOS';
d7 2
d11 1
a11 1
use Test::More tests => 16;
a25 4
# the hint bits shouldn't be set yet
is( $^H & $open::hint_bits, 0,
	'hint bits should not be set in $^H before open import' );

d43 2
a44 8
SKIP: {
    skip("no perlio, no :utf8", 1) unless (find PerlIO::Layer 'perlio');
    # now load a real-looking locale
    $ENV{LC_ALL} = ' .utf8';
    import( 'IN', 'locale' );
    like( ${^OPEN}, qr/^(:utf8)?:utf8\0/,
        'should set a valid locale layer' );
}
d46 1
a46 1
# and see if it sets the magic variables appropriately
a47 2
ok( $^H & $open::hint_bits,
	'hint bits should be set in $^H after open import' );
d65 1
a65 1
    skip("no perlio, no :utf8", 4) unless (find PerlIO::Layer 'perlio');
d116 6
a121 17
    # syswrite() on should work on characters, not bytes
    open G, ">:utf8", "b";
    $ok = $a = 0;
    for (@@a) {
	unless (
		($c = syswrite(G, $_, 1)) == 1 &&
		systell(G)                == ($a += bytes::length($_))
		) {
	    print '# ord($_)           == ', ord($_), "\n";
	    print '# bytes::length($_) == ', bytes::length($_), "\n";
	    print '# systell(G)        == ', systell(G), "\n";
	    print '# $a                == ', $a, "\n";
	    print '# $c                == ', $c, "\n";
	    print "not ";
	    last;
	}
	$ok++;
a122 3
    close G;
    ok($ok == @@a,
       "on :utf8 streams syswrite() should work on characters, not bytes");
d124 54
a177 17
    open G, "<:utf8", "b";
    $ok = $a = 0;
    for (@@a) {
	unless (
		($c = sysread(G, $b, 1)) == 1 &&
		length($b)               == 1 &&
		ord($b)                  == ord($_) &&
		systell(G)               == ($a += bytes::length($_))
		) {
	    print '# ord($_)           == ', ord($_), "\n";
	    print '# ord($b)           == ', ord($b), "\n";
	    print '# length($b)        == ', length($b), "\n";
	    print '# bytes::length($b) == ', bytes::length($b), "\n";
	    print '# systell(G)        == ', systell(G), "\n";
	    print '# $a                == ', $a, "\n";
	    print '# $c                == ', $c, "\n";
	    last;
d179 3
a181 1
	$ok++;
d183 35
a217 3
    close G;
    ok($ok == @@a,
       "checking syswrite() output on :utf8 streams by reading it back in");
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d10 1
a10 1
use Test::More tests => 17;
a47 1
    skip("no Encode for locale layer", 1) unless eval { require Encode }; 
a171 10
}

SKIP: {
    skip("no perlio", 1) unless (find PerlIO::Layer 'perlio');
    use open IN => ':non-existent';
    eval {
	require Symbol; # Anything that exists but we havn't loaded
    };
    like($@@, qr/Can't locate Symbol|Recursive call/i,
	 "test for an endless loop in PerlIO_find_layer");
@


1.1.1.3
log
@perl 5.8.6 from CPAN
@
text
@d10 1
a10 1
use Test::More tests => 16;
d46 9
a54 2
# open :locale logic changed since open 1.04, new logic
# difficult to test portably.
d56 1
a56 1
# see if it sets the magic variables appropriately
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d10 1
a10 1
use Test::More tests => 22;
d25 4
d51 2
d70 1
a70 1
    skip("no perlio, no :utf8", 12) unless (find PerlIO::Layer 'perlio');
d121 17
a137 6
    sub diagnostics {
	print '# ord($_)           == ', ord($_), "\n";
	print '# bytes::length($_) == ', bytes::length($_), "\n";
	print '# systell(G)        == ', systell(G), "\n";
	print '# $a                == ', $a, "\n";
	print '# $c                == ', $c, "\n";
d139 3
d143 17
a159 30

    my %actions = (
		   syswrite => sub { syswrite G, shift; },
		   'syswrite len' => sub { syswrite G, shift, 1; },
		   'syswrite len pad' => sub {
		       my $temp = shift() . "\243";
		       syswrite G, $temp, 1; },
		   'syswrite off' => sub { 
		       my $temp = "\351" . shift();
		       syswrite G, $temp, 1, 1; },
		   'syswrite off pad' => sub { 
		       my $temp = "\351" . shift() . "\243";
		       syswrite G, $temp, 1, 1; },
		  );

    foreach my $key (sort keys %actions) {
	# syswrite() on should work on characters, not bytes
	open G, ">:utf8", "b";

	print "# $key\n";
	$ok = $a = 0;
	for (@@a) {
	    unless (
		    ($c = $actions{$key}($_)) == 1 &&
		    systell(G)                == ($a += bytes::length($_))
		   ) {
		diagnostics();
		last;
	    }
	    $ok++;
d161 1
a161 27
	close G;
	ok($ok == @@a,
	   "on :utf8 streams syswrite() should work on characters, not bytes");

	open G, "<:utf8", "b";
	$ok = $a = 0;
	for (@@a) {
	    unless (
		    ($c = sysread(G, $b, 1)) == 1 &&
		    length($b)               == 1 &&
		    ord($b)                  == ord($_) &&
		    systell(G)               == ($a += bytes::length($_))
		   ) {
		print '# ord($_)           == ', ord($_), "\n";
		print '# ord($b)           == ', ord($b), "\n";
		print '# length($b)        == ', length($b), "\n";
		print '# bytes::length($b) == ', bytes::length($b), "\n";
		print '# systell(G)        == ', systell(G), "\n";
		print '# $a                == ', $a, "\n";
		print '# $c                == ', $c, "\n";
		last;
	    }
	    $ok++;
	}
	close G;
	ok($ok == @@a,
	   "checking syswrite() output on :utf8 streams by reading it back in");
d163 3
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d10 1
a10 1
use Test::More tests => 23;
d183 1
d185 1
a185 5
    skip("no perlio", 2) unless (find PerlIO::Layer 'perlio');

    eval q[use Encode::Alias;use open ":std", ":locale"];
    is($@@, '', 'can use :std and :locale');

@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d6 1
a184 1
    skip("no Encode", 2) unless $Config{extensions} =~ m{\bEncode\b};
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a6 1
	require './test.pl';
d9 1
a9 1
plan 23;
a187 1
}
d189 6
a194 18
{
    local $ENV{PERL_UNICODE};
    delete $ENV{PERL_UNICODE};
    is runperl(
         progs => [
            'use open q\:encoding(UTF-8)\, q-:std-;',
            'use open q\:encoding(UTF-8)\;',
            'if(($_ = <STDIN>) eq qq-\x{100}\n-) { print qq-stdin ok\n- }',
            'else { print qq-got -, join(q q q, map ord, split//), "\n" }',
            'print STDOUT qq-\x{ff}\n-;',
            'print STDERR qq-\x{ff}\n-;',
         ],
         stdin => "\xc4\x80\n",
         stderr => 1,
       ),
       "stdin ok\n\xc3\xbf\n\xc3\xbf\n",
       "use open without :std does not affect standard handles",
    ;
@


