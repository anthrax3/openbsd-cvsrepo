head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.5.0.8
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.4
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.42;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.06;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.47.18;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.48.52;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.38;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!/usr/bin/perl -w

use strict;
use Test;

BEGIN
  {
  $| = 1;
  chdir 't' if -d 't';
  unshift @@INC, '../lib'; # for running manually
  plan tests => 10;
  } 

# test whether Math::BigInt constant works

use Math::BigInt;

ok (Math::BigInt->can('config'));

my $cfg = Math::BigInt->config();

ok (ref($cfg),'HASH');

ok ($cfg->{lib},'Math::BigInt::Calc');
ok ($cfg->{lib_version}, $Math::BigInt::Calc::VERSION);
ok ($cfg->{class},'Math::BigInt');
ok ($cfg->{upgrade}||'','');
ok ($cfg->{div_scale},40);

ok ($cfg->{precision}||0,0);	# should test for undef
ok ($cfg->{accuracy}||0,0);

ok ($cfg->{round_mode},'even');

# all tests done

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d11 1
a11 1
  plan tests => 51;
d14 1
a14 1
# test whether Math::BigInt->config() and Math::BigFloat->config() works
a16 1
use Math::BigFloat;
d18 1
a18 1
my $mbi = 'Math::BigInt'; my $mbf = 'Math::BigFloat';
d20 1
a20 29
##############################################################################
# BigInt

ok ($mbi->can('config'));

my $cfg = $mbi->config();

ok (ref($cfg),'HASH');

ok ($cfg->{lib},'Math::BigInt::Calc');
ok ($cfg->{lib_version}, $Math::BigInt::Calc::VERSION);
ok ($cfg->{class},$mbi);
ok ($cfg->{upgrade}||'','');
ok ($cfg->{div_scale},40);

ok ($cfg->{precision}||0,0);	# should test for undef
ok ($cfg->{accuracy}||0,0);

ok ($cfg->{round_mode},'even');

ok ($cfg->{trap_nan},0);
ok ($cfg->{trap_inf},0);

##############################################################################
# BigFloat

ok ($mbf->can('config'));

$cfg = $mbf->config();
a24 1
ok ($cfg->{with},$mbi);
d26 1
a26 1
ok ($cfg->{class},$mbf);
a33 54

ok ($cfg->{trap_nan},0);
ok ($cfg->{trap_inf},0);

##############################################################################
# test setting values

my $test = {
   trap_nan => 1, 
   trap_inf => 1, 
   accuracy => 2,
   precision => 3,
   round_mode => 'zero',
   div_scale => '100',
   upgrade => 'Math::BigInt::SomeClass',
   downgrade => 'Math::BigInt::SomeClass',
  };

my $c;

foreach my $key (keys %$test)
  {
  # see if setting in MBI works
  eval ( "$mbi\->config( $key => '$test->{$key}' );" );
  $c = $mbi->config(); ok ("$key = $c->{$key}", "$key = $test->{$key}");
  $c = $mbf->config(); 
  # see if setting it in MBI leaves MBF alone
  if (($c->{$key}||0) ne $test->{$key})
    {
    ok (1,1);
    }
  else
    {
    ok ("$key eq $c->{$key}","$key ne $test->{$key}");
    }

  # see if setting in MBF works
  eval ( "$mbf\->config( $key => '$test->{$key}' );" );
  $c = $mbf->config(); ok ("$key = $c->{$key}", "$key = $test->{$key}");
  }

##############################################################################
# test setting illegal keys (should croak)
  
my $never_reached = 0;
eval ("$mbi\->config( 'some_garbage' => 1 ); $never_reached = 1;");
ok ($never_reached,0);

$never_reached = 0;
eval ("$mbf\->config( 'some_garbage' => 1 ); $never_reached = 1;");
ok ($never_reached,0);

# this does not work. Why?
#ok (@@!, "Illegal keys 'some_garbage' passed to Math::BigInt->config() at ./config.t line 104");
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@d54 1
a54 1
ok ($cfg->{with},'Math::BigInt::Calc');
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d16 1
a16 1
use Math::BigInt lib => 'Calc';
d108 1
a108 1
$@@ = ""; my $never_reached = 0;
d112 1
a112 1
$@@ = ""; $never_reached = 0;
d117 1
a117 1
#ok ($@@ eq "Illegal keys 'some_garbage' passed to Math::BigInt->config() at ./config.t line 104", 1);
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
use Test::More;
d11 1
a11 1
  plan tests => 55;
d30 5
a34 18
is ($cfg->{lib},'Math::BigInt::Calc', 'lib');
is ($cfg->{lib_version}, $Math::BigInt::Calc::VERSION, 'lib_version');
is ($cfg->{class},$mbi,'class');
is ($cfg->{upgrade}||'','', 'upgrade');
is ($cfg->{div_scale},40, 'div_Scale');

is ($cfg->{precision}||0,0, 'precision');	# should test for undef
is ($cfg->{accuracy}||0,0,'accuracy');
is ($cfg->{round_mode},'even','round_mode');

is ($cfg->{trap_nan},0, 'trap_nan');
is ($cfg->{trap_inf},0, 'trap_inf');

is ($mbi->config('lib'), 'Math::BigInt::Calc', 'config("lib")');

# can set via hash ref?
$cfg = $mbi->config( { trap_nan => 1 } );
is ($cfg->{trap_nan},1, 'can set via hash ref');
d36 7
a42 2
# reset for later
$mbi->config( trap_nan => 0 );
d53 11
a63 19
is ($cfg->{lib},'Math::BigInt::Calc', 'lib');
is ($cfg->{with},'Math::BigInt::Calc', 'with');
is ($cfg->{lib_version}, $Math::BigInt::Calc::VERSION, 'lib_version');
is ($cfg->{class},$mbf,'class');
is ($cfg->{upgrade}||'','', 'upgrade');
is ($cfg->{div_scale},40, 'div_Scale');

is ($cfg->{precision}||0,0, 'precision');	# should test for undef
is ($cfg->{accuracy}||0,0,'accuracy');
is ($cfg->{round_mode},'even','round_mode');

is ($cfg->{trap_nan},0, 'trap_nan');
is ($cfg->{trap_inf},0, 'trap_inf');

is ($mbf->config('lib'), 'Math::BigInt::Calc', 'config("lib")');

# can set via hash ref?
$cfg = $mbf->config( { trap_nan => 1 } );
is ($cfg->{trap_nan},1, 'can set via hash ref');
d65 2
a66 2
# reset for later
$mbf->config( trap_nan => 0 );
d93 1
a93 1
    is (1,1);
d97 1
a97 1
    is ("$key eq $c->{$key}","$key ne $test->{$key}", "$key");
d110 1
a110 1
is ($never_reached,0);
d114 1
a114 1
is ($never_reached,0);
@


