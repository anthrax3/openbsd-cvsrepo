head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.7.0.8
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.4
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.7.0.6
	OPENBSD_4_6_BASE:1.1.1.7
	OPENBSD_4_5:1.1.1.7.0.2
	OPENBSD_4_5_BASE:1.1.1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.6
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.4
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.2
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.42;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.06;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.21.13.20;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.47.15;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2005.01.15.21.17.23;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.51;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.38;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Math::BigInt::Calc;

use 5.005;
use strict;
# use warnings;	# dont use warnings for older Perls

require Exporter;
use vars qw/@@ISA $VERSION/;
@@ISA = qw(Exporter);

$VERSION = '0.30';

# Package to store unsigned big integers in decimal and do math with them

# Internally the numbers are stored in an array with at least 1 element, no
# leading zero parts (except the first) and in base 1eX where X is determined
# automatically at loading time to be the maximum possible value

# todo:
# - fully remove funky $# stuff (maybe)

# USE_MUL: due to problems on certain os (os390, posix-bc) "* 1e-5" is used
# instead of "/ 1e5" at some places, (marked with USE_MUL). Other platforms
# BS2000, some Crays need USE_DIV instead.
# The BEGIN block is used to determine which of the two variants gives the
# correct result.

##############################################################################
# global constants, flags and accessory
 
# constants for easier life
my $nan = 'NaN';
my ($MBASE,$BASE,$RBASE,$BASE_LEN,$MAX_VAL,$BASE_LEN2,$BASE_LEN_SMALL);
my ($AND_BITS,$XOR_BITS,$OR_BITS);
my ($AND_MASK,$XOR_MASK,$OR_MASK);
my ($LEN_CONVERT);

sub _base_len 
  {
  # set/get the BASE_LEN and assorted other, connected values
  # used only be the testsuite, set is used only by the BEGIN block below
  shift;

  my $b = shift;
  if (defined $b)
    {
    # find whether we can use mul or div or none in mul()/div()
    # (in last case reduce BASE_LEN_SMALL)
    $BASE_LEN_SMALL = $b+1;
    my $caught = 0;
    while (--$BASE_LEN_SMALL > 5)
      {
      $MBASE = int("1e".$BASE_LEN_SMALL);
      $RBASE = abs('1e-'.$BASE_LEN_SMALL);		# see USE_MUL
      $caught = 0;
      $caught += 1 if (int($MBASE * $RBASE) != 1);	# should be 1
      $caught += 2 if (int($MBASE / $MBASE) != 1);	# should be 1
      last if $caught != 3;
      }
    # BASE_LEN is used for anything else than mul()/div()
    $BASE_LEN = $BASE_LEN_SMALL;
    $BASE_LEN = shift if (defined $_[0]);		# one more arg?
    $BASE = int("1e".$BASE_LEN);

    $BASE_LEN2 = int($BASE_LEN_SMALL / 2);		# for mul shortcut
    $MBASE = int("1e".$BASE_LEN_SMALL);
    $RBASE = abs('1e-'.$BASE_LEN_SMALL);		# see USE_MUL
    $MAX_VAL = $MBASE-1;
    $LEN_CONVERT = 0;
    $LEN_CONVERT = 1 if $BASE_LEN_SMALL != $BASE_LEN;

    #print "BASE_LEN: $BASE_LEN MAX_VAL: $MAX_VAL BASE: $BASE RBASE: $RBASE ";
    #print "BASE_LEN_SMALL: $BASE_LEN_SMALL MBASE: $MBASE\n";

    undef &_mul;
    undef &_div;

    if ($caught & 1 != 0)
      {
      # must USE_MUL
      *{_mul} = \&_mul_use_mul;
      *{_div} = \&_div_use_mul;
      }
    else		# $caught must be 2, since it can't be 1 nor 3
      {
      # can USE_DIV instead
      *{_mul} = \&_mul_use_div;
      *{_div} = \&_div_use_div;
      }
    }
  return $BASE_LEN unless wantarray;
  return ($BASE_LEN, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN_SMALL, $MAX_VAL);
  }

BEGIN
  {
  # from Daniel Pfeiffer: determine largest group of digits that is precisely
  # multipliable with itself plus carry
  # Test now changed to expect the proper pattern, not a result off by 1 or 2
  my ($e, $num) = 3;	# lowest value we will use is 3+1-1 = 3
  do 
    {
    $num = ('9' x ++$e) + 0;
    $num *= $num + 1.0;
    } while ("$num" =~ /9{$e}0{$e}/);	# must be a certain pattern
  $e--; 				# last test failed, so retract one step
  # the limits below brush the problems with the test above under the rug:
  # the test should be able to find the proper $e automatically
  $e = 5 if $^O =~ /^uts/;	# UTS get's some special treatment
  $e = 5 if $^O =~ /^unicos/;	# unicos is also problematic (6 seems to work
				# there, but we play safe)
  $e = 5 if $] < 5.006;		# cap, for older Perls
  $e = 7 if $e > 7;		# cap, for VMS, OS/390 and other 64 bit systems
				# 8 fails inside random testsuite, so take 7

  # determine how many digits fit into an integer and can be safely added 
  # together plus carry w/o causing an overflow

  # this below detects 15 on a 64 bit system, because after that it becomes
  # 1e16  and not 1000000 :/ I can make it detect 18, but then I get a lot of
  # test failures. Ugh! (Tomake detect 18: uncomment lines marked with *)
  use integer;
  my $bi = 5;			# approx. 16 bit
  $num = int('9' x $bi);
  # $num = 99999; # *
  # while ( ($num+$num+1) eq '1' . '9' x $bi)	# *
  while ( int($num+$num+1) eq '1' . '9' x $bi)
    {
    $bi++; $num = int('9' x $bi);
    # $bi++; $num *= 10; $num += 9;	# *
    }
  $bi--;				# back off one step
  # by setting them equal, we ignore the findings and use the default
  # one-size-fits-all approach from former versions
  $bi = $e;				# XXX, this should work always

  __PACKAGE__->_base_len($e,$bi);	# set and store

  # find out how many bits _and, _or and _xor can take (old default = 16)
  # I don't think anybody has yet 128 bit scalars, so let's play safe.
  local $^W = 0;	# don't warn about 'nonportable number'
  $AND_BITS = 15; $XOR_BITS = 15; $OR_BITS  = 15;

  # find max bits, we will not go higher than numberofbits that fit into $BASE
  # to make _and etc simpler (and faster for smaller, slower for large numbers)
  my $max = 16;
  while (2 ** $max < $BASE) { $max++; }
  {
    no integer;
    $max = 16 if $] < 5.006;	# older Perls might not take >16 too well
  }
  my ($x,$y,$z);
  do {
    $AND_BITS++;
    $x = oct('0b' . '1' x $AND_BITS); $y = $x & $x;
    $z = (2 ** $AND_BITS) - 1;
    } while ($AND_BITS < $max && $x == $z && $y == $x);
  $AND_BITS --;						# retreat one step
  do {
    $XOR_BITS++;
    $x = oct('0b' . '1' x $XOR_BITS); $y = $x ^ 0;
    $z = (2 ** $XOR_BITS) - 1;
    } while ($XOR_BITS < $max && $x == $z && $y == $x);
  $XOR_BITS --;						# retreat one step
  do {
    $OR_BITS++;
    $x = oct('0b' . '1' x $OR_BITS); $y = $x | $x;
    $z = (2 ** $OR_BITS) - 1;
    } while ($OR_BITS < $max && $x == $z && $y == $x);
  $OR_BITS --;						# retreat one step
  
  }

##############################################################################
# convert between the "small" and the "large" representation

sub _to_large
  {
  # take an array in base $BASE_LEN_SMALL and convert it in-place to $BASE_LEN
  my ($c,$x) = @@_;

#  print "_to_large $BASE_LEN_SMALL => $BASE_LEN\n";

  return $x if $LEN_CONVERT == 0 ||		# nothing to converconvertor
	 @@$x == 1;				# only one element => early out
  
  #     12345    67890    12345    67890   contents
  # to      3        2        1        0   index 
  #             123456  7890123  4567890   contents 

#  # faster variant
#  my @@d; my $str = '';
#  my $z = '0' x $BASE_LEN_SMALL;
#  foreach (@@$x)
#    {
#    # ... . 04321 . 000321
#    $str = substr($z.$_,-$BASE_LEN_SMALL,$BASE_LEN_SMALL) . $str;
#    if (length($str) > $BASE_LEN)
#      {
#      push @@d, substr($str,-$BASE_LEN,$BASE_LEN);	# extract one piece
#      substr($str,-$BASE_LEN,$BASE_LEN) = '';		# remove it
#      }
#    }
#  push @@d, $str if $str !~ /^0*$/;			# extract last piece
#  @@$x = @@d;
#  $x->[-1] = int($x->[-1]);			# strip leading zero
#  $x;

  my $ret = "";
  my $l = scalar @@$x;		# number of parts
  $l --; $ret .= int($x->[$l]); $l--;
  my $z = '0' x ($BASE_LEN_SMALL-1);                            
  while ($l >= 0)
    {
    $ret .= substr($z.$x->[$l],-$BASE_LEN_SMALL); 
    $l--;
    }
  my $str = _new($c,\$ret);			# make array
  @@$x = @@$str;					# clobber contents of $x
  $x->[-1] = int($x->[-1]);			# strip leading zero
  }

sub _to_small
  {
  # take an array in base $BASE_LEN and convert it in-place to $BASE_LEN_SMALL
  my ($c,$x) = @@_;

  return $x if $LEN_CONVERT == 0;		# nothing to do
  return $x if @@$x == 1 && length(int($x->[0])) <= $BASE_LEN_SMALL;

  my $d = _str($c,$x);
  my $il = length($$d)-1;
  ## this leaves '00000' instead of int 0 and will be corrected after any op
  # clobber contents of $x
  @@$x = reverse(unpack("a" . ($il % $BASE_LEN_SMALL+1) 
      . ("a$BASE_LEN_SMALL" x ($il / $BASE_LEN_SMALL)), $$d));	

  $x->[-1] = int($x->[-1]);			# strip leading zero
  }

###############################################################################

sub _new
  {
  # (ref to string) return ref to num_array
  # Convert a number from string format (without sign) to internal base
  # 1ex format. Assumes normalized value as input.
  my $d = $_[1];
  my $il = length($$d)-1;
  # this leaves '00000' instead of int 0 and will be corrected after any op
  [ reverse(unpack("a" . ($il % $BASE_LEN+1) 
    . ("a$BASE_LEN" x ($il / $BASE_LEN)), $$d)) ];
  }                                                                             
  
BEGIN
  {
  $AND_MASK = __PACKAGE__->_new( \( 2 ** $AND_BITS ));
  $XOR_MASK = __PACKAGE__->_new( \( 2 ** $XOR_BITS ));
  $OR_MASK = __PACKAGE__->_new( \( 2 ** $OR_BITS ));
  }

sub _zero
  {
  # create a zero
  [ 0 ];
  }

sub _one
  {
  # create a one
  [ 1 ];
  }

sub _two
  {
  # create a two (used internally for shifting)
  [ 2 ];
  }

sub _copy
  {
  [ @@{$_[1]} ];
  }

# catch and throw away
sub import { }

##############################################################################
# convert back to string and number

sub _str
  {
  # (ref to BINT) return num_str
  # Convert number from internal base 100000 format to string format.
  # internal format is always normalized (no leading zeros, "-0" => "+0")
  my $ar = $_[1];
  my $ret = "";

  my $l = scalar @@$ar;		# number of parts
  return $nan if $l < 1;	# should not happen

  # handle first one different to strip leading zeros from it (there are no
  # leading zero parts in internal representation)
  $l --; $ret .= int($ar->[$l]); $l--;
  # Interestingly, the pre-padd method uses more time
  # the old grep variant takes longer (14 to 10 sec)
  my $z = '0' x ($BASE_LEN-1);                            
  while ($l >= 0)
    {
    $ret .= substr($z.$ar->[$l],-$BASE_LEN); # fastest way I could think of
    $l--;
    }
  \$ret;
  }                                                                             

sub _num
  {
  # Make a number (scalar int/float) from a BigInt object
  my $x = $_[1];
  return $x->[0] if scalar @@$x == 1;  # below $BASE
  my $fac = 1;
  my $num = 0;
  foreach (@@$x)
    {
    $num += $fac*$_; $fac *= $BASE;
    }
  $num; 
  }

##############################################################################
# actual math code

sub _add
  {
  # (ref to int_num_array, ref to int_num_array)
  # routine to add two base 1eX numbers
  # stolen from Knuth Vol 2 Algorithm A pg 231
  # there are separate routines to add and sub as per Knuth pg 233
  # This routine clobbers up array x, but not y.
 
  my ($c,$x,$y) = @@_;

  return $x if (@@$y == 1) && $y->[0] == 0;		# $x + 0 => $x
  if ((@@$x == 1) && $x->[0] == 0)			# 0 + $y => $y->copy
    {
    # twice as slow as $x = [ @@$y ], but necc. to retain $x as ref :(
    @@$x = @@$y; return $x;		
    }
 
  # for each in Y, add Y to X and carry. If after that, something is left in
  # X, foreach in X add carry to X and then return X, carry
  # Trades one "$j++" for having to shift arrays, $j could be made integer
  # but this would impose a limit to number-length of 2**32.
  my $i; my $car = 0; my $j = 0;
  for $i (@@$y)
    {
    $x->[$j] -= $BASE if $car = (($x->[$j] += $i + $car) >= $BASE) ? 1 : 0;
    $j++;
    }
  while ($car != 0)
    {
    $x->[$j] -= $BASE if $car = (($x->[$j] += $car) >= $BASE) ? 1 : 0; $j++;
    }
  $x;
  }                                                                             

sub _inc
  {
  # (ref to int_num_array, ref to int_num_array)
  # routine to add 1 to a base 1eX numbers
  # This routine clobbers up array x, but not y.
  my ($c,$x) = @@_;

  for my $i (@@$x)
    {
    return $x if (($i += 1) < $BASE);		# early out
    $i = 0;					# overflow, next
    }
  push @@$x,1 if ($x->[-1] == 0);		# last overflowed, so extend
  $x;
  }                                                                             

sub _dec
  {
  # (ref to int_num_array, ref to int_num_array)
  # routine to add 1 to a base 1eX numbers
  # This routine clobbers up array x, but not y.
  my ($c,$x) = @@_;

  my $MAX = $BASE-1;				# since MAX_VAL based on MBASE
  for my $i (@@$x)
    {
    last if (($i -= 1) >= 0);			# early out
    $i = $MAX;					# overflow, next
    }
  pop @@$x if $x->[-1] == 0 && @@$x > 1;		# last overflowed (but leave 0)
  $x;
  }                                                                             

sub _sub
  {
  # (ref to int_num_array, ref to int_num_array, swap)
  # subtract base 1eX numbers -- stolen from Knuth Vol 2 pg 232, $x > $y
  # subtract Y from X by modifying x in place
  my ($c,$sx,$sy,$s) = @@_;
 
  my $car = 0; my $i; my $j = 0;
  if (!$s)
    {
    #print "case 2\n";
    for $i (@@$sx)
      {
      last unless defined $sy->[$j] || $car;
      $i += $BASE if $car = (($i -= ($sy->[$j] || 0) + $car) < 0); $j++;
      }
    # might leave leading zeros, so fix that
    return __strip_zeros($sx);
    }
  #print "case 1 (swap)\n";
  for $i (@@$sx)
    {
    # we can't do an early out if $x is < than $y, since we
    # need to copy the high chunks from $y. Found by Bob Mathews.
    #last unless defined $sy->[$j] || $car;
    $sy->[$j] += $BASE
     if $car = (($sy->[$j] = $i-($sy->[$j]||0) - $car) < 0);
    $j++;
    }
  # might leave leading zeros, so fix that
  __strip_zeros($sy);
  }                                                                             

sub _square_use_mul
  {
  # compute $x ** 2 or $x * $x in-place and return $x
  my ($c,$x) = @@_;

  # From: Handbook of Applied Cryptography by A. Menezes, P. van Oorschot and
  #       S. Vanstone., Chapter 14

  #14.16 Algorithm Multiple-precision squaring
  #INPUT: positive integer x = (xt 1 xt 2 ... x1 x0)b.
  #OUTPUT: x * x = x ** 2 in radix b representation. 
  #1. For i from 0 to (2t - 1) do: wi <- 0. 
  #2.  For i from 0 to (t - 1) do the following: 
  # 2.1 (uv)b w2i + xi * xi, w2i v, c u. 
  # 2.2 For j from (i + 1)to (t - 1) do the following: 
  #      (uv)b <- wi+j + 2*xj * xi + c, wi+j <- v, c <- u. 
  # 2.3 wi+t <- u. 
  #3. Return((w2t-1 w2t-2 ... w1 w0)b).

#  # Note: That description is crap. Half of the symbols are not explained or
#  # used with out beeing set.
#  my $t = scalar @@$x;		# count
#  my ($c,$i,$j);
#  for ($i = 0; $i < $t; $i++)
#    {
#    $x->[$i] = $x->[$i*2] + $x[$i]*$x[$i];
#    $x->[$i*2] = $x[$i]; $c = $x[$i];
#    for ($j = $i+1; $j < $t; $j++)
#      {
#      $x->[$i] = $x->[$i+$j] + 2 * $x->[$i] * $x->[$j];
#      $x->[$i+$j] = $x[$j]; $c = $x[$i];
#      }
#    $x->[$i+$t] = $x[$i];
#    }
  $x;
  }

sub _mul_use_mul
  {
  # (ref to int_num_array, ref to int_num_array)
  # multiply two numbers in internal representation
  # modifies first arg, second need not be different from first
  my ($c,$xv,$yv) = @@_;

  # shortcut for two very short numbers (improved by Nathan Zook)
  # works also if xv and yv are the same reference
  if ((@@$xv == 1) && (@@$yv == 1))
    {
    if (($xv->[0] *= $yv->[0]) >= $MBASE)
       {
       $xv->[0] = $xv->[0] - ($xv->[1] = int($xv->[0] * $RBASE)) * $MBASE;
       };
    return $xv;
    }
  # shortcut for result == 0
  if ( ((@@$xv == 1) && ($xv->[0] == 0)) ||
       ((@@$yv == 1) && ($yv->[0] == 0)) )
    {
    @@$xv = (0);
    return $xv;
    }

  # since multiplying $x with $x fails, make copy in this case
  $yv = [@@$xv] if $xv == $yv;	# same references?
#  $yv = [@@$xv] if "$xv" eq "$yv";	# same references?

  # since multiplying $x with $x would fail here, use the faster squaring
#  return _square($c,$xv) if $xv == $yv;	# same reference?

  if ($LEN_CONVERT != 0)
    {
    $c->_to_small($xv); $c->_to_small($yv);
    }

  my @@prod = (); my ($prod,$car,$cty,$xi,$yi);

  for $xi (@@$xv)
    {
    $car = 0; $cty = 0;

    # slow variant
#    for $yi (@@$yv)
#      {
#      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
#      $prod[$cty++] =
#       $prod - ($car = int($prod * RBASE)) * $MBASE;  # see USE_MUL
#      }
#    $prod[$cty] += $car if $car; # need really to check for 0?
#    $xi = shift @@prod;

    # faster variant
    # looping through this if $xi == 0 is silly - so optimize it away!
    $xi = (shift @@prod || 0), next if $xi == 0;
    for $yi (@@$yv)
      {
      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
##     this is actually a tad slower
##        $prod = $prod[$cty]; $prod += ($car + $xi * $yi);	# no ||0 here
      $prod[$cty++] =
       $prod - ($car = int($prod * $RBASE)) * $MBASE;  # see USE_MUL
      }
    $prod[$cty] += $car if $car; # need really to check for 0?
    $xi = shift @@prod || 0;	# || 0 makes v5.005_3 happy
    }
  push @@$xv, @@prod;
  if ($LEN_CONVERT != 0)
    {
    $c->_to_large($yv);
    $c->_to_large($xv);
    }
  else
    {
    __strip_zeros($xv);
    }
  $xv;
  }                                                                             

sub _mul_use_div
  {
  # (ref to int_num_array, ref to int_num_array)
  # multiply two numbers in internal representation
  # modifies first arg, second need not be different from first
  my ($c,$xv,$yv) = @@_;
 
  # shortcut for two very short numbers (improved by Nathan Zook)
  # works also if xv and yv are the same reference
  if ((@@$xv == 1) && (@@$yv == 1))
    {
    if (($xv->[0] *= $yv->[0]) >= $MBASE)
        {
        $xv->[0] =
            $xv->[0] - ($xv->[1] = int($xv->[0] / $MBASE)) * $MBASE;
        };
    return $xv;
    }
  # shortcut for result == 0
  if ( ((@@$xv == 1) && ($xv->[0] == 0)) ||
       ((@@$yv == 1) && ($yv->[0] == 0)) )
    {
    @@$xv = (0);
    return $xv;
    }

 
  # since multiplying $x with $x fails, make copy in this case
  $yv = [@@$xv] if $xv == $yv;	# same references?
#  $yv = [@@$xv] if "$xv" eq "$yv";	# same references?
  # since multiplying $x with $x would fail here, use the faster squaring
#  return _square($c,$xv) if $xv == $yv;	# same reference?

  if ($LEN_CONVERT != 0)
    {
    $c->_to_small($xv); $c->_to_small($yv);
    }
  
  my @@prod = (); my ($prod,$car,$cty,$xi,$yi);
  for $xi (@@$xv)
    {
    $car = 0; $cty = 0;
    # looping through this if $xi == 0 is silly - so optimize it away!
    $xi = (shift @@prod || 0), next if $xi == 0;
    for $yi (@@$yv)
      {
      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
      $prod[$cty++] =
       $prod - ($car = int($prod / $MBASE)) * $MBASE;
      }
    $prod[$cty] += $car if $car; # need really to check for 0?
    $xi = shift @@prod || 0;	# || 0 makes v5.005_3 happy
    }
  push @@$xv, @@prod;
  if ($LEN_CONVERT != 0)
    {
    $c->_to_large($yv);
    $c->_to_large($xv);
    }
  else
    {
    __strip_zeros($xv);
    }
  $xv;
  }                                                                             

sub _div_use_mul
  {
  # ref to array, ref to array, modify first array and return remainder if 
  # in list context
  my ($c,$x,$yorg) = @@_;

  if (@@$x == 1 && @@$yorg == 1)
    {
    # shortcut, $yorg and $x are two small numbers
    if (wantarray)
      {
      my $r = [ $x->[0] % $yorg->[0] ];
      $x->[0] = int($x->[0] / $yorg->[0]);
      return ($x,$r); 
      }
    else
      {
      $x->[0] = int($x->[0] / $yorg->[0]);
      return $x; 
      }
    }
  if (@@$yorg == 1)
    {
    my $rem;
    $rem = _mod($c,[ @@$x ],$yorg) if wantarray;

    # shortcut, $y is < $BASE
    my $j = scalar @@$x; my $r = 0; 
    my $y = $yorg->[0]; my $b;
    while ($j-- > 0)
      {
      $b = $r * $MBASE + $x->[$j];
      $x->[$j] = int($b/$y);
      $r = $b % $y;
      }
    pop @@$x if @@$x > 1 && $x->[-1] == 0;	# splice up a leading zero 
    return ($x,$rem) if wantarray;
    return $x;
    }

  my $y = [ @@$yorg ];				# always make copy to preserve
  if ($LEN_CONVERT != 0)
    {
    $c->_to_small($x); $c->_to_small($y);
    }

  my ($car,$bar,$prd,$dd,$xi,$yi,@@q,$v2,$v1,@@d,$tmp,$q,$u2,$u1,$u0);

  $car = $bar = $prd = 0;
  if (($dd = int($MBASE/($y->[-1]+1))) != 1) 
    {
    for $xi (@@$x) 
      {
      $xi = $xi * $dd + $car;
      $xi -= ($car = int($xi * $RBASE)) * $MBASE;	# see USE_MUL
      }
    push(@@$x, $car); $car = 0;
    for $yi (@@$y) 
      {
      $yi = $yi * $dd + $car;
      $yi -= ($car = int($yi * $RBASE)) * $MBASE;	# see USE_MUL
      }
    }
  else 
    {
    push(@@$x, 0);
    }
  @@q = (); ($v2,$v1) = @@$y[-2,-1];
  $v2 = 0 unless $v2;
  while ($#$x > $#$y) 
    {
    ($u2,$u1,$u0) = @@$x[-3..-1];
    $u2 = 0 unless $u2;
    #warn "oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l ",scalar @@$y,"\n"
    # if $v1 == 0;
     $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$MBASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$MBASE+$u1-$q*$v1)*$MBASE+$u2);
    if ($q)
      {
      ($car, $bar) = (0,0);
      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
        {
        $prd = $q * $y->[$yi] + $car;
        $prd -= ($car = int($prd * $RBASE)) * $MBASE;	# see USE_MUL
	$x->[$xi] += $MBASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
	}
      if ($x->[-1] < $car + $bar) 
        {
        $car = 0; --$q;
	for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
          {
	  $x->[$xi] -= $MBASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) > $MBASE));
	  }
	}   
      }
      pop(@@$x); unshift(@@q, $q);
    }
  if (wantarray) 
    {
    @@d = ();
    if ($dd != 1)  
      {
      $car = 0; 
      for $xi (reverse @@$x) 
        {
        $prd = $car * $MBASE + $xi;
        $car = $prd - ($tmp = int($prd / $dd)) * $dd; # see USE_MUL
        unshift(@@d, $tmp);
        }
      }
    else 
      {
      @@d = @@$x;
      }
    @@$x = @@q;
    my $d = \@@d; 
    if ($LEN_CONVERT != 0)
      {
      $c->_to_large($x); $c->_to_large($d);
      }
    else
      {
      __strip_zeros($x);
      __strip_zeros($d);
      }
    return ($x,$d);
    }
  @@$x = @@q;
  if ($LEN_CONVERT != 0)
    {
    $c->_to_large($x);
    }
  else
    {
    __strip_zeros($x);
    }
  $x;
  }

sub _div_use_div
  {
  # ref to array, ref to array, modify first array and return remainder if 
  # in list context
  my ($c,$x,$yorg) = @@_;

  if (@@$x == 1 && @@$yorg == 1)
    {
    # shortcut, $yorg and $x are two small numbers
    if (wantarray)
      {
      my $r = [ $x->[0] % $yorg->[0] ];
      $x->[0] = int($x->[0] / $yorg->[0]);
      return ($x,$r); 
      }
    else
      {
      $x->[0] = int($x->[0] / $yorg->[0]);
      return $x; 
      }
    }
  if (@@$yorg == 1)
    {
    my $rem;
    $rem = _mod($c,[ @@$x ],$yorg) if wantarray;

    # shortcut, $y is < $BASE
    my $j = scalar @@$x; my $r = 0; 
    my $y = $yorg->[0]; my $b;
    while ($j-- > 0)
      {
      $b = $r * $MBASE + $x->[$j];
      $x->[$j] = int($b/$y);
      $r = $b % $y;
      }
    pop @@$x if @@$x > 1 && $x->[-1] == 0;	# splice up a leading zero 
    return ($x,$rem) if wantarray;
    return $x;
    }

  my $y = [ @@$yorg ];				# always make copy to preserve
  if ($LEN_CONVERT != 0)
    {
    $c->_to_small($x); $c->_to_small($y);
    }
 
  my ($car,$bar,$prd,$dd,$xi,$yi,@@q,$v2,$v1,@@d,$tmp,$q,$u2,$u1,$u0);

  $car = $bar = $prd = 0;
  if (($dd = int($MBASE/($y->[-1]+1))) != 1) 
    {
    for $xi (@@$x) 
      {
      $xi = $xi * $dd + $car;
      $xi -= ($car = int($xi / $MBASE)) * $MBASE;
      }
    push(@@$x, $car); $car = 0;
    for $yi (@@$y) 
      {
      $yi = $yi * $dd + $car;
      $yi -= ($car = int($yi / $MBASE)) * $MBASE;
      }
    }
  else 
    {
    push(@@$x, 0);
    }
  @@q = (); ($v2,$v1) = @@$y[-2,-1];
  $v2 = 0 unless $v2;
  while ($#$x > $#$y) 
    {
    ($u2,$u1,$u0) = @@$x[-3..-1];
    $u2 = 0 unless $u2;
    #warn "oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l ",scalar @@$y,"\n"
    # if $v1 == 0;
     $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$MBASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$MBASE+$u1-$q*$v1)*$MBASE+$u2);
    if ($q)
      {
      ($car, $bar) = (0,0);
      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
        {
        $prd = $q * $y->[$yi] + $car;
        $prd -= ($car = int($prd / $MBASE)) * $MBASE;
	$x->[$xi] += $MBASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
	}
      if ($x->[-1] < $car + $bar) 
        {
        $car = 0; --$q;
	for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
          {
	  $x->[$xi] -= $MBASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) > $MBASE));
	  }
	}   
      }
    pop(@@$x); unshift(@@q, $q);
    }
  if (wantarray) 
    {
    @@d = ();
    if ($dd != 1)  
      {
      $car = 0; 
      for $xi (reverse @@$x) 
        {
        $prd = $car * $MBASE + $xi;
        $car = $prd - ($tmp = int($prd / $dd)) * $dd;
        unshift(@@d, $tmp);
        }
      }
    else 
      {
      @@d = @@$x;
      }
    @@$x = @@q;
    my $d = \@@d; 
    if ($LEN_CONVERT != 0)
      {
      $c->_to_large($x); $c->_to_large($d);
      }
    else
      {
      __strip_zeros($x);
      __strip_zeros($d);
      }
    return ($x,$d);
    }
  @@$x = @@q;
  if ($LEN_CONVERT != 0)
    {
    $c->_to_large($x);
    }
  else
    {
    __strip_zeros($x);
    }
  $x;
  }

##############################################################################
# testing

sub _acmp
  {
  # internal absolute post-normalized compare (ignore signs)
  # ref to array, ref to array, return <0, 0, >0
  # arrays must have at least one entry; this is not checked for

  my ($c,$cx,$cy) = @@_;

  # fast comp based on number of array elements (aka pseudo-length)
  my $lxy = scalar @@$cx - scalar @@$cy;
  return -1 if $lxy < 0;				# already differs, ret
  return 1 if $lxy > 0;					# ditto
  
  # now calculate length based on digits, not parts
  $lxy = _len($c,$cx) - _len($c,$cy);			# difference
  return -1 if $lxy < 0;
  return 1 if $lxy > 0;

  # hm, same lengths,  but same contents?
  my $i = 0; my $a;
  # first way takes 5.49 sec instead of 4.87, but has the early out advantage
  # so grep is slightly faster, but more inflexible. hm. $_ instead of $k
  # yields 5.6 instead of 5.5 sec huh?
  # manual way (abort if unequal, good for early ne)
  my $j = scalar @@$cx - 1;
  while ($j >= 0)
    {
    last if ($a = $cx->[$j] - $cy->[$j]); $j--;
    }
#  my $j = scalar @@$cx;
#  while (--$j >= 0)
#    {
#    last if ($a = $cx->[$j] - $cy->[$j]);
#    }
  return 1 if $a > 0;
  return -1 if $a < 0;
  0;					# equal

  # while it early aborts, it is even slower than the manual variant
  #grep { return $a if ($a = $_ - $cy->[$i++]); } @@$cx;
  # grep way, go trough all (bad for early ne)
  #grep { $a = $_ - $cy->[$i++]; } @@$cx;
  #return $a;
  }

sub _len
  {
  # compute number of digits in bigint, minus the sign

  # int() because add/sub sometimes leaves strings (like '00005') instead of
  # '5' in this place, thus causing length() to report wrong length
  my $cx = $_[1];

  return (@@$cx-1)*$BASE_LEN+length(int($cx->[-1]));
  }

sub _digit
  {
  # return the nth digit, negative values count backward
  # zero is rightmost, so _digit(123,0) will give 3
  my ($c,$x,$n) = @@_;

  my $len = _len('',$x);

  $n = $len+$n if $n < 0;		# -1 last, -2 second-to-last
  $n = abs($n);				# if negative was too big
  $len--; $n = $len if $n > $len;	# n to big?
  
  my $elem = int($n / $BASE_LEN);	# which array element
  my $digit = $n % $BASE_LEN;		# which digit in this element
  $elem = '0000'.@@$x[$elem];		# get element padded with 0's
  return substr($elem,-$digit-1,1);
  }

sub _zeros
  {
  # return amount of trailing zeros in decimal
  # check each array elem in _m for having 0 at end as long as elem == 0
  # Upon finding a elem != 0, stop
  my $x = $_[1];
  my $zeros = 0; my $elem;
  foreach my $e (@@$x)
    {
    if ($e != 0)
      {
      $elem = "$e";				# preserve x
      $elem =~ s/.*?(0*$)/$1/;			# strip anything not zero
      $zeros *= $BASE_LEN;			# elems * 5
      $zeros += length($elem);			# count trailing zeros
      last;					# early out
      }
    $zeros ++;					# real else branch: 50% slower!
    }
  $zeros;
  }

##############################################################################
# _is_* routines

sub _is_zero
  {
  # return true if arg (BINT or num_str) is zero (array '+', '0')
  my $x = $_[1];

  (((scalar @@$x == 1) && ($x->[0] == 0))) <=> 0;
  }

sub _is_even
  {
  # return true if arg (BINT or num_str) is even
  my $x = $_[1];
  (!($x->[0] & 1)) <=> 0; 
  }

sub _is_odd
  {
  # return true if arg (BINT or num_str) is even
  my $x = $_[1];

  (($x->[0] & 1)) <=> 0; 
  }

sub _is_one
  {
  # return true if arg (BINT or num_str) is one (array '+', '1')
  my $x = $_[1];

  (scalar @@$x == 1) && ($x->[0] == 1) <=> 0; 
  }

sub __strip_zeros
  {
  # internal normalization function that strips leading zeros from the array
  # args: ref to array
  my $s = shift;
 
  my $cnt = scalar @@$s; # get count of parts
  my $i = $cnt-1;
  push @@$s,0 if $i < 0;		# div might return empty results, so fix it

  return $s if @@$s == 1;		# early out

  #print "strip: cnt $cnt i $i\n";
  # '0', '3', '4', '0', '0',
  #  0    1    2    3    4
  # cnt = 5, i = 4
  # i = 4
  # i = 3
  # => fcnt = cnt - i (5-2 => 3, cnt => 5-1 = 4, throw away from 4th pos)
  # >= 1: skip first part (this can be zero)
  while ($i > 0) { last if $s->[$i] != 0; $i--; }
  $i++; splice @@$s,$i if ($i < $cnt); # $i cant be 0
  $s;                                                                    
  }                                                                             

###############################################################################
# check routine to test internal state of corruptions

sub _check
  {
  # used by the test suite
  my $x = $_[1];

  return "$x is not a reference" if !ref($x);

  # are all parts are valid?
  my $i = 0; my $j = scalar @@$x; my ($e,$try);
  while ($i < $j)
    {
    $e = $x->[$i]; $e = 'undef' unless defined $e;
    $try = '=~ /^[\+]?[0-9]+\$/; '."($x, $e)";
    last if $e !~ /^[+]?[0-9]+$/;
    $try = '=~ /^[\+]?[0-9]+\$/; '."($x, $e) (stringify)";
    last if "$e" !~ /^[+]?[0-9]+$/;
    $try = '=~ /^[\+]?[0-9]+\$/; '."($x, $e) (cat-stringify)";
    last if '' . "$e" !~ /^[+]?[0-9]+$/;
    $try = ' < 0 || >= $BASE; '."($x, $e)";
    last if $e <0 || $e >= $BASE;
    # this test is disabled, since new/bnorm and certain ops (like early out
    # in add/sub) are allowed/expected to leave '00000' in some elements
    #$try = '=~ /^00+/; '."($x, $e)";
    #last if $e =~ /^00+/;
    $i++;
    }
  return "Illegal part '$e' at pos $i (tested: $try)" if $i < $j;
  return 0;
  }


###############################################################################
###############################################################################
# some optional routines to make BigInt faster

sub _mod
  {
  # if possible, use mod shortcut
  my ($c,$x,$yo) = @@_;

  # slow way since $y to big
  if (scalar @@$yo > 1)
    {
    my ($xo,$rem) = _div($c,$x,$yo);
    return $rem;
    }
  my $y = $yo->[0];
  # both are single element arrays
  if (scalar @@$x == 1)
    {
    $x->[0] %= $y;
    return $x;
    }

  # @@y is single element, but @@x has more than one
  my $b = $BASE % $y;
  if ($b == 0)
    {
    # when BASE % Y == 0 then (B * BASE) % Y == 0
    # (B * BASE) % $y + A % Y => A % Y
    # so need to consider only last element: O(1)
    $x->[0] %= $y;
    }
  elsif ($b == 1)
    {
    # else need to go trough all elements: O(N), but loop is a bit simplified
    my $r = 0;
    foreach (@@$x)
      {
      $r = ($r + $_) % $y;		# not much faster, but heh...
      #$r += $_ % $y; $r %= $y;
      }
    $r = 0 if $r == $y;
    $x->[0] = $r;
    }
  else
    {
    # else need to go trough all elements: O(N)
    my $r = 0; my $bm = 1;
    foreach (@@$x)
      {
      $r = ($_ * $bm + $r) % $y;
      $bm = ($bm * $b) % $y;

      #$r += ($_ % $y) * $bm;
      #$bm *= $b;
      #$bm %= $y;
      #$r %= $y;
      }
    $r = 0 if $r == $y;
    $x->[0] = $r;
    }
  splice (@@$x,1);
  $x;
  }

##############################################################################
# shifts

sub _rsft
  {
  my ($c,$x,$y,$n) = @@_;

  if ($n != 10)
    {
    $n = _new($c,\$n); return _div($c,$x, _pow($c,$n,$y));
    }

  # shortcut (faster) for shifting by 10)
  # multiples of $BASE_LEN
  my $dst = 0;				# destination
  my $src = _num($c,$y);		# as normal int
  my $rem = $src % $BASE_LEN;		# remainder to shift
  $src = int($src / $BASE_LEN);		# source
  if ($rem == 0)
    {
    splice (@@$x,0,$src);		# even faster, 38.4 => 39.3
    }
  else
    {
    my $len = scalar @@$x - $src;	# elems to go
    my $vd; my $z = '0'x $BASE_LEN;
    $x->[scalar @@$x] = 0;		# avoid || 0 test inside loop
    while ($dst < $len)
      {
      $vd = $z.$x->[$src];
      $vd = substr($vd,-$BASE_LEN,$BASE_LEN-$rem);
      $src++;
      $vd = substr($z.$x->[$src],-$rem,$rem) . $vd;
      $vd = substr($vd,-$BASE_LEN,$BASE_LEN) if length($vd) > $BASE_LEN;
      $x->[$dst] = int($vd);
      $dst++;
      }
    splice (@@$x,$dst) if $dst > 0;		# kill left-over array elems
    pop @@$x if $x->[-1] == 0 && @@$x > 1;	# kill last element if 0
    } # else rem == 0
  $x;
  }

sub _lsft
  {
  my ($c,$x,$y,$n) = @@_;

  if ($n != 10)
    {
    $n = _new($c,\$n); return _mul($c,$x, _pow($c,$n,$y));
    }

  # shortcut (faster) for shifting by 10) since we are in base 10eX
  # multiples of $BASE_LEN:
  my $src = scalar @@$x;			# source
  my $len = _num($c,$y);		# shift-len as normal int
  my $rem = $len % $BASE_LEN;		# remainder to shift
  my $dst = $src + int($len/$BASE_LEN);	# destination
  my $vd;				# further speedup
  $x->[$src] = 0;			# avoid first ||0 for speed
  my $z = '0' x $BASE_LEN;
  while ($src >= 0)
    {
    $vd = $x->[$src]; $vd = $z.$vd;
    $vd = substr($vd,-$BASE_LEN+$rem,$BASE_LEN-$rem);
    $vd .= $src > 0 ? substr($z.$x->[$src-1],-$BASE_LEN,$rem) : '0' x $rem;
    $vd = substr($vd,-$BASE_LEN,$BASE_LEN) if length($vd) > $BASE_LEN;
    $x->[$dst] = int($vd);
    $dst--; $src--;
    }
  # set lowest parts to 0
  while ($dst >= 0) { $x->[$dst--] = 0; }
  # fix spurios last zero element
  splice @@$x,-1 if $x->[-1] == 0;
  $x;
  }

sub _pow
  {
  # power of $x to $y
  # ref to array, ref to array, return ref to array
  my ($c,$cx,$cy) = @@_;

  my $pow2 = _one();

  my $y_bin = ${_as_bin($c,$cy)}; $y_bin =~ s/^0b//;
  my $len = length($y_bin);
  while (--$len > 0)
    {
    _mul($c,$pow2,$cx) if substr($y_bin,$len,1) eq '1';		# is odd?
    _mul($c,$cx,$cx);
    }

  _mul($c,$cx,$pow2);
  $cx;
  }

sub _fac
  {
  # factorial of $x
  # ref to array, return ref to array
  my ($c,$cx) = @@_;

  if ((@@$cx == 1) && ($cx->[0] <= 2))
    {
    $cx->[0] = 1 * ($cx->[0]||1); # 0,1 => 1, 2 => 2
    return $cx;
    }

  # go forward until $base is exceeded
  # limit is either $x or $base (x == 100 means as result too high)
  my $steps = 100; $steps = $cx->[0] if @@$cx == 1;
  my $r = 2; my $cf = 3; my $step = 1; my $last = $r;
  while ($r < $BASE && $step < $steps)
    {
    $last = $r; $r *= $cf++; $step++;
    }
  if ((@@$cx == 1) && ($step == $cx->[0]))
    {
    # completely done
    $cx = [$last];
    return $cx;
    }
  my $n = _copy($c,$cx);
  $cx = [$last];

  #$cx = _one();
  while (!(@@$n == 1 && $n->[0] == $step))
    {
    _mul($c,$cx,$n); _dec($c,$n);
    }
  $cx;
  }

use constant DEBUG => 0;

my $steps = 0;

sub steps { $steps };

sub _sqrt
  {
  # square-root of $x
  # ref to array, return ref to array
  my ($c,$x) = @@_;

  if (scalar @@$x == 1)
    {
    # fit's into one Perl scalar
    $x->[0] = int(sqrt($x->[0]));
    return $x;
    } 
  my $y = _copy($c,$x);
  # hopefully _len/2 is < $BASE, the -1 is to always undershot the guess
  # since our guess will "grow"
  my $l = int((_len($c,$x)-1) / 2);	

  my $lastelem = $x->[-1];	# for guess
  my $elems = scalar @@$x - 1;
  # not enough digits, but could have more?
  if ((length($lastelem) <= 3) && ($elems > 1))	
    {
    # right-align with zero pad
    my $len = length($lastelem) & 1;
    print "$lastelem => " if DEBUG;
    $lastelem .= substr($x->[-2] . '0' x $BASE_LEN,0,$BASE_LEN);
    # former odd => make odd again, or former even to even again
    $lastelem = $lastelem / 10 if (length($lastelem) & 1) != $len;	
    print "$lastelem\n" if DEBUG;
    }

  # construct $x (instead of _lsft($c,$x,$l,10)
  my $r = $l % $BASE_LEN;	# 10000 00000 00000 00000 ($BASE_LEN=5)
  $l = int($l / $BASE_LEN);
  print "l =  $l " if DEBUG;
  
  splice @@$x,$l; 		# keep ref($x), but modify it
 
  # we make the first part of the guess not '1000...0' but int(sqrt($lastelem))
  # that gives us:
  # 14400 00000 => sqrt(14400) => 120
  # 144000 000000 => sqrt(144000) => 379

  # $x->[$l--] = int('1' . '0' x $r);			# old way of guessing
  print "$lastelem (elems $elems) => " if DEBUG;
  $lastelem = $lastelem / 10 if ($elems & 1 == 1);		# odd or even?
  my $g = sqrt($lastelem); $g =~ s/\.//;			# 2.345 => 2345
  $r -= 1 if $elems & 1 == 0;					# 70 => 7

  # padd with zeros if result is too short
  $x->[$l--] = int(substr($g . '0' x $r,0,$r+1));
  print "now ",$x->[-1] if DEBUG;
  print " would have been ", int('1' . '0' x $r),"\n" if DEBUG;
  
  # If @@$x > 1, we could compute the second elem of the guess, too, to create
  # an even better guess. Not implemented yet.
  $x->[$l--] = 0 while ($l >= 0);	# all other digits of guess are zero
 
  print "start x= ",${_str($c,$x)},"\n" if DEBUG;
  my $two = _two();
  my $last = _zero();
  my $lastlast = _zero();
  $steps = 0 if DEBUG;
  while (_acmp($c,$last,$x) != 0 && _acmp($c,$lastlast,$x) != 0)
    {
    $steps++ if DEBUG;
    $lastlast = _copy($c,$last);
    $last = _copy($c,$x);
    _add($c,$x, _div($c,_copy($c,$y),$x));
    _div($c,$x, $two );
    print "      x= ",${_str($c,$x)},"\n" if DEBUG;
    }
  print "\nsteps in sqrt: $steps, " if DEBUG;
  _dec($c,$x) if _acmp($c,$y,_mul($c,_copy($c,$x),$x)) < 0;	# overshot? 
  print " final ",$x->[-1],"\n" if DEBUG;
  $x;
  }

##############################################################################
# binary stuff

sub _and
  {
  my ($c,$x,$y) = @@_;

  # the shortcut makes equal, large numbers _really_ fast, and makes only a
  # very small performance drop for small numbers (e.g. something with less
  # than 32 bit) Since we optimize for large numbers, this is enabled.
  return $x if _acmp($c,$x,$y) == 0;		# shortcut
  
  my $m = _one(); my ($xr,$yr);
  my $mask = $AND_MASK;

  my $x1 = $x;
  my $y1 = _copy($c,$y);			# make copy
  $x = _zero();
  my ($b,$xrr,$yrr);
  use integer;
  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))
    {
    ($x1, $xr) = _div($c,$x1,$mask);
    ($y1, $yr) = _div($c,$y1,$mask);

    # make ints() from $xr, $yr
    # this is when the AND_BITS are greater tahn $BASE and is slower for
    # small (<256 bits) numbers, but faster for large numbers. Disabled
    # due to KISS principle

#    $b = 1; $xrr = 0; foreach (@@$xr) { $xrr += $_ * $b; $b *= $BASE; }
#    $b = 1; $yrr = 0; foreach (@@$yr) { $yrr += $_ * $b; $b *= $BASE; }
#    _add($c,$x, _mul($c, _new( $c, \($xrr & $yrr) ), $m) );
    
    # 0+ due to '&' doesn't work in strings
    _add($c,$x, _mul($c, [ 0+$xr->[0] & 0+$yr->[0] ], $m) );
    _mul($c,$m,$mask);
    }
  $x;
  }

sub _xor
  {
  my ($c,$x,$y) = @@_;

  return _zero() if _acmp($c,$x,$y) == 0;	# shortcut (see -and)

  my $m = _one(); my ($xr,$yr);
  my $mask = $XOR_MASK;

  my $x1 = $x;
  my $y1 = _copy($c,$y);			# make copy
  $x = _zero();
  my ($b,$xrr,$yrr);
  use integer;
  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))
    {
    ($x1, $xr) = _div($c,$x1,$mask);
    ($y1, $yr) = _div($c,$y1,$mask);
    # make ints() from $xr, $yr (see _and())
    #$b = 1; $xrr = 0; foreach (@@$xr) { $xrr += $_ * $b; $b *= $BASE; }
    #$b = 1; $yrr = 0; foreach (@@$yr) { $yrr += $_ * $b; $b *= $BASE; }
    #_add($c,$x, _mul($c, _new( $c, \($xrr ^ $yrr) ), $m) );

    # 0+ due to '^' doesn't work in strings
    _add($c,$x, _mul($c, [ 0+$xr->[0] ^ 0+$yr->[0] ], $m) );
    _mul($c,$m,$mask);
    }
  # the loop stops when the shorter of the two numbers is exhausted
  # the remainder of the longer one will survive bit-by-bit, so we simple
  # multiply-add it in
  _add($c,$x, _mul($c, $x1, $m) ) if !_is_zero($c,$x1);
  _add($c,$x, _mul($c, $y1, $m) ) if !_is_zero($c,$y1);
  
  $x;
  }

sub _or
  {
  my ($c,$x,$y) = @@_;

  return $x if _acmp($c,$x,$y) == 0;		# shortcut (see _and)

  my $m = _one(); my ($xr,$yr);
  my $mask = $OR_MASK;

  my $x1 = $x;
  my $y1 = _copy($c,$y);			# make copy
  $x = _zero();
  my ($b,$xrr,$yrr);
  use integer;
  while (!_is_zero($c,$x1) && !_is_zero($c,$y1))
    {
    ($x1, $xr) = _div($c,$x1,$mask);
    ($y1, $yr) = _div($c,$y1,$mask);
    # make ints() from $xr, $yr (see _and())
#    $b = 1; $xrr = 0; foreach (@@$xr) { $xrr += $_ * $b; $b *= $BASE; }
#    $b = 1; $yrr = 0; foreach (@@$yr) { $yrr += $_ * $b; $b *= $BASE; }
#    _add($c,$x, _mul($c, _new( $c, \($xrr | $yrr) ), $m) );
    
    # 0+ due to '|' doesn't work in strings
    _add($c,$x, _mul($c, [ 0+$xr->[0] | 0+$yr->[0] ], $m) );
    _mul($c,$m,$mask);
    }
  # the loop stops when the shorter of the two numbers is exhausted
  # the remainder of the longer one will survive bit-by-bit, so we simple
  # multiply-add it in
  _add($c,$x, _mul($c, $x1, $m) ) if !_is_zero($c,$x1);
  _add($c,$x, _mul($c, $y1, $m) ) if !_is_zero($c,$y1);
  
  $x;
  }

sub _as_hex
  {
  # convert a decimal number to hex (ref to array, return ref to string)
  my ($c,$x) = @@_;

  my $x1 = _copy($c,$x);

  my $es = '';
  my ($xr, $h, $x10000);
  if ($] >= 5.006)
    {
    $x10000 = [ 0x10000 ]; $h = 'h4';
    }
  else
    {
    $x10000 = [ 0x1000 ]; $h = 'h3';
    }
  while (! _is_zero($c,$x1))
    {
    ($x1, $xr) = _div($c,$x1,$x10000);
    $es .= unpack($h,pack('v',$xr->[0]));
    }
  $es = reverse $es;
  $es =~ s/^[0]+//;   # strip leading zeros
  $es = '0x' . $es;
  \$es;
  }

sub _as_bin
  {
  # convert a decimal number to bin (ref to array, return ref to string)
  my ($c,$x) = @@_;

  my $x1 = _copy($c,$x);

  my $es = '';
  my ($xr, $b, $x10000);
  if ($] >= 5.006)
    {
    $x10000 = [ 0x10000 ]; $b = 'b16';
    }
  else
    {
    $x10000 = [ 0x1000 ]; $b = 'b12';
    }
  while (! _is_zero($c,$x1))
    {
    ($x1, $xr) = _div($c,$x1,$x10000);
    $es .= unpack($b,pack('v',$xr->[0]));
    }
  $es = reverse $es;
  $es =~ s/^[0]+//;   # strip leading zeros
  $es = '0b' . $es;
  \$es;
  }

sub _from_hex
  {
  # convert a hex number to decimal (ref to string, return ref to array)
  my ($c,$hs) = @@_;

  my $mul = _one();
  my $m = [ 0x10000 ];				# 16 bit at a time
  my $x = _zero();

  my $len = length($$hs)-2;
  $len = int($len/4);				# 4-digit parts, w/o '0x'
  my $val; my $i = -4;
  while ($len >= 0)
    {
    $val = substr($$hs,$i,4);
    $val =~ s/^[+-]?0x// if $len == 0;		# for last part only because
    $val = hex($val);				# hex does not like wrong chars
    $i -= 4; $len --;
    _add ($c, $x, _mul ($c, [ $val ], $mul ) ) if $val != 0;
    _mul ($c, $mul, $m ) if $len >= 0; 		# skip last mul
    }
  $x;
  }

sub _from_bin
  {
  # convert a hex number to decimal (ref to string, return ref to array)
  my ($c,$bs) = @@_;

  # instead of converting 8 bit at a time, it is faster to convert the
  # number to hex, and then call _from_hex.

  my $hs = $$bs;
  $hs =~ s/^[+-]?0b//;					# remove sign and 0b
  my $l = length($hs);					# bits
  $hs = '0' x (8-($l % 8)) . $hs if ($l % 8) != 0;	# padd left side w/ 0
  my $h = unpack('H*', pack ('B*', $hs));		# repack as hex
  return $c->_from_hex(\('0x'.$h));
 
  my $mul = _one();
  my $m = [ 0x100 ];				# 8 bit at a time
  my $x = _zero();

  my $len = length($$bs)-2;
  $len = int($len/8);				# 4-digit parts, w/o '0x'
  my $val; my $i = -8;
  while ($len >= 0)
    {
    $val = substr($$bs,$i,8);
    $val =~ s/^[+-]?0b// if $len == 0;		# for last part only

    $val = ord(pack('B8',substr('00000000'.$val,-8,8))); 

    $i -= 8; $len --;
    _add ($c, $x, _mul ($c, [ $val ], $mul ) ) if $val != 0;
    _mul ($c, $mul, $m ) if $len >= 0; 		# skip last mul
    }
  $x;
  }

##############################################################################
# special modulus functions

# not ready yet, since it would need to deal with unsigned numbers
sub _modinv1
  {
  # inverse modulus
  my ($c,$num,$mod) = @@_;

  my $u = _zero(); my $u1 = _one();
  my $a = _copy($c,$mod); my $b = _copy($c,$num);

  # Euclid's Algorithm for bgcd(), only that we calc bgcd() ($a) and the
  # result ($u) at the same time
  while (!_is_zero($c,$b))
    {
#    print ${_str($c,$a)}, " ", ${_str($c,$b)}, " ", ${_str($c,$u)}, " ",
#     ${_str($c,$u1)}, "\n";
    ($a, my $q, $b) = ($b, _div($c,$a,$b));
#    print ${_str($c,$a)}, " ", ${_str($c,$q)}, " ", ${_str($c,$b)}, "\n";
    # original: ($u,$u1) = ($u1, $u - $u1 * $q);
    my $t = _copy($c,$u);
    $u = _copy($c,$u1);
    _mul($c,$u1,$q);
    $u1 = _sub($t,$u1);
#    print ${_str($c,$a)}, " ", ${_str($c,$b)}, " ", ${_str($c,$u)}, " ",
#     ${_str($c,$u1)}, "\n";
    }

  # if the gcd is not 1, then return NaN
  return undef unless _is_one($c,$a);

  $num = _mod($c,$u,$mod);
#  print ${_str($c,$num)},"\n";
  $num;
  }

sub _modpow
  {
  # modulus of power ($x ** $y) % $z
  my ($c,$num,$exp,$mod) = @@_;

  # in the trivial case,
  if (_is_one($c,$mod))
    {
    splice @@$num,0,1; $num->[0] = 0;
    return $num;
    }
  if ((scalar @@$num == 1) && (($num->[0] == 0) || ($num->[0] == 1)))
    {
    $num->[0] = 1;
    return $num;
    }

#  $num = _mod($c,$num,$mod);	# this does not make it faster

  my $acc = _copy($c,$num); my $t = _one();

  my $expbin = ${_as_bin($c,$exp)}; $expbin =~ s/^0b//;
  my $len = length($expbin);
  while (--$len >= 0)
    {
    if ( substr($expbin,$len,1) eq '1')			# is_odd
      {
      _mul($c,$t,$acc);
      $t = _mod($c,$t,$mod);
      }
    _mul($c,$acc,$acc);
    $acc = _mod($c,$acc,$mod);
    }
  @@$num = @@$t;
  $num;
  }

##############################################################################
##############################################################################

1;
__END__

=head1 NAME

Math::BigInt::Calc - Pure Perl module to support Math::BigInt

=head1 SYNOPSIS

Provides support for big integer calculations. Not intended to be used by other
modules (except Math::BigInt::Cached). Other modules which sport the same
functions can also be used to support Math::Bigint, like Math::BigInt::Pari.

=head1 DESCRIPTION

In order to allow for multiple big integer libraries, Math::BigInt was
rewritten to use library modules for core math routines. Any module which
follows the same API as this can be used instead by using the following:

	use Math::BigInt lib => 'libname';

'libname' is either the long name ('Math::BigInt::Pari'), or only the short
version like 'Pari'.

=head1 EXPORT

The following functions MUST be defined in order to support the use by
Math::BigInt:

	_new(string)	return ref to new object from ref to decimal string
	_zero()		return a new object with value 0
	_one()		return a new object with value 1

	_str(obj)	return ref to a string representing the object
	_num(obj)	returns a Perl integer/floating point number
			NOTE: because of Perl numeric notation defaults,
			the _num'ified obj may lose accuracy due to 
			machine-dependend floating point size limitations
                    
	_add(obj,obj)	Simple addition of two objects
	_mul(obj,obj)	Multiplication of two objects
	_div(obj,obj)	Division of the 1st object by the 2nd
			In list context, returns (result,remainder).
			NOTE: this is integer math, so no
			fractional part will be returned.
	_sub(obj,obj)	Simple subtraction of 1 object from another
			a third, optional parameter indicates that the params
			are swapped. In this case, the first param needs to
			be preserved, while you can destroy the second.
			sub (x,y,1) => return x - y and keep x intact!
	_dec(obj)	decrement object by one (input is garant. to be > 0)
	_inc(obj)	increment object by one


	_acmp(obj,obj)	<=> operator for objects (return -1, 0 or 1)

	_len(obj)	returns count of the decimal digits of the object
	_digit(obj,n)	returns the n'th decimal digit of object

	_is_one(obj)	return true if argument is +1
	_is_zero(obj)	return true if argument is 0
	_is_even(obj)	return true if argument is even (0,2,4,6..)
	_is_odd(obj)	return true if argument is odd (1,3,5,7..)

	_copy		return a ref to a true copy of the object

	_check(obj)	check whether internal representation is still intact
			return 0 for ok, otherwise error message as string

The following functions are optional, and can be defined if the underlying lib
has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence
slow) fallback routines to emulate these:

	_from_hex(str)	return ref to new object from ref to hexadecimal string
	_from_bin(str)	return ref to new object from ref to binary string
	
	_as_hex(str)	return ref to scalar string containing the value as
			unsigned hex string, with the '0x' prepended.
			Leading zeros must be stripped.
	_as_bin(str)	Like as_hex, only as binary string containing only
			zeros and ones. Leading zeros must be stripped and a
			'0b' must be prepended.
	
	_rsft(obj,N,B)	shift object in base B by N 'digits' right
			For unsupported bases B, return undef to signal failure
	_lsft(obj,N,B)	shift object in base B by N 'digits' left
			For unsupported bases B, return undef to signal failure
	
	_xor(obj1,obj2)	XOR (bit-wise) object 1 with object 2
			Note: XOR, AND and OR pad with zeros if size mismatches
	_and(obj1,obj2)	AND (bit-wise) object 1 with object 2
	_or(obj1,obj2)	OR (bit-wise) object 1 with object 2

	_mod(obj,obj)	Return remainder of div of the 1st by the 2nd object
	_sqrt(obj)	return the square root of object (truncate to int)
	_fac(obj)	return factorial of object 1 (1*2*3*4..)
	_pow(obj,obj)	return object 1 to the power of object 2
	_gcd(obj,obj)	return Greatest Common Divisor of two objects
	
	_zeros(obj)	return number of trailing decimal zeros
	_modinv		return inverse modulus
	_modpow		return modulus of power ($x ** $y) % $z

Input strings come in as unsigned but with prefix (i.e. as '123', '0xabc'
or '0b1101').

Testing of input parameter validity is done by the caller, so you need not
worry about underflow (f.i. in C<_sub()>, C<_dec()>) nor about division by
zero or similar cases.

The first parameter can be modified, that includes the possibility that you
return a reference to a completely different object instead. Although keeping
the reference and just changing it's contents is prefered over creating and
returning a different reference.

Return values are always references to objects or strings. Exceptions are
C<_lsft()> and C<_rsft()>, which return undef if they can not shift the
argument. This is used to delegate shifting of bases different than the one
you can support back to Math::BigInt, which will use some generic code to
calculate the result.

=head1 WRAP YOUR OWN

If you want to port your own favourite c-lib for big numbers to the
Math::BigInt interface, you can take any of the already existing modules as
a rough guideline. You should really wrap up the latest BigInt and BigFloat
testsuites with your module, and replace in them any of the following:

	use Math::BigInt;

by this:

	use Math::BigInt lib => 'yourlib';

This way you ensure that your library really works 100% within Math::BigInt.

=head1 LICENSE
 
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself. 

=head1 AUTHORS

Original math code by Mark Biggar, rewritten by Tels L<http://bloodgate.com/>
in late 2000, 2001.
Seperated from BigInt and shaped API with the help of John Peacock.

=head1 SEE ALSO

L<Math::BigInt>, L<Math::BigFloat>, L<Math::BigInt::BitVect>,
L<Math::BigInt::GMP>, L<Math::BigInt::Cached> and L<Math::BigInt::Pari>.

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d11 1
a11 1
$VERSION = '0.36';
a27 6
# Beware of things like:
# $i = $i * $y + $car; $car = int($i / $MBASE); $i = $i % $MBASE;
# This works on x86, but fails on ARM (SA1100, iPAQ) due to whoknows what
# reasons. So, use this instead (slower, but correct):
# $i = $i * $y + $car; $car = int($i / $MBASE); $i -= $MBASE * $car;

d36 1
d69 3
a71 1
    
d78 1
a78 5
    # $caught & 1 != 0 => cannot use MUL
    # $caught & 2 != 0 => cannot use DIV
    # The parens around ($caught & 1) were important, indeed, if we would use
    # & here.
    if ($caught == 2)				# 2
d80 1
a80 2
      # print "# use mul\n";
      # must USE_MUL since we cannot use DIV
d84 1
a84 1
    else					# 0 or 1
a85 1
      # print "# use div\n";
d119 3
d123 10
a132 18

  ############################################################################
  # the next block is no longer important

  ## this below detects 15 on a 64 bit system, because after that it becomes
  ## 1e16  and not 1000000 :/ I can make it detect 18, but then I get a lot of
  ## test failures. Ugh! (Tomake detect 18: uncomment lines marked with *)

  #my $bi = 5;			# approx. 16 bit
  #$num = int('9' x $bi);
  ## $num = 99999; # *
  ## while ( ($num+$num+1) eq '1' . '9' x $bi)	# *
  #while ( int($num+$num+1) eq '1' . '9' x $bi)
  #  {
  #  $bi++; $num = int('9' x $bi);
  #  # $bi++; $num *= 10; $num += 9;	# *
  #  }
  #$bi--;				# back off one step
d135 1
a135 1
  my $bi = $e;				# XXX, this should work always
d142 1
a142 1
  $AND_BITS = 15; $XOR_BITS = 15; $OR_BITS = 15;
d174 67
d371 1
a371 1
  # This routine modifies array x
d387 1
a387 1
  # This routine modifies array x
d433 37
d477 13
a489 1
  if (@@$yv == 1)
d491 1
a491 23
    # shortcut for two very short numbers (improved by Nathan Zook)
    # works also if xv and yv are the same reference, and handles also $x == 0
    if (@@$xv == 1)
      {
      if (($xv->[0] *= $yv->[0]) >= $MBASE)
         {
         $xv->[0] = $xv->[0] - ($xv->[1] = int($xv->[0] * $RBASE)) * $MBASE;
         };
      return $xv;
      }
    # $x * 0 => 0
    if ($yv->[0] == 0)
      {
      @@$xv = (0);
      return $xv;
      }
    # multiply a large number a by a single element one, so speed up
    my $y = $yv->[0]; my $car = 0;
    foreach my $i (@@$xv)
      {
      $i = $i * $y + $car; $car = int($i * $RBASE); $i -= $car * $MBASE;
      }
    push @@$xv, $car if $car != 0;
a493 2
  # shortcut for result $x == 0 => result = 0
  return $xv if ( ((@@$xv == 1) && ($xv->[0] == 0)) ); 
d497 9
d538 9
a546 1
  __strip_zeros($xv);
d557 14
a570 1
  if (@@$yv == 1)
d572 1
a572 25
    # shortcut for two small numbers, also handles $x == 0
    if (@@$xv == 1)
      {
      # shortcut for two very short numbers (improved by Nathan Zook)
      # works also if xv and yv are the same reference, and handles also $x == 0
      if (($xv->[0] *= $yv->[0]) >= $MBASE)
          {
          $xv->[0] =
              $xv->[0] - ($xv->[1] = int($xv->[0] / $MBASE)) * $MBASE;
          };
      return $xv;
      }
    # $x * 0 => 0
    if ($yv->[0] == 0)
      {
      @@$xv = (0);
      return $xv;
      }
    # multiply a large number a by a single element one, so speed up
    my $y = $yv->[0]; my $car = 0;
    foreach my $i (@@$xv)
      {
      $i = $i * $y + $car; $car = int($i / $MBASE); $i -= $car * $MBASE;
      }
    push @@$xv, $car if $car != 0;
a574 2
  # shortcut for result $x == 0 => result = 0
  return $xv if ( ((@@$xv == 1) && ($xv->[0] == 0)) ); 
d576 1
d579 3
d583 5
d604 9
a612 1
  __strip_zeros($xv);
a619 3

  # see comments in _div_use_div() for more explanations

a620 6
  
  # the general div algorithmn here is about O(N*N) and thus quite slow, so
  # we first check for some special cases and use shortcuts to handle them.

  # This works, because we store the numbers in a chunked format where each
  # element contains 5..7 digits (depending on system).
a621 1
  # if both numbers have only one element:
a636 2

  # if x has more than one, but y has only one element:
d656 2
a657 4
  # now x and y have more than one element

  # check whether y has more elements than x, if yet, the result will be 0
  if (@@$yorg > @@$x)
d659 1
a659 54
    my $rem;
    $rem = [@@$x] if wantarray;                  # make copy
    splice (@@$x,1);                             # keep ref to original array
    $x->[0] = 0;                                # set to 0
    return ($x,$rem) if wantarray;              # including remainder?
    return $x;					# only x, which is [0] now
    }
  # check whether the numbers have the same number of elements, in that case
  # the result will fit into one element and can be computed efficiently
  if (@@$yorg == @@$x)
    {
    my $rem;
    # if $yorg has more digits than $x (it's leading element is longer than
    # the one from $x), the result will also be 0:
    if (length(int($yorg->[-1])) > length(int($x->[-1])))
      {
      $rem = [@@$x] if wantarray;		# make copy
      splice (@@$x,1);				# keep ref to org array
      $x->[0] = 0;				# set to 0
      return ($x,$rem) if wantarray;		# including remainder?
      return $x;
      }
    # now calculate $x / $yorg
    if (length(int($yorg->[-1])) == length(int($x->[-1])))
      {
      # same length, so make full compare, and if equal, return 1
      # hm, same lengths, but same contents? So we need to check all parts:
      my $a = 0; my $j = scalar @@$x - 1;
      # manual way (abort if unequal, good for early ne)
      while ($j >= 0)
        {
        last if ($a = $x->[$j] - $yorg->[$j]); $j--;
        }
      # $a contains the result of the compare between X and Y
      # a < 0: x < y, a == 0 => x == y, a > 0: x > y
      if ($a <= 0)
        {
        if (wantarray)
	  {
          $rem = [ 0 ];			# a = 0 => x == y => rem 1
          $rem = [@@$x] if $a != 0;	# a < 0 => x < y => rem = x
	  }
        splice(@@$x,1);			# keep single element
        $x->[0] = 0;			# if $a < 0
        if ($a == 0)
          {
          # $x == $y
          $x->[0] = 1;
          }
        return ($x,$rem) if wantarray;
        return $x;
        }
      # $x >= $y, proceed normally
      }
a661 4
  # all other cases:

  my $y = [ @@$yorg ];				# always make copy to preserve

d691 1
a691 1
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$MBASE+$u1)/$v1));
d708 1
a708 1
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $MBASE));
d712 1
a712 2
    pop(@@$x);
    unshift(@@q, $q);
d733 9
a741 2
    __strip_zeros($x);
    __strip_zeros($d);
d745 8
a752 1
  __strip_zeros($x);
a761 7
  # the general div algorithmn here is about O(N*N) and thus quite slow, so
  # we first check for some special cases and use shortcuts to handle them.

  # This works, because we store the numbers in a chunked format where each
  # element contains 5..7 digits (depending on system).

  # if both numbers have only one element:
a776 1
  # if x has more than one, but y has only one element:
a794 1
  # now x and y have more than one element
d796 2
a797 2
  # check whether y has more elements than x, if yet, the result will be 0
  if (@@$yorg > @@$x)
d799 1
a799 54
    my $rem;
    $rem = [@@$x] if wantarray;			# make copy
    splice (@@$x,1);				# keep ref to original array
    $x->[0] = 0;				# set to 0
    return ($x,$rem) if wantarray;		# including remainder?
    return $x;					# only x, which is [0] now
    }
  # check whether the numbers have the same number of elements, in that case
  # the result will fit into one element and can be computed efficiently
  if (@@$yorg == @@$x)
    {
    my $rem;
    # if $yorg has more digits than $x (it's leading element is longer than
    # the one from $x), the result will also be 0:
    if (length(int($yorg->[-1])) > length(int($x->[-1])))
      {
      $rem = [@@$x] if wantarray;		# make copy
      splice (@@$x,1);				# keep ref to org array
      $x->[0] = 0;				# set to 0
      return ($x,$rem) if wantarray;		# including remainder?
      return $x;
      }
    # now calculate $x / $yorg
    if (length(int($yorg->[-1])) == length(int($x->[-1])))
      {
      # same length, so make full compare, and if equal, return 1
      # hm, same lengths, but same contents? So we need to check all parts:
      my $a = 0; my $j = scalar @@$x - 1;
      # manual way (abort if unequal, good for early ne)
      while ($j >= 0)
        {
        last if ($a = $x->[$j] - $yorg->[$j]); $j--;
        }
      # $a contains the result of the compare between X and Y
      # a < 0: x < y, a == 0 => x == y, a > 0: x > y
      if ($a <= 0)
        {
        if (wantarray)
	  {
          $rem = [ 0 ];			# a = 0 => x == y => rem 1
          $rem = [@@$x] if $a != 0;	# a < 0 => x < y => rem = x
	  }
        splice(@@$x,1);			# keep single element
        $x->[0] = 0;			# if $a < 0
        if ($a == 0)
          {
          # $x == $y
          $x->[0] = 1;
          }
        return ($x,$rem) if wantarray;
        return $x;
        }
      # $x >= $y, so proceed normally
      }
a800 4

  # all other cases:

  my $y = [ @@$yorg ];				# always make copy to preserve
a822 4

  # @@q will accumulate the final result, $q contains the current computed
  # part of the final result

d831 1
a831 1
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$MBASE+$u1)/$v1));
d848 1
a848 1
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $MBASE));
d873 9
a881 2
    __strip_zeros($x);
    __strip_zeros($d);
d885 8
a892 1
  __strip_zeros($x);
d911 1
a911 1

d913 1
a913 3
  # we need only the length of the last element, since both array have the
  # same number of parts
  $lxy = length(int($cx->[-1])) - length(int($cy->[-1]));
d917 5
a921 2
  # hm, same lengths,  but same contents? So we need to check all parts:
  my $a; my $j = scalar @@$cx - 1;
d923 1
d928 5
d935 7
a941 1
  0;						# numbers are equal
d946 1
a946 1
  # compute number of digits
d952 1
a952 1
  (@@$cx-1)*$BASE_LEN+length(int($cx->[-1]));
d970 1
a970 1
  substr($elem,-$digit-1,1);
a1102 1

d1111 1
a1111 1
  # @@y is a single element, but @@x has more than one element
a1168 8
  my $xlen = (@@$x-1)*$BASE_LEN+length(int($x->[-1]));  # len of x in digits
  if ($src > $xlen or ($src == $xlen and ! defined $x->[1]))
    {
    # 12345 67890 shifted right by more than 10 digits => 0
    splice (@@$x,1);                    # leave only one element
    $x->[0] = 0;                       # set to zero
    return $x;
    }
d1276 2
a1277 1
  # now we must do the left over steps
d1279 2
a1280 24
  # do so as long as n has more than one element
  my $n = $cx->[0];
  # as soon as the last element of $cx is 0, we split it up and remember how
  # many zeors we got so far. The reason is that n! will accumulate zeros at
  # the end rather fast.
  my $zero_elements = 0;
  $cx = [$last];
  if (scalar @@$cx == 1)
    {
    my $n = _copy($c,$cx);
    # no need to test for $steps, since $steps is a scalar and we stop before
    while (scalar @@$n != 1)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @@$cx;
        }
      _mul($c,$cx,$n); _dec($c,$n);
      }
    $n = $n->[0];		# "convert" to scalar
    }
  
  # the left over steps will fit into a scalar, so we can speed it up
  while ($n != $step)
d1282 1
a1282 10
    if ($cx->[0] == 0)
      {
      $zero_elements ++; shift @@$cx;
      }
    _mul($c,$cx,[$n]); $n--;
    }
  # multiply in the zeros again
  while ($zero_elements-- > 0)
    {
    unshift @@$cx, 0; 
d1287 5
a1291 4
# for debugging:
  use constant DEBUG => 0;
  my $steps = 0;
  sub steps { $steps };
d1295 2
a1296 3
  # square-root of $x in place
  # Compute a guess of the result (by rule of thumb), then improve it via
  # Newton's method.
d1301 1
a1301 1
    # fit's into one Perl scalar, so result can be computed directly
d1310 1
a1310 1
  my $lastelem = $x->[-1];					# for guess
d1313 1
a1313 1
  if ((length($lastelem) <= 3) && ($elems > 1))
d1320 1
a1320 1
    $lastelem = $lastelem / 10 if (length($lastelem) & 1) != $len;
d1328 3
a1330 3

  splice @@$x,$l;		# keep ref($x), but modify it

d1333 2
a1334 2
  # 14400 00000 => sqrt(14400) => guess first digits to be 120
  # 144000 000000 => sqrt(144000) => guess 379
d1336 1
d1346 1
a1346 1

d1348 1
a1348 1
  # an even better guess. Not implemented yet. Does it improve performance?
d1350 1
a1350 1

d1363 1
a1363 1
    print " x= ",${_str($c,$x)},"\n" if DEBUG;
a1370 53
sub _root
  {
  # take n'th root of $x in place (n >= 3)
  my ($c,$x,$n) = @@_;
 
  if (scalar @@$x == 1)
    {
    if (scalar @@$n > 1)
      {
      # result will always be smaller than 2 so trunc to 1 at once
      $x->[0] = 1;
      }
    else
      {
      # fit's into one Perl scalar, so result can be computed directly
      $x->[0] = int( $x->[0] ** (1 / $n->[0]) );
      }
    return $x;
    } 

  # X is more than one element
  # if $n is a power of two, we can repeatedly take sqrt($X) and find the
  # proper result, because sqrt(sqrt($x)) == root($x,4)
  my $b = _as_bin($c,$n);
  if ($$b =~ /0b1(0+)/)
    {
    my $count = CORE::length($1);	# 0b100 => len('00') => 2
    my $cnt = $count;			# counter for loop
    unshift (@@$x, 0);			# add one element, together with one
					# more below in the loop this makes 2
    while ($cnt-- > 0)
      {
      # 'inflate' $X by adding one element, basically computing
      # $x * $BASE * $BASE. This gives us more $BASE_LEN digits for result
      # since len(sqrt($X)) approx == len($x) / 2.
      unshift (@@$x, 0);
      # calculate sqrt($x), $x is now one element to big, again. In the next
      # round we make that two, again.
      _sqrt($c,$x);
      }
    # $x is now one element to big, so truncate result by removing it
    splice (@@$x,0,1);
    } 
  else
    {
    # Should compute a guess of the result (by rule of thumb), then improve it
    # via Newton's method or something similiar.
    # XXX TODO
    warn ('_root() not fully implemented in Calc.');
    }
  $x; 
  }

a1488 7
  # fit's into one element
  if (@@$x == 1)
    {
    my $t = '0x' . sprintf("%x",$x->[0]);
    return \$t;
    }

a1516 6
  # fit's into one element
  if (@@$x == 1)
    {
    my $t = '0b' . sprintf("%b",$x->[0]);
    return \$t;
    }
d1603 2
a1604 1
sub _modinv
d1606 2
a1607 2
  # modular inverse
  my ($c,$x,$y) = @@_;
d1609 2
a1610 2
  my $u = _zero($c); my $u1 = _one($c);
  my $a = _copy($c,$y); my $b = _copy($c,$x);
d1613 1
a1613 4
  # result ($u) at the same time. See comments in BigInt for why this works.
  my $q;
  ($a, $q, $b) = ($b, _div($c,$a,$b));		# step 1
  my $sign = 1;
d1616 11
a1626 7
    my $t = _add($c, 				# step 2:
       _mul($c,_copy($c,$u1), $q) ,		#  t =  u1 * q
       $u );					#     + u
    $u = $u1;					#  u = u1, u1 = t
    $u1 = $t;
    $sign = -$sign;
    ($a, $q, $b) = ($b, _div($c,$a,$b));	# step 1
d1630 5
a1634 4
  return (undef,undef) unless _is_one($c,$a);
 
  $sign = $sign == 1 ? '+' : '-';
  ($u1,$sign);
d1688 1
a1688 1
functions can also be used to support Math::BigInt, like Math::BigInt::Pari.
d1701 1
a1701 3
=head1 STORAGE

=head1 METHODS
a1721 2
			The second operand will be not be 0, so no need to
			check for that.
d1771 1
a1771 2
	_sqrt(obj)	return the square root of object (truncated to int)
	_root(obj)	return the n'th (n >= 3) root of obj (truncated to int)
d1783 3
a1785 4
So the library needs only to deal with unsigned big integers. Testing of input
parameter validity is done by the caller, so you need not worry about
underflow (f.i. in C<_sub()>, C<_dec()>) nor about division by zero or similar
cases.
d1792 5
a1796 7
Return values are always references to objects, strings, or true/false for
comparisation routines.

Exceptions are C<_lsft()> and C<_rsft()>, which return undef if they can not
shift the argument. This is used to delegate shifting of bases different than
the one you can support back to Math::BigInt, which will use some generic code
to calculate the result.
d1821 1
a1821 1
in late 2000.
a1822 1
Fixed/enhanced by Tels 2001-2002.
d1827 1
a1827 1
L<Math::BigInt::GMP>, L<Math::BigInt::FastCalc> and L<Math::BigInt::Pari>.
@


1.1.1.3
log
@perl 5.8.3 from CPAN
@
text
@d7 3
a9 1
use vars qw/$VERSION/;
d11 1
a11 1
$VERSION = '0.38';
a196 4

  # < BASE_LEN due len-1 above
  return [ int($$d) ] if $il < $BASE_LEN;	# shortcut for short numbers

a228 1
  # make a true copy
d253 1
a253 1
  # the old grep variant takes longer (14 vs. 10 sec)
d299 2
a300 1
  # Trades one "$j++" for having to shift arrays
d317 2
a318 1
  # Add 1 to $x, modify $x in place
d333 2
a334 1
  # Sub 1 from $x, modify $x in place
d341 1
a341 1
    $i = $MAX;					# underflow, next
d343 1
a343 1
  pop @@$x if $x->[-1] == 0 && @@$x > 1;		# last underflowed (but leave 0)
a789 1

d919 1
a920 4
 
  # shortcut for short numbers 
  return (($cx->[0] <=> $cy->[0]) <=> 0) 
   if scalar @@$cx == scalar @@$cy && scalar @@$cx == 1;
d923 1
a923 5
  my $lxy = (scalar @@$cx - scalar @@$cy)
  # or length of first element if same number of elements (aka difference 0)
    ||
  # need int() here because sometimes the last element is '00018' vs '18'
   (length(int($cx->[-1])) - length(int($cy->[-1])));
d927 9
d937 1
a937 2
  my $a; my $j = scalar @@$cx;
  while (--$j >= 0)
d939 1
a939 1
    last if ($a = $cx->[$j] - $cy->[$j]);
d941 3
a943 1
  $a <=> 0;
d1057 1
a1057 1
# check routine to test internal state for corruptions
d1086 1
a1086 1
  0;
d1125 1
a1125 1
    # else need to go through all elements: O(N), but loop is a bit simplified
d1137 1
a1137 1
    # else need to go through all elements: O(N)
d1152 1
a1152 1
  splice (@@$x,1);		# keep one element of $x
a1246 16
  if (scalar @@$cy == 1 && $cy->[0] == 0)
    {
    splice (@@$cx,1); $cx->[0] = 1;		# y == 0 => x => 1
    return $cx;
    }
  if ((scalar @@$cx == 1 && $cx->[0] == 1) ||	#    x == 1
      (scalar @@$cy == 1 && $cy->[0] == 1))	# or y == 1
    {
    return $cx;
    }
  if (scalar @@$cx == 1 && $cx->[0] == 0)
    {
    splice (@@$cx,1); $cx->[0] = 0;		# 0 ** y => 0 (if not y <= 0)
    return $cx;
    }

d1269 1
a1269 1
    $cx->[0] ||= 1;		# 0 => 1, 1 => 1, 2 => 2
d1274 1
a1274 2
  # limit is either $x steps (steps == 100 means a result always too high) or
  # $base.
d1276 2
a1277 2
  my $r = 2; my $cf = 3; my $step = 2; my $last = $r;
  while ($r*$cf < $BASE && $step < $steps)
d1281 1
a1281 1
  if ((@@$cx == 1) && $step == $cx->[0])
d1283 2
a1284 2
    # completely done, so keep reference to $x and return
    $cx->[0] = $r;
a1286 1
  
a1287 9
  my $n;					# steps still to do
  if (scalar @@$cx == 1)
    {
    $n = $cx->[0];
    }
  else
    {
    $n = _copy($c,$cx);
    }
d1289 5
a1293 1
  $cx->[0] = $last; splice (@@$cx,1);		# keep ref to $x
d1295 2
a1296 3

  # do left-over steps fit into a scalar?
  if (ref $n eq 'ARRAY')
d1298 4
a1301 7
    # No, so use slower inc() & cmp()
    $step = [$step];
    while (_acmp($step,$n) <= 0)
      {
      # as soon as the last element of $cx is 0, we split it up and remember
      # how many zeors we got so far. The reason is that n! will accumulate
      # zeros at the end rather fast.
d1306 1
a1306 1
      _mul($c,$cx,$step); _inc($c,$step);
d1308 1
d1310 3
a1312 1
  else
d1314 1
a1314 2
    # Yes, so we can speed it up slightly
    while ($step <= $n)
d1316 1
a1316 8
      # When the last element of $cx is 0, we split it up and remember
      # how many we got so far. The reason is that n! will accumulate
      # zeros at the end rather fast.
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @@$cx;
        }
      _mul($c,$cx,[$step]); $step++;
d1318 1
d1325 1
a1325 91
  $cx;			# return result
  }

sub _log_int
  {
  # calculate integer log of $x to base $base
  # ref to array, ref to array - return ref to array
  my ($c,$x,$base) = @@_;

  # X == 0 => NaN
  return if (scalar @@$x == 1 && $x->[0] == 0);
  # BASE 0 or 1 => NaN
  return if (scalar @@$base == 1 && $base->[0] < 2);
  my $cmp = _acmp($c,$x,$base); # X == BASE => 1
  if ($cmp == 0)
    {
    splice (@@$x,1); $x->[0] = 1;
    return ($x,1)
    }
  # X < BASE
  if ($cmp < 0)
    {
    splice (@@$x,1); $x->[0] = 0;
    return ($x,undef);
    }

  # this trial multiplication is very fast, even for large counts (like for
  # 2 ** 1024, since this still requires only 1024 very fast steps
  # (multiplication of a large number by a very small number is very fast))
  my $x_org = _copy($c,$x);		# preserve x
  splice(@@$x,1); $x->[0] = 1;		# keep ref to $x

  my $trial = _copy($c,$base);

  # XXX TODO this only works if $base has only one element
  if (scalar @@$base == 1)
    {
    # compute int ( length_in_base_10(X) / ( log(base) / log(10) ) )
    my $len = _len($c,$x_org);
    my $res = int($len / (log($base->[0]) / log(10))) || 1; # avoid $res == 0

    $x->[0] = $res;
    $trial = _pow ($c, _copy($c, $base), $x);
    my $a = _acmp($x,$trial,$x_org);
    return ($x,1) if $a == 0;
    # we now know that $res is too small
    if ($res < 0)
      {
      _mul($c,$trial,$base); _add($c, $x, [1]);
      }
    else
      {
      # or too big
      _div($c,$trial,$base); _sub($c, $x, [1]);
      }
    # did we now get the right result?
    $a = _acmp($x,$trial,$x_org);
    return ($x,1) if $a == 0;		# yes, exactly
    # still too big
    if ($a > 0)
      {
      _div($c,$trial,$base); _sub($c, $x, [1]);
      }
    } 
  
  # simple loop that increments $x by two in each step, possible overstepping
  # the real result by one

  my $a;
  my $base_mul = _mul($c, _copy($c,$base), $base);

  while (($a = _acmp($x,$trial,$x_org)) < 0)
    {
    _mul($c,$trial,$base_mul); _add($c, $x, [2]);
    }

  my $exact = 1;
  if ($a > 0)
    {
    # overstepped the result
    _dec($c, $x);
    _div($c,$trial,$base);
    $a = _acmp($x,$trial,$x_org);
    if ($a > 0)
      {
      _dec($c, $x);
      }
    $exact = 0 if $a != 0;
    }
  
  ($x,$exact);				# return result
d1426 1
a1426 5
      # cannot use int() here, because it rounds wrongly (try 
      # (81 ** 3) ** (1/3) to see what I mean)
      #$x->[0] = int( $x->[0] ** (1 / $n->[0]) );
      # round to 8 digits, then truncate result to integer
      $x->[0] = int ( sprintf ("%.8f", $x->[0] ** (1 / $n->[0]) ) );
d1431 1
a1431 2
  # we know now that X is more than one element long

d1435 1
a1435 1
  if ($$b =~ /0b1(0+)$/)
d1456 4
a1459 51
    # trial computation by starting with 2,4,8,16 etc until we overstep
    my $step;
    my $trial = _two();

    # while still to do more than X steps
    do
      {
      $step = _two();
      while (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) < 0)
        {
        _mul ($c, $step, [2]);
        _add ($c, $trial, $step);
        }

      # hit exactly?
      if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) == 0)
        {
        @@$x = @@$trial;			# make copy while preserving ref to $x
        return $x;
        }
      # overstepped, so go back on step
      _sub($c, $trial, $step);
      } while (scalar @@$step > 1 || $step->[0] > 128);

    # reset step to 2
    $step = _two();
    # add two, because $trial cannot be exactly the result (otherwise we would
    # alrady have found it)
    _add($c, $trial, $step);
 
    # and now add more and more (2,4,6,8,10 etc)
    while (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) < 0)
      {
      _add ($c, $trial, $step);
      }

    # hit not exactly? (overstepped)
    if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) > 0)
      {
      _dec($c,$trial);
      }

    # hit not exactly? (overstepped)
    # 80 too small, 81 slightly too big, 82 too big
    if (_acmp($c, _pow($c, _copy($c, $trial), $n), $x) > 0)
      {
      _dec ($c, $trial); 
      }

    @@$x = @@$trial;			# make copy while preserving ref to $x
    return $x;
d1582 1
a1582 1
  # fit's into one element (handle also 0x0 case)
d1585 1
a1585 1
    my $t = sprintf("0x%x",$x->[0]);
d1601 1
a1601 2
  # while (! _is_zero($c,$x1))
  while (@@$x1 != 1 || $x1->[0] != 0)		# _is_zero()
d1604 1
a1604 1
    $es .= unpack($h,pack('v',$xr->[0]));	# XXX TODO: why pack('v',...)?
d1617 2
a1618 7
  # fit's into one element (and Perl recent enough), handle also 0b0 case
  # handle zero case for older Perls
  if ($] <= 5.005 && @@$x == 1 && $x->[0] == 0)
    {
    my $t = '0b0'; return \$t;
    }
  if (@@$x == 1 && $] >= 5.006)
d1620 1
a1620 1
    my $t = sprintf("0b%b",$x->[0]);
d1635 1
a1635 2
  # while (! _is_zero($c,$x1))
  while (!(@@$x1 == 1 && $x1->[0] == 0))		# _is_zero()
d1638 1
a1638 2
    $es .= unpack($b,pack('v',$xr->[0]));	# XXX TODO: why pack('v',...)?
    # $es .= unpack($b,$xr->[0]);
d1675 1
a1675 1
  # instead of converting X (8) bit at a time, it is faster to "convert" the
d1683 21
a1703 2
  
  $c->_from_hex(\('0x'.$h));
d1790 2
a1791 2
modules. Other modules which sport the same functions can also be used to support
Math::BigInt, like Math::BigInt::GMP or Math::BigInt::Pari.
a1876 4
	_signed_or
	_signed_and
	_signed_xor

a1881 1
			return undef for NaN
a1886 6
	_log_int(X,N)	calculate integer log() of X in base N
			X >= 0, N >= 0 (return undef for NaN)
			returns (RESULT, EXACT) where EXACT is:
			 1     : result is exactly RESULT
			 0     : result was truncated to RESULT
			 undef : unknown whether result is exactly RESULT
d1934 1
a1934 1
Fixed, sped-up and enhanced by Tels http://bloodgate.com 2001-2003.
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d9 1
a9 1
$VERSION = '0.40';
a33 3

# announce that we are compatible with MBI v1.70 and up
sub api_version () { 1; }
d73 3
d85 1
d92 1
d193 2
a194 1
  my $il = length($_[1])-1;
d197 1
a197 1
  return [ int($_[1]) ] if $il < $BASE_LEN;	# shortcut for short numbers
d201 1
a201 1
    . ("a$BASE_LEN" x ($il / $BASE_LEN)), $_[1])) ];
d206 3
a208 3
  $AND_MASK = __PACKAGE__->_new( ( 2 ** $AND_BITS ));
  $XOR_MASK = __PACKAGE__->_new( ( 2 ** $XOR_BITS ));
  $OR_MASK = __PACKAGE__->_new( ( 2 ** $OR_BITS ));
a228 6
sub _ten
  {
  # create a 10 (used internally for shifting)
  [ 10 ];
  }

d263 1
a263 1
  $ret;
d268 1
a268 1
  # Make a number (scalar int/float) from a BigInt object 
d270 1
a270 2

  return 0+$x->[0] if scalar @@$x == 1;  # below $BASE
d357 1
d366 1
a978 3

  return 0 if scalar @@$x == 1 && $x->[0] == 0;

d1000 4
a1003 2
  # return true if arg is zero 
  (((scalar @@{$_[1]} == 1) && ($_[1]->[0] == 0))) <=> 0;
d1008 3
a1010 2
  # return true if arg is even
  (!($_[1]->[0] & 1)) <=> 0; 
d1015 4
a1018 2
  # return true if arg is even
  (($_[1]->[0] & 1)) <=> 0; 
d1023 2
a1024 9
  # return true if arg is one
  (scalar @@{$_[1]} == 1) && ($_[1]->[0] == 1) <=> 0; 
  }

sub _is_two
  {
  # return true if arg is two 
  (scalar @@{$_[1]} == 1) && ($_[1]->[0] == 2) <=> 0; 
  }
d1026 1
a1026 4
sub _is_ten
  {
  # return true if arg is ten 
  (scalar @@{$_[1]} == 1) && ($_[1]->[0] == 10) <=> 0; 
d1089 2
d1163 1
a1163 1
    $n = _new($c,$n); return _div($c,$x, _pow($c,$n,$y));
d1211 1
a1211 1
    $n = _new($c,$n); return _mul($c,$x, _pow($c,$n,$y));
d1263 1
a1263 1
  my $y_bin = _as_bin($c,$cy); $y_bin =~ s/^0b//;
a1356 2
#############################################################################

d1425 1
a1425 1
  while (($a = _acmp($c,$trial,$x_org)) < 0)
d1436 1
a1436 1
    $a = _acmp($c,$trial,$x_org);
d1510 1
a1510 1
  print "start x= ",_str($c,$x),"\n" if DEBUG;
d1522 1
a1522 1
    print " x= ",_str($c,$x),"\n" if DEBUG;
d1559 1
a1559 1
  if ($b =~ /0b1(0+)$/)
d1661 1
a1661 1
    # this is when the AND_BITS are greater than $BASE and is slower for
d1667 1
a1667 1
#    _add($c,$x, _mul($c, _new( $c, ($xrr & $yrr) ), $m) );
d1697 1
a1697 1
    #_add($c,$x, _mul($c, _new( $c, ($xrr ^ $yrr) ), $m) );
d1733 1
a1733 1
#    _add($c,$x, _mul($c, _new( $c, ($xrr | $yrr) ), $m) );
d1757 1
a1757 1
    return $t;
d1781 1
a1781 1
  $es;
d1793 1
a1793 1
    my $t = '0b0'; return $t;
d1798 1
a1798 1
    return $t;
d1822 1
a1822 1
  $es;
d1834 1
a1834 1
  my $len = length($hs)-2;
d1839 1
a1839 1
    $val = substr($hs,$i,4);
d1857 1
a1857 1
  my $hs = $bs;
d1863 1
a1863 1
  $c->_from_hex('0x'.$h);
d1921 1
a1921 1
  my $expbin = _as_bin($c,$exp); $expbin =~ s/^0b//;
a1936 14
sub _gcd
  {
  # greatest common divisor
  my ($c,$x,$y) = @@_;

  while (! _is_zero($c,$y))
    {
    my $t = _copy($c,$y);
    $y = _mod($c, $x, $y);
    $x = $t;
    }
  $x;
  }

d1969 1
a1969 1
Math::BigInt v1.70 or later:
a1970 1
	api_version()	return API version, minimum 1 for v1.70
a1973 2
	_two()		return a new object with value 2
	_ten()		return a new object with value 10
d2003 1
a2003 3
	_is_one(obj)	return true if argument is 1
	_is_two(obj)	return true if argument is 2
	_is_ten(obj)	return true if argument is 10
d2013 4
d2020 1
a2020 1
	_as_hex(str)	return string containing the value as
d2028 1
d2030 1
d2037 4
d2047 2
a2057 10
        _gcd(obj,obj)	return Greatest Common Divisor of two objects

The following functions are optional, and can be defined if the underlying lib
has a fast way to do them. If undefined, Math::BigInt will use pure Perl (hence
slow) fallback routines to emulate these:
	
	_signed_or
	_signed_and
	_signed_xor

d2075 5
a2105 1
Further streamlining (api_version 1) by Tels 2004.
@


1.1.1.5
log
@perl 5.8.6 from CPAN
@
text
@d9 1
a9 1
$VERSION = '0.43';
d40 1
a40 1
my ($MBASE,$BASE,$RBASE,$BASE_LEN,$MAX_VAL,$BASE_LEN_SMALL);
d71 1
a99 15
sub _new
  {
  # (ref to string) return ref to num_array
  # Convert a number from string format (without sign) to internal base
  # 1ex format. Assumes normalized value as input.
  my $il = length($_[1])-1;

  # < BASE_LEN due len-1 above
  return [ int($_[1]) ] if $il < $BASE_LEN;	# shortcut for short numbers

  # this leaves '00000' instead of int 0 and will be corrected after any op
  [ reverse(unpack("a" . ($il % $BASE_LEN+1) 
    . ("a$BASE_LEN" x ($il / $BASE_LEN)), $_[1])) ];
  }                                                                             

d126 22
a147 1
  __PACKAGE__->_base_len($e);	# set and store
d182 21
a207 2
###############################################################################

d331 1
a331 1
  push @@$x,1 if (($x->[-1] || 0) == 0);		# last overflowed, so extend
d971 1
a971 1
  $elem = '0000000'.@@$x[$elem];		# get element padded with 0's
d1179 1
a1179 1
  if ($src >= $xlen or ($src == $xlen and ! defined $x->[1]))
d1764 5
a1768 1
  return sprintf("0x%x",$x->[0]) if @@$x == 1;
d1782 1
d1790 2
a1791 1
  '0x' . $es;					# return result prepended with 0x
d1822 1
d1831 2
a1832 1
  '0b' . $es;					# return result prepended with 0b
a1839 9
  my $m = _new($c, 0x10000000);			# 28 bit at a time (<32 bit!)
  my $d = 7;					# 7 digits at a time
  if ($] <= 5.006)
    {
    # for older Perls, play safe
    $m = [ 0x10000 ];				# 16 bit at a time (<32 bit!)
    $d = 4;					# 4 digits at a time
    }

d1841 1
d1844 3
a1846 2
  my $len = int( (length($hs)-2)/$d );		# $d digit parts, w/o the '0x'
  my $val; my $i = -$d;
d1849 1
a1849 1
    $val = substr($hs,$i,$d);			# get hex digits
d1852 2
a1853 9
    $i -= $d; $len --;
    my $adder = [ $val ];
    # if the resulting number was to big to fit into one element, create a
    # two-element version (bug found by Mark Lakata - Thanx!)
    if (CORE::length($val) > $BASE_LEN)
      {
      $adder = _new($c,$val);
      }
    _add ($c, $x, _mul ($c, $adder, $mul ) ) if $val != 0;
d1871 1
a1871 1
  my $h = '0x' . unpack('H*', pack ('B*', $hs));	# repack as hex
d1873 1
a1873 1
  $c->_from_hex($h);
d1906 2
a1907 1
  ($u1, $sign == 1 ? '+' : '-');
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d9 1
a9 1
$VERSION = '0.47';
d18 1
a18 1
# - fully remove funky $# stuff in div() (maybe - that code scares me...)
d39 2
a40 1
my ($BASE,$BASE_LEN,$MBASE,$RBASE,$MAX_VAL,$BASE_LEN_SMALL);
d74 1
a74 3
   
    # avoid redefinitions
 
d96 1
a96 1
  return ($BASE_LEN, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN_SMALL, $MAX_VAL, $BASE);
d135 5
a141 1
  use integer;
d224 1
d226 2
a227 6
  my $l = scalar @@$ar;				# number of parts
  if ($l < 1)					# should not happen
    {
    require Carp;
    Carp::croak("$_[1] has no elements");
    }
a228 1
  my $ret = "";
d575 2
a576 2
      # same length, so make full compare

d584 1
a584 1
      # a < 0: x < y, a == 0: x == y, a > 0: x > y
d587 12
a598 5
        $rem = [ 0 ];                   # a = 0 => x == y => rem 0
        $rem = [@@$x] if $a != 0;        # a < 0 => x < y => rem = x
        splice(@@$x,1);                  # keep single element
        $x->[0] = 0;                    # if $a < 0
        $x->[0] = 1 if $a == 0;         # $x == $y
d602 1
a602 1
      # $x >= $y, so proceed normally
d769 2
a770 2
      # same length, so make full compare

d778 1
a778 1
      # a < 0: x < y, a == 0: x == y, a > 0: x > y
d781 5
a785 2
        $rem = [ 0 ];			# a = 0 => x == y => rem 0
        $rem = [@@$x] if $a != 0;	# a < 0 => x < y => rem = x
d788 6
a793 2
        $x->[0] = 1 if $a == 0; 	# $x == $y
        return ($x,$rem) if wantarray;	# including remainder?
a796 1

d945 1
a945 1
  $elem = '0' x $BASE_LEN . @@$x[$elem];	# get element padded with 0's
d1931 1
a1931 1
  while ( (scalar @@$y != 1) || ($y->[0] != 0) )		# while ($y != 0)
d2106 2
a2107 2

Fixed, speed-up, streamlined and enhanced by Tels 2001 - 2005.
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
use 5.006;
d7 3
a9 1
our $VERSION = '0.52';
d27 1
a27 1
# $i = $i * $y + $car; $car = int($i / $BASE); $i = $i % $BASE;
d30 1
a30 1
# $i = $i * $y + $car; $car = int($i / $BASE); $i -= $BASE * $car;
d35 2
a36 2
# announce that we are compatible with MBI v1.83 and up
sub api_version () { 2; }
d39 1
a39 1
my ($BASE,$BASE_LEN,$RBASE,$MAX_VAL);
d45 2
a46 3
  # Set/get the BASE_LEN and assorted other, connected values.
  # Used only by the testsuite, the set variant is used only by the BEGIN
  # block below:
d49 1
a49 1
  my ($b, $int) = @@_;
d52 3
a54 17
    # avoid redefinitions
    undef &_mul;
    undef &_div;

    if ($] >= 5.008 && $int && $b > 7)
      {
      $BASE_LEN = $b;
      *_mul = \&_mul_use_div_64;
      *_div = \&_div_use_div_64;
      $BASE = int("1e".$BASE_LEN);
      $MAX_VAL = $BASE-1;
      return $BASE_LEN unless wantarray;
      return ($BASE_LEN, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN, $MAX_VAL, $BASE);
      }

    # find whether we can use mul or div in mul()/div()
    $BASE_LEN = $b+1;
d56 1
a56 1
    while (--$BASE_LEN > 5)
d58 2
a59 2
      $BASE = int("1e".$BASE_LEN);
      $RBASE = abs('1e-'.$BASE_LEN);			# see USE_MUL
d61 2
a62 2
      $caught += 1 if (int($BASE * $RBASE) != 1);	# should be 1
      $caught += 2 if (int($BASE / $BASE) != 1);	# should be 1
d65 3
d69 4
a72 2
    $RBASE = abs('1e-'.$BASE_LEN);			# see USE_MUL
    $MAX_VAL = $BASE-1;
d74 9
a82 2
    # ($caught & 1) != 0 => cannot use MUL
    # ($caught & 2) != 0 => cannot use DIV
d86 2
a87 2
      *_mul = \&_mul_use_mul;
      *_div = \&_div_use_mul;
d92 2
a93 2
      *_mul = \&_mul_use_div;
      *_div = \&_div_use_div;
d97 1
a97 1
  return ($BASE_LEN, $AND_BITS, $XOR_BITS, $OR_BITS, $BASE_LEN, $MAX_VAL, $BASE);
d132 3
d136 1
a136 19
  my $int = 0;
  if ($e > 7)
    {
    use integer;
    my $e1 = 7;
    $num = 7;
    do 
      {
      $num = ('9' x ++$e1) + 0;
      $num *= $num + 1;
      } while ("$num" =~ /9{$e1}0{$e1}/);	# must be a certain pattern
    $e1--; 					# last test failed, so retract one step
    if ($e1 > 7)
      { 
      $int = 1; $e = $e1; 
      }
    }
 
  __PACKAGE__->_base_len($e,$int);	# set and store
d155 1
a155 1
    $x = CORE::oct('0b' . '1' x $AND_BITS); $y = $x & $x;
d161 1
a161 1
    $x = CORE::oct('0b' . '1' x $XOR_BITS); $y = $x ^ 0;
d167 1
a167 1
    $x = CORE::oct('0b' . '1' x $OR_BITS); $y = $x | $x;
a174 3

  # We can compute the approximate lenght no faster than the real length:
  *_alen = \&_len;
a202 10
sub _1ex
  {
  # create a 1Ex
  my $rem = $_[1] % $BASE_LEN;		# remainder
  my $parts = $_[1] / $BASE_LEN;	# parts

  # 000000, 000000, 100 
  [ (0) x $parts, '1' . ('0' x $rem) ];
  }

d275 1
a275 1
    # twice as slow as $x = [ @@$y ], but nec. to retain $x as ref :(
d316 1
a316 1
  my $MAX = $BASE-1;				# since MAX_VAL based on BASE
d370 1
a370 1
      if (($xv->[0] *= $yv->[0]) >= $BASE)
d372 1
a372 1
         $xv->[0] = $xv->[0] - ($xv->[1] = int($xv->[0] * $RBASE)) * $BASE;
d386 1
a386 1
      $i = $i * $y + $car; $car = int($i * $RBASE); $i -= $car * $BASE;
d408 1
a408 1
#       $prod - ($car = int($prod * RBASE)) * $BASE;  # see USE_MUL
d422 1
a422 66
       $prod - ($car = int($prod * $RBASE)) * $BASE;  # see USE_MUL
      }
    $prod[$cty] += $car if $car; # need really to check for 0?
    $xi = shift @@prod || 0;	# || 0 makes v5.005_3 happy
    }
  push @@$xv, @@prod;
  # can't have leading zeros
#  __strip_zeros($xv);
  $xv;
  }                                                                             

sub _mul_use_div_64
  {
  # (ref to int_num_array, ref to int_num_array)
  # multiply two numbers in internal representation
  # modifies first arg, second need not be different from first
  # works for 64 bit integer with "use integer"
  my ($c,$xv,$yv) = @@_;

  use integer;
  if (@@$yv == 1)
    {
    # shortcut for two small numbers, also handles $x == 0
    if (@@$xv == 1)
      {
      # shortcut for two very short numbers (improved by Nathan Zook)
      # works also if xv and yv are the same reference, and handles also $x == 0
      if (($xv->[0] *= $yv->[0]) >= $BASE)
          {
          $xv->[0] =
              $xv->[0] - ($xv->[1] = $xv->[0] / $BASE) * $BASE;
          };
      return $xv;
      }
    # $x * 0 => 0
    if ($yv->[0] == 0)
      {
      @@$xv = (0);
      return $xv;
      }
    # multiply a large number a by a single element one, so speed up
    my $y = $yv->[0]; my $car = 0;
    foreach my $i (@@$xv)
      {
      #$i = $i * $y + $car; $car = $i / $BASE; $i -= $car * $BASE;
      $i = $i * $y + $car; $i -= ($car = $i / $BASE) * $BASE;
      }
    push @@$xv, $car if $car != 0;
    return $xv;
    }
  # shortcut for result $x == 0 => result = 0
  return $xv if ( ((@@$xv == 1) && ($xv->[0] == 0)) ); 

  # since multiplying $x with $x fails, make copy in this case
  $yv = [@@$xv] if $xv == $yv;	# same references?

  my @@prod = (); my ($prod,$car,$cty,$xi,$yi);
  for $xi (@@$xv)
    {
    $car = 0; $cty = 0;
    # looping through this if $xi == 0 is silly - so optimize it away!
    $xi = (shift @@prod || 0), next if $xi == 0;
    for $yi (@@$yv)
      {
      $prod = $xi * $yi + ($prod[$cty] || 0) + $car;
      $prod[$cty++] = $prod - ($car = $prod / $BASE) * $BASE;
d428 1
d438 1
a438 1

d446 1
a446 1
      if (($xv->[0] *= $yv->[0]) >= $BASE)
d449 1
a449 1
              $xv->[0] - ($xv->[1] = int($xv->[0] / $BASE)) * $BASE;
d463 1
a463 3
      $i = $i * $y + $car; $car = int($i / $BASE); $i -= $car * $BASE;
      # This (together with use integer;) does not work on 32-bit Perls
      #$i = $i * $y + $car; $i -= ($car = $i / $BASE) * $BASE;
d483 2
a484 1
      $prod[$cty++] = $prod - ($car = int($prod / $BASE)) * $BASE;
d490 1
a490 2
  # can't have leading zeros
#  __strip_zeros($xv);
d537 1
a537 1
      $b = $r * $BASE + $x->[$j];
d607 1
a607 1
  if (($dd = int($BASE/($y->[-1]+1))) != 1) 
d612 1
a612 1
      $xi -= ($car = int($xi * $RBASE)) * $BASE;	# see USE_MUL
d618 1
a618 1
      $yi -= ($car = int($yi * $RBASE)) * $BASE;	# see USE_MUL
d633 2
a634 2
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
d641 2
a642 2
        $prd -= ($car = int($prd * $RBASE)) * $BASE;	# see USE_MUL
	$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
d649 2
a650 2
	  $x->[$xi] -= $BASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));
d665 1
a665 1
        $prd = $car * $BASE + $xi;
a684 193
sub _div_use_div_64
  {
  # ref to array, ref to array, modify first array and return remainder if 
  # in list context
  # This version works on 64 bit integers
  my ($c,$x,$yorg) = @@_;

  use integer;
  # the general div algorithmn here is about O(N*N) and thus quite slow, so
  # we first check for some special cases and use shortcuts to handle them.

  # This works, because we store the numbers in a chunked format where each
  # element contains 5..7 digits (depending on system).

  # if both numbers have only one element:
  if (@@$x == 1 && @@$yorg == 1)
    {
    # shortcut, $yorg and $x are two small numbers
    if (wantarray)
      {
      my $r = [ $x->[0] % $yorg->[0] ];
      $x->[0] = int($x->[0] / $yorg->[0]);
      return ($x,$r); 
      }
    else
      {
      $x->[0] = int($x->[0] / $yorg->[0]);
      return $x; 
      }
    }
  # if x has more than one, but y has only one element:
  if (@@$yorg == 1)
    {
    my $rem;
    $rem = _mod($c,[ @@$x ],$yorg) if wantarray;

    # shortcut, $y is < $BASE
    my $j = scalar @@$x; my $r = 0; 
    my $y = $yorg->[0]; my $b;
    while ($j-- > 0)
      {
      $b = $r * $BASE + $x->[$j];
      $x->[$j] = int($b/$y);
      $r = $b % $y;
      }
    pop @@$x if @@$x > 1 && $x->[-1] == 0;	# splice up a leading zero 
    return ($x,$rem) if wantarray;
    return $x;
    }
  # now x and y have more than one element

  # check whether y has more elements than x, if yet, the result will be 0
  if (@@$yorg > @@$x)
    {
    my $rem;
    $rem = [@@$x] if wantarray;			# make copy
    splice (@@$x,1);				# keep ref to original array
    $x->[0] = 0;				# set to 0
    return ($x,$rem) if wantarray;		# including remainder?
    return $x;					# only x, which is [0] now
    }
  # check whether the numbers have the same number of elements, in that case
  # the result will fit into one element and can be computed efficiently
  if (@@$yorg == @@$x)
    {
    my $rem;
    # if $yorg has more digits than $x (it's leading element is longer than
    # the one from $x), the result will also be 0:
    if (length(int($yorg->[-1])) > length(int($x->[-1])))
      {
      $rem = [@@$x] if wantarray;		# make copy
      splice (@@$x,1);				# keep ref to org array
      $x->[0] = 0;				# set to 0
      return ($x,$rem) if wantarray;		# including remainder?
      return $x;
      }
    # now calculate $x / $yorg

    if (length(int($yorg->[-1])) == length(int($x->[-1])))
      {
      # same length, so make full compare

      my $a = 0; my $j = scalar @@$x - 1;
      # manual way (abort if unequal, good for early ne)
      while ($j >= 0)
        {
        last if ($a = $x->[$j] - $yorg->[$j]); $j--;
        }
      # $a contains the result of the compare between X and Y
      # a < 0: x < y, a == 0: x == y, a > 0: x > y
      if ($a <= 0)
        {
        $rem = [ 0 ];			# a = 0 => x == y => rem 0
        $rem = [@@$x] if $a != 0;	# a < 0 => x < y => rem = x
        splice(@@$x,1);			# keep single element
        $x->[0] = 0;			# if $a < 0
        $x->[0] = 1 if $a == 0; 	# $x == $y
        return ($x,$rem) if wantarray;	# including remainder?
        return $x;
        }
      # $x >= $y, so proceed normally

      }
    }

  # all other cases:

  my $y = [ @@$yorg ];				# always make copy to preserve
 
  my ($car,$bar,$prd,$dd,$xi,$yi,@@q,$v2,$v1,@@d,$tmp,$q,$u2,$u1,$u0);

  $car = $bar = $prd = 0;
  if (($dd = int($BASE/($y->[-1]+1))) != 1) 
    {
    for $xi (@@$x) 
      {
      $xi = $xi * $dd + $car;
      $xi -= ($car = int($xi / $BASE)) * $BASE;
      }
    push(@@$x, $car); $car = 0;
    for $yi (@@$y) 
      {
      $yi = $yi * $dd + $car;
      $yi -= ($car = int($yi / $BASE)) * $BASE;
      }
    }
  else 
    {
    push(@@$x, 0);
    }

  # @@q will accumulate the final result, $q contains the current computed
  # part of the final result

  @@q = (); ($v2,$v1) = @@$y[-2,-1];
  $v2 = 0 unless $v2;
  while ($#$x > $#$y) 
    {
    ($u2,$u1,$u0) = @@$x[-3..-1];
    $u2 = 0 unless $u2;
    #warn "oups v1 is 0, u0: $u0 $y->[-2] $y->[-1] l ",scalar @@$y,"\n"
    # if $v1 == 0;
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
    if ($q)
      {
      ($car, $bar) = (0,0);
      for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
        {
        $prd = $q * $y->[$yi] + $car;
        $prd -= ($car = int($prd / $BASE)) * $BASE;
	$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
	}
      if ($x->[-1] < $car + $bar) 
        {
        $car = 0; --$q;
	for ($yi = 0, $xi = $#$x-$#$y-1; $yi <= $#$y; ++$yi,++$xi) 
          {
	  $x->[$xi] -= $BASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));
	  }
	}   
      }
    pop(@@$x); unshift(@@q, $q);
    }
  if (wantarray) 
    {
    @@d = ();
    if ($dd != 1)  
      {
      $car = 0; 
      for $xi (reverse @@$x) 
        {
        $prd = $car * $BASE + $xi;
        $car = $prd - ($tmp = int($prd / $dd)) * $dd;
        unshift(@@d, $tmp);
        }
      }
    else 
      {
      @@d = @@$x;
      }
    @@$x = @@q;
    my $d = \@@d; 
    __strip_zeros($x);
    __strip_zeros($d);
    return ($x,$d);
    }
  @@$x = @@q;
  __strip_zeros($x);
  $x;
  }

d724 1
a724 1
      $b = $r * $BASE + $x->[$j];
d795 1
a795 1
  if (($dd = int($BASE/($y->[-1]+1))) != 1) 
d800 1
a800 1
      $xi -= ($car = int($xi / $BASE)) * $BASE;
d806 1
a806 1
      $yi -= ($car = int($yi / $BASE)) * $BASE;
d825 2
a826 2
    $q = (($u0 == $v1) ? $MAX_VAL : int(($u0*$BASE+$u1)/$v1));
    --$q while ($v2*$q > ($u0*$BASE+$u1-$q*$v1)*$BASE+$u2);
d833 2
a834 2
        $prd -= ($car = int($prd / $BASE)) * $BASE;
	$x->[$xi] += $BASE if ($bar = (($x->[$xi] -= $prd + $bar) < 0));
d841 2
a842 2
	  $x->[$xi] -= $BASE
	   if ($car = (($x->[$xi] += $y->[$yi] + $car) >= $BASE));
d856 1
a856 1
        $prd = $car * $BASE + $xi;
d910 1
a910 1
  # compute number of digits in base 10
a1244 46
sub _nok
  {
  # n over k
  # ref to array, return ref to array
  my ($c,$n,$k) = @@_;

  # ( 7 )    7!          7*6*5 * 4*3*2*1   7 * 6 * 5
  # ( - ) = --------- =  --------------- = ---------
  # ( 3 )   3! (7-3)!    3*2*1 * 4*3*2*1   3 * 2 * 1 

  # compute n - k + 2 (so we start with 5 in the example above)
  my $x = _copy($c,$n);

  _sub($c,$n,$k);
  if (!_is_one($c,$n))
    {
    _inc($c,$n);
    my $f = _copy($c,$n); _inc($c,$f);		# n = 5, f = 6, d = 2
    my $d = _two($c);
    while (_acmp($c,$f,$x) <= 0)		# f < n ?
      {
      # n = (n * f / d) == 5 * 6 / 2 => n == 3
      $n = _mul($c,$n,$f); $n = _div($c,$n,$d);
      # f = 7, d = 3
      _inc($c,$f); _inc($c,$d);
      }
    }
  else 
    {
    # keep ref to $n and set it to 1
    splice (@@$n,1); $n->[0] = 1;
    }
  $n;
  }

my @@factorials = (
  1,
  1,
  2,
  2*3,
  2*3*4,
  2*3*4*5,
  2*3*4*5*6,
  2*3*4*5*6*7,
);

d1251 1
a1251 1
  if ((@@$cx == 1) && ($cx->[0] <= 7))
d1253 1
a1253 1
    $cx->[0] = $factorials[$cx->[0]];		# 0 => 1, 1 => 1, 2 => 2 etc.
a1256 69
  if ((@@$cx == 1) && 		# we do this only if $x >= 12 and $x <= 7000
      ($cx->[0] >= 12 && $cx->[0] < 7000))
    {

  # Calculate (k-j) * (k-j+1) ... k .. (k+j-1) * (k + j)
  # See http://blogten.blogspot.com/2007/01/calculating-n.html
  # The above series can be expressed as factors:
  #   k * k - (j - i) * 2
  # We cache k*k, and calculate (j * j) as the sum of the first j odd integers

  # This will not work when N exceeds the storage of a Perl scalar, however,
  # in this case the algorithm would be way to slow to terminate, anyway.

  # As soon as the last element of $cx is 0, we split it up and remember
  # how many zeors we got so far. The reason is that n! will accumulate
  # zeros at the end rather fast.
  my $zero_elements = 0;

  # If n is even, set n = n -1
  my $k = _num($c,$cx); my $even = 1;
  if (($k & 1) == 0)
    {
    $even = $k; $k --;
    }
  # set k to the center point
  $k = ($k + 1) / 2;
#  print "k $k even: $even\n";
  # now calculate k * k
  my $k2 = $k * $k;
  my $odd = 1; my $sum = 1;
  my $i = $k - 1;
  # keep reference to x
  my $new_x = _new($c, $k * $even);
  @@$cx = @@$new_x;
  if ($cx->[0] == 0)
    {
    $zero_elements ++; shift @@$cx;
    }
#  print STDERR "x = ", _str($c,$cx),"\n";
  my $BASE2 = int(sqrt($BASE))-1;
  my $j = 1; 
  while ($j <= $i)
    {
    my $m = ($k2 - $sum); $odd += 2; $sum += $odd; $j++;
    while ($j <= $i && ($m < $BASE2) && (($k2 - $sum) < $BASE2))
      {
      $m *= ($k2 - $sum);
      $odd += 2; $sum += $odd; $j++;
#      print STDERR "\n k2 $k2 m $m sum $sum odd $odd\n"; sleep(1);
      }
    if ($m < $BASE)
      {
      _mul($c,$cx,[$m]);
      }
    else
      {
      _mul($c,$cx,$c->_new($m));
      }
    if ($cx->[0] == 0)
      {
      $zero_elements ++; shift @@$cx;
      }
#    print STDERR "Calculate $k2 - $sum = $m (x = ", _str($c,$cx),")\n";
    }
  # multiply in the zeros again
  unshift @@$cx, (0) x $zero_elements; 
  return $cx;
  }

d1284 1
a1284 5
  # Set $cx to the last result below $BASE (but keep ref to $x)
  $cx->[0] = $last; splice (@@$cx,1);
  # As soon as the last element of $cx is 0, we split it up and remember
  # how many zeors we got so far. The reason is that n! will accumulate
  # zeros at the end rather fast.
a1290 12
    # ($n is at least $BASE here)
    my $base_2 = int(sqrt($BASE)) - 1;
    #print STDERR "base_2: $base_2\n"; 
    while ($step < $base_2)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @@$cx;
        }
      my $b = $step * ($step + 1); $step += 2;
      _mul($c,$cx,[$b]);
      }
d1292 1
a1292 1
    while (_acmp($c,$step,$n) <= 0)
d1294 3
d1307 1
a1307 7
  
#    print "# left over steps $n\n";

    my $base_4 = int(sqrt(sqrt($BASE))) - 2;
    #print STDERR "base_4: $base_4\n";
    my $n4 = $n - 4; 
    while ($step < $n4 && $step < $base_4)
d1309 3
a1315 18
      my $b = $step * ($step + 1); $step += 2; $b *= $step * ($step + 1); $step += 2;
      _mul($c,$cx,[$b]);
      }
    my $base_2 = int(sqrt($BASE)) - 1;
    my $n2 = $n - 2; 
    #print STDERR "base_2: $base_2\n"; 
    while ($step < $n2 && $step < $base_2)
      {
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @@$cx;
        }
      my $b = $step * ($step + 1); $step += 2;
      _mul($c,$cx,[$b]);
      }
    # do what's left over
    while ($step <= $n)
      {
a1316 4
      if ($cx->[0] == 0)
        {
        $zero_elements ++; shift @@$cx;
        }
d1320 4
a1323 1
  unshift @@$cx, (0) x $zero_elements;
d1352 3
d1358 1
a1358 16
  # Compute a guess for the result based on:
  # $guess = int ( length_in_base_10(X) / ( log(base) / log(10) ) )
  my $len = _len($c,$x_org);
  my $log = log($base->[-1]) / log(10);

  # for each additional element in $base, we add $BASE_LEN to the result,
  # based on the observation that log($BASE,10) is BASE_LEN and
  # log(x*y) == log(x) + log(y):
  $log += ((scalar @@$base)-1) * $BASE_LEN;

  # calculate now a guess based on the values obtained above:
  my $res = int($len / $log);

  $x->[0] = $res;
  my $trial = _pow ($c, _copy($c, $base), $x);
  my $a = _acmp($c,$trial,$x_org);
d1360 2
a1361 6
#  print STDERR "# trial ", _str($c,$x)," was: $a (0 = exact, -1 too small, +1 too big)\n";

  # found an exact result?
  return ($x,1) if $a == 0;

  if ($a > 0)
d1363 10
a1372 3
    # or too big
    _div($c,$trial,$base); _dec($c, $x);
    while (($a = _acmp($c,$trial,$x_org)) > 0)
d1374 1
a1374 2
#      print STDERR "# big _log_int at ", _str($c,$x), "\n"; 
      _div($c,$trial,$base); _dec($c, $x);
d1376 17
a1392 9
    # result is now exact (a == 0), or too small (a < 0)
    return ($x, $a == 0 ? 1 : 0);
    }

  # else: result was to small
  _mul($c,$trial,$base);

  # did we now get the right result?
  $a = _acmp($c,$trial,$x_org);
d1394 2
a1395 15
  if ($a == 0)				# yes, exactly
    {
    _inc($c, $x);
    return ($x,1); 
    }
  return ($x,0) if $a > 0;  

  # Result still too small (we should come here only if the estimate above
  # was very off base):
 
  # Now let the normal trial run obtain the real result
  # Simple loop that increments $x by 2 in each step, possible overstepping
  # the real result

  my $base_mul = _mul($c, _copy($c,$base), $base);	# $base * $base
a1398 1
#    print STDERR "# small _log_int at ", _str($c,$x), "\n"; 
d1413 1
a1413 1
    $exact = 0 if $a != 0;		# a = -1 => not exact result, a = 0 => exact
d1433 1
a1433 1
    # fits into one Perl scalar, so result can be computed directly
d1516 1
a1516 1
      # fits into one Perl scalar, so result can be computed directly
d1725 1
a1725 1
  # fits into one element (handle also 0x0 case)
d1743 1
a1743 1
    $es .= unpack($h,pack('V',$xr->[0]));
d1755 1
a1755 1
  # fits into one element (and Perl recent enough), handle also 0b0 case
d1781 2
a1782 1
    $es .= unpack($b,pack('v',$xr->[0]));
a1788 49
sub _as_oct
  {
  # convert a decimal number to octal (ref to array, return ref to string)
  my ($c,$x) = @@_;

  # fits into one element (handle also 0 case)
  return sprintf("0%o",$x->[0]) if @@$x == 1;

  my $x1 = _copy($c,$x);

  my $es = '';
  my $xr;
  my $x1000 = [ 0100000 ];
  while (@@$x1 != 1 || $x1->[0] != 0)		# _is_zero()
    {
    ($x1, $xr) = _div($c,$x1,$x1000);
    $es .= reverse sprintf("%05o", $xr->[0]);
    }
  $es = reverse $es;
  $es =~ s/^[0]+//;   # strip leading zeros
  '0' . $es;					# return result prepended with 0
  }

sub _from_oct
  {
  # convert a octal number to decimal (string, return ref to array)
  my ($c,$os) = @@_;

  # for older Perls, play safe
  my $m = [ 0100000 ];
  my $d = 5;					# 5 digits at a time

  my $mul = _one();
  my $x = _zero();

  my $len = int( (length($os)-1)/$d );		# $d digit parts, w/o the '0'
  my $val; my $i = -$d;
  while ($len >= 0)
    {
    $val = substr($os,$i,$d);			# get oct digits
    $val = CORE::oct($val);
    $i -= $d; $len --;
    my $adder = [ $val ];
    _add ($c, $x, _mul ($c, $adder, $mul ) ) if $val != 0;
    _mul ($c, $mul, $m ) if $len >= 0; 		# skip last mul
    }
  $x;
  }

d1791 1
a1791 1
  # convert a hex number to decimal (string, return ref to array)
d1811 2
a1812 2
    $val =~ s/^0x// if $len == 0;		# for last part only because
    $val = CORE::hex($val);			# hex does not like wrong chars
d1829 1
a1829 1
  # convert a hex number to decimal (string, return ref to array)
d1962 1
a1962 1
	api_version()	return API version, 1 for v1.70, 2 for v1.83
d1973 1
a1973 1
			machine-dependent floating point size limitations
d1988 1
a1988 1
	_dec(obj)	decrement object by one (input is guaranteed to be > 0)
d2009 2
a2010 3
	_from_hex(str)	return new object from a hexadecimal string
	_from_bin(str)	return new object from a binary string
	_from_oct(str)	return new object from an octal string
d2027 1
a2027 1
	_mod(obj1,obj2)	Return remainder of div of the 1st by the 2nd object
d2031 1
a2031 1
	_pow(obj1,obj2)	return object 1 to the power of object 2
a2043 8
The following functions are REQUIRED for an api_version of 2 or greater:

	_1ex($x)	create the number 1Ex where x >= 0
	_alen(obj)	returns approximate count of the decimal digits of the
			object. This estimate MUST always be greater or equal
			to what _len() returns.
        _nok(n,k)	calculate n over k (binomial coefficient)

d2052 1
d2063 1
a2063 1
the reference and just changing its contents is preferred over creating and
d2067 1
a2067 1
comparison routines.
d2095 1
a2095 1
Fixed, speed-up, streamlined and enhanced by Tels 2001 - 2007.
d2099 1
a2099 1
L<Math::BigInt>, L<Math::BigFloat>,
@


