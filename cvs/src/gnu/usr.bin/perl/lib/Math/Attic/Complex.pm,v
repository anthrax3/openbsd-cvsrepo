head	1.10;
access;
symbols
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2010.09.24.14.59.42;	author millert;	state dead;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.34;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.46;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.46;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.34;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.51;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.37;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.53;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#
# Complex numbers and associated mathematical functions
# -- Raphael Manfredi	Since Sep 1996
# -- Jarkko Hietaniemi	Since Mar 1997
# -- Daniel S. Lewart	Since Sep 1997
#

package Math::Complex;

use strict;

use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS $Inf $ExpInf);

$VERSION = 1.56;

use Config;

BEGIN {
    my %DBL_MAX =
	(
	  4  => '1.70141183460469229e+38',
	  8  => '1.7976931348623157e+308',
	 # AFAICT the 10, 12, and 16-byte long doubles
	 # all have the same maximum.
	 10 => '1.1897314953572317650857593266280070162E+4932',
	 12 => '1.1897314953572317650857593266280070162E+4932',
	 16 => '1.1897314953572317650857593266280070162E+4932',
	);
    my $nvsize = $Config{nvsize} ||
	        ($Config{uselongdouble} && $Config{longdblsize}) ||
                 $Config{doublesize};
    die "Math::Complex: Could not figure out nvsize\n"
	unless defined $nvsize;
    die "Math::Complex: Cannot not figure out max nv (nvsize = $nvsize)\n"
	unless defined $DBL_MAX{$nvsize};
    my $DBL_MAX = eval $DBL_MAX{$nvsize};
    die "Math::Complex: Could not figure out max nv (nvsize = $nvsize)\n"
	unless defined $DBL_MAX;
    my $BIGGER_THAN_THIS = 1e30;  # Must find something bigger than this.
    if ($^O eq 'unicosmk') {
	$Inf = $DBL_MAX;
    } else {
	local $SIG{FPE} = { };
        local $!;
	# We do want an arithmetic overflow, Inf INF inf Infinity.
	for my $t (
	    'exp(99999)',  # Enough even with 128-bit long doubles.
	    'inf',
	    'Inf',
	    'INF',
	    'infinity',
	    'Infinity',
	    'INFINITY',
	    '1e99999',
	    ) {
	    local $^W = 0;
	    my $i = eval "$t+1.0";
	    if (defined $i && $i > $BIGGER_THAN_THIS) {
		$Inf = $i;
		last;
	    }
	}
	$Inf = $DBL_MAX unless defined $Inf;  # Oh well, close enough.
	die "Math::Complex: Could not get Infinity"
	    unless $Inf > $BIGGER_THAN_THIS;
	$ExpInf = exp(99999);
    }
    # print "# On this machine, Inf = '$Inf'\n";
}

use Scalar::Util qw(set_prototype);

use warnings;
no warnings 'syntax';  # To avoid the (_) warnings.

BEGIN {
    # For certain functions that we override, in 5.10 or better
    # we can set a smarter prototype that will handle the lexical $_
    # (also a 5.10+ feature).
    if ($] >= 5.010000) {
        set_prototype \&abs, '_';
        set_prototype \&cos, '_';
        set_prototype \&exp, '_';
        set_prototype \&log, '_';
        set_prototype \&sin, '_';
        set_prototype \&sqrt, '_';
    }
}

my $i;
my %LOGN;

# Regular expression for floating point numbers.
# These days we could use Scalar::Util::lln(), I guess.
my $gre = qr'\s*([\+\-]?(?:(?:(?:\d+(?:_\d+)*(?:\.\d*(?:_\d+)*)?|\.\d+(?:_\d+)*)(?:[eE][\+\-]?\d+(?:_\d+)*)?))|inf)'i;

require Exporter;

@@ISA = qw(Exporter);

my @@trig = qw(
	      pi
	      tan
	      csc cosec sec cot cotan
	      asin acos atan
	      acsc acosec asec acot acotan
	      sinh cosh tanh
	      csch cosech sech coth cotanh
	      asinh acosh atanh
	      acsch acosech asech acoth acotanh
	     );

@@EXPORT = (qw(
	     i Re Im rho theta arg
	     sqrt log ln
	     log10 logn cbrt root
	     cplx cplxe
	     atan2
	     ),
	   @@trig);

my @@pi = qw(pi pi2 pi4 pip2 pip4 Inf);

@@EXPORT_OK = @@pi;

%EXPORT_TAGS = (
    'trig' => [@@trig],
    'pi' => [@@pi],
);

use overload
	'+'	=> \&_plus,
	'-'	=> \&_minus,
	'*'	=> \&_multiply,
	'/'	=> \&_divide,
	'**'	=> \&_power,
	'=='	=> \&_numeq,
	'<=>'	=> \&_spaceship,
	'neg'	=> \&_negate,
	'~'	=> \&_conjugate,
	'abs'	=> \&abs,
	'sqrt'	=> \&sqrt,
	'exp'	=> \&exp,
	'log'	=> \&log,
	'sin'	=> \&sin,
	'cos'	=> \&cos,
	'tan'	=> \&tan,
	'atan2'	=> \&atan2,
        '""'    => \&_stringify;

#
# Package "privates"
#

my %DISPLAY_FORMAT = ('style' => 'cartesian',
		      'polar_pretty_print' => 1);
my $eps            = 1e-14;		# Epsilon

#
# Object attributes (internal):
#	cartesian	[real, imaginary] -- cartesian form
#	polar		[rho, theta] -- polar form
#	c_dirty		cartesian form not up-to-date
#	p_dirty		polar form not up-to-date
#	display		display format (package's global when not set)
#

# Die on bad *make() arguments.

sub _cannot_make {
    die "@@{[(caller(1))[3]]}: Cannot take $_[0] of '$_[1]'.\n";
}

sub _make {
    my $arg = shift;
    my ($p, $q);

    if ($arg =~ /^$gre$/) {
	($p, $q) = ($1, 0);
    } elsif ($arg =~ /^(?:$gre)?$gre\s*i\s*$/) {
	($p, $q) = ($1 || 0, $2);
    } elsif ($arg =~ /^\s*\(\s*$gre\s*(?:,\s*$gre\s*)?\)\s*$/) {
	($p, $q) = ($1, $2 || 0);
    }

    if (defined $p) {
	$p =~ s/^\+//;
	$p =~ s/^(-?)inf$/"${1}9**9**9"/e;
	$q =~ s/^\+//;
	$q =~ s/^(-?)inf$/"${1}9**9**9"/e;
    }

    return ($p, $q);
}

sub _emake {
    my $arg = shift;
    my ($p, $q);

    if ($arg =~ /^\s*\[\s*$gre\s*(?:,\s*$gre\s*)?\]\s*$/) {
	($p, $q) = ($1, $2 || 0);
    } elsif ($arg =~ m!^\s*\[\s*$gre\s*(?:,\s*([-+]?\d*\s*)?pi(?:/\s*(\d+))?\s*)?\]\s*$!) {
	($p, $q) = ($1, ($2 eq '-' ? -1 : ($2 || 1)) * pi() / ($3 || 1));
    } elsif ($arg =~ /^\s*\[\s*$gre\s*\]\s*$/) {
	($p, $q) = ($1, 0);
    } elsif ($arg =~ /^\s*$gre\s*$/) {
	($p, $q) = ($1, 0);
    }

    if (defined $p) {
	$p =~ s/^\+//;
	$q =~ s/^\+//;
	$p =~ s/^(-?)inf$/"${1}9**9**9"/e;
	$q =~ s/^(-?)inf$/"${1}9**9**9"/e;
    }

    return ($p, $q);
}

#
# ->make
#
# Create a new complex number (cartesian form)
#
sub make {
    my $self = bless {}, shift;
    my ($re, $im);
    if (@@_ == 0) {
	($re, $im) = (0, 0);
    } elsif (@@_ == 1) {
	return (ref $self)->emake($_[0])
	    if ($_[0] =~ /^\s*\[/);
	($re, $im) = _make($_[0]);
    } elsif (@@_ == 2) {
	($re, $im) = @@_;
    }
    if (defined $re) {
	_cannot_make("real part",      $re) unless $re =~ /^$gre$/;
    }
    $im ||= 0;
    _cannot_make("imaginary part", $im) unless $im =~ /^$gre$/;
    $self->_set_cartesian([$re, $im ]);
    $self->display_format('cartesian');

    return $self;
}

#
# ->emake
#
# Create a new complex number (exponential form)
#
sub emake {
    my $self = bless {}, shift;
    my ($rho, $theta);
    if (@@_ == 0) {
	($rho, $theta) = (0, 0);
    } elsif (@@_ == 1) {
	return (ref $self)->make($_[0])
	    if ($_[0] =~ /^\s*\(/ || $_[0] =~ /i\s*$/);
	($rho, $theta) = _emake($_[0]);
    } elsif (@@_ == 2) {
	($rho, $theta) = @@_;
    }
    if (defined $rho && defined $theta) {
	if ($rho < 0) {
	    $rho   = -$rho;
	    $theta = ($theta <= 0) ? $theta + pi() : $theta - pi();
	}
    }
    if (defined $rho) {
	_cannot_make("rho",   $rho)   unless $rho   =~ /^$gre$/;
    }
    $theta ||= 0;
    _cannot_make("theta", $theta) unless $theta =~ /^$gre$/;
    $self->_set_polar([$rho, $theta]);
    $self->display_format('polar');

    return $self;
}

sub new { &make }		# For backward compatibility only.

#
# cplx
#
# Creates a complex number from a (re, im) tuple.
# This avoids the burden of writing Math::Complex->make(re, im).
#
sub cplx {
	return __PACKAGE__->make(@@_);
}

#
# cplxe
#
# Creates a complex number from a (rho, theta) tuple.
# This avoids the burden of writing Math::Complex->emake(rho, theta).
#
sub cplxe {
	return __PACKAGE__->emake(@@_);
}

#
# pi
#
# The number defined as pi = 180 degrees
#
sub pi () { 4 * CORE::atan2(1, 1) }

#
# pi2
#
# The full circle
#
sub pi2 () { 2 * pi }

#
# pi4
#
# The full circle twice.
#
sub pi4 () { 4 * pi }

#
# pip2
#
# The quarter circle
#
sub pip2 () { pi / 2 }

#
# pip4
#
# The eighth circle.
#
sub pip4 () { pi / 4 }

#
# _uplog10
#
# Used in log10().
#
sub _uplog10 () { 1 / CORE::log(10) }

#
# i
#
# The number defined as i*i = -1;
#
sub i () {
        return $i if ($i);
	$i = bless {};
	$i->{'cartesian'} = [0, 1];
	$i->{'polar'}     = [1, pip2];
	$i->{c_dirty} = 0;
	$i->{p_dirty} = 0;
	return $i;
}

#
# _ip2
#
# Half of i.
#
sub _ip2 () { i / 2 }

#
# Attribute access/set routines
#

sub _cartesian {$_[0]->{c_dirty} ?
		   $_[0]->_update_cartesian : $_[0]->{'cartesian'}}
sub _polar     {$_[0]->{p_dirty} ?
		   $_[0]->_update_polar : $_[0]->{'polar'}}

sub _set_cartesian { $_[0]->{p_dirty}++; $_[0]->{c_dirty} = 0;
		     $_[0]->{'cartesian'} = $_[1] }
sub _set_polar     { $_[0]->{c_dirty}++; $_[0]->{p_dirty} = 0;
		     $_[0]->{'polar'} = $_[1] }

#
# ->_update_cartesian
#
# Recompute and return the cartesian form, given accurate polar form.
#
sub _update_cartesian {
	my $self = shift;
	my ($r, $t) = @@{$self->{'polar'}};
	$self->{c_dirty} = 0;
	return $self->{'cartesian'} = [$r * CORE::cos($t), $r * CORE::sin($t)];
}

#
#
# ->_update_polar
#
# Recompute and return the polar form, given accurate cartesian form.
#
sub _update_polar {
	my $self = shift;
	my ($x, $y) = @@{$self->{'cartesian'}};
	$self->{p_dirty} = 0;
	return $self->{'polar'} = [0, 0] if $x == 0 && $y == 0;
	return $self->{'polar'} = [CORE::sqrt($x*$x + $y*$y),
				   CORE::atan2($y, $x)];
}

#
# (_plus)
#
# Computes z1+z2.
#
sub _plus {
	my ($z1, $z2, $regular) = @@_;
	my ($re1, $im1) = @@{$z1->_cartesian};
	$z2 = cplx($z2) unless ref $z2;
	my ($re2, $im2) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
	unless (defined $regular) {
		$z1->_set_cartesian([$re1 + $re2, $im1 + $im2]);
		return $z1;
	}
	return (ref $z1)->make($re1 + $re2, $im1 + $im2);
}

#
# (_minus)
#
# Computes z1-z2.
#
sub _minus {
	my ($z1, $z2, $inverted) = @@_;
	my ($re1, $im1) = @@{$z1->_cartesian};
	$z2 = cplx($z2) unless ref $z2;
	my ($re2, $im2) = @@{$z2->_cartesian};
	unless (defined $inverted) {
		$z1->_set_cartesian([$re1 - $re2, $im1 - $im2]);
		return $z1;
	}
	return $inverted ?
		(ref $z1)->make($re2 - $re1, $im2 - $im1) :
		(ref $z1)->make($re1 - $re2, $im1 - $im2);

}

#
# (_multiply)
#
# Computes z1*z2.
#
sub _multiply {
        my ($z1, $z2, $regular) = @@_;
	if ($z1->{p_dirty} == 0 and ref $z2 and $z2->{p_dirty} == 0) {
	    # if both polar better use polar to avoid rounding errors
	    my ($r1, $t1) = @@{$z1->_polar};
	    my ($r2, $t2) = @@{$z2->_polar};
	    my $t = $t1 + $t2;
	    if    ($t >   pi()) { $t -= pi2 }
	    elsif ($t <= -pi()) { $t += pi2 }
	    unless (defined $regular) {
		$z1->_set_polar([$r1 * $r2, $t]);
		return $z1;
	    }
	    return (ref $z1)->emake($r1 * $r2, $t);
	} else {
	    my ($x1, $y1) = @@{$z1->_cartesian};
	    if (ref $z2) {
		my ($x2, $y2) = @@{$z2->_cartesian};
		return (ref $z1)->make($x1*$x2-$y1*$y2, $x1*$y2+$y1*$x2);
	    } else {
		return (ref $z1)->make($x1*$z2, $y1*$z2);
	    }
	}
}

#
# _divbyzero
#
# Die on division by zero.
#
sub _divbyzero {
    my $mess = "$_[0]: Division by zero.\n";

    if (defined $_[1]) {
	$mess .= "(Because in the definition of $_[0], the divisor ";
	$mess .= "$_[1] " unless ("$_[1]" eq '0');
	$mess .= "is 0)\n";
    }

    my @@up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# (_divide)
#
# Computes z1/z2.
#
sub _divide {
	my ($z1, $z2, $inverted) = @@_;
	if ($z1->{p_dirty} == 0 and ref $z2 and $z2->{p_dirty} == 0) {
	    # if both polar better use polar to avoid rounding errors
	    my ($r1, $t1) = @@{$z1->_polar};
	    my ($r2, $t2) = @@{$z2->_polar};
	    my $t;
	    if ($inverted) {
		_divbyzero "$z2/0" if ($r1 == 0);
		$t = $t2 - $t1;
		if    ($t >   pi()) { $t -= pi2 }
		elsif ($t <= -pi()) { $t += pi2 }
		return (ref $z1)->emake($r2 / $r1, $t);
	    } else {
		_divbyzero "$z1/0" if ($r2 == 0);
		$t = $t1 - $t2;
		if    ($t >   pi()) { $t -= pi2 }
		elsif ($t <= -pi()) { $t += pi2 }
		return (ref $z1)->emake($r1 / $r2, $t);
	    }
	} else {
	    my ($d, $x2, $y2);
	    if ($inverted) {
		($x2, $y2) = @@{$z1->_cartesian};
		$d = $x2*$x2 + $y2*$y2;
		_divbyzero "$z2/0" if $d == 0;
		return (ref $z1)->make(($x2*$z2)/$d, -($y2*$z2)/$d);
	    } else {
		my ($x1, $y1) = @@{$z1->_cartesian};
		if (ref $z2) {
		    ($x2, $y2) = @@{$z2->_cartesian};
		    $d = $x2*$x2 + $y2*$y2;
		    _divbyzero "$z1/0" if $d == 0;
		    my $u = ($x1*$x2 + $y1*$y2)/$d;
		    my $v = ($y1*$x2 - $x1*$y2)/$d;
		    return (ref $z1)->make($u, $v);
		} else {
		    _divbyzero "$z1/0" if $z2 == 0;
		    return (ref $z1)->make($x1/$z2, $y1/$z2);
		}
	    }
	}
}

#
# (_power)
#
# Computes z1**z2 = exp(z2 * log z1)).
#
sub _power {
	my ($z1, $z2, $inverted) = @@_;
	if ($inverted) {
	    return 1 if $z1 == 0 || $z2 == 1;
	    return 0 if $z2 == 0 && Re($z1) > 0;
	} else {
	    return 1 if $z2 == 0 || $z1 == 1;
	    return 0 if $z1 == 0 && Re($z2) > 0;
	}
	my $w = $inverted ? &exp($z1 * &log($z2))
	                  : &exp($z2 * &log($z1));
	# If both arguments cartesian, return cartesian, else polar.
	return $z1->{c_dirty} == 0 &&
	       (not ref $z2 or $z2->{c_dirty} == 0) ?
	       cplx(@@{$w->_cartesian}) : $w;
}

#
# (_spaceship)
#
# Computes z1 <=> z2.
# Sorts on the real part first, then on the imaginary part. Thus 2-4i < 3+8i.
#
sub _spaceship {
	my ($z1, $z2, $inverted) = @@_;
	my ($re1, $im1) = ref $z1 ? @@{$z1->_cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
	my $sgn = $inverted ? -1 : 1;
	return $sgn * ($re1 <=> $re2) if $re1 != $re2;
	return $sgn * ($im1 <=> $im2);
}

#
# (_numeq)
#
# Computes z1 == z2.
#
# (Required in addition to _spaceship() because of NaNs.)
sub _numeq {
	my ($z1, $z2, $inverted) = @@_;
	my ($re1, $im1) = ref $z1 ? @@{$z1->_cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
	return $re1 == $re2 && $im1 == $im2 ? 1 : 0;
}

#
# (_negate)
#
# Computes -z.
#
sub _negate {
	my ($z) = @@_;
	if ($z->{c_dirty}) {
		my ($r, $t) = @@{$z->_polar};
		$t = ($t <= 0) ? $t + pi : $t - pi;
		return (ref $z)->emake($r, $t);
	}
	my ($re, $im) = @@{$z->_cartesian};
	return (ref $z)->make(-$re, -$im);
}

#
# (_conjugate)
#
# Compute complex's _conjugate.
#
sub _conjugate {
	my ($z) = @@_;
	if ($z->{c_dirty}) {
		my ($r, $t) = @@{$z->_polar};
		return (ref $z)->emake($r, -$t);
	}
	my ($re, $im) = @@{$z->_cartesian};
	return (ref $z)->make($re, -$im);
}

#
# (abs)
#
# Compute or set complex's norm (rho).
#
sub abs {
	my ($z, $rho) = @@_ ? @@_ : $_;
	unless (ref $z) {
	    if (@@_ == 2) {
		$_[0] = $_[1];
	    } else {
		return CORE::abs($z);
	    }
	}
	if (defined $rho) {
	    $z->{'polar'} = [ $rho, ${$z->_polar}[1] ];
	    $z->{p_dirty} = 0;
	    $z->{c_dirty} = 1;
	    return $rho;
	} else {
	    return ${$z->_polar}[0];
	}
}

sub _theta {
    my $theta = $_[0];

    if    ($$theta >   pi()) { $$theta -= pi2 }
    elsif ($$theta <= -pi()) { $$theta += pi2 }
}

#
# arg
#
# Compute or set complex's argument (theta).
#
sub arg {
	my ($z, $theta) = @@_;
	return $z unless ref $z;
	if (defined $theta) {
	    _theta(\$theta);
	    $z->{'polar'} = [ ${$z->_polar}[0], $theta ];
	    $z->{p_dirty} = 0;
	    $z->{c_dirty} = 1;
	} else {
	    $theta = ${$z->_polar}[1];
	    _theta(\$theta);
	}
	return $theta;
}

#
# (sqrt)
#
# Compute sqrt(z).
#
# It is quite tempting to use wantarray here so that in list context
# sqrt() would return the two solutions.  This, however, would
# break things like
#
#	print "sqrt(z) = ", sqrt($z), "\n";
#
# The two values would be printed side by side without no intervening
# whitespace, quite confusing.
# Therefore if you want the two solutions use the root().
#
sub sqrt {
	my ($z) = @@_ ? $_[0] : $_;
	my ($re, $im) = ref $z ? @@{$z->_cartesian} : ($z, 0);
	return $re < 0 ? cplx(0, CORE::sqrt(-$re)) : CORE::sqrt($re)
	    if $im == 0;
	my ($r, $t) = @@{$z->_polar};
	return (ref $z)->emake(CORE::sqrt($r), $t/2);
}

#
# cbrt
#
# Compute cbrt(z) (cubic root).
#
# Why are we not returning three values?  The same answer as for sqrt().
#
sub cbrt {
	my ($z) = @@_;
	return $z < 0 ?
	    -CORE::exp(CORE::log(-$z)/3) :
		($z > 0 ? CORE::exp(CORE::log($z)/3): 0)
	    unless ref $z;
	my ($r, $t) = @@{$z->_polar};
	return 0 if $r == 0;
	return (ref $z)->emake(CORE::exp(CORE::log($r)/3), $t/3);
}

#
# _rootbad
#
# Die on bad root.
#
sub _rootbad {
    my $mess = "Root '$_[0]' illegal, root rank must be positive integer.\n";

    my @@up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# root
#
# Computes all nth root for z, returning an array whose size is n.
# `n' must be a positive integer.
#
# The roots are given by (for k = 0..n-1):
#
# z^(1/n) = r^(1/n) (cos ((t+2 k pi)/n) + i sin ((t+2 k pi)/n))
#
sub root {
	my ($z, $n, $k) = @@_;
	_rootbad($n) if ($n < 1 or int($n) != $n);
	my ($r, $t) = ref $z ?
	    @@{$z->_polar} : (CORE::abs($z), $z >= 0 ? 0 : pi);
	my $theta_inc = pi2 / $n;
	my $rho = $r ** (1/$n);
	my $cartesian = ref $z && $z->{c_dirty} == 0;
	if (@@_ == 2) {
	    my @@root;
	    for (my $i = 0, my $theta = $t / $n;
		 $i < $n;
		 $i++, $theta += $theta_inc) {
		my $w = cplxe($rho, $theta);
		# Yes, $cartesian is loop invariant.
		push @@root, $cartesian ? cplx(@@{$w->_cartesian}) : $w;
	    }
	    return @@root;
	} elsif (@@_ == 3) {
	    my $w = cplxe($rho, $t / $n + $k * $theta_inc);
	    return $cartesian ? cplx(@@{$w->_cartesian}) : $w;
	}
}

#
# Re
#
# Return or set Re(z).
#
sub Re {
	my ($z, $Re) = @@_;
	return $z unless ref $z;
	if (defined $Re) {
	    $z->{'cartesian'} = [ $Re, ${$z->_cartesian}[1] ];
	    $z->{c_dirty} = 0;
	    $z->{p_dirty} = 1;
	} else {
	    return ${$z->_cartesian}[0];
	}
}

#
# Im
#
# Return or set Im(z).
#
sub Im {
	my ($z, $Im) = @@_;
	return 0 unless ref $z;
	if (defined $Im) {
	    $z->{'cartesian'} = [ ${$z->_cartesian}[0], $Im ];
	    $z->{c_dirty} = 0;
	    $z->{p_dirty} = 1;
	} else {
	    return ${$z->_cartesian}[1];
	}
}

#
# rho
#
# Return or set rho(w).
#
sub rho {
    Math::Complex::abs(@@_);
}

#
# theta
#
# Return or set theta(w).
#
sub theta {
    Math::Complex::arg(@@_);
}

#
# (exp)
#
# Computes exp(z).
#
sub exp {
    my ($z) = @@_ ? @@_ : $_;
    return CORE::exp($z) unless ref $z;
    my ($x, $y) = @@{$z->_cartesian};
    return (ref $z)->emake(CORE::exp($x), $y);
}

#
# _logofzero
#
# Die on logarithm of zero.
#
sub _logofzero {
    my $mess = "$_[0]: Logarithm of zero.\n";

    if (defined $_[1]) {
	$mess .= "(Because in the definition of $_[0], the argument ";
	$mess .= "$_[1] " unless ($_[1] eq '0');
	$mess .= "is 0)\n";
    }

    my @@up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# (log)
#
# Compute log(z).
#
sub log {
	my ($z) = @@_ ? @@_ : $_;
	unless (ref $z) {
	    _logofzero("log") if $z == 0;
	    return $z > 0 ? CORE::log($z) : cplx(CORE::log(-$z), pi);
	}
	my ($r, $t) = @@{$z->_polar};
	_logofzero("log") if $r == 0;
	if    ($t >   pi()) { $t -= pi2 }
	elsif ($t <= -pi()) { $t += pi2 }
	return (ref $z)->make(CORE::log($r), $t);
}

#
# ln
#
# Alias for log().
#
sub ln { Math::Complex::log(@@_) }

#
# log10
#
# Compute log10(z).
#

sub log10 {
	return Math::Complex::log($_[0]) * _uplog10;
}

#
# logn
#
# Compute logn(z,n) = log(z) / log(n)
#
sub logn {
	my ($z, $n) = @@_;
	$z = cplx($z, 0) unless ref $z;
	my $logn = $LOGN{$n};
	$logn = $LOGN{$n} = CORE::log($n) unless defined $logn;	# Cache log(n)
	return &log($z) / $logn;
}

#
# (cos)
#
# Compute cos(z) = (exp(iz) + exp(-iz))/2.
#
sub cos {
	my ($z) = @@_ ? @@_ : $_;
	return CORE::cos($z) unless ref $z;
	my ($x, $y) = @@{$z->_cartesian};
	my $ey = CORE::exp($y);
	my $sx = CORE::sin($x);
	my $cx = CORE::cos($x);
	my $ey_1 = $ey ? 1 / $ey : Inf();
	return (ref $z)->make($cx * ($ey + $ey_1)/2,
			      $sx * ($ey_1 - $ey)/2);
}

#
# (sin)
#
# Compute sin(z) = (exp(iz) - exp(-iz))/2.
#
sub sin {
	my ($z) = @@_ ? @@_ : $_;
	return CORE::sin($z) unless ref $z;
	my ($x, $y) = @@{$z->_cartesian};
	my $ey = CORE::exp($y);
	my $sx = CORE::sin($x);
	my $cx = CORE::cos($x);
	my $ey_1 = $ey ? 1 / $ey : Inf();
	return (ref $z)->make($sx * ($ey + $ey_1)/2,
			      $cx * ($ey - $ey_1)/2);
}

#
# tan
#
# Compute tan(z) = sin(z) / cos(z).
#
sub tan {
	my ($z) = @@_;
	my $cz = &cos($z);
	_divbyzero "tan($z)", "cos($z)" if $cz == 0;
	return &sin($z) / $cz;
}

#
# sec
#
# Computes the secant sec(z) = 1 / cos(z).
#
sub sec {
	my ($z) = @@_;
	my $cz = &cos($z);
	_divbyzero "sec($z)", "cos($z)" if ($cz == 0);
	return 1 / $cz;
}

#
# csc
#
# Computes the cosecant csc(z) = 1 / sin(z).
#
sub csc {
	my ($z) = @@_;
	my $sz = &sin($z);
	_divbyzero "csc($z)", "sin($z)" if ($sz == 0);
	return 1 / $sz;
}

#
# cosec
#
# Alias for csc().
#
sub cosec { Math::Complex::csc(@@_) }

#
# cot
#
# Computes cot(z) = cos(z) / sin(z).
#
sub cot {
	my ($z) = @@_;
	my $sz = &sin($z);
	_divbyzero "cot($z)", "sin($z)" if ($sz == 0);
	return &cos($z) / $sz;
}

#
# cotan
#
# Alias for cot().
#
sub cotan { Math::Complex::cot(@@_) }

#
# acos
#
# Computes the arc cosine acos(z) = -i log(z + sqrt(z*z-1)).
#
sub acos {
	my $z = $_[0];
	return CORE::atan2(CORE::sqrt(1-$z*$z), $z)
	    if (! ref $z) && CORE::abs($z) <= 1;
	$z = cplx($z, 0) unless ref $z;
	my ($x, $y) = @@{$z->_cartesian};
	return 0 if $x == 1 && $y == 0;
	my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
	my $alpha = ($t1 + $t2)/2;
	my $beta  = ($t1 - $t2)/2;
	$alpha = 1 if $alpha < 1;
	if    ($beta >  1) { $beta =  1 }
	elsif ($beta < -1) { $beta = -1 }
	my $u = CORE::atan2(CORE::sqrt(1-$beta*$beta), $beta);
	my $v = CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
	$v = -$v if $y > 0 || ($y == 0 && $x < -1);
	return (ref $z)->make($u, $v);
}

#
# asin
#
# Computes the arc sine asin(z) = -i log(iz + sqrt(1-z*z)).
#
sub asin {
	my $z = $_[0];
	return CORE::atan2($z, CORE::sqrt(1-$z*$z))
	    if (! ref $z) && CORE::abs($z) <= 1;
	$z = cplx($z, 0) unless ref $z;
	my ($x, $y) = @@{$z->_cartesian};
	return 0 if $x == 0 && $y == 0;
	my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
	my $alpha = ($t1 + $t2)/2;
	my $beta  = ($t1 - $t2)/2;
	$alpha = 1 if $alpha < 1;
	if    ($beta >  1) { $beta =  1 }
	elsif ($beta < -1) { $beta = -1 }
	my $u =  CORE::atan2($beta, CORE::sqrt(1-$beta*$beta));
	my $v = -CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
	$v = -$v if $y > 0 || ($y == 0 && $x < -1);
	return (ref $z)->make($u, $v);
}

#
# atan
#
# Computes the arc tangent atan(z) = i/2 log((i+z) / (i-z)).
#
sub atan {
	my ($z) = @@_;
	return CORE::atan2($z, 1) unless ref $z;
	my ($x, $y) = ref $z ? @@{$z->_cartesian} : ($z, 0);
	return 0 if $x == 0 && $y == 0;
	_divbyzero "atan(i)"  if ( $z == i);
	_logofzero "atan(-i)" if (-$z == i); # -i is a bad file test...
	my $log = &log((i + $z) / (i - $z));
	return _ip2 * $log;
}

#
# asec
#
# Computes the arc secant asec(z) = acos(1 / z).
#
sub asec {
	my ($z) = @@_;
	_divbyzero "asec($z)", $z if ($z == 0);
	return acos(1 / $z);
}

#
# acsc
#
# Computes the arc cosecant acsc(z) = asin(1 / z).
#
sub acsc {
	my ($z) = @@_;
	_divbyzero "acsc($z)", $z if ($z == 0);
	return asin(1 / $z);
}

#
# acosec
#
# Alias for acsc().
#
sub acosec { Math::Complex::acsc(@@_) }

#
# acot
#
# Computes the arc cotangent acot(z) = atan(1 / z)
#
sub acot {
	my ($z) = @@_;
	_divbyzero "acot(0)"  if $z == 0;
	return ($z >= 0) ? CORE::atan2(1, $z) : CORE::atan2(-1, -$z)
	    unless ref $z;
	_divbyzero "acot(i)"  if ($z - i == 0);
	_logofzero "acot(-i)" if ($z + i == 0);
	return atan(1 / $z);
}

#
# acotan
#
# Alias for acot().
#
sub acotan { Math::Complex::acot(@@_) }

#
# cosh
#
# Computes the hyperbolic cosine cosh(z) = (exp(z) + exp(-z))/2.
#
sub cosh {
	my ($z) = @@_;
	my $ex;
	unless (ref $z) {
	    $ex = CORE::exp($z);
            return $ex ? ($ex == $ExpInf ? Inf() : ($ex + 1/$ex)/2) : Inf();
	}
	my ($x, $y) = @@{$z->_cartesian};
	$ex = CORE::exp($x);
	my $ex_1 = $ex ? 1 / $ex : Inf();
	return (ref $z)->make(CORE::cos($y) * ($ex + $ex_1)/2,
			      CORE::sin($y) * ($ex - $ex_1)/2);
}

#
# sinh
#
# Computes the hyperbolic sine sinh(z) = (exp(z) - exp(-z))/2.
#
sub sinh {
	my ($z) = @@_;
	my $ex;
	unless (ref $z) {
	    return 0 if $z == 0;
	    $ex = CORE::exp($z);
            return $ex ? ($ex == $ExpInf ? Inf() : ($ex - 1/$ex)/2) : -Inf();
	}
	my ($x, $y) = @@{$z->_cartesian};
	my $cy = CORE::cos($y);
	my $sy = CORE::sin($y);
	$ex = CORE::exp($x);
	my $ex_1 = $ex ? 1 / $ex : Inf();
	return (ref $z)->make(CORE::cos($y) * ($ex - $ex_1)/2,
			      CORE::sin($y) * ($ex + $ex_1)/2);
}

#
# tanh
#
# Computes the hyperbolic tangent tanh(z) = sinh(z) / cosh(z).
#
sub tanh {
	my ($z) = @@_;
	my $cz = cosh($z);
	_divbyzero "tanh($z)", "cosh($z)" if ($cz == 0);
	my $sz = sinh($z);
	return  1 if $cz ==  $sz;
	return -1 if $cz == -$sz;
	return $sz / $cz;
}

#
# sech
#
# Computes the hyperbolic secant sech(z) = 1 / cosh(z).
#
sub sech {
	my ($z) = @@_;
	my $cz = cosh($z);
	_divbyzero "sech($z)", "cosh($z)" if ($cz == 0);
	return 1 / $cz;
}

#
# csch
#
# Computes the hyperbolic cosecant csch(z) = 1 / sinh(z).
#
sub csch {
	my ($z) = @@_;
	my $sz = sinh($z);
	_divbyzero "csch($z)", "sinh($z)" if ($sz == 0);
	return 1 / $sz;
}

#
# cosech
#
# Alias for csch().
#
sub cosech { Math::Complex::csch(@@_) }

#
# coth
#
# Computes the hyperbolic cotangent coth(z) = cosh(z) / sinh(z).
#
sub coth {
	my ($z) = @@_;
	my $sz = sinh($z);
	_divbyzero "coth($z)", "sinh($z)" if $sz == 0;
	my $cz = cosh($z);
	return  1 if $cz ==  $sz;
	return -1 if $cz == -$sz;
	return $cz / $sz;
}

#
# cotanh
#
# Alias for coth().
#
sub cotanh { Math::Complex::coth(@@_) }

#
# acosh
#
# Computes the area/inverse hyperbolic cosine acosh(z) = log(z + sqrt(z*z-1)).
#
sub acosh {
	my ($z) = @@_;
	unless (ref $z) {
	    $z = cplx($z, 0);
	}
	my ($re, $im) = @@{$z->_cartesian};
	if ($im == 0) {
	    return CORE::log($re + CORE::sqrt($re*$re - 1))
		if $re >= 1;
	    return cplx(0, CORE::atan2(CORE::sqrt(1 - $re*$re), $re))
		if CORE::abs($re) < 1;
	}
	my $t = &sqrt($z * $z - 1) + $z;
	# Try Taylor if looking bad (this usually means that
	# $z was large negative, therefore the sqrt is really
	# close to abs(z), summing that with z...)
	$t = 1/(2 * $z) - 1/(8 * $z**3) + 1/(16 * $z**5) - 5/(128 * $z**7)
	    if $t == 0;
	my $u = &log($t);
	$u->Im(-$u->Im) if $re < 0 && $im == 0;
	return $re < 0 ? -$u : $u;
}

#
# asinh
#
# Computes the area/inverse hyperbolic sine asinh(z) = log(z + sqrt(z*z+1))
#
sub asinh {
	my ($z) = @@_;
	unless (ref $z) {
	    my $t = $z + CORE::sqrt($z*$z + 1);
	    return CORE::log($t) if $t;
	}
	my $t = &sqrt($z * $z + 1) + $z;
	# Try Taylor if looking bad (this usually means that
	# $z was large negative, therefore the sqrt is really
	# close to abs(z), summing that with z...)
	$t = 1/(2 * $z) - 1/(8 * $z**3) + 1/(16 * $z**5) - 5/(128 * $z**7)
	    if $t == 0;
	return &log($t);
}

#
# atanh
#
# Computes the area/inverse hyperbolic tangent atanh(z) = 1/2 log((1+z) / (1-z)).
#
sub atanh {
	my ($z) = @@_;
	unless (ref $z) {
	    return CORE::log((1 + $z)/(1 - $z))/2 if CORE::abs($z) < 1;
	    $z = cplx($z, 0);
	}
	_divbyzero 'atanh(1)',  "1 - $z" if (1 - $z == 0);
	_logofzero 'atanh(-1)'           if (1 + $z == 0);
	return 0.5 * &log((1 + $z) / (1 - $z));
}

#
# asech
#
# Computes the area/inverse hyperbolic secant asech(z) = acosh(1 / z).
#
sub asech {
	my ($z) = @@_;
	_divbyzero 'asech(0)', "$z" if ($z == 0);
	return acosh(1 / $z);
}

#
# acsch
#
# Computes the area/inverse hyperbolic cosecant acsch(z) = asinh(1 / z).
#
sub acsch {
	my ($z) = @@_;
	_divbyzero 'acsch(0)', $z if ($z == 0);
	return asinh(1 / $z);
}

#
# acosech
#
# Alias for acosh().
#
sub acosech { Math::Complex::acsch(@@_) }

#
# acoth
#
# Computes the area/inverse hyperbolic cotangent acoth(z) = 1/2 log((1+z) / (z-1)).
#
sub acoth {
	my ($z) = @@_;
	_divbyzero 'acoth(0)'            if ($z == 0);
	unless (ref $z) {
	    return CORE::log(($z + 1)/($z - 1))/2 if CORE::abs($z) > 1;
	    $z = cplx($z, 0);
	}
	_divbyzero 'acoth(1)',  "$z - 1" if ($z - 1 == 0);
	_logofzero 'acoth(-1)', "1 + $z" if (1 + $z == 0);
	return &log((1 + $z) / ($z - 1)) / 2;
}

#
# acotanh
#
# Alias for acot().
#
sub acotanh { Math::Complex::acoth(@@_) }

#
# (atan2)
#
# Compute atan(z1/z2), minding the right quadrant.
#
sub atan2 {
	my ($z1, $z2, $inverted) = @@_;
	my ($re1, $im1, $re2, $im2);
	if ($inverted) {
	    ($re1, $im1) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
	    ($re2, $im2) = ref $z1 ? @@{$z1->_cartesian} : ($z1, 0);
	} else {
	    ($re1, $im1) = ref $z1 ? @@{$z1->_cartesian} : ($z1, 0);
	    ($re2, $im2) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
	}
	if ($im1 || $im2) {
	    # In MATLAB the imaginary parts are ignored.
	    # warn "atan2: Imaginary parts ignored";
	    # http://documents.wolfram.com/mathematica/functions/ArcTan
	    # NOTE: Mathematica ArcTan[x,y] while atan2(y,x)
	    my $s = $z1 * $z1 + $z2 * $z2;
	    _divbyzero("atan2") if $s == 0;
	    my $i = &i;
	    my $r = $z2 + $z1 * $i;
	    return -$i * &log($r / &sqrt( $s ));
	}
	return CORE::atan2($re1, $re2);
}

#
# display_format
# ->display_format
#
# Set (get if no argument) the display format for all complex numbers that
# don't happen to have overridden it via ->display_format
#
# When called as an object method, this actually sets the display format for
# the current object.
#
# Valid object formats are 'c' and 'p' for cartesian and polar. The first
# letter is used actually, so the type can be fully spelled out for clarity.
#
sub display_format {
	my $self  = shift;
	my %display_format = %DISPLAY_FORMAT;

	if (ref $self) {			# Called as an object method
	    if (exists $self->{display_format}) {
		my %obj = %{$self->{display_format}};
		@@display_format{keys %obj} = values %obj;
	    }
	}
	if (@@_ == 1) {
	    $display_format{style} = shift;
	} else {
	    my %new = @@_;
	    @@display_format{keys %new} = values %new;
	}

	if (ref $self) { # Called as an object method
	    $self->{display_format} = { %display_format };
	    return
		wantarray ?
		    %{$self->{display_format}} :
		    $self->{display_format}->{style};
	}

        # Called as a class method
	%DISPLAY_FORMAT = %display_format;
	return
	    wantarray ?
		%DISPLAY_FORMAT :
		    $DISPLAY_FORMAT{style};
}

#
# (_stringify)
#
# Show nicely formatted complex number under its cartesian or polar form,
# depending on the current display format:
#
# . If a specific display format has been recorded for this object, use it.
# . Otherwise, use the generic current default for all complex numbers,
#   which is a package global variable.
#
sub _stringify {
	my ($z) = shift;

	my $style = $z->display_format;

	$style = $DISPLAY_FORMAT{style} unless defined $style;

	return $z->_stringify_polar if $style =~ /^p/i;
	return $z->_stringify_cartesian;
}

#
# ->_stringify_cartesian
#
# Stringify as a cartesian representation 'a+bi'.
#
sub _stringify_cartesian {
	my $z  = shift;
	my ($x, $y) = @@{$z->_cartesian};
	my ($re, $im);

	my %format = $z->display_format;
	my $format = $format{format};

	if ($x) {
	    if ($x =~ /^NaN[QS]?$/i) {
		$re = $x;
	    } else {
		if ($x =~ /^-?\Q$Inf\E$/oi) {
		    $re = $x;
		} else {
		    $re = defined $format ? sprintf($format, $x) : $x;
		}
	    }
	} else {
	    undef $re;
	}

	if ($y) {
	    if ($y =~ /^(NaN[QS]?)$/i) {
		$im = $y;
	    } else {
		if ($y =~ /^-?\Q$Inf\E$/oi) {
		    $im = $y;
		} else {
		    $im =
			defined $format ?
			    sprintf($format, $y) :
			    ($y == 1 ? "" : ($y == -1 ? "-" : $y));
		}
	    }
	    $im .= "i";
	} else {
	    undef $im;
	}

	my $str = $re;

	if (defined $im) {
	    if ($y < 0) {
		$str .= $im;
	    } elsif ($y > 0 || $im =~ /^NaN[QS]?i$/i)  {
		$str .= "+" if defined $re;
		$str .= $im;
	    }
	} elsif (!defined $re) {
	    $str = "0";
	}

	return $str;
}


#
# ->_stringify_polar
#
# Stringify as a polar representation '[r,t]'.
#
sub _stringify_polar {
	my $z  = shift;
	my ($r, $t) = @@{$z->_polar};
	my $theta;

	my %format = $z->display_format;
	my $format = $format{format};

	if ($t =~ /^NaN[QS]?$/i || $t =~ /^-?\Q$Inf\E$/oi) {
	    $theta = $t; 
	} elsif ($t == pi) {
	    $theta = "pi";
	} elsif ($r == 0 || $t == 0) {
	    $theta = defined $format ? sprintf($format, $t) : $t;
	}

	return "[$r,$theta]" if defined $theta;

	#
	# Try to identify pi/n and friends.
	#

	$t -= int(CORE::abs($t) / pi2) * pi2;

	if ($format{polar_pretty_print} && $t) {
	    my ($a, $b);
	    for $a (2..9) {
		$b = $t * $a / pi;
		if ($b =~ /^-?\d+$/) {
		    $b = $b < 0 ? "-" : "" if CORE::abs($b) == 1;
		    $theta = "${b}pi/$a";
		    last;
		}
	    }
	}

        if (defined $format) {
	    $r     = sprintf($format, $r);
	    $theta = sprintf($format, $theta) unless defined $theta;
	} else {
	    $theta = $t unless defined $theta;
	}

	return "[$r,$theta]";
}

sub Inf {
    return $Inf;
}

1;
__END__

=pod

=head1 NAME

Math::Complex - complex numbers and associated mathematical functions

=head1 SYNOPSIS

	use Math::Complex;

	$z = Math::Complex->make(5, 6);
	$t = 4 - 3*i + $z;
	$j = cplxe(1, 2*pi/3);

=head1 DESCRIPTION

This package lets you create and manipulate complex numbers. By default,
I<Perl> limits itself to real numbers, but an extra C<use> statement brings
full complex support, along with a full set of mathematical functions
typically associated with and/or extended to complex numbers.

If you wonder what complex numbers are, they were invented to be able to solve
the following equation:

	x*x = -1

and by definition, the solution is noted I<i> (engineers use I<j> instead since
I<i> usually denotes an intensity, but the name does not matter). The number
I<i> is a pure I<imaginary> number.

The arithmetics with pure imaginary numbers works just like you would expect
it with real numbers... you just have to remember that

	i*i = -1

so you have:

	5i + 7i = i * (5 + 7) = 12i
	4i - 3i = i * (4 - 3) = i
	4i * 2i = -8
	6i / 2i = 3
	1 / i = -i

Complex numbers are numbers that have both a real part and an imaginary
part, and are usually noted:

	a + bi

where C<a> is the I<real> part and C<b> is the I<imaginary> part. The
arithmetic with complex numbers is straightforward. You have to
keep track of the real and the imaginary parts, but otherwise the
rules used for real numbers just apply:

	(4 + 3i) + (5 - 2i) = (4 + 5) + i(3 - 2) = 9 + i
	(2 + i) * (4 - i) = 2*4 + 4i -2i -i*i = 8 + 2i + 1 = 9 + 2i

A graphical representation of complex numbers is possible in a plane
(also called the I<complex plane>, but it's really a 2D plane).
The number

	z = a + bi

is the point whose coordinates are (a, b). Actually, it would
be the vector originating from (0, 0) to (a, b). It follows that the addition
of two complex numbers is a vectorial addition.

Since there is a bijection between a point in the 2D plane and a complex
number (i.e. the mapping is unique and reciprocal), a complex number
can also be uniquely identified with polar coordinates:

	[rho, theta]

where C<rho> is the distance to the origin, and C<theta> the angle between
the vector and the I<x> axis. There is a notation for this using the
exponential form, which is:

	rho * exp(i * theta)

where I<i> is the famous imaginary number introduced above. Conversion
between this form and the cartesian form C<a + bi> is immediate:

	a = rho * cos(theta)
	b = rho * sin(theta)

which is also expressed by this formula:

	z = rho * exp(i * theta) = rho * (cos theta + i * sin theta)

In other words, it's the projection of the vector onto the I<x> and I<y>
axes. Mathematicians call I<rho> the I<norm> or I<modulus> and I<theta>
the I<argument> of the complex number. The I<norm> of C<z> is
marked here as C<abs(z)>.

The polar notation (also known as the trigonometric representation) is
much more handy for performing multiplications and divisions of
complex numbers, whilst the cartesian notation is better suited for
additions and subtractions. Real numbers are on the I<x> axis, and
therefore I<y> or I<theta> is zero or I<pi>.

All the common operations that can be performed on a real number have
been defined to work on complex numbers as well, and are merely
I<extensions> of the operations defined on real numbers. This means
they keep their natural meaning when there is no imaginary part, provided
the number is within their definition set.

For instance, the C<sqrt> routine which computes the square root of
its argument is only defined for non-negative real numbers and yields a
non-negative real number (it is an application from B<R+> to B<R+>).
If we allow it to return a complex number, then it can be extended to
negative real numbers to become an application from B<R> to B<C> (the
set of complex numbers):

	sqrt(x) = x >= 0 ? sqrt(x) : sqrt(-x)*i

It can also be extended to be an application from B<C> to B<C>,
whilst its restriction to B<R> behaves as defined above by using
the following definition:

	sqrt(z = [r,t]) = sqrt(r) * exp(i * t/2)

Indeed, a negative real number can be noted C<[x,pi]> (the modulus
I<x> is always non-negative, so C<[x,pi]> is really C<-x>, a negative
number) and the above definition states that

	sqrt([x,pi]) = sqrt(x) * exp(i*pi/2) = [sqrt(x),pi/2] = sqrt(x)*i

which is exactly what we had defined for negative real numbers above.
The C<sqrt> returns only one of the solutions: if you want the both,
use the C<root> function.

All the common mathematical functions defined on real numbers that
are extended to complex numbers share that same property of working
I<as usual> when the imaginary part is zero (otherwise, it would not
be called an extension, would it?).

A I<new> operation possible on a complex number that is
the identity for real numbers is called the I<conjugate>, and is noted
with a horizontal bar above the number, or C<~z> here.

	 z = a + bi
	~z = a - bi

Simple... Now look:

	z * ~z = (a + bi) * (a - bi) = a*a + b*b

We saw that the norm of C<z> was noted C<abs(z)> and was defined as the
distance to the origin, also known as:

	rho = abs(z) = sqrt(a*a + b*b)

so

	z * ~z = abs(z) ** 2

If z is a pure real number (i.e. C<b == 0>), then the above yields:

	a * a = abs(a) ** 2

which is true (C<abs> has the regular meaning for real number, i.e. stands
for the absolute value). This example explains why the norm of C<z> is
noted C<abs(z)>: it extends the C<abs> function to complex numbers, yet
is the regular C<abs> we know when the complex number actually has no
imaginary part... This justifies I<a posteriori> our use of the C<abs>
notation for the norm.

=head1 OPERATIONS

Given the following notations:

	z1 = a + bi = r1 * exp(i * t1)
	z2 = c + di = r2 * exp(i * t2)
	z = <any complex or real number>

the following (overloaded) operations are supported on complex numbers:

	z1 + z2 = (a + c) + i(b + d)
	z1 - z2 = (a - c) + i(b - d)
	z1 * z2 = (r1 * r2) * exp(i * (t1 + t2))
	z1 / z2 = (r1 / r2) * exp(i * (t1 - t2))
	z1 ** z2 = exp(z2 * log z1)
	~z = a - bi
	abs(z) = r1 = sqrt(a*a + b*b)
	sqrt(z) = sqrt(r1) * exp(i * t/2)
	exp(z) = exp(a) * exp(i * b)
	log(z) = log(r1) + i*t
	sin(z) = 1/2i (exp(i * z1) - exp(-i * z))
	cos(z) = 1/2 (exp(i * z1) + exp(-i * z))
	atan2(y, x) = atan(y / x) # Minding the right quadrant, note the order.

The definition used for complex arguments of atan2() is

       -i log((x + iy)/sqrt(x*x+y*y))

Note that atan2(0, 0) is not well-defined.

The following extra operations are supported on both real and complex
numbers:

	Re(z) = a
	Im(z) = b
	arg(z) = t
	abs(z) = r

	cbrt(z) = z ** (1/3)
	log10(z) = log(z) / log(10)
	logn(z, n) = log(z) / log(n)

	tan(z) = sin(z) / cos(z)

	csc(z) = 1 / sin(z)
	sec(z) = 1 / cos(z)
	cot(z) = 1 / tan(z)

	asin(z) = -i * log(i*z + sqrt(1-z*z))
	acos(z) = -i * log(z + i*sqrt(1-z*z))
	atan(z) = i/2 * log((i+z) / (i-z))

	acsc(z) = asin(1 / z)
	asec(z) = acos(1 / z)
	acot(z) = atan(1 / z) = -i/2 * log((i+z) / (z-i))

	sinh(z) = 1/2 (exp(z) - exp(-z))
	cosh(z) = 1/2 (exp(z) + exp(-z))
	tanh(z) = sinh(z) / cosh(z) = (exp(z) - exp(-z)) / (exp(z) + exp(-z))

	csch(z) = 1 / sinh(z)
	sech(z) = 1 / cosh(z)
	coth(z) = 1 / tanh(z)

	asinh(z) = log(z + sqrt(z*z+1))
	acosh(z) = log(z + sqrt(z*z-1))
	atanh(z) = 1/2 * log((1+z) / (1-z))

	acsch(z) = asinh(1 / z)
	asech(z) = acosh(1 / z)
	acoth(z) = atanh(1 / z) = 1/2 * log((1+z) / (z-1))

I<arg>, I<abs>, I<log>, I<csc>, I<cot>, I<acsc>, I<acot>, I<csch>,
I<coth>, I<acosech>, I<acotanh>, have aliases I<rho>, I<theta>, I<ln>,
I<cosec>, I<cotan>, I<acosec>, I<acotan>, I<cosech>, I<cotanh>,
I<acosech>, I<acotanh>, respectively.  C<Re>, C<Im>, C<arg>, C<abs>,
C<rho>, and C<theta> can be used also as mutators.  The C<cbrt>
returns only one of the solutions: if you want all three, use the
C<root> function.

The I<root> function is available to compute all the I<n>
roots of some complex, where I<n> is a strictly positive integer.
There are exactly I<n> such roots, returned as a list. Getting the
number mathematicians call C<j> such that:

	1 + j + j*j = 0;

is a simple matter of writing:

	$j = ((root(1, 3))[1];

The I<k>th root for C<z = [r,t]> is given by:

	(root(z, n))[k] = r**(1/n) * exp(i * (t + 2*k*pi)/n)

You can return the I<k>th root directly by C<root(z, n, k)>,
indexing starting from I<zero> and ending at I<n - 1>.

The I<spaceship> numeric comparison operator, E<lt>=E<gt>, is also
defined. In order to ensure its restriction to real numbers is conform
to what you would expect, the comparison is run on the real part of
the complex number first, and imaginary parts are compared only when
the real parts match.

=head1 CREATION

To create a complex number, use either:

	$z = Math::Complex->make(3, 4);
	$z = cplx(3, 4);

if you know the cartesian form of the number, or

	$z = 3 + 4*i;

if you like. To create a number using the polar form, use either:

	$z = Math::Complex->emake(5, pi/3);
	$x = cplxe(5, pi/3);

instead. The first argument is the modulus, the second is the angle
(in radians, the full circle is 2*pi).  (Mnemonic: C<e> is used as a
notation for complex numbers in the polar form).

It is possible to write:

	$x = cplxe(-3, pi/4);

but that will be silently converted into C<[3,-3pi/4]>, since the
modulus must be non-negative (it represents the distance to the origin
in the complex plane).

It is also possible to have a complex number as either argument of the
C<make>, C<emake>, C<cplx>, and C<cplxe>: the appropriate component of
the argument will be used.

	$z1 = cplx(-2,  1);
	$z2 = cplx($z1, 4);

The C<new>, C<make>, C<emake>, C<cplx>, and C<cplxe> will also
understand a single (string) argument of the forms

    	2-3i
    	-3i
	[2,3]
	[2,-3pi/4]
	[2]

in which case the appropriate cartesian and exponential components
will be parsed from the string and used to create new complex numbers.
The imaginary component and the theta, respectively, will default to zero.

The C<new>, C<make>, C<emake>, C<cplx>, and C<cplxe> will also
understand the case of no arguments: this means plain zero or (0, 0).

=head1 DISPLAYING

When printed, a complex number is usually shown under its cartesian
style I<a+bi>, but there are legitimate cases where the polar style
I<[r,t]> is more appropriate.  The process of converting the complex
number into a string that can be displayed is known as I<stringification>.

By calling the class method C<Math::Complex::display_format> and
supplying either C<"polar"> or C<"cartesian"> as an argument, you
override the default display style, which is C<"cartesian">. Not
supplying any argument returns the current settings.

This default can be overridden on a per-number basis by calling the
C<display_format> method instead. As before, not supplying any argument
returns the current display style for this number. Otherwise whatever you
specify will be the new display style for I<this> particular number.

For instance:

	use Math::Complex;

	Math::Complex::display_format('polar');
	$j = (root(1, 3))[1];
	print "j = $j\n";		# Prints "j = [1,2pi/3]"
	$j->display_format('cartesian');
	print "j = $j\n";		# Prints "j = -0.5+0.866025403784439i"

The polar style attempts to emphasize arguments like I<k*pi/n>
(where I<n> is a positive integer and I<k> an integer within [-9, +9]),
this is called I<polar pretty-printing>.

For the reverse of stringifying, see the C<make> and C<emake>.

=head2 CHANGED IN PERL 5.6

The C<display_format> class method and the corresponding
C<display_format> object method can now be called using
a parameter hash instead of just a one parameter.

The old display format style, which can have values C<"cartesian"> or
C<"polar">, can be changed using the C<"style"> parameter.

	$j->display_format(style => "polar");

The one parameter calling convention also still works.

	$j->display_format("polar");

There are two new display parameters.

The first one is C<"format">, which is a sprintf()-style format string
to be used for both numeric parts of the complex number(s).  The is
somewhat system-dependent but most often it corresponds to C<"%.15g">.
You can revert to the default by setting the C<format> to C<undef>.

	# the $j from the above example

	$j->display_format('format' => '%.5f');
	print "j = $j\n";		# Prints "j = -0.50000+0.86603i"
	$j->display_format('format' => undef);
	print "j = $j\n";		# Prints "j = -0.5+0.86603i"

Notice that this affects also the return values of the
C<display_format> methods: in list context the whole parameter hash
will be returned, as opposed to only the style parameter value.
This is a potential incompatibility with earlier versions if you
have been calling the C<display_format> method in list context.

The second new display parameter is C<"polar_pretty_print">, which can
be set to true or false, the default being true.  See the previous
section for what this means.

=head1 USAGE

Thanks to overloading, the handling of arithmetics with complex numbers
is simple and almost transparent.

Here are some examples:

	use Math::Complex;

	$j = cplxe(1, 2*pi/3);	# $j ** 3 == 1
	print "j = $j, j**3 = ", $j ** 3, "\n";
	print "1 + j + j**2 = ", 1 + $j + $j**2, "\n";

	$z = -16 + 0*i;			# Force it to be a complex
	print "sqrt($z) = ", sqrt($z), "\n";

	$k = exp(i * 2*pi/3);
	print "$j - $k = ", $j - $k, "\n";

	$z->Re(3);			# Re, Im, arg, abs,
	$j->arg(2);			# (the last two aka rho, theta)
					# can be used also as mutators.

=head1 CONSTANTS

=head2 PI

The constant C<pi> and some handy multiples of it (pi2, pi4,
and pip2 (pi/2) and pip4 (pi/4)) are also available if separately
exported:

    use Math::Complex ':pi'; 
    $third_of_circle = pi2 / 3;

=head2 Inf

The floating point infinity can be exported as a subroutine Inf():

    use Math::Complex qw(Inf sinh);
    my $AlsoInf = Inf() + 42;
    my $AnotherInf = sinh(1e42);
    print "$AlsoInf is $AnotherInf\n" if $AlsoInf == $AnotherInf;

Note that the stringified form of infinity varies between platforms:
it can be for example any of

   inf
   infinity
   INF
   1.#INF

or it can be something else. 

Also note that in some platforms trying to use the infinity in
arithmetic operations may result in Perl crashing because using
an infinity causes SIGFPE or its moral equivalent to be sent.
The way to ignore this is

  local $SIG{FPE} = sub { };

=head1 ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO

The division (/) and the following functions

	log	ln	log10	logn
	tan	sec	csc	cot
	atan	asec	acsc	acot
	tanh	sech	csch	coth
	atanh	asech	acsch	acoth

cannot be computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause fatal
runtime errors looking like this

	cot(0): Division by zero.
	(Because in the definition of cot(0), the divisor sin(0) is 0)
	Died at ...

or

	atanh(-1): Logarithm of zero.
	Died at...

For the C<csc>, C<cot>, C<asec>, C<acsc>, C<acot>, C<csch>, C<coth>,
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the
logarithmic functions and the C<atanh>, C<acoth>, the argument cannot
be C<1> (one).  For the C<atanh>, C<acoth>, the argument cannot be
C<-1> (minus one).  For the C<atan>, C<acot>, the argument cannot be
C<i> (the imaginary unit).  For the C<atan>, C<acoth>, the argument
cannot be C<-i> (the negative imaginary unit).  For the C<tan>,
C<sec>, C<tanh>, the argument cannot be I<pi/2 + k * pi>, where I<k>
is any integer.  atan2(0, 0) is undefined, and if the complex arguments
are used for atan2(), a division by zero will happen if z1**2+z2**2 == 0.

Note that because we are operating on approximations of real numbers,
these errors can happen when merely `too close' to the singularities
listed above.

=head1 ERRORS DUE TO INDIGESTIBLE ARGUMENTS

The C<make> and C<emake> accept both real and complex arguments.
When they cannot recognize the arguments they will die with error
messages like the following

    Math::Complex::make: Cannot take real part of ...
    Math::Complex::make: Cannot take real part of ...
    Math::Complex::emake: Cannot take rho of ...
    Math::Complex::emake: Cannot take theta of ...

=head1 BUGS

Saying C<use Math::Complex;> exports many mathematical routines in the
caller environment and even overrides some (C<sqrt>, C<log>, C<atan2>).
This is construed as a feature by the Authors, actually... ;-)

All routines expect to be given real or complex numbers. Don't attempt to
use BigFloat, since Perl has currently no rule to disambiguate a '+'
operation (for instance) between two overloaded entities.

In Cray UNICOS there is some strange numerical instability that results
in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast.  Beware.
The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex.
Whatever it is, it does not manifest itself anywhere else where Perl runs.

=head1 SEE ALSO

L<Math::Trig>

=head1 AUTHORS

Daniel S. Lewart <F<lewart!at!uiuc.edu>>
Jarkko Hietaniemi <F<jhi!at!iki.fi>>
Raphael Manfredi <F<Raphael_Manfredi!at!pobox.com>>

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut

1;

# eof
@


1.9
log
@Merge in perl 5.10.1
@
text
@@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d10 5
a14 1
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS $Inf);
d16 1
a16 1
$VERSION = 1.37;
d19 25
a43 1
    unless ($^O eq 'unicosmk') {
d45 17
a61 12
	# We do want an arithmetic overflow, Inf INF inf Infinity:.
        undef $Inf unless eval <<'EOE' and $Inf =~ /^inf(?:inity)?$/i;
	  local $SIG{FPE} = sub {die};
	  my $t = CORE::exp 30;
	  $Inf = CORE::exp $t;
EOE
	if (!defined $Inf) {		# Try a different method
	  undef $Inf unless eval <<'EOE' and $Inf =~ /^inf(?:inity)?$/i;
	    local $SIG{FPE} = sub {die};
	    my $t = 1;
	    $Inf = $t + "1e99999999999999999999999999999999";
EOE
d63 4
d68 1
a68 1
    $Inf = "Inf" if !defined $Inf || !($Inf > 0); # Desperation.
d71 18
a88 1
use strict;
d122 1
a122 1
my @@pi = qw(pi pi2 pi4 pip2 pip4);
a165 2
#	bn_cartesian
#       bnc_dirty
d633 1
a633 1
	my ($z, $rho) = @@_;
d694 1
a694 1
	my ($z) = @@_;
d827 4
a830 3
	my ($z) = @@_;
	my ($x, $y) = @@{$z->_cartesian};
	return (ref $z)->emake(CORE::exp($x), $y);
d860 1
a860 1
	my ($z) = @@_;
d908 1
a908 1
	my ($z) = @@_;
d914 1
a914 1
	my $ey_1 = $ey ? 1 / $ey : $Inf;
d925 1
a925 1
	my ($z) = @@_;
d931 1
a931 1
	my $ey_1 = $ey ? 1 / $ey : $Inf;
d1125 1
a1125 1
	    return $ex ? ($ex + 1/$ex)/2 : $Inf;
d1129 1
a1129 1
	my $ex_1 = $ex ? 1 / $ex : $Inf;
d1145 1
a1145 1
	    return $ex ? ($ex - 1/$ex)/2 : "-$Inf";
d1151 1
a1151 1
	my $ex_1 = $ex ? 1 / $ex : $Inf;
d1165 4
a1168 1
	return sinh($z) / $cz;
d1211 4
a1214 1
	return cosh($z) / $sz;
d1227 1
a1227 1
# Computes the arc hyperbolic cosine acosh(z) = log(z + sqrt(z*z-1)).
d1255 1
a1255 1
# Computes the arc hyperbolic sine asinh(z) = log(z + sqrt(z*z+1))
d1275 1
a1275 1
# Computes the arc hyperbolic tangent atanh(z) = 1/2 log((1+z) / (1-z)).
d1291 1
a1291 1
# Computes the hyperbolic arc secant asech(z) = acosh(1 / z).
d1302 1
a1302 1
# Computes the hyperbolic arc cosecant acsch(z) = asinh(1 / z).
d1320 1
a1320 1
# Computes the arc hyperbolic cotangent acoth(z) = 1/2 log((1+z) / (z-1)).
d1454 1
a1454 1
		if ($x =~ /^-?$Inf$/oi) {
d1468 1
a1468 1
		if ($y =~ /^-?$Inf$/oi) {
d1512 1
a1512 1
	if ($t =~ /^NaN[QS]?$/i || $t =~ /^-?$Inf$/oi) {
d1550 4
d1821 5
a1825 5
The I<spaceship> comparison operator, E<lt>=E<gt>, is also defined. In
order to ensure its restriction to real numbers is conform to what you
would expect, the comparison is run on the real part of the complex
number first, and imaginary parts are compared only when the real
parts match.
d1973 2
d1984 26
d2074 4
d2083 5
@


1.7
log
@merge in perl 5.8.8
@
text
@d12 1
a12 1
$VERSION = 1.35;
d16 1
a16 1
        my $e = $!;
a29 1
        $! = $e; # Clear ERANGE.
d68 3
a70 1
@@EXPORT_OK = qw(decplx);
d74 1
d78 9
a86 9
	'+'	=> \&plus,
	'-'	=> \&minus,
	'*'	=> \&multiply,
	'/'	=> \&divide,
	'**'	=> \&power,
	'=='	=> \&numeq,
	'<=>'	=> \&spaceship,
	'neg'	=> \&negate,
	'~'	=> \&conjugate,
d95 1
a95 1
	qw("" stringify);
d112 2
d190 1
a190 1
    $self->set_cartesian([$re, $im ]);
d224 1
a224 1
    $self->set_polar([$rho, $theta]);
d260 1
a260 1
# pit2
d264 8
a271 1
sub pit2 () { 2 * pi }
d281 1
a281 1
# deg1
d283 1
a283 1
# One degree in radians, used in stringify_polar.
d285 1
a285 2

sub deg1 () { pi / 180 }
d288 1
a288 1
# uplog10
d292 1
a292 1
sub uplog10 () { 1 / CORE::log(10) }
d310 1
a310 1
# ip2
d314 1
a314 1
sub ip2 () { i / 2 }
d320 9
a328 9
sub cartesian {$_[0]->{c_dirty} ?
		   $_[0]->update_cartesian : $_[0]->{'cartesian'}}
sub polar     {$_[0]->{p_dirty} ?
		   $_[0]->update_polar : $_[0]->{'polar'}}

sub set_cartesian { $_[0]->{p_dirty}++; $_[0]->{c_dirty} = 0;
		    $_[0]->{'cartesian'} = $_[1] }
sub set_polar     { $_[0]->{c_dirty}++; $_[0]->{p_dirty} = 0;
		    $_[0]->{'polar'} = $_[1] }
d331 1
a331 1
# ->update_cartesian
d335 1
a335 1
sub update_cartesian {
d344 1
a344 1
# ->update_polar
d348 1
a348 1
sub update_polar {
d358 1
a358 1
# (plus)
d362 1
a362 1
sub plus {
d364 1
a364 1
	my ($re1, $im1) = @@{$z1->cartesian};
d366 1
a366 1
	my ($re2, $im2) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
d368 1
a368 1
		$z1->set_cartesian([$re1 + $re2, $im1 + $im2]);
d375 1
a375 1
# (minus)
d379 1
a379 1
sub minus {
d381 1
a381 1
	my ($re1, $im1) = @@{$z1->cartesian};
d383 1
a383 1
	my ($re2, $im2) = @@{$z2->cartesian};
d385 1
a385 1
		$z1->set_cartesian([$re1 - $re2, $im1 - $im2]);
d395 1
a395 1
# (multiply)
d399 1
a399 1
sub multiply {
d403 2
a404 2
	    my ($r1, $t1) = @@{$z1->polar};
	    my ($r2, $t2) = @@{$z2->polar};
d406 2
a407 2
	    if    ($t >   pi()) { $t -= pit2 }
	    elsif ($t <= -pi()) { $t += pit2 }
d409 1
a409 1
		$z1->set_polar([$r1 * $r2, $t]);
d414 1
a414 1
	    my ($x1, $y1) = @@{$z1->cartesian};
d416 1
a416 1
		my ($x2, $y2) = @@{$z2->cartesian};
d446 1
a446 1
# (divide)
d450 1
a450 1
sub divide {
d454 2
a455 2
	    my ($r1, $t1) = @@{$z1->polar};
	    my ($r2, $t2) = @@{$z2->polar};
d460 2
a461 2
		if    ($t >   pi()) { $t -= pit2 }
		elsif ($t <= -pi()) { $t += pit2 }
d466 2
a467 2
		if    ($t >   pi()) { $t -= pit2 }
		elsif ($t <= -pi()) { $t += pit2 }
d473 1
a473 1
		($x2, $y2) = @@{$z1->cartesian};
d478 1
a478 1
		my ($x1, $y1) = @@{$z1->cartesian};
d480 1
a480 1
		    ($x2, $y2) = @@{$z2->cartesian};
d495 1
a495 1
# (power)
d499 1
a499 1
sub power {
d513 1
a513 1
	       cplx(@@{$w->cartesian}) : $w;
d517 1
a517 1
# (spaceship)
d522 1
a522 1
sub spaceship {
d524 2
a525 2
	my ($re1, $im1) = ref $z1 ? @@{$z1->cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
d532 1
a532 1
# (numeq)
d536 2
a537 2
# (Required in addition to spaceship() because of NaNs.)
sub numeq {
d539 2
a540 2
	my ($re1, $im1) = ref $z1 ? @@{$z1->cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
d545 1
a545 1
# (negate)
d549 1
a549 1
sub negate {
d552 1
a552 1
		my ($r, $t) = @@{$z->polar};
d556 1
a556 1
	my ($re, $im) = @@{$z->cartesian};
d561 1
a561 1
# (conjugate)
d563 1
a563 1
# Compute complex's conjugate.
d565 1
a565 1
sub conjugate {
d568 1
a568 1
		my ($r, $t) = @@{$z->polar};
d571 1
a571 1
	my ($re, $im) = @@{$z->cartesian};
d590 1
a590 1
	    $z->{'polar'} = [ $rho, ${$z->polar}[1] ];
d595 1
a595 1
	    return ${$z->polar}[0];
d602 2
a603 2
    if    ($$theta >   pi()) { $$theta -= pit2 }
    elsif ($$theta <= -pi()) { $$theta += pit2 }
d616 1
a616 1
	    $z->{'polar'} = [ ${$z->polar}[0], $theta ];
d620 1
a620 1
	    $theta = ${$z->polar}[1];
d643 1
a643 1
	my ($re, $im) = ref $z ? @@{$z->cartesian} : ($z, 0);
d646 1
a646 1
	my ($r, $t) = @@{$z->polar};
d663 1
a663 1
	my ($r, $t) = @@{$z->polar};
d697 2
a698 2
	    @@{$z->polar} : (CORE::abs($z), $z >= 0 ? 0 : pi);
	my $theta_inc = pit2 / $n;
d708 1
a708 1
		push @@root, $cartesian ? cplx(@@{$w->cartesian}) : $w;
d713 1
a713 1
	    return $cartesian ? cplx(@@{$w->cartesian}) : $w;
d726 1
a726 1
	    $z->{'cartesian'} = [ $Re, ${$z->cartesian}[1] ];
d730 1
a730 1
	    return ${$z->cartesian}[0];
d743 1
a743 1
	    $z->{'cartesian'} = [ ${$z->cartesian}[0], $Im ];
d747 1
a747 1
	    return ${$z->cartesian}[1];
d776 1
a776 1
	my ($x, $y) = @@{$z->cartesian};
d812 1
a812 1
	my ($r, $t) = @@{$z->polar};
d814 2
a815 2
	if    ($t >   pi()) { $t -= pit2 }
	elsif ($t <= -pi()) { $t += pit2 }
d833 1
a833 1
	return Math::Complex::log($_[0]) * uplog10;
d857 1
a857 1
	my ($x, $y) = @@{$z->cartesian};
d874 1
a874 1
	my ($x, $y) = @@{$z->cartesian};
d955 1
a955 1
	my ($x, $y) = @@{$z->cartesian};
d980 1
a980 1
	my ($x, $y) = @@{$z->cartesian};
d1003 1
a1003 1
	my ($x, $y) = ref $z ? @@{$z->cartesian} : ($z, 0);
d1008 1
a1008 1
	return ip2 * $log;
d1074 1
a1074 1
	my ($x, $y) = @@{$z->cartesian};
d1094 1
a1094 1
	my ($x, $y) = @@{$z->cartesian};
d1175 1
a1175 1
	my ($re, $im) = @@{$z->cartesian};
d1291 2
a1292 2
	    ($re1, $im1) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
	    ($re2, $im2) = ref $z1 ? @@{$z1->cartesian} : ($z1, 0);
d1294 2
a1295 2
	    ($re1, $im1) = ref $z1 ? @@{$z1->cartesian} : ($z1, 0);
	    ($re2, $im2) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
d1358 1
a1358 1
# (stringify)
d1367 1
a1367 1
sub stringify {
d1374 2
a1375 2
	return $z->stringify_polar if $style =~ /^p/i;
	return $z->stringify_cartesian;
d1379 1
a1379 1
# ->stringify_cartesian
d1383 1
a1383 1
sub stringify_cartesian {
d1385 1
a1385 1
	my ($x, $y) = @@{$z->cartesian};
d1441 1
a1441 1
# ->stringify_polar
d1445 1
a1445 1
sub stringify_polar {
d1447 1
a1447 1
	my ($r, $t) = @@{$z->polar};
d1467 1
a1467 1
	$t -= int(CORE::abs($t) / pit2) * pit2;
d1584 2
a1585 2
the I<argument> of the complex number. The I<norm> of C<z> will be
noted C<abs(z)>.
d1587 5
a1591 5
The polar notation (also known as the trigonometric
representation) is much more handy for performing multiplications and
divisions of complex numbers, whilst the cartesian notation is better
suited for additions and subtractions. Real numbers are on the I<x>
axis, and therefore I<theta> is zero or I<pi>.
d1688 2
d1910 9
d1985 3
a1987 4
Daniel S. Lewart <F<d-lewart@@uiuc.edu>>

Original authors Raphael Manfredi <F<Raphael_Manfredi@@pobox.com>> and
Jarkko Hietaniemi <F<jhi@@iki.fi>>
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d10 1
a10 1
our($VERSION, @@ISA, @@EXPORT, %EXPORT_TAGS, $Inf);
d12 1
a12 1
$VERSION = 1.34;
d41 2
a42 1
my $gre = qr'\s*([\+\-]?(?:(?:(?:\d+(?:_\d+)*(?:\.\d*(?:_\d+)*)?|\.\d+(?:_\d+)*)(?:[eE][\+\-]?\d+(?:_\d+)*)?)))';
d65 1
d69 2
d115 1
a115 1
    die "@@{[(caller(1))[3]]}: Cannot take $_[0] of $_[1].\n";
d118 1
a118 1
sub _remake {
d120 1
a120 1
    my ($made, $p, $q);
d122 3
a124 1
    if ($arg =~ /^(?:$gre)?$gre\s*i\s*$/) {
d126 19
a144 2
	$made = 'cart';
    } elsif ($arg =~ /^\s*\[\s*$gre\s*(?:,\s*$gre\s*)?\]\s*$/) {
d146 6
a151 1
	$made = 'exp';
d154 1
a154 1
    if ($made) {
d157 2
d161 1
a161 1
    return ($made, $p, $q);
d170 12
a181 28
	my $self = bless {}, shift;
	my ($re, $im) = @@_;
	if (@@_ == 1) {
	    my ($remade, $p, $q) = _remake($re);
	    if ($remade) {
		if ($remade eq 'cart') {
		    ($re, $im) = ($p, $q);
		} else {
		    return (ref $self)->emake($p, $q);
		}
	    }
	}
	my $rre = ref $re;
	if ( $rre ) {
	    if ( $rre eq ref $self ) {
		$re = Re($re);
	    } else {
		_cannot_make("real part", $rre);
	    }
	}
	my $rim = ref $im;
	if ( $rim ) {
	    if ( $rim eq ref $self ) {
		$im = Im($im);
	    } else {
		_cannot_make("imaginary part", $rim);
	    }
	}
d183 7
a189 7
	$im ||= 0;
	_cannot_make("imaginary part", $im) unless $im =~ /^$gre$/;
	$self->{'cartesian'} = [ $re, $im ];
	$self->{c_dirty} = 0;
	$self->{p_dirty} = 1;
	$self->display_format('cartesian');
	return $self;
d198 12
a209 28
	my $self = bless {}, shift;
	my ($rho, $theta) = @@_;
	if (@@_ == 1) {
	    my ($remade, $p, $q) = _remake($rho);
	    if ($remade) {
		if ($remade eq 'exp') {
		    ($rho, $theta) = ($p, $q);
		} else {
		    return (ref $self)->make($p, $q);
		}
	    }
	}
	my $rrh = ref $rho;
	if ( $rrh ) {
	    if ( $rrh eq ref $self ) {
		$rho = rho($rho);
	    } else {
		_cannot_make("rho", $rrh);
	    }
	}
	my $rth = ref $theta;
	if ( $rth ) {
	    if ( $rth eq ref $self ) {
		$theta = theta($theta);
	    } else {
		_cannot_make("theta", $rth);
	    }
	}
d214 2
d217 7
a223 7
	$theta ||= 0;
	_cannot_make("theta", $theta) unless $theta =~ /^$gre$/;
	$self->{'polar'} = [$rho, $theta];
	$self->{p_dirty} = 0;
	$self->{c_dirty} = 1;
	$self->display_format('polar');
	return $self;
d315 4
a318 2
sub set_cartesian { $_[0]->{p_dirty}++; $_[0]->{'cartesian'} = $_[1] }
sub set_polar     { $_[0]->{c_dirty}++; $_[0]->{'polar'} = $_[1] }
d664 1
a664 1
    my $mess = "Root $_[0] illegal, root rank must be positive integer.\n";
d684 1
a684 1
	my ($z, $n) = @@_;
a687 2
	my @@root;
	my $k;
a689 1
	my $theta;
d691 13
a703 4
	for ($k = 0, $theta = $t / $n; $k < $n; $k++, $theta += $theta_inc) {
	    my $w = cplxe($rho, $theta);
	    # Yes, $cartesian is loop invariant.
	    push @@root, $cartesian ? cplx(@@{$w->cartesian}) : $w;
a704 1
	return @@root;
d1275 1
a1275 1
# Compute atan(z1/z2).
d1282 1
a1282 1
	    ($re2, $im2) = @@{$z1->cartesian};
d1284 1
a1284 1
	    ($re1, $im1) = @@{$z1->cartesian};
d1287 12
a1298 9
	if ($im2 == 0) {
	    return CORE::atan2($re1, $re2) if $im1 == 0;
	    return ($im1<=>0) * pip2 if $re2 == 0;
	}
	my $w = atan($z1/$z2);
	my ($u, $v) = ref $w ? @@{$w->cartesian} : ($w, 0);
	$u += pi   if $re2 < 0;
	$u -= pit2 if $u > pi;
	return cplx($u, $v);
d1672 5
a1676 1
	atan2(z1, z2) = atan(z1/z2)
d1743 3
d1793 1
d1800 4
a1803 1
=head1 STRINGIFICATION
d1807 2
a1808 1
I<[r,t]> is more appropriate.
d1834 2
d1929 2
a1930 1
is any integer.
d1950 1
a1950 1
caller environment and even overrides some (C<sqrt>, C<log>).
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d12 1
a12 1
$VERSION = 1.31;
d40 3
d114 20
d142 10
d168 3
d186 10
d216 3
d235 1
a235 2
	my ($re, $im) = @@_;
	return __PACKAGE__->make($re, defined $im ? $im : 0);
d245 1
a245 2
	my ($rho, $theta) = @@_;
	return __PACKAGE__->emake($rho, defined $theta ? $theta : 0);
d1611 1
a1611 1
with an horizontal bar above the number, or C<~z> here.
d1710 1
a1710 1
C<rho>, and C<theta> can be used also also mutators.  The C<cbrt>
d1763 2
a1764 2
It is also possible to have a complex number as either argument of
either the C<make> or C<emake>: the appropriate component of
d1770 12
d1898 1
a1898 1
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the the
d1939 1
a1939 2
Raphael Manfredi <F<Raphael_Manfredi@@pobox.com>> and
Jarkko Hietaniemi <F<jhi@@iki.fi>>.
d1941 2
a1942 1
Extensive patches by Daniel S. Lewart <F<d-lewart@@uiuc.edu>>.
@


1.4
log
@perl-5.6.0 + local changes
@
text
@a7 1
require Exporter;
d10 25
a34 1
use 5.005_64;
d37 2
a38 1
our($VERSION, @@ISA, @@EXPORT, %EXPORT_TAGS);
d40 1
a40 3
my ( $i, $ip2, %logn );

$VERSION = sprintf("%s", q$Id: Complex.pm,v 1.26 1998/11/01 00:00:00 dsl Exp $ =~ /(\d+\.\d+)/);
d74 1
a91 1
my $package        = 'Math::Complex';	# Package name
d253 7
d294 2
a295 1
	return $self->{'polar'} = [CORE::sqrt($x*$x + $y*$y), CORE::atan2($y, $x)];
d375 1
a375 1
	$mess .= "$_[1] " unless ($_[1] eq '0');
d449 2
a450 2
	my $w = $inverted ? CORE::exp($z1 * CORE::log($z2))
	                  : CORE::exp($z2 * CORE::log($z1));
d473 13
d523 7
a529 1
	return $z unless ref $z;
d585 2
a586 1
	return $re < 0 ? cplx(0, CORE::sqrt(-$re)) : CORE::sqrt($re) if $im == 0;
d600 3
a602 1
	return $z < 0 ? -CORE::exp(CORE::log(-$z)/3) : ($z > 0 ? CORE::exp(CORE::log($z)/3): 0)
d605 1
d615 1
a615 1
    my $mess = "Root $_[0] not defined, root must be positive integer.\n";
d637 2
a638 1
	my ($r, $t) = ref $z ? @@{$z->polar} : (CORE::abs($z), $z >= 0 ? 0 : pi);
d677 1
a677 1
	return $z unless ref $z;
d780 3
a782 3
	my $logn = $logn{$n};
	$logn = $logn{$n} = CORE::log($n) unless defined $logn;	# Cache log(n)
	return CORE::log($z) / $logn;
d792 1
d795 5
a799 3
	my $ey_1 = 1 / $ey;
	return (ref $z)->make(CORE::cos($x) * ($ey + $ey_1)/2,
			      CORE::sin($x) * ($ey_1 - $ey)/2);
d809 1
d812 5
a816 3
	my $ey_1 = 1 / $ey;
	return (ref $z)->make(CORE::sin($x) * ($ey + $ey_1)/2,
			      CORE::cos($x) * ($ey - $ey_1)/2);
d826 3
a828 3
	my $cz = CORE::cos($z);
	_divbyzero "tan($z)", "cos($z)" if (CORE::abs($cz) < $eps);
	return CORE::sin($z) / $cz;
d838 1
a838 1
	my $cz = CORE::cos($z);
d850 1
a850 1
	my $sz = CORE::sin($z);
d869 1
a869 1
	my $sz = CORE::sin($z);
d871 1
a871 1
	return CORE::cos($z) / $sz;
d888 5
a892 2
	return CORE::atan2(CORE::sqrt(1-$z*$z), $z) if (! ref $z) && CORE::abs($z) <= 1;
	my ($x, $y) = ref $z ? @@{$z->cartesian} : ($z, 0);
d903 1
a903 1
	return __PACKAGE__->make($u, $v);
d913 5
a917 2
	return CORE::atan2($z, CORE::sqrt(1-$z*$z)) if (! ref $z) && CORE::abs($z) <= 1;
	my ($x, $y) = ref $z ? @@{$z->cartesian} : ($z, 0);
d928 1
a928 1
	return __PACKAGE__->make($u, $v);
d939 2
d942 3
a944 4
	_divbyzero "atan(-i)" if (-$z == i);
	my $log = CORE::log((i + $z) / (i - $z));
	$ip2 = 0.5 * i unless defined $ip2;
	return $ip2 * $log;
d983 5
a987 4
	_divbyzero "acot(0)"  if (CORE::abs($z)     < $eps);
	return ($z >= 0) ? CORE::atan2(1, $z) : CORE::atan2(-1, -$z) unless ref $z;
	_divbyzero "acot(i)"  if (CORE::abs($z - i) < $eps);
	_logofzero "acot(-i)" if (CORE::abs($z + i) < $eps);
d1008 1
a1008 1
	    return ($ex + 1/$ex)/2;
d1012 1
a1012 1
	my $ex_1 = 1 / $ex;
d1026 1
d1028 1
a1028 1
	    return ($ex - 1/$ex)/2;
d1031 2
d1034 1
a1034 1
	my $ex_1 = 1 / $ex;
d1090 1
a1090 1
	_divbyzero "coth($z)", "sinh($z)" if ($sz == 0);
a1108 1
	    return CORE::log($z + CORE::sqrt($z*$z-1)) if $z >= 1;
d1113 14
a1126 4
	    return cplx(CORE::log($re + CORE::sqrt($re*$re - 1)), 0) if $re >= 1;
	    return cplx(0, CORE::atan2(CORE::sqrt(1-$re*$re), $re)) if CORE::abs($re) <= 1;
	}
	return CORE::log($z + CORE::sqrt($z*$z - 1));
d1132 1
a1132 1
# Computes the arc hyperbolic sine asinh(z) = log(z + sqrt(z*z-1))
d1136 11
a1146 1
	return CORE::log($z + CORE::sqrt($z*$z + 1));
d1160 3
a1162 3
	_divbyzero 'atanh(1)',  "1 - $z" if ($z ==  1);
	_logofzero 'atanh(-1)'           if ($z == -1);
	return 0.5 * CORE::log((1 + $z) / (1 - $z));
d1172 1
a1172 1
	_divbyzero 'asech(0)', $z if ($z == 0);
d1201 1
a1201 1
	_divbyzero 'acoth(0)'            if (CORE::abs($z)     < $eps);
d1206 3
a1208 3
	_divbyzero 'acoth(1)',  "$z - 1" if (CORE::abs($z - 1) < $eps);
	_logofzero 'acoth(-1)', "1 / $z" if (CORE::abs($z + 1) < $eps);
	return CORE::log((1 + $z) / ($z - 1)) / 2;
d1234 2
a1235 2
	    return cplx(CORE::atan2($re1, $re2), 0) if $im1 == 0;
	    return cplx(($im1<=>0) * pip2, 0) if $re2 == 0;
d1266 6
a1271 14
	    if (@@_ == 1) {
		$display_format{style} = shift;
	    } else {
		my %new = @@_;
		@@display_format{keys %new} = values %new;
	    }
	} else {				# Called as a class method
	    if (@@_ = 1) {
		$display_format{style} = $self;
	    } else {
		my %new = @@_;
		@@display_format{keys %new} = values %new;
	    }
	    undef $self;
d1274 1
a1274 1
	if (defined $self) {
d1282 1
a1320 7
	$x = int($x + ($x < 0 ? -1 : 1) * $eps)
		if int(CORE::abs($x)) != int(CORE::abs($x) + $eps);
	$y = int($y + ($y < 0 ? -1 : 1) * $eps)
		if int(CORE::abs($y)) != int(CORE::abs($y) + $eps);

	$re = "$x" if CORE::abs($x) >= $eps;

d1324 30
a1353 4
	if ($y == 1)			       { $im = 'i' }
	elsif ($y == -1)		       { $im = '-i' }
	elsif (CORE::abs($y) >= $eps) {
	    $im = (defined $format ? sprintf($format, $y) : $y) . "i";
d1356 2
a1357 3
	my $str = '';
	$str = defined $format ? sprintf($format, $re) : $re
	    if defined $re;
d1361 1
a1361 1
	    } elsif ($y > 0)  {
d1365 2
a1372 29
# Helper for stringify_polar, a Greatest Common Divisor with a memory.

sub _gcd {
    my ($a, $b) = @@_;

    use integer;

    # Loops forever if given negative inputs.

    if    ($b and $a > $b) { return gcd($a % $b, $b) }
    elsif ($a and $b > $a) { return gcd($b % $a, $a) }
    else                   { return $a ? $a : $b     }
}

my %gcd;

sub gcd {
    my ($a, $b) = @@_;

    my $id = "$a $b";

    unless (exists $gcd{$id}) {
	$gcd{$id} = _gcd($a, $b);
	$gcd{"$b $a"} = $gcd{$id};
    }

    return $gcd{$id};
}

a1382 2
	return '[0,0]' if $r <= $eps;

d1384 1
d1386 7
a1392 3
	my $nt = $t / pit2;
	$nt = ($nt - int($nt)) * pit2;
	$nt += pit2 if $nt < 0;			# Range [0, 2pi]
d1394 1
a1394 11
	if (CORE::abs($nt) <= $eps)		{ $theta = 0 }
	elsif (CORE::abs(pi-$nt) <= $eps)	{ $theta = 'pi' }

	if (defined $theta) {
		$r = int($r + ($r < 0 ? -1 : 1) * $eps)
			if int(CORE::abs($r)) != int(CORE::abs($r) + $eps);
		$theta = int($theta + ($theta < 0 ? -1 : 1) * $eps)
			if ($theta ne 'pi' and
			    int(CORE::abs($theta)) != int(CORE::abs($theta) + $eps));
		return "\[$r,$theta\]";
	}
d1397 1
a1397 1
	# Okay, number is not a real. Try to identify pi/n and friends...
d1400 1
a1400 4
	$nt -= pit2 if $nt > pi;

	if ($format{polar_pretty_print} && CORE::abs($nt) >= deg1) {
	    my ($n, $k, $kpi);
d1402 7
a1408 13
	    for ($k = 1, $kpi = pi; $k < 10; $k++, $kpi += pi) {
		$n = int($kpi / $nt + ($nt > 0 ? 1 : -1) * 0.5);
		if (CORE::abs($kpi/$n - $nt) <= $eps) {
		    $n = CORE::abs($n);
		    my $gcd = gcd($k, $n);
		    if ($gcd > 1) {
			$k /= $gcd;
			$n /= $gcd;
		    }
		    next if $n > 360;
		    $theta = ($nt < 0 ? '-':'').
			     ($k == 1 ? 'pi':"${k}pi");
		    $theta .= '/'.$n if $n > 1;
a1413 9
	$theta = $nt unless defined $theta;

	$r = int($r + ($r < 0 ? -1 : 1) * $eps)
		if int(CORE::abs($r)) != int(CORE::abs($r) + $eps);
	$theta = int($theta + ($theta < 0 ? -1 : 1) * $eps)
		if ($theta !~ m(^-?\d*pi/\d+$) and
		    int(CORE::abs($theta)) != int(CORE::abs($theta) + $eps));

	my $format = $format{format};
d1416 3
a1418 1
	    $theta = sprintf($format, $theta);
d1421 1
a1421 1
	return "\[$r,$theta\]";
d1750 1
a1750 1
(where I<n> is a positive integer and I<k> an integer within [-9,+9]),
d1760 7
a1766 2
C<"polar">, can be changed using the C<"style"> parameter.  (The one
parameter calling convention also still works.)
d1770 4
a1773 5
The first one is C<"format">, which is a sprintf()-style format
string to be used for both parts of the complex number(s).  The
default is C<undef>, which corresponds usually (this is somewhat
system-dependent) to C<"%.15g">.  You can revert to the default by
setting the format string to C<undef>.
d1779 1
a1779 1
	$j->display_format('format' => '%.6f');
d1784 3
a1786 3
will be returned, as opposed to only the style parameter value.  If
you want to know the whole truth for a complex number, you must call
both the class method and the object method:
d1850 1
a1850 2
listed above.  For example C<tan(2*atan2(1,1)+1e-15)> will die of
division by zero.
@


1.3
log
@perl5.005_03 (stock)
@
text
@d11 1
d14 1
a14 1
use vars qw($VERSION @@ISA @@EXPORT %EXPORT_TAGS);
d69 4
a72 3
my $package = 'Math::Complex';		# Package name
my $display = 'cartesian';		# Default display format
my $eps     = 1e-14;			# Epsilon
d165 1
a165 1
	return $package->make($re, defined $im ? $im : 0);
d176 1
a176 1
	return $package->emake($rho, defined $theta ? $theta : 0);
d184 1
a184 1
use constant pi => 4 * CORE::atan2(1, 1);
d191 1
a191 1
use constant pit2 => 2 * pi;
d198 1
a198 1
use constant pip2 => pi / 2;
d206 1
a206 1
use constant deg1 => pi / 180;
d213 1
a213 1
use constant uplog10 => 1 / CORE::log(10);
d840 1
a840 1
	return $package->make($u, $v);
d862 1
a862 1
	return $package->make($u, $v);
d1158 1
a1158 1
# Set (fetch if no argument) display format for all complex numbers that
d1161 1
a1161 1
# When called as a method, this actually sets the display format for
d1168 2
a1169 2
	my $self = shift;
	my $format = undef;
d1171 19
a1189 5
	if (ref $self) {			# Called as a method
		$format = shift;
	} else {				# Regular procedure call
		$format = $self;
		undef $self;
d1193 5
a1197 3
		return defined $self->{display} ? $self->{display} : $display
			unless defined $format;
		return $self->{display} = $format;
d1200 5
a1204 2
	return $display unless defined $format;
	return $display = $format;
a1218 1
	my $format;
d1220 3
a1222 2
	$format = $display;
	$format = $z->{display} if defined $z->{display};
d1224 1
a1224 1
	return $z->stringify_polar if $format =~ /^p/i;
d1244 9
a1252 3
        if ($y == 1)                           { $im = 'i' }
        elsif ($y == -1)                       { $im = '-i' }
        elsif (CORE::abs($y) >= $eps)                { $im = $y . "i" }
d1255 10
a1264 6
	$str = $re if defined $re;
	$str .= "+$im" if defined $im;
	$str =~ s/\+-/-/;
	$str =~ s/^\+//;
	$str =~ s/([-+])1i/$1i/; # Not redundant with the above 1/-1 tests.
	$str = '0' unless $str;
d1311 2
d1335 1
a1335 1
	if (CORE::abs($nt) >= deg1) {
d1364 6
d1376 2
d1661 3
a1663 3
but that will be silently converted into C<[3,-3pi/4]>, since the modulus
must be non-negative (it represents the distance to the origin in the complex
plane).
d1675 1
a1675 1
form I<a+bi>, but there are legitimate cases where the polar format
d1678 4
a1681 4
By calling the routine C<Math::Complex::display_format> and supplying either
C<"polar"> or C<"cartesian">, you override the default display format,
which is C<"cartesian">. Not supplying any argument returns the current
setting.
d1685 2
a1686 2
returns the current display format for this number. Otherwise whatever you
specify will be the new display format for I<this> particular number.
d1693 2
a1694 2
	$j = ((root(1, 3))[1];
	print "j = $j\n";		# Prints "j = [1,2pi/3]
d1698 38
a1735 2
The polar format attempts to emphasize arguments like I<k*pi/n>
(where I<n> is a positive integer and I<k> an integer within [-9,+9]).
d1826 1
a1826 1
Raphael Manfredi <F<Raphael_Manfredi@@grenoble.hp.com>> and
@


1.2
log
@perl 5.004_04
@
text
@d3 3
a5 3
# -- Raphael Manfredi	September 1996
# -- Jarkko Hietaniemi	March-October 1997
# -- Daniel S. Lewart	September-October 1997
d11 1
a11 1
$VERSION = 1.05;
d13 1
a13 1
# $Id: Complex.pm,v 1.2 1997/10/15 10:08:39 jhi Exp $
d15 1
a15 1
use strict;
d17 1
a17 4
use vars qw($VERSION @@ISA
	    @@EXPORT %EXPORT_TAGS
	    $package $display
	    $i $ip2 $logn %logn);
d34 1
a34 1
	     i Re Im arg
d65 1
a65 1
# Package globals
d68 3
a70 2
$package = 'Math::Complex';		# Package name
$display = 'cartesian';			# Default display format
d81 6
d95 17
a111 1
	$self->{'cartesian'} = [$re, $im];
d114 1
d126 16
d149 1
d182 1
a182 1
use constant pi => 4 * atan2(1, 1);
d199 8
d211 1
a211 1
use constant uplog10 => 1 / log(10);
d249 1
a249 1
	return $self->{'cartesian'} = [$r * cos $t, $r * sin $t];
d263 1
a263 1
	return $self->{'polar'} = [sqrt($x*$x + $y*$y), atan2($y, $x)];
a403 15
# _zerotozero
#
# Die on zero raised to the zeroth.
#
sub _zerotozero {
    my $mess = "The zero raised to the zeroth power is not defined.\n";

    my @@up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
a409 3
	my $z1z = $z1 == 0;
	my $z2z = $z2 == 0;
	_zerotozero if ($z1z and $z2z);
d411 2
a412 2
	    return 0 if ($z2z);
	    return 1 if ($z1z or $z2 == 1);
d414 2
a415 2
	    return 0 if ($z1z);
	    return 1 if ($z2z or $z1 == 1);
d417 6
a422 1
	return $inverted ? exp($z1 * log $z2) : exp($z2 * log $z1);
d429 1
a429 1
# Sorts on the real part first, then on the imaginary part. Thus 2-4i > 3+8i.
d474 1
a474 1
# Compute complex's norm (rho).
d477 17
a493 3
	my ($z) = @@_;
	my ($r, $t) = @@{$z->polar};
	return $r;
d499 1
a499 1
# Compute complex's argument (theta).
d502 12
a513 6
	my ($z) = @@_;
	return ($z < 0 ? pi : 0) unless ref $z;
	my ($r, $t) = @@{$z->polar};
	if    ($t >   pi()) { $t -= pit2 }
	elsif ($t <= -pi()) { $t += pit2 }
	return $t;
d521 10
d533 2
a534 3
	return $z >= 0 ? sqrt($z) : cplx(0, sqrt(-$z)) unless ref $z;
	my ($re, $im) = @@{$z->cartesian};
	return cplx($re < 0 ? (0, sqrt(-$re)) : (sqrt($re), 0)) if $im == 0;
d536 1
a536 1
	return (ref $z)->emake(sqrt($r), $t/2);
d544 2
d548 1
a548 1
	return $z < 0 ? -exp(log(-$z)/3) : ($z > 0 ? exp(log($z)/3): 0)
d551 1
a551 1
	return (ref $z)->emake(exp(log($r)/3), $t/3);
d582 1
a582 1
	my ($r, $t) = ref $z ? @@{$z->polar} : (abs($z), $z >= 0 ? 0 : pi);
d588 1
a588 1
	my $complex = ref($z) || $package;
d590 3
a592 1
		push(@@root, $complex->emake($rho, $theta));
d600 1
a600 1
# Return Re(z).
d603 1
a603 1
	my ($z) = @@_;
d605 7
a611 2
	my ($re, $im) = @@{$z->cartesian};
	return $re;
d617 1
a617 1
# Return Im(z).
d620 27
a646 4
	my ($z) = @@_;
	return 0 unless ref $z;
	my ($re, $im) = @@{$z->cartesian};
	return $im;
d657 1
a657 1
	return (ref $z)->emake(exp($x), $y);
d690 1
a690 1
	    return $z > 0 ? log($z) : cplx(log(-$z), pi);
d696 1
a696 1
	return (ref $z)->make(log($r), $t);
d725 2
a726 2
	$logn = $logn{$n} = log($n) unless defined $logn;	# Cache log(n)
	return log($z) / $logn;
d737 1
a737 1
	my $ey = exp($y);
d739 2
a740 2
	return (ref $z)->make(cos($x) * ($ey + $ey_1)/2,
			      sin($x) * ($ey_1 - $ey)/2);
d751 1
a751 1
	my $ey = exp($y);
d753 2
a754 2
	return (ref $z)->make(sin($x) * ($ey + $ey_1)/2,
			      cos($x) * ($ey - $ey_1)/2);
d764 3
a766 3
	my $cz = cos($z);
	_divbyzero "tan($z)", "cos($z)" if ($cz == 0);
	return sin($z) / $cz;
d776 1
a776 1
	my $cz = cos($z);
d788 1
a788 1
	my $sz = sin($z);
d807 1
a807 1
	my $sz = sin($z);
d809 1
a809 1
	return cos($z) / $sz;
d826 1
a826 1
	return atan2(sqrt(1-$z*$z), $z) if (! ref $z) && abs($z) <= 1;
d828 2
a829 2
	my $t1 = sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = sqrt(($x-1)*($x-1) + $y*$y);
d835 2
a836 2
	my $u = atan2(sqrt(1-$beta*$beta), $beta);
	my $v = log($alpha + sqrt($alpha*$alpha-1));
d848 1
a848 1
	return atan2($z, sqrt(1-$z*$z)) if (! ref $z) && abs($z) <= 1;
d850 2
a851 2
	my $t1 = sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = sqrt(($x-1)*($x-1) + $y*$y);
d857 2
a858 2
	my $u =  atan2($beta, sqrt(1-$beta*$beta));
	my $v = -log($alpha + sqrt($alpha*$alpha-1));
d870 1
a870 1
	return atan2($z, 1) unless ref $z;
d873 1
a873 1
	my $log = log((i + $z) / (i - $z));
d914 4
a917 3
	return ($z >= 0) ? atan2(1, $z) : atan2(-1, -$z) unless ref $z;
	_divbyzero "acot(i)", if ( $z == i);
	_divbyzero "acot(-i)" if (-$z == i);
d937 1
a937 1
	    $ex = exp($z);
d941 1
a941 1
	$ex = exp($x);
d943 2
a944 2
	return (ref $z)->make(cos($y) * ($ex + $ex_1)/2,
			      sin($y) * ($ex - $ex_1)/2);
d956 1
a956 1
	    $ex = exp($z);
d960 1
a960 1
	$ex = exp($x);
d962 2
a963 2
	return (ref $z)->make(cos($y) * ($ex - $ex_1)/2,
			      sin($y) * ($ex + $ex_1)/2);
d1036 1
a1036 1
	    return log($z + sqrt($z*$z-1)) if $z >= 1;
d1041 2
a1042 2
	    return cplx(log($re + sqrt($re*$re - 1)), 0) if $re >= 1;
	    return cplx(0, atan2(sqrt(1-$re*$re), $re)) if abs($re) <= 1;
d1044 1
a1044 1
	return log($z + sqrt($z*$z - 1));
d1054 1
a1054 1
	return log($z + sqrt($z*$z + 1));
d1065 1
a1065 1
	    return log((1 + $z)/(1 - $z))/2 if abs($z) < 1;
d1070 1
a1070 1
	return 0.5 * log((1 + $z) / (1 - $z));
d1109 1
d1111 1
a1111 1
	    return log(($z + 1)/($z - 1))/2 if abs($z) > 1;
d1114 3
a1116 3
	_divbyzero 'acoth(1)', "$z - 1" if ($z ==  1);
	_logofzero 'acoth(-1)'          if ($z == -1);
	return log((1 + $z) / ($z - 1)) / 2;
d1142 1
a1142 1
	    return cplx(atan2($re1, $re2), 0) if $im1 == 0;
a1215 1
	my $eps = 1e-14;
d1218 1
a1218 1
		if int(abs($x)) != int(abs($x) + $eps);
d1220 1
a1220 1
		if int(abs($y)) != int(abs($y) + $eps);
d1222 1
a1222 1
	$re = "$x" if abs($x) >= $eps;
d1225 1
a1225 1
        elsif (abs($y) >= $eps)                { $im = $y . "i" }
d1232 1
d1238 30
a1276 1
	my $eps = 1e-14;
d1284 2
a1285 2
	if (abs($nt) <= $eps)		{ $theta = 0 }
	elsif (abs(pi-$nt) <= $eps)	{ $theta = 'pi' }
d1289 1
a1289 1
			if int(abs($r)) != int(abs($r) + $eps);
d1292 1
a1292 1
			    int(abs($theta)) != int(abs($theta) + $eps));
a1300 1
	my ($n, $k, $kpi);
d1302 4
a1305 1
	for ($k = 1, $kpi = pi; $k < 10; $k++, $kpi += pi) {
d1307 12
a1318 4
		if (abs($kpi/$n - $nt) <= $eps) {
			$theta = ($nt < 0 ? '-':'').
				 ($k == 1 ? 'pi':"${k}pi").'/'.abs($n);
			last;
d1320 1
d1326 1
a1326 1
		if int(abs($r)) != int(abs($r) + $eps);
d1329 1
a1329 1
		    int(abs($theta)) != int(abs($theta) + $eps));
d1462 2
d1516 7
a1522 7
	~z1 = a - bi
	abs(z1) = r1 = sqrt(a*a + b*b)
	sqrt(z1) = sqrt(r1) * exp(i * t1/2)
	exp(z1) = exp(a) * exp(i * b)
	log(z1) = log(r1) + i*t1
	sin(z1) = 1/2i (exp(i * z1) - exp(-i * z1))
	cos(z1) = 1/2 (exp(i * z1) + exp(-i * z1))
d1531 1
d1567 7
a1573 4
I<log>, I<csc>, I<cot>, I<acsc>, I<acot>, I<csch>, I<coth>,
I<acosech>, I<acotanh>, have aliases I<ln>, I<cosec>, I<cotan>,
I<acosec>, I<acotan>, I<cosech>, I<cotanh>, I<acosech>, I<acotanh>,
respectively.
d1624 7
d1679 5
a1683 1
=head1 ERRORS DUE TO DIVISION BY ZERO
d1687 5
a1691 16
	tan
	sec
	csc
	cot
	asec
	acsc
	atan
	acot
	tanh
	sech
	csch
	coth
	atanh
	asech
	acsch
	acoth
d1707 24
a1730 7
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the
C<atanh>, C<acoth>, the argument cannot be C<1> (one).  For the
C<atanh>, C<acoth>, the argument cannot be C<-1> (minus one).  For the
C<atan>, C<acot>, the argument cannot be C<i> (the imaginary unit).
For the C<atan>, C<acoth>, the argument cannot be C<-i> (the negative
imaginary unit).  For the C<tan>, C<sec>, C<tanh>, C<sech>, the
argument cannot be I<pi/2 + k * pi>, where I<k> is any integer.
d1742 5
d1755 2
@


1.1
log
@Initial revision
@
text
@d1 8
d11 3
a13 1
require Exporter;
d15 1
a15 1
@@ISA = ('Exporter');
d17 30
a46 1
# just to make use happy
d49 480
a528 79
    '+'   => sub  { my($x1,$y1,$x2,$y2) = (@@{$_[0]},@@{$_[1]});
                      bless [ $x1+$x2, $y1+$y2];
             },

    '-'   => sub  { my($x1,$y1,$x2,$y2) = (@@{$_[0]},@@{$_[1]});
                      bless [ $x1-$x2, $y1-$y2];
             },

    '*'   => sub  { my($x1,$y1,$x2,$y2) = (@@{$_[0]},@@{$_[1]});
                    bless [ $x1*$x2-$y1*$y2,$x1*$y2+$x2*$y1];
             },

    '/'   => sub  { my($x1,$y1,$x2,$y2) = (@@{$_[0]},@@{$_[1]});
                    my $q = $x2*$x2+$y2*$y2;
                    bless [($x1*$x2+$y1*$y2)/$q, ($y1*$x2-$y2*$x1)/$q];
             },

    'neg' => sub  { my($x,$y) = @@{$_[0]}; bless [ -$x, -$y];
             },

    '~'   => sub  { my($x,$y) = @@{$_[0]}; bless [ $x, -$y];
             },

    'abs'   => sub  { my($x,$y) = @@{$_[0]}; sqrt $x*$x+$y*$y;
             },

    'cos' => sub { my($x,$y) = @@{$_[0]};
                   my ($ab,$c,$s) = (exp $y, cos $x, sin $x);
                   my $abr = 1/(2*$ab); $ab /= 2;
                   bless [ ($abr+$ab)*$c, ($abr-$ab)*$s];
             },

    'sin' => sub { my($x,$y) = @@{$_[0]};
                   my ($ab,$c,$s) = (exp $y, cos $x, sin $x);
                   my $abr = 1/(2*$ab); $ab /= 2;
                   bless [ (-$abr-$ab)*$s, ($abr-$ab)*$c];
             },

    'exp' => sub { my($x,$y) = @@{$_[0]};
                   my ($ab,$c,$s) = (exp $x, cos $y, sin $y);
                   bless [ $ab*$c, $ab*$s ];
              },

    'sqrt' => sub { 
	my($zr,$zi) = @@{$_[0]};
	my ($x, $y, $r, $w);
	my $c = new Math::Complex (0,0);
        if (($zr == 0) && ($zi == 0)) { 
	    # nothing, $c already set
	}
        else {
	  $x = abs($zr);
	  $y = abs($zi);
	  if ($x >= $y) { 
	      $r = $y/$x; 
	      $w = sqrt($x) * sqrt(0.5*(1.0+sqrt(1.0+$r*$r))); 
	  }
	  else { 
	      $r = $x/$y; 
	      $w = sqrt($y) * sqrt($y) * sqrt(0.5*($r+sqrt(1.0+$r*$r))); 
	  }
	  if ( $zr >= 0) { 
	      @@$c = ($w, $zi/(2 * $w) ); 
	  }
	  else { 
	      $c->[1] = ($zi >= 0) ? $w : -$w;
	      $c->[0] = $zi/(2.0* $c->[1]); 
	  }
        } 
        return $c;
      },

    qw("" stringify)
;

sub new {
    my $class = shift;
    my @@C = @@_;
    bless \@@C, $class;
d531 5
d537 4
a540 2
    my($x,$y) = @@{$_[0]};
    $x;
d543 5
d549 411
a959 2
    my($x,$y) = @@{$_[0]};
    $y;
d962 126
a1087 3
sub arg {
    my($x,$y) = @@{$_[0]};
    atan2($y,$x);
d1090 10
d1101 87
a1187 2
    my($x,$y) = @@{$_[0]};
    my($re,$im);
d1189 7
a1195 11
    $re = $x if ($x);
    if ($y == 1) {$im = 'i';}  
    elsif ($y == -1){$im = '-i';} 
    elsif ($y) {$im = "${y}i"; }

    local $_ = $re.'+'.$im;
    s/\+-/-/;
    s/^\+//;
    s/[\+-]$//;
    $_ = 0 if ($_ eq '');
    return $_;
d1203 1
a1203 1
Math::Complex - complex numbers package
d1207 5
a1211 2
  use Math::Complex;
  $i = new Math::Complex;
d1215 111
a1325 1
Complex numbers declared as
d1327 4
a1330 1
    $i = Math::Complex->new(1,1);
d1332 3
a1334 1
can be manipulated with overloaded math operators. The operators
d1336 2
a1337 1
  + - * / neg ~ abs cos sin exp sqrt
d1339 1
a1339 1
are supported as well as
d1341 1
a1341 1
  "" (stringify)
d1343 2
a1344 1
The methods
d1346 1
a1346 1
  Re Im arg
d1348 224
a1571 1
are also provided.
d1575 7
a1581 1
sqrt() should return two roots, but only returns one.
d1585 4
a1588 1
Dave Nadler, Tom Christiansen, Tim Bunce, Larry Wall.
d1591 2
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d1 1
a1 6
#
# Complex numbers and associated mathematical functions
# -- Raphael Manfredi	Since Sep 1996
# -- Jarkko Hietaniemi	Since Mar 1997
# -- Daniel S. Lewart	Since Sep 1997
#
a3 7
package Math::Complex;

use strict;

use vars qw($VERSION @@ISA @@EXPORT %EXPORT_TAGS);

my ( $i, $ip2, %logn );
d5 1
a5 1
$VERSION = sprintf("%s", q$Id: Complex.pm,v 1.26 1998/11/01 00:00:00 dsl Exp $ =~ /(\d+\.\d+)/);
d7 1
a7 25
@@ISA = qw(Exporter);

my @@trig = qw(
	      pi
	      tan
	      csc cosec sec cot cotan
	      asin acos atan
	      acsc acosec asec acot acotan
	      sinh cosh tanh
	      csch cosech sech coth cotanh
	      asinh acosh atanh
	      acsch acosech asech acoth acotanh
	     );

@@EXPORT = (qw(
	     i Re Im rho theta arg
	     sqrt log ln
	     log10 logn cbrt root
	     cplx cplxe
	     ),
	   @@trig);

%EXPORT_TAGS = (
    'trig' => [@@trig],
);
d10 79
a88 285
	'+'	=> \&plus,
	'-'	=> \&minus,
	'*'	=> \&multiply,
	'/'	=> \&divide,
	'**'	=> \&power,
	'<=>'	=> \&spaceship,
	'neg'	=> \&negate,
	'~'	=> \&conjugate,
	'abs'	=> \&abs,
	'sqrt'	=> \&sqrt,
	'exp'	=> \&exp,
	'log'	=> \&log,
	'sin'	=> \&sin,
	'cos'	=> \&cos,
	'tan'	=> \&tan,
	'atan2'	=> \&atan2,
	qw("" stringify);

#
# Package "privates"
#

my $package = 'Math::Complex';		# Package name
my $display = 'cartesian';		# Default display format
my $eps     = 1e-14;			# Epsilon

#
# Object attributes (internal):
#	cartesian	[real, imaginary] -- cartesian form
#	polar		[rho, theta] -- polar form
#	c_dirty		cartesian form not up-to-date
#	p_dirty		polar form not up-to-date
#	display		display format (package's global when not set)
#

# Die on bad *make() arguments.

sub _cannot_make {
    die "@@{[(caller(1))[3]]}: Cannot take $_[0] of $_[1].\n";
}

#
# ->make
#
# Create a new complex number (cartesian form)
#
sub make {
	my $self = bless {}, shift;
	my ($re, $im) = @@_;
	my $rre = ref $re;
	if ( $rre ) {
	    if ( $rre eq ref $self ) {
		$re = Re($re);
	    } else {
		_cannot_make("real part", $rre);
	    }
	}
	my $rim = ref $im;
	if ( $rim ) {
	    if ( $rim eq ref $self ) {
		$im = Im($im);
	    } else {
		_cannot_make("imaginary part", $rim);
	    }
	}
	$self->{'cartesian'} = [ $re, $im ];
	$self->{c_dirty} = 0;
	$self->{p_dirty} = 1;
	$self->display_format('cartesian');
	return $self;
}

#
# ->emake
#
# Create a new complex number (exponential form)
#
sub emake {
	my $self = bless {}, shift;
	my ($rho, $theta) = @@_;
	my $rrh = ref $rho;
	if ( $rrh ) {
	    if ( $rrh eq ref $self ) {
		$rho = rho($rho);
	    } else {
		_cannot_make("rho", $rrh);
	    }
	}
	my $rth = ref $theta;
	if ( $rth ) {
	    if ( $rth eq ref $self ) {
		$theta = theta($theta);
	    } else {
		_cannot_make("theta", $rth);
	    }
	}
	if ($rho < 0) {
	    $rho   = -$rho;
	    $theta = ($theta <= 0) ? $theta + pi() : $theta - pi();
	}
	$self->{'polar'} = [$rho, $theta];
	$self->{p_dirty} = 0;
	$self->{c_dirty} = 1;
	$self->display_format('polar');
	return $self;
}

sub new { &make }		# For backward compatibility only.

#
# cplx
#
# Creates a complex number from a (re, im) tuple.
# This avoids the burden of writing Math::Complex->make(re, im).
#
sub cplx {
	my ($re, $im) = @@_;
	return $package->make($re, defined $im ? $im : 0);
}

#
# cplxe
#
# Creates a complex number from a (rho, theta) tuple.
# This avoids the burden of writing Math::Complex->emake(rho, theta).
#
sub cplxe {
	my ($rho, $theta) = @@_;
	return $package->emake($rho, defined $theta ? $theta : 0);
}

#
# pi
#
# The number defined as pi = 180 degrees
#
use constant pi => 4 * CORE::atan2(1, 1);

#
# pit2
#
# The full circle
#
use constant pit2 => 2 * pi;

#
# pip2
#
# The quarter circle
#
use constant pip2 => pi / 2;

#
# deg1
#
# One degree in radians, used in stringify_polar.
#

use constant deg1 => pi / 180;

#
# uplog10
#
# Used in log10().
#
use constant uplog10 => 1 / CORE::log(10);

#
# i
#
# The number defined as i*i = -1;
#
sub i () {
        return $i if ($i);
	$i = bless {};
	$i->{'cartesian'} = [0, 1];
	$i->{'polar'}     = [1, pip2];
	$i->{c_dirty} = 0;
	$i->{p_dirty} = 0;
	return $i;
}

#
# Attribute access/set routines
#

sub cartesian {$_[0]->{c_dirty} ?
		   $_[0]->update_cartesian : $_[0]->{'cartesian'}}
sub polar     {$_[0]->{p_dirty} ?
		   $_[0]->update_polar : $_[0]->{'polar'}}

sub set_cartesian { $_[0]->{p_dirty}++; $_[0]->{'cartesian'} = $_[1] }
sub set_polar     { $_[0]->{c_dirty}++; $_[0]->{'polar'} = $_[1] }

#
# ->update_cartesian
#
# Recompute and return the cartesian form, given accurate polar form.
#
sub update_cartesian {
	my $self = shift;
	my ($r, $t) = @@{$self->{'polar'}};
	$self->{c_dirty} = 0;
	return $self->{'cartesian'} = [$r * CORE::cos($t), $r * CORE::sin($t)];
}

#
#
# ->update_polar
#
# Recompute and return the polar form, given accurate cartesian form.
#
sub update_polar {
	my $self = shift;
	my ($x, $y) = @@{$self->{'cartesian'}};
	$self->{p_dirty} = 0;
	return $self->{'polar'} = [0, 0] if $x == 0 && $y == 0;
	return $self->{'polar'} = [CORE::sqrt($x*$x + $y*$y), CORE::atan2($y, $x)];
}

#
# (plus)
#
# Computes z1+z2.
#
sub plus {
	my ($z1, $z2, $regular) = @@_;
	my ($re1, $im1) = @@{$z1->cartesian};
	$z2 = cplx($z2) unless ref $z2;
	my ($re2, $im2) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
	unless (defined $regular) {
		$z1->set_cartesian([$re1 + $re2, $im1 + $im2]);
		return $z1;
	}
	return (ref $z1)->make($re1 + $re2, $im1 + $im2);
}

#
# (minus)
#
# Computes z1-z2.
#
sub minus {
	my ($z1, $z2, $inverted) = @@_;
	my ($re1, $im1) = @@{$z1->cartesian};
	$z2 = cplx($z2) unless ref $z2;
	my ($re2, $im2) = @@{$z2->cartesian};
	unless (defined $inverted) {
		$z1->set_cartesian([$re1 - $re2, $im1 - $im2]);
		return $z1;
	}
	return $inverted ?
		(ref $z1)->make($re2 - $re1, $im2 - $im1) :
		(ref $z1)->make($re1 - $re2, $im1 - $im2);

}

#
# (multiply)
#
# Computes z1*z2.
#
sub multiply {
        my ($z1, $z2, $regular) = @@_;
	if ($z1->{p_dirty} == 0 and ref $z2 and $z2->{p_dirty} == 0) {
	    # if both polar better use polar to avoid rounding errors
	    my ($r1, $t1) = @@{$z1->polar};
	    my ($r2, $t2) = @@{$z2->polar};
	    my $t = $t1 + $t2;
	    if    ($t >   pi()) { $t -= pit2 }
	    elsif ($t <= -pi()) { $t += pit2 }
	    unless (defined $regular) {
		$z1->set_polar([$r1 * $r2, $t]);
		return $z1;
	    }
	    return (ref $z1)->emake($r1 * $r2, $t);
	} else {
	    my ($x1, $y1) = @@{$z1->cartesian};
	    if (ref $z2) {
		my ($x2, $y2) = @@{$z2->cartesian};
		return (ref $z1)->make($x1*$x2-$y1*$y2, $x1*$y2+$y1*$x2);
	    } else {
		return (ref $z1)->make($x1*$z2, $y1*$z2);
	    }
	}
a90 269
#
# _divbyzero
#
# Die on division by zero.
#
sub _divbyzero {
    my $mess = "$_[0]: Division by zero.\n";

    if (defined $_[1]) {
	$mess .= "(Because in the definition of $_[0], the divisor ";
	$mess .= "$_[1] " unless ($_[1] eq '0');
	$mess .= "is 0)\n";
    }

    my @@up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# (divide)
#
# Computes z1/z2.
#
sub divide {
	my ($z1, $z2, $inverted) = @@_;
	if ($z1->{p_dirty} == 0 and ref $z2 and $z2->{p_dirty} == 0) {
	    # if both polar better use polar to avoid rounding errors
	    my ($r1, $t1) = @@{$z1->polar};
	    my ($r2, $t2) = @@{$z2->polar};
	    my $t;
	    if ($inverted) {
		_divbyzero "$z2/0" if ($r1 == 0);
		$t = $t2 - $t1;
		if    ($t >   pi()) { $t -= pit2 }
		elsif ($t <= -pi()) { $t += pit2 }
		return (ref $z1)->emake($r2 / $r1, $t);
	    } else {
		_divbyzero "$z1/0" if ($r2 == 0);
		$t = $t1 - $t2;
		if    ($t >   pi()) { $t -= pit2 }
		elsif ($t <= -pi()) { $t += pit2 }
		return (ref $z1)->emake($r1 / $r2, $t);
	    }
	} else {
	    my ($d, $x2, $y2);
	    if ($inverted) {
		($x2, $y2) = @@{$z1->cartesian};
		$d = $x2*$x2 + $y2*$y2;
		_divbyzero "$z2/0" if $d == 0;
		return (ref $z1)->make(($x2*$z2)/$d, -($y2*$z2)/$d);
	    } else {
		my ($x1, $y1) = @@{$z1->cartesian};
		if (ref $z2) {
		    ($x2, $y2) = @@{$z2->cartesian};
		    $d = $x2*$x2 + $y2*$y2;
		    _divbyzero "$z1/0" if $d == 0;
		    my $u = ($x1*$x2 + $y1*$y2)/$d;
		    my $v = ($y1*$x2 - $x1*$y2)/$d;
		    return (ref $z1)->make($u, $v);
		} else {
		    _divbyzero "$z1/0" if $z2 == 0;
		    return (ref $z1)->make($x1/$z2, $y1/$z2);
		}
	    }
	}
}

#
# (power)
#
# Computes z1**z2 = exp(z2 * log z1)).
#
sub power {
	my ($z1, $z2, $inverted) = @@_;
	if ($inverted) {
	    return 1 if $z1 == 0 || $z2 == 1;
	    return 0 if $z2 == 0 && Re($z1) > 0;
	} else {
	    return 1 if $z2 == 0 || $z1 == 1;
	    return 0 if $z1 == 0 && Re($z2) > 0;
	}
	my $w = $inverted ? CORE::exp($z1 * CORE::log($z2))
	                  : CORE::exp($z2 * CORE::log($z1));
	# If both arguments cartesian, return cartesian, else polar.
	return $z1->{c_dirty} == 0 &&
	       (not ref $z2 or $z2->{c_dirty} == 0) ?
	       cplx(@@{$w->cartesian}) : $w;
}

#
# (spaceship)
#
# Computes z1 <=> z2.
# Sorts on the real part first, then on the imaginary part. Thus 2-4i < 3+8i.
#
sub spaceship {
	my ($z1, $z2, $inverted) = @@_;
	my ($re1, $im1) = ref $z1 ? @@{$z1->cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
	my $sgn = $inverted ? -1 : 1;
	return $sgn * ($re1 <=> $re2) if $re1 != $re2;
	return $sgn * ($im1 <=> $im2);
}

#
# (negate)
#
# Computes -z.
#
sub negate {
	my ($z) = @@_;
	if ($z->{c_dirty}) {
		my ($r, $t) = @@{$z->polar};
		$t = ($t <= 0) ? $t + pi : $t - pi;
		return (ref $z)->emake($r, $t);
	}
	my ($re, $im) = @@{$z->cartesian};
	return (ref $z)->make(-$re, -$im);
}

#
# (conjugate)
#
# Compute complex's conjugate.
#
sub conjugate {
	my ($z) = @@_;
	if ($z->{c_dirty}) {
		my ($r, $t) = @@{$z->polar};
		return (ref $z)->emake($r, -$t);
	}
	my ($re, $im) = @@{$z->cartesian};
	return (ref $z)->make($re, -$im);
}

#
# (abs)
#
# Compute or set complex's norm (rho).
#
sub abs {
	my ($z, $rho) = @@_;
	return $z unless ref $z;
	if (defined $rho) {
	    $z->{'polar'} = [ $rho, ${$z->polar}[1] ];
	    $z->{p_dirty} = 0;
	    $z->{c_dirty} = 1;
	    return $rho;
	} else {
	    return ${$z->polar}[0];
	}
}

sub _theta {
    my $theta = $_[0];

    if    ($$theta >   pi()) { $$theta -= pit2 }
    elsif ($$theta <= -pi()) { $$theta += pit2 }
}

#
# arg
#
# Compute or set complex's argument (theta).
#
sub arg {
	my ($z, $theta) = @@_;
	return $z unless ref $z;
	if (defined $theta) {
	    _theta(\$theta);
	    $z->{'polar'} = [ ${$z->polar}[0], $theta ];
	    $z->{p_dirty} = 0;
	    $z->{c_dirty} = 1;
	} else {
	    $theta = ${$z->polar}[1];
	    _theta(\$theta);
	}
	return $theta;
}

#
# (sqrt)
#
# Compute sqrt(z).
#
# It is quite tempting to use wantarray here so that in list context
# sqrt() would return the two solutions.  This, however, would
# break things like
#
#	print "sqrt(z) = ", sqrt($z), "\n";
#
# The two values would be printed side by side without no intervening
# whitespace, quite confusing.
# Therefore if you want the two solutions use the root().
#
sub sqrt {
	my ($z) = @@_;
	my ($re, $im) = ref $z ? @@{$z->cartesian} : ($z, 0);
	return $re < 0 ? cplx(0, CORE::sqrt(-$re)) : CORE::sqrt($re) if $im == 0;
	my ($r, $t) = @@{$z->polar};
	return (ref $z)->emake(CORE::sqrt($r), $t/2);
}

#
# cbrt
#
# Compute cbrt(z) (cubic root).
#
# Why are we not returning three values?  The same answer as for sqrt().
#
sub cbrt {
	my ($z) = @@_;
	return $z < 0 ? -CORE::exp(CORE::log(-$z)/3) : ($z > 0 ? CORE::exp(CORE::log($z)/3): 0)
	    unless ref $z;
	my ($r, $t) = @@{$z->polar};
	return (ref $z)->emake(CORE::exp(CORE::log($r)/3), $t/3);
}

#
# _rootbad
#
# Die on bad root.
#
sub _rootbad {
    my $mess = "Root $_[0] not defined, root must be positive integer.\n";

    my @@up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# root
#
# Computes all nth root for z, returning an array whose size is n.
# `n' must be a positive integer.
#
# The roots are given by (for k = 0..n-1):
#
# z^(1/n) = r^(1/n) (cos ((t+2 k pi)/n) + i sin ((t+2 k pi)/n))
#
sub root {
	my ($z, $n) = @@_;
	_rootbad($n) if ($n < 1 or int($n) != $n);
	my ($r, $t) = ref $z ? @@{$z->polar} : (CORE::abs($z), $z >= 0 ? 0 : pi);
	my @@root;
	my $k;
	my $theta_inc = pit2 / $n;
	my $rho = $r ** (1/$n);
	my $theta;
	my $cartesian = ref $z && $z->{c_dirty} == 0;
	for ($k = 0, $theta = $t / $n; $k < $n; $k++, $theta += $theta_inc) {
	    my $w = cplxe($rho, $theta);
	    # Yes, $cartesian is loop invariant.
	    push @@root, $cartesian ? cplx(@@{$w->cartesian}) : $w;
	}
	return @@root;
}

#
# Re
#
# Return or set Re(z).
#
d92 2
a93 9
	my ($z, $Re) = @@_;
	return $z unless ref $z;
	if (defined $Re) {
	    $z->{'cartesian'} = [ $Re, ${$z->cartesian}[1] ];
	    $z->{c_dirty} = 0;
	    $z->{p_dirty} = 1;
	} else {
	    return ${$z->cartesian}[0];
	}
a95 5
#
# Im
#
# Return or set Im(z).
#
d97 2
a98 9
	my ($z, $Im) = @@_;
	return $z unless ref $z;
	if (defined $Im) {
	    $z->{'cartesian'} = [ ${$z->cartesian}[0], $Im ];
	    $z->{c_dirty} = 0;
	    $z->{p_dirty} = 1;
	} else {
	    return ${$z->cartesian}[1];
	}
d101 3
a103 451
#
# rho
#
# Return or set rho(w).
#
sub rho {
    Math::Complex::abs(@@_);
}

#
# theta
#
# Return or set theta(w).
#
sub theta {
    Math::Complex::arg(@@_);
}

#
# (exp)
#
# Computes exp(z).
#
sub exp {
	my ($z) = @@_;
	my ($x, $y) = @@{$z->cartesian};
	return (ref $z)->emake(CORE::exp($x), $y);
}

#
# _logofzero
#
# Die on logarithm of zero.
#
sub _logofzero {
    my $mess = "$_[0]: Logarithm of zero.\n";

    if (defined $_[1]) {
	$mess .= "(Because in the definition of $_[0], the argument ";
	$mess .= "$_[1] " unless ($_[1] eq '0');
	$mess .= "is 0)\n";
    }

    my @@up = caller(1);

    $mess .= "Died at $up[1] line $up[2].\n";

    die $mess;
}

#
# (log)
#
# Compute log(z).
#
sub log {
	my ($z) = @@_;
	unless (ref $z) {
	    _logofzero("log") if $z == 0;
	    return $z > 0 ? CORE::log($z) : cplx(CORE::log(-$z), pi);
	}
	my ($r, $t) = @@{$z->polar};
	_logofzero("log") if $r == 0;
	if    ($t >   pi()) { $t -= pit2 }
	elsif ($t <= -pi()) { $t += pit2 }
	return (ref $z)->make(CORE::log($r), $t);
}

#
# ln
#
# Alias for log().
#
sub ln { Math::Complex::log(@@_) }

#
# log10
#
# Compute log10(z).
#

sub log10 {
	return Math::Complex::log($_[0]) * uplog10;
}

#
# logn
#
# Compute logn(z,n) = log(z) / log(n)
#
sub logn {
	my ($z, $n) = @@_;
	$z = cplx($z, 0) unless ref $z;
	my $logn = $logn{$n};
	$logn = $logn{$n} = CORE::log($n) unless defined $logn;	# Cache log(n)
	return CORE::log($z) / $logn;
}

#
# (cos)
#
# Compute cos(z) = (exp(iz) + exp(-iz))/2.
#
sub cos {
	my ($z) = @@_;
	my ($x, $y) = @@{$z->cartesian};
	my $ey = CORE::exp($y);
	my $ey_1 = 1 / $ey;
	return (ref $z)->make(CORE::cos($x) * ($ey + $ey_1)/2,
			      CORE::sin($x) * ($ey_1 - $ey)/2);
}

#
# (sin)
#
# Compute sin(z) = (exp(iz) - exp(-iz))/2.
#
sub sin {
	my ($z) = @@_;
	my ($x, $y) = @@{$z->cartesian};
	my $ey = CORE::exp($y);
	my $ey_1 = 1 / $ey;
	return (ref $z)->make(CORE::sin($x) * ($ey + $ey_1)/2,
			      CORE::cos($x) * ($ey - $ey_1)/2);
}

#
# tan
#
# Compute tan(z) = sin(z) / cos(z).
#
sub tan {
	my ($z) = @@_;
	my $cz = CORE::cos($z);
	_divbyzero "tan($z)", "cos($z)" if (CORE::abs($cz) < $eps);
	return CORE::sin($z) / $cz;
}

#
# sec
#
# Computes the secant sec(z) = 1 / cos(z).
#
sub sec {
	my ($z) = @@_;
	my $cz = CORE::cos($z);
	_divbyzero "sec($z)", "cos($z)" if ($cz == 0);
	return 1 / $cz;
}

#
# csc
#
# Computes the cosecant csc(z) = 1 / sin(z).
#
sub csc {
	my ($z) = @@_;
	my $sz = CORE::sin($z);
	_divbyzero "csc($z)", "sin($z)" if ($sz == 0);
	return 1 / $sz;
}

#
# cosec
#
# Alias for csc().
#
sub cosec { Math::Complex::csc(@@_) }

#
# cot
#
# Computes cot(z) = cos(z) / sin(z).
#
sub cot {
	my ($z) = @@_;
	my $sz = CORE::sin($z);
	_divbyzero "cot($z)", "sin($z)" if ($sz == 0);
	return CORE::cos($z) / $sz;
}

#
# cotan
#
# Alias for cot().
#
sub cotan { Math::Complex::cot(@@_) }

#
# acos
#
# Computes the arc cosine acos(z) = -i log(z + sqrt(z*z-1)).
#
sub acos {
	my $z = $_[0];
	return CORE::atan2(CORE::sqrt(1-$z*$z), $z) if (! ref $z) && CORE::abs($z) <= 1;
	my ($x, $y) = ref $z ? @@{$z->cartesian} : ($z, 0);
	my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
	my $alpha = ($t1 + $t2)/2;
	my $beta  = ($t1 - $t2)/2;
	$alpha = 1 if $alpha < 1;
	if    ($beta >  1) { $beta =  1 }
	elsif ($beta < -1) { $beta = -1 }
	my $u = CORE::atan2(CORE::sqrt(1-$beta*$beta), $beta);
	my $v = CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
	$v = -$v if $y > 0 || ($y == 0 && $x < -1);
	return $package->make($u, $v);
}

#
# asin
#
# Computes the arc sine asin(z) = -i log(iz + sqrt(1-z*z)).
#
sub asin {
	my $z = $_[0];
	return CORE::atan2($z, CORE::sqrt(1-$z*$z)) if (! ref $z) && CORE::abs($z) <= 1;
	my ($x, $y) = ref $z ? @@{$z->cartesian} : ($z, 0);
	my $t1 = CORE::sqrt(($x+1)*($x+1) + $y*$y);
	my $t2 = CORE::sqrt(($x-1)*($x-1) + $y*$y);
	my $alpha = ($t1 + $t2)/2;
	my $beta  = ($t1 - $t2)/2;
	$alpha = 1 if $alpha < 1;
	if    ($beta >  1) { $beta =  1 }
	elsif ($beta < -1) { $beta = -1 }
	my $u =  CORE::atan2($beta, CORE::sqrt(1-$beta*$beta));
	my $v = -CORE::log($alpha + CORE::sqrt($alpha*$alpha-1));
	$v = -$v if $y > 0 || ($y == 0 && $x < -1);
	return $package->make($u, $v);
}

#
# atan
#
# Computes the arc tangent atan(z) = i/2 log((i+z) / (i-z)).
#
sub atan {
	my ($z) = @@_;
	return CORE::atan2($z, 1) unless ref $z;
	_divbyzero "atan(i)"  if ( $z == i);
	_divbyzero "atan(-i)" if (-$z == i);
	my $log = CORE::log((i + $z) / (i - $z));
	$ip2 = 0.5 * i unless defined $ip2;
	return $ip2 * $log;
}

#
# asec
#
# Computes the arc secant asec(z) = acos(1 / z).
#
sub asec {
	my ($z) = @@_;
	_divbyzero "asec($z)", $z if ($z == 0);
	return acos(1 / $z);
}

#
# acsc
#
# Computes the arc cosecant acsc(z) = asin(1 / z).
#
sub acsc {
	my ($z) = @@_;
	_divbyzero "acsc($z)", $z if ($z == 0);
	return asin(1 / $z);
}

#
# acosec
#
# Alias for acsc().
#
sub acosec { Math::Complex::acsc(@@_) }

#
# acot
#
# Computes the arc cotangent acot(z) = atan(1 / z)
#
sub acot {
	my ($z) = @@_;
	_divbyzero "acot(0)"  if (CORE::abs($z)     < $eps);
	return ($z >= 0) ? CORE::atan2(1, $z) : CORE::atan2(-1, -$z) unless ref $z;
	_divbyzero "acot(i)"  if (CORE::abs($z - i) < $eps);
	_logofzero "acot(-i)" if (CORE::abs($z + i) < $eps);
	return atan(1 / $z);
}

#
# acotan
#
# Alias for acot().
#
sub acotan { Math::Complex::acot(@@_) }

#
# cosh
#
# Computes the hyperbolic cosine cosh(z) = (exp(z) + exp(-z))/2.
#
sub cosh {
	my ($z) = @@_;
	my $ex;
	unless (ref $z) {
	    $ex = CORE::exp($z);
	    return ($ex + 1/$ex)/2;
	}
	my ($x, $y) = @@{$z->cartesian};
	$ex = CORE::exp($x);
	my $ex_1 = 1 / $ex;
	return (ref $z)->make(CORE::cos($y) * ($ex + $ex_1)/2,
			      CORE::sin($y) * ($ex - $ex_1)/2);
}

#
# sinh
#
# Computes the hyperbolic sine sinh(z) = (exp(z) - exp(-z))/2.
#
sub sinh {
	my ($z) = @@_;
	my $ex;
	unless (ref $z) {
	    $ex = CORE::exp($z);
	    return ($ex - 1/$ex)/2;
	}
	my ($x, $y) = @@{$z->cartesian};
	$ex = CORE::exp($x);
	my $ex_1 = 1 / $ex;
	return (ref $z)->make(CORE::cos($y) * ($ex - $ex_1)/2,
			      CORE::sin($y) * ($ex + $ex_1)/2);
}

#
# tanh
#
# Computes the hyperbolic tangent tanh(z) = sinh(z) / cosh(z).
#
sub tanh {
	my ($z) = @@_;
	my $cz = cosh($z);
	_divbyzero "tanh($z)", "cosh($z)" if ($cz == 0);
	return sinh($z) / $cz;
}

#
# sech
#
# Computes the hyperbolic secant sech(z) = 1 / cosh(z).
#
sub sech {
	my ($z) = @@_;
	my $cz = cosh($z);
	_divbyzero "sech($z)", "cosh($z)" if ($cz == 0);
	return 1 / $cz;
}

#
# csch
#
# Computes the hyperbolic cosecant csch(z) = 1 / sinh(z).
#
sub csch {
	my ($z) = @@_;
	my $sz = sinh($z);
	_divbyzero "csch($z)", "sinh($z)" if ($sz == 0);
	return 1 / $sz;
}

#
# cosech
#
# Alias for csch().
#
sub cosech { Math::Complex::csch(@@_) }

#
# coth
#
# Computes the hyperbolic cotangent coth(z) = cosh(z) / sinh(z).
#
sub coth {
	my ($z) = @@_;
	my $sz = sinh($z);
	_divbyzero "coth($z)", "sinh($z)" if ($sz == 0);
	return cosh($z) / $sz;
}

#
# cotanh
#
# Alias for coth().
#
sub cotanh { Math::Complex::coth(@@_) }

#
# acosh
#
# Computes the arc hyperbolic cosine acosh(z) = log(z + sqrt(z*z-1)).
#
sub acosh {
	my ($z) = @@_;
	unless (ref $z) {
	    return CORE::log($z + CORE::sqrt($z*$z-1)) if $z >= 1;
	    $z = cplx($z, 0);
	}
	my ($re, $im) = @@{$z->cartesian};
	if ($im == 0) {
	    return cplx(CORE::log($re + CORE::sqrt($re*$re - 1)), 0) if $re >= 1;
	    return cplx(0, CORE::atan2(CORE::sqrt(1-$re*$re), $re)) if CORE::abs($re) <= 1;
	}
	return CORE::log($z + CORE::sqrt($z*$z - 1));
}

#
# asinh
#
# Computes the arc hyperbolic sine asinh(z) = log(z + sqrt(z*z-1))
#
sub asinh {
	my ($z) = @@_;
	return CORE::log($z + CORE::sqrt($z*$z + 1));
}

#
# atanh
#
# Computes the arc hyperbolic tangent atanh(z) = 1/2 log((1+z) / (1-z)).
#
sub atanh {
	my ($z) = @@_;
	unless (ref $z) {
	    return CORE::log((1 + $z)/(1 - $z))/2 if CORE::abs($z) < 1;
	    $z = cplx($z, 0);
	}
	_divbyzero 'atanh(1)',  "1 - $z" if ($z ==  1);
	_logofzero 'atanh(-1)'           if ($z == -1);
	return 0.5 * CORE::log((1 + $z) / (1 - $z));
}

#
# asech
#
# Computes the hyperbolic arc secant asech(z) = acosh(1 / z).
#
sub asech {
	my ($z) = @@_;
	_divbyzero 'asech(0)', $z if ($z == 0);
	return acosh(1 / $z);
a105 112
#
# acsch
#
# Computes the hyperbolic arc cosecant acsch(z) = asinh(1 / z).
#
sub acsch {
	my ($z) = @@_;
	_divbyzero 'acsch(0)', $z if ($z == 0);
	return asinh(1 / $z);
}

#
# acosech
#
# Alias for acosh().
#
sub acosech { Math::Complex::acsch(@@_) }

#
# acoth
#
# Computes the arc hyperbolic cotangent acoth(z) = 1/2 log((1+z) / (z-1)).
#
sub acoth {
	my ($z) = @@_;
	_divbyzero 'acoth(0)'            if (CORE::abs($z)     < $eps);
	unless (ref $z) {
	    return CORE::log(($z + 1)/($z - 1))/2 if CORE::abs($z) > 1;
	    $z = cplx($z, 0);
	}
	_divbyzero 'acoth(1)',  "$z - 1" if (CORE::abs($z - 1) < $eps);
	_logofzero 'acoth(-1)', "1 / $z" if (CORE::abs($z + 1) < $eps);
	return CORE::log((1 + $z) / ($z - 1)) / 2;
}

#
# acotanh
#
# Alias for acot().
#
sub acotanh { Math::Complex::acoth(@@_) }

#
# (atan2)
#
# Compute atan(z1/z2).
#
sub atan2 {
	my ($z1, $z2, $inverted) = @@_;
	my ($re1, $im1, $re2, $im2);
	if ($inverted) {
	    ($re1, $im1) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
	    ($re2, $im2) = @@{$z1->cartesian};
	} else {
	    ($re1, $im1) = @@{$z1->cartesian};
	    ($re2, $im2) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
	}
	if ($im2 == 0) {
	    return cplx(CORE::atan2($re1, $re2), 0) if $im1 == 0;
	    return cplx(($im1<=>0) * pip2, 0) if $re2 == 0;
	}
	my $w = atan($z1/$z2);
	my ($u, $v) = ref $w ? @@{$w->cartesian} : ($w, 0);
	$u += pi   if $re2 < 0;
	$u -= pit2 if $u > pi;
	return cplx($u, $v);
}

#
# display_format
# ->display_format
#
# Set (fetch if no argument) display format for all complex numbers that
# don't happen to have overridden it via ->display_format
#
# When called as a method, this actually sets the display format for
# the current object.
#
# Valid object formats are 'c' and 'p' for cartesian and polar. The first
# letter is used actually, so the type can be fully spelled out for clarity.
#
sub display_format {
	my $self = shift;
	my $format = undef;

	if (ref $self) {			# Called as a method
		$format = shift;
	} else {				# Regular procedure call
		$format = $self;
		undef $self;
	}

	if (defined $self) {
		return defined $self->{display} ? $self->{display} : $display
			unless defined $format;
		return $self->{display} = $format;
	}

	return $display unless defined $format;
	return $display = $format;
}

#
# (stringify)
#
# Show nicely formatted complex number under its cartesian or polar form,
# depending on the current display format:
#
# . If a specific display format has been recorded for this object, use it.
# . Otherwise, use the generic current default for all complex numbers,
#   which is a package global variable.
#
d107 2
a108 37
	my ($z) = shift;
	my $format;

	$format = $display;
	$format = $z->{display} if defined $z->{display};

	return $z->stringify_polar if $format =~ /^p/i;
	return $z->stringify_cartesian;
}

#
# ->stringify_cartesian
#
# Stringify as a cartesian representation 'a+bi'.
#
sub stringify_cartesian {
	my $z  = shift;
	my ($x, $y) = @@{$z->cartesian};
	my ($re, $im);

	$x = int($x + ($x < 0 ? -1 : 1) * $eps)
		if int(CORE::abs($x)) != int(CORE::abs($x) + $eps);
	$y = int($y + ($y < 0 ? -1 : 1) * $eps)
		if int(CORE::abs($y)) != int(CORE::abs($y) + $eps);

	$re = "$x" if CORE::abs($x) >= $eps;
        if ($y == 1)                           { $im = 'i' }
        elsif ($y == -1)                       { $im = '-i' }
        elsif (CORE::abs($y) >= $eps)                { $im = $y . "i" }

	my $str = '';
	$str = $re if defined $re;
	$str .= "+$im" if defined $im;
	$str =~ s/\+-/-/;
	$str =~ s/^\+//;
	$str =~ s/([-+])1i/$1i/; # Not redundant with the above 1/-1 tests.
	$str = '0' unless $str;
d110 11
a120 97
	return $str;
}


# Helper for stringify_polar, a Greatest Common Divisor with a memory.

sub _gcd {
    my ($a, $b) = @@_;

    use integer;

    # Loops forever if given negative inputs.

    if    ($b and $a > $b) { return gcd($a % $b, $b) }
    elsif ($a and $b > $a) { return gcd($b % $a, $a) }
    else                   { return $a ? $a : $b     }
}

my %gcd;

sub gcd {
    my ($a, $b) = @@_;

    my $id = "$a $b";

    unless (exists $gcd{$id}) {
	$gcd{$id} = _gcd($a, $b);
	$gcd{"$b $a"} = $gcd{$id};
    }

    return $gcd{$id};
}

#
# ->stringify_polar
#
# Stringify as a polar representation '[r,t]'.
#
sub stringify_polar {
	my $z  = shift;
	my ($r, $t) = @@{$z->polar};
	my $theta;

	return '[0,0]' if $r <= $eps;

	my $nt = $t / pit2;
	$nt = ($nt - int($nt)) * pit2;
	$nt += pit2 if $nt < 0;			# Range [0, 2pi]

	if (CORE::abs($nt) <= $eps)		{ $theta = 0 }
	elsif (CORE::abs(pi-$nt) <= $eps)	{ $theta = 'pi' }

	if (defined $theta) {
		$r = int($r + ($r < 0 ? -1 : 1) * $eps)
			if int(CORE::abs($r)) != int(CORE::abs($r) + $eps);
		$theta = int($theta + ($theta < 0 ? -1 : 1) * $eps)
			if ($theta ne 'pi' and
			    int(CORE::abs($theta)) != int(CORE::abs($theta) + $eps));
		return "\[$r,$theta\]";
	}

	#
	# Okay, number is not a real. Try to identify pi/n and friends...
	#

	$nt -= pit2 if $nt > pi;

	if (CORE::abs($nt) >= deg1) {
	    my ($n, $k, $kpi);

	    for ($k = 1, $kpi = pi; $k < 10; $k++, $kpi += pi) {
		$n = int($kpi / $nt + ($nt > 0 ? 1 : -1) * 0.5);
		if (CORE::abs($kpi/$n - $nt) <= $eps) {
		    $n = CORE::abs($n);
		    my $gcd = gcd($k, $n);
		    if ($gcd > 1) {
			$k /= $gcd;
			$n /= $gcd;
		    }
		    next if $n > 360;
		    $theta = ($nt < 0 ? '-':'').
			     ($k == 1 ? 'pi':"${k}pi");
		    $theta .= '/'.$n if $n > 1;
		    last;
		}
	    }
	}

	$theta = $nt unless defined $theta;

	$r = int($r + ($r < 0 ? -1 : 1) * $eps)
		if int(CORE::abs($r)) != int(CORE::abs($r) + $eps);
	$theta = int($theta + ($theta < 0 ? -1 : 1) * $eps)
		if ($theta !~ m(^-?\d*pi/\d+$) and
		    int(CORE::abs($theta)) != int(CORE::abs($theta) + $eps));

	return "\[$r,$theta\]";
d128 1
a128 1
Math::Complex - complex numbers and associated mathematical functions
d132 2
a133 5
	use Math::Complex;

	$z = Math::Complex->make(5, 6);
	$t = 4 - 3*i + $z;
	$j = cplxe(1, 2*pi/3);
d137 1
a137 113
This package lets you create and manipulate complex numbers. By default,
I<Perl> limits itself to real numbers, but an extra C<use> statement brings
full complex support, along with a full set of mathematical functions
typically associated with and/or extended to complex numbers.

If you wonder what complex numbers are, they were invented to be able to solve
the following equation:

	x*x = -1

and by definition, the solution is noted I<i> (engineers use I<j> instead since
I<i> usually denotes an intensity, but the name does not matter). The number
I<i> is a pure I<imaginary> number.

The arithmetics with pure imaginary numbers works just like you would expect
it with real numbers... you just have to remember that

	i*i = -1

so you have:

	5i + 7i = i * (5 + 7) = 12i
	4i - 3i = i * (4 - 3) = i
	4i * 2i = -8
	6i / 2i = 3
	1 / i = -i

Complex numbers are numbers that have both a real part and an imaginary
part, and are usually noted:

	a + bi

where C<a> is the I<real> part and C<b> is the I<imaginary> part. The
arithmetic with complex numbers is straightforward. You have to
keep track of the real and the imaginary parts, but otherwise the
rules used for real numbers just apply:

	(4 + 3i) + (5 - 2i) = (4 + 5) + i(3 - 2) = 9 + i
	(2 + i) * (4 - i) = 2*4 + 4i -2i -i*i = 8 + 2i + 1 = 9 + 2i

A graphical representation of complex numbers is possible in a plane
(also called the I<complex plane>, but it's really a 2D plane).
The number

	z = a + bi

is the point whose coordinates are (a, b). Actually, it would
be the vector originating from (0, 0) to (a, b). It follows that the addition
of two complex numbers is a vectorial addition.

Since there is a bijection between a point in the 2D plane and a complex
number (i.e. the mapping is unique and reciprocal), a complex number
can also be uniquely identified with polar coordinates:

	[rho, theta]

where C<rho> is the distance to the origin, and C<theta> the angle between
the vector and the I<x> axis. There is a notation for this using the
exponential form, which is:

	rho * exp(i * theta)

where I<i> is the famous imaginary number introduced above. Conversion
between this form and the cartesian form C<a + bi> is immediate:

	a = rho * cos(theta)
	b = rho * sin(theta)

which is also expressed by this formula:

	z = rho * exp(i * theta) = rho * (cos theta + i * sin theta)

In other words, it's the projection of the vector onto the I<x> and I<y>
axes. Mathematicians call I<rho> the I<norm> or I<modulus> and I<theta>
the I<argument> of the complex number. The I<norm> of C<z> will be
noted C<abs(z)>.

The polar notation (also known as the trigonometric
representation) is much more handy for performing multiplications and
divisions of complex numbers, whilst the cartesian notation is better
suited for additions and subtractions. Real numbers are on the I<x>
axis, and therefore I<theta> is zero or I<pi>.

All the common operations that can be performed on a real number have
been defined to work on complex numbers as well, and are merely
I<extensions> of the operations defined on real numbers. This means
they keep their natural meaning when there is no imaginary part, provided
the number is within their definition set.

For instance, the C<sqrt> routine which computes the square root of
its argument is only defined for non-negative real numbers and yields a
non-negative real number (it is an application from B<R+> to B<R+>).
If we allow it to return a complex number, then it can be extended to
negative real numbers to become an application from B<R> to B<C> (the
set of complex numbers):

	sqrt(x) = x >= 0 ? sqrt(x) : sqrt(-x)*i

It can also be extended to be an application from B<C> to B<C>,
whilst its restriction to B<R> behaves as defined above by using
the following definition:

	sqrt(z = [r,t]) = sqrt(r) * exp(i * t/2)

Indeed, a negative real number can be noted C<[x,pi]> (the modulus
I<x> is always non-negative, so C<[x,pi]> is really C<-x>, a negative
number) and the above definition states that

	sqrt([x,pi]) = sqrt(x) * exp(i*pi/2) = [sqrt(x),pi/2] = sqrt(x)*i

which is exactly what we had defined for negative real numbers above.
The C<sqrt> returns only one of the solutions: if you want the both,
use the C<root> function.
d139 1
a139 4
All the common mathematical functions defined on real numbers that
are extended to complex numbers share that same property of working
I<as usual> when the imaginary part is zero (otherwise, it would not
be called an extension, would it?).
d141 1
a141 3
A I<new> operation possible on a complex number that is
the identity for real numbers is called the I<conjugate>, and is noted
with an horizontal bar above the number, or C<~z> here.
d143 1
a143 2
	 z = a + bi
	~z = a - bi
d145 1
a145 1
Simple... Now look:
d147 1
a147 1
	z * ~z = (a + bi) * (a - bi) = a*a + b*b
d149 1
a149 2
We saw that the norm of C<z> was noted C<abs(z)> and was defined as the
distance to the origin, also known as:
d151 1
a151 1
	rho = abs(z) = sqrt(a*a + b*b)
d153 1
a153 245
so

	z * ~z = abs(z) ** 2

If z is a pure real number (i.e. C<b == 0>), then the above yields:

	a * a = abs(a) ** 2

which is true (C<abs> has the regular meaning for real number, i.e. stands
for the absolute value). This example explains why the norm of C<z> is
noted C<abs(z)>: it extends the C<abs> function to complex numbers, yet
is the regular C<abs> we know when the complex number actually has no
imaginary part... This justifies I<a posteriori> our use of the C<abs>
notation for the norm.

=head1 OPERATIONS

Given the following notations:

	z1 = a + bi = r1 * exp(i * t1)
	z2 = c + di = r2 * exp(i * t2)
	z = <any complex or real number>

the following (overloaded) operations are supported on complex numbers:

	z1 + z2 = (a + c) + i(b + d)
	z1 - z2 = (a - c) + i(b - d)
	z1 * z2 = (r1 * r2) * exp(i * (t1 + t2))
	z1 / z2 = (r1 / r2) * exp(i * (t1 - t2))
	z1 ** z2 = exp(z2 * log z1)
	~z = a - bi
	abs(z) = r1 = sqrt(a*a + b*b)
	sqrt(z) = sqrt(r1) * exp(i * t/2)
	exp(z) = exp(a) * exp(i * b)
	log(z) = log(r1) + i*t
	sin(z) = 1/2i (exp(i * z1) - exp(-i * z))
	cos(z) = 1/2 (exp(i * z1) + exp(-i * z))
	atan2(z1, z2) = atan(z1/z2)

The following extra operations are supported on both real and complex
numbers:

	Re(z) = a
	Im(z) = b
	arg(z) = t
	abs(z) = r

	cbrt(z) = z ** (1/3)
	log10(z) = log(z) / log(10)
	logn(z, n) = log(z) / log(n)

	tan(z) = sin(z) / cos(z)

	csc(z) = 1 / sin(z)
	sec(z) = 1 / cos(z)
	cot(z) = 1 / tan(z)

	asin(z) = -i * log(i*z + sqrt(1-z*z))
	acos(z) = -i * log(z + i*sqrt(1-z*z))
	atan(z) = i/2 * log((i+z) / (i-z))

	acsc(z) = asin(1 / z)
	asec(z) = acos(1 / z)
	acot(z) = atan(1 / z) = -i/2 * log((i+z) / (z-i))

	sinh(z) = 1/2 (exp(z) - exp(-z))
	cosh(z) = 1/2 (exp(z) + exp(-z))
	tanh(z) = sinh(z) / cosh(z) = (exp(z) - exp(-z)) / (exp(z) + exp(-z))

	csch(z) = 1 / sinh(z)
	sech(z) = 1 / cosh(z)
	coth(z) = 1 / tanh(z)

	asinh(z) = log(z + sqrt(z*z+1))
	acosh(z) = log(z + sqrt(z*z-1))
	atanh(z) = 1/2 * log((1+z) / (1-z))

	acsch(z) = asinh(1 / z)
	asech(z) = acosh(1 / z)
	acoth(z) = atanh(1 / z) = 1/2 * log((1+z) / (z-1))

I<arg>, I<abs>, I<log>, I<csc>, I<cot>, I<acsc>, I<acot>, I<csch>,
I<coth>, I<acosech>, I<acotanh>, have aliases I<rho>, I<theta>, I<ln>,
I<cosec>, I<cotan>, I<acosec>, I<acotan>, I<cosech>, I<cotanh>,
I<acosech>, I<acotanh>, respectively.  C<Re>, C<Im>, C<arg>, C<abs>,
C<rho>, and C<theta> can be used also also mutators.  The C<cbrt>
returns only one of the solutions: if you want all three, use the
C<root> function.

The I<root> function is available to compute all the I<n>
roots of some complex, where I<n> is a strictly positive integer.
There are exactly I<n> such roots, returned as a list. Getting the
number mathematicians call C<j> such that:

	1 + j + j*j = 0;

is a simple matter of writing:

	$j = ((root(1, 3))[1];

The I<k>th root for C<z = [r,t]> is given by:

	(root(z, n))[k] = r**(1/n) * exp(i * (t + 2*k*pi)/n)

The I<spaceship> comparison operator, E<lt>=E<gt>, is also defined. In
order to ensure its restriction to real numbers is conform to what you
would expect, the comparison is run on the real part of the complex
number first, and imaginary parts are compared only when the real
parts match.

=head1 CREATION

To create a complex number, use either:

	$z = Math::Complex->make(3, 4);
	$z = cplx(3, 4);

if you know the cartesian form of the number, or

	$z = 3 + 4*i;

if you like. To create a number using the polar form, use either:

	$z = Math::Complex->emake(5, pi/3);
	$x = cplxe(5, pi/3);

instead. The first argument is the modulus, the second is the angle
(in radians, the full circle is 2*pi).  (Mnemonic: C<e> is used as a
notation for complex numbers in the polar form).

It is possible to write:

	$x = cplxe(-3, pi/4);

but that will be silently converted into C<[3,-3pi/4]>, since the modulus
must be non-negative (it represents the distance to the origin in the complex
plane).

It is also possible to have a complex number as either argument of
either the C<make> or C<emake>: the appropriate component of
the argument will be used.

	$z1 = cplx(-2,  1);
	$z2 = cplx($z1, 4);

=head1 STRINGIFICATION

When printed, a complex number is usually shown under its cartesian
form I<a+bi>, but there are legitimate cases where the polar format
I<[r,t]> is more appropriate.

By calling the routine C<Math::Complex::display_format> and supplying either
C<"polar"> or C<"cartesian">, you override the default display format,
which is C<"cartesian">. Not supplying any argument returns the current
setting.

This default can be overridden on a per-number basis by calling the
C<display_format> method instead. As before, not supplying any argument
returns the current display format for this number. Otherwise whatever you
specify will be the new display format for I<this> particular number.

For instance:

	use Math::Complex;

	Math::Complex::display_format('polar');
	$j = ((root(1, 3))[1];
	print "j = $j\n";		# Prints "j = [1,2pi/3]
	$j->display_format('cartesian');
	print "j = $j\n";		# Prints "j = -0.5+0.866025403784439i"

The polar format attempts to emphasize arguments like I<k*pi/n>
(where I<n> is a positive integer and I<k> an integer within [-9,+9]).

=head1 USAGE

Thanks to overloading, the handling of arithmetics with complex numbers
is simple and almost transparent.

Here are some examples:

	use Math::Complex;

	$j = cplxe(1, 2*pi/3);	# $j ** 3 == 1
	print "j = $j, j**3 = ", $j ** 3, "\n";
	print "1 + j + j**2 = ", 1 + $j + $j**2, "\n";

	$z = -16 + 0*i;			# Force it to be a complex
	print "sqrt($z) = ", sqrt($z), "\n";

	$k = exp(i * 2*pi/3);
	print "$j - $k = ", $j - $k, "\n";

	$z->Re(3);			# Re, Im, arg, abs,
	$j->arg(2);			# (the last two aka rho, theta)
					# can be used also as mutators.

=head1 ERRORS DUE TO DIVISION BY ZERO OR LOGARITHM OF ZERO

The division (/) and the following functions

	log	ln	log10	logn
	tan	sec	csc	cot
	atan	asec	acsc	acot
	tanh	sech	csch	coth
	atanh	asech	acsch	acoth

cannot be computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause fatal
runtime errors looking like this

	cot(0): Division by zero.
	(Because in the definition of cot(0), the divisor sin(0) is 0)
	Died at ...

or

	atanh(-1): Logarithm of zero.
	Died at...

For the C<csc>, C<cot>, C<asec>, C<acsc>, C<acot>, C<csch>, C<coth>,
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the the
logarithmic functions and the C<atanh>, C<acoth>, the argument cannot
be C<1> (one).  For the C<atanh>, C<acoth>, the argument cannot be
C<-1> (minus one).  For the C<atan>, C<acot>, the argument cannot be
C<i> (the imaginary unit).  For the C<atan>, C<acoth>, the argument
cannot be C<-i> (the negative imaginary unit).  For the C<tan>,
C<sec>, C<tanh>, the argument cannot be I<pi/2 + k * pi>, where I<k>
is any integer.

Note that because we are operating on approximations of real numbers,
these errors can happen when merely `too close' to the singularities
listed above.  For example C<tan(2*atan2(1,1)+1e-15)> will die of
division by zero.

=head1 ERRORS DUE TO INDIGESTIBLE ARGUMENTS

The C<make> and C<emake> accept both real and complex arguments.
When they cannot recognize the arguments they will die with error
messages like the following

    Math::Complex::make: Cannot take real part of ...
    Math::Complex::make: Cannot take real part of ...
    Math::Complex::emake: Cannot take rho of ...
    Math::Complex::emake: Cannot take theta of ...
d157 1
a157 12
Saying C<use Math::Complex;> exports many mathematical routines in the
caller environment and even overrides some (C<sqrt>, C<log>).
This is construed as a feature by the Authors, actually... ;-)

All routines expect to be given real or complex numbers. Don't attempt to
use BigFloat, since Perl has currently no rule to disambiguate a '+'
operation (for instance) between two overloaded entities.

In Cray UNICOS there is some strange numerical instability that results
in root(), cos(), sin(), cosh(), sinh(), losing accuracy fast.  Beware.
The bug may be in UNICOS math libs, in UNICOS C compiler, in Math::Complex.
Whatever it is, it does not manifest itself anywhere else where Perl runs.
d161 1
a161 4
Raphael Manfredi <F<Raphael_Manfredi@@grenoble.hp.com>> and
Jarkko Hietaniemi <F<jhi@@iki.fi>>.

Extensive patches by Daniel S. Lewart <F<d-lewart@@uiuc.edu>>.
a163 4

1;

# eof
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a10 1
use 5.005_64;
d13 1
a13 1
our($VERSION, @@ISA, @@EXPORT, %EXPORT_TAGS);
d68 3
a70 4
my $package        = 'Math::Complex';	# Package name
my %DISPLAY_FORMAT = ('style' => 'cartesian',
		      'polar_pretty_print' => 1);
my $eps            = 1e-14;		# Epsilon
d163 1
a163 1
	return __PACKAGE__->make($re, defined $im ? $im : 0);
d174 1
a174 1
	return __PACKAGE__->emake($rho, defined $theta ? $theta : 0);
d182 1
a182 1
sub pi () { 4 * CORE::atan2(1, 1) }
d189 1
a189 1
sub pit2 () { 2 * pi }
d196 1
a196 1
sub pip2 () { pi / 2 }
d204 1
a204 1
sub deg1 () { pi / 180 }
d211 1
a211 1
sub uplog10 () { 1 / CORE::log(10) }
d838 1
a838 1
	return __PACKAGE__->make($u, $v);
d860 1
a860 1
	return __PACKAGE__->make($u, $v);
d1156 1
a1156 1
# Set (get if no argument) the display format for all complex numbers that
d1159 1
a1159 1
# When called as an object method, this actually sets the display format for
d1166 2
a1167 2
	my $self  = shift;
	my %display_format = %DISPLAY_FORMAT;
d1169 5
a1173 19
	if (ref $self) {			# Called as an object method
	    if (exists $self->{display_format}) {
		my %obj = %{$self->{display_format}};
		@@display_format{keys %obj} = values %obj;
	    }
	    if (@@_ == 1) {
		$display_format{style} = shift;
	    } else {
		my %new = @@_;
		@@display_format{keys %new} = values %new;
	    }
	} else {				# Called as a class method
	    if (@@_ = 1) {
		$display_format{style} = $self;
	    } else {
		my %new = @@_;
		@@display_format{keys %new} = values %new;
	    }
	    undef $self;
d1177 3
a1179 5
	    $self->{display_format} = { %display_format };
	    return
		wantarray ?
		    %{$self->{display_format}} :
		    $self->{display_format}->{style};
d1182 2
a1183 5
	%DISPLAY_FORMAT = %display_format;
	return
	    wantarray ?
		%DISPLAY_FORMAT :
		    $DISPLAY_FORMAT{style};
d1198 1
d1200 2
a1201 1
	my $style = $z->display_format;
d1203 1
a1203 3
	$style = $DISPLAY_FORMAT{style} unless defined $style;

	return $z->stringify_polar if $style =~ /^p/i;
d1223 3
a1225 9

	my %format = $z->display_format;
	my $format = $format{format};

	if ($y == 1)			       { $im = 'i' }
	elsif ($y == -1)		       { $im = '-i' }
	elsif (CORE::abs($y) >= $eps) {
	    $im = (defined $format ? sprintf($format, $y) : $y) . "i";
	}
d1228 6
a1233 10
	$str = defined $format ? sprintf($format, $re) : $re
	    if defined $re;
	if (defined $im) {
	    if ($y < 0) {
		$str .= $im;
	    } elsif ($y > 0)  {
		$str .= "+" if defined $re;
		$str .= $im;
	    }
	}
a1279 2
	my %format = $z->display_format;

d1302 1
a1302 1
	if ($format{polar_pretty_print} && CORE::abs($nt) >= deg1) {
a1330 6
	my $format = $format{format};
        if (defined $format) {
	    $r     = sprintf($format, $r);
	    $theta = sprintf($format, $theta);
	}

a1336 1
=pod
d1620 3
a1622 3
but that will be silently converted into C<[3,-3pi/4]>, since the
modulus must be non-negative (it represents the distance to the origin
in the complex plane).
d1634 1
a1634 1
style I<a+bi>, but there are legitimate cases where the polar style
d1637 4
a1640 4
By calling the class method C<Math::Complex::display_format> and
supplying either C<"polar"> or C<"cartesian"> as an argument, you
override the default display style, which is C<"cartesian">. Not
supplying any argument returns the current settings.
d1644 2
a1645 2
returns the current display style for this number. Otherwise whatever you
specify will be the new display style for I<this> particular number.
d1652 2
a1653 2
	$j = (root(1, 3))[1];
	print "j = $j\n";		# Prints "j = [1,2pi/3]"
d1657 2
a1658 38
The polar style attempts to emphasize arguments like I<k*pi/n>
(where I<n> is a positive integer and I<k> an integer within [-9,+9]),
this is called I<polar pretty-printing>.

=head2 CHANGED IN PERL 5.6

The C<display_format> class method and the corresponding
C<display_format> object method can now be called using
a parameter hash instead of just a one parameter.

The old display format style, which can have values C<"cartesian"> or
C<"polar">, can be changed using the C<"style"> parameter.  (The one
parameter calling convention also still works.)

There are two new display parameters.

The first one is C<"format">, which is a sprintf()-style format
string to be used for both parts of the complex number(s).  The
default is C<undef>, which corresponds usually (this is somewhat
system-dependent) to C<"%.15g">.  You can revert to the default by
setting the format string to C<undef>.

	# the $j from the above example

	$j->display_format('format' => '%.5f');
	print "j = $j\n";		# Prints "j = -0.50000+0.86603i"
	$j->display_format('format' => '%.6f');
	print "j = $j\n";		# Prints "j = -0.5+0.86603i"

Notice that this affects also the return values of the
C<display_format> methods: in list context the whole parameter hash
will be returned, as opposed to only the style parameter value.  If
you want to know the whole truth for a complex number, you must call
both the class method and the object method:

The second new display parameter is C<"polar_pretty_print">, which can
be set to true or false, the default being true.  See the previous
section for what this means.
d1749 1
a1749 1
Raphael Manfredi <F<Raphael_Manfredi@@pobox.com>> and
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d8 1
d11 2
a12 1
our($VERSION, @@ISA, @@EXPORT, %EXPORT_TAGS, $Inf);
d14 1
a14 1
$VERSION = 1.31;
d16 1
a16 20
BEGIN {
    unless ($^O eq 'unicosmk') {
        my $e = $!;
	# We do want an arithmetic overflow, Inf INF inf Infinity:.
        undef $Inf unless eval <<'EOE' and $Inf =~ /^inf(?:inity)?$/i;
	  local $SIG{FPE} = sub {die};
	  my $t = CORE::exp 30;
	  $Inf = CORE::exp $t;
EOE
	if (!defined $Inf) {		# Try a different method
	  undef $Inf unless eval <<'EOE' and $Inf =~ /^inf(?:inity)?$/i;
	    local $SIG{FPE} = sub {die};
	    my $t = 1;
	    $Inf = $t + "1e99999999999999999999999999999999";
EOE
	}
        $! = $e; # Clear ERANGE.
    }
    $Inf = "Inf" if !defined $Inf || !($Inf > 0); # Desperation.
}
d18 1
a18 6
use strict;

my $i;
my %LOGN;

require Exporter;
a51 1
	'=='	=> \&numeq,
d69 1
a230 7
# ip2
#
# Half of i.
#
sub ip2 () { i / 2 }

#
d265 1
a265 2
	return $self->{'polar'} = [CORE::sqrt($x*$x + $y*$y),
				   CORE::atan2($y, $x)];
d345 1
a345 1
	$mess .= "$_[1] " unless ("$_[1]" eq '0');
d419 2
a420 2
	my $w = $inverted ? &exp($z1 * &log($z2))
	                  : &exp($z2 * &log($z1));
a442 13
# (numeq)
#
# Computes z1 == z2.
#
# (Required in addition to spaceship() because of NaNs.)
sub numeq {
	my ($z1, $z2, $inverted) = @@_;
	my ($re1, $im1) = ref $z1 ? @@{$z1->cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @@{$z2->cartesian} : ($z2, 0);
	return $re1 == $re2 && $im1 == $im2 ? 1 : 0;
}

#
d480 1
a480 7
	unless (ref $z) {
	    if (@@_ == 2) {
		$_[0] = $_[1];
	    } else {
		return CORE::abs($z);
	    }
	}
d536 1
a536 2
	return $re < 0 ? cplx(0, CORE::sqrt(-$re)) : CORE::sqrt($re)
	    if $im == 0;
d550 1
a550 3
	return $z < 0 ?
	    -CORE::exp(CORE::log(-$z)/3) :
		($z > 0 ? CORE::exp(CORE::log($z)/3): 0)
a552 1
	return 0 if $r == 0;
d562 1
a562 1
    my $mess = "Root $_[0] illegal, root rank must be positive integer.\n";
d584 1
a584 2
	my ($r, $t) = ref $z ?
	    @@{$z->polar} : (CORE::abs($z), $z >= 0 ? 0 : pi);
d623 1
a623 1
	return 0 unless ref $z;
d726 3
a728 3
	my $logn = $LOGN{$n};
	$logn = $LOGN{$n} = CORE::log($n) unless defined $logn;	# Cache log(n)
	return &log($z) / $logn;
a737 1
	return CORE::cos($z) unless ref $z;
d740 3
a742 5
	my $sx = CORE::sin($x);
	my $cx = CORE::cos($x);
	my $ey_1 = $ey ? 1 / $ey : $Inf;
	return (ref $z)->make($cx * ($ey + $ey_1)/2,
			      $sx * ($ey_1 - $ey)/2);
a751 1
	return CORE::sin($z) unless ref $z;
d754 3
a756 5
	my $sx = CORE::sin($x);
	my $cx = CORE::cos($x);
	my $ey_1 = $ey ? 1 / $ey : $Inf;
	return (ref $z)->make($sx * ($ey + $ey_1)/2,
			      $cx * ($ey - $ey_1)/2);
d766 3
a768 3
	my $cz = &cos($z);
	_divbyzero "tan($z)", "cos($z)" if $cz == 0;
	return &sin($z) / $cz;
d778 1
a778 1
	my $cz = &cos($z);
d790 1
a790 1
	my $sz = &sin($z);
d809 1
a809 1
	my $sz = &sin($z);
d811 1
a811 1
	return &cos($z) / $sz;
d828 2
a829 5
	return CORE::atan2(CORE::sqrt(1-$z*$z), $z)
	    if (! ref $z) && CORE::abs($z) <= 1;
	$z = cplx($z, 0) unless ref $z;
	my ($x, $y) = @@{$z->cartesian};
	return 0 if $x == 1 && $y == 0;
d840 1
a840 1
	return (ref $z)->make($u, $v);
d850 2
a851 5
	return CORE::atan2($z, CORE::sqrt(1-$z*$z))
	    if (! ref $z) && CORE::abs($z) <= 1;
	$z = cplx($z, 0) unless ref $z;
	my ($x, $y) = @@{$z->cartesian};
	return 0 if $x == 0 && $y == 0;
d862 1
a862 1
	return (ref $z)->make($u, $v);
a872 2
	my ($x, $y) = ref $z ? @@{$z->cartesian} : ($z, 0);
	return 0 if $x == 0 && $y == 0;
d874 4
a877 3
	_logofzero "atan(-i)" if (-$z == i); # -i is a bad file test...
	my $log = &log((i + $z) / (i - $z));
	return ip2 * $log;
d916 4
a919 5
	_divbyzero "acot(0)"  if $z == 0;
	return ($z >= 0) ? CORE::atan2(1, $z) : CORE::atan2(-1, -$z)
	    unless ref $z;
	_divbyzero "acot(i)"  if ($z - i == 0);
	_logofzero "acot(-i)" if ($z + i == 0);
d940 1
a940 1
	    return $ex ? ($ex + 1/$ex)/2 : $Inf;
d944 1
a944 1
	my $ex_1 = $ex ? 1 / $ex : $Inf;
a957 1
	    return 0 if $z == 0;
d959 1
a959 1
	    return $ex ? ($ex - 1/$ex)/2 : "-$Inf";
a961 2
	my $cy = CORE::cos($y);
	my $sy = CORE::sin($y);
d963 1
a963 1
	my $ex_1 = $ex ? 1 / $ex : $Inf;
d1019 1
a1019 1
	_divbyzero "coth($z)", "sinh($z)" if $sz == 0;
d1038 1
d1043 4
a1046 14
	    return CORE::log($re + CORE::sqrt($re*$re - 1))
		if $re >= 1;
	    return cplx(0, CORE::atan2(CORE::sqrt(1 - $re*$re), $re))
		if CORE::abs($re) < 1;
	}
	my $t = &sqrt($z * $z - 1) + $z;
	# Try Taylor if looking bad (this usually means that
	# $z was large negative, therefore the sqrt is really
	# close to abs(z), summing that with z...)
	$t = 1/(2 * $z) - 1/(8 * $z**3) + 1/(16 * $z**5) - 5/(128 * $z**7)
	    if $t == 0;
	my $u = &log($t);
	$u->Im(-$u->Im) if $re < 0 && $im == 0;
	return $re < 0 ? -$u : $u;
d1052 1
a1052 1
# Computes the arc hyperbolic sine asinh(z) = log(z + sqrt(z*z+1))
d1056 1
a1056 11
	unless (ref $z) {
	    my $t = $z + CORE::sqrt($z*$z + 1);
	    return CORE::log($t) if $t;
	}
	my $t = &sqrt($z * $z + 1) + $z;
	# Try Taylor if looking bad (this usually means that
	# $z was large negative, therefore the sqrt is really
	# close to abs(z), summing that with z...)
	$t = 1/(2 * $z) - 1/(8 * $z**3) + 1/(16 * $z**5) - 5/(128 * $z**7)
	    if $t == 0;
	return &log($t);
d1070 3
a1072 3
	_divbyzero 'atanh(1)',  "1 - $z" if (1 - $z == 0);
	_logofzero 'atanh(-1)'           if (1 + $z == 0);
	return 0.5 * &log((1 + $z) / (1 - $z));
d1082 1
a1082 1
	_divbyzero 'asech(0)', "$z" if ($z == 0);
d1111 1
a1111 1
	_divbyzero 'acoth(0)'            if ($z == 0);
d1116 3
a1118 3
	_divbyzero 'acoth(1)',  "$z - 1" if ($z - 1 == 0);
	_logofzero 'acoth(-1)', "1 + $z" if (1 + $z == 0);
	return &log((1 + $z) / ($z - 1)) / 2;
d1144 2
a1145 2
	    return CORE::atan2($re1, $re2) if $im1 == 0;
	    return ($im1<=>0) * pip2 if $re2 == 0;
d1176 14
a1189 6
	}
	if (@@_ == 1) {
	    $display_format{style} = shift;
	} else {
	    my %new = @@_;
	    @@display_format{keys %new} = values %new;
d1192 1
a1192 1
	if (ref $self) { # Called as an object method
a1199 1
        # Called as a class method
d1238 7
d1248 4
a1251 30
	if ($x) {
	    if ($x =~ /^NaN[QS]?$/i) {
		$re = $x;
	    } else {
		if ($x =~ /^-?$Inf$/oi) {
		    $re = $x;
		} else {
		    $re = defined $format ? sprintf($format, $x) : $x;
		}
	    }
	} else {
	    undef $re;
	}

	if ($y) {
	    if ($y =~ /^(NaN[QS]?)$/i) {
		$im = $y;
	    } else {
		if ($y =~ /^-?$Inf$/oi) {
		    $im = $y;
		} else {
		    $im =
			defined $format ?
			    sprintf($format, $y) :
			    ($y == 1 ? "" : ($y == -1 ? "-" : $y));
		}
	    }
	    $im .= "i";
	} else {
	    undef $im;
d1254 3
a1256 2
	my $str = $re;

d1260 1
a1260 1
	    } elsif ($y > 0 || $im =~ /^NaN[QS]?i$/i)  {
a1263 2
	} elsif (!defined $re) {
	    $str = "0";
d1270 29
d1309 2
a1311 1
	my $format = $format{format};
d1313 14
a1326 6
	if ($t =~ /^NaN[QS]?$/i || $t =~ /^-?$Inf$/oi) {
	    $theta = $t; 
	} elsif ($t == pi) {
	    $theta = "pi";
	} elsif ($r == 0 || $t == 0) {
	    $theta = defined $format ? sprintf($format, $t) : $t;
a1328 2
	return "[$r,$theta]" if defined $theta;

d1330 1
a1330 1
	# Try to identify pi/n and friends.
d1333 4
a1336 1
	$t -= int(CORE::abs($t) / pit2) * pit2;
d1338 13
a1350 7
	if ($format{polar_pretty_print} && $t) {
	    my ($a, $b);
	    for $a (2..9) {
		$b = $t * $a / pi;
		if ($b =~ /^-?\d+$/) {
		    $b = $b < 0 ? "-" : "" if CORE::abs($b) == 1;
		    $theta = "${b}pi/$a";
d1356 9
d1367 1
a1367 3
	    $theta = sprintf($format, $theta) unless defined $theta;
	} else {
	    $theta = $t unless defined $theta;
d1370 1
a1370 1
	return "[$r,$theta]";
a1376 1

d1698 1
a1698 1
(where I<n> is a positive integer and I<k> an integer within [-9, +9]),
d1708 2
a1709 7
C<"polar">, can be changed using the C<"style"> parameter.

	$j->display_format(style => "polar");

The one parameter calling convention also still works.

	$j->display_format("polar");
d1713 5
a1717 4
The first one is C<"format">, which is a sprintf()-style format string
to be used for both numeric parts of the complex number(s).  The is
somewhat system-dependent but most often it corresponds to C<"%.15g">.
You can revert to the default by setting the C<format> to C<undef>.
d1723 1
a1723 1
	$j->display_format('format' => undef);
d1728 3
a1730 3
will be returned, as opposed to only the style parameter value.
This is a potential incompatibility with earlier versions if you
have been calling the C<display_format> method in list context.
d1794 2
a1795 1
listed above.
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d12 1
a12 1
$VERSION = 1.34;
a39 3
# Regular expression for floating point numbers.
my $gre = qr'\s*([\+\-]?(?:(?:(?:\d+(?:_\d+)*(?:\.\d*(?:_\d+)*)?|\.\d+(?:_\d+)*)(?:[eE][\+\-]?\d+(?:_\d+)*)?)))';

a110 20
sub _remake {
    my $arg = shift;
    my ($made, $p, $q);

    if ($arg =~ /^(?:$gre)?$gre\s*i\s*$/) {
	($p, $q) = ($1 || 0, $2);
	$made = 'cart';
    } elsif ($arg =~ /^\s*\[\s*$gre\s*(?:,\s*$gre\s*)?\]\s*$/) {
	($p, $q) = ($1, $2 || 0);
	$made = 'exp';
    }

    if ($made) {
	$p =~ s/^\+//;
	$q =~ s/^\+//;
    }

    return ($made, $p, $q);
}

a118 10
	if (@@_ == 1) {
	    my ($remade, $p, $q) = _remake($re);
	    if ($remade) {
		if ($remade eq 'cart') {
		    ($re, $im) = ($p, $q);
		} else {
		    return (ref $self)->emake($p, $q);
		}
	    }
	}
a134 3
	_cannot_make("real part",      $re) unless $re =~ /^$gre$/;
	$im ||= 0;
	_cannot_make("imaginary part", $im) unless $im =~ /^$gre$/;
a149 10
	if (@@_ == 1) {
	    my ($remade, $p, $q) = _remake($rho);
	    if ($remade) {
		if ($remade eq 'exp') {
		    ($rho, $theta) = ($p, $q);
		} else {
		    return (ref $self)->make($p, $q);
		}
	    }
	}
a169 3
	_cannot_make("rho",   $rho)   unless $rho   =~ /^$gre$/;
	$theta ||= 0;
	_cannot_make("theta", $theta) unless $theta =~ /^$gre$/;
d186 2
a187 1
	return __PACKAGE__->make(@@_);
d197 2
a198 1
	return __PACKAGE__->emake(@@_);
d1564 1
a1564 1
with a horizontal bar above the number, or C<~z> here.
d1663 1
a1663 1
C<rho>, and C<theta> can be used also as mutators.  The C<cbrt>
d1716 2
a1717 2
It is also possible to have a complex number as either argument of the
C<make>, C<emake>, C<cplx>, and C<cplxe>: the appropriate component of
a1722 12
The C<new>, C<make>, C<emake>, C<cplx>, and C<cplxe> will also
understand a single (string) argument of the forms

    	2-3i
    	-3i
	[2,3]
	[2]

in which case the appropriate cartesian and exponential components
will be parsed from the string and used to create new complex numbers.
The imaginary component and the theta, respectively, will default to zero.

d1839 1
a1839 1
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the
d1880 2
a1881 1
Daniel S. Lewart <F<d-lewart@@uiuc.edu>>
d1883 1
a1883 2
Original authors Raphael Manfredi <F<Raphael_Manfredi@@pobox.com>> and
Jarkko Hietaniemi <F<jhi@@iki.fi>>
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d10 1
a10 1
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS $Inf);
d12 1
a12 1
$VERSION = 1.35;
d41 1
a41 2
# These days we could use Scalar::Util::lln(), I guess.
my $gre = qr'\s*([\+\-]?(?:(?:(?:\d+(?:_\d+)*(?:\.\d*(?:_\d+)*)?|\.\d+(?:_\d+)*)(?:[eE][\+\-]?\d+(?:_\d+)*)?))|inf)'i;
a63 1
	     atan2
a66 2
@@EXPORT_OK = qw(decplx);

d111 1
a111 1
    die "@@{[(caller(1))[3]]}: Cannot take $_[0] of '$_[1]'.\n";
d114 1
a114 1
sub _make {
d116 1
a116 1
    my ($p, $q);
d118 1
a118 3
    if ($arg =~ /^$gre$/) {
	($p, $q) = ($1, 0);
    } elsif ($arg =~ /^(?:$gre)?$gre\s*i\s*$/) {
d120 2
a121 19
    } elsif ($arg =~ /^\s*\(\s*$gre\s*(?:,\s*$gre\s*)?\)\s*$/) {
	($p, $q) = ($1, $2 || 0);
    }

    if (defined $p) {
	$p =~ s/^\+//;
	$p =~ s/^(-?)inf$/"${1}9**9**9"/e;
	$q =~ s/^\+//;
	$q =~ s/^(-?)inf$/"${1}9**9**9"/e;
    }

    return ($p, $q);
}

sub _emake {
    my $arg = shift;
    my ($p, $q);

    if ($arg =~ /^\s*\[\s*$gre\s*(?:,\s*$gre\s*)?\]\s*$/) {
d123 1
a123 6
    } elsif ($arg =~ m!^\s*\[\s*$gre\s*(?:,\s*([-+]?\d*\s*)?pi(?:/\s*(\d+))?\s*)?\]\s*$!) {
	($p, $q) = ($1, ($2 eq '-' ? -1 : ($2 || 1)) * pi() / ($3 || 1));
    } elsif ($arg =~ /^\s*\[\s*$gre\s*\]\s*$/) {
	($p, $q) = ($1, 0);
    } elsif ($arg =~ /^\s*$gre\s*$/) {
	($p, $q) = ($1, 0);
d126 1
a126 1
    if (defined $p) {
a128 2
	$p =~ s/^(-?)inf$/"${1}9**9**9"/e;
	$q =~ s/^(-?)inf$/"${1}9**9**9"/e;
d131 1
a131 1
    return ($p, $q);
d140 28
a167 12
    my $self = bless {}, shift;
    my ($re, $im);
    if (@@_ == 0) {
	($re, $im) = (0, 0);
    } elsif (@@_ == 1) {
	return (ref $self)->emake($_[0])
	    if ($_[0] =~ /^\s*\[/);
	($re, $im) = _make($_[0]);
    } elsif (@@_ == 2) {
	($re, $im) = @@_;
    }
    if (defined $re) {
d169 7
a175 7
    }
    $im ||= 0;
    _cannot_make("imaginary part", $im) unless $im =~ /^$gre$/;
    $self->set_cartesian([$re, $im ]);
    $self->display_format('cartesian');

    return $self;
d184 28
a211 12
    my $self = bless {}, shift;
    my ($rho, $theta);
    if (@@_ == 0) {
	($rho, $theta) = (0, 0);
    } elsif (@@_ == 1) {
	return (ref $self)->make($_[0])
	    if ($_[0] =~ /^\s*\(/ || $_[0] =~ /i\s*$/);
	($rho, $theta) = _emake($_[0]);
    } elsif (@@_ == 2) {
	($rho, $theta) = @@_;
    }
    if (defined $rho && defined $theta) {
a215 2
    }
    if (defined $rho) {
d217 7
a223 7
    }
    $theta ||= 0;
    _cannot_make("theta", $theta) unless $theta =~ /^$gre$/;
    $self->set_polar([$rho, $theta]);
    $self->display_format('polar');

    return $self;
d315 2
a316 4
sub set_cartesian { $_[0]->{p_dirty}++; $_[0]->{c_dirty} = 0;
		    $_[0]->{'cartesian'} = $_[1] }
sub set_polar     { $_[0]->{c_dirty}++; $_[0]->{p_dirty} = 0;
		    $_[0]->{'polar'} = $_[1] }
d662 1
a662 1
    my $mess = "Root '$_[0]' illegal, root rank must be positive integer.\n";
d682 1
a682 1
	my ($z, $n, $k) = @@_;
d686 2
d690 1
d692 4
a695 13
	if (@@_ == 2) {
	    my @@root;
	    for (my $i = 0, my $theta = $t / $n;
		 $i < $n;
		 $i++, $theta += $theta_inc) {
		my $w = cplxe($rho, $theta);
		# Yes, $cartesian is loop invariant.
		push @@root, $cartesian ? cplx(@@{$w->cartesian}) : $w;
	    }
	    return @@root;
	} elsif (@@_ == 3) {
	    my $w = cplxe($rho, $t / $n + $k * $theta_inc);
	    return $cartesian ? cplx(@@{$w->cartesian}) : $w;
d697 1
d1268 1
a1268 1
# Compute atan(z1/z2), minding the right quadrant.
d1275 1
a1275 1
	    ($re2, $im2) = ref $z1 ? @@{$z1->cartesian} : ($z1, 0);
d1277 1
a1277 1
	    ($re1, $im1) = ref $z1 ? @@{$z1->cartesian} : ($z1, 0);
d1280 9
a1288 12
	if ($im1 || $im2) {
	    # In MATLAB the imaginary parts are ignored.
	    # warn "atan2: Imaginary parts ignored";
	    # http://documents.wolfram.com/mathematica/functions/ArcTan
	    # NOTE: Mathematica ArcTan[x,y] while atan2(y,x)
	    my $s = $z1 * $z1 + $z2 * $z2;
	    _divbyzero("atan2") if $s == 0;
	    my $i = &i;
	    my $r = $z2 + $z1 * $i;
	    return -$i * &log($r / &sqrt( $s ));
	}
	return CORE::atan2($re1, $re2);
d1662 1
a1662 5
	atan2(y, x) = atan(y / x) # Minding the right quadrant, note the order.

The definition used for complex arguments of atan2() is

       -i log((x + iy)/sqrt(x*x+y*y))
a1728 3
You can return the I<k>th root directly by C<root(z, n, k)>,
indexing starting from I<zero> and ending at I<n - 1>.

a1775 1
	[2,-3pi/4]
d1782 1
a1782 4
The C<new>, C<make>, C<emake>, C<cplx>, and C<cplxe> will also
understand the case of no arguments: this means plain zero or (0, 0).

=head1 DISPLAYING
d1786 1
a1786 2
I<[r,t]> is more appropriate.  The process of converting the complex
number into a string that can be displayed is known as I<stringification>.
a1811 2
For the reverse of stringifying, see the C<make> and C<emake>.

d1905 1
a1905 2
is any integer.  atan2(0, 0) is undefined, and if the complex arguments
are used for atan2(), a division by zero will happen if z1**2+z2**2 == 0.
d1925 1
a1925 1
caller environment and even overrides some (C<sqrt>, C<log>, C<atan2>).
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d12 1
a12 1
$VERSION = 1.37;
d16 1
a16 1
        local $!;
d30 1
d69 1
a69 3
my @@pi = qw(pi pi2 pi4 pip2 pip4);

@@EXPORT_OK = @@pi;
a72 1
    'pi' => [@@pi],
d76 9
a84 9
	'+'	=> \&_plus,
	'-'	=> \&_minus,
	'*'	=> \&_multiply,
	'/'	=> \&_divide,
	'**'	=> \&_power,
	'=='	=> \&_numeq,
	'<=>'	=> \&_spaceship,
	'neg'	=> \&_negate,
	'~'	=> \&_conjugate,
d93 1
a93 1
        '""'    => \&_stringify;
a109 2
#	bn_cartesian
#       bnc_dirty
d186 1
a186 1
    $self->_set_cartesian([$re, $im ]);
d220 1
a220 1
    $self->_set_polar([$rho, $theta]);
d256 1
a256 1
# pi2
d260 1
a260 8
sub pi2 () { 2 * pi }

#
# pi4
#
# The full circle twice.
#
sub pi4 () { 4 * pi }
d270 1
a270 1
# pip4
d272 1
a272 1
# The eighth circle.
d274 2
a275 1
sub pip4 () { pi / 4 }
d278 1
a278 1
# _uplog10
d282 1
a282 1
sub _uplog10 () { 1 / CORE::log(10) }
d300 1
a300 1
# _ip2
d304 1
a304 1
sub _ip2 () { i / 2 }
d310 9
a318 9
sub _cartesian {$_[0]->{c_dirty} ?
		   $_[0]->_update_cartesian : $_[0]->{'cartesian'}}
sub _polar     {$_[0]->{p_dirty} ?
		   $_[0]->_update_polar : $_[0]->{'polar'}}

sub _set_cartesian { $_[0]->{p_dirty}++; $_[0]->{c_dirty} = 0;
		     $_[0]->{'cartesian'} = $_[1] }
sub _set_polar     { $_[0]->{c_dirty}++; $_[0]->{p_dirty} = 0;
		     $_[0]->{'polar'} = $_[1] }
d321 1
a321 1
# ->_update_cartesian
d325 1
a325 1
sub _update_cartesian {
d334 1
a334 1
# ->_update_polar
d338 1
a338 1
sub _update_polar {
d348 1
a348 1
# (_plus)
d352 1
a352 1
sub _plus {
d354 1
a354 1
	my ($re1, $im1) = @@{$z1->_cartesian};
d356 1
a356 1
	my ($re2, $im2) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
d358 1
a358 1
		$z1->_set_cartesian([$re1 + $re2, $im1 + $im2]);
d365 1
a365 1
# (_minus)
d369 1
a369 1
sub _minus {
d371 1
a371 1
	my ($re1, $im1) = @@{$z1->_cartesian};
d373 1
a373 1
	my ($re2, $im2) = @@{$z2->_cartesian};
d375 1
a375 1
		$z1->_set_cartesian([$re1 - $re2, $im1 - $im2]);
d385 1
a385 1
# (_multiply)
d389 1
a389 1
sub _multiply {
d393 2
a394 2
	    my ($r1, $t1) = @@{$z1->_polar};
	    my ($r2, $t2) = @@{$z2->_polar};
d396 2
a397 2
	    if    ($t >   pi()) { $t -= pi2 }
	    elsif ($t <= -pi()) { $t += pi2 }
d399 1
a399 1
		$z1->_set_polar([$r1 * $r2, $t]);
d404 1
a404 1
	    my ($x1, $y1) = @@{$z1->_cartesian};
d406 1
a406 1
		my ($x2, $y2) = @@{$z2->_cartesian};
d436 1
a436 1
# (_divide)
d440 1
a440 1
sub _divide {
d444 2
a445 2
	    my ($r1, $t1) = @@{$z1->_polar};
	    my ($r2, $t2) = @@{$z2->_polar};
d450 2
a451 2
		if    ($t >   pi()) { $t -= pi2 }
		elsif ($t <= -pi()) { $t += pi2 }
d456 2
a457 2
		if    ($t >   pi()) { $t -= pi2 }
		elsif ($t <= -pi()) { $t += pi2 }
d463 1
a463 1
		($x2, $y2) = @@{$z1->_cartesian};
d468 1
a468 1
		my ($x1, $y1) = @@{$z1->_cartesian};
d470 1
a470 1
		    ($x2, $y2) = @@{$z2->_cartesian};
d485 1
a485 1
# (_power)
d489 1
a489 1
sub _power {
d503 1
a503 1
	       cplx(@@{$w->_cartesian}) : $w;
d507 1
a507 1
# (_spaceship)
d512 1
a512 1
sub _spaceship {
d514 2
a515 2
	my ($re1, $im1) = ref $z1 ? @@{$z1->_cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
d522 1
a522 1
# (_numeq)
d526 2
a527 2
# (Required in addition to _spaceship() because of NaNs.)
sub _numeq {
d529 2
a530 2
	my ($re1, $im1) = ref $z1 ? @@{$z1->_cartesian} : ($z1, 0);
	my ($re2, $im2) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
d535 1
a535 1
# (_negate)
d539 1
a539 1
sub _negate {
d542 1
a542 1
		my ($r, $t) = @@{$z->_polar};
d546 1
a546 1
	my ($re, $im) = @@{$z->_cartesian};
d551 1
a551 1
# (_conjugate)
d553 1
a553 1
# Compute complex's _conjugate.
d555 1
a555 1
sub _conjugate {
d558 1
a558 1
		my ($r, $t) = @@{$z->_polar};
d561 1
a561 1
	my ($re, $im) = @@{$z->_cartesian};
d580 1
a580 1
	    $z->{'polar'} = [ $rho, ${$z->_polar}[1] ];
d585 1
a585 1
	    return ${$z->_polar}[0];
d592 2
a593 2
    if    ($$theta >   pi()) { $$theta -= pi2 }
    elsif ($$theta <= -pi()) { $$theta += pi2 }
d606 1
a606 1
	    $z->{'polar'} = [ ${$z->_polar}[0], $theta ];
d610 1
a610 1
	    $theta = ${$z->_polar}[1];
d633 1
a633 1
	my ($re, $im) = ref $z ? @@{$z->_cartesian} : ($z, 0);
d636 1
a636 1
	my ($r, $t) = @@{$z->_polar};
d653 1
a653 1
	my ($r, $t) = @@{$z->_polar};
d687 2
a688 2
	    @@{$z->_polar} : (CORE::abs($z), $z >= 0 ? 0 : pi);
	my $theta_inc = pi2 / $n;
d698 1
a698 1
		push @@root, $cartesian ? cplx(@@{$w->_cartesian}) : $w;
d703 1
a703 1
	    return $cartesian ? cplx(@@{$w->_cartesian}) : $w;
d716 1
a716 1
	    $z->{'cartesian'} = [ $Re, ${$z->_cartesian}[1] ];
d720 1
a720 1
	    return ${$z->_cartesian}[0];
d733 1
a733 1
	    $z->{'cartesian'} = [ ${$z->_cartesian}[0], $Im ];
d737 1
a737 1
	    return ${$z->_cartesian}[1];
d766 1
a766 1
	my ($x, $y) = @@{$z->_cartesian};
d802 1
a802 1
	my ($r, $t) = @@{$z->_polar};
d804 2
a805 2
	if    ($t >   pi()) { $t -= pi2 }
	elsif ($t <= -pi()) { $t += pi2 }
d823 1
a823 1
	return Math::Complex::log($_[0]) * _uplog10;
d847 1
a847 1
	my ($x, $y) = @@{$z->_cartesian};
d864 1
a864 1
	my ($x, $y) = @@{$z->_cartesian};
d945 1
a945 1
	my ($x, $y) = @@{$z->_cartesian};
d970 1
a970 1
	my ($x, $y) = @@{$z->_cartesian};
d993 1
a993 1
	my ($x, $y) = ref $z ? @@{$z->_cartesian} : ($z, 0);
d998 1
a998 1
	return _ip2 * $log;
d1064 1
a1064 1
	my ($x, $y) = @@{$z->_cartesian};
d1084 1
a1084 1
	my ($x, $y) = @@{$z->_cartesian};
d1165 1
a1165 1
	my ($re, $im) = @@{$z->_cartesian};
d1281 2
a1282 2
	    ($re1, $im1) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
	    ($re2, $im2) = ref $z1 ? @@{$z1->_cartesian} : ($z1, 0);
d1284 2
a1285 2
	    ($re1, $im1) = ref $z1 ? @@{$z1->_cartesian} : ($z1, 0);
	    ($re2, $im2) = ref $z2 ? @@{$z2->_cartesian} : ($z2, 0);
d1348 1
a1348 1
# (_stringify)
d1357 1
a1357 1
sub _stringify {
d1364 2
a1365 2
	return $z->_stringify_polar if $style =~ /^p/i;
	return $z->_stringify_cartesian;
d1369 1
a1369 1
# ->_stringify_cartesian
d1373 1
a1373 1
sub _stringify_cartesian {
d1375 1
a1375 1
	my ($x, $y) = @@{$z->_cartesian};
d1431 1
a1431 1
# ->_stringify_polar
d1435 1
a1435 1
sub _stringify_polar {
d1437 1
a1437 1
	my ($r, $t) = @@{$z->_polar};
d1457 1
a1457 1
	$t -= int(CORE::abs($t) / pi2) * pi2;
d1574 2
a1575 2
the I<argument> of the complex number. The I<norm> of C<z> is
marked here as C<abs(z)>.
d1577 5
a1581 5
The polar notation (also known as the trigonometric representation) is
much more handy for performing multiplications and divisions of
complex numbers, whilst the cartesian notation is better suited for
additions and subtractions. Real numbers are on the I<x> axis, and
therefore I<y> or I<theta> is zero or I<pi>.
a1677 2
Note that atan2(0, 0) is not well-defined.

a1897 9
=head2 PI

The constant C<pi> and some handy multiples of it (pi2, pi4,
and pip2 (pi/2) and pip4 (pi/4)) are also available if separately
exported:

    use Math::Complex ':pi'; 
    $third_of_circle = pi2 / 3;

d1964 4
a1967 3
Daniel S. Lewart <F<lewart!at!uiuc.edu>>
Jarkko Hietaniemi <F<jhi!at!iki.fi>>
Raphael Manfredi <F<Raphael_Manfredi!at!pobox.com>>
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d10 1
a10 5
use strict;

use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS $Inf $ExpInf);

$VERSION = 1.56;
d12 1
a12 1
use Config;
d15 1
a15 25
    my %DBL_MAX =
	(
	  4  => '1.70141183460469229e+38',
	  8  => '1.7976931348623157e+308',
	 # AFAICT the 10, 12, and 16-byte long doubles
	 # all have the same maximum.
	 10 => '1.1897314953572317650857593266280070162E+4932',
	 12 => '1.1897314953572317650857593266280070162E+4932',
	 16 => '1.1897314953572317650857593266280070162E+4932',
	);
    my $nvsize = $Config{nvsize} ||
	        ($Config{uselongdouble} && $Config{longdblsize}) ||
                 $Config{doublesize};
    die "Math::Complex: Could not figure out nvsize\n"
	unless defined $nvsize;
    die "Math::Complex: Cannot not figure out max nv (nvsize = $nvsize)\n"
	unless defined $DBL_MAX{$nvsize};
    my $DBL_MAX = eval $DBL_MAX{$nvsize};
    die "Math::Complex: Could not figure out max nv (nvsize = $nvsize)\n"
	unless defined $DBL_MAX;
    my $BIGGER_THAN_THIS = 1e30;  # Must find something bigger than this.
    if ($^O eq 'unicosmk') {
	$Inf = $DBL_MAX;
    } else {
	local $SIG{FPE} = { };
d17 12
a28 17
	# We do want an arithmetic overflow, Inf INF inf Infinity.
	for my $t (
	    'exp(99999)',  # Enough even with 128-bit long doubles.
	    'inf',
	    'Inf',
	    'INF',
	    'infinity',
	    'Infinity',
	    'INFINITY',
	    '1e99999',
	    ) {
	    local $^W = 0;
	    my $i = eval "$t+1.0";
	    if (defined $i && $i > $BIGGER_THAN_THIS) {
		$Inf = $i;
		last;
	    }
a29 4
	$Inf = $DBL_MAX unless defined $Inf;  # Oh well, close enough.
	die "Math::Complex: Could not get Infinity"
	    unless $Inf > $BIGGER_THAN_THIS;
	$ExpInf = exp(99999);
d31 1
a31 1
    # print "# On this machine, Inf = '$Inf'\n";
d34 1
a34 18
use Scalar::Util qw(set_prototype);

use warnings;
no warnings 'syntax';  # To avoid the (_) warnings.

BEGIN {
    # For certain functions that we override, in 5.10 or better
    # we can set a smarter prototype that will handle the lexical $_
    # (also a 5.10+ feature).
    if ($] >= 5.010000) {
        set_prototype \&abs, '_';
        set_prototype \&cos, '_';
        set_prototype \&exp, '_';
        set_prototype \&log, '_';
        set_prototype \&sin, '_';
        set_prototype \&sqrt, '_';
    }
}
d68 1
a68 1
my @@pi = qw(pi pi2 pi4 pip2 pip4 Inf);
d112 2
d581 1
a581 1
	my ($z, $rho) = @@_ ? @@_ : $_;
d642 1
a642 1
	my ($z) = @@_ ? $_[0] : $_;
d775 3
a777 4
    my ($z) = @@_ ? @@_ : $_;
    return CORE::exp($z) unless ref $z;
    my ($x, $y) = @@{$z->_cartesian};
    return (ref $z)->emake(CORE::exp($x), $y);
d807 1
a807 1
	my ($z) = @@_ ? @@_ : $_;
d855 1
a855 1
	my ($z) = @@_ ? @@_ : $_;
d861 1
a861 1
	my $ey_1 = $ey ? 1 / $ey : Inf();
d872 1
a872 1
	my ($z) = @@_ ? @@_ : $_;
d878 1
a878 1
	my $ey_1 = $ey ? 1 / $ey : Inf();
d1072 1
a1072 1
            return $ex ? ($ex == $ExpInf ? Inf() : ($ex + 1/$ex)/2) : Inf();
d1076 1
a1076 1
	my $ex_1 = $ex ? 1 / $ex : Inf();
d1092 1
a1092 1
            return $ex ? ($ex == $ExpInf ? Inf() : ($ex - 1/$ex)/2) : -Inf();
d1098 1
a1098 1
	my $ex_1 = $ex ? 1 / $ex : Inf();
d1112 1
a1112 4
	my $sz = sinh($z);
	return  1 if $cz ==  $sz;
	return -1 if $cz == -$sz;
	return $sz / $cz;
d1155 1
a1155 4
	my $cz = cosh($z);
	return  1 if $cz ==  $sz;
	return -1 if $cz == -$sz;
	return $cz / $sz;
d1168 1
a1168 1
# Computes the area/inverse hyperbolic cosine acosh(z) = log(z + sqrt(z*z-1)).
d1196 1
a1196 1
# Computes the area/inverse hyperbolic sine asinh(z) = log(z + sqrt(z*z+1))
d1216 1
a1216 1
# Computes the area/inverse hyperbolic tangent atanh(z) = 1/2 log((1+z) / (1-z)).
d1232 1
a1232 1
# Computes the area/inverse hyperbolic secant asech(z) = acosh(1 / z).
d1243 1
a1243 1
# Computes the area/inverse hyperbolic cosecant acsch(z) = asinh(1 / z).
d1261 1
a1261 1
# Computes the area/inverse hyperbolic cotangent acoth(z) = 1/2 log((1+z) / (z-1)).
d1395 1
a1395 1
		if ($x =~ /^-?\Q$Inf\E$/oi) {
d1409 1
a1409 1
		if ($y =~ /^-?\Q$Inf\E$/oi) {
d1453 1
a1453 1
	if ($t =~ /^NaN[QS]?$/i || $t =~ /^-?\Q$Inf\E$/oi) {
a1490 4
sub Inf {
    return $Inf;
}

d1758 5
a1762 5
The I<spaceship> numeric comparison operator, E<lt>=E<gt>, is also
defined. In order to ensure its restriction to real numbers is conform
to what you would expect, the comparison is run on the real part of
the complex number first, and imaginary parts are compared only when
the real parts match.
a1909 2
=head1 CONSTANTS

a1918 26
=head2 Inf

The floating point infinity can be exported as a subroutine Inf():

    use Math::Complex qw(Inf sinh);
    my $AlsoInf = Inf() + 42;
    my $AnotherInf = sinh(1e42);
    print "$AlsoInf is $AnotherInf\n" if $AlsoInf == $AnotherInf;

Note that the stringified form of infinity varies between platforms:
it can be for example any of

   inf
   infinity
   INF
   1.#INF

or it can be something else. 

Also note that in some platforms trying to use the infinity in
arithmetic operations may result in Perl crashing because using
an infinity causes SIGFPE or its moral equivalent to be sent.
The way to ignore this is

  local $SIG{FPE} = sub { };

a1982 4
=head1 SEE ALSO

L<Math::Trig>

a1987 5

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
@


