head	1.14;
access;
symbols
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.11.0.10
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.8
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.11.0.6
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.4
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.10.0.6
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.10.0.4
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.14
date	2010.09.24.14.59.42;	author millert;	state dead;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.41;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.15.21.30.33;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.09.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.39;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.42;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.46;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.46;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.46;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.13;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.05;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.19;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.47.12;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.17.22;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.48.50;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.37;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.53;	author millert;	state Exp;
branches;
next	;


desc
@@


1.14
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Math::BigInt;

#
# "Mike had an infinite amount to do and a negative amount of time in which
# to do it." - Before and After
#

# The following hash values are used:
#   value: unsigned int with actual value (as a Math::BigInt::Calc or similiar)
#   sign : +,-,NaN,+inf,-inf
#   _a   : accuracy
#   _p   : precision
#   _f   : flags, used by MBF to flag parts of a float as untouchable

# Remember not to take shortcuts ala $xs = $x->{value}; $CALC->foo($xs); since
# underlying lib might change the reference!

my $class = "Math::BigInt";
use 5.006;

$VERSION = '1.89';

@@ISA = qw(Exporter);
@@EXPORT_OK = qw(objectify bgcd blcm); 

# _trap_inf and _trap_nan are internal and should never be accessed from the
# outside
use vars qw/$round_mode $accuracy $precision $div_scale $rnd_mode 
	    $upgrade $downgrade $_trap_nan $_trap_inf/;
use strict;

# Inside overload, the first arg is always an object. If the original code had
# it reversed (like $x = 2 * $y), then the third paramater is true.
# In some cases (like add, $x = $x + 2 is the same as $x = 2 + $x) this makes
# no difference, but in some cases it does.

# For overloaded ops with only one argument we simple use $_[0]->copy() to
# preserve the argument.

# Thus inheritance of overload operators becomes possible and transparent for
# our subclasses without the need to repeat the entire overload section there.

use overload
'='     =>      sub { $_[0]->copy(); },

# some shortcuts for speed (assumes that reversed order of arguments is routed
# to normal '+' and we thus can always modify first arg. If this is changed,
# this breaks and must be adjusted.)
'+='	=>	sub { $_[0]->badd($_[1]); },
'-='	=>	sub { $_[0]->bsub($_[1]); },
'*='	=>	sub { $_[0]->bmul($_[1]); },
'/='	=>	sub { scalar $_[0]->bdiv($_[1]); },
'%='	=>	sub { $_[0]->bmod($_[1]); },
'^='	=>	sub { $_[0]->bxor($_[1]); },
'&='	=>	sub { $_[0]->band($_[1]); },
'|='	=>	sub { $_[0]->bior($_[1]); },

'**='	=>	sub { $_[0]->bpow($_[1]); },
'<<='	=>	sub { $_[0]->blsft($_[1]); },
'>>='	=>	sub { $_[0]->brsft($_[1]); },

# not supported by Perl yet
'..'	=>	\&_pointpoint,

'<=>'	=>	sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
                      $_[0]->bcmp($_[1]); 
		      $rc = 1 unless defined $rc;
		      $rc <=> 0;
		},
# we need '>=' to get things like "1 >= NaN" right:
'>='	=>	sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
                      $_[0]->bcmp($_[1]);
		      # if there was a NaN involved, return false
		      return '' unless defined $rc;
		      $rc >= 0;
		},
'cmp'	=>	sub {
         $_[2] ? 
               "$_[1]" cmp $_[0]->bstr() :
               $_[0]->bstr() cmp "$_[1]" },

'cos'	=>	sub { $_[0]->copy->bcos(); }, 
'sin'	=>	sub { $_[0]->copy->bsin(); }, 
'atan2'	=>	sub { $_[2] ?
			ref($_[0])->new($_[1])->batan2($_[0]) :
			$_[0]->copy()->batan2($_[1]) },

# are not yet overloadable
#'hex'	=>	sub { print "hex"; $_[0]; }, 
#'oct'	=>	sub { print "oct"; $_[0]; }, 

# log(N) is log(N, e), where e is Euler's number
'log'	=>	sub { $_[0]->copy()->blog($_[1], undef); }, 
'exp'	=>	sub { $_[0]->copy()->bexp($_[1]); }, 
'int'	=>	sub { $_[0]->copy(); }, 
'neg'	=>	sub { $_[0]->copy()->bneg(); }, 
'abs'	=>	sub { $_[0]->copy()->babs(); },
'sqrt'  =>	sub { $_[0]->copy()->bsqrt(); },
'~'	=>	sub { $_[0]->copy()->bnot(); },

# for subtract it's a bit tricky to not modify b: b-a => -a+b
'-'	=>	sub { my $c = $_[0]->copy; $_[2] ?
			$c->bneg()->badd( $_[1]) :
			$c->bsub( $_[1]) },
'+'	=>	sub { $_[0]->copy()->badd($_[1]); },
'*'	=>	sub { $_[0]->copy()->bmul($_[1]); },

'/'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bdiv($_[0]) : $_[0]->copy->bdiv($_[1]);
  }, 
'%'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bmod($_[0]) : $_[0]->copy->bmod($_[1]);
  }, 
'**'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bpow($_[0]) : $_[0]->copy->bpow($_[1]);
  }, 
'<<'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->blsft($_[0]) : $_[0]->copy->blsft($_[1]);
  }, 
'>>'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->brsft($_[0]) : $_[0]->copy->brsft($_[1]);
  }, 
'&'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->band($_[0]) : $_[0]->copy->band($_[1]);
  }, 
'|'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bior($_[0]) : $_[0]->copy->bior($_[1]);
  }, 
'^'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bxor($_[0]) : $_[0]->copy->bxor($_[1]);
  }, 

# can modify arg of ++ and --, so avoid a copy() for speed, but don't
# use $_[0]->bone(), it would modify $_[0] to be 1!
'++'	=>	sub { $_[0]->binc() },
'--'	=>	sub { $_[0]->bdec() },

# if overloaded, O(1) instead of O(N) and twice as fast for small numbers
'bool'  =>	sub {
  # this kludge is needed for perl prior 5.6.0 since returning 0 here fails :-/
  # v5.6.1 dumps on this: return !$_[0]->is_zero() || undef;		    :-(
  my $t = undef;
  $t = 1 if !$_[0]->is_zero();
  $t;
  },

# the original qw() does not work with the TIESCALAR below, why?
# Order of arguments unsignificant
'""' => sub { $_[0]->bstr(); },
'0+' => sub { $_[0]->numify(); }
;

##############################################################################
# global constants, flags and accessory

# These vars are public, but their direct usage is not recommended, use the
# accessor methods instead

$round_mode = 'even'; # one of 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
$accuracy   = undef;
$precision  = undef;
$div_scale  = 40;

$upgrade = undef;			# default is no upgrade
$downgrade = undef;			# default is no downgrade

# These are internally, and not to be used from the outside at all

$_trap_nan = 0;				# are NaNs ok? set w/ config()
$_trap_inf = 0;				# are infs ok? set w/ config()
my $nan = 'NaN'; 			# constants for easier life

my $CALC = 'Math::BigInt::FastCalc';	# module to do the low level math
					# default is FastCalc.pm
my $IMPORT = 0;				# was import() called yet?
					# used to make require work
my %WARN;				# warn only once for low-level libs
my %CAN;				# cache for $CALC->can(...)
my %CALLBACKS;				# callbacks to notify on lib loads
my $EMU_LIB = 'Math/BigInt/CalcEmu.pm';	# emulate low-level math

##############################################################################
# the old code had $rnd_mode, so we need to support it, too

$rnd_mode   = 'even';
sub TIESCALAR  { my ($class) = @@_; bless \$round_mode, $class; }
sub FETCH      { return $round_mode; }
sub STORE      { $rnd_mode = $_[0]->round_mode($_[1]); }

BEGIN
  { 
  # tie to enable $rnd_mode to work transparently
  tie $rnd_mode, 'Math::BigInt'; 

  # set up some handy alias names
  *as_int = \&as_number;
  *is_pos = \&is_positive;
  *is_neg = \&is_negative;
  }

############################################################################## 

sub round_mode
  {
  no strict 'refs';
  # make Class->round_mode() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    my $m = shift;
    if ($m !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
      {
      require Carp; Carp::croak ("Unknown round mode '$m'");
      }
    return ${"${class}::round_mode"} = $m;
    }
  ${"${class}::round_mode"};
  }

sub upgrade
  {
  no strict 'refs';
  # make Class->upgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@@_ > 0)
    {
    return ${"${class}::upgrade"} = $_[0];
    }
  ${"${class}::upgrade"};
  }

sub downgrade
  {
  no strict 'refs';
  # make Class->downgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@@_ > 0)
    {
    return ${"${class}::downgrade"} = $_[0];
    }
  ${"${class}::downgrade"};
  }

sub div_scale
  {
  no strict 'refs';
  # make Class->div_scale() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    if ($_[0] < 0)
      {
      require Carp; Carp::croak ('div_scale must be greater than zero');
      }
    ${"${class}::div_scale"} = $_[0];
    }
  ${"${class}::div_scale"};
  }

sub accuracy
  {
  # $x->accuracy($a);		ref($x)	$a
  # $x->accuracy();		ref($x)
  # Class->accuracy();		class
  # Class->accuracy($a);	class $a

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  # need to set new value?
  if (@@_ > 0)
    {
    my $a = shift;
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $a = $a->numify() if ref($a) && $a->can('numify');

    if (defined $a)
      {
      # also croak on non-numerical
      if (!$a || $a <= 0)
        {
        require Carp;
	Carp::croak ('Argument to accuracy must be greater than zero');
        }
      if (int($a) != $a)
        {
        require Carp;
	Carp::croak ('Argument to accuracy must be an integer');
        }
      }
    if (ref($x))
      {
      # $object->accuracy() or fallback to global
      $x->bround($a) if $a;		# not for undef, 0
      $x->{_a} = $a;			# set/overwrite, even if not rounded
      delete $x->{_p};			# clear P
      $a = ${"${class}::accuracy"} unless defined $a;   # proper return value
      }
    else
      {
      ${"${class}::accuracy"} = $a;	# set global A
      ${"${class}::precision"} = undef;	# clear global P
      }
    return $a;				# shortcut
    }

  my $a;
  # $object->accuracy() or fallback to global
  $a = $x->{_a} if ref($x);
  # but don't return global undef, when $x's accuracy is 0!
  $a = ${"${class}::accuracy"} if !defined $a;
  $a;
  }

sub precision
  {
  # $x->precision($p);		ref($x)	$p
  # $x->precision();		ref($x)
  # Class->precision();		class
  # Class->precision($p);	class $p

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  if (@@_ > 0)
    {
    my $p = shift;
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $p = $p->numify() if ref($p) && $p->can('numify');
    if ((defined $p) && (int($p) != $p))
      {
      require Carp; Carp::croak ('Argument to precision must be an integer');
      }
    if (ref($x))
      {
      # $object->precision() or fallback to global
      $x->bfround($p) if $p;		# not for undef, 0
      $x->{_p} = $p;			# set/overwrite, even if not rounded
      delete $x->{_a};			# clear A
      $p = ${"${class}::precision"} unless defined $p;  # proper return value
      }
    else
      {
      ${"${class}::precision"} = $p;	# set global P
      ${"${class}::accuracy"} = undef;	# clear global A
      }
    return $p;				# shortcut
    }

  my $p;
  # $object->precision() or fallback to global
  $p = $x->{_p} if ref($x);
  # but don't return global undef, when $x's precision is 0!
  $p = ${"${class}::precision"} if !defined $p;
  $p;
  }

sub config
  {
  # return (or set) configuration data as hash ref
  my $class = shift || 'Math::BigInt';

  no strict 'refs';
  if (@@_ > 1 || (@@_ == 1 && (ref($_[0]) eq 'HASH')))
    {
    # try to set given options as arguments from hash

    my $args = $_[0];
    if (ref($args) ne 'HASH')
      {
      $args = { @@_ };
      }
    # these values can be "set"
    my $set_args = {};
    foreach my $key (
     qw/trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale/
     )
      {
      $set_args->{$key} = $args->{$key} if exists $args->{$key};
      delete $args->{$key};
      }
    if (keys %$args > 0)
      {
      require Carp;
      Carp::croak ("Illegal key(s) '",
       join("','",keys %$args),"' passed to $class\->config()");
      }
    foreach my $key (keys %$set_args)
      {
      if ($key =~ /^trap_(inf|nan)\z/)
        {
        ${"${class}::_trap_$1"} = ($set_args->{"trap_$1"} ? 1 : 0);
        next;
        }
      # use a call instead of just setting the $variable to check argument
      $class->$key($set_args->{$key});
      }
    }

  # now return actual configuration

  my $cfg = {
    lib => $CALC,
    lib_version => ${"${CALC}::VERSION"},
    class => $class,
    trap_nan => ${"${class}::_trap_nan"},
    trap_inf => ${"${class}::_trap_inf"},
    version => ${"${class}::VERSION"},
    };
  foreach my $key (qw/
     upgrade downgrade precision accuracy round_mode div_scale
     /)
    {
    $cfg->{$key} = ${"${class}::$key"};
    };
  if (@@_ == 1 && (ref($_[0]) ne 'HASH'))
    {
    # calls of the style config('lib') return just this value
    return $cfg->{$_[0]};
    }
  $cfg;
  }

sub _scale_a
  { 
  # select accuracy parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$scale,$mode) = @@_;

  $scale = $x->{_a} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::accuracy' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify() : "$scale" if ref($scale);
    $scale = int($scale);
    }

  ($scale,$mode);
  }

sub _scale_p
  { 
  # select precision parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$scale,$mode) = @@_;
  
  $scale = $x->{_p} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::precision' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify() : "$scale" if ref($scale);
    $scale = int($scale);
    }

  ($scale,$mode);
  }

##############################################################################
# constructors

sub copy
  {
  # if two arguments, the first one is the class to "swallow" subclasses
  if (@@_ > 1)
    {
    my  $self = bless {
	sign => $_[1]->{sign}, 
	value => $CALC->_copy($_[1]->{value}),
    }, $_[0] if @@_ > 1;

    $self->{_a} = $_[1]->{_a} if defined $_[1]->{_a};
    $self->{_p} = $_[1]->{_p} if defined $_[1]->{_p};
    return $self;
    }

  my $self = bless {
	sign => $_[0]->{sign}, 
	value => $CALC->_copy($_[0]->{value}),
	}, ref($_[0]);

  $self->{_a} = $_[0]->{_a} if defined $_[0]->{_a};
  $self->{_p} = $_[0]->{_p} if defined $_[0]->{_p};
  $self;
  }

sub new 
  {
  # create a new BigInt object from a string or another BigInt object. 
  # see hash keys documented at top

  # the argument could be an object, so avoid ||, && etc on it, this would
  # cause costly overloaded code to be called. The only allowed ops are
  # ref() and defined.

  my ($class,$wanted,$a,$p,$r) = @@_;
 
  # avoid numify-calls by not using || on $wanted!
  return $class->bzero($a,$p) if !defined $wanted;	# default to 0
  return $class->copy($wanted,$a,$p,$r)
   if ref($wanted) && $wanted->isa($class);		# MBI or subclass

  $class->import() if $IMPORT == 0;		# make require work
  
  my $self = bless {}, $class;

  # shortcut for "normal" numbers
  if ((!ref $wanted) && ($wanted =~ /^([+-]?)[1-9][0-9]*\z/))
    {
    $self->{sign} = $1 || '+';

    if ($wanted =~ /^[+-]/)
     {
      # remove sign without touching wanted to make it work with constants
      my $t = $wanted; $t =~ s/^[+-]//;
      $self->{value} = $CALC->_new($t);
      }
    else
      {
      $self->{value} = $CALC->_new($wanted);
      }
    no strict 'refs';
    if ( (defined $a) || (defined $p) 
        || (defined ${"${class}::precision"})
        || (defined ${"${class}::accuracy"}) 
       )
      {
      $self->round($a,$p,$r) unless (@@_ == 4 && !defined $a && !defined $p);
      }
    return $self;
    }

  # handle '+inf', '-inf' first
  if ($wanted =~ /^[+-]?inf\z/)
    {
    $self->{sign} = $wanted;		# set a default sign for bstr()
    return $self->binf($wanted);
    }
  # split str in m mantissa, e exponent, i integer, f fraction, v value, s sign
  my ($mis,$miv,$mfv,$es,$ev) = _split($wanted);
  if (!ref $mis)
    {
    if ($_trap_nan)
      {
      require Carp; Carp::croak("$wanted is not a number in $class");
      }
    $self->{value} = $CALC->_zero();
    $self->{sign} = $nan;
    return $self;
    }
  if (!ref $miv)
    {
    # _from_hex or _from_bin
    $self->{value} = $mis->{value};
    $self->{sign} = $mis->{sign};
    return $self;	# throw away $mis
    }
  # make integer from mantissa by adjusting exp, then convert to bigint
  $self->{sign} = $$mis;			# store sign
  $self->{value} = $CALC->_zero();		# for all the NaN cases
  my $e = int("$$es$$ev");			# exponent (avoid recursion)
  if ($e > 0)
    {
    my $diff = $e - CORE::length($$mfv);
    if ($diff < 0)				# Not integer
      {
      if ($_trap_nan)
        {
        require Carp; Carp::croak("$wanted not an integer in $class");
        }
      #print "NOI 1\n";
      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
      $self->{sign} = $nan;
      }
    else					# diff >= 0
      {
      # adjust fraction and add it to value
      #print "diff > 0 $$miv\n";
      $$miv = $$miv . ($$mfv . '0' x $diff);
      }
    }
  else
    {
    if ($$mfv ne '')				# e <= 0
      {
      # fraction and negative/zero E => NOI
      if ($_trap_nan)
        {
        require Carp; Carp::croak("$wanted not an integer in $class");
        }
      #print "NOI 2 \$\$mfv '$$mfv'\n";
      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
      $self->{sign} = $nan;
      }
    elsif ($e < 0)
      {
      # xE-y, and empty mfv
      #print "xE-y\n";
      $e = abs($e);
      if ($$miv !~ s/0{$e}$//)		# can strip so many zero's?
        {
        if ($_trap_nan)
          {
          require Carp; Carp::croak("$wanted not an integer in $class");
          }
        #print "NOI 3\n";
        return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
        $self->{sign} = $nan;
        }
      }
    }
  $self->{sign} = '+' if $$miv eq '0';			# normalize -0 => +0
  $self->{value} = $CALC->_new($$miv) if $self->{sign} =~ /^[+-]$/;
  # if any of the globals is set, use them to round and store them inside $self
  # do not round for new($x,undef,undef) since that is used by MBF to signal
  # no rounding
  $self->round($a,$p,$r) unless @@_ == 4 && !defined $a && !defined $p;
  $self;
  }

sub bnan
  {
  # create a bigint 'NaN', if given a BigInt, set it to 'NaN'
  my $self = shift;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  no strict 'refs';
  if (${"${class}::_trap_nan"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to NaN in $class\::bnan()");
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('bnan');
  if ($self->can('_bnan'))
    {
    # use subclass to initialize
    $self->_bnan();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = $nan;
  delete $self->{_a}; delete $self->{_p};	# rounding NaN is silly
  $self;
  }

sub binf
  {
  # create a bigint '+-inf', if given a BigInt, set it to '+-inf'
  # the sign is either '+', or if given, used from there
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign !~ /^-(inf)?$/;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  no strict 'refs';
  if (${"${class}::_trap_inf"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to +-inf in $class\::binf()");
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('binf');
  if ($self->can('_binf'))
    {
    # use subclass to initialize
    $self->_binf();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $sign = $sign . 'inf' if $sign !~ /inf$/;	# - => -inf
  $self->{sign} = $sign;
  ($self->{_a},$self->{_p}) = @@_;		# take over requested rounding
  $self;
  }

sub bzero
  {
  # create a bigint '+0', if given a BigInt, set it to 0
  my $self = shift;
  $self = __PACKAGE__ if !defined $self;
 
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('bzero');
  
  if ($self->can('_bzero'))
    {
    # use subclass to initialize
    $self->_bzero();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = '+';
  if (@@_ > 0)
    {
    if (@@_ > 3)
      {
      # call like: $x->bzero($a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@@_);
      }
    else
      {
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

sub bone
  {
  # create a bigint '+1' (or -1 if given sign '-'),
  # if given a BigInt, set it to +1 or -1, respectively
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign ne '-';
  $self = $class if !defined $self;

  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('bone');

  if ($self->can('_bone'))
    {
    # use subclass to initialize
    $self->_bone();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_one();
    }
  $self->{sign} = $sign;
  if (@@_ > 0)
    {
    if (@@_ > 3)
      {
      # call like: $x->bone($sign,$a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@@_);
      }
    else
      {
      # call like: $x->bone($sign,$a,$p,$r);
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

##############################################################################
# string conversation

sub bsstr
  {
  # (ref to BFLOAT or num_str ) return num_str
  # Convert number from internal format to scientific string format.
  # internal format is always normalized (no leading zeros, "-0E0" => "+0E0")
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_); 

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';	# -inf, NaN
    return 'inf';					# +inf
    }
  my ($m,$e) = $x->parts();
  #$m->bstr() . 'e+' . $e->bstr(); 	# e can only be positive in BigInt
  # 'e+' because E can only be positive in BigInt
  $m->bstr() . 'e+' . $CALC->_str($e->{value}); 
  }

sub bstr 
  {
  # make a string from bigint object
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_); 

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';	# -inf, NaN
    return 'inf';					# +inf
    }
  my $es = ''; $es = $x->{sign} if $x->{sign} eq '-';
  $es.$CALC->_str($x->{value});
  }

sub numify 
  {
  # Make a "normal" scalar from a BigInt object
  my $x = shift; $x = $class->new($x) unless ref $x;

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;
  my $num = $CALC->_num($x->{value});
  return -$num if $x->{sign} eq '-';
  $num;
  }

##############################################################################
# public stuff (usually prefixed with "b")

sub sign
  {
  # return the sign of the number: +/-/-inf/+inf/NaN
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_); 
  
  $x->{sign};
  }

sub _find_round_parameters
  {
  # After any operation or when calling round(), the result is rounded by
  # regarding the A & P from arguments, local parameters, or globals.

  # !!!!!!! If you change this, remember to change round(), too! !!!!!!!!!!

  # This procedure finds the round parameters, but it is for speed reasons
  # duplicated in round. Otherwise, it is tested by the testsuite and used
  # by fdiv().
 
  # returns ($self) or ($self,$a,$p,$r) - sets $self to NaN of both A and P
  # were requested/defined (locally or globally or both)
  
  my ($self,$a,$p,$r,@@args) = @@_;
  # $a accuracy, if given by caller
  # $p precision, if given by caller
  # $r round_mode, if given by caller
  # @@args all 'other' arguments (0 for unary, 1 for binary ops)

  my $c = ref($self);				# find out class of argument(s)
  no strict 'refs';

  # convert to normal scalar for speed and correctness in inner parts
  $a = $a->can('numify') ? $a->numify() : "$a" if defined $a && ref($a);
  $p = $p->can('numify') ? $p->numify() : "$p" if defined $p && ref($p);

  # now pick $a or $p, but only if we have got "arguments"
  if (!defined $a)
    {
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is smaller
      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
      }
    }
  if (!defined $p)
    {
    # even if $a is defined, take $p, to signal error for both defined
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is bigger
      # -2 > -3, and 3 > 2
      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
      }
    }
  # if still none defined, use globals (#2)
  $a = ${"$c\::accuracy"} unless defined $a;
  $p = ${"$c\::precision"} unless defined $p;

  # A == 0 is useless, so undef it to signal no rounding
  $a = undef if defined $a && $a == 0;
 
  # no rounding today? 
  return ($self) unless defined $a || defined $p;		# early out

  # set A and set P is an fatal error
  return ($self->bnan()) if defined $a && defined $p;		# error

  $r = ${"$c\::round_mode"} unless defined $r;
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
    {
    require Carp; Carp::croak ("Unknown round mode '$r'");
    }

  $a = int($a) if defined $a;
  $p = int($p) if defined $p;

  ($self,$a,$p,$r);
  }

sub round
  {
  # Round $self according to given parameters, or given second argument's
  # parameters or global defaults 

  # for speed reasons, _find_round_parameters is embeded here:

  my ($self,$a,$p,$r,@@args) = @@_;
  # $a accuracy, if given by caller
  # $p precision, if given by caller
  # $r round_mode, if given by caller
  # @@args all 'other' arguments (0 for unary, 1 for binary ops)

  my $c = ref($self);				# find out class of argument(s)
  no strict 'refs';

  # now pick $a or $p, but only if we have got "arguments"
  if (!defined $a)
    {
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is smaller
      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
      }
    }
  if (!defined $p)
    {
    # even if $a is defined, take $p, to signal error for both defined
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is bigger
      # -2 > -3, and 3 > 2
      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
      }
    }
  # if still none defined, use globals (#2)
  $a = ${"$c\::accuracy"} unless defined $a;
  $p = ${"$c\::precision"} unless defined $p;
 
  # A == 0 is useless, so undef it to signal no rounding
  $a = undef if defined $a && $a == 0;
  
  # no rounding today? 
  return $self unless defined $a || defined $p;		# early out

  # set A and set P is an fatal error
  return $self->bnan() if defined $a && defined $p;

  $r = ${"$c\::round_mode"} unless defined $r;
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
    {
    require Carp; Carp::croak ("Unknown round mode '$r'");
    }

  # now round, by calling either fround or ffround:
  if (defined $a)
    {
    $self->bround(int($a),$r) if !defined $self->{_a} || $self->{_a} >= $a;
    }
  else # both can't be undefined due to early out
    {
    $self->bfround(int($p),$r) if !defined $self->{_p} || $self->{_p} <= $p;
    }
  # bround() or bfround() already callled bnorm() if nec.
  $self;
  }

sub bnorm
  { 
  # (numstr or BINT) return BINT
  # Normalize number -- no-op here
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  $x;
  }

sub babs 
  {
  # (BINT or num_str) return BINT
  # make number absolute, or return absolute BINT from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return $x if $x->modify('babs');
  # post-normalized abs for internal use (does nothing for NaN)
  $x->{sign} =~ s/^-/+/;
  $x;
  }

sub bneg 
  { 
  # (BINT or num_str) return BINT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  
  return $x if $x->modify('bneg');

  # for +0 dont negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $CALC->_is_zero($x->{value}));
  $x;
  }

sub bcmp 
  {
  # Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT or num_str, BINT or num_str) return cond_code
  
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@@_);
    }

  return $upgrade->bcmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;
    return +1 if $x->{sign} eq '+inf';
    return -1 if $x->{sign} eq '-inf';
    return -1 if $y->{sign} eq '+inf';
    return +1;
    }
  # check sign for speed first
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';	# does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0 

  # have same sign, so compare absolute values. Don't make tests for zero here
  # because it's actually slower than testin in Calc (especially w/ Pari et al)

  # post-normalized compare for internal use (honors signs)
  if ($x->{sign} eq '+') 
    {
    # $x and $y both > 0
    return $CALC->_acmp($x->{value},$y->{value});
    }

  # $x && $y both < 0
  $CALC->_acmp($y->{value},$x->{value});	# swaped acmp (lib returns 0,1,-1)
  }

sub bacmp 
  {
  # Compares 2 values, ignoring their signs. 
  # Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT, BINT) return cond_code
  
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@@_);
    }

  return $upgrade->bacmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} =~ /^[+-]inf$/;
    return 1 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} !~ /^[+-]inf$/;
    return -1;
    }
  $CALC->_acmp($x->{value},$y->{value});	# lib does only 0,1,-1
  }

sub badd 
  {
  # add second arg (BINT or string) to first (BINT) (modifies first)
  # return result as BINT

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('badd');
  return $upgrade->badd($upgrade->new($x),$upgrade->new($y),@@r) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  $r[3] = $y;				# no push!
  # inf and NaN handling
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # NaN first
    return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    # inf handling
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +inf++inf or -inf+-inf => same, rest is NaN
      return $x if $x->{sign} eq $y->{sign};
      return $x->bnan();
      }
    # +-inf + something => +inf
    # something +-inf => +-inf
    $x->{sign} = $y->{sign}, return $x if $y->{sign} =~ /^[+-]inf$/;
    return $x;
    }
    
  my ($sx, $sy) = ( $x->{sign}, $y->{sign} ); 		# get signs

  if ($sx eq $sy)  
    {
    $x->{value} = $CALC->_add($x->{value},$y->{value});	# same sign, abs add
    }
  else 
    {
    my $a = $CALC->_acmp ($y->{value},$x->{value});	# absolute compare
    if ($a > 0)                           
      {
      $x->{value} = $CALC->_sub($y->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sy;
      } 
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      $x->{value} = $CALC->_sub($x->{value}, $y->{value}); # abs sub
      }
    }
  $x->round(@@r);
  }

sub bsub 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # subtract second arg from first, modify first
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bsub');

  return $upgrade->new($x)->bsub($upgrade->new($y),@@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));

  return $x->round(@@r) if $y->is_zero();

  # To correctly handle the lone special case $x->bsub($x), we note the sign
  # of $x, then flip the sign from $y, and if the sign of $x did change, too,
  # then we caught the special case:
  my $xsign = $x->{sign};
  $y->{sign} =~ tr/+\-/-+/; 	# does nothing for NaN
  if ($xsign ne $x->{sign})
    {
    # special case of $x->bsub($x) results in 0
    return $x->bzero(@@r) if $xsign =~ /^[+-]$/;
    return $x->bnan();          # NaN, -inf, +inf
    }
  $x->badd($y,@@r); 		# badd does not leave internal zeros
  $y->{sign} =~ tr/+\-/-+/; 	# refix $y (does nothing for NaN)
  $x;				# already rounded by badd() or no round nec.
  }

sub binc
  {
  # increment arg by one
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  return $x if $x->modify('binc');

  if ($x->{sign} eq '+')
    {
    $x->{value} = $CALC->_inc($x->{value});
    return $x->round($a,$p,$r);
    }
  elsif ($x->{sign} eq '-')
    {
    $x->{value} = $CALC->_dec($x->{value});
    $x->{sign} = '+' if $CALC->_is_zero($x->{value}); # -1 +1 => -0 => +0
    return $x->round($a,$p,$r);
    }
  # inf, nan handling etc
  $x->badd($self->bone(),$a,$p,$r);		# badd does round
  }

sub bdec
  {
  # decrement arg by one
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  return $x if $x->modify('bdec');
  
  if ($x->{sign} eq '-')
    {
    # x already < 0
    $x->{value} = $CALC->_inc($x->{value});
    } 
  else
    {
    return $x->badd($self->bone('-'),@@r) unless $x->{sign} eq '+'; 	# inf or NaN
    # >= 0
    if ($CALC->_is_zero($x->{value}))
      {
      # == 0
      $x->{value} = $CALC->_one(); $x->{sign} = '-';		# 0 => -1
      }
    else
      {
      # > 0
      $x->{value} = $CALC->_dec($x->{value});
      }
    }
  $x->round(@@r);
  }

sub blog
  {
  # calculate $x = $a ** $base + $b and return $a (e.g. the log() to base
  # $base of $x)

  # set up parameters
  my ($self,$x,$base,@@r) = (undef,@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$base,@@r) = objectify(1,ref($x),@@_);
    }

  return $x if $x->modify('blog');

  $base = $self->new($base) if defined $base && !ref $base;

  # inf, -inf, NaN, <0 => NaN
  return $x->bnan()
   if $x->{sign} ne '+' || (defined $base && $base->{sign} ne '+');

  return $upgrade->blog($upgrade->new($x),$base,@@r) if 
    defined $upgrade;

  # fix for bug #24969:
  # the default base is e (Euler's number) which is not an integer
  if (!defined $base)
    {
    require Math::BigFloat;
    my $u = Math::BigFloat->blog(Math::BigFloat->new($x))->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->{sign} = $u->{sign};
    return $x;
    }
  
  my ($rc,$exact) = $CALC->_log_int($x->{value},$base->{value});
  return $x->bnan() unless defined $rc;		# not possible to take log?
  $x->{value} = $rc;
  $x->round(@@r);
  }

sub bnok
  {
  # Calculate n over k (binomial coefficient or "choose" function) as integer.
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bnok');
  return $x->bnan() if $x->{sign} eq 'NaN' || $y->{sign} eq 'NaN';
  return $x->binf() if $x->{sign} eq '+inf';

  # k > n or k < 0 => 0
  my $cmp = $x->bacmp($y);
  return $x->bzero() if $cmp < 0 || $y->{sign} =~ /^-/;
  # k == n => 1
  return $x->bone(@@r) if $cmp == 0;

  if ($CALC->can('_nok'))
    {
    $x->{value} = $CALC->_nok($x->{value},$y->{value});
    }
  else
    {
    # ( 7 )    7!          7*6*5 * 4*3*2*1   7 * 6 * 5
    # ( - ) = --------- =  --------------- = ---------
    # ( 3 )   3! (7-3)!    3*2*1 * 4*3*2*1   3 * 2 * 1 

    # compute n - k + 2 (so we start with 5 in the example above)
    my $z = $x - $y;
    if (!$z->is_one())
      {
      $z->binc();
      my $r = $z->copy(); $z->binc();
      my $d = $self->new(2);
      while ($z->bacmp($x) <= 0)		# f < x ?
        {
        $r->bmul($z); $r->bdiv($d);
        $z->binc(); $d->binc();
        }
      $x->{value} = $r->{value}; $x->{sign} = '+';
      }
    else { $x->bone(); }
    }
  $x->round(@@r);
  }

sub bexp
  {
  # Calculate e ** $x (Euler's number to the power of X), truncated to
  # an integer value.
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  return $x if $x->modify('bexp');

  # inf, -inf, NaN, <0 => NaN
  return $x->bnan() if $x->{sign} eq 'NaN';
  return $x->bone() if $x->is_zero();
  return $x if $x->{sign} eq '+inf';
  return $x->bzero() if $x->{sign} eq '-inf';

  my $u;
  {
    # run through Math::BigFloat unless told otherwise
    require Math::BigFloat unless defined $upgrade;
    local $upgrade = 'Math::BigFloat' unless defined $upgrade;
    # calculate result, truncate it to integer
    $u = $upgrade->bexp($upgrade->new($x),@@r);
  }

  if (!defined $upgrade)
    {
    $u = $u->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->round(@@r);
    }
  else { $x = $u; }
  }

sub blcm 
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # Lowest Common Multiplicator

  my $y = shift; my ($x);
  if (ref($y))
    {
    $x = $y->copy();
    }
  else
    {
    $x = $class->new($y);
    }
  my $self = ref($x);
  while (@@_) 
    {
    my $y = shift; $y = $self->new($y) if !ref ($y);
    $x = __lcm($x,$y);
    } 
  $x;
  }

sub bgcd 
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # GCD -- Euclids algorithm, variant C (Knuth Vol 3, pg 341 ff)

  my $y = shift;
  $y = $class->new($y) if !ref($y);
  my $self = ref($y);
  my $x = $y->copy()->babs();			# keep arguments
  return $x->bnan() if $x->{sign} !~ /^[+-]$/;	# x NaN?

  while (@@_)
    {
    $y = shift; $y = $self->new($y) if !ref($y);
    return $x->bnan() if $y->{sign} !~ /^[+-]$/;	# y NaN?
    $x->{value} = $CALC->_gcd($x->{value},$y->{value});
    last if $CALC->_is_one($x->{value});
    }
  $x;
  }

sub bnot 
  {
  # (num_str or BINT) return BINT
  # represent ~x as twos-complement number
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
 
  return $x if $x->modify('bnot');
  $x->binc()->bneg();			# binc already does round
  }

##############################################################################
# is_foo test routines
# we don't need $self, so undef instead of ref($_[0]) make it slightly faster

sub is_zero
  {
  # return true if arg (BINT or num_str) is zero (array '+', '0')
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  
  return 0 if $x->{sign} !~ /^\+$/;			# -, NaN & +-inf aren't
  $CALC->_is_zero($x->{value});
  }

sub is_nan
  {
  # return true if arg (BINT or num_str) is NaN
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  $x->{sign} eq $nan ? 1 : 0;
  }

sub is_inf
  {
  # return true if arg (BINT or num_str) is +-inf
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  if (defined $sign)
    {
    $sign = '[+-]inf' if $sign eq '';	# +- doesn't matter, only that's inf
    $sign = "[$1]inf" if $sign =~ /^([+-])(inf)?$/;	# extract '+' or '-'
    return $x->{sign} =~ /^$sign$/ ? 1 : 0;
    }
  $x->{sign} =~ /^[+-]inf$/ ? 1 : 0;		# only +-inf is infinity
  }

sub is_one
  {
  # return true if arg (BINT or num_str) is +1, or -1 if sign is given
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
    
  $sign = '+' if !defined $sign || $sign ne '-';
 
  return 0 if $x->{sign} ne $sign; 	# -1 != +1, NaN, +-inf aren't either
  $CALC->_is_one($x->{value});
  }

sub is_odd
  {
  # return true when arg (BINT or num_str) is odd, false for even
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
  $CALC->_is_odd($x->{value});
  }

sub is_even
  {
  # return true when arg (BINT or num_str) is even, false for odd
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
  $CALC->_is_even($x->{value});
  }

sub is_positive
  {
  # return true when arg (BINT or num_str) is positive (>= 0)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return 1 if $x->{sign} eq '+inf';			# +inf is positive
 
  # 0+ is neither positive nor negative
  ($x->{sign} eq '+' && !$x->is_zero()) ? 1 : 0;	
  }

sub is_negative
  {
  # return true when arg (BINT or num_str) is negative (< 0)
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  
  $x->{sign} =~ /^-/ ? 1 : 0; 		# -inf is negative, but NaN is not
  }

sub is_int
  {
  # return true when arg (BINT or num_str) is an integer
  # always true for BigInt, but different for BigFloats
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  
  $x->{sign} =~ /^[+-]$/ ? 1 : 0;		# inf/-inf/NaN aren't
  }

###############################################################################

sub bmul 
  { 
  # multiply the first number by the second number
  # (BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bmul');

  return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/); 
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); 
    return $x->binf('-');
    }

  return $upgrade->bmul($x,$upgrade->new($y),@@r)
   if defined $upgrade && !$y->isa($self);
  
  $r[3] = $y;				# no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});	# do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); 	# no -0

  $x->round(@@r);
  }

sub bmuladd
  { 
  # multiply two numbers and then add the third to the result
  # (BINT or num_str, BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,$z,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$z,@@r) = objectify(3,@@_);
    }

  return $x if $x->modify('bmuladd');

  return $x->bnan() if  ($x->{sign} eq $nan) ||
			($y->{sign} eq $nan) ||
			($z->{sign} eq $nan);

  # inf handling of x and y
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/); 
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); 
    return $x->binf('-');
    }
  # inf handling x*y and z
  if (($z->{sign} =~ /^[+-]inf$/))
    {
    # something +-inf => +-inf
    $x->{sign} = $z->{sign}, return $x if $z->{sign} =~ /^[+-]inf$/;
    }

  return $upgrade->bmuladd($x,$upgrade->new($y),$upgrade->new($z),@@r)
   if defined $upgrade && (!$y->isa($self) || !$z->isa($self) || !$x->isa($self));
 
  # TODO: what if $y and $z have A or P set?
  $r[3] = $z;				# no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});	# do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); 	# no -0

  my ($sx, $sz) = ( $x->{sign}, $z->{sign} ); 		# get signs

  if ($sx eq $sz)  
    {
    $x->{value} = $CALC->_add($x->{value},$z->{value});	# same sign, abs add
    }
  else 
    {
    my $a = $CALC->_acmp ($z->{value},$x->{value});	# absolute compare
    if ($a > 0)                           
      {
      $x->{value} = $CALC->_sub($z->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sz;
      } 
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      $x->{value} = $CALC->_sub($x->{value}, $z->{value}); # abs sub
      }
    }
  $x->round(@@r);
  }

sub _div_inf
  {
  # helper function that handles +-inf cases for bdiv()/bmod() to reuse code
  my ($self,$x,$y) = @@_;

  # NaN if x == NaN or y == NaN or x==y==0
  return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan()
   if (($x->is_nan() || $y->is_nan())   ||
       ($x->is_zero() && $y->is_zero()));
 
  # +-inf / +-inf == NaN, reminder also NaN
  if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
    {
    return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan();
    }
  # x / +-inf => 0, remainder x (works even if x == 0)
  if ($y->{sign} =~ /^[+-]inf$/)
    {
    my $t = $x->copy();		# bzero clobbers up $x
    return wantarray ? ($x->bzero(),$t) : $x->bzero()
    }
  
  # 5 / 0 => +inf, -6 / 0 => -inf
  # +inf / 0 = inf, inf,  and -inf / 0 => -inf, -inf 
  # exception:   -8 / 0 has remainder -8, not 8
  # exception: -inf / 0 has remainder -inf, not inf
  if ($y->is_zero())
    {
    # +-inf / 0 => special case for -inf
    return wantarray ?  ($x,$x->copy()) : $x if $x->is_inf();
    if (!$x->is_zero() && !$x->is_inf())
      {
      my $t = $x->copy();		# binf clobbers up $x
      return wantarray ?
       ($x->binf($x->{sign}),$t) : $x->binf($x->{sign})
      }
    }
  
  # last case: +-inf / ordinary number
  my $sign = '+inf';
  $sign = '-inf' if substr($x->{sign},0,1) ne $y->{sign};
  $x->{sign} = $sign;
  return wantarray ? ($x,$self->bzero()) : $x;
  }

sub bdiv 
  {
  # (dividend: BINT or num_str, divisor: BINT or num_str) return 
  # (BINT,BINT) (quo,rem) or BINT (only rem)
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    } 

  return $x if $x->modify('bdiv');

  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());

  return $upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@@r)
   if defined $upgrade;
   
  $r[3] = $y;					# no push!

  # calc new sign and in case $y == +/- 1, return $x
  my $xsign = $x->{sign};				# keep
  $x->{sign} = ($x->{sign} ne $y->{sign} ? '-' : '+'); 

  if (wantarray)
    {
    my $rem = $self->bzero(); 
    ($x->{value},$rem->{value}) = $CALC->_div($x->{value},$y->{value});
    $x->{sign} = '+' if $CALC->_is_zero($x->{value});
    $rem->{_a} = $x->{_a};
    $rem->{_p} = $x->{_p};
    $x->round(@@r);
    if (! $CALC->_is_zero($rem->{value}))
      {
      $rem->{sign} = $y->{sign};
      $rem = $y->copy()->bsub($rem) if $xsign ne $y->{sign}; # one of them '-'
      }
    else
      {
      $rem->{sign} = '+';			# dont leave -0
      }
    $rem->round(@@r);
    return ($x,$rem);
    }

  $x->{value} = $CALC->_div($x->{value},$y->{value});
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});

  $x->round(@@r);
  }

###############################################################################
# modulus functions

sub bmod 
  {
  # modulus (or remainder)
  # (BINT or num_str, BINT or num_str) return BINT
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bmod');
  $r[3] = $y;					# no push!
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero())
    {
    my ($d,$r) = $self->_div_inf($x,$y);
    $x->{sign} = $r->{sign};
    $x->{value} = $r->{value};
    return $x->round(@@r);
    }

  # calc new sign and in case $y == +/- 1, return $x
  $x->{value} = $CALC->_mod($x->{value},$y->{value});
  if (!$CALC->_is_zero($x->{value}))
    {
    $x->{value} = $CALC->_sub($y->{value},$x->{value},1) 	# $y-$x
      if ($x->{sign} ne $y->{sign});
    $x->{sign} = $y->{sign};
    }
   else
    {
    $x->{sign} = '+';				# dont leave -0
    }
  $x->round(@@r);
  }

sub bmodinv
  {
  # Modular inverse.  given a number which is (hopefully) relatively
  # prime to the modulus, calculate its inverse using Euclid's
  # alogrithm.  If the number is not relatively prime to the modulus
  # (i.e. their gcd is not one) then NaN is returned.

  # set up parameters
  my ($self,$x,$y,@@r) = (undef,@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bmodinv');

  return $x->bnan()
        if ($y->{sign} ne '+'                           # -, NaN, +inf, -inf
         || $x->is_zero()                               # or num == 0
         || $x->{sign} !~ /^[+-]$/                      # or num NaN, inf, -inf
        );

  # put least residue into $x if $x was negative, and thus make it positive
  $x->bmod($y) if $x->{sign} eq '-';

  my $sign;
  ($x->{value},$sign) = $CALC->_modinv($x->{value},$y->{value});
  return $x->bnan() if !defined $x->{value};		# in case no GCD found
  return $x if !defined $sign;			# already real result
  $x->{sign} = $sign;				# flip/flop see below
  $x->bmod($y);					# calc real result
  $x;
  }

sub bmodpow
  {
  # takes a very large number to a very large exponent in a given very
  # large modulus, quickly, thanks to binary exponentation. Supports
  # negative exponents.
  my ($self,$num,$exp,$mod,@@r) = objectify(3,@@_);

  return $num if $num->modify('bmodpow');

  # check modulus for valid values
  return $num->bnan() if ($mod->{sign} ne '+'		# NaN, - , -inf, +inf
                       || $mod->is_zero());

  # check exponent for valid values
  if ($exp->{sign} =~ /\w/) 
    {
    # i.e., if it's NaN, +inf, or -inf...
    return $num->bnan();
    }

  $num->bmodinv ($mod) if ($exp->{sign} eq '-');

  # check num for valid values (also NaN if there was no inverse but $exp < 0)
  return $num->bnan() if $num->{sign} !~ /^[+-]$/;

  # $mod is positive, sign on $exp is ignored, result also positive
  $num->{value} = $CALC->_modpow($num->{value},$exp->{value},$mod->{value});
  $num;
  }

###############################################################################

sub bfac
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute factorial number from $x, modify $x in place
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';	# inf => inf
  return $x->bnan() if $x->{sign} ne '+';			# NaN, <0 etc => NaN

  $x->{value} = $CALC->_fac($x->{value});
  $x->round(@@r);
  }
 
sub bpow 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute power of two numbers -- stolen from Knuth Vol 2 pg 233
  # modifies first argument

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bpow');

  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +-inf ** +-inf
      return $x->bnan();
      }
    # +-inf ** Y
    if ($x->{sign} =~ /^[+-]inf/)
      {
      # +inf ** 0 => NaN
      return $x->bnan() if $y->is_zero();
      # -inf ** -1 => 1/inf => 0
      return $x->bzero() if $y->is_one('-') && $x->is_negative();

      # +inf ** Y => inf
      return $x if $x->{sign} eq '+inf';

      # -inf ** Y => -inf if Y is odd
      return $x if $y->is_odd();
      return $x->babs();
      }
    # X ** +-inf

    # 1 ** +inf => 1
    return $x if $x->is_one();
    
    # 0 ** inf => 0
    return $x if $x->is_zero() && $y->{sign} =~ /^[+]/;

    # 0 ** -inf => inf
    return $x->binf() if $x->is_zero();

    # -1 ** -inf => NaN
    return $x->bnan() if $x->is_one('-') && $y->{sign} =~ /^[-]/;

    # -X ** -inf => 0
    return $x->bzero() if $x->{sign} eq '-' && $y->{sign} =~ /^[-]/;

    # -1 ** inf => NaN
    return $x->bnan() if $x->{sign} eq '-';

    # X ** inf => inf
    return $x->binf() if $y->{sign} =~ /^[+]/;
    # X ** -inf => 0
    return $x->bzero();
    }

  return $upgrade->bpow($upgrade->new($x),$y,@@r)
   if defined $upgrade && (!$y->isa($self) || $y->{sign} eq '-');

  $r[3] = $y;					# no push!

  # cases 0 ** Y, X ** 0, X ** 1, 1 ** Y are handled by Calc or Emu

  my $new_sign = '+';
  $new_sign = $y->is_odd() ? '-' : '+' if ($x->{sign} ne '+'); 

  # 0 ** -7 => ( 1 / (0 ** 7)) => 1 / 0 => +inf 
  return $x->binf() 
    if $y->{sign} eq '-' && $x->{sign} eq '+' && $CALC->_is_zero($x->{value});
  # 1 ** -y => 1 / (1 ** |y|)
  # so do test for negative $y after above's clause
  return $x->bnan() if $y->{sign} eq '-' && !$CALC->_is_one($x->{value});

  $x->{value} = $CALC->_pow($x->{value},$y->{value});
  $x->{sign} = $new_sign;
  $x->{sign} = '+' if $CALC->_is_zero($y->{value});
  $x->round(@@r);
  }

sub blsft 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x << y, base n, y >= 0
 
  # set up parameters
  my ($self,$x,$y,$n,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('blsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@@r) if $y->is_zero();

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

  $x->{value} = $CALC->_lsft($x->{value},$y->{value},$n);
  $x->round(@@r);
  }

sub brsft 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x >> y, base n, y >= 0
  
  # set up parameters
  my ($self,$x,$y,$n,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('brsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@@r) if $y->is_zero();
  return $x->bzero(@@r) if $x->is_zero();		# 0 => 0

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

   # this only works for negative numbers when shifting in base 2
  if (($x->{sign} eq '-') && ($n == 2))
    {
    return $x->round(@@r) if $x->is_one('-');	# -1 => -1
    if (!$y->is_one())
      {
      # although this is O(N*N) in calc (as_bin!) it is O(N) in Pari et al
      # but perhaps there is a better emulation for two's complement shift...
      # if $y != 1, we must simulate it by doing:
      # convert to bin, flip all bits, shift, and be done
      $x->binc();			# -3 => -2
      my $bin = $x->as_bin();
      $bin =~ s/^-0b//;			# strip '-0b' prefix
      $bin =~ tr/10/01/;		# flip bits
      # now shift
      if ($y >= CORE::length($bin))
        {
	$bin = '0'; 			# shifting to far right creates -1
					# 0, because later increment makes 
					# that 1, attached '-' makes it '-1'
					# because -1 >> x == -1 !
        } 
      else
	{
	$bin =~ s/.{$y}$//;		# cut off at the right side
        $bin = '1' . $bin;		# extend left side by one dummy '1'
        $bin =~ tr/10/01/;		# flip bits back
	}
      my $res = $self->new('0b'.$bin);	# add prefix and convert back
      $res->binc();			# remember to increment
      $x->{value} = $res->{value};	# take over value
      return $x->round(@@r);		# we are done now, magic, isn't?
      }
    # x < 0, n == 2, y == 1
    $x->bdec();				# n == 2, but $y == 1: this fixes it
    }

  $x->{value} = $CALC->_rsft($x->{value},$y->{value},$n);
  $x->round(@@r);
  }

sub band 
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x & y
 
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }
  
  return $x if $x->modify('band');

  $r[3] = $y;				# no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;
  
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_and($x->{value},$y->{value});
    return $x->round(@@r);
    }
  
  if ($CAN{signed_and})
    {
    $x->{value} = $CALC->_signed_and($x->{value},$y->{value},$sx,$sy);
    return $x->round(@@r);
    }
 
  require $EMU_LIB;
  __emu_band($self,$x,$y,$sx,$sy,@@r);
  }

sub bior 
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x | y
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bior');
  $r[3] = $y;				# no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);

  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  # the sign of X follows the sign of X, e.g. sign of Y irrelevant for bior()
  
  # don't use lib for negative values
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_or($x->{value},$y->{value});
    return $x->round(@@r);
    }

  # if lib can do negative values, let it handle this
  if ($CAN{signed_or})
    {
    $x->{value} = $CALC->_signed_or($x->{value},$y->{value},$sx,$sy);
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_bior($self,$x,$y,$sx,$sy,@@r);
  }

sub bxor 
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x ^ y
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bxor');
  $r[3] = $y;				# no push!

  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  
  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;

  # don't use lib for negative values
  if ($sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_xor($x->{value},$y->{value});
    return $x->round(@@r);
    }
  
  # if lib can do negative values, let it handle this
  if ($CAN{signed_xor})
    {
    $x->{value} = $CALC->_signed_xor($x->{value},$y->{value},$sx,$sy);
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_bxor($self,$x,$y,$sx,$sy,@@r);
  }

sub length
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  my $e = $CALC->_len($x->{value}); 
  wantarray ? ($e,0) : $e;
  }

sub digit
  {
  # return the nth decimal digit, negative values count backward, 0 is right
  my ($self,$x,$n) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  $n = $n->numify() if ref($n);
  $CALC->_digit($x->{value},$n||0);
  }

sub _trailing_zeros
  {
  # return the amount of trailing zeros in $x (as scalar)
  my $x = shift;
  $x = $class->new($x) unless ref $x;

  return 0 if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf etc

  $CALC->_zeros($x->{value});		# must handle odd values, 0 etc
  }

sub bsqrt
  {
  # calculate square root of $x
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bsqrt');

  return $x->bnan() if $x->{sign} !~ /^\+/;	# -x or -inf or NaN => NaN
  return $x if $x->{sign} eq '+inf';		# sqrt(+inf) == inf

  return $upgrade->bsqrt($x,@@r) if defined $upgrade;

  $x->{value} = $CALC->_sqrt($x->{value});
  $x->round(@@r);
  }

sub broot
  {
  # calculate $y'th root of $x
 
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  $y = $self->new(2) unless defined $y;

  # objectify is costly, so avoid it
  if ((!ref($x)) || (ref($x) ne ref($y)))
    {
    ($self,$x,$y,@@r) = objectify(2,$self || $class,@@_);
    }

  return $x if $x->modify('broot');

  # NaN handling: $x ** 1/0, x or y NaN, or y inf/-inf or y == 0
  return $x->bnan() if $x->{sign} !~ /^\+/ || $y->is_zero() ||
         $y->{sign} !~ /^\+$/;

  return $x->round(@@r)
    if $x->is_zero() || $x->is_one() || $x->is_inf() || $y->is_one();

  return $upgrade->new($x)->broot($upgrade->new($y),@@r) if defined $upgrade;

  $x->{value} = $CALC->_root($x->{value},$y->{value});
  $x->round(@@r);
  }

sub exponent
  {
  # return a copy of the exponent (here always 0, NaN or 1 for $m == 0)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
 
  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+-]//;  # NaN, -inf,+inf => NaN or inf
    return $self->new($s);
    }
  return $self->bone() if $x->is_zero();

  # 12300 => 2 trailing zeros => exponent is 2
  $self->new( $CALC->_zeros($x->{value}) );
  }

sub mantissa
  {
  # return the mantissa (compatible to Math::BigFloat, e.g. reduced)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    # for NaN, +inf, -inf: keep the sign
    return $self->new($x->{sign});
    }
  my $m = $x->copy(); delete $m->{_p}; delete $m->{_a};

  # that's a bit inefficient:
  my $zeros = $CALC->_zeros($m->{value});
  $m->brsft($zeros,10) if $zeros != 0;
  $m;
  }

sub parts
  {
  # return a copy of both the exponent and the mantissa
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  ($x->mantissa(),$x->exponent());
  }
   
##############################################################################
# rounding functions

sub bfround
  {
  # precision: round to the $Nth digit left (+$n) or right (-$n) from the '.'
  # $n == 0 || $n == 1 => round to integer
  my $x = shift; my $self = ref($x) || $x; $x = $self->new($x) unless ref $x;

  my ($scale,$mode) = $x->_scale_p(@@_);

  return $x if !defined $scale || $x->modify('bfround');	# no-op

  # no-op for BigInts if $n <= 0
  $x->bround( $x->length()-$scale, $mode) if $scale > 0;

  delete $x->{_a};	# delete to save memory
  $x->{_p} = $scale;	# store new _p
  $x;
  }

sub _scan_for_nonzero
  {
  # internal, used by bround() to scan for non-zeros after a '5'
  my ($x,$pad,$xs,$len) = @@_;
 
  return 0 if $len == 1;		# "5" is trailed by invisible zeros
  my $follow = $pad - 1;
  return 0 if $follow > $len || $follow < 1;

  # use the string form to check whether only '0's follow or not
  substr ($xs,-$follow) =~ /[^0]/ ? 1 : 0;
  }

sub fround
  {
  # Exists to make life easier for switch between MBF and MBI (should we
  # autoload fxxx() like MBF does for bxxx()?)
  my $x = shift; $x = $class->new($x) unless ref $x;
  $x->bround(@@_);
  }

sub bround
  {
  # accuracy: +$n preserve $n digits from left,
  #           -$n preserve $n digits from right (f.i. for 0.1234 style in MBF)
  # no-op for $n == 0
  # and overwrite the rest with 0's, return normalized number
  # do not return $x->bnorm(), but $x

  my $x = shift; $x = $class->new($x) unless ref $x;
  my ($scale,$mode) = $x->_scale_a(@@_);
  return $x if !defined $scale || $x->modify('bround');	# no-op
  
  if ($x->is_zero() || $scale == 0)
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x;
    }
  return $x if $x->{sign} !~ /^[+-]$/;		# inf, NaN

  # we have fewer digits than we want to scale to
  my $len = $x->length();
  # convert $scale to a scalar in case it is an object (put's a limit on the
  # number length, but this would already limited by memory constraints), makes
  # it faster
  $scale = $scale->numify() if ref ($scale);

  # scale < 0, but > -len (not >=!)
  if (($scale < 0 && $scale < -$len-1) || ($scale >= $len))
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x; 
    }
   
  # count of 0's to pad, from left (+) or right (-): 9 - +6 => 3, or |-6| => 6
  my ($pad,$digit_round,$digit_after);
  $pad = $len - $scale;
  $pad = abs($scale-1) if $scale < 0;

  # do not use digit(), it is very costly for binary => decimal
  # getting the entire string is also costly, but we need to do it only once
  my $xs = $CALC->_str($x->{value});
  my $pl = -$pad-1;

  # pad:   123: 0 => -1, at 1 => -2, at 2 => -3, at 3 => -4
  # pad+1: 123: 0 => 0,  at 1 => -1, at 2 => -2, at 3 => -3
  $digit_round = '0'; $digit_round = substr($xs,$pl,1) if $pad <= $len;
  $pl++; $pl ++ if $pad >= $len;
  $digit_after = '0'; $digit_after = substr($xs,$pl,1) if $pad > 0;

  # in case of 01234 we round down, for 6789 up, and only in case 5 we look
  # closer at the remaining digits of the original $x, remember decision
  my $round_up = 1;					# default round up
  $round_up -- if
    ($mode eq 'trunc')				||	# trunc by round down
    ($digit_after =~ /[01234]/)			|| 	# round down anyway,
							# 6789 => round up
    ($digit_after eq '5')			&&	# not 5000...0000
    ($x->_scan_for_nonzero($pad,$xs,$len) == 0)		&&
    (
     ($mode eq 'even') && ($digit_round =~ /[24680]/) ||
     ($mode eq 'odd')  && ($digit_round =~ /[13579]/) ||
     ($mode eq '+inf') && ($x->{sign} eq '-')   ||
     ($mode eq '-inf') && ($x->{sign} eq '+')   ||
     ($mode eq 'zero')		# round down if zero, sign adjusted below
    );
  my $put_back = 0;					# not yet modified
	
  if (($pad > 0) && ($pad <= $len))
    {
    substr($xs,-$pad,$pad) = '0' x $pad;		# replace with '00...'
    $put_back = 1;					# need to put back
    }
  elsif ($pad > $len)
    {
    $x->bzero();					# round to '0'
    }

  if ($round_up)					# what gave test above?
    {
    $put_back = 1;					# need to put back
    $pad = $len, $xs = '0' x $pad if $scale < 0;	# tlr: whack 0.51=>1.0	

    # we modify directly the string variant instead of creating a number and
    # adding it, since that is faster (we already have the string)
    my $c = 0; $pad ++;				# for $pad == $len case
    while ($pad <= $len)
      {
      $c = substr($xs,-$pad,1) + 1; $c = '0' if $c eq '10';
      substr($xs,-$pad,1) = $c; $pad++;
      last if $c != 0;				# no overflow => early out
      }
    $xs = '1'.$xs if $c == 0;

    }
  $x->{value} = $CALC->_new($xs) if $put_back == 1;	# put back, if needed

  $x->{_a} = $scale if $scale >= 0;
  if ($scale < 0)
    {
    $x->{_a} = $len+$scale;
    $x->{_a} = 0 if $scale < -$len;
    }
  $x;
  }

sub bfloor
  {
  # return integer less or equal then number; no-op since it's already integer
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  $x->round(@@r);
  }

sub bceil
  {
  # return integer greater or equal then number; no-op since it's already int
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  $x->round(@@r);
  }

sub as_number
  {
  # An object might be asked to return itself as bigint on certain overloaded
  # operations. This does exactly this, so that sub classes can simple inherit
  # it or override with their own integer conversion routine.
  $_[0]->copy();
  }

sub as_hex
  {
  # return as hex string, with prefixed 0x
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $s = '';
  $s = $x->{sign} if $x->{sign} eq '-';
  $s . $CALC->_as_hex($x->{value});
  }

sub as_bin
  {
  # return as binary string, with prefixed 0b
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';
  return $s . $CALC->_as_bin($x->{value});
  }

sub as_oct
  {
  # return as octal string, with prefixed 0
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';
  return $s . $CALC->_as_oct($x->{value});
  }

##############################################################################
# private stuff (internal use only)

sub objectify
  {
  # check for strings, if yes, return objects instead
 
  # the first argument is number of args objectify() should look at it will
  # return $count+1 elements, the first will be a classname. This is because
  # overloaded '""' calls bstr($object,undef,undef) and this would result in
  # useless objects being created and thrown away. So we cannot simple loop
  # over @@_. If the given count is 0, all arguments will be used.
 
  # If the second arg is a ref, use it as class.
  # If not, try to use it as classname, unless undef, then use $class 
  # (aka Math::BigInt). The latter shouldn't happen,though.

  # caller:			   gives us:
  # $x->badd(1);                => ref x, scalar y
  # Class->badd(1,2);           => classname x (scalar), scalar x, scalar y
  # Class->badd( Class->(1),2); => classname x (scalar), ref x, scalar y
  # Math::BigInt::badd(1,2);    => scalar x, scalar y
  # In the last case we check number of arguments to turn it silently into
  # $class,1,2. (We can not take '1' as class ;o)
  # badd($class,1) is not supported (it should, eventually, try to add undef)
  # currently it tries 'Math::BigInt' + 1, which will not work.

  # some shortcut for the common cases
  # $x->unary_op();
  return (ref($_[1]),$_[1]) if (@@_ == 2) && ($_[0]||0 == 1) && ref($_[1]);

  my $count = abs(shift || 0);
  
  my (@@a,$k,$d);		# resulting array, temp, and downgrade 
  if (ref $_[0])
    {
    # okay, got object as first
    $a[0] = ref $_[0];
    }
  else
    {
    # nope, got 1,2 (Class->xxx(1) => Class,1 and not supported)
    $a[0] = $class;
    $a[0] = shift if $_[0] =~ /^[A-Z].*::/;	# classname as first?
    }

  no strict 'refs';
  # disable downgrading, because Math::BigFLoat->foo('1.0','2.0') needs floats
  if (defined ${"$a[0]::downgrade"})
    {
    $d = ${"$a[0]::downgrade"};
    ${"$a[0]::downgrade"} = undef;
    }

  my $up = ${"$a[0]::upgrade"};
  # print STDERR "# Now in objectify, my class is today $a[0], count = $count\n";
  if ($count == 0)
    {
    while (@@_)
      {
      $k = shift;
      if (!ref($k))
        {
        $k = $a[0]->new($k);
        }
      elsif (!defined $up && ref($k) ne $a[0])
	{
	# foreign object, try to convert to integer
        $k->can('as_number') ?  $k = $k->as_number() : $k = $a[0]->new($k);
	}
      push @@a,$k;
      }
    }
  else
    {
    while ($count > 0)
      {
      $count--; 
      $k = shift;
      if (!ref($k))
        {
        $k = $a[0]->new($k);
        }
      elsif (!defined $up && ref($k) ne $a[0])
	{
	# foreign object, try to convert to integer
        $k->can('as_number') ? $k = $k->as_number() : $k = $a[0]->new($k);
	}
      push @@a,$k;
      }
    push @@a,@@_;		# return other params, too
    }
  if (! wantarray)
    {
    require Carp; Carp::croak ("$class objectify needs list context");
    }
  ${"$a[0]::downgrade"} = $d;
  @@a;
  }

sub _register_callback
  {
  my ($class,$callback) = @@_;

  if (ref($callback) ne 'CODE')
    { 
    require Carp;
    Carp::croak ("$callback is not a coderef");
    }
  $CALLBACKS{$class} = $callback;
  }

sub import 
  {
  my $self = shift;

  $IMPORT++;				# remember we did import()
  my @@a; my $l = scalar @@_;
  my $warn_or_die = 0;			# 0 - no warn, 1 - warn, 2 - die
  for ( my $i = 0; $i < $l ; $i++ )
    {
    if ($_[$i] eq ':constant')
      {
      # this causes overlord er load to step in
      overload::constant 
	integer => sub { $self->new(shift) },
      	binary => sub { $self->new(shift) };
      }
    elsif ($_[$i] eq 'upgrade')
      {
      # this causes upgrading
      $upgrade = $_[$i+1];		# or undef to disable
      $i++;
      }
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
      {
      # this causes a different low lib to take care...
      $CALC = $_[$i+1] || '';
      # lib => 1 (warn on fallback), try => 0 (no warn), only => 2 (die on fallback)
      $warn_or_die = 1 if $_[$i] eq 'lib';
      $warn_or_die = 2 if $_[$i] eq 'only';
      $i++;
      }
    else
      {
      push @@a, $_[$i];
      }
    }
  # any non :constant stuff is handled by our parent, Exporter
  if (@@a > 0)
    {
    require Exporter;
 
    $self->SUPER::import(@@a);			# need it for subclasses
    $self->export_to_level(1,$self,@@a);		# need it for MBF
    }

  # try to load core math lib
  my @@c = split /\s*,\s*/,$CALC;
  foreach (@@c)
    {
    $_ =~ tr/a-zA-Z0-9://cd;			# limit to sane characters
    }
  push @@c, \'FastCalc', \'Calc'			# if all fail, try these
    if $warn_or_die < 2;			# but not for "only"
  $CALC = '';					# signal error
  foreach my $l (@@c)
    {
    # fallback libraries are "marked" as \'string', extract string if nec.
    my $lib = $l; $lib = $$l if ref($l);

    next if ($lib || '') eq '';
    $lib = 'Math::BigInt::'.$lib if $lib !~ /^Math::BigInt/i;
    $lib =~ s/\.pm$//;
    if ($] < 5.006)
      {
      # Perl < 5.6.0 dies with "out of memory!" when eval("") and ':constant' is
      # used in the same script, or eval("") inside import().
      my @@parts = split /::/, $lib;             # Math::BigInt => Math BigInt
      my $file = pop @@parts; $file .= '.pm';    # BigInt => BigInt.pm
      require File::Spec;
      $file = File::Spec->catfile (@@parts, $file);
      eval { require "$file"; $lib->import( @@c ); }
      }
    else
      {
      eval "use $lib qw/@@c/;";
      }
    if ($@@ eq '')
      {
      my $ok = 1;
      # loaded it ok, see if the api_version() is high enough
      if ($lib->can('api_version') && $lib->api_version() >= 1.0)
	{
	$ok = 0;
	# api_version matches, check if it really provides anything we need
        for my $method (qw/
		one two ten
		str num
		add mul div sub dec inc
		acmp len digit is_one is_zero is_even is_odd
		is_two is_ten
		zeros new copy check
		from_hex from_oct from_bin as_hex as_bin as_oct
		rsft lsft xor and or
		mod sqrt root fac pow modinv modpow log_int gcd
	 /)
          {
	  if (!$lib->can("_$method"))
	    {
	    if (($WARN{$lib}||0) < 2)
	      {
	      require Carp;
	      Carp::carp ("$lib is missing method '_$method'");
	      $WARN{$lib} = 1;		# still warn about the lib
	      }
            $ok++; last; 
	    }
          }
	}
      if ($ok == 0)
	{
	$CALC = $lib;
	if ($warn_or_die > 0 && ref($l))
	  {
	  require Carp;
	  my $msg = "Math::BigInt: couldn't load specified math lib(s), fallback to $lib";
          Carp::carp ($msg) if $warn_or_die == 1;
          Carp::croak ($msg) if $warn_or_die == 2;
	  }
        last;			# found a usable one, break
	}
      else
	{
	if (($WARN{$lib}||0) < 2)
	  {
	  my $ver = eval "\$$lib\::VERSION" || 'unknown';
	  require Carp;
	  Carp::carp ("Cannot load outdated $lib v$ver, please upgrade");
	  $WARN{$lib} = 2;		# never warn again
	  }
        }
      }
    }
  if ($CALC eq '')
    {
    require Carp;
    if ($warn_or_die == 2)
      {
      Carp::croak ("Couldn't load specified math lib(s) and fallback disallowed");
      }
    else
      {
      Carp::croak ("Couldn't load any math lib(s), not even fallback to Calc.pm");
      }
    }

  # notify callbacks
  foreach my $class (keys %CALLBACKS)
    {
    &{$CALLBACKS{$class}}($CALC);
    }

  # Fill $CAN with the results of $CALC->can(...) for emulating lower math lib
  # functions

  %CAN = ();
  for my $method (qw/ signed_and signed_or signed_xor /)
    {
    $CAN{$method} = $CALC->can("_$method") ? 1 : 0;
    }

  # import done
  }

sub from_hex
  {
  # create a bigint from a hexadecimal string
  my ($self, $hs) = @@_;

  my $rc = __from_hex($hs);

  return $self->bnan() unless defined $rc;

  $rc;
  }  

sub from_bin
  {
  # create a bigint from a hexadecimal string
  my ($self, $bs) = @@_;

  my $rc = __from_bin($bs);

  return $self->bnan() unless defined $rc;

  $rc;
  }  

sub from_oct
  {
  # create a bigint from a hexadecimal string
  my ($self, $os) = @@_;

  my $x = $self->bzero();
  
  # strip underscores
  $os =~ s/([0-7])_([0-7])/$1$2/g;	
  $os =~ s/([0-7])_([0-7])/$1$2/g;	
  
  return $x->bnan() if $os !~ /^[\-\+]?0[0-7]+\z/;

  my $sign = '+'; $sign = '-' if $os =~ /^-/;

  $os =~ s/^[+-]//;						# strip sign
  $x->{value} = $CALC->_from_oct($os);
  $x->{sign} = $sign unless $CALC->_is_zero($x->{value}); 	# no '-0'
  $x;
  }

sub __from_hex
  {
  # internal
  # convert a (ref to) big hex string to BigInt, return undef for error
  my $hs = shift;

  my $x = Math::BigInt->bzero();
  
  # strip underscores
  $hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
  $hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
  
  return $x->bnan() if $hs !~ /^[\-\+]?0x[0-9A-Fa-f]+$/;

  my $sign = '+'; $sign = '-' if $hs =~ /^-/;

  $hs =~ s/^[+-]//;						# strip sign
  $x->{value} = $CALC->_from_hex($hs);
  $x->{sign} = $sign unless $CALC->_is_zero($x->{value}); 	# no '-0'
  $x;
  }

sub __from_bin
  {
  # internal
  # convert a (ref to) big binary string to BigInt, return undef for error
  my $bs = shift;

  my $x = Math::BigInt->bzero();

  # strip underscores
  $bs =~ s/([01])_([01])/$1$2/g;	
  $bs =~ s/([01])_([01])/$1$2/g;	
  return $x->bnan() if $bs !~ /^[+-]?0b[01]+$/;

  my $sign = '+'; $sign = '-' if $bs =~ /^\-/;
  $bs =~ s/^[+-]//;						# strip sign

  $x->{value} = $CALC->_from_bin($bs);
  $x->{sign} = $sign unless $CALC->_is_zero($x->{value}); 	# no '-0'
  $x;
  }

sub _split
  {
  # input: num_str; output: undef for invalid or
  # (\$mantissa_sign,\$mantissa_value,\$mantissa_fraction,\$exp_sign,\$exp_value)
  # Internal, take apart a string and return the pieces.
  # Strip leading/trailing whitespace, leading zeros, underscore and reject
  # invalid input.
  my $x = shift;

  # strip white space at front, also extranous leading zeros
  $x =~ s/^\s*([-]?)0*([0-9])/$1$2/g;   # will not strip '  .2'
  $x =~ s/^\s+//;                       # but this will
  $x =~ s/\s+$//g;                      # strip white space at end

  # shortcut, if nothing to split, return early
  if ($x =~ /^[+-]?[0-9]+\z/)
    {
    $x =~ s/^([+-])0*([0-9])/$2/; my $sign = $1 || '+';
    return (\$sign, \$x, \'', \'', \0);
    }

  # invalid starting char?
  return if $x !~ /^[+-]?(\.?[0-9]|0b[0-1]|0x[0-9a-fA-F])/;

  return __from_hex($x) if $x =~ /^[\-\+]?0x/;		# hex string
  return __from_bin($x) if $x =~ /^[\-\+]?0b/;		# binary string
  
  # strip underscores between digits
  $x =~ s/([0-9])_([0-9])/$1$2/g;
  $x =~ s/([0-9])_([0-9])/$1$2/g;		# do twice for 1_2_3

  # some possible inputs: 
  # 2.1234 # 0.12        # 1 	      # 1E1 # 2.134E1 # 434E-10 # 1.02009E-2 
  # .2 	   # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2     # 0e999	

  my ($m,$e,$last) = split /[Ee]/,$x;
  return if defined $last;		# last defined => 1e2E3 or others
  $e = '0' if !defined $e || $e eq "";

  # sign,value for exponent,mantint,mantfrac
  my ($es,$ev,$mis,$miv,$mfv);
  # valid exponent?
  if ($e =~ /^([+-]?)0*([0-9]+)$/)	# strip leading zeros
    {
    $es = $1; $ev = $2;
    # valid mantissa?
    return if $m eq '.' || $m eq '';
    my ($mi,$mf,$lastf) = split /\./,$m;
    return if defined $lastf;		# lastf defined => 1.2.3 or others
    $mi = '0' if !defined $mi;
    $mi .= '0' if $mi =~ /^[\-\+]?$/;
    $mf = '0' if !defined $mf || $mf eq '';
    if ($mi =~ /^([+-]?)0*([0-9]+)$/)		# strip leading zeros
      {
      $mis = $1||'+'; $miv = $2;
      return unless ($mf =~ /^([0-9]*?)0*$/);	# strip trailing zeros
      $mfv = $1;
      # handle the 0e999 case here
      $ev = 0 if $miv eq '0' && $mfv eq '';
      return (\$mis,\$miv,\$mfv,\$es,\$ev);
      }
    }
  return; # NaN, not a number
  }

##############################################################################
# internal calculation routines (others are in Math::BigInt::Calc etc)

sub __lcm 
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does modify first argument
  # LCM
 
  my ($x,$ty) = @@_;
  return $x->bnan() if ($x->{sign} eq $nan) || ($ty->{sign} eq $nan);
  my $method = ref($x) . '::bgcd';
  no strict 'refs';
  $x * $ty / &$method($x,$ty);
  }

###############################################################################
# trigonometric functions

sub bpi
  {
  # Calculate PI to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer, that is, always returns '3'.
  my ($self,$n) = @@_;
  if (@@_ == 1)
    {
    # called like Math::BigInt::bpi(10);
    $n = $self; $self = $class;
    }
  $self = ref($self) if ref($self);

  return $upgrade->new($n) if defined $upgrade;

  # hard-wired to "3"
  $self->new(3);
  }

sub bcos
  {
  # Calculate cosinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bcos');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN

  return $upgrade->new($x)->bcos(@@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bcos(@@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@@r);
  }

sub bsin
  {
  # Calculate sinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bsin');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN

  return $upgrade->new($x)->bsin(@@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bsin(@@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@@r);
  }

sub batan2
  { 
  # calculate arcus tangens of ($y/$x)
 
  # set up parameters
  my ($self,$y,$x,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$y,$x,@@r) = objectify(2,@@_);
    }

  return $y if $y->modify('batan2');

  return $y->bnan() if ($y->{sign} eq $nan) || ($x->{sign} eq $nan);

  # Y    X
  # != 0 -inf result is +- pi
  if ($x->is_inf() || $y->is_inf())
    {
    # upgrade to BigFloat etc.
    return $upgrade->new($y)->batan2($upgrade->new($x),@@r) if defined $upgrade;
    if ($y->is_inf())
      {
      if ($x->{sign} eq '-inf')
        {
        # calculate 3 pi/4 => 2.3.. => 2
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(2));
        }
      elsif ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # calculate pi/2 => 1.5 => 1
        $y->bone( substr($y->{sign},0,1) );
        }
      }
    else
      {
      if ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # PI => 3.1415.. => 3
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(3));
        }
      }
    return $y;
    }

  return $upgrade->new($y)->batan2($upgrade->new($x),@@r) if defined $upgrade;

  require Math::BigFloat;
  my $r = Math::BigFloat->new($y)->batan2(Math::BigFloat->new($x),@@r)->as_int();

  $x->{value} = $r->{value};
  $x->{sign} = $r->{sign};

  $x;
  }

sub batan
  {
  # Calculate arcus tangens of x to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('batan');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN

  return $upgrade->new($x)->batan(@@r) if defined $upgrade;

  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->batan(@@r);

  $x->{value} = $CALC->_new( $x->as_int()->bstr() );
  $x->round(@@r);
  }

###############################################################################
# this method returns 0 if the object can be modified, or 1 if not.
# We use a fast constant sub() here, to avoid costly calls. Subclasses
# may override it with special code (f.i. Math::BigInt::Constant does so)

sub modify () { 0; }

1;
__END__

=pod

=head1 NAME

Math::BigInt - Arbitrary size integer/float math package

=head1 SYNOPSIS

  use Math::BigInt;

  # or make it faster with huge numbers: install (optional)
  # Math::BigInt::GMP and always use (it will fall back to
  # pure Perl if the GMP library is not installed):
  # (See also the L<MATH LIBRARY> section!)

  # will warn if Math::BigInt::GMP cannot be found
  use Math::BigInt lib => 'GMP';

  # to supress the warning use this:
  # use Math::BigInt try => 'GMP';

  # dies if GMP cannot be loaded:
  # use Math::BigInt only => 'GMP';

  my $str = '1234567890';
  my @@values = (64,74,18);
  my $n = 1; my $sign = '-';

  # Number creation	
  my $x = Math::BigInt->new($str);	# defaults to 0
  my $y = $x->copy();			# make a true copy
  my $nan  = Math::BigInt->bnan(); 	# create a NotANumber
  my $zero = Math::BigInt->bzero();	# create a +0
  my $inf = Math::BigInt->binf();	# create a +inf
  my $inf = Math::BigInt->binf('-');	# create a -inf
  my $one = Math::BigInt->bone();	# create a +1
  my $mone = Math::BigInt->bone('-');	# create a -1

  my $pi = Math::BigInt->bpi();		# returns '3'
					# see Math::BigFloat::bpi()

  $h = Math::BigInt->new('0x123');	# from hexadecimal
  $b = Math::BigInt->new('0b101');	# from binary
  $o = Math::BigInt->from_oct('0101');	# from octal

  # Testing (don't modify their arguments)
  # (return true if the condition is met, otherwise false)

  $x->is_zero();	# if $x is +0
  $x->is_nan();		# if $x is NaN
  $x->is_one();		# if $x is +1
  $x->is_one('-');	# if $x is -1
  $x->is_odd();		# if $x is odd
  $x->is_even();	# if $x is even
  $x->is_pos();		# if $x >= 0
  $x->is_neg();		# if $x <  0
  $x->is_inf($sign);	# if $x is +inf, or -inf (sign is default '+')
  $x->is_int();		# if $x is an integer (not a float)

  # comparing and digit/sign extraction
  $x->bcmp($y);		# compare numbers (undef,<0,=0,>0)
  $x->bacmp($y);	# compare absolutely (undef,<0,=0,>0)
  $x->sign();		# return the sign, either +,- or NaN
  $x->digit($n);	# return the nth digit, counting from right
  $x->digit(-$n);	# return the nth digit, counting from left

  # The following all modify their first argument. If you want to preserve
  # $x, use $z = $x->copy()->bXXX($y); See under L<CAVEATS> for why this is
  # necessary when mixing $a = $b assignments with non-overloaded math.

  $x->bzero();		# set $x to 0
  $x->bnan();		# set $x to NaN
  $x->bone();		# set $x to +1
  $x->bone('-');	# set $x to -1
  $x->binf();		# set $x to inf
  $x->binf('-');	# set $x to -inf

  $x->bneg();		# negation
  $x->babs();		# absolute value
  $x->bnorm();		# normalize (no-op in BigInt)
  $x->bnot();		# two's complement (bit wise not)
  $x->binc();		# increment $x by 1
  $x->bdec();		# decrement $x by 1
  
  $x->badd($y);		# addition (add $y to $x)
  $x->bsub($y);		# subtraction (subtract $y from $x)
  $x->bmul($y);		# multiplication (multiply $x by $y)
  $x->bdiv($y);		# divide, set $x to quotient
			# return (quo,rem) or quo if scalar

  $x->bmuladd($y,$z);	# $x = $x * $y + $z

  $x->bmod($y);		   # modulus (x % y)
  $x->bmodpow($exp,$mod);  # modular exponentation (($num**$exp) % $mod))
  $x->bmodinv($mod);	   # the inverse of $x in the given modulus $mod

  $x->bpow($y);		   # power of arguments (x ** y)
  $x->blsft($y);	   # left shift in base 2
  $x->brsft($y);	   # right shift in base 2
			   # returns (quo,rem) or quo if in scalar context
  $x->blsft($y,$n);	   # left shift by $y places in base $n
  $x->brsft($y,$n);	   # right shift by $y places in base $n
			   # returns (quo,rem) or quo if in scalar context
  
  $x->band($y);		   # bitwise and
  $x->bior($y);		   # bitwise inclusive or
  $x->bxor($y);		   # bitwise exclusive or
  $x->bnot();		   # bitwise not (two's complement)

  $x->bsqrt();		   # calculate square-root
  $x->broot($y);	   # $y'th root of $x (e.g. $y == 3 => cubic root)
  $x->bfac();		   # factorial of $x (1*2*3*4*..$x)

  $x->bnok($y);		   # x over y (binomial coefficient n over k)

  $x->blog();		   # logarithm of $x to base e (Euler's number)
  $x->blog($base);	   # logarithm of $x to base $base (f.i. 2)
  $x->bexp();		   # calculate e ** $x where e is Euler's number
  
  $x->round($A,$P,$mode);  # round to accuracy or precision using mode $mode
  $x->bround($n);	   # accuracy: preserve $n digits
  $x->bfround($n);	   # $n > 0: round $nth digits,
			   # $n < 0: round to the $nth digit after the
			   # dot, no-op for BigInts

  # The following do not modify their arguments in BigInt (are no-ops),
  # but do so in BigFloat:

  $x->bfloor();		   # return integer less or equal than $x
  $x->bceil();		   # return integer greater or equal than $x
  
  # The following do not modify their arguments:

  # greatest common divisor (no OO style)
  my $gcd = Math::BigInt::bgcd(@@values);
  # lowest common multiplicator (no OO style)
  my $lcm = Math::BigInt::blcm(@@values);	
 
  $x->length();		   # return number of digits in number
  ($xl,$f) = $x->length(); # length of number and length of fraction part,
			   # latter is always 0 digits long for BigInts

  $x->exponent();	   # return exponent as BigInt
  $x->mantissa();	   # return (signed) mantissa as BigInt
  $x->parts();		   # return (mantissa,exponent) as BigInt
  $x->copy();		   # make a true copy of $x (unlike $y = $x;)
  $x->as_int();		   # return as BigInt (in BigInt: same as copy())
  $x->numify();		   # return as scalar (might overflow!)
  
  # conversation to string (do not modify their argument)
  $x->bstr();		   # normalized string (e.g. '3')
  $x->bsstr();		   # norm. string in scientific notation (e.g. '3E0')
  $x->as_hex();		   # as signed hexadecimal string with prefixed 0x
  $x->as_bin();		   # as signed binary string with prefixed 0b
  $x->as_oct();		   # as signed octal string with prefixed 0


  # precision and accuracy (see section about rounding for more)
  $x->precision();	   # return P of $x (or global, if P of $x undef)
  $x->precision($n);	   # set P of $x to $n
  $x->accuracy();	   # return A of $x (or global, if A of $x undef)
  $x->accuracy($n);	   # set A $x to $n

  # Global methods
  Math::BigInt->precision();	# get/set global P for all BigInt objects
  Math::BigInt->accuracy(); 	# get/set global A for all BigInt objects
  Math::BigInt->round_mode();	# get/set global round mode, one of
				# 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
  Math::BigInt->config();	# return hash containing configuration

=head1 DESCRIPTION

All operators (including basic math operations) are overloaded if you
declare your big integers as

  $i = new Math::BigInt '123_456_789_123_456_789';

Operations with overloaded operators preserve the arguments which is
exactly what you expect.

=over 2

=item Input

Input values to these routines may be any string, that looks like a number
and results in an integer, including hexadecimal and binary numbers.

Scalars holding numbers may also be passed, but note that non-integer numbers
may already have lost precision due to the conversation to float. Quote
your input if you want BigInt to see all the digits:

	$x = Math::BigInt->new(12345678890123456789);	# bad
	$x = Math::BigInt->new('12345678901234567890');	# good

You can include one underscore between any two digits.

This means integer values like 1.01E2 or even 1000E-2 are also accepted.
Non-integer values result in NaN.

Hexadecimal (prefixed with "0x") and binary numbers (prefixed with "0b")
are accepted, too. Please note that octal numbers are not recognized
by new(), so the following will print "123":

	perl -MMath::BigInt -le 'print Math::BigInt->new("0123")'
	
To convert an octal number, use from_oct();

	perl -MMath::BigInt -le 'print Math::BigInt->from_oct("0123")'

Currently, Math::BigInt::new() defaults to 0, while Math::BigInt::new('')
results in 'NaN'. This might change in the future, so use always the following
explicit forms to get a zero or NaN:

	$zero = Math::BigInt->bzero(); 
	$nan = Math::BigInt->bnan(); 

C<bnorm()> on a BigInt object is now effectively a no-op, since the numbers 
are always stored in normalized form. If passed a string, creates a BigInt 
object from the input.

=item Output

Output values are BigInt objects (normalized), except for the methods which
return a string (see L<SYNOPSIS>).

Some routines (C<is_odd()>, C<is_even()>, C<is_zero()>, C<is_one()>,
C<is_nan()>, etc.) return true or false, while others (C<bcmp()>, C<bacmp()>)
return either undef (if NaN is involved), <0, 0 or >0 and are suited for sort.

=back

=head1 METHODS

Each of the methods below (except config(), accuracy() and precision())
accepts three additional parameters. These arguments C<$A>, C<$P> and C<$R>
are C<accuracy>, C<precision> and C<round_mode>. Please see the section about
L<ACCURACY and PRECISION> for more information.

=head2 config()

	use Data::Dumper;

	print Dumper ( Math::BigInt->config() );
	print Math::BigInt->config()->{lib},"\n";

Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.

	key		Description
			Example
	============================================================
	lib		Name of the low-level math library
			Math::BigInt::Calc
	lib_version 	Version of low-level math library (see 'lib')
			0.30
	class		The class name of config() you just called
			Math::BigInt
	upgrade		To which class math operations might be upgraded
			Math::BigFloat
	downgrade	To which class math operations might be downgraded
			undef
	precision	Global precision
			undef
	accuracy	Global accuracy
			undef
	round_mode	Global round mode
			even
	version		version number of the class you used
			1.61
	div_scale	Fallback accuracy for div
			40
	trap_nan	If true, traps creation of NaN via croak()
			1
	trap_inf	If true, traps creation of +inf/-inf via croak()
			1

The following values can be set by passing C<config()> a reference to a hash:

	trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale

Example:
	
	$new_cfg = Math::BigInt->config( { trap_inf => 1, precision => 5 } );

=head2 accuracy()

	$x->accuracy(5);		# local for $x
	CLASS->accuracy(5);		# global for all members of CLASS
					# Note: This also applies to new()!

	$A = $x->accuracy();		# read out accuracy that affects $x
	$A = CLASS->accuracy();		# read out global accuracy

Set or get the global or local accuracy, aka how many significant digits the
results have. If you set a global accuracy, then this also applies to new()!

Warning! The accuracy I<sticks>, e.g. once you created a number under the
influence of C<< CLASS->accuracy($A) >>, all results from math operations with
that number will also be rounded. 

In most cases, you should probably round the results explicitly using one of
L<round()>, L<bround()> or L<bfround()> or by passing the desired accuracy
to the math operation as additional parameter:

        my $x = Math::BigInt->new(30000);
        my $y = Math::BigInt->new(7);
        print scalar $x->copy()->bdiv($y, 2);		# print 4300
        print scalar $x->copy()->bdiv($y)->bround(2);	# print 4300

Please see the section about L<ACCURACY AND PRECISION> for further details.

Value must be greater than zero. Pass an undef value to disable it:

	$x->accuracy(undef);
	Math::BigInt->accuracy(undef);

Returns the current accuracy. For C<$x->accuracy()> it will return either the
local accuracy, or if not defined, the global. This means the return value
represents the accuracy that will be in effect for $x:

	$y = Math::BigInt->new(1234567);	# unrounded
	print Math::BigInt->accuracy(4),"\n";	# set 4, print 4
	$x = Math::BigInt->new(123456);		# $x will be automatically rounded!
	print "$x $y\n";			# '123500 1234567'
	print $x->accuracy(),"\n";		# will be 4
	print $y->accuracy(),"\n";		# also 4, since global is 4
	print Math::BigInt->accuracy(5),"\n";	# set to 5, print 5
	print $x->accuracy(),"\n";		# still 4
	print $y->accuracy(),"\n";		# 5, since global is 5

Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

=head2 precision()

	$x->precision(-2);	# local for $x, round at the second digit right of the dot
	$x->precision(2);	# ditto, round at the second digit left of the dot

	CLASS->precision(5);	# Global for all members of CLASS
				# This also applies to new()!
	CLASS->precision(-5);	# ditto

	$P = CLASS->precision();	# read out global precision 
	$P = $x->precision();		# read out precision that affects $x

Note: You probably want to use L<accuracy()> instead. With L<accuracy> you
set the number of digits each result should have, with L<precision> you
set the place where to round!

C<precision()> sets or gets the global or local precision, aka at which digit
before or after the dot to round all results. A set global precision also
applies to all newly created numbers!

In Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot. In L<Math::BigFloat>, it will round all
results to P digits after the dot.

Please see the section about L<ACCURACY AND PRECISION> for further details.

Pass an undef value to disable it:

	$x->precision(undef);
	Math::BigInt->precision(undef);

Returns the current precision. For C<$x->precision()> it will return either the
local precision of $x, or if not defined, the global. This means the return
value represents the prevision that will be in effect for $x:

	$y = Math::BigInt->new(1234567);	# unrounded
	print Math::BigInt->precision(4),"\n";	# set 4, print 4
	$x = Math::BigInt->new(123456);		# will be automatically rounded
	print $x;				# print "120000"!

Note: Works also for subclasses like L<Math::BigFloat>. Each class has its
own globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

=head2 brsft()

	$x->brsft($y,$n);		

Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and
2, but others work, too.

Right shifting usually amounts to dividing $x by $n ** $y and truncating the
result:


	$x = Math::BigInt->new(10);
	$x->brsft(1);			# same as $x >> 1: 5
	$x = Math::BigInt->new(1234);
	$x->brsft(2,10);		# result 12

There is one exception, and that is base 2 with negative $x:


	$x = Math::BigInt->new(-5);
	print $x->brsft(1);

This will print -3, not -2 (as it would if you divide -5 by 2 and truncate the
result).

=head2 new()

  	$x = Math::BigInt->new($str,$A,$P,$R);

Creates a new BigInt object from a scalar or another BigInt object. The
input is accepted as decimal, hex (with leading '0x') or binary (with leading
'0b').

See L<Input> for more info on accepted input formats.

=head2 from_oct()

	$x = Math::BigInt->from_oct("0775");	# input is octal

=head2 from_hex()

	$x = Math::BigInt->from_hex("0xcafe");	# input is hexadecimal

=head2 from_bin()

	$x = Math::BigInt->from_oct("0x10011");	# input is binary

=head2 bnan()

  	$x = Math::BigInt->bnan();

Creates a new BigInt object representing NaN (Not A Number).
If used on an object, it will set it to NaN:

	$x->bnan();

=head2 bzero()

  	$x = Math::BigInt->bzero();

Creates a new BigInt object representing zero.
If used on an object, it will set it to zero:

	$x->bzero();

=head2 binf()

  	$x = Math::BigInt->binf($sign);

Creates a new BigInt object representing infinity. The optional argument is
either '-' or '+', indicating whether you want infinity or minus infinity.
If used on an object, it will set it to infinity:

	$x->binf();
	$x->binf('-');

=head2 bone()

  	$x = Math::BigInt->binf($sign);

Creates a new BigInt object representing one. The optional argument is
either '-' or '+', indicating whether you want one or minus one.
If used on an object, it will set it to one:

	$x->bone();		# +1
	$x->bone('-');		# -1

=head2 is_one()/is_zero()/is_nan()/is_inf()

  
	$x->is_zero();			# true if arg is +0
	$x->is_nan();			# true if arg is NaN
	$x->is_one();			# true if arg is +1
	$x->is_one('-');		# true if arg is -1
	$x->is_inf();			# true if +inf
	$x->is_inf('-');		# true if -inf (sign is default '+')

These methods all test the BigInt for being one specific value and return
true or false depending on the input. These are faster than doing something
like:

	if ($x == 0)

=head2 is_pos()/is_neg()/is_positive()/is_negative()
	
	$x->is_pos();			# true if > 0
	$x->is_neg();			# true if < 0

The methods return true if the argument is positive or negative, respectively.
C<NaN> is neither positive nor negative, while C<+inf> counts as positive, and
C<-inf> is negative. A C<zero> is neither positive nor negative.

These methods are only testing the sign, and not the value.

C<is_positive()> and C<is_negative()> are aliases to C<is_pos()> and
C<is_neg()>, respectively. C<is_positive()> and C<is_negative()> were
introduced in v1.36, while C<is_pos()> and C<is_neg()> were only introduced
in v1.68.

=head2 is_odd()/is_even()/is_int()

	$x->is_odd();			# true if odd, false for even
	$x->is_even();			# true if even, false for odd
	$x->is_int();			# true if $x is an integer

The return true when the argument satisfies the condition. C<NaN>, C<+inf>,
C<-inf> are not integers and are neither odd nor even.

In BigInt, all numbers except C<NaN>, C<+inf> and C<-inf> are integers.

=head2 bcmp()

	$x->bcmp($y);

Compares $x with $y and takes the sign into account.
Returns -1, 0, 1 or undef.

=head2 bacmp()

	$x->bacmp($y);

Compares $x with $y while ignoring their. Returns -1, 0, 1 or undef.

=head2 sign()

	$x->sign();

Return the sign, of $x, meaning either C<+>, C<->, C<-inf>, C<+inf> or NaN.

If you want $x to have a certain sign, use one of the following methods:

	$x->babs();		# '+'
	$x->babs()->bneg();	# '-'
	$x->bnan();		# 'NaN'
	$x->binf();		# '+inf'
	$x->binf('-');		# '-inf'

=head2 digit()

	$x->digit($n);		# return the nth digit, counting from right

If C<$n> is negative, returns the digit counting from left.

=head2 bneg()

	$x->bneg();

Negate the number, e.g. change the sign between '+' and '-', or between '+inf'
and '-inf', respectively. Does nothing for NaN or zero.

=head2 babs()

	$x->babs();

Set the number to its absolute value, e.g. change the sign from '-' to '+'
and from '-inf' to '+inf', respectively. Does nothing for NaN or positive
numbers.

=head2 bnorm()

	$x->bnorm();			# normalize (no-op)

=head2 bnot()

	$x->bnot();			

Two's complement (bitwise not). This is equivalent to

	$x->binc()->bneg();

but faster.

=head2 binc()

	$x->binc();			# increment x by 1

=head2 bdec()

	$x->bdec();			# decrement x by 1

=head2 badd()

	$x->badd($y);			# addition (add $y to $x)

=head2 bsub()

	$x->bsub($y);			# subtraction (subtract $y from $x)

=head2 bmul()

	$x->bmul($y);			# multiplication (multiply $x by $y)

=head2 bmuladd()

	$x->bmuladd($y,$z);

Multiply $x by $y, and then add $z to the result,

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 bdiv()

	$x->bdiv($y);			# divide, set $x to quotient
					# return (quo,rem) or quo if scalar

=head2 bmod()

	$x->bmod($y);			# modulus (x % y)

=head2 bmodinv()

	num->bmodinv($mod);		# modular inverse

Returns the inverse of C<$num> in the given modulus C<$mod>.  'C<NaN>' is
returned unless C<$num> is relatively prime to C<$mod>, i.e. unless
C<bgcd($num, $mod)==1>.

=head2 bmodpow()

	$num->bmodpow($exp,$mod);	# modular exponentation
					# ($num**$exp % $mod)

Returns the value of C<$num> taken to the power C<$exp> in the modulus
C<$mod> using binary exponentation.  C<bmodpow> is far superior to
writing

	$num ** $exp % $mod

because it is much faster - it reduces internal variables into
the modulus whenever possible, so it operates on smaller numbers.

C<bmodpow> also supports negative exponents.

	bmodpow($num, -1, $mod)

is exactly equivalent to

	bmodinv($num, $mod)

=head2 bpow()

	$x->bpow($y);			# power of arguments (x ** y)

=head2 blog()

	$x->blog($base, $accuracy);	# logarithm of x to the base $base

If C<$base> is not defined, Euler's number (e) is used:

	print $x->blog(undef, 100);	# log(x) to 100 digits

=head2 bexp()

	$x->bexp($accuracy);		# calculate e ** X

Calculates the expression C<e ** $x> where C<e> is Euler's number.

This method was added in v1.82 of Math::BigInt (April 2007).

See also L<blog()>.

=head2 bnok()

	$x->bnok($y);		   # x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

	( n )      n!
	| - |  = -------
	( k )    k!(n-k)!

This method was added in v1.84 of Math::BigInt (April 2007).

=head2 bpi()

	print Math::BigInt->bpi(100), "\n";		# 3

Returns PI truncated to an integer, with the argument being ignored. This means
under BigInt this always returns C<3>.

If upgrading is in effect, returns PI, rounded to N digits with the
current rounding mode:

	use Math::BigFloat;
	use Math::BigInt upgrade => Math::BigFloat;
	print Math::BigInt->bpi(3), "\n";		# 3.14
	print Math::BigInt->bpi(100), "\n";		# 3.1415....

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 bcos()

	my $x = Math::BigInt->new(1);
	print $x->bcos(100), "\n";

Calculate the cosinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 bsin()

	my $x = Math::BigInt->new(1);
	print $x->bsin(100), "\n";

Calculate the sinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 batan2()

	my $x = Math::BigInt->new(1);
	my $y = Math::BigInt->new(1);
	print $y->batan2($x), "\n";

Calculate the arcus tangens of C<$y> divided by C<$x>, modifying $y in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 batan()

	my $x = Math::BigFloat->new(0.5);
	print $x->batan(100), "\n";

Calculate the arcus tangens of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 blsft()

	$x->blsft($y);		# left shift in base 2
	$x->blsft($y,$n);	# left shift, in base $n (like 10)

=head2 brsft()

	$x->brsft($y);		# right shift in base 2
	$x->brsft($y,$n);	# right shift, in base $n (like 10)

=head2 band()

	$x->band($y);			# bitwise and

=head2 bior()

	$x->bior($y);			# bitwise inclusive or

=head2 bxor()

	$x->bxor($y);			# bitwise exclusive or

=head2 bnot()

	$x->bnot();			# bitwise not (two's complement)

=head2 bsqrt()

	$x->bsqrt();			# calculate square-root

=head2 broot()

	$x->broot($N);

Calculates the N'th root of C<$x>.

=head2 bfac()

	$x->bfac();			# factorial of $x (1*2*3*4*..$x)

=head2 round()

	$x->round($A,$P,$round_mode);
	
Round $x to accuracy C<$A> or precision C<$P> using the round mode
C<$round_mode>.

=head2 bround()

	$x->bround($N);               # accuracy: preserve $N digits

=head2 bfround()

	$x->bfround($N);

If N is > 0, rounds to the Nth digit from the left. If N < 0, rounds to
the Nth digit after the dot. Since BigInts are integers, the case N < 0
is a no-op for them.

Examples:

	Input		N		Result
	===================================================
	123456.123456	3		123500
	123456.123456	2		123450
	123456.123456	-2		123456.12
	123456.123456	-3		123456.123

=head2 bfloor()

	$x->bfloor();			

Set $x to the integer less or equal than $x. This is a no-op in BigInt, but
does change $x in BigFloat.

=head2 bceil()

	$x->bceil();

Set $x to the integer greater or equal than $x. This is a no-op in BigInt, but
does change $x in BigFloat.

=head2 bgcd()

	bgcd(@@values);		# greatest common divisor (no OO style)

=head2 blcm()

	blcm(@@values);		# lowest common multiplicator (no OO style)
 
head2 length()

	$x->length();
        ($xl,$fl) = $x->length();

Returns the number of digits in the decimal representation of the number.
In list context, returns the length of the integer and fraction part. For
BigInt's, the length of the fraction part will always be 0.

=head2 exponent()

	$x->exponent();

Return the exponent of $x as BigInt.

=head2 mantissa()

	$x->mantissa();

Return the signed mantissa of $x as BigInt.

=head2 parts()

	$x->parts();		# return (mantissa,exponent) as BigInt

=head2 copy()

	$x->copy();		# make a true copy of $x (unlike $y = $x;)

=head2 as_int()/as_number()

	$x->as_int();	

Returns $x as a BigInt (truncated towards zero). In BigInt this is the same as
C<copy()>. 

C<as_number()> is an alias to this method. C<as_number> was introduced in
v1.22, while C<as_int()> was only introduced in v1.68.
  
=head2 bstr()

	$x->bstr();

Returns a normalized string representation of C<$x>.

=head2 bsstr()

	$x->bsstr();		# normalized string in scientific notation

=head2 as_hex()

	$x->as_hex();		# as signed hexadecimal string with prefixed 0x

=head2 as_bin()

	$x->as_bin();		# as signed binary string with prefixed 0b

=head2 as_oct()

	$x->as_oct();		# as signed octal string with prefixed 0

=head2 numify()

	print $x->numify();

This returns a normal Perl scalar from $x. It is used automatically
whenever a scalar is needed, for instance in array index operations.

This loses precision, to avoid this use L<as_int()> instead.

=head2 modify()

	$x->modify('bpowd');

This method returns 0 if the object can be modified with the given
peration, or 1 if not.

This is used for instance by L<Math::BigInt::Constant>.

=head2 upgrade()/downgrade()

Set/get the class for downgrade/upgrade operations. Thuis is used
for instance by L<bignum>. The defaults are '', thus the following
operation will create a BigInt, not a BigFloat:

	my $i = Math::BigInt->new(123);
	my $f = Math::BigFloat->new('123.1');

	print $i + $f,"\n";			# print 246

=head2 div_scale()

Set/get the number of digits for the default precision in divide
operations.

=head2 round_mode()

Set/get the current round mode.

=head1 ACCURACY and PRECISION

Since version v1.33, Math::BigInt and Math::BigFloat have full support for
accuracy and precision based rounding, both automatically after every
operation, as well as manually.

This section describes the accuracy/precision handling in Math::Big* as it
used to be and as it is now, complete with an explanation of all terms and
abbreviations.

Not yet implemented things (but with correct description) are marked with '!',
things that need to be answered are marked with '?'.

In the next paragraph follows a short description of terms used here (because
these may differ from terms used by others people or documentation).

During the rest of this document, the shortcuts A (for accuracy), P (for
precision), F (fallback) and R (rounding mode) will be used.

=head2 Precision P

A fixed number of digits before (positive) or after (negative)
the decimal point. For example, 123.45 has a precision of -2. 0 means an
integer like 123 (or 120). A precision of 2 means two digits to the left
of the decimal point are zero, so 123 with P = 1 becomes 120. Note that
numbers with zeros before the decimal point may have different precisions,
because 1200 can have p = 0, 1 or 2 (depending on what the inital value
was). It could also have p < 0, when the digits after the decimal point
are zero.

The string output (of floating point numbers) will be padded with zeros:
 
	Initial value   P       A	Result          String
	------------------------------------------------------------
	1234.01         -3      	1000            1000
	1234            -2      	1200            1200
	1234.5          -1      	1230            1230
	1234.001        1       	1234            1234.0
	1234.01         0       	1234            1234
	1234.01         2       	1234.01		1234.01
	1234.01         5       	1234.01		1234.01000

For BigInts, no padding occurs.

=head2 Accuracy A

Number of significant digits. Leading zeros are not counted. A
number may have an accuracy greater than the non-zero digits
when there are zeros in it or trailing zeros. For example, 123.456 has
A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.

The string output (of floating point numbers) will be padded with zeros:

	Initial value   P       A	Result          String
	------------------------------------------------------------
	1234.01			3	1230		1230
	1234.01			6	1234.01		1234.01
	1234.1			8	1234.1		1234.1000

For BigInts, no padding occurs.

=head2 Fallback F

When both A and P are undefined, this is used as a fallback accuracy when
dividing numbers.

=head2 Rounding mode R

When rounding a number, different 'styles' or 'kinds'
of rounding are possible. (Note that random rounding, as in
Math::Round, is not implemented.)

=over 2

=item 'trunc'

truncation invariably removes all digits following the
rounding place, replacing them with zeros. Thus, 987.65 rounded
to tens (P=1) becomes 980, and rounded to the fourth sigdig
becomes 987.6 (A=4). 123.456 rounded to the second place after the
decimal point (P=-2) becomes 123.46.

All other implemented styles of rounding attempt to round to the
"nearest digit." If the digit D immediately to the right of the
rounding place (skipping the decimal point) is greater than 5, the
number is incremented at the rounding place (possibly causing a
cascade of incrementation): e.g. when rounding to units, 0.9 rounds
to 1, and -19.9 rounds to -20. If D < 5, the number is similarly
truncated at the rounding place: e.g. when rounding to units, 0.4
rounds to 0, and -19.4 rounds to -19.

However the results of other styles of rounding differ if the
digit immediately to the right of the rounding place (skipping the
decimal point) is 5 and if there are no digits, or no digits other
than 0, after that 5. In such cases:

=item 'even'

rounds the digit at the rounding place to 0, 2, 4, 6, or 8
if it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.4, -0.55 becomes -0.6, but 0.4501 becomes 0.5.

=item 'odd'

rounds the digit at the rounding place to 1, 3, 5, 7, or 9 if
it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.5, -0.55 becomes -0.5, but 0.5501 becomes 0.6.

=item '+inf'

round to plus infinity, i.e. always round up. E.g., when
rounding to the first sigdig, 0.45 becomes 0.5, -0.55 becomes -0.5,
and 0.4501 also becomes 0.5.

=item '-inf'

round to minus infinity, i.e. always round down. E.g., when
rounding to the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.6,
but 0.4501 becomes 0.5.

=item 'zero'

round to zero, i.e. positive numbers down, negative ones up.
E.g., when rounding to the first sigdig, 0.45 becomes 0.4, -0.55
becomes -0.5, but 0.4501 becomes 0.5.

=item 'common'

round up if the digit immediately to the right of the rounding place
is 5 or greater, otherwise round down. E.g., 0.15 becomes 0.2 and
0.149 becomes 0.1.

=back

The handling of A & P in MBI/MBF (the old core code shipped with Perl
versions <= 5.7.2) is like this:

=over 2

=item Precision

  * ffround($p) is able to round to $p number of digits after the decimal
    point
  * otherwise P is unused

=item Accuracy (significant digits)

  * fround($a) rounds to $a significant digits
  * only fdiv() and fsqrt() take A as (optional) paramater
    + other operations simply create the same number (fneg etc), or more (fmul)
      of digits
    + rounding/truncating is only done when explicitly calling one of fround
      or ffround, and never for BigInt (not implemented)
  * fsqrt() simply hands its accuracy argument over to fdiv.
  * the documentation and the comment in the code indicate two different ways
    on how fdiv() determines the maximum number of digits it should calculate,
    and the actual code does yet another thing
    POD:
      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
    Comment:
      result has at most max(scale, length(dividend), length(divisor)) digits
    Actual code:
      scale = max(scale, length(dividend)-1,length(divisor)-1);
      scale += length(divisor) - length(dividend);
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10+9-3).
    Actually, the 'difference' added to the scale is calculated from the
    number of "significant digits" in dividend and divisor, which is derived
    by looking at the length of the mantissa. Which is wrong, since it includes
    the + sign (oops) and actually gets 2 for '+100' and 4 for '+101'. Oops
    again. Thus 124/3 with div_scale=1 will get you '41.3' based on the strange
    assumption that 124 has 3 significant digits, while 120/7 will get you
    '17', not '17.1' since 120 is thought to have 2 significant digits.
    The rounding after the division then uses the remainder and $y to determine
    wether it must round up or down.
 ?  I have no idea which is the right way. That's why I used a slightly more
 ?  simple scheme and tweaked the few failing testcases to match it.

=back

This is how it works now:

=over 2

=item Setting/Accessing

  * You can set the A global via C<< Math::BigInt->accuracy() >> or
    C<< Math::BigFloat->accuracy() >> or whatever class you are using.
  * You can also set P globally by using C<< Math::SomeClass->precision() >>
    likewise.
  * Globals are classwide, and not inherited by subclasses.
  * to undefine A, use C<< Math::SomeCLass->accuracy(undef); >>
  * to undefine P, use C<< Math::SomeClass->precision(undef); >>
  * Setting C<< Math::SomeClass->accuracy() >> clears automatically
    C<< Math::SomeClass->precision() >>, and vice versa.
  * To be valid, A must be > 0, P can have any value.
  * If P is negative, this means round to the P'th place to the right of the
    decimal point; positive values mean to the left of the decimal point.
    P of 0 means round to integer.
  * to find out the current global A, use C<< Math::SomeClass->accuracy() >>
  * to find out the current global P, use C<< Math::SomeClass->precision() >>
  * use C<< $x->accuracy() >> respective C<< $x->precision() >> for the local
    setting of C<< $x >>.
  * Please note that C<< $x->accuracy() >> respective C<< $x->precision() >>
    return eventually defined global A or P, when C<< $x >>'s A or P is not
    set.

=item Creating numbers

  * When you create a number, you can give the desired A or P via:
    $x = Math::BigInt->new($number,$A,$P);
  * Only one of A or P can be defined, otherwise the result is NaN
  * If no A or P is give ($x = Math::BigInt->new($number) form), then the
    globals (if set) will be used. Thus changing the global defaults later on
    will not change the A or P of previously created numbers (i.e., A and P of
    $x will be what was in effect when $x was created)
  * If given undef for A and P, B<no> rounding will occur, and the globals will
    B<not> be used. This is used by subclasses to create numbers without
    suffering rounding in the parent. Thus a subclass is able to have its own
    globals enforced upon creation of a number by using
    C<< $x = Math::BigInt->new($number,undef,undef) >>:

	use Math::BigInt::SomeSubclass;
	use Math::BigInt;

	Math::BigInt->accuracy(2);
	Math::BigInt::SomeSubClass->accuracy(3);
	$x = Math::BigInt::SomeSubClass->new(1234);	

    $x is now 1230, and not 1200. A subclass might choose to implement
    this otherwise, e.g. falling back to the parent's A and P.

=item Usage

  * If A or P are enabled/defined, they are used to round the result of each
    operation according to the rules below
  * Negative P is ignored in Math::BigInt, since BigInts never have digits
    after the decimal point
  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
    Math::BigInt as globals does not tamper with the parts of a BigFloat.
    A flag is used to mark all Math::BigFloat numbers as 'never round'.

=item Precedence

  * It only makes sense that a number has only one of A or P at a time.
    If you set either A or P on one object, or globally, the other one will
    be automatically cleared.
  * If two objects are involved in an operation, and one of them has A in
    effect, and the other P, this results in an error (NaN).
  * A takes precedence over P (Hint: A comes before P).
    If neither of them is defined, nothing is used, i.e. the result will have
    as many digits as it can (with an exception for fdiv/fsqrt) and will not
    be rounded.
  * There is another setting for fdiv() (and thus for fsqrt()). If neither of
    A or P is defined, fdiv() will use a fallback (F) of $div_scale digits.
    If either the dividend's or the divisor's mantissa has more digits than
    the value of F, the higher value will be used instead of F.
    This is to limit the digits (A) of the result (just consider what would
    happen with unlimited A and P in the case of 1/3 :-)
  * fdiv will calculate (at least) 4 more digits than required (determined by
    A, P or F), and, if F is not used, round the result
    (this will still fail in the case of a result like 0.12345000000001 with A
    or P of 5, but this can not be helped - or can it?)
  * Thus you can have the math done by on Math::Big* class in two modi:
    + never round (this is the default):
      This is done by setting A and P to undef. No math operation
      will round the result, with fdiv() and fsqrt() as exceptions to guard
      against overflows. You must explicitly call bround(), bfround() or
      round() (the latter with parameters).
      Note: Once you have rounded a number, the settings will 'stick' on it
      and 'infect' all other numbers engaged in math operations with it, since
      local settings have the highest precedence. So, to get SaferRound[tm],
      use a copy() before rounding like this:

        $x = Math::BigFloat->new(12.34);
        $y = Math::BigFloat->new(98.76);
        $z = $x * $y;                           # 1218.6984
        print $x->copy()->fround(3);            # 12.3 (but A is now 3!)
        $z = $x * $y;                           # still 1218.6984, without
                                                # copy would have been 1210!

    + round after each op:
      After each single operation (except for testing like is_zero()), the
      method round() is called and the result is rounded appropriately. By
      setting proper values for A and P, you can have all-the-same-A or
      all-the-same-P modes. For example, Math::Currency might set A to undef,
      and P to -2, globally.

 ?Maybe an extra option that forbids local A & P settings would be in order,
 ?so that intermediate rounding does not 'poison' further math? 

=item Overriding globals

  * you will be able to give A, P and R as an argument to all the calculation
    routines; the second parameter is A, the third one is P, and the fourth is
    R (shift right by one for binary operations like badd). P is used only if
    the first parameter (A) is undefined. These three parameters override the
    globals in the order detailed as follows, i.e. the first defined value
    wins:
    (local: per object, global: global default, parameter: argument to sub)
      + parameter A
      + parameter P
      + local A (if defined on both of the operands: smaller one is taken)
      + local P (if defined on both of the operands: bigger one is taken)
      + global A
      + global P
      + global F
  * fsqrt() will hand its arguments to fdiv(), as it used to, only now for two
    arguments (A and P) instead of one

=item Local settings

  * You can set A or P locally by using C<< $x->accuracy() >> or
    C<< $x->precision() >>
    and thus force different A and P for different objects/numbers.
  * Setting A or P this way immediately rounds $x to the new value.
  * C<< $x->accuracy() >> clears C<< $x->precision() >>, and vice versa.

=item Rounding

  * the rounding routines will use the respective global or local settings.
    fround()/bround() is for accuracy rounding, while ffround()/bfround()
    is for precision
  * the two rounding functions take as the second parameter one of the
    following rounding modes (R):
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'
  * you can set/get the global R by using C<< Math::SomeClass->round_mode() >>
    or by setting C<< $Math::SomeClass::round_mode >>
  * after each operation, C<< $result->round() >> is called, and the result may
    eventually be rounded (that is, if A or P were set either locally,
    globally or as parameter to the operation)
  * to manually round a number, call C<< $x->round($A,$P,$round_mode); >>
    this will round the number by using the appropriate rounding function
    and then normalize it.
  * rounding modifies the local settings of the number:

        $x = Math::BigFloat->new(123.456);
        $x->accuracy(5);
        $x->bround(4);

    Here 4 takes precedence over 5, so 123.5 is the result and $x->accuracy()
    will be 4 from now on.

=item Default values

  * R: 'even'
  * F: 40
  * A: undef
  * P: undef

=item Remarks

  * The defaults are set up so that the new code gives the same results as
    the old code (except in a few cases on fdiv):
    + Both A and P are undefined and thus will not be used for rounding
      after each operation.
    + round() is thus a no-op, unless given extra parameters A and P

=back

=head1 Infinity and Not a Number

While BigInt has extensive handling of inf and NaN, certain quirks remain.

=over 2

=item oct()/hex()

These perl routines currently (as of Perl v.5.8.6) cannot handle passed
inf.

	te@@linux:~> perl -wle 'print 2 ** 3333'
	inf
	te@@linux:~> perl -wle 'print 2 ** 3333 == 2 ** 3333'
	1
	te@@linux:~> perl -wle 'print oct(2 ** 3333)'
	0
	te@@linux:~> perl -wle 'print hex(2 ** 3333)'
	Illegal hexadecimal digit 'i' ignored at -e line 1.
	0

The same problems occur if you pass them Math::BigInt->binf() objects. Since
overloading these routines is not possible, this cannot be fixed from BigInt.

=item ==, !=, <, >, <=, >= with NaNs

BigInt's bcmp() routine currently returns undef to signal that a NaN was
involved in a comparison. However, the overload code turns that into
either 1 or '' and thus operations like C<< NaN != NaN >> might return
wrong values.

=item log(-inf)

C<< log(-inf) >> is highly weird. Since log(-x)=pi*i+log(x), then
log(-inf)=pi*i+inf. However, since the imaginary part is finite, the real
infinity "overshadows" it, so the number might as well just be infinity.
However, the result is a complex number, and since BigInt/BigFloat can only
have real numbers as results, the result is NaN.

=item exp(), cos(), sin(), atan2()

These all might have problems handling infinity right.
 
=back

=head1 INTERNALS

The actual numbers are stored as unsigned big integers (with seperate sign).

You should neither care about nor depend on the internal representation; it
might change without notice. Use B<ONLY> method calls like C<< $x->sign(); >>
instead relying on the internal representation.

=head2 MATH LIBRARY

Math with the numbers is done (by default) by a module called
C<Math::BigInt::Calc>. This is equivalent to saying:

	use Math::BigInt try => 'Calc';

You can change this backend library by using:

	use Math::BigInt try => 'GMP';

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:

	use Math::BigInt only => 'GMP,Pari';

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

	use Math::BigInt try => 'Foo,Math::BigInt::Bar';

The library that is loaded last will be used. Note that this can be
overwritten at any time by loading a different library, and numbers
constructed with different libraries cannot be used in math operations
together.

=head3 What library to use?

B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

L<Math::BigInt::GMP> and L<Math::BigInt::Pari> are in cases involving big
numbers much faster than Calc, however it is slower when dealing with very
small numbers (less than about 20 digits) and when converting very large
numbers to decimal (for instance for printing, rounding, calculating their
length in decimal etc).

So please select carefully what libary you want to use.

Different low-level libraries use different formats to store the numbers.
However, you should B<NOT> depend on the number having a specific format
internally.

See the respective math library module documentation for further details.

=head2 SIGN

The sign is either '+', '-', 'NaN', '+inf' or '-inf'.

A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
'-inf' when dividing any negative number by 0.

=head2 mantissa(), exponent() and parts()

C<mantissa()> and C<exponent()> return the said parts of the BigInt such
that:

        $m = $x->mantissa();
        $e = $x->exponent();
        $y = $m * ( 10 ** $e );
        print "ok\n" if $x == $y;

C<< ($m,$e) = $x->parts() >> is just a shortcut that gives you both of them
in one go. Both the returned mantissa and exponent have a sign.

Currently, for BigInts C<$e> is always 0, except +inf and -inf, where it is
C<+inf>; and for NaN, where it is C<NaN>; and for C<$x == 0>, where it is C<1>
(to be compatible with Math::BigFloat's internal representation of a zero as
C<0E1>).

C<$m> is currently just a copy of the original number. The relation between
C<$e> and C<$m> will stay always the same, though their real values might
change.

=head1 EXAMPLES
 
  use Math::BigInt;

  sub bint { Math::BigInt->new(shift); }

  $x = Math::BigInt->bstr("1234")      	# string "1234"
  $x = "$x";                         	# same as bstr()
  $x = Math::BigInt->bneg("1234");   	# BigInt "-1234"
  $x = Math::BigInt->babs("-12345"); 	# BigInt "12345"
  $x = Math::BigInt->bnorm("-0.00"); 	# BigInt "0"
  $x = bint(1) + bint(2);            	# BigInt "3"
  $x = bint(1) + "2";                	# ditto (auto-BigIntify of "2")
  $x = bint(1);                      	# BigInt "1"
  $x = $x + 5 / 2;                   	# BigInt "3"
  $x = $x ** 3;                      	# BigInt "27"
  $x *= 2;                           	# BigInt "54"
  $x = Math::BigInt->new(0);       	# BigInt "0"
  $x--;                              	# BigInt "-1"
  $x = Math::BigInt->badd(4,5)		# BigInt "9"
  print $x->bsstr();			# 9e+0

Examples for rounding:

  use Math::BigFloat;
  use Test;

  $x = Math::BigFloat->new(123.4567);
  $y = Math::BigFloat->new(123.456789);
  Math::BigFloat->accuracy(4);		# no more A than 4

  ok ($x->copy()->fround(),123.4);	# even rounding
  print $x->copy()->fround(),"\n";	# 123.4
  Math::BigFloat->round_mode('odd');	# round to odd
  print $x->copy()->fround(),"\n";	# 123.5
  Math::BigFloat->accuracy(5);		# no more A than 5
  Math::BigFloat->round_mode('odd');	# round to odd
  print $x->copy()->fround(),"\n";	# 123.46
  $y = $x->copy()->fround(4),"\n";	# A = 4: 123.4
  print "$y, ",$y->accuracy(),"\n";	# 123.4, 4

  Math::BigFloat->accuracy(undef);	# A not important now
  Math::BigFloat->precision(2); 	# P important
  print $x->copy()->bnorm(),"\n";	# 123.46
  print $x->copy()->fround(),"\n";	# 123.46

Examples for converting:

  my $x = Math::BigInt->new('0b1'.'01' x 123);
  print "bin: ",$x->as_bin()," hex:",$x->as_hex()," dec: ",$x,"\n";

=head1 Autocreating constants

After C<use Math::BigInt ':constant'> all the B<integer> decimal, hexadecimal
and binary constants in the given scope are converted to C<Math::BigInt>.
This conversion happens at compile time. 

In particular,

  perl -MMath::BigInt=:constant -e 'print 2**100,"\n"'

prints the integer value of C<2**100>. Note that without conversion of 
constants the expression 2**100 will be calculated as perl scalar.

Please note that strings and floating point constants are not affected,
so that

  	use Math::BigInt qw/:constant/;

	$x = 1234567890123456789012345678901234567890
		+ 123456789123456789;
	$y = '1234567890123456789012345678901234567890'
		+ '123456789123456789';

do not work. You need an explicit Math::BigInt->new() around one of the
operands. You should also quote large constants to protect loss of precision:

	use Math::BigInt;

	$x = Math::BigInt->new('1234567889123456789123456789123456789');

Without the quotes Perl would convert the large number to a floating point
constant at compile time and then hand the result to BigInt, which results in
an truncated result or a NaN.

This also applies to integers that look like floating point constants:

	use Math::BigInt ':constant';

	print ref(123e2),"\n";
	print ref(123.2e2),"\n";

will print nothing but newlines. Use either L<bignum> or L<Math::BigFloat>
to get this to work.

=head1 PERFORMANCE

Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x
must be made in the second case. For long numbers, the copy can eat up to 20%
of the work (in the case of addition/subtraction, less for
multiplication/division). If $y is very small compared to $x, the form
$x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes
more time then the actual addition.

With a technique called copy-on-write, the cost of copying with overload could
be minimized or even completely avoided. A test implementation of COW did show
performance gains for overloaded math, but introduced a performance loss due
to a constant overhead for all other operations. So Math::BigInt does currently
not COW.

The rewritten version of this module (vs. v0.01) is slower on certain
operations, like C<new()>, C<bstr()> and C<numify()>. The reason are that it
does now more work and handles much more cases. The time spent in these
operations is usually gained in the other math operations so that code on
the average should get (much) faster. If they don't, please contact the author.

Some operations may be slower for small numbers, but are significantly faster
for big numbers. Other operations are now constant (O(1), like C<bneg()>,
C<babs()> etc), instead of O(N) and thus nearly always take much less time.
These optimizations were done on purpose.

If you find the Calc module to slow, try to install any of the replacement
modules and see if they help you. 

=head2 Alternative math libraries

You can use an alternative library to drive Math::BigInt. See the section
L<MATH LIBRARY> for more information.

For more benchmark results see L<http://bloodgate.com/perl/benchmarks.html>.

=head2 SUBCLASSING

=head1 Subclassing Math::BigInt

The basic design of Math::BigInt allows simple subclasses with very little
work, as long as a few simple rules are followed:

=over 2

=item *

The public API must remain consistent, i.e. if a sub-class is overloading
addition, the sub-class must use the same name, in this case badd(). The
reason for this is that Math::BigInt is optimized to call the object methods
directly.

=item *

The private object hash keys like C<$x->{sign}> may not be changed, but
additional keys can be added, like C<$x->{_custom}>.

=item *

Accessor functions are available for all existing object hash keys and should
be used instead of directly accessing the internal hash keys. The reason for
this is that Math::BigInt itself has a pluggable interface which permits it
to support different storage methods.

=back

More complex sub-classes may have to replicate more of the logic internal of
Math::BigInt if they need to change more basic behaviors. A subclass that
needs to merely change the output only needs to overload C<bstr()>. 

All other object methods and overloaded functions can be directly inherited
from the parent class.

At the very minimum, any subclass will need to provide its own C<new()> and can
store additional hash keys in the object. There are also some package globals
that must be defined, e.g.:

  # Globals
  $accuracy = undef;
  $precision = -2;       # round to 2 decimal places
  $round_mode = 'even';
  $div_scale = 40;

Additionally, you might want to provide the following two globals to allow
auto-upgrading and auto-downgrading to work correctly:

  $upgrade = undef;
  $downgrade = undef;

This allows Math::BigInt to correctly retrieve package globals from the 
subclass, like C<$SubClass::precision>.  See t/Math/BigInt/Subclass.pm or
t/Math/BigFloat/SubClass.pm completely functional subclass examples.

Don't forget to 

	use overload;

in your subclass to automatically inherit the overloading from the parent. If
you like, you can change part of the overloading, look at Math::String for an
example.

=head1 UPGRADING

When used like this:

	use Math::BigInt upgrade => 'Foo::Bar';

certain operations will 'upgrade' their calculation and thus the result to
the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:

	use Math::BigInt upgrade => 'Math::BigFloat';

As a shortcut, you can use the module C<bignum>:

	use bignum;

Also good for oneliners:

	perl -Mbignum -le 'print 2 ** 255'

This makes it possible to mix arguments of different classes (as in 2.5 + 2)
as well es preserve accuracy (as in sqrt(3)).

Beware: This feature is not fully implemented yet.

=head2 Auto-upgrade

The following methods upgrade themselves unconditionally; that is if upgrade
is in effect, they will always hand up their work:

=over 2

=item bsqrt()

=item div()

=item blog()

=item bexp()

=back

Beware: This list is not complete.

All other methods upgrade themselves only when one (or all) of their
arguments are of the class mentioned in $upgrade (This might change in later
versions to a more sophisticated scheme):

=head1 EXPORTS

C<Math::BigInt> exports nothing by default, but can export the following methods:

	bgcd
	blcm

=head1 CAVEATS

Some things might not work as you expect them. Below is documented what is
known to be troublesome:

=over 1

=item bstr(), bsstr() and 'cmp'

Both C<bstr()> and C<bsstr()> as well as automated stringify via overload now
drop the leading '+'. The old code would return '+3', the new returns '3'.
This is to be consistent with Perl and to make C<cmp> (especially with
overloading) to work as you expect. It also solves problems with C<Test.pm>,
because its C<ok()> uses 'eq' internally. 

Mark Biggar said, when asked about to drop the '+' altogether, or make only
C<cmp> work:

	I agree (with the first alternative), don't add the '+' on positive
	numbers.  It's not as important anymore with the new internal 
	form for numbers.  It made doing things like abs and neg easier,
	but those have to be done differently now anyway.

So, the following examples will now work all as expected:

	use Test;
        BEGIN { plan tests => 1 }
	use Math::BigInt;

	my $x = new Math::BigInt 3*3;
	my $y = new Math::BigInt 3*3;

	ok ($x,3*3);
	print "$x eq 9" if $x eq $y;
	print "$x eq 9" if $x eq '9';
	print "$x eq 9" if $x eq 3*3;

Additionally, the following still works:
	
	print "$x == 9" if $x == $y;
	print "$x == 9" if $x == 9;
	print "$x == 9" if $x == 3*3;

There is now a C<bsstr()> method to get the string in scientific notation aka
C<1e+2> instead of C<100>. Be advised that overloaded 'eq' always uses bstr()
for comparison, but Perl will represent some numbers as 100 and others
as 1e+308. If in doubt, convert both arguments to Math::BigInt before 
comparing them as strings:

	use Test;
        BEGIN { plan tests => 3 }
	use Math::BigInt;

	$x = Math::BigInt->new('1e56'); $y = 1e56;
	ok ($x,$y);			# will fail
	ok ($x->bsstr(),$y);		# okay
	$y = Math::BigInt->new($y);
	ok ($x,$y);			# okay

Alternatively, simple use C<< <=> >> for comparisons, this will get it
always right. There is not yet a way to get a number automatically represented
as a string that matches exactly the way Perl represents it.

See also the section about L<Infinity and Not a Number> for problems in
comparing NaNs.

=item int()

C<int()> will return (at least for Perl v5.7.1 and up) another BigInt, not a 
Perl scalar:

	$x = Math::BigInt->new(123);
	$y = int($x);				# BigInt 123
	$x = Math::BigFloat->new(123.45);
	$y = int($x);				# BigInt 123

In all Perl versions you can use C<as_number()> or C<as_int> for the same
effect:

	$x = Math::BigFloat->new(123.45);
	$y = $x->as_number();			# BigInt 123
	$y = $x->as_int();			# ditto

This also works for other subclasses, like Math::String.

If you want a real Perl scalar, use C<numify()>:

	$y = $x->numify();			# 123 as scalar

This is seldom necessary, though, because this is done automatically, like
when you access an array:

	$z = $array[$x];			# does work automatically

=item length

The following will probably not do what you expect:

	$c = Math::BigInt->new(123);
	print $c->length(),"\n";		# prints 30

It prints both the number of digits in the number and in the fraction part
since print calls C<length()> in list context. Use something like: 
	
	print scalar $c->length(),"\n";		# prints 3 

=item bdiv

The following will probably not do what you expect:

	print $c->bdiv(10000),"\n";

It prints both quotient and remainder since print calls C<bdiv()> in list
context. Also, C<bdiv()> will modify $c, so be careful. You probably want
to use
	
	print $c / 10000,"\n";
	print scalar $c->bdiv(10000),"\n";  # or if you want to modify $c

instead.

The quotient is always the greatest integer less than or equal to the
real-valued quotient of the two operands, and the remainder (when it is
nonzero) always has the same sign as the second operand; so, for
example,

	  1 / 4  => ( 0, 1)
	  1 / -4 => (-1,-3)
	 -3 / 4  => (-1, 1)
	 -3 / -4 => ( 0,-3)
	-11 / 2  => (-5,1)
	 11 /-2  => (-5,-1)

As a consequence, the behavior of the operator % agrees with the
behavior of Perl's built-in % operator (as documented in the perlop
manpage), and the equation

	$x == ($x / $y) * $y + ($x % $y)

holds true for any $x and $y, which justifies calling the two return
values of bdiv() the quotient and remainder. The only exception to this rule
are when $y == 0 and $x is negative, then the remainder will also be
negative. See below under "infinity handling" for the reasoning behind this.

Perl's 'use integer;' changes the behaviour of % and / for scalars, but will
not change BigInt's way to do things. This is because under 'use integer' Perl
will do what the underlying C thinks is right and this is different for each
system. If you need BigInt's behaving exactly like Perl's 'use integer', bug
the author to implement it ;)

=item infinity handling

Here are some examples that explain the reasons why certain results occur while
handling infinity:

The following table shows the result of the division and the remainder, so that
the equation above holds true. Some "ordinary" cases are strewn in to show more
clearly the reasoning:

	A /  B  =   C,     R so that C *    B +    R =    A
     =========================================================
	5 /   8 =   0,     5 	     0 *    8 +    5 =    5
	0 /   8 =   0,     0	     0 *    8 +    0 =    0
	0 / inf =   0,     0	     0 *  inf +    0 =    0
	0 /-inf =   0,     0	     0 * -inf +    0 =    0
	5 / inf =   0,     5	     0 *  inf +    5 =    5
	5 /-inf =   0,     5	     0 * -inf +    5 =    5
	-5/ inf =   0,    -5	     0 *  inf +   -5 =   -5
	-5/-inf =   0,    -5	     0 * -inf +   -5 =   -5
       inf/   5 =  inf,    0	   inf *    5 +    0 =  inf
      -inf/   5 = -inf,    0      -inf *    5 +    0 = -inf
       inf/  -5 = -inf,    0	  -inf *   -5 +    0 =  inf
      -inf/  -5 =  inf,    0       inf *   -5 +    0 = -inf
	 5/   5 =    1,    0         1 *    5 +    0 =    5
	-5/  -5 =    1,    0         1 *   -5 +    0 =   -5
       inf/ inf =    1,    0         1 *  inf +    0 =  inf
      -inf/-inf =    1,    0         1 * -inf +    0 = -inf
       inf/-inf =   -1,    0        -1 * -inf +    0 =  inf
      -inf/ inf =   -1,    0         1 * -inf +    0 = -inf
	 8/   0 =  inf,    8       inf *    0 +    8 =    8 
       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf 
         0/   0 =  NaN

These cases below violate the "remainder has the sign of the second of the two
arguments", since they wouldn't match up otherwise.

	A /  B  =   C,     R so that C *    B +    R =    A
     ========================================================
      -inf/   0 = -inf, -inf      -inf *    0 +  inf = -inf 
	-8/   0 = -inf,   -8      -inf *    0 +    8 = -8 

=item Modifying and =

Beware of:

        $x = Math::BigFloat->new(5);
        $y = $x;

It will not do what you think, e.g. making a copy of $x. Instead it just makes
a second reference to the B<same> object and stores it in $y. Thus anything
that modifies $x (except overloaded operators) will modify $y, and vice versa.
Or in other words, C<=> is only safe if you modify your BigInts only via
overloaded math. As soon as you use a method call it breaks:

        $x->bmul(2);
        print "$x, $y\n";       # prints '10, 10'

If you want a true copy of $x, use:

        $y = $x->copy();

You can also chain the calls like this, this will make first a copy and then
multiply it by 2:

        $y = $x->copy()->bmul(2);

See also the documentation for overload.pm regarding C<=>.

=item bpow

C<bpow()> (and the rounding functions) now modifies the first argument and
returns it, unlike the old code which left it alone and only returned the
result. This is to be consistent with C<badd()> etc. The first three will
modify $x, the last one won't:

	print bpow($x,$i),"\n"; 	# modify $x
	print $x->bpow($i),"\n"; 	# ditto
	print $x **= $i,"\n";		# the same
	print $x ** $i,"\n";		# leave $x alone 

The form C<$x **= $y> is faster than C<$x = $x ** $y;>, though.

=item Overloading -$x

The following:

	$x = -$x;

is slower than

	$x->bneg();

since overload calls C<sub($x,0,1);> instead of C<neg($x)>. The first variant
needs to preserve $x since it does not know that it later will get overwritten.
This makes a copy of $x and takes O(N), but $x->bneg() is O(1).

=item Mixing different object types

In Perl you will get a floating point value if you do one of the following:

	$float = 5.0 + 2;
	$float = 2 + 5.0;
	$float = 5 / 2;

With overloaded math, only the first two variants will result in a BigFloat:

	use Math::BigInt;
	use Math::BigFloat;
	
	$mbf = Math::BigFloat->new(5);
	$mbi2 = Math::BigInteger->new(5);
	$mbi = Math::BigInteger->new(2);

					# what actually gets called:
	$float = $mbf + $mbi;		# $mbf->badd()
	$float = $mbf / $mbi;		# $mbf->bdiv()
	$integer = $mbi + $mbf;		# $mbi->badd()
	$integer = $mbi2 / $mbi;	# $mbi2->bdiv()
	$integer = $mbi2 / $mbf;	# $mbi2->bdiv()

This is because math with overloaded operators follows the first (dominating)
operand, and the operation of that is called and returns thus the result. So,
Math::BigInt::bdiv() will always return a Math::BigInt, regardless whether
the result should be a Math::BigFloat or the second operant is one.

To get a Math::BigFloat you either need to call the operation manually,
make sure the operands are already of the proper type or casted to that type
via Math::BigFloat->new():
	
	$float = Math::BigFloat->new($mbi2) / $mbi;	# = 2.5

Beware of simple "casting" the entire expression, this would only convert
the already computed result:

	$float = Math::BigFloat->new($mbi2 / $mbi);	# = 2.0 thus wrong!

Beware also of the order of more complicated expressions like:

	$integer = ($mbi2 + $mbi) / $mbf;		# int / float => int
	$integer = $mbi2 / Math::BigFloat->new($mbi);	# ditto

If in doubt, break the expression into simpler terms, or cast all operands
to the desired resulting type.

Scalar values are a bit different, since:
	
	$float = 2 + $mbf;
	$float = $mbf + 2;

will both result in the proper type due to the way the overloaded math works.

This section also applies to other overloaded math packages, like Math::String.

One solution to you problem might be autoupgrading|upgrading. See the
pragmas L<bignum>, L<bigint> and L<bigrat> for an easy way to do this.

=item bsqrt()

C<bsqrt()> works only good if the result is a big integer, e.g. the square
root of 144 is 12, but from 12 the square root is 3, regardless of rounding
mode. The reason is that the result is always truncated to an integer.

If you want a better approximation of the square root, then use:

	$x = Math::BigFloat->new(12);
	Math::BigFloat->precision(0);
	Math::BigFloat->round_mode('even');
	print $x->copy->bsqrt(),"\n";		# 4

	Math::BigFloat->precision(2);
	print $x->bsqrt(),"\n";			# 3.46
	print $x->bsqrt(3),"\n";		# 3.464

=item brsft()

For negative numbers in base see also L<brsft|brsft>.

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<Math::BigFloat>, L<Math::BigRat> and L<Math::Big> as well as
L<Math::BigInt::BitVect>, L<Math::BigInt::Pari> and  L<Math::BigInt::GMP>.

The pragmas L<bignum>, L<bigint> and L<bigrat> also might be of interest
because they solve the autoupgrading/downgrading issue, at least partly.

The package at
L<http://search.cpan.org/search?mode=module&query=Math%3A%3ABigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.

=head1 AUTHORS

Original code by Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2006
and still at it in 2007.

Many people contributed in one or more ways to the final beast, see the file
CREDITS for an (incomplete) list. If you miss your name, please drop me a
mail. Thank you!

=cut
@


1.13
log
@Merge in perl 5.10.1
@
text
@@


1.12
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d21 1
a21 1
$VERSION = '1.88';
d3003 41
a3043 5
  return $y->bzero() if	$y->is_zero() && $x->{sign} eq '+';		# x >= 0

  # inf handling
  # +-inf => --PI/2 => +-1
  return $y->bone( substr($y->{sign},0,1) ) if $y->{sign} =~ /^[+-]inf$/;
d3095 4
a3098 3
  # or make it faster: install (optional) Math::BigInt::GMP
  # and always use (it will fall back to pure Perl if the
  # GMP library is not installed):
d3106 3
d4433 3
a4435 1
	use Math::BigInt lib => 'Calc';
d4437 1
a4437 1
You can change this by using:
d4439 8
a4446 1
	use Math::BigInt lib => 'BitVect';
d4451 8
a4458 1
	use Math::BigInt lib => 'Foo,Math::BigInt::Bar';
d4460 2
a4461 4
Since Math::BigInt::GMP is in almost all cases faster than Calc (especially in
math involving really big numbers, where it is B<much> faster), and there is
no penalty if Math::BigInt::GMP is not installed, it is a good idea to always
use the following:
d4463 5
a4467 1
	use Math::BigInt lib => 'GMP';
d4469 4
a4472 2
Different low-level libraries use different formats to store the
numbers. You should B<NOT> depend on the number having a specific format
d4634 2
a4635 5
You can use an alternative library to drive Math::BigInt via:

	use Math::BigInt lib => 'Module';

See L<MATH LIBRARY> for more information.
@


1.11
log
@merge in perl 5.8.8
@
text
@d19 1
a19 1
require 5.005;
d21 1
a21 1
$VERSION = '1.77';
d65 1
a65 2
# we might need '==' and '!=' to get things like "NaN == NaN" right
'<=>'	=>	sub { $_[2] ?
d67 12
a78 1
                      $_[0]->bcmp($_[1]); },
d84 2
a85 4
# make cos()/sin()/exp() "work" with BigInt's or subclasses
'cos'	=>	sub { cos($_[0]->numify()) }, 
'sin'	=>	sub { sin($_[0]->numify()) }, 
'exp'	=>	sub { exp($_[0]->numify()) }, 
d87 2
a88 2
			atan2($_[1],$_[0]->numify()) :
			atan2($_[0]->numify(),$_[1]) },
d94 3
a96 1
'log'	=>	sub { $_[0]->copy()->blog($_[1]); }, 
d161 1
a161 1
$round_mode = 'even'; # one of 'even', 'odd', '+inf', '-inf', 'zero' or 'trunc'
d214 1
a214 1
    if ($m !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/)
d294 1
a294 1
        Carp::croak ('Argument to accuracy must be greater than zero');
d298 2
a299 1
        require Carp; Carp::croak ('Argument to accuracy must be an integer');
d378 1
a378 1
  if (@@_ > 0)
d431 5
d453 6
d476 6
d490 1
a490 1
  my ($c,$x);
d493 8
a500 7
    # if two arguments, the first one is the class to "swallow" subclasses
    ($c,$x) = @@_;
    }
  else
    {
    $x = shift;
    $c = ref($x);
a501 1
  return unless ref($x); # only for objects
d503 4
a506 1
  my $self = bless {}, $c;
d508 2
a509 4
  $self->{sign} = $x->{sign};
  $self->{value} = $CALC->_copy($x->{value});
  $self->{_a} = $x->{_a} if defined $x->{_a};
  $self->{_p} = $x->{_p} if defined $x->{_p};
d759 1
a759 1
  # if given a BigInt, set it to +1 or -1, respecively
d881 4
d918 1
a918 1
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/)
d923 3
d978 1
a978 1
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/)
d986 1
a986 1
    $self->bround($a,$r) if !defined $self->{_a} || $self->{_a} >= $a;
d990 1
a990 1
    $self->bfround($p,$r) if !defined $self->{_p} || $self->{_p} <= $p;
d992 1
a992 1
  # bround() or bfround() already callled bnorm() if necc.
d1173 1
d1200 1
a1200 1
  $x;				# already rounded by badd() or no round necc.
d1265 1
a1265 1
  
d1268 2
d1277 12
d1295 83
d1531 1
a1531 1
  # multiply two numbers -- stolen from Knuth Vol 2 pg 233
d1541 1
a1541 1
  
d1571 76
d1825 1
a1825 1
  # large modulus, quickly, thanks to binary exponentation.  supports
d1935 1
a1935 1
   if defined $upgrade && !$y->isa($self);
d2015 1
a2015 1
      if (CORE::length($bin) <= $y)
d2245 2
a2246 1
  $self->new($x->_trailing_zeros());
d2260 1
d2262 1
a2262 1
  my $zeros = $m->_trailing_zeros();
d2441 1
a2441 1
  # operations, this does exactly this, so that sub classes can simple inherit
d2469 11
d2490 1
a2490 1
  # useless objects beeing created and thrown away. So we cannot simple loop
d2535 1
a2535 1
  #print "Now in objectify, my class is today $a[0], count = $count\n";
d2558 1
a2558 1
      $k = shift; 
d2566 1
a2566 1
        $k->can('as_number') ?  $k = $k->as_number() : $k = $a[0]->new($k);
d2598 1
d2614 1
a2614 1
    elsif ($_[$i] =~ /^lib$/i)
d2618 3
d2643 2
a2644 1
  push @@c, 'FastCalc', 'Calc';			# if all fail, try these
d2646 1
a2646 1
  foreach my $lib (@@c)
d2648 3
d2682 2
a2683 1
		new copy check from_hex from_bin as_hex as_bin zeros
d2703 7
d2727 8
a2734 1
    Carp::croak ("Couldn't load any math lib, not even 'Calc.pm'");
d2755 45
d2829 1
d2853 3
a2855 3
  $x =~ s/^\s*([-]?)0*([0-9])/$1$2/g;	# will not strip '  .2'
  $x =~ s/^\s+//;			# but this will			
  $x =~ s/\s+$//g;			# strip white space at end
d2858 1
a2858 1
  if ($x =~ /^[+-]?\d+\z/)
d2867 2
a2868 2
  return __from_hex($x) if $x =~ /^[\-\+]?0x/;	# hex string
  return __from_bin($x) if $x =~ /^[\-\+]?0b/;	# binary string
d2871 2
a2872 2
  $x =~ s/(\d)_(\d)/$1$2/g;
  $x =~ s/(\d)_(\d)/$1$2/g;		# do twice for 1_2_3
d2885 1
a2885 1
  if ($e =~ /^([+-]?)0*(\d+)$/) # strip leading zeros
d2895 1
a2895 1
    if ($mi =~ /^([+-]?)0*(\d+)$/) # strip leading zeros
d2898 1
a2898 1
      return unless ($mf =~ /^(\d*?)0*$/);	# strip trailing zeros
d2925 115
d3063 1
d3066 3
d3074 15
a3088 8
  $x = Math::BigInt->new($str);		# defaults to 0
  $y = $x->copy();			# make a true copy
  $nan  = Math::BigInt->bnan(); 	# create a NotANumber
  $zero = Math::BigInt->bzero();	# create a +0
  $inf = Math::BigInt->binf();		# create a +inf
  $inf = Math::BigInt->binf('-');	# create a -inf
  $one = Math::BigInt->bone();		# create a +1
  $one = Math::BigInt->bone('-');	# create a -1
d3104 1
a3104 1
  # comparing and digit/sign extration
d3113 1
a3113 1
  # neccessary when mixing $a = $b assigments with non-overloaded math.
d3135 2
d3142 6
a3147 4
  $x->blsft($y);	   # left shift
  $x->brsft($y);	   # right shift 
  $x->blsft($y,$n);	   # left shift, by base $n (like 10)
  $x->brsft($y,$n);	   # right shift, by base $n (like 10)
d3158 6
d3166 3
a3168 1
  $x->bfround($n);	   # round to $nth digit, no-op for BigInts
d3199 1
d3212 1
a3212 1
				# 'even', 'odd', '+inf', '-inf', 'zero' or 'trunc'
d3217 1
a3217 1
All operators (inlcuding basic math operations) are overloaded if you
d3244 10
d3283 1
a3283 1
=head2 config
d3315 1
a3315 1
	div_scale	Fallback acccuracy for div
d3331 1
a3331 1
=head2 accuracy
d3347 1
a3347 1
In most cases, you should probably round the results explicitely using one of
d3382 1
a3382 1
=head2 precision
d3427 1
a3427 1
=head2 brsft
d3452 1
a3452 1
=head2 new
d3462 13
a3474 1
=head2 bnan
d3483 1
a3483 1
=head2 bzero
d3492 1
a3492 1
=head2 binf
d3503 1
a3503 1
=head2 bone
d3524 1
a3524 1
These methods all test the BigInt for beeing one specific value and return
d3530 1
a3530 1
=head2 is_pos()/is_neg()
d3541 1
a3541 1
C<is_positive()> and C<is_negative()> are aliase to C<is_pos()> and
d3557 1
a3557 1
=head2 bcmp
d3564 1
a3564 1
=head2 bacmp
d3570 1
a3570 1
=head2 sign
d3584 1
a3584 1
=head2 digit
d3590 1
a3590 1
=head2 bneg
d3597 1
a3597 1
=head2 babs
d3601 1
a3601 1
Set the number to it's absolute value, e.g. change the sign from '-' to '+'
d3605 1
a3605 1
=head2 bnorm
d3609 1
a3609 1
=head2 bnot
d3613 1
a3613 1
Two's complement (bit wise not). This is equivalent to
d3619 1
a3619 1
=head2 binc
d3623 1
a3623 1
=head2 bdec
d3627 1
a3627 1
=head2 badd
d3631 1
a3631 1
=head2 bsub
d3635 1
a3635 1
=head2 bmul
d3639 9
a3647 1
=head2 bdiv
d3652 1
a3652 1
=head2 bmod
d3656 1
a3656 1
=head2 bmodinv
d3664 1
a3664 1
=head2 bmodpow
d3686 1
a3686 1
=head2 bpow
d3690 1
a3690 1
=head2 blsft
d3692 98
a3789 1
	$x->blsft($y);		# left shift
d3792 1
a3792 1
=head2 brsft
d3794 1
a3794 1
	$x->brsft($y);		# right shift 
d3797 1
a3797 1
=head2 band
d3801 1
a3801 1
=head2 bior
d3805 1
a3805 1
=head2 bxor
d3809 1
a3809 1
=head2 bnot
d3813 1
a3813 1
=head2 bsqrt
d3817 7
a3823 1
=head2 bfac
d3827 1
a3827 1
=head2 round
d3834 1
a3834 1
=head2 bround
d3838 1
a3838 1
=head2 bfround
d3840 1
a3840 1
	$x->bfround($N);              # round to $Nth digit, no-op for BigInts
d3842 14
a3855 1
=head2 bfloor
d3862 1
a3862 1
=head2 bceil
d3869 1
a3869 1
=head2 bgcd
d3873 1
a3873 1
=head2 blcm
d3877 1
a3877 1
head2 length
d3886 1
a3886 1
=head2 exponent
d3892 1
a3892 1
=head2 mantissa
d3898 1
a3898 1
=head2 parts
d3902 1
a3902 1
=head2 copy
d3906 1
a3906 1
=head2 as_int
d3916 1
a3916 1
=head2 bstr
d3920 1
a3920 1
Returns a normalized string represantation of C<$x>.
d3922 1
a3922 1
=head2 bsstr
d3926 1
a3926 1
=head2 as_hex
d3930 1
a3930 1
=head2 as_bin
d3934 42
d4102 6
d4139 1
a4139 1
      scale += length(divisior) - length(dividend);
d4178 1
a4178 1
  * Please note that C<< $x->accuracy() >> respecive C<< $x->precision() >>
d4184 1
a4184 1
  * When you create a number, you can give it's desired A or P via:
d4193 1
a4193 1
    suffering rounding in the parent. Thus a subclass is able to have it's own
d4224 1
a4224 1
  * A takes precendence over P (Hint: A comes before P).
d4242 1
a4242 1
      against overflows. You must explicitely call bround(), bfround() or
d4300 1
a4300 1
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc'
d4362 1
a4362 1
involved in a comparisation. However, the overload code turns that into
d4439 4
a4442 3
Currently, for BigInts C<$e> is always 0, except for NaN, +inf and -inf,
where it is C<NaN>; and for C<$x == 0>, where it is C<1> (to be compatible
with Math::BigFloat's internal representation of a zero as C<0E1>).
d4458 1
a4458 1
  $x = Math::BigInt->bnorm("-0 00"); 	# BigInt "0"
d4555 1
a4555 1
to a constant overhead for all other operatons. So Math::BigInt does currently
d4619 1
a4619 1
At the very minimum, any subclass will need to provide it's own C<new()> and can
d4684 2
d4694 1
a4694 1
=head1 BUGS
d4696 1
a4696 13
=over 2

=item broot() does not work

The broot() function in BigInt may only work for small values. This will be
fixed in a later version.

=item Out of Memory!

Under Perl prior to 5.6.0 having an C<use Math::BigInt ':constant';> and 
C<eval()> in your code will crash with "Out of memory". This is probably an
overload/exporter bug. You can workaround by not having C<eval()> 
and ':constant' at the same time or upgrade your Perl to a newer version.
d4698 2
a4699 8
=item Fails to load Calc on Perl prior 5.6.0

Since eval(' use ...') can not be used in conjunction with ':constant', BigInt
will fall back to eval { require ... } when loading the math lib on Perls
prior to 5.6.0. This simple replaces '::' with '/' and thus might fail on
filesystems using a different seperator.  

=back
d4714 1
a4714 1
because it's C<ok()> uses 'eq' internally. 
d4746 1
a4746 1
for comparisation, but Perl will represent some numbers as 100 and others
d4760 1
a4760 1
Alternatively, simple use C<< <=> >> for comparisations, this will get it
a4785 2
It is yet unlcear whether overloaded int() should return a scalar or a BigInt.

d4814 1
a4814 1
context. Also, C<bdiv()> will modify $c, so be carefull. You probably want
d4843 1
a4843 1
negative. See below under "infinity handling" for the reasoning behing this.
d5051 2
a5052 2
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2004
and still at it in 2005.
d5055 1
a5055 1
CREDITS for an (uncomplete) list. If you miss your name, please drop me a
@


1.10
log
@sync in-tree perl with 5.8.6
@
text
@d21 5
a25 4
$VERSION = '1.73';
use Exporter;
@@ISA =       qw( Exporter );
@@EXPORT_OK = qw( objectify bgcd blcm); 
d57 1
a58 1

d65 1
d68 1
a68 1
                      $_[0]->bcmp($_[1])},
d78 7
a84 1
'atan2'	=>	sub { atan2($_[0]->numify(),$_[1]) }, 
d95 2
a96 2
                   $c->bneg()->badd( $_[1]) :
                   $c->bsub( $_[1]) },
d148 2
a149 2
# these are public, but their usage is not recommended, use the accessor
# methods instead
d159 1
a159 3
# these are internally, and not to be used from the outside

sub MB_NEVER_ROUND () { 0x0001; }
d165 2
a166 2
my $CALC = 'Math::BigInt::Calc';	# module to do the low level math
					# default is Calc.pm
d171 1
d222 1
a222 2
    my $u = shift;
    return ${"${class}::upgrade"} = $u;
d236 1
a236 2
    my $u = shift;
    return ${"${class}::downgrade"} = $u;
d253 1
a253 1
    ${"${class}::div_scale"} = shift;
d307 1
a307 1
  my $r;
d309 1
a309 1
  $r = $x->{_a} if ref($x);
d311 2
a312 2
  $r = ${"${class}::accuracy"} if !defined $r;
  $r;
d353 1
a353 1
  my $r;
d355 1
a355 1
  $r = $x->{_p} if ref($x);
d357 2
a358 2
  $r = ${"${class}::precision"} if !defined $r;
  $r;
d427 11
a437 5
  my ($x,$s,$m,$scale,$mode) = @@_;
  $scale = $x->{_a} if !defined $scale;
  $scale = $s if (!defined $scale);
  $mode = $m if !defined $mode;
  return ($scale,$mode);
d444 11
a454 5
  my ($x,$s,$m,$scale,$mode) = @@_;
  $scale = $x->{_p} if !defined $scale;
  $scale = $s if (!defined $scale);
  $mode = $m if !defined $mode;
  return ($scale,$mode);
d475 1
a475 1
  my $self = {}; bless $self,$c;
d531 1
a531 1
  if ($wanted =~ /^[+-]?inf$/)
d533 2
a534 3
    $self->{value} = $CALC->_zero();
    $self->{sign} = $wanted; $self->{sign} = '+inf' if $self->{sign} eq 'inf';
    return $self;
d665 1
a665 1
    Carp::croak ("Tried to set $self to +-inf in $class\::binfn()");
d780 1
a780 2
  my $x = shift; my $class = ref($x) || $x; $x = $class->new(shift) if !ref($x); 
  # my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_); 
d796 1
a796 2
  my $x = shift; my $class = ref($x) || $x; $x = $class->new(shift) if !ref($x); 
  # my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_); 
a848 3
  # leave bigfloat parts alone
  return ($self) if exists $self->{_f} && ($self->{_f} & MB_NEVER_ROUND) != 0;

a905 4
  # leave bigfloat parts alone (that is only used in BigRat for now and can be
  # removed once we rewrote BigRat))
  return ($self) if exists $self->{_f} && ($self->{_f} & MB_NEVER_ROUND) != 0;

d972 1
a972 1
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
d984 1
a984 1
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
d988 2
a989 2
  # for +0 dont negate (to have always normalized)
  $x->{sign} =~ tr/+-/-+/ if !$x->is_zero();	# does nothing for NaN
d1127 1
a1127 2
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
d1148 1
a1148 5
  if ($y->is_zero())
    { 
    $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }
d1150 6
a1155 2
  require Scalar::Util;
  if (Scalar::Util::refaddr($x) == Scalar::Util::refaddr($y)) 
d1157 2
a1158 3
    # if we get the same variable twice, the result must be zero (the code
    # below fails in that case)
    return $x->bzero(@@r) if $x->{sign} =~ /^[+-]$/;
a1160 1
  $y->{sign} =~ tr/+\-/-+/; 	# does nothing for NaN
d1175 1
a1175 2
    $x->round($a,$p,$r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
d1181 1
a1181 2
    $x->round($a,$p,$r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
d1195 1
a1195 1
    # < 0
d1200 1
a1200 1
    return $x->badd($self->bone('-'),@@r) unless $x->{sign} eq '+'; # inf/NaN
d1213 1
a1213 2
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
d1222 1
a1222 1
  my ($self,$x,$base,@@r) = (ref($_[0]),@@_);
d1226 1
a1226 1
    ($self,$x,$base,@@r) = objectify(1,$class,@@_);
a1282 1
    next if $y->is_zero();
d1284 2
a1285 1
    $x->{value} = $CALC->_gcd($x->{value},$y->{value}); last if $x->is_one();
d1369 5
a1373 2
  
  $x->{sign} =~ /^\+/ ? 1 : 0;		# +inf is also positive, but NaN not
d1381 1
a1381 1
  $x->{sign} =~ /^-/ ? 1 : 0; 		# -inf is also negative, but NaN not
d1434 1
a1434 2
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
d1516 1
a1516 1
    $x->round(@@r) if !exists $x->{_f} || ($x->{_f} & MB_NEVER_ROUND) == 0;
d1526 1
a1526 1
    $rem->round(@@r) if !exists $rem->{_f} || ($rem->{_f} & MB_NEVER_ROUND) == 0;
d1533 1
a1533 2
  $x->round(@@r) if !exists $x->{_f} || ($x->{_f} & MB_NEVER_ROUND) == 0;
  $x;
d1566 2
a1567 1
    my $xsign = $x->{sign};
a1568 5
    if ($xsign ne $y->{sign})
      {
      my $t = $CALC->_copy($x->{value});		# copy $x
      $x->{value} = $CALC->_sub($y->{value},$t,1); 	# $y-$x
      }
d1574 1
a1574 2
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
d1585 1
a1585 1
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
d1648 1
a1648 1
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
d1650 2
a1651 4
  return $x if $x->modify('bfac');
 
  return $x if $x->{sign} eq '+inf';		# inf => inf
  return $x->bnan() if $x->{sign} ne '+';	# NaN, <0 etc => NaN
d1744 1
a1744 2
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
d1980 1
a1980 1
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
d2072 1
a2072 1
  my ($scale,$mode) = $x->_scale_p($x->precision(),$x->round_mode(),@@_);
d2101 1
a2101 1
  my $x = shift;
d2114 2
a2115 3
  my ($scale,$mode) = $x->_scale_a($x->accuracy(),$x->round_mode(),@@_);
  return $x if !defined $scale;			# no-op
  return $x if $x->modify('bround');
d2357 12
d2402 7
a2408 3
  # even if @@_ is empty, to give it a chance 
  $self->SUPER::import(@@a);			# need it for subclasses
  $self->export_to_level(1,$self,@@a);		# need it for MBF
d2412 5
a2416 1
  push @@c,'Calc';				# if all fail, try this
d2425 2
a2426 2
      # Perl < 5.6.0 dies with "out of memory!" when eval() and ':constant' is
      # used in the same script, or eval inside import().
d2477 1
a2477 1
	  my $ver = eval "\$$lib\::VERSION";
a2489 2
  _fill_can_cache();		# for emulating lower math lib functions
  }
d2491 8
a2498 3
sub _fill_can_cache
  {
  # fill $CAN with the results of $CALC->can(...)
d2501 1
a2501 1
  for my $method (qw/ signed_and or signed_or xor signed_xor /)
d2505 2
d2511 1
d2533 1
d2553 5
a2557 4
  # (ref to num_str) return num_str
  # internal, take apart a string and return the pieces
  # strip leading/trailing whitespace, leading zeros, underscore and reject
  # invalid input
d2625 1
a2625 1
  my $x = shift; my $ty = shift;
d2627 3
a2629 1
  $x * $ty / bgcd($x,$ty);
d2633 1
a2633 1
# this method return 0 if the object can be modified, or 1 for not
d2642 2
d2646 1
a2646 1
Math::BigInt - Arbitrary size integer math package
d2755 1
a2755 1
			   # latter is always 0 digits long for BigInt's
d2765 2
a2766 2
  $x->bstr();		   # normalized string
  $x->bsstr();		   # normalized string in scientific notation
d2778 5
a2782 3
  Math::BigInt->precision(); # get/set global P for all BigInt objects
  Math::BigInt->accuracy();  # get/set global A for all BigInt objects
  Math::BigInt->config();    # return hash containing configuration
d2826 3
a2828 2
Output values are BigInt objects (normalized), except for bstr(), which
returns a string in normalized form.
d2830 2
a2831 2
C<is_nan()>) return true or false, while others (C<bcmp()>, C<bacmp()>)
return either undef, <0, 0 or >0 and are suited for sort.
d2838 2
a2839 2
accepts three additional parameters. These arguments $A, $P and $R are
accuracy, precision and round_mode. Please see the section about
d2894 4
a2897 2
	$A = $x->accuracy();		# read out
	$A = CLASS->accuracy();		# read out
d2900 14
a2913 1
results have. 
d2928 1
a2928 1
	$x = Math::BigInt->new(123456);		# will be automatically rounded
d2943 21
a2963 11
	$x->precision(-2);		# local for $x, round right of the dot
	$x->precision(2);		# ditto, but round left of the dot
	CLASS->accuracy(5);		# global for all members of CLASS
	CLASS->precision(-5);		# ditto
	$P = CLASS->precision();	# read out
	$P = $x->precision();		# read out

Set or get the global or local precision, aka how many digits the result has
after the dot (or where to round it when passing a positive number). In
Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot.
d2967 1
a2967 1
Value must be greater than zero. Pass an undef value to disable it:
d2974 1
a2974 1
value represents the accuracy that will be in effect for $x:
d2979 1
d2981 2
a2982 2
Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
d3079 2
a3080 2
	$x->is_pos();			# true if >= 0
	$x->is_neg();			# true if <  0
d3084 1
a3084 1
C<-inf> is negative. A C<zero> is positive.
d3123 8
d3710 45
d3758 1
d3760 2
a3761 2
might change without notice. Use only method calls like C<< $x->sign(); >>
instead relying on the internal hash keys like in C<< $x->{sign}; >>. 
d3780 1
a3780 1
cases involving really big numbers, where it is B<much> faster), and there is
d3787 2
a3788 1
numbers. You should not depend on the number having a specific format.
d3794 1
a3794 1
The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored seperately.
d4154 3
d4167 2
a4168 1
In all Perl versions you can use C<as_number()> for the same effect:
d4172 1
d4178 9
a4338 3
With Copy-On-Write, this issue would be gone, but C-o-W is not implemented
since it is slower for all other things.

d4443 2
a4444 2
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2003
and still at it in 2004.
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d21 1
a21 1
$VERSION = '1.70';
d58 3
d85 1
a85 1
# for sub it is a bit tricky to keep b: b-a => -a+b
d87 1
a87 1
                   $c->bneg()->badd($_[1]) :
d673 1
a673 1
  $self = $class if !defined $self;
d764 1
a764 1
  my $x = shift; $class = ref($x) || $x; $x = $class->new(shift) if !ref($x); 
d781 1
a781 1
  my $x = shift; $class = ref($x) || $x; $x = $class->new(shift) if !ref($x); 
d895 2
a896 1
  # leave bigfloat parts alone
d949 2
a950 1
  $self->bnorm();			# after round, normalize
d1148 8
d1256 1
a1256 1
    $x = __PACKAGE__->new($y);
d1274 1
a1274 1
  $y = __PACKAGE__->new($y) if !ref($y);
d1678 51
a1732 2
  return $x if $x->{sign} =~ /^[+-]inf$/;	# -inf/+inf ** x
  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;
d2092 2
a2093 2
  # internal, used by bround()
  my ($x,$pad,$xs) = @@_;
d2095 1
a2095 2
  my $len = $x->length();
  return 0 if $len == 1;		# '5' is trailed by invisible zeros
d2099 2
a2100 3
  # since we do not know underlying represention of $x, use decimal string
  my $r = substr ("$x",-$follow);
  $r =~ /[^0]/ ? 1 : 0;
d2150 2
a2151 2
  # do not use digit(), it is costly for binary => decimal

d2169 1
a2169 1
    ($x->_scan_for_nonzero($pad,$xs) == 0)		&&
d2181 2
a2182 2
    substr($xs,-$pad,$pad) = '0' x $pad;
    $put_back = 1;
d2191 1
a2191 1
    $put_back = 1;
d2206 1
a2206 1
  $x->{value} = $CALC->_new($xs) if $put_back == 1;	# put back in if needed
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d21 1
a21 1
$VERSION = '1.68';
a157 1
my %CAN;				# cache for $CALC->can(...)
d160 2
a161 1

a162 1
my $EMU = 'Math::BigInt::CalcEmu';	# emulate low-level math
d286 3
a288 3
      $x->bround($a) if $a;             # not for undef, 0
      $x->{_a} = $a;                    # set/overwrite, even if not rounded
      $x->{_p} = undef;                 # clear P
d293 2
a294 3
      # set global
      ${"${class}::accuracy"} = $a;
      ${"${class}::precision"} = undef; # clear P
d296 1
a296 1
    return $a;                          # shortcut
d332 3
a334 3
      $x->bfround($p) if $p;            # not for undef, 0
      $x->{_p} = $p;                    # set/overwrite, even if not rounded
      $x->{_a} = undef;                 # clear A
d339 2
a340 3
      # set global
      ${"${class}::precision"} = $p;
      ${"${class}::accuracy"} = undef;  # clear A
d342 1
a342 1
    return $p;                          # shortcut
d456 5
a460 40
  my $r;
  foreach my $k (keys %$x)
    {
    if ($k eq 'value')
      {
      $self->{value} = $CALC->_copy($x->{value}); next;
      }
    if (!($r = ref($x->{$k})))
      {
      $self->{$k} = $x->{$k}; next;
      }
    if ($r eq 'SCALAR')
      {
      $self->{$k} = \${$x->{$k}};
      }
    elsif ($r eq 'ARRAY')
      {
      $self->{$k} = [ @@{$x->{$k}} ];
      }
    elsif ($r eq 'HASH')
      {
      # only one level deep!
      foreach my $h (keys %{$x->{$k}})
        {
        $self->{$k}->{$h} = $x->{$k}->{$h};
        }
      }
    else # normal ref
      {
      my $xk = $x->{$k};
      if ($xk->can('copy'))
        {
	$self->{$k} = $xk->copy();
        }
      else
	{
	$self->{$k} = $xk->new($xk);
	}
      }
    }
d488 1
a488 1
    my $ref = \$wanted;
d492 6
a497 1
      my $t = $wanted; $t =~ s/^[+-]//; $ref = \$t;
a498 5
    # force to string version (otherwise Pari is unhappy about overflowed
    # constants, for instance)
    # not good, BigInt shouldn't need to know about alternative libs:
    # $ref = \"$$ref" if $CALC eq 'Math::BigInt::Pari';
    $self->{value} = $CALC->_new($ref);
d518 1
a518 1
  my ($mis,$miv,$mfv,$es,$ev) = _split(\$wanted);
d591 1
a591 1
  $self->{value} = $CALC->_new($miv) if $self->{sign} =~ /^[+-]$/;
d628 1
a628 1
  return $self;
d663 1
a663 1
  return $self;
d772 1
a772 1
  $m->bstr() . 'e+' . ${$CALC->_str($e->{value})}; 
d787 1
a787 1
  $es.${$CALC->_str($x->{value})};
d1048 2
a1049 1
    return +1;	# inf is always bigger
d1134 2
a1135 3
# upgrade done by badd():
#  return $upgrade->badd($x,$y,@@r) if defined $upgrade &&
#   ((!$x->isa($self)) || (!$y->isa($self)));
d1212 1
a1212 1
    ($self,$x,$base,@@r) = objectify(2,$class,@@_);
d1214 2
d1219 2
a1220 2
   if $x->{sign} ne '+' || $base->{sign} ne '+';
  
d1222 1
a1222 1
    defined $upgrade && (ref($x) ne $upgrade || ref($base) ne $upgrade);
d1224 4
a1227 10
  if ($CAN{log_int})
    {
    my ($rc,$exact) = $CALC->_log_int($x->{value},$base->{value});
    return $x->bnan() unless defined $rc;
    $x->{value} = $rc;
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_blog($self,$x,$base,@@r);
d1243 1
a1243 1
    $x = $class->new($y);
d1245 6
a1250 1
  while (@@_) { $x = __lcm($x,shift); } 
d1263 4
a1266 2
  my $x = $y->copy();		# keep arguments
  if ($CAN{gcd})
d1268 4
a1271 7
    while (@@_)
      {
      $y = shift; $y = $self->new($y) if !ref($y);
      next if $y->is_zero();
      return $x->bnan() if $y->{sign} !~ /^[+-]$/;	# y NaN?
      $x->{value} = $CALC->_gcd($x->{value},$y->{value}); last if $x->is_one();
      }
d1273 1
a1273 9
  else
    {
    while (@@_)
      {
      $y = shift; $y = $self->new($y) if !ref($y);
      $x = __gcd($x,$y->copy()); last if $x->is_one();	# _gcd handles NaN
      } 
    }
  $x->babs();
d1406 3
a1408 3
  
  return $upgrade->bmul($x,$y,@@r)
   if defined $upgrade && $y->isa($upgrade);
d1547 3
a1549 1
  if ($CAN{mod})
d1551 3
a1553 13
    # calc new sign and in case $y == +/- 1, return $x
    $x->{value} = $CALC->_mod($x->{value},$y->{value});
    if (!$CALC->_is_zero($x->{value}))
      {
      my $xsign = $x->{sign};
      $x->{sign} = $y->{sign};
      if ($xsign ne $y->{sign})
        {
        my $t = $CALC->_copy($x->{value});		# copy $x
        $x->{value} = $CALC->_sub($y->{value},$t,1); 	# $y-$x
        }
      }
    else
d1555 2
a1556 1
      $x->{sign} = '+';				# dont leave -0
a1557 2
    $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
d1559 1
a1559 5
  # disable upgrade temporarily, otherwise endless loop due to bdiv()
  local $upgrade = undef;
  my ($t,$rem) = $self->bdiv($x->copy(),$y,@@r);	# slow way (also rounds)
  # modify in place
  foreach (qw/value sign _a _p/)
d1561 1
a1561 1
    $x->{$_} = $rem->{$_};
d1563 1
d1593 7
a1599 13
  if ($CAN{modinv})
    {
    my $sign;
    ($x->{value},$sign) = $CALC->_modinv($x->{value},$y->{value});
    return $x->bnan() if !defined $x->{value};		# in case no GCD found
    return $x if !defined $sign;			# already real result
    $x->{sign} = $sign;					# flip/flop see below
    $x->bmod($y);					# calc real result
    return $x;
    }

  require $EMU_LIB;
  __emu_bmodinv($self,$x,$y,@@r);
d1627 3
a1629 9
  if ($CAN{modpow})
    {
    # $mod is positive, sign on $exp is ignored, result also positive
    $num->{value} = $CALC->_modpow($num->{value},$exp->{value},$mod->{value});
    return $num;
    }

  require $EMU_LIB;
  __emu_bmodpow($self,$num,$exp,$mod,@@r);
d1645 2
a1646 8
  if ($CAN{fac})
    {
    $x->{value} = $CALC->_fac($x->{value});
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_bfac($self,$x,@@r);
d1674 6
a1679 6
  if ($x->{sign} eq '-' && $CALC->_is_one($x->{value}))
    {
    # if $x == -1 and odd/even y => +1/-1
    return $y->is_odd() ? $x->round(@@r) : $x->babs()->round(@@r);
    # my Casio FX-5500L has a bug here: -1 ** 2 is -1, but -1 * -1 is 1;
    }
d1682 1
a1682 1
  return $x->bnan() if $y->{sign} eq '-' && !$x->is_one();
d1684 5
a1688 10
  if ($CAN{pow})
    {
    $x->{value} = $CALC->_pow($x->{value},$y->{value});
    $x->{sign} = '+' if $CALC->_is_zero($y->{value});
    $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }

  require $EMU_LIB;
  __emu_bpow($self,$x,$y,@@r);
d1710 2
a1711 7
  my $t; $t = $CALC->_lsft($x->{value},$y->{value},$n) if $CAN{lsft};
  if (defined $t)
    {
    $x->{value} = $t; return $x->round(@@r);
    }
  # fallback
  $x->bmul( $self->bpow($n, $y, @@r), @@r );
d1771 2
a1772 9
  my $t; $t = $CALC->_rsft($x->{value},$y->{value},$n) if $CAN{rsft};
  if (defined $t)
    {
    $x->{value} = $t;
    return $x->round(@@r);
    }
  # fallback
  $x->bdiv($self->bpow($n,$y, @@r), @@r);
  $x;
d1797 1
a1797 1
  if ($CAN{and} && $sx == 1 && $sy == 1)
a1828 2
  local $Math::BigInt::upgrade = undef;

d1837 1
a1837 1
  if ($CAN{or} && $sx == 1 && $sy == 1)
d1876 1
a1876 1
  if ($CAN{xor} && $sx == 1 && $sy == 1)
d1904 1
a1904 1
  my ($self,$x,$n) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
d1906 1
d1916 1
a1916 3
  return 0 if $x->is_zero() || $x->is_odd() || $x->{sign} !~ /^[+-]$/;

  return $CALC->_zeros($x->{value}) if $CAN{zeros};
d1918 1
a1918 4
  # if not: since we do not know underlying internal representation:
  my $es = "$x"; $es =~ /([0]*)$/;
  return 0 if !defined $1;	# no zeros
  CORE::length("$1");		# as string, not as +0!
d1933 2
a1934 8
  if ($CAN{sqrt})
    {
    $x->{value} = $CALC->_sqrt($x->{value});
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_bsqrt($self,$x,@@r);
d1963 2
a1964 8
  if ($CAN{root})
    {
    $x->{value} = $CALC->_root($x->{value},$y->{value});
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_broot($self,$x,$y,@@r);
d2014 1
a2014 1
  my $x = shift; $x = $class->new($x) unless ref $x;
d2023 2
a2024 2
  $x->{_a} = undef;				# bround sets {_a}
  $x->{_p} = $scale;				# so correct it
d2097 1
a2097 1
  $digit_round = '0'; $digit_round = substr($$xs,$pl,1) if $pad <= $len;
d2099 1
a2099 1
  $digit_after = '0'; $digit_after = substr($$xs,$pl,1) if $pad > 0;
d2121 1
a2121 1
    substr($$xs,-$pad,$pad) = '0' x $pad;
d2132 1
a2132 1
    $pad = $len, $$xs = '0' x $pad if $scale < 0;	# tlr: whack 0.51=>1.0	
d2139 2
a2140 2
      $c = substr($$xs,-$pad,1) + 1; $c = '0' if $c eq '10';
      substr($$xs,-$pad,1) = $c; $pad++;
d2143 1
a2143 1
    $$xs = '1'.$$xs if $c == 0;
d2190 1
a2190 7
  if ($CAN{as_hex})
    {
    return $s . ${$CALC->_as_hex($x->{value})};
    }

  require $EMU_LIB;
  __emu_as_hex(ref($x),$x,$s);
d2201 1
a2201 8
  if ($CAN{as_bin})
    {
    return $s . ${$CALC->_as_bin($x->{value})};
    }

  require $EMU_LIB;
  __emu_as_bin(ref($x),$x,$s);

d2364 47
a2410 1
    $CALC = $lib, last if $@@ eq '';	# no error in loading lib?
d2417 1
a2417 1
  _fill_can_cache();
d2425 1
a2425 5
  for my $method (qw/gcd mod modinv modpow fac pow lsft rsft 
	and signed_and or signed_or xor signed_xor
	from_hex as_hex from_bin as_bin
	zeros sqrt root log_int log
	/)
d2439 2
a2440 2
  $$hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
  $$hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
d2442 1
a2442 1
  return $x->bnan() if $$hs !~ /^[\-\+]?0x[0-9A-Fa-f]+$/;
d2444 1
a2444 1
  my $sign = '+'; $sign = '-' if ($$hs =~ /^-/);
d2446 2
a2447 23
  $$hs =~ s/^[+-]//;			# strip sign
  if ($CAN{'from_hex'})
    {
    $x->{value} = $CALC->_from_hex($hs);
    }
  else
    {
    # fallback to pure perl
    my $mul = Math::BigInt->bone();
    my $x65536 = Math::BigInt->new(65536);
    my $len = CORE::length($$hs)-2;		# minus 2 for 0x
    $len = int($len/4);				# 4-digit parts, w/o '0x'
    my $val; my $i = -4;
    while ($len >= 0)
      {
      $val = substr($$hs,$i,4);
      $val =~ s/^[+-]?0x// if $len == 0;	# for last part only because
      $val = hex($val); 			# hex does not like wrong chars
      $i -= 4; $len --;
      $x += $mul * $val if $val != 0;
      $mul *= $x65536 if $len >= 0;		# skip last mul
      }
    }
d2459 8
a2466 30
  $$bs =~ s/([01])_([01])/$1$2/g;	
  $$bs =~ s/([01])_([01])/$1$2/g;	
  return $x->bnan() if $$bs !~ /^[+-]?0b[01]+$/;

  my $sign = '+'; $sign = '-' if ($$bs =~ /^\-/);
  $$bs =~ s/^[+-]//;				# strip sign
  if ($CAN{'from_bin'})
    {
    $x->{value} = $CALC->_from_bin($bs);
    }
  else
    {
    my $mul = Math::BigInt->bone();
    my $x256 = Math::BigInt->new(256);
    my $len = CORE::length($$bs)-2;		# minus 2 for 0b
    $len = int($len/8);				# 8-digit parts, w/o '0b'
    my $val; my $i = -8;
    while ($len >= 0)
      {
      $val = substr($$bs,$i,8);
      $val =~ s/^[+-]?0b// if $len == 0;	# for last part only
      #$val = oct('0b'.$val);	# does not work on Perl prior to 5.6.0
      # slower:
      # $val = ('0' x (8-CORE::length($val))).$val if CORE::length($val) < 8;
      $val = ord(pack('B8',substr('00000000'.$val,-8,8)));
      $i -= 8; $len --;
      $x += $mul * $val if $val != 0;
      $mul *= $x256 if $len >= 0;		# skip last mul
      }
    }
d2480 3
a2482 3
  $$x =~ s/^\s*([-]?)0*([0-9])/$1$2/g;	# will not strip '  .2'
  $$x =~ s/^\s+//;			# but this will			
  $$x =~ s/\s+$//g;			# strip white space at end
d2485 1
a2485 1
  if ($$x =~ /^[+-]?\d+\z/)
d2487 2
a2488 2
    $$x =~ s/^([+-])0*([0-9])/$2/; my $sign = $1 || '+';
    return (\$sign, $x, \'', \'', \0);
d2492 1
a2492 1
  return if $$x !~ /^[+-]?(\.?[0-9]|0b[0-1]|0x[0-9a-fA-F])/;
d2494 2
a2495 2
  return __from_hex($x) if $$x =~ /^[\-\+]?0x/;	# hex string
  return __from_bin($x) if $$x =~ /^[\-\+]?0b/;	# binary string
d2498 2
a2499 2
  $$x =~ s/(\d)_(\d)/$1$2/g;
  $$x =~ s/(\d)_(\d)/$1$2/g;		# do twice for 1_2_3
d2505 1
a2505 3
  #return if $$x =~ /[Ee].*[Ee]/;	# more than one E => error

  my ($m,$e,$last) = split /[Ee]/,$$x;
d2546 1
a2546 17
  return $x * $ty / bgcd($x,$ty);
  }

sub __gcd
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does modify both arguments
  # GCD -- Euclids algorithm E, Knuth Vol 2 pg 296
  my ($x,$ty) = @@_;

  return $x->bnan() if $x->{sign} !~ /^[+-]$/ || $ty->{sign} !~ /^[+-]$/;

  while (!$ty->is_zero())
    {
    ($x, $ty) = ($ty,bmod($x,$ty));
    }
  $x;
d2573 4
d2579 1
d2598 1
a2598 1
  $x->is_inf(sign);	# if $x is +inf, or -inf (sign is default '+')
d2652 2
a2653 2
  $x->bround($N);          # accuracy: preserve $N digits
  $x->bfround($N);         # round to $Nth digit, no-op for BigInts
d2663 4
a2666 2
  bgcd(@@values);	   # greatest common divisor (no OO style)
  blcm(@@values);	   # lowest common multiplicator (no OO style)
d2669 1
a2669 1
  ($x,$f) = $x->length();  # length of number and length of fraction part,
d4263 2
a4264 2
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001, 2002
and still at it in 2003.
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d21 1
a21 1
$VERSION = '1.66';
d24 5
a28 5
@@EXPORT_OK = qw( objectify _swap bgcd blcm); 
use vars qw/$round_mode $accuracy $precision $div_scale $rnd_mode/;
use vars qw/$upgrade $downgrade/;
# the following are internal and should never be accessed from the outside
use vars qw/$_trap_nan $_trap_inf/;
d32 3
a34 4
# it reversed (like $x = 2 * $y), then the third paramater indicates this
# swapping. To make it work, we use a helper routine which not only reswaps the
# params, but also makes a new object in this case. See _swap() for details,
# especially the cases of operators with different classes.
a44 8
# '+' and '-' do not use _swap, since it is a triffle slower. If you want to
# override _swap (if ever), then override overload of '+' and '-', too!
# for sub it is a bit tricky to keep b: b-a => -a+b
'-'	=>	sub { my $c = $_[0]->copy; $_[2] ?
                   $c->bneg()->badd($_[1]) :
                   $c->bsub( $_[1]) },
'+'	=>	sub { $_[0]->copy()->badd($_[1]); },

d69 7
a75 1
'log'	=>	sub { $_[0]->copy()->blog(); }, 
d82 6
a87 10
'*'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bmul($a[1]); },
'/'	=>	sub { my @@a = ref($_[0])->_swap(@@_);scalar $a[0]->bdiv($a[1]);},
'%'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bmod($a[1]); },
'**'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bpow($a[1]); },
'<<'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->blsft($a[1]); },
'>>'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->brsft($a[1]); },

'&'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->band($a[1]); },
'|'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bior($a[1]); },
'^'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bxor($a[1]); },
d89 27
a115 2
# can modify arg of ++ and --, so avoid a new-copy for speed, but don't
# use $_[0]->__one(), it modifies $_[0] to be 1!
d122 3
a124 3
  # v5.6.1 dumps on that: return !$_[0]->is_zero() || undef;		    :-(
  my $t = !$_[0]->is_zero();
  undef $t if $t == 0;
d150 1
a150 1
use constant MB_NEVER_ROUND => 0x0001;
d157 2
d162 3
d173 10
a182 1
BEGIN { tie $rnd_mode, 'Math::BigInt'; }
d781 1
d808 3
a810 2
  my $sign = 'e+'; # e can only be positive
  return $m->bstr().$sign.$e->bstr();
d825 1
a825 1
  return $es.${$CALC->_str($x->{value})};
d845 1
a845 1
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_); 
d971 1
a971 1
   
d990 1
a990 1
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
d1061 1
a1061 1
  $CALC->_acmp($y->{value},$x->{value});	# swaped (lib returns 0,1,-1)
d1105 1
a1105 1
  return $upgrade->badd($x,$y,@@r) if defined $upgrade &&
d1127 1
a1127 1
  my ($sx, $sy) = ( $x->{sign}, $y->{sign} ); # get signs
a1131 1
    $x->{sign} = $sx;
a1137 1
      #print "swapped sub (a=$a)\n";
a1143 1
      #print "equal sub, result = 0\n";
a1148 1
      #print "unswapped sub (a=$a)\n";
a1149 1
      $x->{sign} = $sx;
d1158 1
a1158 1
  # (BINT or num_str, BINT or num_str) return num_str
d1207 1
a1207 1
  $x->badd($self->__one(),$a,$p,$r);		# badd does round
d1213 1
a1213 1
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
d1216 1
a1216 3
  my $zero = $CALC->_is_zero($x->{value}) && $x->{sign} eq '+';
  # <= 0
  if (($x->{sign} eq '-') || $zero) 
d1218 1
d1220 2
a1221 7
    $x->{sign} = '-' if $zero;			# 0 => 1 => -1
    $x->{sign} = '+' if $CALC->_is_zero($x->{value}); # -1 +1 => -0 => +0
    $x->round($a,$p,$r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }
  # > 0
  elsif ($x->{sign} eq '+')
d1223 12
a1234 3
    $x->{value} = $CALC->_dec($x->{value});
    $x->round($a,$p,$r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
d1236 3
a1238 3
  # inf, nan handling etc
  $x->badd($self->__one('-'),$a,$p,$r);			# badd does round
  } 
d1242 25
a1266 4
  # not implemented yet
  my ($self,$x,$base,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
 
  return $upgrade->blog($upgrade->new($x),$base,$a,$p,$r) if defined $upgrade;
d1268 2
a1269 1
  return $x->bnan();
d1271 1
a1271 1
 
d1301 1
a1301 1
  if ($CALC->can('_gcd'))
d1330 1
a1330 1
  $x->bneg()->bdec();			# bdec already does round
d1333 1
d1335 1
a1339 1
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
d1349 1
a1349 1
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
d1351 1
a1351 2
  return 1 if $x->{sign} eq $nan;
  0;
d1357 1
a1357 5
  my ($self,$x,$sign) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);

  $sign = '' if !defined $sign;
  return 1 if $sign eq $x->{sign};		# match ("+inf" eq "+inf")
  return 0 if $sign !~ /^([+-]|)$/;
d1359 1
a1359 1
  if ($sign eq '')
d1361 3
a1363 2
    return 1 if ($x->{sign} =~ /^[+-]inf$/); 
    return 0;
d1365 1
a1365 3
  $sign = quotemeta($sign.'inf');
  return 1 if ($x->{sign} =~ /^$sign$/);
  0;
d1370 1
a1370 3
  # return true if arg (BINT or num_str) is +1
  # or -1 if sign is given
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
a1381 1
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
a1390 1
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
a1399 1
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
d1402 1
a1402 2
  return 1 if $x->{sign} =~ /^\+/;
  0;
a1407 1
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
d1410 1
a1410 2
  return 1 if ($x->{sign} =~ /^-/);
  0;
d1416 1
a1416 2
  # always true for BigInt, but different for Floats
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
d1593 1
a1593 1
  if ($CALC->can('_mod'))
a1603 1
        $x->{value} = $CALC->_copy($y->{value});	# copy $y to $x
d1614 2
d1651 1
a1651 1
  if ($CALC->can('_modinv'))
d1655 4
a1658 4
    $x->bnan() if !defined $x->{value};                 # in case no GCD found
    return $x if !defined $sign;                        # already real result
    $x->{sign} = $sign;                                 # flip/flop see below
    $x->bmod($y);                                       # calc real result
a1660 2
  my ($u, $u1) = ($self->bzero(), $self->bone());
  my ($a, $b) = ($y->copy(), $x->copy());
d1662 2
a1663 38
  # first step need always be done since $num (and thus $b) is never 0
  # Note that the loop is aligned so that the check occurs between #2 and #1
  # thus saving us one step #2 at the loop end. Typical loop count is 1. Even
  # a case with 28 loops still gains about 3% with this layout.
  my $q;
  ($a, $q, $b) = ($b, $a->bdiv($b));                    # step #1
  # Euclid's Algorithm (calculate GCD of ($a,$b) in $a and also calculate
  # two values in $u and $u1, we use only $u1 afterwards)
  my $sign = 1;                                         # flip-flop
  while (!$b->is_zero())                                # found GCD if $b == 0
    {
    # the original algorithm had:
    # ($u, $u1) = ($u1, $u->bsub($u1->copy()->bmul($q))); # step #2
    # The following creates exact the same sequence of numbers in $u1,
    # except for the sign ($u1 is now always positive). Since formerly
    # the sign of $u1 was alternating between '-' and '+', the $sign
    # flip-flop will take care of that, so that at the end of the loop
    # we have the real sign of $u1. Keeping numbers positive gains us
    # speed since badd() is faster than bsub() and makes it possible
    # to have the algorithmn in Calc for even more speed.

    ($u, $u1) = ($u1, $u->badd($u1->copy()->bmul($q))); # step #2
    $sign = - $sign;                                    # flip sign

    ($a, $q, $b) = ($b, $a->bdiv($b));                  # step #1 again
    }

  # If the gcd is not 1, then return NaN! It would be pointless to
  # have called bgcd to check this first, because we would then be
  # performing the same Euclidean Algorithm *twice*.
  return $x->bnan() unless $a->is_one();

  $u1->bneg() if $sign != 1;                            # need to flip?

  $u1->bmod($y);                                        # calc result
  $x->{value} = $u1->{value};                           # and copy over to $x
  $x->{sign} = $u1->{sign};                             # to modify in place
  $x;
d1691 1
a1691 1
  if ($CALC->can('_modpow'))
d1698 2
a1699 21
  # in the trivial case,
  return $num->bzero(@@r) if $mod->is_one();
  return $num->bone('+',@@r) if $num->is_zero() or $num->is_one();

  # $num->bmod($mod);           # if $x is large, make it smaller first
  my $acc = $num->copy();	# but this is not really faster...

  $num->bone(); # keep ref to $num

  my $expbin = $exp->as_bin(); $expbin =~ s/^[-]?0b//; # ignore sign and prefix
  my $len = CORE::length($expbin);
  while (--$len >= 0)
    {
    if( substr($expbin,$len,1) eq '1')
      {
      $num->bmul($acc)->bmod($mod);
      }
    $acc->bmul($acc)->bmod($mod);
    }

  $num;
d1707 1
a1707 2
  # compute factorial numbers
  # modifies first argument
d1712 2
a1713 2
  return $x->bnan() if $x->{sign} ne '+';	# inf, NnN, <0 etc => NaN
  return $x->bone('+',@@r) if $x->is_zero() || $x->is_one();	# 0 or 1 => 1
d1715 1
a1715 1
  if ($CALC->can('_fac'))
d1721 2
a1722 9
  my $n = $x->copy();
  $x->bone();
  # seems we need not to temp. clear A/P of $x since the result is the same
  my $f = $self->new(2);
  while ($f->bacmp($n) < 0)
    {
    $x->bmul($f); $f->binc();
    }
  $x->bmul($f,@@r);			# last step and also round
d1747 3
a1749 2
  return $x->bone('+',@@r) if $y->is_zero();
  return $x->round(@@r) if $x->is_one() || $y->is_one();
d1758 1
a1758 2
  return $x->bnan() if $y->{sign} eq '-';
  return $x->round(@@r) if $x->is_zero();  # 0**y => 0 (if not y <= 0)
d1760 1
a1760 1
  if ($CALC->can('_pow'))
d1763 1
d1768 2
a1769 28
# based on the assumption that shifting in base 10 is fast, and that mul
# works faster if numbers are small: we count trailing zeros (this step is
# O(1)..O(N), but in case of O(N) we save much more time due to this),
# stripping them out of the multiplication, and add $count * $y zeros
# afterwards like this:
# 300 ** 3 == 300*300*300 == 3*3*3 . '0' x 2 * 3 == 27 . '0' x 6
# creates deep recursion since brsft/blsft use bpow sometimes.
#  my $zeros = $x->_trailing_zeros();
#  if ($zeros > 0)
#    {
#    $x->brsft($zeros,10);	# remove zeros
#    $x->bpow($y);		# recursion (will not branch into here again)
#    $zeros = $y * $zeros; 	# real number of zeros to add
#    $x->blsft($zeros,10);
#    return $x->round(@@r);
#    }

  my $pow2 = $self->__one();
  my $y_bin = $y->as_bin(); $y_bin =~ s/^0b//;
  my $len = CORE::length($y_bin);
  while (--$len > 0)
    {
    $pow2->bmul($x) if substr($y_bin,$len,1) eq '1';	# is odd?
    $x->bmul($x);
    }
  $x->bmul($pow2);
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
d1791 1
a1791 1
  my $t; $t = $CALC->_lsft($x->{value},$y->{value},$n) if $CALC->can('_lsft');
d1797 1
a1797 1
  return $x->bmul( $self->bpow($n, $y, @@r), @@r );
d1853 1
d1857 1
a1857 1
  my $t; $t = $CALC->_rsft($x->{value},$y->{value},$n) if $CALC->can('_rsft');
a1883 1
  local $Math::BigInt::upgrade = undef;
a1885 1
  return $x->bzero(@@r) if $y->is_zero() || $x->is_zero();
d1887 2
a1888 4
  my $sign = 0;					# sign of result
  $sign = 1 if ($x->{sign} eq '-') && ($y->{sign} eq '-');
  my $sx = 1; $sx = -1 if $x->{sign} eq '-';
  my $sy = 1; $sy = -1 if $y->{sign} eq '-';
d1890 1
a1890 1
  if ($CALC->can('_and') && $sx == 1 && $sy == 1)
d1895 5
a1899 16

  my $m = $self->bone(); my ($xr,$yr);
  my $x10000 = $self->new (0x1000);
  my $y1 = copy(ref($x),$y);	 		# make copy
  $y1->babs();					# and positive
  my $x1 = $x->copy()->babs(); $x->bzero();	# modify x in place!
  use integer;					# need this for negative bools
  while (!$x1->is_zero() && !$y1->is_zero())
    {
    ($x1, $xr) = bdiv($x1, $x10000);
    ($y1, $yr) = bdiv($y1, $x10000);
    # make both op's numbers!
    $x->badd( bmul( $class->new(
       abs($sx*int($xr->numify()) & $sy*int($yr->numify()))), 
      $m));
    $m->bmul($x10000);
d1901 3
a1903 2
  $x->bneg() if $sign;
  $x->round(@@r);
a1924 1
  return $x->round(@@r) if $y->is_zero();
d1926 2
a1927 4
  my $sign = 0;					# sign of result
  $sign = 1 if ($x->{sign} eq '-') || ($y->{sign} eq '-');
  my $sx = 1; $sx = -1 if $x->{sign} eq '-';
  my $sy = 1; $sy = -1 if $y->{sign} eq '-';
d1929 2
d1932 1
a1932 1
  if ($CALC->can('_or') && $sx == 1 && $sy == 1)
d1938 5
a1942 15
  my $m = $self->bone(); my ($xr,$yr);
  my $x10000 = $self->new(0x10000);
  my $y1 = copy(ref($x),$y);	 		# make copy
  $y1->babs();					# and positive
  my $x1 = $x->copy()->babs(); $x->bzero();	# modify x in place!
  use integer;					# need this for negative bools
  while (!$x1->is_zero() || !$y1->is_zero())
    {
    ($x1, $xr) = bdiv($x1,$x10000);
    ($y1, $yr) = bdiv($y1,$x10000);
    # make both op's numbers!
    $x->badd( bmul( $class->new(
       abs($sx*int($xr->numify()) | $sy*int($yr->numify()))), 
      $m));
    $m->bmul($x10000);
d1944 3
a1946 2
  $x->bneg() if $sign;
  $x->round(@@r);
a1964 2
  local $Math::BigInt::upgrade = undef;

a1965 1
  return $x->round(@@r) if $y->is_zero();
d1967 2
a1968 4
  my $sign = 0;					# sign of result
  $sign = 1 if $x->{sign} ne $y->{sign};
  my $sx = 1; $sx = -1 if $x->{sign} eq '-';
  my $sy = 1; $sy = -1 if $y->{sign} eq '-';
d1971 1
a1971 1
  if ($CALC->can('_xor') && $sx == 1 && $sy == 1)
d1976 7
d1984 2
a1985 18
  my $m = $self->bone(); my ($xr,$yr);
  my $x10000 = $self->new(0x10000);
  my $y1 = copy(ref($x),$y);	 		# make copy
  $y1->babs();					# and positive
  my $x1 = $x->copy()->babs(); $x->bzero();	# modify x in place!
  use integer;					# need this for negative bools
  while (!$x1->is_zero() || !$y1->is_zero())
    {
    ($x1, $xr) = bdiv($x1, $x10000);
    ($y1, $yr) = bdiv($y1, $x10000);
    # make both op's numbers!
    $x->badd( bmul( $class->new(
       abs($sx*int($xr->numify()) ^ $sy*int($yr->numify()))), 
      $m));
    $m->bmul($x10000);
    }
  $x->bneg() if $sign;
  $x->round(@@r);
d1990 1
a1990 1
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
d1993 1
a1993 1
  return wantarray ? ($e,0) : $e;
d2006 1
a2006 1
  # return the amount of trailing zeros in $x
d2012 1
a2012 1
  return $CALC->_zeros($x->{value}) if $CALC->can('_zeros');
a2028 1
  return $x->round(@@r) if $x->is_zero() || $x->is_one();	# 0,1 => 0,1
d2032 1
a2032 1
  if ($CALC->can('_sqrt'))
d2038 2
a2039 19
  return $x->bone('+',@@r) if $x < 4;				# 2,3 => 1
  my $y = $x->copy();
  my $l = int($x->length()/2);
  
  $x->bone();					# keep ref($x), but modify it
  $x->blsft($l,10) if $l != 0;			# first guess: 1.('0' x (l/2))

  my $last = $self->bzero();
  my $two = $self->new(2);
  my $lastlast = $self->bzero();
  #my $lastlast = $x+$two;
  while ($last != $x && $lastlast != $x)
    {
    $lastlast = $last; $last = $x->copy(); 
    $x->badd($y / $x); 
    $x->bdiv($two);
    }
  $x->bdec() if $x * $x > $y;				# overshot?
  $x->round(@@r);
d2054 1
a2054 1
    ($self,$x,$y,@@r) = $self->objectify(2,@@_);
d2068 1
a2068 1
  if ($CALC->can('_root'))
d2074 2
a2075 42
  return $x->bsqrt() if $y->bacmp(2) == 0;	# 2 => square root

  # since we take at least a cubic root, and only 8 ** 1/3 >= 2 (==2):
  return $x->bone('+',@@r) if $x < 8;		# $x=2..7 => 1

  my $num = $x->numify();

  if ($num <= 1000000)
    {
    $x = $self->new( int($num ** (1 / $y->numify()) ));
    return $x->round(@@r);
    }

  # if $n is a power of two, we can repeatedly take sqrt($X) and find the
  # proper result, because sqrt(sqrt($x)) == root($x,4)
  # See Calc.pm for more details
  my $b = $y->as_bin();
  if ($b =~ /0b1(0+)/)
    {
    my $count = CORE::length($1);	# 0b100 => len('00') => 2
    my $cnt = $count;			# counter for loop
    my $shift = $self->new(6);
    $x->blsft($shift);			# add some zeros (even amount)
    while ($cnt-- > 0)
      {
      # 'inflate' $X by adding more zeros
      $x->blsft($shift);
      # calculate sqrt($x), $x is now a bit too big, again. In the next
      # round we make even bigger, again.
      $x->bsqrt($x);
      }
    # $x is still to big, so truncate result
    $x->brsft($shift);
    }
  else
    {
    # Should compute a guess of the result (by rule of thumb), then improve it
    # via Newton's method or something similiar.
    # XXX TODO
    warn ('broot() not fully implemented in BigInt.');
    }
  return $x->round(@@r);
d2085 2
a2086 2
    my $s = $x->{sign}; $s =~ s/^[+-]//;
    return $self->new($s); 		# -inf,+inf => inf
d2088 3
a2090 4
  my $e = $class->bzero();
  return $e->binc() if $x->is_zero();
  $e += $x->_trailing_zeros();
  $e;
d2100 2
a2101 1
    return $self->new($x->{sign}); 		# keep + or - sign
d2103 2
a2104 2
  my $m = $x->copy();
  # that's inefficient
d2113 1
a2113 1
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
d2115 1
a2115 1
  return ($x->mantissa(),$x->exponent());
d2126 1
d2128 2
a2129 2
  return $x if !defined $scale;		# no-op
  return $x if $x->modify('bfround');
d2132 1
a2132 5
  if ($scale <= 0)
    {
    $x->{_a} = undef;				# clear an eventual set A
    $x->{_p} = $scale; return $x;
    }
a2133 1
  $x->bround( $x->length()-$scale, $mode);
d2141 2
a2142 3
  my $x = shift;
  my $pad = shift;
  my $xs = shift;
a2149 1
  #my $r = substr ($$xs,-$follow);
d2151 1
a2151 2
  return 1 if $r =~ /[^0]/;
  0;
d2156 2
a2157 2
  # to make life easier for switch between MBF and MBI (autoload fxxx()
  # like MBF does for bxxx()?)
d2159 1
a2159 1
  return $x->bround(@@_);
d2270 2
a2271 3
  # return integer less or equal then number, since it is already integer,
  # always returns $self
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
d2278 2
a2279 3
  # return integer greater or equal then number, since it is already integer,
  # always returns $self
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
d2284 7
a2290 2
##############################################################################
# private stuff (internal use only)
d2292 1
a2292 1
sub __one
d2294 14
a2307 5
  # internal speedup, set argument to 1, or create a +/- 1
  my $self = shift;
  my $x = $self->bone(); # $x->{value} = $CALC->_one();
  $x->{sign} = shift || '+';
  $x;
d2310 1
a2310 1
sub _swap
d2312 7
a2318 18
  # Overload will swap params if first one is no object ref so that the first
  # one is always an object ref. In this case, third param is true.
  # This routine is to overcome the effect of scalar,$object creating an object
  # of the class of this package, instead of the second param $object. This
  # happens inside overload, when the overload section of this package is
  # inherited by sub classes.
  # For overload cases (and this is used only there), we need to preserve the
  # args, hence the copy().
  # You can override this method in a subclass, the overload section will call
  # $object->_swap() to make sure it arrives at the proper subclass, with some
  # exceptions like '+' and '-'. To make '+' and '-' work, you also need to
  # specify your own overload for them.

  # object, (object|scalar) => preserve first and make copy
  # scalar, object	    => swapped, re-swap and create new from first
  #                            (using class of second object, not $class!!)
  my $self = shift;			# for override in subclass
  if ($_[2])
d2320 1
a2320 2
    my $c = ref ($_[0]) || $class; 	# fallback $class should not happen
    return ( $c->new($_[1]), $_[0] );
d2322 4
a2325 1
  return ( $_[0]->copy(), $_[1] );
d2328 3
d2432 1
a2432 1
  $IMPORT++;
d2439 3
a2441 2
      overload::constant integer => sub { $self->new(shift) };
      overload::constant binary => sub { $self->new(shift) };
d2493 17
a2509 1
    Carp::croak ("Couldn't load any math lib, not even the default");
d2529 1
a2529 1
  if ($CALC->can('_from_hex'))
d2536 1
a2536 1
    my $mul = Math::BigInt->bzero(); $mul++;
d2538 2
a2539 2
    my $len = CORE::length($$hs)-2;
    $len = int($len/4);			# 4-digit parts, w/o '0x'
d2568 1
a2568 1
  if ($CALC->can('_from_bin'))
d2574 1
a2574 1
    my $mul = Math::BigInt->bzero(); $mul++;
d2576 1
a2576 1
    my $len = CORE::length($$bs)-2;
d2645 1
a2645 1
    return if defined $lastf;		# last defined => 1.2.3 or others
a2661 85
sub as_number
  {
  # an object might be asked to return itself as bigint on certain overloaded
  # operations, this does exactly this, so that sub classes can simple inherit
  # it or override with their own integer conversion routine
  my $self = shift;

  $self->copy();
  }

sub as_hex
  {
  # return as hex string, with prefixed 0x
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $es = ''; my $s = '';
  $s = $x->{sign} if $x->{sign} eq '-';
  if ($CALC->can('_as_hex'))
    {
    $es = ${$CALC->_as_hex($x->{value})};
    }
  else
    {
    return '0x0' if $x->is_zero();

    my $x1 = $x->copy()->babs(); my ($xr,$x10000,$h);
    if ($] >= 5.006)
      {
      $x10000 = Math::BigInt->new (0x10000); $h = 'h4';
      }
    else
      {
      $x10000 = Math::BigInt->new (0x1000); $h = 'h3';
      }
    while (!$x1->is_zero())
      {
      ($x1, $xr) = bdiv($x1,$x10000);
      $es .= unpack($h,pack('v',$xr->numify()));
      }
    $es = reverse $es;
    $es =~ s/^[0]+//; 	# strip leading zeros
    $s .= '0x';
    }
  $s . $es;
  }

sub as_bin
  {
  # return as binary string, with prefixed 0b
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $es = ''; my $s = '';
  $s = $x->{sign} if $x->{sign} eq '-';
  if ($CALC->can('_as_bin'))
    {
    $es = ${$CALC->_as_bin($x->{value})};
    }
  else
    {
    return '0b0' if $x->is_zero();
    my $x1 = $x->copy()->babs(); my ($xr,$x10000,$b);
    if ($] >= 5.006)
      {
      $x10000 = Math::BigInt->new (0x10000); $b = 'b16';
      }
    else
      {
      $x10000 = Math::BigInt->new (0x1000); $b = 'b12';
      }
    while (!$x1->is_zero())
      {
      ($x1, $xr) = bdiv($x1,$x10000);
      $es .= unpack($b,pack('v',$xr->numify()));
      }
    $es = reverse $es; 
    $es =~ s/^[0]+//; 	# strip leading zeros
    $s .= '0b';
    }
  $s . $es;
  }

d2694 1
a2694 1
# We use a fast use constant statement here, to avoid costly calls. Subclasses
d2734 2
a2735 2
  $x->is_positive();	# if $x >= 0
  $x->is_negative();	# if $x <  0
d2812 2
a2813 1
  $x->as_number();	   # return as BigInt (in BigInt: same as copy())
d2820 1
a2820 1
  
d2852 1
a2852 1
your input if you want BigInt to see all the digits.
d2863 5
a2867 1
results in 'NaN'.
d2870 1
a2870 1
are always stored in normalized form. On a string, it creates a BigInt 
d2904 1
a2904 1
	lib		Name of the Math library
d2906 1
a2906 1
	lib_version 	Version of 'lib'
d2908 1
a2908 1
	class		The class of config you just called
d2910 1
a2910 1
	upgrade		To which class numbers are upgraded
d2912 1
a2912 1
	downgrade	To which class numbers are downgraded
d2924 4
d3099 1
a3099 1
=head2 is_positive()/is_negative()
d3101 2
a3102 2
	$x->is_positive();		# true if >= 0
	$x->is_negative();		# true if <  0
d3110 5
d3145 3
a3147 1
=head2 bcmp
d3149 1
a3149 1
  $x->digit($n);		# return the nth digit, counting from right
d3172 7
a3178 1
	$x->bnot();			# two's complement (bit wise not)
d3228 1
a3228 1
because C<bmodpow> is much faster--it reduces internal variables into
d3343 3
a3345 1
=head2 as_number
d3347 5
a3351 1
	$x->as_number();	# return as BigInt (in BigInt: same as copy())
d3353 3
a3355 1
=head2 bsrt
d3357 1
a3357 1
	$x->bstr();		# return normalized string
d3375 1
a3375 1
operation as well as manually.
d3533 1
a3533 1
    the + sign (oups) and actually gets 2 for '+100' and 4 for '+101'. Oups
d3550 4
a3553 3
  * You can set the A global via Math::BigInt->accuracy() or
    Math::BigFloat->accuracy() or whatever class you are using.
  * You can also set P globally by using Math::SomeClass->precision() likewise.
d3555 4
a3558 4
  * to undefine A, use Math::SomeCLass->accuracy(undef);
  * to undefine P, use Math::SomeClass->precision(undef);
  * Setting Math::SomeClass->accuracy() clears automatically
    Math::SomeClass->precision(), and vice versa.
d3563 7
a3569 5
  * to find out the current global A, take Math::SomeClass->accuracy()
  * to find out the current global P, take Math::SomeClass->precision()
  * use $x->accuracy() respective $x->precision() for the local setting of $x.
  * Please note that $x->accuracy() respecive $x->precision() fall back to the
    defined globals, when $x's A or P is not set.
d3584 1
a3584 1
    $x = Math::BigInt->new($number,undef,undef):
d3602 3
a3604 3
  * Math::BigFloat uses Math::BigInts internally, but setting A or P inside
    Math::BigInt as globals should not tamper with the parts of a BigFloat.
    Thus a flag is used to mark all Math::BigFloat numbers as 'never round'
d3609 2
a3610 3
    Since you can set/get both A and P, there is a rule that will practically
    enforce only A or P to be in effect at a time, even if both are set.
    This is called precedence.
d3613 4
a3616 4
  * A takes precendence over P (Hint: A comes before P). If A is defined, it
    is used, otherwise P is used. If neither of them is defined, nothing is
    used, i.e. the result will have as many digits as it can (with an
    exception for fdiv/fsqrt) and will not be rounded.
d3627 1
a3627 1
  * Thus you can have the math done by on Math::Big* class in three modes:
d3676 2
a3677 1
  * You can set A and P locally by using $x->accuracy() and $x->precision()
d3680 1
a3680 1
  * $x->accuracy() clears $x->precision(), and vice versa.
d3690 3
a3692 3
  * you can set and get the global R by using Math::SomeClass->round_mode()
    or by setting $Math::SomeClass::round_mode
  * after each operation, $result->round() is called, and the result may
d3695 1
a3695 1
  * to manually round a number, call $x->round($A,$P,$round_mode);
d3734 1
a3734 1
Math::BigInt::Calc. This is equivalent to saying:
d3747 11
a3757 5
Calc.pm uses as internal format an array of elements of some decimal base
(usually 1e5 or 1e7) with the least significant digit first, while BitVect.pm
uses a bit vector of base 2, most significant bit first. Other modules might
use even different means of representing the numbers. See the respective
module documentation for further details.
d3781 7
a3787 8
Currently, for BigInts C<$e> will be always 0, except for NaN, +inf and -inf,
where it will be NaN; and for $x == 0, where it will be 1
(to be compatible with Math::BigFloat's internal representation of a zero as
C<0E1>).

C<$m> will always be a copy of the original number. The relation between $e
and $m might change in the future, but will always be equivalent in a
numerical sense, e.g. $m might get minimized.
d3896 2
a3897 1
to a constant overhead for all other operatons.
d3899 5
a3903 5
The rewritten version of this module is slower on certain operations, like
new(), bstr() and numify(). The reason are that it does now more work and
handles more cases. The time spent in these operations is usually gained in
the other operations so that programs on the average should get faster. If
they don't, please contect the author.
d3906 3
a3908 3
for big numbers. Other operations are now constant (O(1), like bneg(), babs()
etc), instead of O(N) and thus nearly always take much less time. These
optimizations were done on purpose.
d4065 1
a4065 1
=item stringify, bstr(), bsstr() and 'cmp'
d4067 5
a4071 4
Both stringify and bstr() now drop the leading '+'. The old code would return
'+3', the new returns '3'. This is to be consistent with Perl and to make
cmp (especially with overloading) to work as you expect. It also solves
problems with Test.pm, it's ok() uses 'eq' internally. 
d4073 2
a4074 1
Mark said, when asked about to drop the '+' altogether, or make only cmp work:
d4104 2
a4105 1
as 1e+308. If in doubt, convert both arguments to Math::BigInt before doing eq:
d4117 3
a4119 3
Alternatively, simple use <=> for comparisations, that will get it always
right. There is not yet a way to get a number automatically represented as
a string that matches exactly the way Perl represents it.
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d21 1
a21 2
# This is a patched v1.60, containing a fix for the "1234567890\n" bug
$VERSION = '1.60';
d27 2
d119 2
a120 7
use constant MB_NEVER_ROUND => 0x0001;

my $NaNOK=1; 				# are NaNs ok?
my $nan = 'NaN'; 			# constants for easier life

my $CALC = 'Math::BigInt::Calc';	# module to do low level math
my $IMPORT = 0;				# did import() yet?
d130 12
d163 4
a166 2
    die "Unknown round mode $m"
     if $m !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/;
d169 1
a169 1
  return ${"${class}::round_mode"};
d184 1
a184 1
  return ${"${class}::upgrade"};
d199 1
a199 1
  return ${"${class}::downgrade"};
d205 1
a205 1
  # make Class->round_mode() work
d210 4
a213 1
    die ('div_scale must be greater than zero') if $_[0] < 0;
d216 1
a216 1
  return ${"${class}::div_scale"};
d234 18
a251 1
    die ('accuracy must not be zero') if defined $a && $a == 0;
d255 4
a258 3
      $x->bround($a) if defined $a;
      $x->{_a} = $a;			# set/overwrite, even if not rounded
      $x->{_p} = undef;			# clear P
d264 1
a264 1
      ${"${class}::precision"} = undef;	# clear P
d266 1
a266 1
    return $a;				# shortcut
d275 1
a275 1
  } 
a287 1
  # need to set new value?
d291 8
d302 4
a305 3
      $x->bfround($p) if defined $p;
      $x->{_p} = $p;			# set/overwrite, even if not rounded
      $x->{_a} = undef;			# clear A
d311 1
a311 1
      ${"${class}::accuracy"} = undef;	# clear A
d313 1
a313 1
    return $p;				# shortcut
d322 1
a322 1
  } 
d326 1
a326 1
  # return (later set?) configuration data as hash ref
d330 39
a368 1
  my $lib = $CALC;
d370 2
a371 2
    lib => $lib,
    lib_version => ${"${lib}::VERSION"},
d373 3
d377 3
a379 2
  foreach (
   qw/upgrade downgrade precision accuracy round_mode VERSION div_scale/)
d381 1
a381 1
    $cfg->{lc($_)} = ${"${class}::$_"};
d497 1
a497 1
      # remove sign without touching wanted
d500 4
d527 4
a530 2
    die "$wanted is not a number initialized to $class" if !$NaNOK;
    #print "NaN 1\n";
d551 4
d562 1
a562 1
      # print "diff > 0 $$miv\n";
d571 4
d586 4
d614 6
a621 1
  my $c = ref($self);
d648 6
a655 1
  my $c = ref($self);
d684 1
a684 1

d721 1
a721 1
 
d775 1
a775 3
  # e can only be positive
  my $sign = 'e+';	
  # MBF: my $s = $e->{sign}; $s = '' if $s eq '-'; my $sep = 'e'.$s;
d798 2
a799 1
  return $x->{sign} if $x->{sign} !~ /^[+-]$/;
d821 2
d826 3
d837 1
a837 1
  return ($self) if exists $self->{_f} && $self->{_f} & MB_NEVER_ROUND != 0;
d864 3
d872 1
a872 1
  return ($self->bnan()) if defined $a && defined $p;
d875 6
a880 3
  die "Unknown round mode '$r'" if $r !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/;
 
  return ($self,$a,$p,$r);
d897 1
a897 1
  return ($self) if exists $self->{_f} && $self->{_f} & MB_NEVER_ROUND != 0;
d925 3
d935 4
a938 1
  die "Unknown round mode '$r'" if $r !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/;
d999 3
d1044 3
d1213 1
a1213 1
  return $upgrade->blog($x,$base,$a,$p,$r) if defined $upgrade;
d1326 1
a1326 1
  $sign = '' if !defined $sign; $sign = '+' if $sign ne '-';
a1489 27
  return $upgrade->bdiv($upgrade->new($x),$y,@@r)
   if defined $upgrade && !$y->isa($self);

  $r[3] = $y;					# no push!

  # 0 / something
  return
   wantarray ? ($x->round(@@r),$self->bzero(@@r)):$x->round(@@r) if $x->is_zero();
 
  # Is $x in the interval [0, $y) (aka $x <= $y) ?
  my $cmp = $CALC->_acmp($x->{value},$y->{value});
  if (($cmp < 0) and (($x->{sign} eq $y->{sign}) or !wantarray))
    {
    return $upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@@r)
     if defined $upgrade;

    return $x->bzero()->round(@@r) unless wantarray;
    my $t = $x->copy();      # make copy first, because $x->bzero() clobbers $x
    return ($x->bzero()->round(@@r),$t);
    }
  elsif ($cmp == 0)
    {
    # shortcut, both are the same, so set to +/- 1
    $x->__one( ($x->{sign} ne $y->{sign} ? '-' : '+') ); 
    return $x unless wantarray;
    return ($x->round(@@r),$self->bzero(@@r));
    }
d1493 2
a1497 5
  # check for / +-1 (cant use $y->is_one due to '-'
  if ($CALC->_is_one($y->{value}))
    {
    return wantarray ? ($x->round(@@r),$self->bzero(@@r)) : $x->round(@@r); 
    }
d1506 1
a1506 1
    $x->round(@@r); 
d1510 1
a1510 1
      $rem = $y-$rem if $xsign ne $y->{sign};	# one of them '-'
d1516 2
a1517 1
    return ($x,$rem->round(@@r));
d1523 1
a1523 1
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
d1586 1
a1586 1
  # modular inverse.  given a number which is (hopefully) relatively
d1588 1
a1588 1
  # alogrithm.  if the number is not relatively prime to the modulus
d1593 1
a1593 1
  # objectify is costly, so avoid it 
d1597 1
a1597 1
    } 
d1602 3
a1604 3
	if ($y->{sign} ne '+'				# -, NaN, +inf, -inf
         || $x->is_zero()				# or num == 0
	 || $x->{sign} !~ /^[+-]$/			# or num NaN, inf, -inf
d1612 6
a1617 2
    $x->{value} = $CALC->_modinv($x->{value},$y->{value});
    $x->bnan() if !defined $x->{value} ;            # in case there was none
a1619 1

d1629 18
a1646 4
  # Euclid's Algorithm
  while (!$b->is_zero())
    {
    ($u, $u1) = ($u1, $u->bsub($u1->copy()->bmul($q))); # step #2
d1650 3
a1652 3
  # if the gcd is not 1, then return NaN!  It would be pointless to
  # have called bgcd to check this first, because we would then be performing
  # the same Euclidean Algorithm *twice*
d1655 5
a1659 3
  $u1->bmod($y);
  $x->{value} = $u1->{value};
  $x->{sign} = $u1->{sign};
d1705 1
a1705 1
  my $len = length($expbin);
d1754 1
a1754 1
  
d1810 1
a1810 1
  my $len = length($y_bin);
d2108 1
d2113 3
a2115 3
  return $x->bnan() if $x->{sign} ne '+';	# -x or inf or NaN => NaN
  return $x->bzero(@@r) if $x->is_zero();			# 0 => 0
  return $x->round(@@r) if $x->is_one();			# 1 => 1
d2130 1
a2130 1
  $x->blsft($l,10);
d2134 2
a2135 1
  my $lastlast = $x+$two;
d2138 3
a2140 3
    $lastlast = $last; $last = $x; 
    $x += $y / $x; 
    $x /= $two;
d2142 1
a2142 1
  $x-- if $x * $x > $y;				# overshot?
d2146 76
d2335 5
d2356 1
a2356 1
 
d2394 1
a2394 1
    $pad = $len, $$xs = '0'x$pad if $scale < 0;		# tlr: whack 0.51=>1.0	
d2528 1
a2528 1
  # print "Now in objectify, my class is today $a[0]\n";
d2565 4
a2568 1
  die "$class objectify needs list context" unless wantarray;
d2634 5
a2638 1
  die "Couldn't load any math lib, not even the default" if $CALC eq '';
d2756 1
a2756 1
  # .2 	   # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2
d2758 1
a2758 1
  return if $$x =~ /[Ee].*[Ee]/;	# more than one E => error
d2760 2
a2761 1
  my ($m,$e) = split /[Ee]/,$$x;
d2763 1
d2772 2
a2773 2
    my ($mi,$mf,$last) = split /\./,$m;
    return if defined $last;		# last defined => 1.2.3 or others
d2782 2
a2805 1
  return '0x0' if $x->is_zero();
d2815 2
a2843 1
  return '0b0' if $x->is_zero();
d2853 1
d2923 6
d2938 2
a2939 19
  # Testing
  $x->is_zero();		# true if arg is +0
  $x->is_nan();			# true if arg is NaN
  $x->is_one();			# true if arg is +1
  $x->is_one('-');		# true if arg is -1
  $x->is_odd();			# true if odd, false for even
  $x->is_even();		# true if even, false for odd
  $x->is_positive();		# true if >= 0
  $x->is_negative();		# true if <  0
  $x->is_inf(sign);		# true if +inf, or -inf (sign is default '+')
  $x->is_int();			# true if $x is an integer (not a float)

  $x->bcmp($y);			# compare numbers (undef,<0,=0,>0)
  $x->bacmp($y);		# compare absolutely (undef,<0,=0,>0)
  $x->sign();			# return the sign, either +,- or NaN
  $x->digit($n);		# return the nth digit, counting from right
  $x->digit(-$n);		# return the nth digit, counting from left

  # The following all modify their first argument:
d2941 35
a2975 14
  # set 
  $x->bzero();			# set $x to 0
  $x->bnan();			# set $x to NaN
  $x->bone();			# set $x to +1
  $x->bone('-');		# set $x to -1
  $x->binf();			# set $x to inf
  $x->binf('-');		# set $x to -inf

  $x->bneg();			# negation
  $x->babs();			# absolute value
  $x->bnorm();			# normalize (no-op)
  $x->bnot();			# two's complement (bit wise not)
  $x->binc();			# increment x by 1
  $x->bdec();			# decrement x by 1
d2977 15
a2991 15
  $x->badd($y);			# addition (add $y to $x)
  $x->bsub($y);			# subtraction (subtract $y from $x)
  $x->bmul($y);			# multiplication (multiply $x by $y)
  $x->bdiv($y);			# divide, set $x to quotient
				# return (quo,rem) or quo if scalar

  $x->bmod($y);			# modulus (x % y)
  $x->bmodpow($exp,$mod);	# modular exponentation (($num**$exp) % $mod))
  $x->bmodinv($mod);		# the inverse of $x in the given modulus $mod

  $x->bpow($y);			# power of arguments (x ** y)
  $x->blsft($y);		# left shift
  $x->brsft($y);		# right shift 
  $x->blsft($y,$n);		# left shift, by base $n (like 10)
  $x->brsft($y,$n);		# right shift, by base $n (like 10)
d2993 18
a3010 15
  $x->band($y);			# bitwise and
  $x->bior($y);			# bitwise inclusive or
  $x->bxor($y);			# bitwise exclusive or
  $x->bnot();			# bitwise not (two's complement)

  $x->bsqrt();			# calculate square-root
  $x->bfac();			# factorial of $x (1*2*3*4*..$x)

  $x->round($A,$P,$round_mode); # round to accuracy or precision using mode $r
  $x->bround($N);               # accuracy: preserve $N digits
  $x->bfround($N);              # round to $Nth digit, no-op for BigInts

  # The following do not modify their arguments in BigInt, but do in BigFloat:
  $x->bfloor();			# return integer less or equal than $x
  $x->bceil();			# return integer greater or equal than $x
d3014 2
a3015 2
  bgcd(@@values);		# greatest common divisor (no OO style)
  blcm(@@values);		# lowest common multiplicator (no OO style)
d3017 9
a3025 9
  $x->length();			# return number of digits in number
  ($x,$f) = $x->length();	# length of number and length of fraction part,
				# latter is always 0 digits long for BigInt's

  $x->exponent();		# return exponent as BigInt
  $x->mantissa();		# return (signed) mantissa as BigInt
  $x->parts();			# return (mantissa,exponent) as BigInt
  $x->copy();			# make a true copy of $x (unlike $y = $x;)
  $x->as_number();		# return as BigInt (in BigInt: same as copy())
d3027 5
a3031 5
  # conversation to string 
  $x->bstr();			# normalized string
  $x->bsstr();			# normalized string in scientific notation
  $x->as_hex();			# as signed hexadecimal string with prefixed 0x
  $x->as_bin();			# as signed binary string with prefixed 0b
a3032 1
  Math::BigInt->config();	# return hash containing configuration/version
d3035 9
a3043 7
  $x->precision();              # return P of $x (or global, if P of $x undef)
  $x->precision($n);            # set P of $x to $n
  $x->accuracy();               # return A of $x (or global, if A of $x undef)
  $x->accuracy($n);             # set A $x to $n

  Math::BigInt->precision();	# get/set global P for all BigInt objects
  Math::BigInt->accuracy();	# get/set global A for all BigInt objects
d3057 1
a3057 1
=item Canonical notation
d3059 2
a3060 2
Big integer values are strings of the form C</^[+-]\d+$/> with leading
zeros suppressed.
d3062 3
a3064 3
   '-0'                            canonical value '-0', normalized '0'
   '   -123_123_123'               canonical value '-123123123'
   '1_23_456_7890'                 canonical value '1234567890'
d3066 2
a3067 4
=item Input

Input values to these routines may be either Math::BigInt objects or
strings of the form C</^[+-]?[\d]+\.?[\d]*E?[+-]?[\d]*$/>.
d3069 1
a3069 4
You can include one underscore between any two digits. The input string may
have leading and trailing whitespace, which will be ignored. In later
versions, a more strict (no whitespace at all) or more lax (whitespace
allowed everywhere) input checking will also be possible.
d3072 1
a3072 1
Non integer values result in NaN.
d3074 2
a3075 2
Math::BigInt::new() defaults to 0, while Math::BigInt::new('') results
in 'NaN'.
d3077 1
a3077 1
bnorm() on a BigInt object is now effectively a no-op, since the numbers 
d3079 1
a3079 1
object.
d3093 4
a3096 3
Each of the methods below accepts three additional parameters. These arguments
$A, $P and $R are accuracy, precision and round_mode. Please see more in the
section about ACCURACY and ROUNDIND.
d3103 1
d3106 35
a3140 1
loaded etc.
d3145 3
a3147 1
	$class->accuracy(5);		# global for all members of $class
d3150 3
a3152 2
results have. Please see the section about L<ACCURACY AND PRECISION> for
further details.
d3173 39
d3241 1
a3241 1
Creates a new BigInt object from a string or another BigInt object. The
d3245 2
d3323 2
d3365 1
a3365 1
  $x->bnorm();			# normalize (no-op)
d3369 1
a3369 1
  $x->bnot();			# two's complement (bit wise not)
d3373 1
a3373 1
  $x->binc();			# increment x by 1
d3377 1
a3377 1
  $x->bdec();			# decrement x by 1
d3381 1
a3381 1
  $x->badd($y);			# addition (add $y to $x)
d3385 1
a3385 1
  $x->bsub($y);			# subtraction (subtract $y from $x)
d3389 1
a3389 1
  $x->bmul($y);			# multiplication (multiply $x by $y)
d3393 2
a3394 2
  $x->bdiv($y);			# divide, set $x to quotient
				# return (quo,rem) or quo if scalar
d3398 1
a3398 1
  $x->bmod($y);			# modulus (x % y)
d3402 1
a3402 1
  $num->bmodinv($mod);		# modular inverse
d3410 2
a3411 1
  $num->bmodpow($exp,$mod);	# modular exponentation ($num**$exp % $mod)
d3417 1
a3417 1
  $num ** $exp % $mod
d3424 1
a3424 1
  bmodpow($num, -1, $mod)
d3428 1
a3428 1
  bmodinv($num, $mod)
d3432 1
a3432 1
  $x->bpow($y);			# power of arguments (x ** y)
d3436 2
a3437 2
  $x->blsft($y);		# left shift
  $x->blsft($y,$n);		# left shift, by base $n (like 10)
d3441 2
a3442 2
  $x->brsft($y);		# right shift 
  $x->brsft($y,$n);		# right shift, by base $n (like 10)
d3446 1
a3446 1
  $x->band($y);			# bitwise and
d3450 1
a3450 1
  $x->bior($y);			# bitwise inclusive or
d3454 1
a3454 1
  $x->bxor($y);			# bitwise exclusive or
d3458 1
a3458 1
  $x->bnot();			# bitwise not (two's complement)
d3462 1
a3462 1
  $x->bsqrt();			# calculate square-root
d3466 1
a3466 1
  $x->bfac();			# factorial of $x (1*2*3*4*..$x)
d3470 4
a3473 1
  $x->round($A,$P,$round_mode); # round to accuracy or precision using mode $r
d3477 1
a3477 1
  $x->bround($N);               # accuracy: preserve $N digits
d3481 1
a3481 1
  $x->bfround($N);              # round to $Nth digit, no-op for BigInts
d3499 1
a3499 1
  bgcd(@@values);		# greatest common divisor (no OO style)
d3503 1
a3503 1
  blcm(@@values);		# lowest common multiplicator (no OO style)
d3528 1
a3528 1
  $x->parts();			# return (mantissa,exponent) as BigInt
d3532 1
a3532 1
  $x->copy();			# make a true copy of $x (unlike $y = $x;)
d3536 1
a3536 1
  $x->as_number();		# return as BigInt (in BigInt: same as copy())
d3540 1
a3540 1
  $x->bstr();			# normalized string
d3544 1
a3544 1
  $x->bsstr();			# normalized string in scientific notation
d3548 1
a3548 1
  $x->as_hex();			# as signed hexadecimal string with prefixed 0x
d3552 1
a3552 1
  $x->as_bin();			# as signed binary string with prefixed 0b
d3766 1
a3766 1
	use Math::Bigint::SomeSubclass;
d3972 2
a3973 2
  $x = Math::BigInt->bneg("1234");   	# Bigint "-1234"
  $x = Math::BigInt->babs("-12345"); 	# Bigint "12345"
d4041 1
a4041 1
	use Math::Bigint;
d4211 5
d4523 2
a4524 1
One solution to you problem might be L<autoupgrading|upgrading>.
d4530 1
a4530 1
mode.
d4556 5
a4560 2
L<Math::BigFloat> and L<Math::Big> as well as L<Math::BigInt::BitVect>,
L<Math::BigInt::Pari> and  L<Math::BigInt::GMP>.
d4570 6
a4575 1
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001.
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 39
a40 1
$VERSION='0.01';
d43 70
a112 27
'+'	=>	sub {new Math::BigInt &badd},
'-'	=>	sub {new Math::BigInt
		       $_[2]? bsub($_[1],${$_[0]}) : bsub(${$_[0]},$_[1])},
'<=>'	=>	sub {$_[2]? bcmp($_[1],${$_[0]}) : bcmp(${$_[0]},$_[1])},
'cmp'	=>	sub {$_[2]? ($_[1] cmp ${$_[0]}) : (${$_[0]} cmp $_[1])},
'*'	=>	sub {new Math::BigInt &bmul},
'/'	=>	sub {new Math::BigInt 
		       $_[2]? scalar bdiv($_[1],${$_[0]}) :
			 scalar bdiv(${$_[0]},$_[1])},
'%'	=>	sub {new Math::BigInt
		       $_[2]? bmod($_[1],${$_[0]}) : bmod(${$_[0]},$_[1])},
'**'	=>	sub {new Math::BigInt
		       $_[2]? bpow($_[1],${$_[0]}) : bpow(${$_[0]},$_[1])},
'neg'	=>	sub {new Math::BigInt &bneg},
'abs'	=>	sub {new Math::BigInt &babs},
'<<'	=>	sub {new Math::BigInt
		       $_[2]? blsft($_[1],${$_[0]}) : blsft(${$_[0]},$_[1])},
'>>'	=>	sub {new Math::BigInt
		       $_[2]? brsft($_[1],${$_[0]}) : brsft(${$_[0]},$_[1])},
'&'	=>	sub {new Math::BigInt &band},
'|'	=>	sub {new Math::BigInt &bior},
'^'	=>	sub {new Math::BigInt &bxor},
'~'	=>	sub {new Math::BigInt &bnot},

qw(
""	stringify
0+	numify)			# Order of arguments unsignificant
d115 90
a204 1
$NaNOK=1;
d206 30
a235 86
sub new {
  my($class) = shift;
  my($foo) = bnorm(shift);
  die "Not a number initialized to Math::BigInt" if !$NaNOK && $foo eq "NaN";
  bless \$foo, $class;
}
sub stringify { "${$_[0]}" }
sub numify { 0 + "${$_[0]}" }	# Not needed, additional overhead
				# comparing to direct compilation based on
				# stringify
sub import {
  shift;
  return unless @@_;
  die "unknown import: @@_" unless @@_ == 1 and $_[0] eq ':constant';
  overload::constant integer => sub {Math::BigInt->new(shift)};
}

$zero = 0;

# overcome a floating point problem on certain osnames (posix-bc, os390)
BEGIN {
    my $x = 100000.0;
    my $use_mult = int($x*1e-5)*1e5 == $x ? 1 : 0;
}

# normalize string form of number.   Strip leading zeros.  Strip any
#   white space and add a sign, if missing.
# Strings that are not numbers result the value 'NaN'.

sub bnorm { #(num_str) return num_str
    local($_) = @@_;
    s/\s+//g;                           # strip white space
    if (s/^([+-]?)0*(\d+)$/$1$2/) {     # test if number
	substr($_,$[,0) = '+' unless $1; # Add missing sign
	s/^-0/+0/;
	$_;
    } else {
	'NaN';
    }
}

# Convert a number from string format to internal base 100000 format.
#   Assumes normalized value as input.
sub internal { #(num_str) return int_num_array
    local($d) = @@_;
    ($is,$il) = (substr($d,$[,1),length($d)-2);
    substr($d,$[,1) = '';
    ($is, reverse(unpack("a" . ($il%5+1) . ("a5" x ($il/5)), $d)));
}

# Convert a number from internal base 100000 format to string format.
#   This routine scribbles all over input array.
sub external { #(int_num_array) return num_str
    $es = shift;
    grep($_ > 9999 || ($_ = substr('0000'.$_,-5)), @@_);   # zero pad
    &bnorm(join('', $es, reverse(@@_)));    # reverse concat and normalize
}

# Negate input value.
sub bneg { #(num_str) return num_str
    local($_) = &bnorm(@@_);
    return $_ if $_ eq '+0' or $_ eq 'NaN';
    vec($_,0,8) ^= ord('+') ^ ord('-');
    $_;
}

# Returns the absolute value of the input.
sub babs { #(num_str) return num_str
    &abs(&bnorm(@@_));
}

sub abs { # post-normalized abs for internal use
    local($_) = @@_;
    s/^-/+/;
    $_;
}

# Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)
sub bcmp { #(num_str, num_str) return cond_code
    local($x,$y) = (&bnorm($_[$[]),&bnorm($_[$[+1]));
    if ($x eq 'NaN') {
	undef;
    } elsif ($y eq 'NaN') {
	undef;
    } else {
	&cmp($x,$y) <=> 0;
a236 1
}
d238 38
a275 4
sub cmp { # post-normalized compare for internal use
    local($cx, $cy) = @@_;
    
    return 0 if ($cx eq $cy);
d277 67
a343 2
    local($sx, $sy) = (substr($cx, 0, 1), substr($cy, 0, 1));
    local($ld);
d345 38
a382 32
    if ($sx eq '+') {
      return  1 if ($sy eq '-' || $cy eq '+0');
      $ld = length($cx) - length($cy);
      return $ld if ($ld);
      return $cx cmp $cy;
    } else { # $sx eq '-'
      return -1 if ($sy eq '+');
      $ld = length($cy) - length($cx);
      return $ld if ($ld);
      return $cy cmp $cx;
    }
}

sub badd { #(num_str, num_str) return num_str
    local(*x, *y); ($x, $y) = (&bnorm($_[$[]),&bnorm($_[$[+1]));
    if ($x eq 'NaN') {
	'NaN';
    } elsif ($y eq 'NaN') {
	'NaN';
    } else {
	@@x = &internal($x);             # convert to internal form
	@@y = &internal($y);
	local($sx, $sy) = (shift @@x, shift @@y); # get signs
	if ($sx eq $sy) {
	    &external($sx, &add(*x, *y)); # if same sign add
	} else {
	    ($x, $y) = (&abs($x),&abs($y)); # make abs
	    if (&cmp($y,$x) > 0) {
		&external($sy, &sub(*y, *x));
	    } else {
		&external($sx, &sub(*x, *y));
	    }
d384 45
a429 1
}
d431 63
a493 70
sub bsub { #(num_str, num_str) return num_str
    &badd($_[$[],&bneg($_[$[+1]));    
}

# GCD -- Euclids algorithm Knuth Vol 2 pg 296
sub bgcd { #(num_str, num_str) return num_str
    local($x,$y) = (&bnorm($_[$[]),&bnorm($_[$[+1]));
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	($x, $y) = ($y,&bmod($x,$y)) while $y ne '+0';
	$x;
    }
}

# routine to add two base 1e5 numbers
#   stolen from Knuth Vol 2 Algorithm A pg 231
#   there are separate routines to add and sub as per Kunth pg 233
sub add { #(int_num_array, int_num_array) return int_num_array
    local(*x, *y) = @@_;
    $car = 0;
    for $x (@@x) {
	last unless @@y || $car;
	$x -= 1e5 if $car = (($x += (@@y ? shift(@@y) : 0) + $car) >= 1e5) ? 1 : 0;
    }
    for $y (@@y) {
	last unless $car;
	$y -= 1e5 if $car = (($y += $car) >= 1e5) ? 1 : 0;
    }
    (@@x, @@y, $car);
}

# subtract base 1e5 numbers -- stolen from Knuth Vol 2 pg 232, $x > $y
sub sub { #(int_num_array, int_num_array) return int_num_array
    local(*sx, *sy) = @@_;
    $bar = 0;
    for $sx (@@sx) {
	last unless @@sy || $bar;
	$sx += 1e5 if $bar = (($sx -= (@@sy ? shift(@@sy) : 0) + $bar) < 0);
    }
    @@sx;
}

# multiply two numbers -- stolen from Knuth Vol 2 pg 233
sub bmul { #(num_str, num_str) return num_str
    local(*x, *y); ($x, $y) = (&bnorm($_[$[]), &bnorm($_[$[+1]));
    if ($x eq 'NaN') {
	'NaN';
    } elsif ($y eq 'NaN') {
	'NaN';
    } else {
	@@x = &internal($x);
	@@y = &internal($y);
	&external(&mul(*x,*y));
    }
}

# multiply two numbers in internal representation
# destroys the arguments, supposes that two arguments are different
sub mul { #(*int_num_array, *int_num_array) return int_num_array
    local(*x, *y) = (shift, shift);
    local($signr) = (shift @@x ne shift @@y) ? '-' : '+';
    @@prod = ();
    for $x (@@x) {
      ($car, $cty) = (0, $[);
      for $y (@@y) {
	$prod = $x * $y + ($prod[$cty] || 0) + $car;
        if ($use_mult) {
	$prod[$cty++] =
	  $prod - ($car = int($prod * 1e-5)) * 1e5;
d495 969
a1463 3
        else {
	$prod[$cty++] =
	  $prod - ($car = int($prod / 1e5)) * 1e5;
d1466 202
a1667 2
      $prod[$cty] += $car if $car;
      $x = shift @@prod;
a1668 2
    ($signr, @@x, @@prod);
}
d1670 41
a1710 34
# modulus
sub bmod { #(num_str, num_str) return num_str
    (&bdiv(@@_))[$[+1];
}

sub bdiv { #(dividend: num_str, divisor: num_str) return num_str
    local (*x, *y); ($x, $y) = (&bnorm($_[$[]), &bnorm($_[$[+1]));
    return wantarray ? ('NaN','NaN') : 'NaN'
	if ($x eq 'NaN' || $y eq 'NaN' || $y eq '+0');
    return wantarray ? ('+0',$x) : '+0' if (&cmp(&abs($x),&abs($y)) < 0);
    @@x = &internal($x); @@y = &internal($y);
    $srem = $y[$[];
    $sr = (shift @@x ne shift @@y) ? '-' : '+';
    $car = $bar = $prd = 0;
    if (($dd = int(1e5/($y[$#y]+1))) != 1) {
	for $x (@@x) {
	    $x = $x * $dd + $car;
            if ($use_mult) {
	    $x -= ($car = int($x * 1e-5)) * 1e5;
            }
            else {
	    $x -= ($car = int($x / 1e5)) * 1e5;
            }
	}
	push(@@x, $car); $car = 0;
	for $y (@@y) {
	    $y = $y * $dd + $car;
            if ($use_mult) {
	    $y -= ($car = int($y * 1e-5)) * 1e5;
            }
            else {
	    $y -= ($car = int($y / 1e5)) * 1e5;
            }
	}
d1712 11
a1722 2
    else {
	push(@@x, 0);
d1724 15
a1738 28
    @@q = (); ($v2,$v1) = @@y[-2,-1];
    $v2 = 0 unless $v2;
    while ($#x > $#y) {
	($u2,$u1,$u0) = @@x[-3..-1];
	$u2 = 0 unless $u2;
	$q = (($u0 == $v1) ? 99999 : int(($u0*1e5+$u1)/$v1));
	--$q while ($v2*$q > ($u0*1e5+$u1-$q*$v1)*1e5+$u2);
	if ($q) {
	    ($car, $bar) = (0,0);
	    for ($y = $[, $x = $#x-$#y+$[-1; $y <= $#y; ++$y,++$x) {
		$prd = $q * $y[$y] + $car;
                if ($use_mult) {
		$prd -= ($car = int($prd * 1e-5)) * 1e5;
                }
                else {
		$prd -= ($car = int($prd / 1e5)) * 1e5;
                }
		$x[$x] += 1e5 if ($bar = (($x[$x] -= $prd + $bar) < 0));
	    }
	    if ($x[$#x] < $car + $bar) {
		$car = 0; --$q;
		for ($y = $[, $x = $#x-$#y+$[-1; $y <= $#y; ++$y,++$x) {
		    $x[$x] -= 1e5
			if ($car = (($x[$x] += $y[$y] + $car) > 1e5));
		}
	    }   
	}
	pop(@@x); unshift(@@q, $q);
d1740 35
a1774 9
    if (wantarray) {
	@@d = ();
	if ($dd != 1) {
	    $car = 0;
	    for $x (reverse @@x) {
		$prd = $car * 1e5 + $x;
		$car = $prd - ($tmp = int($prd / $dd)) * $dd;
		unshift(@@d, $tmp);
	    }
d1776 6
a1781 35
	else {
	    @@d = @@x;
	}
	(&external($sr, @@q), &external($srem, @@d, $zero));
    } else {
	&external($sr, @@q);
    }
}

# compute power of two numbers -- stolen from Knuth Vol 2 pg 233
sub bpow { #(num_str, num_str) return num_str
    local(*x, *y); ($x, $y) = (&bnorm($_[$[]), &bnorm($_[$[+1]));
    if ($x eq 'NaN') {
	'NaN';
    } elsif ($y eq 'NaN') {
	'NaN';
    } elsif ($x eq '+1') {
	'+1';
    } elsif ($x eq '-1') {
	&bmod($x,2) ? '-1': '+1';
    } elsif ($y =~ /^-/) {
	'NaN';
    } elsif ($x eq '+0' && $y eq '+0') {
	'NaN';
    } else {
	@@x = &internal($x);
	local(@@pow2)=@@x;
	local(@@pow)=&internal("+1");
	local($y1,$res,@@tmp1,@@tmp2)=(1); # need tmp to send to mul
	while ($y ne '+0') {
	  ($y,$res)=&bdiv($y,2);
	  if ($res ne '+0') {@@tmp=@@pow2; @@pow=&mul(*pow,*tmp);}
	  if ($y ne '+0') {@@tmp=@@pow2;@@pow2=&mul(*pow2,*tmp);}
	}
	&external(@@pow);
a1782 1
}
d1784 22
a1805 23
# compute x << y, y >= 0
sub blsft { #(num_str, num_str) return num_str
    &bmul($_[$[], &bpow(2, $_[$[+1]));
}

# compute x >> y, y >= 0
sub brsft { #(num_str, num_str) return num_str
    &bdiv($_[$[], &bpow(2, $_[$[+1]));
}

# compute x & y
sub band { #(num_str, num_str) return num_str
    local($x,$y,$r,$m,$xr,$yr) = (&bnorm($_[$[]),&bnorm($_[$[+1]),0,1);
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	while ($x ne '+0' && $y ne '+0') {
	    ($x, $xr) = &bdiv($x, 0x10000);
	    ($y, $yr) = &bdiv($y, 0x10000);
	    $r = &badd(&bmul(int $xr & $yr, $m), $r);
	    $m = &bmul($m, 0x10000);
	}
	$r;
d1807 5
a1811 1
}
d1813 12
a1824 13
# compute x | y
sub bior { #(num_str, num_str) return num_str
    local($x,$y,$r,$m,$xr,$yr) = (&bnorm($_[$[]),&bnorm($_[$[+1]),0,1);
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	while ($x ne '+0' || $y ne '+0') {
	    ($x, $xr) = &bdiv($x, 0x10000);
	    ($y, $yr) = &bdiv($y, 0x10000);
	    $r = &badd(&bmul(int $xr | $yr, $m), $r);
	    $m = &bmul($m, 0x10000);
	}
	$r;
a1825 1
}
d1827 31
a1857 13
# compute x ^ y
sub bxor { #(num_str, num_str) return num_str
    local($x,$y,$r,$m,$xr,$yr) = (&bnorm($_[$[]),&bnorm($_[$[+1]),0,1);
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	while ($x ne '+0' || $y ne '+0') {
	    ($x, $xr) = &bdiv($x, 0x10000);
	    ($y, $yr) = &bdiv($y, 0x10000);
	    $r = &badd(&bmul(int $xr ^ $yr, $m), $r);
	    $m = &bmul($m, 0x10000);
	}
	$r;
a1858 1
}
d1860 2
a1861 4
# represent ~x as twos-complement number
sub bnot { #(num_str) return num_str
    &bsub(-1,$_[$[]);
}
d1863 4
a1866 2
1;
__END__
d1868 11
a1878 1
=head1 NAME
d1880 32
a1911 1
Math::BigInt - Arbitrary size integer math package
d1913 2
a1914 1
=head1 SYNOPSIS
d1916 1
a1916 2
  use Math::BigInt;
  $i = Math::BigInt->new($string);
d1918 14
a1931 16
  $i->bneg return BINT               negation
  $i->babs return BINT               absolute value
  $i->bcmp(BINT) return CODE         compare numbers (undef,<0,=0,>0)
  $i->badd(BINT) return BINT         addition
  $i->bsub(BINT) return BINT         subtraction
  $i->bmul(BINT) return BINT         multiplication
  $i->bdiv(BINT) return (BINT,BINT)  division (quo,rem) just quo if scalar
  $i->bmod(BINT) return BINT         modulus
  $i->bgcd(BINT) return BINT         greatest common divisor
  $i->bnorm return BINT              normalization
  $i->blsft(BINT) return BINT        left shift
  $i->brsft(BINT) return (BINT,BINT) right shift (quo,rem) just quo if scalar
  $i->band(BINT) return BINT         bit-wise and
  $i->bior(BINT) return BINT         bit-wise inclusive or
  $i->bxor(BINT) return BINT         bit-wise exclusive or
  $i->bnot return BINT               bit-wise not
d1933 69
a2001 1
=head1 DESCRIPTION
d2003 78
a2080 2
All basic math operations are overloaded if you declare your big
integers as
d2082 51
a2132 1
  $i = new Math::BigInt '123 456 789 123 456 789';
d2134 52
d2187 15
a2201 1
=over 2
d2203 2
a2204 1
=item Canonical notation
d2206 8
a2213 2
Big integer value are strings of the form C</^[+-]\d+$/> with leading
zeros suppressed.
d2215 56
a2270 1
=item Input
d2272 42
a2313 2
Input values to these routines may be strings of the form
C</^\s*[+-]?[\d\s]+$/>.
d2315 7
a2321 1
=item Output
d2323 106
a2428 1
Output values always always in canonical form
d2430 102
a2531 1
=back
d2533 2
a2534 5
Actual math is done in an internal format consisting of an array
whose first element is the sign (/^[+-]$/) and whose remaining 
elements are base 100000 digits with the least significant digit first.
The string 'NaN' is used to represent the result when input arguments 
are not numbers, as well as the result of dividing by zero.
d2536 38
a2573 1
=head1 EXAMPLES
d2575 46
a2620 3
   '+0'                            canonical zero value
   '   -123 123 123'               canonical value '-123123123'
   '1 23 456 7890'                 canonical value '+1234567890'
d2622 36
d2659 2
a2660 1
=head1 Autocreating constants
d2662 26
a2687 3
After C<use Math::BigInt ':constant'> all the integer decimal constants
in the given scope are converted to C<Math::BigInt>.  This conversion
happens at compile time.
d2689 4
a2692 1
In particular
d2694 1
a2694 1
  perl -MMath::BigInt=:constant -e 'print 2**100'
d2696 1199
a3894 2
print the integer value of C<2**100>.  Note that without conversion of 
constants the expression 2**100 will be calculated as floating point number.
d3898 348
a4245 2
The current version of this module is a preliminary version of the
real thing that is currently (as of perl5.002) under development.
d4247 1
a4247 1
=head1 AUTHOR
d4249 2
a4250 1
Mark Biggar, overloaded interface by Ilya Zakharevich.
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d2 1
d55 5
d236 1
d239 5
d268 1
d270 4
d278 1
d280 4
d300 1
d302 4
@


1.3
log
@perl5.005_03 (stock)
@
text
@d7 2
a8 4
'<=>'	=>	sub {new Math::BigInt
		       $_[2]? bcmp($_[1],${$_[0]}) : bcmp(${$_[0]},$_[1])},
'cmp'	=>	sub {new Math::BigInt
		       $_[2]? ($_[1] cmp ${$_[0]}) : (${$_[0]} cmp $_[1])},
d19 8
d267 2
a268 1
    @@q = (); ($v2,$v1) = ($y[-2] || 0, $y[-1]);
d270 2
a271 1
	($u2,$u1,$u0) = ($x[-3] || 0, $x[-2] || 0, $x[-1]);
d339 63
d424 6
@


1.2
log
@perl 5.004_04
@
text
@d39 6
d85 2
a86 2
    vec($_,0,8) ^= ord('+') ^ ord('-') unless $_ eq '+0';
    s/^H/N/;
d109 1
a109 1
	&cmp($x,$y);
d180 1
a180 1
	$x -= 1e5 if $car = (($x += shift(@@y) + $car) >= 1e5) ? 1 : 0;
d194 2
a195 2
	last unless @@y || $bar;
	$sx += 1e5 if $bar = (($sx -= shift(@@sy) + $bar) < 0);
d261 1
a261 1
    @@q = (); ($v2,$v1) = @@y[-2,-1];
d263 1
a263 1
	($u2,$u1,$u0) = @@x[-3..-1];
d392 13
@


1.1
log
@Initial revision
@
text
@d109 17
a125 7
    $cx cmp $cy
    &&
    (
	ord($cy) <=> ord($cx)
	||
	($cx cmp ',') * (length($cy) <=> length($cx) || $cy cmp $cx)
    );
d174 1
a174 1
	$x -= 1e5 if $car = (($x += shift(@@y) + $car) >= 1e5);
d178 1
a178 1
	$y -= 1e5 if $car = (($y += $car) >= 1e5);
d217 1
a217 1
	$prod = $x * $y + $prod[$cty] + $car;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a38 6
sub import {
  shift;
  return unless @@_;
  die "unknown import: @@_" unless @@_ == 1 and $_[0] eq ':constant';
  overload::constant integer => sub {Math::BigInt->new(shift)};
}
d79 2
a80 2
    return $_ if $_ eq '+0' or $_ eq 'NaN';
    vec($_,0,8) ^= ord('+') ^ ord('-');
d103 1
a103 1
	&cmp($x,$y) <=> 0;
d109 7
a115 17
    
    return 0 if ($cx eq $cy);

    local($sx, $sy) = (substr($cx, 0, 1), substr($cy, 0, 1));
    local($ld);

    if ($sx eq '+') {
      return  1 if ($sy eq '-' || $cy eq '+0');
      $ld = length($cx) - length($cy);
      return $ld if ($ld);
      return $cx cmp $cy;
    } else { # $sx eq '-'
      return -1 if ($sy eq '+');
      $ld = length($cy) - length($cx);
      return $ld if ($ld);
      return $cy cmp $cx;
    }
d164 1
a164 1
	$x -= 1e5 if $car = (($x += (@@y ? shift(@@y) : 0) + $car) >= 1e5) ? 1 : 0;
d168 1
a168 1
	$y -= 1e5 if $car = (($y += $car) >= 1e5) ? 1 : 0;
d178 2
a179 2
	last unless @@sy || $bar;
	$sx += 1e5 if $bar = (($sx -= (@@sy ? shift(@@sy) : 0) + $bar) < 0);
d207 1
a207 1
	$prod = $x * $y + ($prod[$cty] || 0) + $car;
d245 1
a245 1
    @@q = (); ($v2,$v1) = ($y[-2] || 0, $y[-1]);
d247 1
a247 1
	($u2,$u1,$u0) = ($x[-3] || 0, $x[-2] || 0, $x[-1]);
a375 13

=head1 Autocreating constants

After C<use Math::BigInt ':constant'> all the integer decimal constants
in the given scope are converted to C<Math::BigInt>.  This conversion
happens at compile time.

In particular

  perl -MMath::BigInt=:constant -e 'print 2**100'

print the integer value of C<2**100>.  Note that without conversion of 
constants the expression 2**100 will be calculated as floating point number.
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d7 4
a10 2
'<=>'	=>	sub {$_[2]? bcmp($_[1],${$_[0]}) : bcmp(${$_[0]},$_[1])},
'cmp'	=>	sub {$_[2]? ($_[1] cmp ${$_[0]}) : (${$_[0]} cmp $_[1])},
a20 8
'<<'	=>	sub {new Math::BigInt
		       $_[2]? blsft($_[1],${$_[0]}) : blsft(${$_[0]},$_[1])},
'>>'	=>	sub {new Math::BigInt
		       $_[2]? brsft($_[1],${$_[0]}) : brsft(${$_[0]},$_[1])},
'&'	=>	sub {new Math::BigInt &band},
'|'	=>	sub {new Math::BigInt &bior},
'^'	=>	sub {new Math::BigInt &bxor},
'~'	=>	sub {new Math::BigInt &bnot},
d261 1
a261 2
    @@q = (); ($v2,$v1) = @@y[-2,-1];
    $v2 = 0 unless $v2;
d263 1
a263 2
	($u2,$u1,$u0) = @@x[-3..-1];
	$u2 = 0 unless $u2;
a330 63
# compute x << y, y >= 0
sub blsft { #(num_str, num_str) return num_str
    &bmul($_[$[], &bpow(2, $_[$[+1]));
}

# compute x >> y, y >= 0
sub brsft { #(num_str, num_str) return num_str
    &bdiv($_[$[], &bpow(2, $_[$[+1]));
}

# compute x & y
sub band { #(num_str, num_str) return num_str
    local($x,$y,$r,$m,$xr,$yr) = (&bnorm($_[$[]),&bnorm($_[$[+1]),0,1);
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	while ($x ne '+0' && $y ne '+0') {
	    ($x, $xr) = &bdiv($x, 0x10000);
	    ($y, $yr) = &bdiv($y, 0x10000);
	    $r = &badd(&bmul(int $xr & $yr, $m), $r);
	    $m = &bmul($m, 0x10000);
	}
	$r;
    }
}

# compute x | y
sub bior { #(num_str, num_str) return num_str
    local($x,$y,$r,$m,$xr,$yr) = (&bnorm($_[$[]),&bnorm($_[$[+1]),0,1);
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	while ($x ne '+0' || $y ne '+0') {
	    ($x, $xr) = &bdiv($x, 0x10000);
	    ($y, $yr) = &bdiv($y, 0x10000);
	    $r = &badd(&bmul(int $xr | $yr, $m), $r);
	    $m = &bmul($m, 0x10000);
	}
	$r;
    }
}

# compute x ^ y
sub bxor { #(num_str, num_str) return num_str
    local($x,$y,$r,$m,$xr,$yr) = (&bnorm($_[$[]),&bnorm($_[$[+1]),0,1);
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	while ($x ne '+0' || $y ne '+0') {
	    ($x, $xr) = &bdiv($x, 0x10000);
	    ($y, $yr) = &bdiv($y, 0x10000);
	    $r = &badd(&bmul(int $xr ^ $yr, $m), $r);
	    $m = &bmul($m, 0x10000);
	}
	$r;
    }
}

# represent ~x as twos-complement number
sub bnot { #(num_str) return num_str
    &bsub(-1,$_[$[]);
}

a352 6
  $i->blsft(BINT) return BINT        left shift
  $i->brsft(BINT) return (BINT,BINT) right shift (quo,rem) just quo if scalar
  $i->band(BINT) return BINT         bit-wise and
  $i->bior(BINT) return BINT         bit-wise inclusive or
  $i->bxor(BINT) return BINT         bit-wise exclusive or
  $i->bnot return BINT               bit-wise not
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a1 1
$VERSION='0.01';
a53 5
# overcome a floating point problem on certain osnames (posix-bc, os390)
BEGIN {
    my $x = 100000.0;
    my $use_mult = int($x*1e-5)*1e5 == $x ? 1 : 0;
}
a229 1
        if ($use_mult) {
a231 5
        }
        else {
	$prod[$cty++] =
	  $prod - ($car = int($prod / 1e5)) * 1e5;
        }
a255 1
            if ($use_mult) {
a256 4
            }
            else {
	    $x -= ($car = int($x / 1e5)) * 1e5;
            }
a260 1
            if ($use_mult) {
a261 4
            }
            else {
	    $y -= ($car = int($y / 1e5)) * 1e5;
            }
a277 1
                if ($use_mult) {
a278 4
                }
                else {
		$prd -= ($car = int($prd / 1e5)) * 1e5;
                }
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d2 1
a2 39

#
# "Mike had an infinite amount to do and a negative amount of time in which
# to do it." - Before and After
#

# The following hash values are used:
#   value: unsigned int with actual value (as a Math::BigInt::Calc or similiar)
#   sign : +,-,NaN,+inf,-inf
#   _a   : accuracy
#   _p   : precision
#   _f   : flags, used by MBF to flag parts of a float as untouchable

# Remember not to take shortcuts ala $xs = $x->{value}; $CALC->foo($xs); since
# underlying lib might change the reference!

my $class = "Math::BigInt";
require 5.005;

# This is a patched v1.60, containing a fix for the "1234567890\n" bug
$VERSION = '1.60';
use Exporter;
@@ISA =       qw( Exporter );
@@EXPORT_OK = qw( objectify _swap bgcd blcm); 
use vars qw/$round_mode $accuracy $precision $div_scale $rnd_mode/;
use vars qw/$upgrade $downgrade/;
use strict;

# Inside overload, the first arg is always an object. If the original code had
# it reversed (like $x = 2 * $y), then the third paramater indicates this
# swapping. To make it work, we use a helper routine which not only reswaps the
# params, but also makes a new object in this case. See _swap() for details,
# especially the cases of operators with different classes.

# For overloaded ops with only one argument we simple use $_[0]->copy() to
# preserve the argument.

# Thus inheritance of overload operators becomes possible and transparent for
# our subclasses without the need to repeat the entire overload section there.
d5 27
a31 70
'='     =>      sub { $_[0]->copy(); },

# '+' and '-' do not use _swap, since it is a triffle slower. If you want to
# override _swap (if ever), then override overload of '+' and '-', too!
# for sub it is a bit tricky to keep b: b-a => -a+b
'-'	=>	sub { my $c = $_[0]->copy; $_[2] ?
                   $c->bneg()->badd($_[1]) :
                   $c->bsub( $_[1]) },
'+'	=>	sub { $_[0]->copy()->badd($_[1]); },

# some shortcuts for speed (assumes that reversed order of arguments is routed
# to normal '+' and we thus can always modify first arg. If this is changed,
# this breaks and must be adjusted.)
'+='	=>	sub { $_[0]->badd($_[1]); },
'-='	=>	sub { $_[0]->bsub($_[1]); },
'*='	=>	sub { $_[0]->bmul($_[1]); },
'/='	=>	sub { scalar $_[0]->bdiv($_[1]); },
'%='	=>	sub { $_[0]->bmod($_[1]); },
'^='	=>	sub { $_[0]->bxor($_[1]); },
'&='	=>	sub { $_[0]->band($_[1]); },
'|='	=>	sub { $_[0]->bior($_[1]); },
'**='	=>	sub { $_[0]->bpow($_[1]); },

# not supported by Perl yet
'..'	=>	\&_pointpoint,

'<=>'	=>	sub { $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
                      $_[0]->bcmp($_[1])},
'cmp'	=>	sub {
         $_[2] ? 
               "$_[1]" cmp $_[0]->bstr() :
               $_[0]->bstr() cmp "$_[1]" },

'log'	=>	sub { $_[0]->copy()->blog(); }, 
'int'	=>	sub { $_[0]->copy(); }, 
'neg'	=>	sub { $_[0]->copy()->bneg(); }, 
'abs'	=>	sub { $_[0]->copy()->babs(); },
'sqrt'  =>	sub { $_[0]->copy()->bsqrt(); },
'~'	=>	sub { $_[0]->copy()->bnot(); },

'*'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bmul($a[1]); },
'/'	=>	sub { my @@a = ref($_[0])->_swap(@@_);scalar $a[0]->bdiv($a[1]);},
'%'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bmod($a[1]); },
'**'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bpow($a[1]); },
'<<'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->blsft($a[1]); },
'>>'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->brsft($a[1]); },

'&'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->band($a[1]); },
'|'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bior($a[1]); },
'^'	=>	sub { my @@a = ref($_[0])->_swap(@@_); $a[0]->bxor($a[1]); },

# can modify arg of ++ and --, so avoid a new-copy for speed, but don't
# use $_[0]->__one(), it modifies $_[0] to be 1!
'++'	=>	sub { $_[0]->binc() },
'--'	=>	sub { $_[0]->bdec() },

# if overloaded, O(1) instead of O(N) and twice as fast for small numbers
'bool'  =>	sub {
  # this kludge is needed for perl prior 5.6.0 since returning 0 here fails :-/
  # v5.6.1 dumps on that: return !$_[0]->is_zero() || undef;		    :-(
  my $t = !$_[0]->is_zero();
  undef $t if $t == 0;
  $t;
  },

# the original qw() does not work with the TIESCALAR below, why?
# Order of arguments unsignificant
'""' => sub { $_[0]->bstr(); },
'0+' => sub { $_[0]->numify(); }
d34 1
a34 2
##############################################################################
# global constants, flags and accessory
d36 86
a121 40
use constant MB_NEVER_ROUND => 0x0001;

my $NaNOK=1; 				# are NaNs ok?
my $nan = 'NaN'; 			# constants for easier life

my $CALC = 'Math::BigInt::Calc';	# module to do low level math
my $IMPORT = 0;				# did import() yet?

$round_mode = 'even'; # one of 'even', 'odd', '+inf', '-inf', 'zero' or 'trunc'
$accuracy   = undef;
$precision  = undef;
$div_scale  = 40;

$upgrade = undef;			# default is no upgrade
$downgrade = undef;			# default is no downgrade

##############################################################################
# the old code had $rnd_mode, so we need to support it, too

$rnd_mode   = 'even';
sub TIESCALAR  { my ($class) = @@_; bless \$round_mode, $class; }
sub FETCH      { return $round_mode; }
sub STORE      { $rnd_mode = $_[0]->round_mode($_[1]); }

BEGIN { tie $rnd_mode, 'Math::BigInt'; }

############################################################################## 

sub round_mode
  {
  no strict 'refs';
  # make Class->round_mode() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    my $m = shift;
    die "Unknown round mode $m"
     if $m !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/;
    return ${"${class}::round_mode"} = $m;
d123 1
a123 2
  return ${"${class}::round_mode"};
  }
d125 4
a128 75
sub upgrade
  {
  no strict 'refs';
  # make Class->upgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@@_ > 0)
    {
    my $u = shift;
    return ${"${class}::upgrade"} = $u;
    }
  return ${"${class}::upgrade"};
  }

sub downgrade
  {
  no strict 'refs';
  # make Class->downgrade() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  # need to set new value?
  if (@@_ > 0)
    {
    my $u = shift;
    return ${"${class}::downgrade"} = $u;
    }
  return ${"${class}::downgrade"};
  }

sub div_scale
  {
  no strict 'refs';
  # make Class->round_mode() work
  my $self = shift;
  my $class = ref($self) || $self || __PACKAGE__;
  if (defined $_[0])
    {
    die ('div_scale must be greater than zero') if $_[0] < 0;
    ${"${class}::div_scale"} = shift;
    }
  return ${"${class}::div_scale"};
  }

sub accuracy
  {
  # $x->accuracy($a);		ref($x)	$a
  # $x->accuracy();		ref($x)
  # Class->accuracy();		class
  # Class->accuracy($a);	class $a

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  # need to set new value?
  if (@@_ > 0)
    {
    my $a = shift;
    die ('accuracy must not be zero') if defined $a && $a == 0;
    if (ref($x))
      {
      # $object->accuracy() or fallback to global
      $x->bround($a) if defined $a;
      $x->{_a} = $a;			# set/overwrite, even if not rounded
      $x->{_p} = undef;			# clear P
      }
    else
      {
      # set global
      ${"${class}::accuracy"} = $a;
      ${"${class}::precision"} = undef;	# clear P
      }
    return $a;				# shortcut
    }
d130 2
a131 106
  my $r;
  # $object->accuracy() or fallback to global
  $r = $x->{_a} if ref($x);
  # but don't return global undef, when $x's accuracy is 0!
  $r = ${"${class}::accuracy"} if !defined $r;
  $r;
  } 

sub precision
  {
  # $x->precision($p);		ref($x)	$p
  # $x->precision();		ref($x)
  # Class->precision();		class
  # Class->precision($p);	class $p

  my $x = shift;
  my $class = ref($x) || $x || __PACKAGE__;

  no strict 'refs';
  # need to set new value?
  if (@@_ > 0)
    {
    my $p = shift;
    if (ref($x))
      {
      # $object->precision() or fallback to global
      $x->bfround($p) if defined $p;
      $x->{_p} = $p;			# set/overwrite, even if not rounded
      $x->{_a} = undef;			# clear A
      }
    else
      {
      # set global
      ${"${class}::precision"} = $p;
      ${"${class}::accuracy"} = undef;	# clear A
      }
    return $p;				# shortcut
    }

  my $r;
  # $object->precision() or fallback to global
  $r = $x->{_p} if ref($x);
  # but don't return global undef, when $x's precision is 0!
  $r = ${"${class}::precision"} if !defined $r;
  $r;
  } 

sub config
  {
  # return (later set?) configuration data as hash ref
  my $class = shift || 'Math::BigInt';

  no strict 'refs';
  my $lib = $CALC;
  my $cfg = {
    lib => $lib,
    lib_version => ${"${lib}::VERSION"},
    class => $class,
    };
  foreach (
   qw/upgrade downgrade precision accuracy round_mode VERSION div_scale/)
    {
    $cfg->{lc($_)} = ${"${class}::$_"};
    };
  $cfg;
  }

sub _scale_a
  { 
  # select accuracy parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$s,$m,$scale,$mode) = @@_;
  $scale = $x->{_a} if !defined $scale;
  $scale = $s if (!defined $scale);
  $mode = $m if !defined $mode;
  return ($scale,$mode);
  }

sub _scale_p
  { 
  # select precision parameter based on precedence,
  # used by bround() and bfround(), may return undef for scale (means no op)
  my ($x,$s,$m,$scale,$mode) = @@_;
  $scale = $x->{_p} if !defined $scale;
  $scale = $s if (!defined $scale);
  $mode = $m if !defined $mode;
  return ($scale,$mode);
  }

##############################################################################
# constructors

sub copy
  {
  my ($c,$x);
  if (@@_ > 1)
    {
    # if two arguments, the first one is the class to "swallow" subclasses
    ($c,$x) = @@_;
    }
  else
    {
    $x = shift;
    $c = ref($x);
    }
  return unless ref($x); # only for objects
d133 32
a164 38
  my $self = {}; bless $self,$c;
  my $r;
  foreach my $k (keys %$x)
    {
    if ($k eq 'value')
      {
      $self->{value} = $CALC->_copy($x->{value}); next;
      }
    if (!($r = ref($x->{$k})))
      {
      $self->{$k} = $x->{$k}; next;
      }
    if ($r eq 'SCALAR')
      {
      $self->{$k} = \${$x->{$k}};
      }
    elsif ($r eq 'ARRAY')
      {
      $self->{$k} = [ @@{$x->{$k}} ];
      }
    elsif ($r eq 'HASH')
      {
      # only one level deep!
      foreach my $h (keys %{$x->{$k}})
        {
        $self->{$k}->{$h} = $x->{$k}->{$h};
        }
      }
    else # normal ref
      {
      my $xk = $x->{$k};
      if ($xk->can('copy'))
        {
	$self->{$k} = $xk->copy();
        }
      else
	{
	$self->{$k} = $xk->new($xk);
a165 45
      }
    }
  $self;
  }

sub new 
  {
  # create a new BigInt object from a string or another BigInt object. 
  # see hash keys documented at top

  # the argument could be an object, so avoid ||, && etc on it, this would
  # cause costly overloaded code to be called. The only allowed ops are
  # ref() and defined.

  my ($class,$wanted,$a,$p,$r) = @@_;
 
  # avoid numify-calls by not using || on $wanted!
  return $class->bzero($a,$p) if !defined $wanted;	# default to 0
  return $class->copy($wanted,$a,$p,$r)
   if ref($wanted) && $wanted->isa($class);		# MBI or subclass

  $class->import() if $IMPORT == 0;		# make require work
  
  my $self = bless {}, $class;

  # shortcut for "normal" numbers
  if ((!ref $wanted) && ($wanted =~ /^([+-]?)[1-9][0-9]*\z/))
    {
    $self->{sign} = $1 || '+';
    my $ref = \$wanted;
    if ($wanted =~ /^[+-]/)
     {
      # remove sign without touching wanted
      my $t = $wanted; $t =~ s/^[+-]//; $ref = \$t;
      }
    $self->{value} = $CALC->_new($ref);
    no strict 'refs';
    if ( (defined $a) || (defined $p) 
        || (defined ${"${class}::precision"})
        || (defined ${"${class}::accuracy"}) 
       )
      {
      $self->round($a,$p,$r) unless (@@_ == 4 && !defined $a && !defined $p);
      }
    return $self;
d167 1
d169 70
a238 63
  # handle '+inf', '-inf' first
  if ($wanted =~ /^[+-]?inf$/)
    {
    $self->{value} = $CALC->_zero();
    $self->{sign} = $wanted; $self->{sign} = '+inf' if $self->{sign} eq 'inf';
    return $self;
    }
  # split str in m mantissa, e exponent, i integer, f fraction, v value, s sign
  my ($mis,$miv,$mfv,$es,$ev) = _split(\$wanted);
  if (!ref $mis)
    {
    die "$wanted is not a number initialized to $class" if !$NaNOK;
    #print "NaN 1\n";
    $self->{value} = $CALC->_zero();
    $self->{sign} = $nan;
    return $self;
    }
  if (!ref $miv)
    {
    # _from_hex or _from_bin
    $self->{value} = $mis->{value};
    $self->{sign} = $mis->{sign};
    return $self;	# throw away $mis
    }
  # make integer from mantissa by adjusting exp, then convert to bigint
  $self->{sign} = $$mis;			# store sign
  $self->{value} = $CALC->_zero();		# for all the NaN cases
  my $e = int("$$es$$ev");			# exponent (avoid recursion)
  if ($e > 0)
    {
    my $diff = $e - CORE::length($$mfv);
    if ($diff < 0)				# Not integer
      {
      #print "NOI 1\n";
      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
      $self->{sign} = $nan;
      }
    else					# diff >= 0
      {
      # adjust fraction and add it to value
      # print "diff > 0 $$miv\n";
      $$miv = $$miv . ($$mfv . '0' x $diff);
      }
    }
  else
    {
    if ($$mfv ne '')				# e <= 0
      {
      # fraction and negative/zero E => NOI
      #print "NOI 2 \$\$mfv '$$mfv'\n";
      return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
      $self->{sign} = $nan;
      }
    elsif ($e < 0)
      {
      # xE-y, and empty mfv
      #print "xE-y\n";
      $e = abs($e);
      if ($$miv !~ s/0{$e}$//)		# can strip so many zero's?
        {
        #print "NOI 3\n";
        return $upgrade->new($wanted,$a,$p,$r) if defined $upgrade;
        $self->{sign} = $nan;
d240 3
a242 969
      }
    }
  $self->{sign} = '+' if $$miv eq '0';			# normalize -0 => +0
  $self->{value} = $CALC->_new($miv) if $self->{sign} =~ /^[+-]$/;
  # if any of the globals is set, use them to round and store them inside $self
  # do not round for new($x,undef,undef) since that is used by MBF to signal
  # no rounding
  $self->round($a,$p,$r) unless @@_ == 4 && !defined $a && !defined $p;
  $self;
  }

sub bnan
  {
  # create a bigint 'NaN', if given a BigInt, set it to 'NaN'
  my $self = shift;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('bnan');
  my $c = ref($self);
  if ($self->can('_bnan'))
    {
    # use subclass to initialize
    $self->_bnan();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = $nan;
  delete $self->{_a}; delete $self->{_p};	# rounding NaN is silly
  return $self;
  }

sub binf
  {
  # create a bigint '+-inf', if given a BigInt, set it to '+-inf'
  # the sign is either '+', or if given, used from there
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign !~ /^-(inf)?$/;
  $self = $class if !defined $self;
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('binf');
  my $c = ref($self);
  if ($self->can('_binf'))
    {
    # use subclass to initialize
    $self->_binf();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $sign = $sign . 'inf' if $sign !~ /inf$/;	# - => -inf
  $self->{sign} = $sign;
  ($self->{_a},$self->{_p}) = @@_;		# take over requested rounding
  return $self;
  }

sub bzero
  {
  # create a bigint '+0', if given a BigInt, set it to 0
  my $self = shift;
  $self = $class if !defined $self;
 
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('bzero');

  if ($self->can('_bzero'))
    {
    # use subclass to initialize
    $self->_bzero();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_zero();
    }
  $self->{sign} = '+';
  if (@@_ > 0)
    {
    if (@@_ > 3)
      {
      # call like: $x->bzero($a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@@_);
      }
    else
      {
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

sub bone
  {
  # create a bigint '+1' (or -1 if given sign '-'),
  # if given a BigInt, set it to +1 or -1, respecively
  my $self = shift;
  my $sign = shift; $sign = '+' if !defined $sign || $sign ne '-';
  $self = $class if !defined $self;
 
  if (!ref($self))
    {
    my $c = $self; $self = {}; bless $self, $c;
    }
  $self->import() if $IMPORT == 0;		# make require work
  return if $self->modify('bone');

  if ($self->can('_bone'))
    {
    # use subclass to initialize
    $self->_bone();
    }
  else
    {
    # otherwise do our own thing
    $self->{value} = $CALC->_one();
    }
  $self->{sign} = $sign;
  if (@@_ > 0)
    {
    if (@@_ > 3)
      {
      # call like: $x->bone($sign,$a,$p,$r,$y);
      ($self,$self->{_a},$self->{_p}) = $self->_find_round_parameters(@@_);
      }
    else
      {
      $self->{_a} = $_[0]
       if ( (!defined $self->{_a}) || (defined $_[0] && $_[0] > $self->{_a}));
      $self->{_p} = $_[1]
       if ( (!defined $self->{_p}) || (defined $_[1] && $_[1] > $self->{_p}));
      }
    }
  $self;
  }

##############################################################################
# string conversation

sub bsstr
  {
  # (ref to BFLOAT or num_str ) return num_str
  # Convert number from internal format to scientific string format.
  # internal format is always normalized (no leading zeros, "-0E0" => "+0E0")
  my $x = shift; $class = ref($x) || $x; $x = $class->new(shift) if !ref($x); 
  # my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_); 

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';	# -inf, NaN
    return 'inf';					# +inf
    }
  my ($m,$e) = $x->parts();
  # e can only be positive
  my $sign = 'e+';	
  # MBF: my $s = $e->{sign}; $s = '' if $s eq '-'; my $sep = 'e'.$s;
  return $m->bstr().$sign.$e->bstr();
  }

sub bstr 
  {
  # make a string from bigint object
  my $x = shift; $class = ref($x) || $x; $x = $class->new(shift) if !ref($x); 
  # my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_); 

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $x->{sign} unless $x->{sign} eq '+inf';	# -inf, NaN
    return 'inf';					# +inf
    }
  my $es = ''; $es = $x->{sign} if $x->{sign} eq '-';
  return $es.${$CALC->_str($x->{value})};
  }

sub numify 
  {
  # Make a "normal" scalar from a BigInt object
  my $x = shift; $x = $class->new($x) unless ref $x;
  return $x->{sign} if $x->{sign} !~ /^[+-]$/;
  my $num = $CALC->_num($x->{value});
  return -$num if $x->{sign} eq '-';
  $num;
  }

##############################################################################
# public stuff (usually prefixed with "b")

sub sign
  {
  # return the sign of the number: +/-/-inf/+inf/NaN
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_); 
  
  $x->{sign};
  }

sub _find_round_parameters
  {
  # After any operation or when calling round(), the result is rounded by
  # regarding the A & P from arguments, local parameters, or globals.

  # This procedure finds the round parameters, but it is for speed reasons
  # duplicated in round. Otherwise, it is tested by the testsuite and used
  # by fdiv().
  
  my ($self,$a,$p,$r,@@args) = @@_;
  # $a accuracy, if given by caller
  # $p precision, if given by caller
  # $r round_mode, if given by caller
  # @@args all 'other' arguments (0 for unary, 1 for binary ops)

  # leave bigfloat parts alone
  return ($self) if exists $self->{_f} && $self->{_f} & MB_NEVER_ROUND != 0;

  my $c = ref($self);				# find out class of argument(s)
  no strict 'refs';

  # now pick $a or $p, but only if we have got "arguments"
  if (!defined $a)
    {
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is smaller
      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
      }
    }
  if (!defined $p)
    {
    # even if $a is defined, take $p, to signal error for both defined
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is bigger
      # -2 > -3, and 3 > 2
      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
      }
    }
  # if still none defined, use globals (#2)
  $a = ${"$c\::accuracy"} unless defined $a;
  $p = ${"$c\::precision"} unless defined $p;
 
  # no rounding today? 
  return ($self) unless defined $a || defined $p;		# early out

  # set A and set P is an fatal error
  return ($self->bnan()) if defined $a && defined $p;

  $r = ${"$c\::round_mode"} unless defined $r;
  die "Unknown round mode '$r'" if $r !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/;
 
  return ($self,$a,$p,$r);
  }

sub round
  {
  # Round $self according to given parameters, or given second argument's
  # parameters or global defaults 

  # for speed reasons, _find_round_parameters is embeded here:

  my ($self,$a,$p,$r,@@args) = @@_;
  # $a accuracy, if given by caller
  # $p precision, if given by caller
  # $r round_mode, if given by caller
  # @@args all 'other' arguments (0 for unary, 1 for binary ops)

  # leave bigfloat parts alone
  return ($self) if exists $self->{_f} && $self->{_f} & MB_NEVER_ROUND != 0;

  my $c = ref($self);				# find out class of argument(s)
  no strict 'refs';

  # now pick $a or $p, but only if we have got "arguments"
  if (!defined $a)
    {
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is smaller
      $a = $_->{_a} if (defined $_->{_a}) && (!defined $a || $_->{_a} < $a);
      }
    }
  if (!defined $p)
    {
    # even if $a is defined, take $p, to signal error for both defined
    foreach ($self,@@args)
      {
      # take the defined one, or if both defined, the one that is bigger
      # -2 > -3, and 3 > 2
      $p = $_->{_p} if (defined $_->{_p}) && (!defined $p || $_->{_p} > $p);
      }
    }
  # if still none defined, use globals (#2)
  $a = ${"$c\::accuracy"} unless defined $a;
  $p = ${"$c\::precision"} unless defined $p;
 
  # no rounding today? 
  return $self unless defined $a || defined $p;		# early out

  # set A and set P is an fatal error
  return $self->bnan() if defined $a && defined $p;

  $r = ${"$c\::round_mode"} unless defined $r;
  die "Unknown round mode '$r'" if $r !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/;

  # now round, by calling either fround or ffround:
  if (defined $a)
    {
    $self->bround($a,$r) if !defined $self->{_a} || $self->{_a} >= $a;
    }
  else # both can't be undefined due to early out
    {
    $self->bfround($p,$r) if !defined $self->{_p} || $self->{_p} <= $p;
    }
  $self->bnorm();			# after round, normalize
  }

sub bnorm
  { 
  # (numstr or BINT) return BINT
  # Normalize number -- no-op here
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
  $x;
  }

sub babs 
  {
  # (BINT or num_str) return BINT
  # make number absolute, or return absolute BINT from string
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return $x if $x->modify('babs');
  # post-normalized abs for internal use (does nothing for NaN)
  $x->{sign} =~ s/^-/+/;
  $x;
  }

sub bneg 
  { 
  # (BINT or num_str) return BINT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
  
  return $x if $x->modify('bneg');

  # for +0 dont negate (to have always normalized)
  $x->{sign} =~ tr/+-/-+/ if !$x->is_zero();	# does nothing for NaN
  $x;
  }

sub bcmp 
  {
  # Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT or num_str, BINT or num_str) return cond_code
  
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@@_);
    }

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;
    return +1 if $x->{sign} eq '+inf';
    return -1 if $x->{sign} eq '-inf';
    return -1 if $y->{sign} eq '+inf';
    return +1;
    }
  # check sign for speed first
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';	# does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0 

  # have same sign, so compare absolute values. Don't make tests for zero here
  # because it's actually slower than testin in Calc (especially w/ Pari et al)

  # post-normalized compare for internal use (honors signs)
  if ($x->{sign} eq '+') 
    {
    # $x and $y both > 0
    return $CALC->_acmp($x->{value},$y->{value});
    }

  # $x && $y both < 0
  $CALC->_acmp($y->{value},$x->{value});	# swaped (lib returns 0,1,-1)
  }

sub bacmp 
  {
  # Compares 2 values, ignoring their signs. 
  # Returns one of undef, <0, =0, >0. (suitable for sort)
  # (BINT, BINT) return cond_code
  
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@@_);
    }

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} =~ /^[+-]inf$/;
    return +1;	# inf is always bigger
    }
  $CALC->_acmp($x->{value},$y->{value});	# lib does only 0,1,-1
  }

sub badd 
  {
  # add second arg (BINT or string) to first (BINT) (modifies first)
  # return result as BINT

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('badd');
  return $upgrade->badd($x,$y,@@r) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

  $r[3] = $y;				# no push!
  # inf and NaN handling
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # NaN first
    return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    # inf handling
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +inf++inf or -inf+-inf => same, rest is NaN
      return $x if $x->{sign} eq $y->{sign};
      return $x->bnan();
      }
    # +-inf + something => +inf
    # something +-inf => +-inf
    $x->{sign} = $y->{sign}, return $x if $y->{sign} =~ /^[+-]inf$/;
    return $x;
    }
    
  my ($sx, $sy) = ( $x->{sign}, $y->{sign} ); # get signs

  if ($sx eq $sy)  
    {
    $x->{value} = $CALC->_add($x->{value},$y->{value});	# same sign, abs add
    $x->{sign} = $sx;
    }
  else 
    {
    my $a = $CALC->_acmp ($y->{value},$x->{value});	# absolute compare
    if ($a > 0)                           
      {
      #print "swapped sub (a=$a)\n";
      $x->{value} = $CALC->_sub($y->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sy;
      } 
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      #print "equal sub, result = 0\n";
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      #print "unswapped sub (a=$a)\n";
      $x->{value} = $CALC->_sub($x->{value}, $y->{value}); # abs sub
      $x->{sign} = $sx;
      }
    }
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
  }

sub bsub 
  {
  # (BINT or num_str, BINT or num_str) return num_str
  # subtract second arg from first, modify first
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bsub');

# upgrade done by badd():
#  return $upgrade->badd($x,$y,@@r) if defined $upgrade &&
#   ((!$x->isa($self)) || (!$y->isa($self)));

  if ($y->is_zero())
    { 
    $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }

  $y->{sign} =~ tr/+\-/-+/; 	# does nothing for NaN
  $x->badd($y,@@r); 		# badd does not leave internal zeros
  $y->{sign} =~ tr/+\-/-+/; 	# refix $y (does nothing for NaN)
  $x;				# already rounded by badd() or no round necc.
  }

sub binc
  {
  # increment arg by one
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  return $x if $x->modify('binc');

  if ($x->{sign} eq '+')
    {
    $x->{value} = $CALC->_inc($x->{value});
    $x->round($a,$p,$r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }
  elsif ($x->{sign} eq '-')
    {
    $x->{value} = $CALC->_dec($x->{value});
    $x->{sign} = '+' if $CALC->_is_zero($x->{value}); # -1 +1 => -0 => +0
    $x->round($a,$p,$r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }
  # inf, nan handling etc
  $x->badd($self->__one(),$a,$p,$r);		# badd does round
  }

sub bdec
  {
  # decrement arg by one
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  return $x if $x->modify('bdec');
  
  my $zero = $CALC->_is_zero($x->{value}) && $x->{sign} eq '+';
  # <= 0
  if (($x->{sign} eq '-') || $zero) 
    {
    $x->{value} = $CALC->_inc($x->{value});
    $x->{sign} = '-' if $zero;			# 0 => 1 => -1
    $x->{sign} = '+' if $CALC->_is_zero($x->{value}); # -1 +1 => -0 => +0
    $x->round($a,$p,$r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }
  # > 0
  elsif ($x->{sign} eq '+')
    {
    $x->{value} = $CALC->_dec($x->{value});
    $x->round($a,$p,$r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }
  # inf, nan handling etc
  $x->badd($self->__one('-'),$a,$p,$r);			# badd does round
  } 

sub blog
  {
  # not implemented yet
  my ($self,$x,$base,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
 
  return $upgrade->blog($x,$base,$a,$p,$r) if defined $upgrade;

  return $x->bnan();
  }
 
sub blcm 
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # Lowest Common Multiplicator

  my $y = shift; my ($x);
  if (ref($y))
    {
    $x = $y->copy();
    }
  else
    {
    $x = $class->new($y);
    }
  while (@@_) { $x = __lcm($x,shift); } 
  $x;
  }

sub bgcd 
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does not modify arguments, but returns new object
  # GCD -- Euclids algorithm, variant C (Knuth Vol 3, pg 341 ff)

  my $y = shift;
  $y = __PACKAGE__->new($y) if !ref($y);
  my $self = ref($y);
  my $x = $y->copy();		# keep arguments
  if ($CALC->can('_gcd'))
    {
    while (@@_)
      {
      $y = shift; $y = $self->new($y) if !ref($y);
      next if $y->is_zero();
      return $x->bnan() if $y->{sign} !~ /^[+-]$/;	# y NaN?
      $x->{value} = $CALC->_gcd($x->{value},$y->{value}); last if $x->is_one();
      }
    }
  else
    {
    while (@@_)
      {
      $y = shift; $y = $self->new($y) if !ref($y);
      $x = __gcd($x,$y->copy()); last if $x->is_one();	# _gcd handles NaN
      } 
    }
  $x->babs();
  }

sub bnot 
  {
  # (num_str or BINT) return BINT
  # represent ~x as twos-complement number
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
 
  return $x if $x->modify('bnot');
  $x->bneg()->bdec();			# bdec already does round
  }

# is_foo test routines

sub is_zero
  {
  # return true if arg (BINT or num_str) is zero (array '+', '0')
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  
  return 0 if $x->{sign} !~ /^\+$/;			# -, NaN & +-inf aren't
  $CALC->_is_zero($x->{value});
  }

sub is_nan
  {
  # return true if arg (BINT or num_str) is NaN
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return 1 if $x->{sign} eq $nan;
  0;
  }

sub is_inf
  {
  # return true if arg (BINT or num_str) is +-inf
  my ($self,$x,$sign) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);

  $sign = '' if !defined $sign;
  return 1 if $sign eq $x->{sign};		# match ("+inf" eq "+inf")
  return 0 if $sign !~ /^([+-]|)$/;

  if ($sign eq '')
    {
    return 1 if ($x->{sign} =~ /^[+-]inf$/); 
    return 0;
    }
  $sign = quotemeta($sign.'inf');
  return 1 if ($x->{sign} =~ /^$sign$/);
  0;
  }

sub is_one
  {
  # return true if arg (BINT or num_str) is +1
  # or -1 if sign is given
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
    
  $sign = '' if !defined $sign; $sign = '+' if $sign ne '-';
 
  return 0 if $x->{sign} ne $sign; 	# -1 != +1, NaN, +-inf aren't either
  $CALC->_is_one($x->{value});
  }

sub is_odd
  {
  # return true when arg (BINT or num_str) is odd, false for even
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
  $CALC->_is_odd($x->{value});
  }

sub is_even
  {
  # return true when arg (BINT or num_str) is even, false for odd
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
  $CALC->_is_even($x->{value});
  }

sub is_positive
  {
  # return true when arg (BINT or num_str) is positive (>= 0)
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  
  return 1 if $x->{sign} =~ /^\+/;
  0;
  }

sub is_negative
  {
  # return true when arg (BINT or num_str) is negative (< 0)
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  
  return 1 if ($x->{sign} =~ /^-/);
  0;
  }

sub is_int
  {
  # return true when arg (BINT or num_str) is an integer
  # always true for BigInt, but different for Floats
  # we don't need $self, so undef instead of ref($_[0]) make it slightly faster
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
  
  $x->{sign} =~ /^[+-]$/ ? 1 : 0;		# inf/-inf/NaN aren't
  }

###############################################################################

sub bmul 
  { 
  # multiply two numbers -- stolen from Knuth Vol 2 pg 233
  # (BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }
  
  return $x if $x->modify('bmul');

  return $x->bnan() if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/); 
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); 
    return $x->binf('-');
    }
  
  return $upgrade->bmul($x,$y,@@r)
   if defined $upgrade && $y->isa($upgrade);
  
  $r[3] = $y;				# no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});	# do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); 	# no -0

  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
  }

sub _div_inf
  {
  # helper function that handles +-inf cases for bdiv()/bmod() to reuse code
  my ($self,$x,$y) = @@_;

  # NaN if x == NaN or y == NaN or x==y==0
  return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan()
   if (($x->is_nan() || $y->is_nan())   ||
       ($x->is_zero() && $y->is_zero()));
 
  # +-inf / +-inf == NaN, reminder also NaN
  if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
    {
    return wantarray ? ($x->bnan(),$self->bnan()) : $x->bnan();
    }
  # x / +-inf => 0, remainder x (works even if x == 0)
  if ($y->{sign} =~ /^[+-]inf$/)
    {
    my $t = $x->copy();		# bzero clobbers up $x
    return wantarray ? ($x->bzero(),$t) : $x->bzero()
    }
  
  # 5 / 0 => +inf, -6 / 0 => -inf
  # +inf / 0 = inf, inf,  and -inf / 0 => -inf, -inf 
  # exception:   -8 / 0 has remainder -8, not 8
  # exception: -inf / 0 has remainder -inf, not inf
  if ($y->is_zero())
    {
    # +-inf / 0 => special case for -inf
    return wantarray ?  ($x,$x->copy()) : $x if $x->is_inf();
    if (!$x->is_zero() && !$x->is_inf())
      {
      my $t = $x->copy();		# binf clobbers up $x
      return wantarray ?
       ($x->binf($x->{sign}),$t) : $x->binf($x->{sign})
      }
    }
  
  # last case: +-inf / ordinary number
  my $sign = '+inf';
  $sign = '-inf' if substr($x->{sign},0,1) ne $y->{sign};
  $x->{sign} = $sign;
  return wantarray ? ($x,$self->bzero()) : $x;
  }

sub bdiv 
  {
  # (dividend: BINT or num_str, divisor: BINT or num_str) return 
  # (BINT,BINT) (quo,rem) or BINT (only rem)
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    } 

  return $x if $x->modify('bdiv');

  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());

  return $upgrade->bdiv($upgrade->new($x),$y,@@r)
   if defined $upgrade && !$y->isa($self);

  $r[3] = $y;					# no push!

  # 0 / something
  return
   wantarray ? ($x->round(@@r),$self->bzero(@@r)):$x->round(@@r) if $x->is_zero();
 
  # Is $x in the interval [0, $y) (aka $x <= $y) ?
  my $cmp = $CALC->_acmp($x->{value},$y->{value});
  if (($cmp < 0) and (($x->{sign} eq $y->{sign}) or !wantarray))
    {
    return $upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@@r)
     if defined $upgrade;

    return $x->bzero()->round(@@r) unless wantarray;
    my $t = $x->copy();      # make copy first, because $x->bzero() clobbers $x
    return ($x->bzero()->round(@@r),$t);
    }
  elsif ($cmp == 0)
    {
    # shortcut, both are the same, so set to +/- 1
    $x->__one( ($x->{sign} ne $y->{sign} ? '-' : '+') ); 
    return $x unless wantarray;
    return ($x->round(@@r),$self->bzero(@@r));
    }
  return $upgrade->bdiv($upgrade->new($x),$upgrade->new($y),@@r)
   if defined $upgrade;
   
  # calc new sign and in case $y == +/- 1, return $x
  my $xsign = $x->{sign};				# keep
  $x->{sign} = ($x->{sign} ne $y->{sign} ? '-' : '+'); 
  # check for / +-1 (cant use $y->is_one due to '-'
  if ($CALC->_is_one($y->{value}))
    {
    return wantarray ? ($x->round(@@r),$self->bzero(@@r)) : $x->round(@@r); 
    }

  if (wantarray)
    {
    my $rem = $self->bzero(); 
    ($x->{value},$rem->{value}) = $CALC->_div($x->{value},$y->{value});
    $x->{sign} = '+' if $CALC->_is_zero($x->{value});
    $rem->{_a} = $x->{_a};
    $rem->{_p} = $x->{_p};
    $x->round(@@r); 
    if (! $CALC->_is_zero($rem->{value}))
      {
      $rem->{sign} = $y->{sign};
      $rem = $y-$rem if $xsign ne $y->{sign};	# one of them '-'
      }
    else
      {
      $rem->{sign} = '+';			# dont leave -0
      }
    return ($x,$rem->round(@@r));
    }

  $x->{value} = $CALC->_div($x->{value},$y->{value});
  $x->{sign} = '+' if $CALC->_is_zero($x->{value});

  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
  }

###############################################################################
# modulus functions

sub bmod 
  {
  # modulus (or remainder)
  # (BINT or num_str, BINT or num_str) return BINT
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bmod');
  $r[3] = $y;					# no push!
  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero())
    {
    my ($d,$r) = $self->_div_inf($x,$y);
    $x->{sign} = $r->{sign};
    $x->{value} = $r->{value};
    return $x->round(@@r);
    }

  if ($CALC->can('_mod'))
    {
    # calc new sign and in case $y == +/- 1, return $x
    $x->{value} = $CALC->_mod($x->{value},$y->{value});
    if (!$CALC->_is_zero($x->{value}))
      {
      my $xsign = $x->{sign};
      $x->{sign} = $y->{sign};
      if ($xsign ne $y->{sign})
        {
        my $t = $CALC->_copy($x->{value});		# copy $x
        $x->{value} = $CALC->_copy($y->{value});	# copy $y to $x
        $x->{value} = $CALC->_sub($y->{value},$t,1); 	# $y-$x
d245 2
a246 12
    else
      {
      $x->{sign} = '+';				# dont leave -0
      }
    $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }
  my ($t,$rem) = $self->bdiv($x->copy(),$y,@@r);	# slow way (also rounds)
  # modify in place
  foreach (qw/value sign _a _p/)
    {
    $x->{$_} = $rem->{$_};
d248 2
a249 2
  $x;
  }
d251 34
a284 31
sub bmodinv
  {
  # modular inverse.  given a number which is (hopefully) relatively
  # prime to the modulus, calculate its inverse using Euclid's
  # alogrithm.  if the number is not relatively prime to the modulus
  # (i.e. their gcd is not one) then NaN is returned.

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it 
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    } 

  return $x if $x->modify('bmodinv');

  return $x->bnan()
	if ($y->{sign} ne '+'				# -, NaN, +inf, -inf
         || $x->is_zero()				# or num == 0
	 || $x->{sign} !~ /^[+-]$/			# or num NaN, inf, -inf
        );

  # put least residue into $x if $x was negative, and thus make it positive
  $x->bmod($y) if $x->{sign} eq '-';

  if ($CALC->can('_modinv'))
    {
    $x->{value} = $CALC->_modinv($x->{value},$y->{value});
    $x->bnan() if !defined $x->{value} ;            # in case there was none
    return $x;
d286 2
a287 15

  my ($u, $u1) = ($self->bzero(), $self->bone());
  my ($a, $b) = ($y->copy(), $x->copy());

  # first step need always be done since $num (and thus $b) is never 0
  # Note that the loop is aligned so that the check occurs between #2 and #1
  # thus saving us one step #2 at the loop end. Typical loop count is 1. Even
  # a case with 28 loops still gains about 3% with this layout.
  my $q;
  ($a, $q, $b) = ($b, $a->bdiv($b));                    # step #1
  # Euclid's Algorithm
  while (!$b->is_zero())
    {
    ($u, $u1) = ($u1, $u->bsub($u1->copy()->bmul($q))); # step #2
    ($a, $q, $b) = ($b, $a->bdiv($b));                  # step #1 again
d289 28
a316 30

  # if the gcd is not 1, then return NaN!  It would be pointless to
  # have called bgcd to check this first, because we would then be performing
  # the same Euclidean Algorithm *twice*
  return $x->bnan() unless $a->is_one();

  $u1->bmod($y);
  $x->{value} = $u1->{value};
  $x->{sign} = $u1->{sign};
  $x;
  }

sub bmodpow
  {
  # takes a very large number to a very large exponent in a given very
  # large modulus, quickly, thanks to binary exponentation.  supports
  # negative exponents.
  my ($self,$num,$exp,$mod,@@r) = objectify(3,@@_);

  return $num if $num->modify('bmodpow');

  # check modulus for valid values
  return $num->bnan() if ($mod->{sign} ne '+'		# NaN, - , -inf, +inf
                       || $mod->is_zero());

  # check exponent for valid values
  if ($exp->{sign} =~ /\w/) 
    {
    # i.e., if it's NaN, +inf, or -inf...
    return $num->bnan();
d318 45
a362 11

  $num->bmodinv ($mod) if ($exp->{sign} eq '-');

  # check num for valid values (also NaN if there was no inverse but $exp < 0)
  return $num->bnan() if $num->{sign} !~ /^[+-]$/;

  if ($CALC->can('_modpow'))
    {
    # $mod is positive, sign on $exp is ignored, result also positive
    $num->{value} = $CALC->_modpow($num->{value},$exp->{value},$mod->{value});
    return $num;
d364 1
d366 23
a388 18
  # in the trivial case,
  return $num->bzero(@@r) if $mod->is_one();
  return $num->bone('+',@@r) if $num->is_zero() or $num->is_one();

  # $num->bmod($mod);           # if $x is large, make it smaller first
  my $acc = $num->copy();	# but this is not really faster...

  $num->bone(); # keep ref to $num

  my $expbin = $exp->as_bin(); $expbin =~ s/^[-]?0b//; # ignore sign and prefix
  my $len = length($expbin);
  while (--$len >= 0)
    {
    if( substr($expbin,$len,1) eq '1')
      {
      $num->bmul($acc)->bmod($mod);
      }
    $acc->bmul($acc)->bmod($mod);
d390 1
d392 13
a404 145
  $num;
  }

###############################################################################

sub bfac
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute factorial numbers
  # modifies first argument
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);

  return $x if $x->modify('bfac');
 
  return $x->bnan() if $x->{sign} ne '+';	# inf, NnN, <0 etc => NaN
  return $x->bone('+',@@r) if $x->is_zero() || $x->is_one();	# 0 or 1 => 1

  if ($CALC->can('_fac'))
    {
    $x->{value} = $CALC->_fac($x->{value});
    return $x->round(@@r);
    }

  my $n = $x->copy();
  $x->bone();
  # seems we need not to temp. clear A/P of $x since the result is the same
  my $f = $self->new(2);
  while ($f->bacmp($n) < 0)
    {
    $x->bmul($f); $f->binc();
    }
  $x->bmul($f,@@r);			# last step and also round
  }
 
sub bpow 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute power of two numbers -- stolen from Knuth Vol 2 pg 233
  # modifies first argument
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bpow');

  return $upgrade->bpow($upgrade->new($x),$y,@@r)
   if defined $upgrade && !$y->isa($self);

  $r[3] = $y;					# no push!
  return $x if $x->{sign} =~ /^[+-]inf$/;	# -inf/+inf ** x
  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;
  return $x->bone('+',@@r) if $y->is_zero();
  return $x->round(@@r) if $x->is_one() || $y->is_one();
  if ($x->{sign} eq '-' && $CALC->_is_one($x->{value}))
    {
    # if $x == -1 and odd/even y => +1/-1
    return $y->is_odd() ? $x->round(@@r) : $x->babs()->round(@@r);
    # my Casio FX-5500L has a bug here: -1 ** 2 is -1, but -1 * -1 is 1;
    }
  # 1 ** -y => 1 / (1 ** |y|)
  # so do test for negative $y after above's clause
  return $x->bnan() if $y->{sign} eq '-';
  return $x->round(@@r) if $x->is_zero();  # 0**y => 0 (if not y <= 0)

  if ($CALC->can('_pow'))
    {
    $x->{value} = $CALC->_pow($x->{value},$y->{value});
    $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
    return $x;
    }

# based on the assumption that shifting in base 10 is fast, and that mul
# works faster if numbers are small: we count trailing zeros (this step is
# O(1)..O(N), but in case of O(N) we save much more time due to this),
# stripping them out of the multiplication, and add $count * $y zeros
# afterwards like this:
# 300 ** 3 == 300*300*300 == 3*3*3 . '0' x 2 * 3 == 27 . '0' x 6
# creates deep recursion since brsft/blsft use bpow sometimes.
#  my $zeros = $x->_trailing_zeros();
#  if ($zeros > 0)
#    {
#    $x->brsft($zeros,10);	# remove zeros
#    $x->bpow($y);		# recursion (will not branch into here again)
#    $zeros = $y * $zeros; 	# real number of zeros to add
#    $x->blsft($zeros,10);
#    return $x->round(@@r);
#    }

  my $pow2 = $self->__one();
  my $y_bin = $y->as_bin(); $y_bin =~ s/^0b//;
  my $len = length($y_bin);
  while (--$len > 0)
    {
    $pow2->bmul($x) if substr($y_bin,$len,1) eq '1';	# is odd?
    $x->bmul($x);
    }
  $x->bmul($pow2);
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
  }

sub blsft 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x << y, base n, y >= 0
 
  # set up parameters
  my ($self,$x,$y,$n,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('blsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@@r) if $y->is_zero();

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

  my $t; $t = $CALC->_lsft($x->{value},$y->{value},$n) if $CALC->can('_lsft');
  if (defined $t)
    {
    $x->{value} = $t; return $x->round(@@r);
    }
  # fallback
  return $x->bmul( $self->bpow($n, $y, @@r), @@r );
  }

sub brsft 
  {
  # (BINT or num_str, BINT or num_str) return BINT
  # compute x >> y, base n, y >= 0
  
  # set up parameters
  my ($self,$x,$y,$n,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$n,@@r) = objectify(2,@@_);
d406 1
d408 11
a418 34
  return $x if $x->modify('brsft');
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@@r) if $y->is_zero();
  return $x->bzero(@@r) if $x->is_zero();		# 0 => 0

  $n = 2 if !defined $n; return $x->bnan() if $n <= 0 || $y->{sign} eq '-';

   # this only works for negative numbers when shifting in base 2
  if (($x->{sign} eq '-') && ($n == 2))
    {
    return $x->round(@@r) if $x->is_one('-');	# -1 => -1
    if (!$y->is_one())
      {
      # although this is O(N*N) in calc (as_bin!) it is O(N) in Pari et al
      # but perhaps there is a better emulation for two's complement shift...
      # if $y != 1, we must simulate it by doing:
      # convert to bin, flip all bits, shift, and be done
      $x->binc();			# -3 => -2
      my $bin = $x->as_bin();
      $bin =~ s/^-0b//;			# strip '-0b' prefix
      $bin =~ tr/10/01/;		# flip bits
      # now shift
      if (CORE::length($bin) <= $y)
        {
	$bin = '0'; 			# shifting to far right creates -1
					# 0, because later increment makes 
					# that 1, attached '-' makes it '-1'
					# because -1 >> x == -1 !
        } 
      else
	{
	$bin =~ s/.{$y}$//;		# cut off at the right side
        $bin = '1' . $bin;		# extend left side by one dummy '1'
        $bin =~ tr/10/01/;		# flip bits back
d420 1
a420 6
      my $res = $self->new('0b'.$bin);	# add prefix and convert back
      $res->binc();			# remember to increment
      $x->{value} = $res->{value};	# take over value
      return $x->round(@@r);		# we are done now, magic, isn't?
      }
    $x->bdec();				# n == 2, but $y == 1: this fixes it
d422 1
d424 4
a427 25
  my $t; $t = $CALC->_rsft($x->{value},$y->{value},$n) if $CALC->can('_rsft');
  if (defined $t)
    {
    $x->{value} = $t;
    return $x->round(@@r);
    }
  # fallback
  $x->bdiv($self->bpow($n,$y, @@r), @@r);
  $x;
  }

sub band 
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x & y
 
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }
  
  return $x if $x->modify('band');
d429 2
a430 2
  $r[3] = $y;				# no push!
  local $Math::BigInt::upgrade = undef;
d432 1
a432 2
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->bzero(@@r) if $y->is_zero() || $x->is_zero();
d434 1
a434 10
  my $sign = 0;					# sign of result
  $sign = 1 if ($x->{sign} eq '-') && ($y->{sign} eq '-');
  my $sx = 1; $sx = -1 if $x->{sign} eq '-';
  my $sy = 1; $sy = -1 if $y->{sign} eq '-';
  
  if ($CALC->can('_and') && $sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_and($x->{value},$y->{value});
    return $x->round(@@r);
    }
d436 1
a436 32
  my $m = $self->bone(); my ($xr,$yr);
  my $x10000 = $self->new (0x1000);
  my $y1 = copy(ref($x),$y);	 		# make copy
  $y1->babs();					# and positive
  my $x1 = $x->copy()->babs(); $x->bzero();	# modify x in place!
  use integer;					# need this for negative bools
  while (!$x1->is_zero() && !$y1->is_zero())
    {
    ($x1, $xr) = bdiv($x1, $x10000);
    ($y1, $yr) = bdiv($y1, $x10000);
    # make both op's numbers!
    $x->badd( bmul( $class->new(
       abs($sx*int($xr->numify()) & $sy*int($yr->numify()))), 
      $m));
    $m->bmul($x10000);
    }
  $x->bneg() if $sign;
  $x->round(@@r);
  }

sub bior 
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x | y
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }
d438 2
a439 2
  return $x if $x->modify('bior');
  $r[3] = $y;				# no push!
d441 16
a456 1
  local $Math::BigInt::upgrade = undef;
d458 1
a458 2
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@@r) if $y->is_zero();
d460 2
a461 11
  my $sign = 0;					# sign of result
  $sign = 1 if ($x->{sign} eq '-') || ($y->{sign} eq '-');
  my $sx = 1; $sx = -1 if $x->{sign} eq '-';
  my $sy = 1; $sy = -1 if $y->{sign} eq '-';

  # don't use lib for negative values
  if ($CALC->can('_or') && $sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_or($x->{value},$y->{value});
    return $x->round(@@r);
    }
d463 1
a463 32
  my $m = $self->bone(); my ($xr,$yr);
  my $x10000 = $self->new(0x10000);
  my $y1 = copy(ref($x),$y);	 		# make copy
  $y1->babs();					# and positive
  my $x1 = $x->copy()->babs(); $x->bzero();	# modify x in place!
  use integer;					# need this for negative bools
  while (!$x1->is_zero() || !$y1->is_zero())
    {
    ($x1, $xr) = bdiv($x1,$x10000);
    ($y1, $yr) = bdiv($y1,$x10000);
    # make both op's numbers!
    $x->badd( bmul( $class->new(
       abs($sx*int($xr->numify()) | $sy*int($yr->numify()))), 
      $m));
    $m->bmul($x10000);
    }
  $x->bneg() if $sign;
  $x->round(@@r);
  }

sub bxor 
  {
  #(BINT or num_str, BINT or num_str) return BINT
  # compute x ^ y
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }
a464 2
  return $x if $x->modify('bxor');
  $r[3] = $y;				# no push!
d466 1
a466 1
  local $Math::BigInt::upgrade = undef;
d468 1
a468 14
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
  return $x->round(@@r) if $y->is_zero();
  
  my $sign = 0;					# sign of result
  $sign = 1 if $x->{sign} ne $y->{sign};
  my $sx = 1; $sx = -1 if $x->{sign} eq '-';
  my $sy = 1; $sy = -1 if $y->{sign} eq '-';

  # don't use lib for negative values
  if ($CALC->can('_xor') && $sx == 1 && $sy == 1)
    {
    $x->{value} = $CALC->_xor($x->{value},$y->{value});
    return $x->round(@@r);
    }
d470 2
a471 69
  my $m = $self->bone(); my ($xr,$yr);
  my $x10000 = $self->new(0x10000);
  my $y1 = copy(ref($x),$y);	 		# make copy
  $y1->babs();					# and positive
  my $x1 = $x->copy()->babs(); $x->bzero();	# modify x in place!
  use integer;					# need this for negative bools
  while (!$x1->is_zero() || !$y1->is_zero())
    {
    ($x1, $xr) = bdiv($x1, $x10000);
    ($y1, $yr) = bdiv($y1, $x10000);
    # make both op's numbers!
    $x->badd( bmul( $class->new(
       abs($sx*int($xr->numify()) ^ $sy*int($yr->numify()))), 
      $m));
    $m->bmul($x10000);
    }
  $x->bneg() if $sign;
  $x->round(@@r);
  }

sub length
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  my $e = $CALC->_len($x->{value}); 
  return wantarray ? ($e,0) : $e;
  }

sub digit
  {
  # return the nth decimal digit, negative values count backward, 0 is right
  my ($self,$x,$n) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);

  $CALC->_digit($x->{value},$n||0);
  }

sub _trailing_zeros
  {
  # return the amount of trailing zeros in $x
  my $x = shift;
  $x = $class->new($x) unless ref $x;

  return 0 if $x->is_zero() || $x->is_odd() || $x->{sign} !~ /^[+-]$/;

  return $CALC->_zeros($x->{value}) if $CALC->can('_zeros');

  # if not: since we do not know underlying internal representation:
  my $es = "$x"; $es =~ /([0]*)$/;
  return 0 if !defined $1;	# no zeros
  CORE::length("$1");		# as string, not as +0!
  }

sub bsqrt
  {
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);

  return $x if $x->modify('bsqrt');

  return $x->bnan() if $x->{sign} ne '+';	# -x or inf or NaN => NaN
  return $x->bzero(@@r) if $x->is_zero();			# 0 => 0
  return $x->round(@@r) if $x->is_one();			# 1 => 1

  return $upgrade->bsqrt($x,@@r) if defined $upgrade;

  if ($CALC->can('_sqrt'))
    {
    $x->{value} = $CALC->_sqrt($x->{value});
    return $x->round(@@r);
    }
d473 1
a473 78
  return $x->bone('+',@@r) if $x < 4;				# 2,3 => 1
  my $y = $x->copy();
  my $l = int($x->length()/2);
  
  $x->bone();					# keep ref($x), but modify it
  $x->blsft($l,10);

  my $last = $self->bzero();
  my $two = $self->new(2);
  my $lastlast = $x+$two;
  while ($last != $x && $lastlast != $x)
    {
    $lastlast = $last; $last = $x; 
    $x += $y / $x; 
    $x /= $two;
    }
  $x-- if $x * $x > $y;				# overshot?
  $x->round(@@r);
  }

sub exponent
  {
  # return a copy of the exponent (here always 0, NaN or 1 for $m == 0)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
 
  if ($x->{sign} !~ /^[+-]$/)
    {
    my $s = $x->{sign}; $s =~ s/^[+-]//;
    return $self->new($s); 		# -inf,+inf => inf
    }
  my $e = $class->bzero();
  return $e->binc() if $x->is_zero();
  $e += $x->_trailing_zeros();
  $e;
  }

sub mantissa
  {
  # return the mantissa (compatible to Math::BigFloat, e.g. reduced)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  if ($x->{sign} !~ /^[+-]$/)
    {
    return $self->new($x->{sign}); 		# keep + or - sign
    }
  my $m = $x->copy();
  # that's inefficient
  my $zeros = $m->_trailing_zeros();
  $m->brsft($zeros,10) if $zeros != 0;
  $m;
  }

sub parts
  {
  # return a copy of both the exponent and the mantissa
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return ($x->mantissa(),$x->exponent());
  }
   
##############################################################################
# rounding functions

sub bfround
  {
  # precision: round to the $Nth digit left (+$n) or right (-$n) from the '.'
  # $n == 0 || $n == 1 => round to integer
  my $x = shift; $x = $class->new($x) unless ref $x;
  my ($scale,$mode) = $x->_scale_p($x->precision(),$x->round_mode(),@@_);
  return $x if !defined $scale;		# no-op
  return $x if $x->modify('bfround');

  # no-op for BigInts if $n <= 0
  if ($scale <= 0)
    {
    $x->{_a} = undef;				# clear an eventual set A
    $x->{_p} = $scale; return $x;
    }
d475 2
a476 51
  $x->bround( $x->length()-$scale, $mode);
  $x->{_a} = undef;				# bround sets {_a}
  $x->{_p} = $scale;				# so correct it
  $x;
  }

sub _scan_for_nonzero
  {
  my $x = shift;
  my $pad = shift;
  my $xs = shift;
 
  my $len = $x->length();
  return 0 if $len == 1;		# '5' is trailed by invisible zeros
  my $follow = $pad - 1;
  return 0 if $follow > $len || $follow < 1;

  # since we do not know underlying represention of $x, use decimal string
  #my $r = substr ($$xs,-$follow);
  my $r = substr ("$x",-$follow);
  return 1 if $r =~ /[^0]/;
  0;
  }

sub fround
  {
  # to make life easier for switch between MBF and MBI (autoload fxxx()
  # like MBF does for bxxx()?)
  my $x = shift;
  return $x->bround(@@_);
  }

sub bround
  {
  # accuracy: +$n preserve $n digits from left,
  #           -$n preserve $n digits from right (f.i. for 0.1234 style in MBF)
  # no-op for $n == 0
  # and overwrite the rest with 0's, return normalized number
  # do not return $x->bnorm(), but $x

  my $x = shift; $x = $class->new($x) unless ref $x;
  my ($scale,$mode) = $x->_scale_a($x->accuracy(),$x->round_mode(),@@_);
  return $x if !defined $scale;			# no-op
  return $x if $x->modify('bround');
  
  if ($x->is_zero() || $scale == 0)
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x;
    }
  return $x if $x->{sign} !~ /^[+-]$/;		# inf, NaN
d478 1
a478 52
  # we have fewer digits than we want to scale to
  my $len = $x->length();
  # scale < 0, but > -len (not >=!)
  if (($scale < 0 && $scale < -$len-1) || ($scale >= $len))
    {
    $x->{_a} = $scale if !defined $x->{_a} || $x->{_a} > $scale; # 3 > 2
    return $x; 
    }
   
  # count of 0's to pad, from left (+) or right (-): 9 - +6 => 3, or |-6| => 6
  my ($pad,$digit_round,$digit_after);
  $pad = $len - $scale;
  $pad = abs($scale-1) if $scale < 0;

  # do not use digit(), it is costly for binary => decimal

  my $xs = $CALC->_str($x->{value});
  my $pl = -$pad-1;
 
  # pad:   123: 0 => -1, at 1 => -2, at 2 => -3, at 3 => -4
  # pad+1: 123: 0 => 0,  at 1 => -1, at 2 => -2, at 3 => -3
  $digit_round = '0'; $digit_round = substr($$xs,$pl,1) if $pad <= $len;
  $pl++; $pl ++ if $pad >= $len;
  $digit_after = '0'; $digit_after = substr($$xs,$pl,1) if $pad > 0;

  # in case of 01234 we round down, for 6789 up, and only in case 5 we look
  # closer at the remaining digits of the original $x, remember decision
  my $round_up = 1;					# default round up
  $round_up -- if
    ($mode eq 'trunc')				||	# trunc by round down
    ($digit_after =~ /[01234]/)			|| 	# round down anyway,
							# 6789 => round up
    ($digit_after eq '5')			&&	# not 5000...0000
    ($x->_scan_for_nonzero($pad,$xs) == 0)		&&
    (
     ($mode eq 'even') && ($digit_round =~ /[24680]/) ||
     ($mode eq 'odd')  && ($digit_round =~ /[13579]/) ||
     ($mode eq '+inf') && ($x->{sign} eq '-')   ||
     ($mode eq '-inf') && ($x->{sign} eq '+')   ||
     ($mode eq 'zero')		# round down if zero, sign adjusted below
    );
  my $put_back = 0;					# not yet modified
	
  if (($pad > 0) && ($pad <= $len))
    {
    substr($$xs,-$pad,$pad) = '0' x $pad;
    $put_back = 1;
    }
  elsif ($pad > $len)
    {
    $x->bzero();					# round to '0'
    }
d480 1
a480 15
  if ($round_up)					# what gave test above?
    {
    $put_back = 1;
    $pad = $len, $$xs = '0'x$pad if $scale < 0;		# tlr: whack 0.51=>1.0	

    # we modify directly the string variant instead of creating a number and
    # adding it, since that is faster (we already have the string)
    my $c = 0; $pad ++;				# for $pad == $len case
    while ($pad <= $len)
      {
      $c = substr($$xs,-$pad,1) + 1; $c = '0' if $c eq '10';
      substr($$xs,-$pad,1) = $c; $pad++;
      last if $c != 0;				# no overflow => early out
      }
    $$xs = '1'.$$xs if $c == 0;
d482 1
a482 2
    }
  $x->{value} = $CALC->_new($xs) if $put_back == 1;	# put back in if needed
d484 5
a488 8
  $x->{_a} = $scale if $scale >= 0;
  if ($scale < 0)
    {
    $x->{_a} = $len+$scale;
    $x->{_a} = 0 if $scale < -$len;
    }
  $x;
  }
d490 1
a490 56
sub bfloor
  {
  # return integer less or equal then number, since it is already integer,
  # always returns $self
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);

  $x->round(@@r);
  }

sub bceil
  {
  # return integer greater or equal then number, since it is already integer,
  # always returns $self
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);

  $x->round(@@r);
  }

##############################################################################
# private stuff (internal use only)

sub __one
  {
  # internal speedup, set argument to 1, or create a +/- 1
  my $self = shift;
  my $x = $self->bone(); # $x->{value} = $CALC->_one();
  $x->{sign} = shift || '+';
  $x;
  }

sub _swap
  {
  # Overload will swap params if first one is no object ref so that the first
  # one is always an object ref. In this case, third param is true.
  # This routine is to overcome the effect of scalar,$object creating an object
  # of the class of this package, instead of the second param $object. This
  # happens inside overload, when the overload section of this package is
  # inherited by sub classes.
  # For overload cases (and this is used only there), we need to preserve the
  # args, hence the copy().
  # You can override this method in a subclass, the overload section will call
  # $object->_swap() to make sure it arrives at the proper subclass, with some
  # exceptions like '+' and '-'. To make '+' and '-' work, you also need to
  # specify your own overload for them.

  # object, (object|scalar) => preserve first and make copy
  # scalar, object	    => swapped, re-swap and create new from first
  #                            (using class of second object, not $class!!)
  my $self = shift;			# for override in subclass
  if ($_[2])
    {
    my $c = ref ($_[0]) || $class; 	# fallback $class should not happen
    return ( $c->new($_[1]), $_[0] );
    }
  return ( $_[0]->copy(), $_[1] );
  }
d492 3
a494 42
sub objectify
  {
  # check for strings, if yes, return objects instead
 
  # the first argument is number of args objectify() should look at it will
  # return $count+1 elements, the first will be a classname. This is because
  # overloaded '""' calls bstr($object,undef,undef) and this would result in
  # useless objects beeing created and thrown away. So we cannot simple loop
  # over @@_. If the given count is 0, all arguments will be used.
 
  # If the second arg is a ref, use it as class.
  # If not, try to use it as classname, unless undef, then use $class 
  # (aka Math::BigInt). The latter shouldn't happen,though.

  # caller:			   gives us:
  # $x->badd(1);                => ref x, scalar y
  # Class->badd(1,2);           => classname x (scalar), scalar x, scalar y
  # Class->badd( Class->(1),2); => classname x (scalar), ref x, scalar y
  # Math::BigInt::badd(1,2);    => scalar x, scalar y
  # In the last case we check number of arguments to turn it silently into
  # $class,1,2. (We can not take '1' as class ;o)
  # badd($class,1) is not supported (it should, eventually, try to add undef)
  # currently it tries 'Math::BigInt' + 1, which will not work.

  # some shortcut for the common cases
  # $x->unary_op();
  return (ref($_[1]),$_[1]) if (@@_ == 2) && ($_[0]||0 == 1) && ref($_[1]);

  my $count = abs(shift || 0);
  
  my (@@a,$k,$d);		# resulting array, temp, and downgrade 
  if (ref $_[0])
    {
    # okay, got object as first
    $a[0] = ref $_[0];
    }
  else
    {
    # nope, got 1,2 (Class->xxx(1) => Class,1 and not supported)
    $a[0] = $class;
    $a[0] = shift if $_[0] =~ /^[A-Z].*::/;	# classname as first?
    }
a495 7
  no strict 'refs';
  # disable downgrading, because Math::BigFLoat->foo('1.0','2.0') needs floats
  if (defined ${"$a[0]::downgrade"})
    {
    $d = ${"$a[0]::downgrade"};
    ${"$a[0]::downgrade"} = undef;
    }
d497 1
a497 338
  my $up = ${"$a[0]::upgrade"};
  # print "Now in objectify, my class is today $a[0]\n";
  if ($count == 0)
    {
    while (@@_)
      {
      $k = shift;
      if (!ref($k))
        {
        $k = $a[0]->new($k);
        }
      elsif (!defined $up && ref($k) ne $a[0])
	{
	# foreign object, try to convert to integer
        $k->can('as_number') ?  $k = $k->as_number() : $k = $a[0]->new($k);
	}
      push @@a,$k;
      }
    }
  else
    {
    while ($count > 0)
      {
      $count--; 
      $k = shift; 
      if (!ref($k))
        {
        $k = $a[0]->new($k);
        }
      elsif (!defined $up && ref($k) ne $a[0])
	{
	# foreign object, try to convert to integer
        $k->can('as_number') ?  $k = $k->as_number() : $k = $a[0]->new($k);
	}
      push @@a,$k;
      }
    push @@a,@@_;		# return other params, too
    }
  die "$class objectify needs list context" unless wantarray;
  ${"$a[0]::downgrade"} = $d;
  @@a;
  }

sub import 
  {
  my $self = shift;

  $IMPORT++;
  my @@a; my $l = scalar @@_;
  for ( my $i = 0; $i < $l ; $i++ )
    {
    if ($_[$i] eq ':constant')
      {
      # this causes overlord er load to step in
      overload::constant integer => sub { $self->new(shift) };
      overload::constant binary => sub { $self->new(shift) };
      }
    elsif ($_[$i] eq 'upgrade')
      {
      # this causes upgrading
      $upgrade = $_[$i+1];		# or undef to disable
      $i++;
      }
    elsif ($_[$i] =~ /^lib$/i)
      {
      # this causes a different low lib to take care...
      $CALC = $_[$i+1] || '';
      $i++;
      }
    else
      {
      push @@a, $_[$i];
      }
    }
  # any non :constant stuff is handled by our parent, Exporter
  # even if @@_ is empty, to give it a chance 
  $self->SUPER::import(@@a);			# need it for subclasses
  $self->export_to_level(1,$self,@@a);		# need it for MBF

  # try to load core math lib
  my @@c = split /\s*,\s*/,$CALC;
  push @@c,'Calc';				# if all fail, try this
  $CALC = '';					# signal error
  foreach my $lib (@@c)
    {
    next if ($lib || '') eq '';
    $lib = 'Math::BigInt::'.$lib if $lib !~ /^Math::BigInt/i;
    $lib =~ s/\.pm$//;
    if ($] < 5.006)
      {
      # Perl < 5.6.0 dies with "out of memory!" when eval() and ':constant' is
      # used in the same script, or eval inside import().
      my @@parts = split /::/, $lib;             # Math::BigInt => Math BigInt
      my $file = pop @@parts; $file .= '.pm';    # BigInt => BigInt.pm
      require File::Spec;
      $file = File::Spec->catfile (@@parts, $file);
      eval { require "$file"; $lib->import( @@c ); }
      }
    else
      {
      eval "use $lib qw/@@c/;";
      }
    $CALC = $lib, last if $@@ eq '';	# no error in loading lib?
    }
  die "Couldn't load any math lib, not even the default" if $CALC eq '';
  }

sub __from_hex
  {
  # convert a (ref to) big hex string to BigInt, return undef for error
  my $hs = shift;

  my $x = Math::BigInt->bzero();
  
  # strip underscores
  $$hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
  $$hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
  
  return $x->bnan() if $$hs !~ /^[\-\+]?0x[0-9A-Fa-f]+$/;

  my $sign = '+'; $sign = '-' if ($$hs =~ /^-/);

  $$hs =~ s/^[+-]//;			# strip sign
  if ($CALC->can('_from_hex'))
    {
    $x->{value} = $CALC->_from_hex($hs);
    }
  else
    {
    # fallback to pure perl
    my $mul = Math::BigInt->bzero(); $mul++;
    my $x65536 = Math::BigInt->new(65536);
    my $len = CORE::length($$hs)-2;
    $len = int($len/4);			# 4-digit parts, w/o '0x'
    my $val; my $i = -4;
    while ($len >= 0)
      {
      $val = substr($$hs,$i,4);
      $val =~ s/^[+-]?0x// if $len == 0;	# for last part only because
      $val = hex($val); 			# hex does not like wrong chars
      $i -= 4; $len --;
      $x += $mul * $val if $val != 0;
      $mul *= $x65536 if $len >= 0;		# skip last mul
      }
    }
  $x->{sign} = $sign unless $CALC->_is_zero($x->{value}); 	# no '-0'
  $x;
  }

sub __from_bin
  {
  # convert a (ref to) big binary string to BigInt, return undef for error
  my $bs = shift;

  my $x = Math::BigInt->bzero();
  # strip underscores
  $$bs =~ s/([01])_([01])/$1$2/g;	
  $$bs =~ s/([01])_([01])/$1$2/g;	
  return $x->bnan() if $$bs !~ /^[+-]?0b[01]+$/;

  my $sign = '+'; $sign = '-' if ($$bs =~ /^\-/);
  $$bs =~ s/^[+-]//;				# strip sign
  if ($CALC->can('_from_bin'))
    {
    $x->{value} = $CALC->_from_bin($bs);
    }
  else
    {
    my $mul = Math::BigInt->bzero(); $mul++;
    my $x256 = Math::BigInt->new(256);
    my $len = CORE::length($$bs)-2;
    $len = int($len/8);				# 8-digit parts, w/o '0b'
    my $val; my $i = -8;
    while ($len >= 0)
      {
      $val = substr($$bs,$i,8);
      $val =~ s/^[+-]?0b// if $len == 0;	# for last part only
      #$val = oct('0b'.$val);	# does not work on Perl prior to 5.6.0
      # slower:
      # $val = ('0' x (8-CORE::length($val))).$val if CORE::length($val) < 8;
      $val = ord(pack('B8',substr('00000000'.$val,-8,8)));
      $i -= 8; $len --;
      $x += $mul * $val if $val != 0;
      $mul *= $x256 if $len >= 0;		# skip last mul
      }
    }
  $x->{sign} = $sign unless $CALC->_is_zero($x->{value}); 	# no '-0'
  $x;
  }

sub _split
  {
  # (ref to num_str) return num_str
  # internal, take apart a string and return the pieces
  # strip leading/trailing whitespace, leading zeros, underscore and reject
  # invalid input
  my $x = shift;

  # strip white space at front, also extranous leading zeros
  $$x =~ s/^\s*([-]?)0*([0-9])/$1$2/g;	# will not strip '  .2'
  $$x =~ s/^\s+//;			# but this will			
  $$x =~ s/\s+$//g;			# strip white space at end

  # shortcut, if nothing to split, return early
  if ($$x =~ /^[+-]?\d+\z/)
    {
    $$x =~ s/^([+-])0*([0-9])/$2/; my $sign = $1 || '+';
    return (\$sign, $x, \'', \'', \0);
    }

  # invalid starting char?
  return if $$x !~ /^[+-]?(\.?[0-9]|0b[0-1]|0x[0-9a-fA-F])/;

  return __from_hex($x) if $$x =~ /^[\-\+]?0x/;	# hex string
  return __from_bin($x) if $$x =~ /^[\-\+]?0b/;	# binary string
  
  # strip underscores between digits
  $$x =~ s/(\d)_(\d)/$1$2/g;
  $$x =~ s/(\d)_(\d)/$1$2/g;		# do twice for 1_2_3

  # some possible inputs: 
  # 2.1234 # 0.12        # 1 	      # 1E1 # 2.134E1 # 434E-10 # 1.02009E-2 
  # .2 	   # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2

  return if $$x =~ /[Ee].*[Ee]/;	# more than one E => error

  my ($m,$e) = split /[Ee]/,$$x;
  $e = '0' if !defined $e || $e eq "";
  # sign,value for exponent,mantint,mantfrac
  my ($es,$ev,$mis,$miv,$mfv);
  # valid exponent?
  if ($e =~ /^([+-]?)0*(\d+)$/) # strip leading zeros
    {
    $es = $1; $ev = $2;
    # valid mantissa?
    return if $m eq '.' || $m eq '';
    my ($mi,$mf,$last) = split /\./,$m;
    return if defined $last;		# last defined => 1.2.3 or others
    $mi = '0' if !defined $mi;
    $mi .= '0' if $mi =~ /^[\-\+]?$/;
    $mf = '0' if !defined $mf || $mf eq '';
    if ($mi =~ /^([+-]?)0*(\d+)$/) # strip leading zeros
      {
      $mis = $1||'+'; $miv = $2;
      return unless ($mf =~ /^(\d*?)0*$/);	# strip trailing zeros
      $mfv = $1;
      return (\$mis,\$miv,\$mfv,\$es,\$ev);
      }
    }
  return; # NaN, not a number
  }

sub as_number
  {
  # an object might be asked to return itself as bigint on certain overloaded
  # operations, this does exactly this, so that sub classes can simple inherit
  # it or override with their own integer conversion routine
  my $self = shift;

  $self->copy();
  }

sub as_hex
  {
  # return as hex string, with prefixed 0x
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc
  return '0x0' if $x->is_zero();

  my $es = ''; my $s = '';
  $s = $x->{sign} if $x->{sign} eq '-';
  if ($CALC->can('_as_hex'))
    {
    $es = ${$CALC->_as_hex($x->{value})};
    }
  else
    {
    my $x1 = $x->copy()->babs(); my ($xr,$x10000,$h);
    if ($] >= 5.006)
      {
      $x10000 = Math::BigInt->new (0x10000); $h = 'h4';
      }
    else
      {
      $x10000 = Math::BigInt->new (0x1000); $h = 'h3';
      }
    while (!$x1->is_zero())
      {
      ($x1, $xr) = bdiv($x1,$x10000);
      $es .= unpack($h,pack('v',$xr->numify()));
      }
    $es = reverse $es;
    $es =~ s/^[0]+//; 	# strip leading zeros
    $s .= '0x';
    }
  $s . $es;
  }

sub as_bin
  {
  # return as binary string, with prefixed 0b
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc
  return '0b0' if $x->is_zero();

  my $es = ''; my $s = '';
  $s = $x->{sign} if $x->{sign} eq '-';
  if ($CALC->can('_as_bin'))
    {
    $es = ${$CALC->_as_bin($x->{value})};
    }
  else
    {
    my $x1 = $x->copy()->babs(); my ($xr,$x10000,$b);
    if ($] >= 5.006)
      {
      $x10000 = Math::BigInt->new (0x10000); $b = 'b16';
      }
    else
      {
      $x10000 = Math::BigInt->new (0x1000); $b = 'b12';
      }
    while (!$x1->is_zero())
      {
      ($x1, $xr) = bdiv($x1,$x10000);
      $es .= unpack($b,pack('v',$xr->numify()));
      }
    $es = reverse $es; 
    $es =~ s/^[0]+//; 	# strip leading zeros
    $s .= '0b';
    }
  $s . $es;
  }

##############################################################################
# internal calculation routines (others are in Math::BigInt::Calc etc)
d499 3
a501 26
sub __lcm 
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does modify first argument
  # LCM
 
  my $x = shift; my $ty = shift;
  return $x->bnan() if ($x->{sign} eq $nan) || ($ty->{sign} eq $nan);
  return $x * $ty / bgcd($x,$ty);
  }

sub __gcd
  { 
  # (BINT or num_str, BINT or num_str) return BINT
  # does modify both arguments
  # GCD -- Euclids algorithm E, Knuth Vol 2 pg 296
  my ($x,$ty) = @@_;

  return $x->bnan() if $x->{sign} !~ /^[+-]$/ || $ty->{sign} !~ /^[+-]$/;

  while (!$ty->is_zero())
    {
    ($x, $ty) = ($ty,bmod($x,$ty));
    }
  $x;
  }
d503 1
a503 4
###############################################################################
# this method return 0 if the object can be modified, or 1 for not
# We use a fast use constant statement here, to avoid costly calls. Subclasses
# may override it with special code (f.i. Math::BigInt::Constant does so)
d505 1
a505 1
sub modify () { 0; }
d507 2
a508 2
1;
__END__
d510 1
a510 1542
=head1 NAME

Math::BigInt - Arbitrary size integer math package

=head1 SYNOPSIS

  use Math::BigInt;

  # Number creation	
  $x = Math::BigInt->new($str);		# defaults to 0
  $nan  = Math::BigInt->bnan(); 	# create a NotANumber
  $zero = Math::BigInt->bzero();	# create a +0
  $inf = Math::BigInt->binf();		# create a +inf
  $inf = Math::BigInt->binf('-');	# create a -inf
  $one = Math::BigInt->bone();		# create a +1
  $one = Math::BigInt->bone('-');	# create a -1

  # Testing
  $x->is_zero();		# true if arg is +0
  $x->is_nan();			# true if arg is NaN
  $x->is_one();			# true if arg is +1
  $x->is_one('-');		# true if arg is -1
  $x->is_odd();			# true if odd, false for even
  $x->is_even();		# true if even, false for odd
  $x->is_positive();		# true if >= 0
  $x->is_negative();		# true if <  0
  $x->is_inf(sign);		# true if +inf, or -inf (sign is default '+')
  $x->is_int();			# true if $x is an integer (not a float)

  $x->bcmp($y);			# compare numbers (undef,<0,=0,>0)
  $x->bacmp($y);		# compare absolutely (undef,<0,=0,>0)
  $x->sign();			# return the sign, either +,- or NaN
  $x->digit($n);		# return the nth digit, counting from right
  $x->digit(-$n);		# return the nth digit, counting from left

  # The following all modify their first argument:

  # set 
  $x->bzero();			# set $x to 0
  $x->bnan();			# set $x to NaN
  $x->bone();			# set $x to +1
  $x->bone('-');		# set $x to -1
  $x->binf();			# set $x to inf
  $x->binf('-');		# set $x to -inf

  $x->bneg();			# negation
  $x->babs();			# absolute value
  $x->bnorm();			# normalize (no-op)
  $x->bnot();			# two's complement (bit wise not)
  $x->binc();			# increment x by 1
  $x->bdec();			# decrement x by 1
  
  $x->badd($y);			# addition (add $y to $x)
  $x->bsub($y);			# subtraction (subtract $y from $x)
  $x->bmul($y);			# multiplication (multiply $x by $y)
  $x->bdiv($y);			# divide, set $x to quotient
				# return (quo,rem) or quo if scalar

  $x->bmod($y);			# modulus (x % y)
  $x->bmodpow($exp,$mod);	# modular exponentation (($num**$exp) % $mod))
  $x->bmodinv($mod);		# the inverse of $x in the given modulus $mod

  $x->bpow($y);			# power of arguments (x ** y)
  $x->blsft($y);		# left shift
  $x->brsft($y);		# right shift 
  $x->blsft($y,$n);		# left shift, by base $n (like 10)
  $x->brsft($y,$n);		# right shift, by base $n (like 10)
  
  $x->band($y);			# bitwise and
  $x->bior($y);			# bitwise inclusive or
  $x->bxor($y);			# bitwise exclusive or
  $x->bnot();			# bitwise not (two's complement)

  $x->bsqrt();			# calculate square-root
  $x->bfac();			# factorial of $x (1*2*3*4*..$x)

  $x->round($A,$P,$round_mode); # round to accuracy or precision using mode $r
  $x->bround($N);               # accuracy: preserve $N digits
  $x->bfround($N);              # round to $Nth digit, no-op for BigInts

  # The following do not modify their arguments in BigInt, but do in BigFloat:
  $x->bfloor();			# return integer less or equal than $x
  $x->bceil();			# return integer greater or equal than $x
  
  # The following do not modify their arguments:

  bgcd(@@values);		# greatest common divisor (no OO style)
  blcm(@@values);		# lowest common multiplicator (no OO style)
 
  $x->length();			# return number of digits in number
  ($x,$f) = $x->length();	# length of number and length of fraction part,
				# latter is always 0 digits long for BigInt's

  $x->exponent();		# return exponent as BigInt
  $x->mantissa();		# return (signed) mantissa as BigInt
  $x->parts();			# return (mantissa,exponent) as BigInt
  $x->copy();			# make a true copy of $x (unlike $y = $x;)
  $x->as_number();		# return as BigInt (in BigInt: same as copy())
  
  # conversation to string 
  $x->bstr();			# normalized string
  $x->bsstr();			# normalized string in scientific notation
  $x->as_hex();			# as signed hexadecimal string with prefixed 0x
  $x->as_bin();			# as signed binary string with prefixed 0b
  
  Math::BigInt->config();	# return hash containing configuration/version

  # precision and accuracy (see section about rounding for more)
  $x->precision();              # return P of $x (or global, if P of $x undef)
  $x->precision($n);            # set P of $x to $n
  $x->accuracy();               # return A of $x (or global, if A of $x undef)
  $x->accuracy($n);             # set A $x to $n

  Math::BigInt->precision();	# get/set global P for all BigInt objects
  Math::BigInt->accuracy();	# get/set global A for all BigInt objects

=head1 DESCRIPTION

All operators (inlcuding basic math operations) are overloaded if you
declare your big integers as

  $i = new Math::BigInt '123_456_789_123_456_789';

Operations with overloaded operators preserve the arguments which is
exactly what you expect.

=over 2

=item Canonical notation

Big integer values are strings of the form C</^[+-]\d+$/> with leading
zeros suppressed.

   '-0'                            canonical value '-0', normalized '0'
   '   -123_123_123'               canonical value '-123123123'
   '1_23_456_7890'                 canonical value '1234567890'

=item Input

Input values to these routines may be either Math::BigInt objects or
strings of the form C</^[+-]?[\d]+\.?[\d]*E?[+-]?[\d]*$/>.

You can include one underscore between any two digits. The input string may
have leading and trailing whitespace, which will be ignored. In later
versions, a more strict (no whitespace at all) or more lax (whitespace
allowed everywhere) input checking will also be possible.

This means integer values like 1.01E2 or even 1000E-2 are also accepted.
Non integer values result in NaN.

Math::BigInt::new() defaults to 0, while Math::BigInt::new('') results
in 'NaN'.

bnorm() on a BigInt object is now effectively a no-op, since the numbers 
are always stored in normalized form. On a string, it creates a BigInt 
object.

=item Output

Output values are BigInt objects (normalized), except for bstr(), which
returns a string in normalized form.
Some routines (C<is_odd()>, C<is_even()>, C<is_zero()>, C<is_one()>,
C<is_nan()>) return true or false, while others (C<bcmp()>, C<bacmp()>)
return either undef, <0, 0 or >0 and are suited for sort.

=back

=head1 METHODS

Each of the methods below accepts three additional parameters. These arguments
$A, $P and $R are accuracy, precision and round_mode. Please see more in the
section about ACCURACY and ROUNDIND.

=head2 config

	use Data::Dumper;

	print Dumper ( Math::BigInt->config() );

Returns a hash containing the configuration, e.g. the version number, lib
loaded etc.

=head2 accuracy

	$x->accuracy(5);		# local for $x
	$class->accuracy(5);		# global for all members of $class

Set or get the global or local accuracy, aka how many significant digits the
results have. Please see the section about L<ACCURACY AND PRECISION> for
further details.

Value must be greater than zero. Pass an undef value to disable it:

	$x->accuracy(undef);
	Math::BigInt->accuracy(undef);

Returns the current accuracy. For C<$x->accuracy()> it will return either the
local accuracy, or if not defined, the global. This means the return value
represents the accuracy that will be in effect for $x:

	$y = Math::BigInt->new(1234567);	# unrounded
	print Math::BigInt->accuracy(4),"\n";	# set 4, print 4
	$x = Math::BigInt->new(123456);		# will be automatically rounded
	print "$x $y\n";			# '123500 1234567'
	print $x->accuracy(),"\n";		# will be 4
	print $y->accuracy(),"\n";		# also 4, since global is 4
	print Math::BigInt->accuracy(5),"\n";	# set to 5, print 5
	print $x->accuracy(),"\n";		# still 4
	print $y->accuracy(),"\n";		# 5, since global is 5

=head2 brsft

	$x->brsft($y,$n);		

Shifts $x right by $y in base $n. Default is base 2, used are usually 10 and
2, but others work, too.

Right shifting usually amounts to dividing $x by $n ** $y and truncating the
result:


	$x = Math::BigInt->new(10);
	$x->brsft(1);			# same as $x >> 1: 5
	$x = Math::BigInt->new(1234);
	$x->brsft(2,10);		# result 12

There is one exception, and that is base 2 with negative $x:


	$x = Math::BigInt->new(-5);
	print $x->brsft(1);

This will print -3, not -2 (as it would if you divide -5 by 2 and truncate the
result).

=head2 new

  	$x = Math::BigInt->new($str,$A,$P,$R);

Creates a new BigInt object from a string or another BigInt object. The
input is accepted as decimal, hex (with leading '0x') or binary (with leading
'0b').

=head2 bnan

  	$x = Math::BigInt->bnan();

Creates a new BigInt object representing NaN (Not A Number).
If used on an object, it will set it to NaN:

	$x->bnan();

=head2 bzero

  	$x = Math::BigInt->bzero();

Creates a new BigInt object representing zero.
If used on an object, it will set it to zero:

	$x->bzero();

=head2 binf

  	$x = Math::BigInt->binf($sign);

Creates a new BigInt object representing infinity. The optional argument is
either '-' or '+', indicating whether you want infinity or minus infinity.
If used on an object, it will set it to infinity:

	$x->binf();
	$x->binf('-');

=head2 bone

  	$x = Math::BigInt->binf($sign);

Creates a new BigInt object representing one. The optional argument is
either '-' or '+', indicating whether you want one or minus one.
If used on an object, it will set it to one:

	$x->bone();		# +1
	$x->bone('-');		# -1

=head2 is_one()/is_zero()/is_nan()/is_inf()

  
	$x->is_zero();			# true if arg is +0
	$x->is_nan();			# true if arg is NaN
	$x->is_one();			# true if arg is +1
	$x->is_one('-');		# true if arg is -1
	$x->is_inf();			# true if +inf
	$x->is_inf('-');		# true if -inf (sign is default '+')

These methods all test the BigInt for beeing one specific value and return
true or false depending on the input. These are faster than doing something
like:

	if ($x == 0)

=head2 is_positive()/is_negative()
	
	$x->is_positive();		# true if >= 0
	$x->is_negative();		# true if <  0

The methods return true if the argument is positive or negative, respectively.
C<NaN> is neither positive nor negative, while C<+inf> counts as positive, and
C<-inf> is negative. A C<zero> is positive.

These methods are only testing the sign, and not the value.

=head2 is_odd()/is_even()/is_int()

	$x->is_odd();			# true if odd, false for even
	$x->is_even();			# true if even, false for odd
	$x->is_int();			# true if $x is an integer

The return true when the argument satisfies the condition. C<NaN>, C<+inf>,
C<-inf> are not integers and are neither odd nor even.

=head2 bcmp

	$x->bcmp($y);

Compares $x with $y and takes the sign into account.
Returns -1, 0, 1 or undef.

=head2 bacmp

	$x->bacmp($y);

Compares $x with $y while ignoring their. Returns -1, 0, 1 or undef.

=head2 sign

	$x->sign();

Return the sign, of $x, meaning either C<+>, C<->, C<-inf>, C<+inf> or NaN.

=head2 bcmp

  $x->digit($n);		# return the nth digit, counting from right

=head2 bneg

	$x->bneg();

Negate the number, e.g. change the sign between '+' and '-', or between '+inf'
and '-inf', respectively. Does nothing for NaN or zero.

=head2 babs

	$x->babs();

Set the number to it's absolute value, e.g. change the sign from '-' to '+'
and from '-inf' to '+inf', respectively. Does nothing for NaN or positive
numbers.

=head2 bnorm

  $x->bnorm();			# normalize (no-op)

=head2 bnot

  $x->bnot();			# two's complement (bit wise not)

=head2 binc

  $x->binc();			# increment x by 1

=head2 bdec

  $x->bdec();			# decrement x by 1

=head2 badd

  $x->badd($y);			# addition (add $y to $x)

=head2 bsub

  $x->bsub($y);			# subtraction (subtract $y from $x)

=head2 bmul

  $x->bmul($y);			# multiplication (multiply $x by $y)

=head2 bdiv

  $x->bdiv($y);			# divide, set $x to quotient
				# return (quo,rem) or quo if scalar

=head2 bmod

  $x->bmod($y);			# modulus (x % y)

=head2 bmodinv

  $num->bmodinv($mod);		# modular inverse

Returns the inverse of C<$num> in the given modulus C<$mod>.  'C<NaN>' is
returned unless C<$num> is relatively prime to C<$mod>, i.e. unless
C<bgcd($num, $mod)==1>.

=head2 bmodpow

  $num->bmodpow($exp,$mod);	# modular exponentation ($num**$exp % $mod)

Returns the value of C<$num> taken to the power C<$exp> in the modulus
C<$mod> using binary exponentation.  C<bmodpow> is far superior to
writing

  $num ** $exp % $mod

because C<bmodpow> is much faster--it reduces internal variables into
the modulus whenever possible, so it operates on smaller numbers.

C<bmodpow> also supports negative exponents.

  bmodpow($num, -1, $mod)

is exactly equivalent to

  bmodinv($num, $mod)

=head2 bpow

  $x->bpow($y);			# power of arguments (x ** y)

=head2 blsft

  $x->blsft($y);		# left shift
  $x->blsft($y,$n);		# left shift, by base $n (like 10)

=head2 brsft

  $x->brsft($y);		# right shift 
  $x->brsft($y,$n);		# right shift, by base $n (like 10)

=head2 band

  $x->band($y);			# bitwise and

=head2 bior

  $x->bior($y);			# bitwise inclusive or

=head2 bxor

  $x->bxor($y);			# bitwise exclusive or

=head2 bnot

  $x->bnot();			# bitwise not (two's complement)

=head2 bsqrt

  $x->bsqrt();			# calculate square-root

=head2 bfac

  $x->bfac();			# factorial of $x (1*2*3*4*..$x)

=head2 round

  $x->round($A,$P,$round_mode); # round to accuracy or precision using mode $r

=head2 bround

  $x->bround($N);               # accuracy: preserve $N digits

=head2 bfround

  $x->bfround($N);              # round to $Nth digit, no-op for BigInts

=head2 bfloor

	$x->bfloor();			

Set $x to the integer less or equal than $x. This is a no-op in BigInt, but
does change $x in BigFloat.

=head2 bceil

	$x->bceil();

Set $x to the integer greater or equal than $x. This is a no-op in BigInt, but
does change $x in BigFloat.

=head2 bgcd

  bgcd(@@values);		# greatest common divisor (no OO style)

=head2 blcm

  blcm(@@values);		# lowest common multiplicator (no OO style)
 
head2 length

	$x->length();
        ($xl,$fl) = $x->length();

Returns the number of digits in the decimal representation of the number.
In list context, returns the length of the integer and fraction part. For
BigInt's, the length of the fraction part will always be 0.

=head2 exponent

	$x->exponent();

Return the exponent of $x as BigInt.

=head2 mantissa

	$x->mantissa();

Return the signed mantissa of $x as BigInt.

=head2 parts

  $x->parts();			# return (mantissa,exponent) as BigInt

=head2 copy

  $x->copy();			# make a true copy of $x (unlike $y = $x;)

=head2 as_number

  $x->as_number();		# return as BigInt (in BigInt: same as copy())
  
=head2 bsrt

  $x->bstr();			# normalized string

=head2 bsstr

  $x->bsstr();			# normalized string in scientific notation

=head2 as_hex

  $x->as_hex();			# as signed hexadecimal string with prefixed 0x

=head2 as_bin

  $x->as_bin();			# as signed binary string with prefixed 0b

=head1 ACCURACY and PRECISION

Since version v1.33, Math::BigInt and Math::BigFloat have full support for
accuracy and precision based rounding, both automatically after every
operation as well as manually.

This section describes the accuracy/precision handling in Math::Big* as it
used to be and as it is now, complete with an explanation of all terms and
abbreviations.

Not yet implemented things (but with correct description) are marked with '!',
things that need to be answered are marked with '?'.

In the next paragraph follows a short description of terms used here (because
these may differ from terms used by others people or documentation).

During the rest of this document, the shortcuts A (for accuracy), P (for
precision), F (fallback) and R (rounding mode) will be used.

=head2 Precision P

A fixed number of digits before (positive) or after (negative)
the decimal point. For example, 123.45 has a precision of -2. 0 means an
integer like 123 (or 120). A precision of 2 means two digits to the left
of the decimal point are zero, so 123 with P = 1 becomes 120. Note that
numbers with zeros before the decimal point may have different precisions,
because 1200 can have p = 0, 1 or 2 (depending on what the inital value
was). It could also have p < 0, when the digits after the decimal point
are zero.

The string output (of floating point numbers) will be padded with zeros:
 
	Initial value   P       A	Result          String
	------------------------------------------------------------
	1234.01         -3      	1000            1000
	1234            -2      	1200            1200
	1234.5          -1      	1230            1230
	1234.001        1       	1234            1234.0
	1234.01         0       	1234            1234
	1234.01         2       	1234.01		1234.01
	1234.01         5       	1234.01		1234.01000

For BigInts, no padding occurs.

=head2 Accuracy A

Number of significant digits. Leading zeros are not counted. A
number may have an accuracy greater than the non-zero digits
when there are zeros in it or trailing zeros. For example, 123.456 has
A of 6, 10203 has 5, 123.0506 has 7, 123.450000 has 8 and 0.000123 has 3.

The string output (of floating point numbers) will be padded with zeros:

	Initial value   P       A	Result          String
	------------------------------------------------------------
	1234.01			3	1230		1230
	1234.01			6	1234.01		1234.01
	1234.1			8	1234.1		1234.1000

For BigInts, no padding occurs.

=head2 Fallback F

When both A and P are undefined, this is used as a fallback accuracy when
dividing numbers.

=head2 Rounding mode R

When rounding a number, different 'styles' or 'kinds'
of rounding are possible. (Note that random rounding, as in
Math::Round, is not implemented.)

=over 2

=item 'trunc'

truncation invariably removes all digits following the
rounding place, replacing them with zeros. Thus, 987.65 rounded
to tens (P=1) becomes 980, and rounded to the fourth sigdig
becomes 987.6 (A=4). 123.456 rounded to the second place after the
decimal point (P=-2) becomes 123.46.

All other implemented styles of rounding attempt to round to the
"nearest digit." If the digit D immediately to the right of the
rounding place (skipping the decimal point) is greater than 5, the
number is incremented at the rounding place (possibly causing a
cascade of incrementation): e.g. when rounding to units, 0.9 rounds
to 1, and -19.9 rounds to -20. If D < 5, the number is similarly
truncated at the rounding place: e.g. when rounding to units, 0.4
rounds to 0, and -19.4 rounds to -19.

However the results of other styles of rounding differ if the
digit immediately to the right of the rounding place (skipping the
decimal point) is 5 and if there are no digits, or no digits other
than 0, after that 5. In such cases:

=item 'even'

rounds the digit at the rounding place to 0, 2, 4, 6, or 8
if it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.4, -0.55 becomes -0.6, but 0.4501 becomes 0.5.

=item 'odd'

rounds the digit at the rounding place to 1, 3, 5, 7, or 9 if
it is not already. E.g., when rounding to the first sigdig, 0.45
becomes 0.5, -0.55 becomes -0.5, but 0.5501 becomes 0.6.

=item '+inf'

round to plus infinity, i.e. always round up. E.g., when
rounding to the first sigdig, 0.45 becomes 0.5, -0.55 becomes -0.5,
and 0.4501 also becomes 0.5.

=item '-inf'

round to minus infinity, i.e. always round down. E.g., when
rounding to the first sigdig, 0.45 becomes 0.4, -0.55 becomes -0.6,
but 0.4501 becomes 0.5.

=item 'zero'

round to zero, i.e. positive numbers down, negative ones up.
E.g., when rounding to the first sigdig, 0.45 becomes 0.4, -0.55
becomes -0.5, but 0.4501 becomes 0.5.

=back

The handling of A & P in MBI/MBF (the old core code shipped with Perl
versions <= 5.7.2) is like this:

=over 2

=item Precision

  * ffround($p) is able to round to $p number of digits after the decimal
    point
  * otherwise P is unused

=item Accuracy (significant digits)

  * fround($a) rounds to $a significant digits
  * only fdiv() and fsqrt() take A as (optional) paramater
    + other operations simply create the same number (fneg etc), or more (fmul)
      of digits
    + rounding/truncating is only done when explicitly calling one of fround
      or ffround, and never for BigInt (not implemented)
  * fsqrt() simply hands its accuracy argument over to fdiv.
  * the documentation and the comment in the code indicate two different ways
    on how fdiv() determines the maximum number of digits it should calculate,
    and the actual code does yet another thing
    POD:
      max($Math::BigFloat::div_scale,length(dividend)+length(divisor))
    Comment:
      result has at most max(scale, length(dividend), length(divisor)) digits
    Actual code:
      scale = max(scale, length(dividend)-1,length(divisor)-1);
      scale += length(divisior) - length(dividend);
    So for lx = 3, ly = 9, scale = 10, scale will actually be 16 (10+9-3).
    Actually, the 'difference' added to the scale is calculated from the
    number of "significant digits" in dividend and divisor, which is derived
    by looking at the length of the mantissa. Which is wrong, since it includes
    the + sign (oups) and actually gets 2 for '+100' and 4 for '+101'. Oups
    again. Thus 124/3 with div_scale=1 will get you '41.3' based on the strange
    assumption that 124 has 3 significant digits, while 120/7 will get you
    '17', not '17.1' since 120 is thought to have 2 significant digits.
    The rounding after the division then uses the remainder and $y to determine
    wether it must round up or down.
 ?  I have no idea which is the right way. That's why I used a slightly more
 ?  simple scheme and tweaked the few failing testcases to match it.

=back

This is how it works now:

=over 2

=item Setting/Accessing

  * You can set the A global via Math::BigInt->accuracy() or
    Math::BigFloat->accuracy() or whatever class you are using.
  * You can also set P globally by using Math::SomeClass->precision() likewise.
  * Globals are classwide, and not inherited by subclasses.
  * to undefine A, use Math::SomeCLass->accuracy(undef);
  * to undefine P, use Math::SomeClass->precision(undef);
  * Setting Math::SomeClass->accuracy() clears automatically
    Math::SomeClass->precision(), and vice versa.
  * To be valid, A must be > 0, P can have any value.
  * If P is negative, this means round to the P'th place to the right of the
    decimal point; positive values mean to the left of the decimal point.
    P of 0 means round to integer.
  * to find out the current global A, take Math::SomeClass->accuracy()
  * to find out the current global P, take Math::SomeClass->precision()
  * use $x->accuracy() respective $x->precision() for the local setting of $x.
  * Please note that $x->accuracy() respecive $x->precision() fall back to the
    defined globals, when $x's A or P is not set.

=item Creating numbers

  * When you create a number, you can give it's desired A or P via:
    $x = Math::BigInt->new($number,$A,$P);
  * Only one of A or P can be defined, otherwise the result is NaN
  * If no A or P is give ($x = Math::BigInt->new($number) form), then the
    globals (if set) will be used. Thus changing the global defaults later on
    will not change the A or P of previously created numbers (i.e., A and P of
    $x will be what was in effect when $x was created)
  * If given undef for A and P, B<no> rounding will occur, and the globals will
    B<not> be used. This is used by subclasses to create numbers without
    suffering rounding in the parent. Thus a subclass is able to have it's own
    globals enforced upon creation of a number by using
    $x = Math::BigInt->new($number,undef,undef):

	use Math::Bigint::SomeSubclass;
	use Math::BigInt;

	Math::BigInt->accuracy(2);
	Math::BigInt::SomeSubClass->accuracy(3);
	$x = Math::BigInt::SomeSubClass->new(1234);	

    $x is now 1230, and not 1200. A subclass might choose to implement
    this otherwise, e.g. falling back to the parent's A and P.

=item Usage

  * If A or P are enabled/defined, they are used to round the result of each
    operation according to the rules below
  * Negative P is ignored in Math::BigInt, since BigInts never have digits
    after the decimal point
  * Math::BigFloat uses Math::BigInts internally, but setting A or P inside
    Math::BigInt as globals should not tamper with the parts of a BigFloat.
    Thus a flag is used to mark all Math::BigFloat numbers as 'never round'

=item Precedence

  * It only makes sense that a number has only one of A or P at a time.
    Since you can set/get both A and P, there is a rule that will practically
    enforce only A or P to be in effect at a time, even if both are set.
    This is called precedence.
  * If two objects are involved in an operation, and one of them has A in
    effect, and the other P, this results in an error (NaN).
  * A takes precendence over P (Hint: A comes before P). If A is defined, it
    is used, otherwise P is used. If neither of them is defined, nothing is
    used, i.e. the result will have as many digits as it can (with an
    exception for fdiv/fsqrt) and will not be rounded.
  * There is another setting for fdiv() (and thus for fsqrt()). If neither of
    A or P is defined, fdiv() will use a fallback (F) of $div_scale digits.
    If either the dividend's or the divisor's mantissa has more digits than
    the value of F, the higher value will be used instead of F.
    This is to limit the digits (A) of the result (just consider what would
    happen with unlimited A and P in the case of 1/3 :-)
  * fdiv will calculate (at least) 4 more digits than required (determined by
    A, P or F), and, if F is not used, round the result
    (this will still fail in the case of a result like 0.12345000000001 with A
    or P of 5, but this can not be helped - or can it?)
  * Thus you can have the math done by on Math::Big* class in three modes:
    + never round (this is the default):
      This is done by setting A and P to undef. No math operation
      will round the result, with fdiv() and fsqrt() as exceptions to guard
      against overflows. You must explicitely call bround(), bfround() or
      round() (the latter with parameters).
      Note: Once you have rounded a number, the settings will 'stick' on it
      and 'infect' all other numbers engaged in math operations with it, since
      local settings have the highest precedence. So, to get SaferRound[tm],
      use a copy() before rounding like this:

        $x = Math::BigFloat->new(12.34);
        $y = Math::BigFloat->new(98.76);
        $z = $x * $y;                           # 1218.6984
        print $x->copy()->fround(3);            # 12.3 (but A is now 3!)
        $z = $x * $y;                           # still 1218.6984, without
                                                # copy would have been 1210!

    + round after each op:
      After each single operation (except for testing like is_zero()), the
      method round() is called and the result is rounded appropriately. By
      setting proper values for A and P, you can have all-the-same-A or
      all-the-same-P modes. For example, Math::Currency might set A to undef,
      and P to -2, globally.

 ?Maybe an extra option that forbids local A & P settings would be in order,
 ?so that intermediate rounding does not 'poison' further math? 

=item Overriding globals

  * you will be able to give A, P and R as an argument to all the calculation
    routines; the second parameter is A, the third one is P, and the fourth is
    R (shift right by one for binary operations like badd). P is used only if
    the first parameter (A) is undefined. These three parameters override the
    globals in the order detailed as follows, i.e. the first defined value
    wins:
    (local: per object, global: global default, parameter: argument to sub)
      + parameter A
      + parameter P
      + local A (if defined on both of the operands: smaller one is taken)
      + local P (if defined on both of the operands: bigger one is taken)
      + global A
      + global P
      + global F
  * fsqrt() will hand its arguments to fdiv(), as it used to, only now for two
    arguments (A and P) instead of one

=item Local settings

  * You can set A and P locally by using $x->accuracy() and $x->precision()
    and thus force different A and P for different objects/numbers.
  * Setting A or P this way immediately rounds $x to the new value.
  * $x->accuracy() clears $x->precision(), and vice versa.

=item Rounding

  * the rounding routines will use the respective global or local settings.
    fround()/bround() is for accuracy rounding, while ffround()/bfround()
    is for precision
  * the two rounding functions take as the second parameter one of the
    following rounding modes (R):
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc'
  * you can set and get the global R by using Math::SomeClass->round_mode()
    or by setting $Math::SomeClass::round_mode
  * after each operation, $result->round() is called, and the result may
    eventually be rounded (that is, if A or P were set either locally,
    globally or as parameter to the operation)
  * to manually round a number, call $x->round($A,$P,$round_mode);
    this will round the number by using the appropriate rounding function
    and then normalize it.
  * rounding modifies the local settings of the number:

        $x = Math::BigFloat->new(123.456);
        $x->accuracy(5);
        $x->bround(4);

    Here 4 takes precedence over 5, so 123.5 is the result and $x->accuracy()
    will be 4 from now on.

=item Default values

  * R: 'even'
  * F: 40
  * A: undef
  * P: undef

=item Remarks

  * The defaults are set up so that the new code gives the same results as
    the old code (except in a few cases on fdiv):
    + Both A and P are undefined and thus will not be used for rounding
      after each operation.
    + round() is thus a no-op, unless given extra parameters A and P

=back

=head1 INTERNALS

The actual numbers are stored as unsigned big integers (with seperate sign).
You should neither care about nor depend on the internal representation; it
might change without notice. Use only method calls like C<< $x->sign(); >>
instead relying on the internal hash keys like in C<< $x->{sign}; >>. 

=head2 MATH LIBRARY

Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:

	use Math::BigInt lib => 'Calc';

You can change this by using:

	use Math::BigInt lib => 'BitVect';

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

	use Math::BigInt lib => 'Foo,Math::BigInt::Bar';

Calc.pm uses as internal format an array of elements of some decimal base
(usually 1e5 or 1e7) with the least significant digit first, while BitVect.pm
uses a bit vector of base 2, most significant bit first. Other modules might
use even different means of representing the numbers. See the respective
module documentation for further details.

=head2 SIGN

The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored seperately.

A sign of 'NaN' is used to represent the result when input arguments are not
numbers or as a result of 0/0. '+inf' and '-inf' represent plus respectively
minus infinity. You will get '+inf' when dividing a positive number by 0, and
'-inf' when dividing any negative number by 0.

=head2 mantissa(), exponent() and parts()

C<mantissa()> and C<exponent()> return the said parts of the BigInt such
that:

        $m = $x->mantissa();
        $e = $x->exponent();
        $y = $m * ( 10 ** $e );
        print "ok\n" if $x == $y;

C<< ($m,$e) = $x->parts() >> is just a shortcut that gives you both of them
in one go. Both the returned mantissa and exponent have a sign.

Currently, for BigInts C<$e> will be always 0, except for NaN, +inf and -inf,
where it will be NaN; and for $x == 0, where it will be 1
(to be compatible with Math::BigFloat's internal representation of a zero as
C<0E1>).

C<$m> will always be a copy of the original number. The relation between $e
and $m might change in the future, but will always be equivalent in a
numerical sense, e.g. $m might get minimized.

=head1 EXAMPLES
 
  use Math::BigInt;

  sub bint { Math::BigInt->new(shift); }

  $x = Math::BigInt->bstr("1234")      	# string "1234"
  $x = "$x";                         	# same as bstr()
  $x = Math::BigInt->bneg("1234");   	# Bigint "-1234"
  $x = Math::BigInt->babs("-12345"); 	# Bigint "12345"
  $x = Math::BigInt->bnorm("-0 00"); 	# BigInt "0"
  $x = bint(1) + bint(2);            	# BigInt "3"
  $x = bint(1) + "2";                	# ditto (auto-BigIntify of "2")
  $x = bint(1);                      	# BigInt "1"
  $x = $x + 5 / 2;                   	# BigInt "3"
  $x = $x ** 3;                      	# BigInt "27"
  $x *= 2;                           	# BigInt "54"
  $x = Math::BigInt->new(0);       	# BigInt "0"
  $x--;                              	# BigInt "-1"
  $x = Math::BigInt->badd(4,5)		# BigInt "9"
  print $x->bsstr();			# 9e+0

Examples for rounding:

  use Math::BigFloat;
  use Test;

  $x = Math::BigFloat->new(123.4567);
  $y = Math::BigFloat->new(123.456789);
  Math::BigFloat->accuracy(4);		# no more A than 4

  ok ($x->copy()->fround(),123.4);	# even rounding
  print $x->copy()->fround(),"\n";	# 123.4
  Math::BigFloat->round_mode('odd');	# round to odd
  print $x->copy()->fround(),"\n";	# 123.5
  Math::BigFloat->accuracy(5);		# no more A than 5
  Math::BigFloat->round_mode('odd');	# round to odd
  print $x->copy()->fround(),"\n";	# 123.46
  $y = $x->copy()->fround(4),"\n";	# A = 4: 123.4
  print "$y, ",$y->accuracy(),"\n";	# 123.4, 4

  Math::BigFloat->accuracy(undef);	# A not important now
  Math::BigFloat->precision(2); 	# P important
  print $x->copy()->bnorm(),"\n";	# 123.46
  print $x->copy()->fround(),"\n";	# 123.46

Examples for converting:

  my $x = Math::BigInt->new('0b1'.'01' x 123);
  print "bin: ",$x->as_bin()," hex:",$x->as_hex()," dec: ",$x,"\n";

=head1 Autocreating constants

After C<use Math::BigInt ':constant'> all the B<integer> decimal, hexadecimal
and binary constants in the given scope are converted to C<Math::BigInt>.
This conversion happens at compile time. 

In particular,

  perl -MMath::BigInt=:constant -e 'print 2**100,"\n"'

prints the integer value of C<2**100>. Note that without conversion of 
constants the expression 2**100 will be calculated as perl scalar.

Please note that strings and floating point constants are not affected,
so that

  	use Math::BigInt qw/:constant/;

	$x = 1234567890123456789012345678901234567890
		+ 123456789123456789;
	$y = '1234567890123456789012345678901234567890'
		+ '123456789123456789';

do not work. You need an explicit Math::BigInt->new() around one of the
operands. You should also quote large constants to protect loss of precision:

	use Math::Bigint;

	$x = Math::BigInt->new('1234567889123456789123456789123456789');

Without the quotes Perl would convert the large number to a floating point
constant at compile time and then hand the result to BigInt, which results in
an truncated result or a NaN.

This also applies to integers that look like floating point constants:

	use Math::BigInt ':constant';

	print ref(123e2),"\n";
	print ref(123.2e2),"\n";

will print nothing but newlines. Use either L<bignum> or L<Math::BigFloat>
to get this to work.

=head1 PERFORMANCE

Using the form $x += $y; etc over $x = $x + $y is faster, since a copy of $x
must be made in the second case. For long numbers, the copy can eat up to 20%
of the work (in the case of addition/subtraction, less for
multiplication/division). If $y is very small compared to $x, the form
$x += $y is MUCH faster than $x = $x + $y since making the copy of $x takes
more time then the actual addition.

With a technique called copy-on-write, the cost of copying with overload could
be minimized or even completely avoided. A test implementation of COW did show
performance gains for overloaded math, but introduced a performance loss due
to a constant overhead for all other operatons.

The rewritten version of this module is slower on certain operations, like
new(), bstr() and numify(). The reason are that it does now more work and
handles more cases. The time spent in these operations is usually gained in
the other operations so that programs on the average should get faster. If
they don't, please contect the author.

Some operations may be slower for small numbers, but are significantly faster
for big numbers. Other operations are now constant (O(1), like bneg(), babs()
etc), instead of O(N) and thus nearly always take much less time. These
optimizations were done on purpose.

If you find the Calc module to slow, try to install any of the replacement
modules and see if they help you. 

=head2 Alternative math libraries

You can use an alternative library to drive Math::BigInt via:

	use Math::BigInt lib => 'Module';

See L<MATH LIBRARY> for more information.

For more benchmark results see L<http://bloodgate.com/perl/benchmarks.html>.

=head2 SUBCLASSING

=head1 Subclassing Math::BigInt

The basic design of Math::BigInt allows simple subclasses with very little
work, as long as a few simple rules are followed:

=over 2

=item *

The public API must remain consistent, i.e. if a sub-class is overloading
addition, the sub-class must use the same name, in this case badd(). The
reason for this is that Math::BigInt is optimized to call the object methods
directly.

=item *

The private object hash keys like C<$x->{sign}> may not be changed, but
additional keys can be added, like C<$x->{_custom}>.

=item *

Accessor functions are available for all existing object hash keys and should
be used instead of directly accessing the internal hash keys. The reason for
this is that Math::BigInt itself has a pluggable interface which permits it
to support different storage methods.

=back

More complex sub-classes may have to replicate more of the logic internal of
Math::BigInt if they need to change more basic behaviors. A subclass that
needs to merely change the output only needs to overload C<bstr()>. 

All other object methods and overloaded functions can be directly inherited
from the parent class.

At the very minimum, any subclass will need to provide it's own C<new()> and can
store additional hash keys in the object. There are also some package globals
that must be defined, e.g.:

  # Globals
  $accuracy = undef;
  $precision = -2;       # round to 2 decimal places
  $round_mode = 'even';
  $div_scale = 40;

Additionally, you might want to provide the following two globals to allow
auto-upgrading and auto-downgrading to work correctly:

  $upgrade = undef;
  $downgrade = undef;

This allows Math::BigInt to correctly retrieve package globals from the 
subclass, like C<$SubClass::precision>.  See t/Math/BigInt/Subclass.pm or
t/Math/BigFloat/SubClass.pm completely functional subclass examples.

Don't forget to 

	use overload;

in your subclass to automatically inherit the overloading from the parent. If
you like, you can change part of the overloading, look at Math::String for an
example.

=head1 UPGRADING

When used like this:

	use Math::BigInt upgrade => 'Foo::Bar';

certain operations will 'upgrade' their calculation and thus the result to
the class Foo::Bar. Usually this is used in conjunction with Math::BigFloat:

	use Math::BigInt upgrade => 'Math::BigFloat';

As a shortcut, you can use the module C<bignum>:

	use bignum;

Also good for oneliners:

	perl -Mbignum -le 'print 2 ** 255'

This makes it possible to mix arguments of different classes (as in 2.5 + 2)
as well es preserve accuracy (as in sqrt(3)).

Beware: This feature is not fully implemented yet.

=head2 Auto-upgrade

The following methods upgrade themselves unconditionally; that is if upgrade
is in effect, they will always hand up their work:

=over 2

=item bsqrt()

=item div()

=item blog()

=back

Beware: This list is not complete.

All other methods upgrade themselves only when one (or all) of their
arguments are of the class mentioned in $upgrade (This might change in later
versions to a more sophisticated scheme):

=head1 BUGS

=over 2

=item Out of Memory!

Under Perl prior to 5.6.0 having an C<use Math::BigInt ':constant';> and 
C<eval()> in your code will crash with "Out of memory". This is probably an
overload/exporter bug. You can workaround by not having C<eval()> 
and ':constant' at the same time or upgrade your Perl to a newer version.

=item Fails to load Calc on Perl prior 5.6.0

Since eval(' use ...') can not be used in conjunction with ':constant', BigInt
will fall back to eval { require ... } when loading the math lib on Perls
prior to 5.6.0. This simple replaces '::' with '/' and thus might fail on
filesystems using a different seperator.  

=back

=head1 CAVEATS

Some things might not work as you expect them. Below is documented what is
known to be troublesome:

=over 1

=item stringify, bstr(), bsstr() and 'cmp'

Both stringify and bstr() now drop the leading '+'. The old code would return
'+3', the new returns '3'. This is to be consistent with Perl and to make
cmp (especially with overloading) to work as you expect. It also solves
problems with Test.pm, it's ok() uses 'eq' internally. 

Mark said, when asked about to drop the '+' altogether, or make only cmp work:

	I agree (with the first alternative), don't add the '+' on positive
	numbers.  It's not as important anymore with the new internal 
	form for numbers.  It made doing things like abs and neg easier,
	but those have to be done differently now anyway.

So, the following examples will now work all as expected:

	use Test;
        BEGIN { plan tests => 1 }
	use Math::BigInt;

	my $x = new Math::BigInt 3*3;
	my $y = new Math::BigInt 3*3;

	ok ($x,3*3);
	print "$x eq 9" if $x eq $y;
	print "$x eq 9" if $x eq '9';
	print "$x eq 9" if $x eq 3*3;

Additionally, the following still works:
	
	print "$x == 9" if $x == $y;
	print "$x == 9" if $x == 9;
	print "$x == 9" if $x == 3*3;

There is now a C<bsstr()> method to get the string in scientific notation aka
C<1e+2> instead of C<100>. Be advised that overloaded 'eq' always uses bstr()
for comparisation, but Perl will represent some numbers as 100 and others
as 1e+308. If in doubt, convert both arguments to Math::BigInt before doing eq:

	use Test;
        BEGIN { plan tests => 3 }
	use Math::BigInt;

	$x = Math::BigInt->new('1e56'); $y = 1e56;
	ok ($x,$y);			# will fail
	ok ($x->bsstr(),$y);		# okay
	$y = Math::BigInt->new($y);
	ok ($x,$y);			# okay

Alternatively, simple use <=> for comparisations, that will get it always
right. There is not yet a way to get a number automatically represented as
a string that matches exactly the way Perl represents it.

=item int()

C<int()> will return (at least for Perl v5.7.1 and up) another BigInt, not a 
Perl scalar:

	$x = Math::BigInt->new(123);
	$y = int($x);				# BigInt 123
	$x = Math::BigFloat->new(123.45);
	$y = int($x);				# BigInt 123

In all Perl versions you can use C<as_number()> for the same effect:

	$x = Math::BigFloat->new(123.45);
	$y = $x->as_number();			# BigInt 123

This also works for other subclasses, like Math::String.

It is yet unlcear whether overloaded int() should return a scalar or a BigInt.

=item length

The following will probably not do what you expect:

	$c = Math::BigInt->new(123);
	print $c->length(),"\n";		# prints 30

It prints both the number of digits in the number and in the fraction part
since print calls C<length()> in list context. Use something like: 
	
	print scalar $c->length(),"\n";		# prints 3 

=item bdiv

The following will probably not do what you expect:

	print $c->bdiv(10000),"\n";

It prints both quotient and remainder since print calls C<bdiv()> in list
context. Also, C<bdiv()> will modify $c, so be carefull. You probably want
to use
	
	print $c / 10000,"\n";
	print scalar $c->bdiv(10000),"\n";  # or if you want to modify $c

instead.

The quotient is always the greatest integer less than or equal to the
real-valued quotient of the two operands, and the remainder (when it is
nonzero) always has the same sign as the second operand; so, for
example,

	  1 / 4  => ( 0, 1)
	  1 / -4 => (-1,-3)
	 -3 / 4  => (-1, 1)
	 -3 / -4 => ( 0,-3)
	-11 / 2  => (-5,1)
	 11 /-2  => (-5,-1)

As a consequence, the behavior of the operator % agrees with the
behavior of Perl's built-in % operator (as documented in the perlop
manpage), and the equation

	$x == ($x / $y) * $y + ($x % $y)

holds true for any $x and $y, which justifies calling the two return
values of bdiv() the quotient and remainder. The only exception to this rule
are when $y == 0 and $x is negative, then the remainder will also be
negative. See below under "infinity handling" for the reasoning behing this.

Perl's 'use integer;' changes the behaviour of % and / for scalars, but will
not change BigInt's way to do things. This is because under 'use integer' Perl
will do what the underlying C thinks is right and this is different for each
system. If you need BigInt's behaving exactly like Perl's 'use integer', bug
the author to implement it ;)

=item infinity handling

Here are some examples that explain the reasons why certain results occur while
handling infinity:

The following table shows the result of the division and the remainder, so that
the equation above holds true. Some "ordinary" cases are strewn in to show more
clearly the reasoning:

	A /  B  =   C,     R so that C *    B +    R =    A
     =========================================================
	5 /   8 =   0,     5 	     0 *    8 +    5 =    5
	0 /   8 =   0,     0	     0 *    8 +    0 =    0
	0 / inf =   0,     0	     0 *  inf +    0 =    0
	0 /-inf =   0,     0	     0 * -inf +    0 =    0
	5 / inf =   0,     5	     0 *  inf +    5 =    5
	5 /-inf =   0,     5	     0 * -inf +    5 =    5
	-5/ inf =   0,    -5	     0 *  inf +   -5 =   -5
	-5/-inf =   0,    -5	     0 * -inf +   -5 =   -5
       inf/   5 =  inf,    0	   inf *    5 +    0 =  inf
      -inf/   5 = -inf,    0      -inf *    5 +    0 = -inf
       inf/  -5 = -inf,    0	  -inf *   -5 +    0 =  inf
      -inf/  -5 =  inf,    0       inf *   -5 +    0 = -inf
	 5/   5 =    1,    0         1 *    5 +    0 =    5
	-5/  -5 =    1,    0         1 *   -5 +    0 =   -5
       inf/ inf =    1,    0         1 *  inf +    0 =  inf
      -inf/-inf =    1,    0         1 * -inf +    0 = -inf
       inf/-inf =   -1,    0        -1 * -inf +    0 =  inf
      -inf/ inf =   -1,    0         1 * -inf +    0 = -inf
	 8/   0 =  inf,    8       inf *    0 +    8 =    8 
       inf/   0 =  inf,  inf       inf *    0 +  inf =  inf 
         0/   0 =  NaN

These cases below violate the "remainder has the sign of the second of the two
arguments", since they wouldn't match up otherwise.

	A /  B  =   C,     R so that C *    B +    R =    A
     ========================================================
      -inf/   0 = -inf, -inf      -inf *    0 +  inf = -inf 
	-8/   0 = -inf,   -8      -inf *    0 +    8 = -8 

=item Modifying and =

Beware of:

        $x = Math::BigFloat->new(5);
        $y = $x;

It will not do what you think, e.g. making a copy of $x. Instead it just makes
a second reference to the B<same> object and stores it in $y. Thus anything
that modifies $x (except overloaded operators) will modify $y, and vice versa.
Or in other words, C<=> is only safe if you modify your BigInts only via
overloaded math. As soon as you use a method call it breaks:

        $x->bmul(2);
        print "$x, $y\n";       # prints '10, 10'

If you want a true copy of $x, use:

        $y = $x->copy();

You can also chain the calls like this, this will make first a copy and then
multiply it by 2:

        $y = $x->copy()->bmul(2);

See also the documentation for overload.pm regarding C<=>.

=item bpow

C<bpow()> (and the rounding functions) now modifies the first argument and
returns it, unlike the old code which left it alone and only returned the
result. This is to be consistent with C<badd()> etc. The first three will
modify $x, the last one won't:

	print bpow($x,$i),"\n"; 	# modify $x
	print $x->bpow($i),"\n"; 	# ditto
	print $x **= $i,"\n";		# the same
	print $x ** $i,"\n";		# leave $x alone 

The form C<$x **= $y> is faster than C<$x = $x ** $y;>, though.

=item Overloading -$x

The following:

	$x = -$x;

is slower than

	$x->bneg();

since overload calls C<sub($x,0,1);> instead of C<neg($x)>. The first variant
needs to preserve $x since it does not know that it later will get overwritten.
This makes a copy of $x and takes O(N), but $x->bneg() is O(1).

With Copy-On-Write, this issue would be gone, but C-o-W is not implemented
since it is slower for all other things.

=item Mixing different object types

In Perl you will get a floating point value if you do one of the following:

	$float = 5.0 + 2;
	$float = 2 + 5.0;
	$float = 5 / 2;

With overloaded math, only the first two variants will result in a BigFloat:

	use Math::BigInt;
	use Math::BigFloat;
	
	$mbf = Math::BigFloat->new(5);
	$mbi2 = Math::BigInteger->new(5);
	$mbi = Math::BigInteger->new(2);

					# what actually gets called:
	$float = $mbf + $mbi;		# $mbf->badd()
	$float = $mbf / $mbi;		# $mbf->bdiv()
	$integer = $mbi + $mbf;		# $mbi->badd()
	$integer = $mbi2 / $mbi;	# $mbi2->bdiv()
	$integer = $mbi2 / $mbf;	# $mbi2->bdiv()

This is because math with overloaded operators follows the first (dominating)
operand, and the operation of that is called and returns thus the result. So,
Math::BigInt::bdiv() will always return a Math::BigInt, regardless whether
the result should be a Math::BigFloat or the second operant is one.

To get a Math::BigFloat you either need to call the operation manually,
make sure the operands are already of the proper type or casted to that type
via Math::BigFloat->new():
	
	$float = Math::BigFloat->new($mbi2) / $mbi;	# = 2.5

Beware of simple "casting" the entire expression, this would only convert
the already computed result:

	$float = Math::BigFloat->new($mbi2 / $mbi);	# = 2.0 thus wrong!

Beware also of the order of more complicated expressions like:

	$integer = ($mbi2 + $mbi) / $mbf;		# int / float => int
	$integer = $mbi2 / Math::BigFloat->new($mbi);	# ditto

If in doubt, break the expression into simpler terms, or cast all operands
to the desired resulting type.

Scalar values are a bit different, since:
	
	$float = 2 + $mbf;
	$float = $mbf + 2;

will both result in the proper type due to the way the overloaded math works.

This section also applies to other overloaded math packages, like Math::String.

One solution to you problem might be L<autoupgrading|upgrading>.

=item bsqrt()

C<bsqrt()> works only good if the result is a big integer, e.g. the square
root of 144 is 12, but from 12 the square root is 3, regardless of rounding
mode.

If you want a better approximation of the square root, then use:

	$x = Math::BigFloat->new(12);
	Math::BigFloat->precision(0);
	Math::BigFloat->round_mode('even');
	print $x->copy->bsqrt(),"\n";		# 4

	Math::BigFloat->precision(2);
	print $x->bsqrt(),"\n";			# 3.46
	print $x->bsqrt(3),"\n";		# 3.464

=item brsft()

For negative numbers in base see also L<brsft|brsft>.

=back

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<Math::BigFloat> and L<Math::Big> as well as L<Math::BigInt::BitVect>,
L<Math::BigInt::Pari> and  L<Math::BigInt::GMP>.
d512 2
a513 4
The package at
L<http://search.cpan.org/search?mode=module&query=Math%3A%3ABigInt> contains
more documentation including a full version history, testcases, empty
subclass files and benchmarks.
d515 1
a515 1
=head1 AUTHORS
d517 1
a517 2
Original code by Mark Biggar, overloaded interface by Ilya Zakharevich.
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001.
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d21 2
a22 1
$VERSION = '1.66';
a27 2
# the following are internal and should never be accessed from the outside
use vars qw/$_trap_nan $_trap_inf/;
d118 7
a124 2
# these are public, but their usage is not recommended, use the accessor
# methods instead
a133 12
# these are internally, and not to be used from the outside

use constant MB_NEVER_ROUND => 0x0001;

$_trap_nan = 0;				# are NaNs ok? set w/ config()
$_trap_inf = 0;				# are infs ok? set w/ config()
my $nan = 'NaN'; 			# constants for easier life

my $CALC = 'Math::BigInt::Calc';	# module to do the low level math
my $IMPORT = 0;				# was import() called yet?
					# used to make require work

d155 2
a156 4
    if ($m !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/)
      {
      require Carp; Carp::croak ("Unknown round mode '$m'");
      }
d159 1
a159 1
  ${"${class}::round_mode"};
d174 1
a174 1
  ${"${class}::upgrade"};
d189 1
a189 1
  ${"${class}::downgrade"};
d195 1
a195 1
  # make Class->div_scale() work
d200 1
a200 4
    if ($_[0] < 0)
      {
      require Carp; Carp::croak ('div_scale must be greater than zero');
      }
d203 1
a203 1
  ${"${class}::div_scale"};
d221 1
a221 18
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $a = $a->numify() if ref($a) && $a->can('numify');

    if (defined $a)
      {
      # also croak on non-numerical
      if (!$a || $a <= 0)
        {
        require Carp;
        Carp::croak ('Argument to accuracy must be greater than zero');
        }
      if (int($a) != $a)
        {
        require Carp; Carp::croak ('Argument to accuracy must be an integer');
        }
      }
d225 3
a227 4
      $x->bround($a) if $a;             # not for undef, 0
      $x->{_a} = $a;                    # set/overwrite, even if not rounded
      $x->{_p} = undef;                 # clear P
      $a = ${"${class}::accuracy"} unless defined $a;   # proper return value
d233 1
a233 1
      ${"${class}::precision"} = undef; # clear P
d235 1
a235 1
    return $a;                          # shortcut
d244 1
a244 1
  }
d257 1
a260 8
    # convert objects to scalars to avoid deep recursion. If object doesn't
    # have numify(), then hopefully it will have overloading for int() and
    # boolean test without wandering into a deep recursion path...
    $p = $p->numify() if ref($p) && $p->can('numify');
    if ((defined $p) && (int($p) != $p))
      {
      require Carp; Carp::croak ('Argument to precision must be an integer');
      }
d264 3
a266 4
      $x->bfround($p) if $p;            # not for undef, 0
      $x->{_p} = $p;                    # set/overwrite, even if not rounded
      $x->{_a} = undef;                 # clear A
      $p = ${"${class}::precision"} unless defined $p;  # proper return value
d272 1
a272 1
      ${"${class}::accuracy"} = undef;  # clear A
d274 1
a274 1
    return $p;                          # shortcut
d283 1
a283 1
  }
d287 1
a287 1
  # return (or set) configuration data as hash ref
d291 1
a291 39
  if (@@_ > 0)
    {
    # try to set given options as arguments from hash

    my $args = $_[0];
    if (ref($args) ne 'HASH')
      {
      $args = { @@_ };
      }
    # these values can be "set"
    my $set_args = {};
    foreach my $key (
     qw/trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale/
     )
      {
      $set_args->{$key} = $args->{$key} if exists $args->{$key};
      delete $args->{$key};
      }
    if (keys %$args > 0)
      {
      require Carp;
      Carp::croak ("Illegal key(s) '",
       join("','",keys %$args),"' passed to $class\->config()");
      }
    foreach my $key (keys %$set_args)
      {
      if ($key =~ /^trap_(inf|nan)\z/)
        {
        ${"${class}::_trap_$1"} = ($set_args->{"trap_$1"} ? 1 : 0);
        next;
        }
      # use a call instead of just setting the $variable to check argument
      $class->$key($set_args->{$key});
      }
    }

  # now return actual configuration

d293 2
a294 2
    lib => $CALC,
    lib_version => ${"${CALC}::VERSION"},
a295 3
    trap_nan => ${"${class}::_trap_nan"},
    trap_inf => ${"${class}::_trap_inf"},
    version => ${"${class}::VERSION"},
d297 2
a298 3
  foreach my $key (qw/
     upgrade downgrade precision accuracy round_mode div_scale
     /)
d300 1
a300 1
    $cfg->{$key} = ${"${class}::$key"};
d416 1
a416 1
      # remove sign without touching wanted to make it work with constants
a418 4
    # force to string version (otherwise Pari is unhappy about overflowed
    # constants, for instance)
    # not good, BigInt shouldn't need to know about alternative libs:
    # $ref = \"$$ref" if $CALC eq 'Math::BigInt::Pari';
d442 2
a443 4
    if ($_trap_nan)
      {
      require Carp; Carp::croak("$wanted is not a number in $class");
      }
a463 4
      if ($_trap_nan)
        {
        require Carp; Carp::croak("$wanted not an integer in $class");
        }
d471 1
a471 1
      #print "diff > 0 $$miv\n";
a479 4
      if ($_trap_nan)
        {
        require Carp; Carp::croak("$wanted not an integer in $class");
        }
a490 4
        if ($_trap_nan)
          {
          require Carp; Carp::croak("$wanted not an integer in $class");
          }
a514 6
  no strict 'refs';
  if (${"${class}::_trap_nan"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to NaN in $class\::bnan()");
    }
d517 1
a543 6
  no strict 'refs';
  if (${"${class}::_trap_inf"})
    {
    require Carp;
    Carp::croak ("Tried to set $self to +-inf in $class\::binfn()");
    }
d546 1
d575 1
a575 1
  
d612 1
a612 1

d666 3
a668 1
  my $sign = 'e+'; # e can only be positive
d691 1
a691 2

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;
a712 2
  # !!!!!!! If you change this, remember to change round(), too! !!!!!!!!!!

a715 3
 
  # returns ($self) or ($self,$a,$p,$r) - sets $self to NaN of both A and P
  # were requested/defined (locally or globally or both)
d724 1
a724 1
  return ($self) if exists $self->{_f} && ($self->{_f} & MB_NEVER_ROUND) != 0;
a750 3

  # A == 0 is useless, so undef it to signal no rounding
  $a = undef if defined $a && $a == 0;
d756 1
a756 1
  return ($self->bnan()) if defined $a && defined $p;		# error
d759 3
a761 6
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/)
    {
    require Carp; Carp::croak ("Unknown round mode '$r'");
    }

  ($self,$a,$p,$r);
d778 1
a778 1
  return ($self) if exists $self->{_f} && ($self->{_f} & MB_NEVER_ROUND) != 0;
a805 3
  # A == 0 is useless, so undef it to signal no rounding
  $a = undef if defined $a && $a == 0;
  
d813 1
a813 4
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc)$/)
    {
   
    }
a873 3
  return $upgrade->bcmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

a915 3
  return $upgrade->bacmp($x,$y) if defined $upgrade &&
    ((!$x->isa($self)) || (!$y->isa($self)));

d1082 1
a1082 1
  return $upgrade->blog($upgrade->new($x),$base,$a,$p,$r) if defined $upgrade;
d1195 1
a1195 1
  $sign = '+' if !defined $sign || $sign ne '-';
d1359 27
a1388 2
  $r[3] = $y;					# no push!

d1392 5
d1405 1
a1405 1
    $x->round(@@r) if !exists $x->{_f} || ($x->{_f} & MB_NEVER_ROUND) == 0;
d1409 1
a1409 1
      $rem = $y->copy()->bsub($rem) if $xsign ne $y->{sign}; # one of them '-'
d1415 1
a1415 2
    $rem->round(@@r) if !exists $rem->{_f} || ($rem->{_f} & MB_NEVER_ROUND) == 0;
    return ($x,$rem);
d1421 1
a1421 1
  $x->round(@@r) if !exists $x->{_f} || ($x->{_f} & MB_NEVER_ROUND) == 0;
d1484 1
a1484 1
  # Modular inverse.  given a number which is (hopefully) relatively
d1486 1
a1486 1
  # alogrithm.  If the number is not relatively prime to the modulus
d1491 1
a1491 1
  # objectify is costly, so avoid it
d1495 1
a1495 1
    }
d1500 3
a1502 3
        if ($y->{sign} ne '+'                           # -, NaN, +inf, -inf
         || $x->is_zero()                               # or num == 0
         || $x->{sign} !~ /^[+-]$/                      # or num NaN, inf, -inf
d1510 2
a1511 6
    my $sign;
    ($x->{value},$sign) = $CALC->_modinv($x->{value},$y->{value});
    $x->bnan() if !defined $x->{value};                 # in case no GCD found
    return $x if !defined $sign;                        # already real result
    $x->{sign} = $sign;                                 # flip/flop see below
    $x->bmod($y);                                       # calc real result
d1514 1
d1524 4
a1527 18
  # Euclid's Algorithm (calculate GCD of ($a,$b) in $a and also calculate
  # two values in $u and $u1, we use only $u1 afterwards)
  my $sign = 1;                                         # flip-flop
  while (!$b->is_zero())                                # found GCD if $b == 0
    {
    # the original algorithm had:
    # ($u, $u1) = ($u1, $u->bsub($u1->copy()->bmul($q))); # step #2
    # The following creates exact the same sequence of numbers in $u1,
    # except for the sign ($u1 is now always positive). Since formerly
    # the sign of $u1 was alternating between '-' and '+', the $sign
    # flip-flop will take care of that, so that at the end of the loop
    # we have the real sign of $u1. Keeping numbers positive gains us
    # speed since badd() is faster than bsub() and makes it possible
    # to have the algorithmn in Calc for even more speed.

    ($u, $u1) = ($u1, $u->badd($u1->copy()->bmul($q))); # step #2
    $sign = - $sign;                                    # flip sign

d1531 3
a1533 3
  # If the gcd is not 1, then return NaN! It would be pointless to
  # have called bgcd to check this first, because we would then be
  # performing the same Euclidean Algorithm *twice*.
d1536 3
a1538 5
  $u1->bneg() if $sign != 1;                            # need to flip?

  $u1->bmod($y);                                        # calc result
  $x->{value} = $u1->{value};                           # and copy over to $x
  $x->{sign} = $u1->{sign};                             # to modify in place
d1584 1
a1584 1
  my $len = CORE::length($expbin);
d1633 1
a1633 1

d1689 1
a1689 1
  my $len = CORE::length($y_bin);
a1986 1
  # calculate square root of $x
d1991 3
a1993 3
  return $x->bnan() if $x->{sign} !~ /^\+/;	# -x or -inf or NaN => NaN
  return $x if $x->{sign} eq '+inf';		# sqrt(+inf) == inf
  return $x->round(@@r) if $x->is_zero() || $x->is_one();	# 0,1 => 0,1
d2008 1
a2008 1
  $x->blsft($l,10) if $l != 0;			# first guess: 1.('0' x (l/2))
d2012 1
a2012 2
  my $lastlast = $self->bzero();
  #my $lastlast = $x+$two;
d2015 3
a2017 3
    $lastlast = $last; $last = $x->copy(); 
    $x->badd($y / $x); 
    $x->bdiv($two);
d2019 1
a2019 1
  $x->bdec() if $x * $x > $y;				# overshot?
a2022 76
sub broot
  {
  # calculate $y'th root of $x
 
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  $y = $self->new(2) unless defined $y;

  # objectify is costly, so avoid it
  if ((!ref($x)) || (ref($x) ne ref($y)))
    {
    ($self,$x,$y,@@r) = $self->objectify(2,@@_);
    }

  return $x if $x->modify('broot');

  # NaN handling: $x ** 1/0, x or y NaN, or y inf/-inf or y == 0
  return $x->bnan() if $x->{sign} !~ /^\+/ || $y->is_zero() ||
         $y->{sign} !~ /^\+$/;

  return $x->round(@@r)
    if $x->is_zero() || $x->is_one() || $x->is_inf() || $y->is_one();

  return $upgrade->new($x)->broot($upgrade->new($y),@@r) if defined $upgrade;

  if ($CALC->can('_root'))
    {
    $x->{value} = $CALC->_root($x->{value},$y->{value});
    return $x->round(@@r);
    }

  return $x->bsqrt() if $y->bacmp(2) == 0;	# 2 => square root

  # since we take at least a cubic root, and only 8 ** 1/3 >= 2 (==2):
  return $x->bone('+',@@r) if $x < 8;		# $x=2..7 => 1

  my $num = $x->numify();

  if ($num <= 1000000)
    {
    $x = $self->new( int($num ** (1 / $y->numify()) ));
    return $x->round(@@r);
    }

  # if $n is a power of two, we can repeatedly take sqrt($X) and find the
  # proper result, because sqrt(sqrt($x)) == root($x,4)
  # See Calc.pm for more details
  my $b = $y->as_bin();
  if ($b =~ /0b1(0+)/)
    {
    my $count = CORE::length($1);	# 0b100 => len('00') => 2
    my $cnt = $count;			# counter for loop
    my $shift = $self->new(6);
    $x->blsft($shift);			# add some zeros (even amount)
    while ($cnt-- > 0)
      {
      # 'inflate' $X by adding more zeros
      $x->blsft($shift);
      # calculate sqrt($x), $x is now a bit too big, again. In the next
      # round we make even bigger, again.
      $x->bsqrt($x);
      }
    # $x is still to big, so truncate result
    $x->brsft($shift);
    }
  else
    {
    # Should compute a guess of the result (by rule of thumb), then improve it
    # via Newton's method or something similiar.
    # XXX TODO
    warn ('broot() not fully implemented in BigInt.');
    }
  return $x->round(@@r);
  }

a2135 5
  # convert $scale to a scalar in case it is an object (put's a limit on the
  # number length, but this would already limited by memory constraints), makes
  # it faster
  $scale = $scale->numify() if ref ($scale);

d2152 1
a2152 1

d2190 1
a2190 1
    $pad = $len, $$xs = '0' x $pad if $scale < 0;	# tlr: whack 0.51=>1.0	
d2324 1
a2324 1
  #print "Now in objectify, my class is today $a[0], count = $count\n";
d2361 1
a2361 4
  if (! wantarray)
    {
    require Carp; Carp::croak ("$class objectify needs list context");
    }
d2427 1
a2427 5
  if ($CALC eq '')
    {
    require Carp;
    Carp::croak ("Couldn't load any math lib, not even the default");
    }
d2545 1
a2545 1
  # .2 	   # 1_2_3.4_5_6 # 1.4E1_2_3  # 1e3 # +.2     # 0e999	
d2547 1
a2547 1
  #return if $$x =~ /[Ee].*[Ee]/;	# more than one E => error
d2549 1
a2549 2
  my ($m,$e,$last) = split /[Ee]/,$$x;
  return if defined $last;		# last defined => 1e2E3 or others
a2550 1

d2559 2
a2560 2
    my ($mi,$mf,$lastf) = split /\./,$m;
    return if defined $lastf;		# last defined => 1.2.3 or others
a2568 2
      # handle the 0e999 case here
      $ev = 0 if $miv eq '0' && $mfv eq '';
d2591 1
a2600 2
    return '0x0' if $x->is_zero();

d2628 1
a2637 1
    return '0b0' if $x->is_zero();
a2706 6
  # or make it faster: install (optional) Math::BigInt::GMP
  # and always use (it will fall back to pure Perl if the
  # GMP library is not installed):

  use Math::BigInt lib => 'GMP';

d2716 19
a2734 2
  # Testing (don't modify their arguments)
  # (return true if the condition is met, otherwise false)
d2736 14
a2749 35
  $x->is_zero();	# if $x is +0
  $x->is_nan();		# if $x is NaN
  $x->is_one();		# if $x is +1
  $x->is_one('-');	# if $x is -1
  $x->is_odd();		# if $x is odd
  $x->is_even();	# if $x is even
  $x->is_positive();	# if $x >= 0
  $x->is_negative();	# if $x <  0
  $x->is_inf(sign);	# if $x is +inf, or -inf (sign is default '+')
  $x->is_int();		# if $x is an integer (not a float)

  # comparing and digit/sign extration
  $x->bcmp($y);		# compare numbers (undef,<0,=0,>0)
  $x->bacmp($y);	# compare absolutely (undef,<0,=0,>0)
  $x->sign();		# return the sign, either +,- or NaN
  $x->digit($n);	# return the nth digit, counting from right
  $x->digit(-$n);	# return the nth digit, counting from left

  # The following all modify their first argument. If you want to preserve
  # $x, use $z = $x->copy()->bXXX($y); See under L<CAVEATS> for why this is
  # neccessary when mixing $a = $b assigments with non-overloaded math.

  $x->bzero();		# set $x to 0
  $x->bnan();		# set $x to NaN
  $x->bone();		# set $x to +1
  $x->bone('-');	# set $x to -1
  $x->binf();		# set $x to inf
  $x->binf('-');	# set $x to -inf

  $x->bneg();		# negation
  $x->babs();		# absolute value
  $x->bnorm();		# normalize (no-op in BigInt)
  $x->bnot();		# two's complement (bit wise not)
  $x->binc();		# increment $x by 1
  $x->bdec();		# decrement $x by 1
d2751 15
a2765 15
  $x->badd($y);		# addition (add $y to $x)
  $x->bsub($y);		# subtraction (subtract $y from $x)
  $x->bmul($y);		# multiplication (multiply $x by $y)
  $x->bdiv($y);		# divide, set $x to quotient
			# return (quo,rem) or quo if scalar

  $x->bmod($y);		   # modulus (x % y)
  $x->bmodpow($exp,$mod);  # modular exponentation (($num**$exp) % $mod))
  $x->bmodinv($mod);	   # the inverse of $x in the given modulus $mod

  $x->bpow($y);		   # power of arguments (x ** y)
  $x->blsft($y);	   # left shift
  $x->brsft($y);	   # right shift 
  $x->blsft($y,$n);	   # left shift, by base $n (like 10)
  $x->brsft($y,$n);	   # right shift, by base $n (like 10)
d2767 15
a2781 18
  $x->band($y);		   # bitwise and
  $x->bior($y);		   # bitwise inclusive or
  $x->bxor($y);		   # bitwise exclusive or
  $x->bnot();		   # bitwise not (two's complement)

  $x->bsqrt();		   # calculate square-root
  $x->broot($y);	   # $y'th root of $x (e.g. $y == 3 => cubic root)
  $x->bfac();		   # factorial of $x (1*2*3*4*..$x)

  $x->round($A,$P,$mode);  # round to accuracy or precision using mode $mode
  $x->bround($N);          # accuracy: preserve $N digits
  $x->bfround($N);         # round to $Nth digit, no-op for BigInts

  # The following do not modify their arguments in BigInt (are no-ops),
  # but do so in BigFloat:

  $x->bfloor();		   # return integer less or equal than $x
  $x->bceil();		   # return integer greater or equal than $x
d2785 2
a2786 2
  bgcd(@@values);	   # greatest common divisor (no OO style)
  blcm(@@values);	   # lowest common multiplicator (no OO style)
d2788 9
a2796 9
  $x->length();		   # return number of digits in number
  ($x,$f) = $x->length();  # length of number and length of fraction part,
			   # latter is always 0 digits long for BigInt's

  $x->exponent();	   # return exponent as BigInt
  $x->mantissa();	   # return (signed) mantissa as BigInt
  $x->parts();		   # return (mantissa,exponent) as BigInt
  $x->copy();		   # make a true copy of $x (unlike $y = $x;)
  $x->as_number();	   # return as BigInt (in BigInt: same as copy())
d2798 5
a2802 5
  # conversation to string (do not modify their argument)
  $x->bstr();		   # normalized string
  $x->bsstr();		   # normalized string in scientific notation
  $x->as_hex();		   # as signed hexadecimal string with prefixed 0x
  $x->as_bin();		   # as signed binary string with prefixed 0b
d2804 1
d2807 7
a2813 9
  $x->precision();	   # return P of $x (or global, if P of $x undef)
  $x->precision($n);	   # set P of $x to $n
  $x->accuracy();	   # return A of $x (or global, if A of $x undef)
  $x->accuracy($n);	   # set A $x to $n

  # Global methods
  Math::BigInt->precision(); # get/set global P for all BigInt objects
  Math::BigInt->accuracy();  # get/set global A for all BigInt objects
  Math::BigInt->config();    # return hash containing configuration
d2827 4
a2830 1
=item Input
d2832 3
a2834 2
Input values to these routines may be any string, that looks like a number
and results in an integer, including hexadecimal and binary numbers.
d2836 1
a2836 3
Scalars holding numbers may also be passed, but note that non-integer numbers
may already have lost precision due to the conversation to float. Quote
your input if you want BigInt to see all the digits.
d2838 2
a2839 2
	$x = Math::BigInt->new(12345678890123456789);	# bad
	$x = Math::BigInt->new('12345678901234567890');	# good
d2841 4
a2844 1
You can include one underscore between any two digits.
d2847 1
a2847 1
Non-integer values result in NaN.
d2849 2
a2850 2
Currently, Math::BigInt::new() defaults to 0, while Math::BigInt::new('')
results in 'NaN'.
d2852 1
a2852 1
C<bnorm()> on a BigInt object is now effectively a no-op, since the numbers 
d2854 1
a2854 1
object from the input.
d2868 3
a2870 4
Each of the methods below (except config(), accuracy() and precision())
accepts three additional parameters. These arguments $A, $P and $R are
accuracy, precision and round_mode. Please see the section about
L<ACCURACY and PRECISION> for more information.
a2876 1
	print Math::BigInt->config()->{lib},"\n";
d2879 1
a2879 35
loaded etc. The following hash keys are currently filled in with the
appropriate information.

	key		Description
			Example
	============================================================
	lib		Name of the Math library
			Math::BigInt::Calc
	lib_version 	Version of 'lib'
			0.30
	class		The class of config you just called
			Math::BigInt
	upgrade		To which class numbers are upgraded
			Math::BigFloat
	downgrade	To which class numbers are downgraded
			undef
	precision	Global precision
			undef
	accuracy	Global accuracy
			undef
	round_mode	Global round mode
			even
	version		version number of the class you used
			1.61
	div_scale	Fallback acccuracy for div
			40

The following values can be set by passing C<config()> a reference to a hash:

	trap_inf trap_nan
        upgrade downgrade precision accuracy round_mode div_scale

Example:
	
	$new_cfg = Math::BigInt->config( { trap_inf => 1, precision => 5 } );
d2884 1
a2884 3
	CLASS->accuracy(5);		# global for all members of CLASS
	$A = $x->accuracy();		# read out
	$A = CLASS->accuracy();		# read out
d2887 2
a2888 3
results have. 

Please see the section about L<ACCURACY AND PRECISION> for further details.
a2908 39
Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

=head2 precision

	$x->precision(-2);		# local for $x, round right of the dot
	$x->precision(2);		# ditto, but round left of the dot
	CLASS->accuracy(5);		# global for all members of CLASS
	CLASS->precision(-5);		# ditto
	$P = CLASS->precision();	# read out
	$P = $x->precision();		# read out

Set or get the global or local precision, aka how many digits the result has
after the dot (or where to round it when passing a positive number). In
Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot.

Please see the section about L<ACCURACY AND PRECISION> for further details.

Value must be greater than zero. Pass an undef value to disable it:

	$x->precision(undef);
	Math::BigInt->precision(undef);

Returns the current precision. For C<$x->precision()> it will return either the
local precision of $x, or if not defined, the global. This means the return
value represents the accuracy that will be in effect for $x:

	$y = Math::BigInt->new(1234567);	# unrounded
	print Math::BigInt->precision(4),"\n";	# set 4, print 4
	$x = Math::BigInt->new(123456);		# will be automatically rounded

Note: Works also for subclasses like Math::BigFloat. Each class has it's own
globals separated from Math::BigInt, but it is possible to subclass
Math::BigInt and make the globals of the subclass aliases to the ones from
Math::BigInt.

d2938 1
a2938 1
Creates a new BigInt object from a scalar or another BigInt object. The
a2941 2
See L<Input> for more info on accepted input formats.

a3017 2
In BigInt, all numbers except C<NaN>, C<+inf> and C<-inf> are integers.

d3058 1
a3058 1
	$x->bnorm();			# normalize (no-op)
d3062 1
a3062 1
	$x->bnot();			# two's complement (bit wise not)
d3066 1
a3066 1
	$x->binc();			# increment x by 1
d3070 1
a3070 1
	$x->bdec();			# decrement x by 1
d3074 1
a3074 1
	$x->badd($y);			# addition (add $y to $x)
d3078 1
a3078 1
	$x->bsub($y);			# subtraction (subtract $y from $x)
d3082 1
a3082 1
	$x->bmul($y);			# multiplication (multiply $x by $y)
d3086 2
a3087 2
	$x->bdiv($y);			# divide, set $x to quotient
					# return (quo,rem) or quo if scalar
d3091 1
a3091 1
	$x->bmod($y);			# modulus (x % y)
d3095 1
a3095 1
	num->bmodinv($mod);		# modular inverse
d3103 1
a3103 2
	$num->bmodpow($exp,$mod);	# modular exponentation
					# ($num**$exp % $mod)
d3109 1
a3109 1
	$num ** $exp % $mod
d3116 1
a3116 1
	bmodpow($num, -1, $mod)
d3120 1
a3120 1
	bmodinv($num, $mod)
d3124 1
a3124 1
	$x->bpow($y);			# power of arguments (x ** y)
d3128 2
a3129 2
	$x->blsft($y);		# left shift
	$x->blsft($y,$n);	# left shift, in base $n (like 10)
d3133 2
a3134 2
	$x->brsft($y);		# right shift 
	$x->brsft($y,$n);	# right shift, in base $n (like 10)
d3138 1
a3138 1
	$x->band($y);			# bitwise and
d3142 1
a3142 1
	$x->bior($y);			# bitwise inclusive or
d3146 1
a3146 1
	$x->bxor($y);			# bitwise exclusive or
d3150 1
a3150 1
	$x->bnot();			# bitwise not (two's complement)
d3154 1
a3154 1
	$x->bsqrt();			# calculate square-root
d3158 1
a3158 1
	$x->bfac();			# factorial of $x (1*2*3*4*..$x)
d3162 1
a3162 4
	$x->round($A,$P,$round_mode);
	
Round $x to accuracy C<$A> or precision C<$P> using the round mode
C<$round_mode>.
d3166 1
a3166 1
	$x->bround($N);               # accuracy: preserve $N digits
d3170 1
a3170 1
	$x->bfround($N);              # round to $Nth digit, no-op for BigInts
d3188 1
a3188 1
	bgcd(@@values);		# greatest common divisor (no OO style)
d3192 1
a3192 1
	blcm(@@values);		# lowest common multiplicator (no OO style)
d3217 1
a3217 1
	$x->parts();		# return (mantissa,exponent) as BigInt
d3221 1
a3221 1
	$x->copy();		# make a true copy of $x (unlike $y = $x;)
d3225 1
a3225 1
	$x->as_number();	# return as BigInt (in BigInt: same as copy())
d3229 1
a3229 1
	$x->bstr();		# return normalized string
d3233 1
a3233 1
	$x->bsstr();		# normalized string in scientific notation
d3237 1
a3237 1
	$x->as_hex();		# as signed hexadecimal string with prefixed 0x
d3241 1
a3241 1
	$x->as_bin();		# as signed binary string with prefixed 0b
d3455 1
a3455 1
	use Math::BigInt::SomeSubclass;
d3661 2
a3662 2
  $x = Math::BigInt->bneg("1234");   	# BigInt "-1234"
  $x = Math::BigInt->babs("-12345"); 	# BigInt "12345"
d3730 1
a3730 1
	use Math::BigInt;
a3899 5
=item broot() does not work

The broot() function in BigInt may only work for small values. This will be
fixed in a later version.

d4207 1
a4207 2
One solution to you problem might be autoupgrading|upgrading. See the
pragmas L<bignum>, L<bigint> and L<bigrat> for an easy way to do this.
d4213 1
a4213 1
mode. The reason is that the result is always truncated to an integer.
d4239 2
a4240 5
L<Math::BigFloat>, L<Math::BigRat> and L<Math::Big> as well as
L<Math::BigInt::BitVect>, L<Math::BigInt::Pari> and  L<Math::BigInt::GMP>.

The pragmas L<bignum>, L<bigint> and L<bigrat> also might be of interest
because they solve the autoupgrading/downgrading issue, at least partly.
d4250 1
a4250 6
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001, 2002
and still at it in 2003.

Many people contributed in one or more ways to the final beast, see the file
CREDITS for an (uncomplete) list. If you miss your name, please drop me a
mail. Thank you!
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d21 1
a21 1
$VERSION = '1.68';
d24 5
a28 5
@@EXPORT_OK = qw( objectify bgcd blcm); 
# _trap_inf and _trap_nan are internal and should never be accessed from the
# outside
use vars qw/$round_mode $accuracy $precision $div_scale $rnd_mode 
	    $upgrade $downgrade $_trap_nan $_trap_inf/;
d32 4
a35 3
# it reversed (like $x = 2 * $y), then the third paramater is true.
# In some cases (like add, $x = $x + 2 is the same as $x = 2 + $x) this makes
# no difference, but in some cases it does.
d46 8
d78 1
a78 7
# make cos()/sin()/exp() "work" with BigInt's or subclasses
'cos'	=>	sub { cos($_[0]->numify()) }, 
'sin'	=>	sub { sin($_[0]->numify()) }, 
'exp'	=>	sub { exp($_[0]->numify()) }, 
'atan2'	=>	sub { atan2($_[0]->numify(),$_[1]) }, 

'log'	=>	sub { $_[0]->copy()->blog($_[1]); }, 
d85 10
a94 6
# for sub it is a bit tricky to keep b: b-a => -a+b
'-'	=>	sub { my $c = $_[0]->copy; $_[2] ?
                   $c->bneg()->badd($_[1]) :
                   $c->bsub( $_[1]) },
'+'	=>	sub { $_[0]->copy()->badd($_[1]); },
'*'	=>	sub { $_[0]->copy()->bmul($_[1]); },
d96 2
a97 27
'/'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bdiv($_[0]) : $_[0]->copy->bdiv($_[1]);
  }, 
'%'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bmod($_[0]) : $_[0]->copy->bmod($_[1]);
  }, 
'**'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bpow($_[0]) : $_[0]->copy->bpow($_[1]);
  }, 
'<<'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->blsft($_[0]) : $_[0]->copy->blsft($_[1]);
  }, 
'>>'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->brsft($_[0]) : $_[0]->copy->brsft($_[1]);
  }, 
'&'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->band($_[0]) : $_[0]->copy->band($_[1]);
  }, 
'|'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bior($_[0]) : $_[0]->copy->bior($_[1]);
  }, 
'^'	=>	sub { 
   $_[2] ? ref($_[0])->new($_[1])->bxor($_[0]) : $_[0]->copy->bxor($_[1]);
  }, 

# can modify arg of ++ and --, so avoid a copy() for speed, but don't
# use $_[0]->bone(), it would modify $_[0] to be 1!
d104 3
a106 3
  # v5.6.1 dumps on this: return !$_[0]->is_zero() || undef;		    :-(
  my $t = undef;
  $t = 1 if !$_[0]->is_zero();
d132 1
a132 1
sub MB_NEVER_ROUND () { 0x0001; }
a138 2
					# default is Calc.pm
my %CAN;				# cache for $CALC->can(...)
a141 3
my $EMU_LIB = 'Math/BigInt/CalcEmu.pm';	# emulate low-level math
my $EMU = 'Math::BigInt::CalcEmu';	# emulate low-level math

d150 1
a150 10
BEGIN
  { 
  # tie to enable $rnd_mode to work transparently
  tie $rnd_mode, 'Math::BigInt'; 

  # set up some handy alias names
  *as_int = \&as_number;
  *is_pos = \&is_positive;
  *is_neg = \&is_negative;
  }
a748 1
      # call like: $x->bone($sign,$a,$p,$r);
d775 2
a776 3
  #$m->bstr() . 'e+' . $e->bstr(); 	# e can only be positive in BigInt
  # 'e+' because E can only be positive in BigInt
  $m->bstr() . 'e+' . ${$CALC->_str($e->{value})}; 
d791 1
a791 1
  $es.${$CALC->_str($x->{value})};
d811 1
a811 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_); 
d937 1
a937 1
    require Carp; Carp::croak ("Unknown round mode '$r'");
d956 1
a956 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d1027 1
a1027 1
  $CALC->_acmp($y->{value},$x->{value});	# swaped acmp (lib returns 0,1,-1)
d1071 1
a1071 1
  return $upgrade->badd($upgrade->new($x),$upgrade->new($y),@@r) if defined $upgrade &&
d1093 1
a1093 1
  my ($sx, $sy) = ( $x->{sign}, $y->{sign} ); 		# get signs
d1098 1
d1105 1
d1112 1
d1118 1
d1120 1
d1129 1
a1129 1
  # (BINT or num_str, BINT or num_str) return BINT
d1178 1
a1178 1
  $x->badd($self->bone(),$a,$p,$r);		# badd does round
d1184 1
a1184 1
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
d1187 3
a1189 1
  if ($x->{sign} eq '-')
a1190 1
    # < 0
d1192 7
a1198 2
    } 
  else
d1200 3
a1202 12
    return $x->badd($self->bone('-'),@@r) unless $x->{sign} eq '+'; # inf/NaN
    # >= 0
    if ($CALC->_is_zero($x->{value}))
      {
      # == 0
      $x->{value} = $CALC->_one(); $x->{sign} = '-';		# 0 => -1
      }
    else
      {
      # > 0
      $x->{value} = $CALC->_dec($x->{value});
      }
d1204 3
a1206 3
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
  }
d1210 4
a1213 10
  # calculate $x = $a ** $base + $b and return $a (e.g. the log() to base
  # $base of $x)

  # set up parameters
  my ($self,$x,$base,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$base,@@r) = objectify(2,$class,@@_);
    }
d1215 1
a1215 17
  # inf, -inf, NaN, <0 => NaN
  return $x->bnan()
   if $x->{sign} ne '+' || $base->{sign} ne '+';
  
  return $upgrade->blog($upgrade->new($x),$base,@@r) if 
    defined $upgrade && (ref($x) ne $upgrade || ref($base) ne $upgrade);

  if ($CAN{log_int})
    {
    my ($rc,$exact) = $CALC->_log_int($x->{value},$base->{value});
    return $x->bnan() unless defined $rc;
    $x->{value} = $rc;
    return $x->round(@@r);
    }

  require $EMU_LIB;
  __emu_blog($self,$x,$base,@@r);
d1217 1
a1217 1

d1247 1
a1247 1
  if ($CAN{gcd})
d1276 1
a1276 1
  $x->binc()->bneg();			# binc already does round
a1278 1
##############################################################################
a1279 1
# we don't need $self, so undef instead of ref($_[0]) make it slightly faster
d1284 1
d1294 1
a1294 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d1296 2
a1297 1
  $x->{sign} eq $nan ? 1 : 0;
d1303 5
a1307 1
  my ($self,$x,$sign) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
d1309 1
a1309 1
  if (defined $sign)
d1311 2
a1312 3
    $sign = '[+-]inf' if $sign eq '';	# +- doesn't matter, only that's inf
    $sign = "[$1]inf" if $sign =~ /^([+-])(inf)?$/;	# extract '+' or '-'
    return $x->{sign} =~ /^$sign$/ ? 1 : 0;
d1314 3
a1316 1
  $x->{sign} =~ /^[+-]inf$/ ? 1 : 0;		# only +-inf is infinity
d1321 3
a1323 1
  # return true if arg (BINT or num_str) is +1, or -1 if sign is given
d1335 1
d1345 1
d1355 1
d1358 2
a1359 1
  $x->{sign} =~ /^\+/ ? 1 : 0;		# +inf is also positive, but NaN not
d1365 1
d1368 2
a1369 1
  $x->{sign} =~ /^-/ ? 1 : 0; 		# -inf is also negative, but NaN not
d1375 2
a1376 1
  # always true for BigInt, but different for BigFloats
d1553 1
a1553 1
  if ($CAN{mod})
d1564 1
a1574 2
  # disable upgrade temporarily, otherwise endless loop due to bdiv()
  local $upgrade = undef;
d1610 1
a1610 1
  if ($CAN{modinv})
d1614 4
a1617 4
    return $x->bnan() if !defined $x->{value};		# in case no GCD found
    return $x if !defined $sign;			# already real result
    $x->{sign} = $sign;					# flip/flop see below
    $x->bmod($y);					# calc real result
d1620 2
d1623 38
a1660 2
  require $EMU_LIB;
  __emu_bmodinv($self,$x,$y,@@r);
d1688 1
a1688 1
  if ($CAN{modpow})
d1695 21
a1715 2
  require $EMU_LIB;
  __emu_bmodpow($self,$num,$exp,$mod,@@r);
d1723 2
a1724 1
  # compute factorial number from $x, modify $x in place
d1729 2
a1730 2
  return $x if $x->{sign} eq '+inf';		# inf => inf
  return $x->bnan() if $x->{sign} ne '+';	# NaN, <0 etc => NaN
d1732 1
a1732 1
  if ($CAN{fac})
d1738 9
a1746 2
  require $EMU_LIB;
  __emu_bfac($self,$x,@@r);
d1771 2
a1772 3

  # cases 0 ** Y, X ** 0, X ** 1, 1 ** Y are handled by Calc or Emu

d1781 2
a1782 1
  return $x->bnan() if $y->{sign} eq '-' && !$x->is_one();
d1784 1
a1784 1
  if ($CAN{pow})
a1786 1
    $x->{sign} = '+' if $CALC->_is_zero($y->{value});
d1791 28
a1818 2
  require $EMU_LIB;
  __emu_bpow($self,$x,$y,@@r);
d1840 1
a1840 1
  my $t; $t = $CALC->_lsft($x->{value},$y->{value},$n) if $CAN{lsft};
d1846 1
a1846 1
  $x->bmul( $self->bpow($n, $y, @@r), @@r );
a1901 1
    # x < 0, n == 2, y == 1
d1905 1
a1905 1
  my $t; $t = $CALC->_rsft($x->{value},$y->{value},$n) if $CAN{rsft};
d1932 1
d1935 1
d1937 4
a1940 2
  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;
d1942 1
a1942 1
  if ($CAN{and} && $sx == 1 && $sy == 1)
d1947 16
a1962 5
  
  if ($CAN{signed_and})
    {
    $x->{value} = $CALC->_signed_and($x->{value},$y->{value},$sx,$sy);
    return $x->round(@@r);
d1964 2
a1965 3
 
  require $EMU_LIB;
  __emu_band($self,$x,$y,$sx,$sy,@@r);
d1987 1
d1989 4
a1992 2
  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;
a1993 2
  # the sign of X follows the sign of X, e.g. sign of Y irrelevant for bior()
  
d1995 1
a1995 1
  if ($CAN{or} && $sx == 1 && $sy == 1)
d2001 15
a2015 5
  # if lib can do negative values, let it handle this
  if ($CAN{signed_or})
    {
    $x->{value} = $CALC->_signed_or($x->{value},$y->{value},$sx,$sy);
    return $x->round(@@r);
d2017 2
a2018 3

  require $EMU_LIB;
  __emu_bior($self,$x,$y,$sx,$sy,@@r);
d2037 2
d2040 1
d2042 4
a2045 2
  my $sx = $x->{sign} eq '+' ? 1 : -1;
  my $sy = $y->{sign} eq '+' ? 1 : -1;
d2048 1
a2048 1
  if ($CAN{xor} && $sx == 1 && $sy == 1)
d2053 16
a2068 6
  
  # if lib can do negative values, let it handle this
  if ($CAN{signed_xor})
    {
    $x->{value} = $CALC->_signed_xor($x->{value},$y->{value},$sx,$sy);
    return $x->round(@@r);
d2070 2
a2071 3

  require $EMU_LIB;
  __emu_bxor($self,$x,$y,$sx,$sy,@@r);
d2076 1
a2076 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d2079 1
a2079 1
  wantarray ? ($e,0) : $e;
d2092 1
a2092 1
  # return the amount of trailing zeros in $x (as scalar)
d2098 1
a2098 1
  return $CALC->_zeros($x->{value}) if $CAN{zeros};
d2115 1
d2119 1
a2119 1
  if ($CAN{sqrt})
d2125 19
a2143 2
  require $EMU_LIB;
  __emu_bsqrt($self,$x,@@r);
d2158 1
a2158 1
    ($self,$x,$y,@@r) = objectify(2,$self || $class,@@_);
d2172 1
a2172 1
  if ($CAN{root})
d2178 42
a2219 2
  require $EMU_LIB;
  __emu_broot($self,$x,$y,@@r);
d2229 2
a2230 2
    my $s = $x->{sign}; $s =~ s/^[+-]//;  # NaN, -inf,+inf => NaN or inf
    return $self->new($s);
d2232 4
a2235 3
  return $self->bone() if $x->is_zero();

  $self->new($x->_trailing_zeros());
d2245 1
a2245 2
    # for NaN, +inf, -inf: keep the sign
    return $self->new($x->{sign});
d2247 2
a2248 2
  my $m = $x->copy(); delete $m->{_p}; delete $m->{_a};
  # that's a bit inefficient:
d2257 1
a2257 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d2259 1
a2259 1
  ($x->mantissa(),$x->exponent());
a2269 1

d2271 2
a2272 2

  return $x if !defined $scale || $x->modify('bfround');	# no-op
d2275 5
a2279 1
  $x->bround( $x->length()-$scale, $mode) if $scale > 0;
d2281 1
d2289 3
a2291 2
  # internal, used by bround()
  my ($x,$pad,$xs) = @@_;
d2299 1
d2301 2
a2302 1
  $r =~ /[^0]/ ? 1 : 0;
d2307 2
a2308 2
  # Exists to make life easier for switch between MBF and MBI (should we
  # autoload fxxx() like MBF does for bxxx()?)
d2310 1
a2310 1
  $x->bround(@@_);
d2421 3
a2423 2
  # return integer less or equal then number; no-op since it's already integer
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
d2430 3
a2432 2
  # return integer greater or equal then number; no-op since it's already int
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
d2437 2
a2438 7
sub as_number
  {
  # An object might be asked to return itself as bigint on certain overloaded
  # operations, this does exactly this, so that sub classes can simple inherit
  # it or override with their own integer conversion routine.
  $_[0]->copy();
  }
d2440 1
a2440 1
sub as_hex
d2442 5
a2446 14
  # return as hex string, with prefixed 0x
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $s = '';
  $s = $x->{sign} if $x->{sign} eq '-';
  if ($CAN{as_hex})
    {
    return $s . ${$CALC->_as_hex($x->{value})};
    }

  require $EMU_LIB;
  __emu_as_hex(ref($x),$x,$s);
d2449 1
a2449 1
sub as_bin
d2451 18
a2468 7
  # return as binary string, with prefixed 0b
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';
  if ($CAN{as_bin})
d2470 2
a2471 1
    return $s . ${$CALC->_as_bin($x->{value})};
d2473 1
a2473 4

  require $EMU_LIB;
  __emu_as_bin(ref($x),$x,$s);

a2475 3
##############################################################################
# private stuff (internal use only)

d2577 1
a2577 1
  $IMPORT++;				# remember we did import()
d2584 2
a2585 3
      overload::constant 
	integer => sub { $self->new(shift) },
      	binary => sub { $self->new(shift) };
d2637 1
a2637 17
    Carp::croak ("Couldn't load any math lib, not even 'Calc.pm'");
    }
  _fill_can_cache();
  }

sub _fill_can_cache
  {
  # fill $CAN with the results of $CALC->can(...)

  %CAN = ();
  for my $method (qw/gcd mod modinv modpow fac pow lsft rsft 
	and signed_and or signed_or xor signed_xor
	from_hex as_hex from_bin as_bin
	zeros sqrt root log_int log
	/)
    {
    $CAN{$method} = $CALC->can("_$method") ? 1 : 0;
d2657 1
a2657 1
  if ($CAN{'from_hex'})
d2664 1
a2664 1
    my $mul = Math::BigInt->bone();
d2666 2
a2667 2
    my $len = CORE::length($$hs)-2;		# minus 2 for 0x
    $len = int($len/4);				# 4-digit parts, w/o '0x'
d2696 1
a2696 1
  if ($CAN{'from_bin'})
d2702 1
a2702 1
    my $mul = Math::BigInt->bone();
d2704 1
a2704 1
    my $len = CORE::length($$bs)-2;		# minus 2 for 0b
d2773 1
a2773 1
    return if defined $lastf;		# lastf defined => 1.2.3 or others
d2790 85
d2907 1
a2907 1
# We use a fast constant sub() here, to avoid costly calls. Subclasses
d2947 2
a2948 2
  $x->is_pos();		# if $x >= 0
  $x->is_neg();		# if $x <  0
d3025 1
a3025 2
  $x->as_int();		   # return as BigInt (in BigInt: same as copy())
  $x->numify();		   # return as scalar (might overflow!)
d3032 1
a3032 1

d3064 1
a3064 1
your input if you want BigInt to see all the digits:
d3075 1
a3075 5
results in 'NaN'. This might change in the future, so use always the following
explicit forms to get a zero or NaN:

	$zero = Math::BigInt->bzero(); 
	$nan = Math::BigInt->bnan(); 
d3078 1
a3078 1
are always stored in normalized form. If passed a string, creates a BigInt 
d3112 1
a3112 1
	lib		Name of the low-level math library
d3114 1
a3114 1
	lib_version 	Version of low-level math library (see 'lib')
d3116 1
a3116 1
	class		The class name of config() you just called
d3118 1
a3118 1
	upgrade		To which class math operations might be upgraded
d3120 1
a3120 1
	downgrade	To which class math operations might be downgraded
a3131 4
	trap_nan	If true, traps creation of NaN via croak()
			1
	trap_inf	If true, traps creation of +inf/-inf via croak()
			1
d3303 1
a3303 1
=head2 is_pos()/is_neg()
d3305 2
a3306 2
	$x->is_pos();			# true if >= 0
	$x->is_neg();			# true if <  0
a3313 5
C<is_positive()> and C<is_negative()> are aliase to C<is_pos()> and
C<is_neg()>, respectively. C<is_positive()> and C<is_negative()> were
introduced in v1.36, while C<is_pos()> and C<is_neg()> were only introduced
in v1.68.

d3344 1
a3344 1
=head2 digit
d3346 1
a3346 3
	$x->digit($n);		# return the nth digit, counting from right

If C<$n> is negative, returns the digit counting from left.
d3369 1
a3369 7
	$x->bnot();			

Two's complement (bit wise not). This is equivalent to

	$x->binc()->bneg();

but faster.
d3419 1
a3419 1
because it is much faster - it reduces internal variables into
d3534 1
a3534 3
=head2 as_int

	$x->as_int();	
d3536 1
a3536 5
Returns $x as a BigInt (truncated towards zero). In BigInt this is the same as
C<copy()>. 

C<as_number()> is an alias to this method. C<as_number> was introduced in
v1.22, while C<as_int()> was only introduced in v1.68.
d3538 1
a3538 3
=head2 bstr

	$x->bstr();
d3540 1
a3540 1
Returns a normalized string represantation of C<$x>.
d3558 1
a3558 1
operation, as well as manually.
d3716 1
a3716 1
    the + sign (oops) and actually gets 2 for '+100' and 4 for '+101'. Oops
d3733 3
a3735 4
  * You can set the A global via C<< Math::BigInt->accuracy() >> or
    C<< Math::BigFloat->accuracy() >> or whatever class you are using.
  * You can also set P globally by using C<< Math::SomeClass->precision() >>
    likewise.
d3737 4
a3740 4
  * to undefine A, use C<< Math::SomeCLass->accuracy(undef); >>
  * to undefine P, use C<< Math::SomeClass->precision(undef); >>
  * Setting C<< Math::SomeClass->accuracy() >> clears automatically
    C<< Math::SomeClass->precision() >>, and vice versa.
d3745 5
a3749 7
  * to find out the current global A, use C<< Math::SomeClass->accuracy() >>
  * to find out the current global P, use C<< Math::SomeClass->precision() >>
  * use C<< $x->accuracy() >> respective C<< $x->precision() >> for the local
    setting of C<< $x >>.
  * Please note that C<< $x->accuracy() >> respecive C<< $x->precision() >>
    return eventually defined global A or P, when C<< $x >>'s A or P is not
    set.
d3764 1
a3764 1
    C<< $x = Math::BigInt->new($number,undef,undef) >>:
d3782 3
a3784 3
  * Math::BigFloat uses Math::BigInt internally, but setting A or P inside
    Math::BigInt as globals does not tamper with the parts of a BigFloat.
    A flag is used to mark all Math::BigFloat numbers as 'never round'.
d3789 3
a3791 2
    If you set either A or P on one object, or globally, the other one will
    be automatically cleared.
d3794 4
a3797 4
  * A takes precendence over P (Hint: A comes before P).
    If neither of them is defined, nothing is used, i.e. the result will have
    as many digits as it can (with an exception for fdiv/fsqrt) and will not
    be rounded.
d3808 1
a3808 1
  * Thus you can have the math done by on Math::Big* class in two modi:
d3857 1
a3857 2
  * You can set A or P locally by using C<< $x->accuracy() >> or
    C<< $x->precision() >>
d3860 1
a3860 1
  * C<< $x->accuracy() >> clears C<< $x->precision() >>, and vice versa.
d3870 3
a3872 3
  * you can set/get the global R by using C<< Math::SomeClass->round_mode() >>
    or by setting C<< $Math::SomeClass::round_mode >>
  * after each operation, C<< $result->round() >> is called, and the result may
d3875 1
a3875 1
  * to manually round a number, call C<< $x->round($A,$P,$round_mode); >>
d3914 1
a3914 1
C<Math::BigInt::Calc>. This is equivalent to saying:
d3927 5
a3931 11
Since Math::BigInt::GMP is in almost all cases faster than Calc (especially in
cases involving really big numbers, where it is B<much> faster), and there is
no penalty if Math::BigInt::GMP is not installed, it is a good idea to always
use the following:

	use Math::BigInt lib => 'GMP';

Different low-level libraries use different formats to store the
numbers. You should not depend on the number having a specific format.

See the respective math library module documentation for further details.
d3955 8
a3962 7
Currently, for BigInts C<$e> is always 0, except for NaN, +inf and -inf,
where it is C<NaN>; and for C<$x == 0>, where it is C<1> (to be compatible
with Math::BigFloat's internal representation of a zero as C<0E1>).

C<$m> is currently just a copy of the original number. The relation between
C<$e> and C<$m> will stay always the same, though their real values might
change.
d4071 1
a4071 2
to a constant overhead for all other operatons. So Math::BigInt does currently
not COW.
d4073 5
a4077 5
The rewritten version of this module (vs. v0.01) is slower on certain
operations, like C<new()>, C<bstr()> and C<numify()>. The reason are that it
does now more work and handles much more cases. The time spent in these
operations is usually gained in the other math operations so that code on
the average should get (much) faster. If they don't, please contact the author.
d4080 3
a4082 3
for big numbers. Other operations are now constant (O(1), like C<bneg()>,
C<babs()> etc), instead of O(N) and thus nearly always take much less time.
These optimizations were done on purpose.
d4239 1
a4239 1
=item bstr(), bsstr() and 'cmp'
d4241 4
a4244 5
Both C<bstr()> and C<bsstr()> as well as automated stringify via overload now
drop the leading '+'. The old code would return '+3', the new returns '3'.
This is to be consistent with Perl and to make C<cmp> (especially with
overloading) to work as you expect. It also solves problems with C<Test.pm>,
because it's C<ok()> uses 'eq' internally. 
d4246 1
a4246 2
Mark Biggar said, when asked about to drop the '+' altogether, or make only
C<cmp> work:
d4276 1
a4276 2
as 1e+308. If in doubt, convert both arguments to Math::BigInt before 
comparing them as strings:
d4288 3
a4290 3
Alternatively, simple use C<< <=> >> for comparisations, this will get it
always right. There is not yet a way to get a number automatically represented
as a string that matches exactly the way Perl represents it.
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d21 1
a21 1
$VERSION = '1.70';
d158 1
d161 1
a161 2
my %WARN;				# warn only once for low-level libs
my %CAN;				# cache for $CALC->can(...)
d163 1
d287 3
a289 3
      $x->bround($a) if $a;		# not for undef, 0
      $x->{_a} = $a;			# set/overwrite, even if not rounded
      delete $x->{_p};			# clear P
d294 3
a296 2
      ${"${class}::accuracy"} = $a;	# set global A
      ${"${class}::precision"} = undef;	# clear global P
d298 1
a298 1
    return $a;				# shortcut
d334 3
a336 3
      $x->bfround($p) if $p;		# not for undef, 0
      $x->{_p} = $p;			# set/overwrite, even if not rounded
      delete $x->{_a};			# clear A
d341 3
a343 2
      ${"${class}::precision"} = $p;	# set global P
      ${"${class}::accuracy"} = undef;	# clear global A
d345 1
a345 1
    return $p;				# shortcut
d459 40
a498 5

  $self->{sign} = $x->{sign};
  $self->{value} = $CALC->_copy($x->{value});
  $self->{_a} = $x->{_a} if defined $x->{_a};
  $self->{_p} = $x->{_p} if defined $x->{_p};
d526 1
a526 1

d530 1
a530 6
      my $t = $wanted; $t =~ s/^[+-]//;
      $self->{value} = $CALC->_new($t);
      }
    else
      {
      $self->{value} = $CALC->_new($wanted);
d532 5
d556 1
a556 1
  my ($mis,$miv,$mfv,$es,$ev) = _split($wanted);
d629 1
a629 1
  $self->{value} = $CALC->_new($$miv) if $self->{sign} =~ /^[+-]$/;
d666 1
a666 1
  $self;
d701 1
a701 1
  $self;
d810 1
a810 1
  $m->bstr() . 'e+' . $CALC->_str($e->{value}); 
d825 1
a825 1
  $es.$CALC->_str($x->{value});
d1086 1
a1086 2
    return 1 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} !~ /^[+-]inf$/;
    return -1;
d1171 3
a1173 2
  return $upgrade->new($x)->bsub($upgrade->new($y),@@r) if defined $upgrade &&
   ((!$x->isa($self)) || (!$y->isa($self)));
d1250 1
a1250 1
    ($self,$x,$base,@@r) = objectify(1,$class,@@_);
a1251 2
  
  return $x if $x->modify('blog');
d1255 4
a1258 1
   if $x->{sign} ne '+' || (defined $base && $base->{sign} ne '+');
d1260 7
a1266 2
  return $upgrade->blog($upgrade->new($x),$base,@@r) if 
    defined $upgrade;
d1268 2
a1269 4
  my ($rc,$exact) = $CALC->_log_int($x->{value},$base->{value});
  return $x->bnan() unless defined $rc;		# not possible to take log?
  $x->{value} = $rc;
  $x->round(@@r);
d1285 1
a1285 1
    $x = __PACKAGE__->new($y);
d1287 1
a1287 6
  my $self = ref($x);
  while (@@_) 
    {
    my $y = shift; $y = $self->new($y) if !ref ($y);
    $x = __lcm($x,$y);
    } 
d1300 12
a1311 4
  my $x = $y->copy()->babs();			# keep arguments
  return $x->bnan() if $x->{sign} !~ /^[+-]$/;	# x NaN?

  while (@@_)
d1313 5
a1317 4
    $y = shift; $y = $self->new($y) if !ref($y);
    next if $y->is_zero();
    return $x->bnan() if $y->{sign} !~ /^[+-]$/;	# y NaN?
    $x->{value} = $CALC->_gcd($x->{value},$y->{value}); last if $x->is_one();
d1319 1
a1319 1
  $x;
d1452 3
a1454 3

  return $upgrade->bmul($x,$upgrade->new($y),@@r)
   if defined $upgrade && !$y->isa($self);
d1593 1
a1593 3
  # calc new sign and in case $y == +/- 1, return $x
  $x->{value} = $CALC->_mod($x->{value},$y->{value});
  if (!$CALC->_is_zero($x->{value}))
d1595 13
a1607 3
    my $xsign = $x->{sign};
    $x->{sign} = $y->{sign};
    if ($xsign ne $y->{sign})
d1609 1
a1609 2
      my $t = $CALC->_copy($x->{value});		# copy $x
      $x->{value} = $CALC->_sub($y->{value},$t,1); 	# $y-$x
d1611 2
d1614 5
a1618 1
   else
d1620 1
a1620 1
    $x->{sign} = '+';				# dont leave -0
a1621 1
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
d1651 13
a1663 7
  my $sign;
  ($x->{value},$sign) = $CALC->_modinv($x->{value},$y->{value});
  return $x->bnan() if !defined $x->{value};		# in case no GCD found
  return $x if !defined $sign;			# already real result
  $x->{sign} = $sign;				# flip/flop see below
  $x->bmod($y);					# calc real result
  $x;
d1691 9
a1699 3
  # $mod is positive, sign on $exp is ignored, result also positive
  $num->{value} = $CALC->_modpow($num->{value},$exp->{value},$mod->{value});
  $num;
d1715 8
a1722 2
  $x->{value} = $CALC->_fac($x->{value});
  $x->round(@@r);
d1750 6
a1755 6
  my $new_sign = '+';
  $new_sign = $y->is_odd() ? '-' : '+' if ($x->{sign} ne '+'); 

  # 0 ** -7 => ( 1 / (0 ** 7)) => 1 / 0 => +inf 
  return $x->binf() 
    if $y->{sign} eq '-' && $x->{sign} eq '+' && $CALC->_is_zero($x->{value});
d1758 9
a1766 1
  return $x->bnan() if $y->{sign} eq '-' && !$CALC->_is_one($x->{value});
d1768 2
a1769 5
  $x->{value} = $CALC->_pow($x->{value},$y->{value});
  $x->{sign} = $new_sign;
  $x->{sign} = '+' if $CALC->_is_zero($y->{value});
  $x->round(@@r) if !exists $x->{_f} || $x->{_f} & MB_NEVER_ROUND == 0;
  $x;
d1791 7
a1797 2
  $x->{value} = $CALC->_lsft($x->{value},$y->{value},$n);
  $x->round(@@r);
d1857 9
a1865 2
  $x->{value} = $CALC->_rsft($x->{value},$y->{value},$n);
  $x->round(@@r);
d1890 1
a1890 1
  if ($sx == 1 && $sy == 1)
d1922 2
d1932 1
a1932 1
  if ($sx == 1 && $sy == 1)
d1971 1
a1971 1
  if ($sx == 1 && $sy == 1)
d1999 1
a1999 1
  my ($self,$x,$n) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
a2000 1
  $n = $n->numify() if ref($n);
d2010 3
a2012 1
  return 0 if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf etc
d2014 4
a2017 1
  $CALC->_zeros($x->{value});		# must handle odd values, 0 etc
d2032 8
a2039 2
  $x->{value} = $CALC->_sqrt($x->{value});
  $x->round(@@r);
d2068 8
a2075 2
  $x->{value} = $CALC->_root($x->{value},$y->{value});
  $x->round(@@r);
d2125 1
a2125 1
  my $x = shift; my $self = ref($x) || $x; $x = $self->new($x) unless ref $x;
d2134 2
a2135 2
  delete $x->{_a};	# delete to save memory
  $x->{_p} = $scale;	# store new _p
d2208 1
a2208 1
  $digit_round = '0'; $digit_round = substr($xs,$pl,1) if $pad <= $len;
d2210 1
a2210 1
  $digit_after = '0'; $digit_after = substr($xs,$pl,1) if $pad > 0;
d2232 1
a2232 1
    substr($xs,-$pad,$pad) = '0' x $pad;
d2243 1
a2243 1
    $pad = $len, $xs = '0' x $pad if $scale < 0;	# tlr: whack 0.51=>1.0	
d2250 2
a2251 2
      $c = substr($xs,-$pad,1) + 1; $c = '0' if $c eq '10';
      substr($xs,-$pad,1) = $c; $pad++;
d2254 1
a2254 1
    $xs = '1'.$xs if $c == 0;
d2301 7
a2307 1
  $s . $CALC->_as_hex($x->{value});
d2318 8
a2325 1
  return $s . $CALC->_as_bin($x->{value});
d2488 1
a2488 47
    if ($@@ eq '')
      {
      my $ok = 1;
      # loaded it ok, see if the api_version() is high enough
      if ($lib->can('api_version') && $lib->api_version() >= 1.0)
	{
	$ok = 0;
	# api_version matches, check if it really provides anything we need
        for my $method (qw/
		one two ten
		str num
		add mul div sub dec inc
		acmp len digit is_one is_zero is_even is_odd
		is_two is_ten
		new copy check from_hex from_bin as_hex as_bin zeros
		rsft lsft xor and or
		mod sqrt root fac pow modinv modpow log_int gcd
	 /)
          {
	  if (!$lib->can("_$method"))
	    {
	    if (($WARN{$lib}||0) < 2)
	      {
	      require Carp;
	      Carp::carp ("$lib is missing method '_$method'");
	      $WARN{$lib} = 1;		# still warn about the lib
	      }
            $ok++; last; 
	    }
          }
	}
      if ($ok == 0)
	{
	$CALC = $lib;
        last;			# found a usable one, break
	}
      else
	{
	if (($WARN{$lib}||0) < 2)
	  {
	  my $ver = eval "\$$lib\::VERSION";
	  require Carp;
	  Carp::carp ("Cannot load outdated $lib v$ver, please upgrade");
	  $WARN{$lib} = 2;		# never warn again
	  }
        }
      }
d2495 1
a2495 1
  _fill_can_cache();		# for emulating lower math lib functions
d2503 5
a2507 1
  for my $method (qw/ signed_and or signed_or xor signed_xor /)
d2521 2
a2522 2
  $hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
  $hs =~ s/([0-9a-fA-F])_([0-9a-fA-F])/$1$2/g;	
d2524 1
a2524 1
  return $x->bnan() if $hs !~ /^[\-\+]?0x[0-9A-Fa-f]+$/;
d2526 1
a2526 1
  my $sign = '+'; $sign = '-' if $hs =~ /^-/;
d2528 23
a2550 2
  $hs =~ s/^[+-]//;						# strip sign
  $x->{value} = $CALC->_from_hex($hs);
d2562 30
a2591 8
  $bs =~ s/([01])_([01])/$1$2/g;	
  $bs =~ s/([01])_([01])/$1$2/g;	
  return $x->bnan() if $bs !~ /^[+-]?0b[01]+$/;

  my $sign = '+'; $sign = '-' if $bs =~ /^\-/;
  $bs =~ s/^[+-]//;						# strip sign

  $x->{value} = $CALC->_from_bin($bs);
d2605 3
a2607 3
  $x =~ s/^\s*([-]?)0*([0-9])/$1$2/g;	# will not strip '  .2'
  $x =~ s/^\s+//;			# but this will			
  $x =~ s/\s+$//g;			# strip white space at end
d2610 1
a2610 1
  if ($x =~ /^[+-]?\d+\z/)
d2612 2
a2613 2
    $x =~ s/^([+-])0*([0-9])/$2/; my $sign = $1 || '+';
    return (\$sign, \$x, \'', \'', \0);
d2617 1
a2617 1
  return if $x !~ /^[+-]?(\.?[0-9]|0b[0-1]|0x[0-9a-fA-F])/;
d2619 2
a2620 2
  return __from_hex($x) if $x =~ /^[\-\+]?0x/;	# hex string
  return __from_bin($x) if $x =~ /^[\-\+]?0b/;	# binary string
d2623 2
a2624 2
  $x =~ s/(\d)_(\d)/$1$2/g;
  $x =~ s/(\d)_(\d)/$1$2/g;		# do twice for 1_2_3
d2630 3
a2632 1
  my ($m,$e,$last) = split /[Ee]/,$x;
d2673 17
a2689 1
  $x * $ty / bgcd($x,$ty);
a2715 4
  my $str = '1234567890';
  my @@values = (64,74,18);
  my $n = 1; my $sign = '-';

a2717 1
  $y = $x->copy();			# make a true copy
d2736 1
a2736 1
  $x->is_inf($sign);	# if $x is +inf, or -inf (sign is default '+')
d2790 2
a2791 2
  $x->bround($n);	   # accuracy: preserve $n digits
  $x->bfround($n);	   # round to $nth digit, no-op for BigInts
d2801 2
a2802 4
  # greatest common divisor (no OO style)
  my $gcd = Math::BigInt::bgcd(@@values);
  # lowest common multiplicator (no OO style)
  my $lcm = Math::BigInt::blcm(@@values);	
d2805 1
a2805 1
  ($xl,$f) = $x->length(); # length of number and length of fraction part,
d4399 2
a4400 2
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2003
and still at it in 2004.
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d21 1
a21 1
$VERSION = '1.73';
a57 3
'<<='	=>	sub { $_[0]->blsft($_[1]); },
'>>='	=>	sub { $_[0]->brsft($_[1]); },

d82 1
a82 1
# for subtract it's a bit tricky to not modify b: b-a => -a+b
d84 1
a84 1
                   $c->bneg()->badd( $_[1]) :
d670 1
a670 1
  $self = __PACKAGE__ if !defined $self;
d761 1
a761 1
  my $x = shift; my $class = ref($x) || $x; $x = $class->new(shift) if !ref($x); 
d778 1
a778 1
  my $x = shift; my $class = ref($x) || $x; $x = $class->new(shift) if !ref($x); 
d892 1
a892 2
  # leave bigfloat parts alone (that is only used in BigRat for now and can be
  # removed once we rewrote BigRat))
d945 1
a945 2
  # bround() or bfround() already callled bnorm() if necc.
  $self;
a1142 8
  require Scalar::Util;
  if (Scalar::Util::refaddr($x) == Scalar::Util::refaddr($y)) 
    {
    # if we get the same variable twice, the result must be zero (the code
    # below fails in that case)
    return $x->bzero(@@r) if $x->{sign} =~ /^[+-]$/;
    return $x->bnan();          # NaN, -inf, +inf
    }
d1243 1
a1243 1
    $x = $class->new($y);
d1261 1
a1261 1
  $y = $class->new($y) if !ref($y);
a1664 51
  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    if (($x->{sign} =~ /^[+-]inf$/) && ($y->{sign} =~ /^[+-]inf$/))
      {
      # +-inf ** +-inf
      return $x->bnan();
      }
    # +-inf ** Y
    if ($x->{sign} =~ /^[+-]inf/)
      {
      # +inf ** 0 => NaN
      return $x->bnan() if $y->is_zero();
      # -inf ** -1 => 1/inf => 0
      return $x->bzero() if $y->is_one('-') && $x->is_negative();

      # +inf ** Y => inf
      return $x if $x->{sign} eq '+inf';

      # -inf ** Y => -inf if Y is odd
      return $x if $y->is_odd();
      return $x->babs();
      }
    # X ** +-inf

    # 1 ** +inf => 1
    return $x if $x->is_one();
    
    # 0 ** inf => 0
    return $x if $x->is_zero() && $y->{sign} =~ /^[+]/;

    # 0 ** -inf => inf
    return $x->binf() if $x->is_zero();

    # -1 ** -inf => NaN
    return $x->bnan() if $x->is_one('-') && $y->{sign} =~ /^[-]/;

    # -X ** -inf => 0
    return $x->bzero() if $x->{sign} eq '-' && $y->{sign} =~ /^[-]/;

    # -1 ** inf => NaN
    return $x->bnan() if $x->{sign} eq '-';

    # X ** inf => inf
    return $x->binf() if $y->{sign} =~ /^[+]/;
    # X ** -inf => 0
    return $x->bzero();
    }

d1669 2
d2030 2
a2031 2
  # internal, used by bround() to scan for non-zeros after a '5'
  my ($x,$pad,$xs,$len) = @@_;
d2033 2
a2034 1
  return 0 if $len == 1;		# "5" is trailed by invisible zeros
d2038 3
a2040 2
  # use the string form to check whether only '0's follow or not
  substr ($xs,-$follow) =~ /[^0]/ ? 1 : 0;
d2090 2
a2091 2
  # do not use digit(), it is very costly for binary => decimal
  # getting the entire string is also costly, but we need to do it only once
d2109 1
a2109 1
    ($x->_scan_for_nonzero($pad,$xs,$len) == 0)		&&
d2121 2
a2122 2
    substr($xs,-$pad,$pad) = '0' x $pad;		# replace with '00...'
    $put_back = 1;					# need to put back
d2131 1
a2131 1
    $put_back = 1;					# need to put back
d2146 1
a2146 1
  $x->{value} = $CALC->_new($xs) if $put_back == 1;	# put back, if needed
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d21 4
a24 5
$VERSION = '1.77';

@@ISA = qw(Exporter);
@@EXPORT_OK = qw(objectify bgcd blcm); 

d56 1
a57 1
'**='	=>	sub { $_[0]->bpow($_[1]); },
a63 1
# we might need '==' and '!=' to get things like "NaN == NaN" right
d66 1
a66 1
                      $_[0]->bcmp($_[1]); },
d76 1
a76 7
'atan2'	=>	sub { $_[2] ?
			atan2($_[1],$_[0]->numify()) :
			atan2($_[0]->numify(),$_[1]) },

# are not yet overloadable
#'hex'	=>	sub { print "hex"; $_[0]; }, 
#'oct'	=>	sub { print "oct"; $_[0]; }, 
d87 2
a88 2
			$c->bneg()->badd( $_[1]) :
			$c->bsub( $_[1]) },
d140 2
a141 2
# These vars are public, but their direct usage is not recommended, use the
# accessor methods instead
d151 3
a153 1
# These are internally, and not to be used from the outside at all
d159 2
a160 2
my $CALC = 'Math::BigInt::FastCalc';	# module to do the low level math
					# default is FastCalc.pm
a164 1
my %CALLBACKS;				# callbacks to notify on lib loads
d215 2
a216 1
    return ${"${class}::upgrade"} = $_[0];
d230 2
a231 1
    return ${"${class}::downgrade"} = $_[0];
d248 1
a248 1
    ${"${class}::div_scale"} = $_[0];
d302 1
a302 1
  my $a;
d304 1
a304 1
  $a = $x->{_a} if ref($x);
d306 2
a307 2
  $a = ${"${class}::accuracy"} if !defined $a;
  $a;
d348 1
a348 1
  my $p;
d350 1
a350 1
  $p = $x->{_p} if ref($x);
d352 2
a353 2
  $p = ${"${class}::precision"} if !defined $p;
  $p;
d422 5
a426 11
  my ($x,$scale,$mode) = @@_;

  $scale = $x->{_a} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::accuracy' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  ($scale,$mode);
d433 5
a437 11
  my ($x,$scale,$mode) = @@_;
  
  $scale = $x->{_p} unless defined $scale;

  no strict 'refs';
  my $class = ref($x);

  $scale = ${ $class . '::precision' } unless defined $scale;
  $mode = ${ $class . '::round_mode' } unless defined $mode;

  ($scale,$mode);
d458 1
a458 1
  my $self = bless {}, $c;
d514 1
a514 1
  if ($wanted =~ /^[+-]?inf\z/)
d516 3
a518 2
    $self->{sign} = $wanted;		# set a default sign for bstr()
    return $self->binf($wanted);
d649 1
a649 1
    Carp::croak ("Tried to set $self to +-inf in $class\::binf()");
d764 2
a765 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_); 
d781 2
a782 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_); 
d835 3
d895 4
d965 1
a965 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d977 1
a977 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d981 2
a982 2
  # for +0 dont negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $CALC->_is_zero($x->{value}));
d1120 2
a1121 1
  $x->round(@@r);
d1142 5
a1146 1
  return $x->round(@@r) if $y->is_zero();
d1148 2
a1149 6
  # To correctly handle the lone special case $x->bsub($x), we note the sign
  # of $x, then flip the sign from $y, and if the sign of $x did change, too,
  # then we caught the special case:
  my $xsign = $x->{sign};
  $y->{sign} =~ tr/+\-/-+/; 	# does nothing for NaN
  if ($xsign ne $x->{sign})
d1151 3
a1153 2
    # special case of $x->bsub($x) results in 0
    return $x->bzero(@@r) if $xsign =~ /^[+-]$/;
d1156 1
d1171 2
a1172 1
    return $x->round($a,$p,$r);
d1178 2
a1179 1
    return $x->round($a,$p,$r);
d1193 1
a1193 1
    # x already < 0
d1198 1
a1198 1
    return $x->badd($self->bone('-'),@@r) unless $x->{sign} eq '+'; 	# inf or NaN
d1211 2
a1212 1
  $x->round(@@r);
d1221 1
a1221 1
  my ($self,$x,$base,@@r) = (undef,@@_);
d1225 1
a1225 1
    ($self,$x,$base,@@r) = objectify(1,ref($x),@@_);
d1282 1
d1284 1
a1284 2
    $x->{value} = $CALC->_gcd($x->{value},$y->{value});
    last if $CALC->_is_one($x->{value});
d1368 2
a1369 5

  return 1 if $x->{sign} eq '+inf';			# +inf is positive
 
  # 0+ is neither positive nor negative
  ($x->{sign} eq '+' && !$x->is_zero()) ? 1 : 0;	
d1377 1
a1377 1
  $x->{sign} =~ /^-/ ? 1 : 0; 		# -inf is negative, but NaN is not
d1430 2
a1431 1
  $x->round(@@r);
d1513 1
a1513 1
    $x->round(@@r);
d1523 1
a1523 1
    $rem->round(@@r);
d1530 2
a1531 1
  $x->round(@@r);
d1564 1
a1564 2
    $x->{value} = $CALC->_sub($y->{value},$x->{value},1) 	# $y-$x
      if ($x->{sign} ne $y->{sign});
d1566 5
d1576 2
a1577 1
  $x->round(@@r);
d1588 1
a1588 1
  my ($self,$x,$y,@@r) = (undef,@@_);
d1651 1
a1651 1
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
d1653 4
a1656 2
  return $x if $x->modify('bfac') || $x->{sign} eq '+inf';	# inf => inf
  return $x->bnan() if $x->{sign} ne '+';			# NaN, <0 etc => NaN
d1749 2
a1750 1
  $x->round(@@r);
d1986 1
a1986 1
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);
d2078 1
a2078 1
  my ($scale,$mode) = $x->_scale_p(@@_);
d2107 1
a2107 1
  my $x = shift; $x = $class->new($x) unless ref $x;
d2120 3
a2122 2
  my ($scale,$mode) = $x->_scale_a(@@_);
  return $x if !defined $scale || $x->modify('bround');	# no-op
a2363 12
sub _register_callback
  {
  my ($class,$callback) = @@_;

  if (ref($callback) ne 'CODE')
    { 
    require Carp;
    Carp::croak ("$callback is not a coderef");
    }
  $CALLBACKS{$class} = $callback;
  }

d2397 3
a2399 7
  if (@@a > 0)
    {
    require Exporter;
 
    $self->SUPER::import(@@a);			# need it for subclasses
    $self->export_to_level(1,$self,@@a);		# need it for MBF
    }
d2403 1
a2403 5
  foreach (@@c)
    {
    $_ =~ tr/a-zA-Z0-9://cd;			# limit to sane characters
    }
  push @@c, 'FastCalc', 'Calc';			# if all fail, try these
d2412 2
a2413 2
      # Perl < 5.6.0 dies with "out of memory!" when eval("") and ':constant' is
      # used in the same script, or eval("") inside import().
d2464 1
a2464 1
	  my $ver = eval "\$$lib\::VERSION" || 'unknown';
d2477 2
d2480 3
a2482 8
  # notify callbacks
  foreach my $class (keys %CALLBACKS)
    {
    &{$CALLBACKS{$class}}($CALC);
    }

  # Fill $CAN with the results of $CALC->can(...) for emulating lower math lib
  # functions
d2485 1
a2485 1
  for my $method (qw/ signed_and signed_or signed_xor /)
a2488 2

  # import done
a2492 1
  # internal
a2513 1
  # internal
d2533 4
a2536 5
  # input: num_str; output: undef for invalid or
  # (\$mantissa_sign,\$mantissa_value,\$mantissa_fraction,\$exp_sign,\$exp_value)
  # Internal, take apart a string and return the pieces.
  # Strip leading/trailing whitespace, leading zeros, underscore and reject
  # invalid input.
d2604 1
a2604 1
  my ($x,$ty) = @@_;
d2606 1
a2606 3
  my $method = ref($x) . '::bgcd';
  no strict 'refs';
  $x * $ty / &$method($x,$ty);
d2610 1
a2610 1
# this method returns 0 if the object can be modified, or 1 if not.
a2618 2
=pod

d2621 1
a2621 1
Math::BigInt - Arbitrary size integer/float math package
d2730 1
a2730 1
			   # latter is always 0 digits long for BigInts
d2740 2
a2741 2
  $x->bstr();		   # normalized string (e.g. '3')
  $x->bsstr();		   # norm. string in scientific notation (e.g. '3E0')
d2753 3
a2755 5
  Math::BigInt->precision();	# get/set global P for all BigInt objects
  Math::BigInt->accuracy(); 	# get/set global A for all BigInt objects
  Math::BigInt->round_mode();	# get/set global round mode, one of
				# 'even', 'odd', '+inf', '-inf', 'zero' or 'trunc'
  Math::BigInt->config();	# return hash containing configuration
d2799 2
a2800 3
Output values are BigInt objects (normalized), except for the methods which
return a string (see L<SYNOPSIS>).

d2802 2
a2803 2
C<is_nan()>, etc.) return true or false, while others (C<bcmp()>, C<bacmp()>)
return either undef (if NaN is involved), <0, 0 or >0 and are suited for sort.
d2810 2
a2811 2
accepts three additional parameters. These arguments C<$A>, C<$P> and C<$R>
are C<accuracy>, C<precision> and C<round_mode>. Please see the section about
d2866 2
a2867 4
					# Note: This also applies to new()!

	$A = $x->accuracy();		# read out accuracy that affects $x
	$A = CLASS->accuracy();		# read out global accuracy
d2870 1
a2870 14
results have. If you set a global accuracy, then this also applies to new()!

Warning! The accuracy I<sticks>, e.g. once you created a number under the
influence of C<< CLASS->accuracy($A) >>, all results from math operations with
that number will also be rounded. 

In most cases, you should probably round the results explicitely using one of
L<round()>, L<bround()> or L<bfround()> or by passing the desired accuracy
to the math operation as additional parameter:

        my $x = Math::BigInt->new(30000);
        my $y = Math::BigInt->new(7);
        print scalar $x->copy()->bdiv($y, 2);		# print 4300
        print scalar $x->copy()->bdiv($y)->bround(2);	# print 4300
d2885 1
a2885 1
	$x = Math::BigInt->new(123456);		# $x will be automatically rounded!
d2900 11
a2910 21
	$x->precision(-2);	# local for $x, round at the second digit right of the dot
	$x->precision(2);	# ditto, round at the second digit left of the dot

	CLASS->precision(5);	# Global for all members of CLASS
				# This also applies to new()!
	CLASS->precision(-5);	# ditto

	$P = CLASS->precision();	# read out global precision 
	$P = $x->precision();		# read out precision that affects $x

Note: You probably want to use L<accuracy()> instead. With L<accuracy> you
set the number of digits each result should have, with L<precision> you
set the place where to round!

C<precision()> sets or gets the global or local precision, aka at which digit
before or after the dot to round all results. A set global precision also
applies to all newly created numbers!

In Math::BigInt, passing a negative number precision has no effect since no
numbers have digits after the dot. In L<Math::BigFloat>, it will round all
results to P digits after the dot.
d2914 1
a2914 1
Pass an undef value to disable it:
d2921 1
a2921 1
value represents the prevision that will be in effect for $x:
a2925 1
	print $x;				# print "120000"!
d2927 2
a2928 2
Note: Works also for subclasses like L<Math::BigFloat>. Each class has its
own globals separated from Math::BigInt, but it is possible to subclass
d3025 2
a3026 2
	$x->is_pos();			# true if > 0
	$x->is_neg();			# true if < 0
d3030 1
a3030 1
C<-inf> is negative. A C<zero> is neither positive nor negative.
a3068 8
If you want $x to have a certain sign, use one of the following methods:

	$x->babs();		# '+'
	$x->babs()->bneg();	# '-'
	$x->bnan();		# 'NaN'
	$x->binf();		# '+inf'
	$x->binf('-');		# '-inf'

a3647 45
=head1 Infinity and Not a Number

While BigInt has extensive handling of inf and NaN, certain quirks remain.

=over 2

=item oct()/hex()

These perl routines currently (as of Perl v.5.8.6) cannot handle passed
inf.

	te@@linux:~> perl -wle 'print 2 ** 3333'
	inf
	te@@linux:~> perl -wle 'print 2 ** 3333 == 2 ** 3333'
	1
	te@@linux:~> perl -wle 'print oct(2 ** 3333)'
	0
	te@@linux:~> perl -wle 'print hex(2 ** 3333)'
	Illegal hexadecimal digit 'i' ignored at -e line 1.
	0

The same problems occur if you pass them Math::BigInt->binf() objects. Since
overloading these routines is not possible, this cannot be fixed from BigInt.

=item ==, !=, <, >, <=, >= with NaNs

BigInt's bcmp() routine currently returns undef to signal that a NaN was
involved in a comparisation. However, the overload code turns that into
either 1 or '' and thus operations like C<< NaN != NaN >> might return
wrong values.

=item log(-inf)

C<< log(-inf) >> is highly weird. Since log(-x)=pi*i+log(x), then
log(-inf)=pi*i+inf. However, since the imaginary part is finite, the real
infinity "overshadows" it, so the number might as well just be infinity.
However, the result is a complex number, and since BigInt/BigFloat can only
have real numbers as results, the result is NaN.

=item exp(), cos(), sin(), atan2()

These all might have problems handling infinity right.
 
=back

a3650 1

d3652 2
a3653 2
might change without notice. Use B<ONLY> method calls like C<< $x->sign(); >>
instead relying on the internal representation.
d3672 1
a3672 1
math involving really big numbers, where it is B<much> faster), and there is
d3679 1
a3679 2
numbers. You should B<NOT> depend on the number having a specific format
internally.
d3685 1
a3685 1
The sign is either '+', '-', 'NaN', '+inf' or '-inf'.
a4044 3
See also the section about L<Infinity and Not a Number> for problems in
comparing NaNs.

d4055 1
a4055 2
In all Perl versions you can use C<as_number()> or C<as_int> for the same
effect:
a4058 1
	$y = $x->as_int();			# ditto
a4063 9
If you want a real Perl scalar, use C<numify()>:

	$y = $x->numify();			# 123 as scalar

This is seldom necessary, though, because this is done automatically, like
when you access an array:

	$z = $array[$x];			# does work automatically

d4216 3
d4323 2
a4324 2
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2004
and still at it in 2005.
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d19 1
a19 1
use 5.006;
d21 1
a21 1
$VERSION = '1.88';
d65 2
a66 1
'<=>'	=>	sub { my $rc = $_[2] ?
d68 1
a68 12
                      $_[0]->bcmp($_[1]); 
		      $rc = 1 unless defined $rc;
		      $rc <=> 0;
		},
# we need '>=' to get things like "1 >= NaN" right:
'>='	=>	sub { my $rc = $_[2] ?
                      ref($_[0])->bcmp($_[1],$_[0]) : 
                      $_[0]->bcmp($_[1]);
		      # if there was a NaN involved, return false
		      return '' unless defined $rc;
		      $rc >= 0;
		},
d74 4
a77 2
'cos'	=>	sub { $_[0]->copy->bcos(); }, 
'sin'	=>	sub { $_[0]->copy->bsin(); }, 
d79 2
a80 2
			ref($_[0])->new($_[1])->batan2($_[0]) :
			$_[0]->copy()->batan2($_[1]) },
d86 1
a86 3
# log(N) is log(N, e), where e is Euler's number
'log'	=>	sub { $_[0]->copy()->blog($_[1], undef); }, 
'exp'	=>	sub { $_[0]->copy()->bexp($_[1]); }, 
d151 1
a151 1
$round_mode = 'even'; # one of 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
d204 1
a204 1
    if ($m !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
d284 1
a284 1
	Carp::croak ('Argument to accuracy must be greater than zero');
d288 1
a288 2
        require Carp;
	Carp::croak ('Argument to accuracy must be an integer');
d367 1
a367 1
  if (@@_ > 1 || (@@_ == 1 && (ref($_[0]) eq 'HASH')))
a419 5
  if (@@_ == 1 && (ref($_[0]) ne 'HASH'))
    {
    # calls of the style config('lib') return just this value
    return $cfg->{$_[0]};
    }
a436 6
  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify() : "$scale" if ref($scale);
    $scale = int($scale);
    }

a453 6
  if (defined $scale)
    {
    $scale = $scale->can('numify') ? $scale->numify() : "$scale" if ref($scale);
    $scale = int($scale);
    }

d462 1
a462 1
  # if two arguments, the first one is the class to "swallow" subclasses
d465 7
a471 8
    my  $self = bless {
	sign => $_[1]->{sign}, 
	value => $CALC->_copy($_[1]->{value}),
    }, $_[0] if @@_ > 1;

    $self->{_a} = $_[1]->{_a} if defined $_[1]->{_a};
    $self->{_p} = $_[1]->{_p} if defined $_[1]->{_p};
    return $self;
d473 1
d475 1
a475 4
  my $self = bless {
	sign => $_[0]->{sign}, 
	value => $CALC->_copy($_[0]->{value}),
	}, ref($_[0]);
d477 4
a480 2
  $self->{_a} = $_[0]->{_a} if defined $_[0]->{_a};
  $self->{_p} = $_[0]->{_p} if defined $_[0]->{_p};
d730 1
a730 1
  # if given a BigInt, set it to +1 or -1, respectively
a851 4
  # convert to normal scalar for speed and correctness in inner parts
  $a = $a->can('numify') ? $a->numify() : "$a" if defined $a && ref($a);
  $p = $p->can('numify') ? $p->numify() : "$p" if defined $p && ref($p);

d885 1
a885 1
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
a889 3
  $a = int($a) if defined $a;
  $p = int($p) if defined $p;

d942 1
a942 1
  if ($r !~ /^(even|odd|\+inf|\-inf|zero|trunc|common)$/)
d950 1
a950 1
    $self->bround(int($a),$r) if !defined $self->{_a} || $self->{_a} >= $a;
d954 1
a954 1
    $self->bfround(int($p),$r) if !defined $self->{_p} || $self->{_p} <= $p;
d956 1
a956 1
  # bround() or bfround() already callled bnorm() if nec.
a1136 1

d1163 1
a1163 1
  $x;				# already rounded by badd() or no round nec.
d1228 1
a1228 1

a1230 2
  $base = $self->new($base) if defined $base && !ref $base;

a1237 12
  # fix for bug #24969:
  # the default base is e (Euler's number) which is not an integer
  if (!defined $base)
    {
    require Math::BigFloat;
    my $u = Math::BigFloat->blog(Math::BigFloat->new($x))->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->{sign} = $u->{sign};
    return $x;
    }
  
a1243 83
sub bnok
  {
  # Calculate n over k (binomial coefficient or "choose" function) as integer.
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  return $x if $x->modify('bnok');
  return $x->bnan() if $x->{sign} eq 'NaN' || $y->{sign} eq 'NaN';
  return $x->binf() if $x->{sign} eq '+inf';

  # k > n or k < 0 => 0
  my $cmp = $x->bacmp($y);
  return $x->bzero() if $cmp < 0 || $y->{sign} =~ /^-/;
  # k == n => 1
  return $x->bone(@@r) if $cmp == 0;

  if ($CALC->can('_nok'))
    {
    $x->{value} = $CALC->_nok($x->{value},$y->{value});
    }
  else
    {
    # ( 7 )    7!          7*6*5 * 4*3*2*1   7 * 6 * 5
    # ( - ) = --------- =  --------------- = ---------
    # ( 3 )   3! (7-3)!    3*2*1 * 4*3*2*1   3 * 2 * 1 

    # compute n - k + 2 (so we start with 5 in the example above)
    my $z = $x - $y;
    if (!$z->is_one())
      {
      $z->binc();
      my $r = $z->copy(); $z->binc();
      my $d = $self->new(2);
      while ($z->bacmp($x) <= 0)		# f < x ?
        {
        $r->bmul($z); $r->bdiv($d);
        $z->binc(); $d->binc();
        }
      $x->{value} = $r->{value}; $x->{sign} = '+';
      }
    else { $x->bone(); }
    }
  $x->round(@@r);
  }

sub bexp
  {
  # Calculate e ** $x (Euler's number to the power of X), truncated to
  # an integer value.
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  return $x if $x->modify('bexp');

  # inf, -inf, NaN, <0 => NaN
  return $x->bnan() if $x->{sign} eq 'NaN';
  return $x->bone() if $x->is_zero();
  return $x if $x->{sign} eq '+inf';
  return $x->bzero() if $x->{sign} eq '-inf';

  my $u;
  {
    # run through Math::BigFloat unless told otherwise
    require Math::BigFloat unless defined $upgrade;
    local $upgrade = 'Math::BigFloat' unless defined $upgrade;
    # calculate result, truncate it to integer
    $u = $upgrade->bexp($upgrade->new($x),@@r);
  }

  if (!defined $upgrade)
    {
    $u = $u->as_int();
    # modify $x in place
    $x->{value} = $u->{value};
    $x->round(@@r);
    }
  else { $x = $u; }
  }

d1397 1
a1397 1
  # multiply the first number by the second number
d1407 1
a1407 1

a1436 76
sub bmuladd
  { 
  # multiply two numbers and then add the third to the result
  # (BINT or num_str, BINT or num_str, BINT or num_str) return BINT

  # set up parameters
  my ($self,$x,$y,$z,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$z,@@r) = objectify(3,@@_);
    }

  return $x if $x->modify('bmuladd');

  return $x->bnan() if  ($x->{sign} eq $nan) ||
			($y->{sign} eq $nan) ||
			($z->{sign} eq $nan);

  # inf handling of x and y
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/); 
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/); 
    return $x->binf('-');
    }
  # inf handling x*y and z
  if (($z->{sign} =~ /^[+-]inf$/))
    {
    # something +-inf => +-inf
    $x->{sign} = $z->{sign}, return $x if $z->{sign} =~ /^[+-]inf$/;
    }

  return $upgrade->bmuladd($x,$upgrade->new($y),$upgrade->new($z),@@r)
   if defined $upgrade && (!$y->isa($self) || !$z->isa($self) || !$x->isa($self));
 
  # TODO: what if $y and $z have A or P set?
  $r[3] = $z;				# no push here

  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-'; # +1 * +1 or -1 * -1 => +

  $x->{value} = $CALC->_mul($x->{value},$y->{value});	# do actual math
  $x->{sign} = '+' if $CALC->_is_zero($x->{value}); 	# no -0

  my ($sx, $sz) = ( $x->{sign}, $z->{sign} ); 		# get signs

  if ($sx eq $sz)  
    {
    $x->{value} = $CALC->_add($x->{value},$z->{value});	# same sign, abs add
    }
  else 
    {
    my $a = $CALC->_acmp ($z->{value},$x->{value});	# absolute compare
    if ($a > 0)                           
      {
      $x->{value} = $CALC->_sub($z->{value},$x->{value},1); # abs sub w/ swap
      $x->{sign} = $sz;
      } 
    elsif ($a == 0)
      {
      # speedup, if equal, set result to 0
      $x->{value} = $CALC->_zero();
      $x->{sign} = '+';
      }
    else # a < 0
      {
      $x->{value} = $CALC->_sub($x->{value}, $z->{value}); # abs sub
      }
    }
  $x->round(@@r);
  }

d1615 1
a1615 1
  # large modulus, quickly, thanks to binary exponentation. Supports
d1725 1
a1725 1
   if defined $upgrade && (!$y->isa($self) || $y->{sign} eq '-');
d1805 1
a1805 1
      if ($y >= CORE::length($bin))
d2035 1
a2035 2
  # 12300 => 2 trailing zeros => exponent is 2
  $self->new( $CALC->_zeros($x->{value}) );
a2048 1

d2050 1
a2050 1
  my $zeros = $CALC->_zeros($m->{value});
d2229 1
a2229 1
  # operations. This does exactly this, so that sub classes can simple inherit
a2256 11
sub as_oct
  {
  # return as octal string, with prefixed 0
  my $x = shift; $x = $class->new($x) if !ref($x);

  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, nan etc

  my $s = ''; $s = $x->{sign} if $x->{sign} eq '-';
  return $s . $CALC->_as_oct($x->{value});
  }

d2267 1
a2267 1
  # useless objects being created and thrown away. So we cannot simple loop
d2312 1
a2312 1
  # print STDERR "# Now in objectify, my class is today $a[0], count = $count\n";
d2335 1
a2335 1
      $k = shift;
d2343 1
a2343 1
        $k->can('as_number') ? $k = $k->as_number() : $k = $a[0]->new($k);
a2374 1
  my $warn_or_die = 0;			# 0 - no warn, 1 - warn, 2 - die
d2390 1
a2390 1
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
a2393 3
      # lib => 1 (warn on fallback), try => 0 (no warn), only => 2 (die on fallback)
      $warn_or_die = 1 if $_[$i] eq 'lib';
      $warn_or_die = 2 if $_[$i] eq 'only';
d2416 1
a2416 2
  push @@c, \'FastCalc', \'Calc'			# if all fail, try these
    if $warn_or_die < 2;			# but not for "only"
d2418 1
a2418 1
  foreach my $l (@@c)
a2419 3
    # fallback libraries are "marked" as \'string', extract string if nec.
    my $lib = $l; $lib = $$l if ref($l);

d2451 1
a2451 2
		zeros new copy check
		from_hex from_oct from_bin as_hex as_bin as_oct
a2470 7
	if ($warn_or_die > 0 && ref($l))
	  {
	  require Carp;
	  my $msg = "Math::BigInt: couldn't load specified math lib(s), fallback to $lib";
          Carp::carp ($msg) if $warn_or_die == 1;
          Carp::croak ($msg) if $warn_or_die == 2;
	  }
d2488 1
a2488 8
    if ($warn_or_die == 2)
      {
      Carp::croak ("Couldn't load specified math lib(s) and fallback disallowed");
      }
    else
      {
      Carp::croak ("Couldn't load any math lib(s), not even fallback to Calc.pm");
      }
a2508 45
sub from_hex
  {
  # create a bigint from a hexadecimal string
  my ($self, $hs) = @@_;

  my $rc = __from_hex($hs);

  return $self->bnan() unless defined $rc;

  $rc;
  }  

sub from_bin
  {
  # create a bigint from a hexadecimal string
  my ($self, $bs) = @@_;

  my $rc = __from_bin($bs);

  return $self->bnan() unless defined $rc;

  $rc;
  }  

sub from_oct
  {
  # create a bigint from a hexadecimal string
  my ($self, $os) = @@_;

  my $x = $self->bzero();
  
  # strip underscores
  $os =~ s/([0-7])_([0-7])/$1$2/g;	
  $os =~ s/([0-7])_([0-7])/$1$2/g;	
  
  return $x->bnan() if $os !~ /^[\-\+]?0[0-7]+\z/;

  my $sign = '+'; $sign = '-' if $os =~ /^-/;

  $os =~ s/^[+-]//;						# strip sign
  $x->{value} = $CALC->_from_oct($os);
  $x->{sign} = $sign unless $CALC->_is_zero($x->{value}); 	# no '-0'
  $x;
  }

a2537 1

d2561 3
a2563 3
  $x =~ s/^\s*([-]?)0*([0-9])/$1$2/g;   # will not strip '  .2'
  $x =~ s/^\s+//;                       # but this will
  $x =~ s/\s+$//g;                      # strip white space at end
d2566 1
a2566 1
  if ($x =~ /^[+-]?[0-9]+\z/)
d2575 2
a2576 2
  return __from_hex($x) if $x =~ /^[\-\+]?0x/;		# hex string
  return __from_bin($x) if $x =~ /^[\-\+]?0b/;		# binary string
d2579 2
a2580 2
  $x =~ s/([0-9])_([0-9])/$1$2/g;
  $x =~ s/([0-9])_([0-9])/$1$2/g;		# do twice for 1_2_3
d2593 1
a2593 1
  if ($e =~ /^([+-]?)0*([0-9]+)$/)	# strip leading zeros
d2603 1
a2603 1
    if ($mi =~ /^([+-]?)0*([0-9]+)$/)		# strip leading zeros
d2606 1
a2606 1
      return unless ($mf =~ /^([0-9]*?)0*$/);	# strip trailing zeros
a2632 115
# trigonometric functions

sub bpi
  {
  # Calculate PI to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer, that is, always returns '3'.
  my ($self,$n) = @@_;
  if (@@_ == 1)
    {
    # called like Math::BigInt::bpi(10);
    $n = $self; $self = $class;
    }
  $self = ref($self) if ref($self);

  return $upgrade->new($n) if defined $upgrade;

  # hard-wired to "3"
  $self->new(3);
  }

sub bcos
  {
  # Calculate cosinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bcos');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN

  return $upgrade->new($x)->bcos(@@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bcos(@@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@@r);
  }

sub bsin
  {
  # Calculate sinus(x) to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('bsin');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN

  return $upgrade->new($x)->bsin(@@r) if defined $upgrade;

  require Math::BigFloat;
  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->bsin(@@r)->as_int();

  $x->bone() if $t->is_one();
  $x->bzero() if $t->is_zero();
  $x->round(@@r);
  }

sub batan2
  { 
  # calculate arcus tangens of ($y/$x)
 
  # set up parameters
  my ($self,$y,$x,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$y,$x,@@r) = objectify(2,@@_);
    }

  return $y if $y->modify('batan2');

  return $y->bnan() if ($y->{sign} eq $nan) || ($x->{sign} eq $nan);

  return $y->bzero() if	$y->is_zero() && $x->{sign} eq '+';		# x >= 0

  # inf handling
  # +-inf => --PI/2 => +-1
  return $y->bone( substr($y->{sign},0,1) ) if $y->{sign} =~ /^[+-]inf$/;

  return $upgrade->new($y)->batan2($upgrade->new($x),@@r) if defined $upgrade;

  require Math::BigFloat;
  my $r = Math::BigFloat->new($y)->batan2(Math::BigFloat->new($x),@@r)->as_int();

  $x->{value} = $r->{value};
  $x->{sign} = $r->{sign};

  $x;
  }

sub batan
  {
  # Calculate arcus tangens of x to N digits. Unless upgrading is in effect, returns the
  # result truncated to an integer.
  my ($self,$x,@@r) = ref($_[0]) ? (undef,@@_) : objectify(1,@@_);

  return $x if $x->modify('batan');

  return $x->bnan() if $x->{sign} !~ /^[+-]\z/;	# -inf +inf or NaN => NaN

  return $upgrade->new($x)->batan(@@r) if defined $upgrade;

  # calculate the result and truncate it to integer
  my $t = Math::BigFloat->new($x)->batan(@@r);

  $x->{value} = $CALC->_new( $x->as_int()->bstr() );
  $x->round(@@r);
  }

###############################################################################
a2655 1
  # will warn if Math::BigInt::GMP cannot be found
a2657 3
  # to supress the warning use this:
  # use Math::BigInt try => 'GMP';

d2663 8
a2670 15
  my $x = Math::BigInt->new($str);	# defaults to 0
  my $y = $x->copy();			# make a true copy
  my $nan  = Math::BigInt->bnan(); 	# create a NotANumber
  my $zero = Math::BigInt->bzero();	# create a +0
  my $inf = Math::BigInt->binf();	# create a +inf
  my $inf = Math::BigInt->binf('-');	# create a -inf
  my $one = Math::BigInt->bone();	# create a +1
  my $mone = Math::BigInt->bone('-');	# create a -1

  my $pi = Math::BigInt->bpi();		# returns '3'
					# see Math::BigFloat::bpi()

  $h = Math::BigInt->new('0x123');	# from hexadecimal
  $b = Math::BigInt->new('0b101');	# from binary
  $o = Math::BigInt->from_oct('0101');	# from octal
d2686 1
a2686 1
  # comparing and digit/sign extraction
d2695 1
a2695 1
  # necessary when mixing $a = $b assignments with non-overloaded math.
a2716 2
  $x->bmuladd($y,$z);	# $x = $x * $y + $z

d2722 4
a2725 6
  $x->blsft($y);	   # left shift in base 2
  $x->brsft($y);	   # right shift in base 2
			   # returns (quo,rem) or quo if in scalar context
  $x->blsft($y,$n);	   # left shift by $y places in base $n
  $x->brsft($y,$n);	   # right shift by $y places in base $n
			   # returns (quo,rem) or quo if in scalar context
a2735 6
  $x->bnok($y);		   # x over y (binomial coefficient n over k)

  $x->blog();		   # logarithm of $x to base e (Euler's number)
  $x->blog($base);	   # logarithm of $x to base $base (f.i. 2)
  $x->bexp();		   # calculate e ** $x where e is Euler's number
  
d2738 1
a2738 3
  $x->bfround($n);	   # $n > 0: round $nth digits,
			   # $n < 0: round to the $nth digit after the
			   # dot, no-op for BigInts
a2768 1
  $x->as_oct();		   # as signed octal string with prefixed 0
d2781 1
a2781 1
				# 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'
d2786 1
a2786 1
All operators (including basic math operations) are overloaded if you
a2812 10
Hexadecimal (prefixed with "0x") and binary numbers (prefixed with "0b")
are accepted, too. Please note that octal numbers are not recognized
by new(), so the following will print "123":

	perl -MMath::BigInt -le 'print Math::BigInt->new("0123")'
	
To convert an octal number, use from_oct();

	perl -MMath::BigInt -le 'print Math::BigInt->from_oct("0123")'

d2842 1
a2842 1
=head2 config()
d2874 1
a2874 1
	div_scale	Fallback accuracy for div
d2890 1
a2890 1
=head2 accuracy()
d2906 1
a2906 1
In most cases, you should probably round the results explicitly using one of
d2941 1
a2941 1
=head2 precision()
d2986 1
a2986 1
=head2 brsft()
d3011 1
a3011 1
=head2 new()
d3021 1
a3021 13
=head2 from_oct()

	$x = Math::BigInt->from_oct("0775");	# input is octal

=head2 from_hex()

	$x = Math::BigInt->from_hex("0xcafe");	# input is hexadecimal

=head2 from_bin()

	$x = Math::BigInt->from_oct("0x10011");	# input is binary

=head2 bnan()
d3030 1
a3030 1
=head2 bzero()
d3039 1
a3039 1
=head2 binf()
d3050 1
a3050 1
=head2 bone()
d3071 1
a3071 1
These methods all test the BigInt for being one specific value and return
d3077 1
a3077 1
=head2 is_pos()/is_neg()/is_positive()/is_negative()
d3088 1
a3088 1
C<is_positive()> and C<is_negative()> are aliases to C<is_pos()> and
d3104 1
a3104 1
=head2 bcmp()
d3111 1
a3111 1
=head2 bacmp()
d3117 1
a3117 1
=head2 sign()
d3131 1
a3131 1
=head2 digit()
d3137 1
a3137 1
=head2 bneg()
d3144 1
a3144 1
=head2 babs()
d3148 1
a3148 1
Set the number to its absolute value, e.g. change the sign from '-' to '+'
d3152 1
a3152 1
=head2 bnorm()
d3156 1
a3156 1
=head2 bnot()
d3160 1
a3160 1
Two's complement (bitwise not). This is equivalent to
d3166 1
a3166 1
=head2 binc()
d3170 1
a3170 1
=head2 bdec()
d3174 1
a3174 1
=head2 badd()
d3178 1
a3178 1
=head2 bsub()
d3182 1
a3182 1
=head2 bmul()
d3186 1
a3186 9
=head2 bmuladd()

	$x->bmuladd($y,$z);

Multiply $x by $y, and then add $z to the result,

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 bdiv()
d3191 1
a3191 1
=head2 bmod()
d3195 1
a3195 1
=head2 bmodinv()
d3203 1
a3203 1
=head2 bmodpow()
d3225 1
a3225 1
=head2 bpow()
d3229 1
a3229 1
=head2 blog()
d3231 1
a3231 98
	$x->blog($base, $accuracy);	# logarithm of x to the base $base

If C<$base> is not defined, Euler's number (e) is used:

	print $x->blog(undef, 100);	# log(x) to 100 digits

=head2 bexp()

	$x->bexp($accuracy);		# calculate e ** X

Calculates the expression C<e ** $x> where C<e> is Euler's number.

This method was added in v1.82 of Math::BigInt (April 2007).

See also L<blog()>.

=head2 bnok()

	$x->bnok($y);		   # x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

	( n )      n!
	| - |  = -------
	( k )    k!(n-k)!

This method was added in v1.84 of Math::BigInt (April 2007).

=head2 bpi()

	print Math::BigInt->bpi(100), "\n";		# 3

Returns PI truncated to an integer, with the argument being ignored. This means
under BigInt this always returns C<3>.

If upgrading is in effect, returns PI, rounded to N digits with the
current rounding mode:

	use Math::BigFloat;
	use Math::BigInt upgrade => Math::BigFloat;
	print Math::BigInt->bpi(3), "\n";		# 3.14
	print Math::BigInt->bpi(100), "\n";		# 3.1415....

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 bcos()

	my $x = Math::BigInt->new(1);
	print $x->bcos(100), "\n";

Calculate the cosinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 bsin()

	my $x = Math::BigInt->new(1);
	print $x->bsin(100), "\n";

Calculate the sinus of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 batan2()

	my $x = Math::BigInt->new(1);
	my $y = Math::BigInt->new(1);
	print $y->batan2($x), "\n";

Calculate the arcus tangens of C<$y> divided by C<$x>, modifying $y in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 batan()

	my $x = Math::BigFloat->new(0.5);
	print $x->batan(100), "\n";

Calculate the arcus tangens of $x, modifying $x in place.

In BigInt, unless upgrading is in effect, the result is truncated to an
integer.

This method was added in v1.87 of Math::BigInt (June 2007).

=head2 blsft()

	$x->blsft($y);		# left shift in base 2
d3234 1
a3234 1
=head2 brsft()
d3236 1
a3236 1
	$x->brsft($y);		# right shift in base 2
d3239 1
a3239 1
=head2 band()
d3243 1
a3243 1
=head2 bior()
d3247 1
a3247 1
=head2 bxor()
d3251 1
a3251 1
=head2 bnot()
d3255 1
a3255 1
=head2 bsqrt()
d3259 1
a3259 7
=head2 broot()

	$x->broot($N);

Calculates the N'th root of C<$x>.

=head2 bfac()
d3263 1
a3263 1
=head2 round()
d3270 1
a3270 1
=head2 bround()
d3274 1
a3274 1
=head2 bfround()
d3276 1
a3276 1
	$x->bfround($N);
d3278 1
a3278 14
If N is > 0, rounds to the Nth digit from the left. If N < 0, rounds to
the Nth digit after the dot. Since BigInts are integers, the case N < 0
is a no-op for them.

Examples:

	Input		N		Result
	===================================================
	123456.123456	3		123500
	123456.123456	2		123450
	123456.123456	-2		123456.12
	123456.123456	-3		123456.123

=head2 bfloor()
d3285 1
a3285 1
=head2 bceil()
d3292 1
a3292 1
=head2 bgcd()
d3296 1
a3296 1
=head2 blcm()
d3300 1
a3300 1
head2 length()
d3309 1
a3309 1
=head2 exponent()
d3315 1
a3315 1
=head2 mantissa()
d3321 1
a3321 1
=head2 parts()
d3325 1
a3325 1
=head2 copy()
d3329 1
a3329 1
=head2 as_int()/as_number()
d3339 1
a3339 1
=head2 bstr()
d3343 1
a3343 1
Returns a normalized string representation of C<$x>.
d3345 1
a3345 1
=head2 bsstr()
d3349 1
a3349 1
=head2 as_hex()
d3353 1
a3353 1
=head2 as_bin()
a3356 42
=head2 as_oct()

	$x->as_oct();		# as signed octal string with prefixed 0

=head2 numify()

	print $x->numify();

This returns a normal Perl scalar from $x. It is used automatically
whenever a scalar is needed, for instance in array index operations.

This loses precision, to avoid this use L<as_int()> instead.

=head2 modify()

	$x->modify('bpowd');

This method returns 0 if the object can be modified with the given
peration, or 1 if not.

This is used for instance by L<Math::BigInt::Constant>.

=head2 upgrade()/downgrade()

Set/get the class for downgrade/upgrade operations. Thuis is used
for instance by L<bignum>. The defaults are '', thus the following
operation will create a BigInt, not a BigFloat:

	my $i = Math::BigInt->new(123);
	my $f = Math::BigFloat->new('123.1');

	print $i + $f,"\n";			# print 246

=head2 div_scale()

Set/get the number of digits for the default precision in divide
operations.

=head2 round_mode()

Set/get the current round mode.

a3482 6
=item 'common'

round up if the digit immediately to the right of the rounding place
is 5 or greater, otherwise round down. E.g., 0.15 becomes 0.2 and
0.149 becomes 0.1.

d3514 1
a3514 1
      scale += length(divisor) - length(dividend);
d3553 1
a3553 1
  * Please note that C<< $x->accuracy() >> respective C<< $x->precision() >>
d3559 1
a3559 1
  * When you create a number, you can give the desired A or P via:
d3568 1
a3568 1
    suffering rounding in the parent. Thus a subclass is able to have its own
d3599 1
a3599 1
  * A takes precedence over P (Hint: A comes before P).
d3617 1
a3617 1
      against overflows. You must explicitly call bround(), bfround() or
d3675 1
a3675 1
    'even', 'odd', '+inf', '-inf', 'zero', 'trunc', 'common'
d3737 1
a3737 1
involved in a comparison. However, the overload code turns that into
d3814 3
a3816 4
Currently, for BigInts C<$e> is always 0, except +inf and -inf, where it is
C<+inf>; and for NaN, where it is C<NaN>; and for C<$x == 0>, where it is C<1>
(to be compatible with Math::BigFloat's internal representation of a zero as
C<0E1>).
d3832 1
a3832 1
  $x = Math::BigInt->bnorm("-0.00"); 	# BigInt "0"
d3929 1
a3929 1
to a constant overhead for all other operations. So Math::BigInt does currently
d3993 1
a3993 1
At the very minimum, any subclass will need to provide its own C<new()> and can
a4057 2
=item bexp()

d4066 1
a4066 1
=head1 EXPORTS
d4068 13
a4080 1
C<Math::BigInt> exports nothing by default, but can export the following methods:
d4082 8
a4089 2
	bgcd
	blcm
d4104 1
a4104 1
because its C<ok()> uses 'eq' internally. 
d4136 1
a4136 1
for comparison, but Perl will represent some numbers as 100 and others
d4150 1
a4150 1
Alternatively, simple use C<< <=> >> for comparisons, this will get it
d4176 2
d4206 1
a4206 1
context. Also, C<bdiv()> will modify $c, so be careful. You probably want
d4235 1
a4235 1
negative. See below under "infinity handling" for the reasoning behind this.
d4443 2
a4444 2
Completely rewritten by Tels http://bloodgate.com in late 2000, 2001 - 2006
and still at it in 2007.
d4447 1
a4447 1
CREDITS for an (incomplete) list. If you miss your name, please drop me a
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d21 1
a21 1
$VERSION = '1.89';
d3003 5
a3007 41
  # Y    X
  # != 0 -inf result is +- pi
  if ($x->is_inf() || $y->is_inf())
    {
    # upgrade to BigFloat etc.
    return $upgrade->new($y)->batan2($upgrade->new($x),@@r) if defined $upgrade;
    if ($y->is_inf())
      {
      if ($x->{sign} eq '-inf')
        {
        # calculate 3 pi/4 => 2.3.. => 2
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(2));
        }
      elsif ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # calculate pi/2 => 1.5 => 1
        $y->bone( substr($y->{sign},0,1) );
        }
      }
    else
      {
      if ($x->{sign} eq '+inf')
        {
        # calculate pi/4 => 0.7 => 0
        $y->bzero();
        }
      else
        {
        # PI => 3.1415.. => 3
        $y->bone( substr($y->{sign},0,1) );
        $y->bmul($self->new(3));
        }
      }
    return $y;
    }
d3059 3
a3061 4
  # or make it faster with huge numbers: install (optional)
  # Math::BigInt::GMP and always use (it will fall back to
  # pure Perl if the GMP library is not installed):
  # (See also the L<MATH LIBRARY> section!)
a3068 3
  # dies if GMP cannot be loaded:
  # use Math::BigInt only => 'GMP';

d4393 1
a4393 3
	use Math::BigInt try => 'Calc';

You can change this backend library by using:
d4395 1
a4395 1
	use Math::BigInt try => 'GMP';
d4397 1
a4397 8
B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.

If your script works with huge numbers and Calc is too slow for them,
you can also for the loading of one of these libraries and if none
of them can be used, the code will die:

	use Math::BigInt only => 'GMP,Pari';
d4402 1
a4402 8
	use Math::BigInt try => 'Foo,Math::BigInt::Bar';

The library that is loaded last will be used. Note that this can be
overwritten at any time by loading a different library, and numbers
constructed with different libraries cannot be used in math operations
together.

=head3 What library to use?
d4404 4
a4407 2
B<Note>: General purpose packages should not be explicit about the library
to use; let the script author decide which is best.
d4409 1
a4409 5
L<Math::BigInt::GMP> and L<Math::BigInt::Pari> are in cases involving big
numbers much faster than Calc, however it is slower when dealing with very
small numbers (less than about 20 digits) and when converting very large
numbers to decimal (for instance for printing, rounding, calculating their
length in decimal etc).
d4411 2
a4412 4
So please select carefully what libary you want to use.

Different low-level libraries use different formats to store the numbers.
However, you should B<NOT> depend on the number having a specific format
d4574 5
a4578 2
You can use an alternative library to drive Math::BigInt. See the section
L<MATH LIBRARY> for more information.
@


