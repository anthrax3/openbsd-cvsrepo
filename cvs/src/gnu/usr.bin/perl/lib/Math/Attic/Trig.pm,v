head	1.10;
access;
symbols
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.10
date	2010.09.24.14.59.42;	author millert;	state dead;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.41;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.39;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.34;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.56;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.57.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.14;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.46;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.34;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.06;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.51;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.37;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.53;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.10
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#
# Trigonometric functions, mostly inherited from Math::Complex.
# -- Jarkko Hietaniemi, since April 1997
# -- Raphael Manfredi, September 1996 (indirectly: because of Math::Complex)
#

require Exporter;
package Math::Trig;

use 5.005;
use strict;

use Math::Complex 1.56;
use Math::Complex qw(:trig :pi);

use vars qw($VERSION $PACKAGE @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS);

@@ISA = qw(Exporter);

$VERSION = 1.20;

my @@angcnv = qw(rad2deg rad2grad
		deg2rad deg2grad
		grad2rad grad2deg);

my @@areal = qw(asin_real acos_real);

@@EXPORT = (@@{$Math::Complex::EXPORT_TAGS{'trig'}},
	   @@angcnv, @@areal);

my @@rdlcnv = qw(cartesian_to_cylindrical
		cartesian_to_spherical
		cylindrical_to_cartesian
		cylindrical_to_spherical
		spherical_to_cartesian
		spherical_to_cylindrical);

my @@greatcircle = qw(
		     great_circle_distance
		     great_circle_direction
		     great_circle_bearing
		     great_circle_waypoint
		     great_circle_midpoint
		     great_circle_destination
		    );

my @@pi = qw(pi pi2 pi4 pip2 pip4);

@@EXPORT_OK = (@@rdlcnv, @@greatcircle, @@pi, 'Inf');

# See e.g. the following pages:
# http://www.movable-type.co.uk/scripts/LatLong.html
# http://williams.best.vwh.net/avform.htm

%EXPORT_TAGS = ('radial' => [ @@rdlcnv ],
	        'great_circle' => [ @@greatcircle ],
	        'pi'     => [ @@pi ]);

sub _DR  () { pi2/360 }
sub _RD  () { 360/pi2 }
sub _DG  () { 400/360 }
sub _GD  () { 360/400 }
sub _RG  () { 400/pi2 }
sub _GR  () { pi2/400 }

#
# Truncating remainder.
#

sub _remt ($$) {
    # Oh yes, POSIX::fmod() would be faster. Possibly. If it is available.
    $_[0] - $_[1] * int($_[0] / $_[1]);
}

#
# Angle conversions.
#

sub rad2rad($)     { _remt($_[0], pi2) }

sub deg2deg($)     { _remt($_[0], 360) }

sub grad2grad($)   { _remt($_[0], 400) }

sub rad2deg ($;$)  { my $d = _RD * $_[0]; $_[1] ? $d : deg2deg($d) }

sub deg2rad ($;$)  { my $d = _DR * $_[0]; $_[1] ? $d : rad2rad($d) }

sub grad2deg ($;$) { my $d = _GD * $_[0]; $_[1] ? $d : deg2deg($d) }

sub deg2grad ($;$) { my $d = _DG * $_[0]; $_[1] ? $d : grad2grad($d) }

sub rad2grad ($;$) { my $d = _RG * $_[0]; $_[1] ? $d : grad2grad($d) }

sub grad2rad ($;$) { my $d = _GR * $_[0]; $_[1] ? $d : rad2rad($d) }

#
# acos and asin functions which always return a real number
#

sub acos_real {
    return 0  if $_[0] >=  1;
    return pi if $_[0] <= -1;
    return acos($_[0]);
}

sub asin_real {
    return  &pip2 if $_[0] >=  1;
    return -&pip2 if $_[0] <= -1;
    return asin($_[0]);
}

sub cartesian_to_spherical {
    my ( $x, $y, $z ) = @@_;

    my $rho = sqrt( $x * $x + $y * $y + $z * $z );

    return ( $rho,
             atan2( $y, $x ),
             $rho ? acos_real( $z / $rho ) : 0 );
}

sub spherical_to_cartesian {
    my ( $rho, $theta, $phi ) = @@_;

    return ( $rho * cos( $theta ) * sin( $phi ),
             $rho * sin( $theta ) * sin( $phi ),
             $rho * cos( $phi   ) );
}

sub spherical_to_cylindrical {
    my ( $x, $y, $z ) = spherical_to_cartesian( @@_ );

    return ( sqrt( $x * $x + $y * $y ), $_[1], $z );
}

sub cartesian_to_cylindrical {
    my ( $x, $y, $z ) = @@_;

    return ( sqrt( $x * $x + $y * $y ), atan2( $y, $x ), $z );
}

sub cylindrical_to_cartesian {
    my ( $rho, $theta, $z ) = @@_;

    return ( $rho * cos( $theta ), $rho * sin( $theta ), $z );
}

sub cylindrical_to_spherical {
    return ( cartesian_to_spherical( cylindrical_to_cartesian( @@_ ) ) );
}

sub great_circle_distance {
    my ( $theta0, $phi0, $theta1, $phi1, $rho ) = @@_;

    $rho = 1 unless defined $rho; # Default to the unit sphere.

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    return $rho *
	acos_real( cos( $lat0 ) * cos( $lat1 ) * cos( $theta0 - $theta1 ) +
		   sin( $lat0 ) * sin( $lat1 ) );
}

sub great_circle_direction {
    my ( $theta0, $phi0, $theta1, $phi1 ) = @@_;

    my $distance = great_circle_distance($theta0, $phi0, $theta1, $phi1);

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    my $direction =
 	acos_real((sin($lat1) - sin($lat0) * cos($distance)) /
		  (cos($lat0) * sin($distance)));
  
    $direction = pi2 - $direction
	if sin($theta1 - $theta0) < 0;

    return rad2rad($direction);
}

*great_circle_bearing         = \&great_circle_direction;

sub great_circle_waypoint {
    my ( $theta0, $phi0, $theta1, $phi1, $point ) = @@_;

    $point = 0.5 unless defined $point;

    my $d = great_circle_distance( $theta0, $phi0, $theta1, $phi1 );

    return undef if $d == pi;

    my $sd = sin($d);

    return ($theta0, $phi0) if $sd == 0;

    my $A = sin((1 - $point) * $d) / $sd;
    my $B = sin(     $point  * $d) / $sd;

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    my $x = $A * cos($lat0) * cos($theta0) + $B * cos($lat1) * cos($theta1);
    my $y = $A * cos($lat0) * sin($theta0) + $B * cos($lat1) * sin($theta1);
    my $z = $A * sin($lat0)                + $B * sin($lat1);

    my $theta = atan2($y, $x);
    my $phi   = acos_real($z);

    return ($theta, $phi);
}

sub great_circle_midpoint {
    great_circle_waypoint(@@_[0..3], 0.5);
}

sub great_circle_destination {
    my ( $theta0, $phi0, $dir0, $dst ) = @@_;

    my $lat0 = pip2 - $phi0;

    my $phi1   = asin_real(sin($lat0)*cos($dst) +
			   cos($lat0)*sin($dst)*cos($dir0));

    my $theta1 = $theta0 + atan2(sin($dir0)*sin($dst)*cos($lat0),
				 cos($dst)-sin($lat0)*sin($phi1));

    my $dir1 = great_circle_bearing($theta1, $phi1, $theta0, $phi0) + pi;

    $dir1 -= pi2 if $dir1 > pi2;

    return ($theta1, $phi1, $dir1);
}

1;

__END__
=pod

=head1 NAME

Math::Trig - trigonometric functions

=head1 SYNOPSIS

    use Math::Trig;

    $x = tan(0.9);
    $y = acos(3.7);
    $z = asin(2.4);

    $halfpi = pi/2;

    $rad = deg2rad(120);

    # Import constants pi2, pip2, pip4 (2*pi, pi/2, pi/4).
    use Math::Trig ':pi';

    # Import the conversions between cartesian/spherical/cylindrical.
    use Math::Trig ':radial';

        # Import the great circle formulas.
    use Math::Trig ':great_circle';

=head1 DESCRIPTION

C<Math::Trig> defines many trigonometric functions not defined by the
core Perl which defines only the C<sin()> and C<cos()>.  The constant
B<pi> is also defined as are a few convenience functions for angle
conversions, and I<great circle formulas> for spherical movement.

=head1 TRIGONOMETRIC FUNCTIONS

The tangent

=over 4

=item B<tan>

=back

The cofunctions of the sine, cosine, and tangent (cosec/csc and cotan/cot
are aliases)

B<csc>, B<cosec>, B<sec>, B<sec>, B<cot>, B<cotan>

The arcus (also known as the inverse) functions of the sine, cosine,
and tangent

B<asin>, B<acos>, B<atan>

The principal value of the arc tangent of y/x

B<atan2>(y, x)

The arcus cofunctions of the sine, cosine, and tangent (acosec/acsc
and acotan/acot are aliases).  Note that atan2(0, 0) is not well-defined.

B<acsc>, B<acosec>, B<asec>, B<acot>, B<acotan>

The hyperbolic sine, cosine, and tangent

B<sinh>, B<cosh>, B<tanh>

The cofunctions of the hyperbolic sine, cosine, and tangent (cosech/csch
and cotanh/coth are aliases)

B<csch>, B<cosech>, B<sech>, B<coth>, B<cotanh>

The area (also known as the inverse) functions of the hyperbolic
sine, cosine, and tangent

B<asinh>, B<acosh>, B<atanh>

The area cofunctions of the hyperbolic sine, cosine, and tangent
(acsch/acosech and acoth/acotanh are aliases)

B<acsch>, B<acosech>, B<asech>, B<acoth>, B<acotanh>

The trigonometric constant B<pi> and some of handy multiples
of it are also defined.

B<pi, pi2, pi4, pip2, pip4>

=head2 ERRORS DUE TO DIVISION BY ZERO

The following functions

    acoth
    acsc
    acsch
    asec
    asech
    atanh
    cot
    coth
    csc
    csch
    sec
    sech
    tan
    tanh

cannot be computed for all arguments because that would mean dividing
by zero or taking logarithm of zero. These situations cause fatal
runtime errors looking like this

    cot(0): Division by zero.
    (Because in the definition of cot(0), the divisor sin(0) is 0)
    Died at ...

or

    atanh(-1): Logarithm of zero.
    Died at...

For the C<csc>, C<cot>, C<asec>, C<acsc>, C<acot>, C<csch>, C<coth>,
C<asech>, C<acsch>, the argument cannot be C<0> (zero).  For the
C<atanh>, C<acoth>, the argument cannot be C<1> (one).  For the
C<atanh>, C<acoth>, the argument cannot be C<-1> (minus one).  For the
C<tan>, C<sec>, C<tanh>, C<sech>, the argument cannot be I<pi/2 + k *
pi>, where I<k> is any integer.

Note that atan2(0, 0) is not well-defined.

=head2 SIMPLE (REAL) ARGUMENTS, COMPLEX RESULTS

Please note that some of the trigonometric functions can break out
from the B<real axis> into the B<complex plane>. For example
C<asin(2)> has no definition for plain real numbers but it has
definition for complex numbers.

In Perl terms this means that supplying the usual Perl numbers (also
known as scalars, please see L<perldata>) as input for the
trigonometric functions might produce as output results that no more
are simple real numbers: instead they are complex numbers.

The C<Math::Trig> handles this by using the C<Math::Complex> package
which knows how to handle complex numbers, please see L<Math::Complex>
for more information. In practice you need not to worry about getting
complex numbers as results because the C<Math::Complex> takes care of
details like for example how to display complex numbers. For example:

    print asin(2), "\n";

should produce something like this (take or leave few last decimals):

    1.5707963267949-1.31695789692482i

That is, a complex number with the real part of approximately C<1.571>
and the imaginary part of approximately C<-1.317>.

=head1 PLANE ANGLE CONVERSIONS

(Plane, 2-dimensional) angles may be converted with the following functions.

=over

=item deg2rad

    $radians  = deg2rad($degrees);

=item grad2rad

    $radians  = grad2rad($gradians);

=item rad2deg

    $degrees  = rad2deg($radians);

=item grad2deg

    $degrees  = grad2deg($gradians);

=item deg2grad

    $gradians = deg2grad($degrees);

=item rad2grad

    $gradians = rad2grad($radians);

=back

The full circle is 2 I<pi> radians or I<360> degrees or I<400> gradians.
The result is by default wrapped to be inside the [0, {2pi,360,400}[ circle.
If you don't want this, supply a true second argument:

    $zillions_of_radians  = deg2rad($zillions_of_degrees, 1);
    $negative_degrees     = rad2deg($negative_radians, 1);

You can also do the wrapping explicitly by rad2rad(), deg2deg(), and
grad2grad().

=over 4

=item rad2rad

    $radians_wrapped_by_2pi = rad2rad($radians);

=item deg2deg

    $degrees_wrapped_by_360 = deg2deg($degrees);

=item grad2grad

    $gradians_wrapped_by_400 = grad2grad($gradians);

=back

=head1 RADIAL COORDINATE CONVERSIONS

B<Radial coordinate systems> are the B<spherical> and the B<cylindrical>
systems, explained shortly in more detail.

You can import radial coordinate conversion functions by using the
C<:radial> tag:

    use Math::Trig ':radial';

    ($rho, $theta, $z)     = cartesian_to_cylindrical($x, $y, $z);
    ($rho, $theta, $phi)   = cartesian_to_spherical($x, $y, $z);
    ($x, $y, $z)           = cylindrical_to_cartesian($rho, $theta, $z);
    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
    ($x, $y, $z)           = spherical_to_cartesian($rho, $theta, $phi);
    ($rho_c, $theta, $z)   = spherical_to_cylindrical($rho_s, $theta, $phi);

B<All angles are in radians>.

=head2 COORDINATE SYSTEMS

B<Cartesian> coordinates are the usual rectangular I<(x, y, z)>-coordinates.

Spherical coordinates, I<(rho, theta, pi)>, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a sphere surface.  The radius of the sphere is B<rho>, also
known as the I<radial> coordinate.  The angle in the I<xy>-plane
(around the I<z>-axis) is B<theta>, also known as the I<azimuthal>
coordinate.  The angle from the I<z>-axis is B<phi>, also known as the
I<polar> coordinate.  The North Pole is therefore I<0, 0, rho>, and
the Gulf of Guinea (think of the missing big chunk of Africa) I<0,
pi/2, rho>.  In geographical terms I<phi> is latitude (northward
positive, southward negative) and I<theta> is longitude (eastward
positive, westward negative).

B<BEWARE>: some texts define I<theta> and I<phi> the other way round,
some texts define the I<phi> to start from the horizontal plane, some
texts use I<r> in place of I<rho>.

Cylindrical coordinates, I<(rho, theta, z)>, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a cylinder surface.  The radius of the cylinder is B<rho>,
also known as the I<radial> coordinate.  The angle in the I<xy>-plane
(around the I<z>-axis) is B<theta>, also known as the I<azimuthal>
coordinate.  The third coordinate is the I<z>, pointing up from the
B<theta>-plane.

=head2 3-D ANGLE CONVERSIONS

Conversions to and from spherical and cylindrical coordinates are
available.  Please notice that the conversions are not necessarily
reversible because of the equalities like I<pi> angles being equal to
I<-pi> angles.

=over 4

=item cartesian_to_cylindrical

    ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);

=item cartesian_to_spherical

    ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);

=item cylindrical_to_cartesian

    ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);

=item cylindrical_to_spherical

    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);

Notice that when C<$z> is not 0 C<$rho_s> is not equal to C<$rho_c>.

=item spherical_to_cartesian

    ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);

=item spherical_to_cylindrical

    ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);

Notice that when C<$z> is not 0 C<$rho_c> is not equal to C<$rho_s>.

=back

=head1 GREAT CIRCLE DISTANCES AND DIRECTIONS

A great circle is section of a circle that contains the circle
diameter: the shortest distance between two (non-antipodal) points on
the spherical surface goes along the great circle connecting those two
points.

=head2 great_circle_distance

You can compute spherical distances, called B<great circle distances>,
by importing the great_circle_distance() function:

  use Math::Trig 'great_circle_distance';

  $distance = great_circle_distance($theta0, $phi0, $theta1, $phi1, [, $rho]);

The I<great circle distance> is the shortest distance between two
points on a sphere.  The distance is in C<$rho> units.  The C<$rho> is
optional, it defaults to 1 (the unit sphere), therefore the distance
defaults to radians.

If you think geographically the I<theta> are longitudes: zero at the
Greenwhich meridian, eastward positive, westward negative -- and the
I<phi> are latitudes: zero at the North Pole, northward positive,
southward negative.  B<NOTE>: this formula thinks in mathematics, not
geographically: the I<phi> zero is at the North Pole, not at the
Equator on the west coast of Africa (Bay of Guinea).  You need to
subtract your geographical coordinates from I<pi/2> (also known as 90
degrees).

  $distance = great_circle_distance($lon0, pi/2 - $lat0,
                                    $lon1, pi/2 - $lat1, $rho);

=head2 great_circle_direction

The direction you must follow the great circle (also known as I<bearing>)
can be computed by the great_circle_direction() function:

  use Math::Trig 'great_circle_direction';

  $direction = great_circle_direction($theta0, $phi0, $theta1, $phi1);

=head2 great_circle_bearing

Alias 'great_circle_bearing' for 'great_circle_direction' is also available.

  use Math::Trig 'great_circle_bearing';

  $direction = great_circle_bearing($theta0, $phi0, $theta1, $phi1);

The result of great_circle_direction is in radians, zero indicating
straight north, pi or -pi straight south, pi/2 straight west, and
-pi/2 straight east.

=head2 great_circle_destination

You can inversely compute the destination if you know the
starting point, direction, and distance:

  use Math::Trig 'great_circle_destination';

  # $diro is the original direction,
  # for example from great_circle_bearing().
  # $distance is the angular distance in radians,
  # for example from great_circle_distance().
  # $thetad and $phid are the destination coordinates,
  # $dird is the final direction at the destination.

  ($thetad, $phid, $dird) =
    great_circle_destination($theta, $phi, $diro, $distance);

or the midpoint if you know the end points:

=head2 great_circle_midpoint

  use Math::Trig 'great_circle_midpoint';

  ($thetam, $phim) =
    great_circle_midpoint($theta0, $phi0, $theta1, $phi1);

The great_circle_midpoint() is just a special case of

=head2 great_circle_waypoint

  use Math::Trig 'great_circle_waypoint';

  ($thetai, $phii) =
    great_circle_waypoint($theta0, $phi0, $theta1, $phi1, $way);

Where the $way is a value from zero ($theta0, $phi0) to one ($theta1,
$phi1).  Note that antipodal points (where their distance is I<pi>
radians) do not have waypoints between them (they would have an an
"equator" between them), and therefore C<undef> is returned for
antipodal points.  If the points are the same and the distance
therefore zero and all waypoints therefore identical, the first point
(either point) is returned.

The thetas, phis, direction, and distance in the above are all in radians.

You can import all the great circle formulas by

  use Math::Trig ':great_circle';

Notice that the resulting directions might be somewhat surprising if
you are looking at a flat worldmap: in such map projections the great
circles quite often do not look like the shortest routes --  but for
example the shortest possible routes from Europe or North America to
Asia do often cross the polar regions.  (The common Mercator projection
does B<not> show great circles as straight lines: straight lines in the
Mercator projection are lines of constant bearing.)

=head1 EXAMPLES

To calculate the distance between London (51.3N 0.5W) and Tokyo
(35.7N 139.8E) in kilometers:

    use Math::Trig qw(great_circle_distance deg2rad);

    # Notice the 90 - latitude: phi zero is at the North Pole.
    sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }
    my @@L = NESW( -0.5, 51.3);
    my @@T = NESW(139.8, 35.7);
    my $km = great_circle_distance(@@L, @@T, 6378); # About 9600 km.

The direction you would have to go from London to Tokyo (in radians,
straight north being zero, straight east being pi/2).

    use Math::Trig qw(great_circle_direction);

    my $rad = great_circle_direction(@@L, @@T); # About 0.547 or 0.174 pi.

The midpoint between London and Tokyo being

    use Math::Trig qw(great_circle_midpoint);

    my @@M = great_circle_midpoint(@@L, @@T);

or about 69 N 89 E, in the frozen wastes of Siberia.

B<NOTE>: you B<cannot> get from A to B like this:

   Dist = great_circle_distance(A, B)
   Dir  = great_circle_direction(A, B)
   C    = great_circle_destination(A, Dist, Dir)

and expect C to be B, because the bearing constantly changes when
going from A to B (except in some special case like the meridians or
the circles of latitudes) and in great_circle_destination() one gives
a B<constant> bearing to follow.

=head2 CAVEAT FOR GREAT CIRCLE FORMULAS

The answers may be off by few percentages because of the irregular
(slightly aspherical) form of the Earth.  The errors are at worst
about 0.55%, but generally below 0.3%.

=head2 Real-valued asin and acos

For small inputs asin() and acos() may return complex numbers even
when real numbers would be enough and correct, this happens because of
floating-point inaccuracies.  You can see these inaccuracies for
example by trying theses:

  print cos(1e-6)**2+sin(1e-6)**2 - 1,"\n";
  printf "%.20f", cos(1e-6)**2+sin(1e-6)**2,"\n";

which will print something like this

  -1.11022302462516e-16
  0.99999999999999988898

even though the expected results are of course exactly zero and one.
The formulas used to compute asin() and acos() are quite sensitive to
this, and therefore they might accidentally slip into the complex
plane even when they should not.  To counter this there are two
interfaces that are guaranteed to return a real-valued output.

=over 4

=item asin_real

    use Math::Trig qw(asin_real);

    $real_angle = asin_real($input_sin);

Return a real-valued arcus sine if the input is between [-1, 1],
B<inclusive> the endpoints.  For inputs greater than one, pi/2
is returned.  For inputs less than minus one, -pi/2 is returned.

=item acos_real

    use Math::Trig qw(acos_real);

    $real_angle = acos_real($input_cos);

Return a real-valued arcus cosine if the input is between [-1, 1],
B<inclusive> the endpoints.  For inputs greater than one, zero
is returned.  For inputs less than minus one, pi is returned.

=back

=head1 BUGS

Saying C<use Math::Trig;> exports many mathematical routines in the
caller environment and even overrides some (C<sin>, C<cos>).  This is
construed as a feature by the Authors, actually... ;-)

The code is not optimized for speed, especially because we use
C<Math::Complex> and thus go quite near complex numbers while doing
the computations even when the arguments are not. This, however,
cannot be completely avoided if we want things like C<asin(2)> to give
an answer instead of giving a fatal runtime error.

Do not attempt navigation using these formulas.

L<Math::Complex>

=head1 AUTHORS

Jarkko Hietaniemi <F<jhi!at!iki.fi>> and 
Raphael Manfredi <F<Raphael_Manfredi!at!pobox.com>>.

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut

# eof
@


1.9
log
@Merge in perl 5.10.1
@
text
@@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d13 1
a13 1
use Math::Complex 1.36;
d20 1
a20 1
$VERSION = 1.04;
d26 2
d29 1
a29 1
	   @@angcnv);
d49 1
a49 1
@@EXPORT_OK = (@@rdlcnv, @@greatcircle, @@pi);
d97 16
d120 1
a120 1
             $rho ? acos( $z / $rho ) : 0 );
d162 2
a163 2
        acos(cos( $lat0 ) * cos( $lat1 ) * cos( $theta0 - $theta1 ) +
             sin( $lat0 ) * sin( $lat1 ) );
d169 1
a169 1
    my $distance = &great_circle_distance;
d175 3
a177 3
	acos((sin($lat1) - sin($lat0) * cos($distance)) /
	     (cos($lat0) * sin($distance)));

d184 1
a184 1
*great_circle_bearing = \&great_circle_direction;
d210 2
a211 2
    my $phi   = acos($z);
    
d224 3
a226 1
    my $phi1   = asin(sin($lat0)*cos($dst)+cos($lat0)*sin($dst)*cos($dir0));
d312 1
a312 1
The arcus (also known as the inverse) functions of the hyperbolic
d317 1
a317 1
The arcus cofunctions of the hyperbolic sine, cosine, and tangent
d561 1
a561 1
Greenwhich meridian, eastward positive, westward negative--and the
d593 2
a597 2
=head2 great_circle_destination

d600 6
a605 2
  # thetad and phid are the destination coordinates,
  # dird is the final direction at the destination.
d608 1
a608 1
    great_circle_destination($theta, $phi, $direction, $distance);
d644 1
a644 1
circles quite often do not look like the shortest routes-- but for
d646 3
a648 1
Asia do often cross the polar regions.
d676 12
a687 1
or about 89.16N 68.93E, practically at the North Pole.
d695 45
d754 2
d760 5
@


1.7
log
@merge in perl 5.8.8
@
text
@d10 1
a10 1
use 5.006;
d13 2
a14 2
use Math::Complex 1.35;
use Math::Complex qw(:trig);
d16 1
a16 1
our($VERSION, $PACKAGE, @@ISA, @@EXPORT, @@EXPORT_OK, %EXPORT_TAGS);
d20 1
a20 1
$VERSION = 1.03;
d45 1
a45 1
my @@pi = qw(pi2 pip2 pip4);
d57 6
a62 10
sub pi2  () { 2 * pi }
sub pip2 () { pi / 2 }
sub pip4 () { pi / 4 }

sub DR  () { pi2/360 }
sub RD  () { 360/pi2 }
sub DG  () { 400/360 }
sub GD  () { 360/400 }
sub RG  () { 400/pi2 }
sub GR  () { pi2/400 }
d68 1
a68 1
sub remt ($$) {
d77 1
a77 1
sub rad2rad($)     { remt($_[0], pi2) }
d79 1
a79 1
sub deg2deg($)     { remt($_[0], 360) }
d81 1
a81 1
sub grad2grad($)   { remt($_[0], 400) }
d83 1
a83 1
sub rad2deg ($;$)  { my $d = RD * $_[0]; $_[1] ? $d : deg2deg($d) }
d85 1
a85 1
sub deg2rad ($;$)  { my $d = DR * $_[0]; $_[1] ? $d : rad2rad($d) }
d87 1
a87 1
sub grad2deg ($;$) { my $d = GD * $_[0]; $_[1] ? $d : deg2deg($d) }
d89 1
a89 1
sub deg2grad ($;$) { my $d = DG * $_[0]; $_[1] ? $d : grad2grad($d) }
d91 1
a91 1
sub rad2grad ($;$) { my $d = RG * $_[0]; $_[1] ? $d : grad2grad($d) }
d93 1
a93 1
sub grad2rad ($;$) { my $d = GR * $_[0]; $_[1] ? $d : rad2rad($d) }
d192 1
a192 1
    my $phi   = atan2($z, sqrt($x*$x + $y*$y));
d228 1
a228 1
	use Math::Trig;
d230 3
a232 3
	$x = tan(0.9);
	$y = acos(3.7);
	$z = asin(2.4);
d234 1
a234 1
	$halfpi = pi/2;
d236 1
a236 1
	$rad = deg2rad(120);
d238 2
a239 2
        # Import constants pi2, pip2, pip4 (2*pi, pi/2, pi/4).
	use Math::Trig ':pi';
d241 2
a242 2
        # Import the conversions between cartesian/spherical/cylindrical.
	use Math::Trig ':radial';
d245 1
a245 1
	use Math::Trig ':great_circle';
d279 1
a279 1
and acotan/acot are aliases)
d302 2
a303 1
The trigonometric constant B<pi> is also defined.
d305 1
a305 1
$pi2 = 2 * B<pi>;
d311 14
a324 14
	acoth
	acsc
	acsch
	asec
	asech
	atanh
	cot
	coth
	csc
	csch
	sec
	sech
	tan
	tanh
d330 3
a332 3
	cot(0): Division by zero.
	(Because in the definition of cot(0), the divisor sin(0) is 0)
	Died at ...
d336 2
a337 2
	atanh(-1): Logarithm of zero.
	Died at...
d344 3
a346 1
pi>, where I<k> is any integer.  atan2(0, 0) is undefined.
d366 1
a366 1
	print asin(2), "\n";
d370 1
a370 1
	1.5707963267949-1.31695789692482i
d379 15
a393 2
	$radians  = deg2rad($degrees);
	$radians  = grad2rad($gradians);
d395 1
a395 2
	$degrees  = rad2deg($radians);
	$degrees  = grad2deg($gradians);
d397 9
a405 2
	$gradians = deg2grad($degrees);
	$gradians = rad2grad($radians);
d411 2
a412 2
	$zillions_of_radians  = deg2rad($zillions_of_degrees, 1);
	$negative_degrees     = rad2deg($negative_radians, 1);
d417 16
d491 1
a491 1
        ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);
d495 1
a495 1
        ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);
d499 1
a499 1
        ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);
d503 1
a503 1
        ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
d509 1
a509 1
        ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);
d513 1
a513 1
        ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);
d521 7
d552 2
d561 11
a571 3
(Alias 'great_circle_bearing' is also available.)
The result is in radians, zero indicating straight north, pi or -pi
straight south, pi/2 straight west, and -pi/2 straight east.
d576 2
d588 2
d597 2
d629 1
a629 1
        use Math::Trig qw(great_circle_distance deg2rad);
d631 5
a635 5
        # Notice the 90 - latitude: phi zero is at the North Pole.
	sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }
	my @@L = NESW( -0.5, 51.3);
        my @@T = NESW(139.8, 35.7);
        my $km = great_circle_distance(@@L, @@T, 6378); # About 9600 km.
d640 1
a640 1
        use Math::Trig qw(great_circle_direction);
d642 1
a642 1
        my $rad = great_circle_direction(@@L, @@T); # About 0.547 or 0.174 pi.
d646 1
a646 1
        use Math::Trig qw(great_circle_midpoint);
d648 1
a648 1
        my @@M = great_circle_midpoint(@@L, @@T);
d650 1
a650 1
or about 68.11N 24.74E, in the Finnish Lapland.
d674 2
a675 2
Jarkko Hietaniemi <F<jhi@@iki.fi>> and 
Raphael Manfredi <F<Raphael_Manfredi@@pobox.com>>.
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d13 1
d20 1
a20 1
$VERSION = 1.02;
d36 20
a55 3
@@EXPORT_OK = (@@rdlcnv, 'great_circle_distance', 'great_circle_direction');

%EXPORT_TAGS = ('radial' => [ @@rdlcnv ]);
d59 1
d170 51
d242 9
d256 1
a256 1
conversions.
d347 1
a347 1
pi>, where I<k> is any integer.
d420 1
a420 2
B<Cartesian> coordinates are the usual rectangular I<(x, y,
z)>-coordinates.
d428 2
a429 2
I<polar> coordinate.  The `North Pole' is therefore I<0, 0, rho>, and
the `Bay of Guinea' (think of the missing big chunk of Africa) I<0,
d511 2
a512 2
The direction you must follow the great circle can be computed by the
great_circle_direction() function:
d518 1
d522 39
d575 7
a581 2
	@@L = (deg2rad(-0.5), deg2rad(90 - 51.3));
        @@T = (deg2rad(139.8),deg2rad(90 - 35.7));
d583 5
a587 1
        $km = great_circle_distance(@@L, @@T, 6378);
d589 1
a589 1
The direction you would have to go from London to Tokyo
d591 1
a591 1
        use Math::Trig qw(great_circle_direction);
d593 1
a593 1
        $rad = great_circle_direction(@@L, @@T);
d598 2
a599 11
(slightly aspherical) form of the Earth.  The formula used for
grear circle distances

	lat0 = 90 degrees - phi0
	lat1 = 90 degrees - phi1
	d = R * arccos(cos(lat0) * cos(lat1) * cos(lon1 - lon01) +
                       sin(lat0) * sin(lat1))

is also somewhat unreliable for small distances (for locations
separated less than about five degrees) because it uses arc cosine
which is rather ill-conditioned for values close to zero.
d612 2
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d19 1
a19 1
$VERSION = 1.01;
d22 2
a23 2
	     deg2rad deg2grad
	     grad2rad grad2deg);
d136 2
d142 5
a146 3
	atan2(sin($theta0 - $theta1) * cos($lat1),
	      cos($lat0) * sin($lat1) -
	      sin($lat0) * cos($lat1) * cos($theta0 - $theta1));
d151 3
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d10 1
a10 1
use 5.005_64;
d19 1
a19 1
$VERSION = 1.00;
d35 1
a35 1
@@EXPORT_OK = (@@rdlcnv, 'great_circle_distance');
d133 14
d400 1
a400 1
=head1 GREAT CIRCLE DISTANCES
d403 1
a403 1
by importing the C<great_circle_distance> function:
d405 1
a405 1
	use Math::Trig 'great_circle_distance'
d426 16
d444 2
a445 2
To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N
139.8E) in kilometers:
d455 11
a465 2
The answer may be off by few percentages because of the irregular
(slightly aspherical) form of the Earth.  The used formula
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d39 9
a47 8
sub pi2 () { 2 * pi }		# use constant generates warning
sub pip2 () { pi / 2 }		# use constant generates warning
use constant DR   => pi2/360;
use constant RD   => 360/pi2;
use constant DG   => 400/360;
use constant GD   => 360/400;
use constant RG   => 400/pi2;
use constant GR   => pi2/400;
d62 5
a66 1
sub rad2deg ($)  { remt(RD * $_[0], 360) }
d68 1
a68 1
sub deg2rad ($)  { remt(DR * $_[0], pi2) }
d70 1
a70 1
sub grad2deg ($) { remt(GD * $_[0], 360) }
d72 1
a72 1
sub deg2grad ($) { remt(DG * $_[0], 400) }
d74 1
a74 1
sub rad2grad ($) { remt(RG * $_[0], 400) }
d76 3
a78 1
sub grad2rad ($) { remt(GR * $_[0], pi2) }
d290 8
@


1.2
log
@perl5.005_03 (stock)
@
text
@d10 1
d15 1
a15 3
use vars qw($VERSION $PACKAGE
	    @@ISA
	    @@EXPORT @@EXPORT_OK %EXPORT_TAGS);
d39 2
a40 2
use constant pi2  => 2 * pi;
use constant pip2 => pi / 2;
d135 1
a135 1
	
d139 1
a139 1
	
d261 1
a261 1
    
d275 1
a275 1
	
d278 1
a278 1
	
d411 10
a420 1
(slightly aspherical) form of the Earth.
d437 1
a437 1
Raphael Manfredi <F<Raphael_Manfredi@@grenoble.hp.com>>.
@


1.1
log
@perl 5.004_04
@
text
@d3 1
a3 1
# -- Jarkko Hietaniemi, April 1997
d16 1
a16 1
	    @@EXPORT);
d29 19
a47 7
use constant pi2 => 2 * pi;
use constant DR  => pi2/360;
use constant RD  => 360/pi2;
use constant DG  => 400/360;
use constant GD  => 360/400;
use constant RG  => 400/pi2;
use constant GR  => pi2/400;
d74 55
d156 5
a160 1
	tan
d165 1
a165 1
	csc cosec sec cot cotan
d170 1
a170 1
	asin acos atan
d174 1
a174 1
	atan2(y, x)
d179 1
a179 1
	acsc acosec asec acot acotan
d183 1
a183 1
	sinh cosh tanh
d188 1
a188 1
	csch cosech sech coth cotanh
d193 1
a193 1
	asinh acosh atanh
d198 1
a198 1
	acsch acosech asech acoth acotanh
d202 1
a202 1
	$pi2 = 2 * pi;
d208 12
a220 5
	sec
	csc
	cot
	asec
	acsc
a221 7
	sech
	csch
	coth
	atanh
	asech
	acsch
	acoth
d270 1
a270 1
=head1 ANGLE CONVERSIONS
d284 129
@


1.1.1.1
log
@perl5.005_03
@
text
@d3 1
a3 1
# -- Jarkko Hietaniemi, since April 1997
d16 1
a16 1
	    @@EXPORT @@EXPORT_OK %EXPORT_TAGS);
d29 7
a35 19
my @@rdlcnv = qw(cartesian_to_cylindrical
		cartesian_to_spherical
		cylindrical_to_cartesian
		cylindrical_to_spherical
		spherical_to_cartesian
		spherical_to_cylindrical);

@@EXPORT_OK = (@@rdlcnv, 'great_circle_distance');

%EXPORT_TAGS = ('radial' => [ @@rdlcnv ]);

use constant pi2  => 2 * pi;
use constant pip2 => pi / 2;
use constant DR   => pi2/360;
use constant RD   => 360/pi2;
use constant DG   => 400/360;
use constant GD   => 360/400;
use constant RG   => 400/pi2;
use constant GR   => pi2/400;
a61 55
sub cartesian_to_spherical {
    my ( $x, $y, $z ) = @@_;

    my $rho = sqrt( $x * $x + $y * $y + $z * $z );

    return ( $rho,
             atan2( $y, $x ),
             $rho ? acos( $z / $rho ) : 0 );
}

sub spherical_to_cartesian {
    my ( $rho, $theta, $phi ) = @@_;

    return ( $rho * cos( $theta ) * sin( $phi ),
             $rho * sin( $theta ) * sin( $phi ),
             $rho * cos( $phi   ) );
}

sub spherical_to_cylindrical {
    my ( $x, $y, $z ) = spherical_to_cartesian( @@_ );

    return ( sqrt( $x * $x + $y * $y ), $_[1], $z );
}

sub cartesian_to_cylindrical {
    my ( $x, $y, $z ) = @@_;

    return ( sqrt( $x * $x + $y * $y ), atan2( $y, $x ), $z );
}

sub cylindrical_to_cartesian {
    my ( $rho, $theta, $z ) = @@_;

    return ( $rho * cos( $theta ), $rho * sin( $theta ), $z );
}

sub cylindrical_to_spherical {
    return ( cartesian_to_spherical( cylindrical_to_cartesian( @@_ ) ) );
}

sub great_circle_distance {
    my ( $theta0, $phi0, $theta1, $phi1, $rho ) = @@_;

    $rho = 1 unless defined $rho; # Default to the unit sphere.

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    return $rho *
        acos(cos( $lat0 ) * cos( $lat1 ) * cos( $theta0 - $theta1 ) +
             sin( $lat0 ) * sin( $lat1 ) );
}

=pod

d89 1
a89 5
=over 4

=item B<tan>

=back
d94 1
a94 1
B<csc>, B<cosec>, B<sec>, B<sec>, B<cot>, B<cotan>
d99 1
a99 1
B<asin>, B<acos>, B<atan>
d103 1
a103 1
B<atan2>(y, x)
d108 1
a108 1
B<acsc>, B<acosec>, B<asec>, B<acot>, B<acotan>
d112 1
a112 1
B<sinh>, B<cosh>, B<tanh>
d117 1
a117 1
B<csch>, B<cosech>, B<sech>, B<coth>, B<cotanh>
d122 1
a122 1
B<asinh>, B<acosh>, B<atanh>
d127 1
a127 1
B<acsch>, B<acosech>, B<asech>, B<acoth>, B<acotanh>
d131 1
a131 1
$pi2 = 2 * B<pi>;
d137 5
a141 1
	acoth
d143 6
d150 1
a150 11
	asec
	asech
	atanh
	cot
	coth
	csc
	csch
	sec
	sech
	tan
	tanh
d199 1
a199 1
=head1 PLANE ANGLE CONVERSIONS
a212 129

=head1 RADIAL COORDINATE CONVERSIONS

B<Radial coordinate systems> are the B<spherical> and the B<cylindrical>
systems, explained shortly in more detail.

You can import radial coordinate conversion functions by using the
C<:radial> tag:

    use Math::Trig ':radial';

    ($rho, $theta, $z)     = cartesian_to_cylindrical($x, $y, $z);
    ($rho, $theta, $phi)   = cartesian_to_spherical($x, $y, $z);
    ($x, $y, $z)           = cylindrical_to_cartesian($rho, $theta, $z);
    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
    ($x, $y, $z)           = spherical_to_cartesian($rho, $theta, $phi);
    ($rho_c, $theta, $z)   = spherical_to_cylindrical($rho_s, $theta, $phi);

B<All angles are in radians>.

=head2 COORDINATE SYSTEMS

B<Cartesian> coordinates are the usual rectangular I<(x, y,
z)>-coordinates.

Spherical coordinates, I<(rho, theta, pi)>, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a sphere surface.  The radius of the sphere is B<rho>, also
known as the I<radial> coordinate.  The angle in the I<xy>-plane
(around the I<z>-axis) is B<theta>, also known as the I<azimuthal>
coordinate.  The angle from the I<z>-axis is B<phi>, also known as the
I<polar> coordinate.  The `North Pole' is therefore I<0, 0, rho>, and
the `Bay of Guinea' (think of the missing big chunk of Africa) I<0,
pi/2, rho>.  In geographical terms I<phi> is latitude (northward
positive, southward negative) and I<theta> is longitude (eastward
positive, westward negative).

B<BEWARE>: some texts define I<theta> and I<phi> the other way round,
some texts define the I<phi> to start from the horizontal plane, some
texts use I<r> in place of I<rho>.

Cylindrical coordinates, I<(rho, theta, z)>, are three-dimensional
coordinates which define a point in three-dimensional space.  They are
based on a cylinder surface.  The radius of the cylinder is B<rho>,
also known as the I<radial> coordinate.  The angle in the I<xy>-plane
(around the I<z>-axis) is B<theta>, also known as the I<azimuthal>
coordinate.  The third coordinate is the I<z>, pointing up from the
B<theta>-plane.

=head2 3-D ANGLE CONVERSIONS

Conversions to and from spherical and cylindrical coordinates are
available.  Please notice that the conversions are not necessarily
reversible because of the equalities like I<pi> angles being equal to
I<-pi> angles.

=over 4

=item cartesian_to_cylindrical

        ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);

=item cartesian_to_spherical

        ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);

=item cylindrical_to_cartesian

        ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);

=item cylindrical_to_spherical

        ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);

Notice that when C<$z> is not 0 C<$rho_s> is not equal to C<$rho_c>.

=item spherical_to_cartesian

        ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);

=item spherical_to_cylindrical

        ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);

Notice that when C<$z> is not 0 C<$rho_c> is not equal to C<$rho_s>.

=back

=head1 GREAT CIRCLE DISTANCES

You can compute spherical distances, called B<great circle distances>,
by importing the C<great_circle_distance> function:

	use Math::Trig 'great_circle_distance'

  $distance = great_circle_distance($theta0, $phi0, $theta1, $phi1, [, $rho]);

The I<great circle distance> is the shortest distance between two
points on a sphere.  The distance is in C<$rho> units.  The C<$rho> is
optional, it defaults to 1 (the unit sphere), therefore the distance
defaults to radians.

If you think geographically the I<theta> are longitudes: zero at the
Greenwhich meridian, eastward positive, westward negative--and the
I<phi> are latitudes: zero at the North Pole, northward positive,
southward negative.  B<NOTE>: this formula thinks in mathematics, not
geographically: the I<phi> zero is at the North Pole, not at the
Equator on the west coast of Africa (Bay of Guinea).  You need to
subtract your geographical coordinates from I<pi/2> (also known as 90
degrees).

  $distance = great_circle_distance($lon0, pi/2 - $lat0,
                                    $lon1, pi/2 - $lat1, $rho);

=head1 EXAMPLES

To calculate the distance between London (51.3N 0.5W) and Tokyo (35.7N
139.8E) in kilometers:

        use Math::Trig qw(great_circle_distance deg2rad);

        # Notice the 90 - latitude: phi zero is at the North Pole.
	@@L = (deg2rad(-0.5), deg2rad(90 - 51.3));
        @@T = (deg2rad(139.8),deg2rad(90 - 35.7));

        $km = great_circle_distance(@@L, @@T, 6378);

The answer may be off by few percentages because of the irregular
(slightly aspherical) form of the Earth.
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a9 1
use 5.005_64;
d14 3
a16 1
our($VERSION, $PACKAGE, @@ISA, @@EXPORT, @@EXPORT_OK, %EXPORT_TAGS);
d40 2
a41 2
sub pi2 () { 2 * pi }		# use constant generates warning
sub pip2 () { pi / 2 }		# use constant generates warning
d136 1
a136 1

d140 1
a140 1

d262 1
a262 1

d276 1
a276 1

d279 1
a279 1

d412 1
a412 10
(slightly aspherical) form of the Earth.  The used formula

	lat0 = 90 degrees - phi0
	lat1 = 90 degrees - phi1
	d = R * arccos(cos(lat0) * cos(lat1) * cos(lon1 - lon01) +
                       sin(lat0) * sin(lat1))

is also somewhat unreliable for small distances (for locations
separated less than about five degrees) because it uses arc cosine
which is rather ill-conditioned for values close to zero.
d429 1
a429 1
Raphael Manfredi <F<Raphael_Manfredi@@pobox.com>>.
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d39 8
a46 9
sub pi2  () { 2 * pi }
sub pip2 () { pi / 2 }

sub DR  () { pi2/360 }
sub RD  () { 360/pi2 }
sub DG  () { 400/360 }
sub GD  () { 360/400 }
sub RG  () { 400/pi2 }
sub GR  () { pi2/400 }
d61 1
a61 5
sub rad2rad($)     { remt($_[0], pi2) }

sub deg2deg($)     { remt($_[0], 360) }

sub grad2grad($)   { remt($_[0], 400) }
d63 1
a63 1
sub rad2deg ($;$)  { my $d = RD * $_[0]; $_[1] ? $d : deg2deg($d) }
d65 1
a65 1
sub deg2rad ($;$)  { my $d = DR * $_[0]; $_[1] ? $d : rad2rad($d) }
d67 1
a67 1
sub grad2deg ($;$) { my $d = GD * $_[0]; $_[1] ? $d : deg2deg($d) }
d69 1
a69 1
sub deg2grad ($;$) { my $d = DG * $_[0]; $_[1] ? $d : grad2grad($d) }
d71 1
a71 3
sub rad2grad ($;$) { my $d = RG * $_[0]; $_[1] ? $d : grad2grad($d) }

sub grad2rad ($;$) { my $d = GR * $_[0]; $_[1] ? $d : rad2rad($d) }
a282 8
The result is by default wrapped to be inside the [0, {2pi,360,400}[ circle.
If you don't want this, supply a true second argument:

	$zillions_of_radians  = deg2rad($zillions_of_degrees, 1);
	$negative_degrees     = rad2deg($negative_radians, 1);

You can also do the wrapping explicitly by rad2rad(), deg2deg(), and
grad2grad().
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d10 1
a10 1
use 5.006;
d19 1
a19 1
$VERSION = 1.01;
d35 1
a35 1
@@EXPORT_OK = (@@rdlcnv, 'great_circle_distance', 'great_circle_direction');
a132 14
sub great_circle_direction {
    my ( $theta0, $phi0, $theta1, $phi1 ) = @@_;

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    my $direction =
	atan2(sin($theta0 - $theta1) * cos($lat1),
	      cos($lat0) * sin($lat1) -
	      sin($lat0) * cos($lat1) * cos($theta0 - $theta1));

    return rad2rad($direction);
}

d386 1
a386 1
=head1 GREAT CIRCLE DISTANCES AND DIRECTIONS
d389 1
a389 1
by importing the great_circle_distance() function:
d391 1
a391 1
  use Math::Trig 'great_circle_distance';
a411 16
The direction you must follow the great circle can be computed by the
great_circle_direction() function:

  use Math::Trig 'great_circle_direction';

  $direction = great_circle_direction($theta0, $phi0, $theta1, $phi1);

The result is in radians, zero indicating straight north, pi or -pi
straight south, pi/2 straight west, and -pi/2 straight east.

Notice that the resulting directions might be somewhat surprising if
you are looking at a flat worldmap: in such map projections the great
circles quite often do not look like the shortest routes-- but for
example the shortest possible routes from Europe or North America to
Asia do often cross the polar regions.

d414 2
a415 2
To calculate the distance between London (51.3N 0.5W) and Tokyo
(35.7N 139.8E) in kilometers:
d425 2
a426 11
The direction you would have to go from London to Tokyo

        use Math::Trig qw(great_circle_direction);

        $rad = great_circle_direction(@@L, @@T);

=head2 CAVEAT FOR GREAT CIRCLE FORMULAS

The answers may be off by few percentages because of the irregular
(slightly aspherical) form of the Earth.  The formula used for
grear circle distances
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d19 1
a19 1
$VERSION = 1.02;
d22 2
a23 2
		deg2rad deg2grad
		grad2rad grad2deg);
a135 2
    my $distance = &great_circle_distance;

d140 3
a142 5
	acos((sin($lat1) - sin($lat0) * cos($distance)) /
	     (cos($lat0) * sin($distance)));

    $direction = pi2 - $direction
	if sin($theta1 - $theta0) < 0;
a146 3
1;

__END__
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@a12 1
use Math::Complex 1.35;
d19 1
a19 1
$VERSION = 1.03;
d35 3
a37 20
my @@greatcircle = qw(
		     great_circle_distance
		     great_circle_direction
		     great_circle_bearing
		     great_circle_waypoint
		     great_circle_midpoint
		     great_circle_destination
		    );

my @@pi = qw(pi2 pip2 pip4);

@@EXPORT_OK = (@@rdlcnv, @@greatcircle, @@pi);

# See e.g. the following pages:
# http://www.movable-type.co.uk/scripts/LatLong.html
# http://williams.best.vwh.net/avform.htm

%EXPORT_TAGS = ('radial' => [ @@rdlcnv ],
	        'great_circle' => [ @@greatcircle ],
	        'pi'     => [ @@pi ]);
a40 1
sub pip4 () { pi / 4 }
a150 51
*great_circle_bearing = \&great_circle_direction;

sub great_circle_waypoint {
    my ( $theta0, $phi0, $theta1, $phi1, $point ) = @@_;

    $point = 0.5 unless defined $point;

    my $d = great_circle_distance( $theta0, $phi0, $theta1, $phi1 );

    return undef if $d == pi;

    my $sd = sin($d);

    return ($theta0, $phi0) if $sd == 0;

    my $A = sin((1 - $point) * $d) / $sd;
    my $B = sin(     $point  * $d) / $sd;

    my $lat0 = pip2 - $phi0;
    my $lat1 = pip2 - $phi1;

    my $x = $A * cos($lat0) * cos($theta0) + $B * cos($lat1) * cos($theta1);
    my $y = $A * cos($lat0) * sin($theta0) + $B * cos($lat1) * sin($theta1);
    my $z = $A * sin($lat0)                + $B * sin($lat1);

    my $theta = atan2($y, $x);
    my $phi   = atan2($z, sqrt($x*$x + $y*$y));
    
    return ($theta, $phi);
}

sub great_circle_midpoint {
    great_circle_waypoint(@@_[0..3], 0.5);
}

sub great_circle_destination {
    my ( $theta0, $phi0, $dir0, $dst ) = @@_;

    my $lat0 = pip2 - $phi0;

    my $phi1   = asin(sin($lat0)*cos($dst)+cos($lat0)*sin($dst)*cos($dir0));
    my $theta1 = $theta0 + atan2(sin($dir0)*sin($dst)*cos($lat0),
				 cos($dst)-sin($lat0)*sin($phi1));

    my $dir1 = great_circle_bearing($theta1, $phi1, $theta0, $phi0) + pi;

    $dir1 -= pi2 if $dir1 > pi2;

    return ($theta1, $phi1, $dir1);
}

a171 9
        # Import constants pi2, pip2, pip4 (2*pi, pi/2, pi/4).
	use Math::Trig ':pi';

        # Import the conversions between cartesian/spherical/cylindrical.
	use Math::Trig ':radial';

        # Import the great circle formulas.
	use Math::Trig ':great_circle';

d177 1
a177 1
conversions, and I<great circle formulas> for spherical movement.
d268 1
a268 1
pi>, where I<k> is any integer.  atan2(0, 0) is undefined.
d341 2
a342 1
B<Cartesian> coordinates are the usual rectangular I<(x, y, z)>-coordinates.
d350 2
a351 2
I<polar> coordinate.  The North Pole is therefore I<0, 0, rho>, and
the Gulf of Guinea (think of the missing big chunk of Africa) I<0,
d433 2
a434 2
The direction you must follow the great circle (also known as I<bearing>)
can be computed by the great_circle_direction() function:
a439 1
(Alias 'great_circle_bearing' is also available.)
a442 39
You can inversely compute the destination if you know the
starting point, direction, and distance:

  use Math::Trig 'great_circle_destination';

  # thetad and phid are the destination coordinates,
  # dird is the final direction at the destination.

  ($thetad, $phid, $dird) =
    great_circle_destination($theta, $phi, $direction, $distance);

or the midpoint if you know the end points:

  use Math::Trig 'great_circle_midpoint';

  ($thetam, $phim) =
    great_circle_midpoint($theta0, $phi0, $theta1, $phi1);

The great_circle_midpoint() is just a special case of

  use Math::Trig 'great_circle_waypoint';

  ($thetai, $phii) =
    great_circle_waypoint($theta0, $phi0, $theta1, $phi1, $way);

Where the $way is a value from zero ($theta0, $phi0) to one ($theta1,
$phi1).  Note that antipodal points (where their distance is I<pi>
radians) do not have waypoints between them (they would have an an
"equator" between them), and therefore C<undef> is returned for
antipodal points.  If the points are the same and the distance
therefore zero and all waypoints therefore identical, the first point
(either point) is returned.

The thetas, phis, direction, and distance in the above are all in radians.

You can import all the great circle formulas by

  use Math::Trig ':great_circle';

d457 4
a460 4
	sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }
	my @@L = NESW( -0.5, 51.3);
        my @@T = NESW(139.8, 35.7);
        my $km = great_circle_distance(@@L, @@T, 6378); # About 9600 km.
d462 1
a462 2
The direction you would have to go from London to Tokyo (in radians,
straight north being zero, straight east being pi/2).
d466 1
a466 9
        my $rad = great_circle_direction(@@L, @@T); # About 0.547 or 0.174 pi.

The midpoint between London and Tokyo being

        use Math::Trig qw(great_circle_midpoint);

        my @@M = great_circle_midpoint(@@L, @@T);

or about 68.11N 24.74E, in the Finnish Lapland.
d471 11
a481 2
(slightly aspherical) form of the Earth.  The errors are at worst
about 0.55%, but generally below 0.3%.
a493 2

Do not attempt navigation using these formulas.
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d10 1
a10 1
use 5.005;
d13 2
a14 2
use Math::Complex 1.36;
use Math::Complex qw(:trig :pi);
d16 1
a16 1
use vars qw($VERSION $PACKAGE @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS);
d20 1
a20 1
$VERSION = 1.04;
d45 1
a45 1
my @@pi = qw(pi pi2 pi4 pip2 pip4);
d57 10
a66 6
sub _DR  () { pi2/360 }
sub _RD  () { 360/pi2 }
sub _DG  () { 400/360 }
sub _GD  () { 360/400 }
sub _RG  () { 400/pi2 }
sub _GR  () { pi2/400 }
d72 1
a72 1
sub _remt ($$) {
d81 1
a81 1
sub rad2rad($)     { _remt($_[0], pi2) }
d83 1
a83 1
sub deg2deg($)     { _remt($_[0], 360) }
d85 1
a85 1
sub grad2grad($)   { _remt($_[0], 400) }
d87 1
a87 1
sub rad2deg ($;$)  { my $d = _RD * $_[0]; $_[1] ? $d : deg2deg($d) }
d89 1
a89 1
sub deg2rad ($;$)  { my $d = _DR * $_[0]; $_[1] ? $d : rad2rad($d) }
d91 1
a91 1
sub grad2deg ($;$) { my $d = _GD * $_[0]; $_[1] ? $d : deg2deg($d) }
d93 1
a93 1
sub deg2grad ($;$) { my $d = _DG * $_[0]; $_[1] ? $d : grad2grad($d) }
d95 1
a95 1
sub rad2grad ($;$) { my $d = _RG * $_[0]; $_[1] ? $d : grad2grad($d) }
d97 1
a97 1
sub grad2rad ($;$) { my $d = _GR * $_[0]; $_[1] ? $d : rad2rad($d) }
d196 1
a196 1
    my $phi   = acos($z);
d232 1
a232 1
    use Math::Trig;
d234 3
a236 3
    $x = tan(0.9);
    $y = acos(3.7);
    $z = asin(2.4);
d238 1
a238 1
    $halfpi = pi/2;
d240 1
a240 1
    $rad = deg2rad(120);
d242 2
a243 2
    # Import constants pi2, pip2, pip4 (2*pi, pi/2, pi/4).
    use Math::Trig ':pi';
d245 2
a246 2
    # Import the conversions between cartesian/spherical/cylindrical.
    use Math::Trig ':radial';
d249 1
a249 1
    use Math::Trig ':great_circle';
d283 1
a283 1
and acotan/acot are aliases).  Note that atan2(0, 0) is not well-defined.
d306 1
a306 2
The trigonometric constant B<pi> and some of handy multiples
of it are also defined.
d308 1
a308 1
B<pi, pi2, pi4, pip2, pip4>
d314 14
a327 14
    acoth
    acsc
    acsch
    asec
    asech
    atanh
    cot
    coth
    csc
    csch
    sec
    sech
    tan
    tanh
d333 3
a335 3
    cot(0): Division by zero.
    (Because in the definition of cot(0), the divisor sin(0) is 0)
    Died at ...
d339 2
a340 2
    atanh(-1): Logarithm of zero.
    Died at...
d347 1
a347 3
pi>, where I<k> is any integer.

Note that atan2(0, 0) is not well-defined.
d367 1
a367 1
    print asin(2), "\n";
d371 1
a371 1
    1.5707963267949-1.31695789692482i
d380 2
a381 15
=over

=item deg2rad

    $radians  = deg2rad($degrees);

=item grad2rad

    $radians  = grad2rad($gradians);

=item rad2deg

    $degrees  = rad2deg($radians);

=item grad2deg
d383 2
a384 1
    $degrees  = grad2deg($gradians);
d386 2
a387 9
=item deg2grad

    $gradians = deg2grad($degrees);

=item rad2grad

    $gradians = rad2grad($radians);

=back
d393 2
a394 2
    $zillions_of_radians  = deg2rad($zillions_of_degrees, 1);
    $negative_degrees     = rad2deg($negative_radians, 1);
a398 16
=over 4

=item rad2rad

    $radians_wrapped_by_2pi = rad2rad($radians);

=item deg2deg

    $degrees_wrapped_by_360 = deg2deg($degrees);

=item grad2grad

    $gradians_wrapped_by_400 = grad2grad($gradians);

=back

d457 1
a457 1
    ($rho, $theta, $z) = cartesian_to_cylindrical($x, $y, $z);
d461 1
a461 1
    ($rho, $theta, $phi) = cartesian_to_spherical($x, $y, $z);
d465 1
a465 1
    ($x, $y, $z) = cylindrical_to_cartesian($rho, $theta, $z);
d469 1
a469 1
    ($rho_s, $theta, $phi) = cylindrical_to_spherical($rho_c, $theta, $z);
d475 1
a475 1
    ($x, $y, $z) = spherical_to_cartesian($rho, $theta, $phi);
d479 1
a479 1
    ($rho_c, $theta, $z) = spherical_to_cylindrical($rho_s, $theta, $phi);
a486 7
A great circle is section of a circle that contains the circle
diameter: the shortest distance between two (non-antipodal) points on
the spherical surface goes along the great circle connecting those two
points.

=head2 great_circle_distance

a510 2
=head2 great_circle_direction

d518 3
a520 11
=head2 great_circle_bearing

Alias 'great_circle_bearing' for 'great_circle_direction' is also available.

  use Math::Trig 'great_circle_bearing';

  $direction = great_circle_bearing($theta0, $phi0, $theta1, $phi1);

The result of great_circle_direction is in radians, zero indicating
straight north, pi or -pi straight south, pi/2 straight west, and
-pi/2 straight east.
a524 2
=head2 great_circle_destination

a534 2
=head2 great_circle_midpoint

a541 2
=head2 great_circle_waypoint

d572 1
a572 1
    use Math::Trig qw(great_circle_distance deg2rad);
d574 5
a578 5
    # Notice the 90 - latitude: phi zero is at the North Pole.
    sub NESW { deg2rad($_[0]), deg2rad(90 - $_[1]) }
    my @@L = NESW( -0.5, 51.3);
    my @@T = NESW(139.8, 35.7);
    my $km = great_circle_distance(@@L, @@T, 6378); # About 9600 km.
d583 1
a583 1
    use Math::Trig qw(great_circle_direction);
d585 1
a585 1
    my $rad = great_circle_direction(@@L, @@T); # About 0.547 or 0.174 pi.
d589 1
a589 1
    use Math::Trig qw(great_circle_midpoint);
d591 1
a591 1
    my @@M = great_circle_midpoint(@@L, @@T);
d593 1
a593 1
or about 89.16N 68.93E, practically at the North Pole.
d617 2
a618 2
Jarkko Hietaniemi <F<jhi!at!iki.fi>> and 
Raphael Manfredi <F<Raphael_Manfredi!at!pobox.com>>.
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d13 1
a13 1
use Math::Complex 1.56;
d20 1
a20 1
$VERSION = 1.20;
a25 2
my @@areal = qw(asin_real acos_real);

d27 1
a27 1
	   @@angcnv, @@areal);
d47 1
a47 1
@@EXPORT_OK = (@@rdlcnv, @@greatcircle, @@pi, 'Inf');
a94 16
#
# acos and asin functions which always return a real number
#

sub acos_real {
    return 0  if $_[0] >=  1;
    return pi if $_[0] <= -1;
    return acos($_[0]);
}

sub asin_real {
    return  &pip2 if $_[0] >=  1;
    return -&pip2 if $_[0] <= -1;
    return asin($_[0]);
}

d102 1
a102 1
             $rho ? acos_real( $z / $rho ) : 0 );
d144 2
a145 2
	acos_real( cos( $lat0 ) * cos( $lat1 ) * cos( $theta0 - $theta1 ) +
		   sin( $lat0 ) * sin( $lat1 ) );
d151 1
a151 1
    my $distance = great_circle_distance($theta0, $phi0, $theta1, $phi1);
d157 3
a159 3
 	acos_real((sin($lat1) - sin($lat0) * cos($distance)) /
		  (cos($lat0) * sin($distance)));
  
d166 1
a166 1
*great_circle_bearing         = \&great_circle_direction;
d192 2
a193 2
    my $phi   = acos_real($z);

d206 1
a206 3
    my $phi1   = asin_real(sin($lat0)*cos($dst) +
			   cos($lat0)*sin($dst)*cos($dir0));

d292 1
a292 1
The area (also known as the inverse) functions of the hyperbolic
d297 1
a297 1
The area cofunctions of the hyperbolic sine, cosine, and tangent
d541 1
a541 1
Greenwhich meridian, eastward positive, westward negative -- and the
a572 2
=head2 great_circle_destination

d576 2
d580 2
a581 6
  # $diro is the original direction,
  # for example from great_circle_bearing().
  # $distance is the angular distance in radians,
  # for example from great_circle_distance().
  # $thetad and $phid are the destination coordinates,
  # $dird is the final direction at the destination.
d584 1
a584 1
    great_circle_destination($theta, $phi, $diro, $distance);
d620 1
a620 1
circles quite often do not look like the shortest routes --  but for
d622 1
a622 3
Asia do often cross the polar regions.  (The common Mercator projection
does B<not> show great circles as straight lines: straight lines in the
Mercator projection are lines of constant bearing.)
d650 1
a650 12
or about 69 N 89 E, in the frozen wastes of Siberia.

B<NOTE>: you B<cannot> get from A to B like this:

   Dist = great_circle_distance(A, B)
   Dir  = great_circle_direction(A, B)
   C    = great_circle_destination(A, Dist, Dir)

and expect C to be B, because the bearing constantly changes when
going from A to B (except in some special case like the meridians or
the circles of latitudes) and in great_circle_destination() one gives
a B<constant> bearing to follow.
a657 45
=head2 Real-valued asin and acos

For small inputs asin() and acos() may return complex numbers even
when real numbers would be enough and correct, this happens because of
floating-point inaccuracies.  You can see these inaccuracies for
example by trying theses:

  print cos(1e-6)**2+sin(1e-6)**2 - 1,"\n";
  printf "%.20f", cos(1e-6)**2+sin(1e-6)**2,"\n";

which will print something like this

  -1.11022302462516e-16
  0.99999999999999988898

even though the expected results are of course exactly zero and one.
The formulas used to compute asin() and acos() are quite sensitive to
this, and therefore they might accidentally slip into the complex
plane even when they should not.  To counter this there are two
interfaces that are guaranteed to return a real-valued output.

=over 4

=item asin_real

    use Math::Trig qw(asin_real);

    $real_angle = asin_real($input_sin);

Return a real-valued arcus sine if the input is between [-1, 1],
B<inclusive> the endpoints.  For inputs greater than one, pi/2
is returned.  For inputs less than minus one, -pi/2 is returned.

=item acos_real

    use Math::Trig qw(acos_real);

    $real_angle = acos_real($input_cos);

Return a real-valued arcus cosine if the input is between [-1, 1],
B<inclusive> the endpoints.  For inputs greater than one, zero
is returned.  For inputs less than minus one, pi is returned.

=back

a671 2
L<Math::Complex>

a675 5

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 
@


