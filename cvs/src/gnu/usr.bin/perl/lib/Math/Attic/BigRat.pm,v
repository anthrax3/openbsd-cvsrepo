head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.7.0.4
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.2
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.10
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.8
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.6
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.4
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.2
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.4.0.6
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.4
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.2
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.42;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.06;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.47.12;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2005.01.15.21.17.22;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.51;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.37;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.53;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@
#
# "Tax the rat farms."
#

# The following hash values are used:
#   sign : +,-,NaN,+inf,-inf
#   _d   : denominator
#   _n   : numeraotr (value = _n/_d)
#   _a   : accuracy
#   _p   : precision
#   _f   : flags, used by MBR to flag parts of a rational as untouchable

package Math::BigRat;

require 5.005_03;
use strict;

use Exporter;
use Math::BigFloat;
use vars qw($VERSION @@ISA $PACKAGE @@EXPORT_OK $upgrade $downgrade
            $accuracy $precision $round_mode $div_scale);

@@ISA = qw(Exporter Math::BigFloat);
@@EXPORT_OK = qw();

$VERSION = '0.07';

use overload;				# inherit from Math::BigFloat

##############################################################################
# global constants, flags and accessory

use constant MB_NEVER_ROUND => 0x0001;

$accuracy = $precision = undef;
$round_mode = 'even';
$div_scale = 40;
$upgrade = undef;
$downgrade = undef;

my $nan = 'NaN';
my $class = 'Math::BigRat';
my $MBI = 'Math::BigInt';

sub isa
  {
  return 0 if $_[1] =~ /^Math::Big(Int|Float)/;		# we aren't
  UNIVERSAL::isa(@@_);
  }

sub _new_from_float
  {
  # turn a single float input into a rational (like '0.1')
  my ($self,$f) = @@_;

  return $self->bnan() if $f->is_nan();
  return $self->binf('-inf') if $f->{sign} eq '-inf';
  return $self->binf('+inf') if $f->{sign} eq '+inf';

  #print "f $f caller", join(' ',caller()),"\n";
  $self->{_n} = $f->{_m}->copy();			# mantissa
  $self->{_d} = $MBI->bone();
  $self->{sign} = $f->{sign}; $self->{_n}->{sign} = '+';
  if ($f->{_e}->{sign} eq '-')
    {
    # something like Math::BigRat->new('0.1');
    $self->{_d}->blsft($f->{_e}->copy()->babs(),10);	# 1 / 1 => 1/10
    }
  else
    {
    # something like Math::BigRat->new('10');
    # 1 / 1 => 10/1
    $self->{_n}->blsft($f->{_e},10) unless $f->{_e}->is_zero();	
    }
  $self;
  }

sub new
  {
  # create a Math::BigRat
  my $class = shift;

  my ($n,$d) = shift;

  my $self = { }; bless $self,$class;
 
  # input like (BigInt,BigInt) or (BigFloat,BigFloat) not handled yet

  if ((!defined $d) && (ref $n) && (!$n->isa('Math::BigRat')))
    {
    if ($n->isa('Math::BigFloat'))
      {
      return $self->_new_from_float($n)->bnorm();
      }
    if ($n->isa('Math::BigInt'))
      {
      $self->{_n} = $n->copy();				# "mantissa" = $n
      $self->{_d} = $MBI->bone();
      $self->{sign} = $self->{_n}->{sign}; $self->{_n}->{sign} = '+';
      return $self->bnorm();
      }
    if ($n->isa('Math::BigInt::Lite'))
      {
      $self->{_n} = $MBI->new($$n);		# "mantissa" = $n
      $self->{_d} = $MBI->bone();
      $self->{sign} = $self->{_n}->{sign}; $self->{_n}->{sign} = '+';
      return $self->bnorm();
      }
    }
  return $n->copy() if ref $n;

  if (!defined $n)
    {
    $self->{_n} = $MBI->bzero();	# undef => 0
    $self->{_d} = $MBI->bone();
    $self->{sign} = '+';
    return $self->bnorm();
    }
  # string input with / delimiter
  if ($n =~ /\s*\/\s*/)
    {
    return Math::BigRat->bnan() if $n =~ /\/.*\//;	# 1/2/3 isn't valid
    return Math::BigRat->bnan() if $n =~ /\/\s*$/;	# 1/ isn't valid
    ($n,$d) = split (/\//,$n);
    # try as BigFloats first
    if (($n =~ /[\.eE]/) || ($d =~ /[\.eE]/))
      {
      # one of them looks like a float 
      $self->_new_from_float(Math::BigFloat->new($n));
      # now correct $self->{_n} due to $n
      my $f = Math::BigFloat->new($d);
      if ($f->{_e}->{sign} eq '-')
        {
	# 10 / 0.1 => 100/1
        $self->{_n}->blsft($f->{_e}->copy()->babs(),10);
        }
      else
        {
        $self->{_d}->blsft($f->{_e},10); 		# 1 / 1 => 10/1
         }
      }
    else
      {
      $self->{_n} = $MBI->new($n);
      $self->{_d} = $MBI->new($d);
      return $self->bnan() if $self->{_n}->is_nan() || $self->{_d}->is_nan();
      # inf handling is missing here
 
      $self->{sign} = $self->{_n}->{sign}; $self->{_n}->{sign} = '+';
      # if $d is negative, flip sign
      $self->{sign} =~ tr/+-/-+/ if $self->{_d}->{sign} eq '-';
      $self->{_d}->{sign} = '+';	# normalize
      }
    return $self->bnorm();
    }

  # simple string input
  if (($n =~ /[\.eE]/))
    {
    # work around bug in BigFloat that makes 1.1.2 valid
    return $self->bnan() if $n =~ /\..*\./;
    # looks like a float
    $self->_new_from_float(Math::BigFloat->new($n));
    }
  else
    {
    $self->{_n} = $MBI->new($n);
    $self->{_d} = $MBI->bone();
    $self->{sign} = $self->{_n}->{sign}; $self->{_n}->{sign} = '+';
    return $self->bnan() if $self->{sign} eq 'NaN';
    return $self->binf($self->{sign}) if $self->{sign} =~ /^[+-]inf$/;
    }
  $self->bnorm();
  }

###############################################################################

sub bstr
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  if ($x->{sign} !~ /^[+-]$/)		# inf, NaN etc
    {
    my $s = $x->{sign}; $s =~ s/^\+//; 	# +inf => inf
    return $s;
    }

  my $s = ''; $s = $x->{sign} if $x->{sign} ne '+';	# +3 vs 3

  return $s.$x->{_n}->bstr() if $x->{_d}->is_one(); 
  return $s.$x->{_n}->bstr() . '/' . $x->{_d}->bstr(); 
  }

sub bsstr
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  if ($x->{sign} !~ /^[+-]$/)		# inf, NaN etc
    {
    my $s = $x->{sign}; $s =~ s/^\+//; 	# +inf => inf
    return $s;
    }
  
  my $s = ''; $s = $x->{sign} if $x->{sign} ne '+';	# +3 vs 3
  return $x->{_n}->bstr() . '/' . $x->{_d}->bstr(); 
  }

sub bnorm
  {
  # reduce the number to the shortest form and remember this (so that we
  # don't reduce again)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  # both parts must be BigInt's
  die ("n is not $MBI but (".ref($x->{_n}).')')
    if ref($x->{_n}) ne $MBI;
  die ("d is not $MBI but (".ref($x->{_d}).')')
    if ref($x->{_d}) ne $MBI;

  # this is to prevent automatically rounding when MBI's globals are set
  $x->{_d}->{_f} = MB_NEVER_ROUND;
  $x->{_n}->{_f} = MB_NEVER_ROUND;
  # 'forget' that parts were rounded via MBI::bround() in MBF's bfround()
  $x->{_d}->{_a} = undef; $x->{_n}->{_a} = undef;
  $x->{_d}->{_p} = undef; $x->{_n}->{_p} = undef; 

  # no normalize for NaN, inf etc.
  return $x if $x->{sign} !~ /^[+-]$/;

  # normalize zeros to 0/1
  if (($x->{sign} =~ /^[+-]$/) &&
      ($x->{_n}->is_zero()))
    {
    $x->{sign} = '+';					# never -0
    $x->{_d} = $MBI->bone() unless $x->{_d}->is_one();
    return $x;
    }

  return $x if $x->{_d}->is_one();			# no need to reduce

  # reduce other numbers
  # disable upgrade in BigInt, otherwise deep recursion
  local $Math::BigInt::upgrade = undef;
  my $gcd = $x->{_n}->bgcd($x->{_d});

  if (!$gcd->is_one())
    {
    $x->{_n}->bdiv($gcd);
    $x->{_d}->bdiv($gcd);
    }
  $x;
  }

##############################################################################
# special values

sub _bnan
  {
  # used by parent class bone() to initialize number to 1
  my $self = shift;
  $self->{_n} = $MBI->bzero();
  $self->{_d} = $MBI->bzero();
  }

sub _binf
  {
  # used by parent class bone() to initialize number to 1
  my $self = shift;
  $self->{_n} = $MBI->bzero();
  $self->{_d} = $MBI->bzero();
  }

sub _bone
  {
  # used by parent class bone() to initialize number to 1
  my $self = shift;
  $self->{_n} = $MBI->bone();
  $self->{_d} = $MBI->bone();
  }

sub _bzero
  {
  # used by parent class bone() to initialize number to 1
  my $self = shift;
  $self->{_n} = $MBI->bzero();
  $self->{_d} = $MBI->bone();
  }

##############################################################################
# mul/add/div etc

sub badd
  {
  # add two rationals
  my ($self,$x,$y,$a,$p,$r) = objectify(2,@@_);

  $x = $self->new($x) unless $x->isa($self);
  $y = $self->new($y) unless $y->isa($self);

  return $x->bnan() if ($x->{sign} eq 'NaN' || $y->{sign} eq 'NaN');

  #  1   1    gcd(3,4) = 1    1*3 + 1*4    7
  #  - + -                  = --------- = --                 
  #  4   3                      4*3       12

  my $gcd = $x->{_d}->bgcd($y->{_d});

  my $aa = $x->{_d}->copy();
  my $bb = $y->{_d}->copy(); 
  if ($gcd->is_one())
    {
    $bb->bdiv($gcd); $aa->bdiv($gcd);
    }
  $x->{_n}->bmul($bb); $x->{_n}->{sign} = $x->{sign};
  my $m = $y->{_n}->copy()->bmul($aa);
  $m->{sign} = $y->{sign};			# 2/1 - 2/1
  $x->{_n}->badd($m);

  $x->{_d}->bmul($y->{_d});

  # calculate new sign
  $x->{sign} = $x->{_n}->{sign}; $x->{_n}->{sign} = '+';

  $x->bnorm()->round($a,$p,$r);
  }

sub bsub
  {
  # subtract two rationals
  my ($self,$x,$y,$a,$p,$r) = objectify(2,@@_);

  $x = $class->new($x) unless $x->isa($class);
  $y = $class->new($y) unless $y->isa($class);

  return $x->bnan() if ($x->{sign} eq 'NaN' || $y->{sign} eq 'NaN');
  # TODO: inf handling

  #  1   1    gcd(3,4) = 1    1*3 + 1*4    7
  #  - + -                  = --------- = --                 
  #  4   3                      4*3       12

  my $gcd = $x->{_d}->bgcd($y->{_d});

  my $aa = $x->{_d}->copy();
  my $bb = $y->{_d}->copy(); 
  if ($gcd->is_one())
    {
    $bb->bdiv($gcd); $aa->bdiv($gcd);
    }
  $x->{_n}->bmul($bb); $x->{_n}->{sign} = $x->{sign};
  my $m = $y->{_n}->copy()->bmul($aa);
  $m->{sign} = $y->{sign};			# 2/1 - 2/1
  $x->{_n}->bsub($m);

  $x->{_d}->bmul($y->{_d});
  
  # calculate new sign
  $x->{sign} = $x->{_n}->{sign}; $x->{_n}->{sign} = '+';

  $x->bnorm()->round($a,$p,$r);
  }

sub bmul
  {
  # multiply two rationals
  my ($self,$x,$y,$a,$p,$r) = objectify(2,@@_);

  $x = $class->new($x) unless $x->isa($class);
  $y = $class->new($y) unless $y->isa($class);

  return $x->bnan() if ($x->{sign} eq 'NaN' || $y->{sign} eq 'NaN');

  # inf handling
  if (($x->{sign} =~ /^[+-]inf$/) || ($y->{sign} =~ /^[+-]inf$/))
    {
    return $x->bnan() if $x->is_zero() || $y->is_zero();
    # result will always be +-inf:
    # +inf * +/+inf => +inf, -inf * -/-inf => +inf
    # +inf * -/-inf => -inf, -inf * +/+inf => -inf
    return $x->binf() if ($x->{sign} =~ /^\+/ && $y->{sign} =~ /^\+/);
    return $x->binf() if ($x->{sign} =~ /^-/ && $y->{sign} =~ /^-/);
    return $x->binf('-');
    }

  # x== 0 # also: or y == 1 or y == -1
  return wantarray ? ($x,$self->bzero()) : $x if $x->is_zero();

  # According to Knuth, this can be optimized by doingtwice gcd (for d and n)
  # and reducing in one step)

  #  1   1    2    1
  #  - * - =  -  = -
  #  4   3    12   6
  $x->{_n}->bmul($y->{_n});
  $x->{_d}->bmul($y->{_d});

  # compute new sign
  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-';

  $x->bnorm()->round($a,$p,$r);
  }

sub bdiv
  {
  # (dividend: BRAT or num_str, divisor: BRAT or num_str) return
  # (BRAT,BRAT) (quo,rem) or BRAT (only rem)
  my ($self,$x,$y,$a,$p,$r) = objectify(2,@@_);

  $x = $class->new($x) unless $x->isa($class);
  $y = $class->new($y) unless $y->isa($class);

  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());

  # x== 0 # also: or y == 1 or y == -1
  return wantarray ? ($x,$self->bzero()) : $x if $x->is_zero();

  # TODO: list context, upgrade

  # 1     1    1   3
  # -  /  - == - * -
  # 4     3    4   1
  $x->{_n}->bmul($y->{_d});
  $x->{_d}->bmul($y->{_n});

  # compute new sign 
  $x->{sign} = $x->{sign} eq $y->{sign} ? '+' : '-';

  $x->bnorm()->round($a,$p,$r);
  $x;
  }

##############################################################################
# bdec/binc

sub bdec
  {
  # decrement value (subtract 1)
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);

  return $x if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf

  if ($x->{sign} eq '-')
    {
    $x->{_n}->badd($x->{_d});	# -5/2 => -7/2
    }
  else
    {
    if ($x->{_n}->bacmp($x->{_d}) < 0)
      {
      # 1/3 -- => -2/3
      $x->{_n} = $x->{_d} - $x->{_n};
      $x->{sign} = '-';
      }
    else
      {
      $x->{_n}->bsub($x->{_d});		# 5/2 => 3/2
      }
    }
  $x->bnorm()->round(@@r);

  #$x->bsub($self->bone())->round(@@r);
  }

sub binc
  {
  # increment value (add 1)
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
  
  return $x if $x->{sign} !~ /^[+-]$/;	# NaN, inf, -inf

  if ($x->{sign} eq '-')
    {
    if ($x->{_n}->bacmp($x->{_d}) < 0)
      {
      # -1/3 ++ => 2/3 (overflow at 0)
      $x->{_n} = $x->{_d} - $x->{_n};
      $x->{sign} = '+';
      }
    else
      {
      $x->{_n}->bsub($x->{_d});		# -5/2 => -3/2
      }
    }
  else
    {
    $x->{_n}->badd($x->{_d});	# 5/2 => 7/2
    }
  $x->bnorm()->round(@@r);

  #$x->badd($self->bone())->round(@@r);
  }

##############################################################################
# is_foo methods (the rest is inherited)

sub is_int
  {
  # return true if arg (BRAT or num_str) is an integer
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return 1 if ($x->{sign} =~ /^[+-]$/) &&	# NaN and +-inf aren't
    $x->{_d}->is_one();				# 1e-1 => no integer
  0;
  }

sub is_zero
  {
  # return true if arg (BRAT or num_str) is zero
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return 1 if $x->{sign} eq '+' && $x->{_n}->is_zero();
  0;
  }

sub is_one
  {
  # return true if arg (BRAT or num_str) is +1 or -1 if signis given
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  my $sign = shift || ''; $sign = '+' if $sign ne '-';
  return 1
   if ($x->{sign} eq $sign && $x->{_n}->is_one() && $x->{_d}->is_one());
  0;
  }

sub is_odd
  {
  # return true if arg (BFLOAT or num_str) is odd or false if even
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return 1 if ($x->{sign} =~ /^[+-]$/) &&		# NaN & +-inf aren't
    ($x->{_d}->is_one() && $x->{_n}->is_odd());		# x/2 is not, but 3/1
  0;
  }

sub is_even
  {
  # return true if arg (BINT or num_str) is even or false if odd
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return 0 if $x->{sign} !~ /^[+-]$/;			# NaN & +-inf aren't
  return 1 if ($x->{_d}->is_one()			# x/3 is never
     && $x->{_n}->is_even());				# but 4/1 is
  0;
  }

BEGIN
  {
  *objectify = \&Math::BigInt::objectify;
  }

##############################################################################
# parts() and friends

sub numerator
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return $MBI->new($x->{sign}) if ($x->{sign} !~ /^[+-]$/);

  my $n = $x->{_n}->copy(); $n->{sign} = $x->{sign};
  $n;
  }

sub denominator
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return $MBI->new($x->{sign}) if ($x->{sign} !~ /^[+-]$/);
  $x->{_d}->copy(); 
  }

sub parts
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return ($self->bnan(),$self->bnan()) if $x->{sign} eq 'NaN';
  return ($self->binf(),$self->binf()) if $x->{sign} eq '+inf';
  return ($self->binf('-'),$self->binf()) if $x->{sign} eq '-inf';

  my $n = $x->{_n}->copy();
  $n->{sign} = $x->{sign};
  return ($n,$x->{_d}->copy());
  }

sub length
  {
  return 0;
  }

sub digit
  {
  return 0;
  }

##############################################################################
# special calc routines

sub bceil
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return $x unless $x->{sign} =~ /^[+-]$/;
  return $x if $x->{_d}->is_one();		# 22/1 => 22, 0/1 => 0

  $x->{_n}->bdiv($x->{_d});			# 22/7 => 3/1 w/ truncate
  $x->{_d}->bone();
  $x->{_n}->binc() if $x->{sign} eq '+';	# +22/7 => 4/1
  $x->{sign} = '+' if $x->{_n}->is_zero();	# -0 => 0
  $x;
  }

sub bfloor
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return $x unless $x->{sign} =~ /^[+-]$/;
  return $x if $x->{_d}->is_one();		# 22/1 => 22, 0/1 => 0

  $x->{_n}->bdiv($x->{_d});			# 22/7 => 3/1 w/ truncate
  $x->{_d}->bone();
  $x->{_n}->binc() if $x->{sign} eq '-';	# -22/7 => -4/1
  $x;
  }

sub bfac
  {
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);

  if (($x->{sign} eq '+') && ($x->{_d}->is_one()))
    {
    $x->{_n}->bfac();
    return $x->round(@@r);
    }
  $x->bnan();
  }

sub bpow
  {
  my ($self,$x,$y,@@r) = objectify(2,@@_);

  return $x if $x->{sign} =~ /^[+-]inf$/;       # -inf/+inf ** x
  return $x->bnan() if $x->{sign} eq $nan || $y->{sign} eq $nan;
  return $x->bone(@@r) if $y->is_zero();
  return $x->round(@@r) if $x->is_one() || $y->is_one();
  if ($x->{sign} eq '-' && $x->{_n}->is_one() && $x->{_d}->is_one())
    {
    # if $x == -1 and odd/even y => +1/-1
    return $y->is_odd() ? $x->round(@@r) : $x->babs()->round(@@r);
    # my Casio FX-5500L has a bug here: -1 ** 2 is -1, but -1 * -1 is 1;
    }
  # 1 ** -y => 1 / (1 ** |y|)
  # so do test for negative $y after above's clause
 #  return $x->bnan() if $y->{sign} eq '-';
  return $x->round(@@r) if $x->is_zero();  # 0**y => 0 (if not y <= 0)

  # shortcut y/1 (and/or x/1)
  if ($y->{_d}->is_one())
    {
    # shortcut for x/1 and y/1
    if ($x->{_d}->is_one())
      {
      $x->{_n}->bpow($y->{_n});		# x/1 ** y/1 => (x ** y)/1
      if ($y->{sign} eq '-')
        {
        # 0.2 ** -3 => 1/(0.2 ** 3)
        ($x->{_n},$x->{_d}) = ($x->{_d},$x->{_n});	# swap
        }
      # correct sign; + ** + => +
      if ($x->{sign} eq '-')
        {
        # - * - => +, - * - * - => -
        $x->{sign} = '+' if $y->{_n}->is_even();	
        }
      return $x->round(@@r);
      }
    # x/z ** y/1
    $x->{_n}->bpow($y->{_n});		# 5/2 ** y/1 => 5 ** y / 2 ** y
    $x->{_d}->bpow($y->{_n});
    if ($y->{sign} eq '-')
      {
      # 0.2 ** -3 => 1/(0.2 ** 3)
      ($x->{_n},$x->{_d}) = ($x->{_d},$x->{_n});	# swap
      }
    # correct sign; + ** + => +
    if ($x->{sign} eq '-')
      {
      # - * - => +, - * - * - => -
      $x->{sign} = '+' if $y->{_n}->is_even();	
      }
    return $x->round(@@r);
    }

  # regular calculation (this is wrong for d/e ** f/g)
  my $pow2 = $self->__one();
  my $y1 = $MBI->new($y->{_n}/$y->{_d})->babs();
  my $two = $MBI->new(2);
  while (!$y1->is_one())
    {
    $pow2->bmul($x) if $y1->is_odd();
    $y1->bdiv($two);
    $x->bmul($x);
    }
  $x->bmul($pow2) unless $pow2->is_one();
  # n ** -x => 1/n ** x
  ($x->{_d},$x->{_n}) = ($x->{_n},$x->{_d}) if $y->{sign} eq '-'; 
  $x;
  #$x->round(@@r);
  }

sub blog
  {
  return Math::BigRat->bnan();
  }

sub bsqrt
  {
  my ($self,$x,$a,$p,$r) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return $x->bnan() if $x->{sign} ne '+';	# inf, NaN, -1 etc
  $x->{_d}->bsqrt($a,$p,$r);
  $x->{_n}->bsqrt($a,$p,$r);
  $x->bnorm();
  }

sub blsft
  {
  my ($self,$x,$y,$b,$a,$p,$r) = objectify(3,@@_);
 
  $x->bmul( $b->copy()->bpow($y), $a,$p,$r);
  $x;
  }

sub brsft
  {
  my ($self,$x,$y,$b,$a,$p,$r) = objectify(2,@@_);

  $x->bdiv( $b->copy()->bpow($y), $a,$p,$r);
  $x;
  }

##############################################################################
# round

sub round
  {
  $_[0];
  }

sub bround
  {
  $_[0];
  }

sub bfround
  {
  $_[0];
  }

##############################################################################
# comparing

sub bcmp
  {
  my ($self,$x,$y) = objectify(2,@@_);

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;
    return +1 if $x->{sign} eq '+inf';
    return -1 if $x->{sign} eq '-inf';
    return -1 if $y->{sign} eq '+inf';
    return +1;
    }
  # check sign for speed first
  return 1 if $x->{sign} eq '+' && $y->{sign} eq '-';   # does also 0 <=> -y
  return -1 if $x->{sign} eq '-' && $y->{sign} eq '+';  # does also -x <=> 0

  # shortcut
  my $xz = $x->{_n}->is_zero();
  my $yz = $y->{_n}->is_zero();
  return 0 if $xz && $yz;                               # 0 <=> 0
  return -1 if $xz && $y->{sign} eq '+';                # 0 <=> +y
  return 1 if $yz && $x->{sign} eq '+';                 # +x <=> 0
 
  my $t = $x->{_n} * $y->{_d}; $t->{sign} = $x->{sign};
  my $u = $y->{_n} * $x->{_d}; $u->{sign} = $y->{sign};
  $t->bcmp($u);
  }

sub bacmp
  {
  my ($self,$x,$y) = objectify(2,@@_);

  if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/))
    {
    # handle +-inf and NaN
    return undef if (($x->{sign} eq $nan) || ($y->{sign} eq $nan));
    return 0 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} =~ /^[+-]inf$/;
    return +1;  # inf is always bigger
    }

  my $t = $x->{_n} * $y->{_d};
  my $u = $y->{_n} * $x->{_d};
  $t->bacmp($u);
  }

##############################################################################
# output conversation

sub as_number
  {
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);

  return $x if $x->{sign} !~ /^[+-]$/;			# NaN, inf etc 
  my $t = $x->{_n}->copy()->bdiv($x->{_d});		# 22/7 => 3
  $t->{sign} = $x->{sign};
  $t;
  }

sub import
  {
  my $self = shift;
  my $l = scalar @@_;
  my $lib = ''; my @@a;
  for ( my $i = 0; $i < $l ; $i++)
    {
#    print "at $_[$i] (",$_[$i+1]||'undef',")\n";
    if ( $_[$i] eq ':constant' )
      {
      # this rest causes overlord er load to step in
      # print "overload @@_\n";
      overload::constant float => sub { $self->new(shift); };
      }
#    elsif ($_[$i] eq 'upgrade')
#      {
#     # this causes upgrading
#      $upgrade = $_[$i+1];              # or undef to disable
#      $i++;
#      }
    elsif ($_[$i] eq 'downgrade')
      {
      # this causes downgrading
      $downgrade = $_[$i+1];            # or undef to disable
      $i++;
      }
    elsif ($_[$i] eq 'lib')
      {
      $lib = $_[$i+1] || '';            # default Calc
      $i++;
      }
    elsif ($_[$i] eq 'with')
      {
      $MBI = $_[$i+1] || 'Math::BigInt';        # default Math::BigInt
      $i++;
      }
    else
      {
      push @@a, $_[$i];
      }
    }
  # let use Math::BigInt lib => 'GMP'; use Math::BigFloat; still work
  my $mbilib = eval { Math::BigInt->config()->{lib} };
  if ((defined $mbilib) && ($MBI eq 'Math::BigInt'))
    {
    # MBI already loaded
    $MBI->import('lib',"$lib,$mbilib", 'objectify');
    }
  else
    {
    # MBI not loaded, or not with "Math::BigInt"
    $lib .= ",$mbilib" if defined $mbilib;

    if ($] < 5.006)
      {
      # Perl < 5.6.0 dies with "out of memory!" when eval() and ':constant' is
      # used in the same script, or eval inside import().
      my @@parts = split /::/, $MBI;             # Math::BigInt => Math BigInt
      my $file = pop @@parts; $file .= '.pm';    # BigInt => BigInt.pm
      $file = File::Spec->catfile (@@parts, $file);
      eval { require $file; $MBI->import( lib => '$lib', 'objectify' ); }
      }
    else
      {
      my $rc = "use $MBI lib => '$lib', 'objectify';";
      eval $rc;
      }
    }
  die ("Couldn't load $MBI: $! $@@") if $@@;

  # any non :constant stuff is handled by our parent, Exporter
  # even if @@_ is empty, to give it a chance
  $self->SUPER::import(@@a);             # for subclasses
  $self->export_to_level(1,$self,@@a);   # need this, too
  }

1;

__END__

=head1 NAME

Math::BigRat - arbitrarily big rationals

=head1 SYNOPSIS

  use Math::BigRat;

  $x = Math::BigRat->new('3/7');

  print $x->bstr(),"\n";

=head1 DESCRIPTION

This is just a placeholder until the real thing is up and running. Watch this
space...

=head2 MATH LIBRARY

Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:

	use Math::BigRat lib => 'Calc';

You can change this by using:

	use Math::BigRat lib => 'BitVect';

The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:

	use Math::BigRat lib => 'Foo,Math::BigInt::Bar';

Calc.pm uses as internal format an array of elements of some decimal base
(usually 1e7, but this might be differen for some systems) with the least
significant digit first, while BitVect.pm uses a bit vector of base 2, most
significant bit first. Other modules might use even different means of
representing the numbers. See the respective module documentation for further
details.

=head1 METHODS

Any method not listed here is dervied from Math::BigFloat (or
Math::BigInt), so make sure you check these two modules for further
information.

=head2 new()

	$x = Math::BigRat->new('1/3');

Create a new Math::BigRat object. Input can come in various forms:

	$x = Math::BigRat->new('1/3');				# simple string
	$x = Math::BigRat->new('1 / 3');			# spaced
	$x = Math::BigRat->new('1 / 0.1');			# w/ floats
	$x = Math::BigRat->new(Math::BigInt->new(3));		# BigInt
	$x = Math::BigRat->new(Math::BigFloat->new('3.1'));	# BigFloat
	$x = Math::BigRat->new(Math::BigInt::Lite->new('2'));	# BigLite

=head2 numerator()

	$n = $x->numerator();

Returns a copy of the numerator (the part above the line) as signed BigInt.

=head2 denominator()
	
	$d = $x->denominator();

Returns a copy of the denominator (the part under the line) as positive BigInt.

=head2 parts()

	($n,$d) = $x->parts();

Return a list consisting of (signed) numerator and (unsigned) denominator as
BigInts.

=head2 as_number()

Returns a copy of the object as BigInt by truncating it to integer.

=head2 bfac()

	$x->bfac();

Calculates the factorial of $x. For instance:

	print Math::BigRat->new('3/1')->bfac(),"\n";	# 1*2*3
	print Math::BigRat->new('5/1')->bfac(),"\n";	# 1*2*3*4*5

Only works for integers for now.

=head2 blog()

Is not yet implemented.

=head2 bround()/round()/bfround()

Are not yet implemented.


=head1 BUGS

Some things are not yet implemented, or only implemented half-way.

=head1 LICENSE

This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.

=head1 SEE ALSO

L<Math::BigFloat> and L<Math::Big> as well as L<Math::BigInt::BitVect>,
L<Math::BigInt::Pari> and  L<Math::BigInt::GMP>.

The package at
L<http://search.cpan.org/search?mode=module&query=Math%3A%3ABigRat> may
contain more documentation and examples as well as testcases.

=head1 AUTHORS

(C) by Tels L<http://bloodgate.com/> 2001-2002. 

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
# "Tax the rat farms." - Lord Vetinari
d22 1
a22 1
            $accuracy $precision $round_mode $div_scale $_trap_nan $_trap_inf);
d27 1
a27 1
$VERSION = '0.10';
d29 1
a29 1
use overload;			# inherit from Math::BigFloat
d34 2
a41 7
# these are internally, and not to be used from the outside

use constant MB_NEVER_ROUND => 0x0001;

$_trap_nan = 0;                         # are NaNs ok? set w/ config()
$_trap_inf = 0;                         # are infs ok? set w/ config()

d61 1
d64 1
a64 1
  $self->{sign} = $f->{sign} || '+'; $self->{_n}->{sign} = '+';
a97 1
      # TODO: trap NaN, inf
d105 1
a105 3
      # TODO: trap NaN, inf
      $self->{sign} = '+'; $self->{sign} = '-' if $$n < 0;
      $self->{_n} = $MBI->new(abs($$n),undef,undef);	# "mantissa" = $n
d107 1
d115 1
a115 1
    $self->{_n} = $MBI->bzero();			# undef => 0
d123 2
a124 2
    return $class->bnan() if $n =~ /\/.*\//;	# 1/2/3 isn't valid
    return $class->bnan() if $n =~ /\/\s*$/;	# 1/ isn't valid
d130 1
a130 9
      # Math::BigFloat($n,undef,undef) does not what it is supposed to do, so:
      local $Math::BigFloat::accuracy = undef;
      local $Math::BigFloat::precision = undef;
      local $Math::BigInt::accuracy = undef;
      local $Math::BigInt::precision = undef;
      my $nf = Math::BigFloat->new($n);
      $self->{sign} = '+';
      return $self->bnan() if $nf->is_nan();
      $self->{_n} = $nf->{_m};
d132 2
a133 12
      my $f = Math::BigFloat->new($d,undef,undef);
      $self->{_d} = $f->{_m};
      return $self->bnan() if $f->is_nan();
      #print "n=$nf e$nf->{_e} d=$f e$f->{_e}\n";
      # calculate the difference between nE and dE
      my $diff_e = $nf->{_e}->copy()->bsub ( $f->{_e} );
      if ($diff_e->is_negative())
	{
        # < 0: mul d with it
        $self->{_d}->blsft($diff_e->babs(),10);
	}
      elsif (!$diff_e->is_zero())
d135 2
a136 2
        # > 0: mul n with it
        $self->{_n}->blsft($diff_e,10);
d138 4
d145 4
a148 17
      # both d and n are (big)ints
      $self->{_n} = $MBI->new($n,undef,undef);
      $self->{_d} = $MBI->new($d,undef,undef);
      $self->{sign} = '+';
      return $self->bnan() if $self->{_n}->{sign} eq $nan ||
                              $self->{_d}->{sign} eq $nan;
      # handle inf and NAN cases:
      if ($self->{_n}->is_inf() || $self->{_d}->is_inf())
        {
        # inf/inf => NaN
        return $self->bnan() if
	  ($self->{_n}->is_inf() && $self->{_d}->is_inf());
        # +-inf/123 => +-inf
        return $self->binf($self->{sign}) if $self->{_n}->is_inf();
        # 123/inf => 0
        return $self->bzero();
        }
d150 1
a150 1
      $self->{sign} = $self->{_n}->{sign}; $self->{_n}->babs();
d153 1
a153 1
      $self->{_d}->babs();				# normalize
a154 1

d161 4
a164 8
    # looks like a float, quacks like a float, so probably is a float
    # Math::BigFloat($n,undef,undef) does not what it is supposed to do, so:
    local $Math::BigFloat::accuracy = undef;
    local $Math::BigFloat::precision = undef;
    local $Math::BigInt::accuracy = undef;
    local $Math::BigInt::precision = undef;
    $self->{sign} = 'NaN';
    $self->_new_from_float(Math::BigFloat->new($n,undef,undef));
d168 1
a168 1
    $self->{_n} = $MBI->new($n,undef,undef);
d170 1
a170 1
    $self->{sign} = $self->{_n}->{sign}; $self->{_n}->babs();
d177 1
a177 16
##############################################################################

sub config
  {
  # return (later set?) configuration data as hash ref
  my $class = shift || 'Math::BigFloat';

  my $cfg = $class->SUPER::config(@@_);

  # now we need only to override the ones that are different from our parent
  $cfg->{class} = $class;
  $cfg->{with} = $MBI;
  $cfg;
  }

##############################################################################
d206 1
a206 1
  return $s . $x->{_n}->bstr() . '/' . $x->{_d}->bstr(); 
d215 5
a219 9
  # both parts must be BigInt's (or whatever we are using today)
  if (ref($x->{_n}) ne $MBI)
    {
    require Carp; Carp::croak ("n is not $MBI but (".ref($x->{_n}).')');
    }
  if (ref($x->{_d}) ne $MBI)
    {
    require Carp; Carp::croak ("d is not $MBI but (".ref($x->{_d}).')');
    }
a244 2
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
d260 1
a260 1
  # used by parent class bnan() to initialize number to NaN
a261 7

  if ($_trap_nan)
    {
    require Carp;
    my $class = ref($self);
    Carp::croak ("Tried to set $self to NaN in $class\::_bnan()");
    }
d268 1
a268 1
  # used by parent class bone() to initialize number to +inf/-inf
a269 7

  if ($_trap_inf)
    {
    require Carp;
    my $class = ref($self);
    Carp::croak ("Tried to set $self to inf in $class\::_binf()");
    }
d276 1
a276 1
  # used by parent class bone() to initialize number to +1/-1
d284 1
a284 1
  # used by parent class bzero() to initialize number to 0
d296 1
a296 8

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }
a301 1
  # TODO: inf handling
d307 1
a307 6
  # we do not compute the gcd() here, but simple do:
  #  5   7    5*3 + 7*4   41
  #  - + -  = --------- = --                 
  #  4   3       4*3      12
 
  # the gcd() calculation and reducing is then done in bnorm()
d309 8
a316 5
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;

  $x->{_n}->bmul($y->{_d}); $x->{_n}->{sign} = $x->{sign};
  my $m = $y->{_n}->copy()->bmul($x->{_d});
d325 1
a325 1
  $x->bnorm()->round(@@r);
d331 1
a332 9
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  # TODO: $self instead or $class??
d339 2
a340 2
  #  1   1    gcd(3,4) = 1    1*3 - 1*4    7
  #  - - -                  = --------- = --                 
a341 5
  
  # we do not compute the gcd() here, but simple do:
  #  5   7    5*3 - 7*4     13
  #  - - -  = --------- = - --
  #  4   3       4*3        12
d343 1
a343 2
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
d345 8
a352 2
  $x->{_n}->bmul($y->{_d}); $x->{_n}->{sign} = $x->{sign};
  my $m = $y->{_n}->copy()->bmul($x->{_d});
d361 1
a361 1
  $x->bnorm()->round(@@r);
d367 1
a367 8
  
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }
a368 1
  # TODO: $self instead or $class??
a394 3
  
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
d401 1
a401 1
  $x->bnorm()->round(@@r);
d408 1
a409 9
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  # TODO: $self instead or $class??
a423 3
  
#  local $Math::BigInt::accuracy = undef;
#  local $Math::BigInt::precision = undef;
d430 1
a430 1
  $x->bnorm()->round(@@r);
a433 56
sub bmod
  {
  # compute "remainder" (in Perl way) of $x / $y

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  # TODO: $self instead or $class??
  $x = $class->new($x) unless $x->isa($class);
  $y = $class->new($y) unless $y->isa($class);

  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());

  return $self->_div_inf($x,$y)
   if (($x->{sign} !~ /^[+-]$/) || ($y->{sign} !~ /^[+-]$/) || $y->is_zero());

  return $x if $x->is_zero();           # 0 / 7 = 0, mod 0

  # compute $x - $y * floor($x/$y), keeping the sign of $x

  # locally disable these, since they would interfere
  local $Math::BigInt::upgrade = undef;
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;

  my $u = $x->copy()->babs();
  # first, do a "normal" division ($x/$y)
  $u->{_d}->bmul($y->{_n});
  $u->{_n}->bmul($y->{_d});

  # compute floor
  if (!$u->{_d}->is_one())
    {
    $u->{_n}->bdiv($u->{_d});			# 22/7 => 3/1 w/ truncate
    # no need to set $u->{_d} to 1, since later we set it to $y->{_d}
    #$x->{_n}->binc() if $x->{sign} eq '-';	# -22/7 => -4/1
    }
  
  # compute $y * $u
  $u->{_d} = $y->{_d};			# 1 * $y->{_d}, see floor above
  $u->{_n}->bmul($y->{_n});

  my $xsign = $x->{sign}; $x->{sign} = '+';	# remember sign and make abs
  # compute $x - $u
  $x->bsub($u);
  $x->{sign} = $xsign;				# put sign back

  $x->bnorm()->round(@@r);
  }

d462 2
d491 2
d504 1
a504 1
    $x->{_d}->is_one();				# x/y && y != 1 => no integer
a607 3
  local $Math::BigInt::upgrade = undef;
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
a621 3
  local $Math::BigInt::upgrade = undef;
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
d642 1
a642 9
  # power ($x ** $y)

  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }
d709 2
a710 1
  $x->bnorm()->round(@@r);
d720 1
a720 1
  my ($self,$x,@@r) = ref($_[0]) ? (ref($_[0]),@@_) : objectify(1,@@_);
d722 4
a725 31
  return $x->bnan() if $x->{sign} !~ /^[+]/;    # NaN, -inf or < 0
  return $x if $x->{sign} eq '+inf';            # sqrt(inf) == inf
  return $x->round(@@r) if $x->is_zero() || $x->is_one();

  local $Math::BigFloat::upgrade = undef;
  local $Math::BigFloat::downgrade = undef;
  local $Math::BigFloat::precision = undef;
  local $Math::BigFloat::accuracy = undef;
  local $Math::BigInt::upgrade = undef;
  local $Math::BigInt::precision = undef;
  local $Math::BigInt::accuracy = undef;
  $x->{_d} = Math::BigFloat->new($x->{_d})->bsqrt();
  $x->{_n} = Math::BigFloat->new($x->{_n})->bsqrt();

  # if sqrt(D) was not integer
  if ($x->{_d}->{_e}->{sign} ne '+')
    {
    $x->{_n}->blsft($x->{_d}->{_e}->babs(),10);		# 7.1/4.51 => 7.1/45.1
    $x->{_d} = $x->{_d}->{_m};				# 7.1/45.1 => 71/45.1
    }
  # if sqrt(N) was not integer
  if ($x->{_n}->{_e}->{sign} ne '+')
    {
    $x->{_d}->blsft($x->{_n}->{_e}->babs(),10);		# 71/45.1 => 710/45.1
    $x->{_n} = $x->{_n}->{_m};				# 710/45.1 => 710/451
    }
 
  # convert parts to $MBI again 
  $x->{_n} = $x->{_n}->as_number();
  $x->{_d} = $x->{_d}->as_number();
  $x->bnorm()->round(@@r);
a814 15
sub numify
  {
  # convert 17/8 => float (aka 2.125)
  my ($self,$x) = ref($_[0]) ? (ref($_[0]),$_[0]) : objectify(1,@@_);
 
  return $x->bstr() if $x->{sign} !~ /^[+-]$/;	# inf, NaN, etc

  # N/1 => N
  return $x->{_n}->numify() if $x->{_d}->is_one();

  # N/D
  my $neg = 1; $neg = -1 if $x->{sign} ne '+';
  $neg * $x->{_n}->numify() / $x->{_d}->numify();	# return sign * N/D
  }

d819 1
a819 6
  return $x if $x->{sign} !~ /^[+-]$/;			# NaN, inf etc
 
  # need to disable these, otherwise bdiv() gives BigRat again
  local $Math::BigInt::upgrade = undef;
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
d893 1
a893 4
  if ($@@)
    {
    require Carp; Carp::croak ("Couldn't load $MBI: $! $@@");
    }
d911 1
a911 1
	use Math::BigRat;
d913 1
a913 1
	$x = Math::BigRat->new('3/7'); $x += '5/9';
d915 1
a915 2
	print $x->bstr(),"\n";
  	print $x ** 2,"\n";
d919 2
a920 2
Math::BigRat complements Math::BigInt and Math::BigFloat by providing support
for arbitrarily big rationals.
d939 1
a939 1
(usually 1e7, but this might be different for some systems) with the least
a944 7
Currently the following replacement libraries exist, search for them at CPAN:

	Math::BigInt::BitVect
	Math::BigInt::GMP
	Math::BigInt::Pari
	Math::BigInt::FastCalc

d947 1
a947 1
Any methods not listed here are dervied from Math::BigFloat (or
a956 2
	$x = Math::BigRat->new(123);				# scalars
	$x = Math::BigRat->new('123.3');			# float
d985 1
a985 4
	$x = Math::BigRat->new('13/7');
	print $x->as_number(),"\n";		# '1'

Returns a copy of the object as BigInt trunced it to integer.
d996 1
a996 1
Works currently only for integers.
a1005 109
=head2 bmod()

	use Math::BigRat;
	my $x = Math::BigRat->new('7/4');
	my $y = Math::BigRat->new('4/3');
	print $x->bmod($y);

Set $x to the remainder of the division of $x by $y.

=head2 is_one()

	print "$x is 1\n" if $x->is_one();

Return true if $x is exactly one, otherwise false.

=head2 is_zero()

	print "$x is 0\n" if $x->is_zero();

Return true if $x is exactly zero, otherwise false.

=head2 is_positive()

	print "$x is >= 0\n" if $x->is_positive();

Return true if $x is positive (greater than or equal to zero), otherwise
false. Please note that '+inf' is also positive, while 'NaN' and '-inf' aren't.

=head2 is_negative()

	print "$x is < 0\n" if $x->is_negative();

Return true if $x is negative (smaller than zero), otherwise false. Please
note that '-inf' is also negative, while 'NaN' and '+inf' aren't.

=head2 is_int()

	print "$x is an integer\n" if $x->is_int();

Return true if $x has a denominator of 1 (e.g. no fraction parts), otherwise
false. Please note that '-inf', 'inf' and 'NaN' aren't integer.

=head2 is_odd()

	print "$x is odd\n" if $x->is_odd();

Return true if $x is odd, otherwise false.

=head2 is_even()

	print "$x is even\n" if $x->is_even();

Return true if $x is even, otherwise false.

=head2 bceil()

	$x->bceil();

Set $x to the next bigger integer value (e.g. truncate the number to integer
and then increment it by one).

=head2 bfloor()
	
	$x->bfloor();

Truncate $x to an integer value.

=head2 config

        use Data::Dumper;

        print Dumper ( Math::BigRat->config() );
        print Math::BigRat->config()->{lib},"\n";

Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.

        key             RO/RW   Description
                                Example
        ============================================================
        lib             RO      Name of the Math library
                                Math::BigInt::Calc
        lib_version     RO      Version of 'lib'
                                0.30
        class           RO      The class of config you just called
                                Math::BigRat
        version         RO      version number of the class you used
                                0.10
        upgrade         RW      To which class numbers are upgraded
                                undef
        downgrade       RW      To which class numbers are downgraded
                                undef
        precision       RW      Global precision
                                undef
        accuracy        RW      Global accuracy
                                undef
        round_mode      RW      Global round mode
                                even
        div_scale       RW      Fallback acccuracy for div
                                40
        trap_nan        RW      Trap creation of NaN (undef = no)
                                undef
        trap_inf        RW      Trap creation of +inf/-inf (undef = no)
                                undef

By passing a reference to a hash you may set the configuration values. This
works only for values that a marked with a C<RW> above, anything else is
read-only.
d1009 1
a1009 13
Some things are not yet implemented, or only implemented half-way:

=over 2

=item inf handling (partial)

=item NaN handling (partial)

=item rounding (not implemented except for bceil/bfloor)

=item $x ** $y where $y is not an integer

=back
d1021 3
a1023 5
See L<http://search.cpan.org/search?dist=bignum> for a way to use
Math::BigRat.

The package at L<http://search.cpan.org/search?dist=Math%3A%3ABigRat>
may contain more documentation and examples as well as testcases.
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@a12 1
# You should not look at the innards of a BigRat - use the methods for this.
d19 1
a19 1
require Exporter;
d21 1
a21 1
use vars qw($VERSION @@ISA $PACKAGE $upgrade $downgrade
d25 1
d27 1
a27 1
$VERSION = '0.12';
a30 2
BEGIN { *objectify = \&Math::BigInt::objectify; }

d48 1
a49 3
my $CALC = 'Math::BigInt::Calc';
my $class = 'Math::BigRat';
my $IMPORT = 0;
a56 5
sub BEGIN
  {
  *AUTOLOAD = \&Math::BigFloat::AUTOLOAD;
  }

d59 1
a59 1
  # turn a single float input into a rational number (like '0.1')
d63 2
a64 1
  return $self->binf($f->{sign}) if $f->{sign} =~ /^[+-]inf$/;
d66 1
a66 3
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
  $self->{_n} = $MBI->new($CALC->_str ( $f->{_m} ),undef,undef);# mantissa
d68 2
a69 2
  $self->{sign} = $f->{sign} || '+';
  if ($f->{_es} eq '-')
d72 1
a72 2
    # 1 / 1 => 1/10
    $self->{_d}->blsft( $MBI->new($CALC->_str ( $f->{_e} )),10);	
d78 1
a78 2
    $self->{_n}->blsft( $MBI->new($CALC->_str($f->{_e})),10) unless 
      $CALC->_is_zero($f->{_e});	
d98 1
a98 1
      $self->_new_from_float($n);
d106 1
d114 1
a115 1
    return $self->bnorm();
d141 1
a141 2

      my $nf = Math::BigFloat->new($n,undef,undef);
d144 1
a144 2
      $self->{_n} = $MBI->new( $CALC->_str( $nf->{_m} ) );

d147 1
d149 1
a149 2
      $self->{_d} = $MBI->new( $CALC->_str( $f->{_m} ) );

d151 1
a151 1
      my $diff_e = $MBI->new ($nf->exponent())->bsub ( $f->exponent);
d177 2
a178 7
        if ($self->{_n}->is_inf())
	  {
	  my $s = '+'; 		# '+inf/+123' or '-inf/-123'
	  $s = '-' if substr($self->{_n}->{sign},0,1) ne $self->{_d}->{sign};
	  # +-inf/123 => +-inf
          return $self->binf($s);
	  }
a214 25
sub copy
  {
  my ($c,$x);
  if (@@_ > 1)
    {
    # if two arguments, the first one is the class to "swallow" subclasses
    ($c,$x) = @@_;
    }
  else
    {
    $x = shift;
    $c = ref($x);
    }
  return unless ref($x); # only for objects

  my $self = {}; bless $self,$c;

  $self->{sign} = $x->{sign};
  $self->{_d} = $x->{_d}->copy();
  $self->{_n} = $x->{_n}->copy();
  $self->{_a} = $x->{_a} if defined $x->{_a};
  $self->{_p} = $x->{_p} if defined $x->{_p};
  $self;
  }

d234 1
a234 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d242 1
a242 1
  my $s = ''; $s = $x->{sign} if $x->{sign} ne '+';	# '+3/2' => '3/2'
d244 2
a245 2
  return $s . $x->{_n}->bstr() if $x->{_d}->is_one();
  $s . $x->{_n}->bstr() . '/' . $x->{_d}->bstr();
d259 1
a259 1
  $s . $x->{_n}->bstr() . '/' . $x->{_d}->bstr(); 
d282 2
a283 2
  delete $x->{_d}->{_a}; delete $x->{_n}->{_a};
  delete $x->{_d}->{_p}; delete $x->{_n}->{_p}; 
d368 1
a368 1
  # add two rational numbers
d405 1
a405 1
  # calculate sign of result and norm our _n part
d413 1
a413 1
  # subtract two rational numbers
d423 30
a452 7
  # flip sign of $x, call badd(), then flip sign of result
  $x->{sign} =~ tr/+-/-+/
    unless $x->{sign} eq '+' && $x->{_n}->is_zero();	# not -0
  $x->badd($y,@@r);			# does norm and round
  $x->{sign} =~ tr/+-/-+/ 
    unless $x->{sign} eq '+' && $x->{_n}->is_zero();	# not -0
  $x;
d457 1
a457 1
  # multiply two rational numbers
d467 3
a469 2
  $x = $self->new($x) unless $x->isa($self);
  $y = $self->new($y) unless $y->isa($self);
d519 3
a521 2
  $x = $self->new($x) unless $x->isa($self);
  $y = $self->new($y) unless $y->isa($self);
d535 2
a536 2
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
d559 3
a561 2
  $x = $self->new($x) unless $x->isa($self);
  $y = $self->new($y) unless $y->isa($self);
a612 2
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
a639 2
  local $Math::BigInt::accuracy = undef;
  local $Math::BigInt::precision = undef;
d666 1
a666 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d676 1
a676 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d685 1
a685 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d687 1
a687 1
  my $sign = $_[2] || ''; $sign = '+' if $sign ne '-';
d696 1
a696 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d706 1
a706 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d714 5
d755 1
a755 4
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return $nan unless $x->is_int();
  $x->{_n}->length();			# length(-123/1) => length(123)
d760 1
a760 4
  my ($self,$x,$n) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return $nan unless $x->is_int();
  $x->{_n}->digit($n);			# digit(-123/1,2) => digit(123,2)
a802 1
  # if $x is an integer
d893 1
a893 99
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,$class,@@_);
    }

  # blog(1,Y) => 0
  return $x->bzero() if $x->is_one() && $y->{sign} eq '+';

  # $x <= 0 => NaN
  return $x->bnan() if $x->is_zero() || $x->{sign} ne '+' || $y->{sign} ne '+';

  if ($x->is_int() && $y->is_int())
    {
    return $self->new($x->as_number()->blog($y->as_number(),@@r));
    }

  # do it with floats
  $x->_new_from_float( $x->_as_float()->blog(Math::BigFloat->new("$y"),@@r) );
  }

sub _as_float
  {
  my $x = shift;

  local $Math::BigFloat::upgrade = undef;
  local $Math::BigFloat::accuracy = undef;
  local $Math::BigFloat::precision = undef;
  # 22/7 => 3.142857143..
  Math::BigFloat->new($x->{_n})->bdiv($x->{_d}, $x->accuracy());
  }

sub broot
  {
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  if ($x->is_int() && $y->is_int())
    {
    return $self->new($x->as_number()->broot($y->as_number(),@@r));
    }

  # do it with floats
  $x->_new_from_float( $x->_as_float()->broot($y,@@r) );
  }

sub bmodpow
  {
  # set up parameters
  my ($self,$x,$y,$m,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$m,@@r) = objectify(3,@@_);
    }

  # $x or $y or $m are NaN or +-inf => NaN
  return $x->bnan()
   if $x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/ ||
   $m->{sign} !~ /^[+-]$/;

  if ($x->is_int() && $y->is_int() && $m->is_int())
    {
    return $self->new($x->as_number()->bmodpow($y->as_number(),$m,@@r));
    }

  warn ("bmodpow() not fully implemented");
  $x->bnan();
  }

sub bmodinv
  {
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,@@_);
    }

  # $x or $y are NaN or +-inf => NaN
  return $x->bnan() 
   if $x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/;

  if ($x->is_int() && $y->is_int())
    {
    return $self->new($x->as_number()->bmodinv($y->as_number(),@@r));
    }

  warn ("bmodinv() not fully implemented");
  $x->bnan();
a910 1

d915 1
a915 1
  if ($x->{_d}->{_es} ne '+')
d917 2
a918 2
    $x->{_n}->blsft($x->{_d}->exponent()->babs(),10);	# 7.1/4.51 => 7.1/45.1
    $x->{_d} = $MBI->new($CALC->_str($x->{_d}->{_m}));	# 7.1/45.1 => 71/45.1
d921 1
a921 1
  if ($x->{_n}->{_es} ne '+')
d923 2
a924 2
    $x->{_d}->blsft($x->{_n}->exponent()->babs(),10);	# 71/45.1 => 710/45.1
    $x->{_n} = $MBI->new($CALC->_str($x->{_n}->{_m}));	# 710/45.1 => 710/451
d928 2
a929 2
  $x->{_n} = $x->{_n}->as_number() unless $x->{_n}->isa($MBI);
  $x->{_d} = $x->{_d}->as_number() unless $x->{_d}->isa($MBI);
d935 1
a935 1
  my ($self,$x,$y,$b,@@r) = objectify(3,@@_);
d937 1
a937 3
  $b = 2 unless defined $b;
  $b = $self->new($b) unless ref ($b);
  $x->bmul( $b->copy()->bpow($y), @@r);
d943 1
a943 1
  my ($self,$x,$y,$b,@@r) = objectify(2,@@_);
d945 1
a945 3
  $b = 2 unless defined $b;
  $b = $self->new($b) unless ref ($b);
  $x->bdiv( $b->copy()->bpow($y), @@r);
d972 1
a972 9
  # compare two signed numbers 
  
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,@@_);
    }
d1002 1
a1002 9
  # compare two numbers (as unsigned)
 
  # set up parameters
  my ($self,$x,$y) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y) = objectify(2,$class,@@_);
    }
d1009 1
a1009 2
    return 1 if $x->{sign} =~ /^[+-]inf$/ && $y->{sign} !~ /^[+-]inf$/;
    return -1;
d1037 1
a1037 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
a1049 20
sub as_bin
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return $x unless $x->is_int();

  my $s = $x->{sign}; $s = '' if $s eq '+';
  $s . $x->{_n}->as_bin();
  }

sub as_hex
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return $x unless $x->is_int();

  my $s = $x->{sign}; $s = '' if $s eq '+';
  $s . $x->{_n}->as_hex();
  }

a1054 2
  $IMPORT++;

d1091 1
a1091 1
  # let use Math::BigInt lib => 'GMP'; use Math::BigRat; still work
a1122 2
  $CALC = Math::BigFloat->config()->{lib};
  
d1135 1
a1135 1
Math::BigRat - arbitrarily big rational numbers
d1141 1
a1141 1
	my $x = Math::BigRat->new('3/7'); $x += '5/9';
a1145 5
	my $y = Math::BigRat->new('inf');
	print "$y ", ($y->is_inf ? 'is' : 'is not') , " infinity\n";

	my $z = Math::BigRat->new(144); $z->bsqrt();

d1149 1
a1149 1
for arbitrarily big rational numbers.
a1193 1
	$x = Math::BigRat->new('inf');				# infinity
a1313 6
=head2 bsqrt()
	
	$x->bsqrt();

Calculate the square root of $x.

a1370 2
=item bmod(), blog(), bmodinv() and bmodpow() (partial)

d1391 1
a1391 1
(C) by Tels L<http://bloodgate.com/> 2001, 2002, 2003, 2004.
@


1.1.1.4
log
@perl 5.8.6 from CPAN
@
text
@d22 1
a22 1
use vars qw($VERSION @@ISA $upgrade $downgrade
d27 1
a27 1
$VERSION = '0.13';
d29 1
a29 1
use overload;			# inherit overload from Math::BigFloat
d31 1
a31 10
BEGIN
  { 
  *objectify = \&Math::BigInt::objectify; 	# inherit this from BigInt
  *AUTOLOAD = \&Math::BigFloat::AUTOLOAD;	# can't inherit AUTOLOAD
  # we inherit these from BigFloat because currently it is not possible
  # that MBF has a different $MBI variable than we, because MBF also uses
  # Math::BigInt::config->('lib'); (there is always only one library loaded)
  *_e_add = \&Math::BigFloat::_e_add;
  *_e_sub = \&Math::BigFloat::_e_sub;
  }
d34 1
a34 1
# Global constants and flags. Access these only via the accessor methods!
d42 3
a44 1
# These are internally, and not to be used from the outside at all!
a48 4
# the package we are using for our private parts, defaults to:
# Math::BigInt->config()->{lib}
my $MBI = 'Math::BigInt::Calc';

d50 2
d61 4
a64 1
##############################################################################
d74 4
a77 2
  $self->{_n} = $MBI->_copy( $f->{_m} );	# mantissa
  $self->{_d} = $MBI->_one();
d83 1
a83 1
    $MBI->_lsft ( $self->{_d}, $f->{_e} ,10);	
d89 2
a90 2
    $MBI->_lsft ( $self->{_n}, $f->{_e} ,10) unless 
      $MBI->_is_zero($f->{_e});	
d115 3
a117 3
      $self->{_n} = $MBI->_copy($n->{value});		# "mantissa" = $n
      $self->{_d} = $MBI->_one();			# d => 1
      $self->{sign} = $n->{sign};
d123 2
a124 2
      $self->{_n} = $MBI->_new(abs($$n));		# "mantissa" = $n
      $self->{_d} = $MBI->_one();			# d => 1
d126 1
a126 1
    return $self->bnorm();				# normalize (120/1 => 12/10)
d128 1
a128 1
  return $n->copy() if ref $n;				# already a BigRat
d132 2
a133 2
    $self->{_n} = $MBI->_zero();			# undef => 0
    $self->{_d} = $MBI->_one();
d135 1
a135 1
    return $self;
a136 1

d146 2
d150 2
a152 1
      # one of them looks like a float 
d156 1
a156 1
      $self->{_n} = $MBI->_copy( $nf->{_m} );	# get mantissa
d161 1
a161 1
      $self->{_d} = $MBI->_copy( $f->{_m} );
d164 1
a164 2
      # XXX TODO: check that exponent() makes a copy to avoid copy()
      my $diff_e = $nf->exponent()->copy()->bsub( $f->exponent);
d168 1
a168 1
        $MBI->_lsft( $self->{_d}, $MBI->_new( $diff_e->babs()), 10);
d173 1
a173 1
        $MBI->_lsft( $self->{_n}, $MBI->_new( $diff_e), 10);
d178 13
a190 37
      # both d and n look like (big)ints

      $self->{sign} = '+';					# no sign => '+'
      $self->{_n} = undef;
      $self->{_d} = undef;
      if ($n =~ /^([+-]?)0*(\d+)\z/)				# first part ok?
	{
	$self->{sign} = $1 || '+';				# no sign => '+'
	$self->{_n} = $MBI->_new($2 || 0);
        }

      if ($d =~ /^([+-]?)0*(\d+)\z/)				# second part ok?
	{
	$self->{sign} =~ tr/+-/-+/ if ($1 || '') eq '-';	# negate if second part neg.
	$self->{_d} = $MBI->_new($2 || 0);
        }

      if (!defined $self->{_n} || !defined $self->{_d})
	{
        $d = Math::BigInt->new($d,undef,undef) unless ref $d;
        $n = Math::BigInt->new($n,undef,undef) unless ref $n;
	
        if ($n->{sign} =~ /^[+-]$/ && $d->{sign} =~ /^[+-]$/)
	  { 
	  # both parts are ok as integers (wierd things like ' 1e0'
          $self->{_n} = $MBI->_copy($n->{value});
          $self->{_d} = $MBI->_copy($d->{value});
          $self->{sign} = $n->{sign};
          $self->{sign} =~ tr/+-/-+/ if $d->{sign} eq '-';	# -1/-2 => 1/2
          return $self->bnorm();
	  }

        $self->{sign} = '+';					# a default sign
        return $self->bnan() if $n->is_nan() || $d->is_nan();

	# handle inf cases:
        if ($n->is_inf() || $d->is_inf())
d192 4
a195 10
	  if ($n->is_inf())
	    {
	    return $self->bnan() if $d->is_inf();		# both are inf => NaN
	    my $s = '+'; 		# '+inf/+123' or '-inf/-123'
	    $s = '-' if substr($n->{sign},0,1) ne $d->{sign};
	    # +-inf/123 => +-inf
	    return $self->binf($s);
	    }
          # 123/inf => 0
          return $self->bzero();
d197 8
a204 1
	}
d214 1
a214 1
    $self->{sign} = 'NaN';
d217 3
d224 5
a228 16
    # for simple forms, use $MBI directly
    if ($n =~ /^([+-]?)0*(\d+)\z/)
      {
      $self->{sign} = $1 || '+';
      $self->{_n} = $MBI->_new($2 || 0);
      $self->{_d} = $MBI->_one();
      }
    else
      {
      my $n = Math::BigInt->new($n,undef,undef);
      $self->{_n} = $MBI->_copy($n->{value});
      $self->{_d} = $MBI->_one();
      $self->{sign} = $n->{sign};
      return $self->bnan() if $self->{sign} eq 'NaN';
      return $self->binf($self->{sign}) if $self->{sign} =~ /^[+-]inf$/;
      }
d248 1
a248 1
  my $self = bless {}, $c;
d251 2
a252 2
  $self->{_d} = $MBI->_copy($x->{_d});
  $self->{_n} = $MBI->_copy($x->{_n});
d287 2
a288 2
  return $s . $MBI->_str($x->{_n}) if $MBI->_is_one($x->{_d});
  $s . $MBI->_str($x->{_n}) . '/' . $MBI->_str($x->{_d});
d302 1
a302 1
  $s . $MBI->_str($x->{_n}) . '/' . $MBI->_str($x->{_d});
d307 2
a308 1
  # reduce the number to the shortest form
d311 2
a312 3
  # Both parts must be objects of whatever we are using today.
  # Second check because Calc.pm has ARRAY res as unblessed objects.
  if (ref($x->{_n}) ne $MBI && ref($x->{_n}) ne 'ARRAY')
d314 1
a314 1
    require Carp; Carp::croak ("n is not $MBI but (".ref($x->{_n}).') in bnorm()');
d316 1
a316 1
  if (ref($x->{_d}) ne $MBI && ref($x->{_d}) ne 'ARRAY')
d318 1
a318 1
    require Carp; Carp::croak ("d is not $MBI but (".ref($x->{_d}).') in bnorm()');
d321 7
d332 2
a333 1
  if ($MBI->_is_zero($x->{_n}))
d335 2
a336 2
    $x->{sign} = '+';					# never leave a -0
    $x->{_d} = $MBI->_one() unless $MBI->_is_one($x->{_d});
d340 1
a340 1
  return $x if $MBI->_is_one($x->{_d});			# no need to reduce
d343 7
a349 4
  my $gcd = $MBI->_copy($x->{_n});
  $gcd = $MBI->_gcd($gcd,$x->{_d});
  
  if (!$MBI->_is_one($gcd))
d351 2
a352 2
    $x->{_n} = $MBI->_div($x->{_n},$gcd);
    $x->{_d} = $MBI->_div($x->{_d},$gcd);
d371 2
a372 2
  $self->{_n} = $MBI->_zero();
  $self->{_d} = $MBI->_zero();
d386 2
a387 2
  $self->{_n} = $MBI->_zero();
  $self->{_d} = $MBI->_zero();
d394 2
a395 2
  $self->{_n} = $MBI->_one();
  $self->{_d} = $MBI->_one();
d402 2
a403 2
  $self->{_n} = $MBI->_zero();
  $self->{_d} = $MBI->_one();
d421 2
a422 3
  # +inf + +inf => +inf,  -inf + -inf => -inf
  return $x->binf(substr($x->{sign},0,1))
    if $x->{sign} eq $y->{sign} && $x->{sign} =~ /^[+-]inf$/;
d424 2
a425 2
  # +inf + -inf or -inf + +inf => NaN
  return $x->bnan() if ($x->{sign} !~ /^[+-]$/ || $y->{sign} !~ /^[+-]$/);
d436 1
a436 1
  # and bnorm() will then take care of the rest
d438 2
a439 1
  $x->{_n} = $MBI->_mul( $x->{_n}, $y->{_d});
d441 4
a444 1
  my $m = $MBI->_mul( $MBI->_copy( $y->{_n} ), $x->{_d} );
d446 1
a446 1
  ($x->{_n}, $x->{sign}) = _e_add( $x->{_n}, $m, $x->{sign}, $y->{sign});
d448 2
a449 1
  $x->{_d} = $MBI->_mul( $x->{_d}, $y->{_d});
a450 1
  # normalize and round
d468 2
a469 2
    unless $x->{sign} eq '+' && $MBI->_is_zero($x->{_n});	# not -0
  $x->badd($y,@@r);				# does norm and round
d471 1
a471 1
    unless $x->{sign} eq '+' && $MBI->_is_zero($x->{_n});	# not -0
d487 3
d507 6
a512 7
  # XXX TODO:
  # According to Knuth, this can be optimized by doing gcd twice (for d and n)
  # and reducing in one step. This would save us the bnorm() at the end.

  #  1   2    1 * 2    2    1
  #  - * - =  -----  = -  = -
  #  4   3    4 * 3    12   6
d514 4
a517 2
  $x->{_n} = $MBI->_mul( $x->{_n}, $y->{_n});
  $x->{_d} = $MBI->_mul( $x->{_d}, $y->{_d});
d538 3
d547 1
a547 3
  # XXX TODO: list context, upgrade
  # According to Knuth, this can be optimized by doing gcd twice (for d and n)
  # and reducing in one step. This would save us the bnorm() at the end.
d553 4
a556 2
  $x->{_n} = $MBI->_mul( $x->{_n}, $y->{_d});
  $x->{_d} = $MBI->_mul( $x->{_d}, $y->{_n});
d577 6
d590 16
a605 10
  # copy x to u, make it positive and then do a normal division ($u/$y)
  my $u = bless { sign => '+' }, $self;
  $u->{_n} = $MBI->_mul( $MBI->_copy($x->{_n}), $y->{_d} );
  $u->{_d} = $MBI->_mul( $MBI->_copy($x->{_d}), $y->{_n} );
  
  # compute floor(u)
  if (! $MBI->_is_one($u->{_d}))
    {
    $u->{_n} = $MBI->_div($u->{_n},$u->{_d});	# 22/7 => 3/1 w/ truncate
    # no need to set $u->{_d} to 1, since below we set it to $y->{_d} anyway
d608 3
a610 3
  # now compute $y * $u
  $u->{_d} = $MBI->_copy($y->{_d});		# 1 * $y->{_d}, see floor above
  $u->{_n} = $MBI->_mul($u->{_n},$y->{_n});
d612 1
a612 1
  my $xsign = $x->{sign}; $x->{sign} = '+';	# remember sign and make x positive
d630 2
d634 1
a634 1
    $x->{_n} = $MBI->_add( $x->{_n}, $x->{_d});		# -5/2 => -7/2
d638 1
a638 1
    if ($MBI->_acmp($x->{_n},$x->{_d}) < 0)		# n < d?
d641 1
a641 1
      $x->{_n} = $MBI->_sub( $MBI->_copy($x->{_d}), $x->{_n});
d646 1
a646 1
      $x->{_n} = $MBI->_sub($x->{_n}, $x->{_d}); 	# 5/2 => 3/2
d659 2
d663 1
a663 1
    if ($MBI->_acmp($x->{_n},$x->{_d}) < 0)
d666 1
a666 1
      $x->{_n} = $MBI->_sub( $MBI->_copy($x->{_d}), $x->{_n});
d671 1
a671 1
      $x->{_n} = $MBI->_sub($x->{_n}, $x->{_d}); 	# -5/2 => -3/2
d676 1
a676 1
    $x->{_n} = $MBI->_add($x->{_n},$x->{_d});		# 5/2 => 7/2
d690 1
a690 1
    $MBI->_is_one($x->{_d});			# x/y && y != 1 => no integer
d699 1
a699 1
  return 1 if $x->{sign} eq '+' && $MBI->_is_zero($x->{_n});
d710 1
a710 1
   if ($x->{sign} eq $sign && $MBI->_is_one($x->{_n}) && $MBI->_is_one($x->{_d}));
d720 1
a720 1
    ($MBI->_is_one($x->{_d}) && $MBI->_is_odd($x->{_n})); # x/2 is not, but 3/1
d730 2
a731 2
  return 1 if ($MBI->_is_one($x->{_d})			# x/3 is never
     && $MBI->_is_even($x->{_n}));			# but 4/1 is
d742 1
a742 2
  # NaN, inf, -inf
  return Math::BigInt->new($x->{sign}) if ($x->{sign} !~ /^[+-]$/);
d744 1
a744 1
  my $n = Math::BigInt->new($MBI->_str($x->{_n})); $n->{sign} = $x->{sign};
d752 2
a753 6
  # NaN
  return Math::BigInt->new($x->{sign}) if $x->{sign} eq 'NaN';
  # inf, -inf
  return Math::BigInt->bone() if $x->{sign} !~ /^[+-]$/;
  
  Math::BigInt->new($MBI->_str($x->{_d}));
d760 3
a762 5
  my $c = 'Math::BigInt';

  return ($c->bnan(),$c->bnan()) if $x->{sign} eq 'NaN';
  return ($c->binf(),$c->binf()) if $x->{sign} eq '+inf';
  return ($c->binf('-'),$c->binf()) if $x->{sign} eq '-inf';
d764 1
a764 1
  my $n = $c->new( $MBI->_str($x->{_n}));
d766 1
a766 2
  my $d = $c->new( $MBI->_str($x->{_d}));
  ($n,$d);
d774 1
a774 1
  $MBI->_len($x->{_n});				# length(-123/1) => length(123)
d779 1
a779 1
  my ($self,$x,$n) = ref($_[0]) ? (undef,$_[0],$_[1]) : objectify(1,@@_);
d782 1
a782 1
  $MBI->_digit($x->{_n},$n || 0);		# digit(-123/1,2) => digit(123,2)
d792 2
a793 2
  return $x if $x->{sign} !~ /^[+-]$/ ||	# not for NaN, inf
            $MBI->_is_one($x->{_d});		# 22/1 => 22, 0/1 => 0
d795 7
a801 5
  $x->{_n} = $MBI->_div($x->{_n},$x->{_d});	# 22/7 => 3/1 w/ truncate
  $x->{_d} = $MBI->_one();			# d => 1
  $x->{_n} = $MBI->_inc($x->{_n})
    if $x->{sign} eq '+';			# +22/7 => 4/1
  $x->{sign} = '+' if $MBI->_is_zero($x->{_n});	# -0 => 0
d809 2
a810 2
  return $x if $x->{sign} !~ /^[+-]$/ ||	# not for NaN, inf
            $MBI->_is_one($x->{_d});		# 22/1 => 22, 0/1 => 0
d812 6
a817 4
  $x->{_n} = $MBI->_div($x->{_n},$x->{_d});	# 22/7 => 3/1 w/ truncate
  $x->{_d} = $MBI->_one();			# d => 1
  $x->{_n} = $MBI->_inc($x->{_n})
    if $x->{sign} eq '-';			# -22/7 => -4/1
d825 2
a826 2
  # if $x is not an integer
  if (($x->{sign} ne '+') || (!$MBI->_is_one($x->{_d})))
d828 2
a829 1
    return $x->bnan();
d831 1
a831 4

  $x->{_n} = $MBI->_fac($x->{_n});
  # since _d is 1, we don't need to reduce/norm the result
  $x->round(@@r);
d850 1
a850 2

  if ($x->{sign} eq '-' && $MBI->_is_one($x->{_n}) && $MBI->_is_one($x->{_d}))
d858 1
a858 1

d862 1
a862 1
  if ($MBI->_is_one($y->{_d}))
d865 1
a865 1
    if ($MBI->_is_one($x->{_d}))
d867 1
a867 1
      $x->{_n} = $MBI->_pow($x->{_n},$y->{_n});		# x/1 ** y/1 => (x ** y)/1
d877 1
a877 1
        $x->{sign} = '+' if $MBI->_is_even($y->{_n});	
d882 2
a883 2
    $x->{_n} = $MBI->_pow($x->{_n},$y->{_n});		# 5/2 ** y/1 => 5 ** y / 2 ** y
    $x->{_d} = $MBI->_pow($x->{_d},$y->{_n});
d893 1
a893 1
      $x->{sign} = '+' if $MBI->_is_even($y->{_n});	
d899 4
a902 5
  my $pow2 = $self->bone();
  my $y1 = $MBI->_div ( $MBI->_copy($y->{_n}), $y->{_d});
  my $two = $MBI->_two();

  while (!$MBI->_is_one($y1))
d904 2
a905 2
    $pow2->bmul($x) if $MBI->_is_odd($y1);
    $MBI->_div($y1, $two);
a939 11
sub _float_from_part
  {
  my $x = shift;

  my $f = Math::BigFloat->bzero();
  $f->{_m} = $MBI->_copy($x);
  $f->{_e} = $MBI->_zero();

  $f;
  }

d948 1
a948 9

  my $a = $x->accuracy() || 0;
  if ($a != 0 || !$MBI->_is_one($x->{_d}))
    {
    # n/d
    return Math::BigFloat->new($x->{sign} . $MBI->_str($x->{_n}))->bdiv( $MBI->_str($x->{_d}), $x->accuracy());
    }
  # just n
  Math::BigFloat->new($x->{sign} . $MBI->_str($x->{_n}));
d1033 2
a1034 4
  $x->{_n} = _float_from_part( $x->{_n} )->bsqrt();
  $x->{_d} = _float_from_part( $x->{_d} )->bsqrt();

  # XXX TODO: we probably can optimze this:
d1040 1
a1040 1
    $x->{_d} = $MBI->_copy( $x->{_d}->{_m} );		# 7.1/45.1 => 71/45.1
d1046 1
a1046 1
    $x->{_n} = $MBI->_copy( $x->{_n}->{_m} );		# 710/45.1 => 710/451
d1048 1
a1048 1

d1050 2
a1051 5
  $x->{_n} = $MBI->_lsft( $MBI->_copy( $x->{_n}->{_m} ), $x->{_n}->{_e}, 10)
    if ref($x->{_n}) ne $MBI && ref($x->{_n}) ne 'ARRAY';
  $x->{_d} = $MBI->_lsft( $MBI->_copy( $x->{_d}->{_m} ), $x->{_d}->{_e}, 10)
    if ref($x->{_d}) ne $MBI && ref($x->{_d}) ne 'ARRAY';

d1067 1
a1067 1
  my ($self,$x,$y,$b,@@r) = objectify(3,@@_);
d1123 2
a1124 2
  my $xz = $MBI->_is_zero($x->{_n});
  my $yz = $MBI->_is_zero($y->{_n});
d1129 3
a1131 6
  my $t = $MBI->_mul( $MBI->_copy($x->{_n}), $y->{_d});
  my $u = $MBI->_mul( $MBI->_copy($y->{_n}), $x->{_d});

  my $cmp = $MBI->_acmp($t,$u);				# signs are equal
  $cmp = -$cmp if $x->{sign} eq '-';			# both are '-' => reverse
  $cmp;
d1155 3
a1157 3
  my $t = $MBI->_mul( $MBI->_copy($x->{_n}), $y->{_d});
  my $u = $MBI->_mul( $MBI->_copy($y->{_n}), $x->{_d});
  $MBI->_acmp($t,$u);					# ignore signs
d1171 1
a1171 1
  return $MBI->_num($x->{_n}) if $MBI->_is_one($x->{_d});
d1175 1
a1175 1
  $neg * $MBI->_num($x->{_n}) / $MBI->_num($x->{_d});	# return sign * N/D
d1182 1
a1182 1
  return Math::BigInt->new($x) if $x->{sign} !~ /^[+-]$/;	# NaN, inf etc
d1184 7
a1190 4
  my $u = Math::BigInt->bzero();
  $u->{sign} = $x->{sign};
  $u->{value} = $MBI->_div( $MBI->_copy($x->{_n}), $x->{_d});	# 22/7 => 3
  $u;
d1200 1
a1200 1
  $s . $MBI->_as_bin($x->{_n});
d1210 1
a1210 1
  $s . $MBI->_as_hex($x->{_n});
d1288 1
a1288 1
  $MBI = Math::BigFloat->config()->{lib};
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d12 1
d20 1
d25 1
a25 1
@@ISA = qw(Math::BigFloat);
d27 1
a27 1
$VERSION = '0.15';
a39 3
  *as_int = \&as_number;
  *is_pos = \&is_positive;
  *is_neg = \&is_negative;
d62 1
d104 1
a104 1
  my ($n,$d) = @@_;
d108 2
a109 1
  # input like (BigInt) or (BigFloat):
d119 1
a119 1
      $self->{_n} = $MBI->_copy($n->{value});		# "mantissa" = N
d127 1
a127 1
      $self->{_n} = $MBI->_new(abs($$n));		# "mantissa" = N
a131 45

  # input like (BigInt,BigInt) or (BigLite,BigLite):
  if (ref($d) && ref($n))
    {
    # do N first (for $self->{sign}):
    if ($n->isa('Math::BigInt'))
      {
      # TODO: trap NaN, inf
      $self->{_n} = $MBI->_copy($n->{value});		# "mantissa" = N
      $self->{sign} = $n->{sign};
      }
    elsif ($n->isa('Math::BigInt::Lite'))
      {
      # TODO: trap NaN, inf
      $self->{sign} = '+'; $self->{sign} = '-' if $$n < 0;
      $self->{_n} = $MBI->_new(abs($$n));		# "mantissa" = $n
      }
    else
      {
      require Carp;
      Carp::croak(ref($n) . " is not a recognized object format for Math::BigRat->new");
      }
    # now D:
    if ($d->isa('Math::BigInt'))
      {
      # TODO: trap NaN, inf
      $self->{_d} = $MBI->_copy($d->{value});		# "mantissa" = D
      # +/+ or -/- => +, +/- or -/+ => -
      $self->{sign} = $d->{sign} ne $self->{sign} ? '-' : '+';
      }
    elsif ($d->isa('Math::BigInt::Lite'))
      {
      # TODO: trap NaN, inf
      $self->{_d} = $MBI->_new(abs($$d));		# "mantissa" = D
      my $ds = '+'; $ds = '-' if $$d < 0;
      # +/+ or -/- => +, +/- or -/+ => -
      $self->{sign} = $ds ne $self->{sign} ? '-' : '+';
      }
    else
      {
      require Carp;
      Carp::croak(ref($d) . " is not a recognized object format for Math::BigRat->new");
      }
    return $self->bnorm();				# normalize (120/1 => 12/10)
    }
a157 1

d202 1
a202 1

d269 7
a275 4
  # if two arguments, the first one is the class to "swallow" subclasses
  my ($c,$x) = @@_;

  if (scalar @@_ == 1)
d277 1
a277 1
    $x = $_[0];
d297 1
a297 1
  my $class = shift || 'Math::BigRat';
d327 1
a327 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d342 1
a342 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
a380 16
# sign manipulation

sub bneg
  {
  # (BRAT or num_str) return BRAT
  # negate number or make a negated number from string
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return $x if $x->modify('bneg');

  # for +0 dont negate (to have always normalized +0). Does nothing for 'NaN'
  $x->{sign} =~ tr/+-/-+/ unless ($x->{sign} eq '+' && $MBI->_is_zero($x->{_n}));
  $x;
  }

##############################################################################
a391 4
    # "$self" below will stringify the object, this blows up if $self is a
    # partial object (happens under trap_nan), so fix it beforehand
    $self->{_d} = $MBI->_zero() unless defined $self->{_d};
    $self->{_n} = $MBI->_zero() unless defined $self->{_n};
a406 4
    # "$self" below will stringify the object, this blows up if $self is a
    # partial object (happens under trap_nan), so fix it beforehand
    $self->{_d} = $MBI->_zero() unless defined $self->{_d};
    $self->{_n} = $MBI->_zero() unless defined $self->{_n};
d456 1
a456 1
  #  5   7    5*3 + 7*4   43
a461 1
  # 5 * 3
a463 1
  # 7 * 4
a465 1
  # 5 * 3 + 7 * 4
a467 1
  # 4 * 3
d470 1
a470 1
  # normalize result, and possible round
d1198 1
a1198 1
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);
d1203 1
a1203 2
  my $neg = ''; $neg = '-' if $x->{sign} eq '-';
  return $neg . $MBI->_num($x->{_n}) if $MBI->_is_one($x->{_d});
d1205 3
a1207 1
  $x->_as_float()->numify() + 0.0;
a1241 3
##############################################################################
# import

d1247 1
d1251 1
d1255 1
d1261 1
a1261 1
#      $upgrade = $_[$i+1];		# or undef to disable
d1267 1
a1267 1
      $downgrade = $_[$i+1];		# or undef to disable
d1272 1
a1272 1
      $lib = $_[$i+1] || '';		# default Calc
d1277 1
a1277 2
      # this argument is no longer used
      #$MBI = $_[$i+1] || 'Math::BigInt::Calc';	# default Math::BigInt::Calc
d1285 11
a1295 1
  require Math::BigInt;
d1297 10
a1306 5
  # let use Math::BigInt lib => 'GMP'; use Math::BigRat; still have GMP
  if ($lib ne '')
    {
    my @@c = split /\s*,\s*/, $lib;
    foreach (@@c)
d1308 2
a1309 1
      $_ =~ tr/a-zA-Z0-9://cd;                    # limit to sane characters
a1310 1
    $lib = join(",", @@c);
d1312 4
a1315 5
  my @@import = ('objectify');
  push @@import, lib => $lib if $lib ne '';

  # MBI already loaded, so feed it our lib arguments
  Math::BigInt->import( @@import );
a1317 3

  # register us with MBI to get notified of future lib changes
  Math::BigInt::_register_callback( $self, sub { $MBI = $_[0]; } );
d1319 2
a1320 2
  # any non :constant stuff is handled by our parent, Exporter (loaded
  # by Math::BigFloat, even if @@_ is empty, to give it a chance
d1331 1
a1331 1
Math::BigRat - Arbitrary big rational numbers
d1350 1
a1350 1
for arbitrary big rational numbers.
a1403 6
	# You can also give D and N as different objects:
	$x = Math::BigRat->new(
		Math::BigInt->new(-123),
		Math::BigInt->new(7),
		);			# => -123/7

d1423 1
a1423 1
=head2 as_int()
d1426 1
a1426 1
	print $x->as_int(),"\n";		# '1'
d1428 1
a1428 17
Returns a copy of the object as BigInt, truncated to an integer.

C<as_number()> is an alias for C<as_int()>.

=head2 as_hex()

	$x = Math::BigRat->new('13');
	print $x->as_hex(),"\n";		# '0xd'

Returns the BigRat as hexadecimal string. Works only for integers. 

=head2 as_bin()

	$x = Math::BigRat->new('13');
	print $x->as_bin(),"\n";		# '0x1101'

Returns the BigRat as binary string. Works only for integers. 
d1470 1
a1470 1
=head2 is_pos()
d1477 1
a1477 3
C<is_positive()> is an alias for C<is_pos()>.

=head2 is_neg()
a1483 2
C<is_negative()> is an alias for C<is_neg()>.

d1601 1
a1601 1
(C) by Tels L<http://bloodgate.com/> 2001 - 2005.
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d16 1
a16 2
# anythig older is untested, and unlikely to work
use 5.006;
d25 1
a25 1
$VERSION = '0.21';
d211 2
a212 1
      my $diff_e = $nf->exponent()->bsub( $f->exponent);
d231 1
a231 1
      if ($n =~ /^([+-]?)0*([0-9]+)\z/)				# first part ok?
d237 1
a237 1
      if ($d =~ /^([+-]?)0*([0-9]+)\z/)				# second part ok?
d293 1
a293 1
    if ($n =~ /^([+-]?)0*([0-9]+)\z/)
a340 6
  if (@@_ == 1 && ref($_[0]) ne 'HASH')
    {
    my $cfg = $class->SUPER::config();
    return $cfg->{$_[0]};
    }

d387 2
a388 1
  if ( my $c = $MBI->_check($x->{_n}) )
d390 1
a390 1
    require Carp; Carp::croak ("n did not pass the self-check ($c) in bnorm()");
d392 1
a392 1
  if ( my $c = $MBI->_check($x->{_d}) )
d394 1
a394 1
    require Carp; Carp::croak ("d did not pass the self-check ($c) in bnorm()");
a1014 124
sub bexp
  {
  # set up parameters
  my ($self,$x,$y,$a,$p,$r) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,$a,$p,$r) = objectify(2,$class,@@_);
    }

  return $x->binf() if $x->{sign} eq '+inf';
  return $x->bzero() if $x->{sign} eq '-inf';

  # we need to limit the accuracy to protect against overflow
  my $fallback = 0;
  my ($scale,@@params);
  ($x,@@params) = $x->_find_round_parameters($a,$p,$r);

  # also takes care of the "error in _find_round_parameters?" case
  return $x if $x->{sign} eq 'NaN';

  # no rounding at all, so must use fallback
  if (scalar @@params == 0)
    {
    # simulate old behaviour
    $params[0] = $self->div_scale();    # and round to it as accuracy
    $params[1] = undef;                 # P = undef
    $scale = $params[0]+4;              # at least four more for proper round
    $params[2] = $r;                    # round mode by caller or undef
    $fallback = 1;                      # to clear a/p afterwards
    }
  else
    {
    # the 4 below is empirical, and there might be cases where it's not enough...
    $scale = abs($params[0] || $params[1]) + 4; # take whatever is defined
    }

  return $x->bone(@@params) if $x->is_zero();

  # See the comments in Math::BigFloat on how this algorithm works.
  # Basically we calculate A and B (where B is faculty(N)) so that A/B = e

  my $x_org = $x->copy();
  if ($scale <= 75)
    {
    # set $x directly from a cached string form
    $x->{_n} = $MBI->_new("90933395208605785401971970164779391644753259799242");
    $x->{_d} = $MBI->_new("33452526613163807108170062053440751665152000000000");
    $x->{sign} = '+';
    }
  else
    {
    # compute A and B so that e = A / B.

    # After some terms we end up with this, so we use it as a starting point:
    my $A = $MBI->_new("90933395208605785401971970164779391644753259799242");
    my $F = $MBI->_new(42); my $step = 42;

    # Compute how many steps we need to take to get $A and $B sufficiently big
    my $steps = Math::BigFloat::_len_to_steps($scale - 4);
#    print STDERR "# Doing $steps steps for ", $scale-4, " digits\n";
    while ($step++ <= $steps)
      {
      # calculate $a * $f + 1
      $A = $MBI->_mul($A, $F);
      $A = $MBI->_inc($A);
      # increment f
      $F = $MBI->_inc($F);
      }
    # compute $B as factorial of $steps (this is faster than doing it manually)
    my $B = $MBI->_fac($MBI->_new($steps));

#  print "A ", $MBI->_str($A), "\nB ", $MBI->_str($B), "\n";

    $x->{_n} = $A;
    $x->{_d} = $B;
    $x->{sign} = '+';
    }

  # $x contains now an estimate of e, with some surplus digits, so we can round
  if (!$x_org->is_one())
    {
    # raise $x to the wanted power and round it in one step:
    $x->bpow($x_org, @@params);
    }
  else
    {
    # else just round the already computed result
    delete $x->{_a}; delete $x->{_p};
    # shortcut to not run through _find_round_parameters again
    if (defined $params[0])
      {
      $x->bround($params[0],$params[2]);                # then round accordingly
      }
    else
      {
      $x->bfround($params[1],$params[2]);               # then round accordingly
      }
    }
  if ($fallback)
    {
    # clear a/p after round, since user did not request it
    delete $x->{_a}; delete $x->{_p};
    }

  $x;
  }

sub bnok
  {
  # set up parameters
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);

  # objectify is costly, so avoid it
  if ((!ref($_[0])) || (ref($_[0]) ne ref($_[1])))
    {
    ($self,$x,$y,@@r) = objectify(2,$class,@@_);
    }

  # do it with floats
  $x->_new_from_float( $x->_as_float()->bnok(Math::BigFloat->new("$y"),@@r) );
  }

d1283 1
a1283 2
  # NaN, inf etc
  return Math::BigInt->new($x->{sign}) if $x->{sign} !~ /^[+-]$/;
a1310 38
sub as_oct
  {
  my ($self,$x) = ref($_[0]) ? (undef,$_[0]) : objectify(1,@@_);

  return $x unless $x->is_int();

  my $s = $x->{sign}; $s = '' if $s eq '+';
  $s . $MBI->_as_oct($x->{_n});
  }

##############################################################################

sub from_hex
  {
  my $class = shift;

  $class->new(@@_);
  }

sub from_bin
  {
  my $class = shift;

  $class->new(@@_);
  }

sub from_oct
  {
  my $class = shift;

  my @@parts;
  for my $c (@@_)
    {
    push @@parts, Math::BigInt->from_oct($c);
    }
  $class->new ( @@parts );
  }

a1318 1
  my $try = 'try';
d1339 1
a1339 1
    elsif ($_[$i] =~ /^(lib|try|only)\z/)
a1341 1
      $try = $1;			# lib, try or only
d1368 1
a1368 1
  push @@import, $try => $lib if $lib ne '';
d1413 4
a1416 2
You can change the underlying module that does the low-level
math operations by using:
d1418 1
a1418 1
	use Math::BigRat try => 'GMP';
d1420 1
a1420 1
Note: This needs Math::BigInt::GMP installed.
a1424 5
	use Math::BigRat try => 'Foo,Math::BigInt::Bar';

If you want to get warned when the fallback occurs, replace "try" with
"lib":

d1427 13
a1439 4
If you want the code to die instead, replace "try" with
"only":

	use Math::BigRat only => 'Foo,Math::BigInt::Bar';
d1443 1
a1443 1
Any methods not listed here are derived from Math::BigFloat (or
d1488 1
a1488 15
=head2 numify()

	my $y = $x->numify();

Returns the object as a scalar. This will lose some data if the object
cannot be represented by a normal Perl scalar (integer or float), so
use as_int() instead.

This routine is automatically used whenever a scalar is required:

	my $x = Math::BigRat->new('3/1');
	@@array = (1,2,3);
	$y = $array[$x];		# set $y to 3

=head2 as_int()/as_number()
a1510 36
=head2 as_oct()

	$x = Math::BigRat->new('13');
	print $x->as_oct(),"\n";		# '015'

Returns the BigRat as octal string. Works only for integers. 

=head2 from_hex()/from_bin()/from_oct()

	my $h = Math::BigRat->from_hex('0x10');
	my $b = Math::BigRat->from_bin('0b10000000');
	my $o = Math::BigRat->from_oct('020');

Create a BigRat from an hexadecimal, binary or octal number
in string form.

=head2 length()

	$len = $x->length();

Return the length of $x in digitis for integer values.

=head2 digit()

	print Math::BigRat->new('123/1')->digit(1);	# 1
	print Math::BigRat->new('123/1')->digit(-1);	# 3

Return the N'ths digit from X when X is an integer value.

=head2 bnorm()

	$x->bnorm();

Reduce the number to the shortest form. This routine is called
automatically whenever it is needed.

d1522 4
a1538 6
=head2 bneg()

	$x->bneg();

Used to negate the object in-place.

d1551 1
a1551 1
=head2 is_pos()/is_positive()
d1560 1
a1560 1
=head2 is_neg()/is_negative()
d1607 1
a1607 71
=head2 broot()
	
	$x->broot($n);

Calculate the N'th root of $x.

=head2 badd()/bmul()/bsub()/bdiv()/bdec()/binc()

Please see the documentation in L<Math::BigInt>.

=head2 copy()

	my $z = $x->copy();

Makes a deep copy of the object.

Please see the documentation in L<Math::BigInt> for further details.

=head2 bstr()/bsstr()

	my $x = Math::BigInt->new('8/4');
	print $x->bstr(),"\n";			# prints 1/2
	print $x->bsstr(),"\n";			# prints 1/2

Return a string representating this object.

=head2 bacmp()/bcmp()

Used to compare numbers.

Please see the documentation in L<Math::BigInt> for further details.

=head2 blsft()/brsft()

Used to shift numbers left/right.

Please see the documentation in L<Math::BigInt> for further details.

=head2 bpow()

	$x->bpow($y);

Compute $x ** $y.

Please see the documentation in L<Math::BigInt> for further details.

=head2 bexp()

	$x->bexp($accuracy);		# calculate e ** X

Calculates two integers A and B so that A/B is equal to C<e ** $x>, where C<e> is
Euler's number.

This method was added in v0.20 of Math::BigRat (May 2007).

See also L<blog()>.

=head2 bnok()

	$x->bnok($y);		   # x over y (binomial coefficient n over k)

Calculates the binomial coefficient n over k, also called the "choose"
function. The result is equivalent to:

	( n )      n!
	| - |  = -------
	( k )    k!(n-k)!

This method was added in v0.20 of Math::BigRat (May 2007).

=head2 config()
d1639 1
a1639 1
        div_scale       RW      Fallback accuracy for div
d1686 1
a1686 1
(C) by Tels L<http://bloodgate.com/> 2001 - 2007.
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d26 1
a26 1
$VERSION = '0.22';
a939 7
  # shortcut if y == 1/N (is then sqrt() respective broot())
  if ($MBI->_is_one($y->{_n}))
    {
    return $x->bsqrt(@@r) if $MBI->_is_two($y->{_d});	# 1/2 => sqrt
    return $x->broot($MBI->_str($y->{_d}),@@r);		# 1/N => root(N)
    }

d977 15
a991 12
#  print STDERR "# $x $y\n";

  # otherwise:

  #      n/d     n  ______________
  # a/b       =  -\/  (a/b) ** d

  # (a/b) ** n == (a ** n) / (b ** n)
  $MBI->_pow($x->{_n}, $y->{_n} );
  $MBI->_pow($x->{_d}, $y->{_n} );

  return $x->broot($MBI->_str($y->{_d}),@@r);		# n/d => root(n)
d1023 1
a1023 1
  my ($self,$x,$y,@@r) = (ref($_[0]),@@_);
d1028 1
a1028 1
    ($self,$x,$y,@@r) = objectify(2,$class,@@_);
d1031 2
a1032 2
  return $x->binf(@@r) if $x->{sign} eq '+inf';
  return $x->bzero(@@r) if $x->{sign} eq '-inf';
d1037 1
a1037 1
  ($x,@@params) = $x->_find_round_parameters(@@r);
d1046 5
a1050 5
    $params[0] = $self->div_scale();	# and round to it as accuracy
    $params[1] = undef;			# P = undef
    $scale = $params[0]+4;		# at least four more for proper round
    $params[2] = $r[2];			# round mode by caller or undef
    $fallback = 1;			# to clear a/p afterwards
d1168 1
a1168 1
    return scalar Math::BigFloat->new($x->{sign} . $MBI->_str($x->{_n}))->bdiv( $MBI->_str($x->{_d}), $x->accuracy());
d1190 1
a1190 1
  $x->_new_from_float( $x->_as_float()->broot($y->_as_float(),@@r) )->bnorm()->bround(@@r);
a1420 22
sub as_float
  {
  # return N/D as Math::BigFloat

  # set up parameters
  my ($self,$x,@@r) = (ref($_[0]),@@_);
  # objectify is costly, so avoid it
  ($self,$x,@@r) = objectify(1,$class,@@_) unless ref $_[0];

  # NaN, inf etc
  return Math::BigFloat->new($x->{sign}) if $x->{sign} !~ /^[+-]$/;
 
  my $u = Math::BigFloat->bzero();
  $u->{sign} = $x->{sign};
  # n
  $u->{_m} = $MBI->_copy($x->{_n});
  $u->{_e} = $MBI->_zero();
  $u->bdiv( $MBI->_str($x->{_d}), @@r);
  # return $u
  $u;
  }

d1658 1
a1658 1
use L<as_int()> or L<as_float()> instead.
a1674 13
=head2 as_float()

	$x = Math::BigRat->new('13/7');
	print $x->as_float(),"\n";		# '1'

	$x = Math::BigRat->new('2/3');
	print $x->as_float(5),"\n";		# '0.66667'

Returns a copy of the object as BigFloat, preserving the
accuracy as wanted, or the default of 40 digits.

This method was added in v0.22 of Math::BigRat (April 2008).

a1935 4
=head2 objectify()

This is an internal routine that turns scalars into objects.

d1972 1
a1972 1
(C) by Tels L<http://bloodgate.com/> 2001 - 2008.
@


