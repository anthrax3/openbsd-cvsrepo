head	1.2;
access;
symbols
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.12.0.10
	OPENBSD_6_0_BASE:1.1.1.12
	OPENBSD_5_9:1.1.1.12.0.4
	OPENBSD_5_9_BASE:1.1.1.12
	OPENBSD_5_8:1.1.1.12.0.6
	OPENBSD_5_8_BASE:1.1.1.12
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.1.1.12.0.2
	OPENBSD_5_7_BASE:1.1.1.12
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.1.1.11.0.4
	OPENBSD_5_6_BASE:1.1.1.11
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.10.0.6
	OPENBSD_5_5_BASE:1.1.1.10
	OPENBSD_5_4:1.1.1.10.0.2
	OPENBSD_5_4_BASE:1.1.1.10
	PERL_5_16_3:1.1.1.10
	OPENBSD_5_3:1.1.1.9.0.10
	OPENBSD_5_3_BASE:1.1.1.9
	OPENBSD_5_2:1.1.1.9.0.8
	OPENBSD_5_2_BASE:1.1.1.9
	OPENBSD_5_1_BASE:1.1.1.9
	OPENBSD_5_1:1.1.1.9.0.6
	OPENBSD_5_0:1.1.1.9.0.4
	OPENBSD_5_0_BASE:1.1.1.9
	OPENBSD_4_9:1.1.1.9.0.2
	OPENBSD_4_9_BASE:1.1.1.9
	PERL_5_12_2:1.1.1.9
	OPENBSD_4_8:1.1.1.8.0.4
	OPENBSD_4_8_BASE:1.1.1.8
	OPENBSD_4_7:1.1.1.8.0.2
	OPENBSD_4_7_BASE:1.1.1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.1.1.7.0.6
	OPENBSD_4_6_BASE:1.1.1.7
	OPENBSD_4_5:1.1.1.7.0.2
	OPENBSD_4_5_BASE:1.1.1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.1.1.6.0.10
	OPENBSD_4_4_BASE:1.1.1.6
	OPENBSD_4_3:1.1.1.6.0.8
	OPENBSD_4_3_BASE:1.1.1.6
	OPENBSD_4_2:1.1.1.6.0.6
	OPENBSD_4_2_BASE:1.1.1.6
	OPENBSD_4_1:1.1.1.6.0.4
	OPENBSD_4_1_BASE:1.1.1.6
	OPENBSD_4_0:1.1.1.6.0.2
	OPENBSD_4_0_BASE:1.1.1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.1.1.5.0.8
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.6
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.4
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.2
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.6
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.4
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.2
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.23.20;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.46.42;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.33;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.50;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2010.09.24.14.48.35;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2013.03.25.20.08.50;	author sthen;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.07;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package charnames;
use strict;
use warnings;
our $VERSION = '1.43';
use unicore::Name;    # mktables-generated algorithmically-defined names
use _charnames ();    # The submodule for this where most of the work gets done

use bytes ();          # for $bytes::hint_bits
use re "/aa";          # Everything in here should be ASCII

# Translate between Unicode character names and their code points.
# This is a wrapper around the submodule C<_charnames>.  This design allows
# C<_charnames> to be autoloaded to enable use of \N{...}, but requires this
# module to be explicitly requested for the functions API.

$Carp::Internal{ (__PACKAGE__) } = 1;

sub import
{
  shift; ## ignore class name
  _charnames->import(@@_);
}

# Cache of already looked-up values.  This is set to only contain
# official values, and user aliases can't override them, so scoping is
# not an issue.
my %viacode;

sub viacode {
  return _charnames::viacode(@@_);
}

sub vianame
{
  if (@@_ != 1) {
    _charnames::carp "charnames::vianame() expects one name argument";
    return ()
  }

  # Looks up the character name and returns its ordinal if
  # found, undef otherwise.

  my $arg = shift;

  if ($arg =~ /^U\+([0-9a-fA-F]+)$/) {

    # khw claims that this is poor interface design.  The function should
    # return either a an ord or a chr for all inputs; not be bipolar.  But
    # can't change it because of backward compatibility.  New code can use
    # string_vianame() instead.
    my $ord = CORE::hex $1;
    return pack("U", $ord) if $ord <= 255 || ! ((caller 0)[8] & $bytes::hint_bits);
    _charnames::carp _charnames::not_legal_use_bytes_msg($arg, chr $ord);
    return;
  }

  # The first 1 arg means wants an ord returned; the second that we are in
  # runtime, and this is the first level routine called from the user
  return _charnames::lookup_name($arg, 1, 1);
} # vianame

sub string_vianame {

  # Looks up the character name and returns its string representation if
  # found, undef otherwise.

  if (@@_ != 1) {
    _charnames::carp "charnames::string_vianame() expects one name argument";
    return;
  }

  my $arg = shift;

  if ($arg =~ /^U\+([0-9a-fA-F]+)$/) {

    my $ord = CORE::hex $1;
    return pack("U", $ord) if $ord <= 255 || ! ((caller 0)[8] & $bytes::hint_bits);

    _charnames::carp _charnames::not_legal_use_bytes_msg($arg, chr $ord);
    return;
  }

  # The 0 arg means wants a string returned; the 1 arg means that we are in
  # runtime, and this is the first level routine called from the user
  return _charnames::lookup_name($arg, 0, 1);
} # string_vianame

1;
__END__

=encoding utf8

=head1 NAME

charnames - access to Unicode character names and named character sequences; also define character names

=head1 SYNOPSIS

 use charnames ':full';
 print "\N{GREEK SMALL LETTER SIGMA} is called sigma.\n";
 print "\N{LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW}",
       " is an officially named sequence of two Unicode characters\n";

 use charnames ':loose';
 print "\N{Greek small-letter  sigma}",
        "can be used to ignore case, underscores, most blanks,"
        "and when you aren't sure if the official name has hyphens\n";

 use charnames ':short';
 print "\N{greek:Sigma} is an upper-case sigma.\n";

 use charnames qw(cyrillic greek);
 print "\N{sigma} is Greek sigma, and \N{be} is Cyrillic b.\n";

 use utf8;
 use charnames ":full", ":alias" => {
   e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
   mychar => 0xE8000,  # Private use area
   "自転車に乗る人" => "BICYCLIST"
 };
 print "\N{e_ACUTE} is a small letter e with an acute.\n";
 print "\N{mychar} allows me to name private use characters.\n";
 print "And I can create synonyms in other languages,",
       " such as \N{自転車に乗る人} for "BICYCLIST (U+1F6B4)\n";

 use charnames ();
 print charnames::viacode(0x1234); # prints "ETHIOPIC SYLLABLE SEE"
 printf "%04X", charnames::vianame("GOTHIC LETTER AHSA"); # prints
                                                          # "10330"
 print charnames::vianame("LATIN CAPITAL LETTER A"); # prints 65 on
                                                     # ASCII platforms;
                                                     # 193 on EBCDIC
 print charnames::string_vianame("LATIN CAPITAL LETTER A"); # prints "A"

=head1 DESCRIPTION

Pragma C<use charnames> is used to gain access to the names of the
Unicode characters and named character sequences, and to allow you to define
your own character and character sequence names.

All forms of the pragma enable use of the following 3 functions:

=over

=item *

L</charnames::string_vianame(I<name>)> for run-time lookup of a
either a character name or a named character sequence, returning its string
representation

=item *

L</charnames::vianame(I<name>)> for run-time lookup of a
character name (but not a named character sequence) to get its ordinal value
(code point)

=item *

L</charnames::viacode(I<code>)> for run-time lookup of a code point to get its
Unicode name.

=back

Starting in Perl v5.16, any occurrence of C<\N{I<CHARNAME>}> sequences
in a double-quotish string automatically loads this module with arguments
C<:full> and C<:short> (described below) if it hasn't already been loaded with
different arguments, in order to compile the named Unicode character into
position in the string.  Prior to v5.16, an explicit S<C<use charnames>> was
required to enable this usage.  (However, prior to v5.16, the form C<S<"use
charnames ();">> did not enable C<\N{I<CHARNAME>}>.)

Note that C<\N{U+I<...>}>, where the I<...> is a hexadecimal number,
also inserts a character into a string.
The character it inserts is the one whose Unicode code point
(ordinal value) is equal to the number.  For example, C<"\N{U+263a}"> is
the Unicode (white background, black foreground) smiley face
equivalent to C<"\N{WHITE SMILING FACE}">.
Also note, C<\N{I<...>}> can mean a regex quantifier instead of a character
name, when the I<...> is a number (or comma separated pair of numbers
(see L<perlreref/QUANTIFIERS>), and is not related to this pragma.

The C<charnames> pragma supports arguments C<:full>, C<:loose>, C<:short>,
script names and L<customized aliases|/CUSTOM ALIASES>.

If C<:full> is present, for expansion of
C<\N{I<CHARNAME>}>, the string I<CHARNAME> is first looked up in the list of
standard Unicode character names.

C<:loose> is a variant of C<:full> which allows I<CHARNAME> to be less
precisely specified.  Details are in L</LOOSE MATCHES>.

If C<:short> is present, and
I<CHARNAME> has the form C<I<SCRIPT>:I<CNAME>>, then I<CNAME> is looked up
as a letter in script I<SCRIPT>, as described in the next paragraph.
Or, if C<use charnames> is used
with script name arguments, then for C<\N{I<CHARNAME>}> the name
I<CHARNAME> is looked up as a letter in the given scripts (in the
specified order). Customized aliases can override these, and are explained in
L</CUSTOM ALIASES>.

For lookup of I<CHARNAME> inside a given script I<SCRIPTNAME>,
this pragma looks in the table of standard Unicode names for the names

  SCRIPTNAME CAPITAL LETTER CHARNAME
  SCRIPTNAME SMALL LETTER CHARNAME
  SCRIPTNAME LETTER CHARNAME

If I<CHARNAME> is all lowercase,
then the C<CAPITAL> variant is ignored, otherwise the C<SMALL> variant
is ignored, and both I<CHARNAME> and I<SCRIPTNAME> are converted to all
uppercase for look-up.  Other than that, both of them follow L<loose|/LOOSE
MATCHES> rules if C<:loose> is also specified; strict otherwise.

Note that C<\N{...}> is compile-time; it's a special form of string
constant used inside double-quotish strings; this means that you cannot
use variables inside the C<\N{...}>.  If you want similar run-time
functionality, use
L<charnames::string_vianame()|/charnames::string_vianame(I<name>)>.

Note, starting in Perl 5.18, the name C<BELL> refers to the Unicode character
U+1F514, instead of the traditional U+0007.  For the latter, use C<ALERT>
or C<BEL>.

It is a syntax error to use C<\N{NAME}> where C<NAME> is unknown.

For C<\N{NAME}>, it is a fatal error if C<use bytes> is in effect and the
input name is that of a character that won't fit into a byte (i.e., whose
ordinal is above 255).

Otherwise, any string that includes a C<\N{I<charname>}> or
C<S<\N{U+I<code point>}>> will automatically have Unicode rules (see
L<perlunicode/Byte and Character Semantics>).

=head1 LOOSE MATCHES

By specifying C<:loose>, Unicode's L<loose character name
matching|http://www.unicode.org/reports/tr44#Matching_Rules> rules are
selected instead of the strict exact match used otherwise.
That means that I<CHARNAME> doesn't have to be so precisely specified.
Upper/lower case doesn't matter (except with scripts as mentioned above), nor
do any underscores, and the only hyphens that matter are those at the
beginning or end of a word in the name (with one exception:  the hyphen in
U+1180 C<HANGUL JUNGSEONG O-E> does matter).
Also, blanks not adjacent to hyphens don't matter.
The official Unicode names are quite variable as to where they use hyphens
versus spaces to separate word-like units, and this option allows you to not
have to care as much.
The reason non-medial hyphens matter is because of cases like
U+0F60 C<TIBETAN LETTER -A> versus U+0F68 C<TIBETAN LETTER A>.
The hyphen here is significant, as is the space before it, and so both must be
included.

C<:loose> slows down look-ups by a factor of 2 to 3 versus
C<:full>, but the trade-off may be worth it to you.  Each individual look-up
takes very little time, and the results are cached, so the speed difference
would become a factor only in programs that do look-ups of many different
spellings, and probably only when those look-ups are through C<vianame()> and
C<string_vianame()>, since C<\N{...}> look-ups are done at compile time.

=head1 ALIASES

Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and
names that were formerly Perl extensions, and some additional ones that Perl
did not previously accept.  The list is getting too long to reproduce here,
but you can get the complete list from the Unicode web site:
L<http://www.unicode.org/Public/UNIDATA/NameAliases.txt>.

Earlier versions of Perl accepted almost all the 6.1 names.  These were most
extensively documented in the v5.14 version of this pod:
L<http://perldoc.perl.org/5.14.0/charnames.html#ALIASES>.

=head1 CUSTOM ALIASES

You can add customized aliases to standard (C<:full>) Unicode naming
conventions.  The aliases override any standard definitions, so, if
you're twisted enough, you can change C<"\N{LATIN CAPITAL LETTER A}"> to
mean C<"B">, etc.

Aliases must begin with a character that is alphabetic.  After that, each may
contain any combination of word (C<\w>) characters, SPACE (U+0020),
HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), RIGHT PARENTHESIS (U+0029),
and NO-BREAK SPACE (U+00A0).  These last three should never have been allowed
in names, and are retained for backwards compatibility only; NO-BREAK SPACE IS
currently deprecated and scheduled for removal in Perl v5.26; the other two
may also be
deprecated and removed in future releases of Perl, so don't use them for new
names.  (More precisely, the first character of a name you specify must be
something that matches all of C<\p{ID_Start}>, C<\p{Alphabetic}>, and
C<\p{Gc=Letter}>.  This makes sure it is what any reasonable person would view
as an alphabetic character.  And, the continuation characters that match C<\w>
must also match C<\p{ID_Continue}>.)  Starting with Perl v5.18, any Unicode
characters meeting the above criteria may be used; prior to that only
Latin1-range characters were acceptable.

An alias can map to either an official Unicode character name (not a loose
matched name) or to a
numeric code point (ordinal).  The latter is useful for assigning names
to code points in Unicode private use areas such as U+E800 through
U+F8FF.
A numeric code point must be a non-negative integer, or a string beginning
with C<"U+"> or C<"0x"> with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.
If it begins with C<"U+">, it is interpreted as the Unicode code point;
otherwise it is interpreted as native.  (Only code points below 256 can
differ between Unicode and native.)  Thus C<U+41> is always the Latin letter
"A"; but C<0x41> can be "NO-BREAK SPACE" on EBCDIC platforms.

Aliases are added either by the use of anonymous hashes:

    use charnames ":alias" => {
        e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
        mychar1 => 0xE8000,
        };
    my $str = "\N{e_ACUTE}";

or by using a file containing aliases:

    use charnames ":alias" => "pro";

This will try to read C<"unicore/pro_alias.pl"> from the C<@@INC> path. This
file should return a list in plain perl:

    (
    A_GRAVE         => "LATIN CAPITAL LETTER A WITH GRAVE",
    A_CIRCUM        => "LATIN CAPITAL LETTER A WITH CIRCUMFLEX",
    A_DIAERES       => "LATIN CAPITAL LETTER A WITH DIAERESIS",
    A_TILDE         => "LATIN CAPITAL LETTER A WITH TILDE",
    A_BREVE         => "LATIN CAPITAL LETTER A WITH BREVE",
    A_RING          => "LATIN CAPITAL LETTER A WITH RING ABOVE",
    A_MACRON        => "LATIN CAPITAL LETTER A WITH MACRON",
    mychar2         => "U+E8001",
    );

Both these methods insert C<":full"> automatically as the first argument (if no
other argument is given), and you can give the C<":full"> explicitly as
well, like

    use charnames ":full", ":alias" => "pro";

C<":loose"> has no effect with these.  Input names must match exactly, using
C<":full"> rules.

Also, both these methods currently allow only single characters to be named.
To name a sequence of characters, use a
L<custom translator|/CUSTOM TRANSLATORS> (described below).

=head1 charnames::string_vianame(I<name>)

This is a runtime equivalent to C<\N{...}>.  I<name> can be any expression
that evaluates to a name accepted by C<\N{...}> under the L<C<:full>
option|/DESCRIPTION> to C<charnames>.  In addition, any other options for the
controlling C<"use charnames"> in the same scope apply, like C<:loose> or any
L<script list, C<:short> option|/DESCRIPTION>, or L<custom aliases|/CUSTOM
ALIASES> you may have defined.

The only differences are due to the fact that C<string_vianame> is run-time
and C<\N{}> is compile time.  You can't interpolate inside a C<\N{}>, (so
C<\N{$variable}> doesn't work); and if the input name is unknown,
C<string_vianame> returns C<undef> instead of it being a syntax error.

=head1 charnames::vianame(I<name>)

This is similar to C<string_vianame>.  The main difference is that under most
circumstances, C<vianame> returns an ordinal code
point, whereas C<string_vianame> returns a string.  For example,

   printf "U+%04X", charnames::vianame("FOUR TEARDROP-SPOKED ASTERISK");

prints "U+2722".

This leads to the other two differences.  Since a single code point is
returned, the function can't handle named character sequences, as these are
composed of multiple characters (it returns C<undef> for these.  And, the code
point can be that of any
character, even ones that aren't legal under the C<S<use bytes>> pragma,

See L</BUGS> for the circumstances in which the behavior differs
from  that described above.

=head1 charnames::viacode(I<code>)

Returns the full name of the character indicated by the numeric code.
For example,

    print charnames::viacode(0x2722);

prints "FOUR TEARDROP-SPOKED ASTERISK".

The name returned is the "best" (defined below) official name or alias
for the code point, if
available; otherwise your custom alias for it, if defined; otherwise C<undef>.
This means that your alias will only be returned for code points that don't
have an official Unicode name (nor alias) such as private use code points.

If you define more than one name for the code point, it is indeterminate
which one will be returned.

As mentioned, the function returns C<undef> if no name is known for the code
point.  In Unicode the proper name for these is the empty string, which
C<undef> stringifies to.  (If you ask for a code point past the legal
Unicode maximum of U+10FFFF that you haven't assigned an alias to, you
get C<undef> plus a warning.)

The input number must be a non-negative integer, or a string beginning
with C<"U+"> or C<"0x"> with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.
If it begins with C<"U+">, it is interpreted as the Unicode code point;
otherwise it is interpreted as native.  (Only code points below 256 can
differ between Unicode and native.)  Thus C<U+41> is always the Latin letter
"A"; but C<0x41> can be "NO-BREAK SPACE" on EBCDIC platforms.

As mentioned above under L</ALIASES>, Unicode 6.1 defines extra names
(synonyms or aliases) for some code points, most of which were already
available as Perl extensions.  All these are accepted by C<\N{...}> and the
other functions in this module, but C<viacode> has to choose which one
name to return for a given input code point, so it returns the "best" name.
To understand how this works, it is helpful to know more about the Unicode
name properties.  All code points actually have only a single name, which
(starting in Unicode 2.0) can never change once a character has been assigned
to the code point.  But mistakes have been made in assigning names, for
example sometimes a clerical error was made during the publishing of the
Standard which caused words to be misspelled, and there was no way to correct
those.  The Name_Alias property was eventually created to handle these
situations.  If a name was wrong, a corrected synonym would be published for
it, using Name_Alias.  C<viacode> will return that corrected synonym as the
"best" name for a code point.  (It is even possible, though it hasn't happened
yet, that the correction itself will need to be corrected, and so another
Name_Alias can be created for that code point; C<viacode> will return the
most recent correction.)

The Unicode name for each of the control characters (such as LINE FEED) is the
empty string.  However almost all had names assigned by other standards, such
as the ASCII Standard, or were in common use.  C<viacode> returns these names
as the "best" ones available.  Unicode 6.1 has created Name_Aliases for each
of them, including alternate names, like NEW LINE.  C<viacode> uses the
original name, "LINE FEED" in preference to the alternate.  Similarly the
name returned for U+FEFF is "ZERO WIDTH NO-BREAK SPACE", not "BYTE ORDER
MARK".

Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099
did not have names nor aliases.
To preserve backwards compatibility, any alias you define for these code
points will be returned by this function, in preference to the official name.

Some code points also have abbreviated names, such as "LF" or "NL".
C<viacode> never returns these.

Because a name correction may be added in future Unicode releases, the name
that C<viacode> returns may change as a result.  This is a rare event, but it
does happen.

=head1 CUSTOM TRANSLATORS

The mechanism of translation of C<\N{...}> escapes is general and not
hardwired into F<charnames.pm>.  A module can install custom
translations (inside the scope which C<use>s the module) with the
following magic incantation:

    sub import {
        shift;
        $^H{charnames} = \&translator;
    }

Here translator() is a subroutine which takes I<CHARNAME> as an
argument, and returns text to insert into the string instead of the
C<\N{I<CHARNAME>}> escape.

This is the only way you can create a custom named sequence of code points.

Since the text to insert should be different
in C<bytes> mode and out of it, the function should check the current
state of C<bytes>-flag as in:

    use bytes ();                      # for $bytes::hint_bits
    sub translator {
        if ($^H & $bytes::hint_bits) {
            return bytes_translator(@@_);
        }
        else {
            return utf8_translator(@@_);
        }
    }

See L</CUSTOM ALIASES> above for restrictions on I<CHARNAME>.

Of course, C<vianame>, C<viacode>, and C<string_vianame> would need to be
overridden as well.

=head1 BUGS

vianame() normally returns an ordinal code point, but when the input name is of
the form C<U+...>, it returns a chr instead.  In this case, if C<use bytes> is
in effect and the character won't fit into a byte, it returns C<undef> and
raises a warning.

Since evaluation of the translation function (see L</CUSTOM
TRANSLATORS>) happens in the middle of compilation (of a string
literal), the translation function should not do any C<eval>s or
C<require>s.  This restriction should be lifted (but is low priority) in
a future version of Perl.

=cut

# ex: set ts=8 sts=2 sw=2 et:
@


1.1
log
@Initial revision
@
text
@d2 26
a27 2
use bytes ();		# for $bytes::hint_bits
$charnames::hint_bits = 0x20000;
d29 3
a31 1
my $txt;
d33 5
a37 7
# This is not optimized in any way yet
sub charnames {
  $name = shift;
  $txt = do "unicode/Name.pl" unless $txt;
  my @@off;
  if ($^H{charnames_full} and $txt =~ /\t\t$name$/m) {
    @@off = ($-[0], $+[0]);
d39 16
a54 8
  unless (@@off) {
    if ($^H{charnames_short} and $name =~ /^(.*?):(.*)/s) {
      my ($script, $cname) = ($1,$2);
      my $case = ( $cname =~ /[[:upper:]]/ ? "CAPITAL" : "SMALL");
      if ($txt =~ m/\t\t\U$script\E (?:$case )?LETTER \U$cname$/m) {
	@@off = ($-[0], $+[0]);
      }
    }
d56 14
a69 6
  unless (@@off) {
    my $case = ( $name =~ /[[:upper:]]/ ? "CAPITAL" : "SMALL");
    for ( @@{$^H{charnames_scripts}} ) {
      (@@off = ($-[0], $+[0])), last 
	if $txt =~ m/\t\t$_ (?:$case )?LETTER \U$name$/m;
    }
d71 10
a80 9
  die "Unknown charname '$name'" unless @@off;
  
  my $ord = hex substr $txt, $off[0] - 4, 4;
  if ($^H & $bytes::hint_bits) {	# "use bytes" in effect?
    use bytes;
    return chr $ord if $ord <= 255;
    my $hex = sprintf '%X=0%o', $ord, $ord;
    my $fname = substr $txt, $off[0] + 2, $off[1] - $off[0] - 2;
    die "Character 0x$hex with name '$fname' is above 0xFF";
a81 14
  return chr $ord;
}

sub import {
  shift;
  die "`use charnames' needs explicit imports list" unless @@_;
  $^H |= $charnames::hint_bits;
  $^H{charnames} = \&charnames ;
  my %h;
  @@h{@@_} = (1) x @@_;
  $^H{charnames_full} = delete $h{':full'};
  $^H{charnames_short} = delete $h{':short'};
  $^H{charnames_scripts} = [map uc, keys %h];
}
d83 4
d91 2
d95 1
a95 1
charnames - define character names for C<\N{named}> string literal escape.
d99 35
a133 8
  use charnames ':full';
  print "\N{GREEK SMALL LETTER SIGMA} is called sigma.\n";

  use charnames ':short';
  print "\N{greek:Sigma} is an upper-case sigma.\n";

  use charnames qw(cyrillic greek);
  print "\N{sigma} is Greek sigma, and \N{be} is Cyrillic b.\n";
d137 63
a199 9
Pragma C<use charnames> supports arguments C<:full>, C<:short> and
script names.  If C<:full> is present, for expansion of
C<\N{CHARNAME}}> string C<CHARNAME> is first looked in the list of
standard Unicode names of chars.  If C<:short> is present, and
C<CHARNAME> has the form C<SCRIPT:CNAME>, then C<CNAME> is looked up
as a letter in script C<SCRIPT>.  If pragma C<use charnames> is used
with script name arguments, then for C<\N{CHARNAME}}> the name
C<CHARNAME> is looked up as a letter in the given scripts (in the
specified order).
d201 2
a202 2
For lookup of C<CHARNAME> inside a given script C<SCRIPTNAME>
this pragma looks for the names
d208 247
a454 3
in the table of standard Unicode names.  If C<CHARNAME> is lowercase,
then the C<CAPITAL> variant is ignored, otherwise the C<SMALL> variant is
ignored.
a462 1
    use charnames ();		# for $charnames::hint_bits
d464 2
a465 3
	shift;
	$^H |= $charnames::hint_bits;
	$^H{charnames} = \&translator;
d468 1
a468 1
Here translator() is a subroutine which takes C<CHARNAME> as an
d470 5
a474 1
C<\N{CHARNAME}> escape.  Since the text to insert should be different
d478 1
a478 1
    use bytes ();			# for $bytes::hint_bits
d480 6
a485 6
	if ($^H & $bytes::hint_bits) {
	    return bytes_translator(@@_);
	}
	else {
	    return utf8_translator(@@_);
	}
d488 5
d495 9
a503 3
Since evaluation of the translation function happens in a middle of
compilation (of a string literal), the translation function should not
do any C<eval>s or C<require>s.  This restriction should be lifted in
d507 2
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@a2 1
use warnings();
d32 2
a33 5

  my $hexlen = 4; # Unicode guarantees 4-, 5-, or 6-digit format
  $hexlen++ while
      $hexlen < 6 && substr($txt, $off[0] - $hexlen - 1, 1) =~ /[0-9a-f]/;
  my $ord = hex substr $txt, $off[0] - $hexlen, $hexlen;
a53 7
  if (warnings::enabled('utf8') && @@{$^H{charnames_scripts}}) {
	$txt = do "unicode/Name.pl" unless $txt;
    for (@@{$^H{charnames_scripts}}) {
        warnings::warn('utf8',  "No such script: '$_'") unless
	    $txt =~ m/\t\t$_ (?:CAPITAL |SMALL )?LETTER /;
	}
  }
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a1 5
use strict;
use warnings;
use Carp;
our $VERSION = '1.01';

d3 1
a5 31
my %alias1 = (
		# Icky 3.2 names with parentheses.
		'LINE FEED'		=> 'LINE FEED (LF)',
		'FORM FEED'		=> 'FORM FEED (FF)',
		'CARRIAGE RETURN'	=> 'CARRIAGE RETURN (CR)',
		'NEXT LINE'		=> 'NEXT LINE (NEL)',
		# Convenience.
		'LF'			=> 'LINE FEED (LF)',
		'FF'			=> 'FORM FEED (FF)',
		'CR'			=> 'CARRIAGE RETURN (CR)',
		'NEL'			=> 'NEXT LINE (NEL)',
	        # More convenience.  For futher convencience,
	        # it is suggested some way using using the NamesList
		# aliases is implemented.
	        'ZWNJ'			=> 'ZERO WIDTH NON-JOINER',
	        'ZWJ'			=> 'ZERO WIDTH JOINER',
		'BOM'			=> 'BYTE ORDER MARK',
	    );

my %alias2 = (
		# Pre-3.2 compatibility (only for the first 256 characters).
		'HORIZONTAL TABULATION'	=> 'CHARACTER TABULATION',
		'VERTICAL TABULATION'	=> 'LINE TABULATION',
		'FILE SEPARATOR'	=> 'INFORMATION SEPARATOR FOUR',
		'GROUP SEPARATOR'	=> 'INFORMATION SEPARATOR THREE',
		'RECORD SEPARATOR'	=> 'INFORMATION SEPARATOR TWO',
		'UNIT SEPARATOR'	=> 'INFORMATION SEPARATOR ONE',
		'PARTIAL LINE DOWN'	=> 'PARTIAL LINE FORWARD',
		'PARTIAL LINE UP'	=> 'PARTIAL LINE BACKWARD',
	    );

d9 6
a14 6
sub charnames
{
  my $name = shift;

  if (exists $alias1{$name}) {
      $name = $alias1{$name};
d16 8
a23 4
  if (exists $alias2{$name}) {
      require warnings;
      warnings::warnif('deprecated', qq{Unicode character name "$name" is deprecated, use "$alias2{$name}" instead});
      $name = $alias2{$name};
d25 6
a30 72

  my $ord;
  my @@off;
  my $fname;

  if ($name eq "BYTE ORDER MARK") {
      $fname = $name;
      $ord = 0xFEFF;
  } else {
      ## Suck in the code/name list as a big string.
      ## Lines look like:
      ##     "0052\t\tLATIN CAPITAL LETTER R\n"
      $txt = do "unicore/Name.pl" unless $txt;

      ## @@off will hold the index into the code/name string of the start and
      ## end of the name as we find it.
      
      ## If :full, look for the the name exactly
      if ($^H{charnames_full} and $txt =~ /\t\t\Q$name\E$/m) {
	  @@off = ($-[0], $+[0]);
      }

      ## If we didn't get above, and :short allowed, look for the short name.
      ## The short name is like "greek:Sigma"
      unless (@@off) {
	  if ($^H{charnames_short} and $name =~ /^(.+?):(.+)/s) {
	      my ($script, $cname) = ($1,$2);
	      my $case = ( $cname =~ /[[:upper:]]/ ? "CAPITAL" : "SMALL");
	      if ($txt =~ m/\t\t\U$script\E (?:$case )?LETTER \U\Q$cname\E$/m) {
		  @@off = ($-[0], $+[0]);
	      }
	  }
      }
      
      ## If we still don't have it, check for the name among the loaded
      ## scripts.
      if (not @@off)
      {
	  my $case = ( $name =~ /[[:upper:]]/ ? "CAPITAL" : "SMALL");
	  for my $script ( @@{$^H{charnames_scripts}} )
	  {
	      if ($txt =~ m/\t\t$script (?:$case )?LETTER \U\Q$name\E$/m) {
		  @@off = ($-[0], $+[0]);
		  last;
	      }
	  }
      }
      
      ## If we don't have it by now, give up.
      unless (@@off) {
	  carp "Unknown charname '$name'";
	  return "\x{FFFD}";
      }
      
      ##
      ## Now know where in the string the name starts.
      ## The code, in hex, is before that.
      ##
      ## The code can be 4-6 characters long, so we've got to sort of
      ## go look for it, just after the newline that comes before $off[0].
      ##
      ## This would be much easier if unicore/Name.pl had info in
      ## a name/code order, instead of code/name order.
      ##
      ## The +1 after the rindex() is to skip past the newline we're finding,
      ## or, if the rindex() fails, to put us to an offset of zero.
      ##
      my $hexstart = rindex($txt, "\n", $off[0]) + 1;

      ## we know where it starts, so turn into number -
      ## the ordinal for the char.
      $ord = hex substr($txt, $hexstart, $off[0] - $hexstart);
d32 6
a37 1

d41 3
a43 5
    my $hex = sprintf "%04x", $ord;
    if (not defined $fname) {
	$fname = substr $txt, $off[0] + 2, $off[1] - $off[0] - 2;
    }
    croak "Character 0x$hex with name '$fname' is above 0xFF";
d45 1
a45 3

  no warnings 'utf8'; # allow even illegal characters
  return pack "U", $ord;
d48 3
a50 8
sub import
{
  shift; ## ignore class name

  if (not @@_)
  {
      carp("`use charnames' needs explicit imports list");
  }
a52 4

  ##
  ## fill %h keys with our @@_ args.
  ##
a54 1

d58 6
a63 15

  ##
  ## If utf8? warnings are enabled, and some scripts were given,
  ## see if at least we can find one letter of each script.
  ##
  if (warnings::enabled('utf8') && @@{$^H{charnames_scripts}})
  {
      $txt = do "unicore/Name.pl" unless $txt;

      for my $script (@@{$^H{charnames_scripts}})
      {
          if (not $txt =~ m/\t\t$script (?:CAPITAL |SMALL )?LETTER /) {
              warnings::warn('utf8',  "No such script: '$script'");
          }
      }
a66 74
require Unicode::UCD; # for Unicode::UCD::_getcode()

my %viacode;

sub viacode
{
    if (@@_ != 1) {
        carp "charnames::viacode() expects one argument";
        return ()
    }

    my $arg = shift;
    my $code = Unicode::UCD::_getcode($arg);

    my $hex;

    if (defined $code) {
        $hex = sprintf "%04X", $arg;
    } else {
        carp("unexpected arg \"$arg\" to charnames::viacode()");
        return;
    }

    if ($code > 0x10FFFF) {
	carp sprintf "Unicode characters only allocated up to U+10FFFF (you asked for U+%X)", $hex;
	return;
    }

    return $viacode{$hex} if exists $viacode{$hex};

    $txt = do "unicore/Name.pl" unless $txt;

    if ($txt =~ m/^$hex\t\t(.+)/m) {
        return $viacode{$hex} = $1;
    } else {
        return;
    }
}

my %vianame;

sub vianame
{
    if (@@_ != 1) {
        carp "charnames::vianame() expects one name argument";
        return ()
    }

    my $arg = shift;

    return chr hex $1 if $arg =~ /^U\+([0-9a-fA-F]+)$/;

    return $vianame{$arg} if exists $vianame{$arg};

    $txt = do "unicore/Name.pl" unless $txt;

    my $pos = index $txt, "\t\t$arg\n";
    if ($[ <= $pos) {
	my $posLF = rindex $txt, "\n", $pos;
	(my $code = substr $txt, $posLF + 1, 6) =~ tr/\t//d;
	return $vianame{$arg} = hex $code;

	# If $pos is at the 1st line, $posLF must be $[ - 1 (not found);
	# then $posLF + 1 equals to $[ (at the beginning of $txt).
	# Otherwise $posLF is the position of "\n";
	# then $posLF + 1 must be the position of the next to "\n"
	# (the beginning of the line).
	# substr($txt, $posLF + 1, 6) may be "0000\t\t", "00A1\t\t",
	# "10300\t", "100000", etc. So we can get the code via removing TAB.
    } else {
        return;
    }
}

d73 1
a73 1
charnames - define character names for C<\N{named}> string literal escapes
a85 3
  print charnames::viacode(0x1234); # prints "ETHIOPIC SYLLABLE SEE"
  printf "%04X", charnames::vianame("GOTHIC LETTER AHSA"); # prints "10330"

d90 1
a90 1
C<\N{CHARNAME}> string C<CHARNAME> is first looked in the list of
d94 1
a94 1
with script name arguments, then for C<\N{CHARNAME}> the name
d106 2
a107 17
then the C<CAPITAL> variant is ignored, otherwise the C<SMALL> variant
is ignored.

Note that C<\N{...}> is compile-time, it's a special form of string
constant used inside double-quoted strings: in other words, you cannot
use variables inside the C<\N{...}>.  If you want similar run-time
functionality, use charnames::vianame().

For the C0 and C1 control characters (U+0000..U+001F, U+0080..U+009F)
as of Unicode 3.1, there are no official Unicode names but you can use
instead the ISO 6429 names (LINE FEED, ESCAPE, and so forth).  In
Unicode 3.2 (as of Perl 5.8) some naming changes take place ISO 6429
has been updated, see L</ALIASES>.  Also note that the U+UU80, U+0081,
U+0084, and U+0099 do not have names even in ISO 6429.

Since the Unicode standard uses "U+HHHH", so can you: "\N{U+263a}"
is the Unicode smiley face, or "\N{WHITE SMILING FACE}".
a137 90

=head1 charnames::viacode(code)

Returns the full name of the character indicated by the numeric code.
The example

    print charnames::viacode(0x2722);

prints "FOUR TEARDROP-SPOKED ASTERISK".

Returns undef if no name is known for the code.

This works only for the standard names, and does not yet apply 
to custom translators.

Notice that the name returned for of U+FEFF is "ZERO WIDTH NO-BREAK
SPACE", not "BYTE ORDER MARK".

=head1 charnames::vianame(name)

Returns the code point indicated by the name.
The example

    printf "%04X", charnames::vianame("FOUR TEARDROP-SPOKED ASTERISK");

prints "2722".

Returns undef if the name is unknown.

This works only for the standard names, and does not yet apply 
to custom translators.

=head1 ALIASES

A few aliases have been defined for convenience: instead of having
to use the official names

    LINE FEED (LF)
    FORM FEED (FF)
    CARRIAGE RETURN (CR)
    NEXT LINE (NEL)

(yes, with parentheses) one can use

    LINE FEED
    FORM FEED
    CARRIAGE RETURN
    NEXT LINE
    LF
    FF
    CR
    NEL

One can also use

    BYTE ORDER MARK
    BOM

and

    ZWNJ
    ZWJ

for ZERO WIDTH NON-JOINER and ZERO WIDTH JOINER.

For backward compatibility one can use the old names for
certain C0 and C1 controls

    old                         new

    HORIZONTAL TABULATION       CHARACTER TABULATION
    VERTICAL TABULATION         LINE TABULATION
    FILE SEPARATOR              INFORMATION SEPARATOR FOUR
    GROUP SEPARATOR             INFORMATION SEPARATOR THREE
    RECORD SEPARATOR            INFORMATION SEPARATOR TWO
    UNIT SEPARATOR              INFORMATION SEPARATOR ONE
    PARTIAL LINE DOWN           PARTIAL LINE FORWARD
    PARTIAL LINE UP             PARTIAL LINE BACKWARD

but the old names in addition to giving the character
will also give a warning about being deprecated.

=head1 ILLEGAL CHARACTERS

If you ask by name for a character that does not exist, a warning is
given and the Unicode I<replacement character> "\x{FFFD}" is returned.

If you ask by code for a character that does not exist, no warning is
given and C<undef> is returned.  (Though if you ask for a code point
past U+10FFFF you do get a warning.)
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d5 1
a5 2
use File::Spec;
our $VERSION = '1.02';
d8 1
a8 1
$charnames::hint_bits = 0x20000; # HINT_LOCALIZE_HH
a40 3
my %alias3 = (
		# User defined aliasses. Even more convenient :)
	    );
a42 30
sub alias (@@)
{
  @@_ or return %alias3;
  my $alias = ref $_[0] ? $_[0] : { @@_ };
  @@alias3{keys %$alias} = values %$alias;
} # alias

sub alias_file ($)
{
  my ($arg, $file) = @@_;
  if (-f $arg && File::Spec->file_name_is_absolute ($arg)) {
    $file = $arg;
  }
  elsif ($arg =~ m/^\w+$/) {
    $file = "unicore/${arg}_alias.pl";
  }
  else {
    croak "Charnames alias files can only have identifier characters";
  }
  if (my @@alias = do $file) {
    @@alias == 1 && !defined $alias[0] and
      croak "$file cannot be used as alias file for charnames";
    @@alias % 2 and
      croak "$file did not return a (valid) list of alias pairs";
    alias (@@alias);
    return (1);
  }
  0;
} # alias_file

d49 1
a49 6
    $name = $alias1{$name};
  }
  elsif (exists $alias2{$name}) {
    require warnings;
    warnings::warnif('deprecated', qq{Unicode character name "$name" is deprecated, use "$alias2{$name}" instead});
    $name = $alias2{$name};
d51 4
a54 2
  elsif (exists $alias3{$name}) {
    $name = $alias3{$name};
d62 2
a63 2
    $fname = $name;
    $ord = 0xFEFF;
d65 10
a74 20
    ## Suck in the code/name list as a big string.
    ## Lines look like:
    ##     "0052\t\tLATIN CAPITAL LETTER R\n"
    $txt = do "unicore/Name.pl" unless $txt;

    ## @@off will hold the index into the code/name string of the start and
    ## end of the name as we find it.

    ## If :full, look for the name exactly
    if ($^H{charnames_full} and $txt =~ /\t\t\Q$name\E$/m) {
      @@off = ($-[0], $+[0]);
    }

    ## If we didn't get above, and :short allowed, look for the short name.
    ## The short name is like "greek:Sigma"
    unless (@@off) {
      if ($^H{charnames_short} and $name =~ /^(.+?):(.+)/s) {
	my ($script, $cname) = ($1, $2);
	my $case = $cname =~ /[[:upper:]]/ ? "CAPITAL" : "SMALL";
	if ($txt =~ m/\t\t\U$script\E (?:$case )?LETTER \U\Q$cname\E$/m) {
a75 1
	}
a76 1
    }
d78 30
a107 9
    ## If we still don't have it, check for the name among the loaded
    ## scripts.
    if (not @@off) {
      my $case = $name =~ /[[:upper:]]/ ? "CAPITAL" : "SMALL";
      for my $script (@@{$^H{charnames_scripts}}) {
	if ($txt =~ m/\t\t$script (?:$case )?LETTER \U\Q$name\E$/m) {
	  @@off = ($-[0], $+[0]);
	  last;
	}
d109 19
a127 26
    }

    ## If we don't have it by now, give up.
    unless (@@off) {
      carp "Unknown charname '$name'";
      return "\x{FFFD}";
    }

    ##
    ## Now know where in the string the name starts.
    ## The code, in hex, is before that.
    ##
    ## The code can be 4-6 characters long, so we've got to sort of
    ## go look for it, just after the newline that comes before $off[0].
    ##
    ## This would be much easier if unicore/Name.pl had info in
    ## a name/code order, instead of code/name order.
    ##
    ## The +1 after the rindex() is to skip past the newline we're finding,
    ## or, if the rindex() fails, to put us to an offset of zero.
    ##
    my $hexstart = rindex($txt, "\n", $off[0]) + 1;

    ## we know where it starts, so turn into number -
    ## the ordinal for the char.
    $ord = hex substr($txt, $hexstart, $off[0] - $hexstart);
d135 1
a135 1
      $fname = substr $txt, $off[0] + 2, $off[1] - $off[0] - 2;
d142 1
a142 1
} # charnames
d148 3
a150 2
  if (not @@_) {
    carp("`use charnames' needs explicit imports list");
d158 2
a159 29
  my ($promote, %h, @@args) = (0);
  while (@@_ and $_ = shift) {
    if ($_ eq ":alias") {
      @@_ or
	croak ":alias needs an argument in charnames";
      my $alias = shift;
      if (ref $alias) {
	ref $alias eq "HASH" or
	  croak "Only HASH reference supported as argument to :alias";
	alias ($alias);
	next;
      }
      if ($alias =~ m{:(\w+)$}) {
	$1 eq "full" || $1 eq "short" and
	  croak ":alias cannot use existing pragma :$1 (reversed order?)";
	alias_file ($1) and $promote = 1;
	next;
      }
      alias_file ($alias);
      next;
    }
    if (m/^:/ and ! ($_ eq ":full" || $_ eq ":short")) {
      warn "unsupported special '$_' in charnames";
      next;
    }
    push @@args, $_;
  }
  @@args == 0 && $promote and @@args = (":full");
  @@h{@@args} = (1) x @@args;
d169 9
a177 6
  if (warnings::enabled('utf8') && @@{$^H{charnames_scripts}}) {
    $txt = do "unicore/Name.pl" unless $txt;

    for my $script (@@{$^H{charnames_scripts}}) {
      if (not $txt =~ m/\t\t$script (?:CAPITAL |SMALL )?LETTER /) {
	warnings::warn('utf8',  "No such script: '$script'");
a178 1
    }
d180 1
a180 1
} # import
d188 4
a191 4
  if (@@_ != 1) {
    carp "charnames::viacode() expects one argument";
    return ()
  }
d193 2
a194 2
  my $arg = shift;
  my $code = Unicode::UCD::_getcode($arg);
d196 1
a196 1
  my $hex;
d198 6
a203 6
  if (defined $code) {
    $hex = sprintf "%04X", $arg;
  } else {
    carp("unexpected arg \"$arg\" to charnames::viacode()");
    return;
  }
d205 4
a208 4
  if ($code > 0x10FFFF) {
    carp sprintf "Unicode characters only allocated up to U+10FFFF (you asked for U+%X)", $hex;
    return;
  }
d210 1
a210 1
  return $viacode{$hex} if exists $viacode{$hex};
d212 1
a212 1
  $txt = do "unicore/Name.pl" unless $txt;
d214 6
a219 6
  if ($txt =~ m/^$hex\t\t(.+)/m) {
    return $viacode{$hex} = $1;
  } else {
    return;
  }
} # viacode
d225 4
a228 4
  if (@@_ != 1) {
    carp "charnames::vianame() expects one name argument";
    return ()
  }
d230 1
a230 1
  my $arg = shift;
d232 1
a232 1
  return chr hex $1 if $arg =~ /^U\+([0-9a-fA-F]+)$/;
d234 1
a234 1
  return $vianame{$arg} if exists $vianame{$arg};
d236 1
a236 1
  $txt = do "unicore/Name.pl" unless $txt;
d238 17
a254 17
  my $pos = index $txt, "\t\t$arg\n";
  if ($[ <= $pos) {
    my $posLF = rindex $txt, "\n", $pos;
    (my $code = substr $txt, $posLF + 1, 6) =~ tr/\t//d;
    return $vianame{$arg} = hex $code;

    # If $pos is at the 1st line, $posLF must be $[ - 1 (not found);
    # then $posLF + 1 equals to $[ (at the beginning of $txt).
    # Otherwise $posLF is the position of "\n";
    # then $posLF + 1 must be the position of the next to "\n"
    # (the beginning of the line).
    # substr($txt, $posLF + 1, 6) may be "0000\t\t", "00A1\t\t",
    # "10300\t", "100000", etc. So we can get the code via removing TAB.
  } else {
    return;
  }
} # vianame
a274 6
  use charnames ":full", ":alias" => {
    e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
  };
  print "\N{e_ACUTE} is a small letter e with an acute.\n";

  use charnames ();
d280 4
a283 4
Pragma C<use charnames> supports arguments C<:full>, C<:short>, script
names and customized aliases.  If C<:full> is present, for expansion of
C<\N{CHARNAME}>, the string C<CHARNAME> is first looked up in the list of
standard Unicode character names.  If C<:short> is present, and
d288 1
a288 1
specified order). Customized aliases are explained in L</CUSTOM ALIASES>.
a345 37
=head1 CUSTOM ALIASES

This version of charnames supports three mechanisms of adding local
or customized aliases to standard Unicode naming conventions (:full)

=head2 Anonymous hashes

    use charnames ":full", ":alias" => {
        e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
        };
    my $str = "\N{e_ACUTE}";

=head2 Alias file

    use charnames ":full", ":alias" => "pro";

    will try to read "unicore/pro_alias.pl" from the @@INC path. This
    file should return a list in plain perl:

    (
    A_GRAVE         => "LATIN CAPITAL LETTER A WITH GRAVE",
    A_CIRCUM        => "LATIN CAPITAL LETTER A WITH CIRCUMFLEX",
    A_DIAERES       => "LATIN CAPITAL LETTER A WITH DIAERESIS",
    A_TILDE         => "LATIN CAPITAL LETTER A WITH TILDE",
    A_BREVE         => "LATIN CAPITAL LETTER A WITH BREVE",
    A_RING          => "LATIN CAPITAL LETTER A WITH RING ABOVE",
    A_MACRON        => "LATIN CAPITAL LETTER A WITH MACRON",
    );

=head2 Alias shortcut

    use charnames ":alias" => ":pro";

    works exactly the same as the alias pairs, only this time,
    ":full" is inserted automatically as first argument (if no
    other argument is given).

d357 1
a357 1
This works only for the standard names, and does not yet apply
d374 1
a374 1
This works only for the standard names, and does not yet apply
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d6 1
a6 1
our $VERSION = '1.04';
d193 2
a194 2
  while (my $arg = shift) {
    if ($arg eq ":alias") {
d213 2
a214 2
    if (substr($arg, 0, 1) eq ':' and ! ($arg eq ":full" || $arg eq ":short")) {
      warn "unsupported special '$arg' in charnames";
d217 1
a217 1
    push @@args, $arg;
d241 1
a241 13
# this comes actually from Unicode::UCD, but it avoids the
# overhead of loading it
sub _getcode {
    my $arg = shift;

    if ($arg =~ /^[1-9]\d*$/) {
	return $arg;
    } elsif ($arg =~ /^(?:[Uu]\+|0[xX])?([[:xdigit:]]+)$/) {
	return hex($1);
    }

    return;
}
d253 1
a253 1
  my $code = _getcode($arg);
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d6 1
a6 1
our $VERSION = '1.05';
d241 14
d261 1
a261 1
    return;
d265 1
a266 2
  # this comes actually from Unicode::UCD, where it is the named
  # function _getcode (), but it avoids the overhead of loading it
d268 2
a269 1
  if ($arg =~ /^[1-9]\d*$/) {
a270 2
  } elsif ($arg =~ /^(?:[Uu]\+|0[xX])?([[:xdigit:]]+)$/) {
    $hex = $1;
d276 1
a276 2
  # checking the length first is slightly faster
  if (length($hex) > 5 && hex($hex) > 0x10FFFF) {
d285 5
a289 3
  return unless $txt =~ m/^$hex\t\t(.+)/m;

  $viacode{$hex} = $1;
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
d6 1
a6 1
our $VERSION = '1.06';
d9 1
a46 10
sub croak
{
  require Carp; goto &Carp::croak;
} # croak

sub carp
{
  require Carp; goto &Carp::carp;
} # carp

d162 1
a162 1
    $ord = CORE::hex substr($txt, $hexstart, $off[0] - $hexstart);
d186 1
d266 1
a266 1
    carp "Unicode characters only allocated up to U+10FFFF (you asked for U+$hex)";
d290 1
a290 1
  return chr CORE::hex $1 if $arg =~ /^U\+([0-9a-fA-F]+)$/;
d300 1
a300 1
    return $vianame{$arg} = CORE::hex $code;
d380 1
a380 1
=head1 ALIASES
d382 4
a385 2
A few aliases have been defined for convenience: instead of having
to use the official names
d387 6
a392 4
    LINE FEED (LF)
    FORM FEED (FF)
    CARRIAGE RETURN (CR)
    NEXT LINE (NEL)
d394 5
a398 1
(yes, with parentheses) one can use
d400 9
a408 37
    LINE FEED
    FORM FEED
    CARRIAGE RETURN
    NEXT LINE
    LF
    FF
    CR
    NEL

One can also use

    BYTE ORDER MARK
    BOM

and

    ZWNJ
    ZWJ

for ZERO WIDTH NON-JOINER and ZERO WIDTH JOINER.

For backward compatibility one can use the old names for
certain C0 and C1 controls

    old                         new

    HORIZONTAL TABULATION       CHARACTER TABULATION
    VERTICAL TABULATION         LINE TABULATION
    FILE SEPARATOR              INFORMATION SEPARATOR FOUR
    GROUP SEPARATOR             INFORMATION SEPARATOR THREE
    RECORD SEPARATOR            INFORMATION SEPARATOR TWO
    UNIT SEPARATOR              INFORMATION SEPARATOR ONE
    PARTIAL LINE DOWN           PARTIAL LINE FORWARD
    PARTIAL LINE UP             PARTIAL LINE BACKWARD

but the old names in addition to giving the character
will also give a warning about being deprecated.
d478 32
a509 1
=head1 CUSTOM TRANSLATORS
d511 2
a512 4
The mechanism of translation of C<\N{...}> escapes is general and not
hardwired into F<charnames.pm>.  A module can install custom
translations (inside the scope which C<use>s the module) with the
following magic incantation:
d514 1
a514 4
    sub import {
	shift;
	$^H{charnames} = \&translator;
    }
d516 8
a523 5
Here translator() is a subroutine which takes C<CHARNAME> as an
argument, and returns text to insert into the string instead of the
C<\N{CHARNAME}> escape.  Since the text to insert should be different
in C<bytes> mode and out of it, the function should check the current
state of C<bytes>-flag as in:
d525 2
a526 9
    use bytes ();			# for $bytes::hint_bits
    sub translator {
	if ($^H & $bytes::hint_bits) {
	    return bytes_translator(@@_);
	}
	else {
	    return utf8_translator(@@_);
	}
    }
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d5 1
a5 1
our $VERSION = '1.07';
a542 5

Unicode standard named sequences are not recognized, such as
C<LATIN CAPITAL LETTER A WITH MACRON AND GRAVE>
(which should mean C<LATIN CAPITAL LETTER A WITH MACRON> with an additional
C<COMBINING GRAVE ACCENT>).
@


1.1.1.9
log
@Perl 5.12.2 from CPAN
@
text
@d440 1
a440 9
or customized aliases to standard Unicode naming conventions (:full).

Note that an alias should not be something that is a legal curly
brace-enclosed quantifier (see L<perlreref/QUANTIFIERS>).  For example
C<\N{123}> means to match 123 non-newline characters, and is not treated as an
alias.  Aliases are discouraged from beginning with anything other than an
alphabetic character and from containing anything other than alphanumerics,
spaces, dashes, colons, parentheses, and underscores.  Currently they must be
ASCII.
a532 2
See L</CUSTOM ALIASES> above for restrictions on C<CHARNAME>.

d535 2
a536 2
If you ask by name for a character that does not exist, a warning is given and
the Unicode I<replacement character> "\x{FFFD}" is returned.
d538 1
a538 1
If you ask by code for a character that is unassigned, no warning is
d540 1
a540 1
past U+10FFFF you do get a warning.)  See L</BUGS> below.
a543 13
viacode should return an empty string for unassigned in-range Unicode code
points, as that is their correct current name.

viacode(0) doesn't return C<NULL>, but C<undef>

vianame returns a chr if the input name is of the form C<U+...>, and an ord
otherwise.  It is planned to change this to always return an ord.

None of the functions work on almost all the Hangul syllable and CJK Unicode
characters that have their code points as part of their names.

Names must be ASCII characters only.

d549 1
a549 1
Since evaluation of the translation function happens in the middle of
@


1.1.1.10
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d4 2
a5 11
our $VERSION = '1.30';
use unicore::Name;    # mktables-generated algorithmically-defined names
use _charnames ();    # The submodule for this where most of the work gets done

use bytes ();          # for $bytes::hint_bits
use re "/aa";          # Everything in here should be ASCII

# Translate between Unicode character names and their code points.
# This is a wrapper around the submodule C<_charnames>.  This design allows
# C<_charnames> to be autoloaded to enable use of \N{...}, but requires this
# module to be explicitly requested for the functions API.
d7 179
a185 1
$Carp::Internal{ (__PACKAGE__) } = 1;
a189 2
  _charnames->import(@@_);
}
d191 57
a247 3
# Cache of already looked-up values.  This is set to only contain
# official values, and user aliases can't override them, so scoping is
# not an issue.
d250 1
a250 5
sub viacode {
  return _charnames::viacode(@@_);
}

sub vianame
d253 2
a254 2
    _charnames::carp "charnames::vianame() expects one name argument";
    return ()
a256 3
  # Looks up the character name and returns its ordinal if
  # found, undef otherwise.

d259 11
a269 1
  if ($arg =~ /^U\+([0-9a-fA-F]+)$/) {
d271 3
a273 7
    # khw claims that this is poor interface design.  The function should
    # return either a an ord or a chr for all inputs; not be bipolar.  But
    # can't change it because of backward compatibility.  New code can use
    # string_vianame() instead.
    my $ord = CORE::hex $1;
    return chr $ord if $ord <= 255 || ! ((caller 0)[8] & $bytes::hint_bits);
    _charnames::carp _charnames::not_legal_use_bytes_msg($arg, chr $ord);
d277 5
a281 4
  # The first 1 arg means wants an ord returned; the second that we are in
  # runtime, and this is the first level routine called from the user
  return _charnames::lookup_name($arg, 1, 1);
} # vianame
d283 2
a284 1
sub string_vianame {
d286 1
a286 2
  # Looks up the character name and returns its string representation if
  # found, undef otherwise.
d288 2
d291 2
a292 2
    _charnames::carp "charnames::string_vianame() expects one name argument";
    return;
d297 3
a299 1
  if ($arg =~ /^U\+([0-9a-fA-F]+)$/) {
d301 1
a301 2
    my $ord = CORE::hex $1;
    return chr $ord if $ord <= 255 || ! ((caller 0)[8] & $bytes::hint_bits);
d303 14
a316 1
    _charnames::carp _charnames::not_legal_use_bytes_msg($arg, chr $ord);
d319 1
a320 4
  # The 0 arg means wants a string returned; the 1 arg means that we are in
  # runtime, and this is the first level routine called from the user
  return _charnames::lookup_name($arg, 0, 1);
} # string_vianame
d327 1
a327 1
charnames - access to Unicode character names and named character sequences; also define character names
d331 17
a347 31
 use charnames ':full';
 print "\N{GREEK SMALL LETTER SIGMA} is called sigma.\n";
 print "\N{LATIN CAPITAL LETTER E WITH VERTICAL LINE BELOW}",
       " is an officially named sequence of two Unicode characters\n";

 use charnames ':loose';
 print "\N{Greek small-letter  sigma}",
        "can be used to ignore case, underscores, most blanks,"
        "and when you aren't sure if the official name has hyphens\n";

 use charnames ':short';
 print "\N{greek:Sigma} is an upper-case sigma.\n";

 use charnames qw(cyrillic greek);
 print "\N{sigma} is Greek sigma, and \N{be} is Cyrillic b.\n";

 use charnames ":full", ":alias" => {
   e_ACUTE => "LATIN SMALL LETTER E WITH ACUTE",
   mychar => 0xE8000,  # Private use area
 };
 print "\N{e_ACUTE} is a small letter e with an acute.\n";
 print "\N{mychar} allows me to name private use characters.\n";

 use charnames ();
 print charnames::viacode(0x1234); # prints "ETHIOPIC SYLLABLE SEE"
 printf "%04X", charnames::vianame("GOTHIC LETTER AHSA"); # prints
                                                          # "10330"
 print charnames::vianame("LATIN CAPITAL LETTER A"); # prints 65 on
                                                     # ASCII platforms;
                                                     # 193 on EBCDIC
 print charnames::string_vianame("LATIN CAPITAL LETTER A"); # prints "A"
d351 9
a359 63
Pragma C<use charnames> is used to gain access to the names of the
Unicode characters and named character sequences, and to allow you to define
your own character and character sequence names.

All forms of the pragma enable use of the following 3 functions:

=over

=item *

L</charnames::string_vianame(I<name>)> for run-time lookup of a
either a character name or a named character sequence, returning its string
representation

=item *

L</charnames::vianame(I<name>)> for run-time lookup of a
character name (but not a named character sequence) to get its ordinal value
(code point)

=item *

L</charnames::viacode(I<code>)> for run-time lookup of a code point to get its
Unicode name.

=back

Starting in Perl v5.16, any occurrence of C<\N{I<CHARNAME>}> sequences
in a double-quotish string automatically loads this module with arguments
C<:full> and C<:short> (described below) if it hasn't already been loaded with
different arguments, in order to compile the named Unicode character into
position in the string.  Prior to v5.16, an explicit S<C<use charnames>> was
required to enable this usage.  (However, prior to v5.16, the form C<S<"use
charnames ();">> did not enable C<\N{I<CHARNAME>}>.)

Note that C<\N{U+I<...>}>, where the I<...> is a hexadecimal number,
also inserts a character into a string.
The character it inserts is the one whose code point
(ordinal value) is equal to the number.  For example, C<"\N{U+263a}"> is
the Unicode (white background, black foreground) smiley face
equivalent to C<"\N{WHITE SMILING FACE}">.
Also note, C<\N{I<...>}> can mean a regex quantifier instead of a character
name, when the I<...> is a number (or comma separated pair of numbers
(see L<perlreref/QUANTIFIERS>), and is not related to this pragma.

The C<charnames> pragma supports arguments C<:full>, C<:loose>, C<:short>,
script names and L<customized aliases|/CUSTOM ALIASES>.

If C<:full> is present, for expansion of
C<\N{I<CHARNAME>}>, the string I<CHARNAME> is first looked up in the list of
standard Unicode character names.

C<:loose> is a variant of C<:full> which allows I<CHARNAME> to be less
precisely specified.  Details are in L</LOOSE MATCHES>.

If C<:short> is present, and
I<CHARNAME> has the form C<I<SCRIPT>:I<CNAME>>, then I<CNAME> is looked up
as a letter in script I<SCRIPT>, as described in the next paragraph.
Or, if C<use charnames> is used
with script name arguments, then for C<\N{I<CHARNAME>}> the name
I<CHARNAME> is looked up as a letter in the given scripts (in the
specified order). Customized aliases can override these, and are explained in
L</CUSTOM ALIASES>.
d361 2
a362 2
For lookup of I<CHARNAME> inside a given script I<SCRIPTNAME>,
this pragma looks in the table of standard Unicode names for the names
d368 1
a368 1
If I<CHARNAME> is all lowercase,
d370 1
a370 3
is ignored, and both I<CHARNAME> and I<SCRIPTNAME> are converted to all
uppercase for look-up.  Other than that, both of them follow L<loose|/LOOSE
MATCHES> rules if C<:loose> is also specified; strict otherwise.
d372 2
a373 2
Note that C<\N{...}> is compile-time; it's a special form of string
constant used inside double-quotish strings; this means that you cannot
d375 39
a413 2
functionality, use
L<charnames::string_vianame()|/charnames::string_vianame(I<name>)>.
d415 2
a416 2
Since Unicode 6.0, it is deprecated to use C<BELL>.  Instead use C<ALERT> (but
C<BEL> will continue to work).
d418 1
a418 2
If the input name is unknown, C<\N{NAME}> raises a warning and
substitutes the Unicode REPLACEMENT CHARACTER (U+FFFD).
d420 2
a421 33
For C<\N{NAME}>, it is a fatal error if C<use bytes> is in effect and the
input name is that of a character that won't fit into a byte (i.e., whose
ordinal is above 255).

Otherwise, any string that includes a C<\N{I<charname>}> or
C<S<\N{U+I<code point>}>> will automatically have Unicode semantics (see
L<perlunicode/Byte and Character Semantics>).

=head1 LOOSE MATCHES

By specifying C<:loose>, Unicode's L<loose character name
matching|http://www.unicode.org/reports/tr44#Matching_Rules> rules are
selected instead of the strict exact match used otherwise.
That means that I<CHARNAME> doesn't have to be so precisely specified.
Upper/lower case doesn't matter (except with scripts as mentioned above), nor
do any underscores, and the only hyphens that matter are those at the
beginning or end of a word in the name (with one exception:  the hyphen in
U+1180 C<HANGUL JUNGSEONG O-E> does matter).
Also, blanks not adjacent to hyphens don't matter.
The official Unicode names are quite variable as to where they use hyphens
versus spaces to separate word-like units, and this option allows you to not
have to care as much.
The reason non-medial hyphens matter is because of cases like
U+0F60 C<TIBETAN LETTER -A> versus U+0F68 C<TIBETAN LETTER A>.
The hyphen here is significant, as is the space before it, and so both must be
included.

C<:loose> slows down look-ups by a factor of 2 to 3 versus
C<:full>, but the trade-off may be worth it to you.  Each individual look-up
takes very little time, and the results are cached, so the speed difference
would become a factor only in programs that do look-ups of many different
spellings, and probably only when those look-ups are through vianame() and
string_vianame(), since C<\N{...}> look-ups are done at compile time.
d423 10
a432 1
=head1 ALIASES
d434 2
a435 9
Starting in Unicode 6.1 and Perl v5.16, Unicode defines many abbreviations and
names that were formerly Perl extensions, and some additional ones that Perl
did not previously accept.  The list is getting too long to reproduce here,
but you can get the complete list from the Unicode web site:
L<http://www.unicode.org/Public/UNIDATA/NameAliases.txt>.

Earlier versions of Perl accepted almost all the 6.1 names.  These were most
extensively documented in the v5.14 version of this pod:
L<http://perldoc.perl.org/5.14.0/charnames.html#ALIASES>.
d439 2
a440 4
You can add customized aliases to standard (C<:full>) Unicode naming
conventions.  The aliases override any standard definitions, so, if
you're twisted enough, you can change C<"\N{LATIN CAPITAL LETTER A}"> to
mean C<"B">, etc.
d444 5
a448 16
C<\N{123}> means to match 123 non-newline characters, and is not treated as a
charnames alias.  Aliases are discouraged from beginning with anything
other than an alphabetic character and from containing anything other
than alphanumerics, spaces, dashes, parentheses, and underscores.
Currently they must be ASCII.

An alias can map to either an official Unicode character name (not a loose
matched name) or to a
numeric code point (ordinal).  The latter is useful for assigning names
to code points in Unicode private use areas such as U+E800 through
U+F8FF.
A numeric code point must be a non-negative integer or a string beginning
with C<"U+"> or C<"0x"> with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.
d450 1
a450 1
Aliases are added either by the use of anonymous hashes:
d452 1
a452 1
    use charnames ":alias" => {
a453 1
        mychar1 => 0xE8000,
d457 1
a457 1
or by using a file containing aliases:
d459 1
a459 1
    use charnames ":alias" => "pro";
d461 2
a462 2
This will try to read C<"unicore/pro_alias.pl"> from the C<@@INC> path. This
file should return a list in plain perl:
a471 1
    mychar2         => "U+E8001",
d474 1
a474 3
Both these methods insert C<":full"> automatically as the first argument (if no
other argument is given), and you can give the C<":full"> explicitly as
well, like
d476 1
a476 1
    use charnames ":full", ":alias" => "pro";
d478 3
a480 2
C<":loose"> has no effect with these.  Input names must match exactly, using
C<":full"> rules.
d482 1
a482 3
Also, both these methods currently allow only single characters to be named.
To name a sequence of characters, use a
L<custom translator|/CUSTOM TRANSLATORS> (described below).
d484 2
a485 1
=head1 charnames::string_vianame(I<name>)
d487 1
a487 6
This is a runtime equivalent to C<\N{...}>.  I<name> can be any expression
that evaluates to a name accepted by C<\N{...}> under the L<C<:full>
option|/DESCRIPTION> to C<charnames>.  In addition, any other options for the
controlling C<"use charnames"> in the same scope apply, like C<:loose> or any
L<script list, C<:short> option|/DESCRIPTION>, or L<custom aliases|/CUSTOM
ALIASES> you may have defined.
d489 1
a489 9
The only difference is that if the input name is unknown, C<string_vianame>
returns C<undef> instead of the REPLACEMENT CHARACTER and does not raise a
warning message.

=head1 charnames::vianame(I<name>)

This is similar to C<string_vianame>.  The main difference is that under most
circumstances, vianame returns an ordinal code
point, whereas C<string_vianame> returns a string.  For example,
d491 1
a491 1
   printf "U+%04X", charnames::vianame("FOUR TEARDROP-SPOKED ASTERISK");
d493 2
a494 1
prints "U+2722".
d496 2
a497 5
This leads to the other two differences.  Since a single code point is
returned, the function can't handle named character sequences, as these are
composed of multiple characters (it returns C<undef> for these.  And, the code
point can be that of any
character, even ones that aren't legal under the C<S<use bytes>> pragma,
d499 1
a499 2
See L</BUGS> for the circumstances in which the behavior differs
from  that described above.
d501 2
a502 1
=head1 charnames::viacode(I<code>)
d504 1
a504 2
Returns the full name of the character indicated by the numeric code.
For example,
d506 1
a506 1
    print charnames::viacode(0x2722);
d508 1
a508 1
prints "FOUR TEARDROP-SPOKED ASTERISK".
d510 2
a511 60
The name returned is the "best" (defined below) official name or alias
for the code point, if
available; otherwise your custom alias for it, if defined; otherwise C<undef>.
This means that your alias will only be returned for code points that don't
have an official Unicode name (nor alias) such as private use code points.

If you define more than one name for the code point, it is indeterminate
which one will be returned.

As mentioned, the function returns C<undef> if no name is known for the code
point.  In Unicode the proper name of these is the empty string, which
C<undef> stringifies to.  (If you ask for a code point past the legal
Unicode maximum of U+10FFFF that you haven't assigned an alias to, you
get C<undef> plus a warning.)

The input number must be a non-negative integer, or a string beginning
with C<"U+"> or C<"0x"> with the remainder considered to be a
hexadecimal integer.  A literal numeric constant must be unsigned; it
will be interpreted as hex if it has a leading zero or contains
non-decimal hex digits; otherwise it will be interpreted as decimal.

As mentioned above under L</ALIASES>, Unicode 6.1 defines extra names
(synonyms or aliases) for some code points, most of which were already
available as Perl extensions.  All these are accepted by C<\N{...}> and the
other functions in this module, but C<viacode> has to choose which one
name to return for a given input code point, so it returns the "best" name.
To understand how this works, it is helpful to know more about the Unicode
name properties.  All code points actually have only a single name, which
(starting in Unicode 2.0) can never change once a character has been assigned
to the code point.  But mistakes have been made in assigning names, for
example sometimes a clerical error was made during the publishing of the
Standard which caused words to be misspelled, and there was no way to correct
those.  The Name_Alias property was eventually created to handle these
situations.  If a name was wrong, a corrected synonym would be published for
it, using Name_Alias.  C<viacode> will return that corrected synonym as the
"best" name for a code point.  (It is even possible, though it hasn't happened
yet, that the correction itself will need to be corrected, and so another
Name_Alias can be created for that code point; C<viacode> will return the
most recent correction.)

The Unicode name for each of the control characters (such as LINE FEED) is the
empty string.  However almost all had names assigned by other standards, such
as the ASCII Standard, or were in common use.  C<viacode> returns these names
as the "best" ones available.  Unicode 6.1 has created Name_Aliases for each
of them, including alternate names, like NEW LINE.  C<viacode> uses the
original name, "LINE FEED" in preference to the alternate.  Similarly the
name returned for U+FEFF is "ZERO WIDTH NO-BREAK SPACE", not "BYTE ORDER
MARK".

Until Unicode 6.1, the 4 control characters U+0080, U+0081, U+0084, and U+0099
did not have names nor aliases.
To preserve backwards compatibility, any alias you define for these code
points will be returned by this function, in preference to the official name.

Some code points also have abbreviated names, such as "LF" or "NL".
C<viacode> never returns these.

Because a name correction may be added in future Unicode releases, the name
that C<viacode> returns may change as a result.  This is a rare event, but it
does happen.
d521 2
a522 2
        shift;
        $^H{charnames} = \&translator;
d525 1
a525 1
Here translator() is a subroutine which takes I<CHARNAME> as an
d527 1
a527 5
C<\N{I<CHARNAME>}> escape.

This is the only way you can create a custom named sequence of code points.

Since the text to insert should be different
d531 1
a531 1
    use bytes ();                      # for $bytes::hint_bits
d533 6
a538 6
        if ($^H & $bytes::hint_bits) {
            return bytes_translator(@@_);
        }
        else {
            return utf8_translator(@@_);
        }
d541 3
a543 1
See L</CUSTOM ALIASES> above for restrictions on I<CHARNAME>.
d545 6
a550 2
Of course, C<vianame>, C<viacode>, and C<string_vianame> would need to be
overridden as well.
d554 21
a574 13
vianame() normally returns an ordinal code point, but when the input name is of
the form C<U+...>, it returns a chr instead.  In this case, if C<use bytes> is
in effect and the character won't fit into a byte, it returns C<undef> and
raises a warning.

Names must be ASCII characters only, which means that you are out of luck if
you want to create aliases in a language where some or all the characters of
the desired aliases are non-ASCII.

Since evaluation of the translation function (see L</CUSTOM
TRANSLATORS>) happens in the middle of compilation (of a string
literal), the translation function should not do any C<eval>s or
C<require>s.  This restriction should be lifted (but is low priority) in
a577 2

# ex: set ts=8 sts=2 sw=2 et:
@


1.1.1.11
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d4 1
a4 1
our $VERSION = '1.36';
a90 2
=encoding utf8

a112 1
 use utf8;
a115 1
   "自転車に乗る人" => "BICYCLIST"
a118 2
 print "And I can create synonyms in other languages,",
       " such as \N{自転車に乗る人} for "BICYCLIST (U+1F6B4)\n";
d214 2
a215 3
Note, starting in Perl 5.18, the name C<BELL> refers to the Unicode character
U+1F514, instead of the traditional U+0007.  For the latter, use C<ALERT>
or C<BEL>.
d217 2
a218 1
It is a syntax error to use C<\N{NAME}> where C<NAME> is unknown.
d251 2
a252 2
spellings, and probably only when those look-ups are through C<vianame()> and
C<string_vianame()>, since C<\N{...}> look-ups are done at compile time.
d273 7
a279 13
Aliases must begin with a character that is alphabetic.  After that, each may
contain any combination of word (C<\w>) characters, SPACE (U+0020),
HYPHEN-MINUS (U+002D), LEFT PARENTHESIS (U+0028), RIGHT PARENTHESIS (U+0029),
and NO-BREAK SPACE (U+00A0).  These last three should never have been allowed
in names, and are retained for backwards compatibility only; they may be
deprecated and removed in future releases of Perl, so don't use them for new
names.  (More precisely, the first character of a name you specify must be
something that matches all of C<\p{ID_Start}>, C<\p{Alphabetic}>, and
C<\p{Gc=Letter}>.  This makes sure it is what any reasonable person would view
as an alphabetic character.  And, the continuation characters that match C<\w>
must also match C<\p{ID_Continue}>.)  Starting with Perl v5.18, any Unicode
characters meeting the above criteria may be used; prior to that only
Latin1-range characters were acceptable.
d340 3
a342 4
The only differences are due to the fact that C<string_vianame> is run-time
and C<\N{}> is compile time.  You can't interpolate inside a C<\N{}>, (so
C<\N{$variable}> doesn't work); and if the input name is unknown,
C<string_vianame> returns C<undef> instead of it being a syntax error.
d347 1
a347 1
circumstances, C<vianame> returns an ordinal code
d382 1
a382 1
point.  In Unicode the proper name for these is the empty string, which
d476 4
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d4 1
a4 1
our $VERSION = '1.40';
d174 1
a174 1
The character it inserts is the one whose Unicode code point
d231 1
a231 1
C<S<\N{U+I<code point>}>> will automatically have Unicode rules (see
a302 4
If it begins with C<"U+">, it is interpreted as the Unicode code point;
otherwise it is interpreted as native.  (Only code points below 256 can
differ between Unicode and native.)  Thus C<U+41> is always the Latin letter
"A"; but C<0x41> can be "NO-BREAK SPACE" on EBCDIC platforms.
a404 4
If it begins with C<"U+">, it is interpreted as the Unicode code point;
otherwise it is interpreted as native.  (Only code points below 256 can
differ between Unicode and native.)  Thus C<U+41> is always the Latin letter
"A"; but C<0x41> can be "NO-BREAK SPACE" on EBCDIC platforms.
@


