head	1.2;
access;
symbols
	OPENBSD_6_1:1.2.0.4
	OPENBSD_6_1_BASE:1.2
	OPENBSD_6_0:1.1.1.9.0.10
	OPENBSD_6_0_BASE:1.1.1.9
	OPENBSD_5_9:1.1.1.9.0.4
	OPENBSD_5_9_BASE:1.1.1.9
	OPENBSD_5_8:1.1.1.9.0.6
	OPENBSD_5_8_BASE:1.1.1.9
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.1.1.9.0.2
	OPENBSD_5_7_BASE:1.1.1.9
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.1.1.8.0.4
	OPENBSD_5_6_BASE:1.1.1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.7.0.6
	OPENBSD_5_5_BASE:1.1.1.7
	OPENBSD_5_4:1.1.1.7.0.2
	OPENBSD_5_4_BASE:1.1.1.7
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.8
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.4
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.18
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.16
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.14
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.12
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.10
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.8
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.6
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.4
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.2
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.3.0.2
	OPENBSD_3_5_BASE:1.1.1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.1.1.2.0.4
	OPENBSD_3_4_BASE:1.1.1.2
	OPENBSD_3_3:1.1.1.2.0.2
	OPENBSD_3_3_BASE:1.1.1.2
	PERL_5_8_0:1.1.1.2
	OPENBSD_3_2:1.1.1.1.0.12
	OPENBSD_3_2_BASE:1.1.1.1
	OPENBSD_3_1:1.1.1.1.0.10
	OPENBSD_3_1_BASE:1.1.1.1
	OPENBSD_3_0:1.1.1.1.0.8
	OPENBSD_3_0_BASE:1.1.1.1
	PERL_5_6_1:1.1.1.1
	OPENBSD_2_9:1.1.1.1.0.6
	OPENBSD_2_9_BASE:1.1.1.1
	OPENBSD_2_8:1.1.1.1.0.4
	OPENBSD_2_8_BASE:1.1.1.1
	OPENBSD_2_7:1.1.1.1.0.2
	OPENBSD_2_7_BASE:1.1.1.1
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.1;
commitid	cxJ08BvJA9Pt2PTM;

1.1
date	2000.04.06.16.09.39;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.39;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2003.12.03.02.44.00;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.46.45;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.31;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.48.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.08.53;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.08;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.2
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package utf8;
use strict;
use warnings;
use re "/aa";  # So we won't even try to look at above Latin1, potentially
               # resulting in a recursive call

sub DEBUG () { 0 }
$|=1 if DEBUG;

sub DESTROY {}

my %Cache;

sub croak { require Carp; Carp::croak(@@_) }

sub _loose_name ($) {
    # Given a lowercase property or property-value name, return its
    # standardized version that is expected for look-up in the 'loose' hashes
    # in Heavy.pl (hence, this depends on what mktables does).  This squeezes
    # out blanks, underscores and dashes.  The complication stems from the
    # grandfathered-in 'L_', which retains a single trailing underscore.

    (my $loose = $_[0]) =~ s/[-_ \t]//g;

    return $loose if $loose !~ / ^ (?: is | to )? l $/x;
    return 'l_' if $_[0] =~ / l .* _ /x;    # If original had a trailing '_'
    return $loose;
}

##
## "SWASH" == "SWATCH HASH". A "swatch" is a swatch of the Unicode landscape.
## It's a data structure that encodes a set of Unicode characters.
##

{
    # If a floating point number is within this distance from the value of a
    # fraction, it is considered to be that fraction, even if many more digits
    # are specified that don't exactly match.
    my $min_floating_slop;

    # To guard against this program calling something that in turn ends up
    # calling this program with the same inputs, and hence infinitely
    # recursing, we keep a stack of the properties that are currently in
    # progress, pushed upon entry, popped upon return.
    my @@recursed;

    sub SWASHNEW {
        my ($class, $type, $list, $minbits, $none) = @@_;
        my $user_defined = 0;
        local $^D = 0 if $^D;

        $class = "" unless defined $class;
        print STDERR __LINE__, ": class=$class, type=$type, list=",
                                (defined $list) ? $list : ':undef:',
                                ", minbits=$minbits, none=$none\n" if DEBUG;

        ##
        ## Get the list of codepoints for the type.
        ## Called from swash_init (see utf8.c) or SWASHNEW itself.
        ##
        ## Callers of swash_init:
        ##     op.c:pmtrans             -- for tr/// and y///
        ##     regexec.c:regclass_swash -- for /[]/, \p, and \P
        ##     utf8.c:is_utf8_common    -- for common Unicode properties
        ##     utf8.c:S__to_utf8_case   -- for lc, uc, ucfirst, etc. and //i
        ##     Unicode::UCD::prop_invlist
        ##     Unicode::UCD::prop_invmap
        ##
        ## Given a $type, our goal is to fill $list with the set of codepoint
        ## ranges. If $type is false, $list passed is used.
        ##
        ## $minbits:
        ##     For binary properties, $minbits must be 1.
        ##     For character mappings (case and transliteration), $minbits must
        ##     be a number except 1.
        ##
        ## $list (or that filled according to $type):
        ##     Refer to perlunicode.pod, "User-Defined Character Properties."
        ##     
        ##     For binary properties, only characters with the property value
        ##     of True should be listed. The 3rd column, if any, will be ignored
        ##
        ## $none is undocumented, so I'm (khw) trying to do some documentation
        ## of it now.  It appears to be if there is a mapping in an input file
        ## that maps to 'XXXX', then that is replaced by $none+1, expressed in
        ## hexadecimal.  It is used somehow in tr///.
        ##
        ## To make the parsing of $type clear, this code takes the a rather
        ## unorthodox approach of last'ing out of the block once we have the
        ## info we need. Were this to be a subroutine, the 'last' would just
        ## be a 'return'.
        ##
        #   If a problem is found $type is returned;
        #   Upon success, a new (or cached) blessed object is returned with
        #   keys TYPE, BITS, EXTRAS, LIST, and NONE with values having the
        #   same meanings as the input parameters.
        #   SPECIALS contains a reference to any special-treatment hash in the
        #       property.
        #   INVERT_IT is non-zero if the result should be inverted before use
        #   USER_DEFINED is non-zero if the result came from a user-defined
        my $file; ## file to load data from, and also part of the %Cache key.

        # Change this to get a different set of Unicode tables
        my $unicore_dir = 'unicore';
        my $invert_it = 0;
        my $list_is_from_mktables = 0;  # Is $list returned from a mktables
                                        # generated file?  If so, we know it's
                                        # well behaved.

        if ($type)
        {
            # Verify that this isn't a recursive call for this property.
            # Can't use croak, as it may try to recurse to here itself.
            my $class_type = $class . "::$type";
            if (grep { $_ eq $class_type } @@recursed) {
                CORE::die "panic: Infinite recursion in SWASHNEW for '$type'\n";
            }
            push @@recursed, $class_type;

            $type =~ s/^\s+//;
            $type =~ s/\s+$//;

            # regcomp.c surrounds the property name with '__" and '_i' if this
            # is to be caseless matching.
            my $caseless = $type =~ s/^(.*)__(.*)_i$/$1$2/;

            print STDERR __LINE__, ": type=$type, caseless=$caseless\n" if DEBUG;

        GETFILE:
            {
                ##
                ## It could be a user-defined property.  Look in current
                ## package if no package given
                ##


                my $caller0 = caller(0);
                my $caller1 = $type =~ s/(.+):://
                              ? $1
                              : $caller0 eq 'main'
                                ? 'main'
                                : caller(1);

                if (defined $caller1 && $type =~ /^I[ns]\w+$/) {
                    my $prop = "${caller1}::$type";
                    if (exists &{$prop}) {
                        # stolen from Scalar::Util::PP::tainted()
                        my $tainted;
                        {
                            local($@@, $SIG{__DIE__}, $SIG{__WARN__});
                            local $^W = 0;
                            no warnings;
                            eval { kill 0 * $prop };
                            $tainted = 1 if $@@ =~ /^Insecure/;
                        }
                        die "Insecure user-defined property \\p{$prop}\n"
                            if $tainted;
                        no strict 'refs';
                        $list = &{$prop}($caseless);
                        $user_defined = 1;
                        last GETFILE;
                    }
                }

                # During Perl's compilation, this routine may be called before
                # the tables are constructed.  If so, we have a chicken/egg
                # problem.  If we die, the tables never get constructed, so
                # keep going, but return an empty table so only what the code
                # has compiled in internally (currently ASCII/Latin1 range
                # matching) will work.
                BEGIN {
                    # Poor man's constant, to avoid a run-time check.
                    $utf8::{miniperl}
                        = \! defined &DynaLoader::boot_DynaLoader;
                }
                if (miniperl) {
                    eval "require '$unicore_dir/Heavy.pl'";
                    if ($@@) {
                        print STDERR __LINE__, ": '$@@'\n" if DEBUG;
                        pop @@recursed if @@recursed;
                        return $type;
                    }
                }
                else {
                    require "$unicore_dir/Heavy.pl";
                }
                BEGIN { delete $utf8::{miniperl} }

                # All property names are matched caselessly
                my $property_and_table = CORE::lc $type;
                print STDERR __LINE__, ": $property_and_table\n" if DEBUG;

                # See if is of the compound form 'property=value', where the
                # value indicates the table we should use.
                my ($property, $table, @@remainder) =
                                    split /\s*[:=]\s*/, $property_and_table, -1;
                if (@@remainder) {
                    pop @@recursed if @@recursed;
                    return $type;
                }

                my $prefix;
                if (! defined $table) {
                        
                    # Here, is the single form.  The property becomes empty, and
                    # the whole value is the table.
                    $table = $property;
                    $prefix = $property = "";
                } else {
                    print STDERR __LINE__, ": $property\n" if DEBUG;

                    # Here it is the compound property=table form.  The property
                    # name is always loosely matched, and always can have an
                    # optional 'is' prefix (which isn't true in the single
                    # form).
                    $property = _loose_name($property) =~ s/^is//r;

                    # And convert to canonical form.  Quit if not valid.
                    $property = $utf8::loose_property_name_of{$property};
                    if (! defined $property) {
                        pop @@recursed if @@recursed;
                        return $type;
                    }

                    $prefix = "$property=";

                    # If the rhs looks like it is a number...
                    print STDERR __LINE__, ": table=$table\n" if DEBUG;
                    if ($table =~ m{ ^ [ \s 0-9 _  + / . -]+ $ }x) {
                        print STDERR __LINE__, ": table=$table\n" if DEBUG;

                        # Don't allow leading nor trailing slashes 
                        if ($table =~ / ^ \/ | \/ $ /x) {
                            pop @@recursed if @@recursed;
                            return $type;
                        }

                        # Split on slash, in case it is a rational, like \p{1/5}
                        my @@parts = split m{ \s* / \s* }x, $table, -1;
                        print __LINE__, ": $type\n" if @@parts > 2 && DEBUG;

                        # Can have maximum of one slash
                        if (@@parts > 2) {
                            pop @@recursed if @@recursed;
                            return $type;
                        }

                        foreach my $part (@@parts) {
                            print __LINE__, ": part=$part\n" if DEBUG;

                            $part =~ s/^\+\s*//;    # Remove leading plus
                            $part =~ s/^-\s*/-/;    # Remove blanks after unary
                                                    # minus

                            # Remove underscores between digits.
                            $part =~ s/(?<= [0-9] ) _ (?= [0-9] ) //xg;

                            # No leading zeros (but don't make a single '0'
                            # into a null string)
                            $part =~ s/ ^ ( -? ) 0+ /$1/x;
                            $part .= '0' if $part eq '-' || $part eq "";

                            # No trailing zeros after a decimal point
                            $part =~ s/ ( \. .*? ) 0+ $ /$1/x;

                            # Begin with a 0 if a leading decimal point
                            $part =~ s/ ^ ( -? ) \. /${1}0./x;

                            # Ensure not a trailing decimal point: turn into an
                            # integer
                            $part =~ s/ \. $ //x;

                            print STDERR __LINE__, ": part=$part\n" if DEBUG;
                            #return $type if $part eq "";
                            
                            # Result better look like a number.  (This test is
                            # needed because, for example could have a plus in
                            # the middle.)
                            if ($part !~ / ^ -? [0-9]+ ( \. [0-9]+)? $ /x) {
                                pop @@recursed if @@recursed;
                                return $type;
                            }
                        }

                        #  If a rational...
                        if (@@parts == 2) {

                            # If denominator is negative, get rid of it, and ...
                            if ($parts[1] =~ s/^-//) {

                                # If numerator is also negative, convert the
                                # whole thing to positive, else move the minus
                                # to the numerator
                                if ($parts[0] !~ s/^-//) {
                                    $parts[0] = '-' . $parts[0];
                                }
                            }
                            $table = join '/', @@parts;
                        }
                        elsif ($property ne 'nv' || $parts[0] !~ /\./) {

                            # Here is not numeric value, or doesn't have a
                            # decimal point.  No further manipulation is
                            # necessary.  (Note the hard-coded property name.
                            # This could fail if other properties eventually
                            # had fractions as well; perhaps the cjk ones
                            # could evolve to do that.  This hard-coding could
                            # be fixed by mktables generating a list of
                            # properties that could have fractions.)
                            $table = $parts[0];
                        } else {

                            # Here is a floating point numeric_value.  Try to
                            # convert to rational.  First see if is in the list
                            # of known ones.
                            if (exists $utf8::nv_floating_to_rational{$parts[0]}) {
                                $table = $utf8::nv_floating_to_rational{$parts[0]};
                            } else {

                                # Here not in the list.  See if is close
                                # enough to something in the list.  First
                                # determine what 'close enough' means.  It has
                                # to be as tight as what mktables says is the
                                # maximum slop, and as tight as how many
                                # digits we were passed.  That is, if the user
                                # said .667, .6667, .66667, etc.  we match as
                                # many digits as they passed until get to
                                # where it doesn't matter any more due to the
                                # machine's precision.  If they said .6666668,
                                # we fail.
                                (my $fraction = $parts[0]) =~ s/^.*\.//;
                                my $epsilon = 10 ** - (length($fraction));
                                if ($epsilon > $utf8::max_floating_slop) {
                                    $epsilon = $utf8::max_floating_slop;
                                }

                                # But it can't be tighter than the minimum
                                # precision for this machine.  If haven't
                                # already calculated that minimum, do so now.
                                if (! defined $min_floating_slop) {

                                    # Keep going down an order of magnitude
                                    # until find that adding this quantity to
                                    # 1 remains 1; but put an upper limit on
                                    # this so in case this algorithm doesn't
                                    # work properly on some platform, that we
                                    # won't loop forever.
                                    my $count = 0;
                                    $min_floating_slop = 1;
                                    while (1+ $min_floating_slop != 1
                                           && $count++ < 50)
                                    {
                                        my $next = $min_floating_slop / 10;
                                        last if $next == 0; # If underflows,
                                                            # use previous one
                                        $min_floating_slop = $next;
                                        print STDERR __LINE__, ": min_float_slop=$min_floating_slop\n" if DEBUG;
                                    }

                                    # Back off a couple orders of magnitude,
                                    # just to be safe.
                                    $min_floating_slop *= 100;
                                }
                                    
                                if ($epsilon < $min_floating_slop) {
                                    $epsilon = $min_floating_slop;
                                }
                                print STDERR __LINE__, ": fraction=.$fraction; epsilon=$epsilon\n" if DEBUG;

                                undef $table;

                                # And for each possible rational in the table,
                                # see if it is within epsilon of the input.
                                foreach my $official
                                        (keys %utf8::nv_floating_to_rational)
                                {
                                    print STDERR __LINE__, ": epsilon=$epsilon, official=$official, diff=", abs($parts[0] - $official), "\n" if DEBUG;
                                    if (abs($parts[0] - $official) < $epsilon) {
                                      $table =
                                      $utf8::nv_floating_to_rational{$official};
                                        last;
                                    }
                                }

                                # Quit if didn't find one.
                                if (! defined $table) {
                                    pop @@recursed if @@recursed;
                                    return $type;
                                }
                            }
                        }
                        print STDERR __LINE__, ": $property=$table\n" if DEBUG;
                    }
                }

                # Combine lhs (if any) and rhs to get something that matches
                # the syntax of the lookups.
                $property_and_table = "$prefix$table";
                print STDERR __LINE__, ": $property_and_table\n" if DEBUG;

                # First try stricter matching.
                $file = $utf8::stricter_to_file_of{$property_and_table};

                # If didn't find it, try again with looser matching by editing
                # out the applicable characters on the rhs and looking up
                # again.
                my $strict_property_and_table;
                if (! defined $file) {

                    # This isn't used unless the name begins with 'to'
                    $strict_property_and_table = $property_and_table =~  s/^to//r;
                    $table = _loose_name($table);
                    $property_and_table = "$prefix$table";
                    print STDERR __LINE__, ": $property_and_table\n" if DEBUG;
                    $file = $utf8::loose_to_file_of{$property_and_table};
                }

                # Add the constant and go fetch it in.
                if (defined $file) {

                    # If the file name contains a !, it means to invert.  The
                    # 0+ makes sure result is numeric
                    $invert_it = 0 + $file =~ s/!//;

                    if ($utf8::why_deprecated{$file}) {
                        warnings::warnif('deprecated', "Use of '$type' in \\p{} or \\P{} is deprecated because: $utf8::why_deprecated{$file};");
                    }

                    if ($caseless
                        && exists $utf8::caseless_equivalent{$property_and_table})
                    {
                        $file = $utf8::caseless_equivalent{$property_and_table};
                    }

                    # The pseudo-directory '#' means that there really isn't a
                    # file to read, the data is in-line as part of the string;
                    # we extract it below.
                    $file = "$unicore_dir/lib/$file.pl" unless $file =~ m!^#/!;
                    last GETFILE;
                }
                print STDERR __LINE__, ": didn't find $property_and_table\n" if DEBUG;

                ##
                ## Last attempt -- see if it's a standard "To" name
                ## (e.g. "ToLower")  ToTitle is used by ucfirst().
                ## The user-level way to access ToDigit() and ToFold()
                ## is to use Unicode::UCD.
                ##
                # Only check if caller wants non-binary
                if ($minbits != 1) {
                    if ($property_and_table =~ s/^to//) {
                    # Look input up in list of properties for which we have
                    # mapping files.  First do it with the strict approach
                        if (defined ($file = $utf8::strict_property_to_file_of{
                                                    $strict_property_and_table}))
                        {
                            $type = $utf8::file_to_swash_name{$file};
                            print STDERR __LINE__, ": type set to $type\n"
                                                                        if DEBUG;
                            $file = "$unicore_dir/$file.pl";
                            last GETFILE;
                        }
                        elsif (defined ($file =
                          $utf8::loose_property_to_file_of{$property_and_table}))
                        {
                            $type = $utf8::file_to_swash_name{$file};
                            print STDERR __LINE__, ": type set to $type\n"
                                                                        if DEBUG;
                            $file = "$unicore_dir/$file.pl";
                            last GETFILE;
                        }   # If that fails see if there is a corresponding binary
                            # property file
                        elsif (defined ($file =
                                    $utf8::loose_to_file_of{$property_and_table}))
                        {

                            # Here, there is no map file for the property we
                            # are trying to get the map of, but this is a
                            # binary property, and there is a file for it that
                            # can easily be translated to a mapping, so use
                            # that, treating this as a binary property.
                            # Setting 'minbits' here causes it to be stored as
                            # such in the cache, so if someone comes along
                            # later looking for just a binary, they get it.
                            $minbits = 1;

                            # The 0+ makes sure is numeric
                            $invert_it = 0 + $file =~ s/!//;
                            $file = "$unicore_dir/lib/$file.pl"
                                                         unless $file =~ m!^#/!;
                            last GETFILE;
                        }
                    }
                }

                ##
                ## If we reach this line, it's because we couldn't figure
                ## out what to do with $type. Ouch.
                ##

                pop @@recursed if @@recursed;
                return $type;
            } # end of GETFILE block

            if (defined $file) {
                print STDERR __LINE__, ": found it (file='$file')\n" if DEBUG;

                ##
                ## If we reach here, it was due to a 'last GETFILE' above
                ## (exception: user-defined properties and mappings), so we
                ## have a filename, so now we load it if we haven't already.

                # The pseudo-directory '#' means the result isn't really a
                # file, but is in-line, with semi-colons to be turned into
                # new-lines.  Since it is in-line there is no advantage to
                # caching the result
                if ($file =~ s!^#/!!) {
                    $list = $utf8::inline_definitions[$file];
                }
                else {
                    # Here, we have an actual file to read in and load, but it
                    # may already have been read-in and cached.  The cache key
                    # is the class and file to load, and whether the results
                    # need to be inverted.
                    my $found = $Cache{$class, $file, $invert_it};
                    if ($found and ref($found) eq $class) {
                        print STDERR __LINE__, ": Returning cached swash for '$class,$file,$invert_it' for \\p{$type}\n" if DEBUG;
                        pop @@recursed if @@recursed;
                        return $found;
                    }

                    local $@@;
                    local $!;
                    $list = do $file; die $@@ if $@@;
                }

                $list_is_from_mktables = 1;
            }
        } # End of $type is non-null

        # Here, either $type was null, or we found the requested property and
        # read it into $list

        my $extras = "";

        my $bits = $minbits;

        # mktables lists don't have extras, like '&utf8::prop', so don't need
        # to separate them; also lists are already sorted, so don't need to do
        # that.
        if ($list && ! $list_is_from_mktables) {
            my $taint = substr($list,0,0); # maintain taint

            # Separate the extras from the code point list, and make sure
            # user-defined properties and tr/// are well-behaved for
            # downstream code.
            if ($user_defined || $none) {
                my @@tmp = split(/^/m, $list);
                my %seen;
                no warnings;

                # The extras are anything that doesn't begin with a hex digit.
                $extras = join '', $taint, grep /^[^0-9a-fA-F]/, @@tmp;

                # Remove the extras, and sort the remaining entries by the
                # numeric value of their beginning hex digits, removing any
                # duplicates.
                $list = join '', $taint,
                        map  { $_->[1] }
                        sort { $a->[0] <=> $b->[0] }
                        map  { /^([0-9a-fA-F]+)/ && !$seen{$1}++ ? [ CORE::hex($1), $_ ] : () }
                        @@tmp; # XXX doesn't do ranges right
            }
            else {
                # mktables has gone to some trouble to make non-user defined
                # properties well-behaved, so we can skip the effort we do for
                # user-defined ones.  Any extras are at the very beginning of
                # the string.

                # This regex splits out the first lines of $list into $1 and
                # strips them off from $list, until we get one that begins
                # with a hex number, alone on the line, or followed by a tab.
                # Either portion may be empty.
                $list =~ s/ \A ( .*? )
                            (?: \z | (?= ^ [0-9a-fA-F]+ (?: \t | $) ) )
                          //msx;

                $extras = "$taint$1";
            }
        }

        if ($none) {
            my $hextra = sprintf "%04x", $none + 1;
            $list =~ s/\tXXXX$/\t$hextra/mg;
        }

        if ($minbits != 1 && $minbits < 32) { # not binary property
            my $top = 0;
            while ($list =~ /^([0-9a-fA-F]+)(?:[\t]([0-9a-fA-F]+)?)(?:[ \t]([0-9a-fA-F]+))?/mg) {
                my $min = CORE::hex $1;
                my $max = defined $2 ? CORE::hex $2 : $min;
                my $val = defined $3 ? CORE::hex $3 : 0;
                $val += $max - $min if defined $3;
                $top = $val if $val > $top;
            }
            my $topbits =
                $top > 0xffff ? 32 :
                $top > 0xff ? 16 : 8;
            $bits = $topbits if $bits < $topbits;
        }

        my @@extras;
        if ($extras) {
            for my $x ($extras) {
                my $taint = substr($x,0,0); # maintain taint
                pos $x = 0;
                while ($x =~ /^([^0-9a-fA-F\n])(.*)/mg) {
                    my $char = "$1$taint";
                    my $name = "$2$taint";
                    print STDERR __LINE__, ": char [$char] => name [$name]\n"
                        if DEBUG;
                    if ($char =~ /[-+!&]/) {
                        my ($c,$t) = split(/::/, $name, 2);	# bogus use of ::, really
                        my $subobj;
                        if ($c eq 'utf8') {
                            $subobj = utf8->SWASHNEW($t, "", $minbits, 0);
                        }
                        elsif (exists &$name) {
                            $subobj = utf8->SWASHNEW($name, "", $minbits, 0);
                        }
                        elsif ($c =~ /^([0-9a-fA-F]+)/) {
                            $subobj = utf8->SWASHNEW("", $c, $minbits, 0);
                        }
                        print STDERR __LINE__, ": returned from getting sub object for $name\n" if DEBUG;
                        if (! ref $subobj) {
                            pop @@recursed if @@recursed && $type;
                            return $subobj;
                        }
                        push @@extras, $name => $subobj;
                        $bits = $subobj->{BITS} if $bits < $subobj->{BITS};
                        $user_defined = $subobj->{USER_DEFINED}
                                              if $subobj->{USER_DEFINED};
                    }
                }
            }
        }

        if (DEBUG) {
            print STDERR __LINE__, ": CLASS = $class, TYPE => $type, BITS => $bits, NONE => $none, INVERT_IT => $invert_it, USER_DEFINED => $user_defined";
            print STDERR "\nLIST =>\n$list" if defined $list;
            print STDERR "\nEXTRAS =>\n$extras" if defined $extras;
            print STDERR "\n";
        }

        my $SWASH = bless {
            TYPE => $type,
            BITS => $bits,
            EXTRAS => $extras,
            LIST => $list,
            NONE => $none,
            USER_DEFINED => $user_defined,
            @@extras,
        } => $class;

        if ($file) {
            $Cache{$class, $file, $invert_it} = $SWASH;
            if ($type
                && exists $utf8::SwashInfo{$type}
                && exists $utf8::SwashInfo{$type}{'specials_name'})
            {
                my $specials_name = $utf8::SwashInfo{$type}{'specials_name'};
                no strict "refs";
                print STDERR "\nspecials_name => $specials_name\n" if DEBUG;
                $SWASH->{'SPECIALS'} = \%$specials_name;
            }
            $SWASH->{'INVERT_IT'} = $invert_it;
        }

        pop @@recursed if @@recursed && $type;

        return $SWASH;
    }
}

# Now SWASHGET is recasted into a C function S_swatch_get (see utf8.c).

1;
@


1.1
log
@Initial revision
@
text
@d2 4
d7 2
a8 2
my $DEBUG = 0;
my $seq = "AAA0000";
d12 2
d16 13
a28 11
sub SWASHNEW {
    my ($class, $type, $list, $minbits, $none) = @@_;
    local $^D = 0 if $^D;
    print STDERR "SWASHNEW @@_\n" if $DEBUG;
    my $extras;
    my $bits;
 
    if ($type and ref ${"${class}::{$type}"} eq $class) {
	warn qq/Found \${"${class}::{$type}"}\n/ if $DEBUG;
	return ${"${class}::{$type}"};	# Already there...
    }
d30 648
a677 1
    $type ||= $seq++;
d679 1
a679 23
    my $caller;
    my $i = 0;
    while (($caller = caller($i)) eq __PACKAGE__) { $i++ }
    my $encoding = $enc{$caller} || "unicode";
    (my $file = $type) =~ s!::!/!g;
    $file =~ s#^(I[sn]|To)([A-Z].*)#$1/$2#;
    $list ||= eval { $caller->$type(); }
	|| do "$file.pl"
	|| do "$encoding/$file.pl"
	|| do "$encoding/Is/${type}.pl"
	|| croak("Can't find $encoding character property definition via $caller->$type or $file.pl");

    $| = 1;

    if ($list) {
	my @@tmp = split(/^/m, $list);
	my %seen;
	no warnings;
	$extras = join '', grep /^[^0-9a-fA-F]/, @@tmp;
	$list = join '',
	    sort { hex $a <=> hex $b }
	    grep {/^([0-9a-fA-F]+)/ and not $seen{$1}++} @@tmp; # XXX doesn't do ranges right
    }
d681 1
a681 3
    if ($none) {
	my $hextra = sprintf "%04x", $none + 1;
	$list =~ s/\tXXXX$/\t$hextra/mg;
a682 43

    if ($minbits < 32) {
	my $top = 0;
	while ($list =~ /^([0-9a-fA-F]+)(?:\t([0-9a-fA-F]+)?)(?:\t([0-9a-fA-F]+))?/mg) {
	    my $min = hex $1;
	    my $max = hex(defined $2 ? $2 : $1);
	    my $val = hex(defined $3 ? $3 : "");
	    $val += $max - $min if defined $3;
	    $top = $val if $val > $top;
	}
	$bits =
	    $top > 0xffff ? 32 :
	    $top > 0xff ? 16 :
	    $top > 1 ? 8 : 1
    }
    $bits = $minbits if $bits < $minbits;

    my @@extras;
    for my $x ($extras) {
	pos $x = 0;
	while ($x =~ /^([^0-9a-fA-F\n])(.*)/mg) {
	    my $char = $1;
	    my $name = $2;
	    # print STDERR "$1 => $2\n" if $DEBUG;
	    if ($char =~ /[-+!]/) {
		my ($c,$t) = split(/::/, $name, 2);	# bogus use of ::, really
		my $subobj = $c->SWASHNEW($t, "", 0, 0, 0);
		push @@extras, $name => $subobj;
		$bits = $subobj->{BITS} if $bits < $subobj->{BITS};
	    }
	}
    }

    print STDERR "CLASS = $class, TYPE => $type, BITS => $bits, NONE => $none\nEXTRAS =>\n$extras\nLIST =>\n$list\n" if $DEBUG;

    ${"${class}::{$type}"} = bless {
	TYPE => $type,
	BITS => $bits,
	EXTRAS => $extras,
	LIST => $list,
	NONE => $none,
	@@extras,
    } => $class;
d685 1
a685 123
# NOTE: utf8.c:swash_init() assumes entries are never modified once generated.

sub SWASHGET {
    my ($self, $start, $len) = @@_;
    local $^D = 0 if $^D;
    my $type = $self->{TYPE};
    my $bits = $self->{BITS};
    my $none = $self->{NONE};
    print STDERR "SWASHGET @@_ [$type/$bits/$none]\n" if $DEBUG;
    my $end = $start + $len;
    my $swatch = "";
    my $key;
    vec($swatch, $len - 1, $bits) = 0;	# Extend to correct length.
    if ($none) {
	for $key (0 .. $len - 1) { vec($swatch, $key, $bits) = $none }
    }

    for ($self->{LIST}) {
	pos $_ = 0;
	if ($bits > 1) {
	  LINE:
	    while (/^([0-9a-fA-F]+)(?:\t([0-9a-fA-F]+)?)(?:\t([0-9a-fA-F]+))?/mg) {
		my $min = hex $1;
		my $max = (defined $2 ? hex $2 : $min);
		my $val = hex $3;
		next if $max < $start;
#		print "$min $max $val\n";
		if ($none) {
		    if ($min < $start) {
			$val += $start - $min if $val < $none;
			$min = $start;
		    }
		    for ($key = $min; $key <= $max; $key++) {
			last LINE if $key >= $end;
#			print STDERR "$key => $val\n" if $DEBUG;
			vec($swatch, $key - $start, $bits) = $val;
			++$val if $val < $none;
		    }
		}
		else {
		    if ($min < $start) {
			$val += $start - $min;
			$min = $start;
		    }
		    for ($key = $min; $key <= $max; $key++, $val++) {
			last LINE if $key >= $end;
#			print STDERR "$key => $val\n" if $DEBUG;
			vec($swatch, $key - $start, $bits) = $val;
		    }
		}
	    }
	}
	else {
	  LINE:
	    while (/^([0-9a-fA-F]+)(?:\t([0-9a-fA-F]+))?/mg) {
		my $min = hex $1;
		my $max = (defined $2 ? hex $2 : $min);
		next if $max < $start;
		if ($min < $start) {
		    $min = $start;
		}
		for ($key = $min; $key <= $max; $key++) {
		    last LINE if $key >= $end;
#		    print STDERR "$key => 1\n" if $DEBUG;
		    vec($swatch, $key - $start, 1) = 1;
		}
	    }
	}
    }
    for my $x ($self->{EXTRAS}) {
	pos $x = 0;
	while ($x =~ /^([-+!])(.*)/mg) {
	    my $char = $1;
	    my $name = $2;
	    print STDERR "INDIRECT $1 $2\n" if $DEBUG;
	    my $otherbits = $self->{$name}->{BITS};
	    croak("SWASHGET size mismatch") if $bits < $otherbits;
	    my $other = $self->{$name}->SWASHGET($start, $len);
	    if ($char eq '+') {
		if ($bits == 1 and $otherbits == 1) {
		    $swatch |= $other;
		}
		else {
		    for ($key = 0; $key < $len; $key++) {
			vec($swatch, $key, $bits) = vec($other, $key, $otherbits);
		    }
		}
	    }
	    elsif ($char eq '!') {
		if ($bits == 1 and $otherbits == 1) {
		    $swatch |= ~$other;
		}
		else {
		    for ($key = 0; $key < $len; $key++) {
			if (!vec($other, $key, $otherbits)) {
			    vec($swatch, $key, $bits) = 1;
			}
		    }
		}
	    }
	    elsif ($char eq '-') {
		if ($bits == 1 and $otherbits == 1) {
		    $swatch &= ~$other;
		}
		else {
		    for ($key = 0; $key < $len; $key++) {
			if (vec($other, $key, $otherbits)) {
			    vec($swatch, $key, $bits) = 0;
			}
		    }
		}
	    }
	}
    }
    if ($DEBUG) {
	print STDERR "CELLS ";
	for ($key = 0; $key < $len; $key++) {
	    print STDERR vec($swatch, $key, $bits), " ";
	}
	print STDERR "\n";
    }
    $swatch;
}
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.8.0 from CPAN
@
text
@a1 2
use strict;
use warnings;
d3 2
a4 1
sub DEBUG () { 0 }
a7 2
my %Cache;

a9 4
##
## "SWASH" == "SWATCH HASH". A "swatch" is a swatch of the Unicode landscape
##

d13 1
a13 123

    print STDERR "SWASHNEW @@_\n" if DEBUG;

    ##
    ## Get the list of codepoints for the type.
    ## Called from utf8.c
    ##
    ## Given a $type, our goal is to fill $list with the set of codepoint
    ## ranges.
    ##
    ## To make the parsing of $type clear, this code takes the a rather
    ## unorthadox approach of last'ing out of the block once we have the
    ## info we need. Were this to be a subroutine, the 'last' would just
    ## be a 'return'.
    ##
    my $file; ## file to load data from, and also part of the %Cache key.
    my $ListSorted = 0;

    if ($type)
    {
        $type =~ s/^\s+//;
        $type =~ s/\s+$//;

        print "type = $type\n" if DEBUG;

      GETFILE:
        {
            ##
            ## 'Is' is always optional, so if it's there, remove it.
            ## Same with 'Category=' and 'Script='.
            ##
            ## 'Block=' is replaced by 'In'.
            ##
            $type =~ s/^Is(?:\s+|[-_])?//i
              or
            $type =~ s/^Category\s*=\s*//i
              or
            $type =~ s/^Script\s*=\s*//i
              or
            $type =~ s/^Block\s*=\s*/In/i;

            ##
            ## See if it's in the direct mapping table.
            ##
            require "unicore/Exact.pl";
            if (my $base = $utf8::Exact{$type}) {
                $file = "unicore/lib/$base.pl";
                last GETFILE;
            }

            ##
            ## If not there exactly, try the canonical form. The canonical
            ## form is lowercased, with any separators (\s+|[-_]) removed.
            ##
            my $canonical = lc $type;
            $canonical =~ s/(?<=[a-z\d])(?:\s+|[-_])(?=[a-z\d])//g;
            print "canonical = $canonical\n" if DEBUG;

            require "unicore/Canonical.pl";
            if (my $base = $utf8::Canonical{$canonical}) {
                $file = "unicore/lib/$base.pl";
                last GETFILE;
            }

	    ##
	    ## It could be a user-defined property.
	    ##

	    if ($type =~ /^I[ns](\w+)$/) {
                my @@caller = caller(1);

                if (defined $caller[0]) {
                    my $prop = $caller[0] . "::" . $type;

                    if (exists &{$prop}) {
                        no strict 'refs';

                        $list = &{$prop};
                        last GETFILE;
                    }
                }
            }

            ##
            ## Last attempt -- see if it's a "To" name (e.g. "ToLower")
            ##
            if ($type =~ /^To([A-Z][A-Za-z]+)$/)
            {
                $file = "unicore/To/$1.pl";
                ## would like to test to see if $file actually exists....
                last GETFILE;
            }

            ##
            ## If we reach this line, it's because we couldn't figure
            ## out what to do with $type. Ouch.
            ##

            return $type;
        }

	if (defined $file) {
	    print "found it (file='$file')\n" if DEBUG;

	    ##
	    ## If we reach here, it was due to a 'last GETFILE' above
	    ## (exception: user-defined properties), so we
	    ## have a filename, so now we load it if we haven't already.
	    ## If we have, return the cached results. The cache key is the
	    ## file to load.
	    ##
	    if ($Cache{$file} and ref($Cache{$file}) eq $class)
	    {
		print "Returning cached '$file' for \\p{$type}\n" if DEBUG;
		return $Cache{$class, $file};
	    }

	    $list = do $file;
	}

        $ListSorted = 1; ## we know that these lists are sorted
    }

d16 21
a37 1
    my $ORIG = $list;
d75 1
a75 1
	    print STDERR "$1 => $2\n" if DEBUG;
d78 1
a78 8
		my $subobj;
		if ($c eq 'utf8') {
		    $subobj = $c->SWASHNEW($t, "", 0, 0, 0);
		}
		elsif ($c =~ /^([0-9a-fA-F]+)/) {
		    $subobj = utf8->SWASHNEW("", $c, 0, 0, 0);
		}
		return $subobj unless ref $subobj;
d85 1
a85 1
    print STDERR "CLASS = $class, TYPE => $type, BITS => $bits, NONE => $none\nEXTRAS =>\n$extras\nLIST =>\n$list\n" if DEBUG;
d87 1
a87 1
    my $SWASH = bless {
a94 6

    if ($file) {
        $Cache{$class, $file} = $SWASH;
    }

    return $SWASH;
a99 1
    # See utf8.c:Perl_swash_fetch for problems with this interface.
d105 1
a105 1
    print STDERR "SWASHGET @@_ [$type/$bits/$none]\n" if DEBUG;
d123 1
a123 1
		print "$min $max $val\n" if DEBUG;
d131 1
a131 1
			print STDERR "$key => $val\n" if DEBUG;
d143 1
a143 1
			print STDERR "$key => $val\n" if DEBUG;
d151 1
a151 1
	    while (/^([0-9a-fA-F]+)(?:[ \t]+([0-9a-fA-F]+))?/mg) {
d160 1
a160 1
		    print STDERR "$key => 1\n" if DEBUG;
d171 1
a171 1
	    print STDERR "INDIRECT $1 $2\n" if DEBUG;
d211 1
a211 1
    if (DEBUG) {
@


1.1.1.3
log
@perl 5.8.2 from CPAN
@
text
@d14 1
a14 2
## "SWASH" == "SWATCH HASH". A "swatch" is a swatch of the Unicode landscape.
## It's a data structure that encodes a set of Unicode characters.
d31 1
a31 1
    ## unorthodox approach of last'ing out of the block once we have the
d53 1
a53 3
            my $wasIs;

            ($wasIs = $type =~ s/^Is(?:\s+|[-_])?//i)
d88 2
a89 1
	    my $caller1 = caller(1);
d91 2
a92 13
	    if (defined $caller1 && $type =~ /^(?:\w+)$/) {
		my $prop = $caller1 . "::" . ( $wasIs ? "Is" : "" ) . $type;
		if (exists &{$prop}) {
		    no strict 'refs';
		    
		    $list = &{$prop};
		    last GETFILE;
		}
	    }

	    ##
	    ## See if it's a user-level "To".
	    ##
d94 2
a95 1
	    my $caller0 = caller(0);
d97 5
a101 9
	    if (defined $caller0 && $type =~ /^To(?:\w+)$/) {
		my $map = $caller0 . "::" . $type;
		if (exists &{$map}) {
		    no strict 'refs';
		    
		    $list = &{$map};
		    last GETFILE;
		}
	    }
d104 1
a104 4
            ## Last attempt -- see if it's a standard "To" name
	    ## (e.g. "ToLower")  ToTitle is used by ucfirst().
	    ## The user-level way to access ToDigit() and ToFold()
	    ## is to use Unicode::UCD.
d106 1
a106 1
            if ($type =~ /^To(Digit|Fold|Lower|Title|Upper)$/)
d126 1
a126 1
	    ## (exception: user-defined properties and mappings), so we
d144 1
a144 1
    my $bits = 0;
d153 2
a154 4
	    map  { $_->[1] }
	    sort { $a->[0] <=> $b->[0] }
	    map  { /^([0-9a-fA-F]+)/; [ hex($1), $_ ] }
	    grep { /^([0-9a-fA-F]+)/ and not $seen{$1}++ } @@tmp; # XXX doesn't do ranges right
d164 1
a164 1
	while ($list =~ /^([0-9a-fA-F]+)(?:[\t]([0-9a-fA-F]+)?)(?:[ \t]([0-9a-fA-F]+))?/mg) {
d166 2
a167 2
	    my $max = defined $2 ? hex $2 : $min;
	    my $val = defined $3 ? hex $3 : 0;
d241 4
a244 9
	    while (/^([0-9a-fA-F]+)(?:[ \t]([0-9a-fA-F]+)?)?(?:[ \t]([0-9a-fA-F]+))?/mg) {
		chomp;
		my ($a, $b, $c) = ($1, $2, $3);
		croak "$type: illegal mapping '$_'"
		    if $type =~ /^To/ &&
		       !(defined $a && defined $c);
		my $min = hex $a;
		my $max = defined $b ? hex $b : $min;
		my $val = defined $c ? hex $c : 0;
a274 1
		chomp;
d276 1
a276 1
		my $max = defined $2 ? hex $2 : $min;
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@a10 2
our (%PropertyAlias, %PA_reverse, %PropValueAlias, %PVA_reverse, %PVA_abbr_map);

d48 6
a53 16
	    ##
	    ## It could be a user-defined property.
	    ##

	    my $caller1 = $type =~ s/(.+)::// ? $1 : caller(1);

	    if (defined $caller1 && $type =~ /^(?:\w+)$/) {
		my $prop = "${caller1}::$type";
		if (exists &{$prop}) {
		    no strict 'refs';
		    
		    $list = &{$prop};
		    last GETFILE;
		}
	    }

d58 1
a58 1
            $type =~ s/^(?:(?:General(?:\s+|_)?)?Category|gc)\s*[:=]\s*//i
d60 1
a60 1
            $type =~ s/^(?:Script|sc)\s*[:=]\s*//i
d62 1
a62 30
            $type =~ s/^Block\s*[:=]\s*/In/i;


	    ##
	    ## See if it's in some enumeration.
	    ##
	    require "unicore/PVA.pl";
	    if ($type =~ /^([\w\s]+)[:=]\s*(.*)/) {
		my ($enum, $val) = (lc $1, lc $2);
		$enum =~ tr/ _-//d;
		$val =~ tr/ _-//d;

		my $pa = $PropertyAlias{$enum} ? $enum : $PA_reverse{$enum};
		my $f = $PropValueAlias{$pa}{$val} ? $val : $PVA_reverse{$pa}{lc $val};

		if ($pa and $f) {
		    $pa = "gc_sc" if $pa eq "gc" or $pa eq "sc";
		    $file = "unicore/lib/$pa/$PVA_abbr_map{$pa}{lc $f}.pl";
		    last GETFILE;
		}
	    }
	    else {
		my $t = lc $type;
		$t =~ tr/ _-//d;

		if ($PropValueAlias{gc}{$t} or $PropValueAlias{sc}{$t}) {
		    $file = "unicore/lib/gc_sc/$PVA_abbr_map{gc_sc}{$t}.pl";
		    last GETFILE;
		}
	    }
d69 1
a69 1
                $file = "unicore/lib/gc_sc/$base.pl";
d82 2
a83 2
            if (my $base = ($utf8::Canonical{$canonical} || $utf8::Canonical{ lc $utf8::PropertyAlias{$canonical} })) {
                $file = "unicore/lib/gc_sc/$base.pl";
d88 16
a110 1

d206 1
a206 1
	    if ($char =~ /[-+!&]/) {
d210 1
a210 4
		    $subobj = utf8->SWASHNEW($t, "", 0, 0, 0);
		}
		elsif (exists &$name) {
		    $subobj = utf8->SWASHNEW($name, "", 0, 0, 0);
d318 1
a318 1
	while ($x =~ /^([-+!&])(.*)/mg) {
a353 12
			    vec($swatch, $key, $bits) = 0;
			}
		    }
		}
	    }
	    elsif ($char eq '&') {
		if ($bits == 1 and $otherbits == 1) {
		    $swatch &= $other;
		}
		else {
		    for ($key = 0; $key < $len; $key++) {
			if (!vec($other, $key, $otherbits)) {
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d28 1
a28 7
    ## Called from swash_init (see utf8.c) or SWASHNEW itself.
    ##
    ## Callers of swash_init:
    ##     op.c:pmtrans             -- for tr/// and y///
    ##     regexec.c:regclass_swash -- for /[]/, \p, and \P
    ##     utf8.c:is_utf8_common    -- for common Unicode properties
    ##     utf8.c:to_utf8_case      -- for lc, uc, ucfirst, etc. and //i
d31 1
a31 12
    ## ranges. If $type is false, $list passed is used.
    ##
    ## $minbits:
    ##     For binary properties, $minbits must be 1.
    ##     For character mappings (case and transliteration), $minbits must
    ##     be a number except 1.
    ##
    ## $list (or that filled according to $type):
    ##     Refer to perlunicode.pod, "User-Defined Character Properties."
    ##     
    ##     For binary properties, only characters with the property value
    ##     of True should be listed. The 3rd column, if any, will be ignored.
d46 1
a46 1
        print STDERR "type = $type\n" if DEBUG;
d120 1
a120 1
            print STDERR "canonical = $canonical\n" if DEBUG;
d151 2
a152 1
            if ($type =~ /^To(Digit|Fold|Lower|Title|Upper)$/) {
d167 1
a167 1
	    print STDERR "found it (file='$file')\n" if DEBUG;
d174 1
a174 1
	    ## class and file to load.
d176 4
a179 4
	    my $found = $Cache{$class, $file};
	    if ($found and ref($found) eq $class) {
		print STDERR "Returning cached '$file' for \\p{$type}\n" if DEBUG;
		return $found;
d182 1
a182 1
	    $list = do $file; die $@@ if $@@;
d189 1
a189 1
    my $bits = $minbits;
d200 1
a200 1
	    map  { /^([0-9a-fA-F]+)/; [ CORE::hex($1), $_ ] }
d209 1
a209 1
    if ($minbits != 1 && $minbits < 32) { # not binary property
d212 3
a214 3
	    my $min = CORE::hex $1;
	    my $max = defined $2 ? CORE::hex $2 : $min;
	    my $val = defined $3 ? CORE::hex $3 : 0;
d218 1
a218 1
	my $topbits =
d220 2
a221 2
	    $top > 0xff ? 16 : 8;
	$bits = $topbits if $bits < $topbits;
d223 1
d236 1
a236 1
		    $subobj = utf8->SWASHNEW($t, "", $minbits, 0);
d239 1
a239 1
		    $subobj = utf8->SWASHNEW($name, "", $minbits, 0);
d242 1
a242 1
		    $subobj = utf8->SWASHNEW("", $c, $minbits, 0);
d269 142
a410 1
# Now SWASHGET is recasted into a C function S_swash_get (see utf8.c).
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d11 2
d20 42
a61 49
{
    # If a floating point number is within this distance from the value of a
    # fraction, it is considered to be that fraction, even if many more digits
    # are specified that don't exactly match.
    my $min_floating_slop;

    sub SWASHNEW {
        my ($class, $type, $list, $minbits, $none) = @@_;
        local $^D = 0 if $^D;

        print STDERR __LINE__, ": ", join(", ", @@_), "\n" if DEBUG;

        ##
        ## Get the list of codepoints for the type.
        ## Called from swash_init (see utf8.c) or SWASHNEW itself.
        ##
        ## Callers of swash_init:
        ##     op.c:pmtrans             -- for tr/// and y///
        ##     regexec.c:regclass_swash -- for /[]/, \p, and \P
        ##     utf8.c:is_utf8_common    -- for common Unicode properties
        ##     utf8.c:to_utf8_case      -- for lc, uc, ucfirst, etc. and //i
        ##
        ## Given a $type, our goal is to fill $list with the set of codepoint
        ## ranges. If $type is false, $list passed is used.
        ##
        ## $minbits:
        ##     For binary properties, $minbits must be 1.
        ##     For character mappings (case and transliteration), $minbits must
        ##     be a number except 1.
        ##
        ## $list (or that filled according to $type):
        ##     Refer to perlunicode.pod, "User-Defined Character Properties."
        ##     
        ##     For binary properties, only characters with the property value
        ##     of True should be listed. The 3rd column, if any, will be ignored
        ##
        ## $none is undocumented, so I'm (khw) trying to do some documentation
        ## of it now.  It appears to be if there is a mapping in an input file
        ## that maps to 'XXXX', then that is replaced by $none+1, expressed in
        ## hexadecimal.  The only place I found it possibly used was in
        ## S_pmtrans in op.c.
        ##
        ## To make the parsing of $type clear, this code takes the a rather
        ## unorthodox approach of last'ing out of the block once we have the
        ## info we need. Were this to be a subroutine, the 'last' would just
        ## be a 'return'.
        ##
        my $file; ## file to load data from, and also part of the %Cache key.
        my $ListSorted = 0;
d63 1
a63 2
        # Change this to get a different set of Unicode tables
        my $unicore_dir = 'unicore';
d65 1
a65 1
        if ($type)
d67 77
a143 2
            $type =~ s/^\s+//;
            $type =~ s/\s+$//;
d145 28
a172 1
            print STDERR __LINE__, ": type = $type\n" if DEBUG;
d174 4
a177 270
        GETFILE:
            {
                ##
                ## It could be a user-defined property.
                ##

                my $caller1 = $type =~ s/(.+)::// ? $1 : caller(1);

                if (defined $caller1 && $type =~ /^(?:\w+)$/) {
                    my $prop = "${caller1}::$type";
                    if (exists &{$prop}) {
                        no strict 'refs';
                        
                        $list = &{$prop};
                        last GETFILE;
                    }
                }

                require "$unicore_dir/Heavy.pl";

                # Everything is caseless matching
                my $property_and_table = lc $type;
                print STDERR __LINE__, ": $property_and_table\n" if DEBUG;

                # See if is of the compound form 'property=value', where the
                # value indicates the table we should use.
                my ($property, $table, @@remainder) =
                                    split /\s*[:=]\s*/, $property_and_table, -1;
                return $type if @@remainder;

                my $prefix;
                if (! defined $table) {
                        
                    # Here, is the single form.  The property becomes empty, and
                    # the whole value is the table.
                    $table = $property;
                    $prefix = $property = "";
                } else {
                    print STDERR __LINE__, ": $property\n" if DEBUG;

                    # Here it is the compound property=table form.  The property
                    # name is always loosely matched, which means remove any of
                    # these:
                    $property =~ s/[_\s-]//g;

                    # And convert to canonical form.  Quit if not valid.
                    $property = $utf8::loose_property_name_of{$property};
                    return $type unless defined $property;

                    $prefix = "$property=";

                    # If the rhs looks like it is a number...
                    print STDERR __LINE__, ": table=$table\n" if DEBUG;
                    if ($table =~ qr{ ^ [ \s 0-9 _  + / . -]+ $ }x) {
                        print STDERR __LINE__, ": table=$table\n" if DEBUG;

                        # Don't allow leading nor trailing slashes 
                        return $type if $table =~ / ^ \/ | \/ $ /x;

                        # Split on slash, in case it is a rational, like \p{1/5}
                        my @@parts = split qr{ \s* / \s* }x, $table, -1;
                        print __LINE__, ": $type\n" if @@parts > 2 && DEBUG;

                        # Can have maximum of one slash
                        return $type if @@parts > 2;

                        foreach my $part (@@parts) {
                            print __LINE__, ": part=$part\n" if DEBUG;

                            $part =~ s/^\+\s*//;    # Remove leading plus
                            $part =~ s/^-\s*/-/;    # Remove blanks after unary
                                                    # minus

                            # Remove underscores between digits.
                            $part =~ s/( ?<= [0-9] ) _ (?= [0-9] ) //xg;

                            # No leading zeros (but don't make a single '0'
                            # into a null string)
                            $part =~ s/ ^ ( -? ) 0+ /$1/x;
                            $part .= '0' if $part eq '-' || $part eq "";

                            # No trailing zeros after a decimal point
                            $part =~ s/ ( \. .*? ) 0+ $ /$1/x;

                            # Begin with a 0 if a leading decimal point
                            $part =~ s/ ^ ( -? ) \. /${1}0./x;

                            # Ensure not a trailing decimal point: turn into an
                            # integer
                            $part =~ s/ \. $ //x;

                            print STDERR __LINE__, ": part=$part\n" if DEBUG;
                            #return $type if $part eq "";
                            
                            # Result better look like a number.  (This test is
                            # needed because, for example could have a plus in
                            # the middle.)
                            return $type if $part
                                            !~ / ^ -? [0-9]+ ( \. [0-9]+)? $ /x;
                        }

                        #  If a rational...
                        if (@@parts == 2) {

                            # If denominator is negative, get rid of it, and ...
                            if ($parts[1] =~ s/^-//) {

                                # If numerator is also negative, convert the
                                # whole thing to positive, or move the minus to
                                # the numerator
                                if ($parts[0] !~ s/^-//) {
                                    $parts[0] = '-' . $parts[0];
                                }
                            }
                            $table = join '/', @@parts;
                        }
                        elsif ($property ne 'nv' || $parts[0] !~ /\./) {

                            # Here is not numeric value, or doesn't have a
                            # decimal point.  No further manipulation is
                            # necessary.  (Note the hard-coded property name.
                            # This could fail if other properties eventually
                            # had fractions as well; perhaps the cjk ones
                            # could evolve to do that.  This hard-coding could
                            # be fixed by mktables generating a list of
                            # properties that could have fractions.)
                            $table = $parts[0];
                        } else {

                            # Here is a floating point numeric_value.  Try to
                            # convert to rational.  First see if is in the list
                            # of known ones.
                            if (exists $utf8::nv_floating_to_rational{$parts[0]}) {
                                $table = $utf8::nv_floating_to_rational{$parts[0]};
                            } else {

                                # Here not in the list.  See if is close
                                # enough to something in the list.  First
                                # determine what 'close enough' means.  It has
                                # to be as tight as what mktables says is the
                                # maximum slop, and as tight as how many
                                # digits we were passed.  That is, if the user
                                # said .667, .6667, .66667, etc.  we match as
                                # many digits as they passed until get to
                                # where it doesn't matter any more due to the
                                # machine's precision.  If they said .6666668,
                                # we fail.
                                (my $fraction = $parts[0]) =~ s/^.*\.//;
                                my $epsilon = 10 ** - (length($fraction));
                                if ($epsilon > $utf8::max_floating_slop) {
                                    $epsilon = $utf8::max_floating_slop;
                                }

                                # But it can't be tighter than the minimum
                                # precision for this machine.  If haven't
                                # already calculated that minimum, do so now.
                                if (! defined $min_floating_slop) {

                                    # Keep going down an order of magnitude
                                    # until find that adding this quantity to
                                    # 1 remains 1; but put an upper limit on
                                    # this so in case this algorithm doesn't
                                    # work properly on some platform, that we
                                    # won't loop forever.
                                    my $count = 0;
                                    $min_floating_slop = 1;
                                    while (1+ $min_floating_slop != 1
                                           && $count++ < 50)
                                    {
                                        my $next = $min_floating_slop / 10;
                                        last if $next == 0; # If underflows,
                                                            # use previous one
                                        $min_floating_slop = $next;
                                        print STDERR __LINE__, ": min_float_slop=$min_floating_slop\n" if DEBUG;
                                    }

                                    # Back off a couple orders of magnitude,
                                    # just to be safe.
                                    $min_floating_slop *= 100;
                                }
                                    
                                if ($epsilon < $min_floating_slop) {
                                    $epsilon = $min_floating_slop;
                                }
                                print STDERR __LINE__, ": fraction=.$fraction; epsilon=$epsilon\n" if DEBUG;

                                undef $table;

                                # And for each possible rational in the table,
                                # see if it is within epsilon of the input.
                                foreach my $official
                                        (keys %utf8::nv_floating_to_rational)
                                {
                                    print STDERR __LINE__, ": epsilon=$epsilon, official=$official, diff=", abs($parts[0] - $official), "\n" if DEBUG;
                                    if (abs($parts[0] - $official) < $epsilon) {
                                      $table =
                                      $utf8::nv_floating_to_rational{$official};
                                        last;
                                    }
                                }

                                # Quit if didn't find one.
                                return $type unless defined $table;
                            }
                        }
                        print STDERR __LINE__, ": $property=$table\n" if DEBUG;
                    }
                }

                # Combine lhs (if any) and rhs to get something that matches
                # the syntax of the lookups.
                $property_and_table = "$prefix$table";
                print STDERR __LINE__, ": $property_and_table\n" if DEBUG;

                # First try stricter matching.
                $file = $utf8::stricter_to_file_of{$property_and_table};

                # If didn't find it, try again with looser matching by editing
                # out the applicable characters on the rhs and looking up
                # again.
                if (! defined $file) {
                    $table =~ s/ [_\s-] //xg;
                    $property_and_table = "$prefix$table";
                    print STDERR __LINE__, ": $property_and_table\n" if DEBUG;
                    $file = $utf8::loose_to_file_of{$property_and_table};
                }

                # Add the constant and go fetch it in.
                if (defined $file) {
                    if ($utf8::why_deprecated{$file}) {
                        warnings::warnif('deprecated', "Use of '$type' in \\p{} or \\P{} is deprecated because: $utf8::why_deprecated{$file};");
                    }
                    $file= "$unicore_dir/lib/$file.pl";
                    last GETFILE;
                }
                print STDERR __LINE__, ": didn't find $property_and_table\n" if DEBUG;

                ##
                ## See if it's a user-level "To".
                ##

                my $caller0 = caller(0);

                if (defined $caller0 && $type =~ /^To(?:\w+)$/) {
                    my $map = $caller0 . "::" . $type;

                    if (exists &{$map}) {
                        no strict 'refs';
                        
                        $list = &{$map};
                        last GETFILE;
                    }
                }

                ##
                ## Last attempt -- see if it's a standard "To" name
                ## (e.g. "ToLower")  ToTitle is used by ucfirst().
                ## The user-level way to access ToDigit() and ToFold()
                ## is to use Unicode::UCD.
                ##
                if ($type =~ /^To(Digit|Fold|Lower|Title|Upper)$/) {
                    $file = "$unicore_dir/To/$1.pl";
                    ## would like to test to see if $file actually exists....
                    last GETFILE;
                }

                ##
                ## If we reach this line, it's because we couldn't figure
                ## out what to do with $type. Ouch.
                ##
d179 2
a180 2
                return $type;
            }
d182 2
a183 2
            if (defined $file) {
                print STDERR __LINE__, ": found it (file='$file')\n" if DEBUG;
d185 12
a196 17
                ##
                ## If we reach here, it was due to a 'last GETFILE' above
                ## (exception: user-defined properties and mappings), so we
                ## have a filename, so now we load it if we haven't already.
                ## If we have, return the cached results. The cache key is the
                ## class and file to load.
                ##
                my $found = $Cache{$class, $file};
                if ($found and ref($found) eq $class) {
                    print STDERR __LINE__, ": Returning cached '$file' for \\p{$type}\n" if DEBUG;
                    return $found;
                }

                local $@@;
                local $!;
                $list = do $file; die $@@ if $@@;
            }
d198 2
a199 2
            $ListSorted = 1; ## we know that these lists are sorted
        }
d201 2
a202 2
        my $extras;
        my $bits = $minbits;
d204 2
a205 12
        my $ORIG = $list;
        if ($list) {
            my @@tmp = split(/^/m, $list);
            my %seen;
            no warnings;
            $extras = join '', grep /^[^0-9a-fA-F]/, @@tmp;
            $list = join '',
                map  { $_->[1] }
                sort { $a->[0] <=> $b->[0] }
                map  { /^([0-9a-fA-F]+)/; [ CORE::hex($1), $_ ] }
                grep { /^([0-9a-fA-F]+)/ and not $seen{$1}++ } @@tmp; # XXX doesn't do ranges right
        }
d207 12
a218 4
        if ($none) {
            my $hextra = sprintf "%04x", $none + 1;
            $list =~ s/\tXXXX$/\t$hextra/mg;
        }
d220 4
a223 14
        if ($minbits != 1 && $minbits < 32) { # not binary property
            my $top = 0;
            while ($list =~ /^([0-9a-fA-F]+)(?:[\t]([0-9a-fA-F]+)?)(?:[ \t]([0-9a-fA-F]+))?/mg) {
                my $min = CORE::hex $1;
                my $max = defined $2 ? CORE::hex $2 : $min;
                my $val = defined $3 ? CORE::hex $3 : 0;
                $val += $max - $min if defined $3;
                $top = $val if $val > $top;
            }
            my $topbits =
                $top > 0xffff ? 32 :
                $top > 0xff ? 16 : 8;
            $bits = $topbits if $bits < $topbits;
        }
d225 14
a238 27
        my @@extras;
        if ($extras) {
            for my $x ($extras) {
                pos $x = 0;
                while ($x =~ /^([^0-9a-fA-F\n])(.*)/mg) {
                    my $char = $1;
                    my $name = $2;
                    print STDERR __LINE__, ": $1 => $2\n" if DEBUG;
                    if ($char =~ /[-+!&]/) {
                        my ($c,$t) = split(/::/, $name, 2);	# bogus use of ::, really
                        my $subobj;
                        if ($c eq 'utf8') {
                            $subobj = utf8->SWASHNEW($t, "", $minbits, 0);
                        }
                        elsif (exists &$name) {
                            $subobj = utf8->SWASHNEW($name, "", $minbits, 0);
                        }
                        elsif ($c =~ /^([0-9a-fA-F]+)/) {
                            $subobj = utf8->SWASHNEW("", $c, $minbits, 0);
                        }
                        return $subobj unless ref $subobj;
                        push @@extras, $name => $subobj;
                        $bits = $subobj->{BITS} if $bits < $subobj->{BITS};
                    }
                }
            }
        }
d240 25
a264 6
        if (DEBUG) {
            print STDERR __LINE__, ": CLASS = $class, TYPE => $type, BITS => $bits, NONE => $none";
            print STDERR "\nLIST =>\n$list" if defined $list;
            print STDERR "\nEXTRAS =>\n$extras" if defined $extras;
            print STDERR "\n";
        }
d266 1
a266 8
        my $SWASH = bless {
            TYPE => $type,
            BITS => $bits,
            EXTRAS => $extras,
            LIST => $list,
            NONE => $none,
            @@extras,
        } => $class;
d268 8
a275 3
        if ($file) {
            $Cache{$class, $file} = $SWASH;
        }
d277 2
a278 1
        return $SWASH;
d280 2
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a5 1
$|=1 if DEBUG;
a12 14
sub _loose_name ($) {
    # Given a lowercase property or property-value name, return its
    # standardized version that is expected for look-up in the 'loose' hashes
    # in Heavy.pl (hence, this depends on what mktables does).  This squeezes
    # out blanks, underscores and dashes.  The complication stems from the
    # grandfathered-in 'L_', which retains a single trailing underscore.

    my $loose = $_[0] =~ s/[-\s_]//rg;

    return $loose if $loose !~ / ^ (?: is | to )? l $/x;
    return 'l_' if $_[0] =~ / l .* _ /x;    # If original had a trailing '_'
    return $loose;
}

a23 6
    # To guard against this program calling something that in turn ends up
    # calling this program with the same inputs, and hence infinitely
    # recursing, we keep a stack of the properties that are currently in
    # progress, pushed upon entry, popped upon return.
    my @@recursed;

a25 1
        my $user_defined = 0;
d28 1
a28 4
        $class = "" unless defined $class;
        print STDERR __LINE__, ": class=$class, type=$type, list=",
                                (defined $list) ? $list : ':undef:',
                                ", minbits=$minbits, none=$none\n" if DEBUG;
a38 2
        ##     Unicode::UCD::prop_invlist
        ##     Unicode::UCD::prop_invmap
d57 2
a58 1
        ## hexadecimal.  It is used somehow in tr///.
a64 8
        #   If a problem is found $type is returned;
        #   Upon success, a new (or cached) blessed object is returned with
        #   keys TYPE, BITS, EXTRAS, LIST, and NONE with values having the
        #   same meanings as the input parameters.
        #   SPECIALS contains a reference to any special-treatment hash in the
        #   INVERT_IT is non-zero if the result should be inverted before use
        #   USER_DEFINED is non-zero if the result came from a user-defined
        #       property.
d66 1
a69 4
        my $invert_it = 0;
        my $list_is_from_mktables = 0;  # Is $list returned from a mktables
                                        # generated file?  If so, we know it's
                                        # well behaved.
a72 8
            # Verify that this isn't a recursive call for this property.
            # Can't use croak, as it may try to recurse to here itself.
            my $class_type = $class . "::$type";
            if (grep { $_ eq $class_type } @@recursed) {
                CORE::die "panic: Infinite recursion in SWASHNEW for '$type'\n";
            }
            push @@recursed, $class_type;

d76 1
a76 5
            # regcomp.c surrounds the property name with '__" and '_i' if this
            # is to be caseless matching.
            my $caseless = $type =~ s/^(.*)__(.*)_i$/$1$2/;

            print STDERR __LINE__, ": type=$type, caseless=$caseless\n" if DEBUG;
d81 1
a81 2
                ## It could be a user-defined property.  Look in current
                ## package if no package given
d84 1
d86 1
a86 5
                my $caller0 = caller(0);
                my $caller1 = $type =~ s/(.+)::// ? $1 : $caller0 eq 'main' ?
                'main' : caller(1);

                if (defined $caller1 && $type =~ /^I[ns]\w+$/) {
a88 11
                        # stolen from Scalar::Util::PP::tainted()
                        my $tainted;
                        {
                            local($@@, $SIG{__DIE__}, $SIG{__WARN__});
                            local $^W = 0;
                            no warnings;
                            eval { kill 0 * $prop };
                            $tainted = 1 if $@@ =~ /^Insecure/;
                        }
                        die "Insecure user-defined property \\p{$prop}\n"
                            if $tainted;
d90 2
a91 2
                        $list = &{$prop}($caseless);
                        $user_defined = 1;
d96 1
a96 19
                # During Perl's compilation, this routine may be called before
                # the tables are constructed.  If so, we have a chicken/egg
                # problem.  If we die, the tables never get constructed, so
                # keep going, but return an empty table so only what the code
                # has compiled in internally (currently ASCII/Latin1 range
                # matching) will work.
                BEGIN {
                    # Poor man's constant, to avoid a run-time check.
                    $utf8::{miniperl}
                        = \! defined &DynaLoader::boot_DynaLoader;
                }
                if (miniperl) {
                    eval "require '$unicore_dir/Heavy.pl'";
                    last GETFILE if $@@;
                }
                else {
                    require "$unicore_dir/Heavy.pl";
                }
                BEGIN { delete $utf8::{miniperl} }
d98 2
a99 2
                # All property names are matched caselessly
                my $property_and_table = CORE::lc $type;
d106 1
a106 4
                if (@@remainder) {
                    pop @@recursed if @@recursed;
                    return $type;
                }
d119 3
a121 4
                    # name is always loosely matched, and always can have an
                    # optional 'is' prefix (which isn't true in the single
                    # form).
                    $property = _loose_name($property) =~ s/^is//r;
d125 1
a125 4
                    if (! defined $property) {
                        pop @@recursed if @@recursed;
                        return $type;
                    }
d135 1
a135 4
                        if ($table =~ / ^ \/ | \/ $ /x) {
                            pop @@recursed if @@recursed;
                            return $type;
                        }
d142 1
a142 4
                        if (@@parts > 2) {
                            pop @@recursed if @@recursed;
                            return $type;
                        }
d175 2
a176 4
                            if ($part !~ / ^ -? [0-9]+ ( \. [0-9]+)? $ /x) {
                                pop @@recursed if @@recursed;
                                return $type;
                            }
d280 1
a280 4
                                if (! defined $table) {
                                    pop @@recursed if @@recursed;
                                    return $type;
                                }
d299 1
a299 1
                    $table = _loose_name($table);
a306 5

                    # A beginning ! means to invert.  The 0+ makes sure is
                    # numeric
                    $invert_it = 0 + $file =~ s/^!//;

a309 6

                    if ($caseless
                        && exists $utf8::caseless_equivalent{$property_and_table})
                    {
                        $file = $utf8::caseless_equivalent{$property_and_table};
                    }
d316 17
d338 5
a342 56
                # Only check if caller wants non-binary
                my $retried = 0;
                if ($minbits != 1 && $property_and_table =~ s/^to//) {{
                    # Look input up in list of properties for which we have
                    # mapping files.
                    if (defined ($file =
                          $utf8::loose_property_to_file_of{$property_and_table}))
                    {
                        $type = $utf8::file_to_swash_name{$file};
                        print STDERR __LINE__, ": type set to $type\n" if DEBUG;
                        $file = "$unicore_dir/$file.pl";
                        last GETFILE;
                    }   # If that fails see if there is a corresponding binary
                        # property file
                    elsif (defined ($file =
                                   $utf8::loose_to_file_of{$property_and_table}))
                    {

                        # Here, there is no map file for the property we are
                        # trying to get the map of, but this is a binary
                        # property, and there is a file for it that can easily
                        # be translated to a mapping.

                        # In the case of properties that are forced to binary,
                        # they are a combination.  We return the actual
                        # mapping instead of the binary.  If the input is
                        # something like 'Tocjkkiicore', it will be found in
                        # %loose_property_to_file_of above as => 'To/kIICore'.
                        # But the form like ToIskiicore won't be.  To fix
                        # this, it was easiest to do it here.  These
                        # properties are the complements of the default
                        # property, so there is an entry in %loose_to_file_of
                        # that is 'iskiicore' => '!kIICore/N', If we find such
                        # an entry, strip off things and try again, which
                        # should find the entry in %loose_property_to_file_of.
                        # Actual binary properties that are of this form, such
                        # as this entry: 'ishrkt' => '!Perl/Any' will also be
                        # retried, but won't be in %loose_property_to_file_of,
                        # and instead the next time through, it will find
                        # 'hrkt' => '!Perl/Any' and proceed.
                        redo if ! $retried
                                && $file =~ /^!/
                                && $property_and_table =~ s/^is//;

                        # This is a binary property.  Setting this here causes
                        # it to be stored as such in the cache, so if someone
                        # comes along later looking for just a binary, they
                        # get it.
                        $minbits = 1;

                        # The 0+ makes sure is numeric
                        $invert_it = 0 + $file =~ s/^!//;
                        $file = "$unicore_dir/lib/$file.pl";
                        last GETFILE;
                    }
                } }
a348 1
                pop @@recursed if @@recursed;
d350 1
a350 1
            } # end of GETFILE block
d360 1
a360 2
                ## class and file to load, and whether the results need to be
                ## inverted.
d362 1
a362 1
                my $found = $Cache{$class, $file, $invert_it};
d364 1
a364 2
                    print STDERR __LINE__, ": Returning cached swash for '$class,$file,$invert_it' for \\p{$type}\n" if DEBUG;
                    pop @@recursed if @@recursed;
a370 1
                $list_is_from_mktables = 1;
a371 1
        } # End of $type is non-null
d373 2
a374 4
        # Here, either $type was null, or we found the requested property and
        # read it into $list

        my $extras = "";
d376 1
d379 11
a389 42
        # mktables lists don't have extras, like '&utf8::prop', so don't need
        # to separate them; also lists are already sorted, so don't need to do
        # that.
        if ($list && ! $list_is_from_mktables) {
            my $taint = substr($list,0,0); # maintain taint

            # Separate the extras from the code point list, and make sure
            # user-defined properties and tr/// are well-behaved for
            # downstream code.
            if ($user_defined || $none) {
                my @@tmp = split(/^/m, $list);
                my %seen;
                no warnings;

                # The extras are anything that doesn't begin with a hex digit.
                $extras = join '', $taint, grep /^[^0-9a-fA-F]/, @@tmp;

                # Remove the extras, and sort the remaining entries by the
                # numeric value of their beginning hex digits, removing any
                # duplicates.
                $list = join '', $taint,
                        map  { $_->[1] }
                        sort { $a->[0] <=> $b->[0] }
                        map  { /^([0-9a-fA-F]+)/; [ CORE::hex($1), $_ ] }
                        grep { /^([0-9a-fA-F]+)/ and not $seen{$1}++ } @@tmp; # XXX doesn't do ranges right
            }
            else {
                # mktables has gone to some trouble to make non-user defined
                # properties well-behaved, so we can skip the effort we do for
                # user-defined ones.  Any extras are at the very beginning of
                # the string.

                # This regex splits out the first lines of $list into $1 and
                # strips them off from $list, until we get one that begins
                # with a hex number, alone on the line, or followed by a tab.
                # Either portion may be empty.
                $list =~ s/ \A ( .*? )
                            (?: \z | (?= ^ [0-9a-fA-F]+ (?: \t | $) ) )
                          //msx;

                $extras = "$taint$1";
            }
a414 1
                my $taint = substr($x,0,0); # maintain taint
d417 3
a419 4
                    my $char = "$1$taint";
                    my $name = "$2$taint";
                    print STDERR __LINE__, ": char [$char] => name [$name]\n"
                        if DEBUG;
d432 1
a432 5
                        print STDERR __LINE__, ": returned from getting sub object for $name\n" if DEBUG;
                        if (! ref $subobj) {
                            pop @@recursed if @@recursed && $type;
                            return $subobj;
                        }
a434 2
                        $user_defined = $subobj->{USER_DEFINED}
                                              if $subobj->{USER_DEFINED};
d441 1
a441 1
            print STDERR __LINE__, ": CLASS = $class, TYPE => $type, BITS => $bits, NONE => $none, INVERT_IT => $invert_it, USER_DEFINED => $user_defined";
a452 1
            USER_DEFINED => $user_defined,
d457 1
a457 11
            $Cache{$class, $file, $invert_it} = $SWASH;
            if ($type
                && exists $utf8::SwashInfo{$type}
                && exists $utf8::SwashInfo{$type}{'specials_name'})
            {
                my $specials_name = $utf8::SwashInfo{$type}{'specials_name'};
                no strict "refs";
                print STDERR "\nspecials_name => $specials_name\n" if DEBUG;
                $SWASH->{'SPECIALS'} = \%$specials_name;
            }
            $SWASH->{'INVERT_IT'} = $invert_it;
a459 2
        pop @@recursed if @@recursed && $type;

d464 1
a464 1
# Now SWASHGET is recasted into a C function S_swatch_get (see utf8.c).
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a3 2
use re "/aa";  # So we won't even try to look at above Latin1, potentially
               # resulting in a recursive call
d247 1
a247 1
                            $part =~ s/(?<= [0-9] ) _ (?= [0-9] ) //xg;
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d410 3
a412 3
                    # If the file name contains a !, it means to invert.  The
                    # 0+ makes sure result is numeric
                    $invert_it = 0 + $file =~ s/!//;
d423 1
a423 5

                    # The pseudo-directory '#' means that there really isn't a
                    # file to read, the data is in-line as part of the string;
                    # we extract it below.
                    $file = "$unicore_dir/lib/$file.pl" unless $file =~ m!^#/!;
d485 2
a486 2
                        $invert_it = 0 + $file =~ s/!//;
                        $file = "$unicore_dir/lib/$file.pl" unless $file =~ m!^#/!;
d507 9
a515 23

                # The pseudo-directory '#' means the result isn't really a
                # file, but is in-line, with semi-colons to be turned into
                # new-lines.  Since it is in-line there is no advantage to
                # caching the result
                if ($file =~ s!^#/!!) {
                    $list = $utf8::inline_definitions[$file];
                }
                else {
                    # Here, we have an actual file to read in and load, but it
                    # may already have been read-in and cached.  The cache key
                    # is the class and file to load, and whether the results
                    # need to be inverted.
                    my $found = $Cache{$class, $file, $invert_it};
                    if ($found and ref($found) eq $class) {
                        print STDERR __LINE__, ": Returning cached swash for '$class,$file,$invert_it' for \\p{$type}\n" if DEBUG;
                        pop @@recursed if @@recursed;
                        return $found;
                    }

                    local $@@;
                    local $!;
                    $list = do $file; die $@@ if $@@;
d518 3
@


