head	1.12;
access;
symbols
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2013.03.25.20.40.56;	author sthen;	state dead;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.42;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.14;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.41;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.00;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.00;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.50;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.50;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.18;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.49;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.37;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.09;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.58;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.42;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.57;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.48.41;	author millert;	state Exp;
branches;
next	;


desc
@@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@=head1 NAME

Term::ReadLine - Perl interface to various C<readline> packages.
If no real package is found, substitutes stubs instead of basic functions.

=head1 SYNOPSIS

  use Term::ReadLine;
  my $term = Term::ReadLine->new('Simple Perl calc');
  my $prompt = "Enter your arithmetic expression: ";
  my $OUT = $term->OUT || \*STDOUT;
  while ( defined ($_ = $term->readline($prompt)) ) {
    my $res = eval($_);
    warn $@@ if $@@;
    print $OUT $res, "\n" unless $@@;
    $term->addhistory($_) if /\S/;
  }

=head1 DESCRIPTION

This package is just a front end to some other packages. It's a stub to
set up a common interface to the various ReadLine implementations found on
CPAN (under the C<Term::ReadLine::*> namespace).

=head1 Minimal set of supported functions

All the supported functions should be called as methods, i.e., either as 

  $term = Term::ReadLine->new('name');

or as 

  $term->addhistory('row');

where $term is a return value of Term::ReadLine-E<gt>new().

=over 12

=item C<ReadLine>

returns the actual package that executes the commands. Among possible
values are C<Term::ReadLine::Gnu>, C<Term::ReadLine::Perl>,
C<Term::ReadLine::Stub>.

=item C<new>

returns the handle for subsequent calls to following
functions. Argument is the name of the application. Optionally can be
followed by two arguments for C<IN> and C<OUT> filehandles. These
arguments should be globs.

=item C<readline>

gets an input line, I<possibly> with actual C<readline>
support. Trailing newline is removed. Returns C<undef> on C<EOF>.

=item C<addhistory>

adds the line to the history of input, from where it can be used if
the actual C<readline> is present.

=item C<IN>, C<OUT>

return the filehandles for input and output or C<undef> if C<readline>
input and output cannot be used for Perl.

=item C<MinLine>

If argument is specified, it is an advice on minimal size of line to
be included into history.  C<undef> means do not include anything into
history. Returns the old value.

=item C<findConsole>

returns an array with two strings that give most appropriate names for
files for input and output using conventions C<"E<lt>$in">, C<"E<gt>out">.

=item Attribs

returns a reference to a hash which describes internal configuration
of the package. Names of keys in this hash conform to standard
conventions with the leading C<rl_> stripped.

=item C<Features>

Returns a reference to a hash with keys being features present in
current implementation. Several optional features are used in the
minimal interface: C<appname> should be present if the first argument
to C<new> is recognized, and C<minline> should be present if
C<MinLine> method is not dummy.  C<autohistory> should be present if
lines are put into history automatically (maybe subject to
C<MinLine>), and C<addhistory> if C<addhistory> method is not dummy.

If C<Features> method reports a feature C<attribs> as present, the
method C<Attribs> is not dummy.

=back

=head1 Additional supported functions

Actually C<Term::ReadLine> can use some other package, that will
support a richer set of commands.

All these commands are callable via method interface and have names
which conform to standard conventions with the leading C<rl_> stripped.

The stub package included with the perl distribution allows some
additional methods: 

=over 12

=item C<tkRunning>

makes Tk event loop run when waiting for user input (i.e., during
C<readline> method).

=item C<ornaments>

makes the command line stand out by using termcap data.  The argument
to C<ornaments> should be 0, 1, or a string of a form
C<"aa,bb,cc,dd">.  Four components of this string should be names of
I<terminal capacities>, first two will be issued to make the prompt
standout, last two to make the input line standout.

=item C<newTTY>

takes two arguments which are input filehandle and output filehandle.
Switches to use these filehandles.

=back

One can check whether the currently loaded ReadLine package supports
these methods by checking for corresponding C<Features>.

=head1 EXPORTS

None

=head1 ENVIRONMENT

The environment variable C<PERL_RL> governs which ReadLine clone is
loaded. If the value is false, a dummy interface is used. If the value
is true, it should be tail of the name of the package to use, such as
C<Perl> or C<Gnu>.  

As a special case, if the value of this variable is space-separated,
the tail might be used to disable the ornaments by setting the tail to
be C<o=0> or C<ornaments=0>.  The head should be as described above, say

If the variable is not set, or if the head of space-separated list is
empty, the best available package is loaded.

  export "PERL_RL=Perl o=0"	# Use Perl ReadLine without ornaments
  export "PERL_RL= o=0"		# Use best available ReadLine without ornaments

(Note that processing of C<PERL_RL> for ornaments is in the discretion of the 
particular used C<Term::ReadLine::*> package).

=head1 CAVEATS

It seems that using Term::ReadLine from Emacs minibuffer doesn't work
quite right and one will get an error message like

    Cannot open /dev/tty for read at ...

One possible workaround for this is to explicitly open /dev/tty like this

    open (FH, "/dev/tty" )
      or eval 'sub Term::ReadLine::findConsole { ("&STDIN", "&STDERR") }';
    die $@@ if $@@;
    close (FH);

or you can try using the 4-argument form of Term::ReadLine->new().

=cut

use strict;

package Term::ReadLine::Stub;
our @@ISA = qw'Term::ReadLine::Tk Term::ReadLine::TermCap';

$DB::emacs = $DB::emacs;	# To peacify -w
our @@rl_term_set;
*rl_term_set = \@@Term::ReadLine::TermCap::rl_term_set;

sub PERL_UNICODE_STDIN () { 0x0001 }

sub ReadLine {'Term::ReadLine::Stub'}
sub readline {
  my $self = shift;
  my ($in,$out,$str) = @@$self;
  my $prompt = shift;
  print $out $rl_term_set[0], $prompt, $rl_term_set[1], $rl_term_set[2]; 
  $self->register_Tk 
     if not $Term::ReadLine::registered and $Term::ReadLine::toloop
	and defined &Tk::DoOneEvent;
  #$str = scalar <$in>;
  $str = $self->get_line;
  $str =~ s/^\s*\Q$prompt\E// if ($^O eq 'MacOS');
  utf8::upgrade($str)
      if (${^UNICODE} & PERL_UNICODE_STDIN || defined ${^ENCODING}) &&
         utf8::valid($str);
  print $out $rl_term_set[3]; 
  # bug in 5.000: chomping empty string creats length -1:
  chomp $str if defined $str;
  $str;
}
sub addhistory {}

sub findConsole {
    my $console;
    my $consoleOUT;

    if ($^O eq 'MacOS') {
        $console = "Dev:Console";
    } elsif (-e "/dev/tty") {
	$console = "/dev/tty";
    } elsif (-e "con" or $^O eq 'MSWin32') {
       $console = 'CONIN$';
       $consoleOUT = 'CONOUT$';
    } else {
	$console = "sys\$command";
    }

    if (($^O eq 'amigaos') || ($^O eq 'beos') || ($^O eq 'epoc')) {
	$console = undef;
    }
    elsif ($^O eq 'os2') {
      if ($DB::emacs) {
	$console = undef;
      } else {
	$console = "/dev/con";
      }
    }

    $consoleOUT = $console unless defined $consoleOUT;
    $console = "&STDIN" unless defined $console;
    if (!defined $consoleOUT) {
      $consoleOUT = defined fileno(STDERR) && $^O ne 'MSWin32' ? "&STDERR" : "&STDOUT";
    }
    ($console,$consoleOUT);
}

sub new {
  die "method new called with wrong number of arguments" 
    unless @@_==2 or @@_==4;
  #local (*FIN, *FOUT);
  my ($FIN, $FOUT, $ret);
  if (@@_==2) {
    my($console, $consoleOUT) = $_[0]->findConsole;


    # the Windows CONIN$ needs GENERIC_WRITE mode to allow
    # a SetConsoleMode() if we end up using Term::ReadKey
    open FIN, (  $^O eq 'MSWin32' && $console eq 'CONIN$' ) ? "+<$console" :
                                                              "<$console";
    open FOUT,">$consoleOUT";

    #OUT->autoflush(1);		# Conflicts with debugger?
    my $sel = select(FOUT);
    $| = 1;				# for DB::OUT
    select($sel);
    $ret = bless [\*FIN, \*FOUT];
  } else {			# Filehandles supplied
    $FIN = $_[2]; $FOUT = $_[3];
    #OUT->autoflush(1);		# Conflicts with debugger?
    my $sel = select($FOUT);
    $| = 1;				# for DB::OUT
    select($sel);
    $ret = bless [$FIN, $FOUT];
  }
  if ($ret->Features->{ornaments} 
      and not ($ENV{PERL_RL} and $ENV{PERL_RL} =~ /\bo\w*=0/)) {
    local $Term::ReadLine::termcap_nowarn = 1;
    $ret->ornaments(1);
  }
  return $ret;
}

sub newTTY {
  my ($self, $in, $out) = @@_;
  $self->[0] = $in;
  $self->[1] = $out;
  my $sel = select($out);
  $| = 1;				# for DB::OUT
  select($sel);
}

sub IN { shift->[0] }
sub OUT { shift->[1] }
sub MinLine { undef }
sub Attribs { {} }

my %features = (tkRunning => 1, ornaments => 1, 'newTTY' => 1);
sub Features { \%features }

sub get_line {
  my $self = shift;
  my $in = $self->IN;
  local ($/) = "\n";
  return scalar <$in>;
}

package Term::ReadLine;		# So late to allow the above code be defined?

our $VERSION = '1.05';

my ($which) = exists $ENV{PERL_RL} ? split /\s+/, $ENV{PERL_RL} : undef;
if ($which) {
  if ($which =~ /\bgnu\b/i){
    eval "use Term::ReadLine::Gnu;";
  } elsif ($which =~ /\bperl\b/i) {
    eval "use Term::ReadLine::Perl;";
  } elsif ($which =~ /^(Stub|TermCap|Tk)$/) {
    # it is already in memory to avoid false exception as seen in:
    # PERL_RL=Stub perl -e'$SIG{__DIE__} = sub { print @@_ }; require Term::ReadLine'
  } else {
    eval "use Term::ReadLine::$which;";
  }
} elsif (defined $which and $which ne '') {	# Defined but false
  # Do nothing fancy
} else {
  eval "use Term::ReadLine::Gnu; 1" or eval "use Term::ReadLine::Perl; 1";
}

#require FileHandle;

# To make possible switch off RL in debugger: (Not needed, work done
# in debugger).
our @@ISA;
if (defined &Term::ReadLine::Gnu::readline) {
  @@ISA = qw(Term::ReadLine::Gnu Term::ReadLine::Stub);
} elsif (defined &Term::ReadLine::Perl::readline) {
  @@ISA = qw(Term::ReadLine::Perl Term::ReadLine::Stub);
} elsif (defined $which && defined &{"Term::ReadLine::$which\::readline"}) {
  @@ISA = "Term::ReadLine::$which";
} else {
  @@ISA = qw(Term::ReadLine::Stub);
}

package Term::ReadLine::TermCap;

# Prompt-start, prompt-end, command-line-start, command-line-end
#     -- zero-width beautifies to emit around prompt and the command line.
our @@rl_term_set = ("","","","");
# string encoded:
our $rl_term_set = ',,,';

our $terminal;
sub LoadTermCap {
  return if defined $terminal;
  
  require Term::Cap;
  $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
}

sub ornaments {
  shift;
  return $rl_term_set unless @@_;
  $rl_term_set = shift;
  $rl_term_set ||= ',,,';
  $rl_term_set = 'us,ue,md,me' if $rl_term_set eq '1';
  my @@ts = split /,/, $rl_term_set, 4;
  eval { LoadTermCap };
  unless (defined $terminal) {
    warn("Cannot find termcap: $@@\n") unless $Term::ReadLine::termcap_nowarn;
    $rl_term_set = ',,,';
    return;
  }
  @@rl_term_set = map {$_ ? $terminal->Tputs($_,1) || '' : ''} @@ts;
  return $rl_term_set;
}


package Term::ReadLine::Tk;

our($count_handle, $count_DoOne, $count_loop);
$count_handle = $count_DoOne = $count_loop = 0;

our($giveup);
sub handle {$giveup = 1; $count_handle++}

sub Tk_loop {
  # Tk->tkwait('variable',\$giveup);	# needs Widget
  $count_DoOne++, Tk::DoOneEvent(0) until $giveup;
  $count_loop++;
  $giveup = 0;
}

sub register_Tk {
  my $self = shift;
  $Term::ReadLine::registered++ 
    or Tk->fileevent($self->IN,'readable',\&handle);
}

sub tkRunning {
  $Term::ReadLine::toloop = $_[1] if @@_ > 1;
  $Term::ReadLine::toloop;
}

sub get_c {
  my $self = shift;
  $self->Tk_loop if $Term::ReadLine::toloop && defined &Tk::DoOneEvent;
  return getc $self->IN;
}

sub get_line {
  my $self = shift;
  $self->Tk_loop if $Term::ReadLine::toloop && defined &Tk::DoOneEvent;
  my $in = $self->IN;
  local ($/) = "\n";
  return scalar <$in>;
}

1;

@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.10
log
@Merge in perl 5.10.1
@
text
@d306 1
a306 1
our $VERSION = '1.04';
d314 3
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d9 1
a9 1
  my $term = new Term::ReadLine 'Simple Perl calc';
d29 1
a29 1
  $term = new Term::ReadLine 'name';
d306 1
a306 1
our $VERSION = '1.03';
@


1.8
log
@merge in perl 5.8.8
@
text
@d212 1
d219 2
a220 1
	$console = "con";
d236 1
a236 1
    my $consoleOUT = $console;
d239 1
a239 1
      $consoleOUT = defined fileno(STDERR) ? "&STDERR" : "&STDOUT";
d252 7
a258 2
    open(FIN, "<$console"); 
    open(FOUT,">$consoleOUT");
d297 7
d306 1
a306 1
our $VERSION = '1.02';
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d21 3
a23 4
This package is just a front end to some other packages. At the moment
this description is written, the only such package is Term-ReadLine,
available on CPAN near you. The real target of this stub package is to
set up a common interface to whatever Readline emerges with time.
d102 1
a102 1
support reacher set of commands.
d292 1
a292 1
our $VERSION = '1.01';
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a4 2
Term::ReadLine - Perl interface to various C<readline> packages. If
no real package is found, substitutes stubs instead of basic functions.
d13 1
a13 1
    my $res = eval($_), "\n";
d36 1
a36 1
where $term is a return value of Term::ReadLine-E<gt>Init.
d63 1
a63 1
=item C<IN>, $C<OUT>
d187 2
d201 3
d293 1
a293 1
our $VERSION = '1.00';
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d9 3
a11 3
  $term = new Term::ReadLine 'Simple Perl calc';
  $prompt = "Enter your arithmetic expression: ";
  $OUT = $term->OUT || STDOUT;
d13 1
a13 1
    $res = eval($_), "\n";
d44 1
a44 1
C<Term::ReadLine::Stub Exporter>.
d160 16
d178 2
d181 1
a181 1
@@ISA = qw'Term::ReadLine::Tk Term::ReadLine::TermCap';
d184 1
d230 1
a230 1
    $consoleOUT = $console;
d244 1
a244 1
    ($console, $consoleOUT) = findConsole;
d249 1
a249 1
    $sel = select(FOUT);
d256 1
a256 1
    $sel = select($FOUT);
d288 2
d309 1
a309 1

d314 2
d324 1
a324 1
@@rl_term_set = ("","","","");
d326 1
a326 1
$rl_term_set = ',,,';
d328 1
d356 1
d359 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d172 2
a173 1
  print $out $rl_term_set[0], shift, $rl_term_set[1], $rl_term_set[2]; 
d179 1
d190 3
a192 1
    if (-e "/dev/tty") {
@


1.3
log
@perl5.005_03 (stock)
@
text
@d196 1
a196 1
    if (($^O eq 'amigaos') || ($^O eq 'beos')) {
@


1.2
log
@perl 5.004_04
@
text
@d142 8
a149 4
The variable C<PERL_RL> governs which ReadLine clone is loaded. If the
value is false, a dummy interface is used. If the value is true, it
should be tail of the name of the package to use, such as C<Perl> or
C<Gnu>. 
d151 8
a158 1
If the variable is not set, the best available package is loaded.
d196 1
a196 1
    if ($^O eq 'amigaos') {
d219 1
a219 1
  my ($FIN, $FOUT);
d229 1
a229 1
    bless [\*FIN, \*FOUT];
d236 1
a236 1
    bless [$FIN, $FOUT];
d238 6
d265 1
a265 1
my $which = $ENV{PERL_RL};
d274 1
a274 1
} elsif (defined $which) {	# Defined but false
d313 1
a313 1
  $rl_term_set = 'us,ue,md,me' if $rl_term_set == 1;
d316 5
a320 1
  warn("Cannot find termcap: $@@\n"), return unless defined $terminal;
d360 1
@


1.1
log
@Initial revision
@
text
@d36 1
a36 1
where $term is a return value of Term::ReadLine->Init.
d77 7
a83 1
files for input and output using conventions C<"<$in">, C<"E<gt>out">.
d95 3
d100 2
d105 31
d140 9
d152 1
d155 1
d159 9
a167 3
  my ($in,$out,$str) = @@{shift()};
  print $out shift; 
  $str = scalar <$in>;
d179 1
a179 1
    } elsif (-e "con") {
d185 4
a188 1
    if (defined $ENV{'OS2_SHELL'}) { # In OS/2
d228 10
d241 4
a244 1
sub Features { {} }
d247 15
a261 1
eval "use Term::ReadLine::Gnu;" or eval "use Term::ReadLine::Perl;";
d276 65
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d36 1
a36 1
where $term is a return value of Term::ReadLine-E<gt>Init.
d77 1
a77 7
files for input and output using conventions C<"E<lt>$in">, C<"E<gt>out">.

=item Attribs

returns a reference to a hash which describes internal configuration
of the package. Names of keys in this hash conform to standard
conventions with the leading C<rl_> stripped.
a88 3
If C<Features> method reports a feature C<attribs> as present, the
method C<Attribs> is not dummy.

a90 2
=head1 Additional supported functions

a93 31
All these commands are callable via method interface and have names
which conform to standard conventions with the leading C<rl_> stripped.

The stub package included with the perl distribution allows some
additional methods: 

=over 12

=item C<tkRunning>

makes Tk event loop run when waiting for user input (i.e., during
C<readline> method).

=item C<ornaments>

makes the command line stand out by using termcap data.  The argument
to C<ornaments> should be 0, 1, or a string of a form
C<"aa,bb,cc,dd">.  Four components of this string should be names of
I<terminal capacities>, first two will be issued to make the prompt
standout, last two to make the input line standout.

=item C<newTTY>

takes two arguments which are input filehandle and output filehandle.
Switches to use these filehandles.

=back

One can check whether the currently loaded ReadLine package supports
these methods by checking for corresponding C<Features>.

a97 20
=head1 ENVIRONMENT

The environment variable C<PERL_RL> governs which ReadLine clone is
loaded. If the value is false, a dummy interface is used. If the value
is true, it should be tail of the name of the package to use, such as
C<Perl> or C<Gnu>.  

As a special case, if the value of this variable is space-separated,
the tail might be used to disable the ornaments by setting the tail to
be C<o=0> or C<ornaments=0>.  The head should be as described above, say

If the variable is not set, or if the head of space-separated list is
empty, the best available package is loaded.

  export "PERL_RL=Perl o=0"	# Use Perl ReadLine without ornaments
  export "PERL_RL= o=0"		# Use best available ReadLine without ornaments

(Note that processing of C<PERL_RL> for ornaments is in the discretion of the 
particular used C<Term::ReadLine::*> package).

a100 1
@@ISA = qw'Term::ReadLine::Tk Term::ReadLine::TermCap';
a102 1
*rl_term_set = \@@Term::ReadLine::TermCap::rl_term_set;
d106 3
a108 9
  my $self = shift;
  my ($in,$out,$str) = @@$self;
  print $out $rl_term_set[0], shift, $rl_term_set[1], $rl_term_set[2]; 
  $self->register_Tk 
     if not $Term::ReadLine::registered and $Term::ReadLine::toloop
	and defined &Tk::DoOneEvent;
  #$str = scalar <$in>;
  $str = $self->get_line;
  print $out $rl_term_set[3]; 
d120 1
a120 1
    } elsif (-e "con" or $^O eq 'MSWin32') {
d126 1
a126 4
    if (($^O eq 'amigaos') || ($^O eq 'beos')) {
	$console = undef;
    }
    elsif ($^O eq 'os2') {
d146 1
a146 1
  my ($FIN, $FOUT, $ret);
d156 1
a156 1
    $ret = bless [\*FIN, \*FOUT];
d163 1
a163 6
    $ret = bless [$FIN, $FOUT];
  }
  if ($ret->Features->{ornaments} 
      and not ($ENV{PERL_RL} and $ENV{PERL_RL} =~ /\bo\w*=0/)) {
    local $Term::ReadLine::termcap_nowarn = 1;
    $ret->ornaments(1);
a164 1
  return $ret;
a165 10

sub newTTY {
  my ($self, $in, $out) = @@_;
  $self->[0] = $in;
  $self->[1] = $out;
  my $sel = select($out);
  $| = 1;				# for DB::OUT
  select($sel);
}

d169 1
a169 4
sub Attribs { {} }

my %features = (tkRunning => 1, ornaments => 1, 'newTTY' => 1);
sub Features { \%features }
d172 1
a172 15

my ($which) = exists $ENV{PERL_RL} ? split /\s+/, $ENV{PERL_RL} : undef;
if ($which) {
  if ($which =~ /\bgnu\b/i){
    eval "use Term::ReadLine::Gnu;";
  } elsif ($which =~ /\bperl\b/i) {
    eval "use Term::ReadLine::Perl;";
  } else {
    eval "use Term::ReadLine::$which;";
  }
} elsif (defined $which and $which ne '') {	# Defined but false
  # Do nothing fancy
} else {
  eval "use Term::ReadLine::Gnu; 1" or eval "use Term::ReadLine::Perl; 1";
}
a186 70
package Term::ReadLine::TermCap;

# Prompt-start, prompt-end, command-line-start, command-line-end
#     -- zero-width beautifies to emit around prompt and the command line.
@@rl_term_set = ("","","","");
# string encoded:
$rl_term_set = ',,,';

sub LoadTermCap {
  return if defined $terminal;
  
  require Term::Cap;
  $terminal = Tgetent Term::Cap ({OSPEED => 9600}); # Avoid warning.
}

sub ornaments {
  shift;
  return $rl_term_set unless @@_;
  $rl_term_set = shift;
  $rl_term_set ||= ',,,';
  $rl_term_set = 'us,ue,md,me' if $rl_term_set eq '1';
  my @@ts = split /,/, $rl_term_set, 4;
  eval { LoadTermCap };
  unless (defined $terminal) {
    warn("Cannot find termcap: $@@\n") unless $Term::ReadLine::termcap_nowarn;
    $rl_term_set = ',,,';
    return;
  }
  @@rl_term_set = map {$_ ? $terminal->Tputs($_,1) || '' : ''} @@ts;
  return $rl_term_set;
}


package Term::ReadLine::Tk;

$count_handle = $count_DoOne = $count_loop = 0;

sub handle {$giveup = 1; $count_handle++}

sub Tk_loop {
  # Tk->tkwait('variable',\$giveup);	# needs Widget
  $count_DoOne++, Tk::DoOneEvent(0) until $giveup;
  $count_loop++;
  $giveup = 0;
}

sub register_Tk {
  my $self = shift;
  $Term::ReadLine::registered++ 
    or Tk->fileevent($self->IN,'readable',\&handle);
}

sub tkRunning {
  $Term::ReadLine::toloop = $_[1] if @@_ > 1;
  $Term::ReadLine::toloop;
}

sub get_c {
  my $self = shift;
  $self->Tk_loop if $Term::ReadLine::toloop && defined &Tk::DoOneEvent;
  return getc $self->IN;
}

sub get_line {
  my $self = shift;
  $self->Tk_loop if $Term::ReadLine::toloop && defined &Tk::DoOneEvent;
  my $in = $self->IN;
  local ($/) = "\n";
  return scalar <$in>;
}
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d196 1
a196 1
    if (($^O eq 'amigaos') || ($^O eq 'beos') || ($^O eq 'epoc')) {
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d172 1
a172 2
  my $prompt = shift;
  print $out $rl_term_set[0], $prompt, $rl_term_set[1], $rl_term_set[2]; 
a177 1
  $str =~ s/^\s*\Q$prompt\E// if ($^O eq 'MacOS');
d188 1
a188 3
    if ($^O eq 'MacOS') {
        $console = "Dev:Console";
    } elsif (-e "/dev/tty") {
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d9 3
a11 3
  my $term = new Term::ReadLine 'Simple Perl calc';
  my $prompt = "Enter your arithmetic expression: ";
  my $OUT = $term->OUT || \*STDOUT;
d13 1
a13 1
    my $res = eval($_), "\n";
d44 1
a44 1
C<Term::ReadLine::Stub>.
a159 16
=head1 CAVEATS

It seems that using Term::ReadLine from Emacs minibuffer doesn't work
quite right and one will get an error message like

    Cannot open /dev/tty for read at ...

One possible workaround for this is to explicitly open /dev/tty like this

    open (FH, "/dev/tty" )
      or eval 'sub Term::ReadLine::findConsole { ("&STDIN", "&STDERR") }';
    die $@@ if $@@;
    close (FH);

or you can try using the 4-argument form of Term::ReadLine->new().

a161 2
use strict;

d163 1
a163 1
our @@ISA = qw'Term::ReadLine::Tk Term::ReadLine::TermCap';
a165 1
our @@rl_term_set;
d211 1
a211 1
    my $consoleOUT = $console;
d225 1
a225 1
    my($console, $consoleOUT) = $_[0]->findConsole;
d230 1
a230 1
    my $sel = select(FOUT);
d237 1
a237 1
    my $sel = select($FOUT);
a268 2
our $VERSION = '1.00';

d288 1
a288 1
our @@ISA;
a292 2
} elsif (defined $which && defined &{"Term::ReadLine::$which\::readline"}) {
  @@ISA = "Term::ReadLine::$which";
d301 1
a301 1
our @@rl_term_set = ("","","","");
d303 1
a303 1
our $rl_term_set = ',,,';
a304 1
our $terminal;
a331 1
our($count_handle, $count_DoOne, $count_loop);
a333 1
our($giveup);
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d3 2
a4 2
Term::ReadLine - Perl interface to various C<readline> packages.
If no real package is found, substitutes stubs instead of basic functions.
d13 1
a13 1
    my $res = eval($_);
d36 1
a36 1
where $term is a return value of Term::ReadLine-E<gt>new().
d63 1
a63 1
=item C<IN>, C<OUT>
a186 2
sub PERL_UNICODE_STDIN () { 0x0001 }

a198 3
  utf8::upgrade($str)
      if (${^UNICODE} & PERL_UNICODE_STDIN || defined ${^ENCODING}) &&
         utf8::valid($str);
d288 1
a288 1
our $VERSION = '1.01';
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d21 4
a24 3
This package is just a front end to some other packages. It's a stub to
set up a common interface to the various ReadLine implementations found on
CPAN (under the C<Term::ReadLine::*> namespace).
d103 1
a103 1
support a richer set of commands.
d293 1
a293 1
our $VERSION = '1.02';
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a211 1
    my $consoleOUT;
d218 1
a218 2
       $console = 'CONIN$';
       $consoleOUT = 'CONOUT$';
d234 1
a234 1
    $consoleOUT = $console unless defined $consoleOUT;
d237 1
a237 1
      $consoleOUT = defined fileno(STDERR) && $^O ne 'MSWin32' ? "&STDERR" : "&STDOUT";
d250 2
a251 7

    # the Windows CONIN$ needs GENERIC_WRITE mode to allow
    # a SetConsoleMode() if we end up using Term::ReadKey
    open FIN, (  $^O eq 'MSWin32' && $console eq 'CONIN$' ) ? "+<$console" :
                                                              "<$console";
    open FOUT,">$consoleOUT";

a289 7
sub get_line {
  my $self = shift;
  my $in = $self->IN;
  local ($/) = "\n";
  return scalar <$in>;
}

d292 1
a292 1
our $VERSION = '1.03';
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d9 1
a9 1
  my $term = Term::ReadLine->new('Simple Perl calc');
d29 1
a29 1
  $term = Term::ReadLine->new('name');
d306 1
a306 1
our $VERSION = '1.04';
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d306 1
a306 1
our $VERSION = '1.05';
a313 3
  } elsif ($which =~ /^(Stub|TermCap|Tk)$/) {
    # it is already in memory to avoid false exception as seen in:
    # PERL_RL=Stub perl -e'$SIG{__DIE__} = sub { print @@_ }; require Term::ReadLine'
@


