head	1.10;
access;
symbols
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.6.0.8
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.6
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.4
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.6.0.2
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.6
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.4
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.2
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2010.09.24.14.59.51;	author millert;	state dead;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.42;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.08;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.09.18.09.46;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.03.03.02.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.24.18.35.37;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.17.06.52;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.06.16.09.49;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.49;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.23.37;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.09;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.47.22;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.17.29;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.57;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.42;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.57;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@# Term::ANSIColor -- Color screen output using ANSI escape sequences.
#
# Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009
#     Russ Allbery <rra@@stanford.edu> and Zenin
# PUSH/POP support submitted 2007 by openmethods.com voice solutions
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.
#
# Ah, September, when the sysadmins turn colors and fall off the trees....
#                               -- Dave Van Domelen

##############################################################################
# Modules and declarations
##############################################################################

package Term::ANSIColor;
require 5.001;

$VERSION = '2.00';

use strict;
use vars qw($AUTOLOAD $AUTOLOCAL $AUTORESET @@COLORLIST @@COLORSTACK $EACHLINE
            @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS $VERSION %ATTRIBUTES
            %ATTRIBUTES_R);

use Exporter ();
BEGIN {
    @@COLORLIST   = qw(CLEAR RESET BOLD DARK UNDERLINE UNDERSCORE BLINK REVERSE
                      CONCEALED BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE
                      ON_BLACK ON_RED ON_GREEN ON_YELLOW ON_BLUE ON_MAGENTA
                      ON_CYAN ON_WHITE);
    @@ISA         = qw(Exporter);
    @@EXPORT      = qw(color colored);
    @@EXPORT_OK   = qw(uncolor);
    %EXPORT_TAGS = (constants => \@@COLORLIST,
                    pushpop   => [ @@COLORLIST,
                                   qw(PUSHCOLOR POPCOLOR LOCALCOLOR) ]);
    Exporter::export_ok_tags ('pushpop');
}

##############################################################################
# Internal data structures
##############################################################################

%ATTRIBUTES = ('clear'      => 0,
               'reset'      => 0,
               'bold'       => 1,
               'dark'       => 2,
               'faint'      => 2,
               'underline'  => 4,
               'underscore' => 4,
               'blink'      => 5,
               'reverse'    => 7,
               'concealed'  => 8,

               'black'      => 30,   'on_black'   => 40,
               'red'        => 31,   'on_red'     => 41,
               'green'      => 32,   'on_green'   => 42,
               'yellow'     => 33,   'on_yellow'  => 43,
               'blue'       => 34,   'on_blue'    => 44,
               'magenta'    => 35,   'on_magenta' => 45,
               'cyan'       => 36,   'on_cyan'    => 46,
               'white'      => 37,   'on_white'   => 47);

# Reverse lookup.  Alphabetically first name for a sequence is preferred.
for (reverse sort keys %ATTRIBUTES) {
    $ATTRIBUTES_R{$ATTRIBUTES{$_}} = $_;
}

##############################################################################
# Implementation (constant form)
##############################################################################

# Time to have fun!  We now want to define the constant subs, which are named
# the same as the attributes above but in all caps.  Each constant sub needs
# to act differently depending on whether $AUTORESET is set.  Without
# autoreset:
#
#     BLUE "text\n"  ==>  "\e[34mtext\n"
#
# If $AUTORESET is set, we should instead get:
#
#     BLUE "text\n"  ==>  "\e[34mtext\n\e[0m"
#
# The sub also needs to handle the case where it has no arguments correctly.
# Maintaining all of this as separate subs would be a major nightmare, as well
# as duplicate the %ATTRIBUTES hash, so instead we define an AUTOLOAD sub to
# define the constant subs on demand.  To do that, we check the name of the
# called sub against the list of attributes, and if it's an all-caps version
# of one of them, we define the sub on the fly and then run it.
#
# If the environment variable ANSI_COLORS_DISABLED is set, just return the
# arguments without adding any escape sequences.  This is to make it easier to
# write scripts that also work on systems without any ANSI support, like
# Windows consoles.
sub AUTOLOAD {
    if (defined $ENV{ANSI_COLORS_DISABLED}) {
        return join ('', @@_);
    }
    my $sub;
    ($sub = $AUTOLOAD) =~ s/^.*:://;
    my $attr = $ATTRIBUTES{lc $sub};
    if ($sub =~ /^[A-Z_]+$/ && defined $attr) {
        $attr = "\e[" . $attr . 'm';
        eval qq {
            sub $AUTOLOAD {
                if (\$AUTORESET && \@@_) {
                    return '$attr' . join ('', \@@_) . "\e[0m";
                } elsif (\$AUTOLOCAL && \@@_) {
                    return PUSHCOLOR ('$attr') . join ('', \@@_) . POPCOLOR;
                } else {
                    return '$attr' . join ('', \@@_);
                }
            }
        };
        goto &$AUTOLOAD;
    } else {
        require Carp;
        Carp::croak ("undefined subroutine &$AUTOLOAD called");
    }
}

# Append a new color to the top of the color stack and return the top of
# the stack.
sub PUSHCOLOR {
    my ($text) = @@_;
    my ($color) = ($text =~ m/^((?:\e\[[\d;]+m)+)/);
    if (@@COLORSTACK) {
        $color = $COLORSTACK[-1] . $color;
    }
    push (@@COLORSTACK, $color);
    return $text;
}

# Pop the color stack and return the new top of the stack (or reset, if
# the stack is empty).
sub POPCOLOR {
    pop @@COLORSTACK;
    if (@@COLORSTACK) {
        return $COLORSTACK[-1] . join ('', @@_);
    } else {
        return RESET (@@_);
    }
}

# Surround arguments with a push and a pop.
sub LOCALCOLOR {
    return PUSHCOLOR (join ('', @@_)) . POPCOLOR ();
}

##############################################################################
# Implementation (attribute string form)
##############################################################################

# Return the escape code for a given set of color attributes.
sub color {
    return '' if defined $ENV{ANSI_COLORS_DISABLED};
    my @@codes = map { split } @@_;
    my $attribute = '';
    foreach (@@codes) {
        $_ = lc $_;
        unless (defined $ATTRIBUTES{$_}) {
            require Carp;
            Carp::croak ("Invalid attribute name $_");
        }
        $attribute .= $ATTRIBUTES{$_} . ';';
    }
    chop $attribute;
    return ($attribute ne '') ? "\e[${attribute}m" : undef;
}

# Return a list of named color attributes for a given set of escape codes.
# Escape sequences can be given with or without enclosing "\e[" and "m".  The
# empty escape sequence '' or "\e[m" gives an empty list of attrs.
sub uncolor {
    my (@@nums, @@result);
    for (@@_) {
        my $escape = $_;
        $escape =~ s/^\e\[//;
        $escape =~ s/m$//;
        unless ($escape =~ /^((?:\d+;)*\d*)$/) {
            require Carp;
            Carp::croak ("Bad escape sequence $_");
        }
        push (@@nums, split (/;/, $1));
    }
    for (@@nums) {
	$_ += 0; # Strip leading zeroes
	my $name = $ATTRIBUTES_R{$_};
	if (!defined $name) {
	    require Carp;
	    Carp::croak ("No name for escape sequence $_" );
	}
	push (@@result, $name);
    }
    return @@result;
}

# Given a string and a set of attributes, returns the string surrounded by
# escape codes to set those attributes and then clear them at the end of the
# string.  The attributes can be given either as an array ref as the first
# argument or as a list as the second and subsequent arguments.  If $EACHLINE
# is set, insert a reset before each occurrence of the string $EACHLINE and
# the starting attribute code after the string $EACHLINE, so that no attribute
# crosses line delimiters (this is often desirable if the output is to be
# piped to a pager or some other program).
sub colored {
    my ($string, @@codes);
    if (ref $_[0]) {
        @@codes = @@{+shift};
        $string = join ('', @@_);
    } else {
        $string = shift;
        @@codes = @@_;
    }
    return $string if defined $ENV{ANSI_COLORS_DISABLED};
    if (defined $EACHLINE) {
        my $attr = color (@@codes);
        return join '',
            map { ($_ ne $EACHLINE) ? $attr . $_ . "\e[0m" : $_ }
                grep { length ($_) > 0 }
                    split (/(\Q$EACHLINE\E)/, $string);
    } else {
        return color (@@codes) . $string . "\e[0m";
    }
}

##############################################################################
# Module return value and documentation
##############################################################################

# Ensure we evaluate to true.
1;
__END__

=head1 NAME

Term::ANSIColor - Color screen output using ANSI escape sequences

=for stopwords
cyan colorize namespace runtime TMTOWTDI cmd.exe 4nt.exe command.com NT
ESC Delvare SSH OpenSSH aixterm ECMA-048 Fraktur overlining Zenin
reimplemented Allbery PUSHCOLOR POPCOLOR LOCALCOLOR openmethods.com

=head1 SYNOPSIS

    use Term::ANSIColor;
    print color 'bold blue';
    print "This text is bold blue.\n";
    print color 'reset';
    print "This text is normal.\n";
    print colored ("Yellow on magenta.", 'yellow on_magenta'), "\n";
    print "This text is normal.\n";
    print colored ['yellow on_magenta'], 'Yellow on magenta.';
    print "\n";

    use Term::ANSIColor qw(uncolor);
    print uncolor '01;31', "\n";

    use Term::ANSIColor qw(:constants);
    print BOLD, BLUE, "This text is in bold blue.\n", RESET;

    use Term::ANSIColor qw(:constants);
    {
        local $Term::ANSIColor::AUTORESET = 1;
        print BOLD BLUE "This text is in bold blue.\n";
        print "This text is normal.\n";
    }

    use Term::ANSIColor qw(:pushpop);
    print PUSHCOLOR RED ON_GREEN "This text is red on green.\n";
    print PUSHCOLOR BLUE "This text is blue on green.\n";
    print RESET BLUE "This text is just blue.\n";
    print POPCOLOR "Back to red on green.\n";
    print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\n";
    print "This text is red on green.\n";
    {
        local $Term::ANSIColor::AUTOLOCAL = 1;
        print ON_BLUE "This text is red on blue.\n";
        print "This text is red on green.\n";
    }
    print POPCOLOR "Back to whatever we started as.\n";

=head1 DESCRIPTION

This module has two interfaces, one through color() and colored() and the
other through constants.  It also offers the utility function uncolor(),
which has to be explicitly imported to be used (see L</SYNOPSIS>).

color() takes any number of strings as arguments and considers them to be
space-separated lists of attributes.  It then forms and returns the escape
sequence to set those attributes.  It doesn't print it out, just returns
it, so you'll have to print it yourself if you want to (this is so that
you can save it as a string, pass it to something else, send it to a file
handle, or do anything else with it that you might care to).

uncolor() performs the opposite translation, turning escape sequences
into a list of strings.

The recognized non-color attributes are clear, reset, bold, dark, faint,
underline, underscore, blink, reverse, and concealed.  Clear and reset
(reset to default attributes), dark and faint (dim and saturated), and
underline and underscore are equivalent, so use whichever is the most
intuitive to you.  The recognized foreground color attributes are black,
red, green, yellow, blue, magenta, cyan, and white.  The recognized
background color attributes are on_black, on_red, on_green, on_yellow,
on_blue, on_magenta, on_cyan, and on_white.  Case is not significant.

Note that not all attributes are supported by all terminal types, and some
terminals may not support any of these sequences.  Dark and faint, blink,
and concealed in particular are frequently not implemented.

Attributes, once set, last until they are unset (by sending the attribute
C<clear> or C<reset>).  Be careful to do this, or otherwise your attribute
will last after your script is done running, and people get very annoyed
at having their prompt and typing changed to weird colors.

As an aid to help with this, colored() takes a scalar as the first
argument and any number of attribute strings as the second argument and
returns the scalar wrapped in escape codes so that the attributes will be
set as requested before the string and reset to normal after the string.
Alternately, you can pass a reference to an array as the first argument,
and then the contents of that array will be taken as attributes and color
codes and the remainder of the arguments as text to colorize.

Normally, colored() just puts attribute codes at the beginning and end of
the string, but if you set $Term::ANSIColor::EACHLINE to some string, that
string will be considered the line delimiter and the attribute will be set
at the beginning of each line of the passed string and reset at the end of
each line.  This is often desirable if the output contains newlines and
you're using background colors, since a background color that persists
across a newline is often interpreted by the terminal as providing the
default background color for the next line.  Programs like pagers can also
be confused by attributes that span lines.  Normally you'll want to set
$Term::ANSIColor::EACHLINE to C<"\n"> to use this feature.

Alternately, if you import C<:constants>, you can use the constants CLEAR,
RESET, BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED,
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, ON_BLACK, ON_RED,
ON_GREEN, ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.
These are the same as color('attribute') and can be used if you prefer
typing:

    print BOLD BLUE ON_WHITE "Text", RESET, "\n";

to

    print colored ("Text", 'bold blue on_white'), "\n";

(Note that the newline is kept separate to avoid confusing the terminal as
described above since a background color is being used.)

When using the constants, if you don't want to have to remember to add the
C<, RESET> at the end of each print line, you can set
$Term::ANSIColor::AUTORESET to a true value.  Then, the display mode will
automatically be reset if there is no comma after the constant.  In other
words, with that variable set:

    print BOLD BLUE "Text\n";

will reset the display mode afterward, whereas:

    print BOLD, BLUE, "Text\n";

will not.  If you are using background colors, you will probably want to
print the newline with a separate print statement to avoid confusing the
terminal.

The subroutine interface has the advantage over the constants interface in
that only two subroutines are exported into your namespace, versus
twenty-two in the constants interface.  On the flip side, the constants
interface has the advantage of better compile time error checking, since
misspelled names of colors or attributes in calls to color() and colored()
won't be caught until runtime whereas misspelled names of constants will
be caught at compile time.  So, pollute your namespace with almost two
dozen subroutines that you may not even use that often, or risk a silly
bug by mistyping an attribute.  Your choice, TMTOWTDI after all.

As of Term::ANSIColor 2.0, you can import C<:pushpop> and maintain a stack
of colors using PUSHCOLOR, POPCOLOR, and LOCALCOLOR.  PUSHCOLOR takes the
attribute string that starts its argument and pushes it onto a stack of
attributes.  POPCOLOR removes the top of the stack and restores the
previous attributes set by the argument of a prior PUSHCOLOR.  LOCALCOLOR
surrounds its argument in a PUSHCOLOR and POPCOLOR so that the color
resets afterward.

When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly
important to not put commas between the constants.

    print PUSHCOLOR BLUE "Text\n";

will correctly push BLUE onto the top of the stack.

    print PUSHCOLOR, BLUE, "Text\n";    # wrong!

will not, and a subsequent pop won't restore the correct attributes.
PUSHCOLOR pushes the attributes set by its argument, which is normally a
string of color constants.  It can't ask the terminal what the current
attributes are.

=head1 DIAGNOSTICS

=over 4

=item Bad escape sequence %s

(F) You passed an invalid ANSI escape sequence to uncolor().

=item Bareword "%s" not allowed while "strict subs" in use

(F) You probably mistyped a constant color name such as:

    $Foobar = FOOBAR . "This line should be blue\n";

or:

    @@Foobar = FOOBAR, "This line should be blue\n";

This will only show up under use strict (another good reason to run under
use strict).

=item Invalid attribute name %s

(F) You passed an invalid attribute name to either color() or colored().

=item Name "%s" used only once: possible typo

(W) You probably mistyped a constant color name such as:

    print FOOBAR "This text is color FOOBAR\n";

It's probably better to always use commas after constant names in order to
force the next error.

=item No comma allowed after filehandle

(F) You probably mistyped a constant color name such as:

    print FOOBAR, "This text is color FOOBAR\n";

Generating this fatal compile error is one of the main advantages of using
the constants interface, since you'll immediately know if you mistype a
color name.

=item No name for escape sequence %s

(F) The ANSI escape sequence passed to uncolor() contains escapes which
aren't recognized and can't be translated to names.

=back

=head1 ENVIRONMENT

=over 4

=item ANSI_COLORS_DISABLED

If this environment variable is set, all of the functions defined by this
module (color(), colored(), and all of the constants not previously used
in the program) will not output any escape sequences and instead will just
return the empty string or pass through the original text as appropriate.
This is intended to support easy use of scripts using this module on
platforms that don't support ANSI escape sequences.

For it to have its proper effect, this environment variable must be set
before any color constants are used in the program.

=back

=head1 RESTRICTIONS

It would be nice if one could leave off the commas around the constants
entirely and just say:

    print BOLD BLUE ON_WHITE "Text\n" RESET;

but the syntax of Perl doesn't allow this.  You need a comma after the
string.  (Of course, you may consider it a bug that commas between all the
constants aren't required, in which case you may feel free to insert
commas unless you're using $Term::ANSIColor::AUTORESET or
PUSHCOLOR/POPCOLOR.)

For easier debugging, you may prefer to always use the commas when not
setting $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR so that you'll
get a fatal compile error rather than a warning.

=head1 NOTES

The codes generated by this module are standard terminal control codes,
complying with ECMA-048 and ISO 6429 (generally referred to as "ANSI
color" for the color codes).  The non-color control codes (bold, dark,
italic, underline, and reverse) are part of the earlier ANSI X3.64
standard for control sequences for video terminals and peripherals.

Note that not all displays are ISO 6429-compliant, or even X3.64-compliant
(or are even attempting to be so).  This module will not work as expected
on displays that do not honor these escape sequences, such as cmd.exe,
4nt.exe, and command.com under either Windows NT or Windows 2000.  They
may just be ignored, or they may display as an ESC character followed by
some apparent garbage.

Jean Delvare provided the following table of different common terminal
emulators and their support for the various attributes and others have
helped me flesh it out:

              clear    bold     faint   under    blink   reverse  conceal
 ------------------------------------------------------------------------
 xterm         yes      yes      no      yes     bold      yes      yes
 linux         yes      yes      yes    bold      yes      yes      no
 rxvt          yes      yes      no      yes  bold/black   yes      no
 dtterm        yes      yes      yes     yes    reverse    yes      yes
 teraterm      yes    reverse    no      yes    rev/red    yes      no
 aixterm      kinda   normal     no      yes      no       yes      yes
 PuTTY         yes     color     no      yes      no       yes      no
 Windows       yes      no       no      no       no       yes      no
 Cygwin SSH    yes      yes      no     color    color    color     yes
 Mac Terminal  yes      yes      no      yes      yes      yes      yes

Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under
Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac
OS X.  Where the entry is other than yes or no, that emulator displays the
given attribute as something else instead.  Note that on an aixterm, clear
doesn't reset colors; you have to explicitly set the colors back to what
you want.  More entries in this table are welcome.

Note that codes 3 (italic), 6 (rapid blink), and 9 (strike-through) are
specified in ANSI X3.64 and ECMA-048 but are not commonly supported by
most displays and emulators and therefore aren't supported by this module
at the present time.  ECMA-048 also specifies a large number of other
attributes, including a sequence of attributes for font changes, Fraktur
characters, double-underlining, framing, circling, and overlining.  As
none of these attributes are widely supported or useful, they also aren't
currently supported by this module.

=head1 SEE ALSO

ECMA-048 is available on-line (at least at the time of this writing) at
L<http://www.ecma-international.org/publications/standards/ECMA-048.HTM>.

ISO 6429 is available from ISO for a charge; the author of this module
does not own a copy of it.  Since the source material for ISO 6429 was
ECMA-048 and the latter is available for free, there seems little reason
to obtain the ISO standard.

The current version of this module is always available from its web site
at L<http://www.eyrie.org/~eagle/software/ansicolor/>.  It is also part of
the Perl core distribution as of 5.6.0.

=head1 AUTHORS

Original idea (using constants) by Zenin, reimplemented using subs by Russ
Allbery <rra@@stanford.edu>, and then combined with the original idea by
Russ with input from Zenin.  Russ Allbery now maintains this module.

=head1 COPYRIGHT AND LICENSE

Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009 Russ
Allbery <rra@@stanford.edu> and Zenin.  This program is free software; you
may redistribute it and/or modify it under the same terms as Perl itself.

PUSHCOLOR, POPCOLOR, and LOCALCOLOR were contributed by openmethods.com
voice solutions.

=cut
@


1.9
log
@Merge in perl 5.10.1
@
text
@@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a1 1
# $Id: ANSIColor.pm 64 2007-03-23 17:58:18Z eagle $
d3 3
a5 2
# Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006
#   by Russ Allbery <rra@@stanford.edu> and Zenin
d20 2
d23 3
a25 2
use vars qw($AUTOLOAD $AUTORESET $EACHLINE @@ISA @@EXPORT @@EXPORT_OK
            %EXPORT_TAGS $VERSION %attributes %attributes_r);
d28 13
a40 11
@@ISA         = qw(Exporter);
@@EXPORT      = qw(color colored);
@@EXPORT_OK   = qw(uncolor);
%EXPORT_TAGS = (constants => [qw(CLEAR RESET BOLD DARK UNDERLINE UNDERSCORE
                                 BLINK REVERSE CONCEALED BLACK RED GREEN
                                 YELLOW BLUE MAGENTA CYAN WHITE ON_BLACK
                                 ON_RED ON_GREEN ON_YELLOW ON_BLUE ON_MAGENTA
                                 ON_CYAN ON_WHITE)]);
Exporter::export_ok_tags ('constants');

$VERSION = '1.12';
d46 1
a46 1
%attributes = ('clear'      => 0,
d50 1
d67 2
a68 2
for (reverse sort keys %attributes) {
    $attributes_r{$attributes{$_}} = $_;
d88 1
a88 1
# as duplicate the %attributes hash, so instead we define an AUTOLOAD sub to
d93 4
a96 4
# If the environment variable ANSI_COLORS_DISABLED is set, turn all of the
# generated subs into pass-through functions that don't add any escape
# sequences.  This is to make it easier to write scripts that also work on
# systems without any ANSI support, like Windows consoles.
d98 3
a100 1
    my $enable_colors = !defined $ENV{ANSI_COLORS_DISABLED};
d103 1
a103 1
    my $attr = $attributes{lc $sub};
d105 1
a105 1
        $attr = $enable_colors ? "\e[" . $attr . 'm' : '';
d109 3
a111 1
                    '$attr' . "\@@_" . "\e[0m";
d113 1
a113 1
                    ('$attr' . "\@@_");
d124 28
d163 1
a163 1
        unless (defined $attributes{$_}) {
d167 1
a167 1
        $attribute .= $attributes{$_} . ';';
d170 1
a170 1
    ($attribute ne '') ? "\e[${attribute}m" : undef;
d190 1
a190 1
	my $name = $attributes_r{$_};
d197 1
a197 1
    @@result;
d220 2
a221 2
        join '',
            map { $_ ne $EACHLINE ? $attr . $_ . "\e[0m" : $_ }
d225 1
a225 1
        color (@@codes) . $string . "\e[0m";
d241 5
d265 19
a283 3
    $Term::ANSIColor::AUTORESET = 1;
    print BOLD BLUE "This text is in bold blue.\n";
    print "This text is normal.\n";
d293 4
a296 4
sequence to set those attributes.  It doesn't print it out, just returns it,
so you'll have to print it yourself if you want to (this is so that you can
save it as a string, pass it to something else, send it to a file handle, or
do anything else with it that you might care to).
d301 8
a308 7
The recognized attributes (all of which should be fairly intuitive) are clear,
reset, dark, bold, underline, underscore, blink, reverse, concealed, black,
red, green, yellow, blue, magenta, cyan, white, on_black, on_red, on_green,
on_yellow, on_blue, on_magenta, on_cyan, and on_white.  Case is not
significant.  Underline and underscore are equivalent, as are clear and reset,
so use whichever is the most intuitive to you.  The color alone sets the
foreground color, and on_color sets the background color.
d311 2
a312 2
terminals may not support any of these sequences.  Dark, blink, and
concealed in particular are frequently not implemented.
d315 11
a325 11
"reset").  Be careful to do this, or otherwise your attribute will last
after your script is done running, and people get very annoyed at having
their prompt and typing changed to weird colors.

As an aid to help with this, colored() takes a scalar as the first argument
and any number of attribute strings as the second argument and returns the
scalar wrapped in escape codes so that the attributes will be set as
requested before the string and reset to normal after the string.
Alternately, you can pass a reference to an array as the first argument, and
then the contents of that array will be taken as attributes and color codes
and the remainder of the arguments as text to colorize.
d339 5
a343 4
RESET, BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED, BLACK,
RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, ON_BLACK, ON_RED, ON_GREEN,
ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.  These are
the same as color('attribute') and can be used if you prefer typing:
d362 1
a362 1
will reset the display mode afterwards, whereas:
d375 26
a400 4
won't be caught until runtime whereas misspelled names of constants will be
caught at compile time.  So, pollute your namespace with almost two dozen
subroutines that you may not even use that often, or risk a silly bug by
mistyping an attribute.  Your choice, TMTOWTDI after all.
d460 2
a461 2
module (color(), colored(), and all of the constants not previously used in
the program) will not output any escape sequences and instead will just
d480 3
a482 2
constants aren't required, in which case you may feel free to insert commas
unless you're using $Term::ANSIColor::AUTORESET.)
d485 2
a486 2
setting $Term::ANSIColor::AUTORESET so that you'll get a fatal compile error
rather than a warning.
d491 4
a494 4
complying with ECMA-48 and ISO 6429 (generally referred to as "ANSI color"
for the color codes).  The non-color control codes (bold, dark, italic,
underline, and reverse) are part of the earlier ANSI X3.64 standard for
control sequences for video terminals and peripherals.
d497 5
a501 5
(or are even attempting to be so).  This module will not work as expected on
displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe,
and command.com under either Windows NT or Windows 2000.  They may just be
ignored, or they may display as an ESC character followed by some apparent
garbage.
d504 2
a505 2
emulators and their support for the various attributes and others have helped
me flesh it out:
d507 1
a507 1
              clear    bold     dark    under    blink   reverse  conceal
d521 2
a522 2
Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS
X.  Where the entry is other than yes or no, that emulator displays the
d524 2
a525 2
doesn't reset colors; you have to explicitly set the colors back to what you
want.  More entries in this table are welcome.
d527 8
a534 8
Note that codes 3 (italic), 6 (rapid blink), and 9 (strikethrough) are
specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most
displays and emulators and therefore aren't supported by this module at the
present time.  ECMA-048 also specifies a large number of other attributes,
including a sequence of attributes for font changes, Fraktur characters,
double-underlining, framing, circling, and overlining.  As none of these
attributes are widely supported or useful, they also aren't currently
supported by this module.
d541 8
a548 8
ISO 6429 is available from ISO for a charge; the author of this module does
not own a copy of it.  Since the source material for ISO 6429 was ECMA-048
and the latter is available for free, there seems little reason to obtain
the ISO standard.

The current version of this module is always available from its web site at
L<http://www.eyrie.org/~eagle/software/ansicolor/>.  It is also part of the
Perl core distribution as of 5.6.0.
d553 2
a554 2
Allbery <rra@@stanford.edu>, and then combined with the original idea by Russ
with input from Zenin.  Russ Allbery now maintains this module.
d558 6
a563 3
Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006 Russ Allbery
<rra@@stanford.edu> and Zenin.  This program is free software; you may
redistribute it and/or modify it under the same terms as Perl itself.
@


1.7
log
@merge in perl 5.8.8
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.10 2005/08/21 18:31:58 eagle Exp $
d4 1
a4 1
# Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005
d35 1
a35 3
# Don't use the CVS revision as the version, since this module is also in Perl
# core and too many things could munge CVS magic revision strings.
$VERSION = '1.10';
d210 1
a210 1
    print colored ("Yellow on magenta.\n", 'yellow on_magenta');
d212 2
a213 1
    print colored ['yellow on_magenta'], "Yellow on magenta.\n";
d230 1
a230 1
which has to be explicitly imported to be used (see L<SYNOPSIS>).
d242 3
a244 3
The recognized attributes (all of which should be fairly intuitive) are
clear, reset, dark, bold, underline, underscore, blink, reverse, concealed,
black, red, green, yellow, blue, magenta, on_black, on_red, on_green,
d246 3
a248 3
significant.  Underline and underscore are equivalent, as are clear and
reset, so use whichever is the most intuitive to you.  The color alone sets
the foreground color, and on_color sets the background color.
d271 6
a276 4
each line.  This is often desirable if the output is being sent to a program
like a pager that can be confused by attributes that span lines.  Normally
you'll want to set $Term::ANSIColor::EACHLINE to C<"\n"> to use this
feature.
d284 1
a284 1
    print BOLD BLUE ON_WHITE "Text\n", RESET;
d288 4
a291 1
    print colored ("Text\n", 'bold blue on_white');
d305 3
a307 1
will not.
d315 1
a315 1
caught at compile time.  So, polute your namespace with almost two dozen
d400 1
a400 1
For easier debuging, you may prefer to always use the commas when not
d474 3
a476 3
Copyright 1996, 1997, 1998, 2000, 2001, 2002 Russ Allbery <rra@@stanford.edu>
and Zenin.  This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.
@


1.6
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.5 2003/12/03 03:02:41 millert Exp $
d4 2
a5 2
# Copyright 1996, 1997, 1998, 2000, 2001, 2002
#   by Russ Allbery <rra@@stanford.edu> and Zenin <zenin@@bawdycaste.com>
d37 1
a37 1
$VERSION = 1.08;
d185 3
a187 2
            map { $_ && $_ ne $EACHLINE ? $attr . $_ . "\e[0m" : $_ }
                split (/(\Q$EACHLINE\E)/, $string);
d428 1
d430 6
a435 5
Windows is Windows telnet, and Cygwin SSH is the OpenSSH implementation under
Cygwin on Windows NT.  Where the entry is other than yes or no, that emulator
displays the given attribute as something else instead.  Note that on an
aixterm, clear doesn't reset colors; you have to explicitly set the colors
back to what you want.  More entries in this table are welcome.
d469 2
a470 2
and Zenin <zenin@@bawdycaste.org>.  This program is free software; you may
redistribute it and/or modify it under the same terms as Perl itself.
@


1.5
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.7 2003/03/26 07:00:51 eagle Exp $
d28 4
a31 4
%EXPORT_TAGS = (constants => [qw(CLEAR RESET BOLD UNDERLINE UNDERSCORE BLINK
                                 REVERSE CONCEALED BLACK RED GREEN YELLOW
                                 BLUE MAGENTA CYAN WHITE ON_BLACK ON_RED
                                 ON_GREEN ON_YELLOW ON_BLUE ON_MAGENTA
d37 1
a37 1
$VERSION = 1.07;
d278 3
a280 3
RED, GREEN, YELLOW, BLUE, MAGENTA, ON_BLACK, ON_RED, ON_GREEN, ON_YELLOW,
ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.  These are the same as
color('attribute') and can be used if you prefer typing:
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.5 2002/06/28 22:49:01 eagle Exp $
d37 1
a37 1
$VERSION = 1.05;
d230 1
a230 1
which has to be explicitly imported to be used (see L<SYNOPSYS>).
d413 2
a414 1
emulators and their support for the various attributes:
d424 9
a432 5

Where the entry is other than yes or no, that emulator interpret the given
attribute as something else instead.  Note that on an aixterm, clear doesn't
reset colors; you have to explicitly set the colors back to what you want.
More entries in this table are welcome.
d446 1
a446 1
L<http://www.ecma.ch/ecma1/STAND/ECMA-048.HTM>.
@


1.3
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.3 2000/08/06 18:28:10 eagle Exp $
d4 2
a5 2
# Copyright 1996, 1997, 1998, 2000
#   by Russ Allbery <rra@@stanford.edu> and Zenin <zenin@@best.com>
d7 1
a7 1
# This program is free software; you can redistribute it and/or modify it
d13 1
a13 1
############################################################################
d15 1
a15 1
############################################################################
d21 2
a22 2
use vars qw(@@ISA @@EXPORT %EXPORT_TAGS $VERSION $AUTOLOAD %attributes
            $AUTORESET $EACHLINE);
d27 1
d35 3
a37 3
# Don't use the CVS revision as the version, since this module is also in
# Perl core and too many things could munge CVS magic revision strings.
$VERSION = 1.03;
d39 1
a39 2

############################################################################
d41 1
a41 1
############################################################################
d53 7
a59 7
               'black'      => 30,   'on_black'   => 40, 
               'red'        => 31,   'on_red'     => 41, 
               'green'      => 32,   'on_green'   => 42, 
               'yellow'     => 33,   'on_yellow'  => 43, 
               'blue'       => 34,   'on_blue'    => 44, 
               'magenta'    => 35,   'on_magenta' => 45, 
               'cyan'       => 36,   'on_cyan'    => 46, 
d62 4
d67 1
a67 1
############################################################################
d69 1
a69 1
############################################################################
d71 3
a73 3
# Time to have fun!  We now want to define the constant subs, which are
# named the same as the attributes above but in all caps.  Each constant sub
# needs to act differently depending on whether $AUTORESET is set.  Without
d76 1
a76 1
#   BLUE "text\n"  ==>  "\e[34mtext\n"
d80 1
a80 1
#   BLUE "text\n"  ==>  "\e[34mtext\n\e[0m"
d83 10
a92 5
# Maintaining all of this as separate subs would be a major nightmare, as
# well as duplicate the %attributes hash, so instead we define an AUTOLOAD
# sub to define the constant subs on demand.  To do that, we check the name
# of the called sub against the list of attributes, and if it's an all-caps
# version of one of them, we define the sub on the fly and then run it.
d94 1
d99 1
a99 1
        $attr = "\e[" . $attr . 'm';
d116 1
a116 2

############################################################################
d118 1
a118 1
############################################################################
d122 1
d137 27
d167 5
a171 5
# argument or as a list as the second and subsequent arguments.  If
# $EACHLINE is set, insert a reset before each occurrence of the string
# $EACHLINE and the starting attribute code after the string $EACHLINE, so
# that no attribute crosses line delimiters (this is often desirable if the
# output is to be piped to a pager or some other program).
d181 1
d184 1
a184 1
        join '', 
d192 1
a192 2

############################################################################
d194 1
a194 1
############################################################################
d215 3
d229 3
a231 2
other through constants.
    
d234 7
a240 4
sequence to set those attributes.  It doesn't print it out, just returns
it, so you'll have to print it yourself if you want to (this is so that
you can save it as a string, pass it to something else, send it to a file
handle, or do anything else with it that you might care to).
d243 6
a248 6
clear, reset, dark, bold, underline, underscore, blink, reverse,
concealed, black, red, green, yellow, blue, magenta, on_black, on_red,
on_green, on_yellow, on_blue, on_magenta, on_cyan, and on_white.  Case is
not significant.  Underline and underscore are equivalent, as are clear
and reset, so use whichever is the most intuitive to you.  The color alone
sets the foreground color, and on_color sets the background color.
d259 7
a265 7
As an aid to help with this, colored() takes a scalar as the first
argument and any number of attribute strings as the second argument and
returns the scalar wrapped in escape codes so that the attributes will be
set as requested before the string and reset to normal after the string.
Alternately, you can pass a reference to an array as the first argument,
and then the contents of that array will be taken as attributes and color
codes and the remainder of the arguments as text to colorize.
d268 7
a274 7
the string, but if you set $Term::ANSIColor::EACHLINE to some string,
that string will be considered the line delimiter and the attribute will
be set at the beginning of each line of the passed string and reset at the
end of each line.  This is often desirable if the output is being sent to
a program like a pager that can be confused by attributes that span lines.
Normally you'll want to set $Term::ANSIColor::EACHLINE to C<"\n"> to use
this feature.
d277 4
a280 4
RESET, BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED,
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, ON_BLACK, ON_RED, ON_GREEN,
ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.  These are
the same as color('attribute') and can be used if you prefer typing:
d307 4
a310 4
won't be caught until runtime whereas misspelled names of constants will
be caught at compile time.  So, polute your namespace with almost two
dozen subroutines that you may not even use that often, or risk a silly
bug by mistyping an attribute.  Your choice, TMTOWTDI after all.
d316 17
d356 6
a361 1
=item Bareword "%s" not allowed while "strict subs" in use
d363 1
a363 1
(F) You probably mistyped a constant color name such as:
d365 1
a365 1
    $Foobar = FOOBAR . "This line should be blue\n";
d367 1
a367 1
or:
d369 6
a374 1
    @@Foobar = FOOBAR, "This line should be blue\n";
d376 2
a377 2
This will only show up under use strict (another good reason to run under
use strict).
d390 2
a391 2
constants aren't required, in which case you may feel free to insert
commas unless you're using $Term::ANSIColor::AUTORESET.)
d394 2
a395 2
setting $Term::ANSIColor::AUTORESET so that you'll get a fatal compile
error rather than a warning.
d399 13
d425 26
a450 3
attribute as something else instead.  Note that on an aixterm, clear
doesn't reset colors; you have to explicitly set the colors back to what
you want.  More entries in this table are welcome.
d454 9
a462 3
Original idea (using constants) by Zenin (zenin@@best.com), reimplemented
using subs by Russ Allbery (rra@@stanford.edu), and then combined with the
original idea by Russ with input from Zenin.
@


1.2
log
@perl-5.6.0 + local changes
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.1 1997/12/10 20:05:29 eagle Exp $
d4 2
a5 2
# Copyright 1996, 1997 by Russ Allbery <rra@@stanford.edu>
#                     and Zenin <zenin@@best.com>
d9 3
d33 4
a36 2
    
($VERSION = (split (' ', q$Revision: 1.1 $ ))[1]) =~ s/\.(\d)$/.0$1/;
d46 1
d101 2
a102 1
        die "undefined subroutine &$AUTOLOAD called";
d129 6
a134 4
# string.  If $EACHLINE is set, insert a reset before each occurrence of the
# string $EACHLINE and the starting attribute code after the string
# $EACHLINE, so that no attribute crosses line delimiters (this is often
# desirable if the output is to be piped to a pager or some other program).
d136 8
a143 1
    my $string = shift;
d145 1
a145 1
        my $attr = color (@@_);
d150 1
a150 1
        color (@@_) . $string . "\e[0m";
d176 1
d199 5
a203 5
clear, reset, bold, underline, underscore, blink, reverse, concealed,
black, red, green, yellow, blue, magenta, on_black, on_red, on_green,
on_yellow, on_blue, on_magenta, on_cyan, and on_white.  Case is not
significant.  Underline and underscore are equivalent, as are clear and
reset, so use whichever is the most intuitive to you.  The color alone
d206 8
a213 4
Note that attributes, once set, last until they are unset (by sending the
attribute "reset").  Be careful to do this, or otherwise your attribute will
last after your script is done running, and people get very annoyed at
having their prompt and typing changed to weird colors.
d219 4
d233 4
a236 4
RESET, BOLD, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED, BLACK, RED,
GREEN, YELLOW, BLUE, MAGENTA, ON_BLACK, ON_RED, ON_GREEN, ON_YELLOW,
ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.  These are the same
as color('attribute') and can be used if you prefer typing:
d259 8
a266 8
that only 2 soubrutines are exported into your namespace, verses 22 in the
constants interface.  On the flip side, the constants interface has the
advantage of better compile time error checking, since misspelled names of
colors or attributes in calls to color() and colored() won't be caught
until runtime whereas misspelled names of constants will be caught at
compile time.  So, polute your namespace with almost two dozen subrutines
that you may not even use that oftin, or risk a silly bug by mistyping an
attribute.  Your choice, TMTOWTDI after all.
d274 1
a274 1
You passed an invalid attribute name to either color() or colored().
d276 1
a276 1
=item Identifier %s used only once: possible typo
d278 1
a278 1
You probably mistyped a constant color name such as:
d287 1
a287 1
You probably mistyped a constant color name such as:
d295 1
a295 1
=item Bareword %s not allowed while "strict subs" in use
d297 1
a297 1
You probably mistyped a constant color name such as:
d325 19
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.3 2000/08/06 18:28:10 eagle Exp $
d4 2
a5 2
# Copyright 1996, 1997, 1998, 2000
#   by Russ Allbery <rra@@stanford.edu> and Zenin <zenin@@best.com>
a8 3
#
# Ah, September, when the sysadmins turn colors and fall off the trees....
#                               -- Dave Van Domelen
d30 2
a31 4

# Don't use the CVS revision as the version, since this module is also in
# Perl core and too many things could munge CVS magic revision strings.
$VERSION = 1.03;
a40 1
               'dark'       => 2,
d95 1
a95 2
        require Carp;
        Carp::croak ("undefined subroutine &$AUTOLOAD called");
d122 4
a125 6
# string.  The attributes can be given either as an array ref as the first
# argument or as a list as the second and subsequent arguments.  If
# $EACHLINE is set, insert a reset before each occurrence of the string
# $EACHLINE and the starting attribute code after the string $EACHLINE, so
# that no attribute crosses line delimiters (this is often desirable if the
# output is to be piped to a pager or some other program).
d127 1
a127 8
    my ($string, @@codes);
    if (ref $_[0]) {
        @@codes = @@{+shift};
        $string = join ('', @@_);
    } else {
        $string = shift;
        @@codes = @@_;
    }
d129 1
a129 1
        my $attr = color (@@codes);
d134 1
a134 1
        color (@@codes) . $string . "\e[0m";
a159 1
    print colored ['yellow on_magenta'], "Yellow on magenta.\n";
d182 5
a186 5
clear, reset, dark, bold, underline, underscore, blink, reverse,
concealed, black, red, green, yellow, blue, magenta, on_black, on_red,
on_green, on_yellow, on_blue, on_magenta, on_cyan, and on_white.  Case is
not significant.  Underline and underscore are equivalent, as are clear
and reset, so use whichever is the most intuitive to you.  The color alone
d189 4
a192 8
Note that not all attributes are supported by all terminal types, and some
terminals may not support any of these sequences.  Dark, blink, and
concealed in particular are frequently not implemented.

Attributes, once set, last until they are unset (by sending the attribute
"reset").  Be careful to do this, or otherwise your attribute will last
after your script is done running, and people get very annoyed at having
their prompt and typing changed to weird colors.
a197 4
Alternately, you can pass a reference to an array as the first argument,
and then the contents of that array will be taken as attributes and color
codes and the remainder of the arguments as text to colorize.

d208 4
a211 4
RESET, BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED,
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, ON_BLACK, ON_RED, ON_GREEN,
ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.  These are
the same as color('attribute') and can be used if you prefer typing:
d234 8
a241 8
that only two subroutines are exported into your namespace, versus
twenty-two in the constants interface.  On the flip side, the constants
interface has the advantage of better compile time error checking, since
misspelled names of colors or attributes in calls to color() and colored()
won't be caught until runtime whereas misspelled names of constants will
be caught at compile time.  So, polute your namespace with almost two
dozen subroutines that you may not even use that often, or risk a silly
bug by mistyping an attribute.  Your choice, TMTOWTDI after all.
d249 1
a249 1
(F) You passed an invalid attribute name to either color() or colored().
d251 1
a251 1
=item Name "%s" used only once: possible typo
d253 1
a253 1
(W) You probably mistyped a constant color name such as:
d262 1
a262 1
(F) You probably mistyped a constant color name such as:
d270 1
a270 1
=item Bareword "%s" not allowed while "strict subs" in use
d272 1
a272 1
(F) You probably mistyped a constant color name such as:
a299 19

=head1 NOTES

Jean Delvare provided the following table of different common terminal
emulators and their support for the various attributes:

              clear    bold     dark    under    blink   reverse  conceal
 ------------------------------------------------------------------------
 xterm         yes      yes      no      yes     bold      yes      yes
 linux         yes      yes      yes    bold      yes      yes      no
 rxvt          yes      yes      no      yes  bold/black   yes      no
 dtterm        yes      yes      yes     yes    reverse    yes      yes
 teraterm      yes    reverse    no      yes    rev/red    yes      no
 aixterm      kinda   normal     no      yes      no       yes      yes

Where the entry is other than yes or no, that emulator interpret the given
attribute as something else instead.  Note that on an aixterm, clear
doesn't reset colors; you have to explicitly set the colors back to what
you want.  More entries in this table are welcome.
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.5 2002/06/28 22:49:01 eagle Exp $
d4 2
a5 2
# Copyright 1996, 1997, 1998, 2000, 2001, 2002
#   by Russ Allbery <rra@@stanford.edu> and Zenin <zenin@@bawdycaste.com>
d7 1
a7 1
# This program is free software; you may redistribute it and/or modify it
d13 1
a13 1
##############################################################################
d15 1
a15 1
##############################################################################
d21 2
a22 2
use vars qw($AUTOLOAD $AUTORESET $EACHLINE @@ISA @@EXPORT @@EXPORT_OK
            %EXPORT_TAGS $VERSION %attributes %attributes_r);
a26 1
@@EXPORT_OK   = qw(uncolor);
d34 3
a36 3
# Don't use the CVS revision as the version, since this module is also in Perl
# core and too many things could munge CVS magic revision strings.
$VERSION = 1.05;
d38 2
a39 1
##############################################################################
d41 1
a41 1
##############################################################################
d53 7
a59 7
               'black'      => 30,   'on_black'   => 40,
               'red'        => 31,   'on_red'     => 41,
               'green'      => 32,   'on_green'   => 42,
               'yellow'     => 33,   'on_yellow'  => 43,
               'blue'       => 34,   'on_blue'    => 44,
               'magenta'    => 35,   'on_magenta' => 45,
               'cyan'       => 36,   'on_cyan'    => 46,
a61 4
# Reverse lookup.  Alphabetically first name for a sequence is preferred.
for (reverse sort keys %attributes) {
    $attributes_r{$attributes{$_}} = $_;
}
d63 1
a63 1
##############################################################################
d65 1
a65 1
##############################################################################
d67 3
a69 3
# Time to have fun!  We now want to define the constant subs, which are named
# the same as the attributes above but in all caps.  Each constant sub needs
# to act differently depending on whether $AUTORESET is set.  Without
d72 1
a72 1
#     BLUE "text\n"  ==>  "\e[34mtext\n"
d76 1
a76 1
#     BLUE "text\n"  ==>  "\e[34mtext\n\e[0m"
d79 5
a83 10
# Maintaining all of this as separate subs would be a major nightmare, as well
# as duplicate the %attributes hash, so instead we define an AUTOLOAD sub to
# define the constant subs on demand.  To do that, we check the name of the
# called sub against the list of attributes, and if it's an all-caps version
# of one of them, we define the sub on the fly and then run it.
#
# If the environment variable ANSI_COLORS_DISABLED is set, turn all of the
# generated subs into pass-through functions that don't add any escape
# sequences.  This is to make it easier to write scripts that also work on
# systems without any ANSI support, like Windows consoles.
a84 1
    my $enable_colors = !defined $ENV{ANSI_COLORS_DISABLED};
d89 1
a89 1
        $attr = $enable_colors ? "\e[" . $attr . 'm' : '';
d106 2
a107 1
##############################################################################
d109 1
a109 1
##############################################################################
a112 1
    return '' if defined $ENV{ANSI_COLORS_DISABLED};
a126 27
# Return a list of named color attributes for a given set of escape codes.
# Escape sequences can be given with or without enclosing "\e[" and "m".  The
# empty escape sequence '' or "\e[m" gives an empty list of attrs.
sub uncolor {
    my (@@nums, @@result);
    for (@@_) {
        my $escape = $_;
        $escape =~ s/^\e\[//;
        $escape =~ s/m$//;
        unless ($escape =~ /^((?:\d+;)*\d*)$/) {
            require Carp;
            Carp::croak ("Bad escape sequence $_");
        }
        push (@@nums, split (/;/, $1));
    }
    for (@@nums) {
	$_ += 0; # Strip leading zeroes
	my $name = $attributes_r{$_};
	if (!defined $name) {
	    require Carp;
	    Carp::croak ("No name for escape sequence $_" );
	}
	push (@@result, $name);
    }
    @@result;
}

d130 5
a134 5
# argument or as a list as the second and subsequent arguments.  If $EACHLINE
# is set, insert a reset before each occurrence of the string $EACHLINE and
# the starting attribute code after the string $EACHLINE, so that no attribute
# crosses line delimiters (this is often desirable if the output is to be
# piped to a pager or some other program).
a143 1
    return $string if defined $ENV{ANSI_COLORS_DISABLED};
d146 1
a146 1
        join '',
d154 2
a155 1
##############################################################################
d157 1
a157 1
##############################################################################
a177 3
    use Term::ANSIColor qw(uncolor);
    print uncolor '01;31', "\n";

d189 2
a190 3
other through constants.  It also offers the utility function uncolor(),
which has to be explicitly imported to be used (see L<SYNOPSYS>).

d193 4
a196 7
sequence to set those attributes.  It doesn't print it out, just returns it,
so you'll have to print it yourself if you want to (this is so that you can
save it as a string, pass it to something else, send it to a file handle, or
do anything else with it that you might care to).

uncolor() performs the opposite translation, turning escape sequences
into a list of strings.
d199 6
a204 6
clear, reset, dark, bold, underline, underscore, blink, reverse, concealed,
black, red, green, yellow, blue, magenta, on_black, on_red, on_green,
on_yellow, on_blue, on_magenta, on_cyan, and on_white.  Case is not
significant.  Underline and underscore are equivalent, as are clear and
reset, so use whichever is the most intuitive to you.  The color alone sets
the foreground color, and on_color sets the background color.
d215 7
a221 7
As an aid to help with this, colored() takes a scalar as the first argument
and any number of attribute strings as the second argument and returns the
scalar wrapped in escape codes so that the attributes will be set as
requested before the string and reset to normal after the string.
Alternately, you can pass a reference to an array as the first argument, and
then the contents of that array will be taken as attributes and color codes
and the remainder of the arguments as text to colorize.
d224 7
a230 7
the string, but if you set $Term::ANSIColor::EACHLINE to some string, that
string will be considered the line delimiter and the attribute will be set
at the beginning of each line of the passed string and reset at the end of
each line.  This is often desirable if the output is being sent to a program
like a pager that can be confused by attributes that span lines.  Normally
you'll want to set $Term::ANSIColor::EACHLINE to C<"\n"> to use this
feature.
d233 4
a236 4
RESET, BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED, BLACK,
RED, GREEN, YELLOW, BLUE, MAGENTA, ON_BLACK, ON_RED, ON_GREEN, ON_YELLOW,
ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.  These are the same as
color('attribute') and can be used if you prefer typing:
d263 4
a266 4
won't be caught until runtime whereas misspelled names of constants will be
caught at compile time.  So, polute your namespace with almost two dozen
subroutines that you may not even use that often, or risk a silly bug by
mistyping an attribute.  Your choice, TMTOWTDI after all.
a271 17
=item Bad escape sequence %s

(F) You passed an invalid ANSI escape sequence to uncolor().

=item Bareword "%s" not allowed while "strict subs" in use

(F) You probably mistyped a constant color name such as:

    $Foobar = FOOBAR . "This line should be blue\n";

or:

    @@Foobar = FOOBAR, "This line should be blue\n";

This will only show up under use strict (another good reason to run under
use strict).

d295 1
a295 1
=item No name for escape sequence %s
d297 1
a297 2
(F) The ANSI escape sequence passed to uncolor() contains escapes which
aren't recognized and can't be translated to names.
d299 1
a299 1
=back
d301 1
a301 1
=head1 ENVIRONMENT
d303 1
a303 1
=over 4
d305 2
a306 11
=item ANSI_COLORS_DISABLED

If this environment variable is set, all of the functions defined by this
module (color(), colored(), and all of the constants not previously used in
the program) will not output any escape sequences and instead will just
return the empty string or pass through the original text as appropriate.
This is intended to support easy use of scripts using this module on
platforms that don't support ANSI escape sequences.

For it to have its proper effect, this environment variable must be set
before any color constants are used in the program.
d319 2
a320 2
constants aren't required, in which case you may feel free to insert commas
unless you're using $Term::ANSIColor::AUTORESET.)
d323 2
a324 2
setting $Term::ANSIColor::AUTORESET so that you'll get a fatal compile error
rather than a warning.
a327 13
The codes generated by this module are standard terminal control codes,
complying with ECMA-48 and ISO 6429 (generally referred to as "ANSI color"
for the color codes).  The non-color control codes (bold, dark, italic,
underline, and reverse) are part of the earlier ANSI X3.64 standard for
control sequences for video terminals and peripherals.

Note that not all displays are ISO 6429-compliant, or even X3.64-compliant
(or are even attempting to be so).  This module will not work as expected on
displays that do not honor these escape sequences, such as cmd.exe, 4nt.exe,
and command.com under either Windows NT or Windows 2000.  They may just be
ignored, or they may display as an ESC character followed by some apparent
garbage.

d341 3
a343 26
attribute as something else instead.  Note that on an aixterm, clear doesn't
reset colors; you have to explicitly set the colors back to what you want.
More entries in this table are welcome.

Note that codes 3 (italic), 6 (rapid blink), and 9 (strikethrough) are
specified in ANSI X3.64 and ECMA-048 but are not commonly supported by most
displays and emulators and therefore aren't supported by this module at the
present time.  ECMA-048 also specifies a large number of other attributes,
including a sequence of attributes for font changes, Fraktur characters,
double-underlining, framing, circling, and overlining.  As none of these
attributes are widely supported or useful, they also aren't currently
supported by this module.

=head1 SEE ALSO

ECMA-048 is available on-line (at least at the time of this writing) at
L<http://www.ecma.ch/ecma1/STAND/ECMA-048.HTM>.

ISO 6429 is available from ISO for a charge; the author of this module does
not own a copy of it.  Since the source material for ISO 6429 was ECMA-048
and the latter is available for free, there seems little reason to obtain
the ISO standard.

The current version of this module is always available from its web site at
L<http://www.eyrie.org/~eagle/software/ansicolor/>.  It is also part of the
Perl core distribution as of 5.6.0.
d347 3
a349 9
Original idea (using constants) by Zenin, reimplemented using subs by Russ
Allbery <rra@@stanford.edu>, and then combined with the original idea by Russ
with input from Zenin.  Russ Allbery now maintains this module.

=head1 COPYRIGHT AND LICENSE

Copyright 1996, 1997, 1998, 2000, 2001, 2002 Russ Allbery <rra@@stanford.edu>
and Zenin <zenin@@bawdycaste.org>.  This program is free software; you may
redistribute it and/or modify it under the same terms as Perl itself.
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.7 2003/03/26 07:00:51 eagle Exp $
d37 1
a37 1
$VERSION = 1.07;
d230 1
a230 1
which has to be explicitly imported to be used (see L<SYNOPSIS>).
d413 1
a413 2
emulators and their support for the various attributes and others have helped
me flesh it out:
d423 5
a427 9
 PuTTY         yes     color     no      yes      no       yes      no
 Windows       yes      no       no      no       no       yes      no
 Cygwin SSH    yes      yes      no     color    color    color     yes

Windows is Windows telnet, and Cygwin SSH is the OpenSSH implementation under
Cygwin on Windows NT.  Where the entry is other than yes or no, that emulator
displays the given attribute as something else instead.  Note that on an
aixterm, clear doesn't reset colors; you have to explicitly set the colors
back to what you want.  More entries in this table are welcome.
d441 1
a441 1
L<http://www.ecma-international.org/publications/standards/ECMA-048.HTM>.
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.5 2003/12/03 03:02:41 millert Exp $
d28 4
a31 4
%EXPORT_TAGS = (constants => [qw(CLEAR RESET BOLD DARK UNDERLINE UNDERSCORE
                                 BLINK REVERSE CONCEALED BLACK RED GREEN
                                 YELLOW BLUE MAGENTA CYAN WHITE ON_BLACK
                                 ON_RED ON_GREEN ON_YELLOW ON_BLUE ON_MAGENTA
d37 1
a37 1
$VERSION = 1.08;
d278 3
a280 3
RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, ON_BLACK, ON_RED, ON_GREEN,
ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.  These are
the same as color('attribute') and can be used if you prefer typing:
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.8 2004/02/20 06:21:26 eagle Exp $
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm,v 1.10 2005/08/21 18:31:58 eagle Exp $
d4 2
a5 2
# Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005
#   by Russ Allbery <rra@@stanford.edu> and Zenin
d37 1
a37 1
$VERSION = '1.10';
d185 2
a186 3
            map { $_ ne $EACHLINE ? $attr . $_ . "\e[0m" : $_ }
                grep { length ($_) > 0 }
                    split (/(\Q$EACHLINE\E)/, $string);
a426 1
 Mac Terminal  yes      yes      no      yes      yes      yes      yes
d428 5
a432 6
Windows is Windows telnet, Cygwin SSH is the OpenSSH implementation under
Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac OS
X.  Where the entry is other than yes or no, that emulator displays the
given attribute as something else instead.  Note that on an aixterm, clear
doesn't reset colors; you have to explicitly set the colors back to what you
want.  More entries in this table are welcome.
d466 2
a467 2
and Zenin.  This program is free software; you may redistribute it and/or
modify it under the same terms as Perl itself.
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d2 1
a2 1
# $Id: ANSIColor.pm 64 2007-03-23 17:58:18Z eagle $
d4 1
a4 1
# Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006
d35 3
a37 1
$VERSION = '1.12';
d212 1
a212 1
    print colored ("Yellow on magenta.", 'yellow on_magenta'), "\n";
d214 1
a214 2
    print colored ['yellow on_magenta'], 'Yellow on magenta.';
    print "\n";
d231 1
a231 1
which has to be explicitly imported to be used (see L</SYNOPSIS>).
d243 3
a245 3
The recognized attributes (all of which should be fairly intuitive) are clear,
reset, dark, bold, underline, underscore, blink, reverse, concealed, black,
red, green, yellow, blue, magenta, cyan, white, on_black, on_red, on_green,
d247 3
a249 3
significant.  Underline and underscore are equivalent, as are clear and reset,
so use whichever is the most intuitive to you.  The color alone sets the
foreground color, and on_color sets the background color.
d272 4
a275 6
each line.  This is often desirable if the output contains newlines and
you're using background colors, since a background color that persists
across a newline is often interpreted by the terminal as providing the
default background color for the next line.  Programs like pagers can also
be confused by attributes that span lines.  Normally you'll want to set
$Term::ANSIColor::EACHLINE to C<"\n"> to use this feature.
d283 1
a283 1
    print BOLD BLUE ON_WHITE "Text", RESET, "\n";
d287 1
a287 4
    print colored ("Text", 'bold blue on_white'), "\n";

(Note that the newline is kept separate to avoid confusing the terminal as
described above since a background color is being used.)
d301 1
a301 3
will not.  If you are using background colors, you will probably want to
print the newline with a separate print statement to avoid confusing the
terminal.
d309 1
a309 1
caught at compile time.  So, pollute your namespace with almost two dozen
d394 1
a394 1
For easier debugging, you may prefer to always use the commas when not
d468 3
a470 3
Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006 Russ Allbery
<rra@@stanford.edu> and Zenin.  This program is free software; you may
redistribute it and/or modify it under the same terms as Perl itself.
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d2 1
d4 2
a5 3
# Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009
#     Russ Allbery <rra@@stanford.edu> and Zenin
# PUSH/POP support submitted 2007 by openmethods.com voice solutions
a19 2
$VERSION = '2.00';

d21 2
a22 3
use vars qw($AUTOLOAD $AUTOLOCAL $AUTORESET @@COLORLIST @@COLORSTACK $EACHLINE
            @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS $VERSION %ATTRIBUTES
            %ATTRIBUTES_R);
d25 11
a35 13
BEGIN {
    @@COLORLIST   = qw(CLEAR RESET BOLD DARK UNDERLINE UNDERSCORE BLINK REVERSE
                      CONCEALED BLACK RED GREEN YELLOW BLUE MAGENTA CYAN WHITE
                      ON_BLACK ON_RED ON_GREEN ON_YELLOW ON_BLUE ON_MAGENTA
                      ON_CYAN ON_WHITE);
    @@ISA         = qw(Exporter);
    @@EXPORT      = qw(color colored);
    @@EXPORT_OK   = qw(uncolor);
    %EXPORT_TAGS = (constants => \@@COLORLIST,
                    pushpop   => [ @@COLORLIST,
                                   qw(PUSHCOLOR POPCOLOR LOCALCOLOR) ]);
    Exporter::export_ok_tags ('pushpop');
}
d41 1
a41 1
%ATTRIBUTES = ('clear'      => 0,
a44 1
               'faint'      => 2,
d61 2
a62 2
for (reverse sort keys %ATTRIBUTES) {
    $ATTRIBUTES_R{$ATTRIBUTES{$_}} = $_;
d82 1
a82 1
# as duplicate the %ATTRIBUTES hash, so instead we define an AUTOLOAD sub to
d87 4
a90 4
# If the environment variable ANSI_COLORS_DISABLED is set, just return the
# arguments without adding any escape sequences.  This is to make it easier to
# write scripts that also work on systems without any ANSI support, like
# Windows consoles.
d92 1
a92 3
    if (defined $ENV{ANSI_COLORS_DISABLED}) {
        return join ('', @@_);
    }
d95 1
a95 1
    my $attr = $ATTRIBUTES{lc $sub};
d97 1
a97 1
        $attr = "\e[" . $attr . 'm';
d101 1
a101 3
                    return '$attr' . join ('', \@@_) . "\e[0m";
                } elsif (\$AUTOLOCAL && \@@_) {
                    return PUSHCOLOR ('$attr') . join ('', \@@_) . POPCOLOR;
d103 1
a103 1
                    return '$attr' . join ('', \@@_);
a113 28
# Append a new color to the top of the color stack and return the top of
# the stack.
sub PUSHCOLOR {
    my ($text) = @@_;
    my ($color) = ($text =~ m/^((?:\e\[[\d;]+m)+)/);
    if (@@COLORSTACK) {
        $color = $COLORSTACK[-1] . $color;
    }
    push (@@COLORSTACK, $color);
    return $text;
}

# Pop the color stack and return the new top of the stack (or reset, if
# the stack is empty).
sub POPCOLOR {
    pop @@COLORSTACK;
    if (@@COLORSTACK) {
        return $COLORSTACK[-1] . join ('', @@_);
    } else {
        return RESET (@@_);
    }
}

# Surround arguments with a push and a pop.
sub LOCALCOLOR {
    return PUSHCOLOR (join ('', @@_)) . POPCOLOR ();
}

d125 1
a125 1
        unless (defined $ATTRIBUTES{$_}) {
d129 1
a129 1
        $attribute .= $ATTRIBUTES{$_} . ';';
d132 1
a132 1
    return ($attribute ne '') ? "\e[${attribute}m" : undef;
d152 1
a152 1
	my $name = $ATTRIBUTES_R{$_};
d159 1
a159 1
    return @@result;
d182 2
a183 2
        return join '',
            map { ($_ ne $EACHLINE) ? $attr . $_ . "\e[0m" : $_ }
d187 1
a187 1
        return color (@@codes) . $string . "\e[0m";
a202 5
=for stopwords
cyan colorize namespace runtime TMTOWTDI cmd.exe 4nt.exe command.com NT
ESC Delvare SSH OpenSSH aixterm ECMA-048 Fraktur overlining Zenin
reimplemented Allbery PUSHCOLOR POPCOLOR LOCALCOLOR openmethods.com

d222 3
a224 19
    {
        local $Term::ANSIColor::AUTORESET = 1;
        print BOLD BLUE "This text is in bold blue.\n";
        print "This text is normal.\n";
    }

    use Term::ANSIColor qw(:pushpop);
    print PUSHCOLOR RED ON_GREEN "This text is red on green.\n";
    print PUSHCOLOR BLUE "This text is blue on green.\n";
    print RESET BLUE "This text is just blue.\n";
    print POPCOLOR "Back to red on green.\n";
    print LOCALCOLOR GREEN ON_BLUE "This text is green on blue.\n";
    print "This text is red on green.\n";
    {
        local $Term::ANSIColor::AUTOLOCAL = 1;
        print ON_BLUE "This text is red on blue.\n";
        print "This text is red on green.\n";
    }
    print POPCOLOR "Back to whatever we started as.\n";
d234 4
a237 4
sequence to set those attributes.  It doesn't print it out, just returns
it, so you'll have to print it yourself if you want to (this is so that
you can save it as a string, pass it to something else, send it to a file
handle, or do anything else with it that you might care to).
d242 7
a248 8
The recognized non-color attributes are clear, reset, bold, dark, faint,
underline, underscore, blink, reverse, and concealed.  Clear and reset
(reset to default attributes), dark and faint (dim and saturated), and
underline and underscore are equivalent, so use whichever is the most
intuitive to you.  The recognized foreground color attributes are black,
red, green, yellow, blue, magenta, cyan, and white.  The recognized
background color attributes are on_black, on_red, on_green, on_yellow,
on_blue, on_magenta, on_cyan, and on_white.  Case is not significant.
d251 2
a252 2
terminals may not support any of these sequences.  Dark and faint, blink,
and concealed in particular are frequently not implemented.
d255 11
a265 11
C<clear> or C<reset>).  Be careful to do this, or otherwise your attribute
will last after your script is done running, and people get very annoyed
at having their prompt and typing changed to weird colors.

As an aid to help with this, colored() takes a scalar as the first
argument and any number of attribute strings as the second argument and
returns the scalar wrapped in escape codes so that the attributes will be
set as requested before the string and reset to normal after the string.
Alternately, you can pass a reference to an array as the first argument,
and then the contents of that array will be taken as attributes and color
codes and the remainder of the arguments as text to colorize.
d279 4
a282 5
RESET, BOLD, DARK, UNDERLINE, UNDERSCORE, BLINK, REVERSE, CONCEALED,
BLACK, RED, GREEN, YELLOW, BLUE, MAGENTA, CYAN, WHITE, ON_BLACK, ON_RED,
ON_GREEN, ON_YELLOW, ON_BLUE, ON_MAGENTA, ON_CYAN, and ON_WHITE directly.
These are the same as color('attribute') and can be used if you prefer
typing:
d301 1
a301 1
will reset the display mode afterward, whereas:
d314 4
a317 26
won't be caught until runtime whereas misspelled names of constants will
be caught at compile time.  So, pollute your namespace with almost two
dozen subroutines that you may not even use that often, or risk a silly
bug by mistyping an attribute.  Your choice, TMTOWTDI after all.

As of Term::ANSIColor 2.0, you can import C<:pushpop> and maintain a stack
of colors using PUSHCOLOR, POPCOLOR, and LOCALCOLOR.  PUSHCOLOR takes the
attribute string that starts its argument and pushes it onto a stack of
attributes.  POPCOLOR removes the top of the stack and restores the
previous attributes set by the argument of a prior PUSHCOLOR.  LOCALCOLOR
surrounds its argument in a PUSHCOLOR and POPCOLOR so that the color
resets afterward.

When using PUSHCOLOR, POPCOLOR, and LOCALCOLOR, it's particularly
important to not put commas between the constants.

    print PUSHCOLOR BLUE "Text\n";

will correctly push BLUE onto the top of the stack.

    print PUSHCOLOR, BLUE, "Text\n";    # wrong!

will not, and a subsequent pop won't restore the correct attributes.
PUSHCOLOR pushes the attributes set by its argument, which is normally a
string of color constants.  It can't ask the terminal what the current
attributes are.
d377 2
a378 2
module (color(), colored(), and all of the constants not previously used
in the program) will not output any escape sequences and instead will just
d397 2
a398 3
constants aren't required, in which case you may feel free to insert
commas unless you're using $Term::ANSIColor::AUTORESET or
PUSHCOLOR/POPCOLOR.)
d401 2
a402 2
setting $Term::ANSIColor::AUTORESET or PUSHCOLOR/POPCOLOR so that you'll
get a fatal compile error rather than a warning.
d407 4
a410 4
complying with ECMA-048 and ISO 6429 (generally referred to as "ANSI
color" for the color codes).  The non-color control codes (bold, dark,
italic, underline, and reverse) are part of the earlier ANSI X3.64
standard for control sequences for video terminals and peripherals.
d413 5
a417 5
(or are even attempting to be so).  This module will not work as expected
on displays that do not honor these escape sequences, such as cmd.exe,
4nt.exe, and command.com under either Windows NT or Windows 2000.  They
may just be ignored, or they may display as an ESC character followed by
some apparent garbage.
d420 2
a421 2
emulators and their support for the various attributes and others have
helped me flesh it out:
d423 1
a423 1
              clear    bold     faint   under    blink   reverse  conceal
d437 2
a438 2
Cygwin on Windows NT, and Mac Terminal is the Terminal application in Mac
OS X.  Where the entry is other than yes or no, that emulator displays the
d440 2
a441 2
doesn't reset colors; you have to explicitly set the colors back to what
you want.  More entries in this table are welcome.
d443 8
a450 8
Note that codes 3 (italic), 6 (rapid blink), and 9 (strike-through) are
specified in ANSI X3.64 and ECMA-048 but are not commonly supported by
most displays and emulators and therefore aren't supported by this module
at the present time.  ECMA-048 also specifies a large number of other
attributes, including a sequence of attributes for font changes, Fraktur
characters, double-underlining, framing, circling, and overlining.  As
none of these attributes are widely supported or useful, they also aren't
currently supported by this module.
d457 8
a464 8
ISO 6429 is available from ISO for a charge; the author of this module
does not own a copy of it.  Since the source material for ISO 6429 was
ECMA-048 and the latter is available for free, there seems little reason
to obtain the ISO standard.

The current version of this module is always available from its web site
at L<http://www.eyrie.org/~eagle/software/ansicolor/>.  It is also part of
the Perl core distribution as of 5.6.0.
d469 2
a470 2
Allbery <rra@@stanford.edu>, and then combined with the original idea by
Russ with input from Zenin.  Russ Allbery now maintains this module.
d474 3
a476 6
Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2005, 2006, 2008, 2009 Russ
Allbery <rra@@stanford.edu> and Zenin.  This program is free software; you
may redistribute it and/or modify it under the same terms as Perl itself.

PUSHCOLOR, POPCOLOR, and LOCALCOLOR were contributed by openmethods.com
voice solutions.
@


