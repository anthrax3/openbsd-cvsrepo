head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.45;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2008.09.29.17.18.39;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.39;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.11.01;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!/usr/bin/perl -w

use strict;
use lib $ENV{PERL_CORE} ? '../lib/Module/Build/t/lib' : 't/lib';
use MBTest;
use File::Spec;
use IO::File;
use Config;

# Don't let our own verbosity/test_file get mixed up with our subprocess's
my @@makefile_keys = qw(TEST_VERBOSE HARNESS_VERBOSE TEST_FILES MAKEFLAGS);
local  @@ENV{@@makefile_keys};
delete @@ENV{@@makefile_keys};

my @@makefile_types = qw(small passthrough traditional);
my $tests_per_type = 14;
if ( $Config{make} && find_in_path($Config{make}) ) {
    plan tests => 38 + @@makefile_types*$tests_per_type*2;
} else {
    plan skip_all => "Don't know how to invoke 'make'";
}
ok 1, "Loaded";


#########################

use Cwd ();
my $cwd = Cwd::cwd;
my $tmp = MBTest->tmpdir;

# Create test distribution; set requires and build_requires
use DistGen;
my $dist = DistGen->new( dir => $tmp );
$dist->regen;

chdir( $dist->dirname ) or die "Can't chdir to '@@{[$dist->dirname]}': $!";


#########################

use Module::Build;
use Module::Build::Compat;

use Carp;  $SIG{__WARN__} = \&Carp::cluck;

my @@make = $Config{make} eq 'nmake' ? ('nmake', '-nologo') : ($Config{make});

#########################

# Test without requires

test_makefile_types();

# Test with requires

my $distname = $dist->name;
$dist->change_build_pl({ 
  module_name         => $distname,
  license             => 'perl',
  requires            => {
    'perl'        => $],
    'File::Spec'  => 0,
  },
  build_requires      => {
    'Test::More'  => 0,
  },
});

$dist->regen;

test_makefile_types( requires => {
    'perl' => $],
    'File::Spec' => 0,
    'Test::More' => 0,
});

######################

$dist->change_build_pl({ 
  module_name         => $distname,
  license             => 'perl',
});
$dist->regen;

# Create M::B instance but don't pollute STDOUT
my $mb;
stdout_of( sub {
    $mb = Module::Build->new_from_context;
});
ok $mb, "Module::Build->new_from_context";


{
  # Make sure fake_makefile() can run without 'build_class', as it may be
  # in older-generated Makefile.PLs
  my $warning = '';
  local $SIG{__WARN__} = sub { $warning = shift; };
  my $maketext = eval { Module::Build::Compat->fake_makefile(makefile => 'Makefile') };
  is $@@, '', "fake_makefile lived";
  like $maketext, qr/^realclean/m, "found 'realclean' in fake_makefile output";
  like $warning, qr/build_class/, "saw warning about 'build_class'";
}

{
  # Make sure custom builder subclass is used in the created
  # Makefile.PL - make sure it fails in the right way here.
  local @@Foo::Builder::ISA = qw(Module::Build);
  my $foo_builder;
  stdout_of( sub {
    $foo_builder = Foo::Builder->new_from_context;
  });
  foreach my $style ('passthrough', 'small') {
    Module::Build::Compat->create_makefile_pl($style, $foo_builder);
    ok -e 'Makefile.PL', "$style Makefile.PL created";
    
    # Should fail with "can't find Foo/Builder.pm"
    my $result;
    my ($stdout, $stderr ) = stdout_stderr_of (sub {
      $result = $mb->run_perl_script('Makefile.PL');
    });
    ok ! $result, "Makefile.PL failed";
    like $stderr, qr{Foo/Builder.pm}, "custom builder wasn't found";
  }
  
  # Now make sure it can actually work.
  my $bar_builder;
  stdout_of( sub {
    $bar_builder = Module::Build->subclass( class => 'Bar::Builder' )->new_from_context;
  });
  foreach my $style ('passthrough', 'small') {
    Module::Build::Compat->create_makefile_pl($style, $bar_builder);
    ok -e 'Makefile.PL', "$style Makefile.PL created via subclass";
    my $result;
    stdout_of( sub {
      $result = $mb->run_perl_script('Makefile.PL');
    });
    ok $result, "Makefile.PL ran without error";
  }
}

{
  # Make sure various Makefile.PL arguments are supported
  Module::Build::Compat->create_makefile_pl('passthrough', $mb);

  my $libdir = File::Spec->catdir( $cwd, 't', 'libdir' );
  my $result;
  stdout_of( sub {
    $result = $mb->run_perl_script('Makefile.PL', [],
      [
      "LIB=$libdir",
      'TEST_VERBOSE=1',
      'INSTALLDIRS=perl',
      'POLLUTE=1',
      ]
    );
  });
  ok $result, "passthrough Makefile.PL ran with arguments";
  ok -e 'Build.PL', "Build.PL generated";

  my $new_build = Module::Build->resume();
  is $new_build->installdirs, 'core', "installdirs is core";
  is $new_build->verbose, 1, "tests set for verbose";
  is $new_build->install_destination('lib'), $libdir, "custom libdir";
  is $new_build->extra_compiler_flags->[0], '-DPERL_POLLUTE', "PERL_POLLUTE set";

  # Make sure those switches actually had an effect
  my ($ran_ok, $output);
  $output = stdout_of( sub { $ran_ok = $new_build->do_system(@@make, 'test') } );
  ok $ran_ok, "make test ran without error";
  $output =~ s/^/# /gm;  # Don't confuse our own test output
  like $output, qr/(?:# ok \d+\s+)+/, 'Should be verbose';

  # Make sure various Makefile arguments are supported
  $output = stdout_of( sub { $ran_ok = $mb->do_system(@@make, 'test', 'TEST_VERBOSE=0') } );
  ok $ran_ok, "make test without verbose ran ok";
  $output =~ s/^/# /gm;  # Don't confuse our own test output
  like $output, qr/(?:# .+basic\.+ok\s+(?:[\d.]+\s*m?s\s*)?)# All tests/,
      'Should be non-verbose';

  $mb->delete_filetree($libdir);
  ok ! -e $libdir, "Sample installation directory should be cleaned up";

  stdout_of( sub { $mb->do_system(@@make, 'realclean'); } );
  ok ! -e 'Makefile', "Makefile shouldn't exist";

  1 while unlink 'Makefile.PL';
  ok ! -e 'Makefile.PL', "Makefile.PL cleaned up";
}

{ # Make sure tilde-expansion works

  # C<glob> on MSWin32 uses $ENV{HOME} if defined to do tilde-expansion
  local $ENV{HOME} = 'C:/' if $^O =~ /MSWin/ && !exists( $ENV{HOME} );

  Module::Build::Compat->create_makefile_pl('passthrough', $mb);

  stdout_of( sub {
    $mb->run_perl_script('Makefile.PL', [], ['INSTALL_BASE=~/foo']);
  });
  my $b2 = Module::Build->current;
  ok $b2->install_base, "install_base set";
  unlike $b2->install_base, qr/^~/, "Tildes should be expanded";
  
  stdout_of( sub { $mb->do_system(@@make, 'realclean'); } );
  ok ! -e 'Makefile', "Makefile shouldn't exist";

  1 while unlink 'Makefile.PL';
  ok ! -e 'Makefile.PL', "Makefile.PL cleaned up";
}

#########################################################

sub test_makefile_types {
  my %opts = @@_;
  $opts{requires} ||= {};

  foreach my $type (@@makefile_types) {
    # Create M::B instance 
    my $mb;
    stdout_of( sub {
        $mb = Module::Build->new_from_context;
    });
    ok $mb, "Module::Build->new_from_context";

    # Create and test Makefile.PL
    Module::Build::Compat->create_makefile_pl($type, $mb);
    ok -e 'Makefile.PL', "$type Makefile.PL created";
    test_makefile_pl_requires_perl( $opts{requires}{perl} );
    test_makefile_creation($mb);
    test_makefile_prereq_pm( $opts{requires} );
      
    my ($output,$success);
    # Capture output to keep our STDOUT clean
    $output = stdout_of( sub {
      $success = $mb->do_system(@@make);
    });
    ok $success, "make ran without error";

    # Can't let 'test' STDOUT go to our STDOUT, or it'll confuse Test::Harness.
    $output = stdout_of( sub {
      $success = $mb->do_system(@@make, 'test');
    });
    ok $success, "make test ran without error";
    like uc $output, qr{DONE\.|SUCCESS}, "make test output indicated success";
    
    $output = stdout_of( sub {
      $success = $mb->do_system(@@make, 'realclean');
    });
    ok $success, "make realclean ran without error";

    # Try again with some Makefile.PL arguments
    test_makefile_creation($mb, [], 'INSTALLDIRS=vendor', 1);
    
    1 while unlink 'Makefile.PL';
    ok ! -e 'Makefile.PL', "cleaned up Makefile";
  }
}

sub test_makefile_creation {
  my ($build, $preargs, $postargs, $cleanup) = @@_;
  
  my ($output, $result);
  # capture output to avoid polluting our test output
  $output = stdout_of( sub {
      $result = $build->run_perl_script('Makefile.PL', $preargs, $postargs);
  });
  my $label = "Makefile.PL ran without error";
  if ( defined $postargs && length $postargs ) {
    $label .= " (postargs: $postargs)";
  }
  ok $result, $label;
  ok -e 'Makefile', "Makefile exists";
  
  if ($cleanup) {
    $output = stdout_of( sub {
      $build->do_system(@@make, 'realclean');
    });
    ok ! -e 'Makefile', "Makefile cleaned up";
  }
  else {
    pass '(skipping cleanup)'; # keep test count constant
  }
}

sub test_makefile_prereq_pm {
  my %requires = %{ $_[0] };
  delete $requires{perl}; # until EU::MM supports this
  SKIP: {
    skip 'Makefile not found', 1 unless -e 'Makefile';
    my $prereq_pm = find_makefile_prereq_pm();
    is_deeply $prereq_pm, \%requires,
      "Makefile has correct PREREQ_PM line";
  }
}

sub test_makefile_pl_requires_perl {
  my $perl_version = shift || q{};
  SKIP: {
    skip 'Makefile.PL not found', 1 unless -e 'Makefile.PL';
    my $file_contents = slurp 'Makefile.PL';
    my $found_requires = $file_contents =~ m{^require $perl_version;}ms;
    if (length $perl_version) {
      ok $found_requires, "Makefile.PL has 'require $perl_version;'"
        or diag "Makefile.PL:\n$file_contents";
    }
    else {
      ok ! $found_requires, "Makefile.PL does not require a perl version";
    }
  }
}

# Following subroutine adapted from code in CPAN.pm 
# by Andreas Koenig and A. Speer.
sub find_makefile_prereq_pm {
  my $fh = IO::File->new( 'Makefile', 'r' ) 
    or die "Can't read Makefile: $!";
  my $req = {};
  local($/) = "\n";
  while (<$fh>) {
    # locate PREREQ_PM
    last if /MakeMaker post_initialize section/;
    my($p) = m{^[\#]
      \s+PREREQ_PM\s+=>\s+(.+)
    }x;
    next unless $p;

    # extract modules
    while ( $p =~ m/(?:\s)([\w\:]+)=>(q\[.*?\]|undef),?/g ){
      my($m,$n) = ($1,$2);
      if ($n =~ /^q\[(.*?)\]$/) {
        $n = $1;
      }
      $req->{$m} = $n;
    }
    last;
  }
  return $req;
}

# cleanup
chdir( $cwd ) or die "Can''t chdir to '$cwd': $!";
$dist->remove;

use File::Path;
rmtree( $tmp );
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d16 3
a18 6
my $tests_per_type = 15;

#find_in_path does not understand VMS.

if ( $Config{make} && $^O ne 'VMS' ? find_in_path($Config{make}) : 1 ) {
    plan 'no_plan';
d22 1
a22 5

my $is_vms_mms = ($^O eq 'VMS') && ($Config{make} =~ /MM[SK]/i);

use_ok 'Module::Build';
ensure_blib('Module::Build');
d27 2
d36 1
a36 1
$dist->chdir_in;
a47 8
my $makefile = 'Makefile';

# VMS MMK/MMS by convention use Descrip.MMS
if ($is_vms_mms) {
    $makefile = 'Descrip.MMS';
}


d54 1
a54 1
# Test with requires and PL_files
a66 1
  PL_files            => { 'foo.PL' => 'foo' },
a68 5
$dist->add_file("foo.PL", <<'END');
open my $fh, ">$ARGV[0]" or die $!;
print $fh "foo\n";
END

d71 5
a75 10
test_makefile_types(
    requires => {
        'perl' => $],
        'File::Spec' => 0,
        'Test::More' => 0,
    },
    PL_files => {
        'foo.PL' => 'foo',
    },
);
d98 1
a98 2

  my $maketext = eval { Module::Build::Compat->fake_makefile(makefile => $makefile) };
d113 2
a114 1
    create_makefile_pl($style, $foo_builder);
d131 2
a132 1
    create_makefile_pl($style, $bar_builder);
d143 1
a143 1
  create_makefile_pl('passthrough', $mb);
d145 1
a145 1
  my $libdir = File::Spec->catdir( $tmp, 'libdir' );
d174 1
a174 12
  my $make_macro = 'TEST_VERBOSE=0';

  # VMS MMK/MMS macros use different syntax.
  if ($is_vms_mms) {
    $make_macro = '/macro=("' . $make_macro . '")';
  }

  $output = stdout_of( sub {
    local $ENV{HARNESS_TIMER}; # RT#39635 - timer messes with output
    $ran_ok = $mb->do_system(@@make, 'test', $make_macro)
  } );

d177 2
a178 24
  like $output,
       qr/# .+basic(\.t)?[.\s#]+ok[.\s#]+All tests successful/,
       'Should be non-verbose';

  (my $libdir2 = $libdir) =~ s/libdir/lbiidr/;
  my $libarch2 = File::Spec->catdir($libdir2, 'arch');

  SKIP: {
    require ExtUtils::Install;
    skip "Needs ExtUtils::Install 1.32 or later", 2
      if ExtUtils::Install->VERSION < 1.32;

    my @@make_args = ('INSTALLDIRS=vendor', "INSTALLVENDORLIB=$libdir2", "INSTALLVENDORARCH=$libarch2");

    if ($is_vms_mms) { # VMS MMK/MMS macros use different syntax.
      $make_args[0] = '/macro=("' . join('","',@@make_args) . '")';
      pop @@make_args while scalar(@@make_args) > 1;
    }

    ($output) = stdout_stderr_of(
      sub {
        $ran_ok = $mb->do_system(@@make, 'fakeinstall', @@make_args);
      }
    );
d180 2
a181 6
    ok $ran_ok, "make fakeinstall with INSTALLDIRS=vendor ran ok";
    $output =~ s/^/# /gm;  # Don't confuse our own test output
    like $output,
        qr/\Q$libdir2\E .* Simple\.pm/ix,
        'Should have installdirs=vendor';
  }
d184 1
a184 1
  ok ! -e $makefile, "$makefile shouldn't exist";
a187 2

  1 while unlink $libdir, $libdir2;
d195 1
a195 1
  create_makefile_pl('passthrough', $mb);
d205 1
a205 1
  ok ! -e $makefile, "$makefile shouldn't exist";
a210 22
{
  $dist->add_file('t/deep/foo.t', q{});
  $dist->regen;

  my $mb;
  stdout_of( sub {
      $mb = Module::Build->new_from_context( recursive_test_files => 1 );
  });

  create_makefile_pl('traditional', $mb);
  my $args = extract_writemakefile_args() || {};
  is $args->{TESTS}, 
    join( q{ }, 
      File::Spec->catfile(qw(t *.t)),
      File::Spec->catfile(qw(t deep *.t))
    ),
    'Makefile.PL has correct TESTS line for recursive test files';
}

# cleanup
$dist->remove;

a215 1
  $opts{PL_files} ||= {};
d226 2
a227 2
    create_makefile_pl($type, $mb);

a230 1
    test_makefile_pl_files( $opts{PL_files} ) if $type eq 'traditional';
a238 4
    for my $file (values %{ $opts{PL_files} }) {
        ok -e $file, "PL_files generated - $file";
    }

d252 1
a252 1
    test_makefile_creation($mb, [], 'INSTALLDIRS=vendor', 'realclean');
a253 3
    # Try again using distclean
    test_makefile_creation($mb, [], '', 'distclean');

d272 1
a272 1
  ok -e $makefile, "$makefile exists";
d275 2
a276 4
    # default to 'realclean' unless we recognize the clean method
    $cleanup = 'realclean' unless $cleanup =~ /^(dist|real)clean$/;
    my ($stdout, $stderr ) = stdout_stderr_of (sub {
      $build->do_system(@@make, $cleanup);
d278 1
a278 1
    ok ! -e $makefile, "$makefile cleaned up with $cleanup";
d289 2
a290 2
    skip "$makefile not found", 1 unless -e $makefile;
    my $prereq_pm = find_params_in_makefile()->{PREREQ_PM} || {};
d292 1
a292 12
      "$makefile has correct PREREQ_PM line";
  }
}

sub test_makefile_pl_files {
  my $expected = shift;

  SKIP: {
    skip 1, 'Makefile.PL not found' unless -e 'Makefile.PL';
    my $args = extract_writemakefile_args() || {};
    is_deeply $args->{PL_FILES}, $expected,
      "Makefile.PL has correct PL_FILES line";
d299 1
a299 1
    skip 1, 'Makefile.PL not found' unless -e 'Makefile.PL';
d312 6
a317 3
sub find_params_in_makefile {
  my $fh = IO::File->new( $makefile, 'r' ) 
    or die "Can't read $makefile: $!";
a318 2

  my %params;
d320 6
a325 4
    # Blank line after params.
    last if keys %params and !/\S+/;

    next unless m{^\# \s+ ( [A-Z_]+ ) \s+ => \s+ ( .* )$}x;
d327 2
a328 3
    my($key, $val) = ($1, $2);
    # extract keys and values
    while ( $val =~ m/(?:\s)(\S+)=>(q\[.*?\]|undef),?/g ) {
d333 1
a333 1
      $params{$key}{$m} = $n;
d335 1
d337 1
a337 2

  return \%params;
d340 3
a342 22
sub extract_writemakefile_args {
  SKIP: {
    skip 1, 'Makefile.PL not found' unless -e 'Makefile.PL';
    my $file_contents = slurp 'Makefile.PL';
    my ($args) = $file_contents =~ m{^WriteMakefile\n\((.*)\).*;}ms;
    ok $args, "Found WriteMakefile arguments"
        or diag "Makefile.PL:\n$file_contents";
    my %args = eval $args or diag $args; ## no critic
    return \%args;
  }
}

sub create_makefile_pl {
    Module::Build::Compat->create_makefile_pl(@@_);
    my $ok = ok -e 'Makefile.PL', "$_[0] Makefile.PL created";

    # Some really conservative make's, like HP/UX, assume files with the same
    # timestamp are out of date.  Send the Makefile.PL one second into the past
    # so its older than the Makefile it will generate.
    # See [rt.cpan.org 45700]
    my $mtime = (stat("Makefile.PL"))[9];
    utime $mtime, $mtime - 1, "Makefile.PL";
d344 2
a345 2
    return $ok;
}
@

