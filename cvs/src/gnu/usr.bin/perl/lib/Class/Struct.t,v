head	1.1;
branch	1.1.1;
access;
symbols
	PERL_5_24_2:1.1.1.3
	OPENBSD_6_1:1.1.1.3.0.14
	OPENBSD_6_1_BASE:1.1.1.3
	OPENBSD_6_0:1.1.1.3.0.12
	OPENBSD_6_0_BASE:1.1.1.3
	OPENBSD_5_9:1.1.1.3.0.6
	OPENBSD_5_9_BASE:1.1.1.3
	OPENBSD_5_8:1.1.1.3.0.8
	OPENBSD_5_8_BASE:1.1.1.3
	PERL_5_20_2:1.1.1.3
	OPENBSD_5_7:1.1.1.3.0.2
	OPENBSD_5_7_BASE:1.1.1.3
	PERL_5_20_1:1.1.1.3
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.44
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.40
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.38
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.36
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.34
	OPENBSD_5_0:1.1.1.2.0.32
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.30
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.28
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.24
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.26
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.22
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.20
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.01;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl -w

BEGIN {
	chdir 't' if -d 't';
	@@INC = '../lib';
}

print "1..12\n";

package aClass;

sub new { bless {}, shift }

sub meth { 42 }

package RecClass;

sub new { bless {}, shift }

package MyObj;

use Class::Struct;
use Class::Struct 'struct'; # test out both forms

use Class::Struct SomeClass => { SomeElem => '$' };

struct( s => '$', a => '@@', h => '%', c => 'aClass' );

my $obj = MyObj->new;

$obj->s('foo');

print "not " unless $obj->s() eq 'foo';
print "ok 1\n";

my $arf = $obj->a;

print "not " unless ref $arf eq 'ARRAY';
print "ok 2\n";

$obj->a(2, 'secundus');

print "not " unless $obj->a(2) eq 'secundus';
print "ok 3\n";

my $hrf = $obj->h;

print "not " unless ref $hrf eq 'HASH';
print "ok 4\n";

$obj->h('x', 10);

print "not " unless $obj->h('x') == 10;
print "ok 5\n";

my $orf = $obj->c;

print "not " if defined($orf);
print "ok 6\n";

$obj = MyObj->new( c => aClass->new );
$orf = $obj->c;

print "not " if ref $orf ne 'aClass';
print "ok 7\n";

print "not " unless $obj->c->meth() == 42;
print "ok 8\n";

my $obk = SomeClass->new();

$obk->SomeElem(123);

print "not " unless $obk->SomeElem() == 123;
print "ok 9\n";

$obj->a([4,5,6]);

print "not " unless $obj->a(1) == 5;
print "ok 10\n";

$obj->h({h=>7,r=>8,f=>9});

print "not " unless $obj->h('r') == 8;
print "ok 11\n";

my $recobj = RecClass->new() or print "not ";
print "ok 12\n";

@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d8 2
a9 3
#
# A couple of simple classes to use as struct elements.
#
d11 1
d13 1
d17 1
a19 3
#
# The first of our Class::Struct based objects.
#
d21 1
d24 1
d29 3
a31 11
#
# The second Class::Struct objects:
# test the 'compile-time without package name' feature.
#
package MyOther;
use Class::Struct s => '$', a => '@@', h => '%', c => 'aClass';

#
# back to main...
#
package main;
d33 2
a34 1
use Test::More tests => 24;
d36 1
a36 2
my $obj = MyObj->new;
isa_ok $obj, 'MyObj';
d38 2
a39 2
$obj->s('foo');
is $obj->s(), 'foo';
a40 1
isa_ok $obj->a, 'ARRAY';
a41 1
is $obj->a(2), 'secundus';
d43 7
a49 2
$obj->a([4,5,6]);
is $obj->a(1), 5;
a50 1
isa_ok $obj->h, 'HASH';
a51 1
is $obj->h('x'), 10;
d53 4
a56 2
$obj->h({h=>7,r=>8,f=>9});
is $obj->h('r'), 8;
d58 2
a59 1
is $obj->c, undef;
d62 1
a62 2
isa_ok $obj->c, 'aClass';
is $obj->c->meth(), 42;
d64 2
d67 4
a70 2
$obj = MyOther->new;
isa_ok $obj, 'MyOther';
d72 1
a72 2
$obj->s('foo');
is $obj->s(), 'foo';
d74 2
a75 3
isa_ok $obj->a, 'ARRAY';
$obj->a(2, 'secundus');
is $obj->a(2), 'secundus';
a77 1
is $obj->a(1), 5;
d79 2
a80 3
isa_ok $obj->h, 'HASH';
$obj->h('x', 10);
is $obj->h('x'), 10;
a82 8
is $obj->h('r'), 8;

is $obj->c, undef;

$obj = MyOther->new( c => aClass->new );
isa_ok $obj->c, 'aClass';
is $obj->c->meth(), 42;

d84 2
d87 2
a88 6
my $obk = SomeClass->new();
$obk->SomeElem(123);
is $obk->SomeElem(), 123;

my $recobj = RecClass->new();
isa_ok $recobj, 'RecClass';
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a35 21
# test overriden accessors
#
package OverrideAccessor;
use Class::Struct;

{ 
 no warnings qw(Class::Struct);
 struct( 'OverrideAccessor', { count => '$' } );
}

sub count {
  my ($self,$count) = @@_;

  if ( @@_ >= 2 ) {
    $self->{'OverrideAccessor::count'} = $count + 9;
  }

  return $self->{'OverrideAccessor::count'};
}

#
d40 1
a40 1
use Test::More;
a103 130
my $override_obj = OverrideAccessor->new( count => 3 );
is $override_obj->count, 12;

$override_obj->count( 1 );
is $override_obj->count, 10;


use Class::Struct Kapow => { z_zwap => 'Regexp', sploosh => 'MyObj' };

is eval { main->new(); }, undef,
    'No new method injected into current package';

my $obj3 = Kapow->new();

isa_ok $obj3, 'Kapow';
is $obj3->z_zwap, undef, 'No z_zwap member by default';
is $obj3->sploosh, undef, 'No sploosh member by default';
$obj3->z_zwap(qr//);
isa_ok $obj3->z_zwap, 'Regexp', 'Can set z_zwap member';
$obj3->sploosh(MyObj->new(s => 'pie'));
isa_ok $obj3->sploosh, 'MyObj',
    'Can set sploosh member to object of correct class';
is $obj3->sploosh->s, 'pie', 'Can set sploosh member to correct object';

my $obj4 = Kapow->new( z_zwap => qr//, sploosh => MyObj->new(a => ['Good']) );

isa_ok $obj4, 'Kapow';
isa_ok $obj4->z_zwap, 'Regexp', 'Initialised z_zwap member';
isa_ok $obj4->sploosh, 'MyObj', 'Initialised sploosh member';
is_deeply $obj4->sploosh->a, ['Good'], 'with correct object';

my $obj5 = Kapow->new( sploosh => { h => {perl => 'rules'} } );

isa_ok $obj5, 'Kapow';
is $obj5->z_zwap, undef, 'No z_zwap member by default';
isa_ok $obj5->sploosh, 'MyObj', 'Initialised sploosh member from hash';
is_deeply $obj5->sploosh->h, { perl => 'rules'} , 'with correct object';

is eval {
    package MyObj;
    struct( s => '$', a => '@@', h => '%', c => 'aClass' );
}, undef, 'Calling struct a second time fails';

like $@@, qr/^function 'new' already defined in package MyObj/,
    'fails with the expected error';

is eval { MyObj->new( a => {} ) }, undef,
    'Using a hash where an array reference is expected';
like $@@, qr/^Initializer for a must be array reference/,
    'fails with the expected error';

is eval { MyObj->new( h => [] ) }, undef,
    'Using an array where a hash reference is expected';
like $@@, qr/^Initializer for h must be hash reference/,
    'fails with the expected error';

is eval { Kapow->new( sploosh => { h => [perl => 'rules'] } ); }, undef,
    'Using an array where a hash reference is expected in an initialiser list';
like $@@, qr/^Initializer for h must be hash reference/,
    'fails with the expected error';

is eval { Kapow->new( sploosh => [ h => {perl => 'rules'} ] ); }, undef,
    "Using an array for a member object's initialiser list";
like $@@, qr/^Initializer for sploosh must be hash or MyObj reference/,
    'fails with the expected error';

is eval {
    package Crraack;
    use Class::Struct 'struct';
    struct( 'pow' => '@@$%!' );
}, undef, 'Bad type fails';
like $@@, qr/^'\@@\$\%\!' is not a valid struct element type/,
    'with the expected error';

is eval {
    $obj3->sploosh(MyOther->new(s => 3.14));
}, undef, 'Setting member to the wrong class of object fails';
like $@@, qr/^sploosh argument is wrong class/,
    'with the expected error';
is $obj3->sploosh->s, 'pie', 'Object is unchanged';

is eval {
    $obj3->sploosh(MyObj->new(s => 3.14), 'plop');
}, undef, 'Too many arguments to setter fails';
like $@@, qr/^Too many args to sploosh/,
    'with the expected error';
is $obj3->sploosh->s, 'pie', 'Object is unchanged';

is eval {
    package Blurp;
    use Class::Struct 'struct';
    struct( Blurp => {}, 'Bonus!' );
}, undef, 'hash based class with extra argument fails';
like $@@, qr/\Astruct usage error.*\n.*\n/,
    'with the expected confession';

is eval {
    package Zamm;
    use Class::Struct 'struct';
    struct( Zamm => [], 'Bonus!' );
}, undef, 'array based class with extra argument fails';
like $@@, qr/\Astruct usage error.*\n.*\n/,
    'with the expected confession';

is eval {
    package Thwapp;
    use Class::Struct 'struct';
    struct( Thwapp => ['Bonus!'] );
}, undef, 'array based class with extra constructor argument fails';
like $@@, qr/\Astruct usage error.*\n.*\n/,
    'with the expected confession';

is eval {
    package Rakkk;
    use Class::Struct 'struct';
    struct( z_zwap => 'Regexp', sploosh => 'MyObj', 'Bonus' );
}, undef, 'default array based class with extra constructor argument fails';
like $@@, qr/\Astruct usage error.*\n.*\n/,
    'with the expected confession';

is eval {
    package Awk;
    use parent -norequire, 'Urkkk';
    use Class::Struct 'struct';
    struct( beer => 'foamy' );
}, undef, '@@ISA is not allowed';
like $@@, qr/^struct class cannot be a subclass \(\@@ISA not allowed\)/,
    'with the expected error';

done_testing;
@


