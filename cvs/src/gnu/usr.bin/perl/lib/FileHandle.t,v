head	1.1;
branch	1.1.1;
access;
symbols
	OPENBSD_6_2:1.1.1.4.0.8
	OPENBSD_6_2_BASE:1.1.1.4
	PERL_5_24_2:1.1.1.4
	OPENBSD_6_1:1.1.1.4.0.12
	OPENBSD_6_1_BASE:1.1.1.4
	OPENBSD_6_0:1.1.1.4.0.10
	OPENBSD_6_0_BASE:1.1.1.4
	OPENBSD_5_9:1.1.1.4.0.4
	OPENBSD_5_9_BASE:1.1.1.4
	OPENBSD_5_8:1.1.1.4.0.6
	OPENBSD_5_8_BASE:1.1.1.4
	PERL_5_20_2:1.1.1.4
	OPENBSD_5_7:1.1.1.4.0.2
	OPENBSD_5_7_BASE:1.1.1.4
	PERL_5_20_1:1.1.1.4
	OPENBSD_5_6:1.1.1.3.0.4
	OPENBSD_5_6_BASE:1.1.1.3
	PERL_5_18_2:1.1.1.3
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.2.0.44
	OPENBSD_5_5_BASE:1.1.1.2
	OPENBSD_5_4:1.1.1.2.0.40
	OPENBSD_5_4_BASE:1.1.1.2
	PERL_5_16_3:1.1.1.2
	OPENBSD_5_3:1.1.1.2.0.38
	OPENBSD_5_3_BASE:1.1.1.2
	OPENBSD_5_2:1.1.1.2.0.36
	OPENBSD_5_2_BASE:1.1.1.2
	OPENBSD_5_1_BASE:1.1.1.2
	OPENBSD_5_1:1.1.1.2.0.34
	OPENBSD_5_0:1.1.1.2.0.32
	OPENBSD_5_0_BASE:1.1.1.2
	OPENBSD_4_9:1.1.1.2.0.30
	OPENBSD_4_9_BASE:1.1.1.2
	PERL_5_12_2:1.1.1.2
	OPENBSD_4_8:1.1.1.2.0.28
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.24
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.26
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.22
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.2.0.20
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2014.11.17.20.53.07;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.1
log
@Initial revision
@
text
@#!./perl

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    require Config; import Config;
    if ($Config{'extensions'} !~ /\bIO\b/ && $^O ne 'VMS') {
	print "1..0\n";
	exit 0;
    }
    if ($^O eq 'mpeix') {
	print "1..0 # Skip: broken on MPE/iX\n";
	exit 0;
    }
}

use FileHandle;
use strict subs;

autoflush STDOUT 1;

$mystdout = new_from_fd FileHandle 1,"w";
$| = 1;
autoflush $mystdout;
print "1..11\n";

print $mystdout "ok ".fileno($mystdout)."\n";

$fh = (new FileHandle "./TEST", O_RDONLY
       or new FileHandle "TEST", O_RDONLY)
  and print "ok 2\n";


$buffer = <$fh>;
print $buffer eq "#!./perl\n" ? "ok 3\n" : "not ok 3\n";


ungetc $fh ord 'A';
CORE::read($fh, $buf,1);
print $buf eq 'A' ? "ok 4\n" : "not ok 4\n";

close $fh;

$fh = new FileHandle;

print "not " unless ($fh->open("< TEST") && <$fh> eq $buffer);
print "ok 5\n";

$fh->seek(0,0);
print "#possible mixed CRLF/LF in t/TEST\nnot " unless (<$fh> eq $buffer);
print "ok 6\n";

$fh->seek(0,2);
$line = <$fh>;
print "not " if (defined($line) || !$fh->eof);
print "ok 7\n";

print "not " unless ($fh->open("TEST","r") && !$fh->tell && $fh->close);
print "ok 8\n";

autoflush STDOUT 0;

print "not " if ($|);
print "ok 9\n";

autoflush STDOUT 1;

print "not " unless ($|);
print "ok 10\n";

if ($^O eq 'dos')
{
    printf("ok %d\n",11);
    exit(0);
}

($rd,$wr) = FileHandle::pipe;

if ($^O eq 'VMS' || $^O eq 'os2' || $^O eq 'amigaos' || $^O eq 'MSWin32' || $^O eq 'NetWare' ||
    $Config{d_fork} ne 'define') {
  $wr->autoflush;
  $wr->printf("ok %d\n",11);
  print $rd->getline;
}
else {
  if (fork) {
   $wr->close;
   print $rd->getline;
  }
  else {
   $rd->close;
   $wr->printf("ok %d\n",11);
   exit(0);
  }
}
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d25 1
a25 1
print "1..12\n";
a95 2

print FileHandle->new('','r') ? "not ok 12\n" : "ok 12\n";
@


1.1.1.3
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d11 4
@


1.1.1.4
log
@Import perl-5.20.1
@
text
@a12 1
use strict;
d14 2
a16 2
use Test::More (tests => 12);
my $TB = Test::More->builder;
d18 1
a18 1
my $mystdout = new_from_fd FileHandle 1,"w";
d21 8
d30 2
a31 7
print $mystdout "ok ".fileno($mystdout),
    " - ", "create new handle from file descriptor", "\n";
$TB->current_test($TB->current_test + 1);

my $fh = (new FileHandle "./TEST", O_RDONLY
       or new FileHandle "TEST", O_RDONLY);
ok(defined($fh), "create new handle O_RDONLY");
a32 2
my $buffer = <$fh>;
is($buffer, "#!./perl\n", "Got expected first line via handle");
a34 1
my $buf;
d36 2
a37 1
is($buf, 'A', "Got expected ordinal value via ungetc in handle's input stream");
d41 3
a43 2
ok(($fh->open("< TEST") && <$fh> eq $buffer),
    "FileHandle open() method created handle, which got expected first line");
d46 2
a47 1
ok((<$fh> eq $buffer), "Averted possible mixed CRLF/LF in t/TEST");
d50 3
a52 2
my $line = <$fh>;
ok(! (defined($line) || !$fh->eof), "FileHandle seek() and eof() methods");
d54 2
a55 2
ok(($fh->open("TEST","r") && !$fh->tell && $fh->close),
    "FileHandle open(), tell() and close() methods");
d58 3
a60 1
ok(! $|, "handle not auto-flushing current output channel");
a62 4
ok($|, "handle auto-flushing current output channel");

SKIP: {
    skip "No fork or pipe on DOS", 1 if ($^O eq 'dos');
d64 2
a65 30
    my ($rd,$wr) = FileHandle::pipe;
    my $non_forking = (
        $^O eq 'VMS' || $^O eq 'os2' || $^O eq 'amigaos' ||
        $^O eq 'MSWin32' || $^O eq 'NetWare' || $Config{d_fork} ne 'define'
    );
    my $content = "Writing to one end of a pipe, reading from the other\n";
    if ($non_forking) {
        $wr->autoflush;
        $wr->print($content);
        is($rd->getline, $content,
            "Read content from pipe on non-forking platform");
    }
    else {
        my $child;
        if ($child = fork) {
            # parent
            $wr->close;
            is($rd->getline, $content,
                "Read content from pipe on forking platform");
        }
        elsif (defined $child) {
            # child
            $rd->close;
            $wr->print($content);
            exit(0);
        }
        else {
            die "fork failed: $!";
        }
    }
d67 25
a91 1
} # END: SKIP for dos
d93 1
a93 1
ok(!FileHandle->new('', 'r'), "Can't open empty filename");
@


