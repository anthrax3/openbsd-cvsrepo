head	1.3;
access;
symbols
	OPENBSD_4_8:1.2.0.4
	OPENBSD_4_8_BASE:1.2
	OPENBSD_4_7:1.2.0.2
	OPENBSD_4_7_BASE:1.2
	PERL_5_10_1:1.1.1.1
	CPAN:1.1.1
	OPENBSD_4_6:1.1.0.4
	OPENBSD_4_6_BASE:1.1;
locks; strict;
comment	@# @;


1.3
date	2010.09.24.14.59.52;	author millert;	state dead;
branches;
next	1.2;

1.2
date	2009.10.12.18.24.44;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2009.05.16.21.42.58;	author simon;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2009.10.12.18.10.56;	author millert;	state Exp;
branches;
next	;


desc
@@


1.3
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!perl -w

use strict;

BEGIN {
    if( $ENV{PERL_CORE} ) {
        chdir 't';
        @@INC = ('../lib', 'lib');
    }
    else {
        unshift @@INC, 't/lib';
    }
}
chdir 't';

use Test::Builder;

# The real Test::Builder
my $Test = Test::Builder->new;
$Test->plan( tests => 6 );


# The one we're going to test.
my $tb = Test::Builder->create();

my $tmpfile = 'foo.tmp';
END { 1 while unlink($tmpfile) }

# Test output to a file
{
    my $out = $tb->output($tmpfile);
    $Test->ok( defined $out );

    print $out "hi!\n";
    close *$out;

    undef $out;
    open(IN, $tmpfile) or die $!;
    chomp(my $line = <IN>);
    close IN;

    $Test->is_eq($line, 'hi!');
}


# Test output to a filehandle
{
    open(FOO, ">>$tmpfile") or die $!;
    my $out = $tb->output(\*FOO);
    my $old = select *$out;
    print "Hello!\n";
    close *$out;
    undef $out;
    select $old;
    open(IN, $tmpfile) or die $!;
    my @@lines = <IN>;
    close IN;

    $Test->like($lines[1], qr/Hello!/);
}


# Test output to a scalar ref
{
    my $scalar = '';
    my $out = $tb->output(\$scalar);

    print $out "Hey hey hey!\n";
    $Test->is_eq($scalar, "Hey hey hey!\n");
}


# Test we can output to the same scalar ref
{
    my $scalar = '';
    my $out = $tb->output(\$scalar);
    my $err = $tb->failure_output(\$scalar);

    print $out "To output ";
    print $err "and beyond!";

    $Test->is_eq($scalar, "To output and beyond!", "One scalar, two filehandles");
}


# Ensure stray newline in name escaping works.
{
    my $fakeout = '';
    my $out = $tb->output(\$fakeout);
    $tb->exported_to(__PACKAGE__);
    $tb->no_ending(1);
    $tb->plan(tests => 5);

    $tb->ok(1, "ok");
    $tb->ok(1, "ok\n");
    $tb->ok(1, "ok, like\nok");
    $tb->skip("wibble\nmoof");
    $tb->todo_skip("todo\nskip\n");

    $Test->is_eq( $fakeout, <<OUTPUT ) || print STDERR $fakeout;
1..5
ok 1 - ok
ok 2 - ok
# 
ok 3 - ok, like
# ok
ok 4 # skip wibble
# moof
not ok 5 # TODO & SKIP todo
# skip
# 
OUTPUT
}
@


1.2
log
@Merge in perl 5.10.1
@
text
@@


1.1
log
@relocate / fix Test::Simple tests

ok millert@@
@
text
@d2 2
a3 1
# $Id$
d16 5
a21 2
# Can't use Test.pm, that's a 5.005 thing.
print "1..4\n";
d23 2
a24 11
my $test_num = 1;
# Utility testing functions.
sub ok ($;$) {
    my($test, $name) = @@_;
    my $ok = '';
    $ok .= "not " unless $test;
    $ok .= "ok $test_num";
    $ok .= " - $name" if defined $name;
    $ok .= "\n";
    print $ok;
    $test_num++;
d26 17
a42 1
    return $test;
a44 3
use TieOut;
use Test::Builder;
my $Test = Test::Builder->new();
d46 21
a66 4
my $result;
my $tmpfile = 'foo.tmp';
my $out = $Test->output($tmpfile);
END { 1 while unlink($tmpfile) }
d68 3
a70 1
ok( defined $out );
a71 2
print $out "hi!\n";
close *$out;
d73 5
a77 17
undef $out;
open(IN, $tmpfile) or die $!;
chomp(my $line = <IN>);
close IN;

ok($line eq 'hi!');

open(FOO, ">>$tmpfile") or die $!;
$out = $Test->output(\*FOO);
$old = select *$out;
print "Hello!\n";
close *$out;
undef $out;
select $old;
open(IN, $tmpfile) or die $!;
my @@lines = <IN>;
close IN;
d79 2
a80 1
ok($lines[1] =~ /Hello!/);
d82 2
d87 12
a98 11
$out = tie *FAKEOUT, 'TieOut';
$Test->output(\*FAKEOUT);
$Test->exported_to(__PACKAGE__);
$Test->no_ending(1);
$Test->plan(tests => 5);

$Test->ok(1, "ok");
$Test->ok(1, "ok\n");
$Test->ok(1, "ok, like\nok");
$Test->skip("wibble\nmoof");
$Test->todo_skip("todo\nskip\n");
d100 1
a100 2
my $output = $out->read;
ok( $output eq <<OUTPUT ) || print STDERR $output;
d113 1
@


1.1.1.1
log
@import perl 5.10.1
@
text
@d2 1
a2 2

use strict;
a14 1
use Test::Builder;
d16 2
a17 3
# The real Test::Builder
my $Test = Test::Builder->new;
$Test->plan( tests => 6 );
d19 11
d31 6
a36 2
# The one we're going to test.
my $tb = Test::Builder->create();
d38 1
d40 1
d43 1
a43 15
# Test output to a file
{
    my $out = $tb->output($tmpfile);
    $Test->ok( defined $out );

    print $out "hi!\n";
    close *$out;

    undef $out;
    open(IN, $tmpfile) or die $!;
    chomp(my $line = <IN>);
    close IN;

    $Test->is_eq($line, 'hi!');
}
d45 2
d48 17
a64 12
# Test output to a filehandle
{
    open(FOO, ">>$tmpfile") or die $!;
    my $out = $tb->output(\*FOO);
    my $old = select *$out;
    print "Hello!\n";
    close *$out;
    undef $out;
    select $old;
    open(IN, $tmpfile) or die $!;
    my @@lines = <IN>;
    close IN;
d66 1
a66 2
    $Test->like($lines[1], qr/Hello!/);
}
a68 22
# Test output to a scalar ref
{
    my $scalar = '';
    my $out = $tb->output(\$scalar);

    print $out "Hey hey hey!\n";
    $Test->is_eq($scalar, "Hey hey hey!\n");
}


# Test we can output to the same scalar ref
{
    my $scalar = '';
    my $out = $tb->output(\$scalar);
    my $err = $tb->failure_output(\$scalar);

    print $out "To output ";
    print $err "and beyond!";

    $Test->is_eq($scalar, "To output and beyond!", "One scalar, two filehandles");
}

d71 11
a81 12
{
    my $fakeout = '';
    my $out = $tb->output(\$fakeout);
    $tb->exported_to(__PACKAGE__);
    $tb->no_ending(1);
    $tb->plan(tests => 5);

    $tb->ok(1, "ok");
    $tb->ok(1, "ok\n");
    $tb->ok(1, "ok, like\nok");
    $tb->skip("wibble\nmoof");
    $tb->todo_skip("todo\nskip\n");
d83 2
a84 1
    $Test->is_eq( $fakeout, <<OUTPUT ) || print STDERR $fakeout;
a96 1
}
@

