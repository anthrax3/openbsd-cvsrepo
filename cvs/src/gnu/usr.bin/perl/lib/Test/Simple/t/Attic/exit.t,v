head	1.4;
access;
symbols
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	PERL_5_10_1:1.1.1.4
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.3.0.12
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.4
date	2010.09.24.14.59.51;	author millert;	state dead;
branches;
next	1.3;

1.3
date	2009.10.12.18.24.43;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.16.21.42.57;	author simon;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.09;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.48.59;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2009.10.12.18.10.56;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!/usr/bin/perl -w

# Can't use Test.pm, that's a 5.005 thing.
package My::Test;

BEGIN {
    if( $ENV{PERL_CORE} ) {
        chdir 't';
        @@INC = '../lib';
    }
}

require Test::Builder;
my $TB = Test::Builder->create();
$TB->level(0);


package main;

use Cwd;
use File::Spec;

my $Orig_Dir = cwd;

my $Perl = File::Spec->rel2abs($^X);
if( $^O eq 'VMS' ) {
    # VMS can't use its own $^X in a system call until almost 5.8
    $Perl = "MCR $^X" if $] < 5.007003;

    # Quiet noisy 'SYS$ABORT'
    $Perl .= q{ -"I../lib"} if $ENV{PERL_CORE};
    $Perl .= q{ -"Mvmsish=hushed"};
}


eval { require POSIX; &POSIX::WEXITSTATUS(0) };
if( $@@ ) {
    *exitstatus = sub { $_[0] >> 8 };
}
else {
    *exitstatus = sub { POSIX::WEXITSTATUS($_[0]) }
}


# Some OS' will alter the exit code to their own native sense...
# sometimes.  Rather than deal with the exception we'll just
# build up the mapping.
print "# Building up a map of exit codes.  May take a while.\n";
my %Exit_Map;

open my $fh, ">", "exit_map_test" or die $!;
print $fh <<'DONE';
if ($^O eq 'VMS') {
    require vmsish;
    import vmsish qw(hushed);
}
my $exit = shift;
print "exit $exit\n";
END { $? = $exit };
DONE

close $fh;
END { 1 while unlink "exit_map_test" }

for my $exit (0..255) {
    # This correctly emulates Test::Builder's behavior.
    my $out = qx[$Perl exit_map_test $exit];
    $TB->like( $out, qr/^exit $exit\n/, "exit map test for $exit" );
    $Exit_Map{$exit} = exitstatus($?);
}
print "# Done.\n";


my %Tests = (
             # File                        Exit Code
             'success.plx'              => 0,
             'one_fail.plx'             => 1,
             'two_fail.plx'             => 2,
             'five_fail.plx'            => 5,
             'extras.plx'               => 2,
             'too_few.plx'              => 255,
             'too_few_fail.plx'         => 2,
             'death.plx'                => 255,
             'last_minute_death.plx'    => 255,
             'pre_plan_death.plx'       => 'not zero',
             'death_in_eval.plx'        => 0,
             'require.plx'              => 0,
             'death_with_handler.plx'   => 255,
             'exit.plx'                 => 1,
            );

chdir 't';
my $lib = File::Spec->catdir(qw(lib Test Simple sample_tests));
while( my($test_name, $exit_code) = each %Tests ) {
    my $file = File::Spec->catfile($lib, $test_name);
    my $wait_stat = system(qq{$Perl -"I../blib/lib" -"I../lib" -"I../t/lib" $file});
    my $actual_exit = exitstatus($wait_stat);

    if( $exit_code eq 'not zero' ) {
        $TB->isnt_num( $actual_exit, $Exit_Map{0},
                      "$test_name exited with $actual_exit ".
                      "(expected non-zero)");
    }
    else {
        $TB->is_num( $actual_exit, $Exit_Map{$exit_code}, 
                      "$test_name exited with $actual_exit ".
                      "(expected $Exit_Map{$exit_code})");
    }
}

$TB->done_testing( scalar keys(%Tests) + 256 );

# So any END block file cleanup works.
chdir $Orig_Dir;
@


1.3
log
@Merge in perl 5.10.1
@
text
@@


1.2
log
@relocate / fix Test::Simple tests

ok millert@@
@
text
@a1 1
# $Id$
a12 15
unless( eval { require File::Spec } ) {
    print "1..0 # Skip Need File::Spec to run this test\n";
    exit 0;
}

if( $^O eq 'VMS' && $] <= 5.00503 ) {
    print "1..0 # Skip test will hang on older VMS perls\n";
    exit 0;
}

if( $^O eq 'MacOS' ) {
    print "1..0 # Skip exit status broken on Mac OS\n";
    exit 0;
}

d20 2
a21 1
my $IsVMS = $^O eq 'VMS';
d23 1
a23 1
print "# Ahh!  I see you're running VMS.\n" if $IsVMS;
d25 9
a33 17
my %Tests = (
             #                      Everyone Else   VMS
             'success.plx'              => [0,      0],
             'one_fail.plx'             => [1,      4],
             'two_fail.plx'             => [2,      4],
             'five_fail.plx'            => [5,      4],
             'extras.plx'               => [2,      4],
             'too_few.plx'              => [255,    4],
             'too_few_fail.plx'         => [2,      4],
             'death.plx'                => [255,    4],
             'last_minute_death.plx'    => [255,    4],
             'pre_plan_death.plx'       => ['not zero',    'not zero'],
             'death_in_eval.plx'        => [0,      0],
             'require.plx'              => [0,      0],
             'death_with_handler.plx'   => [255,    4],
             'exit.plx'                 => [1,      4],
            );
a34 1
$TB->plan( tests => scalar keys(%Tests) );
d44 47
a90 1
my $Perl = File::Spec->rel2abs($^X);
d94 1
a94 12
while( my($test_name, $exit_codes) = each %Tests ) {
    my($exit_code) = $exit_codes->[$IsVMS ? 1 : 0];

    if( $^O eq 'VMS' ) {
        # VMS can't use its own $^X in a system call until almost 5.8
        $Perl = "MCR $^X" if $] < 5.007003;

        # Quiet noisy 'SYS$ABORT'.  'hushed' only exists in 5.6 and up,
        # but it doesn't do any harm on eariler perls.
        $Perl .= q{ -"Mvmsish=hushed"};
    }

d100 1
a100 1
        $TB->isnt_num( $actual_exit, 0,
d102 1
a102 1
                      "(expected $exit_code)");
d105 1
a105 1
        $TB->is_num( $actual_exit, $exit_code, 
d107 1
a107 1
                      "(expected $exit_code)");
d110 5
@


1.1
log
@Initial revision
@
text
@d1 3
d29 3
a31 12
my $test_num = 1;
# Utility testing functions.
sub ok ($;$) {
    my($test, $name) = @@_;
    my $ok = '';
    $ok .= "not " unless $test;
    $ok .= "ok $test_num";
    $ok .= " - $name" if defined $name;
    $ok .= "\n";
    print $ok;
    $test_num++;
}
d46 3
a48 2
             'extras.plx'               => [3,      4],
             'too_few.plx'              => [4,      4],
d51 1
d54 2
d58 1
a58 1
print "1..".keys(%Tests)."\n";
d68 2
a74 2
    my $Perl = $^X;

d88 10
a97 2
    My::Test::ok( $actual_exit == $exit_code, 
                  "$test_name exited with $actual_exit (expected $exit_code)");
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@a0 2
#!/usr/bin/perl -w

a55 1
             'pre_plan_death.plx'       => ['not zero',    'not zero'],
d90 2
a91 10
    if( $exit_code eq 'not zero' ) {
        My::Test::ok( $actual_exit != 0,
                      "$test_name exited with $actual_exit ".
                      "(expected $exit_code)");
    }
    else {
        My::Test::ok( $actual_exit == $exit_code, 
                      "$test_name exited with $actual_exit ".
                      "(expected $exit_code)");
    }
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d54 2
a55 3
             'extras.plx'               => [2,      4],
             'too_few.plx'              => [255,    4],
             'too_few_fail.plx'         => [2,      4],
a60 1
	     'exit.plx'                 => [1,      4],
@


1.1.1.4
log
@import perl 5.10.1
@
text
@d13 27
a39 3
require Test::Builder;
my $TB = Test::Builder->create();
$TB->level(0);
d44 1
a44 2
use Cwd;
use File::Spec;
d46 1
a46 1
my $Orig_Dir = cwd;
d48 16
a63 9
my $Perl = File::Spec->rel2abs($^X);
if( $^O eq 'VMS' ) {
    # VMS can't use its own $^X in a system call until almost 5.8
    $Perl = "MCR $^X" if $] < 5.007003;

    # Quiet noisy 'SYS$ABORT'
    $Perl .= q{ -"I../lib"} if $ENV{PERL_CORE};
    $Perl .= q{ -"Mvmsish=hushed"};
}
d65 1
d75 4
d80 1
a80 27
# Some OS' will alter the exit code to their own native sense...
# sometimes.  Rather than deal with the exception we'll just
# build up the mapping.
print "# Building up a map of exit codes.  May take a while.\n";
my %Exit_Map;

open my $fh, ">", "exit_map_test" or die $!;
print $fh <<'DONE';
if ($^O eq 'VMS') {
    require vmsish;
    import vmsish qw(hushed);
}
my $exit = shift;
print "exit $exit\n";
END { $? = $exit };
DONE

close $fh;
END { 1 while unlink "exit_map_test" }

for my $exit (0..255) {
    # This correctly emulates Test::Builder's behavior.
    my $out = qx[$Perl exit_map_test $exit];
    $TB->like( $out, qr/^exit $exit\n/, "exit map test for $exit" );
    $Exit_Map{$exit} = exitstatus($?);
}
print "# Done.\n";
d82 8
a90 21
my %Tests = (
             # File                        Exit Code
             'success.plx'              => 0,
             'one_fail.plx'             => 1,
             'two_fail.plx'             => 2,
             'five_fail.plx'            => 5,
             'extras.plx'               => 2,
             'too_few.plx'              => 255,
             'too_few_fail.plx'         => 2,
             'death.plx'                => 255,
             'last_minute_death.plx'    => 255,
             'pre_plan_death.plx'       => 'not zero',
             'death_in_eval.plx'        => 0,
             'require.plx'              => 0,
             'death_with_handler.plx'   => 255,
             'exit.plx'                 => 1,
            );

chdir 't';
my $lib = File::Spec->catdir(qw(lib Test Simple sample_tests));
while( my($test_name, $exit_code) = each %Tests ) {
d96 1
a96 1
        $TB->isnt_num( $actual_exit, $Exit_Map{0},
d98 1
a98 1
                      "(expected non-zero)");
d101 1
a101 1
        $TB->is_num( $actual_exit, $Exit_Map{$exit_code}, 
d103 1
a103 1
                      "(expected $Exit_Map{$exit_code})");
a105 5

$TB->done_testing( scalar keys(%Tests) + 256 );

# So any END block file cleanup works.
chdir $Orig_Dir;
@


