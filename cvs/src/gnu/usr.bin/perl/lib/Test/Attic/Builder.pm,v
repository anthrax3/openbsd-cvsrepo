head	1.4;
access;
symbols
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.2.0.4
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.4
date	2010.09.24.14.59.51;	author millert;	state dead;
branches;
next	1.3;

1.3
date	2009.10.12.18.24.42;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2009.05.13.17.10.14;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.09;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.48.58;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.42;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.56;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Test::Builder;

use 5.006;
use strict;
use warnings;

our $VERSION = '0.92';
$VERSION = eval $VERSION;    ## no critic (BuiltinFunctions::ProhibitStringyEval)

BEGIN {
    if( $] < 5.008 ) {
        require Test::Builder::IO::Scalar;
    }
}


# Make Test::Builder thread-safe for ithreads.
BEGIN {
    use Config;
    # Load threads::shared when threads are turned on.
    # 5.8.0's threads are so busted we no longer support them.
    if( $] >= 5.008001 && $Config{useithreads} && $INC{'threads.pm'} ) {
        require threads::shared;

        # Hack around YET ANOTHER threads::shared bug.  It would
        # occassionally forget the contents of the variable when sharing it.
        # So we first copy the data, then share, then put our copy back.
        *share = sub (\[$@@%]) {
            my $type = ref $_[0];
            my $data;

            if( $type eq 'HASH' ) {
                %$data = %{ $_[0] };
            }
            elsif( $type eq 'ARRAY' ) {
                @@$data = @@{ $_[0] };
            }
            elsif( $type eq 'SCALAR' ) {
                $$data = ${ $_[0] };
            }
            else {
                die( "Unknown type: " . $type );
            }

            $_[0] = &threads::shared::share( $_[0] );

            if( $type eq 'HASH' ) {
                %{ $_[0] } = %$data;
            }
            elsif( $type eq 'ARRAY' ) {
                @@{ $_[0] } = @@$data;
            }
            elsif( $type eq 'SCALAR' ) {
                ${ $_[0] } = $$data;
            }
            else {
                die( "Unknown type: " . $type );
            }

            return $_[0];
        };
    }
    # 5.8.0's threads::shared is busted when threads are off
    # and earlier Perls just don't have that module at all.
    else {
        *share = sub { return $_[0] };
        *lock  = sub { 0 };
    }
}

=head1 NAME

Test::Builder - Backend for building test libraries

=head1 SYNOPSIS

  package My::Test::Module;
  use base 'Test::Builder::Module';

  my $CLASS = __PACKAGE__;

  sub ok {
      my($test, $name) = @@_;
      my $tb = $CLASS->builder;

      $tb->ok($test, $name);
  }


=head1 DESCRIPTION

Test::Simple and Test::More have proven to be popular testing modules,
but they're not always flexible enough.  Test::Builder provides the a
building block upon which to write your own test libraries I<which can
work together>.

=head2 Construction

=over 4

=item B<new>

  my $Test = Test::Builder->new;

Returns a Test::Builder object representing the current state of the
test.

Since you only run one test per program C<new> always returns the same
Test::Builder object.  No matter how many times you call C<new()>, you're
getting the same object.  This is called a singleton.  This is done so that
multiple modules share such global information as the test counter and
where test output is going.

If you want a completely new Test::Builder object different from the
singleton, use C<create>.

=cut

my $Test = Test::Builder->new;

sub new {
    my($class) = shift;
    $Test ||= $class->create;
    return $Test;
}

=item B<create>

  my $Test = Test::Builder->create;

Ok, so there can be more than one Test::Builder object and this is how
you get it.  You might use this instead of C<new()> if you're testing
a Test::Builder based module, but otherwise you probably want C<new>.

B<NOTE>: the implementation is not complete.  C<level>, for example, is
still shared amongst B<all> Test::Builder objects, even ones created using
this method.  Also, the method name may change in the future.

=cut

sub create {
    my $class = shift;

    my $self = bless {}, $class;
    $self->reset;

    return $self;
}

=item B<reset>

  $Test->reset;

Reinitializes the Test::Builder singleton to its original state.
Mostly useful for tests run in persistent environments where the same
test might be run multiple times in the same process.

=cut

our $Level;

sub reset {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
    my($self) = @@_;

    # We leave this a global because it has to be localized and localizing
    # hash keys is just asking for pain.  Also, it was documented.
    $Level = 1;

    $self->{Have_Plan}    = 0;
    $self->{No_Plan}      = 0;
    $self->{Have_Output_Plan} = 0;

    $self->{Original_Pid} = $$;

    share( $self->{Curr_Test} );
    $self->{Curr_Test} = 0;
    $self->{Test_Results} = &share( [] );

    $self->{Exported_To}    = undef;
    $self->{Expected_Tests} = 0;

    $self->{Skip_All} = 0;

    $self->{Use_Nums} = 1;

    $self->{No_Header} = 0;
    $self->{No_Ending} = 0;

    $self->{Todo}       = undef;
    $self->{Todo_Stack} = [];
    $self->{Start_Todo} = 0;
    $self->{Opened_Testhandles} = 0;

    $self->_dup_stdhandles;

    return;
}

=back

=head2 Setting up tests

These methods are for setting up tests and declaring how many there
are.  You usually only want to call one of these methods.

=over 4

=item B<plan>

  $Test->plan('no_plan');
  $Test->plan( skip_all => $reason );
  $Test->plan( tests => $num_tests );

A convenient way to set up your tests.  Call this and Test::Builder
will print the appropriate headers and take the appropriate actions.

If you call C<plan()>, don't call any of the other methods below.

=cut

my %plan_cmds = (
    no_plan     => \&no_plan,
    skip_all    => \&skip_all,
    tests       => \&_plan_tests,
);

sub plan {
    my( $self, $cmd, $arg ) = @@_;

    return unless $cmd;

    local $Level = $Level + 1;

    $self->croak("You tried to plan twice") if $self->{Have_Plan};

    if( my $method = $plan_cmds{$cmd} ) {
        local $Level = $Level + 1;
        $self->$method($arg);
    }
    else {
        my @@args = grep { defined } ( $cmd, $arg );
        $self->croak("plan() doesn't understand @@args");
    }

    return 1;
}


sub _plan_tests {
    my($self, $arg) = @@_;

    if($arg) {
        local $Level = $Level + 1;
        return $self->expected_tests($arg);
    }
    elsif( !defined $arg ) {
        $self->croak("Got an undefined number of tests");
    }
    else {
        $self->croak("You said to run 0 tests");
    }

    return;
}


=item B<expected_tests>

    my $max = $Test->expected_tests;
    $Test->expected_tests($max);

Gets/sets the number of tests we expect this test to run and prints out
the appropriate headers.

=cut

sub expected_tests {
    my $self = shift;
    my($max) = @@_;

    if(@@_) {
        $self->croak("Number of tests must be a positive integer.  You gave it '$max'")
          unless $max =~ /^\+?\d+$/;

        $self->{Expected_Tests} = $max;
        $self->{Have_Plan}      = 1;

        $self->_output_plan($max) unless $self->no_header;
    }
    return $self->{Expected_Tests};
}

=item B<no_plan>

  $Test->no_plan;

Declares that this test will run an indeterminate number of tests.

=cut

sub no_plan {
    my($self, $arg) = @@_;

    $self->carp("no_plan takes no arguments") if $arg;

    $self->{No_Plan}   = 1;
    $self->{Have_Plan} = 1;

    return 1;
}


=begin private

=item B<_output_plan>

  $tb->_output_plan($max);
  $tb->_output_plan($max, $directive);
  $tb->_output_plan($max, $directive => $reason);

Handles displaying the test plan.

If a C<$directive> and/or C<$reason> are given they will be output with the
plan.  So here's what skipping all tests looks like:

    $tb->_output_plan(0, "SKIP", "Because I said so");

It sets C<< $tb->{Have_Output_Plan} >> and will croak if the plan was already
output.

=end private

=cut

sub _output_plan {
    my($self, $max, $directive, $reason) = @@_;

    $self->carp("The plan was already output") if $self->{Have_Output_Plan};

    my $plan = "1..$max";
    $plan .= " # $directive" if defined $directive;
    $plan .= " $reason"      if defined $reason;

    $self->_print("$plan\n");

    $self->{Have_Output_Plan} = 1;

    return;
}

=item B<done_testing>

  $Test->done_testing();
  $Test->done_testing($num_tests);

Declares that you are done testing, no more tests will be run after this point.

If a plan has not yet been output, it will do so.

$num_tests is the number of tests you planned to run.  If a numbered
plan was already declared, and if this contradicts, a failing test
will be run to reflect the planning mistake.  If C<no_plan> was declared,
this will override.

If C<done_testing()> is called twice, the second call will issue a
failing test.

If C<$num_tests> is omitted, the number of tests run will be used, like
no_plan.

C<done_testing()> is, in effect, used when you'd want to use C<no_plan>, but
safer. You'd use it like so:

    $Test->ok($a == $b);
    $Test->done_testing();

Or to plan a variable number of tests:

    for my $test (@@tests) {
        $Test->ok($test);
    }
    $Test->done_testing(@@tests);

=cut

sub done_testing {
    my($self, $num_tests) = @@_;

    # If done_testing() specified the number of tests, shut off no_plan.
    if( defined $num_tests ) {
        $self->{No_Plan} = 0;
    }
    else {
        $num_tests = $self->current_test;
    }

    if( $self->{Done_Testing} ) {
        my($file, $line) = @@{$self->{Done_Testing}}[1,2];
        $self->ok(0, "done_testing() was already called at $file line $line");
        return;
    }

    $self->{Done_Testing} = [caller];

    if( $self->expected_tests && $num_tests != $self->expected_tests ) {
        $self->ok(0, "planned to run @@{[ $self->expected_tests ]} ".
                     "but done_testing() expects $num_tests");
    }
    else {
        $self->{Expected_Tests} = $num_tests;
    }

    $self->_output_plan($num_tests) unless $self->{Have_Output_Plan};

    $self->{Have_Plan} = 1;

    return 1;
}


=item B<has_plan>

  $plan = $Test->has_plan

Find out whether a plan has been defined. C<$plan> is either C<undef> (no plan
has been set), C<no_plan> (indeterminate # of tests) or an integer (the number
of expected tests).

=cut

sub has_plan {
    my $self = shift;

    return( $self->{Expected_Tests} ) if $self->{Expected_Tests};
    return('no_plan') if $self->{No_Plan};
    return(undef);
}

=item B<skip_all>

  $Test->skip_all;
  $Test->skip_all($reason);

Skips all the tests, using the given C<$reason>.  Exits immediately with 0.

=cut

sub skip_all {
    my( $self, $reason ) = @@_;

    $self->{Skip_All} = 1;

    $self->_output_plan(0, "SKIP", $reason) unless $self->no_header;
    exit(0);
}

=item B<exported_to>

  my $pack = $Test->exported_to;
  $Test->exported_to($pack);

Tells Test::Builder what package you exported your functions to.

This method isn't terribly useful since modules which share the same
Test::Builder object might get exported to different packages and only
the last one will be honored.

=cut

sub exported_to {
    my( $self, $pack ) = @@_;

    if( defined $pack ) {
        $self->{Exported_To} = $pack;
    }
    return $self->{Exported_To};
}

=back

=head2 Running tests

These actually run the tests, analogous to the functions in Test::More.

They all return true if the test passed, false if the test failed.

C<$name> is always optional.

=over 4

=item B<ok>

  $Test->ok($test, $name);

Your basic test.  Pass if C<$test> is true, fail if $test is false.  Just
like Test::Simple's C<ok()>.

=cut

sub ok {
    my( $self, $test, $name ) = @@_;

    # $test might contain an object which we don't want to accidentally
    # store, so we turn it into a boolean.
    $test = $test ? 1 : 0;

    lock $self->{Curr_Test};
    $self->{Curr_Test}++;

    # In case $name is a string overloaded object, force it to stringify.
    $self->_unoverload_str( \$name );

    $self->diag(<<"ERR") if defined $name and $name =~ /^[\d\s]+$/;
    You named your test '$name'.  You shouldn't use numbers for your test names.
    Very confusing.
ERR

    # Capture the value of $TODO for the rest of this ok() call
    # so it can more easily be found by other routines.
    my $todo    = $self->todo();
    my $in_todo = $self->in_todo;
    local $self->{Todo} = $todo if $in_todo;

    $self->_unoverload_str( \$todo );

    my $out;
    my $result = &share( {} );

    unless($test) {
        $out .= "not ";
        @@$result{ 'ok', 'actual_ok' } = ( ( $self->in_todo ? 1 : 0 ), 0 );
    }
    else {
        @@$result{ 'ok', 'actual_ok' } = ( 1, $test );
    }

    $out .= "ok";
    $out .= " $self->{Curr_Test}" if $self->use_numbers;

    if( defined $name ) {
        $name =~ s|#|\\#|g;    # # in a name can confuse Test::Harness.
        $out .= " - $name";
        $result->{name} = $name;
    }
    else {
        $result->{name} = '';
    }

    if( $self->in_todo ) {
        $out .= " # TODO $todo";
        $result->{reason} = $todo;
        $result->{type}   = 'todo';
    }
    else {
        $result->{reason} = '';
        $result->{type}   = '';
    }

    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = $result;
    $out .= "\n";

    $self->_print($out);

    unless($test) {
        my $msg = $self->in_todo ? "Failed (TODO)" : "Failed";
        $self->_print_to_fh( $self->_diag_fh, "\n" ) if $ENV{HARNESS_ACTIVE};

        my( undef, $file, $line ) = $self->caller;
        if( defined $name ) {
            $self->diag(qq[  $msg test '$name'\n]);
            $self->diag(qq[  at $file line $line.\n]);
        }
        else {
            $self->diag(qq[  $msg test at $file line $line.\n]);
        }
    }

    return $test ? 1 : 0;
}

sub _unoverload {
    my $self = shift;
    my $type = shift;

    $self->_try(sub { require overload; }, die_on_fail => 1);

    foreach my $thing (@@_) {
        if( $self->_is_object($$thing) ) {
            if( my $string_meth = overload::Method( $$thing, $type ) ) {
                $$thing = $$thing->$string_meth();
            }
        }
    }

    return;
}

sub _is_object {
    my( $self, $thing ) = @@_;

    return $self->_try( sub { ref $thing && $thing->isa('UNIVERSAL') } ) ? 1 : 0;
}

sub _unoverload_str {
    my $self = shift;

    return $self->_unoverload( q[""], @@_ );
}

sub _unoverload_num {
    my $self = shift;

    $self->_unoverload( '0+', @@_ );

    for my $val (@@_) {
        next unless $self->_is_dualvar($$val);
        $$val = $$val + 0;
    }

    return;
}

# This is a hack to detect a dualvar such as $!
sub _is_dualvar {
    my( $self, $val ) = @@_;

    # Objects are not dualvars.
    return 0 if ref $val;

    no warnings 'numeric';
    my $numval = $val + 0;
    return $numval != 0 and $numval ne $val ? 1 : 0;
}

=item B<is_eq>

  $Test->is_eq($got, $expected, $name);

Like Test::More's C<is()>.  Checks if C<$got eq $expected>.  This is the
string version.

=item B<is_num>

  $Test->is_num($got, $expected, $name);

Like Test::More's C<is()>.  Checks if C<$got == $expected>.  This is the
numeric version.

=cut

sub is_eq {
    my( $self, $got, $expect, $name ) = @@_;
    local $Level = $Level + 1;

    $self->_unoverload_str( \$got, \$expect );

    if( !defined $got || !defined $expect ) {
        # undef only matches undef and nothing else
        my $test = !defined $got && !defined $expect;

        $self->ok( $test, $name );
        $self->_is_diag( $got, 'eq', $expect ) unless $test;
        return $test;
    }

    return $self->cmp_ok( $got, 'eq', $expect, $name );
}

sub is_num {
    my( $self, $got, $expect, $name ) = @@_;
    local $Level = $Level + 1;

    $self->_unoverload_num( \$got, \$expect );

    if( !defined $got || !defined $expect ) {
        # undef only matches undef and nothing else
        my $test = !defined $got && !defined $expect;

        $self->ok( $test, $name );
        $self->_is_diag( $got, '==', $expect ) unless $test;
        return $test;
    }

    return $self->cmp_ok( $got, '==', $expect, $name );
}

sub _diag_fmt {
    my( $self, $type, $val ) = @@_;

    if( defined $$val ) {
        if( $type eq 'eq' or $type eq 'ne' ) {
            # quote and force string context
            $$val = "'$$val'";
        }
        else {
            # force numeric context
            $self->_unoverload_num($val);
        }
    }
    else {
        $$val = 'undef';
    }

    return;
}

sub _is_diag {
    my( $self, $got, $type, $expect ) = @@_;

    $self->_diag_fmt( $type, $_ ) for \$got, \$expect;

    local $Level = $Level + 1;
    return $self->diag(<<"DIAGNOSTIC");
         got: $got
    expected: $expect
DIAGNOSTIC

}

sub _isnt_diag {
    my( $self, $got, $type ) = @@_;

    $self->_diag_fmt( $type, \$got );

    local $Level = $Level + 1;
    return $self->diag(<<"DIAGNOSTIC");
         got: $got
    expected: anything else
DIAGNOSTIC
}

=item B<isnt_eq>

  $Test->isnt_eq($got, $dont_expect, $name);

Like Test::More's C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
the string version.

=item B<isnt_num>

  $Test->isnt_num($got, $dont_expect, $name);

Like Test::More's C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
the numeric version.

=cut

sub isnt_eq {
    my( $self, $got, $dont_expect, $name ) = @@_;
    local $Level = $Level + 1;

    if( !defined $got || !defined $dont_expect ) {
        # undef only matches undef and nothing else
        my $test = defined $got || defined $dont_expect;

        $self->ok( $test, $name );
        $self->_isnt_diag( $got, 'ne' ) unless $test;
        return $test;
    }

    return $self->cmp_ok( $got, 'ne', $dont_expect, $name );
}

sub isnt_num {
    my( $self, $got, $dont_expect, $name ) = @@_;
    local $Level = $Level + 1;

    if( !defined $got || !defined $dont_expect ) {
        # undef only matches undef and nothing else
        my $test = defined $got || defined $dont_expect;

        $self->ok( $test, $name );
        $self->_isnt_diag( $got, '!=' ) unless $test;
        return $test;
    }

    return $self->cmp_ok( $got, '!=', $dont_expect, $name );
}

=item B<like>

  $Test->like($this, qr/$regex/, $name);
  $Test->like($this, '/$regex/', $name);

Like Test::More's C<like()>.  Checks if $this matches the given C<$regex>.

You'll want to avoid C<qr//> if you want your tests to work before 5.005.

=item B<unlike>

  $Test->unlike($this, qr/$regex/, $name);
  $Test->unlike($this, '/$regex/', $name);

Like Test::More's C<unlike()>.  Checks if $this B<does not match> the
given C<$regex>.

=cut

sub like {
    my( $self, $this, $regex, $name ) = @@_;

    local $Level = $Level + 1;
    return $self->_regex_ok( $this, $regex, '=~', $name );
}

sub unlike {
    my( $self, $this, $regex, $name ) = @@_;

    local $Level = $Level + 1;
    return $self->_regex_ok( $this, $regex, '!~', $name );
}

=item B<cmp_ok>

  $Test->cmp_ok($this, $type, $that, $name);

Works just like Test::More's C<cmp_ok()>.

    $Test->cmp_ok($big_num, '!=', $other_big_num);

=cut

my %numeric_cmps = map { ( $_, 1 ) } ( "<", "<=", ">", ">=", "==", "!=", "<=>" );

sub cmp_ok {
    my( $self, $got, $type, $expect, $name ) = @@_;

    my $test;
    my $error;
    {
        ## no critic (BuiltinFunctions::ProhibitStringyEval)

        local( $@@, $!, $SIG{__DIE__} );    # isolate eval

        my($pack, $file, $line) = $self->caller();

        $test = eval qq[
#line 1 "cmp_ok [from $file line $line]"
\$got $type \$expect;
];
        $error = $@@;
    }
    local $Level = $Level + 1;
    my $ok = $self->ok( $test, $name );

    # Treat overloaded objects as numbers if we're asked to do a
    # numeric comparison.
    my $unoverload
      = $numeric_cmps{$type}
      ? '_unoverload_num'
      : '_unoverload_str';

    $self->diag(<<"END") if $error;
An error occurred while using $type:
------------------------------------
$error
------------------------------------
END

    unless($ok) {
        $self->$unoverload( \$got, \$expect );

        if( $type =~ /^(eq|==)$/ ) {
            $self->_is_diag( $got, $type, $expect );
        }
        elsif( $type =~ /^(ne|!=)$/ ) {
            $self->_isnt_diag( $got, $type );
        }
        else {
            $self->_cmp_diag( $got, $type, $expect );
        }
    }
    return $ok;
}

sub _cmp_diag {
    my( $self, $got, $type, $expect ) = @@_;

    $got    = defined $got    ? "'$got'"    : 'undef';
    $expect = defined $expect ? "'$expect'" : 'undef';

    local $Level = $Level + 1;
    return $self->diag(<<"DIAGNOSTIC");
    $got
        $type
    $expect
DIAGNOSTIC
}

sub _caller_context {
    my $self = shift;

    my( $pack, $file, $line ) = $self->caller(1);

    my $code = '';
    $code .= "#line $line $file\n" if defined $file and defined $line;

    return $code;
}

=back


=head2 Other Testing Methods

These are methods which are used in the course of writing a test but are not themselves tests.

=over 4

=item B<BAIL_OUT>

    $Test->BAIL_OUT($reason);

Indicates to the Test::Harness that things are going so badly all
testing should terminate.  This includes running any additional test
scripts.

It will exit with 255.

=cut

sub BAIL_OUT {
    my( $self, $reason ) = @@_;

    $self->{Bailed_Out} = 1;
    $self->_print("Bail out!  $reason");
    exit 255;
}

=for deprecated
BAIL_OUT() used to be BAILOUT()

=cut

*BAILOUT = \&BAIL_OUT;

=item B<skip>

    $Test->skip;
    $Test->skip($why);

Skips the current test, reporting C<$why>.

=cut

sub skip {
    my( $self, $why ) = @@_;
    $why ||= '';
    $self->_unoverload_str( \$why );

    lock( $self->{Curr_Test} );
    $self->{Curr_Test}++;

    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
        {
            'ok'      => 1,
            actual_ok => 1,
            name      => '',
            type      => 'skip',
            reason    => $why,
        }
    );

    my $out = "ok";
    $out .= " $self->{Curr_Test}" if $self->use_numbers;
    $out .= " # skip";
    $out .= " $why"               if length $why;
    $out .= "\n";

    $self->_print($out);

    return 1;
}

=item B<todo_skip>

  $Test->todo_skip;
  $Test->todo_skip($why);

Like C<skip()>, only it will declare the test as failing and TODO.  Similar
to

    print "not ok $tnum # TODO $why\n";

=cut

sub todo_skip {
    my( $self, $why ) = @@_;
    $why ||= '';

    lock( $self->{Curr_Test} );
    $self->{Curr_Test}++;

    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
        {
            'ok'      => 1,
            actual_ok => 0,
            name      => '',
            type      => 'todo_skip',
            reason    => $why,
        }
    );

    my $out = "not ok";
    $out .= " $self->{Curr_Test}" if $self->use_numbers;
    $out .= " # TODO & SKIP $why\n";

    $self->_print($out);

    return 1;
}

=begin _unimplemented

=item B<skip_rest>

  $Test->skip_rest;
  $Test->skip_rest($reason);

Like C<skip()>, only it skips all the rest of the tests you plan to run
and terminates the test.

If you're running under C<no_plan>, it skips once and terminates the
test.

=end _unimplemented

=back


=head2 Test building utility methods

These methods are useful when writing your own test methods.

=over 4

=item B<maybe_regex>

  $Test->maybe_regex(qr/$regex/);
  $Test->maybe_regex('/$regex/');

Convenience method for building testing functions that take regular
expressions as arguments, but need to work before perl 5.005.

Takes a quoted regular expression produced by C<qr//>, or a string
representing a regular expression.

Returns a Perl value which may be used instead of the corresponding
regular expression, or C<undef> if its argument is not recognised.

For example, a version of C<like()>, sans the useful diagnostic messages,
could be written as:

  sub laconic_like {
      my ($self, $this, $regex, $name) = @@_;
      my $usable_regex = $self->maybe_regex($regex);
      die "expecting regex, found '$regex'\n"
          unless $usable_regex;
      $self->ok($this =~ m/$usable_regex/, $name);
  }

=cut

sub maybe_regex {
    my( $self, $regex ) = @@_;
    my $usable_regex = undef;

    return $usable_regex unless defined $regex;

    my( $re, $opts );

    # Check for qr/foo/
    if( _is_qr($regex) ) {
        $usable_regex = $regex;
    }
    # Check for '/foo/' or 'm,foo,'
    elsif(( $re, $opts )        = $regex =~ m{^ /(.*)/ (\w*) $ }sx              or
          ( undef, $re, $opts ) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
    )
    {
        $usable_regex = length $opts ? "(?$opts)$re" : $re;
    }

    return $usable_regex;
}

sub _is_qr {
    my $regex = shift;

    # is_regexp() checks for regexes in a robust manner, say if they're
    # blessed.
    return re::is_regexp($regex) if defined &re::is_regexp;
    return ref $regex eq 'Regexp';
}

sub _regex_ok {
    my( $self, $this, $regex, $cmp, $name ) = @@_;

    my $ok           = 0;
    my $usable_regex = $self->maybe_regex($regex);
    unless( defined $usable_regex ) {
        local $Level = $Level + 1;
        $ok = $self->ok( 0, $name );
        $self->diag("    '$regex' doesn't look much like a regex to me.");
        return $ok;
    }

    {
        ## no critic (BuiltinFunctions::ProhibitStringyEval)

        my $test;
        my $code = $self->_caller_context;

        local( $@@, $!, $SIG{__DIE__} );    # isolate eval

        # Yes, it has to look like this or 5.4.5 won't see the #line
        # directive.
        # Don't ask me, man, I just work here.
        $test = eval "
$code" . q{$test = $this =~ /$usable_regex/ ? 1 : 0};

        $test = !$test if $cmp eq '!~';

        local $Level = $Level + 1;
        $ok = $self->ok( $test, $name );
    }

    unless($ok) {
        $this = defined $this ? "'$this'" : 'undef';
        my $match = $cmp eq '=~' ? "doesn't match" : "matches";

        local $Level = $Level + 1;
        $self->diag( sprintf <<'DIAGNOSTIC', $this, $match, $regex );
                  %s
    %13s '%s'
DIAGNOSTIC

    }

    return $ok;
}

# I'm not ready to publish this.  It doesn't deal with array return
# values from the code or context.

=begin private

=item B<_try>

    my $return_from_code          = $Test->try(sub { code });
    my($return_from_code, $error) = $Test->try(sub { code });

Works like eval BLOCK except it ensures it has no effect on the rest
of the test (ie. C<$@@> is not set) nor is effected by outside
interference (ie. C<$SIG{__DIE__}>) and works around some quirks in older
Perls.

C<$error> is what would normally be in C<$@@>.

It is suggested you use this in place of eval BLOCK.

=cut

sub _try {
    my( $self, $code, %opts ) = @@_;

    my $error;
    my $return;
    {
        local $!;               # eval can mess up $!
        local $@@;               # don't set $@@ in the test
        local $SIG{__DIE__};    # don't trip an outside DIE handler.
        $return = eval { $code->() };
        $error = $@@;
    }

    die $error if $error and $opts{die_on_fail};

    return wantarray ? ( $return, $error ) : $return;
}

=end private


=item B<is_fh>

    my $is_fh = $Test->is_fh($thing);

Determines if the given C<$thing> can be used as a filehandle.

=cut

sub is_fh {
    my $self     = shift;
    my $maybe_fh = shift;
    return 0 unless defined $maybe_fh;

    return 1 if ref $maybe_fh  eq 'GLOB';    # its a glob ref
    return 1 if ref \$maybe_fh eq 'GLOB';    # its a glob

    return eval { $maybe_fh->isa("IO::Handle") } ||
           # 5.5.4's tied() and can() doesn't like getting undef
           eval { ( tied($maybe_fh) || '' )->can('TIEHANDLE') };
}

=back


=head2 Test style


=over 4

=item B<level>

    $Test->level($how_high);

How far up the call stack should C<$Test> look when reporting where the
test failed.

Defaults to 1.

Setting L<$Test::Builder::Level> overrides.  This is typically useful
localized:

    sub my_ok {
        my $test = shift;

        local $Test::Builder::Level = $Test::Builder::Level + 1;
        $TB->ok($test);
    }

To be polite to other functions wrapping your own you usually want to increment C<$Level> rather than set it to a constant.

=cut

sub level {
    my( $self, $level ) = @@_;

    if( defined $level ) {
        $Level = $level;
    }
    return $Level;
}

=item B<use_numbers>

    $Test->use_numbers($on_or_off);

Whether or not the test should output numbers.  That is, this if true:

  ok 1
  ok 2
  ok 3

or this if false

  ok
  ok
  ok

Most useful when you can't depend on the test output order, such as
when threads or forking is involved.

Defaults to on.

=cut

sub use_numbers {
    my( $self, $use_nums ) = @@_;

    if( defined $use_nums ) {
        $self->{Use_Nums} = $use_nums;
    }
    return $self->{Use_Nums};
}

=item B<no_diag>

    $Test->no_diag($no_diag);

If set true no diagnostics will be printed.  This includes calls to
C<diag()>.

=item B<no_ending>

    $Test->no_ending($no_ending);

Normally, Test::Builder does some extra diagnostics when the test
ends.  It also changes the exit code as described below.

If this is true, none of that will be done.

=item B<no_header>

    $Test->no_header($no_header);

If set to true, no "1..N" header will be printed.

=cut

foreach my $attribute (qw(No_Header No_Ending No_Diag)) {
    my $method = lc $attribute;

    my $code = sub {
        my( $self, $no ) = @@_;

        if( defined $no ) {
            $self->{$attribute} = $no;
        }
        return $self->{$attribute};
    };

    no strict 'refs';    ## no critic
    *{ __PACKAGE__ . '::' . $method } = $code;
}

=back

=head2 Output

Controlling where the test output goes.

It's ok for your test to change where STDOUT and STDERR point to,
Test::Builder's default output settings will not be affected.

=over 4

=item B<diag>

    $Test->diag(@@msgs);

Prints out the given C<@@msgs>.  Like C<print>, arguments are simply
appended together.

Normally, it uses the C<failure_output()> handle, but if this is for a
TODO test, the C<todo_output()> handle is used.

Output will be indented and marked with a # so as not to interfere
with test output.  A newline will be put on the end if there isn't one
already.

We encourage using this rather than calling print directly.

Returns false.  Why?  Because C<diag()> is often used in conjunction with
a failing test (C<ok() || diag()>) it "passes through" the failure.

    return ok(...) || diag(...);

=for blame transfer
Mark Fowler <mark@@twoshortplanks.com>

=cut

sub diag {
    my $self = shift;

    $self->_print_comment( $self->_diag_fh, @@_ );
}

=item B<note>

    $Test->note(@@msgs);

Like C<diag()>, but it prints to the C<output()> handle so it will not
normally be seen by the user except in verbose mode.

=cut

sub note {
    my $self = shift;

    $self->_print_comment( $self->output, @@_ );
}

sub _diag_fh {
    my $self = shift;

    local $Level = $Level + 1;
    return $self->in_todo ? $self->todo_output : $self->failure_output;
}

sub _print_comment {
    my( $self, $fh, @@msgs ) = @@_;

    return if $self->no_diag;
    return unless @@msgs;

    # Prevent printing headers when compiling (i.e. -c)
    return if $^C;

    # Smash args together like print does.
    # Convert undef to 'undef' so its readable.
    my $msg = join '', map { defined($_) ? $_ : 'undef' } @@msgs;

    # Escape the beginning, _print will take care of the rest.
    $msg =~ s/^/# /;

    local $Level = $Level + 1;
    $self->_print_to_fh( $fh, $msg );

    return 0;
}

=item B<explain>

    my @@dump = $Test->explain(@@msgs);

Will dump the contents of any references in a human readable format.
Handy for things like...

    is_deeply($have, $want) || diag explain $have;

or

    is_deeply($have, $want) || note explain $have;

=cut

sub explain {
    my $self = shift;

    return map {
        ref $_
          ? do {
            $self->_try(sub { require Data::Dumper }, die_on_fail => 1);

            my $dumper = Data::Dumper->new( [$_] );
            $dumper->Indent(1)->Terse(1);
            $dumper->Sortkeys(1) if $dumper->can("Sortkeys");
            $dumper->Dump;
          }
          : $_
    } @@_;
}

=begin _private

=item B<_print>

    $Test->_print(@@msgs);

Prints to the C<output()> filehandle.

=end _private

=cut

sub _print {
    my $self = shift;
    return $self->_print_to_fh( $self->output, @@_ );
}

sub _print_to_fh {
    my( $self, $fh, @@msgs ) = @@_;

    # Prevent printing headers when only compiling.  Mostly for when
    # tests are deparsed with B::Deparse
    return if $^C;

    my $msg = join '', @@msgs;

    local( $\, $", $, ) = ( undef, ' ', '' );

    # Escape each line after the first with a # so we don't
    # confuse Test::Harness.
    $msg =~ s{\n(?!\z)}{\n# }sg;

    # Stick a newline on the end if it needs it.
    $msg .= "\n" unless $msg =~ /\n\z/;

    return print $fh $msg;
}

=item B<output>

=item B<failure_output>

=item B<todo_output>

    my $filehandle = $Test->output;
    $Test->output($filehandle);
    $Test->output($filename);
    $Test->output(\$scalar);

These methods control where Test::Builder will print its output.
They take either an open C<$filehandle>, a C<$filename> to open and write to
or a C<$scalar> reference to append to.  It will always return a C<$filehandle>.

B<output> is where normal "ok/not ok" test output goes.

Defaults to STDOUT.

B<failure_output> is where diagnostic output on test failures and
C<diag()> goes.  It is normally not read by Test::Harness and instead is
displayed to the user.

Defaults to STDERR.

C<todo_output> is used instead of C<failure_output()> for the
diagnostics of a failing TODO test.  These will not be seen by the
user.

Defaults to STDOUT.

=cut

sub output {
    my( $self, $fh ) = @@_;

    if( defined $fh ) {
        $self->{Out_FH} = $self->_new_fh($fh);
    }
    return $self->{Out_FH};
}

sub failure_output {
    my( $self, $fh ) = @@_;

    if( defined $fh ) {
        $self->{Fail_FH} = $self->_new_fh($fh);
    }
    return $self->{Fail_FH};
}

sub todo_output {
    my( $self, $fh ) = @@_;

    if( defined $fh ) {
        $self->{Todo_FH} = $self->_new_fh($fh);
    }
    return $self->{Todo_FH};
}

sub _new_fh {
    my $self = shift;
    my($file_or_fh) = shift;

    my $fh;
    if( $self->is_fh($file_or_fh) ) {
        $fh = $file_or_fh;
    }
    elsif( ref $file_or_fh eq 'SCALAR' ) {
        # Scalar refs as filehandles was added in 5.8.
        if( $] >= 5.008 ) {
            open $fh, ">>", $file_or_fh
              or $self->croak("Can't open scalar ref $file_or_fh: $!");
        }
        # Emulate scalar ref filehandles with a tie.
        else {
            $fh = Test::Builder::IO::Scalar->new($file_or_fh)
              or $self->croak("Can't tie scalar ref $file_or_fh");
        }
    }
    else {
        open $fh, ">", $file_or_fh
          or $self->croak("Can't open test output log $file_or_fh: $!");
        _autoflush($fh);
    }

    return $fh;
}

sub _autoflush {
    my($fh) = shift;
    my $old_fh = select $fh;
    $| = 1;
    select $old_fh;

    return;
}

my( $Testout, $Testerr );

sub _dup_stdhandles {
    my $self = shift;

    $self->_open_testhandles;

    # Set everything to unbuffered else plain prints to STDOUT will
    # come out in the wrong order from our own prints.
    _autoflush($Testout);
    _autoflush( \*STDOUT );
    _autoflush($Testerr);
    _autoflush( \*STDERR );

    $self->reset_outputs;

    return;
}

sub _open_testhandles {
    my $self = shift;

    return if $self->{Opened_Testhandles};

    # We dup STDOUT and STDERR so people can change them in their
    # test suites while still getting normal test output.
    open( $Testout, ">&STDOUT" ) or die "Can't dup STDOUT:  $!";
    open( $Testerr, ">&STDERR" ) or die "Can't dup STDERR:  $!";

    #    $self->_copy_io_layers( \*STDOUT, $Testout );
    #    $self->_copy_io_layers( \*STDERR, $Testerr );

    $self->{Opened_Testhandles} = 1;

    return;
}

sub _copy_io_layers {
    my( $self, $src, $dst ) = @@_;

    $self->_try(
        sub {
            require PerlIO;
            my @@src_layers = PerlIO::get_layers($src);

            binmode $dst, join " ", map ":$_", @@src_layers if @@src_layers;
        }
    );

    return;
}

=item reset_outputs

  $tb->reset_outputs;

Resets all the output filehandles back to their defaults.

=cut

sub reset_outputs {
    my $self = shift;

    $self->output        ($Testout);
    $self->failure_output($Testerr);
    $self->todo_output   ($Testout);

    return;
}

=item carp

  $tb->carp(@@message);

Warns with C<@@message> but the message will appear to come from the
point where the original test function was called (C<< $tb->caller >>).

=item croak

  $tb->croak(@@message);

Dies with C<@@message> but the message will appear to come from the
point where the original test function was called (C<< $tb->caller >>).

=cut

sub _message_at_caller {
    my $self = shift;

    local $Level = $Level + 1;
    my( $pack, $file, $line ) = $self->caller;
    return join( "", @@_ ) . " at $file line $line.\n";
}

sub carp {
    my $self = shift;
    return warn $self->_message_at_caller(@@_);
}

sub croak {
    my $self = shift;
    return die $self->_message_at_caller(@@_);
}


=back


=head2 Test Status and Info

=over 4

=item B<current_test>

    my $curr_test = $Test->current_test;
    $Test->current_test($num);

Gets/sets the current test number we're on.  You usually shouldn't
have to set this.

If set forward, the details of the missing tests are filled in as 'unknown'.
if set backward, the details of the intervening tests are deleted.  You
can erase history if you really want to.

=cut

sub current_test {
    my( $self, $num ) = @@_;

    lock( $self->{Curr_Test} );
    if( defined $num ) {
        $self->{Curr_Test} = $num;

        # If the test counter is being pushed forward fill in the details.
        my $test_results = $self->{Test_Results};
        if( $num > @@$test_results ) {
            my $start = @@$test_results ? @@$test_results : 0;
            for( $start .. $num - 1 ) {
                $test_results->[$_] = &share(
                    {
                        'ok'      => 1,
                        actual_ok => undef,
                        reason    => 'incrementing test number',
                        type      => 'unknown',
                        name      => undef
                    }
                );
            }
        }
        # If backward, wipe history.  Its their funeral.
        elsif( $num < @@$test_results ) {
            $#{$test_results} = $num - 1;
        }
    }
    return $self->{Curr_Test};
}

=item B<summary>

    my @@tests = $Test->summary;

A simple summary of the tests so far.  True for pass, false for fail.
This is a logical pass/fail, so todos are passes.

Of course, test #1 is $tests[0], etc...

=cut

sub summary {
    my($self) = shift;

    return map { $_->{'ok'} } @@{ $self->{Test_Results} };
}

=item B<details>

    my @@tests = $Test->details;

Like C<summary()>, but with a lot more detail.

    $tests[$test_num - 1] = 
            { 'ok'       => is the test considered a pass?
              actual_ok  => did it literally say 'ok'?
              name       => name of the test (if any)
              type       => type of test (if any, see below).
              reason     => reason for the above (if any)
            };

'ok' is true if Test::Harness will consider the test to be a pass.

'actual_ok' is a reflection of whether or not the test literally
printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
tests.

'name' is the name of the test.

'type' indicates if it was a special test.  Normal tests have a type
of ''.  Type can be one of the following:

    skip        see skip()
    todo        see todo()
    todo_skip   see todo_skip()
    unknown     see below

Sometimes the Test::Builder test counter is incremented without it
printing any test output, for example, when C<current_test()> is changed.
In these cases, Test::Builder doesn't know the result of the test, so
its type is 'unknown'.  These details for these tests are filled in.
They are considered ok, but the name and actual_ok is left C<undef>.

For example "not ok 23 - hole count # TODO insufficient donuts" would
result in this structure:

    $tests[22] =    # 23 - 1, since arrays start from 0.
      { ok        => 1,   # logically, the test passed since its todo
        actual_ok => 0,   # in absolute terms, it failed
        name      => 'hole count',
        type      => 'todo',
        reason    => 'insufficient donuts'
      };

=cut

sub details {
    my $self = shift;
    return @@{ $self->{Test_Results} };
}

=item B<todo>

    my $todo_reason = $Test->todo;
    my $todo_reason = $Test->todo($pack);

If the current tests are considered "TODO" it will return the reason,
if any.  This reason can come from a C<$TODO> variable or the last call
to C<todo_start()>.

Since a TODO test does not need a reason, this function can return an
empty string even when inside a TODO block.  Use C<< $Test->in_todo >>
to determine if you are currently inside a TODO block.

C<todo()> is about finding the right package to look for C<$TODO> in.  It's
pretty good at guessing the right package to look at.  It first looks for
the caller based on C<$Level + 1>, since C<todo()> is usually called inside
a test function.  As a last resort it will use C<exported_to()>.

Sometimes there is some confusion about where todo() should be looking
for the C<$TODO> variable.  If you want to be sure, tell it explicitly
what $pack to use.

=cut

sub todo {
    my( $self, $pack ) = @@_;

    return $self->{Todo} if defined $self->{Todo};

    local $Level = $Level + 1;
    my $todo = $self->find_TODO($pack);
    return $todo if defined $todo;

    return '';
}

=item B<find_TODO>

    my $todo_reason = $Test->find_TODO();
    my $todo_reason = $Test->find_TODO($pack):

Like C<todo()> but only returns the value of C<$TODO> ignoring
C<todo_start()>.

=cut

sub find_TODO {
    my( $self, $pack ) = @@_;

    $pack = $pack || $self->caller(1) || $self->exported_to;
    return unless $pack;

    no strict 'refs';    ## no critic
    return ${ $pack . '::TODO' };
}

=item B<in_todo>

    my $in_todo = $Test->in_todo;

Returns true if the test is currently inside a TODO block.

=cut

sub in_todo {
    my $self = shift;

    local $Level = $Level + 1;
    return( defined $self->{Todo} || $self->find_TODO ) ? 1 : 0;
}

=item B<todo_start>

    $Test->todo_start();
    $Test->todo_start($message);

This method allows you declare all subsequent tests as TODO tests, up until
the C<todo_end> method has been called.

The C<TODO:> and C<$TODO> syntax is generally pretty good about figuring out
whether or not we're in a TODO test.  However, often we find that this is not
possible to determine (such as when we want to use C<$TODO> but
the tests are being executed in other packages which can't be inferred
beforehand).

Note that you can use this to nest "todo" tests

 $Test->todo_start('working on this');
 # lots of code
 $Test->todo_start('working on that');
 # more code
 $Test->todo_end;
 $Test->todo_end;

This is generally not recommended, but large testing systems often have weird
internal needs.

We've tried to make this also work with the TODO: syntax, but it's not
guaranteed and its use is also discouraged:

 TODO: {
     local $TODO = 'We have work to do!';
     $Test->todo_start('working on this');
     # lots of code
     $Test->todo_start('working on that');
     # more code
     $Test->todo_end;
     $Test->todo_end;
 }

Pick one style or another of "TODO" to be on the safe side.

=cut

sub todo_start {
    my $self = shift;
    my $message = @@_ ? shift : '';

    $self->{Start_Todo}++;
    if( $self->in_todo ) {
        push @@{ $self->{Todo_Stack} } => $self->todo;
    }
    $self->{Todo} = $message;

    return;
}

=item C<todo_end>

 $Test->todo_end;

Stops running tests as "TODO" tests.  This method is fatal if called without a
preceding C<todo_start> method call.

=cut

sub todo_end {
    my $self = shift;

    if( !$self->{Start_Todo} ) {
        $self->croak('todo_end() called without todo_start()');
    }

    $self->{Start_Todo}--;

    if( $self->{Start_Todo} && @@{ $self->{Todo_Stack} } ) {
        $self->{Todo} = pop @@{ $self->{Todo_Stack} };
    }
    else {
        delete $self->{Todo};
    }

    return;
}

=item B<caller>

    my $package = $Test->caller;
    my($pack, $file, $line) = $Test->caller;
    my($pack, $file, $line) = $Test->caller($height);

Like the normal C<caller()>, except it reports according to your C<level()>.

C<$height> will be added to the C<level()>.

If C<caller()> winds up off the top of the stack it report the highest context.

=cut

sub caller {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
    my( $self, $height ) = @@_;
    $height ||= 0;

    my $level = $self->level + $height + 1;
    my @@caller;
    do {
        @@caller = CORE::caller( $level );
        $level--;
    } until @@caller;
    return wantarray ? @@caller : $caller[0];
}

=back

=cut

=begin _private

=over 4

=item B<_sanity_check>

  $self->_sanity_check();

Runs a bunch of end of test sanity checks to make sure reality came
through ok.  If anything is wrong it will die with a fairly friendly
error message.

=cut

#'#
sub _sanity_check {
    my $self = shift;

    $self->_whoa( $self->{Curr_Test} < 0, 'Says here you ran a negative number of tests!' );
    $self->_whoa( $self->{Curr_Test} != @@{ $self->{Test_Results} },
        'Somehow you got a different number of results than tests ran!' );

    return;
}

=item B<_whoa>

  $self->_whoa($check, $description);

A sanity check, similar to C<assert()>.  If the C<$check> is true, something
has gone horribly wrong.  It will die with the given C<$description> and
a note to contact the author.

=cut

sub _whoa {
    my( $self, $check, $desc ) = @@_;
    if($check) {
        local $Level = $Level + 1;
        $self->croak(<<"WHOA");
WHOA!  $desc
This should never happen!  Please contact the author immediately!
WHOA
    }

    return;
}

=item B<_my_exit>

  _my_exit($exit_num);

Perl seems to have some trouble with exiting inside an C<END> block.  5.005_03
and 5.6.1 both seem to do odd things.  Instead, this function edits C<$?>
directly.  It should B<only> be called from inside an C<END> block.  It
doesn't actually exit, that's your job.

=cut

sub _my_exit {
    $? = $_[0];    ## no critic (Variables::RequireLocalizedPunctuationVars)

    return 1;
}

=back

=end _private

=cut

sub _ending {
    my $self = shift;

    my $real_exit_code = $?;

    # Don't bother with an ending if this is a forked copy.  Only the parent
    # should do the ending.
    if( $self->{Original_Pid} != $$ ) {
        return;
    }

    # Ran tests but never declared a plan or hit done_testing
    if( !$self->{Have_Plan} and $self->{Curr_Test} ) {
        $self->diag("Tests were run but no plan was declared and done_testing() was not seen.");
    }

    # Exit if plan() was never called.  This is so "require Test::Simple"
    # doesn't puke.
    if( !$self->{Have_Plan} ) {
        return;
    }

    # Don't do an ending if we bailed out.
    if( $self->{Bailed_Out} ) {
        return;
    }

    # Figure out if we passed or failed and print helpful messages.
    my $test_results = $self->{Test_Results};
    if(@@$test_results) {
        # The plan?  We have no plan.
        if( $self->{No_Plan} ) {
            $self->_output_plan($self->{Curr_Test}) unless $self->no_header;
            $self->{Expected_Tests} = $self->{Curr_Test};
        }

        # Auto-extended arrays and elements which aren't explicitly
        # filled in with a shared reference will puke under 5.8.0
        # ithreads.  So we have to fill them in by hand. :(
        my $empty_result = &share( {} );
        for my $idx ( 0 .. $self->{Expected_Tests} - 1 ) {
            $test_results->[$idx] = $empty_result
              unless defined $test_results->[$idx];
        }

        my $num_failed = grep !$_->{'ok'}, @@{$test_results}[ 0 .. $self->{Curr_Test} - 1 ];

        my $num_extra = $self->{Curr_Test} - $self->{Expected_Tests};

        if( $num_extra != 0 ) {
            my $s = $self->{Expected_Tests} == 1 ? '' : 's';
            $self->diag(<<"FAIL");
Looks like you planned $self->{Expected_Tests} test$s but ran $self->{Curr_Test}.
FAIL
        }

        if($num_failed) {
            my $num_tests = $self->{Curr_Test};
            my $s = $num_failed == 1 ? '' : 's';

            my $qualifier = $num_extra == 0 ? '' : ' run';

            $self->diag(<<"FAIL");
Looks like you failed $num_failed test$s of $num_tests$qualifier.
FAIL
        }

        if($real_exit_code) {
            $self->diag(<<"FAIL");
Looks like your test exited with $real_exit_code just after $self->{Curr_Test}.
FAIL

            _my_exit($real_exit_code) && return;
        }

        my $exit_code;
        if($num_failed) {
            $exit_code = $num_failed <= 254 ? $num_failed : 254;
        }
        elsif( $num_extra != 0 ) {
            $exit_code = 255;
        }
        else {
            $exit_code = 0;
        }

        _my_exit($exit_code) && return;
    }
    elsif( $self->{Skip_All} ) {
        _my_exit(0) && return;
    }
    elsif($real_exit_code) {
        $self->diag(<<"FAIL");
Looks like your test exited with $real_exit_code before it could output anything.
FAIL
        _my_exit($real_exit_code) && return;
    }
    else {
        $self->diag("No tests run!\n");
        _my_exit(255) && return;
    }

    $self->_whoa( 1, "We fell off the end of _ending()" );
}

END {
    $Test->_ending if defined $Test and !$Test->no_ending;
}

=head1 EXIT CODES

If all your tests passed, Test::Builder will exit with zero (which is
normal).  If anything failed it will exit with how many failed.  If
you run less (or more) tests than you planned, the missing (or extras)
will be considered failures.  If no tests were ever run Test::Builder
will throw a warning and exit with 255.  If the test died, even after
having successfully completed all its tests, it will still be
considered a failure and will exit with 255.

So the exit codes are...

    0                   all tests successful
    255                 test died or all passed but wrong # of tests run
    any other number    how many failed (including missing or extras)

If you fail more than 254 tests, it will be reported as 254.

=head1 THREADS

In perl 5.8.1 and later, Test::Builder is thread-safe.  The test
number is shared amongst all threads.  This means if one thread sets
the test number using C<current_test()> they will all be effected.

While versions earlier than 5.8.1 had threads they contain too many
bugs to support.

Test::Builder is only thread-aware if threads.pm is loaded I<before>
Test::Builder.

=head1 MEMORY

An informative hash, accessable via C<<details()>>, is stored for each
test you perform.  So memory usage will scale linearly with each test
run. Although this is not a problem for most test suites, it can
become an issue if you do large (hundred thousands to million)
combinatorics tests in the same run.

In such cases, you are advised to either split the test file into smaller
ones, or use a reverse approach, doing "normal" (code) compares and
triggering fail() should anything go unexpected.

Future versions of Test::Builder will have a way to turn history off.


=head1 EXAMPLES

CPAN can provide the best examples.  Test::Simple, Test::More,
Test::Exception and Test::Differences all use Test::Builder.

=head1 SEE ALSO

Test::Simple, Test::More, Test::Harness

=head1 AUTHORS

Original code by chromatic, maintained by Michael G Schwern
E<lt>schwern@@pobox.comE<gt>

=head1 COPYRIGHT

Copyright 2002-2008 by chromatic E<lt>chromatic@@wgz.orgE<gt> and
                       Michael G Schwern E<lt>schwern@@pobox.comE<gt>.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

See F<http://www.perl.com/perl/misc/Artistic.html>

=cut

1;

@


1.3
log
@Merge in perl 5.10.1
@
text
@@


1.2
log
@update Test::Simple to version 0.86

tested in multiple builds on multiple arches by me
ok millert@@, simon@@
@
text
@d7 1
a7 1
our $VERSION = '0.86';
d10 7
d109 1
a109 1
Test::Builder object.  No matter how many times you call new(), you're
d171 2
d192 1
d217 1
a217 1
If you call plan(), don't call any of the other methods below.
d221 6
d234 1
a234 2
    $self->croak("You tried to plan twice")
      if $self->{Have_Plan};
d236 3
a238 18
    if( $cmd eq 'no_plan' ) {
        $self->carp("no_plan takes no arguments") if $arg;
        $self->no_plan;
    }
    elsif( $cmd eq 'skip_all' ) {
        return $self->skip_all($arg);
    }
    elsif( $cmd eq 'tests' ) {
        if($arg) {
            local $Level = $Level + 1;
            return $self->expected_tests($arg);
        }
        elsif( !defined $arg ) {
            $self->croak("Got an undefined number of tests");
        }
        else {
            $self->croak("You said to run 0 tests");
        }
d248 19
d272 1
a272 1
Gets/sets the # of tests we expect this test to run and prints out
d288 1
a288 1
        $self->_print("1..$max\n") unless $self->no_header;
d297 1
a297 1
Declares that this test will run an indeterminate # of tests.
d302 3
a304 1
    my $self = shift;
d312 109
d425 3
a427 1
Find out whether a plan has been defined. $plan is either C<undef> (no plan has been set), C<no_plan> (indeterminate # of tests) or an integer (the number of expected tests).
d444 1
a444 1
Skips all the tests, using the given $reason.  Exits immediately with 0.
a450 4
    my $out = "1..0";
    $out .= " # Skip $reason" if $reason;
    $out .= "\n";

d453 1
a453 1
    $self->_print($out) unless $self->no_header;
d487 1
a487 1
$name is always optional.
d495 2
a496 2
Your basic test.  Pass if $test is true, fail if $test is false.  Just
like Test::Simple's ok().
a506 2
    $self->_plan_check;

d639 1
a639 1
Like Test::More's is().  Checks if $got eq $expected.  This is the
d646 1
a646 1
Like Test::More's is().  Checks if $got == $expected.  This is the
d736 1
a736 1
Like Test::More's isnt().  Checks if $got ne $dont_expect.  This is
d743 1
a743 1
Like Test::More's isnt().  Checks if $got ne $dont_expect.  This is
d785 1
a785 1
Like Test::More's like().  Checks if $this matches the given $regex.
d787 1
a787 1
You'll want to avoid qr// if you want your tests to work before 5.005.
d794 2
a795 2
Like Test::More's unlike().  Checks if $this B<does not match> the
given $regex.
d817 1
a817 1
Works just like Test::More's cmp_ok().
d942 1
a942 1
Skips the current test, reporting $why.
a950 2
    $self->_plan_check;

d980 1
a980 1
Like skip(), only it will declare the test as failing and TODO.  Similar
a990 2
    $self->_plan_check;

d1020 1
a1020 1
Like skip(), only it skips all the rest of the tests you plan to run
d1023 1
a1023 1
If you're running under no_plan, it skips once and terminates the
d1045 1
a1045 1
Takes a quoted regular expression produced by qr//, or a string
d1049 1
a1049 1
regular expression, or undef if its argument is not recognised.
d1051 1
a1051 1
For example, a version of like(), sans the useful diagnostic messages,
d1154 2
a1155 2
of the test (ie. $@@ is not set) nor is effected by outside
interference (ie. $SIG{__DIE__}) and works around some quirks in older
d1158 1
a1158 1
$error is what would normally be in $@@.
d1189 1
a1189 1
Determines if the given $thing can be used as a filehandle.
d1218 1
a1218 1
How far up the call stack should $Test look when reporting where the
d1283 1
a1283 1
diag().
d1333 1
a1333 1
Prints out the given @@msgs.  Like C<print>, arguments are simply
d1336 2
a1337 2
Normally, it uses the failure_output() handle, but if this is for a
TODO test, the todo_output() handle is used.
d1345 1
a1345 1
Returns false.  Why?  Because diag() is often used in conjunction with
d1365 1
a1365 1
Like diag(), but it prints to the C<output()> handle so it will not
d1443 1
a1443 1
Prints to the output() filehandle.
d1477 1
a1477 2
    $Test->output($fh);
    $Test->output($file);
d1479 1
a1479 1
Where normal "ok/not ok" test output should go.
d1481 8
a1488 1
Defaults to STDOUT.
d1490 1
a1490 1
=item B<failure_output>
d1492 1
a1492 2
    $Test->failure_output($fh);
    $Test->failure_output($file);
d1494 3
a1496 1
Where diagnostic output on test failures and diag() should go.
d1500 3
a1502 6
=item B<todo_output>

    $Test->todo_output($fh);
    $Test->todo_output($file);

Where diagnostics about todo test failures and diag() should go.
d1543 12
a1591 2
my $Opened_Testhandles = 0;

d1595 1
a1595 1
    return if $Opened_Testhandles;
d1605 1
a1605 1
    $Opened_Testhandles = 1;
d1648 1
a1648 1
point where the original test function was called (C<$tb->caller>).
d1655 1
a1655 1
point where the original test function was called (C<$tb->caller>).
a1676 10
sub _plan_check {
    my $self = shift;

    unless( $self->{Have_Plan} ) {
        local $Level = $Level + 2;
        $self->croak("You tried to run a test without a plan");
    }

    return;
}
a1703 3
        $self->croak("Can't change the current test number without a plan!")
          unless $self->{Have_Plan};

d1751 1
a1751 1
Like summary(), but with a lot more detail.
d1765 1
a1765 1
tests.  
d1778 1
a1778 1
printing any test output, for example, when current_test() is changed.
d1781 1
a1781 1
They are considered ok, but the name and actual_ok is left undef.
d1787 1
a1787 1
      { ok        => 1,   # logically, the test passed since it's todo
d1807 2
a1808 2
if any.  This reason can come from a $TODO variable or the last call
to C<<todo_start()>>.
d1811 1
a1811 1
empty string even when inside a TODO block.  Use C<<$Test->in_todo>>
d1814 1
a1814 1
todo() is about finding the right package to look for $TODO in.  It's
d1820 1
a1820 1
for the $TODO variable.  If you want to be sure, tell it explicitly
d1842 2
a1843 2
Like C<<todo()>> but only returns the value of C<<$TODO>> ignoring
C<<todo_start()>>.
d1962 1
a1962 1
Like the normal caller(), except it reports according to your level().
d1964 1
a1964 1
C<$height> will be added to the level().
d1966 1
a1966 1
If caller() winds up off the top of the stack it report the highest context.
a2005 2
    $self->_whoa( !$self->{Have_Plan} and $self->{Curr_Test},
        'Somehow your tests ran without a plan!' );
d2016 2
a2017 2
A sanity check, similar to assert().  If the $check is true, something
has gone horribly wrong.  It will die with the given $description and
d2039 3
a2041 3
Perl seems to have some trouble with exiting inside an END block.  5.005_03
and 5.6.1 both seem to do odd things.  Instead, this function edits $?
directly.  It should ONLY be called from inside an END block.  It
a2061 1
    $self->_sanity_check();
d2069 5
d2090 1
a2090 1
            $self->_print("1..$self->{Curr_Test}\n") unless $self->no_header;
a2184 1

d2189 1
a2189 1
the test number using current_test() they will all be effected.
d2197 15
d2231 1
a2231 1
This program is free software; you can redistribute it and/or 
@


1.1
log
@Initial revision
@
text
@d3 3
a5 5
use 5.004;

# $^C was only introduced in 5.005-ish.  We do this to prevent
# use of uninitialized value warnings in older perls.
$^C ||= 0;
d7 2
a8 13
use strict;
use vars qw($VERSION $CLASS);
$VERSION = '0.15';
$CLASS = __PACKAGE__;

my $IsVMS = $^O eq 'VMS';

use vars qw($Level);
my @@Test_Results = ();
my @@Test_Details = ();
my($Test_Died) = 0;
my($Have_Plan) = 0;
my $Curr_Test = 0;
d13 3
a15 2
    if( $] >= 5.008 && $Config{useithreads} ) {
        require threads;
d17 38
a54 4
        threads::shared->import;
        share(\$Curr_Test);
        share(\@@Test_Details);
        share(\@@Test_Results);
d56 2
d59 2
a60 1
        *lock = sub { 0 };
a63 1

d71 1
a71 14
  use Test::Builder;
  require Exporter;
  @@ISA = qw(Exporter);
  @@EXPORT = qw(ok);

  my $Test = Test::Builder->new;
  $Test->output('my_logfile');

  sub import {
      my($self) = shift;
      my $pack = caller;

      $Test->exported_to($pack);
      $Test->plan(@@_);
d73 1
a73 2
      $self->export_to_level(1, $self, 'ok');
  }
d77 1
d79 1
a79 1
      $Test->ok($test, $name);
d101 1
a101 1
Since you only run one test per program, there is B<one and only one>
d103 6
a108 1
getting the same object.  (This is called a singleton).
d112 2
a113 1
my $Test;
d116 1
a116 1
    $Test ||= bless ['Move along, nothing to see here'], $class;
d120 13
a132 1
=back
d134 2
a135 1
=head2 Setting up tests
d137 2
a138 2
These methods are for setting up tests and declaring how many there
are.  You usually only want to call one of these methods.
d140 2
a141 1
=over 4
d143 1
a143 1
=item B<exported_to>
d145 1
a145 2
  my $pack = $Test->exported_to;
  $Test->exported_to($pack);
d147 3
a149 2
Tells Test::Builder what package you exported your functions to.
This is important for getting TODO tests right.
d153 32
a184 3
my $Exported_To;
sub exported_to {
    my($self, $pack) = @@_;
d186 1
a186 4
    if( defined $pack ) {
        $Exported_To = $pack;
    }
    return $Exported_To;
d189 9
d212 1
a212 1
    my($self, $cmd, $arg) = @@_;
d216 4
a219 4
    if( $Have_Plan ) {
        die sprintf "You tried to plan twice!  Second plan at %s line %d\n",
          ($self->caller)[1,2];
    }
d222 1
d229 2
a230 1
        if( $arg ) {
d234 1
a234 2
            die "Got an undefined number of tests.  Looks like you tried to ".
                "say how many tests you plan to run but made a mistake.\n";
d236 2
a237 2
        elsif( !$arg ) {
            die "You said to run 0 tests!  You've got to run something.\n";
d241 2
a242 3
        require Carp;
        my @@args = grep { defined } ($cmd, $arg);
        Carp::croak("plan() doesn't understand @@args");
a257 1
my $Expected_Tests = 0;
d259 6
a264 1
    my($self, $max) = @@_;
d266 2
a267 3
    if( defined $max ) {
        $Expected_Tests = $max;
        $Have_Plan      = 1;
d271 1
a271 1
    return $Expected_Tests;
a273 1

a281 1
my($No_Plan) = 0;
d283 22
a304 2
    $No_Plan    = 1;
    $Have_Plan  = 1;
a315 1
my $Skip_All = 0;
d317 1
a317 1
    my($self, $reason) = @@_;
d323 1
a323 1
    $Skip_All = 1;
d329 22
d355 3
a357 2
These actually run the tests, analogous to the functions in
Test::More.
d373 5
a377 1
    my($self, $test, $name) = @@_;
d379 4
a382 4
    unless( $Have_Plan ) {
        require Carp;
        Carp::croak("You tried to run a test without a plan!  Gotta have a plan.");
    }
d384 2
a385 2
    lock $Curr_Test;
    $Curr_Test++;
d387 1
a387 1
    $self->diag(<<ERR) if defined $name and $name =~ /^[\d\s]+$/;
d392 5
a396 1
    my($pack, $file, $line) = $self->caller;
d398 1
a398 1
    my $todo = $self->todo($pack);
d401 3
a403 1
    unless( $test ) {
d405 1
a405 1
        $Test_Results[$Curr_Test-1] = $todo ? 1 : 0;
d408 1
a408 1
        $Test_Results[$Curr_Test-1] = 1;
d412 1
a412 1
    $out .= " $Curr_Test" if $self->use_numbers;
d415 6
a420 2
        $name =~ s|#|\\#|g;     # # in a name can confuse Test::Harness.
        $out   .= " - $name";
d423 8
a430 3
    if( $todo ) {
        my $what_todo = $todo;
        $out   .= " # TODO $what_todo";
d433 1
d438 13
a450 4
    unless( $test ) {
        my $msg = $todo ? "Failed (TODO)" : "Failed";
        $self->diag("    $msg test ($file at line $line)\n");
    } 
d455 54
d526 1
a526 1
    my($self, $got, $expect, $name) = @@_;
d529 2
d535 2
a536 2
        $self->ok($test, $name);
        $self->_is_diag($got, 'eq', $expect) unless $test;
d540 1
a540 1
    return $self->cmp_ok($got, 'eq', $expect, $name);
d544 1
a544 1
    my($self, $got, $expect, $name) = @@_;
d547 2
d553 2
a554 2
        $self->ok($test, $name);
        $self->_is_diag($got, '==', $expect) unless $test;
d558 1
a558 1
    return $self->cmp_ok($got, '==', $expect, $name);
d561 2
a562 2
sub _is_diag {
    my($self, $got, $type, $expect) = @@_;
d564 4
a567 10
    foreach my $val (\$got, \$expect) {
        if( defined $$val ) {
            if( $type eq 'eq' ) {
                # quote and force string context
                $$val = "'$$val'"
            }
            else {
                # force numeric context
                $$val = $$val+0;
            }
d570 2
a571 1
            $$val = 'undef';
d574 3
d578 12
a589 3
    return $self->diag(sprintf <<DIAGNOSTIC, $got, $expect);
         got: %s
    expected: %s
d592 13
a604 1
}    
d615 1
a615 1
  $Test->is_num($got, $dont_expect, $name);
d623 1
a623 1
    my($self, $got, $dont_expect, $name) = @@_;
d630 2
a631 2
        $self->ok($test, $name);
        $self->_cmp_diag('ne', $got, $dont_expect) unless $test;
d635 1
a635 1
    return $self->cmp_ok($got, 'ne', $dont_expect, $name);
d639 1
a639 1
    my($self, $got, $dont_expect, $name) = @@_;
d646 2
a647 2
        $self->ok($test, $name);
        $self->_cmp_diag('!=', $got, $dont_expect) unless $test;
d651 1
a651 1
    return $self->cmp_ok($got, '!=', $dont_expect, $name);
a653 1

d674 1
a674 1
    my($self, $this, $regex, $name) = @@_;
d677 1
a677 1
    $self->_regex_ok($this, $regex, '=~', $name);
d681 1
a681 1
    my($self, $this, $regex, $name) = @@_;
d684 1
a684 75
    $self->_regex_ok($this, $regex, '!~', $name);
}

=item B<maybe_regex>

  $Test->maybe_regex(qr/$regex/);
  $Test->maybe_regex('/$regex/');

Convenience method for building testing functions that take regular
expressions as arguments, but need to work before perl 5.005.

Takes a quoted regular expression produced by qr//, or a string
representing a regular expression.

Returns a Perl value which may be used instead of the corresponding
regular expression, or undef if it's argument is not recognised.

For example, a version of like(), sans the useful diagnostic messages,
could be written as:

  sub laconic_like {
      my ($self, $this, $regex, $name) = @@_;
      my $usable_regex = $self->maybe_regex($regex);
      die "expecting regex, found '$regex'\n"
          unless $usable_regex;
      $self->ok($this =~ m/$usable_regex/, $name);
  }

=cut


sub maybe_regex {
	my ($self, $regex) = @@_;
    my $usable_regex = undef;
    if( ref $regex eq 'Regexp' ) {
        $usable_regex = $regex;
    }
    # Check if it looks like '/foo/'
    elsif( my($re, $opts) = $regex =~ m{^ /(.*)/ (\w*) $ }sx ) {
        $usable_regex = length $opts ? "(?$opts)$re" : $re;
    };
    return($usable_regex)
};

sub _regex_ok {
    my($self, $this, $regex, $cmp, $name) = @@_;

    local $Level = $Level + 1;

    my $ok = 0;
    my $usable_regex = $self->maybe_regex($regex);
    unless (defined $usable_regex) {
        $ok = $self->ok( 0, $name );
        $self->diag("    '$regex' doesn't look much like a regex to me.");
        return $ok;
    }

    {
        local $^W = 0;
        my $test = $this =~ /$usable_regex/ ? 1 : 0;
        $test = !$test if $cmp eq '!~';
        $ok = $self->ok( $test, $name );
    }

    unless( $ok ) {
        $this = defined $this ? "'$this'" : 'undef';
        my $match = $cmp eq '=~' ? "doesn't match" : "matches";
        $self->diag(sprintf <<DIAGNOSTIC, $this, $match, $regex);
                  %s
    %13s '%s'
DIAGNOSTIC

    }

    return $ok;
d697 2
d700 1
a700 1
    my($self, $got, $type, $expect, $name) = @@_;
d703 1
d705 11
a715 4
        local $^W = 0;
        local($@@,$!);   # don't interfere with $@@
                        # eval() sometimes resets $!
        $test = eval "\$got $type \$expect";
d718 18
a735 1
    my $ok = $self->ok($test, $name);
a736 1
    unless( $ok ) {
d738 4
a741 1
            $self->_is_diag($got, $type, $expect);
d744 1
a744 1
            $self->_cmp_diag($got, $type, $expect);
d751 2
a752 2
    my($self, $got, $type, $expect) = @@_;
    
d755 6
a760 4
    return $self->diag(sprintf <<DIAGNOSTIC, $got, $type, $expect);
    %s
        %s
    %s
d764 13
a776 1
=item B<BAILOUT>
d778 9
a786 1
    $Test->BAILOUT($reason);
d796 2
a797 2
sub BAILOUT {
    my($self, $reason) = @@_;
d799 1
d804 7
d821 1
a821 1
    my($self, $why) = @@_;
d823 1
d825 1
a825 4
    unless( $Have_Plan ) {
        require Carp;
        Carp::croak("You tried to run tests without a plan!  Gotta have a plan.");
    }
d827 2
a828 2
    lock($Curr_Test);
    $Curr_Test++;
d830 9
a838 1
    $Test_Results[$Curr_Test-1] = 1;
d841 4
a844 2
    $out   .= " $Curr_Test" if $self->use_numbers;
    $out   .= " # skip $why\n";
d846 1
a846 1
    $Test->_print($out);
a850 1

d864 1
a864 1
    my($self, $why) = @@_;
d867 93
a959 3
    unless( $Have_Plan ) {
        require Carp;
        Carp::croak("You tried to run tests without a plan!  Gotta have a plan.");
d962 2
a963 2
    lock($Curr_Test);
    $Curr_Test++;
d965 2
a966 1
    $Test_Results[$Curr_Test-1] = 1;
d968 86
a1053 3
    my $out = "not ok";
    $out   .= " $Curr_Test" if $self->use_numbers;
    $out   .= " # TODO & SKIP $why\n";
d1055 1
a1055 1
    $Test->_print($out);
d1057 1
a1057 1
    return 1;
d1060 2
d1063 3
a1065 1
=begin _unimplemented
d1067 1
a1067 1
=item B<skip_rest>
d1069 1
a1069 2
  $Test->skip_rest;
  $Test->skip_rest($reason);
d1071 4
a1074 2
Like skip(), only it skips all the rest of the tests you plan to run
and terminates the test.
d1076 2
a1077 2
If you're running under no_plan, it skips once and terminates the
test.
d1079 4
a1082 1
=end _unimplemented
d1089 1
d1101 1
a1101 1
Setting $Test::Builder::Level overrides.  This is typically useful
d1104 5
a1108 3
    {
        local $Test::Builder::Level = 2;
        $Test->ok($test);
d1111 2
d1116 1
a1116 1
    my($self, $level) = @@_;
a1123 3
$CLASS->level(1);


a1142 2
Test::Harness will accept either, but avoid mixing the two styles.

a1146 1
my $Use_Nums = 1;
d1148 1
a1148 1
    my($self, $use_nums) = @@_;
d1151 1
a1151 1
        $Use_Nums = $use_nums;
d1153 1
a1153 1
    return $Use_Nums;
d1156 1
a1156 1
=item B<no_header>
d1158 1
a1158 1
    $Test->no_header($no_header);
d1160 2
a1161 1
If set to true, no "1..N" header will be printed.
d1168 1
a1168 1
ends.  It also changes the exit code as described in Test::Simple.
d1172 6
d1180 2
a1181 3
my($No_Header, $No_Ending) = (0,0);
sub no_header {
    my($self, $no_header) = @@_;
d1183 2
a1184 5
    if( defined $no_header ) {
        $No_Header = $no_header;
    }
    return $No_Header;
}
d1186 5
a1190 2
sub no_ending {
    my($self, $no_ending) = @@_;
d1192 2
a1193 4
    if( defined $no_ending ) {
        $No_Ending = $no_ending;
    }
    return $No_Ending;
a1195 1

d1211 5
a1215 3
Prints out the given $message.  Normally, it uses the failure_output()
handle, but if this is for a TODO test, the todo_output() handle is
used.
d1234 31
a1264 1
    my($self, @@msgs) = @@_;
d1270 3
a1272 5
    # Escape each line with a #.
    foreach (@@msgs) {
        $_ = 'undef' unless defined;
        s/^/# /gms;
    }
d1274 2
a1275 1
    push @@msgs, "\n" unless $msgs[-1] =~ /\n\Z/;
d1278 1
a1278 3
    my $fh = $self->todo ? $self->todo_output : $self->failure_output;
    local($\, $", $,) = (undef, ' ', '');
    print $fh @@msgs;
d1283 32
d1328 6
a1333 1
    my($self, @@msgs) = @@_;
d1339 3
a1341 2
    local($\, $", $,) = (undef, ' ', '');
    my $fh = $self->output;
d1345 1
a1345 3
    foreach (@@msgs) {
        s/\n(.)/\n# $1/sg;
    }
d1347 2
a1348 1
    push @@msgs, "\n" unless $msgs[-1] =~ /\n\Z/;
d1350 1
a1350 1
    print $fh @@msgs;
a1352 1

a1381 1
my($Out_FH, $Fail_FH, $Todo_FH);
d1383 1
a1383 1
    my($self, $fh) = @@_;
d1386 1
a1386 1
        $Out_FH = _new_fh($fh);
d1388 1
a1388 1
    return $Out_FH;
d1392 1
a1392 1
    my($self, $fh) = @@_;
d1395 1
a1395 1
        $Fail_FH = _new_fh($fh);
d1397 1
a1397 1
    return $Fail_FH;
d1401 1
a1401 1
    my($self, $fh) = @@_;
d1404 1
a1404 1
        $Todo_FH = _new_fh($fh);
d1406 1
a1406 1
    return $Todo_FH;
d1410 1
d1414 2
a1415 4
    unless( UNIVERSAL::isa($file_or_fh, 'GLOB') ) {
        $fh = do { local *FH };
        open $fh, ">$file_or_fh" or 
            die "Can't open test output log $file_or_fh: $!";
d1418 3
a1420 1
        $fh = $file_or_fh;
d1426 35
a1460 1
unless( $^C ) {
d1463 59
a1521 2
    open(TESTOUT, ">&STDOUT") or die "Can't dup STDOUT:  $!";
    open(TESTERR, ">&STDERR") or die "Can't dup STDERR:  $!";
d1523 11
a1533 10
    # Set everything to unbuffered else plain prints to STDOUT will
    # come out in the wrong order from our own prints.
    _autoflush(\*TESTOUT);
    _autoflush(\*STDOUT);
    _autoflush(\*TESTERR);
    _autoflush(\*STDERR);

    $CLASS->output(\*TESTOUT);
    $CLASS->failure_output(\*TESTERR);
    $CLASS->todo_output(\*TESTOUT);
d1536 3
a1538 5
sub _autoflush {
    my($fh) = shift;
    my $old_fh = select $fh;
    $| = 1;
    select $old_fh;
d1541 10
d1564 2
a1565 1
Gets/sets the current test # we're on.
d1567 3
a1569 1
You usually shouldn't have to set this.
d1574 1
a1574 1
    my($self, $num) = @@_;
d1576 1
a1576 1
    lock($Curr_Test);
d1578 4
a1581 4
        unless( $Have_Plan ) {
            require Carp;
            Carp::croak("Can't change the current test number without a plan!");
        }
d1583 14
a1596 5
        $Curr_Test = $num;
        if( $num > @@Test_Results ) {
            my $start = @@Test_Results ? $#Test_Results : 0;
            for ($start..$num-1) {
                $Test_Results[$_] = 1;
d1599 4
d1604 1
a1604 1
    return $Curr_Test;
a1606 1

d1621 1
a1621 1
    return @@Test_Results;
d1624 1
a1624 1
=item B<details>  I<UNIMPLEMENTED>
d1631 1
a1631 1
            { ok         => is the test considered ok?
d1634 1
a1634 1
              type       => 'skip' or 'todo' (if any)
d1638 40
d1683 12
a1694 8
todo() looks for a $TODO variable in your tests.  If set, all tests
will be considered 'todo' (see Test::More and Test::Harness for
details).  Returns the reason (ie. the value of $TODO) if running as
todo tests, false otherwise.

todo() is pretty part about finding the right package to look for
$TODO in.  It uses the exported_to() package to find it.  If that's
not set, it's pretty good at guessing the right package to look at.
d1703 59
a1761 1
    my($self, $pack) = @@_;
d1763 1
a1763 1
    $pack = $pack || $self->exported_to || $self->caller(1);
d1765 66
a1830 3
    no strict 'refs';
    return defined ${$pack.'::TODO'} ? ${$pack.'::TODO'}
                                     : 0;
d1841 4
d1847 2
a1848 2
sub caller {
    my($self, $height) = @@_;
d1851 6
a1856 1
    my @@caller = CORE::caller($self->level + $height + 1);
d1870 1
a1870 1
  _sanity_check();
d1880 9
a1888 5
    _whoa($Curr_Test < 0,  'Says here you ran a negative number of tests!');
    _whoa(!$Have_Plan and $Curr_Test, 
          'Somehow your tests ran without a plan!');
    _whoa($Curr_Test != @@Test_Results,
          'Somehow you got a different number of results than tests ran!');
d1893 1
a1893 1
  _whoa($check, $description);
d1902 4
a1905 3
    my($check, $desc) = @@_;
    if( $check ) {
        die <<WHOA;
d1910 2
d1926 1
a1926 1
    $? = $_[0];
a1930 1

a1936 12
$SIG{__DIE__} = sub {
    # We don't want to muck with death in an eval, but $^S isn't
    # totally reliable.  5.005_03 and 5.6.1 both do the wrong thing
    # with it.  Instead, we use caller.  This also means it runs under
    # 5.004!
    my $in_eval = 0;
    for( my $stack = 1;  my $sub = (CORE::caller($stack))[3];  $stack++ ) {
        $in_eval = 1 if $sub =~ /^\(eval\)/;
    }
    $Test_Died = 1 unless $in_eval;
};

d1940 14
a1953 1
    _sanity_check();
d1955 4
a1958 3
    # Bailout if plan() was never called.  This is so
    # "require Test::Simple" doesn't puke.
    do{ _my_exit(0) && return } if !$Have_Plan;
d1961 2
a1962 1
    if( @@Test_Results ) {
d1964 12
a1975 3
        if( $No_Plan ) {
            $self->_print("1..$Curr_Test\n") unless $self->no_header;
            $Expected_Tests = $Curr_Test;
d1978 1
a1978 4
        # 5.8.0 threads bug.  Shared arrays will not be auto-extended 
        # by a slice.
        $Test_Results[$Expected_Tests-1] = undef
          unless defined $Test_Results[$Expected_Tests-1];
d1980 1
a1980 2
        my $num_failed = grep !$_, @@Test_Results[0..$Expected_Tests-1];
        $num_failed += abs($Expected_Tests - @@Test_Results);
d1982 2
a1983 1
        if( $Curr_Test < $Expected_Tests ) {
d1985 1
a1985 1
Looks like you planned $Expected_Tests tests but only ran $Curr_Test.
d1988 7
a1994 2
        elsif( $Curr_Test > $Expected_Tests ) {
            my $num_extra = $Curr_Test - $Expected_Tests;
d1996 1
a1996 1
Looks like you planned $Expected_Tests tests but ran $num_extra extra.
d1999 2
a2000 1
        elsif ( $num_failed ) {
d2002 1
a2002 1
Looks like you failed $num_failed tests of $Expected_Tests.
d2004 2
d2008 9
a2016 6
        if( $Test_Died ) {
            $self->diag(<<"FAIL");
Looks like your test died just after $Curr_Test.
FAIL

            _my_exit( 255 ) && return;
d2019 1
a2019 1
        _my_exit( $num_failed <= 254 ? $num_failed : 254  ) && return;
d2021 8
a2028 2
    elsif ( $Skip_All ) {
        _my_exit( 0 ) && return;
d2032 1
a2032 1
        _my_exit( 255 ) && return;
d2034 2
d2042 19
d2063 1
a2063 1
In perl 5.8.0 and later, Test::Builder is thread-safe.  The test
d2067 6
d2089 2
a2090 2
Copyright 2001 by chromatic E<lt>chromatic@@wgz.orgE<gt>,
                  Michael G Schwern E<lt>schwern@@pobox.comE<gt>.
d2100 1
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d11 1
a11 1
$VERSION = '0.17';
d16 7
d30 3
d35 1
a35 2
        *share = sub { 0 };
        *lock  = sub { 0 };
a38 8
use vars qw($Level);
my($Test_Died) = 0;
my($Have_Plan) = 0;
my $Original_Pid = $$;
my $Curr_Test = 0;      share($Curr_Test);
my @@Test_Results = ();  share(@@Test_Results);
my @@Test_Details = ();  share(@@Test_Details);

a219 15
=item B<has_plan>

  $plan = $Test->has_plan
  
Find out whether a plan has been defined. $plan is either C<undef> (no plan has been set), C<no_plan> (indeterminate # of tests) or an integer (the number of expected tests).

=cut

sub has_plan {
	return($Expected_Tests) if $Expected_Tests;
	return('no_plan') if $No_Plan;
	return(undef);
};


a265 4
    # $test might contain an object which we don't want to accidentally
    # store, so we turn it into a boolean.
    $test = $test ? 1 : 0;

a283 3
    my $result = {};
    share($result);

d286 1
a286 1
        @@$result{ 'ok', 'actual_ok' } = ( ( $todo ? 1 : 0 ), 0 );
d289 1
a289 1
        @@$result{ 'ok', 'actual_ok' } = ( 1, $test );
a297 4
        $result->{name} = $name;
    }
    else {
        $result->{name} = '';
a302 6
        $result->{reason} = $what_todo;
        $result->{type}   = 'todo';
    }
    else {
        $result->{reason} = '';
        $result->{type}   = '';
a304 1
    $Test_Results[$Curr_Test-1] = $result;
d633 1
a633 10
    my %result;
    share(%result);
    %result = (
        'ok'      => 1,
        actual_ok => 1,
        name      => '',
        type      => 'skip',
        reason    => $why,
    );
    $Test_Results[$Curr_Test-1] = \%result;
d669 1
a669 11
    my %result;
    share(%result);
    %result = (
        'ok'      => 1,
        actual_ok => 0,
        name      => '',
        type      => 'todo_skip',
        reason    => $why,
    );

    $Test_Results[$Curr_Test-1] = \%result;
d1027 1
a1027 1
            my $start = @@Test_Results ? $#Test_Results + 1 : 0;
d1029 1
a1029 9
                my %result;
                share(%result);
                %result = ( ok        => 1, 
                            actual_ok => undef, 
                            reason    => 'incrementing test number', 
                            type      => 'unknown', 
                            name      => undef 
                          );
                $Test_Results[$_] = \%result;
d1051 1
a1051 1
    return map { $_->{'ok'} } @@Test_Results;
d1054 1
a1054 1
=item B<details>
d1061 1
a1061 1
            { 'ok'       => is the test considered a pass?
d1064 1
a1064 1
              type       => type of test (if any, see below).
a1067 39
'ok' is true if Test::Harness will consider the test to be a pass.

'actual_ok' is a reflection of whether or not the test literally
printed 'ok' or 'not ok'.  This is for examining the result of 'todo'
tests.  

'name' is the name of the test.

'type' indicates if it was a special test.  Normal tests have a type
of ''.  Type can be one of the following:

    skip        see skip()
    todo        see todo()
    todo_skip   see todo_skip()
    unknown     see below

Sometimes the Test::Builder test counter is incremented without it
printing any test output, for example, when current_test() is changed.
In these cases, Test::Builder doesn't know the result of the test, so
it's type is 'unkown'.  These details for these tests are filled in.
They are considered ok, but the name and actual_ok is left undef.

For example "not ok 23 - hole count # TODO insufficient donuts" would
result in this structure:

    $tests[22] =    # 23 - 1, since arrays start from 0.
      { ok        => 1,   # logically, the test passed since it's todo
        actual_ok => 0,   # in absolute terms, it failed
        name      => 'hole count',
        type      => 'todo',
        reason    => 'insufficient donuts'
      };

=cut

sub details {
    return @@Test_Results;
}

a1203 4
    # Don't bother with an ending if this is a forked copy.  Only the parent
    # should do the ending.
    do{ _my_exit($?) && return } if $Original_Pid != $$;

d1206 1
a1206 1
    do{ _my_exit(0) && return } if !$Have_Plan && !$Test_Died;
d1217 3
a1219 8
        # by a slice.  Worse, we have to fill in every entry else
        # we'll get an "Invalid value for shared scalar" error
        for my $idx ($#Test_Results..$Expected_Tests-1) {
            my %empty_result = ();
            share(%empty_result);
            $Test_Results[$idx] = \%empty_result
              unless defined $Test_Results[$idx];
        }
d1221 1
a1221 1
        my $num_failed = grep !$_->{'ok'}, @@Test_Results[0..$Expected_Tests-1];
a1253 5
    elsif ( $Test_Died ) {
        $self->diag(<<'FAIL');
Looks like your test died before it could output anything.
FAIL
    }
d1286 1
a1286 1
Copyright 2002 by chromatic E<lt>chromatic@@wgz.orgE<gt>,
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@d10 5
a14 3
use vars qw($VERSION);
$VERSION = '0.32';
$VERSION = eval $VERSION;    # make the alpha version come out as a number
d19 2
a20 2
    # Load threads::shared when threads are turned on
    if( $] >= 5.008 && $Config{useithreads} && $INC{'threads.pm'}) {
d22 1
a22 38

        # Hack around YET ANOTHER threads::shared bug.  It would 
        # occassionally forget the contents of the variable when sharing it.
        # So we first copy the data, then share, then put our copy back.
        *share = sub (\[$@@%]) {
            my $type = ref $_[0];
            my $data;

            if( $type eq 'HASH' ) {
                %$data = %{$_[0]};
            }
            elsif( $type eq 'ARRAY' ) {
                @@$data = @@{$_[0]};
            }
            elsif( $type eq 'SCALAR' ) {
                $$data = ${$_[0]};
            }
            else {
                die "Unknown type: ".$type;
            }

            $_[0] = &threads::shared::share($_[0]);

            if( $type eq 'HASH' ) {
                %{$_[0]} = %$data;
            }
            elsif( $type eq 'ARRAY' ) {
                @@{$_[0]} = @@$data;
            }
            elsif( $type eq 'SCALAR' ) {
                ${$_[0]} = $$data;
            }
            else {
                die "Unknown type: ".$type;
            }

            return $_[0];
        };
a23 2
    # 5.8.0's threads::shared is busted when threads are off.
    # We emulate it here.
d25 1
a25 1
        *share = sub { return $_[0] };
d30 8
d89 1
a89 1
Since you only run one test per program C<new> always returns the same
d91 1
a91 6
getting the same object.  This is called a singleton.  This is done so that
multiple modules share such global information as the test counter and
where test output is going.

If you want a completely new Test::Builder object different from the
singleton, use C<create>.
d95 1
a95 1
my $Test = Test::Builder->new;
d98 1
a98 1
    $Test ||= $class->create;
a101 67

=item B<create>

  my $Test = Test::Builder->create;

Ok, so there can be more than one Test::Builder object and this is how
you get it.  You might use this instead of C<new()> if you're testing
a Test::Builder based module, but otherwise you probably want C<new>.

B<NOTE>: the implementation is not complete.  C<level>, for example, is
still shared amongst B<all> Test::Builder objects, even ones created using
this method.  Also, the method name may change in the future.

=cut

sub create {
    my $class = shift;

    my $self = bless {}, $class;
    $self->reset;

    return $self;
}

=item B<reset>

  $Test->reset;

Reinitializes the Test::Builder singleton to its original state.
Mostly useful for tests run in persistent environments where the same
test might be run multiple times in the same process.

=cut

use vars qw($Level);

sub reset {
    my ($self) = @@_;

    # We leave this a global because it has to be localized and localizing
    # hash keys is just asking for pain.  Also, it was documented.
    $Level = 1;

    $self->{Test_Died}    = 0;
    $self->{Have_Plan}    = 0;
    $self->{No_Plan}      = 0;
    $self->{Original_Pid} = $$;

    share($self->{Curr_Test});
    $self->{Curr_Test}    = 0;
    $self->{Test_Results} = &share([]);

    $self->{Exported_To}    = undef;
    $self->{Expected_Tests} = 0;

    $self->{Skip_All}   = 0;

    $self->{Use_Nums}   = 1;

    $self->{No_Header}  = 0;
    $self->{No_Ending}  = 0;

    $self->_dup_stdhandles unless $^C;

    return undef;
}

d121 1
d126 1
a126 1
        $self->{Exported_To} = $pack;
d128 1
a128 1
    return $self->{Exported_To};
d149 1
a149 1
    if( $self->{Have_Plan} ) {
d191 1
d193 1
a193 2
    my $self = shift;
    my($max) = @@_;
d195 3
a197 6
    if( @@_ ) {
        die "Number of tests must be a postive integer.  You gave it '$max'.\n"
          unless $max =~ /^\+?\d+$/ and $max > 0;

        $self->{Expected_Tests} = $max;
        $self->{Have_Plan}      = 1;
d201 1
a201 1
    return $self->{Expected_Tests};
d213 1
d215 2
a216 4
    my $self = shift;

    $self->{No_Plan}   = 1;
    $self->{Have_Plan} = 1;
d222 1
a222 1

d228 3
a230 5
    my $self = shift;

    return($self->{Expected_Tests}) if $self->{Expected_Tests};
    return('no_plan') if $self->{No_Plan};
    return(undef);
d243 1
d251 1
a251 1
    $self->{Skip_All} = 1;
d284 1
a284 1
    unless( $self->{Have_Plan} ) {
d289 2
a290 5
    lock $self->{Curr_Test};
    $self->{Curr_Test}++;

    # In case $name is a string overloaded object, force it to stringify.
    $self->_unoverload_str(\$name);
a299 1
    $self->_unoverload_str(\$todo);
d302 2
a303 1
    my $result = &share({});
d314 1
a314 1
    $out .= " $self->{Curr_Test}" if $self->use_numbers;
d326 3
a328 2
        $out   .= " # TODO $todo";
        $result->{reason} = $todo;
d336 1
a336 1
    $self->{Test_Results}[$self->{Curr_Test}-1] = $result;
d343 1
a343 9
        $self->_print_diag("\n") if $ENV{HARNESS_ACTIVE};

	if( defined $name ) {
	    $self->diag(qq[  $msg test '$name'\n]);
	    $self->diag(qq[  in $file at line $line.\n]);
	}
	else {
	    $self->diag(qq[  $msg test in $file at line $line.\n]);
	}
a348 57

sub _unoverload {
    my $self  = shift;
    my $type  = shift;

    local($@@,$!);

    eval { require overload } || return;

    foreach my $thing (@@_) {
        eval { 
            if( _is_object($$thing) ) {
                if( my $string_meth = overload::Method($$thing, $type) ) {
                    $$thing = $$thing->$string_meth();
                }
            }
        };
    }
}


sub _is_object {
    my $thing = shift;

    return eval { ref $thing && $thing->isa('UNIVERSAL') } ? 1 : 0;
}


sub _unoverload_str {
    my $self = shift;

    $self->_unoverload(q[""], @@_);
}    

sub _unoverload_num {
    my $self = shift;

    $self->_unoverload('0+', @@_);

    for my $val (@@_) {
        next unless $self->_is_dualvar($$val);
        $$val = $$val+0;
    }
}


# This is a hack to detect a dualvar such as $!
sub _is_dualvar {
    my($self, $val) = @@_;

    local $^W = 0;
    my $numval = $val+0;
    return 1 if $numval != 0 and $numval ne $val;
}



a368 2
    $self->_unoverload_str(\$got, \$expect);

a384 2
    $self->_unoverload_num(\$got, \$expect);

d408 1
a408 1
                $self->_unoverload_num($val);
d448 1
a448 1
        $self->_cmp_diag($got, 'ne', $dont_expect) unless $test;
d464 1
a464 1
        $self->_cmp_diag($got, '!=', $dont_expect) unless $test;
d534 1
a534 1
    my ($self, $regex) = @@_;
a535 6

    return $usable_regex unless defined $regex;

    my($re, $opts);

    # Check for qr/foo/
d539 2
a540 5
    # Check for '/foo/' or 'm,foo,'
    elsif( ($re, $opts)        = $regex =~ m{^ /(.*)/ (\w*) $ }sx           or
           (undef, $re, $opts) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
         )
    {
d542 2
a543 3
    }

    return $usable_regex;
d549 2
d560 2
a561 10
        my $test;
        my $code = $self->_caller_context;

        local($@@, $!);

        # Yes, it has to look like this or 5.4.5 won't see the #line directive.
        # Don't ask me, man, I just work here.
        $test = eval "
$code" . q{$test = $this =~ /$usable_regex/ ? 1 : 0};

a562 2

        local $Level = $Level + 1;
a588 4

my %numeric_cmps = map { ($_, 1) } 
                       ("<",  "<=", ">",  ">=", "==", "!=", "<=>");

a591 8
    # Treat overloaded objects as numbers if we're asked to do a
    # numeric comparison.
    my $unoverload = $numeric_cmps{$type} ? '_unoverload_num'
                                          : '_unoverload_str';

    $self->$unoverload(\$got, \$expect);


d594 1
d597 1
a597 8

        my $code = $self->_caller_context;

        # Yes, it has to look like this or 5.4.5 won't see the #line directive.
        # Don't ask me, man, I just work here.
        $test = eval "
$code" . "\$got $type \$expect;";

d625 1
d627 1
a627 15
sub _caller_context {
    my $self = shift;

    my($pack, $file, $line) = $self->caller(1);

    my $code = '';
    $code .= "#line $line $file\n" if defined $file and defined $line;

    return $code;
}


=item B<BAIL_OUT>

    $Test->BAIL_OUT($reason);
d637 1
a637 1
sub BAIL_OUT {
a639 1
    $self->{Bailed_Out} = 1;
a643 8
=for deprecated
BAIL_OUT() used to be BAILOUT()

=cut

*BAILOUT = \&BAIL_OUT;


a655 1
    $self->_unoverload_str(\$why);
d657 1
a657 1
    unless( $self->{Have_Plan} ) {
d662 2
a663 2
    lock($self->{Curr_Test});
    $self->{Curr_Test}++;
d665 3
a667 1
    $self->{Test_Results}[$self->{Curr_Test}-1] = &share({
d673 2
a674 1
    });
d677 2
a678 4
    $out   .= " $self->{Curr_Test}" if $self->use_numbers;
    $out   .= " # skip";
    $out   .= " $why"       if length $why;
    $out   .= "\n";
d680 1
a680 1
    $self->_print($out);
d702 1
a702 1
    unless( $self->{Have_Plan} ) {
d707 2
a708 2
    lock($self->{Curr_Test});
    $self->{Curr_Test}++;
d710 3
a712 1
    $self->{Test_Results}[$self->{Curr_Test}-1] = &share({
d718 3
a720 1
    });
d723 1
a723 1
    $out   .= " $self->{Curr_Test}" if $self->use_numbers;
d726 1
a726 1
    $self->_print($out);
d782 2
d810 1
d815 1
a815 1
        $self->{Use_Nums} = $use_nums;
d817 1
a817 1
    return $self->{Use_Nums};
d820 1
d822 1
a822 1
=item B<no_diag>
d824 1
a824 4
    $Test->no_diag($no_diag);

If set true no diagnostics will be printed.  This includes calls to
diag().
d831 1
a831 1
ends.  It also changes the exit code as described below.
a834 6
=item B<no_header>

    $Test->no_header($no_header);

If set to true, no "1..N" header will be printed.

d837 3
a839 2
foreach my $attribute (qw(No_Header No_Ending No_Diag)) {
    my $method = lc $attribute;
d841 5
a845 2
    my $code = sub {
        my($self, $no) = @@_;
d847 2
a848 5
        if( defined $no ) {
            $self->{$attribute} = $no;
        }
        return $self->{$attribute};
    };
d850 4
a853 2
    no strict 'refs';
    *{__PACKAGE__.'::'.$method} = $code;
d872 3
a874 5
Prints out the given @@msgs.  Like C<print>, arguments are simply
appended together.

Normally, it uses the failure_output() handle, but if this is for a
TODO test, the todo_output() handle is used.
a893 2

    return if $self->no_diag;
a898 4
    # Smash args together like print does.
    # Convert undef to 'undef' so its readable.
    my $msg = join '', map { defined($_) ? $_ : 'undef' } @@msgs;

d900 4
a903 1
    $msg =~ s/^/# /gm;
d905 1
a905 2
    # Stick a newline on the end if it needs it.
    $msg .= "\n" unless $msg =~ /\n\Z/;
d908 3
a910 1
    $self->_print_diag($msg);
a933 2
    my $msg = join '', @@msgs;

d939 3
a941 1
    $msg =~ s/\n(.)/\n# $1/sg;
d943 1
a943 2
    # Stick a newline on the end if it needs it.
    $msg .= "\n" unless $msg =~ /\n\Z/;
d945 1
a945 1
    print $fh $msg;
a948 16
=item B<_print_diag>

    $Test->_print_diag(@@msg);

Like _print, but prints to the current diagnostic filehandle.

=cut

sub _print_diag {
    my $self = shift;

    local($\, $", $,) = (undef, ' ', '');
    my $fh = $self->todo ? $self->todo_output : $self->failure_output;
    print $fh @@_;
}    

d978 1
d983 1
a983 1
        $self->{Out_FH} = _new_fh($fh);
d985 1
a985 1
    return $self->{Out_FH};
d992 1
a992 1
        $self->{Fail_FH} = _new_fh($fh);
d994 1
a994 1
    return $self->{Fail_FH};
d1001 1
a1001 1
        $self->{Todo_FH} = _new_fh($fh);
d1003 1
a1003 1
    return $self->{Todo_FH};
a1005 1

d1010 1
a1010 4
    if( _is_fh($file_or_fh) ) {
        $fh = $file_or_fh;
    }
    else {
d1014 3
a1016 1
	_autoflush($fh);
d1022 5
a1026 27

sub _is_fh {
    my $maybe_fh = shift;
    return 0 unless defined $maybe_fh;

    return 1 if ref \$maybe_fh eq 'GLOB'; # its a glob

    return UNIVERSAL::isa($maybe_fh,               'GLOB')       ||
           UNIVERSAL::isa($maybe_fh,               'IO::Handle') ||

           # 5.5.4's tied() and can() doesn't like getting undef
           UNIVERSAL::can((tied($maybe_fh) || ''), 'TIEHANDLE');
}


sub _autoflush {
    my($fh) = shift;
    my $old_fh = select $fh;
    $| = 1;
    select $old_fh;
}


sub _dup_stdhandles {
    my $self = shift;

    $self->_open_testhandles;
d1035 3
a1037 3
    $self->output(\*TESTOUT);
    $self->failure_output(\*TESTERR);
    $self->todo_output(\*TESTOUT);
d1040 5
a1044 9

my $Opened_Testhandles = 0;
sub _open_testhandles {
    return if $Opened_Testhandles;
    # We dup STDOUT and STDERR so people can change them in their
    # test suites while still getting normal test output.
    open(TESTOUT, ">&STDOUT") or die "Can't dup STDOUT:  $!";
    open(TESTERR, ">&STDERR") or die "Can't dup STDERR:  $!";
    $Opened_Testhandles = 1;
d1060 1
a1060 2
Gets/sets the current test number we're on.  You usually shouldn't
have to set this.
d1062 1
a1062 3
If set forward, the details of the missing tests are filled in as 'unknown'.
if set backward, the details of the intervening tests are deleted.  You
can erase history if you really want to.
d1069 1
a1069 1
    lock($self->{Curr_Test});
d1071 1
a1071 1
        unless( $self->{Have_Plan} ) {
d1076 3
a1078 6
        $self->{Curr_Test} = $num;

        # If the test counter is being pushed forward fill in the details.
        my $test_results = $self->{Test_Results};
        if( $num > @@$test_results ) {
            my $start = @@$test_results ? @@$test_results : 0;
d1080 9
a1088 7
                $test_results->[$_] = &share({
                    'ok'      => 1, 
                    actual_ok => undef, 
                    reason    => 'incrementing test number', 
                    type      => 'unknown', 
                    name      => undef 
                });
a1090 4
        # If backward, wipe history.  Its their funeral.
        elsif( $num < @@$test_results ) {
            $#{$test_results} = $num - 1;
        }
d1092 1
a1092 1
    return $self->{Curr_Test};
d1110 1
a1110 1
    return map { $_->{'ok'} } @@{ $self->{Test_Results} };
d1163 1
a1163 2
    my $self = shift;
    return @@{ $self->{Test_Results} };
d1176 3
a1178 3
todo() is about finding the right package to look for $TODO in.  It
uses the exported_to() package to find it.  If that's not set, it's
pretty good at guessing the right package to look at based on $Level.
d1189 1
a1189 2
    $pack = $pack || $self->exported_to || $self->caller($Level);
    return 0 unless $pack;
d1224 1
a1224 1
  $self->_sanity_check();
d1234 2
a1235 4
    my $self = shift;

    _whoa($self->{Curr_Test} < 0,  'Says here you ran a negative number of tests!');
    _whoa(!$self->{Have_Plan} and $self->{Curr_Test}, 
d1237 1
a1237 1
    _whoa($self->{Curr_Test} != @@{ $self->{Test_Results} },
d1294 1
a1294 1
    $Test->{Test_Died} = 1 unless $in_eval;
d1300 1
a1300 1
    $self->_sanity_check();
d1304 5
a1308 11
    # Exit if plan() was never called.  This is so "require Test::Simple" 
    # doesn't puke.
    # Don't do an ending if we bailed out.
    if( ($self->{Original_Pid} != $$) 			or
	(!$self->{Have_Plan} && !$self->{Test_Died}) 	or
	$self->{Bailed_Out}
      )
    {
	_my_exit($?);
	return;
    }
d1311 1
a1311 2
    my $test_results = $self->{Test_Results};
    if( @@$test_results ) {
d1313 3
a1315 3
        if( $self->{No_Plan} ) {
            $self->_print("1..$self->{Curr_Test}\n") unless $self->no_header;
            $self->{Expected_Tests} = $self->{Curr_Test};
d1318 8
a1325 7
        # Auto-extended arrays and elements which aren't explicitly
        # filled in with a shared reference will puke under 5.8.0
        # ithreads.  So we have to fill them in by hand. :(
        my $empty_result = &share({});
        for my $idx ( 0..$self->{Expected_Tests}-1 ) {
            $test_results->[$idx] = $empty_result
              unless defined $test_results->[$idx];
d1328 2
a1329 4
        my $num_failed = grep !$_->{'ok'}, 
                              @@{$test_results}[0..$self->{Curr_Test}-1];

        my $num_extra = $self->{Curr_Test} - $self->{Expected_Tests};
d1331 1
a1331 2
        if( $num_extra < 0 ) {
            my $s = $self->{Expected_Tests} == 1 ? '' : 's';
d1333 1
a1333 1
Looks like you planned $self->{Expected_Tests} test$s but only ran $self->{Curr_Test}.
d1336 2
a1337 2
        elsif( $num_extra > 0 ) {
            my $s = $self->{Expected_Tests} == 1 ? '' : 's';
d1339 1
a1339 1
Looks like you planned $self->{Expected_Tests} test$s but ran $num_extra extra.
d1342 1
a1342 7

        if ( $num_failed ) {
            my $num_tests = $self->{Curr_Test};
            my $s = $num_failed == 1 ? '' : 's';

            my $qualifier = $num_extra == 0 ? '' : ' run';

d1344 1
a1344 1
Looks like you failed $num_failed test$s of $num_tests$qualifier.
d1348 1
a1348 1
        if( $self->{Test_Died} ) {
d1350 1
a1350 1
Looks like your test died just after $self->{Curr_Test}.
d1356 1
a1356 12
        my $exit_code;
        if( $num_failed ) {
            $exit_code = $num_failed <= 254 ? $num_failed : 254;
        }
        elsif( $num_extra != 0 ) {
            $exit_code = 255;
        }
        else {
            $exit_code = 0;
        }

        _my_exit( $exit_code ) && return;
d1358 1
a1358 1
    elsif ( $self->{Skip_All} ) {
d1361 1
a1361 1
    elsif ( $self->{Test_Died} ) {
a1364 1
        _my_exit( 255 ) && return;
a1375 19
=head1 EXIT CODES

If all your tests passed, Test::Builder will exit with zero (which is
normal).  If anything failed it will exit with how many failed.  If
you run less (or more) tests than you planned, the missing (or extras)
will be considered failures.  If no tests were ever run Test::Builder
will throw a warning and exit with 255.  If the test died, even after
having successfully completed all its tests, it will still be
considered a failure and will exit with 255.

So the exit codes are...

    0                   all tests successful
    255                 test died or all passed but wrong # of tests run
    any other number    how many failed (including missing or extras)

If you fail more than 254 tests, it will be reported as 254.


a1381 3
Test::Builder is only thread-aware if threads.pm is loaded I<before>
Test::Builder.

d1398 2
a1399 2
Copyright 2002, 2004 by chromatic E<lt>chromatic@@wgz.orgE<gt> and
                        Michael G Schwern E<lt>schwern@@pobox.comE<gt>.
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d11 1
a11 1
$VERSION = '0.72';
d17 2
a18 3
    # Load threads::shared when threads are turned on.
    # 5.8.0's threads are so busted we no longer support them.
    if( $] >= 5.008001 && $Config{useithreads} && $INC{'threads.pm'}) {
d38 1
a38 1
                die("Unknown type: ".$type);
d53 1
a53 1
                die("Unknown type: ".$type);
d59 2
a60 2
    # 5.8.0's threads::shared is busted when threads are off
    # and earlier Perls just don't have that module at all.
a248 2
    local $Level = $Level + 1;

d250 2
a251 1
        $self->croak("You tried to plan twice");
a261 1
            local $Level = $Level + 1;
d265 2
a266 1
            $self->croak("Got an undefined number of tests");
d269 1
a269 1
            $self->croak("You said to run 0 tests");
d273 1
d275 1
a275 1
        $self->croak("plan() doesn't understand @@args");
d296 1
a296 1
        $self->croak("Number of tests must be a positive integer.  You gave it '$max'")
d366 2
a367 3
These actually run the tests, analogous to the functions in Test::More.

They all return true if the test passed, false if the test failed.
d389 4
a392 1
    $self->_plan_check;
d454 1
a454 1
	    $self->diag(qq[  at $file line $line.\n]);
d457 1
a457 1
	    $self->diag(qq[  $msg test at $file line $line.\n]);
d469 3
a471 1
    $self->_try(sub { require overload } ) || return;
d474 5
a478 3
        if( $self->_is_object($$thing) ) {
            if( my $string_meth = overload::Method($$thing, $type) ) {
                $$thing = $$thing->$string_meth();
d480 1
a480 1
        }
d486 1
a486 1
    my($self, $thing) = @@_;
d488 1
a488 1
    return $self->_try(sub { ref $thing && $thing->isa('UNIVERSAL') }) ? 1 : 0;
d608 1
a608 1
  $Test->isnt_num($got, $dont_expect, $name);
d681 91
d800 2
a801 1
        local($@@,$!,$SIG{__DIE__});  # isolate eval
a848 8
=back


=head2 Other Testing Methods

These are methods which are used in the course of writing a test but are not themselves tests.

=over 4
d892 4
a895 1
    $self->_plan_check;
d936 4
a939 1
    $self->_plan_check;
a979 156
=head2 Test building utility methods

These methods are useful when writing your own test methods.

=over 4

=item B<maybe_regex>

  $Test->maybe_regex(qr/$regex/);
  $Test->maybe_regex('/$regex/');

Convenience method for building testing functions that take regular
expressions as arguments, but need to work before perl 5.005.

Takes a quoted regular expression produced by qr//, or a string
representing a regular expression.

Returns a Perl value which may be used instead of the corresponding
regular expression, or undef if it's argument is not recognised.

For example, a version of like(), sans the useful diagnostic messages,
could be written as:

  sub laconic_like {
      my ($self, $this, $regex, $name) = @@_;
      my $usable_regex = $self->maybe_regex($regex);
      die "expecting regex, found '$regex'\n"
          unless $usable_regex;
      $self->ok($this =~ m/$usable_regex/, $name);
  }

=cut


sub maybe_regex {
    my ($self, $regex) = @@_;
    my $usable_regex = undef;

    return $usable_regex unless defined $regex;

    my($re, $opts);

    # Check for qr/foo/
    if( ref $regex eq 'Regexp' ) {
        $usable_regex = $regex;
    }
    # Check for '/foo/' or 'm,foo,'
    elsif( ($re, $opts)        = $regex =~ m{^ /(.*)/ (\w*) $ }sx           or
           (undef, $re, $opts) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
         )
    {
        $usable_regex = length $opts ? "(?$opts)$re" : $re;
    }

    return $usable_regex;
};

sub _regex_ok {
    my($self, $this, $regex, $cmp, $name) = @@_;

    my $ok = 0;
    my $usable_regex = $self->maybe_regex($regex);
    unless (defined $usable_regex) {
        $ok = $self->ok( 0, $name );
        $self->diag("    '$regex' doesn't look much like a regex to me.");
        return $ok;
    }

    {
        my $test;
        my $code = $self->_caller_context;

        local($@@, $!, $SIG{__DIE__}); # isolate eval

        # Yes, it has to look like this or 5.4.5 won't see the #line directive.
        # Don't ask me, man, I just work here.
        $test = eval "
$code" . q{$test = $this =~ /$usable_regex/ ? 1 : 0};

        $test = !$test if $cmp eq '!~';

        local $Level = $Level + 1;
        $ok = $self->ok( $test, $name );
    }

    unless( $ok ) {
        $this = defined $this ? "'$this'" : 'undef';
        my $match = $cmp eq '=~' ? "doesn't match" : "matches";
        $self->diag(sprintf <<DIAGNOSTIC, $this, $match, $regex);
                  %s
    %13s '%s'
DIAGNOSTIC

    }

    return $ok;
}


# I'm not ready to publish this.  It doesn't deal with array return
# values from the code or context.

=begin private

=item B<_try>

    my $return_from_code          = $Test->try(sub { code });
    my($return_from_code, $error) = $Test->try(sub { code });

Works like eval BLOCK except it ensures it has no effect on the rest of the test (ie. $@@ is not set) nor is effected by outside interference (ie. $SIG{__DIE__}) and works around some quirks in older Perls.

$error is what would normally be in $@@.

It is suggested you use this in place of eval BLOCK.

=cut

sub _try {
    my($self, $code) = @@_;
    
    local $!;               # eval can mess up $!
    local $@@;               # don't set $@@ in the test
    local $SIG{__DIE__};    # don't trip an outside DIE handler.
    my $return = eval { $code->() };
    
    return wantarray ? ($return, $@@) : $return;
}

=end private


=item B<is_fh>

    my $is_fh = $Test->is_fh($thing);

Determines if the given $thing can be used as a filehandle.

=cut

sub is_fh {
    my $self = shift;
    my $maybe_fh = shift;
    return 0 unless defined $maybe_fh;

    return 1 if ref $maybe_fh  eq 'GLOB'; # its a glob ref
    return 1 if ref \$maybe_fh eq 'GLOB'; # its a glob

    return eval { $maybe_fh->isa("IO::Handle") } ||
           # 5.5.4's tied() and can() doesn't like getting undef
           eval { (tied($maybe_fh) || '')->can('TIEHANDLE') };
}


=back


a981 1

d993 1
a993 1
Setting L<$Test::Builder::Level> overrides.  This is typically useful
d996 3
a998 5
    sub my_ok {
        my $test = shift;

        local $Test::Builder::Level = $Test::Builder::Level + 1;
        $TB->ok($test);
a1000 2
To be polite to other functions wrapping your own you usually want to increment C<$Level> rather than set it to a constant.

d1032 2
a1184 1
=begin private
a1191 2
=end private

d1235 1
a1235 1
        $self->{Out_FH} = $self->_new_fh($fh);
d1244 1
a1244 1
        $self->{Fail_FH} = $self->_new_fh($fh);
d1253 1
a1253 1
        $self->{Todo_FH} = $self->_new_fh($fh);
a1259 1
    my $self = shift;
d1263 1
a1263 1
    if( $self->is_fh($file_or_fh) ) {
d1268 2
a1269 2
        open $fh, ">$file_or_fh" or
            $self->croak("Can't open test output log $file_or_fh: $!");
d1277 14
a1327 43
=item carp

  $tb->carp(@@message);

Warns with C<@@message> but the message will appear to come from the
point where the original test function was called (C<$tb->caller>).

=item croak

  $tb->croak(@@message);

Dies with C<@@message> but the message will appear to come from the
point where the original test function was called (C<$tb->caller>).

=cut

sub _message_at_caller {
    my $self = shift;

    local $Level = $Level + 1;
    my($pack, $file, $line) = $self->caller;
    return join("", @@_) . " at $file line $line.\n";
}

sub carp {
    my $self = shift;
    warn $self->_message_at_caller(@@_);
}

sub croak {
    my $self = shift;
    die $self->_message_at_caller(@@_);
}

sub _plan_check {
    my $self = shift;

    unless( $self->{Have_Plan} ) {
        local $Level = $Level + 2;
        $self->croak("You tried to run a test without a plan");
    }
}

d1355 2
a1356 1
            $self->croak("Can't change the current test number without a plan!");
d1526 2
a1527 2
    $self->_whoa($self->{Curr_Test} < 0,  'Says here you ran a negative number of tests!');
    $self->_whoa(!$self->{Have_Plan} and $self->{Curr_Test}, 
d1529 1
a1529 1
    $self->_whoa($self->{Curr_Test} != @@{ $self->{Test_Results} },
d1535 1
a1535 1
  $self->_whoa($check, $description);
d1544 1
a1544 1
    my($self, $check, $desc) = @@_;
d1546 1
a1546 2
        local $Level = $Level + 1;
        $self->croak(<<"WHOA");
d1716 1
a1716 1
In perl 5.8.1 and later, Test::Builder is thread-safe.  The test
a1718 3

While versions earlier than 5.8.1 had threads they contain too many
bugs to support.
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d3 1
a3 3
use 5.006;
use strict;
use warnings;
d5 3
a7 8
our $VERSION = '0.92';
$VERSION = eval $VERSION;    ## no critic (BuiltinFunctions::ProhibitStringyEval)

BEGIN {
    if( $] < 5.008 ) {
        require Test::Builder::IO::Scalar;
    }
}
d9 4
d19 1
a19 1
    if( $] >= 5.008001 && $Config{useithreads} && $INC{'threads.pm'} ) {
d22 1
a22 1
        # Hack around YET ANOTHER threads::shared bug.  It would
d30 1
a30 1
                %$data = %{ $_[0] };
d33 1
a33 1
                @@$data = @@{ $_[0] };
d36 1
a36 1
                $$data = ${ $_[0] };
d39 1
a39 1
                die( "Unknown type: " . $type );
d42 1
a42 1
            $_[0] = &threads::shared::share( $_[0] );
d45 1
a45 1
                %{ $_[0] } = %$data;
d48 1
a48 1
                @@{ $_[0] } = @@$data;
d51 1
a51 1
                ${ $_[0] } = $$data;
d54 1
a54 1
                die( "Unknown type: " . $type );
d68 1
d76 4
a79 1
  use base 'Test::Builder::Module';
d81 12
a92 1
  my $CLASS = __PACKAGE__;
a95 1
      my $tb = $CLASS->builder;
d97 1
a97 1
      $tb->ok($test, $name);
d120 1
a120 1
Test::Builder object.  No matter how many times you call C<new()>, you're
a130 1

d137 1
d171 1
a171 1
our $Level;
d173 2
a174 2
sub reset {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
    my($self) = @@_;
d180 1
a182 2
    $self->{Have_Output_Plan} = 0;

d185 3
a187 3
    share( $self->{Curr_Test} );
    $self->{Curr_Test} = 0;
    $self->{Test_Results} = &share( [] );
d192 1
a192 3
    $self->{Skip_All} = 0;

    $self->{Use_Nums} = 1;
d194 1
a194 2
    $self->{No_Header} = 0;
    $self->{No_Ending} = 0;
d196 2
a197 4
    $self->{Todo}       = undef;
    $self->{Todo_Stack} = [];
    $self->{Start_Todo} = 0;
    $self->{Opened_Testhandles} = 0;
d199 1
a199 1
    $self->_dup_stdhandles;
d201 1
a201 1
    return;
d213 19
d241 1
a241 1
If you call C<plan()>, don't call any of the other methods below.
a244 6
my %plan_cmds = (
    no_plan     => \&no_plan,
    skip_all    => \&skip_all,
    tests       => \&_plan_tests,
);

d246 1
a246 1
    my( $self, $cmd, $arg ) = @@_;
d252 3
a254 1
    $self->croak("You tried to plan twice") if $self->{Have_Plan};
d256 17
a272 3
    if( my $method = $plan_cmds{$cmd} ) {
        local $Level = $Level + 1;
        $self->$method($arg);
d275 1
a275 1
        my @@args = grep { defined } ( $cmd, $arg );
a281 19

sub _plan_tests {
    my($self, $arg) = @@_;

    if($arg) {
        local $Level = $Level + 1;
        return $self->expected_tests($arg);
    }
    elsif( !defined $arg ) {
        $self->croak("Got an undefined number of tests");
    }
    else {
        $self->croak("You said to run 0 tests");
    }

    return;
}


d287 1
a287 1
Gets/sets the number of tests we expect this test to run and prints out
d296 1
a296 1
    if(@@_) {
d298 1
a298 1
          unless $max =~ /^\+?\d+$/;
d303 1
a303 1
        $self->_output_plan($max) unless $self->no_header;
d308 1
d313 1
a313 1
Declares that this test will run an indeterminate number of tests.
d318 1
a318 3
    my($self, $arg) = @@_;

    $self->carp("no_plan takes no arguments") if $arg;
a321 2

    return 1;
a323 109

=begin private

=item B<_output_plan>

  $tb->_output_plan($max);
  $tb->_output_plan($max, $directive);
  $tb->_output_plan($max, $directive => $reason);

Handles displaying the test plan.

If a C<$directive> and/or C<$reason> are given they will be output with the
plan.  So here's what skipping all tests looks like:

    $tb->_output_plan(0, "SKIP", "Because I said so");

It sets C<< $tb->{Have_Output_Plan} >> and will croak if the plan was already
output.

=end private

=cut

sub _output_plan {
    my($self, $max, $directive, $reason) = @@_;

    $self->carp("The plan was already output") if $self->{Have_Output_Plan};

    my $plan = "1..$max";
    $plan .= " # $directive" if defined $directive;
    $plan .= " $reason"      if defined $reason;

    $self->_print("$plan\n");

    $self->{Have_Output_Plan} = 1;

    return;
}

=item B<done_testing>

  $Test->done_testing();
  $Test->done_testing($num_tests);

Declares that you are done testing, no more tests will be run after this point.

If a plan has not yet been output, it will do so.

$num_tests is the number of tests you planned to run.  If a numbered
plan was already declared, and if this contradicts, a failing test
will be run to reflect the planning mistake.  If C<no_plan> was declared,
this will override.

If C<done_testing()> is called twice, the second call will issue a
failing test.

If C<$num_tests> is omitted, the number of tests run will be used, like
no_plan.

C<done_testing()> is, in effect, used when you'd want to use C<no_plan>, but
safer. You'd use it like so:

    $Test->ok($a == $b);
    $Test->done_testing();

Or to plan a variable number of tests:

    for my $test (@@tests) {
        $Test->ok($test);
    }
    $Test->done_testing(@@tests);

=cut

sub done_testing {
    my($self, $num_tests) = @@_;

    # If done_testing() specified the number of tests, shut off no_plan.
    if( defined $num_tests ) {
        $self->{No_Plan} = 0;
    }
    else {
        $num_tests = $self->current_test;
    }

    if( $self->{Done_Testing} ) {
        my($file, $line) = @@{$self->{Done_Testing}}[1,2];
        $self->ok(0, "done_testing() was already called at $file line $line");
        return;
    }

    $self->{Done_Testing} = [caller];

    if( $self->expected_tests && $num_tests != $self->expected_tests ) {
        $self->ok(0, "planned to run @@{[ $self->expected_tests ]} ".
                     "but done_testing() expects $num_tests");
    }
    else {
        $self->{Expected_Tests} = $num_tests;
    }

    $self->_output_plan($num_tests) unless $self->{Have_Output_Plan};

    $self->{Have_Plan} = 1;

    return 1;
}


d328 1
a328 3
Find out whether a plan has been defined. C<$plan> is either C<undef> (no plan
has been set), C<no_plan> (indeterminate # of tests) or an integer (the number
of expected tests).
d335 1
a335 1
    return( $self->{Expected_Tests} ) if $self->{Expected_Tests};
d338 2
a339 1
}
d346 1
a346 1
Skips all the tests, using the given C<$reason>.  Exits immediately with 0.
d351 5
a355 1
    my( $self, $reason ) = @@_;
d359 1
a359 1
    $self->_output_plan(0, "SKIP", $reason) unless $self->no_header;
a362 22
=item B<exported_to>

  my $pack = $Test->exported_to;
  $Test->exported_to($pack);

Tells Test::Builder what package you exported your functions to.

This method isn't terribly useful since modules which share the same
Test::Builder object might get exported to different packages and only
the last one will be honored.

=cut

sub exported_to {
    my( $self, $pack ) = @@_;

    if( defined $pack ) {
        $self->{Exported_To} = $pack;
    }
    return $self->{Exported_To};
}

d371 1
a371 1
C<$name> is always optional.
d379 2
a380 2
Your basic test.  Pass if C<$test> is true, fail if $test is false.  Just
like Test::Simple's C<ok()>.
d385 1
a385 1
    my( $self, $test, $name ) = @@_;
d391 2
d397 1
a397 1
    $self->_unoverload_str( \$name );
d399 1
a399 1
    $self->diag(<<"ERR") if defined $name and $name =~ /^[\d\s]+$/;
d404 1
a404 5
    # Capture the value of $TODO for the rest of this ok() call
    # so it can more easily be found by other routines.
    my $todo    = $self->todo();
    my $in_todo = $self->in_todo;
    local $self->{Todo} = $todo if $in_todo;
d406 2
a407 1
    $self->_unoverload_str( \$todo );
d410 1
a410 1
    my $result = &share( {} );
d412 1
a412 1
    unless($test) {
d414 1
a414 1
        @@$result{ 'ok', 'actual_ok' } = ( ( $self->in_todo ? 1 : 0 ), 0 );
d424 2
a425 2
        $name =~ s|#|\\#|g;    # # in a name can confuse Test::Harness.
        $out .= " - $name";
d432 2
a433 2
    if( $self->in_todo ) {
        $out .= " # TODO $todo";
d442 1
a442 1
    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = $result;
d447 12
a458 13
    unless($test) {
        my $msg = $self->in_todo ? "Failed (TODO)" : "Failed";
        $self->_print_to_fh( $self->_diag_fh, "\n" ) if $ENV{HARNESS_ACTIVE};

        my( undef, $file, $line ) = $self->caller;
        if( defined $name ) {
            $self->diag(qq[  $msg test '$name'\n]);
            $self->diag(qq[  at $file line $line.\n]);
        }
        else {
            $self->diag(qq[  $msg test at $file line $line.\n]);
        }
    }
d463 1
d465 2
a466 2
    my $self = shift;
    my $type = shift;
d468 1
a468 1
    $self->_try(sub { require overload; }, die_on_fail => 1);
d472 1
a472 1
            if( my $string_meth = overload::Method( $$thing, $type ) ) {
d477 1
a478 2
    return;
}
d481 1
a481 1
    my( $self, $thing ) = @@_;
d483 1
a483 1
    return $self->_try( sub { ref $thing && $thing->isa('UNIVERSAL') } ) ? 1 : 0;
d486 1
d490 2
a491 2
    return $self->_unoverload( q[""], @@_ );
}
d496 1
a496 1
    $self->_unoverload( '0+', @@_ );
d500 1
a500 1
        $$val = $$val + 0;
d502 1
a503 2
    return;
}
d507 6
a512 1
    my( $self, $val ) = @@_;
a513 2
    # Objects are not dualvars.
    return 0 if ref $val;
a514 4
    no warnings 'numeric';
    my $numval = $val + 0;
    return $numval != 0 and $numval ne $val ? 1 : 0;
}
d520 1
a520 1
Like Test::More's C<is()>.  Checks if C<$got eq $expected>.  This is the
d527 1
a527 1
Like Test::More's C<is()>.  Checks if C<$got == $expected>.  This is the
d533 1
a533 1
    my( $self, $got, $expect, $name ) = @@_;
d536 1
a536 1
    $self->_unoverload_str( \$got, \$expect );
d542 2
a543 2
        $self->ok( $test, $name );
        $self->_is_diag( $got, 'eq', $expect ) unless $test;
d547 1
a547 1
    return $self->cmp_ok( $got, 'eq', $expect, $name );
d551 1
a551 1
    my( $self, $got, $expect, $name ) = @@_;
d554 1
a554 1
    $self->_unoverload_num( \$got, \$expect );
d560 2
a561 2
        $self->ok( $test, $name );
        $self->_is_diag( $got, '==', $expect ) unless $test;
d565 1
a565 1
    return $self->cmp_ok( $got, '==', $expect, $name );
d568 2
a569 2
sub _diag_fmt {
    my( $self, $type, $val ) = @@_;
d571 10
a580 4
    if( defined $$val ) {
        if( $type eq 'eq' or $type eq 'ne' ) {
            # quote and force string context
            $$val = "'$$val'";
d583 1
a583 2
            # force numeric context
            $self->_unoverload_num($val);
a585 11
    else {
        $$val = 'undef';
    }

    return;
}

sub _is_diag {
    my( $self, $got, $type, $expect ) = @@_;

    $self->_diag_fmt( $type, $_ ) for \$got, \$expect;
d587 3
a589 4
    local $Level = $Level + 1;
    return $self->diag(<<"DIAGNOSTIC");
         got: $got
    expected: $expect
d592 1
a592 13
}

sub _isnt_diag {
    my( $self, $got, $type ) = @@_;

    $self->_diag_fmt( $type, \$got );

    local $Level = $Level + 1;
    return $self->diag(<<"DIAGNOSTIC");
         got: $got
    expected: anything else
DIAGNOSTIC
}
d598 1
a598 1
Like Test::More's C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
d605 1
a605 1
Like Test::More's C<isnt()>.  Checks if C<$got ne $dont_expect>.  This is
d611 1
a611 1
    my( $self, $got, $dont_expect, $name ) = @@_;
d618 2
a619 2
        $self->ok( $test, $name );
        $self->_isnt_diag( $got, 'ne' ) unless $test;
d623 1
a623 1
    return $self->cmp_ok( $got, 'ne', $dont_expect, $name );
d627 1
a627 1
    my( $self, $got, $dont_expect, $name ) = @@_;
d634 2
a635 2
        $self->ok( $test, $name );
        $self->_isnt_diag( $got, '!=' ) unless $test;
d639 1
a639 1
    return $self->cmp_ok( $got, '!=', $dont_expect, $name );
d642 1
d648 1
a648 1
Like Test::More's C<like()>.  Checks if $this matches the given C<$regex>.
d650 1
a650 1
You'll want to avoid C<qr//> if you want your tests to work before 5.005.
d657 2
a658 2
Like Test::More's C<unlike()>.  Checks if $this B<does not match> the
given C<$regex>.
d663 1
a663 1
    my( $self, $this, $regex, $name ) = @@_;
d666 1
a666 1
    return $self->_regex_ok( $this, $regex, '=~', $name );
d670 1
a670 1
    my( $self, $this, $regex, $name ) = @@_;
d673 1
a673 1
    return $self->_regex_ok( $this, $regex, '!~', $name );
d676 1
d681 1
a681 1
Works just like Test::More's C<cmp_ok()>.
d687 3
a689 1
my %numeric_cmps = map { ( $_, 1 ) } ( "<", "<=", ">", ">=", "==", "!=", "<=>" );
d692 9
a700 1
    my( $self, $got, $type, $expect, $name ) = @@_;
a702 1
    my $error;
d704 1
a704 1
        ## no critic (BuiltinFunctions::ProhibitStringyEval)
d706 1
a706 1
        local( $@@, $!, $SIG{__DIE__} );    # isolate eval
d708 4
a711 1
        my($pack, $file, $line) = $self->caller();
a712 5
        $test = eval qq[
#line 1 "cmp_ok [from $file line $line]"
\$got $type \$expect;
];
        $error = $@@;
d715 1
a715 18
    my $ok = $self->ok( $test, $name );

    # Treat overloaded objects as numbers if we're asked to do a
    # numeric comparison.
    my $unoverload
      = $numeric_cmps{$type}
      ? '_unoverload_num'
      : '_unoverload_str';

    $self->diag(<<"END") if $error;
An error occurred while using $type:
------------------------------------
$error
------------------------------------
END

    unless($ok) {
        $self->$unoverload( \$got, \$expect );
d717 1
d719 1
a719 4
            $self->_is_diag( $got, $type, $expect );
        }
        elsif( $type =~ /^(ne|!=)$/ ) {
            $self->_isnt_diag( $got, $type );
d722 1
a722 1
            $self->_cmp_diag( $got, $type, $expect );
d729 2
a730 2
    my( $self, $got, $type, $expect ) = @@_;

d733 4
a736 6

    local $Level = $Level + 1;
    return $self->diag(<<"DIAGNOSTIC");
    $got
        $type
    $expect
d740 1
d744 1
a744 1
    my( $pack, $file, $line ) = $self->caller(1);
d774 1
a774 1
    my( $self, $reason ) = @@_;
d788 1
d794 1
a794 1
Skips the current test, reporting C<$why>.
d799 1
a799 1
    my( $self, $why ) = @@_;
d801 3
a803 1
    $self->_unoverload_str( \$why );
d805 1
a805 1
    lock( $self->{Curr_Test} );
d808 7
a814 9
    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
        {
            'ok'      => 1,
            actual_ok => 1,
            name      => '',
            type      => 'skip',
            reason    => $why,
        }
    );
d817 4
a820 4
    $out .= " $self->{Curr_Test}" if $self->use_numbers;
    $out .= " # skip";
    $out .= " $why"               if length $why;
    $out .= "\n";
d827 1
d833 1
a833 1
Like C<skip()>, only it will declare the test as failing and TODO.  Similar
d841 1
a841 1
    my( $self, $why ) = @@_;
d844 3
a846 1
    lock( $self->{Curr_Test} );
d849 7
a855 9
    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
        {
            'ok'      => 1,
            actual_ok => 0,
            name      => '',
            type      => 'todo_skip',
            reason    => $why,
        }
    );
d858 2
a859 2
    $out .= " $self->{Curr_Test}" if $self->use_numbers;
    $out .= " # TODO & SKIP $why\n";
d866 1
d874 1
a874 1
Like C<skip()>, only it skips all the rest of the tests you plan to run
d877 1
a877 1
If you're running under C<no_plan>, it skips once and terminates the
d899 1
a899 1
Takes a quoted regular expression produced by C<qr//>, or a string
d903 1
a903 1
regular expression, or C<undef> if its argument is not recognised.
d905 1
a905 1
For example, a version of C<like()>, sans the useful diagnostic messages,
d918 1
d920 1
a920 1
    my( $self, $regex ) = @@_;
d925 1
a925 1
    my( $re, $opts );
d928 1
a928 1
    if( _is_qr($regex) ) {
d932 3
a934 3
    elsif(( $re, $opts )        = $regex =~ m{^ /(.*)/ (\w*) $ }sx              or
          ( undef, $re, $opts ) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
    )
d940 1
a940 10
}

sub _is_qr {
    my $regex = shift;

    # is_regexp() checks for regexes in a robust manner, say if they're
    # blessed.
    return re::is_regexp($regex) if defined &re::is_regexp;
    return ref $regex eq 'Regexp';
}
d943 1
a943 1
    my( $self, $this, $regex, $cmp, $name ) = @@_;
d945 1
a945 1
    my $ok           = 0;
d947 1
a947 2
    unless( defined $usable_regex ) {
        local $Level = $Level + 1;
a953 2
        ## no critic (BuiltinFunctions::ProhibitStringyEval)

d957 1
a957 1
        local( $@@, $!, $SIG{__DIE__} );    # isolate eval
d959 1
a959 2
        # Yes, it has to look like this or 5.4.5 won't see the #line
        # directive.
d970 1
a970 1
    unless($ok) {
d973 1
a973 3

        local $Level = $Level + 1;
        $self->diag( sprintf <<'DIAGNOSTIC', $this, $match, $regex );
d983 1
d994 1
a994 4
Works like eval BLOCK except it ensures it has no effect on the rest
of the test (ie. C<$@@> is not set) nor is effected by outside
interference (ie. C<$SIG{__DIE__}>) and works around some quirks in older
Perls.
d996 1
a996 1
C<$error> is what would normally be in C<$@@>.
d1003 8
a1010 15
    my( $self, $code, %opts ) = @@_;

    my $error;
    my $return;
    {
        local $!;               # eval can mess up $!
        local $@@;               # don't set $@@ in the test
        local $SIG{__DIE__};    # don't trip an outside DIE handler.
        $return = eval { $code->() };
        $error = $@@;
    }

    die $error if $error and $opts{die_on_fail};

    return wantarray ? ( $return, $error ) : $return;
d1020 1
a1020 1
Determines if the given C<$thing> can be used as a filehandle.
d1025 1
a1025 1
    my $self     = shift;
d1029 2
a1030 2
    return 1 if ref $maybe_fh  eq 'GLOB';    # its a glob ref
    return 1 if ref \$maybe_fh eq 'GLOB';    # its a glob
d1034 1
a1034 1
           eval { ( tied($maybe_fh) || '' )->can('TIEHANDLE') };
d1037 1
d1050 1
a1050 1
How far up the call stack should C<$Test> look when reporting where the
d1070 1
a1070 1
    my( $self, $level ) = @@_;
d1078 1
d1103 1
a1103 1
    my( $self, $use_nums ) = @@_;
d1111 1
d1117 1
a1117 1
C<diag()>.
d1140 1
a1140 1
        my( $self, $no ) = @@_;
d1148 2
a1149 2
    no strict 'refs';    ## no critic
    *{ __PACKAGE__ . '::' . $method } = $code;
d1152 1
d1168 1
a1168 1
Prints out the given C<@@msgs>.  Like C<print>, arguments are simply
d1171 2
a1172 2
Normally, it uses the C<failure_output()> handle, but if this is for a
TODO test, the C<todo_output()> handle is used.
d1180 1
a1180 1
Returns false.  Why?  Because C<diag()> is often used in conjunction with
d1191 1
a1191 29
    my $self = shift;

    $self->_print_comment( $self->_diag_fh, @@_ );
}

=item B<note>

    $Test->note(@@msgs);

Like C<diag()>, but it prints to the C<output()> handle so it will not
normally be seen by the user except in verbose mode.

=cut

sub note {
    my $self = shift;

    $self->_print_comment( $self->output, @@_ );
}

sub _diag_fh {
    my $self = shift;

    local $Level = $Level + 1;
    return $self->in_todo ? $self->todo_output : $self->failure_output;
}

sub _print_comment {
    my( $self, $fh, @@msgs ) = @@_;
d1203 5
a1207 2
    # Escape the beginning, _print will take care of the rest.
    $msg =~ s/^/# /;
d1210 1
a1210 1
    $self->_print_to_fh( $fh, $msg );
a1214 32
=item B<explain>

    my @@dump = $Test->explain(@@msgs);

Will dump the contents of any references in a human readable format.
Handy for things like...

    is_deeply($have, $want) || diag explain $have;

or

    is_deeply($have, $want) || note explain $have;

=cut

sub explain {
    my $self = shift;

    return map {
        ref $_
          ? do {
            $self->_try(sub { require Data::Dumper }, die_on_fail => 1);

            my $dumper = Data::Dumper->new( [$_] );
            $dumper->Indent(1)->Terse(1);
            $dumper->Sortkeys(1) if $dumper->can("Sortkeys");
            $dumper->Dump;
          }
          : $_
    } @@_;
}

d1221 1
a1221 1
Prints to the C<output()> filehandle.
d1228 1
a1228 6
    my $self = shift;
    return $self->_print_to_fh( $self->output, @@_ );
}

sub _print_to_fh {
    my( $self, $fh, @@msgs ) = @@_;
d1236 2
a1237 1
    local( $\, $", $, ) = ( undef, ' ', '' );
d1241 1
a1241 1
    $msg =~ s{\n(?!\z)}{\n# }sg;
d1244 1
a1244 1
    $msg .= "\n" unless $msg =~ /\n\z/;
d1246 1
a1246 1
    return print $fh $msg;
d1249 20
d1271 2
a1272 1
=item B<failure_output>
d1274 1
a1274 1
=item B<todo_output>
d1276 1
a1276 8
    my $filehandle = $Test->output;
    $Test->output($filehandle);
    $Test->output($filename);
    $Test->output(\$scalar);

These methods control where Test::Builder will print its output.
They take either an open C<$filehandle>, a C<$filename> to open and write to
or a C<$scalar> reference to append to.  It will always return a C<$filehandle>.
d1278 1
a1278 1
B<output> is where normal "ok/not ok" test output goes.
d1280 2
a1281 1
Defaults to STDOUT.
d1283 1
a1283 3
B<failure_output> is where diagnostic output on test failures and
C<diag()> goes.  It is normally not read by Test::Harness and instead is
displayed to the user.
d1287 6
a1292 3
C<todo_output> is used instead of C<failure_output()> for the
diagnostics of a failing TODO test.  These will not be seen by the
user.
d1299 1
a1299 1
    my( $self, $fh ) = @@_;
d1308 1
a1308 1
    my( $self, $fh ) = @@_;
d1317 1
a1317 1
    my( $self, $fh ) = @@_;
d1325 1
a1333 12
    elsif( ref $file_or_fh eq 'SCALAR' ) {
        # Scalar refs as filehandles was added in 5.8.
        if( $] >= 5.008 ) {
            open $fh, ">>", $file_or_fh
              or $self->croak("Can't open scalar ref $file_or_fh: $!");
        }
        # Emulate scalar ref filehandles with a tie.
        else {
            $fh = Test::Builder::IO::Scalar->new($file_or_fh)
              or $self->croak("Can't tie scalar ref $file_or_fh");
        }
    }
d1335 4
a1338 3
        open $fh, ">", $file_or_fh
          or $self->croak("Can't open test output log $file_or_fh: $!");
        _autoflush($fh);
d1344 1
a1349 2

    return;
a1351 1
my( $Testout, $Testerr );
d1360 4
a1363 4
    _autoflush($Testout);
    _autoflush( \*STDOUT );
    _autoflush($Testerr);
    _autoflush( \*STDERR );
d1365 4
a1368 1
    $self->reset_outputs;
a1369 2
    return;
}
d1371 1
d1373 1
a1373 4
    my $self = shift;

    return if $self->{Opened_Testhandles};

d1376 3
a1378 24
    open( $Testout, ">&STDOUT" ) or die "Can't dup STDOUT:  $!";
    open( $Testerr, ">&STDERR" ) or die "Can't dup STDERR:  $!";

    #    $self->_copy_io_layers( \*STDOUT, $Testout );
    #    $self->_copy_io_layers( \*STDERR, $Testerr );

    $self->{Opened_Testhandles} = 1;

    return;
}

sub _copy_io_layers {
    my( $self, $src, $dst ) = @@_;

    $self->_try(
        sub {
            require PerlIO;
            my @@src_layers = PerlIO::get_layers($src);

            binmode $dst, join " ", map ":$_", @@src_layers if @@src_layers;
        }
    );

    return;
a1380 17
=item reset_outputs

  $tb->reset_outputs;

Resets all the output filehandles back to their defaults.

=cut

sub reset_outputs {
    my $self = shift;

    $self->output        ($Testout);
    $self->failure_output($Testerr);
    $self->todo_output   ($Testout);

    return;
}
d1387 1
a1387 1
point where the original test function was called (C<< $tb->caller >>).
d1394 1
a1394 1
point where the original test function was called (C<< $tb->caller >>).
d1402 2
a1403 2
    my( $pack, $file, $line ) = $self->caller;
    return join( "", @@_ ) . " at $file line $line.\n";
d1408 1
a1408 1
    return warn $self->_message_at_caller(@@_);
d1413 1
a1413 1
    return die $self->_message_at_caller(@@_);
d1416 8
d1447 1
a1447 1
    my( $self, $num ) = @@_;
d1449 1
a1449 1
    lock( $self->{Curr_Test} );
d1451 4
d1461 8
a1468 10
            for( $start .. $num - 1 ) {
                $test_results->[$_] = &share(
                    {
                        'ok'      => 1,
                        actual_ok => undef,
                        reason    => 'incrementing test number',
                        type      => 'unknown',
                        name      => undef
                    }
                );
d1479 1
d1501 1
a1501 1
Like C<summary()>, but with a lot more detail.
d1515 1
a1515 1
tests.
d1528 1
a1528 1
printing any test output, for example, when C<current_test()> is changed.
d1530 2
a1531 2
its type is 'unknown'.  These details for these tests are filled in.
They are considered ok, but the name and actual_ok is left C<undef>.
d1537 1
a1537 1
      { ok        => 1,   # logically, the test passed since its todo
d1556 8
a1563 12
If the current tests are considered "TODO" it will return the reason,
if any.  This reason can come from a C<$TODO> variable or the last call
to C<todo_start()>.

Since a TODO test does not need a reason, this function can return an
empty string even when inside a TODO block.  Use C<< $Test->in_todo >>
to determine if you are currently inside a TODO block.

C<todo()> is about finding the right package to look for C<$TODO> in.  It's
pretty good at guessing the right package to look at.  It first looks for
the caller based on C<$Level + 1>, since C<todo()> is usually called inside
a test function.  As a last resort it will use C<exported_to()>.
d1566 1
a1566 1
for the C<$TODO> variable.  If you want to be sure, tell it explicitly
d1572 1
a1572 3
    my( $self, $pack ) = @@_;

    return $self->{Todo} if defined $self->{Todo};
d1574 2
a1575 3
    local $Level = $Level + 1;
    my $todo = $self->find_TODO($pack);
    return $todo if defined $todo;
d1577 3
a1579 120
    return '';
}

=item B<find_TODO>

    my $todo_reason = $Test->find_TODO();
    my $todo_reason = $Test->find_TODO($pack):

Like C<todo()> but only returns the value of C<$TODO> ignoring
C<todo_start()>.

=cut

sub find_TODO {
    my( $self, $pack ) = @@_;

    $pack = $pack || $self->caller(1) || $self->exported_to;
    return unless $pack;

    no strict 'refs';    ## no critic
    return ${ $pack . '::TODO' };
}

=item B<in_todo>

    my $in_todo = $Test->in_todo;

Returns true if the test is currently inside a TODO block.

=cut

sub in_todo {
    my $self = shift;

    local $Level = $Level + 1;
    return( defined $self->{Todo} || $self->find_TODO ) ? 1 : 0;
}

=item B<todo_start>

    $Test->todo_start();
    $Test->todo_start($message);

This method allows you declare all subsequent tests as TODO tests, up until
the C<todo_end> method has been called.

The C<TODO:> and C<$TODO> syntax is generally pretty good about figuring out
whether or not we're in a TODO test.  However, often we find that this is not
possible to determine (such as when we want to use C<$TODO> but
the tests are being executed in other packages which can't be inferred
beforehand).

Note that you can use this to nest "todo" tests

 $Test->todo_start('working on this');
 # lots of code
 $Test->todo_start('working on that');
 # more code
 $Test->todo_end;
 $Test->todo_end;

This is generally not recommended, but large testing systems often have weird
internal needs.

We've tried to make this also work with the TODO: syntax, but it's not
guaranteed and its use is also discouraged:

 TODO: {
     local $TODO = 'We have work to do!';
     $Test->todo_start('working on this');
     # lots of code
     $Test->todo_start('working on that');
     # more code
     $Test->todo_end;
     $Test->todo_end;
 }

Pick one style or another of "TODO" to be on the safe side.

=cut

sub todo_start {
    my $self = shift;
    my $message = @@_ ? shift : '';

    $self->{Start_Todo}++;
    if( $self->in_todo ) {
        push @@{ $self->{Todo_Stack} } => $self->todo;
    }
    $self->{Todo} = $message;

    return;
}

=item C<todo_end>

 $Test->todo_end;

Stops running tests as "TODO" tests.  This method is fatal if called without a
preceding C<todo_start> method call.

=cut

sub todo_end {
    my $self = shift;

    if( !$self->{Start_Todo} ) {
        $self->croak('todo_end() called without todo_start()');
    }

    $self->{Start_Todo}--;

    if( $self->{Start_Todo} && @@{ $self->{Todo_Stack} } ) {
        $self->{Todo} = pop @@{ $self->{Todo_Stack} };
    }
    else {
        delete $self->{Todo};
    }

    return;
d1588 1
a1588 5
Like the normal C<caller()>, except it reports according to your C<level()>.

C<$height> will be added to the C<level()>.

If C<caller()> winds up off the top of the stack it report the highest context.
d1592 2
a1593 2
sub caller {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
    my( $self, $height ) = @@_;
d1596 1
a1596 6
    my $level = $self->level + $height + 1;
    my @@caller;
    do {
        @@caller = CORE::caller( $level );
        $level--;
    } until @@caller;
d1622 5
a1626 5
    $self->_whoa( $self->{Curr_Test} < 0, 'Says here you ran a negative number of tests!' );
    $self->_whoa( $self->{Curr_Test} != @@{ $self->{Test_Results} },
        'Somehow you got a different number of results than tests ran!' );

    return;
d1633 2
a1634 2
A sanity check, similar to C<assert()>.  If the C<$check> is true, something
has gone horribly wrong.  It will die with the given C<$description> and
d1640 2
a1641 2
    my( $self, $check, $desc ) = @@_;
    if($check) {
a1647 2

    return;
d1654 3
a1656 3
Perl seems to have some trouble with exiting inside an C<END> block.  5.005_03
and 5.6.1 both seem to do odd things.  Instead, this function edits C<$?>
directly.  It should B<only> be called from inside an C<END> block.  It
d1662 1
a1662 1
    $? = $_[0];    ## no critic (Variables::RequireLocalizedPunctuationVars)
d1667 1
d1674 12
d1689 1
a1689 1
    my $real_exit_code = $?;
d1693 1
a1693 10
    if( $self->{Original_Pid} != $$ ) {
        return;
    }

    # Ran tests but never declared a plan or hit done_testing
    if( !$self->{Have_Plan} and $self->{Curr_Test} ) {
        $self->diag("Tests were run but no plan was declared and done_testing() was not seen.");
    }

    # Exit if plan() was never called.  This is so "require Test::Simple"
a1694 4
    if( !$self->{Have_Plan} ) {
        return;
    }

d1696 7
a1702 2
    if( $self->{Bailed_Out} ) {
        return;
d1707 1
a1707 1
    if(@@$test_results) {
d1710 1
a1710 1
            $self->_output_plan($self->{Curr_Test}) unless $self->no_header;
d1717 2
a1718 2
        my $empty_result = &share( {} );
        for my $idx ( 0 .. $self->{Expected_Tests} - 1 ) {
d1723 2
a1724 1
        my $num_failed = grep !$_->{'ok'}, @@{$test_results}[ 0 .. $self->{Curr_Test} - 1 ];
d1728 7
a1734 1
        if( $num_extra != 0 ) {
d1737 1
a1737 1
Looks like you planned $self->{Expected_Tests} test$s but ran $self->{Curr_Test}.
d1741 1
a1741 1
        if($num_failed) {
d1752 1
a1752 1
        if($real_exit_code) {
d1754 1
a1754 1
Looks like your test exited with $real_exit_code just after $self->{Curr_Test}.
d1757 1
a1757 1
            _my_exit($real_exit_code) && return;
d1761 1
a1761 1
        if($num_failed) {
d1771 1
a1771 1
        _my_exit($exit_code) && return;
d1773 2
a1774 2
    elsif( $self->{Skip_All} ) {
        _my_exit(0) && return;
d1776 3
a1778 3
    elsif($real_exit_code) {
        $self->diag(<<"FAIL");
Looks like your test exited with $real_exit_code before it could output anything.
d1780 1
a1780 1
        _my_exit($real_exit_code) && return;
d1784 1
a1784 1
        _my_exit(255) && return;
a1785 2

    $self->_whoa( 1, "We fell off the end of _ending()" );
d1810 1
d1815 1
a1815 1
the test number using C<current_test()> they will all be effected.
a1822 15
=head1 MEMORY

An informative hash, accessable via C<<details()>>, is stored for each
test you perform.  So memory usage will scale linearly with each test
run. Although this is not a problem for most test suites, it can
become an issue if you do large (hundred thousands to million)
combinatorics tests in the same run.

In such cases, you are advised to either split the test file into smaller
ones, or use a reverse approach, doing "normal" (code) compares and
triggering fail() should anything go unexpected.

Future versions of Test::Builder will have a way to turn history off.


d1839 2
a1840 2
Copyright 2002-2008 by chromatic E<lt>chromatic@@wgz.orgE<gt> and
                       Michael G Schwern E<lt>schwern@@pobox.comE<gt>.
d1842 1
a1842 1
This program is free software; you can redistribute it and/or
a1849 1

@


