head	1.25;
access;
symbols
	OPENBSD_4_8:1.24.0.4
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	PERL_5_10_1:1.1.1.12
	OPENBSD_4_6:1.22.0.6
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.2
	OPENBSD_4_5_BASE:1.22
	PERL_5_10_0:1.1.1.11
	OPENBSD_4_4:1.18.0.4
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.17.0.2
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	PERL_5_8_8:1.1.1.10
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	PERL_5_8_6:1.1.1.9
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.13.0.4
	OPENBSD_3_4_BASE:1.13
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.9.0.6
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.7.0.6
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_8:1.7.0.4
	OPENBSD_2_8_BASE:1.7
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.6
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.4
	OPENBSD_2_1_BASE:1.2
	OPENBSD_2_0:1.2.0.2
	OPENBSD_2_0_BASE:1.2
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.25
date	2010.09.24.14.59.38;	author millert;	state dead;
branches;
next	1.24;

1.24
date	2009.10.13.01.25.48;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2008.10.12.19.15.31;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.01.13.56.11;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.01.13.31.33;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2008.09.29.17.36.11;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.29.00.31.31;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.15.16.50.41;	author espie;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.28.19.23.06;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.07.21.33.05;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2003.12.03.03.02.37;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.03.20.04.04;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.03.16.08.31;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.31.22.54.15;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.24.18.35.29;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.08.19.56.44;	author espie;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.06.17.06.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	99.05.09.16.34.10;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	99.05.09.02.16.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	99.04.29.22.51.51;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	97.11.30.07.57.26;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	96.10.04.08.51.44;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.39;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.39;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.03;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.42;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.27;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.02;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.16;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.46.53;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2005.01.15.21.17.16;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2006.03.28.18.48.43;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2008.09.29.17.18.33;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2009.10.12.18.10.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.25
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package ExtUtils::MM_Unix;

require 5.006;

use strict;

use Carp;
use ExtUtils::MakeMaker::Config;
use File::Basename qw(basename dirname);
use DirHandle;

our %Config_Override;

use ExtUtils::MakeMaker qw($Verbose neatvalue);

# If we make $VERSION an our variable parse_version() breaks
use vars qw($VERSION);
$VERSION = '6.55_02';

require ExtUtils::MM_Any;
our @@ISA = qw(ExtUtils::MM_Any);

my %Is;
BEGIN { 
    $Is{OS2}     = $^O eq 'os2';
    $Is{Win32}   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
    $Is{Dos}     = $^O eq 'dos';
    $Is{VMS}     = $^O eq 'VMS';
    $Is{OSF}     = $^O eq 'dec_osf';
    $Is{IRIX}    = $^O eq 'irix';
    $Is{NetBSD}  = $^O eq 'netbsd';
    $Is{Interix} = $^O eq 'interix';
    $Is{SunOS4}  = $^O eq 'sunos';
    $Is{Solaris} = $^O eq 'solaris';
    $Is{SunOS}   = $Is{SunOS4} || $Is{Solaris};
    $Is{BSD}     = ($^O =~ /^(?:free|net|open)bsd$/ or
                   grep( $^O eq $_, qw(bsdos interix dragonfly) )
                  );
}

BEGIN {
    if( $Is{VMS} ) {
        # For things like vmsify()
        require VMS::Filespec;
        VMS::Filespec->import;
    }
}


=head1 NAME

ExtUtils::MM_Unix - methods used by ExtUtils::MakeMaker

=head1 SYNOPSIS

C<require ExtUtils::MM_Unix;>

=head1 DESCRIPTION

The methods provided by this package are designed to be used in
conjunction with ExtUtils::MakeMaker. When MakeMaker writes a
Makefile, it creates one or more objects that inherit their methods
from a package C<MM>. MM itself doesn't provide any methods, but it
ISA ExtUtils::MM_Unix class. The inheritance tree of MM lets operating
specific packages take the responsibility for all the methods provided
by MM_Unix. We are trying to reduce the number of the necessary
overrides by defining rather primitive operations within
ExtUtils::MM_Unix.

If you are going to write a platform specific MM package, please try
to limit the necessary overrides to primitive methods, and if it is not
possible to do so, let's work out how to achieve that gain.

If you are overriding any of these methods in your Makefile.PL (in the
MY class), please report that to the makemaker mailing list. We are
trying to minimize the necessary method overrides and switch to data
driven Makefile.PLs wherever possible. In the long run less methods
will be overridable via the MY class.

=head1 METHODS

The following description of methods is still under
development. Please refer to the code for not suitably documented
sections and complain loudly to the makemaker@@perl.org mailing list.
Better yet, provide a patch.

Not all of the methods below are overridable in a
Makefile.PL. Overridable methods are marked as (o). All methods are
overridable by a platform specific MM_*.pm file.

Cross-platform methods are being moved into MM_Any.  If you can't find
something that used to be in here, look in MM_Any.

=cut

# So we don't have to keep calling the methods over and over again,
# we have these globals to cache the values.  Faster and shrtr.
my $Curdir  = __PACKAGE__->curdir;
my $Rootdir = __PACKAGE__->rootdir;
my $Updir   = __PACKAGE__->updir;


=head2 Methods

=over 4

=item os_flavor

Simply says that we're Unix.

=cut

sub os_flavor {
    return('Unix');
}


=item c_o (o)

Defines the suffix rules to compile different flavors of C files to
object files.

=cut

sub c_o {
# --- Translation Sections ---

    my($self) = shift;
    return '' unless $self->needs_linking();
    my(@@m);
    
    my $command = '$(CCCMD)';
    my $flags   = '$(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE)';
    
    if (my $cpp = $Config{cpprun}) {
        my $cpp_cmd = $self->const_cccmd;
        $cpp_cmd =~ s/^CCCMD\s*=\s*\$\(CC\)/$cpp/;
        push @@m, qq{
.c.i:
	$cpp_cmd $flags \$*.c > \$*.i
};
    }

    push @@m, qq{
.c.s:
	$command -S $flags \$*.c

.c\$(OBJ_EXT):
	$command $flags \$*.c

.cpp\$(OBJ_EXT):
	$command $flags \$*.cpp

.cxx\$(OBJ_EXT):
	$command $flags \$*.cxx

.cc\$(OBJ_EXT):
	$command $flags \$*.cc
};

    push @@m, qq{
.C\$(OBJ_EXT):
	$command $flags \$*.C
} if !$Is{OS2} and !$Is{Win32} and !$Is{Dos}; #Case-specific

    return join "", @@m;
}

=item cflags (o)

Does very much the same as the cflags script in the perl
distribution. It doesn't return the whole compiler command line, but
initializes all of its parts. The const_cccmd method then actually
returns the definition of the CCCMD macro which uses these parts.

=cut

#'

sub cflags {
    my($self,$libperl)=@@_;
    return $self->{CFLAGS} if $self->{CFLAGS};
    return '' unless $self->needs_linking();

    my($prog, $uc, $perltype, %cflags);
    $libperl ||= $self->{LIBPERL_A} || "libperl$self->{LIB_EXT}" ;
    $libperl =~ s/\.\$\(A\)$/$self->{LIB_EXT}/;

    @@cflags{qw(cc ccflags optimize shellflags)}
	= @@Config{qw(cc ccflags optimize shellflags)};
    my($optdebug) = "";

    $cflags{shellflags} ||= '';

    my(%map) =  (
		D =>   '-DDEBUGGING',
		E =>   '-DEMBED',
		DE =>  '-DDEBUGGING -DEMBED',
		M =>   '-DEMBED -DMULTIPLICITY',
		DM =>  '-DDEBUGGING -DEMBED -DMULTIPLICITY',
		);

    if ($libperl =~ /libperl(\w*)\Q$self->{LIB_EXT}/){
	$uc = uc($1);
    } else {
	$uc = ""; # avoid warning
    }
    $perltype = $map{$uc} ? $map{$uc} : "";

    if ($uc =~ /^D/) {
	$optdebug = "-g";
    }


    my($name);
    ( $name = $self->{NAME} . "_cflags" ) =~ s/:/_/g ;
    if ($prog = $Config{$name}) {
	# Expand hints for this extension via the shell
	print STDOUT "Processing $name hint:\n" if $Verbose;
	my(@@o)=`cc=\"$cflags{cc}\"
	  ccflags=\"$cflags{ccflags}\"
	  optimize=\"$cflags{optimize}\"
	  perltype=\"$cflags{perltype}\"
	  optdebug=\"$cflags{optdebug}\"
	  eval '$prog'
	  echo cc=\$cc
	  echo ccflags=\$ccflags
	  echo optimize=\$optimize
	  echo perltype=\$perltype
	  echo optdebug=\$optdebug
	  `;
	foreach my $line (@@o){
	    chomp $line;
	    if ($line =~ /(.*?)=\s*(.*)\s*$/){
		$cflags{$1} = $2;
		print STDOUT "	$1 = $2\n" if $Verbose;
	    } else {
		print STDOUT "Unrecognised result from hint: '$line'\n";
	    }
	}
    }

    if ($optdebug) {
	$cflags{optimize} = $optdebug;
    }

    for (qw(ccflags optimize perltype)) {
        $cflags{$_} ||= '';
	$cflags{$_} =~ s/^\s+//;
	$cflags{$_} =~ s/\s+/ /g;
	$cflags{$_} =~ s/\s+$//;
	$self->{uc $_} ||= $cflags{$_};
    }

    if ($self->{POLLUTE}) {
	$self->{CCFLAGS} .= ' -DPERL_POLLUTE ';
    }

    my $pollute = '';
    if ($Config{usemymalloc} and not $Config{bincompat5005}
	and not $Config{ccflags} =~ /-DPERL_POLLUTE_MALLOC\b/
	and $self->{PERL_MALLOC_OK}) {
	$pollute = '$(PERL_MALLOC_DEF)';
    }

    $self->{CCFLAGS}  = quote_paren($self->{CCFLAGS});
    $self->{OPTIMIZE} = quote_paren($self->{OPTIMIZE});

    return $self->{CFLAGS} = qq{
CCFLAGS = $self->{CCFLAGS}
OPTIMIZE = $self->{OPTIMIZE}
PERLTYPE = $self->{PERLTYPE}
MPOLLUTE = $pollute
};

}


=item const_cccmd (o)

Returns the full compiler call for C programs and stores the
definition in CONST_CCCMD.

=cut

sub const_cccmd {
    my($self,$libperl)=@@_;
    return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
    return '' unless $self->needs_linking();
    return $self->{CONST_CCCMD} =
	q{CCCMD = $(CC) -c $(PASTHRU_INC) $(INC) \\
	$(CCFLAGS) $(OPTIMIZE) $(COPTS) \\
	$(PERLTYPE) $(MPOLLUTE) $(DEFINE_VERSION) \\
	$(XS_DEFINE_VERSION)};
}

=item const_config (o)

Defines a couple of constants in the Makefile that are imported from
%Config.

=cut

sub const_config {
# --- Constants Sections ---

    my($self) = shift;
    my @@m = <<"END";

# These definitions are from config.sh (via $INC{'Config.pm'}).
# They may have been overridden via Makefile.PL or on the command line.
END

    my(%once_only);
    foreach my $key (@@{$self->{CONFIG}}){
        # SITE*EXP macros are defined in &constants; avoid duplicates here
        next if $once_only{$key};
        $self->{uc $key} = quote_paren($self->{uc $key});
        push @@m, uc($key) , ' = ' , $self->{uc $key}, "\n";
        $once_only{$key} = 1;
    }
    join('', @@m);
}

=item const_loadlibs (o)

Defines EXTRALIBS, LDLOADLIBS, BSLOADLIBS, LD_RUN_PATH. See
L<ExtUtils::Liblist> for details.

=cut

sub const_loadlibs {
    my($self) = shift;
    return "" unless $self->needs_linking;
    my @@m;
    push @@m, qq{
# $self->{NAME} might depend on some other libraries:
# See ExtUtils::Liblist for details
#
};
    for my $tmp (qw/
         EXTRALIBS LDLOADLIBS BSLOADLIBS
         /) {
        next unless defined $self->{$tmp};
        push @@m, "$tmp = $self->{$tmp}\n";
    }
    # don't set LD_RUN_PATH if empty
    for my $tmp (qw/
         LD_RUN_PATH
         /) {
        next unless $self->{$tmp};
        push @@m, "$tmp = $self->{$tmp}\n";
    }
    return join "", @@m;
}

=item constants (o)

  my $make_frag = $mm->constants;

Prints out macros for lots of constants.

=cut

sub constants {
    my($self) = @@_;
    my @@m = ();

    $self->{DFSEP} = '$(DIRFILESEP)';  # alias for internal use

    for my $macro (qw(

              AR_STATIC_ARGS DIRFILESEP DFSEP
              NAME NAME_SYM 
              VERSION    VERSION_MACRO    VERSION_SYM DEFINE_VERSION
              XS_VERSION XS_VERSION_MACRO             XS_DEFINE_VERSION
              INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB
              INST_MAN1DIR INST_MAN3DIR
              MAN1EXT      MAN3EXT
              INSTALLDIRS INSTALL_BASE DESTDIR PREFIX
              PERLPREFIX      SITEPREFIX      VENDORPREFIX
                   ),
                   (map { ("INSTALL".$_,
                          "DESTINSTALL".$_)
                        } $self->installvars),
                   qw(
              PERL_LIB    
              PERL_ARCHLIB
              LIBPERL_A MYEXTLIB
              FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE 
              PERLMAINCC PERL_SRC PERL_INC 
              PERL            FULLPERL          ABSPERL
              PERLRUN         FULLPERLRUN       ABSPERLRUN
              PERLRUNINST     FULLPERLRUNINST   ABSPERLRUNINST
              PERL_CORE
              PERM_DIR PERM_RW PERM_RWX

	      ) ) 
    {
	next unless defined $self->{$macro};

        # pathnames can have sharp signs in them; escape them so
        # make doesn't think it is a comment-start character.
        $self->{$macro} =~ s/#/\\#/g;
	push @@m, "$macro = $self->{$macro}\n";
    }

    push @@m, qq{
MAKEMAKER   = $self->{MAKEMAKER}
MM_VERSION  = $self->{MM_VERSION}
MM_REVISION = $self->{MM_REVISION}
};

    push @@m, q{
# FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).
# BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)
# PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)
# DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.
};

    for my $macro (qw/
              MAKE
	      FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT
	      LDFROM LINKTYPE BOOTDEP
	      /	) 
    {
	next unless defined $self->{$macro};
	push @@m, "$macro = $self->{$macro}\n";
    }

    push @@m, "
# Handy lists of source code files:
XS_FILES = ".$self->wraplist(sort keys %{$self->{XS}})."
C_FILES  = ".$self->wraplist(@@{$self->{C}})."
O_FILES  = ".$self->wraplist(@@{$self->{O_FILES}})."
H_FILES  = ".$self->wraplist(@@{$self->{H}})."
MAN1PODS = ".$self->wraplist(sort keys %{$self->{MAN1PODS}})."
MAN3PODS = ".$self->wraplist(sort keys %{$self->{MAN3PODS}})."
";


    push @@m, q{
# Where is the Config information that we are using/depend on
CONFIGDEP = $(PERL_ARCHLIB)$(DFSEP)Config.pm $(PERL_INC)$(DFSEP)config.h
};


    push @@m, qq{
# Where to build things
INST_LIBDIR      = $self->{INST_LIBDIR}
INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}

INST_AUTODIR     = $self->{INST_AUTODIR}
INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}

INST_STATIC      = $self->{INST_STATIC}
INST_DYNAMIC     = $self->{INST_DYNAMIC}
INST_BOOT        = $self->{INST_BOOT}
};


    push @@m, qq{
# Extra linker info
EXPORT_LIST        = $self->{EXPORT_LIST}
PERL_ARCHIVE       = $self->{PERL_ARCHIVE}
PERL_ARCHIVE_AFTER = $self->{PERL_ARCHIVE_AFTER}
};

    push @@m, "

TO_INST_PM = ".$self->wraplist(sort keys %{$self->{PM}})."

PM_TO_BLIB = ".$self->wraplist(%{$self->{PM}})."
";

    join('',@@m);
}


=item depend (o)

Same as macro for the depend attribute.

=cut

sub depend {
    my($self,%attribs) = @@_;
    my(@@m,$key,$val);
    while (($key,$val) = each %attribs){
	last unless defined $key;
	push @@m, "$key : $val\n";
    }
    join "", @@m;
}


=item init_DEST

  $mm->init_DEST

Defines the DESTDIR and DEST* variables paralleling the INSTALL*.

=cut

sub init_DEST {
    my $self = shift;

    # Initialize DESTDIR
    $self->{DESTDIR} ||= '';

    # Make DEST variables.
    foreach my $var ($self->installvars) {
        my $destvar = 'DESTINSTALL'.$var;
        $self->{$destvar} ||= '$(DESTDIR)$(INSTALL'.$var.')';
    }
}


=item init_dist

  $mm->init_dist;

Defines a lot of macros for distribution support.

  macro         description                     default

  TAR           tar command to use              tar
  TARFLAGS      flags to pass to TAR            cvf

  ZIP           zip command to use              zip
  ZIPFLAGS      flags to pass to ZIP            -r

  COMPRESS      compression command to          gzip --best
                use for tarfiles
  SUFFIX        suffix to put on                .gz 
                compressed files

  SHAR          shar command to use             shar

  PREOP         extra commands to run before
                making the archive 
  POSTOP        extra commands to run after
                making the archive

  TO_UNIX       a command to convert linefeeds
                to Unix style in your archive 

  CI            command to checkin your         ci -u
                sources to version control
  RCS_LABEL     command to label your sources   rcs -Nv$(VERSION_SYM): -q
                just after CI is run

  DIST_CP       $how argument to manicopy()     best
                when the distdir is created

  DIST_DEFAULT  default target to use to        tardist
                create a distribution

  DISTVNAME     name of the resulting archive   $(DISTNAME)-$(VERSION)
                (minus suffixes)

=cut

sub init_dist {
    my $self = shift;

    $self->{TAR}      ||= 'tar';
    $self->{TARFLAGS} ||= 'cvf';
    $self->{ZIP}      ||= 'zip';
    $self->{ZIPFLAGS} ||= '-r';
    $self->{COMPRESS} ||= 'gzip --best';
    $self->{SUFFIX}   ||= '.gz';
    $self->{SHAR}     ||= 'shar';
    $self->{PREOP}    ||= '$(NOECHO) $(NOOP)'; # eg update MANIFEST
    $self->{POSTOP}   ||= '$(NOECHO) $(NOOP)'; # eg remove the distdir
    $self->{TO_UNIX}  ||= '$(NOECHO) $(NOOP)';

    $self->{CI}       ||= 'ci -u';
    $self->{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';
    $self->{DIST_CP}  ||= 'best';
    $self->{DIST_DEFAULT} ||= 'tardist';

    ($self->{DISTNAME} = $self->{NAME}) =~ s{::}{-}g unless $self->{DISTNAME};
    $self->{DISTVNAME} ||= $self->{DISTNAME}.'-'.$self->{VERSION};

}

=item dist (o)

  my $dist_macros = $mm->dist(%overrides);

Generates a make fragment defining all the macros initialized in
init_dist.

%overrides can be used to override any of the above.

=cut

sub dist {
    my($self, %attribs) = @@_;

    my $make = '';
    foreach my $key (qw( 
            TAR TARFLAGS ZIP ZIPFLAGS COMPRESS SUFFIX SHAR
            PREOP POSTOP TO_UNIX
            CI RCS_LABEL DIST_CP DIST_DEFAULT
            DISTNAME DISTVNAME
           ))
    {
        my $value = $attribs{$key} || $self->{$key};
        $make .= "$key = $value\n";
    }

    return $make;
}

=item dist_basics (o)

Defines the targets distclean, distcheck, skipcheck, manifest, veryclean.

=cut

sub dist_basics {
    my($self) = shift;

    return <<'MAKE_FRAG';
distclean :: realclean distcheck
	$(NOECHO) $(NOOP)

distcheck :
	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck

skipcheck :
	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck

manifest :
	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest

veryclean : realclean
	$(RM_F) *~ */*~ *.orig */*.orig *.bak */*.bak *.old */*.old 

MAKE_FRAG

}

=item dist_ci (o)

Defines a check in target for RCS.

=cut

sub dist_ci {
    my($self) = shift;
    return q{
ci :
	$(PERLRUN) "-MExtUtils::Manifest=maniread" \\
	  -e "@@all = keys %{ maniread() };" \\
	  -e "print(qq{Executing $(CI) @@all\n}); system(qq{$(CI) @@all});" \\
	  -e "print(qq{Executing $(RCS_LABEL) ...\n}); system(qq{$(RCS_LABEL) @@all});"
};
}

=item dist_core (o)

  my $dist_make_fragment = $MM->dist_core;

Puts the targets necessary for 'make dist' together into one make
fragment.

=cut

sub dist_core {
    my($self) = shift;

    my $make_frag = '';
    foreach my $target (qw(dist tardist uutardist tarfile zipdist zipfile 
                           shdist))
    {
        my $method = $target.'_target';
        $make_frag .= "\n";
        $make_frag .= $self->$method();
    }

    return $make_frag;
}


=item B<dist_target>

  my $make_frag = $MM->dist_target;

Returns the 'dist' target to make an archive for distribution.  This
target simply checks to make sure the Makefile is up-to-date and
depends on $(DIST_DEFAULT).

=cut

sub dist_target {
    my($self) = shift;

    my $date_check = $self->oneliner(<<'CODE', ['-l']);
print 'Warning: Makefile possibly out of date with $(VERSION_FROM)'
    if -e '$(VERSION_FROM)' and -M '$(VERSION_FROM)' < -M '$(FIRST_MAKEFILE)';
CODE

    return sprintf <<'MAKE_FRAG', $date_check;
dist : $(DIST_DEFAULT) $(FIRST_MAKEFILE)
	$(NOECHO) %s
MAKE_FRAG
}

=item B<tardist_target>

  my $make_frag = $MM->tardist_target;

Returns the 'tardist' target which is simply so 'make tardist' works.
The real work is done by the dynamically named tardistfile_target()
method, tardist should have that as a dependency.

=cut

sub tardist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
tardist : $(DISTVNAME).tar$(SUFFIX)
	$(NOECHO) $(NOOP)
MAKE_FRAG
}

=item B<zipdist_target>

  my $make_frag = $MM->zipdist_target;

Returns the 'zipdist' target which is simply so 'make zipdist' works.
The real work is done by the dynamically named zipdistfile_target()
method, zipdist should have that as a dependency.

=cut

sub zipdist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
zipdist : $(DISTVNAME).zip
	$(NOECHO) $(NOOP)
MAKE_FRAG
}

=item B<tarfile_target>

  my $make_frag = $MM->tarfile_target;

The name of this target is the name of the tarball generated by
tardist.  This target does the actual work of turning the distdir into
a tarball.

=cut

sub tarfile_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
$(DISTVNAME).tar$(SUFFIX) : distdir
	$(PREOP)
	$(TO_UNIX)
	$(TAR) $(TARFLAGS) $(DISTVNAME).tar $(DISTVNAME)
	$(RM_RF) $(DISTVNAME)
	$(COMPRESS) $(DISTVNAME).tar
	$(POSTOP)
MAKE_FRAG
}

=item zipfile_target

  my $make_frag = $MM->zipfile_target;

The name of this target is the name of the zip file generated by
zipdist.  This target does the actual work of turning the distdir into
a zip file.

=cut

sub zipfile_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
$(DISTVNAME).zip : distdir
	$(PREOP)
	$(ZIP) $(ZIPFLAGS) $(DISTVNAME).zip $(DISTVNAME)
	$(RM_RF) $(DISTVNAME)
	$(POSTOP)
MAKE_FRAG
}

=item uutardist_target

  my $make_frag = $MM->uutardist_target;

Converts the tarfile into a uuencoded file

=cut

sub uutardist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
uutardist : $(DISTVNAME).tar$(SUFFIX)
	uuencode $(DISTVNAME).tar$(SUFFIX) $(DISTVNAME).tar$(SUFFIX) > $(DISTVNAME).tar$(SUFFIX)_uu
MAKE_FRAG
}


=item shdist_target

  my $make_frag = $MM->shdist_target;

Converts the distdir into a shell archive.

=cut

sub shdist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
shdist : distdir
	$(PREOP)
	$(SHAR) $(DISTVNAME) > $(DISTVNAME).shar
	$(RM_RF) $(DISTVNAME)
	$(POSTOP)
MAKE_FRAG
}


=item dlsyms (o)

Used by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.

Normally just returns an empty string.

=cut

sub dlsyms {
    return '';
}


=item dynamic_bs (o)

Defines targets for bootstrap files.

=cut

sub dynamic_bs {
    my($self, %attribs) = @@_;
    return '
BOOTSTRAP =
' unless $self->has_link_code();

    my $target = $Is{VMS} ? '$(MMS$TARGET)' : '$@@';

    return sprintf <<'MAKE_FRAG', ($target) x 5;
BOOTSTRAP = $(BASEEXT).bs

# As Mkbootstrap might not write a file (if none is required)
# we use touch to prevent make continually trying to remake it.
# The DynaLoader only reads a non-empty file.
$(BOOTSTRAP) : $(FIRST_MAKEFILE) $(BOOTDEP) $(INST_ARCHAUTODIR)$(DFSEP).exists
	$(NOECHO) $(ECHO) "Running Mkbootstrap for $(NAME) ($(BSLOADLIBS))"
	$(NOECHO) $(PERLRUN) \
		"-MExtUtils::Mkbootstrap" \
		-e "Mkbootstrap('$(BASEEXT)','$(BSLOADLIBS)');"
	$(NOECHO) $(TOUCH) %s
	$(CHMOD) $(PERM_RW) %s

$(INST_BOOT) : $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists
	$(NOECHO) $(RM_RF) %s
	- $(CP) $(BOOTSTRAP) %s
	$(CHMOD) $(PERM_RW) %s
MAKE_FRAG
}

=item dynamic_lib (o)

Defines how to produce the *.so (or equivalent) files.

=cut

sub dynamic_lib {
    my($self, %attribs) = @@_;
    return '' unless $self->needs_linking(); #might be because of a subdir

    return '' unless $self->has_link_code;

    my($otherldflags) = $attribs{OTHERLDFLAGS} || "";
    my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
    my($armaybe) = $attribs{ARMAYBE} || $self->{ARMAYBE} || ":";
    my($ldfrom) = '$(LDFROM)';
    $armaybe = 'ar' if ($Is{OSF} and $armaybe eq ':');
    my(@@m);
    my $ld_opt = $Is{OS2} ? '$(OPTIMIZE) ' : '';	# Useful on other systems too?
    my $ld_fix = $Is{OS2} ? '|| ( $(RM_F) $@@ && sh -c false )' : '';
    push(@@m,'
# This section creates the dynamically loadable $(INST_DYNAMIC)
# from $(OBJECT) and possibly $(MYEXTLIB).
ARMAYBE = '.$armaybe.'
OTHERLDFLAGS = '.$ld_opt.$otherldflags.'
INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'
INST_DYNAMIC_FIX = '.$ld_fix.'

$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
');
    if ($armaybe ne ':'){
	$ldfrom = 'tmp$(LIB_EXT)';
	push(@@m,'	$(ARMAYBE) cr '.$ldfrom.' $(OBJECT)'."\n");
	push(@@m,'	$(RANLIB) '."$ldfrom\n");
    }
    $ldfrom = "-all $ldfrom -none" if $Is{OSF};

    # The IRIX linker doesn't use LD_RUN_PATH
    my $ldrun = $Is{IRIX} && $self->{LD_RUN_PATH} ?         
                       qq{-rpath "$self->{LD_RUN_PATH}"} : '';

    # For example in AIX the shared objects/libraries from previous builds
    # linger quite a while in the shared dynalinker cache even when nobody
    # is using them.  This is painful if one for instance tries to restart
    # a failed build because the link command will fail unnecessarily 'cos
    # the shared object/library is 'busy'.
    push(@@m,'	$(RM_F) $@@
');

    my $libs = '$(LDLOADLIBS)';

    if (($Is{NetBSD} || $Is{Interix}) && $Config{'useshrplib'} eq 'true') {
	# Use nothing on static perl platforms, and to the flags needed
	# to link against the shared libperl library on shared perl
	# platforms.  We peek at lddlflags to see if we need -Wl,-R
	# or -R to add paths to the run-time library search path.
        if ($Config{'lddlflags'} =~ /-Wl,-R/) {
            $libs .= ' -L$(PERL_INC) -Wl,-R$(INSTALLARCHLIB)/CORE -Wl,-R$(PERL_ARCHLIB)/CORE -lperl';
        } elsif ($Config{'lddlflags'} =~ /-R/) {
            $libs .= ' -L$(PERL_INC) -R$(INSTALLARCHLIB)/CORE -R$(PERL_ARCHLIB)/CORE -lperl';
        }
    }

    my $ld_run_path_shell = "";
    if ($self->{LD_RUN_PATH} ne "") {
	$ld_run_path_shell = 'LD_RUN_PATH="$(LD_RUN_PATH)" ';
    }

    push @@m, sprintf <<'MAKE', $ld_run_path_shell, $ldrun, $ldfrom, $libs;
	%s$(LD) %s $(LDDLFLAGS) %s $(OTHERLDFLAGS) -o $@@ $(MYEXTLIB)	\
	  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)	\
	  $(INST_DYNAMIC_FIX)
MAKE

    push @@m, <<'MAKE';
	$(CHMOD) $(PERM_RWX) $@@
MAKE

    return join('',@@m);
}

=item exescan

Deprecated method. Use libscan instead.

=cut

sub exescan {
    my($self,$path) = @@_;
    $path;
}

=item extliblist

Called by init_others, and calls ext ExtUtils::Liblist. See
L<ExtUtils::Liblist> for details.

=cut

sub extliblist {
    my($self,$libs) = @@_;
    require ExtUtils::Liblist;
    $self->ext($libs, $Verbose);
}

=item find_perl

Finds the executables PERL and FULLPERL

=cut

sub find_perl {
    my($self, $ver, $names, $dirs, $trace) = @@_;

    if ($trace >= 2){
        print "Looking for perl $ver by these names:
@@$names
in these dirs:
@@$dirs
";
    }

    my $stderr_duped = 0;
    local *STDERR_COPY;

    unless ($Is{BSD}) {
        # >& and lexical filehandles together give 5.6.2 indigestion
        if( open(STDERR_COPY, '>&STDERR') ) {  ## no critic
            $stderr_duped = 1;
        }
        else {
            warn <<WARNING;
find_perl() can't dup STDERR: $!
You might see some garbage while we search for Perl
WARNING
        }
    }

    foreach my $name (@@$names){
        foreach my $dir (@@$dirs){
            next unless defined $dir; # $self->{PERL_SRC} may be undefined
            my ($abs, $val);
            if ($self->file_name_is_absolute($name)) {     # /foo/bar
                $abs = $name;
            } elsif ($self->canonpath($name) eq 
                     $self->canonpath(basename($name))) {  # foo
                $abs = $self->catfile($dir, $name);
            } else {                                            # foo/bar
                $abs = $self->catfile($Curdir, $name);
            }
            print "Checking $abs\n" if ($trace >= 2);
            next unless $self->maybe_command($abs);
            print "Executing $abs\n" if ($trace >= 2);

            my $version_check = qq{$abs -le "require $ver; print qq{VER_OK}"};
            $version_check = "$Config{run} $version_check"
                if defined $Config{run} and length $Config{run};

            # To avoid using the unportable 2>&1 to suppress STDERR,
            # we close it before running the command.
            # However, thanks to a thread library bug in many BSDs
            # ( http://www.freebsd.org/cgi/query-pr.cgi?pr=51535 )
            # we cannot use the fancier more portable way in here
            # but instead need to use the traditional 2>&1 construct.
            if ($Is{BSD}) {
                $val = `$version_check 2>&1`;
            } else {
                close STDERR if $stderr_duped;
                $val = `$version_check`;

                # 5.6.2's 3-arg open doesn't work with >&
                open STDERR, ">&STDERR_COPY"  ## no critic
                        if $stderr_duped;
            }

            if ($val =~ /^VER_OK/m) {
                print "Using PERL=$abs\n" if $trace;
                return $abs;
            } elsif ($trace >= 2) {
                print "Result: '$val' ".($? >> 8)."\n";
            }
        }
    }
    print STDOUT "Unable to find a perl $ver (by these names: @@$names, in these dirs: @@$dirs)\n";
    0; # false and not empty
}


=item fixin

  $mm->fixin(@@files);

Inserts the sharpbang or equivalent magic number to a set of @@files.

=cut

sub fixin {    # stolen from the pink Camel book, more or less
    my ( $self, @@files ) = @@_;

    my ($does_shbang) = $Config{'sharpbang'} =~ /^\s*\#\!/;
    for my $file (@@files) {
        my $file_new = "$file.new";
        my $file_bak = "$file.bak";

        open( my $fixin, '<', $file ) or croak "Can't process '$file': $!";
        local $/ = "\n";
        chomp( my $line = <$fixin> );
        next unless $line =~ s/^\s*\#!\s*//;    # Not a shbang file.
        # Now figure out the interpreter name.
        my ( $cmd, $arg ) = split ' ', $line, 2;
        $cmd =~ s!^.*/!!;

        # Now look (in reverse) for interpreter in absolute PATH (unless perl).
        my $interpreter;
        if ( $cmd =~ m{^perl(?:\z|[^a-z])} ) {
            if ( $Config{startperl} =~ m,^\#!.*/perl, ) {
                $interpreter = $Config{startperl};
                $interpreter =~ s,^\#!,,;
            }
            else {
                $interpreter = $Config{perlpath};
            }
        }
        else {
            my (@@absdirs)
                = reverse grep { $self->file_name_is_absolute($_) } $self->path;
            $interpreter = '';

            foreach my $dir (@@absdirs) {
                if ( $self->maybe_command($cmd) ) {
                    warn "Ignoring $interpreter in $file\n"
                        if $Verbose && $interpreter;
                    $interpreter = $self->catfile( $dir, $cmd );
                }
            }
        }

        # Figure out how to invoke interpreter on this machine.

        my ($shb) = "";
        if ($interpreter) {
            print STDOUT "Changing sharpbang in $file to $interpreter"
                if $Verbose;

            # this is probably value-free on DOSISH platforms
            if ($does_shbang) {
                $shb .= "$Config{'sharpbang'}$interpreter";
                $shb .= ' ' . $arg if defined $arg;
                $shb .= "\n";
            }
            $shb .= qq{
eval 'exec $interpreter $arg -S \$0 \${1+"\$\@@"}'
    if 0; # not running under some shell
} unless $Is{Win32};    # this won't work on win32, so don't
        }
        else {
            warn "Can't find $cmd in PATH, $file unchanged"
                if $Verbose;
            next;
        }

        open( my $fixout, ">", "$file_new" ) or do {
            warn "Can't create new $file: $!\n";
            next;
        };

        # Print out the new #! line (or equivalent).
        local $\;
        local $/;
        print $fixout $shb, <$fixin>;
        close $fixin;
        close $fixout;

        chmod 0666, $file_bak;
        unlink $file_bak;
        unless ( _rename( $file, $file_bak ) ) {
            warn "Can't rename $file to $file_bak: $!";
            next;
        }
        unless ( _rename( $file_new, $file ) ) {
            warn "Can't rename $file_new to $file: $!";
            unless ( _rename( $file_bak, $file ) ) {
                warn "Can't rename $file_bak back to $file either: $!";
                warn "Leaving $file renamed as $file_bak\n";
            }
            next;
        }
        unlink $file_bak;
    }
    continue {
        system("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
    }
}


sub _rename {
    my($old, $new) = @@_;

    foreach my $file ($old, $new) {
        if( $Is{VMS} and basename($file) !~ /\./ ) {
            # rename() in 5.8.0 on VMS will not rename a file if it
            # does not contain a dot yet it returns success.
            $file = "$file.";
        }
    }

    return rename($old, $new);
}


=item force (o)

Writes an empty FORCE: target.

=cut

sub force {
    my($self) = shift;
    '# Phony target to force checking subdirectories.
FORCE :
	$(NOECHO) $(NOOP)
';
}

=item guess_name

Guess the name of this package by examining the working directory's
name. MakeMaker calls this only if the developer has not supplied a
NAME attribute.

=cut

# ';

sub guess_name {
    my($self) = @@_;
    use Cwd 'cwd';
    my $name = basename(cwd());
    $name =~ s|[\-_][\d\.\-]+\z||;  # this is new with MM 5.00, we
                                    # strip minus or underline
                                    # followed by a float or some such
    print "Warning: Guessing NAME [$name] from current directory name.\n";
    $name;
}

=item has_link_code

Returns true if C, XS, MYEXTLIB or similar objects exist within this
object that need a compiler. Does not descend into subdirectories as
needs_linking() does.

=cut

sub has_link_code {
    my($self) = shift;
    return $self->{HAS_LINK_CODE} if defined $self->{HAS_LINK_CODE};
    if ($self->{OBJECT} or @@{$self->{C} || []} or $self->{MYEXTLIB}){
	$self->{HAS_LINK_CODE} = 1;
	return 1;
    }
    return $self->{HAS_LINK_CODE} = 0;
}


=item init_dirscan

Scans the directory structure and initializes DIR, XS, XS_FILES,
C, C_FILES, O_FILES, H, H_FILES, PL_FILES, EXE_FILES.

Called by init_main.

=cut

sub init_dirscan {	# --- File and Directory Lists (.xs .pm .pod etc)
    my($self) = @@_;
    my(%dir, %xs, %c, %h, %pl_files, %pm);

    my %ignore = map {( $_ => 1 )} qw(Makefile.PL Build.PL test.pl t);

    # ignore the distdir
    $Is{VMS} ? $ignore{"$self->{DISTVNAME}.dir"} = 1
            : $ignore{$self->{DISTVNAME}} = 1;

    @@ignore{map lc, keys %ignore} = values %ignore if $Is{VMS};

    foreach my $name ($self->lsdir($Curdir)){
	next if $name =~ /\#/;
	next if $name eq $Curdir or $name eq $Updir or $ignore{$name};
	next unless $self->libscan($name);
	if (-d $name){
	    next if -l $name; # We do not support symlinks at all
            next if $self->{NORECURS};
	    $dir{$name} = $name if (-f $self->catfile($name,"Makefile.PL"));
	} elsif ($name =~ /\.xs\z/){
	    my($c); ($c = $name) =~ s/\.xs\z/.c/;
	    $xs{$name} = $c;
	    $c{$c} = 1;
	} elsif ($name =~ /\.c(pp|xx|c)?\z/i){  # .c .C .cpp .cxx .cc
	    $c{$name} = 1
		unless $name =~ m/perlmain\.c/; # See MAP_TARGET
	} elsif ($name =~ /\.h\z/i){
	    $h{$name} = 1;
	} elsif ($name =~ /\.PL\z/) {
	    ($pl_files{$name} = $name) =~ s/\.PL\z// ;
	} elsif (($Is{VMS} || $Is{Dos}) && $name =~ /[._]pl$/i) {
	    # case-insensitive filesystem, one dot per name, so foo.h.PL
	    # under Unix appears as foo.h_pl under VMS or fooh.pl on Dos
	    local($/); open(my $pl, '<', $name); my $txt = <$pl>; close $pl;
	    if ($txt =~ /Extracting \S+ \(with variable substitutions/) {
		($pl_files{$name} = $name) =~ s/[._]pl\z//i ;
	    }
	    else {
                $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name); 
            }
	} elsif ($name =~ /\.(p[ml]|pod)\z/){
	    $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);
	}
    }

    $self->{PL_FILES}   ||= \%pl_files;
    $self->{DIR}        ||= [sort keys %dir];
    $self->{XS}         ||= \%xs;
    $self->{C}          ||= [sort keys %c];
    $self->{H}          ||= [sort keys %h];
    $self->{PM}         ||= \%pm;

    my @@o_files = @@{$self->{C}};
    $self->{O_FILES} = [grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i, @@o_files];
}


=item init_MANPODS

Determines if man pages should be generated and initializes MAN1PODS
and MAN3PODS as appropriate.

=cut

sub init_MANPODS {
    my $self = shift;

    # Set up names of manual pages to generate from pods
    foreach my $man (qw(MAN1 MAN3)) {
        if ( $self->{"${man}PODS"}
             or $self->{"INSTALL${man}DIR"} =~ /^(none|\s*)$/
        ) {
            $self->{"${man}PODS"} ||= {};
        }
        else {
            my $init_method = "init_${man}PODS";
            $self->$init_method();
        }
    }
}


sub _has_pod {
    my($self, $file) = @@_;

    my($ispod)=0;
    if (open( my $fh, '<', $file )) {
        while (<$fh>) {
            if (/^=(?:head\d+|item|pod)\b/) {
                $ispod=1;
                last;
            }
        }
        close $fh;
    } else {
        # If it doesn't exist yet, we assume, it has pods in it
        $ispod = 1;
    }

    return $ispod;
}


=item init_MAN1PODS

Initializes MAN1PODS from the list of EXE_FILES.

=cut

sub init_MAN1PODS {
    my($self) = @@_;

    if ( exists $self->{EXE_FILES} ) {
	foreach my $name (@@{$self->{EXE_FILES}}) {
	    next unless $self->_has_pod($name);

	    $self->{MAN1PODS}->{$name} =
		$self->catfile("\$(INST_MAN1DIR)", 
			       basename($name).".\$(MAN1EXT)");
	}
    }
}


=item init_MAN3PODS

Initializes MAN3PODS from the list of PM files.

=cut

sub init_MAN3PODS {
    my $self = shift;

    my %manifypods = (); # we collect the keys first, i.e. the files
                         # we have to convert to pod

    foreach my $name (keys %{$self->{PM}}) {
	if ($name =~ /\.pod\z/ ) {
	    $manifypods{$name} = $self->{PM}{$name};
	} elsif ($name =~ /\.p[ml]\z/ ) {
	    if( $self->_has_pod($name) ) {
		$manifypods{$name} = $self->{PM}{$name};
	    }
	}
    }

    my $parentlibs_re = join '|', @@{$self->{PMLIBPARENTDIRS}};

    # Remove "Configure.pm" and similar, if it's not the only pod listed
    # To force inclusion, just name it "Configure.pod", or override 
    # MAN3PODS
    foreach my $name (keys %manifypods) {
	if ($self->{PERL_CORE} and $name =~ /(config|setup).*\.pm/is) {
	    delete $manifypods{$name};
	    next;
	}
	my($manpagename) = $name;
	$manpagename =~ s/\.p(od|m|l)\z//;
	# everything below lib is ok
	unless($manpagename =~ s!^\W*($parentlibs_re)\W+!!s) {
	    $manpagename = $self->catfile(
	        split(/::/,$self->{PARENT_NAME}),$manpagename
	    );
	}
	$manpagename = $self->replace_manpage_separator($manpagename);
	$self->{MAN3PODS}->{$name} =
	    $self->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
    }
}


=item init_PM

Initializes PMLIBDIRS and PM from PMLIBDIRS.

=cut

sub init_PM {
    my $self = shift;

    # Some larger extensions often wish to install a number of *.pm/pl
    # files into the library in various locations.

    # The attribute PMLIBDIRS holds an array reference which lists
    # subdirectories which we should search for library files to
    # install. PMLIBDIRS defaults to [ 'lib', $self->{BASEEXT} ].  We
    # recursively search through the named directories (skipping any
    # which don't exist or contain Makefile.PL files).

    # For each *.pm or *.pl file found $self->libscan() is called with
    # the default installation path in $_[1]. The return value of
    # libscan defines the actual installation location.  The default
    # libscan function simply returns the path.  The file is skipped
    # if libscan returns false.

    # The default installation location passed to libscan in $_[1] is:
    #
    #  ./*.pm		=> $(INST_LIBDIR)/*.pm
    #  ./xyz/...	=> $(INST_LIBDIR)/xyz/...
    #  ./lib/...	=> $(INST_LIB)/...
    #
    # In this way the 'lib' directory is seen as the root of the actual
    # perl library whereas the others are relative to INST_LIBDIR
    # (which includes PARENT_NAME). This is a subtle distinction but one
    # that's important for nested modules.

    unless( $self->{PMLIBDIRS} ) {
        if( $Is{VMS} ) {
            # Avoid logical name vs directory collisions
            $self->{PMLIBDIRS} = ['./lib', "./$self->{BASEEXT}"];
        }
        else {
            $self->{PMLIBDIRS} = ['lib', $self->{BASEEXT}];
        }
    }

    #only existing directories that aren't in $dir are allowed

    # Avoid $_ wherever possible:
    # @@{$self->{PMLIBDIRS}} = grep -d && !$dir{$_}, @@{$self->{PMLIBDIRS}};
    my (@@pmlibdirs) = @@{$self->{PMLIBDIRS}};
    @@{$self->{PMLIBDIRS}} = ();
    my %dir = map { ($_ => $_) } @@{$self->{DIR}};
    foreach my $pmlibdir (@@pmlibdirs) {
	-d $pmlibdir && !$dir{$pmlibdir} && push @@{$self->{PMLIBDIRS}}, $pmlibdir;
    }

    unless( $self->{PMLIBPARENTDIRS} ) {
	@@{$self->{PMLIBPARENTDIRS}} = ('lib');
    }

    return if $self->{PM} and $self->{ARGS}{PM};

    if (@@{$self->{PMLIBDIRS}}){
	print "Searching PMLIBDIRS: @@{$self->{PMLIBDIRS}}\n"
	    if ($Verbose >= 2);
	require File::Find;
        File::Find::find(sub {
            if (-d $_){
                unless ($self->libscan($_)){
                    $File::Find::prune = 1;
                }
                return;
            }
            return if /\#/;
            return if /~$/;             # emacs temp files
            return if /,v$/;            # RCS files
            return if m{\.swp$};        # vim swap files

	    my $path   = $File::Find::name;
            my $prefix = $self->{INST_LIBDIR};
            my $striplibpath;

	    my $parentlibs_re = join '|', @@{$self->{PMLIBPARENTDIRS}};
	    $prefix =  $self->{INST_LIB} 
                if ($striplibpath = $path) =~ s{^(\W*)($parentlibs_re)\W}
	                                       {$1}i;

	    my($inst) = $self->catfile($prefix,$striplibpath);
	    local($_) = $inst; # for backwards compatibility
	    $inst = $self->libscan($inst);
	    print "libscan($path) => '$inst'\n" if ($Verbose >= 2);
	    return unless $inst;
	    $self->{PM}{$path} = $inst;
	}, @@{$self->{PMLIBDIRS}});
    }
}


=item init_DIRFILESEP

Using / for Unix.  Called by init_main.

=cut

sub init_DIRFILESEP {
    my($self) = shift;

    $self->{DIRFILESEP} = '/';
}
    

=item init_main

Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE,
EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*,
INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME,
OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB,
PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION,
VERSION_SYM, XS_VERSION.

=cut

sub init_main {
    my($self) = @@_;

    # --- Initialize Module Name and Paths

    # NAME    = Foo::Bar::Oracle
    # FULLEXT = Foo/Bar/Oracle
    # BASEEXT = Oracle
    # PARENT_NAME = Foo::Bar
### Only UNIX:
###    ($self->{FULLEXT} =
###     $self->{NAME}) =~ s!::!/!g ; #eg. BSD/Foo/Socket
    $self->{FULLEXT} = $self->catdir(split /::/, $self->{NAME});


    # Copied from DynaLoader:

    my(@@modparts) = split(/::/,$self->{NAME});
    my($modfname) = $modparts[-1];

    # Some systems have restrictions on files names for DLL's etc.
    # mod2fname returns appropriate file base name (typically truncated)
    # It may also edit @@modparts if required.
    if (defined &DynaLoader::mod2fname) {
        $modfname = &DynaLoader::mod2fname(\@@modparts);
    }

    ($self->{PARENT_NAME}, $self->{BASEEXT}) = $self->{NAME} =~ m!(?:([\w:]+)::)?(\w+)\z! ;
    $self->{PARENT_NAME} ||= '';

    if (defined &DynaLoader::mod2fname) {
	# As of 5.001m, dl_os2 appends '_'
	$self->{DLBASE} = $modfname;
    } else {
	$self->{DLBASE} = '$(BASEEXT)';
    }


    # --- Initialize PERL_LIB, PERL_SRC

    # *Real* information: where did we get these two from? ...
    my $inc_config_dir = dirname($INC{'Config.pm'});
    my $inc_carp_dir   = dirname($INC{'Carp.pm'});

    unless ($self->{PERL_SRC}){
        foreach my $dir_count (1..8) { # 8 is the VMS limit for nesting
            my $dir = $self->catdir(($Updir) x $dir_count);

            if (-f $self->catfile($dir,"config_h.SH")   &&
                -f $self->catfile($dir,"perl.h")        &&
                -f $self->catfile($dir,"lib","strict.pm")
            ) {
                $self->{PERL_SRC}=$dir ;
                last;
            }
        }
    }

    warn "PERL_CORE is set but I can't find your PERL_SRC!\n" if
      $self->{PERL_CORE} and !$self->{PERL_SRC};

    if ($self->{PERL_SRC}){
	$self->{PERL_LIB}     ||= $self->catdir("$self->{PERL_SRC}","lib");

        if (defined $Cross::platform) {
            $self->{PERL_ARCHLIB} = 
              $self->catdir("$self->{PERL_SRC}","xlib",$Cross::platform);
            $self->{PERL_INC}     = 
              $self->catdir("$self->{PERL_SRC}","xlib",$Cross::platform, 
                                 $Is{Win32}?("CORE"):());
        }
        else {
            $self->{PERL_ARCHLIB} = $self->{PERL_LIB};
            $self->{PERL_INC}     = ($Is{Win32}) ? 
              $self->catdir($self->{PERL_LIB},"CORE") : $self->{PERL_SRC};
        }

	# catch a situation that has occurred a few times in the past:
	unless (
		-s $self->catfile($self->{PERL_SRC},'cflags')
		or
		$Is{VMS}
		&&
		-s $self->catfile($self->{PERL_SRC},'perlshr_attr.opt')
		or
		$Is{Win32}
	       ){
	    warn qq{
You cannot build extensions below the perl source tree after executing
a 'make clean' in the perl source tree.

To rebuild extensions distributed with the perl source you should
simply Configure (to include those extensions) and then build perl as
normal. After installing perl the source tree can be deleted. It is
not needed for building extensions by running 'perl Makefile.PL'
usually without extra arguments.

It is recommended that you unpack and build additional extensions away
from the perl source tree.
};
	}
    } else {
	# we should also consider $ENV{PERL5LIB} here
        my $old = $self->{PERL_LIB} || $self->{PERL_ARCHLIB} || $self->{PERL_INC};
	$self->{PERL_LIB}     ||= $Config{privlibexp};
	$self->{PERL_ARCHLIB} ||= $Config{archlibexp};
	$self->{PERL_INC}     = $self->catdir("$self->{PERL_ARCHLIB}","CORE"); # wild guess for now
	my $perl_h;

	if (not -f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h"))
	    and not $old){
	    # Maybe somebody tries to build an extension with an
	    # uninstalled Perl outside of Perl build tree
	    my $lib;
	    for my $dir (@@INC) {
	      $lib = $dir, last if -e $self->catfile($dir, "Config.pm");
	    }
	    if ($lib) {
              # Win32 puts its header files in /perl/src/lib/CORE.
              # Unix leaves them in /perl/src.
	      my $inc = $Is{Win32} ? $self->catdir($lib, "CORE" )
                                  : dirname $lib;
	      if (-e $self->catfile($inc, "perl.h")) {
		$self->{PERL_LIB}	   = $lib;
		$self->{PERL_ARCHLIB}	   = $lib;
		$self->{PERL_INC}	   = $inc;
		$self->{UNINSTALLED_PERL}  = 1;
		print STDOUT <<EOP;
... Detected uninstalled Perl.  Trying to continue.
EOP
	      }
	    }
	}	
    }

    # We get SITELIBEXP and SITEARCHEXP directly via
    # Get_from_Config. When we are running standard modules, these
    # won't matter, we will set INSTALLDIRS to "perl". Otherwise we
    # set it to "site". I prefer that INSTALLDIRS be set from outside
    # MakeMaker.
    $self->{INSTALLDIRS} ||= "site";

    $self->{MAN1EXT} ||= $Config{man1ext};
    $self->{MAN3EXT} ||= $Config{man3ext};

    # Get some stuff out of %Config if we haven't yet done so
    print STDOUT "CONFIG must be an array ref\n"
        if ($self->{CONFIG} and ref $self->{CONFIG} ne 'ARRAY');
    $self->{CONFIG} = [] unless (ref $self->{CONFIG});
    push(@@{$self->{CONFIG}}, @@ExtUtils::MakeMaker::Get_from_Config);
    push(@@{$self->{CONFIG}}, 'shellflags') if $Config{shellflags};
    my(%once_only);
    foreach my $m (@@{$self->{CONFIG}}){
        next if $once_only{$m};
        print STDOUT "CONFIG key '$m' does not exist in Config.pm\n"
                unless exists $Config{$m};
        $self->{uc $m} ||= $Config{$m};
        $once_only{$m} = 1;
    }

# This is too dangerous:
#    if ($^O eq "next") {
#	$self->{AR} = "libtool";
#	$self->{AR_STATIC_ARGS} = "-o";
#    }
# But I leave it as a placeholder

    $self->{AR_STATIC_ARGS} ||= "cr";

    # These should never be needed
    $self->{OBJ_EXT} ||= '.o';
    $self->{LIB_EXT} ||= '.a';

    $self->{MAP_TARGET} ||= "perl";

    $self->{LIBPERL_A} ||= "libperl$self->{LIB_EXT}";

    # make a simple check if we find strict
    warn "Warning: PERL_LIB ($self->{PERL_LIB}) seems not to be a perl library directory
        (strict.pm not found)"
        unless -f $self->catfile("$self->{PERL_LIB}","strict.pm") ||
               $self->{NAME} eq "ExtUtils::MakeMaker";
}

=item init_others

Initializes EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LIBS, LD_RUN_PATH, LD,
OBJECT, BOOTDEP, PERLMAINCC, LDFROM, LINKTYPE, SHELL, NOOP,
FIRST_MAKEFILE, MAKEFILE_OLD, NOECHO, RM_F, RM_RF, TEST_F,
TOUCH, CP, MV, CHMOD, UMASK_NULL, ECHO, ECHO_N

=cut

sub init_others {	# --- Initialize Other Attributes
    my($self) = shift;

    $self->{ECHO}       ||= 'echo';
    $self->{ECHO_N}     ||= 'echo -n';
    $self->{RM_F}       ||= "rm -f";
    $self->{RM_RF}      ||= "rm -rf";
    $self->{TOUCH}      ||= "touch";
    $self->{TEST_F}     ||= "test -f";
    $self->{CP}         ||= "cp";
    $self->{MV}         ||= "mv";
    $self->{CHMOD}      ||= "chmod";
    $self->{FALSE}      ||= 'false';
    $self->{TRUE}       ||= 'true';

    $self->{LD}         ||= 'ld';

    $self->SUPER::init_others(@@_);

    # After SUPER::init_others so $Config{shell} has a
    # chance to get set.
    $self->{SHELL}      ||= '/bin/sh';

    return 1;
}


=item init_linker

Unix has no need of special linker flags.

=cut

sub init_linker {
    my($self) = shift;
    $self->{PERL_ARCHIVE} ||= '';
    $self->{PERL_ARCHIVE_AFTER} ||= '';
    $self->{EXPORT_LIST}  ||= '';
}


=begin _protected

=item init_lib2arch

    $mm->init_lib2arch

=end _protected

=cut

sub init_lib2arch {
    my($self) = shift;

    # The user who requests an installation directory explicitly
    # should not have to tell us an architecture installation directory
    # as well. We look if a directory exists that is named after the
    # architecture. If not we take it as a sign that it should be the
    # same as the requested installation directory. Otherwise we take
    # the found one.
    for my $libpair ({l=>"privlib",   a=>"archlib"}, 
                     {l=>"sitelib",   a=>"sitearch"},
                     {l=>"vendorlib", a=>"vendorarch"},
                    )
    {
        my $lib = "install$libpair->{l}";
        my $Lib = uc $lib;
        my $Arch = uc "install$libpair->{a}";
        if( $self->{$Lib} && ! $self->{$Arch} ){
            my($ilib) = $Config{$lib};

            $self->prefixify($Arch,$ilib,$self->{$Lib});

            unless (-d $self->{$Arch}) {
                print STDOUT "Directory $self->{$Arch} not found\n" 
                  if $Verbose;
                $self->{$Arch} = $self->{$Lib};
            }
            print STDOUT "Defaulting $Arch to $self->{$Arch}\n" if $Verbose;
        }
    }
}


=item init_PERL

    $mm->init_PERL;

Called by init_main.  Sets up ABSPERL, PERL, FULLPERL and all the
*PERLRUN* permutations.

    PERL is allowed to be miniperl
    FULLPERL must be a complete perl

    ABSPERL is PERL converted to an absolute path

    *PERLRUN contains everything necessary to run perl, find it's
         libraries, etc...

    *PERLRUNINST is *PERLRUN + everything necessary to find the
         modules being built.

=cut

sub init_PERL {
    my($self) = shift;

    my @@defpath = ();
    foreach my $component ($self->{PERL_SRC}, $self->path(), 
                           $Config{binexp}) 
    {
	push @@defpath, $component if defined $component;
    }

    # Build up a set of file names (not command names).
    my $thisperl = $self->canonpath($^X);
    $thisperl .= $Config{exe_ext} unless 
                # VMS might have a file version # at the end
      $Is{VMS} ? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i
              : $thisperl =~ m/$Config{exe_ext}$/i;

    # We need a relative path to perl when in the core.
    $thisperl = $self->abs2rel($thisperl) if $self->{PERL_CORE};

    my @@perls = ($thisperl);
    push @@perls, map { "$_$Config{exe_ext}" }
                     ('perl', 'perl5', "perl$Config{version}");

    # miniperl has priority over all but the cannonical perl when in the
    # core.  Otherwise its a last resort.
    my $miniperl = "miniperl$Config{exe_ext}";
    if( $self->{PERL_CORE} ) {
        splice @@perls, 1, 0, $miniperl;
    }
    else {
        push @@perls, $miniperl;
    }

    $self->{PERL} ||=
        $self->find_perl(5.0, \@@perls, \@@defpath, $Verbose );
    # don't check if perl is executable, maybe they have decided to
    # supply switches with perl

    # When built for debugging, VMS doesn't create perl.exe but ndbgperl.exe.
    my $perl_name = 'perl';
    $perl_name = 'ndbgperl' if $Is{VMS} && 
      defined $Config{usevmsdebug} && $Config{usevmsdebug} eq 'define';

    # XXX This logic is flawed.  If "miniperl" is anywhere in the path
    # it will get confused.  It should be fixed to work only on the filename.
    # Define 'FULLPERL' to be a non-miniperl (used in test: target)
    ($self->{FULLPERL} = $self->{PERL}) =~ s/miniperl/$perl_name/i
	unless $self->{FULLPERL};

    # Little hack to get around VMS's find_perl putting "MCR" in front
    # sometimes.
    $self->{ABSPERL} = $self->{PERL};
    my $has_mcr = $self->{ABSPERL} =~ s/^MCR\s*//;
    if( $self->file_name_is_absolute($self->{ABSPERL}) ) {
        $self->{ABSPERL} = '$(PERL)';
    }
    else {
        $self->{ABSPERL} = $self->rel2abs($self->{ABSPERL});

        # Quote the perl command if it contains whitespace
        $self->{ABSPERL} = $self->quote_literal($self->{ABSPERL})
          if $self->{ABSPERL} =~ /\s/;

        $self->{ABSPERL} = 'MCR '.$self->{ABSPERL} if $has_mcr;
    }

    # Are we building the core?
    $self->{PERL_CORE} = $ENV{PERL_CORE} unless exists $self->{PERL_CORE};
    $self->{PERL_CORE} = 0               unless defined $self->{PERL_CORE};

    # How do we run perl?
    foreach my $perl (qw(PERL FULLPERL ABSPERL)) {
        my $run  = $perl.'RUN';

        $self->{$run}  = "\$($perl)";

        # Make sure perl can find itself before it's installed.
        $self->{$run} .= q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"} 
          if $self->{UNINSTALLED_PERL} || $self->{PERL_CORE};

        $self->{$perl.'RUNINST'} = 
          sprintf q{$(%sRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"}, $perl;
    }

    return 1;
}


=item init_platform

=item platform_constants

Add MM_Unix_VERSION.

=cut

sub init_platform {
    my($self) = shift;

    $self->{MM_Unix_VERSION} = $VERSION;
    $self->{PERL_MALLOC_DEF} = '-DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc '.
                               '-Dfree=Perl_mfree -Drealloc=Perl_realloc '.
                               '-Dcalloc=Perl_calloc';

}

sub platform_constants {
    my($self) = shift;
    my $make_frag = '';

    foreach my $macro (qw(MM_Unix_VERSION PERL_MALLOC_DEF))
    {
        next unless defined $self->{$macro};
        $make_frag .= "$macro = $self->{$macro}\n";
    }

    return $make_frag;
}


=item init_PERM

  $mm->init_PERM

Called by init_main.  Initializes PERL_*

=cut

sub init_PERM {
    my($self) = shift;

    $self->{PERM_DIR} = 755  unless defined $self->{PERM_DIR};
    $self->{PERM_RW}  = 644  unless defined $self->{PERM_RW};
    $self->{PERM_RWX} = 755  unless defined $self->{PERM_RWX};

    return 1;
}


=item init_xs

    $mm->init_xs

Sets up macros having to do with XS code.  Currently just INST_STATIC,
INST_DYNAMIC and INST_BOOT.

=cut

sub init_xs {
    my $self = shift;

    if ($self->has_link_code()) {
        $self->{INST_STATIC}  = 
          $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT)$(LIB_EXT)');
        $self->{INST_DYNAMIC} = 
          $self->catfile('$(INST_ARCHAUTODIR)', '$(DLBASE).$(DLEXT)');
        $self->{INST_BOOT}    = 
          $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT).bs');
    } else {
        $self->{INST_STATIC}  = '';
        $self->{INST_DYNAMIC} = '';
        $self->{INST_BOOT}    = '';
    }
}    

=item install (o)

Defines the install target.

=cut

sub install {
    my($self, %attribs) = @@_;
    my(@@m);

    push @@m, q{
install :: pure_install doc_install
	$(NOECHO) $(NOOP)

install_perl :: pure_perl_install doc_perl_install
	$(NOECHO) $(NOOP)

install_site :: pure_site_install doc_site_install
	$(NOECHO) $(NOOP)

install_vendor :: pure_vendor_install doc_vendor_install
	$(NOECHO) $(NOOP)

pure_install :: pure_$(INSTALLDIRS)_install
	$(NOECHO) $(NOOP)

doc_install :: doc_$(INSTALLDIRS)_install
	$(NOECHO) $(NOOP)

pure__install : pure_site_install
	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site

doc__install : doc_site_install
	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site

pure_perl_install :: all
	$(NOECHO) $(MOD_INSTALL) \
		read }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		write }.$self->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(DESTINSTALLPRIVLIB) \
		$(INST_ARCHLIB) $(DESTINSTALLARCHLIB) \
		$(INST_BIN) $(DESTINSTALLBIN) \
		$(INST_SCRIPT) $(DESTINSTALLSCRIPT) \
		$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) \
		$(INST_MAN3DIR) $(DESTINSTALLMAN3DIR)
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
		}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{


pure_site_install :: all
	$(NOECHO) $(MOD_INSTALL) \
		read }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
		write }.$self->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(DESTINSTALLSITELIB) \
		$(INST_ARCHLIB) $(DESTINSTALLSITEARCH) \
		$(INST_BIN) $(DESTINSTALLSITEBIN) \
		$(INST_SCRIPT) $(DESTINSTALLSITESCRIPT) \
		$(INST_MAN1DIR) $(DESTINSTALLSITEMAN1DIR) \
		$(INST_MAN3DIR) $(DESTINSTALLSITEMAN3DIR)
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
		}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{

pure_vendor_install :: all
	$(NOECHO) $(MOD_INSTALL) \
		read }.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
		write }.$self->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(DESTINSTALLVENDORLIB) \
		$(INST_ARCHLIB) $(DESTINSTALLVENDORARCH) \
		$(INST_BIN) $(DESTINSTALLVENDORBIN) \
		$(INST_SCRIPT) $(DESTINSTALLVENDORSCRIPT) \
		$(INST_MAN1DIR) $(DESTINSTALLVENDORMAN1DIR) \
		$(INST_MAN3DIR) $(DESTINSTALLVENDORMAN3DIR)

doc_perl_install :: all
	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	-$(NOECHO) $(DOC_INSTALL) \
		"Module" "$(NAME)" \
		"installed into" "$(INSTALLPRIVLIB)" \
		LINKTYPE "$(LINKTYPE)" \
		VERSION "$(VERSION)" \
		EXE_FILES "$(EXE_FILES)" \
		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{

doc_site_install :: all
	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	-$(NOECHO) $(DOC_INSTALL) \
		"Module" "$(NAME)" \
		"installed into" "$(INSTALLSITELIB)" \
		LINKTYPE "$(LINKTYPE)" \
		VERSION "$(VERSION)" \
		EXE_FILES "$(EXE_FILES)" \
		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{

doc_vendor_install :: all
	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	-$(NOECHO) $(DOC_INSTALL) \
		"Module" "$(NAME)" \
		"installed into" "$(INSTALLVENDORLIB)" \
		LINKTYPE "$(LINKTYPE)" \
		VERSION "$(VERSION)" \
		EXE_FILES "$(EXE_FILES)" \
		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{

};

    push @@m, q{
uninstall :: uninstall_from_$(INSTALLDIRS)dirs
	$(NOECHO) $(NOOP)

uninstall_from_perldirs ::
	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{

uninstall_from_sitedirs ::
	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{

uninstall_from_vendordirs ::
	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{
};

    join("",@@m);
}

=item installbin (o)

Defines targets to make and to install EXE_FILES.

=cut

sub installbin {
    my($self) = shift;

    return "" unless $self->{EXE_FILES} && ref $self->{EXE_FILES} eq "ARRAY";
    my @@exefiles = @@{$self->{EXE_FILES}};
    return "" unless @@exefiles;

    @@exefiles = map vmsify($_), @@exefiles if $Is{VMS};

    my %fromto;
    for my $from (@@exefiles) {
	my($path)= $self->catfile('$(INST_SCRIPT)', basename($from));

	local($_) = $path; # for backwards compatibility
	my $to = $self->libscan($path);
	print "libscan($from) => '$to'\n" if ($Verbose >=2);

        $to = vmsify($to) if $Is{VMS};
	$fromto{$from} = $to;
    }
    my @@to   = values %fromto;

    my @@m;
    push(@@m, qq{
EXE_FILES = @@exefiles

pure_all :: @@to
	\$(NOECHO) \$(NOOP)

realclean ::
});

    # realclean can get rather large.
    push @@m, map "\t$_\n", $self->split_command('$(RM_F)', @@to);
    push @@m, "\n";


    # A target for each exe file.
    while (my($from,$to) = each %fromto) {
	last unless defined $from;

	push @@m, sprintf <<'MAKE', $to, $from, $to, $from, $to, $to, $to;
%s : %s $(FIRST_MAKEFILE) $(INST_SCRIPT)$(DFSEP).exists $(INST_BIN)$(DFSEP).exists
	$(NOECHO) $(RM_F) %s
	$(CP) %s %s
	$(FIXIN) %s
	-$(NOECHO) $(CHMOD) $(PERM_RWX) %s

MAKE

    }

    join "", @@m;
}


=item linkext (o)

Defines the linkext target which in turn defines the LINKTYPE.

=cut

sub linkext {
    my($self, %attribs) = @@_;
    # LINKTYPE => static or dynamic or ''
    my($linktype) = defined $attribs{LINKTYPE} ?
      $attribs{LINKTYPE} : '$(LINKTYPE)';
    "
linkext :: $linktype
	\$(NOECHO) \$(NOOP)
";
}

=item lsdir

Takes as arguments a directory name and a regular expression. Returns
all entries in the directory that match the regular expression.

=cut

sub lsdir {
    my($self) = shift;
    my($dir, $regex) = @@_;
    my(@@ls);
    my $dh = new DirHandle;
    $dh->open($dir || ".") or return ();
    @@ls = $dh->read;
    $dh->close;
    @@ls = grep(/$regex/, @@ls) if $regex;
    @@ls;
}

=item macro (o)

Simple subroutine to insert the macros defined by the macro attribute
into the Makefile.

=cut

sub macro {
    my($self,%attribs) = @@_;
    my(@@m,$key,$val);
    while (($key,$val) = each %attribs){
	last unless defined $key;
	push @@m, "$key = $val\n";
    }
    join "", @@m;
}

=item makeaperl (o)

Called by staticmake. Defines how to write the Makefile to produce a
static new perl.

By default the Makefile produced includes all the static extensions in
the perl library. (Purified versions of library files, e.g.,
DynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)

=cut

sub makeaperl {
    my($self, %attribs) = @@_;
    my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmp, $libperl) =
	@@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};
    my(@@m);
    push @@m, "
# --- MakeMaker makeaperl section ---
MAP_TARGET    = $target
FULLPERL      = $self->{FULLPERL}
";
    return join '', @@m if $self->{PARENT};

    my($dir) = join ":", @@{$self->{DIR}};

    unless ($self->{MAKEAPERL}) {
	push @@m, q{
$(MAP_TARGET) :: static $(MAKE_APERL_FILE)
	$(MAKE) $(USEMAKEFILE) $(MAKE_APERL_FILE) $@@

$(MAKE_APERL_FILE) : $(FIRST_MAKEFILE) pm_to_blib
	$(NOECHO) $(ECHO) Writing \"$(MAKE_APERL_FILE)\" for this $(MAP_TARGET)
	$(NOECHO) $(PERLRUNINST) \
		Makefile.PL DIR=}, $dir, q{ \
		MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
		MAKEAPERL=1 NORECURS=1 CCCDLFLAGS=};

	foreach (@@ARGV){
		if( /\s/ ){
			s/=(.*)/='$1'/;
		}
		push @@m, " \\\n\t\t$_";
	}
#	push @@m, map( " \\\n\t\t$_", @@ARGV );
	push @@m, "\n";

	return join '', @@m;
    }



    my($cccmd, $linkcmd, $lperl);


    $cccmd = $self->const_cccmd($libperl);
    $cccmd =~ s/^CCCMD\s*=\s*//;
    $cccmd =~ s/\$\(INC\)/ "-I$self->{PERL_INC}" /;
    $cccmd .= " $Config{cccdlflags}"
	if ($Config{useshrplib} eq 'true');
    $cccmd =~ s/\(CC\)/\(PERLMAINCC\)/;

    # The front matter of the linkcommand...
    $linkcmd = join ' ', "\$(CC)",
	    grep($_, @@Config{qw(ldflags ccdlflags)});
    $linkcmd =~ s/\s+/ /g;
    $linkcmd =~ s,(perl\.exp),\$(PERL_INC)/$1,;

    # Which *.a files could we make use of...
    my %static;
    require File::Find;
    File::Find::find(sub {
	return unless m/\Q$self->{LIB_EXT}\E$/;

        # Skip perl's libraries.
        return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;

	# Skip purified versions of libraries 
        # (e.g., DynaLoader_pure_p1_c0_032.a)
	return if m/_pure_\w+_\w+_\w+\.\w+$/ and -f "$File::Find::dir/.pure";

	if( exists $self->{INCLUDE_EXT} ){
		my $found = 0;

		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
		$xx =~ s,/?$_,,;
		$xx =~ s,/,::,g;

		# Throw away anything not explicitly marked for inclusion.
		# DynaLoader is implied.
		foreach my $incl ((@@{$self->{INCLUDE_EXT}},'DynaLoader')){
			if( $xx eq $incl ){
				$found++;
				last;
			}
		}
		return unless $found;
	}
	elsif( exists $self->{EXCLUDE_EXT} ){
		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
		$xx =~ s,/?$_,,;
		$xx =~ s,/,::,g;

		# Throw away anything explicitly marked for exclusion
		foreach my $excl (@@{$self->{EXCLUDE_EXT}}){
			return if( $xx eq $excl );
		}
	}

	# don't include the installed version of this extension. I
	# leave this line here, although it is not necessary anymore:
	# I patched minimod.PL instead, so that Miniperl.pm won't
	# enclude duplicates

	# Once the patch to minimod.PL is in the distribution, I can
	# drop it
	return if $File::Find::name =~ m:auto/$self->{FULLEXT}/$self->{BASEEXT}$self->{LIB_EXT}\z:;
	use Cwd 'cwd';
	$static{cwd() . "/" . $_}++;
    }, grep( -d $_, @@{$searchdirs || []}) );

    # We trust that what has been handed in as argument, will be buildable
    $static = [] unless $static;
    @@static{@@{$static}} = (1) x @@{$static};

    $extra = [] unless $extra && ref $extra eq 'ARRAY';
    for (sort keys %static) {
	next unless /\Q$self->{LIB_EXT}\E\z/;
	$_ = dirname($_) . "/extralibs.ld";
	push @@$extra, $_;
    }

    s/^(.*)/"-I$1"/ for @@{$perlinc || []};

    $target ||= "perl";
    $tmp    ||= ".";

# MAP_STATIC doesn't look into subdirs yet. Once "all" is made and we
# regenerate the Makefiles, MAP_STATIC and the dependencies for
# extralibs.all are computed correctly
    push @@m, "
MAP_LINKCMD   = $linkcmd
MAP_PERLINC   = @@{$perlinc || []}
MAP_STATIC    = ",
join(" \\\n\t", reverse sort keys %static), "

MAP_PRELIBS   = $Config{perllibs} $Config{cryptlib}
";

    if (defined $libperl) {
	($lperl = $libperl) =~ s/\$\(A\)/$self->{LIB_EXT}/;
    }
    unless ($libperl && -f $lperl) { # Ilya's code...
	my $dir = $self->{PERL_SRC} || "$self->{PERL_ARCHLIB}/CORE";
	$dir = "$self->{PERL_ARCHLIB}/.." if $self->{UNINSTALLED_PERL};
	$libperl ||= "libperl$self->{LIB_EXT}";
	$libperl   = "$dir/$libperl";
	$lperl   ||= "libperl$self->{LIB_EXT}";
	$lperl     = "$dir/$lperl";

        if (! -f $libperl and ! -f $lperl) {
          # We did not find a static libperl. Maybe there is a shared one?
          if ($Is{SunOS}) {
            $lperl  = $libperl = "$dir/$Config{libperl}";
            # SUNOS ld does not take the full path to a shared library
            $libperl = '' if $Is{SunOS4};
          }
        }

	print STDOUT "Warning: $libperl not found
    If you're going to build a static perl binary, make sure perl is installed
    otherwise ignore this warning\n"
		unless (-f $lperl || defined($self->{PERL_SRC}));
    }

    # SUNOS ld does not take the full path to a shared library
    my $llibperl = $libperl ? '$(MAP_LIBPERL)' : '-lperl';

    push @@m, "
MAP_LIBPERL = $libperl
LLIBPERL    = $llibperl
";

    push @@m, '
$(INST_ARCHAUTODIR)/extralibs.all : $(INST_ARCHAUTODIR)$(DFSEP).exists '.join(" \\\n\t", @@$extra).'
	$(NOECHO) $(RM_F)  $@@
	$(NOECHO) $(TOUCH) $@@
';

    foreach my $catfile (@@$extra){
	push @@m, "\tcat $catfile >> \$\@@\n";
    }

push @@m, "
\$(MAP_TARGET) :: $tmp/perlmain\$(OBJ_EXT) \$(MAP_LIBPERL) \$(MAP_STATIC) \$(INST_ARCHAUTODIR)/extralibs.all
	\$(MAP_LINKCMD) -o \$\@@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) \$(LDFROM) \$(MAP_STATIC) \$(LLIBPERL) `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
	\$(NOECHO) \$(ECHO) 'To install the new \"\$(MAP_TARGET)\" binary, call'
	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename inst_perl MAP_TARGET=\$(MAP_TARGET)'
	\$(NOECHO) \$(ECHO) 'To remove the intermediate files say'
	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename map_clean'

$tmp/perlmain\$(OBJ_EXT): $tmp/perlmain.c
";
    push @@m, "\t".$self->cd($tmp, qq[$cccmd "-I\$(PERL_INC)" perlmain.c])."\n";

    push @@m, qq{
$tmp/perlmain.c: $makefilename}, q{
	$(NOECHO) $(ECHO) Writing $@@
	$(NOECHO) $(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \\
		-e "writemain(grep s#.*/auto/##s, split(q| |, q|$(MAP_STATIC)|))" > $@@t && $(MV) $@@t $@@

};
    push @@m, "\t", q{$(NOECHO) $(PERL) $(INSTALLSCRIPT)/fixpmain
} if (defined (&Dos::UseLFN) && Dos::UseLFN()==0);


    push @@m, q{
doc_inst_perl :
	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	-$(NOECHO) $(DOC_INSTALL) \
		"Perl binary" "$(MAP_TARGET)" \
		MAP_STATIC "$(MAP_STATIC)" \
		MAP_EXTRA "`cat $(INST_ARCHAUTODIR)/extralibs.all`" \
		MAP_LIBPERL "$(MAP_LIBPERL)" \
		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{

};

    push @@m, q{
inst_perl : pure_inst_perl doc_inst_perl

pure_inst_perl : $(MAP_TARGET)
	}.$self->{CP}.q{ $(MAP_TARGET) }.$self->catfile('$(DESTINSTALLBIN)','$(MAP_TARGET)').q{

clean :: map_clean

map_clean :
	}.$self->{RM_F}.qq{ $tmp/perlmain\$(OBJ_EXT) $tmp/perlmain.c \$(MAP_TARGET) $makefilename \$(INST_ARCHAUTODIR)/extralibs.all
};

    join '', @@m;
}

=item makefile (o)

Defines how to rewrite the Makefile.

=cut

sub makefile {
    my($self) = shift;
    my $m;
    # We do not know what target was originally specified so we
    # must force a manual rerun to be sure. But as it should only
    # happen very rarely it is not a significant problem.
    $m = '
$(OBJECT) : $(FIRST_MAKEFILE)

' if $self->{OBJECT};

    my $newer_than_target = $Is{VMS} ? '$(MMS$SOURCE_LIST)' : '$?';
    my $mpl_args = join " ", map qq["$_"], @@ARGV;

    $m .= sprintf <<'MAKE_FRAG', $newer_than_target, $mpl_args;
# We take a very conservative approach here, but it's worth it.
# We move Makefile to Makefile.old here to avoid gnu make looping.
$(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to %s"
	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding Makefile..."
	-$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
	-$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
	- $(MAKE) $(USEMAKEFILE) $(MAKEFILE_OLD) clean $(DEV_NULL)
	$(PERLRUN) Makefile.PL %s
	$(NOECHO) $(ECHO) "==> Your Makefile has been rebuilt. <=="
	$(NOECHO) $(ECHO) "==> Please rerun the $(MAKE) command.  <=="
	$(FALSE)

MAKE_FRAG

    return $m;
}


=item maybe_command

Returns true, if the argument is likely to be a command.

=cut

sub maybe_command {
    my($self,$file) = @@_;
    return $file if -x $file && ! -d $file;
    return;
}


=item needs_linking (o)

Does this module need linking? Looks into subdirectory objects (see
also has_link_code())

=cut

sub needs_linking {
    my($self) = shift;

    my $caller = (caller(0))[3];
    confess("needs_linking called too early") if 
      $caller =~ /^ExtUtils::MakeMaker::/;
    return $self->{NEEDS_LINKING} if defined $self->{NEEDS_LINKING};
    if ($self->has_link_code or $self->{MAKEAPERL}){
	$self->{NEEDS_LINKING} = 1;
	return 1;
    }
    foreach my $child (keys %{$self->{CHILDREN}}) {
	if ($self->{CHILDREN}->{$child}->needs_linking) {
	    $self->{NEEDS_LINKING} = 1;
	    return 1;
	}
    }
    return $self->{NEEDS_LINKING} = 0;
}


=item parse_abstract

parse a file and return what you think is the ABSTRACT

=cut

sub parse_abstract {
    my($self,$parsefile) = @@_;
    my $result;

    local $/ = "\n";
    open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
    my $inpod = 0;
    my $package = $self->{DISTNAME};
    $package =~ s/-/::/g;
    while (<$fh>) {
        $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
        next if !$inpod;
        chop;
        next unless /^($package\s-\s)(.*)/;
        $result = $2;
        last;
    }
    close $fh;

    return $result;
}

=item parse_version

    my $version = MM->parse_version($file);

Parse a $file and return what $VERSION is set to by the first assignment.
It will return the string "undef" if it can't figure out what $VERSION
is. $VERSION should be for all to see, so C<our $VERSION> or plain $VERSION
are okay, but C<my $VERSION> is not.

parse_version() will try to C<use version> before checking for
C<$VERSION> so the following will work.

    $VERSION = qv(1.2.3);

=cut

sub parse_version {
    my($self,$parsefile) = @@_;
    my $result;

    local $/ = "\n";
    local $_;
    open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
    my $inpod = 0;
    while (<$fh>) {
        $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
        next if $inpod || /^\s*#/;
        chop;
        next if /^\s*(if|unless)/;
        next unless m{(?<!\\) ([\$*]) (([\w\:\']*) \bVERSION)\b .* =}x;
        my $eval = qq{
            package ExtUtils::MakeMaker::_version;
            no strict;
            BEGIN { eval {
                # Ensure any version() routine which might have leaked
                # into this package has been deleted.  Interferes with
                # version->import()
                undef *version;
                require version;
                "version"->import;
            } }

            local $1$2;
            \$$2=undef;
            do {
                $_
            };
            \$$2;
        };
        local $^W = 0;
        $result = eval($eval);  ## no critic
        warn "Could not eval '$eval' in $parsefile: $@@" if $@@;
        last if defined $result;
    }
    close $fh;

    $result = "undef" unless defined $result;
    return $result;
}


=item pasthru (o)

Defines the string that is passed to recursive make calls in
subdirectories.

=cut

sub pasthru {
    my($self) = shift;
    my(@@m);

    my(@@pasthru);
    my($sep) = $Is{VMS} ? ',' : '';
    $sep .= "\\\n\t";

    foreach my $key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE
                     PREFIX INSTALL_BASE)
                 ) 
    {
        next unless defined $self->{$key};
	push @@pasthru, "$key=\"\$($key)\"";
    }

    foreach my $key (qw(DEFINE INC)) {
        next unless defined $self->{$key};
	push @@pasthru, "PASTHRU_$key=\"\$(PASTHRU_$key)\"";
    }

    push @@m, "\nPASTHRU = ", join ($sep, @@pasthru), "\n";
    join "", @@m;
}

=item perl_script

Takes one argument, a file name, and returns the file name, if the
argument is likely to be a perl script. On MM_Unix this is true for
any ordinary, readable file.

=cut

sub perl_script {
    my($self,$file) = @@_;
    return $file if -r $file && -f _;
    return;
}

=item perldepend (o)

Defines the dependency from all *.h files that come with the perl
distribution.

=cut

sub perldepend {
    my($self) = shift;
    my(@@m);

    my $make_config = $self->cd('$(PERL_SRC)', '$(MAKE) lib/Config.pm');

    push @@m, sprintf <<'MAKE_FRAG', $make_config if $self->{PERL_SRC};
# Check for unpropogated config.sh changes. Should never happen.
# We do NOT just update config.h because that is not sufficient.
# An out of date config.h is not fatal but complains loudly!
$(PERL_INC)/config.h: $(PERL_SRC)/config.sh
	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; $(FALSE)

$(PERL_ARCHLIB)/Config.pm: $(PERL_SRC)/config.sh
	$(NOECHO) $(ECHO) "Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh"
	%s
MAKE_FRAG

    return join "", @@m unless $self->needs_linking;

    push @@m, q{
PERL_HDRS = \
	$(PERL_INC)/EXTERN.h		\
	$(PERL_INC)/INTERN.h		\
	$(PERL_INC)/XSUB.h		\
	$(PERL_INC)/av.h		\
	$(PERL_INC)/cc_runtime.h	\
	$(PERL_INC)/config.h		\
	$(PERL_INC)/cop.h		\
	$(PERL_INC)/cv.h		\
	$(PERL_INC)/dosish.h		\
	$(PERL_INC)/embed.h		\
	$(PERL_INC)/embedvar.h		\
	$(PERL_INC)/fakethr.h		\
	$(PERL_INC)/form.h		\
	$(PERL_INC)/gv.h		\
	$(PERL_INC)/handy.h		\
	$(PERL_INC)/hv.h		\
	$(PERL_INC)/intrpvar.h		\
	$(PERL_INC)/iperlsys.h		\
	$(PERL_INC)/keywords.h		\
	$(PERL_INC)/mg.h		\
	$(PERL_INC)/nostdio.h		\
	$(PERL_INC)/op.h		\
	$(PERL_INC)/opcode.h		\
	$(PERL_INC)/patchlevel.h	\
	$(PERL_INC)/perl.h		\
	$(PERL_INC)/perlio.h		\
	$(PERL_INC)/perlsdio.h		\
	$(PERL_INC)/perlsfio.h		\
	$(PERL_INC)/perlvars.h		\
	$(PERL_INC)/perly.h		\
	$(PERL_INC)/pp.h		\
	$(PERL_INC)/pp_proto.h		\
	$(PERL_INC)/proto.h		\
	$(PERL_INC)/regcomp.h		\
	$(PERL_INC)/regexp.h		\
	$(PERL_INC)/regnodes.h		\
	$(PERL_INC)/scope.h		\
	$(PERL_INC)/sv.h		\
	$(PERL_INC)/thread.h		\
	$(PERL_INC)/unixish.h		\
	$(PERL_INC)/util.h

$(OBJECT) : $(PERL_HDRS)
} if $self->{OBJECT};

    push @@m, join(" ", values %{$self->{XS}})." : \$(XSUBPPDEPS)\n"  if %{$self->{XS}};

    join "\n", @@m;
}


=item pm_to_blib

Defines target that copies all files in the hash PM to their
destination and autosplits them. See L<ExtUtils::Install/DESCRIPTION>

=cut

sub pm_to_blib {
    my $self = shift;
    my($autodir) = $self->catdir('$(INST_LIB)','auto');
    my $r = q{
pm_to_blib : $(FIRST_MAKEFILE) $(TO_INST_PM)
};

    # VMS will swallow '' and PM_FILTER is often empty.  So use q[]
    my $pm_to_blib = $self->oneliner(<<CODE, ['-MExtUtils::Install']);
pm_to_blib({\@@ARGV}, '$autodir', q[\$(PM_FILTER)], '\$(PERM_DIR)')
CODE

    my @@cmds = $self->split_command($pm_to_blib, %{$self->{PM}});

    $r .= join '', map { "\t\$(NOECHO) $_\n" } @@cmds;
    $r .= qq{\t\$(NOECHO) \$(TOUCH) pm_to_blib\n};

    return $r;
}

=item post_constants (o)

Returns an empty string per default. Dedicated to overrides from
within Makefile.PL after all constants have been defined.

=cut

sub post_constants{
    "";
}

=item post_initialize (o)

Returns an empty string per default. Used in Makefile.PLs to add some
chunk of text to the Makefile after the object is initialized.

=cut

sub post_initialize {
    "";
}

=item postamble (o)

Returns an empty string. Can be used in Makefile.PLs to write some
text to the Makefile at the end.

=cut

sub postamble {
    "";
}

# transform dot-separated version string into comma-separated quadruple
# examples:  '1.2.3.4.5' => '1,2,3,4'
#            '1.2.3'     => '1,2,3,0'
sub _ppd_version {
    my ($self, $string) = @@_;
    return join ',', ((split /\./, $string), (0) x 4)[0..3];
}

=item ppd

Defines target that creates a PPD (Perl Package Description) file
for a binary distribution.

=cut

sub ppd {
    my($self) = @@_;

    my $abstract = $self->{ABSTRACT} || '';
    $abstract =~ s/\n/\\n/sg;
    $abstract =~ s/</&lt;/g;
    $abstract =~ s/>/&gt;/g;

    my $author = $self->{AUTHOR} || '';
    $author =~ s/</&lt;/g;
    $author =~ s/>/&gt;/g;

    my $ppd_xml = sprintf <<'PPD_HTML', $self->{VERSION}, $abstract, $author;
<SOFTPKG NAME="$(DISTNAME)" VERSION="%s">
    <ABSTRACT>%s</ABSTRACT>
    <AUTHOR>%s</AUTHOR>
PPD_HTML

    $ppd_xml .= "    <IMPLEMENTATION>\n";
    if ( $self->{MIN_PERL_VERSION} ) {
        my $min_perl_version = $self->_ppd_version($self->{MIN_PERL_VERSION});
        $ppd_xml .= sprintf <<'PPD_PERLVERS', $min_perl_version;
        <PERLCORE VERSION="%s" />
PPD_PERLVERS

    }

    # Don't add "perl" to requires.  perl dependencies are
    # handles by ARCHITECTURE.
    my %prereqs = %{$self->{PREREQ_PM}};
    delete $prereqs{perl};

    # Build up REQUIRE
    foreach my $prereq (sort keys %prereqs) {
        my $name = $prereq;
        $name .= '::' unless $name =~ /::/;
        my $version = $prereqs{$prereq}+0;  # force numification

        my %attrs = ( NAME => $name );
        $attrs{VERSION} = $version if $version;
        my $attrs = join " ", map { qq[$_="$attrs{$_}"] } keys %attrs;
        $ppd_xml .= qq(        <REQUIRE $attrs />\n);
    }

    my $archname = $Config{archname};
    if ($] >= 5.008) {
        # archname did not change from 5.6 to 5.8, but those versions may
        # not be not binary compatible so now we append the part of the
        # version that changes when binary compatibility may change
        $archname .= "-$Config{PERL_REVISION}.$Config{PERL_VERSION}";
    }
    $ppd_xml .= sprintf <<'PPD_OUT', $archname;
        <ARCHITECTURE NAME="%s" />
PPD_OUT

    if ($self->{PPM_INSTALL_SCRIPT}) {
        if ($self->{PPM_INSTALL_EXEC}) {
            $ppd_xml .= sprintf qq{        <INSTALL EXEC="%s">%s</INSTALL>\n},
                  $self->{PPM_INSTALL_EXEC}, $self->{PPM_INSTALL_SCRIPT};
        }
        else {
            $ppd_xml .= sprintf qq{        <INSTALL>%s</INSTALL>\n}, 
                  $self->{PPM_INSTALL_SCRIPT};
        }
    }

    my ($bin_location) = $self->{BINARY_LOCATION} || '';
    $bin_location =~ s/\\/\\\\/g;

    $ppd_xml .= sprintf <<'PPD_XML', $bin_location;
        <CODEBASE HREF="%s" />
    </IMPLEMENTATION>
</SOFTPKG>
PPD_XML

    my @@ppd_cmds = $self->echo($ppd_xml, '$(DISTNAME).ppd');

    return sprintf <<'PPD_OUT', join "\n\t", @@ppd_cmds;
# Creates a PPD (Perl Package Description) for a binary distribution.
ppd :
	%s
PPD_OUT

}

=item prefixify

  $MM->prefixify($var, $prefix, $new_prefix, $default);

Using either $MM->{uc $var} || $Config{lc $var}, it will attempt to
replace it's $prefix with a $new_prefix.  

Should the $prefix fail to match I<AND> a PREFIX was given as an
argument to WriteMakefile() it will set it to the $new_prefix +
$default.  This is for systems whose file layouts don't neatly fit into
our ideas of prefixes.

This is for heuristics which attempt to create directory structures
that mirror those of the installed perl.

For example:

    $MM->prefixify('installman1dir', '/usr', '/home/foo', 'man/man1');

this will attempt to remove '/usr' from the front of the
$MM->{INSTALLMAN1DIR} path (initializing it to $Config{installman1dir}
if necessary) and replace it with '/home/foo'.  If this fails it will
simply use '/home/foo/man/man1'.

=cut

sub prefixify {
    my($self,$var,$sprefix,$rprefix,$default) = @@_;

    my $path = $self->{uc $var} || 
               $Config_Override{lc $var} || $Config{lc $var} || '';

    $rprefix .= '/' if $sprefix =~ m|/$|;

    print STDERR "  prefixify $var => $path\n" if $Verbose >= 2;
    print STDERR "    from $sprefix to $rprefix\n" if $Verbose >= 2;

    if( $self->{ARGS}{PREFIX} &&
        $path !~ s{^\Q$sprefix\E\b}{$rprefix}s ) 
    {

        print STDERR "    cannot prefix, using default.\n" if $Verbose >= 2;
        print STDERR "    no default!\n" if !$default && $Verbose >= 2;

        $path = $self->catdir($rprefix, $default) if $default;
    }

    print "    now $path\n" if $Verbose >= 2;
    return $self->{uc $var} = $path;
}


=item processPL (o)

Defines targets to run *.PL files.

=cut

sub processPL {
    my $self = shift;
    my $pl_files = $self->{PL_FILES};

    return "" unless $pl_files;

    my $m = '';
    foreach my $plfile (sort keys %$pl_files) {
        my $list = ref($pl_files->{$plfile})
                     ?  $pl_files->{$plfile}
		     : [$pl_files->{$plfile}];

	foreach my $target (@@$list) {
            if( $Is{VMS} ) {
                $plfile = vmsify($self->eliminate_macros($plfile));
                $target = vmsify($self->eliminate_macros($target));
            }

	    # Normally a .PL file runs AFTER pm_to_blib so it can have
	    # blib in its @@INC and load the just built modules.  BUT if
	    # the generated module is something in $(TO_INST_PM) which
	    # pm_to_blib depends on then it can't depend on pm_to_blib
	    # else we have a dependency loop.
	    my $pm_dep;
	    my $perlrun;
	    if( defined $self->{PM}{$target} ) {
		$pm_dep  = '';
		$perlrun = 'PERLRUN';
	    }
	    else {
		$pm_dep  = 'pm_to_blib';
		$perlrun = 'PERLRUNINST';
	    }

            $m .= <<MAKE_FRAG;

all :: $target
	\$(NOECHO) \$(NOOP)

$target :: $plfile $pm_dep
	\$($perlrun) $plfile $target
MAKE_FRAG

	}
    }

    return $m;
}

=item quote_paren

Backslashes parentheses C<()> in command line arguments.
Doesn't handle recursive Makefile C<$(...)> constructs,
but handles simple ones.

=cut

sub quote_paren {
    my $arg = shift;
    $arg =~ s{\$\((.+?)\)}{\$\\\\($1\\\\)}g;	# protect $(...)
    $arg =~ s{(?<!\\)([()])}{\\$1}g;		# quote unprotected
    $arg =~ s{\$\\\\\((.+?)\\\\\)}{\$($1)}g;	# unprotect $(...)
    return $arg;
}

=item replace_manpage_separator

  my $man_name = $MM->replace_manpage_separator($file_path);

Takes the name of a package, which may be a nested package, in the
form 'Foo/Bar.pm' and replaces the slash with C<::> or something else
safe for a man page file name.  Returns the replacement.

=cut

sub replace_manpage_separator {
    my($self,$man) = @@_;

    $man =~ s,/+,::,g;
    return $man;
}


=item cd

=cut

sub cd {
    my($self, $dir, @@cmds) = @@_;

    # No leading tab and no trailing newline makes for easier embedding
    my $make_frag = join "\n\t", map { "cd $dir && $_" } @@cmds;

    return $make_frag;
}

=item oneliner

=cut

sub oneliner {
    my($self, $cmd, $switches) = @@_;
    $switches = [] unless defined $switches;

    # Strip leading and trailing newlines
    $cmd =~ s{^\n+}{};
    $cmd =~ s{\n+$}{};

    my @@cmds = split /\n/, $cmd;
    $cmd = join " \n\t  -e ", map $self->quote_literal($_), @@cmds;
    $cmd = $self->escape_newlines($cmd);

    $switches = join ' ', @@$switches;

    return qq{\$(ABSPERLRUN) $switches -e $cmd --};   
}


=item quote_literal

=cut

sub quote_literal {
    my($self, $text) = @@_;

    # I think all we have to quote is single quotes and I think
    # this is a safe way to do it.
    $text =~ s{'}{'\\''}g;

    return "'$text'";
}


=item escape_newlines

=cut

sub escape_newlines {
    my($self, $text) = @@_;

    $text =~ s{\n}{\\\n}g;

    return $text;
}


=item max_exec_len

Using POSIX::ARG_MAX.  Otherwise falling back to 4096.

=cut

sub max_exec_len {
    my $self = shift;

    if (!defined $self->{_MAX_EXEC_LEN}) {
        if (my $arg_max = eval { require POSIX;  &POSIX::ARG_MAX }) {
            $self->{_MAX_EXEC_LEN} = $arg_max;
        }
        else {      # POSIX minimum exec size
            $self->{_MAX_EXEC_LEN} = 4096;
        }
    }

    return $self->{_MAX_EXEC_LEN};
}


=item static (o)

Defines the static target.

=cut

sub static {
# --- Static Loading Sections ---

    my($self) = shift;
    '
## $(INST_PM) has been moved to the all: target.
## It remains here for awhile to allow for old usage: "make static"
static :: $(FIRST_MAKEFILE) $(INST_STATIC)
	$(NOECHO) $(NOOP)
';
}

=item static_lib (o)

Defines how to produce the *.a (or equivalent) files.

=cut

sub static_lib {
    my($self) = @@_;
    return '' unless $self->has_link_code;

    my(@@m);
    push(@@m, <<'END');

$(INST_STATIC) : $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
	$(RM_RF) $@@
END

    # If this extension has its own library (eg SDBM_File)
    # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
    push(@@m, <<'MAKE_FRAG') if $self->{MYEXTLIB};
	$(CP) $(MYEXTLIB) $@@
MAKE_FRAG

    my $ar; 
    if (exists $self->{FULL_AR} && -x $self->{FULL_AR}) {
        # Prefer the absolute pathed ar if available so that PATH
        # doesn't confuse us.  Perl itself is built with the full_ar.  
        $ar = 'FULL_AR';
    } else {
        $ar = 'AR';
    }
    push @@m, sprintf <<'MAKE_FRAG', $ar;
	$(%s) $(AR_STATIC_ARGS) $@@ $(OBJECT) && $(RANLIB) $@@
	$(CHMOD) $(PERM_RWX) $@@
	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)/extralibs.ld
MAKE_FRAG

    # Old mechanism - still available:
    push @@m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};
	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)/ext.libs
MAKE_FRAG

    join('', @@m);
}

=item staticmake (o)

Calls makeaperl.

=cut

sub staticmake {
    my($self, %attribs) = @@_;
    my(@@static);

    my(@@searchdirs)=($self->{PERL_ARCHLIB}, $self->{SITEARCHEXP},  $self->{INST_ARCHLIB});

    # And as it's not yet built, we add the current extension
    # but only if it has some C code (or XS code, which implies C code)
    if (@@{$self->{C}}) {
	@@static = $self->catfile($self->{INST_ARCHLIB},
				 "auto",
				 $self->{FULLEXT},
				 "$self->{BASEEXT}$self->{LIB_EXT}"
				);
    }

    # Either we determine now, which libraries we will produce in the
    # subdirectories or we do it at runtime of the make.

    # We could ask all subdir objects, but I cannot imagine, why it
    # would be necessary.

    # Instead we determine all libraries for the new perl at
    # runtime.
    my(@@perlinc) = ($self->{INST_ARCHLIB}, $self->{INST_LIB}, $self->{PERL_ARCHLIB}, $self->{PERL_LIB});

    $self->makeaperl(MAKE	=> $self->{MAKEFILE},
		     DIRS	=> \@@searchdirs,
		     STAT	=> \@@static,
		     INCL	=> \@@perlinc,
		     TARGET	=> $self->{MAP_TARGET},
		     TMP	=> "",
		     LIBPERL	=> $self->{LIBPERL_A}
		    );
}

=item subdir_x (o)

Helper subroutine for subdirs

=cut

sub subdir_x {
    my($self, $subdir) = @@_;

    my $subdir_cmd = $self->cd($subdir, 
      '$(MAKE) $(USEMAKEFILE) $(FIRST_MAKEFILE) all $(PASTHRU)'
    );
    return sprintf <<'EOT', $subdir_cmd;

subdirs ::
	$(NOECHO) %s
EOT

}

=item subdirs (o)

Defines targets to process subdirectories.

=cut

sub subdirs {
# --- Sub-directory Sections ---
    my($self) = shift;
    my(@@m);
    # This method provides a mechanism to automatically deal with
    # subdirectories containing further Makefile.PL scripts.
    # It calls the subdir_x() method for each subdirectory.
    foreach my $dir (@@{$self->{DIR}}){
	push(@@m, $self->subdir_x($dir));
####	print "Including $dir subdirectory\n";
    }
    if (@@m){
	unshift(@@m, "
# The default clean, realclean and test targets in this Makefile
# have automatically been given entries for each subdir.

");
    } else {
	push(@@m, "\n# none")
    }
    join('',@@m);
}

=item test (o)

Defines the test targets.

=cut

sub test {
# --- Test and Installation Sections ---

    my($self, %attribs) = @@_;
    my $tests = $attribs{TESTS} || '';
    if (!$tests && -d 't') {
        $tests = $self->find_tests;
    }
    # note: 'test.pl' name is also hardcoded in init_dirscan()
    my(@@m);
    push(@@m,"
TEST_VERBOSE=0
TEST_TYPE=test_\$(LINKTYPE)
TEST_FILE = test.pl
TEST_FILES = $tests
TESTDB_SW = -d

testdb :: testdb_\$(LINKTYPE)

test :: \$(TEST_TYPE) subdirs-test

subdirs-test ::
	\$(NOECHO) \$(NOOP)

");

    foreach my $dir (@@{ $self->{DIR} }) {
        my $test = $self->cd($dir, '$(MAKE) test $(PASTHRU)');

        push @@m, <<END
subdirs-test ::
	\$(NOECHO) $test

END
    }

    push(@@m, "\t\$(NOECHO) \$(ECHO) 'No tests defined for \$(NAME) extension.'\n")
	unless $tests or -f "test.pl" or @@{$self->{DIR}};
    push(@@m, "\n");

    push(@@m, "test_dynamic :: pure_all\n");
    push(@@m, $self->test_via_harness('$(FULLPERLRUN)', '$(TEST_FILES)')) 
      if $tests;
    push(@@m, $self->test_via_script('$(FULLPERLRUN)', '$(TEST_FILE)')) 
      if -f "test.pl";
    push(@@m, "\n");

    push(@@m, "testdb_dynamic :: pure_all\n");
    push(@@m, $self->test_via_script('$(FULLPERLRUN) $(TESTDB_SW)', 
                                    '$(TEST_FILE)'));
    push(@@m, "\n");

    # Occasionally we may face this degenerate target:
    push @@m, "test_ : test_dynamic\n\n";

    if ($self->needs_linking()) {
	push(@@m, "test_static :: pure_all \$(MAP_TARGET)\n");
	push(@@m, $self->test_via_harness('./$(MAP_TARGET)', '$(TEST_FILES)')) if $tests;
	push(@@m, $self->test_via_script('./$(MAP_TARGET)', '$(TEST_FILE)')) if -f "test.pl";
	push(@@m, "\n");
	push(@@m, "testdb_static :: pure_all \$(MAP_TARGET)\n");
	push(@@m, $self->test_via_script('./$(MAP_TARGET) $(TESTDB_SW)', '$(TEST_FILE)'));
	push(@@m, "\n");
    } else {
	push @@m, "test_static :: test_dynamic\n";
	push @@m, "testdb_static :: testdb_dynamic\n";
    }
    join("", @@m);
}

=item test_via_harness (override)

For some reason which I forget, Unix machines like to have
PERL_DL_NONLAZY set for tests.

=cut

sub test_via_harness {
    my($self, $perl, $tests) = @@_;
    return $self->SUPER::test_via_harness("PERL_DL_NONLAZY=1 $perl", $tests);
}

=item test_via_script (override)

Again, the PERL_DL_NONLAZY thing.

=cut

sub test_via_script {
    my($self, $perl, $script) = @@_;
    return $self->SUPER::test_via_script("PERL_DL_NONLAZY=1 $perl", $script);
}


=item tool_xsubpp (o)

Determines typemaps, xsubpp version, prototype behaviour.

=cut

sub tool_xsubpp {
    my($self) = shift;
    return "" unless $self->needs_linking;

    my $xsdir;
    my @@xsubpp_dirs = @@INC;

    # Make sure we pick up the new xsubpp if we're building perl.
    unshift @@xsubpp_dirs, $self->{PERL_LIB} if $self->{PERL_CORE};

    foreach my $dir (@@xsubpp_dirs) {
        $xsdir = $self->catdir($dir, 'ExtUtils');
        if( -r $self->catfile($xsdir, "xsubpp") ) {
            last;
        }
    }

    my $tmdir   = File::Spec->catdir($self->{PERL_LIB},"ExtUtils");
    my(@@tmdeps) = $self->catfile($tmdir,'typemap');
    if( $self->{TYPEMAPS} ){
        foreach my $typemap (@@{$self->{TYPEMAPS}}){
            if( ! -f  $typemap ) {
                warn "Typemap $typemap not found.\n";
            }
            else {
                push(@@tmdeps,  $typemap);
            }
        }
    }
    push(@@tmdeps, "typemap") if -f "typemap";
    my(@@tmargs) = map("-typemap $_", @@tmdeps);
    if( exists $self->{XSOPT} ){
        unshift( @@tmargs, $self->{XSOPT} );
    }

    if ($Is{VMS}                          &&
        $Config{'ldflags'}               && 
        $Config{'ldflags'} =~ m!/Debug!i &&
        (!exists($self->{XSOPT}) || $self->{XSOPT} !~ /linenumbers/)
       ) 
    {
        unshift(@@tmargs,'-nolinenumbers');
    }


    $self->{XSPROTOARG} = "" unless defined $self->{XSPROTOARG};

    return qq{
XSUBPPDIR = $xsdir
XSUBPP = \$(XSUBPPDIR)\$(DFSEP)xsubpp
XSUBPPRUN = \$(PERLRUN) \$(XSUBPP)
XSPROTOARG = $self->{XSPROTOARG}
XSUBPPDEPS = @@tmdeps \$(XSUBPP)
XSUBPPARGS = @@tmargs
XSUBPP_EXTRA_ARGS = 
};
};


=item all_target

Build man pages, too

=cut

sub all_target {
    my $self = shift;

    return <<'MAKE_EXT';
all :: pure_all manifypods
	$(NOECHO) $(NOOP)
MAKE_EXT
}

=item top_targets (o)

Defines the targets all, subdirs, config, and O_FILES

=cut

sub top_targets {
# --- Target Sections ---

    my($self) = shift;
    my(@@m);

    push @@m, $self->all_target, "\n" unless $self->{SKIPHASH}{'all'};

    push @@m, '
pure_all :: config pm_to_blib subdirs linkext
	$(NOECHO) $(NOOP)

subdirs :: $(MYEXTLIB)
	$(NOECHO) $(NOOP)

config :: $(FIRST_MAKEFILE) blibdirs
	$(NOECHO) $(NOOP)
';

    push @@m, '
$(O_FILES): $(H_FILES)
' if @@{$self->{O_FILES} || []} && @@{$self->{H} || []};

    push @@m, q{
help :
	perldoc ExtUtils::MakeMaker
};

    join('',@@m);
}

=item writedoc

Obsolete, deprecated method. Not used since Version 5.21.

=cut

sub writedoc {
# --- perllocal.pod section ---
    my($self,$what,$name,@@attribs)=@@_;
    my $time = localtime;
    print "=head2 $time: $what C<$name>\n\n=over 4\n\n=item *\n\n";
    print join "\n\n=item *\n\n", map("C<$_>",@@attribs);
    print "\n\n=back\n\n";
}

=item xs_c (o)

Defines the suffix rules to compile XS files to C.

=cut

sub xs_c {
    my($self) = shift;
    return '' unless $self->needs_linking();
    '
.xs.c:
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
';
}

=item xs_cpp (o)

Defines the suffix rules to compile XS files to C++.

=cut

sub xs_cpp {
    my($self) = shift;
    return '' unless $self->needs_linking();
    '
.xs.cpp:
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.cpp
';
}

=item xs_o (o)

Defines suffix rules to go from XS to object files directly. This is
only intended for broken make implementations.

=cut

sub xs_o {	# many makes are too dumb to use xs_c then c_o
    my($self) = shift;
    return '' unless $self->needs_linking();
    '
.xs$(OBJ_EXT):
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c
';
}


1;

=back

=head1 SEE ALSO

L<ExtUtils::MakeMaker>

=cut

__END__
@


1.24
log
@Merge in some local changes that got lost.
@
text
@@


1.23
log
@Merge in perl 5.10.1
@
text
@d292 1
a292 1
	$(CCFLAGS) $(OPTIMIZE) \\
@


1.22
log
@Remove hack from MM_Unix.pm and simply set man1dir to 'none' in
installperl to prevent man page installation of the perl man pages.
@
text
@d3 1
a3 1
require 5.005_03;  # Maybe further back, dunno
d12 1
a12 6
use vars qw($VERSION @@ISA
            $Is_OS2 $Is_VMS $Is_Win32 $Is_Dos
            $Is_OSF $Is_IRIX  $Is_NetBSD $Is_BSD
            $Is_SunOS4 $Is_Solaris $Is_SunOS $Is_Interix
            %Config_Override
           );
d16 3
a18 1
$VERSION = '6.42';
d21 1
a21 1
@@ISA = qw(ExtUtils::MM_Any);
d23 1
d25 12
a36 12
    $Is_OS2     = $^O eq 'os2';
    $Is_Win32   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
    $Is_Dos     = $^O eq 'dos';
    $Is_VMS     = $^O eq 'VMS';
    $Is_OSF     = $^O eq 'dec_osf';
    $Is_IRIX    = $^O eq 'irix';
    $Is_NetBSD  = $^O eq 'netbsd';
    $Is_Interix = $^O eq 'interix';
    $Is_SunOS4  = $^O eq 'sunos';
    $Is_Solaris = $^O eq 'solaris';
    $Is_SunOS   = $Is_SunOS4 || $Is_Solaris;
    $Is_BSD     = ($^O =~ /^(?:free|net|open)bsd$/ or
d42 1
a42 1
    if( $Is_VMS ) {
d163 2
a164 2
	$command \$*.C
} if !$Is_OS2 and !$Is_Win32 and !$Is_Dos; #Case-specific
d232 1
a232 2
	my($line);
	foreach $line (@@o){
d292 1
a292 1
	$(CCFLAGS) $(OPTIMIZE) $(COPTS) \\
d308 6
a313 3
    my(@@m,$m);
    push(@@m,"\n# These definitions are from config.sh (via $INC{'Config.pm'})\n");
    push(@@m,"\n# They may have been overridden via Makefile.PL or on the command line\n");
d315 6
a320 6
    foreach $m (@@{$self->{CONFIG}}){
	# SITE*EXP macros are defined in &constants; avoid duplicates here
	next if $once_only{$m};
	$self->{uc $m} = quote_paren($self->{uc $m});
	push @@m, uc($m) , ' = ' , $self->{uc $m}, "\n";
	$once_only{$m} = 1;
d341 5
a345 6
    my($tmp);
    for $tmp (qw/
	 EXTRALIBS LDLOADLIBS BSLOADLIBS
	 /) {
	next unless defined $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
d348 5
a352 5
    for $tmp (qw/
	 LD_RUN_PATH
	 /) {
	next unless $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
d396 1
a396 1
              PERM_RW PERM_RWX
d860 1
a860 1
    my $target = $Is_VMS ? '$(MMS$TARGET)' : '$@@';
d899 1
a899 1
    $armaybe = 'ar' if ($Is_OSF and $armaybe eq ':');
d901 2
a902 2
    my $ld_opt = $Is_OS2 ? '$(OPTIMIZE) ' : '';	# Useful on other systems too?
    my $ld_fix = $Is_OS2 ? '|| ( $(RM_F) $@@ && sh -c false )' : '';
d918 1
a918 1
    $ldfrom = "-all $ldfrom -none" if $Is_OSF;
d921 1
a921 1
    my $ldrun = $Is_IRIX && $self->{LD_RUN_PATH} ?         
d934 1
a934 1
    if (($Is_NetBSD || $Is_Interix) && $Config{'useshrplib'} eq 'true') {
d996 1
a996 1
    my($name, $dir);
d1007 4
a1010 2
    unless ($Is_BSD) {
        if( open(STDERR_COPY, '>&STDERR') ) {
d1021 2
a1022 2
    foreach $name (@@$names){
        foreach $dir (@@$dirs){
d1047 1
a1047 1
            if ($Is_BSD) {
d1052 4
a1055 1
                open STDERR, '>&STDERR_COPY' if $stderr_duped;
d1087 1
a1087 3
        local (*FIXIN);
        local (*FIXOUT);
        open( FIXIN, $file ) or croak "Can't process '$file': $!";
d1089 1
a1089 1
        chomp( my $line = <FIXIN> );
d1097 1
a1097 1
        if ( $cmd eq "perl" ) {
d1108 1
a1108 1
                = reverse grep { $self->file_name_is_absolute } $self->path;
d1110 2
a1111 2
            my ($dir);
            foreach $dir (@@absdirs) {
d1136 1
a1136 1
} unless $Is_Win32;    # this won't work on win32, so don't
d1144 1
a1144 1
        unless ( open( FIXOUT, ">$file_new" ) ) {
d1147 1
a1147 1
        }
d1152 3
a1154 3
        print FIXOUT $shb, <FIXIN>;
        close FIXIN;
        close FIXOUT;
a1172 1
        close(FIXIN) if fileno(FIXIN);
d1182 1
a1182 1
        if( $Is_VMS and basename($file) !~ /\./ ) {
d1258 1
a1258 1
    my($name, %dir, %xs, %c, %h, %pl_files, %pm);
d1263 1
a1263 1
    $Is_VMS ? $ignore{"$self->{DISTVNAME}.dir"} = 1
d1266 1
a1266 1
    @@ignore{map lc, keys %ignore} = values %ignore if $Is_VMS;
d1268 1
a1268 1
    foreach $name ($self->lsdir($Curdir)){
d1287 1
a1287 1
	} elsif (($Is_VMS || $Is_Dos) && $name =~ /[._]pl$/i) {
d1290 1
a1290 1
	    local($/); open(PL,$name); my $txt = <PL>; close PL;
d1294 1
a1294 1
	    else { 
d1326 1
a1326 1
	if ( $self->{"${man}PODS"}
d1334 1
a1334 1
	}
a1341 1
    local *FH;
d1343 8
a1350 8
    if (open(FH,"<$file")) {
	while (<FH>) {
	    if (/^=(?:head\d+|item|pod)\b/) {
		$ispod=1;
		last;
	    }
	}
	close FH;
d1352 2
a1353 2
	# If it doesn't exist yet, we assume, it has pods in it
	$ispod = 1;
d1464 1
a1464 1
        if( $Is_VMS ) {
d1502 3
a1504 2
            return if /~$/;    # emacs temp files
            return if /,v$/;   # RCS files
d1600 1
a1600 1
                -f $self->catfile($dir,"lib","Exporter.pm")
d1619 1
a1619 1
                                 $Is_Win32?("CORE"):());
d1623 1
a1623 1
            $self->{PERL_INC}     = ($Is_Win32) ? 
d1631 1
a1631 1
		$Is_VMS
d1635 1
a1635 1
		$Is_Win32
d1665 1
a1665 1
	      $lib = $dir, last if -e $self->catdir($dir, "Config.pm");
d1670 1
a1670 1
	      my $inc = $Is_Win32 ? $self->catdir($lib, "CORE" )
d1672 1
a1672 1
	      if (-e $self->catdir($inc, "perl.h")) {
d1697 1
a1697 1
	if ($self->{CONFIG} and ref $self->{CONFIG} ne 'ARRAY');
d1703 5
a1707 5
	next if $once_only{$m};
	print STDOUT "CONFIG key '$m' does not exist in Config.pm\n"
		unless exists $Config{$m};
	$self->{uc $m} ||= $Config{$m};
	$once_only{$m} = 1;
d1727 1
a1727 1
    # make a simple check if we find Exporter
d1729 3
a1731 3
        (Exporter.pm not found)"
	unless -f $self->catfile("$self->{PERL_LIB}","Exporter.pm") ||
        $self->{NAME} eq "ExtUtils::MakeMaker";
a1745 63
    $self->{LD} ||= 'ld';

    # Compute EXTRALIBS, BSLOADLIBS and LDLOADLIBS from $self->{LIBS}
    # Lets look at $self->{LIBS} carefully: It may be an anon array, a string or
    # undefined. In any case we turn it into an anon array:

    # May check $Config{libs} too, thus not empty.
    $self->{LIBS} = [$self->{LIBS}] unless ref $self->{LIBS};

    $self->{LIBS} = [''] unless @@{$self->{LIBS}} && defined $self->{LIBS}[0];
    $self->{LD_RUN_PATH} = "";
    my($libs);
    foreach $libs ( @@{$self->{LIBS}} ){
	$libs =~ s/^\s*(.*\S)\s*$/$1/; # remove leading and trailing whitespace
	my(@@libs) = $self->extliblist($libs);
	if ($libs[0] or $libs[1] or $libs[2]){
	    # LD_RUN_PATH now computed by ExtUtils::Liblist
	    ($self->{EXTRALIBS},  $self->{BSLOADLIBS}, 
             $self->{LDLOADLIBS}, $self->{LD_RUN_PATH}) = @@libs;
	    last;
	}
    }

    if ( $self->{OBJECT} ) {
	$self->{OBJECT} =~ s!\.o(bj)?\b!\$(OBJ_EXT)!g;
    } else {
	# init_dirscan should have found out, if we have C files
	$self->{OBJECT} = "";
	$self->{OBJECT} = '$(BASEEXT)$(OBJ_EXT)' if @@{$self->{C}||[]};
    }
    $self->{OBJECT} =~ s/\n+/ \\\n\t/g;
    $self->{BOOTDEP}  = (-f "$self->{BASEEXT}_BS") ? "$self->{BASEEXT}_BS" : "";
    $self->{PERLMAINCC} ||= '$(CC)';
    $self->{LDFROM} = '$(OBJECT)' unless $self->{LDFROM};

    # Sanity check: don't define LINKTYPE = dynamic if we're skipping
    # the 'dynamic' section of MM.  We don't have this problem with
    # 'static', since we either must use it (%Config says we can't
    # use dynamic loading) or the caller asked for it explicitly.
    if (!$self->{LINKTYPE}) {
       $self->{LINKTYPE} = $self->{SKIPHASH}{'dynamic'}
                        ? 'static'
                        : ($Config{usedl} ? 'dynamic' : 'static');
    };

    $self->{NOOP}               ||= '$(SHELL) -c true';
    $self->{NOECHO}             = '@@' unless defined $self->{NOECHO};

    $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE} || 'Makefile';
    $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE};
    $self->{MAKEFILE_OLD}       ||= $self->{MAKEFILE}.'.old';
    $self->{MAKE_APERL_FILE}    ||= $self->{MAKEFILE}.'.aperl';

    # Some makes require a wrapper around macros passed in on the command 
    # line.
    $self->{MACROSTART}         ||= '';
    $self->{MACROEND}           ||= '';

    # Not everybody uses -f to indicate "use this Makefile instead"
    $self->{USEMAKEFILE}        ||= '-f';

    $self->{SHELL}              ||= $Config{sh} || '/bin/sh';

d1755 6
a1760 18
    $self->{MKPATH}     ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e mkpath';
    $self->{EQUALIZE_TIMESTAMP} ||= 
      '$(ABSPERLRUN) "-MExtUtils::Command" -e eqtime';

    $self->{UNINST}     ||= 0;
    $self->{VERBINST}   ||= 0;
    $self->{MOD_INSTALL} ||= 
      $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
install({@@ARGV}, '$(VERBINST)', 0, '$(UNINST)');
CODE
    $self->{DOC_INSTALL}        ||= 
      '$(ABSPERLRUN) "-MExtUtils::Command::MM" -e perllocal_install';
    $self->{UNINSTALL}          ||= 
      '$(ABSPERLRUN) "-MExtUtils::Command::MM" -e uninstall';
    $self->{WARN_IF_OLD_PACKLIST} ||= 
      '$(ABSPERLRUN) "-MExtUtils::Command::MM" -e warn_if_old_packlist';
    $self->{FIXIN}              ||= 
      q{$(PERLRUN) "-MExtUtils::MY" -e "MY->fixin(shift)"};
d1762 3
a1764 2
    $self->{UMASK_NULL}         ||= "umask 0";
    $self->{DEV_NULL}           ||= "> /dev/null 2>&1";
d1861 1
a1861 1
      $Is_VMS ? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i
d1888 1
a1888 1
    $perl_name = 'ndbgperl' if $Is_VMS && 
d1906 5
d1979 1
d2024 1
a2024 1
install :: all pure_install doc_install
d2027 1
a2027 1
install_perl :: all pure_perl_install doc_perl_install
d2030 1
a2030 1
install_site :: all pure_site_install doc_site_install
d2033 1
a2033 1
install_vendor :: all pure_vendor_install doc_vendor_install
d2048 1
a2048 1
pure_perl_install ::
d2062 1
a2062 1
pure_site_install ::
d2075 1
a2075 1
pure_vendor_install ::
d2086 1
a2086 1
doc_perl_install ::
d2097 1
a2097 1
doc_site_install ::
d2108 1
a2108 1
doc_vendor_install ::
d2151 1
a2151 1
    @@exefiles = map vmsify($_), @@exefiles if $Is_VMS;
d2161 1
a2161 1
        $to = vmsify($to) if $Is_VMS;
a2334 2
		my $incl;
		my $xx;
d2336 1
a2336 1
		($xx = $File::Find::name) =~ s,.*?/auto/,,s;
d2342 1
a2342 1
		foreach $incl ((@@{$self->{INCLUDE_EXT}},'DynaLoader')){
d2351 1
a2351 4
		my $excl;
		my $xx;

		($xx = $File::Find::name) =~ s,.*?/auto/,,s;
d2356 1
a2356 1
		foreach $excl (@@{$self->{EXCLUDE_EXT}}){
d2384 1
a2384 1
    grep(s/^(.*)/"-I$1"/, @@{$perlinc || []});
d2414 1
a2414 1
          if ($Is_SunOS) {
d2417 1
a2417 1
            $libperl = '' if $Is_SunOS4;
d2441 1
a2441 2
    my $catfile;
    foreach $catfile (@@$extra){
d2513 1
a2513 1
    my $newer_than_target = $Is_VMS ? '$(MMS$SOURCE_LIST)' : '$?';
d2528 1
a2528 1
	false
d2558 2
a2559 2
    my($child,$caller);
    $caller = (caller(0))[3];
d2567 1
a2567 1
    foreach $child (keys %{$self->{CHILDREN}}) {
d2586 1
a2586 1
    local *FH;
d2588 1
a2588 1
    open(FH,$parsefile) or die "Could not open '$parsefile': $!";
d2592 1
a2592 1
    while (<FH>) {
d2600 2
a2601 1
    close FH;
d2614 2
a2615 1
parse_version() will try to C<use version> before checking for C<$VERSION> so the following will work.
d2624 1
a2624 1
    local *FH;
d2627 1
a2627 1
    open(FH,$parsefile) or die "Could not open '$parsefile': $!";
d2629 1
a2629 1
    while (<FH>) {
d2633 2
a2634 1
        next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
d2651 2
a2652 1
            }; \$$2
d2655 1
a2655 1
        $result = eval($eval);
d2657 1
a2657 1
        last;
d2659 1
a2659 1
    close FH;
d2675 1
a2675 1
    my(@@m,$key);
d2678 1
a2678 1
    my($sep) = $Is_VMS ? ',' : '';
d2681 1
a2681 1
    foreach $key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE
d2689 1
a2689 1
    foreach $key (qw(DEFINE INC)) {
d2730 1
a2730 1
	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; false
a2791 29
=item perm_rw (o)

Returns the attribute C<PERM_RW> or the string C<644>.
Used as the string that is passed
to the C<chmod> command to set the permissions for read/writeable files.
MakeMaker chooses C<644> because it has turned out in the past that
relying on the umask provokes hard-to-track bug reports.
When the return value is used by the perl function C<chmod>, it is
interpreted as an octal value.

=cut

sub perm_rw {
    return shift->{PERM_RW};
}

=item perm_rwx (o)

Returns the attribute C<PERM_RWX> or the string C<755>,
i.e. the string that is passed
to the C<chmod> command to set the permissions for executable files.
See also perl_rw.

=cut

sub perm_rwx {
    return shift->{PERM_RWX};
}

d2803 1
a2803 1
pm_to_blib : $(TO_INST_PM)
d2806 1
d2808 1
a2808 1
pm_to_blib({\@@ARGV}, '$autodir', '\$(PM_FILTER)')
d2852 8
a2869 2
    my ($pack_ver) = join ",", (split (/\./, $self->{VERSION}), (0)x4)[0..3];

d2879 1
a2879 1
    my $ppd_xml = sprintf <<'PPD_HTML', $pack_ver, $abstract, $author;
a2880 1
    <TITLE>$(DISTNAME)</TITLE>
d2886 7
a2892 8
    foreach my $prereq (sort keys %{$self->{PREREQ_PM}}) {
        my $pre_req = $prereq;
        $pre_req =~ s/::/-/g;
        my ($dep_ver) = join ",", (split (/\./, $self->{PREREQ_PM}{$prereq}), 
                                  (0) x 4) [0 .. 3];
        $ppd_xml .= sprintf <<'PPD_OUT', $pre_req, $dep_ver;
        <DEPENDENCY NAME="%s" VERSION="%s" />
PPD_OUT
d2894 15
d2916 1
a2916 1
        $archname .= "-". substr($Config{version},0,3);
a2918 1
        <OS NAME="$(OSNAME)" />
d2989 1
a2989 1
    if( $self->{ARGS}{PREFIX} && $self->file_name_is_absolute($path) && 
d3023 1
a3023 1
            if( $Is_VMS ) {
d3312 1
a3312 1
    my(@@m,$dir);
d3316 1
a3316 1
    foreach $dir (@@{$self->{DIR}}){
a3431 34
=item tools_other (o)

    my $make_frag = $MM->tools_other;

Returns a make fragment containing definitions for the macros init_others() 
initializes.

=cut

sub tools_other {
    my($self) = shift;
    my @@m;

    # We set PM_FILTER as late as possible so it can see all the earlier
    # on macro-order sensitive makes such as nmake.
    for my $tool (qw{ SHELL CHMOD CP MV NOOP NOECHO RM_F RM_RF TEST_F TOUCH 
                      UMASK_NULL DEV_NULL MKPATH EQUALIZE_TIMESTAMP 
                      ECHO ECHO_N
                      UNINST VERBINST
                      MOD_INSTALL DOC_INSTALL UNINSTALL
                      WARN_IF_OLD_PACKLIST
		      MACROSTART MACROEND
                      USEMAKEFILE
                      PM_FILTER
                      FIXIN
                    } ) 
    {
        next unless defined $self->{$tool};
        push @@m, "$tool = $self->{$tool}\n";
    }

    return join "", @@m;
}

d3458 8
a3465 9
	my $typemap;
	foreach $typemap (@@{$self->{TYPEMAPS}}){
		if( ! -f  $typemap ){
			warn "Typemap $typemap not found.\n";
		}
		else{
			push(@@tmdeps,  $typemap);
		}
	}
d3470 1
a3470 1
 	unshift( @@tmargs, $self->{XSOPT} );
d3473 1
a3473 1
    if ($Is_VMS                          &&
d3530 1
a3530 1
subdirs ::
@


1.21
log
@Add another change that got dropped in the merge of perl 5.10.0.
This time, add a comment describing why it is there.
@
text
@d1326 1
a1326 4
	     # Cannot check INSTALL${man}DIR on OpenBSD since we
	     # have that set to "none" to prevent installation of
	     # the main perl man pages.  Use INST_${man}DIR instead
             or $self->{"INST_${man}DIR"} =~ /^(none|\s*)$/
@


1.20
log
@re-apply change from rev 1.18
@
text
@d1326 4
a1329 1
             or $self->{"INSTALL${man}DIR"} =~ /^(none|\s*)$/
@


1.19
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3644 1
a3644 1
subdirs :: $(MYEXTLIB)
@


1.18
log
@fix another make -j race, avoid rebuilding some archives twice in parallel.
okay millert@@, went thru several full builds including >500 perl packages...
@
text
@a6 1
use Exporter ();
a15 1
            $Verbose %pm
d21 1
a21 1
$VERSION = '1.50';
d38 3
a40 2
    $Is_BSD     = $^O =~ /^(?:free|net|open)bsd$/ or
                  $^O eq 'bsdos' or $^O eq 'interix';
d133 4
d140 1
a140 1
        push @@m, '
d142 2
a143 2
	'. $cpp_cmd . ' $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c > $*.i
';
d145 2
a146 1
    push @@m, '
d148 14
a161 13
	$(CCCMD) -S $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c
';
    push @@m, '
.c$(OBJ_EXT):
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c
';
    push @@m, '
.C$(OBJ_EXT):
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.C
' if !$Is_OS2 and !$Is_Win32 and !$Is_Dos; #Case-specific
    push @@m, '
.cpp$(OBJ_EXT):
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.cpp
d163 4
a166 2
.cxx$(OBJ_EXT):
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.cxx
d168 1
a168 4
.cc$(OBJ_EXT):
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.cc
';
    join "", @@m;
d381 1
a381 1
              INSTALLDIRS INSTALLBASE DESTDIR PREFIX
d641 1
a641 1
	$(RM_F) *~ *.orig */*~ */*.orig
d935 1
a935 1
    if (($Is_NetBSD || $Is_Interix) && $Config{'useshrplib'}) {
d1037 4
a1040 1
            # To avoid using the unportable 2>&1 to supress STDERR,
d1054 1
a1054 1
            if ($val =~ /^VER_OK/) {
d1058 1
a1058 1
                print "Result: '$val'\n";
d1075 2
a1076 2
sub fixin { # stolen from the pink Camel book, more or less
    my($self, @@files) = @@_;
d1078 1
a1078 1
    my($does_shbang) = $Config{'sharpbang'} =~ /^\s*\#\!/;
d1083 9
a1091 9
	local(*FIXIN);
	local(*FIXOUT);
	open(FIXIN, $file) or croak "Can't process '$file': $!";
	local $/ = "\n";
	chomp(my $line = <FIXIN>);
	next unless $line =~ s/^\s*\#!\s*//;     # Not a shbang file.
	# Now figure out the interpreter name.
	my($cmd,$arg) = split ' ', $line, 2;
	$cmd =~ s!^.*/!!;
d1093 1
a1093 1
	# Now look (in reverse) for interpreter in absolute PATH (unless perl).
d1095 2
a1096 2
	if ($cmd eq "perl") {
            if ($Config{startperl} =~ m,^\#!.*/perl,) {
d1099 2
a1100 1
            } else {
d1103 16
a1118 12
	} else {
	    my(@@absdirs) = reverse grep {$self->file_name_is_absolute} $self->path;
	    $interpreter = '';
	    my($dir);
	    foreach $dir (@@absdirs) {
		if ($self->maybe_command($cmd)) {
		    warn "Ignoring $interpreter in $file\n" if $Verbose && $interpreter;
		    $interpreter = $self->catfile($dir,$cmd);
		}
	    }
	}
	# Figure out how to invoke interpreter on this machine.
d1120 12
a1131 10
	my($shb) = "";
	if ($interpreter) {
	    print STDOUT "Changing sharpbang in $file to $interpreter" if $Verbose;
	    # this is probably value-free on DOSISH platforms
	    if ($does_shbang) {
		$shb .= "$Config{'sharpbang'}$interpreter";
		$shb .= ' ' . $arg if defined $arg;
		$shb .= "\n";
	    }
	    $shb .= qq{
d1134 12
a1145 6
} unless $Is_Win32; # this won't work on win32, so don't
	} else {
	    warn "Can't find $cmd in PATH, $file unchanged"
		if $Verbose;
	    next;
	}
d1147 6
a1152 11
	unless ( open(FIXOUT,">$file_new") ) {
	    warn "Can't create new $file: $!\n";
	    next;
	}
	
	# Print out the new #! line (or equivalent).
	local $\;
	undef $/;
	print FIXOUT $shb, <FIXIN>;
	close FIXIN;
	close FIXOUT;
d1156 17
a1172 16
	unless ( _rename($file, $file_bak) ) {	
	    warn "Can't rename $file to $file_bak: $!";
	    next;
	}
	unless ( _rename($file_new, $file) ) {	
	    warn "Can't rename $file_new to $file: $!";
	    unless ( _rename($file_bak, $file) ) {
	        warn "Can't rename $file_bak back to $file either: $!";
		warn "Leaving $file renamed as $file_bak\n";
	    }
	    next;
	}
	unlink $file_bak;
    } continue {
	close(FIXIN) if fileno(FIXIN);
	system("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';;
d1201 1
a1201 1
FORCE:
d1248 2
a1249 2
Scans the directory structure and initializes DIR, XS, XS_FILES, PM,
C, C_FILES, O_FILES, H, H_FILES, PL_FILES, MAN*PODS, EXE_FILES.
d1257 1
a1257 2
    my($name, %dir, %xs, %c, %h, %pl_files, %manifypods);
    my %pm;
d1301 136
a1477 1
    my ($pmlibdir);
d1479 2
a1480 1
    foreach $pmlibdir (@@pmlibdirs) {
d1484 6
d1509 1
d1511 2
a1512 1
                if ($striplibpath = $path) =~ s:^(\W*)lib\W:$1:i;
d1519 1
a1519 1
	    $pm{$path} = $inst;
d1522 1
a1523 97
    $self->{PM}  ||= \%pm;
    $self->{PL_FILES} ||= \%pl_files;

    $self->{DIR} ||= [sort keys %dir];

    $self->{XS}  ||= \%xs;
    $self->{C}   ||= [sort keys %c];
    my @@o_files = @@{$self->{C}};
    $self->{O_FILES} = [grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i, @@o_files];
                            
    $self->{H}   ||= [sort keys %h];

    # Set up names of manual pages to generate from pods
    my %pods;
    foreach my $man (qw(MAN1 MAN3)) {
	unless ($self->{"${man}PODS"}) {
	    $self->{"${man}PODS"} = {};
	    $pods{$man} = 1 unless 
              $self->{"INST_${man}DIR"} =~ /^(none|\s*)$/;
	}
    }

    if ($pods{MAN1}) {
	if ( exists $self->{EXE_FILES} ) {
	    foreach $name (@@{$self->{EXE_FILES}}) {
		local *FH;
		my($ispod)=0;
		if (open(FH,"<$name")) {
		    while (<FH>) {
			if (/^=(?:head\d+|item|pod)\b/) {
			    $ispod=1;
			    last;
			}
		    }
		    close FH;
		} else {
		    # If it doesn't exist yet, we assume, it has pods in it
		    $ispod = 1;
		}
		next unless $ispod;
		if ($pods{MAN1}) {
		    $self->{MAN1PODS}->{$name} =
		      $self->catfile("\$(INST_MAN1DIR)", basename($name).".\$(MAN1EXT)");
		}
	    }
	}
    }
    if ($pods{MAN3}) {
	my %manifypods = (); # we collect the keys first, i.e. the files
			     # we have to convert to pod
	foreach $name (keys %{$self->{PM}}) {
	    if ($name =~ /\.pod\z/ ) {
		$manifypods{$name} = $self->{PM}{$name};
	    } elsif ($name =~ /\.p[ml]\z/ ) {
		local *FH;
		my($ispod)=0;
		if (open(FH,"<$name")) {
		    while (<FH>) {
			if (/^=head1\s+\w+/) {
			    $ispod=1;
			    last;
			}
		    }
		    close FH;
		} else {
		    $ispod = 1;
		}
		if( $ispod ) {
		    $manifypods{$name} = $self->{PM}{$name};
		}
	    }
	}

	# Remove "Configure.pm" and similar, if it's not the only pod listed
	# To force inclusion, just name it "Configure.pod", or override 
        # MAN3PODS
	foreach $name (keys %manifypods) {
           if ($self->{PERL_CORE} and $name =~ /(config|setup).*\.pm/is) {
		delete $manifypods{$name};
		next;
	    }
	    my($manpagename) = $name;
	    $manpagename =~ s/\.p(od|m|l)\z//;
           # everything below lib is ok
	    unless($manpagename =~ s!^\W*lib\W+!!s) {
		$manpagename = $self->catfile(
                                split(/::/,$self->{PARENT_NAME}),$manpagename
                               );
	    }
	    if ($pods{MAN3}) {
		$manpagename = $self->replace_manpage_separator($manpagename);
		$self->{MAN3PODS}->{$name} =
		  $self->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
	    }
	}
    }
}
d1594 11
a1604 18
	my($dir);
	foreach $dir ($Updir,
                  $self->catdir($Updir,$Updir),
                  $self->catdir($Updir,$Updir,$Updir),
                  $self->catdir($Updir,$Updir,$Updir,$Updir),
                  $self->catdir($Updir,$Updir,$Updir,$Updir,$Updir))
        {
	    if (
		-f $self->catfile($dir,"config_h.SH")
		&&
		-f $self->catfile($dir,"perl.h")
		&&
		-f $self->catfile($dir,"lib","Exporter.pm")
	       ) {
		$self->{PERL_SRC}=$dir ;
		last;
	    }
	}
d1662 1
a1662 1
	    my $found;
d1664 1
a1664 1
	      $found = $dir, last if -e $self->catdir($dir, "Config.pm");
d1666 5
a1670 2
	    if ($found) {
	      my $inc = dirname $found;
d1672 2
a1673 2
		$self->{PERL_LIB}	   = $found;
		$self->{PERL_ARCHLIB}	   = $found;
d2136 1
a2136 1
		$(INST_SCRIPT) $(DESTINSTALLSCRIPT) \
d2149 1
a2149 1
		$(INST_SCRIPT) $(DESTINSTALLSCRIPT) \
d2542 1
a2542 1
doc_inst_perl:
d2555 1
a2555 1
inst_perl: pure_inst_perl doc_inst_perl
d2557 1
a2557 1
pure_inst_perl: $(MAP_TARGET)
a2648 16
=item nicetext

misnamed method (will have to be changed). The MM_Unix method just
returns the argument without further processing.

On VMS used to insure that colons marking targets are preceded by
space - most Unix Makes don't need this, but it's necessary under VMS
to distinguish the target delimiter from a colon appearing as part of
a filespec.

=cut

sub nicetext {
    my($self,$text) = @@_;
    $text;
}
d2679 3
a2681 1
parse a file and return what you think is $VERSION in this file set to.
d2683 6
a2688 2
is. $VERSION should be for all to see, so our $VERSION or plain $VERSION
are okay, but my $VERSION is not.
d2701 22
a2722 13
	$inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
	next if $inpod || /^\s*#/;
	chop;
	next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
	my $eval = qq{
	    package ExtUtils::MakeMaker::_version;
	    no strict;

	    local $1$2;
	    \$$2=undef; do {
		$_
	    }; \$$2
	};
d2724 3
a2726 3
	$result = eval($eval);
	warn "Could not eval '$eval' in $parsefile: $@@" if $@@;
	last;
d2751 1
a2751 1
                     PREFIX INSTALLBASE)
a2847 1
	$(PERL_INC)/thrdvar.h		\
a2958 6
    if ($self->{ABSTRACT_FROM}){
        $self->{ABSTRACT} = $self->parse_abstract($self->{ABSTRACT_FROM}) or
            carp "WARNING: Setting ABSTRACT via file ".
                 "'$self->{ABSTRACT_FROM}' failed\n";
    }

d2989 8
a2996 1
    $ppd_xml .= sprintf <<'PPD_OUT', $Config{archname};
d3025 1
a3025 1
ppd:
d3103 2
a3104 2
                $plfile = vmsify($plfile);
                $target = vmsify($target);
d3203 1
a3203 1
    return qq{\$(ABSPERLRUN) $switches -e $cmd};   
d3436 5
a3440 1
test :: \$(TEST_TYPE)
d3444 5
a3448 5
        my $test = $self->oneliner(sprintf <<'CODE', $dir);
chdir '%s';  
system '$(MAKE) test $(PASTHRU)' 
    if -f '$(FIRST_MAKEFILE)';
CODE
d3450 1
a3450 1
        push(@@m, "\t\$(NOECHO) $test\n");
d3644 1
a3644 1
subdirs ::
@


1.17
log
@pass COPTS thru, okay millert@@
@
text
@d3582 1
a3582 1
subdirs :: $(MYEXTLIB)
@


1.16
log
@merge in perl 5.8.8
@
text
@d291 1
a291 1
	$(CCFLAGS) $(OPTIMIZE) \\
@


1.15
log
@merge local changes into perl-5.8.3
@
text
@d9 2
a10 2
use Config         qw(%Config);
use File::Basename qw(basename dirname fileparse);
d14 4
a17 4
            $Is_Mac $Is_OS2 $Is_VMS $Is_Win32 $Is_Win95  $Is_Dos $Is_VOS
            $Is_QNX $Is_AIX $Is_OSF $Is_IRIX  $Is_NetBSD $Is_BSD
            $Is_SunOS4 $Is_Solaris $Is_SunOS
            $Verbose %pm %static
d23 1
a23 1
$VERSION = '1.42';
d28 23
a50 16
$Is_OS2     = $^O eq 'os2';
$Is_Mac     = $^O eq 'MacOS';
$Is_Win32   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
$Is_Win95   = $Is_Win32 && Win32::IsWin95();
$Is_Dos     = $^O eq 'dos';
$Is_VOS     = $^O eq 'vos';
$Is_VMS     = $^O eq 'VMS';
$Is_QNX     = $^O eq 'qnx';
$Is_AIX     = $^O eq 'aix';
$Is_OSF     = $^O eq 'dec_osf';
$Is_IRIX    = $^O eq 'irix';
$Is_NetBSD  = $^O eq 'netbsd';
$Is_SunOS4  = $^O eq 'sunos';
$Is_Solaris = $^O eq 'solaris';
$Is_SunOS   = $Is_SunOS4 || $Is_Solaris;
$Is_BSD     = $^O =~ /^(?:free|net|open)bsd|bsdos$/;
d92 4
a95 2
overridable by a platform specific MM_*.pm file (See
L<ExtUtils::MM_VMS>) and L<ExtUtils::MM_OS2>).
d110 1
a110 1
=item os_flavor (o)
a276 86
=item clean (o)

Defines the clean target.

=cut

sub clean {
# --- Cleanup and Distribution Sections ---

    my($self, %attribs) = @@_;
    my(@@m,$dir);
    push(@@m, '
# Delete temporary files but do not touch installed files. We don\'t delete
# the Makefile here so a later make realclean still has a makefile to use.

clean :: clean_subdirs
');

    my(@@otherfiles) = values %{$self->{XS}}; # .c files from *.xs files
    if ( $Is_QNX ) {
      my @@errfiles = @@{$self->{C}};
      for ( @@errfiles ) {
	s/.c$/.err/;
      }
      push( @@otherfiles, @@errfiles, 'perlmain.err' );
    }
    push(@@otherfiles, $attribs{FILES}) if $attribs{FILES};
    push(@@otherfiles, qw[./blib $(MAKE_APERL_FILE) 
                         $(INST_ARCHAUTODIR)/extralibs.all
                         $(INST_ARCHAUTODIR)/extralibs.ld
			 perlmain.c tmon.out mon.out so_locations pm_to_blib
			 *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT)
			 $(BOOTSTRAP) $(BASEEXT).bso
			 $(BASEEXT).def lib$(BASEEXT).def
			 $(BASEEXT).exp $(BASEEXT).x
			]);
    if( $Is_VOS ) {
        push(@@otherfiles, qw[*.kp]);
    }
    else {
        push(@@otherfiles, qw[core core.*perl.*.? *perl.core]);

        # core.\d+
        push(@@otherfiles, map { "core." . "[0-9]"x$_ } (1..5));
    }

    push @@m, "\t-\$(RM_RF) @@otherfiles\n";
    # See realclean and ext/utils/make_ext for usage of Makefile.old
    push(@@m,
	 "\t-\$(MV) \$(FIRST_MAKEFILE) \$(MAKEFILE_OLD) \$(DEV_NULL)\n");
    push(@@m,
	 "\t$attribs{POSTOP}\n")   if $attribs{POSTOP};
    join("", @@m);
}


=item clean_subdirs_target

  my $make_frag = $MM->clean_subdirs_target;

Returns the clean_subdirs target.  This is used by the clean target to
call clean on any subdirectories which contain Makefiles.

=cut

sub clean_subdirs_target {
    my($self) = shift;

    # No subdirectories, no cleaning.
    return <<'NOOP_FRAG' unless @@{$self->{DIR}};
clean_subdirs :
	$(NOECHO) $(NOOP)
NOOP_FRAG


    my $clean = "clean_subdirs :\n";

    for my $dir (@@{$self->{DIR}}) {
        $clean .= sprintf <<'MAKE_FRAG', $dir;
	-cd %s && $(TEST_F) $(FIRST_MAKEFILE) && $(MAKE) clean
MAKE_FRAG
    }

    return $clean;
}

d339 1
a339 1
	 EXTRALIBS LDLOADLIBS BSLOADLIBS LD_RUN_PATH
d344 7
d366 2
d370 1
a370 1
              AR_STATIC_ARGS DIRFILESEP
d377 1
a377 2
              INSTALLDIRS
              DESTDIR PREFIX
d419 1
d421 1
a421 1
	      LDFROM LINKTYPE PM_FILTER
d441 1
a441 1
CONFIGDEP = $(PERL_ARCHLIB)$(DIRFILESEP)Config.pm $(PERL_INC)$(DIRFILESEP)config.h
a492 43
=item dir_target (o)

Takes an array of directories that need to exist and returns a
Makefile entry for a .exists file in these directories. Returns
nothing, if the entry has already been processed. We're helpless
though, if the same directory comes as $(FOO) _and_ as "bar". Both of
them get an entry, that's why we use "::".

=cut

sub dir_target {
# --- Make-Directories section (internal method) ---
# dir_target(@@array) returns a Makefile entry for the file .exists in each
# named directory. Returns nothing, if the entry has already been processed.
# We're helpless though, if the same directory comes as $(FOO) _and_ as "bar".
# Both of them get an entry, that's why we use "::". I chose '$(PERL)' as the
# prerequisite, because there has to be one, something that doesn't change
# too often :)

    my($self,@@dirs) = @@_;
    my(@@m,$dir,$targdir);
    foreach $dir (@@dirs) {
	my($src) = $self->catfile($self->{PERL_INC},'perl.h');
	my($targ) = $self->catfile($dir,'.exists');
	# catfile may have adapted syntax of $dir to target OS, so...
	if ($Is_VMS) { # Just remove file name; dirspec is often in macro
	    ($targdir = $targ) =~ s:/?\.exists\z::;
	}
	else { # while elsewhere we expect to see the dir separator in $targ
	    $targdir = dirname($targ);
	}
	next if $self->{DIR_TARGET}{$self}{$targdir}++;
	push @@m, qq{
$targ :: $src
	\$(NOECHO) \$(MKPATH) $targdir
	\$(NOECHO) \$(EQUALIZE_TIMESTAMP) $src $targ
};
	push(@@m, qq{
	-\$(NOECHO) \$(CHMOD) \$(PERM_RWX) $targdir
}) unless $Is_VMS;
    }
    join "", @@m;
}
a830 1
=item distdir
d832 1
a832 18
Defines the scratch directory target that will hold the distribution
before tar-ing (or shar-ing).

=cut

# For backwards compatibility.
*dist_dir = *distdir;

sub distdir {
    my($self) = shift;

    return <<'MAKE_FRAG';
distdir : metafile metafile_addtomanifest
	$(RM_RF) $(DISTVNAME)
	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"

MAKE_FRAG
d834 1
a834 3
}

=item dist_test
d836 1
a836 22
Defines a target that produces the distribution in the
scratchdirectory, and runs 'perl Makefile.PL; make ;make test' in that
subdirectory.

=cut

sub dist_test {
    my($self) = shift;
    my @@m;
    push @@m, q{
disttest : distdir
	cd $(DISTVNAME) && $(ABSPERLRUN) Makefile.PL
	cd $(DISTVNAME) && $(MAKE) $(PASTHRU)
	cd $(DISTVNAME) && $(MAKE) test $(PASTHRU)
};
    join "", @@m;
}

=item dlsyms (o)

Used by AIX and VMS to define DL_FUNCS and DL_VARS and write the *.exp
files.
d841 1
a841 28
    my($self,%attribs) = @@_;

    return '' unless ($Is_AIX && $self->needs_linking() );

    my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
    my($vars)  = $attribs{DL_VARS} || $self->{DL_VARS} || [];
    my($funclist)  = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
    my(@@m);

    push(@@m,"
dynamic :: $self->{BASEEXT}.exp

") unless $self->{SKIPHASH}{'dynamic'}; # dynamic and static are subs, so...

    push(@@m,"
static :: $self->{BASEEXT}.exp

") unless $self->{SKIPHASH}{'static'};  # we avoid a warning if we tick them

    push(@@m,"
$self->{BASEEXT}.exp: Makefile.PL
",'	$(PERLRUN) -e \'use ExtUtils::Mksymlists; \\
	Mksymlists("NAME" => "',$self->{NAME},'", "DL_FUNCS" => ',
	neatvalue($funcs), ', "FUNCLIST" => ', neatvalue($funclist),
	', "DL_VARS" => ', neatvalue($vars), ');\'
');

    join('',@@m);
a843 15
=item dynamic (o)

Defines the dynamic target.

=cut

sub dynamic {
# --- Dynamic Loading Sections ---

    my($self) = shift;
    '
dynamic :: $(FIRST_MAKEFILE) $(INST_DYNAMIC) $(INST_BOOT)
	$(NOECHO) $(NOOP)
';
}
d857 3
a859 1
    return <<'MAKE_FRAG';
d865 1
a865 1
$(BOOTSTRAP): $(FIRST_MAKEFILE) $(BOOTDEP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
d870 2
a871 2
	$(NOECHO) $(TOUCH) $(BOOTSTRAP)
	$(CHMOD) $(PERM_RW) $@@
d873 4
a876 4
$(INST_BOOT): $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
	$(NOECHO) $(RM_RF) $(INST_BOOT)
	-$(CP) $(BOOTSTRAP) $(INST_BOOT)
	$(CHMOD) $(PERM_RW) $@@
d908 1
a908 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
d931 1
a931 1
    if ($Is_NetBSD) {
d936 10
a945 7
	if ($Config{'useshrplib'}) {
	    if ($Config{'lddlflags'} =~ /-Wl,-R/) {
		$libs .= ' -L$(PERL_INC) -Wl,-R$(INSTALLARCHLIB)/CORE -lperl';
	    } elsif ($Config{'lddlflags'} =~ /-R/) {
		$libs .= ' -L$(PERL_INC) -R$(INSTALLARCHLIB)/CORE -lperl';
	    }
	}
d948 7
a954 4
    push(@@m,
'	LD_RUN_PATH="$(LD_RUN_PATH)" $(LD) '.$ldrun.' $(LDDLFLAGS) '.$ldfrom.
' $(OTHERLDFLAGS) -o $@@ $(MYEXTLIB) $(PERL_ARCHIVE) '.$libs.' $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST) $(INST_DYNAMIC_FIX)');
    push @@m, '
d956 1
a956 1
';
d958 1
a958 2
    push @@m, $self->dir_target('$(INST_ARCHAUTODIR)');
    join('',@@m);
d1032 1
a1032 1
            my $version_check = qq{$abs -e "require $ver; print qq{VER_OK\n}"};
a1058 22
=item find_tests

  my $test = $mm->find_tests;

Returns a string suitable for feeding to the shell to return all
tests in t/*.t.

=cut

sub find_tests {
    my($self) = shift;
    return 't/*.t';
}

=back

=head2 Methods to actually produce chunks of text for the Makefile

The methods here are called for each MakeMaker object in the order
specified by @@ExtUtils::MakeMaker::MM_Sections.

=over 2
d1141 1
a1141 1
	unless ( rename($file, $file_bak) ) {	
d1145 1
a1145 1
	unless ( rename($file_new, $file) ) {	
d1147 1
a1147 1
	    unless ( rename($file_bak, $file) ) {
d1160 16
d1178 1
a1178 1
Just writes FORCE:
d1241 1
a1241 1
    my($name, %dir, %xs, %c, %h, %ignore, %pl_files, %manifypods);
d1244 1
a1244 1
    @@ignore{qw(Makefile.PL test.pl t)} = (1,1,1);
a1577 2
		$Is_Mac
		or
d1622 1
a1622 19
	}
	
	unless(-f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h")))
        {
	    die qq{
Error: Unable to locate installed Perl libraries or Perl source code.

It is recommended that you install perl in a standard location before
building extensions. Some precompiled versions of perl do not contain
these header files, so you cannot build extensions. In such a case,
please build and install your perl from a fresh perl distribution. It
usually solves this kind of problem.

\(You get this message, because MakeMaker could not find "$perl_h"\)
};
	}
#	 print STDOUT "Using header files found in $self->{PERL_INC}\n"
#	     if $Verbose && $self->needs_linking();

d1734 12
a1745 4
    $self->{MAKEFILE}           ||= 'Makefile';
    $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE};
    $self->{MAKEFILE_OLD}       ||= '$(FIRST_MAKEFILE).old';
    $self->{MAKE_APERL_FILE}    ||= '$(FIRST_MAKEFILE).aperl';
d1758 1
a1758 1
    $self->{MKPATH}     ||= '$(PERLRUN) "-MExtUtils::Command" -e mkpath';
d1760 1
a1760 1
      '$(PERLRUN) "-MExtUtils::Command" -e eqtime';
d1768 4
a1771 4
    $self->{DOC_INSTALL} ||= 
      '$(PERLRUN) "-MExtUtils::Command::MM" -e perllocal_install';
    $self->{UNINSTALL}   ||= 
      '$(PERLRUN) "-MExtUtils::Command::MM" -e uninstall';
d1773 3
a1775 1
      '$(PERLRUN) "-MExtUtils::Command::MM" -e warn_if_old_packlist';
a1782 249
=item init_INST

    $mm->init_INST;

Called by init_main.  Sets up all INST_* variables except those related
to XS code.  Those are handled in init_xs.

=cut

sub init_INST {
    my($self) = shift;

    $self->{INST_ARCHLIB} ||= $self->catdir($Curdir,"blib","arch");
    $self->{INST_BIN}     ||= $self->catdir($Curdir,'blib','bin');

    # INST_LIB typically pre-set if building an extension after
    # perl has been built and installed. Setting INST_LIB allows
    # you to build directly into, say $Config{privlibexp}.
    unless ($self->{INST_LIB}){
	if ($self->{PERL_CORE}) {
            if (defined $Cross::platform) {
                $self->{INST_LIB} = $self->{INST_ARCHLIB} = 
                  $self->catdir($self->{PERL_LIB},"..","xlib",
                                     $Cross::platform);
            }
            else {
                $self->{INST_LIB} = $self->{INST_ARCHLIB} = $self->{PERL_LIB};
            }
	} else {
	    $self->{INST_LIB} = $self->catdir($Curdir,"blib","lib");
	}
    }

    my @@parentdir = split(/::/, $self->{PARENT_NAME});
    $self->{INST_LIBDIR}      = $self->catdir('$(INST_LIB)',     @@parentdir);
    $self->{INST_ARCHLIBDIR}  = $self->catdir('$(INST_ARCHLIB)', @@parentdir);
    $self->{INST_AUTODIR}     = $self->catdir('$(INST_LIB)', 'auto', 
                                              '$(FULLEXT)');
    $self->{INST_ARCHAUTODIR} = $self->catdir('$(INST_ARCHLIB)', 'auto',
                                              '$(FULLEXT)');

    $self->{INST_SCRIPT}  ||= $self->catdir($Curdir,'blib','script');

    $self->{INST_MAN1DIR} ||= $self->catdir($Curdir,'blib','man1');
    $self->{INST_MAN3DIR} ||= $self->catdir($Curdir,'blib','man3');

    return 1;
}

=item init_INSTALL

    $mm->init_INSTALL;

Called by init_main.  Sets up all INSTALL_* variables (except
INSTALLDIRS) and *PREFIX.

=cut

sub init_INSTALL {
    my($self) = shift;

    $self->init_lib2arch;

    # Initialize installvendorman*dir if necessary
    foreach my $num (1, 3) {
        my $k = 'installvendorman'.$num.'dir';

        unless ($Config{$k}) {
            $Config_Override{$k} = $Config{usevendorprefix} ?
                  $self->catdir($Config{vendorprefixexp}, 'man', "man$num") :
                  '';
        }
    }

    my $iprefix = $Config{installprefixexp} || $Config{installprefix} || 
                  $Config{prefixexp}        || $Config{prefix} || '';
    my $vprefix = $Config{usevendorprefix}  ? $Config{vendorprefixexp} : '';
    my $sprefix = $Config{siteprefixexp}    || '';

    # 5.005_03 doesn't have a siteprefix.
    $sprefix = $iprefix unless $sprefix;

    # There are often no Config.pm defaults for these, but we can make
    # it up.
    unless( $Config{installsiteman1dir} ) {
        $Config_Override{installsiteman1dir} = 
          $self->catdir($sprefix, 'man', 'man1');
    }

    unless( $Config{installsiteman3dir} ) {
        $Config_Override{installsiteman3dir} = 
          $self->catdir($sprefix, 'man', 'man3');
    }

    unless( $Config{installsitebin} ) {
        $Config_Override{installsitebin} =
          $self->catdir($sprefix, 'bin');
    }

    $self->{PREFIX}       ||= '';

    if( $self->{PREFIX} ) {
        @@{$self}{qw(PERLPREFIX SITEPREFIX VENDORPREFIX)} =
          ('$(PREFIX)') x 3;
    }
    else {
        $self->{PERLPREFIX}   ||= $iprefix;
        $self->{SITEPREFIX}   ||= $sprefix;
        $self->{VENDORPREFIX} ||= $vprefix;
    }

    my $arch    = $Config{archname};
    my $version = $Config{version};

    # default style
    my $libstyle = $Config{installstyle} || 'lib/perl5';
    my $manstyle = '';

    if( $self->{LIBSTYLE} ) {
        $libstyle = $self->{LIBSTYLE};
        $manstyle = $self->{LIBSTYLE} eq 'lib/perl5' ? 'lib/perl5' : '';
    }

    # Some systems, like VOS, set installman*dir to '' if they can't
    # read man pages.
    for my $num (1, 3) {
        $self->{'INSTALLMAN'.$num.'DIR'} ||= 'none'
          unless $Config{'installman'.$num.'dir'};
    }

    my %bin_layouts = 
    (
        bin         => { s => $iprefix,
                         t => 'perl',
                         d => 'bin' },
        vendorbin   => { s => $vprefix,
                         t => 'vendor',
                         d => 'bin' },
        sitebin     => { s => $sprefix,
                         t => 'site',
                         d => 'bin' },
        script      => { s => $iprefix,
                         t => 'perl',
                         d => 'bin' },
    );
    
    my %man_layouts =
    (
        man1dir         => { s => $iprefix,
                             t => 'perl',
                             d => 'man/man1',
                             style => $manstyle, },
        siteman1dir     => { s => $sprefix,
                             t => 'site',
                             d => 'man/man1',
                             style => $manstyle, },
        vendorman1dir   => { s => $vprefix,
                             t => 'vendor',
                             d => 'man/man1',
                             style => $manstyle, },

        man3dir         => { s => $iprefix,
                             t => 'perl',
                             d => 'man/man3',
                             style => $manstyle, },
        siteman3dir     => { s => $sprefix,
                             t => 'site',
                             d => 'man/man3',
                             style => $manstyle, },
        vendorman3dir   => { s => $vprefix,
                             t => 'vendor',
                             d => 'man/man3',
                             style => $manstyle, },
    );

    my %lib_layouts =
    (
        privlib     => { s => $iprefix,
                         t => 'perl',
                         d => '',
                         style => $libstyle, },
        vendorlib   => { s => $vprefix,
                         t => 'vendor',
                         d => '',
                         style => $libstyle, },
        sitelib     => { s => $sprefix,
                         t => 'site',
                         d => 'site_perl',
                         style => $libstyle, },
        
        archlib     => { s => $iprefix,
                         t => 'perl',
                         d => "$version/$arch",
                         style => $libstyle },
        vendorarch  => { s => $vprefix,
                         t => 'vendor',
                         d => "$version/$arch",
                         style => $libstyle },
        sitearch    => { s => $sprefix,
                         t => 'site',
                         d => "site_perl/$version/$arch",
                         style => $libstyle },
    );


    # Special case for LIB.
    if( $self->{LIB} ) {
        foreach my $var (keys %lib_layouts) {
            my $Installvar = uc "install$var";

            if( $var =~ /arch/ ) {
                $self->{$Installvar} ||= 
                  $self->catdir($self->{LIB}, $Config{archname});
            }
            else {
                $self->{$Installvar} ||= $self->{LIB};
            }
        }
    }

    my %type2prefix = ( perl    => 'PERLPREFIX',
                        site    => 'SITEPREFIX',
                        vendor  => 'VENDORPREFIX'
                      );

    my %layouts = (%bin_layouts, %man_layouts, %lib_layouts);
    while( my($var, $layout) = each(%layouts) ) {
        my($s, $t, $d, $style) = @@{$layout}{qw(s t d style)};
        my $r = '$('.$type2prefix{$t}.')';

        print STDERR "Prefixing $var\n" if $Verbose >= 2;

        my $installvar = "install$var";
        my $Installvar = uc $installvar;
        next if $self->{$Installvar};

        $d = "$style/$d" if $style;
        $self->prefixify($installvar, $s, $r, $d);

        print STDERR "  $Installvar == $self->{$Installvar}\n" 
          if $Verbose >= 2;
    }

    # Generate these if they weren't figured out.
    $self->{VENDORARCHEXP} ||= $self->{INSTALLVENDORARCH};
    $self->{VENDORLIBEXP}  ||= $self->{INSTALLVENDORLIB};

    return 1;
}
d1924 2
a1925 1
    $self->{PERL_CORE} = 0 unless exists $self->{PERL_CORE};
d1945 3
a1947 1
=item init_platform (o)
a1950 2
=item platform_constants (o)

d2033 1
d2036 1
d2039 1
d2042 1
d2045 1
d2048 1
d2131 1
d2154 1
d2156 7
a2162 4
    return "" unless @@{$self->{EXE_FILES}};
    my(@@m, $from, $to, %fromto, @@to);
    push @@m, $self->dir_target(qw[$(INST_SCRIPT)]);
    for $from (@@{$self->{EXE_FILES}}) {
d2164 1
d2166 1
a2166 1
	$to = $self->libscan($path);
a2167 3
	$fromto{$from}=$to;
    }
    @@to   = values %fromto;
d2169 2
a2170 7
    my $fixin;
    if( $Is_Win32 ) {
        $fixin = $self->{PERL_CORE} ? '$(PERLRUN) ../../win32/bin/pl2bat.pl'
                                    : 'pl2bat.bat';
    }
    else {
        $fixin = q{$(PERLRUN) "-MExtUtils::MY" -e "MY->fixin(shift)"};
d2172 1
d2174 1
d2176 1
a2176 3
EXE_FILES = @@{$self->{EXE_FILES}}

FIXIN = $fixin
a2181 1
	\$(RM_F) @@to
d2184 7
a2190 1
    while (($from,$to) = each %fromto) {
d2192 10
a2201 8
	my $todir = dirname($to);
	push @@m, "
$to: $from \$(FIRST_MAKEFILE) " . $self->catdir($todir,'.exists') . "
	\$(NOECHO) \$(RM_F) $to
	\$(CP) $from $to
	\$(FIXIN) $to
	-\$(NOECHO) \$(CHMOD) \$(PERM_RWX) $to
";
d2203 1
d2289 1
a2289 1
	$(MAKE) -f $(MAKE_APERL_FILE) $@@
d2291 1
a2291 1
$(MAKE_APERL_FILE) : $(FIRST_MAKEFILE)
d2329 1
a2329 1
    local(%static);
d2333 6
a2338 2
	return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;
	# Skip purified versions of libraries (e.g., DynaLoader_pure_p1_c0_032.a)
d2448 2
a2449 2
    push @@m, "
\$(INST_ARCHAUTODIR)/extralibs.all: \$(INST_ARCHAUTODIR)\$(DIRFILESEP).exists ".join(" \\\n\t", @@$extra).'
d2463 1
a2463 1
	\$(NOECHO) \$(ECHO) '    make -f $makefilename inst_perl MAP_TARGET=\$(MAP_TARGET)'
d2465 1
a2465 1
	\$(NOECHO) \$(ECHO) '    make -f $makefilename map_clean'
d2469 1
a2469 1
    push @@m, qq{\tcd $tmp && $cccmd "-I\$(PERL_INC)" perlmain.c\n};
d2518 1
a2518 1
    my @@m;
d2522 1
a2522 1
    push @@m, '
d2524 1
d2527 4
a2530 1
    push @@m, q{
d2534 1
a2534 1
	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to $?"
d2536 4
a2539 4
	$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
	$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
	-$(MAKE) -f $(MAKEFILE_OLD) clean $(DEV_NULL) || $(NOOP)
	$(PERLRUN) Makefile.PL }.join(" ",map(qq["$_"],@@ARGV)).q{
d2541 1
a2541 1
	$(NOECHO) $(ECHO) "==> Please rerun the make command.  <=="
d2544 1
a2544 1
};
d2546 1
a2546 1
    join "", @@m;
d2648 1
d2692 5
a2696 1
    foreach $key (qw(LIB LIBPERL_A LINKTYPE PREFIX OPTIMIZE)) {
d2701 1
d2733 4
a2736 1
    push @@m, q{
d2745 2
a2746 2
	cd $(PERL_SRC) && $(MAKE) lib/Config.pm
} if $self->{PERL_SRC};
d2844 1
a2844 1
pm_to_blib: $(TO_INST_PM)
d2854 1
a2854 1
    $r .= q{	$(NOECHO) $(TOUCH) $@@};
d3010 3
a3012 1
    if( $path !~ s{^\Q$sprefix\E\b}{$rprefix}s && $self->{ARGS}{PREFIX} ) {
d3032 35
a3066 10
    my($self) = shift;
    return "" unless $self->{PL_FILES};
    my(@@m, $plfile);
    foreach $plfile (sort keys %{$self->{PL_FILES}}) {
        my $list = ref($self->{PL_FILES}->{$plfile})
		? $self->{PL_FILES}->{$plfile}
		: [$self->{PL_FILES}->{$plfile}];
	my $target;
	foreach $target (@@$list) {
	push @@m, "
d3070 4
a3073 3
$target :: $plfile
	\$(PERLRUNINST) $plfile $target
";
d3076 2
a3077 1
    join "", @@m;
d3090 3
a3092 3
    $arg =~ s/\$\((.+?)\)/\$\\\\($1\\\\)/g;	# protect $(...)
    $arg =~ s/(?<!\\)([()])/\\$1/g;		# quote unprotected
    $arg =~ s/\$\\\\\((.+?)\\\\\)/\$($1)/g;	# unprotect $(...)
a3095 80
=item realclean (o)

Defines the realclean target.

=cut

sub realclean {
    my($self, %attribs) = @@_;
    my(@@m);

    push(@@m,'
# Delete temporary files (via clean) and also delete installed files
realclean purge ::  clean realclean_subdirs
	$(RM_RF) $(INST_AUTODIR) $(INST_ARCHAUTODIR)
	$(RM_RF) $(DISTVNAME)
');

    if( $self->has_link_code ){
        push(@@m, "	\$(RM_F) \$(INST_DYNAMIC) \$(INST_BOOT)\n");
        push(@@m, "	\$(RM_F) \$(INST_STATIC)\n");
    }

    my @@files = values %{$self->{PM}};
    push @@files, $attribs{FILES} if $attribs{FILES};
    push @@files, '$(FIRST_MAKEFILE)', '$(MAKEFILE_OLD)';

    # Occasionally files are repeated several times from different sources
    { my(%f) = map { ($_,1) } @@files; @@files = keys %f; }

    # Issue a several little RM_F commands rather than risk creating a
    # very long command line (useful for extensions such as Encode
    # that have many files).
    my $line = "";
    foreach my $file (@@files) {
        if (length($line) + length($file) > 200) {
            push @@m, "\t\$(RM_F) $line\n";
            $line = $file;
        }
        else {
            $line .= " $file"; 
        }
    }
    push @@m, "\t\$(RM_F) $line\n" if $line;
    push(@@m, "\t$attribs{POSTOP}\n")      if $attribs{POSTOP};

    join("", @@m);
}


=item realclean_subdirs_target

  my $make_frag = $MM->realclean_subdirs_target;

Returns the realclean_subdirs target.  This is used by the realclean
target to call realclean on any subdirectories which contain Makefiles.

=cut

sub realclean_subdirs_target {
    my $self = shift;

    return <<'NOOP_FRAG' unless @@{$self->{DIR}};
realclean_subdirs :
	$(NOECHO) $(NOOP)
NOOP_FRAG

    my $rclean = "realclean_subdirs :\n";

    foreach my $dir (@@{$self->{DIR}}){
        $rclean .= sprintf <<'RCLEAN', $dir, $dir;
	-cd %s && $(TEST_F) $(MAKEFILE_OLD) && $(MAKE) -f $(MAKEFILE_OLD) realclean
	-cd %s && $(TEST_F) $(FIRST_MAKEFILE) && $(MAKE) realclean
RCLEAN

    }

    return $rclean;
}


d3114 14
a3127 1
=item oneliner (o)
d3140 1
a3140 1
    $cmd = join " \n\t-e ", map $self->quote_literal($_), @@cmds;
d3145 1
a3145 1
    return qq{\$(PERLRUN) $switches -e $cmd};   
d3230 1
a3230 1
$(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
a3258 1
    push @@m, "\n", $self->dir_target('$(INST_ARCHAUTODIR)');
d3312 5
a3316 1
    return sprintf <<'EOT', $subdir;
d3319 1
a3319 1
	$(NOECHO)cd %s && $(MAKE) -f $(FIRST_MAKEFILE) all $(PASTHRU)
d3321 1
d3381 8
a3388 5
    if ($Is_Win95) {
        push(@@m, map(qq{\t\$(NOECHO) \$(PERLRUN) -e "exit unless -f shift; chdir '$_'; system q{\$(MAKE) test \$(PASTHRU)}" \$(FIRST_MAKEFILE)\n}, @@{$self->{DIR}}));
    }
    else {
        push(@@m, map("\t\$(NOECHO) cd $_ && \$(TEST_F) \$(FIRST_MAKEFILE) && \$(MAKE) test \$(PASTHRU)\n", @@{$self->{DIR}}));
d3453 2
a3454 8
Returns a make fragment containing definitions for:

SHELL, CHMOD, CP, MV, NOOP, NOECHO, RM_F, RM_RF, TEST_F, TOUCH,
DEV_NULL, UMASK_NULL, MKPATH, EQUALIZE_TIMESTAMP,
WARN_IF_OLD_PACKLIST, UNINST, VERBINST, MOD_INSTALL, DOC_INSTALL and
UNINSTALL

init_others() initializes all these values.
d3462 2
d3470 4
d3494 6
a3499 1
    foreach my $dir (@@INC) {
d3525 9
d3539 2
a3540 1
XSUBPP = \$(XSUBPPDIR)/xsubpp
d3577 1
a3577 1
    
d3585 1
a3585 7
config :: $(FIRST_MAKEFILE) $(INST_LIBDIR)$(DIRFILESEP).exists
	$(NOECHO) $(NOOP)

config :: $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
	$(NOECHO) $(NOOP)

config :: $(INST_AUTODIR)$(DIRFILESEP).exists
a3588 19
    push @@m, $self->dir_target(qw[$(INST_AUTODIR) $(INST_LIBDIR) $(INST_ARCHAUTODIR)]);

    if (%{$self->{MAN1PODS}}) {
	push @@m, q[
config :: $(INST_MAN1DIR)$(DIRFILESEP).exists
	$(NOECHO) $(NOOP)

];
	push @@m, $self->dir_target(qw[$(INST_MAN1DIR)]);
    }
    if (%{$self->{MAN3PODS}}) {
	push @@m, q[
config :: $(INST_MAN3DIR)$(DIRFILESEP).exists
	$(NOECHO) $(NOOP)

];
	push @@m, $self->dir_target(qw[$(INST_MAN3DIR)]);
    }

d3594 1
a3594 1
help:
d3627 1
a3627 1
	$(PERLRUN) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
d3642 1
a3642 1
	$(PERLRUN) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.cpp
d3658 1
a3658 1
	$(PERLRUN) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
@


1.14
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d2772 1
a2772 1
	return if m/^libperl/;
@


1.13
log
@Back out a local OpenBSD change I adapted from a 5.6.1 change.
I don't think it is needed anymore and it breaks MM_Unix's prefixify test.
@
text
@d9 1
a9 1
use Config;
a10 1
use File::Spec;
d12 1
a12 1
use strict;
d14 4
a17 2
            $Is_Mac $Is_OS2 $Is_VMS $Is_Win32 $Is_Dos $Is_VOS
            $Verbose %pm %static $Xsubpp_Version
d23 1
a23 1
$VERSION = '1.33';
d28 17
a44 6
$Is_OS2   = $^O eq 'os2';
$Is_Mac   = $^O eq 'MacOS';
$Is_Win32 = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
$Is_Dos   = $^O eq 'dos';
$Is_VOS   = $^O eq 'vos';
$Is_VMS   = $^O eq 'VMS';
d80 2
a81 1
sections and complain loudly to the makemaker mailing list.
d91 7
a97 85
# we have these globals to cache the values.  They have to be global
# else the SelfLoaded methods can't see them.
use vars qw($Curdir $Rootdir $Updir);
$Curdir  = File::Spec->curdir;
$Rootdir = File::Spec->rootdir;
$Updir   = File::Spec->updir;

sub c_o;
sub clean;
sub const_cccmd;
sub const_config;
sub const_loadlibs;
sub constants;
sub depend;
sub dir_target;
sub dist;
sub dist_basics;
sub dist_ci;
sub dist_core;
sub dist_dir;
sub dist_test;
sub dlsyms;
sub dynamic;
sub dynamic_bs;
sub dynamic_lib;
sub exescan;
sub export_list;
sub extliblist;
sub find_perl;
sub fixin;
sub force;
sub guess_name;
sub has_link_code;
sub init_dirscan;
sub init_main;
sub init_others;
sub install;
sub installbin;
sub libscan;
sub linkext;
sub lsdir;
sub macro;
sub makeaperl;
sub makefile;
sub manifypods;
sub maybe_command;
sub maybe_command_in_dirs;
sub needs_linking;
sub nicetext;
sub parse_abstract;
sub parse_version;
sub pasthru;
sub perl_archive;
sub perl_archive_after;
sub perl_script;
sub perldepend;
sub pm_to_blib;
sub ppd;
sub post_constants;
sub post_initialize;
sub postamble;
sub prefixify;
sub processPL;
sub quote_paren;
sub realclean;
sub replace_manpage_separator;
sub static;
sub static_lib;
sub staticmake;
sub subdir_x;
sub subdirs;
sub test;
sub test_via_harness;
sub test_via_script;
sub tool_autosplit;
sub tool_xsubpp;
sub tools_other;
sub top_targets;
sub writedoc;
sub xs_c;
sub xs_cpp;
sub xs_o;
sub xsubpp_version;

#use SelfLoader;
d99 1
a99 2
# SelfLoader not smart enough to avoid autoloading DESTROY
sub DESTROY { }
d101 1
a101 1
#1;
d103 1
a103 1
#__DATA__
d105 5
a109 1
=head2 SelfLoaded methods
a110 1
=over 2
d283 1
a283 1
clean ::
a284 16
    # clean subdirectories first
    for $dir (@@{$self->{DIR}}) {
	if ($Is_Win32  &&  Win32::IsWin95()) {
	    push @@m, <<EOT;
	cd $dir
	\$(TEST_F) $self->{MAKEFILE}
	\$(MAKE) clean
	cd ..
EOT
	}
	else {
	    push @@m, <<EOT;
	-cd $dir && \$(TEST_F) $self->{MAKEFILE} && \$(MAKE) clean
EOT
	}
    }
d287 1
a287 1
    if ( $^O eq 'qnx' ) {
d297 1
d309 3
d314 1
a314 1
    push @@m, "\t-$self->{RM_RF} @@otherfiles\n";
d317 1
a317 1
	 "\t-$self->{MV} $self->{MAKEFILE} $self->{MAKEFILE}.old \$(DEV_NULL)\n");
d323 32
d390 1
a390 1
	next if $once_only{$m} or $m eq 'sitelibexp' or $m eq 'sitearchexp';
d426 3
a428 1
Initializes lots of constants and .SUFFIXES and .PHONY
d434 1
a434 1
    my(@@m,$tmp);
d436 1
a436 1
    for $tmp (qw/
d438 7
a444 3
	      AR_STATIC_ARGS NAME DISTNAME NAME_SYM VERSION
	      VERSION_SYM XS_VERSION 
	      INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB
d446 9
a454 6
              PREFIX          SITEPREFIX      VENDORPREFIX
	      INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
	      INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
              INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN  INSTALLSCRIPT 
              PERL_LIB        PERL_ARCHLIB 
              SITELIBEXP      SITEARCHEXP 
d456 7
a462 4
	      FIRST_MAKEFILE MAKE_APERL_FILE PERLMAINCC PERL_SRC
	      PERL_INC PERL FULLPERL PERLRUN FULLPERLRUN PERLRUNINST 
              FULLPERLRUNINST ABSPERL ABSPERLRUN ABSPERLRUNINST
              FULL_AR PERL_CORE NOOP NOECHO
d464 1
a464 1
	      / ) 
d466 1
a466 1
	next unless defined $self->{$tmp};
d470 2
a471 2
        $self->{$tmp} =~ s/#/\\#/g;
	push @@m, "$tmp = $self->{$tmp}\n";
d475 3
a477 10
VERSION_MACRO = VERSION
DEFINE_VERSION = -D\$(VERSION_MACRO)=\\\"\$(VERSION)\\\"
XS_VERSION_MACRO = XS_VERSION
XS_DEFINE_VERSION = -D\$(XS_VERSION_MACRO)=\\\"\$(XS_VERSION)\\\"
PERL_MALLOC_DEF = -DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc -Dfree=Perl_mfree -Drealloc=Perl_realloc -Dcalloc=Perl_calloc
};

    push @@m, qq{
MAKEMAKER = $INC{'ExtUtils/MakeMaker.pm'}
MM_VERSION = $ExtUtils::MakeMaker::VERSION
d487 1
a487 1
    for $tmp (qw/
d492 2
a493 2
	next unless defined $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
d498 6
a503 6
XS_FILES= ".join(" \\\n\t", sort keys %{$self->{XS}})."
C_FILES = ".join(" \\\n\t", @@{$self->{C}})."
O_FILES = ".join(" \\\n\t", @@{$self->{O_FILES}})."
H_FILES = ".join(" \\\n\t", @@{$self->{H}})."
MAN1PODS = ".join(" \\\n\t", sort keys %{$self->{MAN1PODS}})."
MAN3PODS = ".join(" \\\n\t", sort keys %{$self->{MAN3PODS}})."
a505 20
    for $tmp (qw/
	      INST_MAN1DIR  MAN1EXT 
              INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR
	      INST_MAN3DIR  MAN3EXT
              INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR
	      /) 
    {
	next unless defined $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
    }

    for $tmp (qw(
		PERM_RW PERM_RWX
		)
	     ) 
    {
        my $method = lc($tmp);
	# warn "self[$self] method[$method]";
        push @@m, "$tmp = ", $self->$method(), "\n";
    }
d508 4
a511 2
.NO_CONFIG_REC: Makefile
} if $ENV{CLEARCASE_ROOT};
a512 1
    # why not q{} ? -- emacs
d514 10
a523 15
# work around a famous dec-osf make(1) feature(?):
makemakerdflt: all

.SUFFIXES: .xs .c .C .cpp .i .s .cxx .cc \$(OBJ_EXT)

# Nick wanted to get rid of .PRECIOUS. I don't remember why. I seem to recall, that
# some make implementations will delete the Makefile when we rebuild it. Because
# we call false(1) when we rebuild it. So make(1) is not completely wrong when it
# does so. Our milage may vary.
# .PRECIOUS: Makefile    # seems to be not necessary anymore

.PHONY: all config static dynamic test linkext manifest

# Where is the Config information that we are using/depend on
CONFIGDEP = \$(PERL_ARCHLIB)/Config.pm \$(PERL_INC)/config.h
a525 5
    my @@parentdir = split(/::/, $self->{PARENT_NAME});
    push @@m, q{
# Where to put things:
INST_LIBDIR      = }. File::Spec->catdir('$(INST_LIB)',@@parentdir)        .q{
INST_ARCHLIBDIR  = }. File::Spec->catdir('$(INST_ARCHLIB)',@@parentdir)    .q{
d527 5
a531 2
INST_AUTODIR     = }. File::Spec->catdir('$(INST_LIB)','auto','$(FULLEXT)')       .q{
INST_ARCHAUTODIR = }. File::Spec->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)')   .q{
a533 23
    if ($self->has_link_code()) {
	push @@m, '
INST_STATIC  = $(INST_ARCHAUTODIR)/$(BASEEXT)$(LIB_EXT)
INST_DYNAMIC = $(INST_ARCHAUTODIR)/$(DLBASE).$(DLEXT)
INST_BOOT    = $(INST_ARCHAUTODIR)/$(BASEEXT).bs
';
    } else {
	push @@m, '
INST_STATIC  =
INST_DYNAMIC =
INST_BOOT    =
';
    }

    $tmp = $self->export_list;
    push @@m, "
EXPORT_LIST = $tmp
";
    $tmp = $self->perl_archive;
    push @@m, "
PERL_ARCHIVE = $tmp
";
    $tmp = $self->perl_archive_after;
a534 2
PERL_ARCHIVE_AFTER = $tmp
";
d536 1
a536 2
    push @@m, q{
TO_INST_PM = }.join(" \\\n\t", sort keys %{$self->{PM}}).q{
d538 2
a539 2
PM_TO_BLIB = }.join(" \\\n\t", %{$self->{PM}}).q{
};
d544 1
d583 2
a584 2
	my($src) = File::Spec->catfile($self->{PERL_INC},'perl.h');
	my($targ) = File::Spec->catfile($dir,'.exists');
d595 2
a596 2
	$self->{NOECHO}\$(MKPATH) $targdir
	$self->{NOECHO}\$(EQUALIZE_TIMESTAMP) $src $targ
d599 1
a599 1
	-$self->{NOECHO}\$(CHMOD) \$(PERM_RWX) $targdir
d605 91
d698 6
a703 1
Defines a lot of macros for distribution support.
a709 25
    # VERSION should be sanitised before use as a file name
    $attribs{VERSION}  ||= '$(VERSION)';
    $attribs{NAME}     ||= '$(DISTNAME)';
    $attribs{TAR}      ||= 'tar';
    $attribs{TARFLAGS} ||= 'cvf';
    $attribs{ZIP}      ||= 'zip';
    $attribs{ZIPFLAGS} ||= '-r';
    $attribs{COMPRESS} ||= 'gzip --best';
    $attribs{SUFFIX}   ||= '.gz';
    $attribs{SHAR}     ||= 'shar';
    $attribs{PREOP}    ||= "$self->{NOECHO}\$(NOOP)"; # eg update MANIFEST
    $attribs{POSTOP}   ||= "$self->{NOECHO}\$(NOOP)"; # eg remove the distdir
    $attribs{TO_UNIX}  ||= "$self->{NOECHO}\$(NOOP)";

    $attribs{CI}       ||= 'ci -u';
    $attribs{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';
    $attribs{DIST_CP}  ||= 'best';
    $attribs{DIST_DEFAULT} ||= 'tardist';

    $attribs{DISTVNAME} ||= "$attribs{NAME}-$attribs{VERSION}";

    # We've already printed out VERSION and NAME variables.
    delete $attribs{VERSION};
    delete $attribs{NAME};

d711 9
a719 2
    while(my($var, $value) = each %attribs) {
        $make .= "$var = $value\n";
d762 1
a762 2
    my @@m;
    push @@m, q{
d765 3
a767 3
		-e "@@all = keys %{ maniread() };" \\
		-e 'print("Executing $(CI) @@all\n"); system("$(CI) @@all");' \\
		-e 'print("Executing $(RCS_LABEL) ...\n"); system("$(RCS_LABEL) @@all");'
a768 1
    join "", @@m;
d773 4
a776 1
Defines the targets dist, tardist, zipdist, uutardist, shdist
a781 5
    my @@m;
    push @@m, q{
dist : $(DIST_DEFAULT)
	}.$self->{NOECHO}.q{$(PERL) -le 'print "Warning: Makefile possibly out of date with $$vf" if ' \
	    -e '-e ($$vf="$(VERSION_FROM)") and -M $$vf < -M "}.$self->{MAKEFILE}.q{";'
d783 51
d835 7
d843 10
d854 16
d871 1
d879 12
d892 4
d901 8
d910 6
d917 4
a920 3
	uuencode $(DISTVNAME).tar$(SUFFIX) \\
		$(DISTVNAME).tar$(SUFFIX) > \\
		$(DISTVNAME).tar$(SUFFIX)_uu
d922 12
d939 1
a939 2
};
    join "", @@m;
d942 1
a942 1
=item dist_dir
d949 4
a952 1
sub dist_dir {
d956 1
a956 1
distdir :
d995 1
a995 1
    return '' unless ($^O eq 'aix' && $self->needs_linking() );
d1034 2
a1035 5
## $(INST_PM) has been moved to the all: target.
## It remains here for awhile to allow for old usage: "make dynamic"
#dynamic :: '.$self->{MAKEFILE}.' $(INST_DYNAMIC) $(INST_BOOT) $(INST_PM)
dynamic :: '.$self->{MAKEFILE}.' $(INST_DYNAMIC) $(INST_BOOT)
	'.$self->{NOECHO}.'$(NOOP)
d1051 2
a1052 2
    return '
BOOTSTRAP = '."$self->{BASEEXT}.bs".'
d1057 3
a1059 3
$(BOOTSTRAP): '."$self->{MAKEFILE} $self->{BOOTDEP}".' $(INST_ARCHAUTODIR)/.exists
	'.$self->{NOECHO}.'echo "Running Mkbootstrap for $(NAME) ($(BSLOADLIBS))"
	'.$self->{NOECHO}.'$(PERLRUN) \
d1061 2
a1062 2
		-e "Mkbootstrap(\'$(BASEEXT)\',\'$(BSLOADLIBS)\');"
	'.$self->{NOECHO}.'$(TOUCH) $(BOOTSTRAP)
d1065 3
a1067 3
$(INST_BOOT): $(BOOTSTRAP) $(INST_ARCHAUTODIR)/.exists
	'."$self->{NOECHO}$self->{RM_RF}".' $(INST_BOOT)
	-'.$self->{CP}.' $(BOOTSTRAP) $(INST_BOOT)
d1069 1
a1069 1
';
d1088 1
a1088 1
    $armaybe = 'ar' if ($^O eq 'dec_osf' and $armaybe eq ':');
d1091 1
d1098 1
d1100 1
a1100 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)/.exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
d1107 1
a1107 1
    $ldfrom = "-all $ldfrom -none" if ($^O eq 'dec_osf');
d1110 1
a1110 1
    my $ldrun = $^O eq 'irix' && $self->{LD_RUN_PATH} ?         
d1123 1
a1123 1
    if ($^O eq 'netbsd') {
d1139 1
a1139 1
' $(OTHERLDFLAGS) -o $@@ $(MYEXTLIB) $(PERL_ARCHIVE) '.$libs.' $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)');
d1182 1
a1182 1
	print "Looking for perl $ver by these names:
d1188 15
d1204 37
a1240 21
	foreach $dir (@@$dirs){
	    next unless defined $dir; # $self->{PERL_SRC} may be undefined
	    my ($abs, $val);
	    if (File::Spec->file_name_is_absolute($name)) { # /foo/bar
		$abs = $name;
	    } elsif (File::Spec->canonpath($name) eq File::Spec->canonpath(basename($name))) { # foo
		$abs = File::Spec->catfile($dir, $name);
	    } else { # foo/bar
		$abs = File::Spec->canonpath(File::Spec->catfile($Curdir, $name));
	    }
	    print "Checking $abs\n" if ($trace >= 2);
	    next unless $self->maybe_command($abs);
	    print "Executing $abs\n" if ($trace >= 2);
	    $val = `$abs -e 'require $ver; print "VER_OK\n" ' 2>&1`;
	    if ($val =~ /VER_OK/) {
	        print "Using PERL=$abs\n" if $trace;
	        return $abs;
	    } elsif ($trace >= 2) {
		print "Result: `$val'\n";
	    }
	}
d1282 3
d1305 1
a1305 1
	    my(@@absdirs) = reverse grep {File::Spec->file_name_is_absolute} File::Spec->path;
d1311 1
a1311 1
		    $interpreter = File::Spec->catfile($dir,$cmd);
d1336 1
a1336 1
	unless ( open(FIXOUT,">$file.new") ) {
a1339 1
	my($dev,$ino,$mode) = stat FIXIN;
d1348 4
a1351 2
	unless ( rename($file, "$file.bak") ) {	
	    warn "Can't rename $file to $file.bak: $!";
d1354 5
a1358 5
	unless ( rename("$file.new", $file) ) {	
	    warn "Can't rename $file.new to $file: $!";
	    unless ( rename("$file.bak", $file) ) {
	        warn "Can't rename $file.bak back to $file either: $!";
		warn "Leaving $file renamed as $file.bak\n";
d1362 1
a1362 1
	unlink "$file.bak";
d1379 1
a1379 1
	'.$self->{NOECHO}.'$(NOOP)
d1425 4
a1428 1
Initializes DIR, XS, PM, C, O_FILES, H, PL_FILES, MAN*PODS, EXE_FILES.
d1435 1
a1435 1
    local(%pm); #the sub in find() has to see this hash
d1451 2
a1452 1
	    $dir{$name} = $name if (-f File::Spec->catfile($name,"Makefile.PL"));
d1472 1
a1472 1
                $pm{$name} = File::Spec->catfile($self->{INST_LIBDIR},$name); 
d1475 1
a1475 1
	    $pm{$name} = File::Spec->catfile($self->{INST_LIBDIR},$name);
d1505 8
a1512 8
    if ($Is_VMS) {
      # avoid logical name collisions by adding directory syntax
      $self->{PMLIBDIRS} = ['./lib', './' . $self->{BASEEXT}]
	unless $self->{PMLIBDIRS};
    }
    else {
      $self->{PMLIBDIRS} = ['lib', $self->{BASEEXT}]
       unless $self->{PMLIBDIRS};
d1532 1
a1532 1
                if ($_ eq "CVS" || $_ eq "RCS"){
d1539 1
d1548 1
a1548 1
	    my($inst) = File::Spec->catfile($prefix,$striplibpath);
d1557 11
a1567 8
    $self->{DIR} = [sort keys %dir] unless $self->{DIR};
    $self->{XS}  = \%xs             unless $self->{XS};
    $self->{PM}  = \%pm             unless $self->{PM};
    $self->{C}   = [sort keys %c]   unless $self->{C};
    my(@@o_files) = @@{$self->{C}};
    $self->{O_FILES} = [grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i, @@o_files] ;
    $self->{H}   = [sort keys %h]   unless $self->{H};
    $self->{PL_FILES} = \%pl_files unless $self->{PL_FILES};
d1574 2
a1575 1
	    $pods{$man} = 1 unless $self->{"INST_${man}DIR"} =~ /^(none|\s*)$/;
d1586 1
a1586 1
			if (/^=(head[1-4]|item|pod)\b/) {
d1599 1
a1599 1
		      File::Spec->catfile("\$(INST_MAN1DIR)", basename($name).".\$(MAN1EXT)");
d1615 1
a1615 1
			if (/^=(head[1-4]|item|pod)\b/) {
d1640 5
a1644 2
	    unless ($manpagename =~ s!^\W*lib\W+!!s) { # everything below lib is ok
		$manpagename = File::Spec->catfile(split(/::/,$self->{PARENT_NAME}),$manpagename);
d1649 1
a1649 1
		  File::Spec->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
d1655 13
d1672 1
a1672 1
INSTALL*, INSTALLDIRS, LD, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME,
d1675 1
a1675 1
VERSION_FROM, VERSION_SYM, XS_VERSION.
d1691 1
a1691 1
    $self->{FULLEXT} = File::Spec->catdir(split /::/, $self->{NAME});
d1726 4
a1729 4
                      File::Spec->catdir($Updir,$Updir),
                      File::Spec->catdir($Updir,$Updir,$Updir),
                      File::Spec->catdir($Updir,$Updir,$Updir,$Updir),
                      File::Spec->catdir($Updir,$Updir,$Updir,$Updir,$Updir))
d1732 1
a1732 1
		-f File::Spec->catfile($dir,"config_h.SH")
d1734 1
a1734 1
		-f File::Spec->catfile($dir,"perl.h")
d1736 1
a1736 1
		-f File::Spec->catfile($dir,"lib","Exporter.pm")
d1748 1
a1748 1
	$self->{PERL_LIB}     ||= File::Spec->catdir("$self->{PERL_SRC}","lib");
d1752 1
a1752 1
              File::Spec->catdir("$self->{PERL_SRC}","xlib",$Cross::platform);
d1754 1
a1754 1
              File::Spec->catdir("$self->{PERL_SRC}","xlib",$Cross::platform, 
d1760 1
a1760 1
              File::Spec->catdir($self->{PERL_LIB},"CORE") : $self->{PERL_SRC};
d1765 1
a1765 1
		-s File::Spec->catfile($self->{PERL_SRC},'cflags')
d1769 1
a1769 1
		-s File::Spec->catfile($self->{PERL_SRC},'perlshr_attr.opt')
d1794 1
a1794 1
	$self->{PERL_INC}     = File::Spec->catdir("$self->{PERL_ARCHLIB}","CORE"); # wild guess for now
d1797 1
a1797 1
	if (not -f ($perl_h = File::Spec->catfile($self->{PERL_INC},"perl.h"))
d1803 1
a1803 1
	      $found = $dir, last if -e File::Spec->catdir($dir, "Config.pm");
d1807 1
a1807 1
	      if (-e File::Spec->catdir($inc, "perl.h")) {
d1819 1
a1819 1
	unless(-f ($perl_h = File::Spec->catfile($self->{PERL_INC},"perl.h")))
a1844 4

    $self->init_INST;
    $self->init_INSTALL;

d1854 2
a1855 2
    my(%once_only,$m);
    foreach $m (@@{$self->{CONFIG}}){
a1872 1
    $self->{LD} ||= 'ld';
d1883 1
a1883 1
	unless -f File::Spec->catfile("$self->{PERL_LIB}","Exporter.pm") ||
d1885 1
d1887 1
a1887 9
    # Determine VERSION and VERSION_FROM
    ($self->{DISTNAME}=$self->{NAME}) =~ s#(::)#-#g unless $self->{DISTNAME};
    if ($self->{VERSION_FROM}){
	$self->{VERSION} = $self->parse_version($self->{VERSION_FROM});
        if( $self->{VERSION} eq 'undef' ) {
	    carp "WARNING: Setting VERSION via file ".
                 "'$self->{VERSION_FROM}' failed\n";
        }
    }
d1889 4
a1892 28
    # strip blanks
    if (defined $self->{VERSION}) {
	$self->{VERSION} =~ s/^\s+//;
	$self->{VERSION} =~ s/\s+$//;
    }
    else {
        $self->{VERSION} = '';
    }
    ($self->{VERSION_SYM} = $self->{VERSION}) =~ s/\W/_/g;

    $self->{DISTVNAME} = "$self->{DISTNAME}-$self->{VERSION}";

    # Graham Barr and Paul Marquess had some ideas how to ensure
    # version compatibility between the *.pm file and the
    # corresponding *.xs file. The bottomline was, that we need an
    # XS_VERSION macro that defaults to VERSION:
    $self->{XS_VERSION} ||= $self->{VERSION};


    # --- Initialize Perl Binary Locations
    $self->init_PERL;
}

=item init_others

Initializes EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LIBS, LD_RUN_PATH,
OBJECT, BOOTDEP, PERLMAINCC, LDFROM, LINKTYPE, NOOP, FIRST_MAKEFILE,
MAKEFILE, NOECHO, RM_F, RM_RF, TEST_F, TOUCH, CP, MV, CHMOD, UMASK_NULL
d1899 2
d1906 1
a1906 1
    $self->{LIBS}=[''] unless $self->{LIBS};
d1908 1
a1908 1
    $self->{LIBS}=[$self->{LIBS}] if ref \$self->{LIBS} eq 'SCALAR';
d1944 40
a1983 15
    # These get overridden for VMS and maybe some other systems
    $self->{NOOP}  ||= '$(SHELL) -c true';
    $self->{FIRST_MAKEFILE} ||= "Makefile";
    $self->{MAKEFILE} ||= $self->{FIRST_MAKEFILE};
    $self->{MAKE_APERL_FILE} ||= "Makefile.aperl";
    $self->{NOECHO} = '@@' unless defined $self->{NOECHO};
    $self->{RM_F}  ||= "rm -f";
    $self->{RM_RF} ||= "rm -rf";
    $self->{TOUCH} ||= "touch";
    $self->{TEST_F} ||= "test -f";
    $self->{CP} ||= "cp";
    $self->{MV} ||= "mv";
    $self->{CHMOD} ||= "chmod";
    $self->{UMASK_NULL} ||= "umask 0";
    $self->{DEV_NULL} ||= "> /dev/null 2>&1";
d1990 2
a1991 1
Called by init_main.  Sets up all INST_* variables.
d1998 2
a1999 2
    $self->{INST_ARCHLIB} ||= File::Spec->catdir($Curdir,"blib","arch");
    $self->{INST_BIN}     ||= File::Spec->catdir($Curdir,'blib','bin');
d2008 1
a2008 1
                  File::Spec->catdir($self->{PERL_LIB},"..","xlib",
d2015 1
a2015 1
	    $self->{INST_LIB} = File::Spec->catdir($Curdir,"blib","lib");
d2020 6
a2025 7
    $self->{INST_LIBDIR} = File::Spec->catdir($self->{INST_LIB},@@parentdir);
    $self->{INST_ARCHLIBDIR} = File::Spec->catdir($self->{INST_ARCHLIB},
                                                  @@parentdir);
    $self->{INST_AUTODIR} = File::Spec->catdir($self->{INST_LIB},'auto',
                                               $self->{FULLEXT});
    $self->{INST_ARCHAUTODIR} = File::Spec->catdir($self->{INST_ARCHLIB},
                                                   'auto',$self->{FULLEXT});
d2027 1
a2027 1
    $self->{INST_SCRIPT} ||= File::Spec->catdir($Curdir,'blib','script');
d2029 2
a2030 2
    $self->{INST_MAN1DIR} ||= File::Spec->catdir($Curdir,'blib','man1');
    $self->{INST_MAN3DIR} ||= File::Spec->catdir($Curdir,'blib','man3');
d2040 1
a2040 1
INSTALLDIRS) and PREFIX.
d2049 9
a2057 9
    if( $Config{usevendorprefix} ) {
        $Config_Override{installvendorman1dir} =
          File::Spec->catdir($Config{vendorprefixexp}, 'man', 'man$(MAN1EXT)');
        $Config_Override{installvendorman3dir} =
          File::Spec->catdir($Config{vendorprefixexp}, 'man', 'man$(MAN3EXT)');
    }
    else {
        $Config_Override{installvendorman1dir} = '';
        $Config_Override{installvendorman3dir} = '';
d2072 1
a2072 1
          File::Spec->catdir($sprefix, 'man', 'man$(MAN1EXT)');
d2077 1
a2077 1
          File::Spec->catdir($sprefix, 'man', 'man$(MAN3EXT)');
d2082 1
a2082 1
          File::Spec->catdir($sprefix, 'bin');
d2085 1
a2085 3
    my $u_prefix  = $self->{PREFIX}       || '';
    my $u_sprefix = $self->{SITEPREFIX}   || $u_prefix;
    my $u_vprefix = $self->{VENDORPREFIX} || $u_prefix;
d2087 9
a2095 3
    $self->{PREFIX}       ||= $u_prefix  || $iprefix;
    $self->{SITEPREFIX}   ||= $u_sprefix || $sprefix;
    $self->{VENDORPREFIX} ||= $u_vprefix || $vprefix;
d2101 1
a2101 1
    my $libstyle = 'lib/perl5';
d2119 1
a2119 1
                         r => $u_prefix,
d2122 1
a2122 1
                         r => $u_vprefix,
d2125 1
a2125 1
                         r => $u_sprefix,
d2128 1
a2128 1
                         r => $u_prefix,
d2135 2
a2136 2
                             r => $u_prefix,
                             d => 'man/man$(MAN1EXT)',
d2139 2
a2140 2
                             r => $u_sprefix,
                             d => 'man/man$(MAN1EXT)',
d2143 2
a2144 2
                             r => $u_vprefix,
                             d => 'man/man$(MAN1EXT)',
d2148 2
a2149 2
                             r => $u_prefix,
                             d => 'man/man$(MAN3EXT)',
d2152 2
a2153 2
                             r => $u_sprefix,
                             d => 'man/man$(MAN3EXT)',
d2156 2
a2157 2
                             r => $u_vprefix,
                             d => 'man/man$(MAN3EXT)',
d2164 1
a2164 1
                         r => $u_prefix,
d2168 1
a2168 1
                         r => $u_vprefix,
d2172 1
a2172 1
                         r => $u_sprefix,
d2177 1
a2177 1
                         r => $u_prefix,
d2181 1
a2181 1
                         r => $u_vprefix,
d2185 1
a2185 1
                         r => $u_sprefix,
d2198 1
a2198 1
                  File::Spec->catdir($self->{LIB}, $Config{archname});
d2206 4
d2213 2
a2214 1
        my($s, $r, $d, $style) = @@{$layout}{qw(s r d style)};
d2222 2
a2223 8
        if( $r ) {
            $d = "$style/$d" if $style;
            $self->prefixify($installvar, $s, $r, $d);
        }
        else {
            $self->{$Installvar} = $Config_Override{$installvar} || 
                                   $Config{$installvar};
        }
d2229 4
d2236 14
d2302 1
d2324 9
a2332 2
    my $thisperl = File::Spec->canonpath($^X);
    $thisperl .= $Config{exe_ext} unless $thisperl =~ m/$Config{exe_ext}$/i;
d2352 7
d2360 1
a2360 1
    ($self->{FULLPERL} = $self->{PERL}) =~ s/miniperl/perl/i
d2367 1
a2367 1
    if( File::Spec->file_name_is_absolute($self->{ABSPERL}) ) {
d2371 1
a2371 1
        $self->{ABSPERL} = File::Spec->rel2abs($self->{ABSPERL});
d2380 3
a2382 1
        $self->{$perl.'RUN'}  = "\$($perl)";
d2385 1
a2385 1
        $self->{$perl.'RUN'} .= q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"} 
d2395 33
d2439 2
a2440 2
    $self->{PERM_RW}  = 644;
    $self->{PERM_RWX} = 755;
d2444 27
a2470 1
    
a2493 1
	}.$self->{NOECHO}.q{echo Appending installation info to $(INSTALLARCHLIB)/perllocal.pod
d2496 1
a2496 1
	@@echo INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
d2499 1
a2499 1
	@@echo INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
d2502 11
a2512 11
	}.$self->{NOECHO}.q{$(MOD_INSTALL) \
		read }.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		write }.File::Spec->catfile('$(INSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(INSTALLPRIVLIB) \
		$(INST_ARCHLIB) $(INSTALLARCHLIB) \
		$(INST_BIN) $(INSTALLBIN) \
		$(INST_SCRIPT) $(INSTALLSCRIPT) \
		$(INST_MAN1DIR) $(INSTALLMAN1DIR) \
		$(INST_MAN3DIR) $(INSTALLMAN3DIR)
	}.$self->{NOECHO}.q{$(WARN_IF_OLD_PACKLIST) \
		}.File::Spec->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{
d2516 11
a2526 11
	}.$self->{NOECHO}.q{$(MOD_INSTALL) \
		read }.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
		write }.File::Spec->catfile('$(INSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(INSTALLSITELIB) \
		$(INST_ARCHLIB) $(INSTALLSITEARCH) \
		$(INST_BIN) $(INSTALLSITEBIN) \
		$(INST_SCRIPT) $(INSTALLSCRIPT) \
		$(INST_MAN1DIR) $(INSTALLSITEMAN1DIR) \
		$(INST_MAN3DIR) $(INSTALLSITEMAN3DIR)
	}.$self->{NOECHO}.q{$(WARN_IF_OLD_PACKLIST) \
		}.File::Spec->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{
d2529 9
a2537 7
	}.$self->{NOECHO}.q{$(MOD_INSTALL) \
		$(INST_LIB) $(INSTALLVENDORLIB) \
		$(INST_ARCHLIB) $(INSTALLVENDORARCH) \
		$(INST_BIN) $(INSTALLVENDORBIN) \
		$(INST_SCRIPT) $(INSTALLSCRIPT) \
		$(INST_MAN1DIR) $(INSTALLVENDORMAN1DIR) \
		$(INST_MAN3DIR) $(INSTALLVENDORMAN3DIR)
d2540 3
a2542 2
	-}.$self->{NOECHO}.q{$(MKPATH) $(INSTALLARCHLIB)
	-}.$self->{NOECHO}.q{$(DOC_INSTALL) \
d2548 1
a2548 1
		>> }.File::Spec->catfile('$(INSTALLARCHLIB)','perllocal.pod').q{
d2551 3
a2553 2
	-}.$self->{NOECHO}.q{$(MKPATH) $(INSTALLARCHLIB)
	-}.$self->{NOECHO}.q{$(DOC_INSTALL) \
d2559 1
a2559 1
		>> }.File::Spec->catfile('$(INSTALLSITEARCH)','perllocal.pod').q{
d2562 9
d2578 1
a2578 2
	}.$self->{NOECHO}.
	q{$(UNINSTALL) }.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{
d2581 4
a2584 2
	}.$self->{NOECHO}.
	q{$(UNINSTALL) }.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{
d2603 1
a2603 1
	my($path)= File::Spec->catfile('$(INST_SCRIPT)', basename($from));
d2610 10
d2623 2
a2624 5
} . ($Is_Win32
  ? q{FIXIN = pl2bat.bat
} : q{FIXIN = $(PERLRUN) "-MExtUtils::MY" \
    -e "MY->fixin(shift)"
}).qq{
d2626 1
a2626 1
	$self->{NOECHO}\$(NOOP)
d2629 1
a2629 1
	$self->{RM_F} @@to
d2636 3
a2638 3
$to: $from $self->{MAKEFILE} " . File::Spec->catdir($todir,'.exists') . "
	$self->{NOECHO}$self->{RM_F} $to
	$self->{CP} $from $to
d2640 1
a2640 1
	-$self->{NOECHO}\$(CHMOD) \$(PERM_RWX) $to
a2645 15
=item libscan (o)

Takes a path to a file that is found by init_dirscan and returns false
if we don't want to include this file in the library. Mainly used to
exclude RCS, CVS, and SCCS directories from installation.

=cut

# ';

sub libscan {
    my($self,$path) = @@_;
    return '' if $path =~ m:\b(RCS|CVS|SCCS)\b: ;
    $path;
}
d2660 1
a2660 1
	$self->{NOECHO}\$(NOOP)
d2731 2
a2732 2
	}.$self->{NOECHO}.q{echo Writing \"$(MAKE_APERL_FILE)\" for this $(MAP_TARGET)
	}.$self->{NOECHO}.q{$(PERLRUNINST) \
d2862 1
a2862 1
          if ($^O eq 'solaris' or $^O eq 'sunos') {
d2865 1
a2865 1
            $libperl = '' if $^O eq 'sunos';
d2884 4
a2887 4
\$(INST_ARCHAUTODIR)/extralibs.all: \$(INST_ARCHAUTODIR)/.exists ".join(" \\\n\t", @@$extra)."
	$self->{NOECHO}$self->{RM_F} \$\@@
	$self->{NOECHO}\$(TOUCH) \$\@@
";
d2897 4
a2900 4
	$self->{NOECHO}echo 'To install the new \"\$(MAP_TARGET)\" binary, call'
	$self->{NOECHO}echo '    make -f $makefilename inst_perl MAP_TARGET=\$(MAP_TARGET)'
	$self->{NOECHO}echo 'To remove the intermediate files say'
	$self->{NOECHO}echo '    make -f $makefilename map_clean'
d2908 2
a2909 2
	}.$self->{NOECHO}.q{echo Writing $@@
	}.$self->{NOECHO}.q{$(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \\
d2913 1
a2913 1
    push @@m, "\t",$self->{NOECHO}.q{$(PERL) $(INSTALLSCRIPT)/fixpmain
d2919 3
a2921 3
	}.$self->{NOECHO}.q{echo Appending installation info to $(INSTALLARCHLIB)/perllocal.pod
	-}.$self->{NOECHO}.q{$(MKPATH) $(INSTALLARCHLIB)
	-}.$self->{NOECHO}.q{$(DOC_INSTALL) \
d2926 1
a2926 1
		>> }.File::Spec->catfile('$(INSTALLARCHLIB)','perllocal.pod').q{
d2934 1
a2934 1
	}.$self->{CP}.q{ $(MAP_TARGET) }.File::Spec->catfile('$(INSTALLBIN)','$(MAP_TARGET)').q{
d2962 1
a2962 1
# We take a very conservative approach here, but it\'s worth it.
d2964 6
a2969 6
}.$self->{MAKEFILE}.q{ : Makefile.PL $(CONFIGDEP)
	}.$self->{NOECHO}.q{echo "Makefile out-of-date with respect to $?"
	}.$self->{NOECHO}.q{echo "Cleaning current config before rebuilding Makefile..."
	-}.$self->{NOECHO}.q{$(RM_F) }."$self->{MAKEFILE}.old".q{
	-}.$self->{NOECHO}.q{$(MV) }."$self->{MAKEFILE} $self->{MAKEFILE}.old".q{
	-$(MAKE) -f }.$self->{MAKEFILE}.q{.old clean $(DEV_NULL) || $(NOOP)
d2971 2
a2972 2
	}.$self->{NOECHO}.q{echo "==> Your Makefile has been rebuilt. <=="
	}.$self->{NOECHO}.q{echo "==> Please rerun the make command.  <=="
a2979 52
=item manifypods (o)

Defines targets and routines to translate the pods into manpages and
put them into the INST_* directories.

=cut

sub manifypods {
    my($self, %attribs) = @@_;
    return "\nmanifypods : pure_all\n\t$self->{NOECHO}\$(NOOP)\n" unless
	%{$self->{MAN3PODS}} or %{$self->{MAN1PODS}};
    my($dist);
    my($pod2man_exe);
    if (defined $self->{PERL_SRC}) {
	$pod2man_exe = File::Spec->catfile($self->{PERL_SRC},'pod','pod2man');
    } else {
	$pod2man_exe = File::Spec->catfile($Config{scriptdirexp},'pod2man');
    }
    unless ($pod2man_exe = $self->perl_script($pod2man_exe)) {
      # Maybe a build by uninstalled Perl?
      $pod2man_exe = File::Spec->catfile($self->{PERL_INC}, "pod", "pod2man");
    }
    unless ($pod2man_exe = $self->perl_script($pod2man_exe)) {
	# No pod2man but some MAN3PODS to be installed
	print <<END;

Warning: I could not locate your pod2man program. Please make sure,
         your pod2man program is in your PATH before you execute 'make'

END
        $pod2man_exe = "-S pod2man";
    }
    my(@@m);
    push @@m,
qq[POD2MAN_EXE = $pod2man_exe\n],
qq[POD2MAN = \$(PERL) -we '%m=\@@ARGV;for (keys %m){' \\\n],
q[-e 'next if -e $$m{$$_} && -M $$m{$$_} < -M $$_ && -M $$m{$$_} < -M "],
 $self->{MAKEFILE}, q[";' \\
-e 'print "Manifying $$m{$$_}\n";' \\
-e 'system(q[$(PERLRUN) $(POD2MAN_EXE) ].qq[$$_>$$m{$$_}])==0 or warn "Couldn\\047t install $$m{$$_}\n";' \\
-e 'chmod(oct($(PERM_RW)), $$m{$$_}) or warn "chmod $(PERM_RW) $$m{$$_}: $$!\n";}'
];
    push @@m, "\nmanifypods : pure_all ";
    push @@m, join " \\\n\t", keys %{$self->{MAN1PODS}}, keys %{$self->{MAN3PODS}};

    push(@@m,"\n");
    if (%{$self->{MAN1PODS}} || %{$self->{MAN3PODS}}) {
	push @@m, "\t$self->{NOECHO}\$(POD2MAN) \\\n\t";
	push @@m, join " \\\n\t", %{$self->{MAN1PODS}}, %{$self->{MAN3PODS}};
    }
    join('', @@m);
}
a2992 38
=item maybe_command_in_dirs

method under development. Not yet used. Ask Ilya :-)

=cut

sub maybe_command_in_dirs {	# $ver is optional argument if looking for perl
# Ilya's suggestion. Not yet used, want to understand it first, but at least the code is here
    my($self, $names, $dirs, $trace, $ver) = @@_;
    my($name, $dir);
    foreach $dir (@@$dirs){
	next unless defined $dir; # $self->{PERL_SRC} may be undefined
	foreach $name (@@$names){
	    my($abs,$tryabs);
	    if (File::Spec->file_name_is_absolute($name)) { # /foo/bar
		$abs = $name;
	    } elsif (File::Spec->canonpath($name) eq File::Spec->canonpath(basename($name))) { # bar
		$abs = File::Spec->catfile($dir, $name);
	    } else { # foo/bar
		$abs = File::Spec->catfile($Curdir, $name);
	    }
	    print "Checking $abs for $name\n" if ($trace >= 2);
	    next unless $tryabs = $self->maybe_command($abs);
	    print "Substituting $tryabs instead of $abs\n"
		if ($trace >= 2 and $tryabs ne $abs);
	    $abs = $tryabs;
	    if (defined $ver) {
		print "Executing $abs\n" if ($trace >= 2);
		if (`$abs -e 'require $ver; print "VER_OK\n" ' 2>&1` =~ /VER_OK/) {
		    print "Using PERL=$abs\n" if $trace;
		    return $abs;
		}
	    } else { # Do not look for perl
		return $abs;
	    }
	}
    }
}
d3005 1
a3005 1
    confess("Needs_linking called too early") if 
d3085 1
a3085 2
	# next unless /\$(([\w\:\']*)\bVERSION)\b.*\=/;
	next unless /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
d3163 1
a3163 1
	-}.$self->{NOECHO}.q{echo "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; false
d3166 1
a3166 1
	}.$self->{NOECHO}.q{echo "Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh"
a3196 1
	$(PERL_INC)/opnames.h		\
a3198 1
	$(PERL_INC)/perlapi.h		\
d3215 1
a3215 3
	$(PERL_INC)/utf8.h		\
	$(PERL_INC)/util.h		\
	$(PERL_INC)/warnings.h
d3239 1
a3239 1
    shift->{PERM_RW} || "644";
d3252 1
a3252 1
    shift->{PERM_RWX} || "755";
a3261 10
sub _pm_to_blib_flush {
    my ($self, $autodir, $rr, $ra, $rl) = @@_;
    $$rr .= 
q{	}.$self->{NOECHO}.q[$(PERLRUNINST) "-MExtUtils::Install" \
	-e "pm_to_blib({qw{].qq[@@$ra].q[}},'].$autodir.q{','$(PM_FILTER)')"
};
    @@$ra = ();
    $$rl = 0;
}

d3264 1
a3264 1
    my($autodir) = File::Spec->catdir('$(INST_LIB)','auto');
d3268 11
a3278 14
    my %pm_to_blib = %{$self->{PM}};
    my @@a;
    my $l = 0;
    while (my ($pm, $blib) = each %pm_to_blib) {
	my $la = length $pm;
	my $lb = length $blib;
	if ($l + $la + $lb + @@a / 2 > 200) { # limit line length
	    _pm_to_blib_flush($self, $autodir, \$r, \@@a, \$l);
        }
        push @@a, $pm, $blib;
	$l += $la + $lb;
    }
    _pm_to_blib_flush($self, $autodir, \$r, \@@a, \$l);
    return $r.q{	}.$self->{NOECHO}.q{$(TOUCH) $@@};
a3288 1
    my($self) = shift;
a3299 1
    my($self) = shift;
a3310 1
    my($self) = shift;
a3339 7
    $author =~ s/@@/\\@@/g;

    my $make_ppd = sprintf <<'PPD_OUT', $pack_ver, $abstract, $author;
# Creates a PPD (Perl Package Description) for a binary distribution.
ppd:
	@@$(PERL) -e "print qq{<SOFTPKG NAME=\"$(DISTNAME)\" VERSION=\"%s\">\n\t<TITLE>$(DISTNAME)</TITLE>\n\t<ABSTRACT>%s</ABSTRACT>\n\t<AUTHOR>%s</AUTHOR>\n}" > $(DISTNAME).ppd
PPD_OUT
d3341 6
d3348 1
a3348 1
    $make_ppd .= '	@@$(PERL) -e "print qq{\t<IMPLEMENTATION>\n';
d3354 4
a3357 1
        $make_ppd .= sprintf q{\t\t<DEPENDENCY NAME=\"%s\" VERSION=\"%s\" />\n}, $pre_req, $dep_ver;
a3358 2
    $make_ppd .= qq[}" >> \$(DISTNAME).ppd\n];

d3360 3
a3362 2
    $make_ppd .= sprintf <<'PPD_OUT', $Config{archname};
	@@$(PERL) -e "print qq{\t\t<OS NAME=\"$(OSNAME)\" />\n\t\t<ARCHITECTURE NAME=\"%s\" />\n
a3364 3
    chomp $make_ppd;


d3367 1
a3367 1
            $make_ppd .= sprintf q{\t\t<INSTALL EXEC=\"%s\">%s</INSTALL>\n},
d3371 1
a3371 1
            $make_ppd .= sprintf q{\t\t<INSTALL>%s</INSTALL>\n}, 
d3379 5
a3383 3
    $make_ppd .= sprintf q{\t\t<CODEBASE HREF=\"%s\" />\n}, $bin_location;
    $make_ppd .= q{\t</IMPLEMENTATION>\n};
    $make_ppd .= q{</SOFTPKG>\n};
d3385 7
a3391 1
    $make_ppd .= '}" >> $(DISTNAME).ppd';
a3392 1
    return $make_ppd;
d3400 6
a3405 2
replace it's $prefix with a $new_prefix.  Should the $prefix fail to
match it sill simply set it to the $new_prefix + $default.
d3427 2
d3432 1
a3432 1
    unless( $path =~ s{^\Q$sprefix\E\b}{$rprefix}s ) {
d3437 1
a3437 1
        $path = File::Spec->catdir($rprefix, $default) if $default;
d3463 1
a3463 1
	$self->{NOECHO}\$(NOOP)
d3482 5
a3486 5
    local $_ = shift;
    s/\$\((.+?)\)/\$\\\\($1\\\\)/g;	# protect $(...)
    s/(?<!\\)([()])/\\$1/g;		# quote unprotected
    s/\$\\\\\((.+?)\\\\\)/\$($1)/g;	# unprotect $(...)
    return $_;
d3501 3
a3503 1
realclean purge ::  clean
a3504 14
    # realclean subdirectories first (already cleaned)
    my $sub;
    if( $Is_Win32  &&  Win32::IsWin95() ) {
        $sub = <<'REALCLEAN';
	-cd %s
	-$(PERLRUN) -e "exit unless -f shift; system q{$(MAKE) realclean}" %s
	-cd ..
REALCLEAN
    }
    else {
        $sub = <<'REALCLEAN';
	-cd %s && $(TEST_F) %s && $(MAKE) %s realclean
REALCLEAN
    }
a3505 6
    foreach(@@{$self->{DIR}}){
	push(@@m, sprintf($sub,$_,"$self->{MAKEFILE}.old","-f $self->{MAKEFILE}.old"));
	push(@@m, sprintf($sub,$_,"$self->{MAKEFILE}",''));
    }
    push(@@m, "	$self->{RM_RF} \$(INST_AUTODIR) \$(INST_ARCHAUTODIR)\n");
    push(@@m, "	$self->{RM_RF} \$(DISTVNAME)\n");
d3507 2
a3508 2
        push(@@m, "	$self->{RM_F} \$(INST_DYNAMIC) \$(INST_BOOT)\n");
        push(@@m, "	$self->{RM_F} \$(INST_STATIC)\n");
d3510 8
d3521 9
a3529 12
    if (keys %{$self->{PM}}) {
	my $line = "";
	foreach (values %{$self->{PM}}) {
	    if (length($line) + length($_) > 80) {
		push @@m, "\t$self->{RM_F} $line\n";
		$line = $_;
	    }
	    else {
		$line .= " $_"; 
	    }
	}
    push @@m, "\t$self->{RM_F} $line\n" if $line;
d3531 3
a3533 5
    my(@@otherfiles) = ($self->{MAKEFILE},
		       "$self->{MAKEFILE}.old"); # Makefiles last
    push(@@otherfiles, $attribs{FILES}) if $attribs{FILES};
    push(@@m, "	$self->{RM_RF} @@otherfiles\n") if @@otherfiles;
    push(@@m, "	$attribs{POSTOP}\n")       if $attribs{POSTOP};
d3537 32
d3586 73
d3672 2
a3673 3
#static :: '.$self->{MAKEFILE}.' $(INST_STATIC) $(INST_PM)
static :: '.$self->{MAKEFILE}.' $(INST_STATIC)
	'.$self->{NOECHO}.'$(NOOP)
a3684 3
# Come to think of it, if there are subdirs with linkcode, we still have no INST_STATIC
#    return '' unless $self->needs_linking(); #might be because of a subdir

d3689 2
a3690 1
$(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)/.exists
d3693 1
d3696 3
a3698 1
    push(@@m, "\t$self->{CP} \$(MYEXTLIB) \$\@@\n") if $self->{MYEXTLIB};
d3708 6
a3713 6
    push @@m,
        "\t\$($ar) ".'$(AR_STATIC_ARGS) $@@ $(OBJECT) && $(RANLIB) $@@'."\n";
    push @@m,
q{	$(CHMOD) $(PERM_RWX) $@@
	}.$self->{NOECHO}.q{echo "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)/extralibs.ld
};
d3715 3
a3717 4
    push @@m,
"\t$self->{NOECHO}".q{echo "$(EXTRALIBS)" >> $(PERL_SRC)/ext.libs
}	if $self->{PERL_SRC} && $self->{EXTRALIBS};
    push @@m, "\n";
d3719 2
a3720 2
    push @@m, $self->dir_target('$(INST_ARCHAUTODIR)');
    join('', "\n",@@m);
d3738 1
a3738 1
	@@static = File::Spec->catfile($self->{INST_ARCHLIB},
d3773 1
a3773 23
    my(@@m);
    if ($Is_Win32 && Win32::IsWin95()) {
	if ($Config{'make'} =~ /dmake/i) {
	    # dmake-specific
	    return <<EOT;
subdirs ::
@@[
	cd $subdir
	\$(MAKE) -f \$(FIRST_MAKEFILE) all \$(PASTHRU)
	cd ..
]
EOT
        } elsif ($Config{'make'} =~ /nmake/i) {
	    # nmake-specific
	    return <<EOT;
subdirs ::
	cd $subdir
	\$(MAKE) -f \$(FIRST_MAKEFILE) all \$(PASTHRU)
	cd ..
EOT
	}
    } else {
	return <<EOT;
d3776 1
a3776 1
	$self->{NOECHO}cd $subdir && \$(MAKE) -f \$(FIRST_MAKEFILE) all \$(PASTHRU)
a3777 1
    }
d3837 2
a3838 2
    if ($Is_Win32 && Win32::IsWin95()) {
        push(@@m, map(qq{\t$self->{NOECHO}\$(PERLRUN) -e "exit unless -f shift; chdir '$_'; system q{\$(MAKE) test \$(PASTHRU)}" $self->{MAKEFILE}\n}, @@{$self->{DIR}}));
d3841 1
a3841 1
        push(@@m, map("\t$self->{NOECHO}cd $_ && \$(TEST_F) $self->{MAKEFILE} && \$(MAKE) test \$(PASTHRU)\n", @@{$self->{DIR}}));
d3844 1
a3844 1
    push(@@m, "\t$self->{NOECHO}echo 'No tests defined for \$(NAME) extension.'\n")
a3900 1
=item tool_autosplit (o)
d3902 1
a3902 2
Defines a simple perl call that runs autosplit. May be deprecated by
pm_to_blib soon.
d3904 1
a3904 6
=cut

sub tool_autosplit {
    my($self, %attribs) = @@_;
    my($asl) = "";
    $asl = "\$\$AutoSplit::Maxlen=$attribs{MAXLEN};" if $attribs{MAXLEN};
d3906 1
a3906 7
    return sprintf <<'MAKE_FRAG', $asl;
# Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto
AUTOSPLITFILE = $(PERLRUN) -e 'use AutoSplit; %s autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1) ;'

MAKE_FRAG

}
d3908 4
a3911 1
=item tools_other (o)
d3913 1
a3913 3
Defines SHELL, LD, TOUCH, CP, MV, RM_F, RM_RF, CHMOD, UMASK_NULL in
the Makefile. Also defines the perl programs MKPATH,
WARN_IF_OLD_PACKLIST, MOD_INSTALL. DOC_INSTALL, and UNINSTALL.
a3919 4
    my $bin_sh = $Config{sh} || '/bin/sh';
    push @@m, qq{
SHELL = $bin_sh
};
d3921 10
a3930 2
    for (qw/ CHMOD CP LD MV NOOP RM_F RM_RF TEST_F TOUCH UMASK_NULL DEV_NULL/ ) {
	push @@m, "$_ = $self->{$_}\n";
a3932 41
    push @@m, q{
# The following is a portable way to say mkdir -p
# To see which directories are created, change the if 0 to if 1
MKPATH = $(PERLRUN) "-MExtUtils::Command" -e mkpath

# This helps us to minimize the effect of the .exists files A yet
# better solution would be to have a stable file in the perl
# distribution with a timestamp of zero. But this solution doesn't
# need any changes to the core distribution and works with older perls
EQUALIZE_TIMESTAMP = $(PERLRUN) "-MExtUtils::Command" -e eqtime
};


    return join "", @@m if $self->{PARENT};

    push @@m, q{
# Here we warn users that an old packlist file was found somewhere,
# and that they should call some uninstall routine
WARN_IF_OLD_PACKLIST = $(PERL) -we 'exit unless -f $$ARGV[0];' \\
-e 'print "WARNING: I have found an old package in\n";' \\
-e 'print "\t$$ARGV[0].\n";' \\
-e 'print "Please make sure the two installations are not conflicting\n";'

UNINST=0
VERBINST=0

MOD_INSTALL = $(PERL) "-I$(INST_LIB)" "-I$(PERL_LIB)" "-MExtUtils::Install" \
-e "install({@@ARGV},'$(VERBINST)',0,'$(UNINST)');"

DOC_INSTALL = $(PERL) -e '$$\="\n\n";' \
-e 'print "=head2 ", scalar(localtime), ": C<", shift, ">", " L<", $$arg=shift, "|", $$arg, ">";' \
-e 'print "=over 4";' \
-e 'while (defined($$key = shift) and defined($$val = shift)){print "=item *";print "C<$$key: $$val>";}' \
-e 'print "=back";'

UNINSTALL =   $(PERLRUN) "-MExtUtils::Install" \
-e 'uninstall($$ARGV[0],1,1); print "\nUninstall is deprecated. Please check the";' \
-e 'print " packlist above carefully.\n  There may be errors. Remove the";' \
-e 'print " appropriate files manually.\n  Sorry for the inconveniences.\n"'
};

d3945 11
a3955 2
    my($xsdir)  = File::Spec->catdir($self->{PERL_LIB},"ExtUtils");
    my(@@tmdeps) = File::Spec->catdir('$(XSUBPPDIR)','typemap');
d3974 1
a3974 17
    my $xsubpp_version = $self->xsubpp_version(File::Spec->catfile($xsdir,"xsubpp"));

    # What are the correct thresholds for version 1 && 2 Paul?
    if ( $xsubpp_version > 1.923 ){
	$self->{XSPROTOARG} = "" unless defined $self->{XSPROTOARG};
    } else {
	if (defined $self->{XSPROTOARG} && $self->{XSPROTOARG} =~ /\-prototypes/) {
	    print STDOUT qq{Warning: This extension wants to pass the switch "-prototypes" to xsubpp.
	Your version of xsubpp is $xsubpp_version and cannot handle this.
	Please upgrade to a more recent version of xsubpp.
};
	} else {
	    $self->{XSPROTOARG} = "";
	}
    }

    my $xsubpp = "xsubpp";
d3978 1
a3978 1
XSUBPP = \$(XSUBPPDIR)/$xsubpp
a3985 4
sub xsubpp_version
{
    my($self,$xsubpp) = @@_;
    return $Xsubpp_Version if defined $Xsubpp_Version; # global variable
d3987 1
a3987 1
    my ($version) ;
d3989 1
a3989 1
    # try to figure out the version number of the xsubpp on the system
d3991 1
a3991 1
    # first try the -v flag, introduced in 1.921 & 2.000a2
d3993 2
a3994 1
    return "" unless $self->needs_linking;
d3996 4
a3999 40
    my $command = qq{$self->{PERL} "-I$self->{PERL_LIB}" $xsubpp -v 2>&1};
    print "Running $command\n" if $Verbose >= 2;
    $version = `$command` ;
    warn "Running '$command' exits with status " . ($?>>8) if $?;
    chop $version ;

    return $Xsubpp_Version = $1 if $version =~ /^xsubpp version (.*)/ ;

    # nope, then try something else

    my $counter = '000';
    my ($file) = 'temp' ;
    $counter++ while -e "$file$counter"; # don't overwrite anything
    $file .= $counter;

    open(F, ">$file") or die "Cannot open file '$file': $!\n" ;
    print F <<EOM ;
MODULE = fred PACKAGE = fred

int
fred(a)
        int     a;
EOM

    close F ;

    $command = "$self->{PERL} $xsubpp $file 2>&1";
    print "Running $command\n" if $Verbose >= 2;
    my $text = `$command` ;
    warn "Running '$command' exits with status " . ($?>>8) if $?;
    unlink $file ;

    # gets 1.2 -> 1.92 and 2.000a1
    return $Xsubpp_Version = $1 if $text =~ /automatically by xsubpp version ([\S]+)\s*/  ;

    # it is either 1.0 or 1.1
    return $Xsubpp_Version = 1.1 if $text =~ /^Warning: ignored semicolon/ ;

    # none of the above, so 1.0
    return $Xsubpp_Version = "1.0" ;
d4014 1
a4014 5
    push @@m, '
all :: pure_all manifypods
	'.$self->{NOECHO}.'$(NOOP)
' 
	  unless $self->{SKIPHASH}{'all'};
d4018 1
a4018 1
	'.$self->{NOECHO}.'$(NOOP)
d4021 1
a4021 1
	'.$self->{NOECHO}.'$(NOOP)
d4023 2
a4024 2
config :: '.$self->{MAKEFILE}.' $(INST_LIBDIR)/.exists
	'.$self->{NOECHO}.'$(NOOP)
d4026 2
a4027 2
config :: $(INST_ARCHAUTODIR)/.exists
	'.$self->{NOECHO}.'$(NOOP)
d4029 2
a4030 2
config :: $(INST_AUTODIR)/.exists
	'.$self->{NOECHO}.'$(NOOP)
d4036 3
a4038 3
	push @@m, qq[
config :: \$(INST_MAN1DIR)/.exists
	$self->{NOECHO}\$(NOOP)
d4044 3
a4046 3
	push @@m, qq[
config :: \$(INST_MAN3DIR)/.exists
	$self->{NOECHO}\$(NOOP)
a4123 41
}

=item perl_archive

This is internal method that returns path to libperl.a equivalent
to be linked to dynamic extensions. UNIX does not have one but other
OSs might have one.

=cut 

sub perl_archive
{
 return "";
}

=item perl_archive_after

This is an internal method that returns path to a library which
should be put on the linker command line I<after> the external libraries
to be linked to dynamic extensions.  This may be needed if the linker
is one-pass, and Perl includes some overrides for C RTL functions,
such as malloc().

=cut 

sub perl_archive_after
{
 return "";
}

=item export_list

This is internal method that returns name of a file that is
passed to linker to define symbols to be exported.
UNIX does not have one but OS2 and Win32 do.

=cut 

sub export_list
{
 return "";
@


1.12
log
@The regex used in ExtUtils-MakeMaker-6.05 to check for pod didn't match
=head[1-4] correctly.
@
text
@d3265 1
a3265 1
    unless( $path =~ s{^\Q$sprefix\E(?=/|\z)}{$rprefix}s ) {
@


1.11
log
@MakeMaker now appears to try to install pod pages in $installman{1,3}dir.
However, we define that to the empty string in OpenBSD since we
want to format and install perl's man pages ourselves.  As a result,
man pages were not being generated from .pm files in 3rd party modules.
To fix this, go back to the older behavior of using $inst_man{1,3}dir.

Also, while I'm in here, improve the regexp for deciding what
consists of pod, based on ExtUtils-MakeMaker-6.05.
@
text
@d1428 1
a1428 1
			if (/^=(head|item|pod)\b/) {
d1457 1
a1457 1
			if (/^=(head|item|pod)\b/) {
@


1.10
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d1417 1
a1417 2
	    $pods{$man} = 1 unless 
              $self->{"INSTALL${man}DIR"} =~ /^(none|\s*)$/;
d1428 1
a1428 1
			if (/^=head1\s+\w+/) {
d1457 1
a1457 1
			if (/^=head1\s+\w+/) {
@


1.9
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 4
d8 1
d11 1
d14 19
a32 19
use vars qw($VERSION $Is_Mac $Is_OS2 $Is_VMS $Is_Win32 $Is_Dos $Is_PERL_OBJECT
	    $Verbose %pm %static $Xsubpp_Version);

$VERSION = substr q$Revision: 1.12603 $, 10;
# $Id: MM_Unix.pm,v 1.126 1998/06/28 21:32:49 k Exp k $

Exporter::import('ExtUtils::MakeMaker', qw($Verbose &neatvalue));

$Is_OS2 = $^O eq 'os2';
$Is_Mac = $^O eq 'MacOS';
$Is_Win32 = $^O eq 'MSWin32';
$Is_Dos = $^O eq 'dos';

$Is_PERL_OBJECT = $Config{'ccflags'} =~ /-DPERL_OBJECT/;

if ($Is_VMS = $^O eq 'VMS') {
    require VMS::Filespec;
    import VMS::Filespec qw( &vmsify );
}
a74 32
=head2 Preloaded methods

=over 2

=item canonpath

No physical check on the filesystem, but a logical cleanup of a
path. On UNIX eliminated successive slashes and successive "/.".

=cut

sub canonpath {
    my($self,$path) = @@_;
    my $node = '';
    if ( $^O eq 'qnx' && $path =~ s|^(//\d+)/|/|s ) {
      $node = $1;
    }
    $path =~ s|(?<=[^/])/+|/|g ;                   # xx////xx  -> xx/xx
    $path =~ s|(/\.)+/|/|g ;                       # xx/././xx -> xx/xx
    $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
    $path =~ s|(?<=[^/])/\z|| ;                    # xx/       -> xx
    "$node$path";
}

=item catdir

Concatenate two or more directory names to form a complete path ending
with a directory. But remove the trailing slash from the resulting
string, because it doesn't look good, isn't necessary and confuses
OS2. Of course, if this is the root directory, don't cut off the
trailing slash :-)

d77 84
a160 137
# ';

sub catdir {
    my $self = shift @@_;
    my @@args = @@_;
    for (@@args) {
	# append a slash to each argument unless it has one there
	$_ .= "/" if $_ eq '' or substr($_,-1) ne "/";
    }
    $self->canonpath(join('', @@args));
}

=item catfile

Concatenate one or more directory names and a filename to form a
complete path ending with a filename

=cut

sub catfile {
    my $self = shift @@_;
    my $file = pop @@_;
    return $self->canonpath($file) unless @@_;
    my $dir = $self->catdir(@@_);
    for ($dir) {
	$_ .= "/" unless substr($_,length($_)-1,1) eq "/";
    }
    return $self->canonpath($dir.$file);
}

=item curdir

Returns a string representing of the current directory.  "." on UNIX.

=cut

sub curdir {
    return "." ;
}

=item rootdir

Returns a string representing of the root directory.  "/" on UNIX.

=cut

sub rootdir {
    return "/";
}

=item updir

Returns a string representing of the parent directory.  ".." on UNIX.

=cut

sub updir {
    return "..";
}

sub ExtUtils::MM_Unix::c_o ;
sub ExtUtils::MM_Unix::clean ;
sub ExtUtils::MM_Unix::const_cccmd ;
sub ExtUtils::MM_Unix::const_config ;
sub ExtUtils::MM_Unix::const_loadlibs ;
sub ExtUtils::MM_Unix::constants ;
sub ExtUtils::MM_Unix::depend ;
sub ExtUtils::MM_Unix::dir_target ;
sub ExtUtils::MM_Unix::dist ;
sub ExtUtils::MM_Unix::dist_basics ;
sub ExtUtils::MM_Unix::dist_ci ;
sub ExtUtils::MM_Unix::dist_core ;
sub ExtUtils::MM_Unix::dist_dir ;
sub ExtUtils::MM_Unix::dist_test ;
sub ExtUtils::MM_Unix::dlsyms ;
sub ExtUtils::MM_Unix::dynamic ;
sub ExtUtils::MM_Unix::dynamic_bs ;
sub ExtUtils::MM_Unix::dynamic_lib ;
sub ExtUtils::MM_Unix::exescan ;
sub ExtUtils::MM_Unix::export_list ;
sub ExtUtils::MM_Unix::extliblist ;
sub ExtUtils::MM_Unix::file_name_is_absolute ;
sub ExtUtils::MM_Unix::find_perl ;
sub ExtUtils::MM_Unix::fixin ;
sub ExtUtils::MM_Unix::force ;
sub ExtUtils::MM_Unix::guess_name ;
sub ExtUtils::MM_Unix::has_link_code ;
sub ExtUtils::MM_Unix::htmlifypods ;
sub ExtUtils::MM_Unix::init_dirscan ;
sub ExtUtils::MM_Unix::init_main ;
sub ExtUtils::MM_Unix::init_others ;
sub ExtUtils::MM_Unix::install ;
sub ExtUtils::MM_Unix::installbin ;
sub ExtUtils::MM_Unix::libscan ;
sub ExtUtils::MM_Unix::linkext ;
sub ExtUtils::MM_Unix::lsdir ;
sub ExtUtils::MM_Unix::macro ;
sub ExtUtils::MM_Unix::makeaperl ;
sub ExtUtils::MM_Unix::makefile ;
sub ExtUtils::MM_Unix::manifypods ;
sub ExtUtils::MM_Unix::maybe_command ;
sub ExtUtils::MM_Unix::maybe_command_in_dirs ;
sub ExtUtils::MM_Unix::needs_linking ;
sub ExtUtils::MM_Unix::nicetext ;
sub ExtUtils::MM_Unix::parse_version ;
sub ExtUtils::MM_Unix::pasthru ;
sub ExtUtils::MM_Unix::path ;
sub ExtUtils::MM_Unix::perl_archive;
sub ExtUtils::MM_Unix::perl_archive_after;
sub ExtUtils::MM_Unix::perl_script ;
sub ExtUtils::MM_Unix::perldepend ;
sub ExtUtils::MM_Unix::pm_to_blib ;
sub ExtUtils::MM_Unix::post_constants ;
sub ExtUtils::MM_Unix::post_initialize ;
sub ExtUtils::MM_Unix::postamble ;
sub ExtUtils::MM_Unix::ppd ;
sub ExtUtils::MM_Unix::prefixify ;
sub ExtUtils::MM_Unix::processPL ;
sub ExtUtils::MM_Unix::realclean ;
sub ExtUtils::MM_Unix::replace_manpage_separator ;
sub ExtUtils::MM_Unix::static ;
sub ExtUtils::MM_Unix::static_lib ;
sub ExtUtils::MM_Unix::staticmake ;
sub ExtUtils::MM_Unix::subdir_x ;
sub ExtUtils::MM_Unix::subdirs ;
sub ExtUtils::MM_Unix::test ;
sub ExtUtils::MM_Unix::test_via_harness ;
sub ExtUtils::MM_Unix::test_via_script ;
sub ExtUtils::MM_Unix::tool_autosplit ;
sub ExtUtils::MM_Unix::tool_xsubpp ;
sub ExtUtils::MM_Unix::tools_other ;
sub ExtUtils::MM_Unix::top_targets ;
sub ExtUtils::MM_Unix::writedoc ;
sub ExtUtils::MM_Unix::xs_c ;
sub ExtUtils::MM_Unix::xs_cpp ;
sub ExtUtils::MM_Unix::xs_o ;
sub ExtUtils::MM_Unix::xsubpp_version ;
d162 1
a162 1
package ExtUtils::MM_Unix;
d164 2
a165 1
use SelfLoader;
d167 1
a167 1
1;
d169 1
a169 3
__DATA__

=back
d188 12
d202 1
a202 1
	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.c
d206 2
a207 2
	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.C
' if $^O ne 'os2' and $^O ne 'MSWin32' and $^O ne 'dos'; #Case-specific
d210 1
a210 1
	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.cpp
d213 1
a213 1
	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.cxx
d216 1
a216 1
	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.cc
d269 1
a269 1
    if ($prog = $Config::Config{$name}) {
d301 1
d305 1
a305 22
	$self->{uc $_} ||= $cflags{$_}
    }

    if ($Is_PERL_OBJECT) {
        $self->{CCFLAGS} =~ s/-DPERL_OBJECT(\b|$)/-DPERL_CAPI/g;
        if ($Is_Win32) { 
	    if ($Config{'cc'} =~ /^cl/i) {
		# Turn off C++ mode of the MSC compiler
		$self->{CCFLAGS} =~ s/-TP(\s|$)//g;
		$self->{OPTIMIZE} =~ s/-TP(\s|$)//g;
	    }
	    elsif ($Config{'cc'} =~ /^bcc32/i) {
		# Turn off C++ mode of the Borland compiler
		$self->{CCFLAGS} =~ s/-P(\s|$)//g;
		$self->{OPTIMIZE} =~ s/-P(\s|$)//g;
	    }
	    elsif ($Config{'cc'} =~ /^gcc/i) {
		# Turn off C++ mode of the GCC compiler
		$self->{CCFLAGS} =~ s/-xc\+\+(\s|$)//g;
		$self->{OPTIMIZE} =~ s/-xc\+\+(\s|$)//g;
	    }
        }
d319 3
d366 7
d374 7
a380 6
    push(@@otherfiles, qw[./blib $(MAKE_APERL_FILE) $(INST_ARCHAUTODIR)/extralibs.all
			 perlmain.c mon.out core core.*perl.*.?
			 *perl.core so_locations pm_to_blib
			 *$(OBJ_EXT) *$(LIB_EXT) perl.exe
			 $(BOOTSTRAP) $(BASEEXT).bso $(BASEEXT).def
			 $(BASEEXT).exp
d382 7
d410 2
a411 1
	q{CCCMD = $(CC) -c $(INC) $(CCFLAGS) $(OPTIMIZE) \\
d434 2
a435 1
	push @@m, "\U$m\E = ".$self->{uc $m}."\n";
d480 10
a489 5
	      VERSION_SYM XS_VERSION INST_BIN INST_EXE INST_LIB
	      INST_ARCHLIB INST_SCRIPT PREFIX  INSTALLDIRS
	      INSTALLPRIVLIB INSTALLARCHLIB INSTALLSITELIB
	      INSTALLSITEARCH INSTALLBIN INSTALLSCRIPT PERL_LIB
	      PERL_ARCHLIB SITELIBEXP SITEARCHEXP LIBPERL_A MYEXTLIB
d491 3
a493 1
	      PERL_INC PERL FULLPERL FULL_AR
d495 2
a496 1
	      / ) {
d498 4
a520 1
# ROOTEXT = Directory part of FULLEXT with leading slash (eg /DBD)  !!! Deprecated from MM 5.32  !!!
d528 2
a529 1
	      /	) {
a539 2
HTMLLIBPODS    = ".join(" \\\n\t", sort keys %{$self->{HTMLLIBPODS}})."
HTMLSCRIPTPODS = ".join(" \\\n\t", sort keys %{$self->{HTMLSCRIPTPODS}})."
d545 6
a550 7
	      INST_HTMLPRIVLIBDIR INSTALLHTMLPRIVLIBDIR
	      INST_HTMLSITELIBDIR INSTALLHTMLSITELIBDIR
	      INST_HTMLSCRIPTDIR  INSTALLHTMLSCRIPTDIR
	      INST_HTMLLIBDIR                    HTMLEXT
	      INST_MAN1DIR        INSTALLMAN1DIR MAN1EXT
	      INST_MAN3DIR        INSTALLMAN3DIR MAN3EXT
	      /) {
d558 2
a559 1
	     ) {
d574 1
a574 1
.SUFFIXES: .xs .c .C .cpp .cxx .cc \$(OBJ_EXT)
d591 2
a592 2
INST_LIBDIR      = }. $self->catdir('$(INST_LIB)',@@parentdir)        .q{
INST_ARCHLIBDIR  = }. $self->catdir('$(INST_ARCHLIB)',@@parentdir)    .q{
d594 2
a595 2
INST_AUTODIR     = }. $self->catdir('$(INST_LIB)','auto','$(FULLEXT)')       .q{
INST_ARCHAUTODIR = }. $self->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)')   .q{
a624 6
#    push @@m, q{
#INST_PM = }.join(" \\\n\t", sort values %{$self->{PM}}).q{
#
#PM_TO_BLIB = }.join(" \\\n\t", %{$self->{PM}}).q{
#};

d645 1
a645 1
	push @@m, "$key: $val\n";
d672 2
a673 2
	my($src) = $self->catfile($self->{PERL_INC},'perl.h');
	my($targ) = $self->catfile($dir,'.exists');
a702 1
    my(@@m);
d704 28
a731 22
    my($version)  = $attribs{VERSION}  || '$(VERSION)';
    my($name)     = $attribs{NAME}     || '$(DISTNAME)';
    my($tar)      = $attribs{TAR}      || 'tar';        # eg /usr/bin/gnutar
    my($tarflags) = $attribs{TARFLAGS} || 'cvf';
    my($zip)      = $attribs{ZIP}      || 'zip';        # eg pkzip Yuck!
    my($zipflags) = $attribs{ZIPFLAGS} || '-r';
    my($compress) = $attribs{COMPRESS} || 'gzip --best';
    my($suffix)   = $attribs{SUFFIX}   || '.gz';          # eg .gz
    my($shar)     = $attribs{SHAR}     || 'shar';       # eg "shar --gzip"
    my($preop)    = $attribs{PREOP}    || "$self->{NOECHO}\$(NOOP)"; # eg update MANIFEST
    my($postop)   = $attribs{POSTOP}   || "$self->{NOECHO}\$(NOOP)"; # eg remove the distdir

    my($to_unix)  = $attribs{TO_UNIX} || ($Is_OS2
					  ? "$self->{NOECHO}"
					  . '$(TEST_F) tmp.zip && $(RM) tmp.zip;'
					  . ' $(ZIP) -ll -mr tmp.zip $(DISTVNAME) && unzip -o tmp.zip && $(RM) tmp.zip'
					  : "$self->{NOECHO}\$(NOOP)");

    my($ci)       = $attribs{CI}       || 'ci -u';
    my($rcs_label)= $attribs{RCS_LABEL}|| 'rcs -Nv$(VERSION_SYM): -q';
    my($dist_cp)  = $attribs{DIST_CP}  || 'best';
    my($dist_default) = $attribs{DIST_DEFAULT} || 'tardist';
d733 1
a733 18
    push @@m, "
DISTVNAME = ${name}-$version
TAR  = $tar
TARFLAGS = $tarflags
ZIP  = $zip
ZIPFLAGS = $zipflags
COMPRESS = $compress
SUFFIX = $suffix
SHAR = $shar
PREOP = $preop
POSTOP = $postop
TO_UNIX = $to_unix
CI = $ci
RCS_LABEL = $rcs_label
DIST_CP = $dist_cp
DIST_DEFAULT = $dist_default
";
    join "", @@m;
d744 2
a745 2
    my @@m;
    push @@m, q{
d747 1
a747 1
};
a748 1
    push @@m, q{
d750 1
a750 3
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=fullcheck \\
		-e fullcheck
};
a751 1
    push @@m, q{
d753 1
a753 3
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=skipcheck \\
		-e skipcheck
};
a754 1
    push @@m, q{
d756 1
a756 3
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=mkmanifest \\
		-e mkmanifest
};
a757 1
    push @@m, q{
d760 3
a762 2
};
    join "", @@m;
d776 1
a776 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=maniread \\
d830 1
a830 1
=item dist_dir (o)
d839 2
a840 2
    my @@m;
    push @@m, q{
d843 1
a843 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=manicopy,maniread \\
d845 3
a847 2
};
    join "", @@m;
d850 1
a850 1
=item dist_test (o)
d863 3
a865 3
	cd $(DISTVNAME) && $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) Makefile.PL
	cd $(DISTVNAME) && $(MAKE)
	cd $(DISTVNAME) && $(MAKE) test
d899 1
a899 1
",'	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e \'use ExtUtils::Mksymlists; \\
d947 2
a948 2
	'.$self->{NOECHO}.'$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" \
		-MExtUtils::Mkbootstrap \
d978 1
d983 1
a983 1
OTHERLDFLAGS = '.$otherldflags.'
d996 2
a997 2
    my $ldrun = qq{-rpath "$self->{LD_RUN_PATH}"}
	if ($^O eq 'irix' && $self->{LD_RUN_PATH});
d1007 19
a1025 2
    push(@@m,'	LD_RUN_PATH="$(LD_RUN_PATH)" $(LD) '.$ldrun.' $(LDDLFLAGS) '.$ldfrom.
		' $(OTHERLDFLAGS) -o $@@ $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)');
a1057 16
=item file_name_is_absolute

Takes as argument a path and returns true, if it is an absolute path.

=cut

sub file_name_is_absolute {
    my($self,$file) = @@_;
    if ($Is_Dos){
        $file =~ m{^([a-z]:)?[\\/]}is ;
    }
    else {
        $file =~ m:^/:s ;
    }
}

d1078 1
a1078 1
	    if ($self->file_name_is_absolute($name)) { # /foo/bar
d1080 2
a1081 2
	    } elsif ($self->canonpath($name) eq $self->canonpath(basename($name))) { # foo
		$abs = $self->catfile($dir, $name);
d1083 1
a1083 1
		$abs = $self->canonpath($self->catfile($self->curdir, $name));
d1101 14
d1126 3
a1128 1
Inserts the sharpbang or equivalent magic number to a script
d1133 4
a1136 4
    my($self,@@files) = @@_;
    my($does_shbang) = $Config::Config{'sharpbang'} =~ /^\s*\#\!/;
    my($file,$interpreter);
    for $file (@@files) {
d1139 1
a1139 1
	open(FIXIN, $file) or Carp::croak "Can't process '$file': $!";
d1148 1
d1157 1
a1157 1
	    my(@@absdirs) = reverse grep {$self->file_name_is_absolute} $self->path;
d1163 1
a1163 1
		    $interpreter = $self->catfile($dir,$cmd);
a1200 8
	# can't rename/chmod open files on some DOSISH platforms

	# If they override perm_rwx, we won't notice it during fixin,
	# because fixin is run through a new instance of MakeMaker.
	# That is why we must run another CHMOD later.
	$mode = oct($self->perm_rwx) unless $dev;
	chmod $mode, $file;

a1215 2
	chmod oct($self->perm_rwx), $file or
	  die "Can't reset permissions for $file: $!\n";
a1272 50
=item htmlifypods (o)

Defines targets and routines to translate the pods into HTML manpages
and put them into the INST_HTMLLIBDIR and INST_HTMLSCRIPTDIR
directories.

=cut

sub htmlifypods {
    my($self, %attribs) = @@_;
    return "\nhtmlifypods : pure_all\n\t$self->{NOECHO}\$(NOOP)\n" unless
	%{$self->{HTMLLIBPODS}} || %{$self->{HTMLSCRIPTPODS}};
    my($dist);
    my($pod2html_exe);
    if (defined $self->{PERL_SRC}) {
	$pod2html_exe = $self->catfile($self->{PERL_SRC},'pod','pod2html');
    } else {
	$pod2html_exe = $self->catfile($Config{scriptdirexp},'pod2html');
    }
    unless ($pod2html_exe = $self->perl_script($pod2html_exe)) {
	# No pod2html but some HTMLxxxPODS to be installed
	print <<END;

Warning: I could not locate your pod2html program. Please make sure,
         your pod2html program is in your PATH before you execute 'make'

END
        $pod2html_exe = "-S pod2html";
    }
    my(@@m);
    push @@m,
qq[POD2HTML_EXE = $pod2html_exe\n],
qq[POD2HTML = \$(PERL) -we 'use File::Basename; use File::Path qw(mkpath); %m=\@@ARGV;for (keys %m){' \\\n],
q[-e 'next if -e $$m{$$_} && -M $$m{$$_} < -M $$_ && -M $$m{$$_} < -M "],
 $self->{MAKEFILE}, q[";' \\
-e 'print "Htmlifying $$m{$$_}\n";' \\
-e '$$dir = dirname($$m{$$_}); mkpath($$dir) unless -d $$dir;' \\
-e 'system(qq[$$^X ].q["-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" $(POD2HTML_EXE) ].qq[$$_>$$m{$$_}])==0 or warn "Couldn\\047t install $$m{$$_}\n";' \\
-e 'chmod(oct($(PERM_RW))), $$m{$$_} or warn "chmod $(PERM_RW) $$m{$$_}: $$!\n";}'
];
    push @@m, "\nhtmlifypods : pure_all ";
    push @@m, join " \\\n\t", keys %{$self->{HTMLLIBPODS}}, keys %{$self->{HTMLSCRIPTPODS}};

    push(@@m,"\n");
    if (%{$self->{HTMLLIBPODS}} || %{$self->{HTMLSCRIPTPODS}}) {
	push @@m, "\t$self->{NOECHO}\$(POD2HTML) \\\n\t";
	push @@m, join " \\\n\t", %{$self->{HTMLLIBPODS}}, %{$self->{HTMLSCRIPTPODS}};
    }
    join('', @@m);
}
d1276 1
a1276 1
Initializes DIR, XS, PM, C, O_FILES, H, PL_FILES, HTML*PODS, MAN*PODS, EXE_FILES.
d1284 10
a1293 3
    @@ignore{qw(Makefile.PL test.pl)} = (1,1);
    $ignore{'makefile.pl'} = 1 if $Is_VMS;
    foreach $name ($self->lsdir($self->curdir)){
d1295 1
a1295 1
	next if $name eq $self->curdir or $name eq $self->updir or $ignore{$name};
d1299 1
a1299 1
	    $dir{$name} = $name if (-f $self->catfile($name,"Makefile.PL"));
d1318 3
a1320 1
	    else { $pm{$name} = $self->catfile('$(INST_LIBDIR)',$name); }
d1322 1
a1322 1
	    $pm{$name} = $self->catfile('$(INST_LIBDIR)',$name);
d1352 3
a1354 1
    $self->{PMLIBDIRS} = ['lib', $self->{BASEEXT}]
d1356 5
d1377 18
a1394 13
	File::Find::find(sub {
	    if (-d $_){
		if ($_ eq "CVS" || $_ eq "RCS"){
		    $File::Find::prune = 1;
		}
		return;
	    }
	    return if /\#/;
	    my($path, $prefix) = ($File::Find::name, '$(INST_LIBDIR)');
	    my($striplibpath,$striplibname);
	    $prefix =  '$(INST_LIB)' if (($striplibpath = $path) =~ s:^(\W*)lib\W:$1:i);
	    ($striplibname,$striplibpath) = fileparse($striplibpath);
	    my($inst) = $self->catfile($prefix,$striplibpath,$striplibname);
d1414 1
a1414 1
    foreach my $man (qw(MAN1 MAN3 HTMLLIB HTMLSCRIPT)) {
d1417 2
a1418 1
	    $pods{$man} = 1 unless $self->{"INST_${man}DIR"} =~ /^(none|\s*)$/;
d1422 1
a1422 1
    if ($pods{MAN1} || $pods{HTMLSCRIPT}) {
a1439 4
		if ($pods{HTMLSCRIPT}) {
		    $self->{HTMLSCRIPTPODS}->{$name} =
		      $self->catfile("\$(INST_HTMLSCRIPTDIR)", basename($name).".\$(HTMLEXT)");
		}
d1442 1
a1442 1
		      $self->catfile("\$(INST_MAN1DIR)", basename($name).".\$(MAN1EXT)");
d1447 1
a1447 1
    if ($pods{MAN3} || $pods{HTMLLIB}) {
d1474 2
a1475 1
	# To force inclusion, just name it "Configure.pod", or override MAN3PODS
d1477 1
a1477 1
	    if ($name =~ /(config|setup).*\.pm/is) {
a1482 4
	    if ($pods{HTMLLIB}) {
		$self->{HTMLLIBPODS}->{$name} =
		  $self->catfile("\$(INST_HTMLLIBDIR)", "$manpagename.\$(HTMLEXT)");
	    }
d1484 1
a1484 1
		$manpagename = $self->catfile(split(/::/,$self->{PARENT_NAME}),$manpagename);
d1489 1
a1489 1
		  $self->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
d1497 6
a1502 4
Initializes NAME, FULLEXT, BASEEXT, PARENT_NAME, DLBASE, PERL_SRC,
PERL_LIB, PERL_ARCHLIB, PERL_INC, INSTALLDIRS, INST_*, INSTALL*,
PREFIX, CONFIG, AR, AR_STATIC_ARGS, LD, OBJ_EXT, LIB_EXT, EXE_EXT, MAP_TARGET,
LIBPERL_A, VERSION_FROM, VERSION, DISTNAME, VERSION_SYM.
a1513 1
    # ROOTEXT = Directory part of FULLEXT with leading /. !!! Deprecated from MM 5.32 !!!
d1518 1
a1518 1
    $self->{FULLEXT} = $self->catdir(split /::/, $self->{NAME});
d1534 1
d1544 1
a1544 7
    ### ROOTEXT deprecated from MM 5.32
###    ($self->{ROOTEXT} =
###     $self->{FULLEXT}) =~ s#/?\Q$self->{BASEEXT}\E$## ;      #eg. /BSD/Foo
###    $self->{ROOTEXT} = ($Is_VMS ? '' : '/') . $self->{ROOTEXT} if $self->{ROOTEXT};


    # --- Initialize PERL_LIB, INST_LIB, PERL_SRC
d1552 6
a1557 1
	foreach $dir ($self->updir(),$self->catdir($self->updir(),$self->updir()),$self->catdir($self->updir(),$self->updir(),$self->updir()),$self->catdir($self->updir(),$self->updir(),$self->updir(),$self->updir())){
d1559 1
a1559 1
		-f $self->catfile($dir,"config.sh")
d1561 1
a1561 1
		-f $self->catfile($dir,"perl.h")
d1563 1
a1563 1
		-f $self->catfile($dir,"lib","Exporter.pm")
d1570 4
d1575 14
a1588 3
	$self->{PERL_LIB}     ||= $self->catdir("$self->{PERL_SRC}","lib");
	$self->{PERL_ARCHLIB} = $self->{PERL_LIB};
	$self->{PERL_INC}     = ($Is_Win32) ? $self->catdir($self->{PERL_LIB},"CORE") : $self->{PERL_SRC};
d1592 1
a1592 1
		-s $self->catfile($self->{PERL_SRC},'cflags')
d1596 1
a1596 1
		-s $self->catfile($self->{PERL_SRC},'perlshr_attr.opt')
d1619 3
a1621 3
	$self->{PERL_LIB}     ||= $Config::Config{privlibexp};
	$self->{PERL_ARCHLIB} ||= $Config::Config{archlibexp};
	$self->{PERL_INC}     = $self->catdir("$self->{PERL_ARCHLIB}","CORE"); # wild guess for now
d1624 1
a1624 1
	if (not -f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h"))
d1630 1
a1630 1
	      $found = $dir, last if -e $self->catdir($dir, "Config.pm");
d1634 1
a1634 1
	      if (-e $self->catdir($inc, "perl.h")) {
d1646 2
a1647 1
	unless (-f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h"))){
a1671 168
    # INST_LIB typically pre-set if building an extension after
    # perl has been built and installed. Setting INST_LIB allows
    # you to build directly into, say $Config::Config{privlibexp}.
    unless ($self->{INST_LIB}){


	##### XXXXX We have to change this nonsense

	if (defined $self->{PERL_SRC} and $self->{INSTALLDIRS} eq "perl") {
	    $self->{INST_LIB} = $self->{INST_ARCHLIB} = $self->{PERL_LIB};
	} else {
	    $self->{INST_LIB} = $self->catdir($self->curdir,"blib","lib");
	}
    }
    $self->{INST_ARCHLIB} ||= $self->catdir($self->curdir,"blib","arch");
    $self->{INST_BIN} ||= $self->catdir($self->curdir,'blib','bin');

    # We need to set up INST_LIBDIR before init_libscan() for VMS
    my @@parentdir = split(/::/, $self->{PARENT_NAME});
    $self->{INST_LIBDIR} = $self->catdir('$(INST_LIB)',@@parentdir);
    $self->{INST_ARCHLIBDIR} = $self->catdir('$(INST_ARCHLIB)',@@parentdir);
    $self->{INST_AUTODIR} = $self->catdir('$(INST_LIB)','auto','$(FULLEXT)');
    $self->{INST_ARCHAUTODIR} = $self->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)');

    # INST_EXE is deprecated, should go away March '97
    $self->{INST_EXE} ||= $self->catdir($self->curdir,'blib','script');
    $self->{INST_SCRIPT} ||= $self->catdir($self->curdir,'blib','script');

    # The user who requests an installation directory explicitly
    # should not have to tell us a architecture installation directory
    # as well. We look if a directory exists that is named after the
    # architecture. If not we take it as a sign that it should be the
    # same as the requested installation directory. Otherwise we take
    # the found one.
    # We do the same thing twice: for privlib/archlib and for sitelib/sitearch
    my($libpair);
    for $libpair ({l=>"privlib", a=>"archlib"}, {l=>"sitelib", a=>"sitearch"}) {
	my $lib = "install$libpair->{l}";
	my $Lib = uc $lib;
	my $Arch = uc "install$libpair->{a}";
	if( $self->{$Lib} && ! $self->{$Arch} ){
	    my($ilib) = $Config{$lib};
	    $ilib = VMS::Filespec::unixify($ilib) if $Is_VMS;

	    $self->prefixify($Arch,$ilib,$self->{$Lib});

	    unless (-d $self->{$Arch}) {
		print STDOUT "Directory $self->{$Arch} not found, thusly\n" if $Verbose;
		$self->{$Arch} = $self->{$Lib};
	    }
	    print STDOUT "Defaulting $Arch to $self->{$Arch}\n" if $Verbose;
	}
    }

    # we have to look at the relation between $Config{prefix} and the
    # requested values. We're going to set the $Config{prefix} part of
    # all the installation path variables to literally $(PREFIX), so
    # the user can still say make PREFIX=foo
    my($configure_prefix) = $Config{'prefix'};
    $configure_prefix = VMS::Filespec::unixify($configure_prefix) if $Is_VMS;
    $self->{PREFIX} ||= $configure_prefix;


    my($install_variable,$search_prefix,$replace_prefix);

    # If the prefix contains perl, Configure shapes the tree as follows:
    #    perlprefix/lib/                INSTALLPRIVLIB
    #    perlprefix/lib/pod/
    #    perlprefix/lib/site_perl/	INSTALLSITELIB
    #    perlprefix/bin/		INSTALLBIN
    #    perlprefix/man/		INSTALLMAN1DIR
    # else
    #    prefix/lib/perl5/		INSTALLPRIVLIB
    #    prefix/lib/perl5/pod/
    #    prefix/lib/perl5/site_perl/	INSTALLSITELIB
    #    prefix/bin/			INSTALLBIN
    #    prefix/lib/perl5/man/		INSTALLMAN1DIR
    #
    # The above results in various kinds of breakage on various
    # platforms, so we cope with it as follows: if prefix/lib/perl5
    # or prefix/lib/perl5/man exist, we'll replace those instead
    # of /prefix/{lib,man}

    $replace_prefix = qq[\$\(PREFIX\)];
    for $install_variable (qw/
			   INSTALLBIN
			   INSTALLSCRIPT
			   /) {
	$self->prefixify($install_variable,$configure_prefix,$replace_prefix);
    }
    my $funkylibdir = $self->catdir($configure_prefix,"lib","perl5");
    $funkylibdir = '' unless -d $funkylibdir;
    $search_prefix = $funkylibdir || $self->catdir($configure_prefix,"lib");
    if ($self->{LIB}) {
	$self->{INSTALLPRIVLIB} = $self->{INSTALLSITELIB} = $self->{LIB};
	$self->{INSTALLARCHLIB} = $self->{INSTALLSITEARCH} = 
	    $self->catdir($self->{LIB},$Config{'archname'});
    }
    else {
	if (-d $self->catdir($self->{PREFIX},"lib","perl5")) {
	    $replace_prefix = $self->catdir(qq[\$\(PREFIX\)],"lib", "perl5");
	}
	else {
	    $replace_prefix = $self->catdir(qq[\$\(PREFIX\)],"lib");
	}
	for $install_variable (qw/
			       INSTALLPRIVLIB
			       INSTALLARCHLIB
			       INSTALLSITELIB
			       INSTALLSITEARCH
			       /)
	{
	    $self->prefixify($install_variable,$search_prefix,$replace_prefix);
	}
    }
    my $funkymandir = $self->catdir($configure_prefix,"lib","perl5","man");
    $funkymandir = '' unless -d $funkymandir;
    $search_prefix = $funkymandir || $self->catdir($configure_prefix,"man");
    if (-d $self->catdir($self->{PREFIX},"lib","perl5", "man")) {
	$replace_prefix = $self->catdir(qq[\$\(PREFIX\)],"lib", "perl5", "man");
    }
    else {
	$replace_prefix = $self->catdir(qq[\$\(PREFIX\)],"man");
    }
    for $install_variable (qw/
			   INSTALLMAN1DIR
			   INSTALLMAN3DIR
			   /)
    {
	$self->prefixify($install_variable,$search_prefix,$replace_prefix);
    }

    # Now we head at the manpages. Maybe they DO NOT want manpages
    # installed
    $self->{INSTALLMAN1DIR} = $Config::Config{installman1dir}
	unless defined $self->{INSTALLMAN1DIR};
    unless (defined $self->{INST_MAN1DIR}){
	if ($self->{INSTALLMAN1DIR} =~ /^(none|\s*)$/){
	    $self->{INST_MAN1DIR} = $self->{INSTALLMAN1DIR};
	} else {
	    $self->{INST_MAN1DIR} = $self->catdir($self->curdir,'blib','man1');
	}
    }
    $self->{MAN1EXT} ||= $Config::Config{man1ext};

    $self->{INSTALLMAN3DIR} = $Config::Config{installman3dir}
	unless defined $self->{INSTALLMAN3DIR};
    unless (defined $self->{INST_MAN3DIR}){
	if ($self->{INSTALLMAN3DIR} =~ /^(none|\s*)$/){
	    $self->{INST_MAN3DIR} = $self->{INSTALLMAN3DIR};
	} else {
	    $self->{INST_MAN3DIR} = $self->catdir($self->curdir,'blib','man3');
	}
    }
    $self->{MAN3EXT} ||= $Config::Config{man3ext};

    $self->{INSTALLHTMLPRIVLIBDIR} = $Config::Config{installhtmlprivlibdir}
        unless defined $self->{INSTALLHTMLPRIVLIBDIR};
    $self->{INSTALLHTMLSITELIBDIR} = $Config::Config{installhtmlsitelibdir}
        unless defined $self->{INSTALLHTMLSITELIBDIR};

    unless (defined $self->{INST_HTMLLIBDIR}){
	if ($self->{INSTALLHTMLSITELIBDIR} =~ /^(none|\s*)$/){
	    $self->{INST_HTMLLIBDIR} = $self->{INSTALLHTMLSITELIBDIR};
	} else {
	    $self->{INST_HTMLLIBDIR} = $self->catdir($self->curdir,'blib','html','lib');
	}
    }
d1673 2
a1674 10
    $self->{INSTALLHTMLSCRIPTDIR} = $Config::Config{installhtmlscriptdir}
        unless defined $self->{INSTALLHTMLSCRIPTDIR};
    unless (defined $self->{INST_HTMLSCRIPTDIR}){
	if ($self->{INSTALLHTMLSCRIPTDIR} =~ /^(none|\s*)$/){
	    $self->{INST_HTMLSCRIPTDIR} = $self->{INSTALLHTMLSCRIPTDIR};
	} else {
	    $self->{INST_HTMLSCRIPTDIR} = $self->catdir($self->curdir,'blib','html','bin');
	}
    }
    $self->{HTMLEXT} ||= $Config::Config{htmlext} || 'html';
d1676 2
d1684 1
a1684 1
    push(@@{$self->{CONFIG}}, 'shellflags') if $Config::Config{shellflags};
d1689 2
a1690 2
		unless exists $Config::Config{$m};
	$self->{uc $m} ||= $Config::Config{$m};
d1715 1
a1715 1
	unless -f $self->catfile("$self->{PERL_LIB}","Exporter.pm") ||
d1721 5
a1725 2
	$self->{VERSION} = $self->parse_version($self->{VERSION_FROM}) or
	    Carp::carp "WARNING: Setting VERSION via file '$self->{VERSION_FROM}' failed\n"
d1729 1
a1729 1
    if ($self->{VERSION}) {
d1733 3
a1735 2

    $self->{VERSION} ||= "0.10";
d1738 1
d1746 1
d1748 1
a1748 18

    # Find Perl 5. The only contract here is that both 'PERL' and 'FULLPERL'
    # will be working versions of perl 5. miniperl has priority over perl
    # for PERL to ensure that $(PERL) is usable while building ./ext/*
    my ($component,@@defpath);
    foreach $component ($self->{PERL_SRC}, $self->path(), $Config::Config{binexp}) {
	push @@defpath, $component if defined $component;
    }
    $self->{PERL} ||=
        $self->find_perl(5.0, [ $self->canonpath($^X), 'miniperl',
				'perl','perl5',"perl$Config{version}" ],
	    \@@defpath, $Verbose );
    # don't check if perl is executable, maybe they have decided to
    # supply switches with perl

    # Define 'FULLPERL' to be a non-miniperl (used in test: target)
    ($self->{FULLPERL} = $self->{PERL}) =~ s/miniperl/perl/i
	unless ($self->{FULLPERL});
d1777 2
a1778 1
	    ($self->{EXTRALIBS}, $self->{BSLOADLIBS}, $self->{LDLOADLIBS}, $self->{LD_RUN_PATH}) = @@libs;
d1802 1
a1802 1
                        : ($Config::Config{usedl} ? 'dynamic' : 'static');
d1822 3
a1824 1
=item install (o)
d1826 1
a1826 1
Defines the install target.
d1830 32
a1861 3
sub install {
    my($self, %attribs) = @@_;
    my(@@m);
d1863 1
a1863 2
    push @@m, q{
install :: all pure_install doc_install
d1865 2
a1866 1
install_perl :: all pure_perl_install doc_perl_install
d1868 2
a1869 1
install_site :: all pure_site_install doc_site_install
d1871 1
a1871 2
install_ :: install_site
	@@echo INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
d1873 1
a1873 1
pure_install :: pure_$(INSTALLDIRS)_install
d1875 2
a1876 2
doc_install :: doc_$(INSTALLDIRS)_install
	}.$self->{NOECHO}.q{echo Appending installation info to $(INSTALLARCHLIB)/perllocal.pod
d1878 1
a1878 2
pure__install : pure_site_install
	@@echo INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
d1880 2
a1881 2
doc__install : doc_site_install
	@@echo INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
d1883 370
a2252 14
pure_perl_install ::
	}.$self->{NOECHO}.q{$(MOD_INSTALL) \
		read }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		write }.$self->catfile('$(INSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(INSTALLPRIVLIB) \
		$(INST_ARCHLIB) $(INSTALLARCHLIB) \
		$(INST_BIN) $(INSTALLBIN) \
		$(INST_SCRIPT) $(INSTALLSCRIPT) \
		$(INST_HTMLLIBDIR) $(INSTALLHTMLPRIVLIBDIR) \
		$(INST_HTMLSCRIPTDIR) $(INSTALLHTMLSCRIPTDIR) \
		$(INST_MAN1DIR) $(INSTALLMAN1DIR) \
		$(INST_MAN3DIR) $(INSTALLMAN3DIR)
	}.$self->{NOECHO}.q{$(WARN_IF_OLD_PACKLIST) \
		}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{
d2257 2
a2258 2
		read }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
		write }.$self->catfile('$(INSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{ \
d2261 1
a2261 1
		$(INST_BIN) $(INSTALLBIN) \
d2263 2
a2264 4
		$(INST_HTMLLIBDIR) $(INSTALLHTMLSITELIBDIR) \
		$(INST_HTMLSCRIPTDIR) $(INSTALLHTMLSCRIPTDIR) \
		$(INST_MAN1DIR) $(INSTALLMAN1DIR) \
		$(INST_MAN3DIR) $(INSTALLMAN3DIR)
d2266 10
a2275 1
		}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{
d2285 1
a2285 1
		>> }.$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q{
d2295 3
a2297 1
		>> }.$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q{
d2306 1
a2306 1
	q{$(UNINSTALL) }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{
d2310 1
a2310 1
	q{$(UNINSTALL) }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{
d2329 1
a2329 1
	my($path)= $self->catfile('$(INST_SCRIPT)', basename($from));
d2340 2
a2341 3
  ? q{FIXIN = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) \
    -e "system qq[pl2bat.bat ].shift"
} : q{FIXIN = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::MakeMaker \
d2355 1
a2355 1
$to: $from $self->{MAKEFILE} " . $self->catdir($todir,'.exists') . "
d2466 1
a2466 1
	}.$self->{NOECHO}.q{$(PERL) -I$(INST_ARCHLIB) -I$(INST_LIB) -I$(PERL_ARCHLIB) -I$(PERL_LIB) \
d2490 3
a2492 3
    $cccmd =~ s/\$\(INC\)/ -I$self->{PERL_INC} /;
    $cccmd .= " $Config::Config{cccdlflags}"
	if ($Config::Config{useshrplib} eq 'true');
d2566 1
a2566 1
    grep(s/^/-I/, @@{$perlinc || []});
d2568 2
a2569 2
    $target = "perl" unless $target;
    $tmp = "." unless $tmp;
d2580 1
a2580 1
MAP_PRELIBS   = $Config::Config{perllibs} $Config::Config{cryptlib}
d2597 1
a2597 1
            $lperl  = $libperl = "$dir/$Config::Config{libperl}";
d2609 3
d2614 1
a2626 2
    # SUNOS ld does not take the full path to a shared library
    my $llibperl = ($libperl)?'$(MAP_LIBPERL)':'-lperl';
d2630 1
a2630 1
	\$(MAP_LINKCMD) -o \$\@@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) \$(LDFROM) \$(MAP_STATIC) $llibperl `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
d2638 1
a2638 1
    push @@m, "\tcd $tmp && $cccmd -I\$(PERL_INC) perlmain.c\n";
d2643 1
a2643 1
	}.$self->{NOECHO}.q{$(PERL) $(MAP_PERLINC) -MExtUtils::Miniperl \\
d2660 1
a2660 1
		>> }.$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q{
d2668 1
a2668 1
	}.$self->{CP}.q{ $(MAP_TARGET) }.$self->catfile('$(INSTALLBIN)','$(MAP_TARGET)').q{
d2704 1
a2704 1
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" Makefile.PL }.join(" ",map(qq["$_"],@@ARGV)).q{
a2708 4
# To change behavior to :: would be nice, but would break Tk b9.02
# so you find such a warning below the dist target.
#}.$self->{MAKEFILE}.q{ :: $(VERSION_FROM)
#	}.$self->{NOECHO}.q{echo "Warning: Makefile possibly out of date with $(VERSION_FROM)"
d2728 1
a2728 1
	$pod2man_exe = $self->catfile($self->{PERL_SRC},'pod','pod2man');
d2730 1
a2730 1
	$pod2man_exe = $self->catfile($Config{scriptdirexp},'pod2man');
d2734 1
a2734 1
      $pod2man_exe = $self->catfile($self->{PERL_INC}, "pod", "pod2man");
d2753 2
a2754 2
-e 'system(qq[$$^X ].q["-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" $(POD2MAN_EXE) ].qq[$$_>$$m{$$_}])==0 or warn "Couldn\\047t install $$m{$$_}\n";' \\
-e 'chmod(oct($(PERM_RW))), $$m{$$_} or warn "chmod $(PERM_RW) $$m{$$_}: $$!\n";}'
d2793 1
a2793 1
	    if ($self->file_name_is_absolute($name)) { # /foo/bar
d2795 2
a2796 2
	    } elsif ($self->canonpath($name) eq $self->canonpath(basename($name))) { # bar
		$abs = $self->catfile($dir, $name);
d2798 1
a2798 1
		$abs = $self->catfile($self->curdir, $name);
d2829 2
a2830 1
    Carp::confess("Needs_linking called too early") if $caller =~ /^ExtUtils::MakeMaker::/;
d2862 27
d2893 2
a2894 1
is.
d2907 1
a2907 1
	next if $inpod;
d2920 1
a2920 1
	no warnings;
a2922 1
	$result = "undef" unless defined $result;
d2926 2
a2930 26
=item parse_abstract

parse a file and return what you think is the ABSTRACT

=cut

sub parse_abstract {
    my($self,$parsefile) = @@_;
    my $result;
    local *FH;
    local $/ = "\n";
    open(FH,$parsefile) or die "Could not open '$parsefile': $!";
    my $inpod = 0;
    my $package = $self->{DISTNAME};
    $package =~ s/-/::/g;
    while (<FH>) {
        $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
        next if !$inpod;
        chop;
        next unless /^($package\s-\s)(.*)/;
        $result = $2;
        last;
    }
    close FH;
    return $result;
}
d2947 1
a2947 1
    foreach $key (qw(LIB LIBPERL_A LINKTYPE PREFIX OPTIMIZE)){
d2951 4
a2958 16
=item path

Takes no argument, returns the environment variable PATH as an array.

=cut

sub path {
    my($self) = @@_;
    my $path_sep = ($Is_OS2 || $Is_Dos) ? ";" : ":";
    my $path = $ENV{PATH};
    $path =~ s:\\:/:g if $Is_OS2;
    my @@path = split $path_sep, $path;
    foreach(@@path) { $_ = '.' if $_ eq '' }
    @@path;
}

a3019 1
	$(PERL_INC)/objXSUB.h		\
a3053 55
=item ppd

Defines target that creates a PPD (Perl Package Description) file
for a binary distribution.

=cut

sub ppd {
    my($self) = @@_;
    my(@@m);
    if ($self->{ABSTRACT_FROM}){
        $self->{ABSTRACT} = $self->parse_abstract($self->{ABSTRACT_FROM}) or
            Carp::carp "WARNING: Setting ABSTRACT via file '$self->{ABSTRACT_FROM}' failed\n";
    }
    my ($pack_ver) = join ",", (split (/\./, $self->{VERSION}), (0) x 4) [0 .. 3];
    push(@@m, "# Creates a PPD (Perl Package Description) for a binary distribution.\n");
    push(@@m, "ppd:\n");
    push(@@m, "\t\@@\$(PERL) -e \"print qq{<SOFTPKG NAME=\\\"$self->{DISTNAME}\\\" VERSION=\\\"$pack_ver\\\">\\n}");
    push(@@m, ". qq{\\t<TITLE>$self->{DISTNAME}</TITLE>\\n}");
    my $abstract = $self->{ABSTRACT};
    $abstract =~ s/\n/\\n/sg;
    $abstract =~ s/</&lt;/g;
    $abstract =~ s/>/&gt;/g;
    push(@@m, ". qq{\\t<ABSTRACT>$abstract</ABSTRACT>\\n}");
    my ($author) = $self->{AUTHOR};
    $author =~ s/</&lt;/g;
    $author =~ s/>/&gt;/g;
    $author =~ s/@@/\\@@/g;
    push(@@m, ". qq{\\t<AUTHOR>$author</AUTHOR>\\n}");
    push(@@m, ". qq{\\t<IMPLEMENTATION>\\n}");
    my ($prereq);
    foreach $prereq (sort keys %{$self->{PREREQ_PM}}) {
        my $pre_req = $prereq;
        $pre_req =~ s/::/-/g;
        my ($dep_ver) = join ",", (split (/\./, $self->{PREREQ_PM}{$prereq}), (0) x 4) [0 .. 3];
        push(@@m, ". qq{\\t\\t<DEPENDENCY NAME=\\\"$pre_req\\\" VERSION=\\\"$dep_ver\\\" />\\n}");
    }
    push(@@m, ". qq{\\t\\t<OS NAME=\\\"\$(OSNAME)\\\" />\\n}");
    push(@@m, ". qq{\\t\\t<ARCHITECTURE NAME=\\\"$Config{'archname'}\\\" />\\n}");
    my ($bin_location) = $self->{BINARY_LOCATION};
    $bin_location =~ s/\\/\\\\/g;
    if ($self->{PPM_INSTALL_SCRIPT}) {
        if ($self->{PPM_INSTALL_EXEC}) {
            push(@@m, " . qq{\\t\\t<INSTALL EXEC=\\\"$self->{PPM_INSTALL_EXEC}\\\">$self->{PPM_INSTALL_SCRIPT}</INSTALL>\\n}");
        }
        else {
            push(@@m, " . qq{\\t\\t<INSTALL>$self->{PPM_INSTALL_SCRIPT}</INSTALL>\\n}");
        }
    }
    push(@@m, ". qq{\\t\\t<CODEBASE HREF=\\\"$bin_location\\\" />\\n}");
    push(@@m, ". qq{\\t</IMPLEMENTATION>\\n}");
    push(@@m, ". qq{</SOFTPKG>\\n}\" > $self->{DISTNAME}.ppd");

    join("", @@m);   
}
d3091 10
d3103 2
a3104 2
    my($autodir) = $self->catdir('$(INST_LIB)','auto');
    return q{
a3105 4
	}.$self->{NOECHO}.q{$(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" \
	"-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -MExtUtils::Install \
        -e "pm_to_blib({qw{$(PM_TO_BLIB)}},'}.$autodir.q{','$(PM_FILTER)')"
	}.$self->{NOECHO}.q{$(TOUCH) $@@
d3107 14
d3159 76
d3237 1
a3237 2
Check a path variable in $self from %Config, if it contains a prefix,
and replace it with another one.
d3239 15
a3253 2
Takes as arguments an attribute name, a search prefix and a
replacement prefix. Changes the attribute in the object.
d3258 18
a3275 4
    my($self,$var,$sprefix,$rprefix) = @@_;
    $self->{uc $var} ||= $Config{lc $var};
    $self->{uc $var} = VMS::Filespec::unixpath($self->{uc $var}) if $Is_VMS;
    $self->{uc $var} =~ s,^\Q$sprefix\E(?=/|\z),$rprefix,s;
d3278 1
d3300 1
a3300 1
	\$(PERL) -I\$(INST_ARCHLIB) -I\$(INST_LIB) -I\$(PERL_ARCHLIB) -I\$(PERL_LIB) $plfile $target
d3307 16
d3332 1
d3338 14
a3351 3
    my $sub = ($Is_Win32  &&  Win32::IsWin95()) ?
      "\tcd %s\n\t\$(TEST_F) %s\n\t\$(MAKE) %s realclean\n\tcd ..\n" :
      "\t-cd %s && \$(TEST_F) %s && \$(MAKE) %s realclean\n";
d3357 1
d3388 2
d3391 2
a3392 1
form Foo/Bar and replaces the slash with C<::>. Returns the replacement.
d3398 3
a3400 8
	if ($^O eq 'uwin') {
	    $man =~ s,/+,.,g;
	} elsif ($Is_Dos) {
	    $man =~ s,/+,__,g;
	} else {
	    $man =~ s,/+,::,g;
	}
    $man;
d3440 1
a3440 1
    # If this extension has it's own library (eg SDBM_File)
d3483 1
a3483 1
	@@static = $self->catfile($self->{INST_ARCHLIB},
d3520 3
a3522 2
	# XXX: dmake-specific, like rest of Win95 port
	return <<EOT;
d3526 1
a3526 1
	\$(MAKE) all \$(PASTHRU)
d3530 10
a3539 2
    }
    else {
d3543 1
a3543 2
	$self->{NOECHO}cd $subdir && \$(MAKE) all \$(PASTHRU)

d3587 1
a3587 1
    my $tests = $attribs{TESTS};
d3589 1
a3589 1
	$tests = $Is_Win32 ? join(' ', <t\\*.t>) : 't/*.t';
d3604 8
a3611 2
    push(@@m, map("\t$self->{NOECHO}cd $_ && \$(TEST_F) $self->{MAKEFILE} && \$(MAKE) test \$(PASTHRU)\n",
		 @@{$self->{DIR}}));
d3617 4
a3620 2
    push(@@m, $self->test_via_harness('$(FULLPERL)', '$(TEST_FILES)')) if $tests;
    push(@@m, $self->test_via_script('$(FULLPERL)', '$(TEST_FILE)')) if -f "test.pl";
d3624 2
a3625 1
    push(@@m, $self->test_via_script('$(FULLPERL) $(TESTDB_SW)', '$(TEST_FILE)'));
d3646 1
a3646 1
=item test_via_harness (o)
d3648 2
a3649 1
Helper method to write the test targets
d3655 1
a3655 2
    $perl = "PERL_DL_NONLAZY=1 $perl" unless $Is_Win32;
    "\t$perl".q! -I$(INST_ARCHLIB) -I$(INST_LIB) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -e 'use Test::Harness qw(&runtests $$verbose); $$verbose=$(TEST_VERBOSE); runtests @@ARGV;' !."$tests\n";
d3658 1
a3658 1
=item test_via_script (o)
d3660 1
a3660 1
Other helper method for test.
d3666 1
a3666 3
    $perl = "PERL_DL_NONLAZY=1 $perl" unless $Is_Win32;
    qq{\t$perl}.q{ -I$(INST_ARCHLIB) -I$(INST_LIB) -I$(PERL_ARCHLIB) -I$(PERL_LIB) }.qq{$script
};
a3676 2
# --- Tool Sections ---

d3679 3
a3681 2
    $asl = "\$AutoSplit::Maxlen=$attribs{MAXLEN};" if $attribs{MAXLEN};
    q{
d3683 4
a3686 2
AUTOSPLITFILE = $(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e 'use AutoSplit;}.$asl.q{autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1) ;'
};
d3712 1
a3712 1
MKPATH = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e mkpath
d3718 1
a3718 1
EQUALIZE_TIMESTAMP = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e eqtime
d3735 1
a3735 1
MOD_INSTALL = $(PERL) -I$(INST_LIB) -I$(PERL_LIB) -MExtUtils::Install \
d3744 1
a3744 1
UNINSTALL =   $(PERL) -MExtUtils::Install \
d3762 2
a3763 2
    my($xsdir)  = $self->catdir($self->{PERL_LIB},"ExtUtils");
    my(@@tmdeps) = $self->catdir('$(XSUBPPDIR)','typemap');
d3782 1
a3782 1
    my $xsubpp_version = $self->xsubpp_version($self->catfile($xsdir,"xsubpp"));
d3806 1
d3823 1
a3823 1
    my $command = "$self->{PERL} -I$self->{PERL_LIB} $xsubpp -v 2>&1";
a3875 3
    push @@m, '
#all ::	config $(INST_PM) subdirs linkext manifypods
';
d3878 1
a3878 1
all :: pure_all htmlifypods manifypods
a3901 18
    if (%{$self->{HTMLLIBPODS}}) {
	push @@m, qq[
config :: \$(INST_HTMLLIBDIR)/.exists
	$self->{NOECHO}\$(NOOP)

];
	push @@m, $self->dir_target(qw[$(INST_HTMLLIBDIR)]);
    }

    if (%{$self->{HTMLSCRIPTPODS}}) {
	push @@m, qq[
config :: \$(INST_HTMLSCRIPTDIR)/.exists
	$self->{NOECHO}\$(NOOP)

];
	push @@m, $self->dir_target(qw[$(INST_HTMLSCRIPTDIR)]);
    }

a3927 7
    push @@m, q{
Version_check:
	}.$self->{NOECHO}.q{$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) \
		-MExtUtils::MakeMaker=Version_check \
		-e "Version_check('$(MM_VERSION)')"
};

d3957 1
a3957 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
d3972 1
a3972 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.cpp
d3988 2
a3989 2
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.c
d3996 2
a3997 2
to be linked to dynamic extensions. UNIX does not have one but OS2
and Win32 do.
a4002 1
 return '$(PERL_INC)' . "/$Config{libperl}" if $^O eq "beos";
@


1.8
log
@Insure detection of prefixes is limited to whole words. This avoids
recognizing /usr/libdata as /usr/lib.

Ok millert@@
@
text
@d11 2
a12 2
$VERSION = substr q$Revision: 1.7 $, 10;
# $Id: MM_Unix.pm,v 1.7 2000/04/06 17:06:28 millert Exp $
d211 1
d309 2
a310 2
    @@cflags{qw(cc ccflags optimize large split shellflags)}
	= @@Config{qw(cc ccflags optimize large split shellflags)};
a344 2
	  large=\"$cflags{large}\"
	  split=\"$cflags{'split'}\"
a350 2
	  echo large=\$large
	  echo split=\$split
d368 1
a368 1
    for (qw(ccflags optimize perltype large split)) {
a410 2
LARGE = $self->{LARGE}
SPLIT = $self->{SPLIT}
d455 1
a455 1
			 *~ */*~ */*/*~ *$(OBJ_EXT) *$(LIB_EXT) perl.exe
d481 1
a481 1
	$(PERLTYPE) $(LARGE) $(SPLIT) $(MPOLLUTE) $(DEFINE_VERSION) \\
d584 1
a584 1
	      LDFROM LINKTYPE
d678 4
d814 1
a814 1
Defines the targets distclean, distcheck, skipcheck, manifest.
d842 5
d1069 1
a1069 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)/.exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
d1078 3
a1080 5
    # Brain dead solaris linker does not use LD_RUN_PATH?
    # This fixes dynamic extensions which need shared libs
    my $ldrun = '';
    $ldrun = join ' ', map "-R$_", split /:/, $self->{LD_RUN_PATH}
       if ($^O eq 'solaris');
d1082 7
a1088 3
    # The IRIX linker also doesn't use LD_RUN_PATH
    $ldrun = qq{-rpath "$self->{LD_RUN_PATH}"}
	if ($^O eq 'irix' && $self->{LD_RUN_PATH});
d1090 2
a1091 2
    push(@@m,'	LD_RUN_PATH="$(LD_RUN_PATH)" $(LD) -o $@@ '.$ldrun.' $(LDDLFLAGS) '.$ldfrom.
		' $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) $(EXPORT_LIST)');
d1156 3
a1158 3
    foreach $dir (@@$dirs){
	next unless defined $dir; # $self->{PERL_SRC} may be undefined
	foreach $name (@@$names){
a1257 5
	# If they override perm_rwx, we won't notice it during fixin,
	# because fixin is run through a new instance of MakeMaker.
	# That is why we must run another CHMOD later.
	$mode = oct($self->perm_rwx) unless $dev;
	chmod $mode, $file;
d1265 9
a1273 1
	# can't rename open files on some DOSISH platforms
d1288 1
d1666 1
a1666 1
	foreach $dir ($self->updir(),$self->catdir($self->updir(),$self->updir()),$self->catdir($self->updir(),$self->updir(),$self->updir())){
d2380 1
a2380 1
	    grep($_, @@Config{qw(large split ldflags ccdlflags)});
d2463 1
a2463 1
MAP_PRELIBS   = $Config::Config{libs} $Config::Config{cryptlib}
d2471 1
a2508 5
    # Brain dead solaris linker does not use LD_RUN_PATH?
    # This fixes dynamic extensions which need shared libs
    my $ldfrom = ($^O eq 'solaris')?
           join(' ', map "-R$_", split /:/, $self->{LD_RUN_PATH}):'';

d2511 1
a2511 1
	\$(MAP_LINKCMD) -o \$\@@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) $ldfrom \$(MAP_STATIC) $llibperl `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
d3047 1
a3047 1
        -e "pm_to_blib({qw{$(PM_TO_BLIB)}},'}.$autodir.q{')"
d3102 1
a3102 1
    $self->{uc $var} =~ s/\w\Q$sprefix\E\w/$rprefix/s;
d3119 1
d3159 16
a3174 2
    push(@@m, "	$self->{RM_F} " . join(" ", values %{$self->{PM}}) . "\n")
	if keys %{$self->{PM}};
d3193 3
a3195 1
		$man =~ s,/+,.,g;
d3197 1
a3197 1
		$man =~ s,/+,::,g;
d3516 1
a3516 1
VERBINST=1
d3522 1
a3522 1
-e 'print "=head2 ", scalar(localtime), ": C<", shift, ">", " L<", shift, ">";' \
d3814 15
@


1.7
log
@perl-5.6.0 + local changes
@
text
@d11 2
a12 2
$VERSION = substr q$Revision: 1.12603 $, 10;
# $Id: MM_Unix.pm,v 1.126 1998/06/28 21:32:49 k Exp k $
d3096 1
a3096 1
    $self->{uc $var} =~ s/\Q$sprefix\E/$rprefix/s;
@


1.6
log
@o kill colon-separated paths in *libexp, they confuse too many modules
o kill MakeMaker hack (no longer needed)
o define APPLLIB_EXP to be /usr/local/libdata/perl5 to let users
  override standard modules if they want

The perl search path in @@INC is now:
/usr/local/libdata/perl5
/usr/libdata/perl5/i386-openbsd/5.00503
/usr/libdata/perl5
/usr/local/libdata/perl5/site_perl/i386-openbsd
/usr/local/libdata/perl5/site_perl
.
@
text
@d11 2
a12 2
$VERSION = substr q$Revision: 1.4 $, 10;
# $Id: MM_Unix.pm,v 1.4 1999/04/29 22:51:51 millert Exp $
d14 1
a14 2
Exporter::import('ExtUtils::MakeMaker',
	qw( $Verbose &neatvalue));
d83 1
a83 1
    if ( $^O eq 'qnx' && $path =~ s|^(//\d+)/|/| ) {
d88 2
a89 2
    $path =~ s|^(\./)+|| unless $path eq "./";     # ./xx      -> xx
    $path =~ s|(?<=[^/])/$|| ;                     # xx/       -> xx
d190 1
d378 18
a395 7
    if ($self->{CAPI} && $Is_PERL_OBJECT) {
        $self->{CCFLAGS} =~ s/-DPERL_OBJECT(\s|$)//;
        $self->{CCFLAGS} .= ' -DPERL_CAPI ';
        if ($Is_Win32 && $Config{'cc'} =~ /^cl.exe/i) {
            # Turn off C++ mode of the MSC compiler
            $self->{CCFLAGS} =~ s/-TP(\s|$)//;
            $self->{OPTIMIZE} =~ s/-TP(\s|$)//;
d398 12
d416 1
d440 13
a452 1
	push @@m, "\t-cd $dir && \$(TEST_F) $self->{MAKEFILE} && \$(MAKE) clean\n";
d458 2
a459 1
			 perlmain.c mon.out core so_locations pm_to_blib
d486 1
a486 1
	$(PERLTYPE) $(LARGE) $(SPLIT) $(DEFINE_VERSION) \\
d559 1
a559 1
	      PERL_INC PERL FULLPERL
d571 1
d601 2
d608 6
a613 1
	      INST_MAN1DIR INSTALLMAN1DIR MAN1EXT INST_MAN3DIR INSTALLMAN3DIR MAN3EXT
d741 1
a741 1
	    ($targdir = $targ) =~ s:/?\.exists$::;
d1127 1
a1127 1
        $file =~ m{^([a-z]:)?[\\/]}i ;
d1130 1
a1130 1
        $file =~ m:^/: ;
d1313 1
a1313 1
    $name =~ s|[\-_][\d\.\-]+$||;   # this is new with MM 5.00, we
d1338 51
d1391 1
a1391 1
Initializes DIR, XS, PM, C, O_FILES, H, PL_FILES, MAN*PODS, EXE_FILES.
d1408 2
a1409 2
	} elsif ($name =~ /\.xs$/){
	    my($c); ($c = $name) =~ s/\.xs$/.c/;
d1412 1
a1412 1
	} elsif ($name =~ /\.c(pp|xx|c)?$/i){  # .c .C .cpp .cxx .cc
d1415 1
a1415 1
	} elsif ($name =~ /\.h$/i){
d1417 5
a1421 3
	} elsif ($name =~ /\.PL$/) {
	    ($pl_files{$name} = $name) =~ s/\.PL$// ;
	} elsif ($Is_VMS && $name =~ /\.pl$/) {  # case-insensitive filesystem
d1424 1
a1424 1
		($pl_files{$name} = $name) =~ s/\.pl$// ;
d1427 1
a1427 1
	} elsif ($name =~ /\.(p[ml]|pod)$/){
d1502 1
a1502 1
    $self->{O_FILES} = [grep s/\.c(pp|xx|c)?$/$self->{OBJ_EXT}/i, @@o_files] ;
d1507 9
a1515 5
    if ($self->{MAN1PODS}) {
    } elsif ( $self->{INST_MAN1DIR} =~ /^(none|\s*)$/ ) {
    	$self->{MAN1PODS} = {};
    } else {
	my %manifypods = ();
a1517 2
#		use FileHandle ();
#		my $fh = new FileHandle;
a1519 1
#		if ($fh->open("<$name")) {
a1520 1
#		    while (<$fh>) {
a1526 1
#		    $fh->close;
d1532 8
a1539 4
		if( $ispod ) {
		    $manifypods{$name} =
			$self->catfile('$(INST_MAN1DIR)',
				       basename($name).'.$(MAN1EXT)');
a1542 1
	$self->{MAN1PODS} = \%manifypods;
d1544 1
a1544 4
    if ($self->{MAN3PODS}) {
    } elsif ( $self->{INST_MAN3DIR} =~ /^(none|\s*)$/ ) {
    	$self->{MAN3PODS} = {};
    } else {
d1548 1
a1548 1
	    if ($name =~ /\.pod$/ ) {
d1550 1
a1550 3
	    } elsif ($name =~ /\.p[ml]$/ ) {
#		use FileHandle ();
#		my $fh = new FileHandle;
a1552 1
#		$fh->open("<$name");
a1553 1
		    #		while (<$fh>) {
a1559 1
		    #		$fh->close;
d1573 1
a1573 1
	    if ($name =~ /(config|setup).*\.pm/i) {
d1578 6
a1583 1
	    unless ($manpagename =~ s!^\W*lib\W+!!) { # everything below lib is ok
d1586 5
a1590 3
	    $manpagename =~ s/\.p(od|m|l)$//;
	    $manpagename = $self->replace_manpage_separator($manpagename);
	    $manifypods{$name} = $self->catfile("\$(INST_MAN3DIR)","$manpagename.\$(MAN3EXT)");
a1591 1
	$self->{MAN3PODS} = \%manifypods;
d1632 1
a1632 1
    ($self->{PARENT_NAME}, $self->{BASEEXT}) = $self->{NAME} =~ m!(?:([\w:]+)::)?(\w+)$! ;
d1702 1
d1707 23
d1820 1
a1820 2
    # The rule, taken from Configure, is that if prefix contains perl,
    # we shape the tree
d1832 5
d1845 3
a1847 3
    $search_prefix = $configure_prefix =~ /perl/ ?
	$self->catdir($configure_prefix,"lib") :
	$self->catdir($configure_prefix,"lib","perl5");
d1852 8
a1859 4
    } else {
	$replace_prefix = $self->{PREFIX} =~ /perl/ ? 
	    $self->catdir(qq[\$\(PREFIX\)],"lib") :
		$self->catdir(qq[\$\(PREFIX\)],"lib","perl5");
d1865 2
a1866 1
			       /) {
d1870 9
a1878 6
    $search_prefix = $configure_prefix =~ /perl/ ?
	$self->catdir($configure_prefix,"man") :
	    $self->catdir($configure_prefix,"lib","perl5","man");
    $replace_prefix = $self->{PREFIX} =~ /perl/ ? 
	$self->catdir(qq[\$\(PREFIX\)],"man") :
	    $self->catdir(qq[\$\(PREFIX\)],"lib","perl5","man");
d1882 2
a1883 1
			   /) {
d1911 24
d2008 2
a2009 1
        $self->find_perl(5.0, [ $^X, 'miniperl','perl','perl5',"perl$]" ],
d2128 2
d2144 2
d2152 1
d2162 1
d2388 1
a2388 1
		($xx = $File::Find::name) =~ s,.*?/auto/,,;
d2406 1
a2406 1
		($xx = $File::Find::name) =~ s,.*?/auto/,,;
d2423 1
a2423 1
	return if $File::Find::name =~ m:auto/$self->{FULLEXT}/$self->{BASEEXT}$self->{LIB_EXT}$:;
d2434 1
a2434 1
	next unless /\Q$self->{LIB_EXT}\E$/;
d2519 1
a2519 1
		-e "writemain(grep s#.*/auto/##, split(q| |, q|$(MAP_STATIC)|))" > $@@t && $(MV) $@@t $@@
d2529 1
d2611 5
a2615 1
    unless ($self->perl_script($pod2man_exe)) {
d2742 3
a2744 1
parse a file and return what you think is $VERSION in this file set to
d2770 1
a2770 1
	local($^W) = 0;
d2772 1
a2772 1
	die "Could not eval '$eval' in $parsefile: $@@" if $@@;
d2794 1
a2794 1
    $package =~ s/-/::/;
d2886 47
a2932 10
$(PERL_INC)/EXTERN.h       $(PERL_INC)/gv.h           $(PERL_INC)/pp.h       \
$(PERL_INC)/INTERN.h       $(PERL_INC)/handy.h        $(PERL_INC)/proto.h    \
$(PERL_INC)/XSUB.h         $(PERL_INC)/hv.h           $(PERL_INC)/regcomp.h  \
$(PERL_INC)/av.h           $(PERL_INC)/keywords.h     $(PERL_INC)/regexp.h   \
$(PERL_INC)/config.h       $(PERL_INC)/mg.h           $(PERL_INC)/scope.h    \
$(PERL_INC)/cop.h          $(PERL_INC)/op.h           $(PERL_INC)/sv.h	     \
$(PERL_INC)/cv.h           $(PERL_INC)/opcode.h       $(PERL_INC)/unixish.h  \
$(PERL_INC)/dosish.h       $(PERL_INC)/patchlevel.h   $(PERL_INC)/util.h     \
$(PERL_INC)/embed.h        $(PERL_INC)/perl.h         $(PERL_INC)/iperlsys.h \
$(PERL_INC)/form.h         $(PERL_INC)/perly.h
d3096 1
a3096 1
    $self->{uc $var} =~ s/\Q$sprefix\E/$rprefix/;
d3140 3
a3142 1
    my $sub = "\t-cd %s && \$(TEST_F) %s && \$(MAKE) %s realclean\n";
d3220 8
d3229 3
a3231 2
q{	$(AR) $(AR_STATIC_ARGS) $@@ $(OBJECT) && $(RANLIB) $@@
	$(CHMOD) $(PERM_RWX) $@@
d3295 13
a3307 1
    qq{
d3312 2
a3313 1
};
d3558 1
a3558 1
    my $xsubpp = $self->{CAPI} ? "xsubpp -object_capi" : "xsubpp";
d3564 1
a3564 1
XSUBPPDEPS = @@tmdeps
d3640 1
a3640 1
all :: pure_all manifypods
d3662 5
a3666 2
    push @@m, qq{
config :: Version_check
d3669 3
a3671 1
} unless $self->{PARENT} or ($self->{PERL_SRC} && $self->{INSTALLDIRS} eq "perl") or $self->{NO_VC};
d3673 8
a3680 1
    push @@m, $self->dir_target(qw[$(INST_AUTODIR) $(INST_LIBDIR) $(INST_ARCHAUTODIR)]);
d3744 1
a3744 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && $(MV) xstmp.c $*.c
d3759 1
a3759 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && $(MV) xstmp.c $*.cpp
d3775 1
a3775 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && $(MV) xstmp.c $*.c
@


1.5
log
@Deal with colon-separated paths in *libexp variables.  This is a
hack and I may simply change those variables to point to a single
pathname.
@
text
@a128 1
	$_ =~ s/:.*$//;
d1606 1
a1606 6
	foreach (split(':', $self->{PERL_ARCHLIB})) {
	    last if (-d ($self->{PERL_INC} = $self->catdir($_, "CORE")));
	}
	# use the primary path compenents of privlibexp and archlibexp
	$self->{PERL_LIB} =~ s/:.*//;
	$self->{PERL_ARCHLIB} =~ s/:.*//;
@


1.4
log
@perl5.005_03 (stock)
@
text
@d11 2
a12 2
$VERSION = substr q$Revision: 1.12602 $, 10;
# $Id: MM_Unix.pm,v 1.126 1998/06/28 21:32:49 k Exp k $
d129 1
d1607 6
a1612 1
	$self->{PERL_INC}     = $self->catdir("$self->{PERL_ARCHLIB}","CORE"); # wild guess for now
@


1.3
log
@perl 5.004_04
@
text
@d8 1
a8 1
use vars qw($VERSION $Is_Mac $Is_OS2 $Is_VMS $Is_Win32
d11 2
a12 2
$VERSION = substr q$Revision: 1.118 $, 10;
# $Id: MM_Unix.pm,v 1.118 1997/08/01 09:42:52 k Exp $
d20 3
d83 5
a87 1
    $path =~ s|/+|/|g ;                            # xx////xx  -> xx/xx
d90 2
a91 2
    $path =~ s|/$|| unless $path eq "/";           # xx/       -> xx
    $path;
d107 1
a107 1
    shift;
d113 1
a113 5
    my $result = join('', @@args);
    # remove a trailing slash unless we are root
    substr($result,-1) = ""
	if length($result) > 1 && substr($result,-1) eq "/";
    $result;
d126 1
a126 1
    return $file unless @@_;
d131 1
a131 1
    return $dir.$file;
d217 1
d236 1
d274 1
a274 1
' if $^O ne 'os2' and $^O ne 'MSWin32';		# Case-specific
d378 9
d574 9
d707 2
a708 2
	push(@@m,qq{
	-$self->{NOECHO}\$(CHMOD) 755 $targdir
d731 2
a732 2
    my($compress) = $attribs{COMPRESS} || 'compress';   # eg gzip
    my($suffix)   = $attribs{SUFFIX}   || '.Z';          # eg .gz
d822 1
a822 1
Defeines the targets dist, tardist, zipdist, uutardist, shdist
d919 1
d936 2
a937 1
	neatvalue($funcs),', "DL_VARS" => ', neatvalue($vars), ');\'
d986 1
a986 1
	$(CHMOD) 644 $@@
d991 1
a991 1
	$(CHMOD) 644 $@@
d1035 4
d1042 1
a1042 1
	$(CHMOD) 755 $@@
d1081 6
a1086 1
    $file =~ m:^/: ;
d1186 1
d1195 1
a1195 1
};
d1202 1
a1202 5
	unless ( rename($file, "$file.bak") ) {	
	    warn "Can't modify $file";
	    next;
	}
	unless ( open(FIXOUT,">$file") ) {
d1207 4
a1210 1
	$mode = 0755 unless $dev;
d1219 13
d1234 2
a1235 1
	chmod 0755, $file or die "Can't reset permissions for $file: $!\n";
d1303 1
a1303 1
    $ignore{'test.pl'} = 1;
d1321 8
a1330 5
	} elsif ($name =~ /\.PL$/ && $name ne "Makefile.PL") {
	    ($pl_files{$name} = $name) =~ s/\.PL$// ;
	} elsif ($Is_VMS && $name =~ /\.pl$/ && $name ne 'makefile.pl' &&
	         $name ne 'test.pl') {  # case-insensitive filesystem
	    ($pl_files{$name} = $name) =~ s/\.pl$// ;
d1534 1
a1534 1
    ($self->{PARENT_NAME}, $self->{BASEEXT}) = $self->{NAME} =~ m!([\w:]+::)?(\w+)$! ;
d1988 1
a1988 1
	}.$self->{NOECHO}.q{$(DOC_INSTALL) \
d1997 1
a1997 1
	}.$self->{NOECHO}.q{$(DOC_INSTALL) \
d2024 1
a2024 1
Defines targets to install EXE_FILES.
d2045 4
a2048 1
FIXIN = \$(PERL) -I\$(PERL_ARCHLIB) -I\$(PERL_LIB) -MExtUtils::MakeMaker \\
d2050 2
a2051 2

all :: @@to
d2066 1
d2339 1
a2339 1
	\$(MAP_LINKCMD) -o \$\@@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) $ldfrom $llibperl \$(MAP_STATIC) `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
d2353 1
a2353 1
		-e "writemain(grep s#.*/auto/##, qw|$(MAP_STATIC)|)" > $@@t && $(MV) $@@t $@@
d2356 3
d2363 1
a2363 1
	}.$self->{NOECHO}.q{$(DOC_INSTALL) \
d2409 1
d2435 2
a2436 1
    return "\nmanifypods :\n\t$self->{NOECHO}\$(NOOP)\n" unless %{$self->{MAN3PODS}} or %{$self->{MAN1PODS}};
d2457 3
a2459 2
q[POD2MAN = $(PERL) -we '%m=@@ARGV;for (keys %m){' \\
-e 'next if -e $$m{$$_} && -M $$m{$$_} < -M $$_ && -M $$m{$$_} < -M "].$self->{MAKEFILE}.q[";' \\
d2462 1
a2462 1
-e 'chmod 0644, $$m{$$_} or warn "chmod 644 $$m{$$_}: $$!\n";}'
d2464 1
a2464 1
    push @@m, "\nmanifypods : ";
d2607 26
d2665 1
a2665 1
    my $path_sep = $Is_OS2 ? ";" : ":";
d2721 1
a2721 1
$(PERL_INC)/embed.h        $(PERL_INC)/perl.h				     \
d2732 85
d2900 4
d2905 1
a2905 1
all :: $self->{PL_FILES}->{$plfile}
d2908 2
a2909 2
$self->{PL_FILES}->{$plfile} :: $plfile
	\$(PERL) -I\$(INST_ARCHLIB) -I\$(INST_LIB) -I\$(PERL_ARCHLIB) -I\$(PERL_LIB) $plfile
d2911 1
d2940 2
a2941 1
    push(@@m, "	$self->{RM_F} " . join(" ", values %{$self->{PM}}) . "\n");
d2959 5
a2963 1
    $man =~ s,/+,::,g;
d3010 1
a3010 1
	$(CHMOD) 755 $@@
d3324 2
d3328 1
a3328 1
XSUBPP = \$(XSUBPPDIR)/xsubpp
d3474 1
a3474 1
Obsolete, depecated method. Not used since Version 5.21.
d3498 16
a3513 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >$*.tc && $(MV) $*.tc $@@
d3544 1
@


1.2
log
@Fix a bug in an internal perl build script fragment that caused a bogus
Makefile to be built for the sdbm library subdir.
@
text
@d3 1
a3 4
$VERSION = substr q$Revision: 1.1.1.1 $, 10;
# $Id: MM_Unix.pm,v 1.1.1.1 1996/08/19 10:12:39 downsj Exp $

require Exporter;
d7 6
d17 3
a19 2
$Is_OS2 = $^O =~ m|^os/?2$|i;
$Is_Mac = $^O eq "MacOS";
d47 2
a48 2
to limit the necessary overrides to primitiv methods, and if it is not
possible to do so, let's work it out how to achieve that gain.
d104 1
a104 1
	$_ .= "/" unless substr($_,length($_)-1,1) eq "/";
d108 2
a109 2
    substr($result,length($result)-1,1) = ""
	if length($result) > 1 && substr($result,length($result)-1,1) eq "/";
d180 1
d184 1
d207 1
d237 1
a237 1
#use SelfLoader;
d240 4
a243 1
#__DATA__
d247 2
d265 2
a266 1

d269 2
a270 1

d402 1
a402 1
	push @@m, "\t-cd $dir && test -f $self->{MAKEFILE} && \$(MAKE) clean\n";
d416 1
a416 1
	 "\t-$self->{MV} $self->{MAKEFILE} $self->{MAKEFILE}.old 2>/dev/null\n");
d503 1
a503 1
	      INST_ARCHLIB INST_SCRIPT PREFIX INSTALLDIRS
d607 1
a607 5
    if ($Is_OS2) {
	$tmp = "$self->{BASEEXT}.def";
    } else {
	$tmp = "";
    }
d611 1
a611 6

    if ($Is_OS2) {
	$tmp = "\$(PERL_INC)/libperl\$(LIB_EXT)";
    } else {
	$tmp = "";
    }
d667 1
a667 1
    my(@@m,$dir);
d671 7
a677 2
	my($targdir) = $targ;       # Necessary because catfile may have
	$targdir =~ s:/?.exists$::; # adapted syntax of $dir to target OS
d716 1
a716 1
					  . 'test -f tmp.zip && $(RM) tmp.zip;'
d760 2
a761 2
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -e 'use ExtUtils::Manifest "&fullcheck";' \\
		-e 'fullcheck();'
d766 2
a767 2
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -e 'use ExtUtils::Manifest "&skipcheck";' \\
		-e 'skipcheck();'
d772 2
a773 2
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -e 'use ExtUtils::Manifest "&mkmanifest";' \\
		-e 'mkmanifest();'
d789 2
a790 2
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -e 'use ExtUtils::Manifest "&maniread";' \\
		-e '@@all = keys %{ maniread() };' \\
d857 1
a857 1
		-e 'manicopy(maniread(),"$(DISTVNAME)", "$(DIST_CP)");'
d958 2
a959 2
		-e \'use ExtUtils::Mkbootstrap;\' \
		-e \'Mkbootstrap("$(BASEEXT)","$(BSLOADLIBS)");\'
d1003 8
a1010 1
    push(@@m,'	LD_RUN_PATH="$(LD_RUN_PATH)" $(LD) -o $@@ $(LDDLFLAGS) '.$ldfrom.
d1046 1
a1046 1
Takes as argument a path and returns true, it it is an absolute path.
d1074 1
a1074 1
	    my $abs;
d1085 2
a1086 1
	    if (`$abs -e 'require $ver; print "VER_OK\n" ' 2>&1` =~ /VER_OK/) {
d1089 2
d1098 2
d1102 89
a1190 4
The methods here are called in the order specified by
@@ExtUtils::MakeMaker::MM_Sections. This manpage reflects the order as
well as possible. Some methods call each other, so in doubt refer to
the code.
d1202 1
d1258 1
d1334 1
d1337 1
a1337 1
	    $prefix =  '$(INST_LIB)' if (($striplibpath = $path) =~ s:^(\W*)lib\W:$1:);
a1368 1
		# one day test, if $/ can be set to '' safely (is the bug fixed that was in 5.001m?)
d1385 3
a1387 1
		    $manifypods{$name} = $self->catfile('$(INST_MAN1DIR)',basename($name).'.$(MAN1EXT)');
d1450 1
a1450 1
PREFIX, CONFIG, AR, AR_STATIC_ARGS, LD, OBJ_EXT, LIB_EXT, MAP_TARGET,
a1480 2
    } elsif ($Is_OS2) {                # Need manual correction if run with miniperl:-(
        $modfname = substr($modfname, 0, 7) . '_';
a1482 1

d1485 1
a1485 1
    if (defined &DynaLoader::mod2fname or $Is_OS2) {
d1523 2
a1524 1
	$self->{PERL_INC}     = $self->{PERL_SRC};
d1526 12
a1537 2

	warn <<EOM unless (-s $self->catfile($self->{PERL_SRC},'cflags') or $Is_VMS && -s $self->catfile($self->{PERL_SRC},'perlshr_attr.opt') or $Is_Mac);
d1549 2
a1550 1
EOM
d1557 2
a1558 1
	die <<EOM unless (-f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h")));
d1562 4
a1565 8
building extensions. You can say:

    $^X Makefile.PL PERL_SRC=/path/to/perl/source/directory

if you have not yet installed perl but still want to build this
extension now.
(You get this message, because MakeMaker could not find "$perl_h")
EOM
d1567 3
d1599 7
d1612 1
a1612 1
    # as well We look if a directory exists that is named after the
d1640 47
a1686 4
    my($prefix) = $Config{'prefix'};
    $prefix = VMS::Filespec::unixify($prefix) if $Is_VMS;
    unless ($self->{PREFIX}){
	$self->{PREFIX} = $prefix;
d1688 6
a1693 1
    my($install_variable);
d1695 2
a1696 5

			   INSTALLPRIVLIB INSTALLARCHLIB INSTALLBIN
			   INSTALLMAN1DIR INSTALLMAN3DIR INSTALLSCRIPT
			   INSTALLSITELIB INSTALLSITEARCH

d1698 1
a1698 1
	$self->prefixify($install_variable,$prefix,q[$(PREFIX)]);
a1700 1

d1797 1
a1797 1
    $self->{PERL} =
d1799 1
a1799 1
	    \@@defpath, $Verbose ) unless ($self->{PERL});
d1812 1
a1812 1
MAKEFILE, NOECHO, RM_F, RM_RF, TOUCH, CP, MV, CHMOD, UMASK_NULL
d1826 1
a1826 1
    $self->{LIBS}=[$self->{LIBS}] if ref \$self->{LIBS} eq SCALAR;
d1862 1
a1862 1
    $self->{NOOP}  ||= "sh -c true";
d1870 1
d1875 1
d1938 1
a1938 1
		"$(NAME)" \
d1947 1
a1947 1
		"Module $(NAME)" \
d1991 1
a1991 1
    push(@@m, "
d1994 3
d1998 1
d2002 1
a2002 1
");
d2008 1
a2008 1
$to: $from $self->{MAKEFILE} $todir/.exists
d2011 1
d2091 4
d2143 2
a2144 1
    $cccmd .= " $Config::Config{cccdlflags}" if ($Config::Config{d_shrplib});
d2151 1
d2159 2
d2244 10
d2274 7
d2282 1
a2282 1
    push @@m, "
d2284 1
a2284 1
	\$(MAP_LINKCMD) -o \$\@@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) \$(MAP_LIBPERL) \$(MAP_STATIC) `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
d2297 2
a2298 2
	}.$self->{NOECHO}.q{$(PERL) $(MAP_PERLINC) -e 'use ExtUtils::Miniperl; \\
		writemain(grep s#.*/auto/##, qw|$(MAP_STATIC)|)' > $@@.tmp && mv $@@.tmp $@@
d2306 1
a2306 1
		"Perl binary $(MAP_TARGET)" \
d2351 2
a2352 2
	-}.$self->{NOECHO}.q{mv }."$self->{MAKEFILE} $self->{MAKEFILE}.old".q{
	-$(MAKE) -f }.$self->{MAKEFILE}.q{.old clean >/dev/null 2>&1 || true
d2354 3
a2356 2
	}.$self->{NOECHO}.q{echo ">>> Your Makefile has been rebuilt. <<<"
	}.$self->{NOECHO}.q{echo ">>> Please rerun the make command.  <<<"; false
d2525 13
a2537 6
	next unless /\$(([\w\:\']*)\bVERSION)\b.*\=/;
	local $ExtUtils::MakeMaker::module_version_variable = $1;
	my($thispackage) = $2 || $current_package;
	$thispackage =~ s/:+$//;
	my($eval) = "$_;";
	eval $eval;
d2539 1
a2539 1
	$result = $ {$ExtUtils::MakeMaker::module_version_variable} || 0;
d2559 2
d2562 1
a2562 1
    foreach $key (qw(LIBPERL_A LINKTYPE PREFIX OPTIMIZE)){
d2566 1
a2566 1
    push @@m, "\nPASTHRU = ", join ("\\\n\t", @@pasthru), "\n";
d2582 2
d2648 1
a2648 1
destination and autosplits them. See L<ExtUtils::Install/pm_to_blib>
d2659 1
a2659 1
        -e 'pm_to_blib({qw{$(PM_TO_BLIB)}},"}.$autodir.q{")'
d2678 1
a2678 1
Returns an ampty string per default. Used in Makefile.PLs to add some
d2730 1
d2753 1
a2753 1
    my $sub = "\t-cd %s && test -f %s && \$(MAKE) %s realclean\n";
d2763 1
a2763 3
    if ( values %{$self->{PM}} ){
        push(@@m, "	$self->{RM_F} " . join(" ", values %{$self->{PM}}) . "\n");
    }
d2828 1
a2829 1
	$(CHMOD) 755 $@@
d2831 5
a2835 5

# Old mechanism - still available:

    push @@m, "\t$self->{NOECHO}".q{echo "$(EXTRALIBS)" >> $(PERL_SRC)/ext.libs}."\n\n"
	if $self->{PERL_SRC};
d2939 5
a2943 1
    my($tests) = $attribs{TESTS} || (-d "t" ? "t/*.t" : "");
d2949 1
d2956 1
a2956 1
    push(@@m, map("\t$self->{NOECHO}cd $_ && test -f $self->{MAKEFILE} && \$(MAKE) test \$(PASTHRU)\n",
d2963 2
a2964 2
    push(@@m, $self->test_via_harness('$(FULLPERL)', $tests)) if $tests;
    push(@@m, $self->test_via_script('$(FULLPERL)', 'test.pl')) if -f "test.pl";
d2976 2
a2977 2
	push(@@m, $self->test_via_harness('./$(MAP_TARGET)', $tests)) if $tests;
	push(@@m, $self->test_via_script('./$(MAP_TARGET)', 'test.pl')) if -f "test.pl";
d2997 2
a2998 1
    "\tPERL_DL_NONLAZY=1 $perl".q! -I$(INST_ARCHLIB) -I$(INST_LIB) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -e 'use Test::Harness qw(&runtests $$verbose); $$verbose=$(TEST_VERBOSE); runtests @@ARGV;' !."$tests\n";
d3009 2
a3010 1
    qq{\tPERL_DL_NONLAZY=1 $perl}.q{ -I$(INST_ARCHLIB) -I$(INST_LIB) -I$(PERL_ARCHLIB) -I$(PERL_LIB) }.qq{$script
d3049 1
a3049 1
    for (qw/ CHMOD CP LD MV NOOP RM_F RM_RF TOUCH UMASK_NULL / ) {
a3052 1

d3056 1
a3056 4
MKPATH = $(PERL) -wle '$$"="/"; foreach $$p (@@ARGV){' \\
-e 'next if -d $$p; my(@@p); foreach(split(/\//,$$p)){' \\
-e 'push(@@p,$$_); next if -d "@@p/"; print "mkdir @@p" if 0;' \\
-e 'mkdir("@@p",0777)||die $$! } } exit 0;'
d3062 1
a3062 2
EQUALIZE_TIMESTAMP = $(PERL) -we 'open F, ">$$ARGV[1]"; close F;' \\
-e 'utime ((stat("$$ARGV[0]"))[8,9], $$ARGV[1])'
d3065 1
d3080 1
a3080 1
-e 'install({@@ARGV},"$(VERBINST)",0,"$(UNINST)");'
d3082 2
a3083 1
DOC_INSTALL = $(PERL) -e '$$\="\n\n";print "=head3 ", scalar(localtime), ": C<", shift, ">";' \
d3089 3
a3091 2
-e 'uninstall($$ARGV[0],1);'

d3219 1
d3221 1
d3224 4
a3227 1

d3282 1
a3282 1
		-e 'Version_check("$(MM_VERSION)")'
d3314 1
a3314 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >$*.tc && mv $*.tc $@@
d3330 1
a3330 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && mv xstmp.c $*.c
d3335 27
d3364 1
@


1.1
log
@Initial revision
@
text
@d3 2
a4 2
$VERSION = substr q$Revision: 1.101 $, 10;
# $Id: MM_Unix.pm,v 1.101 1996/06/23 20:51:18 k Exp k $
d2547 3
a2549 1
    push(@@m, "	$self->{RM_F} " . join(" ", values %{$self->{PM}}) . "\n");
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 4
a6 1
use Exporter ();
a9 6
use strict;
use vars qw($VERSION $Is_Mac $Is_OS2 $Is_VMS $Is_Win32 $Is_Dos $Is_PERL_OBJECT
	    $Verbose %pm %static $Xsubpp_Version);

$VERSION = substr q$Revision: 1.12602 $, 10;
# $Id: MM_Unix.pm,v 1.126 1998/06/28 21:32:49 k Exp k $
d14 2
a15 6
$Is_OS2 = $^O eq 'os2';
$Is_Mac = $^O eq 'MacOS';
$Is_Win32 = $^O eq 'MSWin32';
$Is_Dos = $^O eq 'dos';

$Is_PERL_OBJECT = $Config{'ccflags'} =~ /-DPERL_OBJECT/;
d43 2
a44 2
to limit the necessary overrides to primitive methods, and if it is not
possible to do so, let's work out how to achieve that gain.
d76 1
a76 5
    my $node = '';
    if ( $^O eq 'qnx' && $path =~ s|^(//\d+)/|/| ) {
      $node = $1;
    }
    $path =~ s|(?<=[^/])/+|/|g ;                   # xx////xx  -> xx/xx
d79 2
a80 2
    $path =~ s|(?<=[^/])/$|| ;                     # xx/       -> xx
    "$node$path";
d96 1
a96 1
    my $self = shift @@_;
d100 1
a100 1
	$_ .= "/" if $_ eq '' or substr($_,-1) ne "/";
d102 5
a106 1
    $self->canonpath(join('', @@args));
d119 1
a119 1
    return $self->canonpath($file) unless @@_;
d124 1
a124 1
    return $self->canonpath($dir.$file);
a175 1
sub ExtUtils::MM_Unix::export_list ;
a178 1
sub ExtUtils::MM_Unix::fixin ;
a200 1
sub ExtUtils::MM_Unix::perl_archive;
a206 1
sub ExtUtils::MM_Unix::ppd ;
a224 1
sub ExtUtils::MM_Unix::xs_cpp ;
d230 1
a230 1
use SelfLoader;
d233 1
a233 4

__DATA__

=back
a236 2
=over 2

d253 1
a253 2
';
    push @@m, '
d256 1
a256 2
' if $^O ne 'os2' and $^O ne 'MSWin32' and $^O ne 'dos'; #Case-specific
    push @@m, '
a358 9
    if ($self->{CAPI} && $Is_PERL_OBJECT) {
        $self->{CCFLAGS} =~ s/-DPERL_OBJECT(\s|$)//;
        $self->{CCFLAGS} .= ' -DPERL_CAPI ';
        if ($Is_Win32 && $Config{'cc'} =~ /^cl.exe/i) {
            # Turn off C++ mode of the MSC compiler
            $self->{CCFLAGS} =~ s/-TP(\s|$)//;
            $self->{OPTIMIZE} =~ s/-TP(\s|$)//;
        }
    }
d388 1
a388 1
	push @@m, "\t-cd $dir && \$(TEST_F) $self->{MAKEFILE} && \$(MAKE) clean\n";
d402 1
a402 1
	 "\t-$self->{MV} $self->{MAKEFILE} $self->{MAKEFILE}.old \$(DEV_NULL)\n");
d489 1
a489 1
	      INST_ARCHLIB INST_SCRIPT PREFIX  INSTALLDIRS
a545 9
    for $tmp (qw(
		PERM_RW PERM_RWX
		)
	     ) {
        my $method = lc($tmp);
	# warn "self[$self] method[$method]";
        push @@m, "$tmp = ", $self->$method(), "\n";
    }

d593 5
a597 1
    $tmp = $self->export_list;
d601 6
a606 1
    $tmp = $self->perl_archive;
d662 1
a662 1
    my(@@m,$dir,$targdir);
d666 2
a667 7
	# catfile may have adapted syntax of $dir to target OS, so...
	if ($Is_VMS) { # Just remove file name; dirspec is often in macro
	    ($targdir = $targ) =~ s:/?\.exists$::;
	}
	else { # while elsewhere we expect to see the dir separator in $targ
	    $targdir = dirname($targ);
	}
d674 2
a675 2
	push(@@m, qq{
	-$self->{NOECHO}\$(CHMOD) \$(PERM_RWX) $targdir
d698 2
a699 2
    my($compress) = $attribs{COMPRESS} || 'gzip --best';
    my($suffix)   = $attribs{SUFFIX}   || '.gz';          # eg .gz
d706 1
a706 1
					  . '$(TEST_F) tmp.zip && $(RM) tmp.zip;'
d750 2
a751 2
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=fullcheck \\
		-e fullcheck
d756 2
a757 2
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=skipcheck \\
		-e skipcheck
d762 2
a763 2
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=mkmanifest \\
		-e mkmanifest
d779 2
a780 2
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=maniread \\
		-e "@@all = keys %{ maniread() };" \\
d789 1
a789 1
Defines the targets dist, tardist, zipdist, uutardist, shdist
d847 1
a847 1
		-e "manicopy(maniread(),'$(DISTVNAME)', '$(DIST_CP)');"
a885 1
    my($funclist)  = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
d902 1
a902 2
	neatvalue($funcs), ', "FUNCLIST" => ', neatvalue($funclist),
	', "DL_VARS" => ', neatvalue($vars), ');\'
d948 2
a949 2
		-MExtUtils::Mkbootstrap \
		-e "Mkbootstrap(\'$(BASEEXT)\',\'$(BSLOADLIBS)\');"
d951 1
a951 1
	$(CHMOD) $(PERM_RW) $@@
d956 1
a956 1
	$(CHMOD) $(PERM_RW) $@@
d993 1
a993 12

    # Brain dead solaris linker does not use LD_RUN_PATH?
    # This fixes dynamic extensions which need shared libs
    my $ldrun = '';
    $ldrun = join ' ', map "-R$_", split /:/, $self->{LD_RUN_PATH}
       if ($^O eq 'solaris');

    # The IRIX linker also doesn't use LD_RUN_PATH
    $ldrun = qq{-rpath "$self->{LD_RUN_PATH}"}
	if ($^O eq 'irix' && $self->{LD_RUN_PATH});

    push(@@m,'	LD_RUN_PATH="$(LD_RUN_PATH)" $(LD) -o $@@ '.$ldrun.' $(LDDLFLAGS) '.$ldfrom.
d996 1
a996 1
	$(CHMOD) $(PERM_RWX) $@@
d1029 1
a1029 1
Takes as argument a path and returns true, if it is an absolute path.
d1035 1
a1035 6
    if ($Is_Dos){
        $file =~ m{^([a-z]:)?[\\/]}i ;
    }
    else {
        $file =~ m:^/: ;
    }
d1057 1
a1057 1
	    my ($abs, $val);
d1068 1
a1068 2
	    $val = `$abs -e 'require $ver; print "VER_OK\n" ' 2>&1`;
	    if ($val =~ /VER_OK/) {
a1070 2
	    } elsif ($trace >= 2) {
		print "Result: `$val'\n";
a1077 2
=back

d1080 4
a1083 103
The methods here are called for each MakeMaker object in the order
specified by @@ExtUtils::MakeMaker::MM_Sections.

=over 2

=item fixin

Inserts the sharpbang or equivalent magic number to a script

=cut

sub fixin { # stolen from the pink Camel book, more or less
    my($self,@@files) = @@_;
    my($does_shbang) = $Config::Config{'sharpbang'} =~ /^\s*\#\!/;
    my($file,$interpreter);
    for $file (@@files) {
	local(*FIXIN);
	local(*FIXOUT);
	open(FIXIN, $file) or Carp::croak "Can't process '$file': $!";
	local $/ = "\n";
	chomp(my $line = <FIXIN>);
	next unless $line =~ s/^\s*\#!\s*//;     # Not a shbang file.
	# Now figure out the interpreter name.
	my($cmd,$arg) = split ' ', $line, 2;
	$cmd =~ s!^.*/!!;

	# Now look (in reverse) for interpreter in absolute PATH (unless perl).
	if ($cmd eq "perl") {
            if ($Config{startperl} =~ m,^\#!.*/perl,) {
                $interpreter = $Config{startperl};
                $interpreter =~ s,^\#!,,;
            } else {
                $interpreter = $Config{perlpath};
            }
	} else {
	    my(@@absdirs) = reverse grep {$self->file_name_is_absolute} $self->path;
	    $interpreter = '';
	    my($dir);
	    foreach $dir (@@absdirs) {
		if ($self->maybe_command($cmd)) {
		    warn "Ignoring $interpreter in $file\n" if $Verbose && $interpreter;
		    $interpreter = $self->catfile($dir,$cmd);
		}
	    }
	}
	# Figure out how to invoke interpreter on this machine.

	my($shb) = "";
	if ($interpreter) {
	    print STDOUT "Changing sharpbang in $file to $interpreter" if $Verbose;
	    # this is probably value-free on DOSISH platforms
	    if ($does_shbang) {
		$shb .= "$Config{'sharpbang'}$interpreter";
		$shb .= ' ' . $arg if defined $arg;
		$shb .= "\n";
	    }
	    $shb .= qq{
eval 'exec $interpreter $arg -S \$0 \${1+"\$\@@"}'
    if 0; # not running under some shell
} unless $Is_Win32; # this won't work on win32, so don't
	} else {
	    warn "Can't find $cmd in PATH, $file unchanged"
		if $Verbose;
	    next;
	}

	unless ( open(FIXOUT,">$file.new") ) {
	    warn "Can't create new $file: $!\n";
	    next;
	}
	my($dev,$ino,$mode) = stat FIXIN;
	# If they override perm_rwx, we won't notice it during fixin,
	# because fixin is run through a new instance of MakeMaker.
	# That is why we must run another CHMOD later.
	$mode = oct($self->perm_rwx) unless $dev;
	chmod $mode, $file;
	
	# Print out the new #! line (or equivalent).
	local $\;
	undef $/;
	print FIXOUT $shb, <FIXIN>;
	close FIXIN;
	close FIXOUT;
	# can't rename open files on some DOSISH platforms
	unless ( rename($file, "$file.bak") ) {	
	    warn "Can't rename $file to $file.bak: $!";
	    next;
	}
	unless ( rename("$file.new", $file) ) {	
	    warn "Can't rename $file.new to $file: $!";
	    unless ( rename("$file.bak", $file) ) {
	        warn "Can't rename $file.bak back to $file either: $!";
		warn "Leaving $file renamed as $file.bak\n";
	    }
	    next;
	}
	unlink "$file.bak";
    } continue {
	chmod oct($self->perm_rwx), $file or
	  die "Can't reset permissions for $file: $!\n";
	system("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';;
    }
}
a1094 1
	'.$self->{NOECHO}.'$(NOOP)
d1147 1
a1147 1
    @@ignore{qw(Makefile.PL test.pl)} = (1,1);
a1149 1
	next if $name =~ /\#/;
a1163 8
	} elsif ($name =~ /\.PL$/) {
	    ($pl_files{$name} = $name) =~ s/\.PL$// ;
	} elsif ($Is_VMS && $name =~ /\.pl$/) {  # case-insensitive filesystem
	    local($/); open(PL,$name); my $txt = <PL>; close PL;
	    if ($txt =~ /Extracting \S+ \(with variable substitutions/) {
		($pl_files{$name} = $name) =~ s/\.pl$// ;
	    }
	    else { $pm{$name} = $self->catfile('$(INST_LIBDIR)',$name); }
d1166 5
a1224 1
	    return if /\#/;
d1227 1
a1227 1
	    $prefix =  '$(INST_LIB)' if (($striplibpath = $path) =~ s:^(\W*)lib\W:$1:i);
d1259 1
d1276 1
a1276 3
		    $manifypods{$name} =
			$self->catfile('$(INST_MAN1DIR)',
				       basename($name).'.$(MAN1EXT)');
d1339 1
a1339 1
PREFIX, CONFIG, AR, AR_STATIC_ARGS, LD, OBJ_EXT, LIB_EXT, EXE_EXT, MAP_TARGET,
d1370 2
a1373 1
    ($self->{PARENT_NAME}, $self->{BASEEXT}) = $self->{NAME} =~ m!(?:([\w:]+)::)?(\w+)$! ;
d1375 3
a1377 1
    if (defined &DynaLoader::mod2fname) {
d1415 2
a1416 1
	$self->{PERL_INC}     = ($Is_Win32) ? $self->catdir($self->{PERL_LIB},"CORE") : $self->{PERL_SRC};
d1418 1
a1418 13
	# catch a situation that has occurred a few times in the past:
	unless (
		-s $self->catfile($self->{PERL_SRC},'cflags')
		or
		$Is_VMS
		&&
		-s $self->catfile($self->{PERL_SRC},'perlshr_attr.opt')
		or
		$Is_Mac
		or
		$Is_Win32
	       ){
	    warn qq{
d1430 1
a1430 2
};
	}
d1437 1
a1437 2
	unless (-f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h"))){
	    die qq{
d1441 8
a1448 4
building extensions. Some precompiled versions of perl do not contain
these header files, so you cannot build extensions. In such a case,
please build and install your perl from a fresh perl distribution. It
usually solves this kind of problem.
a1449 3
\(You get this message, because MakeMaker could not find "$perl_h"\)
};
	}
a1478 7
    # We need to set up INST_LIBDIR before init_libscan() for VMS
    my @@parentdir = split(/::/, $self->{PARENT_NAME});
    $self->{INST_LIBDIR} = $self->catdir('$(INST_LIB)',@@parentdir);
    $self->{INST_ARCHLIBDIR} = $self->catdir('$(INST_ARCHLIB)',@@parentdir);
    $self->{INST_AUTODIR} = $self->catdir('$(INST_LIB)','auto','$(FULLEXT)');
    $self->{INST_ARCHAUTODIR} = $self->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)');

d1485 1
a1485 1
    # as well. We look if a directory exists that is named after the
d1513 4
a1516 27
    my($configure_prefix) = $Config{'prefix'};
    $configure_prefix = VMS::Filespec::unixify($configure_prefix) if $Is_VMS;
    $self->{PREFIX} ||= $configure_prefix;


    my($install_variable,$search_prefix,$replace_prefix);

    # The rule, taken from Configure, is that if prefix contains perl,
    # we shape the tree
    #    perlprefix/lib/                INSTALLPRIVLIB
    #    perlprefix/lib/pod/
    #    perlprefix/lib/site_perl/	INSTALLSITELIB
    #    perlprefix/bin/		INSTALLBIN
    #    perlprefix/man/		INSTALLMAN1DIR
    # else
    #    prefix/lib/perl5/		INSTALLPRIVLIB
    #    prefix/lib/perl5/pod/
    #    prefix/lib/perl5/site_perl/	INSTALLSITELIB
    #    prefix/bin/			INSTALLBIN
    #    prefix/lib/perl5/man/		INSTALLMAN1DIR

    $replace_prefix = qq[\$\(PREFIX\)];
    for $install_variable (qw/
			   INSTALLBIN
			   INSTALLSCRIPT
			   /) {
	$self->prefixify($install_variable,$configure_prefix,$replace_prefix);
d1518 1
a1518 26
    $search_prefix = $configure_prefix =~ /perl/ ?
	$self->catdir($configure_prefix,"lib") :
	$self->catdir($configure_prefix,"lib","perl5");
    if ($self->{LIB}) {
	$self->{INSTALLPRIVLIB} = $self->{INSTALLSITELIB} = $self->{LIB};
	$self->{INSTALLARCHLIB} = $self->{INSTALLSITEARCH} = 
	    $self->catdir($self->{LIB},$Config{'archname'});
    } else {
	$replace_prefix = $self->{PREFIX} =~ /perl/ ? 
	    $self->catdir(qq[\$\(PREFIX\)],"lib") :
		$self->catdir(qq[\$\(PREFIX\)],"lib","perl5");
	for $install_variable (qw/
			       INSTALLPRIVLIB
			       INSTALLARCHLIB
			       INSTALLSITELIB
			       INSTALLSITEARCH
			       /) {
	    $self->prefixify($install_variable,$search_prefix,$replace_prefix);
	}
    }
    $search_prefix = $configure_prefix =~ /perl/ ?
	$self->catdir($configure_prefix,"man") :
	    $self->catdir($configure_prefix,"lib","perl5","man");
    $replace_prefix = $self->{PREFIX} =~ /perl/ ? 
	$self->catdir(qq[\$\(PREFIX\)],"man") :
	    $self->catdir(qq[\$\(PREFIX\)],"lib","perl5","man");
d1520 5
a1524 2
			   INSTALLMAN1DIR
			   INSTALLMAN3DIR
d1526 1
a1526 1
	$self->prefixify($install_variable,$search_prefix,$replace_prefix);
d1529 1
d1626 1
a1626 1
    $self->{PERL} ||=
d1628 1
a1628 1
	    \@@defpath, $Verbose );
d1641 1
a1641 1
MAKEFILE, NOECHO, RM_F, RM_RF, TEST_F, TOUCH, CP, MV, CHMOD, UMASK_NULL
d1655 1
a1655 1
    $self->{LIBS}=[$self->{LIBS}] if ref \$self->{LIBS} eq 'SCALAR';
d1691 1
a1691 1
    $self->{NOOP}  ||= '$(SHELL) -c true';
a1698 1
    $self->{TEST_F} ||= "test -f";
a1702 1
    $self->{DEV_NULL} ||= "> /dev/null 2>&1";
d1764 2
a1765 2
	-}.$self->{NOECHO}.q{$(DOC_INSTALL) \
		"Module" "$(NAME)" \
d1773 2
a1774 2
	-}.$self->{NOECHO}.q{$(DOC_INSTALL) \
		"Module" "$(NAME)" \
d1800 1
a1800 1
Defines targets to make and to install EXE_FILES.
d1818 1
a1818 1
    push(@@m, qq{
d1821 1
a1821 8
} . ($Is_Win32
  ? q{FIXIN = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) \
    -e "system qq[pl2bat.bat ].shift"
} : q{FIXIN = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::MakeMaker \
    -e "MY->fixin(shift)"
}).qq{
pure_all :: @@to
	$self->{NOECHO}\$(NOOP)
d1825 1
a1825 1
});
d1831 1
a1831 1
$to: $from $self->{MAKEFILE} " . $self->catdir($todir,'.exists') . "
a1833 2
	\$(FIXIN) $to
	-$self->{NOECHO}\$(CHMOD) \$(PERM_RWX) $to
a1912 4
By default the Makefile produced includes all the static extensions in
the perl library. (Purified versions of library files, e.g.,
DynaLoader_pure_p1_c0_032.a are automatically ignored to avoid link errors.)

d1961 1
a1961 2
    $cccmd .= " $Config::Config{cccdlflags}"
	if ($Config::Config{useshrplib} eq 'true');
a1967 1
    $linkcmd =~ s,(perl\.exp),\$(PERL_INC)/$1,;
a1974 2
	# Skip purified versions of libraries (e.g., DynaLoader_pure_p1_c0_032.a)
	return if m/_pure_\w+_\w+_\w+\.\w+$/ and -f "$File::Find::dir/.pure";
a2057 10

        if (! -f $libperl and ! -f $lperl) {
          # We did not find a static libperl. Maybe there is a shared one?
          if ($^O eq 'solaris' or $^O eq 'sunos') {
            $lperl  = $libperl = "$dir/$Config::Config{libperl}";
            # SUNOS ld does not take the full path to a shared library
            $libperl = '' if $^O eq 'sunos';
          }
        }

a2077 2
    # SUNOS ld does not take the full path to a shared library
    my $llibperl = ($libperl)?'$(MAP_LIBPERL)':'-lperl';
d2079 1
a2079 6
    # Brain dead solaris linker does not use LD_RUN_PATH?
    # This fixes dynamic extensions which need shared libs
    my $ldfrom = ($^O eq 'solaris')?
           join(' ', map "-R$_", split /:/, $self->{LD_RUN_PATH}):'';

push @@m, "
d2081 1
a2081 1
	\$(MAP_LINKCMD) -o \$\@@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) $ldfrom \$(MAP_STATIC) $llibperl `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
d2094 2
a2095 2
	}.$self->{NOECHO}.q{$(PERL) $(MAP_PERLINC) -MExtUtils::Miniperl \\
		-e "writemain(grep s#.*/auto/##, split(q| |, q|$(MAP_STATIC)|))" > $@@t && $(MV) $@@t $@@
a2097 3
    push @@m, "\t",$self->{NOECHO}.q{$(PERL) $(INSTALLSCRIPT)/fixpmain
} if (defined (&Dos::UseLFN) && Dos::UseLFN()==0);

d2102 2
a2103 2
	-}.$self->{NOECHO}.q{$(DOC_INSTALL) \
		"Perl binary" "$(MAP_TARGET)" \
d2148 2
a2149 3
	-}.$self->{NOECHO}.q{$(RM_F) }."$self->{MAKEFILE}.old".q{
	-}.$self->{NOECHO}.q{$(MV) }."$self->{MAKEFILE} $self->{MAKEFILE}.old".q{
	-$(MAKE) -f }.$self->{MAKEFILE}.q{.old clean $(DEV_NULL) || $(NOOP)
d2151 2
a2152 3
	}.$self->{NOECHO}.q{echo "==> Your Makefile has been rebuilt. <=="
	}.$self->{NOECHO}.q{echo "==> Please rerun the make command.  <=="
	false
d2172 1
a2172 2
    return "\nmanifypods : pure_all\n\t$self->{NOECHO}\$(NOOP)\n" unless
	%{$self->{MAN3PODS}} or %{$self->{MAN1PODS}};
d2193 2
a2194 3
qq[POD2MAN = \$(PERL) -we '%m=\@@ARGV;for (keys %m){' \\\n],
q[-e 'next if -e $$m{$$_} && -M $$m{$$_} < -M $$_ && -M $$m{$$_} < -M "],
 $self->{MAKEFILE}, q[";' \\
d2197 1
a2197 1
-e 'chmod(oct($(PERM_RW))), $$m{$$_} or warn "chmod $(PERM_RW) $$m{$$_}: $$!\n";}'
d2199 1
a2199 1
    push @@m, "\nmanifypods : pure_all ";
d2321 6
a2326 13
	# next unless /\$(([\w\:\']*)\bVERSION)\b.*\=/;
	next unless /([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
	my $eval = qq{
	    package ExtUtils::MakeMaker::_version;
	    no strict;

	    local $1$2;
	    \$$2=undef; do {
		$_
	    }; \$$2
	};
	local($^W) = 0;
	$result = eval($eval);
d2328 1
a2328 1
	$result = "undef" unless defined $result;
a2334 26
=item parse_abstract

parse a file and return what you think is the ABSTRACT

=cut

sub parse_abstract {
    my($self,$parsefile) = @@_;
    my $result;
    local *FH;
    local $/ = "\n";
    open(FH,$parsefile) or die "Could not open '$parsefile': $!";
    my $inpod = 0;
    my $package = $self->{DISTNAME};
    $package =~ s/-/::/;
    while (<FH>) {
        $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
        next if !$inpod;
        chop;
        next unless /^($package\s-\s)(.*)/;
        $result = $2;
        last;
    }
    close FH;
    return $result;
}
a2347 2
    my($sep) = $Is_VMS ? ',' : '';
    $sep .= "\\\n\t";
d2349 1
a2349 1
    foreach $key (qw(LIB LIBPERL_A LINKTYPE PREFIX OPTIMIZE)){
d2353 1
a2353 1
    push @@m, "\nPASTHRU = ", join ($sep, @@pasthru), "\n";
d2365 1
a2365 1
    my $path_sep = ($Is_OS2 || $Is_Dos) ? ";" : ":";
a2368 2
    foreach(@@path) { $_ = '.' if $_ eq '' }
    @@path;
d2419 1
a2419 1
$(PERL_INC)/embed.h        $(PERL_INC)/perl.h         $(PERL_INC)/iperlsys.h \
a2429 85
=item ppd

Defines target that creates a PPD (Perl Package Description) file
for a binary distribution.

=cut

sub ppd {
    my($self) = @@_;
    my(@@m);
    if ($self->{ABSTRACT_FROM}){
        $self->{ABSTRACT} = $self->parse_abstract($self->{ABSTRACT_FROM}) or
            Carp::carp "WARNING: Setting ABSTRACT via file '$self->{ABSTRACT_FROM}' failed\n";
    }
    my ($pack_ver) = join ",", (split (/\./, $self->{VERSION}), (0) x 4) [0 .. 3];
    push(@@m, "# Creates a PPD (Perl Package Description) for a binary distribution.\n");
    push(@@m, "ppd:\n");
    push(@@m, "\t\@@\$(PERL) -e \"print qq{<SOFTPKG NAME=\\\"$self->{DISTNAME}\\\" VERSION=\\\"$pack_ver\\\">\\n}");
    push(@@m, ". qq{\\t<TITLE>$self->{DISTNAME}</TITLE>\\n}");
    my $abstract = $self->{ABSTRACT};
    $abstract =~ s/\n/\\n/sg;
    $abstract =~ s/</&lt;/g;
    $abstract =~ s/>/&gt;/g;
    push(@@m, ". qq{\\t<ABSTRACT>$abstract</ABSTRACT>\\n}");
    my ($author) = $self->{AUTHOR};
    $author =~ s/</&lt;/g;
    $author =~ s/>/&gt;/g;
    $author =~ s/@@/\\@@/g;
    push(@@m, ". qq{\\t<AUTHOR>$author</AUTHOR>\\n}");
    push(@@m, ". qq{\\t<IMPLEMENTATION>\\n}");
    my ($prereq);
    foreach $prereq (sort keys %{$self->{PREREQ_PM}}) {
        my $pre_req = $prereq;
        $pre_req =~ s/::/-/g;
        my ($dep_ver) = join ",", (split (/\./, $self->{PREREQ_PM}{$prereq}), (0) x 4) [0 .. 3];
        push(@@m, ". qq{\\t\\t<DEPENDENCY NAME=\\\"$pre_req\\\" VERSION=\\\"$dep_ver\\\" />\\n}");
    }
    push(@@m, ". qq{\\t\\t<OS NAME=\\\"\$(OSNAME)\\\" />\\n}");
    push(@@m, ". qq{\\t\\t<ARCHITECTURE NAME=\\\"$Config{'archname'}\\\" />\\n}");
    my ($bin_location) = $self->{BINARY_LOCATION};
    $bin_location =~ s/\\/\\\\/g;
    if ($self->{PPM_INSTALL_SCRIPT}) {
        if ($self->{PPM_INSTALL_EXEC}) {
            push(@@m, " . qq{\\t\\t<INSTALL EXEC=\\\"$self->{PPM_INSTALL_EXEC}\\\">$self->{PPM_INSTALL_SCRIPT}</INSTALL>\\n}");
        }
        else {
            push(@@m, " . qq{\\t\\t<INSTALL>$self->{PPM_INSTALL_SCRIPT}</INSTALL>\\n}");
        }
    }
    push(@@m, ". qq{\\t\\t<CODEBASE HREF=\\\"$bin_location\\\" />\\n}");
    push(@@m, ". qq{\\t</IMPLEMENTATION>\\n}");
    push(@@m, ". qq{</SOFTPKG>\\n}\" > $self->{DISTNAME}.ppd");

    join("", @@m);   
}

=item perm_rw (o)

Returns the attribute C<PERM_RW> or the string C<644>.
Used as the string that is passed
to the C<chmod> command to set the permissions for read/writeable files.
MakeMaker chooses C<644> because it has turned out in the past that
relying on the umask provokes hard-to-track bug reports.
When the return value is used by the perl function C<chmod>, it is
interpreted as an octal value.

=cut

sub perm_rw {
    shift->{PERM_RW} || "644";
}

=item perm_rwx (o)

Returns the attribute C<PERM_RWX> or the string C<755>,
i.e. the string that is passed
to the C<chmod> command to set the permissions for executable files.
See also perl_rw.

=cut

sub perm_rwx {
    shift->{PERM_RWX} || "755";
}

d2433 1
a2433 1
destination and autosplits them. See L<ExtUtils::Install/DESCRIPTION>
d2444 1
a2444 1
        -e "pm_to_blib({qw{$(PM_TO_BLIB)}},'}.$autodir.q{')"
d2463 1
a2463 1
Returns an empty string per default. Used in Makefile.PLs to add some
a2512 4
        my $list = ref($self->{PL_FILES}->{$plfile})
		? $self->{PL_FILES}->{$plfile}
		: [$self->{PL_FILES}->{$plfile}];
	foreach $target (@@$list) {
d2514 1
a2514 2
all :: $target
	$self->{NOECHO}\$(NOOP)
d2516 2
a2517 2
$target :: $plfile
	\$(PERL) -I\$(INST_ARCHLIB) -I\$(INST_LIB) -I\$(PERL_ARCHLIB) -I\$(PERL_LIB) $plfile $target
a2518 1
	}
d2537 1
a2537 1
    my $sub = "\t-cd %s && \$(TEST_F) %s && \$(MAKE) %s realclean\n";
d2547 1
a2547 2
    push(@@m, "	$self->{RM_F} " . join(" ", values %{$self->{PM}}) . "\n")
	if keys %{$self->{PM}};
d2565 1
a2565 5
	if ($^O eq 'uwin') {
		$man =~ s,/+,.,g;
	} else {
		$man =~ s,/+,::,g;
	}
a2611 1
	$(CHMOD) $(PERM_RWX) $@@
d2613 1
d2615 5
a2619 5
    # Old mechanism - still available:
    push @@m,
"\t$self->{NOECHO}".q{echo "$(EXTRALIBS)" >> $(PERL_SRC)/ext.libs
}	if $self->{PERL_SRC} && $self->{EXTRALIBS};
    push @@m, "\n";
d2723 1
a2723 5
    my $tests = $attribs{TESTS};
    if (!$tests && -d 't') {
	$tests = $Is_Win32 ? join(' ', <t\\*.t>) : 't/*.t';
    }
    # note: 'test.pl' name is also hardcoded in init_dirscan()
a2728 1
TEST_FILES = $tests
d2735 1
a2735 1
    push(@@m, map("\t$self->{NOECHO}cd $_ && \$(TEST_F) $self->{MAKEFILE} && \$(MAKE) test \$(PASTHRU)\n",
d2742 2
a2743 2
    push(@@m, $self->test_via_harness('$(FULLPERL)', '$(TEST_FILES)')) if $tests;
    push(@@m, $self->test_via_script('$(FULLPERL)', '$(TEST_FILE)')) if -f "test.pl";
d2755 2
a2756 2
	push(@@m, $self->test_via_harness('./$(MAP_TARGET)', '$(TEST_FILES)')) if $tests;
	push(@@m, $self->test_via_script('./$(MAP_TARGET)', '$(TEST_FILE)')) if -f "test.pl";
d2776 1
a2776 2
    $perl = "PERL_DL_NONLAZY=1 $perl" unless $Is_Win32;
    "\t$perl".q! -I$(INST_ARCHLIB) -I$(INST_LIB) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -e 'use Test::Harness qw(&runtests $$verbose); $$verbose=$(TEST_VERBOSE); runtests @@ARGV;' !."$tests\n";
d2787 1
a2787 2
    $perl = "PERL_DL_NONLAZY=1 $perl" unless $Is_Win32;
    qq{\t$perl}.q{ -I$(INST_ARCHLIB) -I$(INST_LIB) -I$(PERL_ARCHLIB) -I$(PERL_LIB) }.qq{$script
d2826 1
a2826 1
    for (qw/ CHMOD CP LD MV NOOP RM_F RM_RF TEST_F TOUCH UMASK_NULL DEV_NULL/ ) {
d2830 1
d2834 4
a2837 1
MKPATH = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e mkpath
d2843 2
a2844 1
EQUALIZE_TIMESTAMP = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e eqtime
a2846 1

d2861 1
a2861 1
-e "install({@@ARGV},'$(VERBINST)',0,'$(UNINST)');"
d2863 1
a2863 2
DOC_INSTALL = $(PERL) -e '$$\="\n\n";' \
-e 'print "=head2 ", scalar(localtime), ": C<", shift, ">", " L<", shift, ">";' \
d2869 2
a2870 3
-e 'uninstall($$ARGV[0],1,1); print "\nUninstall is deprecated. Please check the";' \
-e 'print " packlist above carefully.\n  There may be errors. Remove the";' \
-e 'print " appropriate files manually.\n  Sorry for the inconveniences.\n"'
a2920 2
    my $xsubpp = $self->{CAPI} ? "xsubpp -object_capi" : "xsubpp";

d2923 1
a2923 1
XSUBPP = \$(XSUBPPDIR)/$xsubpp
a2997 1
';
a2998 1
    push @@m, '
d3001 1
a3001 4
' 
	  unless $self->{SKIPHASH}{'all'};
    
    push @@m, '
d3056 1
a3056 1
		-e "Version_check('$(MM_VERSION)')"
d3064 1
a3064 1
Obsolete, deprecated method. Not used since Version 5.21.
d3088 1
a3088 16
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && $(MV) xstmp.c $*.c
';
}

=item xs_cpp (o)

Defines the suffix rules to compile XS files to C++.

=cut

sub xs_cpp {
    my($self) = shift;
    return '' unless $self->needs_linking();
    '
.xs.cpp:
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && $(MV) xstmp.c $*.cpp
d3104 1
a3104 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs >xstmp.c && $(MV) xstmp.c $*.c
a3108 28
=item perl_archive

This is internal method that returns path to libperl.a equivalent
to be linked to dynamic extensions. UNIX does not have one but OS2
and Win32 do.

=cut 

sub perl_archive
{
 return '$(PERL_INC)' . "/$Config{libperl}" if $^O eq "beos";
 return "";
}

=item export_list

This is internal method that returns name of a file that is
passed to linker to define symbols to be exported.
UNIX does not have one but OS2 and Win32 do.

=cut 

sub export_list
{
 return "";
}


a3110 1
=back
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d11 1
a11 1
$VERSION = substr q$Revision: 1.12603 $, 10;
d14 2
a15 1
Exporter::import('ExtUtils::MakeMaker', qw($Verbose &neatvalue));
d84 1
a84 1
    if ( $^O eq 'qnx' && $path =~ s|^(//\d+)/|/|s ) {
d89 2
a90 2
    $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
    $path =~ s|(?<=[^/])/\z|| ;                    # xx/       -> xx
a190 1
sub ExtUtils::MM_Unix::htmlifypods ;
d378 7
a384 18
    if ($Is_PERL_OBJECT) {
        $self->{CCFLAGS} =~ s/-DPERL_OBJECT(\b|$)/-DPERL_CAPI/g;
        if ($Is_Win32) { 
	    if ($Config{'cc'} =~ /^cl/i) {
		# Turn off C++ mode of the MSC compiler
		$self->{CCFLAGS} =~ s/-TP(\s|$)//g;
		$self->{OPTIMIZE} =~ s/-TP(\s|$)//g;
	    }
	    elsif ($Config{'cc'} =~ /^bcc32/i) {
		# Turn off C++ mode of the Borland compiler
		$self->{CCFLAGS} =~ s/-P(\s|$)//g;
		$self->{OPTIMIZE} =~ s/-P(\s|$)//g;
	    }
	    elsif ($Config{'cc'} =~ /^gcc/i) {
		# Turn off C++ mode of the GCC compiler
		$self->{CCFLAGS} =~ s/-xc\+\+(\s|$)//g;
		$self->{OPTIMIZE} =~ s/-xc\+\+(\s|$)//g;
	    }
a386 12

    if ($self->{POLLUTE}) {
	$self->{CCFLAGS} .= ' -DPERL_POLLUTE ';
    }

    my $pollute = '';
    if ($Config{usemymalloc} and not $Config{bincompat5005}
	and not $Config{ccflags} =~ /-DPERL_POLLUTE_MALLOC\b/
	and $self->{PERL_MALLOC_OK}) {
	$pollute = '$(PERL_MALLOC_DEF)';
    }

a392 1
MPOLLUTE = $pollute
d416 1
a416 13
	if ($Is_Win32  &&  Win32::IsWin95()) {
	    push @@m, <<EOT;
	cd $dir
	\$(TEST_F) $self->{MAKEFILE}
	\$(MAKE) clean
	cd ..
EOT
	}
	else {
	    push @@m, <<EOT;
	-cd $dir && \$(TEST_F) $self->{MAKEFILE} && \$(MAKE) clean
EOT
	}
d422 1
a422 2
			 perlmain.c mon.out core core.*perl.*.?
			 *perl.core so_locations pm_to_blib
d449 1
a449 1
	$(PERLTYPE) $(LARGE) $(SPLIT) $(MPOLLUTE) $(DEFINE_VERSION) \\
d522 1
a522 1
	      PERL_INC PERL FULLPERL FULL_AR
a533 1
PERL_MALLOC_DEF = -DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc -Dfree=Perl_mfree -Drealloc=Perl_realloc -Dcalloc=Perl_calloc
a562 2
HTMLLIBPODS    = ".join(" \\\n\t", sort keys %{$self->{HTMLLIBPODS}})."
HTMLSCRIPTPODS = ".join(" \\\n\t", sort keys %{$self->{HTMLSCRIPTPODS}})."
d568 1
a568 6
	      INST_HTMLPRIVLIBDIR INSTALLHTMLPRIVLIBDIR
	      INST_HTMLSITELIBDIR INSTALLHTMLSITELIBDIR
	      INST_HTMLSCRIPTDIR  INSTALLHTMLSCRIPTDIR
	      INST_HTMLLIBDIR                    HTMLEXT
	      INST_MAN1DIR        INSTALLMAN1DIR MAN1EXT
	      INST_MAN3DIR        INSTALLMAN3DIR MAN3EXT
d696 1
a696 1
	    ($targdir = $targ) =~ s:/?\.exists\z::;
d1082 1
a1082 1
        $file =~ m{^([a-z]:)?[\\/]}is ;
d1085 1
a1085 1
        $file =~ m:^/:s ;
d1268 1
a1268 1
    $name =~ s|[\-_][\d\.\-]+\z||;  # this is new with MM 5.00, we
a1292 51
=item htmlifypods (o)

Defines targets and routines to translate the pods into HTML manpages
and put them into the INST_HTMLLIBDIR and INST_HTMLSCRIPTDIR
directories.

=cut

sub htmlifypods {
    my($self, %attribs) = @@_;
    return "\nhtmlifypods : pure_all\n\t$self->{NOECHO}\$(NOOP)\n" unless
	%{$self->{HTMLLIBPODS}} || %{$self->{HTMLSCRIPTPODS}};
    my($dist);
    my($pod2html_exe);
    if (defined $self->{PERL_SRC}) {
	$pod2html_exe = $self->catfile($self->{PERL_SRC},'pod','pod2html');
    } else {
	$pod2html_exe = $self->catfile($Config{scriptdirexp},'pod2html');
    }
    unless ($pod2html_exe = $self->perl_script($pod2html_exe)) {
	# No pod2html but some HTMLxxxPODS to be installed
	print <<END;

Warning: I could not locate your pod2html program. Please make sure,
         your pod2html program is in your PATH before you execute 'make'

END
        $pod2html_exe = "-S pod2html";
    }
    my(@@m);
    push @@m,
qq[POD2HTML_EXE = $pod2html_exe\n],
qq[POD2HTML = \$(PERL) -we 'use File::Basename; use File::Path qw(mkpath); %m=\@@ARGV;for (keys %m){' \\\n],
q[-e 'next if -e $$m{$$_} && -M $$m{$$_} < -M $$_ && -M $$m{$$_} < -M "],
 $self->{MAKEFILE}, q[";' \\
-e 'print "Htmlifying $$m{$$_}\n";' \\
-e '$$dir = dirname($$m{$$_}); mkpath($$dir) unless -d $$dir;' \\
-e 'system(qq[$$^X ].q["-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" $(POD2HTML_EXE) ].qq[$$_>$$m{$$_}])==0 or warn "Couldn\\047t install $$m{$$_}\n";' \\
-e 'chmod(oct($(PERM_RW))), $$m{$$_} or warn "chmod $(PERM_RW) $$m{$$_}: $$!\n";}'
];
    push @@m, "\nhtmlifypods : pure_all ";
    push @@m, join " \\\n\t", keys %{$self->{HTMLLIBPODS}}, keys %{$self->{HTMLSCRIPTPODS}};

    push(@@m,"\n");
    if (%{$self->{HTMLLIBPODS}} || %{$self->{HTMLSCRIPTPODS}}) {
	push @@m, "\t$self->{NOECHO}\$(POD2HTML) \\\n\t";
	push @@m, join " \\\n\t", %{$self->{HTMLLIBPODS}}, %{$self->{HTMLSCRIPTPODS}};
    }
    join('', @@m);
}

d1295 1
a1295 1
Initializes DIR, XS, PM, C, O_FILES, H, PL_FILES, HTML*PODS, MAN*PODS, EXE_FILES.
d1312 2
a1313 2
	} elsif ($name =~ /\.xs\z/){
	    my($c); ($c = $name) =~ s/\.xs\z/.c/;
d1316 1
a1316 1
	} elsif ($name =~ /\.c(pp|xx|c)?\z/i){  # .c .C .cpp .cxx .cc
d1319 1
a1319 1
	} elsif ($name =~ /\.h\z/i){
d1321 3
a1323 5
	} elsif ($name =~ /\.PL\z/) {
	    ($pl_files{$name} = $name) =~ s/\.PL\z// ;
	} elsif (($Is_VMS || $Is_Dos) && $name =~ /[._]pl$/i) {
	    # case-insensitive filesystem, one dot per name, so foo.h.PL
	    # under Unix appears as foo.h_pl under VMS or fooh.pl on Dos
d1326 1
a1326 1
		($pl_files{$name} = $name) =~ s/[._]pl\z//i ;
d1329 1
a1329 1
	} elsif ($name =~ /\.(p[ml]|pod)\z/){
d1404 1
a1404 1
    $self->{O_FILES} = [grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i, @@o_files] ;
d1409 5
a1413 9
    my %pods;
    foreach my $man (qw(MAN1 MAN3 HTMLLIB HTMLSCRIPT)) {
	unless ($self->{"${man}PODS"}) {
	    $self->{"${man}PODS"} = {};
	    $pods{$man} = 1 unless $self->{"INST_${man}DIR"} =~ /^(none|\s*)$/;
	}
    }

    if ($pods{MAN1} || $pods{HTMLSCRIPT}) {
d1416 2
d1420 1
d1422 1
d1429 1
d1435 4
a1438 8
		next unless $ispod;
		if ($pods{HTMLSCRIPT}) {
		    $self->{HTMLSCRIPTPODS}->{$name} =
		      $self->catfile("\$(INST_HTMLSCRIPTDIR)", basename($name).".\$(HTMLEXT)");
		}
		if ($pods{MAN1}) {
		    $self->{MAN1PODS}->{$name} =
		      $self->catfile("\$(INST_MAN1DIR)", basename($name).".\$(MAN1EXT)");
d1442 1
d1444 4
a1447 1
    if ($pods{MAN3} || $pods{HTMLLIB}) {
d1451 1
a1451 1
	    if ($name =~ /\.pod\z/ ) {
d1453 3
a1455 1
	    } elsif ($name =~ /\.p[ml]\z/ ) {
d1458 1
d1460 1
d1467 1
d1481 1
a1481 1
	    if ($name =~ /(config|setup).*\.pm/is) {
d1486 1
a1486 6
	    $manpagename =~ s/\.p(od|m|l)\z//;
	    if ($pods{HTMLLIB}) {
		$self->{HTMLLIBPODS}->{$name} =
		  $self->catfile("\$(INST_HTMLLIBDIR)", "$manpagename.\$(HTMLEXT)");
	    }
	    unless ($manpagename =~ s!^\W*lib\W+!!s) { # everything below lib is ok
d1489 3
a1491 5
	    if ($pods{MAN3}) {
		$manpagename = $self->replace_manpage_separator($manpagename);
		$self->{MAN3PODS}->{$name} =
		  $self->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
	    }
d1493 1
d1534 1
a1534 1
    ($self->{PARENT_NAME}, $self->{BASEEXT}) = $self->{NAME} =~ m!(?:([\w:]+)::)?(\w+)\z! ;
a1603 1
        my $old = $self->{PERL_LIB} || $self->{PERL_ARCHLIB} || $self->{PERL_INC};
a1607 23

	if (not -f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h"))
	    and not $old){
	    # Maybe somebody tries to build an extension with an
	    # uninstalled Perl outside of Perl build tree
	    my $found;
	    for my $dir (@@INC) {
	      $found = $dir, last if -e $self->catdir($dir, "Config.pm");
	    }
	    if ($found) {
	      my $inc = dirname $found;
	      if (-e $self->catdir($inc, "perl.h")) {
		$self->{PERL_LIB}	   = $found;
		$self->{PERL_ARCHLIB}	   = $found;
		$self->{PERL_INC}	   = $inc;
		$self->{UNINSTALLED_PERL}  = 1;
		print STDOUT <<EOP;
... Detected uninstalled Perl.  Trying to continue.
EOP
	      }
	    }
	}
	
d1698 2
a1699 1
    # If the prefix contains perl, Configure shapes the tree as follows:
a1710 5
    #
    # The above results in various kinds of breakage on various
    # platforms, so we cope with it as follows: if prefix/lib/perl5
    # or prefix/lib/perl5/man exist, we'll replace those instead
    # of /prefix/{lib,man}
d1719 3
a1721 3
    my $funkylibdir = $self->catdir($configure_prefix,"lib","perl5");
    $funkylibdir = '' unless -d $funkylibdir;
    $search_prefix = $funkylibdir || $self->catdir($configure_prefix,"lib");
d1726 4
a1729 8
    }
    else {
	if (-d $self->catdir($self->{PREFIX},"lib","perl5")) {
	    $replace_prefix = $self->catdir(qq[\$\(PREFIX\)],"lib", "perl5");
	}
	else {
	    $replace_prefix = $self->catdir(qq[\$\(PREFIX\)],"lib");
	}
d1735 1
a1735 2
			       /)
	{
d1739 6
a1744 9
    my $funkymandir = $self->catdir($configure_prefix,"lib","perl5","man");
    $funkymandir = '' unless -d $funkymandir;
    $search_prefix = $funkymandir || $self->catdir($configure_prefix,"man");
    if (-d $self->catdir($self->{PREFIX},"lib","perl5", "man")) {
	$replace_prefix = $self->catdir(qq[\$\(PREFIX\)],"lib", "perl5", "man");
    }
    else {
	$replace_prefix = $self->catdir(qq[\$\(PREFIX\)],"man");
    }
d1748 1
a1748 2
			   /)
    {
a1775 24
    $self->{INSTALLHTMLPRIVLIBDIR} = $Config::Config{installhtmlprivlibdir}
        unless defined $self->{INSTALLHTMLPRIVLIBDIR};
    $self->{INSTALLHTMLSITELIBDIR} = $Config::Config{installhtmlsitelibdir}
        unless defined $self->{INSTALLHTMLSITELIBDIR};

    unless (defined $self->{INST_HTMLLIBDIR}){
	if ($self->{INSTALLHTMLSITELIBDIR} =~ /^(none|\s*)$/){
	    $self->{INST_HTMLLIBDIR} = $self->{INSTALLHTMLSITELIBDIR};
	} else {
	    $self->{INST_HTMLLIBDIR} = $self->catdir($self->curdir,'blib','html','lib');
	}
    }

    $self->{INSTALLHTMLSCRIPTDIR} = $Config::Config{installhtmlscriptdir}
        unless defined $self->{INSTALLHTMLSCRIPTDIR};
    unless (defined $self->{INST_HTMLSCRIPTDIR}){
	if ($self->{INSTALLHTMLSCRIPTDIR} =~ /^(none|\s*)$/){
	    $self->{INST_HTMLSCRIPTDIR} = $self->{INSTALLHTMLSCRIPTDIR};
	} else {
	    $self->{INST_HTMLSCRIPTDIR} = $self->catdir($self->curdir,'blib','html','bin');
	}
    }
    $self->{HTMLEXT} ||= $Config::Config{htmlext} || 'html';

d1849 1
a1849 2
        $self->find_perl(5.0, [ $self->canonpath($^X), 'miniperl',
				'perl','perl5',"perl$Config{version}" ],
a1967 2
		$(INST_HTMLLIBDIR) $(INSTALLHTMLPRIVLIBDIR) \
		$(INST_HTMLSCRIPTDIR) $(INSTALLHTMLSCRIPTDIR) \
a1981 2
		$(INST_HTMLLIBDIR) $(INSTALLHTMLSITELIBDIR) \
		$(INST_HTMLSCRIPTDIR) $(INSTALLHTMLSCRIPTDIR) \
a1987 1
	-}.$self->{NOECHO}.q{$(MKPATH) $(INSTALLARCHLIB)
a1996 1
	-}.$self->{NOECHO}.q{$(MKPATH) $(INSTALLARCHLIB)
d2222 1
a2222 1
		($xx = $File::Find::name) =~ s,.*?/auto/,,s;
d2240 1
a2240 1
		($xx = $File::Find::name) =~ s,.*?/auto/,,s;
d2257 1
a2257 1
	return if $File::Find::name =~ m:auto/$self->{FULLEXT}/$self->{BASEEXT}$self->{LIB_EXT}\z:;
d2268 1
a2268 1
	next unless /\Q$self->{LIB_EXT}\E\z/;
d2353 1
a2353 1
		-e "writemain(grep s#.*/auto/##s, split(q| |, q|$(MAP_STATIC)|))" > $@@t && $(MV) $@@t $@@
a2362 1
	-}.$self->{NOECHO}.q{$(MKPATH) $(INSTALLARCHLIB)
d2444 1
a2444 5
    unless ($pod2man_exe = $self->perl_script($pod2man_exe)) {
      # Maybe a build by uninstalled Perl?
      $pod2man_exe = $self->catfile($self->{PERL_INC}, "pod", "pod2man");
    }
    unless ($pod2man_exe = $self->perl_script($pod2man_exe)) {
d2571 1
a2571 3
parse a file and return what you think is $VERSION in this file set to.
It will return the string "undef" if it can't figure out what $VERSION
is.
d2597 1
a2597 1
	no warnings;
d2599 1
a2599 1
	warn "Could not eval '$eval' in $parsefile: $@@" if $@@;
d2621 1
a2621 1
    $package =~ s/-/::/g;
d2713 10
a2722 47
	$(PERL_INC)/EXTERN.h		\
	$(PERL_INC)/INTERN.h		\
	$(PERL_INC)/XSUB.h		\
	$(PERL_INC)/av.h		\
	$(PERL_INC)/cc_runtime.h	\
	$(PERL_INC)/config.h		\
	$(PERL_INC)/cop.h		\
	$(PERL_INC)/cv.h		\
	$(PERL_INC)/dosish.h		\
	$(PERL_INC)/embed.h		\
	$(PERL_INC)/embedvar.h		\
	$(PERL_INC)/fakethr.h		\
	$(PERL_INC)/form.h		\
	$(PERL_INC)/gv.h		\
	$(PERL_INC)/handy.h		\
	$(PERL_INC)/hv.h		\
	$(PERL_INC)/intrpvar.h		\
	$(PERL_INC)/iperlsys.h		\
	$(PERL_INC)/keywords.h		\
	$(PERL_INC)/mg.h		\
	$(PERL_INC)/nostdio.h		\
	$(PERL_INC)/objXSUB.h		\
	$(PERL_INC)/op.h		\
	$(PERL_INC)/opcode.h		\
	$(PERL_INC)/opnames.h		\
	$(PERL_INC)/patchlevel.h	\
	$(PERL_INC)/perl.h		\
	$(PERL_INC)/perlapi.h		\
	$(PERL_INC)/perlio.h		\
	$(PERL_INC)/perlsdio.h		\
	$(PERL_INC)/perlsfio.h		\
	$(PERL_INC)/perlvars.h		\
	$(PERL_INC)/perly.h		\
	$(PERL_INC)/pp.h		\
	$(PERL_INC)/pp_proto.h		\
	$(PERL_INC)/proto.h		\
	$(PERL_INC)/regcomp.h		\
	$(PERL_INC)/regexp.h		\
	$(PERL_INC)/regnodes.h		\
	$(PERL_INC)/scope.h		\
	$(PERL_INC)/sv.h		\
	$(PERL_INC)/thrdvar.h		\
	$(PERL_INC)/thread.h		\
	$(PERL_INC)/unixish.h		\
	$(PERL_INC)/utf8.h		\
	$(PERL_INC)/util.h		\
	$(PERL_INC)/warnings.h
d2886 1
a2886 1
    $self->{uc $var} =~ s/\Q$sprefix\E/$rprefix/s;
d2930 1
a2930 3
    my $sub = ($Is_Win32  &&  Win32::IsWin95()) ?
      "\tcd %s\n\t\$(TEST_F) %s\n\t\$(MAKE) %s realclean\n\tcd ..\n" :
      "\t-cd %s && \$(TEST_F) %s && \$(MAKE) %s realclean\n";
a3007 8
    my $ar; 
    if (exists $self->{FULL_AR} && -x $self->{FULL_AR}) {
        # Prefer the absolute pathed ar if available so that PATH
        # doesn't confuse us.  Perl itself is built with the full_ar.  
        $ar = 'FULL_AR';
    } else {
        $ar = 'AR';
    }
d3009 2
a3010 3
        "\t\$($ar) ".'$(AR_STATIC_ARGS) $@@ $(OBJECT) && $(RANLIB) $@@'."\n";
    push @@m,
q{	$(CHMOD) $(PERM_RWX) $@@
d3074 1
a3074 13
    if ($Is_Win32 && Win32::IsWin95()) {
	# XXX: dmake-specific, like rest of Win95 port
	return <<EOT;
subdirs ::
@@[
	cd $subdir
	\$(MAKE) all \$(PASTHRU)
	cd ..
]
EOT
    }
    else {
	return <<EOT;
d3079 1
a3079 2
EOT
    }
d3324 1
a3324 1
    my $xsubpp = "xsubpp";
d3330 1
a3330 1
XSUBPPDEPS = @@tmdeps \$(XSUBPP)
d3406 1
a3406 1
all :: pure_all htmlifypods manifypods
d3428 2
a3429 5
    push @@m, $self->dir_target(qw[$(INST_AUTODIR) $(INST_LIBDIR) $(INST_ARCHAUTODIR)]);

    if (%{$self->{HTMLLIBPODS}}) {
	push @@m, qq[
config :: \$(INST_HTMLLIBDIR)/.exists
d3432 1
a3432 3
];
	push @@m, $self->dir_target(qw[$(INST_HTMLLIBDIR)]);
    }
d3434 1
a3434 8
    if (%{$self->{HTMLSCRIPTPODS}}) {
	push @@m, qq[
config :: \$(INST_HTMLSCRIPTDIR)/.exists
	$self->{NOECHO}\$(NOOP)

];
	push @@m, $self->dir_target(qw[$(INST_HTMLSCRIPTDIR)]);
    }
d3498 1
a3498 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
d3513 1
a3513 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.cpp
d3529 1
a3529 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a210 1
sub ExtUtils::MM_Unix::perl_archive_after;
d308 2
a309 2
    @@cflags{qw(cc ccflags optimize shellflags)}
	= @@Config{qw(cc ccflags optimize shellflags)};
d344 2
d352 2
d371 1
a371 1
    for (qw(ccflags optimize perltype)) {
d414 2
d460 1
a460 1
			 *$(OBJ_EXT) *$(LIB_EXT) perl.exe
d486 1
a486 1
	$(PERLTYPE) $(MPOLLUTE) $(DEFINE_VERSION) \\
d589 1
a589 1
	      LDFROM LINKTYPE PM_FILTER
a682 4
    $tmp = $self->perl_archive_after;
    push @@m, "
PERL_ARCHIVE_AFTER = $tmp
";
d815 1
a815 1
Defines the targets distclean, distcheck, skipcheck, manifest, veryclean.
a842 5

    push @@m, q{
veryclean : realclean
	$(RM_F) *~ *.orig */*~ */*.orig
};
d1065 1
a1065 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)/.exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
d1074 8
a1081 2
    # The IRIX linker doesn't use LD_RUN_PATH
    my $ldrun = qq{-rpath "$self->{LD_RUN_PATH}"}
d1084 2
a1085 10
    # For example in AIX the shared objects/libraries from previous builds
    # linger quite a while in the shared dynalinker cache even when nobody
    # is using them.  This is painful if one for instance tries to restart
    # a failed build because the link command will fail unnecessarily 'cos
    # the shared object/library is 'busy'.
    push(@@m,'	$(RM_F) $@@
');

    push(@@m,'	LD_RUN_PATH="$(LD_RUN_PATH)" $(LD) '.$ldrun.' $(LDDLFLAGS) '.$ldfrom.
		' $(OTHERLDFLAGS) -o $@@ $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)');
d1150 3
a1152 3
    foreach $name (@@$names){
	foreach $dir (@@$dirs){
	    next unless defined $dir; # $self->{PERL_SRC} may be undefined
d1252 5
d1264 1
a1264 9

	# can't rename/chmod open files on some DOSISH platforms

	# If they override perm_rwx, we won't notice it during fixin,
	# because fixin is run through a new instance of MakeMaker.
	# That is why we must run another CHMOD later.
	$mode = oct($self->perm_rwx) unless $dev;
	chmod $mode, $file;

a1278 1
	close(FIXIN) if fileno(FIXIN);
d1656 1
a1656 1
	foreach $dir ($self->updir(),$self->catdir($self->updir(),$self->updir()),$self->catdir($self->updir(),$self->updir(),$self->updir()),$self->catdir($self->updir(),$self->updir(),$self->updir(),$self->updir())){
d2370 1
a2370 1
	    grep($_, @@Config{qw(ldflags ccdlflags)});
d2453 1
a2453 1
MAP_PRELIBS   = $Config::Config{perllibs} $Config::Config{cryptlib}
a2460 1
	$dir = "$self->{PERL_ARCHLIB}/.." if $self->{UNINSTALLED_PERL};
d2498 5
d2505 1
a2505 1
	\$(MAP_LINKCMD) -o \$\@@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) \$(LDFROM) \$(MAP_STATIC) $llibperl `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
d3041 1
a3041 1
        -e "pm_to_blib({qw{$(PM_TO_BLIB)}},'}.$autodir.q{','$(PM_FILTER)')"
a3112 1
	my $target;
d3152 2
a3153 16
    # Issue a several little RM_F commands rather than risk creating a
    # very long command line (useful for extensions such as Encode
    # that have many files).
    if (keys %{$self->{PM}}) {
	my $line = "";
	foreach (values %{$self->{PM}}) {
	    if (length($line) + length($_) > 80) {
		push @@m, "\t$self->{RM_F} $line\n";
		$line = $_;
	    }
	    else {
		$line .= " $_"; 
	    }
	}
    push @@m, "\t$self->{RM_F} $line\n" if $line;
    }
d3172 1
a3172 3
	    $man =~ s,/+,.,g;
	} elsif ($Is_Dos) {
	    $man =~ s,/+,__,g;
d3174 1
a3174 1
	    $man =~ s,/+,::,g;
d3493 1
a3493 1
VERBINST=0
d3499 1
a3499 1
-e 'print "=head2 ", scalar(localtime), ": C<", shift, ">", " L<", $$arg=shift, "|", $$arg, ">";' \
a3790 15
 return "";
}

=item perl_archive_after

This is an internal method that returns path to a library which
should be put on the linker command line I<after> the external libraries
to be linked to dynamic extensions.  This may be needed if the linker
is one-pass, and Perl includes some overrides for C RTL functions,
such as malloc().

=cut 

sub perl_archive_after
{
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a2 4
require 5.005_03;  # Maybe further back, dunno

use strict;

a3 1
use Carp;
a5 1
use File::Spec;
d8 19
a26 19
use vars qw($VERSION @@ISA
            $Is_Mac $Is_OS2 $Is_VMS $Is_Win32 $Is_Dos $Is_VOS
            $Verbose %pm %static $Xsubpp_Version
            %Config_Override
           );

use ExtUtils::MakeMaker qw($Verbose neatvalue);

$VERSION = '1.33';

require ExtUtils::MM_Any;
@@ISA = qw(ExtUtils::MM_Any);

$Is_OS2   = $^O eq 'os2';
$Is_Mac   = $^O eq 'MacOS';
$Is_Win32 = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
$Is_Dos   = $^O eq 'dos';
$Is_VOS   = $^O eq 'vos';
$Is_VMS   = $^O eq 'VMS';
d69 32
d103 137
a239 84
# So we don't have to keep calling the methods over and over again,
# we have these globals to cache the values.  They have to be global
# else the SelfLoaded methods can't see them.
use vars qw($Curdir $Rootdir $Updir);
$Curdir  = File::Spec->curdir;
$Rootdir = File::Spec->rootdir;
$Updir   = File::Spec->updir;

sub c_o;
sub clean;
sub const_cccmd;
sub const_config;
sub const_loadlibs;
sub constants;
sub depend;
sub dir_target;
sub dist;
sub dist_basics;
sub dist_ci;
sub dist_core;
sub dist_dir;
sub dist_test;
sub dlsyms;
sub dynamic;
sub dynamic_bs;
sub dynamic_lib;
sub exescan;
sub export_list;
sub extliblist;
sub find_perl;
sub fixin;
sub force;
sub guess_name;
sub has_link_code;
sub init_dirscan;
sub init_main;
sub init_others;
sub install;
sub installbin;
sub libscan;
sub linkext;
sub lsdir;
sub macro;
sub makeaperl;
sub makefile;
sub manifypods;
sub maybe_command;
sub maybe_command_in_dirs;
sub needs_linking;
sub nicetext;
sub parse_abstract;
sub parse_version;
sub pasthru;
sub perl_archive;
sub perl_archive_after;
sub perl_script;
sub perldepend;
sub pm_to_blib;
sub ppd;
sub post_constants;
sub post_initialize;
sub postamble;
sub prefixify;
sub processPL;
sub quote_paren;
sub realclean;
sub replace_manpage_separator;
sub static;
sub static_lib;
sub staticmake;
sub subdir_x;
sub subdirs;
sub test;
sub test_via_harness;
sub test_via_script;
sub tool_autosplit;
sub tool_xsubpp;
sub tools_other;
sub top_targets;
sub writedoc;
sub xs_c;
sub xs_cpp;
sub xs_o;
sub xsubpp_version;
d241 1
a241 1
#use SelfLoader;
d243 1
a243 2
# SelfLoader not smart enough to avoid autoloading DESTROY
sub DESTROY { }
d245 1
a245 1
#1;
d247 3
a249 1
#__DATA__
a267 12
    if (my $cpp = $Config{cpprun}) {
        my $cpp_cmd = $self->const_cccmd;
        $cpp_cmd =~ s/^CCCMD\s*=\s*\$\(CC\)/$cpp/;
        push @@m, '
.c.i:
	'. $cpp_cmd . ' $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c > $*.i
';
    }
    push @@m, '
.c.s:
	$(CCCMD) -S $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c
';
d270 1
a270 1
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c
d274 2
a275 2
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.C
' if !$Is_OS2 and !$Is_Win32 and !$Is_Dos; #Case-specific
d278 1
a278 1
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.cpp
d281 1
a281 1
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.cxx
d284 1
a284 1
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.cc
d337 1
a337 1
    if ($prog = $Config{$name}) {
a368 1
        $cflags{$_} ||= '';
d372 22
a393 1
	$self->{uc $_} ||= $cflags{$_};
a406 3
    $self->{CCFLAGS}  = quote_paren($self->{CCFLAGS});
    $self->{OPTIMIZE} = quote_paren($self->{OPTIMIZE});

a450 7
    if ( $^O eq 'qnx' ) {
      my @@errfiles = @@{$self->{C}};
      for ( @@errfiles ) {
	s/.c$/.err/;
      }
      push( @@otherfiles, @@errfiles, 'perlmain.err' );
    }
d452 6
a457 7
    push(@@otherfiles, qw[./blib $(MAKE_APERL_FILE) 
                         $(INST_ARCHAUTODIR)/extralibs.all
			 perlmain.c tmon.out mon.out so_locations pm_to_blib
			 *$(OBJ_EXT) *$(LIB_EXT) perl.exe perl perl$(EXE_EXT)
			 $(BOOTSTRAP) $(BASEEXT).bso
			 $(BASEEXT).def lib$(BASEEXT).def
			 $(BASEEXT).exp $(BASEEXT).x
a458 7
    if( $Is_VOS ) {
        push(@@otherfiles, qw[*.kp]);
    }
    else {
        push(@@otherfiles, qw[core core.*perl.*.? *perl.core]);
    }

d480 1
a480 2
	q{CCCMD = $(CC) -c $(PASTHRU_INC) $(INC) \\
	$(CCFLAGS) $(OPTIMIZE) \\
d503 1
a503 2
	$self->{uc $m} = quote_paren($self->{uc $m});
	push @@m, uc($m) , ' = ' , $self->{uc $m}, "\n";
d548 5
a552 10
	      VERSION_SYM XS_VERSION 
	      INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB
              INSTALLDIRS
              PREFIX          SITEPREFIX      VENDORPREFIX
	      INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
	      INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
              INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN  INSTALLSCRIPT 
              PERL_LIB        PERL_ARCHLIB 
              SITELIBEXP      SITEARCHEXP 
              LIBPERL_A MYEXTLIB
d554 1
a554 3
	      PERL_INC PERL FULLPERL PERLRUN FULLPERLRUN PERLRUNINST 
              FULLPERLRUNINST ABSPERL ABSPERLRUN ABSPERLRUNINST
              FULL_AR PERL_CORE NOOP NOECHO
d556 1
a556 2
	      / ) 
    {
a557 4

        # pathnames can have sharp signs in them; escape them so
        # make doesn't think it is a comment-start character.
        $self->{$tmp} =~ s/#/\\#/g;
d577 1
d585 1
a585 2
	      /	) 
    {
d596 2
d603 7
a609 6
	      INST_MAN1DIR  MAN1EXT 
              INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR
	      INST_MAN3DIR  MAN3EXT
              INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR
	      /) 
    {
d617 1
a617 2
	     ) 
    {
d632 1
a632 1
.SUFFIXES: .xs .c .C .cpp .i .s .cxx .cc \$(OBJ_EXT)
d649 2
a650 2
INST_LIBDIR      = }. File::Spec->catdir('$(INST_LIB)',@@parentdir)        .q{
INST_ARCHLIBDIR  = }. File::Spec->catdir('$(INST_ARCHLIB)',@@parentdir)    .q{
d652 2
a653 2
INST_AUTODIR     = }. File::Spec->catdir('$(INST_LIB)','auto','$(FULLEXT)')       .q{
INST_ARCHAUTODIR = }. File::Spec->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)')   .q{
d683 6
d709 1
a709 1
	push @@m, "$key : $val\n";
d736 2
a737 2
	my($src) = File::Spec->catfile($self->{PERL_INC},'perl.h');
	my($targ) = File::Spec->catfile($dir,'.exists');
d767 1
d769 22
a790 28
    $attribs{VERSION}  ||= '$(VERSION)';
    $attribs{NAME}     ||= '$(DISTNAME)';
    $attribs{TAR}      ||= 'tar';
    $attribs{TARFLAGS} ||= 'cvf';
    $attribs{ZIP}      ||= 'zip';
    $attribs{ZIPFLAGS} ||= '-r';
    $attribs{COMPRESS} ||= 'gzip --best';
    $attribs{SUFFIX}   ||= '.gz';
    $attribs{SHAR}     ||= 'shar';
    $attribs{PREOP}    ||= "$self->{NOECHO}\$(NOOP)"; # eg update MANIFEST
    $attribs{POSTOP}   ||= "$self->{NOECHO}\$(NOOP)"; # eg remove the distdir
    $attribs{TO_UNIX}  ||= "$self->{NOECHO}\$(NOOP)";

    $attribs{CI}       ||= 'ci -u';
    $attribs{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';
    $attribs{DIST_CP}  ||= 'best';
    $attribs{DIST_DEFAULT} ||= 'tardist';

    $attribs{DISTVNAME} ||= "$attribs{NAME}-$attribs{VERSION}";

    # We've already printed out VERSION and NAME variables.
    delete $attribs{VERSION};
    delete $attribs{NAME};

    my $make = '';
    while(my($var, $value) = each %attribs) {
        $make .= "$var = $value\n";
    }
d792 18
a809 1
    return $make;
d820 2
a821 2

    return <<'MAKE_FRAG';
d823 1
a823 1
	$(NOECHO) $(NOOP)
d825 1
d827 3
a829 1
	$(PERLRUN) "-MExtUtils::Manifest=fullcheck" -e fullcheck
d831 1
d833 3
a835 1
	$(PERLRUN) "-MExtUtils::Manifest=skipcheck" -e skipcheck
d837 1
d839 3
a841 1
	$(PERLRUN) "-MExtUtils::Manifest=mkmanifest" -e mkmanifest
d843 1
d846 2
a847 3

MAKE_FRAG

d861 1
a861 1
	$(PERLRUN) "-MExtUtils::Manifest=maniread" \\
d915 1
a915 1
=item dist_dir
d924 2
a925 2

    return <<'MAKE_FRAG';
d928 1
a928 1
	$(PERLRUN) "-MExtUtils::Manifest=manicopy,maniread" \
d930 2
a931 3

MAKE_FRAG

d934 1
a934 1
=item dist_test
d947 3
a949 3
	cd $(DISTVNAME) && $(ABSPERLRUN) Makefile.PL
	cd $(DISTVNAME) && $(MAKE) $(PASTHRU)
	cd $(DISTVNAME) && $(MAKE) test $(PASTHRU)
d983 1
a983 1
",'	$(PERLRUN) -e \'use ExtUtils::Mksymlists; \\
d1031 2
a1032 2
	'.$self->{NOECHO}.'$(PERLRUN) \
		"-MExtUtils::Mkbootstrap" \
a1061 1
    my $ld_opt = $Is_OS2 ? '$(OPTIMIZE) ' : '';	# Useful on other systems too?
d1066 1
a1066 1
OTHERLDFLAGS = '.$ld_opt.$otherldflags.'
d1079 2
a1080 2
    my $ldrun = $^O eq 'irix' && $self->{LD_RUN_PATH} ?         
                       qq{-rpath "$self->{LD_RUN_PATH}"} : '';
d1090 2
a1091 19
    my $libs = '$(LDLOADLIBS)';

    if ($^O eq 'netbsd') {
	# Use nothing on static perl platforms, and to the flags needed
	# to link against the shared libperl library on shared perl
	# platforms.  We peek at lddlflags to see if we need -Wl,-R
	# or -R to add paths to the run-time library search path.
	if ($Config{'useshrplib'}) {
	    if ($Config{'lddlflags'} =~ /-Wl,-R/) {
		$libs .= ' -L$(PERL_INC) -Wl,-R$(INSTALLARCHLIB)/CORE -lperl';
	    } elsif ($Config{'lddlflags'} =~ /-R/) {
		$libs .= ' -L$(PERL_INC) -R$(INSTALLARCHLIB)/CORE -lperl';
	    }
	}
    }

    push(@@m,
'	LD_RUN_PATH="$(LD_RUN_PATH)" $(LD) '.$ldrun.' $(LDDLFLAGS) '.$ldfrom.
' $(OTHERLDFLAGS) -o $@@ $(MYEXTLIB) $(PERL_ARCHIVE) '.$libs.' $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)');
d1124 16
d1160 1
a1160 1
	    if (File::Spec->file_name_is_absolute($name)) { # /foo/bar
d1162 2
a1163 2
	    } elsif (File::Spec->canonpath($name) eq File::Spec->canonpath(basename($name))) { # foo
		$abs = File::Spec->catfile($dir, $name);
d1165 1
a1165 1
		$abs = File::Spec->canonpath(File::Spec->catfile($Curdir, $name));
a1182 14
=item find_tests

  my $test = $mm->find_tests;

Returns a string suitable for feeding to the shell to return all
tests in t/*.t.

=cut

sub find_tests {
    my($self) = shift;
    return 't/*.t';
}

d1194 1
a1194 3
  $mm->fixin(@@files);

Inserts the sharpbang or equivalent magic number to a set of @@files.
d1199 4
a1202 4
    my($self, @@files) = @@_;

    my($does_shbang) = $Config{'sharpbang'} =~ /^\s*\#\!/;
    for my $file (@@files) {
d1205 1
a1205 1
	open(FIXIN, $file) or croak "Can't process '$file': $!";
a1213 1
        my $interpreter;
d1222 1
a1222 1
	    my(@@absdirs) = reverse grep {File::Spec->file_name_is_absolute} File::Spec->path;
d1228 1
a1228 1
		    $interpreter = File::Spec->catfile($dir,$cmd);
d1266 8
d1289 2
d1348 50
d1401 1
a1401 1
Initializes DIR, XS, PM, C, O_FILES, H, PL_FILES, MAN*PODS, EXE_FILES.
d1409 3
a1411 10

    @@ignore{qw(Makefile.PL test.pl t)} = (1,1,1);

    # ignore the distdir
    $Is_VMS ? $ignore{"$self->{DISTVNAME}.dir"} = 1
            : $ignore{$self->{DISTVNAME}} = 1;

    @@ignore{map lc, keys %ignore} = values %ignore if $Is_VMS;

    foreach $name ($self->lsdir($Curdir)){
d1413 1
a1413 1
	next if $name eq $Curdir or $name eq $Updir or $ignore{$name};
d1417 1
a1417 1
	    $dir{$name} = $name if (-f File::Spec->catfile($name,"Makefile.PL"));
d1436 1
a1436 3
	    else { 
                $pm{$name} = File::Spec->catfile($self->{INST_LIBDIR},$name); 
            }
d1438 1
a1438 1
	    $pm{$name} = File::Spec->catfile($self->{INST_LIBDIR},$name);
d1468 1
a1468 3
    if ($Is_VMS) {
      # avoid logical name collisions by adding directory syntax
      $self->{PMLIBDIRS} = ['./lib', './' . $self->{BASEEXT}]
a1469 5
    }
    else {
      $self->{PMLIBDIRS} = ['lib', $self->{BASEEXT}]
       unless $self->{PMLIBDIRS};
    }
d1486 13
a1498 18
        File::Find::find(sub {
            if (-d $_){
                if ($_ eq "CVS" || $_ eq "RCS"){
                    $File::Find::prune = 1;
                }
                return;
            }
            return if /\#/;
            return if /~$/;    # emacs temp files

	    my $path   = $File::Find::name;
            my $prefix = $self->{INST_LIBDIR};
            my $striplibpath;

	    $prefix =  $self->{INST_LIB} 
                if ($striplibpath = $path) =~ s:^(\W*)lib\W:$1:i;

	    my($inst) = File::Spec->catfile($prefix,$striplibpath);
d1518 1
a1518 1
    foreach my $man (qw(MAN1 MAN3)) {
d1521 1
a1521 2
	    $pods{$man} = 1 unless 
              $self->{"INSTALL${man}DIR"} =~ /^(none|\s*)$/;
d1525 1
a1525 1
    if ($pods{MAN1}) {
d1543 4
d1549 1
a1549 1
		      File::Spec->catfile("\$(INST_MAN1DIR)", basename($name).".\$(MAN1EXT)");
d1554 1
a1554 1
    if ($pods{MAN3}) {
d1581 1
a1581 2
	# To force inclusion, just name it "Configure.pod", or override 
        # MAN3PODS
d1583 1
a1583 1
           if ($self->{PERL_CORE} and $name =~ /(config|setup).*\.pm/is) {
d1589 4
d1594 1
a1594 1
		$manpagename = File::Spec->catfile(split(/::/,$self->{PARENT_NAME}),$manpagename);
d1599 1
a1599 1
		  File::Spec->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
d1607 4
a1610 6
Initializes AR, AR_STATIC_ARGS, BASEEXT, CONFIG, DISTNAME, DLBASE,
EXE_EXT, FULLEXT, FULLPERL, FULLPERLRUN, FULLPERLRUNINST, INST_*,
INSTALL*, INSTALLDIRS, LD, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME,
OBJ_EXT, PARENT_NAME, PERL, PERL_ARCHLIB, PERL_INC, PERL_LIB,
PERL_SRC, PERLRUN, PERLRUNINST, PREFIX, VERSION,
VERSION_FROM, VERSION_SYM, XS_VERSION.
d1622 1
d1627 1
a1627 1
    $self->{FULLEXT} = File::Spec->catdir(split /::/, $self->{NAME});
a1642 1
    $self->{PARENT_NAME} ||= '';
d1652 7
a1658 1
    # --- Initialize PERL_LIB, PERL_SRC
d1666 1
a1666 6
	foreach $dir ($Updir,
                      File::Spec->catdir($Updir,$Updir),
                      File::Spec->catdir($Updir,$Updir,$Updir),
                      File::Spec->catdir($Updir,$Updir,$Updir,$Updir),
                      File::Spec->catdir($Updir,$Updir,$Updir,$Updir,$Updir))
        {
d1668 1
a1668 1
		-f File::Spec->catfile($dir,"config_h.SH")
d1670 1
a1670 1
		-f File::Spec->catfile($dir,"perl.h")
d1672 1
a1672 1
		-f File::Spec->catfile($dir,"lib","Exporter.pm")
a1678 4

    warn "PERL_CORE is set but I can't find your PERL_SRC!\n" if
      $self->{PERL_CORE} and !$self->{PERL_SRC};

d1680 3
a1682 14
	$self->{PERL_LIB}     ||= File::Spec->catdir("$self->{PERL_SRC}","lib");

        if (defined $Cross::platform) {
            $self->{PERL_ARCHLIB} = 
              File::Spec->catdir("$self->{PERL_SRC}","xlib",$Cross::platform);
            $self->{PERL_INC}     = 
              File::Spec->catdir("$self->{PERL_SRC}","xlib",$Cross::platform, 
                                 $Is_Win32?("CORE"):());
        }
        else {
            $self->{PERL_ARCHLIB} = $self->{PERL_LIB};
            $self->{PERL_INC}     = ($Is_Win32) ? 
              File::Spec->catdir($self->{PERL_LIB},"CORE") : $self->{PERL_SRC};
        }
d1686 1
a1686 1
		-s File::Spec->catfile($self->{PERL_SRC},'cflags')
d1690 1
a1690 1
		-s File::Spec->catfile($self->{PERL_SRC},'perlshr_attr.opt')
d1713 3
a1715 3
	$self->{PERL_LIB}     ||= $Config{privlibexp};
	$self->{PERL_ARCHLIB} ||= $Config{archlibexp};
	$self->{PERL_INC}     = File::Spec->catdir("$self->{PERL_ARCHLIB}","CORE"); # wild guess for now
d1718 1
a1718 1
	if (not -f ($perl_h = File::Spec->catfile($self->{PERL_INC},"perl.h"))
d1724 1
a1724 1
	      $found = $dir, last if -e File::Spec->catdir($dir, "Config.pm");
d1728 1
a1728 1
	      if (-e File::Spec->catdir($inc, "perl.h")) {
d1740 1
a1740 2
	unless(-f ($perl_h = File::Spec->catfile($self->{PERL_INC},"perl.h")))
        {
d1765 168
d1934 10
a1943 2
    $self->init_INST;
    $self->init_INSTALL;
a1944 2
    $self->{MAN1EXT} ||= $Config{man1ext};
    $self->{MAN3EXT} ||= $Config{man3ext};
d1951 1
a1951 1
    push(@@{$self->{CONFIG}}, 'shellflags') if $Config{shellflags};
d1956 2
a1957 2
		unless exists $Config{$m};
	$self->{uc $m} ||= $Config{$m};
d1982 1
a1982 1
	unless -f File::Spec->catfile("$self->{PERL_LIB}","Exporter.pm") ||
d1988 2
a1989 5
	$self->{VERSION} = $self->parse_version($self->{VERSION_FROM});
        if( $self->{VERSION} eq 'undef' ) {
	    carp "WARNING: Setting VERSION via file ".
                 "'$self->{VERSION_FROM}' failed\n";
        }
d1993 1
a1993 1
    if (defined $self->{VERSION}) {
d1997 2
a1998 3
    else {
        $self->{VERSION} = '';
    }
a2000 1
    $self->{DISTVNAME} = "$self->{DISTNAME}-$self->{VERSION}";
d2008 15
d2024 3
a2026 2
    # --- Initialize Perl Binary Locations
    $self->init_PERL;
d2055 1
a2055 2
	    ($self->{EXTRALIBS},  $self->{BSLOADLIBS}, 
             $self->{LDLOADLIBS}, $self->{LD_RUN_PATH}) = @@libs;
d2079 1
a2079 1
                        : ($Config{usedl} ? 'dynamic' : 'static');
d2099 1
a2099 1
=item init_INST
d2101 1
a2101 3
    $mm->init_INST;

Called by init_main.  Sets up all INST_* variables.
d2105 3
a2107 2
sub init_INST {
    my($self) = shift;
d2109 2
a2110 2
    $self->{INST_ARCHLIB} ||= File::Spec->catdir($Curdir,"blib","arch");
    $self->{INST_BIN}     ||= File::Spec->catdir($Curdir,'blib','bin');
d2112 1
a2112 17
    # INST_LIB typically pre-set if building an extension after
    # perl has been built and installed. Setting INST_LIB allows
    # you to build directly into, say $Config{privlibexp}.
    unless ($self->{INST_LIB}){
	if ($self->{PERL_CORE}) {
            if (defined $Cross::platform) {
                $self->{INST_LIB} = $self->{INST_ARCHLIB} = 
                  File::Spec->catdir($self->{PERL_LIB},"..","xlib",
                                     $Cross::platform);
            }
            else {
                $self->{INST_LIB} = $self->{INST_ARCHLIB} = $self->{PERL_LIB};
            }
	} else {
	    $self->{INST_LIB} = File::Spec->catdir($Curdir,"blib","lib");
	}
    }
d2114 1
a2114 8
    my @@parentdir = split(/::/, $self->{PARENT_NAME});
    $self->{INST_LIBDIR} = File::Spec->catdir($self->{INST_LIB},@@parentdir);
    $self->{INST_ARCHLIBDIR} = File::Spec->catdir($self->{INST_ARCHLIB},
                                                  @@parentdir);
    $self->{INST_AUTODIR} = File::Spec->catdir($self->{INST_LIB},'auto',
                                               $self->{FULLEXT});
    $self->{INST_ARCHAUTODIR} = File::Spec->catdir($self->{INST_ARCHLIB},
                                                   'auto',$self->{FULLEXT});
d2116 2
a2117 1
    $self->{INST_SCRIPT} ||= File::Spec->catdir($Curdir,'blib','script');
d2119 1
a2119 2
    $self->{INST_MAN1DIR} ||= File::Spec->catdir($Curdir,'blib','man1');
    $self->{INST_MAN3DIR} ||= File::Spec->catdir($Curdir,'blib','man3');
d2121 2
a2122 2
    return 1;
}
d2124 2
a2125 1
=item init_INSTALL
d2127 2
a2128 1
    $mm->init_INSTALL;
d2130 14
a2143 2
Called by init_main.  Sets up all INSTALL_* variables (except
INSTALLDIRS) and PREFIX.
a2144 1
=cut
d2146 11
a2156 370
sub init_INSTALL {
    my($self) = shift;

    $self->init_lib2arch;

    if( $Config{usevendorprefix} ) {
        $Config_Override{installvendorman1dir} =
          File::Spec->catdir($Config{vendorprefixexp}, 'man', 'man$(MAN1EXT)');
        $Config_Override{installvendorman3dir} =
          File::Spec->catdir($Config{vendorprefixexp}, 'man', 'man$(MAN3EXT)');
    }
    else {
        $Config_Override{installvendorman1dir} = '';
        $Config_Override{installvendorman3dir} = '';
    }

    my $iprefix = $Config{installprefixexp} || $Config{installprefix} || 
                  $Config{prefixexp}        || $Config{prefix} || '';
    my $vprefix = $Config{usevendorprefix}  ? $Config{vendorprefixexp} : '';
    my $sprefix = $Config{siteprefixexp}    || '';

    # 5.005_03 doesn't have a siteprefix.
    $sprefix = $iprefix unless $sprefix;

    # There are often no Config.pm defaults for these, but we can make
    # it up.
    unless( $Config{installsiteman1dir} ) {
        $Config_Override{installsiteman1dir} = 
          File::Spec->catdir($sprefix, 'man', 'man$(MAN1EXT)');
    }

    unless( $Config{installsiteman3dir} ) {
        $Config_Override{installsiteman3dir} = 
          File::Spec->catdir($sprefix, 'man', 'man$(MAN3EXT)');
    }

    unless( $Config{installsitebin} ) {
        $Config_Override{installsitebin} =
          File::Spec->catdir($sprefix, 'bin');
    }

    my $u_prefix  = $self->{PREFIX}       || '';
    my $u_sprefix = $self->{SITEPREFIX}   || $u_prefix;
    my $u_vprefix = $self->{VENDORPREFIX} || $u_prefix;

    $self->{PREFIX}       ||= $u_prefix  || $iprefix;
    $self->{SITEPREFIX}   ||= $u_sprefix || $sprefix;
    $self->{VENDORPREFIX} ||= $u_vprefix || $vprefix;

    my $arch    = $Config{archname};
    my $version = $Config{version};

    # default style
    my $libstyle = 'lib/perl5';
    my $manstyle = '';

    if( $self->{LIBSTYLE} ) {
        $libstyle = $self->{LIBSTYLE};
        $manstyle = $self->{LIBSTYLE} eq 'lib/perl5' ? 'lib/perl5' : '';
    }

    # Some systems, like VOS, set installman*dir to '' if they can't
    # read man pages.
    for my $num (1, 3) {
        $self->{'INSTALLMAN'.$num.'DIR'} ||= 'none'
          unless $Config{'installman'.$num.'dir'};
    }

    my %bin_layouts = 
    (
        bin         => { s => $iprefix,
                         r => $u_prefix,
                         d => 'bin' },
        vendorbin   => { s => $vprefix,
                         r => $u_vprefix,
                         d => 'bin' },
        sitebin     => { s => $sprefix,
                         r => $u_sprefix,
                         d => 'bin' },
        script      => { s => $iprefix,
                         r => $u_prefix,
                         d => 'bin' },
    );
    
    my %man_layouts =
    (
        man1dir         => { s => $iprefix,
                             r => $u_prefix,
                             d => 'man/man$(MAN1EXT)',
                             style => $manstyle, },
        siteman1dir     => { s => $sprefix,
                             r => $u_sprefix,
                             d => 'man/man$(MAN1EXT)',
                             style => $manstyle, },
        vendorman1dir   => { s => $vprefix,
                             r => $u_vprefix,
                             d => 'man/man$(MAN1EXT)',
                             style => $manstyle, },

        man3dir         => { s => $iprefix,
                             r => $u_prefix,
                             d => 'man/man$(MAN3EXT)',
                             style => $manstyle, },
        siteman3dir     => { s => $sprefix,
                             r => $u_sprefix,
                             d => 'man/man$(MAN3EXT)',
                             style => $manstyle, },
        vendorman3dir   => { s => $vprefix,
                             r => $u_vprefix,
                             d => 'man/man$(MAN3EXT)',
                             style => $manstyle, },
    );

    my %lib_layouts =
    (
        privlib     => { s => $iprefix,
                         r => $u_prefix,
                         d => '',
                         style => $libstyle, },
        vendorlib   => { s => $vprefix,
                         r => $u_vprefix,
                         d => '',
                         style => $libstyle, },
        sitelib     => { s => $sprefix,
                         r => $u_sprefix,
                         d => 'site_perl',
                         style => $libstyle, },
        
        archlib     => { s => $iprefix,
                         r => $u_prefix,
                         d => "$version/$arch",
                         style => $libstyle },
        vendorarch  => { s => $vprefix,
                         r => $u_vprefix,
                         d => "$version/$arch",
                         style => $libstyle },
        sitearch    => { s => $sprefix,
                         r => $u_sprefix,
                         d => "site_perl/$version/$arch",
                         style => $libstyle },
    );


    # Special case for LIB.
    if( $self->{LIB} ) {
        foreach my $var (keys %lib_layouts) {
            my $Installvar = uc "install$var";

            if( $var =~ /arch/ ) {
                $self->{$Installvar} ||= 
                  File::Spec->catdir($self->{LIB}, $Config{archname});
            }
            else {
                $self->{$Installvar} ||= $self->{LIB};
            }
        }
    }


    my %layouts = (%bin_layouts, %man_layouts, %lib_layouts);
    while( my($var, $layout) = each(%layouts) ) {
        my($s, $r, $d, $style) = @@{$layout}{qw(s r d style)};

        print STDERR "Prefixing $var\n" if $Verbose >= 2;

        my $installvar = "install$var";
        my $Installvar = uc $installvar;
        next if $self->{$Installvar};

        if( $r ) {
            $d = "$style/$d" if $style;
            $self->prefixify($installvar, $s, $r, $d);
        }
        else {
            $self->{$Installvar} = $Config_Override{$installvar} || 
                                   $Config{$installvar};
        }

        print STDERR "  $Installvar == $self->{$Installvar}\n" 
          if $Verbose >= 2;
    }

    return 1;
}

=begin _protected

=item init_lib2arch

    $mm->init_lib2arch

=end _protected

=cut

sub init_lib2arch {
    my($self) = shift;

    # The user who requests an installation directory explicitly
    # should not have to tell us an architecture installation directory
    # as well. We look if a directory exists that is named after the
    # architecture. If not we take it as a sign that it should be the
    # same as the requested installation directory. Otherwise we take
    # the found one.
    for my $libpair ({l=>"privlib",   a=>"archlib"}, 
                     {l=>"sitelib",   a=>"sitearch"},
                     {l=>"vendorlib", a=>"vendorarch"},
                    )
    {
        my $lib = "install$libpair->{l}";
        my $Lib = uc $lib;
        my $Arch = uc "install$libpair->{a}";
        if( $self->{$Lib} && ! $self->{$Arch} ){
            my($ilib) = $Config{$lib};

            $self->prefixify($Arch,$ilib,$self->{$Lib});

            unless (-d $self->{$Arch}) {
                print STDOUT "Directory $self->{$Arch} not found\n" 
                  if $Verbose;
                $self->{$Arch} = $self->{$Lib};
            }
            print STDOUT "Defaulting $Arch to $self->{$Arch}\n" if $Verbose;
        }
    }
}


=item init_PERL

    $mm->init_PERL;

Called by init_main.  Sets up ABSPERL, PERL, FULLPERL and all the
*PERLRUN* permutations.

    PERL is allowed to be miniperl
    FULLPERL must be a complete perl
    ABSPERL is PERL converted to an absolute path

    *PERLRUN contains everything necessary to run perl, find it's
         libraries, etc...

    *PERLRUNINST is *PERLRUN + everything necessary to find the
         modules being built.

=cut

sub init_PERL {
    my($self) = shift;

    my @@defpath = ();
    foreach my $component ($self->{PERL_SRC}, $self->path(), 
                           $Config{binexp}) 
    {
	push @@defpath, $component if defined $component;
    }

    # Build up a set of file names (not command names).
    my $thisperl = File::Spec->canonpath($^X);
    $thisperl .= $Config{exe_ext} unless $thisperl =~ m/$Config{exe_ext}$/i;
    my @@perls = ($thisperl);
    push @@perls, map { "$_$Config{exe_ext}" }
                     ('perl', 'perl5', "perl$Config{version}");

    # miniperl has priority over all but the cannonical perl when in the
    # core.  Otherwise its a last resort.
    my $miniperl = "miniperl$Config{exe_ext}";
    if( $self->{PERL_CORE} ) {
        splice @@perls, 1, 0, $miniperl;
    }
    else {
        push @@perls, $miniperl;
    }

    $self->{PERL} ||=
        $self->find_perl(5.0, \@@perls, \@@defpath, $Verbose );
    # don't check if perl is executable, maybe they have decided to
    # supply switches with perl

    # Define 'FULLPERL' to be a non-miniperl (used in test: target)
    ($self->{FULLPERL} = $self->{PERL}) =~ s/miniperl/perl/i
	unless $self->{FULLPERL};

    # Little hack to get around VMS's find_perl putting "MCR" in front
    # sometimes.
    $self->{ABSPERL} = $self->{PERL};
    my $has_mcr = $self->{ABSPERL} =~ s/^MCR\s*//;
    if( File::Spec->file_name_is_absolute($self->{ABSPERL}) ) {
        $self->{ABSPERL} = '$(PERL)';
    }
    else {
        $self->{ABSPERL} = File::Spec->rel2abs($self->{ABSPERL});
        $self->{ABSPERL} = 'MCR '.$self->{ABSPERL} if $has_mcr;
    }

    # Are we building the core?
    $self->{PERL_CORE} = 0 unless exists $self->{PERL_CORE};

    # How do we run perl?
    foreach my $perl (qw(PERL FULLPERL ABSPERL)) {
        $self->{$perl.'RUN'}  = "\$($perl)";

        # Make sure perl can find itself before it's installed.
        $self->{$perl.'RUN'} .= q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"} 
          if $self->{UNINSTALLED_PERL} || $self->{PERL_CORE};

        $self->{$perl.'RUNINST'} = 
          sprintf q{$(%sRUN) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)"}, $perl;
    }

    return 1;
}

=item init_PERM

  $mm->init_PERM

Called by init_main.  Initializes PERL_*

=cut

sub init_PERM {
    my($self) = shift;

    $self->{PERM_RW}  = 644;
    $self->{PERM_RWX} = 755;

    return 1;
}
    

=item install (o)

Defines the install target.

=cut

sub install {
    my($self, %attribs) = @@_;
    my(@@m);

    push @@m, q{
install :: all pure_install doc_install

install_perl :: all pure_perl_install doc_perl_install

install_site :: all pure_site_install doc_site_install

install_vendor :: all pure_vendor_install doc_vendor_install

pure_install :: pure_$(INSTALLDIRS)_install

doc_install :: doc_$(INSTALLDIRS)_install
	}.$self->{NOECHO}.q{echo Appending installation info to $(INSTALLARCHLIB)/perllocal.pod

pure__install : pure_site_install
	@@echo INSTALLDIRS not defined, defaulting to INSTALLDIRS=site

doc__install : doc_site_install
	@@echo INSTALLDIRS not defined, defaulting to INSTALLDIRS=site

pure_perl_install ::
	}.$self->{NOECHO}.q{$(MOD_INSTALL) \
		read }.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		write }.File::Spec->catfile('$(INSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(INSTALLPRIVLIB) \
		$(INST_ARCHLIB) $(INSTALLARCHLIB) \
		$(INST_BIN) $(INSTALLBIN) \
		$(INST_SCRIPT) $(INSTALLSCRIPT) \
		$(INST_MAN1DIR) $(INSTALLMAN1DIR) \
d2159 1
a2159 24
		}.File::Spec->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{


pure_site_install ::
	}.$self->{NOECHO}.q{$(MOD_INSTALL) \
		read }.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
		write }.File::Spec->catfile('$(INSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(INSTALLSITELIB) \
		$(INST_ARCHLIB) $(INSTALLSITEARCH) \
		$(INST_BIN) $(INSTALLSITEBIN) \
		$(INST_SCRIPT) $(INSTALLSCRIPT) \
		$(INST_MAN1DIR) $(INSTALLSITEMAN1DIR) \
		$(INST_MAN3DIR) $(INSTALLSITEMAN3DIR)
	}.$self->{NOECHO}.q{$(WARN_IF_OLD_PACKLIST) \
		}.File::Spec->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{

pure_vendor_install ::
	}.$self->{NOECHO}.q{$(MOD_INSTALL) \
		$(INST_LIB) $(INSTALLVENDORLIB) \
		$(INST_ARCHLIB) $(INSTALLVENDORARCH) \
		$(INST_BIN) $(INSTALLVENDORBIN) \
		$(INST_SCRIPT) $(INSTALLSCRIPT) \
		$(INST_MAN1DIR) $(INSTALLVENDORMAN1DIR) \
		$(INST_MAN3DIR) $(INSTALLVENDORMAN3DIR)
d2169 1
a2169 1
		>> }.File::Spec->catfile('$(INSTALLARCHLIB)','perllocal.pod').q{
d2179 1
a2179 3
		>> }.File::Spec->catfile('$(INSTALLSITEARCH)','perllocal.pod').q{

doc_vendor_install ::
d2188 1
a2188 1
	q{$(UNINSTALL) }.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{
d2192 1
a2192 1
	q{$(UNINSTALL) }.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{
d2211 1
a2211 1
	my($path)= File::Spec->catfile('$(INST_SCRIPT)', basename($from));
d2222 3
a2224 2
  ? q{FIXIN = pl2bat.bat
} : q{FIXIN = $(PERLRUN) "-MExtUtils::MY" \
d2238 1
a2238 1
$to: $from $self->{MAKEFILE} " . File::Spec->catdir($todir,'.exists') . "
d2349 1
a2349 1
	}.$self->{NOECHO}.q{$(PERLRUNINST) \
d2373 3
a2375 3
    $cccmd =~ s/\$\(INC\)/ "-I$self->{PERL_INC}" /;
    $cccmd .= " $Config{cccdlflags}"
	if ($Config{useshrplib} eq 'true');
d2449 1
a2449 1
    grep(s/^(.*)/"-I$1"/, @@{$perlinc || []});
d2451 2
a2452 2
    $target ||= "perl";
    $tmp    ||= ".";
d2463 1
a2463 1
MAP_PRELIBS   = $Config{perllibs} $Config{cryptlib}
d2480 1
a2480 1
            $lperl  = $libperl = "$dir/$Config{libperl}";
a2491 3
    # SUNOS ld does not take the full path to a shared library
    my $llibperl = $libperl ? '$(MAP_LIBPERL)' : '-lperl';

a2493 1
LLIBPERL    = $llibperl
d2506 2
d2511 1
a2511 1
	\$(MAP_LINKCMD) -o \$\@@ \$(OPTIMIZE) $tmp/perlmain\$(OBJ_EXT) \$(LDFROM) \$(MAP_STATIC) \$(LLIBPERL) `cat \$(INST_ARCHAUTODIR)/extralibs.all` \$(MAP_PRELIBS)
d2519 1
a2519 1
    push @@m, qq{\tcd $tmp && $cccmd "-I\$(PERL_INC)" perlmain.c\n};
d2524 1
a2524 1
	}.$self->{NOECHO}.q{$(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \\
d2541 1
a2541 1
		>> }.File::Spec->catfile('$(INSTALLARCHLIB)','perllocal.pod').q{
d2549 1
a2549 1
	}.$self->{CP}.q{ $(MAP_TARGET) }.File::Spec->catfile('$(INSTALLBIN)','$(MAP_TARGET)').q{
d2585 1
a2585 1
	$(PERLRUN) Makefile.PL }.join(" ",map(qq["$_"],@@ARGV)).q{
d2590 4
d2613 1
a2613 1
	$pod2man_exe = File::Spec->catfile($self->{PERL_SRC},'pod','pod2man');
d2615 1
a2615 1
	$pod2man_exe = File::Spec->catfile($Config{scriptdirexp},'pod2man');
d2619 1
a2619 1
      $pod2man_exe = File::Spec->catfile($self->{PERL_INC}, "pod", "pod2man");
d2638 2
a2639 2
-e 'system(q[$(PERLRUN) $(POD2MAN_EXE) ].qq[$$_>$$m{$$_}])==0 or warn "Couldn\\047t install $$m{$$_}\n";' \\
-e 'chmod(oct($(PERM_RW)), $$m{$$_}) or warn "chmod $(PERM_RW) $$m{$$_}: $$!\n";}'
d2678 1
a2678 1
	    if (File::Spec->file_name_is_absolute($name)) { # /foo/bar
d2680 2
a2681 2
	    } elsif (File::Spec->canonpath($name) eq File::Spec->canonpath(basename($name))) { # bar
		$abs = File::Spec->catfile($dir, $name);
d2683 1
a2683 1
		$abs = File::Spec->catfile($Curdir, $name);
d2714 1
a2714 2
    confess("Needs_linking called too early") if 
      $caller =~ /^ExtUtils::MakeMaker::/;
a2745 27
=item parse_abstract

parse a file and return what you think is the ABSTRACT

=cut

sub parse_abstract {
    my($self,$parsefile) = @@_;
    my $result;
    local *FH;
    local $/ = "\n";
    open(FH,$parsefile) or die "Could not open '$parsefile': $!";
    my $inpod = 0;
    my $package = $self->{DISTNAME};
    $package =~ s/-/::/g;
    while (<FH>) {
        $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
        next if !$inpod;
        chop;
        next unless /^($package\s-\s)(.*)/;
        $result = $2;
        last;
    }
    close FH;
    return $result;
}

d2750 1
a2750 2
is. $VERSION should be for all to see, so our $VERSION or plain $VERSION
are okay, but my $VERSION is not.
d2763 1
a2763 1
	next if $inpod || /^\s*#/;
d2776 1
a2776 1
        local $^W = 0;
d2779 1
d2783 8
d2792 18
a2809 1
    $result = "undef" unless defined $result;
a2812 1

d2828 1
a2828 1
    foreach $key (qw(LIB LIBPERL_A LINKTYPE PREFIX OPTIMIZE)) {
a2831 4
    foreach $key (qw(DEFINE INC)) {
	push @@pasthru, "PASTHRU_$key=\"\$(PASTHRU_$key)\"";
    }

d2836 16
d2913 1
d2948 55
a3039 10
sub _pm_to_blib_flush {
    my ($self, $autodir, $rr, $ra, $rl) = @@_;
    $$rr .= 
q{	}.$self->{NOECHO}.q[$(PERLRUNINST) "-MExtUtils::Install" \
	-e "pm_to_blib({qw{].qq[@@$ra].q[}},'].$autodir.q{','$(PM_FILTER)')"
};
    @@$ra = ();
    $$rl = 0;
}

d3042 2
a3043 2
    my($autodir) = File::Spec->catdir('$(INST_LIB)','auto');
    my $r = q{
d3045 4
a3049 14
    my %pm_to_blib = %{$self->{PM}};
    my @@a;
    my $l = 0;
    while (my ($pm, $blib) = each %pm_to_blib) {
	my $la = length $pm;
	my $lb = length $blib;
	if ($l + $la + $lb + @@a / 2 > 200) { # limit line length
	    _pm_to_blib_flush($self, $autodir, \$r, \@@a, \$l);
        }
        push @@a, $pm, $blib;
	$l += $la + $lb;
    }
    _pm_to_blib_flush($self, $autodir, \$r, \@@a, \$l);
    return $r.q{	}.$self->{NOECHO}.q{$(TOUCH) $@@};
a3087 76
=item ppd

Defines target that creates a PPD (Perl Package Description) file
for a binary distribution.

=cut

sub ppd {
    my($self) = @@_;

    if ($self->{ABSTRACT_FROM}){
        $self->{ABSTRACT} = $self->parse_abstract($self->{ABSTRACT_FROM}) or
            carp "WARNING: Setting ABSTRACT via file ".
                 "'$self->{ABSTRACT_FROM}' failed\n";
    }

    my ($pack_ver) = join ",", (split (/\./, $self->{VERSION}), (0)x4)[0..3];

    my $abstract = $self->{ABSTRACT} || '';
    $abstract =~ s/\n/\\n/sg;
    $abstract =~ s/</&lt;/g;
    $abstract =~ s/>/&gt;/g;

    my $author = $self->{AUTHOR} || '';
    $author =~ s/</&lt;/g;
    $author =~ s/>/&gt;/g;
    $author =~ s/@@/\\@@/g;

    my $make_ppd = sprintf <<'PPD_OUT', $pack_ver, $abstract, $author;
# Creates a PPD (Perl Package Description) for a binary distribution.
ppd:
	@@$(PERL) -e "print qq{<SOFTPKG NAME=\"$(DISTNAME)\" VERSION=\"%s\">\n\t<TITLE>$(DISTNAME)</TITLE>\n\t<ABSTRACT>%s</ABSTRACT>\n\t<AUTHOR>%s</AUTHOR>\n}" > $(DISTNAME).ppd
PPD_OUT


    $make_ppd .= '	@@$(PERL) -e "print qq{\t<IMPLEMENTATION>\n';
    foreach my $prereq (sort keys %{$self->{PREREQ_PM}}) {
        my $pre_req = $prereq;
        $pre_req =~ s/::/-/g;
        my ($dep_ver) = join ",", (split (/\./, $self->{PREREQ_PM}{$prereq}), 
                                  (0) x 4) [0 .. 3];
        $make_ppd .= sprintf q{\t\t<DEPENDENCY NAME=\"%s\" VERSION=\"%s\" />\n}, $pre_req, $dep_ver;
    }
    $make_ppd .= qq[}" >> \$(DISTNAME).ppd\n];


    $make_ppd .= sprintf <<'PPD_OUT', $Config{archname};
	@@$(PERL) -e "print qq{\t\t<OS NAME=\"$(OSNAME)\" />\n\t\t<ARCHITECTURE NAME=\"%s\" />\n
PPD_OUT

    chomp $make_ppd;


    if ($self->{PPM_INSTALL_SCRIPT}) {
        if ($self->{PPM_INSTALL_EXEC}) {
            $make_ppd .= sprintf q{\t\t<INSTALL EXEC=\"%s\">%s</INSTALL>\n},
                  $self->{PPM_INSTALL_EXEC}, $self->{PPM_INSTALL_SCRIPT};
        }
        else {
            $make_ppd .= sprintf q{\t\t<INSTALL>%s</INSTALL>\n}, 
                  $self->{PPM_INSTALL_SCRIPT};
        }
    }

    my ($bin_location) = $self->{BINARY_LOCATION} || '';
    $bin_location =~ s/\\/\\\\/g;

    $make_ppd .= sprintf q{\t\t<CODEBASE HREF=\"%s\" />\n}, $bin_location;
    $make_ppd .= q{\t</IMPLEMENTATION>\n};
    $make_ppd .= q{</SOFTPKG>\n};

    $make_ppd .= '}" >> $(DISTNAME).ppd';

    return $make_ppd;
}

d3090 2
a3091 12
  $MM->prefixify($var, $prefix, $new_prefix, $default);

Using either $MM->{uc $var} || $Config{lc $var}, it will attempt to
replace it's $prefix with a $new_prefix.  Should the $prefix fail to
match it sill simply set it to the $new_prefix + $default.

This is for heuristics which attempt to create directory structures
that mirror those of the installed perl.

For example:

    $MM->prefixify('installman1dir', '/usr', '/home/foo', 'man/man1');
d3093 2
a3094 4
this will attempt to remove '/usr' from the front of the
$MM->{INSTALLMAN1DIR} path (initializing it to $Config{installman1dir}
if necessary) and replace it with '/home/foo'.  If this fails it will
simply use '/home/foo/man/man1'.
d3099 4
a3102 18
    my($self,$var,$sprefix,$rprefix,$default) = @@_;

    my $path = $self->{uc $var} || 
               $Config_Override{lc $var} || $Config{lc $var} || '';

    print STDERR "  prefixify $var => $path\n" if $Verbose >= 2;
    print STDERR "    from $sprefix to $rprefix\n" if $Verbose >= 2;

    unless( $path =~ s{^\Q$sprefix\E\b}{$rprefix}s ) {

        print STDERR "    cannot prefix, using default.\n" if $Verbose >= 2;
        print STDERR "    no default!\n" if !$default && $Verbose >= 2;

        $path = File::Spec->catdir($rprefix, $default) if $default;
    }

    print "    now $path\n" if $Verbose >= 2;
    return $self->{uc $var} = $path;
a3104 1

d3126 1
a3126 1
	\$(PERLRUNINST) $plfile $target
a3132 16
=item quote_paren

Backslashes parentheses C<()> in command line arguments.
Doesn't handle recursive Makefile C<$(...)> constructs,
but handles simple ones.

=cut

sub quote_paren {
    local $_ = shift;
    s/\$\((.+?)\)/\$\\\\($1\\\\)/g;	# protect $(...)
    s/(?<!\\)([()])/\\$1/g;		# quote unprotected
    s/\$\\\\\((.+?)\\\\\)/\$($1)/g;	# unprotect $(...)
    return $_;
}

a3141 1

d3147 3
a3149 14
    my $sub;
    if( $Is_Win32  &&  Win32::IsWin95() ) {
        $sub = <<'REALCLEAN';
	-cd %s
	-$(PERLRUN) -e "exit unless -f shift; system q{$(MAKE) realclean}" %s
	-cd ..
REALCLEAN
    }
    else {
        $sub = <<'REALCLEAN';
	-cd %s && $(TEST_F) %s && $(MAKE) %s realclean
REALCLEAN
    }

a3154 1
    push(@@m, "	$self->{RM_RF} \$(DISTVNAME)\n");
a3184 2
  my $man_name = $MM->replace_manpage_separator($file_path);

d3186 1
a3186 2
form 'Foo/Bar.pm' and replaces the slash with C<::> or something else
safe for a man page file name.  Returns the replacement.
d3192 8
a3199 3

    $man =~ s,/+,::,g;
    return $man;
d3239 1
a3239 1
    # If this extension has its own library (eg SDBM_File)
d3282 1
a3282 1
	@@static = File::Spec->catfile($self->{INST_ARCHLIB},
d3319 2
a3320 3
	if ($Config{'make'} =~ /dmake/i) {
	    # dmake-specific
	    return <<EOT;
d3324 1
a3324 1
	\$(MAKE) -f \$(FIRST_MAKEFILE) all \$(PASTHRU)
d3328 2
a3329 10
        } elsif ($Config{'make'} =~ /nmake/i) {
	    # nmake-specific
	    return <<EOT;
subdirs ::
	cd $subdir
	\$(MAKE) -f \$(FIRST_MAKEFILE) all \$(PASTHRU)
	cd ..
EOT
	}
    } else {
d3333 2
a3334 1
	$self->{NOECHO}cd $subdir && \$(MAKE) -f \$(FIRST_MAKEFILE) all \$(PASTHRU)
d3378 1
a3378 1
    my $tests = $attribs{TESTS} || '';
d3380 1
a3380 1
        $tests = $self->find_tests;
d3395 2
a3396 8

    if ($Is_Win32 && Win32::IsWin95()) {
        push(@@m, map(qq{\t$self->{NOECHO}\$(PERLRUN) -e "exit unless -f shift; chdir '$_'; system q{\$(MAKE) test \$(PASTHRU)}" $self->{MAKEFILE}\n}, @@{$self->{DIR}}));
    }
    else {
        push(@@m, map("\t$self->{NOECHO}cd $_ && \$(TEST_F) $self->{MAKEFILE} && \$(MAKE) test \$(PASTHRU)\n", @@{$self->{DIR}}));
    }

d3402 2
a3403 4
    push(@@m, $self->test_via_harness('$(FULLPERLRUN)', '$(TEST_FILES)')) 
      if $tests;
    push(@@m, $self->test_via_script('$(FULLPERLRUN)', '$(TEST_FILE)')) 
      if -f "test.pl";
d3407 1
a3407 2
    push(@@m, $self->test_via_script('$(FULLPERLRUN) $(TESTDB_SW)', 
                                    '$(TEST_FILE)'));
d3428 1
a3428 1
=item test_via_harness (override)
d3430 1
a3430 2
For some reason which I forget, Unix machines like to have
PERL_DL_NONLAZY set for tests.
d3436 2
a3437 1
    return $self->SUPER::test_via_harness("PERL_DL_NONLAZY=1 $perl", $tests);
d3440 1
a3440 1
=item test_via_script (override)
d3442 1
a3442 1
Again, the PERL_DL_NONLAZY thing.
d3448 3
a3450 1
    return $self->SUPER::test_via_script("PERL_DL_NONLAZY=1 $perl", $script);
d3461 2
d3465 2
a3466 3
    $asl = "\$\$AutoSplit::Maxlen=$attribs{MAXLEN};" if $attribs{MAXLEN};

    return sprintf <<'MAKE_FRAG', $asl;
d3468 2
a3469 4
AUTOSPLITFILE = $(PERLRUN) -e 'use AutoSplit; %s autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1) ;'

MAKE_FRAG

d3495 1
a3495 1
MKPATH = $(PERLRUN) "-MExtUtils::Command" -e mkpath
d3501 1
a3501 1
EQUALIZE_TIMESTAMP = $(PERLRUN) "-MExtUtils::Command" -e eqtime
d3518 1
a3518 1
MOD_INSTALL = $(PERL) "-I$(INST_LIB)" "-I$(PERL_LIB)" "-MExtUtils::Install" \
d3527 1
a3527 1
UNINSTALL =   $(PERLRUN) "-MExtUtils::Install" \
d3545 2
a3546 2
    my($xsdir)  = File::Spec->catdir($self->{PERL_LIB},"ExtUtils");
    my(@@tmdeps) = File::Spec->catdir('$(XSUBPPDIR)','typemap');
d3565 1
a3565 1
    my $xsubpp_version = $self->xsubpp_version(File::Spec->catfile($xsdir,"xsubpp"));
a3588 1
XSUBPP_EXTRA_ARGS = 
d3605 1
a3605 1
    my $command = qq{$self->{PERL} "-I$self->{PERL_LIB}" $xsubpp -v 2>&1};
d3658 3
d3663 1
a3663 1
all :: pure_all manifypods
d3687 18
d3731 7
d3767 1
a3767 1
	$(PERLRUN) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
d3782 1
a3782 1
	$(PERLRUN) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.cpp
d3798 2
a3799 2
	$(PERLRUN) $(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
	$(CCCMD) $(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE) $*.c
d3806 2
a3807 2
to be linked to dynamic extensions. UNIX does not have one but other
OSs might have one.
d3813 1
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d9 1
a9 1
use Config         qw(%Config);
d11 1
d13 1
a13 1

d15 2
a16 4
            $Is_Mac $Is_OS2 $Is_VMS $Is_Win32 $Is_Win95  $Is_Dos $Is_VOS
            $Is_QNX $Is_AIX $Is_OSF $Is_IRIX  $Is_NetBSD $Is_BSD
            $Is_SunOS4 $Is_Solaris $Is_SunOS
            $Verbose %pm %static
d22 1
a22 1
$VERSION = '1.42';
d27 6
a32 17
$Is_OS2     = $^O eq 'os2';
$Is_Mac     = $^O eq 'MacOS';
$Is_Win32   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
$Is_Win95   = $Is_Win32 && Win32::IsWin95();
$Is_Dos     = $^O eq 'dos';
$Is_VOS     = $^O eq 'vos';
$Is_VMS     = $^O eq 'VMS';
$Is_QNX     = $^O eq 'qnx';
$Is_AIX     = $^O eq 'aix';
$Is_OSF     = $^O eq 'dec_osf';
$Is_IRIX    = $^O eq 'irix';
$Is_NetBSD  = $^O eq 'netbsd';
$Is_SunOS4  = $^O eq 'sunos';
$Is_Solaris = $^O eq 'solaris';
$Is_SunOS   = $Is_SunOS4 || $Is_Solaris;
$Is_BSD     = $^O =~ /^(?:free|net|open)bsd|bsdos$/;

d68 1
a68 2
sections and complain loudly to the makemaker@@perl.org mailing list.
Better yet, provide a patch.
d78 85
a162 4
# we have these globals to cache the values.  Faster and shrtr.
my $Curdir  = __PACKAGE__->curdir;
my $Rootdir = __PACKAGE__->rootdir;
my $Updir   = __PACKAGE__->updir;
d164 2
d167 1
a167 1
=head2 Methods
d169 1
a169 1
=over 4
d171 1
a171 9
=item os_flavor (o)

Simply says that we're Unix.

=cut

sub os_flavor {
    return('Unix');
}
d173 1
d346 1
a346 1
clean :: clean_subdirs
d348 16
d366 1
a366 1
    if ( $Is_QNX ) {
a375 1
                         $(INST_ARCHAUTODIR)/extralibs.ld
a386 3

        # core.\d+
        push(@@otherfiles, map { "core." . "[0-9]"x$_ } (1..5));
d389 1
a389 1
    push @@m, "\t-\$(RM_RF) @@otherfiles\n";
d392 1
a392 1
	 "\t-\$(MV) \$(FIRST_MAKEFILE) \$(MAKEFILE_OLD) \$(DEV_NULL)\n");
a397 32

=item clean_subdirs_target

  my $make_frag = $MM->clean_subdirs_target;

Returns the clean_subdirs target.  This is used by the clean target to
call clean on any subdirectories which contain Makefiles.

=cut

sub clean_subdirs_target {
    my($self) = shift;

    # No subdirectories, no cleaning.
    return <<'NOOP_FRAG' unless @@{$self->{DIR}};
clean_subdirs :
	$(NOECHO) $(NOOP)
NOOP_FRAG


    my $clean = "clean_subdirs :\n";

    for my $dir (@@{$self->{DIR}}) {
        $clean .= sprintf <<'MAKE_FRAG', $dir;
	-cd %s && $(TEST_F) $(FIRST_MAKEFILE) && $(MAKE) clean
MAKE_FRAG
    }

    return $clean;
}


d433 1
a433 1
	next if $once_only{$m};
d469 1
a469 3
  my $make_frag = $mm->constants;

Prints out macros for lots of constants.
d475 1
a475 1
    my @@m = ();
d477 1
a477 1
    for my $macro (qw(
d479 3
a481 7
              AR_STATIC_ARGS DIRFILESEP
              NAME NAME_SYM 
              VERSION    VERSION_MACRO    VERSION_SYM DEFINE_VERSION
              XS_VERSION XS_VERSION_MACRO             XS_DEFINE_VERSION
              INST_ARCHLIB INST_SCRIPT INST_BIN INST_LIB
              INST_MAN1DIR INST_MAN3DIR
              MAN1EXT      MAN3EXT
d483 6
a488 9
              DESTDIR PREFIX
              PERLPREFIX      SITEPREFIX      VENDORPREFIX
                   ),
                   (map { ("INSTALL".$_,
                          "DESTINSTALL".$_)
                        } $self->installvars),
                   qw(
              PERL_LIB    
              PERL_ARCHLIB
d490 4
a493 7
              FIRST_MAKEFILE MAKEFILE_OLD MAKE_APERL_FILE 
              PERLMAINCC PERL_SRC PERL_INC 
              PERL            FULLPERL          ABSPERL
              PERLRUN         FULLPERLRUN       ABSPERLRUN
              PERLRUNINST     FULLPERLRUNINST   ABSPERLRUNINST
              PERL_CORE
              PERM_RW PERM_RWX
d495 1
a495 1
	      ) ) 
d497 1
a497 1
	next unless defined $self->{$macro};
d501 2
a502 2
        $self->{$macro} =~ s/#/\\#/g;
	push @@m, "$macro = $self->{$macro}\n";
d506 10
a515 3
MAKEMAKER   = $self->{MAKEMAKER}
MM_VERSION  = $self->{MM_VERSION}
MM_REVISION = $self->{MM_REVISION}
d525 1
a525 1
    for my $macro (qw/
d530 2
a531 2
	next unless defined $self->{$macro};
	push @@m, "$macro = $self->{$macro}\n";
d536 6
a541 6
XS_FILES = ".$self->wraplist(sort keys %{$self->{XS}})."
C_FILES  = ".$self->wraplist(@@{$self->{C}})."
O_FILES  = ".$self->wraplist(@@{$self->{O_FILES}})."
H_FILES  = ".$self->wraplist(@@{$self->{H}})."
MAN1PODS = ".$self->wraplist(sort keys %{$self->{MAN1PODS}})."
MAN3PODS = ".$self->wraplist(sort keys %{$self->{MAN3PODS}})."
d544 20
d566 18
d585 1
a585 1
CONFIGDEP = $(PERL_ARCHLIB)$(DIRFILESEP)Config.pm $(PERL_INC)$(DIRFILESEP)config.h
d588 5
d594 2
a595 11
    push @@m, qq{
# Where to build things
INST_LIBDIR      = $self->{INST_LIBDIR}
INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}

INST_AUTODIR     = $self->{INST_AUTODIR}
INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}

INST_STATIC      = $self->{INST_STATIC}
INST_DYNAMIC     = $self->{INST_DYNAMIC}
INST_BOOT        = $self->{INST_BOOT}
d598 13
d612 9
a620 7
    push @@m, qq{
# Extra linker info
EXPORT_LIST        = $self->{EXPORT_LIST}
PERL_ARCHIVE       = $self->{PERL_ARCHIVE}
PERL_ARCHIVE_AFTER = $self->{PERL_ARCHIVE_AFTER}
};

d622 2
d625 2
a626 1
TO_INST_PM = ".$self->wraplist(sort keys %{$self->{PM}})."
d628 2
a629 2
PM_TO_BLIB = ".$self->wraplist(%{$self->{PM}})."
";
a633 1

d672 2
a673 2
	my($src) = $self->catfile($self->{PERL_INC},'perl.h');
	my($targ) = $self->catfile($dir,'.exists');
d684 2
a685 2
	\$(NOECHO) \$(MKPATH) $targdir
	\$(NOECHO) \$(EQUALIZE_TIMESTAMP) $src $targ
d688 1
a688 1
	-\$(NOECHO) \$(CHMOD) \$(PERM_RWX) $targdir
d694 1
a694 25
=item init_DEST

  $mm->init_DEST

Defines the DESTDIR and DEST* variables paralleling the INSTALL*.

=cut

sub init_DEST {
    my $self = shift;

    # Initialize DESTDIR
    $self->{DESTDIR} ||= '';

    # Make DEST variables.
    foreach my $var ($self->installvars) {
        my $destvar = 'DESTINSTALL'.$var;
        $self->{$destvar} ||= '$(DESTDIR)$(INSTALL'.$var.')';
    }
}


=item init_dist

  $mm->init_dist;
a697 72
  macro         description                     default

  TAR           tar command to use              tar
  TARFLAGS      flags to pass to TAR            cvf

  ZIP           zip command to use              zip
  ZIPFLAGS      flags to pass to ZIP            -r

  COMPRESS      compression command to          gzip --best
                use for tarfiles
  SUFFIX        suffix to put on                .gz 
                compressed files

  SHAR          shar command to use             shar

  PREOP         extra commands to run before
                making the archive 
  POSTOP        extra commands to run after
                making the archive

  TO_UNIX       a command to convert linefeeds
                to Unix style in your archive 

  CI            command to checkin your         ci -u
                sources to version control
  RCS_LABEL     command to label your sources   rcs -Nv$(VERSION_SYM): -q
                just after CI is run

  DIST_CP       $how argument to manicopy()     best
                when the distdir is created

  DIST_DEFAULT  default target to use to        tardist
                create a distribution

  DISTVNAME     name of the resulting archive   $(DISTNAME)-$(VERSION)
                (minus suffixes)

=cut

sub init_dist {
    my $self = shift;

    $self->{TAR}      ||= 'tar';
    $self->{TARFLAGS} ||= 'cvf';
    $self->{ZIP}      ||= 'zip';
    $self->{ZIPFLAGS} ||= '-r';
    $self->{COMPRESS} ||= 'gzip --best';
    $self->{SUFFIX}   ||= '.gz';
    $self->{SHAR}     ||= 'shar';
    $self->{PREOP}    ||= '$(NOECHO) $(NOOP)'; # eg update MANIFEST
    $self->{POSTOP}   ||= '$(NOECHO) $(NOOP)'; # eg remove the distdir
    $self->{TO_UNIX}  ||= '$(NOECHO) $(NOOP)';

    $self->{CI}       ||= 'ci -u';
    $self->{RCS_LABEL}||= 'rcs -Nv$(VERSION_SYM): -q';
    $self->{DIST_CP}  ||= 'best';
    $self->{DIST_DEFAULT} ||= 'tardist';

    ($self->{DISTNAME} = $self->{NAME}) =~ s{::}{-}g unless $self->{DISTNAME};
    $self->{DISTVNAME} ||= $self->{DISTNAME}.'-'.$self->{VERSION};

}

=item dist (o)

  my $dist_macros = $mm->dist(%overrides);

Generates a make fragment defining all the macros initialized in
init_dist.

%overrides can be used to override any of the above.

d703 25
d729 2
a730 9
    foreach my $key (qw( 
            TAR TARFLAGS ZIP ZIPFLAGS COMPRESS SUFFIX SHAR
            PREOP POSTOP TO_UNIX
            CI RCS_LABEL DIST_CP DIST_DEFAULT
            DISTNAME DISTVNAME
           ))
    {
        my $value = $attribs{$key} || $self->{$key};
        $make .= "$key = $value\n";
d773 2
a774 1
    return q{
d777 3
a779 3
	  -e "@@all = keys %{ maniread() };" \\
	  -e "print(qq{Executing $(CI) @@all\n}); system(qq{$(CI) @@all});" \\
	  -e "print(qq{Executing $(RCS_LABEL) ...\n}); system(qq{$(RCS_LABEL) @@all});"
d781 1
d786 1
a786 4
  my $dist_make_fragment = $MM->dist_core;

Puts the targets necessary for 'make dist' together into one make
fragment.
d792 5
a797 51
    my $make_frag = '';
    foreach my $target (qw(dist tardist uutardist tarfile zipdist zipfile 
                           shdist))
    {
        my $method = $target.'_target';
        $make_frag .= "\n";
        $make_frag .= $self->$method();
    }

    return $make_frag;
}


=item B<dist_target>

  my $make_frag = $MM->dist_target;

Returns the 'dist' target to make an archive for distribution.  This
target simply checks to make sure the Makefile is up-to-date and
depends on $(DIST_DEFAULT).

=cut

sub dist_target {
    my($self) = shift;

    my $date_check = $self->oneliner(<<'CODE', ['-l']);
print 'Warning: Makefile possibly out of date with $(VERSION_FROM)'
    if -e '$(VERSION_FROM)' and -M '$(VERSION_FROM)' < -M '$(FIRST_MAKEFILE)';
CODE

    return sprintf <<'MAKE_FRAG', $date_check;
dist : $(DIST_DEFAULT) $(FIRST_MAKEFILE)
	$(NOECHO) %s
MAKE_FRAG
}

=item B<tardist_target>

  my $make_frag = $MM->tardist_target;

Returns the 'tardist' target which is simply so 'make tardist' works.
The real work is done by the dynamically named tardistfile_target()
method, tardist should have that as a dependency.

=cut

sub tardist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
a798 7
	$(NOECHO) $(NOOP)
MAKE_FRAG
}

=item B<zipdist_target>

  my $make_frag = $MM->zipdist_target;
a799 10
Returns the 'zipdist' target which is simply so 'make zipdist' works.
The real work is done by the dynamically named zipdistfile_target()
method, zipdist should have that as a dependency.

=cut

sub zipdist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
a800 16
	$(NOECHO) $(NOOP)
MAKE_FRAG
}

=item B<tarfile_target>

  my $make_frag = $MM->tarfile_target;

The name of this target is the name of the tarball generated by
tardist.  This target does the actual work of turning the distdir into
a tarball.

=cut

sub tarfile_target {
    my($self) = shift;
a801 1
    return <<'MAKE_FRAG';
a808 12
MAKE_FRAG
}

=item zipfile_target

  my $make_frag = $MM->zipfile_target;

The name of this target is the name of the zip file generated by
zipdist.  This target does the actual work of turning the distdir into
a zip file.

=cut
a809 4
sub zipfile_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
a814 8
MAKE_FRAG
}

=item uutardist_target

  my $make_frag = $MM->uutardist_target;

Converts the tarfile into a uuencoded file
a815 6
=cut

sub uutardist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
d817 3
a819 4
	uuencode $(DISTVNAME).tar$(SUFFIX) $(DISTVNAME).tar$(SUFFIX) > $(DISTVNAME).tar$(SUFFIX)_uu
MAKE_FRAG
}

a820 12
=item shdist_target

  my $make_frag = $MM->shdist_target;

Converts the distdir into a shell archive.

=cut

sub shdist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
d826 2
a827 1
MAKE_FRAG
d830 1
a830 1
=item distdir
d837 1
a837 4
# For backwards compatibility.
*dist_dir = *distdir;

sub distdir {
d841 1
a841 1
distdir : metafile metafile_addtomanifest
d880 1
a880 1
    return '' unless ($Is_AIX && $self->needs_linking() );
d919 5
a923 2
dynamic :: $(FIRST_MAKEFILE) $(INST_DYNAMIC) $(INST_BOOT)
	$(NOECHO) $(NOOP)
d939 2
a940 2
    return <<'MAKE_FRAG';
BOOTSTRAP = $(BASEEXT).bs
d945 3
a947 3
$(BOOTSTRAP): $(FIRST_MAKEFILE) $(BOOTDEP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
	$(NOECHO) $(ECHO) "Running Mkbootstrap for $(NAME) ($(BSLOADLIBS))"
	$(NOECHO) $(PERLRUN) \
d949 2
a950 2
		-e "Mkbootstrap('$(BASEEXT)','$(BSLOADLIBS)');"
	$(NOECHO) $(TOUCH) $(BOOTSTRAP)
d953 3
a955 3
$(INST_BOOT): $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
	$(NOECHO) $(RM_RF) $(INST_BOOT)
	-$(CP) $(BOOTSTRAP) $(INST_BOOT)
d957 1
a957 1
MAKE_FRAG
d976 1
a976 1
    $armaybe = 'ar' if ($Is_OSF and $armaybe eq ':');
a978 1
    my $ld_fix = $Is_OS2 ? '|| ( $(RM_F) $@@ && sh -c false )' : '';
a984 1
INST_DYNAMIC_FIX = '.$ld_fix.'
d986 1
a986 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
d993 1
a993 1
    $ldfrom = "-all $ldfrom -none" if $Is_OSF;
d996 1
a996 1
    my $ldrun = $Is_IRIX && $self->{LD_RUN_PATH} ?         
d1009 1
a1009 1
    if ($Is_NetBSD) {
d1025 1
a1025 1
' $(OTHERLDFLAGS) -o $@@ $(MYEXTLIB) $(PERL_ARCHIVE) '.$libs.' $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST) $(INST_DYNAMIC_FIX)');
d1068 1
a1068 1
        print "Looking for perl $ver by these names:
a1073 15

    my $stderr_duped = 0;
    local *STDERR_COPY;
    unless ($Is_BSD) {
        if( open(STDERR_COPY, '>&STDERR') ) {
            $stderr_duped = 1;
        }
        else {
            warn <<WARNING;
find_perl() can't dup STDERR: $!
You might see some garbage while we search for Perl
WARNING
        }
    }

d1075 21
a1095 37
        foreach $dir (@@$dirs){
            next unless defined $dir; # $self->{PERL_SRC} may be undefined
            my ($abs, $val);
            if ($self->file_name_is_absolute($name)) {     # /foo/bar
                $abs = $name;
            } elsif ($self->canonpath($name) eq 
                     $self->canonpath(basename($name))) {  # foo
                $abs = $self->catfile($dir, $name);
            } else {                                            # foo/bar
                $abs = $self->catfile($Curdir, $name);
            }
            print "Checking $abs\n" if ($trace >= 2);
            next unless $self->maybe_command($abs);
            print "Executing $abs\n" if ($trace >= 2);

            my $version_check = qq{$abs -e "require $ver; print qq{VER_OK\n}"};
            # To avoid using the unportable 2>&1 to supress STDERR,
            # we close it before running the command.
            # However, thanks to a thread library bug in many BSDs
            # ( http://www.freebsd.org/cgi/query-pr.cgi?pr=51535 )
            # we cannot use the fancier more portable way in here
            # but instead need to use the traditional 2>&1 construct.
            if ($Is_BSD) {
                $val = `$version_check 2>&1`;
            } else {
                close STDERR if $stderr_duped;
                $val = `$version_check`;
                open STDERR, '>&STDERR_COPY' if $stderr_duped;
            }

            if ($val =~ /^VER_OK/) {
                print "Using PERL=$abs\n" if $trace;
                return $abs;
            } elsif ($trace >= 2) {
                print "Result: '$val'\n";
            }
        }
a1136 3
        my $file_new = "$file.new";
        my $file_bak = "$file.bak";

d1157 1
a1157 1
	    my(@@absdirs) = reverse grep {$self->file_name_is_absolute} $self->path;
d1163 1
a1163 1
		    $interpreter = $self->catfile($dir,$cmd);
d1188 1
a1188 1
	unless ( open(FIXOUT,">$file_new") ) {
d1192 1
d1201 2
a1202 4
        chmod 0666, $file_bak;
        unlink $file_bak;
	unless ( rename($file, $file_bak) ) {	
	    warn "Can't rename $file to $file_bak: $!";
d1205 5
a1209 5
	unless ( rename($file_new, $file) ) {	
	    warn "Can't rename $file_new to $file: $!";
	    unless ( rename($file_bak, $file) ) {
	        warn "Can't rename $file_bak back to $file either: $!";
		warn "Leaving $file renamed as $file_bak\n";
d1213 1
a1213 1
	unlink $file_bak;
d1230 1
a1230 1
	$(NOECHO) $(NOOP)
d1276 1
a1276 4
Scans the directory structure and initializes DIR, XS, XS_FILES, PM,
C, C_FILES, O_FILES, H, H_FILES, PL_FILES, MAN*PODS, EXE_FILES.

Called by init_main.
d1283 1
a1283 1
    my %pm;
d1299 1
a1299 2
            next if $self->{NORECURS};
	    $dir{$name} = $name if (-f $self->catfile($name,"Makefile.PL"));
d1319 1
a1319 1
                $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name); 
d1322 1
a1322 1
	    $pm{$name} = $self->catfile($self->{INST_LIBDIR},$name);
d1352 8
a1359 8
    unless( $self->{PMLIBDIRS} ) {
        if( $Is_VMS ) {
            # Avoid logical name vs directory collisions
            $self->{PMLIBDIRS} = ['./lib', "./$self->{BASEEXT}"];
        }
        else {
            $self->{PMLIBDIRS} = ['lib', $self->{BASEEXT}];
        }
d1379 1
a1379 1
                unless ($self->libscan($_)){
a1385 1
            return if /,v$/;   # RCS files
d1394 1
a1394 1
	    my($inst) = $self->catfile($prefix,$striplibpath);
d1403 8
a1410 11
    $self->{PM}  ||= \%pm;
    $self->{PL_FILES} ||= \%pl_files;

    $self->{DIR} ||= [sort keys %dir];

    $self->{XS}  ||= \%xs;
    $self->{C}   ||= [sort keys %c];
    my @@o_files = @@{$self->{C}};
    $self->{O_FILES} = [grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i, @@o_files];
                            
    $self->{H}   ||= [sort keys %h];
d1429 1
a1429 1
			if (/^=(?:head\d+|item|pod)\b/) {
d1442 1
a1442 1
		      $self->catfile("\$(INST_MAN1DIR)", basename($name).".\$(MAN1EXT)");
d1483 2
a1484 5
           # everything below lib is ok
	    unless($manpagename =~ s!^\W*lib\W+!!s) {
		$manpagename = $self->catfile(
                                split(/::/,$self->{PARENT_NAME}),$manpagename
                               );
d1489 1
a1489 1
		  $self->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
a1494 13
=item init_DIRFILESEP

Using / for Unix.  Called by init_main.

=cut

sub init_DIRFILESEP {
    my($self) = shift;

    $self->{DIRFILESEP} = '/';
}
    

d1499 1
a1499 1
INSTALL*, INSTALLDIRS, LIB_EXT, LIBPERL_A, MAP_TARGET, NAME,
d1502 1
a1502 1
VERSION_SYM, XS_VERSION.
d1518 1
a1518 1
    $self->{FULLEXT} = $self->catdir(split /::/, $self->{NAME});
d1553 4
a1556 4
                  $self->catdir($Updir,$Updir),
                  $self->catdir($Updir,$Updir,$Updir),
                  $self->catdir($Updir,$Updir,$Updir,$Updir),
                  $self->catdir($Updir,$Updir,$Updir,$Updir,$Updir))
d1559 1
a1559 1
		-f $self->catfile($dir,"config_h.SH")
d1561 1
a1561 1
		-f $self->catfile($dir,"perl.h")
d1563 1
a1563 1
		-f $self->catfile($dir,"lib","Exporter.pm")
d1575 1
a1575 1
	$self->{PERL_LIB}     ||= $self->catdir("$self->{PERL_SRC}","lib");
d1579 1
a1579 1
              $self->catdir("$self->{PERL_SRC}","xlib",$Cross::platform);
d1581 1
a1581 1
              $self->catdir("$self->{PERL_SRC}","xlib",$Cross::platform, 
d1587 1
a1587 1
              $self->catdir($self->{PERL_LIB},"CORE") : $self->{PERL_SRC};
d1592 1
a1592 1
		-s $self->catfile($self->{PERL_SRC},'cflags')
d1596 1
a1596 1
		-s $self->catfile($self->{PERL_SRC},'perlshr_attr.opt')
d1621 1
a1621 1
	$self->{PERL_INC}     = $self->catdir("$self->{PERL_ARCHLIB}","CORE"); # wild guess for now
d1624 1
a1624 1
	if (not -f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h"))
d1630 1
a1630 1
	      $found = $dir, last if -e $self->catdir($dir, "Config.pm");
d1634 1
a1634 1
	      if (-e $self->catdir($inc, "perl.h")) {
d1646 1
a1646 1
	unless(-f ($perl_h = $self->catfile($self->{PERL_INC},"perl.h")))
d1672 4
d1685 2
a1686 2
    my(%once_only);
    foreach my $m (@@{$self->{CONFIG}}){
d1704 1
d1715 1
a1715 1
	unless -f $self->catfile("$self->{PERL_LIB}","Exporter.pm") ||
a1716 1
}
d1718 9
a1726 1
=item init_others
d1728 28
a1755 4
Initializes EXTRALIBS, BSLOADLIBS, LDLOADLIBS, LIBS, LD_RUN_PATH, LD,
OBJECT, BOOTDEP, PERLMAINCC, LDFROM, LINKTYPE, SHELL, NOOP,
FIRST_MAKEFILE, MAKEFILE_OLD, NOECHO, RM_F, RM_RF, TEST_F,
TOUCH, CP, MV, CHMOD, UMASK_NULL, ECHO, ECHO_N
a1761 2
    $self->{LD} ||= 'ld';

d1767 1
a1767 1
    $self->{LIBS} = [$self->{LIBS}] unless ref $self->{LIBS};
d1769 1
a1769 1
    $self->{LIBS} = [''] unless @@{$self->{LIBS}} && defined $self->{LIBS}[0];
d1805 15
a1819 40
    $self->{NOOP}               ||= '$(SHELL) -c true';
    $self->{NOECHO}             = '@@' unless defined $self->{NOECHO};

    $self->{MAKEFILE}           ||= 'Makefile';
    $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE};
    $self->{MAKEFILE_OLD}       ||= '$(FIRST_MAKEFILE).old';
    $self->{MAKE_APERL_FILE}    ||= '$(FIRST_MAKEFILE).aperl';

    $self->{SHELL}              ||= $Config{sh} || '/bin/sh';

    $self->{ECHO}       ||= 'echo';
    $self->{ECHO_N}     ||= 'echo -n';
    $self->{RM_F}       ||= "rm -f";
    $self->{RM_RF}      ||= "rm -rf";
    $self->{TOUCH}      ||= "touch";
    $self->{TEST_F}     ||= "test -f";
    $self->{CP}         ||= "cp";
    $self->{MV}         ||= "mv";
    $self->{CHMOD}      ||= "chmod";
    $self->{MKPATH}     ||= '$(PERLRUN) "-MExtUtils::Command" -e mkpath';
    $self->{EQUALIZE_TIMESTAMP} ||= 
      '$(PERLRUN) "-MExtUtils::Command" -e eqtime';

    $self->{UNINST}     ||= 0;
    $self->{VERBINST}   ||= 0;
    $self->{MOD_INSTALL} ||= 
      $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
install({@@ARGV}, '$(VERBINST)', 0, '$(UNINST)');
CODE
    $self->{DOC_INSTALL} ||= 
      '$(PERLRUN) "-MExtUtils::Command::MM" -e perllocal_install';
    $self->{UNINSTALL}   ||= 
      '$(PERLRUN) "-MExtUtils::Command::MM" -e uninstall';
    $self->{WARN_IF_OLD_PACKLIST} ||= 
      '$(PERLRUN) "-MExtUtils::Command::MM" -e warn_if_old_packlist';

    $self->{UMASK_NULL}         ||= "umask 0";
    $self->{DEV_NULL}           ||= "> /dev/null 2>&1";

    return 1;
d1826 1
a1826 2
Called by init_main.  Sets up all INST_* variables except those related
to XS code.  Those are handled in init_xs.
d1833 2
a1834 2
    $self->{INST_ARCHLIB} ||= $self->catdir($Curdir,"blib","arch");
    $self->{INST_BIN}     ||= $self->catdir($Curdir,'blib','bin');
d1843 1
a1843 1
                  $self->catdir($self->{PERL_LIB},"..","xlib",
d1850 1
a1850 1
	    $self->{INST_LIB} = $self->catdir($Curdir,"blib","lib");
d1855 7
a1861 6
    $self->{INST_LIBDIR}      = $self->catdir('$(INST_LIB)',     @@parentdir);
    $self->{INST_ARCHLIBDIR}  = $self->catdir('$(INST_ARCHLIB)', @@parentdir);
    $self->{INST_AUTODIR}     = $self->catdir('$(INST_LIB)', 'auto', 
                                              '$(FULLEXT)');
    $self->{INST_ARCHAUTODIR} = $self->catdir('$(INST_ARCHLIB)', 'auto',
                                              '$(FULLEXT)');
d1863 1
a1863 1
    $self->{INST_SCRIPT}  ||= $self->catdir($Curdir,'blib','script');
d1865 2
a1866 2
    $self->{INST_MAN1DIR} ||= $self->catdir($Curdir,'blib','man1');
    $self->{INST_MAN3DIR} ||= $self->catdir($Curdir,'blib','man3');
d1876 1
a1876 1
INSTALLDIRS) and *PREFIX.
d1885 9
a1893 9
    # Initialize installvendorman*dir if necessary
    foreach my $num (1, 3) {
        my $k = 'installvendorman'.$num.'dir';

        unless ($Config{$k}) {
            $Config_Override{$k} = $Config{usevendorprefix} ?
                  $self->catdir($Config{vendorprefixexp}, 'man', "man$num") :
                  '';
        }
d1908 1
a1908 1
          $self->catdir($sprefix, 'man', 'man1');
d1913 1
a1913 1
          $self->catdir($sprefix, 'man', 'man3');
d1918 1
a1918 1
          $self->catdir($sprefix, 'bin');
d1921 3
a1923 1
    $self->{PREFIX}       ||= '';
d1925 3
a1927 9
    if( $self->{PREFIX} ) {
        @@{$self}{qw(PERLPREFIX SITEPREFIX VENDORPREFIX)} =
          ('$(PREFIX)') x 3;
    }
    else {
        $self->{PERLPREFIX}   ||= $iprefix;
        $self->{SITEPREFIX}   ||= $sprefix;
        $self->{VENDORPREFIX} ||= $vprefix;
    }
d1933 1
a1933 1
    my $libstyle = $Config{installstyle} || 'lib/perl5';
d1951 1
a1951 1
                         t => 'perl',
d1954 1
a1954 1
                         t => 'vendor',
d1957 1
a1957 1
                         t => 'site',
d1960 1
a1960 1
                         t => 'perl',
d1967 2
a1968 2
                             t => 'perl',
                             d => 'man/man1',
d1971 2
a1972 2
                             t => 'site',
                             d => 'man/man1',
d1975 2
a1976 2
                             t => 'vendor',
                             d => 'man/man1',
d1980 2
a1981 2
                             t => 'perl',
                             d => 'man/man3',
d1984 2
a1985 2
                             t => 'site',
                             d => 'man/man3',
d1988 2
a1989 2
                             t => 'vendor',
                             d => 'man/man3',
d1996 1
a1996 1
                         t => 'perl',
d2000 1
a2000 1
                         t => 'vendor',
d2004 1
a2004 1
                         t => 'site',
d2009 1
a2009 1
                         t => 'perl',
d2013 1
a2013 1
                         t => 'vendor',
d2017 1
a2017 1
                         t => 'site',
d2030 1
a2030 1
                  $self->catdir($self->{LIB}, $Config{archname});
a2037 4
    my %type2prefix = ( perl    => 'PERLPREFIX',
                        site    => 'SITEPREFIX',
                        vendor  => 'VENDORPREFIX'
                      );
d2041 1
a2041 2
        my($s, $t, $d, $style) = @@{$layout}{qw(s t d style)};
        my $r = '$('.$type2prefix{$t}.')';
d2049 8
a2056 2
        $d = "$style/$d" if $style;
        $self->prefixify($installvar, $s, $r, $d);
a2061 4
    # Generate these if they weren't figured out.
    $self->{VENDORARCHEXP} ||= $self->{INSTALLVENDORARCH};
    $self->{VENDORLIBEXP}  ||= $self->{INSTALLVENDORLIB};

a2064 14
=item init_linker

Unix has no need of special linker flags.

=cut

sub init_linker {
    my($self) = shift;
    $self->{PERL_ARCHIVE} ||= '';
    $self->{PERL_ARCHIVE_AFTER} ||= '';
    $self->{EXPORT_LIST}  ||= '';
}


a2116 1

d2138 2
a2139 9
    my $thisperl = $self->canonpath($^X);
    $thisperl .= $Config{exe_ext} unless 
                # VMS might have a file version # at the end
      $Is_VMS ? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i
              : $thisperl =~ m/$Config{exe_ext}$/i;

    # We need a relative path to perl when in the core.
    $thisperl = $self->abs2rel($thisperl) if $self->{PERL_CORE};

a2158 7
    # When built for debugging, VMS doesn't create perl.exe but ndbgperl.exe.
    my $perl_name = 'perl';
    $perl_name = 'ndbgperl' if $Is_VMS && 
      defined $Config{usevmsdebug} && $Config{usevmsdebug} eq 'define';

    # XXX This logic is flawed.  If "miniperl" is anywhere in the path
    # it will get confused.  It should be fixed to work only on the filename.
d2160 1
a2160 1
    ($self->{FULLPERL} = $self->{PERL}) =~ s/miniperl/$perl_name/i
d2167 1
a2167 1
    if( $self->file_name_is_absolute($self->{ABSPERL}) ) {
d2171 1
a2171 1
        $self->{ABSPERL} = $self->rel2abs($self->{ABSPERL});
d2180 1
a2180 3
        my $run  = $perl.'RUN';

        $self->{$run}  = "\$($perl)";
d2183 1
a2183 1
        $self->{$run} .= q{ "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)"} 
a2192 33

=item init_platform (o)

Add MM_Unix_VERSION.

=item platform_constants (o)

=cut

sub init_platform {
    my($self) = shift;

    $self->{MM_Unix_VERSION} = $VERSION;
    $self->{PERL_MALLOC_DEF} = '-DPERL_EXTMALLOC_DEF -Dmalloc=Perl_malloc '.
                               '-Dfree=Perl_mfree -Drealloc=Perl_realloc '.
                               '-Dcalloc=Perl_calloc';

}

sub platform_constants {
    my($self) = shift;
    my $make_frag = '';

    foreach my $macro (qw(MM_Unix_VERSION PERL_MALLOC_DEF))
    {
        next unless defined $self->{$macro};
        $make_frag .= "$macro = $self->{$macro}\n";
    }

    return $make_frag;
}


d2204 2
a2205 2
    $self->{PERM_RW}  = 644  unless defined $self->{PERM_RW};
    $self->{PERM_RWX} = 755  unless defined $self->{PERM_RWX};
d2209 1
a2209 27


=item init_xs

    $mm->init_xs

Sets up macros having to do with XS code.  Currently just INST_STATIC,
INST_DYNAMIC and INST_BOOT.

=cut

sub init_xs {
    my $self = shift;

    if ($self->has_link_code()) {
        $self->{INST_STATIC}  = 
          $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT)$(LIB_EXT)');
        $self->{INST_DYNAMIC} = 
          $self->catfile('$(INST_ARCHAUTODIR)', '$(DLBASE).$(DLEXT)');
        $self->{INST_BOOT}    = 
          $self->catfile('$(INST_ARCHAUTODIR)', '$(BASEEXT).bs');
    } else {
        $self->{INST_STATIC}  = '';
        $self->{INST_DYNAMIC} = '';
        $self->{INST_BOOT}    = '';
    }
}    
d2233 1
d2236 1
a2236 1
	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
d2239 1
a2239 1
	$(NOECHO) $(ECHO) INSTALLDIRS not defined, defaulting to INSTALLDIRS=site
d2242 11
a2252 11
	$(NOECHO) $(MOD_INSTALL) \
		read }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		write }.$self->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(DESTINSTALLPRIVLIB) \
		$(INST_ARCHLIB) $(DESTINSTALLARCHLIB) \
		$(INST_BIN) $(DESTINSTALLBIN) \
		$(INST_SCRIPT) $(DESTINSTALLSCRIPT) \
		$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) \
		$(INST_MAN3DIR) $(DESTINSTALLMAN3DIR)
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
		}.$self->catdir('$(SITEARCHEXP)','auto','$(FULLEXT)').q{
d2256 11
a2266 11
	$(NOECHO) $(MOD_INSTALL) \
		read }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
		write }.$self->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(DESTINSTALLSITELIB) \
		$(INST_ARCHLIB) $(DESTINSTALLSITEARCH) \
		$(INST_BIN) $(DESTINSTALLSITEBIN) \
		$(INST_SCRIPT) $(DESTINSTALLSCRIPT) \
		$(INST_MAN1DIR) $(DESTINSTALLSITEMAN1DIR) \
		$(INST_MAN3DIR) $(DESTINSTALLSITEMAN3DIR)
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) \
		}.$self->catdir('$(PERL_ARCHLIB)','auto','$(FULLEXT)').q{
d2269 7
a2275 9
	$(NOECHO) $(MOD_INSTALL) \
		read }.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{ \
		write }.$self->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').q{ \
		$(INST_LIB) $(DESTINSTALLVENDORLIB) \
		$(INST_ARCHLIB) $(DESTINSTALLVENDORARCH) \
		$(INST_BIN) $(DESTINSTALLVENDORBIN) \
		$(INST_SCRIPT) $(DESTINSTALLSCRIPT) \
		$(INST_MAN1DIR) $(DESTINSTALLVENDORMAN1DIR) \
		$(INST_MAN3DIR) $(DESTINSTALLVENDORMAN3DIR)
d2278 2
a2279 3
	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	-$(NOECHO) $(DOC_INSTALL) \
d2285 1
a2285 1
		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
d2288 2
a2289 3
	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	-$(NOECHO) $(DOC_INSTALL) \
d2295 1
a2295 1
		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
a2297 9
	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	-$(NOECHO) $(DOC_INSTALL) \
		"Module" "$(NAME)" \
		"installed into" "$(INSTALLVENDORLIB)" \
		LINKTYPE "$(LINKTYPE)" \
		VERSION "$(VERSION)" \
		EXE_FILES "$(EXE_FILES)" \
		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
d2305 2
a2306 1
	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q{
d2309 2
a2310 4
	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q{

uninstall_from_vendordirs ::
	$(NOECHO) $(UNINSTALL) }.$self->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').q{
d2329 1
a2329 1
	my($path)= $self->catfile('$(INST_SCRIPT)', basename($from));
a2335 10

    my $fixin;
    if( $Is_Win32 ) {
        $fixin = $self->{PERL_CORE} ? '$(PERLRUN) ../../win32/bin/pl2bat.pl'
                                    : 'pl2bat.bat';
    }
    else {
        $fixin = q{$(PERLRUN) "-MExtUtils::MY" -e "MY->fixin(shift)"};
    }

d2339 5
a2343 2
FIXIN = $fixin

d2345 1
a2345 1
	\$(NOECHO) \$(NOOP)
d2348 1
a2348 1
	\$(RM_F) @@to
d2355 3
a2357 3
$to: $from \$(FIRST_MAKEFILE) " . $self->catdir($todir,'.exists') . "
	\$(NOECHO) \$(RM_F) $to
	\$(CP) $from $to
d2359 1
a2359 1
	-\$(NOECHO) \$(CHMOD) \$(PERM_RWX) $to
d2365 15
d2394 1
a2394 1
	\$(NOECHO) \$(NOOP)
d2465 2
a2466 2
	$(NOECHO) $(ECHO) Writing \"$(MAKE_APERL_FILE)\" for this $(MAP_TARGET)
	$(NOECHO) $(PERLRUNINST) \
d2596 1
a2596 1
          if ($Is_SunOS) {
d2599 1
a2599 1
            $libperl = '' if $Is_SunOS4;
d2618 4
a2621 4
\$(INST_ARCHAUTODIR)/extralibs.all: \$(INST_ARCHAUTODIR)\$(DIRFILESEP).exists ".join(" \\\n\t", @@$extra).'
	$(NOECHO) $(RM_F)  $@@
	$(NOECHO) $(TOUCH) $@@
';
d2631 4
a2634 4
	\$(NOECHO) \$(ECHO) 'To install the new \"\$(MAP_TARGET)\" binary, call'
	\$(NOECHO) \$(ECHO) '    make -f $makefilename inst_perl MAP_TARGET=\$(MAP_TARGET)'
	\$(NOECHO) \$(ECHO) 'To remove the intermediate files say'
	\$(NOECHO) \$(ECHO) '    make -f $makefilename map_clean'
d2642 2
a2643 2
	$(NOECHO) $(ECHO) Writing $@@
	$(NOECHO) $(PERL) $(MAP_PERLINC) "-MExtUtils::Miniperl" \\
d2647 1
a2647 1
    push @@m, "\t", q{$(NOECHO) $(PERL) $(INSTALLSCRIPT)/fixpmain
d2653 3
a2655 3
	$(NOECHO) $(ECHO) Appending installation info to $(DESTINSTALLARCHLIB)/perllocal.pod
	-$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	-$(NOECHO) $(DOC_INSTALL) \
d2660 1
a2660 1
		>> }.$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q{
d2668 1
a2668 1
	}.$self->{CP}.q{ $(MAP_TARGET) }.$self->catfile('$(DESTINSTALLBIN)','$(MAP_TARGET)').q{
d2696 1
a2696 1
# We take a very conservative approach here, but it's worth it.
d2698 6
a2703 6
$(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to $?"
	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding Makefile..."
	$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
	$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
	-$(MAKE) -f $(MAKEFILE_OLD) clean $(DEV_NULL) || $(NOOP)
d2705 2
a2706 2
	$(NOECHO) $(ECHO) "==> Your Makefile has been rebuilt. <=="
	$(NOECHO) $(ECHO) "==> Please rerun the make command.  <=="
d2714 52
d2779 38
d2829 1
a2829 1
    confess("needs_linking called too early") if 
d2909 2
a2910 1
	next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
d2988 1
a2988 1
	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; false
d2991 1
a2991 1
	$(NOECHO) $(ECHO) "Warning: $(PERL_ARCHLIB)/Config.pm may be out of date with $(PERL_SRC)/config.sh"
d3022 1
d3025 1
d3042 3
a3044 1
	$(PERL_INC)/util.h
d3068 1
a3068 1
    return shift->{PERM_RW};
d3081 1
a3081 1
    return shift->{PERM_RWX};
d3091 10
d3103 1
a3103 1
    my($autodir) = $self->catdir('$(INST_LIB)','auto');
d3107 14
a3120 11

    my $pm_to_blib = $self->oneliner(<<CODE, ['-MExtUtils::Install']);
pm_to_blib({\@@ARGV}, '$autodir', '\$(PM_FILTER)')
CODE

    my @@cmds = $self->split_command($pm_to_blib, %{$self->{PM}});

    $r .= join '', map { "\t\$(NOECHO) $_\n" } @@cmds;
    $r .= q{	$(NOECHO) $(TOUCH) $@@};

    return $r;
d3131 1
d3143 1
d3155 1
d3185 7
a3192 6
    my $ppd_xml = sprintf <<'PPD_HTML', $pack_ver, $abstract, $author;
<SOFTPKG NAME="$(DISTNAME)" VERSION="%s">
    <TITLE>$(DISTNAME)</TITLE>
    <ABSTRACT>%s</ABSTRACT>
    <AUTHOR>%s</AUTHOR>
PPD_HTML
d3194 1
a3194 1
    $ppd_xml .= "    <IMPLEMENTATION>\n";
d3200 7
a3206 2
        $ppd_xml .= sprintf <<'PPD_OUT', $pre_req, $dep_ver;
        <DEPENDENCY NAME="%s" VERSION="%s" />
d3209 1
a3209 1
    }
a3210 4
    $ppd_xml .= sprintf <<'PPD_OUT', $Config{archname};
        <OS NAME="$(OSNAME)" />
        <ARCHITECTURE NAME="%s" />
PPD_OUT
d3214 1
a3214 1
            $ppd_xml .= sprintf qq{        <INSTALL EXEC="%s">%s</INSTALL>\n},
d3218 1
a3218 1
            $ppd_xml .= sprintf qq{        <INSTALL>%s</INSTALL>\n}, 
d3226 3
a3228 5
    $ppd_xml .= sprintf <<'PPD_XML', $bin_location;
        <CODEBASE HREF="%s" />
    </IMPLEMENTATION>
</SOFTPKG>
PPD_XML
d3230 1
a3230 7
    my @@ppd_cmds = $self->echo($ppd_xml, '$(DISTNAME).ppd');

    return sprintf <<'PPD_OUT', join "\n\t", @@ppd_cmds;
# Creates a PPD (Perl Package Description) for a binary distribution.
ppd:
	%s
PPD_OUT
d3232 1
d3240 2
a3241 6
replace it's $prefix with a $new_prefix.  

Should the $prefix fail to match I<AND> a PREFIX was given as an
argument to WriteMakefile() it will set it to the $new_prefix +
$default.  This is for systems whose file layouts don't neatly fit into
our ideas of prefixes.
a3262 2
    $rprefix .= '/' if $sprefix =~ m|/$|;

d3266 1
a3266 1
    if( $path !~ s{^\Q$sprefix\E\b}{$rprefix}s && $self->{ARGS}{PREFIX} ) {
d3271 1
a3271 1
        $path = $self->catdir($rprefix, $default) if $default;
d3297 1
a3297 1
	\$(NOECHO) \$(NOOP)
d3316 5
a3320 5
    my $arg = shift;
    $arg =~ s/\$\((.+?)\)/\$\\\\($1\\\\)/g;	# protect $(...)
    $arg =~ s/(?<!\\)([()])/\\$1/g;		# quote unprotected
    $arg =~ s/\$\\\\\((.+?)\\\\\)/\$($1)/g;	# unprotect $(...)
    return $arg;
d3335 1
a3335 3
realclean purge ::  clean realclean_subdirs
	$(RM_RF) $(INST_AUTODIR) $(INST_ARCHAUTODIR)
	$(RM_RF) $(DISTVNAME)
d3337 14
d3352 6
d3359 2
a3360 2
        push(@@m, "	\$(RM_F) \$(INST_DYNAMIC) \$(INST_BOOT)\n");
        push(@@m, "	\$(RM_F) \$(INST_STATIC)\n");
a3361 8

    my @@files = values %{$self->{PM}};
    push @@files, $attribs{FILES} if $attribs{FILES};
    push @@files, '$(FIRST_MAKEFILE)', '$(MAKEFILE_OLD)';

    # Occasionally files are repeated several times from different sources
    { my(%f) = map { ($_,1) } @@files; @@files = keys %f; }

d3365 12
a3376 9
    my $line = "";
    foreach my $file (@@files) {
        if (length($line) + length($file) > 200) {
            push @@m, "\t\$(RM_F) $line\n";
            $line = $file;
        }
        else {
            $line .= " $file"; 
        }
d3378 5
a3382 3
    push @@m, "\t\$(RM_F) $line\n" if $line;
    push(@@m, "\t$attribs{POSTOP}\n")      if $attribs{POSTOP};

a3385 32

=item realclean_subdirs_target

  my $make_frag = $MM->realclean_subdirs_target;

Returns the realclean_subdirs target.  This is used by the realclean
target to call realclean on any subdirectories which contain Makefiles.

=cut

sub realclean_subdirs_target {
    my $self = shift;

    return <<'NOOP_FRAG' unless @@{$self->{DIR}};
realclean_subdirs :
	$(NOECHO) $(NOOP)
NOOP_FRAG

    my $rclean = "realclean_subdirs :\n";

    foreach my $dir (@@{$self->{DIR}}){
        $rclean .= sprintf <<'RCLEAN', $dir, $dir;
	-cd %s && $(TEST_F) $(MAKEFILE_OLD) && $(MAKE) -f $(MAKEFILE_OLD) realclean
	-cd %s && $(TEST_F) $(FIRST_MAKEFILE) && $(MAKE) realclean
RCLEAN

    }

    return $rclean;
}


a3402 73

=item oneliner (o)

=cut

sub oneliner {
    my($self, $cmd, $switches) = @@_;
    $switches = [] unless defined $switches;

    # Strip leading and trailing newlines
    $cmd =~ s{^\n+}{};
    $cmd =~ s{\n+$}{};

    my @@cmds = split /\n/, $cmd;
    $cmd = join " \n\t-e ", map $self->quote_literal($_), @@cmds;
    $cmd = $self->escape_newlines($cmd);

    $switches = join ' ', @@$switches;

    return qq{\$(PERLRUN) $switches -e $cmd};   
}


=item quote_literal

=cut

sub quote_literal {
    my($self, $text) = @@_;

    # I think all we have to quote is single quotes and I think
    # this is a safe way to do it.
    $text =~ s{'}{'\\''}g;

    return "'$text'";
}


=item escape_newlines

=cut

sub escape_newlines {
    my($self, $text) = @@_;

    $text =~ s{\n}{\\\n}g;

    return $text;
}


=item max_exec_len

Using POSIX::ARG_MAX.  Otherwise falling back to 4096.

=cut

sub max_exec_len {
    my $self = shift;

    if (!defined $self->{_MAX_EXEC_LEN}) {
        if (my $arg_max = eval { require POSIX;  &POSIX::ARG_MAX }) {
            $self->{_MAX_EXEC_LEN} = $arg_max;
        }
        else {      # POSIX minimum exec size
            $self->{_MAX_EXEC_LEN} = 4096;
        }
    }

    return $self->{_MAX_EXEC_LEN};
}


d3416 3
a3418 2
static :: $(FIRST_MAKEFILE) $(INST_STATIC)
	$(NOECHO) $(NOOP)
d3430 3
d3437 1
a3437 2

$(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
a3439 1

d3442 1
a3442 3
    push(@@m, <<'MAKE_FRAG') if $self->{MYEXTLIB};
	$(CP) $(MYEXTLIB) $@@
MAKE_FRAG
d3452 6
a3457 6
    push @@m, sprintf <<'MAKE_FRAG', $ar;
	$(%s) $(AR_STATIC_ARGS) $@@ $(OBJECT) && $(RANLIB) $@@
	$(CHMOD) $(PERM_RWX) $@@
	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)/extralibs.ld
MAKE_FRAG

d3459 4
a3462 3
    push @@m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};
	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)/ext.libs
MAKE_FRAG
d3464 2
a3465 2
    push @@m, "\n", $self->dir_target('$(INST_ARCHAUTODIR)');
    join('', @@m);
d3483 1
a3483 1
	@@static = $self->catfile($self->{INST_ARCHLIB},
d3518 23
a3540 1
    return sprintf <<'EOT', $subdir;
d3543 1
a3543 1
	$(NOECHO)cd %s && $(MAKE) -f $(FIRST_MAKEFILE) all $(PASTHRU)
d3545 1
d3605 2
a3606 2
    if ($Is_Win95) {
        push(@@m, map(qq{\t\$(NOECHO) \$(PERLRUN) -e "exit unless -f shift; chdir '$_'; system q{\$(MAKE) test \$(PASTHRU)}" \$(FIRST_MAKEFILE)\n}, @@{$self->{DIR}}));
d3609 1
a3609 1
        push(@@m, map("\t\$(NOECHO) cd $_ && \$(TEST_F) \$(FIRST_MAKEFILE) && \$(MAKE) test \$(PASTHRU)\n", @@{$self->{DIR}}));
d3612 1
a3612 1
    push(@@m, "\t\$(NOECHO) \$(ECHO) 'No tests defined for \$(NAME) extension.'\n")
d3669 6
d3676 8
a3683 1
=item tools_other (o)
d3685 1
a3685 1
    my $make_frag = $MM->tools_other;
d3687 1
a3687 1
Returns a make fragment containing definitions for:
d3689 1
a3689 4
SHELL, CHMOD, CP, MV, NOOP, NOECHO, RM_F, RM_RF, TEST_F, TOUCH,
DEV_NULL, UMASK_NULL, MKPATH, EQUALIZE_TIMESTAMP,
WARN_IF_OLD_PACKLIST, UNINST, VERBINST, MOD_INSTALL, DOC_INSTALL and
UNINSTALL
d3691 3
a3693 1
init_others() initializes all these values.
d3700 4
d3705 2
a3706 10
    for my $tool (qw{ SHELL CHMOD CP MV NOOP NOECHO RM_F RM_RF TEST_F TOUCH 
                      UMASK_NULL DEV_NULL MKPATH EQUALIZE_TIMESTAMP 
                      ECHO ECHO_N
                      UNINST VERBINST
                      MOD_INSTALL DOC_INSTALL UNINSTALL
                      WARN_IF_OLD_PACKLIST
                    } ) 
    {
        next unless defined $self->{$tool};
        push @@m, "$tool = $self->{$tool}\n";
d3709 41
d3762 2
a3763 11

    my $xsdir;
    foreach my $dir (@@INC) {
        $xsdir = $self->catdir($dir, 'ExtUtils');
        if( -r $self->catfile($xsdir, "xsubpp") ) {
            last;
        }
    }

    my $tmdir   = File::Spec->catdir($self->{PERL_LIB},"ExtUtils");
    my(@@tmdeps) = $self->catfile($tmdir,'typemap');
d3782 17
a3798 1
    $self->{XSPROTOARG} = "" unless defined $self->{XSPROTOARG};
d3802 1
a3802 1
XSUBPP = \$(XSUBPPDIR)/xsubpp
d3810 8
d3819 3
a3821 1
=item all_target
d3823 31
a3853 1
Build man pages, too
d3855 2
a3856 1
=cut
d3858 2
a3859 2
sub all_target {
    my $self = shift;
d3861 2
a3862 4
    return <<'MAKE_EXT';
all :: pure_all manifypods
	$(NOECHO) $(NOOP)
MAKE_EXT
d3877 5
a3881 1
    push @@m, $self->all_target, "\n" unless $self->{SKIPHASH}{'all'};
d3885 1
a3885 1
	$(NOECHO) $(NOOP)
d3888 1
a3888 1
	$(NOECHO) $(NOOP)
d3890 2
a3891 2
config :: $(FIRST_MAKEFILE) $(INST_LIBDIR)$(DIRFILESEP).exists
	$(NOECHO) $(NOOP)
d3893 2
a3894 2
config :: $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
	$(NOECHO) $(NOOP)
d3896 2
a3897 2
config :: $(INST_AUTODIR)$(DIRFILESEP).exists
	$(NOECHO) $(NOOP)
d3903 3
a3905 3
	push @@m, q[
config :: $(INST_MAN1DIR)$(DIRFILESEP).exists
	$(NOECHO) $(NOOP)
d3911 3
a3913 3
	push @@m, q[
config :: $(INST_MAN3DIR)$(DIRFILESEP).exists
	$(NOECHO) $(NOOP)
d3991 41
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d2772 1
a2772 1
	return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@d1575 1
a1575 1
              $self->{"INST_${man}DIR"} =~ /^(none|\s*)$/;
@


1.1.1.9
log
@perl 5.8.6 from CPAN
@
text
@d1575 1
a1575 1
              $self->{"INSTALL${man}DIR"} =~ /^(none|\s*)$/;
@


1.1.1.10
log
@perl 5.8.8 import
@
text
@d9 2
a10 2
use ExtUtils::MakeMaker::Config;
use File::Basename qw(basename dirname);
d14 4
a17 4
            $Is_OS2 $Is_VMS $Is_Win32 $Is_Dos
            $Is_OSF $Is_IRIX  $Is_NetBSD $Is_BSD
            $Is_SunOS4 $Is_Solaris $Is_SunOS $Is_Interix
            $Verbose %pm
d23 1
a23 1
$VERSION = '1.50';
d28 16
a43 23
BEGIN { 
    $Is_OS2     = $^O eq 'os2';
    $Is_Win32   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
    $Is_Dos     = $^O eq 'dos';
    $Is_VMS     = $^O eq 'VMS';
    $Is_OSF     = $^O eq 'dec_osf';
    $Is_IRIX    = $^O eq 'irix';
    $Is_NetBSD  = $^O eq 'netbsd';
    $Is_Interix = $^O eq 'interix';
    $Is_SunOS4  = $^O eq 'sunos';
    $Is_Solaris = $^O eq 'solaris';
    $Is_SunOS   = $Is_SunOS4 || $Is_Solaris;
    $Is_BSD     = $^O =~ /^(?:free|net|open)bsd$/ or
                  $^O eq 'bsdos' or $^O eq 'interix';
}

BEGIN {
    if( $Is_VMS ) {
        # For things like vmsify()
        require VMS::Filespec;
        VMS::Filespec->import;
    }
}
d85 2
a86 4
overridable by a platform specific MM_*.pm file.

Cross-platform methods are being moved into MM_Any.  If you can't find
something that used to be in here, look in MM_Any.
d101 1
a101 1
=item os_flavor
d268 86
d416 1
a416 1
	 EXTRALIBS LDLOADLIBS BSLOADLIBS
a420 7
    # don't set LD_RUN_PATH if empty
    for $tmp (qw/
	 LD_RUN_PATH
	 /) {
	next unless $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
    }
a435 2
    $self->{DFSEP} = '$(DIRFILESEP)';  # alias for internal use

d438 1
a438 1
              AR_STATIC_ARGS DIRFILESEP DFSEP
d445 2
a446 1
              INSTALLDIRS INSTALLBASE DESTDIR PREFIX
a487 1
              MAKE
d489 1
a489 1
	      LDFROM LINKTYPE BOOTDEP
d509 1
a509 1
CONFIGDEP = $(PERL_ARCHLIB)$(DFSEP)Config.pm $(PERL_INC)$(DFSEP)config.h
d561 43
d942 42
d987 2
a988 3
Used by some OS' to define DL_FUNCS and DL_VARS and write the *.exp files.

Normally just returns an empty string.
d993 28
a1020 1
    return '';
d1023 15
d1051 1
a1051 3
    my $target = $Is_VMS ? '$(MMS$TARGET)' : '$@@';

    return sprintf <<'MAKE_FRAG', ($target) x 5;
d1057 1
a1057 1
$(BOOTSTRAP) : $(FIRST_MAKEFILE) $(BOOTDEP) $(INST_ARCHAUTODIR)$(DFSEP).exists
d1062 2
a1063 2
	$(NOECHO) $(TOUCH) %s
	$(CHMOD) $(PERM_RW) %s
d1065 4
a1068 4
$(INST_BOOT) : $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists
	$(NOECHO) $(RM_RF) %s
	- $(CP) $(BOOTSTRAP) %s
	$(CHMOD) $(PERM_RW) %s
d1100 1
a1100 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(PERL_ARCHIVE_AFTER) $(INST_DYNAMIC_DEP)
d1123 1
a1123 1
    if (($Is_NetBSD || $Is_Interix) && $Config{'useshrplib'}) {
d1128 7
a1134 5
        if ($Config{'lddlflags'} =~ /-Wl,-R/) {
            $libs .= ' -L$(PERL_INC) -Wl,-R$(INSTALLARCHLIB)/CORE -Wl,-R$(PERL_ARCHLIB)/CORE -lperl';
        } elsif ($Config{'lddlflags'} =~ /-R/) {
            $libs .= ' -L$(PERL_INC) -R$(INSTALLARCHLIB)/CORE -R$(PERL_ARCHLIB)/CORE -lperl';
        }
d1137 4
a1140 12
    my $ld_run_path_shell = "";
    if ($self->{LD_RUN_PATH} ne "") {
	$ld_run_path_shell = 'LD_RUN_PATH="$(LD_RUN_PATH)" ';
    }

    push @@m, sprintf <<'MAKE', $ld_run_path_shell, $ldrun, $ldfrom, $libs;
	%s$(LD) %s $(LDDLFLAGS) %s $(OTHERLDFLAGS) -o $@@ $(MYEXTLIB)	\
	  $(PERL_ARCHIVE) %s $(PERL_ARCHIVE_AFTER) $(EXPORT_LIST)	\
	  $(INST_DYNAMIC_FIX)
MAKE

    push @@m, <<'MAKE';
d1142 1
a1142 1
MAKE
d1144 2
a1145 1
    return join('',@@m);
d1219 1
a1219 1
            my $version_check = qq{$abs -le "require $ver; print qq{VER_OK}"};
d1246 22
d1350 1
a1350 1
	unless ( _rename($file, $file_bak) ) {	
d1354 1
a1354 1
	unless ( _rename($file_new, $file) ) {	
d1356 1
a1356 1
	    unless ( _rename($file_bak, $file) ) {
a1368 16

sub _rename {
    my($old, $new) = @@_;

    foreach my $file ($old, $new) {
        if( $Is_VMS and basename($file) !~ /\./ ) {
            # rename() in 5.8.0 on VMS will not rename a file if it
            # does not contain a dot yet it returns success.
            $file = "$file.";
        }
    }

    return rename($old, $new);
}


d1371 1
a1371 1
Writes an empty FORCE: target.
d1434 1
a1434 1
    my($name, %dir, %xs, %c, %h, %pl_files, %manifypods);
d1437 1
a1437 1
    my %ignore = map {( $_ => 1 )} qw(Makefile.PL Build.PL test.pl t);
d1771 2
d1817 19
a1835 1
	}	
d1947 4
a1950 12
    $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE} || 'Makefile';
    $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE};
    $self->{MAKEFILE_OLD}       ||= $self->{MAKEFILE}.'.old';
    $self->{MAKE_APERL_FILE}    ||= $self->{MAKEFILE}.'.aperl';

    # Some makes require a wrapper around macros passed in on the command 
    # line.
    $self->{MACROSTART}         ||= '';
    $self->{MACROEND}           ||= '';

    # Not everybody uses -f to indicate "use this Makefile instead"
    $self->{USEMAKEFILE}        ||= '-f';
d1963 1
a1963 1
    $self->{MKPATH}     ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e mkpath';
d1965 1
a1965 1
      '$(ABSPERLRUN) "-MExtUtils::Command" -e eqtime';
d1973 4
a1976 4
    $self->{DOC_INSTALL}        ||= 
      '$(ABSPERLRUN) "-MExtUtils::Command::MM" -e perllocal_install';
    $self->{UNINSTALL}          ||= 
      '$(ABSPERLRUN) "-MExtUtils::Command::MM" -e uninstall';
d1978 1
a1978 3
      '$(ABSPERLRUN) "-MExtUtils::Command::MM" -e warn_if_old_packlist';
    $self->{FIXIN}              ||= 
      q{$(PERLRUN) "-MExtUtils::MY" -e "MY->fixin(shift)"};
d1986 249
d2376 1
a2376 2
    $self->{PERL_CORE} = $ENV{PERL_CORE} unless exists $self->{PERL_CORE};
    $self->{PERL_CORE} = 0               unless defined $self->{PERL_CORE};
d2396 1
a2396 1
=item init_platform
d2398 1
a2398 1
=item platform_constants
d2400 1
a2400 1
Add MM_Unix_VERSION.
a2483 1
	$(NOECHO) $(NOOP)
a2485 1
	$(NOECHO) $(NOOP)
a2487 1
	$(NOECHO) $(NOOP)
a2489 1
	$(NOECHO) $(NOOP)
a2491 1
	$(NOECHO) $(NOOP)
a2493 1
	$(NOECHO) $(NOOP)
a2575 1
	$(NOECHO) $(NOOP)
a2597 1

d2599 4
a2602 7
    my @@exefiles = @@{$self->{EXE_FILES}};
    return "" unless @@exefiles;

    @@exefiles = map vmsify($_), @@exefiles if $Is_VMS;

    my %fromto;
    for my $from (@@exefiles) {
a2603 1

d2605 1
a2605 1
	my $to = $self->libscan($path);
d2607 3
d2611 7
a2617 2
        $to = vmsify($to) if $Is_VMS;
	$fromto{$from} = $to;
a2618 1
    my @@to   = values %fromto;
a2619 1
    my @@m;
d2621 3
a2623 1
EXE_FILES = @@exefiles
d2629 1
d2632 1
a2632 7
    # realclean can get rather large.
    push @@m, map "\t$_\n", $self->split_command('$(RM_F)', @@to);
    push @@m, "\n";


    # A target for each exe file.
    while (my($from,$to) = each %fromto) {
d2634 8
a2641 10

	push @@m, sprintf <<'MAKE', $to, $from, $to, $from, $to, $to, $to;
%s : %s $(FIRST_MAKEFILE) $(INST_SCRIPT)$(DFSEP).exists $(INST_BIN)$(DFSEP).exists
	$(NOECHO) $(RM_F) %s
	$(CP) %s %s
	$(FIXIN) %s
	-$(NOECHO) $(CHMOD) $(PERM_RWX) %s

MAKE

a2642 1

d2728 1
a2728 1
	$(MAKE) $(USEMAKEFILE) $(MAKE_APERL_FILE) $@@
d2730 1
a2730 1
$(MAKE_APERL_FILE) : $(FIRST_MAKEFILE) pm_to_blib
d2768 1
a2768 1
    my %static;
d2772 2
a2773 6

        # Skip perl's libraries.
        return if m/^libperl/ or m/^perl\Q$self->{LIB_EXT}\E$/;

	# Skip purified versions of libraries 
        # (e.g., DynaLoader_pure_p1_c0_032.a)
d2883 2
a2884 2
    push @@m, '
$(INST_ARCHAUTODIR)/extralibs.all : $(INST_ARCHAUTODIR)$(DFSEP).exists '.join(" \\\n\t", @@$extra).'
d2898 1
a2898 1
	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename inst_perl MAP_TARGET=\$(MAP_TARGET)'
d2900 1
a2900 1
	\$(NOECHO) \$(ECHO) '    \$(MAKE) \$(USEMAKEFILE) $makefilename map_clean'
d2904 1
a2904 1
    push @@m, "\t".$self->cd($tmp, qq[$cccmd "-I\$(PERL_INC)" perlmain.c])."\n";
d2953 1
a2953 1
    my $m;
d2957 1
a2957 1
    $m = '
a2958 1

d2961 1
a2961 4
    my $newer_than_target = $Is_VMS ? '$(MMS$SOURCE_LIST)' : '$?';
    my $mpl_args = join " ", map qq["$_"], @@ARGV;

    $m .= sprintf <<'MAKE_FRAG', $newer_than_target, $mpl_args;
d2965 1
a2965 1
	$(NOECHO) $(ECHO) "Makefile out-of-date with respect to %s"
d2967 4
a2970 4
	-$(NOECHO) $(RM_F) $(MAKEFILE_OLD)
	-$(NOECHO) $(MV)   $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
	- $(MAKE) $(USEMAKEFILE) $(MAKEFILE_OLD) clean $(DEV_NULL)
	$(PERLRUN) Makefile.PL %s
d2972 1
a2972 1
	$(NOECHO) $(ECHO) "==> Please rerun the $(MAKE) command.  <=="
d2975 1
a2975 1
MAKE_FRAG
d2977 1
a2977 1
    return $m;
a3078 1
    local $_;
d3122 1
a3122 5
    foreach $key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE
                     PREFIX INSTALLBASE)
                 ) 
    {
        next unless defined $self->{$key};
a3126 1
        next unless defined $self->{$key};
d3158 1
a3158 4

    my $make_config = $self->cd('$(PERL_SRC)', '$(MAKE) lib/Config.pm');

    push @@m, sprintf <<'MAKE_FRAG', $make_config if $self->{PERL_SRC};
d3167 2
a3168 2
	%s
MAKE_FRAG
d3266 1
a3266 1
pm_to_blib : $(TO_INST_PM)
d3276 1
a3276 1
    $r .= qq{\t\$(NOECHO) \$(TOUCH) pm_to_blib\n};
d3432 1
a3432 3
    if( $self->{ARGS}{PREFIX} && $self->file_name_is_absolute($path) && 
        $path !~ s{^\Q$sprefix\E\b}{$rprefix}s ) 
    {
d3452 10
a3461 35
    my $self = shift;
    my $pl_files = $self->{PL_FILES};

    return "" unless $pl_files;

    my $m = '';
    foreach my $plfile (sort keys %$pl_files) {
        my $list = ref($pl_files->{$plfile})
                     ?  $pl_files->{$plfile}
		     : [$pl_files->{$plfile}];

	foreach my $target (@@$list) {
            if( $Is_VMS ) {
                $plfile = vmsify($plfile);
                $target = vmsify($target);
            }

	    # Normally a .PL file runs AFTER pm_to_blib so it can have
	    # blib in its @@INC and load the just built modules.  BUT if
	    # the generated module is something in $(TO_INST_PM) which
	    # pm_to_blib depends on then it can't depend on pm_to_blib
	    # else we have a dependency loop.
	    my $pm_dep;
	    my $perlrun;
	    if( defined $self->{PM}{$target} ) {
		$pm_dep  = '';
		$perlrun = 'PERLRUN';
	    }
	    else {
		$pm_dep  = 'pm_to_blib';
		$perlrun = 'PERLRUNINST';
	    }

            $m .= <<MAKE_FRAG;

d3465 3
a3467 4
$target :: $plfile $pm_dep
	\$($perlrun) $plfile $target
MAKE_FRAG

d3470 1
a3470 2

    return $m;
d3483 3
a3485 3
    $arg =~ s{\$\((.+?)\)}{\$\\\\($1\\\\)}g;	# protect $(...)
    $arg =~ s{(?<!\\)([()])}{\\$1}g;		# quote unprotected
    $arg =~ s{\$\\\\\((.+?)\\\\\)}{\$($1)}g;	# unprotect $(...)
d3489 80
d3587 1
a3587 14
=item cd

=cut

sub cd {
    my($self, $dir, @@cmds) = @@_;

    # No leading tab and no trailing newline makes for easier embedding
    my $make_frag = join "\n\t", map { "cd $dir && $_" } @@cmds;

    return $make_frag;
}

=item oneliner
d3600 1
a3600 1
    $cmd = join " \n\t  -e ", map $self->quote_literal($_), @@cmds;
d3605 1
a3605 1
    return qq{\$(ABSPERLRUN) $switches -e $cmd};   
d3690 1
a3690 1
$(INST_STATIC) : $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
d3719 1
d3773 1
a3773 5

    my $subdir_cmd = $self->cd($subdir, 
      '$(MAKE) $(USEMAKEFILE) $(FIRST_MAKEFILE) all $(PASTHRU)'
    );
    return sprintf <<'EOT', $subdir_cmd;
d3776 1
a3776 1
	$(NOECHO) %s
a3777 1

d3837 5
a3841 8
    foreach my $dir (@@{ $self->{DIR} }) {
        my $test = $self->oneliner(sprintf <<'CODE', $dir);
chdir '%s';  
system '$(MAKE) test $(PASTHRU)' 
    if -f '$(FIRST_MAKEFILE)';
CODE

        push(@@m, "\t\$(NOECHO) $test\n");
d3906 8
a3913 2
Returns a make fragment containing definitions for the macros init_others() 
initializes.
a3920 2
    # We set PM_FILTER as late as possible so it can see all the earlier
    # on macro-order sensitive makes such as nmake.
a3926 4
		      MACROSTART MACROEND
                      USEMAKEFILE
                      PM_FILTER
                      FIXIN
d3947 1
a3947 6
    my @@xsubpp_dirs = @@INC;

    # Make sure we pick up the new xsubpp if we're building perl.
    unshift @@xsubpp_dirs, $self->{PERL_LIB} if $self->{PERL_CORE};

    foreach my $dir (@@xsubpp_dirs) {
a3972 9
    if ($Is_VMS                          &&
        $Config{'ldflags'}               && 
        $Config{'ldflags'} =~ m!/Debug!i &&
        (!exists($self->{XSOPT}) || $self->{XSOPT} !~ /linenumbers/)
       ) 
    {
        unshift(@@tmargs,'-nolinenumbers');
    }

d3978 1
a3978 2
XSUBPP = \$(XSUBPPDIR)\$(DFSEP)xsubpp
XSUBPPRUN = \$(PERLRUN) \$(XSUBPP)
d4015 1
a4015 1

d4023 7
a4029 1
config :: $(FIRST_MAKEFILE) blibdirs
d4033 19
d4057 1
a4057 1
help :
d4090 1
a4090 1
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(XSUBPP_EXTRA_ARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
d4105 1
a4105 1
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.cpp
d4121 1
a4121 1
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.xsc && $(MV) $*.xsc $*.c
@


1.1.1.11
log
@import perl 5.10.0 from CPAN
@
text
@d7 1
d17 1
d23 1
a23 1
$VERSION = '6.42';
d40 2
a41 3
    $Is_BSD     = ($^O =~ /^(?:free|net|open)bsd$/ or
                   grep( $^O eq $_, qw(bsdos interix dragonfly) )
                  );
a133 4
    
    my $command = '$(CCCMD)';
    my $flags   = '$(CCCDLFLAGS) "-I$(PERL_INC)" $(PASTHRU_DEFINE) $(DEFINE)';
    
d137 1
a137 1
        push @@m, qq{
d139 2
a140 2
	$cpp_cmd $flags \$*.c > \$*.i
};
d142 1
a142 2

    push @@m, qq{
d144 13
a156 1
	$command -S $flags \$*.c
d158 2
a159 2
.c\$(OBJ_EXT):
	$command $flags \$*.c
d161 4
a164 16
.cpp\$(OBJ_EXT):
	$command $flags \$*.cpp

.cxx\$(OBJ_EXT):
	$command $flags \$*.cxx

.cc\$(OBJ_EXT):
	$command $flags \$*.cc
};

    push @@m, qq{
.C\$(OBJ_EXT):
	$command \$*.C
} if !$Is_OS2 and !$Is_Win32 and !$Is_Dos; #Case-specific

    return join "", @@m;
d377 1
a377 1
              INSTALLDIRS INSTALL_BASE DESTDIR PREFIX
d637 1
a637 1
	$(RM_F) *~ */*~ *.orig */*.orig *.bak */*.bak *.old */*.old 
d931 1
a931 1
    if (($Is_NetBSD || $Is_Interix) && $Config{'useshrplib'} eq 'true') {
d1033 1
a1033 4
            $version_check = "$Config{run} $version_check"
                if defined $Config{run} and length $Config{run};

            # To avoid using the unportable 2>&1 to suppress STDERR,
d1047 1
a1047 1
            if ($val =~ /^VER_OK/m) {
d1051 1
a1051 1
                print "Result: '$val' ".($? >> 8)."\n";
d1068 2
a1069 2
sub fixin {    # stolen from the pink Camel book, more or less
    my ( $self, @@files ) = @@_;
d1071 1
a1071 1
    my ($does_shbang) = $Config{'sharpbang'} =~ /^\s*\#\!/;
d1076 9
a1084 9
        local (*FIXIN);
        local (*FIXOUT);
        open( FIXIN, $file ) or croak "Can't process '$file': $!";
        local $/ = "\n";
        chomp( my $line = <FIXIN> );
        next unless $line =~ s/^\s*\#!\s*//;    # Not a shbang file.
        # Now figure out the interpreter name.
        my ( $cmd, $arg ) = split ' ', $line, 2;
        $cmd =~ s!^.*/!!;
d1086 1
a1086 1
        # Now look (in reverse) for interpreter in absolute PATH (unless perl).
d1088 2
a1089 2
        if ( $cmd eq "perl" ) {
            if ( $Config{startperl} =~ m,^\#!.*/perl, ) {
d1092 1
a1092 2
            }
            else {
d1095 12
a1106 14
        }
        else {
            my (@@absdirs)
                = reverse grep { $self->file_name_is_absolute } $self->path;
            $interpreter = '';
            my ($dir);
            foreach $dir (@@absdirs) {
                if ( $self->maybe_command($cmd) ) {
                    warn "Ignoring $interpreter in $file\n"
                        if $Verbose && $interpreter;
                    $interpreter = $self->catfile( $dir, $cmd );
                }
            }
        }
d1108 10
a1117 14
        # Figure out how to invoke interpreter on this machine.

        my ($shb) = "";
        if ($interpreter) {
            print STDOUT "Changing sharpbang in $file to $interpreter"
                if $Verbose;

            # this is probably value-free on DOSISH platforms
            if ($does_shbang) {
                $shb .= "$Config{'sharpbang'}$interpreter";
                $shb .= ' ' . $arg if defined $arg;
                $shb .= "\n";
            }
            $shb .= qq{
d1120 6
a1125 7
} unless $Is_Win32;    # this won't work on win32, so don't
        }
        else {
            warn "Can't find $cmd in PATH, $file unchanged"
                if $Verbose;
            next;
        }
d1127 11
a1137 11
        unless ( open( FIXOUT, ">$file_new" ) ) {
            warn "Can't create new $file: $!\n";
            next;
        }

        # Print out the new #! line (or equivalent).
        local $\;
        local $/;
        print FIXOUT $shb, <FIXIN>;
        close FIXIN;
        close FIXOUT;
d1141 16
a1156 17
        unless ( _rename( $file, $file_bak ) ) {
            warn "Can't rename $file to $file_bak: $!";
            next;
        }
        unless ( _rename( $file_new, $file ) ) {
            warn "Can't rename $file_new to $file: $!";
            unless ( _rename( $file_bak, $file ) ) {
                warn "Can't rename $file_bak back to $file either: $!";
                warn "Leaving $file renamed as $file_bak\n";
            }
            next;
        }
        unlink $file_bak;
    }
    continue {
        close(FIXIN) if fileno(FIXIN);
        system("$Config{'eunicefix'} $file") if $Config{'eunicefix'} ne ':';
d1185 1
a1185 1
FORCE :
d1232 2
a1233 2
Scans the directory structure and initializes DIR, XS, XS_FILES,
C, C_FILES, O_FILES, H, H_FILES, PL_FILES, EXE_FILES.
d1241 2
a1242 1
    my($name, %dir, %xs, %c, %h, %pl_files, %pm);
a1285 136
    $self->{PL_FILES}   ||= \%pl_files;
    $self->{DIR}        ||= [sort keys %dir];
    $self->{XS}         ||= \%xs;
    $self->{C}          ||= [sort keys %c];
    $self->{H}          ||= [sort keys %h];
    $self->{PM}         ||= \%pm;

    my @@o_files = @@{$self->{C}};
    $self->{O_FILES} = [grep s/\.c(pp|xx|c)?\z/$self->{OBJ_EXT}/i, @@o_files];
}


=item init_MANPODS

Determines if man pages should be generated and initializes MAN1PODS
and MAN3PODS as appropriate.

=cut

sub init_MANPODS {
    my $self = shift;

    # Set up names of manual pages to generate from pods
    foreach my $man (qw(MAN1 MAN3)) {
	if ( $self->{"${man}PODS"}
             or $self->{"INSTALL${man}DIR"} =~ /^(none|\s*)$/
        ) {
            $self->{"${man}PODS"} ||= {};
        }
        else {
            my $init_method = "init_${man}PODS";
            $self->$init_method();
	}
    }
}


sub _has_pod {
    my($self, $file) = @@_;

    local *FH;
    my($ispod)=0;
    if (open(FH,"<$file")) {
	while (<FH>) {
	    if (/^=(?:head\d+|item|pod)\b/) {
		$ispod=1;
		last;
	    }
	}
	close FH;
    } else {
	# If it doesn't exist yet, we assume, it has pods in it
	$ispod = 1;
    }

    return $ispod;
}


=item init_MAN1PODS

Initializes MAN1PODS from the list of EXE_FILES.

=cut

sub init_MAN1PODS {
    my($self) = @@_;

    if ( exists $self->{EXE_FILES} ) {
	foreach my $name (@@{$self->{EXE_FILES}}) {
	    next unless $self->_has_pod($name);

	    $self->{MAN1PODS}->{$name} =
		$self->catfile("\$(INST_MAN1DIR)", 
			       basename($name).".\$(MAN1EXT)");
	}
    }
}


=item init_MAN3PODS

Initializes MAN3PODS from the list of PM files.

=cut

sub init_MAN3PODS {
    my $self = shift;

    my %manifypods = (); # we collect the keys first, i.e. the files
                         # we have to convert to pod

    foreach my $name (keys %{$self->{PM}}) {
	if ($name =~ /\.pod\z/ ) {
	    $manifypods{$name} = $self->{PM}{$name};
	} elsif ($name =~ /\.p[ml]\z/ ) {
	    if( $self->_has_pod($name) ) {
		$manifypods{$name} = $self->{PM}{$name};
	    }
	}
    }

    my $parentlibs_re = join '|', @@{$self->{PMLIBPARENTDIRS}};

    # Remove "Configure.pm" and similar, if it's not the only pod listed
    # To force inclusion, just name it "Configure.pod", or override 
    # MAN3PODS
    foreach my $name (keys %manifypods) {
	if ($self->{PERL_CORE} and $name =~ /(config|setup).*\.pm/is) {
	    delete $manifypods{$name};
	    next;
	}
	my($manpagename) = $name;
	$manpagename =~ s/\.p(od|m|l)\z//;
	# everything below lib is ok
	unless($manpagename =~ s!^\W*($parentlibs_re)\W+!!s) {
	    $manpagename = $self->catfile(
	        split(/::/,$self->{PARENT_NAME}),$manpagename
	    );
	}
	$manpagename = $self->replace_manpage_separator($manpagename);
	$self->{MAN3PODS}->{$name} =
	    $self->catfile("\$(INST_MAN3DIR)", "$manpagename.\$(MAN3EXT)");
    }
}


=item init_PM

Initializes PMLIBDIRS and PM from PMLIBDIRS.

=cut

sub init_PM {
    my $self = shift;

d1327 1
d1329 1
a1329 2
    my %dir = map { ($_ => $_) } @@{$self->{DIR}};
    foreach my $pmlibdir (@@pmlibdirs) {
a1332 6
    unless( $self->{PMLIBPARENTDIRS} ) {
	@@{$self->{PMLIBPARENTDIRS}} = ('lib');
    }

    return if $self->{PM} and $self->{ARGS}{PM};

a1351 1
	    my $parentlibs_re = join '|', @@{$self->{PMLIBPARENTDIRS}};
d1353 1
a1353 2
                if ($striplibpath = $path) =~ s{^(\W*)($parentlibs_re)\W}
	                                       {$1}i;
d1360 1
a1360 1
	    $self->{PM}{$path} = $inst;
d1363 97
a1461 1

d1531 18
a1548 11
        foreach my $dir_count (1..8) { # 8 is the VMS limit for nesting
            my $dir = $self->catdir(($Updir) x $dir_count);

            if (-f $self->catfile($dir,"config_h.SH")   &&
                -f $self->catfile($dir,"perl.h")        &&
                -f $self->catfile($dir,"lib","Exporter.pm")
            ) {
                $self->{PERL_SRC}=$dir ;
                last;
            }
        }
d1606 1
a1606 1
	    my $lib;
d1608 1
a1608 1
	      $lib = $dir, last if -e $self->catdir($dir, "Config.pm");
d1610 2
a1611 5
	    if ($lib) {
              # Win32 puts its header files in /perl/src/lib/CORE.
              # Unix leaves them in /perl/src.
	      my $inc = $Is_Win32 ? $self->catdir($lib, "CORE" )
                                  : dirname $lib;
d1613 2
a1614 2
		$self->{PERL_LIB}	   = $lib;
		$self->{PERL_ARCHLIB}	   = $lib;
d2077 1
a2077 1
		$(INST_SCRIPT) $(DESTINSTALLSITESCRIPT) \
d2090 1
a2090 1
		$(INST_SCRIPT) $(DESTINSTALLVENDORSCRIPT) \
d2483 1
a2483 1
doc_inst_perl :
d2496 1
a2496 1
inst_perl : pure_inst_perl doc_inst_perl
d2498 1
a2498 1
pure_inst_perl : $(MAP_TARGET)
d2590 16
d2636 1
a2636 3
    my $version = MM->parse_version($file);

Parse a $file and return what $VERSION is set to by the first assignment.
d2638 2
a2639 6
is. $VERSION should be for all to see, so C<our $VERSION> or plain $VERSION
are okay, but C<my $VERSION> is not.

parse_version() will try to C<use version> before checking for C<$VERSION> so the following will work.

    $VERSION = qv(1.2.3);
d2652 13
a2664 22
        $inpod = /^=(?!cut)/ ? 1 : /^=cut/ ? 0 : $inpod;
        next if $inpod || /^\s*#/;
        chop;
        next unless /(?<!\\)([\$*])(([\w\:\']*)\bVERSION)\b.*\=/;
        my $eval = qq{
            package ExtUtils::MakeMaker::_version;
            no strict;
            BEGIN { eval {
                # Ensure any version() routine which might have leaked
                # into this package has been deleted.  Interferes with
                # version->import()
                undef *version;
                require version;
                "version"->import;
            } }

            local $1$2;
            \$$2=undef;
            do {
                $_
            }; \$$2
        };
d2666 3
a2668 3
        $result = eval($eval);
        warn "Could not eval '$eval' in $parsefile: $@@" if $@@;
        last;
d2693 1
a2693 1
                     PREFIX INSTALL_BASE)
d2790 1
d2902 6
d2938 1
a2938 8
    my $archname = $Config{archname};
    if ($] >= 5.008) {
        # archname did not change from 5.6 to 5.8, but those versions may
        # not be not binary compatible so now we append the part of the
        # version that changes when binary compatibility may change
        $archname .= "-". substr($Config{version},0,3);
    }
    $ppd_xml .= sprintf <<'PPD_OUT', $archname;
d2967 1
a2967 1
ppd :
d3045 2
a3046 2
                $plfile = vmsify($self->eliminate_macros($plfile));
                $target = vmsify($self->eliminate_macros($target));
d3145 1
a3145 1
    return qq{\$(ABSPERLRUN) $switches -e $cmd --};   
d3378 1
a3378 5
test :: \$(TEST_TYPE) subdirs-test

subdirs-test ::
	\$(NOECHO) \$(NOOP)

d3382 5
a3386 1
        my $test = $self->cd($dir, '$(MAKE) test $(PASTHRU)');
d3388 1
a3388 5
        push @@m, <<END
subdirs-test ::
	\$(NOECHO) $test

END
@


1.1.1.12
log
@import perl 5.10.1
@
text
@d3 1
a3 1
require 5.006;
d12 6
a17 1
our %Config_Override;
d21 1
a21 3
# If we make $VERSION an our variable parse_version() breaks
use vars qw($VERSION);
$VERSION = '6.55_02';
d24 1
a24 1
our @@ISA = qw(ExtUtils::MM_Any);
a25 1
my %Is;
d27 12
a38 12
    $Is{OS2}     = $^O eq 'os2';
    $Is{Win32}   = $^O eq 'MSWin32' || $Config{osname} eq 'NetWare';
    $Is{Dos}     = $^O eq 'dos';
    $Is{VMS}     = $^O eq 'VMS';
    $Is{OSF}     = $^O eq 'dec_osf';
    $Is{IRIX}    = $^O eq 'irix';
    $Is{NetBSD}  = $^O eq 'netbsd';
    $Is{Interix} = $^O eq 'interix';
    $Is{SunOS4}  = $^O eq 'sunos';
    $Is{Solaris} = $^O eq 'solaris';
    $Is{SunOS}   = $Is{SunOS4} || $Is{Solaris};
    $Is{BSD}     = ($^O =~ /^(?:free|net|open)bsd$/ or
d44 1
a44 1
    if( $Is{VMS} ) {
d165 2
a166 2
	$command $flags \$*.C
} if !$Is{OS2} and !$Is{Win32} and !$Is{Dos}; #Case-specific
d234 2
a235 1
	foreach my $line (@@o){
d311 3
a313 6
    my @@m = <<"END";

# These definitions are from config.sh (via $INC{'Config.pm'}).
# They may have been overridden via Makefile.PL or on the command line.
END

d315 6
a320 6
    foreach my $key (@@{$self->{CONFIG}}){
        # SITE*EXP macros are defined in &constants; avoid duplicates here
        next if $once_only{$key};
        $self->{uc $key} = quote_paren($self->{uc $key});
        push @@m, uc($key) , ' = ' , $self->{uc $key}, "\n";
        $once_only{$key} = 1;
d341 6
a346 5
    for my $tmp (qw/
         EXTRALIBS LDLOADLIBS BSLOADLIBS
         /) {
        next unless defined $self->{$tmp};
        push @@m, "$tmp = $self->{$tmp}\n";
d349 5
a353 5
    for my $tmp (qw/
         LD_RUN_PATH
         /) {
        next unless $self->{$tmp};
        push @@m, "$tmp = $self->{$tmp}\n";
d397 1
a397 1
              PERM_DIR PERM_RW PERM_RWX
d861 1
a861 1
    my $target = $Is{VMS} ? '$(MMS$TARGET)' : '$@@';
d900 1
a900 1
    $armaybe = 'ar' if ($Is{OSF} and $armaybe eq ':');
d902 2
a903 2
    my $ld_opt = $Is{OS2} ? '$(OPTIMIZE) ' : '';	# Useful on other systems too?
    my $ld_fix = $Is{OS2} ? '|| ( $(RM_F) $@@ && sh -c false )' : '';
d919 1
a919 1
    $ldfrom = "-all $ldfrom -none" if $Is{OSF};
d922 1
a922 1
    my $ldrun = $Is{IRIX} && $self->{LD_RUN_PATH} ?         
d935 1
a935 1
    if (($Is{NetBSD} || $Is{Interix}) && $Config{'useshrplib'} eq 'true') {
d997 1
a997 1

d1008 2
a1009 4

    unless ($Is{BSD}) {
        # >& and lexical filehandles together give 5.6.2 indigestion
        if( open(STDERR_COPY, '>&STDERR') ) {  ## no critic
d1020 2
a1021 2
    foreach my $name (@@$names){
        foreach my $dir (@@$dirs){
d1046 1
a1046 1
            if ($Is{BSD}) {
d1051 1
a1051 4

                # 5.6.2's 3-arg open doesn't work with >&
                open STDERR, ">&STDERR_COPY"  ## no critic
                        if $stderr_duped;
d1083 3
a1085 1
        open( my $fixin, '<', $file ) or croak "Can't process '$file': $!";
d1087 1
a1087 1
        chomp( my $line = <$fixin> );
d1095 1
a1095 1
        if ( $cmd =~ m{^perl(?:\z|[^a-z])} ) {
d1106 1
a1106 1
                = reverse grep { $self->file_name_is_absolute($_) } $self->path;
d1108 2
a1109 2

            foreach my $dir (@@absdirs) {
d1134 1
a1134 1
} unless $Is{Win32};    # this won't work on win32, so don't
d1142 1
a1142 1
        open( my $fixout, ">", "$file_new" ) or do {
d1145 1
a1145 1
        };
d1150 3
a1152 3
        print $fixout $shb, <$fixin>;
        close $fixin;
        close $fixout;
d1171 1
d1181 1
a1181 1
        if( $Is{VMS} and basename($file) !~ /\./ ) {
d1257 1
a1257 1
    my(%dir, %xs, %c, %h, %pl_files, %pm);
d1262 1
a1262 1
    $Is{VMS} ? $ignore{"$self->{DISTVNAME}.dir"} = 1
d1265 1
a1265 1
    @@ignore{map lc, keys %ignore} = values %ignore if $Is{VMS};
d1267 1
a1267 1
    foreach my $name ($self->lsdir($Curdir)){
d1286 1
a1286 1
	} elsif (($Is{VMS} || $Is{Dos}) && $name =~ /[._]pl$/i) {
d1289 1
a1289 1
	    local($/); open(my $pl, '<', $name); my $txt = <$pl>; close $pl;
d1293 1
a1293 1
	    else {
d1325 1
a1325 1
        if ( $self->{"${man}PODS"}
d1333 1
a1333 1
        }
d1341 1
d1343 8
a1350 8
    if (open( my $fh, '<', $file )) {
        while (<$fh>) {
            if (/^=(?:head\d+|item|pod)\b/) {
                $ispod=1;
                last;
            }
        }
        close $fh;
d1352 2
a1353 2
        # If it doesn't exist yet, we assume, it has pods in it
        $ispod = 1;
d1464 1
a1464 1
        if( $Is{VMS} ) {
d1502 2
a1503 3
            return if /~$/;             # emacs temp files
            return if /,v$/;            # RCS files
            return if m{\.swp$};        # vim swap files
d1599 1
a1599 1
                -f $self->catfile($dir,"lib","strict.pm")
d1618 1
a1618 1
                                 $Is{Win32}?("CORE"):());
d1622 1
a1622 1
            $self->{PERL_INC}     = ($Is{Win32}) ? 
d1630 1
a1630 1
		$Is{VMS}
d1634 1
a1634 1
		$Is{Win32}
d1664 1
a1664 1
	      $lib = $dir, last if -e $self->catfile($dir, "Config.pm");
d1669 1
a1669 1
	      my $inc = $Is{Win32} ? $self->catdir($lib, "CORE" )
d1671 1
a1671 1
	      if (-e $self->catfile($inc, "perl.h")) {
d1696 1
a1696 1
        if ($self->{CONFIG} and ref $self->{CONFIG} ne 'ARRAY');
d1702 5
a1706 5
        next if $once_only{$m};
        print STDOUT "CONFIG key '$m' does not exist in Config.pm\n"
                unless exists $Config{$m};
        $self->{uc $m} ||= $Config{$m};
        $once_only{$m} = 1;
d1726 1
a1726 1
    # make a simple check if we find strict
d1728 3
a1730 3
        (strict.pm not found)"
        unless -f $self->catfile("$self->{PERL_LIB}","strict.pm") ||
               $self->{NAME} eq "ExtUtils::MakeMaker";
d1745 63
d1817 18
a1834 6
    $self->{FALSE}      ||= 'false';
    $self->{TRUE}       ||= 'true';

    $self->{LD}         ||= 'ld';

    $self->SUPER::init_others(@@_);
d1836 2
a1837 3
    # After SUPER::init_others so $Config{shell} has a
    # chance to get set.
    $self->{SHELL}      ||= '/bin/sh';
d1934 1
a1934 1
      $Is{VMS} ? $thisperl =~ m/$Config{exe_ext}(;\d+)?$/i
d1961 1
a1961 1
    $perl_name = 'ndbgperl' if $Is{VMS} && 
a1978 5

        # Quote the perl command if it contains whitespace
        $self->{ABSPERL} = $self->quote_literal($self->{ABSPERL})
          if $self->{ABSPERL} =~ /\s/;

a2046 1
    $self->{PERM_DIR} = 755  unless defined $self->{PERM_DIR};
d2091 1
a2091 1
install :: pure_install doc_install
d2094 1
a2094 1
install_perl :: pure_perl_install doc_perl_install
d2097 1
a2097 1
install_site :: pure_site_install doc_site_install
d2100 1
a2100 1
install_vendor :: pure_vendor_install doc_vendor_install
d2115 1
a2115 1
pure_perl_install :: all
d2129 1
a2129 1
pure_site_install :: all
d2142 1
a2142 1
pure_vendor_install :: all
d2153 1
a2153 1
doc_perl_install :: all
d2164 1
a2164 1
doc_site_install :: all
d2175 1
a2175 1
doc_vendor_install :: all
d2218 1
a2218 1
    @@exefiles = map vmsify($_), @@exefiles if $Is{VMS};
d2228 1
a2228 1
        $to = vmsify($to) if $Is{VMS};
d2402 2
d2405 1
a2405 1
		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
d2411 1
a2411 1
		foreach my $incl ((@@{$self->{INCLUDE_EXT}},'DynaLoader')){
d2420 4
a2423 1
		(my $xx = $File::Find::name) =~ s,.*?/auto/,,s;
d2428 1
a2428 1
		foreach my $excl (@@{$self->{EXCLUDE_EXT}}){
d2456 1
a2456 1
    s/^(.*)/"-I$1"/ for @@{$perlinc || []};
d2486 1
a2486 1
          if ($Is{SunOS}) {
d2489 1
a2489 1
            $libperl = '' if $Is{SunOS4};
d2513 2
a2514 1
    foreach my $catfile (@@$extra){
d2586 1
a2586 1
    my $newer_than_target = $Is{VMS} ? '$(MMS$SOURCE_LIST)' : '$?';
d2601 1
a2601 1
	$(FALSE)
d2631 2
a2632 2

    my $caller = (caller(0))[3];
d2640 1
a2640 1
    foreach my $child (keys %{$self->{CHILDREN}}) {
d2659 1
a2659 1

d2661 1
a2661 1
    open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
d2665 1
a2665 1
    while (<$fh>) {
d2673 1
a2673 2
    close $fh;

d2686 1
a2686 2
parse_version() will try to C<use version> before checking for
C<$VERSION> so the following will work.
d2695 1
a2695 1

d2698 1
a2698 1
    open(my $fh, '<', $parsefile) or die "Could not open '$parsefile': $!";
d2700 1
a2700 1
    while (<$fh>) {
d2704 1
a2704 2
        next if /^\s*(if|unless)/;
        next unless m{(?<!\\) ([\$*]) (([\w\:\']*) \bVERSION)\b .* =}x;
d2721 1
a2721 2
            };
            \$$2;
d2724 1
a2724 1
        $result = eval($eval);  ## no critic
d2726 1
a2726 1
        last if defined $result;
d2728 1
a2728 1
    close $fh;
d2744 1
a2744 1
    my(@@m);
d2747 1
a2747 1
    my($sep) = $Is{VMS} ? ',' : '';
d2750 1
a2750 1
    foreach my $key (qw(LIB LIBPERL_A LINKTYPE OPTIMIZE
d2758 1
a2758 1
    foreach my $key (qw(DEFINE INC)) {
d2799 1
a2799 1
	-$(NOECHO) $(ECHO) "Warning: $(PERL_INC)/config.h out of date with $(PERL_SRC)/config.sh"; $(FALSE)
d2861 29
d2901 1
a2901 1
pm_to_blib : $(FIRST_MAKEFILE) $(TO_INST_PM)
a2903 1
    # VMS will swallow '' and PM_FILTER is often empty.  So use q[]
d2905 1
a2905 1
pm_to_blib({\@@ARGV}, '$autodir', q[\$(PM_FILTER)], '\$(PERM_DIR)')
a2948 8
# transform dot-separated version string into comma-separated quadruple
# examples:  '1.2.3.4.5' => '1,2,3,4'
#            '1.2.3'     => '1,2,3,0'
sub _ppd_version {
    my ($self, $string) = @@_;
    return join ',', ((split /\./, $string), (0) x 4)[0..3];
}

d2959 2
d2970 1
a2970 1
    my $ppd_xml = sprintf <<'PPD_HTML', $self->{VERSION}, $abstract, $author;
d2972 1
d2978 8
a2985 5
    if ( $self->{MIN_PERL_VERSION} ) {
        my $min_perl_version = $self->_ppd_version($self->{MIN_PERL_VERSION});
        $ppd_xml .= sprintf <<'PPD_PERLVERS', $min_perl_version;
        <PERLCORE VERSION="%s" />
PPD_PERLVERS
a2988 17
    # Don't add "perl" to requires.  perl dependencies are
    # handles by ARCHITECTURE.
    my %prereqs = %{$self->{PREREQ_PM}};
    delete $prereqs{perl};

    # Build up REQUIRE
    foreach my $prereq (sort keys %prereqs) {
        my $name = $prereq;
        $name .= '::' unless $name =~ /::/;
        my $version = $prereqs{$prereq}+0;  # force numification

        my %attrs = ( NAME => $name );
        $attrs{VERSION} = $version if $version;
        my $attrs = join " ", map { qq[$_="$attrs{$_}"] } keys %attrs;
        $ppd_xml .= qq(        <REQUIRE $attrs />\n);
    }

d2994 1
a2994 1
        $archname .= "-$Config{PERL_REVISION}.$Config{PERL_VERSION}";
d2997 1
d3068 1
a3068 1
    if( $self->{ARGS}{PREFIX} &&
d3102 1
a3102 1
            if( $Is{VMS} ) {
d3391 1
a3391 1
    my(@@m);
d3395 1
a3395 1
    foreach my $dir (@@{$self->{DIR}}){
d3511 34
d3571 9
a3579 8
        foreach my $typemap (@@{$self->{TYPEMAPS}}){
            if( ! -f  $typemap ) {
                warn "Typemap $typemap not found.\n";
            }
            else {
                push(@@tmdeps,  $typemap);
            }
        }
d3584 1
a3584 1
        unshift( @@tmargs, $self->{XSOPT} );
d3587 1
a3587 1
    if ($Is{VMS}                          &&
@


