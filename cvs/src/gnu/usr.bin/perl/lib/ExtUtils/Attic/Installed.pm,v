head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.6.0.4
	OPENBSD_4_8_BASE:1.1.1.6
	OPENBSD_4_7:1.1.1.6.0.2
	OPENBSD_4_7_BASE:1.1.1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.20
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.18
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.16
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.14
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.12
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.4.0.10
	OPENBSD_3_9_BASE:1.1.1.4
	OPENBSD_3_8:1.1.1.4.0.8
	OPENBSD_3_8_BASE:1.1.1.4
	OPENBSD_3_7:1.1.1.4.0.6
	OPENBSD_3_7_BASE:1.1.1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.1.1.4.0.4
	OPENBSD_3_6_BASE:1.1.1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.1.1.4.0.2
	OPENBSD_3_5_BASE:1.1.1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.1.1.3.0.4
	OPENBSD_3_4_BASE:1.1.1.3
	OPENBSD_3_3:1.1.1.3.0.2
	OPENBSD_3_3_BASE:1.1.1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.1.1.2.0.12
	OPENBSD_3_2_BASE:1.1.1.2
	OPENBSD_3_1:1.1.1.2.0.10
	OPENBSD_3_1_BASE:1.1.1.2
	OPENBSD_3_0:1.1.1.2.0.8
	OPENBSD_3_0_BASE:1.1.1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2010.09.24.14.59.38;	author millert;	state dead;
branches;
next	1.1;

1.1
date	99.04.29.22.40.02;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.02;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.41;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.02;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.32;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.50;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package ExtUtils::Installed;
use strict;
use Carp qw();
use ExtUtils::Packlist;
use ExtUtils::MakeMaker;
use Config;
use File::Find;
use File::Basename;
use vars qw($VERSION);
$VERSION = '0.02';

sub _is_type($$$)
{
my ($self, $path, $type) = @@_;
return(1) if ($type eq "all");
if ($type eq "doc")
   {
   return(substr($path, 0, length($Config{installman1dir}))
              eq $Config{installman1dir}
          ||
          substr($path, 0, length($Config{installman3dir}))
              eq $Config{installman3dir}
          ? 1 : 0)
   }
if ($type eq "prog")
   {
   return(substr($path, 0, length($Config{prefix})) eq $Config{prefix}
          &&
          substr($path, 0, length($Config{installman1dir}))
             ne $Config{installman1dir}
          &&
          substr($path, 0, length($Config{installman3dir}))
              ne $Config{installman3dir}
          ? 1 : 0);
   }
return(0);
}

sub _is_under($$;)
{
my ($self, $path, @@under) = @@_;
$under[0] = "" if (! @@under);
foreach my $dir (@@under)
   {
   return(1) if (substr($path, 0, length($dir)) eq $dir);
   }
return(0);
}

sub new($)
{
my ($class) = @@_;
$class = ref($class) || $class;
my $self = {};

# Read the core packlist
$self->{Perl}{packlist} =
   ExtUtils::Packlist->new("$Config{installarchlib}/.packlist");
$self->{Perl}{version} = $];

# Read the module packlists
my $sub = sub
   {
   # Only process module .packlists
   return if ($_) ne ".packlist" || $File::Find::dir eq $Config{installarchlib};

   # Hack of the leading bits of the paths & convert to a module name
   my $module = $File::Find::name;
   $module =~ s!$Config{archlib}/auto/(.*)/.packlist!$1!;
   $module =~ s!$Config{sitearch}/auto/(.*)/.packlist!$1!;
   my $modfile = "$module.pm";
   $module =~ s!/!::!g;

   # Find the top-level module file in @@INC
   $self->{$module}{version} = '';
   foreach my $dir (@@INC)
      {
      my $p = MM->catfile($dir, $modfile);
      if (-f $p)
         {
         $self->{$module}{version} = MM->parse_version($p);
         last;
         }
      }

   # Read the .packlist
   $self->{$module}{packlist} = ExtUtils::Packlist->new($File::Find::name);
   };
find($sub, $Config{archlib}, $Config{sitearch});

return(bless($self, $class));
}

sub modules($)
{
my ($self) = @@_;
return(sort(keys(%$self)));
}

sub files($$;$)
{
my ($self, $module, $type, @@under) = @@_;

# Validate arguments
Carp::croak("$module is not installed") if (! exists($self->{$module}));
$type = "all" if (! defined($type));
Carp::croak('type must be "all", "prog" or "doc"')
   if ($type ne "all" && $type ne "prog" && $type ne "doc");

my (@@files);
foreach my $file (keys(%{$self->{$module}{packlist}}))
   {
   push(@@files, $file)
      if ($self->_is_type($file, $type) && $self->_is_under($file, @@under));
   }
return(@@files);
}

sub directories($$;$)
{
my ($self, $module, $type, @@under) = @@_;
my (%dirs);
foreach my $file ($self->files($module, $type, @@under))
   {
   $dirs{dirname($file)}++;
   }
return(sort(keys(%dirs)));
}

sub directory_tree($$;$)
{
my ($self, $module, $type, @@under) = @@_;
my (%dirs);
foreach my $dir ($self->directories($module, $type, @@under))
   {
   $dirs{$dir}++;
   my ($last) = ("");
   while ($last ne $dir)
      {
      $last = $dir;
      $dir = dirname($dir);
      last if (! $self->_is_under($dir, @@under));
      $dirs{$dir}++;
      }
   }
return(sort(keys(%dirs)));
}

sub validate($;$)
{
my ($self, $module, $remove) = @@_;
Carp::croak("$module is not installed") if (! exists($self->{$module}));
return($self->{$module}{packlist}->validate($remove));
}

sub packlist($$)
{
my ($self, $module) = @@_;
Carp::croak("$module is not installed") if (! exists($self->{$module}));
return($self->{$module}{packlist});
}

sub version($$)
{
my ($self, $module) = @@_;
Carp::croak("$module is not installed") if (! exists($self->{$module}));
return($self->{$module}{version});
}

sub DESTROY
{
}

1;

__END__

=head1 NAME

ExtUtils::Installed - Inventory management of installed modules

=head1 SYNOPSIS

   use ExtUtils::Installed;
   my ($inst) = ExtUtils::Installed->new();
   my (@@modules) = $inst->modules();
   my (@@missing) = $inst->validate("DBI");
   my $all_files = $inst->files("DBI");
   my $files_below_usr_local = $inst->files("DBI", "all", "/usr/local");
   my $all_dirs = $inst->directories("DBI");
   my $dirs_below_usr_local = $inst->directory_tree("DBI", "prog");
   my $packlist = $inst->packlist("DBI");

=head1 DESCRIPTION

ExtUtils::Installed  provides a standard way to find out what core and module
files have been installed.  It uses the information stored in .packlist files
created during installation to provide this information.  In addition it
provides facilities to classify the installed files and to extract directory
information from the .packlist files.

=head1 USAGE

The new() function searches for all the installed .packlists on the system, and
stores their contents. The .packlists can be queried with the functions
described below.

=head1 FUNCTIONS

=over

=item new()

This takes no parameters, and searches for all the installed .packlists on the
system.  The packlists are read using the ExtUtils::packlist module.

=item modules()

This returns a list of the names of all the installed modules.  The perl 'core'
is given the special name 'Perl'.

=item files()

This takes one mandatory parameter, the name of a module.  It returns a list of
all the filenames from the package.  To obtain a list of core perl files, use
the module name 'Perl'.  Additional parameters are allowed.  The first is one
of the strings "prog", "man" or "all", to select either just program files,
just manual files or all files.  The remaining parameters are a list of
directories. The filenames returned will be restricted to those under the
specified directories.

=item directories()

This takes one mandatory parameter, the name of a module.  It returns a list of
all the directories from the package.  Additional parameters are allowed.  The
first is one of the strings "prog", "man" or "all", to select either just
program directories, just manual directories or all directories.  The remaining
parameters are a list of directories. The directories returned will be
restricted to those under the specified directories.  This method returns only
the leaf directories that contain files from the specified module.

=item directory_tree()

This is identical in operation to directory(), except that it includes all the
intermediate directories back up to the specified directories.

=item validate()

This takes one mandatory parameter, the name of a module.  It checks that all
the files listed in the modules .packlist actually exist, and returns a list of
any missing files.  If an optional second argument which evaluates to true is
given any missing files will be removed from the .packlist

=item packlist()

This returns the ExtUtils::Packlist object for the specified module.

=item version()

This returns the version number for the specified module.

=back

=head1 EXAMPLE

See the example in L<ExtUtils::Packlist>.

=head1 AUTHOR

Alan Burlison <Alan.Burlison@@uk.sun.com>

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a1 2

use 5.005_64;
d9 2
a10 1
our $VERSION = '0.02';
d59 1
a59 1
$self->{Perl}{version} = $Config{version};
d69 2
a70 2
   $module =~ s!$Config{archlib}/auto/(.*)/.packlist!$1!s;
   $module =~ s!$Config{sitearch}/auto/(.*)/.packlist!$1!s;
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
use 5.00503;
d11 1
a11 2
use File::Spec;
require VMS::Filespec if $^O eq 'VMS';
d13 157
a169 4
use vars qw($VERSION);
$VERSION = '0.06';

my $DOSISH = ($^O =~ /^(MSWin\d\d|os2|dos|mint)$/);
d171 2
a172 178
sub _is_prefix {
    my ($self, $path, $prefix) = @@_;
    return unless defined $prefix && defined $path;

    if( $^O eq 'VMS' ) {
        $prefix = VMS::Filespec::unixify($prefix);
        $path   = VMS::Filespec::unixify($path);
    }
    return 1 if substr($path, 0, length($prefix)) eq $prefix;

    if ($DOSISH) {
        $path =~ s|\\|/|g;
        $prefix =~ s|\\|/|g;
        return 1 if $path =~ m{^\Q$prefix\E}i;
    }
    return(0);
}

sub _is_doc { 
    my ($self, $path) = @@_;
    my $man1dir = $Config{man1direxp};
    my $man3dir = $Config{man3direxp};
    return(($man1dir && $self->_is_prefix($path, $man1dir))
           ||
           ($man3dir && $self->_is_prefix($path, $man3dir))
           ? 1 : 0)
}
 
sub _is_type {
    my ($self, $path, $type) = @@_;
    return 1 if $type eq "all";

    return($self->_is_doc($path)) if $type eq "doc";

    if ($type eq "prog") {
        return($self->_is_prefix($path, $Config{prefix} || $Config{prefixexp})
               &&
               !($self->_is_doc($path))
               ? 1 : 0);
    }
    return(0);
}

sub _is_under {
    my ($self, $path, @@under) = @@_;
    $under[0] = "" if (! @@under);
    foreach my $dir (@@under) {
        return(1) if ($self->_is_prefix($path, $dir));
    }

    return(0);
}

sub new {
    my ($class) = @@_;
    $class = ref($class) || $class;
    my $self = {};

    my $archlib = $Config{archlibexp};
    my $sitearch = $Config{sitearchexp};

    # File::Find does not know how to deal with VMS filepaths.
    if( $^O eq 'VMS' ) {
        $archlib  = VMS::Filespec::unixify($archlib);
        $sitearch = VMS::Filespec::unixify($sitearch);
    }

    if ($DOSISH) {
        $archlib =~ s|\\|/|g;
        $sitearch =~ s|\\|/|g;
    }

    # Read the core packlist
    $self->{Perl}{packlist} =
      ExtUtils::Packlist->new( File::Spec->catfile($archlib, '.packlist') );
    $self->{Perl}{version} = $Config{version};

    # Read the module packlists
    my $sub = sub {
        # Only process module .packlists
        return if ($_) ne ".packlist" || $File::Find::dir eq $archlib;

        # Hack of the leading bits of the paths & convert to a module name
        my $module = $File::Find::name;

        $module =~ s!\Q$archlib\E/?auto/(.*)/.packlist!$1!s  or
        $module =~ s!\Q$sitearch\E/?auto/(.*)/.packlist!$1!s;
        my $modfile = "$module.pm";
        $module =~ s!/!::!g;

        # Find the top-level module file in @@INC
        $self->{$module}{version} = '';
        foreach my $dir (@@INC) {
            my $p = File::Spec->catfile($dir, $modfile);
            if (-f $p) {
                require ExtUtils::MM;
                $self->{$module}{version} = MM->parse_version($p);
                last;
            }
        }

        # Read the .packlist
        $self->{$module}{packlist} = 
          ExtUtils::Packlist->new($File::Find::name);
    };

    my(@@dirs) = grep { -e } ($archlib, $sitearch);
    find($sub, @@dirs) if @@dirs;

    return(bless($self, $class));
}

sub modules {
    my ($self) = @@_;

    # Bug/feature of sort in scalar context requires this.
    return wantarray ? sort keys %$self : keys %$self;
}

sub files {
    my ($self, $module, $type, @@under) = @@_;

    # Validate arguments
    Carp::croak("$module is not installed") if (! exists($self->{$module}));
    $type = "all" if (! defined($type));
    Carp::croak('type must be "all", "prog" or "doc"')
        if ($type ne "all" && $type ne "prog" && $type ne "doc");

    my (@@files);
    foreach my $file (keys(%{$self->{$module}{packlist}})) {
        push(@@files, $file)
          if ($self->_is_type($file, $type) && 
              $self->_is_under($file, @@under));
    }
    return(@@files);
}

sub directories {
    my ($self, $module, $type, @@under) = @@_;
    my (%dirs);
    foreach my $file ($self->files($module, $type, @@under)) {
        $dirs{dirname($file)}++;
    }
    return sort keys %dirs;
}

sub directory_tree {
    my ($self, $module, $type, @@under) = @@_;
    my (%dirs);
    foreach my $dir ($self->directories($module, $type, @@under)) {
        $dirs{$dir}++;
        my ($last) = ("");
        while ($last ne $dir) {
            $last = $dir;
            $dir = dirname($dir);
            last if !$self->_is_under($dir, @@under);
            $dirs{$dir}++;
        }
    }
    return(sort(keys(%dirs)));
}

sub validate {
    my ($self, $module, $remove) = @@_;
    Carp::croak("$module is not installed") if (! exists($self->{$module}));
    return($self->{$module}{packlist}->validate($remove));
}

sub packlist {
    my ($self, $module) = @@_;
    Carp::croak("$module is not installed") if (! exists($self->{$module}));
    return($self->{$module}{packlist});
}

sub version {
    my ($self, $module) = @@_;
    Carp::croak("$module is not installed") if (! exists($self->{$module}));
    return($self->{$module}{version});
a174 1

d211 1
a211 1
=over 4
d228 1
a228 1
of the strings "prog", "doc" or "all", to select either just program files,
d237 1
a237 1
first is one of the strings "prog", "doc" or "all", to select either just
d245 1
a245 1
This is identical in operation to directories(), except that it includes all the
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d12 4
a16 1
my $Is_VMS = $^O eq 'VMS';
a18 5
require VMS::Filespec if $Is_VMS;

use vars qw($VERSION);
$VERSION = '0.08';

d23 1
a23 1
    if( $Is_VMS ) {
a26 5

    # Sloppy Unix path normalization.
    $prefix =~ s{/+}{/}g;
    $path   =~ s{/+}{/}g;

d81 1
a81 1
    if( $Is_VMS ) {
d99 1
a99 1
        return if $_ ne ".packlist" || $File::Find::dir eq $archlib;
d113 1
a113 3
            if (-r $p) {
                $module = _module_name($p, $module) if $Is_VMS;

a129 30

# VMS's non-case preserving file-system means the package name can't
# be reconstructed from the filename.
sub _module_name {
    my($file, $orig_module) = @@_;

    my $module = '';
    if (open PACKFH, $file) {
        while (<PACKFH>) {
            if (/package\s+(\S+)\s*;/) {
                my $pack = $1;
                # Make a sanity check, that lower case $module
                # is identical to lowercase $pack before
                # accepting it
                if (lc($pack) eq lc($orig_module)) {
                    $module = $pack;
                    last;
                }
            }
        }
        close PACKFH;
    }

    print STDERR "Couldn't figure out the package name for $file\n"
      unless $module;

    return $module;
}


@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d19 1
a19 2
$VERSION = '1.43';
$VERSION = eval $VERSION;
d44 1
a44 1
sub _is_doc {
d46 2
a47 3

    my $man1dir = $self->{':private:'}{Config}{man1direxp};
    my $man3dir = $self->{':private:'}{Config}{man3direxp};
d53 1
a53 1

d61 1
a61 1
        return($self->_is_prefix($path, $self->{':private:'}{Config}{prefix} || $self->{':private:'}{Config}{prefixexp})
d80 1
a80 1
    my ($class) = shift(@@_);
d82 1
d84 2
a85 3
    my %args = @@_;

    my $self = {};
a86 39
    if ($args{config_override}) {
        eval {
            $self->{':private:'}{Config} = { %{$args{config_override}} };
        } or Carp::croak(
            "The 'config_override' parameter must be a hash reference."
        );
    }
    else {
        $self->{':private:'}{Config} = \%Config;
    }
    
    for my $tuple ([inc_override => INC => [ @@INC ] ],
                   [ extra_libs => EXTRA => [] ]) 
    {
        my ($arg,$key,$val)=@@$tuple;
        if ( $args{$arg} ) {
            eval {
                $self->{':private:'}{$key} = [ @@{$args{$arg}} ];
            } or Carp::croak(
                "The '$arg' parameter must be an array reference."
            );
        }
        elsif ($val) {
            $self->{':private:'}{$key} = $val;
        }
    }
    {
        my %dupe;
        @@{$self->{':private:'}{INC}} = grep { -e $_ && !$dupe{$_}++ }
            @@{$self->{':private:'}{INC}}, @@{$self->{':private:'}{EXTRA}};        
    }                
    my $perl5lib = defined $ENV{PERL5LIB} ? $ENV{PERL5LIB} : "";

    my @@dirs = ( $self->{':private:'}{Config}{archlibexp},
                 $self->{':private:'}{Config}{sitearchexp},
                 split(/\Q$Config{path_sep}\E/, $perl5lib),
                 @@{$self->{':private:'}{EXTRA}},
               );   
    
d89 2
a90 2
        $_ = VMS::Filespec::unixify($_) 
            for @@dirs;
d94 2
a95 1
        s|\\|/|g for @@dirs;
d97 1
a97 2
    my $archlib = $dirs[0];
    
d101 1
a101 1
    $self->{Perl}{version} = $self->{':private:'}{Config}{version};
d110 3
a112 10
        my $found;
        for (@@dirs) {
            $found = $module =~ s!\Q$_\E/?auto/(.*)/.packlist!$1!s
                and last;
        }            
        unless ($found) {
            # warn "Woah! \$_=$_\n\$module=$module\n\$File::Find::dir=$File::Find::dir\n",
            #    join ("\n",@@dirs);
            return;
        }            
d118 1
a118 1
        foreach my $dir (@@{$self->{':private:'}{INC}}) {
d123 1
d130 1
a130 1
        $self->{$module}{packlist} =
d133 2
a134 3
    my %dupe;
    @@dirs= grep { -e $_ && !$dupe{$_}++ } @@dirs;
    $self->{':private:'}{LIBDIRS} = \@@dirs;    
d174 1
a174 3
    return wantarray
        ? sort grep { not /^:private:$/ } keys %$self
        : grep { not /^:private:$/ } keys %$self;
d189 1
a189 1
          if ($self->_is_type($file, $type) &&
d271 1
a271 2
described below. Where it searches by default is determined by the settings found
in C<%Config::Config>, and what the value is of the PERL5LIB environment variable.
d279 2
a280 29
This takes optional named parameters. Without parameters, this
searches for all the installed .packlists on the system using
information from C<%Config::Config> and the default module search
paths C<@@INC>. The packlists are read using the
L<ExtUtils::Packlist> module.

If the named parameter C<config_override> is specified,
it should be a reference to a hash which contains all information
usually found in C<%Config::Config>. For example, you can obtain
the configuration information for a separate perl installation and
pass that in.

    my $yoda_cfg  = get_fake_config('yoda');
    my $yoda_inst = ExtUtils::Installed->new(config_override=>$yoda_cfg);

Similarly, the parameter C<inc_override> may be a reference to an
array which is used in place of the default module search paths
from C<@@INC>. 

    use Config;
    my @@dirs = split(/\Q$Config{path_sep}\E/, $ENV{PERL5LIB});
    my $p5libs = ExtUtils::Installed->new(inc_override=>\@@dirs);

The parameter c<extra_libs> can be used to specify B<additional> paths to 
search for installed modules. For instance 

    my $installed = ExtUtils::Installed->new(extra_libs=>["/my/lib/path"]);

This should only be necessary if C</my/lib/path> is not in PERL5LIB.
@


1.1.1.6
log
@import perl 5.10.1
@
text
@a4 1
#use warnings; # XXX requires 5.6
d19 1
a19 1
$VERSION = '1.999_001';
d31 3
a33 2
    # Unix path normalization.
    $prefix = File::Spec->canonpath($prefix);
d61 1
a61 1
    my $conf= $self->{':private:'}{Config};
d63 4
a66 2
        return($self->_is_prefix($path, $conf->{prefix} || $conf->{prefixexp})
               && !($self->_is_doc($path)) ? 1 : 0);
a80 45
sub _fix_dirs {
    my ($self, @@dirs)= @@_;
    # File::Find does not know how to deal with VMS filepaths.
    if( $Is_VMS ) {
        $_ = VMS::Filespec::unixify($_)
            for @@dirs;
    }

    if ($DOSISH) {
        s|\\|/|g for @@dirs;
    }
    return wantarray ? @@dirs : $dirs[0];
}

sub _make_entry {
    my ($self, $module, $packlist_file, $modfile)= @@_;

    my $data= {
        module => $module,
        packlist => scalar(ExtUtils::Packlist->new($packlist_file)),
        packlist_file => $packlist_file,
    };

    if (!$modfile) {
        $data->{version} = $self->{':private:'}{Config}{version};
    } else {
        $data->{modfile} = $modfile;
        # Find the top-level module file in @@INC
        $data->{version} = '';
        foreach my $dir (@@{$self->{':private:'}{INC}}) {
            my $p = File::Spec->catfile($dir, $modfile);
            if (-r $p) {
                $module = _module_name($p, $module) if $Is_VMS;

                $data->{version} = MM->parse_version($p);
                $data->{version_from} = $p;
                $data->{packlist_valid} = exists $data->{packlist}{$p};
                last;
            }
        }
    }
    $self->{$module}= $data;
}

our $INSTALLED;
d87 1
a87 6
    return $INSTALLED if $INSTALLED and ($args{default_get} || $args{default});

    my $self = bless {}, $class;

    $INSTALLED= $self if $args{default_set} || $args{default};

d99 1
a99 1

d101 1
a101 1
                   [ extra_libs => EXTRA => [] ])
d117 15
a131 2
        @@{$self->{':private:'}{LIBDIRS}} = grep { -e $_ && !$dupe{$_}++ }
            @@{$self->{':private:'}{EXTRA}}, @@{$self->{':private:'}{INC}};
d134 5
a138 2
    my @@dirs= $self->_fix_dirs(@@{$self->{':private:'}{LIBDIRS}});

d140 3
a142 2
    my $archlib = $self->_fix_dirs($self->{':private:'}{Config}{archlibexp});
    $self->_make_entry("Perl",File::Spec->catfile($archlib, '.packlist'));
a143 1
    my $root;
d151 6
a156 2
        my $found = $module =~ s!^.*?/auto/(.*)/.packlist!$1!s
            or do {
d160 1
a160 2
        };

d164 15
a178 2
        return if $self->{$module}; #shadowing?
        $self->_make_entry($module,$File::Find::name,$modfile);
d180 4
a183 5
    while (@@dirs) {
        $root= shift @@dirs;
        next if !-d $root;
        find($sub,$root);
    }
d185 1
a185 1
    return $self;
d216 2
a219 1
    $self= $self->new(default=>1) if !ref $self;
a228 1
    $self= $self->new(default=>1) if !ref $self;
a246 1
    $self= $self->new(default=>1) if !ref $self;
a255 1
    $self= $self->new(default=>1) if !ref $self;
a271 1
    $self= $self->new(default=>1) if !ref $self;
a277 1
    $self= $self->new(default=>1) if !ref $self;
a283 1
    $self= $self->new(default=>1) if !ref $self;
a287 8
sub debug_dump {
    my ($self, $module) = @@_;
    $self= $self->new(default=>1) if !ref $self;
    local $self->{":private:"}{Config};
    require Data::Dumper;
    print Data::Dumper->new([$self])->Sortkeys(1)->Indent(1)->Dump();
}

d324 1
a324 7
=head1 METHODS

Unless specified otherwise all method can be called as class methods, or as object
methods. If called as class methods then the "default" object will be used, and if
necessary created using the current processes %Config and @@INC.  See the
'default' option to new() for details.

d347 1
a347 1
from C<@@INC>.
d353 2
a354 5
B<Note>: You probably do not want to use these options alone, almost always
you will want to set both together.

The parameter c<extra_libs> can be used to specify B<additional> paths to
search for installed modules. For instance
a358 8

Finally there is the 'default', and the related 'default_get' and 'default_set'
options. These options control the "default" object which is provided by the
class interface to the methods. Setting C<default_get> to true tells the constructor
to return the default object if it is defined. Setting C<default_set> to true tells
the constructor to make the default object the constructed object. Setting the
C<default> option is like setting both to true. This is used primarily internally
and probably isn't interesting to any real user.
@


