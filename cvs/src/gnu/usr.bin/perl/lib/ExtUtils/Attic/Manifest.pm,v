head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2010.09.24.14.59.38;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.11;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.31;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.30;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.41;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.41;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.06;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.42;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.29;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.02;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.42;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.33;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package ExtUtils::Manifest;

require Exporter;
use Config;
use File::Basename;
use File::Copy 'copy';
use File::Find;
use File::Spec;
use Carp;
use strict;

use vars qw($VERSION @@ISA @@EXPORT_OK 
          $Is_MacOS $Is_VMS $Is_VMS_mode $Is_VMS_lc $Is_VMS_nodot
          $Debug $Verbose $Quiet $MANIFEST $DEFAULT_MSKIP);

$VERSION = '1.56';
@@ISA=('Exporter');
@@EXPORT_OK = qw(mkmanifest
                manicheck  filecheck  fullcheck  skipcheck
                manifind   maniread   manicopy   maniadd
                maniskip
               );

$Is_MacOS = $^O eq 'MacOS';
$Is_VMS   = $^O eq 'VMS';
$Is_VMS_mode = 0;
$Is_VMS_lc = 0;
$Is_VMS_nodot = 0;  # No dots in dir names or double dots in files

if ($Is_VMS) {
    require VMS::Filespec if $Is_VMS;
    my $vms_unix_rpt;
    my $vms_efs;
    my $vms_case;

    $Is_VMS_mode = 1;
    $Is_VMS_lc = 1;
    $Is_VMS_nodot = 1;
    if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
        $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
        $vms_efs = VMS::Feature::current("efs_charset");
        $vms_case = VMS::Feature::current("efs_case_preserve");
    } else {
        my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
        my $efs_case = $ENV{'DECC$EFS_CASE_PRESERVE'} || '';
        $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i; 
        $vms_efs = $efs_charset =~ /^[ET1]/i;
        $vms_case = $efs_case =~ /^[ET1]/i;
    }
    $Is_VMS_lc = 0 if ($vms_case);
    $Is_VMS_mode = 0 if ($vms_unix_rpt);
    $Is_VMS_nodot = 0 if ($vms_efs);
}

$Debug   = $ENV{PERL_MM_MANIFEST_DEBUG} || 0;
$Verbose = defined $ENV{PERL_MM_MANIFEST_VERBOSE} ?
                   $ENV{PERL_MM_MANIFEST_VERBOSE} : 1;
$Quiet = 0;
$MANIFEST = 'MANIFEST';

$DEFAULT_MSKIP = File::Spec->catfile( dirname(__FILE__), "$MANIFEST.SKIP" );


=head1 NAME

ExtUtils::Manifest - utilities to write and check a MANIFEST file

=head1 SYNOPSIS

    use ExtUtils::Manifest qw(...funcs to import...);

    mkmanifest();

    my @@missing_files    = manicheck;
    my @@skipped          = skipcheck;
    my @@extra_files      = filecheck;
    my($missing, $extra) = fullcheck;

    my $found    = manifind();

    my $manifest = maniread();

    manicopy($read,$target);

    maniadd({$file => $comment, ...});


=head1 DESCRIPTION

=head2 Functions

ExtUtils::Manifest exports no functions by default.  The following are
exported on request

=over 4

=item mkmanifest

    mkmanifest();

Writes all files in and below the current directory to your F<MANIFEST>.
It works similar to the result of the Unix command

    find . > MANIFEST

All files that match any regular expression in a file F<MANIFEST.SKIP>
(if it exists) are ignored.

Any existing F<MANIFEST> file will be saved as F<MANIFEST.bak>.

=cut

sub _sort {
    return sort { lc $a cmp lc $b } @@_;
}

sub mkmanifest {
    my $manimiss = 0;
    my $read = (-r 'MANIFEST' && maniread()) or $manimiss++;
    $read = {} if $manimiss;
    local *M;
    my $bakbase = $MANIFEST;
    $bakbase =~ s/\./_/g if $Is_VMS_nodot; # avoid double dots
    rename $MANIFEST, "$bakbase.bak" unless $manimiss;
    open M, "> $MANIFEST" or die "Could not open $MANIFEST: $!";
    my $skip = maniskip();
    my $found = manifind();
    my($key,$val,$file,%all);
    %all = (%$found, %$read);
    $all{$MANIFEST} = ($Is_VMS_mode ? "$MANIFEST\t\t" : '') .
                     'This list of files'
        if $manimiss; # add new MANIFEST to known file list
    foreach $file (_sort keys %all) {
	if ($skip->($file)) {
	    # Policy: only remove files if they're listed in MANIFEST.SKIP.
	    # Don't remove files just because they don't exist.
	    warn "Removed from $MANIFEST: $file\n" if $Verbose and exists $read->{$file};
	    next;
	}
	if ($Verbose){
	    warn "Added to $MANIFEST: $file\n" unless exists $read->{$file};
	}
	my $text = $all{$file};
	$file = _unmacify($file);
	my $tabs = (5 - (length($file)+1)/8);
	$tabs = 1 if $tabs < 1;
	$tabs = 0 unless $text;
        if ($file =~ /\s/) {
            $file =~ s/([\\'])/\\$1/g;
            $file = "'$file'";
        }
	print M $file, "\t" x $tabs, $text, "\n";
    }
    close M;
}

# Geez, shouldn't this use File::Spec or File::Basename or something?  
# Why so careful about dependencies?
sub clean_up_filename {
  my $filename = shift;
  $filename =~ s|^\./||;
  $filename =~ s/^:([^:]+)$/$1/ if $Is_MacOS;
  return $filename;
}


=item manifind

    my $found = manifind();

returns a hash reference. The keys of the hash are the files found
below the current directory.

=cut

sub manifind {
    my $p = shift || {};
    my $found = {};

    my $wanted = sub {
	my $name = clean_up_filename($File::Find::name);
	warn "Debug: diskfile $name\n" if $Debug;
	return if -d $_;

        if( $Is_VMS_lc ) {
            $name =~ s#(.*)\.$#\L$1#;
            $name = uc($name) if $name =~ /^MANIFEST(\.SKIP)?$/i;
        }
	$found->{$name} = "";
    };

    # We have to use "$File::Find::dir/$_" in preprocess, because 
    # $File::Find::name is unavailable.
    # Also, it's okay to use / here, because MANIFEST files use Unix-style 
    # paths.
    find({wanted => $wanted},
	 $Is_MacOS ? ":" : ".");

    return $found;
}


=item manicheck

    my @@missing_files = manicheck();

checks if all the files within a C<MANIFEST> in the current directory
really do exist. If C<MANIFEST> and the tree below the current
directory are in sync it silently returns an empty list.
Otherwise it returns a list of files which are listed in the
C<MANIFEST> but missing from the directory, and by default also
outputs these names to STDERR.

=cut

sub manicheck {
    return _check_files();
}


=item filecheck

    my @@extra_files = filecheck();

finds files below the current directory that are not mentioned in the
C<MANIFEST> file. An optional file C<MANIFEST.SKIP> will be
consulted. Any file matching a regular expression in such a file will
not be reported as missing in the C<MANIFEST> file. The list of any
extraneous files found is returned, and by default also reported to
STDERR.

=cut

sub filecheck {
    return _check_manifest();
}


=item fullcheck

    my($missing, $extra) = fullcheck();

does both a manicheck() and a filecheck(), returning then as two array
refs.

=cut

sub fullcheck {
    return [_check_files()], [_check_manifest()];
}


=item skipcheck

    my @@skipped = skipcheck();

lists all the files that are skipped due to your C<MANIFEST.SKIP>
file.

=cut

sub skipcheck {
    my($p) = @@_;
    my $found = manifind();
    my $matches = maniskip();

    my @@skipped = ();
    foreach my $file (_sort keys %$found){
        if (&$matches($file)){
            warn "Skipping $file\n";
            push @@skipped, $file;
            next;
        }
    }

    return @@skipped;
}


sub _check_files {
    my $p = shift;
    my $dosnames=(defined(&Dos::UseLFN) && Dos::UseLFN()==0);
    my $read = maniread() || {};
    my $found = manifind($p);

    my(@@missfile) = ();
    foreach my $file (_sort keys %$read){
        warn "Debug: manicheck checking from $MANIFEST $file\n" if $Debug;
        if ($dosnames){
            $file = lc $file;
            $file =~ s=(\.(\w|-)+)=substr ($1,0,4)=ge;
            $file =~ s=((\w|-)+)=substr ($1,0,8)=ge;
        }
        unless ( exists $found->{$file} ) {
            warn "No such file: $file\n" unless $Quiet;
            push @@missfile, $file;
        }
    }

    return @@missfile;
}


sub _check_manifest {
    my($p) = @@_;
    my $read = maniread() || {};
    my $found = manifind($p);
    my $skip  = maniskip();

    my @@missentry = ();
    foreach my $file (_sort keys %$found){
        next if $skip->($file);
        warn "Debug: manicheck checking from disk $file\n" if $Debug;
        unless ( exists $read->{$file} ) {
            my $canon = $Is_MacOS ? "\t" . _unmacify($file) : '';
            warn "Not in $MANIFEST: $file$canon\n" unless $Quiet;
            push @@missentry, $file;
        }
    }

    return @@missentry;
}


=item maniread

    my $manifest = maniread();
    my $manifest = maniread($manifest_file);

reads a named C<MANIFEST> file (defaults to C<MANIFEST> in the current
directory) and returns a HASH reference with files being the keys and
comments being the values of the HASH.  Blank lines and lines which
start with C<#> in the C<MANIFEST> file are discarded.

=cut

sub maniread {
    my ($mfile) = @@_;
    $mfile ||= $MANIFEST;
    my $read = {};
    local *M;
    unless (open M, "< $mfile"){
        warn "Problem opening $mfile: $!";
        return $read;
    }
    local $_;
    while (<M>){
        chomp;
        next if /^\s*#/;

        my($file, $comment);

        # filename may contain spaces if enclosed in ''
        # (in which case, \\ and \' are escapes)
        if (($file, $comment) = /^'(\\[\\']|.+)+'\s*(.*)/) {
            $file =~ s/\\([\\'])/$1/g;
        }
        else {
            ($file, $comment) = /^(\S+)\s*(.*)/;
        }
        next unless $file;

        if ($Is_MacOS) {
            $file = _macify($file);
            $file =~ s/\\([0-3][0-7][0-7])/sprintf("%c", oct($1))/ge;
        }
        elsif ($Is_VMS_mode) {
            require File::Basename;
            my($base,$dir) = File::Basename::fileparse($file);
            # Resolve illegal file specifications in the same way as tar
            if ($Is_VMS_nodot) {
                $dir =~ tr/./_/;
                my(@@pieces) = split(/\./,$base);
                if (@@pieces > 2)
                    { $base = shift(@@pieces) . '.' . join('_',@@pieces); }
                my $okfile = "$dir$base";
                warn "Debug: Illegal name $file changed to $okfile\n" if $Debug;
                $file = $okfile;
            } 
            $file = lc($file)
                unless $Is_VMS_lc &&($file =~ /^MANIFEST(\.SKIP)?$/);
        }

        $read->{$file} = $comment;
    }
    close M;
    $read;
}

=item maniskip

    my $skipchk = maniskip();
    my $skipchk = maniskip($manifest_skip_file);

    if ($skipchk->($file)) { .. }

reads a named C<MANIFEST.SKIP> file (defaults to C<MANIFEST.SKIP> in
the current directory) and returns a CODE reference that tests whether
a given filename should be skipped.

=cut

# returns an anonymous sub that decides if an argument matches
sub maniskip {
    my @@skip ;
    my $mfile = shift || "$MANIFEST.SKIP";
    _check_mskip_directives($mfile) if -f $mfile;
    local(*M, $_);
    open M, "< $mfile" or open M, "< $DEFAULT_MSKIP" or return sub {0};
    while (<M>){
	chomp;
	s/\r//;
	next if /^#/;
	next if /^\s*$/;
        s/^'//;
        s/'$//;
	push @@skip, _macify($_);
    }
    close M;
    return sub {0} unless (scalar @@skip > 0);

    my $opts = $Is_VMS_mode ? '(?i)' : '';

    # Make sure each entry is isolated in its own parentheses, in case
    # any of them contain alternations
    my $regex = join '|', map "(?:$_)", @@skip;

    return sub { $_[0] =~ qr{$opts$regex} };
}

# checks for the special directives
#   #!include_default
#   #!include /path/to/some/manifest.skip
# in a custom MANIFEST.SKIP for, for including
# the content of, respectively, the default MANIFEST.SKIP
# and an external manifest.skip file
sub _check_mskip_directives {
    my $mfile = shift;
    local (*M, $_);
    my @@lines = ();
    my $flag = 0;
    unless (open M, "< $mfile") {
        warn "Problem opening $mfile: $!";
        return;
    }
    while (<M>) {
        if (/^#!include_default\s*$/) {
	    if (my @@default = _include_mskip_file()) {
	        push @@lines, @@default;
		warn "Debug: Including default MANIFEST.SKIP\n" if $Debug;
		$flag++;
	    }
	    next;
        }
	if (/^#!include\s+(.*)\s*$/) {
	    my $external_file = $1;
	    if (my @@external = _include_mskip_file($external_file)) {
	        push @@lines, @@external;
		warn "Debug: Including external $external_file\n" if $Debug;
		$flag++;
	    }
            next;
        }
        push @@lines, $_;
    }
    close M;
    return unless $flag;
    my $bakbase = $mfile;
    $bakbase =~ s/\./_/g if $Is_VMS_nodot;  # avoid double dots
    rename $mfile, "$bakbase.bak";
    warn "Debug: Saving original $mfile as $bakbase.bak\n" if $Debug;
    unless (open M, "> $mfile") {
        warn "Problem opening $mfile: $!";
        return;
    }
    print M $_ for (@@lines);
    close M;
    return;
}

# returns an array containing the lines of an external
# manifest.skip file, if given, or $DEFAULT_MSKIP
sub _include_mskip_file {
    my $mskip = shift || $DEFAULT_MSKIP;
    unless (-f $mskip) {
        warn qq{Included file "$mskip" not found - skipping};
        return;
    }
    local (*M, $_);
    unless (open M, "< $mskip") {
        warn "Problem opening $mskip: $!";
        return;
    }
    my @@lines = ();
    push @@lines, "\n#!start included $mskip\n";
    push @@lines, $_ while <M>;
    close M;
    push @@lines, "#!end included $mskip\n\n";
    return @@lines;
}

=item manicopy

    manicopy(\%src, $dest_dir);
    manicopy(\%src, $dest_dir, $how);

Copies the files that are the keys in %src to the $dest_dir.  %src is
typically returned by the maniread() function.

    manicopy( maniread(), $dest_dir );

This function is useful for producing a directory tree identical to the 
intended distribution tree. 

$how can be used to specify a different methods of "copying".  Valid
values are C<cp>, which actually copies the files, C<ln> which creates
hard links, and C<best> which mostly links the files but copies any
symbolic link to make a tree without any symbolic link.  C<cp> is the 
default.

=cut

sub manicopy {
    my($read,$target,$how)=@@_;
    croak "manicopy() called without target argument" unless defined $target;
    $how ||= 'cp';
    require File::Path;
    require File::Basename;

    $target = VMS::Filespec::unixify($target) if $Is_VMS_mode;
    File::Path::mkpath([ $target ],! $Quiet,$Is_VMS ? undef : 0755);
    foreach my $file (keys %$read){
    	if ($Is_MacOS) {
	    if ($file =~ m!:!) { 
	   	my $dir = _maccat($target, $file);
		$dir =~ s/[^:]+$//;
	    	File::Path::mkpath($dir,1,0755);
	    }
	    cp_if_diff($file, _maccat($target, $file), $how);
	} else {
	    $file = VMS::Filespec::unixify($file) if $Is_VMS_mode;
	    if ($file =~ m!/!) { # Ilya, that hurts, I fear, or maybe not?
		my $dir = File::Basename::dirname($file);
		$dir = VMS::Filespec::unixify($dir) if $Is_VMS_mode;
		File::Path::mkpath(["$target/$dir"],! $Quiet,$Is_VMS ? undef : 0755);
	    }
	    cp_if_diff($file, "$target/$file", $how);
	}
    }
}

sub cp_if_diff {
    my($from, $to, $how)=@@_;
    if (! -f $from) {
        carp "$from not found";
        return;
    }
    my($diff) = 0;
    local(*F,*T);
    open(F,"< $from\0") or die "Can't read $from: $!\n";
    if (open(T,"< $to\0")) {
        local $_;
	while (<F>) { $diff++,last if $_ ne <T>; }
	$diff++ unless eof(T);
	close T;
    }
    else { $diff++; }
    close F;
    if ($diff) {
	if (-e $to) {
	    unlink($to) or confess "unlink $to: $!";
	}
        STRICT_SWITCH: {
	    best($from,$to), last STRICT_SWITCH if $how eq 'best';
	    cp($from,$to), last STRICT_SWITCH if $how eq 'cp';
	    ln($from,$to), last STRICT_SWITCH if $how eq 'ln';
	    croak("ExtUtils::Manifest::cp_if_diff " .
		  "called with illegal how argument [$how]. " .
		  "Legal values are 'best', 'cp', and 'ln'.");
	}
    }
}

sub cp {
    my ($srcFile, $dstFile) = @@_;
    my ($access,$mod) = (stat $srcFile)[8,9];

    copy($srcFile,$dstFile);
    utime $access, $mod + ($Is_VMS ? 1 : 0), $dstFile;
    _manicopy_chmod($srcFile, $dstFile);
}


sub ln {
    my ($srcFile, $dstFile) = @@_;
    # Fix-me - VMS can support links.
    return &cp if $Is_VMS or ($^O eq 'MSWin32' and Win32::IsWin95());
    link($srcFile, $dstFile);

    unless( _manicopy_chmod($srcFile, $dstFile) ) {
        unlink $dstFile;
        return;
    }
    1;
}

# 1) Strip off all group and world permissions.
# 2) Let everyone read it.
# 3) If the owner can execute it, everyone can.
sub _manicopy_chmod {
    my($srcFile, $dstFile) = @@_;

    my $perm = 0444 | (stat $srcFile)[2] & 0700;
    chmod( $perm | ( $perm & 0100 ? 0111 : 0 ), $dstFile );
}

# Files that are often modified in the distdir.  Don't hard link them.
my @@Exceptions = qw(MANIFEST META.yml SIGNATURE);
sub best {
    my ($srcFile, $dstFile) = @@_;

    my $is_exception = grep $srcFile =~ /$_/, @@Exceptions;
    if ($is_exception or !$Config{d_link} or -l $srcFile) {
	cp($srcFile, $dstFile);
    } else {
	ln($srcFile, $dstFile) or cp($srcFile, $dstFile);
    }
}

sub _macify {
    my($file) = @@_;

    return $file unless $Is_MacOS;

    $file =~ s|^\./||;
    if ($file =~ m|/|) {
	$file =~ s|/+|:|g;
	$file = ":$file";
    }

    $file;
}

sub _maccat {
    my($f1, $f2) = @@_;

    return "$f1/$f2" unless $Is_MacOS;

    $f1 .= ":$f2";
    $f1 =~ s/([^:]:):/$1/g;
    return $f1;
}

sub _unmacify {
    my($file) = @@_;

    return $file unless $Is_MacOS;

    $file =~ s|^:||;
    $file =~ s|([/ \n])|sprintf("\\%03o", unpack("c", $1))|ge;
    $file =~ y|:|/|;

    $file;
}


=item maniadd

  maniadd({ $file => $comment, ...});

Adds an entry to an existing F<MANIFEST> unless its already there.

$file will be normalized (ie. Unixified).  B<UNIMPLEMENTED>

=cut

sub maniadd {
    my($additions) = shift;

    _normalize($additions);
    _fix_manifest($MANIFEST);

    my $manifest = maniread();
    my @@needed = grep { !exists $manifest->{$_} } keys %$additions;
    return 1 unless @@needed;

    open(MANIFEST, ">>$MANIFEST") or 
      die "maniadd() could not open $MANIFEST: $!";

    foreach my $file (_sort @@needed) {
        my $comment = $additions->{$file} || '';
        if ($file =~ /\s/) {
            $file =~ s/([\\'])/\\$1/g;
            $file = "'$file'";
        }
        printf MANIFEST "%-40s %s\n", $file, $comment;
    }
    close MANIFEST or die "Error closing $MANIFEST: $!";

    return 1;
}


# Sometimes MANIFESTs are missing a trailing newline.  Fix this.
sub _fix_manifest {
    my $manifest_file = shift;

    open MANIFEST, $MANIFEST or die "Could not open $MANIFEST: $!";

    # Yes, we should be using seek(), but I'd like to avoid loading POSIX
    # to get SEEK_*
    my @@manifest = <MANIFEST>;
    close MANIFEST;

    unless( $manifest[-1] =~ /\n\z/ ) {
        open MANIFEST, ">>$MANIFEST" or die "Could not open $MANIFEST: $!";
        print MANIFEST "\n";
        close MANIFEST;
    }
}


# UNIMPLEMENTED
sub _normalize {
    return;
}


=back

=head2 MANIFEST

A list of files in the distribution, one file per line.  The MANIFEST
always uses Unix filepath conventions even if you're not on Unix.  This
means F<foo/bar> style not F<foo\bar>.

Anything between white space and an end of line within a C<MANIFEST>
file is considered to be a comment.  Any line beginning with # is also
a comment. Beginning with ExtUtils::Manifest 1.52, a filename may
contain whitespace characters if it is enclosed in single quotes; single
quotes or backslashes in that filename must be backslash-escaped.

    # this a comment
    some/file
    some/other/file            comment about some/file
    'some/third file'          comment


=head2 MANIFEST.SKIP

The file MANIFEST.SKIP may contain regular expressions of files that
should be ignored by mkmanifest() and filecheck(). The regular
expressions should appear one on each line. Blank lines and lines
which start with C<#> are skipped.  Use C<\#> if you need a regular
expression to start with a C<#>.

For example:

    # Version control files and dirs.
    \bRCS\b
    \bCVS\b
    ,v$
    \B\.svn\b

    # Makemaker generated files and dirs.
    ^MANIFEST\.
    ^Makefile$
    ^blib/
    ^MakeMaker-\d

    # Temp, old and emacs backup files.
    ~$
    \.old$
    ^#.*#$
    ^\.#

If no MANIFEST.SKIP file is found, a default set of skips will be
used, similar to the example above.  If you want nothing skipped,
simply make an empty MANIFEST.SKIP file.

In one's own MANIFEST.SKIP file, certain directives
can be used to include the contents of other MANIFEST.SKIP
files. At present two such directives are recognized.

=over 4

=item #!include_default

This inserts the contents of the default MANIFEST.SKIP file

=item #!include /Path/to/another/manifest.skip

This inserts the contents of the specified external file

=back

The included contents will be inserted into the MANIFEST.SKIP
file in between I<#!start included /path/to/manifest.skip>
and I<#!end included /path/to/manifest.skip> markers.
The original MANIFEST.SKIP is saved as MANIFEST.SKIP.bak.

=head2 EXPORT_OK

C<&mkmanifest>, C<&manicheck>, C<&filecheck>, C<&fullcheck>,
C<&maniread>, and C<&manicopy> are exportable.

=head2 GLOBAL VARIABLES

C<$ExtUtils::Manifest::MANIFEST> defaults to C<MANIFEST>. Changing it
results in both a different C<MANIFEST> and a different
C<MANIFEST.SKIP> file. This is useful if you want to maintain
different distributions for different audiences (say a user version
and a developer version including RCS).

C<$ExtUtils::Manifest::Quiet> defaults to 0. If set to a true value,
all functions act silently.

C<$ExtUtils::Manifest::Debug> defaults to 0.  If set to a true value,
or if PERL_MM_MANIFEST_DEBUG is true, debugging output will be
produced.

=head1 DIAGNOSTICS

All diagnostic output is sent to C<STDERR>.

=over 4

=item C<Not in MANIFEST:> I<file>

is reported if a file is found which is not in C<MANIFEST>.

=item C<Skipping> I<file>

is reported if a file is skipped due to an entry in C<MANIFEST.SKIP>.

=item C<No such file:> I<file>

is reported if a file mentioned in a C<MANIFEST> file does not
exist.

=item C<MANIFEST:> I<$!>

is reported if C<MANIFEST> could not be opened.

=item C<Added to MANIFEST:> I<file>

is reported by mkmanifest() if $Verbose is set and a file is added
to MANIFEST. $Verbose is set to 1 by default.

=back

=head1 ENVIRONMENT

=over 4

=item B<PERL_MM_MANIFEST_DEBUG>

Turns on debugging

=back

=head1 SEE ALSO

L<ExtUtils::MakeMaker> which has handy targets for most of the functionality.

=head1 AUTHOR

Andreas Koenig C<andreas.koenig@@anima.de>

Maintained by Michael G Schwern C<schwern@@pobox.com> within the
ExtUtils-MakeMaker package and, as a separate CPAN package, by
Randy Kobes C<r.kobes@@uwinnipeg.ca>.

=cut

1;
@


1.10
log
@Merge in perl 5.10.1
@
text
@@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d13 1
a13 1
          $Is_MacOS $Is_VMS 
d16 1
a16 1
$VERSION = '1.51_01';
d21 1
d26 29
a54 1
require VMS::Filespec if $Is_VMS;
d103 1
a103 1
It works similar to
d110 1
a110 3
Any existing F<MANIFEST> file will be saved as F<MANIFEST.bak>.  Lines
from the old F<MANIFEST> file is preserved, including any comments
that are found in the existing F<MANIFEST> file in the new one.
d124 1
a124 1
    $bakbase =~ s/\./_/g if $Is_VMS; # avoid double dots
d126 2
a127 2
    open M, ">$MANIFEST" or die "Could not open $MANIFEST: $!";
    my $skip = _maniskip();
d131 2
a132 1
    $all{$MANIFEST} = ($Is_VMS ? "$MANIFEST\t\t" : '') . 'This list of files'
d149 4
d185 2
a186 2
	
        if( $Is_VMS ) {
d266 1
a266 1
    my $matches = _maniskip();
d309 1
a309 1
    my $skip  = _maniskip();
d343 1
a343 1
    unless (open M, $mfile){
d352 10
a361 1
        my($file, $comment) = /^(\S+)\s*(.*)/;
d368 1
a368 1
        elsif ($Is_VMS) {
d372 11
a382 7
            $dir =~ tr/./_/;
            my(@@pieces) = split(/\./,$base);
            if (@@pieces > 2) { $base = shift(@@pieces) . '.' . join('_',@@pieces); }
            my $okfile = "$dir$base";
            warn "Debug: Illegal name $file changed to $okfile\n" if $Debug;
            $file = $okfile;
            $file = lc($file) unless $file =~ /^MANIFEST(\.SKIP)?$/;
d391 13
d405 1
a405 1
sub _maniskip {
d407 1
a407 1
    my $mfile = "$MANIFEST.SKIP";
d410 1
a410 1
    open M, $mfile or open M, $DEFAULT_MSKIP or return sub {0};
d416 2
d423 1
a423 1
    my $opts = $Is_VMS ? '(?i)' : '';
d443 1
a443 1
    unless (open M, $mfile) {
d470 1
a470 1
    $bakbase =~ s/\./_/g if $Is_VMS;  # avoid double dots
d473 1
a473 1
    unless (open M, ">$mfile") {
d491 1
a491 1
    unless (open M, $mskip) {
d531 1
a531 1
    $target = VMS::Filespec::unixify($target) if $Is_VMS;
d542 1
a542 1
	    $file = VMS::Filespec::unixify($file) if $Is_VMS;
d545 1
a545 1
		$dir = VMS::Filespec::unixify($dir) if $Is_VMS;
d555 4
a558 1
    -f $from or carp "$0: $from not found";
d597 1
d693 4
d740 3
a742 1
a comment.
d747 1
@


1.8
log
@merge in perl 5.8.8
@
text
@d16 1
a16 1
$VERSION = '1.46';
d96 3
a98 1
    rename $MANIFEST, "$MANIFEST.bak" unless $manimiss;
a116 1
	($file,$text) = split(/\s+/,$text,2) if $Is_VMS && $text;
d312 1
a312 1
        warn "$mfile: $!";
d350 2
a351 1
    local(*M,$_);
d355 1
d361 2
d372 71
d528 1
a528 1
    _manicopy_chmod($dstFile);
d537 1
a537 1
    unless( _manicopy_chmod($dstFile) ) {
d548 1
a548 1
    my($file) = shift;
d550 2
a551 2
    my $perm = 0444 | (stat $file)[2] & 0700;
    chmod( $perm | ( $perm & 0100 ? 0111 : 0 ), $file );
d711 20
d800 3
a802 1
Currently maintained by Michael G Schwern C<schwern@@pobox.com>
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d5 2
a7 1
use File::Copy 'copy';
d16 1
a16 1
$VERSION = 1.42;
d33 1
a33 3
my $Filename = __FILE__;
$DEFAULT_MSKIP = (File::Spec->splitpath($Filename))[1].
                 "$MANIFEST.SKIP";
d369 5
a373 2
    manicopy($src, $dest_dir);
    manicopy($src, $dest_dir, $how);
d375 6
a380 5
copies the files that are the keys in the HASH I<%$src> to the
$dest_dir. The HASH reference $read is typically returned by the
maniread() function. This function is useful for producing a directory
tree identical to the intended distribution tree. The third parameter
$how can be used to specify a different methods of "copying". Valid
d383 1
a383 1
symbolic link to make a tree without any symbolic link. Best is the
d435 1
a435 1
      STRICT_SWITCH: {
d448 2
a449 1
    my ($perm,$access,$mod) = (stat $srcFile)[2,8,9];
d452 1
a452 3
    # chmod a+rX-w,go-w
    chmod(  0444 | ( $perm & 0111 ? 0111 : 0 ),  $dstFile ) 
      unless ($^O eq 'MacOS');
d455 1
d461 1
a461 4
    # chmod a+r,go-w+X (except "X" only applies to u=x)
    local($_) = $dstFile;
    my $mode= 0444 | (stat)[2] & 0700;
    if (! chmod(  $mode | ( $mode & 0100 ? 0111 : 0 ),  $_  )) {
d468 8
a475 6
unless (defined $Config{d_link}) {
    # Really cool fix from Ilya :)
    local $SIG{__WARN__} = sub { 
        warn @@_ unless $_[0] =~ /^Subroutine .* redefined/;
    };
    *ln = \&cp;
d478 2
a479 3



d482 3
a484 1
    if (-l $srcFile) {
d495 1
a495 1
    
d501 1
a501 1
    
d507 1
a507 1
    
d509 1
a509 1
    
d519 1
a519 1
    
d523 1
a523 1
    
d578 1
a578 1
        
d590 4
d595 6
a600 2
file is considered to be a comment.  Filenames and comments are
separated by one or more TAB characters in the output. 
d609 3
a611 1
expression to start with a sharp character. A typical example:
d702 3
a704 1
Andreas Koenig <F<andreas.koenig@@anima.de>>
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d15 1
a15 1
$VERSION = 1.38;
d17 4
a20 2
@@EXPORT_OK = ('mkmanifest', 'manicheck', 'fullcheck', 'filecheck', 
	      'skipcheck', 'maniread', 'manicopy');
d23 1
a23 1
$Is_VMS = $^O eq 'VMS';
d26 1
a26 1
$Debug = $ENV{PERL_MM_MANIFEST_DEBUG} || 0;
d31 3
a33 1
$DEFAULT_MSKIP = (File::Spec->splitpath($INC{"ExtUtils/Manifest.pm"}))[1].
d36 56
d105 1
a105 1
    foreach $file (sort keys %all) {
d135 10
d171 13
a183 3
sub fullcheck {
    return [_check_files()], [_check_manifest()];
}
d189 14
d207 24
d237 1
a237 1
    foreach my $file (sort keys %$found){
d256 1
a256 1
    foreach my $file (sort keys %$read){
d280 1
a280 1
    foreach my $file (sort keys %$found){
d294 12
d312 2
a313 2
	warn "$mfile: $!";
	return $read;
d315 1
d317 2
a318 2
	chomp;
	next if /^#/;
d323 13
a335 13
	if ($Is_MacOS) {
	    $file = _macify($file);
	    $file =~ s/\\([0-3][0-7][0-7])/sprintf("%c", oct($1))/ge;
	}
	elsif ($Is_VMS) {
        require File::Basename;
	    my($base,$dir) = File::Basename::fileparse($file);
	    # Resolve illegal file specifications in the same way as tar
	    $dir =~ tr/./_/;
	    my(@@pieces) = split(/\./,$base);
	    if (@@pieces > 2) { $base = shift(@@pieces) . '.' . join('_',@@pieces); }
	    my $okfile = "$dir$base";
	    warn "Debug: Illegal name $file changed to $okfile\n" if $Debug;
d338 1
a338 1
	}
d350 1
a350 1
    local *M;
d368 17
d421 1
a523 1
1;
d525 15
a539 1
__END__
d541 3
a543 1
=head1 NAME
d545 2
a546 1
ExtUtils::Manifest - utilities to write and check a MANIFEST file
d548 5
a552 1
=head1 SYNOPSIS
d554 2
a555 1
    require ExtUtils::Manifest;
a556 1
    ExtUtils::Manifest::mkmanifest;
d558 3
a560 1
    ExtUtils::Manifest::manicheck;
d562 1
a562 1
    ExtUtils::Manifest::filecheck;
d564 4
a567 1
    ExtUtils::Manifest::fullcheck;
d569 7
a575 1
    ExtUtils::Manifest::skipcheck;
d577 4
a580 1
    ExtUtils::Manifest::manifind();
a581 1
    ExtUtils::Manifest::maniread($file);
d583 1
a583 1
    ExtUtils::Manifest::manicopy($read,$target,$how);
d585 1
a585 1
=head1 DESCRIPTION
d587 3
a589 26
mkmanifest() writes all files in and below the current directory to a
file named in the global variable $ExtUtils::Manifest::MANIFEST (which
defaults to C<MANIFEST>) in the current directory. It works similar to

    find . -print

but in doing so checks each line in an existing C<MANIFEST> file and
includes any comments that are found in the existing C<MANIFEST> file
in the new one. Anything between white space and an end of line within
a C<MANIFEST> file is considered to be a comment. Filenames and
comments are separated by one or more TAB characters in the
output. All files that match any regular expression in a file
C<MANIFEST.SKIP> (if such a file exists) are ignored.

manicheck() checks if all the files within a C<MANIFEST> in the current
directory really do exist. If C<MANIFEST> and the tree below the current
directory are in sync it exits silently, returning an empty list.  Otherwise
it returns a list of files which are listed in the C<MANIFEST> but missing
from the directory, and by default also outputs these names to STDERR.

filecheck() finds files below the current directory that are not
mentioned in the C<MANIFEST> file. An optional file C<MANIFEST.SKIP>
will be consulted. Any file matching a regular expression in such a
file will not be reported as missing in the C<MANIFEST> file. The list of
any extraneous files found is returned, and by default also reported to
STDERR.
a590 25
fullcheck() does both a manicheck() and a filecheck(), returning references
to two arrays, the first for files manicheck() found to be missing, the
seond for unexpeced files found by filecheck().

skipcheck() lists all the files that are skipped due to your
C<MANIFEST.SKIP> file.

manifind() returns a hash reference. The keys of the hash are the
files found below the current directory.

maniread($file) reads a named C<MANIFEST> file (defaults to
C<MANIFEST> in the current directory) and returns a HASH reference
with files being the keys and comments being the values of the HASH.
Blank lines and lines which start with C<#> in the C<MANIFEST> file
are discarded.

C<manicopy($read,$target,$how)> copies the files that are the keys in
the HASH I<%$read> to the named target directory. The HASH reference
$read is typically returned by the maniread() function. This
function is useful for producing a directory tree identical to the
intended distribution tree. The third parameter $how can be used to
specify a different methods of "copying". Valid values are C<cp>,
which actually copies the files, C<ln> which creates hard links, and
C<best> which mostly links the files but copies any symbolic link to
make a tree without any symbolic link. Best is the default.
d592 1
a592 1
=head1 MANIFEST.SKIP
d604 1
d623 1
a623 1
=head1 EXPORT_OK
d628 1
a628 1
=head1 GLOBAL VARIABLES
d692 2
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d7 1
d11 3
a13 2
use vars qw($VERSION @@ISA @@EXPORT_OK
	    $Is_MacOS $Is_VMS $Debug $Verbose $Quiet $MANIFEST $found);
d15 1
a15 1
$VERSION = substr(q$Revision: 1.33 $, 10);
d22 1
a22 1
if ($Is_VMS) { require File::Basename }
d24 3
a26 2
$Debug = 0;
$Verbose = 1;
d29 2
a30 6

# Really cool fix from Ilya :)
unless (defined $Config{d_link}) {
    no warnings;
    *ln = \&cp;
}
d34 1
a34 1
    my $read = maniread() or $manimiss++;
d39 1
a39 1
    my $matches = _maniskip();
d46 6
a51 1
	next if &$matches($file);
d66 9
d76 23
a98 8
    local $found = {};
    find(sub {return if -d $_;
	      (my $name = $File::Find::name) =~ s|^\./||;
	      $name =~ s/^:([^:]+)$/$1/ if $Is_MacOS;
	      warn "Debug: diskfile $name\n" if $Debug;
	      $name =~ s#(.*)\.$#\L$1# if $Is_VMS;
	      $found->{$name} = "";}, $Is_MacOS ? ":" : ".");
    $found;
d102 1
a102 1
    _manicheck(3);
d106 1
a106 1
    return @@{(_manicheck(1))[0]};
d110 1
a110 1
    return @@{(_manicheck(2))[1]};
d114 14
a127 1
    _manicheck(6);
d130 3
a132 5
sub _manicheck {
    my($arg) = @@_;
    my $read = maniread();
    my $found = manifind();
    my $file;
d134 36
a169 14
    my(@@missfile,@@missentry);
    if ($arg & 1){
	foreach $file (sort keys %$read){
	    warn "Debug: manicheck checking from $MANIFEST $file\n" if $Debug;
            if ($dosnames){
                $file = lc $file;
                $file =~ s=(\.(\w|-)+)=substr ($1,0,4)=ge;
                $file =~ s=((\w|-)+)=substr ($1,0,8)=ge;
            }
	    unless ( exists $found->{$file} ) {
		warn "No such file: $file\n" unless $Quiet;
		push @@missfile, $file;
	    }
	}
d171 2
a172 18
    if ($arg & 2){
	$read ||= {};
	my $matches = _maniskip();
	my $skipwarn = $arg & 4;
	foreach $file (sort keys %$found){
	    if (&$matches($file)){
		warn "Skipping $file\n" if $skipwarn;
		next;
	    }
	    warn "Debug: manicheck checking from disk $file\n" if $Debug;
	    unless ( exists $read->{$file} ) {
		my $canon = "\t" . _unmacify($file) if $Is_MacOS;
		warn "Not in $MANIFEST: $file$canon\n" unless $Quiet;
		push @@missentry, $file;
	    }
	}
    }
    (\@@missfile,\@@missentry);
d175 1
d188 4
d193 2
a194 4
	    my($item,$text) = /^(\S+)\s*(.*)/;
	    $item = _macify($item);
	    $item =~ s/\\([0-3][0-7][0-7])/sprintf("%c", oct($1))/ge;
	    $read->{$item}=$text;
d197 1
a197 2
	    my($file)= /^(\S+)/;
	    next unless $file;
d205 2
a206 1
	    $read->{"\L$okfile"}=$_;
d208 2
a209 1
	else { /^(\S+)\s*(.*)/ and $read->{$1}=$2; }
a216 2
    my ($mfile) = @@_;
    my $matches = sub {0};
d218 1
a218 1
    $mfile ||= "$MANIFEST.SKIP";
d220 1
a220 2
    return $matches unless -f $mfile;
    open M, $mfile or return $matches;
d228 7
a234 8
    my $opts = $Is_VMS ? 'oi ' : 'o ';
    my $sub = "\$matches = "
	. "sub { my(\$arg)=\@@_; return 1 if "
	. join (" || ",  (map {s!/!\\/!g; "\$arg =~ m/$_/$opts"} @@skip), 0)
	. " }";
    eval $sub;
    print "Debug: $sub\n" if $Debug;
    $matches;
d243 1
a243 1
    my(%dirs,$file);
d246 1
a246 1
    foreach $file (keys %$read){
d271 1
a271 1
    open(F,"< $from\0") or croak "Can't read $from: $!\n";
d300 2
a301 1
    chmod(  0444 | ( $perm & 0111 ? 0111 : 0 ),  $dstFile ) unless ($^O eq 'MacOS');
d308 3
a310 1
    local($_) = $dstFile; # chmod a+r,go-w+X (except "X" only applies to u=x)
d313 2
a314 2
       unlink $dstFile;
       return;
d319 11
d419 5
a423 4
manicheck() checks if all the files within a C<MANIFEST> in the
current directory really do exist. It only reports discrepancies and
exits silently if MANIFEST and the tree below the current directory
are in sync.
d428 7
a434 3
file will not be reported as missing in the C<MANIFEST> file.

fullcheck() does both a manicheck() and a filecheck().
d466 1
d468 4
d474 4
a478 1
    \.html$
d480 7
a486 2
    ^blib/
    ^MakeMaker-\d
d504 4
d512 1
a512 1
=over
d516 5
a520 3
is reported if a file is found, that is missing in the C<MANIFEST>
file which is excluded by a regular expression in the file
C<MANIFEST.SKIP>.
d538 10
d554 1
a554 1
Andreas Koenig <F<koenig@@franz.ww.TU-Berlin.DE>>
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d11 1
a11 1
	    $Is_VMS $Debug $Verbose $Quiet $MANIFEST $found);
d18 1
d53 1
d65 2
a66 1
	      (my $name = $File::Find::name) =~ s|./||;
d68 2
a69 2
	      $name  =~ s#(.*)\.$#\L$1# if $Is_VMS;
	      $found->{$name} = "";}, ".");
d121 2
a122 1
		warn "Not in $MANIFEST: $file\n" unless $Quiet;
d142 7
a148 1
	if ($Is_VMS) {
d179 1
a179 1
	push @@skip, $_;
d200 1
a200 1
    File::Path::mkpath([ $target ],1,$Is_VMS ? undef : 0755);
d202 15
a216 5
	$file = VMS::Filespec::unixify($file) if $Is_VMS;
	if ($file =~ m!/!) { # Ilya, that hurts, I fear, or maybe not?
	    my $dir = File::Basename::dirname($file);
	    $dir = VMS::Filespec::unixify($dir) if $Is_VMS;
	    File::Path::mkpath(["$target/$dir"],1,$Is_VMS ? undef : 0755);
a217 1
	cp_if_diff($file, "$target/$file", $how);
d226 2
a227 2
    open(F,$from) or croak "Can't read $from: $!\n";
    if (open(T,$to)) {
d255 1
a255 1
    chmod(  0444 | ( $perm & 0111 ? 0111 : 0 ),  $dstFile );
d260 1
a260 1
    return &cp if $Is_VMS;
d278 36
@


1.3
log
@perl5.005_03 (stock)
@
text
@d28 1
a189 1
    umask 0 unless $Is_VMS;
d271 1
a271 1
C<require ExtUtils::Manifest;>
d273 1
a273 1
C<ExtUtils::Manifest::mkmanifest;>
d275 1
a275 1
C<ExtUtils::Manifest::manicheck;>
d277 1
a277 1
C<ExtUtils::Manifest::filecheck;>
d279 1
a279 1
C<ExtUtils::Manifest::fullcheck;>
d281 1
a281 1
C<ExtUtils::Manifest::skipcheck;>
d283 1
a283 1
C<ExtUtild::Manifest::manifind();>
d285 1
a285 1
C<ExtUtils::Manifest::maniread($file);>
d287 1
a287 1
C<ExtUtils::Manifest::manicopy($read,$target,$how);>
d291 1
a291 1
Mkmanifest() writes all files in and below the current directory to a
d305 1
a305 1
Manicheck() checks if all the files within a C<MANIFEST> in the
d310 1
a310 1
Filecheck() finds files below the current directory that are not
d315 1
a315 1
Fullcheck() does both a manicheck() and a filecheck().
d317 1
a317 1
Skipcheck() lists all the files that are skipped due to your
d320 1
a320 1
Manifind() returns a hash reference. The keys of the hash are the
d323 1
a323 1
Maniread($file) reads a named C<MANIFEST> file (defaults to
d329 1
a329 1
I<Manicopy($read,$target,$how)> copies the files that are the keys in
d331 1
a331 1
I<$read> is typically returned by the maniread() function. This
@


1.2
log
@perl 5.004_04
@
text
@d90 1
d95 5
d245 5
a249 1
    chmod(  $mode | ( $mode & 0100 ? 0111 : 0 ),  $_  );
d301 1
a301 1
comments are seperated by one or more TAB characters in the
d320 1
a320 1
Manifind() retruns a hash reference. The keys of the hash are the
@


1.1
log
@Initial revision
@
text
@d3 6
d10 4
a13 1
require Exporter;
d18 2
a19 4
use Config;
use File::Find;
use File::Copy 'copy';
use Carp;
a22 4
$Is_VMS = $^O eq 'VMS';

$VERSION = $VERSION = substr(q$Revision: 1.24 $,10,4);

a23 1

d88 1
a91 1
	my $found = manifind();
a102 1
	my $found = manifind();
d121 1
a121 1
    $mfile = $MANIFEST unless defined $mfile;
d130 14
a143 2
	if ($Is_VMS) { /^(\S+)/ and $read->{"\L$1"}=$_; }
	else         { /^(\S+)\s*(.*)/ and $read->{$1}=$2; }
d154 1
a154 1
    $mfile = "$MANIFEST.SKIP" unless defined $mfile;
d160 1
d178 1
a178 1
    $how = 'cp' unless defined $how && $how;
d192 1
a192 2
	if ($Is_VMS) { vms_cp_if_diff($file,"$target/$file"); }
	else         { cp_if_diff($file, "$target/$file", $how); }
d197 2
a198 2
    my($from,$to, $how)=@@_;
    -f $from || carp "$0: $from not found";
d213 8
a220 20
	&$how($from, $to);
    }
}

# Do the comparisons here rather than spawning off another process
sub vms_cp_if_diff {
    my($from,$to) = @@_;
    my($diff) = 0;
    local(*F,*T);
    open(F,$from) or croak "Can't read $from: $!\n";
    if (open(T,$to)) {
	while (<F>) { $diff++,last if $_ ne <T>; }
	$diff++ unless eof(T);
	close T;
    }
    else { $diff++; }
    close F;
    if ($diff) {
	system('copy',VMS::Filespec::vmsify($from),VMS::Filespec::vmsify($to)) & 1
	    or confess "Copy failed: $!";
d228 1
a228 1
    utime $access, $mod, $dstFile;
d235 1
d247 1
a247 1
	ln($srcFile, $dstFile);
d316 2
d333 3
a335 1
expressions should appear one on each line. A typical example:
d359 1
a359 1
<$ExtUtils::Manifest::Quiet> defaults to 0. If set to a true value,
d396 1
a396 1
Andreas Koenig F<E<lt>koenig@@franz.ww.TU-Berlin.DEE<gt>>
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 1
d5 4
a12 1
use strict;
d14 3
a16 2
use vars qw($VERSION @@ISA @@EXPORT_OK
	    $Is_VMS $Debug $Verbose $Quiet $MANIFEST $found);
d18 1
a18 4
$VERSION = substr(q$Revision: 1.33 $, 10);
@@ISA=('Exporter');
@@EXPORT_OK = ('mkmanifest', 'manicheck', 'fullcheck', 'filecheck', 
	      'skipcheck', 'maniread', 'manicopy');
d20 1
a20 2
$Is_VMS = $^O eq 'VMS';
if ($Is_VMS) { require File::Basename }
a21 3
$Debug = 0;
$Verbose = 1;
$Quiet = 0;
a85 1
    my $found = manifind();
a86 1
    my $dosnames=(defined(&Dos::UseLFN) && Dos::UseLFN()==0);
d89 1
a91 5
            if ($dosnames){
                $file = lc $file;
                $file =~ s=(\.(\w|-)+)=substr ($1,0,4)=ge;
                $file =~ s=((\w|-)+)=substr ($1,0,8)=ge;
            }
d101 1
d120 1
a120 1
    $mfile ||= $MANIFEST;
d129 2
a130 14
	next if /^#/;
	if ($Is_VMS) {
	    my($file)= /^(\S+)/;
	    next unless $file;
	    my($base,$dir) = File::Basename::fileparse($file);
	    # Resolve illegal file specifications in the same way as tar
	    $dir =~ tr/./_/;
	    my(@@pieces) = split(/\./,$base);
	    if (@@pieces > 2) { $base = shift(@@pieces) . '.' . join('_',@@pieces); }
	    my $okfile = "$dir$base";
	    warn "Debug: Illegal name $file changed to $okfile\n" if $Debug;
	    $read->{"\L$okfile"}=$_;
	}
	else { /^(\S+)\s*(.*)/ and $read->{$1}=$2; }
d141 1
a141 1
    $mfile ||= "$MANIFEST.SKIP";
a146 1
	next if /^#/;
d164 1
a164 1
    $how ||= 'cp';
d178 2
a179 1
	cp_if_diff($file, "$target/$file", $how);
d184 2
a185 2
    my($from, $to, $how)=@@_;
    -f $from or carp "$0: $from not found";
d200 20
a219 8
      STRICT_SWITCH: {
	    best($from,$to), last STRICT_SWITCH if $how eq 'best';
	    cp($from,$to), last STRICT_SWITCH if $how eq 'cp';
	    ln($from,$to), last STRICT_SWITCH if $how eq 'ln';
	    croak("ExtUtils::Manifest::cp_if_diff " .
		  "called with illegal how argument [$how]. " .
		  "Legal values are 'best', 'cp', and 'ln'.");
	}
d227 1
a227 1
    utime $access, $mod + ($Is_VMS ? 1 : 0), $dstFile;
a233 1
    return &cp if $Is_VMS;
d237 1
a237 5
    if (! chmod(  $mode | ( $mode & 0100 ? 0111 : 0 ),  $_  )) {
       unlink $dstFile;
       return;
    }
    1;
d245 1
a245 1
	ln($srcFile, $dstFile) or cp($srcFile, $dstFile);
d289 1
a289 1
comments are separated by one or more TAB characters in the
d308 1
a308 1
Manifind() returns a hash reference. The keys of the hash are the
a313 2
Blank lines and lines which start with C<#> in the C<MANIFEST> file
are discarded.
d329 1
a329 3
expressions should appear one on each line. Blank lines and lines
which start with C<#> are skipped.  Use C<\#> if you need a regular
expression to start with a sharp character. A typical example:
d353 1
a353 1
C<$ExtUtils::Manifest::Quiet> defaults to 0. If set to a true value,
d390 1
a390 1
Andreas Koenig <F<koenig@@franz.ww.TU-Berlin.DE>>
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a27 1
    no warnings;
d189 1
d271 1
a271 1
    require ExtUtils::Manifest;
d273 1
a273 1
    ExtUtils::Manifest::mkmanifest;
d275 1
a275 1
    ExtUtils::Manifest::manicheck;
d277 1
a277 1
    ExtUtils::Manifest::filecheck;
d279 1
a279 1
    ExtUtils::Manifest::fullcheck;
d281 1
a281 1
    ExtUtils::Manifest::skipcheck;
d283 1
a283 1
    ExtUtils::Manifest::manifind();
d285 1
a285 1
    ExtUtils::Manifest::maniread($file);
d287 1
a287 1
    ExtUtils::Manifest::manicopy($read,$target,$how);
d291 1
a291 1
mkmanifest() writes all files in and below the current directory to a
d305 1
a305 1
manicheck() checks if all the files within a C<MANIFEST> in the
d310 1
a310 1
filecheck() finds files below the current directory that are not
d315 1
a315 1
fullcheck() does both a manicheck() and a filecheck().
d317 1
a317 1
skipcheck() lists all the files that are skipped due to your
d320 1
a320 1
manifind() returns a hash reference. The keys of the hash are the
d323 1
a323 1
maniread($file) reads a named C<MANIFEST> file (defaults to
d329 1
a329 1
C<manicopy($read,$target,$how)> copies the files that are the keys in
d331 1
a331 1
$read is typically returned by the maniread() function. This
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d11 1
a11 1
	    $Is_MacOS $Is_VMS $Debug $Verbose $Quiet $MANIFEST $found);
a17 1
$Is_MacOS = $^O eq 'MacOS';
a51 1
	$file = _unmacify($file);
d63 1
a63 2
	      (my $name = $File::Find::name) =~ s|^\./||;
	      $name =~ s/^:([^:]+)$/$1/ if $Is_MacOS;
d65 2
a66 2
	      $name =~ s#(.*)\.$#\L$1# if $Is_VMS;
	      $found->{$name} = "";}, $Is_MacOS ? ":" : ".");
d118 1
a118 2
		my $canon = "\t" . _unmacify($file) if $Is_MacOS;
		warn "Not in $MANIFEST: $file$canon\n" unless $Quiet;
d138 1
a138 7
	if ($Is_MacOS) {
	    my($item,$text) = /^(\S+)\s*(.*)/;
	    $item = _macify($item);
	    $item =~ s/\\([0-3][0-7][0-7])/sprintf("%c", oct($1))/ge;
	    $read->{$item}=$text;
	}
	elsif ($Is_VMS) {
d169 1
a169 1
	push @@skip, _macify($_);
d190 1
a190 1
    File::Path::mkpath([ $target ],! $Quiet,$Is_VMS ? undef : 0755);
d192 5
a196 15
    	if ($Is_MacOS) {
	    if ($file =~ m!:!) { 
	   	my $dir = _maccat($target, $file);
		$dir =~ s/[^:]+$//;
	    	File::Path::mkpath($dir,1,0755);
	    }
	    cp_if_diff($file, _maccat($target, $file), $how);
	} else {
	    $file = VMS::Filespec::unixify($file) if $Is_VMS;
	    if ($file =~ m!/!) { # Ilya, that hurts, I fear, or maybe not?
		my $dir = File::Basename::dirname($file);
		$dir = VMS::Filespec::unixify($dir) if $Is_VMS;
		File::Path::mkpath(["$target/$dir"],! $Quiet,$Is_VMS ? undef : 0755);
	    }
	    cp_if_diff($file, "$target/$file", $how);
d198 1
d207 2
a208 2
    open(F,"< $from\0") or croak "Can't read $from: $!\n";
    if (open(T,"< $to\0")) {
d236 1
a236 1
    chmod(  0444 | ( $perm & 0111 ? 0111 : 0 ),  $dstFile ) unless ($^O eq 'MacOS');
d241 1
a241 1
    return &cp if $Is_VMS or ($^O eq 'MSWin32' and Win32::IsWin95());
a258 36
}

sub _macify {
    my($file) = @@_;

    return $file unless $Is_MacOS;
    
    $file =~ s|^\./||;
    if ($file =~ m|/|) {
	$file =~ s|/+|:|g;
	$file = ":$file";
    }
    
    $file;
}

sub _maccat {
    my($f1, $f2) = @@_;
    
    return "$f1/$f2" unless $Is_MacOS;
    
    $f1 .= ":$f2";
    $f1 =~ s/([^:]:):/$1/g;
    return $f1;
}

sub _unmacify {
    my($file) = @@_;

    return $file unless $Is_MacOS;
    
    $file =~ s|^:||;
    $file =~ s|([/ \n])|sprintf("\\%03o", unpack("c", $1))|ge;
    $file =~ y|:|/|;
    
    $file;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a6 1
use File::Spec;
d10 2
a11 3
use vars qw($VERSION @@ISA @@EXPORT_OK 
          $Is_MacOS $Is_VMS 
          $Debug $Verbose $Quiet $MANIFEST $DEFAULT_MSKIP);
d13 1
a13 1
$VERSION = 1.38;
d20 1
a20 1
require VMS::Filespec if $Is_VMS;
d22 2
a23 3
$Debug = $ENV{PERL_MM_MANIFEST_DEBUG} || 0;
$Verbose = defined $ENV{PERL_MM_MANIFEST_VERBOSE} ?
                   $ENV{PERL_MM_MANIFEST_VERBOSE} : 1;
d26 6
a31 2
$DEFAULT_MSKIP = (File::Spec->splitpath($INC{"ExtUtils/Manifest.pm"}))[1].
                 "$MANIFEST.SKIP";
d35 1
a35 1
    my $read = (-r 'MANIFEST' && maniread()) or $manimiss++;
d40 1
a40 1
    my $skip = _maniskip();
d47 1
a47 6
	if ($skip->($file)) {
	    # Policy: only remove files if they're listed in MANIFEST.SKIP.
	    # Don't remove files just because they don't exist.
	    warn "Removed from $MANIFEST: $file\n" if $Verbose and exists $read->{$file};
	    next;
	}
a61 9
# Geez, shouldn't this use File::Spec or File::Basename or something?  
# Why so careful about dependencies?
sub clean_up_filename {
  my $filename = shift;
  $filename =~ s|^\./||;
  $filename =~ s/^:([^:]+)$/$1/ if $Is_MacOS;
  return $filename;
}

d63 8
a70 23
    my $p = shift || {};
    my $found = {};

    my $wanted = sub {
	my $name = clean_up_filename($File::Find::name);
	warn "Debug: diskfile $name\n" if $Debug;
	return if -d $_;
	
        if( $Is_VMS ) {
            $name =~ s#(.*)\.$#\L$1#;
            $name = uc($name) if $name =~ /^MANIFEST(\.SKIP)?$/i;
        }
	$found->{$name} = "";
    };

    # We have to use "$File::Find::dir/$_" in preprocess, because 
    # $File::Find::name is unavailable.
    # Also, it's okay to use / here, because MANIFEST files use Unix-style 
    # paths.
    find({wanted => $wanted},
	 $Is_MacOS ? ":" : ".");

    return $found;
d74 1
a74 1
    return [_check_files()], [_check_manifest()];
d78 1
a78 1
    return _check_files();
d82 1
a82 1
    return _check_manifest();
d86 1
a86 14
    my($p) = @@_;
    my $found = manifind();
    my $matches = _maniskip();

    my @@skipped = ();
    foreach my $file (sort keys %$found){
        if (&$matches($file)){
            warn "Skipping $file\n";
            push @@skipped, $file;
            next;
        }
    }

    return @@skipped;
d89 5
a93 3

sub _check_files {
    my $p = shift;
d95 31
a125 36
    my $read = maniread() || {};
    my $found = manifind($p);

    my(@@missfile) = ();
    foreach my $file (sort keys %$read){
        warn "Debug: manicheck checking from $MANIFEST $file\n" if $Debug;
        if ($dosnames){
            $file = lc $file;
            $file =~ s=(\.(\w|-)+)=substr ($1,0,4)=ge;
            $file =~ s=((\w|-)+)=substr ($1,0,8)=ge;
        }
        unless ( exists $found->{$file} ) {
            warn "No such file: $file\n" unless $Quiet;
            push @@missfile, $file;
        }
    }

    return @@missfile;
}


sub _check_manifest {
    my($p) = @@_;
    my $read = maniread() || {};
    my $found = manifind($p);
    my $skip  = _maniskip();

    my @@missentry = ();
    foreach my $file (sort keys %$found){
        next if $skip->($file);
        warn "Debug: manicheck checking from disk $file\n" if $Debug;
        unless ( exists $read->{$file} ) {
            my $canon = $Is_MacOS ? "\t" . _unmacify($file) : '';
            warn "Not in $MANIFEST: $file$canon\n" unless $Quiet;
            push @@missentry, $file;
        }
d127 1
a127 2

    return @@missentry;
a129 1

a141 4

        my($file, $comment) = /^(\S+)\s*(.*)/;
        next unless $file;

d143 4
a146 2
	    $file = _macify($file);
	    $file =~ s/\\([0-3][0-7][0-7])/sprintf("%c", oct($1))/ge;
d149 2
a150 1
        require File::Basename;
d158 1
a158 2
            $file = $okfile;
            $file = lc($file) unless $file =~ /^MANIFEST(\.SKIP)?$/;
d160 1
a160 2

        $read->{$file} = $comment;
d168 2
d171 1
a171 1
    my $mfile = "$MANIFEST.SKIP";
d173 2
a174 1
    open M, $mfile or open M, $DEFAULT_MSKIP or return sub {0};
d182 8
a189 7
    my $opts = $Is_VMS ? '(?i)' : '';

    # Make sure each entry is isolated in its own parentheses, in case
    # any of them contain alternations
    my $regex = join '|', map "(?:$_)", @@skip;

    return sub { $_[0] =~ qr{$opts$regex} };
d198 1
a198 1

d201 1
a201 1
    foreach my $file (keys %$read){
d226 1
a226 1
    open(F,"< $from\0") or die "Can't read $from: $!\n";
d255 1
a255 2
    chmod(  0444 | ( $perm & 0111 ? 0111 : 0 ),  $dstFile ) 
      unless ($^O eq 'MacOS');
d262 1
a262 3

    # chmod a+r,go-w+X (except "X" only applies to u=x)
    local($_) = $dstFile;
d265 2
a266 2
        unlink $dstFile;
        return;
a270 11
unless (defined $Config{d_link}) {
    # Really cool fix from Ilya :)
    local $SIG{__WARN__} = sub { 
        warn @@_ unless $_[0] =~ /^Subroutine .* redefined/;
    };
    *ln = \&cp;
}




d360 4
a363 5
manicheck() checks if all the files within a C<MANIFEST> in the current
directory really do exist. If C<MANIFEST> and the tree below the current
directory are in sync it exits silently, returning an empty list.  Otherwise
it returns a list of files which are listed in the C<MANIFEST> but missing
from the directory, and by default also outputs these names to STDERR.
d368 3
a370 7
file will not be reported as missing in the C<MANIFEST> file. The list of
any extraneous files found is returned, and by default also reported to
STDERR.

fullcheck() does both a manicheck() and a filecheck(), returning references
to two arrays, the first for files manicheck() found to be missing, the
seond for unexpeced files found by filecheck().
a401 1
    # Version control files and dirs.
a402 4
    \bCVS\b
    ,v$

    # Makemaker generated files and dirs.
d405 3
a410 11
    # Temp, old and emacs backup files.
    ~$
    \.old$
    ^#.*#$
    ^\.#

If no MANIFEST.SKIP file is found, a default set of skips will be
used, similar to the example above.  If you want nothing skipped,
simply make an empty MANIFEST.SKIP file.


a426 4
C<$ExtUtils::Manifest::Debug> defaults to 0.  If set to a true value,
or if PERL_MM_MANIFEST_DEBUG is true, debugging output will be
produced.

d431 1
a431 1
=over 4
d435 3
a437 5
is reported if a file is found which is not in C<MANIFEST>.

=item C<Skipping> I<file>

is reported if a file is skipped due to an entry in C<MANIFEST.SKIP>.
a454 10
=head1 ENVIRONMENT

=over 4

=item B<PERL_MM_MANIFEST_DEBUG>

Turns on debugging

=back

d461 1
a461 1
Andreas Koenig <F<andreas.koenig@@anima.de>>
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d15 1
a15 1
$VERSION = 1.42;
d17 2
a18 4
@@EXPORT_OK = qw(mkmanifest
                manicheck  filecheck  fullcheck  skipcheck
                manifind   maniread   manicopy   maniadd
               );
d21 1
a21 1
$Is_VMS   = $^O eq 'VMS';
d24 1
a24 1
$Debug   = $ENV{PERL_MM_MANIFEST_DEBUG} || 0;
d29 1
a29 3

my $Filename = __FILE__;
$DEFAULT_MSKIP = (File::Spec->splitpath($Filename))[1].
a31 56

=head1 NAME

ExtUtils::Manifest - utilities to write and check a MANIFEST file

=head1 SYNOPSIS

    use ExtUtils::Manifest qw(...funcs to import...);

    mkmanifest();

    my @@missing_files    = manicheck;
    my @@skipped          = skipcheck;
    my @@extra_files      = filecheck;
    my($missing, $extra) = fullcheck;

    my $found    = manifind();

    my $manifest = maniread();

    manicopy($read,$target);

    maniadd({$file => $comment, ...});


=head1 DESCRIPTION

=head2 Functions

ExtUtils::Manifest exports no functions by default.  The following are
exported on request

=over 4

=item mkmanifest

    mkmanifest();

Writes all files in and below the current directory to your F<MANIFEST>.
It works similar to

    find . > MANIFEST

All files that match any regular expression in a file F<MANIFEST.SKIP>
(if it exists) are ignored.

Any existing F<MANIFEST> file will be saved as F<MANIFEST.bak>.  Lines
from the old F<MANIFEST> file is preserved, including any comments
that are found in the existing F<MANIFEST> file in the new one.

=cut

sub _sort {
    return sort { lc $a cmp lc $b } @@_;
}

d45 1
a45 1
    foreach $file (_sort keys %all) {
a74 10

=item manifind

    my $found = manifind();

returns a hash reference. The keys of the hash are the files found
below the current directory.

=cut

d101 3
a103 13

=item manicheck

    my @@missing_files = manicheck();

checks if all the files within a C<MANIFEST> in the current directory
really do exist. If C<MANIFEST> and the tree below the current
directory are in sync it silently returns an empty list.
Otherwise it returns a list of files which are listed in the
C<MANIFEST> but missing from the directory, and by default also
outputs these names to STDERR.

=cut
a108 14

=item filecheck

    my @@extra_files = filecheck();

finds files below the current directory that are not mentioned in the
C<MANIFEST> file. An optional file C<MANIFEST.SKIP> will be
consulted. Any file matching a regular expression in such a file will
not be reported as missing in the C<MANIFEST> file. The list of any
extraneous files found is returned, and by default also reported to
STDERR.

=cut

a112 24

=item fullcheck

    my($missing, $extra) = fullcheck();

does both a manicheck() and a filecheck(), returning then as two array
refs.

=cut

sub fullcheck {
    return [_check_files()], [_check_manifest()];
}


=item skipcheck

    my @@skipped = skipcheck();

lists all the files that are skipped due to your C<MANIFEST.SKIP>
file.

=cut

d119 1
a119 1
    foreach my $file (_sort keys %$found){
d138 1
a138 1
    foreach my $file (_sort keys %$read){
d162 1
a162 1
    foreach my $file (_sort keys %$found){
a175 12
=item maniread

    my $manifest = maniread();
    my $manifest = maniread($manifest_file);

reads a named C<MANIFEST> file (defaults to C<MANIFEST> in the current
directory) and returns a HASH reference with files being the keys and
comments being the values of the HASH.  Blank lines and lines which
start with C<#> in the C<MANIFEST> file are discarded.

=cut

d182 2
a183 2
        warn "$mfile: $!";
        return $read;
a184 1
    local $_;
d186 2
a187 2
        chomp;
        next if /^\s*#/;
d192 13
a204 13
        if ($Is_MacOS) {
            $file = _macify($file);
            $file =~ s/\\([0-3][0-7][0-7])/sprintf("%c", oct($1))/ge;
        }
        elsif ($Is_VMS) {
            require File::Basename;
            my($base,$dir) = File::Basename::fileparse($file);
            # Resolve illegal file specifications in the same way as tar
            $dir =~ tr/./_/;
            my(@@pieces) = split(/\./,$base);
            if (@@pieces > 2) { $base = shift(@@pieces) . '.' . join('_',@@pieces); }
            my $okfile = "$dir$base";
            warn "Debug: Illegal name $file changed to $okfile\n" if $Debug;
d207 1
a207 1
        }
d219 1
a219 1
    local(*M,$_);
a236 17
=item manicopy

    manicopy($src, $dest_dir);
    manicopy($src, $dest_dir, $how);

copies the files that are the keys in the HASH I<%$src> to the
$dest_dir. The HASH reference $read is typically returned by the
maniread() function. This function is useful for producing a directory
tree identical to the intended distribution tree. The third parameter
$how can be used to specify a different methods of "copying". Valid
values are C<cp>, which actually copies the files, C<ln> which creates
hard links, and C<best> which mostly links the files but copies any
symbolic link to make a tree without any symbolic link. Best is the
default.

=cut

a272 1
        local $_;
d375 1
d377 1
a377 1
=item maniadd
d379 1
a379 1
  maniadd({ $file => $comment, ...});
d381 1
a381 1
Adds an entry to an existing F<MANIFEST> unless its already there.
d383 1
a383 1
$file will be normalized (ie. Unixified).  B<UNIMPLEMENTED>
d385 1
a385 1
=cut
d387 1
a387 2
sub maniadd {
    my($additions) = shift;
d389 1
a389 2
    _normalize($additions);
    _fix_manifest($MANIFEST);
d391 1
a391 3
    my $manifest = maniread();
    my @@needed = grep { !exists $manifest->{$_} } keys %$additions;
    return 1 unless @@needed;
d393 1
a393 2
    open(MANIFEST, ">>$MANIFEST") or 
      die "maniadd() could not open $MANIFEST: $!";
d395 1
a395 5
    foreach my $file (_sort @@needed) {
        my $comment = $additions->{$file} || '';
        printf MANIFEST "%-40s %s\n", $file, $comment;
    }
    close MANIFEST or die "Error closing $MANIFEST: $!";
d397 1
a397 2
    return 1;
}
d399 1
d401 1
a401 3
# Sometimes MANIFESTs are missing a trailing newline.  Fix this.
sub _fix_manifest {
    my $manifest_file = shift;
d403 1
a403 1
    open MANIFEST, $MANIFEST or die "Could not open $MANIFEST: $!";
d405 26
a430 4
    # Yes, we should be using seek(), but I'd like to avoid loading POSIX
    # to get SEEK_*
    my @@manifest = <MANIFEST>;
    close MANIFEST;
d432 25
a456 7
    unless( $manifest[-1] =~ /\n\z/ ) {
        open MANIFEST, ">>$MANIFEST" or die "Could not open $MANIFEST: $!";
        print MANIFEST "\n";
        close MANIFEST;
    }
}
        
d458 1
a458 16
# UNIMPLEMENTED
sub _normalize {
    return;
}


=back

=head2 MANIFEST

Anything between white space and an end of line within a C<MANIFEST>
file is considered to be a comment.  Filenames and comments are
separated by one or more TAB characters in the output. 


=head2 MANIFEST.SKIP
a469 1
    \B\.svn\b
d488 1
a488 1
=head2 EXPORT_OK
d493 1
a493 1
=head2 GLOBAL VARIABLES
a556 2

1;
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d5 1
a5 1
use File::Basename;
a6 1
use File::Find;
d15 1
a15 1
$VERSION = '1.46';
d32 3
a34 1
$DEFAULT_MSKIP = File::Spec->catfile( dirname(__FILE__), "$MANIFEST.SKIP" );
d370 2
a371 5
    manicopy(\%src, $dest_dir);
    manicopy(\%src, $dest_dir, $how);

Copies the files that are the keys in %src to the $dest_dir.  %src is
typically returned by the maniread() function.
d373 5
a377 6
    manicopy( maniread(), $dest_dir );

This function is useful for producing a directory tree identical to the 
intended distribution tree. 

$how can be used to specify a different methods of "copying".  Valid
d380 1
a380 1
symbolic link to make a tree without any symbolic link.  C<cp> is the 
d432 1
a432 1
        STRICT_SWITCH: {
d445 1
a445 2
    my ($access,$mod) = (stat $srcFile)[8,9];

d448 3
a450 1
    _manicopy_chmod($dstFile);
a452 1

d458 4
a461 1
    unless( _manicopy_chmod($dstFile) ) {
d468 9
a476 5
# 1) Strip off all group and world permissions.
# 2) Let everyone read it.
# 3) If the owner can execute it, everyone can.
sub _manicopy_chmod {
    my($file) = shift;
a477 3
    my $perm = 0444 | (stat $file)[2] & 0700;
    chmod( $perm | ( $perm & 0100 ? 0111 : 0 ), $file );
}
a478 2
# Files that are often modified in the distdir.  Don't hard link them.
my @@Exceptions = qw(MANIFEST META.yml SIGNATURE);
d481 1
a481 3

    my $is_exception = grep $srcFile =~ /$_/, @@Exceptions;
    if ($is_exception or !$Config{d_link} or -l $srcFile) {
d492 1
a492 1

d498 1
a498 1

d504 1
a504 1

d506 1
a506 1

d516 1
a516 1

d520 1
a520 1

d575 1
a575 1

a586 4
A list of files in the distribution, one file per line.  The MANIFEST
always uses Unix filepath conventions even if you're not on Unix.  This
means F<foo/bar> style not F<foo\bar>.

d588 2
a589 6
file is considered to be a comment.  Any line beginning with # is also
a comment.

    # this a comment
    some/file
    some/other/file            comment about some/file
d598 1
a598 3
expression to start with a C<#>.

For example:
d689 1
a689 3
Andreas Koenig C<andreas.koenig@@anima.de>

Currently maintained by Michael G Schwern C<schwern@@pobox.com>
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d16 1
a16 1
$VERSION = '1.51_01';
d96 1
a96 3
    my $bakbase = $MANIFEST;
    $bakbase =~ s/\./_/g if $Is_VMS; # avoid double dots
    rename $MANIFEST, "$bakbase.bak" unless $manimiss;
d115 1
d311 1
a311 1
        warn "Problem opening $mfile: $!";
d349 1
a349 2
    _check_mskip_directives($mfile) if -f $mfile;
    local(*M, $_);
a352 1
	s/\r//;
a357 2
    return sub {0} unless (scalar @@skip > 0);

a366 71
# checks for the special directives
#   #!include_default
#   #!include /path/to/some/manifest.skip
# in a custom MANIFEST.SKIP for, for including
# the content of, respectively, the default MANIFEST.SKIP
# and an external manifest.skip file
sub _check_mskip_directives {
    my $mfile = shift;
    local (*M, $_);
    my @@lines = ();
    my $flag = 0;
    unless (open M, $mfile) {
        warn "Problem opening $mfile: $!";
        return;
    }
    while (<M>) {
        if (/^#!include_default\s*$/) {
	    if (my @@default = _include_mskip_file()) {
	        push @@lines, @@default;
		warn "Debug: Including default MANIFEST.SKIP\n" if $Debug;
		$flag++;
	    }
	    next;
        }
	if (/^#!include\s+(.*)\s*$/) {
	    my $external_file = $1;
	    if (my @@external = _include_mskip_file($external_file)) {
	        push @@lines, @@external;
		warn "Debug: Including external $external_file\n" if $Debug;
		$flag++;
	    }
            next;
        }
        push @@lines, $_;
    }
    close M;
    return unless $flag;
    my $bakbase = $mfile;
    $bakbase =~ s/\./_/g if $Is_VMS;  # avoid double dots
    rename $mfile, "$bakbase.bak";
    warn "Debug: Saving original $mfile as $bakbase.bak\n" if $Debug;
    unless (open M, ">$mfile") {
        warn "Problem opening $mfile: $!";
        return;
    }
    print M $_ for (@@lines);
    close M;
    return;
}

# returns an array containing the lines of an external
# manifest.skip file, if given, or $DEFAULT_MSKIP
sub _include_mskip_file {
    my $mskip = shift || $DEFAULT_MSKIP;
    unless (-f $mskip) {
        warn qq{Included file "$mskip" not found - skipping};
        return;
    }
    local (*M, $_);
    unless (open M, $mskip) {
        warn "Problem opening $mskip: $!";
        return;
    }
    my @@lines = ();
    push @@lines, "\n#!start included $mskip\n";
    push @@lines, $_ while <M>;
    close M;
    push @@lines, "#!end included $mskip\n\n";
    return @@lines;
}

d452 1
a452 1
    _manicopy_chmod($srcFile, $dstFile);
d461 1
a461 1
    unless( _manicopy_chmod($srcFile, $dstFile) ) {
d472 1
a472 1
    my($srcFile, $dstFile) = @@_;
d474 2
a475 2
    my $perm = 0444 | (stat $srcFile)[2] & 0700;
    chmod( $perm | ( $perm & 0100 ? 0111 : 0 ), $dstFile );
a634 20
In one's own MANIFEST.SKIP file, certain directives
can be used to include the contents of other MANIFEST.SKIP
files. At present two such directives are recognized.

=over 4

=item #!include_default

This inserts the contents of the default MANIFEST.SKIP file

=item #!include /Path/to/another/manifest.skip

This inserts the contents of the specified external file

=back

The included contents will be inserted into the MANIFEST.SKIP
file in between I<#!start included /path/to/manifest.skip>
and I<#!end included /path/to/manifest.skip> markers.
The original MANIFEST.SKIP is saved as MANIFEST.SKIP.bak.
d704 1
a704 3
Maintained by Michael G Schwern C<schwern@@pobox.com> within the
ExtUtils-MakeMaker package and, as a separate CPAN package, by
Randy Kobes C<r.kobes@@uwinnipeg.ca>.
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d13 1
a13 1
          $Is_MacOS $Is_VMS $Is_VMS_mode $Is_VMS_lc $Is_VMS_nodot
d16 1
a16 1
$VERSION = '1.56';
a20 1
                maniskip
d25 1
a25 29
$Is_VMS_mode = 0;
$Is_VMS_lc = 0;
$Is_VMS_nodot = 0;  # No dots in dir names or double dots in files

if ($Is_VMS) {
    require VMS::Filespec if $Is_VMS;
    my $vms_unix_rpt;
    my $vms_efs;
    my $vms_case;

    $Is_VMS_mode = 1;
    $Is_VMS_lc = 1;
    $Is_VMS_nodot = 1;
    if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
        $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
        $vms_efs = VMS::Feature::current("efs_charset");
        $vms_case = VMS::Feature::current("efs_case_preserve");
    } else {
        my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
        my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
        my $efs_case = $ENV{'DECC$EFS_CASE_PRESERVE'} || '';
        $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i; 
        $vms_efs = $efs_charset =~ /^[ET1]/i;
        $vms_case = $efs_case =~ /^[ET1]/i;
    }
    $Is_VMS_lc = 0 if ($vms_case);
    $Is_VMS_mode = 0 if ($vms_unix_rpt);
    $Is_VMS_nodot = 0 if ($vms_efs);
}
d74 1
a74 1
It works similar to the result of the Unix command
d81 3
a83 1
Any existing F<MANIFEST> file will be saved as F<MANIFEST.bak>.
d97 1
a97 1
    $bakbase =~ s/\./_/g if $Is_VMS_nodot; # avoid double dots
d99 2
a100 2
    open M, "> $MANIFEST" or die "Could not open $MANIFEST: $!";
    my $skip = maniskip();
d104 1
a104 2
    $all{$MANIFEST} = ($Is_VMS_mode ? "$MANIFEST\t\t" : '') .
                     'This list of files'
a120 4
        if ($file =~ /\s/) {
            $file =~ s/([\\'])/\\$1/g;
            $file = "'$file'";
        }
d153 2
a154 2

        if( $Is_VMS_lc ) {
d234 1
a234 1
    my $matches = maniskip();
d277 1
a277 1
    my $skip  = maniskip();
d311 1
a311 1
    unless (open M, "< $mfile"){
d320 1
a320 10
        my($file, $comment);

        # filename may contain spaces if enclosed in ''
        # (in which case, \\ and \' are escapes)
        if (($file, $comment) = /^'(\\[\\']|.+)+'\s*(.*)/) {
            $file =~ s/\\([\\'])/$1/g;
        }
        else {
            ($file, $comment) = /^(\S+)\s*(.*)/;
        }
d327 1
a327 1
        elsif ($Is_VMS_mode) {
d331 7
a337 11
            if ($Is_VMS_nodot) {
                $dir =~ tr/./_/;
                my(@@pieces) = split(/\./,$base);
                if (@@pieces > 2)
                    { $base = shift(@@pieces) . '.' . join('_',@@pieces); }
                my $okfile = "$dir$base";
                warn "Debug: Illegal name $file changed to $okfile\n" if $Debug;
                $file = $okfile;
            } 
            $file = lc($file)
                unless $Is_VMS_lc &&($file =~ /^MANIFEST(\.SKIP)?$/);
a345 13
=item maniskip

    my $skipchk = maniskip();
    my $skipchk = maniskip($manifest_skip_file);

    if ($skipchk->($file)) { .. }

reads a named C<MANIFEST.SKIP> file (defaults to C<MANIFEST.SKIP> in
the current directory) and returns a CODE reference that tests whether
a given filename should be skipped.

=cut

d347 1
a347 1
sub maniskip {
d349 1
a349 1
    my $mfile = shift || "$MANIFEST.SKIP";
d352 1
a352 1
    open M, "< $mfile" or open M, "< $DEFAULT_MSKIP" or return sub {0};
a357 2
        s/^'//;
        s/'$//;
d363 1
a363 1
    my $opts = $Is_VMS_mode ? '(?i)' : '';
d383 1
a383 1
    unless (open M, "< $mfile") {
d410 1
a410 1
    $bakbase =~ s/\./_/g if $Is_VMS_nodot;  # avoid double dots
d413 1
a413 1
    unless (open M, "> $mfile") {
d431 1
a431 1
    unless (open M, "< $mskip") {
d471 1
a471 1
    $target = VMS::Filespec::unixify($target) if $Is_VMS_mode;
d482 1
a482 1
	    $file = VMS::Filespec::unixify($file) if $Is_VMS_mode;
d485 1
a485 1
		$dir = VMS::Filespec::unixify($dir) if $Is_VMS_mode;
d495 1
a495 4
    if (! -f $from) {
        carp "$from not found";
        return;
    }
a533 1
    # Fix-me - VMS can support links.
a628 4
        if ($file =~ /\s/) {
            $file =~ s/([\\'])/\\$1/g;
            $file = "'$file'";
        }
d672 1
a672 3
a comment. Beginning with ExtUtils::Manifest 1.52, a filename may
contain whitespace characters if it is enclosed in single quotes; single
quotes or backslashes in that filename must be backslash-escaped.
a676 1
    'some/third file'          comment
@


