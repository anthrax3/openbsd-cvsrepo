head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2010.09.24.14.59.38;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.11;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.50;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.24;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.39;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.39;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.02;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.41;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.27;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.02;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.42;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.32;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.50;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package ExtUtils::Install;
use strict;

use vars qw(@@ISA @@EXPORT $VERSION $MUST_REBOOT %Config);

use AutoSplit;
use Carp ();
use Config qw(%Config);
use Cwd qw(cwd);
use Exporter;
use ExtUtils::Packlist;
use File::Basename qw(dirname);
use File::Compare qw(compare);
use File::Copy;
use File::Find qw(find);
use File::Path;
use File::Spec;


@@ISA = ('Exporter');
@@EXPORT = ('install','uninstall','pm_to_blib', 'install_default');

=pod

=head1 NAME

ExtUtils::Install - install files from here to there

=head1 SYNOPSIS

  use ExtUtils::Install;

  install({ 'blib/lib' => 'some/install/dir' } );

  uninstall($packlist);

  pm_to_blib({ 'lib/Foo/Bar.pm' => 'blib/lib/Foo/Bar.pm' });

=head1 VERSION

1.54

=cut

$VERSION = '1.54';  # <---- dont forget to update the POD section just above this line!
$VERSION = eval $VERSION;

=pod

=head1 DESCRIPTION

Handles the installing and uninstalling of perl modules, scripts, man
pages, etc...

Both install() and uninstall() are specific to the way
ExtUtils::MakeMaker handles the installation and deinstallation of
perl modules. They are not designed as general purpose tools.

On some operating systems such as Win32 installation may not be possible
until after a reboot has occured. This can have varying consequences:
removing an old DLL does not impact programs using the new one, but if
a new DLL cannot be installed properly until reboot then anything
depending on it must wait. The package variable

  $ExtUtils::Install::MUST_REBOOT

is used to store this status.

If this variable is true then such an operation has occured and
anything depending on this module cannot proceed until a reboot
has occured.

If this value is defined but false then such an operation has
ocurred, but should not impact later operations.

=begin _private

=item _chmod($$;$)

Wrapper to chmod() for debugging and error trapping.

=item _warnonce(@@)

Warns about something only once.

=item _choke(@@)

Dies with a special message.

=end _private

=cut

my $Is_VMS     = $^O eq 'VMS';
my $Is_VMS_noefs = $Is_VMS;
my $Is_MacPerl = $^O eq 'MacOS';
my $Is_Win32   = $^O eq 'MSWin32';
my $Is_cygwin  = $^O eq 'cygwin';
my $CanMoveAtBoot = ($Is_Win32 || $Is_cygwin);

    if( $Is_VMS ) {
        my $vms_unix_rpt;
        my $vms_efs;
        my $vms_case;

        if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
            $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
            $vms_efs = VMS::Feature::current("efs_charset");
            $vms_case = VMS::Feature::current("efs_case_preserve");
        } else {
            my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
            my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
            my $efs_case = $ENV{'DECC$EFS_CASE_PRESERVE'} || '';
            $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i;
            $vms_efs = $efs_charset =~ /^[ET1]/i;
            $vms_case = $efs_case =~ /^[ET1]/i;
        }
        $Is_VMS_noefs = 0 if ($vms_efs);
    }



# *note* CanMoveAtBoot is only incidentally the same condition as below
# this needs not hold true in the future.
my $Has_Win32API_File = ($Is_Win32 || $Is_cygwin)
    ? (eval {require Win32API::File; 1} || 0)
    : 0;


my $Inc_uninstall_warn_handler;

# install relative to here

my $INSTALL_ROOT = $ENV{PERL_INSTALL_ROOT};

my $Curdir = File::Spec->curdir;
my $Updir  = File::Spec->updir;

sub _estr(@@) {
    return join "\n",'!' x 72,@@_,'!' x 72,'';
}

{my %warned;
sub _warnonce(@@) {
    my $first=shift;
    my $msg=_estr "WARNING: $first",@@_;
    warn $msg unless $warned{$msg}++;
}}

sub _choke(@@) {
    my $first=shift;
    my $msg=_estr "ERROR: $first",@@_;
    Carp::croak($msg);
}


sub _chmod($$;$) {
    my ( $mode, $item, $verbose )=@@_;
    $verbose ||= 0;
    if (chmod $mode, $item) {
        printf "chmod(0%o, %s)\n",$mode, $item if $verbose > 1;
    } else {
        my $err="$!";
        _warnonce sprintf "WARNING: Failed chmod(0%o, %s): %s\n",
                  $mode, $item, $err
            if -e $item;
    }
}

=begin _private

=item _move_file_at_boot( $file, $target, $moan  )

OS-Specific, Win32/Cygwin

Schedules a file to be moved/renamed/deleted at next boot.
$file should be a filespec of an existing file
$target should be a ref to an array if the file is to be deleted
otherwise it should be a filespec for a rename. If the file is existing
it will be replaced.

Sets $MUST_REBOOT to 0 to indicate a deletion operation has occured
and sets it to 1 to indicate that a move operation has been requested.

returns 1 on success, on failure if $moan is false errors are fatal.
If $moan is true then returns 0 on error and warns instead of dies.

=end _private

=cut



sub _move_file_at_boot { #XXX OS-SPECIFIC
    my ( $file, $target, $moan  )= @@_;
    Carp::confess("Panic: Can't _move_file_at_boot on this platform!")
         unless $CanMoveAtBoot;

    my $descr= ref $target
                ? "'$file' for deletion"
                : "'$file' for installation as '$target'";

    if ( ! $Has_Win32API_File ) {

        my @@msg=(
            "Cannot schedule $descr at reboot.",
            "Try installing Win32API::File to allow operations on locked files",
            "to be scheduled during reboot. Or try to perform the operation by",
            "hand yourself. (You may need to close other perl processes first)"
        );
        if ( $moan ) { _warnonce(@@msg) } else { _choke(@@msg) }
        return 0;
    }
    my $opts= Win32API::File::MOVEFILE_DELAY_UNTIL_REBOOT();
    $opts= $opts | Win32API::File::MOVEFILE_REPLACE_EXISTING()
        unless ref $target;

    _chmod( 0666, $file );
    _chmod( 0666, $target ) unless ref $target;

    if (Win32API::File::MoveFileEx( $file, $target, $opts )) {
        $MUST_REBOOT ||= ref $target ? 0 : 1;
        return 1;
    } else {
        my @@msg=(
            "MoveFileEx $descr at reboot failed: $^E",
            "You may try to perform the operation by hand yourself. ",
            "(You may need to close other perl processes first).",
        );
        if ( $moan ) { _warnonce(@@msg) } else { _choke(@@msg) }
    }
    return 0;
}


=begin _private

=item _unlink_or_rename( $file, $tryhard, $installing )

OS-Specific, Win32/Cygwin

Tries to get a file out of the way by unlinking it or renaming it. On
some OS'es (Win32 based) DLL files can end up locked such that they can
be renamed but not deleted. Likewise sometimes a file can be locked such
that it cant even be renamed or changed except at reboot. To handle
these cases this routine finds a tempfile name that it can either rename
the file out of the way or use as a proxy for the install so that the
rename can happen later (at reboot).

  $file : the file to remove.
  $tryhard : should advanced tricks be used for deletion
  $installing : we are not merely deleting but we want to overwrite

When $tryhard is not true if the unlink fails its fatal. When $tryhard
is true then the file is attempted to be renamed. The renamed file is
then scheduled for deletion. If the rename fails then $installing
governs what happens. If it is false the failure is fatal. If it is true
then an attempt is made to schedule installation at boot using a
temporary file to hold the new file. If this fails then a fatal error is
thrown, if it succeeds it returns the temporary file name (which will be
a derivative of the original in the same directory) so that the caller can
use it to install under. In all other cases of success returns $file.
On failure throws a fatal error.

=end _private

=cut



sub _unlink_or_rename { #XXX OS-SPECIFIC
    my ( $file, $tryhard, $installing )= @@_;

    _chmod( 0666, $file );
    my $unlink_count = 0;
    while (unlink $file) { $unlink_count++; }
    return $file if $unlink_count > 0;
    my $error="$!";

    _choke("Cannot unlink '$file': $!")
          unless $CanMoveAtBoot && $tryhard;

    my $tmp= "AAA";
    ++$tmp while -e "$file.$tmp";
    $tmp= "$file.$tmp";

    warn "WARNING: Unable to unlink '$file': $error\n",
         "Going to try to rename it to '$tmp'.\n";

    if ( rename $file, $tmp ) {
        warn "Rename succesful. Scheduling '$tmp'\nfor deletion at reboot.\n";
        # when $installing we can set $moan to true.
        # IOW, if we cant delete the renamed file at reboot its
        # not the end of the world. The other cases are more serious
        # and need to be fatal.
        _move_file_at_boot( $tmp, [], $installing );
        return $file;
    } elsif ( $installing ) {
        _warnonce("Rename failed: $!. Scheduling '$tmp'\nfor".
             " installation as '$file' at reboot.\n");
        _move_file_at_boot( $tmp, $file );
        return $tmp;
    } else {
        _choke("Rename failed:$!", "Cannot procede.");
    }

}


=pod

=head2 Functions

=begin _private

=item _get_install_skip

Handles loading the INSTALL.SKIP file. Returns an array of patterns to use.

=cut



sub _get_install_skip {
    my ( $skip, $verbose )= @@_;
    if ($ENV{EU_INSTALL_IGNORE_SKIP}) {
        print "EU_INSTALL_IGNORE_SKIP is set, ignore skipfile settings\n"
            if $verbose>2;
        return [];
    }
    if ( ! defined $skip ) {
        print "Looking for install skip list\n"
            if $verbose>2;
        for my $file ( 'INSTALL.SKIP', $ENV{EU_INSTALL_SITE_SKIPFILE} ) {
            next unless $file;
            print "\tChecking for $file\n"
                if $verbose>2;
            if (-e $file) {
                $skip= $file;
                last;
            }
        }
    }
    if ($skip && !ref $skip) {
        print "Reading skip patterns from '$skip'.\n"
            if $verbose;
        if (open my $fh,$skip ) {
            my @@patterns;
            while (<$fh>) {
                chomp;
                next if /^\s*(?:#|$)/;
                print "\tSkip pattern: $_\n" if $verbose>3;
                push @@patterns, $_;
            }
            $skip= \@@patterns;
        } else {
            warn "Can't read skip file:'$skip':$!\n";
            $skip=[];
        }
    } elsif ( UNIVERSAL::isa($skip,'ARRAY') ) {
        print "Using array for skip list\n"
            if $verbose>2;
    } elsif ($verbose) {
        print "No skip list found.\n"
            if $verbose>1;
        $skip= [];
    }
    warn "Got @@{[0+@@$skip]} skip patterns.\n"
        if $verbose>3;
    return $skip
}

=pod

=item _have_write_access

Abstract a -w check that tries to use POSIX::access() if possible.

=cut

{
    my  $has_posix;
    sub _have_write_access {
        my $dir=shift;
        unless (defined $has_posix) {
            $has_posix= (!$Is_cygwin && !$Is_Win32
             && eval 'local $^W; require POSIX; 1') || 0;
        }
        if ($has_posix) {
            return POSIX::access($dir, POSIX::W_OK());
        } else {
            return -w $dir;
        }
    }
}

=pod

=item _can_write_dir(C<$dir>)

Checks whether a given directory is writable, taking account
the possibility that the directory might not exist and would have to
be created first.

Returns a list, containing: C<($writable, $determined_by, @@create)>

C<$writable> says whether whether the directory is (hypothetically) writable

C<$determined_by> is the directory the status was determined from. It will be
either the C<$dir>, or one of its parents.

C<@@create> is a list of directories that would probably have to be created
to make the requested directory. It may not actually be correct on
relative paths with C<..> in them. But for our purposes it should work ok

=cut


sub _can_write_dir {
    my $dir=shift;
    return
        unless defined $dir and length $dir;

    my ($vol, $dirs, $file) = File::Spec->splitpath($dir,1);
    my @@dirs = File::Spec->splitdir($dirs);
    unshift @@dirs, File::Spec->curdir
        unless File::Spec->file_name_is_absolute($dir);

    my $path='';
    my @@make;
    while (@@dirs) {
        if ($Is_VMS_noefs) {
            # There is a bug in catdir that is fixed when the EFS character
            # set is enabled, which requires this VMS specific code.
            $dir = File::Spec->catdir($vol,@@dirs);
        }
        else {
            $dir = File::Spec->catdir(@@dirs);
            $dir = File::Spec->catpath($vol,$dir,'')
                    if defined $vol and length $vol;
        }
        next if ( $dir eq $path );
        if ( ! -e $dir ) {
            unshift @@make,$dir;
            next;
        }
        if ( _have_write_access($dir) ) {
            return 1,$dir,@@make
        } else {
            return 0,$dir,@@make
        }
    } continue {
        pop @@dirs;
    }
    return 0;
}

=pod

=item _mkpath($dir,$show,$mode,$verbose,$dry_run)

Wrapper around File::Path::mkpath() to handle errors.

If $verbose is true and >1 then additional diagnostics will be produced, also
this will force $show to true.

If $dry_run is true then the directory will not be created but a check will be
made to see whether it would be possible to write to the directory, or that
it would be possible to create the directory.

If $dry_run is not true dies if the directory can not be created or is not
writable.

=cut

sub _mkpath {
    my ($dir,$show,$mode,$verbose,$dry_run)=@@_;
    if ( $verbose && $verbose > 1 && ! -d $dir) {
        $show= 1;
        printf "mkpath(%s,%d,%#o)\n", $dir, $show, $mode;
    }
    if (!$dry_run) {
        if ( ! eval { File::Path::mkpath($dir,$show,$mode); 1 } ) {
            _choke("Can't create '$dir'","$@@");
        }

    }
    my ($can,$root,@@make)=_can_write_dir($dir);
    if (!$can) {
        my @@msg=(
            "Can't create '$dir'",
            $root ? "Do not have write permissions on '$root'"
                  : "Unknown Error"
        );
        if ($dry_run) {
            _warnonce @@msg;
        } else {
            _choke @@msg;
        }
    } elsif ($show and $dry_run) {
        print "$_\n" for @@make;
    }

}

=pod

=item _copy($from,$to,$verbose,$dry_run)

Wrapper around File::Copy::copy to handle errors.

If $verbose is true and >1 then additional dignostics will be emitted.

If $dry_run is true then the copy will not actually occur.

Dies if the copy fails.

=cut


sub _copy {
    my ( $from, $to, $verbose, $dry_run)=@@_;
    if ($verbose && $verbose>1) {
        printf "copy(%s,%s)\n", $from, $to;
    }
    if (!$dry_run) {
        File::Copy::copy($from,$to)
            or Carp::croak( _estr "ERROR: Cannot copy '$from' to '$to': $!" );
    }
}

=pod

=item _chdir($from)

Wrapper around chdir to catch errors.

If not called in void context returns the cwd from before the chdir.

dies on error.

=cut

sub _chdir {
    my ($dir)= @@_;
    my $ret;
    if (defined wantarray) {
        $ret= cwd;
    }
    chdir $dir
        or _choke("Couldn't chdir to '$dir': $!");
    return $ret;
}

=pod

=end _private

=over 4

=item B<install>

    # deprecated forms
    install(\%from_to);
    install(\%from_to, $verbose, $dry_run, $uninstall_shadows,
                $skip, $always_copy, \%result);

    # recommended form as of 1.47
    install([
        from_to => \%from_to,
        verbose => 1,
        dry_run => 0,
        uninstall_shadows => 1,
        skip => undef,
        always_copy => 1,
        result => \%install_results,
    ]);


Copies each directory tree of %from_to to its corresponding value
preserving timestamps and permissions.

There are two keys with a special meaning in the hash: "read" and
"write".  These contain packlist files.  After the copying is done,
install() will write the list of target files to $from_to{write}. If
$from_to{read} is given the contents of this file will be merged into
the written file. The read and the written file may be identical, but
on AFS it is quite likely that people are installing to a different
directory than the one where the files later appear.

If $verbose is true, will print out each file removed.  Default is
false.  This is "make install VERBINST=1". $verbose values going
up to 5 show increasingly more diagnostics output.

If $dry_run is true it will only print what it was going to do
without actually doing it.  Default is false.

If $uninstall_shadows is true any differing versions throughout @@INC
will be uninstalled.  This is "make install UNINST=1"

As of 1.37_02 install() supports the use of a list of patterns to filter out
files that shouldn't be installed. If $skip is omitted or undefined then
install will try to read the list from INSTALL.SKIP in the CWD. This file is
a list of regular expressions and is just like the MANIFEST.SKIP file used
by L<ExtUtils::Manifest>.

A default site INSTALL.SKIP may be provided by setting then environment
variable EU_INSTALL_SITE_SKIPFILE, this will only be used when there isn't a
distribution specific INSTALL.SKIP. If the environment variable
EU_INSTALL_IGNORE_SKIP is true then no install file filtering will be
performed.

If $skip is undefined then the skip file will be autodetected and used if it
is found. If $skip is a reference to an array then it is assumed the array
contains the list of patterns, if $skip is a true non reference it is
assumed to be the filename holding the list of patterns, any other value of
$skip is taken to mean that no install filtering should occur.

B<Changes As of Version 1.47>

As of version 1.47 the following additions were made to the install interface.
Note that the new argument style and use of the %result hash is recommended.

The $always_copy parameter which when true causes files to be updated
regardles as to whether they have changed, if it is defined but false then
copies are made only if the files have changed, if it is undefined then the
value of the environment variable EU_INSTALL_ALWAYS_COPY is used as default.

The %result hash will be populated with the various keys/subhashes reflecting
the install. Currently these keys and their structure are:

    install             => { $target    => $source },
    install_fail        => { $target    => $source },
    install_unchanged   => { $target    => $source },

    install_filtered    => { $source    => $pattern },

    uninstall           => { $uninstalled => $source },
    uninstall_fail      => { $uninstalled => $source },

where C<$source> is the filespec of the file being installed. C<$target> is where
it is being installed to, and C<$uninstalled> is any shadow file that is in C<@@INC>
or C<$ENV{PERL5LIB}> or other standard locations, and C<$pattern> is the pattern that
caused a source file to be skipped. In future more keys will be added, such as to
show created directories, however this requires changes in other modules and must
therefore wait.

These keys will be populated before any exceptions are thrown should there be an
error.

Note that all updates of the %result are additive, the hash will not be
cleared before use, thus allowing status results of many installs to be easily
aggregated.

B<NEW ARGUMENT STYLE>

If there is only one argument and it is a reference to an array then
the array is assumed to contain a list of key-value pairs specifying
the options. In this case the option "from_to" is mandatory. This style
means that you dont have to supply a cryptic list of arguments and can
use a self documenting argument list that is easier to understand.

This is now the recommended interface to install().

B<RETURN>

If all actions were successful install will return a hashref of the results
as described above for the $result parameter. If any action is a failure
then install will die, therefore it is recommended to pass in the $result
parameter instead of using the return value. If the result parameter is
provided then the returned hashref will be the passed in hashref.

=cut

sub install { #XXX OS-SPECIFIC
    my($from_to,$verbose,$dry_run,$uninstall_shadows,$skip,$always_copy,$result) = @@_;
    if (@@_==1 and eval { 1+@@$from_to }) {
        my %opts        = @@$from_to;
        $from_to        = $opts{from_to}
                            or Carp::confess("from_to is a mandatory parameter");
        $verbose        = $opts{verbose};
        $dry_run        = $opts{dry_run};
        $uninstall_shadows  = $opts{uninstall_shadows};
        $skip           = $opts{skip};
        $always_copy    = $opts{always_copy};
        $result         = $opts{result};
    }

    $result ||= {};
    $verbose ||= 0;
    $dry_run  ||= 0;

    $skip= _get_install_skip($skip,$verbose);
    $always_copy =  $ENV{EU_INSTALL_ALWAYS_COPY}
                 || $ENV{EU_ALWAYS_COPY}
                 || 0
        unless defined $always_copy;

    my(%from_to) = %$from_to;
    my(%pack, $dir, %warned);
    my($packlist) = ExtUtils::Packlist->new();

    local(*DIR);
    for (qw/read write/) {
        $pack{$_}=$from_to{$_};
        delete $from_to{$_};
    }
    my $tmpfile = install_rooted_file($pack{"read"});
    $packlist->read($tmpfile) if (-f $tmpfile);
    my $cwd = cwd();
    my @@found_files;
    my %check_dirs;

    MOD_INSTALL: foreach my $source (sort keys %from_to) {
        #copy the tree to the target directory without altering
        #timestamp and permission and remember for the .packlist
        #file. The packlist file contains the absolute paths of the
        #install locations. AFS users may call this a bug. We'll have
        #to reconsider how to add the means to satisfy AFS users also.

        #October 1997: we want to install .pm files into archlib if
        #there are any files in arch. So we depend on having ./blib/arch
        #hardcoded here.

        my $targetroot = install_rooted_dir($from_to{$source});

        my $blib_lib  = File::Spec->catdir('blib', 'lib');
        my $blib_arch = File::Spec->catdir('blib', 'arch');
        if ($source eq $blib_lib and
            exists $from_to{$blib_arch} and
            directory_not_empty($blib_arch)
        ){
            $targetroot = install_rooted_dir($from_to{$blib_arch});
            print "Files found in $blib_arch: installing files in $blib_lib into architecture dependent library tree\n";
        }

        next unless -d $source;
        _chdir($source);
        # 5.5.3's File::Find missing no_chdir option
        # XXX OS-SPECIFIC
        # File::Find seems to always be Unixy except on MacPerl :(
        my $current_directory= $Is_MacPerl ? $Curdir : '.';
        find(sub {
            my ($mode,$size,$atime,$mtime) = (stat)[2,7,8,9];

            return if !-f _;
            my $origfile = $_;

            return if $origfile eq ".exists";
            my $targetdir  = File::Spec->catdir($targetroot, $File::Find::dir);
            my $targetfile = File::Spec->catfile($targetdir, $origfile);
            my $sourcedir  = File::Spec->catdir($source, $File::Find::dir);
            my $sourcefile = File::Spec->catfile($sourcedir, $origfile);

            for my $pat (@@$skip) {
                if ( $sourcefile=~/$pat/ ) {
                    print "Skipping $targetfile (filtered)\n"
                        if $verbose>1;
                    $result->{install_filtered}{$sourcefile} = $pat;
                    return;
                }
            }
            # we have to do this for back compat with old File::Finds
            # and because the target is relative
            my $save_cwd = _chdir($cwd);
            my $diff = 0;
            # XXX: I wonder how useful this logic is actually -- demerphq
            if ( $always_copy or !-f $targetfile or -s $targetfile != $size) {
                $diff++;
            } else {
                # we might not need to copy this file
                $diff = compare($sourcefile, $targetfile);
            }
            $check_dirs{$targetdir}++
                unless -w $targetfile;

            push @@found_files,
                [ $diff, $File::Find::dir, $origfile,
                  $mode, $size, $atime, $mtime,
                  $targetdir, $targetfile, $sourcedir, $sourcefile,

                ];
            #restore the original directory we were in when File::Find
            #called us so that it doesnt get horribly confused.
            _chdir($save_cwd);
        }, $current_directory );
        _chdir($cwd);
    }
    foreach my $targetdir (sort keys %check_dirs) {
        _mkpath( $targetdir, 0, 0755, $verbose, $dry_run );
    }
    foreach my $found (@@found_files) {
        my ($diff, $ffd, $origfile, $mode, $size, $atime, $mtime,
            $targetdir, $targetfile, $sourcedir, $sourcefile)= @@$found;

        my $realtarget= $targetfile;
        if ($diff) {
            eval {
                if (-f $targetfile) {
                    print "_unlink_or_rename($targetfile)\n" if $verbose>1;
                    $targetfile= _unlink_or_rename( $targetfile, 'tryhard', 'install' )
                        unless $dry_run;
                } elsif ( ! -d $targetdir ) {
                    _mkpath( $targetdir, 0, 0755, $verbose, $dry_run );
                }
                print "Installing $targetfile\n";

                _copy( $sourcefile, $targetfile, $verbose, $dry_run, );


                #XXX OS-SPECIFIC
                print "utime($atime,$mtime,$targetfile)\n" if $verbose>1;
                utime($atime,$mtime + $Is_VMS,$targetfile) unless $dry_run>1;


                $mode = 0444 | ( $mode & 0111 ? 0111 : 0 );
                $mode = $mode | 0222
                    if $realtarget ne $targetfile;
                _chmod( $mode, $targetfile, $verbose );
                $result->{install}{$targetfile} = $sourcefile;
                1
            } or do {
                $result->{install_fail}{$targetfile} = $sourcefile;
                die $@@;
            };
        } else {
            $result->{install_unchanged}{$targetfile} = $sourcefile;
            print "Skipping $targetfile (unchanged)\n" if $verbose;
        }

        if ( $uninstall_shadows ) {
            inc_uninstall($sourcefile,$ffd, $verbose,
                          $dry_run,
                          $realtarget ne $targetfile ? $realtarget : "",
                          $result);
        }

        # Record the full pathname.
        $packlist->{$targetfile}++;
    }

    if ($pack{'write'}) {
        $dir = install_rooted_dir(dirname($pack{'write'}));
        _mkpath( $dir, 0, 0755, $verbose, $dry_run );
        print "Writing $pack{'write'}\n" if $verbose;
        $packlist->write(install_rooted_file($pack{'write'})) unless $dry_run;
    }

    _do_cleanup($verbose);
    return $result;
}

=begin _private

=item _do_cleanup

Standardize finish event for after another instruction has occured.
Handles converting $MUST_REBOOT to a die for instance.

=end _private

=cut

sub _do_cleanup {
    my ($verbose) = @@_;
    if ($MUST_REBOOT) {
        die _estr "Operation not completed! ",
            "You must reboot to complete the installation.",
            "Sorry.";
    } elsif (defined $MUST_REBOOT & $verbose) {
        warn _estr "Installation will be completed at the next reboot.\n",
             "However it is not necessary to reboot immediately.\n";
    }
}

=begin _undocumented

=item install_rooted_file( $file )

Returns $file, or catfile($INSTALL_ROOT,$file) if $INSTALL_ROOT
is defined.

=item install_rooted_dir( $dir )

Returns $dir, or catdir($INSTALL_ROOT,$dir) if $INSTALL_ROOT
is defined.

=end _undocumented

=cut


sub install_rooted_file {
    if (defined $INSTALL_ROOT) {
        File::Spec->catfile($INSTALL_ROOT, $_[0]);
    } else {
        $_[0];
    }
}


sub install_rooted_dir {
    if (defined $INSTALL_ROOT) {
        File::Spec->catdir($INSTALL_ROOT, $_[0]);
    } else {
        $_[0];
    }
}

=begin _undocumented

=item forceunlink( $file, $tryhard )

Tries to delete a file. If $tryhard is true then we will use whatever
devious tricks we can to delete the file. Currently this only applies to
Win32 in that it will try to use Win32API::File to schedule a delete at
reboot. A wrapper for _unlink_or_rename().

=end _undocumented

=cut


sub forceunlink {
    my ( $file, $tryhard )= @@_; #XXX OS-SPECIFIC
    _unlink_or_rename( $file, $tryhard, not("installing") );
}

=begin _undocumented

=item directory_not_empty( $dir )

Returns 1 if there is an .exists file somewhere in a directory tree.
Returns 0 if there is not.

=end _undocumented

=cut

sub directory_not_empty ($) {
  my($dir) = @@_;
  my $files = 0;
  find(sub {
           return if $_ eq ".exists";
           if (-f) {
             $File::Find::prune++;
             $files = 1;
           }
       }, $dir);
  return $files;
}

=pod

=item B<install_default> I<DISCOURAGED>

    install_default();
    install_default($fullext);

Calls install() with arguments to copy a module from blib/ to the
default site installation location.

$fullext is the name of the module converted to a directory
(ie. Foo::Bar would be Foo/Bar).  If $fullext is not specified, it
will attempt to read it from @@ARGV.

This is primarily useful for install scripts.

B<NOTE> This function is not really useful because of the hard-coded
install location with no way to control site vs core vs vendor
directories and the strange way in which the module name is given.
Consider its use discouraged.

=cut

sub install_default {
  @@_ < 2 or Carp::croak("install_default should be called with 0 or 1 argument");
  my $FULLEXT = @@_ ? shift : $ARGV[0];
  defined $FULLEXT or die "Do not know to where to write install log";
  my $INST_LIB = File::Spec->catdir($Curdir,"blib","lib");
  my $INST_ARCHLIB = File::Spec->catdir($Curdir,"blib","arch");
  my $INST_BIN = File::Spec->catdir($Curdir,'blib','bin');
  my $INST_SCRIPT = File::Spec->catdir($Curdir,'blib','script');
  my $INST_MAN1DIR = File::Spec->catdir($Curdir,'blib','man1');
  my $INST_MAN3DIR = File::Spec->catdir($Curdir,'blib','man3');

  my @@INST_HTML;
  if($Config{installhtmldir}) {
      my $INST_HTMLDIR = File::Spec->catdir($Curdir,'blib','html');
      @@INST_HTML = ($INST_HTMLDIR => $Config{installhtmldir});
  }

  install({
           read => "$Config{sitearchexp}/auto/$FULLEXT/.packlist",
           write => "$Config{installsitearch}/auto/$FULLEXT/.packlist",
           $INST_LIB => (directory_not_empty($INST_ARCHLIB)) ?
                         $Config{installsitearch} :
                         $Config{installsitelib},
           $INST_ARCHLIB => $Config{installsitearch},
           $INST_BIN => $Config{installbin} ,
           $INST_SCRIPT => $Config{installscript},
           $INST_MAN1DIR => $Config{installman1dir},
           $INST_MAN3DIR => $Config{installman3dir},
       @@INST_HTML,
          },1,0,0);
}


=item B<uninstall>

    uninstall($packlist_file);
    uninstall($packlist_file, $verbose, $dont_execute);

Removes the files listed in a $packlist_file.

If $verbose is true, will print out each file removed.  Default is
false.

If $dont_execute is true it will only print what it was going to do
without actually doing it.  Default is false.

=cut

sub uninstall {
    my($fil,$verbose,$dry_run) = @@_;
    $verbose ||= 0;
    $dry_run  ||= 0;

    die _estr "ERROR: no packlist file found: '$fil'"
        unless -f $fil;
    # my $my_req = $self->catfile(qw(auto ExtUtils Install forceunlink.al));
    # require $my_req; # Hairy, but for the first
    my ($packlist) = ExtUtils::Packlist->new($fil);
    foreach (sort(keys(%$packlist))) {
        chomp;
        print "unlink $_\n" if $verbose;
        forceunlink($_,'tryhard') unless $dry_run;
    }
    print "unlink $fil\n" if $verbose;
    forceunlink($fil, 'tryhard') unless $dry_run;
    _do_cleanup($verbose);
}

=begin _undocumented

=item inc_uninstall($filepath,$libdir,$verbose,$dry_run,$ignore,$results)

Remove shadowed files. If $ignore is true then it is assumed to hold
a filename to ignore. This is used to prevent spurious warnings from
occuring when doing an install at reboot.

We now only die when failing to remove a file that has precedence over
our own, when our install has precedence we only warn.

$results is assumed to contain a hashref which will have the keys
'uninstall' and 'uninstall_fail' populated with  keys for the files
removed and values of the source files they would shadow.

=end _undocumented

=cut

sub inc_uninstall {
    my($filepath,$libdir,$verbose,$dry_run,$ignore,$results) = @@_;
    my($dir);
    $ignore||="";
    my $file = (File::Spec->splitpath($filepath))[2];
    my %seen_dir = ();

    my @@PERL_ENV_LIB = split $Config{path_sep}, defined $ENV{'PERL5LIB'}
      ? $ENV{'PERL5LIB'} : $ENV{'PERLLIB'} || '';

    my @@dirs=( @@PERL_ENV_LIB,
               @@INC,
               @@Config{qw(archlibexp
                          privlibexp
                          sitearchexp
                          sitelibexp)});

    #warn join "\n","---",@@dirs,"---";
    my $seen_ours;
    foreach $dir ( @@dirs ) {
        my $canonpath = $Is_VMS ? $dir : File::Spec->canonpath($dir);
        next if $canonpath eq $Curdir;
        next if $seen_dir{$canonpath}++;
        my $targetfile = File::Spec->catfile($canonpath,$libdir,$file);
        next unless -f $targetfile;

        # The reason why we compare file's contents is, that we cannot
        # know, which is the file we just installed (AFS). So we leave
        # an identical file in place
        my $diff = 0;
        if ( -f $targetfile && -s _ == -s $filepath) {
            # We have a good chance, we can skip this one
            $diff = compare($filepath,$targetfile);
        } else {
            $diff++;
        }
        print "#$file and $targetfile differ\n" if $diff && $verbose > 1;

        if (!$diff or $targetfile eq $ignore) {
            $seen_ours = 1;
            next;
        }
        if ($dry_run) {
            $results->{uninstall}{$targetfile} = $filepath;
            if ($verbose) {
                $Inc_uninstall_warn_handler ||= ExtUtils::Install::Warn->new();
                $libdir =~ s|^\./||s ; # That's just cosmetics, no need to port. It looks prettier.
                $Inc_uninstall_warn_handler->add(
                                     File::Spec->catfile($libdir, $file),
                                     $targetfile
                                    );
            }
            # if not verbose, we just say nothing
        } else {
            print "Unlinking $targetfile (shadowing?)\n" if $verbose;
            eval {
                die "Fake die for testing"
                    if $ExtUtils::Install::Testing and
                       ucase(File::Spec->canonpath($ExtUtils::Install::Testing)) eq ucase($targetfile);
                forceunlink($targetfile,'tryhard');
                $results->{uninstall}{$targetfile} = $filepath;
                1;
            } or do {
                $results->{fail_uninstall}{$targetfile} = $filepath;
                if ($seen_ours) {
                    warn "Failed to remove probably harmless shadow file '$targetfile'\n";
                } else {
                    die "$@@\n";
                }
            };
        }
    }
}

=begin _undocumented

=item run_filter($cmd,$src,$dest)

Filter $src using $cmd into $dest.

=end _undocumented

=cut

sub run_filter {
    my ($cmd, $src, $dest) = @@_;
    local(*CMD, *SRC);
    open(CMD, "|$cmd >$dest") || die "Cannot fork: $!";
    open(SRC, $src)           || die "Cannot open $src: $!";
    my $buf;
    my $sz = 1024;
    while (my $len = sysread(SRC, $buf, $sz)) {
        syswrite(CMD, $buf, $len);
    }
    close SRC;
    close CMD or die "Filter command '$cmd' failed for $src";
}

=pod

=item B<pm_to_blib>

    pm_to_blib(\%from_to, $autosplit_dir);
    pm_to_blib(\%from_to, $autosplit_dir, $filter_cmd);

Copies each key of %from_to to its corresponding value efficiently.
Filenames with the extension .pm are autosplit into the $autosplit_dir.
Any destination directories are created.

$filter_cmd is an optional shell command to run each .pm file through
prior to splitting and copying.  Input is the contents of the module,
output the new module contents.

You can have an environment variable PERL_INSTALL_ROOT set which will
be prepended as a directory to each installed file (and directory).

=cut

sub pm_to_blib {
    my($fromto,$autodir,$pm_filter) = @@_;

    _mkpath($autodir,0,0755);
    while(my($from, $to) = each %$fromto) {
        if( -f $to && -s $from == -s $to && -M $to < -M $from ) {
            print "Skip $to (unchanged)\n";
            next;
        }

        # When a pm_filter is defined, we need to pre-process the source first
        # to determine whether it has changed or not.  Therefore, only perform
        # the comparison check when there's no filter to be ran.
        #    -- RAM, 03/01/2001

        my $need_filtering = defined $pm_filter && length $pm_filter &&
                             $from =~ /\.pm$/;

        if (!$need_filtering && 0 == compare($from,$to)) {
            print "Skip $to (unchanged)\n";
            next;
        }
        if (-f $to){
            # we wont try hard here. its too likely to mess things up.
            forceunlink($to);
        } else {
            _mkpath(dirname($to),0,0755);
        }
        if ($need_filtering) {
            run_filter($pm_filter, $from, $to);
            print "$pm_filter <$from >$to\n";
        } else {
            _copy( $from, $to );
            print "cp $from $to\n";
        }
        my($mode,$atime,$mtime) = (stat $from)[2,8,9];
        utime($atime,$mtime+$Is_VMS,$to);
        _chmod(0444 | ( $mode & 0111 ? 0111 : 0 ),$to);
        next unless $from =~ /\.pm$/;
        _autosplit($to,$autodir);
    }
}


=begin _private

=item _autosplit

From 1.0307 back, AutoSplit will sometimes leave an open filehandle to
the file being split.  This causes problems on systems with mandatory
locking (ie. Windows).  So we wrap it and close the filehandle.

=end _private

=cut

sub _autosplit { #XXX OS-SPECIFIC
    my $retval = autosplit(@@_);
    close *AutoSplit::IN if defined *AutoSplit::IN{IO};

    return $retval;
}


package ExtUtils::Install::Warn;

sub new { bless {}, shift }

sub add {
    my($self,$file,$targetfile) = @@_;
    push @@{$self->{$file}}, $targetfile;
}

sub DESTROY {
    unless(defined $INSTALL_ROOT) {
        my $self = shift;
        my($file,$i,$plural);
        foreach $file (sort keys %$self) {
            $plural = @@{$self->{$file}} > 1 ? "s" : "";
            print "## Differing version$plural of $file found. You might like to\n";
            for (0..$#{$self->{$file}}) {
                print "rm ", $self->{$file}[$_], "\n";
                $i++;
            }
        }
        $plural = $i>1 ? "all those files" : "this file";
        my $inst = (_invokant() eq 'ExtUtils::MakeMaker')
                 ? ( $Config::Config{make} || 'make' ).' install'
                     . ( $Is_VMS ? '/MACRO="UNINST"=1' : ' UNINST=1' )
                 : './Build install uninst=1';
        print "## Running '$inst' will unlink $plural for you.\n";
    }
}

=begin _private

=item _invokant

Does a heuristic on the stack to see who called us for more intelligent
error messages. Currently assumes we will be called only by Module::Build
or by ExtUtils::MakeMaker.

=end _private

=cut

sub _invokant {
    my @@stack;
    my $frame = 0;
    while (my $file = (caller($frame++))[1]) {
        push @@stack, (File::Spec->splitpath($file))[2];
    }

    my $builder;
    my $top = pop @@stack;
    if ($top =~ /^Build/i || exists($INC{'Module/Build.pm'})) {
        $builder = 'Module::Build';
    } else {
        $builder = 'ExtUtils::MakeMaker';
    }
    return $builder;
}

=pod

=back

=head1 ENVIRONMENT

=over 4

=item B<PERL_INSTALL_ROOT>

Will be prepended to each install path.

=item B<EU_INSTALL_IGNORE_SKIP>

Will prevent the automatic use of INSTALL.SKIP as the install skip file.

=item B<EU_INSTALL_SITE_SKIPFILE>

If there is no INSTALL.SKIP file in the make directory then this value
can be used to provide a default.

=item B<EU_INSTALL_ALWAYS_COPY>

If this environment variable is true then normal install processes will
always overwrite older identical files during the install process.

Note that the alias EU_ALWAYS_COPY will be supported if EU_INSTALL_ALWAYS_COPY
is not defined until at least the 1.50 release. Please ensure you use the
correct EU_INSTALL_ALWAYS_COPY.

=back

=head1 AUTHOR

Original author lost in the mists of time.  Probably the same as Makemaker.

Production release currently maintained by demerphq C<yves at cpan.org>,
extensive changes by Michael G. Schwern.

Send bug reports via http://rt.cpan.org/.  Please send your
generated Makefile along with your report.

=head1 LICENSE

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

See L<http://www.perl.com/perl/misc/Artistic.html>


=cut

1;
@


1.10
log
@Merge in perl 5.10.1
@
text
@@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a1 1
use 5.00503;
a4 2
$VERSION = '1.44';
$VERSION = eval $VERSION;
d23 2
d39 11
d95 1
d101 22
d161 1
a161 1
        print "chmod($mode, $item)\n" if $verbose > 1;
d164 2
a165 1
        _warnonce "WARNING: Failed chmod($mode, $item): $err\n"
d275 3
a277 2
    unlink $file
        and return $file;
d310 1
a313 49
=over 4

=item B<install>

    install(\%from_to);
    install(\%from_to, $verbose, $dont_execute, $uninstall_shadows, $skip);

Copies each directory tree of %from_to to its corresponding value
preserving timestamps and permissions.

There are two keys with a special meaning in the hash: "read" and
"write".  These contain packlist files.  After the copying is done,
install() will write the list of target files to $from_to{write}. If
$from_to{read} is given the contents of this file will be merged into
the written file. The read and the written file may be identical, but
on AFS it is quite likely that people are installing to a different
directory than the one where the files later appear.

If $verbose is true, will print out each file removed.  Default is
false.  This is "make install VERBINST=1". $verbose values going
up to 5 show increasingly more diagnostics output.

If $dont_execute is true it will only print what it was going to do
without actually doing it.  Default is false.

If $uninstall_shadows is true any differing versions throughout @@INC
will be uninstalled.  This is "make install UNINST=1"

As of 1.37_02 install() supports the use of a list of patterns to filter
out files that shouldn't be installed. If $skip is omitted or undefined
then install will try to read the list from INSTALL.SKIP in the CWD.
This file is a list of regular expressions and is just like the
MANIFEST.SKIP file used by L<ExtUtils::Manifest>.

A default site INSTALL.SKIP may be provided by setting then environment
variable EU_INSTALL_SITE_SKIPFILE, this will only be used when there
isn't a distribution specific INSTALL.SKIP. If the environment variable
EU_INSTALL_IGNORE_SKIP is true then no install file filtering will be
performed.

If $skip is undefined then the skip file will be autodetected and used if it
is found. If $skip is a reference to an array then it is assumed
the array contains the list of patterns, if $skip is a true non reference it is
assumed to be the filename holding the list of patterns, any other value of
$skip is taken to mean that no install filtering should occur.


=cut

d373 2
a380 1

d385 3
a387 2
        if (!defined $has_posix) {
            $has_posix=eval "local $^W; require POSIX; 1" || 0;
d397 1
d424 1
a424 1
    my ($vol, $dirs, $file) = File::Spec->splitpath(File::Spec->rel2abs($dir),1);
d426 3
d432 10
a441 1
        $dir = File::Spec->catdir($vol,@@dirs);
d458 3
a460 1
=item _mkpath($dir,$show,$mode,$verbose,$fake)
d467 1
a467 1
If $fake is true then the directory will not be created but a check will be
d471 1
a471 1
If $fake is not true dies if the directory can not be created or is not
d477 1
a477 1
    my ($dir,$show,$mode,$verbose,$fake)=@@_;
d482 1
a482 1
    if (!$fake) {
d495 1
a495 1
        if ($fake) {
d500 1
a500 1
    } elsif ($show and $fake) {
d503 1
d506 3
a508 1
=item _copy($from,$to,$verbose,$fake)
d514 1
a514 1
If $fake is true then the copy will not actually occur.
d522 1
a522 1
    my ( $from, $to, $verbose, $nonono)=@@_;
d526 1
a526 1
    if (!$nonono) {
d532 2
d555 2
d559 114
d676 14
a689 1
    my($from_to,$verbose,$nonono,$inc_uninstall,$skip) = @@_;
d691 1
a691 1
    $nonono  ||= 0;
d694 4
d713 1
a713 1
    
d759 1
d765 1
a765 1
            my $save_cwd = _chdir($cwd); 
d767 5
a771 2
            if ( -f $targetfile && -s _ == $size) {
                # We have a good chance, we can skip this one
a772 2
            } else {
                $diff++;
d774 1
a774 1
            $check_dirs{$targetdir}++ 
d776 1
a776 1
            
d781 2
a782 2
                  
                ];  
d785 2
a786 2
            _chdir($save_cwd);                
        }, $current_directory ); 
d788 1
a788 2
    }   
    
d790 1
a790 1
        _mkpath( $targetdir, 0, 0755, $verbose, $nonono );
d795 1
a795 1
        
d798 11
a808 12
            if (-f $targetfile) {
                print "_unlink_or_rename($targetfile)\n" if $verbose>1;
                $targetfile= _unlink_or_rename( $targetfile, 'tryhard', 'install' )
                    unless $nonono;
            } elsif ( ! -d $targetdir ) {
                _mkpath( $targetdir, 0, 0755, $verbose, $nonono );
            }
            print "Installing $targetfile\n";
            _copy( $sourcefile, $targetfile, $verbose, $nonono, );
            #XXX OS-SPECIFIC
            print "utime($atime,$mtime,$targetfile)\n" if $verbose>1;
            utime($atime,$mtime + $Is_VMS,$targetfile) unless $nonono>1;
d811 15
a825 4
            $mode = 0444 | ( $mode & 0111 ? 0111 : 0 );
            $mode = $mode | 0222
                if $realtarget ne $targetfile;
            _chmod( $mode, $targetfile, $verbose );
d827 1
d831 1
a831 1
        if ( $inc_uninstall ) {
d833 3
a835 2
                          $nonono,
                          $realtarget ne $targetfile ? $realtarget : "");
d844 3
a846 3
        _mkpath( $dir, 0, 0755, $verbose, $nonono );
        print "Writing $pack{'write'}\n";
        $packlist->write(install_rooted_file($pack{'write'})) unless $nonono;
d850 1
d926 1
a926 1
    _unlink_or_rename( $file, $tryhard );
d953 1
d986 7
d1004 1
d1025 1
a1025 1
    my($fil,$verbose,$nonono) = @@_;
d1027 1
a1027 1
    $nonono  ||= 0;
d1037 1
a1037 1
        forceunlink($_,'tryhard') unless $nonono;
d1040 1
a1040 1
    forceunlink($fil, 'tryhard') unless $nonono;
d1046 1
a1046 1
=item inc_uninstall($filepath,$libdir,$verbose,$nonono,$ignore)
d1052 7
d1064 1
a1064 1
    my($filepath,$libdir,$verbose,$nonono,$ignore) = @@_;
d1073 11
a1083 5
    foreach $dir (@@INC, @@PERL_ENV_LIB, @@Config{qw(archlibexp
                                                  privlibexp
                                                  sitearchexp
                                                  sitelibexp)}) {
        my $canonpath = File::Spec->canonpath($dir);
d1101 6
a1106 2
        next if !$diff or $targetfile eq $ignore;
        if ($nonono) {
d1118 15
a1132 1
            forceunlink($targetfile,'tryhard');
d1161 1
d1268 2
a1269 1
                 ? ( $Config::Config{make} || 'make' ).' install UNINST=1'
d1304 1
d1325 9
d1340 2
a1341 1
Production release currently maintained by demerphq C<yves at cpan.org>
@


1.8
log
@merge in perl 5.8.8
@
text
@d2 2
d5 3
a7 3
use 5.00503;
use vars qw(@@ISA @@EXPORT $VERSION);
$VERSION = '1.33';
d9 1
a9 1
use Exporter;
d12 11
a24 13
$Is_VMS     = $^O eq 'VMS';
$Is_MacPerl = $^O eq 'MacOS';

my $Inc_uninstall_warn_handler;

# install relative to here

my $INSTALL_ROOT = $ENV{PERL_INSTALL_ROOT};

use File::Spec;
my $Curdir = File::Spec->curdir;
my $Updir  = File::Spec->updir;

a39 1

d49 227
d283 1
a283 1
    install(\%from_to, $verbose, $dont_execute, $uninstall_shadows);
d297 2
a298 1
false.  This is "make install VERBINST=1"
d306 19
d327 225
a551 2
sub install {
    my($from_to,$verbose,$nonono,$inc_uninstall) = @@_;
d555 1
a555 7
    use Cwd qw(cwd);
    use ExtUtils::Packlist;
    use File::Basename qw(dirname);
    use File::Copy qw(copy);
    use File::Find qw(find);
    use File::Path qw(mkpath);
    use File::Compare qw(compare);
d558 1
a558 1
    my(%pack, $dir, $warn_permissions);
d560 1
a560 2
    # -w doesn't work reliably on FAT dirs
    $warn_permissions++ if $^O eq 'MSWin32';
d563 2
a564 19
	$pack{$_}=$from_to{$_};
	delete $from_to{$_};
    }
    my($source_dir_or_file);
    foreach $source_dir_or_file (sort keys %from_to) {
	#Check if there are files, and if yes, look if the corresponding
	#target directory is writable for us
	opendir DIR, $source_dir_or_file or next;
	for (readdir DIR) {
	    next if $_ eq $Curdir || $_ eq $Updir || $_ eq ".exists";
            my $targetdir = install_rooted_dir($from_to{$source_dir_or_file});
            mkpath($targetdir) unless $nonono;
	    if (!$nonono && !-w $targetdir) {
		warn "Warning: You do not have permissions to " .
		    "install into $from_to{$source_dir_or_file}"
		    unless $warn_permissions++;
	    }
	}
	closedir DIR;
d569 3
a571 1

d573 9
a581 9
	#copy the tree to the target directory without altering
	#timestamp and permission and remember for the .packlist
	#file. The packlist file contains the absolute paths of the
	#install locations. AFS users may call this a bug. We'll have
	#to reconsider how to add the means to satisfy AFS users also.

	#October 1997: we want to install .pm files into archlib if
	#there are any files in arch. So we depend on having ./blib/arch
	#hardcoded here.
d583 1
a583 1
	my $targetroot = install_rooted_dir($from_to{$source});
d587 5
a591 4
	if ($source eq $blib_lib and
	    exists $from_to{$blib_arch} and
	    directory_not_empty($blib_arch)) {
	    $targetroot = install_rooted_dir($from_to{$blib_arch});
d593 1
a593 1
	}
d595 8
a602 4
        chdir $source or next;
	find(sub {
	    my ($mode,$size,$atime,$mtime) = (stat)[2,7,8,9];
	    return unless -f _;
d604 1
d606 4
a609 3
	    return if $origfile eq ".exists";
	    my $targetdir  = File::Spec->catdir($targetroot, $File::Find::dir);
	    my $targetfile = File::Spec->catfile($targetdir, $origfile);
d613 55
a667 35
            my $save_cwd = cwd;
            chdir $cwd;  # in case the target is relative
                         # 5.5.3's File::Find missing no_chdir option.

	    my $diff = 0;
	    if ( -f $targetfile && -s _ == $size) {
		# We have a good chance, we can skip this one
		$diff = compare($sourcefile, $targetfile);
	    } else {
		print "$sourcefile differs\n" if $verbose>1;
		$diff++;
	    }

	    if ($diff){
		if (-f $targetfile){
		    forceunlink($targetfile) unless $nonono;
		} else {
		    mkpath($targetdir,0,0755) unless $nonono;
		    print "mkpath($targetdir,0,0755)\n" if $verbose>1;
		}
		copy($sourcefile, $targetfile) unless $nonono;
		print "Installing $targetfile\n";
		utime($atime,$mtime + $Is_VMS,$targetfile) unless $nonono>1;
		print "utime($atime,$mtime,$targetfile)\n" if $verbose>1;
		$mode = 0444 | ( $mode & 0111 ? 0111 : 0 );
		chmod $mode, $targetfile;
		print "chmod($mode, $targetfile)\n" if $verbose>1;
	    } else {
		print "Skipping $targetfile (unchanged)\n" if $verbose;
	    }

	    if (defined $inc_uninstall) {
		inc_uninstall($sourcefile,$File::Find::dir,$verbose, 
                              $inc_uninstall ? 0 : 1);
	    }
d669 7
a675 2
	    # Record the full pathname.
	    $packlist->{$targetfile}++;
d677 5
a681 2
            # File::Find can get confused if you chdir in here.
            chdir $save_cwd;
d683 2
a684 3
        # File::Find seems to always be Unixy except on MacPerl :(
	}, $Is_MacPerl ? $Curdir : '.' );
	chdir($cwd) or Carp::croak("Couldn't chdir to $cwd: $!");
d686 1
d688 29
a716 4
	$dir = install_rooted_dir(dirname($pack{'write'}));
	mkpath($dir,0,0755) unless $nonono;
	print "Writing $pack{'write'}\n";
	$packlist->write(install_rooted_file($pack{'write'})) unless $nonono;
d720 17
d739 1
a739 1
	File::Spec->catfile($INSTALL_ROOT, $_[0]);
d741 1
a741 1
	$_[0];
d748 1
a748 1
	File::Spec->catdir($INSTALL_ROOT, $_[0]);
d750 1
a750 1
	$_[0];
d754 13
d769 2
a770 2
    chmod 0666, $_[0];
    unlink $_[0] or Carp::croak("Cannot forceunlink $_[0]: $!")
d773 10
d788 5
a792 5
	   return if $_ eq ".exists";
	   if (-f) {
	     $File::Find::prune++;
	     $files = 1;
	   }
d820 1
a820 1
  @@_ < 2 or die "install_default should be called with 0 or 1 argument";
d830 11
a840 11
	   read => "$Config{sitearchexp}/auto/$FULLEXT/.packlist",
	   write => "$Config{installsitearch}/auto/$FULLEXT/.packlist",
	   $INST_LIB => (directory_not_empty($INST_ARCHLIB)) ?
			 $Config{installsitearch} :
			 $Config{installsitelib},
	   $INST_ARCHLIB => $Config{installsitearch},
	   $INST_BIN => $Config{installbin} ,
	   $INST_SCRIPT => $Config{installscript},
	   $INST_MAN1DIR => $Config{installman1dir},
	   $INST_MAN3DIR => $Config{installman3dir},
	  },1,0,0);
a859 1
    use ExtUtils::Packlist;
d864 2
a865 1
    die "no packlist file found: $fil" unless -f $fil;
d870 3
a872 3
	chomp;
	print "unlink $_\n" if $verbose;
	forceunlink($_) unless $nonono;
d875 2
a876 1
    forceunlink($fil) unless $nonono;
d879 12
d892 1
a892 1
    my($filepath,$libdir,$verbose,$nonono) = @@_;
d894 1
d898 1
a898 1
    my @@PERL_ENV_LIB = split $Config{path_sep}, defined $ENV{'PERL5LIB'} 
d902 27
a928 26
						  privlibexp
						  sitearchexp
						  sitelibexp)}) {
	next if $dir eq $Curdir;
	next if $seen_dir{$dir}++;
	my($targetfile) = File::Spec->catfile($dir,$libdir,$file);
	next unless -f $targetfile;

	# The reason why we compare file's contents is, that we cannot
	# know, which is the file we just installed (AFS). So we leave
	# an identical file in place
	my $diff = 0;
	if ( -f $targetfile && -s _ == -s $filepath) {
	    # We have a good chance, we can skip this one
	    $diff = compare($filepath,$targetfile);
	} else {
	    print "#$file and $targetfile differ\n" if $verbose>1;
	    $diff++;
	}

	next unless $diff;
	if ($nonono) {
	    if ($verbose) {
		$Inc_uninstall_warn_handler ||= new ExtUtils::Install::Warn;
		$libdir =~ s|^\./||s ; # That's just cosmetics, no need to port. It looks prettier.
		$Inc_uninstall_warn_handler->add(
d932 6
a937 6
	    }
	    # if not verbose, we just say nothing
	} else {
	    print "Unlinking $targetfile (shadowing?)\n";
	    forceunlink($targetfile);
	}
d941 10
d959 1
a959 1
	syswrite(CMD, $buf, $len);
d987 1
a987 7
    use File::Basename qw(dirname);
    use File::Copy qw(copy);
    use File::Path qw(mkpath);
    use File::Compare qw(compare);
    use AutoSplit;

    mkpath($autodir,0,0755);
d989 1
a989 1
	if( -f $to && -s $from == -s $to && -M $to < -M $from ) {
d994 4
a997 4
	# When a pm_filter is defined, we need to pre-process the source first
	# to determine whether it has changed or not.  Therefore, only perform
	# the comparison check when there's no filter to be ran.
	#    -- RAM, 03/01/2001
d999 1
a999 1
	my $need_filtering = defined $pm_filter && length $pm_filter && 
d1002 22
a1023 21
	if (!$need_filtering && 0 == compare($from,$to)) {
	    print "Skip $to (unchanged)\n";
	    next;
	}
	if (-f $to){
	    forceunlink($to);
	} else {
	    mkpath(dirname($to),0,0755);
	}
	if ($need_filtering) {
	    run_filter($pm_filter, $from, $to);
	    print "$pm_filter <$from >$to\n";
	} else {
	    copy($from,$to);
	    print "cp $from $to\n";
	}
	my($mode,$atime,$mtime) = (stat $from)[2,8,9];
	utime($atime,$mtime+$Is_VMS,$to);
	chmod(0444 | ( $mode & 0111 ? 0111 : 0 ),$to);
	next unless $from =~ /\.pm$/;
	_autosplit($to,$autodir);
d1040 1
a1040 1
sub _autosplit {
d1070 4
a1073 1
        print "## Running 'make install UNINST=1' will unlink $plural for you.\n";
d1077 30
a1108 1

d1117 9
d1132 1
a1132 3
Currently maintained by Michael G Schwern C<schwern@@pobox.com>

Send patches and ideas to C<makemaker@@perl.org>.
a1136 3
For more up-to-date information, see L<http://www.makemaker.org>.


d1139 1
a1139 1
This program is free software; you can redistribute it and/or 
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d5 1
a5 1
$VERSION = 1.32;
d276 6
a281 6
  my $INST_LIB = File::Spec->catdir(File::Spec->curdir,"blib","lib");
  my $INST_ARCHLIB = File::Spec->catdir(File::Spec->curdir,"blib","arch");
  my $INST_BIN = File::Spec->catdir(File::Spec->curdir,'blib','bin');
  my $INST_SCRIPT = File::Spec->catdir(File::Spec->curdir,'blib','script');
  my $INST_MAN1DIR = File::Spec->catdir(File::Spec->curdir,'blib','man1');
  my $INST_MAN3DIR = File::Spec->catdir(File::Spec->curdir,'blib','man3');
d401 1
a419 13
    # my $my_req = $self->catfile(qw(auto ExtUtils Install forceunlink.al));
    # require $my_req; # Hairy, but for the first

    if (!ref($fromto) && -r $fromto)
     {
      # Win32 has severe command line length limitations, but
      # can generate temporary files on-the-fly
      # so we pass name of file here - eval it to get hash 
      open(FROMTO,"<$fromto") or die "Cannot open $fromto:$!";
      my $str = '$fromto = {qw{'.join('',<FROMTO>).'}}';
      eval $str;
      close(FROMTO);
     }
d524 1
a524 1
Currently maintained by Michael G Schwern <F<schwern@@pobox.com>>
d526 1
a526 1
Send patches and ideas to <F<makemaker@@perl.org>>.
d531 1
a531 1
For more up-to-date information, see http://www.makemaker.org.
d539 1
a539 1
See F<http://www.perl.com/perl/misc/Artistic.html>
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d5 1
a5 1
$VERSION = 1.29;
d12 2
a13 1
$Is_VMS = $^O eq 'VMS';
a14 2
my $splitchar = $^O eq 'VMS' ? '|' : ($^O eq 'os2' || $^O eq 'dos') ? ';' : ':';
my @@PERL_ENV_LIB = split $splitchar, defined $ENV{'PERL5LIB'} ? $ENV{'PERL5LIB'} : $ENV{'PERLLIB'} || '';
d22 2
a24 7
sub install_rooted_file {
    if (defined $INSTALL_ROOT) {
	File::Spec->catfile($INSTALL_ROOT, $_[0]);
    } else {
	$_[0];
    }
}
d26 49
a74 7
sub install_rooted_dir {
    if (defined $INSTALL_ROOT) {
	File::Spec->catdir($INSTALL_ROOT, $_[0]);
    } else {
	$_[0];
    }
}
d76 2
a77 2
#our(@@EXPORT, @@ISA, $Is_VMS);
#use strict;
d79 1
a79 4
sub forceunlink {
    chmod 0666, $_[0];
    unlink $_[0] or Carp::croak("Cannot forceunlink $_[0]: $!")
}
d82 1
a82 1
    my($hash,$verbose,$nonono,$inc_uninstall) = @@_;
a92 1
    use File::Spec;
d94 1
a94 1
    my(%hash) = %$hash;
d101 2
a102 2
	$pack{$_}=$hash{$_};
	delete $hash{$_};
d105 1
a105 1
    foreach $source_dir_or_file (sort keys %hash) {
d110 4
a113 6
	    next if $_ eq "." || $_ eq ".." || $_ eq ".exists";
		my $targetdir = install_rooted_dir($hash{$source_dir_or_file});
	    if (-w $targetdir ||
		mkpath($targetdir)) {
		last;
	    } else {
d115 1
a115 1
		    "install into $hash{$source_dir_or_file}"
d125 1
a125 2
    my($source);
    MOD_INSTALL: foreach $source (sort keys %hash) {
d136 1
a136 1
	my $targetroot = install_rooted_dir($hash{$source});
d138 7
a144 5
	if ($source eq "blib/lib" and
	    exists $hash{"blib/arch"} and
	    directory_not_empty("blib/arch")) {
	    $targetroot = install_rooted_dir($hash{"blib/arch"});
            print "Files found in blib/arch: installing files in blib/lib into architecture dependent library tree\n";
d146 2
a147 1
	chdir($source) or next;
d149 1
a149 2
	    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
                         $atime,$mtime,$ctime,$blksize,$blocks) = stat;
d151 3
a153 1
	    return if $_ eq ".exists";
d155 7
a161 1
	    my $targetfile = File::Spec->catfile($targetdir, $_);
d166 1
a166 1
		$diff = compare($_,$targetfile);
d168 1
a168 1
		print "$_ differs\n" if $verbose>1;
d179 1
a179 1
		copy($_,$targetfile) unless $nonono;
d189 4
a192 6
	    
	    if (! defined $inc_uninstall) { # it's called 
	    } elsif ($inc_uninstall == 0){
		inc_uninstall($_,$File::Find::dir,$verbose,1); # nonono set to 1
	    } else {
		inc_uninstall($_,$File::Find::dir,$verbose,0); # nonono set to 0
d194 1
d198 5
a202 1
	}, ".");
d207 1
a207 1
	mkpath($dir,0,0755);
d209 1
a209 1
	$packlist->write(install_rooted_file($pack{'write'}));
d213 24
d250 22
d296 16
d315 3
d332 1
a332 1
    my($file,$libdir,$verbose,$nonono) = @@_;
d334 1
d336 4
d344 1
a344 1
	next if $dir eq ".";
d353 1
a353 1
	if ( -f $targetfile && -s _ == -s $file) {
d355 1
a355 1
	    $diff = compare($file,$targetfile);
d366 4
a369 1
		$Inc_uninstall_warn_handler->add("$libdir/$file",$targetfile);
d381 1
d393 18
d434 5
a438 3
    foreach (keys %$fromto) {
	my $dest = $fromto->{$_};
	next if -f $dest && -M $dest < -M $_;
d445 2
a446 1
	my $need_filtering = defined $pm_filter && length $pm_filter && /\.pm$/;
d448 2
a449 2
	if (!$need_filtering && 0 == compare($_,$dest)) {
	    print "Skip $dest (unchanged)\n";
d452 2
a453 2
	if (-f $dest){
	    forceunlink($dest);
d455 1
a455 1
	    mkpath(dirname($dest),0,0755);
d458 2
a459 2
	    run_filter($pm_filter, $_, $dest);
	    print "$pm_filter <$_ >$dest\n";
d461 2
a462 2
	    copy($_,$dest);
	    print "cp $_ $dest\n";
d464 5
a468 5
	my($mode,$atime,$mtime) = (stat)[2,8,9];
	utime($atime,$mtime+$Is_VMS,$dest);
	chmod(0444 | ( $mode & 0111 ? 0111 : 0 ),$dest);
	next unless /\.pm$/;
	autosplit($dest,$autodir);
d472 21
d503 14
a516 14
	unless(defined $INSTALL_ROOT) {
		my $self = shift;
		my($file,$i,$plural);
		foreach $file (sort keys %$self) {
		$plural = @@{$self->{$file}} > 1 ? "s" : "";
		print "## Differing version$plural of $file found. You might like to\n";
		for (0..$#{$self->{$file}}) {
			print "rm ", $self->{$file}[$_], "\n";
			$i++;
		}
		}
		$plural = $i>1 ? "all those files" : "this file";
		print "## Running 'make install UNINST=1' will unlink $plural for you.\n";
	}
d519 8
a526 1
1;
d528 1
a528 1
__END__
d530 1
a530 1
=head1 NAME
d532 1
a532 1
ExtUtils::Install - install files from here to there
d534 1
a534 1
=head1 SYNOPSIS
d536 1
a536 1
B<use ExtUtils::Install;>
d538 1
a538 1
B<install($hashref,$verbose,$nonono);>
d540 2
a541 1
B<uninstall($packlistfile,$verbose,$nonono);>
d543 1
a543 1
B<pm_to_blib($hashref);>
a544 1
=head1 DESCRIPTION
d546 1
a546 3
Both install() and uninstall() are specific to the way
ExtUtils::MakeMaker handles the installation and deinstallation of
perl modules. They are not designed as general purpose tools.
d548 2
a549 6
install() takes three arguments. A reference to a hash, a verbose
switch and a don't-really-do-it switch. The hash ref contains a
mapping of directories: each key/value pair is a combination of
directories to be copied. Key is a directory to copy from, value is a
directory to copy to. The whole tree below the "from" directory will
be copied preserving timestamps and permissions.
d551 1
a551 32
There are two keys with a special meaning in the hash: "read" and
"write". After the copying is done, install will write the list of
target files to the file named by C<$hashref-E<gt>{write}>. If there is
another file named by C<$hashref-E<gt>{read}>, the contents of this file will
be merged into the written file. The read and the written file may be
identical, but on AFS it is quite likely that people are installing to a
different directory than the one where the files later appear.

install_default() takes one or less arguments.  If no arguments are 
specified, it takes $ARGV[0] as if it was specified as an argument.  
The argument is the value of MakeMaker's C<FULLEXT> key, like F<Tk/Canvas>.  
This function calls install() with the same arguments as the defaults 
the MakeMaker would use.

The argument-less form is convenient for install scripts like

  perl -MExtUtils::Install -e install_default Tk/Canvas

Assuming this command is executed in a directory with a populated F<blib> 
directory, it will proceed as if the F<blib> was build by MakeMaker on 
this machine.  This is useful for binary distributions.

uninstall() takes as first argument a file containing filenames to be
unlinked. The second argument is a verbose switch, the third is a
no-don't-really-do-it-now switch.

pm_to_blib() takes a hashref as the first argument and copies all keys
of the hash to the corresponding values efficiently. Filenames with
the extension pm are autosplit. Second argument is the autosplit
directory.  If third argument is not empty, it is taken as a filter command
to be ran on each .pm file, the output of the command being what is finally
copied, and the source for auto-splitting.
a552 2
You can have an environment variable PERL_INSTALL_ROOT set which will
be prepended as a directory to each installed file (and directory).
d555 2
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 3
a5 4
use 5.005_64;
our(@@ISA, @@EXPORT, $VERSION);
$VERSION = substr q$Revision: 1.28 $, 10;
# $Date: 1998/01/25 07:08:24 $
d26 1
a26 1
	MY->catfile($INSTALL_ROOT, $_[0]);
d34 1
a34 1
	MY->catdir($INSTALL_ROOT, $_[0]);
a53 1
    use ExtUtils::MakeMaker; # to implement a MY class
d60 1
d121 2
a122 3
	    my $targetdir  = MY->catdir($targetroot, $File::Find::dir);
	    my $origfile   = $_;
	    my $targetfile = MY->catfile($targetdir, $_);
d157 2
a158 1
	    $packlist->{$origfile}++;
d188 6
a193 6
  my $INST_LIB = MM->catdir(MM->curdir,"blib","lib");
  my $INST_ARCHLIB = MM->catdir(MM->curdir,"blib","arch");
  my $INST_BIN = MM->catdir(MM->curdir,'blib','bin');
  my $INST_SCRIPT = MM->catdir(MM->curdir,'blib','script');
  my $INST_MAN1DIR = MM->catdir(MM->curdir,'blib','man1');
  my $INST_MAN3DIR = MM->catdir(MM->curdir,'blib','man3');
d234 1
a234 1
	my($targetfile) = MY->catfile($dir,$libdir,$file);
a265 1
    local *SRC, *CMD;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d19 22
d80 3
a82 2
	    if (-w $hash{$source_dir_or_file} ||
		mkpath($hash{$source_dir_or_file})) {
d92 2
a93 1
    $packlist->read($pack{"read"}) if (-f $pack{"read"});
d107 3
a109 1
	my $targetroot = $hash{$source};
d113 1
a113 1
	    $targetroot = $hash{"blib/arch"};
d122 3
a124 2
	    my $targetdir = MY->catdir($targetroot,$File::Find::dir);
	    my $targetfile = MY->catfile($targetdir,$_);
d159 1
a159 1
	    $packlist->{$targetfile}++;
d165 1
a165 1
	$dir = dirname($pack{'write'});
d168 1
a168 1
	$packlist->write($pack{'write'});
d265 14
d280 1
a280 1
    my($fromto,$autodir) = @@_;
d303 12
a314 3
	next if -f $fromto->{$_} && -M $fromto->{$_} < -M $_;
	unless (compare($_,$fromto->{$_})){
	    print "Skip $fromto->{$_} (unchanged)\n";
d317 2
a318 2
	if (-f $fromto->{$_}){
	    forceunlink($fromto->{$_});
d320 8
a327 1
	    mkpath(dirname($fromto->{$_}),0,0755);
a328 1
	copy($_,$fromto->{$_});
d330 4
a333 5
	utime($atime,$mtime+$Is_VMS,$fromto->{$_});
	chmod(0444 | ( $mode & 0111 ? 0111 : 0 ),$fromto->{$_});
	print "cp $_ $fromto->{$_}\n";
	next unless /\.pm\z/;
	autosplit($fromto->{$_},$autodir);
d347 13
a359 8
    my $self = shift;
    my($file,$i,$plural);
    foreach $file (sort keys %$self) {
	$plural = @@{$self->{$file}} > 1 ? "s" : "";
	print "## Differing version$plural of $file found. You might like to\n";
	for (0..$#{$self->{$file}}) {
	    print "rm ", $self->{$file}[$_], "\n";
	    $i++;
a360 3
    }
    $plural = $i>1 ? "all those files" : "this file";
    print "## Running 'make install UNINST=1' will unlink $plural for you.\n";
d423 6
a428 1
directory.
@


1.3
log
@perl5.005_03 (stock)
@
text
@d3 2
a10 1
use vars qw(@@ISA @@EXPORT $VERSION);
d19 1
a19 1
#use vars qw( @@EXPORT @@ISA $Is_VMS );
a70 1
    my $umask = umask 0 unless $Is_VMS;
d88 1
a88 3
            print "Files found in blib/arch --> Installing files in " 
	        . "blib/lib into architecture dependend library tree!\n"
		; #if $verbose>1;
a136 1
    umask $umask unless $Is_VMS;
a194 1
    close P;
d227 1
a227 1
		$libdir =~ s|^\./|| ; # That's just cosmetics, no need to port. It looks prettier.
a259 1
    my $umask = umask 0022 unless $Is_VMS;
d277 1
a277 1
	next unless /\.pm$/;
a279 1
    umask $umask unless $Is_VMS;
d342 1
a342 1
identical, but on AFS it is quite likely, people are installing to a
d355 1
a355 1
Assuming this command is executed in a directory with populated F<blib> 
@


1.2
log
@perl 5.004_04
@
text
@d3 2
a4 2
$VERSION = substr q$Revision: 1.19 $, 10;
# $Date: 1997/08/01 08:39:37 $
d14 1
a14 1
my $splitchar = $^O eq 'VMS' ? '|' : $^O eq 'os2' ? ';' : ':';
d33 1
d41 2
a42 1
    my(%pack, %write, $dir, $warn_permissions);
d45 1
a45 1
    local(*DIR, *P);
d57 2
a58 1
	    if (-w $hash{$source_dir_or_file} || mkpath($hash{$source_dir_or_file})) {
d61 2
a62 1
		warn "Warning: You do not have permissions to install into $hash{$source_dir_or_file}"
d68 1
a68 9
    if (-f $pack{"read"}) {
	open P, $pack{"read"} or Carp::croak("Couldn't read $pack{'read'}");
	# Remember what you found
	while (<P>) {
	    chomp;
	    $write{$_}++;
	}
	close P;
    }
a71 5
    # This silly reference is just here to be able to call MY->catdir
    # without a warning (Waiting for a proper path/directory module,
    # Charles!)
    my $MY = {};
    bless $MY, 'MY';
d79 13
d98 2
a99 2
	    my $targetdir = $MY->catdir($hash{$source},$File::Find::dir);
	    my $targetfile = $MY->catfile($targetdir,$_);
d134 1
a134 1
	    $write{$targetfile}++;
d144 1
a144 5
	open P, ">$pack{'write'}" or Carp::croak("Couldn't write $pack{'write'}: $!");
	for (sort keys %write) {
	    print P "$_\n";
	}
	close P;
d148 13
d174 3
a176 1
	   $INST_LIB => $Config{installsitelib},
d186 1
d191 2
a192 3
    local *P;
    open P, $fil or Carp::croak("uninstall: Could not read packlist file $fil: $!");
    while (<P>) {
d198 1
a204 2
    my $MY = {};
    bless $MY, 'MY';
d206 4
a209 1
    foreach $dir (@@INC, @@PERL_ENV_LIB, @@Config{qw/archlibexp privlibexp sitearchexp sitelibexp/}) {
d212 1
a212 1
	my($targetfile) = $MY->catfile($dir,$libdir,$file);
d357 1
a357 1
The argumement-less form is convenient for install scripts like
@


1.1
log
@Initial revision
@
text
@d3 2
a4 2
$VERSION = substr q$Revision: 1.12 $, 10;
# $Id: Install.pm,v 1.12 1996/06/23 20:46:07 k Exp $
d8 1
a8 1
use Config ();
d11 1
a11 1
@@EXPORT = ('install','uninstall','pm_to_blib');
d15 1
a15 1
my @@PERL_ENV_LIB = split $splitchar, defined $ENV{'PERL5LIB'} ? $ENV{'PERL5LIB'} : $ENV{'PERLLIB'};
d37 1
a37 7
    # The following lines were needed with AutoLoader (left for the record)
    # my $my_req = $self->catfile(qw(auto ExtUtils Install my_cmp.al));
    # require $my_req;
    # $my_req = $self->catfile(qw(auto ExtUtils Install forceunlink.al));
    # require $my_req; # Hairy, but for the first
    # time use we are in a different directory when autoload happens, so
    # the relativ path to ./blib is ill.
d40 3
a42 1
    my(%pack, %write, $dir);
d58 2
a59 1
		Carp::croak("You do not have permissions to install into $hash{$source_dir_or_file}");
d100 1
a100 1
		$diff = my_cmp($_,$targetfile);
d148 20
a167 24
sub my_cmp {
    my($one,$two) = @@_;
    local(*F,*T);
    my $diff = 0;
    open T, $two or return 1;
    open F, $one or Carp::croak("Couldn't open $one: $!");
    my($fr, $tr, $fbuf, $tbuf, $size);
    $size = 1024;
    # print "Reading $one\n";
    while ( $fr = read(F,$fbuf,$size)) {
	unless (
		$tr = read(T,$tbuf,$size) and 
		$tbuf eq $fbuf
	       ){
	    # print "diff ";
	    $diff++;
	    last;
	}
	# print "$fr/$tr ";
    }
    # print "\n";
    close F;
    close T;
    $diff;
d192 1
a192 1
    foreach $dir (@@INC, @@PERL_ENV_LIB, @@Config::Config{qw/archlibexp privlibexp sitearchexp sitelibexp/}) {
d204 1
a204 1
	    $diff = my_cmp($file,$targetfile);
d231 1
d236 11
d251 1
a251 1
	unless (my_cmp($_,$fromto->{$_})){
d261 3
a263 1
	chmod(0444 | ( (stat)[2] & 0111 ? 0111 : 0 ),$fromto->{$_});
d328 2
a329 2
target files to the file named by $hashref->{write}. If there is
another file named by $hashref->{read}, the contents of this file will
d334 14
a357 1

@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d3 2
a4 2
$VERSION = substr q$Revision: 1.28 $, 10;
# $Date: 1998/01/25 07:08:24 $
d8 1
a8 1
use Config qw(%Config);
d11 1
a11 1
@@EXPORT = ('install','uninstall','pm_to_blib', 'install_default');
d14 2
a15 2
my $splitchar = $^O eq 'VMS' ? '|' : ($^O eq 'os2' || $^O eq 'dos') ? ';' : ':';
my @@PERL_ENV_LIB = split $splitchar, defined $ENV{'PERL5LIB'} ? $ENV{'PERL5LIB'} : $ENV{'PERLLIB'} || '';
a32 1
    use ExtUtils::Packlist;
d37 7
a43 1
    use File::Compare qw(compare);
d46 2
a47 5
    my(%pack, $dir, $warn_permissions);
    my($packlist) = ExtUtils::Packlist->new();
    # -w doesn't work reliably on FAT dirs
    $warn_permissions++ if $^O eq 'MSWin32';
    local(*DIR);
d59 1
a59 2
	    if (-w $hash{$source_dir_or_file} ||
		mkpath($hash{$source_dir_or_file})) {
d62 1
a62 3
		warn "Warning: You do not have permissions to " .
		    "install into $hash{$source_dir_or_file}"
		    unless $warn_permissions++;
d67 9
a75 1
    $packlist->read($pack{"read"}) if (-f $pack{"read"});
d79 5
a90 13

	#October 1997: we want to install .pm files into archlib if
	#there are any files in arch. So we depend on having ./blib/arch
	#hardcoded here.
	my $targetroot = $hash{$source};
	if ($source eq "blib/lib" and
	    exists $hash{"blib/arch"} and
	    directory_not_empty("blib/arch")) {
	    $targetroot = $hash{"blib/arch"};
            print "Files found in blib/arch --> Installing files in " 
	        . "blib/lib into architecture dependend library tree!\n"
		; #if $verbose>1;
	}
d97 2
a98 2
	    my $targetdir = MY->catdir($targetroot,$File::Find::dir);
	    my $targetfile = MY->catfile($targetdir,$_);
d103 1
a103 1
		$diff = compare($_,$targetfile);
d133 1
a133 1
	    $packlist->{$targetfile}++;
d143 5
a147 1
	$packlist->write($pack{'write'});
d151 24
a174 35
sub directory_not_empty ($) {
  my($dir) = @@_;
  my $files = 0;
  find(sub {
	   return if $_ eq ".exists";
	   if (-f) {
	     $File::Find::prune++;
	     $files = 1;
	   }
       }, $dir);
  return $files;
}

sub install_default {
  @@_ < 2 or die "install_default should be called with 0 or 1 argument";
  my $FULLEXT = @@_ ? shift : $ARGV[0];
  defined $FULLEXT or die "Do not know to where to write install log";
  my $INST_LIB = MM->catdir(MM->curdir,"blib","lib");
  my $INST_ARCHLIB = MM->catdir(MM->curdir,"blib","arch");
  my $INST_BIN = MM->catdir(MM->curdir,'blib','bin');
  my $INST_SCRIPT = MM->catdir(MM->curdir,'blib','script');
  my $INST_MAN1DIR = MM->catdir(MM->curdir,'blib','man1');
  my $INST_MAN3DIR = MM->catdir(MM->curdir,'blib','man3');
  install({
	   read => "$Config{sitearchexp}/auto/$FULLEXT/.packlist",
	   write => "$Config{installsitearch}/auto/$FULLEXT/.packlist",
	   $INST_LIB => (directory_not_empty($INST_ARCHLIB)) ?
			 $Config{installsitearch} :
			 $Config{installsitelib},
	   $INST_ARCHLIB => $Config{installsitearch},
	   $INST_BIN => $Config{installbin} ,
	   $INST_SCRIPT => $Config{installscript},
	   $INST_MAN1DIR => $Config{installman1dir},
	   $INST_MAN3DIR => $Config{installman3dir},
	  },1,0,0);
a177 1
    use ExtUtils::Packlist;
d182 3
a184 2
    my ($packlist) = ExtUtils::Packlist->new($fil);
    foreach (sort(keys(%$packlist))) {
a189 1
    close P;
d196 2
d199 1
a199 4
    foreach $dir (@@INC, @@PERL_ENV_LIB, @@Config{qw(archlibexp
						  privlibexp
						  sitearchexp
						  sitelibexp)}) {
d202 1
a202 1
	my($targetfile) = MY->catfile($dir,$libdir,$file);
d211 1
a211 1
	    $diff = compare($file,$targetfile);
a237 1
    use File::Compare qw(compare);
a241 11
    if (!ref($fromto) && -r $fromto)
     {
      # Win32 has severe command line length limitations, but
      # can generate temporary files on-the-fly
      # so we pass name of file here - eval it to get hash 
      open(FROMTO,"<$fromto") or die "Cannot open $fromto:$!";
      my $str = '$fromto = {qw{'.join('',<FROMTO>).'}}';
      eval $str;
      close(FROMTO);
     }

d246 1
a246 1
	unless (compare($_,$fromto->{$_})){
d256 1
a256 3
	my($mode,$atime,$mtime) = (stat)[2,8,9];
	utime($atime,$mtime+$Is_VMS,$fromto->{$_});
	chmod(0444 | ( $mode & 0111 ? 0111 : 0 ),$fromto->{$_});
d321 2
a322 2
target files to the file named by C<$hashref-E<gt>{write}>. If there is
another file named by C<$hashref-E<gt>{read}>, the contents of this file will
a326 14
install_default() takes one or less arguments.  If no arguments are 
specified, it takes $ARGV[0] as if it was specified as an argument.  
The argument is the value of MakeMaker's C<FULLEXT> key, like F<Tk/Canvas>.  
This function calls install() with the same arguments as the defaults 
the MakeMaker would use.

The argument-less form is convenient for install scripts like

  perl -MExtUtils::Install -e install_default Tk/Canvas

Assuming this command is executed in a directory with populated F<blib> 
directory, it will proceed as if the F<blib> was build by MakeMaker on 
this machine.  This is useful for binary distributions.

d337 1
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a2 2
use 5.005_64;
our(@@ISA, @@EXPORT, $VERSION);
d9 1
d18 1
a18 1
#our(@@EXPORT, @@ISA, $Is_VMS);
d70 1
d88 3
a90 1
            print "Files found in blib/arch: installing files in blib/lib into architecture dependent library tree\n";
d139 1
d198 1
d231 1
a231 1
		$libdir =~ s|^\./||s ; # That's just cosmetics, no need to port. It looks prettier.
d264 1
d282 1
a282 1
	next unless /\.pm\z/;
d285 1
d348 1
a348 1
identical, but on AFS it is quite likely that people are installing to a
d361 1
a361 1
Assuming this command is executed in a directory with a populated F<blib> 
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a18 22
# install relative to here

my $INSTALL_ROOT = $ENV{PERL_INSTALL_ROOT};

use File::Spec;

sub install_rooted_file {
    if (defined $INSTALL_ROOT) {
	MY->catfile($INSTALL_ROOT, $_[0]);
    } else {
	$_[0];
    }
}

sub install_rooted_dir {
    if (defined $INSTALL_ROOT) {
	MY->catdir($INSTALL_ROOT, $_[0]);
    } else {
	$_[0];
    }
}

d58 2
a59 3
		my $targetdir = install_rooted_dir($hash{$source_dir_or_file});
	    if (-w $targetdir ||
		mkpath($targetdir)) {
d69 1
a69 2
    my $tmpfile = install_rooted_file($pack{"read"});
    $packlist->read($tmpfile) if (-f $tmpfile);
d83 1
a83 3

	my $targetroot = install_rooted_dir($hash{$source});

d87 1
a87 1
	    $targetroot = install_rooted_dir($hash{"blib/arch"});
d96 2
a97 3
	    my $targetdir  = MY->catdir($targetroot, $File::Find::dir);
	    my $origfile   = $_;
	    my $targetfile = MY->catfile($targetdir, $_);
d132 1
a132 1
	    $packlist->{$origfile}++;
d138 1
a138 1
	$dir = install_rooted_dir(dirname($pack{'write'}));
d141 1
a141 1
	$packlist->write(install_rooted_file($pack{'write'}));
a237 14
sub run_filter {
    my ($cmd, $src, $dest) = @@_;
    local *SRC, *CMD;
    open(CMD, "|$cmd >$dest") || die "Cannot fork: $!";
    open(SRC, $src)           || die "Cannot open $src: $!";
    my $buf;
    my $sz = 1024;
    while (my $len = sysread(SRC, $buf, $sz)) {
	syswrite(CMD, $buf, $len);
    }
    close SRC;
    close CMD or die "Filter command '$cmd' failed for $src";
}

d239 1
a239 1
    my($fromto,$autodir,$pm_filter) = @@_;
d262 3
a264 12
	my $dest = $fromto->{$_};
	next if -f $dest && -M $dest < -M $_;

	# When a pm_filter is defined, we need to pre-process the source first
	# to determine whether it has changed or not.  Therefore, only perform
	# the comparison check when there's no filter to be ran.
	#    -- RAM, 03/01/2001

	my $need_filtering = defined $pm_filter && length $pm_filter && /\.pm$/;

	if (!$need_filtering && 0 == compare($_,$dest)) {
	    print "Skip $dest (unchanged)\n";
d267 2
a268 2
	if (-f $dest){
	    forceunlink($dest);
d270 1
a270 8
	    mkpath(dirname($dest),0,0755);
	}
	if ($need_filtering) {
	    run_filter($pm_filter, $_, $dest);
	    print "$pm_filter <$_ >$dest\n";
	} else {
	    copy($_,$dest);
	    print "cp $_ $dest\n";
d272 1
d274 5
a278 4
	utime($atime,$mtime+$Is_VMS,$dest);
	chmod(0444 | ( $mode & 0111 ? 0111 : 0 ),$dest);
	next unless /\.pm$/;
	autosplit($dest,$autodir);
d292 8
a299 13
	unless(defined $INSTALL_ROOT) {
		my $self = shift;
		my($file,$i,$plural);
		foreach $file (sort keys %$self) {
		$plural = @@{$self->{$file}} > 1 ? "s" : "";
		print "## Differing version$plural of $file found. You might like to\n";
		for (0..$#{$self->{$file}}) {
			print "rm ", $self->{$file}[$_], "\n";
			$i++;
		}
		}
		$plural = $i>1 ? "all those files" : "this file";
		print "## Running 'make install UNINST=1' will unlink $plural for you.\n";
d301 3
d366 1
a366 6
directory.  If third argument is not empty, it is taken as a filter command
to be ran on each .pm file, the output of the command being what is finally
copied, and the source for auto-splitting.

You can have an environment variable PERL_INSTALL_ROOT set which will
be prepended as a directory to each installed file (and directory).
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 4
a6 3
use 5.00503;
use vars qw(@@ISA @@EXPORT $VERSION);
$VERSION = 1.29;
d27 1
a27 1
	File::Spec->catfile($INSTALL_ROOT, $_[0]);
d35 1
a35 1
	File::Spec->catdir($INSTALL_ROOT, $_[0]);
d55 1
a61 1
    use File::Spec;
d122 3
a124 2
	    my $targetdir  = File::Spec->catdir($targetroot, $File::Find::dir);
	    my $targetfile = File::Spec->catfile($targetdir, $_);
d159 1
a159 2
	    # Record the full pathname.
	    $packlist->{$targetfile}++;
d189 6
a194 6
  my $INST_LIB = File::Spec->catdir(File::Spec->curdir,"blib","lib");
  my $INST_ARCHLIB = File::Spec->catdir(File::Spec->curdir,"blib","arch");
  my $INST_BIN = File::Spec->catdir(File::Spec->curdir,'blib','bin');
  my $INST_SCRIPT = File::Spec->catdir(File::Spec->curdir,'blib','script');
  my $INST_MAN1DIR = File::Spec->catdir(File::Spec->curdir,'blib','man1');
  my $INST_MAN3DIR = File::Spec->catdir(File::Spec->curdir,'blib','man3');
d235 1
a235 1
	my($targetfile) = File::Spec->catfile($dir,$libdir,$file);
d267 1
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d5 1
a5 1
$VERSION = 1.32;
d12 1
a12 2
$Is_VMS     = $^O eq 'VMS';
$Is_MacPerl = $^O eq 'MacOS';
d14 2
a22 2
my $Curdir = File::Spec->curdir;
my $Updir  = File::Spec->updir;
d24 7
d32 7
a38 1
=head1 NAME
d40 2
a41 1
ExtUtils::Install - install files from here to there
d43 4
a46 50
=head1 SYNOPSIS

  use ExtUtils::Install;

  install({ 'blib/lib' => 'some/install/dir' } );

  uninstall($packlist);

  pm_to_blib({ 'lib/Foo/Bar.pm' => 'blib/lib/Foo/Bar.pm' });


=head1 DESCRIPTION

Handles the installing and uninstalling of perl modules, scripts, man
pages, etc...

Both install() and uninstall() are specific to the way
ExtUtils::MakeMaker handles the installation and deinstallation of
perl modules. They are not designed as general purpose tools.

=head2 Functions

=over 4

=item B<install>

    install(\%from_to);
    install(\%from_to, $verbose, $dont_execute, $uninstall_shadows);

Copies each directory tree of %from_to to its corresponding value
preserving timestamps and permissions.

There are two keys with a special meaning in the hash: "read" and
"write".  These contain packlist files.  After the copying is done,
install() will write the list of target files to $from_to{write}. If
$from_to{read} is given the contents of this file will be merged into
the written file. The read and the written file may be identical, but
on AFS it is quite likely that people are installing to a different
directory than the one where the files later appear.

If $verbose is true, will print out each file removed.  Default is
false.  This is "make install VERBINST=1"

If $dont_execute is true it will only print what it was going to do
without actually doing it.  Default is false.

If $uninstall_shadows is true any differing versions throughout @@INC
will be uninstalled.  This is "make install UNINST=1"

=cut
d49 1
a49 1
    my($from_to,$verbose,$nonono,$inc_uninstall) = @@_;
d60 1
d62 1
a62 1
    my(%from_to) = %$from_to;
d69 2
a70 2
	$pack{$_}=$from_to{$_};
	delete $from_to{$_};
d73 1
a73 1
    foreach $source_dir_or_file (sort keys %from_to) {
d78 6
a83 4
	    next if $_ eq $Curdir || $_ eq $Updir || $_ eq ".exists";
            my $targetdir = install_rooted_dir($from_to{$source_dir_or_file});
            mkpath($targetdir) unless $nonono;
	    if (!$nonono && !-w $targetdir) {
d85 1
a85 1
		    "install into $from_to{$source_dir_or_file}"
d95 2
a96 1
    MOD_INSTALL: foreach my $source (sort keys %from_to) {
d107 1
a107 1
	my $targetroot = install_rooted_dir($from_to{$source});
d109 5
a113 7
        my $blib_lib  = File::Spec->catdir('blib', 'lib');
        my $blib_arch = File::Spec->catdir('blib', 'arch');
	if ($source eq $blib_lib and
	    exists $from_to{$blib_arch} and
	    directory_not_empty($blib_arch)) {
	    $targetroot = install_rooted_dir($from_to{$blib_arch});
            print "Files found in $blib_arch: installing files in $blib_lib into architecture dependent library tree\n";
d115 1
a115 2

        chdir $source or next;
d117 2
a118 1
	    my ($mode,$size,$atime,$mtime) = (stat)[2,7,8,9];
d120 1
a120 3

            my $origfile = $_;
	    return if $origfile eq ".exists";
d122 1
a122 7
	    my $targetfile = File::Spec->catfile($targetdir, $origfile);
            my $sourcedir  = File::Spec->catdir($source, $File::Find::dir);
            my $sourcefile = File::Spec->catfile($sourcedir, $origfile);

            my $save_cwd = cwd;
            chdir $cwd;  # in case the target is relative
                         # 5.5.3's File::Find missing no_chdir option.
d127 1
a127 1
		$diff = compare($sourcefile, $targetfile);
d129 1
a129 1
		print "$sourcefile differs\n" if $verbose>1;
d140 1
a140 1
		copy($sourcefile, $targetfile) unless $nonono;
d150 6
a155 4

	    if (defined $inc_uninstall) {
		inc_uninstall($sourcefile,$File::Find::dir,$verbose, 
                              $inc_uninstall ? 0 : 1);
a156 1

d160 1
a160 5
            # File::Find can get confused if you chdir in here.
            chdir $save_cwd;

        # File::Find seems to always be Unixy except on MacPerl :(
	}, $Is_MacPerl ? $Curdir : '.' );
d165 1
a165 1
	mkpath($dir,0,0755) unless $nonono;
d167 1
a167 1
	$packlist->write(install_rooted_file($pack{'write'})) unless $nonono;
a170 24
sub install_rooted_file {
    if (defined $INSTALL_ROOT) {
	File::Spec->catfile($INSTALL_ROOT, $_[0]);
    } else {
	$_[0];
    }
}


sub install_rooted_dir {
    if (defined $INSTALL_ROOT) {
	File::Spec->catdir($INSTALL_ROOT, $_[0]);
    } else {
	$_[0];
    }
}


sub forceunlink {
    chmod 0666, $_[0];
    unlink $_[0] or Carp::croak("Cannot forceunlink $_[0]: $!")
}


a183 22

=item B<install_default> I<DISCOURAGED>

    install_default();
    install_default($fullext);

Calls install() with arguments to copy a module from blib/ to the
default site installation location.

$fullext is the name of the module converted to a directory
(ie. Foo::Bar would be Foo/Bar).  If $fullext is not specified, it
will attempt to read it from @@ARGV.

This is primarily useful for install scripts.

B<NOTE> This function is not really useful because of the hard-coded
install location with no way to control site vs core vs vendor
directories and the strange way in which the module name is given.
Consider its use discouraged.

=cut

a207 16

=item B<uninstall>

    uninstall($packlist_file);
    uninstall($packlist_file, $verbose, $dont_execute);

Removes the files listed in a $packlist_file.

If $verbose is true, will print out each file removed.  Default is
false.

If $dont_execute is true it will only print what it was going to do
without actually doing it.  Default is false.

=cut

a210 3
    $verbose ||= 0;
    $nonono  ||= 0;

d225 1
a225 1
    my($filepath,$libdir,$verbose,$nonono) = @@_;
a226 1
    my $file = (File::Spec->splitpath($filepath))[2];
a227 4

    my @@PERL_ENV_LIB = split $Config{path_sep}, defined $ENV{'PERL5LIB'} 
      ? $ENV{'PERL5LIB'} : $ENV{'PERLLIB'} || '';

d232 1
a232 1
	next if $dir eq $Curdir;
d241 1
a241 1
	if ( -f $targetfile && -s _ == -s $filepath) {
d243 1
a243 1
	    $diff = compare($filepath,$targetfile);
d254 1
a254 4
		$Inc_uninstall_warn_handler->add(
                                     File::Spec->catfile($libdir, $file),
                                     $targetfile
                                    );
a265 1
    local(*CMD, *SRC);
a276 18

=item B<pm_to_blib>

    pm_to_blib(\%from_to, $autosplit_dir);
    pm_to_blib(\%from_to, $autosplit_dir, $filter_cmd);

Copies each key of %from_to to its corresponding value efficiently.
Filenames with the extension .pm are autosplit into the $autosplit_dir.

$filter_cmd is an optional shell command to run each .pm file through
prior to splitting and copying.  Input is the contents of the module,
output the new module contents.

You can have an environment variable PERL_INSTALL_ROOT set which will
be prepended as a directory to each installed file (and directory).

=cut

d300 3
a302 5
    while(my($from, $to) = each %$fromto) {
	if( -f $to && -s $from == -s $to && -M $to < -M $from ) {
            print "Skip $to (unchanged)\n";
            next;
        }
d309 1
a309 2
	my $need_filtering = defined $pm_filter && length $pm_filter && 
                             $from =~ /\.pm$/;
d311 2
a312 2
	if (!$need_filtering && 0 == compare($from,$to)) {
	    print "Skip $to (unchanged)\n";
d315 2
a316 2
	if (-f $to){
	    forceunlink($to);
d318 1
a318 1
	    mkpath(dirname($to),0,0755);
d321 2
a322 2
	    run_filter($pm_filter, $from, $to);
	    print "$pm_filter <$from >$to\n";
d324 2
a325 2
	    copy($from,$to);
	    print "cp $from $to\n";
d327 5
a331 5
	my($mode,$atime,$mtime) = (stat $from)[2,8,9];
	utime($atime,$mtime+$Is_VMS,$to);
	chmod(0444 | ( $mode & 0111 ? 0111 : 0 ),$to);
	next unless $from =~ /\.pm$/;
	_autosplit($to,$autodir);
a334 21

=begin _private

=item _autosplit

From 1.0307 back, AutoSplit will sometimes leave an open filehandle to
the file being split.  This causes problems on systems with mandatory
locking (ie. Windows).  So we wrap it and close the filehandle.

=end _private

=cut

sub _autosplit {
    my $retval = autosplit(@@_);
    close *AutoSplit::IN if defined *AutoSplit::IN{IO};

    return $retval;
}


d345 14
a358 14
    unless(defined $INSTALL_ROOT) {
        my $self = shift;
        my($file,$i,$plural);
        foreach $file (sort keys %$self) {
            $plural = @@{$self->{$file}} > 1 ? "s" : "";
            print "## Differing version$plural of $file found. You might like to\n";
            for (0..$#{$self->{$file}}) {
                print "rm ", $self->{$file}[$_], "\n";
                $i++;
            }
        }
        $plural = $i>1 ? "all those files" : "this file";
        print "## Running 'make install UNINST=1' will unlink $plural for you.\n";
    }
d361 1
a361 1
=back
d363 1
d365 1
a365 1
=head1 ENVIRONMENT
d367 1
a367 1
=over 4
d369 1
a369 1
=item B<PERL_INSTALL_ROOT>
d371 1
a371 1
Will be prepended to each install path.
d373 1
a373 1
=back
d375 1
a375 1
=head1 AUTHOR
d377 1
a377 1
Original author lost in the mists of time.  Probably the same as Makemaker.
d379 1
a379 1
Currently maintained by Michael G Schwern <F<schwern@@pobox.com>>
d381 3
a383 1
Send patches and ideas to <F<makemaker@@perl.org>>.
d385 6
a390 2
Send bug reports via http://rt.cpan.org/.  Please send your
generated Makefile along with your report.
d392 32
a423 9
For more up-to-date information, see http://www.makemaker.org.


=head1 LICENSE

This program is free software; you can redistribute it and/or 
modify it under the same terms as Perl itself.

See F<http://www.perl.com/perl/misc/Artistic.html>
d425 2
a428 2

1;
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d5 1
a5 1
$VERSION = '1.33';
d276 6
a281 6
  my $INST_LIB = File::Spec->catdir($Curdir,"blib","lib");
  my $INST_ARCHLIB = File::Spec->catdir($Curdir,"blib","arch");
  my $INST_BIN = File::Spec->catdir($Curdir,'blib','bin');
  my $INST_SCRIPT = File::Spec->catdir($Curdir,'blib','script');
  my $INST_MAN1DIR = File::Spec->catdir($Curdir,'blib','man1');
  my $INST_MAN3DIR = File::Spec->catdir($Curdir,'blib','man3');
a400 1
Any destination directories are created.
d419 13
d536 1
a536 1
Currently maintained by Michael G Schwern C<schwern@@pobox.com>
d538 1
a538 1
Send patches and ideas to C<makemaker@@perl.org>.
d543 1
a543 1
For more up-to-date information, see L<http://www.makemaker.org>.
d551 1
a551 1
See L<http://www.perl.com/perl/misc/Artistic.html>
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d2 1
d4 2
a5 1
use strict;
d7 1
a7 5
use vars qw(@@ISA @@EXPORT $VERSION $MUST_REBOOT %Config);
$VERSION = '1.44';
$VERSION = eval $VERSION;

use AutoSplit;
d10 11
a20 8
use Cwd qw(cwd);
use Exporter;
use ExtUtils::Packlist;
use File::Basename qw(dirname);
use File::Compare qw(compare);
use File::Copy;
use File::Find qw(find);
use File::Path;
d22 2
a25 3
@@ISA = ('Exporter');
@@EXPORT = ('install','uninstall','pm_to_blib', 'install_default');

d40 1
a49 227
On some operating systems such as Win32 installation may not be possible
until after a reboot has occured. This can have varying consequences:
removing an old DLL does not impact programs using the new one, but if
a new DLL cannot be installed properly until reboot then anything
depending on it must wait. The package variable

  $ExtUtils::Install::MUST_REBOOT

is used to store this status.

If this variable is true then such an operation has occured and
anything depending on this module cannot proceed until a reboot
has occured.

If this value is defined but false then such an operation has
ocurred, but should not impact later operations.

=begin _private

=item _chmod($$;$)

Wrapper to chmod() for debugging and error trapping.

=item _warnonce(@@)

Warns about something only once.

=item _choke(@@)

Dies with a special message.

=end _private

=cut

my $Is_VMS     = $^O eq 'VMS';
my $Is_MacPerl = $^O eq 'MacOS';
my $Is_Win32   = $^O eq 'MSWin32';
my $Is_cygwin  = $^O eq 'cygwin';
my $CanMoveAtBoot = ($Is_Win32 || $Is_cygwin);

# *note* CanMoveAtBoot is only incidentally the same condition as below
# this needs not hold true in the future.
my $Has_Win32API_File = ($Is_Win32 || $Is_cygwin)
    ? (eval {require Win32API::File; 1} || 0)
    : 0;


my $Inc_uninstall_warn_handler;

# install relative to here

my $INSTALL_ROOT = $ENV{PERL_INSTALL_ROOT};

my $Curdir = File::Spec->curdir;
my $Updir  = File::Spec->updir;

sub _estr(@@) {
    return join "\n",'!' x 72,@@_,'!' x 72,'';
}

{my %warned;
sub _warnonce(@@) {
    my $first=shift;
    my $msg=_estr "WARNING: $first",@@_;
    warn $msg unless $warned{$msg}++;
}}

sub _choke(@@) {
    my $first=shift;
    my $msg=_estr "ERROR: $first",@@_;
    Carp::croak($msg);
}


sub _chmod($$;$) {
    my ( $mode, $item, $verbose )=@@_;
    $verbose ||= 0;
    if (chmod $mode, $item) {
        print "chmod($mode, $item)\n" if $verbose > 1;
    } else {
        my $err="$!";
        _warnonce "WARNING: Failed chmod($mode, $item): $err\n"
            if -e $item;
    }
}

=begin _private

=item _move_file_at_boot( $file, $target, $moan  )

OS-Specific, Win32/Cygwin

Schedules a file to be moved/renamed/deleted at next boot.
$file should be a filespec of an existing file
$target should be a ref to an array if the file is to be deleted
otherwise it should be a filespec for a rename. If the file is existing
it will be replaced.

Sets $MUST_REBOOT to 0 to indicate a deletion operation has occured
and sets it to 1 to indicate that a move operation has been requested.

returns 1 on success, on failure if $moan is false errors are fatal.
If $moan is true then returns 0 on error and warns instead of dies.

=end _private

=cut



sub _move_file_at_boot { #XXX OS-SPECIFIC
    my ( $file, $target, $moan  )= @@_;
    Carp::confess("Panic: Can't _move_file_at_boot on this platform!")
         unless $CanMoveAtBoot;

    my $descr= ref $target
                ? "'$file' for deletion"
                : "'$file' for installation as '$target'";

    if ( ! $Has_Win32API_File ) {

        my @@msg=(
            "Cannot schedule $descr at reboot.",
            "Try installing Win32API::File to allow operations on locked files",
            "to be scheduled during reboot. Or try to perform the operation by",
            "hand yourself. (You may need to close other perl processes first)"
        );
        if ( $moan ) { _warnonce(@@msg) } else { _choke(@@msg) }
        return 0;
    }
    my $opts= Win32API::File::MOVEFILE_DELAY_UNTIL_REBOOT();
    $opts= $opts | Win32API::File::MOVEFILE_REPLACE_EXISTING()
        unless ref $target;

    _chmod( 0666, $file );
    _chmod( 0666, $target ) unless ref $target;

    if (Win32API::File::MoveFileEx( $file, $target, $opts )) {
        $MUST_REBOOT ||= ref $target ? 0 : 1;
        return 1;
    } else {
        my @@msg=(
            "MoveFileEx $descr at reboot failed: $^E",
            "You may try to perform the operation by hand yourself. ",
            "(You may need to close other perl processes first).",
        );
        if ( $moan ) { _warnonce(@@msg) } else { _choke(@@msg) }
    }
    return 0;
}


=begin _private

=item _unlink_or_rename( $file, $tryhard, $installing )

OS-Specific, Win32/Cygwin

Tries to get a file out of the way by unlinking it or renaming it. On
some OS'es (Win32 based) DLL files can end up locked such that they can
be renamed but not deleted. Likewise sometimes a file can be locked such
that it cant even be renamed or changed except at reboot. To handle
these cases this routine finds a tempfile name that it can either rename
the file out of the way or use as a proxy for the install so that the
rename can happen later (at reboot).

  $file : the file to remove.
  $tryhard : should advanced tricks be used for deletion
  $installing : we are not merely deleting but we want to overwrite

When $tryhard is not true if the unlink fails its fatal. When $tryhard
is true then the file is attempted to be renamed. The renamed file is
then scheduled for deletion. If the rename fails then $installing
governs what happens. If it is false the failure is fatal. If it is true
then an attempt is made to schedule installation at boot using a
temporary file to hold the new file. If this fails then a fatal error is
thrown, if it succeeds it returns the temporary file name (which will be
a derivative of the original in the same directory) so that the caller can
use it to install under. In all other cases of success returns $file.
On failure throws a fatal error.

=end _private

=cut



sub _unlink_or_rename { #XXX OS-SPECIFIC
    my ( $file, $tryhard, $installing )= @@_;

    _chmod( 0666, $file );
    unlink $file
        and return $file;
    my $error="$!";

    _choke("Cannot unlink '$file': $!")
          unless $CanMoveAtBoot && $tryhard;

    my $tmp= "AAA";
    ++$tmp while -e "$file.$tmp";
    $tmp= "$file.$tmp";

    warn "WARNING: Unable to unlink '$file': $error\n",
         "Going to try to rename it to '$tmp'.\n";

    if ( rename $file, $tmp ) {
        warn "Rename succesful. Scheduling '$tmp'\nfor deletion at reboot.\n";
        # when $installing we can set $moan to true.
        # IOW, if we cant delete the renamed file at reboot its
        # not the end of the world. The other cases are more serious
        # and need to be fatal.
        _move_file_at_boot( $tmp, [], $installing );
        return $file;
    } elsif ( $installing ) {
        _warnonce("Rename failed: $!. Scheduling '$tmp'\nfor".
             " installation as '$file' at reboot.\n");
        _move_file_at_boot( $tmp, $file );
        return $tmp;
    } else {
        _choke("Rename failed:$!", "Cannot procede.");
    }

}



d57 1
a57 1
    install(\%from_to, $verbose, $dont_execute, $uninstall_shadows, $skip);
d71 1
a71 2
false.  This is "make install VERBINST=1". $verbose values going
up to 5 show increasingly more diagnostics output.
a78 19
As of 1.37_02 install() supports the use of a list of patterns to filter
out files that shouldn't be installed. If $skip is omitted or undefined
then install will try to read the list from INSTALL.SKIP in the CWD.
This file is a list of regular expressions and is just like the
MANIFEST.SKIP file used by L<ExtUtils::Manifest>.

A default site INSTALL.SKIP may be provided by setting then environment
variable EU_INSTALL_SITE_SKIPFILE, this will only be used when there
isn't a distribution specific INSTALL.SKIP. If the environment variable
EU_INSTALL_IGNORE_SKIP is true then no install file filtering will be
performed.

If $skip is undefined then the skip file will be autodetected and used if it
is found. If $skip is a reference to an array then it is assumed
the array contains the list of patterns, if $skip is a true non reference it is
assumed to be the filename holding the list of patterns, any other value of
$skip is taken to mean that no install filtering should occur.


d81 2
a82 225
=begin _private

=item _get_install_skip

Handles loading the INSTALL.SKIP file. Returns an array of patterns to use.

=cut



sub _get_install_skip {
    my ( $skip, $verbose )= @@_;
    if ($ENV{EU_INSTALL_IGNORE_SKIP}) {
        print "EU_INSTALL_IGNORE_SKIP is set, ignore skipfile settings\n"
            if $verbose>2;
        return [];
    }
    if ( ! defined $skip ) {
        print "Looking for install skip list\n"
            if $verbose>2;
        for my $file ( 'INSTALL.SKIP', $ENV{EU_INSTALL_SITE_SKIPFILE} ) {
            next unless $file;
            print "\tChecking for $file\n"
                if $verbose>2;
            if (-e $file) {
                $skip= $file;
                last;
            }
        }
    }
    if ($skip && !ref $skip) {
        print "Reading skip patterns from '$skip'.\n"
            if $verbose;
        if (open my $fh,$skip ) {
            my @@patterns;
            while (<$fh>) {
                chomp;
                next if /^\s*(?:#|$)/;
                print "\tSkip pattern: $_\n" if $verbose>3;
                push @@patterns, $_;
            }
            $skip= \@@patterns;
        } else {
            warn "Can't read skip file:'$skip':$!\n";
            $skip=[];
        }
    } elsif ( UNIVERSAL::isa($skip,'ARRAY') ) {
        print "Using array for skip list\n"
            if $verbose>2;
    } elsif ($verbose) {
        print "No skip list found.\n"
            if $verbose>1;
        $skip= [];
    }
    warn "Got @@{[0+@@$skip]} skip patterns.\n"
        if $verbose>3;
    return $skip
}

=item _have_write_access

Abstract a -w check that tries to use POSIX::access() if possible.

=cut


{
    my  $has_posix;
    sub _have_write_access {
        my $dir=shift;
        if (!defined $has_posix) {
            $has_posix=eval "local $^W; require POSIX; 1" || 0;
        }
        if ($has_posix) {
            return POSIX::access($dir, POSIX::W_OK());
        } else {
            return -w $dir;
        }
    }
}


=item _can_write_dir(C<$dir>)

Checks whether a given directory is writable, taking account
the possibility that the directory might not exist and would have to
be created first.

Returns a list, containing: C<($writable, $determined_by, @@create)>

C<$writable> says whether whether the directory is (hypothetically) writable

C<$determined_by> is the directory the status was determined from. It will be
either the C<$dir>, or one of its parents.

C<@@create> is a list of directories that would probably have to be created
to make the requested directory. It may not actually be correct on
relative paths with C<..> in them. But for our purposes it should work ok

=cut


sub _can_write_dir {
    my $dir=shift;
    return
        unless defined $dir and length $dir;

    my ($vol, $dirs, $file) = File::Spec->splitpath(File::Spec->rel2abs($dir),1);
    my @@dirs = File::Spec->splitdir($dirs);
    my $path='';
    my @@make;
    while (@@dirs) {
        $dir = File::Spec->catdir($vol,@@dirs);
        next if ( $dir eq $path );
        if ( ! -e $dir ) {
            unshift @@make,$dir;
            next;
        }
        if ( _have_write_access($dir) ) {
            return 1,$dir,@@make
        } else {
            return 0,$dir,@@make
        }
    } continue {
        pop @@dirs;
    }
    return 0;
}

=item _mkpath($dir,$show,$mode,$verbose,$fake)

Wrapper around File::Path::mkpath() to handle errors.

If $verbose is true and >1 then additional diagnostics will be produced, also
this will force $show to true.

If $fake is true then the directory will not be created but a check will be
made to see whether it would be possible to write to the directory, or that
it would be possible to create the directory.

If $fake is not true dies if the directory can not be created or is not
writable.

=cut

sub _mkpath {
    my ($dir,$show,$mode,$verbose,$fake)=@@_;
    if ( $verbose && $verbose > 1 && ! -d $dir) {
        $show= 1;
        printf "mkpath(%s,%d,%#o)\n", $dir, $show, $mode;
    }
    if (!$fake) {
        if ( ! eval { File::Path::mkpath($dir,$show,$mode); 1 } ) {
            _choke("Can't create '$dir'","$@@");
        }

    }
    my ($can,$root,@@make)=_can_write_dir($dir);
    if (!$can) {
        my @@msg=(
            "Can't create '$dir'",
            $root ? "Do not have write permissions on '$root'"
                  : "Unknown Error"
        );
        if ($fake) {
            _warnonce @@msg;
        } else {
            _choke @@msg;
        }
    } elsif ($show and $fake) {
        print "$_\n" for @@make;
    }
}

=item _copy($from,$to,$verbose,$fake)

Wrapper around File::Copy::copy to handle errors.

If $verbose is true and >1 then additional dignostics will be emitted.

If $fake is true then the copy will not actually occur.

Dies if the copy fails.

=cut


sub _copy {
    my ( $from, $to, $verbose, $nonono)=@@_;
    if ($verbose && $verbose>1) {
        printf "copy(%s,%s)\n", $from, $to;
    }
    if (!$nonono) {
        File::Copy::copy($from,$to)
            or Carp::croak( _estr "ERROR: Cannot copy '$from' to '$to': $!" );
    }
}

=item _chdir($from)

Wrapper around chdir to catch errors.

If not called in void context returns the cwd from before the chdir.

dies on error.

=cut

sub _chdir {
    my ($dir)= @@_;
    my $ret;
    if (defined wantarray) {
        $ret= cwd;
    }
    chdir $dir
        or _choke("Couldn't chdir to '$dir': $!");
    return $ret;
}

=end _private

=cut

sub install { #XXX OS-SPECIFIC
    my($from_to,$verbose,$nonono,$inc_uninstall,$skip) = @@_;
d86 7
a92 1
    $skip= _get_install_skip($skip,$verbose);
d95 1
a95 1
    my(%pack, $dir, %warned);
d97 2
a98 1

d101 19
a119 2
        $pack{$_}=$from_to{$_};
        delete $from_to{$_};
d124 1
a124 3
    my @@found_files;
    my %check_dirs;
    
d126 9
a134 9
        #copy the tree to the target directory without altering
        #timestamp and permission and remember for the .packlist
        #file. The packlist file contains the absolute paths of the
        #install locations. AFS users may call this a bug. We'll have
        #to reconsider how to add the means to satisfy AFS users also.

        #October 1997: we want to install .pm files into archlib if
        #there are any files in arch. So we depend on having ./blib/arch
        #hardcoded here.
d136 1
a136 1
        my $targetroot = install_rooted_dir($from_to{$source});
d140 4
a143 5
        if ($source eq $blib_lib and
            exists $from_to{$blib_arch} and
            directory_not_empty($blib_arch)
        ){
            $targetroot = install_rooted_dir($from_to{$blib_arch});
d145 1
a145 1
        }
d147 4
a150 8
        next unless -d $source;
        _chdir($source);
        # 5.5.3's File::Find missing no_chdir option
        # XXX OS-SPECIFIC
        # File::Find seems to always be Unixy except on MacPerl :(
        my $current_directory= $Is_MacPerl ? $Curdir : '.';
        find(sub {
            my ($mode,$size,$atime,$mtime) = (stat)[2,7,8,9];
a151 1
            return if !-f _;
d153 3
a155 4

            return if $origfile eq ".exists";
            my $targetdir  = File::Spec->catdir($targetroot, $File::Find::dir);
            my $targetfile = File::Spec->catfile($targetdir, $origfile);
d159 35
a193 54
            for my $pat (@@$skip) {
                if ( $sourcefile=~/$pat/ ) {
                    print "Skipping $targetfile (filtered)\n"
                        if $verbose>1;
                    return;
                }
            }
            # we have to do this for back compat with old File::Finds
            # and because the target is relative
            my $save_cwd = _chdir($cwd); 
            my $diff = 0;
            if ( -f $targetfile && -s _ == $size) {
                # We have a good chance, we can skip this one
                $diff = compare($sourcefile, $targetfile);
            } else {
                $diff++;
            }
            $check_dirs{$targetdir}++ 
                unless -w $targetfile;
            
            push @@found_files,
                [ $diff, $File::Find::dir, $origfile,
                  $mode, $size, $atime, $mtime,
                  $targetdir, $targetfile, $sourcedir, $sourcefile,
                  
                ];  
            #restore the original directory we were in when File::Find
            #called us so that it doesnt get horribly confused.
            _chdir($save_cwd);                
        }, $current_directory ); 
        _chdir($cwd);
    }   
    
    foreach my $targetdir (sort keys %check_dirs) {
        _mkpath( $targetdir, 0, 0755, $verbose, $nonono );
    }
    foreach my $found (@@found_files) {
        my ($diff, $ffd, $origfile, $mode, $size, $atime, $mtime,
            $targetdir, $targetfile, $sourcedir, $sourcefile)= @@$found;
        
        my $realtarget= $targetfile;
        if ($diff) {
            if (-f $targetfile) {
                print "_unlink_or_rename($targetfile)\n" if $verbose>1;
                $targetfile= _unlink_or_rename( $targetfile, 'tryhard', 'install' )
                    unless $nonono;
            } elsif ( ! -d $targetdir ) {
                _mkpath( $targetdir, 0, 0755, $verbose, $nonono );
            }
            print "Installing $targetfile\n";
            _copy( $sourcefile, $targetfile, $verbose, $nonono, );
            #XXX OS-SPECIFIC
            print "utime($atime,$mtime,$targetfile)\n" if $verbose>1;
            utime($atime,$mtime + $Is_VMS,$targetfile) unless $nonono>1;
d195 2
d198 2
a199 7
            $mode = 0444 | ( $mode & 0111 ? 0111 : 0 );
            $mode = $mode | 0222
                if $realtarget ne $targetfile;
            _chmod( $mode, $targetfile, $verbose );
        } else {
            print "Skipping $targetfile (unchanged)\n" if $verbose;
        }
d201 3
a203 8
        if ( $inc_uninstall ) {
            inc_uninstall($sourcefile,$ffd, $verbose,
                          $nonono,
                          $realtarget ne $targetfile ? $realtarget : "");
        }

        # Record the full pathname.
        $packlist->{$targetfile}++;
a204 1

d206 4
a209 29
        $dir = install_rooted_dir(dirname($pack{'write'}));
        _mkpath( $dir, 0, 0755, $verbose, $nonono );
        print "Writing $pack{'write'}\n";
        $packlist->write(install_rooted_file($pack{'write'})) unless $nonono;
    }

    _do_cleanup($verbose);
}

=begin _private

=item _do_cleanup

Standardize finish event for after another instruction has occured.
Handles converting $MUST_REBOOT to a die for instance.

=end _private

=cut

sub _do_cleanup {
    my ($verbose) = @@_;
    if ($MUST_REBOOT) {
        die _estr "Operation not completed! ",
            "You must reboot to complete the installation.",
            "Sorry.";
    } elsif (defined $MUST_REBOOT & $verbose) {
        warn _estr "Installation will be completed at the next reboot.\n",
             "However it is not necessary to reboot immediately.\n";
a212 17
=begin _undocumented

=item install_rooted_file( $file )

Returns $file, or catfile($INSTALL_ROOT,$file) if $INSTALL_ROOT
is defined.

=item install_rooted_dir( $dir )

Returns $dir, or catdir($INSTALL_ROOT,$dir) if $INSTALL_ROOT
is defined.

=end _undocumented

=cut


d215 1
a215 1
        File::Spec->catfile($INSTALL_ROOT, $_[0]);
d217 1
a217 1
        $_[0];
d224 1
a224 1
        File::Spec->catdir($INSTALL_ROOT, $_[0]);
d226 1
a226 1
        $_[0];
a229 13
=begin _undocumented

=item forceunlink( $file, $tryhard )

Tries to delete a file. If $tryhard is true then we will use whatever
devious tricks we can to delete the file. Currently this only applies to
Win32 in that it will try to use Win32API::File to schedule a delete at
reboot. A wrapper for _unlink_or_rename().

=end _undocumented

=cut

d232 2
a233 2
    my ( $file, $tryhard )= @@_; #XXX OS-SPECIFIC
    _unlink_or_rename( $file, $tryhard );
a235 10
=begin _undocumented

=item directory_not_empty( $dir )

Returns 1 if there is an .exists file somewhere in a directory tree.
Returns 0 if there is not.

=end _undocumented

=cut
d241 5
a245 5
           return if $_ eq ".exists";
           if (-f) {
             $File::Find::prune++;
             $files = 1;
           }
d273 1
a273 1
  @@_ < 2 or Carp::croak("install_default should be called with 0 or 1 argument");
d283 11
a293 11
           read => "$Config{sitearchexp}/auto/$FULLEXT/.packlist",
           write => "$Config{installsitearch}/auto/$FULLEXT/.packlist",
           $INST_LIB => (directory_not_empty($INST_ARCHLIB)) ?
                         $Config{installsitearch} :
                         $Config{installsitelib},
           $INST_ARCHLIB => $Config{installsitearch},
           $INST_BIN => $Config{installbin} ,
           $INST_SCRIPT => $Config{installscript},
           $INST_MAN1DIR => $Config{installman1dir},
           $INST_MAN3DIR => $Config{installman3dir},
          },1,0,0);
d313 1
d318 1
a318 2
    die _estr "ERROR: no packlist file found: '$fil'"
        unless -f $fil;
d323 3
a325 3
        chomp;
        print "unlink $_\n" if $verbose;
        forceunlink($_,'tryhard') unless $nonono;
d328 1
a328 2
    forceunlink($fil, 'tryhard') unless $nonono;
    _do_cleanup($verbose);
a330 12
=begin _undocumented

=item inc_uninstall($filepath,$libdir,$verbose,$nonono,$ignore)

Remove shadowed files. If $ignore is true then it is assumed to hold
a filename to ignore. This is used to prevent spurious warnings from
occuring when doing an install at reboot.

=end _undocumented

=cut

d332 1
a332 1
    my($filepath,$libdir,$verbose,$nonono,$ignore) = @@_;
a333 1
    $ignore||="";
d337 1
a337 1
    my @@PERL_ENV_LIB = split $Config{path_sep}, defined $ENV{'PERL5LIB'}
d341 26
a366 27
                                                  privlibexp
                                                  sitearchexp
                                                  sitelibexp)}) {
        my $canonpath = File::Spec->canonpath($dir);
        next if $canonpath eq $Curdir;
        next if $seen_dir{$canonpath}++;
        my $targetfile = File::Spec->catfile($canonpath,$libdir,$file);
        next unless -f $targetfile;

        # The reason why we compare file's contents is, that we cannot
        # know, which is the file we just installed (AFS). So we leave
        # an identical file in place
        my $diff = 0;
        if ( -f $targetfile && -s _ == -s $filepath) {
            # We have a good chance, we can skip this one
            $diff = compare($filepath,$targetfile);
        } else {
            $diff++;
        }
        print "#$file and $targetfile differ\n" if $diff && $verbose > 1;

        next if !$diff or $targetfile eq $ignore;
        if ($nonono) {
            if ($verbose) {
                $Inc_uninstall_warn_handler ||= ExtUtils::Install::Warn->new();
                $libdir =~ s|^\./||s ; # That's just cosmetics, no need to port. It looks prettier.
                $Inc_uninstall_warn_handler->add(
d370 6
a375 6
            }
            # if not verbose, we just say nothing
        } else {
            print "Unlinking $targetfile (shadowing?)\n" if $verbose;
            forceunlink($targetfile,'tryhard');
        }
a378 10
=begin _undocumented

=item run_filter($cmd,$src,$dest)

Filter $src using $cmd into $dest.

=end _undocumented

=cut

d387 1
a387 1
        syswrite(CMD, $buf, $len);
d415 7
a421 1
    _mkpath($autodir,0,0755);
d423 1
a423 1
        if( -f $to && -s $from == -s $to && -M $to < -M $from ) {
d428 4
a431 4
        # When a pm_filter is defined, we need to pre-process the source first
        # to determine whether it has changed or not.  Therefore, only perform
        # the comparison check when there's no filter to be ran.
        #    -- RAM, 03/01/2001
d433 1
a433 1
        my $need_filtering = defined $pm_filter && length $pm_filter &&
d436 21
a456 22
        if (!$need_filtering && 0 == compare($from,$to)) {
            print "Skip $to (unchanged)\n";
            next;
        }
        if (-f $to){
            # we wont try hard here. its too likely to mess things up.
            forceunlink($to);
        } else {
            _mkpath(dirname($to),0,0755);
        }
        if ($need_filtering) {
            run_filter($pm_filter, $from, $to);
            print "$pm_filter <$from >$to\n";
        } else {
            _copy( $from, $to );
            print "cp $from $to\n";
        }
        my($mode,$atime,$mtime) = (stat $from)[2,8,9];
        utime($atime,$mtime+$Is_VMS,$to);
        _chmod(0444 | ( $mode & 0111 ? 0111 : 0 ),$to);
        next unless $from =~ /\.pm$/;
        _autosplit($to,$autodir);
d473 1
a473 1
sub _autosplit { #XXX OS-SPECIFIC
d503 1
a503 4
        my $inst = (_invokant() eq 'ExtUtils::MakeMaker')
                 ? ( $Config::Config{make} || 'make' ).' install UNINST=1'
                 : './Build install uninst=1';
        print "## Running '$inst' will unlink $plural for you.\n";
d507 1
a507 3
=begin _private

=item _invokant
a508 27
Does a heuristic on the stack to see who called us for more intelligent
error messages. Currently assumes we will be called only by Module::Build
or by ExtUtils::MakeMaker.

=end _private

=cut

sub _invokant {
    my @@stack;
    my $frame = 0;
    while (my $file = (caller($frame++))[1]) {
        push @@stack, (File::Spec->splitpath($file))[2];
    }

    my $builder;
    my $top = pop @@stack;
    if ($top =~ /^Build/i || exists($INC{'Module/Build.pm'})) {
        $builder = 'Module::Build';
    } else {
        $builder = 'ExtUtils::MakeMaker';
    }
    return $builder;
}


=back
a517 9
=item B<EU_INSTALL_IGNORE_SKIP>

Will prevent the automatic use of INSTALL.SKIP as the install skip file.

=item B<EU_INSTALL_SITE_SKIPFILE>

If there is no INSTALL.SKIP file in the make directory then this value
can be used to provide a default.

d524 3
a526 1
Production release currently maintained by demerphq C<yves at cpan.org>
d531 3
d536 1
a536 1
This program is free software; you can redistribute it and/or
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d2 1
d6 2
a25 2
=pod

a39 11
=head1 VERSION

1.54

=cut

$VERSION = '1.54';  # <---- dont forget to update the POD section just above this line!
$VERSION = eval $VERSION;

=pod

a84 1
my $Is_VMS_noefs = $Is_VMS;
a89 22
    if( $Is_VMS ) {
        my $vms_unix_rpt;
        my $vms_efs;
        my $vms_case;

        if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
            $vms_unix_rpt = VMS::Feature::current("filename_unix_report");
            $vms_efs = VMS::Feature::current("efs_charset");
            $vms_case = VMS::Feature::current("efs_case_preserve");
        } else {
            my $unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
            my $efs_charset = $ENV{'DECC$EFS_CHARSET'} || '';
            my $efs_case = $ENV{'DECC$EFS_CASE_PRESERVE'} || '';
            $vms_unix_rpt = $unix_rpt =~ /^[ET1]/i;
            $vms_efs = $efs_charset =~ /^[ET1]/i;
            $vms_case = $efs_case =~ /^[ET1]/i;
        }
        $Is_VMS_noefs = 0 if ($vms_efs);
    }



d128 1
a128 1
        printf "chmod(0%o, %s)\n",$mode, $item if $verbose > 1;
d131 1
a131 2
        _warnonce sprintf "WARNING: Failed chmod(0%o, %s): %s\n",
                  $mode, $item, $err
d241 2
a242 3
    my $unlink_count = 0;
    while (unlink $file) { $unlink_count++; }
    return $file if $unlink_count > 0;
a274 1
=pod
d278 49
a385 2
=pod

d392 1
d397 2
a398 3
        unless (defined $has_posix) {
            $has_posix= (!$Is_cygwin && !$Is_Win32
             && eval 'local $^W; require POSIX; 1') || 0;
a407 1
=pod
d434 1
a434 1
    my ($vol, $dirs, $file) = File::Spec->splitpath($dir,1);
a435 3
    unshift @@dirs, File::Spec->curdir
        unless File::Spec->file_name_is_absolute($dir);

d439 1
a439 10
        if ($Is_VMS_noefs) {
            # There is a bug in catdir that is fixed when the EFS character
            # set is enabled, which requires this VMS specific code.
            $dir = File::Spec->catdir($vol,@@dirs);
        }
        else {
            $dir = File::Spec->catdir(@@dirs);
            $dir = File::Spec->catpath($vol,$dir,'')
                    if defined $vol and length $vol;
        }
d456 1
a456 3
=pod

=item _mkpath($dir,$show,$mode,$verbose,$dry_run)
d463 1
a463 1
If $dry_run is true then the directory will not be created but a check will be
d467 1
a467 1
If $dry_run is not true dies if the directory can not be created or is not
d473 1
a473 1
    my ($dir,$show,$mode,$verbose,$dry_run)=@@_;
d478 1
a478 1
    if (!$dry_run) {
d491 1
a491 1
        if ($dry_run) {
d496 1
a496 1
    } elsif ($show and $dry_run) {
a498 1

d501 1
a501 3
=pod

=item _copy($from,$to,$verbose,$dry_run)
d507 1
a507 1
If $dry_run is true then the copy will not actually occur.
d515 1
a515 1
    my ( $from, $to, $verbose, $dry_run)=@@_;
d519 1
a519 1
    if (!$dry_run) {
a524 2
=pod

a545 2
=pod

a547 114
=over 4

=item B<install>

    # deprecated forms
    install(\%from_to);
    install(\%from_to, $verbose, $dry_run, $uninstall_shadows,
                $skip, $always_copy, \%result);

    # recommended form as of 1.47
    install([
        from_to => \%from_to,
        verbose => 1,
        dry_run => 0,
        uninstall_shadows => 1,
        skip => undef,
        always_copy => 1,
        result => \%install_results,
    ]);


Copies each directory tree of %from_to to its corresponding value
preserving timestamps and permissions.

There are two keys with a special meaning in the hash: "read" and
"write".  These contain packlist files.  After the copying is done,
install() will write the list of target files to $from_to{write}. If
$from_to{read} is given the contents of this file will be merged into
the written file. The read and the written file may be identical, but
on AFS it is quite likely that people are installing to a different
directory than the one where the files later appear.

If $verbose is true, will print out each file removed.  Default is
false.  This is "make install VERBINST=1". $verbose values going
up to 5 show increasingly more diagnostics output.

If $dry_run is true it will only print what it was going to do
without actually doing it.  Default is false.

If $uninstall_shadows is true any differing versions throughout @@INC
will be uninstalled.  This is "make install UNINST=1"

As of 1.37_02 install() supports the use of a list of patterns to filter out
files that shouldn't be installed. If $skip is omitted or undefined then
install will try to read the list from INSTALL.SKIP in the CWD. This file is
a list of regular expressions and is just like the MANIFEST.SKIP file used
by L<ExtUtils::Manifest>.

A default site INSTALL.SKIP may be provided by setting then environment
variable EU_INSTALL_SITE_SKIPFILE, this will only be used when there isn't a
distribution specific INSTALL.SKIP. If the environment variable
EU_INSTALL_IGNORE_SKIP is true then no install file filtering will be
performed.

If $skip is undefined then the skip file will be autodetected and used if it
is found. If $skip is a reference to an array then it is assumed the array
contains the list of patterns, if $skip is a true non reference it is
assumed to be the filename holding the list of patterns, any other value of
$skip is taken to mean that no install filtering should occur.

B<Changes As of Version 1.47>

As of version 1.47 the following additions were made to the install interface.
Note that the new argument style and use of the %result hash is recommended.

The $always_copy parameter which when true causes files to be updated
regardles as to whether they have changed, if it is defined but false then
copies are made only if the files have changed, if it is undefined then the
value of the environment variable EU_INSTALL_ALWAYS_COPY is used as default.

The %result hash will be populated with the various keys/subhashes reflecting
the install. Currently these keys and their structure are:

    install             => { $target    => $source },
    install_fail        => { $target    => $source },
    install_unchanged   => { $target    => $source },

    install_filtered    => { $source    => $pattern },

    uninstall           => { $uninstalled => $source },
    uninstall_fail      => { $uninstalled => $source },

where C<$source> is the filespec of the file being installed. C<$target> is where
it is being installed to, and C<$uninstalled> is any shadow file that is in C<@@INC>
or C<$ENV{PERL5LIB}> or other standard locations, and C<$pattern> is the pattern that
caused a source file to be skipped. In future more keys will be added, such as to
show created directories, however this requires changes in other modules and must
therefore wait.

These keys will be populated before any exceptions are thrown should there be an
error.

Note that all updates of the %result are additive, the hash will not be
cleared before use, thus allowing status results of many installs to be easily
aggregated.

B<NEW ARGUMENT STYLE>

If there is only one argument and it is a reference to an array then
the array is assumed to contain a list of key-value pairs specifying
the options. In this case the option "from_to" is mandatory. This style
means that you dont have to supply a cryptic list of arguments and can
use a self documenting argument list that is easier to understand.

This is now the recommended interface to install().

B<RETURN>

If all actions were successful install will return a hashref of the results
as described above for the $result parameter. If any action is a failure
then install will die, therefore it is recommended to pass in the $result
parameter instead of using the return value. If the result parameter is
provided then the returned hashref will be the passed in hashref.

d551 1
a551 14
    my($from_to,$verbose,$dry_run,$uninstall_shadows,$skip,$always_copy,$result) = @@_;
    if (@@_==1 and eval { 1+@@$from_to }) {
        my %opts        = @@$from_to;
        $from_to        = $opts{from_to}
                            or Carp::confess("from_to is a mandatory parameter");
        $verbose        = $opts{verbose};
        $dry_run        = $opts{dry_run};
        $uninstall_shadows  = $opts{uninstall_shadows};
        $skip           = $opts{skip};
        $always_copy    = $opts{always_copy};
        $result         = $opts{result};
    }

    $result ||= {};
d553 1
a553 1
    $dry_run  ||= 0;
a555 4
    $always_copy =  $ENV{EU_INSTALL_ALWAYS_COPY}
                 || $ENV{EU_ALWAYS_COPY}
                 || 0
        unless defined $always_copy;
d571 1
a571 1

a616 1
                    $result->{install_filtered}{$sourcefile} = $pat;
d622 1
a622 1
            my $save_cwd = _chdir($cwd);
d624 4
a627 2
            # XXX: I wonder how useful this logic is actually -- demerphq
            if ( $always_copy or !-f $targetfile or -s $targetfile != $size) {
a628 3
            } else {
                # we might not need to copy this file
                $diff = compare($sourcefile, $targetfile);
d630 1
a630 1
            $check_dirs{$targetdir}++
d632 1
a632 1

d637 2
a638 2

                ];
d641 2
a642 2
            _chdir($save_cwd);
        }, $current_directory );
d644 2
a645 1
    }
d647 1
a647 1
        _mkpath( $targetdir, 0, 0755, $verbose, $dry_run );
d652 1
a652 1

d655 12
a666 11
            eval {
                if (-f $targetfile) {
                    print "_unlink_or_rename($targetfile)\n" if $verbose>1;
                    $targetfile= _unlink_or_rename( $targetfile, 'tryhard', 'install' )
                        unless $dry_run;
                } elsif ( ! -d $targetdir ) {
                    _mkpath( $targetdir, 0, 0755, $verbose, $dry_run );
                }
                print "Installing $targetfile\n";

                _copy( $sourcefile, $targetfile, $verbose, $dry_run, );
d669 4
a672 15
                #XXX OS-SPECIFIC
                print "utime($atime,$mtime,$targetfile)\n" if $verbose>1;
                utime($atime,$mtime + $Is_VMS,$targetfile) unless $dry_run>1;


                $mode = 0444 | ( $mode & 0111 ? 0111 : 0 );
                $mode = $mode | 0222
                    if $realtarget ne $targetfile;
                _chmod( $mode, $targetfile, $verbose );
                $result->{install}{$targetfile} = $sourcefile;
                1
            } or do {
                $result->{install_fail}{$targetfile} = $sourcefile;
                die $@@;
            };
a673 1
            $result->{install_unchanged}{$targetfile} = $sourcefile;
d677 1
a677 1
        if ( $uninstall_shadows ) {
d679 2
a680 3
                          $dry_run,
                          $realtarget ne $targetfile ? $realtarget : "",
                          $result);
d689 3
a691 3
        _mkpath( $dir, 0, 0755, $verbose, $dry_run );
        print "Writing $pack{'write'}\n" if $verbose;
        $packlist->write(install_rooted_file($pack{'write'})) unless $dry_run;
a694 1
    return $result;
d770 1
a770 1
    _unlink_or_rename( $file, $tryhard, not("installing") );
a796 1
=pod
a828 7

  my @@INST_HTML;
  if($Config{installhtmldir}) {
      my $INST_HTMLDIR = File::Spec->catdir($Curdir,'blib','html');
      @@INST_HTML = ($INST_HTMLDIR => $Config{installhtmldir});
  }

a839 1
       @@INST_HTML,
d860 1
a860 1
    my($fil,$verbose,$dry_run) = @@_;
d862 1
a862 1
    $dry_run  ||= 0;
d872 1
a872 1
        forceunlink($_,'tryhard') unless $dry_run;
d875 1
a875 1
    forceunlink($fil, 'tryhard') unless $dry_run;
d881 1
a881 1
=item inc_uninstall($filepath,$libdir,$verbose,$dry_run,$ignore,$results)
a886 7
We now only die when failing to remove a file that has precedence over
our own, when our install has precedence we only warn.

$results is assumed to contain a hashref which will have the keys
'uninstall' and 'uninstall_fail' populated with  keys for the files
removed and values of the source files they would shadow.

d892 1
a892 1
    my($filepath,$libdir,$verbose,$dry_run,$ignore,$results) = @@_;
d901 5
a905 11
    my @@dirs=( @@PERL_ENV_LIB,
               @@INC,
               @@Config{qw(archlibexp
                          privlibexp
                          sitearchexp
                          sitelibexp)});

    #warn join "\n","---",@@dirs,"---";
    my $seen_ours;
    foreach $dir ( @@dirs ) {
        my $canonpath = $Is_VMS ? $dir : File::Spec->canonpath($dir);
d923 2
a924 6
        if (!$diff or $targetfile eq $ignore) {
            $seen_ours = 1;
            next;
        }
        if ($dry_run) {
            $results->{uninstall}{$targetfile} = $filepath;
d936 1
a936 15
            eval {
                die "Fake die for testing"
                    if $ExtUtils::Install::Testing and
                       ucase(File::Spec->canonpath($ExtUtils::Install::Testing)) eq ucase($targetfile);
                forceunlink($targetfile,'tryhard');
                $results->{uninstall}{$targetfile} = $filepath;
                1;
            } or do {
                $results->{fail_uninstall}{$targetfile} = $filepath;
                if ($seen_ours) {
                    warn "Failed to remove probably harmless shadow file '$targetfile'\n";
                } else {
                    die "$@@\n";
                }
            };
a964 1
=pod
d1071 1
a1071 2
                 ? ( $Config::Config{make} || 'make' ).' install'
                     . ( $Is_VMS ? '/MACRO="UNINST"=1' : ' UNINST=1' )
a1105 1
=pod
a1125 9
=item B<EU_INSTALL_ALWAYS_COPY>

If this environment variable is true then normal install processes will
always overwrite older identical files during the install process.

Note that the alias EU_ALWAYS_COPY will be supported if EU_INSTALL_ALWAYS_COPY
is not defined until at least the 1.50 release. Please ensure you use the
correct EU_INSTALL_ALWAYS_COPY.

d1132 1
a1132 2
Production release currently maintained by demerphq C<yves at cpan.org>,
extensive changes by Michael G. Schwern.
@


