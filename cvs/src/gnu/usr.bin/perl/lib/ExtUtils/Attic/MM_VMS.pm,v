head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2010.09.24.14.59.38;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.11;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.29;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.29;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.52;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.28;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.40;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.40;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.04;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.42;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.28;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.02;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.46.49;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.16;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.43;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.33;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.50;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package ExtUtils::MM_VMS;

use strict;

use ExtUtils::MakeMaker::Config;
require Exporter;

BEGIN {
    # so we can compile the thing on non-VMS platforms.
    if( $^O eq 'VMS' ) {
        require VMS::Filespec;
        VMS::Filespec->import;
    }
}

use File::Basename;

our $VERSION = '6.55_02';

require ExtUtils::MM_Any;
require ExtUtils::MM_Unix;
our @@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );

use ExtUtils::MakeMaker qw($Verbose neatvalue);
our $Revision = $ExtUtils::MakeMaker::Revision;


=head1 NAME

ExtUtils::MM_VMS - methods to override UN*X behaviour in ExtUtils::MakeMaker

=head1 SYNOPSIS

  Do not use this directly.
  Instead, use ExtUtils::MM and it will figure out which MM_*
  class to use for you.

=head1 DESCRIPTION

See ExtUtils::MM_Unix for a documentation of the methods provided
there. This package overrides the implementation of these methods, not
the semantics.

=head2 Methods always loaded

=over 4

=item wraplist

Converts a list into a string wrapped at approximately 80 columns.

=cut

sub wraplist {
    my($self) = shift;
    my($line,$hlen) = ('',0);

    foreach my $word (@@_) {
      # Perl bug -- seems to occasionally insert extra elements when
      # traversing array (scalar(@@array) doesn't show them, but
      # foreach(@@array) does) (5.00307)
      next unless $word =~ /\w/;
      $line .= ' ' if length($line);
      if ($hlen > 80) { $line .= "\\\n\t"; $hlen = 0; }
      $line .= $word;
      $hlen += length($word) + 2;
    }
    $line;
}


# This isn't really an override.  It's just here because ExtUtils::MM_VMS
# appears in @@MM::ISA before ExtUtils::Liblist::Kid, so if there isn't an ext()
# in MM_VMS, then AUTOLOAD is called, and bad things happen.  So, we just
# mimic inheritance here and hand off to ExtUtils::Liblist::Kid.
# XXX This hackery will die soon. --Schwern
sub ext {
    require ExtUtils::Liblist::Kid;
    goto &ExtUtils::Liblist::Kid::ext;
}

=back

=head2 Methods

Those methods which override default MM_Unix methods are marked
"(override)", while methods unique to MM_VMS are marked "(specific)".
For overridden methods, documentation is limited to an explanation
of why this method overrides the MM_Unix method; see the ExtUtils::MM_Unix
documentation for more details.

=over 4

=item guess_name (override)

Try to determine name of extension being built.  We begin with the name
of the current directory.  Since VMS filenames are case-insensitive,
however, we look for a F<.pm> file whose name matches that of the current
directory (presumably the 'main' F<.pm> file for this extension), and try
to find a C<package> statement from which to obtain the Mixed::Case
package name.

=cut

sub guess_name {
    my($self) = @@_;
    my($defname,$defpm,@@pm,%xs);
    local *PM;

    $defname = basename(fileify($ENV{'DEFAULT'}));
    $defname =~ s![\d\-_]*\.dir.*$!!;  # Clip off .dir;1 suffix, and package version
    $defpm = $defname;
    # Fallback in case for some reason a user has copied the files for an
    # extension into a working directory whose name doesn't reflect the
    # extension's name.  We'll use the name of a unique .pm file, or the
    # first .pm file with a matching .xs file.
    if (not -e "${defpm}.pm") {
      @@pm = glob('*.pm');
      s/.pm$// for @@pm;
      if (@@pm == 1) { ($defpm = $pm[0]) =~ s/.pm$//; }
      elsif (@@pm) {
        %xs = map { s/.xs$//; ($_,1) } glob('*.xs');  ## no critic
        if (keys %xs) { 
            foreach my $pm (@@pm) { 
                $defpm = $pm, last if exists $xs{$pm}; 
            } 
        }
      }
    }
    if (open(my $pm, '<', "${defpm}.pm")){
        while (<$pm>) {
            if (/^\s*package\s+([^;]+)/i) {
                $defname = $1;
                last;
            }
        }
        print STDOUT "Warning (non-fatal): Couldn't find package name in ${defpm}.pm;\n\t",
                     "defaulting package name to $defname\n"
            if eof($pm);
        close $pm;
    }
    else {
        print STDOUT "Warning (non-fatal): Couldn't find ${defpm}.pm;\n\t",
                     "defaulting package name to $defname\n";
    }
    $defname =~ s#[\d.\-_]+$##;
    $defname;
}

=item find_perl (override)

Use VMS file specification syntax and CLI commands to find and
invoke Perl images.

=cut

sub find_perl {
    my($self, $ver, $names, $dirs, $trace) = @@_;
    my($vmsfile,@@sdirs,@@snames,@@cand);
    my($rslt);
    my($inabs) = 0;
    local *TCF;

    if( $self->{PERL_CORE} ) {
        # Check in relative directories first, so we pick up the current
        # version of Perl if we're running MakeMaker as part of the main build.
        @@sdirs = sort { my($absa) = $self->file_name_is_absolute($a);
                        my($absb) = $self->file_name_is_absolute($b);
                        if ($absa && $absb) { return $a cmp $b }
                        else { return $absa ? 1 : ($absb ? -1 : ($a cmp $b)); }
                      } @@$dirs;
        # Check miniperl before perl, and check names likely to contain
        # version numbers before "generic" names, so we pick up an
        # executable that's less likely to be from an old installation.
        @@snames = sort { my($ba) = $a =~ m!([^:>\]/]+)$!;  # basename
                         my($bb) = $b =~ m!([^:>\]/]+)$!;
                         my($ahasdir) = (length($a) - length($ba) > 0);
                         my($bhasdir) = (length($b) - length($bb) > 0);
                         if    ($ahasdir and not $bhasdir) { return 1; }
                         elsif ($bhasdir and not $ahasdir) { return -1; }
                         else { $bb =~ /\d/ <=> $ba =~ /\d/
                                  or substr($ba,0,1) cmp substr($bb,0,1)
                                  or length($bb) <=> length($ba) } } @@$names;
    }
    else {
        @@sdirs  = @@$dirs;
        @@snames = @@$names;
    }

    # Image names containing Perl version use '_' instead of '.' under VMS
    s/\.(\d+)$/_$1/ for @@snames;
    if ($trace >= 2){
        print "Looking for perl $ver by these names:\n";
        print "\t@@snames,\n";
        print "in these dirs:\n";
        print "\t@@sdirs\n";
    }
    foreach my $dir (@@sdirs){
        next unless defined $dir; # $self->{PERL_SRC} may be undefined
        $inabs++ if $self->file_name_is_absolute($dir);
        if ($inabs == 1) {
            # We've covered relative dirs; everything else is an absolute
            # dir (probably an installed location).  First, we'll try 
            # potential command names, to see whether we can avoid a long 
            # MCR expression.
            foreach my $name (@@snames) {
                push(@@cand,$name) if $name =~ /^[\w\-\$]+$/;
            }
            $inabs++; # Should happen above in next $dir, but just in case...
        }
        foreach my $name (@@snames){
            push @@cand, ($name !~ m![/:>\]]!) ? $self->catfile($dir,$name)
                                              : $self->fixpath($name,0);
        }
    }
    foreach my $name (@@cand) {
        print "Checking $name\n" if $trace >= 2;
        # If it looks like a potential command, try it without the MCR
        if ($name =~ /^[\w\-\$]+$/) {
            open(my $tcf, ">", "temp_mmvms.com") 
                or die('unable to open temp file');
            print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
            print $tcf "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";
            close $tcf;
            $rslt = `\@@temp_mmvms.com` ;
            unlink('temp_mmvms.com');
            if ($rslt =~ /VER_OK/) {
                print "Using PERL=$name\n" if $trace;
                return $name;
            }
        }
        next unless $vmsfile = $self->maybe_command($name);
        $vmsfile =~ s/;[\d\-]*$//;  # Clip off version number; we can use a newer version as well
        print "Executing $vmsfile\n" if ($trace >= 2);
        open(my $tcf, '>', "temp_mmvms.com")
                or die('unable to open temp file');
        print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
        print $tcf "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";
        close $tcf;
        $rslt = `\@@temp_mmvms.com`;
        unlink('temp_mmvms.com');
        if ($rslt =~ /VER_OK/) {
            print "Using PERL=MCR $vmsfile\n" if $trace;
            return "MCR $vmsfile";
        }
    }
    print STDOUT "Unable to find a perl $ver (by these names: @@$names, in these dirs: @@$dirs)\n";
    0; # false and not empty
}

=item maybe_command (override)

Follows VMS naming conventions for executable files.
If the name passed in doesn't exactly match an executable file,
appends F<.Exe> (or equivalent) to check for executable image, and F<.Com>
to check for DCL procedure.  If this fails, checks directories in DCL$PATH
and finally F<Sys$System:> for an executable file having the name specified,
with or without the F<.Exe>-equivalent suffix.

=cut

sub maybe_command {
    my($self,$file) = @@_;
    return $file if -x $file && ! -d _;
    my(@@dirs) = ('');
    my(@@exts) = ('',$Config{'exe_ext'},'.exe','.com');

    if ($file !~ m![/:>\]]!) {
        for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
            my $dir = $ENV{"DCL\$PATH;$i"};
            $dir .= ':' unless $dir =~ m%[\]:]$%;
            push(@@dirs,$dir);
        }
        push(@@dirs,'Sys$System:');
        foreach my $dir (@@dirs) {
            my $sysfile = "$dir$file";
            foreach my $ext (@@exts) {
                return $file if -x "$sysfile$ext" && ! -d _;
            }
        }
    }
    return 0;
}


=item pasthru (override)

VMS has $(MMSQUALIFIERS) which is a listing of all the original command line
options.  This is used in every invocation of make in the VMS Makefile so
PASTHRU should not be necessary.  Using PASTHRU tends to blow commands past
the 256 character limit.

=cut

sub pasthru {
    return "PASTHRU=\n";
}


=item pm_to_blib (override)

VMS wants a dot in every file so we can't have one called 'pm_to_blib',
it becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when
you have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.

So in VMS its pm_to_blib.ts.

=cut

sub pm_to_blib {
    my $self = shift;

    my $make = $self->SUPER::pm_to_blib;

    $make =~ s{^pm_to_blib :}{pm_to_blib.ts :}m;
    $make =~ s{\$\(TOUCH\) pm_to_blib}{\$(TOUCH) pm_to_blib.ts};

    $make = <<'MAKE' . $make;
# Dummy target to match Unix target name; we use pm_to_blib.ts as
# timestamp file to avoid repeated invocations under VMS
pm_to_blib : pm_to_blib.ts
	$(NOECHO) $(NOOP)

MAKE

    return $make;
}


=item perl_script (override)

If name passed in doesn't specify a readable file, appends F<.com> or
F<.pl> and tries again, since it's customary to have file types on all files
under VMS.

=cut

sub perl_script {
    my($self,$file) = @@_;
    return $file if -r $file && ! -d _;
    return "$file.com" if -r "$file.com";
    return "$file.pl" if -r "$file.pl";
    return '';
}


=item replace_manpage_separator

Use as separator a character which is legal in a VMS-syntax file name.

=cut

sub replace_manpage_separator {
    my($self,$man) = @@_;
    $man = unixify($man);
    $man =~ s#/+#__#g;
    $man;
}

=item init_DEST

(override) Because of the difficulty concatenating VMS filepaths we
must pre-expand the DEST* variables.

=cut

sub init_DEST {
    my $self = shift;

    $self->SUPER::init_DEST;

    # Expand DEST variables.
    foreach my $var ($self->installvars) {
        my $destvar = 'DESTINSTALL'.$var;
        $self->{$destvar} = $self->eliminate_macros($self->{$destvar});
    }
}


=item init_DIRFILESEP

No seperator between a directory path and a filename on VMS.

=cut

sub init_DIRFILESEP {
    my($self) = shift;

    $self->{DIRFILESEP} = '';
    return 1;
}


=item init_main (override)


=cut

sub init_main {
    my($self) = shift;

    $self->SUPER::init_main;

    $self->{DEFINE} ||= '';
    if ($self->{DEFINE} ne '') {
        my(@@terms) = split(/\s+/,$self->{DEFINE});
        my(@@defs,@@udefs);
        foreach my $def (@@terms) {
            next unless $def;
            my $targ = \@@defs;
            if ($def =~ s/^-([DU])//) {    # If it was a Unix-style definition
                $targ = \@@udefs if $1 eq 'U';
                $def =~ s/='(.*)'$/=$1/;  # then remove shell-protection ''
                $def =~ s/^'(.*)'$/$1/;   # from entire term or argument
            }
            if ($def =~ /=/) {
                $def =~ s/"/""/g;  # Protect existing " from DCL
                $def = qq["$def"]; # and quote to prevent parsing of =
            }
            push @@$targ, $def;
        }

        $self->{DEFINE} = '';
        if (@@defs)  { 
            $self->{DEFINE}  = '/Define=(' . join(',',@@defs)  . ')'; 
        }
        if (@@udefs) { 
            $self->{DEFINE} .= '/Undef=('  . join(',',@@udefs) . ')'; 
        }
    }
}

=item init_others (override)

Provide VMS-specific forms of various utility commands, then hand
off to the default MM_Unix method.

DEV_NULL should probably be overriden with something.

Also changes EQUALIZE_TIMESTAMP to set revision date of target file to
one second later than source file, since MMK interprets precisely
equal revision dates for a source and target file as a sign that the
target needs to be updated.

=cut

sub init_others {
    my($self) = @@_;

    $self->{NOOP}               = 'Continue';
    $self->{NOECHO}             ||= '@@ ';

    $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE} || 'Descrip.MMS';
    $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE};
    $self->{MAKE_APERL_FILE}    ||= 'Makeaperl.MMS';
    $self->{MAKEFILE_OLD}       ||= $self->eliminate_macros('$(FIRST_MAKEFILE)_old');
#
#   If an extension is not specified, then MMS/MMK assumes an
#   an extension of .MMS.  If there really is no extension,
#   then a trailing "." needs to be appended to specify a
#   a null extension.
#
    $self->{MAKEFILE} .= '.' unless $self->{MAKEFILE} =~ m/\./;
    $self->{FIRST_MAKEFILE} .= '.' unless $self->{FIRST_MAKEFILE} =~ m/\./;
    $self->{MAKE_APERL_FILE} .= '.' unless $self->{MAKE_APERL_FILE} =~ m/\./;
    $self->{MAKEFILE_OLD} .= '.' unless $self->{MAKEFILE_OLD} =~ m/\./;

    $self->{MACROSTART}         ||= '/Macro=(';
    $self->{MACROEND}           ||= ')';
    $self->{USEMAKEFILE}        ||= '/Descrip=';

    $self->{EQUALIZE_TIMESTAMP} ||= '$(ABSPERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';

    $self->{MOD_INSTALL} ||= 
      $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
install([ from_to => {split(' ', <STDIN>)}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
CODE

    $self->SUPER::init_others;

    $self->{SHELL}    ||= 'Posix';

    $self->{UMASK_NULL} = '! ';  

    # Redirection on VMS goes before the command, not after as on Unix.
    # $(DEV_NULL) is used once and its not worth going nuts over making
    # it work.  However, Unix's DEV_NULL is quite wrong for VMS.
    $self->{DEV_NULL}   = '';

    if ($self->{OBJECT} =~ /\s/) {
        $self->{OBJECT} =~ s/(\\)?\n+\s+/ /g;
        $self->{OBJECT} = $self->wraplist(
            map $self->fixpath($_,0), split /,?\s+/, $self->{OBJECT}
        );
    }

    $self->{LDFROM} = $self->wraplist(
        map $self->fixpath($_,0), split /,?\s+/, $self->{LDFROM}
    );
}


=item init_platform (override)

Add PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.

MM_VMS_REVISION is for backwards compatibility before MM_VMS had a
$VERSION.

=cut

sub init_platform {
    my($self) = shift;

    $self->{MM_VMS_REVISION} = $Revision;
    $self->{MM_VMS_VERSION}  = $VERSION;
    $self->{PERL_VMS} = $self->catdir($self->{PERL_SRC}, 'VMS')
      if $self->{PERL_SRC};
}


=item platform_constants

=cut

sub platform_constants {
    my($self) = shift;
    my $make_frag = '';

    foreach my $macro (qw(PERL_VMS MM_VMS_REVISION MM_VMS_VERSION))
    {
        next unless defined $self->{$macro};
        $make_frag .= "$macro = $self->{$macro}\n";
    }

    return $make_frag;
}


=item init_VERSION (override)

Override the *DEFINE_VERSION macros with VMS semantics.  Translate the
MAKEMAKER filepath to VMS style.

=cut

sub init_VERSION {
    my $self = shift;

    $self->SUPER::init_VERSION;

    $self->{DEFINE_VERSION}    = '"$(VERSION_MACRO)=""$(VERSION)"""';
    $self->{XS_DEFINE_VERSION} = '"$(XS_VERSION_MACRO)=""$(XS_VERSION)"""';
    $self->{MAKEMAKER} = vmsify($INC{'ExtUtils/MakeMaker.pm'});
}


=item constants (override)

Fixes up numerous file and directory macros to insure VMS syntax
regardless of input syntax.  Also makes lists of files
comma-separated.

=cut

sub constants {
    my($self) = @@_;

    # Be kind about case for pollution
    for (@@ARGV) { $_ = uc($_) if /POLLUTE/i; }

    # Cleanup paths for directories in MMS macros.
    foreach my $macro ( qw [
            INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB 
            PERL_LIB PERL_ARCHLIB
            PERL_INC PERL_SRC ],
                        (map { 'INSTALL'.$_ } $self->installvars)
                      ) 
    {
        next unless defined $self->{$macro};
        next if $macro =~ /MAN/ && $self->{$macro} eq 'none';
        $self->{$macro} = $self->fixpath($self->{$macro},1);
    }

    # Cleanup paths for files in MMS macros.
    foreach my $macro ( qw[LIBPERL_A FIRST_MAKEFILE MAKEFILE_OLD 
                           MAKE_APERL_FILE MYEXTLIB] ) 
    {
        next unless defined $self->{$macro};
        $self->{$macro} = $self->fixpath($self->{$macro},0);
    }

    # Fixup files for MMS macros
    # XXX is this list complete?
    for my $macro (qw/
                   FULLEXT VERSION_FROM OBJECT LDFROM
	      /	) {
        next unless defined $self->{$macro};
        $self->{$macro} = $self->fixpath($self->{$macro},0);
    }


    for my $macro (qw/ XS MAN1PODS MAN3PODS PM /) {
        # Where is the space coming from? --jhi
        next unless $self ne " " && defined $self->{$macro};
        my %tmp = ();
        for my $key (keys %{$self->{$macro}}) {
            $tmp{$self->fixpath($key,0)} = 
                                     $self->fixpath($self->{$macro}{$key},0);
        }
        $self->{$macro} = \%tmp;
    }

    for my $macro (qw/ C O_FILES H /) {
        next unless defined $self->{$macro};
        my @@tmp = ();
        for my $val (@@{$self->{$macro}}) {
            push(@@tmp,$self->fixpath($val,0));
        }
        $self->{$macro} = \@@tmp;
    }

    # mms/k does not define a $(MAKE) macro.
    $self->{MAKE} = '$(MMS)$(MMSQUALIFIERS)';

    return $self->SUPER::constants;
}


=item special_targets

Clear the default .SUFFIXES and put in our own list.

=cut

sub special_targets {
    my $self = shift;

    my $make_frag .= <<'MAKE_FRAG';
.SUFFIXES :
.SUFFIXES : $(OBJ_EXT) .c .cpp .cxx .xs

MAKE_FRAG

    return $make_frag;
}

=item cflags (override)

Bypass shell script and produce qualifiers for CC directly (but warn
user if a shell script for this extension exists).  Fold multiple
/Defines into one, since some C compilers pay attention to only one
instance of this qualifier on the command line.

=cut

sub cflags {
    my($self,$libperl) = @@_;
    my($quals) = $self->{CCFLAGS} || $Config{'ccflags'};
    my($definestr,$undefstr,$flagoptstr) = ('','','');
    my($incstr) = '/Include=($(PERL_INC)';
    my($name,$sys,@@m);

    ( $name = $self->{NAME} . "_cflags" ) =~ s/:/_/g ;
    print STDOUT "Unix shell script ".$Config{"$self->{'BASEEXT'}_cflags"}.
         " required to modify CC command for $self->{'BASEEXT'}\n"
    if ($Config{$name});

    if ($quals =~ / -[DIUOg]/) {
	while ($quals =~ / -([Og])(\d*)\b/) {
	    my($type,$lvl) = ($1,$2);
	    $quals =~ s/ -$type$lvl\b\s*//;
	    if ($type eq 'g') { $flagoptstr = '/NoOptimize'; }
	    else { $flagoptstr = '/Optimize' . (defined($lvl) ? "=$lvl" : ''); }
	}
	while ($quals =~ / -([DIU])(\S+)/) {
	    my($type,$def) = ($1,$2);
	    $quals =~ s/ -$type$def\s*//;
	    $def =~ s/"/""/g;
	    if    ($type eq 'D') { $definestr .= qq["$def",]; }
	    elsif ($type eq 'I') { $incstr .= ',' . $self->fixpath($def,1); }
	    else                 { $undefstr  .= qq["$def",]; }
	}
    }
    if (length $quals and $quals !~ m!/!) {
	warn "MM_VMS: Ignoring unrecognized CCFLAGS elements \"$quals\"\n";
	$quals = '';
    }
    $definestr .= q["PERL_POLLUTE",] if $self->{POLLUTE};
    if (length $definestr) { chop($definestr); $quals .= "/Define=($definestr)"; }
    if (length $undefstr)  { chop($undefstr);  $quals .= "/Undef=($undefstr)";   }
    # Deal with $self->{DEFINE} here since some C compilers pay attention
    # to only one /Define clause on command line, so we have to
    # conflate the ones from $Config{'ccflags'} and $self->{DEFINE}
    # ($self->{DEFINE} has already been VMSified in constants() above)
    if ($self->{DEFINE}) { $quals .= $self->{DEFINE}; }
    for my $type (qw(Def Undef)) {
	my(@@terms);
	while ($quals =~ m:/${type}i?n?e?=([^/]+):ig) {
		my $term = $1;
		$term =~ s:^\((.+)\)$:$1:;
		push @@terms, $term;
	    }
	if ($type eq 'Def') {
	    push @@terms, qw[ $(DEFINE_VERSION) $(XS_DEFINE_VERSION) ];
	}
	if (@@terms) {
	    $quals =~ s:/${type}i?n?e?=[^/]+::ig;
	    $quals .= "/${type}ine=(" . join(',',@@terms) . ')';
	}
    }

    $libperl or $libperl = $self->{LIBPERL_A} || "libperl.olb";

    # Likewise with $self->{INC} and /Include
    if ($self->{'INC'}) {
	my(@@includes) = split(/\s+/,$self->{INC});
	foreach (@@includes) {
	    s/^-I//;
	    $incstr .= ','.$self->fixpath($_,1);
	}
    }
    $quals .= "$incstr)";
#    $quals =~ s/,,/,/g; $quals =~ s/\(,/(/g;
    $self->{CCFLAGS} = $quals;

    $self->{PERLTYPE} ||= '';

    $self->{OPTIMIZE} ||= $flagoptstr || $Config{'optimize'};
    if ($self->{OPTIMIZE} !~ m!/!) {
	if    ($self->{OPTIMIZE} =~ m!-g!) { $self->{OPTIMIZE} = '/Debug/NoOptimize' }
	elsif ($self->{OPTIMIZE} =~ /-O(\d*)/) {
	    $self->{OPTIMIZE} = '/Optimize' . (defined($1) ? "=$1" : '');
	}
	else {
	    warn "MM_VMS: Can't parse OPTIMIZE \"$self->{OPTIMIZE}\"; using default\n" if length $self->{OPTIMIZE};
	    $self->{OPTIMIZE} = '/Optimize';
	}
    }

    return $self->{CFLAGS} = qq{
CCFLAGS = $self->{CCFLAGS}
OPTIMIZE = $self->{OPTIMIZE}
PERLTYPE = $self->{PERLTYPE}
};
}

=item const_cccmd (override)

Adds directives to point C preprocessor to the right place when
handling #include E<lt>sys/foo.hE<gt> directives.  Also constructs CC
command line a bit differently than MM_Unix method.

=cut

sub const_cccmd {
    my($self,$libperl) = @@_;
    my(@@m);

    return $self->{CONST_CCCMD} if $self->{CONST_CCCMD};
    return '' unless $self->needs_linking();
    if ($Config{'vms_cc_type'} eq 'gcc') {
        push @@m,'
.FIRST
	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" Then Define/NoLog SYS GNU_CC_Include:[VMS]';
    }
    elsif ($Config{'vms_cc_type'} eq 'vaxc') {
        push @@m,'
.FIRST
	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").eqs."" Then Define/NoLog SYS Sys$Library
	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("VAXC$Include").nes."" Then Define/NoLog SYS VAXC$Include';
    }
    else {
        push @@m,'
.FIRST
	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").eqs."" Then Define/NoLog SYS ',
		($Config{'archname'} eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'
	',$self->{NOECHO},'If F$TrnLnm("Sys").eqs."" .and. F$TrnLnm("DECC$System_Include").nes."" Then Define/NoLog SYS DECC$System_Include';
    }

    push(@@m, "\n\nCCCMD = $Config{'cc'} \$(CCFLAGS)\$(OPTIMIZE)\n");

    $self->{CONST_CCCMD} = join('',@@m);
}


=item tools_other (override)

Throw in some dubious extra macros for Makefile args.

Also keep around the old $(SAY) macro in case somebody's using it.

=cut

sub tools_other {
    my($self) = @@_;

    # XXX Are these necessary?  Does anyone override them?  They're longer
    # than just typing the literal string.
    my $extra_tools = <<'EXTRA_TOOLS';

# Just in case anyone is using the old macro.
USEMACROS = $(MACROSTART)
SAY = $(ECHO)

EXTRA_TOOLS

    return $self->SUPER::tools_other . $extra_tools;
}

=item init_dist (override)

VMSish defaults for some values.

  macro         description                     default

  ZIPFLAGS      flags to pass to ZIP            -Vu

  COMPRESS      compression command to          gzip
                use for tarfiles
  SUFFIX        suffix to put on                -gz 
                compressed files

  SHAR          shar command to use             vms_share

  DIST_DEFAULT  default target to use to        tardist
                create a distribution

  DISTVNAME     Use VERSION_SYM instead of      $(DISTNAME)-$(VERSION_SYM)
                VERSION for the name

=cut

sub init_dist {
    my($self) = @@_;
    $self->{ZIPFLAGS}     ||= '-Vu';
    $self->{COMPRESS}     ||= 'gzip';
    $self->{SUFFIX}       ||= '-gz';
    $self->{SHAR}         ||= 'vms_share';
    $self->{DIST_DEFAULT} ||= 'zipdist';

    $self->SUPER::init_dist;

    $self->{DISTVNAME} = "$self->{DISTNAME}-$self->{VERSION_SYM}"
      unless $self->{ARGS}{DISTVNAME};

    return;
}

=item c_o (override)

Use VMS syntax on command line.  In particular, $(DEFINE) and
$(PERL_INC) have been pulled into $(CCCMD).  Also use MM[SK] macros.

=cut

sub c_o {
    my($self) = @@_;
    return '' unless $self->needs_linking();
    '
.c$(OBJ_EXT) :
	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c

.cpp$(OBJ_EXT) :
	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cpp

.cxx$(OBJ_EXT) :
	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).cxx

';
}

=item xs_c (override)

Use MM[SK] macros.

=cut

sub xs_c {
    my($self) = @@_;
    return '' unless $self->needs_linking();
    '
.xs.c :
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET)
';
}

=item xs_o (override)

Use MM[SK] macros, and VMS command line for C compiler.

=cut

sub xs_o {	# many makes are too dumb to use xs_c then c_o
    my($self) = @@_;
    return '' unless $self->needs_linking();
    '
.xs$(OBJ_EXT) :
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).c
	$(CCCMD) $(CCCDLFLAGS) $(MMS$TARGET_NAME).c
';
}


=item dlsyms (override)

Create VMS linker options files specifying universal symbols for this
extension's shareable image, and listing other shareable images or 
libraries to which it should be linked.

=cut

sub dlsyms {
    my($self,%attribs) = @@_;

    return '' unless $self->needs_linking();

    my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
    my($vars)  = $attribs{DL_VARS}  || $self->{DL_VARS}  || [];
    my($funclist)  = $attribs{FUNCLIST}  || $self->{FUNCLIST}  || [];
    my(@@m);

    unless ($self->{SKIPHASH}{'dynamic'}) {
	push(@@m,'
dynamic :: $(INST_ARCHAUTODIR)$(BASEEXT).opt
	$(NOECHO) $(NOOP)
');
    }

    push(@@m,'
static :: $(INST_ARCHAUTODIR)$(BASEEXT).opt
	$(NOECHO) $(NOOP)
') unless $self->{SKIPHASH}{'static'};

    push @@m,'
$(INST_ARCHAUTODIR)$(BASEEXT).opt : $(BASEEXT).opt
	$(CP) $(MMS$SOURCE) $(MMS$TARGET)

$(BASEEXT).opt : Makefile.PL
	$(PERLRUN) -e "use ExtUtils::Mksymlists;" -
	',qq[-e "Mksymlists('NAME' => '$self->{NAME}', 'DL_FUNCS' => ],
	neatvalue($funcs),q[, 'DL_VARS' => ],neatvalue($vars),
	q[, 'FUNCLIST' => ],neatvalue($funclist),qq[)"\n];

    push @@m, '	$(PERL) -e "print ""$(INST_STATIC)/Include=';
    if ($self->{OBJECT} =~ /\bBASEEXT\b/ or
        $self->{OBJECT} =~ /\b$self->{BASEEXT}\b/i) { 
        push @@m, ($Config{d_vms_case_sensitive_symbols}
	           ? uc($self->{BASEEXT}) :'$(BASEEXT)');
    }
    else {  # We don't have a "main" object file, so pull 'em all in
        # Upcase module names if linker is being case-sensitive
        my($upcase) = $Config{d_vms_case_sensitive_symbols};
        my(@@omods) = split ' ', $self->eliminate_macros($self->{OBJECT});
        for (@@omods) {
            s/\.[^.]*$//;         # Trim off file type
            s[\$\(\w+_EXT\)][];   # even as a macro
            s/.*[:>\/\]]//;       # Trim off dir spec
            $_ = uc if $upcase;
        };

        my(@@lines);
        my $tmp = shift @@omods;
        foreach my $elt (@@omods) {
            $tmp .= ",$elt";
            if (length($tmp) > 80) { push @@lines, $tmp;  $tmp = ''; }
        }
        push @@lines, $tmp;
        push @@m, '(', join( qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""], @@lines),')';
    }
    push @@m, '\n$(INST_STATIC)/Library\n"";" >>$(MMS$TARGET)',"\n";

    if (length $self->{LDLOADLIBS}) {
        my($line) = '';
        foreach my $lib (split ' ', $self->{LDLOADLIBS}) {
            $lib =~ s%\$%\\\$%g;  # Escape '$' in VMS filespecs
            if (length($line) + length($lib) > 160) {
                push @@m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";
                $line = $lib . '\n';
            }
            else { $line .= $lib . '\n'; }
        }
        push @@m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if $line;
    }

    join('',@@m);

}

=item dynamic_lib (override)

Use VMS Link command.

=cut

sub dynamic_lib {
    my($self, %attribs) = @@_;
    return '' unless $self->needs_linking(); #might be because of a subdir

    return '' unless $self->has_link_code();

    my($otherldflags) = $attribs{OTHERLDFLAGS} || "";
    my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
    my $shr = $Config{'dbgprefix'} . 'PerlShr';
    my(@@m);
    push @@m,"

OTHERLDFLAGS = $otherldflags
INST_DYNAMIC_DEP = $inst_dynamic_dep

";
    push @@m, '
$(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
	If F$TrnLNm("',$shr,'").eqs."" Then Define/NoLog/User ',"$shr Sys\$Share:$shr.$Config{'dlext'}",'
	Link $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) $(BASEEXT).opt/Option,$(PERL_INC)perlshr_attr.opt/Option
';

    join('',@@m);
}


=item static_lib (override)

Use VMS commands to manipulate object library.

=cut

sub static_lib {
    my($self) = @@_;
    return '' unless $self->needs_linking();

    return '
$(INST_STATIC) :
	$(NOECHO) $(NOOP)
' unless ($self->{OBJECT} or @@{$self->{C} || []} or $self->{MYEXTLIB});

    my(@@m);
    push @@m,'
# Rely on suffix rule for update action
$(OBJECT) : $(INST_ARCHAUTODIR)$(DFSEP).exists

$(INST_STATIC) : $(OBJECT) $(MYEXTLIB)
';
    # If this extension has its own library (eg SDBM_File)
    # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
    push(@@m, "\t",'$(CP) $(MYEXTLIB) $(MMS$TARGET)',"\n") if $self->{MYEXTLIB};

    push(@@m,"\t",'If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)',"\n");

    # if there was a library to copy, then we can't use MMS$SOURCE_LIST,
    # 'cause it's a library and you can't stick them in other libraries.
    # In that case, we use $OBJECT instead and hope for the best
    if ($self->{MYEXTLIB}) {
      push(@@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(OBJECT)',"\n");
    } else {
      push(@@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)',"\n");
    }
    
    push @@m, "\t\$(NOECHO) \$(PERL) -e 1 >\$(INST_ARCHAUTODIR)extralibs.ld\n";
    foreach my $lib (split ' ', $self->{EXTRALIBS}) {
      push(@@m,"\t",'$(NOECHO) $(PERL) -e "print qq{',$lib,'\n}" >>$(INST_ARCHAUTODIR)extralibs.ld',"\n");
    }
    join('',@@m);
}


=item extra_clean_files

Clean up some OS specific files.  Plus the temp file used to shorten
a lot of commands.

=cut

sub extra_clean_files {
    return qw(
              *.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *.Opt $(BASEEXT).bso
              .MM_Tmp
             );
}


=item zipfile_target

=item tarfile_target

=item shdist_target

Syntax for invoking shar, tar and zip differs from that for Unix.

=cut

sub zipfile_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
$(DISTVNAME).zip : distdir
	$(PREOP)
	$(ZIP) "$(ZIPFLAGS)" $(MMS$TARGET) [.$(DISTVNAME)...]*.*;
	$(RM_RF) $(DISTVNAME)
	$(POSTOP)
MAKE_FRAG
}

sub tarfile_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
$(DISTVNAME).tar$(SUFFIX) : distdir
	$(PREOP)
	$(TO_UNIX)
        $(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)...]
	$(RM_RF) $(DISTVNAME)
	$(COMPRESS) $(DISTVNAME).tar
	$(POSTOP)
MAKE_FRAG
}

sub shdist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
shdist : distdir
	$(PREOP)
	$(SHAR) [.$(DISTVNAME)...]*.*; $(DISTVNAME).share
	$(RM_RF) $(DISTVNAME)
	$(POSTOP)
MAKE_FRAG
}


# --- Test and Installation Sections ---

=item install (override)

Work around DCL's 255 character limit several times,and use
VMS-style command line quoting in a few cases.

=cut

sub install {
    my($self, %attribs) = @@_;
    my(@@m);

    push @@m, q[
install :: all pure_install doc_install
	$(NOECHO) $(NOOP)

install_perl :: all pure_perl_install doc_perl_install
	$(NOECHO) $(NOOP)

install_site :: all pure_site_install doc_site_install
	$(NOECHO) $(NOOP)

pure_install :: pure_$(INSTALLDIRS)_install
	$(NOECHO) $(NOOP)

doc_install :: doc_$(INSTALLDIRS)_install
        $(NOECHO) $(NOOP)

pure__install : pure_site_install
	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"

doc__install : doc_site_install
	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"

# This hack brought to you by DCL's 255-character command line limit
pure_perl_install ::
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLPRIVLIB) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLARCHLIB) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLBIN) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLMAN3DIR) " >>.MM_tmp
	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
	$(NOECHO) $(RM_F) .MM_tmp
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[

# Likewise
pure_site_install ::
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLSITELIB) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLSITEARCH) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLSITEBIN) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLSITEMAN1DIR) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLSITEMAN3DIR) " >>.MM_tmp
	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
	$(NOECHO) $(RM_F) .MM_tmp
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[

pure_vendor_install ::
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLVENDORLIB) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLVENDORARCH) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLVENDORBIN) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLVENDORMAN1DIR) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLVENDORMAN3DIR) " >>.MM_tmp
	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
	$(NOECHO) $(RM_F) .MM_tmp

# Ditto
doc_perl_install ::
	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLPRIVLIB)|" >.MM_tmp
	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
	$(NOECHO) $(RM_F) .MM_tmp

# And again
doc_site_install ::
	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLSITELIB)|" >.MM_tmp
	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
	$(NOECHO) $(RM_F) .MM_tmp

doc_vendor_install ::
	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLVENDORLIB)|" >.MM_tmp
	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
	$(NOECHO) $(RM_F) .MM_tmp

];

    push @@m, q[
uninstall :: uninstall_from_$(INSTALLDIRS)dirs
	$(NOECHO) $(NOOP)

uninstall_from_perldirs ::
	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
	$(NOECHO) $(ECHO) "Uninstall is now deprecated and makes no actual changes."
	$(NOECHO) $(ECHO) "Please check the list above carefully for errors, and manually remove"
	$(NOECHO) $(ECHO) "the appropriate files.  Sorry for the inconvenience."

uninstall_from_sitedirs ::
	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
	$(NOECHO) $(ECHO) "Uninstall is now deprecated and makes no actual changes."
	$(NOECHO) $(ECHO) "Please check the list above carefully for errors, and manually remove"
	$(NOECHO) $(ECHO) "the appropriate files.  Sorry for the inconvenience."
];

    join('',@@m);
}

=item perldepend (override)

Use VMS-style syntax for files; it's cheaper to just do it directly here
than to have the MM_Unix method call C<catfile> repeatedly.  Also, if
we have to rebuild Config.pm, use MM[SK] to do it.

=cut

sub perldepend {
    my($self) = @@_;
    my(@@m);

    push @@m, '
$(OBJECT) : $(PERL_INC)EXTERN.h, $(PERL_INC)INTERN.h, $(PERL_INC)XSUB.h
$(OBJECT) : $(PERL_INC)av.h, $(PERL_INC)cc_runtime.h, $(PERL_INC)config.h
$(OBJECT) : $(PERL_INC)cop.h, $(PERL_INC)cv.h, $(PERL_INC)embed.h
$(OBJECT) : $(PERL_INC)embedvar.h, $(PERL_INC)form.h
$(OBJECT) : $(PERL_INC)gv.h, $(PERL_INC)handy.h, $(PERL_INC)hv.h
$(OBJECT) : $(PERL_INC)intrpvar.h, $(PERL_INC)iperlsys.h, $(PERL_INC)keywords.h
$(OBJECT) : $(PERL_INC)mg.h, $(PERL_INC)nostdio.h, $(PERL_INC)op.h
$(OBJECT) : $(PERL_INC)opcode.h, $(PERL_INC)patchlevel.h
$(OBJECT) : $(PERL_INC)perl.h, $(PERL_INC)perlio.h
$(OBJECT) : $(PERL_INC)perlsdio.h, $(PERL_INC)perlvars.h
$(OBJECT) : $(PERL_INC)perly.h, $(PERL_INC)pp.h, $(PERL_INC)pp_proto.h
$(OBJECT) : $(PERL_INC)proto.h, $(PERL_INC)regcomp.h, $(PERL_INC)regexp.h
$(OBJECT) : $(PERL_INC)regnodes.h, $(PERL_INC)scope.h, $(PERL_INC)sv.h
$(OBJECT) : $(PERL_INC)thread.h, $(PERL_INC)util.h, $(PERL_INC)vmsish.h

' if $self->{OBJECT}; 

    if ($self->{PERL_SRC}) {
	my(@@macros);
	my($mmsquals) = '$(USEMAKEFILE)[.vms]$(FIRST_MAKEFILE)';
	push(@@macros,'__AXP__=1') if $Config{'archname'} eq 'VMS_AXP';
	push(@@macros,'DECC=1')    if $Config{'vms_cc_type'} eq 'decc';
	push(@@macros,'GNUC=1')    if $Config{'vms_cc_type'} eq 'gcc';
	push(@@macros,'SOCKET=1')  if $Config{'d_has_sockets'};
	push(@@macros,qq["CC=$Config{'cc'}"])  if $Config{'cc'} =~ m!/!;
	$mmsquals .= '$(USEMACROS)' . join(',',@@macros) . '$(MACROEND)' if @@macros;
	push(@@m,q[
# Check for unpropagated config.sh changes. Should never happen.
# We do NOT just update config.h because that is not sufficient.
# An out of date config.h is not fatal but complains loudly!
$(PERL_INC)config.h : $(PERL_SRC)config.sh
	$(NOOP)

$(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh
	$(NOECHO) Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.h or genconfig.pl"
	olddef = F$Environment("Default")
	Set Default $(PERL_SRC)
	$(MMS)],$mmsquals,);
	if ($self->{PERL_ARCHLIB} =~ m|\[-| && $self->{PERL_SRC} =~ m|(\[-+)|) {
	    my($prefix,$target) = ($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm',0));
	    $target =~ s/\Q$prefix/[/;
	    push(@@m," $target");
	}
	else { push(@@m,' $(MMS$TARGET)'); }
	push(@@m,q[
	Set Default 'olddef'
]);
    }

    push(@@m, join(" ", map($self->fixpath($_,0),values %{$self->{XS}}))." : \$(XSUBPPDEPS)\n")
      if %{$self->{XS}};

    join('',@@m);
}


=item makeaperl (override)

Undertake to build a new set of Perl images using VMS commands.  Since
VMS does dynamic loading, it's not necessary to statically link each
extension into the Perl image, so this isn't the normal build path.
Consequently, it hasn't really been tested, and may well be incomplete.

=cut

our %olbs;  # needs to be localized

sub makeaperl {
    my($self, %attribs) = @@_;
    my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmpdir, $libperl) = 
      @@attribs{qw(MAKE DIRS STAT EXTRA INCL TARGET TMP LIBPERL)};
    my(@@m);
    push @@m, "
# --- MakeMaker makeaperl section ---
MAP_TARGET    = $target
";
    return join '', @@m if $self->{PARENT};

    my($dir) = join ":", @@{$self->{DIR}};

    unless ($self->{MAKEAPERL}) {
	push @@m, q{
$(MAKE_APERL_FILE) : $(FIRST_MAKEFILE)
	$(NOECHO) $(ECHO) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
	$(NOECHO) $(PERLRUNINST) \
		Makefile.PL DIR=}, $dir, q{ \
		FIRST_MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
		MAKEAPERL=1 NORECURS=1 };

	push @@m, map(q[ \\\n\t\t"$_"], @@ARGV),q{

$(MAP_TARGET) :: $(MAKE_APERL_FILE)
	$(MAKE)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
};
	push @@m, "\n";

	return join '', @@m;
    }


    my($linkcmd,@@optlibs,@@staticpkgs,$extralist,$targdir,$libperldir,%libseen);
    local($_);

    # The front matter of the linkcommand...
    $linkcmd = join ' ', $Config{'ld'},
	    grep($_, @@Config{qw(large split ldflags ccdlflags)});
    $linkcmd =~ s/\s+/ /g;

    # Which *.olb files could we make use of...
    local(%olbs);       # XXX can this be lexical?
    $olbs{$self->{INST_ARCHAUTODIR}} = "$self->{BASEEXT}\$(LIB_EXT)";
    require File::Find;
    File::Find::find(sub {
	return unless m/\Q$self->{LIB_EXT}\E$/;
	return if m/^libperl/;

	if( exists $self->{INCLUDE_EXT} ){
		my $found = 0;

		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
		$xx =~ s,/?$_,,;
		$xx =~ s,/,::,g;

		# Throw away anything not explicitly marked for inclusion.
		# DynaLoader is implied.
		foreach my $incl ((@@{$self->{INCLUDE_EXT}},'DynaLoader')){
			if( $xx eq $incl ){
				$found++;
				last;
			}
		}
		return unless $found;
	}
	elsif( exists $self->{EXCLUDE_EXT} ){
		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
		$xx =~ s,/?$_,,;
		$xx =~ s,/,::,g;

		# Throw away anything explicitly marked for exclusion
		foreach my $excl (@@{$self->{EXCLUDE_EXT}}){
			return if( $xx eq $excl );
		}
	}

	$olbs{$ENV{DEFAULT}} = $_;
    }, grep( -d $_, @@{$searchdirs || []}));

    # We trust that what has been handed in as argument will be buildable
    $static = [] unless $static;
    @@olbs{@@{$static}} = (1) x @@{$static};
 
    $extra = [] unless $extra && ref $extra eq 'ARRAY';
    # Sort the object libraries in inverse order of
    # filespec length to try to insure that dependent extensions
    # will appear before their parents, so the linker will
    # search the parent library to resolve references.
    # (e.g. Intuit::DWIM will precede Intuit, so unresolved
    # references from [.intuit.dwim]dwim.obj can be found
    # in [.intuit]intuit.olb).
    for (sort { length($a) <=> length($b) } keys %olbs) {
	next unless $olbs{$_} =~ /\Q$self->{LIB_EXT}\E$/;
	my($dir) = $self->fixpath($_,1);
	my($extralibs) = $dir . "extralibs.ld";
	my($extopt) = $dir . $olbs{$_};
	$extopt =~ s/$self->{LIB_EXT}$/.opt/;
	push @@optlibs, "$dir$olbs{$_}";
	# Get external libraries this extension will need
	if (-f $extralibs ) {
	    my %seenthis;
	    open my $list, "<", $extralibs or warn $!,next;
	    while (<$list>) {
		chomp;
		# Include a library in the link only once, unless it's mentioned
		# multiple times within a single extension's options file, in which
		# case we assume the builder needed to search it again later in the
		# link.
		my $skip = exists($libseen{$_}) && !exists($seenthis{$_});
		$libseen{$_}++;  $seenthis{$_}++;
		next if $skip;
		push @@$extra,$_;
	    }
	}
	# Get full name of extension for ExtUtils::Miniperl
	if (-f $extopt) {
	    open my $opt, '<', $extopt or die $!;
	    while (<$opt>) {
		next unless /(?:UNIVERSAL|VECTOR)=boot_([\w_]+)/;
		my $pkg = $1;
		$pkg =~ s#__*#::#g;
		push @@staticpkgs,$pkg;
	    }
	}
    }
    # Place all of the external libraries after all of the Perl extension
    # libraries in the final link, in order to maximize the opportunity
    # for XS code from multiple extensions to resolve symbols against the
    # same external library while only including that library once.
    push @@optlibs, @@$extra;

    $target = "Perl$Config{'exe_ext'}" unless $target;
    my $shrtarget;
    ($shrtarget,$targdir) = fileparse($target);
    $shrtarget =~ s/^([^.]*)/$1Shr/;
    $shrtarget = $targdir . $shrtarget;
    $target = "Perlshr.$Config{'dlext'}" unless $target;
    $tmpdir = "[]" unless $tmpdir;
    $tmpdir = $self->fixpath($tmpdir,1);
    if (@@optlibs) { $extralist = join(' ',@@optlibs); }
    else          { $extralist = ''; }
    # Let ExtUtils::Liblist find the necessary libs for us (but skip PerlShr)
    # that's what we're building here).
    push @@optlibs, grep { !/PerlShr/i } split ' ', +($self->ext())[2];
    if ($libperl) {
	unless (-f $libperl || -f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',$libperl))) {
	    print STDOUT "Warning: $libperl not found\n";
	    undef $libperl;
	}
    }
    unless ($libperl) {
	if (defined $self->{PERL_SRC}) {
	    $libperl = $self->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}");
	} elsif (-f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}")) ) {
	} else {
	    print STDOUT "Warning: $libperl not found
    If you're going to build a static perl binary, make sure perl is installed
    otherwise ignore this warning\n";
	}
    }
    $libperldir = $self->fixpath((fileparse($libperl))[1],1);

    push @@m, '
# Fill in the target you want to produce if it\'s not perl
MAP_TARGET    = ',$self->fixpath($target,0),'
MAP_SHRTARGET = ',$self->fixpath($shrtarget,0),"
MAP_LINKCMD   = $linkcmd
MAP_PERLINC   = ", $perlinc ? map('"$_" ',@@{$perlinc}) : '',"
MAP_EXTRA     = $extralist
MAP_LIBPERL = ",$self->fixpath($libperl,0),'
';


    push @@m,"\n${tmpdir}Makeaperl.Opt : \$(MAP_EXTRA)\n";
    foreach (@@optlibs) {
	push @@m,'	$(NOECHO) $(PERL) -e "print q{',$_,'}" >>$(MMS$TARGET)',"\n";
    }
    push @@m,"\n${tmpdir}PerlShr.Opt :\n\t";
    push @@m,'$(NOECHO) $(PERL) -e "print q{$(MAP_SHRTARGET)}" >$(MMS$TARGET)',"\n";

    push @@m,'
$(MAP_SHRTARGET) : $(MAP_LIBPERL) Makeaperl.Opt ',"${libperldir}Perlshr_Attr.Opt",'
	$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_LIBPERL), Makeaperl.Opt/Option ',"${libperldir}Perlshr_Attr.Opt/Option",'
$(MAP_TARGET) : $(MAP_SHRTARGET) ',"${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}PerlShr.Opt",'
	$(MAP_LINKCMD) ',"${tmpdir}perlmain\$(OBJ_EXT)",', PerlShr.Opt/Option
	$(NOECHO) $(ECHO) "To install the new ""$(MAP_TARGET)"" binary, say"
	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
	$(NOECHO) $(ECHO) "To remove the intermediate files, say
	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
';
    push @@m,"\n${tmpdir}perlmain.c : \$(FIRST_MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmpdir}Writemain.tmp\n";
    push @@m, "# More from the 255-char line length limit\n";
    foreach (@@staticpkgs) {
	push @@m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmpdir}Writemain.tmp\n];
    }

    push @@m, sprintf <<'MAKE_FRAG', $tmpdir, $tmpdir;
	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@@F)" %sWritemain.tmp >$(MMS$TARGET)
	$(NOECHO) $(RM_F) %sWritemain.tmp
MAKE_FRAG

    push @@m, q[
# Still more from the 255-char line length limit
doc_inst_perl :
	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	$(NOECHO) $(ECHO) "Perl binary $(MAP_TARGET)|" >.MM_tmp
	$(NOECHO) $(ECHO) "MAP_STATIC|$(MAP_STATIC)|" >>.MM_tmp
	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
	$(NOECHO) $(ECHO) -e "MAP_LIBPERL|$(MAP_LIBPERL)|" >>.MM_tmp
	$(NOECHO) $(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q[
	$(NOECHO) $(RM_F) .MM_tmp
];

    push @@m, "
inst_perl : pure_inst_perl doc_inst_perl
	\$(NOECHO) \$(NOOP)

pure_inst_perl : \$(MAP_TARGET)
	$self->{CP} \$(MAP_SHRTARGET) ",$self->fixpath($Config{'installbin'},1),"
	$self->{CP} \$(MAP_TARGET) ",$self->fixpath($Config{'installbin'},1),"

clean :: map_clean
	\$(NOECHO) \$(NOOP)

map_clean :
	\$(RM_F) ${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}perlmain.c \$(FIRST_MAKEFILE)
	\$(RM_F) ${tmpdir}Makeaperl.Opt ${tmpdir}PerlShr.Opt \$(MAP_TARGET)
";

    join '', @@m;
}


# --- Output postprocessing section ---

=item maketext_filter (override)

Insure that colons marking targets are preceded by space, in order
to distinguish the target delimiter from a colon appearing as
part of a filespec.

=cut

sub maketext_filter {
    my($self, $text) = @@_;

    $text =~ s/^([^\s:=]+)(:+\s)/$1 $2/mg;
    return $text;
}

=item prefixify (override)

prefixifying on VMS is simple.  Each should simply be:

    perl_root:[some.dir]

which can just be converted to:

    volume:[your.prefix.some.dir]

otherwise you get the default layout.

In effect, your search prefix is ignored and $Config{vms_prefix} is
used instead.

=cut

sub prefixify {
    my($self, $var, $sprefix, $rprefix, $default) = @@_;

    # Translate $(PERLPREFIX) to a real path.
    $rprefix = $self->eliminate_macros($rprefix);
    $rprefix = vmspath($rprefix) if $rprefix;
    $sprefix = vmspath($sprefix) if $sprefix;

    $default = vmsify($default) 
      unless $default =~ /\[.*\]/;

    (my $var_no_install = $var) =~ s/^install//;
    my $path = $self->{uc $var} || 
               $ExtUtils::MM_Unix::Config_Override{lc $var} || 
               $Config{lc $var} || $Config{lc $var_no_install};

    if( !$path ) {
        print STDERR "  no Config found for $var.\n" if $Verbose >= 2;
        $path = $self->_prefixify_default($rprefix, $default);
    }
    elsif( !$self->{ARGS}{PREFIX} || !$self->file_name_is_absolute($path) ) {
        # do nothing if there's no prefix or if its relative
    }
    elsif( $sprefix eq $rprefix ) {
        print STDERR "  no new prefix.\n" if $Verbose >= 2;
    }
    else {

        print STDERR "  prefixify $var => $path\n"     if $Verbose >= 2;
        print STDERR "    from $sprefix to $rprefix\n" if $Verbose >= 2;

        my($path_vol, $path_dirs) = $self->splitpath( $path );
        if( $path_vol eq $Config{vms_prefix}.':' ) {
            print STDERR "  $Config{vms_prefix}: seen\n" if $Verbose >= 2;

            $path_dirs =~ s{^\[}{\[.} unless $path_dirs =~ m{^\[\.};
            $path = $self->_catprefix($rprefix, $path_dirs);
        }
        else {
            $path = $self->_prefixify_default($rprefix, $default);
        }
    }

    print "    now $path\n" if $Verbose >= 2;
    return $self->{uc $var} = $path;
}


sub _prefixify_default {
    my($self, $rprefix, $default) = @@_;

    print STDERR "  cannot prefix, using default.\n" if $Verbose >= 2;

    if( !$default ) {
        print STDERR "No default!\n" if $Verbose >= 1;
        return;
    }
    if( !$rprefix ) {
        print STDERR "No replacement prefix!\n" if $Verbose >= 1;
        return '';
    }

    return $self->_catprefix($rprefix, $default);
}

sub _catprefix {
    my($self, $rprefix, $default) = @@_;

    my($rvol, $rdirs) = $self->splitpath($rprefix);
    if( $rvol ) {
        return $self->catpath($rvol,
                                   $self->catdir($rdirs, $default),
                                   ''
                                  )
    }
    else {
        return $self->catdir($rdirs, $default);
    }
}


=item cd

=cut

sub cd {
    my($self, $dir, @@cmds) = @@_;

    $dir = vmspath($dir);

    my $cmd = join "\n\t", map "$_", @@cmds;

    # No leading tab makes it look right when embedded
    my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd;
startdir = F$Environment("Default")
	Set Default %s
	%s
	Set Default 'startdir'
MAKE_FRAG

    # No trailing newline makes this easier to embed
    chomp $make_frag;

    return $make_frag;
}


=item oneliner

=cut

sub oneliner {
    my($self, $cmd, $switches) = @@_;
    $switches = [] unless defined $switches;

    # Strip leading and trailing newlines
    $cmd =~ s{^\n+}{};
    $cmd =~ s{\n+$}{};

    $cmd = $self->quote_literal($cmd);
    $cmd = $self->escape_newlines($cmd);

    # Switches must be quoted else they will be lowercased.
    $switches = join ' ', map { qq{"$_"} } @@$switches;

    return qq{\$(ABSPERLRUN) $switches -e $cmd "--"};
}


=item B<echo>

perl trips up on "<foo>" thinking it's an input redirect.  So we use the
native Write command instead.  Besides, its faster.

=cut

sub echo {
    my($self, $text, $file, $appending) = @@_;
    $appending ||= 0;

    my $opencmd = $appending ? 'Open/Append' : 'Open/Write';

    my @@cmds = ("\$(NOECHO) $opencmd MMECHOFILE $file ");
    push @@cmds, map { '$(NOECHO) Write MMECHOFILE '.$self->quote_literal($_) } 
                split /\n/, $text;
    push @@cmds, '$(NOECHO) Close MMECHOFILE';
    return @@cmds;
}


=item quote_literal

=cut

sub quote_literal {
    my($self, $text) = @@_;

    # I believe this is all we should need.
    $text =~ s{"}{""}g;

    return qq{"$text"};
}

=item escape_newlines

=cut

sub escape_newlines {
    my($self, $text) = @@_;

    $text =~ s{\n}{-\n}g;

    return $text;
}

=item max_exec_len

256 characters.

=cut

sub max_exec_len {
    my $self = shift;

    return $self->{_MAX_EXEC_LEN} ||= 256;
}

=item init_linker

=cut

sub init_linker {
    my $self = shift;
    $self->{EXPORT_LIST} ||= '$(BASEEXT).opt';

    my $shr = $Config{dbgprefix} . 'PERLSHR';
    if ($self->{PERL_SRC}) {
        $self->{PERL_ARCHIVE} ||=
          $self->catfile($self->{PERL_SRC}, "$shr.$Config{'dlext'}");
    }
    else {
        $self->{PERL_ARCHIVE} ||=
          $ENV{$shr} ? $ENV{$shr} : "Sys\$Share:$shr.$Config{'dlext'}";
    }

    $self->{PERL_ARCHIVE_AFTER} ||= '';
}


=item catdir (override)

=item catfile (override)

Eliminate the macros in the output to the MMS/MMK file.

(File::Spec::VMS used to do this for us, but it's being removed)

=cut

sub catdir {
    my $self = shift;

    # Process the macros on VMS MMS/MMK
    my @@args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @@_;

    my $dir = $self->SUPER::catdir(@@args);

    # Fix up the directory and force it to VMS format.
    $dir = $self->fixpath($dir, 1);

    return $dir;
}

sub catfile {
    my $self = shift;

    # Process the macros on VMS MMS/MMK
    my @@args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @@_;

    my $file = $self->SUPER::catfile(@@args);

    $file = vmsify($file);

    return $file
}


=item eliminate_macros

Expands MM[KS]/Make macros in a text string, using the contents of
identically named elements of C<%$self>, and returns the result
as a file specification in Unix syntax.

NOTE:  This is the canonical version of the method.  The version in
File::Spec::VMS is deprecated.

=cut

sub eliminate_macros {
    my($self,$path) = @@_;
    return '' unless $path;
    $self = {} unless ref $self;

    if ($path =~ /\s/) {
      return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
    }

    my($npath) = unixify($path);
    # sometimes unixify will return a string with an off-by-one trailing null
    $npath =~ s{\0$}{};

    my($complex) = 0;
    my($head,$macro,$tail);

    # perform m##g in scalar context so it acts as an iterator
    while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
        if (defined $self->{$2}) {
            ($head,$macro,$tail) = ($1,$2,$3);
            if (ref $self->{$macro}) {
                if (ref $self->{$macro} eq 'ARRAY') {
                    $macro = join ' ', @@{$self->{$macro}};
                }
                else {
                    print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                          "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                    $macro = "\cB$macro\cB";
                    $complex = 1;
                }
            }
            else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
            $npath = "$head$macro$tail";
        }
    }
    if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
    $npath;
}

=item fixpath

   my $path = $mm->fixpath($path);
   my $path = $mm->fixpath($path, $is_dir);

Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
in any directory specification, in order to avoid juxtaposing two
VMS-syntax directories when MM[SK] is run.  Also expands expressions which
are all macro, so that we can tell how long the expansion is, and avoid
overrunning DCL's command buffer when MM[KS] is running.

fixpath() checks to see whether the result matches the name of a
directory in the current default directory and returns a directory or
file specification accordingly.  C<$is_dir> can be set to true to
force fixpath() to consider the path to be a directory or false to force
it to be a file.

NOTE:  This is the canonical version of the method.  The version in
File::Spec::VMS is deprecated.

=cut

sub fixpath {
    my($self,$path,$force_path) = @@_;
    return '' unless $path;
    $self = bless {}, $self unless ref $self;
    my($fixedpath,$prefix,$name);

    if ($path =~ /[ \t]/) {
      return join ' ',
             map { $self->fixpath($_,$force_path) }
	     split /[ \t]+/, $path;
    }

    if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
        if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
            $fixedpath = vmspath($self->eliminate_macros($path));
        }
        else {
            $fixedpath = vmsify($self->eliminate_macros($path));
        }
    }
    elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
        my($vmspre) = $self->eliminate_macros("\$($prefix)");
        # is it a dir or just a name?
        $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
        $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    else {
        $fixedpath = $path;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    # No hints, so we try to guess
    if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
        $fixedpath = vmspath($fixedpath) if -d $fixedpath;
    }

    # Trim off root dirname if it's had other dirs inserted in front of it.
    $fixedpath =~ s/\.000000([\]>])/$1/;
    # Special case for VMS absolute directory specs: these will have had device
    # prepended during trip through Unix syntax in eliminate_macros(), since
    # Unix syntax has no way to express "absolute from the top of this device's
    # directory tree".
    if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }

    return $fixedpath;
}


=item os_flavor

VMS is VMS.

=cut

sub os_flavor {
    return('VMS');
}

=back


=head1 AUTHOR

Original author Charles Bailey F<bailey@@newman.upenn.edu>

Maintained by Michael G Schwern F<schwern@@pobox.com>

See L<ExtUtils::MakeMaker> for patching and contact information.


=cut

1;

@


1.10
log
@Merge in perl 5.10.1
@
text
@@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d18 1
a18 4
# $Revision can't be on the same line or SVN/K gets confused
use vars qw($Revision
            $VERSION @@ISA);
$VERSION = '6.42';
d22 1
a22 1
@@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
d25 1
a25 1
$Revision = $ExtUtils::MakeMaker::Revision;
d107 1
a107 1
    my($defname,$defpm,@@pm,%xs,$pm);
d118 2
a119 1
      @@pm = map { s/.pm$//; $_ } glob('*.pm');
d122 1
a122 1
        %xs = map { s/.xs$//; ($_,1) } glob('*.xs');
d124 1
a124 1
            foreach $pm (@@pm) { 
d130 2
a131 2
    if (open(PM,"${defpm}.pm")){
        while (<PM>) {
d139 2
a140 2
            if eof(PM);
        close PM;
d159 1
a159 1
    my($name,$dir,$vmsfile,@@sdirs,@@snames,@@cand);
d191 1
a191 1
    foreach $name (@@snames) { $name =~ s/\.(\d+)$/_$1/; }
d193 22
a214 19
	print "Looking for perl $ver by these names:\n";
	print "\t@@snames,\n";
	print "in these dirs:\n";
	print "\t@@sdirs\n";
    }
    foreach $dir (@@sdirs){
	next unless defined $dir; # $self->{PERL_SRC} may be undefined
	$inabs++ if $self->file_name_is_absolute($dir);
	if ($inabs == 1) {
	    # We've covered relative dirs; everything else is an absolute
	    # dir (probably an installed location).  First, we'll try potential
	    # command names, to see whether we can avoid a long MCR expression.
	    foreach $name (@@snames) { push(@@cand,$name) if $name =~ /^[\w\-\$]+$/; }
	    $inabs++; # Should happen above in next $dir, but just in case . . .
	}
	foreach $name (@@snames){
	    if ($name !~ m![/:>\]]!) { push(@@cand,$self->catfile($dir,$name)); }
	    else                     { push(@@cand,$self->fixpath($name,0));    }
	}
d216 3
a218 3
    foreach $name (@@cand) {
	print "Checking $name\n" if ($trace >= 2);
	# If it looks like a potential command, try it without the MCR
d220 5
a224 4
            open(TCF,">temp_mmvms.com") || die('unable to open temp file');
            print TCF "\$ set message/nofacil/nosever/noident/notext\n";
            print TCF "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";
            close TCF;
d232 8
a239 7
	next unless $vmsfile = $self->maybe_command($name);
	$vmsfile =~ s/;[\d\-]*$//;  # Clip off version number; we can use a newer version as well
	print "Executing $vmsfile\n" if ($trace >= 2);
        open(TCF,">temp_mmvms.com") || die('unable to open temp file');
        print TCF "\$ set message/nofacil/nosever/noident/notext\n";
        print TCF "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";
        close TCF;
d243 3
a245 3
	    print "Using PERL=MCR $vmsfile\n" if $trace;
	    return "MCR $vmsfile";
	}
d267 1
a267 1
    my($dir,$ext);
d269 12
a280 12
	for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
	    $dir = $ENV{"DCL\$PATH;$i"};
	    $dir .= ':' unless $dir =~ m%[\]:]$%;
	    push(@@dirs,$dir);
	}
	push(@@dirs,'Sys$System:');
	foreach $dir (@@dirs) {
	    my $sysfile = "$dir$file";
	    foreach $ext (@@exts) {
		return $file if -x "$sysfile$ext" && ! -d _;
	    }
	}
d375 1
a375 1
        $self->{$destvar} = File::Spec->eliminate_macros($self->{$destvar});
d453 1
a453 1
    $self->{MAKEFILE}		||= $self->{FIRST_MAKEFILE} || 'Descrip.MMS';
a471 7
    $self->{ECHO}     ||= '$(ABSPERLRUN) -le "print qq{@@ARGV}"';
    $self->{ECHO_N}   ||= '$(ABSPERLRUN) -e  "print qq{@@ARGV}"';
    $self->{TOUCH}    ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e touch';
    $self->{CHMOD}    ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e chmod'; 
    $self->{RM_F}     ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e rm_f';
    $self->{RM_RF}    ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e rm_rf';
    $self->{TEST_F}   ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e test_f';
d476 1
a476 1
install({split(' ',<STDIN>)}, '$(VERBINST)', 0, '$(UNINST)');
a478 2
    $self->{SHELL}    ||= 'Posix';

d481 1
a481 3
    # So we can copy files into directories with less fuss
    $self->{CP}         = '$(ABSPERLRUN) "-MExtUtils::Command" -e cp';
    $self->{MV}         = '$(ABSPERLRUN) "-MExtUtils::Command" -e mv';
d844 4
a847 1
    $self->{DISTVNAME}    = "$self->{DISTNAME}-$self->{VERSION_SYM}";
d952 18
a969 15
       # Upcase module names if linker is being case-sensitive
       my($upcase) = $Config{d_vms_case_sensitive_symbols};
	my(@@omods) = map { s/\.[^.]*$//;         # Trim off file type
	                   s[\$\(\w+_EXT\)][];   # even as a macro
	                   s/.*[:>\/\]]//;       # Trim off dir spec
			   $upcase ? uc($_) : $_;
	                 } split ' ', $self->eliminate_macros($self->{OBJECT});
        my($tmp,@@lines,$elt) = '';
	$tmp = shift @@omods;
	foreach $elt (@@omods) {
	    $tmp .= ",$elt";
		if (length($tmp) > 80) { push @@lines, $tmp;  $tmp = ''; }
	}
	push @@lines, $tmp;
	push @@m, '(', join( qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""], @@lines),')';
d971 1
a971 1
	push @@m, '\n$(INST_STATIC)/Library\n"";" >>$(MMS$TARGET)',"\n";
d974 10
a983 10
	my($lib); my($line) = '';
	foreach $lib (split ' ', $self->{LDLOADLIBS}) {
	    $lib =~ s%\$%\\\$%g;  # Escape '$' in VMS filespecs
	    if (length($line) + length($lib) > 160) {
		push @@m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";
		$line = $lib . '\n';
	    }
	    else { $line .= $lib . '\n'; }
	}
	push @@m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if $line;
d1037 1
a1037 1
    my(@@m,$lib);
d1060 1
a1060 1
    foreach $lib (split ' ', $self->{EXTRALIBS}) {
d1332 1
a1332 1
use vars qw(%olbs);
a1384 2
		my $incl;
		my $xx;
d1386 1
a1386 1
		($xx = $File::Find::name) =~ s,.*?/auto/,,;
d1392 1
a1392 1
		foreach $incl ((@@{$self->{INCLUDE_EXT}},'DynaLoader')){
d1401 1
a1401 4
		my $excl;
		my $xx;

		($xx = $File::Find::name) =~ s,.*?/auto/,,;
d1406 1
a1406 1
		foreach $excl (@@{$self->{EXCLUDE_EXT}}){
d1436 2
a1437 2
	    open LIST,$extralibs or warn $!,next;
	    while (<LIST>) {
a1447 1
	    close LIST;
d1451 2
a1452 2
	    open OPT,$extopt or die $!;
	    while (<OPT>) {
d1567 1
d1607 2
a1608 2
    $rprefix = VMS::Filespec::vmspath($rprefix) if $rprefix;
    $sprefix = VMS::Filespec::vmspath($sprefix) if $sprefix;
d1610 1
a1610 1
    $default = VMS::Filespec::vmsify($default) 
d1810 39
d1924 1
a1924 1
    $self = bless {} unless ref $self;
@


1.8
log
@merge in perl 5.8.8
@
text
@d21 1
a21 1
$VERSION = '5.73';
d286 1
a286 1
options.  This is used in every invokation of make in the VMS Makefile so
d450 1
a450 1
    $self->{MAKEFILE}           ||= 'Descrip.MMS';
d453 11
a463 1
    $self->{MAKEFILE_OLD}       ||= '$(FIRST_MAKEFILE)_old';
d1282 1
a1282 2
$(OBJECT) : $(PERL_INC)thrdvar.h, $(PERL_INC)thread.h
$(OBJECT) : $(PERL_INC)util.h, $(PERL_INC)vmsish.h
d1574 1
a1574 1
  
d1577 1
a1577 1
=item nicetext (override)
d1585 5
a1589 5
sub nicetext {
    my($self,$text) = @@_;
    return $text if $text =~ m/^\w+\s*=/; # leave macro defs alone
    $text =~ s/([^\s:])(:+\s)/$1 $2/gs;
    $text;
d1734 1
a1734 1
    return qq{\$(ABSPERLRUN) $switches -e $cmd};
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@a0 5
#   MM_VMS.pm
#   MakeMaker default methods for VMS
#
#   Author:  Charles Bailey  bailey@@newman.upenn.edu

d5 1
a5 1
use Config;
d17 5
a21 3
use vars qw($Revision @@ISA $VERSION);
($VERSION) = '5.70';
($Revision) = q$Revision: 1.110 $ =~ /Revision:\s+(\S+)/;
d28 1
d282 45
d343 1
d455 12
a466 8
    $self->{ECHO}     ||= '$(PERLRUN) -le "print qq{@@ARGV}"';
    $self->{ECHO_N}   ||= '$(PERLRUN) -e  "print qq{@@ARGV}"';
    $self->{TOUCH}    ||= '$(PERLRUN) "-MExtUtils::Command" -e touch';
    $self->{CHMOD}    ||= '$(PERLRUN) "-MExtUtils::Command" -e chmod'; 
    $self->{RM_F}     ||= '$(PERLRUN) "-MExtUtils::Command" -e rm_f';
    $self->{RM_RF}    ||= '$(PERLRUN) "-MExtUtils::Command" -e rm_rf';
    $self->{TEST_F}   ||= '$(PERLRUN) "-MExtUtils::Command" -e test_f';
    $self->{EQUALIZE_TIMESTAMP} ||= '$(PERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';
d475 6
a480 2
    $self->{CP} = 'Copy/NoConfirm';
    $self->{MV} = 'Rename/NoConfirm';
d483 4
a486 1
    $self->SUPER::init_others;
d621 3
a784 56
=item tool_sxubpp (override)

Use VMS-style quoting on xsubpp command line.

=cut

sub tool_xsubpp {
    my($self) = @@_;
    return '' unless $self->needs_linking;

    my $xsdir;
    foreach my $dir (@@INC) {
        $xsdir = $self->catdir($dir, 'ExtUtils');
        if( -r $self->catfile($xsdir, "xsubpp") ) {
            last;
        }
    }

    my $tmdir   = File::Spec->catdir($self->{PERL_LIB},"ExtUtils");
    my(@@tmdeps) = $self->catfile($tmdir,'typemap');
    if( $self->{TYPEMAPS} ){
	my $typemap;
	foreach $typemap (@@{$self->{TYPEMAPS}}){
		if( ! -f  $typemap ){
			warn "Typemap $typemap not found.\n";
		}
		else{
			push(@@tmdeps, $self->fixpath($typemap,0));
		}
	}
    }
    push(@@tmdeps, "typemap") if -f "typemap";
    my(@@tmargs) = map("-typemap $_", @@tmdeps);
    if( exists $self->{XSOPT} ){
	unshift( @@tmargs, $self->{XSOPT} );
    }

    if ($Config{'ldflags'} && 
        $Config{'ldflags'} =~ m!/Debug!i &&
        (!exists($self->{XSOPT}) || $self->{XSOPT} !~ /linenumbers/)) {
        unshift(@@tmargs,'-nolinenumbers');
    }


    $self->{XSPROTOARG} = '' unless defined $self->{XSPROTOARG};

    return "
XSUBPPDIR = $xsdir
XSUBPP = \$(PERLRUN) \$(XSUBPPDIR)xsubpp
XSPROTOARG = $self->{XSPROTOARG}
XSUBPPDEPS = @@tmdeps
XSUBPPARGS = @@tmargs
";
}


a799 7
# Assumes $(MMS) invokes MMS or MMK
# (It is assumed in some cases later that the default makefile name
# (Descrip.MMS for MM[SK]) is used.)
USEMAKEFILE = /Descrip=
USEMACROS = /Macro=(
MACROEND = )

d801 1
d879 1
a879 1
	$(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET)
d894 1
a894 1
	$(XSUBPP) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).c
d1005 1
a1005 2
$(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt $(INST_ARCHAUTODIR)$(DIRFILESEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
	$(NOECHO) $(MKPATH) $(INST_ARCHAUTODIR)
a1009 1
    push @@m, $self->dir_target('$(INST_ARCHAUTODIR)');
a1012 28
=item dynamic_bs (override)

Use VMS-style quoting on Mkbootstrap command line.

=cut

sub dynamic_bs {
    my($self, %attribs) = @@_;
    return '
BOOTSTRAP =
' unless $self->has_link_code();
    '
BOOTSTRAP = '."$self->{BASEEXT}.bs".'

# As MakeMaker mkbootstrap might not write a file (if none is required)
# we use touch to prevent make continually trying to remake it.
# The DynaLoader only reads a non-empty file.
$(BOOTSTRAP) : $(FIRST_MAKEFILE) '."$self->{BOOTDEP}".' $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
	$(NOECHO) $(ECHO) "Running mkbootstrap for $(NAME) ($(BSLOADLIBS))"
	$(NOECHO) $(PERLRUN) -
	-e "use ExtUtils::Mkbootstrap; Mkbootstrap(\'$(BASEEXT)\',\'$(BSLOADLIBS)\');"
	$(NOECHO) $(TOUCH) $(MMS$TARGET)

$(INST_BOOT) : $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
	$(NOECHO) $(RM_RF) $(INST_BOOT)
	- $(CP) $(BOOTSTRAP) $(INST_BOOT)
';
}
d1032 1
a1032 1
$(OBJECT) : $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
d1046 1
a1046 1
      push(@@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(OBJECT)',"\n"); 
a1054 112
    push @@m, $self->dir_target('$(INST_ARCHAUTODIR)');
    join('',@@m);
}


=item processPL (override)

Use VMS-style quoting on command line.

=cut

sub processPL {
    my($self) = @@_;
    return "" unless $self->{PL_FILES};
    my(@@m, $plfile);
    foreach $plfile (sort keys %{$self->{PL_FILES}}) {
        my $list = ref($self->{PL_FILES}->{$plfile})
		? $self->{PL_FILES}->{$plfile}
		: [$self->{PL_FILES}->{$plfile}];
	foreach my $target (@@$list) {
	    my $vmsplfile = vmsify($plfile);
	    my $vmsfile = vmsify($target);
	    push @@m, "
all :: $vmsfile
	\$(NOECHO) \$(NOOP)

$vmsfile :: $vmsplfile
",'	$(PERLRUNINST) '," $vmsplfile $vmsfile
";
	}
    }
    join "", @@m;
}

=item installbin (override)

Stay under DCL's 255 character command line limit once again by
splitting potentially long list of files across multiple lines
in C<realclean> target.

=cut

sub installbin {
    my($self) = @@_;
    return '' unless $self->{EXE_FILES} && ref $self->{EXE_FILES} eq "ARRAY";
    return '' unless @@{$self->{EXE_FILES}};
    my(@@m, $from, $to, %fromto, @@to);
    my(@@exefiles) = map { vmsify($_) } @@{$self->{EXE_FILES}};
    for $from (@@exefiles) {
	my($path) = '$(INST_SCRIPT)' . basename($from);
	local($_) = $path;  # backward compatibility
	$to = $self->libscan($path);
	print "libscan($from) => '$to'\n" if ($Verbose >=2);
	$fromto{$from} = vmsify($to);
    }
    @@to = values %fromto;
    push @@m, "
EXE_FILES = @@exefiles

pure_all :: @@to
	\$(NOECHO) \$(NOOP)

realclean ::
";

    my $line = '';
    foreach $to (@@to) {
	if (length($line) + length($to) > 80) {
	    push @@m, "\t\$(RM_F) $line\n";
	    $line = $to;
	}
	else { $line .= " $to"; }
    }
    push @@m, "\t\$(RM_F) $line\n\n" if $line;

    while (($from,$to) = each %fromto) {
	last unless defined $from;
	my $todir;
	if ($to =~ m#[/>:\]]#) {
            $todir = dirname($to); 
        }
	else { 
            ($todir = $to) =~ s/[^\)]+$//; 
        }
	$todir = $self->fixpath($todir,1);
	push @@m, "
$to : $from \$(FIRST_MAKEFILE) ${todir}\$(DIRFILESEP).exists
	\$(CP) $from $to

", $self->dir_target($todir);
    }
    join "", @@m;
}

=item subdir_x (override)

Use VMS commands to change default directory.

=cut

sub subdir_x {
    my($self, $subdir) = @@_;
    my(@@m,$key);
    $subdir = $self->fixpath($subdir,1);
    push @@m, '

subdirs ::
	olddef = F$Environment("Default")
	Set Default ',$subdir,'
	- $(MMS)$(MMSQUALIFIERS) all $(USEMACROS)$(PASTHRU)$(MACROEND)
	Set Default \'olddef\'
';
a1057 58
=item clean (override)

Split potentially long list of files across multiple commands (in
order to stay under the magic command line limit).  Also use MM[SK]
commands for handling subdirectories.

=cut

sub clean {
    my($self, %attribs) = @@_;
    my(@@m,$dir);
    push @@m, '
# Delete temporary files but do not touch installed files. We don\'t delete
# the Descrip.MMS here so that a later make realclean still has it to use.
clean :: clean_subdirs
';
    push @@m, '	$(RM_F) *.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *$(OBJ_EXT) *$(LIB_EXT) *.Opt $(BOOTSTRAP) $(BASEEXT).bso .MM_Tmp
';

    my(@@otherfiles) = values %{$self->{XS}}; # .c files from *.xs files
    # Unlink realclean, $attribs{FILES} is a string here; it may contain
    # a list or a macro that expands to a list.
    if ($attribs{FILES}) {
        my @@filelist = ref $attribs{FILES} eq 'ARRAY'
            ? @@{$attribs{FILES}}
            : split /\s+/, $attribs{FILES};

	foreach my $word (@@filelist) {
	    if ($word =~ m#^\$\((.*)\)$# and 
                ref $self->{$1} eq 'ARRAY') 
            {
		push(@@otherfiles, @@{$self->{$1}});
	    }
	    else { push(@@otherfiles, $word); }
	}
    }
    push(@@otherfiles, qw[ blib $(MAKE_APERL_FILE) 
                          perlmain.c pm_to_blib pm_to_blib.ts ]);
    push(@@otherfiles, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));
    push(@@otherfiles, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.ld'));

    # Occasionally files are repeated several times from different sources
    { my(%of) = map { ($_ => 1) } @@otherfiles; @@otherfiles = keys %of; }
    
    my $line = '';
    foreach my $file (@@otherfiles) {
	$file = $self->fixpath($file);
	if (length($line) + length($file) > 80) {
	    push @@m, "\t\$(RM_RF) $line\n";
	    $line = "$file";
	}
	else { $line .= " $file"; }
    }
    push @@m, "\t\$(RM_RF) $line\n" if $line;
    push(@@m, "	$attribs{POSTOP}\n") if $attribs{POSTOP};
    join('', @@m);
}

d1059 1
a1059 1
=item clean_subdirs_target
d1061 2
a1062 3
  my $make_frag = $MM->clean_subdirs_target;

VMS semantics for changing directories and rerunning make very different.
d1066 5
a1070 21
sub clean_subdirs_target {
    my($self) = shift;

    # No subdirectories, no cleaning.
    return <<'NOOP_FRAG' unless @@{$self->{DIR}};
clean_subdirs :
	$(NOECHO) $(NOOP)
NOOP_FRAG


    my $clean = "clean_subdirs :\n";

    foreach my $dir (@@{$self->{DIR}}) { # clean subdirectories first
	$dir = $self->fixpath($dir,1);

        $clean .= sprintf <<'MAKE_FRAG', $dir, $dir;
	If F$Search("%s$(FIRST_MAKEFILE)").nes."" Then $(PERLRUN) -e "chdir '%s'; print `$(MMS)$(MMSQUALIFIERS) clean`;"
MAKE_FRAG
    }

    return $clean;
d1074 1
a1074 1
=item realclean (override)
d1076 1
a1076 1
Guess what we're working around?  Also, use MM[SK] for subdirectories.
d1078 1
a1078 72
=cut

sub realclean {
    my($self, %attribs) = @@_;
    my(@@m);
    push(@@m,'
# Delete temporary files (via clean) and also delete installed files
realclean :: clean
');
    foreach(@@{$self->{DIR}}){
	my($vmsdir) = $self->fixpath($_,1);
	push(@@m, '	If F$Search("'."$vmsdir".'$(FIRST_MAKEFILE)").nes."" Then \\',"\n\t",
	      '$(PERL) -e "chdir ',"'$vmsdir'",'; print `$(MMS)$(MMSQUALIFIERS) realclean`;"',"\n");
    }
    push @@m, "	\$(RM_RF) \$(INST_AUTODIR) \$(INST_ARCHAUTODIR)\n";
    push @@m, "	\$(RM_RF) \$(DISTVNAME)\n";
    # We can't expand several of the MMS macros here, since they don't have
    # corresponding %$self keys (i.e. they're defined in Descrip.MMS as a
    # combination of macros).  In order to stay below DCL's 255 char limit,
    # we put only 2 on a line.
    my($file,$fcnt);
    my(@@files) = values %{$self->{PM}};
    push @@files, qw{ $(FIRST_MAKEFILE) $(MAKEFILE_OLD) };
    if ($self->has_link_code) {
	push(@@files,qw{ $(INST_DYNAMIC) $(INST_STATIC) $(INST_BOOT) $(OBJECT) });
    }

    # Occasionally files are repeated several times from different sources
    { my(%f) = map { ($_,1) } @@files; @@files = keys %f; }

    my $line = '';
    foreach $file (@@files) {
	if (length($line) + length($file) > 80 || ++$fcnt >= 2) {
	    push @@m, "\t\$(RM_F) $line\n";
	    $line = "$file";
	    $fcnt = 0;
	}
	else { $line .= " $file"; }
    }
    push @@m, "\t\$(RM_F) $line\n" if $line;
    if ($attribs{FILES}) {
	my($word,$key,@@filist,@@allfiles);
	if (ref $attribs{FILES} eq 'ARRAY') { @@filist = @@{$attribs{FILES}}; }
	else { @@filist = split /\s+/, $attribs{FILES}; }
	foreach $word (@@filist) {
	    if (($key) = $word =~ m#^\$\((.*)\)$# and ref $self->{$key} eq 'ARRAY') {
		push(@@allfiles, @@{$self->{$key}});
	    }
	    else { push(@@allfiles, $word); }
	}
	$line = '';
	# Occasionally files are repeated several times from different sources
	{ my(%af) = map { ($_,1) } @@allfiles; @@allfiles = keys %af; }
	foreach $file (@@allfiles) {
	    $file = $self->fixpath($file);
	    if (length($line) + length($file) > 80) {
		push @@m, "\t\$(RM_RF) $line\n";
		$line = "$file";
	    }
	    else { $line .= " $file"; }
	}
	push @@m, "\t\$(RM_RF) $line\n" if $line;
    }
    push(@@m, "	$attribs{POSTOP}\n")                     if $attribs{POSTOP};
    join('', @@m);
}

=item zipfile_target (o)

=item tarfile_target (o)

=item shdist_target (o)
a1121 19
=item dist_test (override)

Use VMS commands to change default directory, and use VMS-style
quoting on command line.

=cut

sub dist_test {
    my($self) = @@_;
q{
disttest : distdir
	startdir = F$Environment("Default")
	Set Default [.$(DISTVNAME)]
	$(ABSPERLRUN) Makefile.PL
	$(MMS)$(MMSQUALIFIERS)
	$(MMS)$(MMSQUALIFIERS) test
	Set Default 'startdir'
};
}
d1134 1
a1134 13
    my(@@m,@@exe_files);

    if ($self->{EXE_FILES}) {
	my($line,$file) = ('','');
	foreach $file (@@{$self->{EXE_FILES}}) {
	    $line .= "$file ";
	    if (length($line) > 128) {
		push(@@exe_files,qq[\t\$(NOECHO) \$(ECHO) "$line" >>.MM_tmp\n]);
		$line = '';
	    }
	}
	push(@@exe_files,qq[\t\$(NOECHO) \$(ECHO) "$line" >>.MM_tmp\n]) if $line;
    }
d1204 1
a1204 2
],@@exe_files,
q[	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
d1213 1
a1213 2
],@@exe_files,
q[	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
d1221 1
a1221 2
],@@exe_files,
q[	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
a1314 102
=item makefile (override)

Use VMS commands and quoting.

=cut

sub makefile {
    my($self) = @@_;
    my(@@m,@@cmd);
    # We do not know what target was originally specified so we
    # must force a manual rerun to be sure. But as it should only
    # happen very rarely it is not a significant problem.
    push @@m, q[
$(OBJECT) : $(FIRST_MAKEFILE)
] if $self->{OBJECT};

    push @@m,q[
# We take a very conservative approach here, but it's worth it.
# We move $(FIRST_MAKEFILE) to $(MAKEFILE_OLD) here to avoid gnu make looping.
$(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
	$(NOECHO) $(ECHO) "$(FIRST_MAKEFILE) out-of-date with respect to $(MMS$SOURCE_LIST)"
	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding $(FIRST_MAKEFILE) ..."
	- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
	- $(MMS)$(MMSQUALIFIERS) $(USEMAKEFILE)$(MAKEFILE_OLD) clean
	$(PERLRUN) Makefile.PL ],join(' ',map(qq["$_"],@@ARGV)),q[
	$(NOECHO) $(ECHO) "$(FIRST_MAKEFILE) has been rebuilt."
	$(NOECHO) $(ECHO) "Please run $(MMS) to build the extension."
];

    join('',@@m);
}

=item find_tests (override)

=cut

sub find_tests {
    my $self = shift;
    return -d 't' ? 't/*.t' : '';
}

=item test (override)

Use VMS commands for handling subdirectories.

=cut

sub test {
    my($self, %attribs) = @@_;
    my($tests) = $attribs{TESTS} || $self->find_tests;
    my(@@m);
    push @@m,"
TEST_VERBOSE = 0
TEST_TYPE = test_\$(LINKTYPE)
TEST_FILE = test.pl
TESTDB_SW = -d

test :: \$(TEST_TYPE)
	\$(NOECHO) \$(NOOP)

testdb :: testdb_\$(LINKTYPE)
	\$(NOECHO) \$(NOOP)

";
    foreach(@@{$self->{DIR}}){
      my($vmsdir) = $self->fixpath($_,1);
      push(@@m, '	If F$Search("',$vmsdir,'$(FIRST_MAKEFILE)").nes."" Then $(PERL) -e "chdir ',"'$vmsdir'",
           '; print `$(MMS)$(MMSQUALIFIERS) $(PASTHRU2) test`'."\n");
    }
    push(@@m, "\t\$(NOECHO) \$(ECHO) \"No tests defined for \$(NAME) extension.\"\n")
        unless $tests or -f "test.pl" or @@{$self->{DIR}};
    push(@@m, "\n");

    push(@@m, "test_dynamic :: pure_all\n");
    push(@@m, $self->test_via_harness('$(FULLPERLRUN)', $tests)) if $tests;
    push(@@m, $self->test_via_script('$(FULLPERLRUN)', 'test.pl')) if -f "test.pl";
    push(@@m, "\t\$(NOECHO) \$(NOOP)\n") if (!$tests && ! -f "test.pl");
    push(@@m, "\n");

    push(@@m, "testdb_dynamic :: pure_all\n");
    push(@@m, $self->test_via_script('$(FULLPERLRUN) "$(TESTDB_SW)"', '$(TEST_FILE)'));
    push(@@m, "\n");

    # Occasionally we may face this degenerate target:
    push @@m, "test_ : test_dynamic\n\n";
 
    if ($self->needs_linking()) {
	push(@@m, "test_static :: pure_all \$(MAP_TARGET)\n");
	push(@@m, $self->test_via_harness('$(MAP_TARGET)', $tests)) if $tests;
	push(@@m, $self->test_via_script('$(MAP_TARGET)', 'test.pl')) if -f 'test.pl';
	push(@@m, "\n");
	push(@@m, "testdb_static :: pure_all \$(MAP_TARGET)\n");
	push(@@m, $self->test_via_script('$(MAP_TARGET) $(TESTDB_SW)', '$(TEST_FILE)'));
	push(@@m, "\n");
    }
    else {
	push @@m, "test_static :: test_dynamic\n\t\$(NOECHO) \$(NOOP)\n\n";
	push @@m, "testdb_static :: testdb_dynamic\n\t\$(NOECHO) \$(NOOP)\n";
    }

    join('',@@m);
}
d1352 1
a1352 1
	$(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
d1520 1
a1520 1
	$(NOECHO) $(ECHO) "    $(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
d1522 1
a1522 1
	$(NOECHO) $(ECHO) "    $(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
d1620 3
d1681 27
a1707 1
=item oneliner (o)
d1725 1
a1725 1
    return qq{\$(PERLRUN) $switches -e $cmd};
d1729 1
a1729 1
=item B<echo> (o)
d1787 1
a1787 1
=item init_linker (o)
d1860 3
d1869 5
a1873 5
If optional second argument has a TRUE value, then the return string is
a VMS-syntax directory specification, if it is FALSE, the return string
is a VMS-syntax file specification, and if it is not specified, fixpath()
checks to see whether it matches the name of a directory in the current
default directory, and returns a directory or file specification accordingly.
d1886 1
a1886 1
    if ($path =~ /\s/) {
d1889 1
a1889 1
	     split /\s+/, $path;
d1939 10
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@a9 1
use Carp qw( &carp );
d12 9
a20 1
use VMS::Filespec;
a21 1
use File::Spec;
d23 2
a24 1
($VERSION) = $Revision = '5.65';
d28 1
a28 1
@@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix File::Spec );
a61 1
    my($word);
d63 1
a63 1
    foreach $word (@@_) {
d167 27
a193 19
    # Check in relative directories first, so we pick up the current
    # version of Perl if we're running MakeMaker as part of the main build.
    @@sdirs = sort { my($absa) = File::Spec->file_name_is_absolute($a);
                    my($absb) = File::Spec->file_name_is_absolute($b);
                    if ($absa && $absb) { return $a cmp $b }
                    else { return $absa ? 1 : ($absb ? -1 : ($a cmp $b)); }
                  } @@$dirs;
    # Check miniperl before perl, and check names likely to contain
    # version numbers before "generic" names, so we pick up an
    # executable that's less likely to be from an old installation.
    @@snames = sort { my($ba) = $a =~ m!([^:>\]/]+)$!;  # basename
                     my($bb) = $b =~ m!([^:>\]/]+)$!;
                     my($ahasdir) = (length($a) - length($ba) > 0);
                     my($bhasdir) = (length($b) - length($bb) > 0);
                     if    ($ahasdir and not $bhasdir) { return 1; }
                     elsif ($bhasdir and not $ahasdir) { return -1; }
                     else { $bb =~ /\d/ <=> $ba =~ /\d/
                            or substr($ba,0,1) cmp substr($bb,0,1)
                            or length($bb) <=> length($ba) } } @@$names;
d204 1
a204 1
	$inabs++ if File::Spec->file_name_is_absolute($dir);
d213 1
a213 1
	    if ($name !~ m![/:>\]]!) { push(@@cand,File::Spec->catfile($dir,$name)); }
d228 3
a230 3
	    print "Using PERL=$name\n" if $trace;
	    return $name;
	}
a283 36
=item maybe_command_in_dirs (override)

Uses DCL argument quoting on test command line.

=cut

sub maybe_command_in_dirs {	# $ver is optional argument if looking for perl
    my($self, $names, $dirs, $trace, $ver) = @@_;
    my($name, $dir);
    foreach $dir (@@$dirs){
	next unless defined $dir; # $self->{PERL_SRC} may be undefined
	foreach $name (@@$names){
	    my($abs,$tryabs);
	    if (File::Spec->file_name_is_absolute($name)) {
		$abs = $name;
	    } else {
		$abs = File::Spec->catfile($dir, $name);
	    }
	    print "Checking $abs for $name\n" if ($trace >= 2);
	    next unless $tryabs = $self->maybe_command($abs);
	    print "Substituting $tryabs instead of $abs\n" 
		if ($trace >= 2 and $tryabs ne $abs);
	    $abs = $tryabs;
	    if (defined $ver) {
		print "Executing $abs\n" if ($trace >= 2);
		if (`$abs -e 'require $ver; print "VER_OK\n" ' 2>&1` =~ /VER_OK/) {
		    print "Using $abs\n" if $trace;
		    return $abs;
		}
	    } else { # Do not look for perl
		return $abs;
	    }
	}
    }
}

d313 34
a348 2
Override DISTVNAME so it uses VERSION_SYM to avoid getting too many
dots in the name.
d356 28
a383 1
    $self->{DISTVNAME} = "$self->{DISTNAME}-$self->{VERSION_SYM}";
d391 7
d403 24
a426 9
    $self->{NOOP} = 'Continue';
    $self->{FIRST_MAKEFILE} ||= 'Descrip.MMS';
    $self->{MAKE_APERL_FILE} ||= 'Makeaperl.MMS';
    $self->{MAKEFILE} ||= $self->{FIRST_MAKEFILE};
    $self->{NOECHO} ||= '@@ ';
    $self->{RM_F} = '$(PERL) -e "foreach (@@ARGV) { 1 while ( -d $_ ? rmdir $_ : unlink $_)}"';
    $self->{RM_RF} = '$(PERLRUN) -e "use File::Path; @@dirs = map(VMS::Filespec::unixify($_),@@ARGV); rmtree(\@@dirs,0,0)"';
    $self->{TOUCH} = '$(PERL) -e "$t=time; foreach (@@ARGV) { -e $_ ? utime($t,$t,@@ARGV) : (open(F,qq(>$_)),close F)}"';
    $self->{CHMOD} = '$(PERL) -e "chmod @@ARGV"';  # expect Unix syntax from MakeMaker
d430 1
a430 1
    
d432 11
d445 56
d504 2
a505 2
regardless of input syntax.  Also adds a few VMS-specific macros
and makes lists of files comma-separated.
a510 1
    my(@@m,$def,$macro);
d515 2
a516 35
    $self->{DEFINE} ||= '';
    if ($self->{DEFINE} ne '') {
	my(@@terms) = split(/\s+/,$self->{DEFINE});
	my(@@defs,@@udefs);
	foreach $def (@@terms) {
	    next unless $def;
	    my $targ = \@@defs;
	    if ($def =~ s/^-([DU])//) {       # If it was a Unix-style definition
		if ($1 eq 'U') { $targ = \@@udefs; }
		$def =~ s/='(.*)'$/=$1/;  # then remove shell-protection ''
		$def =~ s/^'(.*)'$/$1/;   # from entire term or argument
	    }
	    if ($def =~ /=/) {
		$def =~ s/"/""/g;  # Protect existing " from DCL
		$def = qq["$def"]; # and quote to prevent parsing of =
	    }
	    push @@$targ, $def;
	}
	$self->{DEFINE} = '';
	if (@@defs)  { 
            $self->{DEFINE}  = '/Define=(' . join(',',@@defs)  . ')'; 
        }
	if (@@udefs) { 
            $self->{DEFINE} .= '/Undef=('  . join(',',@@udefs) . ')'; 
        }
    }

    if ($self->{OBJECT} =~ /\s/) {
	$self->{OBJECT} =~ s/(\\)?\n+\s+/ /g;
	$self->{OBJECT} = $self->wraplist(map($self->fixpath($_,0),split(/,?\s+/,$self->{OBJECT})));
    }
    $self->{LDFROM} = $self->wraplist(map($self->fixpath($_,0),split(/,?\s+/,$self->{LDFROM})));


    foreach $macro ( qw [
a517 5
            INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
	    INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
            INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN  INSTALLSCRIPT 
            INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR
            INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR
d519 5
a523 2
            PERL_INC PERL_SRC FULLEXT ] ) {
	next unless defined $self->{$macro};
d525 1
a525 32
	$self->{$macro} = $self->fixpath($self->{$macro},1);
    }
    $self->{PERL_VMS} = File::Spec->catdir($self->{PERL_SRC},q(VMS))
	if ($self->{PERL_SRC});
                        


    # Fix up file specs
    foreach $macro ( qw[LIBPERL_A FIRST_MAKEFILE MAKE_APERL_FILE MYEXTLIB] ) {
	next unless defined $self->{$macro};
	$self->{$macro} = $self->fixpath($self->{$macro},0);
    }

    foreach $macro (qw/
	      AR_STATIC_ARGS NAME DISTNAME NAME_SYM VERSION VERSION_SYM 
              XS_VERSION
	      INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT 
              INSTALLDIRS
              PREFIX          SITEPREFIX      VENDORPREFIX
	      INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
	      INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
              INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN  INSTALLSCRIPT 
	      PERL_LIB PERL_ARCHLIB 
              SITELIBEXP SITEARCHEXP 
              LIBPERL_A MYEXTLIB
	      FIRST_MAKEFILE MAKE_APERL_FILE PERLMAINCC PERL_SRC PERL_VMS
	      PERL_INC PERL FULLPERL PERLRUN FULLPERLRUN PERLRUNINST
              FULLPERLRUNINST ABSPERL ABSPERLRUN ABSPERLRUNINST
              PERL_CORE NOECHO NOOP
	      / ) {
	next unless defined $self->{$macro};
	push @@m, "$macro = $self->{$macro}\n";
d528 6
a533 23

    push @@m, q[
VERSION_MACRO = VERSION
DEFINE_VERSION = "$(VERSION_MACRO)=""$(VERSION)"""
XS_VERSION_MACRO = XS_VERSION
XS_DEFINE_VERSION = "$(XS_VERSION_MACRO)=""$(XS_VERSION)"""

MAKEMAKER = ],File::Spec->catfile($self->{PERL_LIB},'ExtUtils','MakeMaker.pm'),qq[
MM_VERSION = $ExtUtils::MakeMaker::VERSION
MM_REVISION = $ExtUtils::MakeMaker::Revision
MM_VMS_REVISION = $ExtUtils::MM_VMS::Revision

# FULLEXT = Pathname for extension directory (eg DBD/Oracle).
# BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT.
# PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)
# DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.
];

    for my $tmp (qw/
	      FULLEXT VERSION_FROM OBJECT LDFROM
	      /	) {
	next unless defined $self->{$tmp};
	push @@m, "$tmp = ",$self->fixpath($self->{$tmp},0),"\n";
d536 4
a539 2
    for my $tmp (qw/
	      BASEEXT PARENT_NAME DLBASE INC DEFINE LINKTYPE
d541 2
a542 2
	next unless defined $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
a544 9
    for my $tmp (qw/ XS MAN1PODS MAN3PODS PM /) {
	# Where is the space coming from? --jhi
	next unless $self ne " " && defined $self->{$tmp};
	my(%tmp,$key);
	for $key (keys %{$self->{$tmp}}) {
	    $tmp{$self->fixpath($key,0)} = $self->fixpath($self->{$tmp}{$key},0);
	}
	$self->{$tmp} = \%tmp;
    }
d546 9
a554 7
    for my $tmp (qw/ C O_FILES H /) {
	next unless defined $self->{$tmp};
	my(@@tmp,$val);
	for $val (@@{$self->{$tmp}}) {
	    push(@@tmp,$self->fixpath($val,0));
	}
	$self->{$tmp} = \@@tmp;
d557 7
a563 20
    push @@m,'

# Handy lists of source code files:
XS_FILES = ',$self->wraplist(sort keys %{$self->{XS}}),'
C_FILES  = ',$self->wraplist(@@{$self->{C}}),'
O_FILES  = ',$self->wraplist(@@{$self->{O_FILES}} ),'
H_FILES  = ',$self->wraplist(@@{$self->{H}}),'
MAN1PODS = ',$self->wraplist(sort keys %{$self->{MAN1PODS}}),'
MAN3PODS = ',$self->wraplist(sort keys %{$self->{MAN3PODS}}),'

';

    for my $tmp (qw/
	      INST_MAN1DIR  MAN1EXT 
              INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR
	      INST_MAN3DIR  MAN3EXT
              INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR
	      /) {
	next unless defined $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
d566 2
a567 3
push @@m,"
makemakerdflt : all
	\$(NOECHO) \$(NOOP)
a568 2
.SUFFIXES :
.SUFFIXES : \$(OBJ_EXT) .c .cpp .cxx .xs
d570 1
a570 2
# Here is the Config.pm that we are using/depend on
CONFIGDEP = \$(PERL_ARCHLIB)Config.pm, \$(PERL_INC)config.h \$(VERSION_FROM)
d572 1
a572 3
# Where to put things:
INST_LIBDIR      = $self->{INST_LIBDIR}
INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}
d574 1
a574 3
INST_AUTODIR     = $self->{INST_AUTODIR}
INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}
";
d576 2
a577 16
    if ($self->has_link_code()) {
	push @@m,'
INST_STATIC = $(INST_ARCHAUTODIR)$(BASEEXT)$(LIB_EXT)
INST_DYNAMIC = $(INST_ARCHAUTODIR)$(DLBASE).$(DLEXT)
INST_BOOT = $(INST_ARCHAUTODIR)$(BASEEXT).bs
';
    } else {
	my $shr = $Config{'dbgprefix'} . 'PERLSHR';
	push @@m,'
INST_STATIC =
INST_DYNAMIC =
INST_BOOT =
EXPORT_LIST = $(BASEEXT).opt
PERL_ARCHIVE = ',($ENV{$shr} ? $ENV{$shr} : "Sys\$Share:$shr.$Config{'dlext'}"),'
';
    }
d579 3
a581 4
    $self->{TO_INST_PM} = [ sort keys %{$self->{PM}} ];
    $self->{PM_TO_BLIB} = [ %{$self->{PM}} ];
    push @@m,'
TO_INST_PM = ',$self->wraplist(@@{$self->{TO_INST_PM}}),'
d583 1
a583 2
PM_TO_BLIB = ',$self->wraplist(@@{$self->{PM_TO_BLIB}}),'
';
d585 1
a585 1
    join('',@@m);
a725 72
=item pm_to_blib (override)

DCL I<still> accepts a maximum of 255 characters on a command
line, so we write the (potentially) long list of file names
to a temp file, then persuade Perl to read it instead of the
command line to find args.

=cut

sub pm_to_blib {
    my($self) = @@_;
    my($autodir) = File::Spec->catdir($self->{INST_LIB},'auto');
    my(%files) = @@{$self->{PM_TO_BLIB}};

    my $m = <<'MAKE_FRAG';

# Dummy target to match Unix target name; we use pm_to_blib.ts as
# timestamp file to avoid repeated invocations under VMS
pm_to_blib : pm_to_blib.ts
	$(NOECHO) $(NOOP)

# As always, keep under DCL's 255-char limit
pm_to_blib.ts : $(TO_INST_PM)
MAKE_FRAG

    if( keys %files ) {
        $m .= <<'MAKE_FRAG';
	$(NOECHO) $(RM_F) .MM_tmp
MAKE_FRAG

        my $line = '';
        while (my($from, $to) = each %files) {
            $line .= " $from $to";
            if (length($line) > 128) {
                $m .= sprintf <<'MAKE_FRAG', $line;
	$(NOECHO) $(PERL) -e "print '%s'" >>.MM_tmp
MAKE_FRAG
                $line = '';
            }
        }
        $m .= sprintf <<'MAKE_FRAG', $line if $line;
	$(NOECHO) $(PERL) -e "print '%s'" >>.MM_tmp
MAKE_FRAG

        $m .= sprintf <<'MAKE_FRAG', $autodir;
	$(PERLRUN) "-MExtUtils::Install" -e "pm_to_blib({split(' ',<STDIN>)},'%s','$(PM_FILTER)')" <.MM_tmp
	$(NOECHO) $(RM_F) .MM_tmp
MAKE_FRAG

    }
    $m .= <<'MAKE_FRAG';
	$(NOECHO) $(TOUCH) pm_to_blib.ts
MAKE_FRAG

    return $m;
}

=item tool_autosplit (override)

Use VMS-style quoting on command line.

=cut

sub tool_autosplit {
    my($self, %attribs) = @@_;
    my($asl) = "";
    $asl = "\$AutoSplit::Maxlen=$attribs{MAXLEN};" if $attribs{MAXLEN};
    q{
# Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto
AUTOSPLITFILE = $(PERLRUN) -e "use AutoSplit;}.$asl.q{autosplit($ARGV[0], $ARGV[1], 0, 1, 1) ;"
};
}
d736 11
a746 4
    my($xsdir) = File::Spec->catdir($self->{PERL_LIB},'ExtUtils');
    # drop back to old location if xsubpp is not in new location yet
    $xsdir = File::Spec->catdir($self->{PERL_SRC},'ext') unless (-f File::Spec->catfile($xsdir,'xsubpp'));
    my(@@tmdeps) = '$(XSUBPPDIR)typemap';
a768 1
    my $xsubpp_version = $self->xsubpp_version(File::Spec->catfile($xsdir,'xsubpp'));
a769 13
    # What are the correct thresholds for version 1 && 2 Paul?
    if ( $xsubpp_version > 1.923 ){
	$self->{XSPROTOARG} = '' unless defined $self->{XSPROTOARG};
    } else {
	if (defined $self->{XSPROTOARG} && $self->{XSPROTOARG} =~ /\-prototypes/) {
	    print STDOUT qq{Warning: This extension wants to pass the switch "-prototypes" to xsubpp.
	Your version of xsubpp is $xsubpp_version and cannot handle this.
	Please upgrade to a more recent version of xsubpp.
};
	} else {
	    $self->{XSPROTOARG} = "";
	}
    }
d771 3
a773 1
    "
a781 1
=item xsubpp_version (override)
d783 1
a783 2
Test xsubpp exit status according to VMS rules ($sts & 1 ==E<gt> good)
rather than Unix rules ($sts == 0 ==E<gt> good).
d785 1
a785 1
=cut
d787 1
a787 5
sub xsubpp_version
{
    my($self,$xsubpp) = @@_;
    my ($version) ;
    return '' unless $self->needs_linking;
d789 1
a789 1
    # try to figure out the version number of the xsubpp on the system
d791 2
a792 1
    # first try the -v flag, introduced in 1.921 & 2.000a2
d794 3
a796 8
    my $command = qq{$self->{PERL} "-I$self->{PERL_LIB}" $xsubpp -v};
    print "Running: $command\n" if $Verbose;
    $version = `$command` ;
    if ($?) {
	use vmsish 'status';
	warn "Running '$command' exits with status $?";
    }
    chop $version ;
d798 6
a803 1
    return $1 if $version =~ /^xsubpp version (.*)/ ;
d805 2
a806 1
    # nope, then try something else
d808 1
a808 4
    my $counter = '000';
    my ($file) = 'temp' ;
    $counter++ while -e "$file$counter"; # don't overwrite anything
    $file .= $counter;
d810 2
a811 4
    local(*F);
    open(F, ">$file") or die "Cannot open file '$file': $!\n" ;
    print F <<EOM ;
MODULE = fred PACKAGE = fred
d813 1
a813 4
int
fred(a)
	int	a;
EOM
d815 1
a815 1
    close F ;
d817 1
a817 8
    $command = "$self->{PERLRUN} $xsubpp $file";
    print "Running: $command\n" if $Verbose;
    my $text = `$command` ;
    if ($?) {
	use vmsish 'status';
	warn "Running '$command' exits with status $?";
    }
    unlink $file ;
d819 1
a819 2
    # gets 1.2 -> 1.92 and 2.000a1
    return $1 if $text =~ /automatically by xsubpp version ([\S]+)\s*/  ;
d821 4
a824 2
    # it is either 1.0 or 1.1
    return 1.1 if $text =~ /^Warning: ignored semicolon/ ;
d826 1
a826 3
    # none of the above, so 1.0
    return "1.0" ;
}
d828 2
a829 1
=item tools_other (override)
d831 2
a832 6
Adds a few MM[SK] macros, and shortens some the installatin commands,
in order to stay under DCL's 255-character limit.  Also changes
EQUALIZE_TIMESTAMP to set revision date of target file to one second
later than source file, since MMK interprets precisely equal revision
dates for a source and target file as a sign that the target needs
to be updated.
d836 1
a836 1
sub tools_other {
d838 5
a842 28
    qq!
# Assumes \$(MMS) invokes MMS or MMK
# (It is assumed in some cases later that the default makefile name
# (Descrip.MMS for MM[SK]) is used.)
USEMAKEFILE = /Descrip=
USEMACROS = /Macro=(
MACROEND = )
MAKEFILE = Descrip.MMS
SHELL = Posix
TOUCH = $self->{TOUCH}
CHMOD = $self->{CHMOD}
CP = $self->{CP}
MV = $self->{MV}
RM_F  = $self->{RM_F}
RM_RF = $self->{RM_RF}
SAY = Write Sys\$Output
UMASK_NULL = $self->{UMASK_NULL}
MKPATH = Create/Directory
EQUALIZE_TIMESTAMP = \$(PERL) -we "open F,qq{>\$ARGV[1]};close F;utime(0,(stat(\$ARGV[0]))[9]+1,\$ARGV[1])"
!. ($self->{PARENT} ? '' : 
qq!WARN_IF_OLD_PACKLIST = \$(PERL) -e "if (-f \$ARGV[0]){print qq[WARNING: Old package found (\$ARGV[0]); please check for collisions\\n]}"
MOD_INSTALL = \$(PERLRUN) "-MExtUtils::Install" -e "install({split(' ',<STDIN>)},1);"
DOC_INSTALL = \$(PERL) -e "\@@ARGV=split(/\\|/,<STDIN>);print '=head2 ',scalar(localtime),': C<',shift,qq[>\\n\\n=over 4\\n\\n];while(\$key=shift && \$val=shift){print qq[=item *\\n\\nC<\$key: \$val>\\n\\n];}print qq[=back\\n\\n]"
UNINSTALL = \$(PERLRUN) "-MExtUtils::Install" -e "uninstall(\$ARGV[0],1,1);"
!);
}

=item dist (override)
d844 1
a844 2
Provide VMSish defaults for some values, then hand off to
default MM_Unix method.
d846 1
a846 19
=cut

sub dist {
    my($self, %attribs) = @@_;
    $attribs{VERSION}      ||= $self->{VERSION_SYM};
    $attribs{NAME}         ||= $self->{DISTNAME};
    $attribs{ZIPFLAGS}     ||= '-Vu';
    $attribs{COMPRESS}     ||= 'gzip';
    $attribs{SUFFIX}       ||= '-gz';
    $attribs{SHAR}         ||= 'vms_share';
    $attribs{DIST_DEFAULT} ||= 'zipdist';

    # Sanitize these for use in $(DISTVNAME) filespec
    $attribs{VERSION} =~ s/[^\w\$]/_/g;
    $attribs{NAME} =~ s/[^\w\$]/-/g;

    $attribs{DISTVNAME} ||= '$(DISTNAME)-$(VERSION_SYM)';

    return $self->SUPER::dist(%attribs);
a902 56
=item top_targets (override)

Path seperator differences.

=cut

sub top_targets {
    my($self) = shift;
    my(@@m);
    push @@m, '
all :: pure_all manifypods
	$(NOECHO) $(NOOP)

pure_all :: config pm_to_blib subdirs linkext
	$(NOECHO) $(NOOP)

subdirs :: $(MYEXTLIB)
	$(NOECHO) $(NOOP)

config :: $(MAKEFILE) $(INST_LIBDIR).exists
	$(NOECHO) $(NOOP)

config :: $(INST_ARCHAUTODIR).exists
	$(NOECHO) $(NOOP)

config :: $(INST_AUTODIR).exists
	$(NOECHO) $(NOOP)
';

    push @@m, $self->dir_target(qw[$(INST_AUTODIR) $(INST_LIBDIR) $(INST_ARCHAUTODIR)]);
    if (%{$self->{MAN1PODS}}) {
	push @@m, q[
config :: $(INST_MAN1DIR).exists
	$(NOECHO) $(NOOP)
];
	push @@m, $self->dir_target(qw[$(INST_MAN1DIR)]);
    }
    if (%{$self->{MAN3PODS}}) {
	push @@m, q[
config :: $(INST_MAN3DIR).exists
	$(NOECHO) $(NOOP)
];
	push @@m, $self->dir_target(qw[$(INST_MAN3DIR)]);
    }

    push @@m, '
$(O_FILES) : $(H_FILES)
' if @@{$self->{O_FILES} || []} && @@{$self->{H} || []};

    push @@m, q{
help :
	perldoc ExtUtils::MakeMaker
};

    join('',@@m);
}
d1009 1
a1009 1
$(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt $(INST_ARCHAUTODIR).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
d1036 2
a1037 2
$(BOOTSTRAP) : $(MAKEFILE) '."$self->{BOOTDEP}".' $(INST_ARCHAUTODIR).exists
	$(NOECHO) $(SAY) "Running mkbootstrap for $(NAME) ($(BSLOADLIBS))"
d1042 1
a1042 1
$(INST_BOOT) : $(BOOTSTRAP) $(INST_ARCHAUTODIR).exists
d1066 1
a1066 1
$(OBJECT) : $(INST_ARCHAUTODIR).exists
a1093 50
=item manifypods (override)

Use VMS-style quoting on command line, and VMS logical name
to specify fallback location at build time if we can't find pod2man.

=cut


sub manifypods {
    my($self, %attribs) = @@_;
    return "\nmanifypods :\n\t\$(NOECHO) \$(NOOP)\n" unless %{$self->{MAN3PODS}} or %{$self->{MAN1PODS}};
    my($dist);
    my($pod2man_exe);
    if (defined $self->{PERL_SRC}) {
	$pod2man_exe = File::Spec->catfile($self->{PERL_SRC},'pod','pod2man');
    } else {
	$pod2man_exe = File::Spec->catfile($Config{scriptdirexp},'pod2man');
    }
    if (not ($pod2man_exe = $self->perl_script($pod2man_exe))) {
	# No pod2man but some MAN3PODS to be installed
	print <<END;

Warning: I could not locate your pod2man program.  As a last choice,
         I will look for the file to which the logical name POD2MAN
         points when MMK is invoked.

END
        $pod2man_exe = "pod2man";
    }
    my(@@m);
    push @@m,
qq[POD2MAN_EXE = $pod2man_exe\n],
q[POD2MAN = $(PERLRUN) "-MPod::Man" -we "%m=@@ARGV;for(keys %m){" -
-e "Pod::Man->new->parse_from_file($_,$m{$_}) }"
];
    push @@m, "\nmanifypods : \$(MAN1PODS) \$(MAN3PODS)\n";
    if (%{$self->{MAN1PODS}} || %{$self->{MAN3PODS}}) {
	my($pod);
	foreach $pod (sort keys %{$self->{MAN1PODS}}) {
	    push @@m, qq[\t\@@- If F\$Search("\$(POD2MAN_EXE)").nes."" Then \$(POD2MAN) ];
	    push @@m, "$pod $self->{MAN1PODS}{$pod}\n";
	}
	foreach $pod (sort keys %{$self->{MAN3PODS}}) {
	    push @@m, qq[\t\@@- If F\$Search("\$(POD2MAN_EXE)").nes."" Then \$(POD2MAN) ];
	    push @@m, "$pod $self->{MAN3PODS}{$pod}\n";
	}
    }
    join('', @@m);
}

d1135 1
a1135 1
    my(@@m, $from, $to, %fromto, @@to, $line);
d1148 3
d1153 2
a1154 1
    $line = '';  #avoid unitialized var warning
d1167 6
a1172 2
	if ($to =~ m#[/>:\]]#) { $todir = dirname($to); }
	else                   { ($todir = $to) =~ s/[^\)]+$//; }
d1175 1
a1175 1
$to : $from \$(MAKEFILE) ${todir}.exists
d1218 1
a1218 1
clean ::
a1219 5
    foreach $dir (@@{$self->{DIR}}) { # clean subdirectories first
	my($vmsdir) = $self->fixpath($dir,1);
	push( @@m, '	If F$Search("'.$vmsdir.'$(MAKEFILE)").nes."" Then \\',"\n\t",
	      '$(PERL) -e "chdir ',"'$vmsdir'",'; print `$(MMS)$(MMSQUALIFIERS) clean`;"',"\n");
    }
d1227 9
a1235 6
	my($word,$key,@@filist);
	if (ref $attribs{FILES} eq 'ARRAY') { @@filist = @@{$attribs{FILES}}; }
	else { @@filist = split /\s+/, $attribs{FILES}; }
	foreach $word (@@filist) {
	    if (($key) = $word =~ m#^\$\((.*)\)$# and ref $self->{$key} eq 'ARRAY') {
		push(@@otherfiles, @@{$self->{$key}});
d1240 5
a1244 4
    push(@@otherfiles, qw[ blib $(MAKE_APERL_FILE) extralibs.ld perlmain.c pm_to_blib.ts ]);
    push(@@otherfiles,File::Spec->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));
    my($file,$line);
    $line = '';  #avoid unitialized var warning
d1246 1
a1246 1
    { my(%of) = map { ($_,1) } @@otherfiles; @@otherfiles = keys %of; }
d1248 2
a1249 1
    foreach $file (@@otherfiles) {
d1262 33
d1310 1
a1310 1
	push(@@m, '	If F$Search("'."$vmsdir".'$(MAKEFILE)").nes."" Then \\',"\n\t",
d1319 3
a1321 2
    my($file,$line,$fcnt);
    my(@@files) = qw{ $(MAKEFILE) $(MAKEFILE)_old };
d1325 1
a1325 2
    push(@@files, values %{$self->{PM}});
    $line = '';  #avoid unitialized var warning
d1328 2
a1330 1
	$file = $self->fixpath($file);
d1366 1
d1368 1
a1368 1
=item dist_core (override)
d1370 3
a1372 2
Syntax for invoking F<VMS_Share> differs from that for Unix F<shar>,
so C<shdist> target actions are VMS-specific.
d1376 2
a1377 11
sub dist_core {
    my($self) = @@_;
q[
dist : $(DIST_DEFAULT)
	$(NOECHO) $(PERL) -le "print 'Warning: $m older than $vf' if -e ($vf = '$(VERSION_FROM)') && -M $vf < -M ($m = '$(MAKEFILE)')"

zipdist : $(DISTVNAME).zip
	$(NOECHO) $(NOOP)

tardist : $(DISTVNAME).tar$(SUFFIX)
	$(NOECHO) $(NOOP)
d1379 1
d1385 2
d1388 4
d1399 2
d1402 4
d1408 1
a1408 1
	$(SHAR) [.$(DISTVNAME...]*.*; $(DISTVNAME).share
d1411 1
a1411 1
];
d1445 1
a1445 1
    my(@@m,@@docfiles);
d1452 1
a1452 1
		push(@@docfiles,qq[\t\$(NOECHO) \$(PERL) -e "print '$line'" >>.MM_tmp\n]);
d1456 1
a1456 1
	push(@@docfiles,qq[\t\$(NOECHO) \$(PERL) -e "print '$line'" >>.MM_tmp\n]) if $line;
d1473 1
a1473 1
	$(NOECHO) $(SAY) "Appending installation info to $(INSTALLARCHLIB)perllocal.pod"
d1476 1
a1476 1
	$(NOECHO) $(SAY) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1479 1
a1479 1
	$(NOECHO) $(SAY) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1484 10
a1493 10
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(INSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_LIB) $(INSTALLPRIVLIB) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_ARCHLIB) $(INSTALLARCHLIB) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_BIN) $(INSTALLBIN) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_SCRIPT) $(INSTALLSCRIPT) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLMAN1DIR) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLMAN3DIR) '" >>.MM_tmp
	$(MOD_INSTALL) <.MM_tmp
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].File::Spec->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
d1498 10
a1507 10
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(INSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_LIB) $(INSTALLSITELIB) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_ARCHLIB) $(INSTALLSITEARCH) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_BIN) $(INSTALLSITEBIN) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_SCRIPT) $(INSTALLSCRIPT) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLSITEMAN1DIR) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLSITEMAN3DIR) '" >>.MM_tmp
	$(MOD_INSTALL) <.MM_tmp
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].File::Spec->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
d1510 10
a1519 8
	$(NOECHO) $(PERL) -e "print '$(INST_LIB) $(INSTALLVENDORLIB) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_ARCHLIB) $(INSTALLVENDORARCH) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_BIN) $(INSTALLVENDORBIN) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_SCRIPT) $(INSTALLSCRIPT) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLVENDORMAN1DIR) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLVENDORMAN3DIR) '" >>.MM_tmp
	$(MOD_INSTALL) <.MM_tmp
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
d1523 7
a1529 9
	$(NOECHO) $(PERL) -e "print 'Module $(NAME)|installed into|$(INSTALLPRIVLIB)|'" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES)|'" >>.MM_tmp
],@@docfiles,
q%	$(NOECHO) $(PERL) -e "print q[@@ARGV=split(/\\|/,<STDIN>);]" >.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[print '=head2 ',scalar(localtime),': C<',shift,qq[>\\n\\n=over 4\\n\\n];]" >>.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[while(($key=shift) && ($val=shift)) ]" >>.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[{print qq[=item *\\n\\nC<$key: $val>\\n\\n];}print qq[=back\\n\\n];]" >>.MM2_tmp
	$(NOECHO) $(PERL) .MM2_tmp <.MM_tmp >>%.File::Spec->catfile($self->{INSTALLARCHLIB},'perllocal.pod').q[
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;,.MM2_tmp;
d1533 7
a1539 9
	$(NOECHO) $(PERL) -e "print 'Module $(NAME)|installed into|$(INSTALLSITELIB)|'" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES)|'" >>.MM_tmp
],@@docfiles,
q%	$(NOECHO) $(PERL) -e "print q[@@ARGV=split(/\\|/,<STDIN>);]" >.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[print '=head2 ',scalar(localtime),': C<',shift,qq[>\\n\\n=over 4\\n\\n];]" >>.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[while(($key=shift) && ($val=shift)) ]" >>.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[{print qq[=item *\\n\\nC<$key: $val>\\n\\n];}print qq[=back\\n\\n];]" >>.MM2_tmp
	$(NOECHO) $(PERL) .MM2_tmp <.MM_tmp >>%.File::Spec->catfile($self->{INSTALLARCHLIB},'perllocal.pod').q[
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;,.MM2_tmp;
d1542 7
d1557 4
a1560 4
	$(NOECHO) $(UNINSTALL) ].File::Spec->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
	$(NOECHO) $(SAY) "Uninstall is now deprecated and makes no actual changes."
	$(NOECHO) $(SAY) "Please check the list above carefully for errors, and manually remove"
	$(NOECHO) $(SAY) "the appropriate files.  Sorry for the inconvenience."
d1563 4
a1566 4
	$(NOECHO) $(UNINSTALL) ],File::Spec->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist'),"\n",q[
	$(NOECHO) $(SAY) "Uninstall is now deprecated and makes no actual changes."
	$(NOECHO) $(SAY) "Please check the list above carefully for errors, and manually remove"
	$(NOECHO) $(SAY) "the appropriate files.  Sorry for the inconvenience."
d1588 1
a1588 1
$(OBJECT) : $(PERL_INC)embedvar.h, $(PERL_INC)fakethr.h, $(PERL_INC)form.h
d1592 3
a1594 3
$(OBJECT) : $(PERL_INC)opcode.h, $(PERL_INC)opnames.h, $(PERL_INC)patchlevel.h
$(OBJECT) : $(PERL_INC)perl.h, $(PERL_INC)perlapi.h, $(PERL_INC)perlio.h
$(OBJECT) : $(PERL_INC)perlsdio.h, $(PERL_INC)perlsfio.h, $(PERL_INC)perlvars.h
d1598 2
a1599 2
$(OBJECT) : $(PERL_INC)thrdvar.h, $(PERL_INC)thread.h, $(PERL_INC)utf8.h
$(OBJECT) : $(PERL_INC)util.h, $(PERL_INC)vmsish.h, $(PERL_INC)warnings.h
d1605 1
a1605 1
	my($mmsquals) = '$(USEMAKEFILE)[.vms]$(MAKEFILE)';
d1658 7
a1664 7
# We take a very conservative approach here, but it\'s worth it.
# We move $(MAKEFILE) to $(MAKEFILE)_old here to avoid gnu make looping.
$(MAKEFILE) : Makefile.PL $(CONFIGDEP)
	$(NOECHO) $(SAY) "$(MAKEFILE) out-of-date with respect to $(MMS$SOURCE_LIST)"
	$(NOECHO) $(SAY) "Cleaning current config before rebuilding $(MAKEFILE) ..."
	- $(MV) $(MAKEFILE) $(MAKEFILE)_old
	- $(MMS)$(MMSQUALIFIERS) $(USEMAKEFILE)$(MAKEFILE)_old clean
d1666 2
a1667 2
	$(NOECHO) $(SAY) "$(MAKEFILE) has been rebuilt."
	$(NOECHO) $(SAY) "Please run $(MMS) to build the extension."
d1707 1
a1707 1
      push(@@m, '	If F$Search("',$vmsdir,'$(MAKEFILE)").nes."" Then $(PERL) -e "chdir ',"'$vmsdir'",
d1710 1
a1710 1
    push(@@m, "\t\$(NOECHO) \$(SAY) \"No tests defined for \$(NAME) extension.\"\n")
d1757 1
a1757 1
    my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmp, $libperl) = 
d1771 1
a1771 1
	$(NOECHO) $(SAY) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
d1774 1
a1774 1
		MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
d1899 2
a1900 2
    $tmp = "[]" unless $tmp;
    $tmp = $self->fixpath($tmp,1);
d1907 1
a1907 1
	unless (-f $libperl || -f ($libperl = File::Spec->catfile($Config{'installarchlib'},'CORE',$libperl))) {
d1914 2
a1915 2
	    $libperl = File::Spec->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}");
	} elsif (-f ($libperl = File::Spec->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}")) ) {
d1935 1
a1935 1
    push @@m,"\n${tmp}Makeaperl.Opt : \$(MAP_EXTRA)\n";
d1939 1
a1939 1
    push @@m,"\n${tmp}PerlShr.Opt :\n\t";
d1942 1
a1942 1
push @@m,'
d1945 6
a1950 6
$(MAP_TARGET) : $(MAP_SHRTARGET) ',"${tmp}perlmain\$(OBJ_EXT) ${tmp}PerlShr.Opt",'
	$(MAP_LINKCMD) ',"${tmp}perlmain\$(OBJ_EXT)",', PerlShr.Opt/Option
	$(NOECHO) $(SAY) "To install the new ""$(MAP_TARGET)"" binary, say"
	$(NOECHO) $(SAY) "    $(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
	$(NOECHO) $(SAY) "To remove the intermediate files, say
	$(NOECHO) $(SAY) "    $(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(MAKEFILE) map_clean"
d1952 1
a1952 1
    push @@m,"\n${tmp}perlmain.c : \$(MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmp}Writemain.tmp\n";
d1955 1
a1955 1
	push @@m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmp}Writemain.tmp\n];
d1957 5
a1961 3
	push @@m,'
	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@@F)" ',$tmp,'Writemain.tmp >$(MMS$TARGET)
	$(NOECHO) $(RM_F) ',"${tmp}Writemain.tmp\n";
d1966 7
a1972 6
	$(NOECHO) $(PERL) -e "print 'Perl binary $(MAP_TARGET)|'" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'MAP_STATIC|$(MAP_STATIC)|'" >>.MM_tmp
	$(NOECHO) $(PERL) -pl040 -e " " ].File::Spec->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
	$(NOECHO) $(PERL) -e "print 'MAP_LIBPERL|$(MAP_LIBPERL)|'" >>.MM_tmp
	$(DOC_INSTALL) <.MM_tmp >>].File::Spec->catfile('$(INSTALLARCHLIB)','perllocal.pod').q[
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
d1987 2
a1988 2
	\$(RM_F) ${tmp}perlmain\$(OBJ_EXT) ${tmp}perlmain.c \$(MAKEFILE)
	\$(RM_F) ${tmp}Makeaperl.Opt ${tmp}PerlShr.Opt \$(MAP_TARGET)
d2030 6
d2040 3
a2042 2
    my $path = $self->{uc $var} || $Config{lc $var} || 
               $Config{lc $var_no_install};
d2056 1
a2056 1
        my($path_vol, $path_dirs) = File::Spec->splitpath( $path );
d2093 1
a2093 1
    my($rvol, $rdirs) = File::Spec->splitpath($rprefix);
d2095 2
a2096 2
        return File::Spec->catpath($rvol,
                                   File::Spec->catdir($rdirs, $default),
d2101 101
a2201 1
        return File::Spec->catdir($rdirs, $default);
d2203 2
d2207 126
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@a2 2
#   This package is inserted into @@ISA of MakeMaker's MM before the
#   built-in ExtUtils::MM_Unix methods if MakeMaker.pm is run under VMS.
d8 2
d16 6
a21 2
our($Revision, @@ISA);
$Revision = '5.56 (27-Apr-1999)';
d23 1
a23 2
@@ISA = qw( File::Spec );
unshift @@MM::ISA, 'ExtUtils::MM_VMS';
a24 1
Exporter::import('ExtUtils::MakeMaker', '$Verbose', '&neatvalue');
d32 3
a34 1
 use ExtUtils::MM_VMS; # Done internally by ExtUtils::MakeMaker if needed
d44 1
a44 1
=over
a69 86
=item rootdir (override)

Returns a string representing of the root directory.

=cut

sub rootdir {
    return '';
}

package ExtUtils::MM_VMS;

sub ExtUtils::MM_VMS::ext;
sub ExtUtils::MM_VMS::guess_name;
sub ExtUtils::MM_VMS::find_perl;
sub ExtUtils::MM_VMS::path;
sub ExtUtils::MM_VMS::maybe_command;
sub ExtUtils::MM_VMS::maybe_command_in_dirs;
sub ExtUtils::MM_VMS::perl_script;
sub ExtUtils::MM_VMS::file_name_is_absolute;
sub ExtUtils::MM_VMS::replace_manpage_separator;
sub ExtUtils::MM_VMS::init_others;
sub ExtUtils::MM_VMS::constants;
sub ExtUtils::MM_VMS::cflags;
sub ExtUtils::MM_VMS::const_cccmd;
sub ExtUtils::MM_VMS::pm_to_blib;
sub ExtUtils::MM_VMS::tool_autosplit;
sub ExtUtils::MM_VMS::tool_xsubpp;
sub ExtUtils::MM_VMS::xsubpp_version;
sub ExtUtils::MM_VMS::tools_other;
sub ExtUtils::MM_VMS::dist;
sub ExtUtils::MM_VMS::c_o;
sub ExtUtils::MM_VMS::xs_c;
sub ExtUtils::MM_VMS::xs_o;
sub ExtUtils::MM_VMS::top_targets;
sub ExtUtils::MM_VMS::dlsyms;
sub ExtUtils::MM_VMS::dynamic_lib;
sub ExtUtils::MM_VMS::dynamic_bs;
sub ExtUtils::MM_VMS::static_lib;
sub ExtUtils::MM_VMS::manifypods;
sub ExtUtils::MM_VMS::processPL;
sub ExtUtils::MM_VMS::installbin;
sub ExtUtils::MM_VMS::subdir_x;
sub ExtUtils::MM_VMS::clean;
sub ExtUtils::MM_VMS::realclean;
sub ExtUtils::MM_VMS::dist_basics;
sub ExtUtils::MM_VMS::dist_core;
sub ExtUtils::MM_VMS::dist_dir;
sub ExtUtils::MM_VMS::dist_test;
sub ExtUtils::MM_VMS::install;
sub ExtUtils::MM_VMS::perldepend;
sub ExtUtils::MM_VMS::makefile;
sub ExtUtils::MM_VMS::test;
sub ExtUtils::MM_VMS::test_via_harness;
sub ExtUtils::MM_VMS::test_via_script;
sub ExtUtils::MM_VMS::makeaperl;
sub ExtUtils::MM_VMS::ext;
sub ExtUtils::MM_VMS::nicetext;

#use SelfLoader;
sub AUTOLOAD {
    my $code;
    if (defined fileno(DATA)) {
	my $fh = select DATA;
	my $o = $/;			# For future reads from the file.
	$/ = "\n__END__\n";
	$code = <DATA>;
	$/ = $o;
	select $fh;
	close DATA;
	eval $code;
	if ($@@) {
	    $@@ =~ s/ at .*\n//;
	    Carp::croak $@@;
	}
    } else {
	warn "AUTOLOAD called unexpectedly for $AUTOLOAD"; 
    }
    defined(&$AUTOLOAD) or die "Myloader inconsistency error";
    goto &$AUTOLOAD;
}

1;

#__DATA__

d75 1
d77 2
a78 2
  require ExtUtils::Liblist;
  ExtUtils::Liblist::Kid::ext(@@_);
d83 1
a83 1
=head2 SelfLoaded methods
d91 1
a91 1
=over
d121 5
a125 1
        if (%xs) { foreach $pm (@@pm) { $defpm = $pm, last if exists $xs{$pm}; } }
d163 2
a164 2
    @@sdirs = sort { my($absa) = $self->file_name_is_absolute($a);
                    my($absb) = $self->file_name_is_absolute($b);
d190 1
a190 1
	$inabs++ if $self->file_name_is_absolute($dir);
d199 1
a199 1
	    if ($name !~ m![/:>\]]!) { push(@@cand,$self->catfile($dir,$name)); }
a235 13
=item path (override)

Translate logical name DCL$PATH as a searchlist, rather than trying
to C<split> string value of C<$ENV{'PATH'}>.

=cut

sub path {
    my(@@dirs,$dir,$i);
    while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@@dirs,$dir); }
    @@dirs;
}

d283 1
a283 1
	    if ($self->file_name_is_absolute($name)) {
d286 1
a286 1
		$abs = $self->catfile($dir, $name);
a321 13
=item file_name_is_absolute (override)

Checks for VMS directory spec as well as Unix separators.

=cut

sub file_name_is_absolute {
    my($self,$file) = @@_;
    # If it's a logical name, expand it.
    $file = $ENV{$file} while $file =~ /^[\w\$\-]+$/ and $ENV{$file};
    $file =~ m!^/! or $file =~ m![<\[][^.\-\]>]! or $file =~ /:[^<\[]/;
}

d335 14
d365 1
a365 1
    $self->{RM_RF} = '$(PERL) "-I$(PERL_LIB)" -e "use File::Path; @@dirs = map(VMS::Filespec::unixify($_),@@ARGV); rmtree(\@@dirs,0,0)"';
d371 2
a372 1
    &ExtUtils::MM_Unix::init_others;
d390 1
d409 6
a414 2
	if (@@defs)  { $self->{DEFINE}  = '/Define=(' . join(',',@@defs)  . ')'; }
	if (@@udefs) { $self->{DEFINE} .= '/Undef=('  . join(',',@@udefs) . ')'; }
a423 3
    # Fix up directory specs
    $self->{ROOTEXT} = $self->{ROOTEXT} ? $self->fixpath($self->{ROOTEXT},1)
                                        : '[]';
d425 8
a432 5
            INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB INST_EXE INSTALLPRIVLIB
            INSTALLARCHLIB INSTALLSCRIPT INSTALLBIN PERL_LIB PERL_ARCHLIB
            PERL_INC PERL_SRC FULLEXT INST_MAN1DIR INSTALLMAN1DIR
            INST_MAN3DIR INSTALLMAN3DIR INSTALLSITELIB INSTALLSITEARCH
            SITELIBEXP SITEARCHEXP ] ) {
d434 1
d437 1
a437 1
    $self->{PERL_VMS} = $self->catdir($self->{PERL_SRC},q(VMS))
d449 11
a459 5
	      AR_STATIC_ARGS NAME DISTNAME NAME_SYM VERSION VERSION_SYM XS_VERSION
	      INST_BIN INST_EXE INST_LIB INST_ARCHLIB INST_SCRIPT PREFIX
	      INSTALLDIRS INSTALLPRIVLIB  INSTALLARCHLIB INSTALLSITELIB
	      INSTALLSITEARCH INSTALLBIN INSTALLSCRIPT PERL_LIB
	      PERL_ARCHLIB SITELIBEXP SITEARCHEXP LIBPERL_A MYEXTLIB
d461 3
a463 1
	      PERL_INC PERL FULLPERL
d476 1
a476 1
MAKEMAKER = ],$self->catfile($self->{PERL_LIB},'ExtUtils','MakeMaker.pm'),qq[
d487 1
a487 1
    for $tmp (qw/
d494 1
a494 1
    for $tmp (qw/
d501 3
a503 2
    for $tmp (qw/ XS MAN1PODS MAN3PODS PM /) {
	next unless defined $self->{$tmp};
d511 1
a511 1
    for $tmp (qw/ C O_FILES H /) {
d532 5
a536 2
    for $tmp (qw/
	      INST_MAN1DIR INSTALLMAN1DIR MAN1EXT INST_MAN3DIR INSTALLMAN3DIR MAN3EXT
d543 3
d637 1
a637 1
    for $type (qw(Def Undef)) {
d667 2
a684 2
SPLIT =
LARGE =
d717 1
a717 1
		($Config{'arch'} eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'
d737 2
a738 3
    my($line,$from,$to,@@m);
    my($autodir) = $self->catdir('$(INST_LIB)','auto');
    my(@@files) = @@{$self->{PM_TO_BLIB}};
d740 1
a740 1
    push @@m, q{
d749 25
a773 2
	$(NOECHO) $(PERL) -e "print '},shift(@@files),q{ },shift(@@files),q{'" >.MM_tmp
};
a774 7
    $line = '';  # avoid uninitialized var warning
    while ($from = shift(@@files),$to = shift(@@files)) {
	$line .= " $from $to";
	if (length($line) > 128) {
	    push(@@m,"\t\$(NOECHO) \$(PERL) -e \"print '$line'\" >>.MM_tmp\n");
	    $line = '';
	}
d776 3
a778 7
    push(@@m,"\t\$(NOECHO) \$(PERL) -e \"print '$line'\" >>.MM_tmp\n") if $line;

    push(@@m,q[	$(PERL) "-I$(PERL_LIB)" "-MExtUtils::Install" -e "pm_to_blib({split(' ',<STDIN>)},'].$autodir.q[','$(PM_FILTER)')" <.MM_tmp]);
    push(@@m,qq[
	\$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
	\$(NOECHO) \$(TOUCH) pm_to_blib.ts
]);
d780 1
a780 1
    join('',@@m);
d789 1
a789 1
sub tool_autosplit{
d795 1
a795 1
AUTOSPLITFILE = $(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e "use AutoSplit;}.$asl.q{ AutoSplit::autosplit($ARGV[0], $ARGV[1], 0, 1, 1) ;"
d808 1
a808 1
    my($xsdir) = $self->catdir($self->{PERL_LIB},'ExtUtils');
d810 1
a810 1
    $xsdir = $self->catdir($self->{PERL_SRC},'ext') unless (-f $self->catfile($xsdir,'xsubpp'));
d834 1
a834 1
    my $xsubpp_version = $self->xsubpp_version($self->catfile($xsdir,'xsubpp'));
d852 1
a852 1
XSUBPP = \$(PERL) \"-I\$(PERL_ARCHLIB)\" \"-I\$(PERL_LIB)\" \$(XSUBPPDIR)xsubpp
d876 1
a876 1
    my $command = "$self->{PERL} \"-I$self->{PERL_LIB}\" $xsubpp -v";
d906 1
a906 1
    $command = "$self->{PERL} $xsubpp $file";
a954 2
NOOP = $self->{NOOP}
NOECHO = $self->{NOECHO}
d959 1
a959 1
MOD_INSTALL = \$(PERL) "-I\$(PERL_LIB)" "-MExtUtils::Install" -e "install({split(' ',<STDIN>)},1);"
d961 1
a961 1
UNINSTALL = \$(PERL) "-I\$(PERL_LIB)" "-MExtUtils::Install" -e "uninstall(\$ARGV[0],1,1);"
d986 3
a988 1
    return ExtUtils::MM_Unix::dist($self,%attribs);
d1047 1
a1047 1
Use VMS quoting on command line for Version_check.
a1098 6
    push @@m, q{
Version_check :
	$(NOECHO) $(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -
	"-MExtUtils::MakeMaker=Version_check" -e "&Version_check('$(MM_VERSION)')"
};

d1137 1
a1137 1
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e "use ExtUtils::Mksymlists;" -
d1236 1
a1236 1
	$(NOECHO) $(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -
d1268 1
a1268 1
    # If this extension has it's own library (eg SDBM_File)
d1306 1
a1306 1
	$pod2man_exe = $self->catfile($self->{PERL_SRC},'pod','pod2man');
d1308 1
a1308 1
	$pod2man_exe = $self->catfile($Config{scriptdirexp},'pod2man');
d1324 2
a1325 2
q[POD2MAN = $(PERL) -we "%m=@@ARGV;for (keys %m){" -
-e "system(""MCR $^X $(POD2MAN_EXE) $_ >$m{$_}"");}"
d1356 1
a1356 1
	foreach $target (@@$list) {
d1364 1
a1364 1
",'	$(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" '," $vmsplfile $vmsfile
a1395 3
all :: @@to
	\$(NOECHO) \$(NOOP)

d1483 1
a1483 1
    push(@@otherfiles,$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));
d1520 2
a1521 2
    push @@m,'	$(RM_RF) $(INST_AUTODIR) $(INST_ARCHAUTODIR)
';
a1571 22
=item dist_basics (override)

Use VMS-style quoting on command line.

=cut

sub dist_basics {
    my($self) = @@_;
'
distclean :: realclean distcheck
	$(NOECHO) $(NOOP)

distcheck :
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e "use ExtUtils::Manifest \'&fullcheck\'; fullcheck()"

skipcheck :
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e "use ExtUtils::Manifest \'&skipcheck\'; skipcheck()"

manifest :
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e "use ExtUtils::Manifest \'&mkmanifest\'; mkmanifest()"
';
}
a1613 16
=item dist_dir (override)

Use VMS-style quoting on command line.

=cut

sub dist_dir {
    my($self) = @@_;
q{
distdir :
	$(RM_RF) $(DISTVNAME)
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e "use ExtUtils::Manifest '/mani/';" \\
	-e "manicopy(maniread(),'$(DISTVNAME)','$(DIST_CP)');"
};
}

d1627 1
a1627 1
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" Makefile.PL
d1652 1
a1652 1
		push(@@docfiles,qq[\t\$(PERL) -e "print '$line'" >>.MM_tmp\n]);
d1656 1
a1656 1
	push(@@docfiles,qq[\t\$(PERL) -e "print '$line'" >>.MM_tmp\n]) if $line;
a1668 3
install_ :: install_site
	$(NOECHO) $(SAY) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"

d1683 2
a1684 2
	$(NOECHO) $(PERL) -e "print 'read ].$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q[ '" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'write ].$self->catfile('$(INSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q[ '" >>.MM_tmp
d1693 1
a1693 1
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q[
d1697 2
a1698 2
	$(NOECHO) $(PERL) -e "print 'read ].$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q[ '" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'write ].$self->catfile('$(INSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q[ '" >>.MM_tmp
d1701 12
a1712 1
	$(NOECHO) $(PERL) -e "print '$(INST_BIN) $(INSTALLBIN) '" >>.MM_tmp
d1714 2
a1715 2
	$(NOECHO) $(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLMAN1DIR) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLMAN3DIR) '" >>.MM_tmp
a1717 1
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q[
d1728 1
a1728 1
	$(NOECHO) $(PERL) .MM2_tmp <.MM_tmp >>%.$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q[
d1740 1
a1740 1
	$(NOECHO) $(PERL) .MM2_tmp <.MM_tmp >>%.$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q[
d1743 2
d1752 1
a1752 1
	$(NOECHO) $(UNINSTALL) ].$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q[
d1758 1
a1758 1
	$(NOECHO) $(UNINSTALL) ],$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist'),"\n",q[
d1780 15
a1794 8
$(OBJECT) : $(PERL_INC)EXTERN.h, $(PERL_INC)INTERN.h, $(PERL_INC)XSUB.h, $(PERL_INC)av.h
$(OBJECT) : $(PERL_INC)cop.h, $(PERL_INC)cv.h, $(PERL_INC)embed.h, $(PERL_INC)form.h
$(OBJECT) : $(PERL_INC)gv.h, $(PERL_INC)handy.h, $(PERL_INC)hv.h, $(PERL_INC)keywords.h
$(OBJECT) : $(PERL_INC)mg.h, $(PERL_INC)op.h, $(PERL_INC)opcode.h, $(PERL_INC)patchlevel.h
$(OBJECT) : $(PERL_INC)perl.h, $(PERL_INC)perly.h, $(PERL_INC)pp.h, $(PERL_INC)proto.h
$(OBJECT) : $(PERL_INC)regcomp.h, $(PERL_INC)regexp.h, $(PERL_INC)scope.h, $(PERL_INC)sv.h
$(OBJECT) : $(PERL_INC)vmsish.h, $(PERL_INC)util.h, $(PERL_INC)config.h
$(OBJECT) : $(PERL_INC)iperlsys.h
d1801 1
a1801 1
	push(@@macros,'__AXP__=1') if $Config{'arch'} eq 'VMS_AXP';
d1860 1
a1860 1
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" Makefile.PL ],join(' ',map(qq["$_"],@@ARGV)),q[
d1868 9
d1885 1
a1885 1
    my($tests) = $attribs{TESTS} || ( -d 't' ? 't/*.t' : '');
d1910 2
a1911 2
    push(@@m, $self->test_via_harness('$(FULLPERL)', $tests)) if $tests;
    push(@@m, $self->test_via_script('$(FULLPERL)', 'test.pl')) if -f "test.pl";
d1916 1
a1916 1
    push(@@m, $self->test_via_script('$(FULLPERL) "$(TESTDB_SW)"', '$(TEST_FILE)'));
a1938 24
=item test_via_harness (override)

Use VMS-style quoting on command line.

=cut

sub test_via_harness {
    my($self,$perl,$tests) = @@_;
    "	$perl".' "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" "-I$(PERL_LIB)" "-I$(PERL_ARCHLIB)" \\'."\n\t".
    '-e "use Test::Harness qw(&runtests $verbose); $verbose=$(TEST_VERBOSE); runtests @@ARGV;" \\'."\n\t$tests\n";
}

=item test_via_script (override)

Use VMS-style quoting on command line.

=cut

sub test_via_script {
    my($self,$perl,$script) = @@_;
    "	$perl".' "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" '.$script.'
';
}

d1948 2
d1967 1
a1967 1
	$(NOECHO) $(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" \
d1992 1
a1992 1
    local(%olbs);
d2089 1
d2102 1
a2102 1
	unless (-f $libperl || -f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',$libperl))) {
d2109 2
a2110 2
	    $libperl = $self->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}");
	} elsif (-f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}")) ) {
d2161 1
a2161 1
	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
d2163 1
a2163 1
	$(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q[
a2196 1

d2198 1
d2203 87
a2289 1
1;
d2295 1
a2295 1
__END__
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d154 1
a154 1
# appears in @@MM::ISA before ExtUtils::Liblist, so if there isn't an ext()
d156 1
a156 1
# mimic inheritance here and hand off to ExtUtils::Liblist.
d158 2
a159 1
  ExtUtils::Liblist::ext(@@_);
d235 1
d237 1
d283 8
a290 2
	if ($name =~ /^[\w\-\$]+$/ &&
            `$name -e "require $ver; print ""VER_OK\\n"""` =~ /VER_OK/) {
d294 1
d298 7
a304 1
        if (`MCR $vmsfile -e "require $ver; print ""VER_OK\\n"""` =~ /VER_OK/) {
d630 1
a630 1
INST_DYNAMIC = $(INST_ARCHAUTODIR)$(BASEEXT).$(DLEXT)
d830 1
a830 1
    push(@@m,q[	$(PERL) "-I$(PERL_LIB)" "-MExtUtils::Install" -e "pm_to_blib({split(' ',<STDIN>)},'].$autodir.q[')" <.MM_tmp]);
d885 5
d1042 1
a1042 1
    $attribs{NAME} =~ s/[^\w\$]/_/g;
d1218 2
a1219 2
	my($tmp,@@lines,$elt) = '';
	my $tmp = shift @@omods;
d1676 3
d1688 1
a1688 1
	$(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)]
d1899 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d15 3
d19 1
a19 3
use vars qw($Revision);
$Revision = '5.52 (12-Sep-1998)';

a41 150
=item eliminate_macros

Expands MM[KS]/Make macros in a text string, using the contents of
identically named elements of C<%$self>, and returns the result
as a file specification in Unix syntax.

=cut

sub eliminate_macros {
    my($self,$path) = @@_;
    unless ($path) {
	print "eliminate_macros('') = ||\n" if $Verbose >= 3;
	return '';
    }
    my($npath) = unixify($path);
    my($complex) = 0;
    my($head,$macro,$tail);

    # perform m##g in scalar context so it acts as an iterator
    while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#g) { 
        if ($self->{$2}) {
            ($head,$macro,$tail) = ($1,$2,$3);
            if (ref $self->{$macro}) {
                if (ref $self->{$macro} eq 'ARRAY') {
                    print "Note: expanded array macro \$($macro) in $path\n" if $Verbose;
                    $macro = join ' ', @@{$self->{$macro}};
                }
                else {
                    print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                          "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                    $macro = "\cB$macro\cB";
                    $complex = 1;
                }
            }
            else { ($macro = unixify($self->{$macro})) =~ s#/$##; }
            $npath = "$head$macro$tail";
        }
    }
    if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#g; }
    print "eliminate_macros($path) = |$npath|\n" if $Verbose >= 3;
    $npath;
}

=item fixpath

Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
in any directory specification, in order to avoid juxtaposing two
VMS-syntax directories when MM[SK] is run.  Also expands expressions which
are all macro, so that we can tell how long the expansion is, and avoid
overrunning DCL's command buffer when MM[KS] is running.

If optional second argument has a TRUE value, then the return string is
a VMS-syntax directory specification, if it is FALSE, the return string
is a VMS-syntax file specification, and if it is not specified, fixpath()
checks to see whether it matches the name of a directory in the current
default directory, and returns a directory or file specification accordingly.

=cut

sub fixpath {
    my($self,$path,$force_path) = @@_;
    unless ($path) {
	print "eliminate_macros('') = ||\n" if $Verbose >= 3;
	return '';
    }
    my($fixedpath,$prefix,$name);

    if ($path =~ m#^\$\([^\)]+\)$# || $path =~ m#[/:>\]]#) { 
        if ($force_path or $path =~ /(?:DIR\)|\])$/) {
            $fixedpath = vmspath($self->eliminate_macros($path));
        }
        else {
            $fixedpath = vmsify($self->eliminate_macros($path));
        }
    }
    elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#)) && $self->{$prefix}) {
        my($vmspre) = $self->eliminate_macros("\$($prefix)");
        # is it a dir or just a name?
        $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR$/) ? vmspath($vmspre) : '';
        $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    else {
        $fixedpath = $path;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    # No hints, so we try to guess
    if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
        $fixedpath = vmspath($fixedpath) if -d $fixedpath;
    }
    # Trim off root dirname if it's had other dirs inserted in front of it.
    $fixedpath =~ s/\.000000([\]>])/$1/;
    print "fixpath($path) = |$fixedpath|\n" if $Verbose >= 3;
    $fixedpath;
}

=item catdir

Concatenates a list of file specifications, and returns the result as a
VMS-syntax directory specification.

=cut

sub catdir {
    my($self,@@dirs) = @@_;
    my($dir) = pop @@dirs;
    @@dirs = grep($_,@@dirs);
    my($rslt);
    if (@@dirs) {
      my($path) = (@@dirs == 1 ? $dirs[0] : $self->catdir(@@dirs));
      my($spath,$sdir) = ($path,$dir);
      $spath =~ s/.dir$//; $sdir =~ s/.dir$//; 
      $sdir = $self->eliminate_macros($sdir) unless $sdir =~ /^[\w\-]+$/;
      $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
    }
    else { 
      if ($dir =~ /^\$\([^\)]+\)$/) { $rslt = $dir; }
      else                          { $rslt = vmspath($dir); }
    }
    print "catdir(",join(',',@@_[1..$#_]),") = |$rslt|\n" if $Verbose >= 3;
    $rslt;
}

=item catfile

Concatenates a list of file specifications, and returns the result as a
VMS-syntax directory specification.

=cut

sub catfile {
    my($self,@@files) = @@_;
    my($file) = pop @@files;
    @@files = grep($_,@@files);
    my($rslt);
    if (@@files) {
      my($path) = (@@files == 1 ? $files[0] : $self->catdir(@@files));
      my($spath) = $path;
      $spath =~ s/.dir$//;
      if ( $spath =~ /^[^\)\]\/:>]+\)$/ && basename($file) eq $file) { $rslt = "$spath$file"; }
      else {
          $rslt = $self->eliminate_macros($spath);
          $rslt = vmsify($rslt.($rslt ? '/' : '').unixify($file));
      }
    }
    else { $rslt = vmsify($file); }
    print "catfile(",join(',',@@_[1..$#_]),") = |$rslt|\n" if $Verbose >= 3;
    $rslt;
}

a65 10
=item curdir (override)

Returns a string representing of the current directory.

=cut

sub curdir {
    return '[]';
}

a75 10
=item updir (override)

Returns a string representing of the parent directory.

=cut

sub updir {
    return '[-]';
}

d281 1
a281 1
	    `$name -e "require $ver; print ""VER_OK\n"""` =~ /VER_OK/) {
d288 1
a288 1
	if (`MCR $vmsfile -e "require $ver; print ""VER_OK\n"""` =~ /VER_OK/) {
d459 3
d463 3
a465 2
	my(@@defs) = split(/\s+/,$self->{DEFINE});
	foreach $def (@@defs) {
d467 3
a469 1
	    if ($def =~ s/^-D//) {       # If it was a Unix-style definition
d477 1
d479 3
a481 1
	$self->{DEFINE} = join ',',@@defs;
d680 1
d686 16
a701 7
    if ($quals =~ m:(.*)/define=\(?([^\(\/\)\s]+)\)?(.*)?:i) {
	$quals = "$1/Define=($2," . ($self->{DEFINE} ? "$self->{DEFINE}," : '') .
	         "\$(DEFINE_VERSION),\$(XS_DEFINE_VERSION))$3";
    }
    else {
	$quals .= '/Define=(' . ($self->{DEFINE} ? "$self->{DEFINE}," : '') .
	          '$(DEFINE_VERSION),$(XS_DEFINE_VERSION))';
a704 11
# This whole section is commented out, since I don't think it's necessary (or applicable)
#    if ($libperl =~ s/^$Config{'dbgprefix'}//) { $libperl =~ s/perl([^Dd]*)\./perld$1./; }
#    if ($libperl =~ /libperl(\w+)\./i) {
#	my($type) = uc $1;
#	my(%map) = ( 'D'  => 'DEBUGGING', 'E' => 'EMBED', 'M' => 'MULTIPLICITY',
#	             'DE' => 'DEBUGGING,EMBED', 'DM' => 'DEBUGGING,MULTIPLICITY',
#	             'EM' => 'EMBED,MULTIPLICITY', 'DEM' => 'DEBUGGING,EMBED,MULTIPLICITY' );
#	my($add) = join(',', grep { $quals !~ /\b$_\b/ } split(/,/,$map{$type}));
#	$quals =~ s:/define=\(([^\)]+)\):/Define=($1,$add):i if $add;
#	$self->{PERLTYPE} ||= $type;
#    }
d715 1
d720 1
a720 1
	if    ($self->{OPTIMIZE} =~ m!\b-g\b!) { $self->{OPTIMIZE} = '/Debug/NoOptimize' }
a1108 7
    push @@m, q{
config :: Version_check
	$(NOECHO) $(NOOP)

} unless $self->{PARENT} or ($self->{PERL_SRC} && $self->{INSTALLDIRS} eq "perl") or $self->{NO_VC};


d1173 1
a1173 1
    push(@@m,'
d1181 26
a1206 3
	q[, 'FUNCLIST' => ],neatvalue($funclist),')"
	$(PERL) -e "print ""$(INST_STATIC)/Include=$(BASEEXT)\n$(INST_STATIC)/Library\n"";" >>$(MMS$TARGET)
');
d1324 2
a1325 2
    foreach $lib (split $self->{EXTRALIBS}) {
      $lib = '""' if $lib eq '"';
d2045 3
a2047 1
		MAKEAPERL=1 NORECURS=1
a2051 1
	push @@m, map( " \\\n\t\t$_", @@ARGV );
d2172 1
a2172 1
    # Let ExtUtils::Liblist find the necessary for us (but skip PerlShr;
d2174 1
a2174 1
    push @@optlibs, grep { !/PerlShr/i } split +($self->ext())[2];
@


1.2
log
@perl 5.004_04
@
text
@d6 1
a6 1
#   Author:  Charles Bailey  bailey@@genetics.upenn.edu
d17 1
a17 1
$Revision = '5.3901 (6-Mar-1997)';
d64 10
a73 3
              carp "Can't expand macro containing " . ref $self->{$macro};
              $npath = "$head\cB$macro\cB$tail";
              $complex = 1;
d79 1
a79 1
    if ($complex) { $npath =~ s#\cB(.*?)\cB#\$($1)#g; }
d93 4
a96 2
a VMS-syntax directory specification, otherwise it is a VMS-syntax file
specification.
d127 4
a130 2
    # Convert names without directory or type to paths
    if (!$force_path and $fixedpath !~ /[:>(.\]]/) { $fixedpath = vmspath($fixedpath); }
d207 1
a207 1
      $line .= ', ' if length($line);
d443 1
a443 1
	    else                     { push(@@cand,$self->fixpath($name));      }
d646 1
a646 1
	$self->{OBJECT} = join(' ',map($self->fixpath($_),split(/,?\s+/,$self->{OBJECT})));
d648 1
a648 1
    $self->{LDFROM} = join(' ',map($self->fixpath($_),split(/,?\s+/,$self->{LDFROM})));
d671 1
a671 1
	$self->{$macro} = $self->fixpath($self->{$macro});
d709 1
a709 1
	push @@m, "$tmp = ",$self->fixpath($self->{$tmp}),"\n";
d723 1
a723 1
	    $tmp{$self->fixpath($key)} = $self->fixpath($self->{$tmp}{$key});
d732 1
a732 1
	    push(@@tmp,$self->fixpath($val));
d740 6
a745 6
XS_FILES = ',$self->wraplist(', ', sort keys %{$self->{XS}}),'
C_FILES  = ',$self->wraplist(', ', @@{$self->{C}}),'
O_FILES  = ',$self->wraplist(', ', @@{$self->{O_FILES}} ),'
H_FILES  = ',$self->wraplist(', ', @@{$self->{H}}),'
MAN1PODS = ',$self->wraplist(', ', sort keys %{$self->{MAN1PODS}}),'
MAN3PODS = ',$self->wraplist(', ', sort keys %{$self->{MAN3PODS}}),'
d778 1
d784 1
a784 1
PERL_ARCHIVE = ',($ENV{'PERLSHR'} ? $ENV{'PERLSHR'} : "Sys\$Share:PerlShr.$Config{'dlext'}"),'
d791 1
a791 1
TO_INST_PM = ',$self->wraplist(', ',@@{$self->{TO_INST_PM}}),'
d793 1
a793 1
PM_TO_BLIB = ',$self->wraplist(', ',@@{$self->{PM_TO_BLIB}}),'
d810 3
a812 1
    my($quals) = $Config{'ccflags'};
a813 1
    my($optimize) = '/Optimize';
d820 22
d844 1
a844 1
    # conflate the ones from $Config{'cc'} and $self->{DEFINE}
d855 11
a865 7
    if ($libperl =~ /libperl(\w+)\./i) {
        my($type) = uc $1;
        my(%map) = ( 'D'  => 'DEBUGGING', 'E' => 'EMBED', 'M' => 'MULTIPLICITY',
                     'DE' => 'DEBUGGING,EMBED', 'DM' => 'DEBUGGING,MULTIPLICITY',
                     'EM' => 'EMBED,MULTIPLICITY', 'DEM' => 'DEBUGGING,EMBED,MULTIPLICITY' );
        $quals =~ s:/define=\(([^\)]+)\):/Define=($1,$map{$type}):i
    }
a867 1
    my($incstr) = '/Include=($(PERL_INC)';
d872 1
a872 1
	    $incstr .= ', '.$self->fixpath($_,1);
d876 1
d878 11
a888 2
    $optimize = '/Debug/NoOptimize'
	if ($self->{OPTIMIZE} =~ /-g/ or $self->{OPTIMIZE} =~ m!/Debug!i);
d891 3
a893 3
CCFLAGS = $quals
OPTIMIZE = $optimize
PERLTYPE =
d1019 1
a1019 1
			push(@@tmdeps, $self->fixpath($typemap));
d1325 1
a1325 1
    my($srcdir)= $attribs{PERL_SRC} || $self->{PERL_SRC} || '';
d1330 1
a1330 1
dynamic :: rtls.opt $(INST_ARCHAUTODIR)$(BASEEXT).opt
a1332 16
	if ($srcdir) {
	   my($popt) = $self->catfile($srcdir,'perlshr.opt');
	   my($lopt) = $self->catfile($srcdir,'crtl.opt');
	   push(@@m,"# Depend on \$(BASEEXT).opt to insure we copy here *after* autogenerating (wrong) rtls.opt in Mksymlists
rtls.opt : $popt $lopt \$(BASEEXT).opt
	Copy/Log $popt Sys\$Disk:[]rtls.opt
	Append/Log $lopt Sys\$Disk:[]rtls.opt
");
	}
	else {
	    push(@@m,'
# rtls.opt is built in the same step as $(BASEEXT).opt
rtls.opt : $(BASEEXT).opt
	$(TOUCH) $(MMS$TARGET)
');
	}
d1347 2
a1348 1
	neatvalue($funcs),q[, 'DL_VARS' => ],neatvalue($vars),')"
d1383 1
d1392 1
a1392 1
$(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt rtls.opt $(INST_ARCHAUTODIR).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
d1394 2
a1395 2
	$(NOECHO) If F$TrnLNm("PerlShr").eqs."" Then Define/NoLog/User PerlShr Sys$Share:PerlShr.',$Config{'dlext'},'
	Link $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) $(BASEEXT).opt/Option,rtls.opt/Option,$(PERL_INC)perlshr_attr.opt/Option
d1446 1
a1446 1
    my(@@m);
d1455 1
a1455 1
    push(@@m, '	$(CP) $(MYEXTLIB) $(MMS$TARGET)',"\n") if $self->{MYEXTLIB};
d1457 15
a1471 5
    push(@@m,'
	If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)
	Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)
	$(NOECHO) $(PERL) -e "open F,\'>>$(INST_ARCHAUTODIR)extralibs.ld\';print F qq{$(EXTRALIBS)\n};close F;"
');
a1476 25
# sub installpm_x { # called by installpm perl file
#     my($self, $dist, $inst, $splitlib) = @@_;
#     if ($inst =~ m!#!) {
# 	warn "Warning: MM[SK] would have problems processing this file: $inst, SKIPPED\n";
# 	return '';
#     }
#     $inst = $self->fixpath($inst);
#     $dist = $self->fixpath($dist);
#     my($instdir) = $inst =~ /([^\)]+\))[^\)]*$/ ? $1 : dirname($inst);
#     my(@@m);
# 
#     push(@@m, "
# $inst : $dist \$(MAKEFILE) ${instdir}.exists \$(INST_ARCHAUTODIR).exists
# ",'	$(NOECHO) $(RM_F) $(MMS$TARGET)
# 	$(NOECHO) $(CP) ',"$dist $inst",'
# 	$(CHMOD) 644 $(MMS$TARGET)
# ');
#     push(@@m, '	$(AUTOSPLITFILE) $(MMS$TARGET) ',
#               $self->catdir($splitlib,'auto')."\n\n")
#         if ($splitlib and $inst =~ /\.pm$/);
#     push(@@m,$self->dir_target($instdir));
# 
#     join('',@@m);
# }

d1538 7
a1544 3
	my $vmsplfile = vmsify($plfile);
	my $vmsfile = vmsify($self->{PL_FILES}->{$plfile});
	push @@m, "
d1549 1
a1549 1
",'	$(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" '," $vmsplfile
d1551 1
d1667 1
a1667 1
	    else { push(@@otherfiles, $attribs{FILES}); }
d1674 3
d1721 2
d1741 1
a1741 1
	    else { push(@@allfiles, $attribs{FILES}); }
d1744 2
d1984 1
a1984 3
than to have the MM_Unix method call C<catfile> repeatedly.  Also use
config.vms as source of original config data if the Perl distribution
is available; config.sh is an ancillary file under VMS.  Finally, if
d2001 1
d2018 4
a2021 7
#$(PERL_INC)config.h : $(PERL_SRC)config.sh
$(PERL_INC)config.h : $(PERL_VMS)config.vms
	$(NOECHO) Write Sys$Error "Warning: $(PERL_INC)config.h out of date with $(PERL_VMS)config.vms"

#$(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh
$(PERL_ARCHLIB)Config.pm : $(PERL_VMS)config.vms $(PERL_VMS)genconfig.pl
	$(NOECHO) Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.vms or genconfig.pl"
d2026 1
a2026 1
	    my($prefix,$target) = ($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm'));
d2036 1
a2036 1
    push(@@m, join(" ", map($self->fixpath($_),values %{$self->{XS}}))." : \$(XSUBPPDEPS)\n")
d2201 2
a2202 1
    my($linkcmd,@@staticopts,@@staticpkgs,$extralist,$targdir,$libperldir);
d2265 1
a2265 1
    for (sort keys %olbs) {
d2271 2
d2274 1
d2276 11
a2286 1
	    push @@$extra, <LIST>;
d2289 1
d2294 2
a2295 2
		# ExtUtils::Miniperl expects Unix paths
		(my($pkg) = "$1_$1$self->{LIB_EXT}") =~ s#_*#/#g;
a2297 1
	    push @@staticopts, $extopt;
d2300 5
d2313 5
a2317 5
    if (@@$extra) {
	$extralist = join(' ',@@$extra);
	$extralist =~ s/[,\s\n]+/, /g;
    }
    else { $extralist = ''; }
d2338 2
a2339 2
MAP_TARGET    = ',$self->fixpath($target),'
MAP_SHRTARGET = ',$self->fixpath($shrtarget),"
d2341 1
a2341 5
MAP_PERLINC   = ", $perlinc ? map('"$_" ',@@{$perlinc}) : '','
# We use the linker options files created with each extension, rather than
#specifying the object files directly on the command line.
MAP_STATIC    = ',@@staticopts ? join(' ', @@staticopts) : '','
MAP_OPTS    = ',@@staticopts ? ','.join(',', map($_.'/Option', @@staticopts)) : '',"
d2343 1
a2343 1
MAP_LIBPERL = ",$self->fixpath($libperl),'
d2347 10
a2356 3
    push @@m,'
$(MAP_SHRTARGET) : $(MAP_LIBPERL) $(MAP_STATIC) ',"${libperldir}Perlshr_Attr.Opt",'
	$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_OPTS), $(MAP_EXTRA), $(MAP_LIBPERL) ',"${libperldir}Perlshr_Attr.Opt",'
d2364 8
a2371 4
    push @@m,'
',"${tmp}perlmain.c",' : $(MAKEFILE)
	$(NOECHO) $(PERL) $(MAP_PERLINC) -e "use ExtUtils::Miniperl; writemain(qw|',@@staticpkgs,'|)" >$(MMS$TARGET)
';
d2374 1
a2374 1
# More from the 255-char line length limit
d2397 1
a2397 1
	\$(RM_F) ${tmp}PerlShr.Opt \$(MAP_TARGET)
@


1.1
log
@Initial revision
@
text
@a8 2
$ExtUtils::MM_VMS::Revision=$ExtUtils::MM_VMS::Revision = '5.35 (23-Jun-1996)';
unshift @@MM::ISA, 'ExtUtils::MM_VMS';
d10 1
d16 5
d39 2
d56 1
d63 6
a68 1
            ($macro = unixify($self->{$macro})) =~ s#/$##;
d72 1
d99 1
a99 1
    if ($path =~ m#^\$\(.+\)$# || $path =~ m#[/:>\]]#) { 
d108 3
a110 1
        my($vmspre) = vmspath($self->{$prefix}) || ''; # is it a dir or just a name?
d120 2
d143 5
a147 1
      $rslt = vmspath($self->eliminate_macros($spath)."/$sdir");
a148 1
    else { $rslt = vmspath($dir); }
d180 24
d236 1
a246 1
sub ExtUtils::MM_VMS::const_loadlibs;
d310 11
d329 2
d344 1
a344 1
    my($defname,$defpm);
d350 12
d389 1
a389 1
sub find_perl{
d392 1
d395 2
a396 2
    @@sdirs = sort { my($absb) = file_name_is_absolute($a);
                    my($absb) = file_name_is_absolute($b);
d405 10
a414 3
                     substr($ba,0,1) cmp substr($bb,0,1)
                     or -1*(length($ba) <=> length($bb)) } @@$names;
    if ($trace){
d422 8
d437 6
d448 1
a448 1
	    return "MCR $vmsfile"
d472 4
a475 4
appends F<.Exe> to check for executable image, and F<.Com> to check
for DCL procedure.  If this fails, checks F<Sys$Share:> for an
executable file having the name specified.  Finally, appends F<.Exe>
and checks again.
d482 3
a484 2
    return "$file.exe" if -x "$file.exe";
    return "$file.com" if -x "$file.com";
d486 12
a497 3
	my($shrfile) = 'Sys$Share:' . $file;
	return $file if -x $shrfile && ! -d _;
	return "$file.exe" if -x "$shrfile.exe";
d528 1
a528 1
		    print "Using PERL=$abs\n" if $trace;
d540 2
a541 2
If name passed in doesn't specify a readable file, appends F<.pl> and
tries again, since it's customary to have file types on all files
d549 2
a550 1
    return "$file.pl" if -r "$file.pl" && ! -d _;
d561 4
a564 2
    my($self,$file);
    $file =~ m!^/! or $file =~ m![:<\[][^.\-]!;
d590 1
a590 1
    $self->{NOOP} = "\t@@ Continue";
d601 1
a601 1
    $self->{UMASK_NULL} = "\t!";  
d621 8
a628 2
	    $def =~ s/^-D//;
	    $def = "\"$def\"" if $def =~ /=/;
d635 1
a635 1
	$self->{OBJECT} = map($self->fixpath($_),split(/,?\s+/,$self->{OBJECT}));
a638 11
    if ($self->{'INC'} && $self->{INC} !~ m!/Include=!i) {
	my(@@val) = ( '/Include=(' );
	my(@@includes) = split(/\s+/,$self->{INC});
	my($plural);
	foreach (@@includes) {
	    s/^-I//;
	    push @@val,', ' if $plural++;
	    push @@val,$self->fixpath($_,1);
	}
	$self->{INC} = join('',@@val,')');
    }
d695 8
a702 2
	      FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT
	      LDFROM LINKTYPE
d729 6
a734 6
XS_FILES = ',join(', ', sort keys %{$self->{XS}}),'
C_FILES  = ',join(', ', @@{$self->{C}}),'
O_FILES  = ',join(', ', @@{$self->{O_FILES}} ),'
H_FILES  = ',join(', ', @@{$self->{H}}),'
MAN1PODS = ',join(', ', sort keys %{$self->{MAN1PODS}}),'
MAN3PODS = ',join(', ', sort keys %{$self->{MAN3PODS}}),'
d746 1
d753 2
a754 2
INST_LIBDIR = ",($self->{'INST_LIBDIR'} = $self->catdir($self->{INST_LIB},$self->{ROOTEXT})),"
INST_ARCHLIBDIR = ",($self->{'INST_ARCHLIBDIR'} = $self->catdir($self->{INST_ARCHLIB},$self->{ROOTEXT})),"
d756 3
a758 3
INST_AUTODIR = ",($self->{'INST_AUTODIR'} = $self->catdir($self->{INST_LIB},'auto',$self->{FULLEXT})),'
INST_ARCHAUTODIR = ',($self->{'INST_ARCHAUTODIR'} = $self->catdir($self->{INST_ARCHLIB},'auto',$self->{FULLEXT})),'
';
d772 1
a772 1
PERL_ARCHIVE = ',($ENV{'PERLSHR'} ? $ENV{'PERLSHR'} : 'Sys$Share:PerlShr.Exe'),'
d779 1
a779 1
TO_INST_PM = ',join(', ',@@{$self->{TO_INST_PM}}),'
d781 1
a781 1
PM_TO_BLIB = ',join(', ',@@{$self->{PM_TO_BLIB}}),'
a786 51
=item const_loadlibs (override)

Basically a stub which passes through library specfications provided
by the caller.  Will be updated or removed when VMS support is added
to ExtUtils::Liblist.

=cut

sub const_loadlibs{
    my($self) = @@_;
    my (@@m);
    push @@m, "
# $self->{NAME} might depend on some other libraries.
# (These comments may need revising:)
#
# Dependent libraries can be linked in one of three ways:
#
#  1.  (For static extensions) by the ld command when the perl binary
#      is linked with the extension library. See EXTRALIBS below.
#
#  2.  (For dynamic extensions) by the ld command when the shared
#      object is built/linked. See LDLOADLIBS below.
#
#  3.  (For dynamic extensions) by the DynaLoader when the shared
#      object is loaded. See BSLOADLIBS below.
#
# EXTRALIBS =	List of libraries that need to be linked with when
#		linking a perl binary which includes this extension
#		Only those libraries that actually exist are included.
#		These are written to a file and used when linking perl.
#
# LDLOADLIBS =	List of those libraries which can or must be linked into
#		the shared library when created using ld. These may be
#		static or dynamic libraries.
#		LD_RUN_PATH is a colon separated list of the directories
#		in LDLOADLIBS. It is passed as an environment variable to
#		the process that links the shared library.
#
# BSLOADLIBS =	List of those libraries that are needed but can be
#		linked in dynamically at run time on this platform.
#		SunOS/Solaris does not need this because ld records
#		the information (from LDLOADLIBS) into the object file.
#		This list is used to create a .bs (bootstrap) file.
#
EXTRALIBS  = ",map($self->fixpath($_) . ' ',$self->{'EXTRALIBS'}),"
BSLOADLIBS = ",map($self->fixpath($_) . ' ',$self->{'BSLOADLIBS'}),"
LDLOADLIBS = ",map($self->fixpath($_) . ' ',$self->{'LDLOADLIBS'}),"\n";

    join('',@@m);
}

d791 2
a792 3
/Defines into one, and do the same with /Includes, since some C
compilers pay attention to only one instance of these qualifiers
on the command line.
d837 1
a837 4
    if ($quals =~ m:(.*)/include=\(?([^\(\/\)\s]+)\)?(.*):i) {
	$quals = "$1$incstr,$2)$3";
    }
    else { $quals .= "$incstr)"; }
d854 1
a854 1
handling #include <sys/foo.h> directives.  Also constructs CC
d905 6
d912 2
a913 2
pm_to_blib : $(TO_INST_PM)
	},$self->{NOECHO},q{$(PERL) -e "print '},shift(@@files),q{ },shift(@@files),q{'" >.MM_tmp
d920 1
a920 1
	    push(@@m,"\t$self->{NOECHO}\$(PERL) -e \"print '$line'\" >>.MM_tmp\n");
d924 1
a924 1
    push(@@m,"\t$self->{NOECHO}\$(PERL) -e \"print '$line'\" >>.MM_tmp\n") if $line;
d928 2
a929 2
	$self->{NOECHO}Delete/NoLog/NoConfirm .MM_tmp;
	$self->{NOECHO}\$(TOUCH) pm_to_blib.ts
d1008 2
a1009 2
Test xsubpp exit status according to VMS rules ($sts & 1 ==> good)
rather than Unix rules ($sts == 0 ==> good).
d1026 4
a1029 1
    warn "Running '$command' exits with status " . $? unless ($? & 1);
d1056 4
a1059 1
    warn "Running '$command' exits with status " . $? unless ($? & 1);
d1100 1
d1103 1
d1109 2
a1110 2
DOC_INSTALL = \$(PERL) -e "\@@ARGV=split('|',<STDIN>);print '=head3 ',scalar(localtime),': C<',shift,qq[>\\n\\n=over 4\\n\\n];while(\$key=shift && \$val=shift){print qq[=item *\\n\\nC<\$key: \$val>\\n\\n];}print qq[=back\\n\\n]"
UNINSTALL = \$(PERL) "-I\$(PERL_LIB)" "-MExtUtils::Install" -e "uninstall(\$ARGV[0],1);"
d1124 1
d1131 4
d1203 1
a1203 1
	$(NOOP)
d1206 1
a1206 1
	$(NOOP)
d1209 1
a1209 1
	$(NOOP)
d1212 1
a1212 1
	$(NOOP)
d1215 1
a1215 1
	$(NOOP)
d1218 1
a1218 1
	$(NOOP)
d1223 1
a1223 1
	$(NOOP)
d1232 1
a1232 1
	$(NOOP)
d1239 1
a1239 1
	$(NOOP)
d1255 1
a1255 1
	},$self->{NOECHO},q{$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -
d1283 1
a1283 1
	$(NOOP)
d1288 1
a1288 1
	   push(@@m,"# Depend on $(BASEEXT).opt to insure we copy here *after* autogenerating (wrong) rtls.opt in Mksymlists
d1305 1
a1305 1
	$(NOOP)
d1319 13
d1333 1
d1359 2
a1360 1
	',$self->{NOECHO},'$(MKPATH) $(INST_ARCHAUTODIR)
d1386 2
a1387 2
	'.$self->{NOECHO}.'Write Sys$Output "Running mkbootstrap for $(NAME) ($(BSLOADLIBS))"
	'.$self->{NOECHO}.'$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -
d1389 1
a1389 1
	'.$self->{NOECHO}.' $(TOUCH) $(MMS$TARGET)
d1392 1
a1392 1
	'.$self->{NOECHO}.'$(RM_RF) $(INST_BOOT)
d1409 1
a1409 1
	$(NOOP)
d1426 1
a1426 1
	',$self->{NOECHO},'$(PERL) -e "open F,\'>>$(INST_ARCHAUTODIR)extralibs.ld\';print F qq[$(EXTRALIBS)\n];close F;"
d1446 2
a1447 2
# ",'	',$self->{NOECHO},'$(RM_F) $(MMS$TARGET)
# 	',$self->{NOECHO},'$(CP) ',"$dist $inst",'
d1468 1
a1468 1
    return "\nmanifypods :\n\t\$(NOOP)\n" unless %{$self->{MAN3PODS}} or %{$self->{MAN1PODS}};
d1476 1
a1476 2
    if ($pod2man_exe = $self->perl_script($pod2man_exe)) { $found_pod2man = 1; }
    else {
d1493 1
a1493 3
    push @@m, "\nmanifypods : ";
    push @@m, join " ", keys %{$self->{MAN1PODS}}, keys %{$self->{MAN3PODS}};
    push(@@m,"\n");
d1519 2
d1522 2
a1523 2
all :: $self->{PL_FILES}->{$plfile}
	\$(NOOP)
d1525 2
a1526 2
$self->{PL_FILES}->{$plfile} :: $plfile
",'	$(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" '," $plfile
d1545 2
a1546 1
    for $from (@@{$self->{EXE_FILES}}) {
d1551 1
a1551 1
	$fromto{$from}=$to;
d1553 1
a1553 1
    @@to   = values %fromto;
d1555 1
a1555 1
EXE_FILES = @@{$self->{EXE_FILES}}
d1558 1
a1558 1
	\$(NOOP)
d1602 1
a1602 1
	- $(MMS) all $(USEMACROS)$(PASTHRU)$(MACROEND)
d1626 2
a1627 2
	push( @@m, '	If F$Search("'.$vmsdir.'$(MAKEFILE)") Then \\',"\n\t",
	      '$(PERL) -e "chdir ',"'$vmsdir'",'; print `$(MMS) clean`;"',"\n");
d1629 1
a1629 1
    push @@m, '	$(RM_F) *.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *$(OBJ_EXT) *$(LIB_EXT) *.Opt $(BOOTSTRAP) $(BASEEXT).bso
d1633 13
a1645 1
    push(@@otherfiles, $attribs{FILES}) if $attribs{FILES};
d1658 1
a1658 1
    push @@m, "\t\$(RM_RF) $line\n" if line;
d1679 1
a1679 1
	      '$(PERL) -e "chdir ',"'$vmsdir'",'; print `$(MMS) realclean`;"',"\n");
d1704 10
a1713 1
    if ($attribs{FILES} && ref $attribs{FILES} eq 'ARRAY') {
d1715 1
a1715 1
	foreach $file (@@{$attribs{'FILES'}}) {
d1739 1
a1739 1
	$(NOOP)
d1745 1
a1745 1
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e "use ExtUtils::Manifest \'&fullcheck\'; skipcheck()"
d1763 1
a1763 1
	].$self->{NOECHO}.q[$(PERL) -le "print 'Warning: $m older than $vf' if -e ($vf = '$(VERSION_FROM)') && -M $vf < -M ($m = '$(MAKEFILE)'"
d1766 1
a1766 1
	$(NOOP)
d1770 1
a1770 1
	$(ZIP) "$(ZIPFLAGS)" $(MMS$TARGET) $(SRC)
d1777 1
a1777 1
	$(TAR) "$(TARFLAGS)" $(DISTVNAME).tar $(SRC)
d1784 1
a1784 1
	$(SHARE) $(SRC) $(DISTVNAME).share
d1820 2
a1821 2
	$(MMS)
	$(MMS) test
d1844 1
a1844 1
		push(@@docfiles,qq[\t\$(PERL) -e "print $line" >>.MM_tmp\n]);
d1848 1
a1848 1
	push(@@docfiles,qq[\t\$(PERL) -e "print $line" >>.MM_tmp\n]) if $line;
d1853 1
a1853 1
	$(NOOP)
d1856 1
a1856 1
	$(NOOP)
d1859 1
a1859 1
	$(NOOP)
d1862 1
a1862 1
	],$self->{NOECHO},q[Write Sys$Output "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1865 1
a1865 1
	$(NOOP)
d1868 1
a1868 1
	],$self->{NOECHO},q[Write Sys$Output "Appending installation info to $(INST_ARCHLIB)perllocal.pod"
d1871 1
a1871 1
	],$self->{NOECHO},q[Write Sys$Output "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1874 1
a1874 1
	],$self->{NOECHO},q[Write Sys$Output "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1878 8
a1885 8
	].$self->{NOECHO}.q[$(PERL) -e "print 'read ].$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q[ '" >.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print 'write ].$self->catfile('$(INSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q[ '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_LIB) $(INSTALLPRIVLIB) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_ARCHLIB) $(INSTALLARCHLIB) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_BIN) $(INSTALLBIN) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_SCRIPT) $(INSTALLSCRIPT) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLMAN1DIR) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLMAN3DIR) '" >>.MM_tmp
d1887 2
a1888 2
	].$self->{NOECHO}.q[Delete/NoLog/NoConfirm .MM_tmp;
	].$self->{NOECHO}.q[$(WARN_IF_OLD_PACKLIST) ].$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q[
d1892 8
a1899 8
	].$self->{NOECHO}.q[$(PERL) -e "print 'read ].$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q[ '" >.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print 'write ].$self->catfile('$(INSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q[ '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_LIB) $(INSTALLSITELIB) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_ARCHLIB) $(INSTALLSITEARCH) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_BIN) $(INSTALLBIN) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_SCRIPT) $(INSTALLSCRIPT) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLMAN1DIR) '" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLMAN3DIR) '" >>.MM_tmp
d1901 2
a1902 2
	].$self->{NOECHO}.q[Delete/NoLog/NoConfirm .MM_tmp;
	].$self->{NOECHO}.q[$(WARN_IF_OLD_PACKLIST) ].$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q[
d1906 9
a1914 5
	].$self->{NOECHO}.q[$(PERL) -e "print 'Module $(NAME)|installed into|$(INSTALLPRIVLIB)|'" >.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print 'LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|'" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print 'LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|'" >>.MM_tmp
],@@docfiles,q[	$(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q[
	].$self->{NOECHO}.q[Delete/NoLog/NoConfirm .MM_tmp;
d1918 9
a1926 5
	].$self->{NOECHO}.q[$(PERL) -e "print 'Module $(NAME)|installed into|$(INSTALLSITELIB)|'" >.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print 'LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|'" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print 'LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|'" >>.MM_tmp
],@@docfiles,q[	$(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q[
	].$self->{NOECHO}.q[Delete/NoLog/NoConfirm .MM_tmp;
d1932 1
a1932 1
	$(NOOP)
d1935 4
a1938 1
	].$self->{NOECHO}.q[$(UNINSTALL) ].$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q[
d1941 5
a1945 1
	].$self->{NOECHO}.q[$(UNINSTALL) ].$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist')."\n";
d1990 1
a1990 1
	],$self->{NOECHO},q[Write Sys$Error "Warning: $(PERL_INC)config.h out of date with $(PERL_VMS)config.vms"
d1994 1
a1994 1
	],$self->{NOECHO},q[Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.vms or genconfig.pl"
d1997 8
a2004 1
	$(MMS)],$mmsquals,q[ $(MMS$TARGET)
d2035 2
a2036 2
	],$self->{NOECHO},q[Write Sys$Output "$(MAKEFILE) out-of-date with respect to $(MMS$SOURCE_LIST)"
	],$self->{NOECHO},q[Write Sys$Output "Cleaning current config before rebuilding $(MAKEFILE) ..."
d2038 1
a2038 1
	- $(MMS) $(USEMAKEFILE)$(MAKEFILE)_old clean
d2040 2
a2041 2
	],$self->{NOECHO},q[Write Sys$Output "$(MAKEFILE) has been rebuilt."
	],$self->{NOECHO},q[Write Sys$Output "Please run $(MMS) to build the extension."
d2064 1
a2064 1
	\$(NOOP)
d2067 1
a2067 1
	\$(NOOP)
d2073 1
a2073 1
           '; print `$(MMS) $(PASTHRU2) test`'."\n");
d2075 1
a2075 1
    push(@@m, "\t$self->{NOECHO}Write Sys\$Output \"No tests defined for \$(NAME) extension.\"\n")
d2082 1
a2082 1
    push(@@m, "    \$(NOOP)\n") if (!$tests && ! -f "test.pl");
d2102 2
a2103 2
	push @@m, "test_static :: test_dynamic\n\t$self->{NOECHO}\$(NOOP)\n\n";
	push @@m, "testdb_static :: testdb_dynamic\n\t$self->{NOECHO}\$(NOOP)\n";
d2158 2
a2159 2
	},$self->{NOECHO},q{Write Sys$Output "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
	},$self->{NOECHO},q{$(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" \
d2165 1
a2165 1
	$(MMS)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
d2174 1
a2174 1
    my($linkcmd,@@staticopts,@@staticpkgs,$extralist,$target,$targdir,$libperldir);
d2260 1
a2260 1
    $target = "Perl.Exe" unless $target;
d2310 4
a2313 4
	',$self->{NOECHO},'Write Sys$Output "To install the new ""$(MAP_TARGET)"" binary, say"
	',$self->{NOECHO},'Write Sys$Output "    $(MMS)$(USEMAKEFILE)$(MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
	',$self->{NOECHO},'Write Sys$Output "To remove the intermediate files, say
	',$self->{NOECHO},'Write Sys$Output "    $(MMS)$(USEMAKEFILE)$(MAKEFILE) map_clean"
d2317 1
a2317 1
	',$self->{NOECHO},'$(PERL) $(MAP_PERLINC) -e "use ExtUtils::Miniperl; writemain(qw|',@@staticpkgs,'|)" >$(MMS$TARGET)
d2323 4
a2326 4
	].$self->{NOECHO}.q[$(PERL) -e "print 'Perl binary $(MAP_TARGET)|'" >.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print 'MAP_STATIC|$(MAP_STATIC)|'" >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
	].$self->{NOECHO}.q[$(PERL) -e "print 'MAP_LIBPERL|$(MAP_LIBPERL)|'" >>.MM_tmp
d2328 1
a2328 1
	].$self->{NOECHO}.q[Delete/NoLog/NoConfirm .MM_tmp;
d2333 1
a2333 1
	\$(NOOP)
d2340 1
a2340 1
	\$(NOOP)
a2349 12
=item ext (specific)

Stub routine standing in for C<ExtUtils::LibList::ext> until VMS
support is added to that package.

=cut

sub ext {
    my($self) = @@_;
    '','','';
}

d2368 4
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d6 1
a6 1
#   Author:  Charles Bailey  bailey@@newman.upenn.edu
d9 2
a11 1
use Carp qw( &carp );
a16 5
use vars qw($Revision);
$Revision = '5.52 (12-Sep-1998)';

unshift @@MM::ISA, 'ExtUtils::MM_VMS';

a34 2
=over

a49 1
    my($complex) = 0;
d56 1
a56 13
            if (ref $self->{$macro}) {
                if (ref $self->{$macro} eq 'ARRAY') {
                    print "Note: expanded array macro \$($macro) in $path\n" if $Verbose;
                    $macro = join ' ', @@{$self->{$macro}};
                }
                else {
                    print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                          "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                    $macro = "\cB$macro\cB";
                    $complex = 1;
                }
            }
            else { ($macro = unixify($self->{$macro})) =~ s#/$##; }
a59 1
    if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#g; }
d73 2
a74 4
a VMS-syntax directory specification, if it is FALSE, the return string
is a VMS-syntax file specification, and if it is not specified, fixpath()
checks to see whether it matches the name of a directory in the current
default directory, and returns a directory or file specification accordingly.
d86 1
a86 1
    if ($path =~ m#^\$\([^\)]+\)$# || $path =~ m#[/:>\]]#) { 
d95 1
a95 3
        my($vmspre) = $self->eliminate_macros("\$($prefix)");
        # is it a dir or just a name?
        $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR$/) ? vmspath($vmspre) : '';
d103 2
a104 6
    # No hints, so we try to guess
    if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
        $fixedpath = vmspath($fixedpath) if -d $fixedpath;
    }
    # Trim off root dirname if it's had other dirs inserted in front of it.
    $fixedpath =~ s/\.000000([\]>])/$1/;
d126 1
a126 5
      $rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
    }
    else { 
      if ($dir =~ /^\$\([^\)]+\)$/) { $rslt = $dir; }
      else                          { $rslt = vmspath($dir); }
d128 1
a159 24
=item wraplist

Converts a list into a string wrapped at approximately 80 columns.

=cut

sub wraplist {
    my($self) = shift;
    my($line,$hlen) = ('',0);
    my($word);

    foreach $word (@@_) {
      # Perl bug -- seems to occasionally insert extra elements when
      # traversing array (scalar(@@array) doesn't show them, but
      # foreach(@@array) does) (5.00307)
      next unless $word =~ /\w/;
      $line .= ' ' if length($line);
      if ($hlen > 80) { $line .= "\\\n\t"; $hlen = 0; }
      $line .= $word;
      $hlen += length($word) + 2;
    }
    $line;
}

a191 1
sub ExtUtils::MM_VMS::ext;
d202 1
a265 11

# This isn't really an override.  It's just here because ExtUtils::MM_VMS
# appears in @@MM::ISA before ExtUtils::Liblist, so if there isn't an ext()
# in MM_VMS, then AUTOLOAD is called, and bad things happen.  So, we just
# mimic inheritance here and hand off to ExtUtils::Liblist.
sub ext {
  ExtUtils::Liblist::ext(@@_);
}

=back

a273 2
=over

d287 1
a287 1
    my($defname,$defpm,@@pm,%xs,$pm);
a292 12
    # Fallback in case for some reason a user has copied the files for an
    # extension into a working directory whose name doesn't reflect the
    # extension's name.  We'll use the name of a unique .pm file, or the
    # first .pm file with a matching .xs file.
    if (not -e "${defpm}.pm") {
      @@pm = map { s/.pm$//; $_ } glob('*.pm');
      if (@@pm == 1) { ($defpm = $pm[0]) =~ s/.pm$//; }
      elsif (@@pm) {
        %xs = map { s/.xs$//; ($_,1) } glob('*.xs');
        if (%xs) { foreach $pm (@@pm) { $defpm = $pm, last if exists $xs{$pm}; } }
      }
    }
d320 1
a320 1
sub find_perl {
a322 1
    my($inabs) = 0;
d325 2
a326 2
    @@sdirs = sort { my($absa) = $self->file_name_is_absolute($a);
                    my($absb) = $self->file_name_is_absolute($b);
d335 3
a337 10
                     my($ahasdir) = (length($a) - length($ba) > 0);
                     my($bhasdir) = (length($b) - length($bb) > 0);
                     if    ($ahasdir and not $bhasdir) { return 1; }
                     elsif ($bhasdir and not $ahasdir) { return -1; }
                     else { $bb =~ /\d/ <=> $ba =~ /\d/
                            or substr($ba,0,1) cmp substr($bb,0,1)
                            or length($bb) <=> length($ba) } } @@$names;
    # Image names containing Perl version use '_' instead of '.' under VMS
    foreach $name (@@snames) { $name =~ s/\.(\d+)$/_$1/; }
    if ($trace >= 2){
a344 8
	$inabs++ if $self->file_name_is_absolute($dir);
	if ($inabs == 1) {
	    # We've covered relative dirs; everything else is an absolute
	    # dir (probably an installed location).  First, we'll try potential
	    # command names, to see whether we can avoid a long MCR expression.
	    foreach $name (@@snames) { push(@@cand,$name) if $name =~ /^[\w\-\$]+$/; }
	    $inabs++; # Should happen above in next $dir, but just in case . . .
	}
d347 1
a347 1
	    else                     { push(@@cand,$self->fixpath($name,0));    }
a351 6
	# If it looks like a potential command, try it without the MCR
	if ($name =~ /^[\w\-\$]+$/ &&
	    `$name -e "require $ver; print ""VER_OK\n"""` =~ /VER_OK/) {
	    print "Using PERL=$name\n" if $trace;
	    return $name;
	}
d357 1
a357 1
	    return "MCR $vmsfile";
d381 4
a384 4
appends F<.Exe> (or equivalent) to check for executable image, and F<.Com>
to check for DCL procedure.  If this fails, checks directories in DCL$PATH
and finally F<Sys$System:> for an executable file having the name specified,
with or without the F<.Exe>-equivalent suffix.
d391 2
a392 3
    my(@@dirs) = ('');
    my(@@exts) = ('',$Config{'exe_ext'},'.exe','.com');
    my($dir,$ext);
d394 3
a396 12
	for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
	    $dir = $ENV{"DCL\$PATH;$i"};
	    $dir .= ':' unless $dir =~ m%[\]:]$%;
	    push(@@dirs,$dir);
	}
	push(@@dirs,'Sys$System:');
	foreach $dir (@@dirs) {
	    my $sysfile = "$dir$file";
	    foreach $ext (@@exts) {
		return $file if -x "$sysfile$ext" && ! -d _;
	    }
	}
d427 1
a427 1
		    print "Using $abs\n" if $trace;
d439 2
a440 2
If name passed in doesn't specify a readable file, appends F<.com> or
F<.pl> and tries again, since it's customary to have file types on all files
d448 1
a448 2
    return "$file.com" if -r "$file.com";
    return "$file.pl" if -r "$file.pl";
d459 2
a460 4
    my($self,$file) = @@_;
    # If it's a logical name, expand it.
    $file = $ENV{$file} while $file =~ /^[\w\$\-]+$/ and $ENV{$file};
    $file =~ m!^/! or $file =~ m![<\[][^.\-\]>]! or $file =~ /:[^<\[]/;
d486 1
a486 1
    $self->{NOOP} = 'Continue';
d497 1
a497 1
    $self->{UMASK_NULL} = '! ';  
d517 2
a518 8
	    if ($def =~ s/^-D//) {       # If it was a Unix-style definition
		$def =~ s/='(.*)'$/=$1/;  # then remove shell-protection ''
		$def =~ s/^'(.*)'$/$1/;   # from entire term or argument
	    }
	    if ($def =~ /=/) {
		$def =~ s/"/""/g;  # Protect existing " from DCL
		$def = qq["$def"]; # and quote to prevent parsing of =
	    }
d525 1
a525 1
	$self->{OBJECT} = $self->wraplist(map($self->fixpath($_,0),split(/,?\s+/,$self->{OBJECT})));
d527 1
a527 1
    $self->{LDFROM} = $self->wraplist(map($self->fixpath($_,0),split(/,?\s+/,$self->{LDFROM})));
d529 11
d561 1
a561 1
	$self->{$macro} = $self->fixpath($self->{$macro},0);
d596 2
a597 8
	      FULLEXT VERSION_FROM OBJECT LDFROM
	      /	) {
	next unless defined $self->{$tmp};
	push @@m, "$tmp = ",$self->fixpath($self->{$tmp},0),"\n";
    }

    for $tmp (qw/
	      BASEEXT PARENT_NAME DLBASE INC DEFINE LINKTYPE
d607 1
a607 1
	    $tmp{$self->fixpath($key,0)} = $self->fixpath($self->{$tmp}{$key},0);
d616 1
a616 1
	    push(@@tmp,$self->fixpath($val,0));
d624 6
a629 6
XS_FILES = ',$self->wraplist(sort keys %{$self->{XS}}),'
C_FILES  = ',$self->wraplist(@@{$self->{C}}),'
O_FILES  = ',$self->wraplist(@@{$self->{O_FILES}} ),'
H_FILES  = ',$self->wraplist(@@{$self->{H}}),'
MAN1PODS = ',$self->wraplist(sort keys %{$self->{MAN1PODS}}),'
MAN3PODS = ',$self->wraplist(sort keys %{$self->{MAN3PODS}}),'
a640 1
.SUFFIXES :
d647 2
a648 2
INST_LIBDIR      = $self->{INST_LIBDIR}
INST_ARCHLIBDIR  = $self->{INST_ARCHLIBDIR}
d650 3
a652 3
INST_AUTODIR     = $self->{INST_AUTODIR}
INST_ARCHAUTODIR = $self->{INST_ARCHAUTODIR}
";
a660 1
	my $shr = $Config{'dbgprefix'} . 'PERLSHR';
d666 1
a666 1
PERL_ARCHIVE = ',($ENV{$shr} ? $ENV{$shr} : "Sys\$Share:$shr.$Config{'dlext'}"),'
d673 1
a673 1
TO_INST_PM = ',$self->wraplist(@@{$self->{TO_INST_PM}}),'
d675 1
a675 1
PM_TO_BLIB = ',$self->wraplist(@@{$self->{PM_TO_BLIB}}),'
d681 51
d736 3
a738 2
/Defines into one, since some C compilers pay attention to only one
instance of this qualifier on the command line.
d744 1
a744 3
    my($quals) = $self->{CCFLAGS} || $Config{'ccflags'};
    my($definestr,$undefstr,$flagoptstr) = ('','','');
    my($incstr) = '/Include=($(PERL_INC)';
d746 1
a752 22
    if ($quals =~ / -[DIUOg]/) {
	while ($quals =~ / -([Og])(\d*)\b/) {
	    my($type,$lvl) = ($1,$2);
	    $quals =~ s/ -$type$lvl\b\s*//;
	    if ($type eq 'g') { $flagoptstr = '/NoOptimize'; }
	    else { $flagoptstr = '/Optimize' . (defined($lvl) ? "=$lvl" : ''); }
	}
	while ($quals =~ / -([DIU])(\S+)/) {
	    my($type,$def) = ($1,$2);
	    $quals =~ s/ -$type$def\s*//;
	    $def =~ s/"/""/g;
	    if    ($type eq 'D') { $definestr .= qq["$def",]; }
	    elsif ($type eq 'I') { $incstr .= ',' . $self->fixpath($def,1); }
	    else                 { $undefstr  .= qq["$def",]; }
	}
    }
    if (length $quals and $quals !~ m!/!) {
	warn "MM_VMS: Ignoring unrecognized CCFLAGS elements \"$quals\"\n";
	$quals = '';
    }
    if (length $definestr) { chop($definestr); $quals .= "/Define=($definestr)"; }
    if (length $undefstr)  { chop($undefstr);  $quals .= "/Undef=($undefstr)";   }
d755 1
a755 1
    # conflate the ones from $Config{'ccflags'} and $self->{DEFINE}
d766 7
a772 11
# This whole section is commented out, since I don't think it's necessary (or applicable)
#    if ($libperl =~ s/^$Config{'dbgprefix'}//) { $libperl =~ s/perl([^Dd]*)\./perld$1./; }
#    if ($libperl =~ /libperl(\w+)\./i) {
#	my($type) = uc $1;
#	my(%map) = ( 'D'  => 'DEBUGGING', 'E' => 'EMBED', 'M' => 'MULTIPLICITY',
#	             'DE' => 'DEBUGGING,EMBED', 'DM' => 'DEBUGGING,MULTIPLICITY',
#	             'EM' => 'EMBED,MULTIPLICITY', 'DEM' => 'DEBUGGING,EMBED,MULTIPLICITY' );
#	my($add) = join(',', grep { $quals !~ /\b$_\b/ } split(/,/,$map{$type}));
#	$quals =~ s:/define=\(([^\)]+)\):/Define=($1,$add):i if $add;
#	$self->{PERLTYPE} ||= $type;
#    }
d775 1
d780 1
a780 1
	    $incstr .= ','.$self->fixpath($_,1);
d783 4
a786 2
    $quals .= "$incstr)";
    $self->{CCFLAGS} = $quals;
d788 2
a789 11
    $self->{OPTIMIZE} ||= $flagoptstr || $Config{'optimize'};
    if ($self->{OPTIMIZE} !~ m!/!) {
	if    ($self->{OPTIMIZE} =~ m!\b-g\b!) { $self->{OPTIMIZE} = '/Debug/NoOptimize' }
	elsif ($self->{OPTIMIZE} =~ /-O(\d*)/) {
	    $self->{OPTIMIZE} = '/Optimize' . (defined($1) ? "=$1" : '');
	}
	else {
	    warn "MM_VMS: Can't parse OPTIMIZE \"$self->{OPTIMIZE}\"; using default\n" if length $self->{OPTIMIZE};
	    $self->{OPTIMIZE} = '/Optimize';
	}
    }
d792 3
a794 3
CCFLAGS = $self->{CCFLAGS}
OPTIMIZE = $self->{OPTIMIZE}
PERLTYPE = $self->{PERLTYPE}
d803 1
a803 1
handling #include E<lt>sys/foo.hE<gt> directives.  Also constructs CC
a853 6

# Dummy target to match Unix target name; we use pm_to_blib.ts as
# timestamp file to avoid repeated invocations under VMS
pm_to_blib : pm_to_blib.ts
	$(NOECHO) $(NOOP)

d855 2
a856 2
pm_to_blib.ts : $(TO_INST_PM)
	$(NOECHO) $(PERL) -e "print '},shift(@@files),q{ },shift(@@files),q{'" >.MM_tmp
d863 1
a863 1
	    push(@@m,"\t\$(NOECHO) \$(PERL) -e \"print '$line'\" >>.MM_tmp\n");
d867 1
a867 1
    push(@@m,"\t\$(NOECHO) \$(PERL) -e \"print '$line'\" >>.MM_tmp\n") if $line;
d871 2
a872 2
	\$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
	\$(NOECHO) \$(TOUCH) pm_to_blib.ts
d914 1
a914 1
			push(@@tmdeps, $self->fixpath($typemap,0));
d951 2
a952 2
Test xsubpp exit status according to VMS rules ($sts & 1 ==E<gt> good)
rather than Unix rules ($sts == 0 ==E<gt> good).
d969 1
a969 4
    if ($?) {
	use vmsish 'status';
	warn "Running '$command' exits with status $?";
    }
d996 1
a996 4
    if ($?) {
	use vmsish 'status';
	warn "Running '$command' exits with status $?";
    }
a1036 1
SAY = Write Sys\$Output
a1038 1
NOECHO = $self->{NOECHO}
d1044 2
a1045 2
DOC_INSTALL = \$(PERL) -e "\@@ARGV=split(/\\|/,<STDIN>);print '=head2 ',scalar(localtime),': C<',shift,qq[>\\n\\n=over 4\\n\\n];while(\$key=shift && \$val=shift){print qq[=item *\\n\\nC<\$key: \$val>\\n\\n];}print qq[=back\\n\\n]"
UNINSTALL = \$(PERL) "-I\$(PERL_LIB)" "-MExtUtils::Install" -e "uninstall(\$ARGV[0],1,1);"
a1058 1
    $attribs{NAME}         ||= $self->{DISTNAME};
a1064 4
    # Sanitize these for use in $(DISTVNAME) filespec
    $attribs{VERSION} =~ s/[^\w\$]/_/g;
    $attribs{NAME} =~ s/[^\w\$]/_/g;

d1133 1
a1133 1
	$(NOECHO) $(NOOP)
d1136 1
a1136 1
	$(NOECHO) $(NOOP)
d1139 1
a1139 1
	$(NOECHO) $(NOOP)
d1142 1
a1142 1
	$(NOECHO) $(NOOP)
d1145 1
a1145 1
	$(NOECHO) $(NOOP)
d1148 1
a1148 1
	$(NOECHO) $(NOOP)
d1153 1
a1153 1
	$(NOECHO) $(NOOP)
d1162 1
a1162 1
	$(NOECHO) $(NOOP)
d1169 1
a1169 1
	$(NOECHO) $(NOOP)
d1185 1
a1185 1
	$(NOECHO) $(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -
d1207 1
a1207 1
    my($funclist)  = $attribs{FUNCLIST}  || $self->{FUNCLIST}  || [];
d1212 17
a1228 2
dynamic :: $(INST_ARCHAUTODIR)$(BASEEXT).opt
	$(NOECHO) $(NOOP)
d1230 1
d1235 1
a1235 1
	$(NOECHO) $(NOOP)
d1245 1
a1245 2
	neatvalue($funcs),q[, 'DL_VARS' => ],neatvalue($vars),
	q[, 'FUNCLIST' => ],neatvalue($funclist),')"
a1248 13
    if (length $self->{LDLOADLIBS}) {
	my($lib); my($line) = '';
	foreach $lib (split ' ', $self->{LDLOADLIBS}) {
	    $lib =~ s%\$%\\\$%g;  # Escape '$' in VMS filespecs
	    if (length($line) + length($lib) > 160) {
		push @@m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";
		$line = $lib . '\n';
	    }
	    else { $line .= $lib . '\n'; }
	}
	push @@m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if $line;
    }

a1249 1

a1265 1
    my $shr = $Config{'dbgprefix'} . 'PerlShr';
d1274 3
a1276 4
$(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt $(INST_ARCHAUTODIR).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
	$(NOECHO) $(MKPATH) $(INST_ARCHAUTODIR)
	If F$TrnLNm("',$shr,'").eqs."" Then Define/NoLog/User ',"$shr Sys\$Share:$shr.$Config{'dlext'}",'
	Link $(LDFLAGS) /Shareable=$(MMS$TARGET)$(OTHERLDFLAGS) $(BASEEXT).opt/Option,$(PERL_INC)perlshr_attr.opt/Option
d1301 2
a1302 2
	$(NOECHO) $(SAY) "Running mkbootstrap for $(NAME) ($(BSLOADLIBS))"
	$(NOECHO) $(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -
d1304 1
a1304 1
	$(NOECHO) $(TOUCH) $(MMS$TARGET)
d1307 1
a1307 1
	$(NOECHO) $(RM_RF) $(INST_BOOT)
d1324 1
a1324 1
	$(NOECHO) $(NOOP)
d1327 1
a1327 1
    my(@@m,$lib);
d1336 1
a1336 1
    push(@@m, "\t",'$(CP) $(MYEXTLIB) $(MMS$TARGET)',"\n") if $self->{MYEXTLIB};
d1338 5
a1342 15
    push(@@m,"\t",'If F$Search("$(MMS$TARGET)").eqs."" Then Library/Object/Create $(MMS$TARGET)',"\n");

    # if there was a library to copy, then we can't use MMS$SOURCE_LIST,
    # 'cause it's a library and you can't stick them in other libraries.
    # In that case, we use $OBJECT instead and hope for the best
    if ($self->{MYEXTLIB}) {
      push(@@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(OBJECT)',"\n"); 
    } else {
      push(@@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(MMS$SOURCE_LIST)',"\n");
    }
    
    foreach $lib (split $self->{EXTRALIBS}) {
      $lib = '""' if $lib eq '"';
      push(@@m,"\t",'$(NOECHO) $(PERL) -e "print qq{',$lib,'\n}" >>$(INST_ARCHAUTODIR)extralibs.ld',"\n");
    }
d1348 25
d1383 1
a1383 1
    return "\nmanifypods :\n\t\$(NOECHO) \$(NOOP)\n" unless %{$self->{MAN3PODS}} or %{$self->{MAN1PODS}};
d1391 2
a1392 1
    if (not ($pod2man_exe = $self->perl_script($pod2man_exe))) {
d1409 3
a1411 1
    push @@m, "\nmanifypods : \$(MAN1PODS) \$(MAN3PODS)\n";
d1437 3
a1439 9
        my $list = ref($self->{PL_FILES}->{$plfile})
		? $self->{PL_FILES}->{$plfile}
		: [$self->{PL_FILES}->{$plfile}];
	foreach $target (@@$list) {
	    my $vmsplfile = vmsify($plfile);
	    my $vmsfile = vmsify($target);
	    push @@m, "
all :: $vmsfile
	\$(NOECHO) \$(NOOP)
d1441 2
a1442 2
$vmsfile :: $vmsplfile
",'	$(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" '," $vmsplfile $vmsfile
a1443 1
	}
d1461 1
a1461 2
    my(@@exefiles) = map { vmsify($_) } @@{$self->{EXE_FILES}};
    for $from (@@exefiles) {
d1466 1
a1466 1
	$fromto{$from} = vmsify($to);
d1468 1
a1468 1
    @@to = values %fromto;
d1470 1
a1470 1
EXE_FILES = @@exefiles
d1473 1
a1473 1
	\$(NOECHO) \$(NOOP)
d1517 1
a1517 1
	- $(MMS)$(MMSQUALIFIERS) all $(USEMACROS)$(PASTHRU)$(MACROEND)
d1541 2
a1542 2
	push( @@m, '	If F$Search("'.$vmsdir.'$(MAKEFILE)").nes."" Then \\',"\n\t",
	      '$(PERL) -e "chdir ',"'$vmsdir'",'; print `$(MMS)$(MMSQUALIFIERS) clean`;"',"\n");
d1544 1
a1544 1
    push @@m, '	$(RM_F) *.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *$(OBJ_EXT) *$(LIB_EXT) *.Opt $(BOOTSTRAP) $(BASEEXT).bso .MM_Tmp
d1548 1
a1548 13
    # Unlink realclean, $attribs{FILES} is a string here; it may contain
    # a list or a macro that expands to a list.
    if ($attribs{FILES}) {
	my($word,$key,@@filist);
	if (ref $attribs{FILES} eq 'ARRAY') { @@filist = @@{$attribs{FILES}}; }
	else { @@filist = split /\s+/, $attribs{FILES}; }
	foreach $word (@@filist) {
	    if (($key) = $word =~ m#^\$\((.*)\)$# and ref $self->{$key} eq 'ARRAY') {
		push(@@otherfiles, @@{$self->{$key}});
	    }
	    else { push(@@otherfiles, $word); }
	}
    }
a1552 3
    # Occasionally files are repeated several times from different sources
    { my(%of) = map { ($_,1) } @@otherfiles; @@otherfiles = keys %of; }
    
d1561 1
a1561 1
    push @@m, "\t\$(RM_RF) $line\n" if $line;
d1582 1
a1582 1
	      '$(PERL) -e "chdir ',"'$vmsdir'",'; print `$(MMS)$(MMSQUALIFIERS) realclean`;"',"\n");
a1596 2
    # Occasionally files are repeated several times from different sources
    { my(%f) = map { ($_,1) } @@files; @@files = keys %f; }
d1607 1
a1607 10
    if ($attribs{FILES}) {
	my($word,$key,@@filist,@@allfiles);
	if (ref $attribs{FILES} eq 'ARRAY') { @@filist = @@{$attribs{FILES}}; }
	else { @@filist = split /\s+/, $attribs{FILES}; }
	foreach $word (@@filist) {
	    if (($key) = $word =~ m#^\$\((.*)\)$# and ref $self->{$key} eq 'ARRAY') {
		push(@@allfiles, @@{$self->{$key}});
	    }
	    else { push(@@allfiles, $word); }
	}
d1609 1
a1609 3
	# Occasionally files are repeated several times from different sources
	{ my(%af) = map { ($_,1) } @@allfiles; @@allfiles = keys %af; }
	foreach $file (@@allfiles) {
d1633 1
a1633 1
	$(NOECHO) $(NOOP)
d1639 1
a1639 1
	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -e "use ExtUtils::Manifest \'&skipcheck\'; skipcheck()"
d1657 1
a1657 1
	$(NOECHO) $(PERL) -le "print 'Warning: $m older than $vf' if -e ($vf = '$(VERSION_FROM)') && -M $vf < -M ($m = '$(MAKEFILE)')"
d1660 1
a1660 1
	$(NOECHO) $(NOOP)
d1664 1
a1664 1
	$(ZIP) "$(ZIPFLAGS)" $(MMS$TARGET) [.$(DISTVNAME)...]*.*;
d1671 1
a1671 1
	$(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)]
d1678 1
a1678 1
	$(SHAR) [.$(DISTVNAME...]*.*; $(DISTVNAME).share
d1714 2
a1715 2
	$(MMS)$(MMSQUALIFIERS)
	$(MMS)$(MMSQUALIFIERS) test
d1738 1
a1738 1
		push(@@docfiles,qq[\t\$(PERL) -e "print '$line'" >>.MM_tmp\n]);
d1742 1
a1742 1
	push(@@docfiles,qq[\t\$(PERL) -e "print '$line'" >>.MM_tmp\n]) if $line;
d1747 1
a1747 1
	$(NOECHO) $(NOOP)
d1750 1
a1750 1
	$(NOECHO) $(NOOP)
d1753 1
a1753 1
	$(NOECHO) $(NOOP)
d1756 1
a1756 1
	$(NOECHO) $(SAY) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1759 1
a1759 1
	$(NOECHO) $(NOOP)
d1762 1
a1762 1
	$(NOECHO) $(SAY) "Appending installation info to $(INSTALLARCHLIB)perllocal.pod"
d1765 1
a1765 1
	$(NOECHO) $(SAY) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1768 1
a1768 1
	$(NOECHO) $(SAY) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1772 8
a1779 8
	$(NOECHO) $(PERL) -e "print 'read ].$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q[ '" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'write ].$self->catfile('$(INSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').q[ '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_LIB) $(INSTALLPRIVLIB) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_ARCHLIB) $(INSTALLARCHLIB) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_BIN) $(INSTALLBIN) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_SCRIPT) $(INSTALLSCRIPT) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLMAN1DIR) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLMAN3DIR) '" >>.MM_tmp
d1781 2
a1782 2
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q[
d1786 8
a1793 8
	$(NOECHO) $(PERL) -e "print 'read ].$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').q[ '" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'write ].$self->catfile('$(INSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').q[ '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_LIB) $(INSTALLSITELIB) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_ARCHLIB) $(INSTALLSITEARCH) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_BIN) $(INSTALLBIN) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_SCRIPT) $(INSTALLSCRIPT) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLMAN1DIR) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLMAN3DIR) '" >>.MM_tmp
d1795 2
a1796 2
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q[
d1800 5
a1804 9
	$(NOECHO) $(PERL) -e "print 'Module $(NAME)|installed into|$(INSTALLPRIVLIB)|'" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES)|'" >>.MM_tmp
],@@docfiles,
q%	$(NOECHO) $(PERL) -e "print q[@@ARGV=split(/\\|/,<STDIN>);]" >.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[print '=head2 ',scalar(localtime),': C<',shift,qq[>\\n\\n=over 4\\n\\n];]" >>.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[while(($key=shift) && ($val=shift)) ]" >>.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[{print qq[=item *\\n\\nC<$key: $val>\\n\\n];}print qq[=back\\n\\n];]" >>.MM2_tmp
	$(NOECHO) $(PERL) .MM2_tmp <.MM_tmp >>%.$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q[
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;,.MM2_tmp;
d1808 5
a1812 9
	$(NOECHO) $(PERL) -e "print 'Module $(NAME)|installed into|$(INSTALLSITELIB)|'" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES)|'" >>.MM_tmp
],@@docfiles,
q%	$(NOECHO) $(PERL) -e "print q[@@ARGV=split(/\\|/,<STDIN>);]" >.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[print '=head2 ',scalar(localtime),': C<',shift,qq[>\\n\\n=over 4\\n\\n];]" >>.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[while(($key=shift) && ($val=shift)) ]" >>.MM2_tmp
	$(NOECHO) $(PERL) -e "print q[{print qq[=item *\\n\\nC<$key: $val>\\n\\n];}print qq[=back\\n\\n];]" >>.MM2_tmp
	$(NOECHO) $(PERL) .MM2_tmp <.MM_tmp >>%.$self->catfile('$(INSTALLARCHLIB)','perllocal.pod').q[
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;,.MM2_tmp;
d1818 1
a1818 1
	$(NOECHO) $(NOOP)
d1821 1
a1821 4
	$(NOECHO) $(UNINSTALL) ].$self->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').q[
	$(NOECHO) $(SAY) "Uninstall is now deprecated and makes no actual changes."
	$(NOECHO) $(SAY) "Please check the list above carefully for errors, and manually remove"
	$(NOECHO) $(SAY) "the appropriate files.  Sorry for the inconvenience."
d1824 1
a1824 5
	$(NOECHO) $(UNINSTALL) ],$self->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist'),"\n",q[
	$(NOECHO) $(SAY) "Uninstall is now deprecated and makes no actual changes."
	$(NOECHO) $(SAY) "Please check the list above carefully for errors, and manually remove"
	$(NOECHO) $(SAY) "the appropriate files.  Sorry for the inconvenience."
];
d1832 3
a1834 1
than to have the MM_Unix method call C<catfile> repeatedly.  Also, if
a1850 1
$(OBJECT) : $(PERL_INC)iperlsys.h
d1867 7
a1873 4
$(PERL_INC)config.h : $(PERL_SRC)config.sh

$(PERL_ARCHLIB)Config.pm : $(PERL_SRC)config.sh
	$(NOECHO) Write Sys$Error "$(PERL_ARCHLIB)Config.pm may be out of date with config.h or genconfig.pl"
d1876 1
a1876 8
	$(MMS)],$mmsquals,);
	if ($self->{PERL_ARCHLIB} =~ m|\[-| && $self->{PERL_SRC} =~ m|(\[-+)|) {
	    my($prefix,$target) = ($1,$self->fixpath('$(PERL_ARCHLIB)Config.pm',0));
	    $target =~ s/\Q$prefix/[/;
	    push(@@m," $target");
	}
	else { push(@@m,' $(MMS$TARGET)'); }
	push(@@m,q[
d1881 1
a1881 1
    push(@@m, join(" ", map($self->fixpath($_,0),values %{$self->{XS}}))." : \$(XSUBPPDEPS)\n")
d1907 2
a1908 2
	$(NOECHO) $(SAY) "$(MAKEFILE) out-of-date with respect to $(MMS$SOURCE_LIST)"
	$(NOECHO) $(SAY) "Cleaning current config before rebuilding $(MAKEFILE) ..."
d1910 1
a1910 1
	- $(MMS)$(MMSQUALIFIERS) $(USEMAKEFILE)$(MAKEFILE)_old clean
d1912 2
a1913 2
	$(NOECHO) $(SAY) "$(MAKEFILE) has been rebuilt."
	$(NOECHO) $(SAY) "Please run $(MMS) to build the extension."
d1936 1
a1936 1
	\$(NOECHO) \$(NOOP)
d1939 1
a1939 1
	\$(NOECHO) \$(NOOP)
d1945 1
a1945 1
           '; print `$(MMS)$(MMSQUALIFIERS) $(PASTHRU2) test`'."\n");
d1947 1
a1947 1
    push(@@m, "\t\$(NOECHO) \$(SAY) \"No tests defined for \$(NAME) extension.\"\n")
d1954 1
a1954 1
    push(@@m, "\t\$(NOECHO) \$(NOOP)\n") if (!$tests && ! -f "test.pl");
d1974 2
a1975 2
	push @@m, "test_static :: test_dynamic\n\t\$(NOECHO) \$(NOOP)\n\n";
	push @@m, "testdb_static :: testdb_dynamic\n\t\$(NOECHO) \$(NOOP)\n";
d2030 2
a2031 2
	$(NOECHO) $(SAY) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
	$(NOECHO) $(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" \
d2037 1
a2037 1
	$(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
d2046 1
a2046 2
    my($linkcmd,@@optlibs,@@staticpkgs,$extralist,$targdir,$libperldir,%libseen);
    local($_);
d2109 1
a2109 1
    for (sort { length($a) <=> length($b) } keys %olbs) {
a2114 2
	push @@optlibs, "$dir$olbs{$_}";
	# Get external libraries this extension will need
a2115 1
	    my %seenthis;
d2117 1
a2117 11
	    while (<LIST>) {
		chomp;
		# Include a library in the link only once, unless it's mentioned
		# multiple times within a single extension's options file, in which
		# case we assume the builder needed to search it again later in the
		# link.
		my $skip = exists($libseen{$_}) && !exists($seenthis{$_});
		$libseen{$_}++;  $seenthis{$_}++;
		next if $skip;
		push @@$extra,$_;
	    }
a2119 1
	# Get full name of extension for ExtUtils::Miniperl
d2124 2
a2125 2
		my $pkg = $1;
		$pkg =~ s#__*#::#g;
d2128 1
a2130 5
    # Place all of the external libraries after all of the Perl extension
    # libraries in the final link, in order to maximize the opportunity
    # for XS code from multiple extensions to resolve symbols against the
    # same external library while only including that library once.
    push @@optlibs, @@$extra;
d2132 1
a2132 1
    $target = "Perl$Config{'exe_ext'}" unless $target;
d2139 5
a2143 5
    if (@@optlibs) { $extralist = join(' ',@@optlibs); }
    else          { $extralist = ''; }
    # Let ExtUtils::Liblist find the necessary for us (but skip PerlShr;
    # that's what we're building here).
    push @@optlibs, grep { !/PerlShr/i } split +($self->ext())[2];
d2164 2
a2165 2
MAP_TARGET    = ',$self->fixpath($target,0),'
MAP_SHRTARGET = ',$self->fixpath($shrtarget,0),"
d2167 5
a2171 1
MAP_PERLINC   = ", $perlinc ? map('"$_" ',@@{$perlinc}) : '',"
d2173 1
a2173 1
MAP_LIBPERL = ",$self->fixpath($libperl,0),'
d2177 3
a2179 10
    push @@m,"\n${tmp}Makeaperl.Opt : \$(MAP_EXTRA)\n";
    foreach (@@optlibs) {
	push @@m,'	$(NOECHO) $(PERL) -e "print q{',$_,'}" >>$(MMS$TARGET)',"\n";
    }
    push @@m,"\n${tmp}PerlShr.Opt :\n\t";
    push @@m,'$(NOECHO) $(PERL) -e "print q{$(MAP_SHRTARGET)}" >$(MMS$TARGET)',"\n";

push @@m,'
$(MAP_SHRTARGET) : $(MAP_LIBPERL) Makeaperl.Opt ',"${libperldir}Perlshr_Attr.Opt",'
	$(MAP_LINKCMD)/Shareable=$(MMS$TARGET) $(MAP_LIBPERL), Makeaperl.Opt/Option ',"${libperldir}Perlshr_Attr.Opt/Option",'
d2182 9
a2190 13
	$(NOECHO) $(SAY) "To install the new ""$(MAP_TARGET)"" binary, say"
	$(NOECHO) $(SAY) "    $(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
	$(NOECHO) $(SAY) "To remove the intermediate files, say
	$(NOECHO) $(SAY) "    $(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(MAKEFILE) map_clean"
';
    push @@m,"\n${tmp}perlmain.c : \$(MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmp}Writemain.tmp\n";
    push @@m, "# More from the 255-char line length limit\n";
    foreach (@@staticpkgs) {
	push @@m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmp}Writemain.tmp\n];
    }
	push @@m,'
	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@@F)" ',$tmp,'Writemain.tmp >$(MMS$TARGET)
	$(NOECHO) $(RM_F) ',"${tmp}Writemain.tmp\n";
d2193 1
a2193 1
# Still more from the 255-char line length limit
d2195 4
a2198 4
	$(NOECHO) $(PERL) -e "print 'Perl binary $(MAP_TARGET)|'" >.MM_tmp
	$(NOECHO) $(PERL) -e "print 'MAP_STATIC|$(MAP_STATIC)|'" >>.MM_tmp
	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
	$(NOECHO) $(PERL) -e "print 'MAP_LIBPERL|$(MAP_LIBPERL)|'" >>.MM_tmp
d2200 1
a2200 1
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
d2205 1
a2205 1
	\$(NOECHO) \$(NOOP)
d2212 1
a2212 1
	\$(NOECHO) \$(NOOP)
d2216 1
a2216 1
	\$(RM_F) ${tmp}Makeaperl.Opt ${tmp}PerlShr.Opt \$(MAP_TARGET)
d2222 12
a2251 4

=back

=cut
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a14 3
use File::Spec;
our($Revision, @@ISA);
$Revision = '5.56 (27-Apr-1999)';
d16 3
a18 1
@@ISA = qw( File::Spec );
d41 150
d215 10
d235 10
d450 1
a450 1
            `$name -e "require $ver; print ""VER_OK\\n"""` =~ /VER_OK/) {
d457 1
a457 1
        if (`MCR $vmsfile -e "require $ver; print ""VER_OK\\n"""` =~ /VER_OK/) {
a627 3
    # Be kind about case for pollution
    for (@@ARGV) { $_ = uc($_) if /POLLUTE/i; }

d629 2
a630 3
	my(@@terms) = split(/\s+/,$self->{DEFINE});
	my(@@defs,@@udefs);
	foreach $def (@@terms) {
d632 1
a632 3
	    my $targ = \@@defs;
	    if ($def =~ s/^-([DU])//) {       # If it was a Unix-style definition
		if ($1 eq 'U') { $targ = \@@udefs; }
a639 1
	    push @@$targ, $def;
d641 1
a641 3
	$self->{DEFINE} = '';
	if (@@defs)  { $self->{DEFINE}  = '/Define=(' . join(',',@@defs)  . ')'; }
	if (@@udefs) { $self->{DEFINE} .= '/Undef=('  . join(',',@@udefs) . ')'; }
a839 1
    $definestr .= q["PERL_POLLUTE",] if $self->{POLLUTE};
d845 7
a851 16
    # ($self->{DEFINE} has already been VMSified in constants() above)
    if ($self->{DEFINE}) { $quals .= $self->{DEFINE}; }
    for $type (qw(Def Undef)) {
	my(@@terms);
	while ($quals =~ m:/${type}i?n?e?=([^/]+):ig) {
		my $term = $1;
		$term =~ s:^\((.+)\)$:$1:;
		push @@terms, $term;
	    }
	if ($type eq 'Def') {
	    push @@terms, qw[ $(DEFINE_VERSION) $(XS_DEFINE_VERSION) ];
	}
	if (@@terms) {
	    $quals =~ s:/${type}i?n?e?=[^/]+::ig;
	    $quals .= "/${type}ine=(" . join(',',@@terms) . ')';
	}
d855 11
a875 1
#    $quals =~ s/,,/,/g; $quals =~ s/\(,/(/g;
d880 1
a880 1
	if    ($self->{OPTIMIZE} =~ m!-g!) { $self->{OPTIMIZE} = '/Debug/NoOptimize' }
d1269 7
d1340 1
a1340 1
    push @@m,'
d1348 3
a1350 26
	q[, 'FUNCLIST' => ],neatvalue($funclist),qq[)"\n];

    push @@m, '	$(PERL) -e "print ""$(INST_STATIC)/Include=';
    if ($self->{OBJECT} =~ /\bBASEEXT\b/ or
        $self->{OBJECT} =~ /\b$self->{BASEEXT}\b/i) { 
        push @@m, ($Config{d_vms_case_sensitive_symbols}
	           ? uc($self->{BASEEXT}) :'$(BASEEXT)');
    }
    else {  # We don't have a "main" object file, so pull 'em all in
       # Upcase module names if linker is being case-sensitive
       my($upcase) = $Config{d_vms_case_sensitive_symbols};
	my(@@omods) = map { s/\.[^.]*$//;         # Trim off file type
	                   s[\$\(\w+_EXT\)][];   # even as a macro
	                   s/.*[:>\/\]]//;       # Trim off dir spec
			   $upcase ? uc($_) : $_;
	                 } split ' ', $self->eliminate_macros($self->{OBJECT});
	my($tmp,@@lines,$elt) = '';
	my $tmp = shift @@omods;
	foreach $elt (@@omods) {
	    $tmp .= ",$elt";
		if (length($tmp) > 80) { push @@lines, $tmp;  $tmp = ''; }
	}
	push @@lines, $tmp;
	push @@m, '(', join( qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""], @@lines),')';
    }
	push @@m, '\n$(INST_STATIC)/Library\n"";" >>$(MMS$TARGET)',"\n";
d1468 2
a1469 2
    push @@m, "\t\$(NOECHO) \$(PERL) -e 1 >\$(INST_ARCHAUTODIR)extralibs.ld\n";
    foreach $lib (split ' ', $self->{EXTRALIBS}) {
d2189 1
a2189 3
		MAKEAPERL=1 NORECURS=1 };

	push @@m, map(q[ \\\n\t\t"$_"], @@ARGV),q{
d2194 1
d2315 1
a2315 1
    # Let ExtUtils::Liblist find the necessary libs for us (but skip PerlShr)
d2317 1
a2317 1
    push @@optlibs, grep { !/PerlShr/i } split ' ', +($self->ext())[2];
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d154 1
a154 1
# appears in @@MM::ISA before ExtUtils::Liblist::Kid, so if there isn't an ext()
d156 1
a156 1
# mimic inheritance here and hand off to ExtUtils::Liblist::Kid.
d158 1
a158 2
  require ExtUtils::Liblist;
  ExtUtils::Liblist::Kid::ext(@@_);
a233 1
    my($rslt);
a234 1
    local *TCF;
d280 2
a281 8
        if ($name =~ /^[\w\-\$]+$/) {
            open(TCF,">temp_mmvms.com") || die('unable to open temp file');
            print TCF "\$ set message/nofacil/nosever/noident/notext\n";
            print TCF "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";
            close TCF;
            $rslt = `\@@temp_mmvms.com` ;
            unlink('temp_mmvms.com');
            if ($rslt =~ /VER_OK/) {
a284 1
        }
d288 1
a288 7
        open(TCF,">temp_mmvms.com") || die('unable to open temp file');
        print TCF "\$ set message/nofacil/nosever/noident/notext\n";
        print TCF "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";
        close TCF;
        $rslt = `\@@temp_mmvms.com`;
        unlink('temp_mmvms.com');
        if ($rslt =~ /VER_OK/) {
d614 1
a614 1
INST_DYNAMIC = $(INST_ARCHAUTODIR)$(DLBASE).$(DLEXT)
d814 1
a814 1
    push(@@m,q[	$(PERL) "-I$(PERL_LIB)" "-MExtUtils::Install" -e "pm_to_blib({split(' ',<STDIN>)},'].$autodir.q[','$(PM_FILTER)')" <.MM_tmp]);
a868 5
    if ($Config{'ldflags'} && 
        $Config{'ldflags'} =~ m!/Debug!i &&
        (!exists($self->{XSOPT}) || $self->{XSOPT} !~ /linenumbers/)) {
        unshift(@@tmargs,'-nolinenumbers');
    }
d1021 1
a1021 1
    $attribs{NAME} =~ s/[^\w\$]/-/g;
d1197 2
a1198 2
        my($tmp,@@lines,$elt) = '';
	$tmp = shift @@omods;
a1654 3
tardist : $(DISTVNAME).tar$(SUFFIX)
	$(NOECHO) $(NOOP)

d1664 1
a1664 1
        $(TAR) "$(TARFLAGS)" $(DISTVNAME).tar [.$(DISTVNAME)...]
a1874 1
	$(NOOP)
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d3 2
a9 2
use strict;

d16 2
a17 6
use vars qw($Revision @@ISA $VERSION);
($VERSION) = $Revision = '5.65';

require ExtUtils::MM_Any;
require ExtUtils::MM_Unix;
@@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix File::Spec );
d19 2
a20 1
use ExtUtils::MakeMaker qw($Verbose neatvalue);
d22 1
d30 1
a30 3
  Do not use this directly.
  Instead, use ExtUtils::MM and it will figure out which MM_*
  class to use for you.
d40 1
a40 1
=over 4
d66 86
a156 1
# XXX This hackery will die soon. --Schwern
d158 2
a159 2
    require ExtUtils::Liblist::Kid;
    goto &ExtUtils::Liblist::Kid::ext;
d164 1
a164 1
=head2 Methods
d172 1
a172 1
=over 4
d202 1
a202 5
        if (keys %xs) { 
            foreach $pm (@@pm) { 
                $defpm = $pm, last if exists $xs{$pm}; 
            } 
        }
d240 2
a241 2
    @@sdirs = sort { my($absa) = File::Spec->file_name_is_absolute($a);
                    my($absb) = File::Spec->file_name_is_absolute($b);
d267 1
a267 1
	$inabs++ if File::Spec->file_name_is_absolute($dir);
d276 1
a276 1
	    if ($name !~ m![/:>\]]!) { push(@@cand,File::Spec->catfile($dir,$name)); }
d313 13
d373 1
a373 1
	    if (File::Spec->file_name_is_absolute($name)) {
d376 1
a376 1
		$abs = File::Spec->catfile($dir, $name);
d412 13
a437 14
=item init_main (override)

Override DISTVNAME so it uses VERSION_SYM to avoid getting too many
dots in the name.

=cut

sub init_main {
    my($self) = shift;

    $self->SUPER::init_main;
    $self->{DISTVNAME} = "$self->{DISTNAME}-$self->{VERSION_SYM}";
}

d454 1
a454 1
    $self->{RM_RF} = '$(PERLRUN) -e "use File::Path; @@dirs = map(VMS::Filespec::unixify($_),@@ARGV); rmtree(\@@dirs,0,0)"';
d460 1
a460 2
    
    $self->SUPER::init_others;
a477 1
    $self->{DEFINE} ||= '';
d496 2
a497 6
	if (@@defs)  { 
            $self->{DEFINE}  = '/Define=(' . join(',',@@defs)  . ')'; 
        }
	if (@@udefs) { 
            $self->{DEFINE} .= '/Undef=('  . join(',',@@udefs) . ')'; 
        }
d507 3
d511 5
a515 8
            INST_BIN INST_SCRIPT INST_LIB INST_ARCHLIB 
            INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
	    INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
            INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN  INSTALLSCRIPT 
            INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR
            INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR
            PERL_LIB PERL_ARCHLIB
            PERL_INC PERL_SRC FULLEXT ] ) {
a516 1
        next if $macro =~ /MAN/ && $self->{$macro} eq 'none';
d519 1
a519 1
    $self->{PERL_VMS} = File::Spec->catdir($self->{PERL_SRC},q(VMS))
d531 5
a535 11
	      AR_STATIC_ARGS NAME DISTNAME NAME_SYM VERSION VERSION_SYM 
              XS_VERSION
	      INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT 
              INSTALLDIRS
              PREFIX          SITEPREFIX      VENDORPREFIX
	      INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
	      INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
              INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN  INSTALLSCRIPT 
	      PERL_LIB PERL_ARCHLIB 
              SITELIBEXP SITEARCHEXP 
              LIBPERL_A MYEXTLIB
d537 1
a537 3
	      PERL_INC PERL FULLPERL PERLRUN FULLPERLRUN PERLRUNINST
              FULLPERLRUNINST ABSPERL ABSPERLRUN ABSPERLRUNINST
              PERL_CORE NOECHO NOOP
d550 1
a550 1
MAKEMAKER = ],File::Spec->catfile($self->{PERL_LIB},'ExtUtils','MakeMaker.pm'),qq[
d561 1
a561 1
    for my $tmp (qw/
d568 1
a568 1
    for my $tmp (qw/
d575 2
a576 3
    for my $tmp (qw/ XS MAN1PODS MAN3PODS PM /) {
	# Where is the space coming from? --jhi
	next unless $self ne " " && defined $self->{$tmp};
d584 1
a584 1
    for my $tmp (qw/ C O_FILES H /) {
d605 2
a606 5
    for my $tmp (qw/
	      INST_MAN1DIR  MAN1EXT 
              INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR
	      INST_MAN3DIR  MAN3EXT
              INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR
a612 3
makemakerdflt : all
	\$(NOECHO) \$(NOOP)

d704 1
a704 1
    for my $type (qw(Def Undef)) {
a733 2
    $self->{PERLTYPE} ||= '';

d750 2
d784 1
a784 1
		($Config{'archname'} eq 'VMS_AXP' ? 'Sys$Library' : 'DECC$Library_Include'),'
d804 3
a806 2
    my($autodir) = File::Spec->catdir($self->{INST_LIB},'auto');
    my(%files) = @@{$self->{PM_TO_BLIB}};
d808 1
a808 1
    my $m = <<'MAKE_FRAG';
d817 2
a818 25
MAKE_FRAG

    if( keys %files ) {
        $m .= <<'MAKE_FRAG';
	$(NOECHO) $(RM_F) .MM_tmp
MAKE_FRAG

        my $line = '';
        while (my($from, $to) = each %files) {
            $line .= " $from $to";
            if (length($line) > 128) {
                $m .= sprintf <<'MAKE_FRAG', $line;
	$(NOECHO) $(PERL) -e "print '%s'" >>.MM_tmp
MAKE_FRAG
                $line = '';
            }
        }
        $m .= sprintf <<'MAKE_FRAG', $line if $line;
	$(NOECHO) $(PERL) -e "print '%s'" >>.MM_tmp
MAKE_FRAG

        $m .= sprintf <<'MAKE_FRAG', $autodir;
	$(PERLRUN) "-MExtUtils::Install" -e "pm_to_blib({split(' ',<STDIN>)},'%s','$(PM_FILTER)')" <.MM_tmp
	$(NOECHO) $(RM_F) .MM_tmp
MAKE_FRAG
d820 7
d828 7
a834 3
    $m .= <<'MAKE_FRAG';
	$(NOECHO) $(TOUCH) pm_to_blib.ts
MAKE_FRAG
d836 1
a836 1
    return $m;
d845 1
a845 1
sub tool_autosplit {
d851 1
a851 1
AUTOSPLITFILE = $(PERLRUN) -e "use AutoSplit;}.$asl.q{autosplit($ARGV[0], $ARGV[1], 0, 1, 1) ;"
d864 1
a864 1
    my($xsdir) = File::Spec->catdir($self->{PERL_LIB},'ExtUtils');
d866 1
a866 1
    $xsdir = File::Spec->catdir($self->{PERL_SRC},'ext') unless (-f File::Spec->catfile($xsdir,'xsubpp'));
d890 1
a890 1
    my $xsubpp_version = $self->xsubpp_version(File::Spec->catfile($xsdir,'xsubpp'));
d908 1
a908 1
XSUBPP = \$(PERLRUN) \$(XSUBPPDIR)xsubpp
d932 1
a932 1
    my $command = qq{$self->{PERL} "-I$self->{PERL_LIB}" $xsubpp -v};
d962 1
a962 1
    $command = "$self->{PERLRUN} $xsubpp $file";
d1011 2
d1017 1
a1017 1
MOD_INSTALL = \$(PERLRUN) "-MExtUtils::Install" -e "install({split(' ',<STDIN>)},1);"
d1019 1
a1019 1
UNINSTALL = \$(PERLRUN) "-MExtUtils::Install" -e "uninstall(\$ARGV[0],1,1);"
d1044 1
a1044 3
    $attribs{DISTVNAME} ||= '$(DISTNAME)-$(VERSION_SYM)';

    return $self->SUPER::dist(%attribs);
d1103 1
a1103 1
Path seperator differences.
d1155 6
d1199 1
a1199 1
	$(PERLRUN) -e "use ExtUtils::Mksymlists;" -
d1298 1
a1298 1
	$(NOECHO) $(PERLRUN) -
d1330 1
a1330 1
    # If this extension has its own library (eg SDBM_File)
d1368 1
a1368 1
	$pod2man_exe = File::Spec->catfile($self->{PERL_SRC},'pod','pod2man');
d1370 1
a1370 1
	$pod2man_exe = File::Spec->catfile($Config{scriptdirexp},'pod2man');
d1386 2
a1387 2
q[POD2MAN = $(PERLRUN) "-MPod::Man" -we "%m=@@ARGV;for(keys %m){" -
-e "Pod::Man->new->parse_from_file($_,$m{$_}) }"
d1418 1
a1418 1
	foreach my $target (@@$list) {
d1426 1
a1426 1
",'	$(PERLRUNINST) '," $vmsplfile $vmsfile
d1458 3
d1548 1
a1548 1
    push(@@otherfiles,File::Spec->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));
d1585 2
a1586 2
    push @@m, "	\$(RM_RF) \$(INST_AUTODIR) \$(INST_ARCHAUTODIR)\n";
    push @@m, "	\$(RM_RF) \$(DISTVNAME)\n";
d1637 22
d1701 16
d1730 1
a1730 1
	$(ABSPERLRUN) Makefile.PL
d1755 1
a1755 1
		push(@@docfiles,qq[\t\$(NOECHO) \$(PERL) -e "print '$line'" >>.MM_tmp\n]);
d1759 1
a1759 1
	push(@@docfiles,qq[\t\$(NOECHO) \$(PERL) -e "print '$line'" >>.MM_tmp\n]) if $line;
d1772 3
d1789 2
a1790 2
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(PERL_ARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(INSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
d1799 1
a1799 1
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].File::Spec->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
d1803 2
a1804 2
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(SITEARCHEXP)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(INSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
d1807 1
a1807 1
	$(NOECHO) $(PERL) -e "print '$(INST_BIN) $(INSTALLSITEBIN) '" >>.MM_tmp
d1809 2
a1810 13
	$(NOECHO) $(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLSITEMAN1DIR) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLSITEMAN3DIR) '" >>.MM_tmp
	$(MOD_INSTALL) <.MM_tmp
	$(NOECHO) Delete/NoLog/NoConfirm .MM_tmp;
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].File::Spec->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[

pure_vendor_install ::
	$(NOECHO) $(PERL) -e "print '$(INST_LIB) $(INSTALLVENDORLIB) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_ARCHLIB) $(INSTALLVENDORARCH) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_BIN) $(INSTALLVENDORBIN) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_SCRIPT) $(INSTALLSCRIPT) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN1DIR) $(INSTALLVENDORMAN1DIR) '" >>.MM_tmp
	$(NOECHO) $(PERL) -e "print '$(INST_MAN3DIR) $(INSTALLVENDORMAN3DIR) '" >>.MM_tmp
d1813 1
d1824 1
a1824 1
	$(NOECHO) $(PERL) .MM2_tmp <.MM_tmp >>%.File::Spec->catfile($self->{INSTALLARCHLIB},'perllocal.pod').q[
d1836 1
a1836 1
	$(NOECHO) $(PERL) .MM2_tmp <.MM_tmp >>%.File::Spec->catfile($self->{INSTALLARCHLIB},'perllocal.pod').q[
a1838 2
doc_vendor_install ::

d1846 1
a1846 1
	$(NOECHO) $(UNINSTALL) ].File::Spec->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
d1852 1
a1852 1
	$(NOECHO) $(UNINSTALL) ],File::Spec->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist'),"\n",q[
d1874 8
a1881 15
$(OBJECT) : $(PERL_INC)EXTERN.h, $(PERL_INC)INTERN.h, $(PERL_INC)XSUB.h
$(OBJECT) : $(PERL_INC)av.h, $(PERL_INC)cc_runtime.h, $(PERL_INC)config.h
$(OBJECT) : $(PERL_INC)cop.h, $(PERL_INC)cv.h, $(PERL_INC)embed.h
$(OBJECT) : $(PERL_INC)embedvar.h, $(PERL_INC)fakethr.h, $(PERL_INC)form.h
$(OBJECT) : $(PERL_INC)gv.h, $(PERL_INC)handy.h, $(PERL_INC)hv.h
$(OBJECT) : $(PERL_INC)intrpvar.h, $(PERL_INC)iperlsys.h, $(PERL_INC)keywords.h
$(OBJECT) : $(PERL_INC)mg.h, $(PERL_INC)nostdio.h, $(PERL_INC)op.h
$(OBJECT) : $(PERL_INC)opcode.h, $(PERL_INC)opnames.h, $(PERL_INC)patchlevel.h
$(OBJECT) : $(PERL_INC)perl.h, $(PERL_INC)perlapi.h, $(PERL_INC)perlio.h
$(OBJECT) : $(PERL_INC)perlsdio.h, $(PERL_INC)perlsfio.h, $(PERL_INC)perlvars.h
$(OBJECT) : $(PERL_INC)perly.h, $(PERL_INC)pp.h, $(PERL_INC)pp_proto.h
$(OBJECT) : $(PERL_INC)proto.h, $(PERL_INC)regcomp.h, $(PERL_INC)regexp.h
$(OBJECT) : $(PERL_INC)regnodes.h, $(PERL_INC)scope.h, $(PERL_INC)sv.h
$(OBJECT) : $(PERL_INC)thrdvar.h, $(PERL_INC)thread.h, $(PERL_INC)utf8.h
$(OBJECT) : $(PERL_INC)util.h, $(PERL_INC)vmsish.h, $(PERL_INC)warnings.h
d1888 1
a1888 1
	push(@@macros,'__AXP__=1') if $Config{'archname'} eq 'VMS_AXP';
d1947 1
a1947 1
	$(PERLRUN) Makefile.PL ],join(' ',map(qq["$_"],@@ARGV)),q[
a1954 9
=item find_tests (override)

=cut

sub find_tests {
    my $self = shift;
    return -d 't' ? 't/*.t' : '';
}

d1963 1
a1963 1
    my($tests) = $attribs{TESTS} || $self->find_tests;
d1988 2
a1989 2
    push(@@m, $self->test_via_harness('$(FULLPERLRUN)', $tests)) if $tests;
    push(@@m, $self->test_via_script('$(FULLPERLRUN)', 'test.pl')) if -f "test.pl";
d1994 1
a1994 1
    push(@@m, $self->test_via_script('$(FULLPERLRUN) "$(TESTDB_SW)"', '$(TEST_FILE)'));
d2017 24
a2049 2
use vars qw(%olbs);

d2067 1
a2067 1
	$(NOECHO) $(PERLRUNINST) \
d2092 1
a2092 1
    local(%olbs);       # XXX can this be lexical?
a2188 1
    my $shrtarget;
d2201 1
a2201 1
	unless (-f $libperl || -f ($libperl = File::Spec->catfile($Config{'installarchlib'},'CORE',$libperl))) {
d2208 2
a2209 2
	    $libperl = File::Spec->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}");
	} elsif (-f ($libperl = File::Spec->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}")) ) {
d2260 1
a2260 1
	$(NOECHO) $(PERL) -pl040 -e " " ].File::Spec->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
d2262 1
a2262 1
	$(DOC_INSTALL) <.MM_tmp >>].File::Spec->catfile('$(INSTALLARCHLIB)','perllocal.pod').q[
d2296 1
a2297 1
    return $text if $text =~ m/^\w+\s*=/; # leave macro defs alone
d2302 1
a2302 87
=item prefixify (override)

prefixifying on VMS is simple.  Each should simply be:

    perl_root:[some.dir]

which can just be converted to:

    volume:[your.prefix.some.dir]

otherwise you get the default layout.

In effect, your search prefix is ignored and $Config{vms_prefix} is
used instead.

=cut

sub prefixify {
    my($self, $var, $sprefix, $rprefix, $default) = @@_;
    $default = VMS::Filespec::vmsify($default) 
      unless $default =~ /\[.*\]/;

    (my $var_no_install = $var) =~ s/^install//;
    my $path = $self->{uc $var} || $Config{lc $var} || 
               $Config{lc $var_no_install};

    if( !$path ) {
        print STDERR "  no Config found for $var.\n" if $Verbose >= 2;
        $path = $self->_prefixify_default($rprefix, $default);
    }
    elsif( $sprefix eq $rprefix ) {
        print STDERR "  no new prefix.\n" if $Verbose >= 2;
    }
    else {

        print STDERR "  prefixify $var => $path\n"     if $Verbose >= 2;
        print STDERR "    from $sprefix to $rprefix\n" if $Verbose >= 2;

        my($path_vol, $path_dirs) = File::Spec->splitpath( $path );
        if( $path_vol eq $Config{vms_prefix}.':' ) {
            print STDERR "  $Config{vms_prefix}: seen\n" if $Verbose >= 2;

            $path_dirs =~ s{^\[}{\[.} unless $path_dirs =~ m{^\[\.};
            $path = $self->_catprefix($rprefix, $path_dirs);
        }
        else {
            $path = $self->_prefixify_default($rprefix, $default);
        }
    }

    print "    now $path\n" if $Verbose >= 2;
    return $self->{uc $var} = $path;
}


sub _prefixify_default {
    my($self, $rprefix, $default) = @@_;

    print STDERR "  cannot prefix, using default.\n" if $Verbose >= 2;

    if( !$default ) {
        print STDERR "No default!\n" if $Verbose >= 1;
        return;
    }
    if( !$rprefix ) {
        print STDERR "No replacement prefix!\n" if $Verbose >= 1;
        return '';
    }

    return $self->_catprefix($rprefix, $default);
}

sub _catprefix {
    my($self, $rprefix, $default) = @@_;

    my($rvol, $rdirs) = File::Spec->splitpath($rprefix);
    if( $rvol ) {
        return File::Spec->catpath($rvol,
                                   File::Spec->catdir($rdirs, $default),
                                   ''
                                  )
    }
    else {
        return File::Spec->catdir($rdirs, $default);
    }
}

d2308 1
a2308 1
1;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d10 1
d13 1
a13 9

BEGIN {
    # so we can compile the thing on non-VMS platforms.
    if( $^O eq 'VMS' ) {
        require VMS::Filespec;
        VMS::Filespec->import;
    }
}

d15 1
d17 1
a17 2
($VERSION) = '5.70';
($Revision) = q$Revision: 1.110 $ =~ /Revision:\s+(\S+)/;
d21 1
a21 1
@@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
d55 1
d57 1
a57 1
    foreach my $word (@@_) {
d161 19
a179 27

    if( $self->{PERL_CORE} ) {
        # Check in relative directories first, so we pick up the current
        # version of Perl if we're running MakeMaker as part of the main build.
        @@sdirs = sort { my($absa) = $self->file_name_is_absolute($a);
                        my($absb) = $self->file_name_is_absolute($b);
                        if ($absa && $absb) { return $a cmp $b }
                        else { return $absa ? 1 : ($absb ? -1 : ($a cmp $b)); }
                      } @@$dirs;
        # Check miniperl before perl, and check names likely to contain
        # version numbers before "generic" names, so we pick up an
        # executable that's less likely to be from an old installation.
        @@snames = sort { my($ba) = $a =~ m!([^:>\]/]+)$!;  # basename
                         my($bb) = $b =~ m!([^:>\]/]+)$!;
                         my($ahasdir) = (length($a) - length($ba) > 0);
                         my($bhasdir) = (length($b) - length($bb) > 0);
                         if    ($ahasdir and not $bhasdir) { return 1; }
                         elsif ($bhasdir and not $ahasdir) { return -1; }
                         else { $bb =~ /\d/ <=> $ba =~ /\d/
                                  or substr($ba,0,1) cmp substr($bb,0,1)
                                  or length($bb) <=> length($ba) } } @@$names;
    }
    else {
        @@sdirs  = @@$dirs;
        @@snames = @@$names;
    }

d190 1
a190 1
	$inabs++ if $self->file_name_is_absolute($dir);
d199 1
a199 1
	    if ($name !~ m![/:>\]]!) { push(@@cand,$self->catfile($dir,$name)); }
d214 3
a216 3
                print "Using PERL=$name\n" if $trace;
                return $name;
            }
d270 36
a334 34
=item init_DEST

(override) Because of the difficulty concatenating VMS filepaths we
must pre-expand the DEST* variables.

=cut

sub init_DEST {
    my $self = shift;

    $self->SUPER::init_DEST;

    # Expand DEST variables.
    foreach my $var ($self->installvars) {
        my $destvar = 'DESTINSTALL'.$var;
        $self->{$destvar} = File::Spec->eliminate_macros($self->{$destvar});
    }
}


=item init_DIRFILESEP

No seperator between a directory path and a filename on VMS.

=cut

sub init_DIRFILESEP {
    my($self) = shift;

    $self->{DIRFILESEP} = '';
    return 1;
}


d337 2
d346 1
a346 28

    $self->{DEFINE} ||= '';
    if ($self->{DEFINE} ne '') {
        my(@@terms) = split(/\s+/,$self->{DEFINE});
        my(@@defs,@@udefs);
        foreach my $def (@@terms) {
            next unless $def;
            my $targ = \@@defs;
            if ($def =~ s/^-([DU])//) {    # If it was a Unix-style definition
                $targ = \@@udefs if $1 eq 'U';
                $def =~ s/='(.*)'$/=$1/;  # then remove shell-protection ''
                $def =~ s/^'(.*)'$/$1/;   # from entire term or argument
            }
            if ($def =~ /=/) {
                $def =~ s/"/""/g;  # Protect existing " from DCL
                $def = qq["$def"]; # and quote to prevent parsing of =
            }
            push @@$targ, $def;
        }

        $self->{DEFINE} = '';
        if (@@defs)  { 
            $self->{DEFINE}  = '/Define=(' . join(',',@@defs)  . ')'; 
        }
        if (@@udefs) { 
            $self->{DEFINE} .= '/Undef=('  . join(',',@@udefs) . ')'; 
        }
    }
a353 7
DEV_NULL should probably be overriden with something.

Also changes EQUALIZE_TIMESTAMP to set revision date of target file to
one second later than source file, since MMK interprets precisely
equal revision dates for a source and target file as a sign that the
target needs to be updated.

d359 9
a367 24
    $self->{NOOP}               = 'Continue';
    $self->{NOECHO}             ||= '@@ ';

    $self->{MAKEFILE}           ||= 'Descrip.MMS';
    $self->{FIRST_MAKEFILE}     ||= $self->{MAKEFILE};
    $self->{MAKE_APERL_FILE}    ||= 'Makeaperl.MMS';
    $self->{MAKEFILE_OLD}       ||= '$(FIRST_MAKEFILE)_old';

    $self->{ECHO}     ||= '$(PERLRUN) -le "print qq{@@ARGV}"';
    $self->{ECHO_N}   ||= '$(PERLRUN) -e  "print qq{@@ARGV}"';
    $self->{TOUCH}    ||= '$(PERLRUN) "-MExtUtils::Command" -e touch';
    $self->{CHMOD}    ||= '$(PERLRUN) "-MExtUtils::Command" -e chmod'; 
    $self->{RM_F}     ||= '$(PERLRUN) "-MExtUtils::Command" -e rm_f';
    $self->{RM_RF}    ||= '$(PERLRUN) "-MExtUtils::Command" -e rm_rf';
    $self->{TEST_F}   ||= '$(PERLRUN) "-MExtUtils::Command" -e test_f';
    $self->{EQUALIZE_TIMESTAMP} ||= '$(PERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';

    $self->{MOD_INSTALL} ||= 
      $self->oneliner(<<'CODE', ['-MExtUtils::Install']);
install({split(' ',<STDIN>)}, '$(VERBINST)', 0, '$(UNINST)');
CODE

    $self->{SHELL}    ||= 'Posix';

d371 1
a371 1

a372 11

    if ($self->{OBJECT} =~ /\s/) {
        $self->{OBJECT} =~ s/(\\)?\n+\s+/ /g;
        $self->{OBJECT} = $self->wraplist(
            map $self->fixpath($_,0), split /,?\s+/, $self->{OBJECT}
        );
    }

    $self->{LDFROM} = $self->wraplist(
        map $self->fixpath($_,0), split /,?\s+/, $self->{LDFROM}
    );
a374 56

=item init_platform (override)

Add PERL_VMS, MM_VMS_REVISION and MM_VMS_VERSION.

MM_VMS_REVISION is for backwards compatibility before MM_VMS had a
$VERSION.

=cut

sub init_platform {
    my($self) = shift;

    $self->{MM_VMS_REVISION} = $Revision;
    $self->{MM_VMS_VERSION}  = $VERSION;
    $self->{PERL_VMS} = $self->catdir($self->{PERL_SRC}, 'VMS')
      if $self->{PERL_SRC};
}


=item platform_constants

=cut

sub platform_constants {
    my($self) = shift;
    my $make_frag = '';

    foreach my $macro (qw(PERL_VMS MM_VMS_REVISION MM_VMS_VERSION))
    {
        next unless defined $self->{$macro};
        $make_frag .= "$macro = $self->{$macro}\n";
    }

    return $make_frag;
}


=item init_VERSION (override)

Override the *DEFINE_VERSION macros with VMS semantics.  Translate the
MAKEMAKER filepath to VMS style.

=cut

sub init_VERSION {
    my $self = shift;

    $self->SUPER::init_VERSION;

    $self->{DEFINE_VERSION}    = '"$(VERSION_MACRO)=""$(VERSION)"""';
    $self->{XS_DEFINE_VERSION} = '"$(XS_VERSION_MACRO)=""$(XS_VERSION)"""';
    $self->{MAKEMAKER} = vmsify($INC{'ExtUtils/MakeMaker.pm'});
}


d378 2
a379 2
regardless of input syntax.  Also makes lists of files
comma-separated.
d385 1
d390 35
a424 2
    # Cleanup paths for directories in MMS macros.
    foreach my $macro ( qw [
d426 5
d432 2
a433 5
            PERL_INC PERL_SRC ],
                        (map { 'INSTALL'.$_ } $self->installvars)
                      ) 
    {
        next unless defined $self->{$macro};
d435 32
a466 1
        $self->{$macro} = $self->fixpath($self->{$macro},1);
d469 23
a491 6
    # Cleanup paths for files in MMS macros.
    foreach my $macro ( qw[LIBPERL_A FIRST_MAKEFILE MAKEFILE_OLD 
                           MAKE_APERL_FILE MYEXTLIB] ) 
    {
        next unless defined $self->{$macro};
        $self->{$macro} = $self->fixpath($self->{$macro},0);
d494 2
a495 4
    # Fixup files for MMS macros
    # XXX is this list complete?
    for my $macro (qw/
                   FULLEXT VERSION_FROM OBJECT LDFROM
d497 2
a498 2
        next unless defined $self->{$macro};
        $self->{$macro} = $self->fixpath($self->{$macro},0);
d501 9
d511 7
a517 9
    for my $macro (qw/ XS MAN1PODS MAN3PODS PM /) {
        # Where is the space coming from? --jhi
        next unless $self ne " " && defined $self->{$macro};
        my %tmp = ();
        for my $key (keys %{$self->{$macro}}) {
            $tmp{$self->fixpath($key,0)} = 
                                     $self->fixpath($self->{$macro}{$key},0);
        }
        $self->{$macro} = \%tmp;
d520 20
a539 7
    for my $macro (qw/ C O_FILES H /) {
        next unless defined $self->{$macro};
        my @@tmp = ();
        for my $val (@@{$self->{$macro}}) {
            push(@@tmp,$self->fixpath($val,0));
        }
        $self->{$macro} = \@@tmp;
d542 3
a544 2
    return $self->SUPER::constants;
}
d546 2
d549 2
a550 1
=item special_targets
d552 3
a554 1
Clear the default .SUFFIXES and put in our own list.
d556 3
a558 1
=cut
d560 16
a575 2
sub special_targets {
    my $self = shift;
d577 4
a580 3
    my $make_frag .= <<'MAKE_FRAG';
.SUFFIXES :
.SUFFIXES : $(OBJ_EXT) .c .cpp .cxx .xs
d582 2
a583 1
MAKE_FRAG
d585 1
a585 1
    return $make_frag;
d726 72
d808 4
a811 11

    my $xsdir;
    foreach my $dir (@@INC) {
        $xsdir = $self->catdir($dir, 'ExtUtils');
        if( -r $self->catfile($xsdir, "xsubpp") ) {
            last;
        }
    }

    my $tmdir   = File::Spec->catdir($self->{PERL_LIB},"ExtUtils");
    my(@@tmdeps) = $self->catfile($tmdir,'typemap');
d834 1
d836 13
d850 1
a850 3
    $self->{XSPROTOARG} = '' unless defined $self->{XSPROTOARG};

    return "
d859 1
d861 2
a862 1
=item tools_other (override)
d864 1
a864 1
Throw in some dubious extra macros for Makefile args.
d866 5
a870 1
Also keep around the old $(SAY) macro in case somebody's using it.
d872 1
a872 1
=cut
d874 1
a874 2
sub tools_other {
    my($self) = @@_;
d876 8
a883 3
    # XXX Are these necessary?  Does anyone override them?  They're longer
    # than just typing the literal string.
    my $extra_tools = <<'EXTRA_TOOLS';
d885 1
a885 6
# Assumes $(MMS) invokes MMS or MMK
# (It is assumed in some cases later that the default makefile name
# (Descrip.MMS for MM[SK]) is used.)
USEMAKEFILE = /Descrip=
USEMACROS = /Macro=(
MACROEND = )
d887 1
a887 2
# Just in case anyone is using the old macro.
SAY = $(ECHO)
d889 4
a892 1
EXTRA_TOOLS
d894 4
a897 2
    return $self->SUPER::tools_other . $extra_tools;
}
d899 4
a902 1
=item init_dist (override)
d904 1
a904 1
VMSish defaults for some values.
d906 8
a913 1
  macro         description                     default
d915 2
a916 1
  ZIPFLAGS      flags to pass to ZIP            -Vu
d918 2
a919 4
  COMPRESS      compression command to          gzip
                use for tarfiles
  SUFFIX        suffix to put on                -gz 
                compressed files
d921 3
a923 1
  SHAR          shar command to use             vms_share
d925 1
a925 2
  DIST_DEFAULT  default target to use to        tardist
                create a distribution
d927 6
a932 2
  DISTVNAME     Use VERSION_SYM instead of      $(DISTNAME)-$(VERSION_SYM)
                VERSION for the name
d936 1
a936 1
sub init_dist {
d938 28
a965 5
    $self->{ZIPFLAGS}     ||= '-Vu';
    $self->{COMPRESS}     ||= 'gzip';
    $self->{SUFFIX}       ||= '-gz';
    $self->{SHAR}         ||= 'vms_share';
    $self->{DIST_DEFAULT} ||= 'zipdist';
d967 2
a968 1
    $self->SUPER::init_dist;
d970 19
a988 1
    $self->{DISTVNAME}    = "$self->{DISTNAME}-$self->{VERSION_SYM}";
d1045 56
d1207 1
a1207 1
$(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt $(INST_ARCHAUTODIR)$(DIRFILESEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
d1234 2
a1235 2
$(BOOTSTRAP) : $(FIRST_MAKEFILE) '."$self->{BOOTDEP}".' $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
	$(NOECHO) $(ECHO) "Running mkbootstrap for $(NAME) ($(BSLOADLIBS))"
d1240 1
a1240 1
$(INST_BOOT) : $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
d1264 1
a1264 1
$(OBJECT) : $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
d1292 50
d1383 1
a1383 1
    my(@@m, $from, $to, %fromto, @@to);
a1395 3
pure_all :: @@to
	\$(NOECHO) \$(NOOP)

d1398 1
a1398 2

    my $line = '';
d1411 2
a1412 6
	if ($to =~ m#[/>:\]]#) {
            $todir = dirname($to); 
        }
	else { 
            ($todir = $to) =~ s/[^\)]+$//; 
        }
d1415 1
a1415 1
$to : $from \$(FIRST_MAKEFILE) ${todir}\$(DIRFILESEP).exists
d1458 1
a1458 1
clean :: clean_subdirs
d1460 5
d1472 6
a1477 9
        my @@filelist = ref $attribs{FILES} eq 'ARRAY'
            ? @@{$attribs{FILES}}
            : split /\s+/, $attribs{FILES};

	foreach my $word (@@filelist) {
	    if ($word =~ m#^\$\((.*)\)$# and 
                ref $self->{$1} eq 'ARRAY') 
            {
		push(@@otherfiles, @@{$self->{$1}});
d1482 4
a1485 5
    push(@@otherfiles, qw[ blib $(MAKE_APERL_FILE) 
                          perlmain.c pm_to_blib pm_to_blib.ts ]);
    push(@@otherfiles, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'));
    push(@@otherfiles, $self->catfile('$(INST_ARCHAUTODIR)','extralibs.ld'));

d1487 1
a1487 1
    { my(%of) = map { ($_ => 1) } @@otherfiles; @@otherfiles = keys %of; }
d1489 1
a1489 2
    my $line = '';
    foreach my $file (@@otherfiles) {
a1501 33

=item clean_subdirs_target

  my $make_frag = $MM->clean_subdirs_target;

VMS semantics for changing directories and rerunning make very different.

=cut

sub clean_subdirs_target {
    my($self) = shift;

    # No subdirectories, no cleaning.
    return <<'NOOP_FRAG' unless @@{$self->{DIR}};
clean_subdirs :
	$(NOECHO) $(NOOP)
NOOP_FRAG


    my $clean = "clean_subdirs :\n";

    foreach my $dir (@@{$self->{DIR}}) { # clean subdirectories first
	$dir = $self->fixpath($dir,1);

        $clean .= sprintf <<'MAKE_FRAG', $dir, $dir;
	If F$Search("%s$(FIRST_MAKEFILE)").nes."" Then $(PERLRUN) -e "chdir '%s'; print `$(MMS)$(MMSQUALIFIERS) clean`;"
MAKE_FRAG
    }

    return $clean;
}


d1517 1
a1517 1
	push(@@m, '	If F$Search("'."$vmsdir".'$(FIRST_MAKEFILE)").nes."" Then \\',"\n\t",
d1526 2
a1527 3
    my($file,$fcnt);
    my(@@files) = values %{$self->{PM}};
    push @@files, qw{ $(FIRST_MAKEFILE) $(MAKEFILE_OLD) };
d1531 2
a1532 1

a1534 2

    my $line = '';
d1536 1
a1571 1
=item zipfile_target (o)
d1573 1
a1573 1
=item tarfile_target (o)
d1575 2
a1576 1
=item shdist_target (o)
d1578 7
a1584 1
Syntax for invoking shar, tar and zip differs from that for Unix.
d1586 2
a1587 1
=cut
d1589 2
a1590 2
sub zipfile_target {
    my($self) = shift;
a1591 1
    return <<'MAKE_FRAG';
a1596 2
MAKE_FRAG
}
a1597 4
sub tarfile_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
a1604 2
MAKE_FRAG
}
a1605 4
sub shdist_target {
    my($self) = shift;

    return <<'MAKE_FRAG';
d1608 1
a1608 1
	$(SHAR) [.$(DISTVNAME)...]*.*; $(DISTVNAME).share
d1611 1
a1611 1
MAKE_FRAG
d1645 1
a1645 1
    my(@@m,@@exe_files);
d1652 1
a1652 1
		push(@@exe_files,qq[\t\$(NOECHO) \$(ECHO) "$line" >>.MM_tmp\n]);
d1656 1
a1656 1
	push(@@exe_files,qq[\t\$(NOECHO) \$(ECHO) "$line" >>.MM_tmp\n]) if $line;
d1673 1
a1673 1
        $(NOECHO) $(NOOP)
d1676 1
a1676 1
	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1679 1
a1679 1
	$(NOECHO) $(ECHO) "INSTALLDIRS not defined, defaulting to INSTALLDIRS=site"
d1684 10
a1693 10
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLARCHLIB)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLPRIVLIB) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLARCHLIB) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLBIN) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLMAN1DIR) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLMAN3DIR) " >>.MM_tmp
	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
	$(NOECHO) $(RM_F) .MM_tmp
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
d1698 10
a1707 10
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLSITEARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLSITELIB) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLSITEARCH) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLSITEBIN) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLSITEMAN1DIR) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLSITEMAN3DIR) " >>.MM_tmp
	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
	$(NOECHO) $(RM_F) .MM_tmp
	$(NOECHO) $(WARN_IF_OLD_PACKLIST) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
d1710 8
a1717 10
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'read '.File::Spec->catfile('$(VENDORARCHEXP)','auto','$(FULLEXT)','.packlist').' '" >.MM_tmp
	$(NOECHO) $(PERLRUN) "-MFile::Spec" -e "print 'write '.File::Spec->catfile('$(DESTINSTALLVENDORARCH)','auto','$(FULLEXT)','.packlist').' '" >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_LIB) $(DESTINSTALLVENDORLIB) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_ARCHLIB) $(DESTINSTALLVENDORARCH) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_BIN) $(DESTINSTALLVENDORBIN) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_SCRIPT) $(DESTINSTALLSCRIPT) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN1DIR) $(DESTINSTALLVENDORMAN1DIR) " >>.MM_tmp
	$(NOECHO) $(ECHO_N) "$(INST_MAN3DIR) $(DESTINSTALLVENDORMAN3DIR) " >>.MM_tmp
	$(NOECHO) $(MOD_INSTALL) <.MM_tmp
	$(NOECHO) $(RM_F) .MM_tmp
d1721 9
a1729 7
	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLPRIVLIB)|" >.MM_tmp
	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
],@@exe_files,
q[	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
	$(NOECHO) $(RM_F) .MM_tmp
d1733 9
a1741 7
	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLSITELIB)|" >.MM_tmp
	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
],@@exe_files,
q[	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
	$(NOECHO) $(RM_F) .MM_tmp
a1743 7
	$(NOECHO) $(ECHO) "Appending installation info to ].$self->catfile($self->{DESTINSTALLARCHLIB}, 'perllocal.pod').q["
	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	$(NOECHO) $(ECHO_N) "installed into|$(INSTALLVENDORLIB)|" >.MM_tmp
	$(NOECHO) $(ECHO_N) "LINKTYPE|$(LINKTYPE)|VERSION|$(VERSION)|EXE_FILES|$(EXE_FILES) " >>.MM_tmp
],@@exe_files,
q[	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
	$(NOECHO) $(RM_F) .MM_tmp
d1752 4
a1755 4
	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{PERL_ARCHLIB},'auto',$self->{FULLEXT},'.packlist').q[
	$(NOECHO) $(ECHO) "Uninstall is now deprecated and makes no actual changes."
	$(NOECHO) $(ECHO) "Please check the list above carefully for errors, and manually remove"
	$(NOECHO) $(ECHO) "the appropriate files.  Sorry for the inconvenience."
d1758 4
a1761 4
	$(NOECHO) $(UNINSTALL) ].$self->catfile($self->{SITEARCHEXP},'auto',$self->{FULLEXT},'.packlist').q[
	$(NOECHO) $(ECHO) "Uninstall is now deprecated and makes no actual changes."
	$(NOECHO) $(ECHO) "Please check the list above carefully for errors, and manually remove"
	$(NOECHO) $(ECHO) "the appropriate files.  Sorry for the inconvenience."
d1783 1
a1783 1
$(OBJECT) : $(PERL_INC)embedvar.h, $(PERL_INC)form.h
d1787 3
a1789 3
$(OBJECT) : $(PERL_INC)opcode.h, $(PERL_INC)patchlevel.h
$(OBJECT) : $(PERL_INC)perl.h, $(PERL_INC)perlio.h
$(OBJECT) : $(PERL_INC)perlsdio.h, $(PERL_INC)perlvars.h
d1793 2
a1794 2
$(OBJECT) : $(PERL_INC)thrdvar.h, $(PERL_INC)thread.h
$(OBJECT) : $(PERL_INC)util.h, $(PERL_INC)vmsish.h
d1800 1
a1800 1
	my($mmsquals) = '$(USEMAKEFILE)[.vms]$(FIRST_MAKEFILE)';
d1853 7
a1859 7
# We take a very conservative approach here, but it's worth it.
# We move $(FIRST_MAKEFILE) to $(MAKEFILE_OLD) here to avoid gnu make looping.
$(FIRST_MAKEFILE) : Makefile.PL $(CONFIGDEP)
	$(NOECHO) $(ECHO) "$(FIRST_MAKEFILE) out-of-date with respect to $(MMS$SOURCE_LIST)"
	$(NOECHO) $(ECHO) "Cleaning current config before rebuilding $(FIRST_MAKEFILE) ..."
	- $(MV) $(FIRST_MAKEFILE) $(MAKEFILE_OLD)
	- $(MMS)$(MMSQUALIFIERS) $(USEMAKEFILE)$(MAKEFILE_OLD) clean
d1861 2
a1862 2
	$(NOECHO) $(ECHO) "$(FIRST_MAKEFILE) has been rebuilt."
	$(NOECHO) $(ECHO) "Please run $(MMS) to build the extension."
d1902 1
a1902 1
      push(@@m, '	If F$Search("',$vmsdir,'$(FIRST_MAKEFILE)").nes."" Then $(PERL) -e "chdir ',"'$vmsdir'",
d1905 1
a1905 1
    push(@@m, "\t\$(NOECHO) \$(ECHO) \"No tests defined for \$(NAME) extension.\"\n")
d1952 1
a1952 1
    my($makefilename, $searchdirs, $static, $extra, $perlinc, $target, $tmpdir, $libperl) = 
d1966 1
a1966 1
	$(NOECHO) $(ECHO) "Writing ""$(MMS$TARGET)"" for this $(MAP_TARGET)"
d1969 1
a1969 1
		FIRST_MAKEFILE=$(MAKE_APERL_FILE) LINKTYPE=static \
d2094 2
a2095 2
    $tmpdir = "[]" unless $tmpdir;
    $tmpdir = $self->fixpath($tmpdir,1);
d2102 1
a2102 1
	unless (-f $libperl || -f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',$libperl))) {
d2109 2
a2110 2
	    $libperl = $self->catfile($self->{PERL_SRC},"libperl$self->{LIB_EXT}");
	} elsif (-f ($libperl = $self->catfile($Config{'installarchlib'},'CORE',"libperl$self->{LIB_EXT}")) ) {
d2130 1
a2130 1
    push @@m,"\n${tmpdir}Makeaperl.Opt : \$(MAP_EXTRA)\n";
d2134 1
a2134 1
    push @@m,"\n${tmpdir}PerlShr.Opt :\n\t";
d2137 1
a2137 1
    push @@m,'
d2140 6
a2145 6
$(MAP_TARGET) : $(MAP_SHRTARGET) ',"${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}PerlShr.Opt",'
	$(MAP_LINKCMD) ',"${tmpdir}perlmain\$(OBJ_EXT)",', PerlShr.Opt/Option
	$(NOECHO) $(ECHO) "To install the new ""$(MAP_TARGET)"" binary, say"
	$(NOECHO) $(ECHO) "    $(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
	$(NOECHO) $(ECHO) "To remove the intermediate files, say
	$(NOECHO) $(ECHO) "    $(MMS)$(MMSQUALIFIERS)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
d2147 1
a2147 1
    push @@m,"\n${tmpdir}perlmain.c : \$(FIRST_MAKEFILE)\n\t\$(NOECHO) \$(PERL) -e 1 >${tmpdir}Writemain.tmp\n";
d2150 1
a2150 1
	push @@m,'	$(NOECHO) $(PERL) -e "print q{',$_,qq[}" >>${tmpdir}Writemain.tmp\n];
d2152 3
a2154 5

    push @@m, sprintf <<'MAKE_FRAG', $tmpdir, $tmpdir;
	$(NOECHO) $(PERL) $(MAP_PERLINC) -ane "use ExtUtils::Miniperl; writemain(@@F)" %sWritemain.tmp >$(MMS$TARGET)
	$(NOECHO) $(RM_F) %sWritemain.tmp
MAKE_FRAG
d2159 6
a2164 7
	$(NOECHO) $(MKPATH) $(DESTINSTALLARCHLIB)
	$(NOECHO) $(ECHO) "Perl binary $(MAP_TARGET)|" >.MM_tmp
	$(NOECHO) $(ECHO) "MAP_STATIC|$(MAP_STATIC)|" >>.MM_tmp
	$(NOECHO) $(PERL) -pl040 -e " " ].$self->catfile('$(INST_ARCHAUTODIR)','extralibs.all'),q[ >>.MM_tmp
	$(NOECHO) $(ECHO) -e "MAP_LIBPERL|$(MAP_LIBPERL)|" >>.MM_tmp
	$(NOECHO) $(DOC_INSTALL) <.MM_tmp >>].$self->catfile('$(DESTINSTALLARCHLIB)','perllocal.pod').q[
	$(NOECHO) $(RM_F) .MM_tmp
d2179 2
a2180 2
	\$(RM_F) ${tmpdir}perlmain\$(OBJ_EXT) ${tmpdir}perlmain.c \$(FIRST_MAKEFILE)
	\$(RM_F) ${tmpdir}Makeaperl.Opt ${tmpdir}PerlShr.Opt \$(MAP_TARGET)
a2221 6

    # Translate $(PERLPREFIX) to a real path.
    $rprefix = $self->eliminate_macros($rprefix);
    $rprefix = VMS::Filespec::vmspath($rprefix) if $rprefix;
    $sprefix = VMS::Filespec::vmspath($sprefix) if $sprefix;

d2226 2
a2227 3
    my $path = $self->{uc $var} || 
               $ExtUtils::MM_Unix::Config_Override{lc $var} || 
               $Config{lc $var} || $Config{lc $var_no_install};
d2241 1
a2241 1
        my($path_vol, $path_dirs) = $self->splitpath( $path );
d2278 1
a2278 1
    my($rvol, $rdirs) = $self->splitpath($rprefix);
d2280 2
a2281 2
        return $self->catpath($rvol,
                                   $self->catdir($rdirs, $default),
d2286 1
a2286 101
        return $self->catdir($rdirs, $default);
    }
}


=item oneliner (o)

=cut

sub oneliner {
    my($self, $cmd, $switches) = @@_;
    $switches = [] unless defined $switches;

    # Strip leading and trailing newlines
    $cmd =~ s{^\n+}{};
    $cmd =~ s{\n+$}{};

    $cmd = $self->quote_literal($cmd);
    $cmd = $self->escape_newlines($cmd);

    # Switches must be quoted else they will be lowercased.
    $switches = join ' ', map { qq{"$_"} } @@$switches;

    return qq{\$(PERLRUN) $switches -e $cmd};
}


=item B<echo> (o)

perl trips up on "<foo>" thinking it's an input redirect.  So we use the
native Write command instead.  Besides, its faster.

=cut

sub echo {
    my($self, $text, $file, $appending) = @@_;
    $appending ||= 0;

    my $opencmd = $appending ? 'Open/Append' : 'Open/Write';

    my @@cmds = ("\$(NOECHO) $opencmd MMECHOFILE $file ");
    push @@cmds, map { '$(NOECHO) Write MMECHOFILE '.$self->quote_literal($_) } 
                split /\n/, $text;
    push @@cmds, '$(NOECHO) Close MMECHOFILE';
    return @@cmds;
}


=item quote_literal

=cut

sub quote_literal {
    my($self, $text) = @@_;

    # I believe this is all we should need.
    $text =~ s{"}{""}g;

    return qq{"$text"};
}

=item escape_newlines

=cut

sub escape_newlines {
    my($self, $text) = @@_;

    $text =~ s{\n}{-\n}g;

    return $text;
}

=item max_exec_len

256 characters.

=cut

sub max_exec_len {
    my $self = shift;

    return $self->{_MAX_EXEC_LEN} ||= 256;
}

=item init_linker (o)

=cut

sub init_linker {
    my $self = shift;
    $self->{EXPORT_LIST} ||= '$(BASEEXT).opt';

    my $shr = $Config{dbgprefix} . 'PERLSHR';
    if ($self->{PERL_SRC}) {
        $self->{PERL_ARCHIVE} ||=
          $self->catfile($self->{PERL_SRC}, "$shr.$Config{'dlext'}");
    }
    else {
        $self->{PERL_ARCHIVE} ||=
          $ENV{$shr} ? $ENV{$shr} : "Sys\$Share:$shr.$Config{'dlext'}";
a2287 2

    $self->{PERL_ARCHIVE_AFTER} ||= '';
a2289 126
=item eliminate_macros

Expands MM[KS]/Make macros in a text string, using the contents of
identically named elements of C<%$self>, and returns the result
as a file specification in Unix syntax.

NOTE:  This is the canonical version of the method.  The version in
File::Spec::VMS is deprecated.

=cut

sub eliminate_macros {
    my($self,$path) = @@_;
    return '' unless $path;
    $self = {} unless ref $self;

    if ($path =~ /\s/) {
      return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
    }

    my($npath) = unixify($path);
    # sometimes unixify will return a string with an off-by-one trailing null
    $npath =~ s{\0$}{};

    my($complex) = 0;
    my($head,$macro,$tail);

    # perform m##g in scalar context so it acts as an iterator
    while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
        if (defined $self->{$2}) {
            ($head,$macro,$tail) = ($1,$2,$3);
            if (ref $self->{$macro}) {
                if (ref $self->{$macro} eq 'ARRAY') {
                    $macro = join ' ', @@{$self->{$macro}};
                }
                else {
                    print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                          "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                    $macro = "\cB$macro\cB";
                    $complex = 1;
                }
            }
            else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
            $npath = "$head$macro$tail";
        }
    }
    if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
    $npath;
}

=item fixpath

Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
in any directory specification, in order to avoid juxtaposing two
VMS-syntax directories when MM[SK] is run.  Also expands expressions which
are all macro, so that we can tell how long the expansion is, and avoid
overrunning DCL's command buffer when MM[KS] is running.

If optional second argument has a TRUE value, then the return string is
a VMS-syntax directory specification, if it is FALSE, the return string
is a VMS-syntax file specification, and if it is not specified, fixpath()
checks to see whether it matches the name of a directory in the current
default directory, and returns a directory or file specification accordingly.

NOTE:  This is the canonical version of the method.  The version in
File::Spec::VMS is deprecated.

=cut

sub fixpath {
    my($self,$path,$force_path) = @@_;
    return '' unless $path;
    $self = bless {} unless ref $self;
    my($fixedpath,$prefix,$name);

    if ($path =~ /\s/) {
      return join ' ',
             map { $self->fixpath($_,$force_path) }
	     split /\s+/, $path;
    }

    if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
        if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
            $fixedpath = vmspath($self->eliminate_macros($path));
        }
        else {
            $fixedpath = vmsify($self->eliminate_macros($path));
        }
    }
    elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
        my($vmspre) = $self->eliminate_macros("\$($prefix)");
        # is it a dir or just a name?
        $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
        $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    else {
        $fixedpath = $path;
        $fixedpath = vmspath($fixedpath) if $force_path;
    }
    # No hints, so we try to guess
    if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
        $fixedpath = vmspath($fixedpath) if -d $fixedpath;
    }

    # Trim off root dirname if it's had other dirs inserted in front of it.
    $fixedpath =~ s/\.000000([\]>])/$1/;
    # Special case for VMS absolute directory specs: these will have had device
    # prepended during trip through Unix syntax in eliminate_macros(), since
    # Unix syntax has no way to express "absolute from the top of this device's
    # directory tree".
    if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }

    return $fixedpath;
}


=item os_flavor

VMS is VMS.

=cut

sub os_flavor {
    return('VMS');
}
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d24 1
a24 1
($Revision) = q$Revision: 1.7 $ =~ /Revision:\s+(\S+)/;
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d24 1
a24 1
($Revision) = q$Revision: 1.110 $ =~ /Revision:\s+(\S+)/;
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d1 5
d10 1
a10 1
use ExtUtils::MakeMaker::Config;
d22 3
a24 5

# $Revision can't be on the same line or SVN/K gets confused
use vars qw($Revision
            $VERSION @@ISA);
$VERSION = '5.73';
a30 1
$Revision = $ExtUtils::MakeMaker::Revision;
a283 45

=item pasthru (override)

VMS has $(MMSQUALIFIERS) which is a listing of all the original command line
options.  This is used in every invokation of make in the VMS Makefile so
PASTHRU should not be necessary.  Using PASTHRU tends to blow commands past
the 256 character limit.

=cut

sub pasthru {
    return "PASTHRU=\n";
}


=item pm_to_blib (override)

VMS wants a dot in every file so we can't have one called 'pm_to_blib',
it becomes 'pm_to_blib.' and MMS/K isn't smart enough to know that when
you have a target called 'pm_to_blib' it should look for 'pm_to_blib.'.

So in VMS its pm_to_blib.ts.

=cut

sub pm_to_blib {
    my $self = shift;

    my $make = $self->SUPER::pm_to_blib;

    $make =~ s{^pm_to_blib :}{pm_to_blib.ts :}m;
    $make =~ s{\$\(TOUCH\) pm_to_blib}{\$(TOUCH) pm_to_blib.ts};

    $make = <<'MAKE' . $make;
# Dummy target to match Unix target name; we use pm_to_blib.ts as
# timestamp file to avoid repeated invocations under VMS
pm_to_blib : pm_to_blib.ts
	$(NOECHO) $(NOOP)

MAKE

    return $make;
}


a299 1

d411 8
a418 12
    $self->{MACROSTART}         ||= '/Macro=(';
    $self->{MACROEND}           ||= ')';
    $self->{USEMAKEFILE}        ||= '/Descrip=';

    $self->{ECHO}     ||= '$(ABSPERLRUN) -le "print qq{@@ARGV}"';
    $self->{ECHO_N}   ||= '$(ABSPERLRUN) -e  "print qq{@@ARGV}"';
    $self->{TOUCH}    ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e touch';
    $self->{CHMOD}    ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e chmod'; 
    $self->{RM_F}     ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e rm_f';
    $self->{RM_RF}    ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e rm_rf';
    $self->{TEST_F}   ||= '$(ABSPERLRUN) "-MExtUtils::Command" -e test_f';
    $self->{EQUALIZE_TIMESTAMP} ||= '$(ABSPERLRUN) -we "open F,qq{>>$ARGV[1]};close F;utime(0,(stat($ARGV[0]))[9]+1,$ARGV[1])"';
d427 2
a428 6
    $self->SUPER::init_others;

    # So we can copy files into directories with less fuss
    $self->{CP}         = '$(ABSPERLRUN) "-MExtUtils::Command" -e cp';
    $self->{MV}         = '$(ABSPERLRUN) "-MExtUtils::Command" -e mv';

d431 1
a431 4
    # Redirection on VMS goes before the command, not after as on Unix.
    # $(DEV_NULL) is used once and its not worth going nuts over making
    # it work.  However, Unix's DEV_NULL is quite wrong for VMS.
    $self->{DEV_NULL}   = '';
a565 3
    # mms/k does not define a $(MAKE) macro.
    $self->{MAKE} = '$(MMS)$(MMSQUALIFIERS)';

d727 56
d798 7
a805 1
USEMACROS = $(MACROSTART)
d883 1
a883 1
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET)
d898 1
a898 1
	$(XSUBPPRUN) $(XSPROTOARG) $(XSUBPPARGS) $(MMS$TARGET_NAME).xs >$(MMS$TARGET_NAME).c
d1009 2
a1010 1
$(INST_DYNAMIC) : $(INST_STATIC) $(PERL_INC)perlshr_attr.opt $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
d1015 1
d1019 28
d1066 1
a1066 1
$(OBJECT) : $(INST_ARCHAUTODIR)$(DFSEP).exists
d1080 1
a1080 1
      push(@@m,"\t",'Library/Object/Replace $(MMS$TARGET) $(OBJECT)',"\n");
d1089 112
d1204 58
d1263 1
a1263 1
=item extra_clean_files
d1265 3
a1267 2
Clean up some OS specific files.  Plus the temp file used to shorten
a lot of commands.
d1271 21
a1291 5
sub extra_clean_files {
    return qw(
              *.Map *.Dmp *.Lis *.cpp *.$(DLEXT) *.Opt $(BASEEXT).bso
              .MM_Tmp
             );
d1295 1
a1295 1
=item zipfile_target
d1297 1
a1297 1
=item tarfile_target
d1299 72
a1370 1
=item shdist_target
d1414 19
d1445 13
a1457 1
    my(@@m);
d1527 2
a1528 1
	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
d1537 2
a1538 1
	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
d1546 2
a1547 1
	$(NOECHO) $(DOC_INSTALL) "Module" "$(NAME)" <.MM_tmp >>].$self->catfile($self->{DESTINSTALLARCHLIB},'perllocal.pod').q[
d1641 102
d1780 1
a1780 1
	$(MAKE)$(USEMAKEFILE)$(MAKE_APERL_FILE) static $(MMS$TARGET)
d1948 1
a1948 1
	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) inst_perl $(USEMACROS)MAP_TARGET=$(MAP_TARGET)$(ENDMACRO)"
d1950 1
a1950 1
	$(NOECHO) $(ECHO) "    $(MAKE)$(USEMAKEFILE)$(FIRST_MAKEFILE) map_clean"
a2047 3
    elsif( !$self->{ARGS}{PREFIX} || !$self->file_name_is_absolute($path) ) {
        # do nothing if there's no prefix or if its relative
    }
d2106 1
a2106 27
=item cd

=cut

sub cd {
    my($self, $dir, @@cmds) = @@_;

    $dir = vmspath($dir);

    my $cmd = join "\n\t", map "$_", @@cmds;

    # No leading tab makes it look right when embedded
    my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd;
startdir = F$Environment("Default")
	Set Default %s
	%s
	Set Default 'startdir'
MAKE_FRAG

    # No trailing newline makes this easier to embed
    chomp $make_frag;

    return $make_frag;
}


=item oneliner
d2124 1
a2124 1
    return qq{\$(ABSPERLRUN) $switches -e $cmd};
d2128 1
a2128 1
=item B<echo>
d2186 1
a2186 1
=item init_linker
a2258 3
   my $path = $mm->fixpath($path);
   my $path = $mm->fixpath($path, $is_dir);

d2265 5
a2269 5
fixpath() checks to see whether the result matches the name of a
directory in the current default directory and returns a directory or
file specification accordingly.  C<$is_dir> can be set to true to
force fixpath() to consider the path to be a directory or false to force
it to be a file.
d2282 1
a2282 1
    if ($path =~ /[ \t]/) {
d2285 1
a2285 1
	     split /[ \t]+/, $path;
a2334 10


=head1 AUTHOR

Original author Charles Bailey F<bailey@@newman.upenn.edu>

Maintained by Michael G Schwern F<schwern@@pobox.com>

See L<ExtUtils::MakeMaker> for patching and contact information.

@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d21 1
a21 1
$VERSION = '6.42';
d286 1
a286 1
options.  This is used in every invocation of make in the VMS Makefile so
d450 1
a450 1
    $self->{MAKEFILE}		||= $self->{FIRST_MAKEFILE} || 'Descrip.MMS';
d453 1
a453 11
    $self->{MAKEFILE_OLD}       ||= $self->eliminate_macros('$(FIRST_MAKEFILE)_old');
#
#   If an extension is not specified, then MMS/MMK assumes an
#   an extension of .MMS.  If there really is no extension,
#   then a trailing "." needs to be appended to specify a
#   a null extension.
#
    $self->{MAKEFILE} .= '.' unless $self->{MAKEFILE} =~ m/\./;
    $self->{FIRST_MAKEFILE} .= '.' unless $self->{FIRST_MAKEFILE} =~ m/\./;
    $self->{MAKE_APERL_FILE} .= '.' unless $self->{MAKE_APERL_FILE} =~ m/\./;
    $self->{MAKEFILE_OLD} .= '.' unless $self->{MAKEFILE_OLD} =~ m/\./;
d1272 2
a1273 1
$(OBJECT) : $(PERL_INC)thread.h, $(PERL_INC)util.h, $(PERL_INC)vmsish.h
d1565 1
a1565 1

d1568 1
a1568 1
=item maketext_filter (override)
d1576 5
a1580 5
sub maketext_filter {
    my($self, $text) = @@_;

    $text =~ s/^([^\s:=]+)(:+\s)/$1 $2/mg;
    return $text;
d1725 1
a1725 1
    return qq{\$(ABSPERLRUN) $switches -e $cmd "--"};
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d18 4
a21 1
our $VERSION = '6.55_02';
d25 1
a25 1
our @@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
d28 1
a28 1
our $Revision = $ExtUtils::MakeMaker::Revision;
d110 1
a110 1
    my($defname,$defpm,@@pm,%xs);
d121 1
a121 2
      @@pm = glob('*.pm');
      s/.pm$// for @@pm;
d124 1
a124 1
        %xs = map { s/.xs$//; ($_,1) } glob('*.xs');  ## no critic
d126 1
a126 1
            foreach my $pm (@@pm) { 
d132 2
a133 2
    if (open(my $pm, '<', "${defpm}.pm")){
        while (<$pm>) {
d141 2
a142 2
            if eof($pm);
        close $pm;
d161 1
a161 1
    my($vmsfile,@@sdirs,@@snames,@@cand);
d193 1
a193 1
    s/\.(\d+)$/_$1/ for @@snames;
d195 19
a213 22
        print "Looking for perl $ver by these names:\n";
        print "\t@@snames,\n";
        print "in these dirs:\n";
        print "\t@@sdirs\n";
    }
    foreach my $dir (@@sdirs){
        next unless defined $dir; # $self->{PERL_SRC} may be undefined
        $inabs++ if $self->file_name_is_absolute($dir);
        if ($inabs == 1) {
            # We've covered relative dirs; everything else is an absolute
            # dir (probably an installed location).  First, we'll try 
            # potential command names, to see whether we can avoid a long 
            # MCR expression.
            foreach my $name (@@snames) {
                push(@@cand,$name) if $name =~ /^[\w\-\$]+$/;
            }
            $inabs++; # Should happen above in next $dir, but just in case...
        }
        foreach my $name (@@snames){
            push @@cand, ($name !~ m![/:>\]]!) ? $self->catfile($dir,$name)
                                              : $self->fixpath($name,0);
        }
d215 3
a217 3
    foreach my $name (@@cand) {
        print "Checking $name\n" if $trace >= 2;
        # If it looks like a potential command, try it without the MCR
d219 4
a222 5
            open(my $tcf, ">", "temp_mmvms.com") 
                or die('unable to open temp file');
            print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
            print $tcf "\$ $name -e \"require $ver; print \"\"VER_OK\\n\"\"\"\n";
            close $tcf;
d230 7
a236 8
        next unless $vmsfile = $self->maybe_command($name);
        $vmsfile =~ s/;[\d\-]*$//;  # Clip off version number; we can use a newer version as well
        print "Executing $vmsfile\n" if ($trace >= 2);
        open(my $tcf, '>', "temp_mmvms.com")
                or die('unable to open temp file');
        print $tcf "\$ set message/nofacil/nosever/noident/notext\n";
        print $tcf "\$ mcr $vmsfile -e \"require $ver; print \"\"VER_OK\\n\"\"\" \n";
        close $tcf;
d240 3
a242 3
            print "Using PERL=MCR $vmsfile\n" if $trace;
            return "MCR $vmsfile";
        }
d264 1
a264 1

d266 12
a277 12
        for (my $i = 0; defined $ENV{"DCL\$PATH;$i"}; $i++) {
            my $dir = $ENV{"DCL\$PATH;$i"};
            $dir .= ':' unless $dir =~ m%[\]:]$%;
            push(@@dirs,$dir);
        }
        push(@@dirs,'Sys$System:');
        foreach my $dir (@@dirs) {
            my $sysfile = "$dir$file";
            foreach my $ext (@@exts) {
                return $file if -x "$sysfile$ext" && ! -d _;
            }
        }
d372 1
a372 1
        $self->{$destvar} = $self->eliminate_macros($self->{$destvar});
d450 1
a450 1
    $self->{MAKEFILE}           ||= $self->{FIRST_MAKEFILE} || 'Descrip.MMS';
d469 7
d480 1
a480 1
install([ from_to => {split(' ', <STDIN>)}, verbose => '$(VERBINST)', uninstall_shadows => '$(UNINST)', dir_mode => '$(PERM_DIR)' ]);
d483 2
d487 3
a489 1
    $self->{SHELL}    ||= 'Posix';
d852 1
a852 4
    $self->{DISTVNAME} = "$self->{DISTNAME}-$self->{VERSION_SYM}"
      unless $self->{ARGS}{DISTVNAME};

    return;
d957 15
a971 18
        # Upcase module names if linker is being case-sensitive
        my($upcase) = $Config{d_vms_case_sensitive_symbols};
        my(@@omods) = split ' ', $self->eliminate_macros($self->{OBJECT});
        for (@@omods) {
            s/\.[^.]*$//;         # Trim off file type
            s[\$\(\w+_EXT\)][];   # even as a macro
            s/.*[:>\/\]]//;       # Trim off dir spec
            $_ = uc if $upcase;
        };

        my(@@lines);
        my $tmp = shift @@omods;
        foreach my $elt (@@omods) {
            $tmp .= ",$elt";
            if (length($tmp) > 80) { push @@lines, $tmp;  $tmp = ''; }
        }
        push @@lines, $tmp;
        push @@m, '(', join( qq[, -\\n\\t"";" >>\$(MMS\$TARGET)\n\t\$(PERL) -e "print ""], @@lines),')';
d973 1
a973 1
    push @@m, '\n$(INST_STATIC)/Library\n"";" >>$(MMS$TARGET)',"\n";
d976 10
a985 10
        my($line) = '';
        foreach my $lib (split ' ', $self->{LDLOADLIBS}) {
            $lib =~ s%\$%\\\$%g;  # Escape '$' in VMS filespecs
            if (length($line) + length($lib) > 160) {
                push @@m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n";
                $line = $lib . '\n';
            }
            else { $line .= $lib . '\n'; }
        }
        push @@m, "\t\$(PERL) -e \"print qq{$line}\" >>\$(MMS\$TARGET)\n" if $line;
d1039 1
a1039 1
    my(@@m);
d1062 1
a1062 1
    foreach my $lib (split ' ', $self->{EXTRALIBS}) {
d1334 1
a1334 1
our %olbs;  # needs to be localized
d1387 2
d1390 1
a1390 1
		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
d1396 1
a1396 1
		foreach my $incl ((@@{$self->{INCLUDE_EXT}},'DynaLoader')){
d1405 4
a1408 1
		(my $xx = $File::Find::name) =~ s,.*?/auto/,,;
d1413 1
a1413 1
		foreach my $excl (@@{$self->{EXCLUDE_EXT}}){
d1443 2
a1444 2
	    open my $list, "<", $extralibs or warn $!,next;
	    while (<$list>) {
d1455 1
d1459 2
a1460 2
	    open my $opt, '<', $extopt or die $!;
	    while (<$opt>) {
a1574 1

d1614 2
a1615 2
    $rprefix = vmspath($rprefix) if $rprefix;
    $sprefix = vmspath($sprefix) if $sprefix;
d1617 1
a1617 1
    $default = vmsify($default) 
a1816 39

=item catdir (override)

=item catfile (override)

Eliminate the macros in the output to the MMS/MMK file.

(File::Spec::VMS used to do this for us, but it's being removed)

=cut

sub catdir {
    my $self = shift;

    # Process the macros on VMS MMS/MMK
    my @@args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @@_;

    my $dir = $self->SUPER::catdir(@@args);

    # Fix up the directory and force it to VMS format.
    $dir = $self->fixpath($dir, 1);

    return $dir;
}

sub catfile {
    my $self = shift;

    # Process the macros on VMS MMS/MMK
    my @@args = map { m{\$\(} ? $self->eliminate_macros($_) : $_  } @@_;

    my $file = $self->SUPER::catfile(@@args);

    $file = vmsify($file);

    return $file
}


d1892 1
a1892 1
    $self = bless {}, $self unless ref $self;
@


