head	1.10;
access;
symbols
	OPENBSD_4_8:1.9.0.8
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.4
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2010.09.24.14.59.38;	author millert;	state dead;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.11;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.31;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.33;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.34;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.42;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.42;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.08;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.43;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.29;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.03;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.44;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.33;	author millert;	state Exp;
branches;
next	;


desc
@@


1.10
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!./miniperl

require 5.002;
use ExtUtils::ParseXS qw(process_file);
use Getopt::Long;

my %args = ();

my $usage = "Usage: xsubpp [-v] [-csuffix csuffix] [-except] [-prototypes] [-noversioncheck] [-nolinenumbers] [-nooptimize] [-noinout] [-noargtypes] [-s pattern] [-typemap typemap]... file.xs\n";

Getopt::Long::Configure qw(no_auto_abbrev no_ignore_case);

@@ARGV = grep {$_ ne '-C++'} @@ARGV;  # Allow -C++ for backward compatibility
GetOptions(\%args, qw(hiertype!
		      prototypes!
		      versioncheck!
		      linenumbers!
		      optimize!
		      inout!
		      argtypes!
		      object_capi!
		      except!
		      v
		      typemap=s@@
		      output=s
		      s=s
		      csuffix=s
		     ))
  or die $usage;

if ($args{v}) {
  print "xsubpp version $ExtUtils::ParseXS::VERSION\n";
  exit;
}

@@ARGV == 1 or die $usage;

$args{filename} = shift @@ARGV;

process_file(%args);
exit( ExtUtils::ParseXS::errors() ? 1 : 0 );

__END__

=head1 NAME

xsubpp - compiler to convert Perl XS code into C code

=head1 SYNOPSIS

B<xsubpp> [B<-v>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-nolinenumbers>] [B<-nooptimize>] [B<-typemap typemap>] [B<-output filename>]... file.xs

=head1 DESCRIPTION

This compiler is typically run by the makefiles created by L<ExtUtils::MakeMaker>.

I<xsubpp> will compile XS code into C code by embedding the constructs
necessary to let C functions manipulate Perl values and creates the glue
necessary to let Perl access those functions.  The compiler uses typemaps to
determine how to map C function parameters and variables to Perl values.

The compiler will search for typemap files called I<typemap>.  It will use
the following search path to find default typemaps, with the rightmost
typemap taking precedence.

	../../../typemap:../../typemap:../typemap:typemap

It will also use a default typemap installed as C<ExtUtils::typemap>.

=head1 OPTIONS

Note that the C<XSOPT> MakeMaker option may be used to add these options to
any makefiles generated by MakeMaker.

=over 5

=item B<-hiertype>

Retains '::' in type names so that C++ hierarchical types can be mapped.

=item B<-except>

Adds exception handling stubs to the C code.

=item B<-typemap typemap>

Indicates that a user-supplied typemap should take precedence over the
default typemaps.  This option may be used multiple times, with the last
typemap having the highest precedence.

=item B<-output filename>

Specifies the name of the output file to generate.  If no file is
specified, output will be written to standard output.

=item B<-v>

Prints the I<xsubpp> version number to standard output, then exits.

=item B<-prototypes>

By default I<xsubpp> will not automatically generate prototype code for
all xsubs. This flag will enable prototypes.

=item B<-noversioncheck>

Disables the run time test that determines if the object file (derived
from the C<.xs> file) and the C<.pm> files have the same version
number.

=item B<-nolinenumbers>

Prevents the inclusion of `#line' directives in the output.

=item B<-nooptimize>

Disables certain optimizations.  The only optimization that is currently
affected is the use of I<target>s by the output C code (see L<perlguts>).
This may significantly slow down the generated code, but this is the way
B<xsubpp> of 5.005 and earlier operated.

=item B<-noinout>

Disable recognition of C<IN>, C<OUT_LIST> and C<INOUT_LIST> declarations.

=item B<-noargtypes>

Disable recognition of ANSI-like descriptions of function signature.

=item B<-C++>

Currently doesn't do anything at all.  This flag has been a no-op for
many versions of perl, at least as far back as perl5.003_07.  It's
allowed here for backwards compatibility.

=back

=head1 ENVIRONMENT

No environment variables are used.

=head1 AUTHOR

Originally by Larry Wall.  Turned into the C<ExtUtils::ParseXS> module
by Ken Williams.

=head1 MODIFICATION HISTORY

See the file F<Changes>.

=head1 SEE ALSO

perl(1), perlxs(1), perlxstut(1), ExtUtils::ParseXS

=cut

@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.8
log
@merge in perl 5.8.8
@
text
@d3 42
d51 1
a51 1
B<xsubpp> [B<-v>] [B<-C++>] [B<-csuffix csuffix>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-nolinenumbers>] [B<-nooptimize>] [B<-typemap typemap>] ... file.xs
d68 2
a76 10
=item B<-C++>

Adds ``extern "C"'' to the C code.

=item B<-csuffix csuffix>

Set the suffix used for the generated C or C++ code.  Defaults to '.c'
(even with B<-C++>), but some platforms might want to have e.g. '.cpp'.
Don't forget the '.' from the front.

d79 1
a79 1
Retains '::' in type names so that C++ hierachical types can be mapped.
d91 5
d130 6
d144 2
a145 1
Larry Wall
d149 1
a149 1
See the file F<changes.pod>.
d153 1
a153 1
perl(1), perlxs(1), perlxstut(1)
a156 1798
require 5.002;
use Cwd;
use vars qw($cplusplus $hiertype);
use vars '%v';

use Config;

sub Q ;

# Global Constants

$XSUBPP_version = "1.9508";

my ($Is_VMS, $SymSet);
if ($^O eq 'VMS') {
    $Is_VMS = 1;
    # Establish set of global symbols with max length 28, since xsubpp
    # will later add the 'XS_' prefix.
    require ExtUtils::XSSymSet;
    $SymSet = new ExtUtils::XSSymSet 28;
}

$FH = 'File0000' ;

$usage = "Usage: xsubpp [-v] [-C++] [-csuffix csuffix] [-except] [-prototypes] [-noversioncheck] [-nolinenumbers] [-nooptimize] [-noinout] [-noargtypes] [-s pattern] [-typemap typemap]... file.xs\n";

$proto_re = "[" . quotemeta('\$%&*@@;[]') . "]" ;

$except = "";
$WantPrototypes = -1 ;
$WantVersionChk = 1 ;
$ProtoUsed = 0 ;
$WantLineNumbers = 1 ;
$WantOptimize = 1 ;
$Overload = 0;
$Fallback = 'PL_sv_undef';

my $process_inout = 1;
my $process_argtypes = 1;
my $csuffix = '.c';

SWITCH: while (@@ARGV and $ARGV[0] =~ /^-./) {
    $flag = shift @@ARGV;
    $flag =~ s/^-// ;
    $spat = quotemeta shift,	next SWITCH	if $flag eq 's';
    $cplusplus = 1,	next SWITCH	if $flag eq 'C++';
    $csuffix   = shift,	next SWITCH	if $flag eq 'csuffix';
    $hiertype  = 1,	next SWITCH	if $flag eq 'hiertype';
    $WantPrototypes = 0, next SWITCH	if $flag eq 'noprototypes';
    $WantPrototypes = 1, next SWITCH	if $flag eq 'prototypes';
    $WantVersionChk = 0, next SWITCH	if $flag eq 'noversioncheck';
    $WantVersionChk = 1, next SWITCH	if $flag eq 'versioncheck';
    # XXX left this in for compat
    next SWITCH                         if $flag eq 'object_capi';
    $except = " TRY",	next SWITCH	if $flag eq 'except';
    push(@@tm,shift),	next SWITCH	if $flag eq 'typemap';
    $WantLineNumbers = 0, next SWITCH	if $flag eq 'nolinenumbers';
    $WantLineNumbers = 1, next SWITCH	if $flag eq 'linenumbers';
    $WantOptimize = 0, next SWITCH	if $flag eq 'nooptimize';
    $WantOptimize = 1, next SWITCH	if $flag eq 'optimize';
    $process_inout = 0, next SWITCH	if $flag eq 'noinout';
    $process_inout = 1, next SWITCH	if $flag eq 'inout';
    $process_argtypes = 0, next SWITCH	if $flag eq 'noargtypes';
    $process_argtypes = 1, next SWITCH	if $flag eq 'argtypes';
    (print "xsubpp version $XSUBPP_version\n"), exit
	if $flag eq 'v';
    die $usage;
}
if ($WantPrototypes == -1)
  { $WantPrototypes = 0}
else
  { $ProtoUsed = 1 }


@@ARGV == 1 or die $usage;
($dir, $filename) = $ARGV[0] =~ m#(.*)/(.*)#
	or ($dir, $filename) = $ARGV[0] =~ m#(.*)\\(.*)#
	or ($dir, $filename) = $ARGV[0] =~ m#(.*[>\]])(.*)#
	or ($dir, $filename) = ('.', $ARGV[0]);
chdir($dir);
$pwd = cwd();

++ $IncludedFiles{$ARGV[0]} ;

my(@@XSStack) = ({type => 'none'});	# Stack of conditionals and INCLUDEs
my($XSS_work_idx, $cpp_next_tmp) = (0, "XSubPPtmpAAAA");


sub TrimWhitespace
{
    $_[0] =~ s/^\s+|\s+$//go ;
}

sub TidyType
{
    local ($_) = @@_ ;

    # rationalise any '*' by joining them into bunches and removing whitespace
    s#\s*(\*+)\s*#$1#g;
    s#(\*+)# $1 #g ;

    # change multiple whitespace into a single space
    s/\s+/ /g ;

    # trim leading & trailing whitespace
    TrimWhitespace($_) ;

    $_ ;
}

$typemap = shift @@ARGV;
foreach $typemap (@@tm) {
    die "Can't find $typemap in $pwd\n" unless -r $typemap;
}
unshift @@tm, qw(../../../../lib/ExtUtils/typemap ../../../lib/ExtUtils/typemap
                ../../lib/ExtUtils/typemap ../../../typemap ../../typemap
                ../typemap typemap);
foreach $typemap (@@tm) {
    next unless -f $typemap ;
    # skip directories, binary files etc.
    warn("Warning: ignoring non-text typemap file '$typemap'\n"), next
	unless -T $typemap ;
    open(TYPEMAP, $typemap)
	or warn ("Warning: could not open typemap file '$typemap': $!\n"), next;
    $mode = 'Typemap';
    $junk = "" ;
    $current = \$junk;
    while (<TYPEMAP>) {
	next if /^\s*#/;
        my $line_no = $. + 1;
	if (/^INPUT\s*$/)   { $mode = 'Input';   $current = \$junk;  next; }
	if (/^OUTPUT\s*$/)  { $mode = 'Output';  $current = \$junk;  next; }
	if (/^TYPEMAP\s*$/) { $mode = 'Typemap'; $current = \$junk;  next; }
	if ($mode eq 'Typemap') {
	    chomp;
	    my $line = $_ ;
            TrimWhitespace($_) ;
	    # skip blank lines and comment lines
	    next if /^$/ or /^#/ ;
	    my($type,$kind, $proto) = /^\s*(.*?\S)\s+(\S+)\s*($proto_re*)\s*$/ or
		warn("Warning: File '$typemap' Line $. '$line' TYPEMAP entry needs 2 or 3 columns\n"), next;
            $type = TidyType($type) ;
	    $type_kind{$type} = $kind ;
            # prototype defaults to '$'
            $proto = "\$" unless $proto ;
            warn("Warning: File '$typemap' Line $. '$line' Invalid prototype '$proto'\n")
                unless ValidProtoString($proto) ;
            $proto_letter{$type} = C_string($proto) ;
	}
	elsif (/^\s/) {
	    $$current .= $_;
	}
	elsif ($mode eq 'Input') {
	    s/\s+$//;
	    $input_expr{$_} = '';
	    $current = \$input_expr{$_};
	}
	else {
	    s/\s+$//;
	    $output_expr{$_} = '';
	    $current = \$output_expr{$_};
	}
    }
    close(TYPEMAP);
}

foreach $key (keys %input_expr) {
    $input_expr{$key} =~ s/;*\s+\z//;
}

$bal = qr[(?:(?>[^()]+)|\((??{ $bal })\))*];	# ()-balanced
$cast = qr[(?:\(\s*SV\s*\*\s*\)\s*)?];		# Optional (SV*) cast
$size = qr[,\s* (??{ $bal }) ]x;		# Third arg (to setpvn)

foreach $key (keys %output_expr) {
    use re 'eval';

    my ($t, $with_size, $arg, $sarg) =
      ($output_expr{$key} =~
	 m[^ \s+ sv_set ( [iunp] ) v (n)? 	# Type, is_setpvn
	     \s* \( \s* $cast \$arg \s* ,
	     \s* ( (??{ $bal }) )		# Set from
	     ( (??{ $size }) )?			# Possible sizeof set-from
	     \) \s* ; \s* $
	  ]x);
    $targetable{$key} = [$t, $with_size, $arg, $sarg] if $t;
}

$END = "!End!\n\n";		# "impossible" keyword (multiple newline)

# Match an XS keyword
$BLOCK_re= '\s*(' . join('|', qw(
	REQUIRE BOOT CASE PREINIT INPUT INIT CODE PPCODE OUTPUT
	CLEANUP ALIAS ATTRS PROTOTYPES PROTOTYPE VERSIONCHECK INCLUDE
	SCOPE INTERFACE INTERFACE_MACRO C_ARGS POSTCALL OVERLOAD FALLBACK
	)) . "|$END)\\s*:";

# Input:  ($_, @@line) == unparsed input.
# Output: ($_, @@line) == (rest of line, following lines).
# Return: the matched keyword if found, otherwise 0
sub check_keyword {
	$_ = shift(@@line) while !/\S/ && @@line;
	s/^(\s*)($_[0])\s*:\s*(?:#.*)?/$1/s && $2;
}

my ($C_group_rex, $C_arg);
# Group in C (no support for comments or literals)
$C_group_rex = qr/ [({\[]
		   (?: (?> [^()\[\]{}]+ ) | (??{ $C_group_rex }) )*
		   [)}\]] /x ;
# Chunk in C without comma at toplevel (no comments):
$C_arg = qr/ (?: (?> [^()\[\]{},"']+ )
	     |   (??{ $C_group_rex })
	     |   " (?: (?> [^\\"]+ )
		   |   \\.
		   )* "		# String literal
	     |   ' (?: (?> [^\\']+ ) | \\. )* ' # Char literal
	     )* /xs;

if ($WantLineNumbers) {
    {
	package xsubpp::counter;
	sub TIEHANDLE {
	    my ($class, $cfile) = @@_;
	    my $buf = "";
	    $SECTION_END_MARKER = "#line --- \"$cfile\"";
	    $line_no = 1;
	    bless \$buf;
	}

	sub PRINT {
	    my $self = shift;
	    for (@@_) {
		$$self .= $_;
		while ($$self =~ s/^([^\n]*\n)//) {
		    my $line = $1;
		    ++ $line_no;
		    $line =~ s|^\#line\s+---(?=\s)|#line $line_no|;
		    print STDOUT $line;
		}
	    }
	}

	sub PRINTF {
	    my $self = shift;
	    my $fmt = shift;
	    $self->PRINT(sprintf($fmt, @@_));
	}

	sub DESTROY {
	    # Not necessary if we're careful to end with a "\n"
	    my $self = shift;
	    print STDOUT $$self;
	}
    }

    my $cfile = $filename;
    $cfile =~ s/\.xs$/$csuffix/i or $cfile .= $csuffix;
    tie(*PSEUDO_STDOUT, 'xsubpp::counter', $cfile);
    select PSEUDO_STDOUT;
}

sub print_section {
    # the "do" is required for right semantics
    do { $_ = shift(@@line) } while !/\S/ && @@line;

    print("#line ", $line_no[@@line_no - @@line -1], " \"$filename\"\n")
	if $WantLineNumbers && !/^\s*#\s*line\b/ && !/^#if XSubPPtmp/;
    for (;  defined($_) && !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	print "$_\n";
    }
    print "$xsubpp::counter::SECTION_END_MARKER\n" if $WantLineNumbers;
}

sub merge_section {
    my $in = '';

    while (!/\S/ && @@line) {
        $_ = shift(@@line);
    }

    for (;  defined($_) && !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	$in .= "$_\n";
    }
    chomp $in;
    return $in;
}

sub process_keyword($)
{
    my($pattern) = @@_ ;
    my $kwd ;

    &{"${kwd}_handler"}()
        while $kwd = check_keyword($pattern) ;
}

sub CASE_handler {
    blurt ("Error: `CASE:' after unconditional `CASE:'")
	if $condnum && $cond eq '';
    $cond = $_;
    TrimWhitespace($cond);
    print "   ", ($condnum++ ? " else" : ""), ($cond ? " if ($cond)\n" : "\n");
    $_ = '' ;
}

sub INPUT_handler {
    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	last if /^\s*NOT_IMPLEMENTED_YET/;
	next unless /\S/;	# skip blank lines

	TrimWhitespace($_) ;
	my $line = $_ ;

	# remove trailing semicolon if no initialisation
	s/\s*;$//g unless /[=;+].*\S/ ;

	# Process the length(foo) declarations
	if (s/^([^=]*)\blength\(\s*(\w+)\s*\)\s*$/$1 XSauto_length_of_$2=NO_INIT/x) {
	  print "\tSTRLEN\tSTRLEN_length_of_$2;\n";
	  $lengthof{$2} = $name;
	  # $islengthof{$name} = $1;
	  $deferred .= "\n\tXSauto_length_of_$2 = STRLEN_length_of_$2;";
	}

	# check for optional initialisation code
	my $var_init = '' ;
	$var_init = $1 if s/\s*([=;+].*)$//s ;
	$var_init =~ s/"/\\"/g;

	s/\s+/ /g;
	my ($var_type, $var_addr, $var_name) = /^(.*?[^&\s])\s*(\&?)\s*\b(\w+)$/s
	    or blurt("Error: invalid argument declaration '$line'"), next;

	# Check for duplicate definitions
	blurt ("Error: duplicate definition of argument '$var_name' ignored"), next
	    if $arg_list{$var_name}++
	      or defined $argtype_seen{$var_name} and not $processing_arg_with_types;

	$thisdone |= $var_name eq "THIS";
	$retvaldone |= $var_name eq "RETVAL";
	$var_types{$var_name} = $var_type;
	# XXXX This check is a safeguard against the unfinished conversion of
	# generate_init().  When generate_init() is fixed,
	# one can use 2-args map_type() unconditionally.
	if ($var_type =~ / \( \s* \* \s* \) /x) {
	  # Function pointers are not yet supported with &output_init!
	  print "\t" . &map_type($var_type, $var_name);
	  $name_printed = 1;
	} else {
	  print "\t" . &map_type($var_type);
	  $name_printed = 0;
	}
	$var_num = $args_match{$var_name};

        $proto_arg[$var_num] = ProtoString($var_type)
	    if $var_num ;
	$func_args =~ s/\b($var_name)\b/&$1/ if $var_addr;
	if ($var_init =~ /^[=;]\s*NO_INIT\s*;?\s*$/
	    or $in_out{$var_name} and $in_out{$var_name} =~ /^OUT/
	    and $var_init !~ /\S/) {
	  if ($name_printed) {
	    print ";\n";
	  } else {
	    print "\t$var_name;\n";
	  }
	} elsif ($var_init =~ /\S/) {
	    &output_init($var_type, $var_num, $var_name, $var_init, $name_printed);
	} elsif ($var_num) {
	    # generate initialization code
	    &generate_init($var_type, $var_num, $var_name, $name_printed);
	} else {
	    print ";\n";
	}
    }
}

sub OUTPUT_handler {
    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	next unless /\S/;
	if (/^\s*SETMAGIC\s*:\s*(ENABLE|DISABLE)\s*/) {
	    $DoSetMagic = ($1 eq "ENABLE" ? 1 : 0);
	    next;
	}
	my ($outarg, $outcode) = /^\s*(\S+)\s*(.*?)\s*$/s ;
	blurt ("Error: duplicate OUTPUT argument '$outarg' ignored"), next
	    if $outargs{$outarg} ++ ;
	if (!$gotRETVAL and $outarg eq 'RETVAL') {
	    # deal with RETVAL last
	    $RETVAL_code = $outcode ;
	    $gotRETVAL = 1 ;
	    next ;
	}
	blurt ("Error: OUTPUT $outarg not an argument"), next
	    unless defined($args_match{$outarg});
	blurt("Error: No input definition for OUTPUT argument '$outarg' - ignored"), next
	    unless defined $var_types{$outarg} ;
	$var_num = $args_match{$outarg};
	if ($outcode) {
	    print "\t$outcode\n";
	    print "\tSvSETMAGIC(ST(" , $var_num-1 , "));\n" if $DoSetMagic;
	} else {
	    &generate_output($var_types{$outarg}, $var_num, $outarg, $DoSetMagic);
	}
	delete $in_out{$outarg} 	# No need to auto-OUTPUT
	  if exists $in_out{$outarg} and $in_out{$outarg} =~ /OUT$/;
    }
}

sub C_ARGS_handler() {
    my $in = merge_section();

    TrimWhitespace($in);
    $func_args = $in;
}

sub INTERFACE_MACRO_handler() {
    my $in = merge_section();

    TrimWhitespace($in);
    if ($in =~ /\s/) {		# two
        ($interface_macro, $interface_macro_set) = split ' ', $in;
    } else {
        $interface_macro = $in;
	$interface_macro_set = 'UNKNOWN_CVT'; # catch later
    }
    $interface = 1;		# local
    $Interfaces = 1;		# global
}

sub INTERFACE_handler() {
    my $in = merge_section();

    TrimWhitespace($in);

    foreach (split /[\s,]+/, $in) {
        $Interfaces{$_} = $_;
    }
    print Q<<"EOF";
#	XSFUNCTION = $interface_macro($ret_type,cv,XSANY.any_dptr);
EOF
    $interface = 1;		# local
    $Interfaces = 1;		# global
}

sub CLEANUP_handler() { print_section() }
sub PREINIT_handler() { print_section() }
sub POSTCALL_handler() { print_section() }
sub INIT_handler()    { print_section() }

sub GetAliases
{
    my ($line) = @@_ ;
    my ($orig) = $line ;
    my ($alias) ;
    my ($value) ;

    # Parse alias definitions
    # format is
    #    alias = value alias = value ...

    while ($line =~ s/^\s*([\w:]+)\s*=\s*(\w+)\s*//) {
        $alias = $1 ;
        $orig_alias = $alias ;
        $value = $2 ;

        # check for optional package definition in the alias
	$alias = $Packprefix . $alias if $alias !~ /::/ ;

        # check for duplicate alias name & duplicate value
	Warn("Warning: Ignoring duplicate alias '$orig_alias'")
	    if defined $XsubAliases{$alias} ;

	Warn("Warning: Aliases '$orig_alias' and '$XsubAliasValues{$value}' have identical values")
	    if $XsubAliasValues{$value} ;

	$XsubAliases = 1;
	$XsubAliases{$alias} = $value ;
	$XsubAliasValues{$value} = $orig_alias ;
    }

    blurt("Error: Cannot parse ALIAS definitions from '$orig'")
        if $line ;
}

sub ATTRS_handler ()
{
    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	next unless /\S/;
	TrimWhitespace($_) ;
        push @@Attributes, $_;
    }
}

sub ALIAS_handler ()
{
    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	next unless /\S/;
	TrimWhitespace($_) ;
        GetAliases($_) if $_ ;
    }
}

sub OVERLOAD_handler()
{
    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	next unless /\S/;
	TrimWhitespace($_) ;
        while ( s/^\s*([\w:"\\)\+\-\*\/\%\<\>\.\&\|\^\!\~\{\}\=]+)\s*//) {
	    $Overload = 1 unless $Overload;
	    my $overload = "$Package\::(".$1 ;
            push(@@InitFileCode,
    	     "        newXS(\"$overload\", XS_$Full_func_name, file$proto);\n");
        }
    }

}

sub FALLBACK_handler()
{
    # the rest of the current line should contain either TRUE, 
    # FALSE or UNDEF

    TrimWhitespace($_) ;
    my %map = (
	TRUE => "PL_sv_yes", 1 => "PL_sv_yes",
	FALSE => "PL_sv_no", 0 => "PL_sv_no",
	UNDEF => "PL_sv_undef",
    ) ;

    # check for valid FALLBACK value
    death ("Error: FALLBACK: TRUE/FALSE/UNDEF") unless exists $map{uc $_} ;

    $Fallback = $map{uc $_} ;
}

sub REQUIRE_handler ()
{
    # the rest of the current line should contain a version number
    my ($Ver) = $_ ;

    TrimWhitespace($Ver) ;

    death ("Error: REQUIRE expects a version number")
	unless $Ver ;

    # check that the version number is of the form n.n
    death ("Error: REQUIRE: expected a number, got '$Ver'")
	unless $Ver =~ /^\d+(\.\d*)?/ ;

    death ("Error: xsubpp $Ver (or better) required--this is only $XSUBPP_version.")
        unless $XSUBPP_version >= $Ver ;
}

sub VERSIONCHECK_handler ()
{
    # the rest of the current line should contain either ENABLE or
    # DISABLE

    TrimWhitespace($_) ;

    # check for ENABLE/DISABLE
    death ("Error: VERSIONCHECK: ENABLE/DISABLE")
        unless /^(ENABLE|DISABLE)/i ;

    $WantVersionChk = 1 if $1 eq 'ENABLE' ;
    $WantVersionChk = 0 if $1 eq 'DISABLE' ;

}

sub PROTOTYPE_handler ()
{
    my $specified ;

    death("Error: Only 1 PROTOTYPE definition allowed per xsub")
        if $proto_in_this_xsub ++ ;

    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	next unless /\S/;
	$specified = 1 ;
	TrimWhitespace($_) ;
        if ($_ eq 'DISABLE') {
	   $ProtoThisXSUB = 0
        }
        elsif ($_ eq 'ENABLE') {
	   $ProtoThisXSUB = 1
        }
        else {
            # remove any whitespace
            s/\s+//g ;
            death("Error: Invalid prototype '$_'")
                unless ValidProtoString($_) ;
            $ProtoThisXSUB = C_string($_) ;
        }
    }

    # If no prototype specified, then assume empty prototype ""
    $ProtoThisXSUB = 2 unless $specified ;

    $ProtoUsed = 1 ;

}

sub SCOPE_handler ()
{
    death("Error: Only 1 SCOPE declaration allowed per xsub")
        if $scope_in_this_xsub ++ ;

    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
		next unless /\S/;
		TrimWhitespace($_) ;
        if ($_ =~ /^DISABLE/i) {
		   $ScopeThisXSUB = 0
        }
        elsif ($_ =~ /^ENABLE/i) {
		   $ScopeThisXSUB = 1
        }
    }

}

sub PROTOTYPES_handler ()
{
    # the rest of the current line should contain either ENABLE or
    # DISABLE

    TrimWhitespace($_) ;

    # check for ENABLE/DISABLE
    death ("Error: PROTOTYPES: ENABLE/DISABLE")
        unless /^(ENABLE|DISABLE)/i ;

    $WantPrototypes = 1 if $1 eq 'ENABLE' ;
    $WantPrototypes = 0 if $1 eq 'DISABLE' ;
    $ProtoUsed = 1 ;

}

sub INCLUDE_handler ()
{
    # the rest of the current line should contain a valid filename

    TrimWhitespace($_) ;

    death("INCLUDE: filename missing")
        unless $_ ;

    death("INCLUDE: output pipe is illegal")
        if /^\s*\|/ ;

    # simple minded recursion detector
    death("INCLUDE loop detected")
        if $IncludedFiles{$_} ;

    ++ $IncludedFiles{$_} unless /\|\s*$/ ;

    # Save the current file context.
    push(@@XSStack, {
	type		=> 'file',
        LastLine        => $lastline,
        LastLineNo      => $lastline_no,
        Line            => \@@line,
        LineNo          => \@@line_no,
        Filename        => $filename,
        Handle          => $FH,
        }) ;

    ++ $FH ;

    # open the new file
    open ($FH, "$_") or death("Cannot open '$_': $!") ;

    print Q<<"EOF" ;
#
#/* INCLUDE:  Including '$_' from '$filename' */
#
EOF

    $filename = $_ ;

    # Prime the pump by reading the first
    # non-blank line

    # skip leading blank lines
    while (<$FH>) {
        last unless /^\s*$/ ;
    }

    $lastline = $_ ;
    $lastline_no = $. ;

}

sub PopFile()
{
    return 0 unless $XSStack[-1]{type} eq 'file' ;

    my $data     = pop @@XSStack ;
    my $ThisFile = $filename ;
    my $isPipe   = ($filename =~ /\|\s*$/) ;

    -- $IncludedFiles{$filename}
        unless $isPipe ;

    close $FH ;

    $FH         = $data->{Handle} ;
    $filename   = $data->{Filename} ;
    $lastline   = $data->{LastLine} ;
    $lastline_no = $data->{LastLineNo} ;
    @@line       = @@{ $data->{Line} } ;
    @@line_no    = @@{ $data->{LineNo} } ;

    if ($isPipe and $? ) {
        -- $lastline_no ;
        print STDERR "Error reading from pipe '$ThisFile': $! in $filename, line $lastline_no\n"  ;
        exit 1 ;
    }

    print Q<<"EOF" ;
#
#/* INCLUDE: Returning to '$filename' from '$ThisFile' */
#
EOF

    return 1 ;
}

sub ValidProtoString ($)
{
    my($string) = @@_ ;

    if ( $string =~ /^$proto_re+$/ ) {
        return $string ;
    }

    return 0 ;
}

sub C_string ($)
{
    my($string) = @@_ ;

    $string =~ s[\\][\\\\]g ;
    $string ;
}

sub ProtoString ($)
{
    my ($type) = @@_ ;

    $proto_letter{$type} or "\$" ;
}

sub check_cpp {
    my @@cpp = grep(/^\#\s*(?:if|e\w+)/, @@line);
    if (@@cpp) {
	my ($cpp, $cpplevel);
	for $cpp (@@cpp) {
	    if ($cpp =~ /^\#\s*if/) {
		$cpplevel++;
	    } elsif (!$cpplevel) {
		Warn("Warning: #else/elif/endif without #if in this function");
		print STDERR "    (precede it with a blank line if the matching #if is outside the function)\n"
		    if $XSStack[-1]{type} eq 'if';
		return;
	    } elsif ($cpp =~ /^\#\s*endif/) {
		$cpplevel--;
	    }
	}
	Warn("Warning: #if without #endif in this function") if $cpplevel;
    }
}


sub Q {
    my($text) = @@_;
    $text =~ s/^#//gm;
    $text =~ s/\[\[/{/g;
    $text =~ s/\]\]/}/g;
    $text;
}

open($FH, $filename) or die "cannot open $filename: $!\n";

# Identify the version of xsubpp used
print <<EOM ;
/*
 * This file was generated automatically by xsubpp version $XSUBPP_version from the
 * contents of $filename. Do not edit this file, edit $filename instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

EOM


print("#line 1 \"$filename\"\n")
    if $WantLineNumbers;

firstmodule:
while (<$FH>) {
    if (/^=/) {
        my $podstartline = $.;
    	do {
	    if (/^=cut\s*$/) {
		# We can't just write out a /* */ comment, as our embedded
		# POD might itself be in a comment. We can't put a /**/
		# comment inside #if 0, as the C standard says that the source
		# file is decomposed into preprocessing characters in the stage
		# before preprocessing commands are executed.
		# I don't want to leave the text as barewords, because the spec
		# isn't clear whether macros are expanded before or after
		# preprocessing commands are executed, and someone pathological
		# may just have defined one of the 3 words as a macro that does
		# something strange. Multiline strings are illegal in C, so
		# the "" we write must be a string literal. And they aren't
		# concatenated until 2 steps later, so we are safe.
		print("#if 0\n  \"Skipped embedded POD.\"\n#endif\n");
		printf("#line %d \"$filename\"\n", $. + 1)
		  if $WantLineNumbers;
		next firstmodule
	    }

	} while (<$FH>);
	# At this point $. is at end of file so die won't state the start
	# of the problem, and as we haven't yet read any lines &death won't
	# show the correct line in the message either.
	die ("Error: Unterminated pod in $filename, line $podstartline\n")
	  unless $lastline;
    }
    last if ($Module, $Package, $Prefix) =
	/^MODULE\s*=\s*([\w:]+)(?:\s+PACKAGE\s*=\s*([\w:]+))?(?:\s+PREFIX\s*=\s*(\S+))?\s*$/;

    print $_;
}
&Exit unless defined $_;

print "$xsubpp::counter::SECTION_END_MARKER\n" if $WantLineNumbers;

$lastline    = $_;
$lastline_no = $.;

# Read next xsub into @@line from ($lastline, <$FH>).
sub fetch_para {
    # parse paragraph
    death ("Error: Unterminated `#if/#ifdef/#ifndef'")
	if !defined $lastline && $XSStack[-1]{type} eq 'if';
    @@line = ();
    @@line_no = () ;
    return PopFile() if !defined $lastline;

    if ($lastline =~
	/^MODULE\s*=\s*([\w:]+)(?:\s+PACKAGE\s*=\s*([\w:]+))?(?:\s+PREFIX\s*=\s*(\S+))?\s*$/) {
	$Module = $1;
	$Package = defined($2) ? $2 : '';	# keep -w happy
	$Prefix  = defined($3) ? $3 : '';	# keep -w happy
	$Prefix = quotemeta $Prefix ;
	($Module_cname = $Module) =~ s/\W/_/g;
	($Packid = $Package) =~ tr/:/_/;
	$Packprefix = $Package;
	$Packprefix .= "::" if $Packprefix ne "";
	$lastline = "";
    }

    for(;;) {
	# Skip embedded PODs
	while ($lastline =~ /^=/) {
    	    while ($lastline = <$FH>) {
	    	last if ($lastline =~ /^=cut\s*$/);
	    }
	    death ("Error: Unterminated pod") unless $lastline;
	    $lastline = <$FH>;
	    chomp $lastline;
	    $lastline =~ s/^\s+$//;
	}
	if ($lastline !~ /^\s*#/ ||
	    # CPP directives:
	    #	ANSI:	if ifdef ifndef elif else endif define undef
	    #		line error pragma
	    #	gcc:	warning include_next
	    #   obj-c:	import
	    #   others:	ident (gcc notes that some cpps have this one)
	    $lastline =~ /^#[ \t]*(?:(?:if|ifn?def|elif|else|endif|define|undef|pragma|error|warning|line\s+\d+|ident)\b|(?:include(?:_next)?|import)\s*["<].*[>"])/) {
	    last if $lastline =~ /^\S/ && @@line && $line[-1] eq "";
	    push(@@line, $lastline);
	    push(@@line_no, $lastline_no) ;
	}

	# Read next line and continuation lines
	last unless defined($lastline = <$FH>);
	$lastline_no = $.;
	my $tmp_line;
	$lastline .= $tmp_line
	    while ($lastline =~ /\\$/ && defined($tmp_line = <$FH>));

	chomp $lastline;
	$lastline =~ s/^\s+$//;
    }
    pop(@@line), pop(@@line_no) while @@line && $line[-1] eq "";
    1;
}

PARAGRAPH:
while (fetch_para()) {
    # Print initial preprocessor statements and blank lines
    while (@@line && $line[0] !~ /^[^\#]/) {
	my $line = shift(@@line);
	print $line, "\n";
	next unless $line =~ /^\#\s*((if)(?:n?def)?|elsif|else|endif)\b/;
	my $statement = $+;
	if ($statement eq 'if') {
	    $XSS_work_idx = @@XSStack;
	    push(@@XSStack, {type => 'if'});
	} else {
	    death ("Error: `$statement' with no matching `if'")
		if $XSStack[-1]{type} ne 'if';
	    if ($XSStack[-1]{varname}) {
		push(@@InitFileCode, "#endif\n");
		push(@@BootCode,     "#endif");
	    }

	    my(@@fns) = keys %{$XSStack[-1]{functions}};
	    if ($statement ne 'endif') {
		# Hide the functions defined in other #if branches, and reset.
		@@{$XSStack[-1]{other_functions}}{@@fns} = (1) x @@fns;
		@@{$XSStack[-1]}{qw(varname functions)} = ('', {});
	    } else {
		my($tmp) = pop(@@XSStack);
		0 while (--$XSS_work_idx
			 && $XSStack[$XSS_work_idx]{type} ne 'if');
		# Keep all new defined functions
		push(@@fns, keys %{$tmp->{other_functions}});
		@@{$XSStack[$XSS_work_idx]{functions}}{@@fns} = (1) x @@fns;
	    }
	}
    }

    next PARAGRAPH unless @@line;

    if ($XSS_work_idx && !$XSStack[$XSS_work_idx]{varname}) {
	# We are inside an #if, but have not yet #defined its xsubpp variable.
	print "#define $cpp_next_tmp 1\n\n";
	push(@@InitFileCode, "#if $cpp_next_tmp\n");
	push(@@BootCode,     "#if $cpp_next_tmp");
	$XSStack[$XSS_work_idx]{varname} = $cpp_next_tmp++;
    }

    death ("Code is not inside a function"
	   ." (maybe last function was ended by a blank line "
	   ." followed by a statement on column one?)")
	if $line[0] =~ /^\s/;

    # initialize info arrays
    undef(%args_match);
    undef(%var_types);
    undef(%defaults);
    undef($class);
    undef($externC);
    undef($static);
    undef($elipsis);
    undef($wantRETVAL) ;
    undef($RETVAL_no_return) ;
    undef(%arg_list) ;
    undef(@@proto_arg) ;
    undef(@@fake_INPUT_pre) ;	# For length(s) generated variables
    undef(@@fake_INPUT) ;
    undef($processing_arg_with_types) ;
    undef(%argtype_seen) ;
    undef(@@outlist) ;
    undef(%in_out) ;
    undef(%lengthof) ;
    # undef(%islengthof) ;
    undef($proto_in_this_xsub) ;
    undef($scope_in_this_xsub) ;
    undef($interface);
    undef($prepush_done);
    $interface_macro = 'XSINTERFACE_FUNC' ;
    $interface_macro_set = 'XSINTERFACE_FUNC_SET' ;
    $ProtoThisXSUB = $WantPrototypes ;
    $ScopeThisXSUB = 0;
    $xsreturn = 0;

    $_ = shift(@@line);
    while ($kwd = check_keyword("REQUIRE|PROTOTYPES|FALLBACK|VERSIONCHECK|INCLUDE")) {
        &{"${kwd}_handler"}() ;
        next PARAGRAPH unless @@line ;
        $_ = shift(@@line);
    }

    if (check_keyword("BOOT")) {
	&check_cpp;
	push (@@BootCode, "#line $line_no[@@line_no - @@line] \"$filename\"")
	  if $WantLineNumbers && $line[0] !~ /^\s*#\s*line\b/;
        push (@@BootCode, @@line, "") ;
        next PARAGRAPH ;
    }


    # extract return type, function name and arguments
    ($ret_type) = TidyType($_);
    $RETVAL_no_return = 1 if $ret_type =~ s/^NO_OUTPUT\s+//;

    # Allow one-line ANSI-like declaration
    unshift @@line, $2
      if $process_argtypes
	and $ret_type =~ s/^(.*?\w.*?)\s*\b(\w+\s*\(.*)/$1/s;

    # a function definition needs at least 2 lines
    blurt ("Error: Function definition too short '$ret_type'"), next PARAGRAPH
	unless @@line ;

    $externC = 1 if $ret_type =~ s/^extern "C"\s+//;
    $static  = 1 if $ret_type =~ s/^static\s+//;

    $func_header = shift(@@line);
    blurt ("Error: Cannot parse function definition from '$func_header'"), next PARAGRAPH
	unless $func_header =~ /^(?:([\w:]*)::)?(\w+)\s*\(\s*(.*?)\s*\)\s*(const)?\s*(;\s*)?$/s;

    ($class, $func_name, $orig_args) =  ($1, $2, $3) ;
    $class = "$4 $class" if $4;
    ($pname = $func_name) =~ s/^($Prefix)?/$Packprefix/;
    ($clean_func_name = $func_name) =~ s/^$Prefix//;
    $Full_func_name = "${Packid}_$clean_func_name";
    if ($Is_VMS) { $Full_func_name = $SymSet->addsym($Full_func_name); }

    # Check for duplicate function definition
    for $tmp (@@XSStack) {
	next unless defined $tmp->{functions}{$Full_func_name};
	Warn("Warning: duplicate function definition '$clean_func_name' detected");
	last;
    }
    $XSStack[$XSS_work_idx]{functions}{$Full_func_name} ++ ;
    %XsubAliases = %XsubAliasValues = %Interfaces = @@Attributes = ();
    $DoSetMagic = 1;

    $orig_args =~ s/\\\s*/ /g;		# process line continuations

    my %only_C_inlist;	# Not in the signature of Perl function
    if ($process_argtypes and $orig_args =~ /\S/) {
	my $args = "$orig_args ,";
	if ($args =~ /^( (??{ $C_arg }) , )* $ /x) {
	    @@args = ($args =~ /\G ( (??{ $C_arg }) ) , /xg);
	    for ( @@args ) {
		s/^\s+//;
		s/\s+$//;
		my ($arg, $default) = / ( [^=]* ) ( (?: = .* )? ) /x;
		my ($pre, $name) = ($arg =~ /(.*?) \s*
					     \b ( \w+ | length\( \s*\w+\s* \) )
					     \s* $ /x);
		next unless length $pre;
		my $out_type;
		my $inout_var;
		if ($process_inout and s/^(IN|IN_OUTLIST|OUTLIST|OUT|IN_OUT)\s+//) {
		    my $type = $1;
		    $out_type = $type if $type ne 'IN';
		    $arg =~ s/^(IN|IN_OUTLIST|OUTLIST|OUT|IN_OUT)\s+//;
		    $pre =~ s/^(IN|IN_OUTLIST|OUTLIST|OUT|IN_OUT)\s+//;
		}
		my $islength;
		if ($name =~ /^length\( \s* (\w+) \s* \)\z/x) {
		  $name = "XSauto_length_of_$1";
		  $islength = 1;
		  die "Default value on length() argument: `$_'"
		    if length $default;
		}
		if (length $pre or $islength) {	# Has a type
		    if ($islength) {
		      push @@fake_INPUT_pre, $arg;
		    } else {
		      push @@fake_INPUT, $arg;
		    }
		    # warn "pushing '$arg'\n";
		    $argtype_seen{$name}++;
		    $_ = "$name$default"; # Assigns to @@args
		}
		$only_C_inlist{$_} = 1 if $out_type eq "OUTLIST" or $islength;
		push @@outlist, $name if $out_type =~ /OUTLIST$/;
		$in_out{$name} = $out_type if $out_type;
	    }
	} else {
	    @@args = split(/\s*,\s*/, $orig_args);
	    Warn("Warning: cannot parse argument list '$orig_args', fallback to split");
	}
    } else {
	@@args = split(/\s*,\s*/, $orig_args);
	for (@@args) {
	    if ($process_inout and s/^(IN|IN_OUTLIST|OUTLIST|IN_OUT|OUT)\s+//) {
		my $out_type = $1;
		next if $out_type eq 'IN';
		$only_C_inlist{$_} = 1 if $out_type eq "OUTLIST";
		push @@outlist, $name if $out_type =~ /OUTLIST$/;
		$in_out{$_} = $out_type;
	    }
	}
    }
    if (defined($class)) {
	my $arg0 = ((defined($static) or $func_name eq 'new')
		    ? "CLASS" : "THIS");
	unshift(@@args, $arg0);
	($report_args = "$arg0, $report_args") =~ s/^\w+, $/$arg0/;
    }
    my $extra_args = 0;
    @@args_num = ();
    $num_args = 0;
    my $report_args = '';
    foreach $i (0 .. $#args) {
	    if ($args[$i] =~ s/\.\.\.//) {
		    $elipsis = 1;
		    if ($args[$i] eq '' && $i == $#args) {
		        $report_args .= ", ...";
			pop(@@args);
			last;
		    }
	    }
	    if ($only_C_inlist{$args[$i]}) {
		push @@args_num, undef;
	    } else {
		push @@args_num, ++$num_args;
		$report_args .= ", $args[$i]";
	    }
	    if ($args[$i] =~ /^([^=]*[^\s=])\s*=\s*(.*)/s) {
		    $extra_args++;
		    $args[$i] = $1;
		    $defaults{$args[$i]} = $2;
		    $defaults{$args[$i]} =~ s/"/\\"/g;
	    }
	    $proto_arg[$i+1] = "\$" ;
    }
    $min_args = $num_args - $extra_args;
    $report_args =~ s/"/\\"/g;
    $report_args =~ s/^,\s+//;
    my @@func_args = @@args;
    shift @@func_args if defined($class);

    for (@@func_args) {
	s/^/&/ if $in_out{$_};
    }
    $func_args = join(", ", @@func_args);
    @@args_match{@@args} = @@args_num;

    $PPCODE = grep(/^\s*PPCODE\s*:/, @@line);
    $CODE = grep(/^\s*CODE\s*:/, @@line);
    # Detect CODE: blocks which use ST(n)= or XST_m*(n,v)
    #   to set explicit return values.
    $EXPLICIT_RETURN = ($CODE &&
		("@@line" =~ /(\bST\s*\([^;]*=) | (\bXST_m\w+\s*\()/x ));
    $ALIAS  = grep(/^\s*ALIAS\s*:/,  @@line);
    $INTERFACE  = grep(/^\s*INTERFACE\s*:/,  @@line);

    $xsreturn = 1 if $EXPLICIT_RETURN;

    $externC = $externC ? qq[extern "C"] : "";

    # print function header
    print Q<<"EOF";
#$externC
#XS(XS_${Full_func_name}); /* prototype to pass -Wmissing-prototypes */
#XS(XS_${Full_func_name})
#[[
#    dXSARGS;
EOF
    print Q<<"EOF" if $ALIAS ;
#    dXSI32;
EOF
    print Q<<"EOF" if $INTERFACE ;
#    dXSFUNCTION($ret_type);
EOF
    if ($elipsis) {
	$cond = ($min_args ? qq(items < $min_args) : 0);
    }
    elsif ($min_args == $num_args) {
	$cond = qq(items != $min_args);
    }
    else {
	$cond = qq(items < $min_args || items > $num_args);
    }

    print Q<<"EOF" if $except;
#    char errbuf[1024];
#    *errbuf = '\0';
EOF

    if ($ALIAS)
      { print Q<<"EOF" if $cond }
#    if ($cond)
#       Perl_croak(aTHX_ "Usage: %s($report_args)", GvNAME(CvGV(cv)));
EOF
    else
      { print Q<<"EOF" if $cond }
#    if ($cond)
#	Perl_croak(aTHX_ "Usage: $pname($report_args)");
EOF

    #gcc -Wall: if an xsub has no arguments and PPCODE is used
    #it is likely none of ST, XSRETURN or XSprePUSH macros are used
    #hence `ax' (setup by dXSARGS) is unused
    #XXX: could breakup the dXSARGS; into dSP;dMARK;dITEMS
    #but such a move could break third-party extensions
    print Q<<"EOF" if $PPCODE and $num_args == 0;
#   PERL_UNUSED_VAR(ax); /* -Wall */
EOF

    print Q<<"EOF" if $PPCODE;
#    SP -= items;
EOF

    # Now do a block of some sort.

    $condnum = 0;
    $cond = '';			# last CASE: condidional
    push(@@line, "$END:");
    push(@@line_no, $line_no[-1]);
    $_ = '';
    &check_cpp;
    while (@@line) {
	&CASE_handler if check_keyword("CASE");
	print Q<<"EOF";
#   $except [[
EOF

	# do initialization of input variables
	$thisdone = 0;
	$retvaldone = 0;
	$deferred = "";
	%arg_list = () ;
        $gotRETVAL = 0;

	INPUT_handler() ;
	process_keyword("INPUT|PREINIT|INTERFACE_MACRO|C_ARGS|ALIAS|ATTRS|PROTOTYPE|SCOPE|OVERLOAD") ;

	print Q<<"EOF" if $ScopeThisXSUB;
#   ENTER;
#   [[
EOF
	
	if (!$thisdone && defined($class)) {
	    if (defined($static) or $func_name eq 'new') {
		print "\tchar *";
		$var_types{"CLASS"} = "char *";
		&generate_init("char *", 1, "CLASS");
	    }
	    else {
		print "\t$class *";
		$var_types{"THIS"} = "$class *";
		&generate_init("$class *", 1, "THIS");
	    }
	}

	# do code
	if (/^\s*NOT_IMPLEMENTED_YET/) {
		print "\n\tPerl_croak(aTHX_ \"$pname: not implemented yet\");\n";
		$_ = '' ;
	} else {
		if ($ret_type ne "void") {
			print "\t" . &map_type($ret_type, 'RETVAL') . ";\n"
				if !$retvaldone;
			$args_match{"RETVAL"} = 0;
			$var_types{"RETVAL"} = $ret_type;
			print "\tdXSTARG;\n"
				if $WantOptimize and $targetable{$type_kind{$ret_type}};
		}

		if (@@fake_INPUT or @@fake_INPUT_pre) {
		    unshift @@line, @@fake_INPUT_pre, @@fake_INPUT, $_;
		    $_ = "";
		    $processing_arg_with_types = 1;
		    INPUT_handler() ;
		}
		print $deferred;

        process_keyword("INIT|ALIAS|ATTRS|PROTOTYPE|INTERFACE_MACRO|INTERFACE|C_ARGS|OVERLOAD") ;

		if (check_keyword("PPCODE")) {
			print_section();
			death ("PPCODE must be last thing") if @@line;
			print "\tLEAVE;\n" if $ScopeThisXSUB;
			print "\tPUTBACK;\n\treturn;\n";
		} elsif (check_keyword("CODE")) {
			print_section() ;
		} elsif (defined($class) and $func_name eq "DESTROY") {
			print "\n\t";
			print "delete THIS;\n";
		} else {
			print "\n\t";
			if ($ret_type ne "void") {
				print "RETVAL = ";
				$wantRETVAL = 1;
			}
			if (defined($static)) {
			    if ($func_name eq 'new') {
				$func_name = "$class";
			    } else {
				print "${class}::";
			    }
			} elsif (defined($class)) {
			    if ($func_name eq 'new') {
				$func_name .= " $class";
			    } else {
				print "THIS->";
			    }
			}
			$func_name =~ s/^($spat)//
			    if defined($spat);
			$func_name = 'XSFUNCTION' if $interface;
			print "$func_name($func_args);\n";
		}
	}

	# do output variables
	$gotRETVAL = 0;		# 1 if RETVAL seen in OUTPUT section;
	undef $RETVAL_code ;	# code to set RETVAL (from OUTPUT section);
	# $wantRETVAL set if 'RETVAL =' autogenerated
	($wantRETVAL, $ret_type) = (0, 'void') if $RETVAL_no_return;
	undef %outargs ;
	process_keyword("POSTCALL|OUTPUT|ALIAS|ATTRS|PROTOTYPE|OVERLOAD");

	&generate_output($var_types{$_}, $args_match{$_}, $_, $DoSetMagic)
	  for grep $in_out{$_} =~ /OUT$/, keys %in_out;

	# all OUTPUT done, so now push the return value on the stack
	if ($gotRETVAL && $RETVAL_code) {
	    print "\t$RETVAL_code\n";
	} elsif ($gotRETVAL || $wantRETVAL) {
	    my $t = $WantOptimize && $targetable{$type_kind{$ret_type}};
	    my $var = 'RETVAL';
	    my $type = $ret_type;

	    # 0: type, 1: with_size, 2: how, 3: how_size
	    if ($t and not $t->[1] and $t->[0] eq 'p') {
		# PUSHp corresponds to setpvn.  Treate setpv directly
		my $what = eval qq("$t->[2]");
		warn $@@ if $@@;

		print "\tsv_setpv(TARG, $what); XSprePUSH; PUSHTARG;\n";
		$prepush_done = 1;
	    }
	    elsif ($t) {
		my $what = eval qq("$t->[2]");
		warn $@@ if $@@;

		my $size = $t->[3];
		$size = '' unless defined $size;
		$size = eval qq("$size");
		warn $@@ if $@@;
		print "\tXSprePUSH; PUSH$t->[0]($what$size);\n";
		$prepush_done = 1;
	    }
	    else {
		# RETVAL almost never needs SvSETMAGIC()
		&generate_output($ret_type, 0, 'RETVAL', 0);
	    }
	}

	$xsreturn = 1 if $ret_type ne "void";
	my $num = $xsreturn;
	my $c = @@outlist;
	# (PP)CODE set different values of SP; reset to PPCODE's with 0 output
	print "\tXSprePUSH;"    if $c and not $prepush_done;
	# Take into account stuff already put on stack
	print "\t++SP;"         if $c and not $prepush_done and $xsreturn;
	# Now SP corresponds to ST($xsreturn), so one can combine PUSH and ST()
	print "\tEXTEND(SP,$c);\n" if $c;
	$xsreturn += $c;
	generate_output($var_types{$_}, $num++, $_, 0, 1) for @@outlist;

	# do cleanup
	process_keyword("CLEANUP|ALIAS|ATTRS|PROTOTYPE|OVERLOAD") ;

	print Q<<"EOF" if $ScopeThisXSUB;
#   ]]
EOF
	print Q<<"EOF" if $ScopeThisXSUB and not $PPCODE;
#   LEAVE;
EOF

	# print function trailer
	print Q<<EOF;
#    ]]
EOF
	print Q<<EOF if $except;
#    BEGHANDLERS
#    CATCHALL
#	sprintf(errbuf, "%s: %s\\tpropagated", Xname, Xreason);
#    ENDHANDLERS
EOF
	if (check_keyword("CASE")) {
	    blurt ("Error: No `CASE:' at top of function")
		unless $condnum;
	    $_ = "CASE: $_";	# Restore CASE: label
	    next;
	}
	last if $_ eq "$END:";
	death(/^$BLOCK_re/o ? "Misplaced `$1:'" : "Junk at end of function");
    }

    print Q<<EOF if $except;
#    if (errbuf[0])
#	Perl_croak(aTHX_ errbuf);
EOF

    if ($xsreturn) {
        print Q<<EOF unless $PPCODE;
#    XSRETURN($xsreturn);
EOF
    } else {
        print Q<<EOF unless $PPCODE;
#    XSRETURN_EMPTY;
EOF
    }

    print Q<<EOF;
#]]
#
EOF

    my $newXS = "newXS" ;
    my $proto = "" ;

    # Build the prototype string for the xsub
    if ($ProtoThisXSUB) {
	$newXS = "newXSproto";

	if ($ProtoThisXSUB eq 2) {
	    # User has specified empty prototype
	    $proto = ', ""' ;
	}
        elsif ($ProtoThisXSUB ne 1) {
            # User has specified a prototype
            $proto = ', "' . $ProtoThisXSUB . '"';
        }
        else {
	    my $s = ';';
            if ($min_args < $num_args)  {
                $s = '';
		$proto_arg[$min_args] .= ";" ;
	    }
            push @@proto_arg, "$s\@@"
                if $elipsis ;

            $proto = ', "' . join ("", @@proto_arg) . '"';
        }
    }

    if (%XsubAliases) {
	$XsubAliases{$pname} = 0
	    unless defined $XsubAliases{$pname} ;
	while ( ($name, $value) = each %XsubAliases) {
	    push(@@InitFileCode, Q<<"EOF");
#        cv = newXS(\"$name\", XS_$Full_func_name, file);
#        XSANY.any_i32 = $value ;
EOF
	push(@@InitFileCode, Q<<"EOF") if $proto;
#        sv_setpv((SV*)cv$proto) ;
EOF
        }
    }
    elsif (@@Attributes) {
	    push(@@InitFileCode, Q<<"EOF");
#        cv = newXS(\"$pname\", XS_$Full_func_name, file);
#        apply_attrs_string("$Package", cv, "@@Attributes", 0);
EOF
    }
    elsif ($interface) {
	while ( ($name, $value) = each %Interfaces) {
	    $name = "$Package\::$name" unless $name =~ /::/;
	    push(@@InitFileCode, Q<<"EOF");
#        cv = newXS(\"$name\", XS_$Full_func_name, file);
#        $interface_macro_set(cv,$value) ;
EOF
	    push(@@InitFileCode, Q<<"EOF") if $proto;
#        sv_setpv((SV*)cv$proto) ;
EOF
        }
    }
    else {
	push(@@InitFileCode,
	     "        ${newXS}(\"$pname\", XS_$Full_func_name, file$proto);\n");
    }
}

if ($Overload) # make it findable with fetchmethod
{
    
    print Q<<"EOF"; 
#XS(XS_${Packid}_nil); /* prototype to pass -Wmissing-prototypes */
#XS(XS_${Packid}_nil)
#{
#   XSRETURN_EMPTY;
#}
#
EOF
    unshift(@@InitFileCode, <<"MAKE_FETCHMETHOD_WORK");
    /* Making a sub named "${Package}::()" allows the package */
    /* to be findable via fetchmethod(), and causes */
    /* overload::Overloaded("${Package}") to return true. */
    newXS("${Package}::()", XS_${Packid}_nil, file$proto);
MAKE_FETCHMETHOD_WORK
}

# print initialization routine

print Q<<"EOF";
##ifdef __cplusplus
#extern "C"
##endif
EOF

print Q<<"EOF";
#XS(boot_$Module_cname); /* prototype to pass -Wmissing-prototypes */
#XS(boot_$Module_cname)
EOF

print Q<<"EOF";
#[[
#    dXSARGS;
EOF

#-Wall: if there is no $Full_func_name there are no xsubs in this .xs
#so `file' is unused
print Q<<"EOF" if $Full_func_name;
#    char* file = __FILE__;
EOF

print Q "#\n";

print Q<<"EOF" if $WantVersionChk ;
#    XS_VERSION_BOOTCHECK ;
#
EOF

print Q<<"EOF" if defined $XsubAliases or defined $Interfaces ;
#    {
#        CV * cv ;
#
EOF

print Q<<"EOF" if ($Overload);
#    /* register the overloading (type 'A') magic */
#    PL_amagic_generation++;
#    /* The magic for overload gets a GV* via gv_fetchmeth as */
#    /* mentioned above, and looks in the SV* slot of it for */
#    /* the "fallback" status. */
#    sv_setsv(
#        get_sv( "${Package}::()", TRUE ),
#        $Fallback
#    );
EOF

print @@InitFileCode;

print Q<<"EOF" if defined $XsubAliases or defined $Interfaces ;
#    }
EOF

if (@@BootCode)
{
    print "\n    /* Initialisation Section */\n\n" ;
    @@line = @@BootCode;
    print_section();
    print "\n    /* End of Initialisation Section */\n\n" ;
}

print Q<<"EOF";;
#    XSRETURN_YES;
#]]
#
EOF

warn("Please specify prototyping behavior for $filename (see perlxs manual)\n")
    unless $ProtoUsed ;
&Exit;

sub output_init {
    local($type, $num, $var, $init, $name_printed) = @@_;
    local($arg) = "ST(" . ($num - 1) . ")";

    if(  $init =~ /^=/  ) {
        if ($name_printed) {
	  eval qq/print " $init\\n"/;
	} else {
	  eval qq/print "\\t$var $init\\n"/;
	}
	warn $@@   if  $@@;
    } else {
	if(  $init =~ s/^\+//  &&  $num  ) {
	    &generate_init($type, $num, $var, $name_printed);
	} elsif ($name_printed) {
	    print ";\n";
	    $init =~ s/^;//;
	} else {
	    eval qq/print "\\t$var;\\n"/;
	    warn $@@   if  $@@;
	    $init =~ s/^;//;
	}
	$deferred .= eval qq/"\\n\\t$init\\n"/;
	warn $@@   if  $@@;
    }
}

sub Warn
{
    # work out the line number
    my $line_no = $line_no[@@line_no - @@line -1] ;

    print STDERR "@@_ in $filename, line $line_no\n" ;
}

sub blurt
{
    Warn @@_ ;
    $errors ++
}

sub death
{
    Warn @@_ ;
    exit 1 ;
}

sub generate_init {
    local($type, $num, $var) = @@_;
    local($arg) = "ST(" . ($num - 1) . ")";
    local($argoff) = $num - 1;
    local($ntype);
    local($tk);

    $type = TidyType($type) ;
    blurt("Error: '$type' not in typemap"), return
	unless defined($type_kind{$type});

    ($ntype = $type) =~ s/\s*\*/Ptr/g;
    ($subtype = $ntype) =~ s/(?:Array)?(?:Ptr)?$//;
    $tk = $type_kind{$type};
    $tk =~ s/OBJ$/REF/ if $func_name =~ /DESTROY$/;
    if ($tk eq 'T_PV' and exists $lengthof{$var}) {
      print "\t$var" unless $name_printed;
      print " = ($type)SvPV($arg, STRLEN_length_of_$var);\n";
      die "default value not supported with length(NAME) supplied"
	if defined $defaults{$var};
      return;
    }
    $type =~ tr/:/_/ unless $hiertype;
    blurt("Error: No INPUT definition for type '$type', typekind '$type_kind{$type}' found"), return
        unless defined $input_expr{$tk} ;
    $expr = $input_expr{$tk};
    if ($expr =~ /DO_ARRAY_ELEM/) {
        blurt("Error: '$subtype' not in typemap"), return
	    unless defined($type_kind{$subtype});
        blurt("Error: No INPUT definition for type '$subtype', typekind '$type_kind{$subtype}' found"), return
            unless defined $input_expr{$type_kind{$subtype}} ;
	$subexpr = $input_expr{$type_kind{$subtype}};
        $subexpr =~ s/\$type/\$subtype/g;
	$subexpr =~ s/ntype/subtype/g;
	$subexpr =~ s/\$arg/ST(ix_$var)/g;
	$subexpr =~ s/\n\t/\n\t\t/g;
	$subexpr =~ s/is not of (.*\")/[arg %d] is not of $1, ix_$var + 1/g;
	$subexpr =~ s/\$var/${var}[ix_$var - $argoff]/;
	$expr =~ s/DO_ARRAY_ELEM/$subexpr/;
    }
    if ($expr =~ m#/\*.*scope.*\*/#i) { # "scope" in C comments
    	$ScopeThisXSUB = 1;
    }
    if (defined($defaults{$var})) {
	    $expr =~ s/(\t+)/$1    /g;
	    $expr =~ s/        /\t/g;
	    if ($name_printed) {
	      print ";\n";
	    } else {
	      eval qq/print "\\t$var;\\n"/;
	      warn $@@   if  $@@;
	    }
	    if ($defaults{$var} eq 'NO_INIT') {
		$deferred .= eval qq/"\\n\\tif (items >= $num) {\\n$expr;\\n\\t}\\n"/;
	    } else {
		$deferred .= eval qq/"\\n\\tif (items < $num)\\n\\t    $var = $defaults{$var};\\n\\telse {\\n$expr;\\n\\t}\\n"/;
	    }
	    warn $@@   if  $@@;
    } elsif ($ScopeThisXSUB or $expr !~ /^\s*\$var =/) {
	    if ($name_printed) {
	      print ";\n";
	    } else {
	      eval qq/print "\\t$var;\\n"/;
	      warn $@@   if  $@@;
	    }
	    $deferred .= eval qq/"\\n$expr;\\n"/;
	    warn $@@   if  $@@;
    } else {
	    die "panic: do not know how to handle this branch for function pointers"
	      if $name_printed;
	    eval qq/print "$expr;\\n"/;
	    warn $@@   if  $@@;
    }
}

sub generate_output {
    local($type, $num, $var, $do_setmagic, $do_push) = @@_;
    local($arg) = "ST(" . ($num - ($num != 0)) . ")";
    local($argoff) = $num - 1;
    local($ntype);

    $type = TidyType($type) ;
    if ($type =~ /^array\(([^,]*),(.*)\)/) {
            print "\t$arg = sv_newmortal();\n";
	    print "\tsv_setpvn($arg, (char *)$var, $2 * sizeof($1));\n";
	    print "\tSvSETMAGIC($arg);\n" if $do_setmagic;
    } else {
	    blurt("Error: '$type' not in typemap"), return
		unless defined($type_kind{$type});
            blurt("Error: No OUTPUT definition for type '$type', typekind '$type_kind{$type}' found"), return
                unless defined $output_expr{$type_kind{$type}} ;
	    ($ntype = $type) =~ s/\s*\*/Ptr/g;
	    $ntype =~ s/\(\)//g;
	    ($subtype = $ntype) =~ s/(?:Array)?(?:Ptr)?$//;
	    $expr = $output_expr{$type_kind{$type}};
	    if ($expr =~ /DO_ARRAY_ELEM/) {
	        blurt("Error: '$subtype' not in typemap"), return
		    unless defined($type_kind{$subtype});
                blurt("Error: No OUTPUT definition for type '$subtype', typekind '$type_kind{$subtype}' found"), return
                    unless defined $output_expr{$type_kind{$subtype}} ;
		$subexpr = $output_expr{$type_kind{$subtype}};
		$subexpr =~ s/ntype/subtype/g;
		$subexpr =~ s/\$arg/ST(ix_$var)/g;
		$subexpr =~ s/\$var/${var}[ix_$var]/g;
		$subexpr =~ s/\n\t/\n\t\t/g;
		$expr =~ s/DO_ARRAY_ELEM\n/$subexpr/;
		eval "print qq\a$expr\a";
		warn $@@   if  $@@;
		print "\t\tSvSETMAGIC(ST(ix_$var));\n" if $do_setmagic;
	    }
	    elsif ($var eq 'RETVAL') {
		if ($expr =~ /^\t\$arg = new/) {
		    # We expect that $arg has refcnt 1, so we need to
		    # mortalize it.
		    eval "print qq\a$expr\a";
		    warn $@@   if  $@@;
		    print "\tsv_2mortal(ST($num));\n";
		    print "\tSvSETMAGIC(ST($num));\n" if $do_setmagic;
		}
		elsif ($expr =~ /^\s*\$arg\s*=/) {
		    # We expect that $arg has refcnt >=1, so we need
		    # to mortalize it!
		    eval "print qq\a$expr\a";
		    warn $@@   if  $@@;
		    print "\tsv_2mortal(ST(0));\n";
		    print "\tSvSETMAGIC(ST(0));\n" if $do_setmagic;
		}
		else {
		    # Just hope that the entry would safely write it
		    # over an already mortalized value. By
		    # coincidence, something like $arg = &sv_undef
		    # works too.
		    print "\tST(0) = sv_newmortal();\n";
		    eval "print qq\a$expr\a";
		    warn $@@   if  $@@;
		    # new mortals don't have set magic
		}
	    }
	    elsif ($do_push) {
	        print "\tPUSHs(sv_newmortal());\n";
		$arg = "ST($num)";
		eval "print qq\a$expr\a";
		warn $@@   if  $@@;
		print "\tSvSETMAGIC($arg);\n" if $do_setmagic;
	    }
	    elsif ($arg =~ /^ST\(\d+\)$/) {
		eval "print qq\a$expr\a";
		warn $@@   if  $@@;
		print "\tSvSETMAGIC($arg);\n" if $do_setmagic;
	    }
    }
}

sub map_type {
    my($type, $varname) = @@_;

    # C++ has :: in types too so skip this
    $type =~ tr/:/_/ unless $hiertype;
    $type =~ s/^array\(([^,]*),(.*)\).*/$1 */s;
    if ($varname) {
      if ($varname && $type =~ / \( \s* \* (?= \s* \) ) /xg) {
	(substr $type, pos $type, 0) = " $varname ";
      } else {
	$type .= "\t$varname";
      }
    }
    $type;
}


sub Exit {
# If this is VMS, the exit status has meaning to the shell, so we
# use a predictable value (SS$_Normal or SS$_Abort) rather than an
# arbitrary number.
#    exit ($Is_VMS ? ($errors ? 44 : 1) : $errors) ;
    exit ($errors ? 1 : 0);
}
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d9 1
a9 1
B<xsubpp> [B<-v>] [B<-C++>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-nolinenumbers>] [B<-nooptimize>] [B<-typemap typemap>] ... file.xs
d37 6
d135 1
a135 1
$usage = "Usage: xsubpp [-v] [-C++] [-except] [-prototypes] [-noversioncheck] [-nolinenumbers] [-nooptimize] [-noinout] [-noargtypes] [-s pattern] [-typemap typemap]... file.xs\n";
d150 1
d157 1
d368 1
a368 1
    $cfile =~ s/\.xs$/.c/i or $cfile .= ".c";
d1070 1
d1124 2
a1125 1
    $static = 1 if $ret_type =~ s/^static\s+//;
d1264 2
d1268 1
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d140 1
d297 1
a297 1
	SCOPE INTERFACE INTERFACE_MACRO C_ARGS POSTCALL OVERLOAD
d621 18
d910 13
a922 1
		print("/* Skipped embedded POD. */\n");
d1087 1
a1087 1
    while ($kwd = check_keyword("REQUIRE|PROTOTYPES|VERSIONCHECK|INCLUDE")) {
d1456 5
a1460 1
	print "\tXSprePUSH;" if $c and not $prepush_done;
d1580 19
d1637 9
a1645 9
#    {
#        /* create the package stash */
#        HV *hv = get_hv(\"$Package\::OVERLOAD\",TRUE);
#        SV *sv = *hv_fetch(hv,"register",8,1);
#        sv_inc(sv);
#        SvSETMAGIC(sv);
#        /* Make it findable via fetchmethod */
#        newXS(\"$Package\::()\", NULL, file);
#    }
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d37 4
d107 1
a107 1
use vars '$cplusplus';
d131 1
a131 3
$proto_re = "[" . quotemeta('\$%&*@@;') . "]" ;
# mjn
$OBJ   = 1 if $Config{'ccflags'} =~ /PERL_OBJECT/i;
d139 1
d149 1
d155 1
a155 1
    $WantCAPI = 1, next SWITCH    if $flag eq 'object_capi';
d205 1
a205 1
    
d220 1
a220 1
    next unless -e $typemap ;
d222 1
a222 1
    warn("Warning: ignoring non-text typemap file '$typemap'\n"), next 
d224 1
a224 1
    open(TYPEMAP, $typemap) 
d231 1
a231 1
        my $line_no = $. + 1; 
d247 1
a247 1
            warn("Warning: File '$typemap' Line $. '$line' Invalid prototype '$proto'\n") 
d269 1
a269 1
    $input_expr{$key} =~ s/\n+$//;
d294 1
a294 1
	REQUIRE BOOT CASE PREINIT INPUT INIT CODE PPCODE OUTPUT 
d296 1
a296 1
	SCOPE INTERFACE INTERFACE_MACRO C_ARGS POSTCALL
d367 1
a367 1
    
d378 1
a378 1
  
d382 1
a382 1
    
d395 1
a395 1
    &{"${kwd}_handler"}() 
d411 1
a411 1
	next unless /\S/;	# skip blank lines 
d419 8
d438 2
a439 2
	    if $arg_list{$var_name}++ 
	      or defined $arg_types{$var_name} and not $processing_arg_with_types;
d457 1
a457 1
        $proto_arg[$var_num] = ProtoString($var_type) 
d506 1
a506 1
	delete $in_out{$outarg} 	# No need to auto-OUTPUT 
d513 1
a513 1
  
d516 1
a516 1
} 
d520 1
a520 1
  
d534 1
a534 1
  
d536 1
a536 1
    
d547 4
a550 4
sub CLEANUP_handler() { print_section() } 
sub PREINIT_handler() { print_section() } 
sub POSTCALL_handler() { print_section() } 
sub INIT_handler()    { print_section() } 
d570 1
a570 1
        
d605 15
d635 1
a635 1
        unless $XSUBPP_version >= $Ver ; 
d642 1
a642 1
 
d644 1
a644 1
 
d648 1
a648 1
 
d651 1
a651 1
 
d658 1
a658 1
    death("Error: Only 1 PROTOTYPE definition allowed per xsub") 
d666 1
a666 1
	   $ProtoThisXSUB = 0 
d669 1
a669 1
	   $ProtoThisXSUB = 1 
d689 1
a689 1
    death("Error: Only 1 SCOPE declaration allowed per xsub") 
d696 1
a696 1
		   $ScopeThisXSUB = 0 
d699 1
a699 1
		   $ScopeThisXSUB = 1 
d708 1
a708 1
    # DISABLE 
d725 1
a725 1
 
d727 1
a727 1
 
d750 1
a750 1
 
d755 1
a755 1
 
d764 1
a764 1
    # Prime the pump by reading the first 
d774 1
a774 1
 
d776 1
a776 1
 
d784 1
a784 1
 
d872 1
a872 1
 * This file was generated automatically by xsubpp version $XSUBPP_version from the 
d875 1
a875 1
 *	ANY CHANGES MADE HERE WILL BE LOST! 
d880 1
a880 1
 
a906 3
    if ($OBJ) {
        s/#if(?:def\s|\s+defined)\s*(\(__cplusplus\)|__cplusplus)/#if defined(__cplusplus) && !defined(PERL_OBJECT)/;
    }
d939 1
a939 1
	# Skip embedded PODs 
d1023 1
a1023 1
	   ." followed by a a statement on column one?)")
d1037 2
a1038 1
    undef(@@arg_with_types) ;
d1040 1
a1040 1
    undef(%arg_types) ;
d1043 2
d1109 1
a1109 1
    my %only_outlist;
d1117 4
a1120 4
		my $arg = $_;
		my $default;
		($arg, $default) = / ( [^=]* ) ( (?: = .* )? ) /x;
		my ($pre, $name) = ($arg =~ /(.*?) \s* \b(\w+) \s* $ /x);
d1128 8
d1137 6
a1142 2
		if (/\W/) {	# Has a type
		    push @@arg_with_types, $arg;
d1144 2
a1145 2
		    $arg_types{$name} = $arg;
		    $_ = "$name$default";
d1147 1
a1147 1
		$only_outlist{$_} = 1 if $out_type eq "OUTLIST";
d1161 1
a1161 1
		$only_outlist{$_} = 1 if $out_type eq "OUTLIST";
d1186 1
a1186 1
	    if ($only_outlist{$args[$i]}) {
d1225 1
d1251 1
a1251 1
    if ($ALIAS) 
d1256 1
a1256 1
    else 
d1262 9
d1297 1
a1297 1
	process_keyword("INPUT|PREINIT|INTERFACE_MACRO|C_ARGS|ALIAS|ATTRS|PROTOTYPE|SCOPE") ;
d1331 2
a1332 2
		if (@@arg_with_types) {
		    unshift @@line, @@arg_with_types, $_;
d1339 1
a1339 1
        process_keyword("INIT|ALIAS|ATTRS|PROTOTYPE|INTERFACE_MACRO|INTERFACE|C_ARGS") ;
d1383 1
a1383 1
	process_keyword("POSTCALL|OUTPUT|ALIAS|ATTRS|PROTOTYPE"); 
d1431 1
a1431 1
	process_keyword("CLEANUP|ALIAS|ATTRS|PROTOTYPE") ;
d1498 1
a1498 1
                $s = ''; 
d1501 1
a1501 1
            push @@proto_arg, "$s\@@" 
d1503 1
a1503 1
    
d1509 1
a1509 1
	$XsubAliases{$pname} = 0 
d1520 1
a1520 1
    } 
d1554 1
d1561 5
a1566 1
#
d1569 2
d1582 12
d1614 1
a1614 1
warn("Please specify prototyping behavior for $filename (see perlxs manual)\n") 
d1649 1
a1649 1
 
d1653 2
a1654 2
sub blurt 
{ 
d1656 1
a1656 1
    $errors ++ 
d1673 1
a1673 1
    blurt("Error: '$type' not in typemap"), return 
d1680 8
a1687 1
    $type =~ tr/:/_/;
d1692 1
a1692 1
        blurt("Error: '$subtype' not in typemap"), return 
d1697 1
d1723 1
a1723 1
    } elsif ($ScopeThisXSUB or $expr !~ /^\t\$var =/) {
d1748 1
d1821 2
a1822 1
    $type =~ tr/:/_/;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d112 1
a112 1
$XSUBPP_version = "1.9507";
d291 1
a291 1
	CLEANUP ALIAS PROTOTYPES PROTOTYPE VERSIONCHECK INCLUDE
d421 1
a421 1
	my ($var_type, $var_addr, $var_name) = /^(.*?[^& ]) *(\&?) *\b(\w+)$/s
d447 1
a447 4
	if ($var_addr) {
	    $var_addr{$var_name} = 1;
	    $func_args =~ s/\b($var_name)\b/&$1/;
	}
d449 1
a449 1
	    or $in_out{$var_name} and $in_out{$var_name} eq 'OUTLIST'
d494 2
d575 9
d858 1
d860 17
d915 10
a1004 1
    undef(%var_addr);
d1016 1
a1016 1
    undef(@@in_out) ;
d1077 1
a1077 1
    %XsubAliases = %XsubAliasValues = %Interfaces = ();
d1082 1
a1082 1
    my %out_vars;
d1097 1
a1097 1
		if ($process_inout and s/^(IN|IN_OUTLIST|OUTLIST)\s+//) {
d1100 1
a1100 1
		    $arg =~ s/^(IN|IN_OUTLIST|OUTLIST)\s+//;
d1108 2
a1109 2
		$out_vars{$_} = 1 if $out_type eq 'OUTLIST';
		push @@in_out, $name if $out_type;
d1119 1
a1119 1
	    if ($process_inout and s/^(IN|IN_OUTLIST|OUTLIST)\s+//) {
d1122 2
a1123 2
		$out_vars{$_} = 1 if $out_type eq 'OUTLIST';
		push @@in_out, $name;
d1147 1
a1147 1
	    if ($out_vars{$args[$i]}) {
d1248 1
a1248 1
	process_keyword("INPUT|PREINIT|INTERFACE_MACRO|C_ARGS|ALIAS|PROTOTYPE|SCOPE") ;
d1290 1
a1290 1
        process_keyword("INIT|ALIAS|PROTOTYPE|INTERFACE_MACRO|INTERFACE|C_ARGS") ;
d1334 4
a1337 1
	process_keyword("POSTCALL|OUTPUT|ALIAS|PROTOTYPE"); 
d1375 1
a1375 1
	my $c = @@in_out;
d1379 1
a1379 1
	generate_output($var_types{$_}, $num++, $_, 0, 1) for @@in_out;
d1382 1
a1382 1
	process_keyword("CLEANUP|ALIAS|PROTOTYPE") ;
d1472 6
@


1.3
log
@perl5.005_03 (stock)
@
text
@d9 1
a9 1
B<xsubpp> [B<-v>] [B<-C++>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-nolinenumbers>] [B<-typemap typemap>] [B<-object_capi>]... file.xs
d13 2
d28 3
a36 1

d66 8
a73 1
=item B<-object_capi>
d75 1
a75 1
Compile code as C in a PERL_OBJECT environment.
d77 5
a81 1
back
d125 1
a125 1
$usage = "Usage: xsubpp [-v] [-C++] [-except] [-prototypes] [-noversioncheck] [-nolinenumbers] [-s pattern] [-typemap typemap]... file.xs\n";
d136 5
d150 1
d156 7
a162 1
    (print "xsubpp version $XSUBPP_version\n"), exit  	
d268 18
d292 1
a292 1
	SCOPE INTERFACE INTERFACE_MACRO C_ARGS
d303 13
d426 2
a427 1
	    if $arg_list{$var_name} ++  ;
d432 11
a442 1
	print "\t" . &map_type($var_type);
d451 6
a456 1
	if ($var_init =~ /^[=;]\s*NO_INIT\s*;?\s*$/) {
d458 1
d460 1
a460 1
	    &output_init($var_type, $var_num, $var_name, $var_init);
d463 1
a463 1
	    &generate_init($var_type, $var_num, $var_name);
d538 1
d908 1
a908 1
	    
d975 1
d978 5
d986 1
d991 1
d1011 6
d1026 1
a1026 1
	unless $func_header =~ /^(?:([\w:]*)::)?(\w+)\s*\(\s*(.*?)\s*\)\s*(const)?\s*$/s;
d1045 48
a1092 1
    @@args = split(/\s*,\s*/, $orig_args);
d1097 1
a1097 1
	($orig_args = "$arg0, $orig_args") =~ s/^$arg0, $/$arg0/;
d1099 5
a1103 3
    $orig_args =~ s/"/\\"/g;
    $min_args = $num_args = @@args;
    foreach $i (0..$num_args-1) {
d1106 2
a1107 2
		    $min_args--;
		    if ($args[$i] eq '' && $i == $num_args - 1) {
d1112 6
d1119 1
a1119 1
		    $min_args--;
d1126 8
a1133 4
    if (defined($class)) {
	    $func_args = join(", ", @@args[1..$#args]);
    } else {
	    $func_args = join(", ", @@args);
d1135 2
a1136 1
    @@args_match{@@args} = 1..@@args;
d1147 2
d1179 1
a1179 1
#       croak("Usage: %s($orig_args)", GvNAME(CvGV(cv)));
d1184 1
a1184 1
#	croak("Usage: $pname($orig_args)");
d1235 1
a1235 1
		print "\n\tcroak(\"$pname: not implemented yet\");\n";
d1239 1
a1239 1
			print "\t" . &map_type($ret_type) . "\tRETVAL;\n"
d1243 2
d1247 6
d1294 4
a1297 2
	$gotRETVAL = 0;
	undef $RETVAL_code ;
d1299 1
a1299 1
        process_keyword("OUTPUT|ALIAS|PROTOTYPE"); 
d1305 28
a1332 2
	    # RETVAL almost never needs SvSETMAGIC()
	    &generate_output($ret_type, 0, 'RETVAL', 0);
d1335 8
d1375 1
a1375 1
#	croak(errbuf);
d1378 1
a1378 1
    if ($ret_type ne "void" or $EXPLICIT_RETURN) {
d1380 1
a1380 1
#    XSRETURN(1);
a1459 8
if ($WantCAPI) {
print Q<<"EOF";
##ifdef PERL_CAPI
#XS(boot__CAPI_entry)
##else
EOF
}

a1463 6
if ($WantCAPI) {
print Q<<"EOF";
##endif	/* PERL_CAPI */
EOF
}

a1501 17
if ($WantCAPI) { 
print Q<<"EOF";
##ifdef PERL_CAPI
##define XSCAPI(name) void name(CV* cv, void* pPerl)
#
##ifdef __cplusplus
#extern "C"
##endif
#XSCAPI(boot_$Module_cname)
#[[
#    SetCPerlObj(pPerl);
#    boot__CAPI_entry(cv);
#]]
##endif	/* PERL_CAPI */
EOF
}

d1507 1
a1507 1
    local($type, $num, $var, $init) = @@_;
d1511 5
a1515 1
	eval qq/print "\\t$var $init\\n"/;
d1519 4
a1522 1
	    &generate_init($type, $num, $var);
d1569 1
a1569 1
    blurt("Error: No INPUT definition for type '$type' found"), return
d1575 1
a1575 1
        blurt("Error: No INPUT definition for type '$subtype' found"), return
d1591 11
a1601 3
	    eval qq/print "\\t$var;\\n"/;
	    warn $@@   if  $@@;
	    $deferred .= eval qq/"\\n\\tif (items < $num)\\n\\t    $var = $defaults{$var};\\n\\telse {\\n$expr;\\n\\t}\\n"/;
d1604 6
a1609 2
	    eval qq/print "\\t$var;\\n"/;
	    warn $@@   if  $@@;
d1613 2
d1621 1
a1621 1
    local($type, $num, $var, $do_setmagic) = @@_;
d1628 1
a1628 1
	    print "\tsv_setpvn($arg, (char *)$var, $2 * sizeof($1)), XFree((char *)$var);\n";
d1633 1
a1633 1
            blurt("Error: No OUTPUT definition for type '$type' found"), return
d1642 1
a1642 1
                blurt("Error: No OUTPUT definition for type '$subtype' found"), return
d1660 2
a1661 2
		    print "\tsv_2mortal(ST(0));\n";
		    print "\tSvSETMAGIC(ST(0));\n" if $do_setmagic;
d1682 7
d1698 1
a1698 1
    my($type) = @@_;
d1702 7
@


1.2
log
@perl 5.004_04
@
text
@d9 1
a9 1
B<xsubpp> [B<-v>] [B<-C++>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-nolinenumbers>] [B<-typemap typemap>]... file.xs
d62 5
a66 1
=back
d89 3
d97 1
a97 1
$XSUBPP_version = "1.9505";
d113 2
d130 1
d247 1
a247 1
	SCOPE
d314 14
d355 1
a355 1
	s/\s*;$//g unless /=/ ;
d359 1
a359 1
	$var_init = $1 if s/\s*(=.*)$//s ;
d382 1
a382 1
	if ($var_init =~ /^=\s*NO_INIT\s*;?\s*$/) {
d385 1
a385 1
	    &output_init($var_type, $var_num, "$var_name $var_init");
d398 4
d415 1
d418 1
d420 1
a420 2
	    $var_num = $args_match{$outarg};
	    &generate_output($var_types{$outarg}, $var_num, $outarg); 
d425 36
d777 4
d785 2
d903 3
d926 1
a926 1
    my($ret_type) = TidyType($_);
d936 1
a936 1
	unless $func_header =~ /^(?:([\w:]*)::)?(\w+)\s*\(\s*(.*?)\s*\)\s*$/s;
d939 1
d952 2
a953 1
    %XsubAliases = %XsubAliasValues = ();
d995 1
d1006 3
d1061 1
a1061 1
	process_keyword("INPUT|PREINIT|ALIAS|PROTOTYPE|SCOPE") ;
d1095 1
a1095 1
        process_keyword("INIT|ALIAS|PROTOTYPE") ;
d1128 1
d1143 2
a1144 1
	    &generate_output($ret_type, 0, 'RETVAL');
d1237 12
d1257 1
d1262 11
d1274 9
d1294 1
a1294 1
print Q<<"EOF" if defined $XsubAliases ;
d1302 1
a1302 1
print Q<<"EOF" if defined $XsubAliases ;
d1315 17
a1331 2
#    ST(0) = &sv_yes;
#    XSRETURN(1);
d1333 1
d1335 1
a1340 1

d1342 1
a1342 1
    local($type, $num, $init) = @@_;
d1345 14
a1358 1
    eval qq/print " $init\\\n"/;
d1420 1
d1422 1
d1425 1
d1427 1
d1430 1
d1435 1
a1435 1
    local($type, $num, $var) = @@_;
d1443 1
d1465 2
d1473 1
d1475 1
d1479 1
a1479 5
		    # to mortalize it. However, the extension may have
		    # returned the built-in perl value, which is
		    # read-only, thus not mortalizable. However, it is
		    # safe to leave it as it is, since it would be
		    # ignored by REFCNT_dec. Builtin values have REFCNT==0.
d1481 3
a1483 1
		    print "\tif (SvREFCNT(ST(0))) sv_2mortal(ST(0));\n";
d1492 2
d1498 2
@


1.1
log
@Initial revision
@
text
@d9 1
a9 1
B<xsubpp> [B<-v>] [B<-C++>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-typemap typemap>]... file.xs
d58 4
d78 1
a78 1
perl(1), perlxs(1), perlxstut(1), perlapi(1)
a81 2
# Global Constants
$XSUBPP_version = "1.935";
d83 1
d88 13
d103 1
a103 1
$usage = "Usage: xsubpp [-v] [-C++] [-except] [-prototypes] [-noversioncheck] [-s pattern] [-typemap typemap]... file.xs\n";
d111 1
d115 1
a115 1
    $spat = shift,	next SWITCH	if $flag eq 's';
d123 2
d137 1
d141 1
a141 4
# Check for VMS; Config.pm may not be installed yet, but this routine
# is built into VMS perl
if (defined(&VMS::Filespec::vmsify)) { $Is_VMS = 1; $pwd = $ENV{DEFAULT}; }
else                                 { $Is_VMS = 0; chomp($pwd = `pwd`);   }
d148 1
d190 1
d205 1
a205 1
            $proto = '$' unless $proto ;
d237 1
d249 43
d293 5
a297 1
    $_ = shift(@@line) while !/\S/ && @@line;
d301 1
d511 18
d659 1
a659 1
    $proto_letter{$type} or '$' ;
d697 1
a697 1
 * contents of $filename. Don't edit this file, edit $filename instead.
d706 3
a718 1

d733 1
d814 3
a816 1
    death ("Code is not inside a function")
d831 1
d833 1
d844 3
a846 1
        push (@@BootCode, $_, @@line, "") ;
d866 3
a868 1
    $Full_func_name = "${Packid}_$func_name";
d873 1
a873 1
	Warn("Warning: duplicate function definition '$func_name' detected");
d881 2
a882 1
	my $arg0 = ((defined($static) or $func_name =~ /^new/) ? "CLASS" : "THIS");
d903 1
a903 1
	    $proto_arg[$i+1] = '$' ;
d913 5
d922 1
a922 1
#XS(XS_${Packid}_$func_name)
d981 1
a981 1
	process_keyword("INPUT|PREINIT|ALIAS|PROTOTYPE") ;
d983 5
d989 1
a989 1
	    if (defined($static) or $func_name =~ /^new/) {
d1012 1
d1014 2
a1015 1
                process_keyword("INIT|ALIAS|PROTOTYPE") ;
d1020 1
d1034 1
a1034 1
			    if ($func_name =~ /^new/) {
d1040 1
a1040 1
			    if ($func_name =~ /^new/) {
d1068 7
d1100 2
a1101 1
    print Q<<EOF unless $PPCODE;
d1104 5
d1122 1
a1122 1
	if ($ProtoThisXSUB == 2) {
d1126 1
a1126 1
        elsif ($ProtoThisXSUB != 1) {
d1193 3
a1195 2
    print "\n    /* Initialisation Section */\n" ;
    print grep (s/$/\n/, @@BootCode) ;
d1265 1
a1265 1
	$subexpr =~ s/is not of (.*")/[arg %d] is not of $1, ix_$var + 1/g;
d1269 3
d1277 1
a1277 1
    } elsif ($expr !~ /^\t\$var =/) {
d1317 3
a1319 1
		if ($expr =~ /^\t\$arg = /) {
d1323 10
d1334 4
d1361 2
a1362 1
    exit ($Is_VMS ? ($errors ? 44 : 1) : $errors) ;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d9 1
a9 1
B<xsubpp> [B<-v>] [B<-C++>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-nolinenumbers>] [B<-typemap typemap>] [B<-object_capi>]... file.xs
d58 1
a58 9
=item B<-nolinenumbers>

Prevents the inclusion of `#line' directives in the output.

=item B<-object_capi>

Compile code as C in a PERL_OBJECT environment.

back
d74 1
a74 1
perl(1), perlxs(1), perlxstut(1)
d78 2
a80 1
use Cwd;
a81 3
use vars '%v';

use Config;
a84 13
# Global Constants

$XSUBPP_version = "1.9507";

my ($Is_VMS, $SymSet);
if ($^O eq 'VMS') {
    $Is_VMS = 1;
    # Establish set of global symbols with max length 28, since xsubpp
    # will later add the 'XS_' prefix.
    require ExtUtils::XSSymSet;
    $SymSet = new ExtUtils::XSSymSet 28;
}

d87 1
a87 1
$usage = "Usage: xsubpp [-v] [-C++] [-except] [-prototypes] [-noversioncheck] [-nolinenumbers] [-s pattern] [-typemap typemap]... file.xs\n";
a89 2
# mjn
$OBJ   = 1 if $Config{'ccflags'} =~ /PERL_OBJECT/i;
a94 1
$WantLineNumbers = 1 ;
d98 1
a98 1
    $spat = quotemeta shift,	next SWITCH	if $flag eq 's';
a103 1
    $WantCAPI = 1, next SWITCH    if $flag eq 'object_capi';
a105 2
    $WantLineNumbers = 0, next SWITCH	if $flag eq 'nolinenumbers';
    $WantLineNumbers = 1, next SWITCH	if $flag eq 'linenumbers';
a117 1
	or ($dir, $filename) = $ARGV[0] =~ m#(.*)\\(.*)#
d121 4
a124 1
$pwd = cwd();
a130 1

a171 1
        my $line_no = $. + 1; 
d186 1
a186 1
            $proto = "\$" unless $proto ;
a217 1
	SCOPE INTERFACE INTERFACE_MACRO C_ARGS
a228 43
if ($WantLineNumbers) {
    {
	package xsubpp::counter;
	sub TIEHANDLE {
	    my ($class, $cfile) = @@_;
	    my $buf = "";
	    $SECTION_END_MARKER = "#line --- \"$cfile\"";
	    $line_no = 1;
	    bless \$buf;
	}

	sub PRINT {
	    my $self = shift;
	    for (@@_) {
		$$self .= $_;
		while ($$self =~ s/^([^\n]*\n)//) {
		    my $line = $1;
		    ++ $line_no;
		    $line =~ s|^\#line\s+---(?=\s)|#line $line_no|;
		    print STDOUT $line;
		}
	    }
	}

	sub PRINTF {
	    my $self = shift;
	    my $fmt = shift;
	    $self->PRINT(sprintf($fmt, @@_));
	}

	sub DESTROY {
	    # Not necessary if we're careful to end with a "\n"
	    my $self = shift;
	    print STDOUT $$self;
	}
    }

    my $cfile = $filename;
    $cfile =~ s/\.xs$/.c/i or $cfile .= ".c";
    tie(*PSEUDO_STDOUT, 'xsubpp::counter', $cfile);
    select PSEUDO_STDOUT;
}

d230 1
a230 5
    # the "do" is required for right semantics
    do { $_ = shift(@@line) } while !/\S/ && @@line;
    
    print("#line ", $line_no[@@line_no - @@line -1], " \"$filename\"\n")
	if $WantLineNumbers && !/^\s*#\s*line\b/ && !/^#if XSubPPtmp/;
a233 15
    print "$xsubpp::counter::SECTION_END_MARKER\n" if $WantLineNumbers;
}

sub merge_section {
    my $in = '';
  
    while (!/\S/ && @@line) {
        $_ = shift(@@line);
    }
    
    for (;  defined($_) && !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	$in .= "$_\n";
    }
    chomp $in;
    return $in;
d263 1
a263 1
	s/\s*;$//g unless /[=;+].*\S/ ;
d267 1
a267 1
	$var_init = $1 if s/\s*([=;+].*)$//s ;
d290 1
a290 1
	if ($var_init =~ /^[=;]\s*NO_INIT\s*;?\s*$/) {
d293 1
a293 1
	    &output_init($var_type, $var_num, $var_name, $var_init);
a305 4
	if (/^\s*SETMAGIC\s*:\s*(ENABLE|DISABLE)\s*/) {
	    $DoSetMagic = ($1 eq "ENABLE" ? 1 : 0);
	    next;
	}
a318 1
	$var_num = $args_match{$outarg};
a320 1
	    print "\tSvSETMAGIC(ST(" , $var_num-1 , "));\n" if $DoSetMagic;
d322 2
a323 1
	    &generate_output($var_types{$outarg}, $var_num, $outarg, $DoSetMagic);
a327 36
sub C_ARGS_handler() {
    my $in = merge_section();
  
    TrimWhitespace($in);
    $func_args = $in;
} 

sub INTERFACE_MACRO_handler() {
    my $in = merge_section();
  
    TrimWhitespace($in);
    if ($in =~ /\s/) {		# two
        ($interface_macro, $interface_macro_set) = split ' ', $in;
    } else {
        $interface_macro = $in;
	$interface_macro_set = 'UNKNOWN_CVT'; # catch later
    }
    $interface = 1;		# local
    $Interfaces = 1;		# global
}

sub INTERFACE_handler() {
    my $in = merge_section();
  
    TrimWhitespace($in);
    
    foreach (split /[\s,]+/, $in) {
        $Interfaces{$_} = $_;
    }
    print Q<<"EOF";
#	XSFUNCTION = $interface_macro($ret_type,cv,XSANY.any_dptr);
EOF
    $interface = 1;		# local
    $Interfaces = 1;		# global
}

a442 18
sub SCOPE_handler ()
{
    death("Error: Only 1 SCOPE declaration allowed per xsub") 
        if $scope_in_this_xsub ++ ;

    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
		next unless /\S/;
		TrimWhitespace($_) ;
        if ($_ =~ /^DISABLE/i) {
		   $ScopeThisXSUB = 0 
        }
        elsif ($_ =~ /^ENABLE/i) {
		   $ScopeThisXSUB = 1 
        }
    }

}

d573 1
a573 1
    $proto_letter{$type} or "\$" ;
d611 1
a611 1
 * contents of $filename. Do not edit this file, edit $filename instead.
a619 3
print("#line 1 \"$filename\"\n")
    if $WantLineNumbers;

a622 4

    if ($OBJ) {
        s/#if(?:def\s|\s+defined)\s*(\(__cplusplus\)|__cplusplus)/#if defined(__cplusplus) && !defined(PERL_OBJECT)/;
    }
a626 2
print "$xsubpp::counter::SECTION_END_MARKER\n" if $WantLineNumbers;

d630 1
a644 1
	$Prefix = quotemeta $Prefix ;
d725 1
a725 3
    death ("Code is not inside a function"
	   ." (maybe last function was ended by a blank line "
	   ." followed by a a statement on column one?)")
a739 4
    undef($scope_in_this_xsub) ;
    undef($interface);
    $interface_macro = 'XSINTERFACE_FUNC' ;
    $interface_macro_set = 'XSINTERFACE_FUNC_SET' ;
a740 1
    $ScopeThisXSUB = 0;
d751 1
a751 3
	push (@@BootCode, "#line $line_no[@@line_no - @@line] \"$filename\"")
	  if $WantLineNumbers && $line[0] !~ /^\s*#\s*line\b/;
        push (@@BootCode, @@line, "") ;
d757 1
a757 1
    ($ret_type) = TidyType($_);
d767 1
a767 1
	unless $func_header =~ /^(?:([\w:]*)::)?(\w+)\s*\(\s*(.*?)\s*\)\s*(const)?\s*$/s;
a769 1
    $class = "$4 $class" if $4;
d771 1
a771 3
    ($clean_func_name = $func_name) =~ s/^$Prefix//;
    $Full_func_name = "${Packid}_$clean_func_name";
    if ($Is_VMS) { $Full_func_name = $SymSet->addsym($Full_func_name); }
d776 1
a776 1
	Warn("Warning: duplicate function definition '$clean_func_name' detected");
d780 1
a780 2
    %XsubAliases = %XsubAliasValues = %Interfaces = ();
    $DoSetMagic = 1;
d784 1
a784 2
	my $arg0 = ((defined($static) or $func_name eq 'new')
		    ? "CLASS" : "THIS");
d805 1
a805 1
	    $proto_arg[$i+1] = "\$" ;
a814 5
    $CODE = grep(/^\s*CODE\s*:/, @@line);
    # Detect CODE: blocks which use ST(n)= or XST_m*(n,v)
    #   to set explicit return values.
    $EXPLICIT_RETURN = ($CODE &&
		("@@line" =~ /(\bST\s*\([^;]*=) | (\bXST_m\w+\s*\()/x ));
a815 1
    $INTERFACE  = grep(/^\s*INTERFACE\s*:/,  @@line);
d819 1
a819 1
#XS(XS_${Full_func_name})
a825 3
    print Q<<"EOF" if $INTERFACE ;
#    dXSFUNCTION($ret_type);
EOF
d878 1
a878 1
	process_keyword("INPUT|PREINIT|INTERFACE_MACRO|C_ARGS|ALIAS|PROTOTYPE|SCOPE") ;
a879 5
	print Q<<"EOF" if $ScopeThisXSUB;
#   ENTER;
#   [[
EOF
	
d881 1
a881 1
	    if (defined($static) or $func_name eq 'new') {
a903 1

d905 1
a905 2

        process_keyword("INIT|ALIAS|PROTOTYPE|INTERFACE_MACRO|INTERFACE|C_ARGS") ;
a909 1
			print "\tLEAVE;\n" if $ScopeThisXSUB;
d923 1
a923 1
			    if ($func_name eq 'new') {
d929 1
a929 1
			    if ($func_name eq 'new') {
a936 1
			$func_name = 'XSFUNCTION' if $interface;
d951 1
a951 2
	    # RETVAL almost never needs SvSETMAGIC()
	    &generate_output($ret_type, 0, 'RETVAL', 0);
a956 7
	print Q<<"EOF" if $ScopeThisXSUB;
#   ]]
EOF
	print Q<<"EOF" if $ScopeThisXSUB and not $PPCODE;
#   LEAVE;
EOF

d982 1
a982 2
    if ($ret_type ne "void" or $EXPLICIT_RETURN) {
        print Q<<EOF unless $PPCODE;
a984 5
    } else {
        print Q<<EOF unless $PPCODE;
#    XSRETURN_EMPTY;
EOF
    }
d998 1
a998 1
	if ($ProtoThisXSUB eq 2) {
d1002 1
a1002 1
        elsif ($ProtoThisXSUB ne 1) {
a1030 12
    } 
    elsif ($interface) {
	while ( ($name, $value) = each %Interfaces) {
	    $name = "$Package\::$name" unless $name =~ /::/;
	    push(@@InitFileCode, Q<<"EOF");
#        cv = newXS(\"$name\", XS_$Full_func_name, file);
#        $interface_macro_set(cv,$value) ;
EOF
	    push(@@InitFileCode, Q<<"EOF") if $proto;
#        sv_setpv((SV*)cv$proto) ;
EOF
        }
a1038 1

a1042 11
EOF

if ($WantCAPI) {
print Q<<"EOF";
##ifdef PERL_CAPI
#XS(boot__CAPI_entry)
##else
EOF
}

print Q<<"EOF";
a1043 9
EOF

if ($WantCAPI) {
print Q<<"EOF";
##endif	/* PERL_CAPI */
EOF
}

print Q<<"EOF";
d1055 1
a1055 1
print Q<<"EOF" if defined $XsubAliases or defined $Interfaces ;
d1063 1
a1063 1
print Q<<"EOF" if defined $XsubAliases or defined $Interfaces ;
d1069 2
a1070 3
    print "\n    /* Initialisation Section */\n\n" ;
    @@line = @@BootCode;
    print_section();
d1075 2
a1076 17
#    XSRETURN_YES;
#]]
#
EOF

if ($WantCAPI) { 
print Q<<"EOF";
##ifdef PERL_CAPI
##define XSCAPI(name) void name(CV* cv, void* pPerl)
#
##ifdef __cplusplus
#extern "C"
##endif
#XSCAPI(boot_$Module_cname)
#[[
#    SetCPerlObj(pPerl);
#    boot__CAPI_entry(cv);
a1077 1
##endif	/* PERL_CAPI */
a1078 1
}
d1084 1
d1086 1
a1086 1
    local($type, $num, $var, $init) = @@_;
d1089 1
a1089 14
    if(  $init =~ /^=/  ) {
	eval qq/print "\\t$var $init\\n"/;
	warn $@@   if  $@@;
    } else {
	if(  $init =~ s/^\+//  &&  $num  ) {
	    &generate_init($type, $num, $var);
	} else {
	    eval qq/print "\\t$var;\\n"/;
	    warn $@@   if  $@@;
	    $init =~ s/^;//;
	}
	$deferred .= eval qq/"\\n\\t$init\\n"/;
	warn $@@   if  $@@;
    }
d1140 1
a1140 1
	$subexpr =~ s/is not of (.*\")/[arg %d] is not of $1, ix_$var + 1/g;
a1143 3
    if ($expr =~ m#/\*.*scope.*\*/#i) { # "scope" in C comments
    	$ScopeThisXSUB = 1;
    }
a1147 1
	    warn $@@   if  $@@;
d1149 1
a1149 2
	    warn $@@   if  $@@;
    } elsif ($ScopeThisXSUB or $expr !~ /^\t\$var =/) {
a1150 1
	    warn $@@   if  $@@;
a1151 1
	    warn $@@   if  $@@;
a1153 1
	    warn $@@   if  $@@;
d1158 1
a1158 1
    local($type, $num, $var, $do_setmagic) = @@_;
a1165 1
	    print "\tSvSETMAGIC($arg);\n" if $do_setmagic;
a1186 2
		warn $@@   if  $@@;
		print "\t\tSvSETMAGIC(ST(ix_$var));\n" if $do_setmagic;
d1189 1
a1189 11
		if ($expr =~ /^\t\$arg = new/) {
		    # We expect that $arg has refcnt 1, so we need to
		    # mortalize it.
		    eval "print qq\a$expr\a";
		    warn $@@   if  $@@;
		    print "\tsv_2mortal(ST(0));\n";
		    print "\tSvSETMAGIC(ST(0));\n" if $do_setmagic;
		}
		elsif ($expr =~ /^\s*\$arg\s*=/) {
		    # We expect that $arg has refcnt >=1, so we need
		    # to mortalize it!
a1190 1
		    warn $@@   if  $@@;
a1191 1
		    print "\tSvSETMAGIC(ST(0));\n" if $do_setmagic;
a1193 4
		    # Just hope that the entry would safely write it
		    # over an already mortalized value. By
		    # coincidence, something like $arg = &sv_undef
		    # works too.
a1195 2
		    warn $@@   if  $@@;
		    # new mortals don't have set magic
a1199 2
		warn $@@   if  $@@;
		print "\tSvSETMAGIC($arg);\n" if $do_setmagic;
d1217 1
a1217 2
#    exit ($Is_VMS ? ($errors ? 44 : 1) : $errors) ;
    exit ($errors ? 1 : 0);
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d9 1
a9 1
B<xsubpp> [B<-v>] [B<-C++>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-nolinenumbers>] [B<-nooptimize>] [B<-typemap typemap>] ... file.xs
a12 2
This compiler is typically run by the makefiles created by L<ExtUtils::MakeMaker>.

a25 3
Note that the C<XSOPT> MakeMaker option may be used to add these options to
any makefiles generated by MakeMaker.

d32 1
d62 1
a62 8
=item B<-nooptimize>

Disables certain optimizations.  The only optimization that is currently
affected is the use of I<target>s by the output C code (see L<perlguts>).
This may significantly slow down the generated code, but this is the way
B<xsubpp> of 5.005 and earlier operated.

=item B<-noinout>
d64 1
a64 1
Disable recognition of C<IN>, C<OUT_LIST> and C<INOUT_LIST> declarations.
d66 1
a66 5
=item B<-noargtypes>

Disable recognition of ANSI-like descriptions of function signature.

=back
d110 1
a110 1
$usage = "Usage: xsubpp [-v] [-C++] [-except] [-prototypes] [-noversioncheck] [-nolinenumbers] [-nooptimize] [-noinout] [-noargtypes] [-s pattern] [-typemap typemap]... file.xs\n";
a120 5
$WantOptimize = 1 ;

my $process_inout = 1;
my $process_argtypes = 1;

a129 1
    # XXX left this in for compat
d135 1
a135 7
    $WantOptimize = 0, next SWITCH	if $flag eq 'nooptimize';
    $WantOptimize = 1, next SWITCH	if $flag eq 'optimize';
    $process_inout = 0, next SWITCH	if $flag eq 'noinout';
    $process_inout = 1, next SWITCH	if $flag eq 'inout';
    $process_argtypes = 0, next SWITCH	if $flag eq 'noargtypes';
    $process_argtypes = 1, next SWITCH	if $flag eq 'argtypes';
    (print "xsubpp version $XSUBPP_version\n"), exit
a240 18
$bal = qr[(?:(?>[^()]+)|\((??{ $bal })\))*];	# ()-balanced
$cast = qr[(?:\(\s*SV\s*\*\s*\)\s*)?];		# Optional (SV*) cast
$size = qr[,\s* (??{ $bal }) ]x;		# Third arg (to setpvn)

foreach $key (keys %output_expr) {
    use re 'eval';

    my ($t, $with_size, $arg, $sarg) =
      ($output_expr{$key} =~
	 m[^ \s+ sv_set ( [iunp] ) v (n)? 	# Type, is_setpvn
	     \s* \( \s* $cast \$arg \s* ,
	     \s* ( (??{ $bal }) )		# Set from
	     ( (??{ $size }) )?			# Possible sizeof set-from
	     \) \s* ; \s* $
	  ]x);
    $targetable{$key} = [$t, $with_size, $arg, $sarg] if $t;
}

d247 1
a247 1
	SCOPE INTERFACE INTERFACE_MACRO C_ARGS POSTCALL
a257 13
my ($C_group_rex, $C_arg);
# Group in C (no support for comments or literals)
$C_group_rex = qr/ [({\[]
		   (?: (?> [^()\[\]{}]+ ) | (??{ $C_group_rex }) )*
		   [)}\]] /x ;
# Chunk in C without comma at toplevel (no comments):
$C_arg = qr/ (?: (?> [^()\[\]{},"']+ )
	     |   (??{ $C_group_rex })
	     |   " (?: (?> [^\\"]+ )
		   |   \\.
		   )* "		# String literal
	     |   ' (?: (?> [^\\']+ ) | \\. )* ' # Char literal
	     )* /xs;
d368 1
a368 2
	    if $arg_list{$var_name}++ 
	      or defined $arg_types{$var_name} and not $processing_arg_with_types;
d373 1
a373 11
	# XXXX This check is a safeguard against the unfinished conversion of
	# generate_init().  When generate_init() is fixed,
	# one can use 2-args map_type() unconditionally.
	if ($var_type =~ / \( \s* \* \s* \) /x) {
	  # Function pointers are not yet supported with &output_init!
	  print "\t" . &map_type($var_type, $var_name);
	  $name_printed = 1;
	} else {
	  print "\t" . &map_type($var_type);
	  $name_printed = 0;
	}
d382 1
a382 6
	if ($var_init =~ /^[=;]\s*NO_INIT\s*;?\s*$/
	    or $in_out{$var_name} and $in_out{$var_name} eq 'OUTLIST'
	    and $var_init !~ /\S/) {
	  if ($name_printed) {
	    print ";\n";
	  } else {
a383 1
	  }
d385 1
a385 1
	    &output_init($var_type, $var_num, $var_name, $var_init, $name_printed);
d388 1
a388 1
	    &generate_init($var_type, $var_num, $var_name, $name_printed);
a462 1
sub POSTCALL_handler() { print_section() } 
d832 1
a832 1

a898 1
    undef($RETVAL_no_return) ;
a900 5
    undef(@@arg_with_types) ;
    undef($processing_arg_with_types) ;
    undef(%arg_types) ;
    undef(@@in_out) ;
    undef(%in_out) ;
a903 1
    undef($prepush_done);
a907 1
    $xsreturn = 0;
a926 6
    $RETVAL_no_return = 1 if $ret_type =~ s/^NO_OUTPUT\s+//;

    # Allow one-line ANSI-like declaration
    unshift @@line, $2
      if $process_argtypes
	and $ret_type =~ s/^(.*?\w.*?)\s*\b(\w+\s*\(.*)/$1/s;
d936 1
a936 1
	unless $func_header =~ /^(?:([\w:]*)::)?(\w+)\s*\(\s*(.*?)\s*\)\s*(const)?\s*(;\s*)?$/s;
d955 1
a955 48
    $orig_args =~ s/\\\s*/ /g;		# process line continuations

    my %out_vars;
    if ($process_argtypes and $orig_args =~ /\S/) {
	my $args = "$orig_args ,";
	if ($args =~ /^( (??{ $C_arg }) , )* $ /x) {
	    @@args = ($args =~ /\G ( (??{ $C_arg }) ) , /xg);
	    for ( @@args ) {
		s/^\s+//;
		s/\s+$//;
		my $arg = $_;
		my $default;
		($arg, $default) = / ( [^=]* ) ( (?: = .* )? ) /x;
		my ($pre, $name) = ($arg =~ /(.*?) \s* \b(\w+) \s* $ /x);
		next unless length $pre;
		my $out_type;
		my $inout_var;
		if ($process_inout and s/^(IN|IN_OUTLIST|OUTLIST)\s+//) {
		    my $type = $1;
		    $out_type = $type if $type ne 'IN';
		    $arg =~ s/^(IN|IN_OUTLIST|OUTLIST)\s+//;
		}
		if (/\W/) {	# Has a type
		    push @@arg_with_types, $arg;
		    # warn "pushing '$arg'\n";
		    $arg_types{$name} = $arg;
		    $_ = "$name$default";
		}
		$out_vars{$_} = 1 if $out_type eq 'OUTLIST';
		push @@in_out, $name if $out_type;
		$in_out{$name} = $out_type if $out_type;
	    }
	} else {
	    @@args = split(/\s*,\s*/, $orig_args);
	    Warn("Warning: cannot parse argument list '$orig_args', fallback to split");
	}
    } else {
	@@args = split(/\s*,\s*/, $orig_args);
	for (@@args) {
	    if ($process_inout and s/^(IN|IN_OUTLIST|OUTLIST)\s+//) {
		my $out_type = $1;
		next if $out_type eq 'IN';
		$out_vars{$_} = 1 if $out_type eq 'OUTLIST';
		push @@in_out, $name;
		$in_out{$_} = $out_type;
	    }
	}
    }
d960 1
a960 1
	($report_args = "$arg0, $report_args") =~ s/^\w+, $/$arg0/;
d962 3
a964 5
    my $extra_args = 0;
    @@args_num = ();
    $num_args = 0;
    my $report_args = '';
    foreach $i (0 .. $#args) {
d967 2
a968 2
		    if ($args[$i] eq '' && $i == $#args) {
		        $report_args .= ", ...";
a972 6
	    if ($out_vars{$args[$i]}) {
		push @@args_num, undef;
	    } else {
		push @@args_num, ++$num_args;
		$report_args .= ", $args[$i]";
	    }
d974 1
a974 1
		    $extra_args++;
d981 4
a984 8
    $min_args = $num_args - $extra_args;
    $report_args =~ s/"/\\"/g;
    $report_args =~ s/^,\s+//;
    my @@func_args = @@args;
    shift @@func_args if defined($class);

    for (@@func_args) {
	s/^/&/ if $in_out{$_};
d986 1
a986 2
    $func_args = join(", ", @@func_args);
    @@args_match{@@args} = @@args_num;
a996 2
    $xsreturn = 1 if $EXPLICIT_RETURN;

d1027 1
a1027 1
#       Perl_croak(aTHX_ "Usage: %s($report_args)", GvNAME(CvGV(cv)));
d1032 1
a1032 1
#	Perl_croak(aTHX_ "Usage: $pname($report_args)");
d1083 1
a1083 1
		print "\n\tPerl_croak(aTHX_ \"$pname: not implemented yet\");\n";
d1087 1
a1087 1
			print "\t" . &map_type($ret_type, 'RETVAL') . ";\n"
a1090 2
			print "\tdXSTARG;\n"
				if $WantOptimize and $targetable{$type_kind{$ret_type}};
a1092 6
		if (@@arg_with_types) {
		    unshift @@line, @@arg_with_types, $_;
		    $_ = "";
		    $processing_arg_with_types = 1;
		    INPUT_handler() ;
		}
d1134 2
a1135 4
	$gotRETVAL = 0;		# 1 if RETVAL seen in OUTPUT section;
	undef $RETVAL_code ;	# code to set RETVAL (from OUTPUT section);
	# $wantRETVAL set if 'RETVAL =' autogenerated
	($wantRETVAL, $ret_type) = (0, 'void') if $RETVAL_no_return;
d1137 1
a1137 1
	process_keyword("POSTCALL|OUTPUT|ALIAS|PROTOTYPE"); 
d1143 2
a1144 28
	    my $t = $WantOptimize && $targetable{$type_kind{$ret_type}};
	    my $var = 'RETVAL';
	    my $type = $ret_type;

	    # 0: type, 1: with_size, 2: how, 3: how_size
	    if ($t and not $t->[1] and $t->[0] eq 'p') {
		# PUSHp corresponds to setpvn.  Treate setpv directly
		my $what = eval qq("$t->[2]");
		warn $@@ if $@@;

		print "\tsv_setpv(TARG, $what); XSprePUSH; PUSHTARG;\n";
		$prepush_done = 1;
	    }
	    elsif ($t) {
		my $what = eval qq("$t->[2]");
		warn $@@ if $@@;

		my $size = $t->[3];
		$size = '' unless defined $size;
		$size = eval qq("$size");
		warn $@@ if $@@;
		print "\tXSprePUSH; PUSH$t->[0]($what$size);\n";
		$prepush_done = 1;
	    }
	    else {
		# RETVAL almost never needs SvSETMAGIC()
		&generate_output($ret_type, 0, 'RETVAL', 0);
	    }
a1146 8
	$xsreturn = 1 if $ret_type ne "void";
	my $num = $xsreturn;
	my $c = @@in_out;
	print "\tXSprePUSH;" if $c and not $prepush_done;
	print "\tEXTEND(SP,$c);\n" if $c;
	$xsreturn += $c;
	generate_output($var_types{$_}, $num++, $_, 0, 1) for @@in_out;

d1179 1
a1179 1
#	Perl_croak(aTHX_ errbuf);
d1182 1
a1182 1
    if ($xsreturn) {
d1184 1
a1184 1
#    XSRETURN($xsreturn);
d1264 8
d1276 6
d1320 17
d1342 1
a1342 1
    local($type, $num, $var, $init, $name_printed) = @@_;
d1346 1
a1346 5
        if ($name_printed) {
	  eval qq/print " $init\\n"/;
	} else {
	  eval qq/print "\\t$var $init\\n"/;
	}
d1350 1
a1350 4
	    &generate_init($type, $num, $var, $name_printed);
	} elsif ($name_printed) {
	    print ";\n";
	    $init =~ s/^;//;
d1397 1
a1397 1
    blurt("Error: No INPUT definition for type '$type', typekind '$type_kind{$type}' found"), return
d1403 1
a1403 1
        blurt("Error: No INPUT definition for type '$subtype', typekind '$type_kind{$subtype}' found"), return
d1419 3
a1421 11
	    if ($name_printed) {
	      print ";\n";
	    } else {
	      eval qq/print "\\t$var;\\n"/;
	      warn $@@   if  $@@;
	    }
	    if ($defaults{$var} eq 'NO_INIT') {
		$deferred .= eval qq/"\\n\\tif (items >= $num) {\\n$expr;\\n\\t}\\n"/;
	    } else {
		$deferred .= eval qq/"\\n\\tif (items < $num)\\n\\t    $var = $defaults{$var};\\n\\telse {\\n$expr;\\n\\t}\\n"/;
	    }
d1424 2
a1425 6
	    if ($name_printed) {
	      print ";\n";
	    } else {
	      eval qq/print "\\t$var;\\n"/;
	      warn $@@   if  $@@;
	    }
a1428 2
	    die "panic: do not know how to handle this branch for function pointers"
	      if $name_printed;
d1435 1
a1435 1
    local($type, $num, $var, $do_setmagic, $do_push) = @@_;
d1442 1
a1442 1
	    print "\tsv_setpvn($arg, (char *)$var, $2 * sizeof($1));\n";
d1447 1
a1447 1
            blurt("Error: No OUTPUT definition for type '$type', typekind '$type_kind{$type}' found"), return
d1456 1
a1456 1
                blurt("Error: No OUTPUT definition for type '$subtype', typekind '$type_kind{$subtype}' found"), return
d1474 2
a1475 2
		    print "\tsv_2mortal(ST($num));\n";
		    print "\tSvSETMAGIC(ST($num));\n" if $do_setmagic;
a1495 7
	    elsif ($do_push) {
	        print "\tPUSHs(sv_newmortal());\n";
		$arg = "ST($num)";
		eval "print qq\a$expr\a";
		warn $@@   if  $@@;
		print "\tSvSETMAGIC($arg);\n" if $do_setmagic;
	    }
d1505 1
a1505 1
    my($type, $varname) = @@_;
a1508 7
    if ($varname) {
      if ($varname && $type =~ / \( \s* \* (?= \s* \) ) /xg) {
	(substr $type, pos $type, 0) = " $varname ";
      } else {
	$type .= "\t$varname";
      }
    }
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d112 1
a112 1
$XSUBPP_version = "1.9508";
d291 1
a291 1
	CLEANUP ALIAS ATTRS PROTOTYPES PROTOTYPE VERSIONCHECK INCLUDE
d421 1
a421 1
	my ($var_type, $var_addr, $var_name) = /^(.*?[^&\s])\s*(\&?)\s*\b(\w+)$/s
d447 4
a450 1
	$func_args =~ s/\b($var_name)\b/&$1/ if $var_addr;
d452 1
a452 1
	    or $in_out{$var_name} and $in_out{$var_name} =~ /^OUT/
a496 2
	delete $in_out{$outarg} 	# No need to auto-OUTPUT 
	  if exists $in_out{$outarg} and $in_out{$outarg} =~ /OUT$/;
a575 9
sub ATTRS_handler ()
{
    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	next unless /\S/;
	TrimWhitespace($_) ;
        push @@Attributes, $_;
    }
}

a849 1
firstmodule:
a850 17
    if (/^=/) {
        my $podstartline = $.;
    	do {
	    if (/^=cut\s*$/) {
		print("/* Skipped embedded POD. */\n");
		printf("#line %d \"$filename\"\n", $. + 1)
		  if $WantLineNumbers;
		next firstmodule
	    }

	} while (<$FH>);
	# At this point $. is at end of file so die won't state the start
	# of the problem, and as we haven't yet read any lines &death won't
	# show the correct line in the message either.
	die ("Error: Unterminated pod in $filename, line $podstartline\n")
	  unless $lastline;
    }
a888 10
	# Skip embedded PODs 
	while ($lastline =~ /^=/) {
    	    while ($lastline = <$FH>) {
	    	last if ($lastline =~ /^=cut\s*$/);
	    }
	    death ("Error: Unterminated pod") unless $lastline;
	    $lastline = <$FH>;
	    chomp $lastline;
	    $lastline =~ s/^\s+$//;
	}
d969 1
d981 1
a981 1
    undef(@@outlist) ;
d1042 1
a1042 1
    %XsubAliases = %XsubAliasValues = %Interfaces = @@Attributes = ();
d1047 1
a1047 1
    my %only_outlist;
d1062 1
a1062 1
		if ($process_inout and s/^(IN|IN_OUTLIST|OUTLIST|OUT|IN_OUT)\s+//) {
d1065 1
a1065 1
		    $arg =~ s/^(IN|IN_OUTLIST|OUTLIST|OUT|IN_OUT)\s+//;
d1073 2
a1074 2
		$only_outlist{$_} = 1 if $out_type eq "OUTLIST";
		push @@outlist, $name if $out_type =~ /OUTLIST$/;
d1084 1
a1084 1
	    if ($process_inout and s/^(IN|IN_OUTLIST|OUTLIST|IN_OUT|OUT)\s+//) {
d1087 2
a1088 2
		$only_outlist{$_} = 1 if $out_type eq "OUTLIST";
		push @@outlist, $name if $out_type =~ /OUTLIST$/;
d1112 1
a1112 1
	    if ($only_outlist{$args[$i]}) {
d1213 1
a1213 1
	process_keyword("INPUT|PREINIT|INTERFACE_MACRO|C_ARGS|ALIAS|ATTRS|PROTOTYPE|SCOPE") ;
d1255 1
a1255 1
        process_keyword("INIT|ALIAS|ATTRS|PROTOTYPE|INTERFACE_MACRO|INTERFACE|C_ARGS") ;
d1299 1
a1299 4
	process_keyword("POSTCALL|OUTPUT|ALIAS|ATTRS|PROTOTYPE"); 

	&generate_output($var_types{$_}, $args_match{$_}, $_, $DoSetMagic)
	  for grep $in_out{$_} =~ /OUT$/, keys %in_out;
d1337 1
a1337 1
	my $c = @@outlist;
d1341 1
a1341 1
	generate_output($var_types{$_}, $num++, $_, 0, 1) for @@outlist;
d1344 1
a1344 1
	process_keyword("CLEANUP|ALIAS|ATTRS|PROTOTYPE") ;
a1433 6
    elsif (@@Attributes) {
	    push(@@InitFileCode, Q<<"EOF");
#        cv = newXS(\"$pname\", XS_$Full_func_name, file);
#        apply_attrs_string("$Package", cv, "@@Attributes", 0);
EOF
    }
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a36 4
=item B<-hiertype>

Retains '::' in type names so that C++ hierachical types can be mapped.

d103 1
a103 1
use vars qw($cplusplus $hiertype);
d127 3
a129 1
$proto_re = "[" . quotemeta('\$%&*@@;[]') . "]" ;
a136 1
$Overload = 0;
a145 1
    $hiertype  = 1,	next SWITCH	if $flag eq 'hiertype';
d151 1
a151 1
    next SWITCH                         if $flag eq 'object_capi';
d201 1
a201 1

d216 1
a216 1
    next unless -f $typemap ;
d218 1
a218 1
    warn("Warning: ignoring non-text typemap file '$typemap'\n"), next
d220 1
a220 1
    open(TYPEMAP, $typemap)
d227 1
a227 1
        my $line_no = $. + 1;
d243 1
a243 1
            warn("Warning: File '$typemap' Line $. '$line' Invalid prototype '$proto'\n")
d265 1
a265 1
    $input_expr{$key} =~ s/;*\s+\z//;
d290 1
a290 1
	REQUIRE BOOT CASE PREINIT INPUT INIT CODE PPCODE OUTPUT
d292 1
a292 1
	SCOPE INTERFACE INTERFACE_MACRO C_ARGS POSTCALL OVERLOAD
d363 1
a363 1

d374 1
a374 1

d378 1
a378 1

d391 1
a391 1
    &{"${kwd}_handler"}()
d407 1
a407 1
	next unless /\S/;	# skip blank lines
a414 8
	# Process the length(foo) declarations
	if (s/^([^=]*)\blength\(\s*(\w+)\s*\)\s*$/$1 XSauto_length_of_$2=NO_INIT/x) {
	  print "\tSTRLEN\tSTRLEN_length_of_$2;\n";
	  $lengthof{$2} = $name;
	  # $islengthof{$name} = $1;
	  $deferred .= "\n\tXSauto_length_of_$2 = STRLEN_length_of_$2;";
	}

d426 2
a427 2
	    if $arg_list{$var_name}++
	      or defined $argtype_seen{$var_name} and not $processing_arg_with_types;
d445 1
a445 1
        $proto_arg[$var_num] = ProtoString($var_type)
d494 1
a494 1
	delete $in_out{$outarg} 	# No need to auto-OUTPUT
d501 1
a501 1

d504 1
a504 1
}
d508 1
a508 1

d522 1
a522 1

d524 1
a524 1

d535 4
a538 4
sub CLEANUP_handler() { print_section() }
sub PREINIT_handler() { print_section() }
sub POSTCALL_handler() { print_section() }
sub INIT_handler()    { print_section() }
d558 1
a558 1

a592 15
sub OVERLOAD_handler()
{
    for (;  !/^$BLOCK_re/o;  $_ = shift(@@line)) {
	next unless /\S/;
	TrimWhitespace($_) ;
        while ( s/^\s*([\w:"\\)\+\-\*\/\%\<\>\.\&\|\^\!\~\{\}\=]+)\s*//) {
	    $Overload = 1 unless $Overload;
	    my $overload = "$Package\::(".$1 ;
            push(@@InitFileCode,
    	     "        newXS(\"$overload\", XS_$Full_func_name, file$proto);\n");
        }
    }

}

d608 1
a608 1
        unless $XSUBPP_version >= $Ver ;
d615 1
a615 1

d617 1
a617 1

d621 1
a621 1

d624 1
a624 1

d631 1
a631 1
    death("Error: Only 1 PROTOTYPE definition allowed per xsub")
d639 1
a639 1
	   $ProtoThisXSUB = 0
d642 1
a642 1
	   $ProtoThisXSUB = 1
d662 1
a662 1
    death("Error: Only 1 SCOPE declaration allowed per xsub")
d669 1
a669 1
		   $ScopeThisXSUB = 0
d672 1
a672 1
		   $ScopeThisXSUB = 1
d681 1
a681 1
    # DISABLE
d698 1
a698 1

d700 1
a700 1

d723 1
a723 1

d728 1
a728 1

d737 1
a737 1
    # Prime the pump by reading the first
d747 1
a747 1

d749 1
a749 1

d757 1
a757 1

d845 1
a845 1
 * This file was generated automatically by xsubpp version $XSUBPP_version from the
d848 1
a848 1
 *	ANY CHANGES MADE HERE WILL BE LOST!
d853 1
a853 1

d880 3
d915 1
a915 1
	# Skip embedded PODs
d999 1
a999 1
	   ." followed by a statement on column one?)")
d1013 1
a1013 2
    undef(@@fake_INPUT_pre) ;	# For length(s) generated variables
    undef(@@fake_INPUT) ;
d1015 1
a1015 1
    undef(%argtype_seen) ;
a1017 2
    undef(%lengthof) ;
    # undef(%islengthof) ;
d1082 1
a1082 1
    my %only_C_inlist;	# Not in the signature of Perl function
d1090 4
a1093 4
		my ($arg, $default) = / ( [^=]* ) ( (?: = .* )? ) /x;
		my ($pre, $name) = ($arg =~ /(.*?) \s*
					     \b ( \w+ | length\( \s*\w+\s* \) )
					     \s* $ /x);
a1100 8
		    $pre =~ s/^(IN|IN_OUTLIST|OUTLIST|OUT|IN_OUT)\s+//;
		}
		my $islength;
		if ($name =~ /^length\( \s* (\w+) \s* \)\z/x) {
		  $name = "XSauto_length_of_$1";
		  $islength = 1;
		  die "Default value on length() argument: `$_'"
		    if length $default;
d1102 2
a1103 6
		if (length $pre or $islength) {	# Has a type
		    if ($islength) {
		      push @@fake_INPUT_pre, $arg;
		    } else {
		      push @@fake_INPUT, $arg;
		    }
d1105 2
a1106 2
		    $argtype_seen{$name}++;
		    $_ = "$name$default"; # Assigns to @@args
d1108 1
a1108 1
		$only_C_inlist{$_} = 1 if $out_type eq "OUTLIST" or $islength;
d1122 1
a1122 1
		$only_C_inlist{$_} = 1 if $out_type eq "OUTLIST";
d1147 1
a1147 1
	    if ($only_C_inlist{$args[$i]}) {
a1185 1
#XS(XS_${Full_func_name}); /* prototype to pass -Wmissing-prototypes */
d1211 1
a1211 1
    if ($ALIAS)
d1216 1
a1216 1
    else
a1221 9
    #gcc -Wall: if an xsub has no arguments and PPCODE is used
    #it is likely none of ST, XSRETURN or XSprePUSH macros are used
    #hence `ax' (setup by dXSARGS) is unused
    #XXX: could breakup the dXSARGS; into dSP;dMARK;dITEMS
    #but such a move could break third-party extensions
    print Q<<"EOF" if $PPCODE and $num_args == 0;
#   PERL_UNUSED_VAR(ax); /* -Wall */
EOF

d1248 1
a1248 1
	process_keyword("INPUT|PREINIT|INTERFACE_MACRO|C_ARGS|ALIAS|ATTRS|PROTOTYPE|SCOPE|OVERLOAD") ;
d1282 2
a1283 2
		if (@@fake_INPUT or @@fake_INPUT_pre) {
		    unshift @@line, @@fake_INPUT_pre, @@fake_INPUT, $_;
d1290 1
a1290 1
        process_keyword("INIT|ALIAS|ATTRS|PROTOTYPE|INTERFACE_MACRO|INTERFACE|C_ARGS|OVERLOAD") ;
d1334 1
a1334 1
	process_keyword("POSTCALL|OUTPUT|ALIAS|ATTRS|PROTOTYPE|OVERLOAD");
d1382 1
a1382 1
	process_keyword("CLEANUP|ALIAS|ATTRS|PROTOTYPE|OVERLOAD") ;
d1449 1
a1449 1
                $s = '';
d1452 1
a1452 1
            push @@proto_arg, "$s\@@"
d1454 1
a1454 1

d1460 1
a1460 1
	$XsubAliases{$pname} = 0
d1471 1
a1471 1
    }
a1504 1
#XS(boot_$Module_cname); /* prototype to pass -Wmissing-prototypes */
a1510 5
EOF

#-Wall: if there is no $Full_func_name there are no xsubs in this .xs
#so `file' is unused
print Q<<"EOF" if $Full_func_name;
d1512 1
a1514 2
print Q "#\n";

a1525 12
print Q<<"EOF" if ($Overload);
#    {
#        /* create the package stash */
#        HV *hv = get_hv(\"$Package\::OVERLOAD\",TRUE);
#        SV *sv = *hv_fetch(hv,"register",8,1);
#        sv_inc(sv);
#        SvSETMAGIC(sv);
#        /* Make it findable via fetchmethod */
#        newXS(\"$Package\::()\", NULL, file);
#    }
EOF

d1546 1
a1546 1
warn("Please specify prototyping behavior for $filename (see perlxs manual)\n")
d1581 1
a1581 1

d1585 2
a1586 2
sub blurt
{
d1588 1
a1588 1
    $errors ++
d1605 1
a1605 1
    blurt("Error: '$type' not in typemap"), return
d1612 1
a1612 8
    if ($tk eq 'T_PV' and exists $lengthof{$var}) {
      print "\t$var" unless $name_printed;
      print " = ($type)SvPV($arg, STRLEN_length_of_$var);\n";
      die "default value not supported with length(NAME) supplied"
	if defined $defaults{$var};
      return;
    }
    $type =~ tr/:/_/ unless $hiertype;
d1617 1
a1617 1
        blurt("Error: '$subtype' not in typemap"), return
a1621 1
        $subexpr =~ s/\$type/\$subtype/g;
d1647 1
a1647 1
    } elsif ($ScopeThisXSUB or $expr !~ /^\s*\$var =/) {
a1671 1
            print "\t$arg = sv_newmortal();\n";
d1744 1
a1744 2
    # C++ has :: in types too so skip this
    $type =~ tr/:/_/ unless $hiertype;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a139 1
$Fallback = 'PL_sv_undef';
d296 1
a296 1
	SCOPE INTERFACE INTERFACE_MACRO C_ARGS POSTCALL OVERLOAD FALLBACK
a619 18
sub FALLBACK_handler()
{
    # the rest of the current line should contain either TRUE, 
    # FALSE or UNDEF

    TrimWhitespace($_) ;
    my %map = (
	TRUE => "PL_sv_yes", 1 => "PL_sv_yes",
	FALSE => "PL_sv_no", 0 => "PL_sv_no",
	UNDEF => "PL_sv_undef",
    ) ;

    # check for valid FALLBACK value
    death ("Error: FALLBACK: TRUE/FALSE/UNDEF") unless exists $map{uc $_} ;

    $Fallback = $map{uc $_} ;
}

d891 1
a891 13
		# We can't just write out a /* */ comment, as our embedded
		# POD might itself be in a comment. We can't put a /**/
		# comment inside #if 0, as the C standard says that the source
		# file is decomposed into preprocessing characters in the stage
		# before preprocessing commands are executed.
		# I don't want to leave the text as barewords, because the spec
		# isn't clear whether macros are expanded before or after
		# preprocessing commands are executed, and someone pathological
		# may just have defined one of the 3 words as a macro that does
		# something strange. Multiline strings are illegal in C, so
		# the "" we write must be a string literal. And they aren't
		# concatenated until 2 steps later, so we are safe.
		print("#if 0\n  \"Skipped embedded POD.\"\n#endif\n");
d1056 1
a1056 1
    while ($kwd = check_keyword("REQUIRE|PROTOTYPES|FALLBACK|VERSIONCHECK|INCLUDE")) {
d1425 1
a1425 5
	# (PP)CODE set different values of SP; reset to PPCODE's with 0 output
	print "\tXSprePUSH;"    if $c and not $prepush_done;
	# Take into account stuff already put on stack
	print "\t++SP;"         if $c and not $prepush_done and $xsreturn;
	# Now SP corresponds to ST($xsreturn), so one can combine PUSH and ST()
a1544 19
if ($Overload) # make it findable with fetchmethod
{
    
    print Q<<"EOF"; 
#XS(XS_${Packid}_nil); /* prototype to pass -Wmissing-prototypes */
#XS(XS_${Packid}_nil)
#{
#   XSRETURN_EMPTY;
#}
#
EOF
    unshift(@@InitFileCode, <<"MAKE_FETCHMETHOD_WORK");
    /* Making a sub named "${Package}::()" allows the package */
    /* to be findable via fetchmethod(), and causes */
    /* overload::Overloaded("${Package}") to return true. */
    newXS("${Package}::()", XS_${Packid}_nil, file$proto);
MAKE_FETCHMETHOD_WORK
}

d1583 9
a1591 9
#    /* register the overloading (type 'A') magic */
#    PL_amagic_generation++;
#    /* The magic for overload gets a GV* via gv_fetchmeth as */
#    /* mentioned above, and looks in the SV* slot of it for */
#    /* the "fallback" status. */
#    sv_setsv(
#        get_sv( "${Package}::()", TRUE ),
#        $Fallback
#    );
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d9 1
a9 1
B<xsubpp> [B<-v>] [B<-C++>] [B<-csuffix csuffix>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-nolinenumbers>] [B<-nooptimize>] [B<-typemap typemap>] ... file.xs
a36 6
=item B<-csuffix csuffix>

Set the suffix used for the generated C or C++ code.  Defaults to '.c'
(even with B<-C++>), but some platforms might want to have e.g. '.cpp'.
Don't forget the '.' from the front.

d129 1
a129 1
$usage = "Usage: xsubpp [-v] [-C++] [-csuffix csuffix] [-except] [-prototypes] [-noversioncheck] [-nolinenumbers] [-nooptimize] [-noinout] [-noargtypes] [-s pattern] [-typemap typemap]... file.xs\n";
a143 1
my $csuffix = '.c';
a149 1
    $csuffix   = shift,	next SWITCH	if $flag eq 'csuffix';
d360 1
a360 1
    $cfile =~ s/\.xs$/$csuffix/i or $cfile .= $csuffix;
a1061 1
    undef($externC);
d1115 1
a1115 2
    $externC = 1 if $ret_type =~ s/^extern "C"\s+//;
    $static  = 1 if $ret_type =~ s/^static\s+//;
a1253 2
    $externC = $externC ? qq[extern "C"] : "";

a1255 1
#$externC
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a2 42
require 5.002;
use ExtUtils::ParseXS qw(process_file);
use Getopt::Long;

my %args = ();

my $usage = "Usage: xsubpp [-v] [-csuffix csuffix] [-except] [-prototypes] [-noversioncheck] [-nolinenumbers] [-nooptimize] [-noinout] [-noargtypes] [-s pattern] [-typemap typemap]... file.xs\n";

Getopt::Long::Configure qw(no_auto_abbrev no_ignore_case);

@@ARGV = grep {$_ ne '-C++'} @@ARGV;  # Allow -C++ for backward compatibility
GetOptions(\%args, qw(hiertype!
		      prototypes!
		      versioncheck!
		      linenumbers!
		      optimize!
		      inout!
		      argtypes!
		      object_capi!
		      except!
		      v
		      typemap=s@@
		      output=s
		      s=s
		      csuffix=s
		     ))
  or die $usage;

if ($args{v}) {
  print "xsubpp version $ExtUtils::ParseXS::VERSION\n";
  exit;
}

@@ARGV == 1 or die $usage;

$args{filename} = shift @@ARGV;

process_file(%args);
exit( ExtUtils::ParseXS::errors() ? 1 : 0 );

__END__

d9 1
a9 1
B<xsubpp> [B<-v>] [B<-except>] [B<-s pattern>] [B<-prototypes>] [B<-noversioncheck>] [B<-nolinenumbers>] [B<-nooptimize>] [B<-typemap typemap>] [B<-output filename>]... file.xs
a25 2
It will also use a default typemap installed as C<ExtUtils::typemap>.

d33 10
d45 1
a45 1
Retains '::' in type names so that C++ hierarchical types can be mapped.
a56 5
=item B<-output filename>

Specifies the name of the output file to generate.  If no file is
specified, output will be written to standard output.

a90 6
=item B<-C++>

Currently doesn't do anything at all.  This flag has been a no-op for
many versions of perl, at least as far back as perl5.003_07.  It's
allowed here for backwards compatibility.

d99 1
a99 2
Originally by Larry Wall.  Turned into the C<ExtUtils::ParseXS> module
by Ken Williams.
d103 1
a103 1
See the file F<Changes>.
d107 1
a107 1
perl(1), perlxs(1), perlxstut(1), ExtUtils::ParseXS
d111 1798
@


