head	1.10;
access;
symbols
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.10
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.8
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.6
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.4
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.6.0.10
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.8
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.6
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.10
date	2010.09.24.14.59.38;	author millert;	state dead;
branches;
next	1.9;

1.9
date	2009.10.12.18.24.40;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.11;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2006.03.28.19.23.06;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.37;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.30;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.30;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.52;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.57.28;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.05;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.42;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.28;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.03;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.44;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.33;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.50;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.10
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package ExtUtils::MM_Win32;

use strict;


=head1 NAME

ExtUtils::MM_Win32 - methods to override UN*X behaviour in ExtUtils::MakeMaker

=head1 SYNOPSIS

 use ExtUtils::MM_Win32; # Done internally by ExtUtils::MakeMaker if needed

=head1 DESCRIPTION

See ExtUtils::MM_Unix for a documentation of the methods provided
there. This package overrides the implementation of these methods, not
the semantics.

=cut 

use ExtUtils::MakeMaker::Config;
use File::Basename;
use File::Spec;
use ExtUtils::MakeMaker qw( neatvalue );

require ExtUtils::MM_Any;
require ExtUtils::MM_Unix;
our @@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
our $VERSION = '6.55_02';

$ENV{EMXSHELL} = 'sh'; # to run `commands`

my $BORLAND = $Config{'cc'} =~ /^bcc/i ? 1 : 0;
my $GCC     = $Config{'cc'} =~ /^gcc/i ? 1 : 0;


=head2 Overridden methods

=over 4

=item B<dlsyms>

=cut

sub dlsyms {
    my($self,%attribs) = @@_;

    my($funcs) = $attribs{DL_FUNCS} || $self->{DL_FUNCS} || {};
    my($vars)  = $attribs{DL_VARS} || $self->{DL_VARS} || [];
    my($funclist) = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
    my($imports)  = $attribs{IMPORTS} || $self->{IMPORTS} || {};
    my(@@m);

    if (not $self->{SKIPHASH}{'dynamic'}) {
	push(@@m,"
$self->{BASEEXT}.def: Makefile.PL
",
     q!	$(PERLRUN) -MExtUtils::Mksymlists \\
     -e "Mksymlists('NAME'=>\"!, $self->{NAME},
     q!\", 'DLBASE' => '!,$self->{DLBASE},
     # The above two lines quoted differently to work around
     # a bug in the 4DOS/4NT command line interpreter.  The visible
     # result of the bug was files named q('extension_name',) *with the
     # single quotes and the comma* in the extension build directories.
     q!', 'DL_FUNCS' => !,neatvalue($funcs),
     q!, 'FUNCLIST' => !,neatvalue($funclist),
     q!, 'IMPORTS' => !,neatvalue($imports),
     q!, 'DL_VARS' => !, neatvalue($vars), q!);"
!);
    }
    join('',@@m);
}

=item replace_manpage_separator

Changes the path separator with .

=cut

sub replace_manpage_separator {
    my($self,$man) = @@_;
    $man =~ s,/+,.,g;
    $man;
}


=item B<maybe_command>

Since Windows has nothing as simple as an executable bit, we check the
file extension.

The PATHEXT env variable will be used to get a list of extensions that
might indicate a command, otherwise .com, .exe, .bat and .cmd will be
used by default.

=cut

sub maybe_command {
    my($self,$file) = @@_;
    my @@e = exists($ENV{'PATHEXT'})
          ? split(/;/, $ENV{PATHEXT})
	  : qw(.com .exe .bat .cmd);
    my $e = '';
    for (@@e) { $e .= "\Q$_\E|" }
    chop $e;
    # see if file ends in one of the known extensions
    if ($file =~ /($e)$/i) {
	return $file if -e $file;
    }
    else {
	for (@@e) {
	    return "$file$_" if -e "$file$_";
	}
    }
    return;
}


=item B<init_DIRFILESEP>

Using \ for Windows.

=cut

sub init_DIRFILESEP {
    my($self) = shift;

    # The ^ makes sure its not interpreted as an escape in nmake
    $self->{DIRFILESEP} = $self->is_make_type('nmake') ? '^\\' :
                          $self->is_make_type('dmake') ? '\\\\'
                                                       : '\\';
}

=item B<init_others>

Override some of the Unix specific commands with portable
ExtUtils::Command ones.

Also provide defaults for LD and AR in case the %Config values aren't
set.

LDLOADLIBS's default is changed to $Config{libs}.

Adjustments are made for Borland's quirks needing -L to come first.

=cut

sub init_others {
    my ($self) = @@_;

    $self->{NOOP}     ||= 'rem';
    $self->{DEV_NULL} ||= '> NUL';

    $self->{FIXIN}    ||= $self->{PERL_CORE} ? 
      "\$(PERLRUN) $self->{PERL_SRC}/win32/bin/pl2bat.pl" : 
      'pl2bat.bat';

    $self->{LD}     ||= 'link';
    $self->{AR}     ||= 'lib';

    $self->SUPER::init_others;

    # Setting SHELL from $Config{sh} can break dmake.  Its ok without it.
    delete $self->{SHELL};

    $self->{LDLOADLIBS} ||= $Config{libs};
    # -Lfoo must come first for Borland, so we put it in LDDLFLAGS
    if ($BORLAND) {
        my $libs = $self->{LDLOADLIBS};
        my $libpath = '';
        while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /) {
            $libpath .= ' ' if length $libpath;
            $libpath .= $1;
        }
        $self->{LDLOADLIBS} = $libs;
        $self->{LDDLFLAGS} ||= $Config{lddlflags};
        $self->{LDDLFLAGS} .= " $libpath";
    }

    return 1;
}


=item init_platform

Add MM_Win32_VERSION.

=item platform_constants

=cut

sub init_platform {
    my($self) = shift;

    $self->{MM_Win32_VERSION} = $VERSION;
}

sub platform_constants {
    my($self) = shift;
    my $make_frag = '';

    foreach my $macro (qw(MM_Win32_VERSION))
    {
        next unless defined $self->{$macro};
        $make_frag .= "$macro = $self->{$macro}\n";
    }

    return $make_frag;
}


=item special_targets

Add .USESHELL target for dmake.

=cut

sub special_targets {
    my($self) = @@_;

    my $make_frag = $self->SUPER::special_targets;

    $make_frag .= <<'MAKE_FRAG' if $self->is_make_type('dmake');
.USESHELL :
MAKE_FRAG

    return $make_frag;
}


=item static_lib

Changes how to run the linker.

The rest is duplicate code from MM_Unix.  Should move the linker code
to its own method.

=cut

sub static_lib {
    my($self) = @@_;
    return '' unless $self->has_link_code;

    my(@@m);
    push(@@m, <<'END');
$(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
	$(RM_RF) $@@
END

    # If this extension has its own library (eg SDBM_File)
    # then copy that to $(INST_STATIC) and add $(OBJECT) into it.
    push @@m, <<'MAKE_FRAG' if $self->{MYEXTLIB};
	$(CP) $(MYEXTLIB) $@@
MAKE_FRAG

    push @@m,
q{	$(AR) }.($BORLAND ? '$@@ $(OBJECT:^"+")'
			  : ($GCC ? '-ru $@@ $(OBJECT)'
			          : '-out:$@@ $(OBJECT)')).q{
	$(CHMOD) $(PERM_RWX) $@@
	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)\extralibs.ld
};

    # Old mechanism - still available:
    push @@m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};
	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)\ext.libs
MAKE_FRAG

    join('', @@m);
}


=item dynamic_lib

Complicated stuff for Win32 that I don't understand. :(

=cut

sub dynamic_lib {
    my($self, %attribs) = @@_;
    return '' unless $self->needs_linking(); #might be because of a subdir

    return '' unless $self->has_link_code;

    my($otherldflags) = $attribs{OTHERLDFLAGS} || ($BORLAND ? 'c0d32.obj': '');
    my($inst_dynamic_dep) = $attribs{INST_DYNAMIC_DEP} || "";
    my($ldfrom) = '$(LDFROM)';
    my(@@m);

# one thing for GCC/Mingw32:
# we try to overcome non-relocateable-DLL problems by generating
#    a (hopefully unique) image-base from the dll's name
# -- BKS, 10-19-1999
    if ($GCC) { 
	my $dllname = $self->{BASEEXT} . "." . $self->{DLEXT};
	$dllname =~ /(....)(.{0,4})/;
	my $baseaddr = unpack("n", $1 ^ $2);
	$otherldflags .= sprintf("-Wl,--image-base,0x%x0000 ", $baseaddr);
    }

    push(@@m,'
# This section creates the dynamically loadable $(INST_DYNAMIC)
# from $(OBJECT) and possibly $(MYEXTLIB).
OTHERLDFLAGS = '.$otherldflags.'
INST_DYNAMIC_DEP = '.$inst_dynamic_dep.'

$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
');
    if ($GCC) {
      push(@@m,  
       q{	dlltool --def $(EXPORT_LIST) --output-exp dll.exp
	$(LD) -o $@@ -Wl,--base-file -Wl,dll.base $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) dll.exp
	dlltool --def $(EXPORT_LIST) --base-file dll.base --output-exp dll.exp
	$(LD) -o $@@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) dll.exp });
    } elsif ($BORLAND) {
      push(@@m,
       q{	$(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) }.$ldfrom.q{,$@@,,}
       .($self->is_make_type('dmake')
                ? q{$(PERL_ARCHIVE:s,/,\,) $(LDLOADLIBS:s,/,\,) }
		 .q{$(MYEXTLIB:s,/,\,),$(EXPORT_LIST:s,/,\,)}
		: q{$(subst /,\,$(PERL_ARCHIVE)) $(subst /,\,$(LDLOADLIBS)) }
		 .q{$(subst /,\,$(MYEXTLIB)),$(subst /,\,$(EXPORT_LIST))})
       .q{,$(RESFILES)});
    } else {	# VC
      push(@@m,
       q{	$(LD) -out:$@@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) }
      .q{$(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) -def:$(EXPORT_LIST)});

      # Embed the manifest file if it exists
      push(@@m, q{
       if exist $@@.manifest mt -nologo -manifest $@@.manifest -outputresource:$@@;2
       if exist $@@.manifest del $@@.manifest});
    }
    push @@m, '
	$(CHMOD) $(PERM_RWX) $@@
';

    join('',@@m);
}

=item extra_clean_files

Clean out some extra dll.{base,exp} files which might be generated by
gcc.  Otherwise, take out all *.pdb files.

=cut

sub extra_clean_files {
    my $self = shift;

    return $GCC ? (qw(dll.base dll.exp)) : ('*.pdb');
}

=item init_linker

=cut

sub init_linker {
    my $self = shift;

    $self->{PERL_ARCHIVE}       = "\$(PERL_INC)\\$Config{libperl}";
    $self->{PERL_ARCHIVE_AFTER} = '';
    $self->{EXPORT_LIST}        = '$(BASEEXT).def';
}


=item perl_script

Checks for the perl program under several common perl extensions.

=cut

sub perl_script {
    my($self,$file) = @@_;
    return $file if -r $file && -f _;
    return "$file.pl"  if -r "$file.pl" && -f _;
    return "$file.plx" if -r "$file.plx" && -f _;
    return "$file.bat" if -r "$file.bat" && -f _;
    return;
}


=item xs_o

This target is stubbed out.  Not sure why.

=cut

sub xs_o {
    return ''
}


=item pasthru

All we send is -nologo to nmake to prevent it from printing its damned
banner.

=cut

sub pasthru {
    my($self) = shift;
    return "PASTHRU = " . ($self->is_make_type('nmake') ? "-nologo" : "");
}


=item arch_check (override)

Normalize all arguments for consistency of comparison.

=cut

sub arch_check {
    my $self = shift;

    # Win32 is an XS module, minperl won't have it.
    # arch_check() is not critical, so just fake it.
    return 1 unless $self->can_load_xs;
    return $self->SUPER::arch_check( map { $self->_normalize_path_name($_) } @@_);
}

sub _normalize_path_name {
    my $self = shift;
    my $file = shift;

    require Win32;
    my $short = Win32::GetShortPathName($file);
    return defined $short ? lc $short : lc $file;
}


=item oneliner

These are based on what command.com does on Win98.  They may be wrong
for other Windows shells, I don't know.

=cut

sub oneliner {
    my($self, $cmd, $switches) = @@_;
    $switches = [] unless defined $switches;

    # Strip leading and trailing newlines
    $cmd =~ s{^\n+}{};
    $cmd =~ s{\n+$}{};

    $cmd = $self->quote_literal($cmd);
    $cmd = $self->escape_newlines($cmd);

    $switches = join ' ', @@$switches;

    return qq{\$(ABSPERLRUN) $switches -e $cmd --};
}


sub quote_literal {
    my($self, $text) = @@_;

    # I don't know if this is correct, but it seems to work on
    # Win98's command.com
    $text =~ s{"}{\\"}g;

    # dmake eats '{' inside double quotes and leaves alone { outside double
    # quotes; however it transforms {{ into { either inside and outside double
    # quotes.  It also translates }} into }.  The escaping below is not
    # 100% correct.
    if( $self->is_make_type('dmake') ) {
        $text =~ s/{/{{/g;
        $text =~ s/}}/}}}/g;
    }

    return qq{"$text"};
}


sub escape_newlines {
    my($self, $text) = @@_;

    # Escape newlines
    $text =~ s{\n}{\\\n}g;

    return $text;
}


=item cd

dmake can handle Unix style cd'ing but nmake (at least 1.5) cannot.  It
wants:

    cd dir1\dir2
    command
    another_command
    cd ..\..

=cut

sub cd {
    my($self, $dir, @@cmds) = @@_;

    return $self->SUPER::cd($dir, @@cmds) unless $self->is_make_type('nmake');

    my $cmd = join "\n\t", map "$_", @@cmds;

    my $updirs = $self->catdir(map { $self->updir } $self->splitdir($dir));

    # No leading tab and no trailing newline makes for easier embedding.
    my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd, $updirs;
cd %s
	%s
	cd %s
MAKE_FRAG

    chomp $make_frag;

    return $make_frag;
}


=item max_exec_len

nmake 1.50 limits command length to 2048 characters.

=cut

sub max_exec_len {
    my $self = shift;

    return $self->{_MAX_EXEC_LEN} ||= 2 * 1024;
}


=item os_flavor

Windows is Win32.

=cut

sub os_flavor {
    return('Win32');
}


=item cflags

Defines the PERLDLL symbol if we are configured for static building since all
code destined for the perl5xx.dll must be compiled with the PERLDLL symbol
defined.

=cut

sub cflags {
    my($self,$libperl)=@@_;
    return $self->{CFLAGS} if $self->{CFLAGS};
    return '' unless $self->needs_linking();

    my $base = $self->SUPER::cflags($libperl);
    foreach (split /\n/, $base) {
        /^(\S*)\s*=\s*(\S*)$/ and $self->{$1} = $2;
    };
    $self->{CCFLAGS} .= " -DPERLDLL" if ($self->{LINKTYPE} eq 'static');

    return $self->{CFLAGS} = qq{
CCFLAGS = $self->{CCFLAGS}
OPTIMIZE = $self->{OPTIMIZE}
PERLTYPE = $self->{PERLTYPE}
};

}

sub is_make_type {
    my($self, $type) = @@_;
    return !! ($self->make =~ /\b$type(?:\.exe)?$/);
}

1;
__END__

=back

=cut 


@


1.9
log
@Merge in perl 5.10.1
@
text
@@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a26 2
use vars qw(@@ISA $VERSION);

d29 2
a30 2
@@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
$VERSION = '6.42';
d34 2
a35 2
my $BORLAND = 1 if $Config{'cc'} =~ /^bcc/i;
my $GCC     = 1 if $Config{'cc'} =~ /^gcc/i;
a128 2
    my $make = $self->make;

d130 3
a132 3
    $self->{DIRFILESEP} = $make eq 'nmake' ? '^\\' :
                          $make eq 'dmake' ? '\\\\'
                                           : '\\';
a151 10
    # Used in favor of echo because echo won't strip quotes. :(
    $self->{ECHO}     ||= $self->oneliner('print qq{@@ARGV}', ['-l']);
    $self->{ECHO_N}   ||= $self->oneliner('print qq{@@ARGV}');

    $self->{TOUCH}    ||= '$(ABSPERLRUN) -MExtUtils::Command -e touch';
    $self->{CHMOD}    ||= '$(ABSPERLRUN) -MExtUtils::Command -e chmod'; 
    $self->{CP}       ||= '$(ABSPERLRUN) -MExtUtils::Command -e cp';
    $self->{RM_F}     ||= '$(ABSPERLRUN) -MExtUtils::Command -e rm_f';
    $self->{RM_RF}    ||= '$(ABSPERLRUN) -MExtUtils::Command -e rm_rf';
    $self->{MV}       ||= '$(ABSPERLRUN) -MExtUtils::Command -e mv';
a152 1
    $self->{TEST_F}   ||= '$(ABSPERLRUN) -MExtUtils::Command -e test_f';
d159 2
a160 2
    $self->{LD}     ||= $Config{ld} || 'link';
    $self->{AR}     ||= $Config{ar} || 'lib';
d224 1
a224 1
    $make_frag .= <<'MAKE_FRAG' if $self->make eq 'dmake';
d319 1
a319 1
       .($self->make eq 'dmake' 
d330 4
a333 7
      # VS2005 (aka VC 8) or higher, but not for 64-bit compiler from Platform SDK
      if ($Config{ivsize} == 4 && $Config{cc} eq 'cl' and $Config{ccversion} =~ /^(\d+)/ and $1 >= 14) 
    {
        push(@@m,
          q{
	mt -nologo -manifest $@@.manifest -outputresource:$@@;2 && del $@@.manifest});
      }
d404 26
a429 1
    return "PASTHRU = " . ($self->make eq 'nmake' ? "-nologo" : "");
d468 1
a468 1
    if( $self->make eq 'dmake' ) {
d492 1
a492 1
    cd dir
d495 1
a495 3
    cd ..

NOTE: This only works with simple relative directories.  Throw it an absolute dir or something with .. in it and things will go wrong.
d502 1
a502 1
    return $self->SUPER::cd($dir, @@cmds) unless $self->make eq 'nmake';
d570 5
@


1.7
log
@merge in perl 5.8.8
@
text
@d27 1
a27 1
use vars qw(@@ISA $VERSION $BORLAND $GCC $DMAKE $NMAKE);
d32 1
a32 1
$VERSION = '1.12';
d36 2
a37 4
$BORLAND = 1 if $Config{'cc'} =~ /^bcc/i;
$GCC     = 1 if $Config{'cc'} =~ /^gcc/i;
$DMAKE = 1 if $Config{'make'} =~ /^dmake/i;
$NMAKE = 1 if $Config{'make'} =~ /^nmake/i;
d131 2
d134 3
a136 3
    $self->{DIRFILESEP} = $NMAKE ? '^\\' :
                          $DMAKE ? '\\\\'
                                 : '\\';
d239 1
a239 1
    $make_frag .= <<'MAKE_FRAG' if $DMAKE;
d334 2
a335 1
       .($DMAKE ? q{$(PERL_ARCHIVE:s,/,\,) $(LDLOADLIBS:s,/,\,) }
d344 8
d422 1
a422 1
    return "PASTHRU = " . ($NMAKE ? "-nologo" : "");
d446 1
a446 1
    return qq{\$(ABSPERLRUN) $switches -e $cmd};
d461 1
a461 1
    if( $DMAKE ) {
d490 1
a490 2
B<NOTE> This cd can only go one level down.  So far this sufficient for
what MakeMaker needs.
d497 1
a497 1
    return $self->SUPER::cd($dir, @@cmds) unless $NMAKE;
d501 2
d504 1
a504 1
    my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd;
d507 1
a507 1
	cd ..
d539 27
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d22 1
a22 1
use Config;
d32 1
a32 1
$VERSION = '1.09';
a123 14
=item B<find_tests>

The Win9x shell does not expand globs and I'll play it safe and assume
other Windows variants don't either.

So we do it for them.

=cut

sub find_tests {
    return join(' ', <t\\*.t>);
}


d160 6
a165 6
    $self->{TOUCH}    ||= '$(PERLRUN) -MExtUtils::Command -e touch';
    $self->{CHMOD}    ||= '$(PERLRUN) -MExtUtils::Command -e chmod'; 
    $self->{CP}       ||= '$(PERLRUN) -MExtUtils::Command -e cp';
    $self->{RM_F}     ||= '$(PERLRUN) -MExtUtils::Command -e rm_f';
    $self->{RM_RF}    ||= '$(PERLRUN) -MExtUtils::Command -e rm_rf';
    $self->{MV}       ||= '$(PERLRUN) -MExtUtils::Command -e mv';
d167 1
a167 1
    $self->{TEST_F}   ||= '$(PERLRUN) -MExtUtils::Command -e test_f';
d170 4
d200 1
a200 1
=item init_platform (o)
d204 1
a204 1
=item platform_constants (o)
d228 1
a228 1
=item special_targets (o)
d247 1
a247 1
=item static_lib (o)
d262 1
a262 1
$(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
a284 1
    push @@m, "\n", $self->dir_target('$(INST_ARCHAUTODIR)');
d289 1
a289 1
=item dynamic_lib (o)
d323 1
a323 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
a347 1
    push @@m, $self->dir_target('$(INST_ARCHAUTODIR)');
d351 1
a351 1
=item clean
d358 2
a359 8
sub clean
{
    my ($self) = shift;
    my $s = $self->SUPER::clean(@@_);
    my $clean = $GCC ? 'dll.base dll.exp' : '*.pdb';
    $s .= <<END;
clean ::
	-\$(RM_F) $clean
d361 1
a361 2
END
    return $s;
d393 1
a393 1
=item xs_o (o)
d404 1
a404 1
=item pasthru (o)
d417 1
a417 1
=item oneliner (o)
d437 1
a437 1
    return qq{\$(PERLRUN) $switches -e $cmd};
d468 35
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 2
a19 2
=over 4

d27 1
a27 1
use vars qw(@@ISA $VERSION $BORLAND $GCC $DMAKE $NMAKE $PERLMAKE);
d32 1
a32 1
$VERSION = '1.05';
d40 9
a48 1
$PERLMAKE = 1 if $Config{'make'} =~ /^pmake/i;
a57 1
    (my $boot = $self->{NAME}) =~ s/:/_/g;
d79 6
d91 12
d124 6
a129 43
sub find_perl {
    my($self, $ver, $names, $dirs, $trace) = @@_;
    $trace ||= 0;

    my($name, $dir);
    if ($trace >= 2){
	print "Looking for perl $ver by these names:
@@$names
in these dirs:
@@$dirs
";
    }
    foreach $dir (@@$dirs){
	next unless defined $dir; # $self->{PERL_SRC} may be undefined
	foreach $name (@@$names){
	    my ($abs, $val);
	    if (File::Spec->file_name_is_absolute($name)) {  # /foo/bar
		$abs = $name;
	    } elsif (File::Spec->canonpath($name) eq 
                     File::Spec->canonpath(basename($name))) # foo
            {
		$abs = File::Spec->catfile($dir, $name);
	    } else {                                         # foo/bar
		$abs = File::Spec->canonpath(
                           File::Spec->catfile(File::Spec->curdir, $name)
                       );
	    }
	    print "Checking $abs\n" if ($trace >= 2);
	    next unless $self->maybe_command($abs);
	    print "Executing $abs\n" if ($trace >= 2);
            (my($safe_abs) = $abs) =~ s{(\s)}{\\$1}g;
	    $val = `$safe_abs -e "require $ver;" 2>&1`;
	    if ($? == 0) {
	        print "Using PERL=$abs\n" if $trace;
	        return $abs;
	    } elsif ($trace >= 2) {
		print "Result: `$val'\n";
	    }
	}
    }
    print STDOUT "Unable to find a perl $ver (by these names: @@$names, in these dirs: @@$dirs)\n";
    0; # false and not empty
}
d131 1
a132 2
# This code was taken out of MM_Unix to avoid loading File::Glob
# unless necessary.
d138 13
a150 28
sub init_others
{
 my ($self) = @@_;
 $self->SUPER::init_others;
 $self->{'TOUCH'}  = '$(PERLRUN) -MExtUtils::Command -e touch';
 $self->{'CHMOD'}  = '$(PERLRUN) -MExtUtils::Command -e chmod'; 
 $self->{'CP'}     = '$(PERLRUN) -MExtUtils::Command -e cp';
 $self->{'RM_F'}   = '$(PERLRUN) -MExtUtils::Command -e rm_f';
 $self->{'RM_RF'}  = '$(PERLRUN) -MExtUtils::Command -e rm_rf';
 $self->{'MV'}     = '$(PERLRUN) -MExtUtils::Command -e mv';
 $self->{'NOOP'}   = 'rem';
 $self->{'TEST_F'} = '$(PERLRUN) -MExtUtils::Command -e test_f';
 $self->{'LD'}     = $Config{'ld'} || 'link';
 $self->{'AR'}     = $Config{'ar'} || 'lib';
 $self->{'LDLOADLIBS'} ||= $Config{'libs'};
 # -Lfoo must come first for Borland, so we put it in LDDLFLAGS
 if ($BORLAND) {
     my $libs = $self->{'LDLOADLIBS'};
     my $libpath = '';
     while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /) {
         $libpath .= ' ' if length $libpath;
         $libpath .= $1;
     }
     $self->{'LDLOADLIBS'} = $libs;
     $self->{'LDDLFLAGS'} ||= $Config{'lddlflags'};
     $self->{'LDDLFLAGS'} .= " $libpath";
 }
 $self->{'DEV_NULL'} = '> NUL';
d153 1
d155 2
a156 1
=item constants (o)
d158 6
a163 1
Initializes lots of constants and .SUFFIXES and .PHONY
d167 2
a168 3
sub constants {
    my($self) = @@_;
    my(@@m,$tmp);
d170 3
a172 21
    for $tmp (qw/
	      AR_STATIC_ARGS NAME DISTNAME NAME_SYM VERSION
	      VERSION_SYM XS_VERSION 
          INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT 
          INSTALLDIRS
          PREFIX          SITEPREFIX      VENDORPREFIX
	      INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
	      INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
          INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN  INSTALLSCRIPT 
          PERL_LIB        PERL_ARCHLIB 
          SITELIBEXP      SITEARCHEXP 
          LIBPERL_A MYEXTLIB
	      FIRST_MAKEFILE MAKE_APERL_FILE PERLMAINCC PERL_SRC
	      PERL_INC PERL FULLPERL PERLRUN FULLPERLRUN PERLRUNINST 
          FULLPERLRUNINST ABSPERL ABSPERLRUN ABSPERLRUNINST
          FULL_AR PERL_CORE

	      / ) {
	next unless defined $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
    }
d174 9
a182 6
    push @@m, qq{
VERSION_MACRO = VERSION
DEFINE_VERSION = -D\$(VERSION_MACRO)=\\\"\$(VERSION)\\\"
XS_VERSION_MACRO = XS_VERSION
XS_DEFINE_VERSION = -D\$(XS_VERSION_MACRO)=\\\"\$(XS_VERSION)\\\"
};
d184 2
a185 4
    push @@m, qq{
MAKEMAKER = $INC{'ExtUtils/MakeMaker.pm'}
MM_VERSION = $ExtUtils::MakeMaker::VERSION
};
d187 1
a187 6
    push @@m, q{
# FULLEXT = Pathname for extension directory (eg Foo/Bar/Oracle).
# BASEEXT = Basename part of FULLEXT. May be just equal FULLEXT. (eg Oracle)
# PARENT_NAME = NAME without BASEEXT and no trailing :: (eg Foo::Bar)
# DLBASE  = Basename part of dynamic library. May be just equal BASEEXT.
};
d189 2
a190 7
    for $tmp (qw/
	      FULLEXT BASEEXT PARENT_NAME DLBASE VERSION_FROM INC DEFINE OBJECT
	      LDFROM LINKTYPE
	      /	) {
	next unless defined $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
    }
d192 12
a203 18
    push @@m, "
# Handy lists of source code files:
XS_FILES= ".join(" \\\n\t", sort keys %{$self->{XS}})."
C_FILES = ".join(" \\\n\t", @@{$self->{C}})."
O_FILES = ".join(" \\\n\t", @@{$self->{O_FILES}})."
H_FILES = ".join(" \\\n\t", @@{$self->{H}})."
MAN1PODS = ".join(" \\\n\t", sort keys %{$self->{MAN1PODS}})."
MAN3PODS = ".join(" \\\n\t", sort keys %{$self->{MAN3PODS}})."
";

    for $tmp (qw/
	      INST_MAN1DIR  MAN1EXT 
          INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR
	      INST_MAN3DIR  MAN3EXT
          INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR
	      /) {
	next unless defined $self->{$tmp};
	push @@m, "$tmp = $self->{$tmp}\n";
d206 2
a207 3
    push @@m, qq{
.USESHELL :
} if $DMAKE;
a208 3
    push @@m, q{
.NO_CONFIG_REC: Makefile
} if $ENV{CLEARCASE_ROOT};
d210 1
a210 4
    # why not q{} ? -- emacs
    push @@m, qq{
# work around a famous dec-osf make(1) feature(?):
makemakerdflt: all
d212 1
a212 1
.SUFFIXES: .xs .c .C .cpp .cxx .cc \$(OBJ_EXT)
d214 1
a214 5
# Nick wanted to get rid of .PRECIOUS. I don't remember why. I seem to 
# recall, that some make implementations will delete the Makefile when we 
# rebuild it. Because we call false(1) when we rebuild it. So make(1) is 
# not completely wrong when it does so. Our milage may vary.
# .PRECIOUS: Makefile    # seems to be not necessary anymore
d216 1
a216 1
.PHONY: all config static dynamic test linkext manifest
d218 2
a219 3
# Where is the Config information that we are using/depend on
CONFIGDEP = \$(PERL_ARCHLIB)\\Config.pm \$(PERL_INC)\\config.h
};
d221 2
a222 5
    my @@parentdir = split(/::/, $self->{PARENT_NAME});
    push @@m, q{
# Where to put things:
INST_LIBDIR      = }. File::Spec->catdir('$(INST_LIB)',@@parentdir)        .q{
INST_ARCHLIBDIR  = }. File::Spec->catdir('$(INST_ARCHLIB)',@@parentdir)    .q{
d224 3
a226 3
INST_AUTODIR     = }. File::Spec->catdir('$(INST_LIB)','auto','$(FULLEXT)')       .q{
INST_ARCHAUTODIR = }. File::Spec->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)')   .q{
};
d228 4
a231 12
    if ($self->has_link_code()) {
	push @@m, '
INST_STATIC  = $(INST_ARCHAUTODIR)\$(BASEEXT)$(LIB_EXT)
INST_DYNAMIC = $(INST_ARCHAUTODIR)\$(DLBASE).$(DLEXT)
INST_BOOT    = $(INST_ARCHAUTODIR)\$(BASEEXT).bs
';
    } else {
	push @@m, '
INST_STATIC  =
INST_DYNAMIC =
INST_BOOT    =
';
d234 3
a236 8
    $tmp = $self->export_list;
    push @@m, "
EXPORT_LIST = $tmp
";
    $tmp = $self->perl_archive;
    push @@m, "
PERL_ARCHIVE = $tmp
";
d238 1
a238 2
    push @@m, q{
TO_INST_PM = }.join(" \\\n\t", sort keys %{$self->{PM}}).q{
d240 12
a251 2
PM_TO_BLIB = }.join(" \\\n\t", %{$self->{PM}}).q{
};
d253 1
a253 1
    join('',@@m);
d259 4
a262 1
Defines how to produce the *.a (or equivalent) files.
a267 3
# Come to think of it, if there are subdirs with linkcode, we still have no INST_STATIC
#    return '' unless $self->needs_linking(); #might be because of a subdir

d272 1
a272 1
$(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)\.exists
d275 1
d278 3
a280 1
    push(@@m, "\t$self->{CP} \$(MYEXTLIB) \$\@@\n") if $self->{MYEXTLIB};
d286 2
a287 2
	}.$self->{NOECHO}.q{echo "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)\extralibs.ld
	$(CHMOD) 755 $@@
d290 4
a293 4
# Old mechanism - still available:

    push @@m, "\t$self->{NOECHO}".q{echo "$(EXTRALIBS)" >> $(PERL_SRC)\ext.libs}."\n\n"
	if $self->{PERL_SRC};
d295 2
a296 2
    push @@m, $self->dir_target('$(INST_ARCHAUTODIR)');
    join('', "\n",@@m);
a298 32
=item dynamic_bs (o)

Defines targets for bootstrap files.

=cut

sub dynamic_bs {
    my($self, %attribs) = @@_;
    return '
BOOTSTRAP =
' unless $self->has_link_code();

    return '
BOOTSTRAP = '."$self->{BASEEXT}.bs".'

# As Mkbootstrap might not write a file (if none is required)
# we use touch to prevent make continually trying to remake it.
# The DynaLoader only reads a non-empty file.
$(BOOTSTRAP): '."$self->{MAKEFILE} $self->{BOOTDEP}".' $(INST_ARCHAUTODIR)\.exists
	'.$self->{NOECHO}.'echo "Running Mkbootstrap for $(NAME) ($(BSLOADLIBS))"
	'.$self->{NOECHO}.'$(PERLRUN) \
		-MExtUtils::Mkbootstrap \
		-e "Mkbootstrap(\'$(BASEEXT)\',\'$(BSLOADLIBS)\');"
	'.$self->{NOECHO}.'$(TOUCH) $(BOOTSTRAP)
	$(CHMOD) 644 $@@

$(INST_BOOT): $(BOOTSTRAP) $(INST_ARCHAUTODIR)\.exists
	'."$self->{NOECHO}$self->{RM_RF}".' $(INST_BOOT)
	-'.$self->{CP}.' $(BOOTSTRAP) $(INST_BOOT)
	$(CHMOD) 644 $@@
';
}
d302 1
a302 1
Defines how to produce the *.so (or equivalent) files.
d334 1
a334 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)\.exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
d356 1
a356 1
	$(CHMOD) 755 $@@
d363 7
d383 1
d385 1
d387 2
a388 5
sub perl_archive
{
    my ($self) = @@_;
    return '$(PERL_INC)\\'.$Config{'libperl'};
}
d390 3
a392 4
sub export_list
{
 my ($self) = @@_;
 return "$self->{BASEEXT}.def";
d398 1
a398 3
Takes one argument, a file name, and returns the file name, if the
argument is likely to be a perl script. On MM_Unix this is true for
any ordinary, readable file.
d405 2
a406 1
    return "$file.pl" if -r "$file.pl" && -f _;
a410 24
=item pm_to_blib

Defines target that copies all files in the hash PM to their
destination and autosplits them. See L<ExtUtils::Install/DESCRIPTION>

=cut

sub pm_to_blib {
    my $self = shift;
    my($autodir) = File::Spec->catdir('$(INST_LIB)','auto');
    return q{
pm_to_blib: $(TO_INST_PM)
	}.$self->{NOECHO}.q{$(PERLRUNINST) -MExtUtils::Install \
        -e "pm_to_blib(}.
	($NMAKE ? 'qw[ <<pmfiles.dat ],'
	        : $DMAKE ? 'qw[ $(mktmp,pmfiles.dat $(PM_TO_BLIB:s,\\,\\\\,)\n) ],'
			 : '{ qw[$(PM_TO_BLIB)] },'
	 ).q{'}.$autodir.q{','$(PM_FILTER)')"
}. ($NMAKE ? q{
$(PM_TO_BLIB)
<<
	} : '') . "\t".$self->{NOECHO}.q{$(TOUCH) $@@
};
}
d412 1
d414 1
a414 3
=item tool_autosplit (override)

Use Win32 quoting on command line.
d418 2
a419 8
sub tool_autosplit{
    my($self, %attribs) = @@_;
    my($asl) = "";
    $asl = "\$AutoSplit::Maxlen=$attribs{MAXLEN};" if $attribs{MAXLEN};
    q{
# Usage: $(AUTOSPLITFILE) FileToSplit AutoDirToSplitInto
AUTOSPLITFILE = $(PERLRUN) -MAutoSplit }.$asl.q{ -e "autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1);"
};
a421 1
=item tools_other (o)
d423 1
a423 1
Win32 overrides.
d425 2
a426 3
Defines SHELL, LD, TOUCH, CP, MV, RM_F, RM_RF, CHMOD, UMASK_NULL in
the Makefile. Also defines the perl programs MKPATH,
WARN_IF_OLD_PACKLIST, MOD_INSTALL. DOC_INSTALL, and UNINSTALL.
d430 1
a430 1
sub tools_other {
d432 1
a432 52
    my @@m;
    my $bin_sh = $Config{sh} || 'cmd /c';
    push @@m, qq{
SHELL = $bin_sh
} unless $DMAKE;  # dmake determines its own shell 

    for (qw/ CHMOD CP LD MV NOOP RM_F RM_RF TEST_F TOUCH UMASK_NULL DEV_NULL/ ) {
	push @@m, "$_ = $self->{$_}\n";
    }

    push @@m, q{
# The following is a portable way to say mkdir -p
# To see which directories are created, change the if 0 to if 1
MKPATH = $(PERLRUN) -MExtUtils::Command -e mkpath

# This helps us to minimize the effect of the .exists files A yet
# better solution would be to have a stable file in the perl
# distribution with a timestamp of zero. But this solution doesn't
# need any changes to the core distribution and works with older perls
EQUALIZE_TIMESTAMP = $(PERLRUN) -MExtUtils::Command -e eqtime
};


    return join "", @@m if $self->{PARENT};

    push @@m, q{
# Here we warn users that an old packlist file was found somewhere,
# and that they should call some uninstall routine
WARN_IF_OLD_PACKLIST = $(PERL) -lwe "exit unless -f $$ARGV[0];" \\
-e "print 'WARNING: I have found an old package in';" \\
-e "print '	', $$ARGV[0], '.';" \\
-e "print 'Please make sure the two installations are not conflicting';"

UNINST=0
VERBINST=1

MOD_INSTALL = $(PERL) -I$(INST_LIB) -I$(PERL_LIB) -MExtUtils::Install \
-e "install({ @@ARGV },'$(VERBINST)',0,'$(UNINST)');"

DOC_INSTALL = $(PERL) -e "$$\=\"\n\n\";" \
-e "print '=head2 ', scalar(localtime), ': C<', shift, '>', ' L<', $$arg=shift, '|', $$arg, '>';" \
-e "print '=over 4';" \
-e "while (defined($$key = shift) and defined($$val = shift)) { print '=item *';print 'C<', \"$$key: $$val\", '>'; }" \
-e "print '=back';"

UNINSTALL =   $(PERL) -MExtUtils::Install \
-e "uninstall($$ARGV[0],1,1); print \"\nUninstall is deprecated. Please check the";" \
-e "print \" packlist above carefully.\n  There may be errors. Remove the\";" \
-e "print \" appropriate files manually.\n  Sorry for the inconveniences.\n\""
};

    return join "", @@m;
a434 1
=item xs_o (o)
d436 1
a436 2
Defines suffix rules to go from XS to object files directly. This is
only intended for broken make implementations.
d438 2
a439 10
=cut

sub xs_o {	# many makes are too dumb to use xs_c then c_o
    my($self) = shift;
    return ''
}

=item top_targets (o)

Defines the targets all, subdirs, config, and O_FILES
d443 3
a445 2
sub top_targets {
# --- Target Sections ---
d447 3
a449 2
    my($self) = shift;
    my(@@m);
d451 2
a452 9
    push @@m, '
all :: pure_all manifypods
	'.$self->{NOECHO}.'$(NOOP)
' 
	  unless $self->{SKIPHASH}{'all'};
    
    push @@m, '
pure_all :: config pm_to_blib subdirs linkext
	'.$self->{NOECHO}.'$(NOOP)
d454 1
a454 2
subdirs :: $(MYEXTLIB)
	'.$self->{NOECHO}.'$(NOOP)
d456 2
a457 2
config :: '.$self->{MAKEFILE}.' $(INST_LIBDIR)\.exists
	'.$self->{NOECHO}.'$(NOOP)
a458 2
config :: $(INST_ARCHAUTODIR)\.exists
	'.$self->{NOECHO}.'$(NOOP)
d460 2
a461 5
config :: $(INST_AUTODIR)\.exists
	'.$self->{NOECHO}.'$(NOOP)
';

    push @@m, $self->dir_target(qw[$(INST_AUTODIR) $(INST_LIBDIR) $(INST_ARCHAUTODIR)]);
d463 3
a465 4
    if (%{$self->{MAN1PODS}}) {
	push @@m, qq[
config :: \$(INST_MAN1DIR)\\.exists
	$self->{NOECHO}\$(NOOP)
d467 7
a473 2
];
	push @@m, $self->dir_target(qw[$(INST_MAN1DIR)]);
a474 4
    if (%{$self->{MAN3PODS}}) {
	push @@m, qq[
config :: \$(INST_MAN3DIR)\\.exists
	$self->{NOECHO}\$(NOOP)
d476 1
a476 14
];
	push @@m, $self->dir_target(qw[$(INST_MAN3DIR)]);
    }

    push @@m, '
$(O_FILES): $(H_FILES)
' if @@{$self->{O_FILES} || []} && @@{$self->{H} || []};

    push @@m, q{
help:
	perldoc ExtUtils::MakeMaker
};

    join('',@@m);
a478 1
=item manifypods (o)
d480 2
a481 1
We don't want manpage process.
d483 2
a484 1
=cut
d486 1
a486 3
sub manifypods {
    my($self) = shift;
    return "\nmanifypods :\n\t$self->{NOECHO}\$(NOOP)\n";
a488 1
=item dist_ci (o)
d490 3
a492 1
Same as MM_Unix version (changes command-line quoting).
d496 4
a499 11
sub dist_ci {
    my($self) = shift;
    my @@m;
    push @@m, q{
ci :
	$(PERLRUN) -MExtUtils::Manifest=maniread \\
		-e "@@all = keys %{ maniread() };" \\
		-e "print(\"Executing $(CI) @@all\n\"); system(\"$(CI) @@all\");" \\
		-e "print(\"Executing $(RCS_LABEL) ...\n\"); system(\"$(RCS_LABEL) @@all\");"
};
    join "", @@m;
a501 5
=item dist_core (o)

Same as MM_Unix version (changes command-line quoting).

=cut
d503 1
a503 39
sub dist_core {
    my($self) = shift;
    my @@m;
    push @@m, q{
dist : $(DIST_DEFAULT)
	}.$self->{NOECHO}.q{$(PERL) -le "print \"Warning: Makefile possibly out of date with $$vf\" if " \
	    -e "-e ($$vf=\"$(VERSION_FROM)\") and -M $$vf < -M \"}.$self->{MAKEFILE}.q{\";"

tardist : $(DISTVNAME).tar$(SUFFIX)

zipdist : $(DISTVNAME).zip

$(DISTVNAME).tar$(SUFFIX) : distdir
	$(PREOP)
	$(TO_UNIX)
	$(TAR) $(TARFLAGS) $(DISTVNAME).tar $(DISTVNAME)
	$(RM_RF) $(DISTVNAME)
	$(COMPRESS) $(DISTVNAME).tar
	$(POSTOP)

$(DISTVNAME).zip : distdir
	$(PREOP)
	$(ZIP) $(ZIPFLAGS) $(DISTVNAME).zip $(DISTVNAME)
	$(RM_RF) $(DISTVNAME)
	$(POSTOP)

uutardist : $(DISTVNAME).tar$(SUFFIX)
	uuencode $(DISTVNAME).tar$(SUFFIX) \\
		$(DISTVNAME).tar$(SUFFIX) > \\
		$(DISTVNAME).tar$(SUFFIX)_uu

shdist : distdir
	$(PREOP)
	$(SHAR) $(DISTVNAME) > $(DISTVNAME).shar
	$(RM_RF) $(DISTVNAME)
	$(POSTOP)
};
    join "", @@m;
}
d505 1
a505 4
=item pasthru (o)

Defines the string that is passed to recursive make calls in
subdirectories.
d509 2
a510 3
sub pasthru {
    my($self) = shift;
    return "PASTHRU = " . ($NMAKE ? "-nologo" : "");
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
d18 1
a18 1
=over
a22 1
#use Cwd;
d24 4
a27 1
require Exporter;
d29 4
a32 2
Exporter::import('ExtUtils::MakeMaker',
       qw( $Verbose &neatvalue));
a34 1
unshift @@MM::ISA, 'ExtUtils::MM_Win32';
a40 44
$OBJ   = 1 if $Config{'ccflags'} =~ /PERL_OBJECT/i;

# a few workarounds for command.com (very basic)
{
    package ExtUtils::MM_Win95;

    # the $^O test may be overkill, but we want to be sure Win32::IsWin95()
    # exists before we try it

    unshift @@MM::ISA, 'ExtUtils::MM_Win95'
	if ($^O =~ /Win32/ && Win32::IsWin95());

    sub xs_c {
	my($self) = shift;
	return '' unless $self->needs_linking();
	'
.xs.c:
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) \\
	    $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
	'
    }

    sub xs_cpp {
	my($self) = shift;
	return '' unless $self->needs_linking();
	'
.xs.cpp:
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) \\
	    $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.cpp
	';
    }

    # many makes are too dumb to use xs_c then c_o
    sub xs_o {
	my($self) = shift;
	return '' unless $self->needs_linking();
	'
.xs$(OBJ_EXT):
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) \\
	    $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.c
	';
    }
}	# end of command.com workarounds
d56 7
a62 3
     q!	$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -MExtUtils::Mksymlists \\
     -e "Mksymlists('NAME' => '!, $self->{NAME},
     q!', 'DLBASE' => '!,$self->{DLBASE},
a97 4
sub file_name_is_absolute {
    my($self,$file) = @@_;
    $file =~ m{^([a-z]:)?[\\/]}i ;
}
d101 2
d115 1
a115 1
	    if ($self->file_name_is_absolute($name)) { # /foo/bar
d117 8
a124 4
	    } elsif ($self->canonpath($name) eq $self->canonpath(basename($name))) { # foo
		$abs = $self->catfile($dir, $name);
	    } else { # foo/bar
		$abs = $self->canonpath($self->catfile($self->curdir, $name));
d129 2
a130 1
	    $val = `$abs -e "require $ver;" 2>&1`;
d143 5
a147 9
sub catdir {
    my $self = shift;
    my @@args = @@_;
    for (@@args) {
	# append a slash to each argument unless it has one there
	$_ .= "\\" if $_ eq '' or substr($_,-1) ne "\\";
    }
    my $result = $self->canonpath(join('', @@args));
    $result;
a149 16
=item catfile

Concatenate one or more directory names and a filename to form a
complete path ending with a filename

=cut

sub catfile {
    my $self = shift @@_;
    my $file = pop @@_;
    return $file unless @@_;
    my $dir = $self->catdir(@@_);
    $dir =~ s/(\\\.)$//;
    $dir .= "\\" unless substr($dir,length($dir)-1,1) eq "\\";
    return $dir.$file;
}
d154 7
a160 7
 &ExtUtils::MM_Unix::init_others;
 $self->{'TOUCH'}  = '$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e touch';
 $self->{'CHMOD'}  = '$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e chmod'; 
 $self->{'CP'}     = '$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e cp';
 $self->{'RM_F'}   = '$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e rm_f';
 $self->{'RM_RF'}  = '$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e rm_rf';
 $self->{'MV'}     = '$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e mv';
d162 1
a162 1
 $self->{'TEST_F'} = '$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e test_f';
a178 1
 # $self->{'NOECHO'} = ''; # till we have it working
a192 1

d194 10
a203 5
	      VERSION_SYM XS_VERSION INST_BIN INST_EXE INST_LIB
	      INST_ARCHLIB INST_SCRIPT PREFIX  INSTALLDIRS
	      INSTALLPRIVLIB INSTALLARCHLIB INSTALLSITELIB
	      INSTALLSITEARCH INSTALLBIN INSTALLSCRIPT PERL_LIB
	      PERL_ARCHLIB SITELIBEXP SITEARCHEXP LIBPERL_A MYEXTLIB
d205 3
a207 1
	      PERL_INC PERL FULLPERL
d222 1
a222 1
MAKEMAKER = $INC{'ExtUtils\MakeMaker.pm'}
a228 1
# ROOTEXT = Directory part of FULLEXT with leading slash (eg /DBD)  !!! Deprecated from MM 5.32  !!!
a246 2
HTMLLIBPODS    = ".join(" \\\n\t", sort keys %{$self->{HTMLLIBPODS}})."
HTMLSCRIPTPODS = ".join(" \\\n\t", sort keys %{$self->{HTMLSCRIPTPODS}})."
d252 4
a255 6
	      INST_HTMLPRIVLIBDIR INSTALLHTMLPRIVLIBDIR
	      INST_HTMLSITELIBDIR INSTALLHTMLSITELIBDIR
	      INST_HTMLSCRIPTDIR  INSTALLHTMLSCRIPTDIR
	      INST_HTMLLIBDIR                    HTMLEXT
	      INST_MAN1DIR        INSTALLMAN1DIR MAN1EXT
	      INST_MAN3DIR        INSTALLMAN3DIR MAN3EXT
d276 4
a279 4
# Nick wanted to get rid of .PRECIOUS. I don't remember why. I seem to recall, that
# some make implementations will delete the Makefile when we rebuild it. Because
# we call false(1) when we rebuild it. So make(1) is not completely wrong when it
# does so. Our milage may vary.
d291 2
a292 2
INST_LIBDIR      = }. $self->catdir('$(INST_LIB)',@@parentdir)        .q{
INST_ARCHLIBDIR  = }. $self->catdir('$(INST_ARCHLIB)',@@parentdir)    .q{
d294 2
a295 2
INST_AUTODIR     = }. $self->catdir('$(INST_LIB)','auto','$(FULLEXT)')       .q{
INST_ARCHAUTODIR = }. $self->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)')   .q{
a320 6
#    push @@m, q{
#INST_PM = }.join(" \\\n\t", sort values %{$self->{PM}}).q{
#
#PM_TO_BLIB = }.join(" \\\n\t", %{$self->{PM}}).q{
#};

a330 8
sub path {
    my($self) = @@_;
    my $path = $ENV{'PATH'} || $ENV{'Path'} || $ENV{'path'};
    my @@path = split(';',$path);
    foreach(@@path) { $_ = '.' if $_ eq '' }
    @@path;
}

d349 1
a349 1
    # If this extension has it's own library (eg SDBM_File)
d390 1
a390 1
	'.$self->{NOECHO}.'$(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" \
d466 15
a492 19
=item canonpath

No physical check on the filesystem, but a logical cleanup of a
path. On UNIX eliminated successive slashes and successive "/.".

=cut

sub canonpath {
    my($self,$path) = @@_;
    $path =~ s/^([a-z]:)/\u$1/;
    $path =~ s|/|\\|g;
    $path =~ s|(.)\\+|$1\\|g ;                     # xx////xx  -> xx/xx
    $path =~ s|(\\\.)+\\|\\|g ;                    # xx/././xx -> xx/xx
    $path =~ s|^(\.\\)+|| unless $path eq ".\\";   # ./xx      -> xx
    $path =~ s|\\$|| 
             unless $path =~ m#^([a-z]:)?\\#;      # xx/       -> xx
    $path .= '.' if $path =~ m#\\$#;
    $path;
}
d519 1
a519 1
    my($autodir) = $self->catdir('$(INST_LIB)','auto');
d522 1
a522 2
	}.$self->{NOECHO}.q{$(PERL) "-I$(INST_ARCHLIB)" "-I$(INST_LIB)" \
	"-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -MExtUtils::Install \
d528 1
a528 1
	}. ($NMAKE ? q{
d531 1
a531 1
	} : '') . $self->{NOECHO}.q{$(TOUCH) $@@
a534 11
=item test_via_harness (o)

Helper method to write the test targets

=cut

sub test_via_harness {
    my($self, $perl, $tests) = @@_;
    "\t$perl".q! -Mblib -I$(PERL_ARCHLIB) -I$(PERL_LIB) -e "use Test::Harness qw(&runtests $$verbose); $$verbose=$(TEST_VERBOSE); runtests @@ARGV;" !."$tests\n";
}

d548 1
a548 1
AUTOSPLITFILE = $(PERL) "-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" -MAutoSplit }.$asl.q{ -e "autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1);"
d577 1
a577 1
MKPATH = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e mkpath
d583 1
a583 1
EQUALIZE_TIMESTAMP = $(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Command -e eqtime
a640 3
    push @@m, '
#all ::	config $(INST_PM) subdirs linkext manifypods
';
d643 1
a643 1
all :: pure_all htmlifypods manifypods
a666 18
    if (%{$self->{HTMLLIBPODS}}) {
	push @@m, qq[
config :: \$(INST_HTMLLIBDIR)/.exists
	$self->{NOECHO}\$(NOOP)

];
	push @@m, $self->dir_target(qw[$(INST_HTMLLIBDIR)]);
    }

    if (%{$self->{HTMLSCRIPTPODS}}) {
	push @@m, qq[
config :: \$(INST_HTMLSCRIPTDIR)/.exists
	$self->{NOECHO}\$(NOOP)

];
	push @@m, $self->dir_target(qw[$(INST_HTMLSCRIPTDIR)]);
    }

a692 7
    push @@m, q{
Version_check:
	}.$self->{NOECHO}.q{$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) \
		-MExtUtils::MakeMaker=Version_check \
		-e "Version_check('$(MM_VERSION)')"
};

a695 53
=item htmlifypods (o)

Defines targets and routines to translate the pods into HTML manpages
and put them into the INST_HTMLLIBDIR and INST_HTMLSCRIPTDIR
directories.

Same as MM_Unix version (changes command-line quoting).

=cut

sub htmlifypods {
    my($self, %attribs) = @@_;
    return "\nhtmlifypods : pure_all\n\t$self->{NOECHO}\$(NOOP)\n" unless
	%{$self->{HTMLLIBPODS}} || %{$self->{HTMLSCRIPTPODS}};
    my($dist);
    my($pod2html_exe);
    if (defined $self->{PERL_SRC}) {
	$pod2html_exe = $self->catfile($self->{PERL_SRC},'pod','pod2html');
    } else {
	$pod2html_exe = $self->catfile($Config{scriptdirexp},'pod2html');
    }
    unless ($pod2html_exe = $self->perl_script($pod2html_exe)) {
	# No pod2html but some HTMLxxxPODS to be installed
	print <<END;

Warning: I could not locate your pod2html program. Please make sure,
         your pod2html program is in your PATH before you execute 'make'

END
        $pod2html_exe = "-S pod2html";
    }
    my(@@m);
    push @@m,
qq[POD2HTML_EXE = $pod2html_exe\n],
qq[POD2HTML = \$(PERL) -we "use File::Basename; use File::Path qw(mkpath); %m=\@@ARGV;for (keys %m){" \\\n],
q[-e "next if -e $$m{$$_} && -M $$m{$$_} < -M $$_ && -M $$m{$$_} < -M '],
 $self->{MAKEFILE}, q[';" \\
-e "print qq(Htmlifying $$m{$$_}\n);" \\
-e "$$dir = dirname($$m{$$_}); mkpath($$dir) unless -d $$dir;" \\
-e "system(qq[$$^X ].q["-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" $(POD2HTML_EXE) ].qq[$$_>$$m{$$_}])==0 or warn qq(Couldn\\047t install $$m{$$_}\n);" \\
-e "chmod(oct($(PERM_RW))), $$m{$$_} or warn qq(chmod $(PERM_RW) $$m{$$_}: $$!\n);}"
];
    push @@m, "\nhtmlifypods : pure_all ";
    push @@m, join " \\\n\t", keys %{$self->{HTMLLIBPODS}}, keys %{$self->{HTMLSCRIPTPODS}};

    push(@@m,"\n");
    if (%{$self->{HTMLLIBPODS}} || %{$self->{HTMLSCRIPTPODS}}) {
	push @@m, "\t$self->{NOECHO}\$(POD2HTML) \\\n\t";
	push @@m, join " \\\n\t", %{$self->{HTMLLIBPODS}}, %{$self->{HTMLSCRIPTPODS}};
    }
    join('', @@m);
}

d718 1
a718 1
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) -MExtUtils::Manifest=maniread \\
a782 1

@


1.3
log
@perl-5.6.0 + local changes
@
text
@d599 1
a599 1
	 ).q{'}.$autodir.q{')"
d687 1
a687 1
-e "print '=head2 ', scalar(localtime), ': C<', shift, '>', ' L<', shift, '>';" \
@


1.2
log
@perl5.005_03 (stock)
@
text
@d39 43
d296 2
d303 6
a308 1
	      INST_MAN1DIR INSTALLMAN1DIR MAN1EXT INST_MAN3DIR INSTALLMAN3DIR MAN3EXT
a390 1
    local $^W = 1;
d486 12
a535 5
    if($OBJ) {
        if ($self->{CAPI}) {
            return '$(PERL_INC)\perlCAPI$(LIB_EXT)';
        }
    }
d575 1
d577 1
d729 1
a729 1
all :: pure_all manifypods
d751 5
a755 2
    push @@m, qq{
config :: Version_check
d758 8
a765 1
} unless $self->{PARENT} or ($self->{PERL_SRC} && $self->{INSTALLDIRS} eq "perl") or $self->{NO_VC};
d767 3
a769 1
    push @@m, $self->dir_target(qw[$(INST_AUTODIR) $(INST_LIBDIR) $(INST_ARCHAUTODIR)]);
d807 53
d862 1
a862 1
We don't want manpage process.  XXX add pod2html support later.
@


1.1
log
@perl 5.004_04
@
text
@d33 1
d36 2
d44 1
d57 1
d73 15
a87 1
    return "$file.exe" if -e "$file.exe";
d175 13
a187 7
 $self->{'LDLOADLIBS'}
    ||= ( $BORLAND
          ? 'import32.lib cw32mti.lib '
          : 'msvcrt.lib oldnames.lib kernel32.lib comdlg32.lib winspool.lib gdi32.lib '
	    .'advapi32.lib user32.lib shell32.lib netapi32.lib ole32.lib '
	    .'oleaut32.lib uuid.lib wsock32.lib mpr.lib winmm.lib version.lib '
	) . ' odbc32.lib odbccp32.lib';
d372 3
a374 1
q{	$(AR) }.($BORLAND ? '$@@ $(OBJECT:^"+")' : '-out:$@@ $(OBJECT)').q{
d445 19
a463 5

    push(@@m, $BORLAND ?
q{	$(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) }.$ldfrom.q{,$@@,,$(PERL_ARCHIVE:s,/,\,) $(LDLOADLIBS:s,/,\,) $(MYEXTLIB:s,/,\,),$(EXPORT_LIST:s,/,\,),$(RESFILES)} :
q{	$(LD) -out:$@@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) -def:$(EXPORT_LIST)}
	);
d474 7
a480 1
 return '$(PERL_INC)\perl$(LIB_EXT)';
d537 5
a541 4
        -e "pm_to_blib(qw[ }.
	($NMAKE ? '<<pmfiles.dat'
		: '$(mktmp,pmfiles.dat $(PM_TO_BLIB:s,\\,\\\\,)\n)').
	q{ ],'}.$autodir.q{')"
d744 1
d833 1
@


1.1.1.1
log
@perl5.005_03
@
text
@a32 1
$GCC     = 1 if $Config{'cc'} =~ /^gcc/i;
a34 2
$PERLMAKE = 1 if $Config{'make'} =~ /^pmake/i;
$OBJ   = 1 if $Config{'ccflags'} =~ /PERL_OBJECT/i;
a40 1
    my($funclist) = $attribs{FUNCLIST} || $self->{FUNCLIST} || [];
a52 1
     q!, 'FUNCLIST' => !,neatvalue($funclist),
d68 1
a68 15
    my @@e = exists($ENV{'PATHEXT'})
          ? split(/;/, $ENV{PATHEXT})
	  : qw(.com .exe .bat .cmd);
    my $e = '';
    for (@@e) { $e .= "\Q$_\E|" }
    chop $e;
    # see if file ends in one of the known extensions
    if ($file =~ /($e)$/i) {
	return $file if -e $file;
    }
    else {
	for (@@e) {
	    return "$file$_" if -e "$file$_";
	}
    }
d156 7
a162 13
 $self->{'LDLOADLIBS'} ||= $Config{'libs'};
 # -Lfoo must come first for Borland, so we put it in LDDLFLAGS
 if ($BORLAND) {
     my $libs = $self->{'LDLOADLIBS'};
     my $libpath = '';
     while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /) {
         $libpath .= ' ' if length $libpath;
         $libpath .= $1;
     }
     $self->{'LDLOADLIBS'} = $libs;
     $self->{'LDDLFLAGS'} ||= $Config{'lddlflags'};
     $self->{'LDDLFLAGS'} .= " $libpath";
 }
d347 1
a347 3
q{	$(AR) }.($BORLAND ? '$@@ $(OBJECT:^"+")'
			  : ($GCC ? '-ru $@@ $(OBJECT)'
			          : '-out:$@@ $(OBJECT)')).q{
d418 5
a422 19
    if ($GCC) {
      push(@@m,  
       q{	dlltool --def $(EXPORT_LIST) --output-exp dll.exp
	$(LD) -o $@@ -Wl,--base-file -Wl,dll.base $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) dll.exp
	dlltool --def $(EXPORT_LIST) --base-file dll.base --output-exp dll.exp
	$(LD) -o $@@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) $(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) dll.exp });
    } elsif ($BORLAND) {
      push(@@m,
       q{	$(LD) $(LDDLFLAGS) $(OTHERLDFLAGS) }.$ldfrom.q{,$@@,,}
       .($DMAKE ? q{$(PERL_ARCHIVE:s,/,\,) $(LDLOADLIBS:s,/,\,) }
		 .q{$(MYEXTLIB:s,/,\,),$(EXPORT_LIST:s,/,\,)}
		: q{$(subst /,\,$(PERL_ARCHIVE)) $(subst /,\,$(LDLOADLIBS)) }
		 .q{$(subst /,\,$(MYEXTLIB)),$(subst /,\,$(EXPORT_LIST))})
       .q{,$(RESFILES)});
    } else {	# VC
      push(@@m,
       q{	$(LD) -out:$@@ $(LDDLFLAGS) }.$ldfrom.q{ $(OTHERLDFLAGS) }
      .q{$(MYEXTLIB) $(PERL_ARCHIVE) $(LDLOADLIBS) -def:$(EXPORT_LIST)});
    }
d433 1
a433 7
    my ($self) = @@_;
    if($OBJ) {
        if ($self->{CAPI}) {
            return '$(PERL_INC)\perlCAPI$(LIB_EXT)';
        }
    }
    return '$(PERL_INC)\\'.$Config{'libperl'};
d490 4
a493 5
        -e "pm_to_blib(}.
	($NMAKE ? 'qw[ <<pmfiles.dat ],'
	        : $DMAKE ? 'qw[ $(mktmp,pmfiles.dat $(PM_TO_BLIB:s,\\,\\\\,)\n) ],'
			 : '{ qw[$(PM_TO_BLIB)] },'
	 ).q{'}.$autodir.q{')"
a695 1
    my($self) = shift;
a783 1

@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@a38 43
# a few workarounds for command.com (very basic)
{
    package ExtUtils::MM_Win95;

    # the $^O test may be overkill, but we want to be sure Win32::IsWin95()
    # exists before we try it

    unshift @@MM::ISA, 'ExtUtils::MM_Win95'
	if ($^O =~ /Win32/ && Win32::IsWin95());

    sub xs_c {
	my($self) = shift;
	return '' unless $self->needs_linking();
	'
.xs.c:
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) \\
	    $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
	'
    }

    sub xs_cpp {
	my($self) = shift;
	return '' unless $self->needs_linking();
	'
.xs.cpp:
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) \\
	    $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.cpp
	';
    }

    # many makes are too dumb to use xs_c then c_o
    sub xs_o {
	my($self) = shift;
	return '' unless $self->needs_linking();
	'
.xs$(OBJ_EXT):
	$(PERL) -I$(PERL_ARCHLIB) -I$(PERL_LIB) $(XSUBPP) \\
	    $(XSPROTOARG) $(XSUBPPARGS) $*.xs > $*.c
	$(CCCMD) $(CCCDLFLAGS) -I$(PERL_INC) $(DEFINE) $*.c
	';
    }
}	# end of command.com workarounds

a252 2
HTMLLIBPODS    = ".join(" \\\n\t", sort keys %{$self->{HTMLLIBPODS}})."
HTMLSCRIPTPODS = ".join(" \\\n\t", sort keys %{$self->{HTMLSCRIPTPODS}})."
d258 1
a258 6
	      INST_HTMLPRIVLIBDIR INSTALLHTMLPRIVLIBDIR
	      INST_HTMLSITELIBDIR INSTALLHTMLSITELIBDIR
	      INST_HTMLSCRIPTDIR  INSTALLHTMLSCRIPTDIR
	      INST_HTMLLIBDIR                    HTMLEXT
	      INST_MAN1DIR        INSTALLMAN1DIR MAN1EXT
	      INST_MAN3DIR        INSTALLMAN3DIR MAN3EXT
d341 1
a436 12

# one thing for GCC/Mingw32:
# we try to overcome non-relocateable-DLL problems by generating
#    a (hopefully unique) image-base from the dll's name
# -- BKS, 10-19-1999
    if ($GCC) { 
	my $dllname = $self->{BASEEXT} . "." . $self->{DLEXT};
	$dllname =~ /(....)(.{0,4})/;
	my $baseaddr = unpack("n", $1 ^ $2);
	$otherldflags .= sprintf("-Wl,--image-base,0x%x0000 ", $baseaddr);
    }

d475 5
a518 1
    return $file if -r $file && -f _;
a519 1
    return "$file.bat" if -r "$file.bat" && -f _;
d671 1
a671 1
all :: pure_all htmlifypods manifypods
d693 2
a694 5
    push @@m, $self->dir_target(qw[$(INST_AUTODIR) $(INST_LIBDIR) $(INST_ARCHAUTODIR)]);

    if (%{$self->{HTMLLIBPODS}}) {
	push @@m, qq[
config :: \$(INST_HTMLLIBDIR)/.exists
d697 1
a697 3
];
	push @@m, $self->dir_target(qw[$(INST_HTMLLIBDIR)]);
    }
d699 1
a699 8
    if (%{$self->{HTMLSCRIPTPODS}}) {
	push @@m, qq[
config :: \$(INST_HTMLSCRIPTDIR)/.exists
	$self->{NOECHO}\$(NOOP)

];
	push @@m, $self->dir_target(qw[$(INST_HTMLSCRIPTDIR)]);
    }
a736 53
=item htmlifypods (o)

Defines targets and routines to translate the pods into HTML manpages
and put them into the INST_HTMLLIBDIR and INST_HTMLSCRIPTDIR
directories.

Same as MM_Unix version (changes command-line quoting).

=cut

sub htmlifypods {
    my($self, %attribs) = @@_;
    return "\nhtmlifypods : pure_all\n\t$self->{NOECHO}\$(NOOP)\n" unless
	%{$self->{HTMLLIBPODS}} || %{$self->{HTMLSCRIPTPODS}};
    my($dist);
    my($pod2html_exe);
    if (defined $self->{PERL_SRC}) {
	$pod2html_exe = $self->catfile($self->{PERL_SRC},'pod','pod2html');
    } else {
	$pod2html_exe = $self->catfile($Config{scriptdirexp},'pod2html');
    }
    unless ($pod2html_exe = $self->perl_script($pod2html_exe)) {
	# No pod2html but some HTMLxxxPODS to be installed
	print <<END;

Warning: I could not locate your pod2html program. Please make sure,
         your pod2html program is in your PATH before you execute 'make'

END
        $pod2html_exe = "-S pod2html";
    }
    my(@@m);
    push @@m,
qq[POD2HTML_EXE = $pod2html_exe\n],
qq[POD2HTML = \$(PERL) -we "use File::Basename; use File::Path qw(mkpath); %m=\@@ARGV;for (keys %m){" \\\n],
q[-e "next if -e $$m{$$_} && -M $$m{$$_} < -M $$_ && -M $$m{$$_} < -M '],
 $self->{MAKEFILE}, q[';" \\
-e "print qq(Htmlifying $$m{$$_}\n);" \\
-e "$$dir = dirname($$m{$$_}); mkpath($$dir) unless -d $$dir;" \\
-e "system(qq[$$^X ].q["-I$(PERL_ARCHLIB)" "-I$(PERL_LIB)" $(POD2HTML_EXE) ].qq[$$_>$$m{$$_}])==0 or warn qq(Couldn\\047t install $$m{$$_}\n);" \\
-e "chmod(oct($(PERM_RW))), $$m{$$_} or warn qq(chmod $(PERM_RW) $$m{$$_}: $$!\n);}"
];
    push @@m, "\nhtmlifypods : pure_all ";
    push @@m, join " \\\n\t", keys %{$self->{HTMLLIBPODS}}, keys %{$self->{HTMLSCRIPTPODS}};

    push(@@m,"\n");
    if (%{$self->{HTMLLIBPODS}} || %{$self->{HTMLSCRIPTPODS}}) {
	push @@m, "\t$self->{NOECHO}\$(POD2HTML) \\\n\t";
	push @@m, join " \\\n\t", %{$self->{HTMLLIBPODS}}, %{$self->{HTMLSCRIPTPODS}};
    }
    join('', @@m);
}

d739 1
a739 1
We don't want manpage process.
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d599 1
a599 1
	 ).q{'}.$autodir.q{','$(PM_FILTER)')"
d687 1
a687 1
-e "print '=head2 ', scalar(localtime), ': C<', shift, '>', ' L<', $$arg=shift, '|', $$arg, '>';" \
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a2 1

d17 1
a17 1
=over 4
d22 1
d24 1
a24 4
use File::Spec;
use ExtUtils::MakeMaker qw( neatvalue );

use vars qw(@@ISA $VERSION $BORLAND $GCC $DMAKE $NMAKE $PERLMAKE);
d26 2
a27 4
require ExtUtils::MM_Any;
require ExtUtils::MM_Unix;
@@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
$VERSION = '1.05';
d30 1
d37 44
d96 3
a98 7
     q!	$(PERLRUN) -MExtUtils::Mksymlists \\
     -e "Mksymlists('NAME'=>\"!, $self->{NAME},
     q!\", 'DLBASE' => '!,$self->{DLBASE},
     # The above two lines quoted differently to work around
     # a bug in the 4DOS/4NT command line interpreter.  The visible
     # result of the bug was files named q('extension_name',) *with the
     # single quotes and the comma* in the extension build directories.
d134 4
a140 2
    $trace ||= 0;

d153 1
a153 1
	    if (File::Spec->file_name_is_absolute($name)) {  # /foo/bar
d155 4
a158 8
	    } elsif (File::Spec->canonpath($name) eq 
                     File::Spec->canonpath(basename($name))) # foo
            {
		$abs = File::Spec->catfile($dir, $name);
	    } else {                                         # foo/bar
		$abs = File::Spec->canonpath(
                           File::Spec->catfile(File::Spec->curdir, $name)
                       );
d163 1
a163 2
            (my($safe_abs) = $abs) =~ s{(\s)}{\\$1}g;
	    $val = `$safe_abs -e "require $ver;" 2>&1`;
d176 12
d189 13
a201 4
# This code was taken out of MM_Unix to avoid loading File::Glob
# unless necessary.
sub find_tests {
    return join(' ', <t\\*.t>);
a203 1

d207 7
a213 7
 $self->SUPER::init_others;
 $self->{'TOUCH'}  = '$(PERLRUN) -MExtUtils::Command -e touch';
 $self->{'CHMOD'}  = '$(PERLRUN) -MExtUtils::Command -e chmod'; 
 $self->{'CP'}     = '$(PERLRUN) -MExtUtils::Command -e cp';
 $self->{'RM_F'}   = '$(PERLRUN) -MExtUtils::Command -e rm_f';
 $self->{'RM_RF'}  = '$(PERLRUN) -MExtUtils::Command -e rm_rf';
 $self->{'MV'}     = '$(PERLRUN) -MExtUtils::Command -e mv';
d215 1
a215 1
 $self->{'TEST_F'} = '$(PERLRUN) -MExtUtils::Command -e test_f';
d232 1
d247 1
d249 5
a253 10
	      VERSION_SYM XS_VERSION 
          INST_BIN INST_LIB INST_ARCHLIB INST_SCRIPT 
          INSTALLDIRS
          PREFIX          SITEPREFIX      VENDORPREFIX
	      INSTALLPRIVLIB  INSTALLSITELIB  INSTALLVENDORLIB
	      INSTALLARCHLIB  INSTALLSITEARCH INSTALLVENDORARCH
          INSTALLBIN      INSTALLSITEBIN  INSTALLVENDORBIN  INSTALLSCRIPT 
          PERL_LIB        PERL_ARCHLIB 
          SITELIBEXP      SITEARCHEXP 
          LIBPERL_A MYEXTLIB
d255 1
a255 3
	      PERL_INC PERL FULLPERL PERLRUN FULLPERLRUN PERLRUNINST 
          FULLPERLRUNINST ABSPERL ABSPERLRUN ABSPERLRUNINST
          FULL_AR PERL_CORE
d270 1
a270 1
MAKEMAKER = $INC{'ExtUtils/MakeMaker.pm'}
d277 1
d296 2
d303 6
a308 4
	      INST_MAN1DIR  MAN1EXT 
          INSTALLMAN1DIR INSTALLSITEMAN1DIR INSTALLVENDORMAN1DIR
	      INST_MAN3DIR  MAN3EXT
          INSTALLMAN3DIR INSTALLSITEMAN3DIR INSTALLVENDORMAN3DIR
d329 4
a332 4
# Nick wanted to get rid of .PRECIOUS. I don't remember why. I seem to 
# recall, that some make implementations will delete the Makefile when we 
# rebuild it. Because we call false(1) when we rebuild it. So make(1) is 
# not completely wrong when it does so. Our milage may vary.
d344 2
a345 2
INST_LIBDIR      = }. File::Spec->catdir('$(INST_LIB)',@@parentdir)        .q{
INST_ARCHLIBDIR  = }. File::Spec->catdir('$(INST_ARCHLIB)',@@parentdir)    .q{
d347 2
a348 2
INST_AUTODIR     = }. File::Spec->catdir('$(INST_LIB)','auto','$(FULLEXT)')       .q{
INST_ARCHAUTODIR = }. File::Spec->catdir('$(INST_ARCHLIB)','auto','$(FULLEXT)')   .q{
d374 6
d390 8
d416 1
a416 1
    # If this extension has its own library (eg SDBM_File)
d457 1
a457 1
	'.$self->{NOECHO}.'$(PERLRUN) \
a532 15
sub clean
{
    my ($self) = shift;
    my $s = $self->SUPER::clean(@@_);
    my $clean = $GCC ? 'dll.base dll.exp' : '*.pdb';
    $s .= <<END;
clean ::
	-\$(RM_F) $clean

END
    return $s;
}



d545 19
d590 1
a590 1
    my($autodir) = File::Spec->catdir('$(INST_LIB)','auto');
d593 2
a594 1
	}.$self->{NOECHO}.q{$(PERLRUNINST) -MExtUtils::Install \
d600 1
a600 1
}. ($NMAKE ? q{
d603 1
a603 1
	} : '') . "\t".$self->{NOECHO}.q{$(TOUCH) $@@
d607 11
d631 1
a631 1
AUTOSPLITFILE = $(PERLRUN) -MAutoSplit }.$asl.q{ -e "autosplit($$ARGV[0], $$ARGV[1], 0, 1, 1);"
d660 1
a660 1
MKPATH = $(PERLRUN) -MExtUtils::Command -e mkpath
d666 1
a666 1
EQUALIZE_TIMESTAMP = $(PERLRUN) -MExtUtils::Command -e eqtime
d724 3
d729 1
a729 1
all :: pure_all manifypods
d753 18
d797 7
d807 53
d882 1
a882 1
	$(PERLRUN) -MExtUtils::Manifest=maniread \\
d947 1
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@a2 2
use strict;

d18 2
d27 1
a27 1
use vars qw(@@ISA $VERSION $BORLAND $GCC $DMAKE $NMAKE);
d32 1
a32 1
$VERSION = '1.09';
d40 1
a40 9


=head2 Overridden methods

=over 4

=item B<dlsyms>

=cut
d50 1
a71 6
=item replace_manpage_separator

Changes the path separator with .

=cut

a77 12

=item B<maybe_command>

Since Windows has nothing as simple as an executable bit, we check the
file extension.

The PATHEXT env variable will be used to get a list of extensions that
might indicate a command, otherwise .com, .exe, .bat and .cmd will be
used by default.

=cut

d99 43
a141 1
=item B<find_tests>
a142 6
The Win9x shell does not expand globs and I'll play it safe and assume
other Windows variants don't either.

So we do it for them.

=cut
d144 2
d151 28
a178 13
=item B<init_DIRFILESEP>

Using \ for Windows.

=cut

sub init_DIRFILESEP {
    my($self) = shift;

    # The ^ makes sure its not interpreted as an escape in nmake
    $self->{DIRFILESEP} = $NMAKE ? '^\\' :
                          $DMAKE ? '\\\\'
                                 : '\\';
a180 1
=item B<init_others>
d182 1
a182 2
Override some of the Unix specific commands with portable
ExtUtils::Command ones.
d184 1
a184 6
Also provide defaults for LD and AR in case the %Config values aren't
set.

LDLOADLIBS's default is changed to $Config{libs}.

Adjustments are made for Borland's quirks needing -L to come first.
d188 3
a190 2
sub init_others {
    my ($self) = @@_;
d192 21
a212 3
    # Used in favor of echo because echo won't strip quotes. :(
    $self->{ECHO}     ||= $self->oneliner('print qq{@@ARGV}', ['-l']);
    $self->{ECHO_N}   ||= $self->oneliner('print qq{@@ARGV}');
d214 6
a219 9
    $self->{TOUCH}    ||= '$(PERLRUN) -MExtUtils::Command -e touch';
    $self->{CHMOD}    ||= '$(PERLRUN) -MExtUtils::Command -e chmod'; 
    $self->{CP}       ||= '$(PERLRUN) -MExtUtils::Command -e cp';
    $self->{RM_F}     ||= '$(PERLRUN) -MExtUtils::Command -e rm_f';
    $self->{RM_RF}    ||= '$(PERLRUN) -MExtUtils::Command -e rm_rf';
    $self->{MV}       ||= '$(PERLRUN) -MExtUtils::Command -e mv';
    $self->{NOOP}     ||= 'rem';
    $self->{TEST_F}   ||= '$(PERLRUN) -MExtUtils::Command -e test_f';
    $self->{DEV_NULL} ||= '> NUL';
d221 4
a224 2
    $self->{LD}     ||= $Config{ld} || 'link';
    $self->{AR}     ||= $Config{ar} || 'lib';
d226 6
a231 1
    $self->SUPER::init_others;
d233 7
a239 2
    # Setting SHELL from $Config{sh} can break dmake.  Its ok without it.
    delete $self->{SHELL};
d241 18
a258 12
    $self->{LDLOADLIBS} ||= $Config{libs};
    # -Lfoo must come first for Borland, so we put it in LDDLFLAGS
    if ($BORLAND) {
        my $libs = $self->{LDLOADLIBS};
        my $libpath = '';
        while ($libs =~ s/(?:^|\s)(("?)-L.+?\2)(?:\s|$)/ /) {
            $libpath .= ' ' if length $libpath;
            $libpath .= $1;
        }
        $self->{LDLOADLIBS} = $libs;
        $self->{LDDLFLAGS} ||= $Config{lddlflags};
        $self->{LDDLFLAGS} .= " $libpath";
d261 3
a263 2
    return 1;
}
d265 3
d269 4
a272 1
=item init_platform (o)
d274 1
a274 1
Add MM_Win32_VERSION.
d276 5
a280 1
=item platform_constants (o)
d282 1
a282 1
=cut
d284 3
a286 2
sub init_platform {
    my($self) = shift;
d288 5
a292 2
    $self->{MM_Win32_VERSION} = $VERSION;
}
d294 3
a296 3
sub platform_constants {
    my($self) = shift;
    my $make_frag = '';
d298 12
a309 4
    foreach my $macro (qw(MM_Win32_VERSION))
    {
        next unless defined $self->{$macro};
        $make_frag .= "$macro = $self->{$macro}\n";
d312 8
a319 2
    return $make_frag;
}
d321 2
d324 2
a325 1
=item special_targets (o)
d327 1
a327 14
Add .USESHELL target for dmake.

=cut

sub special_targets {
    my($self) = @@_;

    my $make_frag = $self->SUPER::special_targets;

    $make_frag .= <<'MAKE_FRAG' if $DMAKE;
.USESHELL :
MAKE_FRAG

    return $make_frag;
d333 1
a333 4
Changes how to run the linker.

The rest is duplicate code from MM_Unix.  Should move the linker code
to its own method.
d339 3
d346 1
a346 1
$(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists
a348 1

d351 1
a351 3
    push @@m, <<'MAKE_FRAG' if $self->{MYEXTLIB};
	$(CP) $(MYEXTLIB) $@@
MAKE_FRAG
d357 2
a358 2
	$(CHMOD) $(PERM_RWX) $@@
	$(NOECHO) $(ECHO) "$(EXTRALIBS)" > $(INST_ARCHAUTODIR)\extralibs.ld
d361 4
a364 4
    # Old mechanism - still available:
    push @@m, <<'MAKE_FRAG' if $self->{PERL_SRC} && $self->{EXTRALIBS};
	$(NOECHO) $(ECHO) "$(EXTRALIBS)" >> $(PERL_SRC)\ext.libs
MAKE_FRAG
d366 2
a367 2
    push @@m, "\n", $self->dir_target('$(INST_ARCHAUTODIR)');
    join('', @@m);
d370 32
d405 1
a405 1
Complicated stuff for Win32 that I don't understand. :(
d437 1
a437 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DIRFILESEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
d459 1
a459 1
	$(CHMOD) $(PERM_RWX) $@@
a465 7
=item clean

Clean out some extra dll.{base,exp} files which might be generated by
gcc.  Otherwise, take out all *.pdb files.

=cut

a478 1
=item init_linker
a479 1
=cut
d481 5
a485 2
sub init_linker {
    my $self = shift;
d487 4
a490 3
    $self->{PERL_ARCHIVE}       = "\$(PERL_INC)\\$Config{libperl}";
    $self->{PERL_ARCHIVE_AFTER} = '';
    $self->{EXPORT_LIST}        = '$(BASEEXT).def';
d496 3
a498 1
Checks for the perl program under several common perl extensions.
d505 1
a505 2
    return "$file.pl"  if -r "$file.pl" && -f _;
    return "$file.plx" if -r "$file.plx" && -f _;
d510 25
d536 1
a536 1
=item xs_o (o)
d538 1
a538 1
This target is stubbed out.  Not sure why.
d542 8
a549 2
sub xs_o {
    return ''
d552 1
d554 1
a554 1
=item pasthru (o)
d556 3
a558 2
All we send is -nologo to nmake to prevent it from printing its damned
banner.
d562 1
a562 1
sub pasthru {
d564 52
a615 1
    return "PASTHRU = " . ($NMAKE ? "-nologo" : "");
d618 1
d620 2
a621 1
=item oneliner (o)
d623 10
a632 2
These are based on what command.com does on Win98.  They may be wrong
for other Windows shells, I don't know.
d636 2
a637 3
sub oneliner {
    my($self, $cmd, $switches) = @@_;
    $switches = [] unless defined $switches;
d639 12
a650 3
    # Strip leading and trailing newlines
    $cmd =~ s{^\n+}{};
    $cmd =~ s{\n+$}{};
d652 2
a653 2
    $cmd = $self->quote_literal($cmd);
    $cmd = $self->escape_newlines($cmd);
d655 2
a656 1
    $switches = join ' ', @@$switches;
d658 2
a659 2
    return qq{\$(PERLRUN) $switches -e $cmd};
}
d661 3
d665 1
a665 2
sub quote_literal {
    my($self, $text) = @@_;
d667 4
a670 3
    # I don't know if this is correct, but it seems to work on
    # Win98's command.com
    $text =~ s{"}{\\"}g;
d672 2
a673 7
    # dmake eats '{' inside double quotes and leaves alone { outside double
    # quotes; however it transforms {{ into { either inside and outside double
    # quotes.  It also translates }} into }.  The escaping below is not
    # 100% correct.
    if( $DMAKE ) {
        $text =~ s/{/{{/g;
        $text =~ s/}}/}}}/g;
d675 4
d680 14
a693 1
    return qq{"$text"};
d696 1
d698 1
a698 2
sub escape_newlines {
    my($self, $text) = @@_;
d700 1
a700 2
    # Escape newlines
    $text =~ s{\n}{\\\n}g;
d702 3
a704 1
    return $text;
d707 18
d726 1
a726 1
=item max_exec_len
d728 1
a728 1
nmake 1.50 limits command length to 2048 characters.
d732 38
a769 4
sub max_exec_len {
    my $self = shift;

    return $self->{_MAX_EXEC_LEN} ||= 2 * 1024;
d772 1
d774 2
a775 3
=item os_flavor

Windows is Win32.
d779 3
a781 2
sub os_flavor {
    return('Win32');
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d22 1
a22 1
use ExtUtils::MakeMaker::Config;
d32 1
a32 1
$VERSION = '1.12';
d124 14
d174 6
a179 6
    $self->{TOUCH}    ||= '$(ABSPERLRUN) -MExtUtils::Command -e touch';
    $self->{CHMOD}    ||= '$(ABSPERLRUN) -MExtUtils::Command -e chmod'; 
    $self->{CP}       ||= '$(ABSPERLRUN) -MExtUtils::Command -e cp';
    $self->{RM_F}     ||= '$(ABSPERLRUN) -MExtUtils::Command -e rm_f';
    $self->{RM_RF}    ||= '$(ABSPERLRUN) -MExtUtils::Command -e rm_rf';
    $self->{MV}       ||= '$(ABSPERLRUN) -MExtUtils::Command -e mv';
d181 1
a181 1
    $self->{TEST_F}   ||= '$(ABSPERLRUN) -MExtUtils::Command -e test_f';
a183 4
    $self->{FIXIN}    ||= $self->{PERL_CORE} ? 
      "\$(PERLRUN) $self->{PERL_SRC}/win32/bin/pl2bat.pl" : 
      'pl2bat.bat';

d210 1
a210 1
=item init_platform
d214 1
a214 1
=item platform_constants
d238 1
a238 1
=item special_targets
d257 1
a257 1
=item static_lib
d272 1
a272 1
$(INST_STATIC): $(OBJECT) $(MYEXTLIB) $(INST_ARCHAUTODIR)$(DFSEP).exists
d295 1
d300 1
a300 1
=item dynamic_lib
d334 1
a334 1
$(INST_DYNAMIC): $(OBJECT) $(MYEXTLIB) $(BOOTSTRAP) $(INST_ARCHAUTODIR)$(DFSEP).exists $(EXPORT_LIST) $(PERL_ARCHIVE) $(INST_DYNAMIC_DEP)
d359 1
d363 1
a363 1
=item extra_clean_files
d370 8
a377 2
sub extra_clean_files {
    my $self = shift;
d379 2
a380 1
    return $GCC ? (qw(dll.base dll.exp)) : ('*.pdb');
d412 1
a412 1
=item xs_o
d423 1
a423 1
=item pasthru
d436 1
a436 1
=item oneliner
d456 1
a456 1
    return qq{\$(ABSPERLRUN) $switches -e $cmd};
a486 35
}


=item cd

dmake can handle Unix style cd'ing but nmake (at least 1.5) cannot.  It
wants:

    cd dir
    command
    another_command
    cd ..

B<NOTE> This cd can only go one level down.  So far this sufficient for
what MakeMaker needs.

=cut

sub cd {
    my($self, $dir, @@cmds) = @@_;

    return $self->SUPER::cd($dir, @@cmds) unless $NMAKE;

    my $cmd = join "\n\t", map "$_", @@cmds;

    # No leading tab and no trailing newline makes for easier embedding.
    my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd;
cd %s
	%s
	cd ..
MAKE_FRAG

    chomp $make_frag;

    return $make_frag;
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d27 1
a27 1
use vars qw(@@ISA $VERSION);
d32 1
a32 1
$VERSION = '6.42';
d36 4
a39 2
my $BORLAND = 1 if $Config{'cc'} =~ /^bcc/i;
my $GCC     = 1 if $Config{'cc'} =~ /^gcc/i;
a132 2
    my $make = $self->make;

d134 3
a136 3
    $self->{DIRFILESEP} = $make eq 'nmake' ? '^\\' :
                          $make eq 'dmake' ? '\\\\'
                                           : '\\';
d239 1
a239 1
    $make_frag .= <<'MAKE_FRAG' if $self->make eq 'dmake';
d334 1
a334 2
       .($self->make eq 'dmake' 
                ? q{$(PERL_ARCHIVE:s,/,\,) $(LDLOADLIBS:s,/,\,) }
a342 8

      # VS2005 (aka VC 8) or higher, but not for 64-bit compiler from Platform SDK
      if ($Config{ivsize} == 4 && $Config{cc} eq 'cl' and $Config{ccversion} =~ /^(\d+)/ and $1 >= 14) 
    {
        push(@@m,
          q{
	mt -nologo -manifest $@@.manifest -outputresource:$@@;2 && del $@@.manifest});
      }
d413 1
a413 1
    return "PASTHRU = " . ($self->make eq 'nmake' ? "-nologo" : "");
d437 1
a437 1
    return qq{\$(ABSPERLRUN) $switches -e $cmd --};
d452 1
a452 1
    if( $self->make eq 'dmake' ) {
d481 2
a482 1
NOTE: This only works with simple relative directories.  Throw it an absolute dir or something with .. in it and things will go wrong.
d489 1
a489 1
    return $self->SUPER::cd($dir, @@cmds) unless $self->make eq 'nmake';
a492 2
    my $updirs = $self->catdir(map { $self->updir } $self->splitdir($dir));

d494 1
a494 1
    my $make_frag = sprintf <<'MAKE_FRAG', $dir, $cmd, $updirs;
d497 1
a497 1
	cd %s
a528 27

=item cflags

Defines the PERLDLL symbol if we are configured for static building since all
code destined for the perl5xx.dll must be compiled with the PERLDLL symbol
defined.

=cut

sub cflags {
    my($self,$libperl)=@@_;
    return $self->{CFLAGS} if $self->{CFLAGS};
    return '' unless $self->needs_linking();

    my $base = $self->SUPER::cflags($libperl);
    foreach (split /\n/, $base) {
        /^(\S*)\s*=\s*(\S*)$/ and $self->{$1} = $2;
    };
    $self->{CCFLAGS} .= " -DPERLDLL" if ($self->{LINKTYPE} eq 'static');

    return $self->{CFLAGS} = qq{
CCFLAGS = $self->{CCFLAGS}
OPTIMIZE = $self->{OPTIMIZE}
PERLTYPE = $self->{PERLTYPE}
};

}
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d27 2
d31 2
a32 2
our @@ISA = qw( ExtUtils::MM_Any ExtUtils::MM_Unix );
our $VERSION = '6.55_02';
d36 2
a37 2
my $BORLAND = $Config{'cc'} =~ /^bcc/i ? 1 : 0;
my $GCC     = $Config{'cc'} =~ /^gcc/i ? 1 : 0;
d131 2
d134 3
a136 3
    $self->{DIRFILESEP} = $self->is_make_type('nmake') ? '^\\' :
                          $self->is_make_type('dmake') ? '\\\\'
                                                       : '\\';
d156 10
d167 1
d174 2
a175 2
    $self->{LD}     ||= 'link';
    $self->{AR}     ||= 'lib';
d239 1
a239 1
    $make_frag .= <<'MAKE_FRAG' if $self->is_make_type('dmake');
d334 1
a334 1
       .($self->is_make_type('dmake')
d345 7
a351 4
      # Embed the manifest file if it exists
      push(@@m, q{
       if exist $@@.manifest mt -nologo -manifest $@@.manifest -outputresource:$@@;2
       if exist $@@.manifest del $@@.manifest});
d422 1
a422 26
    return "PASTHRU = " . ($self->is_make_type('nmake') ? "-nologo" : "");
}


=item arch_check (override)

Normalize all arguments for consistency of comparison.

=cut

sub arch_check {
    my $self = shift;

    # Win32 is an XS module, minperl won't have it.
    # arch_check() is not critical, so just fake it.
    return 1 unless $self->can_load_xs;
    return $self->SUPER::arch_check( map { $self->_normalize_path_name($_) } @@_);
}

sub _normalize_path_name {
    my $self = shift;
    my $file = shift;

    require Win32;
    my $short = Win32::GetShortPathName($file);
    return defined $short ? lc $short : lc $file;
d461 1
a461 1
    if( $self->is_make_type('dmake') ) {
d485 1
a485 1
    cd dir1\dir2
d488 3
a490 1
    cd ..\..
d497 1
a497 1
    return $self->SUPER::cd($dir, @@cmds) unless $self->is_make_type('nmake');
a564 5
}

sub is_make_type {
    my($self, $type) = @@_;
    return !! ($self->make =~ /\b$type(?:\.exe)?$/);
@


