head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.5.0.4
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.2
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.4.0.6
	OPENBSD_4_6_BASE:1.1.1.4
	OPENBSD_4_5:1.1.1.4.0.2
	OPENBSD_4_5_BASE:1.1.1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.1.1.3.0.10
	OPENBSD_4_4_BASE:1.1.1.3
	OPENBSD_4_3:1.1.1.3.0.8
	OPENBSD_4_3_BASE:1.1.1.3
	OPENBSD_4_2:1.1.1.3.0.6
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.4
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.2
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.39;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.03;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2006.03.28.18.48.45;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.34;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.51;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!/usr/bin/perl -w

BEGIN {
    if( $ENV{PERL_CORE} ) {
        chdir 't' if -d 't';
        @@INC = '../lib';
    }
    else {
        unshift @@INC, 't/lib/';
    }
}
chdir 't';


use strict;

use Config;
use Cwd;
use File::Path;
use File::Basename;
use File::Spec;

use Test::More tests => 46;

BEGIN { use_ok( 'ExtUtils::Installed' ) }

my $mandirs =  !!$Config{man1direxp} + !!$Config{man3direxp};

# saves having to qualify package name for class methods
my $ei = bless( {}, 'ExtUtils::Installed' );

# _is_prefix
ok( $ei->_is_prefix('foo/bar', 'foo'),
	'_is_prefix() should match valid path prefix' );
ok( !$ei->_is_prefix('\foo\bar', '\bar'),
	'... should not match wrong prefix' );

# _is_type
ok( $ei->_is_type(0, 'all'), '_is_type() should be true for type of "all"' );

foreach my $path (qw( man1dir man3dir )) {
SKIP: {
	my $dir = $Config{$path.'exp'};
        skip("no man directory $path on this system", 2 ) unless $dir;

	my $file = $dir . '/foo';
	ok( $ei->_is_type($file, 'doc'),   "... should find doc file in $path" );
	ok( !$ei->_is_type($file, 'prog'), "... but not prog file in $path" );
    }
}

# VMS 5.6.1 doesn't seem to have $Config{prefixexp}
my $prefix = $Config{prefix} || $Config{prefixexp};

# You can concatenate /foo but not foo:, which defaults in the current 
# directory
$prefix = VMS::Filespec::unixify($prefix) if $^O eq 'VMS';

# ActivePerl 5.6.1/631 has $Config{prefixexp} as 'p:' for some reason
$prefix = $Config{prefix} if $prefix eq 'p:' && $^O eq 'MSWin32';

ok( $ei->_is_type( File::Spec->catfile($prefix, 'bar'), 'prog'),
	"... should find prog file under $prefix" );

SKIP: {
	skip('no man directories on this system', 1) unless $mandirs;
	is( $ei->_is_type('bar', 'doc'), 0, 
		'... should not find doc file outside path' );
}

ok( !$ei->_is_type('bar', 'prog'),
	'... nor prog file outside path' );
ok( !$ei->_is_type('whocares', 'someother'), '... nor other type anywhere' );

# _is_under
ok( $ei->_is_under('foo'), '_is_under() should return true with no dirs' );

my @@under = qw( boo bar baz );
ok( !$ei->_is_under('foo', @@under), '... should find no file not under dirs');
ok( $ei->_is_under('baz', @@under),  '... should find file under dir' );


my $wrotelist;

rmtree 'auto/FakeMod';
ok( mkpath('auto/FakeMod') );
END { rmtree 'auto/FakeMod' }

ok(open(PACKLIST, '>auto/FakeMod/.packlist'));
print PACKLIST 'list';
close PACKLIST;

ok(open(FAKEMOD, '>auto/FakeMod/FakeMod.pm'));

print FAKEMOD <<'FAKE';
package FakeMod;
use vars qw( $VERSION );
$VERSION = '1.1.1';
1;
FAKE

close FAKEMOD;

{
    # avoid warning and death by localizing glob
    local *ExtUtils::Installed::Config;
    my $fake_mod_dir = File::Spec->catdir(cwd(), 'auto', 'FakeMod');
    %ExtUtils::Installed::Config = (
        %Config,
        archlibexp	   => cwd(),
        sitearchexp	   => $fake_mod_dir,
    );

	# necessary to fool new()
	push @@INC, $fake_mod_dir;

	my $realei = ExtUtils::Installed->new();
    isa_ok( $realei, 'ExtUtils::Installed' );
    isa_ok( $realei->{Perl}{packlist}, 'ExtUtils::Packlist' );
    is( $realei->{Perl}{version}, $Config{version}, 
        'new() should set Perl version from %Config' );

	ok( exists $realei->{FakeMod}, 'new() should find modules with .packlists');
	isa_ok( $realei->{FakeMod}{packlist}, 'ExtUtils::Packlist' );
	is( $realei->{FakeMod}{version}, '1.1.1', 
		'... should find version in modules' );
}

# modules
$ei->{$_} = 1 for qw( abc def ghi );
is( join(' ', $ei->modules()), 'abc def ghi', 
	'modules() should return sorted keys' );

# This didn't work for a long time due to a sort in scalar context oddity.
is( $ei->modules, 3,    'modules() in scalar context' );

# files
$ei->{goodmod} = { 
	packlist => { 
                ($Config{man1direxp} ? 
                    (File::Spec->catdir($Config{man1direxp}, 'foo') => 1) : 
                        ()),
                ($Config{man3direxp} ? 
                    (File::Spec->catdir($Config{man3direxp}, 'bar') => 1) : 
                        ()),
                File::Spec->catdir($prefix, 'foobar') => 1,
		foobaz	=> 1,
	},
};

eval { $ei->files('badmod') };
like( $@@, qr/badmod is not installed/,'files() should croak given bad modname');
eval { $ei->files('goodmod', 'badtype' ) };
like( $@@, qr/type must be/,'files() should croak given bad type' );

my @@files;
SKIP: {
    skip('no man directory man1dir on this system', 2) 
      unless $Config{man1direxp}; 
    @@files = $ei->files('goodmod', 'doc', $Config{man1direxp});
    is( scalar @@files, 1, '... should find doc file under given dir' );
    is( (grep { /foo$/ } @@files), 1, '... checking file name' );
}
SKIP: {
    skip('no man directories on this system', 1) unless $mandirs;
    @@files = $ei->files('goodmod', 'doc');
    is( scalar @@files, $mandirs, '... should find all doc files with no dir' );
}

@@files = $ei->files('goodmod', 'prog', 'fake', 'fake2');
is( scalar @@files, 0, '... should find no doc files given wrong dirs' );
@@files = $ei->files('goodmod', 'prog');
is( scalar @@files, 1, '... should find doc file in correct dir' );
like( $files[0], qr/foobar[>\]]?$/, '... checking file name' );
@@files = $ei->files('goodmod');
is( scalar @@files, 2 + $mandirs, '... should find all files with no type specified' );
my %dirnames = map { lc($_) => dirname($_) } @@files;

# directories
my @@dirs = $ei->directories('goodmod', 'prog', 'fake');
is( scalar @@dirs, 0, 'directories() should return no dirs if no files found' );

SKIP: {
    skip('no man directories on this system', 1) unless $mandirs;
    @@dirs = $ei->directories('goodmod', 'doc');
    is( scalar @@dirs, $mandirs, '... should find all files files() would' );
}
@@dirs = $ei->directories('goodmod');
is( scalar @@dirs, 2 + $mandirs, '... should find all files files() would, again' );
@@files = sort map { exists $dirnames{lc($_)} ? $dirnames{lc($_)} : '' } @@files;
is( join(' ', @@files), join(' ', @@dirs), '... should sort output' );

# directory_tree
my $expectdirs = 
       ($mandirs == 2) && 
       (dirname($Config{man1direxp}) eq dirname($Config{man3direxp}))
       ? 3 : 2;
 
SKIP: {
    skip('no man directories on this system', 1) unless $mandirs;
    @@dirs = $ei->directory_tree('goodmod', 'doc', $Config{man1direxp} ?
       dirname($Config{man1direxp}) : dirname($Config{man3direxp}));
    is( scalar @@dirs, $expectdirs, 
        'directory_tree() should report intermediate dirs to those requested' );
}

my $fakepak = Fakepak->new(102);

$ei->{yesmod} = { 
	version		=> 101,
	packlist	=> $fakepak,
};

# these should all croak
foreach my $sub (qw( validate packlist version )) {
	eval { $ei->$sub('nomod') };
	like( $@@, qr/nomod is not installed/, 
		"$sub() should croak when asked about uninstalled module" );
}

# validate
is( $ei->validate('yesmod'), 'validated', 
	'validate() should return results of packlist validate() call' );

# packlist
is( ${ $ei->packlist('yesmod') }, 102, 
	'packlist() should report installed mod packlist' );

# version
is( $ei->version('yesmod'), 101, 
	'version() should report installed mod version' );

END {
	if ($wrotelist) {
		for my $file (qw( .packlist FakePak.pm )) {
			1 while unlink $file;
		}
		File::Path::rmtree('auto') or warn "Couldn't rmtree auto: $!";
	}
}

package Fakepak;

sub new {
	my $class = shift;
	bless(\(my $scalar = shift), $class);
}

sub validate {
	'validated'
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d12 1
a12 3

my $Is_VMS = $^O eq 'VMS';
chdir($Is_VMS ? 'BFD_TEST_ROOT:[t]' : 't');
d57 1
a57 1
$prefix = VMS::Filespec::unixify($prefix) if $Is_VMS;
d83 2
d87 1
a87 1
END { rmtree 'auto' }
d233 8
@


1.1.1.3
log
@perl 5.8.8 import
@
text
@a11 1
chdir 't';
d14 2
d36 1
a36 1
        '_is_prefix() should match valid path prefix' );
d38 1
a38 1
        '... should not match wrong prefix' );
d44 2
a45 2
    SKIP: {
        my $dir = $Config{$path.'exp'};
d48 3
a50 3
        my $file = $dir . '/foo';
        ok( $ei->_is_type($file, 'doc'),   "... should find doc file in $path" );
        ok( !$ei->_is_type($file, 'prog'), "... but not prog file in $path" );
d65 1
a65 1
        "... should find prog file under $prefix" );
d68 3
a70 3
    skip('no man directories on this system', 1) unless $mandirs;
    is( $ei->_is_type('bar', 'doc'), 0, 
	'... should not find doc file outside path' );
d74 1
a74 1
        '... nor prog file outside path' );
d110 2
a111 2
        archlibexp         => cwd(),
        sitearchexp        => $fake_mod_dir,
d114 2
a115 2
    # necessary to fool new()
    push @@INC, $fake_mod_dir;
d117 1
a117 1
    my $realei = ExtUtils::Installed->new();
d123 4
a126 4
    ok( exists $realei->{FakeMod}, 'new() should find modules with .packlists');
    isa_ok( $realei->{FakeMod}{packlist}, 'ExtUtils::Packlist' );
    is( $realei->{FakeMod}{version}, '1.1.1', 
	'... should find version in modules' );
d132 1
a132 1
    'modules() should return sorted keys' );
d139 1
a139 1
        packlist => { 
d147 2
a148 2
                foobaz  => 1,
        },
d210 2
a211 2
        version         => 101,
        packlist        => $fakepak,
d216 3
a218 3
    eval { $ei->$sub('nomod') };
    like( $@@, qr/nomod is not installed/, 
	  "$sub() should croak when asked about uninstalled module" );
d223 1
a223 1
        'validate() should return results of packlist validate() call' );
d227 1
a227 1
        'packlist() should report installed mod packlist' );
d231 1
a231 1
        'version() should report installed mod version' );
d237 2
a238 2
    my $class = shift;
    bless(\(my $scalar = shift), $class);
d242 1
a242 1
    return 'validated'
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d24 1
a24 1
use Test::More tests => 63;
a32 4
# Make sure meta info is available
$ei->{':private:'}{Config} = \%Config;
$ei->{':private:'}{INC} = \@@INC;

d56 1
a56 1
# You can concatenate /foo but not foo:, which defaults in the current
d68 1
a68 1
    is( $ei->_is_type('bar', 'doc'), 0,
a102 1
my $fake_mod_dir = File::Spec->catdir(cwd(), 'auto', 'FakeMod');
d106 1
d119 1
a119 1
    is( $realei->{Perl}{version}, $Config{version},
d124 1
a124 68
    is( $realei->{FakeMod}{version}, '1.1.1',
	'... should find version in modules' );
}

# Now try this using PERL5LIB
{
    local $ENV{PERL5LIB} = join $Config{path_sep}, $fake_mod_dir;
    local *ExtUtils::Installed::Config;
    %ExtUtils::Installed::Config = (
        %Config,
        archlibexp         => cwd(),
        sitearchexp        => cwd(),
    );

    my $realei = ExtUtils::Installed->new();
    isa_ok( $realei, 'ExtUtils::Installed' );
    isa_ok( $realei->{Perl}{packlist}, 'ExtUtils::Packlist' );
    is( $realei->{Perl}{version}, $Config{version},
        'new() should set Perl version from %Config' );

    ok( exists $realei->{FakeMod},
        'new() should find modules with .packlists using PERL5LIB'
    );
    isa_ok( $realei->{FakeMod}{packlist}, 'ExtUtils::Packlist' );
    is( $realei->{FakeMod}{version}, '1.1.1',
	'... should find version in modules' );
}

# Do the same thing as the last block, but with overrides for
# %Config and @@INC.
{
    my $config_override = { %Config::Config };
    $config_override->{archlibexp} = cwd();
    $config_override->{sitearchexp} = $fake_mod_dir;
    $config_override->{version} = 'fake_test_version';

    my @@inc_override = (@@INC, $fake_mod_dir);

    my $realei = ExtUtils::Installed->new(
        'config_override' => $config_override,
        'inc_override' => \@@inc_override,
    );
    isa_ok( $realei, 'ExtUtils::Installed' );
    isa_ok( $realei->{Perl}{packlist}, 'ExtUtils::Packlist' );
    is( $realei->{Perl}{version}, 'fake_test_version',
        'new(config_override => HASH) overrides %Config' );

    ok( exists $realei->{FakeMod}, 'new() with overrides should find modules with .packlists');
    isa_ok( $realei->{FakeMod}{packlist}, 'ExtUtils::Packlist' );
    is( $realei->{FakeMod}{version}, '1.1.1',
	'... should find version in modules' );
}

# Check if extra_libs works.
{
    my $realei = ExtUtils::Installed->new(
        'extra_libs' => [ cwd() ],
    );
    isa_ok( $realei, 'ExtUtils::Installed' );
    isa_ok( $realei->{Perl}{packlist}, 'ExtUtils::Packlist' );
    ok( exists $realei->{FakeMod}, 
        'new() with extra_libs should find modules with .packlists');
    
    #{ use Data::Dumper; local $realei->{':private:'}{Config};
    #  warn Dumper($realei); }
    
    isa_ok( $realei->{FakeMod}{packlist}, 'ExtUtils::Packlist' );
    is( $realei->{FakeMod}{version}, '1.1.1',
d130 1
a130 1
is( join(' ', $ei->modules()), 'abc def ghi',
d137 4
a140 4
$ei->{goodmod} = {
        packlist => {
                ($Config{man1direxp} ?
                    (File::Spec->catdir($Config{man1direxp}, 'foo') => 1) :
d142 2
a143 2
                ($Config{man3direxp} ?
                    (File::Spec->catdir($Config{man3direxp}, 'bar') => 1) :
d157 2
a158 2
    skip('no man directory man1dir on this system', 2)
      unless $Config{man1direxp};
d193 2
a194 2
my $expectdirs =
       ($mandirs == 2) &&
d197 1
a197 1

d202 1
a202 1
    is( scalar @@dirs, $expectdirs,
d208 1
a208 1
$ei->{yesmod} = {
d216 1
a216 1
    like( $@@, qr/nomod is not installed/,
d221 1
a221 1
is( $ei->validate('yesmod'), 'validated',
d225 1
a225 1
is( ${ $ei->packlist('yesmod') }, 102,
d229 1
a229 1
is( $ei->version('yesmod'), 101,
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d48 1
a48 1
        my $dir = File::Spec->canonpath($Config{$path.'exp'});
@


