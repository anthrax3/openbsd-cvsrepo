head	1.12;
access;
symbols
	OPENBSD_6_1:1.12.0.4
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.11.0.12
	OPENBSD_6_0_BASE:1.11
	OPENBSD_5_9:1.11.0.6
	OPENBSD_5_9_BASE:1.11
	OPENBSD_5_8:1.11.0.8
	OPENBSD_5_8_BASE:1.11
	PERL_5_20_2:1.1.1.10
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	PERL_5_20_1:1.1.1.10
	OPENBSD_5_6:1.11.0.4
	OPENBSD_5_6_BASE:1.11
	PERL_5_18_2:1.1.1.10
	PERL:1.1.1
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	PERL_5_16_3:1.1.1.9
	OPENBSD_5_3:1.9.0.10
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.8
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.6
	OPENBSD_5_0:1.9.0.4
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.2
	OPENBSD_4_9_BASE:1.9
	PERL_5_12_2:1.1.1.8
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.11;
commitid	cxJ08BvJA9Pt2PTM;

1.11
date	2014.03.24.15.05.28;	author afresh1;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.25.20.40.56;	author sthen;	state Exp;
branches;
next	1.9;

1.9
date	2010.09.24.15.07.01;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.11;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.37;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.30;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.32;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.53;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.33;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.42;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.42;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.07;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.43;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.29;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.59;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.03;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.33;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2010.09.24.14.48.41;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2013.03.25.20.08.54;	author sthen;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	;


desc
@@


1.12
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@# basic C types
int			T_IV
unsigned		T_UV
unsigned int		T_UV
long			T_IV
unsigned long		T_UV
short			T_IV
unsigned short		T_UV
char			T_CHAR
unsigned char		T_U_CHAR
char *			T_PV
unsigned char *		T_PV
const char *		T_PV
caddr_t			T_PV
wchar_t *		T_PV
wchar_t			T_IV
# bool_t is defined in <rpc/rpc.h>
bool_t			T_IV
size_t			T_UV
ssize_t			T_IV
time_t			T_NV
unsigned long *		T_OPAQUEPTR
char **			T_PACKEDARRAY
void *			T_PTR
Time_t *		T_PV
SV *			T_SV

# These are the backwards-compatibility AV*/HV* typemaps that
# do not decrement refcounts. Locally override with
# "AV*	T_AVREF_REFCOUNT_FIXED", "HV*	T_HVREF_REFCOUNT_FIXED",
# "CV*	T_CVREF_REFCOUNT_FIXED", "SVREF	T_SVREF_REFCOUNT_FIXED",
# to get the fixed versions.
SVREF			T_SVREF
CV *			T_CVREF
AV *			T_AVREF
HV *			T_HVREF

IV			T_IV
UV			T_UV
NV                      T_NV
I32			T_IV
I16			T_IV
I8			T_IV
STRLEN			T_UV
U32			T_U_LONG
U16			T_U_SHORT
U8			T_UV
Result			T_U_CHAR
Boolean			T_BOOL
float                   T_FLOAT
double			T_DOUBLE
SysRet			T_SYSRET
SysRetLong		T_SYSRET
FILE *			T_STDIO
PerlIO *		T_INOUT
FileHandle		T_PTROBJ
InputStream		T_IN
InOutStream		T_INOUT
OutputStream		T_OUT
bool			T_BOOL

#############################################################################
INPUT
T_SV
	$var = $arg
T_SVREF
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv)){
		    $var = SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext(\"%s: %s is not a reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_SVREF_REFCOUNT_FIXED
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv)){
		    $var = SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext(\"%s: %s is not a reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_AVREF
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVAV){
		    $var = (AV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext(\"%s: %s is not an ARRAY reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_AVREF_REFCOUNT_FIXED
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVAV){
		    $var = (AV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext(\"%s: %s is not an ARRAY reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_HVREF
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    $var = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext(\"%s: %s is not a HASH reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_HVREF_REFCOUNT_FIXED
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    $var = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak_nocontext(\"%s: %s is not a HASH reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_CVREF
	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
                $var = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!$var) {
		    Perl_croak_nocontext(\"%s: %s is not a CODE reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_CVREF_REFCOUNT_FIXED
	STMT_START {
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
                $var = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!$var) {
		    Perl_croak_nocontext(\"%s: %s is not a CODE reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_SYSRET
	$var NOT IMPLEMENTED
T_UV
	$var = ($type)SvUV($arg)
T_IV
	$var = ($type)SvIV($arg)
T_INT
	$var = (int)SvIV($arg)
T_ENUM
	$var = ($type)SvIV($arg)
T_BOOL
	$var = (bool)SvTRUE($arg)
T_U_INT
	$var = (unsigned int)SvUV($arg)
T_SHORT
	$var = (short)SvIV($arg)
T_U_SHORT
	$var = (unsigned short)SvUV($arg)
T_LONG
	$var = (long)SvIV($arg)
T_U_LONG
	$var = (unsigned long)SvUV($arg)
T_CHAR
	$var = (char)*SvPV_nolen($arg)
T_U_CHAR
	$var = (unsigned char)SvUV($arg)
T_FLOAT
	$var = (float)SvNV($arg)
T_NV
	$var = ($type)SvNV($arg)
T_DOUBLE
	$var = (double)SvNV($arg)
T_PV
	$var = ($type)SvPV_nolen($arg)
T_PTR
	$var = INT2PTR($type,SvIV($arg))
T_PTRREF
	if (SvROK($arg)) {
	    IV tmp = SvIV((SV*)SvRV($arg));
	    $var = INT2PTR($type,tmp);
	}
	else
	    Perl_croak_nocontext(\"%s: %s is not a reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
T_REF_IV_REF
	if (sv_isa($arg, \"${ntype}\")) {
	    IV tmp = SvIV((SV*)SvRV($arg));
	    $var = *INT2PTR($type *, tmp);
	}
	else
	    Perl_croak_nocontext(\"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
T_REF_IV_PTR
	if (sv_isa($arg, \"${ntype}\")) {
	    IV tmp = SvIV((SV*)SvRV($arg));
	    $var = INT2PTR($type, tmp);
	}
	else
	    Perl_croak_nocontext(\"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
T_PTROBJ
	if (SvROK($arg) && sv_derived_from($arg, \"${ntype}\")) {
	    IV tmp = SvIV((SV*)SvRV($arg));
	    $var = INT2PTR($type,tmp);
	}
	else
	    Perl_croak_nocontext(\"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
T_PTRDESC
	if (sv_isa($arg, \"${ntype}\")) {
	    IV tmp = SvIV((SV*)SvRV($arg));
	    ${type}_desc = (\U${type}_DESC\E*) tmp;
	    $var = ${type}_desc->ptr;
	}
	else
	    Perl_croak_nocontext(\"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
T_REFREF
	if (SvROK($arg)) {
	    IV tmp = SvIV((SV*)SvRV($arg));
	    $var = *INT2PTR($type,tmp);
	}
	else
	    Perl_croak_nocontext(\"%s: %s is not a reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
T_REFOBJ
	if (sv_isa($arg, \"${ntype}\")) {
	    IV tmp = SvIV((SV*)SvRV($arg));
	    $var = *INT2PTR($type,tmp);
	}
	else
	    Perl_croak_nocontext(\"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
T_OPAQUE
	$var = *($type *)SvPV_nolen($arg)
T_OPAQUEPTR
	$var = ($type)SvPV_nolen($arg)
T_PACKED
	$var = XS_unpack_$ntype($arg)
T_PACKEDARRAY
	$var = XS_unpack_$ntype($arg)
T_ARRAY
	U32 ix_$var = $argoff;
	$var = $ntype(items -= $argoff);
	while (items--) {
	    DO_ARRAY_ELEM;
	    ix_$var++;
	}
        /* this is the number of elements in the array */
        ix_$var -= $argoff
T_STDIO
	$var = PerlIO_findFILE(IoIFP(sv_2io($arg)))
T_IN
	$var = IoIFP(sv_2io($arg))
T_INOUT
	$var = IoIFP(sv_2io($arg))
T_OUT
	$var = IoOFP(sv_2io($arg))
#############################################################################
OUTPUT
T_SV
	$arg = $var;
T_SVREF
	$arg = newRV((SV*)$var);
T_SVREF_REFCOUNT_FIXED
	$arg = newRV_noinc((SV*)$var);
T_AVREF
	$arg = newRV((SV*)$var);
T_AVREF_REFCOUNT_FIXED
	$arg = newRV_noinc((SV*)$var);
T_HVREF
	$arg = newRV((SV*)$var);
T_HVREF_REFCOUNT_FIXED
	$arg = newRV_noinc((SV*)$var);
T_CVREF
	$arg = newRV((SV*)$var);
T_CVREF_REFCOUNT_FIXED
	$arg = newRV_noinc((SV*)$var);
T_IV
	sv_setiv($arg, (IV)$var);
T_UV
	sv_setuv($arg, (UV)$var);
T_INT
	sv_setiv($arg, (IV)$var);
T_SYSRET
	if ($var != -1) {
	    if ($var == 0)
		sv_setpvn($arg, "0 but true", 10);
	    else
		sv_setiv($arg, (IV)$var);
	}
T_ENUM
	sv_setiv($arg, (IV)$var);
T_BOOL
	${"$var" eq "RETVAL" ? \"$arg = boolSV($var);" : \"sv_setsv($arg, boolSV($var));"}
T_U_INT
	sv_setuv($arg, (UV)$var);
T_SHORT
	sv_setiv($arg, (IV)$var);
T_U_SHORT
	sv_setuv($arg, (UV)$var);
T_LONG
	sv_setiv($arg, (IV)$var);
T_U_LONG
	sv_setuv($arg, (UV)$var);
T_CHAR
	sv_setpvn($arg, (char *)&$var, 1);
T_U_CHAR
	sv_setuv($arg, (UV)$var);
T_FLOAT
	sv_setnv($arg, (double)$var);
T_NV
	sv_setnv($arg, (NV)$var);
T_DOUBLE
	sv_setnv($arg, (double)$var);
T_PV
	sv_setpv((SV*)$arg, $var);
T_PTR
	sv_setiv($arg, PTR2IV($var));
T_PTRREF
	sv_setref_pv($arg, Nullch, (void*)$var);
T_REF_IV_REF
	sv_setref_pv($arg, \"${ntype}\", (void*)new $ntype($var));
T_REF_IV_PTR
	sv_setref_pv($arg, \"${ntype}\", (void*)$var);
T_PTROBJ
	sv_setref_pv($arg, \"${ntype}\", (void*)$var);
T_PTRDESC
	sv_setref_pv($arg, \"${ntype}\", (void*)new\U${type}_DESC\E($var));
T_REFREF
	NOT_IMPLEMENTED
T_REFOBJ
	NOT IMPLEMENTED
T_OPAQUE
	sv_setpvn($arg, (char *)&$var, sizeof($var));
T_OPAQUEPTR
	sv_setpvn($arg, (char *)$var, sizeof(*$var));
T_PACKED
	XS_pack_$ntype($arg, $var);
T_PACKEDARRAY
	XS_pack_$ntype($arg, $var, count_$ntype);
T_ARRAY
        {
	    U32 ix_$var;
            SSize_t extend_size =
                /* The weird way this is written is because g++ is dumb
                 * enough to warn "comparison is always false" on something
                 * like:
                 *
                 * sizeof(a) > sizeof(b) && a > B_t_MAX
                 *
                 * (where the LH condition is false)
                 */
                (size_$var > (sizeof(size_$var) > sizeof(SSize_t)
                              ? SSize_t_MAX : size_$var))
                ? -1 : (SSize_t)size_$var;
	    EXTEND(SP, extend_size);
	    for (ix_$var = 0; ix_$var < size_$var; ix_$var++) {
		ST(ix_$var) = sv_newmortal();
	DO_ARRAY_ELEM
	    }
        }
T_STDIO
	{
	    GV *gv = newGVgen("$Package");
	    PerlIO *fp = PerlIO_importFILE($var,0);
	    if ( fp && do_open(gv, "+<&", 3, FALSE, 0, 0, fp) ) {
		SV *rv = newRV_inc((SV*)gv);
		rv = sv_bless(rv, GvSTASH(gv));
		${"$var" eq "RETVAL" ? \"$arg = sv_2mortal(rv);"
		    : \"sv_setsv($arg, rv);\n\t\tSvREFCNT_dec_NN(rv);"}
	    }${"$var" ne "RETVAL" ? \"
	    else
		sv_setsv($arg, &PL_sv_undef);\n" : \""}
	}
T_IN
	{
	    GV *gv = newGVgen("$Package");
	    if ( do_open(gv, "<&", 2, FALSE, 0, 0, $var) ) {
		SV *rv = newRV_inc((SV*)gv);
		rv = sv_bless(rv, GvSTASH(gv));
		${"$var" eq "RETVAL" ? \"$arg = sv_2mortal(rv);"
		    : \"sv_setsv($arg, rv);\n\t\tSvREFCNT_dec_NN(rv);"}
	    }${"$var" ne "RETVAL" ? \"
	    else
		sv_setsv($arg, &PL_sv_undef);\n" : \""}
	}
T_INOUT
	{
	    GV *gv = newGVgen("$Package");
	    if ( do_open(gv, "+<&", 3, FALSE, 0, 0, $var) ) {
		SV *rv = newRV_inc((SV*)gv);
		rv = sv_bless(rv, GvSTASH(gv));
		${"$var" eq "RETVAL" ? \"$arg = sv_2mortal(rv);"
		    : \"sv_setsv($arg, rv);\n\t\tSvREFCNT_dec_NN(rv);"}
	    }${"$var" ne "RETVAL" ? \"
	    else
		sv_setsv($arg, &PL_sv_undef);\n" : \""}
	}
T_OUT
	{
	    GV *gv = newGVgen("$Package");
	    if ( do_open(gv, "+>&", 3, FALSE, 0, 0, $var) ) {
		SV *rv = newRV_inc((SV*)gv);
		rv = sv_bless(rv, GvSTASH(gv));
		${"$var" eq "RETVAL" ? \"$arg = sv_2mortal(rv);"
		    : \"sv_setsv($arg, rv);\n\t\tSvREFCNT_dec_NN(rv);"}
	    }${"$var" ne "RETVAL" ? \"
	    else
		sv_setsv($arg, &PL_sv_undef);\n" : \""}
	}
@


1.11
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d74 1
a74 1
		    Perl_croak(aTHX_ \"%s: %s is not a reference\",
d87 1
a87 1
		    Perl_croak(aTHX_ \"%s: %s is not a reference\",
d100 1
a100 1
		    Perl_croak(aTHX_ \"%s: %s is not an ARRAY reference\",
d113 1
a113 1
		    Perl_croak(aTHX_ \"%s: %s is not an ARRAY reference\",
d126 1
a126 1
		    Perl_croak(aTHX_ \"%s: %s is not a HASH reference\",
d139 1
a139 1
		    Perl_croak(aTHX_ \"%s: %s is not a HASH reference\",
d152 1
a152 1
		    Perl_croak(aTHX_ \"%s: %s is not a CODE reference\",
d165 1
a165 1
		    Perl_croak(aTHX_ \"%s: %s is not a CODE reference\",
d212 1
a212 1
	    Perl_croak(aTHX_ \"%s: %s is not a reference\",
d221 1
a221 1
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
d230 1
a230 1
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
d239 1
a239 1
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
d249 1
a249 1
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
d258 1
a258 1
	    Perl_croak(aTHX_ \"%s: %s is not a reference\",
d267 1
a267 1
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
d381 13
a393 1
	    EXTEND(SP,size_$var);
d403 6
a408 2
	    if ( fp && do_open(gv, "+<&", 3, FALSE, 0, 0, fp) )
		sv_setsv($arg, sv_bless(newRV((SV*)gv), gv_stashpv("$Package",1)));
d410 1
a410 1
		$arg = &PL_sv_undef;
d415 6
a420 2
	    if ( do_open(gv, "<&", 2, FALSE, 0, 0, $var) )
		sv_setsv($arg, sv_bless(newRV((SV*)gv), gv_stashpv("$Package",1)));
d422 1
a422 1
		$arg = &PL_sv_undef;
d427 6
a432 2
	    if ( do_open(gv, "+<&", 3, FALSE, 0, 0, $var) )
		sv_setsv($arg, sv_bless(newRV((SV*)gv), gv_stashpv("$Package",1)));
d434 1
a434 1
		$arg = &PL_sv_undef;
d439 6
a444 2
	    if ( do_open(gv, "+>&", 3, FALSE, 0, 0, $var) )
		sv_setsv($arg, sv_bless(newRV((SV*)gv), gv_stashpv("$Package",1)));
d446 1
a446 1
		$arg = &PL_sv_undef;
@


1.10
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d146 3
a148 1
		SV* const xsub_tmp_sv = $arg;
d150 2
a151 4
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVCV){
		    $var = (CV*)SvRV(xsub_tmp_sv);
		}
		else{
d159 3
a161 1
		SV* const xsub_tmp_sv = $arg;
d163 2
a164 4
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVCV){
		    $var = (CV*)SvRV(xsub_tmp_sv);
		}
		else{
d331 1
a331 1
	$arg = boolSV($var);
@


1.9
log
@merge in perl 5.12.2 plus local changes
@
text
@d27 6
d34 1
a36 1
CV *			T_CVREF
d67 25
a91 6
	if (SvROK($arg))
	    $var = (SV*)SvRV($arg);
	else
	    Perl_croak(aTHX_ \"%s: %s is not a reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
d93 25
a117 6
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV)
	    $var = (AV*)SvRV($arg);
	else
	    Perl_croak(aTHX_ \"%s: %s is not an array reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
d119 25
a143 6
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVHV)
	    $var = (HV*)SvRV($arg);
	else
	    Perl_croak(aTHX_ \"%s: %s is not a hash reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
d145 25
a169 6
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVCV)
	    $var = (CV*)SvRV($arg);
	else
	    Perl_croak(aTHX_ \"%s: %s is not a code reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
a277 2
T_CALLBACK
	$var = make_perl_cb_$type($arg)
d301 2
d305 2
d309 2
d313 2
a377 5
T_DATAUNIT	
	sv_setpvn($arg, $var.chp(), $var.size());
T_CALLBACK
	sv_setpvn($arg, $var.context.value().chp(),
		$var.context.value().size());
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d152 1
a152 1
	if (sv_derived_from($arg, \"${ntype}\")) {
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d64 3
a66 1
	    Perl_croak(aTHX_ \"$var is not a reference\")
d71 3
a73 1
	    Perl_croak(aTHX_ \"$var is not an array reference\")
d78 3
a80 1
	    Perl_croak(aTHX_ \"$var is not a hash reference\")
d85 3
a87 1
	    Perl_croak(aTHX_ \"$var is not a code reference\")
d130 3
a132 1
	    Perl_croak(aTHX_ \"$var is not a reference\")
d139 3
a141 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
d148 3
a150 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
d157 3
a159 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
d167 3
a169 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
d176 3
a178 1
	    Perl_croak(aTHX_ \"$var is not a reference\")
d185 3
a187 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d17 1
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d13 1
d18 1
a18 1
size_t			T_IV
d22 1
a22 1
char **			T_PACKED
d33 1
a33 1
NV			T_NV
d37 1
d42 2
a43 1
Boolean			T_IV
d47 2
a48 1
FILE *			T_IN
d60 1
a60 1
	if (sv_isa($arg, \"${ntype}\"))
d63 1
a63 1
	    croak(\"$var is not of type ${ntype}\")
d65 1
a65 1
	if (sv_isa($arg, \"${ntype}\"))
d68 1
a68 1
	    croak(\"$var is not of type ${ntype}\")
d70 1
a70 1
	if (sv_isa($arg, \"${ntype}\"))
d73 1
a73 1
	    croak(\"$var is not of type ${ntype}\")
d75 1
a75 1
	if (sv_isa($arg, \"${ntype}\"))
d78 1
a78 1
	    croak(\"$var is not of type ${ntype}\")
d90 1
a90 1
	$var = (int)SvIV($arg)
d102 1
a102 1
	$var = (char)*SvPV($arg,PL_na)
d112 1
a112 1
	$var = ($type)SvPV($arg,PL_na)
d121 1
a121 1
	    croak(\"$var is not a reference\")
d123 1
a123 1
	if (sv_isa($arg, \"${type}\")) {
d125 1
a125 1
	    $var = *($type *) tmp;
d128 1
a128 1
	    croak(\"$var is not of type ${ntype}\")
d130 1
a130 1
	if (sv_isa($arg, \"${type}\")) {
d132 1
a132 1
	    $var = ($type) tmp;
d135 1
a135 1
	    croak(\"$var is not of type ${ntype}\")
d142 1
a142 1
	    croak(\"$var is not of type ${ntype}\")
d146 1
a146 1
	    ${type}_desc = (\U${type}_DESC\E*) tmp; 
d150 1
a150 1
	    croak(\"$var is not of type ${ntype}\")
d157 1
a157 1
	    croak(\"$var is not a reference\")
d164 1
a164 1
	    croak(\"$var is not of type ${ntype}\")
d166 1
a166 1
	$var NOT IMPLEMENTED
d168 1
a168 1
	$var = ($type)SvPV($arg,PL_na)
d176 1
a177 1
	U32 ix_$var = $argoff;
d180 1
d182 4
d256 1
a256 2
	sv_setrefref($arg, \"${ntype}\", XS_service_$ntype,
		    ($var ? (void*)new $ntype($var) : 0));
d273 4
a276 2
	ST_EXTEND($var.size);
	for (U32 ix_$var = 0; ix_$var < $var.size; ix_$var++) {
d279 10
a289 1
	SP += $var.size - 1;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@a0 1
# $Header: /home/rmb1/misc/CVS/perl5.005_61/lib/ExtUtils/typemap,v 1.3 1999/09/13 09:46:43 rmb1 Exp $ 
d32 1
d229 1
a229 1
	sv_setnv($arg, (double)$var);
d235 1
a235 1
	sv_setiv($arg, (IV)$var);
@


1.3
log
@perl5.005_03 (stock)
@
text
@d1 1
a1 1
# $Header$ 
d32 1
d110 1
a110 1
	$var = ($type)SvIV($arg)
d114 1
a114 1
	    $var = ($type) tmp;
d135 1
a135 1
	    $var = ($type) tmp;
d150 1
a150 1
	    $var = *($type) tmp;
d157 1
a157 1
	    $var = *($type) tmp;
d254 1
a254 1
	sv_setpvn($arg, (char *)$var, sizeof(*$var)), XFree((char *)$var);
@


1.2
log
@perl 5.004_04
@
text
@d4 2
a5 2
unsigned		T_IV
unsigned int		T_IV
d7 1
a7 1
unsigned long		T_IV
d9 1
a9 1
unsigned short		T_IV
d37 1
a37 1
U8			T_IV
d76 2
d87 1
a87 1
	$var = (unsigned int)SvIV($arg)
d91 1
a91 1
	$var = (unsigned short)SvIV($arg)
d95 1
a95 1
	$var = (unsigned long)SvIV($arg)
d97 1
a97 1
	$var = (char)*SvPV($arg,na)
d99 1
a99 1
	$var = (unsigned char)SvIV($arg)
d107 1
a107 1
	$var = ($type)SvPV($arg,na)
d163 1
a163 1
	$var = ($type)SvPV($arg,na)
d196 2
d212 1
a212 1
	sv_setiv($arg, (IV)$var);
d216 1
a216 1
	sv_setiv($arg, (IV)$var);
d220 1
a220 1
	sv_setiv($arg, (IV)$var);
d224 1
a224 1
	sv_setiv($arg, (IV)$var);
d269 1
a269 1
	sp += $var.size - 1;
d276 1
a276 1
		$arg = &sv_undef;
d284 1
a284 1
		$arg = &sv_undef;
d292 1
a292 1
		$arg = &sv_undef;
@


1.1
log
@Initial revision
@
text
@d48 1
d82 2
d130 1
a130 1
	if (sv_isa($arg, \"${ntype}\")) {
d205 2
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d4 2
a5 2
unsigned		T_UV
unsigned int		T_UV
d7 1
a7 1
unsigned long		T_UV
d9 1
a9 1
unsigned short		T_UV
d37 1
a37 1
U8			T_UV
a47 1
bool			T_BOOL
a74 2
T_UV
	$var = ($type)SvUV($arg)
a80 2
T_BOOL
	$var = (int)SvIV($arg)
d82 1
a82 1
	$var = (unsigned int)SvUV($arg)
d86 1
a86 1
	$var = (unsigned short)SvUV($arg)
d90 1
a90 1
	$var = (unsigned long)SvUV($arg)
d92 1
a92 1
	$var = (char)*SvPV($arg,PL_na)
d94 1
a94 1
	$var = (unsigned char)SvUV($arg)
d102 1
a102 1
	$var = ($type)SvPV($arg,PL_na)
d127 1
a127 1
	if (sv_derived_from($arg, \"${ntype}\")) {
d158 1
a158 1
	$var = ($type)SvPV($arg,PL_na)
a190 2
T_UV
	sv_setuv($arg, (UV)$var);
a201 2
T_BOOL
	$arg = boolSV($var);
d203 1
a203 1
	sv_setuv($arg, (UV)$var);
d207 1
a207 1
	sv_setuv($arg, (UV)$var);
d211 1
a211 1
	sv_setuv($arg, (UV)$var);
d215 1
a215 1
	sv_setuv($arg, (UV)$var);
d260 1
a260 1
	SP += $var.size - 1;
d267 1
a267 1
		$arg = &PL_sv_undef;
d275 1
a275 1
		$arg = &PL_sv_undef;
d283 1
a283 1
		$arg = &PL_sv_undef;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d1 1
a1 1
# $Header: /home/rmb1/misc/CVS/perl5.005_61/lib/ExtUtils/typemap,v 1.3 1999/09/13 09:46:43 rmb1 Exp $ 
a31 1
UV			T_UV
d109 1
a109 1
	$var = INT2PTR($type,SvIV($arg))
d113 1
a113 1
	    $var = INT2PTR($type,tmp);
d134 1
a134 1
	    $var = INT2PTR($type,tmp);
d149 1
a149 1
	    $var = *INT2PTR($type,tmp);
d156 1
a156 1
	    $var = *INT2PTR($type,tmp);
d253 1
a253 1
	sv_setpvn($arg, (char *)$var, sizeof(*$var));
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d1 1
a32 1
NV			T_NV
d229 1
a229 1
	sv_setnv($arg, (NV)$var);
d235 1
a235 1
	sv_setiv($arg, PTR2IV($var));
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a12 1
const char *		T_PV
d17 1
a17 1
size_t			T_UV
d21 1
a21 1
char **			T_PACKEDARRAY
d32 1
a32 1
NV                      T_NV
a35 1
STRLEN			T_UV
d40 1
a40 2
Boolean			T_BOOL
float                   T_FLOAT
d44 1
a44 2
FILE *			T_STDIO
PerlIO *		T_INOUT
d56 1
a56 1
	if (SvROK($arg))
d59 1
a59 1
	    Perl_croak(aTHX_ \"$var is not a reference\")
d61 1
a61 1
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVAV)
d64 1
a64 1
	    Perl_croak(aTHX_ \"$var is not an array reference\")
d66 1
a66 1
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVHV)
d69 1
a69 1
	    Perl_croak(aTHX_ \"$var is not a hash reference\")
d71 1
a71 1
	if (SvROK($arg) && SvTYPE(SvRV($arg))==SVt_PVCV)
d74 1
a74 1
	    Perl_croak(aTHX_ \"$var is not a code reference\")
d86 1
a86 1
	$var = (bool)SvTRUE($arg)
d98 1
a98 1
	$var = (char)*SvPV_nolen($arg)
d108 1
a108 1
	$var = ($type)SvPV_nolen($arg)
d117 1
a117 1
	    Perl_croak(aTHX_ \"$var is not a reference\")
d119 1
a119 1
	if (sv_isa($arg, \"${ntype}\")) {
d121 1
a121 1
	    $var = *INT2PTR($type *, tmp);
d124 1
a124 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
d126 1
a126 1
	if (sv_isa($arg, \"${ntype}\")) {
d128 1
a128 1
	    $var = INT2PTR($type, tmp);
d131 1
a131 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
d138 1
a138 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
d142 1
a142 1
	    ${type}_desc = (\U${type}_DESC\E*) tmp;
d146 1
a146 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
d153 1
a153 1
	    Perl_croak(aTHX_ \"$var is not a reference\")
d160 1
a160 1
	    Perl_croak(aTHX_ \"$var is not of type ${ntype}\")
d162 1
a162 1
	$var = *($type *)SvPV_nolen($arg)
d164 1
a164 1
	$var = ($type)SvPV_nolen($arg)
d172 1
a173 1
	$var = $ntype(items -= $argoff);
a175 1
	    ix_$var++;
a176 4
        /* this is the number of elements in the array */
        ix_$var -= $argoff
T_STDIO
	$var = PerlIO_findFILE(IoIFP(sv_2io($arg)))
d247 2
a248 1
	NOT_IMPLEMENTED
d265 2
a266 4
        {
	    U32 ix_$var;
	    EXTEND(SP,size_$var);
	    for (ix_$var = 0; ix_$var < size_$var; ix_$var++) {
a268 10
	    }
        }
T_STDIO
	{
	    GV *gv = newGVgen("$Package");
	    PerlIO *fp = PerlIO_importFILE($var,0);
	    if ( fp && do_open(gv, "+<&", 3, FALSE, 0, 0, fp) )
		sv_setsv($arg, sv_bless(newRV((SV*)gv), gv_stashpv("$Package",1)));
	    else
		$arg = &PL_sv_undef;
d270 1
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a16 1
# bool_t is defined in <rpc/rpc.h>
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d64 1
a64 3
	    Perl_croak(aTHX_ \"%s: %s is not a reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
d69 1
a69 3
	    Perl_croak(aTHX_ \"%s: %s is not an array reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
d74 1
a74 3
	    Perl_croak(aTHX_ \"%s: %s is not a hash reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
d79 1
a79 3
	    Perl_croak(aTHX_ \"%s: %s is not a code reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
d122 1
a122 3
	    Perl_croak(aTHX_ \"%s: %s is not a reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
d129 1
a129 3
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
d136 1
a136 3
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
d143 1
a143 3
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
d151 1
a151 3
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
d158 1
a158 3
	    Perl_croak(aTHX_ \"%s: %s is not a reference\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\")
d165 1
a165 3
	    Perl_croak(aTHX_ \"%s: %s is not of type %s\",
			${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
			\"$var\", \"$ntype\")
@


1.1.1.8
log
@Perl 5.12.2 from CPAN
@
text
@d152 1
a152 1
	if (SvROK($arg) && sv_derived_from($arg, \"${ntype}\")) {
@


1.1.1.9
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a26 6

# These are the backwards-compatibility AV*/HV* typemaps that
# do not decrement refcounts. Locally override with
# "AV*	T_AVREF_REFCOUNT_FIXED", "HV*	T_HVREF_REFCOUNT_FIXED",
# "CV*	T_CVREF_REFCOUNT_FIXED", "SVREF	T_SVREF_REFCOUNT_FIXED",
# to get the fixed versions.
a27 1
CV *			T_CVREF
d30 1
d61 6
a66 25
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv)){
		    $var = SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ \"%s: %s is not a reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_SVREF_REFCOUNT_FIXED
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv)){
		    $var = SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ \"%s: %s is not a reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
d68 6
a73 25
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVAV){
		    $var = (AV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ \"%s: %s is not an ARRAY reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_AVREF_REFCOUNT_FIXED
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVAV){
		    $var = (AV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ \"%s: %s is not an ARRAY reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
d75 6
a80 25
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    $var = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ \"%s: %s is not a HASH reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_HVREF_REFCOUNT_FIXED
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVHV){
		    $var = (HV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ \"%s: %s is not a HASH reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
d82 6
a87 25
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVCV){
		    $var = (CV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ \"%s: %s is not a CODE reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
T_CVREF_REFCOUNT_FIXED
	STMT_START {
		SV* const xsub_tmp_sv = $arg;
		SvGETMAGIC(xsub_tmp_sv);
		if (SvROK(xsub_tmp_sv) && SvTYPE(SvRV(xsub_tmp_sv)) == SVt_PVCV){
		    $var = (CV*)SvRV(xsub_tmp_sv);
		}
		else{
		    Perl_croak(aTHX_ \"%s: %s is not a CODE reference\",
				${$ALIAS?\q[GvNAME(CvGV(cv))]:\qq[\"$pname\"]},
				\"$var\");
		}
	} STMT_END
d196 2
a220 2
T_SVREF_REFCOUNT_FIXED
	$arg = newRV_noinc((SV*)$var);
a222 2
T_AVREF_REFCOUNT_FIXED
	$arg = newRV_noinc((SV*)$var);
a224 2
T_HVREF_REFCOUNT_FIXED
	$arg = newRV_noinc((SV*)$var);
a226 2
T_CVREF_REFCOUNT_FIXED
	$arg = newRV_noinc((SV*)$var);
d290 5
@


1.1.1.10
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d146 1
a146 3
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = $arg;
d148 4
a151 2
                $var = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!$var) {
d159 1
a159 3
                HV *st;
                GV *gvp;
		SV * const xsub_tmp_sv = $arg;
d161 4
a164 2
                $var = sv_2cv(xsub_tmp_sv, &st, &gvp, 0);
		if (!$var) {
d331 1
a331 1
	${"$var" eq "RETVAL" ? \"$arg = boolSV($var);" : \"sv_setsv($arg, boolSV($var));"}
@


