head	1.6;
access;
symbols
	OPENBSD_4_8:1.5.0.4
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.2
	OPENBSD_4_7_BASE:1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.4.0.16
	OPENBSD_4_6_BASE:1.4
	OPENBSD_4_5:1.4.0.12
	OPENBSD_4_5_BASE:1.4
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.4.0.10
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.8
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.6
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.4
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.2
	OPENBSD_4_0_BASE:1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.3.0.26
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.24
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.22
	OPENBSD_3_7_BASE:1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.3.0.20
	OPENBSD_3_6_BASE:1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.3.0.18
	OPENBSD_3_5_BASE:1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.3.0.16
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.6
date	2010.09.24.14.59.41;	author millert;	state dead;
branches;
next	1.5;

1.5
date	2009.10.12.18.24.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.40;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.44;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.45;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.45;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.12;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.48.49;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.11.07;	author millert;	state Exp;
branches;
next	;


desc
@@


1.6
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package IPC::Open2;

use strict;
our ($VERSION, @@ISA, @@EXPORT);

require 5.000;
require Exporter;

$VERSION	= 1.03;
@@ISA		= qw(Exporter);
@@EXPORT		= qw(open2);

=head1 NAME

IPC::Open2, open2 - open a process for both reading and writing

=head1 SYNOPSIS

    use IPC::Open2;

    $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'some cmd and args');
      # or without using the shell
    $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'some', 'cmd', 'and', 'args');

    # or with handle autovivification
    my($chld_out, $chld_in);
    $pid = open2($chld_out, $chld_in, 'some cmd and args');
      # or without using the shell
    $pid = open2($chld_out, $chld_in, 'some', 'cmd', 'and', 'args');

    waitpid( $pid, 0 );
    my $child_exit_status = $? >> 8;

=head1 DESCRIPTION

The open2() function runs the given $cmd and connects $chld_out for
reading and $chld_in for writing.  It's what you think should work 
when you try

    $pid = open(HANDLE, "|cmd args|");

The write filehandle will have autoflush turned on.

If $chld_out is a string (that is, a bareword filehandle rather than a glob
or a reference) and it begins with C<< >& >>, then the child will send output
directly to that file handle.  If $chld_in is a string that begins with
C<< <& >>, then $chld_in will be closed in the parent, and the child will
read from it directly.  In both cases, there will be a dup(2) instead of a
pipe(2) made.

If either reader or writer is the null string, this will be replaced
by an autogenerated filehandle.  If so, you must pass a valid lvalue
in the parameter slot so it can be overwritten in the caller, or
an exception will be raised.

open2() returns the process ID of the child process.  It doesn't return on
failure: it just raises an exception matching C</^open2:/>.  However,
C<exec> failures in the child are not detected.  You'll have to
trap SIGPIPE yourself.

open2() does not wait for and reap the child process after it exits.
Except for short programs where it's acceptable to let the operating system
take care of this, you need to do this yourself.  This is normally as
simple as calling C<waitpid $pid, 0> when you're done with the process.
Failing to do this can result in an accumulation of defunct or "zombie"
processes.  See L<perlfunc/waitpid> for more information.

This whole affair is quite dangerous, as you may block forever.  It
assumes it's going to talk to something like B<bc>, both writing
to it and reading from it.  This is presumably safe because you
"know" that commands like B<bc> will read a line at a time and
output a line at a time.  Programs like B<sort> that read their
entire input stream first, however, are quite apt to cause deadlock.

The big problem with this approach is that if you don't have control 
over source code being run in the child process, you can't control
what it does with pipe buffering.  Thus you can't just open a pipe to
C<cat -v> and continually read and write a line from it.

The IO::Pty and Expect modules from CPAN can help with this, as they
provide a real tty (well, a pseudo-tty, actually), which gets you
back to line buffering in the invoked command again.

=head1 WARNING 

The order of arguments differs from that of open3().

=head1 SEE ALSO

See L<IPC::Open3> for an alternative that handles STDERR as well.  This
function is really just a wrapper around open3().

=cut

# &open2: tom christiansen, <tchrist@@convex.com>
#
# usage: $pid = open2('rdr', 'wtr', 'some cmd and args');
#    or  $pid = open2('rdr', 'wtr', 'some', 'cmd', 'and', 'args');
#
# spawn the given $cmd and connect $rdr for
# reading and $wtr for writing.  return pid
# of child, or 0 on failure.  
# 
# WARNING: this is dangerous, as you may block forever
# unless you are very careful.  
# 
# $wtr is left unbuffered.
# 
# abort program if
#	rdr or wtr are null
# 	a system call fails

require IPC::Open3;

sub open2 {
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
    return IPC::Open3::_open3('open2', scalar caller,
				$_[1], $_[0], '>&STDERR', @@_[2 .. $#_]);
}

1
@


1.5
log
@Merge in perl 5.10.1
@
text
@@


1.4
log
@merge in perl 5.8.8
@
text
@d9 1
a9 1
$VERSION	= 1.02;
d30 3
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d9 1
a9 1
$VERSION	= 1.01;
d21 1
a21 1
    $pid = open2(\*RDRFH, \*WTRFH, 'some cmd and args');
d23 1
a23 1
    $pid = open2(\*RDRFH, \*WTRFH, 'some', 'cmd', 'and', 'args');
d26 2
a27 2
    my($rdrfh, $wtrfh);
    $pid = open2($rdrfh, $wtrfh, 'some cmd and args');
d29 1
a29 1
    $pid = open2($rdrfh, $wtrfh, 'some', 'cmd', 'and', 'args');
d33 2
a34 2
The open2() function runs the given $cmd and connects $rdrfh for
reading and $wtrfh for writing.  It's what you think should work 
d41 1
a41 1
If $rdrfh is a string (that is, a bareword filehandle rather than a glob
d43 3
a45 3
directly to that file handle.  If $wtrfh is a string that begins with
C<< <& >>, then $wtrfh will be closed in the parent, and the child will read
from it directly.  In both cases, there will be a dup(2) instead of a
@


1.2
log
@perl 5.004_04
@
text
@d4 1
a4 1
use vars qw($VERSION @@ISA @@EXPORT);
d20 10
a29 3
    $pid = open2(\*RDR, \*WTR, 'some cmd and args');
      # or
    $pid = open2(\*RDR, \*WTR, 'some', 'cmd', 'and', 'args');
d33 2
a34 2
The open2() function spawns the given $cmd and connects $rdr for
reading and $wtr for writing.  It's what you think should work 
d37 1
a37 1
    open(HANDLE, "|cmd args|");
d41 4
a44 4
If $rdr is a string (that is, a bareword filehandle rather than a glob
or a reference) and it begins with ">&", then the child will send output
directly to that file handle.  If $wtr is a string that begins with
"<&", then WTR will be closed in the parent, and the child will read
d48 5
d54 17
a70 13
failure: it just raises an exception matching C</^open2:/>.

=head1 WARNING 

It will not create these file handles for you.  You have to do this yourself.
So don't pass it empty variables expecting them to get filled in for you.

Additionally, this is very dangerous as you may block forever.
It assumes it's going to talk to something like B<bc>, both writing to
it and reading from it.  This is presumably safe because you "know"
that commands like B<bc> will read a line at a time and output a line at
a time.  Programs like B<sort> that read their entire input stream first,
however, are quite apt to cause deadlock.  
d77 8
a112 1
    my ($read, $write, @@cmd) = @@_;
d115 1
a115 1
				$write, $read, '>&STDERR', @@cmd);
@


1.1
log
@Initial revision
@
text
@d2 4
d8 4
a11 1
use Carp;
d30 10
a39 1
    open(HANDLE, "|cmd args");
d57 3
a59 3
over source code being run in the the child process, you can't control what it does 
with pipe buffering.  Thus you can't just open a pipe to C<cat -v> and continually
read and write a line from it.
d63 2
a64 1
See L<open3> for an alternative that handles STDERR as well.
a67 3
@@ISA = qw(Exporter);
@@EXPORT = qw(open2);

d84 1
a84 1
# 	pipe or fork or exec fails
d86 1
a86 1
$fh = 'FHOPEN000';  # package static in case called more than once
d89 4
a92 30
    local($kidpid);
    local($dad_rdr, $dad_wtr, @@cmd) = @@_;

    $dad_rdr ne '' 		|| croak "open2: rdr should not be null";
    $dad_wtr ne '' 		|| croak "open2: wtr should not be null";

    # force unqualified filehandles into callers' package
    local($package) = caller;
    $dad_rdr =~ s/^[^']+$/$package'$&/ unless ref $dad_rdr;
    $dad_wtr =~ s/^[^']+$/$package'$&/ unless ref $dad_wtr;

    local($kid_rdr) = ++$fh;
    local($kid_wtr) = ++$fh;

    pipe($dad_rdr, $kid_wtr) 	|| croak "open2: pipe 1 failed: $!";
    pipe($kid_rdr, $dad_wtr) 	|| croak "open2: pipe 2 failed: $!";

    if (($kidpid = fork) < 0) {
	croak "open2: fork failed: $!";
    } elsif ($kidpid == 0) {
	close $dad_rdr; close $dad_wtr;
	open(STDIN,  "<&$kid_rdr");
	open(STDOUT, ">&$kid_wtr");
	warn "execing @@cmd\n" if $debug;
	exec @@cmd
	    or croak "open2: exec of @@cmd failed";   
    } 
    close $kid_rdr; close $kid_wtr;
    select((select($dad_wtr), $| = 1)[0]); # unbuffer pipe
    $kidpid;
a93 1
1; # so require is happy
d95 1
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a1 4

use strict;
use vars qw($VERSION @@ISA @@EXPORT);

d4 1
a4 4

$VERSION	= 1.01;
@@ISA		= qw(Exporter);
@@EXPORT		= qw(open2);
d23 1
a23 10
    open(HANDLE, "|cmd args|");

The write filehandle will have autoflush turned on.

If $rdr is a string (that is, a bareword filehandle rather than a glob
or a reference) and it begins with ">&", then the child will send output
directly to that file handle.  If $wtr is a string that begins with
"<&", then WTR will be closed in the parent, and the child will read
from it directly.  In both cases, there will be a dup(2) instead of a
pipe(2) made.
d41 3
a43 3
over source code being run in the child process, you can't control
what it does with pipe buffering.  Thus you can't just open a pipe to
C<cat -v> and continually read and write a line from it.
d47 1
a47 2
See L<IPC::Open3> for an alternative that handles STDERR as well.  This
function is really just a wrapper around open3().
d51 3
d70 1
a70 1
# 	a system call fails
d72 1
a72 1
require IPC::Open3;
d75 30
a104 4
    my ($read, $write, @@cmd) = @@_;
    local $Carp::CarpLevel = $Carp::CarpLevel + 1;
    return IPC::Open3::_open3('open2', scalar caller,
				$write, $read, '>&STDERR', @@cmd);
d106 1
a107 1
1
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d4 1
a4 1
our ($VERSION, @@ISA, @@EXPORT);
d20 3
a22 10

    $pid = open2(\*RDRFH, \*WTRFH, 'some cmd and args');
      # or without using the shell
    $pid = open2(\*RDRFH, \*WTRFH, 'some', 'cmd', 'and', 'args');

    # or with handle autovivification
    my($rdrfh, $wtrfh);
    $pid = open2($rdrfh, $wtrfh, 'some cmd and args');
      # or without using the shell
    $pid = open2($rdrfh, $wtrfh, 'some', 'cmd', 'and', 'args');
d26 2
a27 2
The open2() function runs the given $cmd and connects $rdrfh for
reading and $wtrfh for writing.  It's what you think should work 
d30 1
a30 1
    $pid = open(HANDLE, "|cmd args|");
d34 4
a37 4
If $rdrfh is a string (that is, a bareword filehandle rather than a glob
or a reference) and it begins with C<< >& >>, then the child will send output
directly to that file handle.  If $wtrfh is a string that begins with
C<< <& >>, then $wtrfh will be closed in the parent, and the child will read
d41 7
a47 4
If either reader or writer is the null string, this will be replaced
by an autogenerated filehandle.  If so, you must pass a valid lvalue
in the parameter slot so it can be overwritten in the caller, or
an exception will be raised.
d49 6
a54 18
open2() returns the process ID of the child process.  It doesn't return on
failure: it just raises an exception matching C</^open2:/>.  However,
C<exec> failures in the child are not detected.  You'll have to
trap SIGPIPE yourself.

open2() does not wait for and reap the child process after it exits.
Except for short programs where it's acceptable to let the operating system
take care of this, you need to do this yourself.  This is normally as
simple as calling C<waitpid $pid, 0> when you're done with the process.
Failing to do this can result in an accumulation of defunct or "zombie"
processes.  See L<perlfunc/waitpid> for more information.

This whole affair is quite dangerous, as you may block forever.  It
assumes it's going to talk to something like B<bc>, both writing
to it and reading from it.  This is presumably safe because you
"know" that commands like B<bc> will read a line at a time and
output a line at a time.  Programs like B<sort> that read their
entire input stream first, however, are quite apt to cause deadlock.
a60 8
The IO::Pty and Expect modules from CPAN can help with this, as they
provide a real tty (well, a pseudo-tty, actually), which gets you
back to line buffering in the invoked command again.

=head1 WARNING 

The order of arguments differs from that of open3().

d89 1
d92 1
a92 1
				$_[1], $_[0], '>&STDERR', @@_[2 .. $#_]);
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d9 1
a9 1
$VERSION	= 1.02;
d21 1
a21 1
    $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'some cmd and args');
d23 1
a23 1
    $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'some', 'cmd', 'and', 'args');
d26 2
a27 2
    my($chld_out, $chld_in);
    $pid = open2($chld_out, $chld_in, 'some cmd and args');
d29 1
a29 1
    $pid = open2($chld_out, $chld_in, 'some', 'cmd', 'and', 'args');
d33 2
a34 2
The open2() function runs the given $cmd and connects $chld_out for
reading and $chld_in for writing.  It's what you think should work 
d41 1
a41 1
If $chld_out is a string (that is, a bareword filehandle rather than a glob
d43 3
a45 3
directly to that file handle.  If $chld_in is a string that begins with
C<< <& >>, then $chld_in will be closed in the parent, and the child will
read from it directly.  In both cases, there will be a dup(2) instead of a
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d9 1
a9 1
$VERSION	= 1.03;
a29 3

    waitpid( $pid, 0 );
    my $child_exit_status = $? >> 8;
@


