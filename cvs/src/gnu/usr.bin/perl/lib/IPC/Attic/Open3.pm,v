head	1.12;
access;
symbols
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.12
date	2010.09.24.14.59.41;	author millert;	state dead;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.41;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.09.35;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.33;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.41;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.45;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.45;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.45;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.12;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.46;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.04;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.46.47;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.21;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.49;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.36;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.11.07;	author millert;	state Exp;
branches;
next	;


desc
@@


1.12
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package IPC::Open3;

use strict;
no strict 'refs'; # because users pass me bareword filehandles
our ($VERSION, @@ISA, @@EXPORT);

require Exporter;

use Carp;
use Symbol qw(gensym qualify);

$VERSION	= 1.04;
@@ISA		= qw(Exporter);
@@EXPORT		= qw(open3);

=head1 NAME

IPC::Open3, open3 - open a process for reading, writing, and error handling

=head1 SYNOPSIS

    $pid = open3(\*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR,
		    'some cmd and args', 'optarg', ...);

    my($wtr, $rdr, $err);
    use Symbol 'gensym'; $err = gensym;
    $pid = open3($wtr, $rdr, $err,
		    'some cmd and args', 'optarg', ...);

    waitpid( $pid, 0 );
    my $child_exit_status = $? >> 8;

=head1 DESCRIPTION

Extremely similar to open2(), open3() spawns the given $cmd and
connects CHLD_OUT for reading from the child, CHLD_IN for writing to
the child, and CHLD_ERR for errors.  If CHLD_ERR is false, or the
same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child
are on the same filehandle (this means that an autovivified lexical
cannot be used for the STDERR filehandle, see SYNOPSIS).  The CHLD_IN
will have autoflush turned on.

If CHLD_IN begins with C<< <& >>, then CHLD_IN will be closed in the
parent, and the child will read from it directly.  If CHLD_OUT or
CHLD_ERR begins with C<< >& >>, then the child will send output
directly to that filehandle.  In both cases, there will be a dup(2)
instead of a pipe(2) made.

If either reader or writer is the null string, this will be replaced
by an autogenerated filehandle.  If so, you must pass a valid lvalue
in the parameter slot so it can be overwritten in the caller, or 
an exception will be raised.

The filehandles may also be integers, in which case they are understood
as file descriptors.

open3() returns the process ID of the child process.  It doesn't return on
failure: it just raises an exception matching C</^open3:/>.  However,
C<exec> failures in the child (such as no such file or permission denied),
are just reported to CHLD_ERR, as it is not possible to trap them.

If the child process dies for any reason, the next write to CHLD_IN is
likely to generate a SIGPIPE in the parent, which is fatal by default.
So you may wish to handle this signal.

Note if you specify C<-> as the command, in an analogous fashion to
C<open(FOO, "-|")> the child process will just be the forked Perl
process rather than an external command.  This feature isn't yet
supported on Win32 platforms.

open3() does not wait for and reap the child process after it exits.  
Except for short programs where it's acceptable to let the operating system
take care of this, you need to do this yourself.  This is normally as 
simple as calling C<waitpid $pid, 0> when you're done with the process.
Failing to do this can result in an accumulation of defunct or "zombie"
processes.  See L<perlfunc/waitpid> for more information.

If you try to read from the child's stdout writer and their stderr
writer, you'll have problems with blocking, which means you'll want
to use select() or the IO::Select, which means you'd best use
sysread() instead of readline() for normal stuff.

This is very dangerous, as you may block forever.  It assumes it's
going to talk to something like B<bc>, both writing to it and reading
from it.  This is presumably safe because you "know" that commands
like B<bc> will read a line at a time and output a line at a time.
Programs like B<sort> that read their entire input stream first,
however, are quite apt to cause deadlock.

The big problem with this approach is that if you don't have control
over source code being run in the child process, you can't control
what it does with pipe buffering.  Thus you can't just open a pipe to
C<cat -v> and continually read and write a line from it.

=head1 See Also

=over 4

=item L<IPC::Open2>

Like Open3 but without STDERR catpure.

=item L<IPC::Run>

This is a CPAN module that has better error handling and more facilities
than Open3.

=back

=head1 WARNING

The order of arguments differs from that of open2().

=cut

# &open3: Marc Horowitz <marc@@mit.edu>
# derived mostly from &open2 by tom christiansen, <tchrist@@convex.com>
# fixed for 5.001 by Ulrich Kunitz <kunitz@@mai-koeln.com>
# ported to Win32 by Ron Schmidt, Merrill Lynch almost ended my career
# fixed for autovivving FHs, tchrist again
# allow fd numbers to be used, by Frank Tobin
# allow '-' as command (c.f. open "-|"), by Adam Spiers <perl@@adamspiers.org>
#
# $Id: Open3.pm,v 1.11 2009/10/12 18:24:41 millert Exp $
#
# usage: $pid = open3('wtr', 'rdr', 'err' 'some cmd and args', 'optarg', ...);
#
# spawn the given $cmd and connect rdr for
# reading, wtr for writing, and err for errors.
# if err is '', or the same as rdr, then stdout and
# stderr of the child are on the same fh.  returns pid
# of child (or dies on failure).


# if wtr begins with '<&', then wtr will be closed in the parent, and
# the child will read from it directly.  if rdr or err begins with
# '>&', then the child will send output directly to that fd.  In both
# cases, there will be a dup() instead of a pipe() made.


# WARNING: this is dangerous, as you may block forever
# unless you are very careful.
#
# $wtr is left unbuffered.
#
# abort program if
#   rdr or wtr are null
#   a system call fails

our $Me = 'open3 (bug)';	# you should never see this, it's always localized

# Fatal.pm needs to be fixed WRT prototypes.

sub xfork {
    my $pid = fork;
    defined $pid or croak "$Me: fork failed: $!";
    return $pid;
}

sub xpipe {
    pipe $_[0], $_[1] or croak "$Me: pipe($_[0], $_[1]) failed: $!";
}

# I tried using a * prototype character for the filehandle but it still
# disallows a bearword while compiling under strict subs.

sub xopen {
    open $_[0], $_[1] or croak "$Me: open($_[0], $_[1]) failed: $!";
}

sub xclose {
    close $_[0] or croak "$Me: close($_[0]) failed: $!";
}

sub fh_is_fd {
    return $_[0] =~ /\A=?(\d+)\z/;
}

sub xfileno {
    return $1 if $_[0] =~ /\A=?(\d+)\z/;  # deal with fh just being an fd
    return fileno $_[0];
}

my $do_spawn = $^O eq 'os2' || $^O eq 'MSWin32';

sub _open3 {
    local $Me = shift;
    my($package, $dad_wtr, $dad_rdr, $dad_err, @@cmd) = @@_;
    my($dup_wtr, $dup_rdr, $dup_err, $kidpid);

    if (@@cmd > 1 and $cmd[0] eq '-') {
	croak "Arguments don't make sense when the command is '-'"
    }

    # simulate autovivification of filehandles because
    # it's too ugly to use @@_ throughout to make perl do it for us
    # tchrist 5-Mar-00

    unless (eval  {
	$dad_wtr = $_[1] = gensym unless defined $dad_wtr && length $dad_wtr;
	$dad_rdr = $_[2] = gensym unless defined $dad_rdr && length $dad_rdr;
	1; }) 
    {
	# must strip crud for croak to add back, or looks ugly
	$@@ =~ s/(?<=value attempted) at .*//s;
	croak "$Me: $@@";
    } 

    $dad_err ||= $dad_rdr;

    $dup_wtr = ($dad_wtr =~ s/^[<>]&//);
    $dup_rdr = ($dad_rdr =~ s/^[<>]&//);
    $dup_err = ($dad_err =~ s/^[<>]&//);

    # force unqualified filehandles into caller's package
    $dad_wtr = qualify $dad_wtr, $package unless fh_is_fd($dad_wtr);
    $dad_rdr = qualify $dad_rdr, $package unless fh_is_fd($dad_rdr);
    $dad_err = qualify $dad_err, $package unless fh_is_fd($dad_err);

    my $kid_rdr = gensym;
    my $kid_wtr = gensym;
    my $kid_err = gensym;

    xpipe $kid_rdr, $dad_wtr if !$dup_wtr;
    xpipe $dad_rdr, $kid_wtr if !$dup_rdr;
    xpipe $dad_err, $kid_err if !$dup_err && $dad_err ne $dad_rdr;

    $kidpid = $do_spawn ? -1 : xfork;
    if ($kidpid == 0) {		# Kid
	# A tie in the parent should not be allowed to cause problems.
	untie *STDIN;
	untie *STDOUT;
	# If she wants to dup the kid's stderr onto her stdout I need to
	# save a copy of her stdout before I put something else there.
	if ($dad_rdr ne $dad_err && $dup_err
		&& xfileno($dad_err) == fileno(STDOUT)) {
	    my $tmp = gensym;
	    xopen($tmp, ">&$dad_err");
	    $dad_err = $tmp;
	}

	if ($dup_wtr) {
	    xopen \*STDIN,  "<&$dad_wtr" if fileno(STDIN) != xfileno($dad_wtr);
	} else {
	    xclose $dad_wtr;
	    xopen \*STDIN,  "<&=" . fileno $kid_rdr;
	}
	if ($dup_rdr) {
	    xopen \*STDOUT, ">&$dad_rdr" if fileno(STDOUT) != xfileno($dad_rdr);
	} else {
	    xclose $dad_rdr;
	    xopen \*STDOUT, ">&=" . fileno $kid_wtr;
	}
	if ($dad_rdr ne $dad_err) {
	    if ($dup_err) {
		# I have to use a fileno here because in this one case
		# I'm doing a dup but the filehandle might be a reference
		# (from the special case above).
		xopen \*STDERR, ">&" . xfileno($dad_err)
		    if fileno(STDERR) != xfileno($dad_err);
	    } else {
		xclose $dad_err;
		xopen \*STDERR, ">&=" . fileno $kid_err;
	    }
	} else {
	    xopen \*STDERR, ">&STDOUT" if fileno(STDERR) != fileno(STDOUT);
	}
	return 0 if ($cmd[0] eq '-');
	local($")=(" ");
	exec @@cmd or do {
	    carp "$Me: exec of @@cmd failed";
	    eval { require POSIX; POSIX::_exit(255); };
	    exit 255;
	};
    } elsif ($do_spawn) {
	# All the bookkeeping of coincidence between handles is
	# handled in spawn_with_handles.

	my @@close;
	if ($dup_wtr) {
	  $kid_rdr = \*{$dad_wtr};
	  push @@close, $kid_rdr;
	} else {
	  push @@close, \*{$dad_wtr}, $kid_rdr;
	}
	if ($dup_rdr) {
	  $kid_wtr = \*{$dad_rdr};
	  push @@close, $kid_wtr;
	} else {
	  push @@close, \*{$dad_rdr}, $kid_wtr;
	}
	if ($dad_rdr ne $dad_err) {
	    if ($dup_err) {
	      $kid_err = \*{$dad_err};
	      push @@close, $kid_err;
	    } else {
	      push @@close, \*{$dad_err}, $kid_err;
	    }
	} else {
	  $kid_err = $kid_wtr;
	}
	require IO::Pipe;
	$kidpid = eval {
	    spawn_with_handles( [ { mode => 'r',
				    open_as => $kid_rdr,
				    handle => \*STDIN },
				  { mode => 'w',
				    open_as => $kid_wtr,
				    handle => \*STDOUT },
				  { mode => 'w',
				    open_as => $kid_err,
				    handle => \*STDERR },
				], \@@close, @@cmd);
	};
	die "$Me: $@@" if $@@;
    }

    xclose $kid_rdr if !$dup_wtr;
    xclose $kid_wtr if !$dup_rdr;
    xclose $kid_err if !$dup_err && $dad_rdr ne $dad_err;
    # If the write handle is a dup give it away entirely, close my copy
    # of it.
    xclose $dad_wtr if $dup_wtr;

    select((select($dad_wtr), $| = 1)[0]); # unbuffer pipe
    $kidpid;
}

sub open3 {
    if (@@_ < 4) {
	local $" = ', ';
	croak "open3(@@_): not enough arguments";
    }
    return _open3 'open3', scalar caller, @@_
}

sub spawn_with_handles {
    my $fds = shift;		# Fields: handle, mode, open_as
    my $close_in_child = shift;
    my ($fd, $pid, @@saved_fh, $saved, %saved, @@errs);
    require Fcntl;

    foreach $fd (@@$fds) {
	$fd->{tmp_copy} = IO::Handle->new_from_fd($fd->{handle}, $fd->{mode});
	$saved{fileno $fd->{handle}} = $fd->{tmp_copy};
    }
    foreach $fd (@@$fds) {
	bless $fd->{handle}, 'IO::Handle'
	    unless eval { $fd->{handle}->isa('IO::Handle') } ;
	# If some of handles to redirect-to coincide with handles to
	# redirect, we need to use saved variants:
	$fd->{handle}->fdopen($saved{fileno $fd->{open_as}} || $fd->{open_as},
			      $fd->{mode});
    }
    unless ($^O eq 'MSWin32') {
	# Stderr may be redirected below, so we save the err text:
	foreach $fd (@@$close_in_child) {
	    fcntl($fd, Fcntl::F_SETFD(), 1) or push @@errs, "fcntl $fd: $!"
		unless $saved{fileno $fd}; # Do not close what we redirect!
	}
    }

    unless (@@errs) {
	$pid = eval { system 1, @@_ }; # 1 == P_NOWAIT
	push @@errs, "IO::Pipe: Can't spawn-NOWAIT: $!" if !$pid || $pid < 0;
    }

    foreach $fd (@@$fds) {
	$fd->{handle}->fdopen($fd->{tmp_copy}, $fd->{mode});
	$fd->{tmp_copy}->close or croak "Can't close: $!";
    }
    croak join "\n", @@errs if @@errs;
    return $pid;
}

1; # so require is happy
@


1.11
log
@Merge in perl 5.10.1
@
text
@d124 1
a124 1
# $Id: open3.pl,v 1.1 1993/11/23 06:26:15 marc Exp $
@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d12 1
a12 1
$VERSION	= 1.02;
d26 1
d30 3
d39 3
a41 2
are on the same filehandle.  The CHLD_IN will have autoflush turned
on.
@


1.9
log
@merge in perl 5.8.8
@
text
@d54 6
a59 2
C<exec> failures in the child are not detected.  You'll have to 
trap SIGPIPE yourself.
d90 15
d119 1
a119 1
# $Id: Open3.pm,v 1.8 2004/08/09 18:09:35 millert Exp $
d186 4
d263 1
a263 5
	if ($cmd[0] eq '-') {
	    croak "Arguments don't make sense when the command is '-'"
	      if @@cmd > 1;
	    return 0;
	}
d265 5
a269 2
	exec @@cmd # XXX: wrong process to croak from
	    or croak "$Me: exec of @@cmd failed";
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d12 1
a12 1
$VERSION	= 1.0106;
d22 1
a22 1
    $pid = open3(\*WTRFH, \*RDRFH, \*ERRFH,
d32 11
a42 9
connects RDRFH for reading, WTRFH for writing, and ERRFH for errors.  If
ERRFH is false, or the same file descriptor as RDRFH, then STDOUT and 
STDERR of the child are on the same filehandle.  The WTRFH will have
autoflush turned on.

If WTRFH begins with C<< <& >>, then WTRFH will be closed in the parent, and
the child will read from it directly.  If RDRFH or ERRFH begins with
C<< >& >>, then the child will send output directly to that filehandle.
In both cases, there will be a dup(2) instead of a pipe(2) made.
d100 1
a100 1
# $Id: Open3.pm,v 1.7 2003/12/03 03:02:38 millert Exp $
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d12 1
a12 1
$VERSION	= 1.0105;
d98 1
a98 1
# $Id: open3.pl,v 1.1 1993/11/23 06:26:15 marc Exp $
d200 3
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d12 1
a12 1
$VERSION	= 1.0104;
d55 5
d96 1
d234 5
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d12 1
a12 1
$VERSION	= 1.0103;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d47 3
d55 1
a55 1
open2() does not wait for and reap the child process after it exits.  
d90 1
d143 9
d180 3
a182 3
    $dad_wtr = qualify $dad_wtr, $package;
    $dad_rdr = qualify $dad_rdr, $package;
    $dad_err = qualify $dad_err, $package;
d197 1
a197 1
		&& fileno($dad_err) == fileno(STDOUT)) {
d204 1
a204 1
	    xopen \*STDIN,  "<&$dad_wtr" if fileno(STDIN) != fileno($dad_wtr);
d210 1
a210 1
	    xopen \*STDOUT, ">&$dad_rdr" if fileno(STDOUT) != fileno($dad_rdr);
d220 2
a221 2
		xopen \*STDERR, ">&" . fileno $dad_err
		    if fileno(STDERR) != fileno($dad_err);
@


1.3
log
@perl5.005_03 (stock)
@
text
@d5 1
a5 1
use vars qw($VERSION @@ISA @@EXPORT $Me);
a6 1
require 5.001;
d25 4
d33 3
a35 2
ERRFH is '', or the same as RDRFH, then STDOUT and STDERR of the child are
on the same file handle.  The WTRFH will have autoflush turned on.
d37 1
a37 1
If WTRFH begins with "E<lt>&", then WTRFH will be closed in the parent, and
d39 1
a39 1
"E<gt>&", then the child will send output directly to that file handle.
d42 4
a45 4
If you try to read from the child's stdout writer and their stderr
writer, you'll have problems with blocking, which means you'll
want to use select(), which means you'll have to use sysread() instead
of normal stuff.
d48 10
a57 1
failure: it just raises an exception matching C</^open3:/>.
d59 10
a68 11
=head1 WARNING

It will not create these file handles for you.  You have to do this
yourself.  So don't pass it empty variables expecting them to get filled
in for you.

Additionally, this is very dangerous as you may block forever.  It
assumes it's going to talk to something like B<bc>, both writing to it
and reading from it.  This is presumably safe because you "know" that
commands like B<bc> will read a line at a time and output a line at a
time.  Programs like B<sort> that read their entire input stream first,
d76 4
d86 1
d114 1
a114 1
$Me = 'open3 (bug)';	# you should never see this, it's always localized
d146 15
a160 3
    $dad_wtr			or croak "$Me: wtr should not be null";
    $dad_rdr			or croak "$Me: rdr should not be null";
    $dad_err = $dad_rdr if ($dad_err eq '');
d166 1
a166 1
    # force unqualified filehandles into callers' package
d217 1
a217 1
	exec @@cmd
@


1.2
log
@perl 5.004_04
@
text
@d5 1
a5 1
use vars qw($VERSION @@ISA @@EXPORT $Fh $Me);
d11 1
a11 1
use Symbol 'qualify';
d13 1
a13 1
$VERSION	= 1.0101;
d69 1
a96 1
$Fh = 'FHOPEN000';	# package static in case called more than once
d122 1
a122 1
my $do_spawn = $^O eq 'os2';
d142 3
a144 3
    my $kid_rdr = ++$Fh;
    my $kid_wtr = ++$Fh;
    my $kid_err = ++$Fh;
d156 1
a156 1
	    my $tmp = ++$Fh;
d165 1
a165 2
	    xopen \*STDIN,  "<&$kid_rdr";
	    xclose $kid_rdr;
d171 1
a171 2
	    xopen \*STDOUT, ">&$kid_wtr";
	    xclose $kid_wtr;
d175 4
a178 1
		xopen \*STDERR, ">&$dad_err"
d182 1
a182 2
		xopen \*STDERR, ">&$kid_err";
		xclose $kid_err;
d189 1
a189 1
	    or croak "open3: exec of @@cmd failed";
d196 2
a197 2
	  $kid_rdr = $dad_wtr;
	  push @@close, \*{$kid_rdr};
d199 1
a199 1
	  push @@close, \*{$dad_wtr}, \*{$kid_rdr};
d202 2
a203 2
	  $kid_wtr = $dad_rdr;
	  push @@close, \*{$kid_wtr};
d205 1
a205 1
	  push @@close, \*{$dad_rdr}, \*{$kid_wtr};
d209 2
a210 2
	      $kid_err = $dad_err ;
	      push @@close, \*{$kid_err};
d212 1
a212 1
	      push @@close, \*{$dad_err}, \*{$kid_err};
d220 1
a220 1
				    open_as => \*{$kid_rdr},
d223 1
a223 1
				    open_as => \*{$kid_wtr},
d226 1
a226 1
				    open_as => \*{$kid_err},
d230 1
a230 1
	die "open3: $@@" if $@@;
d270 6
a275 4
    # Stderr may be redirected below, so we save the err text:
    foreach $fd (@@$close_in_child) {
	fcntl($fd, Fcntl::F_SETFD(), 1) or push @@errs, "fcntl $fd: $!"
	    unless $saved{fileno $fd};	# Do not close what we redirect!
@


1.1
log
@Initial revision
@
text
@d2 5
d9 1
d11 5
d23 1
a23 1
    $pid = open3(\*WTRFH, \*RDRFH, \*ERRFH 
d31 1
a31 1
on the same file handle.
d33 1
a33 1
If WTRFH begins with "<&", then WTRFH will be closed in the parent, and
d35 2
a36 2
">&", then the child will send output directly to that file handle.  In both
cases, there will be a dup(2) instead of a pipe(2) made.
d43 20
a62 1
All caveats from open2() continue to apply.  See L<open2> for details.
a65 3
@@ISA = qw(Exporter);
@@EXPORT = qw(open3);

d78 1
a78 1
# of child, or 0 on failure.
d94 1
a94 1
#   pipe or fork or exec fails
d96 2
a97 1
$fh = 'FHOPEN000';  # package static in case called more than once
d99 29
a127 4
sub open3 {
    my($kidpid);
    my($dad_wtr, $dad_rdr, $dad_err, @@cmd) = @@_;
    my($dup_wtr, $dup_rdr, $dup_err);
d129 2
a130 2
    $dad_wtr			|| croak "open3: wtr should not be null";
    $dad_rdr			|| croak "open3: rdr should not be null";
d138 22
a159 8
    my($package) = caller;
    $dad_wtr =~ s/^[^:]+$/$package\:\:$&/ unless ref $dad_wtr;
    $dad_rdr =~ s/^[^:]+$/$package\:\:$&/ unless ref $dad_rdr;
    $dad_err =~ s/^[^:]+$/$package\:\:$&/ unless ref $dad_err;

    my($kid_rdr) = ++$fh;
    my($kid_wtr) = ++$fh;
    my($kid_err) = ++$fh;
a160 13
    if (!$dup_wtr) {
	pipe($kid_rdr, $dad_wtr)    || croak "open3: pipe 1 (stdin) failed: $!";
    }
    if (!$dup_rdr) {
	pipe($dad_rdr, $kid_wtr)    || croak "open3: pipe 2 (stdout) failed: $!";
    }
    if ($dad_err ne $dad_rdr && !$dup_err) {
	pipe($dad_err, $kid_err)    || croak "open3: pipe 3 (stderr) failed: $!";
    }

    if (($kidpid = fork) < 0) {
        croak "open3: fork failed: $!";
    } elsif ($kidpid == 0) {
d162 1
a162 1
	    open(STDIN,  "<&$dad_wtr") if (fileno(STDIN) != fileno($dad_wtr));
d164 3
a166 2
	    close($dad_wtr);
	    open(STDIN,  "<&$kid_rdr");
d169 1
a169 1
	    open(STDOUT, ">&$dad_rdr") if (fileno(STDOUT) != fileno($dad_rdr));
d171 3
a173 2
	    close($dad_rdr);
	    open(STDOUT, ">&$kid_wtr");
d177 2
a178 2
		open(STDERR, ">&$dad_err")
		    if (fileno(STDERR) != fileno($dad_err));
d180 3
a182 2
		close($dad_err);
		open(STDERR, ">&$kid_err");
d185 1
a185 1
	    open(STDERR, ">&STDOUT") if (fileno(STDERR) != fileno(STDOUT));
d190 41
d233 6
a238 4
    close $kid_rdr; close $kid_wtr; close $kid_err;
    if ($dup_wtr) {
	close($dad_wtr);
    }
d243 46
a289 1

@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a1 5

use strict;
no strict 'refs'; # because users pass me bareword filehandles
use vars qw($VERSION @@ISA @@EXPORT $Me);

a3 1

a4 5
use Symbol qw(gensym qualify);

$VERSION	= 1.0103;
@@ISA		= qw(Exporter);
@@EXPORT		= qw(open3);
d12 1
a12 1
    $pid = open3(\*WTRFH, \*RDRFH, \*ERRFH,
d20 1
a20 1
on the same file handle.  The WTRFH will have autoflush turned on.
d22 1
a22 1
If WTRFH begins with "E<lt>&", then WTRFH will be closed in the parent, and
d24 2
a25 2
"E<gt>&", then the child will send output directly to that file handle.
In both cases, there will be a dup(2) instead of a pipe(2) made.
d32 1
a32 2
open3() returns the process ID of the child process.  It doesn't return on
failure: it just raises an exception matching C</^open3:/>.
d34 1
a34 17
=head1 WARNING

It will not create these file handles for you.  You have to do this
yourself.  So don't pass it empty variables expecting them to get filled
in for you.

Additionally, this is very dangerous as you may block forever.  It
assumes it's going to talk to something like B<bc>, both writing to it
and reading from it.  This is presumably safe because you "know" that
commands like B<bc> will read a line at a time and output a line at a
time.  Programs like B<sort> that read their entire input stream first,
however, are quite apt to cause deadlock.

The big problem with this approach is that if you don't have control
over source code being run in the child process, you can't control
what it does with pipe buffering.  Thus you can't just open a pipe to
C<cat -v> and continually read and write a line from it.
d36 2
a37 1
=cut
a41 1
# ported to Win32 by Ron Schmidt, Merrill Lynch almost ended my career
d51 1
a51 1
# of child (or dies on failure).
d67 1
a67 1
#   a system call fails
d69 1
a69 1
$Me = 'open3 (bug)';	# you should never see this, it's always localized
d71 4
a74 24
# Fatal.pm needs to be fixed WRT prototypes.

sub xfork {
    my $pid = fork;
    defined $pid or croak "$Me: fork failed: $!";
    return $pid;
}

sub xpipe {
    pipe $_[0], $_[1] or croak "$Me: pipe($_[0], $_[1]) failed: $!";
}

# I tried using a * prototype character for the filehandle but it still
# disallows a bearword while compiling under strict subs.

sub xopen {
    open $_[0], $_[1] or croak "$Me: open($_[0], $_[1]) failed: $!";
}

sub xclose {
    close $_[0] or croak "$Me: close($_[0]) failed: $!";
}

my $do_spawn = $^O eq 'os2' || $^O eq 'MSWin32';
d76 2
a77 7
sub _open3 {
    local $Me = shift;
    my($package, $dad_wtr, $dad_rdr, $dad_err, @@cmd) = @@_;
    my($dup_wtr, $dup_rdr, $dup_err, $kidpid);

    $dad_wtr			or croak "$Me: wtr should not be null";
    $dad_rdr			or croak "$Me: rdr should not be null";
d85 18
a102 22
    $dad_wtr = qualify $dad_wtr, $package;
    $dad_rdr = qualify $dad_rdr, $package;
    $dad_err = qualify $dad_err, $package;

    my $kid_rdr = gensym;
    my $kid_wtr = gensym;
    my $kid_err = gensym;

    xpipe $kid_rdr, $dad_wtr if !$dup_wtr;
    xpipe $dad_rdr, $kid_wtr if !$dup_rdr;
    xpipe $dad_err, $kid_err if !$dup_err && $dad_err ne $dad_rdr;

    $kidpid = $do_spawn ? -1 : xfork;
    if ($kidpid == 0) {		# Kid
	# If she wants to dup the kid's stderr onto her stdout I need to
	# save a copy of her stdout before I put something else there.
	if ($dad_rdr ne $dad_err && $dup_err
		&& fileno($dad_err) == fileno(STDOUT)) {
	    my $tmp = gensym;
	    xopen($tmp, ">&$dad_err");
	    $dad_err = $tmp;
	}
d104 3
d108 1
a108 1
	    xopen \*STDIN,  "<&$dad_wtr" if fileno(STDIN) != fileno($dad_wtr);
d110 2
a111 2
	    xclose $dad_wtr;
	    xopen \*STDIN,  "<&=" . fileno $kid_rdr;
d114 1
a114 1
	    xopen \*STDOUT, ">&$dad_rdr" if fileno(STDOUT) != fileno($dad_rdr);
d116 2
a117 2
	    xclose $dad_rdr;
	    xopen \*STDOUT, ">&=" . fileno $kid_wtr;
d121 2
a122 5
		# I have to use a fileno here because in this one case
		# I'm doing a dup but the filehandle might be a reference
		# (from the special case above).
		xopen \*STDERR, ">&" . fileno $dad_err
		    if fileno(STDERR) != fileno($dad_err);
d124 2
a125 2
		xclose $dad_err;
		xopen \*STDERR, ">&=" . fileno $kid_err;
d128 1
a128 1
	    xopen \*STDERR, ">&STDOUT" if fileno(STDERR) != fileno(STDOUT);
d132 2
a133 4
	    or croak "$Me: exec of @@cmd failed";
    } elsif ($do_spawn) {
	# All the bookkeeping of coincidence between handles is
	# handled in spawn_with_handles.
d135 3
a137 37
	my @@close;
	if ($dup_wtr) {
	  $kid_rdr = \*{$dad_wtr};
	  push @@close, $kid_rdr;
	} else {
	  push @@close, \*{$dad_wtr}, $kid_rdr;
	}
	if ($dup_rdr) {
	  $kid_wtr = \*{$dad_rdr};
	  push @@close, $kid_wtr;
	} else {
	  push @@close, \*{$dad_rdr}, $kid_wtr;
	}
	if ($dad_rdr ne $dad_err) {
	    if ($dup_err) {
	      $kid_err = \*{$dad_err};
	      push @@close, $kid_err;
	    } else {
	      push @@close, \*{$dad_err}, $kid_err;
	    }
	} else {
	  $kid_err = $kid_wtr;
	}
	require IO::Pipe;
	$kidpid = eval {
	    spawn_with_handles( [ { mode => 'r',
				    open_as => $kid_rdr,
				    handle => \*STDIN },
				  { mode => 'w',
				    open_as => $kid_wtr,
				    handle => \*STDOUT },
				  { mode => 'w',
				    open_as => $kid_err,
				    handle => \*STDERR },
				], \@@close, @@cmd);
	};
	die "$Me: $@@" if $@@;
a139 7
    xclose $kid_rdr if !$dup_wtr;
    xclose $kid_wtr if !$dup_rdr;
    xclose $kid_err if !$dup_err && $dad_rdr ne $dad_err;
    # If the write handle is a dup give it away entirely, close my copy
    # of it.
    xclose $dad_wtr if $dup_wtr;

d143 1
a144 48
sub open3 {
    if (@@_ < 4) {
	local $" = ', ';
	croak "open3(@@_): not enough arguments";
    }
    return _open3 'open3', scalar caller, @@_
}

sub spawn_with_handles {
    my $fds = shift;		# Fields: handle, mode, open_as
    my $close_in_child = shift;
    my ($fd, $pid, @@saved_fh, $saved, %saved, @@errs);
    require Fcntl;

    foreach $fd (@@$fds) {
	$fd->{tmp_copy} = IO::Handle->new_from_fd($fd->{handle}, $fd->{mode});
	$saved{fileno $fd->{handle}} = $fd->{tmp_copy};
    }
    foreach $fd (@@$fds) {
	bless $fd->{handle}, 'IO::Handle'
	    unless eval { $fd->{handle}->isa('IO::Handle') } ;
	# If some of handles to redirect-to coincide with handles to
	# redirect, we need to use saved variants:
	$fd->{handle}->fdopen($saved{fileno $fd->{open_as}} || $fd->{open_as},
			      $fd->{mode});
    }
    unless ($^O eq 'MSWin32') {
	# Stderr may be redirected below, so we save the err text:
	foreach $fd (@@$close_in_child) {
	    fcntl($fd, Fcntl::F_SETFD(), 1) or push @@errs, "fcntl $fd: $!"
		unless $saved{fileno $fd}; # Do not close what we redirect!
	}
    }

    unless (@@errs) {
	$pid = eval { system 1, @@_ }; # 1 == P_NOWAIT
	push @@errs, "IO::Pipe: Can't spawn-NOWAIT: $!" if !$pid || $pid < 0;
    }

    foreach $fd (@@$fds) {
	$fd->{handle}->fdopen($fd->{tmp_copy}, $fd->{mode});
	$fd->{tmp_copy}->close or croak "Can't close: $!";
    }
    croak join "\n", @@errs if @@errs;
    return $pid;
}

1; # so require is happy
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d5 1
a5 1
our ($VERSION, @@ISA, @@EXPORT);
d7 1
a25 4
    my($wtr, $rdr, $err);
    $pid = open3($wtr, $rdr, $err,
		    'some cmd and args', 'optarg', ...);

d30 2
a31 3
ERRFH is false, or the same file descriptor as RDRFH, then STDOUT and 
STDERR of the child are on the same filehandle.  The WTRFH will have
autoflush turned on.
d33 1
a33 1
If WTRFH begins with C<< <& >>, then WTRFH will be closed in the parent, and
d35 1
a35 1
C<< >& >>, then the child will send output directly to that filehandle.
d38 4
a41 4
If either reader or writer is the null string, this will be replaced
by an autogenerated filehandle.  If so, you must pass a valid lvalue
in the parameter slot so it can be overwritten in the caller, or 
an exception will be raised.
d44 3
a46 10
failure: it just raises an exception matching C</^open3:/>.  However,
C<exec> failures in the child are not detected.  You'll have to 
trap SIGPIPE yourself.

open2() does not wait for and reap the child process after it exits.  
Except for short programs where it's acceptable to let the operating system
take care of this, you need to do this yourself.  This is normally as 
simple as calling C<waitpid $pid, 0> when you're done with the process.
Failing to do this can result in an accumulation of defunct or "zombie"
processes.  See L<perlfunc/waitpid> for more information.
d48 9
a56 10
If you try to read from the child's stdout writer and their stderr
writer, you'll have problems with blocking, which means you'll want
to use select() or the IO::Select, which means you'd best use
sysread() instead of readline() for normal stuff.

This is very dangerous, as you may block forever.  It assumes it's
going to talk to something like B<bc>, both writing to it and reading
from it.  This is presumably safe because you "know" that commands
like B<bc> will read a line at a time and output a line at a time.
Programs like B<sort> that read their entire input stream first,
a63 4
=head1 WARNING

The order of arguments differs from that of open2().

a69 1
# fixed for autovivving FHs, tchrist again
d97 1
a97 1
our $Me = 'open3 (bug)';	# you should never see this, it's always localized
d129 3
a131 15
    # simulate autovivification of filehandles because
    # it's too ugly to use @@_ throughout to make perl do it for us
    # tchrist 5-Mar-00

    unless (eval  {
	$dad_wtr = $_[1] = gensym unless defined $dad_wtr && length $dad_wtr;
	$dad_rdr = $_[2] = gensym unless defined $dad_rdr && length $dad_rdr;
	1; }) 
    {
	# must strip crud for croak to add back, or looks ugly
	$@@ =~ s/(?<=value attempted) at .*//s;
	croak "$Me: $@@";
    } 

    $dad_err ||= $dad_rdr;
d137 1
a137 1
    # force unqualified filehandles into caller's package
d188 1
a188 1
	exec @@cmd # XXX: wrong process to croak from
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a46 3
The filehandles may also be integers, in which case they are understood
as file descriptors.

d52 1
a52 1
open3() does not wait for and reap the child process after it exits.  
a86 1
# allow fd numbers to be used, by Frank Tobin
a138 9
sub fh_is_fd {
    return $_[0] =~ /\A=?(\d+)\z/;
}

sub xfileno {
    return $1 if $_[0] =~ /\A=?(\d+)\z/;  # deal with fh just being an fd
    return fileno $_[0];
}

d167 3
a169 3
    $dad_wtr = qualify $dad_wtr, $package unless fh_is_fd($dad_wtr);
    $dad_rdr = qualify $dad_rdr, $package unless fh_is_fd($dad_rdr);
    $dad_err = qualify $dad_err, $package unless fh_is_fd($dad_err);
d184 1
a184 1
		&& xfileno($dad_err) == fileno(STDOUT)) {
d191 1
a191 1
	    xopen \*STDIN,  "<&$dad_wtr" if fileno(STDIN) != xfileno($dad_wtr);
d197 1
a197 1
	    xopen \*STDOUT, ">&$dad_rdr" if fileno(STDOUT) != xfileno($dad_rdr);
d207 2
a208 2
		xopen \*STDERR, ">&" . xfileno($dad_err)
		    if fileno(STDERR) != xfileno($dad_err);
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d12 1
a12 1
$VERSION	= 1.0104;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d12 1
a12 1
$VERSION	= 1.0105;
a54 5
Note if you specify C<-> as the command, in an analogous fashion to
C<open(FOO, "-|")> the child process will just be the forked Perl
process rather than an external command.  This feature isn't yet
supported on Win32 platforms.

a90 1
# allow '-' as command (c.f. open "-|"), by Adam Spiers <perl@@adamspiers.org>
a227 5
	}
	if ($cmd[0] eq '-') {
	    croak "Arguments don't make sense when the command is '-'"
	      if @@cmd > 1;
	    return 0;
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d12 1
a12 1
$VERSION	= 1.0106;
d98 1
a98 1
# $Id: Open3.pm,v 1.7 2003/12/03 03:02:38 millert Exp $
a199 3
	# A tie in the parent should not be allowed to cause problems.
	untie *STDIN;
	untie *STDOUT;
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d98 1
a98 1
# $Id: open3.pl,v 1.1 1993/11/23 06:26:15 marc Exp $
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d12 1
a12 1
$VERSION	= 1.02;
d22 1
a22 1
    $pid = open3(\*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR,
d32 9
a40 11
connects CHLD_OUT for reading from the child, CHLD_IN for writing to
the child, and CHLD_ERR for errors.  If CHLD_ERR is false, or the
same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child
are on the same filehandle.  The CHLD_IN will have autoflush turned
on.

If CHLD_IN begins with C<< <& >>, then CHLD_IN will be closed in the
parent, and the child will read from it directly.  If CHLD_OUT or
CHLD_ERR begins with C<< >& >>, then the child will send output
directly to that filehandle.  In both cases, there will be a dup(2)
instead of a pipe(2) made.
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d54 2
a55 6
C<exec> failures in the child (such as no such file or permission denied),
are just reported to CHLD_ERR, as it is not possible to trap them.

If the child process dies for any reason, the next write to CHLD_IN is
likely to generate a SIGPIPE in the parent, which is fatal by default.
So you may wish to handle this signal.
a85 15
=head1 See Also

=over 4

=item L<IPC::Open2>

Like Open3 but without STDERR catpure.

=item L<IPC::Run>

This is a CPAN module that has better error handling and more facilities
than Open3.

=back

a166 4
    if (@@cmd > 1 and $cmd[0] eq '-') {
	croak "Arguments don't make sense when the command is '-'"
    }

d240 5
a244 1
	return 0 if ($cmd[0] eq '-');
d246 2
a247 5
	exec @@cmd or do {
	    carp "$Me: exec of @@cmd failed";
	    eval { require POSIX; POSIX::_exit(255); };
	    exit 255;
	};
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d12 1
a12 1
$VERSION	= 1.04;
a25 1
    use Symbol 'gensym'; $err = gensym;
a28 3
    waitpid( $pid, 0 );
    my $child_exit_status = $? >> 8;

d35 2
a36 3
are on the same filehandle (this means that an autovivified lexical
cannot be used for the STDERR filehandle, see SYNOPSIS).  The CHLD_IN
will have autoflush turned on.
@


