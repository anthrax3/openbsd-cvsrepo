head	1.9;
access;
symbols
	OPENBSD_5_3:1.8.0.14
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.12
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.10
	OPENBSD_5_0:1.8.0.8
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.6
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.5.0.20
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.18
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.16
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.14
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.12
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.10
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.8
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.6
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.5.0.2
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.9
date	2013.03.25.20.40.56;	author sthen;	state dead;
branches;
next	1.8;

1.8
date	2009.10.13.01.25.48;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.12.18.24.44;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.30.12.21.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.03.03.02.41;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.54;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.51;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.18;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.10;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@package Text::Abbrev;
require 5.005;		# Probably works on earlier versions too.
require Exporter;

our $VERSION = '1.01';

=head1 NAME

Text::Abbrev - create an abbreviation table from a list

=head1 SYNOPSIS

    use Text::Abbrev;
    abbrev $hashref, LIST


=head1 DESCRIPTION

Stores all unambiguous truncations of each element of LIST
as keys in the associative array referenced by C<$hashref>.
The values are the original list elements.

=head1 EXAMPLE

    $hashref = abbrev qw(list edit send abort gripe);

    %hash = abbrev qw(list edit send abort gripe);

    abbrev $hashref, qw(list edit send abort gripe);

    abbrev(*hash, qw(list edit send abort gripe));

=cut

@@ISA = qw(Exporter);
@@EXPORT = qw(abbrev);

# Usage:
#	abbrev \%foo, LIST;
#	...
#	$long = $foo{$short};

sub abbrev {
    my ($word, $hashref, $glob, %table, $returnvoid);

    @@_ or return;   # So we don't autovivify onto @@_ and trigger warning
    if (ref($_[0])) {           # hash reference preferably
      $hashref = shift;
      $returnvoid = 1;
    } elsif (ref \$_[0] eq 'GLOB') {  # is actually a glob (deprecated)
      $hashref = \%{shift()};
      $returnvoid = 1;
    }
    %{$hashref} = ();

    WORD: foreach $word (@@_) {
        for (my $len = (length $word) - 1; $len > 0; --$len) {
	    my $abbrev = substr($word,0,$len);
	    my $seen = ++$table{$abbrev};
	    if ($seen == 1) {	    # We're the first word so far to have
	    			    # this abbreviation.
	        $hashref->{$abbrev} = $word;
	    } elsif ($seen == 2) {  # We're the second word to have this
	    			    # abbreviation, so we can't use it.
	        delete $hashref->{$abbrev};
	    } else {		    # We're the third word to have this
	    			    # abbreviation, so skip to the next word.
	        next WORD;
	    }
	}
    }
    # Non-abbreviations always get entered, even if they aren't unique
    foreach $word (@@_) {
        $hashref->{$word} = $word;
    }
    return if $returnvoid;
    if (wantarray) {
      %{$hashref};
    } else {
      $hashref;
    }
}

1;
@


1.8
log
@Merge in some local changes that got lost.
@
text
@@


1.7
log
@Merge in perl 5.10.1
@
text
@d9 1
a9 1
abbrev - create an abbreviation table from a list
@


1.6
log
@Remove a couple more bogus man pages and add missing MLINKs.  The
makewhatis info for the perl man pages now matches the pages themselves.
@
text
@d9 1
a9 1
Text::Abbrev - create an abbreviation table from a list
@


1.5
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d9 1
a9 1
abbrev - create an abbreviation table from a list
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d5 1
a5 1
our $VERSION = '1.00';
d46 1
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d5 2
@


1.2
log
@perl 5.004_04
@
text
@d2 1
a2 1
require 5.000;
d18 1
a18 1
as keys key in the associative array referenced to by C<$hashref>.
d37 1
a37 1
#	&abbrev(*foo,LIST);
d42 1
a42 2
    my (%domain);
    my ($name, $ref, $glob);
d45 21
a65 17
      $ref = shift;
    } elsif ($_[0] =~ /^\*/) {  # looks like a glob (deprecated)
      $glob = shift;
    } 
    my @@cmp = @@_;

    foreach $name (@@_) {
	my @@extra = split(//,$name);
	my $abbrev = shift(@@extra);
	my $len = 1;
        my $cmp;
	WORD: foreach $cmp (@@cmp) {
	    next if $cmp eq $name;
	    while (substr($cmp,0,$len) eq $abbrev) {
                last WORD unless @@extra;
                $abbrev .= shift(@@extra);
		++$len;
a67 5
	$domain{$abbrev} = $name;
	while (@@extra) {
	    $abbrev .= shift(@@extra);
	    $domain{$abbrev} = $name;
	}
d69 3
a71 7
    if ($ref) {
      %$ref = %domain;
      return;
    } elsif ($glob) {           # old style
      local (*hash) = $glob;
      %hash = %domain;
      return;
d73 1
d75 1
a75 1
      %domain;
d77 1
a77 1
      \%domain;
a81 1

@


1.1
log
@Initial revision
@
text
@d11 2
a12 2
    use Abbrev;
    abbrev *HASH, LIST
d18 1
a18 1
as keys key in the associative array indicated by C<*hash>.
d23 7
a29 1
    abbrev(*hash,qw("list edit send abort gripe"));
d42 10
a51 3
    local(*domain) = shift;
    @@cmp = @@_;
    %domain = ();
d53 5
a57 4
	@@extra = split(//,$name);
	$abbrev = shift(@@extra);
	$len = 1;
	foreach $cmp (@@cmp) {
d60 2
a61 1
		$abbrev .= shift(@@extra);
d70 13
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d11 2
a12 2
    use Text::Abbrev;
    abbrev $hashref, LIST
d18 1
a18 1
as keys key in the associative array referenced to by C<$hashref>.
d23 1
a23 7
    $hashref = abbrev qw(list edit send abort gripe);

    %hash = abbrev qw(list edit send abort gripe);

    abbrev $hashref, qw(list edit send abort gripe);

    abbrev(*hash, qw(list edit send abort gripe));
d36 3
a38 10
    my (%domain);
    my ($name, $ref, $glob);

    if (ref($_[0])) {           # hash reference preferably
      $ref = shift;
    } elsif ($_[0] =~ /^\*/) {  # looks like a glob (deprecated)
      $glob = shift;
    } 
    my @@cmp = @@_;

d40 4
a43 5
	my @@extra = split(//,$name);
	my $abbrev = shift(@@extra);
	my $len = 1;
        my $cmp;
	WORD: foreach $cmp (@@cmp) {
d46 1
a46 2
                last WORD unless @@extra;
                $abbrev .= shift(@@extra);
a54 13
    }
    if ($ref) {
      %$ref = %domain;
      return;
    } elsif ($glob) {           # old style
      local (*hash) = $glob;
      %hash = %domain;
      return;
    }
    if (wantarray) {
      %domain;
    } else {
      \%domain;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d2 1
a2 1
require 5.005;		# Probably works on earlier versions too.
d18 1
a18 1
as keys in the associative array referenced by C<$hashref>.
d37 1
a37 1
#	abbrev \%foo, LIST;
d42 2
a43 1
    my ($word, $hashref, $glob, %table, $returnvoid);
d46 17
a62 21
      $hashref = shift;
      $returnvoid = 1;
    } elsif (ref \$_[0] eq 'GLOB') {  # is actually a glob (deprecated)
      $hashref = \%{shift()};
      $returnvoid = 1;
    }
    %{$hashref} = ();

    WORD: foreach $word (@@_) {
        for (my $len = (length $word) - 1; $len > 0; --$len) {
	    my $abbrev = substr($word,0,$len);
	    my $seen = ++$table{$abbrev};
	    if ($seen == 1) {	    # We're the first word so far to have
	    			    # this abbreviation.
	        $hashref->{$abbrev} = $word;
	    } elsif ($seen == 2) {  # We're the second word to have this
	    			    # abbreviation, so we can't use it.
	        delete $hashref->{$abbrev};
	    } else {		    # We're the third word to have this
	    			    # abbreviation, so skip to the next word.
	        next WORD;
d65 5
d71 7
a77 3
    # Non-abbreviations always get entered, even if they aren't unique
    foreach $word (@@_) {
        $hashref->{$word} = $word;
a78 1
    return if $returnvoid;
d80 1
a80 1
      %{$hashref};
d82 1
a82 1
      $hashref;
d87 1
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@a4 2
our $VERSION = '1.00';

@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d5 1
a5 1
our $VERSION = '1.01';
a45 1
    @@_ or return;   # So we don't autovivify onto @@_ and trigger warning
@


