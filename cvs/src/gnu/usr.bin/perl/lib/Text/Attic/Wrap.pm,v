head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.8
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.6
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.4
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2010.09.24.14.59.52;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.44;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.14;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.08;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.09.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.41;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.01;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.06;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.51;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.19;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.38;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.10;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.47.27;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.49.00;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.44;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.10.56;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Text::Wrap;

use warnings::register;
require Exporter;

@@ISA = qw(Exporter);
@@EXPORT = qw(wrap fill);
@@EXPORT_OK = qw($columns $break $huge);

$VERSION = 2009.0305;

use vars qw($VERSION $columns $debug $break $huge $unexpand $tabstop
	$separator $separator2);
use strict;

BEGIN	{
	$columns = 76;  # <= screen width
	$debug = 0;
	$break = '\s';
	$huge = 'wrap'; # alternatively: 'die' or 'overflow'
	$unexpand = 1;
	$tabstop = 8;
	$separator = "\n";
	$separator2 = undef;
}

use Text::Tabs qw(expand unexpand);

sub wrap
{
	my ($ip, $xp, @@t) = @@_;

	local($Text::Tabs::tabstop) = $tabstop;
	my $r = "";
	my $tail = pop(@@t);
	my $t = expand(join("", (map { /\s+\z/ ? ( $_ ) : ($_, ' ') } @@t), $tail));
	my $lead = $ip;
	my $nll = $columns - length(expand($xp)) - 1;
	if ($nll <= 0 && $xp ne '') {
		my $nc = length(expand($xp)) + 2;
		warnings::warnif "Increasing \$Text::Wrap::columns from $columns to $nc to accommodate length of subsequent tab";
		$columns = $nc;
		$nll = 1;
	}
	my $ll = $columns - length(expand($ip)) - 1;
	$ll = 0 if $ll < 0;
	my $nl = "";
	my $remainder = "";

	use re 'taint';

	pos($t) = 0;
	while ($t !~ /\G(?:$break)*\Z/gc) {
		if ($t =~ /\G([^\n]{0,$ll})($break|\n+|\z)/xmgc) {
			$r .= $unexpand 
				? unexpand($nl . $lead . $1)
				: $nl . $lead . $1;
			$remainder = $2;
		} elsif ($huge eq 'wrap' && $t =~ /\G([^\n]{$ll})/gc) {
			$r .= $unexpand 
				? unexpand($nl . $lead . $1)
				: $nl . $lead . $1;
			$remainder = defined($separator2) ? $separator2 : $separator;
		} elsif ($huge eq 'overflow' && $t =~ /\G([^\n]*?)($break|\n+|\z)/xmgc) {
			$r .= $unexpand 
				? unexpand($nl . $lead . $1)
				: $nl . $lead . $1;
			$remainder = $2;
		} elsif ($huge eq 'die') {
			die "couldn't wrap '$t'";
		} elsif ($columns < 2) {
			warnings::warnif "Increasing \$Text::Wrap::columns from $columns to 2";
			$columns = 2;
			return ($ip, $xp, @@t);
		} else {
			die "This shouldn't happen";
		}
			
		$lead = $xp;
		$ll = $nll;
		$nl = defined($separator2)
			? ($remainder eq "\n"
				? "\n"
				: $separator2)
			: $separator;
	}
	$r .= $remainder;

	print "-----------$r---------\n" if $debug;

	print "Finish up with '$lead'\n" if $debug;

	$r .= $lead . substr($t, pos($t), length($t)-pos($t))
		if pos($t) ne length($t);

	print "-----------$r---------\n" if $debug;;

	return $r;
}

sub fill 
{
	my ($ip, $xp, @@raw) = @@_;
	my @@para;
	my $pp;

	for $pp (split(/\n\s+/, join("\n",@@raw))) {
		$pp =~ s/\s+/ /g;
		my $x = wrap($ip, $xp, $pp);
		push(@@para, $x);
	}

	# if paragraph_indent is the same as line_indent, 
	# separate paragraphs with blank lines

	my $ps = ($ip eq $xp) ? "\n\n" : "\n";
	return join ($ps, @@para);
}

1;
__END__

=head1 NAME

Text::Wrap - line wrapping to form simple paragraphs

=head1 SYNOPSIS 

B<Example 1>

	use Text::Wrap;

	$initial_tab = "\t";	# Tab before first line
	$subsequent_tab = "";	# All other lines flush left

	print wrap($initial_tab, $subsequent_tab, @@text);
	print fill($initial_tab, $subsequent_tab, @@text);

	$lines = wrap($initial_tab, $subsequent_tab, @@text);

	@@paragraphs = fill($initial_tab, $subsequent_tab, @@text);

B<Example 2>

	use Text::Wrap qw(wrap $columns $huge);

	$columns = 132;		# Wrap at 132 characters
	$huge = 'die';
	$huge = 'wrap';
	$huge = 'overflow';

B<Example 3>
	
	use Text::Wrap;

	$Text::Wrap::columns = 72;
	print wrap('', '', @@text);

=head1 DESCRIPTION

C<Text::Wrap::wrap()> is a very simple paragraph formatter.  It formats a
single paragraph at a time by breaking lines at word boundaries.
Indentation is controlled for the first line (C<$initial_tab>) and
all subsequent lines (C<$subsequent_tab>) independently.  Please note: 
C<$initial_tab> and C<$subsequent_tab> are the literal strings that will
be used: it is unlikely you would want to pass in a number.

Text::Wrap::fill() is a simple multi-paragraph formatter.  It formats
each paragraph separately and then joins them together when it's done.  It
will destroy any whitespace in the original text.  It breaks text into
paragraphs by looking for whitespace after a newline.  In other respects
it acts like wrap().

Both C<wrap()> and C<fill()> return a single string.

=head1 OVERRIDES

C<Text::Wrap::wrap()> has a number of variables that control its behavior.
Because other modules might be using C<Text::Wrap::wrap()> it is suggested
that you leave these variables alone!  If you can't do that, then 
use C<local($Text::Wrap::VARIABLE) = YOURVALUE> when you change the
values so that the original value is restored.  This C<local()> trick
will not work if you import the variable into your own namespace.

Lines are wrapped at C<$Text::Wrap::columns> columns (default value: 76).
C<$Text::Wrap::columns> should be set to the full width of your output
device.  In fact, every resulting line will have length of no more than
C<$columns - 1>.

It is possible to control which characters terminate words by
modifying C<$Text::Wrap::break>. Set this to a string such as
C<'[\s:]'> (to break before spaces or colons) or a pre-compiled regexp
such as C<qr/[\s']/> (to break before spaces or apostrophes). The
default is simply C<'\s'>; that is, words are terminated by spaces.
(This means, among other things, that trailing punctuation  such as
full stops or commas stay with the word they are "attached" to.)
Setting C<$Text::Wrap::break> to a regular expression that doesn't
eat any characters (perhaps just a forward look-ahead assertion) will
cause warnings.

Beginner note: In example 2, above C<$columns> is imported into
the local namespace, and set locally.  In example 3,
C<$Text::Wrap::columns> is set in its own namespace without importing it.

C<Text::Wrap::wrap()> starts its work by expanding all the tabs in its
input into spaces.  The last thing it does it to turn spaces back
into tabs.  If you do not want tabs in your results, set 
C<$Text::Wrap::unexpand> to a false value.  Likewise if you do not
want to use 8-character tabstops, set C<$Text::Wrap::tabstop> to
the number of characters you do want for your tabstops.

If you want to separate your lines with something other than C<\n>
then set C<$Text::Wrap::separator> to your preference.  This replaces
all newlines with C<$Text::Wrap::separator>.  If you just want to 
preserve existing newlines but add new breaks with something else, set
C<$Text::Wrap::separator2> instead.

When words that are longer than C<$columns> are encountered, they
are broken up.  C<wrap()> adds a C<"\n"> at column C<$columns>.
This behavior can be overridden by setting C<$huge> to
'die' or to 'overflow'.  When set to 'die', large words will cause
C<die()> to be called.  When set to 'overflow', large words will be
left intact.  

Historical notes: 'die' used to be the default value of
C<$huge>.  Now, 'wrap' is the default value.

=head1 EXAMPLES

Code:

  print wrap("\t","",<<END);
  This is a bit of text that forms 
  a normal book-style indented paragraph
  END

Result:

  "	This is a bit of text that forms
  a normal book-style indented paragraph   
  "

Code:

  $Text::Wrap::columns=20;
  $Text::Wrap::separator="|";
  print wrap("","","This is a bit of text that forms a normal book-style paragraph");

Result:

  "This is a bit of|text that forms a|normal book-style|paragraph"

=head1 SEE ALSO

For wrapping multi-byte characters: L<Text::WrapI18N>.
For more detailed controls: L<Text::Format>.

=head1 LICENSE

David Muir Sharnoff <muir@@idiom.org> with help from Tim Pierce and
many many others.  Copyright (C) 1996-2009 David Muir Sharnoff.  
This module may be modified, used, copied, and redistributed at
your own risk.  Publicly redistributed versions that are modified 
must use a different name.

@


1.10
log
@Merge in perl 5.10.1
@
text
@@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d10 1
a10 1
$VERSION = 2006.1117;
d38 7
a46 1
	my $nll = $columns - length(expand($xp)) - 1;
d185 4
a188 3
Lines are wrapped at C<$Text::Wrap::columns> columns.  C<$Text::Wrap::columns>
should be set to the full width of your output device.  In fact,
every resulting line will have length of no more than C<$columns - 1>.  
d197 3
d214 2
a215 2
all newlines with C<$Text::Wrap::separator>.  If you just to preserve
existing newlines but add new breaks with something else, set 
d253 5
d260 2
a261 2
David Muir Sharnoff <muir@@idiom.com> with help from Tim Pierce and
many many others.  Copyright (C) 1996-2006 David Muir Sharnoff.  
d263 2
a264 2
your own risk.  Publicly redistributed modified versions must use 
a different name.
@


1.8
log
@merge in perl 5.8.8
@
text
@d3 1
d10 1
a10 1
$VERSION = 2005.0824_01;
d47 2
a48 2
	while ($t !~ /\G\s*\Z/gc) {
		if ($t =~ /\G([^\n]{0,$ll})($break|\n*\z)/xmgc) {
d58 1
a58 1
		} elsif ($huge eq 'overflow' && $t =~ /\G([^\n]*?)($break|\z)/xmgc) {
d65 4
d125 1
a125 1
	use Text::Wrap
d147 2
a148 2

	use Text::Wrap
d156 1
a156 1
single paragraph at a time by breaking lines at word boundries.
d160 1
a160 1
be used: it is unlikley you would want to pass in a number.
d168 2
d218 22
a239 1
=head1 EXAMPLE
d241 1
a241 2
	print wrap("\t","","This is a bit of text that forms 
		a normal book-style paragraph");
d246 1
a246 1
many many others.  Copyright (C) 1996-2002 David Muir Sharnoff.  
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d9 1
a9 1
$VERSION = 2001.09292;
d12 1
a12 1
	$separator);
d23 1
d47 1
a47 1
		if ($t =~ /\G([^\n]{0,$ll})($break|\z)/xmgc) {
d56 1
a56 1
			$remainder = $separator;
d70 5
a74 1
		$nl = $separator;
d159 1
a159 1
will destory any whitespace in the original text.  It breaks text into
d191 1
a191 1
C<$Text::Wrap::unexapand> to a false value.  Likewise if you do not
d196 4
a199 1
then set C<$Text::Wrap::seporator> to your preference.
d216 1
a216 1
=head1 AUTHOR
d219 4
a222 1
many many others.  
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d9 1
a9 1
$VERSION = 2001.09291;
d123 1
a123 1
	@@lines = wrap($initial_tab, $subsequent_tab, @@text);
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d9 1
a9 1
$VERSION = 2001.0929;
d37 1
d148 1
a148 1
all subsquent lines (C<$subsequent_tab>) independently.  Please note: 
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d9 1
a9 1
$VERSION = 2001.0131;
d11 2
a12 1
use vars qw($VERSION $columns $debug $break $huge);
d20 3
d31 1
d34 1
a34 1
	my $t = expand(join("", (map { /\s+\Z/ ? ( $_ ) : ($_, ' ') } @@t), $tail));
d41 2
d45 4
a48 2
		if ($t =~ /\G([^\n]{0,$ll})($break|\Z(?!\n))/xmgc) {
			$r .= unexpand($nl . $lead . $1);
d51 8
a58 4
			$r .= unexpand($nl . $lead . $1);
			$remainder = "\n";
		} elsif ($huge eq 'overflow' && $t =~ /\G([^\n]*?)($break|\Z(?!\n))/xmgc) {
			$r .= unexpand($nl . $lead . $1);
d68 1
a68 1
		$nl = "\n";
d136 1
a136 1
	
d144 1
a144 1
Text::Wrap::wrap() is a very simple paragraph formatter.  It formats a
d151 15
d170 8
d182 10
d199 1
a199 11
Text::Wrap::fill() is a simple multi-paragraph formatter.  It formats
each paragraph separately and then joins them together when it's done.  It
will destory any whitespace in the original text.  It breaks text into
paragraphs by looking for whitespace after a newline.  In other respects
it acts like wrap().

When called in list context, C<wrap()> will return a list of lines and 
C<fill()> will return a list of paragraphs.

Historical notes: Older versions of C<wrap()> and C<fill()> always 
returned strings.  Also, 'die' used to be the default value of
@


1.3
log
@perl5.005_03 (stock)
@
text
@d9 1
a9 1
$VERSION = 98.112902;
d18 1
a18 1
	$huge = 'wrap'; # alternatively: 'die'
d28 2
a29 1
	my $t = expand(join(" ",@@t));
d36 3
a38 2
	while ($t !~ /^\s*$/) {
		if ($t =~ s/^([^\n]{0,$ll})($break|\Z(?!\n))//xm) {
d41 1
a41 1
		} elsif ($huge eq 'wrap' && $t =~ s/^([^\n]{$ll})//) {
d44 3
d61 1
a61 1
	print "Finish up with '$lead', '$t'\n" if $debug;
d63 2
a64 1
	$r .= $lead . $t if $t ne "";
d67 1
d86 2
a87 1
	return join ($ip eq $xp ? "\n\n" : "\n", @@para);
d99 2
d103 3
d109 6
d117 1
a117 1
	$columns = 132;
d120 8
d132 20
a151 11
single paragraph at a time by breaking lines at word boundaries.
Indentation is controlled for the first line ($initial_tab) and
all subsequent lines ($subsequent_tab) independently.  

Lines are wrapped at $Text::Wrap::columns columns.  
$Text::Wrap::columns should be set to the full width of your output device.

When words that are longer than $columns are encountered, they
are broken up.  Previous versions of wrap() die()ed instead.
To restore the old (dying) behavior, set $Text::Wrap::huge to
'die'.
d155 1
a155 1
will destroy any whitespace in the original text.  It breaks text into
d158 7
@


1.2
log
@perl 5.004_04
@
text
@d5 3
a7 3
@@ISA = (Exporter);
@@EXPORT = qw(wrap);
@@EXPORT_OK = qw($columns);
d9 1
a9 1
$VERSION = 97.011701;
d11 1
a11 1
use vars qw($VERSION $columns $debug);
d17 2
d30 2
a31 1
	my $ll = $columns - length(expand($lead)) - 1;
d33 1
d35 13
a47 9
	# remove up to a line length of things that aren't
	# new lines and tabs.

	if ($t =~ s/^([^\n]{0,$ll})(\s|\Z(?!\n))//xm) {

		# accept it.
		$r .= unexpand($lead . $1);

		# recompute the leader
d49 4
a52 19
		$ll = $columns - length(expand($lead)) - 1;
		$nl = $2;

		# repeat the above until there's none left
		while ($t) {
			if ( $t =~ s/^([^\n]{0,$ll})(\s|\Z(?!\n))//xm ) {
				print "\$2 is '$2'\n" if $debug;
				$nl = $2;
				$r .= unexpand("\n" . $lead . $1);
			} elsif ($t =~ s/^([^\n]{$ll})//) {
				$nl = "\n";
				$r .= unexpand("\n" . $lead . $1);
			}
		}
		$r .= $nl;
	} 

	die "couldn't wrap '$t'" 
		if length($t) > $ll;
d64 18
d94 1
d96 1
a96 1
	use Text::Wrap qw(wrap $columns);
d99 2
d105 1
a105 1
single paragraph at a time by breaking lines at word boundries.
d107 1
a107 2
all subsquent lines ($subsequent_tab) independently.  $Text::Wrap::columns
should be set to the full width of your output device.
d109 2
a110 4
=head1 EXAMPLE

	print wrap("\t","","This is a bit of text that forms 
		a normal book-style paragraph");
d112 4
a115 18
=head1 BUGS

It's not clear what the correct behavior should be when Wrap() is
presented with a word that is longer than a line.  The previous 
behavior was to die.  Now the word is split at line-length.

=head1 AUTHOR

David Muir Sharnoff <muir@@idiom.com> with help from Tim Pierce and
others.

=cut

Latest change by Andreas Koenig <k@@anna.in-berlin.de> - 1/17/97

	print fill($initial_tab, $subsequent_tab, @@text);

	print fill("", "", `cat book`);
d119 1
a119 1
will destory any whitespace in the original text.  It breaks text into
d123 1
a123 1
# Tim Pierce did a faster version of this:
d125 2
a126 5
sub fill 
{
	my ($ip, $xp, @@raw) = @@_;
	my @@para;
	my $pp;
d128 1
a128 5
	for $pp (split(/\n\s+/, join("\n",@@raw))) {
		$pp =~ s/\s+/ /g;
		my $x = wrap($ip, $xp, $pp);
		push(@@para, $x);
	}
d130 2
a131 5
	# if paragraph_indent is the same as line_indent, 
	# separate paragraphs with blank lines

	return join ($ip eq $xp ? "\n\n" : "\n", @@para);
}
@


1.1
log
@Initial revision
@
text
@a0 1

a2 54
#
# This is a very simple paragraph formatter.  It formats one 
# paragraph at a time by wrapping and indenting text.
#
# Usage:
#
#	use Text::Wrap;
#
#	print wrap($initial_tab,$subsequent_tab,@@text);
#
# You can also set the number of columns to wrap before:
#
#	$Text::Wrap::columns = 135; # <= width of screen
#
#	use Text::Wrap qw(wrap $columns); 
#	$columns = 70;
#	
#
# The first line will be printed with $initial_tab prepended.  All
# following lines will have $subsequent_tab prepended.
#
# Example:
#
#	print wrap("\t","","This is a bit of text that ...");
#
# David Muir Sharnoff <muir@@idiom.com>
# Version: 9/21/95
#

=head1 NAME

Text::Wrap -- wrap text into a paragraph

=head1 SYNOPSIS

	use Text::Wrap;
	
	$Text::Wrap::columns = 20; # Default
	print wrap("\t","",Hello, world, it's a nice day, isn't it?");

=head1 DESCRIPTION

This module is a simple paragraph formatter that wraps text into a paragraph
and indents each line. The single exported function, wrap(), takes three
arguments. The first is included before the first output line, and the
second argument is included before each subsequest output line. The third
argument is the text to be wrapped.

=head1 AUTHOR

David Muir Sharnoff <muir@@idiom.com>

=cut

d9 5
d15 2
a16 1
	$Text::Wrap::columns = 76;  # <= screen width
d19 1
a19 2
use Text::Tabs;
use strict;
d25 1
a25 1
	my $r;
d28 12
a39 3
	my $ll = $Text::Wrap::columns - length(expand($lead)) - 1;
	if ($t =~ s/^([^\n]{0,$ll})\s//) {
		$r .= unexpand($lead . $1 . "\n");
d41 13
a53 3
		my $ll = $Text::Wrap::columns - length(expand($lead)) - 1;
		while ($t =~ s/^([^\n]{0,$ll})\s//) {
			$r .= unexpand($lead . $1 . "\n");
d55 1
d57 1
d60 8
a67 1
	$r .= $t;
d72 74
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d1 1
d4 51
a54 1
require Exporter;
d56 1
a56 3
@@ISA = qw(Exporter);
@@EXPORT = qw(wrap fill);
@@EXPORT_OK = qw($columns $break $huge);
d58 1
a58 1
$VERSION = 98.112902;
d60 3
a62 2
use vars qw($VERSION $columns $debug $break $huge);
use strict;
d65 1
a65 4
	$columns = 76;  # <= screen width
	$debug = 0;
	$break = '\s';
	$huge = 'wrap'; # alternatively: 'die'
d68 2
a69 1
use Text::Tabs qw(expand unexpand);
d75 1
a75 1
	my $r = "";
d78 7
a84 16
	my $ll = $columns - length(expand($ip)) - 1;
	my $nll = $columns - length(expand($xp)) - 1;
	my $nl = "";
	my $remainder = "";

	while ($t !~ /^\s*$/) {
		if ($t =~ s/^([^\n]{0,$ll})($break|\Z(?!\n))//xm) {
			$r .= unexpand($nl . $lead . $1);
			$remainder = $2;
		} elsif ($huge eq 'wrap' && $t =~ s/^([^\n]{$ll})//) {
			$r .= unexpand($nl . $lead . $1);
			$remainder = "\n";
		} elsif ($huge eq 'die') {
			die "couldn't wrap '$t'";
		} else {
			die "This shouldn't happen";
d86 4
a89 14
			
		$lead = $xp;
		$ll = $nll;
		$nl = "\n";
	}
	$r .= $remainder;

	print "-----------$r---------\n" if $debug;

	print "Finish up with '$lead', '$t'\n" if $debug;

	$r .= $lead . $t if $t ne "";

	print "-----------$r---------\n" if $debug;;
a92 18
sub fill 
{
	my ($ip, $xp, @@raw) = @@_;
	my @@para;
	my $pp;

	for $pp (split(/\n\s+/, join("\n",@@raw))) {
		$pp =~ s/\s+/ /g;
		my $x = wrap($ip, $xp, $pp);
		push(@@para, $x);
	}

	# if paragraph_indent is the same as line_indent, 
	# separate paragraphs with blank lines

	return join ($ip eq $xp ? "\n\n" : "\n", @@para);
}

a93 50
__END__

=head1 NAME

Text::Wrap - line wrapping to form simple paragraphs

=head1 SYNOPSIS 

	use Text::Wrap

	print wrap($initial_tab, $subsequent_tab, @@text);
	print fill($initial_tab, $subsequent_tab, @@text);

	use Text::Wrap qw(wrap $columns $huge);

	$columns = 132;
	$huge = 'die';
	$huge = 'wrap';

=head1 DESCRIPTION

Text::Wrap::wrap() is a very simple paragraph formatter.  It formats a
single paragraph at a time by breaking lines at word boundaries.
Indentation is controlled for the first line ($initial_tab) and
all subsequent lines ($subsequent_tab) independently.  

Lines are wrapped at $Text::Wrap::columns columns.  
$Text::Wrap::columns should be set to the full width of your output device.

When words that are longer than $columns are encountered, they
are broken up.  Previous versions of wrap() die()ed instead.
To restore the old (dying) behavior, set $Text::Wrap::huge to
'die'.

Text::Wrap::fill() is a simple multi-paragraph formatter.  It formats
each paragraph separately and then joins them together when it's done.  It
will destroy any whitespace in the original text.  It breaks text into
paragraphs by looking for whitespace after a newline.  In other respects
it acts like wrap().

=head1 EXAMPLE

	print wrap("\t","","This is a bit of text that forms 
		a normal book-style paragraph");

=head1 AUTHOR

David Muir Sharnoff <muir@@idiom.com> with help from Tim Pierce and
many many others.  

@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d9 1
a9 1
$VERSION = 2001.0131;
d18 1
a18 1
	$huge = 'wrap'; # alternatively: 'die' or 'overflow'
d28 1
a28 2
	my $tail = pop(@@t);
	my $t = expand(join("", (map { /\s+\Z/ ? ( $_ ) : ($_, ' ') } @@t), $tail));
d35 2
a36 3
	pos($t) = 0;
	while ($t !~ /\G\s*\Z/gc) {
		if ($t =~ /\G([^\n]{0,$ll})($break|\Z(?!\n))/xmgc) {
d39 1
a39 1
		} elsif ($huge eq 'wrap' && $t =~ /\G([^\n]{$ll})/gc) {
a41 3
		} elsif ($huge eq 'overflow' && $t =~ /\G([^\n]*?)($break|\Z(?!\n))/xmgc) {
			$r .= unexpand($nl . $lead . $1);
			$remainder = $2;
d56 1
a56 1
	print "Finish up with '$lead'\n" if $debug;
d58 1
a58 2
	$r .= $lead . substr($t, pos($t), length($t)-pos($t))
		if pos($t) ne length($t);
a60 1

d79 1
a79 2
	my $ps = ($ip eq $xp) ? "\n\n" : "\n";
	return join ($ps, @@para);
a90 2
B<Example 1>

a92 3
	$initial_tab = "\t";	# Tab before first line
	$subsequent_tab = "";	# All other lines flush left

a95 6
	@@lines = wrap($initial_tab, $subsequent_tab, @@text);

	@@paragraphs = fill($initial_tab, $subsequent_tab, @@text);

B<Example 2>

d98 1
a98 1
	$columns = 132;		# Wrap at 132 characters
a100 8
	$huge = 'overflow';

B<Example 3>
	
	use Text::Wrap

	$Text::Wrap::columns = 72;
	print wrap('', '', @@text);
d105 11
a115 20
single paragraph at a time by breaking lines at word boundries.
Indentation is controlled for the first line (C<$initial_tab>) and
all subsquent lines (C<$subsequent_tab>) independently.  Please note: 
C<$initial_tab> and C<$subsequent_tab> are the literal strings that will
be used: it is unlikley you would want to pass in a number.

Lines are wrapped at C<$Text::Wrap::columns> columns.  C<$Text::Wrap::columns>
should be set to the full width of your output device.  In fact,
every resulting line will have length of no more than C<$columns - 1>.  

Beginner note: In example 2, above C<$columns> is imported into
the local namespace, and set locally.  In example 3,
C<$Text::Wrap::columns> is set in its own namespace without importing it.

When words that are longer than C<$columns> are encountered, they
are broken up.  C<wrap()> adds a C<"\n"> at column C<$columns>.
This behavior can be overridden by setting C<$huge> to
'die' or to 'overflow'.  When set to 'die', large words will cause
C<die()> to be called.  When set to 'overflow', large words will be
left intact.  
d119 1
a119 1
will destory any whitespace in the original text.  It breaks text into
a121 7

When called in list context, C<wrap()> will return a list of lines and 
C<fill()> will return a list of paragraphs.

Historical notes: Older versions of C<wrap()> and C<fill()> always 
returned strings.  Also, 'die' used to be the default value of
C<$huge>.  Now, 'wrap' is the default value.
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d9 1
a9 1
$VERSION = 2001.0929;
d11 1
a11 2
use vars qw($VERSION $columns $debug $break $huge $unexpand $tabstop
	$separator);
a18 3
	$unexpand = 1;
	$tabstop = 8;
	$separator = "\n";
a26 1
	local($Text::Tabs::tabstop) = $tabstop;
d29 1
a29 1
	my $t = expand(join("", (map { /\s+\z/ ? ( $_ ) : ($_, ' ') } @@t), $tail));
a35 2
	use re 'taint';

d38 2
a39 4
		if ($t =~ /\G([^\n]{0,$ll})($break|\z)/xmgc) {
			$r .= $unexpand 
				? unexpand($nl . $lead . $1)
				: $nl . $lead . $1;
d42 4
a45 8
			$r .= $unexpand 
				? unexpand($nl . $lead . $1)
				: $nl . $lead . $1;
			$remainder = $separator;
		} elsif ($huge eq 'overflow' && $t =~ /\G([^\n]*?)($break|\z)/xmgc) {
			$r .= $unexpand 
				? unexpand($nl . $lead . $1)
				: $nl . $lead . $1;
d55 1
a55 1
		$nl = $separator;
d123 1
a123 1

d131 1
a131 1
C<Text::Wrap::wrap()> is a very simple paragraph formatter.  It formats a
a137 15
Text::Wrap::fill() is a simple multi-paragraph formatter.  It formats
each paragraph separately and then joins them together when it's done.  It
will destory any whitespace in the original text.  It breaks text into
paragraphs by looking for whitespace after a newline.  In other respects
it acts like wrap().

=head1 OVERRIDES

C<Text::Wrap::wrap()> has a number of variables that control its behavior.
Because other modules might be using C<Text::Wrap::wrap()> it is suggested
that you leave these variables alone!  If you can't do that, then 
use C<local($Text::Wrap::VARIABLE) = YOURVALUE> when you change the
values so that the original value is restored.  This C<local()> trick
will not work if you import the variable into your own namespace.

a141 8
It is possible to control which characters terminate words by
modifying C<$Text::Wrap::break>. Set this to a string such as
C<'[\s:]'> (to break before spaces or colons) or a pre-compiled regexp
such as C<qr/[\s']/> (to break before spaces or apostrophes). The
default is simply C<'\s'>; that is, words are terminated by spaces.
(This means, among other things, that trailing punctuation  such as
full stops or commas stay with the word they are "attached" to.)

a145 10
C<Text::Wrap::wrap()> starts its work by expanding all the tabs in its
input into spaces.  The last thing it does it to turn spaces back
into tabs.  If you do not want tabs in your results, set 
C<$Text::Wrap::unexapand> to a false value.  Likewise if you do not
want to use 8-character tabstops, set C<$Text::Wrap::tabstop> to
the number of characters you do want for your tabstops.

If you want to separate your lines with something other than C<\n>
then set C<$Text::Wrap::seporator> to your preference.

d153 11
a163 1
Historical notes: 'die' used to be the default value of
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d9 1
a9 1
$VERSION = 2001.09291;
a36 1
	$ll = 0 if $ll < 0;
d147 1
a147 1
all subsequent lines (C<$subsequent_tab>) independently.  Please note: 
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d9 1
a9 1
$VERSION = 2001.09292;
d123 1
a123 1
	$lines = wrap($initial_tab, $subsequent_tab, @@text);
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d9 1
a9 1
$VERSION = 2005.0824_01;
d12 1
a12 1
	$separator $separator2);
a22 1
	$separator2 = undef;
d46 1
a46 1
		if ($t =~ /\G([^\n]{0,$ll})($break|\n*\z)/xmgc) {
d55 1
a55 1
			$remainder = defined($separator2) ? $separator2 : $separator;
d69 1
a69 5
		$nl = defined($separator2)
			? ($remainder eq "\n"
				? "\n"
				: $separator2)
			: $separator;
d154 1
a154 1
will destroy any whitespace in the original text.  It breaks text into
d186 1
a186 1
C<$Text::Wrap::unexpand> to a false value.  Likewise if you do not
d191 1
a191 4
then set C<$Text::Wrap::separator> to your preference.  This replaces
all newlines with C<$Text::Wrap::separator>.  If you just to preserve
existing newlines but add new breaks with something else, set 
C<$Text::Wrap::separator2> instead.
d208 1
a208 1
=head1 LICENSE
d211 1
a211 4
many many others.  Copyright (C) 1996-2002 David Muir Sharnoff.  
This module may be modified, used, copied, and redistributed at
your own risk.  Publicly redistributed modified versions must use 
a different name.
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@a2 1
use warnings::register;
d9 1
a9 1
$VERSION = 2006.1117;
d46 2
a47 2
	while ($t !~ /\G(?:$break)*\Z/gc) {
		if ($t =~ /\G([^\n]{0,$ll})($break|\n+|\z)/xmgc) {
d57 1
a57 1
		} elsif ($huge eq 'overflow' && $t =~ /\G([^\n]*?)($break|\n+|\z)/xmgc) {
a63 4
		} elsif ($columns < 2) {
			warnings::warnif "Increasing \$Text::Wrap::columns from $columns to 2";
			$columns = 2;
			return ($ip, $xp, @@t);
d120 1
a120 1
	use Text::Wrap;
d142 2
a143 2
	
	use Text::Wrap;
d151 1
a151 1
single paragraph at a time by breaking lines at word boundaries.
d155 1
a155 1
be used: it is unlikely you would want to pass in a number.
a162 2
Both C<wrap()> and C<fill()> return a single string.

d211 1
a211 22
=head1 EXAMPLES

Code:

  print wrap("\t","",<<END);
  This is a bit of text that forms 
  a normal book-style indented paragraph
  END

Result:

  "	This is a bit of text that forms
  a normal book-style indented paragraph   
  "

Code:

  $Text::Wrap::columns=20;
  $Text::Wrap::separator="|";
  print wrap("","","This is a bit of text that forms a normal book-style paragraph");

Result:
d213 2
a214 1
  "This is a bit of|text that forms a|normal book-style|paragraph"
d219 1
a219 1
many many others.  Copyright (C) 1996-2006 David Muir Sharnoff.  
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d10 1
a10 1
$VERSION = 2009.0305;
a37 7
	my $nll = $columns - length(expand($xp)) - 1;
	if ($nll <= 0 && $xp ne '') {
		my $nc = length(expand($xp)) + 2;
		warnings::warnif "Increasing \$Text::Wrap::columns from $columns to $nc to accommodate length of subsequent tab";
		$columns = $nc;
		$nll = 1;
	}
d40 1
d179 3
a181 4
Lines are wrapped at C<$Text::Wrap::columns> columns (default value: 76).
C<$Text::Wrap::columns> should be set to the full width of your output
device.  In fact, every resulting line will have length of no more than
C<$columns - 1>.
a189 3
Setting C<$Text::Wrap::break> to a regular expression that doesn't
eat any characters (perhaps just a forward look-ahead assertion) will
cause warnings.
d204 2
a205 2
all newlines with C<$Text::Wrap::separator>.  If you just want to 
preserve existing newlines but add new breaks with something else, set
a242 5
=head1 SEE ALSO

For wrapping multi-byte characters: L<Text::WrapI18N>.
For more detailed controls: L<Text::Format>.

d245 2
a246 2
David Muir Sharnoff <muir@@idiom.org> with help from Tim Pierce and
many many others.  Copyright (C) 1996-2009 David Muir Sharnoff.  
d248 2
a249 2
your own risk.  Publicly redistributed versions that are modified 
must use a different name.
@


