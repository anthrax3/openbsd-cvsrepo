head	1.9;
access;
symbols
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2010.09.24.14.59.52;	author millert;	state dead;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.44;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.14;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.08;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.06;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.51;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.19;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.38;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.49.00;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.44;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.55;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@
package Text::Tabs;

require Exporter;

@@ISA = (Exporter);
@@EXPORT = qw(expand unexpand $tabstop);

use vars qw($VERSION $tabstop $debug);
$VERSION = 2009.0305;

use strict;

BEGIN	{
	$tabstop = 8;
	$debug = 0;
}

sub expand {
	my @@l;
	my $pad;
	for ( @@_ ) {
		my $s = '';
		for (split(/^/m, $_, -1)) {
			my $offs = 0;
			s{\t}{
				$pad = $tabstop - (pos() + $offs) % $tabstop;
				$offs += $pad - 1;
				" " x $pad;
			}eg;
			$s .= $_;
		}
		push(@@l, $s);
	}
	return @@l if wantarray;
	return $l[0];
}

sub unexpand
{
	my (@@l) = @@_;
	my @@e;
	my $x;
	my $line;
	my @@lines;
	my $lastbit;
	my $ts_as_space = " "x$tabstop;
	for $x (@@l) {
		@@lines = split("\n", $x, -1);
		for $line (@@lines) {
			$line = expand($line);
			@@e = split(/(.{$tabstop})/,$line,-1);
			$lastbit = pop(@@e);
			$lastbit = '' 
				unless defined $lastbit;
			$lastbit = "\t"
				if $lastbit eq $ts_as_space;
			for $_ (@@e) {
				if ($debug) {
					my $x = $_;
					$x =~ s/\t/^I\t/gs;
					print "sub on '$x'\n";
				}
				s/  +$/\t/;
			}
			$line = join('',@@e, $lastbit);
		}
		$x = join("\n", @@lines);
	}
	return @@l if wantarray;
	return $l[0];
}

1;
__END__

sub expand
{
	my (@@l) = @@_;
	for $_ (@@l) {
		1 while s/(^|\n)([^\t\n]*)(\t+)/
			$1. $2 . (" " x 
				($tabstop * length($3)
				- (length($2) % $tabstop)))
			/sex;
	}
	return @@l if wantarray;
	return $l[0];
}


=head1 NAME

Text::Tabs -- expand and unexpand tabs per the unix expand(1) and unexpand(1)

=head1 SYNOPSIS

  use Text::Tabs;

  $tabstop = 4;  # default = 8
  @@lines_without_tabs = expand(@@lines_with_tabs);
  @@lines_with_tabs = unexpand(@@lines_without_tabs);

=head1 DESCRIPTION

Text::Tabs does about what the unix utilities expand(1) and unexpand(1) 
do.  Given a line with tabs in it, expand will replace the tabs with
the appropriate number of spaces.  Given a line with or without tabs in
it, unexpand will add tabs when it can save bytes by doing so (just
like C<unexpand -a>).  Invisible compression with plain ASCII! 

=head1 EXAMPLE

  #!perl
  # unexpand -a
  use Text::Tabs;

  while (<>) {
    print unexpand $_;
  }

Instead of the C<expand> comand, use:

  perl -MText::Tabs -n -e 'print expand $_'

Instead of the C<unexpand -a> command, use:

  perl -MText::Tabs -n -e 'print unexpand $_'

=head1 LICENSE

Copyright (C) 1996-2002,2005,2006 David Muir Sharnoff.  
Copyright (C) 2005 Aristotle Pagaltzis 
This module may be modified, used, copied, and redistributed at your own risk.
Publicly redistributed modified versions must use a different name.

@


1.8
log
@Merge in perl 5.10.1
@
text
@@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d10 1
a10 1
$VERSION = 2007.1117;
@


1.6
log
@merge in perl 5.8.8
@
text
@d10 1
a10 1
$VERSION = 2005.0824;
d47 1
d54 2
a55 1
			$lastbit = '' unless defined $lastbit;
d57 1
a57 1
				if $lastbit eq " "x$tabstop;
d100 1
a100 1
  $tabstop = 4;
d106 1
a106 1
Text::Tabs does about what the unix utilities expand(1) and unexpand(1)
d109 2
a110 2
it, unexpand will add tabs when it can save bytes by doing so.  Invisible
compression with plain ascii!
d112 1
a112 1
=head1 BUGS
d114 15
a128 2
expand doesn't handle newlines very quickly -- do not feed it an
entire document in one string.  Instead feed it an array of lines.
d132 1
a132 1
Copyright (C) 1996-2002,2005 David Muir Sharnoff.  
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d10 1
a10 1
$VERSION = 98.112801;
d19 15
a33 9
sub expand
{
	my (@@l) = @@_;
	for $_ (@@l) {
		1 while s/(^|\n)([^\t\n]*)(\t+)/
			$1. $2 . (" " x 
				($tabstop * length($3)
				- (length($2) % $tabstop)))
			/sex;
d75 14
d115 6
a120 1
=head1 AUTHOR
a121 1
David Muir Sharnoff <muir@@idiom.com>
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d76 1
a76 1
use Text::Tabs;
d78 3
a80 3
$tabstop = 4;
@@lines_without_tabs = expand(@@lines_with_tabs);
@@lines_with_tabs = unexpand(@@lines_without_tabs);
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d76 1
a76 1
    use Text::Tabs;
d78 3
a80 3
    $tabstop = 4;
    @@lines_without_tabs = expand(@@lines_with_tabs);
    @@lines_with_tabs = unexpand(@@lines_without_tabs);
@


1.2
log
@perl 5.004_04
@
text
@d10 1
a10 1
$VERSION = 96.121201;
d21 1
a21 1
	my @@l = @@_;
d35 1
a35 1
	my @@l = @@_;
d76 1
a76 1
use Text::Tabs;
d78 3
a80 3
$tabstop = 4;
@@lines_without_tabs = expand(@@lines_with_tabs);
@@lines_with_tabs = unexpand(@@lines_without_tabs);
@


1.1
log
@Initial revision
@
text
@a0 40
#
# expand and unexpand tabs as per the unix expand and 
# unexpand programs.
#
# expand and unexpand operate on arrays of lines.  Do not
# feed strings that contain newlines to them.
#
# David Muir Sharnoff <muir@@idiom.com>
# 
# Version: 9/21/95
#

=head1 NAME

Text::Tabs -- expand and unexpand tabs

=head1 SYNOPSIS

	use Text::Tabs;
	
	#$tabstop = 8; # Defaults
	print expand("Hello\tworld");
	print unexpand("Hello,        world");
	$tabstop = 4;
	print join("\n",expand(split(/\n/,
		"Hello\tworld,\nit's a nice day.\n"
		)));

=head1 DESCRIPTION

This module expands and unexpands tabs into spaces, as per the unix expand
and unexpand programs. Either function should be passed an array of strings
(newlines may I<not> be included, and should be used to split an incoming
string into separate elements.) which will be processed and returned.

=head1 AUTHOR

David Muir Sharnoff <muir@@idiom.com>

=cut
d9 9
a17 1
$tabstop = 8;
d23 5
a27 5
		1 while s/^([^\t]*)(\t+)/
			$1 . (" " x 
				($tabstop * length($2)
				- (length($1) % $tabstop)))
			/e;
d30 1
a30 1
	return @@l[0];
d35 1
a35 1
	my @@l = &expand(@@_);
d37 4
d42 17
a58 3
		@@e = split(/(.{$tabstop})/,$x);
		for $_ (@@e) {
			s/  +$/\t/;
d60 1
a60 1
		$x = join('',@@e);
d63 1
a63 1
	return @@l[0];
d67 31
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d1 40
d49 1
a49 9
use vars qw($VERSION $tabstop $debug);
$VERSION = 96.121201;

use strict;

BEGIN	{
	$tabstop = 8;
	$debug = 0;
}
d55 5
a59 5
		1 while s/(^|\n)([^\t\n]*)(\t+)/
			$1. $2 . (" " x 
				($tabstop * length($3)
				- (length($2) % $tabstop)))
			/sex;
d62 1
a62 1
	return $l[0];
d67 1
a67 1
	my @@l = @@_;
a68 4
	my $x;
	my $line;
	my @@lines;
	my $lastbit;
d70 3
a72 17
		@@lines = split("\n", $x, -1);
		for $line (@@lines) {
			$line = expand($line);
			@@e = split(/(.{$tabstop})/,$line,-1);
			$lastbit = pop(@@e);
			$lastbit = '' unless defined $lastbit;
			$lastbit = "\t"
				if $lastbit eq " "x$tabstop;
			for $_ (@@e) {
				if ($debug) {
					my $x = $_;
					$x =~ s/\t/^I\t/gs;
					print "sub on '$x'\n";
				}
				s/  +$/\t/;
			}
			$line = join('',@@e, $lastbit);
d74 1
a74 1
		$x = join("\n", @@lines);
d77 1
a77 1
	return $l[0];
a80 31
__END__


=head1 NAME

Text::Tabs -- expand and unexpand tabs per the unix expand(1) and unexpand(1)

=head1 SYNOPSIS

use Text::Tabs;

$tabstop = 4;
@@lines_without_tabs = expand(@@lines_with_tabs);
@@lines_with_tabs = unexpand(@@lines_without_tabs);

=head1 DESCRIPTION

Text::Tabs does about what the unix utilities expand(1) and unexpand(1)
do.  Given a line with tabs in it, expand will replace the tabs with
the appropriate number of spaces.  Given a line with or without tabs in
it, unexpand will add tabs when it can save bytes by doing so.  Invisible
compression with plain ascii!

=head1 BUGS

expand doesn't handle newlines very quickly -- do not feed it an
entire document in one string.  Instead feed it an array of lines.

=head1 AUTHOR

David Muir Sharnoff <muir@@idiom.com>
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d10 1
a10 1
$VERSION = 98.112801;
d21 1
a21 1
	my (@@l) = @@_;
d35 1
a35 1
	my (@@l) = @@_;
d76 1
a76 1
    use Text::Tabs;
d78 3
a80 3
    $tabstop = 4;
    @@lines_without_tabs = expand(@@lines_with_tabs);
    @@lines_with_tabs = unexpand(@@lines_without_tabs);
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d76 1
a76 1
use Text::Tabs;
d78 3
a80 3
$tabstop = 4;
@@lines_without_tabs = expand(@@lines_with_tabs);
@@lines_with_tabs = unexpand(@@lines_without_tabs);
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d76 1
a76 1
  use Text::Tabs;
d78 3
a80 3
  $tabstop = 4;
  @@lines_without_tabs = expand(@@lines_with_tabs);
  @@lines_with_tabs = unexpand(@@lines_without_tabs);
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d10 1
a10 1
$VERSION = 2005.0824;
d19 9
a27 15
sub expand {
	my @@l;
	my $pad;
	for ( @@_ ) {
		my $s = '';
		for (split(/^/m, $_, -1)) {
			my $offs = 0;
			s{\t}{
				$pad = $tabstop - (pos() + $offs) % $tabstop;
				$offs += $pad - 1;
				" " x $pad;
			}eg;
			$s .= $_;
		}
		push(@@l, $s);
a68 14
sub expand
{
	my (@@l) = @@_;
	for $_ (@@l) {
		1 while s/(^|\n)([^\t\n]*)(\t+)/
			$1. $2 . (" " x 
				($tabstop * length($3)
				- (length($2) % $tabstop)))
			/sex;
	}
	return @@l if wantarray;
	return $l[0];
}

d95 1
a95 6
=head1 LICENSE

Copyright (C) 1996-2002,2005 David Muir Sharnoff.  
Copyright (C) 2005 Aristotle Pagaltzis 
This module may be modified, used, copied, and redistributed at your own risk.
Publicly redistributed modified versions must use a different name.
d97 1
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d10 1
a10 1
$VERSION = 2007.1117;
a46 1
	my $ts_as_space = " "x$tabstop;
d53 1
a53 2
			$lastbit = '' 
				unless defined $lastbit;
d55 1
a55 1
				if $lastbit eq $ts_as_space;
d98 1
a98 1
  $tabstop = 4;  # default = 8
d104 1
a104 1
Text::Tabs does about what the unix utilities expand(1) and unexpand(1) 
d107 2
a108 2
it, unexpand will add tabs when it can save bytes by doing so (just
like C<unexpand -a>).  Invisible compression with plain ASCII! 
d110 1
a110 1
=head1 EXAMPLE
d112 2
a113 15
  #!perl
  # unexpand -a
  use Text::Tabs;

  while (<>) {
    print unexpand $_;
  }

Instead of the C<expand> comand, use:

  perl -MText::Tabs -n -e 'print expand $_'

Instead of the C<unexpand -a> command, use:

  perl -MText::Tabs -n -e 'print unexpand $_'
d117 1
a117 1
Copyright (C) 1996-2002,2005,2006 David Muir Sharnoff.  
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d10 1
a10 1
$VERSION = 2009.0305;
@


