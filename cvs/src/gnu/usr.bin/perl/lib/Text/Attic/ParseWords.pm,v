head	1.12;
access;
symbols
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.9.0.10
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.8
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.9.0.6
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.4
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.9.0.2
	OPENBSD_4_0_BASE:1.9
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.6
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.4
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.12
date	2010.09.24.14.59.52;	author millert;	state dead;
branches;
next	1.11;

1.11
date	2009.10.12.18.24.44;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2008.09.29.17.36.14;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.28.19.23.08;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.15.21.30.34;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.09.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.38;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.54;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.52.00;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.58.04;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.51;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.51;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.18;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.50;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.38;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.08.09.17.47.24;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2005.01.15.21.17.31;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2006.03.28.18.49.00;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.44;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.56;	author millert;	state Exp;
branches;
next	;


desc
@@


1.12
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Text::ParseWords;

use strict;
require 5.006;
our $VERSION = "3.27";


use Exporter;
our @@ISA = qw(Exporter);
our @@EXPORT = qw(shellwords quotewords nested_quotewords parse_line);
our @@EXPORT_OK = qw(old_shellwords);
our $PERL_SINGLE_QUOTE;


sub shellwords {
    my (@@lines) = @@_;
    my @@allwords;

    foreach my $line (@@lines) {
	$line =~ s/^\s+//;
	my @@words = parse_line('\s+', 0, $line);
	pop @@words if (@@words and !defined $words[-1]);
	return() unless (@@words || !length($line));
	push(@@allwords, @@words);
    }
    return(@@allwords);
}



sub quotewords {
    my($delim, $keep, @@lines) = @@_;
    my($line, @@words, @@allwords);

    foreach $line (@@lines) {
	@@words = parse_line($delim, $keep, $line);
	return() unless (@@words || !length($line));
	push(@@allwords, @@words);
    }
    return(@@allwords);
}



sub nested_quotewords {
    my($delim, $keep, @@lines) = @@_;
    my($i, @@allwords);

    for ($i = 0; $i < @@lines; $i++) {
	@@{$allwords[$i]} = parse_line($delim, $keep, $lines[$i]);
	return() unless (@@{$allwords[$i]} || !length($lines[$i]));
    }
    return(@@allwords);
}



sub parse_line {
    my($delimiter, $keep, $line) = @@_;
    my($word, @@pieces);

    no warnings 'uninitialized';	# we will be testing undef strings

    while (length($line)) {
        # This pattern is optimised to be stack conservative on older perls.
        # Do not refactor without being careful and testing it on very long strings.
        # See Perl bug #42980 for an example of a stack busting input.
        $line =~ s/^
                    (?: 
                        # double quoted string
                        (")                             # $quote
                        ((?>[^\\"]*(?:\\.[^\\"]*)*))"   # $quoted 
		    |	# --OR--
                        # singe quoted string
                        (')                             # $quote
                        ((?>[^\\']*(?:\\.[^\\']*)*))'   # $quoted
                    |   # --OR--
                        # unquoted string
		        (                               # $unquoted 
                            (?:\\.|[^\\"'])*?           
                        )		
                        # followed by
		        (                               # $delim
                            \Z(?!\n)                    # EOL
                        |   # --OR--
                            (?-x:$delimiter)            # delimiter
                        |   # --OR--                    
                            (?!^)(?=["'])               # a quote
                        )  
		    )//xs or return;		# extended layout                  
        my ($quote, $quoted, $unquoted, $delim) = (($1 ? ($1,$2) : ($3,$4)), $5, $6);


	return() unless( defined($quote) || length($unquoted) || length($delim));

        if ($keep) {
	    $quoted = "$quote$quoted$quote";
	}
        else {
	    $unquoted =~ s/\\(.)/$1/sg;
	    if (defined $quote) {
		$quoted =~ s/\\(.)/$1/sg if ($quote eq '"');
		$quoted =~ s/\\([\\'])/$1/g if ( $PERL_SINGLE_QUOTE && $quote eq "'");
            }
	}
        $word .= substr($line, 0, 0);	# leave results tainted
        $word .= defined $quote ? $quoted : $unquoted;
 
        if (length($delim)) {
            push(@@pieces, $word);
            push(@@pieces, $delim) if ($keep eq 'delimiters');
            undef $word;
        }
        if (!length($line)) {
            push(@@pieces, $word);
	}
    }
    return(@@pieces);
}



sub old_shellwords {

    # Usage:
    #	use ParseWords;
    #	@@words = old_shellwords($line);
    #	or
    #	@@words = old_shellwords(@@lines);
    #	or
    #	@@words = old_shellwords();	# defaults to $_ (and clobbers it)

    no warnings 'uninitialized';	# we will be testing undef strings
    local *_ = \join('', @@_) if @@_;
    my (@@words, $snippet);

    s/\A\s+//;
    while ($_ ne '') {
	my $field = substr($_, 0, 0);	# leave results tainted
	for (;;) {
	    if (s/\A"(([^"\\]|\\.)*)"//s) {
		($snippet = $1) =~ s#\\(.)#$1#sg;
	    }
	    elsif (/\A"/) {
		require Carp;
		Carp::carp("Unmatched double quote: $_");
		return();
	    }
	    elsif (s/\A'(([^'\\]|\\.)*)'//s) {
		($snippet = $1) =~ s#\\(.)#$1#sg;
	    }
	    elsif (/\A'/) {
		require Carp;
		Carp::carp("Unmatched single quote: $_");
		return();
	    }
	    elsif (s/\A\\(.?)//s) {
		$snippet = $1;
	    }
	    elsif (s/\A([^\s\\'"]+)//) {
		$snippet = $1;
	    }
	    else {
		s/\A\s+//;
		last;
	    }
	    $field .= $snippet;
	}
	push(@@words, $field);
    }
    return @@words;
}

1;

__END__

=head1 NAME

Text::ParseWords - parse text into an array of tokens or array of arrays

=head1 SYNOPSIS

  use Text::ParseWords;
  @@lists = nested_quotewords($delim, $keep, @@lines);
  @@words = quotewords($delim, $keep, @@lines);
  @@words = shellwords(@@lines);
  @@words = parse_line($delim, $keep, $line);
  @@words = old_shellwords(@@lines); # DEPRECATED!

=head1 DESCRIPTION

The &nested_quotewords() and &quotewords() functions accept a delimiter 
(which can be a regular expression)
and a list of lines and then breaks those lines up into a list of
words ignoring delimiters that appear inside quotes.  &quotewords()
returns all of the tokens in a single long list, while &nested_quotewords()
returns a list of token lists corresponding to the elements of @@lines.
&parse_line() does tokenizing on a single string.  The &*quotewords()
functions simply call &parse_line(), so if you're only splitting
one line you can call &parse_line() directly and save a function
call.

The $keep argument is a boolean flag.  If true, then the tokens are
split on the specified delimiter, but all other characters (quotes,
backslashes, etc.) are kept in the tokens.  If $keep is false then the
&*quotewords() functions remove all quotes and backslashes that are
not themselves backslash-escaped or inside of single quotes (i.e.,
&quotewords() tries to interpret these characters just like the Bourne
shell).  NB: these semantics are significantly different from the
original version of this module shipped with Perl 5.000 through 5.004.
As an additional feature, $keep may be the keyword "delimiters" which
causes the functions to preserve the delimiters in each string as
tokens in the token lists, in addition to preserving quote and
backslash characters.

&shellwords() is written as a special case of &quotewords(), and it
does token parsing with whitespace as a delimiter-- similar to most
Unix shells.

=head1 EXAMPLES

The sample program:

  use Text::ParseWords;
  @@words = quotewords('\s+', 0, q{this   is "a test" of\ quotewords \"for you});
  $i = 0;
  foreach (@@words) {
      print "$i: <$_>\n";
      $i++;
  }

produces:

  0: <this>
  1: <is>
  2: <a test>
  3: <of quotewords>
  4: <"for>
  5: <you>

demonstrating:

=over 4

=item 0

a simple word

=item 1

multiple spaces are skipped because of our $delim

=item 2

use of quotes to include a space in a word

=item 3

use of a backslash to include a space in a word

=item 4

use of a backslash to remove the special meaning of a double-quote

=item 5

another simple word (note the lack of effect of the
backslashed double-quote)

=back

Replacing C<quotewords('\s+', 0, q{this   is...})>
with C<shellwords(q{this   is...})>
is a simpler way to accomplish the same thing.

=head1 AUTHORS

Maintainer: Alexandr Ciornii <alexchornyATgmail.com>.

Previous maintainer: Hal Pomeranz <pomeranz@@netcom.com>, 1994-1997 (Original
author unknown).  Much of the code for &parse_line() (including the
primary regexp) from Joerk Behrends <jbehrends@@multimediaproduzenten.de>.

Examples section another documentation provided by John Heidemann 
<johnh@@ISI.EDU>

Bug reports, patches, and nagging provided by lots of folks-- thanks
everybody!  Special thanks to Michael Schwern <schwern@@envirolink.org>
for assuring me that a &nested_quotewords() would be useful, and to 
Jeff Friedl <jfriedl@@yahoo-inc.com> for telling me not to worry about
error-checking (sort of-- you had to be there).

=cut
@


1.11
log
@Merge in perl 5.10.1
@
text
@@


1.10
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 3
a5 2
use vars qw($VERSION @@ISA @@EXPORT $PERL_SINGLE_QUOTE);
$VERSION = "3.26";
a6 1
require 5.000;
d9 4
a12 3
@@ISA = qw(Exporter);
@@EXPORT = qw(shellwords quotewords nested_quotewords parse_line);
@@EXPORT_OK = qw(old_shellwords);
d185 5
a189 5
  @@lists = &nested_quotewords($delim, $keep, @@lines);
  @@words = &quotewords($delim, $keep, @@lines);
  @@words = &shellwords(@@lines);
  @@words = &parse_line($delim, $keep, $line);
  @@words = &old_shellwords(@@lines); # DEPRECATED!
d226 1
a226 1
  @@words = &quotewords('\s+', 0, q{this   is "a test" of\ quotewords \"for you});
d273 2
a274 2
Replacing C<&quotewords('\s+', 0, q{this   is...})>
with C<&shellwords(q{this   is...})>
d279 3
a281 1
Maintainer is Hal Pomeranz <pomeranz@@netcom.com>, 1994-1997 (Original
@


1.9
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
$VERSION = "3.24";
d15 11
a25 3
    my(@@lines) = @@_;
    $lines[$#lines] =~ s/\s+$//;
    return(quotewords('\s+', 0, @@lines));
d64 29
a92 9
	$line =~ s/^(["'])			# a $quote
        	    ((?:\\.|(?!\1)[^\\])*)	# and $quoted text
		    \1				# followed by the same quote
		   |				# --OR--
		   ^((?:\\.|[^\\"'])*?)		# an $unquoted text
		    (\Z(?!\n)|(?-x:$delimiter)|(?!^)(?=["']))  
		    				# plus EOL, delimiter, or quote
		  //xs or return;		# extended layout
	my($quote, $quoted, $unquoted, $delim) = ($1, $2, $3, $4);
d156 1
a156 1
	    elsif (s/\A\\(.)//s) {
@


1.8
log
@sync in-tree perl with 5.8.6
@
text
@d4 1
a4 1
$VERSION = "3.23";
d15 1
a15 1
    local(@@lines) = @@_;
a24 1
    
d39 1
a39 1
    
a49 4
	# We will be testing undef strings
	no warnings;
	use re 'taint'; # if it's tainted, leave it as such

d53 2
d77 1
d101 2
d104 3
a106 2
    local($_) = join('', @@_);
    my(@@words,$snippet,$field);
d108 1
a108 1
    s/^\s+//;
d110 1
a110 1
	$field = '';
d112 2
a113 2
	    if (s/^"(([^"\\]|\\.)*)"//) {
		($snippet = $1) =~ s#\\(.)#$1#g;
d115 3
a117 1
	    elsif (/^"/) {
d120 2
a121 2
	    elsif (s/^'(([^'\\]|\\.)*)'//) {
		($snippet = $1) =~ s#\\(.)#$1#g;
d123 3
a125 1
	    elsif (/^'/) {
d128 1
a128 1
	    elsif (s/^\\(.)//) {
d131 1
a131 1
	    elsif (s/^([^\s\\'"]+)//) {
d135 1
a135 1
		s/^\s+//;
d142 1
a142 1
    @@words;
@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d4 1
a4 1
$VERSION = "3.22";
d56 1
a56 1
    my($quote, $quoted, $unquoted, $delim, $word, @@pieces);
d59 10
a68 15

	($quote, $quoted, undef, $unquoted, $delim, undef) =
	    $line =~ m/^(["'])                 # a $quote
                        ((?:\\[\000-\377]|(?!\1)[^\\])*)  # and $quoted text
                        \1 		       # followed by the same quote
                        ([\000-\377]*)	       # and the rest
		       |                       # --OR--
                       ^((?:\\[\000-\377]|[^\\"'])*?)     # an $unquoted text
		      (\Z(?!\n)|(?-x:$delimiter)|(?!^)(?=["']))  
                                               # plus EOL, delimiter, or quote
                      ([\000-\377]*)	       # the rest
		      /x;		       # extended layout
	return() unless( $quote || length($unquoted) || length($delim));

	$line = $+;
d74 1
a74 1
	    $unquoted =~ s/\\([\000-\377])/$1/g;
d76 1
a76 1
		$quoted =~ s/\\([\000-\377])/$1/g if ($quote eq '"');
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d4 1
a4 1
$VERSION = "3.21";
d62 1
a62 1
                        ((?:\\.|(?!\1)[^\\])*)    # and $quoted text
d66 1
a66 1
                       ^((?:\\.|[^\\"'])*?)    # an $unquoted text
d79 1
a79 1
	    $unquoted =~ s/\\(.)/$1/g;
d81 1
a81 1
		$quoted =~ s/\\(.)/$1/g if ($quote eq '"');
d171 2
a172 2
functions simply call &parse_lines(), so if you're only splitting
one line you can call &parse_lines() directly and save a function
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d4 1
a4 1
$VERSION = "3.2";
d53 1
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d217 1
d221 1
d225 1
d229 1
d233 1
d237 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d4 1
a4 1
$VERSION = "3.1";
d52 1
a52 1
	local($^W) = 0;
@


1.2
log
@perl 5.004_04
@
text
@d3 3
a6 4
use Carp;

require AutoLoader;
*AUTOLOAD = \&AutoLoader::AUTOLOAD;
d8 1
a8 1
require Exporter;
d10 1
a10 1
@@EXPORT = qw(shellwords quotewords);
a12 41
=head1 NAME

Text::ParseWords - parse text into an array of tokens

=head1 SYNOPSIS

  use Text::ParseWords;
  @@words = &quotewords($delim, $keep, @@lines);
  @@words = &shellwords(@@lines);
  @@words = &old_shellwords(@@lines);

=head1 DESCRIPTION

&quotewords() accepts a delimiter (which can be a regular expression)
and a list of lines and then breaks those lines up into a list of
words ignoring delimiters that appear inside quotes.

The $keep argument is a boolean flag.  If true, the quotes are kept
with each word, otherwise quotes are stripped in the splitting process.
$keep also defines whether unprotected backslashes are retained.

A &shellwords() replacement is included to demonstrate the new package.
This version differs from the original in that it will _NOT_ default
to using $_ if no arguments are given.  I personally find the old behavior
to be a mis-feature.

&quotewords() works by simply jamming all of @@lines into a single
string in $_ and then pulling off words a bit at a time until $_
is exhausted.

=head1 AUTHORS

Hal Pomeranz (pomeranz@@netcom.com), 23 March 1994

Basically an update and generalization of the old shellwords.pl.
Much code shamelessly stolen from the old version (author unknown).

=cut

1;
__END__
d17 1
a17 1
    &quotewords('\s+', 0, @@lines);
d23 11
a34 25
# The inner "for" loop builds up each word (or $field) one $snippet
# at a time.  A $snippet is a quoted string, a backslashed character,
# or an unquoted string.  We fall out of the "for" loop when we reach
# the end of $_ or when we hit a delimiter.  Falling out of the "for"
# loop, we push the $field we've been building up onto the list of
# @@words we'll be returning, and then loop back and pull another word
# off of $_.
#
# The first two cases inside the "for" loop deal with quoted strings.
# The first case matches a double quoted string, removes it from $_,
# and assigns the double quoted string to $snippet in the body of the
# conditional.  The second case handles single quoted strings.  In
# the third case we've found a quote at the current beginning of $_,
# but it didn't match the quoted string regexps in the first two cases,
# so it must be an unbalanced quote and we croak with an error (which can
# be caught by eval()).
#
# The next case handles backslashed characters, and the next case is the
# exit case on reaching the end of the string or finding a delimiter.
#
# Otherwise, we've found an unquoted thing and we pull of characters one
# at a time until we reach something that could start another $snippet--
# a quote of some sort, a backslash, or the delimiter.  This one character
# at a time behavior was necessary if the delimiter was going to be a
# regexp (love to hear it if you can figure out a better way).
a35 2
    my ($delim, $keep, @@lines) = @@_;
    my (@@words, $snippet, $field);
d37 11
a47 1
    local $_ = join ('', @@lines);
a48 2
    while (length) {
	$field = '';
d50 21
a70 2
	for (;;) {
	    $snippet = '';
d72 1
a72 24
	    if (s/^"([^"\\]*(\\.[^"\\]*)*)"//) {
		$snippet = $1;
		$snippet = qq|"$snippet"| if $keep;
	    }
	    elsif (s/^'([^'\\]*(\\.[^'\\]*)*)'//) {
		$snippet = $1;
		$snippet = "'$snippet'" if $keep;
	    }
	    elsif (/^["']/) {
		croak 'Unmatched quote';
	    }
	    elsif (s/^\\(.)//) {
		$snippet = $1;
		$snippet = "\\$snippet" if $keep;
	    }
	    elsif (!length || s/^$delim//) {
	       last;
	    }
	    else {
		while (length && !(/^$delim/ || /^['"\\]/)) {
		   $snippet .= substr ($_, 0, 1);
		   substr($_, 0, 1) = '';
		}
	    }
d74 19
a92 1
	    $field .= $snippet;
a93 2

	push @@words, $field;
d95 2
a97 2
    return @@words;
}
d119 1
a119 1
		croak "Unmatched double quote: $_";
d125 1
a125 1
		croak "Unmatched single quote: $_";
d143 114
@


1.1
log
@Initial revision
@
text
@d4 2
a5 1
require Exporter;
d7 1
a7 1
use Carp;
d9 2
a10 1
@@ISA = qw(Exporter AutoLoader);
a39 1

d92 4
a95 2
    local($delim, $keep, @@lines) = @@_;
    local(@@words,$snippet,$field,$_);
d97 1
a97 2
    $_ = join('', @@lines);
    while ($_) {
d99 1
d101 3
a103 2
            $snippet = '';
	    if (s/^"(([^"\\]|\\[\\"])*)"//) {
d105 1
a105 1
                $snippet = "\"$snippet\"" if ($keep);
d107 1
a107 1
	    elsif (s/^'(([^'\\]|\\[\\'])*)'//) {
d109 1
a109 1
                $snippet = "'$snippet'" if ($keep);
d112 5
a116 1
		croak "Unmatched quote";
d118 2
a119 6
            elsif (s/^\\(.)//) {
                $snippet = $1;
                $snippet = "\\$snippet" if ($keep);
            }
	    elsif (!$_ || s/^$delim//) {
               last;
d122 4
a125 4
                while ($_ && !(/^$delim/ || /^['"\\]/)) {
		   $snippet .=  substr($_, 0, 1);
                   substr($_, 0, 1) = '';
                }
d127 1
d130 2
a131 1
	push(@@words, $field);
d133 2
a134 1
    @@words;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a2 3
use vars qw($VERSION @@ISA @@EXPORT $PERL_SINGLE_QUOTE);
$VERSION = "3.1";

d4 3
d8 2
a9 3
use Exporter;
@@ISA = qw(Exporter);
@@EXPORT = qw(shellwords quotewords nested_quotewords parse_line);
d12 20
d33 9
a41 5
sub shellwords {
    local(@@lines) = @@_;
    $lines[$#lines] =~ s/\s+$//;
    return(quotewords('\s+', 0, @@lines));
}
d43 1
d45 1
d47 2
a48 12
sub quotewords {
    my($delim, $keep, @@lines) = @@_;
    my($line, @@words, @@allwords);
    

    foreach $line (@@lines) {
	@@words = parse_line($delim, $keep, $line);
	return() unless (@@words || !length($line));
	push(@@allwords, @@words);
    }
    return(@@allwords);
}
d50 1
d52 2
d55 4
a58 9
sub nested_quotewords {
    my($delim, $keep, @@lines) = @@_;
    my($i, @@allwords);
    
    for ($i = 0; $i < @@lines; $i++) {
	@@{$allwords[$i]} = parse_line($delim, $keep, $lines[$i]);
	return() unless (@@{$allwords[$i]} || !length($lines[$i]));
    }
    return(@@allwords);
d63 27
a89 21
sub parse_line {
	# We will be testing undef strings
	local($^W) = 0;

    my($delimiter, $keep, $line) = @@_;
    my($quote, $quoted, $unquoted, $delim, $word, @@pieces);

    while (length($line)) {

	($quote, $quoted, undef, $unquoted, $delim, undef) =
	    $line =~ m/^(["'])                 # a $quote
                        ((?:\\.|(?!\1)[^\\])*)    # and $quoted text
                        \1 		       # followed by the same quote
                        ([\000-\377]*)	       # and the rest
		       |                       # --OR--
                       ^((?:\\.|[^\\"'])*?)    # an $unquoted text
		      (\Z(?!\n)|(?-x:$delimiter)|(?!^)(?=["']))  
                                               # plus EOL, delimiter, or quote
                      ([\000-\377]*)	       # the rest
		      /x;		       # extended layout
	return() unless( $quote || length($unquoted) || length($delim));
d91 2
a92 1
	$line = $+;
d94 19
a112 8
        if ($keep) {
	    $quoted = "$quote$quoted$quote";
	}
        else {
	    $unquoted =~ s/\\(.)/$1/g;
	    if (defined $quote) {
		$quoted =~ s/\\(.)/$1/g if ($quote eq '"');
		$quoted =~ s/\\([\\'])/$1/g if ( $PERL_SINGLE_QUOTE && $quote eq "'");
d114 10
d125 1
a125 10
        $word .= defined $quote ? $quoted : $unquoted;
 
        if (length($delim)) {
            push(@@pieces, $word);
            push(@@pieces, $delim) if ($keep eq 'delimiters');
            undef $word;
        }
        if (!length($line)) {
            push(@@pieces, $word);
	}
d127 1
a127 1
    return(@@pieces);
a130 1

d150 1
a150 1
		return();
d156 1
a156 1
		return();
a173 114

1;

__END__

=head1 NAME

Text::ParseWords - parse text into an array of tokens or array of arrays

=head1 SYNOPSIS

  use Text::ParseWords;
  @@lists = &nested_quotewords($delim, $keep, @@lines);
  @@words = &quotewords($delim, $keep, @@lines);
  @@words = &shellwords(@@lines);
  @@words = &parse_line($delim, $keep, $line);
  @@words = &old_shellwords(@@lines); # DEPRECATED!

=head1 DESCRIPTION

The &nested_quotewords() and &quotewords() functions accept a delimiter 
(which can be a regular expression)
and a list of lines and then breaks those lines up into a list of
words ignoring delimiters that appear inside quotes.  &quotewords()
returns all of the tokens in a single long list, while &nested_quotewords()
returns a list of token lists corresponding to the elements of @@lines.
&parse_line() does tokenizing on a single string.  The &*quotewords()
functions simply call &parse_lines(), so if you're only splitting
one line you can call &parse_lines() directly and save a function
call.

The $keep argument is a boolean flag.  If true, then the tokens are
split on the specified delimiter, but all other characters (quotes,
backslashes, etc.) are kept in the tokens.  If $keep is false then the
&*quotewords() functions remove all quotes and backslashes that are
not themselves backslash-escaped or inside of single quotes (i.e.,
&quotewords() tries to interpret these characters just like the Bourne
shell).  NB: these semantics are significantly different from the
original version of this module shipped with Perl 5.000 through 5.004.
As an additional feature, $keep may be the keyword "delimiters" which
causes the functions to preserve the delimiters in each string as
tokens in the token lists, in addition to preserving quote and
backslash characters.

&shellwords() is written as a special case of &quotewords(), and it
does token parsing with whitespace as a delimiter-- similar to most
Unix shells.

=head1 EXAMPLES

The sample program:

  use Text::ParseWords;
  @@words = &quotewords('\s+', 0, q{this   is "a test" of\ quotewords \"for you});
  $i = 0;
  foreach (@@words) {
      print "$i: <$_>\n";
      $i++;
  }

produces:

  0: <this>
  1: <is>
  2: <a test>
  3: <of quotewords>
  4: <"for>
  5: <you>

demonstrating:

=over 4

=item 0
a simple word

=item 1
multiple spaces are skipped because of our $delim

=item 2
use of quotes to include a space in a word

=item 3
use of a backslash to include a space in a word

=item 4
use of a backslash to remove the special meaning of a double-quote

=item 5
another simple word (note the lack of effect of the
backslashed double-quote)

=back

Replacing C<&quotewords('\s+', 0, q{this   is...})>
with C<&shellwords(q{this   is...})>
is a simpler way to accomplish the same thing.

=head1 AUTHORS

Maintainer is Hal Pomeranz <pomeranz@@netcom.com>, 1994-1997 (Original
author unknown).  Much of the code for &parse_line() (including the
primary regexp) from Joerk Behrends <jbehrends@@multimediaproduzenten.de>.

Examples section another documentation provided by John Heidemann 
<johnh@@ISI.EDU>

Bug reports, patches, and nagging provided by lots of folks-- thanks
everybody!  Special thanks to Michael Schwern <schwern@@envirolink.org>
for assuring me that a &nested_quotewords() would be useful, and to 
Jeff Friedl <jfriedl@@yahoo-inc.com> for telling me not to worry about
error-checking (sort of-- you had to be there).

=cut
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d4 1
a4 1
$VERSION = "3.2";
d52 1
a52 1
	no warnings;
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a216 1

a219 1

a222 1

a225 1

a228 1

a231 1

@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d4 1
a4 1
$VERSION = "3.21";
a52 1
	use re 'taint'; # if it's tainted, leave it as such
@


1.1.1.6
log
@Import of stock perl 5.8.5
@
text
@d4 1
a4 1
$VERSION = "3.22";
d62 1
a62 1
                        ((?:\\[\000-\377]|(?!\1)[^\\])*)  # and $quoted text
d66 1
a66 1
                       ^((?:\\[\000-\377]|[^\\"'])*?)     # an $unquoted text
d79 1
a79 1
	    $unquoted =~ s/\\([\000-\377])/$1/g;
d81 1
a81 1
		$quoted =~ s/\\([\000-\377])/$1/g if ($quote eq '"');
d171 2
a172 2
functions simply call &parse_line(), so if you're only splitting
one line you can call &parse_line() directly and save a function
@


1.1.1.7
log
@perl 5.8.6 from CPAN
@
text
@d4 1
a4 1
$VERSION = "3.23";
d56 1
a56 1
    my($word, @@pieces);
d59 15
a73 10
	$line =~ s/^(["'])			# a $quote
        	    ((?:\\.|(?!\1)[^\\])*)	# and $quoted text
		    \1				# followed by the same quote
		   |				# --OR--
		   ^((?:\\.|[^\\"'])*?)		# an $unquoted text
		    (\Z(?!\n)|(?-x:$delimiter)|(?!^)(?=["']))  
		    				# plus EOL, delimiter, or quote
		  //xs or return;		# extended layout
	my($quote, $quoted, $unquoted, $delim) = ($1, $2, $3, $4);
	return() unless( defined($quote) || length($unquoted) || length($delim));
d79 1
a79 1
	    $unquoted =~ s/\\(.)/$1/sg;
d81 1
a81 1
		$quoted =~ s/\\(.)/$1/sg if ($quote eq '"');
@


1.1.1.8
log
@perl 5.8.8 import
@
text
@d4 1
a4 1
$VERSION = "3.24";
d15 1
a15 1
    my(@@lines) = @@_;
d25 1
d40 1
a40 1

d51 4
a57 2
    no warnings 'uninitialized';	# we will be testing undef strings

a79 1
        $word .= substr($line, 0, 0);	# leave results tainted
a102 2
    #	or
    #	@@words = old_shellwords();	# defaults to $_ (and clobbers it)
d104 2
a105 3
    no warnings 'uninitialized';	# we will be testing undef strings
    local *_ = \join('', @@_) if @@_;
    my (@@words, $snippet);
d107 1
a107 1
    s/\A\s+//;
d109 1
a109 1
	my $field = substr($_, 0, 0);	# leave results tainted
d111 2
a112 2
	    if (s/\A"(([^"\\]|\\.)*)"//s) {
		($snippet = $1) =~ s#\\(.)#$1#sg;
d114 1
a114 3
	    elsif (/\A"/) {
		require Carp;
		Carp::carp("Unmatched double quote: $_");
d117 2
a118 2
	    elsif (s/\A'(([^'\\]|\\.)*)'//s) {
		($snippet = $1) =~ s#\\(.)#$1#sg;
d120 1
a120 3
	    elsif (/\A'/) {
		require Carp;
		Carp::carp("Unmatched single quote: $_");
d123 1
a123 1
	    elsif (s/\A\\(.)//s) {
d126 1
a126 1
	    elsif (s/\A([^\s\\'"]+)//) {
d130 1
a130 1
		s/\A\s+//;
d137 1
a137 1
    return @@words;
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
$VERSION = "3.26";
d15 3
a17 11
    my (@@lines) = @@_;
    my @@allwords;

    foreach my $line (@@lines) {
	$line =~ s/^\s+//;
	my @@words = parse_line('\s+', 0, $line);
	pop @@words if (@@words and !defined $words[-1]);
	return() unless (@@words || !length($line));
	push(@@allwords, @@words);
    }
    return(@@allwords);
d56 9
a64 29
        # This pattern is optimised to be stack conservative on older perls.
        # Do not refactor without being careful and testing it on very long strings.
        # See Perl bug #42980 for an example of a stack busting input.
        $line =~ s/^
                    (?: 
                        # double quoted string
                        (")                             # $quote
                        ((?>[^\\"]*(?:\\.[^\\"]*)*))"   # $quoted 
		    |	# --OR--
                        # singe quoted string
                        (')                             # $quote
                        ((?>[^\\']*(?:\\.[^\\']*)*))'   # $quoted
                    |   # --OR--
                        # unquoted string
		        (                               # $unquoted 
                            (?:\\.|[^\\"'])*?           
                        )		
                        # followed by
		        (                               # $delim
                            \Z(?!\n)                    # EOL
                        |   # --OR--
                            (?-x:$delimiter)            # delimiter
                        |   # --OR--                    
                            (?!^)(?=["'])               # a quote
                        )  
		    )//xs or return;		# extended layout                  
        my ($quote, $quoted, $unquoted, $delim) = (($1 ? ($1,$2) : ($3,$4)), $5, $6);


d128 1
a128 1
	    elsif (s/\A\\(.?)//s) {
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d3 2
a4 3
use strict;
require 5.006;
our $VERSION = "3.27";
d6 1
d9 3
a11 4
our @@ISA = qw(Exporter);
our @@EXPORT = qw(shellwords quotewords nested_quotewords parse_line);
our @@EXPORT_OK = qw(old_shellwords);
our $PERL_SINGLE_QUOTE;
d184 5
a188 5
  @@lists = nested_quotewords($delim, $keep, @@lines);
  @@words = quotewords($delim, $keep, @@lines);
  @@words = shellwords(@@lines);
  @@words = parse_line($delim, $keep, $line);
  @@words = old_shellwords(@@lines); # DEPRECATED!
d225 1
a225 1
  @@words = quotewords('\s+', 0, q{this   is "a test" of\ quotewords \"for you});
d272 2
a273 2
Replacing C<quotewords('\s+', 0, q{this   is...})>
with C<shellwords(q{this   is...})>
d278 1
a278 3
Maintainer: Alexandr Ciornii <alexchornyATgmail.com>.

Previous maintainer: Hal Pomeranz <pomeranz@@netcom.com>, 1994-1997 (Original
@


