head	1.16;
access;
symbols
	OPENBSD_6_0:1.15.0.10
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.4
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.6
	OPENBSD_5_8_BASE:1.15
	PERL_5_20_2:1.1.1.14
	OPENBSD_5_7:1.15.0.2
	OPENBSD_5_7_BASE:1.15
	PERL_5_20_1:1.1.1.14
	OPENBSD_5_6:1.14.0.4
	OPENBSD_5_6_BASE:1.14
	PERL_5_18_2:1.1.1.13
	PERL:1.1.1
	OPENBSD_5_5:1.13.0.6
	OPENBSD_5_5_BASE:1.13
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	PERL_5_16_3:1.1.1.12
	OPENBSD_5_3:1.12.0.14
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.12
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.10
	OPENBSD_5_0:1.12.0.8
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	PERL_5_12_2:1.1.1.11
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.8
	PERL_5_8_3:1.1.1.7
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.16
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	cxJ08BvJA9Pt2PTM;

1.15
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	QP75iYx42Uo7mMxO;

1.14
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.25.20.40.55;	author sthen;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.37;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.04;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.09.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.35;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.21;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.05.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.41;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.56.37;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.29;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.29;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.39;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.33;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.14;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.57;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.04.07.21.13.12;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2004.08.09.17.46.37;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.31;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.28;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.49;	author millert;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2013.03.25.20.08.50;	author sthen;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	2014.11.17.20.53.07;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.16
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package Benchmark;

use strict;


=head1 NAME

Benchmark - benchmark running times of Perl code

=head1 SYNOPSIS

    use Benchmark qw(:all) ;

    timethis ($count, "code");

    # Use Perl code in strings...
    timethese($count, {
	'Name1' => '...code1...',
	'Name2' => '...code2...',
    });

    # ... or use subroutine references.
    timethese($count, {
	'Name1' => sub { ...code1... },
	'Name2' => sub { ...code2... },
    });

    # cmpthese can be used both ways as well
    cmpthese($count, {
	'Name1' => '...code1...',
	'Name2' => '...code2...',
    });

    cmpthese($count, {
	'Name1' => sub { ...code1... },
	'Name2' => sub { ...code2... },
    });

    # ...or in two stages
    $results = timethese($count,
        {
	    'Name1' => sub { ...code1... },
	    'Name2' => sub { ...code2... },
        },
	'none'
    );
    cmpthese( $results ) ;

    $t = timeit($count, '...other code...')
    print "$count loops of other code took:",timestr($t),"\n";

    $t = countit($time, '...other code...')
    $count = $t->iters ;
    print "$count loops of other code took:",timestr($t),"\n";

    # enable hires wallclock timing if possible
    use Benchmark ':hireswallclock';

=head1 DESCRIPTION

The Benchmark module encapsulates a number of routines to help you
figure out how long it takes to execute some code.

timethis - run a chunk of code several times

timethese - run several chunks of code several times

cmpthese - print results of timethese as a comparison chart

timeit - run a chunk of code and see how long it goes

countit - see how many times a chunk of code runs in a given time


=head2 Methods

=over 10

=item new

Returns the current time.   Example:

    use Benchmark;
    $t0 = Benchmark->new;
    # ... your code here ...
    $t1 = Benchmark->new;
    $td = timediff($t1, $t0);
    print "the code took:",timestr($td),"\n";

=item debug

Enables or disable debugging by setting the C<$Benchmark::Debug> flag:

    Benchmark->debug(1);
    $t = timeit(10, ' 5 ** $Global ');
    Benchmark->debug(0);

=item iters

Returns the number of iterations.

=back

=head2 Standard Exports

The following routines will be exported into your namespace
if you use the Benchmark module:

=over 10

=item timeit(COUNT, CODE)

Arguments: COUNT is the number of times to run the loop, and CODE is
the code to run.  CODE may be either a code reference or a string to
be eval'd; either way it will be run in the caller's package.

Returns: a Benchmark object.

=item timethis ( COUNT, CODE, [ TITLE, [ STYLE ]] )

Time COUNT iterations of CODE. CODE may be a string to eval or a
code reference; either way the CODE will run in the caller's package.
Results will be printed to STDOUT as TITLE followed by the times.
TITLE defaults to "timethis COUNT" if none is provided. STYLE
determines the format of the output, as described for timestr() below.

The COUNT can be zero or negative: this means the I<minimum number of
CPU seconds> to run.  A zero signifies the default of 3 seconds.  For
example to run at least for 10 seconds:

	timethis(-10, $code)

or to run two pieces of code tests for at least 3 seconds:

	timethese(0, { test1 => '...', test2 => '...'})

CPU seconds is, in UNIX terms, the user time plus the system time of
the process itself, as opposed to the real (wallclock) time and the
time spent by the child processes.  Less than 0.1 seconds is not
accepted (-0.01 as the count, for example, will cause a fatal runtime
exception).

Note that the CPU seconds is the B<minimum> time: CPU scheduling and
other operating system factors may complicate the attempt so that a
little bit more time is spent.  The benchmark output will, however,
also tell the number of C<$code> runs/second, which should be a more
interesting number than the actually spent seconds.

Returns a Benchmark object.

=item timethese ( COUNT, CODEHASHREF, [ STYLE ] )

The CODEHASHREF is a reference to a hash containing names as keys
and either a string to eval or a code reference for each value.
For each (KEY, VALUE) pair in the CODEHASHREF, this routine will
call

	timethis(COUNT, VALUE, KEY, STYLE)

The routines are called in string comparison order of KEY.

The COUNT can be zero or negative, see timethis().

Returns a hash reference of Benchmark objects, keyed by name.

=item timediff ( T1, T2 )

Returns the difference between two Benchmark times as a Benchmark
object suitable for passing to timestr().

=item timestr ( TIMEDIFF, [ STYLE, [ FORMAT ] ] )

Returns a string that formats the times in the TIMEDIFF object in
the requested STYLE. TIMEDIFF is expected to be a Benchmark object
similar to that returned by timediff().

STYLE can be any of 'all', 'none', 'noc', 'nop' or 'auto'. 'all' shows
each of the 5 times available ('wallclock' time, user time, system time,
user time of children, and system time of children). 'noc' shows all
except the two children times. 'nop' shows only wallclock and the
two children times. 'auto' (the default) will act as 'all' unless
the children times are both zero, in which case it acts as 'noc'.
'none' prevents output.

FORMAT is the L<printf(3)>-style format specifier (without the
leading '%') to use to print the times. It defaults to '5.2f'.

=back

=head2 Optional Exports

The following routines will be exported into your namespace
if you specifically ask that they be imported:

=over 10

=item clearcache ( COUNT )

Clear the cached time for COUNT rounds of the null loop.

=item clearallcache ( )

Clear all cached times.

=item cmpthese ( COUNT, CODEHASHREF, [ STYLE ] )

=item cmpthese ( RESULTSHASHREF, [ STYLE ] )

Optionally calls timethese(), then outputs comparison chart.  This:

    cmpthese( -1, { a => "++\$i", b => "\$i *= 2" } ) ;

outputs a chart like:

           Rate    b    a
    b 2831802/s   -- -61%
    a 7208959/s 155%   --

This chart is sorted from slowest to fastest, and shows the percent speed
difference between each pair of tests.

C<cmpthese> can also be passed the data structure that timethese() returns:

    $results = timethese( -1,
        { a => "++\$i", b => "\$i *= 2" } ) ;
    cmpthese( $results );

in case you want to see both sets of results.
If the first argument is an unblessed hash reference,
that is RESULTSHASHREF; otherwise that is COUNT.

Returns a reference to an ARRAY of rows, each row is an ARRAY of cells from the
above chart, including labels. This:

    my $rows = cmpthese( -1,
        { a => '++$i', b => '$i *= 2' }, "none" );

returns a data structure like:

    [
        [ '',       'Rate',   'b',    'a' ],
        [ 'b', '2885232/s',  '--', '-59%' ],
        [ 'a', '7099126/s', '146%',  '--' ],
    ]

B<NOTE>: This result value differs from previous versions, which returned
the C<timethese()> result structure.  If you want that, just use the two
statement C<timethese>...C<cmpthese> idiom shown above.

Incidentally, note the variance in the result values between the two examples;
this is typical of benchmarking.  If this were a real benchmark, you would
probably want to run a lot more iterations.

=item countit(TIME, CODE)

Arguments: TIME is the minimum length of time to run CODE for, and CODE is
the code to run.  CODE may be either a code reference or a string to
be eval'd; either way it will be run in the caller's package.

TIME is I<not> negative.  countit() will run the loop many times to
calculate the speed of CODE before running it for TIME.  The actual
time run for will usually be greater than TIME due to system clock
resolution, so it's best to look at the number of iterations divided
by the times that you are concerned with, not just the iterations.

Returns: a Benchmark object.

=item disablecache ( )

Disable caching of timings for the null loop. This will force Benchmark
to recalculate these timings for each new piece of code timed.

=item enablecache ( )

Enable caching of timings for the null loop. The time taken for COUNT
rounds of the null loop will be calculated only once for each
different COUNT used.

=item timesum ( T1, T2 )

Returns the sum of two Benchmark times as a Benchmark object suitable
for passing to timestr().

=back

=head2 :hireswallclock

If the Time::HiRes module has been installed, you can specify the
special tag C<:hireswallclock> for Benchmark (if Time::HiRes is not
available, the tag will be silently ignored).  This tag will cause the
wallclock time to be measured in microseconds, instead of integer
seconds.  Note though that the speed computations are still conducted
in CPU time, not wallclock time.

=head1 Benchmark Object

Many of the functions in this module return a Benchmark object,
or in the case of C<timethese()>, a reference to a hash, the values of
which are Benchmark objects.  This is useful if you want to store or
further process results from Benchmark functions.

Internally the Benchmark object holds timing values,
described in L</"NOTES"> below.
The following methods can be used to access them:

=over 4

=item cpu_p

Total CPU (User + System) of the main (parent) process.

=item cpu_c

Total CPU (User + System) of any children processes.

=item cpu_a

Total CPU of parent and any children processes.

=item real

Real elapsed time "wallclock seconds".

=item iters

Number of iterations run.

=back

The following illustrates use of the Benchmark object:

    $result = timethis(100000, sub { ... });
    print "total CPU = ", $result->cpu_a, "\n";

=head1 NOTES

The data is stored as a list of values from the time and times
functions:

      ($real, $user, $system, $children_user, $children_system, $iters)

in seconds for the whole loop (not divided by the number of rounds).

The timing is done using time(3) and times(3).

Code is executed in the caller's package.

The time of the null loop (a loop with the same
number of rounds but empty loop body) is subtracted
from the time of the real loop.

The null loop times can be cached, the key being the
number of rounds. The caching can be controlled using
calls like these:

    clearcache($key);
    clearallcache();

    disablecache();
    enablecache();

Caching is off by default, as it can (usually slightly) decrease
accuracy and does not usually noticeably affect runtimes.

=head1 EXAMPLES

For example,

    use Benchmark qw( cmpthese ) ;
    $x = 3;
    cmpthese( -5, {
        a => sub{$x*$x},
        b => sub{$x**2},
    } );

outputs something like this:

   Benchmark: running a, b, each for at least 5 CPU seconds...
          Rate    b    a
   b 1559428/s   -- -62%
   a 4152037/s 166%   --


while

    use Benchmark qw( timethese cmpthese ) ;
    $x = 3;
    $r = timethese( -5, {
        a => sub{$x*$x},
        b => sub{$x**2},
    } );
    cmpthese $r;

outputs something like this:

    Benchmark: running a, b, each for at least 5 CPU seconds...
             a: 10 wallclock secs ( 5.14 usr +  0.13 sys =  5.27 CPU) @@ 3835055.60/s (n=20210743)
             b:  5 wallclock secs ( 5.41 usr +  0.00 sys =  5.41 CPU) @@ 1574944.92/s (n=8520452)
           Rate    b    a
    b 1574945/s   -- -59%
    a 3835056/s 144%   --


=head1 INHERITANCE

Benchmark inherits from no other class, except of course
from Exporter.

=head1 CAVEATS

Comparing eval'd strings with code references will give you
inaccurate results: a code reference will show a slightly slower
execution time than the equivalent eval'd string.

The real time timing is done using time(2) and
the granularity is therefore only one second.

Short tests may produce negative figures because perl
can appear to take longer to execute the empty loop
than a short test; try:

    timethis(100,'1');

The system time of the null loop might be slightly
more than the system time of the loop with the actual
code and therefore the difference might end up being E<lt> 0.

=head1 SEE ALSO

L<Devel::NYTProf> - a Perl code profiler

=head1 AUTHORS

Jarkko Hietaniemi <F<jhi@@iki.fi>>, Tim Bunce <F<Tim.Bunce@@ig.co.uk>>

=head1 MODIFICATION HISTORY

September 8th, 1994; by Tim Bunce.

March 28th, 1997; by Hugo van der Sanden: added support for code
references and the already documented 'debug' method; revamped
documentation.

April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time
functionality.

September, 1999; by Barrie Slaymaker: math fixes and accuracy and
efficiency tweaks.  Added cmpthese().  A result is now returned from
timethese().  Exposed countit() (was runfor()).

December, 2001; by Nicholas Clark: make timestr() recognise the style 'none'
and return an empty string. If cmpthese is calling timethese, make it pass the
style in. (so that 'none' will suppress output). Make sub new dump its
debugging output to STDERR, to be consistent with everything else.
All bugs found while writing a regression test.

September, 2002; by Jarkko Hietaniemi: add ':hireswallclock' special tag.

February, 2004; by Chia-liang Kao: make cmpthese and timestr use time
statistics for children instead of parent when the style is 'nop'.

November, 2007; by Christophe Grosjean: make cmpthese and timestr compute
time consistently with style argument, default is 'all' not 'noc' any more.

=cut

# evaluate something in a clean lexical environment
sub _doeval { no strict;  eval shift }

#
# put any lexicals at file scope AFTER here
#

use Carp;
use Exporter;

our(@@ISA, @@EXPORT, @@EXPORT_OK, %EXPORT_TAGS, $VERSION);

@@ISA=qw(Exporter);
@@EXPORT=qw(timeit timethis timethese timediff timestr);
@@EXPORT_OK=qw(timesum cmpthese countit
	      clearcache clearallcache disablecache enablecache);
%EXPORT_TAGS=( all => [ @@EXPORT, @@EXPORT_OK ] ) ;

$VERSION = 1.22;

# --- ':hireswallclock' special handling

my $hirestime;

sub mytime () { time }

init();

sub BEGIN {
    if (eval 'require Time::HiRes') {
	import Time::HiRes qw(time);
	$hirestime = \&Time::HiRes::time;
    }
}

sub import {
    my $class = shift;
    if (grep { $_ eq ":hireswallclock" } @@_) {
	@@_ = grep { $_ ne ":hireswallclock" } @@_;
	local $^W=0;
	*mytime = $hirestime if defined $hirestime;
    }
    Benchmark->export_to_level(1, $class, @@_);
}

our($Debug, $Min_Count, $Min_CPU, $Default_Format, $Default_Style,
    %_Usage, %Cache, $Do_Cache);

sub init {
    $Debug = 0;
    $Min_Count = 4;
    $Min_CPU   = 0.4;
    $Default_Format = '5.2f';
    $Default_Style = 'auto';
    # The cache can cause a slight loss of sys time accuracy. If a
    # user does many tests (>10) with *very* large counts (>10000)
    # or works on a very slow machine the cache may be useful.
    disablecache();
    clearallcache();
}

sub debug { $Debug = ($_[1] != 0); }

sub usage {
    my $calling_sub = (caller(1))[3];
    $calling_sub =~ s/^Benchmark:://;
    return $_Usage{$calling_sub} || '';
}

# The cache needs two branches: 's' for strings and 'c' for code.  The
# empty loop is different in these two cases.

$_Usage{clearcache} = <<'USAGE';
usage: clearcache($count);
USAGE

sub clearcache    {
    die usage unless @@_ == 1;
    delete $Cache{"$_[0]c"}; delete $Cache{"$_[0]s"};
}

$_Usage{clearallcache} = <<'USAGE';
usage: clearallcache();
USAGE

sub clearallcache {
    die usage if @@_;
    %Cache = ();
}

$_Usage{enablecache} = <<'USAGE';
usage: enablecache();
USAGE

sub enablecache   {
    die usage if @@_;
    $Do_Cache = 1;
}

$_Usage{disablecache} = <<'USAGE';
usage: disablecache();
USAGE

sub disablecache  {
    die usage if @@_;
    $Do_Cache = 0;
}


# --- Functions to process the 'time' data type

sub new { my @@t = (mytime, times, @@_ == 2 ? $_[1] : 0);
	  print STDERR "new=@@t\n" if $Debug;
	  bless \@@t; }

sub cpu_p { my($r,$pu,$ps,$cu,$cs) = @@{$_[0]}; $pu+$ps         ; }
sub cpu_c { my($r,$pu,$ps,$cu,$cs) = @@{$_[0]};         $cu+$cs ; }
sub cpu_a { my($r,$pu,$ps,$cu,$cs) = @@{$_[0]}; $pu+$ps+$cu+$cs ; }
sub real  { my($r,$pu,$ps,$cu,$cs) = @@{$_[0]}; $r              ; }
sub iters { $_[0]->[5] ; }

# return the sum of various times: which ones depending on $style

sub elapsed {
    my ($self, $style) = @@_;
    $style = "" unless defined $style;

    return $self->cpu_c if $style eq 'nop';
    return $self->cpu_p if $style eq 'noc';
    return $self->cpu_a;
}


$_Usage{timediff} = <<'USAGE';
usage: $result_diff = timediff($result1, $result2);
USAGE

sub timediff {
    my($a, $b) = @@_;

    die usage unless ref $a and ref $b;

    my @@r;
    for (my $i=0; $i < @@$a; ++$i) {
	push(@@r, $a->[$i] - $b->[$i]);
    }
    #die "Bad timediff(): ($r[1] + $r[2]) <= 0 (@@$a[1,2]|@@$b[1,2])\n"
    #        if ($r[1] + $r[2]) < 0;
    bless \@@r;
}

$_Usage{timesum} = <<'USAGE';
usage: $sum = timesum($result1, $result2);
USAGE

sub timesum {
    my($a, $b) = @@_;

    die usage unless ref $a and ref $b;

    my @@r;
    for (my $i=0; $i < @@$a; ++$i) {
 	push(@@r, $a->[$i] + $b->[$i]);
    }
    bless \@@r;
}


$_Usage{timestr} = <<'USAGE';
usage: $formatted_result = timestr($result1);
USAGE

sub timestr {
    my($tr, $style, $f) = @@_;

    die usage unless ref $tr;

    my @@t = @@$tr;
    warn "bad time value (@@t)" unless @@t==6;
    my($r, $pu, $ps, $cu, $cs, $n) = @@t;
    my($pt, $ct, $tt) = ($tr->cpu_p, $tr->cpu_c, $tr->cpu_a);
    $f = $Default_Format unless defined $f;
    # format a time in the required style, other formats may be added here
    $style ||= $Default_Style;
    return '' if $style eq 'none';
    $style = ($ct>0) ? 'all' : 'noc' if $style eq 'auto';
    my $s = "@@t $style"; # default for unknown style
    my $w = $hirestime ? "%2g" : "%2d";
    $s = sprintf("$w wallclock secs (%$f usr %$f sys + %$f cusr %$f csys = %$f CPU)",
			    $r,$pu,$ps,$cu,$cs,$tt) if $style eq 'all';
    $s = sprintf("$w wallclock secs (%$f usr + %$f sys = %$f CPU)",
			    $r,$pu,$ps,$pt) if $style eq 'noc';
    $s = sprintf("$w wallclock secs (%$f cusr + %$f csys = %$f CPU)",
			    $r,$cu,$cs,$ct) if $style eq 'nop';
    my $elapsed = $tr->elapsed($style);
    $s .= sprintf(" @@ %$f/s (n=$n)",$n/($elapsed)) if $n && $elapsed;
    $s;
}

sub timedebug {
    my($msg, $t) = @@_;
    print STDERR "$msg",timestr($t),"\n" if $Debug;
}

# --- Functions implementing low-level support for timing loops

$_Usage{runloop} = <<'USAGE';
usage: runloop($number, [$string | $coderef])
USAGE

sub runloop {
    my($n, $c) = @@_;

    $n+=0; # force numeric now, so garbage won't creep into the eval
    croak "negative loopcount $n" if $n<0;
    confess usage unless defined $c;
    my($t0, $t1, $td); # before, after, difference

    # find package of caller so we can execute code there
    my($curpack) = caller(0);
    my($i, $pack)= 0;
    while (($pack) = caller(++$i)) {
	last if $pack ne $curpack;
    }

    my ($subcode, $subref);
    if (ref $c eq 'CODE') {
	$subcode = "sub { for (1 .. $n) { local \$_; package $pack; &\$c; } }";
        $subref  = eval $subcode;
    }
    else {
	$subcode = "sub { for (1 .. $n) { local \$_; package $pack; $c;} }";
        $subref  = _doeval($subcode);
    }
    croak "runloop unable to compile '$c': $@@\ncode: $subcode\n" if $@@;
    print STDERR "runloop $n '$subcode'\n" if $Debug;

    # Wait for the user timer to tick.  This makes the error range more like
    # -0.01, +0.  If we don't wait, then it's more like -0.01, +0.01.  This
    # may not seem important, but it significantly reduces the chances of
    # getting a too low initial $n in the initial, 'find the minimum' loop
    # in &countit.  This, in turn, can reduce the number of calls to
    # &runloop a lot, and thus reduce additive errors.
    #
    # Note that its possible for the act of reading the system clock to
    # burn lots of system CPU while we burn very little user clock in the
    # busy loop, which can cause the loop to run for a very long wall time.
    # So gradually ramp up the duration of the loop. See RT #122003
    #
    my $tbase = Benchmark->new(0)->[1];
    my $limit = 1;
    while ( ( $t0 = Benchmark->new(0) )->[1] == $tbase ) {
        for (my $i=0; $i < $limit; $i++) { my $x = $i / 1.5 } # burn user CPU
        $limit *= 1.1;
    }
    $subref->();
    $t1 = Benchmark->new($n);
    $td = &timediff($t1, $t0);
    timedebug("runloop:",$td);
    $td;
}

$_Usage{timeit} = <<'USAGE';
usage: $result = timeit($count, 'code' );        or
       $result = timeit($count, sub { code } );
USAGE

sub timeit {
    my($n, $code) = @@_;
    my($wn, $wc, $wd);

    die usage unless defined $code and
                     (!ref $code or ref $code eq 'CODE');

    printf STDERR "timeit $n $code\n" if $Debug;
    my $cache_key = $n . ( ref( $code ) ? 'c' : 's' );
    if ($Do_Cache && exists $Cache{$cache_key} ) {
	$wn = $Cache{$cache_key};
    } else {
	$wn = &runloop($n, ref( $code ) ? sub { } : '' );
	# Can't let our baseline have any iterations, or they get subtracted
	# out of the result.
	$wn->[5] = 0;
	$Cache{$cache_key} = $wn;
    }

    $wc = &runloop($n, $code);

    $wd = timediff($wc, $wn);
    timedebug("timeit: ",$wc);
    timedebug("      - ",$wn);
    timedebug("      = ",$wd);

    $wd;
}


my $default_for = 3;
my $min_for     = 0.1;


$_Usage{countit} = <<'USAGE';
usage: $result = countit($time, 'code' );        or
       $result = countit($time, sub { code } );
USAGE

sub countit {
    my ( $tmax, $code ) = @@_;

    die usage unless @@_;

    if ( not defined $tmax or $tmax == 0 ) {
	$tmax = $default_for;
    } elsif ( $tmax < 0 ) {
	$tmax = -$tmax;
    }

    die "countit($tmax, ...): timelimit cannot be less than $min_for.\n"
	if $tmax < $min_for;

    my ($n, $tc);

    # First find the minimum $n that gives a significant timing.
    my $zeros=0;
    for ($n = 1; ; $n *= 2 ) {
	my $t0 = Benchmark->new(0);
	my $td = timeit($n, $code);
	my $t1 = Benchmark->new(0);
	$tc = $td->[1] + $td->[2];
	if ( $tc <= 0 and $n > 1024 ) {
	    my $d = timediff($t1, $t0);
	    # note that $d is the total CPU time taken to call timeit(),
	    # while $tc is is difference in CPU secs between the empty run
	    # and the code run. If the code is trivial, its possible
	    # for $d to get large while $tc is still zero (or slightly
	    # negative). Bail out once timeit() starts taking more than a
	    # few seconds without noticeable difference.
	    if ($d->[1] + $d->[2] > 8
		|| ++$zeros > 16)
	    {
	        die "Timing is consistently zero in estimation loop, cannot benchmark. N=$n\n";
            }
	} else {
	    $zeros = 0;
	}
	last if $tc > 0.1;
    }

    my $nmin = $n;

    # Get $n high enough that we can guess the final $n with some accuracy.
    my $tpra = 0.1 * $tmax; # Target/time practice.
    while ( $tc < $tpra ) {
	# The 5% fudge is to keep us from iterating again all
	# that often (this speeds overall responsiveness when $tmax is big
	# and we guess a little low).  This does not noticeably affect
	# accuracy since we're not counting these times.
	$n = int( $tpra * 1.05 * $n / $tc ); # Linear approximation.
	my $td = timeit($n, $code);
	my $new_tc = $td->[1] + $td->[2];
        # Make sure we are making progress.
        $tc = $new_tc > 1.2 * $tc ? $new_tc : 1.2 * $tc;
    }

    # Now, do the 'for real' timing(s), repeating until we exceed
    # the max.
    my $ntot  = 0;
    my $rtot  = 0;
    my $utot  = 0.0;
    my $stot  = 0.0;
    my $cutot = 0.0;
    my $cstot = 0.0;
    my $ttot  = 0.0;

    # The 5% fudge is because $n is often a few % low even for routines
    # with stable times and avoiding extra timeit()s is nice for
    # accuracy's sake.
    $n = int( $n * ( 1.05 * $tmax / $tc ) );
    $zeros=0;
    while () {
	my $td = timeit($n, $code);
	$ntot  += $n;
	$rtot  += $td->[0];
	$utot  += $td->[1];
	$stot  += $td->[2];
	$cutot += $td->[3];
	$cstot += $td->[4];
	$ttot = $utot + $stot;
	last if $ttot >= $tmax;
	if ( $ttot <= 0 ) {
	    ++$zeros > 16
	        and die "Timing is consistently zero, cannot benchmark. N=$n\n";
	} else {
	    $zeros = 0;
	}
        $ttot = 0.01 if $ttot < 0.01;
	my $r = $tmax / $ttot - 1; # Linear approximation.
	$n = int( $r * $ntot );
	$n = $nmin if $n < $nmin;
    }

    return bless [ $rtot, $utot, $stot, $cutot, $cstot, $ntot ];
}

# --- Functions implementing high-level time-then-print utilities

sub n_to_for {
    my $n = shift;
    return $n == 0 ? $default_for : $n < 0 ? -$n : undef;
}

$_Usage{timethis} = <<'USAGE';
usage: $result = timethis($time, 'code' );        or
       $result = timethis($time, sub { code } );
USAGE

sub timethis{
    my($n, $code, $title, $style) = @@_;
    my($t, $forn);

    die usage unless defined $code and
                     (!ref $code or ref $code eq 'CODE');

    if ( $n > 0 ) {
	croak "non-integer loopcount $n, stopped" if int($n)<$n;
	$t = timeit($n, $code);
	$title = "timethis $n" unless defined $title;
    } else {
	my $fort  = n_to_for( $n );
	$t     = countit( $fort, $code );
	$title = "timethis for $fort" unless defined $title;
	$forn  = $t->[-1];
    }
    local $| = 1;
    $style = "" unless defined $style;
    printf("%10s: ", $title) unless $style eq 'none';
    print timestr($t, $style, $Default_Format),"\n" unless $style eq 'none';

    $n = $forn if defined $forn;

    if ($t->elapsed($style) < 0) {
        # due to clock granularity and variable CPU speed and load,
        # on quick code with a small number of loops, it's possible for
        # the empty loop to appear to take longer than the real loop
        # (e.g. 1 tick versus 0 ticks). This leads to a negative elapsed
        # time. In this case, floor it at zero, to stop bizarre results.
        print "            (warning: too few iterations for a reliable count)\n";
        $t->[$_] = 0 for 1..4;
    }

    # A conservative warning to spot very silly tests.
    # Don't assume that your benchmark is ok simply because
    # you don't get this warning!
    print "            (warning: too few iterations for a reliable count)\n"
	if     $n < $Min_Count
	    || ($t->real < 1 && $n < 1000)
	    || $t->cpu_a < $Min_CPU;
    $t;
}


$_Usage{timethese} = <<'USAGE';
usage: timethese($count, { Name1 => 'code1', ... });        or
       timethese($count, { Name1 => sub { code1 }, ... });
USAGE

sub timethese{
    my($n, $alt, $style) = @@_;
    die usage unless ref $alt eq 'HASH';

    my @@names = sort keys %$alt;
    $style = "" unless defined $style;
    print "Benchmark: " unless $style eq 'none';
    if ( $n > 0 ) {
	croak "non-integer loopcount $n, stopped" if int($n)<$n;
	print "timing $n iterations of" unless $style eq 'none';
    } else {
	print "running" unless $style eq 'none';
    }
    print " ", join(', ',@@names) unless $style eq 'none';
    unless ( $n > 0 ) {
	my $for = n_to_for( $n );
	print ", each" if $n > 1 && $style ne 'none';
	print " for at least $for CPU seconds" unless $style eq 'none';
    }
    print "...\n" unless $style eq 'none';

    # we could save the results in an array and produce a summary here
    # sum, min, max, avg etc etc
    my %results;
    foreach my $name (@@names) {
        $results{$name} = timethis ($n, $alt -> {$name}, $name, $style);
    }

    return \%results;
}


$_Usage{cmpthese} = <<'USAGE';
usage: cmpthese($count, { Name1 => 'code1', ... });        or
       cmpthese($count, { Name1 => sub { code1 }, ... });  or
       cmpthese($result, $style);
USAGE

sub cmpthese{
    my ($results, $style);

    # $count can be a blessed object.
    if ( ref $_[0] eq 'HASH' ) {
        ($results, $style) = @@_;
    }
    else {
        my($count, $code) = @@_[0,1];
        $style = $_[2] if defined $_[2];

        die usage unless ref $code eq 'HASH';

        $results = timethese($count, $code, ($style || "none"));
    }

    $style = "" unless defined $style;

    # Flatten in to an array of arrays with the name as the first field
    my @@vals = map{ [ $_, @@{$results->{$_}} ] } keys %$results;

    for (@@vals) {
        # recreate the pre-flattened Benchmark object
        my $tmp_bm = bless [ @@{$_}[1..$#$_] ];
	my $elapsed = $tmp_bm->elapsed($style);
	# The epsilon fudge here is to prevent div by 0.  Since clock
	# resolutions are much larger, it's below the noise floor.
	my $rate = $_->[6]/(($elapsed)+0.000000000000001);
	$_->[7] = $rate;
    }

    # Sort by rate
    @@vals = sort { $a->[7] <=> $b->[7] } @@vals;

    # If more than half of the rates are greater than one...
    my $display_as_rate = @@vals ? ($vals[$#vals>>1]->[7] > 1) : 0;

    my @@rows;
    my @@col_widths;

    my @@top_row = (
        '',
	$display_as_rate ? 'Rate' : 's/iter',
	map { $_->[0] } @@vals
    );

    push @@rows, \@@top_row;
    @@col_widths = map { length( $_ ) } @@top_row;

    # Build the data rows
    # We leave the last column in even though it never has any data.  Perhaps
    # it should go away.  Also, perhaps a style for a single column of
    # percentages might be nice.
    for my $row_val ( @@vals ) {
	my @@row;

        # Column 0 = test name
	push @@row, $row_val->[0];
	$col_widths[0] = length( $row_val->[0] )
	    if length( $row_val->[0] ) > $col_widths[0];

        # Column 1 = performance
	my $row_rate = $row_val->[7];

	# We assume that we'll never get a 0 rate.
	my $rate = $display_as_rate ? $row_rate : 1 / $row_rate;

	# Only give a few decimal places before switching to sci. notation,
	# since the results aren't usually that accurate anyway.
	my $format =
	   $rate >= 100 ?
	       "%0.0f" :
	   $rate >= 10 ?
	       "%0.1f" :
	   $rate >= 1 ?
	       "%0.2f" :
	   $rate >= 0.1 ?
	       "%0.3f" :
	       "%0.2e";

	$format .= "/s"
	    if $display_as_rate;

	my $formatted_rate = sprintf( $format, $rate );
	push @@row, $formatted_rate;
	$col_widths[1] = length( $formatted_rate )
	    if length( $formatted_rate ) > $col_widths[1];

        # Columns 2..N = performance ratios
	my $skip_rest = 0;
	for ( my $col_num = 0 ; $col_num < @@vals ; ++$col_num ) {
	    my $col_val = $vals[$col_num];
	    my $out;
	    if ( $skip_rest ) {
		$out = '';
	    }
	    elsif ( $col_val->[0] eq $row_val->[0] ) {
		$out = "--";
		# $skip_rest = 1;
	    }
	    else {
		my $col_rate = $col_val->[7];
		$out = sprintf( "%.0f%%", 100*$row_rate/$col_rate - 100 );
	    }
	    push @@row, $out;
	    $col_widths[$col_num+2] = length( $out )
		if length( $out ) > $col_widths[$col_num+2];

	    # A little weirdness to set the first column width properly
	    $col_widths[$col_num+2] = length( $col_val->[0] )
		if length( $col_val->[0] ) > $col_widths[$col_num+2];
	}
	push @@rows, \@@row;
    }

    return \@@rows if $style eq "none";

    # Equalize column widths in the chart as much as possible without
    # exceeding 80 characters.  This does not use or affect cols 0 or 1.
    my @@sorted_width_refs =
       sort { $$a <=> $$b } map { \$_ } @@col_widths[2..$#col_widths];
    my $max_width = ${$sorted_width_refs[-1]};

    my $total = @@col_widths - 1 ;
    for ( @@col_widths ) { $total += $_ }

    STRETCHER:
    while ( $total < 80 ) {
	my $min_width = ${$sorted_width_refs[0]};
	last
	   if $min_width == $max_width;
	for ( @@sorted_width_refs ) {
	    last
		if $$_ > $min_width;
	    ++$$_;
	    ++$total;
	    last STRETCHER
		if $total >= 80;
	}
    }

    # Dump the output
    my $format = join( ' ', map { "%${_}s" } @@col_widths ) . "\n";
    substr( $format, 1, 0 ) = '-';
    for ( @@rows ) {
	printf $format, @@$_;
    }

    return \@@rows ;
}


1;
@


1.15
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d407 1
a407 1
for Exporter.
d485 1
a485 1
$VERSION = 1.18;
d588 11
d661 1
a661 5
    my $elapsed = do {
	if ($style eq 'nop') {$cu+$cs}
	elsif ($style eq 'noc') {$pu+$ps}
	else {$cu+$cs+$pu+$ps}
    };
d710 6
d717 5
a721 1
    while ( ( $t0 = Benchmark->new(0) )->[1] == $tbase ) {} ;
d907 10
d993 3
a997 5
	my $elapsed = do {
	    if ($style eq 'nop') {$_->[4]+$_->[5]}
	    elsif ($style eq 'noc') {$_->[2]+$_->[3]}
	    else {$_->[2]+$_->[3]+$_->[4]+$_->[5]}
	};
@


1.14
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d40 1
a40 1
    $results = timethese($count, 
d224 2
a225 1
    $results = timethese( -1, { a => "++\$i", b => "\$i *= 2" } ) ;
d235 2
a236 1
    my $rows = cmpthese( -1, { a => '++$i', b => '$i *= 2' }, "none" );
d295 40
d384 1
a384 1
while 
d447 2
a448 2
September, 1999; by Barrie Slaymaker: math fixes and accuracy and 
efficiency tweaks.  Added cmpthese().  A result is now returned from 
d485 1
a485 1
$VERSION = 1.15;
d530 1
a530 1
sub usage { 
d543 1
a543 1
sub clearcache    { 
d545 1
a545 1
    delete $Cache{"$_[0]c"}; delete $Cache{"$_[0]s"}; 
d552 1
a552 1
sub clearallcache { 
d554 1
a554 1
    %Cache = (); 
d563 1
a563 1
    $Do_Cache = 1; 
d572 1
a572 1
    $Do_Cache = 0; 
d697 1
a697 1
    # Wait for the user timer to tick.  This makes the error range more like 
d775 1
d777 1
d780 12
a791 2
	    ++$zeros > 16
	        and die "Timing is consistently zero in estimation loop, cannot benchmark. N=$n\n";
d805 1
a805 1
	# and we guess a little low).  This does not noticably affect 
d986 4
a989 4
    my @@top_row = ( 
        '', 
	$display_as_rate ? 'Rate' : 's/iter', 
	map { $_->[0] } @@vals 
d1015 3
a1017 3
	my $format = 
	   $rate >= 100 ? 
	       "%0.0f" : 
d1054 1
a1054 1
	    # A little wierdness to set the first column width properly
d1065 1
a1065 1
    my @@sorted_width_refs = 
d1078 1
a1078 1
	    last 
@


1.13
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d443 1
a443 1
$VERSION = 1.13;
@


1.12
log
@Merge in perl 5.10.1
@
text
@d248 1
a248 1
Incidently, note the variance in the result values between the two examples;
d321 1
a321 1
accuracy and does not usually noticably affect runtimes.
d388 1
a388 1
L<Devel::DProf> - a Perl code profiler
d443 1
a443 1
$VERSION = 1.11;
d752 1
a752 1
	# accuracy since we're not couting these times.
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d84 1
a84 1
    $t0 = new Benchmark;
d86 1
a86 1
    $t1 = new Benchmark;
d94 1
a94 1
    debug Benchmark 1;
d96 1
a96 1
    debug Benchmark 0;
d222 1
a222 1
c<cmpthese> can also be passed the data structure that timethese() returns:
d443 1
a443 1
$VERSION = 1.10;
@


1.10
log
@merge in perl 5.8.8
@
text
@d164 1
a164 1
Returns a hash of Benchmark objects, keyed by name.
d228 2
d420 3
d443 1
a443 1
$VERSION = 1.07;
d464 1
d560 2
d602 1
a602 1
    $s=sprintf("$w wallclock secs (%$f usr %$f sys + %$f cusr %$f csys = %$f CPU)",
d604 1
a604 1
    $s=sprintf("$w wallclock secs (%$f usr + %$f sys = %$f CPU)",
d606 1
a606 1
    $s=sprintf("$w wallclock secs (%$f cusr + %$f csys = %$f CPU)",
d608 6
a613 2
    $s .= sprintf(" @@ %$f/s (n=$n)", $n / ( $style eq 'nop' ? $cu + $cs : $pu + $ps ))
	if $n && ($style eq 'nop' ? $cu+$cs : $pu+$ps);
d731 1
d735 6
d774 1
a774 1

d785 6
a790 1

d893 2
a894 1
    if( ref $_[0] ) {
d914 6
a919 2
	my $rate = $_->[6] / (( $style eq 'nop' ? $_->[4] + $_->[5]
						: $_->[2] + $_->[3]) + 0.000000000000001 );
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d438 1
a438 1
$VERSION = 1.06;
d651 1
a651 1
    &$subref;
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d415 3
d438 1
a438 1
$VERSION = 1.052;
d600 2
a601 1
    $s .= sprintf(" @@ %$f/s (n=$n)", $n / ( $pu + $ps )) if $n && $pu+$ps;
d889 2
a890 1
	my $rate = $_->[6] / ( $_->[2] + $_->[3] + 0.000000000000001 );
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d435 1
a435 1
$VERSION = 1.051;
d893 1
a893 1
    my $display_as_rate = $vals[$#vals>>1]->[7] > 1;
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 3
d56 3
d205 1
a205 1
=item cmpthese ( COUT, CODEHASHREF, [ STYLE ] )
d282 9
d413 2
d418 1
a418 1
sub _doeval { eval shift }
d426 4
a429 1
@@ISA=(Exporter);
d435 25
a459 1
$VERSION = 1.04;
d461 2
a462 1
&init;
d465 5
a469 5
    $debug = 0;
    $min_count = 4;
    $min_cpu   = 0.4;
    $defaultfmt = '5.2f';
    $defaultstyle = 'auto';
d473 2
a474 2
    &disablecache;
    &clearallcache;
d477 7
a483 1
sub debug { $debug = ($_[1] != 0); }
d486 38
a523 5
# emtpy loop is different in these two cases.
sub clearcache    { delete $cache{"$_[0]c"}; delete $cache{"$_[0]s"}; }
sub clearallcache { %cache = (); }
sub enablecache   { $cache = 1; }
sub disablecache  { $cache = 0; }
d527 2
a528 2
sub new { my @@t = (time, times, @@_ == 2 ? $_[1] : 0);
	  print STDERR "new=@@t\n" if $debug;
d537 5
d544 3
d554 4
d559 6
a564 3
     my($a, $b) = @@_;
     my @@r;
     for (my $i=0; $i < @@$a; ++$i) {
d566 2
a567 2
     }
     bless \@@r;
d570 5
d577 3
d584 1
a584 1
    $f = $defaultfmt unless defined $f;
d586 1
a586 1
    $style ||= $defaultstyle;
d590 2
a591 1
    $s=sprintf("%2d wallclock secs (%$f usr %$f sys + %$f cusr %$f csys = %$f CPU)",
d593 1
a593 1
    $s=sprintf("%2d wallclock secs (%$f usr + %$f sys = %$f CPU)",
d595 1
a595 1
    $s=sprintf("%2d wallclock secs (%$f cusr + %$f csys = %$f CPU)",
d603 1
a603 1
    print STDERR "$msg",timestr($t),"\n" if $debug;
d608 4
d617 1
a617 1
    confess "Usage: runloop(number, [string | coderef])" unless defined $c;
d637 1
a637 1
    print STDERR "runloop $n '$subcode'\n" if $debug;
d654 4
d663 4
a666 1
    printf STDERR "timeit $n $code\n" if $debug;
d668 2
a669 2
    if ($cache && exists $cache{$cache_key} ) {
	$wn = $cache{$cache_key};
d675 1
a675 1
	$cache{$cache_key} = $wn;
d693 5
d701 2
d779 5
d786 4
a789 1
    my($t, $for, $forn);
d796 1
a796 1
	$fort  = n_to_for( $n );
d804 1
a804 1
    print timestr($t, $style, $defaultfmt),"\n" unless $style eq 'none';
d812 1
a812 1
	if     $n < $min_count
d814 1
a814 1
	    || $t->cpu_a < $min_cpu;
d818 6
d826 2
a827 2
    die "usage: timethese(count, { 'Name1'=>'code1', ... }\n"
		unless ref $alt eq HASH;
d855 7
d863 13
a875 1
    my ($results, $style) = ref $_[0] ? @@_ : ( timethese( @@_[0,1,2] ), $_[2] ) ;
d923 1
a923 1
	my $a = $display_as_rate ? $row_rate : 1 / $row_rate;
d928 1
a928 1
	   $a >= 100 ? 
d930 1
a930 1
	   $a >= 10 ?
d932 1
a932 1
	   $a >= 1 ?
d934 1
a934 1
	   $a >= 0.1 ?
d940 5
a944 5
	# Using $b here due to optimizing bug in _58 through _61
	my $b = sprintf( $format, $a );
	push @@row, $b;
	$col_widths[1] = length( $b )
	    if length( $b ) > $col_widths[1];
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d9 2
d201 14
a214 1
=item cmpthese ( RESULTSHASHREF )
d216 1
a216 4
Optionally calls timethese(), then outputs comparison chart.  This 
chart is sorted from slowest to fastest, and shows the percent 
speed difference between each pair of tests.  Can also be passed 
the data structure that timethese() returns:
d218 1
a218 1
    $results = timethese( .... );
d221 22
a242 1
Returns the data structure returned by timethese() (or passed in).
d310 6
a315 1
   use Benchmark;$x=3;cmpthese(-5,{a=>sub{$x*$x},b=>sub{$x**2}})
d320 4
a323 5
	    a: 10 wallclock secs ( 5.14 usr +  0.13 sys =  5.27 CPU) @@ 3835055.60/s (n=20210743)
	    b:  5 wallclock secs ( 5.41 usr +  0.00 sys =  5.41 CPU) @@ 1574944.92/s (n=8520452)
	  Rate    b    a
   b 1574945/s   -- -59%
   a 3835056/s 144%   --
d327 7
a333 4
   use Benchmark;
   $x=3;
   $r=timethese(-5,{a=>sub{$x*$x},b=>sub{$x**2}},'none');
   cmpthese($r);
d337 6
a342 3
          Rate    b    a
   b 1559428/s   -- -62%
   a 4152037/s 166%   --
d392 6
d413 1
d415 1
a415 1
$VERSION = 1.00;
d444 1
a444 1
	  print "new=@@t\n" if $debug;
d480 1
d552 1
a552 1
	$wn = &runloop($n, ref( $code ) ? sub { undef } : '' );
d700 2
a701 1
	print ", each for at least $for CPU seconds" unless $style eq 'none';
d716 1
a716 1
    my $results = ref $_[0] ? $_[0] : timethese( @@_ );
d718 1
a718 2
    return $results
       if defined $_[2] && $_[2] eq 'none';
d814 2
d847 1
a847 1
    return $results;
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d555 3
a557 1
	$tc = $td->[1] + $td->[2];
d586 1
@


1.3
log
@perl5.005_03 (stock)
@
text
@d5 1
a5 7
Benchmark - benchmark running times of code

timethis - run a chunk of code several times

timethese - run several chunks of code several times

timeit - run a chunk of code and see how long it goes
d23 21
d47 4
d56 11
d90 4
d156 2
a162 5
=item timesum ( T1, T2 )

Returns the sum of two Benchmark times as a Benchmark object suitable
for passing to timestr().

d169 2
a170 2
STYLE can be any of 'all', 'noc', 'nop' or 'auto'. 'all' shows each
of the 5 times available ('wallclock' time, user time, system time,
d175 1
d197 28
d236 5
d248 1
a248 1
      ($real, $user, $system, $children_user, $children_system)
d260 1
a260 1
The null loop times are cached, the key being the
d270 32
d310 1
a310 1
inaccurate results: a code reference will show a slower
d326 4
d345 4
d362 4
a365 1
@@EXPORT_OK=qw(clearcache clearallcache disablecache enablecache);
d384 3
a386 1
sub clearcache    { delete $cache{$_[0]}; }
d401 1
d426 1
a426 1
    my($pt, $ct, $t) = ($tr->cpu_p, $tr->cpu_c, $tr->cpu_a);
d433 1
a433 1
			    @@t,$t) if $style eq 'all';
d438 1
a438 1
    $s .= sprintf(" @@ %$f/s (n=$n)", $n / ( $pu + $ps )) if $n;
d476 8
a483 1
    $t0 = Benchmark->new(0);
a486 1

d497 3
a499 3

    if ($cache && exists $cache{$n}) {
	$wn = $cache{$n};
d501 5
a505 2
	$wn = &runloop($n, '');
	$cache{$n} = $wn;
a510 1

d522 3
a524 2
sub runfor {
    my ($code, $tmax) = @@_;
d532 1
a532 1
    die "runfor(..., $tmax): timelimit cannot be less than $min_for.\n"
d535 1
a535 5
    my ($n, $td, $tc, $ntot, $rtot, $utot, $stot, $cutot, $cstot );

    # First find the minimum $n that gives a non-zero timing.
    
    my $nmin;
d537 3
a539 2
    for ($n = 1, $tc = 0; $tc <= 0; $n *= 2 ) {
	$td = timeit($n, $code);
d541 1
d544 1
a544 1
    $nmin = $n;
d546 11
a556 2
    my $ttot = 0;
    my $tpra = 0.05 * $tmax; # Target/time practice.
d558 21
a578 9
    # Double $n until we have think we have practiced enough.
    for ( $n = 1; $ttot < $tpra; $n *= 2 ) {
	$td = timeit($n, $code);
	$tc = $td->cpu_p;
	$ntot += $n;
	$rtot += $td->[0];
	$utot += $td->[1];
	$stot += $td->[2];
	$ttot = $utot + $stot;
d581 2
a582 3
    }

    my $r;
d584 2
a585 4
    # Then iterate towards the $tmax.
    while ( $ttot < $tmax ) {
	$r = $tmax / $ttot - 1; # Linear approximation.
	$n = int( $r * $n );
a586 8
	$td = timeit($n, $code);
	$ntot += $n;
	$rtot += $td->[0];
	$utot += $td->[1];
	$stot += $td->[2];
	$ttot = $utot + $stot;
	$cutot += $td->[3];
	$cstot += $td->[4];
d609 1
a609 1
	$t     = runfor($code, $fort);
d615 2
a616 2
    printf("%10s: ", $title);
    print timestr($t, $style, $defaultfmt),"\n";
d636 1
a636 1
    print "Benchmark: ";
d639 1
a639 1
	print "timing $n iterations of";
d641 1
a641 1
	print "running";
d643 1
a643 1
    print " ", join(', ',@@names);
d646 1
a646 1
	print ", each for at least $for CPU seconds";
d648 1
a648 1
    print "...\n";
d652 1
d654 135
a788 1
        timethis ($n, $alt -> {$name}, $name, $style);
d790 2
d793 1
@


1.2
log
@perl 5.004_04
@
text
@d85 24
d118 4
d127 6
a132 1
=item timestr ( TIMEDIFF, [ STYLE, [ FORMAT ]] )
d241 3
d246 7
d283 3
a285 1
sub new { my @@t = (time, times); print "new=@@t\n" if $debug; bless \@@t; }
d295 1
a295 1
    for ($i=0; $i < @@$a; ++$i) {
d301 9
d313 2
a314 2
    warn "bad time value" unless @@t==5;
    my($r, $pu, $ps, $cu, $cs) = @@t;
d321 1
a321 1
    $s=sprintf("%2d secs (%$f usr %$f sys + %$f cusr %$f csys = %$f cpu)",
d323 1
a323 1
    $s=sprintf("%2d secs (%$f usr %$f sys = %$f cpu)",
d325 1
a325 1
    $s=sprintf("%2d secs (%$f cusr %$f csys = %$f cpu)",
d327 1
d353 9
a361 4
    my $subcode = (ref $c eq 'CODE')
	? "sub { package $pack; my(\$_i)=$n; while (\$_i--){&\$c;} }"
	: "sub { package $pack; my(\$_i)=$n; while (\$_i--){$c;} }";
    my $subref  = eval $subcode;
d365 1
a365 1
    $t0 = &new;
d367 1
a367 1
    $t1 = &new;
d399 65
d466 5
d473 12
a484 1
    my $t = timeit($n, $code);
a485 1
    $title = "timethis $n" unless defined $title;
d488 3
a490 1
    print timestr($t, $style),"\n";
d508 13
a520 1
    print "Benchmark: timing $n iterations of ",join(', ',@@names),"...\n";
d524 3
a526 1
    map timethis($n, $alt->{$_}, $_, $style), @@names;
@


1.1
log
@Initial revision
@
text
@d17 1
d23 6
d50 1
a50 1
    print "the code took:",timestr($dt),"\n";
d56 1
a56 1
    debug Benchmark 1; 
d58 1
a58 1
    debug Benchmark 0; 
d64 1
a64 1
The following routines will be exported into your namespace 
d71 15
a85 4
Arguments: COUNT is the number of time to run the loop, and 
the second is the code to run.  CODE may be a string containing the code,
a reference to the function to run, or a reference to a hash containing 
keys which are names and values which are more CODE specs.
d87 4
a90 1
Side-effects: prints out noise to standard out.
d92 1
a92 1
Returns: a Benchmark object.  
d94 1
a94 1
=item timethis
d96 2
a97 1
=item timethese
d99 1
a99 1
=item timediff
d101 13
a113 1
=item timestr
d124 5
a128 1
clearcache
d130 1
a130 1
clearallcache
d132 1
a132 1
disablecache
d134 8
a141 1
enablecache
d148 1
a148 1
functions: 
a157 4
Enable debugging by:  

    $Benchmark::debug = 1;

d166 1
a166 1
    clearcache($key); 
d169 1
a169 1
    disablecache(); 
d179 4
d187 2
a188 2
can appear to take longer to execute the empty loop 
than a short test; try: 
d194 1
a194 3
code and therefore the difference might end up being < 0.

More documentation is needed :-( especially for styles and formats.
d198 1
a198 2
Jarkko Hietaniemi <Jarkko.Hietaniemi@@hut.fi>,
Tim Bunce <Tim.Bunce@@ig.co.uk>
d204 4
a209 81
# Purpose: benchmark running times of code.
#
#
# Usage - to time code snippets and print results:
#
#	timethis($count, '...code...');
#		
# prints:
#	timethis 100:  2 secs ( 0.23 usr  0.10 sys =  0.33 cpu)
#
#
#	timethese($count, {
#		Name1 => '...code1...',
#		Name2 => '...code2...',
#		... });
# prints:
#	Benchmark: timing 100 iterations of Name1, Name2...
#	     Name1:  2 secs ( 0.50 usr  0.00 sys =  0.50 cpu)
#	     Name2:  1 secs ( 0.48 usr  0.00 sys =  0.48 cpu)
#
# The default display style will automatically add child process
# values if non-zero.
#
#
# Usage - to time sections of your own code:
#
#	use Benchmark;
#	$t0 = new Benchmark;
#	... your code here ...
#	$t1 = new Benchmark;
#	$td = &timediff($t1, $t0);
#	print "the code took:",timestr($td),"\n";
#
#	$t = &timeit($count, '...other code...')
#	print "$count loops of other code took:",timestr($t),"\n";
# 
#
# Data format:
#       The data is stored as a list of values from the time and times
#       functions: ($real, $user, $system, $children_user, $children_system)
#	in seconds for the whole loop (not divided by the number of rounds).
#		
# Internals:
#	The timing is done using time(3) and times(3).
#		
#	Code is executed in the callers package
#
#	Enable debugging by:  $Benchmark::debug = 1;
#
#	The time of the null loop (a loop with the same
#	number of rounds but empty loop body) is substracted
#	from the time of the real loop.
#
#	The null loop times are cached, the key being the
#	number of rounds. The caching can be controlled using
#	&clearcache($key); &clearallcache;
#	&disablecache; &enablecache;
#
# Caveats:
#
#	The real time timing is done using time(2) and
#	the granularity is therefore only one second.
#
#	Short tests may produce negative figures because perl
#	can appear to take longer to execute the empty loop 
#	than a short test: try timethis(100,'1');
#
#	The system time of the null loop might be slightly
#	more than the system time of the loop with the actual
#	code and therefore the difference might end up being < 0
#
#	More documentation is needed :-(
#	Especially for styles and formats.
#
# Authors:	Jarkko Hietaniemi <Jarkko.Hietaniemi@@hut.fi>
# 		Tim Bunce <Tim.Bunce@@ig.co.uk>
#
#
# Last updated:	Sept 8th 94 by Tim Bunce
#

d231 2
a237 1

d240 1
a240 1
sub new { my(@@t)=(time, times); print "new=@@t\n" if $debug; bless \@@t; }
d247 1
a247 1
sub timediff{
d249 2
a250 2
    my(@@r);
    for($i=0; $i < @@$a; ++$i){
d256 1
a256 1
sub timestr{
d258 1
a258 1
    my(@@t) = @@$tr;
d262 1
a262 1
    $f = $defaultfmt unless $f;
d264 3
a266 3
    $style = $defaultstyle unless $style;
    $style = ($ct>0) ? 'all' : 'noc' if $style=~/^auto$/;
    my($s) = "@@t $style"; # default for unknown style
d268 1
a268 1
			    @@t,$t) if $style =~ /^all$/;
d270 1
a270 1
			    $r,$pu,$ps,$pt) if $style =~ /^noc$/;
d272 1
a272 1
			    $r,$cu,$cs,$ct) if $style =~ /^nop$/;
d275 2
a276 1
sub timedebug{
d278 1
a278 1
    print STDERR "$msg",timestr($t),"\n" if ($debug);
a280 1

d287 2
a288 2
    croak "negativ loopcount $n" if $n<0;
    confess "Usage: runloop(number, string)" unless defined $c;
d292 2
a293 2
    my ($curpack) = caller(0);
    my ($i, $pack)= 0;
d298 3
a300 1
    my $subcode = "sub { package $pack; my(\$_i)=$n; while (\$_i--){$c;} }";
d303 1
a303 1
    print STDERR "runloop $n '$subcode'\n" if ($debug);
d321 1
a321 1
    if ($cache && exists $cache{$n}){
d323 1
a323 1
    }else{
a338 1

d343 4
a346 4
    my($t) = timeit($n, $code);
    local($|) = 1;
    $title = "timethis $n" unless $title;
    $style = "" unless $style;
d349 1
d354 1
a354 1
	if (   $n < $min_count
d356 1
a356 1
	    || $t->cpu_a < $min_cpu);
a359 1

d364 2
a365 3
    my(@@all);
    my(@@names) = sort keys %$alt;
    $style = "" unless $style;
d367 2
a368 5
    foreach(@@names){
	$t = timethis($n, $alt->{$_}, $_, $style);
	push(@@all, $t);
    }
    # we could produce a summary from @@all here
d370 1
a370 1
    @@all;
a371 1

@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a16 1
    # Use Perl code in strings...
a21 6
    # ... or use subroutine references.
    timethese($count, {
	'Name1' => sub { ...code1... },
	'Name2' => sub { ...code2... },
    });

d43 1
a43 1
    print "the code took:",timestr($td),"\n";
d49 1
a49 1
    debug Benchmark 1;
d51 1
a51 1
    debug Benchmark 0;
d57 1
a57 1
The following routines will be exported into your namespace
d64 4
a67 29
Arguments: COUNT is the number of times to run the loop, and CODE is
the code to run.  CODE may be either a code reference or a string to
be eval'd; either way it will be run in the caller's package.

Returns: a Benchmark object.

=item timethis ( COUNT, CODE, [ TITLE, [ STYLE ]] )

Time COUNT iterations of CODE. CODE may be a string to eval or a
code reference; either way the CODE will run in the caller's package.
Results will be printed to STDOUT as TITLE followed by the times.
TITLE defaults to "timethis COUNT" if none is provided. STYLE
determines the format of the output, as described for timestr() below.

The COUNT can be zero or negative: this means the I<minimum number of
CPU seconds> to run.  A zero signifies the default of 3 seconds.  For
example to run at least for 10 seconds:

	timethis(-10, $code)

or to run two pieces of code tests for at least 3 seconds:

	timethese(0, { test1 => '...', test2 => '...'})

CPU seconds is, in UNIX terms, the user time plus the system time of
the process itself, as opposed to the real (wallclock) time and the
time spent by the child processes.  Less than 0.1 seconds is not
accepted (-0.01 as the count, for example, will cause a fatal runtime
exception).
d69 1
a69 5
Note that the CPU seconds is the B<minimum> time: CPU scheduling and
other operating system factors may complicate the attempt so that a
little bit more time is spent.  The benchmark output will, however,
also tell the number of C<$code> runs/second, which should be a more
interesting number than the actually spent seconds.
d71 1
a71 1
Returns a Benchmark object.
d73 1
a73 1
=item timethese ( COUNT, CODEHASHREF, [ STYLE ] )
d75 1
a75 4
The CODEHASHREF is a reference to a hash containing names as keys
and either a string to eval or a code reference for each value.
For each (KEY, VALUE) pair in the CODEHASHREF, this routine will
call
d77 1
a77 1
	timethis(COUNT, VALUE, KEY, STYLE)
d79 1
a79 29
The routines are called in string comparison order of KEY.

The COUNT can be zero or negative, see timethis().

=item timediff ( T1, T2 )

Returns the difference between two Benchmark times as a Benchmark
object suitable for passing to timestr().

=item timesum ( T1, T2 )

Returns the sum of two Benchmark times as a Benchmark object suitable
for passing to timestr().

=item timestr ( TIMEDIFF, [ STYLE, [ FORMAT ] ] )

Returns a string that formats the times in the TIMEDIFF object in
the requested STYLE. TIMEDIFF is expected to be a Benchmark object
similar to that returned by timediff().

STYLE can be any of 'all', 'noc', 'nop' or 'auto'. 'all' shows each
of the 5 times available ('wallclock' time, user time, system time,
user time of children, and system time of children). 'noc' shows all
except the two children times. 'nop' shows only wallclock and the
two children times. 'auto' (the default) will act as 'all' unless
the children times are both zero, in which case it acts as 'noc'.

FORMAT is the L<printf(3)>-style format specifier (without the
leading '%') to use to print the times. It defaults to '5.2f'.
d90 1
a90 5
=item clearcache ( COUNT )

Clear the cached time for COUNT rounds of the null loop.

=item clearallcache ( )
d92 1
a92 1
Clear all cached times.
d94 1
a94 1
=item disablecache ( )
d96 1
a96 8
Disable caching of timings for the null loop. This will force Benchmark
to recalculate these timings for each new piece of code timed.

=item enablecache ( )

Enable caching of timings for the null loop. The time taken for COUNT
rounds of the null loop will be calculated only once for each
different COUNT used.
d103 1
a103 1
functions:
d113 4
d125 1
a125 1
    clearcache($key);
d128 1
a128 1
    disablecache();
a137 4
Comparing eval'd strings with code references will give you
inaccurate results: a code reference will show a slower
execution time than the equivalent eval'd string.

d142 2
a143 2
can appear to take longer to execute the empty loop
than a short test; try:
d149 3
a151 1
code and therefore the difference might end up being E<lt> 0.
d155 2
a156 1
Jarkko Hietaniemi <F<jhi@@iki.fi>>, Tim Bunce <F<Tim.Bunce@@ig.co.uk>>
a161 7
March 28th, 1997; by Hugo van der Sanden: added support for code
references and the already documented 'debug' method; revamped
documentation.

April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time
functionality.

d164 77
a240 3
# evaluate something in a clean lexical environment
sub _doeval { eval shift }

d242 1
a242 1
# put any lexicals at file scope AFTER here
a265 2
sub debug { $debug = ($_[1] != 0); }

d271 1
d274 1
a274 3
sub new { my @@t = (time, times, @@_ == 2 ? $_[1] : 0);
	  print "new=@@t\n" if $debug;
	  bless \@@t; }
d281 1
a281 1
sub timediff {
d283 2
a284 2
    my @@r;
    for (my $i=0; $i < @@$a; ++$i) {
d290 1
a290 10
sub timesum {
     my($a, $b) = @@_;
     my @@r;
     for (my $i=0; $i < @@$a; ++$i) {
 	push(@@r, $a->[$i] + $b->[$i]);
     }
     bless \@@r;
}

sub timestr {
d292 3
a294 3
    my @@t = @@$tr;
    warn "bad time value (@@t)" unless @@t==6;
    my($r, $pu, $ps, $cu, $cs, $n) = @@t;
d296 1
a296 1
    $f = $defaultfmt unless defined $f;
d298 9
a306 10
    $style ||= $defaultstyle;
    $style = ($ct>0) ? 'all' : 'noc' if $style eq 'auto';
    my $s = "@@t $style"; # default for unknown style
    $s=sprintf("%2d wallclock secs (%$f usr %$f sys + %$f cusr %$f csys = %$f CPU)",
			    @@t,$t) if $style eq 'all';
    $s=sprintf("%2d wallclock secs (%$f usr + %$f sys = %$f CPU)",
			    $r,$pu,$ps,$pt) if $style eq 'noc';
    $s=sprintf("%2d wallclock secs (%$f cusr + %$f csys = %$f CPU)",
			    $r,$cu,$cs,$ct) if $style eq 'nop';
    $s .= sprintf(" @@ %$f/s (n=$n)", $n / ( $pu + $ps )) if $n;
d309 1
a309 2

sub timedebug {
d311 1
a311 1
    print STDERR "$msg",timestr($t),"\n" if $debug;
d314 1
d321 2
a322 2
    croak "negative loopcount $n" if $n<0;
    confess "Usage: runloop(number, [string | coderef])" unless defined $c;
d326 2
a327 2
    my($curpack) = caller(0);
    my($i, $pack)= 0;
d332 2
a333 9
    my ($subcode, $subref);
    if (ref $c eq 'CODE') {
	$subcode = "sub { for (1 .. $n) { local \$_; package $pack; &\$c; } }";
        $subref  = eval $subcode;
    }
    else {
	$subcode = "sub { for (1 .. $n) { local \$_; package $pack; $c;} }";
        $subref  = _doeval($subcode);
    }
d335 1
a335 1
    print STDERR "runloop $n '$subcode'\n" if $debug;
d337 1
a337 1
    $t0 = Benchmark->new(0);
d339 1
a339 1
    $t1 = Benchmark->new($n);
d353 1
a353 1
    if ($cache && exists $cache{$n}) {
d355 1
a355 1
    } else {
a371 64
my $default_for = 3;
my $min_for     = 0.1;

sub runfor {
    my ($code, $tmax) = @@_;

    if ( not defined $tmax or $tmax == 0 ) {
	$tmax = $default_for;
    } elsif ( $tmax < 0 ) {
	$tmax = -$tmax;
    }

    die "runfor(..., $tmax): timelimit cannot be less than $min_for.\n"
	if $tmax < $min_for;

    my ($n, $td, $tc, $ntot, $rtot, $utot, $stot, $cutot, $cstot );

    # First find the minimum $n that gives a non-zero timing.
    
    my $nmin;

    for ($n = 1, $tc = 0; $tc <= 0; $n *= 2 ) {
	$td = timeit($n, $code);
	$tc = $td->[1] + $td->[2];
    }

    $nmin = $n;

    my $ttot = 0;
    my $tpra = 0.05 * $tmax; # Target/time practice.

    # Double $n until we have think we have practiced enough.
    for ( $n = 1; $ttot < $tpra; $n *= 2 ) {
	$td = timeit($n, $code);
	$tc = $td->cpu_p;
	$ntot += $n;
	$rtot += $td->[0];
	$utot += $td->[1];
	$stot += $td->[2];
	$ttot = $utot + $stot;
	$cutot += $td->[3];
	$cstot += $td->[4];
    }

    my $r;

    # Then iterate towards the $tmax.
    while ( $ttot < $tmax ) {
	$r = $tmax / $ttot - 1; # Linear approximation.
	$n = int( $r * $n );
	$n = $nmin if $n < $nmin;
	$td = timeit($n, $code);
	$ntot += $n;
	$rtot += $td->[0];
	$utot += $td->[1];
	$stot += $td->[2];
	$ttot = $utot + $stot;
	$cutot += $td->[3];
	$cstot += $td->[4];
    }

    return bless [ $rtot, $utot, $stot, $cutot, $cstot, $ntot ];
}

a373 5
sub n_to_for {
    my $n = shift;
    return $n == 0 ? $default_for : $n < 0 ? -$n : undef;
}

d376 4
a379 14
    my($t, $for, $forn);

    if ( $n > 0 ) {
	croak "non-integer loopcount $n, stopped" if int($n)<$n;
	$t = timeit($n, $code);
	$title = "timethis $n" unless defined $title;
    } else {
	$fort  = n_to_for( $n );
	$t     = runfor($code, $fort);
	$title = "timethis for $fort" unless defined $title;
	$forn  = $t->[-1];
    }
    local $| = 1;
    $style = "" unless defined $style;
d381 1
a381 4
    print timestr($t, $style, $defaultfmt),"\n";

    $n = $forn if defined $forn;

d386 1
a386 1
	if     $n < $min_count
d388 1
a388 1
	    || $t->cpu_a < $min_cpu;
d392 1
d397 7
a403 13
    my @@names = sort keys %$alt;
    $style = "" unless defined $style;
    print "Benchmark: ";
    if ( $n > 0 ) {
	croak "non-integer loopcount $n, stopped" if int($n)<$n;
	print "timing $n iterations of";
    } else {
	print "running";
    }
    print " ", join(', ',@@names);
    unless ( $n > 0 ) {
	my $for = n_to_for( $n );
	print ", each for at least $for CPU seconds";
d405 1
a405 3
    print "...\n";

    # we could save the results in an array and produce a summary here
d407 1
a407 3
    foreach my $name (@@names) {
        timethis ($n, $alt -> {$name}, $name, $style);
    }
d409 1
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d5 7
a11 1
Benchmark - benchmark running times of Perl code
a28 21
    # cmpthese can be used both ways as well
    cmpthese($count, {
	'Name1' => '...code1...',
	'Name2' => '...code2...',
    });

    cmpthese($count, {
	'Name1' => sub { ...code1... },
	'Name2' => sub { ...code2... },
    });

    # ...or in two stages
    $results = timethese($count, 
        {
	    'Name1' => sub { ...code1... },
	    'Name2' => sub { ...code2... },
        },
	'none'
    );
    cmpthese( $results ) ;

a31 4
    $t = countit($time, '...other code...')
    $count = $t->iters ;
    print "$count loops of other code took:",timestr($t),"\n";

a36 11
timethis - run a chunk of code several times

timethese - run several chunks of code several times

cmpthese - print results of timethese as a comparison chart

timeit - run a chunk of code and see how long it goes

countit - see how many times a chunk of code runs in a given time


a59 4
=item iters

Returns the number of iterations.

a121 2
Returns a hash of Benchmark objects, keyed by name.

d127 5
d138 2
a139 2
STYLE can be any of 'all', 'none', 'noc', 'nop' or 'auto'. 'all' shows
each of the 5 times available ('wallclock' time, user time, system time,
a143 1
'none' prevents output.
a164 28
=item cmpthese ( COUT, CODEHASHREF, [ STYLE ] )

=item cmpthese ( RESULTSHASHREF )

Optionally calls timethese(), then outputs comparison chart.  This 
chart is sorted from slowest to fastest, and shows the percent 
speed difference between each pair of tests.  Can also be passed 
the data structure that timethese() returns:

    $results = timethese( .... );
    cmpthese( $results );

Returns the data structure returned by timethese() (or passed in).

=item countit(TIME, CODE)

Arguments: TIME is the minimum length of time to run CODE for, and CODE is
the code to run.  CODE may be either a code reference or a string to
be eval'd; either way it will be run in the caller's package.

TIME is I<not> negative.  countit() will run the loop many times to
calculate the speed of CODE before running it for TIME.  The actual
time run for will usually be greater than TIME due to system clock
resolution, so it's best to look at the number of iterations divided
by the times that you are concerned with, not just the iterations.

Returns: a Benchmark object.

a175 5
=item timesum ( T1, T2 )

Returns the sum of two Benchmark times as a Benchmark object suitable
for passing to timestr().

d183 1
a183 1
      ($real, $user, $system, $children_user, $children_system, $iters)
d195 1
a195 1
The null loop times can be cached, the key being the
a204 32
Caching is off by default, as it can (usually slightly) decrease
accuracy and does not usually noticably affect runtimes.

=head1 EXAMPLES

For example,

   use Benchmark;$x=3;cmpthese(-5,{a=>sub{$x*$x},b=>sub{$x**2}})

outputs something like this:

   Benchmark: running a, b, each for at least 5 CPU seconds...
	    a: 10 wallclock secs ( 5.14 usr +  0.13 sys =  5.27 CPU) @@ 3835055.60/s (n=20210743)
	    b:  5 wallclock secs ( 5.41 usr +  0.00 sys =  5.41 CPU) @@ 1574944.92/s (n=8520452)
	  Rate    b    a
   b 1574945/s   -- -59%
   a 3835056/s 144%   --

while 

   use Benchmark;
   $x=3;
   $r=timethese(-5,{a=>sub{$x*$x},b=>sub{$x**2}},'none');
   cmpthese($r);

outputs something like this:

          Rate    b    a
   b 1559428/s   -- -62%
   a 4152037/s 166%   --


d213 1
a213 1
inaccurate results: a code reference will show a slightly slower
a228 4
=head1 SEE ALSO

L<Devel::DProf> - a Perl code profiler

a243 4
September, 1999; by Barrie Slaymaker: math fixes and accuracy and 
efficiency tweaks.  Added cmpthese().  A result is now returned from 
timethese().  Exposed countit() (was runfor()).

d257 1
a257 4
@@EXPORT_OK=qw(timesum cmpthese countit
	      clearcache clearallcache disablecache enablecache);

$VERSION = 1.00;
d276 1
a276 3
# The cache needs two branches: 's' for strings and 'c' for code.  The
# emtpy loop is different in these two cases.
sub clearcache    { delete $cache{"$_[0]c"}; delete $cache{"$_[0]s"}; }
a290 1
sub iters { $_[0]->[5] ; }
d315 1
a315 1
    my($pt, $ct, $tt) = ($tr->cpu_p, $tr->cpu_c, $tr->cpu_a);
d322 1
a322 1
			    $r,$pu,$ps,$cu,$cs,$tt) if $style eq 'all';
d327 1
a327 1
    $s .= sprintf(" @@ %$f/s (n=$n)", $n / ( $pu + $ps )) if $n && $pu+$ps;
d365 1
a365 8
    # Wait for the user timer to tick.  This makes the error range more like 
    # -0.01, +0.  If we don't wait, then it's more like -0.01, +0.01.  This
    # may not seem important, but it significantly reduces the chances of
    # getting a too low initial $n in the initial, 'find the minimum' loop
    # in &countit.  This, in turn, can reduce the number of calls to
    # &runloop a lot, and thus reduce additive errors.
    my $tbase = Benchmark->new(0)->[1];
    while ( ( $t0 = Benchmark->new(0) )->[1] == $tbase ) {} ;
d369 1
d380 3
a382 3
    my $cache_key = $n . ( ref( $code ) ? 'c' : 's' );
    if ($cache && exists $cache{$cache_key} ) {
	$wn = $cache{$cache_key};
d384 2
a385 5
	$wn = &runloop($n, ref( $code ) ? sub { undef } : '' );
	# Can't let our baseline have any iterations, or they get subtracted
	# out of the result.
	$wn->[5] = 0;
	$cache{$cache_key} = $wn;
d391 1
d403 2
a404 3

sub countit {
    my ( $tmax, $code ) = @@_;
d412 1
a412 1
    die "countit($tmax, ...): timelimit cannot be less than $min_for.\n"
d415 5
a419 1
    my ($n, $tc);
d421 2
a422 3
    # First find the minimum $n that gives a significant timing.
    for ($n = 1; ; $n *= 2 ) {
	my $td = timeit($n, $code);
a423 1
	last if $tc > 0.1;
d426 1
a426 1
    my $nmin = $n;
d428 2
a429 11
    # Get $n high enough that we can guess the final $n with some accuracy.
    my $tpra = 0.1 * $tmax; # Target/time practice.
    while ( $tc < $tpra ) {
	# The 5% fudge is to keep us from iterating again all
	# that often (this speeds overall responsiveness when $tmax is big
	# and we guess a little low).  This does not noticably affect 
	# accuracy since we're not couting these times.
	$n = int( $tpra * 1.05 * $n / $tc ); # Linear approximation.
	my $td = timeit($n, $code);
	$tc = $td->[1] + $td->[2];
    }
d431 9
a439 21
    # Now, do the 'for real' timing(s), repeating until we exceed
    # the max.
    my $ntot  = 0;
    my $rtot  = 0;
    my $utot  = 0.0;
    my $stot  = 0.0;
    my $cutot = 0.0;
    my $cstot = 0.0;
    my $ttot  = 0.0;

    # The 5% fudge is because $n is often a few % low even for routines
    # with stable times and avoiding extra timeit()s is nice for
    # accuracy's sake.
    $n = int( $n * ( 1.05 * $tmax / $tc ) );

    while () {
	my $td = timeit($n, $code);
	$ntot  += $n;
	$rtot  += $td->[0];
	$utot  += $td->[1];
	$stot  += $td->[2];
d442 3
a444 2
	$ttot = $utot + $stot;
	last if $ttot >= $tmax;
d446 4
a449 2
	my $r = $tmax / $ttot - 1; # Linear approximation.
	$n = int( $r * $ntot );
d451 8
d481 1
a481 1
	$t     = countit( $fort, $code );
d487 2
a488 2
    printf("%10s: ", $title) unless $style eq 'none';
    print timestr($t, $style, $defaultfmt),"\n" unless $style eq 'none';
d508 1
a508 1
    print "Benchmark: " unless $style eq 'none';
d511 1
a511 1
	print "timing $n iterations of" unless $style eq 'none';
d513 1
a513 1
	print "running" unless $style eq 'none';
d515 1
a515 1
    print " ", join(', ',@@names) unless $style eq 'none';
d518 1
a518 1
	print ", each for at least $for CPU seconds" unless $style eq 'none';
d520 1
a520 1
    print "...\n" unless $style eq 'none';
a523 1
    my %results;
d525 1
a525 135
        $results{$name} = timethis ($n, $alt -> {$name}, $name, $style);
    }

    return \%results;
}

sub cmpthese{
    my $results = ref $_[0] ? $_[0] : timethese( @@_ );

    return $results
       if defined $_[2] && $_[2] eq 'none';

    # Flatten in to an array of arrays with the name as the first field
    my @@vals = map{ [ $_, @@{$results->{$_}} ] } keys %$results;

    for (@@vals) {
	# The epsilon fudge here is to prevent div by 0.  Since clock
	# resolutions are much larger, it's below the noise floor.
	my $rate = $_->[6] / ( $_->[2] + $_->[3] + 0.000000000000001 );
	$_->[7] = $rate;
    }

    # Sort by rate
    @@vals = sort { $a->[7] <=> $b->[7] } @@vals;

    # If more than half of the rates are greater than one...
    my $display_as_rate = $vals[$#vals>>1]->[7] > 1;

    my @@rows;
    my @@col_widths;

    my @@top_row = ( 
        '', 
	$display_as_rate ? 'Rate' : 's/iter', 
	map { $_->[0] } @@vals 
    );

    push @@rows, \@@top_row;
    @@col_widths = map { length( $_ ) } @@top_row;

    # Build the data rows
    # We leave the last column in even though it never has any data.  Perhaps
    # it should go away.  Also, perhaps a style for a single column of
    # percentages might be nice.
    for my $row_val ( @@vals ) {
	my @@row;

        # Column 0 = test name
	push @@row, $row_val->[0];
	$col_widths[0] = length( $row_val->[0] )
	    if length( $row_val->[0] ) > $col_widths[0];

        # Column 1 = performance
	my $row_rate = $row_val->[7];

	# We assume that we'll never get a 0 rate.
	my $a = $display_as_rate ? $row_rate : 1 / $row_rate;

	# Only give a few decimal places before switching to sci. notation,
	# since the results aren't usually that accurate anyway.
	my $format = 
	   $a >= 100 ? 
	       "%0.0f" : 
	   $a >= 10 ?
	       "%0.1f" :
	   $a >= 1 ?
	       "%0.2f" :
	   $a >= 0.1 ?
	       "%0.3f" :
	       "%0.2e";

	$format .= "/s"
	    if $display_as_rate;
	# Using $b here due to optimizing bug in _58 through _61
	my $b = sprintf( $format, $a );
	push @@row, $b;
	$col_widths[1] = length( $b )
	    if length( $b ) > $col_widths[1];

        # Columns 2..N = performance ratios
	my $skip_rest = 0;
	for ( my $col_num = 0 ; $col_num < @@vals ; ++$col_num ) {
	    my $col_val = $vals[$col_num];
	    my $out;
	    if ( $skip_rest ) {
		$out = '';
	    }
	    elsif ( $col_val->[0] eq $row_val->[0] ) {
		$out = "--";
		# $skip_rest = 1;
	    }
	    else {
		my $col_rate = $col_val->[7];
		$out = sprintf( "%.0f%%", 100*$row_rate/$col_rate - 100 );
	    }
	    push @@row, $out;
	    $col_widths[$col_num+2] = length( $out )
		if length( $out ) > $col_widths[$col_num+2];

	    # A little wierdness to set the first column width properly
	    $col_widths[$col_num+2] = length( $col_val->[0] )
		if length( $col_val->[0] ) > $col_widths[$col_num+2];
	}
	push @@rows, \@@row;
    }

    # Equalize column widths in the chart as much as possible without
    # exceeding 80 characters.  This does not use or affect cols 0 or 1.
    my @@sorted_width_refs = 
       sort { $$a <=> $$b } map { \$_ } @@col_widths[2..$#col_widths];
    my $max_width = ${$sorted_width_refs[-1]};

    my $total = @@col_widths - 1 ;
    for ( @@col_widths ) { $total += $_ }

    STRETCHER:
    while ( $total < 80 ) {
	my $min_width = ${$sorted_width_refs[0]};
	last
	   if $min_width == $max_width;
	for ( @@sorted_width_refs ) {
	    last 
		if $$_ > $min_width;
	    ++$$_;
	    ++$total;
	    last STRETCHER
		if $total >= 80;
	}
    }

    # Dump the output
    my $format = join( ' ', map { "%${_}s" } @@col_widths ) . "\n";
    substr( $format, 1, 0 ) = '-';
    for ( @@rows ) {
	printf $format, @@$_;
a526 2

    return $results;
a527 1

@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d555 1
a555 3
	my $new_tc = $td->[1] + $td->[2];
        # Make sure we are making progress.
        $tc = $new_tc > 1.2 * $tc ? $new_tc : 1.2 * $tc;
a583 1
        $ttot = 0.01 if $ttot < 0.01;
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@a8 2
    use Benchmark qw(:all) ;

d199 1
a199 14
=item cmpthese ( RESULTSHASHREF, [ STYLE ] )

Optionally calls timethese(), then outputs comparison chart.  This:

    cmpthese( -1, { a => "++\$i", b => "\$i *= 2" } ) ;

outputs a chart like:

           Rate    b    a
    b 2831802/s   -- -61%
    a 7208959/s 155%   --

This chart is sorted from slowest to fastest, and shows the percent speed
difference between each pair of tests.
d201 4
a204 1
c<cmpthese> can also be passed the data structure that timethese() returns:
d206 1
a206 1
    $results = timethese( -1, { a => "++\$i", b => "\$i *= 2" } ) ;
d209 1
a209 22
in case you want to see both sets of results.

Returns a reference to an ARRAY of rows, each row is an ARRAY of cells from the
above chart, including labels. This:

    my $rows = cmpthese( -1, { a => '++$i', b => '$i *= 2' }, "none" );

returns a data structure like:

    [
        [ '',       'Rate',   'b',    'a' ],
        [ 'b', '2885232/s',  '--', '-59%' ],
        [ 'a', '7099126/s', '146%',  '--' ],
    ]

B<NOTE>: This result value differs from previous versions, which returned
the C<timethese()> result structure.  If you want that, just use the two
statement C<timethese>...C<cmpthese> idiom shown above.

Incidently, note the variance in the result values between the two examples;
this is typical of benchmarking.  If this were a real benchmark, you would
probably want to run a lot more iterations.
d277 1
a277 6
    use Benchmark qw( cmpthese ) ;
    $x = 3;
    cmpthese( -5, {
        a => sub{$x*$x},
        b => sub{$x**2},
    } );
d282 5
a286 4
          Rate    b    a
   b 1559428/s   -- -62%
   a 4152037/s 166%   --

d290 4
a293 7
    use Benchmark qw( timethese cmpthese ) ;
    $x = 3;
    $r = timethese( -5, {
        a => sub{$x*$x},
        b => sub{$x**2},
    } );
    cmpthese $r;
d297 3
a299 6
    Benchmark: running a, b, each for at least 5 CPU seconds...
             a: 10 wallclock secs ( 5.14 usr +  0.13 sys =  5.27 CPU) @@ 3835055.60/s (n=20210743)
             b:  5 wallclock secs ( 5.41 usr +  0.00 sys =  5.41 CPU) @@ 1574944.92/s (n=8520452)
           Rate    b    a
    b 1574945/s   -- -59%
    a 3835056/s 144%   --
a348 6
December, 2001; by Nicholas Clark: make timestr() recognise the style 'none'
and return an empty string. If cmpthese is calling timethese, make it pass the
style in. (so that 'none' will suppress output). Make sub new dump its
debugging output to STDERR, to be consistent with everything else.
All bugs found while writing a regression test.

a363 1
%EXPORT_TAGS=( all => [ @@EXPORT, @@EXPORT_OK ] ) ;
d365 1
a365 1
$VERSION = 1.04;
d394 1
a394 1
	  print STDERR "new=@@t\n" if $debug;
a429 1
    return '' if $style eq 'none';
d501 1
a501 1
	$wn = &runloop($n, ref( $code ) ? sub { } : '' );
d649 1
a649 2
	print ", each" if $n > 1 && $style ne 'none';
	print " for at least $for CPU seconds" unless $style eq 'none';
d664 1
a664 1
    my ($results, $style) = ref $_[0] ? @@_ : ( timethese( @@_[0,1,2] ), $_[2] ) ;
d666 2
a667 1
    $style = "" unless defined $style;
a762 2
    return \@@rows if $style eq "none";

d794 1
a794 1
    return \@@rows ;
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a2 3
use strict;


a52 3
    # enable hires wallclock timing if possible
    use Benchmark ':hireswallclock';

d199 1
a199 1
=item cmpthese ( COUNT, CODEHASHREF, [ STYLE ] )
a275 9
=head2 :hireswallclock

If the Time::HiRes module has been installed, you can specify the
special tag C<:hireswallclock> for Benchmark (if Time::HiRes is not
available, the tag will be silently ignored).  This tag will cause the
wallclock time to be measured in microseconds, instead of integer
seconds.  Note though that the speed computations are still conducted
in CPU time, not wallclock time.

a397 2
September, 2002; by Jarkko Hietaniemi: add ':hireswallclock' special tag.

d401 1
a401 1
sub _doeval { no strict;  eval shift }
d409 1
a409 4

our(@@ISA, @@EXPORT, @@EXPORT_OK, %EXPORT_TAGS, $VERSION);

@@ISA=qw(Exporter);
d415 1
a415 25
$VERSION = 1.051;

# --- ':hireswallclock' special handling

my $hirestime;

sub mytime () { time }

init();

sub BEGIN {
    if (eval 'require Time::HiRes') {
	import Time::HiRes qw(time);
	$hirestime = \&Time::HiRes::time;
    }
}

sub import {
    my $class = shift;
    if (grep { $_ eq ":hireswallclock" } @@_) {
	@@_ = grep { $_ ne ":hireswallclock" } @@_;
	*mytime = $hirestime if defined $hirestime;
    }
    Benchmark->export_to_level(1, $class, @@_);
}
d417 1
a417 2
our($Debug, $Min_Count, $Min_CPU, $Default_Format, $Default_Style,
    %_Usage, %Cache, $Do_Cache);
d420 5
a424 5
    $Debug = 0;
    $Min_Count = 4;
    $Min_CPU   = 0.4;
    $Default_Format = '5.2f';
    $Default_Style = 'auto';
d428 2
a429 2
    disablecache();
    clearallcache();
d432 1
a432 7
sub debug { $Debug = ($_[1] != 0); }

sub usage { 
    my $calling_sub = (caller(1))[3];
    $calling_sub =~ s/^Benchmark:://;
    return $_Usage{$calling_sub} || '';
}
d435 5
a439 38
# empty loop is different in these two cases.

$_Usage{clearcache} = <<'USAGE';
usage: clearcache($count);
USAGE

sub clearcache    { 
    die usage unless @@_ == 1;
    delete $Cache{"$_[0]c"}; delete $Cache{"$_[0]s"}; 
}

$_Usage{clearallcache} = <<'USAGE';
usage: clearallcache();
USAGE

sub clearallcache { 
    die usage if @@_;
    %Cache = (); 
}

$_Usage{enablecache} = <<'USAGE';
usage: enablecache();
USAGE

sub enablecache   {
    die usage if @@_;
    $Do_Cache = 1; 
}

$_Usage{disablecache} = <<'USAGE';
usage: disablecache();
USAGE

sub disablecache  {
    die usage if @@_;
    $Do_Cache = 0; 
}

d443 2
a444 2
sub new { my @@t = (mytime, times, @@_ == 2 ? $_[1] : 0);
	  print STDERR "new=@@t\n" if $Debug;
a452 5

$_Usage{timediff} = <<'USAGE';
usage: $result_diff = timediff($result1, $result2);
USAGE

a454 3

    die usage unless ref $a and ref $b;

a461 4
$_Usage{timesum} = <<'USAGE';
usage: $sum = timesum($result1, $result2);
USAGE

d463 3
a465 6
    my($a, $b) = @@_;

    die usage unless ref $a and ref $b;

    my @@r;
    for (my $i=0; $i < @@$a; ++$i) {
d467 2
a468 2
    }
    bless \@@r;
a470 5

$_Usage{timestr} = <<'USAGE';
usage: $formatted_result = timestr($result1);
USAGE

a472 3

    die usage unless ref $tr;

d477 1
a477 1
    $f = $Default_Format unless defined $f;
d479 1
a479 1
    $style ||= $Default_Style;
d483 1
a483 2
    my $w = $hirestime ? "%2g" : "%2d";
    $s=sprintf("$w wallclock secs (%$f usr %$f sys + %$f cusr %$f csys = %$f CPU)",
d485 1
a485 1
    $s=sprintf("$w wallclock secs (%$f usr + %$f sys = %$f CPU)",
d487 1
a487 1
    $s=sprintf("$w wallclock secs (%$f cusr + %$f csys = %$f CPU)",
d495 1
a495 1
    print STDERR "$msg",timestr($t),"\n" if $Debug;
a499 4
$_Usage{runloop} = <<'USAGE';
usage: runloop($number, [$string | $coderef])
USAGE

d505 1
a505 1
    confess usage unless defined $c;
d525 1
a525 1
    print STDERR "runloop $n '$subcode'\n" if $Debug;
a541 4
$_Usage{timeit} = <<'USAGE';
usage: $result = timeit($count, 'code' );        or
       $result = timeit($count, sub { code } );
USAGE
d547 1
a547 4
    die usage unless defined $code and
                     (!ref $code or ref $code eq 'CODE');

    printf STDERR "timeit $n $code\n" if $Debug;
d549 2
a550 2
    if ($Do_Cache && exists $Cache{$cache_key} ) {
	$wn = $Cache{$cache_key};
d556 1
a556 1
	$Cache{$cache_key} = $wn;
a573 5
$_Usage{countit} = <<'USAGE';
usage: $result = countit($time, 'code' );        or
       $result = countit($time, sub { code } );
USAGE

a576 2
    die usage unless @@_;

a652 5
$_Usage{timethis} = <<'USAGE';
usage: $result = timethis($time, 'code' );        or
       $result = timethis($time, sub { code } );
USAGE

d655 1
a655 4
    my($t, $forn);

    die usage unless defined $code and
                     (!ref $code or ref $code eq 'CODE');
d662 1
a662 1
	my $fort  = n_to_for( $n );
d670 1
a670 1
    print timestr($t, $style, $Default_Format),"\n" unless $style eq 'none';
d678 1
a678 1
	if     $n < $Min_Count
d680 1
a680 1
	    || $t->cpu_a < $Min_CPU;
a683 6

$_Usage{timethese} = <<'USAGE';
usage: timethese($count, { Name1 => 'code1', ... });        or
       timethese($count, { Name1 => sub { code1 }, ... });
USAGE

d686 2
a687 2
    die usage unless ref $alt eq 'HASH';

a714 7

$_Usage{cmpthese} = <<'USAGE';
usage: cmpthese($count, { Name1 => 'code1', ... });        or
       cmpthese($count, { Name1 => sub { code1 }, ... });  or
       cmpthese($result, $style);
USAGE

d716 1
a716 13
    my ($results, $style);

    if( ref $_[0] ) {
        ($results, $style) = @@_;
    }
    else {
        my($count, $code) = @@_[0,1];
        $style = $_[2] if defined $_[2];

        die usage unless ref $code eq 'HASH';

        $results = timethese($count, $code, ($style || "none"));
    }
d764 1
a764 1
	my $rate = $display_as_rate ? $row_rate : 1 / $row_rate;
d769 1
a769 1
	   $rate >= 100 ? 
d771 1
a771 1
	   $rate >= 10 ?
d773 1
a773 1
	   $rate >= 1 ?
d775 1
a775 1
	   $rate >= 0.1 ?
d781 5
a785 5

	my $formatted_rate = sprintf( $format, $rate );
	push @@row, $formatted_rate;
	$col_widths[1] = length( $formatted_rate )
	    if length( $formatted_rate ) > $col_widths[1];
@


1.1.1.7
log
@perl 5.8.3 from CPAN
@
text
@d435 1
a435 1
$VERSION = 1.052;
d893 1
a893 1
    my $display_as_rate = @@vals ? ($vals[$#vals>>1]->[7] > 1) : 0;
@


1.1.1.8
log
@Import of stock perl 5.8.5
@
text
@a414 3
February, 2004; by Chia-liang Kao: make cmpthese and timestr use time
statistics for children instead of parent when the style is 'nop'.

d435 1
a435 1
$VERSION = 1.06;
d597 1
a597 2
    $s .= sprintf(" @@ %$f/s (n=$n)", $n / ( $style eq 'nop' ? $cu + $cs : $pu + $ps ))
	if $n && ($style eq 'nop' ? $cu+$cs : $pu+$ps);
d885 1
a885 2
	my $rate = $_->[6] / (( $style eq 'nop' ? $_->[4] + $_->[5]
						: $_->[2] + $_->[3]) + 0.000000000000001 );
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d438 1
a438 1
$VERSION = 1.07;
d651 1
a651 1
    $subref->();
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d164 1
a164 1
Returns a hash reference of Benchmark objects, keyed by name.
a227 2
If the first argument is an unblessed hash reference,
that is RESULTSHASHREF; otherwise that is COUNT.
a417 3
November, 2007; by Christophe Grosjean: make cmpthese and timestr compute
time consistently with style argument, default is 'all' not 'noc' any more.

d438 1
a438 1
$VERSION = 1.10;
a458 1
	local $^W=0;
a553 2
    #die "Bad timediff(): ($r[1] + $r[2]) <= 0 (@@$a[1,2]|@@$b[1,2])\n"
    #        if ($r[1] + $r[2]) < 0;
d594 1
a594 1
    $s = sprintf("$w wallclock secs (%$f usr %$f sys + %$f cusr %$f csys = %$f CPU)",
d596 1
a596 1
    $s = sprintf("$w wallclock secs (%$f usr + %$f sys = %$f CPU)",
d598 1
a598 1
    $s = sprintf("$w wallclock secs (%$f cusr + %$f csys = %$f CPU)",
d600 2
a601 6
    my $elapsed = do {
	if ($style eq 'nop') {$cu+$cs}
	elsif ($style eq 'noc') {$pu+$ps}
	else {$cu+$cs+$pu+$ps}
    };
    $s .= sprintf(" @@ %$f/s (n=$n)",$n/($elapsed)) if $n && $elapsed;
a718 1
    my $zeros=0;
a721 6
	if ( $tc <= 0 and $n > 1024 ) {
	    ++$zeros > 16
	        and die "Timing is consistently zero in estimation loop, cannot benchmark. N=$n\n";
	} else {
	    $zeros = 0;
	}
d755 1
a755 1
    $zeros=0;
d766 1
a766 6
	if ( $ttot <= 0 ) {
	    ++$zeros > 16
	        and die "Timing is consistently zero, cannot benchmark. N=$n\n";
	} else {
	    $zeros = 0;
	}
d869 1
a869 2
    # $count can be a blessed object.
    if ( ref $_[0] eq 'HASH' ) {
d889 2
a890 6
	my $elapsed = do {
	    if ($style eq 'nop') {$_->[4]+$_->[5]}
	    elsif ($style eq 'noc') {$_->[2]+$_->[3]}
	    else {$_->[2]+$_->[3]+$_->[4]+$_->[5]}
	};
	my $rate = $_->[6]/(($elapsed)+0.000000000000001);
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d84 1
a84 1
    $t0 = Benchmark->new;
d86 1
a86 1
    $t1 = Benchmark->new;
d94 1
a94 1
    Benchmark->debug(1);
d96 1
a96 1
    Benchmark->debug(0);
d222 1
a222 1
C<cmpthese> can also be passed the data structure that timethese() returns:
d443 1
a443 1
$VERSION = 1.11;
@


1.1.1.12
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d248 1
a248 1
Incidentally, note the variance in the result values between the two examples;
d321 1
a321 1
accuracy and does not usually noticeably affect runtimes.
d388 1
a388 1
L<Devel::NYTProf> - a Perl code profiler
d443 1
a443 1
$VERSION = 1.13;
d752 1
a752 1
	# accuracy since we're not counting these times.
@


1.1.1.13
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@d443 1
a443 1
$VERSION = 1.15;
@


1.1.1.14
log
@Import perl-5.20.1
@
text
@d40 1
a40 1
    $results = timethese($count,
d224 1
a224 2
    $results = timethese( -1,
        { a => "++\$i", b => "\$i *= 2" } ) ;
d234 1
a234 2
    my $rows = cmpthese( -1,
        { a => '++$i', b => '$i *= 2' }, "none" );
a292 40
=head1 Benchmark Object

Many of the functions in this module return a Benchmark object,
or in the case of C<timethese()>, a reference to a hash, the values of
which are Benchmark objects.  This is useful if you want to store or
further process results from Benchmark functions.

Internally the Benchmark object holds timing values,
described in L</"NOTES"> below.
The following methods can be used to access them:

=over 4

=item cpu_p

Total CPU (User + System) of the main (parent) process.

=item cpu_c

Total CPU (User + System) of any children processes.

=item cpu_a

Total CPU of parent and any children processes.

=item real

Real elapsed time "wallclock seconds".

=item iters

Number of iterations run.

=back

The following illustrates use of the Benchmark object:

    $result = timethis(100000, sub { ... });
    print "total CPU = ", $result->cpu_a, "\n";

d342 1
a342 1
while
d405 2
a406 2
September, 1999; by Barrie Slaymaker: math fixes and accuracy and
efficiency tweaks.  Added cmpthese().  A result is now returned from
d443 1
a443 1
$VERSION = 1.18;
d488 1
a488 1
sub usage {
d501 1
a501 1
sub clearcache    {
d503 1
a503 1
    delete $Cache{"$_[0]c"}; delete $Cache{"$_[0]s"};
d510 1
a510 1
sub clearallcache {
d512 1
a512 1
    %Cache = ();
d521 1
a521 1
    $Do_Cache = 1;
d530 1
a530 1
    $Do_Cache = 0;
d655 1
a655 1
    # Wait for the user timer to tick.  This makes the error range more like
a732 1
	my $t0 = Benchmark->new(0);
a733 1
	my $t1 = Benchmark->new(0);
d736 2
a737 12
	    my $d = timediff($t1, $t0);
	    # note that $d is the total CPU time taken to call timeit(),
	    # while $tc is is difference in CPU secs between the empty run
	    # and the code run. If the code is trivial, its possible
	    # for $d to get large while $tc is still zero (or slightly
	    # negative). Bail out once timeit() starts taking more than a
	    # few seconds without noticeable difference.
	    if ($d->[1] + $d->[2] > 8
		|| ++$zeros > 16)
	    {
	        die "Timing is consistently zero in estimation loop, cannot benchmark. N=$n\n";
            }
d751 1
a751 1
	# and we guess a little low).  This does not noticeably affect
d932 4
a935 4
    my @@top_row = (
        '',
	$display_as_rate ? 'Rate' : 's/iter',
	map { $_->[0] } @@vals
d961 3
a963 3
	my $format =
	   $rate >= 100 ?
	       "%0.0f" :
d1000 1
a1000 1
	    # A little weirdness to set the first column width properly
d1011 1
a1011 1
    my @@sorted_width_refs =
d1024 1
a1024 1
	    last
@


