head	1.14;
access;
symbols
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.8
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.6
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.4
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.14
date	2010.09.24.14.59.32;	author millert;	state dead;
branches;
next	1.13;

1.13
date	2009.10.12.18.24.37;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.03.24.16.38.39;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.04;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.09.18.09.28;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.04;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.35;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.07.23.01.42.49;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.05.24.18.35.22;	author millert;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2000.04.06.17.06.00;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.41;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.56.38;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.39;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.33;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.15;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.57;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.13;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.46.37;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.07;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.32;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.28;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.50;	author millert;	state Exp;
branches;
next	;

1.4.6.1
date	2003.08.19.18.19.12;	author brad;	state Exp;
branches;
next	;

1.5.2.1
date	2003.08.19.18.22.53;	author brad;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.14
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package CGI;
require 5.004;
use Carp 'croak';

# See the bottom of this file for the POD documentation.  Search for the
# string '=head'.

# You can run this file through either pod2man or pod2html to produce pretty
# documentation in manual or html file format (these utilities are part of the
# Perl 5 distribution).

# Copyright 1995-1998 Lincoln D. Stein.  All rights reserved.
# It may be used and modified freely, but I do request that this copyright
# notice remain attached to the file.  You may modify this module as you 
# wish, but if you redistribute a modified version, please attach a note
# listing the modifications you have made.

# The most recent version and complete docs are available at:
#   http://stein.cshl.org/WWW/software/CGI/

$CGI::revision = '$Id: CGI.pm,v 1.13 2009/10/12 18:24:37 millert Exp $';
$CGI::VERSION='3.43';

# HARD-CODED LOCATION FOR FILE UPLOAD TEMPORARY FILES.
# UNCOMMENT THIS ONLY IF YOU KNOW WHAT YOU'RE DOING.
# $CGITempFile::TMPDIRECTORY = '/usr/tmp';
use CGI::Util qw(rearrange rearrange_header make_attributes unescape escape expires ebcdic2ascii ascii2ebcdic);

#use constant XHTML_DTD => ['-//W3C//DTD XHTML Basic 1.0//EN',
#                           'http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd'];

use constant XHTML_DTD => ['-//W3C//DTD XHTML 1.0 Transitional//EN',
                           'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'];

{
  local $^W = 0;
  $TAINTED = substr("$0$^X",0,0);
}

$MOD_PERL            = 0; # no mod_perl by default

#global settings
$POST_MAX            = -1; # no limit to uploaded files
$DISABLE_UPLOADS     = 0;

@@SAVED_SYMBOLS = ();


# >>>>> Here are some globals that you might want to adjust <<<<<<
sub initialize_globals {
    # Set this to 1 to enable copious autoloader debugging messages
    $AUTOLOAD_DEBUG = 0;

    # Set this to 1 to generate XTML-compatible output
    $XHTML = 1;

    # Change this to the preferred DTD to print in start_html()
    # or use default_dtd('text of DTD to use');
    $DEFAULT_DTD = [ '-//W3C//DTD HTML 4.01 Transitional//EN',
		     'http://www.w3.org/TR/html4/loose.dtd' ] ;

    # Set this to 1 to enable NOSTICKY scripts
    # or: 
    #    1) use CGI qw(-nosticky)
    #    2) $CGI::nosticky(1)
    $NOSTICKY = 0;

    # Set this to 1 to enable NPH scripts
    # or: 
    #    1) use CGI qw(-nph)
    #    2) CGI::nph(1)
    #    3) print header(-nph=>1)
    $NPH = 0;

    # Set this to 1 to enable debugging from @@ARGV
    # Set to 2 to enable debugging from STDIN
    $DEBUG = 1;

    # Set this to 1 to make the temporary files created
    # during file uploads safe from prying eyes
    # or do...
    #    1) use CGI qw(:private_tempfiles)
    #    2) CGI::private_tempfiles(1);
    $PRIVATE_TEMPFILES = 0;

    # Set this to 1 to generate automatic tab indexes
    $TABINDEX = 0;

    # Set this to 1 to cause files uploaded in multipart documents
    # to be closed, instead of caching the file handle
    # or:
    #    1) use CGI qw(:close_upload_files)
    #    2) $CGI::close_upload_files(1);
    # Uploads with many files run out of file handles.
    # Also, for performance, since the file is already on disk,
    # it can just be renamed, instead of read and written.
    $CLOSE_UPLOAD_FILES = 0;

    # Automatically determined -- don't change
    $EBCDIC = 0;

    # Change this to 1 to suppress redundant HTTP headers
    $HEADERS_ONCE = 0;

    # separate the name=value pairs by semicolons rather than ampersands
    $USE_PARAM_SEMICOLONS = 1;

    # Do not include undefined params parsed from query string
    # use CGI qw(-no_undef_params);
    $NO_UNDEF_PARAMS = 0;

    # return everything as utf-8
    $PARAM_UTF8      = 0;

    # Other globals that you shouldn't worry about.
    undef $Q;
    $BEEN_THERE = 0;
    $DTD_PUBLIC_IDENTIFIER = "";
    undef @@QUERY_PARAM;
    undef %EXPORT;
    undef $QUERY_CHARSET;
    undef %QUERY_FIELDNAMES;
    undef %QUERY_TMPFILES;

    # prevent complaints by mod_perl
    1;
}

# ------------------ START OF THE LIBRARY ------------

*end_form = \&endform;

# make mod_perlhappy
initialize_globals();

# FIGURE OUT THE OS WE'RE RUNNING UNDER
# Some systems support the $^O variable.  If not
# available then require() the Config library
unless ($OS) {
    unless ($OS = $^O) {
	require Config;
	$OS = $Config::Config{'osname'};
    }
}
if ($OS =~ /^MSWin/i) {
  $OS = 'WINDOWS';
} elsif ($OS =~ /^VMS/i) {
  $OS = 'VMS';
} elsif ($OS =~ /^dos/i) {
  $OS = 'DOS';
} elsif ($OS =~ /^MacOS/i) {
    $OS = 'MACINTOSH';
} elsif ($OS =~ /^os2/i) {
    $OS = 'OS2';
} elsif ($OS =~ /^epoc/i) {
    $OS = 'EPOC';
} elsif ($OS =~ /^cygwin/i) {
    $OS = 'CYGWIN';
} else {
    $OS = 'UNIX';
}

# Some OS logic.  Binary mode enabled on DOS, NT and VMS
$needs_binmode = $OS=~/^(WINDOWS|DOS|OS2|MSWin|CYGWIN)/;

# This is the default class for the CGI object to use when all else fails.
$DefaultClass = 'CGI' unless defined $CGI::DefaultClass;

# This is where to look for autoloaded routines.
$AutoloadClass = $DefaultClass unless defined $CGI::AutoloadClass;

# The path separator is a slash, backslash or semicolon, depending
# on the paltform.
$SL = {
     UNIX    => '/',  OS2 => '\\', EPOC      => '/', CYGWIN => '/',
     WINDOWS => '\\', DOS => '\\', MACINTOSH => ':', VMS    => '/'
    }->{$OS};

# This no longer seems to be necessary
# Turn on NPH scripts by default when running under IIS server!
# $NPH++ if defined($ENV{'SERVER_SOFTWARE'}) && $ENV{'SERVER_SOFTWARE'}=~/IIS/;
$IIS++ if defined($ENV{'SERVER_SOFTWARE'}) && $ENV{'SERVER_SOFTWARE'}=~/IIS/;

# Turn on special checking for Doug MacEachern's modperl
if (exists $ENV{MOD_PERL}) {
  # mod_perl handlers may run system() on scripts using CGI.pm;
  # Make sure so we don't get fooled by inherited $ENV{MOD_PERL}
  if (exists $ENV{MOD_PERL_API_VERSION} && $ENV{MOD_PERL_API_VERSION} == 2) {
    $MOD_PERL = 2;
    require Apache2::Response;
    require Apache2::RequestRec;
    require Apache2::RequestUtil;
    require Apache2::RequestIO;
    require APR::Pool;
  } else {
    $MOD_PERL = 1;
    require Apache;
  }
}

# Turn on special checking for ActiveState's PerlEx
$PERLEX++ if defined($ENV{'GATEWAY_INTERFACE'}) && $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-PerlEx/;

# Define the CRLF sequence.  I can't use a simple "\r\n" because the meaning
# of "\n" is different on different OS's (sometimes it generates CRLF, sometimes LF
# and sometimes CR).  The most popular VMS web server
# doesn't accept CRLF -- instead it wants a LR.  EBCDIC machines don't
# use ASCII, so \015\012 means something different.  I find this all 
# really annoying.
$EBCDIC = "\t" ne "\011";
if ($OS eq 'VMS') {
  $CRLF = "\n";
} elsif ($EBCDIC) {
  $CRLF= "\r\n";
} else {
  $CRLF = "\015\012";
}

if ($needs_binmode) {
    $CGI::DefaultClass->binmode(\*main::STDOUT);
    $CGI::DefaultClass->binmode(\*main::STDIN);
    $CGI::DefaultClass->binmode(\*main::STDERR);
}

%EXPORT_TAGS = (
		':html2'=>['h1'..'h6',qw/p br hr ol ul li dl dt dd menu code var strong em
			   tt u i b blockquote pre img a address cite samp dfn html head
			   base body Link nextid title meta kbd start_html end_html
			   input Select option comment charset escapeHTML/],
		':html3'=>[qw/div table caption th td TR Tr sup Sub strike applet Param nobr
			   embed basefont style span layer ilayer font frameset frame script small big Area Map/],
                ':html4'=>[qw/abbr acronym bdo col colgroup del fieldset iframe
                            ins label legend noframes noscript object optgroup Q 
                            thead tbody tfoot/], 
		':netscape'=>[qw/blink fontsize center/],
		':form'=>[qw/textfield textarea filefield password_field hidden checkbox checkbox_group 
			  submit reset defaults radio_group popup_menu button autoEscape
			  scrolling_list image_button start_form end_form startform endform
			  start_multipart_form end_multipart_form isindex tmpFileName uploadInfo URL_ENCODED MULTIPART/],
		':cgi'=>[qw/param upload path_info path_translated request_uri url self_url script_name 
			 cookie Dump
			 raw_cookie request_method query_string Accept user_agent remote_host content_type
			 remote_addr referer server_name server_software server_port server_protocol virtual_port
			 virtual_host remote_ident auth_type http append
			 save_parameters restore_parameters param_fetch
			 remote_user user_name header redirect import_names put 
			 Delete Delete_all url_param cgi_error/],
		':ssl' => [qw/https/],
		':cgi-lib' => [qw/ReadParse PrintHeader HtmlTop HtmlBot SplitParam Vars/],
		':html' => [qw/:html2 :html3 :html4 :netscape/],
		':standard' => [qw/:html2 :html3 :html4 :form :cgi/],
		':push' => [qw/multipart_init multipart_start multipart_end multipart_final/],
		':all' => [qw/:html2 :html3 :netscape :form :cgi :internal :html4/]
		);

# Custom 'can' method for both autoloaded and non-autoloaded subroutines.
# Author: Cees Hek <cees@@sitesuite.com.au>

sub can {
	my($class, $method) = @@_;

	# See if UNIVERSAL::can finds it.

	if (my $func = $class -> SUPER::can($method) ){
		return $func;
	}

	# Try to compile the function.

	eval {
		# _compile looks at $AUTOLOAD for the function name.

		local $AUTOLOAD = join "::", $class, $method;
		&_compile;
	};

	# Now that the function is loaded (if it exists)
	# just use UNIVERSAL::can again to do the work.

	return $class -> SUPER::can($method);
}

# to import symbols into caller
sub import {
    my $self = shift;

    # This causes modules to clash.
    undef %EXPORT_OK;
    undef %EXPORT;

    $self->_setup_symbols(@@_);
    my ($callpack, $callfile, $callline) = caller;

    # To allow overriding, search through the packages
    # Till we find one in which the correct subroutine is defined.
    my @@packages = ($self,@@{"$self\:\:ISA"});
    for $sym (keys %EXPORT) {
	my $pck;
	my $def = ${"$self\:\:AutoloadClass"} || $DefaultClass;
	for $pck (@@packages) {
	    if (defined(&{"$pck\:\:$sym"})) {
		$def = $pck;
		last;
	    }
	}
	*{"${callpack}::$sym"} = \&{"$def\:\:$sym"};
    }
}

sub compile {
    my $pack = shift;
    $pack->_setup_symbols('-compile',@@_);
}

sub expand_tags {
    my($tag) = @@_;
    return ("start_$1","end_$1") if $tag=~/^(?:\*|start_|end_)(.+)/;
    my(@@r);
    return ($tag) unless $EXPORT_TAGS{$tag};
    for (@@{$EXPORT_TAGS{$tag}}) {
	push(@@r,&expand_tags($_));
    }
    return @@r;
}

#### Method: new
# The new routine.  This will check the current environment
# for an existing query string, and initialize itself, if so.
####
sub new {
  my($class,@@initializer) = @@_;
  my $self = {};

  bless $self,ref $class || $class || $DefaultClass;

  # always use a tempfile
  $self->{'use_tempfile'} = 1;

  if (ref($initializer[0])
      && (UNIVERSAL::isa($initializer[0],'Apache')
	  ||
	  UNIVERSAL::isa($initializer[0],'Apache2::RequestRec')
	 )) {
    $self->r(shift @@initializer);
  }
 if (ref($initializer[0]) 
     && (UNIVERSAL::isa($initializer[0],'CODE'))) {
    $self->upload_hook(shift @@initializer, shift @@initializer);
    $self->{'use_tempfile'} = shift @@initializer if (@@initializer > 0);
  }
  if ($MOD_PERL) {
    if ($MOD_PERL == 1) {
      $self->r(Apache->request) unless $self->r;
      my $r = $self->r;
      $r->register_cleanup(\&CGI::_reset_globals);
      $self->_setup_symbols(@@SAVED_SYMBOLS) if @@SAVED_SYMBOLS;
    }
    else {
      # XXX: once we have the new API
      # will do a real PerlOptions -SetupEnv check
      $self->r(Apache2::RequestUtil->request) unless $self->r;
      my $r = $self->r;
      $r->subprocess_env unless exists $ENV{REQUEST_METHOD};
      $r->pool->cleanup_register(\&CGI::_reset_globals);
      $self->_setup_symbols(@@SAVED_SYMBOLS) if @@SAVED_SYMBOLS;
    }
    undef $NPH;
  }
  $self->_reset_globals if $PERLEX;
  $self->init(@@initializer);
  return $self;
}

# We provide a DESTROY method so that we can ensure that
# temporary files are closed (via Fh->DESTROY) before they
# are unlinked (via CGITempFile->DESTROY) because it is not
# possible to unlink an open file on Win32. We explicitly
# call DESTROY on each, rather than just undefing them and
# letting Perl DESTROY them by garbage collection, in case the
# user is still holding any reference to them as well.
sub DESTROY {
  my $self = shift;
  if ($OS eq 'WINDOWS') {
    for my $href (values %{$self->{'.tmpfiles'}}) {
      $href->{hndl}->DESTROY if defined $href->{hndl};
      $href->{name}->DESTROY if defined $href->{name};
    }
  }
}

sub r {
  my $self = shift;
  my $r = $self->{'.r'};
  $self->{'.r'} = shift if @@_;
  $r;
}

sub upload_hook {
  my $self;
  if (ref $_[0] eq 'CODE') {
    $CGI::Q = $self = $CGI::DefaultClass->new(@@_);
  } else {
    $self = shift;
  }
  my ($hook,$data,$use_tempfile) = @@_;
  $self->{'.upload_hook'} = $hook;
  $self->{'.upload_data'} = $data;
  $self->{'use_tempfile'} = $use_tempfile if defined $use_tempfile;
}

#### Method: param
# Returns the value(s)of a named parameter.
# If invoked in a list context, returns the
# entire list.  Otherwise returns the first
# member of the list.
# If name is not provided, return a list of all
# the known parameters names available.
# If more than one argument is provided, the
# second and subsequent arguments are used to
# set the value of the parameter.
####
sub param {
    my($self,@@p) = self_or_default(@@_);
    return $self->all_parameters unless @@p;
    my($name,$value,@@other);

    # For compatibility between old calling style and use_named_parameters() style, 
    # we have to special case for a single parameter present.
    if (@@p > 1) {
	($name,$value,@@other) = rearrange([NAME,[DEFAULT,VALUE,VALUES]],@@p);
	my(@@values);

	if (substr($p[0],0,1) eq '-') {
	    @@values = defined($value) ? (ref($value) && ref($value) eq 'ARRAY' ? @@{$value} : $value) : ();
	} else {
	    for ($value,@@other) {
		push(@@values,$_) if defined($_);
	    }
	}
	# If values is provided, then we set it.
	if (@@values or defined $value) {
	    $self->add_parameter($name);
	    $self->{param}{$name}=[@@values];
	}
    } else {
	$name = $p[0];
    }

    return unless defined($name) && $self->{param}{$name};

    my @@result = @@{$self->{param}{$name}};

    if ($PARAM_UTF8) {
      eval "require Encode; 1;" unless Encode->can('decode'); # bring in these functions
      @@result = map {ref $_ ? $_ : Encode::decode(utf8=>$_) } @@result;
    }

    return wantarray ?  @@result : $result[0];
}

sub self_or_default {
    return @@_ if defined($_[0]) && (!ref($_[0])) &&($_[0] eq 'CGI');
    unless (defined($_[0]) && 
	    (ref($_[0]) eq 'CGI' || UNIVERSAL::isa($_[0],'CGI')) # slightly optimized for common case
	    ) {
	$Q = $CGI::DefaultClass->new unless defined($Q);
	unshift(@@_,$Q);
    }
    return wantarray ? @@_ : $Q;
}

sub self_or_CGI {
    local $^W=0;                # prevent a warning
    if (defined($_[0]) &&
	(substr(ref($_[0]),0,3) eq 'CGI' 
	 || UNIVERSAL::isa($_[0],'CGI'))) {
	return @@_;
    } else {
	return ($DefaultClass,@@_);
    }
}

########################################
# THESE METHODS ARE MORE OR LESS PRIVATE
# GO TO THE __DATA__ SECTION TO SEE MORE
# PUBLIC METHODS
########################################

# Initialize the query object from the environment.
# If a parameter list is found, this object will be set
# to a hash in which parameter names are keys
# and the values are stored as lists
# If a keyword list is found, this method creates a bogus
# parameter list with the single parameter 'keywords'.

sub init {
  my $self = shift;
  my($query_string,$meth,$content_length,$fh,@@lines) = ('','','','');

  my $is_xforms;

  my $initializer = shift;  # for backward compatibility
  local($/) = "\n";

    # set autoescaping on by default
    $self->{'escape'} = 1;

    # if we get called more than once, we want to initialize
    # ourselves from the original query (which may be gone
    # if it was read from STDIN originally.)
    if (defined(@@QUERY_PARAM) && !defined($initializer)) {
        for my $name (@@QUERY_PARAM) {
            my $val = $QUERY_PARAM{$name}; # always an arrayref;
            $self->param('-name'=>$name,'-value'=> $val);
            if (defined $val and ref $val eq 'ARRAY') {
                for my $fh (grep {defined(fileno($_))} @@$val) {
                   seek($fh,0,0); # reset the filehandle.  
                }

            }
        }
        $self->charset($QUERY_CHARSET);
        $self->{'.fieldnames'} = {%QUERY_FIELDNAMES};
        $self->{'.tmpfiles'}   = {%QUERY_TMPFILES};
        return;
    }

    $meth=$ENV{'REQUEST_METHOD'} if defined($ENV{'REQUEST_METHOD'});
    $content_length = defined($ENV{'CONTENT_LENGTH'}) ? $ENV{'CONTENT_LENGTH'} : 0;

    $fh = to_filehandle($initializer) if $initializer;

    # set charset to the safe ISO-8859-1
    $self->charset('ISO-8859-1');

  METHOD: {

      # avoid unreasonably large postings
      if (($POST_MAX > 0) && ($content_length > $POST_MAX)) {
	#discard the post, unread
	$self->cgi_error("413 Request entity too large");
	last METHOD;
      }

      # Process multipart postings, but only if the initializer is
      # not defined.
      if ($meth eq 'POST'
	  && defined($ENV{'CONTENT_TYPE'})
	  && $ENV{'CONTENT_TYPE'}=~m|^multipart/form-data|
	  && !defined($initializer)
	  ) {
	  my($boundary) = $ENV{'CONTENT_TYPE'} =~ /boundary=\"?([^\";,]+)\"?/;
	  $self->read_multipart($boundary,$content_length);
	  last METHOD;
      } 

      # Process XForms postings. We know that we have XForms in the
      # following cases:
      # method eq 'POST' && content-type eq 'application/xml'
      # method eq 'POST' && content-type =~ /multipart\/related.+start=/
      # There are more cases, actually, but for now, we don't support other
      # methods for XForm posts.
      # In a XForm POST, the QUERY_STRING is parsed normally.
      # If the content-type is 'application/xml', we just set the param
      # XForms:Model (referring to the xml syntax) param containing the
      # unparsed XML data.
      # In the case of multipart/related we set XForms:Model as above, but
      # the other parts are available as uploads with the Content-ID as the
      # the key.
      # See the URL below for XForms specs on this issue.
      # http://www.w3.org/TR/2006/REC-xforms-20060314/slice11.html#submit-options
      if ($meth eq 'POST' && defined($ENV{'CONTENT_TYPE'})) {
              if ($ENV{'CONTENT_TYPE'} eq 'application/xml') {
                      my($param) = 'XForms:Model';
                      my($value) = '';
                      $self->add_parameter($param);
                      $self->read_from_client(\$value,$content_length,0)
                        if $content_length > 0;
                      push (@@{$self->{param}{$param}},$value);
                      $is_xforms = 1;
              } elsif ($ENV{'CONTENT_TYPE'} =~ /multipart\/related.+boundary=\"?([^\";,]+)\"?.+start=\"?\<?([^\"\>]+)\>?\"?/) {
                      my($boundary,$start) = ($1,$2);
                      my($param) = 'XForms:Model';
                      $self->add_parameter($param);
                      my($value) = $self->read_multipart_related($start,$boundary,$content_length,0);
                      push (@@{$self->{param}{$param}},$value);
                      if ($MOD_PERL) {
                              $query_string = $self->r->args;
                      } else {
                              $query_string = $ENV{'QUERY_STRING'} if defined $ENV{'QUERY_STRING'};
                              $query_string ||= $ENV{'REDIRECT_QUERY_STRING'} if defined $ENV{'REDIRECT_QUERY_STRING'};
                      }
                      $is_xforms = 1;
              }
      }


      # If initializer is defined, then read parameters
      # from it.
      if (!$is_xforms && defined($initializer)) {
	  if (UNIVERSAL::isa($initializer,'CGI')) {
	      $query_string = $initializer->query_string;
	      last METHOD;
	  }
	  if (ref($initializer) && ref($initializer) eq 'HASH') {
	      for (keys %$initializer) {
		  $self->param('-name'=>$_,'-value'=>$initializer->{$_});
	      }
	      last METHOD;
	  }

          if (defined($fh) && ($fh ne '')) {
              while (<$fh>) {
                  chomp;
                  last if /^=/;
                  push(@@lines,$_);
              }
              # massage back into standard format
              if ("@@lines" =~ /=/) {
                  $query_string=join("&",@@lines);
              } else {
                  $query_string=join("+",@@lines);
              }
              last METHOD;
          }

	  # last chance -- treat it as a string
	  $initializer = $$initializer if ref($initializer) eq 'SCALAR';
	  $query_string = $initializer;

	  last METHOD;
      }

      # If method is GET or HEAD, fetch the query from
      # the environment.
      if ($is_xforms || $meth=~/^(GET|HEAD)$/) {
	  if ($MOD_PERL) {
	    $query_string = $self->r->args;
	  } else {
	      $query_string = $ENV{'QUERY_STRING'} if defined $ENV{'QUERY_STRING'};
	      $query_string ||= $ENV{'REDIRECT_QUERY_STRING'} if defined $ENV{'REDIRECT_QUERY_STRING'};
	  }
	  last METHOD;
      }

      if ($meth eq 'POST' || $meth eq 'PUT') {
	  $self->read_from_client(\$query_string,$content_length,0)
	      if $content_length > 0;
	  # Some people want to have their cake and eat it too!
	  # Uncomment this line to have the contents of the query string
	  # APPENDED to the POST data.
	  # $query_string .= (length($query_string) ? '&' : '') . $ENV{'QUERY_STRING'} if defined $ENV{'QUERY_STRING'};
	  last METHOD;
      }

      # If $meth is not of GET, POST or HEAD, assume we're being debugged offline.
      # Check the command line and then the standard input for data.
      # We use the shellwords package in order to behave the way that
      # UN*X programmers expect.
      if ($DEBUG)
      {
          my $cmdline_ret = read_from_cmdline();
          $query_string = $cmdline_ret->{'query_string'};
          if (defined($cmdline_ret->{'subpath'}))
          {
              $self->path_info($cmdline_ret->{'subpath'});
          }
      }
  }

# YL: Begin Change for XML handler 10/19/2001
    if (!$is_xforms && ($meth eq 'POST' || $meth eq 'PUT')
        && defined($ENV{'CONTENT_TYPE'})
        && $ENV{'CONTENT_TYPE'} !~ m|^application/x-www-form-urlencoded|
	&& $ENV{'CONTENT_TYPE'} !~ m|^multipart/form-data| ) {
        my($param) = $meth . 'DATA' ;
        $self->add_parameter($param) ;
      push (@@{$self->{param}{$param}},$query_string);
      undef $query_string ;
    }
# YL: End Change for XML handler 10/19/2001

    # We now have the query string in hand.  We do slightly
    # different things for keyword lists and parameter lists.
    if (defined $query_string && length $query_string) {
	if ($query_string =~ /[&=;]/) {
	    $self->parse_params($query_string);
	} else {
	    $self->add_parameter('keywords');
	    $self->{param}{'keywords'} = [$self->parse_keywordlist($query_string)];
	}
    }

    # Special case.  Erase everything if there is a field named
    # .defaults.
    if ($self->param('.defaults')) {
      $self->delete_all();
    }

    # hash containing our defined fieldnames
    $self->{'.fieldnames'} = {};
    for ($self->param('.cgifields')) {
	$self->{'.fieldnames'}->{$_}++;
    }
    
    # Clear out our default submission button flag if present
    $self->delete('.submit');
    $self->delete('.cgifields');

    $self->save_request unless defined $initializer;
}

# FUNCTIONS TO OVERRIDE:
# Turn a string into a filehandle
sub to_filehandle {
    my $thingy = shift;
    return undef unless $thingy;
    return $thingy if UNIVERSAL::isa($thingy,'GLOB');
    return $thingy if UNIVERSAL::isa($thingy,'FileHandle');
    if (!ref($thingy)) {
	my $caller = 1;
	while (my $package = caller($caller++)) {
	    my($tmp) = $thingy=~/[\':]/ ? $thingy : "$package\:\:$thingy"; 
	    return $tmp if defined(fileno($tmp));
	}
    }
    return undef;
}

# send output to the browser
sub put {
    my($self,@@p) = self_or_default(@@_);
    $self->print(@@p);
}

# print to standard output (for overriding in mod_perl)
sub print {
    shift;
    CORE::print(@@_);
}

# get/set last cgi_error
sub cgi_error {
    my ($self,$err) = self_or_default(@@_);
    $self->{'.cgi_error'} = $err if defined $err;
    return $self->{'.cgi_error'};
}

sub save_request {
    my($self) = @@_;
    # We're going to play with the package globals now so that if we get called
    # again, we initialize ourselves in exactly the same way.  This allows
    # us to have several of these objects.
    @@QUERY_PARAM = $self->param; # save list of parameters
    for (@@QUERY_PARAM) {
      next unless defined $_;
      $QUERY_PARAM{$_}=$self->{param}{$_};
    }
    $QUERY_CHARSET = $self->charset;
    %QUERY_FIELDNAMES = %{$self->{'.fieldnames'}};
    %QUERY_TMPFILES   = %{ $self->{'.tmpfiles'} || {} };
}

sub parse_params {
    my($self,$tosplit) = @@_;
    my(@@pairs) = split(/[&;]/,$tosplit);
    my($param,$value);
    for (@@pairs) {
	($param,$value) = split('=',$_,2);
	next unless defined $param;
	next if $NO_UNDEF_PARAMS and not defined $value;
	$value = '' unless defined $value;
	$param = unescape($param);
	$value = unescape($value);
	$self->add_parameter($param);
	push (@@{$self->{param}{$param}},$value);
    }
}

sub add_parameter {
    my($self,$param)=@@_;
    return unless defined $param;
    push (@@{$self->{'.parameters'}},$param) 
	unless defined($self->{param}{$param});
}

sub all_parameters {
    my $self = shift;
    return () unless defined($self) && $self->{'.parameters'};
    return () unless @@{$self->{'.parameters'}};
    return @@{$self->{'.parameters'}};
}

# put a filehandle into binary mode (DOS)
sub binmode {
    return unless defined($_[1]) && defined fileno($_[1]);
    CORE::binmode($_[1]);
}

sub _make_tag_func {
    my ($self,$tagname) = @@_;
    my $func = qq(
	sub $tagname {
         my (\$q,\$a,\@@rest) = self_or_default(\@@_);
         my(\$attr) = '';
	 if (ref(\$a) && ref(\$a) eq 'HASH') {
	    my(\@@attr) = make_attributes(\$a,\$q->{'escape'});
	    \$attr = " \@@attr" if \@@attr;
	  } else {
	    unshift \@@rest,\$a if defined \$a;
	  }
	);
    if ($tagname=~/start_(\w+)/i) {
	$func .= qq! return "<\L$1\E\$attr>";} !;
    } elsif ($tagname=~/end_(\w+)/i) {
	$func .= qq! return "<\L/$1\E>"; } !;
    } else {
	$func .= qq#
	    return \$XHTML ? "\L<$tagname\E\$attr />" : "\L<$tagname\E\$attr>" unless \@@rest;
	    my(\$tag,\$untag) = ("\L<$tagname\E\$attr>","\L</$tagname>\E");
	    my \@@result = map { "\$tag\$_\$untag" } 
                              (ref(\$rest[0]) eq 'ARRAY') ? \@@{\$rest[0]} : "\@@rest";
	    return "\@@result";
            }#;
    }
return $func;
}

sub AUTOLOAD {
    print STDERR "CGI::AUTOLOAD for $AUTOLOAD\n" if $CGI::AUTOLOAD_DEBUG;
    my $func = &_compile;
    goto &$func;
}

sub _compile {
    my($func) = $AUTOLOAD;
    my($pack,$func_name);
    {
	local($1,$2); # this fixes an obscure variable suicide problem.
	$func=~/(.+)::([^:]+)$/;
	($pack,$func_name) = ($1,$2);
	$pack=~s/::SUPER$//;	# fix another obscure problem
	$pack = ${"$pack\:\:AutoloadClass"} || $CGI::DefaultClass
	    unless defined(${"$pack\:\:AUTOLOADED_ROUTINES"});

        my($sub) = \%{"$pack\:\:SUBS"};
        unless (%$sub) {
	   my($auto) = \${"$pack\:\:AUTOLOADED_ROUTINES"};
	   local ($@@,$!);
	   eval "package $pack; $$auto";
	   croak("$AUTOLOAD: $@@") if $@@;
           $$auto = '';  # Free the unneeded storage (but don't undef it!!!)
       }
       my($code) = $sub->{$func_name};

       $code = "sub $AUTOLOAD { }" if (!$code and $func_name eq 'DESTROY');
       if (!$code) {
	   (my $base = $func_name) =~ s/^(start_|end_)//i;
	   if ($EXPORT{':any'} || 
	       $EXPORT{'-any'} ||
	       $EXPORT{$base} || 
	       (%EXPORT_OK || grep(++$EXPORT_OK{$_},&expand_tags(':html')))
	           && $EXPORT_OK{$base}) {
	       $code = $CGI::DefaultClass->_make_tag_func($func_name);
	   }
       }
       croak("Undefined subroutine $AUTOLOAD\n") unless $code;
       local ($@@,$!);
       eval "package $pack; $code";
       if ($@@) {
	   $@@ =~ s/ at .*\n//;
	   croak("$AUTOLOAD: $@@");
       }
    }       
    CORE::delete($sub->{$func_name});  #free storage
    return "$pack\:\:$func_name";
}

sub _selected {
  my $self = shift;
  my $value = shift;
  return '' unless $value;
  return $XHTML ? qq(selected="selected" ) : qq(selected );
}

sub _checked {
  my $self = shift;
  my $value = shift;
  return '' unless $value;
  return $XHTML ? qq(checked="checked" ) : qq(checked );
}

sub _reset_globals { initialize_globals(); }

sub _setup_symbols {
    my $self = shift;
    my $compile = 0;

    # to avoid reexporting unwanted variables
    undef %EXPORT;

    for (@@_) {
	$HEADERS_ONCE++,         next if /^[:-]unique_headers$/;
	$NPH++,                  next if /^[:-]nph$/;
	$NOSTICKY++,             next if /^[:-]nosticky$/;
	$DEBUG=0,                next if /^[:-]no_?[Dd]ebug$/;
	$DEBUG=2,                next if /^[:-][Dd]ebug$/;
	$USE_PARAM_SEMICOLONS++, next if /^[:-]newstyle_urls$/;
	$PARAM_UTF8++,           next if /^[:-]utf8$/;
	$XHTML++,                next if /^[:-]xhtml$/;
	$XHTML=0,                next if /^[:-]no_?xhtml$/;
	$USE_PARAM_SEMICOLONS=0, next if /^[:-]oldstyle_urls$/;
	$PRIVATE_TEMPFILES++,    next if /^[:-]private_tempfiles$/;
	$TABINDEX++,             next if /^[:-]tabindex$/;
	$CLOSE_UPLOAD_FILES++,   next if /^[:-]close_upload_files$/;
	$EXPORT{$_}++,           next if /^[:-]any$/;
	$compile++,              next if /^[:-]compile$/;
	$NO_UNDEF_PARAMS++,      next if /^[:-]no_undef_params$/;
	
	# This is probably extremely evil code -- to be deleted some day.
	if (/^[-]autoload$/) {
	    my($pkg) = caller(1);
	    *{"${pkg}::AUTOLOAD"} = sub { 
		my($routine) = $AUTOLOAD;
		$routine =~ s/^.*::/CGI::/;
		&$routine;
	    };
	    next;
	}

	for (&expand_tags($_)) {
	    tr/a-zA-Z0-9_//cd;  # don't allow weird function names
	    $EXPORT{$_}++;
	}
    }
    _compile_all(keys %EXPORT) if $compile;
    @@SAVED_SYMBOLS = @@_;
}

sub charset {
  my ($self,$charset) = self_or_default(@@_);
  $self->{'.charset'} = $charset if defined $charset;
  $self->{'.charset'};
}

sub element_id {
  my ($self,$new_value) = self_or_default(@@_);
  $self->{'.elid'} = $new_value if defined $new_value;
  sprintf('%010d',$self->{'.elid'}++);
}

sub element_tab {
  my ($self,$new_value) = self_or_default(@@_);
  $self->{'.etab'} ||= 1;
  $self->{'.etab'} = $new_value if defined $new_value;
  my $tab = $self->{'.etab'}++;
  return '' unless $TABINDEX or defined $new_value;
  return qq(tabindex="$tab" );
}

###############################################################################
################# THESE FUNCTIONS ARE AUTOLOADED ON DEMAND ####################
###############################################################################
$AUTOLOADED_ROUTINES = '';      # get rid of -w warning
$AUTOLOADED_ROUTINES=<<'END_OF_AUTOLOAD';

%SUBS = (

'URL_ENCODED'=> <<'END_OF_FUNC',
sub URL_ENCODED { 'application/x-www-form-urlencoded'; }
END_OF_FUNC

'MULTIPART' => <<'END_OF_FUNC',
sub MULTIPART {  'multipart/form-data'; }
END_OF_FUNC

'SERVER_PUSH' => <<'END_OF_FUNC',
sub SERVER_PUSH { 'multipart/x-mixed-replace;boundary="' . shift() . '"'; }
END_OF_FUNC

'new_MultipartBuffer' => <<'END_OF_FUNC',
# Create a new multipart buffer
sub new_MultipartBuffer {
    my($self,$boundary,$length) = @@_;
    return MultipartBuffer->new($self,$boundary,$length);
}
END_OF_FUNC

'read_from_client' => <<'END_OF_FUNC',
# Read data from a file handle
sub read_from_client {
    my($self, $buff, $len, $offset) = @@_;
    local $^W=0;                # prevent a warning
    return $MOD_PERL
        ? $self->r->read($$buff, $len, $offset)
        : read(\*STDIN, $$buff, $len, $offset);
}
END_OF_FUNC

'delete' => <<'END_OF_FUNC',
#### Method: delete
# Deletes the named parameter entirely.
####
sub delete {
    my($self,@@p) = self_or_default(@@_);
    my(@@names) = rearrange([NAME],@@p);
    my @@to_delete = ref($names[0]) eq 'ARRAY' ? @@$names[0] : @@names;
    my %to_delete;
    for my $name (@@to_delete)
    {
        CORE::delete $self->{param}{$name};
        CORE::delete $self->{'.fieldnames'}->{$name};
        $to_delete{$name}++;
    }
    @@{$self->{'.parameters'}}=grep { !exists($to_delete{$_}) } $self->param();
    return;
}
END_OF_FUNC

#### Method: import_names
# Import all parameters into the given namespace.
# Assumes namespace 'Q' if not specified
####
'import_names' => <<'END_OF_FUNC',
sub import_names {
    my($self,$namespace,$delete) = self_or_default(@@_);
    $namespace = 'Q' unless defined($namespace);
    die "Can't import names into \"main\"\n" if \%{"${namespace}::"} == \%::;
    if ($delete || $MOD_PERL || exists $ENV{'FCGI_ROLE'}) {
	# can anyone find an easier way to do this?
	for (keys %{"${namespace}::"}) {
	    local *symbol = "${namespace}::${_}";
	    undef $symbol;
	    undef @@symbol;
	    undef %symbol;
	}
    }
    my($param,@@value,$var);
    for $param ($self->param) {
	# protect against silly names
	($var = $param)=~tr/a-zA-Z0-9_/_/c;
	$var =~ s/^(?=\d)/_/;
	local *symbol = "${namespace}::$var";
	@@value = $self->param($param);
	@@symbol = @@value;
	$symbol = $value[0];
    }
}
END_OF_FUNC

#### Method: keywords
# Keywords acts a bit differently.  Calling it in a list context
# returns the list of keywords.  
# Calling it in a scalar context gives you the size of the list.
####
'keywords' => <<'END_OF_FUNC',
sub keywords {
    my($self,@@values) = self_or_default(@@_);
    # If values is provided, then we set it.
    $self->{param}{'keywords'}=[@@values] if @@values;
    my(@@result) = defined($self->{param}{'keywords'}) ? @@{$self->{param}{'keywords'}} : ();
    @@result;
}
END_OF_FUNC

# These are some tie() interfaces for compatibility
# with Steve Brenner's cgi-lib.pl routines
'Vars' => <<'END_OF_FUNC',
sub Vars {
    my $q = shift;
    my %in;
    tie(%in,CGI,$q);
    return %in if wantarray;
    return \%in;
}
END_OF_FUNC

# These are some tie() interfaces for compatibility
# with Steve Brenner's cgi-lib.pl routines
'ReadParse' => <<'END_OF_FUNC',
sub ReadParse {
    local(*in);
    if (@@_) {
	*in = $_[0];
    } else {
	my $pkg = caller();
	*in=*{"${pkg}::in"};
    }
    tie(%in,CGI);
    return scalar(keys %in);
}
END_OF_FUNC

'PrintHeader' => <<'END_OF_FUNC',
sub PrintHeader {
    my($self) = self_or_default(@@_);
    return $self->header();
}
END_OF_FUNC

'HtmlTop' => <<'END_OF_FUNC',
sub HtmlTop {
    my($self,@@p) = self_or_default(@@_);
    return $self->start_html(@@p);
}
END_OF_FUNC

'HtmlBot' => <<'END_OF_FUNC',
sub HtmlBot {
    my($self,@@p) = self_or_default(@@_);
    return $self->end_html(@@p);
}
END_OF_FUNC

'SplitParam' => <<'END_OF_FUNC',
sub SplitParam {
    my ($param) = @@_;
    my (@@params) = split ("\0", $param);
    return (wantarray ? @@params : $params[0]);
}
END_OF_FUNC

'MethGet' => <<'END_OF_FUNC',
sub MethGet {
    return request_method() eq 'GET';
}
END_OF_FUNC

'MethPost' => <<'END_OF_FUNC',
sub MethPost {
    return request_method() eq 'POST';
}
END_OF_FUNC

'TIEHASH' => <<'END_OF_FUNC',
sub TIEHASH {
    my $class = shift;
    my $arg   = $_[0];
    if (ref($arg) && UNIVERSAL::isa($arg,'CGI')) {
       return $arg;
    }
    return $Q ||= $class->new(@@_);
}
END_OF_FUNC

'STORE' => <<'END_OF_FUNC',
sub STORE {
    my $self = shift;
    my $tag  = shift;
    my $vals = shift;
    my @@vals = index($vals,"\0")!=-1 ? split("\0",$vals) : $vals;
    $self->param(-name=>$tag,-value=>\@@vals);
}
END_OF_FUNC

'FETCH' => <<'END_OF_FUNC',
sub FETCH {
    return $_[0] if $_[1] eq 'CGI';
    return undef unless defined $_[0]->param($_[1]);
    return join("\0",$_[0]->param($_[1]));
}
END_OF_FUNC

'FIRSTKEY' => <<'END_OF_FUNC',
sub FIRSTKEY {
    $_[0]->{'.iterator'}=0;
    $_[0]->{'.parameters'}->[$_[0]->{'.iterator'}++];
}
END_OF_FUNC

'NEXTKEY' => <<'END_OF_FUNC',
sub NEXTKEY {
    $_[0]->{'.parameters'}->[$_[0]->{'.iterator'}++];
}
END_OF_FUNC

'EXISTS' => <<'END_OF_FUNC',
sub EXISTS {
    exists $_[0]->{param}{$_[1]};
}
END_OF_FUNC

'DELETE' => <<'END_OF_FUNC',
sub DELETE {
    $_[0]->delete($_[1]);
}
END_OF_FUNC

'CLEAR' => <<'END_OF_FUNC',
sub CLEAR {
    %{$_[0]}=();
}
####
END_OF_FUNC

####
# Append a new value to an existing query
####
'append' => <<'EOF',
sub append {
    my($self,@@p) = self_or_default(@@_);
    my($name,$value) = rearrange([NAME,[VALUE,VALUES]],@@p);
    my(@@values) = defined($value) ? (ref($value) ? @@{$value} : $value) : ();
    if (@@values) {
	$self->add_parameter($name);
	push(@@{$self->{param}{$name}},@@values);
    }
    return $self->param($name);
}
EOF

#### Method: delete_all
# Delete all parameters
####
'delete_all' => <<'EOF',
sub delete_all {
    my($self) = self_or_default(@@_);
    my @@param = $self->param();
    $self->delete(@@param);
}
EOF

'Delete' => <<'EOF',
sub Delete {
    my($self,@@p) = self_or_default(@@_);
    $self->delete(@@p);
}
EOF

'Delete_all' => <<'EOF',
sub Delete_all {
    my($self,@@p) = self_or_default(@@_);
    $self->delete_all(@@p);
}
EOF

#### Method: autoescape
# If you want to turn off the autoescaping features,
# call this method with undef as the argument
'autoEscape' => <<'END_OF_FUNC',
sub autoEscape {
    my($self,$escape) = self_or_default(@@_);
    my $d = $self->{'escape'};
    $self->{'escape'} = $escape;
    $d;
}
END_OF_FUNC


#### Method: version
# Return the current version
####
'version' => <<'END_OF_FUNC',
sub version {
    return $VERSION;
}
END_OF_FUNC

#### Method: url_param
# Return a parameter in the QUERY_STRING, regardless of
# whether this was a POST or a GET
####
'url_param' => <<'END_OF_FUNC',
sub url_param {
    my ($self,@@p) = self_or_default(@@_);
    my $name = shift(@@p);
    return undef unless exists($ENV{QUERY_STRING});
    unless (exists($self->{'.url_param'})) {
	$self->{'.url_param'}={}; # empty hash
	if ($ENV{QUERY_STRING} =~ /=/) {
	    my(@@pairs) = split(/[&;]/,$ENV{QUERY_STRING});
	    my($param,$value);
	    for (@@pairs) {
		($param,$value) = split('=',$_,2);
		$param = unescape($param);
		$value = unescape($value);
		push(@@{$self->{'.url_param'}->{$param}},$value);
	    }
	} else {
	    $self->{'.url_param'}->{'keywords'} = [$self->parse_keywordlist($ENV{QUERY_STRING})];
	}
    }
    return keys %{$self->{'.url_param'}} unless defined($name);
    return () unless $self->{'.url_param'}->{$name};
    return wantarray ? @@{$self->{'.url_param'}->{$name}}
                     : $self->{'.url_param'}->{$name}->[0];
}
END_OF_FUNC

#### Method: Dump
# Returns a string in which all the known parameter/value 
# pairs are represented as nested lists, mainly for the purposes 
# of debugging.
####
'Dump' => <<'END_OF_FUNC',
sub Dump {
    my($self) = self_or_default(@@_);
    my($param,$value,@@result);
    return '<ul></ul>' unless $self->param;
    push(@@result,"<ul>");
    for $param ($self->param) {
	my($name)=$self->escapeHTML($param);
	push(@@result,"<li><strong>$param</strong></li>");
	push(@@result,"<ul>");
	for $value ($self->param($param)) {
	    $value = $self->escapeHTML($value);
            $value =~ s/\n/<br \/>\n/g;
	    push(@@result,"<li>$value</li>");
	}
	push(@@result,"</ul>");
    }
    push(@@result,"</ul>");
    return join("\n",@@result);
}
END_OF_FUNC

#### Method as_string
#
# synonym for "dump"
####
'as_string' => <<'END_OF_FUNC',
sub as_string {
    &Dump(@@_);
}
END_OF_FUNC

#### Method: save
# Write values out to a filehandle in such a way that they can
# be reinitialized by the filehandle form of the new() method
####
'save' => <<'END_OF_FUNC',
sub save {
    my($self,$filehandle) = self_or_default(@@_);
    $filehandle = to_filehandle($filehandle);
    my($param);
    local($,) = '';  # set print field separator back to a sane value
    local($\) = '';  # set output line separator to a sane value
    for $param ($self->param) {
	my($escaped_param) = escape($param);
	my($value);
	for $value ($self->param($param)) {
	    print $filehandle "$escaped_param=",escape("$value"),"\n";
	}
    }
    for (keys %{$self->{'.fieldnames'}}) {
          print $filehandle ".cgifields=",escape("$_"),"\n";
    }
    print $filehandle "=\n";    # end of record
}
END_OF_FUNC


#### Method: save_parameters
# An alias for save() that is a better name for exportation.
# Only intended to be used with the function (non-OO) interface.
####
'save_parameters' => <<'END_OF_FUNC',
sub save_parameters {
    my $fh = shift;
    return save(to_filehandle($fh));
}
END_OF_FUNC

#### Method: restore_parameters
# A way to restore CGI parameters from an initializer.
# Only intended to be used with the function (non-OO) interface.
####
'restore_parameters' => <<'END_OF_FUNC',
sub restore_parameters {
    $Q = $CGI::DefaultClass->new(@@_);
}
END_OF_FUNC

#### Method: multipart_init
# Return a Content-Type: style header for server-push
# This has to be NPH on most web servers, and it is advisable to set $| = 1
#
# Many thanks to Ed Jordan <ed@@fidalgo.net> for this
# contribution, updated by Andrew Benham (adsb@@bigfoot.com)
####
'multipart_init' => <<'END_OF_FUNC',
sub multipart_init {
    my($self,@@p) = self_or_default(@@_);
    my($boundary,@@other) = rearrange_header([BOUNDARY],@@p);
    $boundary = $boundary || '------- =_aaaaaaaaaa0';
    $self->{'separator'} = "$CRLF--$boundary$CRLF";
    $self->{'final_separator'} = "$CRLF--$boundary--$CRLF";
    $type = SERVER_PUSH($boundary);
    return $self->header(
	-nph => 0,
	-type => $type,
	(map { split "=", $_, 2 } @@other),
    ) . "WARNING: YOUR BROWSER DOESN'T SUPPORT THIS SERVER-PUSH TECHNOLOGY." . $self->multipart_end;
}
END_OF_FUNC


#### Method: multipart_start
# Return a Content-Type: style header for server-push, start of section
#
# Many thanks to Ed Jordan <ed@@fidalgo.net> for this
# contribution, updated by Andrew Benham (adsb@@bigfoot.com)
####
'multipart_start' => <<'END_OF_FUNC',
sub multipart_start {
    my(@@header);
    my($self,@@p) = self_or_default(@@_);
    my($type,@@other) = rearrange([TYPE],@@p);
    $type = $type || 'text/html';
    push(@@header,"Content-Type: $type");

    # rearrange() was designed for the HTML portion, so we
    # need to fix it up a little.
    for (@@other) {
        # Don't use \s because of perl bug 21951
        next unless my($header,$value) = /([^ \r\n\t=]+)=\"?(.+?)\"?$/;
	($_ = $header) =~ s/^(\w)(.*)/$1 . lc ($2) . ': '.$self->unescapeHTML($value)/e;
    }
    push(@@header,@@other);
    my $header = join($CRLF,@@header)."${CRLF}${CRLF}";
    return $header;
}
END_OF_FUNC


#### Method: multipart_end
# Return a MIME boundary separator for server-push, end of section
#
# Many thanks to Ed Jordan <ed@@fidalgo.net> for this
# contribution
####
'multipart_end' => <<'END_OF_FUNC',
sub multipart_end {
    my($self,@@p) = self_or_default(@@_);
    return $self->{'separator'};
}
END_OF_FUNC


#### Method: multipart_final
# Return a MIME boundary separator for server-push, end of all sections
#
# Contributed by Andrew Benham (adsb@@bigfoot.com)
####
'multipart_final' => <<'END_OF_FUNC',
sub multipart_final {
    my($self,@@p) = self_or_default(@@_);
    return $self->{'final_separator'} . "WARNING: YOUR BROWSER DOESN'T SUPPORT THIS SERVER-PUSH TECHNOLOGY." . $CRLF;
}
END_OF_FUNC


#### Method: header
# Return a Content-Type: style header
#
####
'header' => <<'END_OF_FUNC',
sub header {
    my($self,@@p) = self_or_default(@@_);
    my(@@header);

    return "" if $self->{'.header_printed'}++ and $HEADERS_ONCE;

    my($type,$status,$cookie,$target,$expires,$nph,$charset,$attachment,$p3p,@@other) = 
	rearrange([['TYPE','CONTENT_TYPE','CONTENT-TYPE'],
			    'STATUS',['COOKIE','COOKIES'],'TARGET',
                            'EXPIRES','NPH','CHARSET',
                            'ATTACHMENT','P3P'],@@p);

    $nph     ||= $NPH;

    $type ||= 'text/html' unless defined($type);

    if (defined $charset) {
      $self->charset($charset);
    } else {
      $charset = $self->charset if $type =~ /^text\//;
    }
   $charset ||= '';

    # rearrange() was designed for the HTML portion, so we
    # need to fix it up a little.
    for (@@other) {
        # Don't use \s because of perl bug 21951
        next unless my($header,$value) = /([^ \r\n\t=]+)=\"?(.+?)\"?$/;
        ($_ = $header) =~ s/^(\w)(.*)/"\u$1\L$2" . ': '.$self->unescapeHTML($value)/e;
    }

    $type .= "; charset=$charset"
      if     $type ne ''
         and $type !~ /\bcharset\b/
         and defined $charset
         and $charset ne '';

    # Maybe future compatibility.  Maybe not.
    my $protocol = $ENV{SERVER_PROTOCOL} || 'HTTP/1.0';
    push(@@header,$protocol . ' ' . ($status || '200 OK')) if $nph;
    push(@@header,"Server: " . &server_software()) if $nph;

    push(@@header,"Status: $status") if $status;
    push(@@header,"Window-Target: $target") if $target;
    if ($p3p) {
       $p3p = join ' ',@@$p3p if ref($p3p) eq 'ARRAY';
       push(@@header,qq(P3P: policyref="/w3c/p3p.xml", CP="$p3p"));
    }
    # push all the cookies -- there may be several
    if ($cookie) {
	my(@@cookie) = ref($cookie) && ref($cookie) eq 'ARRAY' ? @@{$cookie} : $cookie;
	for (@@cookie) {
            my $cs = UNIVERSAL::isa($_,'CGI::Cookie') ? $_->as_string : $_;
	    push(@@header,"Set-Cookie: $cs") if $cs ne '';
	}
    }
    # if the user indicates an expiration time, then we need
    # both an Expires and a Date header (so that the browser is
    # uses OUR clock)
    push(@@header,"Expires: " . expires($expires,'http'))
	if $expires;
    push(@@header,"Date: " . expires(0,'http')) if $expires || $cookie || $nph;
    push(@@header,"Pragma: no-cache") if $self->cache();
    push(@@header,"Content-Disposition: attachment; filename=\"$attachment\"") if $attachment;
    push(@@header,map {ucfirst $_} @@other);
    push(@@header,"Content-Type: $type") if $type ne '';
    my $header = join($CRLF,@@header)."${CRLF}${CRLF}";
    if (($MOD_PERL >= 1) && !$nph) {
        $self->r->send_cgi_header($header);
        return '';
    }
    return $header;
}
END_OF_FUNC


#### Method: cache
# Control whether header() will produce the no-cache
# Pragma directive.
####
'cache' => <<'END_OF_FUNC',
sub cache {
    my($self,$new_value) = self_or_default(@@_);
    $new_value = '' unless $new_value;
    if ($new_value ne '') {
	$self->{'cache'} = $new_value;
    }
    return $self->{'cache'};
}
END_OF_FUNC


#### Method: redirect
# Return a Location: style header
#
####
'redirect' => <<'END_OF_FUNC',
sub redirect {
    my($self,@@p) = self_or_default(@@_);
    my($url,$target,$status,$cookie,$nph,@@other) = 
         rearrange([[LOCATION,URI,URL],TARGET,STATUS,['COOKIE','COOKIES'],NPH],@@p);
    $status = '302 Found' unless defined $status;
    $url ||= $self->self_url;
    my(@@o);
    for (@@other) { tr/\"//d; push(@@o,split("=",$_,2)); }
    unshift(@@o,
	 '-Status'  => $status,
	 '-Location'=> $url,
	 '-nph'     => $nph);
    unshift(@@o,'-Target'=>$target) if $target;
    unshift(@@o,'-Type'=>'');
    my @@unescaped;
    unshift(@@unescaped,'-Cookie'=>$cookie) if $cookie;
    return $self->header((map {$self->unescapeHTML($_)} @@o),@@unescaped);
}
END_OF_FUNC


#### Method: start_html
# Canned HTML header
#
# Parameters:
# $title -> (optional) The title for this HTML document (-title)
# $author -> (optional) e-mail address of the author (-author)
# $base -> (optional) if set to true, will enter the BASE address of this document
#          for resolving relative references (-base) 
# $xbase -> (optional) alternative base at some remote location (-xbase)
# $target -> (optional) target window to load all links into (-target)
# $script -> (option) Javascript code (-script)
# $no_script -> (option) Javascript <noscript> tag (-noscript)
# $meta -> (optional) Meta information tags
# $head -> (optional) any other elements you'd like to incorporate into the <head> tag
#           (a scalar or array ref)
# $style -> (optional) reference to an external style sheet
# @@other -> (optional) any other named parameters you'd like to incorporate into
#           the <body> tag.
####
'start_html' => <<'END_OF_FUNC',
sub start_html {
    my($self,@@p) = &self_or_default(@@_);
    my($title,$author,$base,$xbase,$script,$noscript,
        $target,$meta,$head,$style,$dtd,$lang,$encoding,$declare_xml,@@other) = 
	rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,
                   META,HEAD,STYLE,DTD,LANG,ENCODING,DECLARE_XML],@@p);

    $self->element_id(0);
    $self->element_tab(0);

    $encoding = lc($self->charset) unless defined $encoding;

    # Need to sort out the DTD before it's okay to call escapeHTML().
    my(@@result,$xml_dtd);
    if ($dtd) {
        if (defined(ref($dtd)) and (ref($dtd) eq 'ARRAY')) {
            $dtd = $DEFAULT_DTD unless $dtd->[0] =~ m|^-//|;
        } else {
            $dtd = $DEFAULT_DTD unless $dtd =~ m|^-//|;
        }
    } else {
        $dtd = $XHTML ? XHTML_DTD : $DEFAULT_DTD;
    }

    $xml_dtd++ if ref($dtd) eq 'ARRAY' && $dtd->[0] =~ /\bXHTML\b/i;
    $xml_dtd++ if ref($dtd) eq '' && $dtd =~ /\bXHTML\b/i;
    push @@result,qq(<?xml version="1.0" encoding="$encoding"?>) if $xml_dtd && $declare_xml;

    if (ref($dtd) && ref($dtd) eq 'ARRAY') {
        push(@@result,qq(<!DOCTYPE html\n\tPUBLIC "$dtd->[0]"\n\t "$dtd->[1]">));
	$DTD_PUBLIC_IDENTIFIER = $dtd->[0];
    } else {
        push(@@result,qq(<!DOCTYPE html\n\tPUBLIC "$dtd">));
	$DTD_PUBLIC_IDENTIFIER = $dtd;
    }

    # Now that we know whether we're using the HTML 3.2 DTD or not, it's okay to
    # call escapeHTML().  Strangely enough, the title needs to be escaped as
    # HTML while the author needs to be escaped as a URL.
    $title = $self->escapeHTML($title || 'Untitled Document');
    $author = $self->escape($author);

    if ($DTD_PUBLIC_IDENTIFIER =~ /[^X]HTML (2\.0|3\.2)/i) {
	$lang = "" unless defined $lang;
	$XHTML = 0;
    }
    else {
	$lang = 'en-US' unless defined $lang;
    }

    my $lang_bits = $lang ne '' ? qq( lang="$lang" xml:lang="$lang") : '';
    my $meta_bits = qq(<meta http-equiv="Content-Type" content="text/html; charset=$encoding" />) 
                    if $XHTML && $encoding && !$declare_xml;

    push(@@result,$XHTML ? qq(<html xmlns="http://www.w3.org/1999/xhtml"$lang_bits>\n<head>\n<title>$title</title>)
                        : ($lang ? qq(<html lang="$lang">) : "<html>")
	                  . "<head><title>$title</title>");
	if (defined $author) {
    push(@@result,$XHTML ? "<link rev=\"made\" href=\"mailto:$author\" />"
			: "<link rev=\"made\" href=\"mailto:$author\">");
	}

    if ($base || $xbase || $target) {
	my $href = $xbase || $self->url('-path'=>1);
	my $t = $target ? qq/ target="$target"/ : '';
	push(@@result,$XHTML ? qq(<base href="$href"$t />) : qq(<base href="$href"$t>));
    }

    if ($meta && ref($meta) && (ref($meta) eq 'HASH')) {
	for (keys %$meta) { push(@@result,$XHTML ? qq(<meta name="$_" content="$meta->{$_}" />) 
			: qq(<meta name="$_" content="$meta->{$_}">)); }
    }

    my $meta_bits_set = 0;
    if( $head ) {
        if( ref $head ) {
            push @@result, @@$head;
            $meta_bits_set = 1 if grep { /http-equiv=["']Content-Type/i }@@$head;
        }
        else {
            push @@result, $head;
            $meta_bits_set = 1 if $head =~ /http-equiv=["']Content-Type/i;
        }
    }

    # handle the infrequently-used -style and -script parameters
    push(@@result,$self->_style($style))   if defined $style;
    push(@@result,$self->_script($script)) if defined $script;
    push(@@result,$meta_bits)              if defined $meta_bits and !$meta_bits_set;

    # handle -noscript parameter
    push(@@result,<<END) if $noscript;
<noscript>
$noscript
</noscript>
END
    ;
    my($other) = @@other ? " @@other" : '';
    push(@@result,"</head>\n<body$other>\n");
    return join("\n",@@result);
}
END_OF_FUNC

### Method: _style
# internal method for generating a CSS style section
####
'_style' => <<'END_OF_FUNC',
sub _style {
    my ($self,$style) = @@_;
    my (@@result);

    my $type = 'text/css';
    my $rel  = 'stylesheet';


    my $cdata_start = $XHTML ? "\n<!--/* <![CDATA[ */" : "\n<!-- ";
    my $cdata_end   = $XHTML ? "\n/* ]]> */-->\n" : " -->\n";

    my @@s = ref($style) eq 'ARRAY' ? @@$style : $style;
    my $other = '';

    for my $s (@@s) {
      if (ref($s)) {
       my($src,$code,$verbatim,$stype,$alternate,$foo,@@other) =
           rearrange([qw(SRC CODE VERBATIM TYPE ALTERNATE FOO)],
                      ('-foo'=>'bar',
                       ref($s) eq 'ARRAY' ? @@$s : %$s));
       my $type = defined $stype ? $stype : 'text/css';
       my $rel  = $alternate ? 'alternate stylesheet' : 'stylesheet';
       $other = "@@other" if @@other;

       if (ref($src) eq "ARRAY") # Check to see if the $src variable is an array reference
       { # If it is, push a LINK tag for each one
           for $src (@@$src)
         {
           push(@@result,$XHTML ? qq(<link rel="$rel" type="$type" href="$src" $other/>)
                             : qq(<link rel="$rel" type="$type" href="$src"$other>)) if $src;
         }
       }
       else
       { # Otherwise, push the single -src, if it exists.
         push(@@result,$XHTML ? qq(<link rel="$rel" type="$type" href="$src" $other/>)
                             : qq(<link rel="$rel" type="$type" href="$src"$other>)
              ) if $src;
        }
     if ($verbatim) {
           my @@v = ref($verbatim) eq 'ARRAY' ? @@$verbatim : $verbatim;
           push(@@result, "<style type=\"text/css\">\n$_\n</style>") for @@v;
      }
      my @@c = ref($code) eq 'ARRAY' ? @@$code : $code if $code;
      push(@@result,style({'type'=>$type},"$cdata_start\n$_\n$cdata_end")) for @@c;

      } else {
           my $src = $s;
           push(@@result,$XHTML ? qq(<link rel="$rel" type="$type" href="$src" $other/>)
                               : qq(<link rel="$rel" type="$type" href="$src"$other>));
      }
    }
    @@result;
}
END_OF_FUNC

'_script' => <<'END_OF_FUNC',
sub _script {
    my ($self,$script) = @@_;
    my (@@result);

    my (@@scripts) = ref($script) eq 'ARRAY' ? @@$script : ($script);
    for $script (@@scripts) {
	my($src,$code,$language);
	if (ref($script)) { # script is a hash
	    ($src,$code,$type) =
		rearrange(['SRC','CODE',['LANGUAGE','TYPE']],
				 '-foo'=>'bar',	# a trick to allow the '-' to be omitted
				 ref($script) eq 'ARRAY' ? @@$script : %$script);
            $type ||= 'text/javascript';
            unless ($type =~ m!\w+/\w+!) {
                $type =~ s/[\d.]+$//;
                $type = "text/$type";
            }
	} else {
	    ($src,$code,$type) = ('',$script, 'text/javascript');
	}

    my $comment = '//';  # javascript by default
    $comment = '#' if $type=~/perl|tcl/i;
    $comment = "'" if $type=~/vbscript/i;

    my ($cdata_start,$cdata_end);
    if ($XHTML) {
       $cdata_start    = "$comment<![CDATA[\n";
       $cdata_end     .= "\n$comment]]>";
    } else {
       $cdata_start  =  "\n<!-- Hide script\n";
       $cdata_end    = $comment;
       $cdata_end   .= " End script hiding -->\n";
   }
     my(@@satts);
     push(@@satts,'src'=>$src) if $src;
     push(@@satts,'type'=>$type);
     $code = $cdata_start . $code . $cdata_end if defined $code;
     push(@@result,$self->script({@@satts},$code || ''));
    }
    @@result;
}
END_OF_FUNC

#### Method: end_html
# End an HTML document.
# Trivial method for completeness.  Just returns "</body>"
####
'end_html' => <<'END_OF_FUNC',
sub end_html {
    return "\n</body>\n</html>";
}
END_OF_FUNC


################################
# METHODS USED IN BUILDING FORMS
################################

#### Method: isindex
# Just prints out the isindex tag.
# Parameters:
#  $action -> optional URL of script to run
# Returns:
#   A string containing a <isindex> tag
'isindex' => <<'END_OF_FUNC',
sub isindex {
    my($self,@@p) = self_or_default(@@_);
    my($action,@@other) = rearrange([ACTION],@@p);
    $action = qq/ action="$action"/ if $action;
    my($other) = @@other ? " @@other" : '';
    return $XHTML ? "<isindex$action$other />" : "<isindex$action$other>";
}
END_OF_FUNC


#### Method: startform
# Start a form
# Parameters:
#   $method -> optional submission method to use (GET or POST)
#   $action -> optional URL of script to run
#   $enctype ->encoding to use (URL_ENCODED or MULTIPART)
'startform' => <<'END_OF_FUNC',
sub startform {
    my($self,@@p) = self_or_default(@@_);

    my($method,$action,$enctype,@@other) = 
	rearrange([METHOD,ACTION,ENCTYPE],@@p);

    $method  = $self->escapeHTML(lc($method || 'post'));
    $enctype = $self->escapeHTML($enctype || &URL_ENCODED);
    if (defined $action) {
       $action = $self->escapeHTML($action);
    }
    else {
       $action = $self->escapeHTML($self->request_uri || $self->self_url);
    }
    $action = qq(action="$action");
    my($other) = @@other ? " @@other" : '';
    $self->{'.parametersToAdd'}={};
    return qq/<form method="$method" $action enctype="$enctype"$other>\n/;
}
END_OF_FUNC


#### Method: start_form
# synonym for startform
'start_form' => <<'END_OF_FUNC',
sub start_form {
    $XHTML ? &start_multipart_form : &startform;
}
END_OF_FUNC

'end_multipart_form' => <<'END_OF_FUNC',
sub end_multipart_form {
    &endform;
}
END_OF_FUNC

#### Method: start_multipart_form
# synonym for startform
'start_multipart_form' => <<'END_OF_FUNC',
sub start_multipart_form {
    my($self,@@p) = self_or_default(@@_);
    if (defined($p[0]) && substr($p[0],0,1) eq '-') {
      return $self->startform(-enctype=>&MULTIPART,@@p);
    } else {
	my($method,$action,@@other) = 
	    rearrange([METHOD,ACTION],@@p);
	return $self->startform($method,$action,&MULTIPART,@@other);
    }
}
END_OF_FUNC


#### Method: endform
# End a form
'endform' => <<'END_OF_FUNC',
sub endform {
    my($self,@@p) = self_or_default(@@_);
    if ( $NOSTICKY ) {
    return wantarray ? ("</form>") : "\n</form>";
    } else {
      if (my @@fields = $self->get_fields) {
         return wantarray ? ("<div>",@@fields,"</div>","</form>")
                          : "<div>".(join '',@@fields)."</div>\n</form>";
      } else {
         return "</form>";
      }
    }
}
END_OF_FUNC


'_textfield' => <<'END_OF_FUNC',
sub _textfield {
    my($self,$tag,@@p) = self_or_default(@@_);
    my($name,$default,$size,$maxlength,$override,$tabindex,@@other) = 
	rearrange([NAME,[DEFAULT,VALUE,VALUES],SIZE,MAXLENGTH,[OVERRIDE,FORCE],TABINDEX],@@p);

    my $current = $override ? $default : 
	(defined($self->param($name)) ? $self->param($name) : $default);

    $current = defined($current) ? $self->escapeHTML($current,1) : '';
    $name = defined($name) ? $self->escapeHTML($name) : '';
    my($s) = defined($size) ? qq/ size="$size"/ : '';
    my($m) = defined($maxlength) ? qq/ maxlength="$maxlength"/ : '';
    my($other) = @@other ? " @@other" : '';
    # this entered at cristy's request to fix problems with file upload fields
    # and WebTV -- not sure it won't break stuff
    my($value) = $current ne '' ? qq(value="$current") : '';
    $tabindex = $self->element_tab($tabindex);
    return $XHTML ? qq(<input type="$tag" name="$name" $tabindex$value$s$m$other />) 
                  : qq(<input type="$tag" name="$name" $value$s$m$other>);
}
END_OF_FUNC

#### Method: textfield
# Parameters:
#   $name -> Name of the text field
#   $default -> Optional default value of the field if not
#                already defined.
#   $size ->  Optional width of field in characaters.
#   $maxlength -> Optional maximum number of characters.
# Returns:
#   A string containing a <input type="text"> field
#
'textfield' => <<'END_OF_FUNC',
sub textfield {
    my($self,@@p) = self_or_default(@@_);
    $self->_textfield('text',@@p);
}
END_OF_FUNC


#### Method: filefield
# Parameters:
#   $name -> Name of the file upload field
#   $size ->  Optional width of field in characaters.
#   $maxlength -> Optional maximum number of characters.
# Returns:
#   A string containing a <input type="file"> field
#
'filefield' => <<'END_OF_FUNC',
sub filefield {
    my($self,@@p) = self_or_default(@@_);
    $self->_textfield('file',@@p);
}
END_OF_FUNC


#### Method: password
# Create a "secret password" entry field
# Parameters:
#   $name -> Name of the field
#   $default -> Optional default value of the field if not
#                already defined.
#   $size ->  Optional width of field in characters.
#   $maxlength -> Optional maximum characters that can be entered.
# Returns:
#   A string containing a <input type="password"> field
#
'password_field' => <<'END_OF_FUNC',
sub password_field {
    my ($self,@@p) = self_or_default(@@_);
    $self->_textfield('password',@@p);
}
END_OF_FUNC

#### Method: textarea
# Parameters:
#   $name -> Name of the text field
#   $default -> Optional default value of the field if not
#                already defined.
#   $rows ->  Optional number of rows in text area
#   $columns -> Optional number of columns in text area
# Returns:
#   A string containing a <textarea></textarea> tag
#
'textarea' => <<'END_OF_FUNC',
sub textarea {
    my($self,@@p) = self_or_default(@@_);
    my($name,$default,$rows,$cols,$override,$tabindex,@@other) =
	rearrange([NAME,[DEFAULT,VALUE],ROWS,[COLS,COLUMNS],[OVERRIDE,FORCE],TABINDEX],@@p);

    my($current)= $override ? $default :
	(defined($self->param($name)) ? $self->param($name) : $default);

    $name = defined($name) ? $self->escapeHTML($name) : '';
    $current = defined($current) ? $self->escapeHTML($current) : '';
    my($r) = $rows ? qq/ rows="$rows"/ : '';
    my($c) = $cols ? qq/ cols="$cols"/ : '';
    my($other) = @@other ? " @@other" : '';
    $tabindex = $self->element_tab($tabindex);
    return qq{<textarea name="$name" $tabindex$r$c$other>$current</textarea>};
}
END_OF_FUNC


#### Method: button
# Create a javascript button.
# Parameters:
#   $name ->  (optional) Name for the button. (-name)
#   $value -> (optional) Value of the button when selected (and visible name) (-value)
#   $onclick -> (optional) Text of the JavaScript to run when the button is
#                clicked.
# Returns:
#   A string containing a <input type="button"> tag
####
'button' => <<'END_OF_FUNC',
sub button {
    my($self,@@p) = self_or_default(@@_);

    my($label,$value,$script,$tabindex,@@other) = rearrange([NAME,[VALUE,LABEL],
						            [ONCLICK,SCRIPT],TABINDEX],@@p);

    $label=$self->escapeHTML($label);
    $value=$self->escapeHTML($value,1);
    $script=$self->escapeHTML($script);

    my($name) = '';
    $name = qq/ name="$label"/ if $label;
    $value = $value || $label;
    my($val) = '';
    $val = qq/ value="$value"/ if $value;
    $script = qq/ onclick="$script"/ if $script;
    my($other) = @@other ? " @@other" : '';
    $tabindex = $self->element_tab($tabindex);
    return $XHTML ? qq(<input type="button" $tabindex$name$val$script$other />)
                  : qq(<input type="button"$name$val$script$other>);
}
END_OF_FUNC


#### Method: submit
# Create a "submit query" button.
# Parameters:
#   $name ->  (optional) Name for the button.
#   $value -> (optional) Value of the button when selected (also doubles as label).
#   $label -> (optional) Label printed on the button(also doubles as the value).
# Returns:
#   A string containing a <input type="submit"> tag
####
'submit' => <<'END_OF_FUNC',
sub submit {
    my($self,@@p) = self_or_default(@@_);

    my($label,$value,$tabindex,@@other) = rearrange([NAME,[VALUE,LABEL],TABINDEX],@@p);

    $label=$self->escapeHTML($label);
    $value=$self->escapeHTML($value,1);

    my $name = $NOSTICKY ? '' : 'name=".submit" ';
    $name = qq/name="$label" / if defined($label);
    $value = defined($value) ? $value : $label;
    my $val = '';
    $val = qq/value="$value" / if defined($value);
    $tabindex = $self->element_tab($tabindex);
    my($other) = @@other ? "@@other " : '';
    return $XHTML ? qq(<input type="submit" $tabindex$name$val$other/>)
                  : qq(<input type="submit" $name$val$other>);
}
END_OF_FUNC


#### Method: reset
# Create a "reset" button.
# Parameters:
#   $name -> (optional) Name for the button.
# Returns:
#   A string containing a <input type="reset"> tag
####
'reset' => <<'END_OF_FUNC',
sub reset {
    my($self,@@p) = self_or_default(@@_);
    my($label,$value,$tabindex,@@other) = rearrange(['NAME',['VALUE','LABEL'],TABINDEX],@@p);
    $label=$self->escapeHTML($label);
    $value=$self->escapeHTML($value,1);
    my ($name) = ' name=".reset"';
    $name = qq/ name="$label"/ if defined($label);
    $value = defined($value) ? $value : $label;
    my($val) = '';
    $val = qq/ value="$value"/ if defined($value);
    my($other) = @@other ? " @@other" : '';
    $tabindex = $self->element_tab($tabindex);
    return $XHTML ? qq(<input type="reset" $tabindex$name$val$other />)
                  : qq(<input type="reset"$name$val$other>);
}
END_OF_FUNC


#### Method: defaults
# Create a "defaults" button.
# Parameters:
#   $name -> (optional) Name for the button.
# Returns:
#   A string containing a <input type="submit" name=".defaults"> tag
#
# Note: this button has a special meaning to the initialization script,
# and tells it to ERASE the current query string so that your defaults
# are used again!
####
'defaults' => <<'END_OF_FUNC',
sub defaults {
    my($self,@@p) = self_or_default(@@_);

    my($label,$tabindex,@@other) = rearrange([[NAME,VALUE],TABINDEX],@@p);

    $label=$self->escapeHTML($label,1);
    $label = $label || "Defaults";
    my($value) = qq/ value="$label"/;
    my($other) = @@other ? " @@other" : '';
    $tabindex = $self->element_tab($tabindex);
    return $XHTML ? qq(<input type="submit" name=".defaults" $tabindex$value$other />)
                  : qq/<input type="submit" NAME=".defaults"$value$other>/;
}
END_OF_FUNC


#### Method: comment
# Create an HTML <!-- comment -->
# Parameters: a string
'comment' => <<'END_OF_FUNC',
sub comment {
    my($self,@@p) = self_or_CGI(@@_);
    return "<!-- @@p -->";
}
END_OF_FUNC

#### Method: checkbox
# Create a checkbox that is not logically linked to any others.
# The field value is "on" when the button is checked.
# Parameters:
#   $name -> Name of the checkbox
#   $checked -> (optional) turned on by default if true
#   $value -> (optional) value of the checkbox, 'on' by default
#   $label -> (optional) a user-readable label printed next to the box.
#             Otherwise the checkbox name is used.
# Returns:
#   A string containing a <input type="checkbox"> field
####
'checkbox' => <<'END_OF_FUNC',
sub checkbox {
    my($self,@@p) = self_or_default(@@_);

    my($name,$checked,$value,$label,$labelattributes,$override,$tabindex,@@other) =
       rearrange([NAME,[CHECKED,SELECTED,ON],VALUE,LABEL,LABELATTRIBUTES,
                   [OVERRIDE,FORCE],TABINDEX],@@p);

    $value = defined $value ? $value : 'on';

    if (!$override && ($self->{'.fieldnames'}->{$name} || 
		       defined $self->param($name))) {
	$checked = grep($_ eq $value,$self->param($name)) ? $self->_checked(1) : '';
    } else {
	$checked = $self->_checked($checked);
    }
    my($the_label) = defined $label ? $label : $name;
    $name = $self->escapeHTML($name);
    $value = $self->escapeHTML($value,1);
    $the_label = $self->escapeHTML($the_label);
    my($other) = @@other ? "@@other " : '';
    $tabindex = $self->element_tab($tabindex);
    $self->register_parameter($name);
    return $XHTML ? CGI::label($labelattributes,
                    qq{<input type="checkbox" name="$name" value="$value" $tabindex$checked$other/>$the_label})
                  : qq{<input type="checkbox" name="$name" value="$value"$checked$other>$the_label};
}
END_OF_FUNC



# Escape HTML -- used internally
'escapeHTML' => <<'END_OF_FUNC',
sub escapeHTML {
         # hack to work around  earlier hacks
         push @@_,$_[0] if @@_==1 && $_[0] eq 'CGI';
         my ($self,$toencode,$newlinestoo) = CGI::self_or_default(@@_);
         return undef unless defined($toencode);
         return $toencode if ref($self) && !$self->{'escape'};
         $toencode =~ s{&}{&amp;}gso;
         $toencode =~ s{<}{&lt;}gso;
         $toencode =~ s{>}{&gt;}gso;
	 if ($DTD_PUBLIC_IDENTIFIER =~ /[^X]HTML 3\.2/i) {
	     # $quot; was accidentally omitted from the HTML 3.2 DTD -- see
	     # <http://validator.w3.org/docs/errors.html#bad-entity> /
	     # <http://lists.w3.org/Archives/Public/www-html/1997Mar/0003.html>.
	     $toencode =~ s{"}{&#34;}gso;
         }
         else {
	     $toencode =~ s{"}{&quot;}gso;
         }
         # Handle bug in some browsers with Latin charsets
         if ($self->{'.charset'} &&
             (uc($self->{'.charset'}) eq 'ISO-8859-1' ||
              uc($self->{'.charset'}) eq 'WINDOWS-1252'))
         {
                $toencode =~ s{'}{&#39;}gso;
                $toencode =~ s{\x8b}{&#8249;}gso;
                $toencode =~ s{\x9b}{&#8250;}gso;
                if (defined $newlinestoo && $newlinestoo) {
                     $toencode =~ s{\012}{&#10;}gso;
                     $toencode =~ s{\015}{&#13;}gso;
                }
         }
         return $toencode;
}
END_OF_FUNC

# unescape HTML -- used internally
'unescapeHTML' => <<'END_OF_FUNC',
sub unescapeHTML {
    # hack to work around  earlier hacks
    push @@_,$_[0] if @@_==1 && $_[0] eq 'CGI';
    my ($self,$string) = CGI::self_or_default(@@_);
    return undef unless defined($string);
    my $latin = defined $self->{'.charset'} ? $self->{'.charset'} =~ /^(ISO-8859-1|WINDOWS-1252)$/i
                                            : 1;
    # thanks to Randal Schwartz for the correct solution to this one
    $string=~ s[&(.*?);]{
	local $_ = $1;
	/^amp$/i	? "&" :
	/^quot$/i	? '"' :
        /^gt$/i		? ">" :
	/^lt$/i		? "<" :
	/^#(\d+)$/ && $latin	     ? chr($1) :
	/^#x([0-9a-f]+)$/i && $latin ? chr(hex($1)) :
	$_
	}gex;
    return $string;
}
END_OF_FUNC

# Internal procedure - don't use
'_tableize' => <<'END_OF_FUNC',
sub _tableize {
    my($rows,$columns,$rowheaders,$colheaders,@@elements) = @@_;
    my @@rowheaders = $rowheaders ? @@$rowheaders : ();
    my @@colheaders = $colheaders ? @@$colheaders : ();
    my($result);

    if (defined($columns)) {
	$rows = int(0.99 + @@elements/$columns) unless defined($rows);
    }
    if (defined($rows)) {
	$columns = int(0.99 + @@elements/$rows) unless defined($columns);
    }

    # rearrange into a pretty table
    $result = "<table>";
    my($row,$column);
    unshift(@@colheaders,'') if @@colheaders && @@rowheaders;
    $result .= "<tr>" if @@colheaders;
    for (@@colheaders) {
	$result .= "<th>$_</th>";
    }
    for ($row=0;$row<$rows;$row++) {
	$result .= "<tr>";
	$result .= "<th>$rowheaders[$row]</th>" if @@rowheaders;
	for ($column=0;$column<$columns;$column++) {
	    $result .= "<td>" . $elements[$column*$rows + $row] . "</td>"
		if defined($elements[$column*$rows + $row]);
	}
	$result .= "</tr>";
    }
    $result .= "</table>";
    return $result;
}
END_OF_FUNC


#### Method: radio_group
# Create a list of logically-linked radio buttons.
# Parameters:
#   $name -> Common name for all the buttons.
#   $values -> A pointer to a regular array containing the
#             values for each button in the group.
#   $default -> (optional) Value of the button to turn on by default.  Pass '-'
#               to turn _nothing_ on.
#   $linebreak -> (optional) Set to true to place linebreaks
#             between the buttons.
#   $labels -> (optional)
#             A pointer to a hash of labels to print next to each checkbox
#             in the form $label{'value'}="Long explanatory label".
#             Otherwise the provided values are used as the labels.
# Returns:
#   An ARRAY containing a series of <input type="radio"> fields
####
'radio_group' => <<'END_OF_FUNC',
sub radio_group {
    my($self,@@p) = self_or_default(@@_);
   $self->_box_group('radio',@@p);
}
END_OF_FUNC

#### Method: checkbox_group
# Create a list of logically-linked checkboxes.
# Parameters:
#   $name -> Common name for all the check boxes
#   $values -> A pointer to a regular array containing the
#             values for each checkbox in the group.
#   $defaults -> (optional)
#             1. If a pointer to a regular array of checkbox values,
#             then this will be used to decide which
#             checkboxes to turn on by default.
#             2. If a scalar, will be assumed to hold the
#             value of a single checkbox in the group to turn on. 
#   $linebreak -> (optional) Set to true to place linebreaks
#             between the buttons.
#   $labels -> (optional)
#             A pointer to a hash of labels to print next to each checkbox
#             in the form $label{'value'}="Long explanatory label".
#             Otherwise the provided values are used as the labels.
# Returns:
#   An ARRAY containing a series of <input type="checkbox"> fields
####

'checkbox_group' => <<'END_OF_FUNC',
sub checkbox_group {
    my($self,@@p) = self_or_default(@@_);
   $self->_box_group('checkbox',@@p);
}
END_OF_FUNC

'_box_group' => <<'END_OF_FUNC',
sub _box_group {
    my $self     = shift;
    my $box_type = shift;

    my($name,$values,$defaults,$linebreak,$labels,$labelattributes,
       $attributes,$rows,$columns,$rowheaders,$colheaders,
       $override,$nolabels,$tabindex,$disabled,@@other) =
        rearrange([NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LINEBREAK,LABELS,LABELATTRIBUTES,
                       ATTRIBUTES,ROWS,[COLUMNS,COLS],[ROWHEADERS,ROWHEADER],[COLHEADERS,COLHEADER],
                       [OVERRIDE,FORCE],NOLABELS,TABINDEX,DISABLED
                  ],@@_);


    my($result,$checked,@@elements,@@values);

    @@values = $self->_set_values_and_labels($values,\$labels,$name);
    my %checked = $self->previous_or_default($name,$defaults,$override);

    # If no check array is specified, check the first by default
    $checked{$values[0]}++ if $box_type eq 'radio' && !%checked;

    $name=$self->escapeHTML($name);

    my %tabs = ();
    if ($TABINDEX && $tabindex) {
      if (!ref $tabindex) {
          $self->element_tab($tabindex);
      } elsif (ref $tabindex eq 'ARRAY') {
          %tabs = map {$_=>$self->element_tab} @@$tabindex;
      } elsif (ref $tabindex eq 'HASH') {
          %tabs = %$tabindex;
      }
    }
    %tabs = map {$_=>$self->element_tab} @@values unless %tabs;
    my $other = @@other ? "@@other " : '';
    my $radio_checked;

    # for disabling groups of radio/checkbox buttons
    my %disabled;
    for (@@{$disabled}) {
   	$disabled{$_}=1;
    }

    for (@@values) {
    	 my $disable="";
	 if ($disabled{$_}) {
		$disable="disabled='1'";
	 }

        my $checkit = $self->_checked($box_type eq 'radio' ? ($checked{$_} && !$radio_checked++)
                                                           : $checked{$_});
	my($break);
	if ($linebreak) {
          $break = $XHTML ? "<br />" : "<br>";
	}
	else {
	  $break = '';
	}
	my($label)='';
	unless (defined($nolabels) && $nolabels) {
	    $label = $_;
	    $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
	    $label = $self->escapeHTML($label,1);
            $label = "<span style=\"color:gray\">$label</span>" if $disabled{$_};
	}
        my $attribs = $self->_set_attributes($_, $attributes);
        my $tab     = $tabs{$_};
	$_=$self->escapeHTML($_);

        if ($XHTML) {
           push @@elements,
              CGI::label($labelattributes,
                   qq(<input type="$box_type" name="$name" value="$_" $checkit$other$tab$attribs$disable/>$label)).${break};
        } else {
            push(@@elements,qq/<input type="$box_type" name="$name" value="$_"$checkit$other$tab$attribs$disable>${label}${break}/);
        }
    }
    $self->register_parameter($name);
    return wantarray ? @@elements : "@@elements"
           unless defined($columns) || defined($rows);
    return _tableize($rows,$columns,$rowheaders,$colheaders,@@elements);
}
END_OF_FUNC


#### Method: popup_menu
# Create a popup menu.
# Parameters:
#   $name -> Name for all the menu
#   $values -> A pointer to a regular array containing the
#             text of each menu item.
#   $default -> (optional) Default item to display
#   $labels -> (optional)
#             A pointer to a hash of labels to print next to each checkbox
#             in the form $label{'value'}="Long explanatory label".
#             Otherwise the provided values are used as the labels.
# Returns:
#   A string containing the definition of a popup menu.
####
'popup_menu' => <<'END_OF_FUNC',
sub popup_menu {
    my($self,@@p) = self_or_default(@@_);

    my($name,$values,$default,$labels,$attributes,$override,$tabindex,@@other) =
       rearrange([NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LABELS,
       ATTRIBUTES,[OVERRIDE,FORCE],TABINDEX],@@p);
    my($result,%selected);

    if (!$override && defined($self->param($name))) {
	$selected{$self->param($name)}++;
    } elsif (defined $default) {
	%selected = map {$_=>1} ref($default) eq 'ARRAY' 
                                ? @@$default 
                                : $default;
    }
    $name=$self->escapeHTML($name);
    my($other) = @@other ? " @@other" : '';

    my(@@values);
    @@values = $self->_set_values_and_labels($values,\$labels,$name);
    $tabindex = $self->element_tab($tabindex);
    $result = qq/<select name="$name" $tabindex$other>\n/;
    for (@@values) {
        if (/<optgroup/) {
            for my $v (split(/\n/)) {
                my $selectit = $XHTML ? 'selected="selected"' : 'selected';
		for my $selected (keys %selected) {
		    $v =~ s/(value="$selected")/$selectit $1/;
		}
                $result .= "$v\n";
            }
        }
        else {
          my $attribs   = $self->_set_attributes($_, $attributes);
	  my($selectit) = $self->_selected($selected{$_});
	  my($label)    = $_;
	  $label        = $labels->{$_} if defined($labels) && defined($labels->{$_});
	  my($value)    = $self->escapeHTML($_);
	  $label        = $self->escapeHTML($label,1);
          $result      .= "<option${attribs} ${selectit}value=\"$value\">$label</option>\n";
        }
    }

    $result .= "</select>";
    return $result;
}
END_OF_FUNC


#### Method: optgroup
# Create a optgroup.
# Parameters:
#   $name -> Label for the group
#   $values -> A pointer to a regular array containing the
#              values for each option line in the group.
#   $labels -> (optional)
#              A pointer to a hash of labels to print next to each item
#              in the form $label{'value'}="Long explanatory label".
#              Otherwise the provided values are used as the labels.
#   $labeled -> (optional)
#               A true value indicates the value should be used as the label attribute
#               in the option elements.
#               The label attribute specifies the option label presented to the user.
#               This defaults to the content of the <option> element, but the label
#               attribute allows authors to more easily use optgroup without sacrificing
#               compatibility with browsers that do not support option groups.
#   $novals -> (optional)
#              A true value indicates to suppress the val attribute in the option elements
# Returns:
#   A string containing the definition of an option group.
####
'optgroup' => <<'END_OF_FUNC',
sub optgroup {
    my($self,@@p) = self_or_default(@@_);
    my($name,$values,$attributes,$labeled,$noval,$labels,@@other)
        = rearrange([NAME,[VALUES,VALUE],ATTRIBUTES,LABELED,NOVALS,LABELS],@@p);

    my($result,@@values);
    @@values = $self->_set_values_and_labels($values,\$labels,$name,$labeled,$novals);
    my($other) = @@other ? " @@other" : '';

    $name=$self->escapeHTML($name);
    $result = qq/<optgroup label="$name"$other>\n/;
    for (@@values) {
        if (/<optgroup/) {
            for (split(/\n/)) {
                my $selectit = $XHTML ? 'selected="selected"' : 'selected';
                s/(value="$selected")/$selectit $1/ if defined $selected;
                $result .= "$_\n";
            }
        }
        else {
            my $attribs = $self->_set_attributes($_, $attributes);
            my($label) = $_;
            $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
            $label=$self->escapeHTML($label);
            my($value)=$self->escapeHTML($_,1);
            $result .= $labeled ? $novals ? "<option$attribs label=\"$value\">$label</option>\n"
                                          : "<option$attribs label=\"$value\" value=\"$value\">$label</option>\n"
                                : $novals ? "<option$attribs>$label</option>\n"
                                          : "<option$attribs value=\"$value\">$label</option>\n";
        }
    }
    $result .= "</optgroup>";
    return $result;
}
END_OF_FUNC


#### Method: scrolling_list
# Create a scrolling list.
# Parameters:
#   $name -> name for the list
#   $values -> A pointer to a regular array containing the
#             values for each option line in the list.
#   $defaults -> (optional)
#             1. If a pointer to a regular array of options,
#             then this will be used to decide which
#             lines to turn on by default.
#             2. Otherwise holds the value of the single line to turn on.
#   $size -> (optional) Size of the list.
#   $multiple -> (optional) If set, allow multiple selections.
#   $labels -> (optional)
#             A pointer to a hash of labels to print next to each checkbox
#             in the form $label{'value'}="Long explanatory label".
#             Otherwise the provided values are used as the labels.
# Returns:
#   A string containing the definition of a scrolling list.
####
'scrolling_list' => <<'END_OF_FUNC',
sub scrolling_list {
    my($self,@@p) = self_or_default(@@_);
    my($name,$values,$defaults,$size,$multiple,$labels,$attributes,$override,$tabindex,@@other)
	= rearrange([NAME,[VALUES,VALUE],[DEFAULTS,DEFAULT],
          SIZE,MULTIPLE,LABELS,ATTRIBUTES,[OVERRIDE,FORCE],TABINDEX],@@p);

    my($result,@@values);
    @@values = $self->_set_values_and_labels($values,\$labels,$name);

    $size = $size || scalar(@@values);

    my(%selected) = $self->previous_or_default($name,$defaults,$override);

    my($is_multiple) = $multiple ? qq/ multiple="multiple"/ : '';
    my($has_size) = $size ? qq/ size="$size"/: '';
    my($other) = @@other ? " @@other" : '';

    $name=$self->escapeHTML($name);
    $tabindex = $self->element_tab($tabindex);
    $result = qq/<select name="$name" $tabindex$has_size$is_multiple$other>\n/;
    for (@@values) {
	my($selectit) = $self->_selected($selected{$_});
	my($label) = $_;
	$label = $labels->{$_} if defined($labels) && defined($labels->{$_});
	$label=$self->escapeHTML($label);
	my($value)=$self->escapeHTML($_,1);
        my $attribs = $self->_set_attributes($_, $attributes);
        $result .= "<option ${selectit}${attribs}value=\"$value\">$label</option>\n";
    }
    $result .= "</select>";
    $self->register_parameter($name);
    return $result;
}
END_OF_FUNC


#### Method: hidden
# Parameters:
#   $name -> Name of the hidden field
#   @@default -> (optional) Initial values of field (may be an array)
#      or
#   $default->[initial values of field]
# Returns:
#   A string containing a <input type="hidden" name="name" value="value">
####
'hidden' => <<'END_OF_FUNC',
sub hidden {
    my($self,@@p) = self_or_default(@@_);

    # this is the one place where we departed from our standard
    # calling scheme, so we have to special-case (darn)
    my(@@result,@@value);
    my($name,$default,$override,@@other) = 
	rearrange([NAME,[DEFAULT,VALUE,VALUES],[OVERRIDE,FORCE]],@@p);

    my $do_override = 0;
    if ( ref($p[0]) || substr($p[0],0,1) eq '-') {
	@@value = ref($default) ? @@{$default} : $default;
	$do_override = $override;
    } else {
	for ($default,$override,@@other) {
	    push(@@value,$_) if defined($_);
	}
    }

    # use previous values if override is not set
    my @@prev = $self->param($name);
    @@value = @@prev if !$do_override && @@prev;

    $name=$self->escapeHTML($name);
    for (@@value) {
	$_ = defined($_) ? $self->escapeHTML($_,1) : '';
	push @@result,$XHTML ? qq(<input type="hidden" name="$name" value="$_" @@other />)
                            : qq(<input type="hidden" name="$name" value="$_" @@other>);
    }
    return wantarray ? @@result : join('',@@result);
}
END_OF_FUNC


#### Method: image_button
# Parameters:
#   $name -> Name of the button
#   $src ->  URL of the image source
#   $align -> Alignment style (TOP, BOTTOM or MIDDLE)
# Returns:
#   A string containing a <input type="image" name="name" src="url" align="alignment">
####
'image_button' => <<'END_OF_FUNC',
sub image_button {
    my($self,@@p) = self_or_default(@@_);

    my($name,$src,$alignment,@@other) =
	rearrange([NAME,SRC,ALIGN],@@p);

    my($align) = $alignment ? " align=\L\"$alignment\"" : '';
    my($other) = @@other ? " @@other" : '';
    $name=$self->escapeHTML($name);
    return $XHTML ? qq(<input type="image" name="$name" src="$src"$align$other />)
                  : qq/<input type="image" name="$name" src="$src"$align$other>/;
}
END_OF_FUNC


#### Method: self_url
# Returns a URL containing the current script and all its
# param/value pairs arranged as a query.  You can use this
# to create a link that, when selected, will reinvoke the
# script with all its state information preserved.
####
'self_url' => <<'END_OF_FUNC',
sub self_url {
    my($self,@@p) = self_or_default(@@_);
    return $self->url('-path_info'=>1,'-query'=>1,'-full'=>1,@@p);
}
END_OF_FUNC


# This is provided as a synonym to self_url() for people unfortunate
# enough to have incorporated it into their programs already!
'state' => <<'END_OF_FUNC',
sub state {
    &self_url;
}
END_OF_FUNC


#### Method: url
# Like self_url, but doesn't return the query string part of
# the URL.
####
'url' => <<'END_OF_FUNC',
sub url {
    my($self,@@p) = self_or_default(@@_);
    my ($relative,$absolute,$full,$path_info,$query,$base,$rewrite) = 
	rearrange(['RELATIVE','ABSOLUTE','FULL',['PATH','PATH_INFO'],['QUERY','QUERY_STRING'],'BASE','REWRITE'],@@p);
    my $url  = '';
    $full++      if $base || !($relative || $absolute);
    $rewrite++   unless defined $rewrite;

    my $path        =  $self->path_info;
    my $script_name =  $self->script_name;
    my $request_uri =  unescape($self->request_uri) || '';
    my $query_str   =  $self->query_string;

    my $rewrite_in_use = $request_uri && $request_uri !~ /^\Q$script_name/;
    undef $path if $rewrite_in_use && $rewrite;  # path not valid when rewriting active

    my $uri         =  $rewrite && $request_uri ? $request_uri : $script_name;
    $uri            =~ s/\?.*$//s;                                # remove query string
    $uri            =~ s/\Q$ENV{PATH_INFO}\E$// if defined $ENV{PATH_INFO};
#    $uri            =~ s/\Q$path\E$//      if defined $path;      # remove path

    if ($full) {
	my $protocol = $self->protocol();
	$url = "$protocol://";
	my $vh = http('x_forwarded_host') || http('host') || '';
        $vh =~ s/\:\d+$//;  # some clients add the port number (incorrectly). Get rid of it.
	if ($vh) {
	    $url .= $vh;
	} else {
	    $url .= server_name();
	}
        my $port = $self->server_port;
	$url .= ":" . $port
	  unless (lc($protocol) eq 'http'  && $port == 80)
		|| (lc($protocol) eq 'https' && $port == 443);
        return $url if $base;
	$url .= $uri;
    } elsif ($relative) {
	($url) = $uri =~ m!([^/]+)$!;
    } elsif ($absolute) {
	$url = $uri;
    }

    $url .= $path         if $path_info and defined $path;
    $url .= "?$query_str" if $query     and $query_str ne '';
    $url ||= '';
    $url =~ s/([^a-zA-Z0-9_.%;&?\/\\:+=~-])/sprintf("%%%02X",ord($1))/eg;
    return $url;
}

END_OF_FUNC

#### Method: cookie
# Set or read a cookie from the specified name.
# Cookie can then be passed to header().
# Usual rules apply to the stickiness of -value.
#  Parameters:
#   -name -> name for this cookie (optional)
#   -value -> value of this cookie (scalar, array or hash) 
#   -path -> paths for which this cookie is valid (optional)
#   -domain -> internet domain in which this cookie is valid (optional)
#   -secure -> if true, cookie only passed through secure channel (optional)
#   -expires -> expiry date in format Wdy, DD-Mon-YYYY HH:MM:SS GMT (optional)
####
'cookie' => <<'END_OF_FUNC',
sub cookie {
    my($self,@@p) = self_or_default(@@_);
    my($name,$value,$path,$domain,$secure,$expires,$httponly) =
	rearrange([NAME,[VALUE,VALUES],PATH,DOMAIN,SECURE,EXPIRES,HTTPONLY],@@p);

    require CGI::Cookie;

    # if no value is supplied, then we retrieve the
    # value of the cookie, if any.  For efficiency, we cache the parsed
    # cookies in our state variables.
    unless ( defined($value) ) {
	$self->{'.cookies'} = CGI::Cookie->fetch
	    unless $self->{'.cookies'};

	# If no name is supplied, then retrieve the names of all our cookies.
	return () unless $self->{'.cookies'};
	return keys %{$self->{'.cookies'}} unless $name;
	return () unless $self->{'.cookies'}->{$name};
	return $self->{'.cookies'}->{$name}->value if defined($name) && $name ne '';
    }

    # If we get here, we're creating a new cookie
    return undef unless defined($name) && $name ne '';	# this is an error

    my @@param;
    push(@@param,'-name'=>$name);
    push(@@param,'-value'=>$value);
    push(@@param,'-domain'=>$domain) if $domain;
    push(@@param,'-path'=>$path) if $path;
    push(@@param,'-expires'=>$expires) if $expires;
    push(@@param,'-secure'=>$secure) if $secure;
    push(@@param,'-httponly'=>$httponly) if $httponly;

    return new CGI::Cookie(@@param);
}
END_OF_FUNC

'parse_keywordlist' => <<'END_OF_FUNC',
sub parse_keywordlist {
    my($self,$tosplit) = @@_;
    $tosplit = unescape($tosplit); # unescape the keywords
    $tosplit=~tr/+/ /;          # pluses to spaces
    my(@@keywords) = split(/\s+/,$tosplit);
    return @@keywords;
}
END_OF_FUNC

'param_fetch' => <<'END_OF_FUNC',
sub param_fetch {
    my($self,@@p) = self_or_default(@@_);
    my($name) = rearrange([NAME],@@p);
    unless (exists($self->{param}{$name})) {
	$self->add_parameter($name);
	$self->{param}{$name} = [];
    }
    
    return $self->{param}{$name};
}
END_OF_FUNC

###############################################
# OTHER INFORMATION PROVIDED BY THE ENVIRONMENT
###############################################

#### Method: path_info
# Return the extra virtual path information provided
# after the URL (if any)
####
'path_info' => <<'END_OF_FUNC',
sub path_info {
    my ($self,$info) = self_or_default(@@_);
    if (defined($info)) {
	$info = "/$info" if $info ne '' &&  substr($info,0,1) ne '/';
	$self->{'.path_info'} = $info;
    } elsif (! defined($self->{'.path_info'}) ) {
        my (undef,$path_info) = $self->_name_and_path_from_env;
	$self->{'.path_info'} = $path_info || '';
    }
    return $self->{'.path_info'};
}
END_OF_FUNC

# This function returns a potentially modified version of SCRIPT_NAME
# and PATH_INFO. Some HTTP servers do sanitise the paths in those
# variables. It is the case of at least Apache 2. If for instance the
# user requests: /path/./to/script.cgi/x//y/z/../x?y, Apache will set:
# REQUEST_URI=/path/./to/script.cgi/x//y/z/../x?y
# SCRIPT_NAME=/path/to/env.cgi
# PATH_INFO=/x/y/x
#
# This is all fine except that some bogus CGI scripts expect
# PATH_INFO=/http://foo when the user requests
# http://xxx/script.cgi/http://foo
#
# Old versions of this module used to accomodate with those scripts, so
# this is why we do this here to keep those scripts backward compatible.
# Basically, we accomodate with those scripts but within limits, that is
# we only try to preserve the number of / that were provided by the user
# if $REQUEST_URI and "$SCRIPT_NAME$PATH_INFO" only differ by the number
# of consecutive /.
#
# So for instance, in: http://foo/x//y/script.cgi/a//b, we'll return a
# script_name of /x//y/script.cgi and a path_info of /a//b, but in:
# http://foo/./x//z/script.cgi/a/../b//c, we'll return the versions
# possibly sanitised by the HTTP server, so in the case of Apache 2:
# script_name == /foo/x/z/script.cgi and path_info == /b/c.
#
# Future versions of this module may no longer do that, so one should
# avoid relying on the browser, proxy, server, and CGI.pm preserving the
# number of consecutive slashes as no guarantee can be made there.
'_name_and_path_from_env' => <<'END_OF_FUNC',
sub _name_and_path_from_env {
    my $self = shift;
    my $script_name = $ENV{SCRIPT_NAME}  || '';
    my $path_info   = $ENV{PATH_INFO}    || '';
    my $uri         = $self->request_uri || '';

    $uri =~ s/\?.*//s;
    $uri = unescape($uri);

    if ($uri ne "$script_name$path_info") {
        my $script_name_pattern = quotemeta($script_name);
        my $path_info_pattern = quotemeta($path_info);
        $script_name_pattern =~ s{(?:\\/)+}{/+}g;
        $path_info_pattern =~ s{(?:\\/)+}{/+}g;

        if ($uri =~ /^($script_name_pattern)($path_info_pattern)$/s) {
            # REQUEST_URI and SCRIPT_NAME . PATH_INFO only differ by the
            # numer of consecutive slashes, so we can extract the info from
            # REQUEST_URI:
            ($script_name, $path_info) = ($1, $2);
        }
    }
    return ($script_name,$path_info);
}
END_OF_FUNC


#### Method: request_method
# Returns 'POST', 'GET', 'PUT' or 'HEAD'
####
'request_method' => <<'END_OF_FUNC',
sub request_method {
    return $ENV{'REQUEST_METHOD'};
}
END_OF_FUNC

#### Method: content_type
# Returns the content_type string
####
'content_type' => <<'END_OF_FUNC',
sub content_type {
    return $ENV{'CONTENT_TYPE'};
}
END_OF_FUNC

#### Method: path_translated
# Return the physical path information provided
# by the URL (if any)
####
'path_translated' => <<'END_OF_FUNC',
sub path_translated {
    return $ENV{'PATH_TRANSLATED'};
}
END_OF_FUNC


#### Method: request_uri
# Return the literal request URI
####
'request_uri' => <<'END_OF_FUNC',
sub request_uri {
    return $ENV{'REQUEST_URI'};
}
END_OF_FUNC


#### Method: query_string
# Synthesize a query string from our current
# parameters
####
'query_string' => <<'END_OF_FUNC',
sub query_string {
    my($self) = self_or_default(@@_);
    my($param,$value,@@pairs);
    for $param ($self->param) {
	my($eparam) = escape($param);
	for $value ($self->param($param)) {
	    $value = escape($value);
            next unless defined $value;
	    push(@@pairs,"$eparam=$value");
	}
    }
    for (keys %{$self->{'.fieldnames'}}) {
      push(@@pairs,".cgifields=".escape("$_"));
    }
    return join($USE_PARAM_SEMICOLONS ? ';' : '&',@@pairs);
}
END_OF_FUNC


#### Method: accept
# Without parameters, returns an array of the
# MIME types the browser accepts.
# With a single parameter equal to a MIME
# type, will return undef if the browser won't
# accept it, 1 if the browser accepts it but
# doesn't give a preference, or a floating point
# value between 0.0 and 1.0 if the browser
# declares a quantitative score for it.
# This handles MIME type globs correctly.
####
'Accept' => <<'END_OF_FUNC',
sub Accept {
    my($self,$search) = self_or_CGI(@@_);
    my(%prefs,$type,$pref,$pat);
    
    my(@@accept) = defined $self->http('accept') 
                ? split(',',$self->http('accept'))
                : ();

    for (@@accept) {
	($pref) = /q=(\d\.\d+|\d+)/;
	($type) = m#(\S+/[^;]+)#;
	next unless $type;
	$prefs{$type}=$pref || 1;
    }

    return keys %prefs unless $search;
    
    # if a search type is provided, we may need to
    # perform a pattern matching operation.
    # The MIME types use a glob mechanism, which
    # is easily translated into a perl pattern match

    # First return the preference for directly supported
    # types:
    return $prefs{$search} if $prefs{$search};

    # Didn't get it, so try pattern matching.
    for (keys %prefs) {
	next unless /\*/;       # not a pattern match
	($pat = $_) =~ s/([^\w*])/\\$1/g; # escape meta characters
	$pat =~ s/\*/.*/g; # turn it into a pattern
	return $prefs{$_} if $search=~/$pat/;
    }
}
END_OF_FUNC


#### Method: user_agent
# If called with no parameters, returns the user agent.
# If called with one parameter, does a pattern match (case
# insensitive) on the user agent.
####
'user_agent' => <<'END_OF_FUNC',
sub user_agent {
    my($self,$match)=self_or_CGI(@@_);
    return $self->http('user_agent') unless $match;
    return $self->http('user_agent') =~ /$match/i;
}
END_OF_FUNC


#### Method: raw_cookie
# Returns the magic cookies for the session.
# The cookies are not parsed or altered in any way, i.e.
# cookies are returned exactly as given in the HTTP
# headers.  If a cookie name is given, only that cookie's
# value is returned, otherwise the entire raw cookie
# is returned.
####
'raw_cookie' => <<'END_OF_FUNC',
sub raw_cookie {
    my($self,$key) = self_or_CGI(@@_);

    require CGI::Cookie;

    if (defined($key)) {
	$self->{'.raw_cookies'} = CGI::Cookie->raw_fetch
	    unless $self->{'.raw_cookies'};

	return () unless $self->{'.raw_cookies'};
	return () unless $self->{'.raw_cookies'}->{$key};
	return $self->{'.raw_cookies'}->{$key};
    }
    return $self->http('cookie') || $ENV{'COOKIE'} || '';
}
END_OF_FUNC

#### Method: virtual_host
# Return the name of the virtual_host, which
# is not always the same as the server
######
'virtual_host' => <<'END_OF_FUNC',
sub virtual_host {
    my $vh = http('x_forwarded_host') || http('host') || server_name();
    $vh =~ s/:\d+$//;		# get rid of port number
    return $vh;
}
END_OF_FUNC

#### Method: remote_host
# Return the name of the remote host, or its IP
# address if unavailable.  If this variable isn't
# defined, it returns "localhost" for debugging
# purposes.
####
'remote_host' => <<'END_OF_FUNC',
sub remote_host {
    return $ENV{'REMOTE_HOST'} || $ENV{'REMOTE_ADDR'} 
    || 'localhost';
}
END_OF_FUNC


#### Method: remote_addr
# Return the IP addr of the remote host.
####
'remote_addr' => <<'END_OF_FUNC',
sub remote_addr {
    return $ENV{'REMOTE_ADDR'} || '127.0.0.1';
}
END_OF_FUNC


#### Method: script_name
# Return the partial URL to this script for
# self-referencing scripts.  Also see
# self_url(), which returns a URL with all state information
# preserved.
####
'script_name' => <<'END_OF_FUNC',
sub script_name {
    my ($self,@@p) = self_or_default(@@_);
    if (@@p) {
        $self->{'.script_name'} = shift @@p;
    } elsif (!exists $self->{'.script_name'}) {
        my ($script_name,$path_info) = $self->_name_and_path_from_env();
        $self->{'.script_name'} = $script_name;
    }
    return $self->{'.script_name'};
}
END_OF_FUNC


#### Method: referer
# Return the HTTP_REFERER: useful for generating
# a GO BACK button.
####
'referer' => <<'END_OF_FUNC',
sub referer {
    my($self) = self_or_CGI(@@_);
    return $self->http('referer');
}
END_OF_FUNC


#### Method: server_name
# Return the name of the server
####
'server_name' => <<'END_OF_FUNC',
sub server_name {
    return $ENV{'SERVER_NAME'} || 'localhost';
}
END_OF_FUNC

#### Method: server_software
# Return the name of the server software
####
'server_software' => <<'END_OF_FUNC',
sub server_software {
    return $ENV{'SERVER_SOFTWARE'} || 'cmdline';
}
END_OF_FUNC

#### Method: virtual_port
# Return the server port, taking virtual hosts into account
####
'virtual_port' => <<'END_OF_FUNC',
sub virtual_port {
    my($self) = self_or_default(@@_);
    my $vh = $self->http('x_forwarded_host') || $self->http('host');
    my $protocol = $self->protocol;
    if ($vh) {
        return ($vh =~ /:(\d+)$/)[0] || ($protocol eq 'https' ? 443 : 80);
    } else {
        return $self->server_port();
    }
}
END_OF_FUNC

#### Method: server_port
# Return the tcp/ip port the server is running on
####
'server_port' => <<'END_OF_FUNC',
sub server_port {
    return $ENV{'SERVER_PORT'} || 80; # for debugging
}
END_OF_FUNC

#### Method: server_protocol
# Return the protocol (usually HTTP/1.0)
####
'server_protocol' => <<'END_OF_FUNC',
sub server_protocol {
    return $ENV{'SERVER_PROTOCOL'} || 'HTTP/1.0'; # for debugging
}
END_OF_FUNC

#### Method: http
# Return the value of an HTTP variable, or
# the list of variables if none provided
####
'http' => <<'END_OF_FUNC',
sub http {
    my ($self,$parameter) = self_or_CGI(@@_);
    return $ENV{$parameter} if $parameter=~/^HTTP/;
    $parameter =~ tr/-/_/;
    return $ENV{"HTTP_\U$parameter\E"} if $parameter;
    my(@@p);
    for (keys %ENV) {
	push(@@p,$_) if /^HTTP/;
    }
    return @@p;
}
END_OF_FUNC

#### Method: https
# Return the value of HTTPS
####
'https' => <<'END_OF_FUNC',
sub https {
    local($^W)=0;
    my ($self,$parameter) = self_or_CGI(@@_);
    return $ENV{HTTPS} unless $parameter;
    return $ENV{$parameter} if $parameter=~/^HTTPS/;
    $parameter =~ tr/-/_/;
    return $ENV{"HTTPS_\U$parameter\E"} if $parameter;
    my(@@p);
    for (keys %ENV) {
	push(@@p,$_) if /^HTTPS/;
    }
    return @@p;
}
END_OF_FUNC

#### Method: protocol
# Return the protocol (http or https currently)
####
'protocol' => <<'END_OF_FUNC',
sub protocol {
    local($^W)=0;
    my $self = shift;
    return 'https' if uc($self->https()) eq 'ON'; 
    return 'https' if $self->server_port == 443;
    my $prot = $self->server_protocol;
    my($protocol,$version) = split('/',$prot);
    return "\L$protocol\E";
}
END_OF_FUNC

#### Method: remote_ident
# Return the identity of the remote user
# (but only if his host is running identd)
####
'remote_ident' => <<'END_OF_FUNC',
sub remote_ident {
    return $ENV{'REMOTE_IDENT'};
}
END_OF_FUNC


#### Method: auth_type
# Return the type of use verification/authorization in use, if any.
####
'auth_type' => <<'END_OF_FUNC',
sub auth_type {
    return $ENV{'AUTH_TYPE'};
}
END_OF_FUNC


#### Method: remote_user
# Return the authorization name used for user
# verification.
####
'remote_user' => <<'END_OF_FUNC',
sub remote_user {
    return $ENV{'REMOTE_USER'};
}
END_OF_FUNC


#### Method: user_name
# Try to return the remote user's name by hook or by
# crook
####
'user_name' => <<'END_OF_FUNC',
sub user_name {
    my ($self) = self_or_CGI(@@_);
    return $self->http('from') || $ENV{'REMOTE_IDENT'} || $ENV{'REMOTE_USER'};
}
END_OF_FUNC

#### Method: nosticky
# Set or return the NOSTICKY global flag
####
'nosticky' => <<'END_OF_FUNC',
sub nosticky {
    my ($self,$param) = self_or_CGI(@@_);
    $CGI::NOSTICKY = $param if defined($param);
    return $CGI::NOSTICKY;
}
END_OF_FUNC

#### Method: nph
# Set or return the NPH global flag
####
'nph' => <<'END_OF_FUNC',
sub nph {
    my ($self,$param) = self_or_CGI(@@_);
    $CGI::NPH = $param if defined($param);
    return $CGI::NPH;
}
END_OF_FUNC

#### Method: private_tempfiles
# Set or return the private_tempfiles global flag
####
'private_tempfiles' => <<'END_OF_FUNC',
sub private_tempfiles {
    my ($self,$param) = self_or_CGI(@@_);
    $CGI::PRIVATE_TEMPFILES = $param if defined($param);
    return $CGI::PRIVATE_TEMPFILES;
}
END_OF_FUNC
#### Method: close_upload_files
# Set or return the close_upload_files global flag
####
'close_upload_files' => <<'END_OF_FUNC',
sub close_upload_files {
    my ($self,$param) = self_or_CGI(@@_);
    $CGI::CLOSE_UPLOAD_FILES = $param if defined($param);
    return $CGI::CLOSE_UPLOAD_FILES;
}
END_OF_FUNC


#### Method: default_dtd
# Set or return the default_dtd global
####
'default_dtd' => <<'END_OF_FUNC',
sub default_dtd {
    my ($self,$param,$param2) = self_or_CGI(@@_);
    if (defined $param2 && defined $param) {
        $CGI::DEFAULT_DTD = [ $param, $param2 ];
    } elsif (defined $param) {
        $CGI::DEFAULT_DTD = $param;
    }
    return $CGI::DEFAULT_DTD;
}
END_OF_FUNC

# -------------- really private subroutines -----------------
'previous_or_default' => <<'END_OF_FUNC',
sub previous_or_default {
    my($self,$name,$defaults,$override) = @@_;
    my(%selected);

    if (!$override && ($self->{'.fieldnames'}->{$name} || 
		       defined($self->param($name)) ) ) {
	$selected{$_}++ for $self->param($name);
    } elsif (defined($defaults) && ref($defaults) && 
	     (ref($defaults) eq 'ARRAY')) {
	$selected{$_}++ for @@{$defaults};
    } else {
	$selected{$defaults}++ if defined($defaults);
    }

    return %selected;
}
END_OF_FUNC

'register_parameter' => <<'END_OF_FUNC',
sub register_parameter {
    my($self,$param) = @@_;
    $self->{'.parametersToAdd'}->{$param}++;
}
END_OF_FUNC

'get_fields' => <<'END_OF_FUNC',
sub get_fields {
    my($self) = @@_;
    return $self->CGI::hidden('-name'=>'.cgifields',
			      '-values'=>[keys %{$self->{'.parametersToAdd'}}],
			      '-override'=>1);
}
END_OF_FUNC

'read_from_cmdline' => <<'END_OF_FUNC',
sub read_from_cmdline {
    my($input,@@words);
    my($query_string);
    my($subpath);
    if ($DEBUG && @@ARGV) {
	@@words = @@ARGV;
    } elsif ($DEBUG > 1) {
	require "shellwords.pl";
	print STDERR "(offline mode: enter name=value pairs on standard input; press ^D or ^Z when done)\n";
	chomp(@@lines = <STDIN>); # remove newlines
	$input = join(" ",@@lines);
	@@words = &shellwords($input);    
    }
    for (@@words) {
	s/\\=/%3D/g;
	s/\\&/%26/g;	    
    }

    if ("@@words"=~/=/) {
	$query_string = join('&',@@words);
    } else {
	$query_string = join('+',@@words);
    }
    if ($query_string =~ /^(.*?)\?(.*)$/)
    {
        $query_string = $2;
        $subpath = $1;
    }
    return { 'query_string' => $query_string, 'subpath' => $subpath };
}
END_OF_FUNC

#####
# subroutine: read_multipart
#
# Read multipart data and store it into our parameters.
# An interesting feature is that if any of the parts is a file, we
# create a temporary file and open up a filehandle on it so that the
# caller can read from it if necessary.
#####
'read_multipart' => <<'END_OF_FUNC',
sub read_multipart {
    my($self,$boundary,$length) = @@_;
    my($buffer) = $self->new_MultipartBuffer($boundary,$length);
    return unless $buffer;
    my(%header,$body);
    my $filenumber = 0;
    while (!$buffer->eof) {
	%header = $buffer->readHeader;

	unless (%header) {
	    $self->cgi_error("400 Bad request (malformed multipart POST)");
	    return;
	}

	$header{'Content-Disposition'} ||= ''; # quench uninit variable warning

	my($param)= $header{'Content-Disposition'}=~/ name="([^"]*)"/;
        $param .= $TAINTED;

        # See RFC 1867, 2183, 2045
        # NB: File content will be loaded into memory should
        # content-disposition parsing fail.
        my ($filename) = $header{'Content-Disposition'}
	               =~/ filename=(("[^"]*")|([a-z\d!\#'\*\+,\.^_\`\{\}\|\~]*))/i;

	$filename ||= ''; # quench uninit variable warning

        $filename =~ s/^"([^"]*)"$/$1/;
	# Test for Opera's multiple upload feature
	my($multipart) = ( defined( $header{'Content-Type'} ) &&
		$header{'Content-Type'} =~ /multipart\/mixed/ ) ?
		1 : 0;

	# add this parameter to our list
	$self->add_parameter($param);

	# If no filename specified, then just read the data and assign it
	# to our parameter list.
	if ( ( !defined($filename) || $filename eq '' ) && !$multipart ) {
	    my($value) = $buffer->readBody;
            $value .= $TAINTED;
	    push(@@{$self->{param}{$param}},$value);
	    next;
	}

	my ($tmpfile,$tmp,$filehandle);
      UPLOADS: {
	  # If we get here, then we are dealing with a potentially large
	  # uploaded form.  Save the data to a temporary file, then open
	  # the file for reading.

	  # skip the file if uploads disabled
	  if ($DISABLE_UPLOADS) {
	      while (defined($data = $buffer->read)) { }
	      last UPLOADS;
	  }

	  # set the filename to some recognizable value
          if ( ( !defined($filename) || $filename eq '' ) && $multipart ) {
              $filename = "multipart/mixed";
          }

	  # choose a relatively unpredictable tmpfile sequence number
          my $seqno = unpack("%16C*",join('',localtime,grep {defined $_} values %ENV));
          for (my $cnt=10;$cnt>0;$cnt--) {
	    next unless $tmpfile = new CGITempFile($seqno);
	    $tmp = $tmpfile->as_string;
	    last if defined($filehandle = Fh->new($filename,$tmp,$PRIVATE_TEMPFILES));
            $seqno += int rand(100);
          }
          die "CGI open of tmpfile: $!\n" unless defined $filehandle;
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode 
                     && defined fileno($filehandle);

	  # if this is an multipart/mixed attachment, save the header
	  # together with the body for later parsing with an external
	  # MIME parser module
	  if ( $multipart ) {
	      for ( keys %header ) {
		  print $filehandle "$_: $header{$_}${CRLF}";
	      }
	      print $filehandle "${CRLF}";
	  }

	  my ($data);
	  local($\) = '';
          my $totalbytes = 0;
          while (defined($data = $buffer->read)) {
              if (defined $self->{'.upload_hook'})
               {
                  $totalbytes += length($data);
                   &{$self->{'.upload_hook'}}($filename ,$data, $totalbytes, $self->{'.upload_data'});
              }
              print $filehandle $data if ($self->{'use_tempfile'});
          }

	  # back up to beginning of file
	  seek($filehandle,0,0);

      ## Close the filehandle if requested this allows a multipart MIME
      ## upload to contain many files, and we won't die due to too many
      ## open file handles. The user can access the files using the hash
      ## below.
      close $filehandle if $CLOSE_UPLOAD_FILES;
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode;

	  # Save some information about the uploaded file where we can get
	  # at it later.
	  # Use the typeglob as the key, as this is guaranteed to be
	  # unique for each filehandle.  Don't use the file descriptor as
	  # this will be re-used for each filehandle if the
	  # close_upload_files feature is used.
	  $self->{'.tmpfiles'}->{$$filehandle}= {
              hndl => $filehandle,
	      name => $tmpfile,
	      info => {%header},
	  };
	  push(@@{$self->{param}{$param}},$filehandle);
      }
    }
}
END_OF_FUNC

#####
# subroutine: read_multipart_related
#
# Read multipart/related data and store it into our parameters.  The
# first parameter sets the start of the data. The part identified by
# this Content-ID will not be stored as a file upload, but will be
# returned by this method.  All other parts will be available as file
# uploads accessible by their Content-ID
#####
'read_multipart_related' => <<'END_OF_FUNC',
sub read_multipart_related {
    my($self,$start,$boundary,$length) = @@_;
    my($buffer) = $self->new_MultipartBuffer($boundary,$length);
    return unless $buffer;
    my(%header,$body);
    my $filenumber = 0;
    my $returnvalue;
    while (!$buffer->eof) {
	%header = $buffer->readHeader;

	unless (%header) {
	    $self->cgi_error("400 Bad request (malformed multipart POST)");
	    return;
	}

	my($param) = $header{'Content-ID'}=~/\<([^\>]*)\>/;
        $param .= $TAINTED;

	# If this is the start part, then just read the data and assign it
	# to our return variable.
	if ( $param eq $start ) {
	    $returnvalue = $buffer->readBody;
            $returnvalue .= $TAINTED;
	    next;
	}

	# add this parameter to our list
	$self->add_parameter($param);

	my ($tmpfile,$tmp,$filehandle);
      UPLOADS: {
	  # If we get here, then we are dealing with a potentially large
	  # uploaded form.  Save the data to a temporary file, then open
	  # the file for reading.

	  # skip the file if uploads disabled
	  if ($DISABLE_UPLOADS) {
	      while (defined($data = $buffer->read)) { }
	      last UPLOADS;
	  }

	  # choose a relatively unpredictable tmpfile sequence number
          my $seqno = unpack("%16C*",join('',localtime,grep {defined $_} values %ENV));
          for (my $cnt=10;$cnt>0;$cnt--) {
	    next unless $tmpfile = new CGITempFile($seqno);
	    $tmp = $tmpfile->as_string;
	    last if defined($filehandle = Fh->new($param,$tmp,$PRIVATE_TEMPFILES));
            $seqno += int rand(100);
          }
          die "CGI open of tmpfile: $!\n" unless defined $filehandle;
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode 
                     && defined fileno($filehandle);

	  my ($data);
	  local($\) = '';
          my $totalbytes;
          while (defined($data = $buffer->read)) {
              if (defined $self->{'.upload_hook'})
               {
                  $totalbytes += length($data);
                   &{$self->{'.upload_hook'}}($param ,$data, $totalbytes, $self->{'.upload_data'});
              }
              print $filehandle $data if ($self->{'use_tempfile'});
          }

	  # back up to beginning of file
	  seek($filehandle,0,0);

      ## Close the filehandle if requested this allows a multipart MIME
      ## upload to contain many files, and we won't die due to too many
      ## open file handles. The user can access the files using the hash
      ## below.
      close $filehandle if $CLOSE_UPLOAD_FILES;
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode;

	  # Save some information about the uploaded file where we can get
	  # at it later.
	  # Use the typeglob as the key, as this is guaranteed to be
	  # unique for each filehandle.  Don't use the file descriptor as
	  # this will be re-used for each filehandle if the
	  # close_upload_files feature is used.
	  $self->{'.tmpfiles'}->{$$filehandle}= {
              hndl => $filehandle,
	      name => $tmpfile,
	      info => {%header},
	  };
	  push(@@{$self->{param}{$param}},$filehandle);
      }
    }
    return $returnvalue;
}
END_OF_FUNC


'upload' =><<'END_OF_FUNC',
sub upload {
    my($self,$param_name) = self_or_default(@@_);
    my @@param = grep {ref($_) && defined(fileno($_))} $self->param($param_name);
    return unless @@param;
    return wantarray ? @@param : $param[0];
}
END_OF_FUNC

'tmpFileName' => <<'END_OF_FUNC',
sub tmpFileName {
    my($self,$filename) = self_or_default(@@_);
    return $self->{'.tmpfiles'}->{$$filename}->{name} ?
	$self->{'.tmpfiles'}->{$$filename}->{name}->as_string
	    : '';
}
END_OF_FUNC

'uploadInfo' => <<'END_OF_FUNC',
sub uploadInfo {
    my($self,$filename) = self_or_default(@@_);
    return $self->{'.tmpfiles'}->{$$filename}->{info};
}
END_OF_FUNC

# internal routine, don't use
'_set_values_and_labels' => <<'END_OF_FUNC',
sub _set_values_and_labels {
    my $self = shift;
    my ($v,$l,$n) = @@_;
    $$l = $v if ref($v) eq 'HASH' && !ref($$l);
    return $self->param($n) if !defined($v);
    return $v if !ref($v);
    return ref($v) eq 'HASH' ? keys %$v : @@$v;
}
END_OF_FUNC

# internal routine, don't use
'_set_attributes' => <<'END_OF_FUNC',
sub _set_attributes {
    my $self = shift;
    my($element, $attributes) = @@_;
    return '' unless defined($attributes->{$element});
    $attribs = ' ';
    for my $attrib (keys %{$attributes->{$element}}) {
        (my $clean_attrib = $attrib) =~ s/^-//;
        $attribs .= "@@{[lc($clean_attrib)]}=\"$attributes->{$element}{$attrib}\" ";
    }
    $attribs =~ s/ $//;
    return $attribs;
}
END_OF_FUNC

'_compile_all' => <<'END_OF_FUNC',
sub _compile_all {
    for (@@_) {
	next if defined(&$_);
	$AUTOLOAD = "CGI::$_";
	_compile();
    }
}
END_OF_FUNC

);
END_OF_AUTOLOAD
;

#########################################################
# Globals and stubs for other packages that we use.
#########################################################

################### Fh -- lightweight filehandle ###############
package Fh;

use overload 
    '""'  => \&asString,
    'cmp' => \&compare,
    'fallback'=>1;

$FH='fh00000';

*Fh::AUTOLOAD = \&CGI::AUTOLOAD;

sub DESTROY {
    my $self = shift;
    close $self;
}

$AUTOLOADED_ROUTINES = '';      # prevent -w error
$AUTOLOADED_ROUTINES=<<'END_OF_AUTOLOAD';
%SUBS =  (
'asString' => <<'END_OF_FUNC',
sub asString {
    my $self = shift;
    # get rid of package name
    (my $i = $$self) =~ s/^\*(\w+::fh\d{5})+//; 
    $i =~ s/%(..)/ chr(hex($1)) /eg;
    return $i.$CGI::TAINTED;
# BEGIN DEAD CODE
# This was an extremely clever patch that allowed "use strict refs".
# Unfortunately it relied on another bug that caused leaky file descriptors.
# The underlying bug has been fixed, so this no longer works.  However
# "strict refs" still works for some reason.
#    my $self = shift;
#    return ${*{$self}{SCALAR}};
# END DEAD CODE
}
END_OF_FUNC

'compare' => <<'END_OF_FUNC',
sub compare {
    my $self = shift;
    my $value = shift;
    return "$self" cmp $value;
}
END_OF_FUNC

'new'  => <<'END_OF_FUNC',
sub new {
    my($pack,$name,$file,$delete) = @@_;
    _setup_symbols(@@SAVED_SYMBOLS) if @@SAVED_SYMBOLS;
    require Fcntl unless defined &Fcntl::O_RDWR;
    (my $safename = $name) =~ s/([':%])/ sprintf '%%%02X', ord $1 /eg;
    my $fv = ++$FH . $safename;
    my $ref = \*{"Fh::$fv"};
    $file =~ m!^([a-zA-Z0-9_\+ \'\":/.\$\\~-]+)$! || return;
    my $safe = $1;
    sysopen($ref,$safe,Fcntl::O_RDWR()|Fcntl::O_CREAT()|Fcntl::O_EXCL(),0600) || return;
    unlink($safe) if $delete;
    CORE::delete $Fh::{$fv};
    return bless $ref,$pack;
}
END_OF_FUNC

'handle' => <<'END_OF_FUNC',
sub handle {
  my $self = shift;
  eval "require IO::Handle" unless IO::Handle->can('new_from_fd');
  return IO::Handle->new_from_fd(fileno $self,"<");
}
END_OF_FUNC

);
END_OF_AUTOLOAD

######################## MultipartBuffer ####################
package MultipartBuffer;

use constant DEBUG => 0;

# how many bytes to read at a time.  We use
# a 4K buffer by default.
$INITIAL_FILLUNIT = 1024 * 4;
$TIMEOUT = 240*60;       # 4 hour timeout for big files
$SPIN_LOOP_MAX = 2000;  # bug fix for some Netscape servers
$CRLF=$CGI::CRLF;

#reuse the autoload function
*MultipartBuffer::AUTOLOAD = \&CGI::AUTOLOAD;

# avoid autoloader warnings
sub DESTROY {}

###############################################################################
################# THESE FUNCTIONS ARE AUTOLOADED ON DEMAND ####################
###############################################################################
$AUTOLOADED_ROUTINES = '';      # prevent -w error
$AUTOLOADED_ROUTINES=<<'END_OF_AUTOLOAD';
%SUBS =  (

'new' => <<'END_OF_FUNC',
sub new {
    my($package,$interface,$boundary,$length) = @@_;
    $FILLUNIT = $INITIAL_FILLUNIT;
    $CGI::DefaultClass->binmode($IN); # if $CGI::needs_binmode;  # just do it always

    # If the user types garbage into the file upload field,
    # then Netscape passes NOTHING to the server (not good).
    # We may hang on this read in that case. So we implement
    # a read timeout.  If nothing is ready to read
    # by then, we return.

    # Netscape seems to be a little bit unreliable
    # about providing boundary strings.
    my $boundary_read = 0;
    if ($boundary) {

	# Under the MIME spec, the boundary consists of the 
	# characters "--" PLUS the Boundary string

	# BUG: IE 3.01 on the Macintosh uses just the boundary -- not
	# the two extra hyphens.  We do a special case here on the user-agent!!!!
	$boundary = "--$boundary" unless CGI::user_agent('MSIE\s+3\.0[12];\s*Mac|DreamPassport');

    } else { # otherwise we find it ourselves
	my($old);
	($old,$/) = ($/,$CRLF); # read a CRLF-delimited line
	$boundary = <STDIN>;      # BUG: This won't work correctly under mod_perl
	$length -= length($boundary);
	chomp($boundary);               # remove the CRLF
	$/ = $old;                      # restore old line separator
        $boundary_read++;
    }

    my $self = {LENGTH=>$length,
		CHUNKED=>!$length,
		BOUNDARY=>$boundary,
		INTERFACE=>$interface,
		BUFFER=>'',
	    };

    $FILLUNIT = length($boundary)
	if length($boundary) > $FILLUNIT;

    my $retval = bless $self,ref $package || $package;

    # Read the preamble and the topmost (boundary) line plus the CRLF.
    unless ($boundary_read) {
      while ($self->read(0)) { }
    }
    die "Malformed multipart POST: data truncated\n" if $self->eof;

    return $retval;
}
END_OF_FUNC

'readHeader' => <<'END_OF_FUNC',
sub readHeader {
    my($self) = @@_;
    my($end);
    my($ok) = 0;
    my($bad) = 0;

    local($CRLF) = "\015\012" if $CGI::OS eq 'VMS' || $CGI::EBCDIC;

    do {
	$self->fillBuffer($FILLUNIT);
	$ok++ if ($end = index($self->{BUFFER},"${CRLF}${CRLF}")) >= 0;
	$ok++ if $self->{BUFFER} eq '';
	$bad++ if !$ok && $self->{LENGTH} <= 0;
	# this was a bad idea
	# $FILLUNIT *= 2 if length($self->{BUFFER}) >= $FILLUNIT; 
    } until $ok || $bad;
    return () if $bad;

    #EBCDIC NOTE: translate header into EBCDIC, but watch out for continuation lines!

    my($header) = substr($self->{BUFFER},0,$end+2);
    substr($self->{BUFFER},0,$end+4) = '';
    my %return;

    if ($CGI::EBCDIC) {
      warn "untranslated header=$header\n" if DEBUG;
      $header = CGI::Util::ascii2ebcdic($header);
      warn "translated header=$header\n" if DEBUG;
    }

    # See RFC 2045 Appendix A and RFC 822 sections 3.4.8
    #   (Folding Long Header Fields), 3.4.3 (Comments)
    #   and 3.4.5 (Quoted-Strings).

    my $token = '[-\w!\#$%&\'*+.^_\`|{}~]';
    $header=~s/$CRLF\s+/ /og;		# merge continuation lines

    while ($header=~/($token+):\s+([^$CRLF]*)/mgox) {
        my ($field_name,$field_value) = ($1,$2);
	$field_name =~ s/\b(\w)/uc($1)/eg; #canonicalize
	$return{$field_name}=$field_value;
    }
    return %return;
}
END_OF_FUNC

# This reads and returns the body as a single scalar value.
'readBody' => <<'END_OF_FUNC',
sub readBody {
    my($self) = @@_;
    my($data);
    my($returnval)='';

    #EBCDIC NOTE: want to translate returnval into EBCDIC HERE

    while (defined($data = $self->read)) {
	$returnval .= $data;
    }

    if ($CGI::EBCDIC) {
      warn "untranslated body=$returnval\n" if DEBUG;
      $returnval = CGI::Util::ascii2ebcdic($returnval);
      warn "translated body=$returnval\n"   if DEBUG;
    }
    return $returnval;
}
END_OF_FUNC

# This will read $bytes or until the boundary is hit, whichever happens
# first.  After the boundary is hit, we return undef.  The next read will
# skip over the boundary and begin reading again;
'read' => <<'END_OF_FUNC',
sub read {
    my($self,$bytes) = @@_;

    # default number of bytes to read
    $bytes = $bytes || $FILLUNIT;

    # Fill up our internal buffer in such a way that the boundary
    # is never split between reads.
    $self->fillBuffer($bytes);

    my $boundary_start = $CGI::EBCDIC ? CGI::Util::ebcdic2ascii($self->{BOUNDARY})      : $self->{BOUNDARY};
    my $boundary_end   = $CGI::EBCDIC ? CGI::Util::ebcdic2ascii($self->{BOUNDARY}.'--') : $self->{BOUNDARY}.'--';

    # Find the boundary in the buffer (it may not be there).
    my $start = index($self->{BUFFER},$boundary_start);

    warn "boundary=$self->{BOUNDARY} length=$self->{LENGTH} start=$start\n" if DEBUG;

    # protect against malformed multipart POST operations
    die "Malformed multipart POST\n" unless $self->{CHUNKED} || ($start >= 0 || $self->{LENGTH} > 0);

    #EBCDIC NOTE: want to translate boundary search into ASCII here.

    # If the boundary begins the data, then skip past it
    # and return undef.
    if ($start == 0) {

	# clear us out completely if we've hit the last boundary.
	if (index($self->{BUFFER},$boundary_end)==0) {
	    $self->{BUFFER}='';
	    $self->{LENGTH}=0;
	    return undef;
	}

	# just remove the boundary.
	substr($self->{BUFFER},0,length($boundary_start))='';
        $self->{BUFFER} =~ s/^\012\015?//;
	return undef;
    }

    my $bytesToReturn;
    if ($start > 0) {           # read up to the boundary
        $bytesToReturn = $start-2 > $bytes ? $bytes : $start;
    } else {    # read the requested number of bytes
	# leave enough bytes in the buffer to allow us to read
	# the boundary.  Thanks to Kevin Hendrick for finding
	# this one.
	$bytesToReturn = $bytes - (length($boundary_start)+1);
    }

    my $returnval=substr($self->{BUFFER},0,$bytesToReturn);
    substr($self->{BUFFER},0,$bytesToReturn)='';
    
    # If we hit the boundary, remove the CRLF from the end.
    return ($bytesToReturn==$start)
           ? substr($returnval,0,-2) : $returnval;
}
END_OF_FUNC


# This fills up our internal buffer in such a way that the
# boundary is never split between reads
'fillBuffer' => <<'END_OF_FUNC',
sub fillBuffer {
    my($self,$bytes) = @@_;
    return unless $self->{CHUNKED} || $self->{LENGTH};

    my($boundaryLength) = length($self->{BOUNDARY});
    my($bufferLength) = length($self->{BUFFER});
    my($bytesToRead) = $bytes - $bufferLength + $boundaryLength + 2;
    $bytesToRead = $self->{LENGTH} if !$self->{CHUNKED} && $self->{LENGTH} < $bytesToRead;

    # Try to read some data.  We may hang here if the browser is screwed up.
    my $bytesRead = $self->{INTERFACE}->read_from_client(\$self->{BUFFER},
							 $bytesToRead,
							 $bufferLength);
    warn "bytesToRead=$bytesToRead, bufferLength=$bufferLength, buffer=$self->{BUFFER}\n" if DEBUG;
    $self->{BUFFER} = '' unless defined $self->{BUFFER};

    # An apparent bug in the Apache server causes the read()
    # to return zero bytes repeatedly without blocking if the
    # remote user aborts during a file transfer.  I don't know how
    # they manage this, but the workaround is to abort if we get
    # more than SPIN_LOOP_MAX consecutive zero reads.
    if ($bytesRead <= 0) {
	die  "CGI.pm: Server closed socket during multipart read (client aborted?).\n"
	    if ($self->{ZERO_LOOP_COUNTER}++ >= $SPIN_LOOP_MAX);
    } else {
	$self->{ZERO_LOOP_COUNTER}=0;
    }

    $self->{LENGTH} -= $bytesRead if !$self->{CHUNKED} && $bytesRead;
}
END_OF_FUNC


# Return true when we've finished reading
'eof' => <<'END_OF_FUNC'
sub eof {
    my($self) = @@_;
    return 1 if (length($self->{BUFFER}) == 0)
		 && ($self->{LENGTH} <= 0);
    undef;
}
END_OF_FUNC

);
END_OF_AUTOLOAD

####################################################################################
################################## TEMPORARY FILES #################################
####################################################################################
package CGITempFile;

sub find_tempdir {
  $SL = $CGI::SL;
  $MAC = $CGI::OS eq 'MACINTOSH';
  my ($vol) = $MAC ? MacPerl::Volumes() =~ /:(.*)/ : "";
  unless (defined $TMPDIRECTORY) {
    @@TEMP=("${SL}usr${SL}tmp","${SL}var${SL}tmp",
	   "C:${SL}temp","${SL}tmp","${SL}temp",
	   "${vol}${SL}Temporary Items",
           "${SL}WWW_ROOT", "${SL}SYS\$SCRATCH",
	   "C:${SL}system${SL}temp");
    
    if( $CGI::OS eq 'WINDOWS' ){
       unshift @@TEMP,
           $ENV{TEMP},
           $ENV{TMP},
           $ENV{WINDIR} . $SL . 'TEMP';
    }

    unshift(@@TEMP,$ENV{'TMPDIR'}) if defined $ENV{'TMPDIR'};

    # this feature was supposed to provide per-user tmpfiles, but
    # it is problematic.
    #    unshift(@@TEMP,(getpwuid($<))[7].'/tmp') if $CGI::OS eq 'UNIX';
    # Rob: getpwuid() is unfortunately UNIX specific. On brain dead OS'es this
    #    : can generate a 'getpwuid() not implemented' exception, even though
    #    : it's never called.  Found under DOS/Win with the DJGPP perl port.
    #    : Refer to getpwuid() only at run-time if we're fortunate and have  UNIX.
    # unshift(@@TEMP,(eval {(getpwuid($>))[7]}).'/tmp') if $CGI::OS eq 'UNIX' and $> != 0;

    for (@@TEMP) {
      do {$TMPDIRECTORY = $_; last} if -d $_ && -w _;
    }
  }
  $TMPDIRECTORY  = $MAC ? "" : "." unless $TMPDIRECTORY;
}

find_tempdir();

$MAXTRIES = 5000;

# cute feature, but overload implementation broke it
# %OVERLOAD = ('""'=>'as_string');
*CGITempFile::AUTOLOAD = \&CGI::AUTOLOAD;

sub DESTROY {
    my($self) = @@_;
    $$self =~ m!^([a-zA-Z0-9_ \'\":/.\$\\~-]+)$! || return;
    my $safe = $1;             # untaint operation
    unlink $safe;              # get rid of the file
}

###############################################################################
################# THESE FUNCTIONS ARE AUTOLOADED ON DEMAND ####################
###############################################################################
$AUTOLOADED_ROUTINES = '';      # prevent -w error
$AUTOLOADED_ROUTINES=<<'END_OF_AUTOLOAD';
%SUBS = (

'new' => <<'END_OF_FUNC',
sub new {
    my($package,$sequence) = @@_;
    my $filename;
    find_tempdir() unless -w $TMPDIRECTORY;
    for (my $i = 0; $i < $MAXTRIES; $i++) {
	last if ! -f ($filename = sprintf("\%s${SL}CGItemp%d", $TMPDIRECTORY, $sequence++));
    }
    # check that it is a more-or-less valid filename
    return unless $filename =~ m!^([a-zA-Z0-9_\+ \'\":/.\$\\~-]+)$!;
    # this used to untaint, now it doesn't
    # $filename = $1;
    return bless \$filename;
}
END_OF_FUNC

'as_string' => <<'END_OF_FUNC'
sub as_string {
    my($self) = @@_;
    return $$self;
}
END_OF_FUNC

);
END_OF_AUTOLOAD

package CGI;

# We get a whole bunch of warnings about "possibly uninitialized variables"
# when running with the -w switch.  Touch them all once to get rid of the
# warnings.  This is ugly and I hate it.
if ($^W) {
    $CGI::CGI = '';
    $CGI::CGI=<<EOF;
    $CGI::VERSION;
    $MultipartBuffer::SPIN_LOOP_MAX;
    $MultipartBuffer::CRLF;
    $MultipartBuffer::TIMEOUT;
    $MultipartBuffer::INITIAL_FILLUNIT;
EOF
    ;
}

1;

__END__

=head1 NAME

CGI - Handle Common Gateway Interface requests and responses

=head1 SYNOPSIS

    use CGI;

    my $q = CGI->new;

    # Process an HTTP request
     @@values  = $q->param('form_field');

     $fh      = $q->upload('file_field');

     $riddle  = $query->cookie('riddle_name');
     %answers = $query->cookie('answers');

    # Prepare various HTTP responses
    print $q->header();
    print $q->header('application/json');

	$cookie1 = $q->cookie(-name=>'riddle_name', -value=>"The Sphynx's Question");
	$cookie2 = $q->cookie(-name=>'answers', -value=>\%answers);
    print $q->header(
        -type    => 'image/gif',
        -expires => '+3d',
        -cookie  => [$cookie1,$cookie2]
        );

   print  $q->redirect('http://somewhere.else/in/movie/land');

=head1 DESCRIPTION

CGI.pm is a stable, complete and mature solution for processing and preparing
HTTP requests and responses.  Major features including processing form
submissions, file uploads, reading and writing cookies, query string generation
and manipulation, and processing and preparing HTTP headers. Some HTML
generation utilities are included as well.

CGI.pm performs very well in in a vanilla CGI.pm environment and also comes
with built-in support for mod_perl and mod_perl2 as well as FastCGI.

It has the benefit of having developed and refined over 10 years with input
from dozens of contributors and being deployed on thousands of websites.
CGI.pm has been included in the Perl distribution since Perl 5.4, and has
become a de-facto standard.

=head2 PROGRAMMING STYLE

There are two styles of programming with CGI.pm, an object-oriented
style and a function-oriented style.  In the object-oriented style you
create one or more CGI objects and then use object methods to create
the various elements of the page.  Each CGI object starts out with the
list of named parameters that were passed to your CGI script by the
server.  You can modify the objects, save them to a file or database
and recreate them.  Because each object corresponds to the "state" of
the CGI script, and because each object's parameter list is
independent of the others, this allows you to save the state of the
script and restore it later.

For example, using the object oriented style, here is how you create
a simple "Hello World" HTML page:

   #!/usr/local/bin/perl -w
   use CGI;                             # load CGI routines
   $q = new CGI;                        # create new CGI object
   print $q->header,                    # create the HTTP header
         $q->start_html('hello world'), # start the HTML
         $q->h1('hello world'),         # level 1 header
         $q->end_html;                  # end the HTML

In the function-oriented style, there is one default CGI object that
you rarely deal with directly.  Instead you just call functions to
retrieve CGI parameters, create HTML tags, manage cookies, and so
on.  This provides you with a cleaner programming interface, but
limits you to using one CGI object at a time.  The following example
prints the same page, but uses the function-oriented interface.
The main differences are that we now need to import a set of functions
into our name space (usually the "standard" functions), and we don't
need to create the CGI object.

   #!/usr/local/bin/perl
   use CGI qw/:standard/;           # load standard CGI routines
   print header,                    # create the HTTP header
         start_html('hello world'), # start the HTML
         h1('hello world'),         # level 1 header
         end_html;                  # end the HTML

The examples in this document mainly use the object-oriented style.
See HOW TO IMPORT FUNCTIONS for important information on
function-oriented programming in CGI.pm

=head2 CALLING CGI.PM ROUTINES

Most CGI.pm routines accept several arguments, sometimes as many as 20
optional ones!  To simplify this interface, all routines use a named
argument calling style that looks like this:

   print $q->header(-type=>'image/gif',-expires=>'+3d');

Each argument name is preceded by a dash.  Neither case nor order
matters in the argument list.  -type, -Type, and -TYPE are all
acceptable.  In fact, only the first argument needs to begin with a
dash.  If a dash is present in the first argument, CGI.pm assumes
dashes for the subsequent ones.

Several routines are commonly called with just one argument.  In the
case of these routines you can provide the single argument without an
argument name.  header() happens to be one of these routines.  In this
case, the single argument is the document type.

   print $q->header('text/html');

Other such routines are documented below.

Sometimes named arguments expect a scalar, sometimes a reference to an
array, and sometimes a reference to a hash.  Often, you can pass any
type of argument and the routine will do whatever is most appropriate.
For example, the param() routine is used to set a CGI parameter to a
single or a multi-valued value.  The two cases are shown below:

   $q->param(-name=>'veggie',-value=>'tomato');
   $q->param(-name=>'veggie',-value=>['tomato','tomahto','potato','potahto']);

A large number of routines in CGI.pm actually aren't specifically
defined in the module, but are generated automatically as needed.
These are the "HTML shortcuts," routines that generate HTML tags for
use in dynamically-generated pages.  HTML tags have both attributes
(the attribute="value" pairs within the tag itself) and contents (the
part between the opening and closing pairs.)  To distinguish between
attributes and contents, CGI.pm uses the convention of passing HTML
attributes as a hash reference as the first argument, and the
contents, if any, as any subsequent arguments.  It works out like
this:

   Code                           Generated HTML
   ----                           --------------
   h1()                           <h1>
   h1('some','contents');         <h1>some contents</h1>
   h1({-align=>left});            <h1 align="LEFT">
   h1({-align=>left},'contents'); <h1 align="LEFT">contents</h1>

HTML tags are described in more detail later.

Many newcomers to CGI.pm are puzzled by the difference between the
calling conventions for the HTML shortcuts, which require curly braces
around the HTML tag attributes, and the calling conventions for other
routines, which manage to generate attributes without the curly
brackets.  Don't be confused.  As a convenience the curly braces are
optional in all but the HTML shortcuts.  If you like, you can use
curly braces when calling any routine that takes named arguments.  For
example:

   print $q->header( {-type=>'image/gif',-expires=>'+3d'} );

If you use the B<-w> switch, you will be warned that some CGI.pm argument
names conflict with built-in Perl functions.  The most frequent of
these is the -values argument, used to create multi-valued menus,
radio button clusters and the like.  To get around this warning, you
have several choices:

=over 4

=item 1.

Use another name for the argument, if one is available. 
For example, -value is an alias for -values.

=item 2.

Change the capitalization, e.g. -Values

=item 3.

Put quotes around the argument name, e.g. '-values'

=back

Many routines will do something useful with a named argument that it
doesn't recognize.  For example, you can produce non-standard HTTP
header fields by providing them as named arguments:

  print $q->header(-type  =>  'text/html',
                   -cost  =>  'Three smackers',
                   -annoyance_level => 'high',
                   -complaints_to   => 'bit bucket');

This will produce the following nonstandard HTTP header:

   HTTP/1.0 200 OK
   Cost: Three smackers
   Annoyance-level: high
   Complaints-to: bit bucket
   Content-type: text/html

Notice the way that underscores are translated automatically into
hyphens.  HTML-generating routines perform a different type of
translation. 

This feature allows you to keep up with the rapidly changing HTTP and
HTML "standards".

=head2 CREATING A NEW QUERY OBJECT (OBJECT-ORIENTED STYLE):

     $query = new CGI;

This will parse the input (from both POST and GET methods) and store
it into a perl5 object called $query. 

Any filehandles from file uploads will have their position reset to 
the beginning of the file. 

=head2 CREATING A NEW QUERY OBJECT FROM AN INPUT FILE

     $query = new CGI(INPUTFILE);

If you provide a file handle to the new() method, it will read
parameters from the file (or STDIN, or whatever).  The file can be in
any of the forms describing below under debugging (i.e. a series of
newline delimited TAG=VALUE pairs will work).  Conveniently, this type
of file is created by the save() method (see below).  Multiple records
can be saved and restored.

Perl purists will be pleased to know that this syntax accepts
references to file handles, or even references to filehandle globs,
which is the "official" way to pass a filehandle:

    $query = new CGI(\*STDIN);

You can also initialize the CGI object with a FileHandle or IO::File
object.

If you are using the function-oriented interface and want to
initialize CGI state from a file handle, the way to do this is with
B<restore_parameters()>.  This will (re)initialize the
default CGI object from the indicated file handle.

    open (IN,"test.in") || die;
    restore_parameters(IN);
    close IN;

You can also initialize the query object from a hash
reference:

    $query = new CGI( {'dinosaur'=>'barney',
		       'song'=>'I love you',
		       'friends'=>[qw/Jessica George Nancy/]}
		    );

or from a properly formatted, URL-escaped query string:

    $query = new CGI('dinosaur=barney&color=purple');

or from a previously existing CGI object (currently this clones the
parameter list, but none of the other object-specific fields, such as
autoescaping):

    $old_query = new CGI;
    $new_query = new CGI($old_query);

To create an empty query, initialize it from an empty string or hash:

   $empty_query = new CGI("");

       -or-

   $empty_query = new CGI({});

=head2 FETCHING A LIST OF KEYWORDS FROM THE QUERY:

     @@keywords = $query->keywords

If the script was invoked as the result of an <ISINDEX> search, the
parsed keywords can be obtained as an array using the keywords() method.

=head2 FETCHING THE NAMES OF ALL THE PARAMETERS PASSED TO YOUR SCRIPT:

     @@names = $query->param

If the script was invoked with a parameter list
(e.g. "name1=value1&name2=value2&name3=value3"), the param() method
will return the parameter names as a list.  If the script was invoked
as an <ISINDEX> script and contains a string without ampersands
(e.g. "value1+value2+value3") , there will be a single parameter named
"keywords" containing the "+"-delimited keywords.

NOTE: As of version 1.5, the array of parameter names returned will
be in the same order as they were submitted by the browser.
Usually this order is the same as the order in which the 
parameters are defined in the form (however, this isn't part
of the spec, and so isn't guaranteed).

=head2 FETCHING THE VALUE OR VALUES OF A SINGLE NAMED PARAMETER:

    @@values = $query->param('foo');

	      -or-

    $value = $query->param('foo');

Pass the param() method a single argument to fetch the value of the
named parameter. If the parameter is multivalued (e.g. from multiple
selections in a scrolling list), you can ask to receive an array.  Otherwise
the method will return a single value.

If a value is not given in the query string, as in the queries
"name1=&name2=", it will be returned as an empty string.


If the parameter does not exist at all, then param() will return undef
in a scalar context, and the empty list in a list context.


=head2 SETTING THE VALUE(S) OF A NAMED PARAMETER:

    $query->param('foo','an','array','of','values');

This sets the value for the named parameter 'foo' to an array of
values.  This is one way to change the value of a field AFTER
the script has been invoked once before.  (Another way is with
the -override parameter accepted by all methods that generate
form elements.)

param() also recognizes a named parameter style of calling described
in more detail later:

    $query->param(-name=>'foo',-values=>['an','array','of','values']);

			      -or-

    $query->param(-name=>'foo',-value=>'the value');

=head2 APPENDING ADDITIONAL VALUES TO A NAMED PARAMETER:

   $query->append(-name=>'foo',-values=>['yet','more','values']);

This adds a value or list of values to the named parameter.  The
values are appended to the end of the parameter if it already exists.
Otherwise the parameter is created.  Note that this method only
recognizes the named argument calling syntax.

=head2 IMPORTING ALL PARAMETERS INTO A NAMESPACE:

   $query->import_names('R');

This creates a series of variables in the 'R' namespace.  For example,
$R::foo, @@R:foo.  For keyword lists, a variable @@R::keywords will appear.
If no namespace is given, this method will assume 'Q'.
WARNING:  don't import anything into 'main'; this is a major security
risk!!!!

NOTE 1: Variable names are transformed as necessary into legal Perl
variable names.  All non-legal characters are transformed into
underscores.  If you need to keep the original names, you should use
the param() method instead to access CGI variables by name.

NOTE 2: In older versions, this method was called B<import()>.  As of version 2.20, 
this name has been removed completely to avoid conflict with the built-in
Perl module B<import> operator.

=head2 DELETING A PARAMETER COMPLETELY:

    $query->delete('foo','bar','baz');

This completely clears a list of parameters.  It sometimes useful for
resetting parameters that you don't want passed down between script
invocations.

If you are using the function call interface, use "Delete()" instead
to avoid conflicts with Perl's built-in delete operator.

=head2 DELETING ALL PARAMETERS:

   $query->delete_all();

This clears the CGI object completely.  It might be useful to ensure
that all the defaults are taken when you create a fill-out form.

Use Delete_all() instead if you are using the function call interface.

=head2 HANDLING NON-URLENCODED ARGUMENTS


If POSTed data is not of type application/x-www-form-urlencoded or
multipart/form-data, then the POSTed data will not be processed, but
instead be returned as-is in a parameter named POSTDATA.  To retrieve
it, use code like this:

   my $data = $query->param('POSTDATA');

Likewise if PUTed data can be retrieved with code like this:

   my $data = $query->param('PUTDATA');

(If you don't know what the preceding means, don't worry about it.  It
only affects people trying to use CGI for XML processing and other
specialized tasks.)


=head2 DIRECT ACCESS TO THE PARAMETER LIST:

   $q->param_fetch('address')->[1] = '1313 Mockingbird Lane';
   unshift @@{$q->param_fetch(-name=>'address')},'George Munster';

If you need access to the parameter list in a way that isn't covered
by the methods above, you can obtain a direct reference to it by
calling the B<param_fetch()> method with the name of the .  This
will return an array reference to the named parameters, which you then
can manipulate in any way you like.

You can also use a named argument style using the B<-name> argument.

=head2 FETCHING THE PARAMETER LIST AS A HASH:

    $params = $q->Vars;
    print $params->{'address'};
    @@foo = split("\0",$params->{'foo'});
    %params = $q->Vars;

    use CGI ':cgi-lib';
    $params = Vars;

Many people want to fetch the entire parameter list as a hash in which
the keys are the names of the CGI parameters, and the values are the
parameters' values.  The Vars() method does this.  Called in a scalar
context, it returns the parameter list as a tied hash reference.
Changing a key changes the value of the parameter in the underlying
CGI parameter list.  Called in a list context, it returns the
parameter list as an ordinary hash.  This allows you to read the
contents of the parameter list, but not to change it.

When using this, the thing you must watch out for are multivalued CGI
parameters.  Because a hash cannot distinguish between scalar and
list context, multivalued parameters will be returned as a packed
string, separated by the "\0" (null) character.  You must split this
packed string in order to get at the individual values.  This is the
convention introduced long ago by Steve Brenner in his cgi-lib.pl
module for Perl version 4.

If you wish to use Vars() as a function, import the I<:cgi-lib> set of
function calls (also see the section on CGI-LIB compatibility).

=head2 SAVING THE STATE OF THE SCRIPT TO A FILE:

    $query->save(\*FILEHANDLE)

This will write the current state of the form to the provided
filehandle.  You can read it back in by providing a filehandle
to the new() method.  Note that the filehandle can be a file, a pipe,
or whatever!

The format of the saved file is:

	NAME1=VALUE1
	NAME1=VALUE1'
	NAME2=VALUE2
	NAME3=VALUE3
	=

Both name and value are URL escaped.  Multi-valued CGI parameters are
represented as repeated names.  A session record is delimited by a
single = symbol.  You can write out multiple records and read them
back in with several calls to B<new>.  You can do this across several
sessions by opening the file in append mode, allowing you to create
primitive guest books, or to keep a history of users' queries.  Here's
a short example of creating multiple session records:

   use CGI;

   open (OUT,">>test.out") || die;
   $records = 5;
   for (0..$records) {
       my $q = new CGI;
       $q->param(-name=>'counter',-value=>$_);
       $q->save(\*OUT);
   }
   close OUT;

   # reopen for reading
   open (IN,"test.out") || die;
   while (!eof(IN)) {
       my $q = new CGI(\*IN);
       print $q->param('counter'),"\n";
   }

The file format used for save/restore is identical to that used by the
Whitehead Genome Center's data exchange format "Boulderio", and can be
manipulated and even databased using Boulderio utilities.  See

  http://stein.cshl.org/boulder/

for further details.

If you wish to use this method from the function-oriented (non-OO)
interface, the exported name for this method is B<save_parameters()>.

=head2 RETRIEVING CGI ERRORS

Errors can occur while processing user input, particularly when
processing uploaded files.  When these errors occur, CGI will stop
processing and return an empty parameter list.  You can test for
the existence and nature of errors using the I<cgi_error()> function.
The error messages are formatted as HTTP status codes. You can either
incorporate the error text into an HTML page, or use it as the value
of the HTTP status:

    my $error = $q->cgi_error;
    if ($error) {
	print $q->header(-status=>$error),
	      $q->start_html('Problems'),
              $q->h2('Request not processed'),
	      $q->strong($error);
        exit 0;
    }

When using the function-oriented interface (see the next section),
errors may only occur the first time you call I<param()>. Be ready
for this!

=head2 USING THE FUNCTION-ORIENTED INTERFACE

To use the function-oriented interface, you must specify which CGI.pm
routines or sets of routines to import into your script's namespace.
There is a small overhead associated with this importation, but it
isn't much.

   use CGI <list of methods>;

The listed methods will be imported into the current package; you can
call them directly without creating a CGI object first.  This example
shows how to import the B<param()> and B<header()>
methods, and then use them directly:

   use CGI 'param','header';
   print header('text/plain');
   $zipcode = param('zipcode');

More frequently, you'll import common sets of functions by referring
to the groups by name.  All function sets are preceded with a ":"
character as in ":html3" (for tags defined in the HTML 3 standard).

Here is a list of the function sets you can import:

=over 4

=item B<:cgi>

Import all CGI-handling methods, such as B<param()>, B<path_info()>
and the like.

=item B<:form>

Import all fill-out form generating methods, such as B<textfield()>.

=item B<:html2>

Import all methods that generate HTML 2.0 standard elements.

=item B<:html3>

Import all methods that generate HTML 3.0 elements (such as
<table>, <super> and <sub>).

=item B<:html4>

Import all methods that generate HTML 4 elements (such as
<abbrev>, <acronym> and <thead>).

=item B<:netscape>

Import all methods that generate Netscape-specific HTML extensions.

=item B<:html>

Import all HTML-generating shortcuts (i.e. 'html2' + 'html3' +
'netscape')...

=item B<:standard>

Import "standard" features, 'html2', 'html3', 'html4', 'form' and 'cgi'.

=item B<:all>

Import all the available methods.  For the full list, see the CGI.pm
code, where the variable %EXPORT_TAGS is defined.

=back

If you import a function name that is not part of CGI.pm, the module
will treat it as a new HTML tag and generate the appropriate
subroutine.  You can then use it like any other HTML tag.  This is to
provide for the rapidly-evolving HTML "standard."  For example, say
Microsoft comes out with a new tag called <gradient> (which causes the
user's desktop to be flooded with a rotating gradient fill until his
machine reboots).  You don't need to wait for a new version of CGI.pm
to start using it immediately:

   use CGI qw/:standard :html3 gradient/;
   print gradient({-start=>'red',-end=>'blue'});

Note that in the interests of execution speed CGI.pm does B<not> use
the standard L<Exporter> syntax for specifying load symbols.  This may
change in the future.

If you import any of the state-maintaining CGI or form-generating
methods, a default CGI object will be created and initialized
automatically the first time you use any of the methods that require
one to be present.  This includes B<param()>, B<textfield()>,
B<submit()> and the like.  (If you need direct access to the CGI
object, you can find it in the global variable B<$CGI::Q>).  By
importing CGI.pm methods, you can create visually elegant scripts:

   use CGI qw/:standard/;
   print 
       header,
       start_html('Simple Script'),
       h1('Simple Script'),
       start_form,
       "What's your name? ",textfield('name'),p,
       "What's the combination?",
       checkbox_group(-name=>'words',
		      -values=>['eenie','meenie','minie','moe'],
		      -defaults=>['eenie','moe']),p,
       "What's your favorite color?",
       popup_menu(-name=>'color',
		  -values=>['red','green','blue','chartreuse']),p,
       submit,
       end_form,
       hr,"\n";

    if (param) {
       print 
	   "Your name is ",em(param('name')),p,
	   "The keywords are: ",em(join(", ",param('words'))),p,
	   "Your favorite color is ",em(param('color')),".\n";
    }
    print end_html;

=head2 PRAGMAS

In addition to the function sets, there are a number of pragmas that
you can import.  Pragmas, which are always preceded by a hyphen,
change the way that CGI.pm functions in various ways.  Pragmas,
function sets, and individual functions can all be imported in the
same use() line.  For example, the following use statement imports the
standard set of functions and enables debugging mode (pragma
-debug):

   use CGI qw/:standard -debug/;

The current list of pragmas is as follows:

=over 4

=item -any

When you I<use CGI -any>, then any method that the query object
doesn't recognize will be interpreted as a new HTML tag.  This allows
you to support the next I<ad hoc> Netscape or Microsoft HTML
extension.  This lets you go wild with new and unsupported tags:

   use CGI qw(-any);
   $q=new CGI;
   print $q->gradient({speed=>'fast',start=>'red',end=>'blue'});

Since using <cite>any</cite> causes any mistyped method name
to be interpreted as an HTML tag, use it with care or not at
all.

=item -compile

This causes the indicated autoloaded methods to be compiled up front,
rather than deferred to later.  This is useful for scripts that run
for an extended period of time under FastCGI or mod_perl, and for
those destined to be crunched by Malcolm Beattie's Perl compiler.  Use
it in conjunction with the methods or method families you plan to use.

   use CGI qw(-compile :standard :html3);

or even

   use CGI qw(-compile :all);

Note that using the -compile pragma in this way will always have
the effect of importing the compiled functions into the current
namespace.  If you want to compile without importing use the
compile() method instead:

   use CGI();
   CGI->compile();

This is particularly useful in a mod_perl environment, in which you
might want to precompile all CGI routines in a startup script, and
then import the functions individually in each mod_perl script.

=item -nosticky

By default the CGI module implements a state-preserving behavior
called "sticky" fields.  The way this works is that if you are
regenerating a form, the methods that generate the form field values
will interrogate param() to see if similarly-named parameters are
present in the query string. If they find a like-named parameter, they
will use it to set their default values.

Sometimes this isn't what you want.  The B<-nosticky> pragma prevents
this behavior.  You can also selectively change the sticky behavior in
each element that you generate.

=item -tabindex

Automatically add tab index attributes to each form field. With this
option turned off, you can still add tab indexes manually by passing a
-tabindex option to each field-generating method.

=item -no_undef_params

This keeps CGI.pm from including undef params in the parameter list.

=item -no_xhtml

By default, CGI.pm versions 2.69 and higher emit XHTML
(http://www.w3.org/TR/xhtml1/).  The -no_xhtml pragma disables this
feature.  Thanks to Michalis Kabrianis <kabrianis@@hellug.gr> for this
feature.

If start_html()'s -dtd parameter specifies an HTML 2.0 or 3.2 DTD, 
XHTML will automatically be disabled without needing to use this 
pragma.

=item -utf8

This makes CGI.pm treat all parameters as UTF-8 strings. Use this with
care, as it will interfere with the processing of binary uploads. It
is better to manually select which fields are expected to return utf-8
strings and convert them using code like this:

 use Encode;
 my $arg = decode utf8=>param('foo');

=item -nph

This makes CGI.pm produce a header appropriate for an NPH (no
parsed header) script.  You may need to do other things as well
to tell the server that the script is NPH.  See the discussion
of NPH scripts below.

=item -newstyle_urls

Separate the name=value pairs in CGI parameter query strings with
semicolons rather than ampersands.  For example:

   ?name=fred;age=24;favorite_color=3

Semicolon-delimited query strings are always accepted, but will not be
emitted by self_url() and query_string() unless the -newstyle_urls
pragma is specified.

This became the default in version 2.64.

=item -oldstyle_urls

Separate the name=value pairs in CGI parameter query strings with
ampersands rather than semicolons.  This is no longer the default.

=item -autoload

This overrides the autoloader so that any function in your program
that is not recognized is referred to CGI.pm for possible evaluation.
This allows you to use all the CGI.pm functions without adding them to
your symbol table, which is of concern for mod_perl users who are
worried about memory consumption.  I<Warning:> when
I<-autoload> is in effect, you cannot use "poetry mode"
(functions without the parenthesis).  Use I<hr()> rather
than I<hr>, or add something like I<use subs qw/hr p header/> 
to the top of your script.

=item -no_debug

This turns off the command-line processing features.  If you want to
run a CGI.pm script from the command line to produce HTML, and you
don't want it to read CGI parameters from the command line or STDIN,
then use this pragma:

   use CGI qw(-no_debug :standard);

=item -debug

This turns on full debugging.  In addition to reading CGI arguments
from the command-line processing, CGI.pm will pause and try to read
arguments from STDIN, producing the message "(offline mode: enter
name=value pairs on standard input)" features.

See the section on debugging for more details.

=item -private_tempfiles

CGI.pm can process uploaded file. Ordinarily it spools the uploaded
file to a temporary directory, then deletes the file when done.
However, this opens the risk of eavesdropping as described in the file
upload section.  Another CGI script author could peek at this data
during the upload, even if it is confidential information. On Unix
systems, the -private_tempfiles pragma will cause the temporary file
to be unlinked as soon as it is opened and before any data is written
into it, reducing, but not eliminating the risk of eavesdropping
(there is still a potential race condition).  To make life harder for
the attacker, the program chooses tempfile names by calculating a 32
bit checksum of the incoming HTTP headers.

To ensure that the temporary file cannot be read by other CGI scripts,
use suEXEC or a CGI wrapper program to run your script.  The temporary
file is created with mode 0600 (neither world nor group readable).

The temporary directory is selected using the following algorithm:

    1. if the current user (e.g. "nobody") has a directory named
    "tmp" in its home directory, use that (Unix systems only).

    2. if the environment variable TMPDIR exists, use the location
    indicated.

    3. Otherwise try the locations /usr/tmp, /var/tmp, C:\temp,
    /tmp, /temp, ::Temporary Items, and \WWW_ROOT.

Each of these locations is checked that it is a directory and is
writable.  If not, the algorithm tries the next choice.

=back

=head2 SPECIAL FORMS FOR IMPORTING HTML-TAG FUNCTIONS

Many of the methods generate HTML tags.  As described below, tag
functions automatically generate both the opening and closing tags.
For example:

  print h1('Level 1 Header');

produces

  <h1>Level 1 Header</h1>

There will be some times when you want to produce the start and end
tags yourself.  In this case, you can use the form start_I<tag_name>
and end_I<tag_name>, as in:

  print start_h1,'Level 1 Header',end_h1;

With a few exceptions (described below), start_I<tag_name> and
end_I<tag_name> functions are not generated automatically when you
I<use CGI>.  However, you can specify the tags you want to generate
I<start/end> functions for by putting an asterisk in front of their
name, or, alternatively, requesting either "start_I<tag_name>" or
"end_I<tag_name>" in the import list.

Example:

  use CGI qw/:standard *table start_ul/;

In this example, the following functions are generated in addition to
the standard ones:

=over 4

=item 1. start_table() (generates a <table> tag)

=item 2. end_table() (generates a </table> tag)

=item 3. start_ul() (generates a <ul> tag)

=item 4. end_ul() (generates a </ul> tag)

=back

=head1 GENERATING DYNAMIC DOCUMENTS

Most of CGI.pm's functions deal with creating documents on the fly.
Generally you will produce the HTTP header first, followed by the
document itself.  CGI.pm provides functions for generating HTTP
headers of various types as well as for generating HTML.  For creating
GIF images, see the GD.pm module.

Each of these functions produces a fragment of HTML or HTTP which you
can print out directly so that it displays in the browser window,
append to a string, or save to a file for later use.

=head2 CREATING A STANDARD HTTP HEADER:

Normally the first thing you will do in any CGI script is print out an
HTTP header.  This tells the browser what type of document to expect,
and gives other optional information, such as the language, expiration
date, and whether to cache the document.  The header can also be
manipulated for special purposes, such as server push and pay per view
pages.

	print header;

	     -or-

	print header('image/gif');

	     -or-

	print header('text/html','204 No response');

	     -or-

	print header(-type=>'image/gif',
			     -nph=>1,
			     -status=>'402 Payment required',
			     -expires=>'+3d',
			     -cookie=>$cookie,
                             -charset=>'utf-7',
                             -attachment=>'foo.gif',
			     -Cost=>'$2.00');

header() returns the Content-type: header.  You can provide your own
MIME type if you choose, otherwise it defaults to text/html.  An
optional second parameter specifies the status code and a human-readable
message.  For example, you can specify 204, "No response" to create a
script that tells the browser to do nothing at all.

The last example shows the named argument style for passing arguments
to the CGI methods using named parameters.  Recognized parameters are
B<-type>, B<-status>, B<-expires>, and B<-cookie>.  Any other named
parameters will be stripped of their initial hyphens and turned into
header fields, allowing you to specify any HTTP header you desire.
Internal underscores will be turned into hyphens:

    print header(-Content_length=>3002);

Most browsers will not cache the output from CGI scripts.  Every time
the browser reloads the page, the script is invoked anew.  You can
change this behavior with the B<-expires> parameter.  When you specify
an absolute or relative expiration interval with this parameter, some
browsers and proxy servers will cache the script's output until the
indicated expiration date.  The following forms are all valid for the
-expires field:

	+30s                              30 seconds from now
	+10m                              ten minutes from now
	+1h                               one hour from now
	-1d                               yesterday (i.e. "ASAP!")
	now                               immediately
	+3M                               in three months
	+10y                              in ten years time
	Thursday, 25-Apr-1999 00:40:33 GMT  at the indicated time & date

The B<-cookie> parameter generates a header that tells the browser to provide
a "magic cookie" during all subsequent transactions with your script.
Netscape cookies have a special format that includes interesting attributes
such as expiration time.  Use the cookie() method to create and retrieve
session cookies.

The B<-nph> parameter, if set to a true value, will issue the correct
headers to work with a NPH (no-parse-header) script.  This is important
to use with certain servers that expect all their scripts to be NPH.

The B<-charset> parameter can be used to control the character set
sent to the browser.  If not provided, defaults to ISO-8859-1.  As a
side effect, this sets the charset() method as well.

The B<-attachment> parameter can be used to turn the page into an
attachment.  Instead of displaying the page, some browsers will prompt
the user to save it to disk.  The value of the argument is the
suggested name for the saved file.  In order for this to work, you may
have to set the B<-type> to "application/octet-stream".

The B<-p3p> parameter will add a P3P tag to the outgoing header.  The
parameter can be an arrayref or a space-delimited string of P3P tags.
For example:

   print header(-p3p=>[qw(CAO DSP LAW CURa)]);
   print header(-p3p=>'CAO DSP LAW CURa');

In either case, the outgoing header will be formatted as:

  P3P: policyref="/w3c/p3p.xml" cp="CAO DSP LAW CURa"

=head2 GENERATING A REDIRECTION HEADER

   print redirect('http://somewhere.else/in/movie/land');

Sometimes you don't want to produce a document yourself, but simply
redirect the browser elsewhere, perhaps choosing a URL based on the
time of day or the identity of the user.  

The redirect() function redirects the browser to a different URL.  If
you use redirection like this, you should B<not> print out a header as
well.

You should always use full URLs (including the http: or ftp: part) in
redirection requests.  Relative URLs will not work correctly.

You can also use named arguments:

    print redirect(-uri=>'http://somewhere.else/in/movie/land',
			   -nph=>1,
                           -status=>301);

The B<-nph> parameter, if set to a true value, will issue the correct
headers to work with a NPH (no-parse-header) script.  This is important
to use with certain servers, such as Microsoft IIS, which
expect all their scripts to be NPH.

The B<-status> parameter will set the status of the redirect.  HTTP
defines three different possible redirection status codes:

     301 Moved Permanently
     302 Found
     303 See Other

The default if not specified is 302, which means "moved temporarily."
You may change the status to another status code if you wish.  Be
advised that changing the status to anything other than 301, 302 or
303 will probably break redirection.

=head2 CREATING THE HTML DOCUMENT HEADER

   print start_html(-title=>'Secrets of the Pyramids',
			    -author=>'fred@@capricorn.org',
			    -base=>'true',
			    -target=>'_blank',
			    -meta=>{'keywords'=>'pharaoh secret mummy',
				    'copyright'=>'copyright 1996 King Tut'},
			    -style=>{'src'=>'/styles/style1.css'},
			    -BGCOLOR=>'blue');

After creating the HTTP header, most CGI scripts will start writing
out an HTML document.  The start_html() routine creates the top of the
page, along with a lot of optional information that controls the
page's appearance and behavior.

This method returns a canned HTML header and the opening <body> tag.
All parameters are optional.  In the named parameter form, recognized
parameters are -title, -author, -base, -xbase, -dtd, -lang and -target
(see below for the explanation).  Any additional parameters you
provide, such as the Netscape unofficial BGCOLOR attribute, are added
to the <body> tag.  Additional parameters must be proceeded by a
hyphen.

The argument B<-xbase> allows you to provide an HREF for the <base> tag
different from the current location, as in

    -xbase=>"http://home.mcom.com/"

All relative links will be interpreted relative to this tag.

The argument B<-target> allows you to provide a default target frame
for all the links and fill-out forms on the page.  B<This is a
non-standard HTTP feature which only works with Netscape browsers!>
See the Netscape documentation on frames for details of how to
manipulate this.

    -target=>"answer_window"

All relative links will be interpreted relative to this tag.
You add arbitrary meta information to the header with the B<-meta>
argument.  This argument expects a reference to a hash
containing name/value pairs of meta information.  These will be turned
into a series of header <meta> tags that look something like this:

    <meta name="keywords" content="pharaoh secret mummy">
    <meta name="description" content="copyright 1996 King Tut">

To create an HTTP-EQUIV type of <meta> tag, use B<-head>, described
below.

The B<-style> argument is used to incorporate cascading stylesheets
into your code.  See the section on CASCADING STYLESHEETS for more
information.

The B<-lang> argument is used to incorporate a language attribute into
the <html> tag.  For example:

    print $q->start_html(-lang=>'fr-CA');

The default if not specified is "en-US" for US English, unless the 
-dtd parameter specifies an HTML 2.0 or 3.2 DTD, in which case the
lang attribute is left off.  You can force the lang attribute to left
off in other cases by passing an empty string (-lang=>'').

The B<-encoding> argument can be used to specify the character set for
XHTML.  It defaults to iso-8859-1 if not specified.

The B<-declare_xml> argument, when used in conjunction with XHTML,
will put a <?xml> declaration at the top of the HTML header. The sole
purpose of this declaration is to declare the character set
encoding. In the absence of -declare_xml, the output HTML will contain
a <meta> tag that specifies the encoding, allowing the HTML to pass
most validators.  The default for -declare_xml is false.

You can place other arbitrary HTML elements to the <head> section with the
B<-head> tag.  For example, to place the rarely-used <link> element in the
head section, use this:

    print start_html(-head=>Link({-rel=>'next',
		                  -href=>'http://www.capricorn.com/s2.html'}));

To incorporate multiple HTML elements into the <head> section, just pass an
array reference:

    print start_html(-head=>[ 
                             Link({-rel=>'next',
				   -href=>'http://www.capricorn.com/s2.html'}),
		             Link({-rel=>'previous',
				   -href=>'http://www.capricorn.com/s1.html'})
			     ]
		     );

And here's how to create an HTTP-EQUIV <meta> tag:

      print start_html(-head=>meta({-http_equiv => 'Content-Type',
                                    -content    => 'text/html'}))


JAVASCRIPTING: The B<-script>, B<-noScript>, B<-onLoad>,
B<-onMouseOver>, B<-onMouseOut> and B<-onUnload> parameters are used
to add Netscape JavaScript calls to your pages.  B<-script> should
point to a block of text containing JavaScript function definitions.
This block will be placed within a <script> block inside the HTML (not
HTTP) header.  The block is placed in the header in order to give your
page a fighting chance of having all its JavaScript functions in place
even if the user presses the stop button before the page has loaded
completely.  CGI.pm attempts to format the script in such a way that
JavaScript-naive browsers will not choke on the code: unfortunately
there are some browsers, such as Chimera for Unix, that get confused
by it nevertheless.

The B<-onLoad> and B<-onUnload> parameters point to fragments of JavaScript
code to execute when the page is respectively opened and closed by the
browser.  Usually these parameters are calls to functions defined in the
B<-script> field:

      $query = new CGI;
      print header;
      $JSCRIPT=<<END;
      // Ask a silly question
      function riddle_me_this() {
	 var r = prompt("What walks on four legs in the morning, " +
		       "two legs in the afternoon, " +
		       "and three legs in the evening?");
	 response(r);
      }
      // Get a silly answer
      function response(answer) {
	 if (answer == "man")
	    alert("Right you are!");
	 else
	    alert("Wrong!  Guess again.");
      }
      END
      print start_html(-title=>'The Riddle of the Sphinx',
			       -script=>$JSCRIPT);

Use the B<-noScript> parameter to pass some HTML text that will be displayed on 
browsers that do not have JavaScript (or browsers where JavaScript is turned
off).

The <script> tag, has several attributes including "type" and src.
The latter is particularly interesting, as it allows you to keep the
JavaScript code in a file or CGI script rather than cluttering up each
page with the source.  To use these attributes pass a HASH reference
in the B<-script> parameter containing one or more of -type, -src, or
-code:

    print $q->start_html(-title=>'The Riddle of the Sphinx',
			 -script=>{-type=>'JAVASCRIPT',
                                   -src=>'/javascript/sphinx.js'}
			 );

    print $q->(-title=>'The Riddle of the Sphinx',
	       -script=>{-type=>'PERLSCRIPT',
			 -code=>'print "hello world!\n;"'}
	       );


A final feature allows you to incorporate multiple <script> sections into the
header.  Just pass the list of script sections as an array reference.
this allows you to specify different source files for different dialects
of JavaScript.  Example:

     print $q->start_html(-title=>'The Riddle of the Sphinx',
                          -script=>[
                                    { -type => 'text/javascript',
                                      -src      => '/javascript/utilities10.js'
                                    },
                                    { -type => 'text/javascript',
                                      -src      => '/javascript/utilities11.js'
                                    },
                                    { -type => 'text/jscript',
                                      -src      => '/javascript/utilities12.js'
                                    },
                                    { -type => 'text/ecmascript',
                                      -src      => '/javascript/utilities219.js'
                                    }
                                 ]
                             );

The option "-language" is a synonym for -type, and is supported for
backwad compatibility.

The old-style positional parameters are as follows:

=over 4

=item B<Parameters:>

=item 1.

The title

=item 2.

The author's e-mail address (will create a <link rev="MADE"> tag if present

=item 3.

A 'true' flag if you want to include a <base> tag in the header.  This
helps resolve relative addresses to absolute ones when the document is moved, 
but makes the document hierarchy non-portable.  Use with care!

=item 4, 5, 6...

Any other parameters you want to include in the <body> tag.  This is a good
place to put Netscape extensions, such as colors and wallpaper patterns.

=back

=head2 ENDING THE HTML DOCUMENT:

	print end_html

This ends an HTML document by printing the </body></html> tags.

=head2 CREATING A SELF-REFERENCING URL THAT PRESERVES STATE INFORMATION:

    $myself = self_url;
    print q(<a href="$myself">I'm talking to myself.</a>);

self_url() will return a URL, that, when selected, will reinvoke
this script with all its state information intact.  This is most
useful when you want to jump around within the document using
internal anchors but you don't want to disrupt the current contents
of the form(s).  Something like this will do the trick.

     $myself = self_url;
     print "<a href=\"$myself#table1\">See table 1</a>";
     print "<a href=\"$myself#table2\">See table 2</a>";
     print "<a href=\"$myself#yourself\">See for yourself</a>";

If you want more control over what's returned, using the B<url()>
method instead.

You can also retrieve the unprocessed query string with query_string():

    $the_string = query_string;

=head2 OBTAINING THE SCRIPT'S URL

    $full_url      = url();
    $full_url      = url(-full=>1);  #alternative syntax
    $relative_url  = url(-relative=>1);
    $absolute_url  = url(-absolute=>1);
    $url_with_path = url(-path_info=>1);
    $url_with_path_and_query = url(-path_info=>1,-query=>1);
    $netloc        = url(-base => 1);

B<url()> returns the script's URL in a variety of formats.  Called
without any arguments, it returns the full form of the URL, including
host name and port number

    http://your.host.com/path/to/script.cgi

You can modify this format with the following named arguments:

=over 4

=item B<-absolute>

If true, produce an absolute URL, e.g.

    /path/to/script.cgi

=item B<-relative>

Produce a relative URL.  This is useful if you want to reinvoke your
script with different parameters. For example:

    script.cgi

=item B<-full>

Produce the full URL, exactly as if called without any arguments.
This overrides the -relative and -absolute arguments.

=item B<-path> (B<-path_info>)

Append the additional path information to the URL.  This can be
combined with B<-full>, B<-absolute> or B<-relative>.  B<-path_info>
is provided as a synonym.

=item B<-query> (B<-query_string>)

Append the query string to the URL.  This can be combined with
B<-full>, B<-absolute> or B<-relative>.  B<-query_string> is provided
as a synonym.

=item B<-base>

Generate just the protocol and net location, as in http://www.foo.com:8000

=item B<-rewrite>

If Apache's mod_rewrite is turned on, then the script name and path
info probably won't match the request that the user sent. Set
-rewrite=>1 (default) to return URLs that match what the user sent
(the original request URI). Set -rewrite=>0 to return URLs that match
the URL after mod_rewrite's rules have run. Because the additional
path information only makes sense in the context of the rewritten URL,
-rewrite is set to false when you request path info in the URL.

=back

=head2 MIXING POST AND URL PARAMETERS

   $color = url_param('color');

It is possible for a script to receive CGI parameters in the URL as
well as in the fill-out form by creating a form that POSTs to a URL
containing a query string (a "?" mark followed by arguments).  The
B<param()> method will always return the contents of the POSTed
fill-out form, ignoring the URL's query string.  To retrieve URL
parameters, call the B<url_param()> method.  Use it in the same way as
B<param()>.  The main difference is that it allows you to read the
parameters, but not set them.


Under no circumstances will the contents of the URL query string
interfere with similarly-named CGI parameters in POSTed forms.  If you
try to mix a URL query string with a form submitted with the GET
method, the results will not be what you expect.

=head1 CREATING STANDARD HTML ELEMENTS:

CGI.pm defines general HTML shortcut methods for most, if not all of
the HTML 3 and HTML 4 tags.  HTML shortcuts are named after a single
HTML element and return a fragment of HTML text that you can then
print or manipulate as you like.  Each shortcut returns a fragment of
HTML code that you can append to a string, save to a file, or, most
commonly, print out so that it displays in the browser window.

This example shows how to use the HTML methods:

   print $q->blockquote(
		     "Many years ago on the island of",
		     $q->a({href=>"http://crete.org/"},"Crete"),
		     "there lived a Minotaur named",
		     $q->strong("Fred."),
		    ),
       $q->hr;

This results in the following HTML code (extra newlines have been
added for readability):

   <blockquote>
   Many years ago on the island of
   <a href="http://crete.org/">Crete</a> there lived
   a minotaur named <strong>Fred.</strong> 
   </blockquote>
   <hr>

If you find the syntax for calling the HTML shortcuts awkward, you can
import them into your namespace and dispense with the object syntax
completely (see the next section for more details):

   use CGI ':standard';
   print blockquote(
      "Many years ago on the island of",
      a({href=>"http://crete.org/"},"Crete"),
      "there lived a minotaur named",
      strong("Fred."),
      ),
      hr;

=head2 PROVIDING ARGUMENTS TO HTML SHORTCUTS

The HTML methods will accept zero, one or multiple arguments.  If you
provide no arguments, you get a single tag:

   print hr;  	#  <hr>

If you provide one or more string arguments, they are concatenated
together with spaces and placed between opening and closing tags:

   print h1("Chapter","1"); # <h1>Chapter 1</h1>"

If the first argument is a hash reference, then the keys
and values of the hash become the HTML tag's attributes:

   print a({-href=>'fred.html',-target=>'_new'},
      "Open a new frame");

	    <a href="fred.html",target="_new">Open a new frame</a>

You may dispense with the dashes in front of the attribute names if
you prefer:

   print img {src=>'fred.gif',align=>'LEFT'};

	   <img align="LEFT" src="fred.gif">

Sometimes an HTML tag attribute has no argument.  For example, ordered
lists can be marked as COMPACT.  The syntax for this is an argument that
that points to an undef string:

   print ol({compact=>undef},li('one'),li('two'),li('three'));

Prior to CGI.pm version 2.41, providing an empty ('') string as an
attribute argument was the same as providing undef.  However, this has
changed in order to accommodate those who want to create tags of the form 
<img alt="">.  The difference is shown in these two pieces of code:

   CODE                   RESULT
   img({alt=>undef})      <img alt>
   img({alt=>''})         <img alt="">

=head2 THE DISTRIBUTIVE PROPERTY OF HTML SHORTCUTS

One of the cool features of the HTML shortcuts is that they are
distributive.  If you give them an argument consisting of a
B<reference> to a list, the tag will be distributed across each
element of the list.  For example, here's one way to make an ordered
list:

   print ul(
             li({-type=>'disc'},['Sneezy','Doc','Sleepy','Happy'])
           );

This example will result in HTML output that looks like this:

   <ul>
     <li type="disc">Sneezy</li>
     <li type="disc">Doc</li>
     <li type="disc">Sleepy</li>
     <li type="disc">Happy</li>
   </ul>

This is extremely useful for creating tables.  For example:

   print table({-border=>undef},
           caption('When Should You Eat Your Vegetables?'),
           Tr({-align=>CENTER,-valign=>TOP},
           [
              th(['Vegetable', 'Breakfast','Lunch','Dinner']),
              td(['Tomatoes' , 'no', 'yes', 'yes']),
              td(['Broccoli' , 'no', 'no',  'yes']),
              td(['Onions'   , 'yes','yes', 'yes'])
           ]
           )
        );

=head2 HTML SHORTCUTS AND LIST INTERPOLATION

Consider this bit of code:

   print blockquote(em('Hi'),'mom!'));

It will ordinarily return the string that you probably expect, namely:

   <blockquote><em>Hi</em> mom!</blockquote>

Note the space between the element "Hi" and the element "mom!".
CGI.pm puts the extra space there using array interpolation, which is
controlled by the magic $" variable.  Sometimes this extra space is
not what you want, for example, when you are trying to align a series
of images.  In this case, you can simply change the value of $" to an
empty string.

   {
      local($") = '';
      print blockquote(em('Hi'),'mom!'));
    }

I suggest you put the code in a block as shown here.  Otherwise the
change to $" will affect all subsequent code until you explicitly
reset it.

=head2 NON-STANDARD HTML SHORTCUTS

A few HTML tags don't follow the standard pattern for various
reasons.  

B<comment()> generates an HTML comment (<!-- comment -->).  Call it
like

    print comment('here is my comment');

Because of conflicts with built-in Perl functions, the following functions
begin with initial caps:

    Select
    Tr
    Link
    Delete
    Accept
    Sub

In addition, start_html(), end_html(), start_form(), end_form(),
start_multipart_form() and all the fill-out form tags are special.
See their respective sections.

=head2 AUTOESCAPING HTML

By default, all HTML that is emitted by the form-generating functions
is passed through a function called escapeHTML():

=over 4

=item $escaped_string = escapeHTML("unescaped string");

Escape HTML formatting characters in a string.

=back

Provided that you have specified a character set of ISO-8859-1 (the
default), the standard HTML escaping rules will be used.  The "<"
character becomes "&lt;", ">" becomes "&gt;", "&" becomes "&amp;", and
the quote character becomes "&quot;".  In addition, the hexadecimal
0x8b and 0x9b characters, which some browsers incorrectly interpret
as the left and right angle-bracket characters, are replaced by their
numeric character entities ("&#8249" and "&#8250;").  If you manually change
the charset, either by calling the charset() method explicitly or by
passing a -charset argument to header(), then B<all> characters will
be replaced by their numeric entities, since CGI.pm has no lookup
table for all the possible encodings.

The automatic escaping does not apply to other shortcuts, such as
h1().  You should call escapeHTML() yourself on untrusted data in
order to protect your pages against nasty tricks that people may enter
into guestbooks, etc..  To change the character set, use charset().
To turn autoescaping off completely, use autoEscape(0):

=over 4

=item $charset = charset([$charset]);

Get or set the current character set.

=item $flag = autoEscape([$flag]);

Get or set the value of the autoescape flag.

=back

=head2 PRETTY-PRINTING HTML

By default, all the HTML produced by these functions comes out as one
long line without carriage returns or indentation. This is yuck, but
it does reduce the size of the documents by 10-20%.  To get
pretty-printed output, please use L<CGI::Pretty>, a subclass
contributed by Brian Paulsen.

=head1 CREATING FILL-OUT FORMS:

I<General note>  The various form-creating methods all return strings
to the caller, containing the tag or tags that will create the requested
form element.  You are responsible for actually printing out these strings.
It's set up this way so that you can place formatting tags
around the form elements.

I<Another note> The default values that you specify for the forms are only
used the B<first> time the script is invoked (when there is no query
string).  On subsequent invocations of the script (when there is a query
string), the former values are used even if they are blank.  

If you want to change the value of a field from its previous value, you have two
choices:

(1) call the param() method to set it.

(2) use the -override (alias -force) parameter (a new feature in version 2.15).
This forces the default value to be used, regardless of the previous value:

   print textfield(-name=>'field_name',
			   -default=>'starting value',
			   -override=>1,
			   -size=>50,
			   -maxlength=>80);

I<Yet another note> By default, the text and labels of form elements are
escaped according to HTML rules.  This means that you can safely use
"<CLICK ME>" as the label for a button.  However, it also interferes with
your ability to incorporate special HTML character sequences, such as &Aacute;,
into your fields.  If you wish to turn off automatic escaping, call the
autoEscape() method with a false value immediately after creating the CGI object:

   $query = new CGI;
   autoEscape(undef);

I<A Lurking Trap!> Some of the form-element generating methods return
multiple tags.  In a scalar context, the tags will be concatenated
together with spaces, or whatever is the current value of the $"
global.  In a list context, the methods will return a list of
elements, allowing you to modify them if you wish.  Usually you will
not notice this behavior, but beware of this:

    printf("%s\n",end_form())

end_form() produces several tags, and only the first of them will be
printed because the format only expects one value.

<p>


=head2 CREATING AN ISINDEX TAG

   print isindex(-action=>$action);

	 -or-

   print isindex($action);

Prints out an <isindex> tag.  Not very exciting.  The parameter
-action specifies the URL of the script to process the query.  The
default is to process the query with the current script.

=head2 STARTING AND ENDING A FORM

    print start_form(-method=>$method,
		    -action=>$action,
		    -enctype=>$encoding);
      <... various form stuff ...>
    print endform;

	-or-

    print start_form($method,$action,$encoding);
      <... various form stuff ...>
    print endform;

start_form() will return a <form> tag with the optional method,
action and form encoding that you specify.  The defaults are:

    method: POST
    action: this script
    enctype: application/x-www-form-urlencoded

endform() returns the closing </form> tag.  

Start_form()'s enctype argument tells the browser how to package the various
fields of the form before sending the form to the server.  Two
values are possible:

B<Note:> This method was previously named startform(), and startform()
is still recognized as an alias.

=over 4

=item B<application/x-www-form-urlencoded>

This is the older type of encoding used by all browsers prior to
Netscape 2.0.  It is compatible with many CGI scripts and is
suitable for short fields containing text data.  For your
convenience, CGI.pm stores the name of this encoding
type in B<&CGI::URL_ENCODED>.

=item B<multipart/form-data>

This is the newer type of encoding introduced by Netscape 2.0.
It is suitable for forms that contain very large fields or that
are intended for transferring binary data.  Most importantly,
it enables the "file upload" feature of Netscape 2.0 forms.  For
your convenience, CGI.pm stores the name of this encoding type
in B<&CGI::MULTIPART>

Forms that use this type of encoding are not easily interpreted
by CGI scripts unless they use CGI.pm or another library designed
to handle them.

If XHTML is activated (the default), then forms will be automatically
created using this type of encoding.

=back

For compatibility, the start_form() method uses the older form of
encoding by default.  If you want to use the newer form of encoding
by default, you can call B<start_multipart_form()> instead of
B<start_form()>.

JAVASCRIPTING: The B<-name> and B<-onSubmit> parameters are provided
for use with JavaScript.  The -name parameter gives the
form a name so that it can be identified and manipulated by
JavaScript functions.  -onSubmit should point to a JavaScript
function that will be executed just before the form is submitted to your
server.  You can use this opportunity to check the contents of the form 
for consistency and completeness.  If you find something wrong, you
can put up an alert box or maybe fix things up yourself.  You can 
abort the submission by returning false from this function.  

Usually the bulk of JavaScript functions are defined in a <script>
block in the HTML header and -onSubmit points to one of these function
call.  See start_html() for details.

=head2 FORM ELEMENTS

After starting a form, you will typically create one or more
textfields, popup menus, radio groups and other form elements.  Each
of these elements takes a standard set of named arguments.  Some
elements also have optional arguments.  The standard arguments are as
follows:

=over 4

=item B<-name>

The name of the field. After submission this name can be used to
retrieve the field's value using the param() method.

=item B<-value>, B<-values>

The initial value of the field which will be returned to the script
after form submission.  Some form elements, such as text fields, take
a single scalar -value argument. Others, such as popup menus, take a
reference to an array of values. The two arguments are synonyms.

=item B<-tabindex>

A numeric value that sets the order in which the form element receives
focus when the user presses the tab key. Elements with lower values
receive focus first.

=item B<-id>

A string identifier that can be used to identify this element to
JavaScript and DHTML.

=item B<-override>

A boolean, which, if true, forces the element to take on the value
specified by B<-value>, overriding the sticky behavior described
earlier for the B<-no_sticky> pragma.

=item B<-onChange>, B<-onFocus>, B<-onBlur>, B<-onMouseOver>, B<-onMouseOut>, B<-onSelect>

These are used to assign JavaScript event handlers. See the
JavaScripting section for more details.

=back

Other common arguments are described in the next section. In addition
to these, all attributes described in the HTML specifications are
supported.

=head2 CREATING A TEXT FIELD

    print textfield(-name=>'field_name',
		    -value=>'starting value',
		    -size=>50,
		    -maxlength=>80);
	-or-

    print textfield('field_name','starting value',50,80);

textfield() will return a text input field. 

=over 4

=item B<Parameters>

=item 1.

The first parameter is the required name for the field (-name). 

=item 2.

The optional second parameter is the default starting value for the field
contents (-value, formerly known as -default).

=item 3.

The optional third parameter is the size of the field in
      characters (-size).

=item 4.

The optional fourth parameter is the maximum number of characters the
      field will accept (-maxlength).

=back

As with all these methods, the field will be initialized with its 
previous contents from earlier invocations of the script.
When the form is processed, the value of the text field can be
retrieved with:

       $value = param('foo');

If you want to reset it from its initial value after the script has been
called once, you can do so like this:

       param('foo',"I'm taking over this value!");

=head2 CREATING A BIG TEXT FIELD

   print textarea(-name=>'foo',
			  -default=>'starting value',
			  -rows=>10,
			  -columns=>50);

	-or

   print textarea('foo','starting value',10,50);

textarea() is just like textfield, but it allows you to specify
rows and columns for a multiline text entry box.  You can provide
a starting value for the field, which can be long and contain
multiple lines.

=head2 CREATING A PASSWORD FIELD

   print password_field(-name=>'secret',
				-value=>'starting value',
				-size=>50,
				-maxlength=>80);
	-or-

   print password_field('secret','starting value',50,80);

password_field() is identical to textfield(), except that its contents 
will be starred out on the web page.

=head2 CREATING A FILE UPLOAD FIELD

    print filefield(-name=>'uploaded_file',
			    -default=>'starting value',
			    -size=>50,
			    -maxlength=>80);
	-or-

    print filefield('uploaded_file','starting value',50,80);

filefield() will return a file upload field for Netscape 2.0 browsers.
In order to take full advantage of this I<you must use the new 
multipart encoding scheme> for the form.  You can do this either
by calling B<start_form()> with an encoding type of B<&CGI::MULTIPART>,
or by calling the new method B<start_multipart_form()> instead of
vanilla B<start_form()>.

=over 4

=item B<Parameters>

=item 1.

The first parameter is the required name for the field (-name).  

=item 2.

The optional second parameter is the starting value for the field contents
to be used as the default file name (-default).

For security reasons, browsers don't pay any attention to this field,
and so the starting value will always be blank.  Worse, the field
loses its "sticky" behavior and forgets its previous contents.  The
starting value field is called for in the HTML specification, however,
and possibly some browser will eventually provide support for it.

=item 3.

The optional third parameter is the size of the field in
characters (-size).

=item 4.

The optional fourth parameter is the maximum number of characters the
field will accept (-maxlength).

=back

When the form is processed, you can retrieve the entered filename
by calling param():

       $filename = param('uploaded_file');

Different browsers will return slightly different things for the
name.  Some browsers return the filename only.  Others return the full
path to the file, using the path conventions of the user's machine.
Regardless, the name returned is always the name of the file on the
I<user's> machine, and is unrelated to the name of the temporary file
that CGI.pm creates during upload spooling (see below).

The filename returned is also a file handle.  You can read the contents
of the file using standard Perl file reading calls:

	# Read a text file and print it out
	while (<$filename>) {
	   print;
	}

	# Copy a binary file to somewhere safe
	open (OUTFILE,">>/usr/local/web/users/feedback");
	while ($bytesread=read($filename,$buffer,1024)) {
	   print OUTFILE $buffer;
	}

However, there are problems with the dual nature of the upload fields.
If you C<use strict>, then Perl will complain when you try to use a
string as a filehandle.  You can get around this by placing the file
reading code in a block containing the C<no strict> pragma.  More
seriously, it is possible for the remote user to type garbage into the
upload field, in which case what you get from param() is not a
filehandle at all, but a string.

To be safe, use the I<upload()> function (new in version 2.47).  When
called with the name of an upload field, I<upload()> returns a
filehandle-like object, or undef if the parameter is not a valid
filehandle.

     $fh = upload('uploaded_file');
     while (<$fh>) {
	   print;
     }

In a list context, upload() will return an array of filehandles.
This makes it possible to create forms that use the same name for
multiple upload fields.

This is the recommended idiom.

The lightweight filehandle returned by CGI.pm is not compatible with
IO::Handle; for example, it does not have read() or getline()
functions, but instead must be manipulated using read($fh) or
<$fh>. To get a compatible IO::Handle object, call the handle's
handle() method:

  my $real_io_handle = upload('uploaded_file')->handle;

When a file is uploaded the browser usually sends along some
information along with it in the format of headers.  The information
usually includes the MIME content type.  Future browsers may send
other information as well (such as modification date and size). To
retrieve this information, call uploadInfo().  It returns a reference to
a hash containing all the document headers.

       $filename = param('uploaded_file');
       $type = uploadInfo($filename)->{'Content-Type'};
       unless ($type eq 'text/html') {
	  die "HTML FILES ONLY!";
       }

If you are using a machine that recognizes "text" and "binary" data
modes, be sure to understand when and how to use them (see the Camel book).  
Otherwise you may find that binary files are corrupted during file
uploads.

There are occasionally problems involving parsing the uploaded file.
This usually happens when the user presses "Stop" before the upload is
finished.  In this case, CGI.pm will return undef for the name of the
uploaded file and set I<cgi_error()> to the string "400 Bad request
(malformed multipart POST)".  This error message is designed so that
you can incorporate it into a status code to be sent to the browser.
Example:

   $file = upload('uploaded_file');
   if (!$file && cgi_error) {
      print header(-status=>cgi_error);
      exit 0;
   }

You are free to create a custom HTML page to complain about the error,
if you wish.

You can set up a callback that will be called whenever a file upload
is being read during the form processing. This is much like the
UPLOAD_HOOK facility available in Apache::Request, with the exception
that the first argument to the callback is an Apache::Upload object,
here it's the remote filename.

 $q = CGI->new(\&hook [,$data [,$use_tempfile]]);

 sub hook
 {
        my ($filename, $buffer, $bytes_read, $data) = @@_;
        print  "Read $bytes_read bytes of $filename\n";         
 }

The $data field is optional; it lets you pass configuration
information (e.g. a database handle) to your hook callback.

The $use_tempfile field is a flag that lets you turn on and off
CGI.pm's use of a temporary disk-based file during file upload. If you
set this to a FALSE value (default true) then param('uploaded_file')
will no longer work, and the only way to get at the uploaded data is
via the hook you provide.

If using the function-oriented interface, call the CGI::upload_hook()
method before calling param() or any other CGI functions:

  CGI::upload_hook(\&hook [,$data [,$use_tempfile]]);

This method is not exported by default.  You will have to import it
explicitly if you wish to use it without the CGI:: prefix.

If you are using CGI.pm on a Windows platform and find that binary
files get slightly larger when uploaded but that text files remain the
same, then you have forgotten to activate binary mode on the output
filehandle.  Be sure to call binmode() on any handle that you create
to write the uploaded file to disk.

JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur>,
B<-onMouseOver>, B<-onMouseOut> and B<-onSelect> parameters are
recognized.  See textfield() for details.

=head2 CREATING A POPUP MENU

   print popup_menu('menu_name',
			    ['eenie','meenie','minie'],
			    'meenie');

      -or-

   %labels = ('eenie'=>'your first choice',
	      'meenie'=>'your second choice',
	      'minie'=>'your third choice');
   %attributes = ('eenie'=>{'class'=>'class of first choice'});
   print popup_menu('menu_name',
			    ['eenie','meenie','minie'],
          'meenie',\%labels,\%attributes);

	-or (named parameter style)-

   print popup_menu(-name=>'menu_name',
			    -values=>['eenie','meenie','minie'],
			    -default=>['meenie','minie'],
          -labels=>\%labels,
          -attributes=>\%attributes);

popup_menu() creates a menu.

=over 4

=item 1.

The required first argument is the menu's name (-name).

=item 2.

The required second argument (-values) is an array B<reference>
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference to
a named array, such as "\@@foo".

=item 3.

The optional third parameter (-default) is the name of the default
menu choice.  If not specified, the first item will be the default.
The values of the previous choice will be maintained across
queries. Pass an array reference to select multiple defaults.

=item 4.

The optional fourth parameter (-labels) is provided for people who
want to use different values for the user-visible label inside the
popup menu and the value returned to your script.  It's a pointer to an
hash relating menu values to user-visible labels.  If you
leave this parameter blank, the menu values will be displayed by
default.  (You can also leave a label undefined if you want to).

=item 5.

The optional fifth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.

=back

When the form is processed, the selected value of the popup menu can
be retrieved using:

      $popup_menu_value = param('menu_name');

=head2 CREATING AN OPTION GROUP

Named parameter style

  print popup_menu(-name=>'menu_name',
                  -values=>[qw/eenie meenie minie/,
                            optgroup(-name=>'optgroup_name',
                                             -values => ['moe','catch'],
                                             -attributes=>{'catch'=>{'class'=>'red'}})],
                  -labels=>{'eenie'=>'one',
                            'meenie'=>'two',
                            'minie'=>'three'},
                  -default=>'meenie');

  Old style
  print popup_menu('menu_name',
                  ['eenie','meenie','minie',
                   optgroup('optgroup_name', ['moe', 'catch'],
                                   {'catch'=>{'class'=>'red'}})],'meenie',
                  {'eenie'=>'one','meenie'=>'two','minie'=>'three'});

optgroup() creates an option group within a popup menu.

=over 4

=item 1.

The required first argument (B<-name>) is the label attribute of the
optgroup and is B<not> inserted in the parameter list of the query.

=item 2.

The required second argument (B<-values>)  is an array reference
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference
to a named array, such as \@@foo.  If you pass a HASH reference,
the keys will be used for the menu values, and the values will be
used for the menu labels (see -labels below).

=item 3.

The optional third parameter (B<-labels>) allows you to pass a reference
to a hash containing user-visible labels for one or more
of the menu items.  You can use this when you want the user to see one
menu string, but have the browser return your program a different one.
If you don't specify this, the value string will be used instead
("eenie", "meenie" and "minie" in this example).  This is equivalent
to using a hash reference for the -values parameter.

=item 4.

An optional fourth parameter (B<-labeled>) can be set to a true value
and indicates that the values should be used as the label attribute
for each option element within the optgroup.

=item 5.

An optional fifth parameter (-novals) can be set to a true value and
indicates to suppress the val attribute in each option element within
the optgroup.

See the discussion on optgroup at W3C
(http://www.w3.org/TR/REC-html40/interact/forms.html#edef-OPTGROUP)
for details.

=item 6.

An optional sixth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.

=back

=head2 CREATING A SCROLLING LIST

   print scrolling_list('list_name',
				['eenie','meenie','minie','moe'],
        ['eenie','moe'],5,'true',{'moe'=>{'class'=>'red'}});
      -or-

   print scrolling_list('list_name',
				['eenie','meenie','minie','moe'],
				['eenie','moe'],5,'true',
        \%labels,%attributes);

	-or-

   print scrolling_list(-name=>'list_name',
				-values=>['eenie','meenie','minie','moe'],
				-default=>['eenie','moe'],
				-size=>5,
				-multiple=>'true',
        -labels=>\%labels,
        -attributes=>\%attributes);

scrolling_list() creates a scrolling list.  

=over 4

=item B<Parameters:>

=item 1.

The first and second arguments are the list name (-name) and values
(-values).  As in the popup menu, the second argument should be an
array reference.

=item 2.

The optional third argument (-default) can be either a reference to a
list containing the values to be selected by default, or can be a
single value to select.  If this argument is missing or undefined,
then nothing is selected when the list first appears.  In the named
parameter version, you can use the synonym "-defaults" for this
parameter.

=item 3.

The optional fourth argument is the size of the list (-size).

=item 4.

The optional fifth argument can be set to true to allow multiple
simultaneous selections (-multiple).  Otherwise only one selection
will be allowed at a time.

=item 5.

The optional sixth argument is a pointer to a hash
containing long user-visible labels for the list items (-labels).
If not provided, the values will be displayed.

=item 6.

The optional sixth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.

When this form is processed, all selected list items will be returned as
a list under the parameter name 'list_name'.  The values of the
selected items can be retrieved with:

      @@selected = param('list_name');

=back

=head2 CREATING A GROUP OF RELATED CHECKBOXES

   print checkbox_group(-name=>'group_name',
				-values=>['eenie','meenie','minie','moe'],
				-default=>['eenie','moe'],
				-linebreak=>'true',
                                -disabled => ['moe'],
        -labels=>\%labels,
        -attributes=>\%attributes);

   print checkbox_group('group_name',
				['eenie','meenie','minie','moe'],
        ['eenie','moe'],'true',\%labels,
        {'moe'=>{'class'=>'red'}});

   HTML3-COMPATIBLE BROWSERS ONLY:

   print checkbox_group(-name=>'group_name',
				-values=>['eenie','meenie','minie','moe'],
				-rows=2,-columns=>2);


checkbox_group() creates a list of checkboxes that are related
by the same name.

=over 4

=item B<Parameters:>

=item 1.

The first and second arguments are the checkbox name and values,
respectively (-name and -values).  As in the popup menu, the second
argument should be an array reference.  These values are used for the
user-readable labels printed next to the checkboxes as well as for the
values passed to your script in the query string.

=item 2.

The optional third argument (-default) can be either a reference to a
list containing the values to be checked by default, or can be a
single value to checked.  If this argument is missing or undefined,
then nothing is selected when the list first appears.

=item 3.

The optional fourth argument (-linebreak) can be set to true to place
line breaks between the checkboxes so that they appear as a vertical
list.  Otherwise, they will be strung together on a horizontal line.

=back


The optional B<-labels> argument is a pointer to a hash
relating the checkbox values to the user-visible labels that will be
printed next to them.  If not provided, the values will be used as the
default.


The optional parameters B<-rows>, and B<-columns> cause
checkbox_group() to return an HTML3 compatible table containing the
checkbox group formatted with the specified number of rows and
columns.  You can provide just the -columns parameter if you wish;
checkbox_group will calculate the correct number of rows for you.

The option B<-disabled> takes an array of checkbox values and disables
them by greying them out (this may not be supported by all browsers).

The optional B<-attributes> argument is provided to assign any of the
common HTML attributes to an individual menu item. It's a pointer to
a hash relating menu values to another hash
with the attribute's name as the key and the attribute's value as the
value.

The optional B<-tabindex> argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:

  -tabindex => 100    #  this group starts at index 100 and counts up
  -tabindex => ['moe','minie','eenie','meenie']  # tab in this order
  -tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order

The optional B<-labelattributes> argument will contain attributes
attached to the <label> element that surrounds each button.

When the form is processed, all checked boxes will be returned as
a list under the parameter name 'group_name'.  The values of the
"on" checkboxes can be retrieved with:

      @@turned_on = param('group_name');

The value returned by checkbox_group() is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:

    @@h = checkbox_group(-name=>'group_name',-values=>\@@values);
    &use_in_creative_way(@@h);

=head2 CREATING A STANDALONE CHECKBOX

    print checkbox(-name=>'checkbox_name',
			   -checked=>1,
			   -value=>'ON',
			   -label=>'CLICK ME');

	-or-

    print checkbox('checkbox_name','checked','ON','CLICK ME');

checkbox() is used to create an isolated checkbox that isn't logically
related to any others.

=over 4

=item B<Parameters:>

=item 1.

The first parameter is the required name for the checkbox (-name).  It
will also be used for the user-readable label printed next to the
checkbox.

=item 2.

The optional second parameter (-checked) specifies that the checkbox
is turned on by default.  Synonyms are -selected and -on.

=item 3.

The optional third parameter (-value) specifies the value of the
checkbox when it is checked.  If not provided, the word "on" is
assumed.

=item 4.

The optional fourth parameter (-label) is the user-readable label to
be attached to the checkbox.  If not provided, the checkbox name is
used.

=back

The value of the checkbox can be retrieved using:

    $turned_on = param('checkbox_name');

=head2 CREATING A RADIO BUTTON GROUP

   print radio_group(-name=>'group_name',
			     -values=>['eenie','meenie','minie'],
			     -default=>'meenie',
			     -linebreak=>'true',
           -labels=>\%labels,
           -attributes=>\%attributes);

	-or-

   print radio_group('group_name',['eenie','meenie','minie'],
            'meenie','true',\%labels,\%attributes);


   HTML3-COMPATIBLE BROWSERS ONLY:

   print radio_group(-name=>'group_name',
			     -values=>['eenie','meenie','minie','moe'],
			     -rows=2,-columns=>2);

radio_group() creates a set of logically-related radio buttons
(turning one member of the group on turns the others off)

=over 4

=item B<Parameters:>

=item 1.

The first argument is the name of the group and is required (-name).

=item 2.

The second argument (-values) is the list of values for the radio
buttons.  The values and the labels that appear on the page are
identical.  Pass an array I<reference> in the second argument, either
using an anonymous array, as shown, or by referencing a named array as
in "\@@foo".

=item 3.

The optional third parameter (-default) is the name of the default
button to turn on. If not specified, the first item will be the
default.  You can provide a nonexistent button name, such as "-" to
start up with no buttons selected.

=item 4.

The optional fourth parameter (-linebreak) can be set to 'true' to put
line breaks between the buttons, creating a vertical list.

=item 5.

The optional fifth parameter (-labels) is a pointer to an associative
array relating the radio button values to user-visible labels to be
used in the display.  If not provided, the values themselves are
displayed.

=back


All modern browsers can take advantage of the optional parameters
B<-rows>, and B<-columns>.  These parameters cause radio_group() to
return an HTML3 compatible table containing the radio group formatted
with the specified number of rows and columns.  You can provide just
the -columns parameter if you wish; radio_group will calculate the
correct number of rows for you.

To include row and column headings in the returned table, you
can use the B<-rowheaders> and B<-colheaders> parameters.  Both
of these accept a pointer to an array of headings to use.
The headings are just decorative.  They don't reorganize the
interpretation of the radio buttons -- they're still a single named
unit.

The optional B<-tabindex> argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:

  -tabindex => 100    #  this group starts at index 100 and counts up
  -tabindex => ['moe','minie','eenie','meenie']  # tab in this order
  -tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order


The optional B<-attributes> argument is provided to assign any of the
common HTML attributes to an individual menu item. It's a pointer to
a hash relating menu values to another hash
with the attribute's name as the key and the attribute's value as the
value.

The optional B<-labelattributes> argument will contain attributes
attached to the <label> element that surrounds each button.

When the form is processed, the selected radio button can
be retrieved using:

      $which_radio_button = param('group_name');

The value returned by radio_group() is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:

    @@h = radio_group(-name=>'group_name',-values=>\@@values);
    &use_in_creative_way(@@h);

=head2 CREATING A SUBMIT BUTTON 

   print submit(-name=>'button_name',
			-value=>'value');

	-or-

   print submit('button_name','value');

submit() will create the query submission button.  Every form
should have one of these.

=over 4

=item B<Parameters:>

=item 1.

The first argument (-name) is optional.  You can give the button a
name if you have several submission buttons in your form and you want
to distinguish between them.  

=item 2.

The second argument (-value) is also optional.  This gives the button
a value that will be passed to your script in the query string. The
name will also be used as the user-visible label.

=item 3.

You can use -label as an alias for -value.  I always get confused
about which of -name and -value changes the user-visible label on the
button.

=back

You can figure out which button was pressed by using different
values for each one:

     $which_one = param('button_name');

=head2 CREATING A RESET BUTTON

   print reset

reset() creates the "reset" button.  Note that it restores the
form to its value from the last time the script was called, 
NOT necessarily to the defaults.

Note that this conflicts with the Perl reset() built-in.  Use
CORE::reset() to get the original reset function.

=head2 CREATING A DEFAULT BUTTON

   print defaults('button_label')

defaults() creates a button that, when invoked, will cause the
form to be completely reset to its defaults, wiping out all the
changes the user ever made.

=head2 CREATING A HIDDEN FIELD

	print hidden(-name=>'hidden_name',
			     -default=>['value1','value2'...]);

		-or-

	print hidden('hidden_name','value1','value2'...);

hidden() produces a text field that can't be seen by the user.  It
is useful for passing state variable information from one invocation
of the script to the next.

=over 4

=item B<Parameters:>

=item 1.

The first argument is required and specifies the name of this
field (-name).

=item 2.  

The second argument is also required and specifies its value
(-default).  In the named parameter style of calling, you can provide
a single value here or a reference to a whole list

=back

Fetch the value of a hidden field this way:

     $hidden_value = param('hidden_name');

Note, that just like all the other form elements, the value of a
hidden field is "sticky".  If you want to replace a hidden field with
some other values after the script has been called once you'll have to
do it manually:

     param('hidden_name','new','values','here');

=head2 CREATING A CLICKABLE IMAGE BUTTON

     print image_button(-name=>'button_name',
				-src=>'/source/URL',
				-align=>'MIDDLE');      

	-or-

     print image_button('button_name','/source/URL','MIDDLE');

image_button() produces a clickable image.  When it's clicked on the
position of the click is returned to your script as "button_name.x"
and "button_name.y", where "button_name" is the name you've assigned
to it.

=over 4

=item B<Parameters:>

=item 1.

The first argument (-name) is required and specifies the name of this
field.

=item 2.

The second argument (-src) is also required and specifies the URL

=item 3.
The third option (-align, optional) is an alignment type, and may be
TOP, BOTTOM or MIDDLE

=back

Fetch the value of the button this way:
     $x = param('button_name.x');
     $y = param('button_name.y');

=head2 CREATING A JAVASCRIPT ACTION BUTTON

     print button(-name=>'button_name',
			  -value=>'user visible label',
			  -onClick=>"do_something()");

	-or-

     print button('button_name',"do_something()");

button() produces a button that is compatible with Netscape 2.0's
JavaScript.  When it's pressed the fragment of JavaScript code
pointed to by the B<-onClick> parameter will be executed.

=head1 HTTP COOKIES

Browsers support a so-called "cookie" designed to help maintain state
within a browser session.  CGI.pm has several methods that support
cookies.

A cookie is a name=value pair much like the named parameters in a CGI
query string.  CGI scripts create one or more cookies and send
them to the browser in the HTTP header.  The browser maintains a list
of cookies that belong to a particular Web server, and returns them
to the CGI script during subsequent interactions.

In addition to the required name=value pair, each cookie has several
optional attributes:

=over 4

=item 1. an expiration time

This is a time/date string (in a special GMT format) that indicates
when a cookie expires.  The cookie will be saved and returned to your
script until this expiration date is reached if the user exits
the browser and restarts it.  If an expiration date isn't specified, the cookie
will remain active until the user quits the browser.

=item 2. a domain

This is a partial or complete domain name for which the cookie is 
valid.  The browser will return the cookie to any host that matches
the partial domain name.  For example, if you specify a domain name
of ".capricorn.com", then the browser will return the cookie to
Web servers running on any of the machines "www.capricorn.com", 
"www2.capricorn.com", "feckless.capricorn.com", etc.  Domain names
must contain at least two periods to prevent attempts to match
on top level domains like ".edu".  If no domain is specified, then
the browser will only return the cookie to servers on the host the
cookie originated from.

=item 3. a path

If you provide a cookie path attribute, the browser will check it
against your script's URL before returning the cookie.  For example,
if you specify the path "/cgi-bin", then the cookie will be returned
to each of the scripts "/cgi-bin/tally.pl", "/cgi-bin/order.pl",
and "/cgi-bin/customer_service/complain.pl", but not to the script
"/cgi-private/site_admin.pl".  By default, path is set to "/", which
causes the cookie to be sent to any CGI script on your site.

=item 4. a "secure" flag

If the "secure" attribute is set, the cookie will only be sent to your
script if the CGI request is occurring on a secure channel, such as SSL.

=back

The interface to HTTP cookies is the B<cookie()> method:

    $cookie = cookie(-name=>'sessionID',
			     -value=>'xyzzy',
			     -expires=>'+1h',
			     -path=>'/cgi-bin/database',
			     -domain=>'.capricorn.org',
			     -secure=>1);
    print header(-cookie=>$cookie);

B<cookie()> creates a new cookie.  Its parameters include:

=over 4

=item B<-name>

The name of the cookie (required).  This can be any string at all.
Although browsers limit their cookie names to non-whitespace
alphanumeric characters, CGI.pm removes this restriction by escaping
and unescaping cookies behind the scenes.

=item B<-value>

The value of the cookie.  This can be any scalar value,
array reference, or even hash reference.  For example,
you can store an entire hash into a cookie this way:

	$cookie=cookie(-name=>'family information',
			       -value=>\%childrens_ages);

=item B<-path>

The optional partial path for which this cookie will be valid, as described
above.

=item B<-domain>

The optional partial domain for which this cookie will be valid, as described
above.

=item B<-expires>

The optional expiration date for this cookie.  The format is as described 
in the section on the B<header()> method:

	"+1h"  one hour from now

=item B<-secure>

If set to true, this cookie will only be used within a secure
SSL session.

=back

The cookie created by cookie() must be incorporated into the HTTP
header within the string returned by the header() method:

        use CGI ':standard';
	print header(-cookie=>$my_cookie);

To create multiple cookies, give header() an array reference:

	$cookie1 = cookie(-name=>'riddle_name',
				  -value=>"The Sphynx's Question");
	$cookie2 = cookie(-name=>'answers',
				  -value=>\%answers);
	print header(-cookie=>[$cookie1,$cookie2]);

To retrieve a cookie, request it by name by calling cookie() method
without the B<-value> parameter. This example uses the object-oriented
form:

	use CGI;
	$query = new CGI;
	$riddle = $query->cookie('riddle_name');
        %answers = $query->cookie('answers');

Cookies created with a single scalar value, such as the "riddle_name"
cookie, will be returned in that form.  Cookies with array and hash
values can also be retrieved.

The cookie and CGI namespaces are separate.  If you have a parameter
named 'answers' and a cookie named 'answers', the values retrieved by
param() and cookie() are independent of each other.  However, it's
simple to turn a CGI parameter into a cookie, and vice-versa:

   # turn a CGI parameter into a cookie
   $c=cookie(-name=>'answers',-value=>[param('answers')]);
   # vice-versa
   param(-name=>'answers',-value=>[cookie('answers')]);

If you call cookie() without any parameters, it will return a list of
the names of all cookies passed to your script:

  @@cookies = cookie();

See the B<cookie.cgi> example script for some ideas on how to use
cookies effectively.

=head1 WORKING WITH FRAMES

It's possible for CGI.pm scripts to write into several browser panels
and windows using the HTML 4 frame mechanism.  There are three
techniques for defining new frames programmatically:

=over 4

=item 1. Create a <Frameset> document

After writing out the HTTP header, instead of creating a standard
HTML document using the start_html() call, create a <frameset> 
document that defines the frames on the page.  Specify your script(s)
(with appropriate parameters) as the SRC for each of the frames.

There is no specific support for creating <frameset> sections 
in CGI.pm, but the HTML is very simple to write.  See the frame
documentation in Netscape's home pages for details 

  http://wp.netscape.com/assist/net_sites/frames.html

=item 2. Specify the destination for the document in the HTTP header

You may provide a B<-target> parameter to the header() method:

    print header(-target=>'ResultsWindow');

This will tell the browser to load the output of your script into the
frame named "ResultsWindow".  If a frame of that name doesn't already
exist, the browser will pop up a new window and load your script's
document into that.  There are a number of magic names that you can
use for targets.  See the frame documents on Netscape's home pages for
details.

=item 3. Specify the destination for the document in the <form> tag

You can specify the frame to load in the FORM tag itself.  With
CGI.pm it looks like this:

    print start_form(-target=>'ResultsWindow');

When your script is reinvoked by the form, its output will be loaded
into the frame named "ResultsWindow".  If one doesn't already exist
a new window will be created.

=back

The script "frameset.cgi" in the examples directory shows one way to
create pages in which the fill-out form and the response live in
side-by-side frames.

=head1 SUPPORT FOR JAVASCRIPT

The usual way to use JavaScript is to define a set of functions in a
<SCRIPT> block inside the HTML header and then to register event
handlers in the various elements of the page. Events include such
things as the mouse passing over a form element, a button being
clicked, the contents of a text field changing, or a form being
submitted. When an event occurs that involves an element that has
registered an event handler, its associated JavaScript code gets
called.

The elements that can register event handlers include the <BODY> of an
HTML document, hypertext links, all the various elements of a fill-out
form, and the form itself. There are a large number of events, and
each applies only to the elements for which it is relevant. Here is a
partial list:

=over 4

=item B<onLoad>

The browser is loading the current document. Valid in:

     + The HTML <BODY> section only.

=item B<onUnload>

The browser is closing the current page or frame. Valid for:

     + The HTML <BODY> section only.

=item B<onSubmit>

The user has pressed the submit button of a form. This event happens
just before the form is submitted, and your function can return a
value of false in order to abort the submission.  Valid for:

     + Forms only.

=item B<onClick>

The mouse has clicked on an item in a fill-out form. Valid for:

     + Buttons (including submit, reset, and image buttons)
     + Checkboxes
     + Radio buttons

=item B<onChange>

The user has changed the contents of a field. Valid for:

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=item B<onFocus>

The user has selected a field to work with. Valid for:

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=item B<onBlur>

The user has deselected a field (gone to work somewhere else).  Valid
for:

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=item B<onSelect>

The user has changed the part of a text field that is selected.  Valid
for:

     + Text fields
     + Text areas
     + Password fields
     + File fields

=item B<onMouseOver>

The mouse has moved over an element.

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=item B<onMouseOut>

The mouse has moved off an element.

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=back

In order to register a JavaScript event handler with an HTML element,
just use the event name as a parameter when you call the corresponding
CGI method. For example, to have your validateAge() JavaScript code
executed every time the textfield named "age" changes, generate the
field like this: 

 print textfield(-name=>'age',-onChange=>"validateAge(this)");

This example assumes that you've already declared the validateAge()
function by incorporating it into a <SCRIPT> block. The CGI.pm
start_html() method provides a convenient way to create this section.

Similarly, you can create a form that checks itself over for
consistency and alerts the user if some essential value is missing by
creating it this way: 
  print startform(-onSubmit=>"validateMe(this)");

See the javascript.cgi script for a demonstration of how this all
works.


=head1 LIMITED SUPPORT FOR CASCADING STYLE SHEETS

CGI.pm has limited support for HTML3's cascading style sheets (css).
To incorporate a stylesheet into your document, pass the
start_html() method a B<-style> parameter.  The value of this
parameter may be a scalar, in which case it is treated as the source
URL for the stylesheet, or it may be a hash reference.  In the latter
case you should provide the hash with one or more of B<-src> or
B<-code>.  B<-src> points to a URL where an externally-defined
stylesheet can be found.  B<-code> points to a scalar value to be
incorporated into a <style> section.  Style definitions in B<-code>
override similarly-named ones in B<-src>, hence the name "cascading."

You may also specify the type of the stylesheet by adding the optional
B<-type> parameter to the hash pointed to by B<-style>.  If not
specified, the style defaults to 'text/css'.

To refer to a style within the body of your document, add the
B<-class> parameter to any HTML element:

    print h1({-class=>'Fancy'},'Welcome to the Party');

Or define styles on the fly with the B<-style> parameter:

    print h1({-style=>'Color: red;'},'Welcome to Hell');

You may also use the new B<span()> element to apply a style to a
section of text:

    print span({-style=>'Color: red;'},
	       h1('Welcome to Hell'),
	       "Where did that handbasket get to?"
	       );

Note that you must import the ":html3" definitions to have the
B<span()> method available.  Here's a quick and dirty example of using
CSS's.  See the CSS specification at
http://www.w3.org/pub/WWW/TR/Wd-css-1.html for more information.

    use CGI qw/:standard :html3/;

    #here's a stylesheet incorporated directly into the page
    $newStyle=<<END;
    <!-- 
    P.Tip {
	margin-right: 50pt;
	margin-left: 50pt;
        color: red;
    }
    P.Alert {
	font-size: 30pt;
        font-family: sans-serif;
      color: red;
    }
    -->
    END
    print header();
    print start_html( -title=>'CGI with Style',
		      -style=>{-src=>'http://www.capricorn.com/style/st1.css',
		               -code=>$newStyle}
	             );
    print h1('CGI with Style'),
          p({-class=>'Tip'},
	    "Better read the cascading style sheet spec before playing with this!"),
          span({-style=>'color: magenta'},
	       "Look Mom, no hands!",
	       p(),
	       "Whooo wee!"
	       );
    print end_html;

Pass an array reference to B<-code> or B<-src> in order to incorporate
multiple stylesheets into your document.

Should you wish to incorporate a verbatim stylesheet that includes
arbitrary formatting in the header, you may pass a -verbatim tag to
the -style hash, as follows:

print start_html (-style  =>  {-verbatim => '@@import url("/server-common/css/'.$cssFile.'");',
                  -src    =>  '/server-common/css/core.css'});


This will generate an HTML header that contains this:

 <link rel="stylesheet" type="text/css"  href="/server-common/css/core.css">
   <style type="text/css">
   @@import url("/server-common/css/main.css");
   </style>

Any additional arguments passed in the -style value will be
incorporated into the <link> tag.  For example:

 start_html(-style=>{-src=>['/styles/print.css','/styles/layout.css'],
			  -media => 'all'});

This will give:

 <link rel="stylesheet" type="text/css" href="/styles/print.css" media="all"/>
 <link rel="stylesheet" type="text/css" href="/styles/layout.css" media="all"/>

<p>

To make more complicated <link> tags, use the Link() function
and pass it to start_html() in the -head argument, as in:

  @@h = (Link({-rel=>'stylesheet',-type=>'text/css',-src=>'/ss/ss.css',-media=>'all'}),
        Link({-rel=>'stylesheet',-type=>'text/css',-src=>'/ss/fred.css',-media=>'paper'}));
  print start_html({-head=>\@@h})

To create primary and  "alternate" stylesheet, use the B<-alternate> option:

 start_html(-style=>{-src=>[
                           {-src=>'/styles/print.css'},
			   {-src=>'/styles/alt.css',-alternate=>1}
                           ]
		    });

=head1 DEBUGGING

If you are running the script from the command line or in the perl
debugger, you can pass the script a list of keywords or
parameter=value pairs on the command line or from standard input (you
don't have to worry about tricking your script into reading from
environment variables).  You can pass keywords like this:

    your_script.pl keyword1 keyword2 keyword3

or this:

   your_script.pl keyword1+keyword2+keyword3

or this:

    your_script.pl name1=value1 name2=value2

or this:

    your_script.pl name1=value1&name2=value2

To turn off this feature, use the -no_debug pragma.

To test the POST method, you may enable full debugging with the -debug
pragma.  This will allow you to feed newline-delimited name=value
pairs to the script on standard input.

When debugging, you can use quotes and backslashes to escape 
characters in the familiar shell manner, letting you place
spaces and other funny characters in your parameter=value
pairs:

   your_script.pl "name1='I am a long value'" "name2=two\ words"

Finally, you can set the path info for the script by prefixing the first
name/value parameter with the path followed by a question mark (?):

    your_script.pl /your/path/here?name1=value1&name2=value2

=head2 DUMPING OUT ALL THE NAME/VALUE PAIRS

The Dump() method produces a string consisting of all the query's
name/value pairs formatted nicely as a nested list.  This is useful
for debugging purposes:

    print Dump


Produces something that looks like:

    <ul>
    <li>name1
	<ul>
	<li>value1
	<li>value2
	</ul>
    <li>name2
	<ul>
	<li>value1
	</ul>
    </ul>

As a shortcut, you can interpolate the entire CGI object into a string
and it will be replaced with the a nice HTML dump shown above:

    $query=new CGI;
    print "<h2>Current Values</h2> $query\n";

=head1 FETCHING ENVIRONMENT VARIABLES

Some of the more useful environment variables can be fetched
through this interface.  The methods are as follows:

=over 4

=item B<Accept()>

Return a list of MIME types that the remote browser accepts. If you
give this method a single argument corresponding to a MIME type, as in
Accept('text/html'), it will return a floating point value
corresponding to the browser's preference for this type from 0.0
(don't want) to 1.0.  Glob types (e.g. text/*) in the browser's accept
list are handled correctly.

Note that the capitalization changed between version 2.43 and 2.44 in
order to avoid conflict with Perl's accept() function.

=item B<raw_cookie()>

Returns the HTTP_COOKIE variable.  Cookies have a special format, and
this method call just returns the raw form (?cookie dough).  See
cookie() for ways of setting and retrieving cooked cookies.

Called with no parameters, raw_cookie() returns the packed cookie
structure.  You can separate it into individual cookies by splitting
on the character sequence "; ".  Called with the name of a cookie,
retrieves the B<unescaped> form of the cookie.  You can use the
regular cookie() method to get the names, or use the raw_fetch()
method from the CGI::Cookie module.

=item B<user_agent()>

Returns the HTTP_USER_AGENT variable.  If you give
this method a single argument, it will attempt to
pattern match on it, allowing you to do something
like user_agent(Mozilla);

=item B<path_info()>

Returns additional path information from the script URL.
E.G. fetching /cgi-bin/your_script/additional/stuff will result in
path_info() returning "/additional/stuff".

NOTE: The Microsoft Internet Information Server
is broken with respect to additional path information.  If
you use the Perl DLL library, the IIS server will attempt to
execute the additional path information as a Perl script.
If you use the ordinary file associations mapping, the
path information will be present in the environment, 
but incorrect.  The best thing to do is to avoid using additional
path information in CGI scripts destined for use with IIS.

=item B<path_translated()>

As per path_info() but returns the additional
path information translated into a physical path, e.g.
"/usr/local/etc/httpd/htdocs/additional/stuff".

The Microsoft IIS is broken with respect to the translated
path as well.

=item B<remote_host()>

Returns either the remote host name or IP address.
if the former is unavailable.

=item B<script_name()>
Return the script name as a partial URL, for self-refering
scripts.

=item B<referer()>

Return the URL of the page the browser was viewing
prior to fetching your script.  Not available for all
browsers.

=item B<auth_type ()>

Return the authorization/verification method in use for this
script, if any.

=item B<server_name ()>

Returns the name of the server, usually the machine's host
name.

=item B<virtual_host ()>

When using virtual hosts, returns the name of the host that
the browser attempted to contact

=item B<server_port ()>

Return the port that the server is listening on.

=item B<virtual_port ()>

Like server_port() except that it takes virtual hosts into account.
Use this when running with virtual hosts.

=item B<server_software ()>

Returns the server software and version number.

=item B<remote_user ()>

Return the authorization/verification name used for user
verification, if this script is protected.

=item B<user_name ()>

Attempt to obtain the remote user's name, using a variety of different
techniques.  This only works with older browsers such as Mosaic.
Newer browsers do not report the user name for privacy reasons!

=item B<request_method()>

Returns the method used to access your script, usually
one of 'POST', 'GET' or 'HEAD'.

=item B<content_type()>

Returns the content_type of data submitted in a POST, generally 
multipart/form-data or application/x-www-form-urlencoded

=item B<http()>

Called with no arguments returns the list of HTTP environment
variables, including such things as HTTP_USER_AGENT,
HTTP_ACCEPT_LANGUAGE, and HTTP_ACCEPT_CHARSET, corresponding to the
like-named HTTP header fields in the request.  Called with the name of
an HTTP header field, returns its value.  Capitalization and the use
of hyphens versus underscores are not significant.

For example, all three of these examples are equivalent:

   $requested_language = http('Accept-language');
   $requested_language = http('Accept_language');
   $requested_language = http('HTTP_ACCEPT_LANGUAGE');

=item B<https()>

The same as I<http()>, but operates on the HTTPS environment variables
present when the SSL protocol is in effect.  Can be used to determine
whether SSL is turned on.

=back

=head1 USING NPH SCRIPTS

NPH, or "no-parsed-header", scripts bypass the server completely by
sending the complete HTTP header directly to the browser.  This has
slight performance benefits, but is of most use for taking advantage
of HTTP extensions that are not directly supported by your server,
such as server push and PICS headers.

Servers use a variety of conventions for designating CGI scripts as
NPH.  Many Unix servers look at the beginning of the script's name for
the prefix "nph-".  The Macintosh WebSTAR server and Microsoft's
Internet Information Server, in contrast, try to decide whether a
program is an NPH script by examining the first line of script output.


CGI.pm supports NPH scripts with a special NPH mode.  When in this
mode, CGI.pm will output the necessary extra header information when
the header() and redirect() methods are
called.

The Microsoft Internet Information Server requires NPH mode.  As of
version 2.30, CGI.pm will automatically detect when the script is
running under IIS and put itself into this mode.  You do not need to
do this manually, although it won't hurt anything if you do.  However,
note that if you have applied Service Pack 6, much of the
functionality of NPH scripts, including the ability to redirect while
setting a cookie, B<do not work at all> on IIS without a special patch
from Microsoft.  See
http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP:
Non-Parsed Headers Stripped From CGI Applications That Have nph-
Prefix in Name.

=over 4

=item In the B<use> statement 

Simply add the "-nph" pragmato the list of symbols to be imported into
your script:

      use CGI qw(:standard -nph)

=item By calling the B<nph()> method:

Call B<nph()> with a non-zero parameter at any point after using CGI.pm in your program.

      CGI->nph(1)

=item By using B<-nph> parameters

in the B<header()> and B<redirect()>  statements:

      print header(-nph=>1);

=back

=head1 Server Push

CGI.pm provides four simple functions for producing multipart
documents of the type needed to implement server push.  These
functions were graciously provided by Ed Jordan <ed@@fidalgo.net>.  To
import these into your namespace, you must import the ":push" set.
You are also advised to put the script into NPH mode and to set $| to
1 to avoid buffering problems.

Here is a simple script that demonstrates server push:

  #!/usr/local/bin/perl
  use CGI qw/:push -nph/;
  $| = 1;
  print multipart_init(-boundary=>'----here we go!');
  for (0 .. 4) {
      print multipart_start(-type=>'text/plain'),
            "The current time is ",scalar(localtime),"\n";
      if ($_ < 4) {
              print multipart_end;
      } else {
              print multipart_final;
      }
      sleep 1;
  }

This script initializes server push by calling B<multipart_init()>.
It then enters a loop in which it begins a new multipart section by
calling B<multipart_start()>, prints the current local time,
and ends a multipart section with B<multipart_end()>.  It then sleeps
a second, and begins again. On the final iteration, it ends the
multipart section with B<multipart_final()> rather than with
B<multipart_end()>.

=over 4

=item multipart_init()

  multipart_init(-boundary=>$boundary);

Initialize the multipart system.  The -boundary argument specifies
what MIME boundary string to use to separate parts of the document.
If not provided, CGI.pm chooses a reasonable boundary for you.

=item multipart_start()

  multipart_start(-type=>$type)

Start a new part of the multipart document using the specified MIME
type.  If not specified, text/html is assumed.

=item multipart_end()

  multipart_end()

End a part.  You must remember to call multipart_end() once for each
multipart_start(), except at the end of the last part of the multipart
document when multipart_final() should be called instead of multipart_end().

=item multipart_final()

  multipart_final()

End all parts.  You should call multipart_final() rather than
multipart_end() at the end of the last part of the multipart document.

=back

Users interested in server push applications should also have a look
at the CGI::Push module.

=head1 Avoiding Denial of Service Attacks

A potential problem with CGI.pm is that, by default, it attempts to
process form POSTings no matter how large they are.  A wily hacker
could attack your site by sending a CGI script a huge POST of many
megabytes.  CGI.pm will attempt to read the entire POST into a
variable, growing hugely in size until it runs out of memory.  While
the script attempts to allocate the memory the system may slow down
dramatically.  This is a form of denial of service attack.

Another possible attack is for the remote user to force CGI.pm to
accept a huge file upload.  CGI.pm will accept the upload and store it
in a temporary directory even if your script doesn't expect to receive
an uploaded file.  CGI.pm will delete the file automatically when it
terminates, but in the meantime the remote user may have filled up the
server's disk space, causing problems for other programs.

The best way to avoid denial of service attacks is to limit the amount
of memory, CPU time and disk space that CGI scripts can use.  Some Web
servers come with built-in facilities to accomplish this. In other
cases, you can use the shell I<limit> or I<ulimit>
commands to put ceilings on CGI resource usage.


CGI.pm also has some simple built-in protections against denial of
service attacks, but you must activate them before you can use them.
These take the form of two global variables in the CGI name space:

=over 4

=item B<$CGI::POST_MAX>

If set to a non-negative integer, this variable puts a ceiling
on the size of POSTings, in bytes.  If CGI.pm detects a POST
that is greater than the ceiling, it will immediately exit with an error
message.  This value will affect both ordinary POSTs and
multipart POSTs, meaning that it limits the maximum size of file
uploads as well.  You should set this to a reasonably high
value, such as 1 megabyte.

=item B<$CGI::DISABLE_UPLOADS>

If set to a non-zero value, this will disable file uploads
completely.  Other fill-out form values will work as usual.

=back

You can use these variables in either of two ways.

=over 4

=item B<1. On a script-by-script basis>

Set the variable at the top of the script, right after the "use" statement:

    use CGI qw/:standard/;
    use CGI::Carp 'fatalsToBrowser';
    $CGI::POST_MAX=1024 * 100;  # max 100K posts
    $CGI::DISABLE_UPLOADS = 1;  # no uploads

=item B<2. Globally for all scripts>

Open up CGI.pm, find the definitions for $POST_MAX and 
$DISABLE_UPLOADS, and set them to the desired values.  You'll 
find them towards the top of the file in a subroutine named 
initialize_globals().

=back

An attempt to send a POST larger than $POST_MAX bytes will cause
I<param()> to return an empty CGI parameter list.  You can test for
this event by checking I<cgi_error()>, either after you create the CGI
object or, if you are using the function-oriented interface, call
<param()> for the first time.  If the POST was intercepted, then
cgi_error() will return the message "413 POST too large".

This error message is actually defined by the HTTP protocol, and is
designed to be returned to the browser as the CGI script's status
 code.  For example:

   $uploaded_file = param('upload');
   if (!$uploaded_file && cgi_error()) {
      print header(-status=>cgi_error());
      exit 0;
   }

However it isn't clear that any browser currently knows what to do
with this status code.  It might be better just to create an
HTML page that warns the user of the problem.

=head1 COMPATIBILITY WITH CGI-LIB.PL

To make it easier to port existing programs that use cgi-lib.pl the
compatibility routine "ReadParse" is provided.  Porting is simple:

OLD VERSION
    require "cgi-lib.pl";
    &ReadParse;
    print "The value of the antique is $in{antique}.\n";

NEW VERSION
    use CGI;
    CGI::ReadParse();
    print "The value of the antique is $in{antique}.\n";

CGI.pm's ReadParse() routine creates a tied variable named %in,
which can be accessed to obtain the query variables.  Like
ReadParse, you can also provide your own variable.  Infrequently
used features of ReadParse, such as the creation of @@in and $in 
variables, are not supported.

Once you use ReadParse, you can retrieve the query object itself
this way:

    $q = $in{CGI};
    print textfield(-name=>'wow',
			-value=>'does this really work?');

This allows you to start using the more interesting features
of CGI.pm without rewriting your old scripts from scratch.

=head1 AUTHOR INFORMATION

The GD.pm interface is copyright 1995-2007, Lincoln D. Stein.  It is
distributed under GPL and the Artistic License 2.0.

Address bug reports and comments to: lstein@@cshl.org.  When sending
bug reports, please provide the version of CGI.pm, the version of
Perl, the name and version of your Web server, and the name and
version of the operating system you are using.  If the problem is even
remotely browser dependent, please provide information about the
affected browers as well.

=head1 CREDITS

Thanks very much to:

=over 4

=item Matt Heffron (heffron@@falstaff.css.beckman.com)

=item James Taylor (james.taylor@@srs.gov)

=item Scott Anguish <sanguish@@digifix.com>

=item Mike Jewell (mlj3u@@virginia.edu)

=item Timothy Shimmin (tes@@kbs.citri.edu.au)

=item Joergen Haegg (jh@@axis.se)

=item Laurent Delfosse (delfosse@@delfosse.com)

=item Richard Resnick (applepi1@@aol.com)

=item Craig Bishop (csb@@barwonwater.vic.gov.au)

=item Tony Curtis (tc@@vcpc.univie.ac.at)

=item Tim Bunce (Tim.Bunce@@ig.co.uk)

=item Tom Christiansen (tchrist@@convex.com)

=item Andreas Koenig (k@@franz.ww.TU-Berlin.DE)

=item Tim MacKenzie (Tim.MacKenzie@@fulcrum.com.au)

=item Kevin B. Hendricks (kbhend@@dogwood.tyler.wm.edu)

=item Stephen Dahmen (joyfire@@inxpress.net)

=item Ed Jordan (ed@@fidalgo.net)

=item David Alan Pisoni (david@@cnation.com)

=item Doug MacEachern (dougm@@opengroup.org)

=item Robin Houston (robin@@oneworld.org)

=item ...and many many more...

for suggestions and bug fixes.

=back

=head1 A COMPLETE EXAMPLE OF A SIMPLE FORM-BASED SCRIPT


	#!/usr/local/bin/perl

	use CGI ':standard';

	print header;
	print start_html("Example CGI.pm Form");
	print "<h1> Example CGI.pm Form</h1>\n";
        print_prompt();
	do_work();
	print_tail();
	print end_html;

	sub print_prompt {
	   print start_form;
	   print "<em>What's your name?</em><br>";
	   print textfield('name');
	   print checkbox('Not my real name');

	   print "<p><em>Where can you find English Sparrows?</em><br>";
	   print checkbox_group(
				 -name=>'Sparrow locations',
				 -values=>[England,France,Spain,Asia,Hoboken],
				 -linebreak=>'yes',
				 -defaults=>[England,Asia]);

	   print "<p><em>How far can they fly?</em><br>",
		radio_group(
			-name=>'how far',
			-values=>['10 ft','1 mile','10 miles','real far'],
			-default=>'1 mile');

	   print "<p><em>What's your favorite color?</em>  ";
	   print popup_menu(-name=>'Color',
				    -values=>['black','brown','red','yellow'],
				    -default=>'red');

	   print hidden('Reference','Monty Python and the Holy Grail');

	   print "<p><em>What have you got there?</em><br>";
	   print scrolling_list(
			 -name=>'possessions',
			 -values=>['A Coconut','A Grail','An Icon',
				   'A Sword','A Ticket'],
			 -size=>5,
			 -multiple=>'true');

	   print "<p><em>Any parting comments?</em><br>";
	   print textarea(-name=>'Comments',
				  -rows=>10,
				  -columns=>50);

	   print "<p>",reset;
	   print submit('Action','Shout');
	   print submit('Action','Scream');
	   print endform;
	   print "<hr>\n";
	}

	sub do_work {
	   my(@@values,$key);

	   print "<h2>Here are the current settings in this form</h2>";

	   for $key (param) {
	      print "<strong>$key</strong> -> ";
	      @@values = param($key);
	      print join(", ",@@values),"<br>\n";
	  }
	}

	sub print_tail {
	   print <<END;
	<hr>
	<address>Lincoln D. Stein</address><br>
	<a href="/">Home Page</a>
	END
	}

=head1 BUGS

Please report them.

=head1 SEE ALSO

L<CGI::Carp>, L<CGI::Fast>, L<CGI::Pretty>

=cut

@


1.13
log
@Merge in perl 5.10.1
@
text
@d21 1
a21 1
$CGI::revision = '$Id: CGI.pm,v 1.263 2009/02/11 16:56:37 lstein Exp $';
@


1.12
log
@s/postion/position/g
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.11 2008/09/29 17:36:08 millert Exp $';
$CGI::VERSION='3.29';
d27 1
a27 1
use CGI::Util qw(rearrange make_attributes unescape escape expires ebcdic2ascii ascii2ebcdic);
d40 6
a45 1
$MOD_PERL = 0; # no mod_perl by default
a98 7
    # Set this to a positive value to limit the size of a POSTing
    # to a certain number of bytes:
    $POST_MAX = -1;

    # Change this to 1 to disable uploads entirely:
    $DISABLE_UPLOADS = 0;

d112 3
d230 1
a230 1
		':html3'=>[qw/div table caption th td TR Tr sup Sub strike applet Param 
d297 1
a297 1
    foreach $sym (keys %EXPORT) {
d300 1
a300 1
	foreach $pck (@@packages) {
d320 1
a320 1
    foreach (@@{$EXPORT_TAGS{$tag}}) {
d356 1
d365 1
d384 1
a384 1
    foreach my $href (values %{$self->{'.tmpfiles'}}) {
d436 1
a436 1
	    foreach ($value,@@other) {
d443 1
a443 1
	    $self->{$name}=[@@values];
d449 3
a451 1
    return unless defined($name) && $self->{$name};
d453 3
a455 8
    my $charset = $self->charset || '';
    my $utf8    = $charset eq 'utf-8';
    if ($utf8) {
      eval "require Encode; 1;" if $utf8 && !Encode->can('decode'); # bring in these functions
      return wantarray ? map {Encode::decode(utf8=>$_) } @@{$self->{$name}} 
                       : Encode::decode(utf8=>$self->{$name}->[0]);
    } else {
      return wantarray ? @@{$self->{$name}} : $self->{$name}->[0];
d457 2
d491 1
a491 1
# to an associative array in which parameter names are keys
d579 1
a579 1
                      push (@@{$self->{$param}},$value);
d586 1
a586 1
                      push (@@{$self->{$param}},$value);
d606 1
a606 1
	      foreach (keys %$initializer) {
d646 1
a646 1
      if ($meth eq 'POST') {
d672 1
a672 1
    if (!$is_xforms && $meth eq 'POST'
d676 1
a676 1
        my($param) = 'POSTDATA' ;
d678 1
a678 1
      push (@@{$self->{$param}},$query_string);
d690 1
a690 1
	    $self->{'keywords'} = [$self->parse_keywordlist($query_string)];
d700 1
a700 1
    # Associative array containing our defined fieldnames
d702 1
a702 1
    foreach ($self->param('.cgifields')) {
d755 1
a755 1
    foreach (@@QUERY_PARAM) {
d757 1
a757 1
      $QUERY_PARAM{$_}=$self->{$_};
d768 1
a768 1
    foreach (@@pairs) {
d776 1
a776 1
	push (@@{$self->{$param}},$value);
d784 1
a784 1
	unless defined($self->{$param});
d902 1
a902 1
    foreach (@@_) {
d909 1
d931 1
a931 1
	foreach (&expand_tags($_)) {
d1009 1
a1009 1
    foreach my $name (@@to_delete)
d1011 1
a1011 1
        CORE::delete $self->{$name};
d1031 1
a1031 1
	foreach (keys %{"${namespace}::"}) {
d1039 1
a1039 1
    foreach $param ($self->param) {
d1060 2
a1061 2
    $self->{'keywords'}=[@@values] if @@values;
    my(@@result) = defined($self->{'keywords'}) ? @@{$self->{'keywords'}} : ();
d1179 1
a1179 1
    exists $_[0]->{$_[1]};
d1206 1
a1206 1
	push(@@{$self->{$name}},@@values);
d1273 1
a1273 1
	    foreach (@@pairs) {
d1301 1
a1301 1
    foreach $param ($self->param) {
d1305 1
a1305 1
	foreach $value ($self->param($param)) {
d1338 1
a1338 1
    foreach $param ($self->param) {
d1341 1
a1341 1
	foreach $value ($self->param($param)) {
d1345 1
a1345 1
    foreach (keys %{$self->{'.fieldnames'}}) {
d1384 1
a1384 1
    my($boundary,@@other) = rearrange([BOUNDARY],@@p);
d1414 1
a1414 1
    foreach (@@other) {
d1483 1
a1483 1
    foreach (@@other) {
d1509 1
a1509 1
	foreach (@@cookie) {
d1525 1
a1525 1
    if ($MOD_PERL and not $nph) {
d1562 1
a1562 1
    foreach (@@other) { tr/\"//d; push(@@o,split("=",$_,2)); }
d1665 1
a1665 1
	foreach (keys %$meta) { push(@@result,$XHTML ? qq(<meta name="$_" content="$meta->{$_}" />) 
d1669 11
a1679 1
    push(@@result,ref($head) ? @@$head : $head) if $head;
d1684 1
a1684 1
    push(@@result,$meta_bits)              if defined $meta_bits;
d1715 1
d1725 1
a1725 1
       my $other = @@other ? join ' ',@@other : '';
d1729 1
a1729 1
           foreach $src (@@$src)
d1743 1
a1743 1
           push(@@result, "<style type=\"text/css\">\n$_\n</style>") foreach @@v;
d1746 1
a1746 1
      push(@@result,style({'type'=>$type},"$cdata_start\n$_\n$cdata_end")) foreach @@c;
d1764 1
a1764 1
    foreach $script (@@scripts) {
d1848 1
a1848 1
    $method  = $self->escapeHTML(lc($method) || 'post');
d2164 3
a2166 2
    my($name,$checked,$value,$label,$override,$tabindex,@@other) = 
	rearrange([NAME,[CHECKED,SELECTED,ON],VALUE,LABEL,[OVERRIDE,FORCE],TABINDEX],@@p);
d2183 2
a2184 1
    return $XHTML ? CGI::label(qq{<input type="checkbox" name="$name" value="$value" $tabindex$checked$other/>$the_label})
d2211 5
a2215 3
         my $latin = uc $self->{'.charset'} eq 'ISO-8859-1' ||
                     uc $self->{'.charset'} eq 'WINDOWS-1252';
         if ($latin) {  # bug in some browsers
d2272 1
a2272 1
    foreach (@@colheaders) {
d2301 1
a2301 1
#             A pointer to an associative array of labels to print next to each checkbox
d2329 1
a2329 1
#             A pointer to an associative array of labels to print next to each checkbox
d2348 2
a2349 2
    my($name,$values,$defaults,$linebreak,$labels,$attributes,
       $rows,$columns,$rowheaders,$colheaders,
d2351 5
a2355 4
       rearrange([      NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LINEBREAK,LABELS,ATTRIBUTES,
		        ROWS,[COLUMNS,COLS],[ROWHEADERS,ROWHEADER],[COLHEADERS,COLHEADER],
			[OVERRIDE,FORCE],NOLABELS,TABINDEX,DISABLED
                 ],@@_);
d2383 1
a2383 1
    foreach (@@{$disabled}) {
d2387 1
a2387 1
    foreach (@@values) {
d2415 1
a2415 1
              CGI::label(
d2437 1
a2437 1
#             A pointer to an associative array of labels to print next to each checkbox
d2450 1
a2450 1
    my($result,$selected);
d2453 5
a2457 3
	$selected = $self->param($name);
    } else {
	$selected = $default;
d2466 1
a2466 1
    foreach (@@values) {
d2468 1
a2468 1
            foreach (split(/\n/)) {
d2470 4
a2473 2
                s/(value="$selected")/$selectit $1/ if defined $selected;
                $result .= "$_\n";
d2477 7
a2483 7
          my $attribs = $self->_set_attributes($_, $attributes);
	  my($selectit) = defined($selected) ? $self->_selected($selected eq $_) : '';
	  my($label) = $_;
	  $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
	  my($value) = $self->escapeHTML($_);
	  $label=$self->escapeHTML($label,1);
          $result .= "<option${attribs} ${selectit}value=\"$value\">$label</option>\n";
d2500 1
a2500 1
#              A pointer to an associative array of labels to print next to each item
d2527 1
a2527 1
    foreach (@@values) {
d2529 1
a2529 1
            foreach (split(/\n/)) {
d2567 1
a2567 1
#             A pointer to an associative array of labels to print next to each checkbox
d2586 1
d2594 1
a2594 1
    foreach (@@values) {
d2634 1
a2634 1
	foreach ($default,$override,@@other) {
d2644 1
a2644 1
    foreach (@@value) {
d2719 1
a2719 1
    my $rewrite_in_use = $request_uri && $request_uri !~ /^$script_name/;
d2723 3
a2725 2
    $uri            =~ s/\?.*$//;                                 # remove query string
    $uri            =~ s/\Q$path\E$//      if defined $path;      # remove path
d2751 1
d2822 1
a2822 1
    unless (exists($self->{$name})) {
d2824 1
a2824 1
	$self->{$name} = [];
d2827 1
a2827 1
    return $self->{$name};
d2853 28
a2880 1
# WE USE THIS TO COMPENSATE FOR A BUG IN APACHE 2 PRESENT AT LEAST UP THROUGH 2.0.54
d2883 22
a2904 21
   my $self = shift;
   my $raw_script_name = $ENV{SCRIPT_NAME} || '';
   my $raw_path_info   = $ENV{PATH_INFO}   || '';
   my $uri             = unescape($self->request_uri) || '';

   my $protected    = quotemeta($raw_path_info);
   $raw_script_name =~ s/$protected$//;

   my @@uri_double_slashes  = $uri =~ m^(/{2,}?)^g;
   my @@path_double_slashes = "$raw_script_name $raw_path_info" =~ m^(/{2,}?)^g;

   my $apache_bug      = @@uri_double_slashes != @@path_double_slashes;
   return ($raw_script_name,$raw_path_info) unless $apache_bug;

   my $path_info_search = quotemeta($raw_path_info);
   $path_info_search    =~ s!/!/+!g;
   if ($uri =~ m/^(.+)($path_info_search)/) {
       return ($1,$2);
   } else {
       return ($raw_script_name,$raw_path_info);
   }
d2956 1
a2956 1
    foreach $param ($self->param) {
d2958 1
a2958 1
	foreach $value ($self->param($param)) {
d2964 1
a2964 1
    foreach (keys %{$self->{'.fieldnames'}}) {
d2988 3
a2990 1
    my(@@accept) = split(',',$self->http('accept'));
d2992 1
a2992 1
    foreach (@@accept) {
d3011 1
a3011 1
    foreach (keys %prefs) {
d3192 1
a3192 1
    foreach (keys %ENV) {
d3211 1
a3211 1
    foreach (keys %ENV) {
d3343 1
a3343 1
	grep($selected{$_}++,$self->param($name));
d3346 1
a3346 1
	grep($selected{$_}++,@@{$defaults});
d3385 1
a3385 1
    foreach (@@words) {
d3427 2
d3432 9
a3440 2
	# Bug:  Netscape doesn't escape quotation marks in file names!!!
	my($filename) = $header{'Content-Disposition'}=~/ filename="([^"]*)"/;
d3454 1
a3454 1
	    push(@@{$self->{$param}},$value);
d3491 1
a3491 1
	      foreach ( keys %header ) {
d3499 1
a3499 1
          my $totalbytes;
d3530 1
a3530 1
	  push(@@{$self->{$param}},$filehandle);
d3632 1
a3632 1
	  push(@@{$self->{$param}},$filehandle);
d3684 1
a3684 1
    foreach my $attrib (keys %{$attributes->{$element}}) {
d3695 1
a3695 1
    foreach (@@_) {
d3713 1
d3765 1
a3765 1
    $file =~ m!^([a-zA-Z0-9_ \'\":/.\$\\-]+)$! || return;
d3774 8
d3845 1
a3845 1
		CHUNKED=>!defined $length,
d4063 8
d4082 1
a4082 1
    foreach (@@TEMP) {
d4099 1
a4099 1
    $$self =~ m!^([a-zA-Z0-9_ \'\":/.\$\\-]+)$! || return;
d4117 1
a4117 1
	last if ! -f ($filename = sprintf("${TMPDIRECTORY}${SL}CGItemp%d",$sequence++));
d4120 1
a4120 1
    return unless $filename =~ m!^([a-zA-Z0-9_ \'\":/.\$\\-]+)$!;
d4160 1
a4160 1
CGI - Simple Common Gateway Interface Class
d4164 1
a4164 2
  # CGI script that creates a fill-out form
  # and echoes back its values.
d4166 1
a4166 26
  use CGI qw/:standard/;
  print header,
        start_html('A Simple Example'),
        h1('A Simple Example'),
        start_form,
        "What's your name? ",textfield('name'),p,
        "What's the combination?", p,
        checkbox_group(-name=>'words',
		       -values=>['eenie','meenie','minie','moe'],
		       -defaults=>['eenie','minie']), p,
        "What's your favorite color? ",
        popup_menu(-name=>'color',
	           -values=>['red','green','blue','chartreuse']),p,
        submit,
        end_form,
        hr;

   if (param()) {
       my $name      = param('name');
       my $keywords  = join ', ',param('words');
       my $color     = param('color');
       print "Your name is",em(escapeHTML($name)),p,
	     "The keywords are: ",em(escapeHTML($keywords)),p,
	     "Your favorite color is ",em(escapeHTML($color)),
	     hr;
   }
d4168 2
a4169 1
=head1 ABSTRACT
d4171 1
a4171 11
This perl library uses perl5 objects to make it easy to create Web
fill-out forms and parse their contents.  This package defines CGI
objects, entities that contain the values of the current query string
and other state variables.  Using a CGI object's methods, you can
examine keywords and parameters passed to your script, and create
forms whose initial values are taken from the current query (thereby
preserving state information).  The module provides shortcut functions
that produce boilerplate HTML, reducing typing and coding errors. It
also provides functionality for some of the more advanced features of
CGI scripting, including support for file uploads, cookies, cascading
style sheets, server push, and frames.
d4173 14
a4186 2
CGI.pm also provides a simple function-oriented programming style for
those who don't need its object-oriented features.
d4188 1
a4188 1
The current version of CGI.pm is available at
d4190 1
a4190 2
  http://www.genome.wi.mit.edu/ftp/pub/software/WWW/cgi_docs.html
  ftp://ftp-genome.wi.mit.edu/pub/software/WWW/
d4192 13
a4204 1
=head1 DESCRIPTION
d4400 1
a4400 1
You can also initialize the query object from an associative array
d4465 1
a4465 2
"name1=&name2=" or "name1&name2", it will be returned as an empty
string.  This feature is new in 2.63.
d4549 4
d4630 1
a4630 1
   foreach (0..$records) {
d4888 10
d5215 1
a5215 1
argument.  This argument expects a reference to an associative array
d5474 1
a5474 1
(the original request URI). Set -rewrite->0 to return URLs that match
d5554 2
a5555 2
If the first argument is an associative array reference, then the keys
and values of the associative array become the HTML tag's attributes:
d6073 2
a6074 1
filehandle, or undef if the parameter is not a valid filehandle.
d6081 1
a6081 1
In an list context, upload() will return an array of filehandles.
d6087 5
a6091 3
For robust code, consider reseting the file handle position to beginning of the
file. Inside of larger frameworks, other code may have already used the query
object and changed the filehandle position:
d6093 1
a6093 1
  seek($fh,0,0); # reset position to beginning of file.
d6100 1
a6100 1
an associative array containing all the document headers.
d6191 1
a6191 1
			    -default=>'meenie',
d6214 2
a6215 1
The values of the previous choice will be maintained across queries.
d6222 1
a6222 1
associative array relating menu values to user-visible labels.  If you
d6230 2
a6231 2
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
d6283 1
a6283 1
to an associative array containing user-visible labels for one or more
d6310 2
a6311 2
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
d6371 1
a6371 1
The optional sixth argument is a pointer to an associative array
d6379 2
a6380 2
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
d6444 1
a6444 1
The optional b<-labels> argument is a pointer to an associative array
d6456 1
a6456 1
The option b<-disabled> takes an array of checkbox values and disables
d6461 1
a6461 1
an associative array relating menu values to another associative array
d6479 3
d6635 1
a6635 1
an associative array relating menu values to another associative array
d6639 3
d6805 1
a6805 3
pointed to by the B<-onClick> parameter will be executed.  On
non-Netscape browsers this form element will probably not even
display.
d6809 3
a6811 4
Netscape browsers versions 1.1 and higher, and all versions of
Internet Explorer, support a so-called "cookie" designed to help
maintain state within a browser session.  CGI.pm has several methods
that support cookies.
d6886 2
a6887 2
array reference, or even associative array reference.  For example,
you can store an entire associative array into a cookie this way:
a7013 13
Netscape versions 2.0 and higher incorporate an interpreted language
called JavaScript. Internet Explorer, 3.0 and higher, supports a
closely-related dialect called JScript. JavaScript isn't the same as
Java, and certainly isn't at all the same as Perl, which is a great
pity. JavaScript allows you to programmatically change the contents of
fill-out forms, create new windows, and pop up dialog box from within
Netscape itself. From the point of view of CGI scripting, JavaScript
is quite useful for validating fill-out forms prior to submitting
them.

You'll need to know JavaScript in order to use it. There are many good
sources in bookstores and on the web.

d7355 3
a7357 5
Returns the HTTP_COOKIE variable, an HTTP extension implemented by
Netscape browsers version 1.1 and higher, and all versions of Internet
Explorer.  Cookies have a special format, and this method call just
returns the raw form (?cookie dough).  See cookie() for ways of
setting and retrieving cooked cookies.
d7371 1
a7371 1
like user_agent(netscape);
d7510 1
a7510 1
setting a cookie, b<do not work at all> on IIS without a special patch
d7554 1
a7554 1
  foreach (0 .. 4) {
a7609 3
Only Netscape Navigator supports server push.  Internet Explorer
browsers do not.

d7733 2
a7734 4
Copyright 1995-1998, Lincoln D. Stein.  All rights reserved.  

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
d7861 1
a7861 1
	   foreach $key (param) {
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d21 1
a21 1
$CGI::revision = '$Id: CGI.pm,v 1.234 2007/04/16 16:58:46 lstein Exp $';
d6005 1
a6005 1
object and changed the filehandle postion:
d6007 1
a6007 1
  seek($fh,0,0); # reset postion to beginning of file.
@


1.10
log
@merge in perl 5.8.8
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.194 2005/12/06 22:12:56 lstein Exp $';
$CGI::VERSION='3.15';
d43 1
d122 1
d334 4
d348 1
d402 1
a402 1
  my ($hook,$data) = @@_;
d405 1
d438 1
a438 1
	if (@@values) {
d447 10
a456 1
    return wantarray ? @@{$self->{$name}} : $self->{$name}->[0];
d498 2
d510 14
a523 6
	foreach (@@QUERY_PARAM) {
	    $self->param('-name'=>$_,'-value'=>$QUERY_PARAM{$_});
	}
	$self->charset($QUERY_CHARSET);
	$self->{'.fieldnames'} = {%QUERY_FIELDNAMES};
	return;
d538 4
a541 11
	# quietly read and discard the post
	  my $buffer;
          my $tmplength = $content_length;
          while($tmplength > 0) {
                 my $maxbuffer = ($tmplength < 10000)?$tmplength:10000;
                 my $bytesread = $MOD_PERL ? $self->r->read($buffer,$maxbuffer) : read(STDIN,$buffer,$maxbuffer);
                 $tmplength -= $bytesread;
          }
          $self->cgi_error("413 Request entity too large");
          last METHOD;
       }
d555 41
d598 1
a598 1
      if (defined($initializer)) {
a608 15
	  
	  if (defined($fh) && ($fh ne '')) {
	      while (<$fh>) {
		  chomp;
		  last if /^=/;
		  push(@@lines,$_);
	      }
	      # massage back into standard format
	      if ("@@lines" =~ /=/) {
		  $query_string=join("&",@@lines);
	      } else {
		  $query_string=join("+",@@lines);
	      }
	      last METHOD;
	  }
d634 1
a634 1
      if ($meth=~/^(GET|HEAD)$/) {
d670 1
a670 1
    if ($meth eq 'POST'
d759 1
d1468 3
d1474 1
a1474 1
      $charset = $self->charset;
d1476 1
d1486 5
a1490 2
    $type ||= 'text/html' unless defined($type);
    $type .= "; charset=$charset" if $type ne '' and $type =~ m!^text/! and $type !~ /\bcharset\b/ and $charset ne '';
d1556 1
a1556 1
    $status = '302 Moved' unless defined $status;
d1603 1
a1603 1
    $encoding = 'iso-8859-1' unless defined $encoding;
d1693 1
d1695 2
d1705 2
a1706 2
       my($src,$code,$verbatim,$stype,$foo,@@other) =
           rearrange([qw(SRC CODE VERBATIM TYPE FOO)],
d1709 2
a1710 1
       $type  = $stype if $stype;
d1717 2
a1718 2
           push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
                             : qq(<link rel="stylesheet" type="$type" href="$src"$other>)) if $src;
d1723 2
a1724 2
         push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
                             : qq(<link rel="stylesheet" type="$type" href="$src"$other>)
d1736 2
a1737 2
           push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
                               : qq(<link rel="stylesheet" type="$type" href="$src"$other>));
d1753 2
a1754 2
	    ($src,$code,$language, $type) =
		rearrange([SRC,CODE,LANGUAGE,TYPE],
d1757 4
a1760 6
            # User may not have specified language
            $language ||= 'JavaScript';
            unless (defined $type) {
                $type = lc $language;
                # strip '1.2' from 'javascript1.2'
                $type =~ s/^(\D+).*$/text\/$1/;
d1763 1
a1763 1
	    ($src,$code,$language, $type) = ('',$script,'JavaScript', 'text/javascript');
a1780 1
     push(@@satts,'language'=>$language) unless defined $type;
d1840 1
a1840 1
       $action = $self->escapeHTML($self->request_uri);
d1870 1
a1870 3
	my(%p) = @@p;
	$p{'-enctype'}=&MULTIPART;
	return $self->startform(%p);
d2332 1
a2332 1
       $override,$nolabels,$tabindex,@@other) =
d2334 2
a2335 2
		        ROWS,[COLUMNS,COLS],ROWHEADERS,COLHEADERS,
			[OVERRIDE,FORCE],NOLABELS,TABINDEX
a2336 1
    my($result,$checked);
d2338 1
a2339 1
    my(@@elements,@@values);
a2358 1

d2361 7
d2369 5
d2388 1
d2393 1
d2397 1
a2397 1
                   qq(<input type="$box_type" name="$name" value="$_" $checkit$other$tab$attribs/>$label)).${break};
d2399 1
a2399 1
           push(@@elements,qq/<input type="$box_type" name="$name" value="$_"$checkit$other$tab$attribs>${label}${break}/);
d2454 7
a2460 7
            my $attribs = $self->_set_attributes($_, $attributes);
	my($selectit) = defined($selected) ? $self->_selected($selected eq $_) : '';
	my($label) = $_;
	$label = $labels->{$_} if defined($labels) && defined($labels->{$_});
	my($value) = $self->escapeHTML($_);
	$label=$self->escapeHTML($label,1);
            $result .= "<option $selectit${attribs}value=\"$value\">$label</option>\n";
d2645 1
a2645 1
    my($align) = $alignment ? " align=\U\"$alignment\"" : '';
d2692 1
a2692 1
    my $request_uri = $self->request_uri || '';
d2700 1
a2700 1
    $uri            =~ s/$path$//      if defined $path;          # remove path
d2705 2
a2706 1
	my $vh = http('x_forwarded_host') || http('host');
a2710 4
	    my $port = $self->server_port;
	    $url .= ":" . $port
		unless (lc($protocol) eq 'http'  && $port == 80)
		    || (lc($protocol) eq 'https' && $port == 443);
d2712 4
d2719 1
a2719 1
	($url) = $script_name =~ m!([^/]+)$!;
d2747 2
a2748 2
    my($name,$value,$path,$domain,$secure,$expires) =
	rearrange([NAME,[VALUE,VALUES],PATH,DOMAIN,SECURE,EXPIRES],@@p);
d2776 1
a2821 3
	# hack to fix broken path info in IIS
	$self->{'.path_info'} =~ s/^\Q$ENV{'SCRIPT_NAME'}\E// if $IIS;

d2833 1
a2833 1
   my $uri             = $ENV{REQUEST_URI} || '';
d2835 2
a2836 3
   if ($raw_script_name =~ m/$raw_path_info$/) {
     $raw_script_name =~ s/$raw_path_info$//;
   }
d2844 1
a2844 4
   my $path_info_search = $raw_path_info;
   # these characters will not (necessarily) be escaped
   $path_info_search    =~ s/([^a-zA-Z0-9$()':_.,+*\/;?=&-])/uc sprintf("%%%02x",ord($1))/eg;
   $path_info_search    = quotemeta($path_info_search);
d3051 1
a3051 1
        $self->{'.script_name'} = shift;
d3371 1
a3371 1
	my($param)= $header{'Content-Disposition'}=~/ name="([^;]*)"/;
d3375 1
a3375 1
	my($filename) = $header{'Content-Disposition'}=~/ filename="([^;]*)"/;
d3441 103
a3543 1
	      print $filehandle $data;
d3570 1
d3574 1
d3578 1
a3578 1
    my @@param = grep(ref && fileno($_), $self->param($param_name));
d4296 4
a4299 1
it into a perl5 object called $query.  
d4760 1
a4760 1
those destined to be crunched by Malcom Beattie's Perl compiler.  Use
d5233 6
a5238 6
Netscape 3.0 recognizes several attributes of the <script> tag,
including LANGUAGE and SRC.  The latter is particularly interesting,
as it allows you to keep the JavaScript code in a file or CGI script
rather than cluttering up each page with the source.  To use these
attributes pass a HASH reference in the B<-script> parameter containing
one or more of -language, -src, or -code:
d5241 1
a5241 1
			 -script=>{-language=>'JAVASCRIPT',
d5246 1
a5246 1
	       -script=>{-language=>'PERLSCRIPT',
d5254 1
a5254 1
of JavaScript.  Example:     
d5258 1
a5258 1
                                    { -language => 'JavaScript1.0',
d5261 1
a5261 1
                                    { -language => 'JavaScript1.1',
d5264 1
a5264 1
                                    { -language => 'JavaScript1.2',
d5267 1
a5267 1
                                    { -language => 'JavaScript28.2',
d5273 2
a5274 7
If this looks a bit extreme, take my advice and stick with straight CGI scripting.  

See

   http://home.netscape.com/eng/mozilla/2.0/handbook/javascript/

for more information about JavaScript.
d6003 6
d6050 1
a6050 1
 $q = CGI->new(\&hook,$data);
d6058 9
d6070 1
a6070 1
  CGI::upload_hook(\&hook,$data);
d6212 1
a6212 1
indicates to suppress the val attribut in each option element within
d6310 1
d6363 5
a6367 6
Modern browsers can take advantage of the optional parameters
B<-rows>, and B<-columns>.  These parameters cause checkbox_group() to
return an HTML3 compatible table containing the checkbox group
formatted with the specified number of rows and columns.  You can
provide just the -columns parameter if you wish; checkbox_group will
calculate the correct number of rows for you.
d6369 2
d6522 1
a6522 1
can use the B<-rowheader> and B<-colheader> parameters.  Both
d6829 1
d6841 2
a6842 1
without the B<-value> parameter:
d6846 2
a6847 2
	$riddle = cookie('riddle_name');
        %answers = cookie('answers');
d6863 5
d6890 1
a6890 1
  http://home.netscape.com/assist/net_sites/frames.html
d6928 1
a6928 1
pity. JavaScript allows you to programatically change the contents of
d7149 2
a7150 4
print start_html (-STYLE  =>  {-verbatim => '@@import
url("/server-common/css/'.$cssFile.'");',
                      -src      =>  '/server-common/css/core.css'});
</blockquote></pre>
d7179 8
@


1.9
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.8 2004/04/07 21:33:04 millert Exp $';
$CGI::VERSION=3.05;
d80 3
a182 1
  eval "require mod_perl";
d185 10
a194 11
  if (defined $mod_perl::VERSION) {
    if ($mod_perl::VERSION >= 1.99) {
      $MOD_PERL = 2;
      require Apache::Response;
      require Apache::RequestRec;
      require Apache::RequestUtil;
      require APR::Pool;
    } else {
      $MOD_PERL = 1;
      require Apache;
    }
d237 2
a238 1
		':cgi'=>[qw/param upload path_info path_translated url self_url script_name cookie Dump
d253 27
d335 1
a335 1
	  UNIVERSAL::isa($initializer[0],'Apache::RequestRec')
a343 2
    $self->r(Apache->request) unless $self->r;
    my $r = $self->r;
d345 2
d352 2
d373 5
a377 3
  foreach my $href (values %{$self->{'.tmpfiles'}}) {
    $href->{hndl}->DESTROY if defined $href->{hndl};
    $href->{name}->DESTROY if defined $href->{name};
d389 7
a395 1
  my ($self,$hook,$data) = self_or_default(@@_);
d513 9
a521 10
	  my $max = $content_length;
	  while ($max > 0 &&
		 (my $bytes = $MOD_PERL
                  ? $self->r->read($buffer,$max < 10000 ? $max : 10000)
                  : read(STDIN,$buffer,$max < 10000 ? $max : 10000)
                 )) {
	    $self->cgi_error("413 Request entity too large");
	    last METHOD;
	  }
	}
d800 1
d819 1
d834 1
a834 1
  return $XHTML ? qq( selected="selected") : qq( selected);
d841 1
a841 1
  return $XHTML ? qq( checked="checked") : qq( checked);
d864 1
d896 15
d1151 1
a1151 1
    my($self,@@p) = @@_;
d1542 6
a1547 2
        $target,$meta,$head,$style,$dtd,$lang,$encoding,@@other) = 
	rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,META,HEAD,STYLE,DTD,LANG,ENCODING],@@p);
d1565 1
a1565 1
    push @@result,qq(<?xml version="1.0" encoding="$encoding"?>) if $xml_dtd; 
d1589 6
a1594 2
    push(@@result,$XHTML ? qq(<html xmlns="http://www.w3.org/1999/xhtml" lang="$lang" xml:lang="$lang"><head><title>$title</title>)
                        : ($lang ? qq(<html lang="$lang">) : "<html>") 
d1598 1
a1598 1
								: "<link rev=\"made\" href=\"mailto:$author\">");
d1617 1
d1627 1
a1627 1
    push(@@result,"</head><body$other>");
d1727 2
a1728 2
     $code = "$cdata_start$code$cdata_end" if defined $code;
     push(@@result,script({@@satts},$code || ''));
d1740 1
a1740 1
    return "</body></html>";
d1785 1
a1785 4
       $action = $self->escapeHTML($self->url(-absolute=>1,-path=>1));
       if (exists $ENV{QUERY_STRING} && length($ENV{QUERY_STRING})>0) {
           $action .= "?".$self->escapeHTML($ENV{QUERY_STRING},1);
       }
d1799 1
a1799 1
    &startform;
d1814 1
a1814 1
    if (defined($param[0]) && substr($param[0],0,1) eq '-') {
d1831 1
a1831 1
    my($self,@@p) = self_or_default(@@_);    
d1835 6
a1840 2
    return wantarray ? ("<div>",$self->get_fields,"</div>","</form>") : 
                        "<div>".$self->get_fields ."</div>\n</form>";
d1849 2
a1850 2
    my($name,$default,$size,$maxlength,$override,@@other) = 
	rearrange([NAME,[DEFAULT,VALUE,VALUES],SIZE,MAXLENGTH,[OVERRIDE,FORCE]],@@p);
d1863 2
a1864 1
    return $XHTML ? qq(<input type="$tag" name="$name" $value$s$m$other />) 
d1934 2
a1935 3
    
    my($name,$default,$rows,$cols,$override,@@other) =
	rearrange([NAME,[DEFAULT,VALUE],ROWS,[COLS,COLUMNS],[OVERRIDE,FORCE]],@@p);
d1945 2
a1946 1
    return qq{<textarea name="$name"$r$c$other>$current</textarea>};
d1965 2
a1966 2
    my($label,$value,$script,@@other) = rearrange([NAME,[VALUE,LABEL],
							 [ONCLICK,SCRIPT]],@@p);
d1979 2
a1980 1
    return $XHTML ? qq(<input type="button"$name$val$script$other />)
d1999 1
a1999 1
    my($label,$value,@@other) = rearrange([NAME,[VALUE,LABEL]],@@p);
d2004 2
a2005 2
    my $name = $NOSTICKY ? '' : ' name=".submit"';
    $name = qq/ name="$label"/ if defined($label);
d2008 5
a2012 4
    $val = qq/ value="$value"/ if defined($value);
    my($other) = @@other ? " @@other" : '';
    return $XHTML ? qq(<input type="submit"$name$val$other />)
                  : qq(<input type="submit"$name$val$other>);
d2027 1
a2027 1
    my($label,$value,@@other) = rearrange(['NAME',['VALUE','LABEL']],@@p);
d2036 2
a2037 1
    return $XHTML ? qq(<input type="reset"$name$val$other />)
d2058 1
a2058 1
    my($label,@@other) = rearrange([[NAME,VALUE]],@@p);
d2064 2
a2065 1
    return $XHTML ? qq(<input type="submit" name=".defaults"$value$other />)
d2097 3
a2099 3
    my($name,$checked,$value,$label,$override,@@other) = 
	rearrange([NAME,[CHECKED,SELECTED,ON],VALUE,LABEL,[OVERRIDE,FORCE]],@@p);
    
d2112 2
a2113 1
    my($other) = @@other ? " @@other" : '';
d2115 1
a2115 1
    return $XHTML ? qq{<input type="checkbox" name="$name" value="$value"$checked$other />$the_label}
a2120 71
#### Method: checkbox_group
# Create a list of logically-linked checkboxes.
# Parameters:
#   $name -> Common name for all the check boxes
#   $values -> A pointer to a regular array containing the
#             values for each checkbox in the group.
#   $defaults -> (optional)
#             1. If a pointer to a regular array of checkbox values,
#             then this will be used to decide which
#             checkboxes to turn on by default.
#             2. If a scalar, will be assumed to hold the
#             value of a single checkbox in the group to turn on. 
#   $linebreak -> (optional) Set to true to place linebreaks
#             between the buttons.
#   $labels -> (optional)
#             A pointer to an associative array of labels to print next to each checkbox
#             in the form $label{'value'}="Long explanatory label".
#             Otherwise the provided values are used as the labels.
# Returns:
#   An ARRAY containing a series of <input type="checkbox"> fields
####
'checkbox_group' => <<'END_OF_FUNC',
sub checkbox_group {
    my($self,@@p) = self_or_default(@@_);

    my($name,$values,$defaults,$linebreak,$labels,$attributes,$rows,$columns,
       $rowheaders,$colheaders,$override,$nolabels,@@other) =
	rearrange([NAME,[VALUES,VALUE],[DEFAULTS,DEFAULT],
            LINEBREAK,LABELS,ATTRIBUTES,ROWS,[COLUMNS,COLS],
			  ROWHEADERS,COLHEADERS,
			  [OVERRIDE,FORCE],NOLABELS],@@p);

    my($checked,$break,$result,$label);

    my(%checked) = $self->previous_or_default($name,$defaults,$override);

	if ($linebreak) {
    $break = $XHTML ? "<br />" : "<br>";
	}
	else {
	$break = '';
	}
    $name=$self->escapeHTML($name);

    # Create the elements
    my(@@elements,@@values);

    @@values = $self->_set_values_and_labels($values,\$labels,$name);

    my($other) = @@other ? " @@other" : '';
    foreach (@@values) {
	$checked = $self->_checked($checked{$_});
	$label = '';
	unless (defined($nolabels) && $nolabels) {
	    $label = $_;
	    $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
	    $label = $self->escapeHTML($label);
	}
        my $attribs = $self->_set_attributes($_, $attributes);
	$_ = $self->escapeHTML($_,1);
        push(@@elements,$XHTML ? qq(<input type="checkbox" name="$name" value="$_"$checked$other$attribs />${label}${break})
                              : qq/<input type="checkbox" name="$name" value="$_"$checked$other$attribs>${label}${break}/);
    }
    $self->register_parameter($name);
    return wantarray ? @@elements : join(' ',@@elements)
        unless defined($columns) || defined($rows);
    $rows = 1 if $rows && $rows < 1;
    $cols = 1 if $cols && $cols < 1;
    return _tableize($rows,$columns,$rowheaders,$colheaders,@@elements);
}
END_OF_FUNC
d2185 2
a2186 2
    $rowheaders = [] unless defined $rowheaders;
    $colheaders = [] unless defined $colheaders;
d2195 1
a2195 1
    
d2199 3
a2201 3
    unshift(@@$colheaders,'') if @@$colheaders && @@$rowheaders;
    $result .= "<tr>" if @@{$colheaders};
    foreach (@@{$colheaders}) {
d2206 1
a2206 1
	$result .= "<th>$rowheaders->[$row]</th>" if @@$rowheaders;
d2239 3
d2243 41
a2283 6
    my($name,$values,$default,$linebreak,$labels,$attributes,
       $rows,$columns,$rowheaders,$colheaders,$override,$nolabels,@@other) =
  rearrange([NAME,[VALUES,VALUE],DEFAULT,LINEBREAK,LABELS,ATTRIBUTES,
			  ROWS,[COLUMNS,COLS],
			  ROWHEADERS,COLHEADERS,
			  [OVERRIDE,FORCE],NOLABELS],@@p);
d2286 1
a2286 5
    if (!$override && defined($self->param($name))) {
	$checked = $self->param($name);
    } else {
	$checked = $default;
    }
d2289 1
d2292 2
a2293 1
    $checked = $values[0] unless defined($checked) && $checked ne '';
d2296 14
a2309 1
    my($other) = @@other ? " @@other" : '';
d2311 2
a2312 1
	my($checkit) = $checked eq $_ ? qq/ checked="checked"/ : '';
d2326 2
a2327 1
  my $attribs = $self->_set_attributes($_, $attributes);
d2329 7
a2335 2
  push(@@elements,$XHTML ? qq(<input type="radio" name="$name" value="$_"$checkit$other$attribs />${label}${break})
                              : qq/<input type="radio" name="$name" value="$_"$checkit$other$attribs>${label}${break}/);
d2338 1
a2338 1
    return wantarray ? @@elements : join(' ',@@elements) 
d2363 1
a2363 1
    my($name,$values,$default,$labels,$attributes,$override,@@other) =
d2365 1
a2365 1
       ATTRIBUTES,[OVERRIDE,FORCE]],@@p);
d2378 2
a2379 2

    $result = qq/<select name="$name"$other>\n/;
d2395 1
a2395 1
            $result .= "<option$selectit$attribs value=\"$value\">$label</option>\n";
d2488 1
a2488 1
    my($name,$values,$defaults,$size,$multiple,$labels,$attributes,$override,@@other)
d2490 1
a2490 1
          SIZE,MULTIPLE,LABELS,ATTRIBUTES,[OVERRIDE,FORCE]],@@p);
d2503 2
a2504 1
    $result = qq/<select name="$name"$has_size$is_multiple$other>\n/;
d2512 1
a2512 1
        $result .= "<option$selectit$attribs value=\"$value\">$label</option>\n";
d2619 3
a2621 3
    my ($relative,$absolute,$full,$path_info,$query,$base) = 
	rearrange(['RELATIVE','ABSOLUTE','FULL',['PATH','PATH_INFO'],['QUERY','QUERY_STRING'],'BASE'],@@p);
    my $url;
d2623 1
d2625 11
a2635 14
    my $path = $self->path_info;
    my $script_name = $self->script_name;

    # for compatibility with Apache's MultiViews
    if (exists($ENV{REQUEST_URI})) {
        my $index;
	$script_name = unescape($ENV{REQUEST_URI});
        $script_name =~ s/\?.+$//s;   # strip query string
        # and path
        if (exists($ENV{PATH_INFO})) {
           my $encoded_path = unescape($ENV{PATH_INFO});
           $script_name      =~ s/\Q$encoded_path\E$//i;
         }
    }
d2651 1
a2651 1
	$url .= $script_name;
d2655 1
a2655 1
	$url = $script_name;
d2658 2
a2659 3
    $url .= $path if $path_info and defined $path;
    $url .= "?" . $self->query_string if $query and $self->query_string;
    $url = '' unless defined $url;
d2753 2
a2754 3
	$self->{'.path_info'} = defined($ENV{'PATH_INFO'}) ? 
	    $ENV{'PATH_INFO'} : '';

d2763 31
d2824 10
d2989 8
a2996 4
    return $ENV{'SCRIPT_NAME'} if defined($ENV{'SCRIPT_NAME'});
    # These are for debugging
    return "/$0" unless $0=~/^\//;
    return $0;
d3038 1
d3040 1
a3040 1
        return ($vh =~ /:(\d+)$/)[0] || '80';
d3351 1
a3351 1
          my $seqno = unpack("%16C*",join('',localtime,values %ENV));
d3396 5
a3400 1
	  $self->{'.tmpfiles'}->{fileno($filehandle)}= {
d3423 2
a3424 2
    return $self->{'.tmpfiles'}->{fileno($filename)}->{name} ?
	$self->{'.tmpfiles'}->{fileno($filename)}->{name}->as_string
d3432 1
a3432 1
    return $self->{'.tmpfiles'}->{fileno($filename)}->{info};
d3493 5
a3543 7
'DESTROY'  => <<'END_OF_FUNC',
sub DESTROY {
    my $self = shift;
    close $self;
}
END_OF_FUNC

d3577 1
a3577 1
    
d3607 1
d3718 1
d3720 1
a3720 2
    die "Malformed multipart POST\n" unless ($start >= 0) || ($self->{LENGTH} > 0);

d3766 1
a3766 1
    return unless $self->{LENGTH};
d3771 1
a3771 1
    $bytesToRead = $self->{LENGTH} if $self->{LENGTH} < $bytesToRead;
d3785 1
a3785 1
    if ($bytesRead == 0) {
d3792 1
a3792 1
    $self->{LENGTH} -= $bytesRead;
a3815 1
  undef $TMPDIRECTORY;
d3819 1
a3819 1
  unless ($TMPDIRECTORY) {
d3939 6
a3944 3
       print "Your name is",em(param('name')),p,
	     "The keywords are: ",em(join(", ",param('words'))),p,
	     "Your favorite color is ",em(param('color')),
d4303 15
d4363 1
a4363 1
    $query->save(FILEHANDLE)
d4393 1
a4393 1
       $q->save(OUT);
d4400 1
a4400 1
       my $q = new CGI(IN);
d4616 16
a4631 5
This makes CGI.pm not generating the hidden fields .submit
and .cgifields. It is very useful if you don't want to
have the hidden fields appear in the querystring in a GET method.
For example, a search script generated this way will have
a very nice url with search parameters for bookmarking.
d4802 1
a4802 1
	print $query->header;
d4806 1
a4806 1
	print $query->header('image/gif');
d4810 1
a4810 1
	print $query->header('text/html','204 No response');
d4814 1
a4814 1
	print $query->header(-type=>'image/gif',
d4836 1
a4836 1
    print $query->header(-Content_length=>3002);
d4888 1
a4888 1
   print $query->redirect('http://somewhere.else/in/movie/land');
d4903 1
a4903 1
    print $query->redirect(-uri=>'http://somewhere.else/in/movie/land',
d4926 1
a4926 1
   print $query->start_html(-title=>'Secrets of the Pyramids',
d4992 7
d5042 1
a5042 1
      print $query->header;
d5059 1
a5059 1
      print $query->start_html(-title=>'The Riddle of the Sphinx',
d5143 1
a5143 1
	print $query->end_html
d5149 1
a5149 1
    $myself = $query->self_url;
d5158 1
a5158 1
     $myself = $query->self_url;
d5168 1
a5168 1
    $the_string = $query->query_string;
d5172 7
a5178 7
    $full_url      = $query->url();
    $full_url      = $query->url(-full=>1);  #alternative syntax
    $relative_url  = $query->url(-relative=>1);
    $absolute_url  = $query->url(-absolute=>1);
    $url_with_path = $query->url(-path_info=>1);
    $url_with_path_and_query = $query->url(-path_info=>1,-query=>1);
    $netloc        = $query->url(-base => 1);
d5224 10
d5238 1
a5238 1
   $color = $query->url_param('color');
a5265 1
   $q = new CGI;
d5496 1
a5496 1
   print $query->textfield(-name=>'field_name',
d5510 1
a5510 1
   $query->autoEscape(undef);
d5519 1
a5519 1
    printf("%s\n",$query->end_form())
d5529 1
a5529 1
   print $query->isindex(-action=>$action);
d5533 1
a5533 1
   print $query->isindex($action);
d5541 3
a5543 3
    print $query->start_form(-method=>$method,
			    -action=>$action,
			    -enctype=>$encoding);
d5545 1
a5545 1
    print $query->endform;
d5549 1
a5549 1
    print $query->start_form($method,$action,$encoding);
d5551 1
a5551 1
    print $query->endform;
d5592 3
d5616 50
d5668 4
a5671 4
    print $query->textfield(-name=>'field_name',
			    -default=>'starting value',
			    -size=>50,
			    -maxlength=>80);
d5674 1
a5674 1
    print $query->textfield('field_name','starting value',50,80);
d5676 1
a5676 1
textfield() will return a text input field.  
d5684 1
a5684 1
The first parameter is the required name for the field (-name).  
d5689 1
a5689 1
contents (-default).  
d5708 1
a5708 1
       $value = $query->param('foo');
d5713 1
a5713 20
       $query->param('foo',"I'm taking over this value!");

NEW AS OF VERSION 2.15: If you don't want the field to take on its previous
value, you can force its current value by using the -override (alias -force)
parameter:

    print $query->textfield(-name=>'field_name',
			    -default=>'starting value',
			    -override=>1,
			    -size=>50,
			    -maxlength=>80);

JAVASCRIPTING: You can also provide B<-onChange>, B<-onFocus>,
B<-onBlur>, B<-onMouseOver>, B<-onMouseOut> and B<-onSelect>
parameters to register JavaScript event handlers.  The onChange
handler will be called whenever the user changes the contents of the
text field.  You can do text validation if you like.  onFocus and
onBlur are called respectively when the insertion point moves into and
out of the text field.  onSelect is called when the user changes the
portion of the text that is selected.
d5717 1
a5717 1
   print $query->textarea(-name=>'foo',
d5724 1
a5724 1
   print $query->textarea('foo','starting value',10,50);
a5730 4
JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur> ,
B<-onMouseOver>, B<-onMouseOut>, and B<-onSelect> parameters are
recognized.  See textfield().

d5733 1
a5733 1
   print $query->password_field(-name=>'secret',
d5739 1
a5739 1
   print $query->password_field('secret','starting value',50,80);
a5743 4
JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur>,
B<-onMouseOver>, B<-onMouseOut> and B<-onSelect> parameters are
recognized.  See textfield().

d5746 1
a5746 1
    print $query->filefield(-name=>'uploaded_file',
d5752 1
a5752 1
    print $query->filefield('uploaded_file','starting value',50,80);
d5795 1
a5795 1
       $filename = $query->param('uploaded_file');
d5830 1
a5830 1
     $fh = $query->upload('uploaded_file');
d5848 2
a5849 2
       $filename = $query->param('uploaded_file');
       $type = $query->uploadInfo($filename)->{'Content-Type'};
d5867 3
a5869 3
   $file = $query->upload('uploaded_file');
   if (!$file && $query->cgi_error) {
      print $query->header(-status=>$query->cgi_error);
d5882 1
a5882 2
 $q = CGI->new();
 $q->upload_hook(\&hook,$data);
d5910 1
a5910 1
   print $query->popup_menu('menu_name',
d5920 1
a5920 1
   print $query->popup_menu('menu_name',
d5926 1
a5926 1
   print $query->popup_menu(-name=>'menu_name',
d5975 1
a5975 6
      $popup_menu_value = $query->param('menu_name');

JAVASCRIPTING: popup_menu() recognizes the following event handlers:
B<-onChange>, B<-onFocus>, B<-onMouseOver>, B<-onMouseOut>, and
B<-onBlur>.  See the textfield() section for details on when these
handlers are called.
d5981 1
a5981 1
  print $query->popup_menu(-name=>'menu_name',
d5983 3
a5985 3
                            $q->optgroup(-name=>'optgroup_name',
                                         -values ['moe','catch'],
                                         -attributes=>{'catch'=>{'class'=>'red'}}),
d5992 1
a5992 1
  print $query->popup_menu('menu_name',
d5994 2
a5995 2
                   $q->optgroup('optgroup_name', ['moe', 'catch'],
                         {'catch'=>{'class'=>'red'}})],'meenie',
d5998 1
a5998 1
optgroup creates an option group within a popup menu.
d6054 1
a6054 1
   print $query->scrolling_list('list_name',
d6059 1
a6059 1
   print $query->scrolling_list('list_name',
d6066 1
a6066 1
   print $query->scrolling_list(-name=>'list_name',
d6123 1
a6123 1
      @@selected = $query->param('list_name');
a6126 5
JAVASCRIPTING: scrolling_list() recognizes the following event
handlers: B<-onChange>, B<-onFocus>, B<-onMouseOver>, B<-onMouseOut>
and B<-onBlur>.  See textfield() for the description of when these
handlers are called.

d6129 1
a6129 1
   print $query->checkbox_group(-name=>'group_name',
d6136 1
a6136 1
   print $query->checkbox_group('group_name',
d6143 1
a6143 1
   print $query->checkbox_group(-name=>'group_name',
d6176 1
a6176 8
=item 4.

The optional fifth argument is a pointer to an associative array
relating the checkbox values to the user-visible labels that will
be printed next to them (-labels).  If not provided, the values will
be used as the default.

=item 5.
a6177 6
B<HTML3-compatible browsers> (such as Netscape) can take advantage of
the optional parameters B<-rows>, and B<-columns>.  These parameters
cause checkbox_group() to return an HTML3 compatible table containing
the checkbox group formatted with the specified number of rows and
columns.  You can provide just the -columns parameter if you wish;
checkbox_group will calculate the correct number of rows for you.
d6179 33
a6211 16
=item 6.

The optional sixth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
attribute's value as the value.

To include row and column headings in the returned table, you
can use the B<-rowheaders> and B<-colheaders> parameters.  Both
of these accept a pointer to an array of headings to use.
The headings are just decorative.  They don't reorganize the
interpretation of the checkboxes -- they're still a single named
unit.

=back
d6217 1
a6217 1
      @@turned_on = $query->param('group_name');
d6223 1
a6223 1
    @@h = $query->checkbox_group(-name=>'group_name',-values=>\@@values);
a6225 6
JAVASCRIPTING: checkbox_group() recognizes the B<-onClick>
parameter.  This specifies a JavaScript code fragment or
function call to be executed every time the user clicks on
any of the buttons in the group.  You can retrieve the identity
of the particular button clicked on using the "this" variable.

d6228 1
a6228 1
    print $query->checkbox(-name=>'checkbox_name',
d6235 1
a6235 1
    print $query->checkbox('checkbox_name','checked','ON','CLICK ME');
d6271 1
a6271 4
    $turned_on = $query->param('checkbox_name');

JAVASCRIPTING: checkbox() recognizes the B<-onClick>
parameter.  See checkbox_group() for further details.
d6275 1
a6275 1
   print $query->radio_group(-name=>'group_name',
d6284 1
a6284 1
   print $query->radio_group('group_name',['eenie','meenie','minie'],
d6290 1
a6290 1
   print $query->radio_group(-name=>'group_name',
d6332 1
a6332 1
=item 6.
a6333 8
B<HTML3-compatible browsers> (such as Netscape) can take advantage 
of the optional 
parameters B<-rows>, and B<-columns>.  These parameters cause
radio_group() to return an HTML3 compatible table containing
the radio group formatted with the specified number of rows
and columns.  You can provide just the -columns parameter if you
wish; radio_group will calculate the correct number of rows
for you.
d6335 6
a6340 7
=item 6.

The optional sixth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
attribute's value as the value.
d6349 20
a6368 1
=back
d6373 1
a6373 1
      $which_radio_button = $query->param('group_name');
d6379 1
a6379 1
    @@h = $query->radio_group(-name=>'group_name',-values=>\@@values);
d6384 1
a6384 1
   print $query->submit(-name=>'button_name',
d6389 1
a6389 1
   print $query->submit('button_name','value');
d6421 1
a6421 4
     $which_one = $query->param('button_name');

JAVASCRIPTING: radio_group() recognizes the B<-onClick>
parameter.  See checkbox_group() for further details.
d6425 1
a6425 1
   print $query->reset
d6436 1
a6436 1
   print $query->defaults('button_label')
d6444 1
a6444 1
	print $query->hidden(-name=>'hidden_name',
d6449 1
a6449 1
	print $query->hidden('hidden_name','value1','value2'...);
d6474 1
a6474 1
     $hidden_value = $query->param('hidden_name');
d6481 1
a6481 1
     $query->param('hidden_name','new','values','here');
d6485 1
a6485 1
     print $query->image_button(-name=>'button_name',
d6491 1
a6491 1
     print $query->image_button('button_name','/source/URL','MIDDLE');
a6497 3
JAVASCRIPTING: image_button() recognizes the B<-onClick>
parameter.  See checkbox_group() for further details.

d6518 2
a6519 2
     $x = $query->param('button_name.x');
     $y = $query->param('button_name.y');
d6523 1
a6523 1
     print $query->button(-name=>'button_name',
d6529 1
a6529 1
     print $query->button('button_name',"do_something()");
d6595 1
a6595 1
    $cookie = $query->cookie(-name=>'sessionID',
d6601 1
a6601 1
    print $query->header(-cookie=>$cookie);
d6620 1
a6620 1
	$cookie=$query->cookie(-name=>'family information',
d6650 1
a6650 1
	print $query->header(-cookie=>$my_cookie);
d6654 1
a6654 1
	$cookie1 = $query->cookie(-name=>'riddle_name',
d6656 1
a6656 1
	$cookie2 = $query->cookie(-name=>'answers',
d6658 1
a6658 1
	print $query->header(-cookie=>[$cookie1,$cookie2]);
d6665 2
a6666 2
	$riddle = $query->cookie('riddle_name');
        %answers = $query->cookie('answers');
d6678 1
a6678 1
   $c=$q->cookie(-name=>'answers',-value=>[$q->param('answers')]);
d6680 1
a6680 1
   $q->param(-name=>'answers',-value=>[$q->cookie('answers')]);
d6710 1
a6710 1
    print $q->header(-target=>'ResultsWindow');
d6724 1
a6724 1
    print $q->start_form(-target=>'ResultsWindow');
d6736 149
d6963 1
a6963 1
print $q->start_html (-STYLE  =>  {-verbatim => '@@import
d7042 1
a7042 1
    print $query->Dump
d7076 1
a7076 1
$query->Accept('text/html'), it will return a floating point value
d7104 1
a7104 1
like $query->user_agent(netscape);
d7110 1
a7110 1
$query->path_info() returning "/additional/stuff".
d7205 3
a7207 3
   $requested_language = $q->http('Accept-language');
   $requested_language = $q->http('Accept_language');
   $requested_language = $q->http('HTTP_ACCEPT_LANGUAGE');
d7268 1
a7268 1
      print $q->header(-nph=>1);
d7448 1
a7448 1
    CGI::ReadParse;
d7461 1
a7461 1
    print $q->textfield(-name=>'wow',
d7538 1
a7538 3
	use CGI;

	$query = new CGI;
d7540 2
a7541 2
	print $query->header;
	print $query->start_html("Example CGI.pm Form");
d7543 4
a7546 4
	&print_prompt($query);
	&do_work($query);
	&print_tail;
	print $query->end_html;
d7549 1
a7549 3
	   my($query) = @@_;

	   print $query->start_form;
d7551 2
a7552 2
	   print $query->textfield('name');
	   print $query->checkbox('Not my real name');
d7555 1
a7555 1
	   print $query->checkbox_group(
d7562 1
a7562 1
		$query->radio_group(
d7568 1
a7568 1
	   print $query->popup_menu(-name=>'Color',
d7572 1
a7572 1
	   print $query->hidden('Reference','Monty Python and the Holy Grail');
d7575 1
a7575 1
	   print $query->scrolling_list(
d7583 1
a7583 1
	   print $query->textarea(-name=>'Comments',
d7587 4
a7590 4
	   print "<p>",$query->reset;
	   print $query->submit('Action','Shout');
	   print $query->submit('Action','Scream');
	   print $query->endform;
a7594 1
	   my($query) = @@_;
d7599 1
a7599 1
	   foreach $key ($query->param) {
d7601 1
a7601 1
	      @@values = $query->param($key);
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.145 2003/12/10 15:16:08 lstein Exp $';
$CGI::VERSION=3.01;
a39 2
my @@SAVED_SYMBOLS;

d41 1
d113 1
d125 2
d186 1
d310 4
d611 1
a611 1
	undef %{$self};
d824 1
a824 1
    $CLOSE_UPLOAD_FILES++,   next if /^[:-]close_upload_files$/;
d910 1
a910 1
    return wantarray ? () : undef;
d1284 1
a1284 1
	-nph => 1,
d1444 3
a1446 1
    my($url,$target,$cookie,$nph,@@other) = rearrange([[LOCATION,URI,URL],TARGET,['COOKIE','COOKIES'],NPH],@@p);
d1451 1
a1451 1
	 '-Status'  => '302 Moved',
d1491 1
a1491 5
    # strangely enough, the title needs to be escaped as HTML
    # while the author needs to be escaped as a URL
    $title = $self->escapeHTML($title || 'Untitled Document');
    $author = $self->escape($author);
    $lang = 'en-US' unless defined $lang;
d1509 1
d1512 15
d1528 1
d1551 1
a1551 1
    push(@@result,$self->_style($style)) if defined $style;
d1579 16
a1594 13
    if (ref($style)) {
     my($src,$code,$verbatim,$stype,$foo,@@other) =
         rearrange([SRC,CODE,VERBATIM,TYPE],
                    '-foo'=>'bar',    # trick to allow dash to be omitted
                    ref($style) eq 'ARRAY' ? @@$style : %$style);
     $type  = $stype if $stype;
     my $other = @@other ? join ' ',@@other : '';

     if (ref($src) eq "ARRAY") # Check to see if the $src variable is an array reference
     { # If it is, push a LINK tag for each one
         foreach $src (@@$src)
       {
         push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
d1596 1
d1598 17
a1614 6
     }
     else
     { # Otherwise, push the single -src, if it exists.
       push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
                           : qq(<link rel="stylesheet" type="$type" href="$src"$other>)
            ) if $src;
a1615 8
   if ($verbatim) {
         push(@@result, "<style type=\"text/css\">\n$verbatim\n</style>");
    }
      push(@@result,style({'type'=>$type},"$cdata_start\n$code\n$cdata_end")) if $code;
    } else {
         my $src = $style;
         push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
                             : qq(<link rel="stylesheet" type="$type" href="$src"$other>));
d1714 6
a1719 4
    $method = lc($method) || 'post';
    $enctype = $enctype || &URL_ENCODED;
    unless (defined $action) {

d1721 1
a1721 1
       if (length($ENV{QUERY_STRING})>0) {
a1779 9
#### Method: end_form
# synonym for endform
'end_form' => <<'END_OF_FUNC',
sub end_form {
    &endform;
}
END_OF_FUNC


d1936 1
a1936 1
    my($name) = ' name=".submit"' unless $NOSTICKY;
d2113 1
a2113 1
    return wantarray ? @@elements : join(' ',@@elements)            
d2132 9
a2140 1
         $toencode =~ s{"}{&quot;}gso;
d2159 2
d2499 2
a2500 2
	push @@result,$XHTML ? qq(<input type="hidden" name="$name" value="$_" />)
                            : qq(<input type="hidden" name="$name" value="$_">);
d2573 1
a2573 1
        $script_name =~ s/\?.+$//;   # strip query string
d2576 2
a2577 2
           my $encoded_path = quotemeta($ENV{PATH_INFO});
           $script_name      =~ s/$encoded_path$//i;
d2584 1
a2584 1
	my $vh = http('host');
d2856 1
a2856 1
    my $vh = http('host') || server_name();
d2938 1
a2938 1
    my $vh = $self->http('host');
d3211 1
a3211 1
	my($param)= $header{'Content-Disposition'}=~/ name="?([^\";]*)"?/;
d3215 1
a3215 1
	my($filename) = $header{'Content-Disposition'}=~/ filename="?([^\"]*)"?/;
d3352 2
a3353 2
        $attrib =~ s/^-//;
        $attribs .= "@@{[lc($attrib)]}=\"$attributes->{$element}{$attrib}\" ";
d4513 4
d4773 2
a4774 1
			   -nph=>1);
d4781 12
d4849 1
a4849 2
the <html> tag.  The default if not specified is "en-US" for US
English.  For example:
d4853 4
a4856 2
To leave off the lang attribute, as you must do if you want to generate
legal HTML 3.2 or earlier, pass the empty string (-lang=>'').
d5365 15
d5662 1
a5662 1
In an array context, upload() will return an array of filehandles.
d6235 1
a6235 3
to distinguish between them.  The name will also be used as the
user-visible label.  Be aware that a few older browsers don't deal with this correctly and
B<never> send back a value from a button.
d6240 8
a6247 1
a value that will be passed to your script in the query string.
d6646 2
a6647 2
Pass an array reference to B<-style> in order to incorporate multiple
stylesheets into your document.
d7138 1
a7138 1
    CGI::ReadParse
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.130 2003/08/01 14:39:17 lstein Exp $ + patches by merlyn';
$CGI::VERSION='3.00';
d27 1
a27 1
use CGI::Util qw(rearrange make_attributes unescape escape expires);
d213 3
a215 3
    $CGI::DefaultClass->binmode(main::STDOUT);
    $CGI::DefaultClass->binmode(main::STDIN);
    $CGI::DefaultClass->binmode(main::STDERR);
d235 2
a236 2
			 remote_addr referer server_name server_software server_port server_protocol
			 virtual_host remote_ident auth_type http
d298 1
d326 14
a339 3
# We provide a DESTROY method so that the autoloader
# doesn't bother trying to find it.
sub DESTROY { }
d348 6
d468 7
a474 2
	  while ($max > 0 && (my $bytes = read(STDIN,$buffer,$max < 10000 ? $max : 10000))) {
	    $max -= $bytes;
d476 1
a476 3
	  $self->cgi_error("413 Request entity too large");
	  last METHOD;
      }
d519 15
d554 1
a554 1
	  $self->read_from_client(\*STDIN,\$query_string,$content_length,0)
d567 9
a575 1
      $query_string = read_from_cmdline() if $DEBUG;
d702 1
d871 2
a872 2
    my($self,$boundary,$length,$filehandle) = @@_;
    return MultipartBuffer->new($self,$boundary,$length,$filehandle);
d879 1
a879 1
    my($self, $fh, $buff, $len, $offset) = @@_;
d881 3
a883 2
    return undef unless defined($fh);
    return read($fh, $$buff, $len, $offset);
d1349 1
a1349 1
    return undef if $self->{'.header_printed'}++ and $HEADERS_ONCE;
d1579 1
a1579 1
      if ($verbatim) {
d1688 1
d2559 1
a2559 1
		unless (lc($protocol) eq 'http' && $port == 80)
d2900 15
d3127 1
d3132 1
a3132 1
	print STDERR "(offline mode: enter name=value pairs on standard input)\n";
d3147 6
a3152 1
    return $query_string;
d3166 2
a3167 2
    my($self,$boundary,$length,$filehandle) = @@_;
    my($buffer) = $self->new_MultipartBuffer($boundary,$length,$filehandle);
d3227 2
a3228 1
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode;
d3231 1
a3231 1
	  # together with the body for lateron parsing with an external
d3242 7
a3248 1
	  while (defined($data = $buffer->read)) {
d3250 1
a3250 1
	  }
d3265 1
d3416 2
d3440 1
a3440 1
    my($package,$interface,$boundary,$length,$filehandle) = @@_;
d3442 1
a3442 9
    my $IN;
    if ($filehandle) {
	my($package) = caller;
	# force into caller's package if necessary
	$IN = $filehandle=~/[':]/ ? $filehandle : "$package\:\:$filehandle"; 
    }
    $IN = "main::STDIN" unless $IN;

    $CGI::DefaultClass->binmode($IN) if $CGI::needs_binmode;
d3465 1
a3465 1
	$boundary = <$IN>;      # BUG: This won't work correctly under mod_perl
a3473 1
		IN=>$IN,
d3487 1
a3487 1
    die "Malformed multipart POST\n" if $self->eof;
d3500 1
a3500 1
    local($CRLF) = "\015\012" if $CGI::OS eq 'VMS';
d3512 2
d3518 6
d3546 3
d3552 6
d3570 1
a3570 1
    $bytes = $bytes || $FILLUNIT;       
d3576 3
d3580 3
a3582 1
    my $start = index($self->{BUFFER},$self->{BOUNDARY});
d3586 3
d3594 1
a3594 1
	if (index($self->{BUFFER},"$self->{BOUNDARY}--")==0) {
d3601 1
a3601 1
	substr($self->{BUFFER},0,length($self->{BOUNDARY}))='';
d3613 1
a3613 1
	$bytesToReturn = $bytes - (length($self->{BOUNDARY})+1);
d3638 2
a3639 3
    # Try to read some data.  We may hang here if the browser is screwed up.  
    my $bytesRead = $self->{INTERFACE}->read_from_client($self->{IN},
							 \$self->{BUFFER},
d3642 1
d4731 2
a4732 5
One hint I can offer is that relative links may not work correctly
when you generate a redirection to another document on your site.
This is due to a well-intentioned optimization that some servers use.
The solution to this is to use the full URL (including the http: part)
of the document you are redirecting to.
d5638 23
d6510 2
a6511 2
parameter may be a scalar, in which case it is incorporated directly
into a <style> section, or it may be a hash reference.  In the latter
d6651 5
d6783 5
@


1.6
log
@Update CGI module to version 2.98; fixes a cross-site scripting bug
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.127 2003/06/18 19:57:21 lstein Exp $';
$CGI::VERSION='2.98';
d1642 1
a1642 1
       $action = $self->url(-absolute=>1,-path=>1);
d1644 1
a1644 1
           $action .= "?$ENV{QUERY_STRING}";
a1646 1
    $action =~ s/\"/%22/g;  # fix cross-site scripting bug reported by obscure
d3586 6
a3591 4
$SL = $CGI::SL;
$MAC = $CGI::OS eq 'MACINTOSH';
my ($vol) = $MAC ? MacPerl::Volumes() =~ /:(.*)/ : "";
unless ($TMPDIRECTORY) {
d3609 1
a3609 1
	do {$TMPDIRECTORY = $_; last} if -d $_ && -w _;
d3611 2
d3615 2
a3616 1
$TMPDIRECTORY  = $MAC ? "" : "." unless $TMPDIRECTORY;
d3641 1
d4949 1
a4949 1
   $color = $query-&gt;url_param('color');
d5703 2
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.62 2002/04/10 19:36:01 lstein Exp $';
$CGI::VERSION='2.81';
d35 9
d81 10
d149 2
d156 1
a156 1
$needs_binmode = $OS=~/^(WINDOWS|DOS|OS2|MSWin)/;
d167 2
a168 2
       UNIX=>'/', OS2=>'\\', EPOC=>'/',
       WINDOWS=>'\\', DOS=>'\\', MACINTOSH=>':', VMS=>'/'
d177 15
a191 6
if (exists $ENV{'GATEWAY_INTERFACE'} 
    && 
    ($MOD_PERL = $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-Perl\//))
{
    $| = 1;
    require Apache;
d193 1
d224 1
a224 1
			   embed basefont style span layer ilayer font frameset frame script small big/],
a240 1
		':imagemap' => [qw/Area Map/],
d252 1
a252 1
# This causes modules to clash.  
d296 27
a322 10
    my($class,$initializer) = @@_;
    my $self = {};
    bless $self,ref $class || $class || $DefaultClass;
    if ($MOD_PERL && defined Apache->request) {
      Apache->request->register_cleanup(\&CGI::_reset_globals);
      undef $NPH;
    }
    $self->_reset_globals if $PERLEX;
    $self->init($initializer);
    return $self;
d329 7
d414 8
a421 3
    my($self,$initializer) = @@_;
    my($query_string,$meth,$content_length,$fh,@@lines) = ('','','','');
    local($/) = "\n";
d447 6
d509 1
a509 1
	      $query_string = Apache->request->args;
d534 12
d573 1
a573 1
    $self->save_request unless $initializer;
d665 8
a672 9
            shift if \$_[0] && 
                    (ref(\$_[0]) &&
                     (substr(ref(\$_[0]),0,3) eq 'CGI' ||
                    UNIVERSAL::isa(\$_[0],'CGI')));
	    my(\$attr) = '';
	    if (ref(\$_[0]) && ref(\$_[0]) eq 'HASH') {
		my(\@@attr) = make_attributes(shift()||undef,1);
		\$attr = " \@@attr" if \@@attr;
	    }
d680 1
a680 1
	    return \$XHTML ? "\L<$tagname\E\$attr />" : "\L<$tagname\E\$attr>" unless \@@_;
d683 1
a683 1
                              (ref(\$_[0]) eq 'ARRAY') ? \@@{\$_[0]} : "\@@_";
d772 1
d794 1
d847 10
a856 4
    my($name) = rearrange([NAME],@@p);
    CORE::delete $self->{$name};
    CORE::delete $self->{'.fieldnames'}->{$name};
    @@{$self->{'.parameters'}}=grep($_ ne $name,$self->param());
d977 7
a983 3
sub TIEHASH { 
    return $_[1] if defined $_[1];
    return $Q ||= new shift;
d1059 2
a1060 1
    undef %{$self};
d1084 3
a1086 1
    $self->{'dontescape'}=!$escape;
d1144 1
a1144 1
	push(@@result,"<li><strong>$param</strong>");
d1148 2
a1149 2
            $value =~ s/\n/<br>\n/g;
	    push(@@result,"<li>$value");
d1256 2
a1257 1
        next unless my($header,$value) = /([^\s=]+)=\"?(.+?)\"?$/;
d1305 1
a1305 1
    my($type,$status,$cookie,$target,$expires,$nph,$charset,$attachment,@@other) = 
d1309 1
a1309 1
                            'ATTACHMENT'],@@p);
d1321 3
a1323 3
        next unless my($header,$value) = /([^\s=]+)=\"?(.+?)\"?$/;
	($_ = $header) =~ s/^(\w)(.*)/$1 . lc ($2) . ': '.$self->unescapeHTML($value)/e;
        $header = ucfirst($header);
d1327 1
a1327 1
    $type .= "; charset=$charset" if $type ne '' and $type =~ m!^text/! and $type !~ /\bcharset\b/;
d1336 4
a1357 1

d1360 2
a1361 3
	my $r = Apache->request;
	$r->send_cgi_header($header);
	return '';
d1391 1
a1391 1
    my($url,$target,$cookie,$nph,@@other) = rearrange([[LOCATION,URI,URL],TARGET,COOKIE,NPH],@@p);
d1396 3
a1398 3
	 '-Status'=>'302 Moved',
	 '-Location'=>$url,
	 '-nph'=>$nph);
a1399 1
    unshift(@@o,'-Cookie'=>$cookie) if $cookie;
d1401 3
a1403 1
    return $self->header(@@o);
d1440 1
a1440 1
    $lang ||= 'en-US';
d1461 3
a1463 2
    push(@@result,$XHTML ? qq(<html xmlns="http://www.w3.org/1999/xhtml" lang="$lang"><head><title>$title</title>)
                        : qq(<html lang="$lang"><head><title>$title</title>));
d1512 3
a1514 3
     my($src,$code,$stype,@@other) =
         rearrange([SRC,CODE,TYPE],
                    '-foo'=>'bar', # a trick to allow the '-' to be omitted
d1516 3
a1518 1
     $type = $stype if $stype;
d1520 2
a1521 2
     { # If it is, push a LINK tag for each one.
       foreach $src (@@$src)
d1523 2
a1524 2
         push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" />)
                             : qq(<link rel="stylesheet" type="$type" href="$src">)) if $src;
d1529 2
a1530 2
       push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" />)
                           : qq(<link rel="stylesheet" type="$type" href="$src">)
d1533 4
a1536 1
     push(@@result,style({'type'=>$type},"$cdata_start\n$code\n$cdata_end")) if $code;
d1538 3
a1540 1
     push(@@result,style({'type'=>$type},"$cdata_start\n$style\n$cdata_end"));
d1574 15
a1588 11
    my $cdata_start  =  "\n<!-- Hide script\n";
    $cdata_start    .= "$comment<![CDATA[\n"  if $XHTML; 
    my $cdata_end    = $XHTML ? "\n$comment]]>" : $comment;
    $cdata_end      .= " End script hiding -->\n";

	my(@@satts);
	push(@@satts,'src'=>$src) if $src;
	push(@@satts,'language'=>$language);
        push(@@satts,'type'=>$type);
	$code = "$cdata_start$code$cdata_end" if defined $code;
	push(@@result,script({@@satts},$code || ''));
d1614 1
a1614 1
#   A string containing a <ISINDEX> tag
d1619 1
a1619 1
    $action = qq/action="$action"/ if $action;
d1621 1
a1621 1
    return $XHTML ? "<isindex $action$other />" : "<isindex $action$other>";
d1643 3
a1645 1
       $action .= "?$ENV{QUERY_STRING}" if $ENV{QUERY_STRING};
d1647 1
d1696 2
a1697 2
    return wantarray ? ($self->get_fields,"</form>") : 
                        $self->get_fields ."\n</form>";
d1716 1
a1716 1
	rearrange([NAME,[DEFAULT,VALUE],SIZE,MAXLENGTH,[OVERRIDE,FORCE]],@@p);
d1742 1
a1742 1
#   A string containing a <INPUT TYPE="text"> field
d1758 1
a1758 1
#   A string containing a <INPUT TYPE="text"> field
d1777 1
a1777 1
#   A string containing a <INPUT TYPE="password"> field
d1824 1
a1824 1
#   A string containing a <INPUT TYPE="button"> tag
d1857 1
a1857 1
#   A string containing a <INPUT TYPE="submit"> tag
d1871 1
a1871 1
    my($val) = '';
d1885 1
a1885 1
#   A string containing a <INPUT TYPE="reset"> tag
d1890 1
a1890 1
    my($label,@@other) = rearrange([NAME],@@p);
d1892 6
a1897 1
    my($value) = defined($label) ? qq/ value="$label"/ : '';
d1899 2
a1900 2
    return $XHTML ? qq(<input type="reset"$value$other />)
                  : qq(<input type="reset"$value$other>);
d1910 1
a1910 1
#   A string containing a <INPUT TYPE="submit" NAME=".defaults"> tag
d1952 1
a1952 1
#   A string containing a <INPUT TYPE="checkbox"> field
d2000 1
a2000 1
#   An ARRAY containing a series of <INPUT TYPE="checkbox"> fields
d2006 1
a2006 1
    my($name,$values,$defaults,$linebreak,$labels,$rows,$columns,
d2009 1
a2009 1
			  LINEBREAK,LABELS,ROWS,[COLUMNS,COLS],
d2039 1
d2041 2
a2042 2
	push(@@elements,$XHTML ? qq(<input type="checkbox" name="$name" value="$_"$checked$other />${label}${break})
                              : qq/<input type="checkbox" name="$name" value="$_"$checked$other>${label}${break}/);
d2047 2
d2060 1
a2060 1
         return $toencode if ref($self) && $self->{'dontescape'};
d2069 2
a2070 2
                $toencode =~ s{\x8b}{&#139;}gso;
                $toencode =~ s{\x9b}{&#155;}gso;
d2155 1
a2155 1
#   An ARRAY containing a series of <INPUT TYPE="radio"> fields
d2161 1
a2161 1
    my($name,$values,$default,$linebreak,$labels,
d2163 1
a2163 1
	rearrange([NAME,[VALUES,VALUE],DEFAULT,LINEBREAK,LABELS,
d2197 1
d2199 2
a2200 2
	push(@@elements,$XHTML ? qq(<input type="radio" name="$name" value="$_"$checkit$other />${label}${break})
                              : qq/<input type="radio" name="$name" value="$_"$checkit$other>${label}${break}/);
d2228 3
a2230 2
    my($name,$values,$default,$labels,$override,@@other) =
	rearrange([NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LABELS,[OVERRIDE,FORCE]],@@p);
d2246 9
d2260 2
a2261 1
	$result .= "<option$selectit value=\"$value\">$label</option>\n";
d2270 60
d2353 1
a2353 1
    my($name,$values,$defaults,$size,$multiple,$labels,$override,@@other)
d2355 1
a2355 1
			    SIZE,MULTIPLE,LABELS,[OVERRIDE,FORCE]],@@p);
d2375 2
a2376 1
	$result .= "<option$selectit value=\"$value\">$label</option>\n";
d2392 1
a2392 1
#   A string containing a <INPUT TYPE="hidden" NAME="name" VALUE="value">
d2435 1
a2435 1
#   A string containing a <INPUT TYPE="image" NAME="name" SRC="url" ALIGN="alignment">
d2494 1
a2494 1
	$script_name = $ENV{REQUEST_URI};
d2498 1
a2498 1
           (my $encoded_path = $ENV{PATH_INFO}) =~ s/([^a-zA-Z0-9_.%;&?\/\\:+=~-])/sprintf("%%%02X",ord($1))/eg;
d2999 11
d3113 1
d3117 4
d3127 1
a3127 1
	if ( !defined($filename) || $filename eq '' ) {
d3129 1
d3146 5
d3162 10
d3180 6
d3237 16
d3291 1
a3291 1
    return $i;
d3314 1
d3319 4
a3322 2
    sysopen($ref,$file,Fcntl::O_RDWR()|Fcntl::O_CREAT()|Fcntl::O_EXCL(),0600) || return;
    unlink($file) if $delete;
a3447 1
    
d3454 1
d3456 1
a3456 1
	my ($field_name,$field_value) = ($1,$2); # avoid taintedness
d3513 1
a3513 1
    my $bytesToReturn;    
d3515 1
a3515 1
	$bytesToReturn = $start > $bytes ? $bytes : $start;
d3527 1
a3527 1
    return (($start > 0) && ($start <= $bytes)) 
d3596 1
a3596 1
    unshift(@@TEMP,$ENV{'TMPDIR'}) if exists $ENV{'TMPDIR'};
d3621 3
a3623 1
    unlink $$self;              # get rid of the file
d3640 4
a3643 3
    # untaint the darn thing
    return unless $filename =~ m!^([a-zA-Z0-9_ '":/.\$\\-]+)$!;
    $filename = $1;
d3828 2
a3829 2
   h1({-align=>left});            <h1 ALIGN="LEFT">
   h1({-align=>left},'contents'); <h1 ALIGN="LEFT">contents</h1>
d3831 1
a3831 1
HTML tags are described in more detail later.  
d3995 5
d4038 6
a4043 1
In older versions, this method was called B<import()>.  As of version 2.20, 
d4049 1
a4049 1
    $query->delete('foo');
d4051 3
a4053 3
This completely clears a parameter.  It sometimes useful for
resetting parameters that you don't want passed down between
script invocations.
d4354 8
a4361 1
compile() method instead (see below).
d4596 1
a4596 1
headers to work with an NPH (no-parse-header) script.  This is important
d4609 11
d4644 2
a4645 2
headers to work with an NPH (no-parse-header) script.  This is important
to use with certain servers, such as Microsoft Internet Explorer, which
d4709 3
d4875 3
a4877 3
     print "<a href=$myself#table1>See table 1</a>";
     print "<a href=$myself#table2>See table 2</a>";
     print "<a href=$myself#yourself>See for yourself</a>";
d5032 1
a5032 1
lists can be marked as COMPACT.  The syntax for this is an argument
d5039 1
a5039 1
changed in order to accommodate those who want to create tags of the form
d5042 3
a5044 3
     CODE                   RESULT
     img({alt=>undef})      <img alt>
     img({alt=>''})         <img alt="">
d5148 1
a5148 1
0x8b and 0x9b characters, which many windows-based browsers interpret
d5150 1
a5150 1
numeric HTML entities ("&#139" and "&#155;").  If you manually change
d5160 1
a5160 1
To turn autoescaping off completely, use autoescape():
d5563 1
d5566 1
a5566 1
			    'meenie',\%labels);
d5573 2
a5574 1
			    -labels=>\%labels);
d5601 1
a5601 1
popup menu nd the value returned to your script.  It's a pointer to an
d5606 8
d5626 73
d5703 1
a5703 1
				['eenie','moe'],5,'true');
d5709 1
a5709 1
				\%labels);
d5718 2
a5719 1
				-labels=>\%labels);
d5758 8
d5785 2
a5786 1
				-labels=>\%labels);
d5790 2
a5791 1
				['eenie','moe'],'true',\%labels);
d5844 8
d5936 2
a5937 1
			     -labels=>\%labels);
d5942 1
a5942 1
					  'meenie','true',\%labels);
d6000 8
a6159 1

d6458 37
a6629 1

d7110 1
a7110 7
This module has grown large and monolithic.  Furthermore it's doing many
things, such as handling URLs, parsing CGI input, writing HTML, etc., that
are also done in the LWP modules. It should be discarded in favor of
the CGI::* modules, but somehow I continue to work on it.

Note that the code is truly contorted in order to avoid spurious
warnings when programs are run with the B<-w> switch.
@


1.5.2.1
log
@Fix by brad@@

fixes a cross-site scripting bug

http://marc.theaimsgroup.com/?l=bugtraq&m=105880349328877&w=2

ok deraadt@@ millert@@
@
text
@d21 1
a21 1
$CGI::revision = '$Id: CGI.pm,v 1.5 2002/10/27 22:25:25 millert Exp $';
d1536 1
a1536 3
       if (length($ENV{QUERY_STRING})>0) {
           $action .= "?$ENV{QUERY_STRING}";
       }
a1537 1
    $action =~ s/\"/%22/g;  # fix cross-site scripting bug reported by obscure
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.49 2001/02/04 23:08:39 lstein Exp $';
$CGI::VERSION='2.752';
d26 1
a26 1
# $TempFile::TMPDIRECTORY = '/usr/tmp';
d29 5
a33 2
use constant XHTML_DTD => ['-//W3C//DTD XHTML Basic 1.0//EN',
                           'http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd'];
d39 1
a39 1
    
d88 4
d146 2
a147 2
    UNIX=>'/', OS2=>'\\', EPOC=>'/', 
    WINDOWS=>'\\', DOS=>'\\', MACINTOSH=>':', VMS=>'/'
d194 3
d212 2
a213 2
		':html' => [qw/:html2 :html3 :netscape/],
		':standard' => [qw/:html2 :html3 :form :cgi/],
d215 1
a215 1
		':all' => [qw/:html2 :html3 :netscape :form :cgi :internal/]
d223 2
a224 2
#    undef %EXPORT_OK;
#    undef %EXPORT;
d555 2
d662 14
d681 4
d698 1
d1049 2
a1050 2
    return '<UL></UL>' unless $self->param;
    push(@@result,"<UL>");
d1053 2
a1054 2
	push(@@result,"<LI><STRONG>$param</STRONG>");
	push(@@result,"<UL>");
d1057 2
a1058 2
            $value =~ s/\n/<BR>\n/g;
	    push(@@result,"<LI>$value");
d1060 1
a1060 1
	push(@@result,"</UL>");
d1062 1
a1062 1
    push(@@result,"</UL>\n");
d1231 1
d1260 1
a1260 1
    push(@@header,@@other);
d1326 1
a1326 1
# $head -> (optional) any other elements you'd like to incorporate into the <HEAD> tag
d1330 1
a1330 1
#           the <BODY> tag.
d1335 5
a1339 2
    my($title,$author,$base,$xbase,$script,$noscript,$target,$meta,$head,$style,$dtd,$lang,@@other) = 
	rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,META,HEAD,STYLE,DTD,LANG],@@p);
d1359 1
a1359 1
    push @@result,q(<?xml version="1.0" encoding="utf-8"?>) if $xml_dtd; 
d1362 1
a1362 1
        push(@@result,qq(<!DOCTYPE html\n\tPUBLIC "$dtd->[0]"\n\t"$dtd->[1]">));
d1426 1
a1426 1
                             : qq(<link rel="stylesheet" type="$type" href="$src">/)) if $src;
d1489 1
a1489 1
# Trivial method for completeness.  Just returns "</BODY>"
d1620 1
a1620 1
                  : qq/<input type="$tag" name="$name" $value$s$m$other>/;
d1684 1
a1684 1
#   A string containing a <TEXTAREA></TEXTAREA> tag
d1698 2
a1699 2
    my($r) = $rows ? " rows=$rows" : '';
    my($c) = $cols ? " cols=$cols" : '';
d1735 1
a1735 1
                  : qq/<input type="button"$name$val$script$other>/;
d1765 1
a1765 1
                  : qq/<input type="submit"$name$val$other>/;
d1785 1
a1785 1
                  : qq/<input type="reset"$value$other>/;
d1850 1
a1850 1
	$checked = grep($_ eq $value,$self->param($name)) ? ' checked' : '';
d1852 1
a1852 1
	$checked = $checked ? qq/ checked/ : '';
d1917 1
a1917 1
	$checked = $checked{$_} ? qq/ checked/ : '';
d1938 2
d2065 1
a2065 1
	my($checkit) = $checked eq $_ ? qq/ checked/ : '';
d2126 1
a2126 1
	my($selectit) = defined($selected) ? ($selected eq $_ ? qq/selected/ : '' ) : '';
d2131 1
a2131 1
	$result .= "<option $selectit value=\"$value\">$label</option>\n";
d2134 1
a2134 1
    $result .= "</select>\n";
d2173 1
a2173 1
    my($is_multiple) = $multiple ? qq/ multiple/ : '';
d2180 1
a2180 1
	my($selectit) = $selected{$_} ? qq/selected/ : '';
d2185 1
a2185 1
	$result .= "<option $selectit value=\"$value\">$label</option>\n";
d2187 1
a2187 1
    $result .= "</select>\n";
d2253 1
a2253 1
    my($align) = $alignment ? " align=\U$alignment" : '';
d2295 1
a2295 1
    $full++ if $base || !($relative || $absolute);
d2300 11
a2310 14
# If anybody knows why I ever wrote this please tell me!
#    if (exists($ENV{REQUEST_URI})) {
#        my $index;
#	$script_name = $ENV{REQUEST_URI};
#        # strip query string
#        substr($script_name,$index) = '' if ($index = index($script_name,'?')) >= 0;
#        # and path
#        if (exists($ENV{PATH_INFO})) {
#           (my $encoded_path = $ENV{PATH_INFO}) =~ s!([^a-zA-Z0-9_./-])!uc sprintf("%%%02x",ord($1))!eg;;
#           substr($script_name,$index) = '' if ($index = rindex($script_name,$encoded_path)) >= 0;
#         }
#    } else {
#	$script_name = $self->script_name;
#    }
d2336 1
a2336 1
    $url =~ s/([^a-zA-Z0-9_.%;&?\/\\:+=~-])/uc sprintf("%%%02x",ord($1))/eg;
d2941 1
a2941 1
	    next unless $tmpfile = new TempFile($seqno);
d2946 1
a2946 1
          die "CGI open of tmpfile: $!\n" unless $filehandle;
d2974 3
a2976 4
    my $param = $self->param($param_name);
    return unless $param;
    return unless ref($param) && fileno($param);
    return $param;
d3143 1
a3143 1
	$boundary = "--$boundary" unless CGI::user_agent('MSIE\s+3\.0[12];\s*Mac');
d3279 2
a3280 1
    return ($start > 0) ? substr($returnval,0,-2) : $returnval;
d3337 1
a3337 1
package TempFile;
d3369 6
a3374 1
*TempFile::AUTOLOAD = \&CGI::AUTOLOAD;
a3396 7
'DESTROY' => <<'END_OF_FUNC',
sub DESTROY {
    my($self) = @@_;
    unlink $$self;              # get rid of the file
}
END_OF_FUNC

d3575 4
a3578 4
   h1()                           <H1>
   h1('some','contents');         <H1>some contents</H1>
   h1({-align=>left});            <H1 ALIGN="LEFT">
   h1({-align=>left},'contents'); <H1 ALIGN="LEFT">contents</H1>
d3967 1
a3967 1
Import all methods that generate HTML 3.0 proposed elements (such as
d3970 5
d3986 1
a3986 1
Import "standard" features, 'html2', 'html3', 'form' and 'cgi'.
d3999 1
a3999 1
Microsoft comes out with a new tag called <GRADIENT> (which causes the
d4103 4
d4213 1
a4213 1
  <H1>Level 1 Header</H1>
d4237 1
a4237 1
=item 1. start_table() (generates a <TABLE> tag)
d4239 1
a4239 1
=item 2. end_table() (generates a </TABLE> tag)
d4241 1
a4241 1
=item 3. start_ul() (generates a <UL> tag)
d4243 1
a4243 1
=item 4. end_ul() (generates a </UL> tag)
d4328 1
a4328 1
headers to work with a NPH (no-parse-header) script.  This is important
d4365 1
a4365 1
headers to work with a NPH (no-parse-header) script.  This is important
d4385 1
a4385 1
This method returns a canned HTML header and the opening <BODY> tag.
d4390 1
a4390 1
to the <BODY> tag.  Additional parameters must be proceeded by a
d4393 1
a4393 1
The argument B<-xbase> allows you to provide an HREF for the <BASE> tag
d4412 1
a4412 1
into a series of header <META> tags that look something like this:
d4414 2
a4415 2
    <META NAME="keywords" CONTENT="pharaoh secret mummy">
    <META NAME="description" CONTENT="copyright 1996 King Tut">
d4417 1
a4417 1
To create an HTTP-EQUIV type of <META> tag, use B<-head>, described
d4425 1
a4425 1
the <HTML> tag.  The default if not specified is "en-US" for US
d4430 5
a4434 2
You can place other arbitrary HTML elements to the <HEAD> section with the
B<-head> tag.  For example, to place the rarely-used <LINK> element in the
d4440 1
a4440 1
To incorporate multiple HTML elements into the <HEAD> section, just pass an
d4451 1
a4451 1
And here's how to create an HTTP-EQUIV <META> tag:
d4461 1
a4461 1
This block will be placed within a <SCRIPT> block inside the HTML (not
d4500 1
a4500 1
Netscape 3.0 recognizes several attributes of the <SCRIPT> tag,
d4518 1
a4518 1
A final feature allows you to incorporate multiple <SCRIPT> sections into the
a4538 1
     </pre>
d4560 1
a4560 1
The author's e-mail address (will create a <LINK REV="MADE"> tag if present
d4564 1
a4564 1
A 'true' flag if you want to include a <BASE> tag in the header.  This
d4570 1
a4570 1
Any other parameters you want to include in the <BODY> tag.  This is a good
d4579 1
a4579 1
This ends an HTML document by printing the </BODY></HTML> tags.
d4584 1
a4584 1
    print q(<A HREF="$myself">I'm talking to myself.</A>);
d4593 3
a4595 3
     print "<A HREF=$myself#table1>See table 1</A>";
     print "<A HREF=$myself#table2>See table 2</A>";
     print "<A HREF=$myself#yourself>See for yourself</A>";
d4704 1
a4704 1
   <a HREF="http://crete.org/">Crete</a> there lived
d4727 1
a4727 1
   print hr;  	#  <HR>
d4732 1
a4732 1
   print h1("Chapter","1"); # <H1>Chapter 1</H1>"
d4740 1
a4740 1
	    <A HREF="fred.html",TARGET="_new">Open a new frame</A>
d4747 1
a4747 1
	   <IMG ALIGN="LEFT" SRC="fred.gif">
d4750 1
a4750 1
lists can be marked as COMPACT.  The syntax for this is an argument that
d4757 2
a4758 2
changed in order to accommodate those who want to create tags of the form 
<IMG ALT="">.  The difference is shown in these two pieces of code:
d4760 3
a4762 3
   CODE                   RESULT
   img({alt=>undef})      <IMG ALT>
   img({alt=>''})         <IMT ALT="">
d4778 6
a4783 6
   <UL>
     <LI TYPE="disc">Sneezy</LI>
     <LI TYPE="disc">Doc</LI>
     <LI TYPE="disc">Sleepy</LI>
     <LI TYPE="disc">Happy</LI>
   </UL>
d4807 1
a4807 1
   <BLOCKQUOTE><EM>Hi</EM> mom!</BLOCKQUOTE>
d4945 1
a4945 1
Prints out an <ISINDEX> tag.  Not very exciting.  The parameter
d4963 1
a4963 1
start_form() will return a <FORM> tag with the optional method,
d4970 1
a4970 1
endform() returns the closing </FORM> tag.  
d5019 1
a5019 1
Usually the bulk of JavaScript functions are defined in a <SCRIPT>
d5219 4
d5260 6
d5499 1
a5499 1
			   -checked=>'checked',
d5952 1
a5952 1
HTML document using the start_html() call, create a <FRAMESET> 
d5956 1
a5956 1
There is no specific support for creating <FRAMESET> sections 
d5975 1
a5975 1
=item 3. Specify the destination for the document in the <FORM> tag
d5998 1
a5998 1
into a <STYLE> section, or it may be a hash reference.  In the latter
d6002 1
a6002 1
incorporated into a <STYLE> section.  Style definitions in B<-code>
d6112 11
a6122 11
    <UL>
    <LI>name1
	<UL>
	<LI>value1
	<LI>value2
	</UL>
    <LI>name2
	<UL>
	<LI>value1
	</UL>
    </UL>
d6128 1
a6128 1
    print "<H2>Current Values</H2> $query\n";
d6298 11
a6308 6
The Microsoft Internet Information Server requires NPH mode.  As of version
2.30, CGI.pm will automatically detect when the script is running under IIS
and put itself into this mode.  You do not need to do this manually, although
it won't hurt anything if you do.

There are a number of ways to put CGI.pm into NPH mode:
d6605 1
a6605 1
	print "<H1> Example CGI.pm Form</H1>\n";
d6615 1
a6615 1
	   print "<EM>What's your name?</EM><BR>";
d6619 1
a6619 1
	   print "<P><EM>Where can you find English Sparrows?</EM><BR>";
d6626 1
a6626 1
	   print "<P><EM>How far can they fly?</EM><BR>",
d6632 1
a6632 1
	   print "<P><EM>What's your favorite color?</EM>  ";
d6639 1
a6639 1
	   print "<P><EM>What have you got there?</EM><BR>";
d6647 1
a6647 1
	   print "<P><EM>Any parting comments?</EM><BR>";
d6652 1
a6652 1
	   print "<P>",$query->reset;
d6656 1
a6656 1
	   print "<HR>\n";
d6663 1
a6663 1
	   print "<H2>Here are the current settings in this form</H2>";
d6666 1
a6666 1
	      print "<STRONG>$key</STRONG> -> ";
d6668 1
a6668 1
	      print join(", ",@@values),"<BR>\n";
d6674 3
a6676 3
	<HR>
	<ADDRESS>Lincoln D. Stein</ADDRESS><BR>
	<A HREF="/">Home Page</A>
d6692 1
a6692 3
L<CGI::Carp>, L<URI::URL>, L<CGI::Request>, L<CGI::MiniSvr>,
L<CGI::Base>, L<CGI::Form>, L<CGI::Push>, L<CGI::Fast>,
L<CGI::Pretty>
@


1.4.6.1
log
@Fix by brad@@

fixes a cross-site scripting bug

http://marc.theaimsgroup.com/?l=bugtraq&m=105880349328877&w=2

ok deraadt@@ millert@@
@
text
@d21 1
a21 1
$CGI::revision = '$Id: CGI.pm,v 1.4 2001/05/24 18:35:22 millert Exp $';
d1501 1
a1501 3
       if (length($ENV{QUERY_STRING})>0) {
           $action .= "?$ENV{QUERY_STRING}";
       }
a1502 1
    $action =~ s/\"/%22/g;  # fix cross-site scripting bug reported by obscure
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d3 1
d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.19 1999/08/31 17:04:37 lstein Exp $';
$CGI::VERSION='2.56';
d27 4
d36 3
d42 8
a49 1
    $DEFAULT_DTD = '-//IETF//DTD HTML//EN';
d54 1
a54 1
    #    2) $CGI::nph(1)
d58 3
a60 3
    # Set this to 1 to disable debugging from the
    # command line
    $NO_DEBUG = 0;
d66 1
a66 1
    #    2) $CGI::private_tempfiles(1);
d83 1
a83 1
    $USE_PARAM_SEMICOLONS = 0;
d90 2
d111 1
a111 1
if ($OS=~/Win/i) {
d113 1
a113 1
} elsif ($OS=~/vms/i) {
d115 1
a115 3
} elsif ($OS=~/bsdos/i) {
  $OS = 'UNIX';
} elsif ($OS=~/dos/i) {
d117 1
a117 1
} elsif ($OS=~/^MacOS$/i) {
d119 1
a119 1
} elsif ($OS=~/os2/i) {
d121 2
d139 2
a140 1
    UNIX=>'/', OS2=>'\\', WINDOWS=>'\\', DOS=>'\\', MACINTOSH=>':', VMS=>'/'
a173 21
if ($EBCDIC) {
@@A2E = (
  0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 21, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
 64, 90,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
215,216,217,226,227,228,229,230,231,232,233,173,224,189, 95,109,
121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
151,152,153,162,163,164,165,166,167,168,169,192, 79,208,161,  7,
 32, 33, 34, 35, 36, 37,  6, 23, 40, 41, 42, 43, 44,  9, 10, 27,
 48, 49, 26, 51, 52, 53, 54,  8, 56, 57, 58, 59,  4, 20, 62,255,
 65,170, 74,177,159,178,106,181,187,180,154,138,176,202,175,188,
144,143,234,250,190,160,182,179,157,218,155,139,183,184,185,171,
100,101, 98,102, 99,103,158,104,116,113,114,115,120,117,118,119,
172,105,237,238,235,239,236,191,128,253,254,251,252,186,174, 89,
 68, 69, 66, 70, 67, 71,156, 72, 84, 81, 82, 83, 88, 85, 86, 87,
140, 73,205,206,203,207,204,225,112,221,222,219,220,141,142,223
      );
}

d184 1
a184 1
			   input Select option comment/],
d195 1
a195 1
			 virtual_host remote_ident auth_type http use_named_parameters 
d204 1
a204 1
		':push' => [qw/multipart_init multipart_start multipart_end/],
d259 3
a261 3
    if ($MOD_PERL) {
	Apache->request->register_cleanup(\&CGI::_reset_globals);
	undef $NPH;
d291 1
a291 1
	($name,$value,@@other) = $self->rearrange([NAME,[DEFAULT,VALUE,VALUES]],@@p);
d294 1
a294 1
	if (substr($p[0],0,1) eq '-' || $self->use_named_parameters) {
d322 1
a322 1
    return @@_;
d357 1
a357 1
    if (@@QUERY_PARAM && !defined($initializer)) {
d361 2
d371 3
d437 1
d456 1
a456 1
      $query_string = read_from_cmdline() unless $NO_DEBUG;
d461 2
a462 2
    if (defined $query_string && $query_string) {
	if ($query_string =~ /=/) {
d485 1
a524 23
# unescape URL-encoded data
sub unescape {
  shift() if ref($_[0]) || (defined $_[1] && $_[0] eq $DefaultClass);
  my $todecode = shift;
  return undef unless defined($todecode);
  $todecode =~ tr/+/ /;       # pluses become spaces
    if ($EBCDIC) {
      $todecode =~ s/%([0-9a-fA-F]{2})/pack("c",$A2E[hex($1)])/ge;
    } else {
      $todecode =~ s/%([0-9a-fA-F]{2})/pack("c",hex($1))/ge;
    }
  return $todecode;
}

# URL-encode data
sub escape {
  shift() if ref($_[0]) || (defined $_[1] && $_[0] eq $DefaultClass);
  my $toencode = shift;
  return undef unless defined($toencode);
  $toencode=~s/([^a-zA-Z0-9_.-])/uc sprintf("%%%02x",ord($1))/eg;
  return $toencode;
}

d532 2
a533 1
	$QUERY_PARAM{$_}=$self->{$_};
d535 2
d545 1
d555 1
d575 5
a579 7
	sub $tagname { 
	    shift if \$_[0] && 
#		(!ref(\$_[0]) && \$_[0] eq \$CGI::DefaultClass) ||
		    (ref(\$_[0]) &&
		     (substr(ref(\$_[0]),0,3) eq 'CGI' ||
		    UNIVERSAL::isa(\$_[0],'CGI')));
	    
d582 1
a582 1
		my(\@@attr) = make_attributes( '',shift() );
d587 1
a587 1
	$func .= qq! return "<\U$1\E\$attr>";} !;
d589 1
a589 1
	$func .= qq! return "<\U/$1\E>"; } !;
d592 4
a595 3
	    my(\$tag,\$untag) = ("\U<$tagname\E\$attr>","\U</$tagname>\E");
	    return \$tag unless \@@_;
	    my \@@result = map { "\$tag\$_\$untag" } (ref(\$_[0]) eq 'ARRAY') ? \@@{\$_[0]} : "\@@_";
a607 41
# PRIVATE SUBROUTINE
# Smart rearrangement of parameters to allow named parameter
# calling.  We do the rearangement if:
# 1. The first parameter begins with a -
# 2. The use_named_parameters() method returns true
sub rearrange {
    my($self,$order,@@param) = @@_;
    return () unless @@param;

    if (ref($param[0]) eq 'HASH') {
	@@param = %{$param[0]};
    } else {
	return @@param 
	    unless (defined($param[0]) && substr($param[0],0,1) eq '-')
		|| $self->use_named_parameters;
    }

    # map parameters into positional indices
    my ($i,%pos);
    $i = 0;
    foreach (@@$order) {
	foreach (ref($_) eq 'ARRAY' ? @@$_ : $_) { $pos{$_} = $i; }
	$i++;
    }

    my (@@result,%leftover);
    $#result = $#$order;  # preextend
    while (@@param) {
	my $key = uc(shift(@@param));
	$key =~ s/^\-//;
	if (exists $pos{$key}) {
	    $result[$pos{$key}] = shift(@@param);
	} else {
	    $leftover{$key} = shift(@@param);
	}
    }

    push (@@result,$self->make_attributes(\%leftover)) if %leftover;
    @@result;
}

d623 1
a623 1
	   die $@@ if $@@;
d639 1
a639 1
       die "Undefined subroutine $AUTOLOAD\n" unless $code;
d643 1
a643 1
	   die $@@;
d658 3
a660 1
	$NO_DEBUG++,             next if /^[:-]no_?[Dd]ebug$/;
d662 3
d688 6
d711 1
a711 16
sub SERVER_PUSH { 'multipart/x-mixed-replace; boundary="' . shift() . '"'; }
END_OF_FUNC

'use_named_parameters' => <<'END_OF_FUNC',
#### Method: use_named_parameters
# Force CGI.pm to use named parameter-style method calls
# rather than positional parameters.  The same effect
# will happen automatically if the first parameter
# begins with a -.
sub use_named_parameters {
    my($self,$use_named) = self_or_default(@@_);
    return $self->{'.named'} unless defined ($use_named);

    # stupidity to avoid annoying warnings
    return $self->{'.named'}=$use_named;
}
d737 2
a738 1
    my($self,$name) = self_or_default(@@_);
d864 1
a864 1
    return $Q || new shift;
d870 5
a874 1
    $_[0]->param($_[1],split("\0",$_[2]));
d924 1
a924 1
    my($name,$value) = $self->rearrange([NAME,[VALUE,VALUES]],@@p);
a977 15
'make_attributes' => <<'END_OF_FUNC',
sub make_attributes {
    my($self,$attr) = @@_;
    return () unless $attr && ref($attr) && ref($attr) eq 'HASH';
    my(@@att);
    foreach (keys %{$attr}) {
	my($key) = $_;
	$key=~s/^\-//;     # get rid of initial - if present
	$key=~tr/a-z_/A-Z-/; # parameters are upper case, use dashes
	push(@@att,defined($attr->{$_}) ? qq/$key="$attr->{$_}"/ : qq/$key/);
    }
    return @@att;
}
END_OF_FUNC

d1009 1
a1009 1
#### Method: dump
d1014 2
a1015 2
'dump' => <<'END_OF_FUNC',
sub dump {
d1042 1
a1042 1
    &dump(@@_);
d1064 3
d1095 1
a1095 1
# This has to be NPH, and it is advisable to set $| = 1
d1098 1
a1098 1
# contribution
d1103 1
a1103 1
    my($boundary,@@other) = $self->rearrange([BOUNDARY],@@p);
d1105 2
a1106 1
    $self->{'separator'} = "\n--$boundary\n";
d1112 1
a1112 1
    ) . $self->multipart_end;
d1121 1
a1121 1
# contribution
d1125 1
d1127 1
a1127 1
    my($type,@@other) = $self->rearrange([TYPE],@@p);
d1129 11
a1139 4
    return $self->header(
	-type => $type,
	(map { split "=", $_, 2 } @@other),
    );
d1145 1
a1145 1
# Return a Content-Type: style header for server-push, end of section
d1158 13
d1182 12
a1193 3
    my($type,$status,$cookie,$target,$expires,$nph,@@other) = 
	$self->rearrange([['TYPE','CONTENT_TYPE','CONTENT-TYPE'],
			  STATUS,[COOKIE,COOKIES],TARGET,EXPIRES,NPH],@@p);
a1194 1
    $nph ||= $NPH;
d1199 1
a1199 1
	($_ = $header) =~ s/^(\w)(.*)/$1 . lc ($2) . ": $value"/e;
d1203 1
d1208 1
d1225 1
a1225 1
    push(@@header,"Date: " . expires(0,'http')) if $expires || $cookie;
d1227 1
d1265 2
a1266 2
    my($url,$target,$cookie,$nph,@@other) = $self->rearrange([[LOCATION,URI,URL],TARGET,COOKIE,NPH],@@p);
    $url = $url || $self->self_url;
d1303 2
a1304 2
    my($title,$author,$base,$xbase,$script,$noscript,$target,$meta,$head,$style,$dtd,@@other) = 
	$self->rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,META,HEAD,STYLE,DTD],@@p);
d1310 27
a1336 5
    my(@@result);
    $dtd = $DEFAULT_DTD unless $dtd && $dtd =~ m|^-//|;
    push(@@result,qq(<!DOCTYPE HTML PUBLIC "$dtd">)) if $dtd;
    push(@@result,"<HTML><HEAD><TITLE>$title</TITLE>");
    push(@@result,"<LINK REV=MADE HREF=\"mailto:$author\">") if defined $author;
d1340 2
a1341 2
	my $t = $target ? qq/ TARGET="$target"/ : '';
	push(@@result,qq/<BASE HREF="$href"$t>/);
d1345 2
a1346 1
	foreach (keys %$meta) { push(@@result,qq(<META NAME="$_" CONTENT="$meta->{$_}">)); }
d1357 1
a1357 1
<NOSCRIPT>
d1359 1
a1359 1
</NOSCRIPT>
d1363 1
a1363 1
    push(@@result,"</HEAD><BODY$other>");
d1376 4
d1381 20
a1400 7
	my($src,$code,$stype,@@other) =
	    $self->rearrange([SRC,CODE,TYPE],
			     '-foo'=>'bar',	# a trick to allow the '-' to be omitted
			     ref($style) eq 'ARRAY' ? @@$style : %$style);
	$type = $stype if $stype;
	push(@@result,qq/<LINK REL="stylesheet" TYPE="$type" HREF="$src">/) if $src;
	push(@@result,style({'type'=>$type},"<!--\n$code\n-->")) if $code;
d1402 1
a1402 1
	push(@@result,style({'type'=>$type},"<!--\n$style\n-->"));
a1407 1

d1412 1
d1417 2
a1418 2
	    ($src,$code,$language) =
		$self->rearrange([SRC,CODE,LANGUAGE],
d1421 7
a1427 1
	    
d1429 1
a1429 1
	    ($src,$code,$language) = ('',$script,'JavaScript');
d1431 10
d1443 3
a1445 5
	push(@@satts,'language'=>$language || 'JavaScript');
	$code = "<!-- Hide script\n$code\n// End script hiding -->"
	    if $code && $language=~/javascript/i;
	$code = "<!-- Hide script\n$code\n\# End script hiding -->"
	    if $code && $language=~/perl/i;
d1458 1
a1458 1
    return "</BODY></HTML>";
d1476 2
a1477 2
    my($action,@@other) = $self->rearrange([ACTION],@@p);
    $action = qq/ACTION="$action"/ if $action;
d1479 1
a1479 1
    return "<ISINDEX $action$other>";
d1495 1
a1495 1
	$self->rearrange([METHOD,ACTION,ENCTYPE],@@p);
d1497 1
a1497 1
    $method = $method || 'POST';
d1499 5
a1503 2
    $action = $action ? qq/ACTION="$action"/ : $method eq 'GET' ?
	'ACTION="'.$self->script_name.'"' : '';
d1506 1
a1506 1
    return qq/<FORM METHOD="$method" $action ENCTYPE="$enctype"$other>\n/;
d1530 1
a1530 2
    if ($self->use_named_parameters || 
	(defined($param[0]) && substr($param[0],0,1) eq '-')) {
d1536 1
a1536 1
	    $self->rearrange([METHOD,ACTION],@@p);
d1548 6
a1553 2
    return wantarray ? ($self->get_fields,"</FORM>") : 
                        $self->get_fields ."\n</FORM>";
d1571 1
a1571 1
	$self->rearrange([NAME,[DEFAULT,VALUE],SIZE,MAXLENGTH,[OVERRIDE,FORCE]],@@p);
d1576 1
a1576 1
    $current = defined($current) ? $self->escapeHTML($current) : '';
d1578 2
a1579 2
    my($s) = defined($size) ? qq/ SIZE=$size/ : '';
    my($m) = defined($maxlength) ? qq/ MAXLENGTH=$maxlength/ : '';
d1583 3
a1585 2
    my($value) = $current ne '' ? qq(VALUE="$current") : '';
    return qq/<INPUT TYPE="$tag" NAME="$name" $value$s$m$other>/;
d1656 1
a1656 1
	$self->rearrange([NAME,[DEFAULT,VALUE],ROWS,[COLS,COLUMNS],[OVERRIDE,FORCE]],@@p);
d1663 2
a1664 2
    my($r) = $rows ? " ROWS=$rows" : '';
    my($c) = $cols ? " COLS=$cols" : '';
d1666 1
a1666 1
    return qq{<TEXTAREA NAME="$name"$r$c$other>$current</TEXTAREA>};
d1685 1
a1685 1
    my($label,$value,$script,@@other) = $self->rearrange([NAME,[VALUE,LABEL],
d1689 1
a1689 1
    $value=$self->escapeHTML($value);
d1693 1
a1693 1
    $name = qq/ NAME="$label"/ if $label;
d1696 2
a1697 2
    $val = qq/ VALUE="$value"/ if $value;
    $script = qq/ ONCLICK="$script"/ if $script;
d1699 2
a1700 1
    return qq/<INPUT TYPE="button"$name$val$script$other>/;
d1718 1
a1718 1
    my($label,$value,@@other) = $self->rearrange([NAME,[VALUE,LABEL]],@@p);
d1721 1
a1721 1
    $value=$self->escapeHTML($value);
d1723 2
a1724 2
    my($name) = ' NAME=".submit"';
    $name = qq/ NAME="$label"/ if defined($label);
d1727 1
a1727 1
    $val = qq/ VALUE="$value"/ if defined($value);
d1729 2
a1730 1
    return qq/<INPUT TYPE="submit"$name$val$other>/;
d1745 1
a1745 1
    my($label,@@other) = $self->rearrange([NAME],@@p);
d1747 1
a1747 1
    my($value) = defined($label) ? qq/ VALUE="$label"/ : '';
d1749 2
a1750 1
    return qq/<INPUT TYPE="reset"$value$other>/;
d1770 1
a1770 1
    my($label,@@other) = $self->rearrange([[NAME,VALUE]],@@p);
d1772 1
a1772 1
    $label=$self->escapeHTML($label);
d1774 1
a1774 1
    my($value) = qq/ VALUE="$label"/;
d1776 2
a1777 1
    return qq/<INPUT TYPE="submit" NAME=".defaults"$value$other>/;
d1809 1
a1809 1
	$self->rearrange([NAME,[CHECKED,SELECTED,ON],VALUE,LABEL,[OVERRIDE,FORCE]],@@p);
d1815 1
a1815 1
	$checked = grep($_ eq $value,$self->param($name)) ? ' CHECKED' : '';
d1817 1
a1817 1
	$checked = $checked ? ' CHECKED' : '';
d1821 1
a1821 1
    $value = $self->escapeHTML($value);
d1825 2
a1826 1
    return qq{<INPUT TYPE="checkbox" NAME="$name" VALUE="$value"$checked$other>$the_label};
d1858 1
a1858 1
	$self->rearrange([NAME,[VALUES,VALUE],[DEFAULTS,DEFAULT],
d1867 6
a1872 1
    $break = $linebreak ? "<BR>" : '';
d1882 1
a1882 1
	$checked = $checked{$_} ? ' CHECKED' : '';
d1889 3
a1891 2
	$_ = $self->escapeHTML($_);
	push(@@elements,qq/<INPUT TYPE="checkbox" NAME="$name" VALUE="$_"$checked$other>${label}${break}/);
d1903 19
a1921 9
    my ($self,$toencode) = self_or_default(@@_);
    return undef unless defined($toencode);
    return $toencode if ref($self) && $self->{'dontescape'};

    $toencode=~s/&/&amp;/g;
    $toencode=~s/\"/&quot;/g;
    $toencode=~s/>/&gt;/g;
    $toencode=~s/</&lt;/g;
    return $toencode;
d1928 1
a1928 1
    my $string = ref($_[0]) ? $_[1] : $_[0];
d1930 2
d1939 2
a1940 2
	/^#(\d+)$/	? chr($1) :
	/^#x([0-9a-f]+)$/i ? chr(hex($1)) :
d1951 2
d1963 1
a1963 1
    $result = "<TABLE>";
d1966 1
a1966 1
    $result .= "<TR>" if @@$colheaders;
d1968 1
a1968 1
	$result .= "<TH>$_</TH>";
d1971 2
a1972 2
	$result .= "<TR>";
	$result .= "<TH>$rowheaders->[$row]</TH>" if @@$rowheaders;
d1974 1
a1974 1
	    $result .= "<TD>" . $elements[$column*$rows + $row] . "</TD>"
d1977 1
a1977 1
	$result .= "</TR>";
d1979 1
a1979 1
    $result .= "</TABLE>";
d2008 1
a2008 1
	$self->rearrange([NAME,[VALUES,VALUE],DEFAULT,LINEBREAK,LABELS,
d2028 8
a2035 2
	my($checkit) = $checked eq $_ ? ' CHECKED' : '';
	my($break) = $linebreak ? '<BR>' : '';
d2040 1
a2040 1
	    $label = $self->escapeHTML($label);
d2043 2
a2044 1
	push(@@elements,qq/<INPUT TYPE="radio" NAME="$name" VALUE="$_"$checkit$other>${label}${break}/);
d2073 1
a2073 1
	$self->rearrange([NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LABELS,[OVERRIDE,FORCE]],@@p);
d2087 1
a2087 1
    $result = qq/<SELECT NAME="$name"$other>\n/;
d2089 1
a2089 1
	my($selectit) = defined($selected) ? ($selected eq $_ ? 'SELECTED' : '' ) : '';
d2093 2
a2094 2
	$label=$self->escapeHTML($label);
	$result .= "<OPTION $selectit VALUE=\"$value\">$label\n";
d2097 1
a2097 1
    $result .= "</SELECT>\n";
d2127 1
a2127 1
	= $self->rearrange([NAME,[VALUES,VALUE],[DEFAULTS,DEFAULT],
d2136 2
a2137 2
    my($is_multiple) = $multiple ? ' MULTIPLE' : '';
    my($has_size) = $size ? " SIZE=$size" : '';
d2141 1
a2141 1
    $result = qq/<SELECT NAME="$name"$has_size$is_multiple$other>\n/;
d2143 1
a2143 1
	my($selectit) = $selected{$_} ? 'SELECTED' : '';
d2147 2
a2148 2
	my($value)=$self->escapeHTML($_);
	$result .= "<OPTION $selectit VALUE=\"$value\">$label\n";
d2150 1
a2150 1
    $result .= "</SELECT>\n";
d2174 1
a2174 1
	$self->rearrange([NAME,[DEFAULT,VALUE,VALUES],[OVERRIDE,FORCE]],@@p);
d2177 1
a2177 1
    if ( ref($p[0]) || substr($p[0],0,1) eq '-' || $self->use_named_parameters ) {
d2192 3
a2194 2
	$_ = defined($_) ? $self->escapeHTML($_) : '';
	push(@@result,qq/<INPUT TYPE="hidden" NAME="$name" VALUE="$_">/);
d2214 1
a2214 1
	$self->rearrange([NAME,SRC,ALIGN],@@p);
d2216 1
a2216 1
    my($align) = $alignment ? " ALIGN=\U$alignment" : '';
d2219 2
a2220 1
    return qq/<INPUT TYPE="image" NAME="$name" SRC="$src"$align$other>/;
d2255 2
a2256 2
    my ($relative,$absolute,$full,$path_info,$query) = 
	$self->rearrange(['RELATIVE','ABSOLUTE','FULL',['PATH','PATH_INFO'],['QUERY','QUERY_STRING']],@@p);
d2258 1
a2258 1
    $full++ if !($relative || $absolute);
d2261 16
a2276 12
    my $script_name;
    if (exists($ENV{REQUEST_URI})) {
        my $index;
	$script_name = $ENV{REQUEST_URI};
        # strip query string
        substr($script_name,$index) = '' if ($index = index($script_name,'?')) >= 0;
        # and path
        substr($script_name,$index) = '' if exists($ENV{PATH_INFO})
                                     and ($index = rindex($script_name,$ENV{PATH_INFO})) >= 0;
    } else {
	$script_name = $self->script_name;
    }
d2291 1
d2298 1
d2301 2
d2324 1
a2324 1
	$self->rearrange([NAME,[VALUE,VALUES],PATH,DOMAIN,SECURE,EXPIRES],@@p);
d2343 1
a2343 1
    return undef unless $name;	# this is an error
d2353 1
a2353 64
    return CGI::Cookie->new(@@param);
}
END_OF_FUNC

# This internal routine creates an expires time exactly some number of
# hours from the current time.  It incorporates modifications from 
# Mark Fisher.
'expire_calc' => <<'END_OF_FUNC',
sub expire_calc {
    my($time) = @@_;
    my(%mult) = ('s'=>1,
                 'm'=>60,
                 'h'=>60*60,
                 'd'=>60*60*24,
                 'M'=>60*60*24*30,
                 'y'=>60*60*24*365);
    # format for time can be in any of the forms...
    # "now" -- expire immediately
    # "+180s" -- in 180 seconds
    # "+2m" -- in 2 minutes
    # "+12h" -- in 12 hours
    # "+1d"  -- in 1 day
    # "+3M"  -- in 3 months
    # "+2y"  -- in 2 years
    # "-3m"  -- 3 minutes ago(!)
    # If you don't supply one of these forms, we assume you are
    # specifying the date yourself
    my($offset);
    if (!$time || (lc($time) eq 'now')) {
        $offset = 0;
    } elsif ($time=~/^\d+/) {
        return $time;
    } elsif ($time=~/^([+-]?(?:\d+|\d*\.\d*))([mhdMy]?)/) {
        $offset = ($mult{$2} || 1)*$1;
    } else {
        return $time;
    }
    return (time+$offset);
}
END_OF_FUNC

# This internal routine creates date strings suitable for use in
# cookies and HTTP headers.  (They differ, unfortunately.)
# Thanks to Mark Fisher for this.
'expires' => <<'END_OF_FUNC',
sub expires {
    my($time,$format) = @@_;
    $format ||= 'http';

    my(@@MON)=qw/Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec/;
    my(@@WDAY) = qw/Sun Mon Tue Wed Thu Fri Sat/;

    # pass through preformatted dates for the sake of expire_calc()
    $time = expire_calc($time);
    return $time unless $time =~ /^\d+$/;

    # make HTTP/cookie date string from GMT'ed time
    # (cookies use '-' as date separator, HTTP uses ' ')
    my($sc) = ' ';
    $sc = '-' if $format eq "cookie";
    my($sec,$min,$hour,$mday,$mon,$year,$wday) = gmtime($time);
    $year += 1900;
    return sprintf("%s, %02d$sc%s$sc%04d %02d:%02d:%02d GMT",
                   $WDAY[$wday],$mday,$MON[$mon],$year,$hour,$min,$sec);
d2370 1
a2370 1
    my($name) = $self->rearrange([NAME],@@p);
d2452 3
d2742 11
d2780 6
a2785 2
    my ($self,$param) = self_or_CGI(@@_);
    $CGI::DEFAULT_DTD = $param if defined($param);
d2830 1
a2830 1
    if (@@ARGV) {
d2832 1
a2832 1
    } else {
d2879 1
a2879 1
	my($filename) = $header{'Content-Disposition'}=~/ filename="?([^\";]*)"?/;
d3012 1
a3012 1
    $i =~ s/\\(.)/$1/g;
d3037 3
a3039 1
    my $ref = \*{'Fh::' .  ++$FH . quotemeta($name)};
d3042 1
a3042 1
    CORE::delete $Fh::{$FH};
d3102 1
d3119 1
d3135 3
a3137 1
    while ($self->read(0)) { }
d3151 1
a3151 3
    if ($CGI::OS eq 'VMS') {  # tssk, tssk: inconsistency alert!
	local($CRLF) = "\015\012";
    }
d3216 1
a3216 2
    # and return undef.  The +2 here is a fiendish plot to
    # remove the CR/LF pair at the end of the boundary.
d3227 2
a3228 1
	substr($self->{BUFFER},0,length($self->{BOUNDARY})+2)='';
d3311 3
a3313 2
	   "${vol}${SL}Temporary Items","${SL}sys\$scratch",
	   "${SL}WWW_ROOT");
d3316 2
a3317 1
    #
d3323 1
a3323 1
    unshift(@@TEMP,(eval {(getpwuid($<))[7]}).'/tmp') if $CGI::OS eq 'UNIX';
d3352 1
a3352 1
    return unless $filename =~ m!^([a-zA-Z0-9_ '":/\\]+)$!;
a3511 11
You don't have to use the hyphen at all if you don't want to.  After
creating a CGI object, call the B<use_named_parameters()> method with
a nonzero value.  This will tell CGI.pm that you intend to use named
parameters exclusively:

   $query = new CGI;
   $query->use_named_parameters(1);
   $field = $query->radio_group('name'=>'OS',
				'values'=>['Unix','Windows','Macintosh'],
				'default'=>'Unix');

d3528 1
a3528 1
   $q->param(-name=>'veggie',-value=>'[tomato','tomahto','potato','potahto']);
d3569 1
a3569 2
=item 1. Use another name for the argument, if one is available.  For
example, -value is an alias for -values.
d3571 4
a3574 1
=item 2. Change the capitalization, e.g. -Values
d3576 5
a3580 1
=item 3. Put quotes around the argument name, e.g. '-values'
d3683 5
a3687 4
(e.g. "name1=value1&name2=value2&name3=value3"), the param()
method will return the parameter names as a list.  If the
script was invoked as an <ISINDEX> script, there will be a
single parameter named 'keywords'.
d3708 4
d3802 1
a3802 1
CGI parameter list.  Called in an array context, it returns the
d3808 1
a3808 1
array context, multivalued parameters will be returned as a packed
d4015 2
a4016 2
standard set of functions and disables debugging mode (pragma
-no_debug):
d4018 1
a4018 1
   use CGI qw/:standard -no_debug/;
d4058 15
d4091 7
d4114 2
a4115 2
don't want it pausing to request CGI parameters from standard input or
the command line, then use this pragma:
d4119 1
a4119 2
If you'd like to process the command-line parameters but not standard
input, this should work:
d4121 4
a4124 2
   use CGI qw(-no_debug :standard);
   restore_parameters(join('&',@@ARGV));
d4244 2
d4288 11
a4298 2
to use with certain servers, such as Microsoft Internet Explorer, which
expect all their scripts to be NPH.
d4310 1
a4310 3
well.  As of version 2.0, we produce both the unofficial Location:
header and the official URI: header.  This should satisfy most servers
and browsers.
d4346 5
a4350 4
parameters are -title, -author, -base, -xbase and -target (see below
for the explanation).  Any additional parameters you provide, such as
the Netscape unofficial BGCOLOR attribute, are added to the <BODY>
tag.  Additional parameters must be proceeded by a hyphen.
d4360 4
a4363 2
for all the links and fill-out forms on the page.  See the Netscape
documentation on frames for details of how to manipulate this.
d4376 2
a4377 4
There is no support for the HTTP-EQUIV type of <META> tag.  This is
because you can modify the HTTP header directly with the B<header()>
method.  For example, if you want to send the Refresh: header, do it
in the header() method:
d4379 7
a4385 1
    print $q->header(-Refresh=>'10; URL=http://www.capricorn.com');
d4387 1
a4387 2
The B<-style> tag is used to incorporate cascading stylesheets into
your code.  See the section on CASCADING STYLESHEETS for more information.
d4394 1
a4394 1
		     -href=>'http://www.capricorn.com/s2.html'}));
d4407 6
d4541 1
a4541 1
    print "<A HREF=$myself>I'm talking to myself.</A>";
d4569 1
d4611 4
d4730 1
a4730 1
             li({-type=>'disc'},['Sneezy','Doc','Sleepy','Happy']);
d4806 43
a4893 1

d4908 1
a4908 1
    print $query->startform(-method=>$method,
d4916 1
a4916 1
    print $query->startform($method,$action,$encoding);
d4920 1
a4920 1
startform() will return a <FORM> tag with the optional method,
d4929 1
a4929 1
Startform()'s enctype argument tells the browser how to package the various
d4933 3
d4944 1
a4944 1
type in B<$CGI::URL_ENCODED>.
d4961 1
a4961 1
For compatibility, the startform() method uses the older form of
d4964 1
a4964 1
B<startform()>.
d5098 1
a5098 1
by calling B<startform()> with an encoding type of B<$CGI::MULTIPART>,
d5100 1
a5100 1
vanilla B<startform()>.
d5714 1
d5863 2
a5864 2
To retrieve a cookie, request it by name by calling cookie()
method without the B<-value> parameter:
d5868 6
a5873 2
	%answers = $query->cookie(-name=>'answers');
	# $query->cookie('answers') will work too!
d5927 1
a5927 1
    print $q->startform(-target=>'ResultsWindow');
d6010 3
d6015 5
a6019 6
If you are running the script
from the command line or in the perl debugger, you can pass the script
a list of keywords or parameter=value pairs on the command line or 
from standard input (you don't have to worry about tricking your
script into reading from environment variables).
You can pass keywords like this:
d6035 5
a6039 1
or even as newline-delimited parameters on standard input.
d6050 1
a6050 1
The dump() method produces a string consisting of all the query's
d6054 1
a6054 1
    print $query->dump
d6121 2
a6122 3
E.G. fetching /cgi-bin/your_script/additional/stuff will
result in $query->path_info() returning
"additional/stuff".
d6148 1
d6173 4
d6267 3
a6269 1
=item By using B<-nph> parameters in the B<header()> and B<redirect()>  statements:
d6277 1
a6277 1
CGI.pm provides three simple functions for producing multipart
d6289 2
a6290 2
  print multipart_init(-boundary=>'----------------here we go!');
  while (1) {
d6292 6
a6297 2
            "The current time is ",scalar(localtime),"\n",
            multipart_end;
d6302 2
a6303 2
It then enters an infinite loop in which it begins a new multipart
section by calling B<multipart_start()>, prints the current local time,
d6305 3
a6307 1
a second, and begins again.
d6331 9
a6339 1
multipart_start().
d6346 3
d6556 1
a6556 1
	   print $query->startform;
@


1.2
log
@perl5.005_03 (stock)
@
text
@d20 2
a21 2
$CGI::revision = '$Id: CGI.pm,v 1.5 1998/12/06 10:19:48 lstein Exp $';
$CGI::VERSION='2.46';
d61 3
d95 1
a95 1
    $OS = 'WINDOWS';
d97 5
a101 1
    $OS = 'VMS';
d111 1
a111 1
$needs_binmode = $OS=~/^(WINDOWS|VMS|OS2)/;
d122 1
a122 1
    UNIX=>'/', OS2=>'\\', WINDOWS=>'\\', MACINTOSH=>':', VMS=>'/'
d133 1
a133 1
    ($MOD_PERL = $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-Perl/))
d149 1
a149 1
    $CRLF = "\n";
d151 1
a151 1
    $CRLF= "\r\n";
d153 22
a174 1
    $CRLF = "\015\012";
d195 2
a196 2
		':cgi'=>[qw/param path_info path_translated url self_url script_name cookie Dump
			 raw_cookie request_method query_string Accept user_agent remote_host 
d200 2
a201 1
			 remote_user user_name header redirect import_names put Delete Delete_all url_param/],
d204 1
a204 1
		':cgi-lib' => [qw/ReadParse PrintHeader HtmlTop HtmlBot SplitParam/],
d360 1
a360 1
    if (defined(@@QUERY_PARAM) && !defined($initializer)) {
d369 1
a369 2
    die "Client attempted to POST $content_length bytes, but POSTs are limited to $POST_MAX"
	if ($POST_MAX > 0) && ($content_length > $POST_MAX);
d374 6
d431 5
a435 1
	  $query_string = $ENV{'QUERY_STRING'} if defined $ENV{'QUERY_STRING'};
d458 1
a458 1
    if ($query_string ne '') {
d514 7
d523 10
a532 6
    shift() if ref($_[0]);
    my $todecode = shift;
    return undef unless defined($todecode);
    $todecode =~ tr/+/ /;       # pluses become spaces
    $todecode =~ s/%([0-9a-fA-F]{2})/pack("c",hex($1))/ge;
    return $todecode;
d537 5
a541 5
    shift() if ref($_[0]) || $_[0] eq $DefaultClass;
    my $toencode = shift;
    return undef unless defined($toencode);
    $toencode=~s/([^a-zA-Z0-9_.-])/uc sprintf("%%%02x",ord($1))/eg;
    return $toencode;
d588 1
a588 1
    my $func = qq#
d591 1
a591 1
		(!ref(\$_[0]) && \$_[0] eq \$CGI::DefaultClass) ||
d601 1
a601 1
	#;
d702 1
a702 1
    delete($sub->{$func_name});  #free storage
d798 2
a799 2
    delete $self->{$name};
    delete $self->{'.fieldnames'}->{$name};
d814 1
a814 1
    if ($delete || $MOD_PERL) {
d845 1
a845 1
    $self->{'keywords'}=[@@values] if defined(@@values);
d853 12
d922 2
a923 1
    return $Q || new CGI;
d1096 1
d1131 1
a1131 1
	    print $filehandle "$escaped_param=",escape($value),"\n";
d1393 1
a1393 1
	push(@@result,qq/<LINK REL="stylesheet" HREF="$src">/) if $src;
d1414 1
a1414 1
				 ref($style) eq 'ARRAY' ? @@$script : %$script);
d1426 1
a1426 1
	push(@@result,script({@@satts},$code));
d1526 2
a1527 1
    return ($self->get_fields,"</FORM>");
d1794 1
a1794 3
    return <<END;
<INPUT TYPE="checkbox" NAME="$name" VALUE="$value"$checked$other>$the_label
END
d1865 1
a1865 2
    my($self,$toencode) = @@_;
    $toencode = $self unless ref($self);
d1913 2
a1914 2
    unshift(@@$colheaders,'') if defined(@@$colheaders) && defined(@@$rowheaders);
    $result .= "<TR>" if defined(@@{$colheaders});
d1920 1
a1920 1
	$result .= "<TH>$rowheaders->[$row]</TH>" if defined(@@$rowheaders);
d2133 1
a2133 1
	$_=$self->escapeHTML($_);
d2199 14
d2226 1
a2226 1
	$url .= $self->script_name;
d2228 1
a2228 1
	($url) = $self->script_name =~ m!([^/]+)$!;
d2230 1
a2230 1
	$url = $self->script_name;
d2232 1
a2232 1
    $url .= $self->path_info if $path_info and $self->path_info;
d2284 1
a2284 1
    return new CGI::Cookie(@@param);
d2314 2
d2327 1
a2327 1
# Thanks to Fisher Mark for this.
d2410 9
d2442 1
d2646 1
d2665 1
d2846 5
a2850 1
	die "Malformed multipart POST\n" unless %header;
d2862 1
a2862 1
	unless ($filename) {
d2880 9
a2888 5
	  $tmpfile = new TempFile;
	  $tmp = $tmpfile->as_string;
	  
	  $filehandle = Fh->new($filename,$tmp,$PRIVATE_TEMPFILES);

a2889 1
	  chmod 0600,$tmp;    # only the owner can tamper with it
d2903 1
a2903 1
	  $self->{'.tmpfiles'}->{$filename}= {
d2913 10
d2926 2
a2927 2
    return $self->{'.tmpfiles'}->{$filename}->{name} ?
	$self->{'.tmpfiles'}->{$filename}->{name}->as_string
d2935 1
a2935 1
    return $self->{'.tmpfiles'}->{$filename}->{info};
d2987 1
a2987 1
    (my $i = $$self) =~ s/^\*(\w+::)+//; 
d3013 2
a3014 4
    ++$FH;
    my $ref = \*{'Fh::' . quotemeta($name)}; 
    sysopen($ref,$file,Fcntl::O_RDWR()|Fcntl::O_CREAT()|Fcntl::O_EXCL()) 
	|| die "CGI open of $file: $!\n";
d3016 1
a3016 1
    delete $Fh::{$FH};
d3083 1
a3083 1
	$boundary = "--$boundary" unless CGI::user_agent('MSIE 3\.0[12];  ?Mac');
d3282 2
a3283 1
	   "C:${SL}temp","${SL}tmp","${SL}temp","${vol}${SL}Temporary Items",
d3285 10
a3300 1
$SEQUENCE=0;
d3316 9
a3324 8
    my($package) = @@_;
    my $directory;
    my $i;
    for ($i = 0; $i < $MAXTRIES; $i++) {
	$directory = sprintf("${TMPDIRECTORY}${SL}CGItemp%d%04d",${$},++$SEQUENCE);
	last if ! -f $directory;
    }
    return bless \$directory;
a3357 1
    $TempFile::SEQUENCE;
d3439 1
a3439 1
   #!/usr/local/bin/perl
d3757 30
d3833 2
a3834 2
	
  http://www.genome.wi.mit.edu/genome_software/other/boulder.html
d3841 23
d3924 1
a3924 1
code, where the variable %TAGS is defined.
d4072 1
a4072 1
  
d4077 29
a4105 9
CGI.pm can process uploaded file. Ordinarily it spools the
uploaded file to a temporary directory, then deletes the file
when done.  However, this opens the risk of eavesdropping as
described in the file upload section.
Another CGI script author could peek at this data during the
upload, even if it is confidential information. On Unix systems,
the -private_tempfiles pragma will cause the temporary file to be unlinked as soon
as it is opened and before any data is written into it,
eliminating the risk of eavesdropping.
d4325 2
a4326 2
    print $q->start_html(-head=>Link({-rel=>'next',
				  -href=>'http://www.capricorn.com/s2.html'}));
d4331 5
a4335 5
    print $q->start_html(-head=>[ 
                              Link({-rel=>'next',
				    -href=>'http://www.capricorn.com/s2.html'}),
			      Link({-rel=>'previous',
				    -href=>'http://www.capricorn.com/s1.html'})
d4395 2
a4396 2
	       -script=>{-language=>'PERLSCRIPT'},
			 -code=>'print "hello world!\n;"'
d4405 4
a4408 4
     print $q-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
                          -script=&gt;[
                                    { -language =&gt; 'JavaScript1.0',
                                      -src      =&gt; '/javascript/utilities10.js'
d4410 2
a4411 2
                                    { -language =&gt; 'JavaScript1.1',
                                      -src      =&gt; '/javascript/utilities11.js'
d4413 2
a4414 2
                                    { -language =&gt; 'JavaScript1.2',
                                      -src      =&gt; '/javascript/utilities12.js'
d4416 2
a4417 2
                                    { -language =&gt; 'JavaScript28.2',
                                      -src      =&gt; '/javascript/utilities219.js'
d4572 1
a4572 1
		     "there lived a minotaur named",
d4619 1
a4619 1
   
d4637 1
a4637 1
  
d4771 1
a4771 1
			     
d4801 1
a4801 1
	
d5010 1
a5010 1
by calling param().
d5014 6
a5019 13
In Netscape Navigator 2.0, the filename that gets returned is the full
local filename on the B<remote user's> machine.  If the remote user is
on a Unix machine, the filename will follow Unix conventions:

	/path/to/the/file

On an MS-DOS/Windows and OS/2 machines, the filename will follow DOS conventions:

	C:\PATH\TO\THE\FILE.MSW

On a Macintosh machine, the filename will follow Mac conventions:

	HD 40:Desktop Folder:Sort Through:Reminders
d5035 19
d5069 19
a5087 1
Otherwise you may find that binary files are corrupted during file uploads.
d5245 1
a5245 1
    
d5783 1
a5783 1
   
d5920 1
a5920 1
    
d6058 26
d6165 1
a6165 1
     
d6260 20
a6279 6
Since an attempt to send a POST larger than $POST_MAX bytes
will cause a fatal error, you might want to use CGI::Carp to echo the
fatal error message to the browser window as shown in the example
above.  Otherwise the remote user will see only a generic "Internal
Server" error message.  See the L<CGI::Carp> manual page for more
details.
d6283 2
a6284 3
To make it easier to port existing programs that use cgi-lib.pl
the compatibility routine "ReadParse" is provided.  Porting is
simple:
d6382 1
a6382 1
     
d6384 1
a6384 1
 
d6394 1
a6394 1
 
d6397 1
a6397 1
 
d6402 1
a6402 1
 
d6409 1
a6409 1
 
d6415 1
a6415 1
 
d6420 1
a6420 1
 
d6422 1
a6422 1
 
d6430 1
a6430 1
 
d6435 2
a6436 2
 
	   print "<P>",$query->Reset;
d6442 1
a6442 1
 
d6455 1
a6455 1
 
@


1.1
log
@perl 5.004_04
@
text
@d2 1
a2 1
require 5.001;
d11 1
a11 1
# Copyright 1995-1997 Lincoln D. Stein.  All rights reserved.
d18 1
a18 2
#   http://www.genome.wi.mit.edu/ftp/pub/software/WWW/cgi_docs.html
#   ftp://ftp-genome.wi.mit.edu/pub/software/WWW/
d20 2
a21 26
# Set this to 1 to enable copious autoloader debugging messages
$AUTOLOAD_DEBUG=0;

# Set this to 1 to enable NPH scripts
# or: 
#    1) use CGI qw(:nph)
#    2) $CGI::nph(1)
#    3) print header(-nph=>1)
$NPH=0;

# Set this to 1 to make the temporary files created
# during file uploads safe from prying eyes
# or do...
#    1) use CGI qw(:private_tempfiles)
#    2) $CGI::private_tempfiles(1);
$PRIVATE_TEMPFILES=0;

$CGI::revision = '$Id: CGI.pm,v 2.36 1997/5/10 8:22 lstein Exp $';
$CGI::VERSION='2.36';

# OVERRIDE THE OS HERE IF CGI.pm GUESSES WRONG
# $OS = 'UNIX';
# $OS = 'MACINTOSH';
# $OS = 'WINDOWS';
# $OS = 'VMS';
# $OS = 'OS2';
d27 50
d79 3
d95 1
a95 1
} elsif ($OS=~/Mac/i) {
d108 1
d115 1
a115 5
    UNIX=>'/',
    OS2=>'\\',
    WINDOWS=>'\\',
    MACINTOSH=>':',
    VMS=>'\\'
d118 1
d120 2
a121 1
$NPH++ if defined($ENV{'SERVER_SOFTWARE'}) && $ENV{'SERVER_SOFTWARE'}=~/IIS/;
d124 4
a127 2
if (defined($ENV{'GATEWAY_INTERFACE'}) && ($MOD_PERL = $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-Perl/)) {
    $NPH++;
d129 1
a129 1
    $SEQNO = 1;
d131 2
d134 14
a147 3
# This is really "\r\n", but the meaning of \n is different
# in MacPerl, so we resort to octal here.
$CRLF = "\015\012";
a154 3
# Cute feature, but it broke when the overload mechanism changed...
# %OVERLOAD = ('""'=>'as_string');

d156 25
a180 21
	      ':html2'=>[h1..h6,qw/p br hr ol ul li dl dt dd menu code var strong em
			 tt i b blockquote pre img a address cite samp dfn html head
			 base body link nextid title meta kbd start_html end_html
			 input Select option/],
	      ':html3'=>[qw/div table caption th td TR Tr super sub strike applet PARAM embed basefont style span/],
	      ':netscape'=>[qw/blink frameset frame script font fontsize center/],
	      ':form'=>[qw/textfield textarea filefield password_field hidden checkbox checkbox_group 
		       submit reset defaults radio_group popup_menu button autoEscape
		       scrolling_list image_button start_form end_form startform endform
		       start_multipart_form isindex tmpFileName uploadInfo URL_ENCODED MULTIPART/],
	      ':cgi'=>[qw/param path_info path_translated url self_url script_name cookie dump
		       raw_cookie request_method query_string accept user_agent remote_host 
		       remote_addr referer server_name server_software server_port server_protocol
		       virtual_host remote_ident auth_type http use_named_parameters
		       remote_user user_name header redirect import_names put/],
	      ':ssl' => [qw/https/],
	      ':cgi-lib' => [qw/ReadParse PrintHeader HtmlTop HtmlBot SplitParam/],
	      ':html' => [qw/:html2 :html3 :netscape/],
	      ':standard' => [qw/:html2 :form :cgi/],
	      ':all' => [qw/:html2 :html3 :netscape :form :cgi/]
	 );
d185 6
d192 1
a192 8
    foreach (@@_) {
	$NPH++, next if $_ eq ':nph';
	$PRIVATE_TEMPFILES++, next if $_ eq ':private_tempfiles';
	foreach (&expand_tags($_)) {
	    tr/a-zA-Z0-9_//cd;  # don't allow weird function names
	    $EXPORT{$_}++;
	}
    }
d209 5
d216 1
d233 5
a237 2
    $CGI::DefaultClass->_reset_globals() if $MOD_PERL;
    $initializer = to_filehandle($initializer) if $initializer;
d284 1
a284 1
    return () unless defined($name) && $self->{$name};
a287 11
#### Method: delete
# Deletes the named parameter entirely.
####
sub delete {
    my($self,$name) = self_or_default(@@_);
    delete $self->{$name};
    delete $self->{'.fieldnames'}->{$name};
    @@{$self->{'.parameters'}}=grep($_ ne $name,$self->param());
    return wantarray ? () : undef;
}

d289 1
a289 1
    return @@_ if defined($_[0]) && !ref($_[0]) && ($_[0] eq 'CGI');
d291 2
a292 5
	    ref($_[0]) &&
	    (ref($_[0]) eq 'CGI' ||
	     eval "\$_[0]->isaCGI()")) { # optimize for the common case
	$CGI::DefaultClass->_reset_globals() 
	    if defined($Q) && $MOD_PERL && $CGI::DefaultClass->_new_request();
a298 15
sub _new_request {
    return undef unless (defined(Apache->seqno()) or eval { require Apache });
    if (Apache->seqno() != $SEQNO) {
	$SEQNO = Apache->seqno();
	return 1;
    } else {
	return undef;
    }
}

sub _reset_globals {
    undef $Q;
    undef @@QUERY_PARAM;
}

d303 1
a303 1
	 || eval "\$_[0]->isaCGI()")) {
a309 37
sub isaCGI {
    return 1;
}

#### Method: import_names
# Import all parameters into the given namespace.
# Assumes namespace 'Q' if not specified
####
sub import_names {
    my($self,$namespace) = self_or_default(@@_);
    $namespace = 'Q' unless defined($namespace);
    die "Can't import names into 'main'\n"
	if $namespace eq 'main';
    my($param,@@value,$var);
    foreach $param ($self->param) {
	# protect against silly names
	($var = $param)=~tr/a-zA-Z0-9_/_/c;
	$var = "${namespace}::$var";
	@@value = $self->param($param);
	@@{$var} = @@value;
	${$var} = $value[0];
    }
}

#### Method: use_named_parameters
# Force CGI.pm to use named parameter-style method calls
# rather than positional parameters.  The same effect
# will happen automatically if the first parameter
# begins with a -.
sub use_named_parameters {
    my($self,$use_named) = self_or_default(@@_);
    return $self->{'.named'} unless defined ($use_named);

    # stupidity to avoid annoying warnings
    return $self->{'.named'}=$use_named;
}

d325 2
a326 2
    my($query_string,@@lines);
    my($meth) = '';
a331 1

d339 4
a343 2
    # If initializer is defined, then read parameters
    # from it.
d345 15
d361 4
a364 1

d372 2
a373 3
	  $initializer = $$initializer if ref($initializer);
	  if (defined(fileno($initializer))) {
	      while (<$initializer>) {
d386 3
d390 1
d393 3
a395 2
	  # If method is GET or HEAD, fetch the query from
	  # the environment.
d397 4
a400 6
	$query_string = $ENV{'QUERY_STRING'};
	last METHOD;
    }
	
      # If the method is POST, fetch the query from standard
      # input.
d402 2
a403 13

	  if (defined($ENV{'CONTENT_TYPE'}) 
	      && 
	      $ENV{'CONTENT_TYPE'}=~m|^multipart/form-data|) {
	      my($boundary) = $ENV{'CONTENT_TYPE'}=~/boundary=(\S+)/;
	      $self->read_multipart($boundary,$ENV{'CONTENT_LENGTH'});

	  } else {

	      $self->read_from_client(\*STDIN,\$query_string,$ENV{'CONTENT_LENGTH'},0)
		  if $ENV{'CONTENT_LENGTH'} > 0;

	  }
d407 1
a407 1
	  # $query_string .= ($query_string ? '&' : '') . $ENV{'QUERY_STRING'} if $ENV{'QUERY_STRING'};
d410 2
a411 2
	  
      # If neither is set, assume we're being debugged offline.
d415 1
a415 1
      $query_string = &read_from_cmdline;
d417 1
a417 1
    
d420 1
a420 1
    if ($query_string) {
a444 1

a446 1

a447 1

d450 10
a459 5
    my $string = shift;
    if ($string && !ref($string)) {
	my($package) = caller(1);
	my($tmp) = $string=~/[':]/ ? $string : "$package\:\:$string"; 
	return $tmp if defined(fileno($tmp));
d461 1
a461 19
    return $string;
}

# Create a new multipart buffer
sub new_MultipartBuffer {
    my($self,$boundary,$length,$filehandle) = @@_;
    return MultipartBuffer->new($self,$boundary,$length,$filehandle);
}

# Read data from a file handle
sub read_from_client {
    my($self, $fh, $buff, $len, $offset) = @@_;
    local $^W=0;                # prevent a warning
    return read($fh, $$buff, $len, $offset);
}

# put a filehandle into binary mode (DOS)
sub binmode {
    binmode($_[1]);
d478 3
a480 1
    my($todecode) = @@_;
d488 4
a491 2
    my($toencode) = @@_;
    $toencode=~s/([^a-zA-Z0-9_\-.])/uc sprintf("%%%02x",ord($1))/eg;
a505 8
sub parse_keywordlist {
    my($self,$tosplit) = @@_;
    $tosplit = &unescape($tosplit); # unescape the keywords
    $tosplit=~tr/+/ /;          # pluses to spaces
    my(@@keywords) = split(/\s+/,$tosplit);
    return @@keywords;
}

d508 1
a508 1
    my(@@pairs) = split('&',$tosplit);
d511 3
a513 3
	($param,$value) = split('=');
	$param = &unescape($param);
	$value = &unescape($value);
d532 34
a565 6
#### Method as_string
#
# synonym for "dump"
####
sub as_string {
    &dump(@@_);
d570 2
a571 30
    my($func) = $AUTOLOAD;
    my($pack,$func_name) = $func=~/(.+)::([^:]+)$/;
    $pack = ${"$pack\:\:AutoloadClass"} || $CGI::DefaultClass
                unless defined(${"$pack\:\:AUTOLOADED_ROUTINES"});

    my($sub) = \%{"$pack\:\:SUBS"};
    unless (%$sub) {
	my($auto) = \${"$pack\:\:AUTOLOADED_ROUTINES"};
	eval "package $pack; $$auto";
	die $@@ if $@@;
    }
    my($code) = $sub->{$func_name};

    $code = "sub $AUTOLOAD { }" if (!$code and $func_name eq 'DESTROY');
    if (!$code) {
	if ($EXPORT{':any'} || 
	    $EXPORT{$func_name} || 
	    (%EXPORT_OK || grep(++$EXPORT_OK{$_},&expand_tags(':html')))
	    && $EXPORT_OK{$func_name}) {
	    $code = $sub->{'HTML_FUNC'};
	    $code=~s/func_name/$func_name/mg;
	}
    }
    die "Undefined subroutine $AUTOLOAD\n" unless $code;
    eval "package $pack; $code";
    if ($@@) {
	$@@ =~ s/ at .*\n//;
	die $@@;
    }
    goto &{"$pack\:\:$func_name"};
a581 3
    
    return @@param unless (defined($param[0]) && substr($param[0],0,1) eq '-')
	|| $self->use_named_parameters;
d583 26
a608 4
    my $i;
    for ($i=0;$i<@@param;$i+=2) {
	$param[$i]=~s/^\-//;     # get rid of initial - if present
	$param[$i]=~tr/a-z/A-Z/; # parameters are upper case
d610 75
a684 18
    
    my(%param) = @@param;                # convert into associative array
    my(@@return_array);
    
    my($key)='';
    foreach $key (@@$order) {
	my($value);
	# this is an awful hack to fix spurious warnings when the
	# -w switch is set.
	if (ref($key) && ref($key) eq 'ARRAY') {
	    foreach (@@$key) {
		last if defined($value);
		$value = $param{$_};
		delete $param{$_};
	    }
	} else {
	    $value = $param{$key};
	    delete $param{$key};
a685 1
	push(@@return_array,$value);
d687 1
a687 2
    push (@@return_array,$self->make_attributes(\%param)) if %param;
    return (@@return_array);
d706 49
a754 2
'HTML_FUNC' => <<'END_OF_FUNC',
sub func_name { 
d756 16
a771 19
    # handle various cases in which we're called
    # most of this bizarre stuff is to avoid -w errors
    shift if $_[0] && 
	(!ref($_[0]) && $_[0] eq $CGI::DefaultClass) ||
	    (ref($_[0]) &&
	     (substr(ref($_[0]),0,3) eq 'CGI' ||
	      eval "\$_[0]->isaCGI()"));

    my($attr) = '';
    if (ref($_[0]) && ref($_[0]) eq 'HASH') {
	my(@@attr) = CGI::make_attributes('',shift);
	$attr = " @@attr" if @@attr;
    }
    my($tag,$untag) = ("\U<func_name\E$attr>","\U</func_name>\E");
    return $tag unless @@_;
    if (ref($_[0]) eq 'ARRAY') {
	my(@@r);
	foreach (@@{$_[0]}) {
	    push(@@r,"$tag$_$untag");
d773 10
a782 3
	return "@@r";
    } else {
	return "$tag@@_$untag";
d796 2
a797 2
    $self->{'keywords'}=[@@values] if @@values;
    my(@@result) = @@{$self->{'keywords'}};
d814 1
d861 1
a861 1
    return new CGI;
d937 14
d979 2
a980 2
	$key=~tr/a-z/A-Z/; # parameters are upper case
	push(@@att,$attr->{$_} ne '' ? qq/$key="$attr->{$_}"/ : qq/$key/);
d986 31
d1043 9
d1060 1
d1062 2
a1063 4
    my($package) = caller;
# Check that this still works!
#    $filehandle = $filehandle=~/[':]/ ? $filehandle : "$package\:\:$filehandle";
    $filehandle = to_filehandle($filehandle);
d1065 1
a1065 1
	my($escaped_param) = &escape($param);
d1076 77
d1162 2
d1165 2
a1166 1
	$self->rearrange([TYPE,STATUS,[COOKIE,COOKIES],TARGET,EXPIRES,NPH],@@p);
d1168 1
d1172 2
a1173 4
	next unless my($header,$value) = /([^\s=]+)=(.+)/;
	substr($header,1,1000)=~tr/A-Z/a-z/;
	($value)=$value=~/^"(.*)"$/;
	$_ = "$header: $value";
d1176 5
a1180 1
    $type = $type || 'text/html';
a1181 1
    push(@@header,'HTTP/1.0 ' . ($status || '200 OK')) if $nph || $NPH;
d1183 1
a1183 1
    push(@@header,"Window-target: $target") if $target;
d1186 1
a1186 1
	my(@@cookie) = ref($cookie) ? @@{$cookie} : $cookie;
d1188 2
a1189 1
	    push(@@header,"Set-cookie: $_");
d1195 1
a1195 1
    push(@@header,"Expires: " . &date(&expire_calc($expires),'http'))
d1197 1
a1197 1
    push(@@header,"Date: " . &date(&expire_calc(0),'http')) if $expires || $cookie;
d1200 1
a1200 1
    push(@@header,"Content-type: $type");
d1202 7
a1208 2
    my $header = join($CRLF,@@header);
    return $header . "${CRLF}${CRLF}";
d1236 1
a1236 1
    my($url,$target,$cookie,$nph,@@other) = $self->rearrange([[URI,URL],TARGET,COOKIE,NPH],@@p);
d1239 3
a1241 10
    foreach (@@other) { push(@@o,split("=")); }
    if($MOD_PERL or exists $self->{'.req'}) {
	my $r = $self->{'.req'} || Apache->request;
	$r->header_out(Location => $url);
	$r->err_header_out(Location => $url);
	$r->status(302);
	return;
    }
    push(@@o,
	 '-Status'=>'302 Found',
d1243 4
a1246 4
	 '-URI'=>$url,
	 '-nph'=>($nph||$NPH));
    push(@@o,'-Target'=>$target) if $target;
    push(@@o,'-Cookie'=>$cookie) if $cookie;
d1274 2
a1275 2
    my($title,$author,$base,$xbase,$script,$noscript,$target,$meta,$head,$style,@@other) = 
	$self->rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,META,HEAD,STYLE],@@p);
d1280 1
a1280 1
    $author = $self->escapeHTML($author);
d1282 2
a1283 1
    push(@@result,'<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">');
d1285 1
a1285 1
    push(@@result,"<LINK REV=MADE HREF=\"mailto:$author\">") if $author;
d1288 1
a1288 1
	my $href = $xbase || $self->url();
d1299 35
a1333 12
    # handle various types of -style parameters
    if ($style) {
	if (ref($style)) {
	    my($src,$code,@@other) =
		$self->rearrange([SRC,CODE],
				 '-foo'=>'bar',	# a trick to allow the '-' to be omitted
				 ref($style) eq 'ARRAY' ? @@$style : %$style);
	    push(@@result,qq/<LINK REL="stylesheet" HREF="$src">/) if $src;
	    push(@@result,style($code)) if $code;
	} else {
	    push(@@result,style($style))
	}
d1335 3
d1339 7
a1345 2
    # handle -script parameter
    if ($script) {
d1352 1
a1352 1
	
d1365 1
a1365 11

    # handle -noscript parameter
    push(@@result,<<END) if $noscript;
<NOSCRIPT>
$noscript
</NOSCRIPT>
END
    ;
    my($other) = @@other ? " @@other" : '';
    push(@@result,"</HEAD><BODY$other>");
    return join("\n",@@result);
a1368 1

d1433 5
d1477 21
d1511 1
a1511 12
    my($name,$default,$size,$maxlength,$override,@@other) = 
	$self->rearrange([NAME,[DEFAULT,VALUE],SIZE,MAXLENGTH,[OVERRIDE,FORCE]],@@p);

    my $current = $override ? $default : 
	(defined($self->param($name)) ? $self->param($name) : $default);

    $current = defined($current) ? $self->escapeHTML($current) : '';
    $name = defined($name) ? $self->escapeHTML($name) : '';
    my($s) = defined($size) ? qq/ SIZE=$size/ : '';
    my($m) = defined($maxlength) ? qq/ MAXLENGTH=$maxlength/ : '';
    my($other) = @@other ? " @@other" : '';    
    return qq/<INPUT TYPE="text" NAME="$name" VALUE="$current"$s$m$other>/;
d1527 1
a1527 13

    my($name,$default,$size,$maxlength,$override,@@other) = 
	$self->rearrange([NAME,[DEFAULT,VALUE],SIZE,MAXLENGTH,[OVERRIDE,FORCE]],@@p);

    $current = $override ? $default :
	(defined($self->param($name)) ? $self->param($name) : $default);

    $name = defined($name) ? $self->escapeHTML($name) : '';
    my($s) = defined($size) ? qq/ SIZE=$size/ : '';
    my($m) = defined($maxlength) ? qq/ MAXLENGTH=$maxlength/ : '';
    $current = defined($current) ? $self->escapeHTML($current) : '';
    $other = ' ' . join(" ",@@other);
    return qq/<INPUT TYPE="file" NAME="$name" VALUE="$current"$s$m$other>/;
d1546 1
a1546 13

    my($name,$default,$size,$maxlength,$override,@@other) = 
	$self->rearrange([NAME,[DEFAULT,VALUE],SIZE,MAXLENGTH,[OVERRIDE,FORCE]],@@p);

    my($current) =  $override ? $default :
	(defined($self->param($name)) ? $self->param($name) : $default);

    $name = defined($name) ? $self->escapeHTML($name) : '';
    $current = defined($current) ? $self->escapeHTML($current) : '';
    my($s) = defined($size) ? qq/ SIZE=$size/ : '';
    my($m) = defined($maxlength) ? qq/ MAXLENGTH=$maxlength/ : '';
    my($other) = @@other ? " @@other" : '';
    return qq/<INPUT TYPE="password" NAME="$name" VALUE="$current"$s$m$other>/;
a1549 1

d1632 2
a1633 2
    $name = qq/ NAME="$label"/ if $label;
    $value = $value || $label;
d1687 10
d1716 5
a1720 3
    if (!$override && defined($self->param($name))) {
	$value = $self->param($name) unless defined $value;
	$checked = $self->param($name) eq $value ? ' CHECKED' : '';
a1722 1
	$value = defined $value ? $value : 'on';
d1777 4
a1780 2
    my(@@elements);
    my(@@values) = $values ? @@$values : $self->param($name);
d1787 1
a1787 1
	    $label = $labels->{$_} if defined($labels) && $labels->{$_};
d1791 1
a1791 1
	push(@@elements,qq/<INPUT TYPE="checkbox" NAME="$name" VALUE="$_"$checked$other>${label} ${break}/);
d1794 2
a1795 1
    return wantarray ? @@elements : join('',@@elements) unless $columns;
a1799 1

d1804 1
d1806 2
a1807 1
    return $toencode if $self->{'dontescape'};
d1816 19
d1842 7
a1848 1
    $rows = int(0.99 + @@elements/$columns) unless $rows;
d1852 2
a1853 2
    unshift(@@$colheaders,'') if @@$colheaders && @@$rowheaders;
    $result .= "<TR>" if @@{$colheaders};
d1859 1
a1859 1
	$result .= "<TH>$rowheaders->[$row]</TH>" if @@$rowheaders;
d1861 2
a1862 1
	    $result .= "<TD>" . $elements[$column*$rows + $row] . "</TD>";
d1906 3
d1910 1
a1910 1
    $checked = $values->[0] unless $checked;
a1912 2
    my(@@elements);
    my(@@values) = $values ? @@$values : $self->param($name);
d1920 1
a1920 1
	    $label = $labels->{$_} if defined($labels) && $labels->{$_};
d1924 1
a1924 1
	push(@@elements,qq/<INPUT TYPE="radio" NAME="$name" VALUE="$_"$checkit$other>${label} ${break}/);
d1927 2
a1928 1
    return wantarray ? @@elements : join('',@@elements) unless $columns;
d1964 3
a1966 1
    my(@@values) = $values ? @@$values : $self->param($name);
d1971 1
a1971 1
	$label = $labels->{$_} if defined($labels) && $labels->{$_};
d2010 3
a2012 2
    my($result);
    my(@@values) = $values ? @@$values : $self->param($name);
d2025 1
a2025 1
	$label = $labels->{$_} if defined($labels) && $labels->{$_};
d2057 1
a2057 1
    if ( substr($p[0],0,1) eq '-' || $self->use_named_parameters ) {
d2111 2
a2112 10
    my($self) = self_or_default(@@_);
    my($query_string) = $self->query_string;
    my $protocol = $self->protocol();
    my $name = "$protocol://" . $self->server_name;
    $name .= ":" . $self->server_port
	unless $self->server_port == 80;
    $name .= $self->script_name;
    $name .= $self->path_info if $self->path_info;
    return $name unless $query_string;
    return "$name?$query_string";
d2132 28
a2159 7
    my($self) = self_or_default(@@_);
    my $protocol = $self->protocol();
    my $name = "$protocol://" . $self->server_name;
    $name .= ":" . $self->server_port
	unless $self->server_port == 80;
    $name .= $self->script_name;
    return $name;
a2176 1
# temporary, for debugging.
d2182 1
d2186 4
a2189 10
    # cookie in our state variables.
    unless (defined($value)) {
	unless ($self->{'.cookies'}) {
	    my(@@pairs) = split("; ",$self->raw_cookie);
	    foreach (@@pairs) {
		my($key,$value) = split("=");
		my(@@values) = map unescape($_),split('&',$value);
		$self->{'.cookies'}->{unescape($key)} = [@@values];
	    }
	}
d2193 15
a2207 27
	return wantarray ? @@{$self->{'.cookies'}->{$name}} : $self->{'.cookies'}->{$name}->[0]
	    if defined($name) && $name ne '';
	return keys %{$self->{'.cookies'}};
    }
    my(@@values);

    # Pull out our parameters.
    if (ref($value)) {
	if (ref($value) eq 'ARRAY') {
	    @@values = @@$value;
	} elsif (ref($value) eq 'HASH') {
	    @@values = %$value;
	}
    } else {
	@@values = ($value);
    }
    @@values = map escape($_),@@values;

    # I.E. requires the path to be present.
    ($path = $ENV{'SCRIPT_NAME'})=~s![^/]+$!! unless $path;

    my(@@constant_values);
    push(@@constant_values,"domain=$domain") if $domain;
    push(@@constant_values,"path=$path") if $path;
    push(@@constant_values,"expires=".&date(&expire_calc($expires),'cookie'))
	if $expires;
    push(@@constant_values,'secure') if $secure;
d2209 1
a2209 3
    my($key) = &escape($name);
    my($cookie) = join("=",$key,join("&",@@values));
    return join("; ",$cookie,@@constant_values);
a2212 1

d2215 1
a2215 1
# Fisher Mark.
d2237 1
a2237 1
    if (!$time || ($time eq 'now')) {
d2239 1
a2239 1
    } elsif ($time=~/^([+-]?\d+)([mhdMy]?)/) {
d2251 2
a2252 2
'date' => <<'END_OF_FUNC',
sub date {
d2254 2
d2260 2
a2261 3
    if ("$time" =~ m/^[^0-9]/o) {
        return $time;
    }
d2274 23
d2307 13
a2319 1
    return $ENV{'PATH_INFO'};
d2353 1
a2353 1
	my($eparam) = &escape($param);
d2355 1
a2355 1
	    $value = &escape($value);
d2359 1
a2359 1
    return join("&",@@pairs);
d2375 2
a2376 2
'accept' => <<'END_OF_FUNC',
sub accept {
d2425 7
a2431 4
#### Method: cookie
# Returns the magic cookie for the session.
# To set the magic cookie for new transations,
# try print $q->header('-Set-cookie'=>'my cookie')
d2435 12
a2446 1
    my($self) = self_or_CGI(@@_);
d2457 3
a2459 1
    return http('host') || server_name();
d2495 1
a2495 1
    return $ENV{'SCRIPT_NAME'} if $ENV{'SCRIPT_NAME'};
d2593 1
a2593 1
    return 'https' if $self->https() eq 'ON'; 
d2661 1
a2661 1
    $CGI::$PRIVATE_TEMPFILES = $param if defined($param);
d2666 11
d2707 3
a2709 3
    return $self->hidden('-name'=>'.cgifields',
			 '-values'=>[keys %{$self->{'.parametersToAdd'}}],
			 '-override'=>1);
a2714 1
    require "shellwords.pl";
d2718 1
a2718 1
	$input = join(" ",@@ARGV);
d2720 1
d2722 1
a2722 1
	chomp(@@lines = <>); # remove newlines
d2724 5
a2730 5
    # minimal handling of escape characters
    $input=~s/\\=/%3D/g;
    $input=~s/\\&/%26/g;
    
    @@words = &shellwords($input);
d2750 2
a2751 2
    my($self,$boundary,$length) = @@_;
    my($buffer) = $self->new_MultipartBuffer($boundary,$length);
d2754 1
d2759 4
a2762 8
	# In beta1 it was "Content-disposition".  In beta2 it's "Content-Disposition"
	# Sheesh.
	my($key) = $header{'Content-disposition'} ? 'Content-disposition' : 'Content-Disposition';
	my($param)= $header{$key}=~/ name="([^\"]*)"/;

	# possible bug: our regular expression expects the filename= part to fall
	# at the end of the line.  Netscape doesn't escape quotation marks in file names!!!
	my($filename) = $header{$key}=~/ filename="(.*)"$/;
d2775 11
a2785 18
	# If we get here, then we are dealing with a potentially large
	# uploaded form.  Save the data to a temporary file, then open
	# the file for reading.
	my($tmpfile) = new TempFile;
	my $tmp = $tmpfile->as_string;
	
	# Now create a new filehandle in the caller's namespace.
	# The name of this filehandle just happens to be identical
	# to the original filename (NOT the name of the temporary
	# file, which is hidden!)
	my($filehandle);
	if ($filename=~/^[a-zA-Z_]/) {
	    my($frame,$cp)=(1);
	    do { $cp = caller($frame++); } until !eval("'$cp'->isaCGI()");
	    $filehandle = "$cp\:\:$filename";
	} else {
	    $filehandle = "\:\:$filename";
	}
d2787 4
a2790 11
        # potential security problem -- this type of line can clobber 
	# tempfile, and can be abused by malicious users.
	# open ($filehandle,">$tmp") || die "CGI open of $tmpfile: $!\n";

	# This technique causes open to fail if file already exists.
	unless (defined(&O_RDWR)) {
	    require Fcntl;
	    import Fcntl qw/O_RDWR O_CREAT O_EXCL/;
	}
	sysopen($filehandle,$tmp,&O_RDWR|&O_CREAT|&O_EXCL) || die "CGI open of $tmp: $!\n";
	unlink($tmp) if $PRIVATE_TEMPFILES;
d2792 2
a2793 6
	$CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode;
	chmod 0600,$tmp;    # only the owner can tamper with it
	my $data;
	while (defined($data = $buffer->read)) {
	    print $filehandle $data;
	}
d2795 5
a2799 2
	seek($filehandle,0,0); #rewind file
	push(@@{$self->{$param}},$filename);
d2801 12
a2812 13
	# Under Unix, it would be safe to let the temporary file
	# be deleted immediately.  However, I fear that other operating
	# systems are not so forgiving.  Therefore we save a reference
	# to the temporary file in the CGI object so that the file
	# isn't unlinked until the CGI object itself goes out of
	# scope.  This is a bit hacky, but it has the interesting side
	# effect that one can access the name of the tmpfile by
	# asking for $query->{$query->param('foo')}, where 'foo'
	# is the name of the file upload field.
	$self->{'.tmpfiles'}->{$filename}= {
	    name=>($PRIVATE_TEMPFILES ? '' : $tmpfile),
	    info=>{%header}
	}
d2826 1
a2826 1
'uploadInfo' => <<'END_OF_FUNC'
d2833 22
d2859 69
a2927 1
# Globals and stubs for other packages that we use
d2931 4
a2934 4
# a 5K buffer by default.
$FILLUNIT = 1024 * 5;
$TIMEOUT = 10*60;       # 10 minute timeout
$SPIN_LOOP_MAX = 1000;  # bug fix for some Netscape servers
d2940 3
d2953 1
d2976 5
a2980 4
	$boundary = "--$boundary";
	# Read the topmost (boundary) line plus the CRLF
	my($null) = '';
	$length -= $interface->read_from_client($IN,\$null,length($boundary)+2,0);
d3000 7
a3006 1
    return bless $self,ref $package || $package;
d3016 5
d3026 2
a3027 1
	$FILLUNIT *= 2 if length($self->{BUFFER}) >= $FILLUNIT; 
d3034 12
a3045 2
    while ($header=~/^([\w-]+): (.*)$CRLF/mog) {
	$return{$1}=$2;
d3136 1
d3174 2
d3177 3
a3179 1
    @@TEMP=("${SL}usr${SL}tmp","${SL}var${SL}tmp","${SL}tmp","${SL}temp","${SL}Temporary Items");
d3185 3
a3187 2
$TMPDIRECTORY  = "." unless $TMPDIRECTORY;
$SEQUENCE="CGItemp${$}0000";
d3203 6
a3208 2
    $SEQUENCE++;
    my $directory = "${TMPDIRECTORY}${SL}${SEQUENCE}";
d3242 1
a3242 1
    $MultipartBuffer::FILLUNIT;
d3248 1
a3248 1
$revision;
d3258 26
a3283 2
  use CGI;
  # the rest is too complicated for a synopsis; keep reading
d3287 14
a3300 8
This perl library uses perl5 objects to make it easy to create
Web fill-out forms and parse their contents.  This package
defines CGI objects, entities that contain the values of the
current query string and other state variables.
Using a CGI object's methods, you can examine keywords and parameters
passed to your script, and create forms whose initial values
are taken from the current query (thereby preserving state
information).
d3307 3
a3309 1
=head1 INSTALLATION
d3311 56
a3366 2
CGI is a part of the base Perl installation.  However, you may need
to install a newer version someday.  Therefore:
d3368 4
a3371 2
To install this package, just change to the directory in which this
file is found and type the following:
d3373 5
a3377 3
	perl Makefile.PL
	make
	make install
d3379 54
a3432 3
This will copy CGI.pm to your perl library directory for use by all
perl scripts.  You probably must be root to do this.   Now you can
load the CGI routines in your Perl scripts with the line:
d3434 1
a3434 1
	use CGI;
d3436 2
a3437 5
If you don't have sufficient privileges to install CGI.pm in the Perl
library directory, you can put CGI.pm into some convenient spot, such
as your home directory, or in cgi-bin itself and prefix all Perl
scripts that call it with something along the lines of the following
preamble:
d3439 1
a3439 2
	use lib '/home/davis/lib';
	use CGI;
d3441 1
a3441 2
If you are using a version of perl earlier than 5.002 (such as NT perl), use
this instead:
d3443 1
a3443 4
	BEGIN {
		unshift(@@INC,'/home/davis/lib');
	}
	use CGI;
d3445 20
a3464 8
The CGI distribution also comes with a cute module called L<CGI::Carp>.
It redefines the die(), warn(), confess() and croak() error routines
so that they write nicely formatted error messages into the server's
error log (or to the output stream of your choice).  This avoids long
hours of groping through the error and access logs, trying to figure
out which CGI script is generating  error messages.  If you choose,
you can even have fatal error messages echoed to the browser to avoid
the annoying and uninformative "Server Error" message.
d3466 2
a3467 1
=head1 DESCRIPTION
d3469 1
a3469 1
=head2 CREATING A NEW QUERY OBJECT:
d3480 6
a3485 6
If you provide a file handle to the new() method, it
will read parameters from the file (or STDIN, or whatever).  The
file can be in any of the forms describing below under debugging
(i.e. a series of newline delimited TAG=VALUE pairs will work).
Conveniently, this type of file is created by the save() method
(see below).  Multiple records can be saved and restored.
d3493 12
d3517 7
d3526 5
a3530 3
	$empty_query = new CGI("");
	     -or-
	$empty_query = new CGI({});
d3589 1
a3589 1
   $query->append(-name=>;'foo',-values=>['yet','more','values']);
d3618 3
d3623 1
a3623 1
$query->delete_all();
d3628 16
a3643 1
=head2 SAVING THE STATE OF THE FORM TO A FILE:
d3694 208
a3901 1
=head2 CREATING A SELF-REFERENCING URL THAT PRESERVES STATE INFORMATION:
d3903 4
a3906 2
    $myself = $query->self_url;
    print "<A HREF=$myself>I'm talking to myself.</A>";
d3908 1
a3908 5
self_url() will return a URL, that, when selected, will reinvoke
this script with all its state information intact.  This is most
useful when you want to jump around within the document using
internal anchors but you don't want to disrupt the current contents
of the form(s).  Something like this will do the trick.
d3910 9
a3918 4
     $myself = $query->self_url;
     print "<A HREF=$myself#table1>See table 1</A>";
     print "<A HREF=$myself#table2>See table 2</A>";
     print "<A HREF=$myself#yourself>See for yourself</A>";
d3920 1
a3920 2
If you don't want to get the whole query string, call
the method url() to return just the URL for the script:
d3922 1
a3922 2
    $myself = $query->url;
    print "<A HREF=$myself>No query string in this baby!</A>\n";
d3924 3
a3926 1
You can also retrieve the unprocessed query string with query_string():
d3928 1
a3928 1
    $the_string = $query->query_string;
d3930 1
a3930 1
=head2 COMPATIBILITY WITH CGI-LIB.PL
d3932 1
a3932 3
To make it easier to port existing programs that use cgi-lib.pl
the compatibility routine "ReadParse" is provided.  Porting is
simple:
d3934 3
a3936 4
OLD VERSION
    require "cgi-lib.pl";
    &ReadParse;
    print "The value of the antique is $in{antique}.\n";
d3938 1
a3938 4
NEW VERSION
    use CGI;
    CGI::ReadParse
    print "The value of the antique is $in{antique}.\n";
d3940 6
a3945 5
CGI.pm's ReadParse() routine creates a tied variable named %in,
which can be accessed to obtain the query variables.  Like
ReadParse, you can also provide your own variable.  Infrequently
used features of ReadParse, such as the creation of @@in and $in 
variables, are not supported.
d3947 1
a3947 2
Once you use ReadParse, you can retrieve the query object itself
this way:
d3949 1
a3949 3
    $q = $in{CGI};
    print $q->textfield(-name=>'wow',
			-value=>'does this really work?');
d3951 2
a3952 2
This allows you to start using the more interesting features
of CGI.pm without rewriting your old scripts from scratch.
d3954 1
a3954 1
=head2 CALLING CGI FUNCTIONS THAT TAKE MULTIPLE ARGUMENTS
d3956 1
a3956 22
In versions of CGI.pm prior to 2.0, it could get difficult to remember
the proper order of arguments in CGI function calls that accepted five
or six different arguments.  As of 2.0, there's a better way to pass
arguments to the various CGI functions.  In this style, you pass a
series of name=>argument pairs, like this:

   $field = $query->radio_group(-name=>'OS',
				-values=>[Unix,Windows,Macintosh],
				-default=>'Unix');

The advantages of this style are that you don't have to remember the
exact order of the arguments, and if you leave out a parameter, in
most cases it will default to some reasonable value.  If you provide
a parameter that the method doesn't recognize, it will usually do
something useful with it, such as incorporating it into the HTML form
tag.  For example if Netscape decides next week to add a new
JUSTIFICATION parameter to the text field tags, you can start using
the feature without waiting for a new version of CGI.pm:

   $field = $query->textfield(-name=>'State',
			      -default=>'gaseous',
			      -justification=>'RIGHT');
d3958 1
a3958 1
This will result in an HTML tag that looks like this:
d3960 1
a3960 2
	<INPUT TYPE="textfield" NAME="State" VALUE="gaseous"
	       JUSTIFICATION="RIGHT">
d3962 1
a3962 5
Parameter names are case insensitive: you can use -name, or -Name or
-NAME.  You don't have to use the hyphen if you don't want to.  After
creating a CGI object, call the B<use_named_parameters()> method with
a nonzero value.  This will tell CGI.pm that you intend to use named
parameters exclusively:
d3964 1
a3964 5
   $query = new CGI;
   $query->use_named_parameters(1);
   $field = $query->radio_group('name'=>'OS',
				'values'=>['Unix','Windows','Macintosh'],
				'default'=>'Unix');
d3966 1
a3966 7
Actually, CGI.pm only looks for a hyphen in the first parameter.  So
you can leave it off subsequent parameters if you like.  Something to
be wary of is the potential that a string constant like "values" will
collide with a keyword (and in fact it does!) While Perl usually
figures out when you're referring to a function and when you're
referring to a string, you probably should put quotation marks around
all string constants just to play it safe.
d3968 18
a3985 1
=head2 CREATING THE HTTP HEADER:
d4010 1
a4010 4
script that tells the browser to do nothing at all.  If you want to
add additional fields to the header, just tack them on to the end:

    print $query->header('text/html','200 OK','Content-Length: 3002');
d4014 1
a4014 1
B<-type>, B<-status>, B<-expires>, and B<-cookie>.  Any other 
d4017 3
d4036 1
a4036 5
	Thursday, 25-Apr-96 00:40:33 GMT  at the indicated time & date

(CGI::expires() is the static function call used internally that turns
relative time intervals into HTTP dates.  You can call it directly if
you wish.)
d4049 1
a4049 1
=head2 GENERATING A REDIRECTION INSTRUCTION
d4053 9
a4061 4
redirects the browser elsewhere.  If you use redirection like this,
you should B<not> print out a header as well.  As of version 2.0, we
produce both the unofficial Location: header and the official URI:
header.  This should satisfy most servers and browsers.
d4069 1
a4069 1
You can use named parameters:
d4079 1
a4079 2

=head2 CREATING THE HTML HEADER:
d4090 11
a4100 11
   -or-

   print $query->start_html('Secrets of the Pyramids',
			    'fred@@capricorn.org','true',
			    'BGCOLOR="blue"');

This will return a canned HTML header and the opening <BODY> tag.  
All parameters are optional.   In the named parameter form, recognized
parameters are -title, -author, -base, -xbase and -target (see below for the
explanation).  Any additional parameters you provide, such as the
Netscape unofficial BGCOLOR attribute, are added to the <BODY> tag.
d4121 298
a4418 2
    <META NAME="keywords" CONTENT="pharaoh secret mummy">
    <META NAME="description" CONTENT="copyright 1996 King Tut">
d4420 2
a4421 4
There is no support for the HTTP-EQUIV type of <META> tag.  This is
because you can modify the HTTP header directly with the B<header()>
method.  For example, if you want to send the Refresh: header, do it
in the header() method:
d4423 1
a4423 1
    print $q->header(-Refresh=>'10; URL=http://www.capricorn.com');
d4425 2
a4426 2
The B<-style> tag is used to incorporate cascading stylesheets into
your code.  See the section on CASCADING STYLESHEETS for more information.
d4428 2
a4429 3
You can place other arbitrary HTML elements to the <HEAD> section with the
B<-head> tag.  For example, to place the rarely-used <LINK> element in the
head section, use this:
d4431 4
a4434 2
    print $q->header(-head=>link({-rel=>'next',
				  -href=>'http://www.capricorn.com/s2.html'}));
d4436 1
a4436 2
To incorporate multiple HTML elements into the <HEAD> section, just pass an
array reference:
d4438 1
a4438 6
    print $q->header(-head=>[ link({-rel=>'next',
				    -href=>'http://www.capricorn.com/s2.html'}),
			      link({-rel=>'previous',
				    -href=>'http://www.capricorn.com/s1.html'})
			     ]
		     );
d4440 3
d4444 1
a4444 11
JAVASCRIPTING: The B<-script>, B<-noScript>, B<-onLoad> and B<-onUnload> parameters
are used to add Netscape JavaScript calls to your pages.  B<-script>
should point to a block of text containing JavaScript function
definitions.  This block will be placed within a <SCRIPT> block inside
the HTML (not HTTP) header.  The block is placed in the header in
order to give your page a fighting chance of having all its JavaScript
functions in place even if the user presses the stop button before the
page has loaded completely.  CGI.pm attempts to format the script in
such a way that JavaScript-naive browsers will not choke on the code:
unfortunately there are some browsers, such as Chimera for Unix, that
get confused by it nevertheless.
d4446 8
a4453 4
The B<-onLoad> and B<-onUnload> parameters point to fragments of JavaScript
code to execute when the page is respectively opened and closed by the
browser.  Usually these parameters are calls to functions defined in the
B<-script> field:
d4455 1
a4455 20
      $query = new CGI;
      print $query->header;
      $JSCRIPT=<<END;
      // Ask a silly question
      function riddle_me_this() {
	 var r = prompt("What walks on four legs in the morning, " +
		       "two legs in the afternoon, " +
		       "and three legs in the evening?");
	 response(r);
      }
      // Get a silly answer
      function response(answer) {
	 if (answer == "man")
	    alert("Right you are!");
	 else
	    alert("Wrong!  Guess again.");
      }
      END
      print $query->start_html(-title=>'The Riddle of the Sphinx',
			       -script=>$JSCRIPT);
d4457 5
a4461 3
Use the B<-noScript> parameter to pass some HTML text that will be displayed on 
browsers that do not have JavaScript (or browsers where JavaScript is turned
off).
d4463 3
a4465 6
Netscape 3.0 recognizes several attributes of the <SCRIPT> tag,
including LANGUAGE and SRC.  The latter is particularly interesting,
as it allows you to keep the JavaScript code in a file or CGI script
rather than cluttering up each page with the source.  To use these
attributes pass a HASH reference in the B<-script> parameter containing
one or more of -language, -src, or -code:
d4467 1
a4467 4
    print $q->start_html(-title=>'The Riddle of the Sphinx',
			 -script=>{-language=>'JAVASCRIPT',
                                   -src=>'/javascript/sphinx.js'}
			 );
d4469 6
a4474 4
    print $q->(-title=>'The Riddle of the Sphinx',
	       -script=>{-language=>'PERLSCRIPT'},
			 -code=>'print "hello world!\n;"'
	       );
d4476 1
d4478 11
a4488 1
See
d4490 1
a4490 1
   http://home.netscape.com/eng/mozilla/2.0/handbook/javascript/
d4492 1
a4492 1
for more information about JavaScript.
d4494 1
a4494 1
The old-style positional parameters are as follows:
d4496 1
a4496 1
=over 4
d4498 1
a4498 1
=item B<Parameters:>
d4500 6
a4505 1
=item 1.
d4507 4
a4510 1
The title
d4512 3
a4514 1
=item 2.
d4516 1
a4516 1
The author's e-mail address (will create a <LINK REV="MADE"> tag if present
d4518 2
a4519 1
=item 3.
d4521 2
a4522 3
A 'true' flag if you want to include a <BASE> tag in the header.  This
helps resolve relative addresses to absolute ones when the document is moved, 
but makes the document hierarchy non-portable.  Use with care!
d4524 1
a4524 1
=item 4, 5, 6...
d4526 2
a4527 2
Any other parameters you want to include in the <BODY> tag.  This is a good
place to put Netscape extensions, such as colors and wallpaper patterns.
d4529 6
a4534 1
=back
d4536 3
a4538 1
=head2 ENDING THE HTML DOCUMENT:
d4540 1
a4540 1
	print $query->end_html
d4542 5
a4546 1
This ends an HTML document by printing the </BODY></HTML> tags.
d4548 1
a4548 1
=head1 CREATING FORMS
d4602 1
a4602 1
			    -encoding=>$encoding);
d4617 1
a4617 1
    encoding: application/x-www-form-urlencoded
d4621 1
a4621 1
Startform()'s encoding method tells the browser how to package the various
d4642 1
a4642 1
in B<$CGI::MULTIPART>
d4728 8
a4735 7
JAVASCRIPTING: You can also provide B<-onChange>, B<-onFocus>, B<-onBlur>
and B<-onSelect> parameters to register JavaScript event handlers.
The onChange handler will be called whenever the user changes the
contents of the text field.  You can do text validation if you like.
onFocus and onBlur are called respectively when the insertion point
moves into and out of the text field.  onSelect is called when the
user changes the portion of the text that is selected.
d4753 3
a4755 2
JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur>
and B<-onSelect> parameters are recognized.  See textfield().
d4770 3
a4772 2
JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur>
and B<-onSelect> parameters are recognized.  See textfield().
d4804 5
a4808 6
The beta2 version of Netscape 2.0 currently doesn't pay any attention
to this field, and so the starting value will always be blank.  Worse,
the field loses its "sticky" behavior and forgets its previous
contents.  The starting value field is called for in the HTML
specification, however, and possibly later versions of Netscape will
honor it.
d4827 3
a4829 3
In Netscape Gold, the filename that gets returned is the full local filename
on the B<remote user's> machine.  If the remote user is on a Unix
machine, the filename will follow Unix conventions:
d4872 3
a4874 3
JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur>
and B<-onSelect> parameters are recognized.  See textfield()
for details. 
d4936 3
a4938 2
B<-onChange>, B<-onFocus>, and B<-onBlur>.  See the textfield()
section for details on when these handlers are called.
d5006 4
a5009 3
JAVASCRIPTING: scrolling_list() recognizes the following event handlers:
B<-onChange>, B<-onFocus>, and B<-onBlur>.  See textfield() for
the description of when these handlers are called.
d5067 6
a5072 8
B<HTML3-compatible browsers> (such as Netscape) can take advantage 
of the optional 
parameters B<-rows>, and B<-columns>.  These parameters cause
checkbox_group() to return an HTML3 compatible table containing
the checkbox group formatted with the specified number of rows
and columns.  You can provide just the -columns parameter if you
wish; checkbox_group will calculate the correct number of rows
for you.
d5075 1
a5075 1
can use the B<-rowheader> and B<-colheader> parameters.  Both
d5225 1
a5225 1
interpetation of the radio buttons -- they're still a single named
d5289 3
d5398 1
a5398 1
=head1 NETSCAPE COOKIES
d5400 4
a5403 3
Netscape browsers versions 1.1 and higher support a so-called
"cookie" designed to help maintain state within a browser session.
CGI.pm has several methods that support cookies.
d5421 2
a5422 2
Netscape and restarts it.  If an expiration date isn't specified, the cookie
will remain active until the user quits Netscape.
d5429 1
a5429 1
of ".capricorn.com", then Netscape will return the cookie to
d5454 1
a5454 1
The interface to Netscape cookies is the B<cookie()> method:
d5471 1
a5471 1
Although Netscape limits its cookie names to non-whitespace
d5542 5
a5546 13
B<NOTE:> There appear to be some (undocumented) restrictions on
Netscape cookies.  In Netscape 2.01, at least, I haven't been able to
set more than three cookies at a time.  There may also be limits on
the length of cookies.  If you need to store a lot of information,
it's probably better to create a unique session ID, store it in a
cookie, and use the session ID to locate an external file/database
saved on the server's side of the connection.

=head1 WORKING WITH NETSCAPE FRAMES

It's possible for CGI.pm scripts to write into several browser
panels and windows using Netscape's frame mechanism.  
There are three techniques for defining new frames programmatically:
d5569 6
a5574 6
This will tell Netscape to load the output of your script into the
frame named "ResultsWindow".  If a frame of that name doesn't
already exist, Netscape will pop up a new window and load your
script's document into that.  There are a number of magic names
that you can use for targets.  See the frame documents on Netscape's
home pages for details.
d5606 4
d5719 2
a5720 7
You can pass a value of 'true' to dump() in order to get it to
print the results out as plain text, suitable for incorporating
into a <PRE> section.

As a shortcut, as of version 1.56 you can interpolate the entire CGI
object into a string and it will be replaced with the a nice HTML dump
shown above:
d5732 1
a5732 1
=item B<accept()>
d5734 9
a5742 8
Return a list of MIME types that the remote browser
accepts. If you give this method a single argument
corresponding to a MIME type, as in
$query->accept('text/html'), it will return a
floating point value corresponding to the browser's
preference for this type from 0.0 (don't want) to 1.0.
Glob types (e.g. text/*) in the browser's accept list
are handled correctly.
d5746 12
a5757 6
Returns the HTTP_COOKIE variable, an HTTP extension
implemented by Netscape browsers version 1.1
and higher.  Cookies have a special format, and this 
method call just returns the raw form (?cookie dough).
See cookie() for ways of setting and retrieving
cooked cookies.
d5832 3
a5834 4
Attempt to obtain the remote user's name, using a variety
of different techniques.  This only works with older browsers
such as Mosaic.  Netscape does not reliably report the user
name!
d5843 1
a5843 1
=head1 CREATING HTML ELEMENTS
d5845 5
a5849 4
In addition to its shortcuts for creating form elements, CGI.pm
defines general HTML shortcut methods as well.  HTML shortcuts are
named after a single HTML element and return a fragment of HTML text
that you can then print or manipulate as you like.
d5851 5
a5855 1
This example shows how to use the HTML methods:
a5856 8
	$q = new CGI;
	print $q->blockquote(
			     "Many years ago on the island of",
			     $q->a({href=>"http://crete.org/"},"Crete"),
			     "there lived a minotaur named",
			     $q->strong("Fred."),
			    ),
	       $q->hr;
d5858 4
a5861 2
This results in the following HTML code (extra newlines have been
added for readability):
d5863 4
a5866 6
	<blockquote>
	Many years ago on the island of
	<a HREF="http://crete.org/">Crete</a> there lived
	a minotaur named <strong>Fred.</strong> 
	</blockquote>
	<hr>
d5868 1
a5868 3
If you find the syntax for calling the HTML shortcuts awkward, you can
import them into your namespace and dispense with the object syntax
completely (see the next section for more details):
d5870 1
a5870 10
	use CGI shortcuts;      # IMPORT HTML SHORTCUTS
	print blockquote(
		     "Many years ago on the island of",
		     a({href=>"http://crete.org/"},"Crete"),
		     "there lived a minotaur named",
		     strong("Fred."),
		     ),
	       hr;

=head2 PROVIDING ARGUMENTS TO HTML SHORTCUTS
d5872 1
a5872 2
The HTML methods will accept zero, one or multiple arguments.  If you
provide no arguments, you get a single tag:
d5874 2
a5875 2
	print hr;  
	#  gives "<hr>"
d5877 1
a5877 2
If you provide one or more string arguments, they are concatenated
together with spaces and placed between opening and closing tags:
d5879 1
a5879 2
	print h1("Chapter","1"); 
	# gives "<h1>Chapter 1</h1>"
d5881 1
a5881 2
If the first argument is an associative array reference, then the keys
and values of the associative array become the HTML tag's attributes:
d5883 1
a5883 3
	print a({href=>'fred.html',target=>'_new'},
		"Open a new frame");
	# gives <a href="fred.html",target="_new">Open a new frame</a>
d5885 1
a5885 2
You are free to use CGI.pm-style dashes in front of the attribute
names if you prefer:
d5887 1
a5887 2
	print img {-src=>'fred.gif',-align=>'LEFT'};
	# gives <img ALIGN="LEFT" SRC="fred.gif">
d5889 1
a5889 1
=head2 Generating new HTML tags
d5891 1
a5891 4
Since no mere mortal can keep up with Netscape and Microsoft as they
battle it out for control of HTML, the code that generates HTML tags
is general and extensible.  You can create new HTML tags freely just
by referring to them on the import line:
d5893 19
a5911 1
	use CGI shortcuts,winkin,blinkin,nod;
d5913 5
a5917 2
Now, in addition to the standard CGI shortcuts, you've created HTML
tags named "winkin", "blinkin" and "nod".  You can use them like this:
d5919 1
a5919 2
	print blinkin {color=>'blue',rate=>'fast'},"Yahoo!";
	# <blinkin COLOR="blue" RATE="fast">Yahoo!</blinkin>
d5921 3
a5923 6
=head1 IMPORTING CGI METHOD CALLS INTO YOUR NAME SPACE

As a convenience, you can import most of the CGI method calls directly
into your name space.  The syntax for doing this is:

	use CGI <list of methods>;
d5925 3
a5927 4
The listed methods will be imported into the current package; you can
call them directly without creating a CGI object first.  This example
shows how to import the B<param()> and B<header()>
methods, and then use them directly:
d5929 1
a5929 3
	use CGI param,header;
	print header('text/plain');
	$zipcode = param('zipcode');
d5931 1
a5931 2
You can import groups of methods by referring to a number of special
names:
d5933 2
a5934 1
=over 4
d5936 1
a5936 1
=item B<cgi>
d5938 1
a5938 2
Import all CGI-handling methods, such as B<param()>, B<path_info()>
and the like.
d5940 2
a5941 1
=item B<form>
d5943 1
a5943 1
Import all fill-out form generating methods, such as B<textfield()>.
d5945 2
a5946 1
=item B<html2>
d5948 1
a5948 1
Import all methods that generate HTML 2.0 standard elements.
d5950 25
a5974 1
=item B<html3>
d5976 1
a5976 6
Import all methods that generate HTML 3.0 proposed elements (such as
<table>, <super> and <sub>).

=item B<netscape>

Import all methods that generate Netscape-specific HTML extensions.
d5978 1
a5978 1
=item B<shortcuts>
d5980 7
a5986 6
Import all HTML-generating shortcuts (i.e. 'html2' + 'html3' +
'netscape')...

=item B<standard>

Import "standard" features, 'html2', 'form' and 'cgi'.
d5988 1
a5988 1
=item B<all>
d5990 2
a5991 2
Import all the available methods.  For the full list, see the CGI.pm
code, where the variable %TAGS is defined.
d5995 1
a5995 3
Note that in the interests of execution speed CGI.pm does B<not> use
the standard L<Exporter> syntax for specifying load symbols.  This may
change in the future.
d5997 1
a5997 25
If you import any of the state-maintaining CGI or form-generating
methods, a default CGI object will be created and initialized
automatically the first time you use any of the methods that require
one to be present.  This includes B<param()>, B<textfield()>,
B<submit()> and the like.  (If you need direct access to the CGI
object, you can find it in the global variable B<$CGI::Q>).  By
importing CGI.pm methods, you can create visually elegant scripts:

   use CGI standard,html2;
   print 
       header,
       start_html('Simple Script'),
       h1('Simple Script'),
       start_form,
       "What's your name? ",textfield('name'),p,
       "What's the combination?",
       checkbox_group(-name=>'words',
		      -values=>['eenie','meenie','minie','moe'],
		      -defaults=>['eenie','moe']),p,
       "What's your favorite color?",
       popup_menu(-name=>'color',
		  -values=>['red','green','blue','chartreuse']),p,
       submit,
       end_form,
       hr,"\n";
d5999 1
a5999 7
    if (param) {
       print 
	   "Your name is ",em(param('name')),p,
	   "The keywords are: ",em(join(", ",param('words'))),p,
	   "Your favorite color is ",em(param('color')),".\n";
    }
    print end_html;
d6001 1
a6001 1
=head1 USING NPH SCRIPTS
d6003 4
a6006 5
NPH, or "no-parsed-header", scripts bypass the server completely by
sending the complete HTTP header directly to the browser.  This has
slight performance benefits, but is of most use for taking advantage
of HTTP extensions that are not directly supported by your server,
such as server push and PICS headers.
d6008 1
a6008 5
Servers use a variety of conventions for designating CGI scripts as
NPH.  Many Unix servers look at the beginning of the script's name for
the prefix "nph-".  The Macintosh WebSTAR server and Microsoft's
Internet Information Server, in contrast, try to decide whether a
program is an NPH script by examining the first line of script output.
d6010 4
d6015 1
a6015 4
CGI.pm supports NPH scripts with a special NPH mode.  When in this
mode, CGI.pm will output the necessary extra header information when
the header() and redirect() methods are
called.
d6017 6
a6022 4
The Microsoft Internet Information Server requires NPH mode.  As of version
2.30, CGI.pm will automatically detect when the script is running under IIS
and put itself into this mode.  You do not need to do this manually, although
it won't hurt anything if you do.
d6024 1
a6024 1
There are a number of ways to put CGI.pm into NPH mode:
d6026 3
a6028 1
=over 4
d6030 4
a6033 2
=item In the B<use> statement
Simply add ":nph" to the list of symbols to be imported into your script:
d6035 4
a6038 1
      use CGI qw(:standard :nph)
d6040 5
a6044 1
=item By calling the B<nph()> method:
d6046 2
a6047 1
Call B<nph()> with a non-zero parameter at any point after using CGI.pm in your program.
d6049 3
a6051 1
      CGI->nph(1)
d6053 2
a6054 1
=item By using B<-nph> parameters in the B<header()> and B<redirect()>  statements:
d6056 1
a6056 3
      print $q->header(-nph=&gt;1);

=back
d6058 1
a6058 1
=head1 AUTHOR INFORMATION
d6060 2
a6061 5
Copyright 1995,1996, Lincoln D. Stein.  All rights reserved.  It may
be used and modified freely, but I do request that this copyright
notice remain attached to the file.  You may modify this module as you
wish, but if you redistribute a modified version, please attach a note
listing the modifications you have made.
d6063 6
a6068 2
Address bug reports and comments to:
lstein@@genome.wi.mit.edu
d6088 1
a6088 1
=item Laurent Delfosse (delfosse@@csgrad1.cs.wvu.edu)
d6112 4
d6180 1
a6180 1
	   print "<P>",$query->reset;
d6221 2
a6222 2
L<CGI::Base>, L<CGI::Form>, L<CGI::Apache>, L<CGI::Switch>,
L<CGI::Push>, L<CGI::Fast>
@


1.1.1.1
log
@perl5.005_03
@
text
@d2 1
a2 1
require 5.004;
d11 1
a11 1
# Copyright 1995-1998 Lincoln D. Stein.  All rights reserved.
d18 2
a19 1
#   http://stein.cshl.org/WWW/software/CGI/
d21 26
a46 2
$CGI::revision = '$Id: CGI.pm,v 1.5 1998/12/06 10:19:48 lstein Exp $';
$CGI::VERSION='2.46';
a51 50
# >>>>> Here are some globals that you might want to adjust <<<<<<
sub initialize_globals {
    # Set this to 1 to enable copious autoloader debugging messages
    $AUTOLOAD_DEBUG = 0;

    # Change this to the preferred DTD to print in start_html()
    # or use default_dtd('text of DTD to use');
    $DEFAULT_DTD = '-//IETF//DTD HTML//EN';

    # Set this to 1 to enable NPH scripts
    # or: 
    #    1) use CGI qw(-nph)
    #    2) $CGI::nph(1)
    #    3) print header(-nph=>1)
    $NPH = 0;

    # Set this to 1 to disable debugging from the
    # command line
    $NO_DEBUG = 0;

    # Set this to 1 to make the temporary files created
    # during file uploads safe from prying eyes
    # or do...
    #    1) use CGI qw(:private_tempfiles)
    #    2) $CGI::private_tempfiles(1);
    $PRIVATE_TEMPFILES = 0;

    # Set this to a positive value to limit the size of a POSTing
    # to a certain number of bytes:
    $POST_MAX = -1;

    # Change this to 1 to disable uploads entirely:
    $DISABLE_UPLOADS = 0;

    # Change this to 1 to suppress redundant HTTP headers
    $HEADERS_ONCE = 0;

    # separate the name=value pairs by semicolons rather than ampersands
    $USE_PARAM_SEMICOLONS = 0;

    # Other globals that you shouldn't worry about.
    undef $Q;
    $BEEN_THERE = 0;
    undef @@QUERY_PARAM;
    undef %EXPORT;

    # prevent complaints by mod_perl
    1;
}

a53 3
# make mod_perlhappy
initialize_globals();

d67 1
a67 1
} elsif ($OS=~/^MacOS$/i) {
a79 1

d86 5
a90 1
    UNIX=>'/', OS2=>'\\', WINDOWS=>'\\', MACINTOSH=>':', VMS=>'/'
a92 1
# This no longer seems to be necessary
d94 1
a94 2
# $NPH++ if defined($ENV{'SERVER_SOFTWARE'}) && $ENV{'SERVER_SOFTWARE'}=~/IIS/;
$IIS++ if defined($ENV{'SERVER_SOFTWARE'}) && $ENV{'SERVER_SOFTWARE'}=~/IIS/;
d97 2
a98 4
if (exists $ENV{'GATEWAY_INTERFACE'} 
    && 
    ($MOD_PERL = $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-Perl/))
{
d100 1
a100 1
    require Apache;
a101 2
# Turn on special checking for ActiveState's PerlEx
$PERLEX++ if defined($ENV{'GATEWAY_INTERFACE'}) && $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-PerlEx/;
d103 3
a105 14
# Define the CRLF sequence.  I can't use a simple "\r\n" because the meaning
# of "\n" is different on different OS's (sometimes it generates CRLF, sometimes LF
# and sometimes CR).  The most popular VMS web server
# doesn't accept CRLF -- instead it wants a LR.  EBCDIC machines don't
# use ASCII, so \015\012 means something different.  I find this all 
# really annoying.
$EBCDIC = "\t" ne "\011";
if ($OS eq 'VMS') {
    $CRLF = "\n";
} elsif ($EBCDIC) {
    $CRLF= "\r\n";
} else {
    $CRLF = "\015\012";
}
d113 3
d117 21
a137 25
		':html2'=>['h1'..'h6',qw/p br hr ol ul li dl dt dd menu code var strong em
			   tt u i b blockquote pre img a address cite samp dfn html head
			   base body Link nextid title meta kbd start_html end_html
			   input Select option comment/],
		':html3'=>[qw/div table caption th td TR Tr sup Sub strike applet Param 
			   embed basefont style span layer ilayer font frameset frame script small big/],
		':netscape'=>[qw/blink fontsize center/],
		':form'=>[qw/textfield textarea filefield password_field hidden checkbox checkbox_group 
			  submit reset defaults radio_group popup_menu button autoEscape
			  scrolling_list image_button start_form end_form startform endform
			  start_multipart_form end_multipart_form isindex tmpFileName uploadInfo URL_ENCODED MULTIPART/],
		':cgi'=>[qw/param path_info path_translated url self_url script_name cookie Dump
			 raw_cookie request_method query_string Accept user_agent remote_host 
			 remote_addr referer server_name server_software server_port server_protocol
			 virtual_host remote_ident auth_type http use_named_parameters 
			 save_parameters restore_parameters param_fetch
			 remote_user user_name header redirect import_names put Delete Delete_all url_param/],
		':ssl' => [qw/https/],
		':imagemap' => [qw/Area Map/],
		':cgi-lib' => [qw/ReadParse PrintHeader HtmlTop HtmlBot SplitParam/],
		':html' => [qw/:html2 :html3 :netscape/],
		':standard' => [qw/:html2 :html3 :form :cgi/],
		':push' => [qw/multipart_init multipart_start multipart_end/],
		':all' => [qw/:html2 :html3 :netscape :form :cgi :internal/]
		);
a141 6

# This causes modules to clash.  
#    undef %EXPORT_OK;
#    undef %EXPORT;

    $self->_setup_symbols(@@_);
d143 8
a150 1

a166 5
sub compile {
    my $pack = shift;
    $pack->_setup_symbols('-compile',@@_);
}

a168 1
    return ("start_$1","end_$1") if $tag=~/^(?:\*|start_|end_)(.+)/;
d185 2
a186 5
    if ($MOD_PERL) {
	Apache->request->register_cleanup(\&CGI::_reset_globals);
	undef $NPH;
    }
    $self->_reset_globals if $PERLEX;
d233 1
a233 1
    return unless defined($name) && $self->{$name};
d237 11
d249 1
a249 1
    return @@_ if defined($_[0]) && (!ref($_[0])) &&($_[0] eq 'CGI');
d251 5
a255 2
	    (ref($_[0]) eq 'CGI' || UNIVERSAL::isa($_[0],'CGI')) # slightly optimized for common case
	    ) {
d262 15
d281 1
a281 1
	 || UNIVERSAL::isa($_[0],'CGI'))) {
d288 37
d340 2
a341 2
    my($query_string,$meth,$content_length,$fh,@@lines) = ('','','','');
    local($/) = "\n";
d347 1
a354 4
    $content_length = defined($ENV{'CONTENT_LENGTH'}) ? $ENV{'CONTENT_LENGTH'} : 0;
    die "Client attempted to POST $content_length bytes, but POSTs are limited to $POST_MAX"
	if ($POST_MAX > 0) && ($content_length > $POST_MAX);
    $fh = to_filehandle($initializer) if $initializer;
d356 2
d359 1
a360 19
      # Process multipart postings, but only if the initializer is
      # not defined.
      if ($meth eq 'POST'
	  && defined($ENV{'CONTENT_TYPE'})
	  && $ENV{'CONTENT_TYPE'}=~m|^multipart/form-data|
	  && !defined($initializer)
	  ) {
	  my($boundary) = $ENV{'CONTENT_TYPE'} =~ /boundary=\"?([^\";,]+)\"?/;
	  $self->read_multipart($boundary,$content_length);
	  last METHOD;
      } 

      # If initializer is defined, then read parameters
      # from it.
      if (defined($initializer)) {
	  if (UNIVERSAL::isa($initializer,'CGI')) {
	      $query_string = $initializer->query_string;
	      last METHOD;
	  }
d368 3
a370 2
	  if (defined($fh) && ($fh ne '')) {
	      while (<$fh>) {
a382 3

	  # last chance -- treat it as a string
	  $initializer = $$initializer if ref($initializer) eq 'SCALAR';
a383 1

d386 16
d403 4
a406 6
      # If method is GET or HEAD, fetch the query from
      # the environment.
      if ($meth=~/^(GET|HEAD)$/) {
	  $query_string = $ENV{'QUERY_STRING'} if defined $ENV{'QUERY_STRING'};
	  last METHOD;
      }
d408 1
a408 3
      if ($meth eq 'POST') {
	  $self->read_from_client(\*STDIN,\$query_string,$content_length,0)
	      if $content_length > 0;
d412 1
a412 1
	  # $query_string .= (length($query_string) ? '&' : '') . $ENV{'QUERY_STRING'} if defined $ENV{'QUERY_STRING'};
d415 2
a416 2

      # If $meth is not of GET, POST or HEAD, assume we're being debugged offline.
d420 1
a420 1
      $query_string = read_from_cmdline() unless $NO_DEBUG;
d422 1
a422 1

d425 1
a425 1
    if ($query_string ne '') {
d450 1
d453 1
d455 1
d458 5
a462 10
    my $thingy = shift;
    return undef unless $thingy;
    return $thingy if UNIVERSAL::isa($thingy,'GLOB');
    return $thingy if UNIVERSAL::isa($thingy,'FileHandle');
    if (!ref($thingy)) {
	my $caller = 1;
	while (my $package = caller($caller++)) {
	    my($tmp) = $thingy=~/[\':]/ ? $thingy : "$package\:\:$thingy"; 
	    return $tmp if defined(fileno($tmp));
	}
d464 19
a482 1
    return undef;
d499 1
a499 3
    shift() if ref($_[0]);
    my $todecode = shift;
    return undef unless defined($todecode);
d507 2
a508 4
    shift() if ref($_[0]) || $_[0] eq $DefaultClass;
    my $toencode = shift;
    return undef unless defined($toencode);
    $toencode=~s/([^a-zA-Z0-9_.-])/uc sprintf("%%%02x",ord($1))/eg;
d523 8
d533 1
a533 1
    my(@@pairs) = split(/[&;]/,$tosplit);
d536 3
a538 3
	($param,$value) = split('=',$_,2);
	$param = unescape($param);
	$value = unescape($value);
d557 6
a562 34
# put a filehandle into binary mode (DOS)
sub binmode {
    CORE::binmode($_[1]);
}

sub _make_tag_func {
    my ($self,$tagname) = @@_;
    my $func = qq#
	sub $tagname { 
	    shift if \$_[0] && 
		(!ref(\$_[0]) && \$_[0] eq \$CGI::DefaultClass) ||
		    (ref(\$_[0]) &&
		     (substr(ref(\$_[0]),0,3) eq 'CGI' ||
		    UNIVERSAL::isa(\$_[0],'CGI')));
	    
	    my(\$attr) = '';
	    if (ref(\$_[0]) && ref(\$_[0]) eq 'HASH') {
		my(\@@attr) = make_attributes( '',shift() );
		\$attr = " \@@attr" if \@@attr;
	    }
	#;
    if ($tagname=~/start_(\w+)/i) {
	$func .= qq! return "<\U$1\E\$attr>";} !;
    } elsif ($tagname=~/end_(\w+)/i) {
	$func .= qq! return "<\U/$1\E>"; } !;
    } else {
	$func .= qq#
	    my(\$tag,\$untag) = ("\U<$tagname\E\$attr>","\U</$tagname>\E");
	    return \$tag unless \@@_;
	    my \@@result = map { "\$tag\$_\$untag" } (ref(\$_[0]) eq 'ARRAY') ? \@@{\$_[0]} : "\@@_";
	    return "\@@result";
            }#;
    }
return $func;
d567 30
a596 2
    my $func = &_compile;
    goto &$func;
d607 3
d611 20
a630 23
    if (ref($param[0]) eq 'HASH') {
	@@param = %{$param[0]};
    } else {
	return @@param 
	    unless (defined($param[0]) && substr($param[0],0,1) eq '-')
		|| $self->use_named_parameters;
    }

    # map parameters into positional indices
    my ($i,%pos);
    $i = 0;
    foreach (@@$order) {
	foreach (ref($_) eq 'ARRAY' ? @@$_ : $_) { $pos{$_} = $i; }
	$i++;
    }

    my (@@result,%leftover);
    $#result = $#$order;  # preextend
    while (@@param) {
	my $key = uc(shift(@@param));
	$key =~ s/^\-//;
	if (exists $pos{$key}) {
	    $result[$pos{$key}] = shift(@@param);
d632 2
a633 78
	    $leftover{$key} = shift(@@param);
	}
    }

    push (@@result,$self->make_attributes(\%leftover)) if %leftover;
    @@result;
}

sub _compile {
    my($func) = $AUTOLOAD;
    my($pack,$func_name);
    {
	local($1,$2); # this fixes an obscure variable suicide problem.
	$func=~/(.+)::([^:]+)$/;
	($pack,$func_name) = ($1,$2);
	$pack=~s/::SUPER$//;	# fix another obscure problem
	$pack = ${"$pack\:\:AutoloadClass"} || $CGI::DefaultClass
	    unless defined(${"$pack\:\:AUTOLOADED_ROUTINES"});

        my($sub) = \%{"$pack\:\:SUBS"};
        unless (%$sub) {
	   my($auto) = \${"$pack\:\:AUTOLOADED_ROUTINES"};
	   eval "package $pack; $$auto";
	   die $@@ if $@@;
           $$auto = '';  # Free the unneeded storage (but don't undef it!!!)
       }
       my($code) = $sub->{$func_name};

       $code = "sub $AUTOLOAD { }" if (!$code and $func_name eq 'DESTROY');
       if (!$code) {
	   (my $base = $func_name) =~ s/^(start_|end_)//i;
	   if ($EXPORT{':any'} || 
	       $EXPORT{'-any'} ||
	       $EXPORT{$base} || 
	       (%EXPORT_OK || grep(++$EXPORT_OK{$_},&expand_tags(':html')))
	           && $EXPORT_OK{$base}) {
	       $code = $CGI::DefaultClass->_make_tag_func($func_name);
	   }
       }
       die "Undefined subroutine $AUTOLOAD\n" unless $code;
       eval "package $pack; $code";
       if ($@@) {
	   $@@ =~ s/ at .*\n//;
	   die $@@;
       }
    }       
    delete($sub->{$func_name});  #free storage
    return "$pack\:\:$func_name";
}

sub _reset_globals { initialize_globals(); }

sub _setup_symbols {
    my $self = shift;
    my $compile = 0;
    foreach (@@_) {
	$HEADERS_ONCE++,         next if /^[:-]unique_headers$/;
	$NPH++,                  next if /^[:-]nph$/;
	$NO_DEBUG++,             next if /^[:-]no_?[Dd]ebug$/;
	$USE_PARAM_SEMICOLONS++, next if /^[:-]newstyle_urls$/;
	$PRIVATE_TEMPFILES++,    next if /^[:-]private_tempfiles$/;
	$EXPORT{$_}++,           next if /^[:-]any$/;
	$compile++,              next if /^[:-]compile$/;
	
	# This is probably extremely evil code -- to be deleted some day.
	if (/^[-]autoload$/) {
	    my($pkg) = caller(1);
	    *{"${pkg}::AUTOLOAD"} = sub { 
		my($routine) = $AUTOLOAD;
		$routine =~ s/^.*::/CGI::/;
		&$routine;
	    };
	    next;
	}

	foreach (&expand_tags($_)) {
	    tr/a-zA-Z0-9_//cd;  # don't allow weird function names
	    $EXPORT{$_}++;
d635 1
d637 2
a638 1
    _compile_all(keys %EXPORT) if $compile;
d657 2
a658 49
'SERVER_PUSH' => <<'END_OF_FUNC',
sub SERVER_PUSH { 'multipart/x-mixed-replace; boundary="' . shift() . '"'; }
END_OF_FUNC

'use_named_parameters' => <<'END_OF_FUNC',
#### Method: use_named_parameters
# Force CGI.pm to use named parameter-style method calls
# rather than positional parameters.  The same effect
# will happen automatically if the first parameter
# begins with a -.
sub use_named_parameters {
    my($self,$use_named) = self_or_default(@@_);
    return $self->{'.named'} unless defined ($use_named);

    # stupidity to avoid annoying warnings
    return $self->{'.named'}=$use_named;
}
END_OF_FUNC

'new_MultipartBuffer' => <<'END_OF_FUNC',
# Create a new multipart buffer
sub new_MultipartBuffer {
    my($self,$boundary,$length,$filehandle) = @@_;
    return MultipartBuffer->new($self,$boundary,$length,$filehandle);
}
END_OF_FUNC

'read_from_client' => <<'END_OF_FUNC',
# Read data from a file handle
sub read_from_client {
    my($self, $fh, $buff, $len, $offset) = @@_;
    local $^W=0;                # prevent a warning
    return undef unless defined($fh);
    return read($fh, $$buff, $len, $offset);
}
END_OF_FUNC

'delete' => <<'END_OF_FUNC',
#### Method: delete
# Deletes the named parameter entirely.
####
sub delete {
    my($self,$name) = self_or_default(@@_);
    delete $self->{$name};
    delete $self->{'.fieldnames'}->{$name};
    @@{$self->{'.parameters'}}=grep($_ ne $name,$self->param());
    return wantarray ? () : undef;
}
END_OF_FUNC
d660 19
a678 16
#### Method: import_names
# Import all parameters into the given namespace.
# Assumes namespace 'Q' if not specified
####
'import_names' => <<'END_OF_FUNC',
sub import_names {
    my($self,$namespace,$delete) = self_or_default(@@_);
    $namespace = 'Q' unless defined($namespace);
    die "Can't import names into \"main\"\n" if \%{"${namespace}::"} == \%::;
    if ($delete || $MOD_PERL) {
	# can anyone find an easier way to do this?
	foreach (keys %{"${namespace}::"}) {
	    local *symbol = "${namespace}::${_}";
	    undef $symbol;
	    undef @@symbol;
	    undef %symbol;
d680 3
a682 10
    }
    my($param,@@value,$var);
    foreach $param ($self->param) {
	# protect against silly names
	($var = $param)=~tr/a-zA-Z0-9_/_/c;
	$var =~ s/^(?=\d)/_/;
	local *symbol = "${namespace}::$var";
	@@value = $self->param($param);
	@@symbol = @@value;
	$symbol = $value[0];
d696 2
a697 2
    $self->{'keywords'}=[@@values] if defined(@@values);
    my(@@result) = defined($self->{'keywords'}) ? @@{$self->{'keywords'}} : ();
a713 1
    return scalar(keys %in);
d760 1
a760 1
    return $Q || new CGI;
a835 14
'Delete' => <<'EOF',
sub Delete {
    my($self,@@p) = self_or_default(@@_);
    $self->delete(@@p);
}
EOF

'Delete_all' => <<'EOF',
sub Delete_all {
    my($self,@@p) = self_or_default(@@_);
    $self->delete_all(@@p);
}
EOF

d864 2
a865 2
	$key=~tr/a-z_/A-Z-/; # parameters are upper case, use dashes
	push(@@att,defined($attr->{$_}) ? qq/$key="$attr->{$_}"/ : qq/$key/);
a870 31
#### Method: url_param
# Return a parameter in the QUERY_STRING, regardless of
# whether this was a POST or a GET
####
'url_param' => <<'END_OF_FUNC',
sub url_param {
    my ($self,@@p) = self_or_default(@@_);
    my $name = shift(@@p);
    return undef unless exists($ENV{QUERY_STRING});
    unless (exists($self->{'.url_param'})) {
	$self->{'.url_param'}={}; # empty hash
	if ($ENV{QUERY_STRING} =~ /=/) {
	    my(@@pairs) = split(/[&;]/,$ENV{QUERY_STRING});
	    my($param,$value);
	    foreach (@@pairs) {
		($param,$value) = split('=',$_,2);
		$param = unescape($param);
		$value = unescape($value);
		push(@@{$self->{'.url_param'}->{$param}},$value);
	    }
	} else {
	    $self->{'.url_param'}->{'keywords'} = [$self->parse_keywordlist($ENV{QUERY_STRING})];
	}
    }
    return keys %{$self->{'.url_param'}} unless defined($name);
    return () unless $self->{'.url_param'}->{$name};
    return wantarray ? @@{$self->{'.url_param'}->{$name}}
                     : $self->{'.url_param'}->{$name}->[0];
}
END_OF_FUNC

d897 4
a900 13
#### Method as_string
#
# synonym for "dump"
####
'as_string' => <<'END_OF_FUNC',
sub as_string {
    &dump(@@_);
}
END_OF_FUNC

#### Method: save
# Write values out to a filehandle in such a way that they can
# be reinitialized by the filehandle form of the new() method
d905 4
a909 3
    my($param);
    local($,) = '';  # set print field separator back to a sane value
    local($\) = '';  # set output line separator to a sane value
d911 1
a911 1
	my($escaped_param) = escape($param);
a921 77
#### Method: save_parameters
# An alias for save() that is a better name for exportation.
# Only intended to be used with the function (non-OO) interface.
####
'save_parameters' => <<'END_OF_FUNC',
sub save_parameters {
    my $fh = shift;
    return save(to_filehandle($fh));
}
END_OF_FUNC

#### Method: restore_parameters
# A way to restore CGI parameters from an initializer.
# Only intended to be used with the function (non-OO) interface.
####
'restore_parameters' => <<'END_OF_FUNC',
sub restore_parameters {
    $Q = $CGI::DefaultClass->new(@@_);
}
END_OF_FUNC

#### Method: multipart_init
# Return a Content-Type: style header for server-push
# This has to be NPH, and it is advisable to set $| = 1
#
# Many thanks to Ed Jordan <ed@@fidalgo.net> for this
# contribution
####
'multipart_init' => <<'END_OF_FUNC',
sub multipart_init {
    my($self,@@p) = self_or_default(@@_);
    my($boundary,@@other) = $self->rearrange([BOUNDARY],@@p);
    $boundary = $boundary || '------- =_aaaaaaaaaa0';
    $self->{'separator'} = "\n--$boundary\n";
    $type = SERVER_PUSH($boundary);
    return $self->header(
	-nph => 1,
	-type => $type,
	(map { split "=", $_, 2 } @@other),
    ) . $self->multipart_end;
}
END_OF_FUNC


#### Method: multipart_start
# Return a Content-Type: style header for server-push, start of section
#
# Many thanks to Ed Jordan <ed@@fidalgo.net> for this
# contribution
####
'multipart_start' => <<'END_OF_FUNC',
sub multipart_start {
    my($self,@@p) = self_or_default(@@_);
    my($type,@@other) = $self->rearrange([TYPE],@@p);
    $type = $type || 'text/html';
    return $self->header(
	-type => $type,
	(map { split "=", $_, 2 } @@other),
    );
}
END_OF_FUNC


#### Method: multipart_end
# Return a Content-Type: style header for server-push, end of section
#
# Many thanks to Ed Jordan <ed@@fidalgo.net> for this
# contribution
####
'multipart_end' => <<'END_OF_FUNC',
sub multipart_end {
    my($self,@@p) = self_or_default(@@_);
    return $self->{'separator'};
}
END_OF_FUNC


a930 2
    return undef if $self->{'.header_printed'}++ and $HEADERS_ONCE;

d932 1
a932 2
	$self->rearrange([['TYPE','CONTENT_TYPE','CONTENT-TYPE'],
			  STATUS,[COOKIE,COOKIES],TARGET,EXPIRES,NPH],@@p);
a933 1
    $nph ||= $NPH;
d937 4
a940 2
        next unless my($header,$value) = /([^\s=]+)=\"?(.+?)\"?$/;
	($_ = $header) =~ s/^(\w)(.*)/$1 . lc ($2) . ": $value"/e;
d943 1
a943 5
    $type ||= 'text/html' unless defined($type);

    # Maybe future compatibility.  Maybe not.
    my $protocol = $ENV{SERVER_PROTOCOL} || 'HTTP/1.0';
    push(@@header,$protocol . ' ' . ($status || '200 OK')) if $nph;
d945 1
d947 1
a947 1
    push(@@header,"Window-Target: $target") if $target;
d950 1
a950 1
	my(@@cookie) = ref($cookie) && ref($cookie) eq 'ARRAY' ? @@{$cookie} : $cookie;
d952 1
a952 2
            my $cs = UNIVERSAL::isa($_,'CGI::Cookie') ? $_->as_string : $_;
	    push(@@header,"Set-Cookie: $cs") if $cs ne '';
d958 1
a958 1
    push(@@header,"Expires: " . expires($expires,'http'))
d960 1
a960 1
    push(@@header,"Date: " . expires(0,'http')) if $expires || $cookie;
d963 1
a963 1
    push(@@header,"Content-Type: $type") if $type ne '';
d965 2
a966 7
    my $header = join($CRLF,@@header)."${CRLF}${CRLF}";
    if ($MOD_PERL and not $nph) {
	my $r = Apache->request;
	$r->send_cgi_header($header);
	return '';
    }
    return $header;
d994 1
a994 1
    my($url,$target,$cookie,$nph,@@other) = $self->rearrange([[LOCATION,URI,URL],TARGET,COOKIE,NPH],@@p);
d997 10
a1006 3
    foreach (@@other) { tr/\"//d; push(@@o,split("=",$_,2)); }
    unshift(@@o,
	 '-Status'=>'302 Moved',
d1008 4
a1011 4
	 '-nph'=>$nph);
    unshift(@@o,'-Target'=>$target) if $target;
    unshift(@@o,'-Cookie'=>$cookie) if $cookie;
    unshift(@@o,'-Type'=>'');
d1039 2
a1040 2
    my($title,$author,$base,$xbase,$script,$noscript,$target,$meta,$head,$style,$dtd,@@other) = 
	$self->rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,META,HEAD,STYLE,DTD],@@p);
d1045 1
a1045 1
    $author = $self->escape($author);
d1047 1
a1047 2
    $dtd = $DEFAULT_DTD unless $dtd && $dtd =~ m|^-//|;
    push(@@result,qq(<!DOCTYPE HTML PUBLIC "$dtd">)) if $dtd;
d1049 1
a1049 1
    push(@@result,"<LINK REV=MADE HREF=\"mailto:$author\">") if defined $author;
d1052 1
a1052 1
	my $href = $xbase || $self->url('-path'=>1);
d1063 12
a1074 35
    # handle the infrequently-used -style and -script parameters
    push(@@result,$self->_style($style)) if defined $style;
    push(@@result,$self->_script($script)) if defined $script;

    # handle -noscript parameter
    push(@@result,<<END) if $noscript;
<NOSCRIPT>
$noscript
</NOSCRIPT>
END
    ;
    my($other) = @@other ? " @@other" : '';
    push(@@result,"</HEAD><BODY$other>");
    return join("\n",@@result);
}
END_OF_FUNC

### Method: _style
# internal method for generating a CSS style section
####
'_style' => <<'END_OF_FUNC',
sub _style {
    my ($self,$style) = @@_;
    my (@@result);
    my $type = 'text/css';
    if (ref($style)) {
	my($src,$code,$stype,@@other) =
	    $self->rearrange([SRC,CODE,TYPE],
			     '-foo'=>'bar',	# a trick to allow the '-' to be omitted
			     ref($style) eq 'ARRAY' ? @@$style : %$style);
	$type = $stype if $stype;
	push(@@result,qq/<LINK REL="stylesheet" HREF="$src">/) if $src;
	push(@@result,style({'type'=>$type},"<!--\n$code\n-->")) if $code;
    } else {
	push(@@result,style({'type'=>$type},"<!--\n$style\n-->"));
a1075 3
    @@result;
}
END_OF_FUNC
d1077 2
a1078 7

'_script' => <<'END_OF_FUNC',
sub _script {
    my ($self,$script) = @@_;
    my (@@result);
    my (@@scripts) = ref($script) eq 'ARRAY' ? @@$script : ($script);
    foreach $script (@@scripts) {
d1085 1
a1085 1
	    
d1098 11
a1108 1
    @@result;
d1112 1
a1176 5
'end_multipart_form' => <<'END_OF_FUNC',
sub end_multipart_form {
    &endform;
}
END_OF_FUNC
a1215 21
'_textfield' => <<'END_OF_FUNC',
sub _textfield {
    my($self,$tag,@@p) = self_or_default(@@_);
    my($name,$default,$size,$maxlength,$override,@@other) = 
	$self->rearrange([NAME,[DEFAULT,VALUE],SIZE,MAXLENGTH,[OVERRIDE,FORCE]],@@p);

    my $current = $override ? $default : 
	(defined($self->param($name)) ? $self->param($name) : $default);

    $current = defined($current) ? $self->escapeHTML($current) : '';
    $name = defined($name) ? $self->escapeHTML($name) : '';
    my($s) = defined($size) ? qq/ SIZE=$size/ : '';
    my($m) = defined($maxlength) ? qq/ MAXLENGTH=$maxlength/ : '';
    my($other) = @@other ? " @@other" : '';
    # this entered at cristy's request to fix problems with file upload fields
    # and WebTV -- not sure it won't break stuff
    my($value) = $current ne '' ? qq(VALUE="$current") : '';
    return qq/<INPUT TYPE="$tag" NAME="$name" $value$s$m$other>/;
}
END_OF_FUNC

d1229 12
a1240 1
    $self->_textfield('text',@@p);
d1256 13
a1268 1
    $self->_textfield('file',@@p);
d1287 13
a1299 1
    $self->_textfield('password',@@p);
d1303 1
d1386 2
a1387 2
    $name = qq/ NAME="$label"/ if defined($label);
    $value = defined($value) ? $value : $label;
a1440 10
#### Method: comment
# Create an HTML <!-- comment -->
# Parameters: a string
'comment' => <<'END_OF_FUNC',
sub comment {
    my($self,@@p) = self_or_CGI(@@_);
    return "<!-- @@p -->";
}
END_OF_FUNC

d1460 3
a1462 5
    $value = defined $value ? $value : 'on';

    if (!$override && ($self->{'.fieldnames'}->{$name} || 
		       defined $self->param($name))) {
	$checked = grep($_ eq $value,$self->param($name)) ? ' CHECKED' : '';
d1465 1
d1520 2
a1521 4
    my(@@elements,@@values);

    @@values = $self->_set_values_and_labels($values,\$labels,$name);

d1528 1
a1528 1
	    $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
d1532 1
a1532 1
	push(@@elements,qq/<INPUT TYPE="checkbox" NAME="$name" VALUE="$_"$checked$other>${label}${break}/);
d1535 1
a1535 2
    return wantarray ? @@elements : join(' ',@@elements)            
        unless defined($columns) || defined($rows);
d1540 1
a1544 1
    $toencode = $self unless ref($self);
d1546 1
a1546 2
    return $toencode if ref($self) && $self->{'dontescape'};

a1554 19
# unescape HTML -- used internally
'unescapeHTML' => <<'END_OF_FUNC',
sub unescapeHTML {
    my $string = ref($_[0]) ? $_[1] : $_[0];
    return undef unless defined($string);
    # thanks to Randal Schwartz for the correct solution to this one
    $string=~ s[&(.*?);]{
	local $_ = $1;
	/^amp$/i	? "&" :
	/^quot$/i	? '"' :
        /^gt$/i		? ">" :
	/^lt$/i		? "<" :
	/^#(\d+)$/	? chr($1) :
	/^#x([0-9a-f]+)$/i ? chr(hex($1)) :
	$_
	}gex;
    return $string;
}
END_OF_FUNC
d1562 1
a1562 7
    if (defined($columns)) {
	$rows = int(0.99 + @@elements/$columns) unless defined($rows);
    }
    if (defined($rows)) {
	$columns = int(0.99 + @@elements/$rows) unless defined($columns);
    }
    
d1566 2
a1567 2
    unshift(@@$colheaders,'') if defined(@@$colheaders) && defined(@@$rowheaders);
    $result .= "<TR>" if defined(@@{$colheaders});
d1573 1
a1573 1
	$result .= "<TH>$rowheaders->[$row]</TH>" if defined(@@$rowheaders);
d1575 1
a1575 2
	    $result .= "<TD>" . $elements[$column*$rows + $row] . "</TD>"
		if defined($elements[$column*$rows + $row]);
a1618 3
    my(@@elements,@@values);
    @@values = $self->_set_values_and_labels($values,\$labels,$name);

d1620 1
a1620 1
    $checked = $values[0] unless defined($checked) && $checked ne '';
d1623 2
d1632 1
a1632 1
	    $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
d1636 1
a1636 1
	push(@@elements,qq/<INPUT TYPE="radio" NAME="$name" VALUE="$_"$checkit$other>${label}${break}/);
d1639 1
a1639 2
    return wantarray ? @@elements : join(' ',@@elements) 
           unless defined($columns) || defined($rows);
d1675 1
a1675 3
    my(@@values);
    @@values = $self->_set_values_and_labels($values,\$labels,$name);

d1680 1
a1680 1
	$label = $labels->{$_} if defined($labels) && defined($labels->{$_});
d1719 2
a1720 3
    my($result,@@values);
    @@values = $self->_set_values_and_labels($values,\$labels,$name);

d1733 1
a1733 1
	$label = $labels->{$_} if defined($labels) && defined($labels->{$_});
d1765 1
a1765 1
    if ( ref($p[0]) || substr($p[0],0,1) eq '-' || $self->use_named_parameters ) {
d1819 10
a1828 2
    my($self,@@p) = self_or_default(@@_);
    return $self->url('-path_info'=>1,'-query'=>1,'-full'=>1,@@p);
d1848 7
a1854 28
    my($self,@@p) = self_or_default(@@_);
    my ($relative,$absolute,$full,$path_info,$query) = 
	$self->rearrange(['RELATIVE','ABSOLUTE','FULL',['PATH','PATH_INFO'],['QUERY','QUERY_STRING']],@@p);
    my $url;
    $full++ if !($relative || $absolute);

    if ($full) {
	my $protocol = $self->protocol();
	$url = "$protocol://";
	my $vh = http('host');
	if ($vh) {
	    $url .= $vh;
	} else {
	    $url .= server_name();
	    my $port = $self->server_port;
	    $url .= ":" . $port
		unless (lc($protocol) eq 'http' && $port == 80)
		    || (lc($protocol) eq 'https' && $port == 443);
	}
	$url .= $self->script_name;
    } elsif ($relative) {
	($url) = $self->script_name =~ m!([^/]+)$!;
    } elsif ($absolute) {
	$url = $self->script_name;
    }
    $url .= $self->path_info if $path_info and $self->path_info;
    $url .= "?" . $self->query_string if $query and $self->query_string;
    return $url;
d1872 1
a1877 1
    require CGI::Cookie;
d1881 10
a1890 4
    # cookies in our state variables.
    unless ( defined($value) ) {
	$self->{'.cookies'} = CGI::Cookie->fetch
	    unless $self->{'.cookies'};
d1894 27
a1920 15
	return keys %{$self->{'.cookies'}} unless $name;
	return () unless $self->{'.cookies'}->{$name};
	return $self->{'.cookies'}->{$name}->value if defined($name) && $name ne '';
    }

    # If we get here, we're creating a new cookie
    return undef unless $name;	# this is an error

    my @@param;
    push(@@param,'-name'=>$name);
    push(@@param,'-value'=>$value);
    push(@@param,'-domain'=>$domain) if $domain;
    push(@@param,'-path'=>$path) if $path;
    push(@@param,'-expires'=>$expires) if $expires;
    push(@@param,'-secure'=>$secure) if $secure;
d1922 3
a1924 1
    return new CGI::Cookie(@@param);
d1928 1
d1931 1
a1931 1
# Mark Fisher.
d1953 1
a1953 1
    if (!$time || (lc($time) eq 'now')) {
d1955 1
a1955 1
    } elsif ($time=~/^([+-]?(?:\d+|\d*\.\d*))([mhdMy]?)/) {
d1967 2
a1968 2
'expires' => <<'END_OF_FUNC',
sub expires {
a1969 2
    $format ||= 'http';

d1974 3
a1976 2
    $time = expire_calc($time);
    return $time unless $time =~ /^\d+$/;
a1988 23
'parse_keywordlist' => <<'END_OF_FUNC',
sub parse_keywordlist {
    my($self,$tosplit) = @@_;
    $tosplit = unescape($tosplit); # unescape the keywords
    $tosplit=~tr/+/ /;          # pluses to spaces
    my(@@keywords) = split(/\s+/,$tosplit);
    return @@keywords;
}
END_OF_FUNC

'param_fetch' => <<'END_OF_FUNC',
sub param_fetch {
    my($self,@@p) = self_or_default(@@_);
    my($name) = $self->rearrange([NAME],@@p);
    unless (exists($self->{$name})) {
	$self->add_parameter($name);
	$self->{$name} = [];
    }
    
    return $self->{$name};
}
END_OF_FUNC

d1999 1
a1999 13
    my ($self,$info) = self_or_default(@@_);
    if (defined($info)) {
	$info = "/$info" if $info ne '' &&  substr($info,0,1) ne '/';
	$self->{'.path_info'} = $info;
    } elsif (! defined($self->{'.path_info'}) ) {
	$self->{'.path_info'} = defined($ENV{'PATH_INFO'}) ? 
	    $ENV{'PATH_INFO'} : '';

	# hack to fix broken path info in IIS
	$self->{'.path_info'} =~ s/^\Q$ENV{'SCRIPT_NAME'}\E// if $IIS;

    }
    return $self->{'.path_info'};
d2033 1
a2033 1
	my($eparam) = escape($param);
d2035 1
a2035 1
	    $value = escape($value);
d2039 1
a2039 1
    return join($USE_PARAM_SEMICOLONS ? ';' : '&',@@pairs);
d2055 2
a2056 2
'Accept' => <<'END_OF_FUNC',
sub Accept {
d2105 4
a2108 7
#### Method: raw_cookie
# Returns the magic cookies for the session.
# The cookies are not parsed or altered in any way, i.e.
# cookies are returned exactly as given in the HTTP
# headers.  If a cookie name is given, only that cookie's
# value is returned, otherwise the entire raw cookie
# is returned.
d2112 1
a2112 12
    my($self,$key) = self_or_CGI(@@_);

    require CGI::Cookie;

    if (defined($key)) {
	$self->{'.raw_cookies'} = CGI::Cookie->raw_fetch
	    unless $self->{'.raw_cookies'};

	return () unless $self->{'.raw_cookies'};
	return () unless $self->{'.raw_cookies'}->{$key};
	return $self->{'.raw_cookies'}->{$key};
    }
d2123 1
a2123 3
    my $vh = http('host') || server_name();
    $vh =~ s/:\d+$//;		# get rid of port number
    return $vh;
d2159 1
a2159 1
    return $ENV{'SCRIPT_NAME'} if defined($ENV{'SCRIPT_NAME'});
d2257 1
a2257 1
    return 'https' if uc($self->https()) eq 'ON'; 
d2325 1
a2325 1
    $CGI::PRIVATE_TEMPFILES = $param if defined($param);
a2329 11
#### Method: default_dtd
# Set or return the default_dtd global
####
'default_dtd' => <<'END_OF_FUNC',
sub default_dtd {
    my ($self,$param) = self_or_CGI(@@_);
    $CGI::DEFAULT_DTD = $param if defined($param);
    return $CGI::DEFAULT_DTD;
}
END_OF_FUNC

d2360 3
a2362 3
    return $self->CGI::hidden('-name'=>'.cgifields',
			      '-values'=>[keys %{$self->{'.parametersToAdd'}}],
			      '-override'=>1);
d2368 1
d2372 1
a2372 1
	@@words = @@ARGV;
a2373 1
	require "shellwords.pl";
d2375 1
a2375 1
	chomp(@@lines = <STDIN>); # remove newlines
a2376 5
	@@words = &shellwords($input);    
    }
    foreach (@@words) {
	s/\\=/%3D/g;
	s/\\&/%26/g;	    
d2379 5
d2403 2
a2404 2
    my($self,$boundary,$length,$filehandle) = @@_;
    my($buffer) = $self->new_MultipartBuffer($boundary,$length,$filehandle);
a2406 1
    my $filenumber = 0;
d2411 8
a2418 4
	my($param)= $header{'Content-Disposition'}=~/ name="?([^\";]*)"?/;

	# Bug:  Netscape doesn't escape quotation marks in file names!!!
	my($filename) = $header{'Content-Disposition'}=~/ filename="?([^\";]*)"?/;
d2431 18
a2448 11
	my ($tmpfile,$tmp,$filehandle);
      UPLOADS: {
	  # If we get here, then we are dealing with a potentially large
	  # uploaded form.  Save the data to a temporary file, then open
	  # the file for reading.

	  # skip the file if uploads disabled
	  if ($DISABLE_UPLOADS) {
	      while (defined($data = $buffer->read)) { }
	      last UPLOADS;
	  }
d2450 11
a2460 4
	  $tmpfile = new TempFile;
	  $tmp = $tmpfile->as_string;
	  
	  $filehandle = Fh->new($filename,$tmp,$PRIVATE_TEMPFILES);
d2462 6
a2467 2
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode;
	  chmod 0600,$tmp;    # only the owner can tamper with it
d2469 2
a2470 5
	  my ($data);
	  local($\) = '';
	  while (defined($data = $buffer->read)) {
	      print $filehandle $data;
	  }
d2472 13
a2484 12
	  # back up to beginning of file
	  seek($filehandle,0,0);
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode;

	  # Save some information about the uploaded file where we can get
	  # at it later.
	  $self->{'.tmpfiles'}->{$filename}= {
	      name => $tmpfile,
	      info => {%header},
	  };
	  push(@@{$self->{$param}},$filehandle);
      }
d2498 1
a2498 1
'uploadInfo' => <<'END_OF_FUNC',
a2504 22
# internal routine, don't use
'_set_values_and_labels' => <<'END_OF_FUNC',
sub _set_values_and_labels {
    my $self = shift;
    my ($v,$l,$n) = @@_;
    $$l = $v if ref($v) eq 'HASH' && !ref($$l);
    return $self->param($n) if !defined($v);
    return $v if !ref($v);
    return ref($v) eq 'HASH' ? keys %$v : @@$v;
}
END_OF_FUNC

'_compile_all' => <<'END_OF_FUNC',
sub _compile_all {
    foreach (@@_) {
	next if defined(&$_);
	$AUTOLOAD = "CGI::$_";
	_compile();
    }
}
END_OF_FUNC

d2509 2
a2510 10
#########################################################
# Globals and stubs for other packages that we use.
#########################################################

################### Fh -- lightweight filehandle ###############
package Fh;
use overload 
    '""'  => \&asString,
    'cmp' => \&compare,
    'fallback'=>1;
d2512 6
a2517 1
$FH='fh00000';
d2519 2
a2520 1
*Fh::AUTOLOAD = \&CGI::AUTOLOAD;
d2522 3
a2527 17
'asString' => <<'END_OF_FUNC',
sub asString {
    my $self = shift;
    # get rid of package name
    (my $i = $$self) =~ s/^\*(\w+::)+//; 
    $i =~ s/\\(.)/$1/g;
    return $i;
# BEGIN DEAD CODE
# This was an extremely clever patch that allowed "use strict refs".
# Unfortunately it relied on another bug that caused leaky file descriptors.
# The underlying bug has been fixed, so this no longer works.  However
# "strict refs" still works for some reason.
#    my $self = shift;
#    return ${*{$self}{SCALAR}};
# END DEAD CODE
}
END_OF_FUNC
d2529 1
a2529 9
'compare' => <<'END_OF_FUNC',
sub compare {
    my $self = shift;
    my $value = shift;
    return "$self" cmp $value;
}
END_OF_FUNC

'new'  => <<'END_OF_FUNC',
d2531 7
a2537 55
    my($pack,$name,$file,$delete) = @@_;
    require Fcntl unless defined &Fcntl::O_RDWR;
    ++$FH;
    my $ref = \*{'Fh::' . quotemeta($name)}; 
    sysopen($ref,$file,Fcntl::O_RDWR()|Fcntl::O_CREAT()|Fcntl::O_EXCL()) 
	|| die "CGI open of $file: $!\n";
    unlink($file) if $delete;
    delete $Fh::{$FH};
    return bless $ref,$pack;
}
END_OF_FUNC

'DESTROY'  => <<'END_OF_FUNC',
sub DESTROY {
    my $self = shift;
    close $self;
}
END_OF_FUNC

);
END_OF_AUTOLOAD

######################## MultipartBuffer ####################
package MultipartBuffer;

# how many bytes to read at a time.  We use
# a 4K buffer by default.
$INITIAL_FILLUNIT = 1024 * 4;
$TIMEOUT = 240*60;       # 4 hour timeout for big files
$SPIN_LOOP_MAX = 2000;  # bug fix for some Netscape servers
$CRLF=$CGI::CRLF;

#reuse the autoload function
*MultipartBuffer::AUTOLOAD = \&CGI::AUTOLOAD;

# avoid autoloader warnings
sub DESTROY {}

###############################################################################
################# THESE FUNCTIONS ARE AUTOLOADED ON DEMAND ####################
###############################################################################
$AUTOLOADED_ROUTINES = '';      # prevent -w error
$AUTOLOADED_ROUTINES=<<'END_OF_AUTOLOAD';
%SUBS =  (

'new' => <<'END_OF_FUNC',
sub new {
    my($package,$interface,$boundary,$length,$filehandle) = @@_;
    $FILLUNIT = $INITIAL_FILLUNIT;
    my $IN;
    if ($filehandle) {
	my($package) = caller;
	# force into caller's package if necessary
	$IN = $filehandle=~/[':]/ ? $filehandle : "$package\:\:$filehandle"; 
    }
d2554 4
a2557 5

	# BUG: IE 3.01 on the Macintosh uses just the boundary -- not
	# the two extra hyphens.  We do a special case here on the user-agent!!!!
	$boundary = "--$boundary" unless CGI::user_agent('MSIE 3\.0[12];  ?Mac');

d2577 1
a2577 7
    my $retval = bless $self,ref $package || $package;

    # Read the preamble and the topmost (boundary) line plus the CRLF.
    while ($self->read(0)) { }
    die "Malformed multipart POST\n" if $self->eof;

    return $retval;
a2586 5

    if ($CGI::OS eq 'VMS') {  # tssk, tssk: inconsistency alert!
	local($CRLF) = "\015\012";
    }

d2592 1
a2592 2
	# this was a bad idea
	# $FILLUNIT *= 2 if length($self->{BUFFER}) >= $FILLUNIT; 
d2599 2
a2600 12

    
    # See RFC 2045 Appendix A and RFC 822 sections 3.4.8
    #   (Folding Long Header Fields), 3.4.3 (Comments)
    #   and 3.4.5 (Quoted-Strings).

    my $token = '[-\w!\#$%&\'*+.^_\`|{}~]';
    $header=~s/$CRLF\s+/ /og;		# merge continuation lines
    while ($header=~/($token+):\s+([^$CRLF]*)/mgox) {
	my ($field_name,$field_value) = ($1,$2); # avoid taintedness
	$field_name =~ s/\b(\w)/uc($1)/eg; #canonicalize
	$return{$field_name}=$field_value;
a2690 1
    $self->{BUFFER} = '' unless defined $self->{BUFFER};
a2727 2
$MAC = $CGI::OS eq 'MACINTOSH';
my ($vol) = $MAC ? MacPerl::Volumes() =~ /:(.*)/ : "";
d2729 1
a2729 3
    @@TEMP=("${SL}usr${SL}tmp","${SL}var${SL}tmp",
	   "C:${SL}temp","${SL}tmp","${SL}temp","${vol}${SL}Temporary Items",
	   "${SL}WWW_ROOT");
d2735 2
a2736 3
$TMPDIRECTORY  = $MAC ? "" : "." unless $TMPDIRECTORY;
$SEQUENCE=0;
$MAXTRIES = 5000;
d2752 2
a2753 6
    my $directory;
    my $i;
    for ($i = 0; $i < $MAXTRIES; $i++) {
	$directory = sprintf("${TMPDIRECTORY}${SL}CGItemp%d%04d",${$},++$SEQUENCE);
	last if ! -f $directory;
    }
d2787 1
a2787 1
    $MultipartBuffer::INITIAL_FILLUNIT;
d2793 1
a2793 1
1;
d2803 2
a2804 26
  # CGI script that creates a fill-out form
  # and echoes back its values.

  use CGI qw/:standard/;
  print header,
        start_html('A Simple Example'),
        h1('A Simple Example'),
        start_form,
        "What's your name? ",textfield('name'),p,
        "What's the combination?", p,
        checkbox_group(-name=>'words',
		       -values=>['eenie','meenie','minie','moe'],
		       -defaults=>['eenie','minie']), p,
        "What's your favorite color? ",
        popup_menu(-name=>'color',
	           -values=>['red','green','blue','chartreuse']),p,
        submit,
        end_form,
        hr;

   if (param()) {
       print "Your name is",em(param('name')),p,
	     "The keywords are: ",em(join(", ",param('words'))),p,
	     "Your favorite color is ",em(param('color')),
	     hr;
   }
d2808 8
a2815 14
This perl library uses perl5 objects to make it easy to create Web
fill-out forms and parse their contents.  This package defines CGI
objects, entities that contain the values of the current query string
and other state variables.  Using a CGI object's methods, you can
examine keywords and parameters passed to your script, and create
forms whose initial values are taken from the current query (thereby
preserving state information).  The module provides shortcut functions
that produce boilerplate HTML, reducing typing and coding errors. It
also provides functionality for some of the more advanced features of
CGI scripting, including support for file uploads, cookies, cascading
style sheets, server push, and frames.

CGI.pm also provides a simple function-oriented programming style for
those who don't need its object-oriented features.
d2822 1
a2822 3
=head1 DESCRIPTION

=head2 PROGRAMMING STYLE
d2824 2
a2825 56
There are two styles of programming with CGI.pm, an object-oriented
style and a function-oriented style.  In the object-oriented style you
create one or more CGI objects and then use object methods to create
the various elements of the page.  Each CGI object starts out with the
list of named parameters that were passed to your CGI script by the
server.  You can modify the objects, save them to a file or database
and recreate them.  Because each object corresponds to the "state" of
the CGI script, and because each object's parameter list is
independent of the others, this allows you to save the state of the
script and restore it later.

For example, using the object oriented style, here is how you create
a simple "Hello World" HTML page:

   #!/usr/local/bin/perl
   use CGI;                             # load CGI routines
   $q = new CGI;                        # create new CGI object
   print $q->header,                    # create the HTTP header
         $q->start_html('hello world'), # start the HTML
         $q->h1('hello world'),         # level 1 header
         $q->end_html;                  # end the HTML

In the function-oriented style, there is one default CGI object that
you rarely deal with directly.  Instead you just call functions to
retrieve CGI parameters, create HTML tags, manage cookies, and so
on.  This provides you with a cleaner programming interface, but
limits you to using one CGI object at a time.  The following example
prints the same page, but uses the function-oriented interface.
The main differences are that we now need to import a set of functions
into our name space (usually the "standard" functions), and we don't
need to create the CGI object.

   #!/usr/local/bin/perl
   use CGI qw/:standard/;           # load standard CGI routines
   print header,                    # create the HTTP header
         start_html('hello world'), # start the HTML
         h1('hello world'),         # level 1 header
         end_html;                  # end the HTML

The examples in this document mainly use the object-oriented style.
See HOW TO IMPORT FUNCTIONS for important information on
function-oriented programming in CGI.pm

=head2 CALLING CGI.PM ROUTINES

Most CGI.pm routines accept several arguments, sometimes as many as 20
optional ones!  To simplify this interface, all routines use a named
argument calling style that looks like this:

   print $q->header(-type=>'image/gif',-expires=>'+3d');

Each argument name is preceded by a dash.  Neither case nor order
matters in the argument list.  -type, -Type, and -TYPE are all
acceptable.  In fact, only the first argument needs to begin with a
dash.  If a dash is present in the first argument, CGI.pm assumes
dashes for the subsequent ones.
d2827 2
a2828 4
You don't have to use the hyphen at all if you don't want to.  After
creating a CGI object, call the B<use_named_parameters()> method with
a nonzero value.  This will tell CGI.pm that you intend to use named
parameters exclusively:
d2830 3
a2832 5
   $query = new CGI;
   $query->use_named_parameters(1);
   $field = $query->radio_group('name'=>'OS',
				'values'=>['Unix','Windows','Macintosh'],
				'default'=>'Unix');
d2834 3
a2836 54
Several routines are commonly called with just one argument.  In the
case of these routines you can provide the single argument without an
argument name.  header() happens to be one of these routines.  In this
case, the single argument is the document type.

   print $q->header('text/html');

Other such routines are documented below.

Sometimes named arguments expect a scalar, sometimes a reference to an
array, and sometimes a reference to a hash.  Often, you can pass any
type of argument and the routine will do whatever is most appropriate.
For example, the param() routine is used to set a CGI parameter to a
single or a multi-valued value.  The two cases are shown below:

   $q->param(-name=>'veggie',-value=>'tomato');
   $q->param(-name=>'veggie',-value=>'[tomato','tomahto','potato','potahto']);

A large number of routines in CGI.pm actually aren't specifically
defined in the module, but are generated automatically as needed.
These are the "HTML shortcuts," routines that generate HTML tags for
use in dynamically-generated pages.  HTML tags have both attributes
(the attribute="value" pairs within the tag itself) and contents (the
part between the opening and closing pairs.)  To distinguish between
attributes and contents, CGI.pm uses the convention of passing HTML
attributes as a hash reference as the first argument, and the
contents, if any, as any subsequent arguments.  It works out like
this:

   Code                           Generated HTML
   ----                           --------------
   h1()                           <H1>
   h1('some','contents');         <H1>some contents</H1>
   h1({-align=>left});            <H1 ALIGN="LEFT">
   h1({-align=>left},'contents'); <H1 ALIGN="LEFT">contents</H1>

HTML tags are described in more detail later.  

Many newcomers to CGI.pm are puzzled by the difference between the
calling conventions for the HTML shortcuts, which require curly braces
around the HTML tag attributes, and the calling conventions for other
routines, which manage to generate attributes without the curly
brackets.  Don't be confused.  As a convenience the curly braces are
optional in all but the HTML shortcuts.  If you like, you can use
curly braces when calling any routine that takes named arguments.  For
example:

   print $q->header( {-type=>'image/gif',-expires=>'+3d'} );

If you use the B<-w> switch, you will be warned that some CGI.pm argument
names conflict with built-in Perl functions.  The most frequent of
these is the -values argument, used to create multi-valued menus,
radio button clusters and the like.  To get around this warning, you
have several choices:
d2838 1
a2838 1
=over 4
d2840 5
a2844 2
=item 1. Use another name for the argument, if one is available.  For
example, -value is an alias for -values.
d2846 2
a2847 1
=item 2. Change the capitalization, e.g. -Values
d2849 2
a2850 1
=item 3. Put quotes around the argument name, e.g. '-values'
d2852 4
a2855 1
=back
d2857 8
a2864 20
Many routines will do something useful with a named argument that it
doesn't recognize.  For example, you can produce non-standard HTTP
header fields by providing them as named arguments:

  print $q->header(-type  =>  'text/html',
                   -cost  =>  'Three smackers',
                   -annoyance_level => 'high',
                   -complaints_to   => 'bit bucket');

This will produce the following nonstandard HTTP header:

   HTTP/1.0 200 OK
   Cost: Three smackers
   Annoyance-level: high
   Complaints-to: bit bucket
   Content-type: text/html

Notice the way that underscores are translated automatically into
hyphens.  HTML-generating routines perform a different type of
translation. 
d2866 1
a2866 2
This feature allows you to keep up with the rapidly changing HTTP and
HTML "standards".
d2868 1
a2868 1
=head2 CREATING A NEW QUERY OBJECT (OBJECT-ORIENTED STYLE):
d2879 6
a2884 6
If you provide a file handle to the new() method, it will read
parameters from the file (or STDIN, or whatever).  The file can be in
any of the forms describing below under debugging (i.e. a series of
newline delimited TAG=VALUE pairs will work).  Conveniently, this type
of file is created by the save() method (see below).  Multiple records
can be saved and restored.
a2891 12
You can also initialize the CGI object with a FileHandle or IO::File
object.

If you are using the function-oriented interface and want to
initialize CGI state from a file handle, the way to do this is with
B<restore_parameters()>.  This will (re)initialize the
default CGI object from the indicated file handle.

    open (IN,"test.in") || die;
    restore_parameters(IN);
    close IN;

a2903 7
or from a previously existing CGI object (currently this clones the
parameter list, but none of the other object-specific fields, such as
autoescaping):

    $old_query = new CGI;
    $new_query = new CGI($old_query);

d2906 3
a2908 5
   $empty_query = new CGI("");

       -or-

   $empty_query = new CGI({});
d2967 1
a2967 1
   $query->append(-name=>'foo',-values=>['yet','more','values']);
a2995 3
If you are using the function call interface, use "Delete()" instead
to avoid conflicts with Perl's built-in delete operator.

d2998 1
a2998 1
   $query->delete_all();
d3003 1
a3003 16
Use Delete_all() instead if you are using the function call interface.

=head2 DIRECT ACCESS TO THE PARAMETER LIST:

   $q->param_fetch('address')->[1] = '1313 Mockingbird Lane';
   unshift @@{$q->param_fetch(-name=>'address')},'George Munster';

If you need access to the parameter list in a way that isn't covered
by the methods above, you can obtain a direct reference to it by
calling the B<param_fetch()> method with the name of the .  This
will return an array reference to the named parameters, which you then
can manipulate in any way you like.

You can also use a named argument style using the B<-name> argument.

=head2 SAVING THE STATE OF THE SCRIPT TO A FILE:
d3054 1
a3054 2
If you wish to use this method from the function-oriented (non-OO)
interface, the exported name for this method is B<save_parameters()>.
d3056 2
a3057 1
=head2 USING THE FUNCTION-ORIENTED INTERFACE
d3059 5
a3063 4
To use the function-oriented interface, you must specify which CGI.pm
routines or sets of routines to import into your script's namespace.
There is a small overhead associated with this importation, but it
isn't much.
d3065 4
a3068 1
   use CGI <list of methods>;
d3070 2
a3071 4
The listed methods will be imported into the current package; you can
call them directly without creating a CGI object first.  This example
shows how to import the B<param()> and B<header()>
methods, and then use them directly:
d3073 2
a3074 7
   use CGI 'param','header';
   print header('text/plain');
   $zipcode = param('zipcode');

More frequently, you'll import common sets of functions by referring
to the groups by name.  All function sets are preceded with a ":"
character as in ":html3" (for tags defined in the HTML 3 standard).
d3076 1
a3076 1
Here is a list of the function sets you can import:
d3078 1
a3078 1
=over 4
d3080 1
a3080 1
=item B<:cgi>
d3082 3
a3084 2
Import all CGI-handling methods, such as B<param()>, B<path_info()>
and the like.
d3086 4
a3089 1
=item B<:form>
d3091 4
a3094 1
Import all fill-out form generating methods, such as B<textfield()>.
d3096 5
a3100 1
=item B<:html2>
d3102 2
a3103 1
Import all methods that generate HTML 2.0 standard elements.
d3105 3
a3107 1
=item B<:html3>
d3109 2
a3110 2
Import all methods that generate HTML 3.0 proposed elements (such as
<table>, <super> and <sub>).
d3112 1
a3112 1
=item B<:netscape>
d3114 22
a3135 1
Import all methods that generate Netscape-specific HTML extensions.
d3137 1
a3137 1
=item B<:html>
d3139 2
a3140 2
Import all HTML-generating shortcuts (i.e. 'html2' + 'html3' +
'netscape')...
d3142 5
a3146 1
=item B<:standard>
d3148 5
a3152 147
Import "standard" features, 'html2', 'html3', 'form' and 'cgi'.

=item B<:all>

Import all the available methods.  For the full list, see the CGI.pm
code, where the variable %TAGS is defined.

=back

If you import a function name that is not part of CGI.pm, the module
will treat it as a new HTML tag and generate the appropriate
subroutine.  You can then use it like any other HTML tag.  This is to
provide for the rapidly-evolving HTML "standard."  For example, say
Microsoft comes out with a new tag called <GRADIENT> (which causes the
user's desktop to be flooded with a rotating gradient fill until his
machine reboots).  You don't need to wait for a new version of CGI.pm
to start using it immediately:

   use CGI qw/:standard :html3 gradient/;
   print gradient({-start=>'red',-end=>'blue'});

Note that in the interests of execution speed CGI.pm does B<not> use
the standard L<Exporter> syntax for specifying load symbols.  This may
change in the future.

If you import any of the state-maintaining CGI or form-generating
methods, a default CGI object will be created and initialized
automatically the first time you use any of the methods that require
one to be present.  This includes B<param()>, B<textfield()>,
B<submit()> and the like.  (If you need direct access to the CGI
object, you can find it in the global variable B<$CGI::Q>).  By
importing CGI.pm methods, you can create visually elegant scripts:

   use CGI qw/:standard/;
   print 
       header,
       start_html('Simple Script'),
       h1('Simple Script'),
       start_form,
       "What's your name? ",textfield('name'),p,
       "What's the combination?",
       checkbox_group(-name=>'words',
		      -values=>['eenie','meenie','minie','moe'],
		      -defaults=>['eenie','moe']),p,
       "What's your favorite color?",
       popup_menu(-name=>'color',
		  -values=>['red','green','blue','chartreuse']),p,
       submit,
       end_form,
       hr,"\n";

    if (param) {
       print 
	   "Your name is ",em(param('name')),p,
	   "The keywords are: ",em(join(", ",param('words'))),p,
	   "Your favorite color is ",em(param('color')),".\n";
    }
    print end_html;

=head2 PRAGMAS

In addition to the function sets, there are a number of pragmas that
you can import.  Pragmas, which are always preceded by a hyphen,
change the way that CGI.pm functions in various ways.  Pragmas,
function sets, and individual functions can all be imported in the
same use() line.  For example, the following use statement imports the
standard set of functions and disables debugging mode (pragma
-no_debug):

   use CGI qw/:standard -no_debug/;

The current list of pragmas is as follows:

=over 4

=item -any

When you I<use CGI -any>, then any method that the query object
doesn't recognize will be interpreted as a new HTML tag.  This allows
you to support the next I<ad hoc> Netscape or Microsoft HTML
extension.  This lets you go wild with new and unsupported tags:

   use CGI qw(-any);
   $q=new CGI;
   print $q->gradient({speed=>'fast',start=>'red',end=>'blue'});

Since using <cite>any</cite> causes any mistyped method name
to be interpreted as an HTML tag, use it with care or not at
all.

=item -compile

This causes the indicated autoloaded methods to be compiled up front,
rather than deferred to later.  This is useful for scripts that run
for an extended period of time under FastCGI or mod_perl, and for
those destined to be crunched by Malcom Beattie's Perl compiler.  Use
it in conjunction with the methods or method families you plan to use.

   use CGI qw(-compile :standard :html3);

or even

   use CGI qw(-compile :all);

Note that using the -compile pragma in this way will always have
the effect of importing the compiled functions into the current
namespace.  If you want to compile without importing use the
compile() method instead (see below).

=item -nph

This makes CGI.pm produce a header appropriate for an NPH (no
parsed header) script.  You may need to do other things as well
to tell the server that the script is NPH.  See the discussion
of NPH scripts below.

=item -newstyle_urls

Separate the name=value pairs in CGI parameter query strings with
semicolons rather than ampersands.  For example:

   ?name=fred;age=24;favorite_color=3

Semicolon-delimited query strings are always accepted, but will not be
emitted by self_url() and query_string() unless the -newstyle_urls
pragma is specified.

=item -autoload

This overrides the autoloader so that any function in your program
that is not recognized is referred to CGI.pm for possible evaluation.
This allows you to use all the CGI.pm functions without adding them to
your symbol table, which is of concern for mod_perl users who are
worried about memory consumption.  I<Warning:> when
I<-autoload> is in effect, you cannot use "poetry mode"
(functions without the parenthesis).  Use I<hr()> rather
than I<hr>, or add something like I<use subs qw/hr p header/> 
to the top of your script.

=item -no_debug

This turns off the command-line processing features.  If you want to
run a CGI.pm script from the command line to produce HTML, and you
don't want it pausing to request CGI parameters from standard input or
the command line, then use this pragma:

   use CGI qw(-no_debug :standard);
d3154 7
a3160 2
If you'd like to process the command-line parameters but not standard
input, this should work:
d3162 1
a3162 83
   use CGI qw(-no_debug :standard);
   restore_parameters(join('&',@@ARGV));
  
See the section on debugging for more details.

=item -private_tempfiles

CGI.pm can process uploaded file. Ordinarily it spools the
uploaded file to a temporary directory, then deletes the file
when done.  However, this opens the risk of eavesdropping as
described in the file upload section.
Another CGI script author could peek at this data during the
upload, even if it is confidential information. On Unix systems,
the -private_tempfiles pragma will cause the temporary file to be unlinked as soon
as it is opened and before any data is written into it,
eliminating the risk of eavesdropping.

=back

=head2 SPECIAL FORMS FOR IMPORTING HTML-TAG FUNCTIONS

Many of the methods generate HTML tags.  As described below, tag
functions automatically generate both the opening and closing tags.
For example:

  print h1('Level 1 Header');

produces

  <H1>Level 1 Header</H1>

There will be some times when you want to produce the start and end
tags yourself.  In this case, you can use the form start_I<tag_name>
and end_I<tag_name>, as in:

  print start_h1,'Level 1 Header',end_h1;

With a few exceptions (described below), start_I<tag_name> and
end_I<tag_name> functions are not generated automatically when you
I<use CGI>.  However, you can specify the tags you want to generate
I<start/end> functions for by putting an asterisk in front of their
name, or, alternatively, requesting either "start_I<tag_name>" or
"end_I<tag_name>" in the import list.

Example:

  use CGI qw/:standard *table start_ul/;

In this example, the following functions are generated in addition to
the standard ones:

=over 4

=item 1. start_table() (generates a <TABLE> tag)

=item 2. end_table() (generates a </TABLE> tag)

=item 3. start_ul() (generates a <UL> tag)

=item 4. end_ul() (generates a </UL> tag)

=back

=head1 GENERATING DYNAMIC DOCUMENTS

Most of CGI.pm's functions deal with creating documents on the fly.
Generally you will produce the HTTP header first, followed by the
document itself.  CGI.pm provides functions for generating HTTP
headers of various types as well as for generating HTML.  For creating
GIF images, see the GD.pm module.

Each of these functions produces a fragment of HTML or HTTP which you
can print out directly so that it displays in the browser window,
append to a string, or save to a file for later use.

=head2 CREATING A STANDARD HTTP HEADER:

Normally the first thing you will do in any CGI script is print out an
HTTP header.  This tells the browser what type of document to expect,
and gives other optional information, such as the language, expiration
date, and whether to cache the document.  The header can also be
manipulated for special purposes, such as server push and pay per view
pages.
d3187 4
a3190 1
script that tells the browser to do nothing at all.
d3194 1
a3194 1
B<-type>, B<-status>, B<-expires>, and B<-cookie>.  Any other named
a3196 3
Internal underscores will be turned into hyphens:

    print $query->header(-Content_length=>3002);
d3213 5
a3217 1
	Thursday, 25-Apr-1999 00:40:33 GMT  at the indicated time & date
d3230 1
a3230 1
=head2 GENERATING A REDIRECTION HEADER
d3234 4
a3237 9
Sometimes you don't want to produce a document yourself, but simply
redirect the browser elsewhere, perhaps choosing a URL based on the
time of day or the identity of the user.  

The redirect() function redirects the browser to a different URL.  If
you use redirection like this, you should B<not> print out a header as
well.  As of version 2.0, we produce both the unofficial Location:
header and the official URI: header.  This should satisfy most servers
and browsers.
d3245 1
a3245 1
You can also use named arguments:
d3255 2
a3256 1
=head2 CREATING THE HTML DOCUMENT HEADER
d3267 11
a3277 11
After creating the HTTP header, most CGI scripts will start writing
out an HTML document.  The start_html() routine creates the top of the
page, along with a lot of optional information that controls the
page's appearance and behavior.

This method returns a canned HTML header and the opening <BODY> tag.
All parameters are optional.  In the named parameter form, recognized
parameters are -title, -author, -base, -xbase and -target (see below
for the explanation).  Any additional parameters you provide, such as
the Netscape unofficial BGCOLOR attribute, are added to the <BODY>
tag.  Additional parameters must be proceeded by a hyphen.
d3298 2
a3299 298
    <META NAME="keywords" CONTENT="pharaoh secret mummy">
    <META NAME="description" CONTENT="copyright 1996 King Tut">

There is no support for the HTTP-EQUIV type of <META> tag.  This is
because you can modify the HTTP header directly with the B<header()>
method.  For example, if you want to send the Refresh: header, do it
in the header() method:

    print $q->header(-Refresh=>'10; URL=http://www.capricorn.com');

The B<-style> tag is used to incorporate cascading stylesheets into
your code.  See the section on CASCADING STYLESHEETS for more information.

You can place other arbitrary HTML elements to the <HEAD> section with the
B<-head> tag.  For example, to place the rarely-used <LINK> element in the
head section, use this:

    print $q->start_html(-head=>Link({-rel=>'next',
				  -href=>'http://www.capricorn.com/s2.html'}));

To incorporate multiple HTML elements into the <HEAD> section, just pass an
array reference:

    print $q->start_html(-head=>[ 
                              Link({-rel=>'next',
				    -href=>'http://www.capricorn.com/s2.html'}),
			      Link({-rel=>'previous',
				    -href=>'http://www.capricorn.com/s1.html'})
			     ]
		     );

JAVASCRIPTING: The B<-script>, B<-noScript>, B<-onLoad>,
B<-onMouseOver>, B<-onMouseOut> and B<-onUnload> parameters are used
to add Netscape JavaScript calls to your pages.  B<-script> should
point to a block of text containing JavaScript function definitions.
This block will be placed within a <SCRIPT> block inside the HTML (not
HTTP) header.  The block is placed in the header in order to give your
page a fighting chance of having all its JavaScript functions in place
even if the user presses the stop button before the page has loaded
completely.  CGI.pm attempts to format the script in such a way that
JavaScript-naive browsers will not choke on the code: unfortunately
there are some browsers, such as Chimera for Unix, that get confused
by it nevertheless.

The B<-onLoad> and B<-onUnload> parameters point to fragments of JavaScript
code to execute when the page is respectively opened and closed by the
browser.  Usually these parameters are calls to functions defined in the
B<-script> field:

      $query = new CGI;
      print $query->header;
      $JSCRIPT=<<END;
      // Ask a silly question
      function riddle_me_this() {
	 var r = prompt("What walks on four legs in the morning, " +
		       "two legs in the afternoon, " +
		       "and three legs in the evening?");
	 response(r);
      }
      // Get a silly answer
      function response(answer) {
	 if (answer == "man")
	    alert("Right you are!");
	 else
	    alert("Wrong!  Guess again.");
      }
      END
      print $query->start_html(-title=>'The Riddle of the Sphinx',
			       -script=>$JSCRIPT);

Use the B<-noScript> parameter to pass some HTML text that will be displayed on 
browsers that do not have JavaScript (or browsers where JavaScript is turned
off).

Netscape 3.0 recognizes several attributes of the <SCRIPT> tag,
including LANGUAGE and SRC.  The latter is particularly interesting,
as it allows you to keep the JavaScript code in a file or CGI script
rather than cluttering up each page with the source.  To use these
attributes pass a HASH reference in the B<-script> parameter containing
one or more of -language, -src, or -code:

    print $q->start_html(-title=>'The Riddle of the Sphinx',
			 -script=>{-language=>'JAVASCRIPT',
                                   -src=>'/javascript/sphinx.js'}
			 );

    print $q->(-title=>'The Riddle of the Sphinx',
	       -script=>{-language=>'PERLSCRIPT'},
			 -code=>'print "hello world!\n;"'
	       );


A final feature allows you to incorporate multiple <SCRIPT> sections into the
header.  Just pass the list of script sections as an array reference.
this allows you to specify different source files for different dialects
of JavaScript.  Example:     

     print $q-&gt;start_html(-title=&gt;'The Riddle of the Sphinx',
                          -script=&gt;[
                                    { -language =&gt; 'JavaScript1.0',
                                      -src      =&gt; '/javascript/utilities10.js'
                                    },
                                    { -language =&gt; 'JavaScript1.1',
                                      -src      =&gt; '/javascript/utilities11.js'
                                    },
                                    { -language =&gt; 'JavaScript1.2',
                                      -src      =&gt; '/javascript/utilities12.js'
                                    },
                                    { -language =&gt; 'JavaScript28.2',
                                      -src      =&gt; '/javascript/utilities219.js'
                                    }
                                 ]
                             );
     </pre>

If this looks a bit extreme, take my advice and stick with straight CGI scripting.  

See

   http://home.netscape.com/eng/mozilla/2.0/handbook/javascript/

for more information about JavaScript.

The old-style positional parameters are as follows:

=over 4

=item B<Parameters:>

=item 1.

The title

=item 2.

The author's e-mail address (will create a <LINK REV="MADE"> tag if present

=item 3.

A 'true' flag if you want to include a <BASE> tag in the header.  This
helps resolve relative addresses to absolute ones when the document is moved, 
but makes the document hierarchy non-portable.  Use with care!

=item 4, 5, 6...

Any other parameters you want to include in the <BODY> tag.  This is a good
place to put Netscape extensions, such as colors and wallpaper patterns.

=back

=head2 ENDING THE HTML DOCUMENT:

	print $query->end_html

This ends an HTML document by printing the </BODY></HTML> tags.

=head2 CREATING A SELF-REFERENCING URL THAT PRESERVES STATE INFORMATION:

    $myself = $query->self_url;
    print "<A HREF=$myself>I'm talking to myself.</A>";

self_url() will return a URL, that, when selected, will reinvoke
this script with all its state information intact.  This is most
useful when you want to jump around within the document using
internal anchors but you don't want to disrupt the current contents
of the form(s).  Something like this will do the trick.

     $myself = $query->self_url;
     print "<A HREF=$myself#table1>See table 1</A>";
     print "<A HREF=$myself#table2>See table 2</A>";
     print "<A HREF=$myself#yourself>See for yourself</A>";

If you want more control over what's returned, using the B<url()>
method instead.

You can also retrieve the unprocessed query string with query_string():

    $the_string = $query->query_string;

=head2 OBTAINING THE SCRIPT'S URL

    $full_url      = $query->url();
    $full_url      = $query->url(-full=>1);  #alternative syntax
    $relative_url  = $query->url(-relative=>1);
    $absolute_url  = $query->url(-absolute=>1);
    $url_with_path = $query->url(-path_info=>1);
    $url_with_path_and_query = $query->url(-path_info=>1,-query=>1);

B<url()> returns the script's URL in a variety of formats.  Called
without any arguments, it returns the full form of the URL, including
host name and port number

    http://your.host.com/path/to/script.cgi

You can modify this format with the following named arguments:

=over 4

=item B<-absolute>

If true, produce an absolute URL, e.g.

    /path/to/script.cgi

=item B<-relative>

Produce a relative URL.  This is useful if you want to reinvoke your
script with different parameters. For example:

    script.cgi

=item B<-full>

Produce the full URL, exactly as if called without any arguments.
This overrides the -relative and -absolute arguments.

=item B<-path> (B<-path_info>)

Append the additional path information to the URL.  This can be
combined with B<-full>, B<-absolute> or B<-relative>.  B<-path_info>
is provided as a synonym.

=item B<-query> (B<-query_string>)

Append the query string to the URL.  This can be combined with
B<-full>, B<-absolute> or B<-relative>.  B<-query_string> is provided
as a synonym.

=back

=head2 MIXING POST AND URL PARAMETERS

   $color = $query-&gt;url_param('color');

It is possible for a script to receive CGI parameters in the URL as
well as in the fill-out form by creating a form that POSTs to a URL
containing a query string (a "?" mark followed by arguments).  The
B<param()> method will always return the contents of the POSTed
fill-out form, ignoring the URL's query string.  To retrieve URL
parameters, call the B<url_param()> method.  Use it in the same way as
B<param()>.  The main difference is that it allows you to read the
parameters, but not set them.


Under no circumstances will the contents of the URL query string
interfere with similarly-named CGI parameters in POSTed forms.  If you
try to mix a URL query string with a form submitted with the GET
method, the results will not be what you expect.

=head1 CREATING STANDARD HTML ELEMENTS:

CGI.pm defines general HTML shortcut methods for most, if not all of
the HTML 3 and HTML 4 tags.  HTML shortcuts are named after a single
HTML element and return a fragment of HTML text that you can then
print or manipulate as you like.  Each shortcut returns a fragment of
HTML code that you can append to a string, save to a file, or, most
commonly, print out so that it displays in the browser window.

This example shows how to use the HTML methods:

   $q = new CGI;
   print $q->blockquote(
		     "Many years ago on the island of",
		     $q->a({href=>"http://crete.org/"},"Crete"),
		     "there lived a minotaur named",
		     $q->strong("Fred."),
		    ),
       $q->hr;

This results in the following HTML code (extra newlines have been
added for readability):

   <blockquote>
   Many years ago on the island of
   <a HREF="http://crete.org/">Crete</a> there lived
   a minotaur named <strong>Fred.</strong> 
   </blockquote>
   <hr>

If you find the syntax for calling the HTML shortcuts awkward, you can
import them into your namespace and dispense with the object syntax
completely (see the next section for more details):

   use CGI ':standard';
   print blockquote(
      "Many years ago on the island of",
      a({href=>"http://crete.org/"},"Crete"),
      "there lived a minotaur named",
      strong("Fred."),
      ),
      hr;

=head2 PROVIDING ARGUMENTS TO HTML SHORTCUTS

The HTML methods will accept zero, one or multiple arguments.  If you
provide no arguments, you get a single tag:

   print hr;  	#  <HR>
d3301 4
a3304 2
If you provide one or more string arguments, they are concatenated
together with spaces and placed between opening and closing tags:
d3306 1
a3306 1
   print h1("Chapter","1"); # <H1>Chapter 1</H1>"
d3308 2
a3309 2
If the first argument is an associative array reference, then the keys
and values of the associative array become the HTML tag's attributes:
d3311 3
a3313 2
   print a({-href=>'fred.html',-target=>'_new'},
      "Open a new frame");
d3315 2
a3316 4
	    <A HREF="fred.html",TARGET="_new">Open a new frame</A>
   
You may dispense with the dashes in front of the attribute names if
you prefer:
d3318 2
a3319 1
   print img {src=>'fred.gif',align=>'LEFT'};
d3321 6
a3326 1
	   <IMG ALIGN="LEFT" SRC="fred.gif">
a3327 3
Sometimes an HTML tag attribute has no argument.  For example, ordered
lists can be marked as COMPACT.  The syntax for this is an argument that
that points to an undef string:
d3329 11
a3339 1
   print ol({compact=>undef},li('one'),li('two'),li('three'));
d3341 4
a3344 8
Prior to CGI.pm version 2.41, providing an empty ('') string as an
attribute argument was the same as providing undef.  However, this has
changed in order to accommodate those who want to create tags of the form 
<IMG ALT="">.  The difference is shown in these two pieces of code:
  
   CODE                   RESULT
   img({alt=>undef})      <IMG ALT>
   img({alt=>''})         <IMT ALT="">
d3346 20
a3365 1
=head2 THE DISTRIBUTIVE PROPERTY OF HTML SHORTCUTS
d3367 3
a3369 5
One of the cool features of the HTML shortcuts is that they are
distributive.  If you give them an argument consisting of a
B<reference> to a list, the tag will be distributed across each
element of the list.  For example, here's one way to make an ordered
list:
d3371 6
a3376 3
   print ul(
             li({-type=>'disc'},['Sneezy','Doc','Sleepy','Happy']);
           );
d3378 4
a3381 1
This example will result in HTML output that looks like this:
d3383 4
a3386 6
   <UL>
     <LI TYPE="disc">Sneezy</LI>
     <LI TYPE="disc">Doc</LI>
     <LI TYPE="disc">Sleepy</LI>
     <LI TYPE="disc">Happy</LI>
   </UL>
a3387 1
This is extremely useful for creating tables.  For example:
d3389 1
a3389 11
   print table({-border=>undef},
           caption('When Should You Eat Your Vegetables?'),
           Tr({-align=>CENTER,-valign=>TOP},
           [
              th(['Vegetable', 'Breakfast','Lunch','Dinner']),
              td(['Tomatoes' , 'no', 'yes', 'yes']),
              td(['Broccoli' , 'no', 'no',  'yes']),
              td(['Onions'   , 'yes','yes', 'yes'])
           ]
           )
        );
d3391 1
a3391 1
=head2 HTML SHORTCUTS AND LIST INTERPOLATION
d3393 1
a3393 1
Consider this bit of code:
d3395 1
a3395 1
   print blockquote(em('Hi'),'mom!'));
d3397 1
a3397 1
It will ordinarily return the string that you probably expect, namely:
d3399 1
a3399 1
   <BLOCKQUOTE><EM>Hi</EM> mom!</BLOCKQUOTE>
d3401 1
a3401 6
Note the space between the element "Hi" and the element "mom!".
CGI.pm puts the extra space there using array interpolation, which is
controlled by the magic $" variable.  Sometimes this extra space is
not what you want, for example, when you are trying to align a series
of images.  In this case, you can simply change the value of $" to an
empty string.
d3403 1
a3403 4
   {
      local($") = '';
      print blockquote(em('Hi'),'mom!'));
    }
d3405 1
a3405 3
I suggest you put the code in a block as shown here.  Otherwise the
change to $" will affect all subsequent code until you explicitly
reset it.
d3407 1
a3407 1
=head2 NON-STANDARD HTML SHORTCUTS
d3409 1
a3409 2
A few HTML tags don't follow the standard pattern for various
reasons.  
d3411 3
a3413 2
B<comment()> generates an HTML comment (<!-- comment -->).  Call it
like
d3415 1
a3415 1
    print comment('here is my comment');
d3417 2
a3418 2
Because of conflicts with built-in Perl functions, the following functions
begin with initial caps:
d3420 1
a3420 6
    Select
    Tr
    Link
    Delete
    Accept
    Sub
d3422 1
a3422 3
In addition, start_html(), end_html(), start_form(), end_form(),
start_multipart_form() and all the fill-out form tags are special.
See their respective sections.
d3424 1
a3424 1
=head2 PRETTY-PRINTING HTML
d3426 1
a3426 5
By default, all the HTML produced by these functions comes out as one
long line without carriage returns or indentation. This is yuck, but
it does reduce the size of the documents by 10-20%.  To get
pretty-printed output, please use L<CGI::Pretty>, a subclass
contributed by Brian Paulsen.
d3428 1
a3428 1
=head1 CREATING FILL-OUT FORMS:
d3482 1
a3482 1
			    -enctype=>$encoding);
d3497 1
a3497 1
    enctype: application/x-www-form-urlencoded
d3501 1
a3501 1
Startform()'s enctype argument tells the browser how to package the various
d3522 1
a3522 1
in B<&CGI::MULTIPART>
d3608 7
a3614 8
JAVASCRIPTING: You can also provide B<-onChange>, B<-onFocus>,
B<-onBlur>, B<-onMouseOver>, B<-onMouseOut> and B<-onSelect>
parameters to register JavaScript event handlers.  The onChange
handler will be called whenever the user changes the contents of the
text field.  You can do text validation if you like.  onFocus and
onBlur are called respectively when the insertion point moves into and
out of the text field.  onSelect is called when the user changes the
portion of the text that is selected.
d3632 2
a3633 3
JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur> ,
B<-onMouseOver>, B<-onMouseOut>, and B<-onSelect> parameters are
recognized.  See textfield().
d3648 2
a3649 3
JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur>,
B<-onMouseOver>, B<-onMouseOut> and B<-onSelect> parameters are
recognized.  See textfield().
d3681 6
a3686 5
For security reasons, browsers don't pay any attention to this field,
and so the starting value will always be blank.  Worse, the field
loses its "sticky" behavior and forgets its previous contents.  The
starting value field is called for in the HTML specification, however,
and possibly some browser will eventually provide support for it.
d3705 3
a3707 3
In Netscape Navigator 2.0, the filename that gets returned is the full
local filename on the B<remote user's> machine.  If the remote user is
on a Unix machine, the filename will follow Unix conventions:
d3750 3
a3752 3
JAVASCRIPTING: The B<-onChange>, B<-onFocus>, B<-onBlur>,
B<-onMouseOver>, B<-onMouseOut> and B<-onSelect> parameters are
recognized.  See textfield() for details.
d3814 2
a3815 3
B<-onChange>, B<-onFocus>, B<-onMouseOver>, B<-onMouseOut>, and
B<-onBlur>.  See the textfield() section for details on when these
handlers are called.
d3883 3
a3885 4
JAVASCRIPTING: scrolling_list() recognizes the following event
handlers: B<-onChange>, B<-onFocus>, B<-onMouseOver>, B<-onMouseOut>
and B<-onBlur>.  See textfield() for the description of when these
handlers are called.
d3943 8
a3950 6
B<HTML3-compatible browsers> (such as Netscape) can take advantage of
the optional parameters B<-rows>, and B<-columns>.  These parameters
cause checkbox_group() to return an HTML3 compatible table containing
the checkbox group formatted with the specified number of rows and
columns.  You can provide just the -columns parameter if you wish;
checkbox_group will calculate the correct number of rows for you.
d3953 1
a3953 1
can use the B<-rowheaders> and B<-colheaders> parameters.  Both
d4103 1
a4103 1
interpretation of the radio buttons -- they're still a single named
a4166 3
Note that this conflicts with the Perl reset() built-in.  Use
CORE::reset() to get the original reset function.

d4273 1
a4273 1
=head1 HTTP COOKIES
d4275 3
a4277 4
Netscape browsers versions 1.1 and higher, and all versions of
Internet Explorer, support a so-called "cookie" designed to help
maintain state within a browser session.  CGI.pm has several methods
that support cookies.
d4295 2
a4296 2
the browser and restarts it.  If an expiration date isn't specified, the cookie
will remain active until the user quits the browser.
d4303 1
a4303 1
of ".capricorn.com", then the browser will return the cookie to
d4328 1
a4328 1
The interface to HTTP cookies is the B<cookie()> method:
d4345 1
a4345 1
Although browsers limit their cookie names to non-whitespace
d4416 13
a4428 5
=head1 WORKING WITH FRAMES

It's possible for CGI.pm scripts to write into several browser panels
and windows using the HTML 4 frame mechanism.  There are three
techniques for defining new frames programmatically:
d4451 6
a4456 6
This will tell the browser to load the output of your script into the
frame named "ResultsWindow".  If a frame of that name doesn't already
exist, the browser will pop up a new window and load your script's
document into that.  There are a number of magic names that you can
use for targets.  See the frame documents on Netscape's home pages for
details.
a4487 4
You may also specify the type of the stylesheet by adding the optional
B<-type> parameter to the hash pointed to by B<-style>.  If not
specified, the style defaults to 'text/css'.

d4597 7
a4603 2
As a shortcut, you can interpolate the entire CGI object into a string
and it will be replaced with the a nice HTML dump shown above:
d4615 1
a4615 1
=item B<Accept()>
d4617 8
a4624 9
Return a list of MIME types that the remote browser accepts. If you
give this method a single argument corresponding to a MIME type, as in
$query->Accept('text/html'), it will return a floating point value
corresponding to the browser's preference for this type from 0.0
(don't want) to 1.0.  Glob types (e.g. text/*) in the browser's accept
list are handled correctly.

Note that the capitalization changed between version 2.43 and 2.44 in
order to avoid conflict with Perl's accept() function.
d4628 6
a4633 12
Returns the HTTP_COOKIE variable, an HTTP extension implemented by
Netscape browsers version 1.1 and higher, and all versions of Internet
Explorer.  Cookies have a special format, and this method call just
returns the raw form (?cookie dough).  See cookie() for ways of
setting and retrieving cooked cookies.

Called with no parameters, raw_cookie() returns the packed cookie
structure.  You can separate it into individual cookies by splitting
on the character sequence "; ".  Called with the name of a cookie,
retrieves the B<unescaped> form of the cookie.  You can use the
regular cookie() method to get the names, or use the raw_fetch()
method from the CGI::Cookie module.
d4708 4
a4711 3
Attempt to obtain the remote user's name, using a variety of different
techniques.  This only works with older browsers such as Mosaic.
Newer browsers do not report the user name for privacy reasons!
d4720 42
a4761 1
=head1 USING NPH SCRIPTS
d4763 2
a4764 5
NPH, or "no-parsed-header", scripts bypass the server completely by
sending the complete HTTP header directly to the browser.  This has
slight performance benefits, but is of most use for taking advantage
of HTTP extensions that are not directly supported by your server,
such as server push and PICS headers.
d4766 2
a4767 5
Servers use a variety of conventions for designating CGI scripts as
NPH.  Many Unix servers look at the beginning of the script's name for
the prefix "nph-".  The Macintosh WebSTAR server and Microsoft's
Internet Information Server, in contrast, try to decide whether a
program is an NPH script by examining the first line of script output.
d4769 2
d4772 2
a4773 4
CGI.pm supports NPH scripts with a special NPH mode.  When in this
mode, CGI.pm will output the necessary extra header information when
the header() and redirect() methods are
called.
d4775 2
a4776 4
The Microsoft Internet Information Server requires NPH mode.  As of version
2.30, CGI.pm will automatically detect when the script is running under IIS
and put itself into this mode.  You do not need to do this manually, although
it won't hurt anything if you do.
d4778 3
a4780 1
There are a number of ways to put CGI.pm into NPH mode:
d4782 2
a4783 1
=over 4
d4785 2
a4786 1
=item In the B<use> statement 
d4788 1
a4788 2
Simply add the "-nph" pragmato the list of symbols to be imported into
your script:
d4790 4
a4793 1
      use CGI qw(:standard -nph)
d4795 1
a4795 1
=item By calling the B<nph()> method:
d4797 2
a4798 1
Call B<nph()> with a non-zero parameter at any point after using CGI.pm in your program.
d4800 2
a4801 1
      CGI->nph(1)
d4803 1
a4803 1
=item By using B<-nph> parameters in the B<header()> and B<redirect()>  statements:
d4805 2
a4806 1
      print $q->header(-nph=>1);
d4808 1
a4808 1
=back
d4810 4
a4813 1
=head1 Server Push
d4815 3
a4817 19
CGI.pm provides three simple functions for producing multipart
documents of the type needed to implement server push.  These
functions were graciously provided by Ed Jordan <ed@@fidalgo.net>.  To
import these into your namespace, you must import the ":push" set.
You are also advised to put the script into NPH mode and to set $| to
1 to avoid buffering problems.

Here is a simple script that demonstrates server push:

  #!/usr/local/bin/perl
  use CGI qw/:push -nph/;
  $| = 1;
  print multipart_init(-boundary=>'----------------here we go!');
  while (1) {
      print multipart_start(-type=>'text/plain'),
            "The current time is ",scalar(localtime),"\n",
            multipart_end;
      sleep 1;
  }
d4819 2
a4820 5
This script initializes server push by calling B<multipart_init()>.
It then enters an infinite loop in which it begins a new multipart
section by calling B<multipart_start()>, prints the current local time,
and ends a multipart section with B<multipart_end()>.  It then sleeps
a second, and begins again.
d4824 6
a4829 3
=item multipart_init()
     
  multipart_init(-boundary=>$boundary);
d4831 1
a4831 3
Initialize the multipart system.  The -boundary argument specifies
what MIME boundary string to use to separate parts of the document.
If not provided, CGI.pm chooses a reasonable boundary for you.
d4833 1
a4833 1
=item multipart_start()
d4835 1
a4835 1
  multipart_start(-type=>$type)
d4837 1
a4837 2
Start a new part of the multipart document using the specified MIME
type.  If not specified, text/html is assumed.
d4839 2
a4840 1
=item multipart_end()
d4842 1
a4842 1
  multipart_end()
d4844 1
a4844 2
End a part.  You must remember to call multipart_end() once for each
multipart_start().
d4846 1
a4846 1
=back
d4848 2
a4849 2
Users interested in server push applications should also have a look
at the CGI::Push module.
d4851 1
a4851 1
=head1 Avoiding Denial of Service Attacks
d4853 1
a4853 25
A potential problem with CGI.pm is that, by default, it attempts to
process form POSTings no matter how large they are.  A wily hacker
could attack your site by sending a CGI script a huge POST of many
megabytes.  CGI.pm will attempt to read the entire POST into a
variable, growing hugely in size until it runs out of memory.  While
the script attempts to allocate the memory the system may slow down
dramatically.  This is a form of denial of service attack.

Another possible attack is for the remote user to force CGI.pm to
accept a huge file upload.  CGI.pm will accept the upload and store it
in a temporary directory even if your script doesn't expect to receive
an uploaded file.  CGI.pm will delete the file automatically when it
terminates, but in the meantime the remote user may have filled up the
server's disk space, causing problems for other programs.

The best way to avoid denial of service attacks is to limit the amount
of memory, CPU time and disk space that CGI scripts can use.  Some Web
servers come with built-in facilities to accomplish this. In other
cases, you can use the shell I<limit> or I<ulimit>
commands to put ceilings on CGI resource usage.


CGI.pm also has some simple built-in protections against denial of
service attacks, but you must activate them before you can use them.
These take the form of two global variables in the CGI name space:
d4855 1
a4855 1
=over 4
d4857 2
a4858 1
=item B<$CGI::POST_MAX>
d4860 1
a4860 7
If set to a non-negative integer, this variable puts a ceiling
on the size of POSTings, in bytes.  If CGI.pm detects a POST
that is greater than the ceiling, it will immediately exit with an error
message.  This value will affect both ordinary POSTs and
multipart POSTs, meaning that it limits the maximum size of file
uploads as well.  You should set this to a reasonably high
value, such as 1 megabyte.
d4862 3
a4864 1
=item B<$CGI::DISABLE_UPLOADS>
d4866 7
a4872 2
If set to a non-zero value, this will disable file uploads
completely.  Other fill-out form values will work as usual.
d4874 17
a4890 1
=back
d4892 7
a4898 1
You can use these variables in either of two ways.
d4900 1
a4900 1
=over 4
d4902 5
a4906 1
=item B<1. On a script-by-script basis>
d4908 5
a4912 1
Set the variable at the top of the script, right after the "use" statement:
a4913 4
    use CGI qw/:standard/;
    use CGI::Carp 'fatalsToBrowser';
    $CGI::POST_MAX=1024 * 100;  # max 100K posts
    $CGI::DISABLE_UPLOADS = 1;  # no uploads
d4915 4
a4918 1
=item B<2. Globally for all scripts>
d4920 4
a4923 4
Open up CGI.pm, find the definitions for $POST_MAX and 
$DISABLE_UPLOADS, and set them to the desired values.  You'll 
find them towards the top of the file in a subroutine named 
initialize_globals().
d4925 1
a4925 1
=back
d4927 1
a4927 6
Since an attempt to send a POST larger than $POST_MAX bytes
will cause a fatal error, you might want to use CGI::Carp to echo the
fatal error message to the browser window as shown in the example
above.  Otherwise the remote user will see only a generic "Internal
Server" error message.  See the L<CGI::Carp> manual page for more
details.
d4929 2
a4930 1
=head1 COMPATIBILITY WITH CGI-LIB.PL
d4932 1
a4932 3
To make it easier to port existing programs that use cgi-lib.pl
the compatibility routine "ReadParse" is provided.  Porting is
simple:
d4934 1
a4934 4
OLD VERSION
    require "cgi-lib.pl";
    &ReadParse;
    print "The value of the antique is $in{antique}.\n";
d4936 1
a4936 4
NEW VERSION
    use CGI;
    CGI::ReadParse
    print "The value of the antique is $in{antique}.\n";
d4938 1
a4938 5
CGI.pm's ReadParse() routine creates a tied variable named %in,
which can be accessed to obtain the query variables.  Like
ReadParse, you can also provide your own variable.  Infrequently
used features of ReadParse, such as the creation of @@in and $in 
variables, are not supported.
d4940 1
a4940 2
Once you use ReadParse, you can retrieve the query object itself
this way:
d4942 1
a4942 3
    $q = $in{CGI};
    print $q->textfield(-name=>'wow',
			-value=>'does this really work?');
d4944 1
a4944 2
This allows you to start using the more interesting features
of CGI.pm without rewriting your old scripts from scratch.
d4948 5
a4952 4
Copyright 1995-1998, Lincoln D. Stein.  All rights reserved.  

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
d4954 2
a4955 6
Address bug reports and comments to: lstein@@cshl.org.  When sending
bug reports, please provide the version of CGI.pm, the version of
Perl, the name and version of your Web server, and the name and
version of the operating system you are using.  If the problem is even
remotely browser dependent, please provide information about the
affected browers as well.
d4975 1
a4975 1
=item Laurent Delfosse (delfosse@@delfosse.com)
a4998 4
=item Doug MacEachern (dougm@@opengroup.org)

=item Robin Houston (robin@@oneworld.org)

d5063 1
a5063 1
	   print "<P>",$query->Reset;
d5104 2
a5105 2
L<CGI::Base>, L<CGI::Form>, L<CGI::Push>, L<CGI::Fast>,
L<CGI::Pretty>
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d20 2
a21 2
$CGI::revision = '$Id: CGI.pm,v 1.19 1999/08/31 17:04:37 lstein Exp $';
$CGI::VERSION='2.56';
a60 3
    # Automatically determined -- don't change
    $EBCDIC = 0;

d92 1
a92 1
  $OS = 'WINDOWS';
d94 1
a94 5
  $OS = 'VMS';
} elsif ($OS=~/bsdos/i) {
  $OS = 'UNIX';
} elsif ($OS=~/dos/i) {
  $OS = 'DOS';
d104 1
a104 1
$needs_binmode = $OS=~/^(WINDOWS|DOS|OS2|MSWin)/;
d115 1
a115 1
    UNIX=>'/', OS2=>'\\', WINDOWS=>'\\', DOS=>'\\', MACINTOSH=>':', VMS=>'/'
d126 1
a126 1
    ($MOD_PERL = $ENV{'GATEWAY_INTERFACE'} =~ /^CGI-Perl\//))
d142 1
a142 1
  $CRLF = "\n";
d144 1
a144 1
  $CRLF= "\r\n";
d146 1
a146 22
  $CRLF = "\015\012";
}

if ($EBCDIC) {
@@A2E = (
  0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 21, 11, 12, 13, 14, 15,
 16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
 64, 90,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
215,216,217,226,227,228,229,230,231,232,233,173,224,189, 95,109,
121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
151,152,153,162,163,164,165,166,167,168,169,192, 79,208,161,  7,
 32, 33, 34, 35, 36, 37,  6, 23, 40, 41, 42, 43, 44,  9, 10, 27,
 48, 49, 26, 51, 52, 53, 54,  8, 56, 57, 58, 59,  4, 20, 62,255,
 65,170, 74,177,159,178,106,181,187,180,154,138,176,202,175,188,
144,143,234,250,190,160,182,179,157,218,155,139,183,184,185,171,
100,101, 98,102, 99,103,158,104,116,113,114,115,120,117,118,119,
172,105,237,238,235,239,236,191,128,253,254,251,252,186,174, 89,
 68, 69, 66, 70, 67, 71,156, 72, 84, 81, 82, 83, 88, 85, 86, 87,
140, 73,205,206,203,207,204,225,112,221,222,219,220,141,142,223
      );
d167 2
a168 2
		':cgi'=>[qw/param upload path_info path_translated url self_url script_name cookie Dump
			 raw_cookie request_method query_string Accept user_agent remote_host content_type
d172 1
a172 2
			 remote_user user_name header redirect import_names put 
			 Delete Delete_all url_param cgi_error/],
d175 1
a175 1
		':cgi-lib' => [qw/ReadParse PrintHeader HtmlTop HtmlBot SplitParam Vars/],
d331 1
a331 1
    if (@@QUERY_PARAM && !defined($initializer)) {
d340 2
a341 1

a345 6
      # avoid unreasonably large postings
      if (($POST_MAX > 0) && ($content_length > $POST_MAX)) {
	  $self->cgi_error("413 Request entity too large");
	  last METHOD;
      }

d397 1
a397 5
	  if ($MOD_PERL) {
	      $query_string = Apache->request->args;
	  } else {
	      $query_string = $ENV{'QUERY_STRING'} if defined $ENV{'QUERY_STRING'};
	  }
d420 1
a420 1
    if (defined $query_string && $query_string) {
a475 7
# get/set last cgi_error
sub cgi_error {
    my ($self,$err) = self_or_default(@@_);
    $self->{'.cgi_error'} = $err if defined $err;
    return $self->{'.cgi_error'};
}

d478 6
a483 10
  shift() if ref($_[0]) || (defined $_[1] && $_[0] eq $DefaultClass);
  my $todecode = shift;
  return undef unless defined($todecode);
  $todecode =~ tr/+/ /;       # pluses become spaces
    if ($EBCDIC) {
      $todecode =~ s/%([0-9a-fA-F]{2})/pack("c",$A2E[hex($1)])/ge;
    } else {
      $todecode =~ s/%([0-9a-fA-F]{2})/pack("c",hex($1))/ge;
    }
  return $todecode;
d488 5
a492 5
  shift() if ref($_[0]) || (defined $_[1] && $_[0] eq $DefaultClass);
  my $toencode = shift;
  return undef unless defined($toencode);
  $toencode=~s/([^a-zA-Z0-9_.-])/uc sprintf("%%%02x",ord($1))/eg;
  return $toencode;
d539 1
a539 1
    my $func = qq(
d542 1
a542 1
#		(!ref(\$_[0]) && \$_[0] eq \$CGI::DefaultClass) ||
d552 1
a552 1
	);
d653 1
a653 1
    CORE::delete($sub->{$func_name});  #free storage
d749 2
a750 2
    CORE::delete $self->{$name};
    CORE::delete $self->{'.fieldnames'}->{$name};
d765 1
a765 1
    if ($delete || $MOD_PERL || exists $ENV{'FCGI_ROLE'}) {
d796 1
a796 1
    $self->{'keywords'}=[@@values] if @@values;
a803 12
'Vars' => <<'END_OF_FUNC',
sub Vars {
    my $q = shift;
    my %in;
    tie(%in,CGI,$q);
    return %in if wantarray;
    return \%in;
}
END_OF_FUNC

# These are some tie() interfaces for compatibility
# with Steve Brenner's cgi-lib.pl routines
d861 1
a861 2
    return $_[1] if defined $_[1];
    return $Q || new shift;
a1033 1
            $value =~ s/\n/<BR>\n/g;
d1068 1
a1068 1
	    print $filehandle "$escaped_param=",escape("$value"),"\n";
d1330 1
a1330 1
	push(@@result,qq/<LINK REL="stylesheet" TYPE="$type" HREF="$src">/) if $src;
d1351 1
a1351 1
				 ref($script) eq 'ARRAY' ? @@$script : %$script);
d1363 1
a1363 1
	push(@@result,script({@@satts},$code || ''));
d1463 1
a1463 2
    return wantarray ? ($self->get_fields,"</FORM>") : 
                        $self->get_fields ."\n</FORM>";
d1730 3
a1732 1
    return qq{<INPUT TYPE="checkbox" NAME="$name" VALUE="$value"$checked$other>$the_label};
d1803 2
a1804 1
    my ($self,$toencode) = self_or_default(@@_);
d1852 2
a1853 2
    unshift(@@$colheaders,'') if @@$colheaders && @@$rowheaders;
    $result .= "<TR>" if @@$colheaders;
d1859 1
a1859 1
	$result .= "<TH>$rowheaders->[$row]</TH>" if @@$rowheaders;
d2072 1
a2072 1
	$_ = defined($_) ? $self->escapeHTML($_) : '';
a2137 14
    my $path = $self->path_info;
    my $script_name;
    if (exists($ENV{REQUEST_URI})) {
        my $index;
	$script_name = $ENV{REQUEST_URI};
        # strip query string
        substr($script_name,$index) = '' if ($index = index($script_name,'?')) >= 0;
        # and path
        substr($script_name,$index) = '' if exists($ENV{PATH_INFO})
                                     and ($index = rindex($script_name,$ENV{PATH_INFO})) >= 0;
    } else {
	$script_name = $self->script_name;
    }

d2151 1
a2151 1
	$url .= $script_name;
d2153 1
a2153 1
	($url) = $script_name =~ m!([^/]+)$!;
d2155 1
a2155 1
	$url = $script_name;
d2157 1
a2157 1
    $url .= $path if $path_info and defined $path;
d2209 1
a2209 1
    return CGI::Cookie->new(@@param);
a2238 2
    } elsif ($time=~/^\d+/) {
        return $time;
d2250 1
a2250 1
# Thanks to Mark Fisher for this.
a2332 9
#### Method: content_type
# Returns the content_type string
####
'content_type' => <<'END_OF_FUNC',
sub content_type {
    return $ENV{'CONTENT_TYPE'};
}
END_OF_FUNC

a2355 1
            next unless defined $value;
a2558 1
    $parameter =~ tr/-/_/;
a2576 1
    $parameter =~ tr/-/_/;
d2757 1
a2757 5

	unless (%header) {
	    $self->cgi_error("400 Bad request (malformed multipart POST)");
	    return;
	}
d2769 1
a2769 1
	if ( !defined($filename) || $filename eq '' ) {
d2787 5
a2791 9
	  # choose a relatively unpredictable tmpfile sequence number
          my $seqno = unpack("%16C*",join('',localtime,values %ENV));
          for (my $cnt=10;$cnt>0;$cnt--) {
	    next unless $tmpfile = new TempFile($seqno);
	    $tmp = $tmpfile->as_string;
	    last if defined($filehandle = Fh->new($filename,$tmp,$PRIVATE_TEMPFILES));
            $seqno += int rand(100);
          }
          die "CGI open of tmpfile: $!\n" unless $filehandle;
d2793 1
d2807 1
a2807 1
	  $self->{'.tmpfiles'}->{fileno($filehandle)}= {
a2816 10
'upload' =><<'END_OF_FUNC',
sub upload {
    my($self,$param_name) = self_or_default(@@_);
    my $param = $self->param($param_name);
    return unless $param;
    return unless ref($param) && fileno($param);
    return $param;
}
END_OF_FUNC

d2820 2
a2821 2
    return $self->{'.tmpfiles'}->{fileno($filename)}->{name} ?
	$self->{'.tmpfiles'}->{fileno($filename)}->{name}->as_string
d2829 1
a2829 1
    return $self->{'.tmpfiles'}->{fileno($filename)}->{info};
d2881 1
a2881 1
    (my $i = $$self) =~ s/^\*(\w+::fh\d{5})+//; 
d2907 4
a2910 2
    my $ref = \*{'Fh::' .  ++$FH . quotemeta($name)};
    sysopen($ref,$file,Fcntl::O_RDWR()|Fcntl::O_CREAT()|Fcntl::O_EXCL(),0600) || return;
d2912 1
a2912 1
    CORE::delete $Fh::{$FH};
d2979 1
a2979 1
	$boundary = "--$boundary" unless CGI::user_agent('MSIE\s+3\.0[12];\s*Mac');
d3178 1
a3178 2
	   "C:${SL}temp","${SL}tmp","${SL}temp",
	   "${vol}${SL}Temporary Items","${SL}sys\$scratch",
a3179 10
    unshift(@@TEMP,$ENV{'TMPDIR'}) if exists $ENV{'TMPDIR'};

    #
    #    unshift(@@TEMP,(getpwuid($<))[7].'/tmp') if $CGI::OS eq 'UNIX';
    # Rob: getpwuid() is unfortunately UNIX specific. On brain dead OS'es this
    #    : can generate a 'getpwuid() not implemented' exception, even though
    #    : it's never called.  Found under DOS/Win with the DJGPP perl port.
    #    : Refer to getpwuid() only at run-time if we're fortunate and have  UNIX.
    unshift(@@TEMP,(eval {(getpwuid($<))[7]}).'/tmp') if $CGI::OS eq 'UNIX';

d3186 1
d3202 8
a3209 9
    my($package,$sequence) = @@_;
    my $filename;
    for (my $i = 0; $i < $MAXTRIES; $i++) {
	last if ! -f ($filename = sprintf("${TMPDIRECTORY}${SL}CGItemp%d",$sequence++));
    }
    # untaint the darn thing
    return unless $filename =~ m!^([a-zA-Z0-9_ '":/\\]+)$!;
    $filename = $1;
    return bless \$filename;
d3243 1
d3325 1
a3325 1
   #!/usr/local/bin/perl -w
a3642 30
=head2 FETCHING THE PARAMETER LIST AS A HASH:

    $params = $q->Vars;
    print $params->{'address'};
    @@foo = split("\0",$params->{'foo'});
    %params = $q->Vars;

    use CGI ':cgi-lib';
    $params = Vars;

Many people want to fetch the entire parameter list as a hash in which
the keys are the names of the CGI parameters, and the values are the
parameters' values.  The Vars() method does this.  Called in a scalar
context, it returns the parameter list as a tied hash reference.
Changing a key changes the value of the parameter in the underlying
CGI parameter list.  Called in an array context, it returns the
parameter list as an ordinary hash.  This allows you to read the
contents of the parameter list, but not to change it.

When using this, the thing you must watch out for are multivalued CGI
parameters.  Because a hash cannot distinguish between scalar and
array context, multivalued parameters will be returned as a packed
string, separated by the "\0" (null) character.  You must split this
packed string in order to get at the individual values.  This is the
convention introduced long ago by Steve Brenner in his cgi-lib.pl
module for Perl version 4.

If you wish to use Vars() as a function, import the I<:cgi-lib> set of
function calls (also see the section on CGI-LIB compatibility).

d3689 2
a3690 2

  http://stein.cshl.org/boulder/
a3696 23
=head2 RETRIEVING CGI ERRORS

Errors can occur while processing user input, particularly when
processing uploaded files.  When these errors occur, CGI will stop
processing and return an empty parameter list.  You can test for
the existence and nature of errors using the I<cgi_error()> function.
The error messages are formatted as HTTP status codes. You can either
incorporate the error text into an HTML page, or use it as the value
of the HTTP status:

    my $error = $q->cgi_error;
    if ($error) {
	print $q->header(-status=>$error),
	      $q->start_html('Problems'),
              $q->h2('Request not processed'),
	      $q->strong($error);
        exit 0;
    }

When using the function-oriented interface (see the next section),
errors may only occur the first time you call I<param()>. Be ready
for this!

d3757 1
a3757 1
code, where the variable %EXPORT_TAGS is defined.
d3905 1
a3905 1

d3910 9
a3918 29
CGI.pm can process uploaded file. Ordinarily it spools the uploaded
file to a temporary directory, then deletes the file when done.
However, this opens the risk of eavesdropping as described in the file
upload section.  Another CGI script author could peek at this data
during the upload, even if it is confidential information. On Unix
systems, the -private_tempfiles pragma will cause the temporary file
to be unlinked as soon as it is opened and before any data is written
into it, reducing, but not eliminating the risk of eavesdropping
(there is still a potential race condition).  To make life harder for
the attacker, the program chooses tempfile names by calculating a 32
bit checksum of the incoming HTTP headers.

To ensure that the temporary file cannot be read by other CGI scripts,
use suEXEC or a CGI wrapper program to run your script.  The temporary
file is created with mode 0600 (neither world nor group readable).

The temporary directory is selected using the following algorithm:

    1. if the current user (e.g. "nobody") has a directory named
    "tmp" in its home directory, use that (Unix systems only).

    2. if the environment variable TMPDIR exists, use the location
    indicated.

    3. Otherwise try the locations /usr/tmp, /var/tmp, C:\temp,
    /tmp, /temp, ::Temporary Items, and \WWW_ROOT.

Each of these locations is checked that it is a directory and is
writable.  If not, the algorithm tries the next choice.
d4138 2
a4139 2
    print start_html(-head=>Link({-rel=>'next',
		     -href=>'http://www.capricorn.com/s2.html'}));
d4144 5
a4148 5
    print start_html(-head=>[ 
                             Link({-rel=>'next',
				   -href=>'http://www.capricorn.com/s2.html'}),
		             Link({-rel=>'previous',
				   -href=>'http://www.capricorn.com/s1.html'})
d4208 2
a4209 2
	       -script=>{-language=>'PERLSCRIPT',
			 -code=>'print "hello world!\n;"'}
d4218 4
a4221 4
     print $q->start_html(-title=>'The Riddle of the Sphinx',
                          -script=>[
                                    { -language => 'JavaScript1.0',
                                      -src      => '/javascript/utilities10.js'
d4223 2
a4224 2
                                    { -language => 'JavaScript1.1',
                                      -src      => '/javascript/utilities11.js'
d4226 2
a4227 2
                                    { -language => 'JavaScript1.2',
                                      -src      => '/javascript/utilities12.js'
d4229 2
a4230 2
                                    { -language => 'JavaScript28.2',
                                      -src      => '/javascript/utilities219.js'
d4385 1
a4385 1
		     "there lived a Minotaur named",
d4432 1
a4432 1

d4450 1
a4450 1

d4584 1
a4584 1

d4614 1
a4614 1

d4823 1
a4823 1
by calling param():
d4827 13
a4839 6
Different browsers will return slightly different things for the
name.  Some browsers return the filename only.  Others return the full
path to the file, using the path conventions of the user's machine.
Regardless, the name returned is always the name of the file on the
I<user's> machine, and is unrelated to the name of the temporary file
that CGI.pm creates during upload spooling (see below).
a4854 19
However, there are problems with the dual nature of the upload fields.
If you C<use strict>, then Perl will complain when you try to use a
string as a filehandle.  You can get around this by placing the file
reading code in a block containing the C<no strict> pragma.  More
seriously, it is possible for the remote user to type garbage into the
upload field, in which case what you get from param() is not a
filehandle at all, but a string.

To be safe, use the I<upload()> function (new in version 2.47).  When
called with the name of an upload field, I<upload()> returns a
filehandle, or undef if the parameter is not a valid filehandle.

     $fh = $query->upload('uploaded_file');
     while (<$fh>) {
	   print;
     }

This is the recommended idiom.

d4870 1
a4870 19
Otherwise you may find that binary files are corrupted during file
uploads.

There are occasionally problems involving parsing the uploaded file.
This usually happens when the user presses "Stop" before the upload is
finished.  In this case, CGI.pm will return undef for the name of the
uploaded file and set I<cgi_error()> to the string "400 Bad request
(malformed multipart POST)".  This error message is designed so that
you can incorporate it into a status code to be sent to the browser.
Example:

   $file = $query->upload('uploaded_file');
   if (!$file && $query->cgi_error) {
      print $query->header(-status=>$query->cgi_error);
      exit 0;
   }

You are free to create a custom HTML page to complain about the error,
if you wish.
d5028 1
a5028 1

d5566 1
a5566 1

d5703 1
a5703 1

a5840 26
=item B<content_type()>

Returns the content_type of data submitted in a POST, generally 
multipart/form-data or application/x-www-form-urlencoded

=item B<http()>

Called with no arguments returns the list of HTTP environment
variables, including such things as HTTP_USER_AGENT,
HTTP_ACCEPT_LANGUAGE, and HTTP_ACCEPT_CHARSET, corresponding to the
like-named HTTP header fields in the request.  Called with the name of
an HTTP header field, returns its value.  Capitalization and the use
of hyphens versus underscores are not significant.

For example, all three of these examples are equivalent:

   $requested_language = $q->http('Accept-language');
   $requested_language = $q->http('Accept_language');
   $requested_language = $q->http('HTTP_ACCEPT_LANGUAGE');

=item B<https()>

The same as I<http()>, but operates on the HTTPS environment variables
present when the SSL protocol is in effect.  Can be used to determine
whether SSL is turned on.

d5922 1
a5922 1

d6017 6
a6022 20
An attempt to send a POST larger than $POST_MAX bytes will cause
I<param()> to return an empty CGI parameter list.  You can test for
this event by checking I<cgi_error()>, either after you create the CGI
object or, if you are using the function-oriented interface, call
<param()> for the first time.  If the POST was intercepted, then
cgi_error() will return the message "413 POST too large".

This error message is actually defined by the HTTP protocol, and is
designed to be returned to the browser as the CGI script's status
 code.  For example:

   $uploaded_file = param('upload');
   if (!$uploaded_file && cgi_error()) {
      print header(-status=>cgi_error());
      exit 0;
   }

However it isn't clear that any browser currently knows what to do
with this status code.  It might be better just to create an
HTML page that warns the user of the problem.
d6026 3
a6028 2
To make it easier to port existing programs that use cgi-lib.pl the
compatibility routine "ReadParse" is provided.  Porting is simple:
d6126 1
a6126 1

d6128 1
a6128 1

d6138 1
a6138 1

d6141 1
a6141 1

d6146 1
a6146 1

d6153 1
a6153 1

d6159 1
a6159 1

d6164 1
a6164 1

d6166 1
a6166 1

d6174 1
a6174 1

d6179 2
a6180 2

	   print "<P>",$query->reset;
d6186 1
a6186 1

d6199 1
a6199 1

@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a2 1
use Carp 'croak';
d20 2
a21 2
$CGI::revision = '$Id: CGI.pm,v 1.49 2001/02/04 23:08:39 lstein Exp $';
$CGI::VERSION='2.752';
a25 4
use CGI::Util qw(rearrange make_attributes unescape escape expires);

use constant XHTML_DTD => ['-//W3C//DTD XHTML Basic 1.0//EN',
                           'http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd'];
a30 3
    
    # Set this to 1 to generate XTML-compatible output
    $XHTML = 1;
d34 1
a34 8
    $DEFAULT_DTD = [ '-//W3C//DTD HTML 4.01 Transitional//EN',
		     'http://www.w3.org/TR/html4/loose.dtd' ] ;

    # Set this to 1 to enable NOSTICKY scripts
    # or: 
    #    1) use CGI qw(-nosticky)
    #    2) $CGI::nosticky(1)
    $NOSTICKY = 0;
d39 1
a39 1
    #    2) CGI::nph(1)
d43 3
a45 3
    # Set this to 1 to enable debugging from @@ARGV
    # Set to 2 to enable debugging from STDIN
    $DEBUG = 1;
d51 1
a51 1
    #    2) CGI::private_tempfiles(1);
d68 1
a68 1
    $USE_PARAM_SEMICOLONS = 1;
a74 2
    undef $QUERY_CHARSET;
    undef %QUERY_FIELDNAMES;
d94 1
a94 1
if ($OS =~ /^MSWin/i) {
d96 1
a96 1
} elsif ($OS =~ /^VMS/i) {
d98 3
a100 1
} elsif ($OS =~ /^dos/i) {
d102 1
a102 1
} elsif ($OS =~ /^MacOS/i) {
d104 1
a104 1
} elsif ($OS =~ /^os2/i) {
a105 2
} elsif ($OS =~ /^epoc/i) {
    $OS = 'EPOC';
d122 1
a122 2
    UNIX=>'/', OS2=>'\\', EPOC=>'/', 
    WINDOWS=>'\\', DOS=>'\\', MACINTOSH=>':', VMS=>'/'
d156 21
d187 1
a187 1
			   input Select option comment charset escapeHTML/],
d198 1
a198 1
			 virtual_host remote_ident auth_type http
d207 1
a207 1
		':push' => [qw/multipart_init multipart_start multipart_end multipart_final/],
d262 3
a264 3
    if ($MOD_PERL && defined Apache->request) {
      Apache->request->register_cleanup(\&CGI::_reset_globals);
      undef $NPH;
d294 1
a294 1
	($name,$value,@@other) = rearrange([NAME,[DEFAULT,VALUE,VALUES]],@@p);
d297 1
a297 1
	if (substr($p[0],0,1) eq '-') {
d325 1
a325 1
    return wantarray ? @@_ : $Q;
d360 1
a360 1
    if (defined(@@QUERY_PARAM) && !defined($initializer)) {
a363 2
	$self->charset($QUERY_CHARSET);
	$self->{'.fieldnames'} = {%QUERY_FIELDNAMES};
a371 3
    # set charset to the safe ISO-8859-1
    $self->charset('ISO-8859-1');

a434 1
	      $query_string ||= $ENV{'REDIRECT_QUERY_STRING'} if defined $ENV{'REDIRECT_QUERY_STRING'};
d453 1
a453 1
      $query_string = read_from_cmdline() if $DEBUG;
d458 2
a459 2
    if (defined $query_string && length $query_string) {
	if ($query_string =~ /[&=;]/) {
a481 1

d521 23
d551 1
a551 2
      next unless defined $_;
      $QUERY_PARAM{$_}=$self->{$_};
a552 2
    $QUERY_CHARSET = $self->charset;
    %QUERY_FIELDNAMES = %{$self->{'.fieldnames'}};
a560 1
	$value = '' unless defined $value;
a569 1
    return unless defined $param;
d589 7
a595 5
	sub $tagname {
            shift if \$_[0] && 
                    (ref(\$_[0]) &&
                     (substr(ref(\$_[0]),0,3) eq 'CGI' ||
                    UNIVERSAL::isa(\$_[0],'CGI')));
d598 1
a598 1
		my(\@@attr) = make_attributes(shift()||undef,1);
d603 1
a603 1
	$func .= qq! return "<\L$1\E\$attr>";} !;
d605 1
a605 1
	$func .= qq! return "<\L/$1\E>"; } !;
d608 3
a610 4
	    return \$XHTML ? "\L<$tagname\E\$attr />" : "\L<$tagname\E\$attr>" unless \@@_;
	    my(\$tag,\$untag) = ("\L<$tagname\E\$attr>","\L</$tagname>\E");
	    my \@@result = map { "\$tag\$_\$untag" } 
                              (ref(\$_[0]) eq 'ARRAY') ? \@@{\$_[0]} : "\@@_";
d623 41
d679 1
a679 1
	   croak("$AUTOLOAD: $@@") if $@@;
d695 1
a695 1
       croak("Undefined subroutine $AUTOLOAD\n") unless $code;
d699 1
a699 1
	   croak("$AUTOLOAD: $@@");
d714 1
a714 3
	$NOSTICKY++,             next if /^[:-]nosticky$/;
	$DEBUG=0,                next if /^[:-]no_?[Dd]ebug$/;
	$DEBUG=2,                next if /^[:-][Dd]ebug$/;
a715 3
	$XHTML++,                next if /^[:-]xhtml$/;
	$XHTML=0,                next if /^[:-]no_?xhtml$/;
	$USE_PARAM_SEMICOLONS=0, next if /^[:-]oldstyle_urls$/;
a738 6
sub charset {
  my ($self,$charset) = self_or_default(@@_);
  $self->{'.charset'} = $charset if defined $charset;
  $self->{'.charset'};
}

d756 16
a771 1
sub SERVER_PUSH { 'multipart/x-mixed-replace;boundary="' . shift() . '"'; }
d797 1
a797 2
    my($self,@@p) = self_or_default(@@_);
    my($name) = rearrange([NAME],@@p);
d923 1
a923 1
    return $Q ||= new shift;
d929 1
a929 5
    my $self = shift;
    my $tag  = shift;
    my $vals = shift;
    my @@vals = index($vals,"\0")!=-1 ? split("\0",$vals) : $vals;
    $self->param(-name=>$tag,-value=>\@@vals);
d979 1
a979 1
    my($name,$value) = rearrange([NAME,[VALUE,VALUES]],@@p);
d1033 15
d1079 1
a1079 1
#### Method: Dump
d1084 2
a1085 2
'Dump' => <<'END_OF_FUNC',
sub Dump {
d1112 1
a1112 1
    &Dump(@@_);
a1133 3
    foreach (keys %{$self->{'.fieldnames'}}) {
          print $filehandle ".cgifields=",escape("$_"),"\n";
    }
d1162 1
a1162 1
# This has to be NPH on most web servers, and it is advisable to set $| = 1
d1165 1
a1165 1
# contribution, updated by Andrew Benham (adsb@@bigfoot.com)
d1170 1
a1170 1
    my($boundary,@@other) = rearrange([BOUNDARY],@@p);
d1172 1
a1172 2
    $self->{'separator'} = "$CRLF--$boundary$CRLF";
    $self->{'final_separator'} = "$CRLF--$boundary--$CRLF";
d1178 1
a1178 1
    ) . "WARNING: YOUR BROWSER DOESN'T SUPPORT THIS SERVER-PUSH TECHNOLOGY." . $self->multipart_end;
d1187 1
a1187 1
# contribution, updated by Andrew Benham (adsb@@bigfoot.com)
a1190 1
    my(@@header);
d1192 1
a1192 1
    my($type,@@other) = rearrange([TYPE],@@p);
d1194 4
a1197 11
    push(@@header,"Content-Type: $type");

    # rearrange() was designed for the HTML portion, so we
    # need to fix it up a little.
    foreach (@@other) {
        next unless my($header,$value) = /([^\s=]+)=\"?(.+?)\"?$/;
	($_ = $header) =~ s/^(\w)(.*)/$1 . lc ($2) . ': '.$self->unescapeHTML($value)/e;
    }
    push(@@header,@@other);
    my $header = join($CRLF,@@header)."${CRLF}${CRLF}";
    return $header;
d1203 1
a1203 1
# Return a MIME boundary separator for server-push, end of section
a1215 13
#### Method: multipart_final
# Return a MIME boundary separator for server-push, end of all sections
#
# Contributed by Andrew Benham (adsb@@bigfoot.com)
####
'multipart_final' => <<'END_OF_FUNC',
sub multipart_final {
    my($self,@@p) = self_or_default(@@_);
    return $self->{'final_separator'} . "WARNING: YOUR BROWSER DOESN'T SUPPORT THIS SERVER-PUSH TECHNOLOGY." . $CRLF;
}
END_OF_FUNC


d1227 3
a1229 12
    my($type,$status,$cookie,$target,$expires,$nph,$charset,$attachment,@@other) = 
	rearrange([['TYPE','CONTENT_TYPE','CONTENT-TYPE'],
			    'STATUS',['COOKIE','COOKIES'],'TARGET',
                            'EXPIRES','NPH','CHARSET',
                            'ATTACHMENT'],@@p);

    $nph     ||= $NPH;
    if (defined $charset) {
      $self->charset($charset);
    } else {
      $charset = $self->charset;
    }
d1231 1
d1236 1
a1236 1
	($_ = $header) =~ s/^(\w)(.*)/$1 . lc ($2) . ': '.$self->unescapeHTML($value)/e;
a1239 1
    $type .= "; charset=$charset" if $type ne '' and $type =~ m!^text/! and $type !~ /\bcharset\b/;
a1243 1
    push(@@header,"Server: " . &server_software()) if $nph;
d1260 1
a1260 1
    push(@@header,"Date: " . expires(0,'http')) if $expires || $cookie || $nph;
a1261 1
    push(@@header,"Content-Disposition: attachment; filename=\"$attachment\"") if $attachment;
d1299 2
a1300 2
    my($url,$target,$cookie,$nph,@@other) = rearrange([[LOCATION,URI,URL],TARGET,COOKIE,NPH],@@p);
    $url ||= $self->self_url;
d1337 2
a1338 2
    my($title,$author,$base,$xbase,$script,$noscript,$target,$meta,$head,$style,$dtd,$lang,@@other) = 
	rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,META,HEAD,STYLE,DTD,LANG],@@p);
d1344 5
a1348 27
    $lang ||= 'en-US';
    my(@@result,$xml_dtd);
    if ($dtd) {
        if (defined(ref($dtd)) and (ref($dtd) eq 'ARRAY')) {
            $dtd = $DEFAULT_DTD unless $dtd->[0] =~ m|^-//|;
        } else {
            $dtd = $DEFAULT_DTD unless $dtd =~ m|^-//|;
        }
    } else {
        $dtd = $XHTML ? XHTML_DTD : $DEFAULT_DTD;
    }

    $xml_dtd++ if ref($dtd) eq 'ARRAY' && $dtd->[0] =~ /\bXHTML\b/i;
    $xml_dtd++ if ref($dtd) eq '' && $dtd =~ /\bXHTML\b/i;
    push @@result,q(<?xml version="1.0" encoding="utf-8"?>) if $xml_dtd; 

    if (ref($dtd) && ref($dtd) eq 'ARRAY') {
        push(@@result,qq(<!DOCTYPE html\n\tPUBLIC "$dtd->[0]"\n\t"$dtd->[1]">));
    } else {
        push(@@result,qq(<!DOCTYPE html\n\tPUBLIC "$dtd">));
    }
    push(@@result,$XHTML ? qq(<html xmlns="http://www.w3.org/1999/xhtml" lang="$lang"><head><title>$title</title>)
                        : qq(<html lang="$lang"><head><title>$title</title>));
	if (defined $author) {
    push(@@result,$XHTML ? "<link rev=\"made\" href=\"mailto:$author\" />"
								: "<link rev=\"made\" href=\"mailto:$author\">");
	}
d1352 2
a1353 2
	my $t = $target ? qq/ target="$target"/ : '';
	push(@@result,$XHTML ? qq(<base href="$href"$t />) : qq(<base href="$href"$t>));
d1357 1
a1357 2
	foreach (keys %$meta) { push(@@result,$XHTML ? qq(<meta name="$_" content="$meta->{$_}" />) 
			: qq(<meta name="$_" content="$meta->{$_}">)); }
d1368 1
a1368 1
<noscript>
d1370 1
a1370 1
</noscript>
d1374 1
a1374 1
    push(@@result,"</head><body$other>");
a1386 4

    my $cdata_start = $XHTML ? "\n<!--/* <![CDATA[ */" : "\n<!-- ";
    my $cdata_end   = $XHTML ? "\n/* ]]> */-->\n" : " -->\n";

d1388 7
a1394 20
     my($src,$code,$stype,@@other) =
         rearrange([SRC,CODE,TYPE],
                    '-foo'=>'bar', # a trick to allow the '-' to be omitted
                    ref($style) eq 'ARRAY' ? @@$style : %$style);
     $type = $stype if $stype;
     if (ref($src) eq "ARRAY") # Check to see if the $src variable is an array reference
     { # If it is, push a LINK tag for each one.
       foreach $src (@@$src)
       {
         push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" />)
                             : qq(<link rel="stylesheet" type="$type" href="$src">/)) if $src;
       }
     }
     else
     { # Otherwise, push the single -src, if it exists.
       push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" />)
                           : qq(<link rel="stylesheet" type="$type" href="$src">)
            ) if $src;
      }
     push(@@result,style({'type'=>$type},"$cdata_start\n$code\n$cdata_end")) if $code;
d1396 1
a1396 1
     push(@@result,style({'type'=>$type},"$cdata_start\n$style\n$cdata_end"));
d1402 1
a1406 1

d1411 2
a1412 2
	    ($src,$code,$language, $type) =
		rearrange([SRC,CODE,LANGUAGE,TYPE],
d1415 1
a1415 7
            # User may not have specified language
            $language ||= 'JavaScript';
            unless (defined $type) {
                $type = lc $language;
                # strip '1.2' from 'javascript1.2'
                $type =~ s/^(\D+).*$/text\/$1/;
            }
d1417 1
a1417 1
	    ($src,$code,$language, $type) = ('',$script,'JavaScript', 'text/javascript');
a1418 10

    my $comment = '//';  # javascript by default
    $comment = '#' if $type=~/perl|tcl/i;
    $comment = "'" if $type=~/vbscript/i;

    my $cdata_start  =  "\n<!-- Hide script\n";
    $cdata_start    .= "$comment<![CDATA[\n"  if $XHTML; 
    my $cdata_end    = $XHTML ? "\n$comment]]>" : $comment;
    $cdata_end      .= " End script hiding -->\n";

d1421 5
a1425 3
	push(@@satts,'language'=>$language);
        push(@@satts,'type'=>$type);
	$code = "$cdata_start$code$cdata_end" if defined $code;
d1438 1
a1438 1
    return "</body></html>";
d1456 2
a1457 2
    my($action,@@other) = rearrange([ACTION],@@p);
    $action = qq/action="$action"/ if $action;
d1459 1
a1459 1
    return $XHTML ? "<isindex $action$other />" : "<isindex $action$other>";
d1475 1
a1475 1
	rearrange([METHOD,ACTION,ENCTYPE],@@p);
d1477 1
a1477 1
    $method = lc($method) || 'post';
d1479 2
a1480 5
    unless (defined $action) {
       $action = $self->url(-absolute=>1,-path=>1);
       $action .= "?$ENV{QUERY_STRING}" if $ENV{QUERY_STRING};
    }
    $action = qq(action="$action");
d1483 1
a1483 1
    return qq/<form method="$method" $action enctype="$enctype"$other>\n/;
d1507 2
a1508 1
    if (defined($param[0]) && substr($param[0],0,1) eq '-') {
d1514 1
a1514 1
	    rearrange([METHOD,ACTION],@@p);
d1526 2
a1527 6
    if ( $NOSTICKY ) {
    return wantarray ? ("</form>") : "\n</form>";
    } else {
    return wantarray ? ($self->get_fields,"</form>") : 
                        $self->get_fields ."\n</form>";
    }
d1545 1
a1545 1
	rearrange([NAME,[DEFAULT,VALUE],SIZE,MAXLENGTH,[OVERRIDE,FORCE]],@@p);
d1550 1
a1550 1
    $current = defined($current) ? $self->escapeHTML($current,1) : '';
d1552 2
a1553 2
    my($s) = defined($size) ? qq/ size="$size"/ : '';
    my($m) = defined($maxlength) ? qq/ maxlength="$maxlength"/ : '';
d1557 2
a1558 3
    my($value) = $current ne '' ? qq(value="$current") : '';
    return $XHTML ? qq(<input type="$tag" name="$name" $value$s$m$other />) 
                  : qq/<input type="$tag" name="$name" $value$s$m$other>/;
d1629 1
a1629 1
	rearrange([NAME,[DEFAULT,VALUE],ROWS,[COLS,COLUMNS],[OVERRIDE,FORCE]],@@p);
d1636 2
a1637 2
    my($r) = $rows ? " rows=$rows" : '';
    my($c) = $cols ? " cols=$cols" : '';
d1639 1
a1639 1
    return qq{<textarea name="$name"$r$c$other>$current</textarea>};
d1658 1
a1658 1
    my($label,$value,$script,@@other) = rearrange([NAME,[VALUE,LABEL],
d1662 1
a1662 1
    $value=$self->escapeHTML($value,1);
d1666 1
a1666 1
    $name = qq/ name="$label"/ if $label;
d1669 2
a1670 2
    $val = qq/ value="$value"/ if $value;
    $script = qq/ onclick="$script"/ if $script;
d1672 1
a1672 2
    return $XHTML ? qq(<input type="button"$name$val$script$other />)
                  : qq/<input type="button"$name$val$script$other>/;
d1690 1
a1690 1
    my($label,$value,@@other) = rearrange([NAME,[VALUE,LABEL]],@@p);
d1693 1
a1693 1
    $value=$self->escapeHTML($value,1);
d1695 2
a1696 2
    my($name) = ' name=".submit"' unless $NOSTICKY;
    $name = qq/ name="$label"/ if defined($label);
d1699 1
a1699 1
    $val = qq/ value="$value"/ if defined($value);
d1701 1
a1701 2
    return $XHTML ? qq(<input type="submit"$name$val$other />)
                  : qq/<input type="submit"$name$val$other>/;
d1716 1
a1716 1
    my($label,@@other) = rearrange([NAME],@@p);
d1718 1
a1718 1
    my($value) = defined($label) ? qq/ value="$label"/ : '';
d1720 1
a1720 2
    return $XHTML ? qq(<input type="reset"$value$other />)
                  : qq/<input type="reset"$value$other>/;
d1740 1
a1740 1
    my($label,@@other) = rearrange([[NAME,VALUE]],@@p);
d1742 1
a1742 1
    $label=$self->escapeHTML($label,1);
d1744 1
a1744 1
    my($value) = qq/ value="$label"/;
d1746 1
a1746 2
    return $XHTML ? qq(<input type="submit" name=".defaults"$value$other />)
                  : qq/<input type="submit" NAME=".defaults"$value$other>/;
d1778 1
a1778 1
	rearrange([NAME,[CHECKED,SELECTED,ON],VALUE,LABEL,[OVERRIDE,FORCE]],@@p);
d1784 1
a1784 1
	$checked = grep($_ eq $value,$self->param($name)) ? ' checked' : '';
d1786 1
a1786 1
	$checked = $checked ? qq/ checked/ : '';
d1790 1
a1790 1
    $value = $self->escapeHTML($value,1);
d1794 1
a1794 2
    return $XHTML ? qq{<input type="checkbox" name="$name" value="$value"$checked$other />$the_label}
                  : qq{<input type="checkbox" name="$name" value="$value"$checked$other>$the_label};
d1826 1
a1826 1
	rearrange([NAME,[VALUES,VALUE],[DEFAULTS,DEFAULT],
d1835 1
a1835 6
	if ($linebreak) {
    $break = $XHTML ? "<br />" : "<br>";
	}
	else {
	$break = '';
	}
d1845 1
a1845 1
	$checked = $checked{$_} ? qq/ checked/ : '';
d1852 2
a1853 3
	$_ = $self->escapeHTML($_,1);
	push(@@elements,$XHTML ? qq(<input type="checkbox" name="$name" value="$_"$checked$other />${label}${break})
                              : qq/<input type="checkbox" name="$name" value="$_"$checked$other>${label}${break}/);
d1865 9
a1873 19
         my ($self,$toencode,$newlinestoo) = CGI::self_or_default(@@_);
         return undef unless defined($toencode);
         return $toencode if ref($self) && $self->{'dontescape'};
         $toencode =~ s{&}{&amp;}gso;
         $toencode =~ s{<}{&lt;}gso;
         $toencode =~ s{>}{&gt;}gso;
         $toencode =~ s{"}{&quot;}gso;
         my $latin = uc $self->{'.charset'} eq 'ISO-8859-1' ||
                     uc $self->{'.charset'} eq 'WINDOWS-1252';
         if ($latin) {  # bug in some browsers
                $toencode =~ s{'}{&#39;}gso;
                $toencode =~ s{\x8b}{&#139;}gso;
                $toencode =~ s{\x9b}{&#155;}gso;
                if (defined $newlinestoo && $newlinestoo) {
                     $toencode =~ s{\012}{&#10;}gso;
                     $toencode =~ s{\015}{&#13;}gso;
                }
         }
         return $toencode;
d1880 1
a1880 1
    my ($self,$string) = CGI::self_or_default(@@_);
a1881 2
    my $latin = defined $self->{'.charset'} ? $self->{'.charset'} =~ /^(ISO-8859-1|WINDOWS-1252)$/i
                                            : 1;
d1889 2
a1890 2
	/^#(\d+)$/ && $latin	     ? chr($1) :
	/^#x([0-9a-f]+)$/i && $latin ? chr(hex($1)) :
a1900 2
    $rowheaders = [] unless defined $rowheaders;
    $colheaders = [] unless defined $colheaders;
d1911 1
a1911 1
    $result = "<table>";
d1914 1
a1914 1
    $result .= "<tr>" if @@{$colheaders};
d1916 1
a1916 1
	$result .= "<th>$_</th>";
d1919 2
a1920 2
	$result .= "<tr>";
	$result .= "<th>$rowheaders->[$row]</th>" if @@$rowheaders;
d1922 1
a1922 1
	    $result .= "<td>" . $elements[$column*$rows + $row] . "</td>"
d1925 1
a1925 1
	$result .= "</tr>";
d1927 1
a1927 1
    $result .= "</table>";
d1956 1
a1956 1
	rearrange([NAME,[VALUES,VALUE],DEFAULT,LINEBREAK,LABELS,
d1976 2
a1977 8
	my($checkit) = $checked eq $_ ? qq/ checked/ : '';
	my($break);
	if ($linebreak) {
          $break = $XHTML ? "<br />" : "<br>";
	}
	else {
	  $break = '';
	}
d1982 1
a1982 1
	    $label = $self->escapeHTML($label,1);
d1985 1
a1985 2
	push(@@elements,$XHTML ? qq(<input type="radio" name="$name" value="$_"$checkit$other />${label}${break})
                              : qq/<input type="radio" name="$name" value="$_"$checkit$other>${label}${break}/);
d2014 1
a2014 1
	rearrange([NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LABELS,[OVERRIDE,FORCE]],@@p);
d2028 1
a2028 1
    $result = qq/<select name="$name"$other>\n/;
d2030 1
a2030 1
	my($selectit) = defined($selected) ? ($selected eq $_ ? qq/selected/ : '' ) : '';
d2034 2
a2035 2
	$label=$self->escapeHTML($label,1);
	$result .= "<option $selectit value=\"$value\">$label</option>\n";
d2038 1
a2038 1
    $result .= "</select>\n";
d2068 1
a2068 1
	= rearrange([NAME,[VALUES,VALUE],[DEFAULTS,DEFAULT],
d2077 2
a2078 2
    my($is_multiple) = $multiple ? qq/ multiple/ : '';
    my($has_size) = $size ? qq/ size="$size"/: '';
d2082 1
a2082 1
    $result = qq/<select name="$name"$has_size$is_multiple$other>\n/;
d2084 1
a2084 1
	my($selectit) = $selected{$_} ? qq/selected/ : '';
d2088 2
a2089 2
	my($value)=$self->escapeHTML($_,1);
	$result .= "<option $selectit value=\"$value\">$label</option>\n";
d2091 1
a2091 1
    $result .= "</select>\n";
d2115 1
a2115 1
	rearrange([NAME,[DEFAULT,VALUE,VALUES],[OVERRIDE,FORCE]],@@p);
d2118 1
a2118 1
    if ( ref($p[0]) || substr($p[0],0,1) eq '-') {
d2133 2
a2134 3
	$_ = defined($_) ? $self->escapeHTML($_,1) : '';
	push @@result,$XHTML ? qq(<input type="hidden" name="$name" value="$_" />)
                            : qq(<input type="hidden" name="$name" value="$_">);
d2154 1
a2154 1
	rearrange([NAME,SRC,ALIGN],@@p);
d2156 1
a2156 1
    my($align) = $alignment ? " align=\U$alignment" : '';
d2159 1
a2159 2
    return $XHTML ? qq(<input type="image" name="$name" src="$src"$align$other />)
                  : qq/<input type="image" name="$name" src="$src"$align$other>/;
d2194 2
a2195 2
    my ($relative,$absolute,$full,$path_info,$query,$base) = 
	rearrange(['RELATIVE','ABSOLUTE','FULL',['PATH','PATH_INFO'],['QUERY','QUERY_STRING'],'BASE'],@@p);
d2197 1
a2197 1
    $full++ if $base || !($relative || $absolute);
d2200 12
a2211 16
    my $script_name = $self->script_name;

# If anybody knows why I ever wrote this please tell me!
#    if (exists($ENV{REQUEST_URI})) {
#        my $index;
#	$script_name = $ENV{REQUEST_URI};
#        # strip query string
#        substr($script_name,$index) = '' if ($index = index($script_name,'?')) >= 0;
#        # and path
#        if (exists($ENV{PATH_INFO})) {
#           (my $encoded_path = $ENV{PATH_INFO}) =~ s!([^a-zA-Z0-9_./-])!uc sprintf("%%%02x",ord($1))!eg;;
#           substr($script_name,$index) = '' if ($index = rindex($script_name,$encoded_path)) >= 0;
#         }
#    } else {
#	$script_name = $self->script_name;
#    }
a2225 1
        return $url if $base;
a2231 1

a2233 2
    $url = '' unless defined $url;
    $url =~ s/([^a-zA-Z0-9_.%;&?\/\\:+=~-])/uc sprintf("%%%02x",ord($1))/eg;
d2255 1
a2255 1
	rearrange([NAME,[VALUE,VALUES],PATH,DOMAIN,SECURE,EXPIRES],@@p);
d2274 1
a2274 1
    return undef unless defined($name) && $name ne '';	# this is an error
d2284 64
a2347 1
    return new CGI::Cookie(@@param);
d2364 1
a2364 1
    my($name) = rearrange([NAME],@@p);
a2445 3
    foreach (keys %{$self->{'.fieldnames'}}) {
      push(@@pairs,".cgifields=".escape("$_"));
    }
a2732 11
#### Method: nosticky
# Set or return the NOSTICKY global flag
####
'nosticky' => <<'END_OF_FUNC',
sub nosticky {
    my ($self,$param) = self_or_CGI(@@_);
    $CGI::NOSTICKY = $param if defined($param);
    return $CGI::NOSTICKY;
}
END_OF_FUNC

d2760 2
a2761 6
    my ($self,$param,$param2) = self_or_CGI(@@_);
    if (defined $param2 && defined $param) {
        $CGI::DEFAULT_DTD = [ $param, $param2 ];
    } elsif (defined $param) {
        $CGI::DEFAULT_DTD = $param;
    }
d2806 1
a2806 1
    if ($DEBUG && @@ARGV) {
d2808 1
a2808 1
    } elsif ($DEBUG > 1) {
d2855 1
a2855 1
	my($filename) = $header{'Content-Disposition'}=~/ filename="?([^\"]*)"?/;
d2988 1
a2988 1
    $i =~ s/%(..)/ chr(hex($1)) /eg;
d3013 1
a3013 3
    (my $safename = $name) =~ s/([':%])/ sprintf '%%%02X', ord $1 /eg;
    my $fv = ++$FH . $safename;
    my $ref = \*{"Fh::$fv"};
d3016 1
a3016 1
    CORE::delete $Fh::{$fv};
a3075 1
    my $boundary_read = 0;
a3091 1
        $boundary_read++;
d3107 1
a3107 3
    unless ($boundary_read) {
      while ($self->read(0)) { }
    }
d3121 3
a3123 1
    local($CRLF) = "\015\012" if $CGI::OS eq 'VMS';
d3188 2
a3189 1
    # and return undef.
d3200 1
a3200 2
	substr($self->{BUFFER},0,length($self->{BOUNDARY}))='';
        $self->{BUFFER} =~ s/^\012\015?//;
d3283 2
a3284 3
	   "${vol}${SL}Temporary Items",
           "${SL}WWW_ROOT", "${SL}SYS\$SCRATCH",
	   "C:${SL}system${SL}temp");
d3287 1
a3287 2
    # this feature was supposed to provide per-user tmpfiles, but
    # it is problematic.
d3293 1
a3293 1
    # unshift(@@TEMP,(eval {(getpwuid($>))[7]}).'/tmp') if $CGI::OS eq 'UNIX' and $> != 0;
d3322 1
a3322 1
    return unless $filename =~ m!^([a-zA-Z0-9_ '":/.\$\\-]+)$!;
d3482 11
d3509 1
a3509 1
   $q->param(-name=>'veggie',-value=>['tomato','tomahto','potato','potahto']);
d3550 2
a3551 1
=item 1.
d3553 1
a3553 4
Use another name for the argument, if one is available. 
For example, -value is an alias for -values.

=item 2.
d3555 1
a3555 5
Change the capitalization, e.g. -Values

=item 3.

Put quotes around the argument name, e.g. '-values'
d3658 4
a3661 5
(e.g. "name1=value1&name2=value2&name3=value3"), the param() method
will return the parameter names as a list.  If the script was invoked
as an <ISINDEX> script and contains a string without ampersands
(e.g. "value1+value2+value3") , there will be a single parameter named
"keywords" containing the "+"-delimited keywords.
a3681 4
If a value is not given in the query string, as in the queries
"name1=&name2=" or "name1&name2", it will be returned as an empty
string.  This feature is new in 2.63.

d3772 1
a3772 1
CGI parameter list.  Called in a list context, it returns the
d3778 1
a3778 1
list context, multivalued parameters will be returned as a packed
d3985 2
a3986 2
standard set of functions and enables debugging mode (pragma
-debug):
d3988 1
a3988 1
   use CGI qw/:standard -debug/;
a4027 15
=item -nosticky

This makes CGI.pm not generating the hidden fields .submit
and .cgifields. It is very useful if you don't want to
have the hidden fields appear in the querystring in a GET method.
For example, a search script generated this way will have
a very nice url with search parameters for bookmarking.

=item -no_xhtml

By default, CGI.pm versions 2.69 and higher emit XHTML
(http://www.w3.org/TR/xhtml1/).  The -no_xhtml pragma disables this
feature.  Thanks to Michalis Kabrianis <kabrianis@@hellug.gr> for this
feature.

a4045 7
This became the default in version 2.64.

=item -oldstyle_urls

Separate the name=value pairs in CGI parameter query strings with
ampersands rather than semicolons.  This is no longer the default.

d4062 2
a4063 2
don't want it to read CGI parameters from the command line or STDIN,
then use this pragma:
d4067 2
a4068 1
=item -debug
d4070 2
a4071 4
This turns on full debugging.  In addition to reading CGI arguments
from the command-line processing, CGI.pm will pause and try to read
arguments from STDIN, producing the message "(offline mode: enter
name=value pairs on standard input)" features.
a4190 2
                             -charset=>'utf-7',
                             -attachment=>'foo.gif',
d4233 2
a4234 11
to use with certain servers that expect all their scripts to be NPH.

The B<-charset> parameter can be used to control the character set
sent to the browser.  If not provided, defaults to ISO-8859-1.  As a
side effect, this sets the charset() method as well.

The B<-attachment> parameter can be used to turn the page into an
attachment.  Instead of displaying the page, some browsers will prompt
the user to save it to disk.  The value of the argument is the
suggested name for the saved file.  In order for this to work, you may
have to set the B<-type> to "application/octet-stream".
d4246 3
a4248 1
well.
d4284 4
a4287 5
parameters are -title, -author, -base, -xbase, -dtd, -lang and -target
(see below for the explanation).  Any additional parameters you
provide, such as the Netscape unofficial BGCOLOR attribute, are added
to the <BODY> tag.  Additional parameters must be proceeded by a
hyphen.
d4297 2
a4298 4
for all the links and fill-out forms on the page.  B<This is a
non-standard HTTP feature which only works with Netscape browsers!>
See the Netscape documentation on frames for details of how to
manipulate this.
d4311 4
a4314 2
To create an HTTP-EQUIV type of <META> tag, use B<-head>, described
below.
d4316 1
a4316 7
The B<-style> argument is used to incorporate cascading stylesheets
into your code.  See the section on CASCADING STYLESHEETS for more
information.

The B<-lang> argument is used to incorporate a language attribute into
the <HTML> tag.  The default if not specified is "en-US" for US
English.  For example:
d4318 2
a4319 1
    print $q->start_html(-lang=>'fr-CA');
d4326 1
a4326 1
		                  -href=>'http://www.capricorn.com/s2.html'}));
a4338 6
And here's how to create an HTTP-EQUIV <META> tag:

      print start_html(-head=>meta({-http_equiv => 'Content-Type',
                                    -content    => 'text/html'}))


d4467 1
a4467 1
    print q(<A HREF="$myself">I'm talking to myself.</A>);
a4494 1
    $netloc        = $query->url(-base => 1);
a4535 4
=item B<-base>

Generate just the protocol and net location, as in http://www.foo.com:8000

d4651 1
a4651 1
             li({-type=>'disc'},['Sneezy','Doc','Sleepy','Happy'])
a4726 43
=head2 AUTOESCAPING HTML

By default, all HTML that is emitted by the form-generating functions
is passed through a function called escapeHTML():

=over 4

=item $escaped_string = escapeHTML("unescaped string");

Escape HTML formatting characters in a string.

=back

Provided that you have specified a character set of ISO-8859-1 (the
default), the standard HTML escaping rules will be used.  The "<"
character becomes "&lt;", ">" becomes "&gt;", "&" becomes "&amp;", and
the quote character becomes "&quot;".  In addition, the hexadecimal
0x8b and 0x9b characters, which many windows-based browsers interpret
as the left and right angle-bracket characters, are replaced by their
numeric HTML entities ("&#139" and "&#155;").  If you manually change
the charset, either by calling the charset() method explicitly or by
passing a -charset argument to header(), then B<all> characters will
be replaced by their numeric entities, since CGI.pm has no lookup
table for all the possible encodings.

The automatic escaping does not apply to other shortcuts, such as
h1().  You should call escapeHTML() yourself on untrusted data in
order to protect your pages against nasty tricks that people may enter
into guestbooks, etc..  To change the character set, use charset().
To turn autoescaping off completely, use autoescape():

=over 4

=item $charset = charset([$charset]);

Get or set the current character set.

=item $flag = autoEscape([$flag]);

Get or set the value of the autoescape flag.

=back

d4772 1
d4787 1
a4787 1
    print $query->start_form(-method=>$method,
d4795 1
a4795 1
    print $query->start_form($method,$action,$encoding);
d4799 1
a4799 1
start_form() will return a <FORM> tag with the optional method,
d4808 1
a4808 1
Start_form()'s enctype argument tells the browser how to package the various
a4811 3
B<Note:> This method was previously named startform(), and startform()
is still recognized as an alias.

d4820 1
a4820 1
type in B<&CGI::URL_ENCODED>.
d4837 1
a4837 1
For compatibility, the start_form() method uses the older form of
d4840 1
a4840 1
B<start_form()>.
d4974 1
a4974 1
by calling B<start_form()> with an encoding type of B<&CGI::MULTIPART>,
d4976 1
a4976 1
vanilla B<start_form()>.
a5589 1

d5738 2
a5739 2
To retrieve a cookie, request it by name by calling cookie() method
without the B<-value> parameter:
d5743 2
a5744 6
	$riddle = $query->cookie('riddle_name');
        %answers = $query->cookie('answers');

Cookies created with a single scalar value, such as the "riddle_name"
cookie, will be returned in that form.  Cookies with array and hash
values can also be retrieved.
d5798 1
a5798 1
    print $q->start_form(-target=>'ResultsWindow');
a5880 3
Pass an array reference to B<-style> in order to incorporate multiple
stylesheets into your document.

d5883 6
a5888 5
If you are running the script from the command line or in the perl
debugger, you can pass the script a list of keywords or
parameter=value pairs on the command line or from standard input (you
don't have to worry about tricking your script into reading from
environment variables).  You can pass keywords like this:
d5904 1
a5904 5
To turn off this feature, use the -no_debug pragma.

To test the POST method, you may enable full debugging with the -debug
pragma.  This will allow you to feed newline-delimited name=value
pairs to the script on standard input.
d5915 1
a5915 1
The Dump() method produces a string consisting of all the query's
d5919 1
a5919 1
    print $query->Dump
d5986 3
a5988 2
E.G. fetching /cgi-bin/your_script/additional/stuff will result in
$query->path_info() returning "/additional/stuff".
a6013 1

a6037 4
=item B<server_port ()>

Return the port that the server is listening on.

d6128 1
a6128 3
=item By using B<-nph> parameters

in the B<header()> and B<redirect()>  statements:
d6136 1
a6136 1
CGI.pm provides four simple functions for producing multipart
d6148 2
a6149 2
  print multipart_init(-boundary=>'----here we go!');
  foreach (0 .. 4) {
d6151 2
a6152 6
            "The current time is ",scalar(localtime),"\n";
      if ($_ < 4) {
              print multipart_end;
      } else {
              print multipart_final;
      }
d6157 2
a6158 2
It then enters a loop in which it begins a new multipart section by
calling B<multipart_start()>, prints the current local time,
d6160 1
a6160 3
a second, and begins again. On the final iteration, it ends the
multipart section with B<multipart_final()> rather than with
B<multipart_end()>.
d6184 1
a6184 9
multipart_start(), except at the end of the last part of the multipart
document when multipart_final() should be called instead of multipart_end().

=item multipart_final()

  multipart_final()

End all parts.  You should call multipart_final() rather than
multipart_end() at the end of the last part of the multipart document.
a6190 3
Only Netscape Navigator supports server push.  Internet Explorer
browsers do not.

d6398 1
a6398 1
	   print $query->start_form;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.62 2002/04/10 19:36:01 lstein Exp $';
$CGI::VERSION='2.81';
d26 1
a26 1
# $CGITempFile::TMPDIRECTORY = '/usr/tmp';
d29 2
a30 5
#use constant XHTML_DTD => ['-//W3C//DTD XHTML Basic 1.0//EN',
#                           'http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd'];

use constant XHTML_DTD => ['-//W3C//DTD XHTML 1.0 Transitional//EN',
                           'http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd'];
d36 1
a36 1

a84 4
    # Do not include undefined params parsed from query string
    # use CGI qw(-no_undef_params);
    $NO_UNDEF_PARAMS = 0;

d139 2
a140 2
       UNIX=>'/', OS2=>'\\', EPOC=>'/',
       WINDOWS=>'\\', DOS=>'\\', MACINTOSH=>':', VMS=>'/'
a186 3
                ':html4'=>[qw/abbr acronym bdo col colgroup del fieldset iframe
                            ins label legend noframes noscript object optgroup Q 
                            thead tbody tfoot/], 
d202 2
a203 2
		':html' => [qw/:html2 :html3 :html4 :netscape/],
		':standard' => [qw/:html2 :html3 :html4 :form :cgi/],
d205 1
a205 1
		':all' => [qw/:html2 :html3 :netscape :form :cgi :internal :html4/]
d213 2
a214 2
    undef %EXPORT_OK;
    undef %EXPORT;
a544 2
	next unless defined $param;
	next if $NO_UNDEF_PARAMS and not defined $value;
a649 14
sub _selected {
  my $self = shift;
  my $value = shift;
  return '' unless $value;
  return $XHTML ? qq( selected="selected") : qq( selected);
}

sub _checked {
  my $self = shift;
  my $value = shift;
  return '' unless $value;
  return $XHTML ? qq( checked="checked") : qq( checked);
}

a654 4

    # to avoid reexporting unwanted variables
    undef %EXPORT;

a667 1
	$NO_UNDEF_PARAMS++,      next if /^[:-]no_undef_params$/;
d1018 2
a1019 2
    return '<ul></ul>' unless $self->param;
    push(@@result,"<ul>");
d1022 2
a1023 2
	push(@@result,"<li><strong>$param</strong>");
	push(@@result,"<ul>");
d1026 2
a1027 2
            $value =~ s/\n/<br>\n/g;
	    push(@@result,"<li>$value");
d1029 1
a1029 1
	push(@@result,"</ul>");
d1031 1
a1031 1
    push(@@result,"</ul>");
a1199 1
        $header = ucfirst($header);
d1228 1
a1228 1
    push(@@header,map {ucfirst $_} @@other);
d1294 1
a1294 1
# $head -> (optional) any other elements you'd like to incorporate into the <head> tag
d1298 1
a1298 1
#           the <body> tag.
d1303 2
a1304 5
    my($title,$author,$base,$xbase,$script,$noscript,
        $target,$meta,$head,$style,$dtd,$lang,$encoding,@@other) = 
	rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,META,HEAD,STYLE,DTD,LANG,ENCODING],@@p);

    $encoding = 'iso-8859-1' unless defined $encoding;
d1324 1
a1324 1
    push @@result,qq(<?xml version="1.0" encoding="$encoding"?>) if $xml_dtd; 
d1327 1
a1327 1
        push(@@result,qq(<!DOCTYPE html\n\tPUBLIC "$dtd->[0]"\n\t "$dtd->[1]">));
d1391 1
a1391 1
                             : qq(<link rel="stylesheet" type="$type" href="$src">)) if $src;
d1454 1
a1454 1
# Trivial method for completeness.  Just returns "</body>"
d1585 1
a1585 1
                  : qq(<input type="$tag" name="$name" $value$s$m$other>);
d1649 1
a1649 1
#   A string containing a <textarea></textarea> tag
d1663 2
a1664 2
    my($r) = $rows ? qq/ rows="$rows"/ : '';
    my($c) = $cols ? qq/ cols="$cols"/ : '';
d1700 1
a1700 1
                  : qq(<input type="button"$name$val$script$other>);
d1730 1
a1730 1
                  : qq(<input type="submit"$name$val$other>);
d1750 1
a1750 1
                  : qq(<input type="reset"$value$other>);
d1815 1
a1815 1
	$checked = grep($_ eq $value,$self->param($name)) ? $self->_checked(1) : '';
d1817 1
a1817 1
	$checked = $self->_checked($checked);
d1882 1
a1882 1
	$checked = $self->_checked($checked{$_});
a1902 2
         # hack to work around  earlier hacks
         push @@_,$_[0] if @@_==1 && $_[0] eq 'CGI';
d2028 1
a2028 1
	my($checkit) = $checked eq $_ ? qq/ checked="checked"/ : '';
d2089 1
a2089 1
	my($selectit) = defined($selected) ? $self->_selected($selected eq $_) : '';
d2094 1
a2094 1
	$result .= "<option$selectit value=\"$value\">$label</option>\n";
d2097 1
a2097 1
    $result .= "</select>";
d2136 1
a2136 1
    my($is_multiple) = $multiple ? qq/ multiple="multiple"/ : '';
d2143 1
a2143 1
	my($selectit) = $self->_selected($selected{$_});
d2148 1
a2148 1
	$result .= "<option$selectit value=\"$value\">$label</option>\n";
d2150 1
a2150 1
    $result .= "</select>";
d2216 1
a2216 1
    my($align) = $alignment ? " align=\U\"$alignment\"" : '';
d2258 1
a2258 1
    $full++      if $base || !($relative || $absolute);
d2263 14
a2276 11
    # for compatibility with Apache's MultiViews
    if (exists($ENV{REQUEST_URI})) {
        my $index;
	$script_name = $ENV{REQUEST_URI};
        $script_name =~ s/\?.+$//;   # strip query string
        # and path
        if (exists($ENV{PATH_INFO})) {
           (my $encoded_path = $ENV{PATH_INFO}) =~ s/([^a-zA-Z0-9_.%;&?\/\\:+=~-])/sprintf("%%%02X",ord($1))/eg;
           $script_name      =~ s/$encoded_path$//i;
         }
    }
d2302 1
a2302 1
    $url =~ s/([^a-zA-Z0-9_.%;&?\/\\:+=~-])/sprintf("%%%02X",ord($1))/eg;
d2907 1
a2907 1
	    next unless $tmpfile = new CGITempFile($seqno);
d2912 1
a2912 1
          die "CGI open of tmpfile: $!\n" unless defined $filehandle;
d2940 4
a2943 3
    my @@param = grep(ref && fileno($_), $self->param($param_name));
    return unless @@param;
    return wantarray ? @@param : $param[0];
d3110 1
a3110 1
	$boundary = "--$boundary" unless CGI::user_agent('MSIE\s+3\.0[12];\s*Mac|DreamPassport');
d3246 1
a3246 2
    return (($start > 0) && ($start <= $bytes)) 
           ? substr($returnval,0,-2) : $returnval;
d3303 1
a3303 1
package CGITempFile;
d3335 1
a3335 6
*CGITempFile::AUTOLOAD = \&CGI::AUTOLOAD;

sub DESTROY {
    my($self) = @@_;
    unlink $$self;              # get rid of the file
}
d3358 7
d3543 4
a3546 4
   h1()                           <h1>
   h1('some','contents');         <h1>some contents</h1>
   h1({-align=>left});            <h1 ALIGN="LEFT">
   h1({-align=>left},'contents'); <h1 ALIGN="LEFT">contents</h1>
d3935 1
a3935 1
Import all methods that generate HTML 3.0 elements (such as
a3937 5
=item B<:html4>

Import all methods that generate HTML 4 elements (such as
<abbrev>, <acronym> and <thead>).

d3949 1
a3949 1
Import "standard" features, 'html2', 'html3', 'html4', 'form' and 'cgi'.
d3962 1
a3962 1
Microsoft comes out with a new tag called <gradient> (which causes the
a4065 4
=item -no_undef_params

This keeps CGI.pm from including undef params in the parameter list.

d4172 1
a4172 1
  <h1>Level 1 Header</h1>
d4196 1
a4196 1
=item 1. start_table() (generates a <table> tag)
d4198 1
a4198 1
=item 2. end_table() (generates a </table> tag)
d4200 1
a4200 1
=item 3. start_ul() (generates a <ul> tag)
d4202 1
a4202 1
=item 4. end_ul() (generates a </ul> tag)
d4287 1
a4287 1
headers to work with an NPH (no-parse-header) script.  This is important
d4324 1
a4324 1
headers to work with an NPH (no-parse-header) script.  This is important
d4344 1
a4344 1
This method returns a canned HTML header and the opening <body> tag.
d4349 1
a4349 1
to the <body> tag.  Additional parameters must be proceeded by a
d4352 1
a4352 1
The argument B<-xbase> allows you to provide an HREF for the <base> tag
d4371 1
a4371 1
into a series of header <meta> tags that look something like this:
d4373 2
a4374 2
    <meta name="keywords" content="pharaoh secret mummy">
    <meta name="description" content="copyright 1996 King Tut">
d4376 1
a4376 1
To create an HTTP-EQUIV type of <meta> tag, use B<-head>, described
d4384 1
a4384 1
the <html> tag.  The default if not specified is "en-US" for US
d4389 2
a4390 5
The B<-encoding> argument can be used to specify the character set for
XHTML.  It defaults to iso-8859-1 if not specified.

You can place other arbitrary HTML elements to the <head> section with the
B<-head> tag.  For example, to place the rarely-used <link> element in the
d4396 1
a4396 1
To incorporate multiple HTML elements into the <head> section, just pass an
d4407 1
a4407 1
And here's how to create an HTTP-EQUIV <meta> tag:
d4417 1
a4417 1
This block will be placed within a <script> block inside the HTML (not
d4456 1
a4456 1
Netscape 3.0 recognizes several attributes of the <script> tag,
d4474 1
a4474 1
A final feature allows you to incorporate multiple <script> sections into the
d4495 1
d4517 1
a4517 1
The author's e-mail address (will create a <link rev="MADE"> tag if present
d4521 1
a4521 1
A 'true' flag if you want to include a <base> tag in the header.  This
d4527 1
a4527 1
Any other parameters you want to include in the <body> tag.  This is a good
d4536 1
a4536 1
This ends an HTML document by printing the </body></html> tags.
d4541 1
a4541 1
    print q(<a href="$myself">I'm talking to myself.</a>);
d4550 3
a4552 3
     print "<a href=$myself#table1>See table 1</a>";
     print "<a href=$myself#table2>See table 2</a>";
     print "<a href=$myself#yourself>See for yourself</a>";
d4661 1
a4661 1
   <a href="http://crete.org/">Crete</a> there lived
d4684 1
a4684 1
   print hr;  	#  <hr>
d4689 1
a4689 1
   print h1("Chapter","1"); # <h1>Chapter 1</h1>"
d4697 1
a4697 1
	    <a href="fred.html",target="_new">Open a new frame</a>
d4704 1
a4704 1
	   <img align="LEFT" src="fred.gif">
d4707 1
a4707 1
lists can be marked as COMPACT.  The syntax for this is an argument
d4714 2
a4715 2
changed in order to accommodate those who want to create tags of the form
<img alt="">.  The difference is shown in these two pieces of code:
d4717 3
a4719 3
     CODE                   RESULT
     img({alt=>undef})      <img alt>
     img({alt=>''})         <img alt="">
d4735 6
a4740 6
   <ul>
     <li type="disc">Sneezy</li>
     <li type="disc">Doc</li>
     <li type="disc">Sleepy</li>
     <li type="disc">Happy</li>
   </ul>
d4764 1
a4764 1
   <blockquote><em>Hi</em> mom!</blockquote>
d4902 1
a4902 1
Prints out an <isindex> tag.  Not very exciting.  The parameter
d4920 1
a4920 1
start_form() will return a <form> tag with the optional method,
d4927 1
a4927 1
endform() returns the closing </form> tag.  
d4976 1
a4976 1
Usually the bulk of JavaScript functions are defined in a <script>
a5175 4
In an array context, upload() will return an array of filehandles.
This makes it possible to create forms that use the same name for
multiple upload fields.

a5212 6
If you are using CGI.pm on a Windows platform and find that binary
files get slightly larger when uploaded but that text files remain the
same, then you have forgotten to activate binary mode on the output
filehandle.  Be sure to call binmode() on any handle that you create
to write the uploaded file to disk.

d5446 1
a5446 1
			   -checked=>1,
d5899 1
a5899 1
HTML document using the start_html() call, create a <frameset> 
d5903 1
a5903 1
There is no specific support for creating <frameset> sections 
d5922 1
a5922 1
=item 3. Specify the destination for the document in the <form> tag
d5945 1
a5945 1
into a <style> section, or it may be a hash reference.  In the latter
d5949 1
a5949 1
incorporated into a <style> section.  Style definitions in B<-code>
d6059 11
a6069 11
    <ul>
    <li>name1
	<ul>
	<li>value1
	<li>value2
	</ul>
    <li>name2
	<ul>
	<li>value1
	</ul>
    </ul>
d6075 1
a6075 1
    print "<h2>Current Values</h2> $query\n";
d6245 6
a6250 11
The Microsoft Internet Information Server requires NPH mode.  As of
version 2.30, CGI.pm will automatically detect when the script is
running under IIS and put itself into this mode.  You do not need to
do this manually, although it won't hurt anything if you do.  However,
note that if you have applied Service Pack 6, much of the
functionality of NPH scripts, including the ability to redirect while
setting a cookie, b<do not work at all> on IIS without a special patch
from Microsoft.  See
http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP:
Non-Parsed Headers Stripped From CGI Applications That Have nph-
Prefix in Name.
d6547 1
a6547 1
	print "<h1> Example CGI.pm Form</h1>\n";
d6557 1
a6557 1
	   print "<em>What's your name?</em><br>";
d6561 1
a6561 1
	   print "<p><em>Where can you find English Sparrows?</em><br>";
d6568 1
a6568 1
	   print "<p><em>How far can they fly?</em><br>",
d6574 1
a6574 1
	   print "<p><em>What's your favorite color?</em>  ";
d6581 1
a6581 1
	   print "<p><em>What have you got there?</em><br>";
d6589 1
a6589 1
	   print "<p><em>Any parting comments?</em><br>";
d6594 1
a6594 1
	   print "<p>",$query->reset;
d6598 1
a6598 1
	   print "<hr>\n";
d6605 1
a6605 1
	   print "<h2>Here are the current settings in this form</h2>";
d6608 1
a6608 1
	      print "<strong>$key</strong> -> ";
d6610 1
a6610 1
	      print join(", ",@@values),"<br>\n";
d6616 3
a6618 3
	<hr>
	<address>Lincoln D. Stein</address><br>
	<a href="/">Home Page</a>
d6634 3
a6636 1
L<CGI::Carp>, L<CGI::Fast>, L<CGI::Pretty>
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.130 2003/08/01 14:39:17 lstein Exp $ + patches by merlyn';
$CGI::VERSION='3.00';
a34 9
{
  local $^W = 0;
  $TAINTED = substr("$0$^X",0,0);
}

my @@SAVED_SYMBOLS;

$MOD_PERL = 0; # no mod_perl by default

a71 10
    # Set this to 1 to cause files uploaded in multipart documents
    # to be closed, instead of caching the file handle
    # or:
    #    1) use CGI qw(:close_upload_files)
    #    2) $CGI::close_upload_files(1);
    # Uploads with many files run out of file handles.
    # Also, for performance, since the file is already on disk,
    # it can just be renamed, instead of read and written.
    $CLOSE_UPLOAD_FILES = 0;

a129 2
} elsif ($OS =~ /^cygwin/i) {
    $OS = 'CYGWIN';
d135 1
a135 1
$needs_binmode = $OS=~/^(WINDOWS|DOS|OS2|MSWin|CYGWIN)/;
d146 2
a147 2
     UNIX    => '/',  OS2 => '\\', EPOC      => '/', CYGWIN => '/',
     WINDOWS => '\\', DOS => '\\', MACINTOSH => ':', VMS    => '/'
d156 6
a161 15
if (exists $ENV{MOD_PERL}) {
  eval "require mod_perl";
  # mod_perl handlers may run system() on scripts using CGI.pm;
  # Make sure so we don't get fooled by inherited $ENV{MOD_PERL}
  if (defined $mod_perl::VERSION) {
    if ($mod_perl::VERSION >= 1.99) {
      $MOD_PERL = 2;
      require Apache::RequestRec;
      require Apache::RequestUtil;
      require APR::Pool;
    } else {
      $MOD_PERL = 1;
      require Apache;
    }
  }
a162 1

d193 1
a193 1
			   embed basefont style span layer ilayer font frameset frame script small big Area Map/],
d210 1
d222 1
a222 1
    # This causes modules to clash.
d266 10
a275 27
  my($class,@@initializer) = @@_;
  my $self = {};
  bless $self,ref $class || $class || $DefaultClass;
  if (ref($initializer[0])
      && (UNIVERSAL::isa($initializer[0],'Apache')
	  ||
	  UNIVERSAL::isa($initializer[0],'Apache::RequestRec')
	 )) {
    $self->r(shift @@initializer);
  }
  if ($MOD_PERL) {
    $self->r(Apache->request) unless $self->r;
    my $r = $self->r;
    if ($MOD_PERL == 1) {
      $r->register_cleanup(\&CGI::_reset_globals);
    }
    else {
      # XXX: once we have the new API
      # will do a real PerlOptions -SetupEnv check
      $r->subprocess_env unless exists $ENV{REQUEST_METHOD};
      $r->pool->cleanup_register(\&CGI::_reset_globals);
    }
    undef $NPH;
  }
  $self->_reset_globals if $PERLEX;
  $self->init(@@initializer);
  return $self;
a281 7
sub r {
  my $self = shift;
  my $r = $self->{'.r'};
  $self->{'.r'} = shift if @@_;
  $r;
}

d360 3
a362 8
  my $self = shift;
  my($query_string,$meth,$content_length,$fh,@@lines) = ('','','','');

  my $initializer = shift;  # for backward compatibility
  local($/) = "\n";

    # set autoescaping on by default
    $self->{'escape'} = 1;
a387 6
	# quietly read and discard the post
	  my $buffer;
	  my $max = $content_length;
	  while ($max > 0 && (my $bytes = read(STDIN,$buffer,$max < 10000 ? $max : 10000))) {
	    $max -= $bytes;
	  }
d444 1
a444 1
	    $query_string = $self->r->args;
a468 12
# YL: Begin Change for XML handler 10/19/2001
    if ($meth eq 'POST'
        && defined($ENV{'CONTENT_TYPE'})
        && $ENV{'CONTENT_TYPE'} !~ m|^application/x-www-form-urlencoded|
	&& $ENV{'CONTENT_TYPE'} !~ m|^multipart/form-data| ) {
        my($param) = 'POSTDATA' ;
        $self->add_parameter($param) ;
      push (@@{$self->{$param}},$query_string);
      undef $query_string ;
    }
# YL: End Change for XML handler 10/19/2001

d496 1
a496 1
    $self->save_request unless defined $initializer;
d588 9
a596 8
         my (\$q,\$a,\@@rest) = self_or_default(\@@_);
         my(\$attr) = '';
	 if (ref(\$a) && ref(\$a) eq 'HASH') {
	    my(\@@attr) = make_attributes(\$a,\$q->{'escape'});
	    \$attr = " \@@attr" if \@@attr;
	  } else {
	    unshift \@@rest,\$a if defined \$a;
	  }
d604 1
a604 1
	    return \$XHTML ? "\L<$tagname\E\$attr />" : "\L<$tagname\E\$attr>" unless \@@rest;
d607 1
a607 1
                              (ref(\$rest[0]) eq 'ARRAY') ? \@@{\$rest[0]} : "\@@rest";
a695 1
    $CLOSE_UPLOAD_FILES++,   next if /^[:-]close_upload_files$/;
a716 1
    @@SAVED_SYMBOLS = @@_;
d769 4
a772 10
    my(@@names) = rearrange([NAME],@@p);
    my @@to_delete = ref($names[0]) eq 'ARRAY' ? @@$names[0] : @@names;
    my %to_delete;
    foreach my $name (@@to_delete)
    {
        CORE::delete $self->{$name};
        CORE::delete $self->{'.fieldnames'}->{$name};
        $to_delete{$name}++;
    }
    @@{$self->{'.parameters'}}=grep { !exists($to_delete{$_}) } $self->param();
d893 3
a895 7
sub TIEHASH {
    my $class = shift;
    my $arg   = $_[0];
    if (ref($arg) && UNIVERSAL::isa($arg,'CGI')) {
       return $arg;
    }
    return $Q ||= $class->new(@@_);
d971 1
a971 2
    my @@param = $self->param();
    $self->delete(@@param);
d995 1
a995 3
    my $d = $self->{'escape'};
    $self->{'escape'} = $escape;
    $d;
d1053 1
a1053 1
	push(@@result,"<li><strong>$param</strong></li>");
d1057 2
a1058 2
            $value =~ s/\n/<br \/>\n/g;
	    push(@@result,"<li>$value</li>");
d1165 1
a1165 2
        # Don't use \s because of perl bug 21951
        next unless my($header,$value) = /([^ \r\n\t=]+)=\"?(.+?)\"?$/;
d1213 1
a1213 1
    my($type,$status,$cookie,$target,$expires,$nph,$charset,$attachment,$p3p,@@other) = 
d1217 1
a1217 1
                            'ATTACHMENT','P3P'],@@p);
d1229 3
a1231 3
        # Don't use \s because of perl bug 21951
        next unless my($header,$value) = /([^ \r\n\t=]+)=\"?(.+?)\"?$/;
        ($_ = $header) =~ s/^(\w)(.*)/"\u$1\L$2" . ': '.$self->unescapeHTML($value)/e;
d1235 1
a1235 1
    $type .= "; charset=$charset" if $type ne '' and $type =~ m!^text/! and $type !~ /\bcharset\b/ and $charset ne '';
a1243 4
    if ($p3p) {
       $p3p = join ' ',@@$p3p if ref($p3p) eq 'ARRAY';
       push(@@header,qq(P3P: policyref="/w3c/p3p.xml", CP="$p3p"));
    }
d1262 1
d1265 3
a1267 2
        $self->r->send_cgi_header($header);
        return '';
d1297 1
a1297 1
    my($url,$target,$cookie,$nph,@@other) = rearrange([[LOCATION,URI,URL],TARGET,['COOKIE','COOKIES'],NPH],@@p);
d1302 3
a1304 3
	 '-Status'  => '302 Moved',
	 '-Location'=> $url,
	 '-nph'     => $nph);
d1306 1
d1308 1
a1308 3
    my @@unescaped;
    unshift(@@unescaped,'-Cookie'=>$cookie) if $cookie;
    return $self->header((map {$self->unescapeHTML($_)} @@o),@@unescaped);
d1345 1
a1345 1
    $lang = 'en-US' unless defined $lang;
d1366 2
a1367 3
    push(@@result,$XHTML ? qq(<html xmlns="http://www.w3.org/1999/xhtml" lang="$lang" xml:lang="$lang"><head><title>$title</title>)
                        : ($lang ? qq(<html lang="$lang">) : "<html>") 
	                  . "<head><title>$title</title>");
d1416 3
a1418 3
     my($src,$code,$verbatim,$stype,$foo,@@other) =
         rearrange([SRC,CODE,VERBATIM,TYPE],
                    '-foo'=>'bar',    # trick to allow dash to be omitted
d1420 1
a1420 3
     $type  = $stype if $stype;
     my $other = @@other ? join ' ',@@other : '';

d1422 2
a1423 2
     { # If it is, push a LINK tag for each one
         foreach $src (@@$src)
d1425 2
a1426 2
         push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
                             : qq(<link rel="stylesheet" type="$type" href="$src"$other>)) if $src;
d1431 2
a1432 2
       push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
                           : qq(<link rel="stylesheet" type="$type" href="$src"$other>)
d1435 1
a1435 4
      if ($verbatim) {
         push(@@result, "<style type=\"text/css\">\n$verbatim\n</style>");
    }
      push(@@result,style({'type'=>$type},"$cdata_start\n$code\n$cdata_end")) if $code;
d1437 1
a1437 3
         my $src = $style;
         push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
                             : qq(<link rel="stylesheet" type="$type" href="$src"$other>));
d1471 11
a1481 15
    my ($cdata_start,$cdata_end);
    if ($XHTML) {
       $cdata_start    = "$comment<![CDATA[\n";
       $cdata_end     .= "\n$comment]]>";
    } else {
       $cdata_start  =  "\n<!-- Hide script\n";
       $cdata_end    = $comment;
       $cdata_end   .= " End script hiding -->\n";
   }
     my(@@satts);
     push(@@satts,'src'=>$src) if $src;
     push(@@satts,'language'=>$language) unless defined $type;
     push(@@satts,'type'=>$type);
     $code = "$cdata_start$code$cdata_end" if defined $code;
     push(@@result,script({@@satts},$code || ''));
d1507 1
a1507 1
#   A string containing a <isindex> tag
d1512 1
a1512 1
    $action = qq/ action="$action"/ if $action;
d1514 1
a1514 1
    return $XHTML ? "<isindex$action$other />" : "<isindex$action$other>";
d1535 2
a1536 4
       $action = $self->escapeHTML($self->url(-absolute=>1,-path=>1));
       if (length($ENV{QUERY_STRING})>0) {
           $action .= "?".$self->escapeHTML($ENV{QUERY_STRING},1);
       }
d1586 2
a1587 2
    return wantarray ? ("<div>",$self->get_fields,"</div>","</form>") : 
                        "<div>".$self->get_fields ."</div>\n</form>";
d1606 1
a1606 1
	rearrange([NAME,[DEFAULT,VALUE,VALUES],SIZE,MAXLENGTH,[OVERRIDE,FORCE]],@@p);
d1632 1
a1632 1
#   A string containing a <input type="text"> field
d1648 1
a1648 1
#   A string containing a <input type="file"> field
d1667 1
a1667 1
#   A string containing a <input type="password"> field
d1714 1
a1714 1
#   A string containing a <input type="button"> tag
d1747 1
a1747 1
#   A string containing a <input type="submit"> tag
d1761 1
a1761 1
    my $val = '';
d1775 1
a1775 1
#   A string containing a <input type="reset"> tag
d1780 1
a1780 1
    my($label,$value,@@other) = rearrange(['NAME',['VALUE','LABEL']],@@p);
d1782 1
a1782 6
    $value=$self->escapeHTML($value,1);
    my ($name) = ' name=".reset"';
    $name = qq/ name="$label"/ if defined($label);
    $value = defined($value) ? $value : $label;
    my($val) = '';
    $val = qq/ value="$value"/ if defined($value);
d1784 2
a1785 2
    return $XHTML ? qq(<input type="reset"$name$val$other />)
                  : qq(<input type="reset"$name$val$other>);
d1795 1
a1795 1
#   A string containing a <input type="submit" name=".defaults"> tag
d1837 1
a1837 1
#   A string containing a <input type="checkbox"> field
d1885 1
a1885 1
#   An ARRAY containing a series of <input type="checkbox"> fields
d1891 1
a1891 1
    my($name,$values,$defaults,$linebreak,$labels,$attributes,$rows,$columns,
d1894 1
a1894 1
            LINEBREAK,LABELS,ATTRIBUTES,ROWS,[COLUMNS,COLS],
a1923 1
        my $attribs = $self->_set_attributes($_, $attributes);
d1925 2
a1926 2
        push(@@elements,$XHTML ? qq(<input type="checkbox" name="$name" value="$_"$checked$other$attribs />${label}${break})
                              : qq/<input type="checkbox" name="$name" value="$_"$checked$other$attribs>${label}${break}/);
a1930 2
    $rows = 1 if $rows && $rows < 1;
    $cols = 1 if $cols && $cols < 1;
d1942 1
a1942 1
         return $toencode if ref($self) && !$self->{'escape'};
d1951 2
a1952 2
                $toencode =~ s{\x8b}{&#8249;}gso;
                $toencode =~ s{\x9b}{&#8250;}gso;
d2037 1
a2037 1
#   An ARRAY containing a series of <input type="radio"> fields
d2043 1
a2043 1
    my($name,$values,$default,$linebreak,$labels,$attributes,
d2045 1
a2045 1
  rearrange([NAME,[VALUES,VALUE],DEFAULT,LINEBREAK,LABELS,ATTRIBUTES,
a2078 1
  my $attribs = $self->_set_attributes($_, $attributes);
d2080 2
a2081 2
  push(@@elements,$XHTML ? qq(<input type="radio" name="$name" value="$_"$checkit$other$attribs />${label}${break})
                              : qq/<input type="radio" name="$name" value="$_"$checkit$other$attribs>${label}${break}/);
d2109 2
a2110 3
    my($name,$values,$default,$labels,$attributes,$override,@@other) =
       rearrange([NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LABELS,
       ATTRIBUTES,[OVERRIDE,FORCE]],@@p);
a2125 9
        if (/<optgroup/) {
            foreach (split(/\n/)) {
                my $selectit = $XHTML ? 'selected="selected"' : 'selected';
                s/(value="$selected")/$selectit $1/ if defined $selected;
                $result .= "$_\n";
            }
        }
        else {
            my $attribs = $self->_set_attributes($_, $attributes);
d2131 1
a2131 2
            $result .= "<option$selectit$attribs value=\"$value\">$label</option>\n";
        }
a2139 60
#### Method: optgroup
# Create a optgroup.
# Parameters:
#   $name -> Label for the group
#   $values -> A pointer to a regular array containing the
#              values for each option line in the group.
#   $labels -> (optional)
#              A pointer to an associative array of labels to print next to each item
#              in the form $label{'value'}="Long explanatory label".
#              Otherwise the provided values are used as the labels.
#   $labeled -> (optional)
#               A true value indicates the value should be used as the label attribute
#               in the option elements.
#               The label attribute specifies the option label presented to the user.
#               This defaults to the content of the <option> element, but the label
#               attribute allows authors to more easily use optgroup without sacrificing
#               compatibility with browsers that do not support option groups.
#   $novals -> (optional)
#              A true value indicates to suppress the val attribute in the option elements
# Returns:
#   A string containing the definition of an option group.
####
'optgroup' => <<'END_OF_FUNC',
sub optgroup {
    my($self,@@p) = self_or_default(@@_);
    my($name,$values,$attributes,$labeled,$noval,$labels,@@other)
        = rearrange([NAME,[VALUES,VALUE],ATTRIBUTES,LABELED,NOVALS,LABELS],@@p);

    my($result,@@values);
    @@values = $self->_set_values_and_labels($values,\$labels,$name,$labeled,$novals);
    my($other) = @@other ? " @@other" : '';

    $name=$self->escapeHTML($name);
    $result = qq/<optgroup label="$name"$other>\n/;
    foreach (@@values) {
        if (/<optgroup/) {
            foreach (split(/\n/)) {
                my $selectit = $XHTML ? 'selected="selected"' : 'selected';
                s/(value="$selected")/$selectit $1/ if defined $selected;
                $result .= "$_\n";
            }
        }
        else {
            my $attribs = $self->_set_attributes($_, $attributes);
            my($label) = $_;
            $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
            $label=$self->escapeHTML($label);
            my($value)=$self->escapeHTML($_,1);
            $result .= $labeled ? $novals ? "<option$attribs label=\"$value\">$label</option>\n"
                                          : "<option$attribs label=\"$value\" value=\"$value\">$label</option>\n"
                                : $novals ? "<option$attribs>$label</option>\n"
                                          : "<option$attribs value=\"$value\">$label</option>\n";
        }
    }
    $result .= "</optgroup>";
    return $result;
}
END_OF_FUNC


d2163 1
a2163 1
    my($name,$values,$defaults,$size,$multiple,$labels,$attributes,$override,@@other)
d2165 1
a2165 1
          SIZE,MULTIPLE,LABELS,ATTRIBUTES,[OVERRIDE,FORCE]],@@p);
d2185 1
a2185 2
        my $attribs = $self->_set_attributes($_, $attributes);
        $result .= "<option$selectit$attribs value=\"$value\">$label</option>\n";
d2201 1
a2201 1
#   A string containing a <input type="hidden" name="name" value="value">
d2244 1
a2244 1
#   A string containing a <input type="image" name="name" src="url" align="alignment">
d2303 1
a2303 1
	$script_name = unescape($ENV{REQUEST_URI});
d2307 1
a2307 1
           my $encoded_path = quotemeta($ENV{PATH_INFO});
a2807 11
#### Method: close_upload_files
# Set or return the close_upload_files global flag
####
'close_upload_files' => <<'END_OF_FUNC',
sub close_upload_files {
    my ($self,$param) = self_or_CGI(@@_);
    $CGI::CLOSE_UPLOAD_FILES = $param if defined($param);
    return $CGI::CLOSE_UPLOAD_FILES;
}
END_OF_FUNC

a2910 1
        $param .= $TAINTED;
a2913 4
	# Test for Opera's multiple upload feature
	my($multipart) = ( defined( $header{'Content-Type'} ) &&
		$header{'Content-Type'} =~ /multipart\/mixed/ ) ?
		1 : 0;
d2920 1
a2920 1
	if ( ( !defined($filename) || $filename eq '' ) && !$multipart ) {
a2921 1
            $value .= $TAINTED;
a2937 5
	  # set the filename to some recognizable value
          if ( ( !defined($filename) || $filename eq '' ) && $multipart ) {
              $filename = "multipart/mixed";
          }

a2948 10
	  # if this is an multipart/mixed attachment, save the header
	  # together with the body for lateron parsing with an external
	  # MIME parser module
	  if ( $multipart ) {
	      foreach ( keys %header ) {
		  print $filehandle "$_: $header{$_}${CRLF}";
	      }
	      print $filehandle "${CRLF}";
	  }

a2956 6

      ## Close the filehandle if requested this allows a multipart MIME
      ## upload to contain many files, and we won't die due to too many
      ## open file handles. The user can access the files using the hash
      ## below.
      close $filehandle if $CLOSE_UPLOAD_FILES;
a3007 16
# internal routine, don't use
'_set_attributes' => <<'END_OF_FUNC',
sub _set_attributes {
    my $self = shift;
    my($element, $attributes) = @@_;
    return '' unless defined($attributes->{$element});
    $attribs = ' ';
    foreach my $attrib (keys %{$attributes->{$element}}) {
        $attrib =~ s/^-//;
        $attribs .= "@@{[lc($attrib)]}=\"$attributes->{$element}{$attrib}\" ";
    }
    $attribs =~ s/ $//;
    return $attribs;
}
END_OF_FUNC

d3046 1
a3046 1
    return $i.$CGI::TAINTED;
a3068 1
    _setup_symbols(@@SAVED_SYMBOLS) if @@SAVED_SYMBOLS;
d3073 2
a3074 4
    $file =~ m!^([a-zA-Z0-9_ \'\":/.\$\\-]+)$! || return;
    my $safe = $1;
    sysopen($ref,$safe,Fcntl::O_RDWR()|Fcntl::O_CREAT()|Fcntl::O_EXCL(),0600) || return;
    unlink($safe) if $delete;
d3200 1
a3206 1

d3208 1
a3208 1
        my ($field_name,$field_value) = ($1,$2);
d3265 1
a3265 1
    my $bytesToReturn;
d3267 1
a3267 1
        $bytesToReturn = $start-2 > $bytes ? $bytes : $start;
d3279 1
a3279 1
    return ($bytesToReturn==$start)
d3339 4
a3342 6
sub find_tempdir {
  undef $TMPDIRECTORY;
  $SL = $CGI::SL;
  $MAC = $CGI::OS eq 'MACINTOSH';
  my ($vol) = $MAC ? MacPerl::Volumes() =~ /:(.*)/ : "";
  unless ($TMPDIRECTORY) {
d3348 1
a3348 1
    unshift(@@TEMP,$ENV{'TMPDIR'}) if defined $ENV{'TMPDIR'};
d3360 1
a3360 1
      do {$TMPDIRECTORY = $_; last} if -d $_ && -w _;
a3361 2
  }
  $TMPDIRECTORY  = $MAC ? "" : "." unless $TMPDIRECTORY;
d3364 1
a3364 2
find_tempdir();

d3373 1
a3373 3
    $$self =~ m!^([a-zA-Z0-9_ \'\":/.\$\\-]+)$! || return;
    my $safe = $1;             # untaint operation
    unlink $safe;              # get rid of the file
a3386 1
    find_tempdir() unless -w $TMPDIRECTORY;
d3390 3
a3392 4
    # check that it is a more-or-less valid filename
    return unless $filename =~ m!^([a-zA-Z0-9_ \'\":/.\$\\-]+)$!;
    # this used to untaint, now it doesn't
    # $filename = $1;
d3577 2
a3578 2
   h1({-align=>left});            <h1 align="LEFT">
   h1({-align=>left},'contents'); <h1 align="LEFT">contents</h1>
d3580 1
a3580 1
HTML tags are described in more detail later.
a3743 5

If the parameter does not exist at all, then param() will return undef
in a scalar context, and the empty list in a list context.


d3782 1
a3782 6
NOTE 1: Variable names are transformed as necessary into legal Perl
variable names.  All non-legal characters are transformed into
underscores.  If you need to keep the original names, you should use
the param() method instead to access CGI variables by name.

NOTE 2: In older versions, this method was called B<import()>.  As of version 2.20, 
d3788 1
a3788 1
    $query->delete('foo','bar','baz');
d3790 3
a3792 3
This completely clears a list of parameters.  It sometimes useful for
resetting parameters that you don't want passed down between script
invocations.
d4093 1
a4093 8
compile() method instead:

   use CGI();
   CGI->compile();

This is particularly useful in a mod_perl environment, in which you
might want to precompile all CGI routines in a startup script, and
then import the functions individually in each mod_perl script.
d4328 1
a4328 1
headers to work with a NPH (no-parse-header) script.  This is important
a4340 11
The B<-p3p> parameter will add a P3P tag to the outgoing header.  The
parameter can be an arrayref or a space-delimited string of P3P tags.
For example:

   print header(-p3p=>[qw(CAO DSP LAW CURa)]);
   print header(-p3p=>'CAO DSP LAW CURa');

In either case, the outgoing header will be formatted as:

  P3P: policyref="/w3c/p3p.xml" cp="CAO DSP LAW CURa"

d4365 2
a4366 2
headers to work with a NPH (no-parse-header) script.  This is important
to use with certain servers, such as Microsoft IIS, which
a4429 3
To leave off the lang attribute, as you must do if you want to generate
legal HTML 3.2 or earlier, pass the empty string (-lang=>'').

d4593 3
a4595 3
     print "<a href=\"$myself#table1\">See table 1</a>";
     print "<a href=\"$myself#table2\">See table 2</a>";
     print "<a href=\"$myself#yourself\">See for yourself</a>";
d4662 1
a4662 1
   $color = $query->url_param('color');
d4750 1
a4750 1
lists can be marked as COMPACT.  The syntax for this is an argument that
d4757 1
a4757 1
changed in order to accommodate those who want to create tags of the form 
d4760 3
a4762 3
   CODE                   RESULT
   img({alt=>undef})      <img alt>
   img({alt=>''})         <img alt="">
d4866 1
a4866 1
0x8b and 0x9b characters, which some browsers incorrectly interpret
d4868 1
a4868 1
numeric character entities ("&#8249" and "&#8250;").  If you manually change
d4878 1
a4878 1
To turn autoescaping off completely, use autoEscape(0):
a5280 1
   %attributes = ('eenie'=>{'class'=>'class of first choice'});
d5283 1
a5283 1
          'meenie',\%labels,\%attributes);
d5290 1
a5290 2
          -labels=>\%labels,
          -attributes=>\%attributes);
d5317 1
a5317 1
popup menu and the value returned to your script.  It's a pointer to an
a5321 8
=item 5.

The optional fifth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
attribute's value as the value.

a5333 75
=head2 CREATING AN OPTION GROUP

Named parameter style

  print $query->popup_menu(-name=>'menu_name',
                  -values=>[qw/eenie meenie minie/,
                            $q->optgroup(-name=>'optgroup_name',
                                         -values ['moe','catch'],
                                         -attributes=>{'catch'=>{'class'=>'red'}}),
                  -labels=>{'eenie'=>'one',
                            'meenie'=>'two',
                            'minie'=>'three'},
                  -default=>'meenie');

  Old style
  print $query->popup_menu('menu_name',
                  ['eenie','meenie','minie',
                   $q->optgroup('optgroup_name', ['moe', 'catch'],
                         {'catch'=>{'class'=>'red'}})],'meenie',
                  {'eenie'=>'one','meenie'=>'two','minie'=>'three'});

optgroup creates an option group within a popup menu.

=over 4

=item 1.

The required first argument (B<-name>) is the label attribute of the
optgroup and is B<not> inserted in the parameter list of the query.

=item 2.

The required second argument (B<-values>)  is an array reference
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference
to a named array, such as \@@foo.  If you pass a HASH reference,
the keys will be used for the menu values, and the values will be
used for the menu labels (see -labels below).

=item 3.

The optional third parameter (B<-labels>) allows you to pass a reference
to an associative array containing user-visible labels for one or more
of the menu items.  You can use this when you want the user to see one
menu string, but have the browser return your program a different one.
If you don't specify this, the value string will be used instead
("eenie", "meenie" and "minie" in this example).  This is equivalent
to using a hash reference for the -values parameter.

=item 4.

An optional fourth parameter (B<-labeled>) can be set to a true value
and indicates that the values should be used as the label attribute
for each option element within the optgroup.

=item 5.

An optional fifth parameter (-novals) can be set to a true value and
indicates to suppress the val attribut in each option element within
the optgroup.

See the discussion on optgroup at W3C
(http://www.w3.org/TR/REC-html40/interact/forms.html#edef-OPTGROUP)
for details.

=item 6.

An optional sixth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
attribute's value as the value.

=back

d5338 1
a5338 1
        ['eenie','moe'],5,'true',{'moe'=>{'class'=>'red'}});
d5344 1
a5344 1
        \%labels,%attributes);
d5353 1
a5353 2
        -labels=>\%labels,
        -attributes=>\%attributes);
a5391 8
=item 6.

The optional sixth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
attribute's value as the value.

d5411 1
a5411 2
        -labels=>\%labels,
        -attributes=>\%attributes);
d5415 1
a5415 2
        ['eenie','moe'],'true',\%labels,
        {'moe'=>{'class'=>'red'}});
a5467 8
=item 6.

The optional sixth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
attribute's value as the value.

d5552 1
a5552 2
           -labels=>\%labels,
           -attributes=>\%attributes);
d5557 1
a5557 1
            'meenie','true',\%labels,\%attributes);
a5614 8
=item 6.

The optional sixth parameter (-attributes) is provided to assign
any of the common HTML attributes to an individual menu item. It's
a pointer to an associative array relating menu values to another
associative array with the attribute's name as the key and the
attribute's value as the value.

d5767 1
a6065 37
Should you wish to incorporate a verbatim stylesheet that includes
arbitrary formatting in the header, you may pass a -verbatim tag to
the -style hash, as follows:

print $q->start_html (-STYLE  =>  {-verbatim => '@@import
url("/server-common/css/'.$cssFile.'");',
                      -src      =>  '/server-common/css/core.css'});
</blockquote></pre>


This will generate an HTML header that contains this:

 <link rel="stylesheet" type="text/css"  href="/server-common/css/core.css">
   <style type="text/css">
   @@import url("/server-common/css/main.css");
   </style>

Any additional arguments passed in the -style value will be
incorporated into the <link> tag.  For example:

 start_html(-style=>{-src=>['/styles/print.css','/styles/layout.css'],
			  -media => 'all'});

This will give:

 <link rel="stylesheet" type="text/css" href="/styles/print.css" media="all"/>
 <link rel="stylesheet" type="text/css" href="/styles/layout.css" media="all"/>

<p>

To make more complicated <link> tags, use the Link() function
and pass it to start_html() in the -head argument, as in:

  @@h = (Link({-rel=>'stylesheet',-type=>'text/css',-src=>'/ss/ss.css',-media=>'all'}),
        Link({-rel=>'stylesheet',-type=>'text/css',-src=>'/ss/fred.css',-media=>'paper'}));
  print start_html({-head=>\@@h})

d6201 1
d6682 7
a6688 1
Please report them.
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.145 2003/12/10 15:16:08 lstein Exp $';
$CGI::VERSION=3.01;
d27 1
a27 1
use CGI::Util qw(rearrange make_attributes unescape escape expires ebcdic2ascii ascii2ebcdic);
d213 3
a215 3
    $CGI::DefaultClass->binmode(\*main::STDOUT);
    $CGI::DefaultClass->binmode(\*main::STDIN);
    $CGI::DefaultClass->binmode(\*main::STDERR);
d235 2
a236 2
			 remote_addr referer server_name server_software server_port server_protocol virtual_port
			 virtual_host remote_ident auth_type http append
a297 1

d325 3
a327 14
# We provide a DESTROY method so that we can ensure that
# temporary files are closed (via Fh->DESTROY) before they
# are unlinked (via CGITempFile->DESTROY) because it is not
# possible to unlink an open file on Win32. We explicitly
# call DESTROY on each, rather than just undefing them and
# letting Perl DESTROY them by garbage collection, in case the
# user is still holding any reference to them as well.
sub DESTROY {
  my $self = shift;
  foreach my $href (values %{$self->{'.tmpfiles'}}) {
    $href->{hndl}->DESTROY if defined $href->{hndl};
    $href->{name}->DESTROY if defined $href->{name};
  }
}
a335 6
sub upload_hook {
  my ($self,$hook,$data) = self_or_default(@@_);
  $self->{'.upload_hook'} = $hook;
  $self->{'.upload_data'} = $data;
}

d450 2
a451 7
	  while ($max > 0 &&
		 (my $bytes = $MOD_PERL
                  ? $self->r->read($buffer,$max < 10000 ? $max : 10000)
                  : read(STDIN,$buffer,$max < 10000 ? $max : 10000)
                 )) {
	    $self->cgi_error("413 Request entity too large");
	    last METHOD;
d453 3
a455 1
	}
a497 15
          if (defined($fh) && ($fh ne '')) {
              while (<$fh>) {
                  chomp;
                  last if /^=/;
                  push(@@lines,$_);
              }
              # massage back into standard format
              if ("@@lines" =~ /=/) {
                  $query_string=join("&",@@lines);
              } else {
                  $query_string=join("+",@@lines);
              }
              last METHOD;
          }

d518 1
a518 1
	  $self->read_from_client(\$query_string,$content_length,0)
d531 1
a531 9
      if ($DEBUG)
      {
          my $cmdline_ret = read_from_cmdline();
          $query_string = $cmdline_ret->{'query_string'};
          if (defined($cmdline_ret->{'subpath'}))
          {
              $self->path_info($cmdline_ret->{'subpath'});
          }
      }
a657 1
    return unless defined($_[1]) && defined fileno($_[1]);
d826 2
a827 2
    my($self,$boundary,$length) = @@_;
    return MultipartBuffer->new($self,$boundary,$length);
d834 1
a834 1
    my($self, $buff, $len, $offset) = @@_;
d836 2
a837 3
    return $MOD_PERL
        ? $self->r->read($$buff, $len, $offset)
        : read(\*STDIN, $$buff, $len, $offset);
d1303 1
a1303 1
    return "" if $self->{'.header_printed'}++ and $HEADERS_ONCE;
d1533 1
a1533 1
   if ($verbatim) {
a1641 1

d2512 1
a2512 1
		unless (lc($protocol) eq 'http'  && $port == 80)
a2852 15
#### Method: virtual_port
# Return the server port, taking virtual hosts into account
####
'virtual_port' => <<'END_OF_FUNC',
sub virtual_port {
    my($self) = self_or_default(@@_);
    my $vh = $self->http('host');
    if ($vh) {
        return ($vh =~ /:(\d+)$/)[0] || '80';
    } else {
        return $self->server_port();
    }
}
END_OF_FUNC

a3064 1
    my($subpath);
d3069 1
a3069 1
	print STDERR "(offline mode: enter name=value pairs on standard input; press ^D or ^Z when done)\n";
d3084 1
a3084 6
    if ($query_string =~ /^(.*?)\?(.*)$/)
    {
        $query_string = $2;
        $subpath = $1;
    }
    return { 'query_string' => $query_string, 'subpath' => $subpath };
d3098 2
a3099 2
    my($self,$boundary,$length) = @@_;
    my($buffer) = $self->new_MultipartBuffer($boundary,$length);
d3159 1
a3159 2
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode 
                     && defined fileno($filehandle);
d3162 1
a3162 1
	  # together with the body for later parsing with an external
d3173 1
a3173 7
          my $totalbytes;
          while (defined($data = $buffer->read)) {
              if (defined $self->{'.upload_hook'})
               {
                  $totalbytes += length($data);
                   &{$self->{'.upload_hook'}}($filename ,$data, $totalbytes, $self->{'.upload_data'});
              }
d3175 1
a3175 1
          }
a3189 1
              hndl => $filehandle,
a3339 2
use constant DEBUG => 0;

d3362 1
a3362 1
    my($package,$interface,$boundary,$length) = @@_;
d3364 9
a3372 1
    $CGI::DefaultClass->binmode($IN); # if $CGI::needs_binmode;  # just do it always
d3395 1
a3395 1
	$boundary = <STDIN>;      # BUG: This won't work correctly under mod_perl
d3404 1
d3418 1
a3418 1
    die "Malformed multipart POST: data truncated\n" if $self->eof;
d3431 1
a3431 1
    local($CRLF) = "\015\012" if $CGI::OS eq 'VMS' || $CGI::EBCDIC;
a3442 2
    #EBCDIC NOTE: translate header into EBCDIC, but watch out for continuation lines!

a3446 6
    if ($CGI::EBCDIC) {
      warn "untranslated header=$header\n" if DEBUG;
      $header = CGI::Util::ascii2ebcdic($header);
      warn "translated header=$header\n" if DEBUG;
    }

a3468 3

    #EBCDIC NOTE: want to translate returnval into EBCDIC HERE

a3471 6

    if ($CGI::EBCDIC) {
      warn "untranslated body=$returnval\n" if DEBUG;
      $returnval = CGI::Util::ascii2ebcdic($returnval);
      warn "translated body=$returnval\n"   if DEBUG;
    }
d3484 1
a3484 1
    $bytes = $bytes || $FILLUNIT;
a3489 3
    my $boundary_start = $CGI::EBCDIC ? CGI::Util::ebcdic2ascii($self->{BOUNDARY})      : $self->{BOUNDARY};
    my $boundary_end   = $CGI::EBCDIC ? CGI::Util::ebcdic2ascii($self->{BOUNDARY}.'--') : $self->{BOUNDARY}.'--';

d3491 1
a3491 3
    my $start = index($self->{BUFFER},$boundary_start);

    warn "boundary=$self->{BOUNDARY} length=$self->{LENGTH} start=$start\n" if DEBUG;
a3494 3

    #EBCDIC NOTE: want to translate boundary search into ASCII here.

d3500 1
a3500 1
	if (index($self->{BUFFER},$boundary_end)==0) {
d3507 1
a3507 1
	substr($self->{BUFFER},0,length($boundary_start))='';
d3519 1
a3519 1
	$bytesToReturn = $bytes - (length($boundary_start)+1);
d3544 3
a3546 2
    # Try to read some data.  We may hang here if the browser is screwed up.
    my $bytesRead = $self->{INTERFACE}->read_from_client(\$self->{BUFFER},
a3548 1
    warn "bytesToRead=$bytesToRead, bufferLength=$bufferLength, buffer=$self->{BUFFER}\n" if DEBUG;
d4637 5
a4641 2
You should always use full URLs (including the http: or ftp: part) in
redirection requests.  Relative URLs will not work correctly.
a5546 23
You can set up a callback that will be called whenever a file upload
is being read during the form processing. This is much like the
UPLOAD_HOOK facility available in Apache::Request, with the exception
that the first argument to the callback is an Apache::Upload object,
here it's the remote filename.

 $q = CGI->new();
 $q->upload_hook(\&hook,$data);

 sub hook
 {
        my ($filename, $buffer, $bytes_read, $data) = @@_;
        print  "Read $bytes_read bytes of $filename\n";         
 }

If using the function-oriented interface, call the CGI::upload_hook()
method before calling param() or any other CGI functions:

  CGI::upload_hook(\&hook,$data);

This method is not exported by default.  You will have to import it
explicitly if you wish to use it without the CGI:: prefix.

d6396 2
a6397 2
parameter may be a scalar, in which case it is treated as the source
URL for the stylesheet, or it may be a hash reference.  In the latter
a6536 5
Finally, you can set the path info for the script by prefixing the first
name/value parameter with the path followed by a question mark (?):

    your_script.pl /your/path/here?name1=value1&name2=value2

a6663 5

=item B<virtual_port ()>

Like server_port() except that it takes virtual hosts into account.
Use this when running with virtual hosts.
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.8 2004/04/07 21:33:04 millert Exp $';
$CGI::VERSION=3.05;
d40 2
a42 1
@@SAVED_SYMBOLS = ();
a113 1
    $DTD_PUBLIC_IDENTIFIER = "";
a124 2
*end_form = \&endform;

a183 1
      require Apache::Response;
a306 4
 if (ref($initializer[0]) 
     && (UNIVERSAL::isa($initializer[0],'CODE'))) {
    $self->upload_hook(shift @@initializer, shift @@initializer);
  }
d604 1
a604 1
      $self->delete_all();
d817 1
a817 1
	$CLOSE_UPLOAD_FILES++,   next if /^[:-]close_upload_files$/;
d903 1
a903 1
    return;
d1277 1
a1277 1
	-nph => 0,
d1437 1
a1437 3
    my($url,$target,$status,$cookie,$nph,@@other) = 
         rearrange([[LOCATION,URI,URL],TARGET,STATUS,['COOKIE','COOKIES'],NPH],@@p);
    $status = '302 Moved' unless defined $status;
d1442 1
a1442 1
	 '-Status'  => $status,
d1482 5
a1486 1
    # Need to sort out the DTD before it's okay to call escapeHTML().
a1503 1
	$DTD_PUBLIC_IDENTIFIER = $dtd->[0];
a1505 15
	$DTD_PUBLIC_IDENTIFIER = $dtd;
    }

    # Now that we know whether we're using the HTML 3.2 DTD or not, it's okay to
    # call escapeHTML().  Strangely enough, the title needs to be escaped as
    # HTML while the author needs to be escaped as a URL.
    $title = $self->escapeHTML($title || 'Untitled Document');
    $author = $self->escape($author);

    if ($DTD_PUBLIC_IDENTIFIER =~ /[^X]HTML (2\.0|3\.2)/i) {
	$lang = "" unless defined $lang;
	$XHTML = 0;
    }
    else {
	$lang = 'en-US' unless defined $lang;
a1506 1

d1529 1
a1529 1
    push(@@result,$self->_style($style))   if defined $style;
d1557 13
a1569 16
    my @@s = ref($style) eq 'ARRAY' ? @@$style : $style;

    for my $s (@@s) {
      if (ref($s)) {
       my($src,$code,$verbatim,$stype,$foo,@@other) =
           rearrange([qw(SRC CODE VERBATIM TYPE FOO)],
                      ('-foo'=>'bar',
                       ref($s) eq 'ARRAY' ? @@$s : %$s));
       $type  = $stype if $stype;
       my $other = @@other ? join ' ',@@other : '';

       if (ref($src) eq "ARRAY") # Check to see if the $src variable is an array reference
       { # If it is, push a LINK tag for each one
           foreach $src (@@$src)
         {
           push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
a1570 1
         }
d1572 13
a1584 2
       else
       { # Otherwise, push the single -src, if it exists.
d1586 1
a1586 15
                             : qq(<link rel="stylesheet" type="$type" href="$src"$other>)
              ) if $src;
        }
     if ($verbatim) {
           my @@v = ref($verbatim) eq 'ARRAY' ? @@$verbatim : $verbatim;
           push(@@result, "<style type=\"text/css\">\n$_\n</style>") foreach @@v;
      }
      my @@c = ref($code) eq 'ARRAY' ? @@$code : $code if $code;
      push(@@result,style({'type'=>$type},"$cdata_start\n$_\n$cdata_end")) foreach @@c;

      } else {
           my $src = $s;
           push(@@result,$XHTML ? qq(<link rel="stylesheet" type="$type" href="$src" $other/>)
                               : qq(<link rel="stylesheet" type="$type" href="$src"$other>));
      }
d1685 4
a1688 6
    $method  = $self->escapeHTML(lc($method) || 'post');
    $enctype = $self->escapeHTML($enctype || &URL_ENCODED);
    if (defined $action) {
       $action = $self->escapeHTML($action);
    }
    else {
d1690 1
a1690 1
       if (exists $ENV{QUERY_STRING} && length($ENV{QUERY_STRING})>0) {
d1749 9
d1914 1
a1914 1
    my $name = $NOSTICKY ? '' : ' name=".submit"';
d2091 1
a2091 1
    return wantarray ? @@elements : join(' ',@@elements)
d2110 1
a2110 9
	 if ($DTD_PUBLIC_IDENTIFIER =~ /[^X]HTML 3\.2/i) {
	     # $quot; was accidentally omitted from the HTML 3.2 DTD -- see
	     # <http://validator.w3.org/docs/errors.html#bad-entity> /
	     # <http://lists.w3.org/Archives/Public/www-html/1997Mar/0003.html>.
	     $toencode =~ s{"}{&#34;}gso;
         }
         else {
	     $toencode =~ s{"}{&quot;}gso;
         }
a2128 2
    # hack to work around  earlier hacks
    push @@_,$_[0] if @@_==1 && $_[0] eq 'CGI';
d2467 2
a2468 2
	push @@result,$XHTML ? qq(<input type="hidden" name="$name" value="$_" @@other />)
                            : qq(<input type="hidden" name="$name" value="$_" @@other>);
d2541 1
a2541 1
        $script_name =~ s/\?.+$//s;   # strip query string
d2544 2
a2545 2
           my $encoded_path = unescape($ENV{PATH_INFO});
           $script_name      =~ s/\Q$encoded_path\E$//i;
d2552 1
a2552 1
	my $vh = http('x_forwarded_host') || http('host');
d2824 1
a2824 1
    my $vh = http('x_forwarded_host') || http('host') || server_name();
d2906 1
a2906 1
    my $vh = $self->http('x_forwarded_host') || $self->http('host');
d3179 1
a3179 1
	my($param)= $header{'Content-Disposition'}=~/ name="([^;]*)"/;
d3183 1
a3183 1
	my($filename) = $header{'Content-Disposition'}=~/ filename="([^;]*)"/;
d3320 2
a3321 2
        (my $clean_attrib = $attrib) =~ s/^-//;
        $attribs .= "@@{[lc($clean_attrib)]}=\"$attributes->{$element}{$attrib}\" ";
a4480 4
If start_html()'s -dtd parameter specifies an HTML 2.0 or 3.2 DTD, 
XHTML will automatically be disabled without needing to use this 
pragma.

d4737 1
a4737 2
			   -nph=>1,
                           -status=>301);
a4743 12
The B<-status> parameter will set the status of the redirect.  HTTP
defines three different possible redirection status codes:

     301 Moved Permanently
     302 Found
     303 See Other

The default if not specified is 302, which means "moved temporarily."
You may change the status to another status code if you wish.  Be
advised that changing the status to anything other than 301, 302 or
303 will probably break redirection.

d4800 2
a4801 1
the <html> tag.  For example:
d4805 2
a4806 4
The default if not specified is "en-US" for US English, unless the 
-dtd parameter specifies an HTML 2.0 or 3.2 DTD, in which case the
lang attribute is left off.  You can force the lang attribute to left
off in other cases by passing an empty string (-lang=>'').
a5314 15
I<A Lurking Trap!> Some of the form-element generating methods return
multiple tags.  In a scalar context, the tags will be concatenated
together with spaces, or whatever is the current value of the $"
global.  In a list context, the methods will return a list of
elements, allowing you to modify them if you wish.  Usually you will
not notice this behavior, but beware of this:

    printf("%s\n",$query->end_form())

end_form() produces several tags, and only the first of them will be
printed because the format only expects one value.

<p>


d5597 1
a5597 1
In an list context, upload() will return an array of filehandles.
d6170 3
a6172 1
to distinguish between them.  
d6177 1
a6177 8
a value that will be passed to your script in the query string. The
name will also be used as the user-visible label.

=item 3.

You can use -label as an alias for -value.  I always get confused
about which of -name and -value changes the user-visible label on the
button.
d6576 2
a6577 2
Pass an array reference to B<-code> or B<-src> in order to incorporate
multiple stylesheets into your document.
d7068 1
a7068 1
    CGI::ReadParse;
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d21 1
a21 1
$CGI::revision = '$Id: CGI.pm,v 1.165 2004/04/12 20:37:26 lstein Exp $';
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.194 2005/12/06 22:12:56 lstein Exp $';
$CGI::VERSION='3.15';
a79 3
    # Set this to 1 to generate automatic tab indexes
    $TABINDEX = 0;

d180 1
d183 11
a193 10
  if (exists $ENV{MOD_PERL_API_VERSION} && $ENV{MOD_PERL_API_VERSION} == 2) {
    $MOD_PERL = 2;
    require Apache2::Response;
    require Apache2::RequestRec;
    require Apache2::RequestUtil;
    require Apache2::RequestIO;
    require APR::Pool;
  } else {
    $MOD_PERL = 1;
    require Apache;
d236 1
a236 2
		':cgi'=>[qw/param upload path_info path_translated request_uri url self_url script_name 
			 cookie Dump
a250 27
# Custom 'can' method for both autoloaded and non-autoloaded subroutines.
# Author: Cees Hek <cees@@sitesuite.com.au>

sub can {
	my($class, $method) = @@_;

	# See if UNIVERSAL::can finds it.

	if (my $func = $class -> SUPER::can($method) ){
		return $func;
	}

	# Try to compile the function.

	eval {
		# _compile looks at $AUTOLOAD for the function name.

		local $AUTOLOAD = join "::", $class, $method;
		&_compile;
	};

	# Now that the function is loaded (if it exists)
	# just use UNIVERSAL::can again to do the work.

	return $class -> SUPER::can($method);
}

d306 1
a306 1
	  UNIVERSAL::isa($initializer[0],'Apache2::RequestRec')
d315 2
a317 2
      $self->r(Apache->request) unless $self->r;
      my $r = $self->r;
a322 2
      $self->r(Apache2::RequestUtil->request) unless $self->r;
      my $r = $self->r;
d342 3
a344 5
  if ($OS eq 'WINDOWS') {
    foreach my $href (values %{$self->{'.tmpfiles'}}) {
      $href->{hndl}->DESTROY if defined $href->{hndl};
      $href->{name}->DESTROY if defined $href->{name};
    }
d356 1
a356 7
  my $self;
  if (ref $_[0] eq 'CODE') {
    $CGI::Q = $self = $CGI::DefaultClass->new(@@_);
  } else {
    $self = shift;
  }
  my ($hook,$data) = @@_;
d474 10
a483 9
          my $tmplength = $content_length;
          while($tmplength > 0) {
                 my $maxbuffer = ($tmplength < 10000)?$tmplength:10000;
                 my $bytesread = $MOD_PERL ? $self->r->read($buffer,$maxbuffer) : read(STDIN,$buffer,$maxbuffer);
                 $tmplength -= $bytesread;
          }
          $self->cgi_error("413 Request entity too large");
          last METHOD;
       }
a761 1
	   local ($@@,$!);
a779 1
       local ($@@,$!);
d794 1
a794 1
  return $XHTML ? qq(selected="selected" ) : qq(selected );
d801 1
a801 1
  return $XHTML ? qq(checked="checked" ) : qq(checked );
a823 1
	$TABINDEX++,             next if /^[:-]tabindex$/;
a854 15
sub element_id {
  my ($self,$new_value) = self_or_default(@@_);
  $self->{'.elid'} = $new_value if defined $new_value;
  sprintf('%010d',$self->{'.elid'}++);
}

sub element_tab {
  my ($self,$new_value) = self_or_default(@@_);
  $self->{'.etab'} ||= 1;
  $self->{'.etab'} = $new_value if defined $new_value;
  my $tab = $self->{'.etab'}++;
  return '' unless $TABINDEX or defined $new_value;
  return qq(tabindex="$tab" );
}

d1095 1
a1095 1
    my($self,@@p) = self_or_default(@@_);
d1486 2
a1487 6
        $target,$meta,$head,$style,$dtd,$lang,$encoding,$declare_xml,@@other) = 
	rearrange([TITLE,AUTHOR,BASE,XBASE,SCRIPT,NOSCRIPT,TARGET,
                   META,HEAD,STYLE,DTD,LANG,ENCODING,DECLARE_XML],@@p);

    $self->element_id(0);
    $self->element_tab(0);
d1505 1
a1505 1
    push @@result,qq(<?xml version="1.0" encoding="$encoding"?>) if $xml_dtd && $declare_xml;
d1529 2
a1530 6
    my $lang_bits = $lang ne '' ? qq( lang="$lang" xml:lang="$lang") : '';
    my $meta_bits = qq(<meta http-equiv="Content-Type" content="text/html; charset=$encoding" />) 
                    if $XHTML && $encoding && !$declare_xml;

    push(@@result,$XHTML ? qq(<html xmlns="http://www.w3.org/1999/xhtml"$lang_bits>\n<head>\n<title>$title</title>)
                        : ($lang ? qq(<html lang="$lang">) : "<html>")
d1534 1
a1534 1
			: "<link rev=\"made\" href=\"mailto:$author\">");
a1552 1
    push(@@result,$meta_bits)              if defined $meta_bits;
d1562 1
a1562 1
    push(@@result,"</head>\n<body$other>\n");
d1662 2
a1663 2
     $code = $cdata_start . $code . $cdata_end if defined $code;
     push(@@result,$self->script({@@satts},$code || ''));
d1675 1
a1675 1
    return "\n</body>\n</html>";
d1720 4
a1723 1
       $action = $self->escapeHTML($self->request_uri);
d1737 1
a1737 1
    $XHTML ? &start_multipart_form : &startform;
d1752 1
a1752 1
    if (defined($p[0]) && substr($p[0],0,1) eq '-') {
d1769 1
a1769 1
    my($self,@@p) = self_or_default(@@_);
d1773 2
a1774 6
      if (my @@fields = $self->get_fields) {
         return wantarray ? ("<div>",@@fields,"</div>","</form>")
                          : "<div>".(join '',@@fields)."</div>\n</form>";
      } else {
         return "</form>";
      }
d1783 2
a1784 2
    my($name,$default,$size,$maxlength,$override,$tabindex,@@other) = 
	rearrange([NAME,[DEFAULT,VALUE,VALUES],SIZE,MAXLENGTH,[OVERRIDE,FORCE],TABINDEX],@@p);
d1797 1
a1797 2
    $tabindex = $self->element_tab($tabindex);
    return $XHTML ? qq(<input type="$tag" name="$name" $tabindex$value$s$m$other />) 
d1867 3
a1869 2
    my($name,$default,$rows,$cols,$override,$tabindex,@@other) =
	rearrange([NAME,[DEFAULT,VALUE],ROWS,[COLS,COLUMNS],[OVERRIDE,FORCE],TABINDEX],@@p);
d1879 1
a1879 2
    $tabindex = $self->element_tab($tabindex);
    return qq{<textarea name="$name" $tabindex$r$c$other>$current</textarea>};
d1898 2
a1899 2
    my($label,$value,$script,$tabindex,@@other) = rearrange([NAME,[VALUE,LABEL],
						            [ONCLICK,SCRIPT],TABINDEX],@@p);
d1912 1
a1912 2
    $tabindex = $self->element_tab($tabindex);
    return $XHTML ? qq(<input type="button" $tabindex$name$val$script$other />)
d1931 1
a1931 1
    my($label,$value,$tabindex,@@other) = rearrange([NAME,[VALUE,LABEL],TABINDEX],@@p);
d1936 2
a1937 2
    my $name = $NOSTICKY ? '' : 'name=".submit" ';
    $name = qq/name="$label" / if defined($label);
d1940 4
a1943 5
    $val = qq/value="$value" / if defined($value);
    $tabindex = $self->element_tab($tabindex);
    my($other) = @@other ? "@@other " : '';
    return $XHTML ? qq(<input type="submit" $tabindex$name$val$other/>)
                  : qq(<input type="submit" $name$val$other>);
d1958 1
a1958 1
    my($label,$value,$tabindex,@@other) = rearrange(['NAME',['VALUE','LABEL'],TABINDEX],@@p);
d1967 1
a1967 2
    $tabindex = $self->element_tab($tabindex);
    return $XHTML ? qq(<input type="reset" $tabindex$name$val$other />)
d1988 1
a1988 1
    my($label,$tabindex,@@other) = rearrange([[NAME,VALUE],TABINDEX],@@p);
d1994 1
a1994 2
    $tabindex = $self->element_tab($tabindex);
    return $XHTML ? qq(<input type="submit" name=".defaults" $tabindex$value$other />)
d2026 3
a2028 3
    my($name,$checked,$value,$label,$override,$tabindex,@@other) = 
	rearrange([NAME,[CHECKED,SELECTED,ON],VALUE,LABEL,[OVERRIDE,FORCE],TABINDEX],@@p);

d2041 1
a2041 2
    my($other) = @@other ? "@@other " : '';
    $tabindex = $self->element_tab($tabindex);
d2043 1
a2043 1
    return $XHTML ? CGI::label(qq{<input type="checkbox" name="$name" value="$value" $tabindex$checked$other/>$the_label})
d2049 71
d2184 2
a2185 2
    my @@rowheaders = $rowheaders ? @@$rowheaders : ();
    my @@colheaders = $colheaders ? @@$colheaders : ();
d2194 1
a2194 1

d2198 3
a2200 3
    unshift(@@colheaders,'') if @@colheaders && @@rowheaders;
    $result .= "<tr>" if @@colheaders;
    foreach (@@colheaders) {
d2205 1
a2205 1
	$result .= "<th>$rowheaders[$row]</th>" if @@rowheaders;
a2237 3
   $self->_box_group('radio',@@p);
}
END_OF_FUNC
d2239 6
a2244 41
#### Method: checkbox_group
# Create a list of logically-linked checkboxes.
# Parameters:
#   $name -> Common name for all the check boxes
#   $values -> A pointer to a regular array containing the
#             values for each checkbox in the group.
#   $defaults -> (optional)
#             1. If a pointer to a regular array of checkbox values,
#             then this will be used to decide which
#             checkboxes to turn on by default.
#             2. If a scalar, will be assumed to hold the
#             value of a single checkbox in the group to turn on. 
#   $linebreak -> (optional) Set to true to place linebreaks
#             between the buttons.
#   $labels -> (optional)
#             A pointer to an associative array of labels to print next to each checkbox
#             in the form $label{'value'}="Long explanatory label".
#             Otherwise the provided values are used as the labels.
# Returns:
#   An ARRAY containing a series of <input type="checkbox"> fields
####

'checkbox_group' => <<'END_OF_FUNC',
sub checkbox_group {
    my($self,@@p) = self_or_default(@@_);
   $self->_box_group('checkbox',@@p);
}
END_OF_FUNC

'_box_group' => <<'END_OF_FUNC',
sub _box_group {
    my $self     = shift;
    my $box_type = shift;

    my($name,$values,$defaults,$linebreak,$labels,$attributes,
       $rows,$columns,$rowheaders,$colheaders,
       $override,$nolabels,$tabindex,@@other) =
       rearrange([      NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LINEBREAK,LABELS,ATTRIBUTES,
		        ROWS,[COLUMNS,COLS],ROWHEADERS,COLHEADERS,
			[OVERRIDE,FORCE],NOLABELS,TABINDEX
                 ],@@_);
d2247 5
a2251 1

a2253 1
    my %checked = $self->previous_or_default($name,$defaults,$override);
d2256 1
a2256 2
    $checked{$values[0]}++ if $box_type eq 'radio' && !%checked;

d2259 1
a2259 14
    my %tabs = ();
    if ($TABINDEX && $tabindex) {
      if (!ref $tabindex) {
          $self->element_tab($tabindex);
      } elsif (ref $tabindex eq 'ARRAY') {
          %tabs = map {$_=>$self->element_tab} @@$tabindex;
      } elsif (ref $tabindex eq 'HASH') {
          %tabs = %$tabindex;
      }
    }
    %tabs = map {$_=>$self->element_tab} @@values unless %tabs;

    my $other = @@other ? "@@other " : '';
    my $radio_checked;
d2261 1
a2261 2
        my $checkit = $self->_checked($box_type eq 'radio' ? ($checked{$_} && !$radio_checked++)
                                                           : $checked{$_});
d2275 1
a2275 2
        my $attribs = $self->_set_attributes($_, $attributes);
        my $tab     = $tabs{$_};
d2277 2
a2278 7
        if ($XHTML) {
           push @@elements,
              CGI::label(
                   qq(<input type="$box_type" name="$name" value="$_" $checkit$other$tab$attribs/>$label)).${break};
        } else {
           push(@@elements,qq/<input type="$box_type" name="$name" value="$_"$checkit$other$tab$attribs>${label}${break}/);
        }
d2281 1
a2281 1
    return wantarray ? @@elements : "@@elements"
d2306 1
a2306 1
    my($name,$values,$default,$labels,$attributes,$override,$tabindex,@@other) =
d2308 1
a2308 1
       ATTRIBUTES,[OVERRIDE,FORCE],TABINDEX],@@p);
d2321 2
a2322 2
    $tabindex = $self->element_tab($tabindex);
    $result = qq/<select name="$name" $tabindex$other>\n/;
d2338 1
a2338 1
            $result .= "<option $selectit${attribs}value=\"$value\">$label</option>\n";
d2431 1
a2431 1
    my($name,$values,$defaults,$size,$multiple,$labels,$attributes,$override,$tabindex,@@other)
d2433 1
a2433 1
          SIZE,MULTIPLE,LABELS,ATTRIBUTES,[OVERRIDE,FORCE],TABINDEX],@@p);
d2446 1
a2446 2
    $tabindex = $self->element_tab($tabindex);
    $result = qq/<select name="$name" $tabindex$has_size$is_multiple$other>\n/;
d2454 1
a2454 1
        $result .= "<option ${selectit}${attribs}value=\"$value\">$label</option>\n";
d2561 3
a2563 3
    my ($relative,$absolute,$full,$path_info,$query,$base,$rewrite) = 
	rearrange(['RELATIVE','ABSOLUTE','FULL',['PATH','PATH_INFO'],['QUERY','QUERY_STRING'],'BASE','REWRITE'],@@p);
    my $url  = '';
a2564 1
    $rewrite++   unless defined $rewrite;
d2566 14
a2579 11
    my $path        =  $self->path_info;
    my $script_name =  $self->script_name;
    my $request_uri = $self->request_uri || '';
    my $query_str   =  $self->query_string;

    my $rewrite_in_use = $request_uri && $request_uri !~ /^$script_name/;
    undef $path if $rewrite_in_use && $rewrite;  # path not valid when rewriting active

    my $uri         =  $rewrite && $request_uri ? $request_uri : $script_name;
    $uri            =~ s/\?.*$//;                                 # remove query string
    $uri            =~ s/$path$//      if defined $path;          # remove path
d2595 1
a2595 1
	$url .= $uri;
d2599 1
a2599 1
	$url = $uri;
d2602 3
a2604 2
    $url .= $path         if $path_info and defined $path;
    $url .= "?$query_str" if $query     and $query_str ne '';
d2698 3
a2700 2
        my (undef,$path_info) = $self->_name_and_path_from_env;
	$self->{'.path_info'} = $path_info || '';
a2708 31
# WE USE THIS TO COMPENSATE FOR A BUG IN APACHE 2 PRESENT AT LEAST UP THROUGH 2.0.54
'_name_and_path_from_env' => <<'END_OF_FUNC',
sub _name_and_path_from_env {
   my $self = shift;
   my $raw_script_name = $ENV{SCRIPT_NAME} || '';
   my $raw_path_info   = $ENV{PATH_INFO}   || '';
   my $uri             = $ENV{REQUEST_URI} || '';

   if ($raw_script_name =~ m/$raw_path_info$/) {
     $raw_script_name =~ s/$raw_path_info$//;
   }

   my @@uri_double_slashes  = $uri =~ m^(/{2,}?)^g;
   my @@path_double_slashes = "$raw_script_name $raw_path_info" =~ m^(/{2,}?)^g;

   my $apache_bug      = @@uri_double_slashes != @@path_double_slashes;
   return ($raw_script_name,$raw_path_info) unless $apache_bug;

   my $path_info_search = $raw_path_info;
   # these characters will not (necessarily) be escaped
   $path_info_search    =~ s/([^a-zA-Z0-9$()':_.,+*\/;?=&-])/uc sprintf("%%%02x",ord($1))/eg;
   $path_info_search    = quotemeta($path_info_search);
   $path_info_search    =~ s!/!/+!g;
   if ($uri =~ m/^(.+)($path_info_search)/) {
       return ($1,$2);
   } else {
       return ($raw_script_name,$raw_path_info);
   }
}
END_OF_FUNC

a2738 10
#### Method: request_uri
# Return the literal request URI
####
'request_uri' => <<'END_OF_FUNC',
sub request_uri {
    return $ENV{'REQUEST_URI'};
}
END_OF_FUNC


d2894 4
a2897 8
    my ($self,@@p) = self_or_default(@@_);
    if (@@p) {
        $self->{'.script_name'} = shift;
    } elsif (!exists $self->{'.script_name'}) {
        my ($script_name,$path_info) = $self->_name_and_path_from_env();
        $self->{'.script_name'} = $script_name;
    }
    return $self->{'.script_name'};
a2938 1
    my $protocol = $self->protocol;
d2940 1
a2940 1
        return ($vh =~ /:(\d+)$/)[0] || ($protocol eq 'https' ? 443 : 80);
d3251 1
a3251 1
          my $seqno = unpack("%16C*",join('',localtime,grep {defined $_} values %ENV));
d3296 1
a3296 5
	  # Use the typeglob as the key, as this is guaranteed to be
	  # unique for each filehandle.  Don't use the file descriptor as
	  # this will be re-used for each filehandle if the
	  # close_upload_files feature is used.
	  $self->{'.tmpfiles'}->{$$filehandle}= {
d3319 2
a3320 2
    return $self->{'.tmpfiles'}->{$$filename}->{name} ?
	$self->{'.tmpfiles'}->{$$filename}->{name}->as_string
d3328 1
a3328 1
    return $self->{'.tmpfiles'}->{$$filename}->{info};
a3388 5
sub DESTROY {
    my $self = shift;
    close $self;
}

d3435 7
d3475 1
a3475 1

a3504 1
		CHUNKED=>!defined $length,
d3615 2
a3617 2
    # protect against malformed multipart POST operations
    die "Malformed multipart POST\n" unless $self->{CHUNKED} || ($start >= 0 || $self->{LENGTH} > 0);
d3663 1
a3663 1
    return unless $self->{CHUNKED} || $self->{LENGTH};
d3668 1
a3668 1
    $bytesToRead = $self->{LENGTH} if !$self->{CHUNKED} && $self->{LENGTH} < $bytesToRead;
d3682 1
a3682 1
    if ($bytesRead <= 0) {
d3689 1
a3689 1
    $self->{LENGTH} -= $bytesRead if !$self->{CHUNKED} && $bytesRead;
d3713 1
d3717 1
a3717 1
  unless (defined $TMPDIRECTORY) {
d3837 3
a3839 6
       my $name      = param('name');
       my $keywords  = join ', ',param('words');
       my $color     = param('color');
       print "Your name is",em(escapeHTML($name)),p,
	     "The keywords are: ",em(escapeHTML($keywords)),p,
	     "Your favorite color is ",em(escapeHTML($color)),
a4197 15
=head2 HANDLING NON-URLENCODED ARGUMENTS


If POSTed data is not of type application/x-www-form-urlencoded or
multipart/form-data, then the POSTed data will not be processed, but
instead be returned as-is in a parameter named POSTDATA.  To retrieve
it, use code like this:

   my $data = $query->param('POSTDATA');

(If you don't know what the preceding means, don't worry about it.  It
only affects people trying to use CGI for XML processing and other
specialized tasks.)


d4243 1
a4243 1
    $query->save(\*FILEHANDLE)
d4273 1
a4273 1
       $q->save(\*OUT);
d4280 1
a4280 1
       my $q = new CGI(\*IN);
d4496 5
a4500 16
By default the CGI module implements a state-preserving behavior
called "sticky" fields.  The way this works is that if you are
regenerating a form, the methods that generate the form field values
will interrogate param() to see if similarly-named parameters are
present in the query string. If they find a like-named parameter, they
will use it to set their default values.

Sometimes this isn't what you want.  The B<-nosticky> pragma prevents
this behavior.  You can also selectively change the sticky behavior in
each element that you generate.

=item -tabindex

Automatically add tab index attributes to each form field. With this
option turned off, you can still add tab indexes manually by passing a
-tabindex option to each field-generating method.
d4671 1
a4671 1
	print header;
d4675 1
a4675 1
	print header('image/gif');
d4679 1
a4679 1
	print header('text/html','204 No response');
d4683 1
a4683 1
	print header(-type=>'image/gif',
d4705 1
a4705 1
    print header(-Content_length=>3002);
d4757 1
a4757 1
   print redirect('http://somewhere.else/in/movie/land');
d4772 1
a4772 1
    print redirect(-uri=>'http://somewhere.else/in/movie/land',
d4795 1
a4795 1
   print start_html(-title=>'Secrets of the Pyramids',
a4860 7
The B<-declare_xml> argument, when used in conjunction with XHTML,
will put a <?xml> declaration at the top of the HTML header. The sole
purpose of this declaration is to declare the character set
encoding. In the absence of -declare_xml, the output HTML will contain
a <meta> tag that specifies the encoding, allowing the HTML to pass
most validators.  The default for -declare_xml is false.

d4904 1
a4904 1
      print header;
d4921 1
a4921 1
      print start_html(-title=>'The Riddle of the Sphinx',
d5005 1
a5005 1
	print end_html
d5011 1
a5011 1
    $myself = self_url;
d5020 1
a5020 1
     $myself = self_url;
d5030 1
a5030 1
    $the_string = query_string;
d5034 7
a5040 7
    $full_url      = url();
    $full_url      = url(-full=>1);  #alternative syntax
    $relative_url  = url(-relative=>1);
    $absolute_url  = url(-absolute=>1);
    $url_with_path = url(-path_info=>1);
    $url_with_path_and_query = url(-path_info=>1,-query=>1);
    $netloc        = url(-base => 1);
a5085 10
=item B<-rewrite>

If Apache's mod_rewrite is turned on, then the script name and path
info probably won't match the request that the user sent. Set
-rewrite=>1 (default) to return URLs that match what the user sent
(the original request URI). Set -rewrite->0 to return URLs that match
the URL after mod_rewrite's rules have run. Because the additional
path information only makes sense in the context of the rewritten URL,
-rewrite is set to false when you request path info in the URL.

d5090 1
a5090 1
   $color = url_param('color');
d5118 1
d5349 1
a5349 1
   print textfield(-name=>'field_name',
d5363 1
a5363 1
   autoEscape(undef);
d5372 1
a5372 1
    printf("%s\n",end_form())
d5382 1
a5382 1
   print isindex(-action=>$action);
d5386 1
a5386 1
   print isindex($action);
d5394 3
a5396 3
    print start_form(-method=>$method,
		    -action=>$action,
		    -enctype=>$encoding);
d5398 1
a5398 1
    print endform;
d5402 1
a5402 1
    print start_form($method,$action,$encoding);
d5404 1
a5404 1
    print endform;
a5444 3
If XHTML is activated (the default), then forms will be automatically
created using this type of encoding.

a5465 50
=head2 FORM ELEMENTS

After starting a form, you will typically create one or more
textfields, popup menus, radio groups and other form elements.  Each
of these elements takes a standard set of named arguments.  Some
elements also have optional arguments.  The standard arguments are as
follows:

=over 4

=item B<-name>

The name of the field. After submission this name can be used to
retrieve the field's value using the param() method.

=item B<-value>, B<-values>

The initial value of the field which will be returned to the script
after form submission.  Some form elements, such as text fields, take
a single scalar -value argument. Others, such as popup menus, take a
reference to an array of values. The two arguments are synonyms.

=item B<-tabindex>

A numeric value that sets the order in which the form element receives
focus when the user presses the tab key. Elements with lower values
receive focus first.

=item B<-id>

A string identifier that can be used to identify this element to
JavaScript and DHTML.

=item B<-override>

A boolean, which, if true, forces the element to take on the value
specified by B<-value>, overriding the sticky behavior described
earlier for the B<-no_sticky> pragma.

=item B<-onChange>, B<-onFocus>, B<-onBlur>, B<-onMouseOver>, B<-onMouseOut>, B<-onSelect>

These are used to assign JavaScript event handlers. See the
JavaScripting section for more details.

=back

Other common arguments are described in the next section. In addition
to these, all attributes described in the HTML specifications are
supported.

d5468 4
a5471 4
    print textfield(-name=>'field_name',
		    -value=>'starting value',
		    -size=>50,
		    -maxlength=>80);
d5474 1
a5474 1
    print textfield('field_name','starting value',50,80);
d5476 1
a5476 1
textfield() will return a text input field. 
d5484 1
a5484 1
The first parameter is the required name for the field (-name). 
d5489 1
a5489 1
contents (-value, formerly known as -default).
d5508 1
a5508 1
       $value = param('foo');
d5513 20
a5532 1
       param('foo',"I'm taking over this value!");
d5536 1
a5536 1
   print textarea(-name=>'foo',
d5543 1
a5543 1
   print textarea('foo','starting value',10,50);
d5550 4
d5556 1
a5556 1
   print password_field(-name=>'secret',
d5562 1
a5562 1
   print password_field('secret','starting value',50,80);
d5567 4
d5573 1
a5573 1
    print filefield(-name=>'uploaded_file',
d5579 1
a5579 1
    print filefield('uploaded_file','starting value',50,80);
d5622 1
a5622 1
       $filename = param('uploaded_file');
d5657 1
a5657 1
     $fh = upload('uploaded_file');
d5675 2
a5676 2
       $filename = param('uploaded_file');
       $type = uploadInfo($filename)->{'Content-Type'};
d5694 3
a5696 3
   $file = upload('uploaded_file');
   if (!$file && cgi_error) {
      print header(-status=>cgi_error);
d5709 2
a5710 1
 $q = CGI->new(\&hook,$data);
d5738 1
a5738 1
   print popup_menu('menu_name',
d5748 1
a5748 1
   print popup_menu('menu_name',
d5754 1
a5754 1
   print popup_menu(-name=>'menu_name',
d5803 6
a5808 1
      $popup_menu_value = param('menu_name');
d5814 1
a5814 1
  print popup_menu(-name=>'menu_name',
d5816 3
a5818 3
                            optgroup(-name=>'optgroup_name',
                                             -values => ['moe','catch'],
                                             -attributes=>{'catch'=>{'class'=>'red'}})],
d5825 1
a5825 1
  print popup_menu('menu_name',
d5827 2
a5828 2
                   optgroup('optgroup_name', ['moe', 'catch'],
                                   {'catch'=>{'class'=>'red'}})],'meenie',
d5831 1
a5831 1
optgroup() creates an option group within a popup menu.
d5887 1
a5887 1
   print scrolling_list('list_name',
d5892 1
a5892 1
   print scrolling_list('list_name',
d5899 1
a5899 1
   print scrolling_list(-name=>'list_name',
d5956 1
a5956 1
      @@selected = param('list_name');
d5960 5
d5967 1
a5967 1
   print checkbox_group(-name=>'group_name',
d5974 1
a5974 1
   print checkbox_group('group_name',
d5981 1
a5981 1
   print checkbox_group(-name=>'group_name',
d6014 15
a6028 1
=back
d6030 1
d6032 14
a6045 33
The optional b<-labels> argument is a pointer to an associative array
relating the checkbox values to the user-visible labels that will be
printed next to them.  If not provided, the values will be used as the
default.


Modern browsers can take advantage of the optional parameters
B<-rows>, and B<-columns>.  These parameters cause checkbox_group() to
return an HTML3 compatible table containing the checkbox group
formatted with the specified number of rows and columns.  You can
provide just the -columns parameter if you wish; checkbox_group will
calculate the correct number of rows for you.


The optional B<-attributes> argument is provided to assign any of the
common HTML attributes to an individual menu item. It's a pointer to
an associative array relating menu values to another associative array
with the attribute's name as the key and the attribute's value as the
value.

The optional B<-tabindex> argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:

  -tabindex => 100    #  this group starts at index 100 and counts up
  -tabindex => ['moe','minie','eenie','meenie']  # tab in this order
  -tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order
d6051 1
a6051 1
      @@turned_on = param('group_name');
d6057 1
a6057 1
    @@h = checkbox_group(-name=>'group_name',-values=>\@@values);
d6060 6
d6068 1
a6068 1
    print checkbox(-name=>'checkbox_name',
d6075 1
a6075 1
    print checkbox('checkbox_name','checked','ON','CLICK ME');
d6111 4
a6114 1
    $turned_on = param('checkbox_name');
d6118 1
a6118 1
   print radio_group(-name=>'group_name',
d6127 1
a6127 1
   print radio_group('group_name',['eenie','meenie','minie'],
d6133 1
a6133 1
   print radio_group(-name=>'group_name',
d6175 1
a6175 1
=back
d6177 8
d6186 7
a6192 6
All modern browsers can take advantage of the optional parameters
B<-rows>, and B<-columns>.  These parameters cause radio_group() to
return an HTML3 compatible table containing the radio group formatted
with the specified number of rows and columns.  You can provide just
the -columns parameter if you wish; radio_group will calculate the
correct number of rows for you.
d6201 1
a6201 20
The optional B<-tabindex> argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:

  -tabindex => 100    #  this group starts at index 100 and counts up
  -tabindex => ['moe','minie','eenie','meenie']  # tab in this order
  -tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order


The optional B<-attributes> argument is provided to assign any of the
common HTML attributes to an individual menu item. It's a pointer to
an associative array relating menu values to another associative array
with the attribute's name as the key and the attribute's value as the
value.
d6206 1
a6206 1
      $which_radio_button = param('group_name');
d6212 1
a6212 1
    @@h = radio_group(-name=>'group_name',-values=>\@@values);
d6217 1
a6217 1
   print submit(-name=>'button_name',
d6222 1
a6222 1
   print submit('button_name','value');
d6254 4
a6257 1
     $which_one = param('button_name');
d6261 1
a6261 1
   print reset
d6272 1
a6272 1
   print defaults('button_label')
d6280 1
a6280 1
	print hidden(-name=>'hidden_name',
d6285 1
a6285 1
	print hidden('hidden_name','value1','value2'...);
d6310 1
a6310 1
     $hidden_value = param('hidden_name');
d6317 1
a6317 1
     param('hidden_name','new','values','here');
d6321 1
a6321 1
     print image_button(-name=>'button_name',
d6327 1
a6327 1
     print image_button('button_name','/source/URL','MIDDLE');
d6334 3
d6357 2
a6358 2
     $x = param('button_name.x');
     $y = param('button_name.y');
d6362 1
a6362 1
     print button(-name=>'button_name',
d6368 1
a6368 1
     print button('button_name',"do_something()");
d6434 1
a6434 1
    $cookie = cookie(-name=>'sessionID',
d6440 1
a6440 1
    print header(-cookie=>$cookie);
d6459 1
a6459 1
	$cookie=cookie(-name=>'family information',
d6489 1
a6489 1
	print header(-cookie=>$my_cookie);
d6493 1
a6493 1
	$cookie1 = cookie(-name=>'riddle_name',
d6495 1
a6495 1
	$cookie2 = cookie(-name=>'answers',
d6497 1
a6497 1
	print header(-cookie=>[$cookie1,$cookie2]);
d6504 2
a6505 2
	$riddle = cookie('riddle_name');
        %answers = cookie('answers');
d6517 1
a6517 1
   $c=cookie(-name=>'answers',-value=>[param('answers')]);
d6519 1
a6519 1
   param(-name=>'answers',-value=>[cookie('answers')]);
d6549 1
a6549 1
    print header(-target=>'ResultsWindow');
d6563 1
a6563 1
    print start_form(-target=>'ResultsWindow');
a6574 149
=head1 SUPPORT FOR JAVASCRIPT

Netscape versions 2.0 and higher incorporate an interpreted language
called JavaScript. Internet Explorer, 3.0 and higher, supports a
closely-related dialect called JScript. JavaScript isn't the same as
Java, and certainly isn't at all the same as Perl, which is a great
pity. JavaScript allows you to programatically change the contents of
fill-out forms, create new windows, and pop up dialog box from within
Netscape itself. From the point of view of CGI scripting, JavaScript
is quite useful for validating fill-out forms prior to submitting
them.

You'll need to know JavaScript in order to use it. There are many good
sources in bookstores and on the web.

The usual way to use JavaScript is to define a set of functions in a
<SCRIPT> block inside the HTML header and then to register event
handlers in the various elements of the page. Events include such
things as the mouse passing over a form element, a button being
clicked, the contents of a text field changing, or a form being
submitted. When an event occurs that involves an element that has
registered an event handler, its associated JavaScript code gets
called.

The elements that can register event handlers include the <BODY> of an
HTML document, hypertext links, all the various elements of a fill-out
form, and the form itself. There are a large number of events, and
each applies only to the elements for which it is relevant. Here is a
partial list:

=over 4

=item B<onLoad>

The browser is loading the current document. Valid in:

     + The HTML <BODY> section only.

=item B<onUnload>

The browser is closing the current page or frame. Valid for:

     + The HTML <BODY> section only.

=item B<onSubmit>

The user has pressed the submit button of a form. This event happens
just before the form is submitted, and your function can return a
value of false in order to abort the submission.  Valid for:

     + Forms only.

=item B<onClick>

The mouse has clicked on an item in a fill-out form. Valid for:

     + Buttons (including submit, reset, and image buttons)
     + Checkboxes
     + Radio buttons

=item B<onChange>

The user has changed the contents of a field. Valid for:

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=item B<onFocus>

The user has selected a field to work with. Valid for:

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=item B<onBlur>

The user has deselected a field (gone to work somewhere else).  Valid
for:

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=item B<onSelect>

The user has changed the part of a text field that is selected.  Valid
for:

     + Text fields
     + Text areas
     + Password fields
     + File fields

=item B<onMouseOver>

The mouse has moved over an element.

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=item B<onMouseOut>

The mouse has moved off an element.

     + Text fields
     + Text areas
     + Password fields
     + File fields
     + Popup Menus
     + Scrolling lists

=back

In order to register a JavaScript event handler with an HTML element,
just use the event name as a parameter when you call the corresponding
CGI method. For example, to have your validateAge() JavaScript code
executed every time the textfield named "age" changes, generate the
field like this: 

 print textfield(-name=>'age',-onChange=>"validateAge(this)");

This example assumes that you've already declared the validateAge()
function by incorporating it into a <SCRIPT> block. The CGI.pm
start_html() method provides a convenient way to create this section.

Similarly, you can create a form that checks itself over for
consistency and alerts the user if some essential value is missing by
creating it this way: 
  print startform(-onSubmit=>"validateMe(this)");

See the javascript.cgi script for a demonstration of how this all
works.


d6653 1
a6653 1
print start_html (-STYLE  =>  {-verbatim => '@@import
d6732 1
a6732 1
    print Dump
d6766 1
a6766 1
Accept('text/html'), it will return a floating point value
d6794 1
a6794 1
like user_agent(netscape);
d6800 1
a6800 1
path_info() returning "/additional/stuff".
d6895 3
a6897 3
   $requested_language = http('Accept-language');
   $requested_language = http('Accept_language');
   $requested_language = http('HTTP_ACCEPT_LANGUAGE');
d6958 1
a6958 1
      print header(-nph=>1);
d7138 1
a7138 1
    CGI::ReadParse();
d7151 1
a7151 1
    print textfield(-name=>'wow',
d7228 3
a7230 1
	use CGI ':standard';
d7232 2
a7233 2
	print header;
	print start_html("Example CGI.pm Form");
d7235 4
a7238 4
        print_prompt();
	do_work();
	print_tail();
	print end_html;
d7241 3
a7243 1
	   print start_form;
d7245 2
a7246 2
	   print textfield('name');
	   print checkbox('Not my real name');
d7249 1
a7249 1
	   print checkbox_group(
d7256 1
a7256 1
		radio_group(
d7262 1
a7262 1
	   print popup_menu(-name=>'Color',
d7266 1
a7266 1
	   print hidden('Reference','Monty Python and the Holy Grail');
d7269 1
a7269 1
	   print scrolling_list(
d7277 1
a7277 1
	   print textarea(-name=>'Comments',
d7281 4
a7284 4
	   print "<p>",reset;
	   print submit('Action','Shout');
	   print submit('Action','Scream');
	   print endform;
d7289 1
d7294 1
a7294 1
	   foreach $key (param) {
d7296 1
a7296 1
	      @@values = param($key);
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.234 2007/04/16 16:58:46 lstein Exp $';
$CGI::VERSION='3.29';
a42 1

a120 1
    undef %QUERY_TMPFILES;
a331 4

  # always use a tempfile
  $self->{'use_tempfile'} = 1;

a341 1
    $self->{'use_tempfile'} = shift @@initializer if (@@initializer > 0);
d395 1
a395 1
  my ($hook,$data,$use_tempfile) = @@_;
a397 1
  $self->{'use_tempfile'} = $use_tempfile if defined $use_tempfile;
d430 1
a430 1
	if (@@values or defined $value) {
d439 1
a439 10

    my $charset = $self->charset || '';
    my $utf8    = $charset eq 'utf-8';
    if ($utf8) {
      eval "require Encode; 1;" if $utf8 && !Encode->can('decode'); # bring in these functions
      return wantarray ? map {Encode::decode(utf8=>$_) } @@{$self->{$name}} 
                       : Encode::decode(utf8=>$self->{$name}->[0]);
    } else {
      return wantarray ? @@{$self->{$name}} : $self->{$name}->[0];
    }
a480 2
  my $is_xforms;

d491 6
a496 14
        for my $name (@@QUERY_PARAM) {
            my $val = $QUERY_PARAM{$name}; # always an arrayref;
            $self->param('-name'=>$name,'-value'=> $val);
            if (defined $val and ref $val eq 'ARRAY') {
                for my $fh (grep {defined(fileno($_))} @@$val) {
                   seek($fh,0,0); # reset the filehandle.  
                }

            }
        }
        $self->charset($QUERY_CHARSET);
        $self->{'.fieldnames'} = {%QUERY_FIELDNAMES};
        $self->{'.tmpfiles'}   = {%QUERY_TMPFILES};
        return;
d511 11
a521 4
	#discard the post, unread
	$self->cgi_error("413 Request entity too large");
	last METHOD;
      }
a534 41
      # Process XForms postings. We know that we have XForms in the
      # following cases:
      # method eq 'POST' && content-type eq 'application/xml'
      # method eq 'POST' && content-type =~ /multipart\/related.+start=/
      # There are more cases, actually, but for now, we don't support other
      # methods for XForm posts.
      # In a XForm POST, the QUERY_STRING is parsed normally.
      # If the content-type is 'application/xml', we just set the param
      # XForms:Model (referring to the xml syntax) param containing the
      # unparsed XML data.
      # In the case of multipart/related we set XForms:Model as above, but
      # the other parts are available as uploads with the Content-ID as the
      # the key.
      # See the URL below for XForms specs on this issue.
      # http://www.w3.org/TR/2006/REC-xforms-20060314/slice11.html#submit-options
      if ($meth eq 'POST' && defined($ENV{'CONTENT_TYPE'})) {
              if ($ENV{'CONTENT_TYPE'} eq 'application/xml') {
                      my($param) = 'XForms:Model';
                      my($value) = '';
                      $self->add_parameter($param);
                      $self->read_from_client(\$value,$content_length,0)
                        if $content_length > 0;
                      push (@@{$self->{$param}},$value);
                      $is_xforms = 1;
              } elsif ($ENV{'CONTENT_TYPE'} =~ /multipart\/related.+boundary=\"?([^\";,]+)\"?.+start=\"?\<?([^\"\>]+)\>?\"?/) {
                      my($boundary,$start) = ($1,$2);
                      my($param) = 'XForms:Model';
                      $self->add_parameter($param);
                      my($value) = $self->read_multipart_related($start,$boundary,$content_length,0);
                      push (@@{$self->{$param}},$value);
                      if ($MOD_PERL) {
                              $query_string = $self->r->args;
                      } else {
                              $query_string = $ENV{'QUERY_STRING'} if defined $ENV{'QUERY_STRING'};
                              $query_string ||= $ENV{'REDIRECT_QUERY_STRING'} if defined $ENV{'REDIRECT_QUERY_STRING'};
                      }
                      $is_xforms = 1;
              }
      }


d537 1
a537 1
      if (!$is_xforms && defined($initializer)) {
d548 15
d588 1
a588 1
      if ($is_xforms || $meth=~/^(GET|HEAD)$/) {
d624 1
a624 1
    if (!$is_xforms && $meth eq 'POST'
a712 1
    %QUERY_TMPFILES   = %{ $self->{'.tmpfiles'} || {} };
a1420 3

    $type ||= 'text/html' unless defined($type);

d1424 1
a1424 1
      $charset = $self->charset if $type =~ /^text\//;
a1425 1
   $charset ||= '';
d1435 2
a1436 5
    $type .= "; charset=$charset"
      if     $type ne ''
         and $type !~ /\bcharset\b/
         and defined $charset
         and $charset ne '';
d1502 1
a1502 1
    $status = '302 Found' unless defined $status;
d1549 1
a1549 1
    $encoding = lc($self->charset) unless defined $encoding;
a1638 1

a1639 2
    my $rel  = 'stylesheet';

d1648 2
a1649 2
       my($src,$code,$verbatim,$stype,$alternate,$foo,@@other) =
           rearrange([qw(SRC CODE VERBATIM TYPE ALTERNATE FOO)],
d1652 1
a1652 2
       my $type = defined $stype ? $stype : 'text/css';
       my $rel  = $alternate ? 'alternate stylesheet' : 'stylesheet';
d1659 2
a1660 2
           push(@@result,$XHTML ? qq(<link rel="$rel" type="$type" href="$src" $other/>)
                             : qq(<link rel="$rel" type="$type" href="$src"$other>)) if $src;
d1665 2
a1666 2
         push(@@result,$XHTML ? qq(<link rel="$rel" type="$type" href="$src" $other/>)
                             : qq(<link rel="$rel" type="$type" href="$src"$other>)
d1678 2
a1679 2
           push(@@result,$XHTML ? qq(<link rel="$rel" type="$type" href="$src" $other/>)
                               : qq(<link rel="$rel" type="$type" href="$src"$other>));
d1695 2
a1696 2
	    ($src,$code,$type) =
		rearrange(['SRC','CODE',['LANGUAGE','TYPE']],
d1699 6
a1704 4
            $type ||= 'text/javascript';
            unless ($type =~ m!\w+/\w+!) {
                $type =~ s/[\d.]+$//;
                $type = "text/$type";
d1707 1
a1707 1
	    ($src,$code,$type) = ('',$script, 'text/javascript');
d1725 1
d1785 1
a1785 1
       $action = $self->escapeHTML($self->request_uri || $self->self_url);
d1815 3
a1817 1
      return $self->startform(-enctype=>&MULTIPART,@@p);
d2279 1
a2279 1
       $override,$nolabels,$tabindex,$disabled,@@other) =
d2281 2
a2282 2
		        ROWS,[COLUMNS,COLS],[ROWHEADERS,ROWHEADER],[COLHEADERS,COLHEADER],
			[OVERRIDE,FORCE],NOLABELS,TABINDEX,DISABLED
d2284 1
a2285 1
    my($result,$checked,@@elements,@@values);
d2287 1
d2307 1
a2309 7

    # for disabling groups of radio/checkbox buttons
    my %disabled;
    foreach (@@{$disabled}) {
   	$disabled{$_}=1;
    }

a2310 5
    	 my $disable="";
	 if ($disabled{$_}) {
		$disable="disabled='1'";
	 }

a2324 1
            $label = "<span style=\"color:gray\">$label</span>" if $disabled{$_};
a2328 1

d2332 1
a2332 1
                   qq(<input type="$box_type" name="$name" value="$_" $checkit$other$tab$attribs$disable/>$label)).${break};
d2334 1
a2334 1
            push(@@elements,qq/<input type="$box_type" name="$name" value="$_"$checkit$other$tab$attribs$disable>${label}${break}/);
d2389 7
a2395 7
          my $attribs = $self->_set_attributes($_, $attributes);
	  my($selectit) = defined($selected) ? $self->_selected($selected eq $_) : '';
	  my($label) = $_;
	  $label = $labels->{$_} if defined($labels) && defined($labels->{$_});
	  my($value) = $self->escapeHTML($_);
	  $label=$self->escapeHTML($label,1);
          $result .= "<option${attribs} ${selectit}value=\"$value\">$label</option>\n";
d2580 1
a2580 1
    my($align) = $alignment ? " align=\L\"$alignment\"" : '';
d2627 1
a2627 1
    my $request_uri =  unescape($self->request_uri) || '';
d2635 1
a2635 1
    $uri            =~ s/\Q$path\E$//      if defined $path;      # remove path
d2640 1
a2640 2
	my $vh = http('x_forwarded_host') || http('host') || '';
        $vh =~ s/\:\d+$//;  # some clients add the port number (incorrectly). Get rid of it.
d2645 4
a2649 4
        my $port = $self->server_port;
	$url .= ":" . $port
	  unless (lc($protocol) eq 'http'  && $port == 80)
		|| (lc($protocol) eq 'https' && $port == 443);
d2653 1
a2653 1
	($url) = $uri =~ m!([^/]+)$!;
d2681 2
a2682 2
    my($name,$value,$path,$domain,$secure,$expires,$httponly) =
	rearrange([NAME,[VALUE,VALUES],PATH,DOMAIN,SECURE,EXPIRES,HTTPONLY],@@p);
a2709 1
    push(@@param,'-httponly'=>$httponly) if $httponly;
d2755 3
d2769 1
a2769 1
   my $uri             = unescape($self->request_uri) || '';
d2771 3
a2773 2
   my $protected    = quotemeta($raw_path_info);
   $raw_script_name =~ s/$protected$//;
d2781 4
a2784 1
   my $path_info_search = quotemeta($raw_path_info);
d2991 1
a2991 1
        $self->{'.script_name'} = shift @@p;
d3311 1
a3311 1
	my($param)= $header{'Content-Disposition'}=~/ name="([^"]*)"/;
d3315 1
a3315 1
	my($filename) = $header{'Content-Disposition'}=~/ filename="([^"]*)"/;
d3381 1
a3381 103
              print $filehandle $data if ($self->{'use_tempfile'});
          }

	  # back up to beginning of file
	  seek($filehandle,0,0);

      ## Close the filehandle if requested this allows a multipart MIME
      ## upload to contain many files, and we won't die due to too many
      ## open file handles. The user can access the files using the hash
      ## below.
      close $filehandle if $CLOSE_UPLOAD_FILES;
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode;

	  # Save some information about the uploaded file where we can get
	  # at it later.
	  # Use the typeglob as the key, as this is guaranteed to be
	  # unique for each filehandle.  Don't use the file descriptor as
	  # this will be re-used for each filehandle if the
	  # close_upload_files feature is used.
	  $self->{'.tmpfiles'}->{$$filehandle}= {
              hndl => $filehandle,
	      name => $tmpfile,
	      info => {%header},
	  };
	  push(@@{$self->{$param}},$filehandle);
      }
    }
}
END_OF_FUNC

#####
# subroutine: read_multipart_related
#
# Read multipart/related data and store it into our parameters.  The
# first parameter sets the start of the data. The part identified by
# this Content-ID will not be stored as a file upload, but will be
# returned by this method.  All other parts will be available as file
# uploads accessible by their Content-ID
#####
'read_multipart_related' => <<'END_OF_FUNC',
sub read_multipart_related {
    my($self,$start,$boundary,$length) = @@_;
    my($buffer) = $self->new_MultipartBuffer($boundary,$length);
    return unless $buffer;
    my(%header,$body);
    my $filenumber = 0;
    my $returnvalue;
    while (!$buffer->eof) {
	%header = $buffer->readHeader;

	unless (%header) {
	    $self->cgi_error("400 Bad request (malformed multipart POST)");
	    return;
	}

	my($param) = $header{'Content-ID'}=~/\<([^\>]*)\>/;
        $param .= $TAINTED;

	# If this is the start part, then just read the data and assign it
	# to our return variable.
	if ( $param eq $start ) {
	    $returnvalue = $buffer->readBody;
            $returnvalue .= $TAINTED;
	    next;
	}

	# add this parameter to our list
	$self->add_parameter($param);

	my ($tmpfile,$tmp,$filehandle);
      UPLOADS: {
	  # If we get here, then we are dealing with a potentially large
	  # uploaded form.  Save the data to a temporary file, then open
	  # the file for reading.

	  # skip the file if uploads disabled
	  if ($DISABLE_UPLOADS) {
	      while (defined($data = $buffer->read)) { }
	      last UPLOADS;
	  }

	  # choose a relatively unpredictable tmpfile sequence number
          my $seqno = unpack("%16C*",join('',localtime,grep {defined $_} values %ENV));
          for (my $cnt=10;$cnt>0;$cnt--) {
	    next unless $tmpfile = new CGITempFile($seqno);
	    $tmp = $tmpfile->as_string;
	    last if defined($filehandle = Fh->new($param,$tmp,$PRIVATE_TEMPFILES));
            $seqno += int rand(100);
          }
          die "CGI open of tmpfile: $!\n" unless defined $filehandle;
	  $CGI::DefaultClass->binmode($filehandle) if $CGI::needs_binmode 
                     && defined fileno($filehandle);

	  my ($data);
	  local($\) = '';
          my $totalbytes;
          while (defined($data = $buffer->read)) {
              if (defined $self->{'.upload_hook'})
               {
                  $totalbytes += length($data);
                   &{$self->{'.upload_hook'}}($param ,$data, $totalbytes, $self->{'.upload_data'});
              }
              print $filehandle $data if ($self->{'use_tempfile'});
a3407 1
    return $returnvalue;
a3410 1

d3414 1
a3414 1
    my @@param = grep {ref($_) && defined(fileno($_))} $self->param($param_name);
d4132 1
a4132 4
it into a perl5 object called $query. 

Any filehandles from file uploads will have their position reset to 
the beginning of the file. 
d4593 1
a4593 1
those destined to be crunched by Malcolm Beattie's Perl compiler.  Use
d5066 6
a5071 6
The <script> tag, has several attributes including "type" and src.
The latter is particularly interesting, as it allows you to keep the
JavaScript code in a file or CGI script rather than cluttering up each
page with the source.  To use these attributes pass a HASH reference
in the B<-script> parameter containing one or more of -type, -src, or
-code:
d5074 1
a5074 1
			 -script=>{-type=>'JAVASCRIPT',
d5079 1
a5079 1
	       -script=>{-type=>'PERLSCRIPT',
d5087 1
a5087 1
of JavaScript.  Example:
d5091 1
a5091 1
                                    { -type => 'text/javascript',
d5094 1
a5094 1
                                    { -type => 'text/javascript',
d5097 1
a5097 1
                                    { -type => 'text/jscript',
d5100 1
a5100 1
                                    { -type => 'text/ecmascript',
d5106 7
a5112 2
The option "-language" is a synonym for -type, and is supported for
backwad compatibility.
a5840 6
For robust code, consider reseting the file handle position to beginning of the
file. Inside of larger frameworks, other code may have already used the query
object and changed the filehandle postion:

  seek($fh,0,0); # reset postion to beginning of file.

d5882 1
a5882 1
 $q = CGI->new(\&hook [,$data [,$use_tempfile]]);
a5889 9
The $data field is optional; it lets you pass configuration
information (e.g. a database handle) to your hook callback.

The $use_tempfile field is a flag that lets you turn on and off
CGI.pm's use of a temporary disk-based file during file upload. If you
set this to a FALSE value (default true) then param('uploaded_file')
will no longer work, and the only way to get at the uploaded data is
via the hook you provide.

d5893 1
a5893 1
  CGI::upload_hook(\&hook [,$data [,$use_tempfile]]);
d6035 1
a6035 1
indicates to suppress the val attribute in each option element within
a6132 1
                                -disabled => ['moe'],
d6185 6
a6190 5
The optional parameters B<-rows>, and B<-columns> cause
checkbox_group() to return an HTML3 compatible table containing the
checkbox group formatted with the specified number of rows and
columns.  You can provide just the -columns parameter if you wish;
checkbox_group will calculate the correct number of rows for you.
a6191 2
The option b<-disabled> takes an array of checkbox values and disables
them by greying them out (this may not be supported by all browsers).
d6343 1
a6343 1
can use the B<-rowheaders> and B<-colheaders> parameters.  Both
a6649 1
        use CGI ':standard';
d6661 1
a6661 2
without the B<-value> parameter. This example uses the object-oriented
form:
d6665 2
a6666 2
	$riddle = $query->cookie('riddle_name');
        %answers = $query->cookie('answers');
a6681 5
If you call cookie() without any parameters, it will return a list of
the names of all cookies passed to your script:

  @@cookies = cookie();

d6704 1
a6704 1
  http://wp.netscape.com/assist/net_sites/frames.html
d6742 1
a6742 1
pity. JavaScript allows you to programmatically change the contents of
d6963 4
a6966 2
print start_html (-style  =>  {-verbatim => '@@import url("/server-common/css/'.$cssFile.'");',
                  -src    =>  '/server-common/css/core.css'});
a6994 8

To create primary and  "alternate" stylesheet, use the B<-alternate> option:

 start_html(-style=>{-src=>[
                           {-src=>'/styles/print.css'},
			   {-src=>'/styles/alt.css',-alternate=>1}
                           ]
		    });
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d21 2
a22 2
$CGI::revision = '$Id: CGI.pm,v 1.263 2009/02/11 16:56:37 lstein Exp $';
$CGI::VERSION='3.43';
d27 1
a27 1
use CGI::Util qw(rearrange rearrange_header make_attributes unescape escape expires ebcdic2ascii ascii2ebcdic);
d40 1
a40 6
$MOD_PERL            = 0; # no mod_perl by default

#global settings
$POST_MAX            = -1; # no limit to uploaded files
$DISABLE_UPLOADS     = 0;

d94 7
a113 3
    # return everything as utf-8
    $PARAM_UTF8      = 0;

d229 1
a229 1
		':html3'=>[qw/div table caption th td TR Tr sup Sub strike applet Param nobr
d296 1
a296 1
    for $sym (keys %EXPORT) {
d299 1
a299 1
	for $pck (@@packages) {
d319 1
a319 1
    for (@@{$EXPORT_TAGS{$tag}}) {
a354 1
      $self->_setup_symbols(@@SAVED_SYMBOLS) if @@SAVED_SYMBOLS;
a362 1
      $self->_setup_symbols(@@SAVED_SYMBOLS) if @@SAVED_SYMBOLS;
d381 1
a381 1
    for my $href (values %{$self->{'.tmpfiles'}}) {
d433 1
a433 1
	    for ($value,@@other) {
d440 1
a440 1
	    $self->{param}{$name}=[@@values];
d446 1
a446 1
    return unless defined($name) && $self->{param}{$name};
d448 8
a455 5
    my @@result = @@{$self->{param}{$name}};

    if ($PARAM_UTF8) {
      eval "require Encode; 1;" unless Encode->can('decode'); # bring in these functions
      @@result = map {ref $_ ? $_ : Encode::decode(utf8=>$_) } @@result;
a456 2

    return wantarray ?  @@result : $result[0];
d489 1
a489 1
# to a hash in which parameter names are keys
d577 1
a577 1
                      push (@@{$self->{param}{$param}},$value);
d584 1
a584 1
                      push (@@{$self->{param}{$param}},$value);
d604 1
a604 1
	      for (keys %$initializer) {
d644 1
a644 1
      if ($meth eq 'POST' || $meth eq 'PUT') {
d670 1
a670 1
    if (!$is_xforms && ($meth eq 'POST' || $meth eq 'PUT')
d674 1
a674 1
        my($param) = $meth . 'DATA' ;
d676 1
a676 1
      push (@@{$self->{param}{$param}},$query_string);
d688 1
a688 1
	    $self->{param}{'keywords'} = [$self->parse_keywordlist($query_string)];
d698 1
a698 1
    # hash containing our defined fieldnames
d700 1
a700 1
    for ($self->param('.cgifields')) {
d753 1
a753 1
    for (@@QUERY_PARAM) {
d755 1
a755 1
      $QUERY_PARAM{$_}=$self->{param}{$_};
d766 1
a766 1
    for (@@pairs) {
d774 1
a774 1
	push (@@{$self->{param}{$param}},$value);
d782 1
a782 1
	unless defined($self->{param}{$param});
d900 1
a900 1
    for (@@_) {
a906 1
	$PARAM_UTF8++,           next if /^[:-]utf8$/;
d928 1
a928 1
	for (&expand_tags($_)) {
d1006 1
a1006 1
    for my $name (@@to_delete)
d1008 1
a1008 1
        CORE::delete $self->{param}{$name};
d1028 1
a1028 1
	for (keys %{"${namespace}::"}) {
d1036 1
a1036 1
    for $param ($self->param) {
d1057 2
a1058 2
    $self->{param}{'keywords'}=[@@values] if @@values;
    my(@@result) = defined($self->{param}{'keywords'}) ? @@{$self->{param}{'keywords'}} : ();
d1176 1
a1176 1
    exists $_[0]->{param}{$_[1]};
d1203 1
a1203 1
	push(@@{$self->{param}{$name}},@@values);
d1270 1
a1270 1
	    for (@@pairs) {
d1298 1
a1298 1
    for $param ($self->param) {
d1302 1
a1302 1
	for $value ($self->param($param)) {
d1335 1
a1335 1
    for $param ($self->param) {
d1338 1
a1338 1
	for $value ($self->param($param)) {
d1342 1
a1342 1
    for (keys %{$self->{'.fieldnames'}}) {
d1381 1
a1381 1
    my($boundary,@@other) = rearrange_header([BOUNDARY],@@p);
d1411 1
a1411 1
    for (@@other) {
d1480 1
a1480 1
    for (@@other) {
d1506 1
a1506 1
	for (@@cookie) {
d1522 1
a1522 1
    if (($MOD_PERL >= 1) && !$nph) {
d1559 1
a1559 1
    for (@@other) { tr/\"//d; push(@@o,split("=",$_,2)); }
d1662 1
a1662 1
	for (keys %$meta) { push(@@result,$XHTML ? qq(<meta name="$_" content="$meta->{$_}" />) 
d1666 1
a1666 11
    my $meta_bits_set = 0;
    if( $head ) {
        if( ref $head ) {
            push @@result, @@$head;
            $meta_bits_set = 1 if grep { /http-equiv=["']Content-Type/i }@@$head;
        }
        else {
            push @@result, $head;
            $meta_bits_set = 1 if $head =~ /http-equiv=["']Content-Type/i;
        }
    }
d1671 1
a1671 1
    push(@@result,$meta_bits)              if defined $meta_bits and !$meta_bits_set;
a1701 1
    my $other = '';
d1711 1
a1711 1
       $other = "@@other" if @@other;
d1715 1
a1715 1
           for $src (@@$src)
d1729 1
a1729 1
           push(@@result, "<style type=\"text/css\">\n$_\n</style>") for @@v;
d1732 1
a1732 1
      push(@@result,style({'type'=>$type},"$cdata_start\n$_\n$cdata_end")) for @@c;
d1750 1
a1750 1
    for $script (@@scripts) {
d1834 1
a1834 1
    $method  = $self->escapeHTML(lc($method || 'post'));
d2150 2
a2151 3
    my($name,$checked,$value,$label,$labelattributes,$override,$tabindex,@@other) =
       rearrange([NAME,[CHECKED,SELECTED,ON],VALUE,LABEL,LABELATTRIBUTES,
                   [OVERRIDE,FORCE],TABINDEX],@@p);
d2168 1
a2168 2
    return $XHTML ? CGI::label($labelattributes,
                    qq{<input type="checkbox" name="$name" value="$value" $tabindex$checked$other/>$the_label})
d2195 3
a2197 5
         # Handle bug in some browsers with Latin charsets
         if ($self->{'.charset'} &&
             (uc($self->{'.charset'}) eq 'ISO-8859-1' ||
              uc($self->{'.charset'}) eq 'WINDOWS-1252'))
         {
d2254 1
a2254 1
    for (@@colheaders) {
d2283 1
a2283 1
#             A pointer to a hash of labels to print next to each checkbox
d2311 1
a2311 1
#             A pointer to a hash of labels to print next to each checkbox
d2330 2
a2331 2
    my($name,$values,$defaults,$linebreak,$labels,$labelattributes,
       $attributes,$rows,$columns,$rowheaders,$colheaders,
d2333 4
a2336 5
        rearrange([NAME,[VALUES,VALUE],[DEFAULT,DEFAULTS],LINEBREAK,LABELS,LABELATTRIBUTES,
                       ATTRIBUTES,ROWS,[COLUMNS,COLS],[ROWHEADERS,ROWHEADER],[COLHEADERS,COLHEADER],
                       [OVERRIDE,FORCE],NOLABELS,TABINDEX,DISABLED
                  ],@@_);

d2364 1
a2364 1
    for (@@{$disabled}) {
d2368 1
a2368 1
    for (@@values) {
d2396 1
a2396 1
              CGI::label($labelattributes,
d2418 1
a2418 1
#             A pointer to a hash of labels to print next to each checkbox
d2431 1
a2431 1
    my($result,%selected);
d2434 3
a2436 5
	$selected{$self->param($name)}++;
    } elsif (defined $default) {
	%selected = map {$_=>1} ref($default) eq 'ARRAY' 
                                ? @@$default 
                                : $default;
d2445 1
a2445 1
    for (@@values) {
d2447 1
a2447 1
            for my $v (split(/\n/)) {
d2449 2
a2450 4
		for my $selected (keys %selected) {
		    $v =~ s/(value="$selected")/$selectit $1/;
		}
                $result .= "$v\n";
d2454 7
a2460 7
          my $attribs   = $self->_set_attributes($_, $attributes);
	  my($selectit) = $self->_selected($selected{$_});
	  my($label)    = $_;
	  $label        = $labels->{$_} if defined($labels) && defined($labels->{$_});
	  my($value)    = $self->escapeHTML($_);
	  $label        = $self->escapeHTML($label,1);
          $result      .= "<option${attribs} ${selectit}value=\"$value\">$label</option>\n";
d2477 1
a2477 1
#              A pointer to a hash of labels to print next to each item
d2504 1
a2504 1
    for (@@values) {
d2506 1
a2506 1
            for (split(/\n/)) {
d2544 1
a2544 1
#             A pointer to a hash of labels to print next to each checkbox
a2562 1

d2570 1
a2570 1
    for (@@values) {
d2610 1
a2610 1
	for ($default,$override,@@other) {
d2620 1
a2620 1
    for (@@value) {
d2695 1
a2695 1
    my $rewrite_in_use = $request_uri && $request_uri !~ /^\Q$script_name/;
d2699 2
a2700 3
    $uri            =~ s/\?.*$//s;                                # remove query string
    $uri            =~ s/\Q$ENV{PATH_INFO}\E$// if defined $ENV{PATH_INFO};
#    $uri            =~ s/\Q$path\E$//      if defined $path;      # remove path
a2725 1
    $url ||= '';
d2796 1
a2796 1
    unless (exists($self->{param}{$name})) {
d2798 1
a2798 1
	$self->{param}{$name} = [];
d2801 1
a2801 1
    return $self->{param}{$name};
d2827 1
a2827 28
# This function returns a potentially modified version of SCRIPT_NAME
# and PATH_INFO. Some HTTP servers do sanitise the paths in those
# variables. It is the case of at least Apache 2. If for instance the
# user requests: /path/./to/script.cgi/x//y/z/../x?y, Apache will set:
# REQUEST_URI=/path/./to/script.cgi/x//y/z/../x?y
# SCRIPT_NAME=/path/to/env.cgi
# PATH_INFO=/x/y/x
#
# This is all fine except that some bogus CGI scripts expect
# PATH_INFO=/http://foo when the user requests
# http://xxx/script.cgi/http://foo
#
# Old versions of this module used to accomodate with those scripts, so
# this is why we do this here to keep those scripts backward compatible.
# Basically, we accomodate with those scripts but within limits, that is
# we only try to preserve the number of / that were provided by the user
# if $REQUEST_URI and "$SCRIPT_NAME$PATH_INFO" only differ by the number
# of consecutive /.
#
# So for instance, in: http://foo/x//y/script.cgi/a//b, we'll return a
# script_name of /x//y/script.cgi and a path_info of /a//b, but in:
# http://foo/./x//z/script.cgi/a/../b//c, we'll return the versions
# possibly sanitised by the HTTP server, so in the case of Apache 2:
# script_name == /foo/x/z/script.cgi and path_info == /b/c.
#
# Future versions of this module may no longer do that, so one should
# avoid relying on the browser, proxy, server, and CGI.pm preserving the
# number of consecutive slashes as no guarantee can be made there.
d2830 21
a2850 22
    my $self = shift;
    my $script_name = $ENV{SCRIPT_NAME}  || '';
    my $path_info   = $ENV{PATH_INFO}    || '';
    my $uri         = $self->request_uri || '';

    $uri =~ s/\?.*//s;
    $uri = unescape($uri);

    if ($uri ne "$script_name$path_info") {
        my $script_name_pattern = quotemeta($script_name);
        my $path_info_pattern = quotemeta($path_info);
        $script_name_pattern =~ s{(?:\\/)+}{/+}g;
        $path_info_pattern =~ s{(?:\\/)+}{/+}g;

        if ($uri =~ /^($script_name_pattern)($path_info_pattern)$/s) {
            # REQUEST_URI and SCRIPT_NAME . PATH_INFO only differ by the
            # numer of consecutive slashes, so we can extract the info from
            # REQUEST_URI:
            ($script_name, $path_info) = ($1, $2);
        }
    }
    return ($script_name,$path_info);
d2902 1
a2902 1
    for $param ($self->param) {
d2904 1
a2904 1
	for $value ($self->param($param)) {
d2910 1
a2910 1
    for (keys %{$self->{'.fieldnames'}}) {
d2934 1
a2934 3
    my(@@accept) = defined $self->http('accept') 
                ? split(',',$self->http('accept'))
                : ();
d2936 1
a2936 1
    for (@@accept) {
d2955 1
a2955 1
    for (keys %prefs) {
d3136 1
a3136 1
    for (keys %ENV) {
d3155 1
a3155 1
    for (keys %ENV) {
d3287 1
a3287 1
	$selected{$_}++ for $self->param($name);
d3290 1
a3290 1
	$selected{$_}++ for @@{$defaults};
d3329 1
a3329 1
    for (@@words) {
a3370 2
	$header{'Content-Disposition'} ||= ''; # quench uninit variable warning

d3374 2
a3375 9
        # See RFC 1867, 2183, 2045
        # NB: File content will be loaded into memory should
        # content-disposition parsing fail.
        my ($filename) = $header{'Content-Disposition'}
	               =~/ filename=(("[^"]*")|([a-z\d!\#'\*\+,\.^_\`\{\}\|\~]*))/i;

	$filename ||= ''; # quench uninit variable warning

        $filename =~ s/^"([^"]*)"$/$1/;
d3389 1
a3389 1
	    push(@@{$self->{param}{$param}},$value);
d3426 1
a3426 1
	      for ( keys %header ) {
d3434 1
a3434 1
          my $totalbytes = 0;
d3465 1
a3465 1
	  push(@@{$self->{param}{$param}},$filehandle);
d3567 1
a3567 1
	  push(@@{$self->{param}{$param}},$filehandle);
d3619 1
a3619 1
    for my $attrib (keys %{$attributes->{$element}}) {
d3630 1
a3630 1
    for (@@_) {
a3647 1

d3699 1
a3699 1
    $file =~ m!^([a-zA-Z0-9_\+ \'\":/.\$\\~-]+)$! || return;
a3707 8
'handle' => <<'END_OF_FUNC',
sub handle {
  my $self = shift;
  eval "require IO::Handle" unless IO::Handle->can('new_from_fd');
  return IO::Handle->new_from_fd(fileno $self,"<");
}
END_OF_FUNC

d3771 1
a3771 1
		CHUNKED=>!$length,
a3988 8
    
    if( $CGI::OS eq 'WINDOWS' ){
       unshift @@TEMP,
           $ENV{TEMP},
           $ENV{TMP},
           $ENV{WINDIR} . $SL . 'TEMP';
    }

d4000 1
a4000 1
    for (@@TEMP) {
d4017 1
a4017 1
    $$self =~ m!^([a-zA-Z0-9_ \'\":/.\$\\~-]+)$! || return;
d4035 1
a4035 1
	last if ! -f ($filename = sprintf("\%s${SL}CGItemp%d", $TMPDIRECTORY, $sequence++));
d4038 1
a4038 1
    return unless $filename =~ m!^([a-zA-Z0-9_\+ \'\":/.\$\\~-]+)$!;
d4078 1
a4078 1
CGI - Handle Common Gateway Interface requests and responses
d4082 29
a4110 1
    use CGI;
d4112 1
a4112 1
    my $q = CGI->new;
d4114 11
a4124 2
    # Process an HTTP request
     @@values  = $q->param('form_field');
d4126 2
a4127 1
     $fh      = $q->upload('file_field');
d4129 1
a4129 14
     $riddle  = $query->cookie('riddle_name');
     %answers = $query->cookie('answers');

    # Prepare various HTTP responses
    print $q->header();
    print $q->header('application/json');

	$cookie1 = $q->cookie(-name=>'riddle_name', -value=>"The Sphynx's Question");
	$cookie2 = $q->cookie(-name=>'answers', -value=>\%answers);
    print $q->header(
        -type    => 'image/gif',
        -expires => '+3d',
        -cookie  => [$cookie1,$cookie2]
        );
d4131 2
a4132 1
   print  $q->redirect('http://somewhere.else/in/movie/land');
a4135 14
CGI.pm is a stable, complete and mature solution for processing and preparing
HTTP requests and responses.  Major features including processing form
submissions, file uploads, reading and writing cookies, query string generation
and manipulation, and processing and preparing HTTP headers. Some HTML
generation utilities are included as well.

CGI.pm performs very well in in a vanilla CGI.pm environment and also comes
with built-in support for mod_perl and mod_perl2 as well as FastCGI.

It has the benefit of having developed and refined over 10 years with input
from dozens of contributors and being deployed on thousands of websites.
CGI.pm has been included in the Perl distribution since Perl 5.4, and has
become a de-facto standard.

d4330 1
a4330 1
You can also initialize the query object from a hash
d4395 2
a4396 1
"name1=&name2=", it will be returned as an empty string.
a4479 4
Likewise if PUTed data can be retrieved with code like this:

   my $data = $query->param('PUTDATA');

d4557 1
a4557 1
   for (0..$records) {
a4814 10
=item -utf8

This makes CGI.pm treat all parameters as UTF-8 strings. Use this with
care, as it will interfere with the processing of binary uploads. It
is better to manually select which fields are expected to return utf-8
strings and convert them using code like this:

 use Encode;
 my $arg = decode utf8=>param('foo');

d5132 1
a5132 1
argument.  This argument expects a reference to a hash
d5391 1
a5391 1
(the original request URI). Set -rewrite=>0 to return URLs that match
d5471 2
a5472 2
If the first argument is a hash reference, then the keys
and values of the hash become the HTML tag's attributes:
d5990 1
a5990 2
filehandle-like object, or undef if the parameter is not a valid
filehandle.
d5997 1
a5997 1
In a list context, upload() will return an array of filehandles.
d6003 3
a6005 5
The lightweight filehandle returned by CGI.pm is not compatible with
IO::Handle; for example, it does not have read() or getline()
functions, but instead must be manipulated using read($fh) or
<$fh>. To get a compatible IO::Handle object, call the handle's
handle() method:
d6007 1
a6007 1
  my $real_io_handle = upload('uploaded_file')->handle;
d6014 1
a6014 1
a hash containing all the document headers.
d6105 1
a6105 1
			    -default=>['meenie','minie'],
d6128 1
a6128 2
The values of the previous choice will be maintained across
queries. Pass an array reference to select multiple defaults.
d6135 1
a6135 1
hash relating menu values to user-visible labels.  If you
d6143 2
a6144 2
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
d6196 1
a6196 1
to a hash containing user-visible labels for one or more
d6223 2
a6224 2
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
d6284 1
a6284 1
The optional sixth argument is a pointer to a hash
d6292 2
a6293 2
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
d6357 1
a6357 1
The optional B<-labels> argument is a pointer to a hash
d6369 1
a6369 1
The option B<-disabled> takes an array of checkbox values and disables
d6374 1
a6374 1
a hash relating menu values to another hash
a6391 3
The optional B<-labelattributes> argument will contain attributes
attached to the <label> element that surrounds each button.

d6545 1
a6545 1
a hash relating menu values to another hash
a6548 3
The optional B<-labelattributes> argument will contain attributes
attached to the <label> element that surrounds each button.

d6712 3
a6714 1
pointed to by the B<-onClick> parameter will be executed.
d6718 4
a6721 3
Browsers support a so-called "cookie" designed to help maintain state
within a browser session.  CGI.pm has several methods that support
cookies.
d6796 2
a6797 2
array reference, or even hash reference.  For example,
you can store an entire hash into a cookie this way:
d6924 13
d7278 5
a7282 3
Returns the HTTP_COOKIE variable.  Cookies have a special format, and
this method call just returns the raw form (?cookie dough).  See
cookie() for ways of setting and retrieving cooked cookies.
d7296 1
a7296 1
like user_agent(Mozilla);
d7435 1
a7435 1
setting a cookie, B<do not work at all> on IIS without a special patch
d7479 1
a7479 1
  for (0 .. 4) {
d7535 3
d7661 4
a7664 2
The GD.pm interface is copyright 1995-2007, Lincoln D. Stein.  It is
distributed under GPL and the Artistic License 2.0.
d7791 1
a7791 1
	   for $key (param) {
@


