head	1.13;
access;
symbols
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.9.0.6
	OPENBSD_3_9_BASE:1.9
	OPENBSD_3_8:1.9.0.4
	OPENBSD_3_8_BASE:1.9
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.13
date	2010.09.24.14.59.33;	author millert;	state dead;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.38;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.09;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.15.21.30.31;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.09.18.09.28;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.33.04;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.36;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.24;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.45;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.56.49;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.49;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.19;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.57;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.12;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.46.44;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.06;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.31;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.50;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.13
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package base;

use strict 'vars';
use vars qw($VERSION);
$VERSION = '2.14';
$VERSION = eval $VERSION;

# constant.pm is slow
sub SUCCESS () { 1 }

sub PUBLIC     () { 2**0  }
sub PRIVATE    () { 2**1  }
sub INHERITED  () { 2**2  }
sub PROTECTED  () { 2**3  }


my $Fattr = \%fields::attr;

sub has_fields {
    my($base) = shift;
    my $fglob = ${"$base\::"}{FIELDS};
    return( ($fglob && 'GLOB' eq ref($fglob) && *$fglob{HASH}) ? 1 : 0 );
}

sub has_version {
    my($base) = shift;
    my $vglob = ${$base.'::'}{VERSION};
    return( ($vglob && *$vglob{SCALAR}) ? 1 : 0 );
}

sub has_attr {
    my($proto) = shift;
    my($class) = ref $proto || $proto;
    return exists $Fattr->{$class};
}

sub get_attr {
    $Fattr->{$_[0]} = [1] unless $Fattr->{$_[0]};
    return $Fattr->{$_[0]};
}

if ($] < 5.009) {
    *get_fields = sub {
        # Shut up a possible typo warning.
        () = \%{$_[0].'::FIELDS'};
        my $f = \%{$_[0].'::FIELDS'};

        # should be centralized in fields? perhaps
        # fields::mk_FIELDS_be_OK. Peh. As long as %{ $package . '::FIELDS' }
        # is used here anyway, it doesn't matter.
        bless $f, 'pseudohash' if (ref($f) ne 'pseudohash');

        return $f;
    }
}
else {
    *get_fields = sub {
        # Shut up a possible typo warning.
        () = \%{$_[0].'::FIELDS'};
        return \%{$_[0].'::FIELDS'};
    }
}

sub import {
    my $class = shift;

    return SUCCESS unless @@_;

    # List of base classes from which we will inherit %FIELDS.
    my $fields_base;

    my $inheritor = caller(0);
    my @@isa_classes;

    my @@bases;
    foreach my $base (@@_) {
        if ( $inheritor eq $base ) {
            warn "Class '$inheritor' tried to inherit from itself\n";
        }

        next if grep $_->isa($base), ($inheritor, @@bases);

        if (has_version($base)) {
            ${$base.'::VERSION'} = '-1, set by base.pm' 
              unless defined ${$base.'::VERSION'};
        }
        else {
            my $sigdie;
            {
                local $SIG{__DIE__};
                eval "require $base";
                # Only ignore "Can't locate" errors from our eval require.
                # Other fatal errors (syntax etc) must be reported.
                die if $@@ && $@@ !~ /^Can't locate .*? at \(eval /;
                unless (%{"$base\::"}) {
                    require Carp;
                    local $" = " ";
                    Carp::croak(<<ERROR);
Base class package "$base" is empty.
    (Perhaps you need to 'use' the module which defines that package first,
    or make that module available in \@@INC (\@@INC contains: @@INC).
ERROR
                }
                $sigdie = $SIG{__DIE__} || undef;
            }
            # Make sure a global $SIG{__DIE__} makes it out of the localization.
            $SIG{__DIE__} = $sigdie if defined $sigdie;
            ${$base.'::VERSION'} = "-1, set by base.pm"
              unless defined ${$base.'::VERSION'};
        }
        push @@bases, $base;

        if ( has_fields($base) || has_attr($base) ) {
            # No multiple fields inheritance *suck*
            if ($fields_base) {
                require Carp;
                Carp::croak("Can't multiply inherit fields");
            } else {
                $fields_base = $base;
            }
        }
    }
    # Save this until the end so it's all or nothing if the above loop croaks.
    push @@{"$inheritor\::ISA"}, @@isa_classes;

    push @@{"$inheritor\::ISA"}, @@bases;

    if( defined $fields_base ) {
        inherit_fields($inheritor, $fields_base);
    }
}


sub inherit_fields {
    my($derived, $base) = @@_;

    return SUCCESS unless $base;

    my $battr = get_attr($base);
    my $dattr = get_attr($derived);
    my $dfields = get_fields($derived);
    my $bfields = get_fields($base);

    $dattr->[0] = @@$battr;

    if( keys %$dfields ) {
        warn <<"END";
$derived is inheriting from $base but already has its own fields!
This will cause problems.  Be sure you use base BEFORE declaring fields.
END

    }

    # Iterate through the base's fields adding all the non-private
    # ones to the derived class.  Hang on to the original attribute
    # (Public, Private, etc...) and add Inherited.
    # This is all too complicated to do efficiently with add_fields().
    while (my($k,$v) = each %$bfields) {
        my $fno;
        if ($fno = $dfields->{$k} and $fno != $v) {
            require Carp;
            Carp::croak ("Inherited fields can't override existing fields");
        }

        if( $battr->[$v] & PRIVATE ) {
            $dattr->[$v] = PRIVATE | INHERITED;
        }
        else {
            $dattr->[$v] = INHERITED | $battr->[$v];
            $dfields->{$k} = $v;
        }
    }

    foreach my $idx (1..$#{$battr}) {
        next if defined $dattr->[$idx];
        $dattr->[$idx] = $battr->[$idx] & INHERITED;
    }
}


1;

__END__

=head1 NAME

base - Establish an ISA relationship with base classes at compile time

=head1 SYNOPSIS

    package Baz;
    use base qw(Foo Bar);

=head1 DESCRIPTION

Unless you are using the C<fields> pragma, consider this module discouraged
in favor of the lighter-weight C<parent>.

Allows you to both load one or more modules, while setting up inheritance from
those modules at the same time.  Roughly similar in effect to

    package Baz;
    BEGIN {
        require Foo;
        require Bar;
        push @@ISA, qw(Foo Bar);
    }

C<base> employs some heuristics to determine if a module has already been
loaded, if it has it doesn't try again. If C<base> tries to C<require> the
module it will not die if it cannot find the module's file, but will die on any
other error. After all this, should your base class be empty, containing no
symbols, it will die. This is useful for inheriting from classes in the same
file as yourself, like so:

        package Foo;
        sub exclaim { "I can have such a thing?!" }
        
        package Bar;
        use base "Foo";

If $VERSION is not detected even after loading it, <base> will define $VERSION
in the base package, setting it to the string C<-1, set by base.pm>.

C<base> will also initialize the fields if one of the base classes has it.
Multiple inheritance of fields is B<NOT> supported, if two or more base classes
each have inheritable fields the 'base' pragma will croak. See L<fields>,
L<public> and L<protected> for a description of this feature.

The base class' C<import> method is B<not> called.


=head1 DIAGNOSTICS

=over 4

=item Base class package "%s" is empty.

base.pm was unable to require the base package, because it was not
found in your path.

=item Class 'Foo' tried to inherit from itself

Attempting to inherit from yourself generates a warning.

    use Foo;
    use base 'Foo';

=back

=head1 HISTORY

This module was introduced with Perl 5.004_04.

=head1 CAVEATS

Due to the limitations of the implementation, you must use
base I<before> you declare any of your own fields.


=head1 SEE ALSO

L<fields>

=cut
@


1.12
log
@Merge in perl 5.10.1
@
text
@@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d5 2
a6 1
$VERSION = '2.13';
d195 3
@


1.10
log
@merge in perl 5.8.8
@
text
@d5 1
a5 1
$VERSION = '2.07';
d21 1
a21 1
    return( ($fglob && *$fglob{HASH}) ? 1 : 0 );
d43 8
a50 8
	# Shut up a possible typo warning.
	() = \%{$_[0].'::FIELDS'};
	my $f = \%{$_[0].'::FIELDS'};

	# should be centralized in fields? perhaps
	# fields::mk_FIELDS_be_OK. Peh. As long as %{ $package . '::FIELDS' }
	# is used here anyway, it doesn't matter.
	bless $f, 'pseudohash' if (ref($f) ne 'pseudohash');
d52 1
a52 1
	return $f;
d57 3
a59 3
	# Shut up a possible typo warning.
	() = \%{$_[0].'::FIELDS'};
	return \%{$_[0].'::FIELDS'};
d72 1
d74 1
d76 5
a80 1
        next if $inheritor->isa($base);
d83 2
a84 2
	    ${$base.'::VERSION'} = '-1, set by base.pm' 
	      unless defined ${$base.'::VERSION'};
d87 11
a97 8
            local $SIG{__DIE__};
            eval "require $base";
            # Only ignore "Can't locate" errors from our eval require.
            # Other fatal errors (syntax etc) must be reported.
            die if $@@ && $@@ !~ /^Can't locate .*? at \(eval /;
            unless (%{"$base\::"}) {
                require Carp;
                Carp::croak(<<ERROR);
d99 2
a100 1
    (Perhaps you need to 'use' the module which defines that package first.)
d102 2
a103 1

d105 2
d110 1
a110 1
        push @@{"$inheritor\::ISA"}, $base;
d113 7
a119 7
	    # No multiple fields inheritence *suck*
	    if ($fields_base) {
		require Carp;
		Carp::croak("Can't multiply inherit %FIELDS");
	    } else {
		$fields_base = $base;
	    }
d122 4
d146 5
a150 4
        warn "$derived is inheriting from $base but already has its own ".
             "fields!\n".
             "This will cause problems.\n".
             "Be sure you use base BEFORE declaring fields\n";
d159 4
a162 4
	if ($fno = $dfields->{$k} and $fno != $v) {
	    require Carp;
	    Carp::croak ("Inherited %FIELDS can't override existing %FIELDS");
	}
d174 2
a175 2
	next if defined $dattr->[$idx];
	$dattr->[$idx] = $battr->[$idx] & INHERITED;
d186 1
a186 1
base - Establish IS-A relationship with base classes at compile time
d205 23
a227 12
If any of the listed modules are not loaded yet, I<base> silently attempts to
C<require> them (and silently continues if the C<require> failed).  Whether to
C<require> a base class module is determined by the absence of a global variable
$VERSION in the base package.  If $VERSION is not detected even after loading
it, <base> will define $VERSION in the base package, setting it to the string
C<-1, set by base.pm>.

Will also initialize the fields if one of the base classes has it.
Multiple inheritence of fields is B<NOT> supported, if two or more
base classes each have inheritable fields the 'base' pragma will
croak.  See L<fields>, L<public> and L<protected> for a description of
this feature.
d238 7
a249 1

@


1.9
log
@sync in-tree perl with 5.8.6
@
text
@d5 1
a5 1
$VERSION = '2.06';
d81 1
a81 1
            local $SIG{__DIE__} = 'IGNORE';
@


1.8
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d155 3
a157 4
    unless( keys %$bfields ) {
        foreach my $idx (1..$#{$battr}) {
            $dattr->[$idx] = $battr->[$idx] & INHERITED;
        }
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d5 1
a5 1
$VERSION = '2.04';
d41 20
a60 5
sub get_fields {
    # Shut up a possible typo warning.
    () = \%{$_[0].'::FIELDS'};

    return \%{$_[0].'::FIELDS'};
d200 11
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d5 1
a5 1
$VERSION = '2.03';
d116 1
a116 1
             "This will cause problems with pseudo-hashes.\n".
d154 1
a154 1
base - Establish IS-A relationship with base class at compile time
d163 2
a164 1
Roughly similar in effect to
d166 1
d173 7
d181 1
a181 1
Multiple Inheritence of fields is B<NOT> supported, if two or more
a185 11
When strict 'vars' is in scope, I<base> also lets you assign to @@ISA
without having to declare @@ISA with the 'vars' pragma first.

If any of the base classes are not loaded yet, I<base> silently
C<require>s them (but it won't call the C<import> method).  Whether to
C<require> a base class package is determined by the absence of a global
$VERSION in the base package.  If $VERSION is not detected even after
loading it, I<base> will define $VERSION in the base package, setting it to
the string C<-1, set by base.pm>.


d193 1
a193 1
Due to the limitations of the pseudo-hash implementation, you must use
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d1 151
d166 3
a168 3
	require Foo;
	require Bar;
	push @@ISA, qw(Foo Bar);
d171 5
a175 4
Will also initialize the %FIELDS hash if one of the base classes has
it.  Multiple inheritance of %FIELDS is not supported.  The 'base'
pragma will croak if multiple base classes have a %FIELDS hash.  See
L<fields> for a description of this feature.
d177 1
a177 1
When strict 'vars' is in scope I<base> also let you assign to @@ISA
d181 6
a186 5
C<require>s them.  Whether to C<require> a base class package is
determined by the absence of a global $VERSION in the base package.
If $VERSION is not detected even after loading it, <base> will
define $VERSION in the base package, setting it to the string
C<-1, set by base.pm>.
a191 1
=head1 SEE ALSO
d193 1
a193 1
L<fields>
d195 2
a196 1
=cut
a197 1
package base;
d199 1
a199 2
use 5.006_001;
our $VERSION = "1.03";
d201 1
a201 4
sub import {
    my $class = shift;
    my $fields_base;
    my $pkg = caller(0);
d203 1
a203 40
    foreach my $base (@@_) {
	next if $pkg->isa($base);
        my $vglob;
	if ($vglob = ${"$base\::"}{VERSION} and *$vglob{SCALAR}) {
          $$vglob = "-1, set by base.pm" unless defined $$vglob;
        } else {
	    eval "require $base";
	    # Only ignore "Can't locate" errors from our eval require.
	    # Other fatal errors (syntax etc) must be reported.
	    die if $@@ && $@@ !~ /^Can't locate .*? at \(eval /;
	    unless (%{"$base\::"}) {
		require Carp;
		Carp::croak("Base class package \"$base\" is empty.\n",
			    "\t(Perhaps you need to 'use' the module ",
			    "which defines that package first.)");
	    }
	    ${"$base\::VERSION"} = "-1, set by base.pm" unless defined ${"$base\::VERSION"};
	}
	push @@{"$pkg\::ISA"}, $base;

	# A simple test like (defined %{"$base\::FIELDS"}) will
	# sometimes produce typo warnings because it would create
	# the hash if it was not present before.
	my $fglob;
	if ($fglob = ${"$base\::"}{"FIELDS"} and *$fglob{HASH}) {
	    if ($fields_base) {
		require Carp;
		Carp::croak("Can't multiply inherit %FIELDS");
	    } else {
		$fields_base = $base;
	    }
	}
    }
    if ($fields_base) {
	require fields;
	fields::inherit($pkg, $fields_base);
    }
}

1;
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d47 2
a48 2
use 5.005_64;
our $VERSION = "1.01";
d57 4
a60 2
	push @@{"$pkg\::ISA"}, $base;
	unless (exists ${"$base\::"}{VERSION}) {
d71 1
a71 2
	    ${"$base\::VERSION"} = "-1, set by base.pm"
		unless exists ${"$base\::"}{VERSION};
d73 1
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d33 1
a33 1
C<-1, defined by base.pm>.
@


1.2
log
@perl5.005_03 (stock)
@
text
@d22 1
a22 1
pragma will croak if multiple base classes has a %FIELDS hash.  See
d28 9
d47 3
d53 1
d56 3
a58 1
	unless (defined %{"$base\::"}) {
d63 1
a63 1
	    unless (defined %{"$base\::"}) {
d69 2
a85 2
    my $pkg = caller(0);
    push @@{"$pkg\::ISA"}, @@_;
@


1.1
log
@perl 5.004_04
@
text
@a7 1

d20 8
d30 1
a30 1
=head1 BUGS
d32 1
a32 1
Needs proper documentation!
d40 1
d45 3
d55 19
a74 2
    
    push @@{caller(0) . '::ISA'}, @@_;
@


1.1.1.1
log
@perl5.005_03
@
text
@d8 1
a20 8
Will also initialize the %FIELDS hash if one of the base classes has
it.  Multiple inheritance of %FIELDS is not supported.  The 'base'
pragma will croak if multiple base classes has a %FIELDS hash.  See
L<fields> for a description of this feature.

When strict 'vars' is in scope I<base> also let you assign to @@ISA
without having to declare @@ISA with the 'vars' pragma first.

d23 1
a23 1
=head1 SEE ALSO
d25 1
a25 1
L<fields>
a32 1
    my $fields_base;
a36 3
	    # Only ignore "Can't locate" errors from our eval require.
	    # Other fatal errors (syntax etc) must be reported.
	    die if $@@ && $@@ !~ /^Can't locate .*? at \(eval /;
a43 19

	# A simple test like (defined %{"$base\::FIELDS"}) will
	# sometimes produce typo warnings because it would create
	# the hash if it was not present before.
	my $fglob;
	if ($fglob = ${"$base\::"}{"FIELDS"} and *$fglob{HASH}) {
	    if ($fields_base) {
		require Carp;
		Carp::croak("Can't multiply inherit %FIELDS");
	    } else {
		$fields_base = $base;
	    }
	}
    }
    my $pkg = caller(0);
    push @@{"$pkg\::ISA"}, @@_;
    if ($fields_base) {
	require fields;
	fields::inherit($pkg, $fields_base);
d45 2
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d22 1
a22 1
pragma will croak if multiple base classes have a %FIELDS hash.  See
a27 9
If any of the base classes are not loaded yet, I<base> silently
C<require>s them.  Whether to C<require> a base class package is
determined by the absence of a global $VERSION in the base package.
If $VERSION is not detected even after loading it, <base> will
define $VERSION in the base package, setting it to the string
C<-1, defined by base.pm>.

=head1 HISTORY

a37 3
use 5.005_64;
our $VERSION = "1.01";

a40 1
    my $pkg = caller(0);
d43 1
a43 3
	next if $pkg->isa($base);
	push @@{"$pkg\::ISA"}, $base;
	unless (exists ${"$base\::"}{VERSION}) {
d48 1
a48 1
	    unless (%{"$base\::"}) {
a53 2
	    ${"$base\::VERSION"} = "-1, set by base.pm"
		unless exists ${"$base\::"}{VERSION};
d69 2
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d33 1
a33 1
C<-1, set by base.pm>.
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d47 2
a48 2
use 5.006_001;
our $VERSION = "1.03";
d57 2
a58 4
        my $vglob;
	if ($vglob = ${"$base\::"}{VERSION} and *$vglob{SCALAR}) {
          $$vglob = "-1, set by base.pm" unless defined $$vglob;
        } else {
d69 2
a70 1
	    ${"$base\::VERSION"} = "-1, set by base.pm" unless defined ${"$base\::VERSION"};
a71 1
	push @@{"$pkg\::ISA"}, $base;
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@a0 151
package base;

use strict 'vars';
use vars qw($VERSION);
$VERSION = '2.03';

# constant.pm is slow
sub SUCCESS () { 1 }

sub PUBLIC     () { 2**0  }
sub PRIVATE    () { 2**1  }
sub INHERITED  () { 2**2  }
sub PROTECTED  () { 2**3  }


my $Fattr = \%fields::attr;

sub has_fields {
    my($base) = shift;
    my $fglob = ${"$base\::"}{FIELDS};
    return( ($fglob && *$fglob{HASH}) ? 1 : 0 );
}

sub has_version {
    my($base) = shift;
    my $vglob = ${$base.'::'}{VERSION};
    return( ($vglob && *$vglob{SCALAR}) ? 1 : 0 );
}

sub has_attr {
    my($proto) = shift;
    my($class) = ref $proto || $proto;
    return exists $Fattr->{$class};
}

sub get_attr {
    $Fattr->{$_[0]} = [1] unless $Fattr->{$_[0]};
    return $Fattr->{$_[0]};
}

sub get_fields {
    # Shut up a possible typo warning.
    () = \%{$_[0].'::FIELDS'};

    return \%{$_[0].'::FIELDS'};
}

sub import {
    my $class = shift;

    return SUCCESS unless @@_;

    # List of base classes from which we will inherit %FIELDS.
    my $fields_base;

    my $inheritor = caller(0);

    foreach my $base (@@_) {
        next if $inheritor->isa($base);

        if (has_version($base)) {
	    ${$base.'::VERSION'} = '-1, set by base.pm' 
	      unless defined ${$base.'::VERSION'};
        }
        else {
            local $SIG{__DIE__} = 'IGNORE';
            eval "require $base";
            # Only ignore "Can't locate" errors from our eval require.
            # Other fatal errors (syntax etc) must be reported.
            die if $@@ && $@@ !~ /^Can't locate .*? at \(eval /;
            unless (%{"$base\::"}) {
                require Carp;
                Carp::croak(<<ERROR);
Base class package "$base" is empty.
    (Perhaps you need to 'use' the module which defines that package first.)
ERROR

            }
            ${$base.'::VERSION'} = "-1, set by base.pm"
              unless defined ${$base.'::VERSION'};
        }
        push @@{"$inheritor\::ISA"}, $base;

        if ( has_fields($base) || has_attr($base) ) {
	    # No multiple fields inheritence *suck*
	    if ($fields_base) {
		require Carp;
		Carp::croak("Can't multiply inherit %FIELDS");
	    } else {
		$fields_base = $base;
	    }
        }
    }

    if( defined $fields_base ) {
        inherit_fields($inheritor, $fields_base);
    }
}


sub inherit_fields {
    my($derived, $base) = @@_;

    return SUCCESS unless $base;

    my $battr = get_attr($base);
    my $dattr = get_attr($derived);
    my $dfields = get_fields($derived);
    my $bfields = get_fields($base);

    $dattr->[0] = @@$battr;

    if( keys %$dfields ) {
        warn "$derived is inheriting from $base but already has its own ".
             "fields!\n".
             "This will cause problems with pseudo-hashes.\n".
             "Be sure you use base BEFORE declaring fields\n";
    }

    # Iterate through the base's fields adding all the non-private
    # ones to the derived class.  Hang on to the original attribute
    # (Public, Private, etc...) and add Inherited.
    # This is all too complicated to do efficiently with add_fields().
    while (my($k,$v) = each %$bfields) {
        my $fno;
	if ($fno = $dfields->{$k} and $fno != $v) {
	    require Carp;
	    Carp::croak ("Inherited %FIELDS can't override existing %FIELDS");
	}

        if( $battr->[$v] & PRIVATE ) {
            $dattr->[$v] = PRIVATE | INHERITED;
        }
        else {
            $dattr->[$v] = INHERITED | $battr->[$v];
            $dfields->{$k} = $v;
        }
    }

    unless( keys %$bfields ) {
        foreach my $idx (1..$#{$battr}) {
            $dattr->[$idx] = $battr->[$idx] & INHERITED;
        }
    }
}


1;

__END__

d15 3
a17 3
        require Foo;
        require Bar;
        push @@ISA, qw(Foo Bar);
d20 4
a23 5
Will also initialize the fields if one of the base classes has it.
Multiple Inheritence of fields is B<NOT> supported, if two or more
base classes each have inheritable fields the 'base' pragma will
croak.  See L<fields>, L<public> and L<protected> for a description of
this feature.
d25 1
a25 1
When strict 'vars' is in scope, I<base> also lets you assign to @@ISA
d29 5
a33 6
C<require>s them (but it won't call the C<import> method).  Whether to
C<require> a base class package is determined by the absence of a global
$VERSION in the base package.  If $VERSION is not detected even after
loading it, I<base> will define $VERSION in the base package, setting it to
the string C<-1, set by base.pm>.

d39 3
d43 1
a43 1
=head1 CAVEATS
d45 1
a45 2
Due to the limitations of the pseudo-hash implementation, you must use
base I<before> you declare any of your own fields.
d47 2
d50 24
a73 1
=head1 SEE ALSO
d75 18
a92 1
L<fields>
d94 1
a94 1
=cut
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d5 1
a5 1
$VERSION = '2.04';
d116 1
a116 1
             "This will cause problems.\n".
d154 1
a154 1
base - Establish IS-A relationship with base classes at compile time
d163 1
a163 2
Allows you to both load one or more modules, while setting up inheritance from
those modules at the same time.  Roughly similar in effect to
a164 1
    package Baz;
a170 7
If any of the listed modules are not loaded yet, I<base> silently attempts to
C<require> them (and silently continues if the C<require> failed).  Whether to
C<require> a base class module is determined by the absence of a global variable
$VERSION in the base package.  If $VERSION is not detected even after loading
it, <base> will define $VERSION in the base package, setting it to the string
C<-1, set by base.pm>.

d172 1
a172 1
Multiple inheritence of fields is B<NOT> supported, if two or more
d177 11
d195 1
a195 1
Due to the limitations of the implementation, you must use
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d5 1
a5 1
$VERSION = '2.06';
d41 5
a45 20
if ($] < 5.009) {
    *get_fields = sub {
	# Shut up a possible typo warning.
	() = \%{$_[0].'::FIELDS'};
	my $f = \%{$_[0].'::FIELDS'};

	# should be centralized in fields? perhaps
	# fields::mk_FIELDS_be_OK. Peh. As long as %{ $package . '::FIELDS' }
	# is used here anyway, it doesn't matter.
	bless $f, 'pseudohash' if (ref($f) ne 'pseudohash');

	return $f;
    }
}
else {
    *get_fields = sub {
	# Shut up a possible typo warning.
	() = \%{$_[0].'::FIELDS'};
	return \%{$_[0].'::FIELDS'};
    }
a184 11

=head1 DIAGNOSTICS

=over 4

=item Base class package "%s" is empty.

base.pm was unable to require the base package, because it was not
found in your path.

=back
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d155 4
a158 3
    foreach my $idx (1..$#{$battr}) {
	next if defined $dattr->[$idx];
	$dattr->[$idx] = $battr->[$idx] & INHERITED;
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d5 1
a5 1
$VERSION = '2.07';
d81 1
a81 1
            local $SIG{__DIE__};
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d5 1
a5 1
$VERSION = '2.13';
d21 1
a21 1
    return( ($fglob && 'GLOB' eq ref($fglob) && *$fglob{HASH}) ? 1 : 0 );
d43 8
a50 8
        # Shut up a possible typo warning.
        () = \%{$_[0].'::FIELDS'};
        my $f = \%{$_[0].'::FIELDS'};

        # should be centralized in fields? perhaps
        # fields::mk_FIELDS_be_OK. Peh. As long as %{ $package . '::FIELDS' }
        # is used here anyway, it doesn't matter.
        bless $f, 'pseudohash' if (ref($f) ne 'pseudohash');
d52 1
a52 1
        return $f;
d57 3
a59 3
        # Shut up a possible typo warning.
        () = \%{$_[0].'::FIELDS'};
        return \%{$_[0].'::FIELDS'};
a71 1
    my @@isa_classes;
a72 1
    my @@bases;
d74 1
a74 5
        if ( $inheritor eq $base ) {
            warn "Class '$inheritor' tried to inherit from itself\n";
        }

        next if grep $_->isa($base), ($inheritor, @@bases);
d77 2
a78 2
            ${$base.'::VERSION'} = '-1, set by base.pm' 
              unless defined ${$base.'::VERSION'};
d81 8
a88 11
            my $sigdie;
            {
                local $SIG{__DIE__};
                eval "require $base";
                # Only ignore "Can't locate" errors from our eval require.
                # Other fatal errors (syntax etc) must be reported.
                die if $@@ && $@@ !~ /^Can't locate .*? at \(eval /;
                unless (%{"$base\::"}) {
                    require Carp;
                    local $" = " ";
                    Carp::croak(<<ERROR);
d90 1
a90 2
    (Perhaps you need to 'use' the module which defines that package first,
    or make that module available in \@@INC (\@@INC contains: @@INC).
d92 1
a92 2
                }
                $sigdie = $SIG{__DIE__} || undef;
a93 2
            # Make sure a global $SIG{__DIE__} makes it out of the localization.
            $SIG{__DIE__} = $sigdie if defined $sigdie;
d97 1
a97 1
        push @@bases, $base;
d100 7
a106 7
            # No multiple fields inheritance *suck*
            if ($fields_base) {
                require Carp;
                Carp::croak("Can't multiply inherit fields");
            } else {
                $fields_base = $base;
            }
a108 4
    # Save this until the end so it's all or nothing if the above loop croaks.
    push @@{"$inheritor\::ISA"}, @@isa_classes;

    push @@{"$inheritor\::ISA"}, @@bases;
d129 4
a132 5
        warn <<"END";
$derived is inheriting from $base but already has its own fields!
This will cause problems.  Be sure you use base BEFORE declaring fields.
END

d141 4
a144 4
        if ($fno = $dfields->{$k} and $fno != $v) {
            require Carp;
            Carp::croak ("Inherited fields can't override existing fields");
        }
d156 2
a157 2
        next if defined $dattr->[$idx];
        $dattr->[$idx] = $battr->[$idx] & INHERITED;
d168 1
a168 1
base - Establish an ISA relationship with base classes at compile time
d187 12
a198 23
C<base> employs some heuristics to determine if a module has already been
loaded, if it has it doesn't try again. If C<base> tries to C<require> the
module it will not die if it cannot find the module's file, but will die on any
other error. After all this, should your base class be empty, containing no
symbols, it will die. This is useful for inheriting from classes in the same
file as yourself, like so:

        package Foo;
        sub exclaim { "I can have such a thing?!" }
        
        package Bar;
        use base "Foo";

If $VERSION is not detected even after loading it, <base> will define $VERSION
in the base package, setting it to the string C<-1, set by base.pm>.

C<base> will also initialize the fields if one of the base classes has it.
Multiple inheritance of fields is B<NOT> supported, if two or more base classes
each have inheritable fields the 'base' pragma will croak. See L<fields>,
L<public> and L<protected> for a description of this feature.

The base class' C<import> method is B<not> called.

a208 7
=item Class 'Foo' tried to inherit from itself

Attempting to inherit from yourself generates a warning.

    use Foo;
    use base 'Foo';

d214 1
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d5 1
a5 2
$VERSION = '2.14';
$VERSION = eval $VERSION;
a193 3

Unless you are using the C<fields> pragma, consider this module discouraged
in favor of the lighter-weight C<parent>.
@


