head	1.9;
access;
symbols
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.7.0.18
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.16
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.14
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.12
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.10
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.7
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2010.09.24.14.59.33;	author millert;	state dead;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.09;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.09.18.09.28;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.35;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.06;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.56.46;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.31;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.31;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.48;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.35;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.18;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.43.59;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.46.41;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.29;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package Shell;
use 5.006_001;
use strict;
use warnings;
use File::Spec::Functions;

our($capture_stderr, $raw, $VERSION, $AUTOLOAD);

$VERSION = '0.72_01';
$VERSION = eval $VERSION;

sub new { bless \my $foo, shift }
sub DESTROY { }

sub import {
    my $self = shift;
    my ($callpack, $callfile, $callline) = caller;
    my @@EXPORT;
    if (@@_) {
        @@EXPORT = @@_;
    } else {
        @@EXPORT = 'AUTOLOAD';
    }
    foreach my $sym (@@EXPORT) {
        no strict 'refs';
        *{"${callpack}::$sym"} = \&{"Shell::$sym"};
    }
}

# NOTE: this is used to enable constant folding in 
# expressions like (OS eq 'MSWin32') and 
# (OS eq 'os2') just like it happened in  0.6  version 
# which used eval "string" to install subs on the fly.
use constant OS => $^O;

=begin private

=item B<_make_cmd>

  $sub = _make_cmd($cmd);
  $sub = $shell->_make_cmd($cmd);

Creates a closure which invokes the system command C<$cmd>.

=end private

=cut

sub _make_cmd {
    shift if ref $_[0] && $_[0]->isa( 'Shell' );
    my $cmd = shift;
    my $null = File::Spec::Functions::devnull();
    $Shell::capture_stderr ||= 0;
    # closing over $^O, $cmd, and $null
    return sub {
            shift if ref $_[0] && $_[0]->isa( 'Shell' );
            if (@@_ < 1) {
                $Shell::capture_stderr ==  1 ? `$cmd 2>&1` : 
                $Shell::capture_stderr == -1 ? `$cmd 2>$null` : 
                `$cmd`;
            } elsif (OS eq 'os2') {
                local(*SAVEOUT, *READ, *WRITE);

                open SAVEOUT, '>&STDOUT' or die;
                pipe READ, WRITE or die;
                open STDOUT, '>&WRITE' or die;
                close WRITE;

                my $pid = system(1, $cmd, @@_);
                die "Can't execute $cmd: $!\n" if $pid < 0;

                open STDOUT, '>&SAVEOUT' or die;
                close SAVEOUT;

                if (wantarray) {
                    my @@ret = <READ>;
                    close READ;
                    waitpid $pid, 0;
                    @@ret;
                } else {
                    local($/) = undef;
                    my $ret = <READ>;
                    close READ;
                    waitpid $pid, 0;
                    $ret;
                }
            } else {
                my $a;
                my @@arr = @@_;
                unless( $Shell::raw ){
                  if (OS eq 'MSWin32') {
                    # XXX this special-casing should not be needed
                    # if we do quoting right on Windows. :-(
                    #
                    # First, escape all quotes.  Cover the case where we
                    # want to pass along a quote preceded by a backslash
                    # (i.e., C<"param \""" end">).
                    # Ugly, yup?  You know, windoze.
                    # Enclose in quotes only the parameters that need it:
                    #   try this: c:> dir "/w"
                    #   and this: c:> dir /w
                    for (@@arr) {
                        s/"/\\"/g;
                        s/\\\\"/\\\\"""/g;
                        $_ = qq["$_"] if /\s/;
                    }
                  } else {
                    for (@@arr) {
                        s/(['\\])/\\$1/g;
                        $_ = $_;
                     }
                  }
                }
                push @@arr, '2>&1'        if $Shell::capture_stderr ==  1;
                push @@arr, '2>$null' if $Shell::capture_stderr == -1;
                open(SUBPROC, join(' ', $cmd, @@arr, '|'))
                    or die "Can't exec $cmd: $!\n";
                if (wantarray) {
                    my @@ret = <SUBPROC>;
                    close SUBPROC;        # XXX Oughta use a destructor.
                    @@ret;
                } else {
                    local($/) = undef;
                    my $ret = <SUBPROC>;
                    close SUBPROC;
                    $ret;
                }
            }
        };
        }

sub AUTOLOAD {
    shift if ref $_[0] && $_[0]->isa( 'Shell' );
    my $cmd = $AUTOLOAD;
    $cmd =~ s/^.*:://;
    no strict 'refs';
    *$AUTOLOAD = _make_cmd($cmd);
    goto &$AUTOLOAD;
}

1;

__END__

=head1 NAME

Shell - run shell commands transparently within perl

=head1 SYNOPSIS

   use Shell qw(cat ps cp);
   $passwd = cat('</etc/passwd');
   @@pslines = ps('-ww'),
   cp("/etc/passwd", "/tmp/passwd");

   # object oriented 
   my $sh = Shell->new;
   print $sh->ls('-l');

=head1 DESCRIPTION

=head2 Caveats

This package is included as a show case, illustrating a few Perl features.
It shouldn't be used for production programs. Although it does provide a 
simple interface for obtaining the standard output of arbitrary commands,
there may be better ways of achieving what you need.

Running shell commands while obtaining standard output can be done with the
C<qx/STRING/> operator, or by calling C<open> with a filename expression that
ends with C<|>, giving you the option to process one line at a time.
If you don't need to process standard output at all, you might use C<system>
(in preference of doing a print with the collected standard output).

Since Shell.pm and all of the aforementioned techniques use your system's
shell to call some local command, none of them is portable across different 
systems. Note, however, that there are several built in functions and 
library packages providing portable implementations of functions operating
on files, such as: C<glob>, C<link> and C<unlink>, C<mkdir> and C<rmdir>, 
C<rename>, C<File::Compare>, C<File::Copy>, C<File::Find> etc.

Using Shell.pm while importing C<foo> creates a subroutine C<foo> in the
namespace of the importing package. Calling C<foo> with arguments C<arg1>,
C<arg2>,... results in a shell command C<foo arg1 arg2...>, where the 
function name and the arguments are joined with a blank. (See the subsection 
on Escaping magic characters.) Since the result is essentially a command
line to be passed to the shell, your notion of arguments to the Perl
function is not necessarily identical to what the shell treats as a
command line token, to be passed as an individual argument to the program.
Furthermore, note that this implies that C<foo> is callable by file name
only, which frequently depends on the setting of the program's environment.

Creating a Shell object gives you the opportunity to call any command
in the usual OO notation without requiring you to announce it in the
C<use Shell> statement. Don't assume any additional semantics being
associated with a Shell object: in no way is it similar to a shell
process with its environment or current working directory or any
other setting.

=head2 Escaping Magic Characters

It is, in general, impossible to take care of quoting the shell's
magic characters. For some obscure reason, however, Shell.pm quotes
apostrophes (C<'>) and backslashes (C<\>) on UNIX, and spaces and
quotes (C<">) on Windows.

=head2 Configuration

If you set $Shell::capture_stderr to 1, the module will attempt to
capture the standard error output of the process as well. This is
done by adding C<2E<gt>&1> to the command line, so don't try this on
a system not supporting this redirection.

Setting $Shell::capture_stderr to -1 will send standard error to the
bit bucket (i.e., the equivalent of adding C<2E<gt>/dev/null> to the
command line).  The same caveat regarding redirection applies.

If you set $Shell::raw to true no quoting whatsoever is done.

=head1 BUGS

Quoting should be off by default.

It isn't possible to call shell built in commands, but it can be
done by using a workaround, e.g. shell( '-c', 'set' ).

Capturing standard error does not work on some systems (e.g. VMS).

=head1 AUTHOR

  Date: Thu, 22 Sep 94 16:18:16 -0700
  Message-Id: <9409222318.AA17072@@scalpel.netlabs.com>
  To: perl5-porters@@isu.edu
  From: Larry Wall <lwall@@scalpel.netlabs.com>
  Subject: a new module I just wrote

Here's one that'll whack your mind a little out.

    #!/usr/bin/perl

    use Shell;

    $foo = echo("howdy", "<funny>", "world");
    print $foo;

    $passwd = cat("</etc/passwd");
    print $passwd;

    sub ps;
    print ps -ww;

    cp("/etc/passwd", "/etc/passwd.orig");

That's maybe too gonzo.  It actually exports an AUTOLOAD to the current
package (and uncovered a bug in Beta 3, by the way).  Maybe the usual
usage should be

    use Shell qw(echo cat ps cp);

Larry Wall

Changes by Jenda@@Krynicky.cz and Dave Cottle <d.cottle@@csc.canterbury.ac.nz>.

Changes for OO syntax and bug fixes by Casey West <casey@@geeknest.com>.

C<$Shell::raw> and pod rewrite by Wolfgang Laun.

Rewritten to use closures rather than C<eval "string"> by Adriano Ferreira.

=cut
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.7
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d9 2
a10 1
$VERSION = '0.6';
d20 1
a20 1
	@@EXPORT = @@_;
d22 1
a22 1
	@@EXPORT = 'AUTOLOAD';
d30 20
a49 1
sub AUTOLOAD {
d51 1
a51 2
    my $cmd = $AUTOLOAD;
    $cmd =~ s/^.*:://;
d54 58
a111 58
    eval <<"*END*";
	sub $AUTOLOAD {
	    shift if ref \$_[0] && \$_[0]->isa( 'Shell' );
	    if (\@@_ < 1) {
		\$Shell::capture_stderr ==  1 ? `$cmd 2>&1` : 
		\$Shell::capture_stderr == -1 ? `$cmd 2>$null` : 
		`$cmd`;
	    } elsif ('$^O' eq 'os2') {
		local(\*SAVEOUT, \*READ, \*WRITE);

		open SAVEOUT, '>&STDOUT' or die;
		pipe READ, WRITE or die;
		open STDOUT, '>&WRITE' or die;
		close WRITE;

		my \$pid = system(1, '$cmd', \@@_);
		die "Can't execute $cmd: \$!\\n" if \$pid < 0;

		open STDOUT, '>&SAVEOUT' or die;
		close SAVEOUT;

		if (wantarray) {
		    my \@@ret = <READ>;
		    close READ;
		    waitpid \$pid, 0;
		    \@@ret;
		} else {
		    local(\$/) = undef;
		    my \$ret = <READ>;
		    close READ;
		    waitpid \$pid, 0;
		    \$ret;
		}
	    } else {
		my \$a;
		my \@@arr = \@@_;
		unless( \$Shell::raw ){
		  if ('$^O' eq 'MSWin32') {
		    # XXX this special-casing should not be needed
		    # if we do quoting right on Windows. :-(
		    #
		    # First, escape all quotes.  Cover the case where we
		    # want to pass along a quote preceded by a backslash
		    # (i.e., C<"param \\""" end">).
		    # Ugly, yup?  You know, windoze.
		    # Enclose in quotes only the parameters that need it:
		    #   try this: c:\> dir "/w"
		    #   and this: c:\> dir /w
		    for (\@@arr) {
			s/"/\\\\"/g;
			s/\\\\\\\\"/\\\\\\\\"""/g;
			\$_ = qq["\$_"] if /\\s/;
		    }
		  } else {
		    for (\@@arr) {
			s/(['\\\\])/\\\\\$1/g;
			\$_ = \$_;
 		    }
d113 18
a130 18
		}
		push \@@arr, '2>&1'        if \$Shell::capture_stderr ==  1;
		push \@@arr, '2>$null' if \$Shell::capture_stderr == -1;
		open(SUBPROC, join(' ', '$cmd', \@@arr, '|'))
		    or die "Can't exec $cmd: \$!\\n";
		if (wantarray) {
		    my \@@ret = <SUBPROC>;
		    close SUBPROC;	# XXX Oughta use a destructor.
		    \@@ret;
		} else {
		    local(\$/) = undef;
		    my \$ret = <SUBPROC>;
		    close SUBPROC;
		    \$ret;
		}
	    }
	}
*END*
d132 6
a137 1
    die "$@@\n" if $@@;
d209 1
a209 1
If you set $Shell::capture_stderr to true, the module will attempt to
d214 4
d267 2
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d5 1
a5 1
our($capture_stderr, $VERSION, $AUTOLOAD);
d7 3
a9 1
$VERSION = '0.5';
d33 2
d39 3
a41 1
		\$Shell::capture_stderr ? `$cmd 2>&1` : `$cmd`;
d71 2
a72 1
		if ('$^O' eq 'MSWin32') {
d88 1
a88 1
		} else {
d92 2
a93 1
		    }
d95 2
a96 1
		push \@@arr, '2>&1' if \$Shell::capture_stderr;
d127 8
a134 1
See below.
d138 65
d224 1
a224 1
    cp("/etc/passwd", "/tmp/passwd");
d232 1
a232 9
Larry


If you set $Shell::capture_stderr to 1, the module will attempt to
capture the STDERR of the process as well.

The module now should work on Win32.

 Jenda
d234 1
a234 36
There seemed to be a problem where all arguments to a shell command were
quoted before being executed.  As in the following example:

 cat('</etc/passwd');
 ls('*.pl');

really turned into:

 cat '</etc/passwd'
 ls '*.pl'

instead of:

  cat </etc/passwd
  ls *.pl

and of course, this is wrong.

I have fixed this bug, it was brought up by Wolfgang Laun [ID 20000326.008]

Casey

=head2 OBJECT ORIENTED SYNTAX

Shell now has an OO interface.  Good for namespace conservation 
and shell representation.

 use Shell;
 my $sh = Shell->new;
 print $sh->ls;

Casey

=head1 AUTHOR

Larry Wall
d236 1
a236 1
Changes by Jenda@@Krynicky.cz and Dave Cottle <d.cottle@@csc.canterbury.ac.nz>
d238 1
a238 1
Changes and bug fixes by Casey West <casey@@geeknest.com>
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d7 1
a7 1
$VERSION = '0.4';
d9 1
a9 1
sub new { bless \$VERSION, shift } # Nothing better to bless
d33 1
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 1
a2 1
use 5.005_64;
d7 1
a7 1
$VERSION = '0.3';
d199 1
a199 1
Changes and bug fixes by Casey Tweten <crt@@kiski.net>
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d3 3
a5 1
our($capture_stderr, $VERSION);
d7 4
a10 1
$VERSION = '0.2';
d18 1
a18 2
    }
    else {
d21 2
a22 1
    foreach $sym (@@EXPORT) {
d25 1
a25 1
};
d27 2
a28 1
AUTOLOAD {
d35 1
a35 2
	    }
	    elsif ('$^O' eq 'os2') {
d54 1
a54 2
		}
		else {
d61 1
a61 2
	    }
	    else {
d80 1
a80 2
		}
		else {
d83 1
a83 1
			\$_ = "'\$_'";
d93 1
a93 2
		}
		else {
d108 1
d160 33
d198 2
@


1.2
log
@perl 5.004_04
@
text
@d2 2
d5 1
a5 1
use Config;
d25 2
a26 2
    eval qq {
	*$AUTOLOAD = sub {
d28 1
a28 1
		`$cmd`;
d30 1
a30 1
	    elsif (\$Config{'archname'} eq 'os2') {
d38 2
a39 2
		my \$pid = system(1, \$cmd, \@@_);
		die "Can't execute $cmd: \$!\n" if \$pid < 0;
d59 28
a86 3
		open(SUBPROC, "-|")
			or exec '$cmd', \@@_
			or die "Can't exec $cmd: \$!\n";
d100 3
a102 1
    };
d151 7
d161 2
@


1.1
log
@Initial revision
@
text
@d24 1
a24 1
	sub $AUTOLOAD {
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d24 1
a24 1
	*$AUTOLOAD = sub {
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a1 2
use 5.005_64;
our($capture_stderr, $VERSION);
d3 1
a3 1
$VERSION = '0.2';
d23 2
a24 2
    eval <<"*END*";
	sub $AUTOLOAD {
d26 1
a26 1
		\$Shell::capture_stderr ? `$cmd 2>&1` : `$cmd`;
d28 1
a28 1
	    elsif ('$^O' eq 'os2') {
d36 2
a37 2
		my \$pid = system(1, '$cmd', \@@_);
		die "Can't execute $cmd: \$!\\n" if \$pid < 0;
d57 3
a59 28
		my \$a;
		my \@@arr = \@@_;
		if ('$^O' eq 'MSWin32') {
		    # XXX this special-casing should not be needed
		    # if we do quoting right on Windows. :-(
		    #
		    # First, escape all quotes.  Cover the case where we
		    # want to pass along a quote preceded by a backslash
		    # (i.e., C<"param \\""" end">).
		    # Ugly, yup?  You know, windoze.
		    # Enclose in quotes only the parameters that need it:
		    #   try this: c:\> dir "/w"
		    #   and this: c:\> dir /w
		    for (\@@arr) {
			s/"/\\\\"/g;
			s/\\\\\\\\"/\\\\\\\\"""/g;
			\$_ = qq["\$_"] if /\\s/;
		    }
		}
		else {
		    for (\@@arr) {
			s/(['\\\\])/\\\\\$1/g;
			\$_ = "'\$_'";
		    }
		}
		push \@@arr, '2>&1' if \$Shell::capture_stderr;
		open(SUBPROC, join(' ', '$cmd', \@@arr, '|'))
		    or die "Can't exec $cmd: \$!\\n";
d73 1
a73 3
*END*

    die "$@@\n" if $@@;
a121 7
If you set $Shell::capture_stderr to 1, the module will attempt to
capture the STDERR of the process as well.

The module now should work on Win32.

 Jenda

a124 2

Changes by Jenda@@Krynicky.cz and Dave Cottle <d.cottle@@csc.canterbury.ac.nz>
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d3 1
a3 3
use strict;
use warnings;
our($capture_stderr, $VERSION, $AUTOLOAD);
d5 1
a5 4
$VERSION = '0.3';

sub new { bless \$VERSION, shift } # Nothing better to bless
sub DESTROY { }
d13 2
a14 1
    } else {
d17 1
a17 2
    foreach my $sym (@@EXPORT) {
        no strict 'refs';
d20 1
a20 1
}
d22 1
a22 2
sub AUTOLOAD {
    shift if ref $_[0] && $_[0]->isa( 'Shell' );
d29 2
a30 1
	    } elsif ('$^O' eq 'os2') {
d49 2
a50 1
		} else {
d57 2
a58 1
	    } else {
d77 2
a78 1
		} else {
d81 1
a81 1
			\$_ = \$_;
d91 2
a92 1
		} else {
a106 1

a157 33
There seemed to be a problem where all arguments to a shell command were
quoted before being executed.  As in the following example:

 cat('</etc/passwd');
 ls('*.pl');

really turned into:

 cat '</etc/passwd'
 ls '*.pl'

instead of:

  cat </etc/passwd
  ls *.pl

and of course, this is wrong.

I have fixed this bug, it was brought up by Wolfgang Laun [ID 20000326.008]

Casey

=head2 OBJECT ORIENTED SYNTAX

Shell now has an OO interface.  Good for namespace conservation 
and shell representation.

 use Shell;
 my $sh = Shell->new;
 print $sh->ls;

Casey

a162 2

Changes and bug fixes by Casey Tweten <crt@@kiski.net>
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d2 1
a2 1
use 5.006_001;
d7 1
a7 1
$VERSION = '0.4';
d199 1
a199 1
Changes and bug fixes by Casey West <casey@@geeknest.com>
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d7 1
a7 1
$VERSION = '0.5';
d9 1
a9 1
sub new { bless \my $foo, shift }
a32 1
	    shift if ref \$_[0] && \$_[0]->isa( 'Shell' );
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d5 1
a5 1
use File::Spec::Functions;
d7 1
a7 3
our($capture_stderr, $raw, $VERSION, $AUTOLOAD);

$VERSION = '0.6';
a30 2
    my $null = File::Spec::Functions::devnull();
    $Shell::capture_stderr ||= 0;
d35 1
a35 3
		\$Shell::capture_stderr ==  1 ? `$cmd 2>&1` : 
		\$Shell::capture_stderr == -1 ? `$cmd 2>$null` : 
		`$cmd`;
d65 1
a65 2
		unless( \$Shell::raw ){
		  if ('$^O' eq 'MSWin32') {
d81 1
a81 1
		  } else {
d85 1
a85 2
 		    }
                  }
d87 1
a87 2
		push \@@arr, '2>&1'        if \$Shell::capture_stderr ==  1;
		push \@@arr, '2>$null' if \$Shell::capture_stderr == -1;
d118 1
a118 8
   use Shell qw(cat ps cp);
   $passwd = cat('</etc/passwd');
   @@pslines = ps('-ww'),
   cp("/etc/passwd", "/tmp/passwd");

   # object oriented 
   my $sh = Shell->new;
   print $sh->ls('-l');
a121 65
=head2 Caveats

This package is included as a show case, illustrating a few Perl features.
It shouldn't be used for production programs. Although it does provide a 
simple interface for obtaining the standard output of arbitrary commands,
there may be better ways of achieving what you need.

Running shell commands while obtaining standard output can be done with the
C<qx/STRING/> operator, or by calling C<open> with a filename expression that
ends with C<|>, giving you the option to process one line at a time.
If you don't need to process standard output at all, you might use C<system>
(in preference of doing a print with the collected standard output).

Since Shell.pm and all of the aforementioned techniques use your system's
shell to call some local command, none of them is portable across different 
systems. Note, however, that there are several built in functions and 
library packages providing portable implementations of functions operating
on files, such as: C<glob>, C<link> and C<unlink>, C<mkdir> and C<rmdir>, 
C<rename>, C<File::Compare>, C<File::Copy>, C<File::Find> etc.

Using Shell.pm while importing C<foo> creates a subroutine C<foo> in the
namespace of the importing package. Calling C<foo> with arguments C<arg1>,
C<arg2>,... results in a shell command C<foo arg1 arg2...>, where the 
function name and the arguments are joined with a blank. (See the subsection 
on Escaping magic characters.) Since the result is essentially a command
line to be passed to the shell, your notion of arguments to the Perl
function is not necessarily identical to what the shell treats as a
command line token, to be passed as an individual argument to the program.
Furthermore, note that this implies that C<foo> is callable by file name
only, which frequently depends on the setting of the program's environment.

Creating a Shell object gives you the opportunity to call any command
in the usual OO notation without requiring you to announce it in the
C<use Shell> statement. Don't assume any additional semantics being
associated with a Shell object: in no way is it similar to a shell
process with its environment or current working directory or any
other setting.

=head2 Escaping Magic Characters

It is, in general, impossible to take care of quoting the shell's
magic characters. For some obscure reason, however, Shell.pm quotes
apostrophes (C<'>) and backslashes (C<\>) on UNIX, and spaces and
quotes (C<">) on Windows.

=head2 Configuration

If you set $Shell::capture_stderr to true, the module will attempt to
capture the standard error output of the process as well. This is
done by adding C<2E<gt>&1> to the command line, so don't try this on
a system not supporting this redirection.

If you set $Shell::raw to true no quoting whatsoever is done.

=head1 BUGS

Quoting should be off by default.

It isn't possible to call shell built in commands, but it can be
done by using a workaround, e.g. shell( '-c', 'set' ).

Capturing standard error does not work on some systems (e.g. VMS).

=head1 AUTHOR

d143 1
a143 1
    cp("/etc/passwd", "/etc/passwd.orig");
d151 45
d198 1
a198 3
Changes by Jenda@@Krynicky.cz and Dave Cottle <d.cottle@@csc.canterbury.ac.nz>.

Changes for OO syntax and bug fixes by Casey West <casey@@geeknest.com>.
d200 1
a200 1
C<$Shell::raw> and pod rewrite by Wolfgang Laun.
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d9 1
a9 2
$VERSION = '0.72_01';
$VERSION = eval $VERSION;
d19 1
a19 1
        @@EXPORT = @@_;
d21 1
a21 1
        @@EXPORT = 'AUTOLOAD';
d29 1
a29 20
# NOTE: this is used to enable constant folding in 
# expressions like (OS eq 'MSWin32') and 
# (OS eq 'os2') just like it happened in  0.6  version 
# which used eval "string" to install subs on the fly.
use constant OS => $^O;

=begin private

=item B<_make_cmd>

  $sub = _make_cmd($cmd);
  $sub = $shell->_make_cmd($cmd);

Creates a closure which invokes the system command C<$cmd>.

=end private

=cut

sub _make_cmd {
d31 2
a32 1
    my $cmd = shift;
d35 58
a92 58
    # closing over $^O, $cmd, and $null
    return sub {
            shift if ref $_[0] && $_[0]->isa( 'Shell' );
            if (@@_ < 1) {
                $Shell::capture_stderr ==  1 ? `$cmd 2>&1` : 
                $Shell::capture_stderr == -1 ? `$cmd 2>$null` : 
                `$cmd`;
            } elsif (OS eq 'os2') {
                local(*SAVEOUT, *READ, *WRITE);

                open SAVEOUT, '>&STDOUT' or die;
                pipe READ, WRITE or die;
                open STDOUT, '>&WRITE' or die;
                close WRITE;

                my $pid = system(1, $cmd, @@_);
                die "Can't execute $cmd: $!\n" if $pid < 0;

                open STDOUT, '>&SAVEOUT' or die;
                close SAVEOUT;

                if (wantarray) {
                    my @@ret = <READ>;
                    close READ;
                    waitpid $pid, 0;
                    @@ret;
                } else {
                    local($/) = undef;
                    my $ret = <READ>;
                    close READ;
                    waitpid $pid, 0;
                    $ret;
                }
            } else {
                my $a;
                my @@arr = @@_;
                unless( $Shell::raw ){
                  if (OS eq 'MSWin32') {
                    # XXX this special-casing should not be needed
                    # if we do quoting right on Windows. :-(
                    #
                    # First, escape all quotes.  Cover the case where we
                    # want to pass along a quote preceded by a backslash
                    # (i.e., C<"param \""" end">).
                    # Ugly, yup?  You know, windoze.
                    # Enclose in quotes only the parameters that need it:
                    #   try this: c:> dir "/w"
                    #   and this: c:> dir /w
                    for (@@arr) {
                        s/"/\\"/g;
                        s/\\\\"/\\\\"""/g;
                        $_ = qq["$_"] if /\s/;
                    }
                  } else {
                    for (@@arr) {
                        s/(['\\])/\\$1/g;
                        $_ = $_;
                     }
d94 18
a111 18
                }
                push @@arr, '2>&1'        if $Shell::capture_stderr ==  1;
                push @@arr, '2>$null' if $Shell::capture_stderr == -1;
                open(SUBPROC, join(' ', $cmd, @@arr, '|'))
                    or die "Can't exec $cmd: $!\n";
                if (wantarray) {
                    my @@ret = <SUBPROC>;
                    close SUBPROC;        # XXX Oughta use a destructor.
                    @@ret;
                } else {
                    local($/) = undef;
                    my $ret = <SUBPROC>;
                    close SUBPROC;
                    $ret;
                }
            }
        };
        }
d113 1
a113 6
sub AUTOLOAD {
    shift if ref $_[0] && $_[0]->isa( 'Shell' );
    my $cmd = $AUTOLOAD;
    $cmd =~ s/^.*:://;
    no strict 'refs';
    *$AUTOLOAD = _make_cmd($cmd);
d185 1
a185 1
If you set $Shell::capture_stderr to 1, the module will attempt to
a189 4
Setting $Shell::capture_stderr to -1 will send standard error to the
bit bucket (i.e., the equivalent of adding C<2E<gt>/dev/null> to the
command line).  The same caveat regarding redirection applies.

a238 2

Rewritten to use closures rather than C<eval "string"> by Adriano Ferreira.
@


