head	1.8;
access;
symbols
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.6.0.32
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.28
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.6.0.30
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.26
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.6.0.24
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.22
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.20
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.18
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.16
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.6.0.14
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.12
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.10
	OPENBSD_3_7_BASE:1.6
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.6.0.8
	OPENBSD_3_6_BASE:1.6
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.6.0.6
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2013.03.25.20.40.55;	author sthen;	state dead;
branches;
next	1.7;

1.7
date	2010.09.24.15.06.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.24;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.08;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.56.50;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.31;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.31;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.19;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.48.35;	author millert;	state Exp;
branches;
next	;


desc
@@


1.8
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@package bigint;
#
# This library is no longer being maintained, and is included for backward
# compatibility with Perl 4 programs which may require it.
#
# In particular, this should not be used as an example of modern Perl
# programming techniques.
# This legacy library is deprecated and will be removed in a future
# release of perl.
#
# Suggested alternative:  Math::BigInt

# arbitrary size integer math package
#
# by Mark Biggar
#
# Canonical Big integer value are strings of the form
#       /^[+-]\d+$/ with leading zeros suppressed
# Input values to these routines may be strings of the form
#       /^\s*[+-]?[\d\s]+$/.
# Examples:
#   '+0'                            canonical zero value
#   '   -123 123 123'               canonical value '-123123123'
#   '1 23 456 7890'                 canonical value '+1234567890'
# Output values always in canonical form
#
# Actual math is done in an internal format consisting of an array
#   whose first element is the sign (/^[+-]$/) and whose remaining 
#   elements are base 100000 digits with the least significant digit first.
# The string 'NaN' is used to represent the result when input arguments 
#   are not numbers, as well as the result of dividing by zero
#
# routines provided are:
#
#   bneg(BINT) return BINT              negation
#   babs(BINT) return BINT              absolute value
#   bcmp(BINT,BINT) return CODE         compare numbers (undef,<0,=0,>0)
#   badd(BINT,BINT) return BINT         addition
#   bsub(BINT,BINT) return BINT         subtraction
#   bmul(BINT,BINT) return BINT         multiplication
#   bdiv(BINT,BINT) return (BINT,BINT)  division (quo,rem) just quo if scalar
#   bmod(BINT,BINT) return BINT         modulus
#   bgcd(BINT,BINT) return BINT         greatest common divisor
#   bnorm(BINT) return BINT             normalization
#

# overcome a floating point problem on certain osnames (posix-bc, os390)
BEGIN {
    my $x = 100000.0;
    my $use_mult = int($x*1e-5)*1e5 == $x ? 1 : 0;
}

$zero = 0;


# normalize string form of number.   Strip leading zeros.  Strip any
#   white space and add a sign, if missing.
# Strings that are not numbers result the value 'NaN'.

sub main'bnorm { #(num_str) return num_str
    local($_) = @@_;
    s/\s+//g;                           # strip white space
    if (s/^([+-]?)0*(\d+)$/$1$2/) {     # test if number
	substr($_,$[,0) = '+' unless $1; # Add missing sign
	s/^-0/+0/;
	$_;
    } else {
	'NaN';
    }
}

# Convert a number from string format to internal base 100000 format.
#   Assumes normalized value as input.
sub internal { #(num_str) return int_num_array
    local($d) = @@_;
    ($is,$il) = (substr($d,$[,1),length($d)-2);
    substr($d,$[,1) = '';
    ($is, reverse(unpack("a" . ($il%5+1) . ("a5" x ($il/5)), $d)));
}

# Convert a number from internal base 100000 format to string format.
#   This routine scribbles all over input array.
sub external { #(int_num_array) return num_str
    $es = shift;
    grep($_ > 9999 || ($_ = substr('0000'.$_,-5)), @@_);   # zero pad
    &'bnorm(join('', $es, reverse(@@_)));    # reverse concat and normalize
}

# Negate input value.
sub main'bneg { #(num_str) return num_str
    local($_) = &'bnorm(@@_);
    vec($_,0,8) ^= ord('+') ^ ord('-') unless $_ eq '+0';
    s/^./N/ unless /^[-+]/; # works both in ASCII and EBCDIC
    $_;
}

# Returns the absolute value of the input.
sub main'babs { #(num_str) return num_str
    &abs(&'bnorm(@@_));
}

sub abs { # post-normalized abs for internal use
    local($_) = @@_;
    s/^-/+/;
    $_;
}

# Compares 2 values.  Returns one of undef, <0, =0, >0. (suitable for sort)
sub main'bcmp { #(num_str, num_str) return cond_code
    local($x,$y) = (&'bnorm($_[$[]),&'bnorm($_[$[+1]));
    if ($x eq 'NaN') {
	undef;
    } elsif ($y eq 'NaN') {
	undef;
    } else {
	&cmp($x,$y);
    }
}

sub cmp { # post-normalized compare for internal use
    local($cx, $cy) = @@_;
    return 0 if ($cx eq $cy);

    local($sx, $sy) = (substr($cx, 0, 1), substr($cy, 0, 1));
    local($ld);

    if ($sx eq '+') {
      return  1 if ($sy eq '-' || $cy eq '+0');
      $ld = length($cx) - length($cy);
      return $ld if ($ld);
      return $cx cmp $cy;
    } else { # $sx eq '-'
      return -1 if ($sy eq '+');
      $ld = length($cy) - length($cx);
      return $ld if ($ld);
      return $cy cmp $cx;
    }

}

sub main'badd { #(num_str, num_str) return num_str
    local(*x, *y); ($x, $y) = (&'bnorm($_[$[]),&'bnorm($_[$[+1]));
    if ($x eq 'NaN') {
	'NaN';
    } elsif ($y eq 'NaN') {
	'NaN';
    } else {
	@@x = &internal($x);             # convert to internal form
	@@y = &internal($y);
	local($sx, $sy) = (shift @@x, shift @@y); # get signs
	if ($sx eq $sy) {
	    &external($sx, &add(*x, *y)); # if same sign add
	} else {
	    ($x, $y) = (&abs($x),&abs($y)); # make abs
	    if (&cmp($y,$x) > 0) {
		&external($sy, &sub(*y, *x));
	    } else {
		&external($sx, &sub(*x, *y));
	    }
	}
    }
}

sub main'bsub { #(num_str, num_str) return num_str
    &'badd($_[$[],&'bneg($_[$[+1]));    
}

# GCD -- Euclids algorithm Knuth Vol 2 pg 296
sub main'bgcd { #(num_str, num_str) return num_str
    local($x,$y) = (&'bnorm($_[$[]),&'bnorm($_[$[+1]));
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	($x, $y) = ($y,&'bmod($x,$y)) while $y ne '+0';
	$x;
    }
}

# routine to add two base 1e5 numbers
#   stolen from Knuth Vol 2 Algorithm A pg 231
#   there are separate routines to add and sub as per Kunth pg 233
sub add { #(int_num_array, int_num_array) return int_num_array
    local(*x, *y) = @@_;
    $car = 0;
    for $x (@@x) {
	last unless @@y || $car;
	$x -= 1e5 if $car = (($x += shift(@@y) + $car) >= 1e5) ? 1 : 0;
    }
    for $y (@@y) {
	last unless $car;
	$y -= 1e5 if $car = (($y += $car) >= 1e5) ? 1 : 0;
    }
    (@@x, @@y, $car);
}

# subtract base 1e5 numbers -- stolen from Knuth Vol 2 pg 232, $x > $y
sub sub { #(int_num_array, int_num_array) return int_num_array
    local(*sx, *sy) = @@_;
    $bar = 0;
    for $sx (@@sx) {
	last unless @@y || $bar;
	$sx += 1e5 if $bar = (($sx -= shift(@@sy) + $bar) < 0);
    }
    @@sx;
}

# multiply two numbers -- stolen from Knuth Vol 2 pg 233
sub main'bmul { #(num_str, num_str) return num_str
    local(*x, *y); ($x, $y) = (&'bnorm($_[$[]), &'bnorm($_[$[+1]));
    if ($x eq 'NaN') {
	'NaN';
    } elsif ($y eq 'NaN') {
	'NaN';
    } else {
	@@x = &internal($x);
	@@y = &internal($y);
	local($signr) = (shift @@x ne shift @@y) ? '-' : '+';
	@@prod = ();
	for $x (@@x) {
	    ($car, $cty) = (0, $[);
	    for $y (@@y) {
		$prod = $x * $y + $prod[$cty] + $car;
                if ($use_mult) {
		    $prod[$cty++] =
		        $prod - ($car = int($prod * 1e-5)) * 1e5;
                }
                else {
		    $prod[$cty++] =
		        $prod - ($car = int($prod / 1e5)) * 1e5;
                }
	    }
	    $prod[$cty] += $car if $car;
	    $x = shift @@prod;
	}
	&external($signr, @@x, @@prod);
    }
}

# modulus
sub main'bmod { #(num_str, num_str) return num_str
    (&'bdiv(@@_))[$[+1];
}

sub main'bdiv { #(dividend: num_str, divisor: num_str) return num_str
    local (*x, *y); ($x, $y) = (&'bnorm($_[$[]), &'bnorm($_[$[+1]));
    return wantarray ? ('NaN','NaN') : 'NaN'
	if ($x eq 'NaN' || $y eq 'NaN' || $y eq '+0');
    return wantarray ? ('+0',$x) : '+0' if (&cmp(&abs($x),&abs($y)) < 0);
    @@x = &internal($x); @@y = &internal($y);
    $srem = $y[$[];
    $sr = (shift @@x ne shift @@y) ? '-' : '+';
    $car = $bar = $prd = 0;
    if (($dd = int(1e5/($y[$#y]+1))) != 1) {
	for $x (@@x) {
	    $x = $x * $dd + $car;
            if ($use_mult) {
	    $x -= ($car = int($x * 1e-5)) * 1e5;
            }
            else {
	    $x -= ($car = int($x / 1e5)) * 1e5;
            }
	}
	push(@@x, $car); $car = 0;
	for $y (@@y) {
	    $y = $y * $dd + $car;
            if ($use_mult) {
	    $y -= ($car = int($y * 1e-5)) * 1e5;
            }
            else {
	    $y -= ($car = int($y / 1e5)) * 1e5;
            }
	}
    }
    else {
	push(@@x, 0);
    }
    @@q = (); ($v2,$v1) = @@y[-2,-1];
    while ($#x > $#y) {
	($u2,$u1,$u0) = @@x[-3..-1];
	$q = (($u0 == $v1) ? 99999 : int(($u0*1e5+$u1)/$v1));
	--$q while ($v2*$q > ($u0*1e5+$u1-$q*$v1)*1e5+$u2);
	if ($q) {
	    ($car, $bar) = (0,0);
	    for ($y = $[, $x = $#x-$#y+$[-1; $y <= $#y; ++$y,++$x) {
		$prd = $q * $y[$y] + $car;
                if ($use_mult) {
		$prd -= ($car = int($prd * 1e-5)) * 1e5;
                }
                else {
		$prd -= ($car = int($prd / 1e5)) * 1e5;
                }
		$x[$x] += 1e5 if ($bar = (($x[$x] -= $prd + $bar) < 0));
	    }
	    if ($x[$#x] < $car + $bar) {
		$car = 0; --$q;
		for ($y = $[, $x = $#x-$#y+$[-1; $y <= $#y; ++$y,++$x) {
		    $x[$x] -= 1e5
			if ($car = (($x[$x] += $y[$y] + $car) > 1e5));
		}
	    }   
	}
	pop(@@x); unshift(@@q, $q);
    }
    if (wantarray) {
	@@d = ();
	if ($dd != 1) {
	    $car = 0;
	    for $x (reverse @@x) {
		$prd = $car * 1e5 + $x;
		$car = $prd - ($tmp = int($prd / $dd)) * $dd;
		unshift(@@d, $tmp);
	    }
	}
	else {
	    @@d = @@x;
	}
	(&external($sr, @@q), &external($srem, @@d, $zero));
    } else {
	&external($sr, @@q);
    }
}
1;
@


1.7
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d8 2
d12 1
a12 1
#
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d23 1
a23 1
# Output values always always in canonical form
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d45 6
d221 8
a228 2
		$prod[$cty++] =
		    $prod - ($car = int($prod * 1e-5)) * 1e5;
d254 1
d256 4
d264 1
d266 4
d284 1
d286 4
@


1.3
log
@perl5.005_03 (stock)
@
text
@d2 9
a10 1

@


1.2
log
@perl 5.004_04
@
text
@d77 1
a77 1
    s/^H/N/;
@


1.1
log
@Initial revision
@
text
@d106 17
a122 7
    $cx cmp $cy
    &&
    (
	ord($cy) <=> ord($cx)
	||
	($cx cmp ',') * (length($cy) <=> length($cx) || $cy cmp $cx)
    );
d171 1
a171 1
	$x -= 1e5 if $car = (($x += shift(@@y) + $car) >= 1e5);
d175 1
a175 1
	$y -= 1e5 if $car = (($y += $car) >= 1e5);
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d77 1
a77 1
    s/^./N/ unless /^[-+]/; # works both in ASCII and EBCDIC
d106 7
a112 17
    return 0 if ($cx eq $cy);

    local($sx, $sy) = (substr($cx, 0, 1), substr($cy, 0, 1));
    local($ld);

    if ($sx eq '+') {
      return  1 if ($sy eq '-' || $cy eq '+0');
      $ld = length($cx) - length($cy);
      return $ld if ($ld);
      return $cx cmp $cy;
    } else { # $sx eq '-'
      return -1 if ($sy eq '+');
      $ld = length($cy) - length($cx);
      return $ld if ($ld);
      return $cy cmp $cx;
    }

d161 1
a161 1
	$x -= 1e5 if $car = (($x += shift(@@y) + $car) >= 1e5) ? 1 : 0;
d165 1
a165 1
	$y -= 1e5 if $car = (($y += $car) >= 1e5) ? 1 : 0;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d2 1
a2 9
#
# This library is no longer being maintained, and is included for backward
# compatibility with Perl 4 programs which may require it.
#
# In particular, this should not be used as an example of modern Perl
# programming techniques.
#
# Suggested alternative:  Math::BigInt
#
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a44 6
# overcome a floating point problem on certain osnames (posix-bc, os390)
BEGIN {
    my $x = 100000.0;
    my $use_mult = int($x*1e-5)*1e5 == $x ? 1 : 0;
}

d215 2
a216 8
                if ($use_mult) {
		    $prod[$cty++] =
		        $prod - ($car = int($prod * 1e-5)) * 1e5;
                }
                else {
		    $prod[$cty++] =
		        $prod - ($car = int($prod / 1e5)) * 1e5;
                }
a241 1
            if ($use_mult) {
a242 4
            }
            else {
	    $x -= ($car = int($x / 1e5)) * 1e5;
            }
a246 1
            if ($use_mult) {
a247 4
            }
            else {
	    $y -= ($car = int($y / 1e5)) * 1e5;
            }
a261 1
                if ($use_mult) {
a262 4
                }
                else {
		$prd -= ($car = int($prd / 1e5)) * 1e5;
                }
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d23 1
a23 1
# Output values always in canonical form
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@a7 2
# This legacy library is deprecated and will be removed in a future
# release of perl.
d10 1
a10 1

@


