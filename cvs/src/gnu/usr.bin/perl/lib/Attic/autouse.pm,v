head	1.8;
access;
symbols
	OPENBSD_4_8:1.7.0.8
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.4
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.8
date	2010.09.24.14.59.33;	author millert;	state dead;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.09.18.09.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.45;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.56.48;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2004.08.09.17.46.42;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.30;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.8
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package autouse;

#use strict;		# debugging only
use 5.006;		# use warnings

$autouse::VERSION = '1.06';

$autouse::DEBUG ||= 0;

sub vet_import ($);

sub croak {
    require Carp;
    Carp::croak(@@_);
}

sub import {
    my $class = @@_ ? shift : 'autouse';
    croak "usage: use $class MODULE [,SUBS...]" unless @@_;
    my $module = shift;

    (my $pm = $module) =~ s{::}{/}g;
    $pm .= '.pm';
    if (exists $INC{$pm}) {
	vet_import $module;
	local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
	# $Exporter::Verbose = 1;
	return $module->import(map { (my $f = $_) =~ s/\(.*?\)$//; $f } @@_);
    }

    # It is not loaded: need to do real work.
    my $callpkg = caller(0);
    print "autouse called from $callpkg\n" if $autouse::DEBUG;

    my $index;
    for my $f (@@_) {
	my $proto;
	$proto = $1 if (my $func = $f) =~ s/\((.*)\)$//;

	my $closure_import_func = $func;	# Full name
	my $closure_func = $func;		# Name inside package
	my $index = rindex($func, '::');
	if ($index == -1) {
	    $closure_import_func = "${callpkg}::$func";
	} else {
	    $closure_func = substr $func, $index + 2;
	    croak "autouse into different package attempted"
		unless substr($func, 0, $index) eq $module;
	}

	my $load_sub = sub {
	    unless ($INC{$pm}) {
		require $pm;
		vet_import $module;
	    }
            no warnings qw(redefine prototype);
	    *$closure_import_func = \&{"${module}::$closure_func"};
	    print "autousing $module; "
		  ."imported $closure_func as $closure_import_func\n"
		if $autouse::DEBUG;
	    goto &$closure_import_func;
	};

	if (defined $proto) {
	    *$closure_import_func = eval "sub ($proto) { goto &\$load_sub }"
	        || die;
	} else {
	    *$closure_import_func = $load_sub;
	}
    }
}

sub vet_import ($) {
    my $module = shift;
    if (my $import = $module->can('import')) {
	croak "autoused module $module has unique import() method"
	    unless defined(&Exporter::import)
		   && ($import == \&Exporter::import ||
		       $import == \&UNIVERSAL::import)
    }
}

1;

__END__

=head1 NAME

autouse - postpone load of modules until a function is used

=head1 SYNOPSIS

  use autouse 'Carp' => qw(carp croak);
  carp "this carp was predeclared and autoused ";

=head1 DESCRIPTION

If the module C<Module> is already loaded, then the declaration

  use autouse 'Module' => qw(func1 func2($;$));

is equivalent to

  use Module qw(func1 func2);

if C<Module> defines func2() with prototype C<($;$)>, and func1() has
no prototypes.  (At least if C<Module> uses C<Exporter>'s C<import>,
otherwise it is a fatal error.)

If the module C<Module> is not loaded yet, then the above declaration
declares functions func1() and func2() in the current package.  When
these functions are called, they load the package C<Module> if needed,
and substitute themselves with the correct definitions.

=begin _deprecated

   use Module qw(Module::func3);

will work and is the equivalent to:

   use Module qw(func3);

It is not a very useful feature and has been deprecated.

=end _deprecated


=head1 WARNING

Using C<autouse> will move important steps of your program's execution
from compile time to runtime.  This can

=over 4

=item *

Break the execution of your program if the module you C<autouse>d has
some initialization which it expects to be done early.

=item *

hide bugs in your code since important checks (like correctness of
prototypes) is moved from compile time to runtime.  In particular, if
the prototype you specified on C<autouse> line is wrong, you will not
find it out until the corresponding function is executed.  This will be
very unfortunate for functions which are not always called (note that
for such functions C<autouse>ing gives biggest win, for a workaround
see below).

=back

To alleviate the second problem (partially) it is advised to write
your scripts like this:

  use Module;
  use autouse Module => qw(carp($) croak(&$));
  carp "this carp was predeclared and autoused ";

The first line ensures that the errors in your argument specification
are found early.  When you ship your application you should comment
out the first line, since it makes the second one useless.

=head1 AUTHOR

Ilya Zakharevich (ilya@@math.ohio-state.edu)

=head1 SEE ALSO

perl(1).

=cut
@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.6
log
@merge in perl 5.8.8
@
text
@d4 1
a4 1
use 5.003_90;		# ->can, for my $var
d6 1
a6 1
$autouse::VERSION = '1.05';
d56 1
a56 1
            no warnings 'redefine';
d76 1
a76 1
	croak "autoused module has unique import() method"
d78 2
a79 1
		   && $import == \&Exporter::import;
@


1.5
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d6 1
a6 1
$autouse::VERSION = '1.04';
d53 1
a53 2
		eval {require $pm};
		die if $@@;
d65 2
a66 1
	    *$closure_import_func = eval "sub ($proto) { &\$load_sub }";
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d6 1
a6 1
$autouse::VERSION = '1.03';
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d6 1
a6 1
$autouse::VERSION = '1.02';
d42 1
a42 1
	my $index = index($func, '::');
d57 1
d99 1
a99 1
  use autouse 'Module' => qw(func1 func2($;$) Module::func3);
d105 3
a107 3
if C<Module> defines func2() with prototype C<($;$)>, and func1() and
func3() have no prototypes.  (At least if C<Module> uses C<Exporter>'s
C<import>, otherwise it is a fatal error.)
d110 16
a125 4
declares functions func1() and func2() in the current package, and
declares a function Module::func3().  When these functions are called,
they load the package C<Module> if needed, and substitute themselves
with the correct definitions.
d132 1
a132 1
=over
@


1.2
log
@perl5.005_03 (stock)
@
text
@d6 1
a6 1
$autouse::VERSION = '1.01';
d28 1
a28 1
	return $module->import(map { (my $f = $_) =~ s/\(.*?\)$// } @@_);
@


1.1
log
@perl 5.004_04
@
text
@a148 9
=head1 BUGS

If Module::func3() is autoused, and the module is loaded between the
C<autouse> directive and a call to Module::func3(), warnings about
redefinition would appear if warnings are enabled.

If Module::func3() is autoused, warnings are disabled when loading the
module via autoused functions.

@


1.1.1.1
log
@perl5.005_03
@
text
@d149 9
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d6 1
a6 1
$autouse::VERSION = '1.02';
d28 1
a28 1
	return $module->import(map { (my $f = $_) =~ s/\(.*?\)$//; $f } @@_);
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d6 1
a6 1
$autouse::VERSION = '1.03';
d42 1
a42 1
	my $index = rindex($func, '::');
a56 1
            no warnings 'redefine';
d98 1
a98 1
  use autouse 'Module' => qw(func1 func2($;$));
d104 3
a106 3
if C<Module> defines func2() with prototype C<($;$)>, and func1() has
no prototypes.  (At least if C<Module> uses C<Exporter>'s C<import>,
otherwise it is a fatal error.)
d109 4
a112 16
declares functions func1() and func2() in the current package.  When
these functions are called, they load the package C<Module> if needed,
and substitute themselves with the correct definitions.

=begin _deprecated

   use Module qw(Module::func3);

will work and is the equivalent to:

   use Module qw(func3);

It is not a very useful feature and has been deprecated.

=end _deprecated

d119 1
a119 1
=over 4
@


1.1.1.4
log
@Import of stock perl 5.8.5
@
text
@d6 1
a6 1
$autouse::VERSION = '1.04';
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d6 1
a6 1
$autouse::VERSION = '1.05';
d53 2
a54 1
		require $pm;
d66 1
a66 2
	    *$closure_import_func = eval "sub ($proto) { goto &\$load_sub }"
	        || die;
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d4 1
a4 1
use 5.006;		# use warnings
d6 1
a6 1
$autouse::VERSION = '1.06';
d56 1
a56 1
            no warnings qw(redefine prototype);
d76 1
a76 1
	croak "autoused module $module has unique import() method"
d78 1
a78 2
		   && ($import == \&Exporter::import ||
		       $import == \&UNIVERSAL::import)
@


