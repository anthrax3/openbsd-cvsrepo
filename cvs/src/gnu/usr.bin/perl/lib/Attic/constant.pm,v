head	1.8;
access;
symbols
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.4.0.14
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.12
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.10
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.4.0.8
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.4.0.6
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.4.0.4
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.2
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;


1.8
date	2010.09.24.14.59.33;	author millert;	state dead;
branches;
next	1.7;

1.7
date	2009.10.12.18.24.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2008.09.29.17.36.09;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.09;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.46;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.56.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.50;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.48.33;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.48;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.8
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package constant;
use 5.005;
use strict;
use warnings::register;

use vars qw($VERSION %declared);
$VERSION = '1.17';

#=======================================================================

# Some names are evil choices.
my %keywords = map +($_, 1), qw{ BEGIN INIT CHECK END DESTROY AUTOLOAD };
$keywords{UNITCHECK}++ if $] > 5.009;

my %forced_into_main = map +($_, 1),
    qw{ STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG };

my %forbidden = (%keywords, %forced_into_main);

#=======================================================================
# import() - import symbols into user's namespace
#
# What we actually do is define a function in the caller's namespace
# which returns the value. The function we create will normally
# be inlined as a constant, thereby avoiding further sub calling 
# overhead.
#=======================================================================
sub import {
    my $class = shift;
    return unless @@_;			# Ignore 'use constant;'
    my $constants;
    my $multiple  = ref $_[0];
    my $pkg = caller;
    my $symtab;
    my $str_end = $] >= 5.006 ? "\\z" : "\\Z";

    if ($] > 5.009002) {
	no strict 'refs';
	$symtab = \%{$pkg . '::'};
    };

    if ( $multiple ) {
	if (ref $_[0] ne 'HASH') {
	    require Carp;
	    Carp::croak("Invalid reference type '".ref(shift)."' not 'HASH'");
	}
	$constants = shift;
    } else {
	$constants->{+shift} = undef;
    }

    foreach my $name ( keys %$constants ) {
	unless (defined $name) {
	    require Carp;
	    Carp::croak("Can't use undef as constant name");
	}

	# Normal constant name
	if ($name =~ /^_?[^\W_0-9]\w*$str_end/ and !$forbidden{$name}) {
	    # Everything is okay

	# Name forced into main, but we're not in main. Fatal.
	} elsif ($forced_into_main{$name} and $pkg ne 'main') {
	    require Carp;
	    Carp::croak("Constant name '$name' is forced into main::");

	# Starts with double underscore. Fatal.
	} elsif ($name =~ /^__/) {
	    require Carp;
	    Carp::croak("Constant name '$name' begins with '__'");

	# Maybe the name is tolerable
	} elsif ($name =~ /^[A-Za-z_]\w*$str_end/) {
	    # Then we'll warn only if you've asked for warnings
	    if (warnings::enabled()) {
		if ($keywords{$name}) {
		    warnings::warn("Constant name '$name' is a Perl keyword");
		} elsif ($forced_into_main{$name}) {
		    warnings::warn("Constant name '$name' is " .
			"forced into package main::");
		}
	    }

	# Looks like a boolean
	# use constant FRED == fred;
	} elsif ($name =~ /^[01]?$str_end/) {
            require Carp;
	    if (@@_) {
		Carp::croak("Constant name '$name' is invalid");
	    } else {
		Carp::croak("Constant name looks like boolean value");
	    }

	} else {
	   # Must have bad characters
            require Carp;
	    Carp::croak("Constant name '$name' has invalid characters");
	}

	{
	    no strict 'refs';
	    my $full_name = "${pkg}::$name";
	    $declared{$full_name}++;
	    if ($multiple || @@_ == 1) {
		my $scalar = $multiple ? $constants->{$name} : $_[0];
		if ($symtab && !exists $symtab->{$name}) {
		    # No typeglob yet, so we can use a reference as space-
		    # efficient proxy for a constant subroutine
		    # The check in Perl_ck_rvconst knows that inlinable
		    # constants from cv_const_sv are read only. So we have to:
		    Internals::SvREADONLY($scalar, 1);
		    $symtab->{$name} = \$scalar;
		    mro::method_changed_in($pkg);
		} else {
		    *$full_name = sub () { $scalar };
		}
	    } elsif (@@_) {
		my @@list = @@_;
		*$full_name = sub () { @@list };
	    } else {
		*$full_name = sub () { };
	    }
	}
    }
}

1;

__END__

=head1 NAME

constant - Perl pragma to declare constants

=head1 SYNOPSIS

    use constant PI    => 4 * atan2(1, 1);
    use constant DEBUG => 0;

    print "Pi equals ", PI, "...\n" if DEBUG;

    use constant {
        SEC   => 0,
        MIN   => 1,
        HOUR  => 2,
        MDAY  => 3,
        MON   => 4,
        YEAR  => 5,
        WDAY  => 6,
        YDAY  => 7,
        ISDST => 8,
    };

    use constant WEEKDAYS => qw(
        Sunday Monday Tuesday Wednesday Thursday Friday Saturday
    );

    print "Today is ", (WEEKDAYS)[ (localtime)[WDAY] ], ".\n";

=head1 DESCRIPTION

This pragma allows you to declare constants at compile-time.

When you declare a constant such as C<PI> using the method shown
above, each machine your script runs upon can have as many digits
of accuracy as it can use. Also, your program will be easier to
read, more likely to be maintained (and maintained correctly), and
far less likely to send a space probe to the wrong planet because
nobody noticed the one equation in which you wrote C<3.14195>.

When a constant is used in an expression, Perl replaces it with its
value at compile time, and may then optimize the expression further.
In particular, any code in an C<if (CONSTANT)> block will be optimized
away if the constant is false.

=head1 NOTES

As with all C<use> directives, defining a constant happens at
compile time. Thus, it's probably not correct to put a constant
declaration inside of a conditional statement (like C<if ($foo)
{ use constant ... }>).

Constants defined using this module cannot be interpolated into
strings like variables.  However, concatenation works just fine:

    print "Pi equals PI...\n";        # WRONG: does not expand "PI"
    print "Pi equals ".PI."...\n";    # right

Even though a reference may be declared as a constant, the reference may
point to data which may be changed, as this code shows.

    use constant ARRAY => [ 1,2,3,4 ];
    print ARRAY->[1];
    ARRAY->[1] = " be changed";
    print ARRAY->[1];

Dereferencing constant references incorrectly (such as using an array
subscript on a constant hash reference, or vice versa) will be trapped at
compile time.

Constants belong to the package they are defined in.  To refer to a
constant defined in another package, specify the full package name, as
in C<Some::Package::CONSTANT>.  Constants may be exported by modules,
and may also be called as either class or instance methods, that is,
as C<< Some::Package->CONSTANT >> or as C<< $obj->CONSTANT >> where
C<$obj> is an instance of C<Some::Package>.  Subclasses may define
their own constants to override those in their base class.

The use of all caps for constant names is merely a convention,
although it is recommended in order to make constants stand out
and to help avoid collisions with other barewords, keywords, and
subroutine names. Constant names must begin with a letter or
underscore. Names beginning with a double underscore are reserved. Some
poor choices for names will generate warnings, if warnings are enabled at
compile time.

=head2 List constants

Constants may be lists of more (or less) than one value.  A constant
with no values evaluates to C<undef> in scalar context.  Note that
constants with more than one value do I<not> return their last value in
scalar context as one might expect.  They currently return the number
of values, but B<this may change in the future>.  Do not use constants
with multiple values in scalar context.

B<NOTE:> This implies that the expression defining the value of a
constant is evaluated in list context.  This may produce surprises:

    use constant TIMESTAMP => localtime;                # WRONG!
    use constant TIMESTAMP => scalar localtime;         # right

The first line above defines C<TIMESTAMP> as a 9-element list, as
returned by C<localtime()> in list context.  To set it to the string
returned by C<localtime()> in scalar context, an explicit C<scalar>
keyword is required.

List constants are lists, not arrays.  To index or slice them, they
must be placed in parentheses.

    my @@workdays = WEEKDAYS[1 .. 5];            # WRONG!
    my @@workdays = (WEEKDAYS)[1 .. 5];          # right

=head2 Defining multiple constants at once

Instead of writing multiple C<use constant> statements, you may define
multiple constants in a single statement by giving, instead of the
constant name, a reference to a hash where the keys are the names of
the constants to be defined.  Obviously, all constants defined using
this method must have a single value.

    use constant {
        FOO => "A single value",
        BAR => "This", "won't", "work!",        # Error!
    };

This is a fundamental limitation of the way hashes are constructed in
Perl.  The error messages produced when this happens will often be
quite cryptic -- in the worst case there may be none at all, and
you'll only later find that something is broken.

When defining multiple constants, you cannot use the values of other
constants defined in the same declaration.  This is because the
calling package doesn't know about any constant within that group
until I<after> the C<use> statement is finished.

    use constant {
        BITMASK => 0xAFBAEBA8,
        NEGMASK => ~BITMASK,                    # Error!
    };

=head2 Magic constants

Magical values and references can be made into constants at compile
time, allowing for way cool stuff like this.  (These error numbers
aren't totally portable, alas.)

    use constant E2BIG => ($! = 7);
    print   E2BIG, "\n";        # something like "Arg list too long"
    print 0+E2BIG, "\n";        # "7"

You can't produce a tied constant by giving a tied scalar as the
value.  References to tied variables, however, can be used as
constants without any problems.

=head1 TECHNICAL NOTES

In the current implementation, scalar constants are actually
inlinable subroutines. As of version 5.004 of Perl, the appropriate
scalar constant is inserted directly in place of some subroutine
calls, thereby saving the overhead of a subroutine call. See
L<perlsub/"Constant Functions"> for details about how and when this
happens.

In the rare case in which you need to discover at run time whether a
particular constant has been declared via this module, you may use
this function to examine the hash C<%constant::declared>. If the given
constant name does not include a package name, the current package is
used.

    sub declared ($) {
        use constant 1.01;              # don't omit this!
        my $name = shift;
        $name =~ s/^::/main::/;
        my $pkg = caller;
        my $full_name = $name =~ /::/ ? $name : "${pkg}::$name";
        $constant::declared{$full_name};
    }

=head1 CAVEATS

In the current version of Perl, list constants are not inlined
and some symbols may be redefined without generating a warning.

It is not possible to have a subroutine or a keyword with the same
name as a constant in the same package. This is probably a Good Thing.

A constant with a name in the list C<STDIN STDOUT STDERR ARGV ARGVOUT
ENV INC SIG> is not allowed anywhere but in package C<main::>, for
technical reasons. 

Unlike constants in some languages, these cannot be overridden
on the command line or via environment variables.

You can get into trouble if you use constants in a context which
automatically quotes barewords (as is true for any subroutine call).
For example, you can't say C<$hash{CONSTANT}> because C<CONSTANT> will
be interpreted as a string.  Use C<$hash{CONSTANT()}> or
C<$hash{+CONSTANT}> to prevent the bareword quoting mechanism from
kicking in.  Similarly, since the C<< => >> operator quotes a bareword
immediately to its left, you have to say C<< CONSTANT() => 'value' >>
(or simply use a comma in place of the big arrow) instead of
C<< CONSTANT => 'value' >>.

=head1 SEE ALSO

L<Readonly> - Facility for creating read-only scalars, arrays, hashes.

L<Const> - Facility for creating read-only variables. Similar to C<Readonly>,
but uses C<SvREADONLY> instead of C<tie>.

L<Attribute::Constant> - Make read-only variables via attribute

L<Scalar::Readonly> - Perl extension to the C<SvREADONLY> scalar flag

L<Hash::Util> - A selection of general-utility hash subroutines (mostly
to lock/unlock keys and values)

=head1 BUGS

Please report any bugs or feature requests via the perlbug(1) utility.

=head1 AUTHORS

Tom Phoenix, E<lt>F<rootbeer@@redcat.com>E<gt>, with help from
many other folks.

Multiple constant declarations at once added by Casey West,
E<lt>F<casey@@geeknest.com>E<gt>.

Documentation mostly rewritten by Ilmari Karonen,
E<lt>F<perl@@itz.pp.sci.fi>E<gt>.

This program is maintained by the Perl 5 Porters. 
The CPAN distribution is maintained by SE<eacute>bastien Aperghis-Tramoni
E<lt>F<sebastien@@aperghis.net>E<gt>.

=head1 COPYRIGHT & LICENSE

Copyright (C) 1997, 1999 Tom Phoenix

This module is free software; you can redistribute it or modify it
under the same terms as Perl itself.

=cut
@


1.7
log
@Merge in perl 5.10.1
@
text
@@


1.6
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d7 1
a7 1
$VERSION = '1.13';
d171 1
a171 1
When a constant is used in an expression, perl replaces it with its
d334 14
d367 1
a367 1
=head1 COPYRIGHT
@


1.5
log
@merge in perl 5.8.8
@
text
@d2 1
a2 1

a3 1
use 5.006_00;
d6 2
a7 2
our($VERSION, %declared);
$VERSION = '1.05';
d13 1
d31 1
a31 1
    my %constants = ();
d33 8
d47 1
a47 1
	%constants = %{+shift};
d49 1
a49 1
	$constants{+shift} = undef;
d52 1
a52 1
    foreach my $name ( keys %constants ) {
a56 1
	my $pkg = caller;
d59 1
a59 1
	if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
d73 1
a73 1
	} elsif ($name =~ /^[A-Za-z_]\w*\z/) {
d86 1
a86 1
	} elsif ($name =~ /^[01]?\z/) {
d104 11
a114 6
	    if ($multiple) {
		my $scalar = $constants{$name};
		*$full_name = sub () { $scalar };
	    } else {
		if (@@_ == 1) {
		    my $scalar = $_[0];
a115 5
		} elsif (@@_) {
		    my @@list = @@_;
		    *$full_name = sub () { @@list };
		} else {
		    *$full_name = sub () { };
d117 5
d162 1
a162 1
This will declare a symbol to be a constant with the given value.
d233 2
a234 2
returned by localtime() in list context.  To set it to the string
returned by localtime() in scalar context, an explicit C<scalar>
d309 1
a309 1
=head1 BUGS
d334 5
a338 1
=head1 AUTHOR
d348 4
@


1.4
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d8 1
a8 1
$VERSION = '1.04';
a73 5
		} else {
		    # Catch-all - what did I miss? If you get this error,
		    # please let me know what your constant's name was.
		    # Write to <rootbeer@@redcat.com>. Thanks!
		    warnings::warn("Constant name '$name' has unknown problems");
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d4 1
a4 1
use 5.005_64;
d8 1
a8 1
$VERSION = '1.02';
d31 11
a41 4
    my $name = shift;
    unless (defined $name) {
        require Carp;
	Carp::croak("Can't use undef as constant name");
a42 1
    my $pkg = caller;
d44 44
a87 23
    # Normal constant name
    if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
        # Everything is okay

    # Name forced into main, but we're not in main. Fatal.
    } elsif ($forced_into_main{$name} and $pkg ne 'main') {
	require Carp;
	Carp::croak("Constant name '$name' is forced into main::");

    # Starts with double underscore. Fatal.
    } elsif ($name =~ /^__/) {
	require Carp;
	Carp::croak("Constant name '$name' begins with '__'");

    # Maybe the name is tolerable
    } elsif ($name =~ /^[A-Za-z_]\w*\z/) {
	# Then we'll warn only if you've asked for warnings
	if (warnings::enabled()) {
	    if ($keywords{$name}) {
		warnings::warn("Constant name '$name' is a Perl keyword");
	    } elsif ($forced_into_main{$name}) {
		warnings::warn("Constant name '$name' is " .
		    "forced into package main::");
d89 1
a89 4
		# Catch-all - what did I miss? If you get this error,
		# please let me know what your constant's name was.
		# Write to <rootbeer@@redcat.com>. Thanks!
		warnings::warn("Constant name '$name' has unknown problems");
a90 1
	}
a91 6
    # Looks like a boolean
    # 		use constant FRED == fred;
    } elsif ($name =~ /^[01]?\z/) {
        require Carp;
	if (@@_) {
	    Carp::croak("Constant name '$name' is invalid");
d93 3
a95 1
	    Carp::croak("Constant name looks like boolean value");
d98 18
a115 18
    } else {
	# Must have bad characters
        require Carp;
	Carp::croak("Constant name '$name' has invalid characters");
    }

    {
	no strict 'refs';
	my $full_name = "${pkg}::$name";
	$declared{$full_name}++;
	if (@@_ == 1) {
	    my $scalar = $_[0];
	    *$full_name = sub () { $scalar };
	} elsif (@@_) {
	    my @@list = @@_;
	    *$full_name = sub () { @@list };
	} else {
	    *$full_name = sub () { };
a117 1

d130 22
a151 23
    use constant BUFFER_SIZE	=> 4096;
    use constant ONE_YEAR	=> 365.2425 * 24 * 60 * 60;
    use constant PI		=> 4 * atan2 1, 1;
    use constant DEBUGGING	=> 0;
    use constant ORACLE		=> 'oracle@@cs.indiana.edu';
    use constant USERNAME	=> scalar getpwuid($<);
    use constant USERINFO	=> getpwuid($<);

    sub deg2rad { PI * $_[0] / 180 }

    print "This line does nothing"		unless DEBUGGING;

    # references can be constants
    use constant CHASH		=> { foo => 42 };
    use constant CARRAY		=> [ 1,2,3,4 ];
    use constant CPSEUDOHASH	=> [ { foo => 1}, 42 ];
    use constant CCODE		=> sub { "bite $_[0]\n" };

    print CHASH->{foo};
    print CARRAY->[$i];
    print CPSEUDOHASH->{foo};
    print CCODE->("me");
    print CHASH->[10];			# compile-time error
d155 1
a155 2
This will declare a symbol to be a constant with the given scalar
or list value.
d164 5
d171 4
a174 2
The value or values are evaluated in a list context. You may override
this with C<scalar> as shown above.
d176 2
a177 3
These constants do not directly interpolate into double-quotish
strings, although you may do so indirectly. (See L<perlref> for
details about how this works.)
d179 2
a180 1
    print "The value of PI is @@{[ PI ]}.\n";
d182 11
a192 1
List constants are returned as lists, not as arrays.
d194 7
a200 2
    $homedir = USERINFO[7];		# WRONG
    $homedir = (USERINFO)[7];		# Right
d210 1
a210 3
Constant symbols are package scoped (rather than block scoped, as
C<use strict> is). That is, you can refer to a constant from package
Other as C<Other::CONST>.
d212 61
a272 4
As with all C<use> directives, defining a constant happens at
compile time. Thus, it's probably not correct to put a constant
declaration inside of a conditional statement (like C<if ($foo)
{ use constant ... }>).
d274 3
a276 19
Omitting the value for a symbol gives it the value of C<undef> in
a scalar context or the empty list, C<()>, in a list context. This
isn't so nice as it may sound, though, because in this case you
must either quote the symbol name, or use a big arrow, (C<=E<gt>>),
with nothing to point to. It is probably best to declare these
explicitly.

    use constant UNICORNS	=> ();
    use constant LOGFILE	=> undef;

The result from evaluating a list constant in a scalar context is
not documented, and is B<not> guaranteed to be any particular value
in the future. In particular, you should not rely upon it being
the number of elements in the list, especially since it is not
B<necessarily> that value in the current implementation.

Magical values, tied values, and references can be made into
constants at compile time, allowing for way cool stuff like this.
(These error numbers aren't totally portable, alas.)
d278 1
a278 3
    use constant E2BIG => ($! = 7);
    print   E2BIG, "\n";	# something like "Arg list too long"
    print 0+E2BIG, "\n";	# "7"
d280 6
a285 3
Dereferencing constant references incorrectly (such as using an array
subscript on a constant hash reference, or vice versa) will be trapped at
compile time.
d294 6
a299 6
	use constant 1.01;		# don't omit this!
	my $name = shift;
	$name =~ s/^::/main::/;
	my $pkg = caller;
	my $full_name = $name =~ /::/ ? $name : "${pkg}::$name";
	$constant::declared{$full_name};
a301 9
=head1 TECHNICAL NOTE

In the current implementation, scalar constants are actually
inlinable subroutines. As of version 5.004 of Perl, the appropriate
scalar constant is inserted directly in place of some subroutine
calls, thereby saving the overhead of a subroutine call. See
L<perlsub/"Constant Functions"> for details about how and when this
happens.

d307 1
a307 1
It is not possible to have a subroutine or keyword with the same
a313 8
Even though a reference may be declared as a constant, the reference may
point to data which may be changed, as this code shows.

    use constant CARRAY		=> [ 1,2,3,4 ];
    print CARRAY->[1];
    CARRAY->[1] = " be changed";
    print CARRAY->[1];

d322 2
a323 2
kicking in.  Similarly, since the C<=E<gt>> operator quotes a bareword
immediately to its left, you have to say C<CONSTANT() =E<gt> 'value'>
d325 1
a325 1
C<CONSTANT =E<gt> 'value'>.
d331 6
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 102
a104 1
$VERSION = '1.00';
d124 1
a124 1
    # references can be declared constant
d134 1
a134 1
    print CHASH->[10];				# compile-time error
d167 4
a170 1
subroutine names. Constant names must begin with a letter.
d205 18
a222 1
Errors in dereferencing constant references are trapped at compile-time.
d239 13
a251 1
name as a constant. This is probably a Good Thing.
d262 3
a264 2
immediately to its left you have to say C<CONSTANT() =E<gt> 'value'>
instead of C<CONSTANT =E<gt> 'value'>.
d268 1
a268 1
Tom Phoenix, E<lt>F<rootbeer@@teleport.com>E<gt>, with help from
d273 1
a273 1
Copyright (C) 1997, Tom Phoenix
a278 42

use strict;
use Carp;
use vars qw($VERSION);

#=======================================================================

# Some of this stuff didn't work in version 5.003, alas.
require 5.003_96;

#=======================================================================
# import() - import symbols into user's namespace
#
# What we actually do is define a function in the caller's namespace
# which returns the value. The function we create will normally
# be inlined as a constant, thereby avoiding further sub calling 
# overhead.
#=======================================================================
sub import {
    my $class = shift;
    my $name = shift or return;			# Ignore 'use constant;'
    croak qq{Can't define "$name" as constant} .
	    qq{ (name contains invalid characters or is empty)}
	unless $name =~ /^[^\W_0-9]\w*$/;

    my $pkg = caller;
    {
	no strict 'refs';
	if (@@_ == 1) {
	    my $scalar = $_[0];
	    *{"${pkg}::$name"} = sub () { $scalar };
	} elsif (@@_) {
	    my @@list = @@_;
	    *{"${pkg}::$name"} = sub () { @@list };
	} else {
	    *{"${pkg}::$name"} = sub () { };
	}
    }

}

1;
@


1.1
log
@perl 5.004_04
@
text
@d23 12
d101 2
d122 9
@


1.1.1.1
log
@perl5.005_03
@
text
@a22 12
    # references can be declared constant
    use constant CHASH		=> { foo => 42 };
    use constant CARRAY		=> [ 1,2,3,4 ];
    use constant CPSEUDOHASH	=> [ { foo => 1}, 42 ];
    use constant CCODE		=> sub { "bite $_[0]\n" };

    print CHASH->{foo};
    print CARRAY->[$i];
    print CPSEUDOHASH->{foo};
    print CCODE->("me");
    print CHASH->[10];				# compile-time error

a88 2
Errors in dereferencing constant references are trapped at compile-time.

a107 9

You can get into trouble if you use constants in a context which
automatically quotes barewords (as is true for any subroutine call).
For example, you can't say C<$hash{CONSTANT}> because C<CONSTANT> will
be interpreted as a string.  Use C<$hash{CONSTANT()}> or
C<$hash{+CONSTANT}> to prevent the bareword quoting mechanism from
kicking in.  Similarly, since the C<=E<gt>> operator quotes a bareword
immediately to its left you have to say C<CONSTANT() =E<gt> 'value'>
instead of C<CONSTANT =E<gt> 'value'>.
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 1
a3 102
use strict;
use 5.005_64;
use warnings::register;

our($VERSION, %declared);
$VERSION = '1.02';

#=======================================================================

# Some names are evil choices.
my %keywords = map +($_, 1), qw{ BEGIN INIT CHECK END DESTROY AUTOLOAD };

my %forced_into_main = map +($_, 1),
    qw{ STDIN STDOUT STDERR ARGV ARGVOUT ENV INC SIG };

my %forbidden = (%keywords, %forced_into_main);

#=======================================================================
# import() - import symbols into user's namespace
#
# What we actually do is define a function in the caller's namespace
# which returns the value. The function we create will normally
# be inlined as a constant, thereby avoiding further sub calling 
# overhead.
#=======================================================================
sub import {
    my $class = shift;
    return unless @@_;			# Ignore 'use constant;'
    my $name = shift;
    unless (defined $name) {
        require Carp;
	Carp::croak("Can't use undef as constant name");
    }
    my $pkg = caller;

    # Normal constant name
    if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
        # Everything is okay

    # Name forced into main, but we're not in main. Fatal.
    } elsif ($forced_into_main{$name} and $pkg ne 'main') {
	require Carp;
	Carp::croak("Constant name '$name' is forced into main::");

    # Starts with double underscore. Fatal.
    } elsif ($name =~ /^__/) {
	require Carp;
	Carp::croak("Constant name '$name' begins with '__'");

    # Maybe the name is tolerable
    } elsif ($name =~ /^[A-Za-z_]\w*\z/) {
	# Then we'll warn only if you've asked for warnings
	if (warnings::enabled()) {
	    if ($keywords{$name}) {
		warnings::warn("Constant name '$name' is a Perl keyword");
	    } elsif ($forced_into_main{$name}) {
		warnings::warn("Constant name '$name' is " .
		    "forced into package main::");
	    } else {
		# Catch-all - what did I miss? If you get this error,
		# please let me know what your constant's name was.
		# Write to <rootbeer@@redcat.com>. Thanks!
		warnings::warn("Constant name '$name' has unknown problems");
	    }
	}

    # Looks like a boolean
    # 		use constant FRED == fred;
    } elsif ($name =~ /^[01]?\z/) {
        require Carp;
	if (@@_) {
	    Carp::croak("Constant name '$name' is invalid");
	} else {
	    Carp::croak("Constant name looks like boolean value");
	}

    } else {
	# Must have bad characters
        require Carp;
	Carp::croak("Constant name '$name' has invalid characters");
    }

    {
	no strict 'refs';
	my $full_name = "${pkg}::$name";
	$declared{$full_name}++;
	if (@@_ == 1) {
	    my $scalar = $_[0];
	    *$full_name = sub () { $scalar };
	} elsif (@@_) {
	    my @@list = @@_;
	    *$full_name = sub () { @@list };
	} else {
	    *$full_name = sub () { };
	}
    }

}

1;

__END__
d23 1
a23 1
    # references can be constants
d33 1
a33 1
    print CHASH->[10];			# compile-time error
d66 1
a66 4
subroutine names. Constant names must begin with a letter or
underscore. Names beginning with a double underscore are reserved. Some
poor choices for names will generate warnings, if warnings are enabled at
compile time.
d101 1
a101 18
Dereferencing constant references incorrectly (such as using an array
subscript on a constant hash reference, or vice versa) will be trapped at
compile time.

In the rare case in which you need to discover at run time whether a
particular constant has been declared via this module, you may use
this function to examine the hash C<%constant::declared>. If the given
constant name does not include a package name, the current package is
used.

    sub declared ($) {
	use constant 1.01;		# don't omit this!
	my $name = shift;
	$name =~ s/^::/main::/;
	my $pkg = caller;
	my $full_name = $name =~ /::/ ? $name : "${pkg}::$name";
	$constant::declared{$full_name};
    }
d118 1
a118 13
name as a constant in the same package. This is probably a Good Thing.

A constant with a name in the list C<STDIN STDOUT STDERR ARGV ARGVOUT
ENV INC SIG> is not allowed anywhere but in package C<main::>, for
technical reasons. 

Even though a reference may be declared as a constant, the reference may
point to data which may be changed, as this code shows.

    use constant CARRAY		=> [ 1,2,3,4 ];
    print CARRAY->[1];
    CARRAY->[1] = " be changed";
    print CARRAY->[1];
d129 2
a130 3
immediately to its left, you have to say C<CONSTANT() =E<gt> 'value'>
(or simply use a comma in place of the big arrow) instead of
C<CONSTANT =E<gt> 'value'>.
d134 1
a134 1
Tom Phoenix, E<lt>F<rootbeer@@redcat.com>E<gt>, with help from
d139 1
a139 1
Copyright (C) 1997, 1999 Tom Phoenix
d145 42
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d4 1
a4 1
use 5.006_00;
d8 1
a8 1
$VERSION = '1.04';
d31 4
a34 11
    my %constants = ();
    my $multiple  = ref $_[0];

    if ( $multiple ) {
	if (ref $_[0] ne 'HASH') {
	    require Carp;
	    Carp::croak("Invalid reference type '".ref(shift)."' not 'HASH'");
	}
	%constants = %{+shift};
    } else {
	$constants{+shift} = undef;
d36 1
d38 23
a60 44
    foreach my $name ( keys %constants ) {
	unless (defined $name) {
	    require Carp;
	    Carp::croak("Can't use undef as constant name");
	}
	my $pkg = caller;

	# Normal constant name
	if ($name =~ /^_?[^\W_0-9]\w*\z/ and !$forbidden{$name}) {
	    # Everything is okay

	# Name forced into main, but we're not in main. Fatal.
	} elsif ($forced_into_main{$name} and $pkg ne 'main') {
	    require Carp;
	    Carp::croak("Constant name '$name' is forced into main::");

	# Starts with double underscore. Fatal.
	} elsif ($name =~ /^__/) {
	    require Carp;
	    Carp::croak("Constant name '$name' begins with '__'");

	# Maybe the name is tolerable
	} elsif ($name =~ /^[A-Za-z_]\w*\z/) {
	    # Then we'll warn only if you've asked for warnings
	    if (warnings::enabled()) {
		if ($keywords{$name}) {
		    warnings::warn("Constant name '$name' is a Perl keyword");
		} elsif ($forced_into_main{$name}) {
		    warnings::warn("Constant name '$name' is " .
			"forced into package main::");
		} else {
		    # Catch-all - what did I miss? If you get this error,
		    # please let me know what your constant's name was.
		    # Write to <rootbeer@@redcat.com>. Thanks!
		    warnings::warn("Constant name '$name' has unknown problems");
		}
	    }

	# Looks like a boolean
	# use constant FRED == fred;
	} elsif ($name =~ /^[01]?\z/) {
            require Carp;
	    if (@@_) {
		Carp::croak("Constant name '$name' is invalid");
d62 4
a65 1
		Carp::croak("Constant name looks like boolean value");
d67 1
d69 6
d76 1
a76 3
	   # Must have bad characters
            require Carp;
	    Carp::croak("Constant name '$name' has invalid characters");
d79 18
a96 18
	{
	    no strict 'refs';
	    my $full_name = "${pkg}::$name";
	    $declared{$full_name}++;
	    if ($multiple) {
		my $scalar = $constants{$name};
		*$full_name = sub () { $scalar };
	    } else {
		if (@@_ == 1) {
		    my $scalar = $_[0];
		    *$full_name = sub () { $scalar };
		} elsif (@@_) {
		    my @@list = @@_;
		    *$full_name = sub () { @@list };
		} else {
		    *$full_name = sub () { };
		}
	    }
d99 1
d112 23
a134 22
    use constant PI    => 4 * atan2(1, 1);
    use constant DEBUG => 0;

    print "Pi equals ", PI, "...\n" if DEBUG;

    use constant {
        SEC   => 0,
        MIN   => 1,
        HOUR  => 2,
        MDAY  => 3,
        MON   => 4,
        YEAR  => 5,
        WDAY  => 6,
        YDAY  => 7,
        ISDST => 8,
    };

    use constant WEEKDAYS => qw(
        Sunday Monday Tuesday Wednesday Thursday Friday Saturday
    );

    print "Today is ", (WEEKDAYS)[ (localtime)[WDAY] ], ".\n";
d138 2
a139 1
This will declare a symbol to be a constant with the given value.
a147 5
When a constant is used in an expression, perl replaces it with its
value at compile time, and may then optimize the expression further.
In particular, any code in an C<if (CONSTANT)> block will be optimized
away if the constant is false.

d150 2
a151 4
As with all C<use> directives, defining a constant happens at
compile time. Thus, it's probably not correct to put a constant
declaration inside of a conditional statement (like C<if ($foo)
{ use constant ... }>).
d153 3
a155 2
Constants defined using this module cannot be interpolated into
strings like variables.  However, concatenation works just fine:
d157 1
a157 2
    print "Pi equals PI...\n";        # WRONG: does not expand "PI"
    print "Pi equals ".PI."...\n";    # right
d159 1
a159 11
Even though a reference may be declared as a constant, the reference may
point to data which may be changed, as this code shows.

    use constant ARRAY => [ 1,2,3,4 ];
    print ARRAY->[1];
    ARRAY->[1] = " be changed";
    print ARRAY->[1];

Dereferencing constant references incorrectly (such as using an array
subscript on a constant hash reference, or vice versa) will be trapped at
compile time.
d161 2
a162 7
Constants belong to the package they are defined in.  To refer to a
constant defined in another package, specify the full package name, as
in C<Some::Package::CONSTANT>.  Constants may be exported by modules,
and may also be called as either class or instance methods, that is,
as C<< Some::Package->CONSTANT >> or as C<< $obj->CONSTANT >> where
C<$obj> is an instance of C<Some::Package>.  Subclasses may define
their own constants to override those in their base class.
d172 3
a174 1
=head2 List constants
d176 24
a199 57
Constants may be lists of more (or less) than one value.  A constant
with no values evaluates to C<undef> in scalar context.  Note that
constants with more than one value do I<not> return their last value in
scalar context as one might expect.  They currently return the number
of values, but B<this may change in the future>.  Do not use constants
with multiple values in scalar context.

B<NOTE:> This implies that the expression defining the value of a
constant is evaluated in list context.  This may produce surprises:

    use constant TIMESTAMP => localtime;                # WRONG!
    use constant TIMESTAMP => scalar localtime;         # right

The first line above defines C<TIMESTAMP> as a 9-element list, as
returned by localtime() in list context.  To set it to the string
returned by localtime() in scalar context, an explicit C<scalar>
keyword is required.

List constants are lists, not arrays.  To index or slice them, they
must be placed in parentheses.

    my @@workdays = WEEKDAYS[1 .. 5];            # WRONG!
    my @@workdays = (WEEKDAYS)[1 .. 5];          # right

=head2 Defining multiple constants at once

Instead of writing multiple C<use constant> statements, you may define
multiple constants in a single statement by giving, instead of the
constant name, a reference to a hash where the keys are the names of
the constants to be defined.  Obviously, all constants defined using
this method must have a single value.

    use constant {
        FOO => "A single value",
        BAR => "This", "won't", "work!",        # Error!
    };

This is a fundamental limitation of the way hashes are constructed in
Perl.  The error messages produced when this happens will often be
quite cryptic -- in the worst case there may be none at all, and
you'll only later find that something is broken.

When defining multiple constants, you cannot use the values of other
constants defined in the same declaration.  This is because the
calling package doesn't know about any constant within that group
until I<after> the C<use> statement is finished.

    use constant {
        BITMASK => 0xAFBAEBA8,
        NEGMASK => ~BITMASK,                    # Error!
    };

=head2 Magic constants

Magical values and references can be made into constants at compile
time, allowing for way cool stuff like this.  (These error numbers
aren't totally portable, alas.)
d202 2
a203 2
    print   E2BIG, "\n";        # something like "Arg list too long"
    print 0+E2BIG, "\n";        # "7"
d205 3
a207 12
You can't produce a tied constant by giving a tied scalar as the
value.  References to tied variables, however, can be used as
constants without any problems.

=head1 TECHNICAL NOTES

In the current implementation, scalar constants are actually
inlinable subroutines. As of version 5.004 of Perl, the appropriate
scalar constant is inserted directly in place of some subroutine
calls, thereby saving the overhead of a subroutine call. See
L<perlsub/"Constant Functions"> for details about how and when this
happens.
d216 6
a221 6
        use constant 1.01;              # don't omit this!
        my $name = shift;
        $name =~ s/^::/main::/;
        my $pkg = caller;
        my $full_name = $name =~ /::/ ? $name : "${pkg}::$name";
        $constant::declared{$full_name};
d224 9
d238 1
a238 1
It is not possible to have a subroutine or a keyword with the same
d245 8
d261 2
a262 2
kicking in.  Similarly, since the C<< => >> operator quotes a bareword
immediately to its left, you have to say C<< CONSTANT() => 'value' >>
d264 1
a264 1
C<< CONSTANT => 'value' >>.
a269 6

Multiple constant declarations at once added by Casey West,
E<lt>F<casey@@geeknest.com>E<gt>.

Documentation mostly rewritten by Ilmari Karonen,
E<lt>F<perl@@itz.pp.sci.fi>E<gt>.
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@d8 1
a8 1
$VERSION = '1.05';
d74 5
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d2 1
a2 1
use 5.005;
d4 1
d7 2
a8 2
use vars qw($VERSION %declared);
$VERSION = '1.13';
a13 1
$keywords{UNITCHECK}++ if $] > 5.009;
d31 1
a31 1
    my $constants;
a32 8
    my $pkg = caller;
    my $symtab;
    my $str_end = $] >= 5.006 ? "\\z" : "\\Z";

    if ($] > 5.009002) {
	no strict 'refs';
	$symtab = \%{$pkg . '::'};
    };
d39 1
a39 1
	$constants = shift;
d41 1
a41 1
	$constants->{+shift} = undef;
d44 1
a44 1
    foreach my $name ( keys %$constants ) {
d49 1
d52 1
a52 1
	if ($name =~ /^_?[^\W_0-9]\w*$str_end/ and !$forbidden{$name}) {
d66 1
a66 1
	} elsif ($name =~ /^[A-Za-z_]\w*$str_end/) {
d79 1
a79 1
	} elsif ($name =~ /^[01]?$str_end/) {
d97 10
a106 10
	    if ($multiple || @@_ == 1) {
		my $scalar = $multiple ? $constants->{$name} : $_[0];
		if ($symtab && !exists $symtab->{$name}) {
		    # No typeglob yet, so we can use a reference as space-
		    # efficient proxy for a constant subroutine
		    # The check in Perl_ck_rvconst knows that inlinable
		    # constants from cv_const_sv are read only. So we have to:
		    Internals::SvREADONLY($scalar, 1);
		    $symtab->{$name} = \$scalar;
		    mro::method_changed_in($pkg);
d108 1
a108 1
		    *$full_name = sub () { $scalar };
a109 5
	    } elsif (@@_) {
		my @@list = @@_;
		*$full_name = sub () { @@list };
	    } else {
		*$full_name = sub () { };
d150 1
a150 1
This pragma allows you to declare constants at compile-time.
d221 2
a222 2
returned by C<localtime()> in list context.  To set it to the string
returned by C<localtime()> in scalar context, an explicit C<scalar>
d297 1
a297 1
=head1 CAVEATS
d322 1
a322 5
=head1 BUGS

Please report any bugs or feature requests via the perlbug(1) utility.

=head1 AUTHORS
a331 4

This program is maintained by the Perl 5 Porters. 
The CPAN distribution is maintained by SE<eacute>bastien Aperghis-Tramoni
E<lt>F<sebastien@@aperghis.net>E<gt>.
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d7 1
a7 1
$VERSION = '1.17';
d171 1
a171 1
When a constant is used in an expression, Perl replaces it with its
a333 14
=head1 SEE ALSO

L<Readonly> - Facility for creating read-only scalars, arrays, hashes.

L<Const> - Facility for creating read-only variables. Similar to C<Readonly>,
but uses C<SvREADONLY> instead of C<tie>.

L<Attribute::Constant> - Make read-only variables via attribute

L<Scalar::Readonly> - Perl extension to the C<SvREADONLY> scalar flag

L<Hash::Util> - A selection of general-utility hash subroutines (mostly
to lock/unlock keys and values)

d353 1
a353 1
=head1 COPYRIGHT & LICENSE
@


