head	1.5;
access;
symbols
	OPENBSD_5_3:1.4.0.10
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.8
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.3.0.44
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.40
	OPENBSD_4_7_BASE:1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.3.0.42
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.38
	OPENBSD_4_5_BASE:1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.3.0.36
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.34
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.32
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.30
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.28
	OPENBSD_4_0_BASE:1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.3.0.26
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.24
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.22
	OPENBSD_3_7_BASE:1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.3.0.20
	OPENBSD_3_6_BASE:1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.3.0.18
	OPENBSD_3_5_BASE:1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.3.0.16
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.14
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.3.0.12
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.10
	OPENBSD_3_1_BASE:1.3
	OPENBSD_3_0:1.3.0.8
	OPENBSD_3_0_BASE:1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2013.03.25.20.40.55;	author sthen;	state dead;
branches;
next	1.4;

1.4
date	2010.09.24.15.06.59;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.07;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.56.50;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.31;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.31;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.35;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@package bigfloat;
require "bigint.pl";
#
# This library is no longer being maintained, and is included for backward
# compatibility with Perl 4 programs which may require it.
# This legacy library is deprecated and will be removed in a future
# release of perl.
#
# In particular, this should not be used as an example of modern Perl
# programming techniques.
#
# Suggested alternative: Math::BigFloat

# Arbitrary length float math package
#
# by Mark Biggar
#
# number format
#   canonical strings have the form /[+-]\d+E[+-]\d+/
#   Input values can have embedded whitespace
# Error returns
#   'NaN'           An input parameter was "Not a Number" or 
#                       divide by zero or sqrt of negative number
# Division is computed to 
#   max($div_scale,length(dividend)+length(divisor)) 
#   digits by default.
# Also used for default sqrt scale

$div_scale = 40;

# Rounding modes one of 'even', 'odd', '+inf', '-inf', 'zero' or 'trunc'.

$rnd_mode = 'even';

#   bigfloat routines
#
#   fadd(NSTR, NSTR) return NSTR            addition
#   fsub(NSTR, NSTR) return NSTR            subtraction
#   fmul(NSTR, NSTR) return NSTR            multiplication
#   fdiv(NSTR, NSTR[,SCALE]) returns NSTR   division to SCALE places
#   fneg(NSTR) return NSTR                  negation
#   fabs(NSTR) return NSTR                  absolute value
#   fcmp(NSTR,NSTR) return CODE             compare undef,<0,=0,>0
#   fround(NSTR, SCALE) return NSTR         round to SCALE digits
#   ffround(NSTR, SCALE) return NSTR        round at SCALEth place
#   fnorm(NSTR) return (NSTR)               normalize
#   fsqrt(NSTR[, SCALE]) return NSTR        sqrt to SCALE places

# Convert a number to canonical string form.
#   Takes something that looks like a number and converts it to
#   the form /^[+-]\d+E[+-]\d+$/.
sub main'fnorm { #(string) return fnum_str
    local($_) = @@_;
    s/\s+//g;                               # strip white space
    if (/^([+-]?)(\d*)(\.(\d*))?([Ee]([+-]?\d+))?$/
	  && ($2 ne '' || defined($4))) {
	my $x = defined($4) ? $4 : '';
	&norm(($1 ? "$1$2$x" : "+$2$x"), (($x ne '') ? $6-length($x) : $6));
    } else {
	'NaN';
    }
}

# normalize number -- for internal use
sub norm { #(mantissa, exponent) return fnum_str
    local($_, $exp) = @@_;
    if ($_ eq 'NaN') {
	'NaN';
    } else {
	s/^([+-])0+/$1/;                        # strip leading zeros
	if (length($_) == 1) {
	    '+0E+0';
	} else {
	    $exp += length($1) if (s/(0+)$//);  # strip trailing zeros
	    sprintf("%sE%+ld", $_, $exp);
	}
    }
}

# negation
sub main'fneg { #(fnum_str) return fnum_str
    local($_) = &'fnorm($_[$[]);
    vec($_,0,8) ^= ord('+') ^ ord('-') unless $_ eq '+0E+0'; # flip sign
    if ( ord("\t") == 9 ) { # ascii
        s/^H/N/;
    }
    else { # ebcdic character set
        s/\373/N/;
    }
    $_;
}

# absolute value
sub main'fabs { #(fnum_str) return fnum_str
    local($_) = &'fnorm($_[$[]);
    s/^-/+/;		                       # mash sign
    $_;
}

# multiplication
sub main'fmul { #(fnum_str, fnum_str) return fnum_str
    local($x,$y) = (&'fnorm($_[$[]),&'fnorm($_[$[+1]));
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	local($xm,$xe) = split('E',$x);
	local($ym,$ye) = split('E',$y);
	&norm(&'bmul($xm,$ym),$xe+$ye);
    }
}

# addition
sub main'fadd { #(fnum_str, fnum_str) return fnum_str
    local($x,$y) = (&'fnorm($_[$[]),&'fnorm($_[$[+1]));
    if ($x eq 'NaN' || $y eq 'NaN') {
	'NaN';
    } else {
	local($xm,$xe) = split('E',$x);
	local($ym,$ye) = split('E',$y);
	($xm,$xe,$ym,$ye) = ($ym,$ye,$xm,$xe) if ($xe < $ye);
	&norm(&'badd($ym,$xm.('0' x ($xe-$ye))),$ye);
    }
}

# subtraction
sub main'fsub { #(fnum_str, fnum_str) return fnum_str
    &'fadd($_[$[],&'fneg($_[$[+1]));    
}

# division
#   args are dividend, divisor, scale (optional)
#   result has at most max(scale, length(dividend), length(divisor)) digits
sub main'fdiv #(fnum_str, fnum_str[,scale]) return fnum_str
{
    local($x,$y,$scale) = (&'fnorm($_[$[]),&'fnorm($_[$[+1]),$_[$[+2]);
    if ($x eq 'NaN' || $y eq 'NaN' || $y eq '+0E+0') {
	'NaN';
    } else {
	local($xm,$xe) = split('E',$x);
	local($ym,$ye) = split('E',$y);
	$scale = $div_scale if (!$scale);
	$scale = length($xm)-1 if (length($xm)-1 > $scale);
	$scale = length($ym)-1 if (length($ym)-1 > $scale);
	$scale = $scale + length($ym) - length($xm);
	&norm(&round(&'bdiv($xm.('0' x $scale),$ym),&'babs($ym)),
	    $xe-$ye-$scale);
    }
}

# round int $q based on fraction $r/$base using $rnd_mode
sub round { #(int_str, int_str, int_str) return int_str
    local($q,$r,$base) = @@_;
    if ($q eq 'NaN' || $r eq 'NaN') {
	'NaN';
    } elsif ($rnd_mode eq 'trunc') {
	$q;                         # just truncate
    } else {
	local($cmp) = &'bcmp(&'bmul($r,'+2'),$base);
	if ( $cmp < 0 ||
		 ($cmp == 0 &&
		  ( $rnd_mode eq 'zero'                             ||
		   ($rnd_mode eq '-inf' && (substr($q,$[,1) eq '+')) ||
		   ($rnd_mode eq '+inf' && (substr($q,$[,1) eq '-')) ||
		   ($rnd_mode eq 'even' && $q =~ /[24680]$/)        ||
		   ($rnd_mode eq 'odd'  && $q =~ /[13579]$/)        )) ) {
	    $q;                     # round down
	} else {
	    &'badd($q, ((substr($q,$[,1) eq '-') ? '-1' : '+1'));
				    # round up
	}
    }
}

# round the mantissa of $x to $scale digits
sub main'fround { #(fnum_str, scale) return fnum_str
    local($x,$scale) = (&'fnorm($_[$[]),$_[$[+1]);
    if ($x eq 'NaN' || $scale <= 0) {
	$x;
    } else {
	local($xm,$xe) = split('E',$x);
	if (length($xm)-1 <= $scale) {
	    $x;
	} else {
	    &norm(&round(substr($xm,$[,$scale+1),
			 "+0".substr($xm,$[+$scale+1,1),"+10"),
		  $xe+length($xm)-$scale-1);
	}
    }
}

# round $x at the 10 to the $scale digit place
sub main'ffround { #(fnum_str, scale) return fnum_str
    local($x,$scale) = (&'fnorm($_[$[]),$_[$[+1]);
    if ($x eq 'NaN') {
	'NaN';
    } else {
	local($xm,$xe) = split('E',$x);
	if ($xe >= $scale) {
	    $x;
	} else {
	    $xe = length($xm)+$xe-$scale;
	    if ($xe < 1) {
		'+0E+0';
	    } elsif ($xe == 1) {
		# The first substr preserves the sign, which means that
		# we'll pass a non-normalized "-0" to &round when rounding
		# -0.006 (for example), purely so that &round won't lose
		# the sign.
		&norm(&round(substr($xm,$[,1).'0',
		      "+0".substr($xm,$[+1,1),"+10"), $scale);
	    } else {
		&norm(&round(substr($xm,$[,$xe),
		      "+0".substr($xm,$[+$xe,1),"+10"), $scale);
	    }
	}
    }
}
    
# compare 2 values returns one of undef, <0, =0, >0
#   returns undef if either or both input value are not numbers
sub main'fcmp #(fnum_str, fnum_str) return cond_code
{
    local($x, $y) = (&'fnorm($_[$[]),&'fnorm($_[$[+1]));
    if ($x eq "NaN" || $y eq "NaN") {
	undef;
    } else {
	ord($y) <=> ord($x)
	||
	(  local($xm,$xe,$ym,$ye) = split('E', $x."E$y"),
	     (($xe <=> $ye) * (substr($x,$[,1).'1')
             || &bigint'cmp($xm,$ym))
	);
    }
}

# square root by Newtons method.
sub main'fsqrt { #(fnum_str[, scale]) return fnum_str
    local($x, $scale) = (&'fnorm($_[$[]), $_[$[+1]);
    if ($x eq 'NaN' || $x =~ /^-/) {
	'NaN';
    } elsif ($x eq '+0E+0') {
	'+0E+0';
    } else {
	local($xm, $xe) = split('E',$x);
	$scale = $div_scale if (!$scale);
	$scale = length($xm)-1 if ($scale < length($xm)-1);
	local($gs, $guess) = (1, sprintf("1E%+d", (length($xm)+$xe-1)/2));
	while ($gs < 2*$scale) {
	    $guess = &'fmul(&'fadd($guess,&'fdiv($x,$guess,$gs*2)),".5");
	    $gs *= 2;
	}
	&'fround($guess, $scale);
    }
}

1;
@


1.4
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.3
log
@perl-5.6.0 + local changes
@
text
@d6 2
d13 1
a13 1
#
@


1.2
log
@perl 5.004_04
@
text
@d3 9
d18 1
a18 1
#   Input values can have inbedded whitespace
d82 6
a87 1
    s/^H/N/;
d143 1
a143 1
	&norm(&round(&'bdiv($xm.('0' x $scale),$ym),$ym),
d203 6
a208 1
		&norm(&round('+0',"+0".substr($xm,$[+1,1),"+10"), $scale);
@


1.1
log
@Initial revision
@
text
@d44 4
a47 2
    if (/^([+-]?)(\d*)(\.(\d*))?([Ee]([+-]?\d+))?$/ && "$2$4" ne '') {
	&norm(($1 ? "$1$2$4" : "+$2$4"),(($4 ne '') ? $6-length($4) : $6));
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d44 2
a45 4
    if (/^([+-]?)(\d*)(\.(\d*))?([Ee]([+-]?\d+))?$/
	  && ($2 ne '' || defined($4))) {
	my $x = defined($4) ? $4 : '';
	&norm(($1 ? "$1$2$x" : "+$2$x"), (($x ne '') ? $6-length($x) : $6));
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a2 9
#
# This library is no longer being maintained, and is included for backward
# compatibility with Perl 4 programs which may require it.
#
# In particular, this should not be used as an example of modern Perl
# programming techniques.
#
# Suggested alternative: Math::BigFloat
#
d9 1
a9 1
#   Input values can have embedded whitespace
d73 1
a73 6
    if ( ord("\t") == 9 ) { # ascii
        s/^H/N/;
    }
    else { # ebcdic character set
        s/\373/N/;
    }
d129 1
a129 1
	&norm(&round(&'bdiv($xm.('0' x $scale),$ym),&'babs($ym)),
d189 1
a189 6
		# The first substr preserves the sign, which means that
		# we'll pass a non-normalized "-0" to &round when rounding
		# -0.006 (for example), purely so that &round won't lose
		# the sign.
		&norm(&round(substr($xm,$[,1).'0',
		      "+0".substr($xm,$[+1,1),"+10"), $scale);
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@a5 2
# This legacy library is deprecated and will be removed in a future
# release of perl.
d11 1
a11 1

@


