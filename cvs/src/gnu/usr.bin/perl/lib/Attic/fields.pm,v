head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.7.0.4
	OPENBSD_4_8_BASE:1.1.1.7
	OPENBSD_4_7:1.1.1.7.0.2
	OPENBSD_4_7_BASE:1.1.1.7
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.1.1.6.0.6
	OPENBSD_4_6_BASE:1.1.1.6
	OPENBSD_4_5:1.1.1.6.0.2
	OPENBSD_4_5_BASE:1.1.1.6
	PERL_5_10_0:1.1.1.6
	OPENBSD_4_4:1.1.1.5.0.20
	OPENBSD_4_4_BASE:1.1.1.5
	OPENBSD_4_3:1.1.1.5.0.18
	OPENBSD_4_3_BASE:1.1.1.5
	OPENBSD_4_2:1.1.1.5.0.16
	OPENBSD_4_2_BASE:1.1.1.5
	OPENBSD_4_1:1.1.1.5.0.14
	OPENBSD_4_1_BASE:1.1.1.5
	OPENBSD_4_0:1.1.1.5.0.12
	OPENBSD_4_0_BASE:1.1.1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.1.1.5.0.10
	OPENBSD_3_9_BASE:1.1.1.5
	OPENBSD_3_8:1.1.1.5.0.8
	OPENBSD_3_8_BASE:1.1.1.5
	OPENBSD_3_7:1.1.1.5.0.6
	OPENBSD_3_7_BASE:1.1.1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.1.1.5.0.4
	OPENBSD_3_6_BASE:1.1.1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.5
	OPENBSD_3_5:1.1.1.5.0.2
	OPENBSD_3_5_BASE:1.1.1.5
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.1.1.4.0.4
	OPENBSD_3_4_BASE:1.1.1.4
	OPENBSD_3_3:1.1.1.4.0.2
	OPENBSD_3_3_BASE:1.1.1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.1.1.3.0.6
	OPENBSD_3_2_BASE:1.1.1.3
	OPENBSD_3_1:1.1.1.3.0.4
	OPENBSD_3_1_BASE:1.1.1.3
	OPENBSD_3_0:1.1.1.3.0.2
	OPENBSD_3_0_BASE:1.1.1.3
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.1.1.2.0.6
	OPENBSD_2_9_BASE:1.1.1.2
	OPENBSD_2_8:1.1.1.2.0.4
	OPENBSD_2_8_BASE:1.1.1.2
	OPENBSD_2_7:1.1.1.2.0.2
	OPENBSD_2_7_BASE:1.1.1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.1.1.0.2
	OPENBSD_2_6_BASE:1.1.1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.2
date	2010.09.24.14.59.33;	author millert;	state dead;
branches;
next	1.1;

1.1
date	99.04.29.22.39.51;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.51;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.37;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.21;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2009.10.12.18.10.49;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package fields;

=head1 NAME

fields - compile-time class fields

=head1 SYNOPSIS

    {
        package Foo;
        use fields qw(foo bar _private);
    }
    ...
    my Foo $var = new Foo;
    $var->{foo} = 42;

    # This will generate a compile-time error.
    $var->{zap} = 42;

    {
        package Bar;
        use base 'Foo';
        use fields 'bar';             # hides Foo->{bar}
        use fields qw(baz _private);  # not shared with Foo
    }

=head1 DESCRIPTION

The C<fields> pragma enables compile-time verified class fields.  It
does so by updating the %FIELDS hash in the calling package.

If a typed lexical variable holding a reference is used to access a
hash element and the %FIELDS hash of the given type exists, then the
operation is turned into an array access at compile time.  The %FIELDS
hash maps from hash element names to the array indices.  If the hash
element is not present in the %FIELDS hash, then a compile-time error
is signaled.

Since the %FIELDS hash is used at compile-time, it must be set up at
compile-time too.  This is made easier with the help of the 'fields'
and the 'base' pragma modules.  The 'base' pragma will copy fields
from base classes and the 'fields' pragma adds new fields.  Field
names that start with an underscore character are made private to a
class and are not visible to subclasses.  Inherited fields can be
overridden but will generate a warning if used together with the C<-w>
switch.

The effect of all this is that you can have objects with named fields
which are as compact and as fast arrays to access.  This only works
as long as the objects are accessed through properly typed variables.
For untyped access to work you have to make sure that a reference to
the proper %FIELDS hash is assigned to the 0'th element of the array
object (so that the objects can be treated like an pseudo-hash).  A
constructor like this does the job:

  sub new
  {
      my $class = shift;
      no strict 'refs';
      my $self = bless [\%{"$class\::FIELDS"}], $class;
      $self;
  }


=head1 SEE ALSO

L<base>,
L<perlref/Pseudo-hashes: Using an array as a hash>

=cut

use strict;
no strict 'refs';
use vars qw(%attr $VERSION);

$VERSION = "0.02";

# some constants
sub _PUBLIC    () { 1 }
sub _PRIVATE   () { 2 }
sub _INHERITED () { 4 }

# The %attr hash holds the attributes of the currently assigned fields
# per class.  The hash is indexed by class names and the hash value is
# an array reference.  The array is indexed with the field numbers
# (minus one) and the values are integer bit masks (or undef).  The
# size of the array also indicate the next field index too assign for
# additional fields in this class.

sub import {
    my $class = shift;
    my $package = caller(0);
    my $fields = \%{"$package\::FIELDS"};
    my $fattr = ($attr{$package} ||= []);

    foreach my $f (@@_) {
	if (my $fno = $fields->{$f}) {
	    require Carp;
            if ($fattr->[$fno-1] & _INHERITED) {
                Carp::carp("Hides field '$f' in base class") if $^W;
            } else {
                Carp::croak("Field name '$f' already in use");
            }
	}
	$fields->{$f} = @@$fattr + 1;
        push(@@$fattr, ($f =~ /^_/) ? _PRIVATE : _PUBLIC);
    }
}

sub inherit  # called by base.pm
{
    my($derived, $base) = @@_;

    if (defined %{"$derived\::FIELDS"}) {
	 require Carp;
         Carp::croak("Inherited %FIELDS can't override existing %FIELDS");
    } else {
         my $base_fields    = \%{"$base\::FIELDS"};
	 my $derived_fields = \%{"$derived\::FIELDS"};

         $attr{$derived}[@@{$attr{$base}}-1] = undef;
         while (my($k,$v) = each %$base_fields) {
            next if $attr{$base}[$v-1] & _PRIVATE;
            $attr{$derived}[$v-1] = _INHERITED;
            $derived_fields->{$k} = $v;
         }
    }
    
}

sub _dump  # sometimes useful for debugging
{
   for my $pkg (sort keys %attr) {
      print "\n$pkg";
      if (defined @@{"$pkg\::ISA"}) {
         print " (", join(", ", @@{"$pkg\::ISA"}), ")";
      }
      print "\n";
      my $fields = \%{"$pkg\::FIELDS"};
      for my $f (sort {$fields->{$a} <=> $fields->{$b}} keys %$fields) {
         my $no = $fields->{$f};
         print "   $no: $f";
         my $fattr = $attr{$pkg}[$no-1];
         if (defined $fattr) {
            my @@a;
	    push(@@a, "public")    if $fattr & _PUBLIC;
            push(@@a, "private")   if $fattr & _PRIVATE;
            push(@@a, "inherited") if $fattr & _INHERITED;
            print "\t(", join(", ", @@a), ")";
         }
         print "\n";
      }
   }
}

1;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d11 1
a11 11
        use fields qw(foo bar _Foo_private);
	sub new {
	    my Foo $self = shift;
	    unless (ref $self) {
		$self = fields::new($self);
		$self->{_Foo_private} = "this is Foo's secret";
	    }
	    $self->{foo} = 10;
	    $self->{bar} = 20;
	    return $self;
	}
d13 2
a14 2

    my Foo $var = Foo::->new;
d17 1
a17 1
    # this will generate a compile-time error
a19 1
    # subclassing
d23 2
a24 9
        use fields qw(baz _Bar_private);	# not shared with Foo
	sub new {
	    my $class = shift;
	    my $self = fields::new($class);
	    $self->SUPER::new();		# init base fields
	    $self->{baz} = 10;			# init own fields
	    $self->{_Bar_private} = "this is Bar's secret";
	    return $self;
	}
d29 2
a30 6
The C<fields> pragma enables compile-time verified class fields.

NOTE: The current implementation keeps the declared fields in the %FIELDS
hash of the calling package, but this may change in future versions.
Do B<not> update the %FIELDS hash directly, because it must be created
at compile-time for it to be fully useful, as is done by this pragma.
d33 12
a44 10
hash element and a package with the same name as the type has declared
class fields using this pragma, then the operation is turned into an
array access at compile time.

The related C<base> pragma will combine fields from base classes and any
fields declared using the C<fields> pragma.  This enables field
inheritance to work properly.

Field names that start with an underscore character are made private to
the class and are not visible to subclasses.  Inherited fields can be
d51 12
a62 3
If the objects are not typed, access is only checked at run time.

The following functions are supported:
a63 47
=over 8

=item new

fields::new() creates and blesses a pseudo-hash comprised of the fields
declared using the C<fields> pragma into the specified class.
This makes it possible to write a constructor like this:

    package Critter::Sounds;
    use fields qw(cat dog bird);

    sub new {
	my Critter::Sounds $self = shift;
	$self = fields::new($self) unless ref $self;
	$self->{cat} = 'meow';				# scalar element
	@@$self{'dog','bird'} = ('bark','tweet');	# slice
	return $self;
    }

=item phash

fields::phash() can be used to create and initialize a plain (unblessed)
pseudo-hash.  This function should always be used instead of creating
pseudo-hashes directly.

If the first argument is a reference to an array, the pseudo-hash will
be created with keys from that array.  If a second argument is supplied,
it must also be a reference to an array whose elements will be used as
the values.  If the second array contains less elements than the first,
the trailing elements of the pseudo-hash will not be initialized.
This makes it particularly useful for creating a pseudo-hash from
subroutine arguments:

    sub dogtag {
	my $tag = fields::phash([qw(name rank ser_num)], [@@_]);
    }

fields::phash() also accepts a list of key-value pairs that will
be used to construct the pseudo hash.  Examples:

    my $tag = fields::phash(name => "Joe",
			    rank => "captain",
			    ser_num => 42);

    my $pseudohash = fields::phash(%args);

=back
a71 1
use 5.005_64;
d74 1
a74 2
use warnings::register;
our(%attr, $VERSION);
d76 1
a76 1
$VERSION = "1.01";
d81 1
d85 4
a88 5
# an array reference.  The first element in the array is the lowest field
# number not belonging to a base class.  The remaining elements' indices
# are the field numbers.  The values are integer bit masks, or undef
# in the case of base class private fields (which occupy a slot but are
# otherwise irrelevant to the class).
a91 1
    return unless @@_;
a92 2
    # avoid possible typo warnings
    %{"$package\::FIELDS"} = () unless %{"$package\::FIELDS"};
d94 1
a94 2
    my $fattr = ($attr{$package} ||= [1]);
    my $next = @@$fattr;
a95 7
    if ($next > $fattr->[0]
	and ($fields->{$_[0]} || 0) >= $fattr->[0])
    {
	# There are already fields not belonging to base classes.
	# Looks like a possible module reload...
	$next = $fattr->[0];
    }
d97 1
a97 5
	my $fno = $fields->{$f};

	# Allow the module to be reloaded so long as field positions
	# have not changed.
	if ($fno and $fno != $next) {
d99 2
a100 3
            if ($fno < $fattr->[0]) {
                warnings::warn("Hides field '$f' in base class") 
		    if warnings::enabled();
d105 2
a106 12
	$fields->{$f} = $next;
        $fattr->[$next] = ($f =~ /^_/) ? _PRIVATE : _PUBLIC;
	$next += 1;
    }
    if (@@$fattr > $next) {
	# Well, we gave them the benefit of the doubt by guessing the
	# module was reloaded, but they appear to be declaring fields
	# in more than one place.  We can't be sure (without some extra
	# bookkeeping) that the rest of the fields will be declared or
	# have the same positions, so punt.
	require Carp;
	Carp::croak ("Reloaded module must declare all fields at once");
d110 2
a111 1
sub inherit  { # called by base.pm when $base_fields is nonempty
d113 16
a128 22
    my $base_attr = $attr{$base};
    my $derived_attr = $attr{$derived} ||= [];
    # avoid possible typo warnings
    %{"$base\::FIELDS"} = () unless %{"$base\::FIELDS"};
    %{"$derived\::FIELDS"} = () unless %{"$derived\::FIELDS"};
    my $base_fields    = \%{"$base\::FIELDS"};
    my $derived_fields = \%{"$derived\::FIELDS"};

    $derived_attr->[0] = $base_attr ? scalar(@@$base_attr) : 1;
    while (my($k,$v) = each %$base_fields) {
	my($fno);
	if ($fno = $derived_fields->{$k} and $fno != $v) {
	    require Carp;
	    Carp::croak ("Inherited %FIELDS can't override existing %FIELDS");
	}
	if ($base_attr->[$v] & _PRIVATE) {
	    $derived_attr->[$v] = undef;
	} else {
	    $derived_attr->[$v] = $base_attr->[$v];
	    $derived_fields->{$k} = $v;
	}
     }
d133 21
a153 60
    for my $pkg (sort keys %attr) {
	print "\n$pkg";
	if (@@{"$pkg\::ISA"}) {
	    print " (", join(", ", @@{"$pkg\::ISA"}), ")";
	}
	print "\n";
	my $fields = \%{"$pkg\::FIELDS"};
	for my $f (sort {$fields->{$a} <=> $fields->{$b}} keys %$fields) {
	    my $no = $fields->{$f};
	    print "   $no: $f";
	    my $fattr = $attr{$pkg}[$no];
	    if (defined $fattr) {
		my @@a;
		push(@@a, "public")    if $fattr & _PUBLIC;
		push(@@a, "private")   if $fattr & _PRIVATE;
		push(@@a, "inherited") if $no < $attr{$pkg}[0];
		print "\t(", join(", ", @@a), ")";
	    }
	    print "\n";
	}
    }
}

sub new {
    my $class = shift;
    $class = ref $class if ref $class;
    return bless [\%{$class . "::FIELDS"}], $class;
}

sub phash {
    my $h;
    my $v;
    if (@@_) {
	if (ref $_[0] eq 'ARRAY') {
	    my $a = shift;
	    @@$h{@@$a} = 1 .. @@$a;
	    if (@@_) {
		$v = shift;
		unless (! @@_ and ref $v eq 'ARRAY') {
		    require Carp;
		    Carp::croak ("Expected at most two array refs\n");
		}
	    }
	}
	else {
	    if (@@_ % 2) {
		require Carp;
		Carp::croak ("Odd number of elements initializing pseudo-hash\n");
	    }
	    my $i = 0;
	    @@$h{grep ++$i % 2, @@_} = 1 .. @@_ / 2;
	    $i = 0;
	    $v = [grep $i++ % 2, @@_];
	}
    }
    else {
	$h = {};
	$v = [];
    }
    [ $h, @@$v ];
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d175 2
a176 1
                warnings::warnif("Hides field '$f' in base class") ;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d130 1
a130 1
use 5.006_001;
d136 1
a136 1
$VERSION = "1.02";
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@a2 168
require 5.005;
use strict;
no strict 'refs';
unless( eval q{require warnings::register; warnings::register->import} ) {
    *warnings::warnif = sub { 
        require Carp;
        Carp::carp(@@_);
    }
}
use vars qw(%attr $VERSION);

$VERSION = '2.03';

# constant.pm is slow
sub PUBLIC     () { 2**0  }
sub PRIVATE    () { 2**1  }
sub INHERITED  () { 2**2  }
sub PROTECTED  () { 2**3  }


# The %attr hash holds the attributes of the currently assigned fields
# per class.  The hash is indexed by class names and the hash value is
# an array reference.  The first element in the array is the lowest field
# number not belonging to a base class.  The remaining elements' indices
# are the field numbers.  The values are integer bit masks, or undef
# in the case of base class private fields (which occupy a slot but are
# otherwise irrelevant to the class).

sub import {
    my $class = shift;
    return unless @@_;
    my $package = caller(0);
    # avoid possible typo warnings
    %{"$package\::FIELDS"} = () unless %{"$package\::FIELDS"};
    my $fields = \%{"$package\::FIELDS"};
    my $fattr = ($attr{$package} ||= [1]);
    my $next = @@$fattr;

    # Quiet pseudo-hash deprecation warning for uses of fields::new.
    bless \%{"$package\::FIELDS"}, 'pseudohash';

    if ($next > $fattr->[0]
	and ($fields->{$_[0]} || 0) >= $fattr->[0])
    {
	# There are already fields not belonging to base classes.
	# Looks like a possible module reload...
	$next = $fattr->[0];
    }
    foreach my $f (@@_) {
	my $fno = $fields->{$f};

	# Allow the module to be reloaded so long as field positions
	# have not changed.
	if ($fno and $fno != $next) {
	    require Carp;
            if ($fno < $fattr->[0]) {
              if ($] < 5.006001) {
                warn("Hides field '$f' in base class") if $^W;
              } else {
                warnings::warnif("Hides field '$f' in base class") ;
              }
            } else {
                Carp::croak("Field name '$f' already in use");
            }
	}
	$fields->{$f} = $next;
        $fattr->[$next] = ($f =~ /^_/) ? PRIVATE : PUBLIC;
	$next += 1;
    }
    if (@@$fattr > $next) {
	# Well, we gave them the benefit of the doubt by guessing the
	# module was reloaded, but they appear to be declaring fields
	# in more than one place.  We can't be sure (without some extra
	# bookkeeping) that the rest of the fields will be declared or
	# have the same positions, so punt.
	require Carp;
	Carp::croak ("Reloaded module must declare all fields at once");
    }
}

sub inherit {
    require base;
    goto &base::inherit_fields;
}

sub _dump  # sometimes useful for debugging
{
    for my $pkg (sort keys %attr) {
	print "\n$pkg";
	if (@@{"$pkg\::ISA"}) {
	    print " (", join(", ", @@{"$pkg\::ISA"}), ")";
	}
	print "\n";
	my $fields = \%{"$pkg\::FIELDS"};
	for my $f (sort {$fields->{$a} <=> $fields->{$b}} keys %$fields) {
	    my $no = $fields->{$f};
	    print "   $no: $f";
	    my $fattr = $attr{$pkg}[$no];
	    if (defined $fattr) {
		my @@a;
		push(@@a, "public")    if $fattr & PUBLIC;
		push(@@a, "private")   if $fattr & PRIVATE;
		push(@@a, "inherited") if $fattr & INHERITED;
		print "\t(", join(", ", @@a), ")";
	    }
	    print "\n";
	}
    }
}

if ($] < 5.009) {
  *new = sub {
    my $class = shift;
    $class = ref $class if ref $class;
    return bless [\%{$class . "::FIELDS"}], $class;
  }
} else {
  *new = sub {
    my $class = shift;
    $class = ref $class if ref $class;
    require Hash::Util;
    my $self = bless {}, $class;

    # The lock_keys() prototype won't work since we require Hash::Util :(
    &Hash::Util::lock_keys(\%$self, keys %{$class.'::FIELDS'});
    return $self;
  }
}

sub phash {
    die "Pseudo-hashes have been removed from Perl" if $] >= 5.009;
    my $h;
    my $v;
    if (@@_) {
       if (ref $_[0] eq 'ARRAY') {
           my $a = shift;
           @@$h{@@$a} = 1 .. @@$a;
           if (@@_) {
               $v = shift;
               unless (! @@_ and ref $v eq 'ARRAY') {
                   require Carp;
                   Carp::croak ("Expected at most two array refs\n");
               }
           }
       }
       else {
           if (@@_ % 2) {
               require Carp;
               Carp::croak ("Odd number of elements initializing pseudo-hash\n");
           }
           my $i = 0;
           @@$h{grep ++$i % 2, @@_} = 1 .. @@_ / 2;
           $i = 0;
           $v = [grep $i++ % 2, @@_];
       }
    }
    else {
       $h = {};
       $v = [];
    }
    [ $h, @@$v ];

}

1;

__END__

d24 1
a24 1
    my $var = Foo->new;
d27 1
a27 1
    # this will generate an error
a53 2
B<Only valid for perl before 5.9.0:>

d55 3
a57 4
hash element and a package with the same name as the type has
declared class fields using this pragma, then the operation is
turned into an array access at compile time.

d68 4
a71 8
B<Only valid for perls before 5.9.0:>

The effect of all this is that you can have objects with named
fields which are as compact and as fast arrays to access. This only
works as long as the objects are accessed through properly typed
variables. If the objects are not typed, access is only checked at
run time.

d75 1
a75 1
=over 4
d79 2
a80 11
B< perl before 5.9.0: > fields::new() creates and blesses a
pseudo-hash comprised of the fields declared using the C<fields>
pragma into the specified class.

B< perl 5.9.0 and higher: > fields::new() creates and blesses a
restricted-hash comprised of the fields declared using the C<fields>
pragma into the specified class.

This function is usable with or without pseudo-hashes.  It is the
recommended way to construct a fields-based object.

d87 1
a87 1
	my $self = shift;
a95 2
B< before perl 5.9.0: > 

d109 1
a109 1
       my $tag = fields::phash([qw(name rank ser_num)], [@@_]);
d116 2
a117 2
                            rank => "captain",
                            ser_num => 42);
a120 6
B< perl 5.9.0 and higher: >

Pseudo-hashes have been removed from Perl as of 5.10.  Consider using
restricted hashes or fields::new() instead.  Using fields::phash()
will cause an error.

d125 2
a126 1
L<base>
d129 157
@


1.1.1.6
log
@import perl 5.10.0 from CPAN
@
text
@d6 1
a6 1
unless( eval q{require warnings::register; warnings::register->import; 1} ) {
d14 1
a14 1
$VERSION = '2.13';
d45 1
a45 1
        and ($fields->{$_[0]} || 0) >= $fattr->[0])
d47 3
a49 3
        # There are already fields not belonging to base classes.
        # Looks like a possible module reload...
        $next = $fattr->[0];
d52 1
a52 1
        my $fno = $fields->{$f};
d54 4
a57 4
        # Allow the module to be reloaded so long as field positions
        # have not changed.
        if ($fno and $fno != $next) {
            require Carp;
d67 2
a68 2
        }
        $fields->{$f} = $next;
d70 1
a70 1
        $next += 1;
d73 7
a79 7
        # Well, we gave them the benefit of the doubt by guessing the
        # module was reloaded, but they appear to be declaring fields
        # in more than one place.  We can't be sure (without some extra
        # bookkeeping) that the rest of the fields will be declared or
        # have the same positions, so punt.
        require Carp;
        Carp::croak ("Reloaded module must declare all fields at once");
d91 19
a109 19
        print "\n$pkg";
        if (@@{"$pkg\::ISA"}) {
            print " (", join(", ", @@{"$pkg\::ISA"}), ")";
        }
        print "\n";
        my $fields = \%{"$pkg\::FIELDS"};
        for my $f (sort {$fields->{$a} <=> $fields->{$b}} keys %$fields) {
            my $no = $fields->{$f};
            print "   $no: $f";
            my $fattr = $attr{$pkg}[$no];
            if (defined $fattr) {
                my @@a;
                push(@@a, "public")    if $fattr & PUBLIC;
                push(@@a, "private")   if $fattr & PRIVATE;
                push(@@a, "inherited") if $fattr & INHERITED;
                print "\t(", join(", ", @@a), ")";
            }
            print "\n";
        }
d127 1
a127 1
    &Hash::Util::lock_keys(\%$self, _accessible_keys($class));
a131 8
sub _accessible_keys {
    my ($class) = @@_;
    return (
        keys %{$class.'::FIELDS'},
        map(_accessible_keys($_), @@{$class.'::ISA'}),
    );
}

d180 10
a189 10
        sub new {
            my Foo $self = shift;
            unless (ref $self) {
                $self = fields::new($self);
                $self->{_Foo_private} = "this is Foo's secret";
            }
            $self->{foo} = 10;
            $self->{bar} = 20;
            return $self;
        }
d202 9
a210 9
        use fields qw(baz _Bar_private);        # not shared with Foo
        sub new {
            my $class = shift;
            my $self = fields::new($class);
            $self->SUPER::new();                # init base fields
            $self->{baz} = 10;                  # init own fields
            $self->{_Bar_private} = "this is Bar's secret";
            return $self;
        }
d271 5
a275 5
        my $self = shift;
        $self = fields::new($self) unless ref $self;
        $self->{cat} = 'meow';                          # scalar element
        @@$self{'dog','bird'} = ('bark','tweet');        # slice
        return $self;
@


1.1.1.7
log
@import perl 5.10.1
@
text
@d14 1
a14 1
$VERSION = '2.14';
@


