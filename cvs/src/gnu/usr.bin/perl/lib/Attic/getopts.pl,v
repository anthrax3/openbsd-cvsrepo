head	1.7;
access;
symbols
	OPENBSD_5_3:1.6.0.10
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.8
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.6
	OPENBSD_5_0:1.6.0.4
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.2
	OPENBSD_4_9_BASE:1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.5.0.18
	OPENBSD_4_8_BASE:1.5
	OPENBSD_4_7:1.5.0.14
	OPENBSD_4_7_BASE:1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.5.0.16
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.12
	OPENBSD_4_5_BASE:1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.5.0.10
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.8
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.6
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.4
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.5
	OPENBSD_3_9:1.4.0.20
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.18
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.16
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.4.0.14
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.4.0.12
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.4.0.10
	OPENBSD_3_4_BASE:1.4
	OPENBSD_3_3:1.4.0.8
	OPENBSD_3_3_BASE:1.4
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.7
date	2013.03.25.20.40.55;	author sthen;	state dead;
branches;
next	1.6;

1.6
date	2010.09.24.15.06.59;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.25;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.11;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.00;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.34;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.34;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.53;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.37;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.21;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2006.03.28.18.48.36;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.48.35;	author millert;	state Exp;
branches;
next	;


desc
@@


1.7
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@;# getopts.pl - a better getopt.pl
#
# This library is no longer being maintained, and is included for backward
# compatibility with Perl 4 programs which may require it.
#
# In particular, this should not be used as an example of modern Perl
# programming techniques.
#
# Suggested alternatives: Getopt::Long  or  Getopt::Std

;# Usage:
;#      do Getopts('a:bc');  # -a takes arg. -b & -c not. Sets opt_* as a
;#                           #  side effect.

sub Getopts {
    local($argumentative) = @@_;
    local(@@args,$_,$first,$rest);
    local($errs) = 0;
    local($[) = 0;

    @@args = split( / */, $argumentative );
    while(@@ARGV && ($_ = $ARGV[0]) =~ /^-(.)(.*)/) {
		($first,$rest) = ($1,$2);
		$pos = index($argumentative,$first);
		if($pos >= $[) {
			if($args[$pos+1] eq ':') {
				shift(@@ARGV);
				if($rest eq '') {
					++$errs unless(@@ARGV);
					$rest = shift(@@ARGV);
				}
				eval "
				push(\@@opt_$first, \$rest);
				if (!defined \$opt_$first or \$opt_$first eq '') {
					\$opt_$first = \$rest;
				}
				else {
					\$opt_$first .= ' ' . \$rest;
				}
				";
			}
			else {
				eval "\$opt_$first = 1";
				if($rest eq '') {
					shift(@@ARGV);
				}
				else {
					$ARGV[0] = "-$rest";
				}
			}
		}
		else {
			print STDERR "Unknown option: $first\n";
			++$errs;
			if($rest ne '') {
				$ARGV[0] = "-$rest";
			}
			else {
				shift(@@ARGV);
			}
		}
	}
    $errs == 0;
}

1;
@


1.6
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.5
log
@merge in perl 5.8.8
@
text
@d10 1
a10 1
#
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d34 1
a34 1
				if(\$opt_$first eq '') {
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d19 1
d23 28
a50 15
	($first,$rest) = ($1,$2);
	$pos = index($argumentative,$first);
	if($pos >= 0) {
	    if($pos < $#args && $args[$pos+1] eq ':') {
		shift(@@ARGV);
		if($rest eq '') {
		    ++$errs unless @@ARGV;
		    $rest = shift(@@ARGV);
		}
		${"opt_$first"} = $rest;
	    }
	    else {
		${"opt_$first"} = 1;
		if($rest eq '') {
		    shift(@@ARGV);
d53 8
a60 1
		    $ARGV[0] = "-$rest";
a61 11
	    }
	}
	else {
	    print STDERR "Unknown option: $first\n";
	    ++$errs;
	    if($rest ne '') {
		$ARGV[0] = "-$rest";
	    }
	    else {
		shift(@@ARGV);
	    }
a62 1
    }
@


1.2
log
@perl 5.004_04
@
text
@d2 9
a10 1

@


1.1
log
@Initial revision
@
text
@a10 1
    local($[) = 0;
d16 2
a17 2
	if($pos >= $[) {
	    if($args[$pos+1] eq ':') {
d23 1
a23 1
		eval "\$opt_$first = \$rest;";
d26 1
a26 1
		eval "\$opt_$first = 1";
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d11 1
d17 2
a18 2
	if($pos >= 0) {
	    if($pos < $#args && $args[$pos+1] eq ':') {
d24 1
a24 1
		${"opt_$first"} = $rest;
d27 1
a27 1
		${"opt_$first"} = 1;
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d2 1
a2 9
#
# This library is no longer being maintained, and is included for backward
# compatibility with Perl 4 programs which may require it.
#
# In particular, this should not be used as an example of modern Perl
# programming techniques.
#
# Suggested alternatives: Getopt::Long  or  Getopt::Std
#
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a18 1
    local($[) = 0;
d22 15
a36 28
		($first,$rest) = ($1,$2);
		$pos = index($argumentative,$first);
		if($pos >= $[) {
			if($args[$pos+1] eq ':') {
				shift(@@ARGV);
				if($rest eq '') {
					++$errs unless(@@ARGV);
					$rest = shift(@@ARGV);
				}
				eval "
				push(\@@opt_$first, \$rest);
				if(\$opt_$first eq '') {
					\$opt_$first = \$rest;
				}
				else {
					\$opt_$first .= ' ' . \$rest;
				}
				";
			}
			else {
				eval "\$opt_$first = 1";
				if($rest eq '') {
					shift(@@ARGV);
				}
				else {
					$ARGV[0] = "-$rest";
				}
			}
d39 1
a39 8
			print STDERR "Unknown option: $first\n";
			++$errs;
			if($rest ne '') {
				$ARGV[0] = "-$rest";
			}
			else {
				shift(@@ARGV);
			}
d41 11
d53 1
@


1.1.1.5
log
@perl 5.8.8 import
@
text
@d34 1
a34 1
				if (!defined \$opt_$first or \$opt_$first eq '') {
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d10 1
a10 1

@


