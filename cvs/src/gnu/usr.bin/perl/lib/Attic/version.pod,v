head	1.2;
access;
symbols
	OPENBSD_5_6:1.1.1.4.0.8
	OPENBSD_5_6_BASE:1.1.1.4
	PERL_5_18_2:1.1.1.4
	PERL:1.1.1
	OPENBSD_5_5:1.1.1.4.0.6
	OPENBSD_5_5_BASE:1.1.1.4
	OPENBSD_5_4:1.1.1.4.0.2
	OPENBSD_5_4_BASE:1.1.1.4
	PERL_5_16_3:1.1.1.4
	OPENBSD_5_3:1.1.1.3.0.10
	OPENBSD_5_3_BASE:1.1.1.3
	OPENBSD_5_2:1.1.1.3.0.8
	OPENBSD_5_2_BASE:1.1.1.3
	OPENBSD_5_1_BASE:1.1.1.3
	OPENBSD_5_1:1.1.1.3.0.6
	OPENBSD_5_0:1.1.1.3.0.4
	OPENBSD_5_0_BASE:1.1.1.3
	OPENBSD_4_9:1.1.1.3.0.2
	OPENBSD_4_9_BASE:1.1.1.3
	PERL_5_12_2:1.1.1.3
	OPENBSD_4_8:1.1.1.2.0.4
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.2
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.1.0.6
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.2
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2014.11.17.20.57.06;	author afresh1;	state dead;
branches;
next	1.1;
commitid	QP75iYx42Uo7mMxO;

1.1
date	2008.09.29.17.18.31;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2008.09.29.17.18.31;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2009.10.12.18.10.49;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2010.09.24.14.48.35;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2013.03.25.20.08.54;	author sthen;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@=head1 NAME

version - Perl extension for Version Objects

=head1 SYNOPSIS

  use version;
  $version = version->new("12.2.1"); # must be quoted for Perl < 5.8.1
  print $version; 		# v12.2.1
  print $version->numify; 	# 12.002001
  if ( $version gt "12.2" )	# true

  $alphaver = version->new("1.02_03"); # must be quoted!
  print $alphaver;		# 1.02_0300
  print $alphaver->is_alpha();  # true
  
  $ver = qv("1.2.0");           # v1.2.0

  $perlver = version->new(5.005_03); # must not be quoted!
  print $perlver;		# 5.005030

=head1 DESCRIPTION

Overloaded version objects for all modern versions of Perl.  This module
implements all of the features of version objects which will be part
of Perl 5.10.0.

=head2 BEST PRACTICES

If you intend for your module to be used by different releases of Perl,
and/or for your $VERSION scalar to mean what you think it means, there 
are a few simple rules to follow:

=over 4

=item * Be consistent

Whichever of the two types of version objects that you choose to employ, 
you should stick to either L<Numeric Versions> or L<Extended Versions>
and not mix them together.  While this is I<possible>, it is very 
confusing to the average user.

If you intend to use L<Extended Versions>, you are strongly encouraged 
to use the L<qv()> operator with a quoted term, e.g.:

  use version; our $VERSION = qv("1.2.3");

on a single line as above. 

At the very least, decide on which of the several ways to initialize 
your version objects you prefer and stick with it.  It is also best to 
be explicit about what value you intend to assign your version object 
and to not rely on hidden behavior of the parser. 

=item * Be careful

If you are using Module::Build or ExtUtils::MakeMaker, so that you can
release your module to CPAN, you have to recognize that neither of those
programs completely handles version objects natively (yet).  If you use
version objects with Module::Build, you should add an explicit dependency
to the release of version.pm in your Build.PL:

  my $builder = Module::Build->new(
     ...
     requires => {
         ... ,
         'version'    => 0.50,
	 ...,
     },
     ...
  );

and it should Just Work(TM).  Module::Build will [hopefully soon] 
include full support for version objects; there are no current plans 
to patch ExtUtils::MakeMaker to support version objects.

=back

=head2 Using modules that use version.pm

As much as possible, the version.pm module remains compatible with all
current code.  However, if your module is using a module that has defined
C<$VERSION> using the version class, there are a couple of things to be
aware of.  For purposes of discussion, we will assume that we have the
following module installed:

  package Example;
  use version;  $VERSION = qv('1.2.2');
  ...module code here...
  1;

=over 4

=item Numeric versions always work

Code of the form:

  use Example 1.002003;

will always work correctly.  The C<use> will perform an automatic
C<$VERSION> comparison using the floating point number given as the first
term after the module name (e.g. above 1.002.003).  In this case, the
installed module is too old for the requested line, so you would see an
error like:

  Example version 1.002003 (v1.2.3) required--this is only version 1.002002 (v1.2.2)...

=item Extended version work sometimes

With Perl >= 5.6.2, you can also use a line like this:

  use Example 1.2.3;

and it will again work (i.e. give the error message as above), even with
releases of Perl which do not normally support v-strings (see L<What about
v-strings> below).  This has to do with that fact that C<use> only checks
to see if the second term I<looks like a number> and passes that to the
replacement L<UNIVERSAL::VERSION>.  This is not true in Perl 5.005_04,
however, so you are B<strongly encouraged> to always use a numeric version
in your code, even for those versions of Perl which support the extended
version.

=back

=head2 What IS a version

For the purposes of this module, a version "number" is a sequence of
positive integer values separated by one or more decimal points and 
optionally a single underscore.  This corresponds to what Perl itself 
uses for a version, as well as extending the "version as number" that 
is discussed in the various editions of the Camel book.

There are actually two distinct kinds of version objects:

=over 4

=item * Numeric Versions

Any initial parameter which "looks like a number", see L<Numeric
Versions>.  This also covers versions with a single decimal point and
a single embedded underscore, see L<Numeric Alpha Versions>, even though
these must be quoted to preserve the underscore formatting.

=item * Extended Versions

Any initial parameter which contains more than one decimal point
and an optional embedded underscore, see L<Extended Versions>.  This 
is what is commonly used in most open source software as the "external"
version (the one used as part of the tag or tarfile name).  The use
of the exported L<qv()> function also produces this kind of version
object.

=back

Both of these methods will produce similar version objects, in that
the default stringification will yield the version L<Normal Form> only 
if required:

  $v  = version->new(1.002);     # 1.002, but compares like 1.2.0
  $v  = version->new(1.002003);  # 1.002003
  $v2 = version->new("1.2.3");   # v1.2.3

In specific, version numbers initialized as L<Numeric Versions> will
stringify as they were originally created (i.e. the same string that was
passed to C<new()>.  Version numbers initialized as L<Extended Versions>
will be stringified as L<Normal Form>.

=head2 Numeric Versions

These correspond to historical versions of Perl itself prior to 5.6.0,
as well as all other modules which follow the Camel rules for the
$VERSION scalar.  A numeric version is initialized with what looks like
a floating point number.  Leading zeros B<are> significant and trailing
zeros are implied so that a minimum of three places is maintained
between subversions.  What this means is that any subversion (digits
to the right of the decimal place) that contains less than three digits
will have trailing zeros added to make up the difference, but only for
purposes of comparison with other version objects.  For example:

                                   # Prints     Equivalent to  
  $v = version->new(      1.2);    # 1.2        v1.200.0
  $v = version->new(     1.02);    # 1.02       v1.20.0
  $v = version->new(    1.002);    # 1.002      v1.2.0
  $v = version->new(   1.0023);    # 1.0023     v1.2.300
  $v = version->new(  1.00203);    # 1.00203    v1.2.30
  $v = version->new( 1.002003);    # 1.002003   v1.2.3

All of the preceding examples are true whether or not the input value is 
quoted.  The important feature is that the input value contains only a 
single decimal.  See also L<Alpha Versions> for how to handle 

IMPORTANT NOTE: As shown above, if your numeric version contains more 
than 3 significant digits after the decimal place, it will be split on 
each multiple of 3, so 1.0003 is equivalent to v1.0.300, due to the need 
to remain compatible with Perl's own 5.005_03 == 5.5.30 interpretation.  
Any trailing zeros are ignored for mathematical comparison purposes.

=head2 Extended Versions

These are the newest form of versions, and correspond to Perl's own
version style beginning with 5.6.0.  Starting with Perl 5.10.0,
and most likely Perl 6, this is likely to be the preferred form.  This
method normally requires that the input parameter be quoted, although 
Perl's after 5.8.1 can use v-strings as a special form of quoting, but
this is highly discouraged.

Unlike L<Numeric Versions>, Extended Versions have more than
a single decimal point, e.g.:

                                   # Prints
  $v = version->new( "v1.200");    # v1.200.0
  $v = version->new("v1.20.0");    # v1.20.0
  $v = qv("v1.2.3");               # v1.2.3
  $v = qv("1.2.3");                # v1.2.3
  $v = qv("1.20");                 # v1.20.0

In general, Extended Versions permit the greatest amount of freedom
to specify a version, whereas Numeric Versions enforce a certain
uniformity.  See also L<New Operator> for an additional method of
initializing version objects.

Just like L<Numeric Versions>, Extended Versions can be used as 
L<Alpha Versions>.

=head2 Numeric Alpha Versions

The one time that a numeric version must be quoted is when a alpha form is
used with an otherwise numeric version (i.e. a single decimal point).  This
is commonly used for CPAN releases, where CPAN or CPANPLUS will ignore alpha
versions for automatic updating purposes.  Since some developers have used
only two significant decimal places for their non-alpha releases, the
version object will automatically take that into account if the initializer
is quoted.  For example Module::Example was released to CPAN with the
following sequence of $VERSION's:

  # $VERSION    Stringified
  0.01          0.01
  0.02          0.02
  0.02_01       0.02_01
  0.02_02       0.02_02
  0.03          0.03
  etc.

The stringified form of numeric versions will always be the same string
that was used to initialize the version object.

=head2 Object Methods

Overloading has been used with version objects to provide a natural
interface for their use.  All mathematical operations are forbidden,
since they don't make any sense for base version objects.  Consequently,
there is no overloaded numification available.  If you want to use a
version object in a numeric context for some reason, see the L<numify>
object method.

=over 4

=item * New Operator

Like all OO interfaces, the new() operator is used to initialize
version objects.  One way to increment versions when programming is to
use the CVS variable $Revision, which is automatically incremented by
CVS every time the file is committed to the repository.

In order to facilitate this feature, the following
code can be employed:

  $VERSION = version->new(qw$Revision: 2.7 $);

and the version object will be created as if the following code
were used:

  $VERSION = version->new("v2.7");

In other words, the version will be automatically parsed out of the
string, and it will be quoted to preserve the meaning CVS normally
carries for versions.  The CVS $Revision$ increments differently from
numeric versions (i.e. 1.10 follows 1.9), so it must be handled as if
it were a L<Extended Version>.

A new version object can be created as a copy of an existing version
object, either as a class method:

  $v1 = version->new(12.3);
  $v2 = version->new($v1);

or as an object method:

  $v1 = version->new(12.3);
  $v2 = $v1->new(12.3);

and in each case, $v1 and $v2 will be identical.  NOTE: if you create
a new object using an existing object like this:

  $v2 = $v1->new();

the new object B<will not> be a clone of the existing object.  In the
example case, $v2 will be an empty object of the same type as $v1.

=back

=over 4

=item * qv()

An alternate way to create a new version object is through the exported
qv() sub.  This is not strictly like other q? operators (like qq, qw),
in that the only delimiters supported are parentheses (or spaces).  It is
the best way to initialize a short version without triggering the floating
point interpretation.  For example:

  $v1 = qv(1.2);         # 1.2.0
  $v2 = qv("1.2");       # also 1.2.0

As you can see, either a bare number or a quoted string can usually 
be used interchangably, except in the case of a trailing zero, which
must be quoted to be converted properly.  For this reason, it is strongly
recommended that all initializers to qv() be quoted strings instead of
bare numbers.

To prevent the C<qv()> function from being exported to the caller's namespace,
either use version with a null parameter:

  use version ();

or just require version, like this:

  require version;

Both methods will prevent the import() method from firing and exporting the
C<qv()> sub.  This is true of subclasses of version as well, see
L<SUBCLASSING> for details.

=back

For the subsequent examples, the following three objects will be used:

  $ver   = version->new("1.2.3.4"); # see "Quoting" below
  $alpha = version->new("1.2.3_4"); # see "Alpha versions" below
  $nver  = version->new(1.002);     # see "Numeric Versions" above

=over 4

=item * Normal Form

For any version object which is initialized with multiple decimal
places (either quoted or if possible v-string), or initialized using
the L<qv()> operator, the stringified representation is returned in
a normalized or reduced form (no extraneous zeros), and with a leading 'v':

  print $ver->normal;         # prints as v1.2.3.4
  print $ver->stringify;      # ditto
  print $ver;                 # ditto
  print $nver->normal;        # prints as v1.2.0
  print $nver->stringify;     # prints as 1.002, see "Stringification" 

In order to preserve the meaning of the processed version, the 
normalized representation will always contain at least three sub terms.
In other words, the following is guaranteed to always be true:

  my $newver = version->new($ver->stringify);
  if ($newver eq $ver ) # always true
    {...}

=back

=over 4

=item * Numification

Although all mathematical operations on version objects are forbidden
by default, it is possible to retrieve a number which corresponds 
to the version object through the use of the $obj->numify
method.  For formatting purposes, when displaying a number which
corresponds a version object, all sub versions are assumed to have
three decimal places.  So for example:

  print $ver->numify;         # prints 1.002003004
  print $nver->numify;        # prints 1.002

Unlike the stringification operator, there is never any need to append
trailing zeros to preserve the correct version value.

=back

=over 4

=item * Stringification

The default stringification for version objects returns exactly the same
string as was used to create it, whether you used C<new()> or C<qv()>,
with one exception.  The sole exception is if the object was created using
C<qv()> and the initializer did not have two decimal places or a leading
'v' (both optional), then the stringified form will have a leading 'v'
prepended, in order to support round-trip processing.

For example:

  Initialized as          Stringifies to
  ==============          ==============
  version->new("1.2")       1.2
  version->new("v1.2")     v1.2
  qv("1.2.3")               1.2.3
  qv("v1.3.5")             v1.3.5
  qv("1.2")                v1.2   ### exceptional case 

See also L<UNIVERSAL::VERSION>, as this also returns the stringified form
when used as a class method.

=back

=over 4

=item * Comparison operators

Both C<cmp> and C<E<lt>=E<gt>> operators perform the same comparison between
terms (upgrading to a version object automatically).  Perl automatically
generates all of the other comparison operators based on those two.
In addition to the obvious equalities listed below, appending a single
trailing 0 term does not change the value of a version for comparison
purposes.  In other words "v1.2" and "1.2.0" will compare as identical.

For example, the following relations hold:

  As Number        As String           Truth Value
  -------------    ----------------    -----------
  $ver >  1.0      $ver gt "1.0"       true
  $ver <  2.5      $ver lt             true
  $ver != 1.3      $ver ne "1.3"       true
  $ver == 1.2      $ver eq "1.2"       false
  $ver == 1.2.3.4  $ver eq "1.2.3.4"   see discussion below

It is probably best to chose either the numeric notation or the string
notation and stick with it, to reduce confusion.  Perl6 version objects
B<may> only support numeric comparisons.  See also L<Quoting>.

WARNING: Comparing version with unequal numbers of decimal points (whether
explicitly or implicitly initialized), may yield unexpected results at
first glance.  For example, the following inequalities hold:

  version->new(0.96)     > version->new(0.95); # 0.960.0 > 0.950.0
  version->new("0.96.1") < version->new(0.95); # 0.096.1 < 0.950.0

For this reason, it is best to use either exclusively L<Numeric Versions> or
L<Extended Versions> with multiple decimal points.

=back

=over 4

=item * Logical Operators 

If you need to test whether a version object
has been initialized, you can simply test it directly:

  $vobj = version->new($something);
  if ( $vobj )   # true only if $something was non-blank

You can also test whether a version object is an L<Alpha version>, for
example to prevent the use of some feature not present in the main
release:

  $vobj = version->new("1.2_3"); # MUST QUOTE
  ...later...
  if ( $vobj->is_alpha )       # True

=back

=head2 Quoting

Because of the nature of the Perl parsing and tokenizing routines,
certain initialization values B<must> be quoted in order to correctly
parse as the intended version, especially when using the L<qv()> operator.
In all cases, a floating point number passed to version->new() will be
identically converted whether or not the value itself is quoted.  This is
not true for L<qv()>, however, when trailing zeros would be stripped on
an unquoted input, which would result in a very different version object.

In addition, in order to be compatible with earlier Perl version styles,
any use of versions of the form 5.006001 will be translated as v5.6.1.  
In other words, a version with a single decimal point will be parsed as
implicitly having three digits between subversions, but only for internal
comparison purposes.

The complicating factor is that in bare numbers (i.e. unquoted), the
underscore is a legal numeric character and is automatically stripped
by the Perl tokenizer before the version code is called.  However, if
a number containing one or more decimals and an underscore is quoted, i.e.
not bare, that is considered a L<Alpha Version> and the underscore is
significant.

If you use a mathematic formula that resolves to a floating point number,
you are dependent on Perl's conversion routines to yield the version you
expect.  You are pretty safe by dividing by a power of 10, for example,
but other operations are not likely to be what you intend.  For example:

  $VERSION = version->new((qw$Revision: 1.4)[1]/10);
  print $VERSION;          # yields 0.14
  $V2 = version->new(100/9); # Integer overflow in decimal number
  print $V2;               # yields something like 11.111.111.100

Perl 5.8.1 and beyond will be able to automatically quote v-strings but
that is not possible in earlier versions of Perl.  In other words:

  $version = version->new("v2.5.4");  # legal in all versions of Perl
  $newvers = version->new(v2.5.4);    # legal only in Perl >= 5.8.1

=head2 What about v-strings?

Beginning with Perl 5.6.0, an alternate method to code arbitrary strings
of bytes was introduced, called v-strings.  They were intended to be an
easy way to enter, for example, Unicode strings (which contain two bytes
per character).  Some programs have used them to encode printer control
characters (e.g. CRLF).  They were also intended to be used for $VERSION,
but their use as such has been problematic from the start.

There are two ways to enter v-strings: a bare number with two or more
decimal points, or a bare number with one or more decimal points and a 
leading 'v' character (also bare).  For example:

  $vs1 = 1.2.3; # encoded as \1\2\3
  $vs2 = v1.2;  # encoded as \1\2 

However, the use of bare v-strings to initialize version objects is
B<strongly> discouraged in all circumstances (especially the leading 
'v' style), since the meaning will change depending on which Perl you 
are running.  It is better to directly use L<"Extended Versions"> to 
ensure the proper interpretation.

If you insist on using bare v-strings with Perl > 5.6.0, be aware of the 
following limitations:

1) For Perl releases 5.6.0 through 5.8.0, the v-string code merely guesses, 
based on some characteristics of v-strings.  You B<must> use a three part
version, e.g. 1.2.3 or v1.2.3 in order for this heuristic to be successful.

2) For Perl releases 5.8.1 and later, v-strings have changed in the Perl
core to be magical, which means that the version.pm code can automatically
determine whether the v-string encoding was used.

3) In all cases, a version created using v-strings will have a stringified
form that has a leading 'v' character, for the simple reason that sometimes
it is impossible to tell whether one was present initially.

=head2 Types of Versions Objects

There are two types of Version Objects:

=over 4

=item * Ordinary versions

These are the versions that normal modules will use.  Can contain as
many subversions as required.  In particular, those using RCS/CVS can
use the following:

  $VERSION = version->new(qw$Revision: 2.7 $);

and the current RCS Revision for that file will be inserted
automatically.  If the file has been moved to a branch, the Revision
will have three or more elements; otherwise, it will have only two.
This allows you to automatically increment your module version by
using the Revision number from the primary file in a distribution, see
L<ExtUtils::MakeMaker/"VERSION_FROM">.

=item * Alpha Versions

For module authors using CPAN, the convention has been to note
unstable releases with an underscore in the version string, see
L<CPAN>.  Alpha releases will test as being newer than the more recent
stable release, and less than the next stable release.  For example:

  $alphaver = version->new("12.03_01"); # must be quoted

obeys the relationship

  12.03 < $alphaver < 12.04

Alpha versions with a single decimal point will be treated exactly as if
they were L<Numeric Versions>, for parsing and output purposes.  The
underscore will be output when an alpha version is stringified, in the same
place as it was when input.

Alpha versions with more than a single decimal point will be treated 
exactly as if they were L<Extended Versions>, and will display without any
trailing (or leading) zeros, in the L<Version Normal> form.  For example,

  $newver = version->new("12.3.1_1");
  print $newver; # v12.3.1_1

=back

=head2 Replacement UNIVERSAL::VERSION

In addition to the version objects, this modules also replaces the core
UNIVERSAL::VERSION function with one that uses version objects for its
comparisons.  The return from this operator is always the stringified form,
but the warning message generated includes either the stringified form or
the normal form, depending on how it was called.

For example:

  package Foo;
  $VERSION = 1.2;

  package Bar;
  $VERSION = "1.3.5"; # works with all Perl's (since it is quoted)

  package main;
  use version;

  print $Foo::VERSION; # prints 1.2

  print $Bar::VERSION; # prints 1.003005

  eval "use foo 10";
  print $@@; # prints "foo version 10 required..."
  eval "use foo 1.3.5; # work in Perl 5.6.1 or better
  print $@@; # prints "foo version 1.3.5 required..."

  eval "use bar 1.3.6";
  print $@@; # prints "bar version 1.3.6 required..."
  eval "use bar 1.004"; # note numeric version
  print $@@; # prints "bar version 1.004 required..."


IMPORTANT NOTE: This may mean that code which searches for a specific
string (to determine whether a given module is available) may need to be
changed.  It is always better to use the built-in comparison implicit in
C<use> or C<require>, rather than manually poking at C<class->VERSION>
and then doing a comparison yourself.

The replacement UNIVERSAL::VERSION, when used as a function, like this:

  print $module->VERSION;

will also exclusively return the stringified form.  See L<Stringification>
for more details.

=head1 SUBCLASSING

This module is specifically designed and tested to be easily subclassed.
In practice, you only need to override the methods you want to change, but
you have to take some care when overriding new() (since that is where all
of the parsing takes place).  For example, this is a perfect acceptable
derived class:

  package myversion;
  use base version;
  sub new { 
      my($self,$n)=@@_;
      my $obj;
      # perform any special input handling here
      $obj = $self->SUPER::new($n);
      # and/or add additional hash elements here
      return $obj;
  }

See also L<version::AlphaBeta> on CPAN for an alternate representation of
version strings.

B<NOTE:> Although the L<qv> operator is not a true class method, but rather a
function exported into the caller's namespace, a subclass of version will 
inherit an import() function which will perform the correct magic on behalf
of the subclass.

=head1 EXPORT

qv - Extended Version initialization operator

=head1 AUTHOR

John Peacock E<lt>jpeacock@@cpan.orgE<gt>

=head1 SEE ALSO

L<perl>.

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import perl 5.10.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.1
@
text
@d7 11
a17 1
  # Parsing version strings (decimal or dotted-decimal)
d19 2
a20 2
  use version 0.77; # get latest bug-fixes and API
  $ver = version->parse($string)
d22 1
a22 1
  # Declaring a dotted-decimal $VERSION (keep on one line!)
d24 52
a75 3
  use version 0.77; our $VERSION = version->declare("v1.2.3"); # formal
  use version 0.77; our $VERSION = qv("v1.2.3");               # shorthand
  use version 0.77; our $VERSION = qv("v1.2_3");               # alpha
d77 1
a77 1
  # Declaring an old-style decimal $VERSION (use quotes!)
d79 1
a79 2
  use version 0.77; our $VERSION = version->parse("1.0203");   # formal
  use version 0.77; our $VERSION = version->parse("1.02_03");  # alpha
d81 5
a85 1
  # Comparing mixed version styles (decimals, dotted-decimals, objects)
d87 4
a90 3
  if ( version->parse($v1) == version->parse($v2) ) {
    # do stuff
  }
d92 1
a92 1
  # Sorting mixed version styles
d94 1
a94 3
  @@ordered = sort { version->parse($a) <=> version->parse($b) } @@list;

=head1 DESCRIPTION
d96 1
a96 6
Version objects were added to Perl in 5.10.  This module implements version
objects for older version of Perl and provides the version object API for all
versions of Perl.  All previous releases before 0.74 are deprecated and should
not be used due to incompatible API changes.  Version 0.77 introduces the new
'parse' and 'declare' methods to standardize usage.  You are strongly urged to
set 0.77 as a minimum in your code, e.g. 
d98 1
a98 1
  use version 0.77; # even for Perl v.5.10.0
d100 5
a104 1
=head1 TYPES OF VERSION OBJECTS
d106 1
a106 2
There are two different types of version objects, corresponding to the two
different styles of versions in use:
d108 1
a108 1
=over 2
d110 1
a110 1
=item Decimal Versions
d112 1
a112 3
The classic floating-point number $VERSION.  The advantage to this style is
that you don't need to do anything special, just type a number (without
quotes) into your source file.
d114 8
a121 7
=item Dotted Decimal Versions

The more modern form of version assignment, with 3 (or potentially more)
integers seperated by decimal points (e.g. v1.2.3).  This is the form that
Perl itself has used since 5.6.0 was released.  The leading "v" is now 
strongly recommended for clarity, and will throw a warning in a future
release if omitted.
d125 1
a125 1
See L<VERSION OBJECT DETAILS> for further information.
d127 5
a131 1
=head1 DECLARING VERSIONS
d133 1
a133 3
If you have a module that uses a decimal $VERSION (floating point), and you
do not intend to ever change that, this module is not for you.  There is
nothing that version.pm gains you over a simple $VERSION assignment:
d135 1
a135 1
  our $VERSION = 1.02;
d137 1
a137 2
Since Perl v5.10.0 includes the version.pm comparison logic anyways, 
you don't need to do anything at all.
d139 4
a142 1
=head2 How to convert a module from decimal to dotted-decimal
d144 1
a144 3
If you have used a decimal $VERSION in the past and wish to switch to a
dotted-decimal $VERSION, then you need to make a one-time conversion to
the new format. 
d146 6
a151 4
B<Important Note>: you must ensure that your new $VERSION is numerically
greater than your current decimal $VERSION; this is not always obvious. First,
convert your old decimal version (e.g. 1.02) to a normalized dotted-decimal
form:
d153 1
a153 2
  $ perl -Mversion -e 'print version->parse("1.02")->normal'
  v1.20.0
d155 136
a290 1
Then increment any of the dotted-decimal components (v1.20.1 or v1.21.0).
d292 2
a293 1
=head2 How to C<declare()> a dotted-decimal version
d295 1
a295 1
  use version 0.77; our $VERSION = version->declare("v1.2.3");
d297 2
a298 6
The C<declare()> method always creates dotted-decimal version objects.  When
used in a module, you B<must> put it on the same line as "use version" to
ensure that $VERSION is read correctly by PAUSE and installer tools.  You
should also add 'version' to the 'configure_requires' section of your
module metadata file.  See instructions in L<ExtUtils::MakeMaker> or
L<Module::Build> for details.
d300 1
a300 3
B<Important Note>: Even if you pass in what looks like a decimal number
("1.2"), a dotted-decimal will be created ("v1.200.0"). To avoid confusion
or unintentional errors on older Perls, follow these guidelines:
d302 1
a302 1
=over 2
d304 1
a304 1
=item *
d306 5
a310 1
Always use a dotted-decimal with (at least) three components
d312 2
a313 1
=item *
d315 5
a319 1
Always use a leading-v
d321 2
a322 1
=item *
d324 1
a324 1
Always quote the version
d326 1
a326 1
=back
d328 1
a328 3
If you really insist on using version.pm with an ordinary decimal version,
use C<parse()> instead of declare.  See the L<PARSING AND COMPARING VERSIONS>
for details.
d330 3
a332 3
See also L<VERSION OBJECT DETAILS> for more on version number conversion,
quoting, calculated version numbers and declaring developer or "alpha" version
numbers.
d334 1
a334 1
=head1 PARSING AND COMPARING VERSIONS
d336 1
a336 3
If you need to compare version numbers, but can't be sure whether they are
expressed as numbers, strings, v-strings or version objects,  then you can
use version.pm to parse them all into objects for comparison.
d338 26
a363 1
=head2 How to C<parse()> a version
d365 1
a365 2
The C<parse()> method takes in anything that might be a version and returns
a corresponding version object, doing any necessary conversion along the way.
d367 1
a367 1
=over 2
d369 1
a369 1
=item *
d371 6
a376 4
Dotted-decimal: bare v-strings (v1.2.3) and strings with more than one
decimal point and a leading 'v' ("v1.2.3"); NOTE you can technically use a
v-string or strings with a leading-v and only one decimal point (v1.2 or
"v1.2"), but you will confuse both yourself and others.
d378 2
a379 1
=item *
d381 2
a382 1
Decimal: regular decimal numbers (literal or in a string)
d386 1
a386 1
Some examples:
d388 1
a388 8
  $variable   version->parse($variable)
  ---------   -------------------------
  1.23        v1.230.0
  "1.23"      v1.230.0
  v1.23       v1.23.0
  "v1.23"     v1.23.0
  "1.2.3"     v1.2.3
  "v1.2.3"    v1.2.3
d390 16
a405 1
See L<VERSION OBJECT DETAILS> for more on version number conversion.
d407 4
a410 1
=head2 How to compare version objects
d412 1
a412 3
Version objects overload the C<cmp> and C<< E<lt>=E<gt> >> operators.  Perl
automatically generates all of the other comparison operators based on those
two so all the normal logical comparisons will work.
d414 1
a414 3
  if ( version->parse($v1) == version->parse($v2) ) {
    # do stuff
  }
d416 24
a439 3
If a version object is compared against a non-version object, the non-object
term will be converted to a version object using C<parse()>.  This may give
surprising results:
d441 2
a442 2
  $v1 = version->parse("v0.95.0");
  $bool = $v1 < 0.96; # FALSE since 0.96 is v0.960.0
d444 2
a445 1
Always comparing to a version object will help avoid surprises:
d447 1
a447 1
  $bool = $v1 < version->parse("v0.96.0"); # TRUE
d449 1
a449 1
=head1 VERSION OBJECT DETAILS
d451 1
a451 1
=head2 Equivalence between Decimal and Dotted-Decimal Versions
d453 2
a454 3
When Perl 5.6.0 was released, the decision was made to provide a
transformation between the old-style decimal versions and new-style
dotted-decimal versions:
d456 2
a457 2
  5.6.0    == 5.006000
  5.005_04 == 5.5.40
d459 3
a461 4
The floating point number is taken and split first on the single decimal
place, then each group of three digits to the right of the decimal makes up
the next digit, and so on until the number of significant digits is exhausted,
B<plus> enough trailing zeros to reach the next multiple of three.
d463 3
a465 2
This was the method that version.pm adopted as well.  Some examples may be
helpful:
d467 1
a467 9
                            equivalent
  decimal    zero-padded    dotted-decimal
  -------    -----------    --------------
  1.2        1.200          v1.200.0
  1.02       1.020          v1.20.0
  1.002      1.002          v1.2.0
  1.0023     1.002300       v1.2.300
  1.00203    1.002030       v1.2.30
  1.002003   1.002003       v1.2.3
d469 1
a469 1
=head2 Quoting rules
d473 18
a490 10
parse as the intended version, especially when using the L<declare> or
L<qv> methods.  While you do not have to quote decimal numbers when
creating version objects, it is always safe to quote B<all> initial values
when using version.pm methods, as this will ensure that what you type is
what is used.

Additionally, if you quote your initializer, then the quoted value that goes
B<in> will be be exactly what comes B<out> when your $VERSION is printed
(stringified).  If you do not quote your value, Perl's normal numeric handling
comes into play and you may not get back what you were expecting.
d502 1
a502 1
Perl 5.8.1 and beyond are able to automatically quote v-strings but
d510 7
d525 4
a528 3
B<strongly> discouraged in all circumstances.  Also, bare
v-strings are not completely supported in any version of Perl prior to
5.8.1.
d545 1
a545 1
=head2 Alpha versions
d547 1
a547 6
For module authors using CPAN, the convention has been to note unstable
releases with an underscore in the version string. (See L<CPAN>.)  version.pm
follows this convention and alpha releases will test as being newer than the
more recent stable release, and less than the next stable release.  For
dotted-decimal versions, only the last element may be separated by an
underscore:
d549 1
a549 2
  # Declaring
  use version 0.77; our $VERSION = version->declare("v1.2_3");
d551 1
a551 3
  # Parsing
  $v1 = version->parse("v1.2_3");
  $v1 = version->parse("1.002_003");
d553 3
a555 1
=head1 OBJECT METHODS
d557 1
a557 1
=head2 is_alpha()
d559 6
a564 1
True if and only if the version object was created with a underscore, e.g.
d566 1
a566 2
  version->parse('1.002_03')->is_alpha;  # TRUE
  version->declare('1.2.3_4')->is_alpha; # TRUE
d568 4
a571 1
=head2 is_qv()
d573 1
a573 1
True only if the version object is a dotted-decimal version, e.g.
d575 1
a575 4
  version->parse('v1.2.0')->is_qv;        # TRUE
  version->declare('v1.2')->is_qv;       # TRUE
  qv('1.2')->is_qv;                      # TRUE
  version->parse('1.2')->is_qv;          # FALSE
d577 1
a577 1
=head2 normal()
d579 4
a582 2
Returns a string with a standard 'normalized' dotted-decimal form with a
leading-v and at least 3 components.
d584 3
a586 2
 version->declare('v1.2')->normal;  # v1.2.0
 version->parse('1.2')->normal;     # v1.200.0
d588 2
a589 1
=head2 numify()
d591 24
a614 2
Returns a value representing the object in a pure decimal form without
trailing zeroes.
d616 4
a619 2
 version->declare('v1.2')->numify;  # 1.002
 version->parse('1.2')->numify;     # 1.2
d621 4
a624 1
=head2 stringify()
a625 4
Returns a string that is as close to the original representation as possible.
If the original representation was a numeric literal, it will be returned the
way perl would normally represent it in a string.  This method is used whenever
a version object is interpolated into a string.
d627 5
a631 3
 version->declare('v1.2')->stringify;    # v1.2
 version->parse('1.200')->stringify;     # 1.200
 version->parse(1.02_30)->stringify;     # 1.023
d633 1
a633 1
=head1 EXPORTED FUNCTIONS
d635 1
a635 1
=head2 qv()
d637 2
a638 3
This function is no longer recommended for use, but is maintained for
compatibility with existing code.  If you do not want to have it exported
to your namespace, use this form:
d640 30
a669 1
  use version 0.77 ();
a675 2

L<version::Internal>.
@


1.1.1.3
log
@Perl 5.12.2 from CPAN
@
text
@a19 1
  our $VERSION = "1.0203";                                     # recommended
d40 1
a40 1
set 0.77 as a minimum in your code, e.g.
d54 2
a55 3
that you don't need to do anything special, just type a number into your
source file.  Quoting is recommended, as it ensures that trailing zeroes
("1.50") are preserved in any warnings or other output.
d61 1
a61 1
Perl itself has used since 5.6.0 was released.  The leading "v" is now
d67 2
d75 1
a75 1
  our $VERSION = "1.02";
d77 1
a77 1
Since Perl v5.10.0 includes the version.pm comparison logic anyways,
d84 1
a84 1
the new format.
d131 1
a131 1
See also L<version::Internals> for more on version number conversion,
d138 1
a138 1
expressed as numbers, strings, v-strings or version objects,  then you should
d172 1
a172 38
See L<version::Internals> for more on version number conversion.

=head2 How to check for a legal version string

If you do not want to actually create a full blown version object, but
would still like to verify that a given string meets the criteria to
be parsed as a version, there are two helper functions that can be
employed directly:

=over 4

=item C<is_lax()>

The lax criteria corresponds to what is currently allowed by the
version parser.  All of the following formats are acceptable
for dotted-decimal formats strings:

    v1.2
    1.2345.6
    v1.23_4
    1.2345
    1.2345_01

=item C<is_strict()>

If you want to limit youself to a much more narrow definition of what
a version string constitutes, C<is_strict()> is limited to version
strings like the following list:

    v1.234.5
    2.3456

=back

See L<version::Internals> for details of the regular expressions
that define the legal version string forms, as well as how to use
those regular expressions in your own code if C<is_lax()> and
C<is_strict()> are not sufficient for your needs.
d195 1
a195 3
Note that "alpha" version objects (where the version string contains
a trailing underscore segment) compare as less than the equivalent
version without an underscore:
d197 1
a197 1
  $bool = version->parse("1.23_45") < version->parse("1.2345"); # TRUE
d199 100
a298 1
See L<version::Internals> for more details on "alpha" versions.
a354 16
=head2 is_lax()

(Not exported by default)

This function takes a scalar argument and returns a boolean value indicating
whether the argument meets the "lax" rules for a version number.  Leading and
trailing spaces are not allowed.

=head2 is_strict()

(Not exported by default)

This function takes a scalar argument and returns a boolean value indicating
whether the argument meets the "strict" rules for a version number.  Leading
and trailing spaces are not allowed.

d361 1
a361 1
L<version::Internals>.
@


1.1.1.4
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d14 3
a16 3
  use version; our $VERSION = version->declare("v1.2.3"); # formal
  use version; our $VERSION = qv("v1.2.3");               # shorthand
  use version; our $VERSION = qv("v1.2_3");               # alpha
d21 2
a22 2
  use version; our $VERSION = version->parse("1.0203");   # formal
  use version; our $VERSION = version->parse("1.02_03");  # alpha
d62 2
a63 2
integers separated by decimal points (e.g. v1.2.3).  This is the form that
Perl itself has used since 5.6.0 was released.  The leading 'v' is now
d65 1
a65 2
release if omitted.  A leading 'v' character is required to pass the
L</is_strict()> test.
d98 1
a98 1
  use version; our $VERSION = version->declare("v1.2.3");
d197 1
a197 1
If you want to limit yourself to a much more narrow definition of what
d213 1
a213 1
Version objects overload the C<cmp> and C<< <=> >> operators.  Perl
@


