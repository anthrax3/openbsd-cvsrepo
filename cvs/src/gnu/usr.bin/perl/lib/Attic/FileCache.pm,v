head	1.9;
access;
symbols
	OPENBSD_4_8:1.8.0.4
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.7.0.6
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.6.0.10
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.8
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.6
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.5.0.8
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.6
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.2.0.20
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.18
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.16
	OPENBSD_3_0_BASE:1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.2.0.14
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.9
date	2010.09.24.14.59.33;	author millert;	state dead;
branches;
next	1.8;

1.8
date	2009.10.12.18.24.38;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2008.09.29.17.36.09;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2006.03.28.19.23.05;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.08.09.18.09.28;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.03.03.02.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.56.43;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.30;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.30;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.43.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.46.41;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2006.03.28.18.48.35;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.29;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.10.48;	author millert;	state Exp;
branches;
next	;


desc
@@


1.9
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@package FileCache;

our $VERSION = '1.08';

=head1 NAME

FileCache - keep more files open than the system permits

=head1 SYNOPSIS

    no strict 'refs';

    use FileCache;
    # or
    use FileCache maxopen => 16;

    cacheout $mode, $path;
    # or
    cacheout $path;
    print $path @@data;

    $fh = cacheout $mode, $path;
    # or
    $fh = cacheout $path;
    print $fh @@data;

=head1 DESCRIPTION

The C<cacheout> function will make sure that there's a filehandle open
for reading or writing available as the pathname you give it. It
automatically closes and re-opens files if you exceed your system's
maximum number of file descriptors, or the suggested maximum I<maxopen>.

=over

=item cacheout EXPR

The 1-argument form of cacheout will open a file for writing (C<< '>' >>)
on it's first use, and appending (C<<< '>>' >>>) thereafter.

Returns EXPR on success for convenience. You may neglect the
return value and manipulate EXPR as the filehandle directly if you prefer.

=item cacheout MODE, EXPR

The 2-argument form of cacheout will use the supplied mode for the initial
and subsequent openings. Most valid modes for 3-argument C<open> are supported
namely; C<< '>' >>, C<< '+>' >>, C<< '<' >>, C<< '<+' >>, C<<< '>>' >>>,
C< '|-' > and C< '-|' >

To pass supplemental arguments to a program opened with C< '|-' > or C< '-|' >
append them to the command string as you would system EXPR.

Returns EXPR on success for convenience. You may neglect the
return value and manipulate EXPR as the filehandle directly if you prefer.

=back

=head1 CAVEATS

While it is permissible to C<close> a FileCache managed file,
do not do so if you are calling C<FileCache::cacheout> from a package other
than which it was imported, or with another module which overrides C<close>.
If you must, use C<FileCache::cacheout_close>.

Although FileCache can be used with piped opens ('-|' or '|-') doing so is
strongly discouraged.  If FileCache finds it necessary to close and then reopen
a pipe, the command at the far end of the pipe will be reexecuted - the results
of performing IO on FileCache'd pipes is unlikely to be what you expect.  The
ability to use FileCache on pipes may be removed in a future release.

FileCache does not store the current file offset if it finds it necessary to
close a file.  When the file is reopened, the offset will be as specified by the
original C<open> file mode.  This could be construed to be a bug.

The module functionality relies on symbolic references, so things will break
under 'use strict' unless 'no strict "refs"' is also specified.

=head1 BUGS

F<sys/param.h> lies with its C<NOFILE> define on some systems,
so you may have to set I<maxopen> yourself.

=cut

require 5.006;
use Carp;
use strict;
no strict 'refs';

# These are not C<my> for legacy reasons.
# Previous versions requested the user set $cacheout_maxopen by hand.
# Some authors fiddled with %saw to overcome the clobber on initial open.
use vars qw(%saw $cacheout_maxopen);
$cacheout_maxopen = 16;

use base 'Exporter';
our @@EXPORT = qw[cacheout cacheout_close];


my %isopen;
my $cacheout_seq = 0;

sub import {
    my ($pkg,%args) = @@_;

    # Use Exporter. %args are for us, not Exporter.
    # Make sure to up export_to_level, or we will import into ourselves,
    # rather than our calling package;

    __PACKAGE__->export_to_level(1);
    Exporter::import( $pkg );

    # Truth is okay here because setting maxopen to 0 would be bad
    return $cacheout_maxopen = $args{maxopen} if $args{maxopen};

    # XXX This code is crazy.  Why is it a one element foreach loop?
    # Why is it using $param both as a filename and filehandle?
    foreach my $param ( '/usr/include/sys/param.h' ){
      if (open($param, '<', $param)) {
	local ($_, $.);
	while (<$param>) {
	  if( /^\s*#\s*define\s+NOFILE\s+(\d+)/ ){
	    $cacheout_maxopen = $1 - 4;
	    close($param);
	    last;
	  }
	}
	close $param;
      }
    }
    $cacheout_maxopen ||= 16;
}

# Open in their package.
sub cacheout_open {
  return open(*{caller(1) . '::' . $_[1]}, $_[0], $_[1]) && $_[1];
}

# Close in their package.
sub cacheout_close {
  # Short-circuit in case the filehandle disappeared
  my $pkg = caller($_[1]||0);
  defined fileno(*{$pkg . '::' . $_[0]}) &&
    CORE::close(*{$pkg . '::' . $_[0]});
  delete $isopen{$_[0]};
}

# But only this sub name is visible to them.
sub cacheout {
    my($mode, $file, $class, $ret, $ref, $narg);
    croak "Not enough arguments for cacheout"  unless $narg = scalar @@_;
    croak "Too many arguments for cacheout"    if $narg > 2;

    ($mode, $file) = @@_;
    ($file, $mode) = ($mode, $file) if $narg == 1;
    croak "Invalid mode for cacheout" if $mode &&
      ( $mode !~ /^\s*(?:>>|\+?>|\+?<|\|\-|)|\-\|\s*$/ );

    # Mode changed?
    if( $isopen{$file} && ($mode||'>') ne $isopen{$file}->[1] ){
      &cacheout_close($file, 1);
    }

    if( $isopen{$file}) {
      $ret = $file;
      $isopen{$file}->[0]++;
    }
    else{
      if( scalar keys(%isopen) > $cacheout_maxopen -1 ) {
	my @@lru = sort{ $isopen{$a}->[0] <=> $isopen{$b}->[0] } keys(%isopen);
	$cacheout_seq = 0;
	$isopen{$_}->[0] = $cacheout_seq++ for
	  splice(@@lru, int($cacheout_maxopen / 3)||$cacheout_maxopen);
	&cacheout_close($_, 1) for @@lru;
      }

      unless( $ref ){
	$mode ||= $saw{$file} ? '>>' : ($saw{$file}=1, '>');
      }
      #XXX should we just return the value from cacheout_open, no croak?
      $ret = cacheout_open($mode, $file) or croak("Can't create $file: $!");

      $isopen{$file} = [++$cacheout_seq, $mode];
    }
    return $ret;
}
1;
@


1.8
log
@Merge in perl 5.10.1
@
text
@@


1.7
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 1
a3 1
our $VERSION = '1.07';
d11 2
d75 3
@


1.6
log
@merge in perl 5.8.8
@
text
@d3 1
a3 1
our $VERSION = '1.06';
a82 1
use Config;
d139 1
a139 1
  fileno(*{$pkg . '::' . $_[0]}) &&
@


1.5
log
@merge 5.8.5 into HEAD
remove now-unused files
crank libperl shared library major number
update Makefile.bsd-wrapper
tweak openbsd hints file for arm and m68k
@
text
@d3 1
a3 1
our $VERSION = '1.04_01';
d55 2
d86 1
d91 6
d102 7
a108 3
    $pkg = caller(1);
    *{$pkg.'::cacheout'} = \&cacheout;
    *{$pkg.'::close'}    = \&cacheout_close;
d112 3
d160 1
a160 1
    
d179 1
a179 1
      
@


1.4
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
our $VERSION = 1.03;
d49 3
d62 10
a76 7
=head1 NOTES

FileCache installs signal handlers for CHLD (a.k.a. CLD) and PIPE in the
calling package to handle deceased children from 2-arg C<cacheout> with C<'|-'>
or C<'-|'> I<expediently>. The children would otherwise be reaped eventually,
unless you terminated before repeatedly calling cacheout.

a96 5
    # Reap our children
    ${"$pkg\::SIG"}{'CLD'}  = 'IGNORE' if $Config{sig_name} =~ /\bCLD\b/;
    ${"$pkg\::SIG"}{'CHLD'} = 'IGNORE' if $Config{sig_name} =~ /\bCHLD\b/;
    ${"$pkg\::SIG"}{'PIPE'} = 'IGNORE' if $Config{sig_name} =~ /\bPIPE\b/;

d139 1
a139 1
    
d141 1
a141 1
    if( $isopen{$file} && ($mode||'>') ne $isopen{$file}->[2] ){
@


1.3
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
our $VERSION = '1.021';
d15 2
d20 4
a23 2
    cacheout $mode, $path;
    print $path @@data;
d29 2
a30 2
automatically closes and re-opens files if you exceed  your system's
maximum number of file descriptors, or the suggested maximum.
d39 3
d49 3
a53 4
If you use cacheout with C<'|-'> or C<'-|'> you should catch SIGPIPE
and explicitly close the filehandle., when it is closed from the
other end some cleanup needs to be done.

d62 8
a69 1
so you may have to set maxopen (I<$FileCache::cacheout_maxopen>) yourself.
d75 1
a77 1
use vars qw(%saw $cacheout_maxopen);
d81 1
d87 8
a94 2
    *{caller(1).'::cacheout'} = \&cacheout;
    *{caller(1).'::close'}    = \&cacheout_close;
d97 12
a108 6
    return $cacheout_maxopen = $args{maxopen} if $args{maxopen} ;
    if (open(PARAM,'/usr/include/sys/param.h')) {
      local ($_, $.);
      while (<PARAM>) {
	$cacheout_maxopen = $1 - 4
	  if /^\s*#\s*define\s+NOFILE\s+(\d+)/;
a109 1
      close PARAM;
a114 1

d116 1
a116 1
    open(*{caller(1) . '::' . $_[1]}, $_[0], $_[1]);
a119 1

d121 5
a125 3
    fileno(*{caller(1) . '::' . $_[0]}) &&
      CORE::close(*{caller(1) . '::' . $_[0]});
    delete $isopen{$_[0]};
a128 1
 
d130 6
a135 6
    croak "Not enough arguments for cacheout"  unless @@_;
    croak "Too many arguments for cacheout" if scalar @@_ > 2;
    my($mode, $file)=@@_;
    ($file, $mode) = ($mode, $file) if scalar @@_ == 1;
    # We don't want children
    croak "Invalid file for cacheout" if $file =~ /^\s*(?:\|\-)|(?:\-\|)\s*$/;
d137 19
a155 1
      ( $mode !~ /^\s*(?:>>)|(?:\+?>)|(?:\+?<)|(?:\|\-)|(?:\-\|)\s*$/ );
d157 2
a158 4
    unless( $isopen{$file}) {
      if( scalar keys(%isopen) > $cacheout_maxopen -1 ) {
	my @@lru = sort {$isopen{$a} <=> $isopen{$b};} keys(%isopen);
	&cacheout_close($_) for splice(@@lru, $cacheout_maxopen / 3);
d160 4
a163 2
      $mode ||=  ( $saw{$file} = ! $saw{$file} ) ? '>': '>>';
      cacheout_open($mode, $file) or croak("Can't create $file: $!");
d165 1
a165 1
    $isopen{$file} = ++$cacheout_seq;
a166 1

@


1.2
log
@perl 5.004_04
@
text
@d3 2
d11 4
d18 3
d24 28
a51 3
for writing available as the pathname you give it.  It automatically
closes and re-opens files if you exceed your system file descriptor
maximum.
d56 1
a56 1
so you may have to set $FileCache::cacheout_maxopen yourself.
d60 1
a60 1
require 5.000;
d62 26
a87 6
use Exporter;

@@ISA = qw(Exporter);
@@EXPORT = qw(
    cacheout
);
d92 1
a92 2
    my $pack = caller(1);
    open(*{$pack . '::' . $_[0]}, $_[1]);
d95 2
d98 3
a100 2
    my $pack = caller(1);
    close(*{$pack . '::' . $_[0]});
d104 1
a104 4

$cacheout_seq = 0;
$cacheout_numopen = 0;

d106 16
a121 21
    ($file) = @@_;
    unless (defined $cacheout_maxopen) {
	if (open(PARAM,'/usr/include/sys/param.h')) {
	    local ($_, $.);
	    while (<PARAM>) {
		$cacheout_maxopen = $1 - 4
		    if /^\s*#\s*define\s+NOFILE\s+(\d+)/;
	    }
	    close PARAM;
	}
	$cacheout_maxopen = 16 unless $cacheout_maxopen;
    }
    if (!$isopen{$file}) {
	if (++$cacheout_numopen > $cacheout_maxopen) {
	    my @@lru = sort {$isopen{$a} <=> $isopen{$b};} keys(%isopen);
	    splice(@@lru, $cacheout_maxopen / 3);
	    $cacheout_numopen -= @@lru;
	    for (@@lru) { &cacheout_close($_); delete $isopen{$_}; }
	}
	cacheout_open($file, ($saw{$file}++ ? '>>' : '>') . $file)
	    or croak("Can't create $file: $!");
@


1.1
log
@Initial revision
@
text
@d22 1
a22 1
so you may have to set $cacheout::maxopen yourself.
d56 1
a56 1
	    local $.;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d22 1
a22 1
so you may have to set $FileCache::cacheout_maxopen yourself.
d56 1
a56 1
	    local ($_, $.);
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a2 2
our $VERSION = '1.021';

a8 4
    use FileCache;
    # or
    use FileCache maxopen => 16;

a11 3
    cacheout $mode, $path;
    print $path @@data;

d15 3
a17 28
for reading or writing available as the pathname you give it. It
automatically closes and re-opens files if you exceed  your system's
maximum number of file descriptors, or the suggested maximum.

=over

=item cacheout EXPR

The 1-argument form of cacheout will open a file for writing (C<< '>' >>)
on it's first use, and appending (C<<< '>>' >>>) thereafter.

=item cacheout MODE, EXPR

The 2-argument form of cacheout will use the supplied mode for the initial
and subsequent openings. Most valid modes for 3-argument C<open> are supported
namely; C<< '>' >>, C<< '+>' >>, C<< '<' >>, C<< '<+' >>, C<<< '>>' >>>,
C< '|-' > and C< '-|' >

=head1 CAVEATS

If you use cacheout with C<'|-'> or C<'-|'> you should catch SIGPIPE
and explicitly close the filehandle., when it is closed from the
other end some cleanup needs to be done.

While it is permissible to C<close> a FileCache managed file,
do not do so if you are calling C<FileCache::cacheout> from a package other
than which it was imported, or with another module which overrides C<close>.
If you must, use C<FileCache::cacheout_close>.
d22 1
a22 1
so you may have to set maxopen (I<$FileCache::cacheout_maxopen>) yourself.
d26 1
a26 1
require 5.006;
d28 6
a33 26
use strict;
no strict 'refs';
use vars qw(%saw $cacheout_maxopen);
# These are not C<my> for legacy reasons.
# Previous versions requested the user set $cacheout_maxopen by hand.
# Some authors fiddled with %saw to overcome the clobber on initial open.
my %isopen;
my $cacheout_seq = 0;

sub import {
    my ($pkg,%args) = @@_;
    *{caller(1).'::cacheout'} = \&cacheout;
    *{caller(1).'::close'}    = \&cacheout_close;

    # Truth is okay here because setting maxopen to 0 would be bad
    return $cacheout_maxopen = $args{maxopen} if $args{maxopen} ;
    if (open(PARAM,'/usr/include/sys/param.h')) {
      local ($_, $.);
      while (<PARAM>) {
	$cacheout_maxopen = $1 - 4
	  if /^\s*#\s*define\s+NOFILE\s+(\d+)/;
      }
      close PARAM;
    }
    $cacheout_maxopen ||= 16;
}
d38 2
a39 1
    open(*{caller(1) . '::' . $_[1]}, $_[0], $_[1]);
a41 2
# Close in their package.

d43 2
a44 3
    fileno(*{caller(1) . '::' . $_[0]}) &&
      CORE::close(*{caller(1) . '::' . $_[0]});
    delete $isopen{$_[0]};
d48 4
a51 1
 
d53 21
a73 16
    croak "Not enough arguments for cacheout"  unless @@_;
    croak "Too many arguments for cacheout" if scalar @@_ > 2;
    my($mode, $file)=@@_;
    ($file, $mode) = ($mode, $file) if scalar @@_ == 1;
    # We don't want children
    croak "Invalid file for cacheout" if $file =~ /^\s*(?:\|\-)|(?:\-\|)\s*$/;
    croak "Invalid mode for cacheout" if $mode &&
      ( $mode !~ /^\s*(?:>>)|(?:\+?>)|(?:\+?<)|(?:\|\-)|(?:\-\|)\s*$/ );

    unless( $isopen{$file}) {
      if( scalar keys(%isopen) > $cacheout_maxopen -1 ) {
	my @@lru = sort {$isopen{$a} <=> $isopen{$b};} keys(%isopen);
	&cacheout_close($_) for splice(@@lru, $cacheout_maxopen / 3);
      }
      $mode ||=  ( $saw{$file} = ! $saw{$file} ) ? '>': '>>';
      cacheout_open($mode, $file) or croak("Can't create $file: $!");
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = 1.03;
a14 2
    cacheout $mode, $path;
    # or
d18 2
a19 4
    $fh = cacheout $mode, $path;
    # or
    $fh = cacheout $path;
    print $fh @@data;
d25 2
a26 2
automatically closes and re-opens files if you exceed your system's
maximum number of file descriptors, or the suggested maximum I<maxopen>.
a34 3
Returns EXPR on success for convenience. You may neglect the
return value and manipulate EXPR as the filehandle directly if you prefer.

d42 1
a42 2
Returns EXPR on success for convenience. You may neglect the
return value and manipulate EXPR as the filehandle directly if you prefer.
d44 3
a46 1
=head1 CAVEATS
d56 1
a56 8
so you may have to set I<maxopen> yourself.

=head1 NOTES

FileCache installs signal handlers for CHLD (a.k.a. CLD) and PIPE in the
calling package to handle deceased children from 2-arg C<cacheout> with C<'|-'>
or C<'-|'> I<expediently>. The children would otherwise be reaped eventually,
unless you terminated before repeatedly calling cacheout.
a61 1
use Config;
d64 1
a67 1
use vars qw(%saw $cacheout_maxopen);
d73 2
a74 8
    $pkg = caller(1);
    *{$pkg.'::cacheout'} = \&cacheout;
    *{$pkg.'::close'}    = \&cacheout_close;

    # Reap our children
    ${"$pkg\::SIG"}{'CLD'}  = 'IGNORE' if $Config{sig_name} =~ /\bCLD\b/;
    ${"$pkg\::SIG"}{'CHLD'} = 'IGNORE' if $Config{sig_name} =~ /\bCHLD\b/;
    ${"$pkg\::SIG"}{'PIPE'} = 'IGNORE' if $Config{sig_name} =~ /\bPIPE\b/;
d77 6
a82 12
    return $cacheout_maxopen = $args{maxopen} if $args{maxopen};
    foreach my $param ( '/usr/include/sys/param.h' ){
      if (open($param, '<', $param)) {
	local ($_, $.);
	while (<$param>) {
	  if( /^\s*#\s*define\s+NOFILE\s+(\d+)/ ){
	    $cacheout_maxopen = $1 - 4;
	    close($param);
	    last;
	  }
	}
	close $param;
d84 1
d90 1
d92 1
a92 1
  return open(*{caller(1) . '::' . $_[1]}, $_[0], $_[1]) && $_[1];
d96 1
d98 3
a100 5
  # Short-circuit in case the filehandle disappeared
  my $pkg = caller($_[1]||0);
  fileno(*{$pkg . '::' . $_[0]}) &&
    CORE::close(*{$pkg . '::' . $_[0]});
  delete $isopen{$_[0]};
d104 1
d106 8
a113 3
    my($mode, $file, $class, $ret, $ref, $narg);
    croak "Not enough arguments for cacheout"  unless $narg = scalar @@_;
    croak "Too many arguments for cacheout"    if $narg > 2;
d115 1
a115 15
    ($mode, $file) = @@_;
    ($file, $mode) = ($mode, $file) if $narg == 1;
    croak "Invalid mode for cacheout" if $mode &&
      ( $mode !~ /^\s*(?:>>|\+?>|\+?<|\|\-|)|\-\|\s*$/ );
    
    # Mode changed?
    if( $isopen{$file} && ($mode||'>') ne $isopen{$file}->[2] ){
      &cacheout_close($file, 1);
    }
    
    if( $isopen{$file}) {
      $ret = $file;
      $isopen{$file}->[0]++;
    }
    else{
d117 2
a118 5
	my @@lru = sort{ $isopen{$a}->[0] <=> $isopen{$b}->[0] } keys(%isopen);
	$cacheout_seq = 0;
	$isopen{$_}->[0] = $cacheout_seq++ for
	  splice(@@lru, int($cacheout_maxopen / 3)||$cacheout_maxopen);
	&cacheout_close($_, 1) for @@lru;
d120 2
a121 8

      unless( $ref ){
	$mode ||= $saw{$file} ? '>>' : ($saw{$file}=1, '>');
      }
      #XXX should we just return the value from cacheout_open, no croak?
      $ret = cacheout_open($mode, $file) or croak("Can't create $file: $!");
      
      $isopen{$file} = [++$cacheout_seq, $mode];
d123 1
a123 1
    return $ret;
d125 1
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d3 1
a3 1
our $VERSION = '1.04_01';
a48 3
To pass supplemental arguments to a program opened with C< '|-' > or C< '-|' >
append them to the command string as you would system EXPR.

a58 10
Although FileCache can be used with piped opens ('-|' or '|-') doing so is
strongly discouraged.  If FileCache finds it necessary to close and then reopen
a pipe, the command at the far end of the pipe will be reexecuted - the results
of performing IO on FileCache'd pipes is unlikely to be what you expect.  The
ability to use FileCache on pipes may be removed in a future release.

FileCache does not store the current file offset if it finds it necessary to
close a file.  When the file is reopened, the offset will be as specified by the
original C<open> file mode.  This could be construed to be a bug.

d64 7
d91 5
d138 1
a138 1

d140 1
a140 1
    if( $isopen{$file} && ($mode||'>') ne $isopen{$file}->[1] ){
@


1.1.1.6
log
@perl 5.8.8 import
@
text
@d3 1
a3 1
our $VERSION = '1.06';
a54 2
=back

a83 1

a87 6
$cacheout_maxopen = 16;

use base 'Exporter';
our @@EXPORT = qw[cacheout cacheout_close];


d93 3
a95 7

    # Use Exporter. %args are for us, not Exporter.
    # Make sure to up export_to_level, or we will import into ourselves,
    # rather than our calling package;

    __PACKAGE__->export_to_level(1);
    Exporter::import( $pkg );
a98 3

    # XXX This code is crazy.  Why is it a one element foreach loop?
    # Why is it using $param both as a filename and filehandle?
d144 1
a144 1

d163 1
a163 1

@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.07';
d83 1
d140 1
a140 1
  defined fileno(*{$pkg . '::' . $_[0]}) &&
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d3 1
a3 1
our $VERSION = '1.08';
a10 2
    no strict 'refs';

a72 3

The module functionality relies on symbolic references, so things will break
under 'use strict' unless 'no strict "refs"' is also specified.
@


