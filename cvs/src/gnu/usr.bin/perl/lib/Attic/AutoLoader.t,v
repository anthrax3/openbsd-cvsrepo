head	1.4;
access;
symbols
	OPENBSD_4_6:1.3.0.6
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.2
	OPENBSD_4_5_BASE:1.3
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.1.1.3.0.14
	OPENBSD_4_2_BASE:1.1.1.3
	OPENBSD_4_1:1.1.1.3.0.12
	OPENBSD_4_1_BASE:1.1.1.3
	OPENBSD_4_0:1.1.1.3.0.10
	OPENBSD_4_0_BASE:1.1.1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.4
date	2009.10.12.18.24.37;	author millert;	state dead;
branches;
next	1.3;

1.3
date	2008.09.29.17.36.08;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2007.08.24.22.47.29;	author simon;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.57;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.57;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.04.07.21.13.12;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2008.09.29.17.18.28;	author millert;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Merge in perl 5.10.1
@
text
@#!./perl -w

BEGIN {
    chdir 't' if -d 't';
	@@INC = '../lib';
}

use strict;
use File::Spec;
use File::Path;

my $dir;
BEGIN
{
	$dir = File::Spec->catdir( "auto-$$" );
	unshift @@INC, $dir;
}

use Test::More tests => 22;

# First we must set up some autoloader files
my $fulldir = File::Spec->catdir( $dir, 'auto', 'Foo' );
mkpath( $fulldir ) or die "Can't mkdir '$fulldir': $!";

open(FOO, '>', File::Spec->catfile( $fulldir, 'foo.al' ))
	or die "Can't open foo file: $!";
print FOO <<'EOT';
package Foo;
sub foo { shift; shift || "foo" }
1;
EOT
close(FOO);

open(BAR, '>', File::Spec->catfile( $fulldir, 'bar.al' ))
	or die "Can't open bar file: $!";
print BAR <<'EOT';
package Foo;
sub bar { shift; shift || "bar" }
1;
EOT
close(BAR);

open(BAZ, '>', File::Spec->catfile( $fulldir, 'bazmarkhian.al' ))
	or die "Can't open bazmarkhian file: $!";
print BAZ <<'EOT';
package Foo;
sub bazmarkhianish { shift; shift || "baz" }
1;
EOT
close(BAZ);

open(BLECH, '>', File::Spec->catfile( $fulldir, 'blechanawilla.al' ))
       or die "Can't open blech file: $!";
print BLECH <<'EOT';
package Foo;
sub blechanawilla { compilation error (
EOT
close(BLECH);

# This is just to keep the old SVR3 systems happy; they may fail
# to find the above file so we duplicate it where they should find it.
open(BLECH, '>', File::Spec->catfile( $fulldir, 'blechanawil.al' ))
       or die "Can't open blech file: $!";
print BLECH <<'EOT';
package Foo;
sub blechanawilla { compilation error (
EOT
close(BLECH);

# Let's define the package
package Foo;
require AutoLoader;
AutoLoader->import( 'AUTOLOAD' );

sub new { bless {}, shift };
sub foo;
sub bazmarkhianish; 

package main;

my $foo = Foo->new();

my $result = $foo->can( 'foo' );
ok( $result,               'can() first time' );
is( $foo->foo, 'foo', 'autoloaded first time' );
is( $foo->foo, 'foo', 'regular call' );
is( $result,   \&Foo::foo, 'can() returns ref to regular installed sub' );
$result    = $foo->can( 'bar' );
ok( $result,               'can() should work when importing AUTOLOAD too' );
is( $foo->bar, 'bar', 'regular call' );
is( $result,   \&Foo::bar, '... returning ref to regular installed sub' );

eval {
    $foo->will_fail;
};
like( $@@, qr/^Can't locate/, 'undefined method' );

$result = $foo->can( 'will_fail' );
ok( ! $result,               'can() should fail on undefined methods' );

# Used to be trouble with this
eval {
    my $foo = Foo->new();
    die "oops";
};
like( $@@, qr/oops/, 'indirect method call' );

# Pass regular expression variable to autoloaded function.  This used
# to go wrong because AutoLoader used regular expressions to generate
# autoloaded filename.
'foo' =~ /(\w+)/;

is( $foo->bar($1), 'foo', 'autoloaded method should not stomp match vars' );
is( $foo->bar($1), 'foo', '(again)' );
is( $foo->bazmarkhianish($1), 'foo', 'for any method call' );
is( $foo->bazmarkhianish($1), 'foo', '(again)' );

# Used to retry long subnames with shorter filenames on any old
# exception, including compilation error.  Now AutoLoader only
# tries shorter filenames if it can't find the long one.
eval {
  $foo->blechanawilla;
};
like( $@@, qr/syntax error/i, 'require error propagates' );

# test recursive autoloads
open(F, '>', File::Spec->catfile( $fulldir, 'a.al'))
	or die "Cannot make 'a' file: $!";
print F <<'EOT';
package Foo;
BEGIN { b() }
sub a { ::ok( 1, 'adding a new autoloaded method' ); }
1;
EOT
close(F);

open(F, '>', File::Spec->catfile( $fulldir, 'b.al'))
	or die "Cannot make 'b' file: $!";
print F <<'EOT';
package Foo;
sub b { ::ok( 1, 'adding a new autoloaded method' ) }
1;
EOT
close(F);
Foo::a();

package Bar;
AutoLoader->import();
::ok( ! defined &AUTOLOAD, 'AutoLoader should not export AUTOLOAD by default' );
::ok( ! defined &can,      '... nor can()' );

package Foo;
AutoLoader->unimport();
eval { Foo->baz() };
::like( $@@, qr/locate object method "baz"/,
	'unimport() should remove imported AUTOLOAD()' );

package Baz;

sub AUTOLOAD { 'i am here' }

AutoLoader->import();
AutoLoader->unimport();

::is( Baz->AUTOLOAD(), 'i am here', '... but not non-imported AUTOLOAD()' );


package SomeClass;
use AutoLoader 'AUTOLOAD';
sub new {
    bless {} => shift;
}

package main;

$INC{"SomeClass.pm"} = $0; # Prepare possible recursion
{
    my $p = SomeClass->new();
} # <-- deep recursion in AUTOLOAD looking for SomeClass::DESTROY?
::ok(1, "AutoLoader shouldn't loop forever if \%INC is modified");

# cleanup
END {
	return unless $dir && -d $dir;
	rmtree $dir;
}
@


1.3
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@@


1.2
log
@fix a bug leading to infinite recursion; adapted from CPAN

ok millert@@
@
text
@d19 1
a19 1
use Test::More tests => 18;
a76 1
sub bar;
d81 1
a81 1
my $foo = new Foo;
d88 4
d103 1
a103 1
    my $foo = new Foo;
d124 1
a124 1
like( $@@, qr/syntax error/, 'require error propagates' );
d150 1
d166 1
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
#!./perl
d5 1
a5 9
    if ($^O eq 'MacOS') {
	$dir = ":auto-$$";
	$sep = ":";
    } else {
	$dir = "auto-$$";
	$sep = "/";
    }
    @@INC = $dir;
    push @@INC, '../lib';
d8 12
a19 1
print "1..11\n";
d22 2
a23 3
mkdir $dir, 0755            or die "Can't mkdir $dir: $!";
mkdir "$dir${sep}auto", 0755     or die "Can't mkdir: $!";
mkdir "$dir${sep}auto${sep}Foo", 0755 or die "Can't mkdir: $!";
d25 2
a26 1
open(FOO, ">$dir${sep}auto${sep}Foo${sep}foo.al") or die;
d34 2
a35 1
open(BAR, ">$dir${sep}auto${sep}Foo${sep}bar.al") or die;
d43 2
a44 1
open(BAZ, ">$dir${sep}auto${sep}Foo${sep}bazmarkhian.al") or die;
d52 18
d73 1
a73 1
@@ISA=qw(AutoLoader);
d76 3
d82 1
a82 4
$foo = new Foo;

print "not " unless $foo->foo eq 'foo';  # autoloaded first time
print "ok 1\n";
d84 5
a88 2
print "not " unless $foo->foo eq 'foo';  # regular call
print "ok 2\n";
a89 1
# Try an undefined method
d93 4
a96 2
print "not " unless $@@ =~ /^Can't locate/;
print "ok 3\n";
d103 1
a103 2
print "not " unless $@@ =~ /oops/;
print "ok 4\n";
d108 1
a108 3
"foo" =~ /(\w+)/;
print "not " unless $1 eq 'foo';
print "ok 5\n";
d110 12
a121 11
print "not " unless $foo->bar($1) eq 'foo';
print "ok 6\n";

print "not " unless $foo->bar($1) eq 'foo';
print "ok 7\n";

print "not " unless $foo->bazmarkhianish($1) eq 'foo';
print "ok 8\n";

print "not " unless $foo->bazmarkhianish($1) eq 'foo';
print "ok 9\n";
d124 2
a125 1
open(F, ">$dir${sep}auto${sep}Foo${sep}a.al") or die;
d129 1
a129 1
sub a { print "ok 11\n"; }
d134 2
a135 1
open(F, ">$dir${sep}auto${sep}Foo${sep}b.al") or die;
d138 1
a138 1
sub b { print "ok 10\n"; }
d144 33
d179 2
a180 9
return unless $dir && -d $dir;
unlink "$dir${sep}auto${sep}Foo${sep}foo.al";
unlink "$dir${sep}auto${sep}Foo${sep}bar.al";
unlink "$dir${sep}auto${sep}Foo${sep}bazmarkhian.al";
unlink "$dir${sep}auto${sep}Foo${sep}a.al";
unlink "$dir${sep}auto${sep}Foo${sep}b.al";
rmdir "$dir${sep}auto${sep}Foo";
rmdir "$dir${sep}auto";
rmdir "$dir";
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d1 1
a1 1
#!./perl -w
d5 9
a13 1
	@@INC = '../lib';
d16 1
a16 12
use strict;
use File::Spec;
use File::Path;

my $dir;
BEGIN
{
	$dir = File::Spec->catdir( "auto-$$" );
	unshift @@INC, $dir;
}

use Test::More tests => 14;
d19 3
a21 2
my $fulldir = File::Spec->catdir( $dir, 'auto', 'Foo' );
mkpath( $fulldir ) or die "Can't mkdir '$fulldir': $!";
d23 1
a23 2
open(FOO, '>', File::Spec->catfile( $fulldir, 'foo.al' ))
	or die "Can't open foo file: $!";
d31 1
a31 2
open(BAR, '>', File::Spec->catfile( $fulldir, 'bar.al' ))
	or die "Can't open bar file: $!";
d39 1
a39 2
open(BAZ, '>', File::Spec->catfile( $fulldir, 'bazmarkhian.al' ))
	or die "Can't open bazmarkhian file: $!";
a46 18
open(BLECH, '>', File::Spec->catfile( $fulldir, 'blechanawilla.al' ))
       or die "Can't open blech file: $!";
print BLECH <<'EOT';
package Foo;
sub blechanawilla { compilation error (
EOT
close(BLECH);

# This is just to keep the old SVR3 systems happy; they may fail
# to find the above file so we duplicate it where they should find it.
open(BLECH, '>', File::Spec->catfile( $fulldir, 'blechanawil.al' ))
       or die "Can't open blech file: $!";
print BLECH <<'EOT';
package Foo;
sub blechanawilla { compilation error (
EOT
close(BLECH);

d50 1
a50 1
AutoLoader->import( 'AUTOLOAD' );
d56 4
a59 1
my $foo = new Foo;
d61 2
a62 2
is( $foo->foo, 'foo', 'autoloaded first time' );
is( $foo->foo, 'foo', 'regular call' );
d64 1
d68 2
a69 1
like( $@@, qr/^Can't locate/, 'undefined method' );
d76 2
a77 1
like( $@@, qr/oops/, 'indirect method call' );
d82 12
a93 1
'foo' =~ /(\w+)/;
d95 2
a96 12
is( $foo->bar($1), 'foo', 'autoloaded method should not stomp match vars' );
is( $foo->bar($1), 'foo', '(again)' );
is( $foo->bazmarkhianish($1), 'foo', 'for any method call' );
is( $foo->bazmarkhianish($1), 'foo', '(again)' );

# Used to retry long subnames with shorter filenames on any old
# exception, including compilation error.  Now AutoLoader only
# tries shorter filenames if it can't find the long one.
eval {
  $foo->blechanawilla;
};
like( $@@, qr/syntax error/, 'require error propagates' );
d99 1
a99 2
open(F, '>', File::Spec->catfile( $fulldir, 'a.al'))
	or die "Cannot make 'a' file: $!";
d103 1
a103 1
sub a { ::ok( 1, 'adding a new autoloaded method' ); }
d108 1
a108 2
open(F, '>', File::Spec->catfile( $fulldir, 'b.al'))
	or die "Cannot make 'b' file: $!";
d111 1
a111 1
sub b { ::ok( 1, 'adding a new autoloaded method' ) }
a116 21
package Bar;
AutoLoader->import();
::ok( ! defined &AUTOLOAD, 'AutoLoader should not export AUTOLOAD by default' );

package Foo;
AutoLoader->unimport();
eval { Foo->baz() };
::like( $@@, qr/locate object method "baz"/,
	'unimport() should remove imported AUTOLOAD()' );

package Baz;

sub AUTOLOAD { 'i am here' }

AutoLoader->import();
AutoLoader->unimport();

::is( Baz->AUTOLOAD(), 'i am here', '... but not non-imported AUTOLOAD()' );

package main;

d119 9
a127 2
	return unless $dir && -d $dir;
	rmtree $dir;
@


1.1.1.3
log
@perl 5.8.3 from CPAN
@
text
@d19 1
a19 1
use Test::More tests => 17;
a75 3
sub foo;
sub bar;
sub bazmarkhianish; 
a80 2
my $result = $foo->can( 'foo' );
ok( $result,               'can() first time' );
a82 1
is( $result,   \&Foo::foo, 'can() returns ref to regular installed sub' );
a87 3

$result = $foo->can( 'will_fail' );
ok( ! $result,               'can() should fail on undefined methods' );
@


1.1.1.4
log
@import perl 5.10.0 from CPAN
@
text
@d19 1
a19 1
use Test::More tests => 22;
d77 1
d82 1
a82 1
my $foo = Foo->new();
a88 4
$result    = $foo->can( 'bar' );
ok( $result,               'can() should work when importing AUTOLOAD too' );
is( $foo->bar, 'bar', 'regular call' );
is( $result,   \&Foo::bar, '... returning ref to regular installed sub' );
d100 1
a100 1
    my $foo = Foo->new();
d121 1
a121 1
like( $@@, qr/syntax error/i, 'require error propagates' );
a146 1
::ok( ! defined &can,      '... nor can()' );
a162 7

package SomeClass;
use AutoLoader 'AUTOLOAD';
sub new {
    bless {} => shift;
}

a163 6

$INC{"SomeClass.pm"} = $0; # Prepare possible recursion
{
    my $p = SomeClass->new();
} # <-- deep recursion in AUTOLOAD looking for SomeClass::DESTROY?
::ok(1, "AutoLoader shouldn't loop forever if \%INC is modified");
@


