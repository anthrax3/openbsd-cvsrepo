head	1.20;
access;
symbols
	OPENBSD_6_2_BASE:1.20
	PERL_5_24_2:1.1.1.13
	OPENBSD_6_1:1.18.0.4
	OPENBSD_6_1_BASE:1.18
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.4
	OPENBSD_5_8_BASE:1.16
	PERL_5_20_2:1.1.1.12
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	PERL_5_20_1:1.1.1.12
	OPENBSD_5_6:1.12.0.8
	OPENBSD_5_6_BASE:1.12
	PERL_5_18_2:1.1.1.11
	PERL:1.1.1
	OPENBSD_5_5:1.12.0.6
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.2
	OPENBSD_5_4_BASE:1.12
	PERL_5_16_3:1.1.1.11
	OPENBSD_5_3:1.11.0.14
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.12
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.10
	OPENBSD_5_0:1.11.0.8
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	PERL_5_10_1:1.1.1.10
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.9
	OPENBSD_4_4:1.8.0.18
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.16
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.14
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.12
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.10
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.8
	OPENBSD_3_9:1.8.0.8
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.6
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.4
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.12
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.10
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.8
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.20
date	2017.08.14.13.49.45;	author afresh1;	state Exp;
branches;
next	1.19;
commitid	AOpGtCFzbfdujI88;

1.19
date	2017.08.14.13.48.47;	author afresh1;	state Exp;
branches;
next	1.18;
commitid	CrMEpTqBUsxCMTjx;

1.18
date	2017.02.05.00.33.41;	author afresh1;	state Exp;
branches;
next	1.17;
commitid	7JLVNm1wwPgqSqTa;

1.17
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.16;
commitid	cxJ08BvJA9Pt2PTM;

1.16
date	2015.04.25.19.26.22;	author afresh1;	state Exp;
branches;
next	1.15;
commitid	3qGYFVvfrExB70FB;

1.15
date	2015.04.25.19.14.47;	author afresh1;	state Exp;
branches;
next	1.14;
commitid	XRK22kO4se3v2i2I;

1.14
date	2014.11.17.21.01.01;	author afresh1;	state Exp;
branches;
next	1.13;
commitid	LnErp1MFKSuew5Fr;

1.13
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.12;
commitid	QP75iYx42Uo7mMxO;

1.12
date	2013.03.25.20.40.56;	author sthen;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.13.01.25.48;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.41;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.04.07.21.33.06;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.03.28.18.58.13;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.39;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.42;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.44;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.44;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.45;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.04;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.18;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.47.06;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.20;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2008.09.29.17.18.35;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2009.10.12.18.10.55;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2013.03.25.20.08.54;	author sthen;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	2014.11.17.20.53.08;	author afresh1;	state Exp;
branches;
next	1.1.1.13;
commitid	B31cAbBIXiCqnL97;

1.1.1.13
date	2017.08.14.13.46.14;	author afresh1;	state Exp;
branches;
next	;
commitid	fAzrs78vdW2Yfc6A;


desc
@@


1.20
log
@Apply local patches - perl-5.24.2

OK bluhm@@, Reads ok sthen@@
@
text
@package Getopt::Std;
require 5.000;
require Exporter;

=head1 NAME

Getopt::Std, getopt, getopts - Process single-character switches with switch clustering

=head1 SYNOPSIS

    use Getopt::Std;

    getopts('oif:');  # -o & -i are boolean flags, -f takes an argument
		      # Sets $opt_* as a side effect.
    getopts('oif:', \%opts);  # options as above. Values in %opts
    getopt('oDI');    # -o, -D & -I take arg.
                      # Sets $opt_* as a side effect.
    getopt('oDI', \%opts);    # -o, -D & -I take arg.  Values in %opts

=head1 DESCRIPTION

The C<getopts()> function processes single-character switches with switch
clustering.  Pass one argument which is a string containing all switches to be
recognized.  For each switch found, if an argument is expected and provided,
C<getopts()> sets C<$opt_x> (where C<x> is the switch name) to the value of
the argument.  If an argument is expected but none is provided, C<$opt_x> is
set to an undefined value.  If a switch does not take an argument, C<$opt_x>
is set to C<1>.

Switches which take an argument don't care whether there is a space between
the switch and the argument.  If unspecified switches are found on the
command-line, the user will be warned that an unknown option was given.

The C<getopts()> function returns true unless an invalid option was found.

The C<getopt()> function is similar, but its argument is a string containing
all switches that take an argument.  If no argument is provided for a switch,
say, C<y>, the corresponding C<$opt_y> will be set to an undefined value.
Unspecified switches are silently accepted.  Use of C<getopt()> is not
recommended.

Note that, if your code is running under the recommended C<use strict
vars> pragma, you will need to declare these package variables
with C<our>:

    our($opt_x, $opt_y);

For those of you who don't like additional global variables being created,
C<getopt()> and C<getopts()> will also accept a hash reference as an optional
second argument.  Hash keys will be C<x> (where C<x> is the switch name) with
key values the value of the argument or C<1> if no argument is specified.

To allow programs to process arguments that look like switches, but aren't,
both functions will stop processing switches when they see the argument
C<-->.  The C<--> will be removed from @@ARGV.

=head1 C<--help> and C<--version>

If C<-> is not a recognized switch letter, getopts() supports arguments
C<--help> and C<--version>.  If C<main::HELP_MESSAGE()> and/or
C<main::VERSION_MESSAGE()> are defined, they are called; the arguments are
the output file handle, the name of option-processing package, its version,
and the switches string.  If the subroutines are not defined, an attempt is
made to generate intelligent messages; for best results, define $main::VERSION.

If embedded documentation (in pod format, see L<perlpod>) is detected
in the script, C<--help> will also show how to access the documentation.

Note that due to excessive paranoia, if $Getopt::Std::STANDARD_HELP_VERSION
isn't true (the default is false), then the messages are printed on STDERR,
and the processing continues after the messages are printed.  This being
the opposite of the standard-conforming behaviour, it is strongly recommended
to set $Getopt::Std::STANDARD_HELP_VERSION to true.

One can change the output file handle of the messages by setting
$Getopt::Std::OUTPUT_HELP_VERSION.  One can print the messages of C<--help>
(without the C<Usage:> line) and C<--version> by calling functions help_mess()
and version_mess() with the switches string as an argument.

=cut

@@ISA = qw(Exporter);
@@EXPORT = qw(getopt getopts);
$VERSION = '1.11';
# uncomment the next line to disable 1.03-backward compatibility paranoia
# $STANDARD_HELP_VERSION = 1;

# Process single-character switches with switch clustering.  Pass one argument
# which is a string containing all switches that take an argument.  For each
# switch found, sets $opt_x (where x is the switch name) to the value of the
# argument, or 1 if no argument.  Switches which take an argument don't care
# whether there is a space between the switch and the argument.

# Usage:
#	getopt('oDI');  # -o, -D & -I take arg.  Sets opt_* as a side effect.

sub getopt (;$$) {
    my ($argumentative, $hash) = @@_;
    $argumentative = '' if !defined $argumentative;
    my ($first,$rest);
    local $_;
    local @@EXPORT;

    while (@@ARGV && ($_ = $ARGV[0]) =~ /^-(.)(.*)/) {
	($first,$rest) = ($1,$2);
	if (/^--$/) {	# early exit if --
	    shift @@ARGV;
	    last;
	}
	if (index($argumentative,$first) >= 0) {
	    if ($rest ne '') {
		shift(@@ARGV);
	    }
	    else {
		shift(@@ARGV);
		$rest = shift(@@ARGV);
	    }
	    if (ref $hash) {
	        $$hash{$first} = $rest;
	    }
	    else {
	        ${"opt_$first"} = $rest;
	        push( @@EXPORT, "\$opt_$first" );
	    }
	}
	else {
	    if (ref $hash) {
	        $$hash{$first} = 1;
	    }
	    else {
	        ${"opt_$first"} = 1;
	        push( @@EXPORT, "\$opt_$first" );
	    }
	    if ($rest ne '') {
		$ARGV[0] = "-$rest";
	    }
	    else {
		shift(@@ARGV);
	    }
	}
    }
    unless (ref $hash) { 
	local $Exporter::ExportLevel = 1;
	import Getopt::Std;
    }
}

sub output_h () {
  return $OUTPUT_HELP_VERSION if defined $OUTPUT_HELP_VERSION;
  return \*STDOUT if $STANDARD_HELP_VERSION;
  return \*STDERR;
}

sub try_exit () {
    exit 0 if $STANDARD_HELP_VERSION;
    my $p = __PACKAGE__;
    print {output_h()} <<EOM;
  [Now continuing due to backward compatibility and excessive paranoia.
   See 'perldoc $p' about \$$p\::STANDARD_HELP_VERSION.]
EOM
}

sub version_mess ($;$) {
    my $args = shift;
    my $h = output_h;
    if (@@_ and defined &main::VERSION_MESSAGE) {
	main::VERSION_MESSAGE($h, __PACKAGE__, $VERSION, $args);
    } else {
	my $v = $main::VERSION;
	$v = '[unknown]' unless defined $v;
	my $myv = $VERSION;
	$myv .= ' [paranoid]' unless $STANDARD_HELP_VERSION;
	my $perlv = $];
	$perlv = sprintf "%vd", $^V if $] >= 5.006;
	print $h <<EOH;
$0 version $v calling Getopt::Std::getopts (version $myv),
running under Perl version $perlv.
EOH
    }
}

sub help_mess ($;$) {
    my $args = shift;
    my $h = output_h;
    if (@@_ and defined &main::HELP_MESSAGE) {
	main::HELP_MESSAGE($h, __PACKAGE__, $VERSION, $args);
    } else {
	my (@@witharg) = ($args =~ /(\S)\s*:/g);
	my (@@rest) = ($args =~ /([^\s:])(?!\s*:)/g);
	my ($help, $arg) = ('', '');
	if (@@witharg) {
	    $help .= "\n\tWith arguments: -" . join " -", @@witharg;
	    $arg = "\nSpace is not required between options and their arguments.";
	}
	if (@@rest) {
	    $help .= "\n\tBoolean (without arguments): -" . join " -", @@rest;
	}
	my ($scr) = ($0 =~ m,([^/\\]+)$,);
	print $h <<EOH if @@_;			# Let the script override this

Usage: $scr [-OPTIONS [-MORE_OPTIONS]] [--] [PROGRAM_ARG1 ...]
EOH
	print $h <<EOH;

The following single-character options are accepted:$help

Options may be merged together.  -- stops processing of options.$arg
EOH
	my $has_pod;
	if ( defined $0 and $0 ne '-e' and -f $0 and -r $0
	     and open my $script, '<', $0 ) {
	    while (<$script>) {
		$has_pod = 1, last if /^=(pod|head1)/;
	    }
	}
	print $h <<EOH if $has_pod;

For more details run
	perldoc -F $0
EOH
    }
}

# Usage:
#   getopts('a:bc');	# -a takes arg. -b & -c not. Sets opt_* as a
#			#  side effect.

sub getopts ($;$) {
    my ($argumentative, $hash) = @@_;
    my (@@args,$first,$rest,$exit);
    my $errs = 0;
    local $_;
    local @@EXPORT;

    @@args = split( / */, $argumentative );
    while(@@ARGV && ($_ = $ARGV[0]) =~ /^-(.)(.*)/s) {
	($first,$rest) = ($1,$2);
	if (/^--$/) {	# early exit if --
	    shift @@ARGV;
	    last;
	}
	my $pos = index($argumentative,$first);
	if ($pos >= 0) {
	    if (defined($args[$pos+1]) and ($args[$pos+1] eq ':')) {
		shift(@@ARGV);
		if ($rest eq '') {
		    ++$errs unless @@ARGV;
		    $rest = shift(@@ARGV);
		}
		if (ref $hash) {
		    $$hash{$first} = $rest;
		}
		else {
		    ${"opt_$first"} = $rest;
		    push( @@EXPORT, "\$opt_$first" );
		}
	    }
	    else {
		if (ref $hash) {
		    $$hash{$first} = 1;
		}
		else {
		    ${"opt_$first"} = 1;
		    push( @@EXPORT, "\$opt_$first" );
		}
		if ($rest eq '') {
		    shift(@@ARGV);
		}
		else {
		    $ARGV[0] = "-$rest";
		}
	    }
	}
	else {
	    if ($first eq '-' and $rest eq 'help') {
		version_mess($argumentative, 'main');
		help_mess($argumentative, 'main');
		try_exit();
		shift(@@ARGV);
		next;
	    } elsif ($first eq '-' and $rest eq 'version') {
		version_mess($argumentative, 'main');
		try_exit();
		shift(@@ARGV);
		next;
	    }
	    warn "Unknown option: $first\n";
	    ++$errs;
	    if ($rest ne '') {
		$ARGV[0] = "-$rest";
	    }
	    else {
		shift(@@ARGV);
	    }
	}
    }
    unless (ref $hash) { 
	local $Exporter::ExportLevel = 1;
	import Getopt::Std;
    }
    $errs == 0;
}

1;
@


1.19
log
@Fix merge issues, remove excess files - match perl-5.24.2 dist

OK bluhm@@, Reads ok sthen@@
@
text
@d7 1
a7 1
getopt, getopts - Process single-character switches with switch clustering
@


1.18
log
@Apply local patches - perl-5.24.1
@
text
@d7 1
a7 1
Getopt::Std, getopt, getopts - Process single-character switches with switch clustering
@


1.17
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@d7 1
a7 1
getopt, getopts - Process single-character switches with switch clustering
@


1.16
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d7 1
a7 1
Getopt::Std, getopt, getopts - Process single-character switches with switch clustering
d39 2
a40 2
Unspecified switches are silently accepted.  B<Use of C<getopts()> is not
recommended.>
d84 1
a84 1
$VERSION = '1.10';
@


1.15
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d7 1
a7 1
getopt, getopts - Process single-character switches with switch clustering
@


1.14
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d7 1
a7 1
Getopt::Std, getopt, getopts - Process single-character switches with switch clustering
@


1.13
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d7 1
a7 1
getopt, getopts - Process single-character switches with switch clustering
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d7 1
a7 1
Getopt::Std, getopt, getopts - Process single-character switches with switch clustering
a12 2
    getopt('oDI');    # -o, -D & -I take arg.  Sets $opt_* as a side effect.
    getopt('oDI', \%opts);    # -o, -D & -I take arg.  Values in %opts
d16 3
d22 7
a28 6
The getopt() function processes single-character switches with switch
clustering.  Pass one argument which is a string containing all switches
that take an argument.  For each switch found, sets $opt_x (where x is the
switch name) to the value of the argument if an argument is expected,
or 1 otherwise.  Switches which take an argument don't care whether
there is a space between the switch and the argument.
d30 2
a31 2
The getopts() function is similar, but you should pass to it the list of all
switches to be recognized.  If unspecified switches are found on the
d33 8
a40 1
The getopts() function returns true unless an invalid option was found.
d43 2
a44 2
'vars'> pragma, you will need to declare these package variables
with "our":
d48 4
a51 4
For those of you who don't like additional global variables being created, getopt()
and getopts() will also accept a hash reference as an optional second argument. 
Hash keys will be x (where x is the switch name) with key values the value of
the argument or 1 if no argument is specified.
d84 1
a84 1
$VERSION = '1.07';
@


1.11
log
@Merge in some local changes that got lost.
@
text
@d75 1
a75 1
$VERSION = '1.06';
d150 1
a150 1
   See ``perldoc $p'' about \$$p\::STANDARD_HELP_VERSION.]
@


1.10
log
@Merge in perl 5.10.1
@
text
@d7 1
a7 1
getopt, getopts - Process single-character switches with switch clustering
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d7 1
a7 1
Getopt::Std, getopt, getopts - Process single-character switches with switch clustering
d75 1
a75 1
$VERSION = '1.05';
@


1.8
log
@merge local changes into perl-5.8.3
@
text
@d31 1
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d74 1
a74 1
$VERSION = '1.04';
@


1.6
log
@Add missing MLINKS for Getopt::Std and fix NAME section
@
text
@d47 23
d74 3
a76 1
$VERSION = '1.03';
d138 76
d220 1
a220 1
    my (@@args,$first,$rest);
d226 1
a226 1
    while(@@ARGV && ($_ = $ARGV[0]) =~ /^-(.)(.*)/) {
d232 1
a232 1
	$pos = index($argumentative,$first);
d265 12
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d7 1
a7 3
getopt - Process single-character switches with switch clustering

getopts - Process single-character switches with switch clustering
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d15 1
a15 1
    getopt('oDI');    # -o, -D & -I take arg.  Sets opt_* as a side effect.
d18 1
a18 1
		      # Sets opt_* as a side effect.
d23 1
a23 1
The getopt() functions processes single-character switches with switch
d26 7
a32 3
switch name) to the value of the argument, or 1 if no argument.  Switches
which take an argument don't care whether there is a space between the
switch and the argument.
d38 1
a38 1
    our($opt_foo, $opt_bar);
d53 1
a53 1
$VERSION = '1.02';
d64 5
a68 3
sub getopt ($;$) {
    local($argumentative, $hash) = @@_;
    local($_,$first,$rest);
d120 4
a123 3
    local($argumentative, $hash) = @@_;
    local(@@args,$_,$first,$rest);
    local($errs) = 0;
@


1.3
log
@perl5.005_03 (stock)
@
text
@d31 2
a32 2
'vars'> pragma, it may be helpful to declare these package variables
via C<use vars> perhaps something like this:
d34 1
a34 1
    use vars qw/ $opt_foo $opt_bar /;
d36 1
a36 1
For those of you who don't like additional variables being created, getopt()
d41 4
d49 1
a49 1
$VERSION = $VERSION = '1.01';
d67 4
d79 7
a85 7
          if (ref $hash) {
              $$hash{$first} = $rest;
          }
          else {
              ${"opt_$first"} = $rest;
              push( @@EXPORT, "\$opt_$first" );
          }
d88 7
a94 7
          if (ref $hash) {
              $$hash{$first} = 1;
          }
          else {
              ${"opt_$first"} = 1;
              push( @@EXPORT, "\$opt_$first" );
          }
d122 4
d127 2
a128 2
	if($pos >= 0) {
	    if(defined($args[$pos+1]) and ($args[$pos+1] eq ':')) {
d130 1
a130 1
		if($rest eq '') {
d134 17
a150 17
              if (ref $hash) {
                  $$hash{$first} = $rest;
              }
              else {
                  ${"opt_$first"} = $rest;
                  push( @@EXPORT, "\$opt_$first" );
              }
	    }
	    else {
              if (ref $hash) {
                  $$hash{$first} = 1;
              }
              else {
                  ${"opt_$first"} = 1;
                  push( @@EXPORT, "\$opt_$first" );
              }
		if($rest eq '') {
d161 1
a161 1
	    if($rest ne '') {
a176 1

@


1.2
log
@perl 5.004_04
@
text
@d30 6
d45 1
a45 2

# $RCSfile: getopt.pl,v $$Revision: 4.1 $$Date: 92/08/07 18:23:58 $
d59 1
a59 1
    local $Exporter::ExportLevel;
d95 4
a98 2
    $Exporter::ExportLevel++;
    import Getopt::Std;
d109 1
a109 1
    local $Exporter::ExportLevel;
d147 1
a147 1
	    print STDERR "Unknown option: $first\n";
d157 4
a160 2
    $Exporter::ExportLevel++;
    import Getopt::Std;
@


1.1
log
@Initial revision
@
text
@d14 3
a16 1
    getopt('oDI');  # -o, -D & -I take arg.  Sets opt_* as a side effect.
d19 1
d30 5
d51 2
a52 2
sub getopt {
    local($argumentative) = @@_;
d66 7
a72 2
	    eval "\$opt_$first = \$rest;";
	    push( @@EXPORT, "\$opt_$first" );
d75 7
a81 2
	    eval "\$opt_$first = 1;";
	    push( @@EXPORT, "\$opt_$first" );
d98 2
a99 2
sub getopts {
    local($argumentative) = @@_;
d115 7
a121 2
		eval "\$opt_$first = \$rest;";
		push( @@EXPORT, "\$opt_$first" );
d124 7
a130 2
		eval "\$opt_$first = 1";
		push( @@EXPORT, "\$opt_$first" );
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d14 1
a14 3

    getopt('oDI');    # -o, -D & -I take arg.  Sets opt_* as a side effect.
    getopt('oDI', \%opts);    # -o, -D & -I take arg.  Values in %opts
a16 1
    getopts('oif:', \%opts);  # options as above. Values in %opts
a26 11
Note that, if your code is running under the recommended C<use strict
'vars'> pragma, it may be helpful to declare these package variables
via C<use vars> perhaps something like this:

    use vars qw/ $opt_foo $opt_bar /;

For those of you who don't like additional variables being created, getopt()
and getopts() will also accept a hash reference as an optional second argument. 
Hash keys will be x (where x is the switch name) with key values the value of
the argument or 1 if no argument is specified.

d31 2
a32 1
$VERSION = $VERSION = '1.01';
d43 2
a44 2
sub getopt ($;$) {
    local($argumentative, $hash) = @@_;
d46 1
a46 1
    local @@EXPORT;
d58 2
a59 7
          if (ref $hash) {
              $$hash{$first} = $rest;
          }
          else {
              ${"opt_$first"} = $rest;
              push( @@EXPORT, "\$opt_$first" );
          }
d62 2
a63 7
          if (ref $hash) {
              $$hash{$first} = 1;
          }
          else {
              ${"opt_$first"} = 1;
              push( @@EXPORT, "\$opt_$first" );
          }
d72 2
a73 4
    unless (ref $hash) { 
	local $Exporter::ExportLevel = 1;
	import Getopt::Std;
    }
d80 2
a81 2
sub getopts ($;$) {
    local($argumentative, $hash) = @@_;
d84 1
a84 1
    local @@EXPORT;
d97 2
a98 7
              if (ref $hash) {
                  $$hash{$first} = $rest;
              }
              else {
                  ${"opt_$first"} = $rest;
                  push( @@EXPORT, "\$opt_$first" );
              }
d101 2
a102 7
              if (ref $hash) {
                  $$hash{$first} = 1;
              }
              else {
                  ${"opt_$first"} = 1;
                  push( @@EXPORT, "\$opt_$first" );
              }
d112 1
a112 1
	    warn "Unknown option: $first\n";
d122 2
a123 4
    unless (ref $hash) { 
	local $Exporter::ExportLevel = 1;
	import Getopt::Std;
    }
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d31 2
a32 2
'vars'> pragma, you will need to declare these package variables
with "our":
d34 1
a34 1
    our($opt_foo, $opt_bar);
d36 1
a36 1
For those of you who don't like additional global variables being created, getopt()
a40 4
To allow programs to process arguments that look like switches, but aren't,
both functions will stop processing switches when they see the argument
C<-->.  The C<--> will be removed from @@ARGV.

d45 1
a45 1
$VERSION = '1.02';
a62 4
	if (/^--$/) {	# early exit if --
	    shift @@ARGV;
	    last;
	}
d71 7
a77 7
	    if (ref $hash) {
	        $$hash{$first} = $rest;
	    }
	    else {
	        ${"opt_$first"} = $rest;
	        push( @@EXPORT, "\$opt_$first" );
	    }
d80 7
a86 7
	    if (ref $hash) {
	        $$hash{$first} = 1;
	    }
	    else {
	        ${"opt_$first"} = 1;
	        push( @@EXPORT, "\$opt_$first" );
	    }
a113 4
	if (/^--$/) {	# early exit if --
	    shift @@ARGV;
	    last;
	}
d115 2
a116 2
	if ($pos >= 0) {
	    if (defined($args[$pos+1]) and ($args[$pos+1] eq ':')) {
d118 1
a118 1
		if ($rest eq '') {
d122 17
a138 17
		if (ref $hash) {
		    $$hash{$first} = $rest;
		}
		else {
		    ${"opt_$first"} = $rest;
		    push( @@EXPORT, "\$opt_$first" );
		}
	    }
	    else {
		if (ref $hash) {
		    $$hash{$first} = 1;
		}
		else {
		    ${"opt_$first"} = 1;
		    push( @@EXPORT, "\$opt_$first" );
		}
		if ($rest eq '') {
d149 1
a149 1
	    if ($rest ne '') {
d165 1
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d15 1
a15 1
    getopt('oDI');    # -o, -D & -I take arg.  Sets $opt_* as a side effect.
d18 1
a18 1
		      # Sets $opt_* as a side effect.
d23 1
a23 1
The getopt() function processes single-character switches with switch
d26 3
a28 7
switch name) to the value of the argument if an argument is expected,
or 1 otherwise.  Switches which take an argument don't care whether
there is a space between the switch and the argument.

The getopts() function is similar, but you should pass to it the list of all
switches to be recognized.  If unspecified switches are found on the
command-line, the user will be warned that an unknown option was given.
d34 1
a34 1
    our($opt_x, $opt_y);
d49 1
a49 1
$VERSION = '1.03';
d60 3
a62 5
sub getopt (;$$) {
    my ($argumentative, $hash) = @@_;
    $argumentative = '' if !defined $argumentative;
    my ($first,$rest);
    local $_;
d114 3
a116 4
    my ($argumentative, $hash) = @@_;
    my (@@args,$first,$rest);
    my $errs = 0;
    local $_;
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@a48 23
=head1 C<--help> and C<--version>

If C<-> is not a recognized switch letter, getopts() supports arguments
C<--help> and C<--version>.  If C<main::HELP_MESSAGE()> and/or
C<main::VERSION_MESSAGE()> are defined, they are called; the arguments are
the output file handle, the name of option-processing package, its version,
and the switches string.  If the subroutines are not defined, an attempt is
made to generate intelligent messages; for best results, define $main::VERSION.

If embedded documentation (in pod format, see L<perlpod>) is detected
in the script, C<--help> will also show how to access the documentation.

Note that due to excessive paranoia, if $Getopt::Std::STANDARD_HELP_VERSION
isn't true (the default is false), then the messages are printed on STDERR,
and the processing continues after the messages are printed.  This being
the opposite of the standard-conforming behaviour, it is strongly recommended
to set $Getopt::Std::STANDARD_HELP_VERSION to true.

One can change the output file handle of the messages by setting
$Getopt::Std::OUTPUT_HELP_VERSION.  One can print the messages of C<--help>
(without the C<Usage:> line) and C<--version> by calling functions help_mess()
and version_mess() with the switches string as an argument.

d53 1
a53 3
$VERSION = '1.04';
# uncomment the next line to disable 1.03-backward compatibility paranoia
# $STANDARD_HELP_VERSION = 1;
a114 76
sub output_h () {
  return $OUTPUT_HELP_VERSION if defined $OUTPUT_HELP_VERSION;
  return \*STDOUT if $STANDARD_HELP_VERSION;
  return \*STDERR;
}

sub try_exit () {
    exit 0 if $STANDARD_HELP_VERSION;
    my $p = __PACKAGE__;
    print {output_h()} <<EOM;
  [Now continuing due to backward compatibility and excessive paranoia.
   See ``perldoc $p'' about \$$p\::STANDARD_HELP_VERSION.]
EOM
}

sub version_mess ($;$) {
    my $args = shift;
    my $h = output_h;
    if (@@_ and defined &main::VERSION_MESSAGE) {
	main::VERSION_MESSAGE($h, __PACKAGE__, $VERSION, $args);
    } else {
	my $v = $main::VERSION;
	$v = '[unknown]' unless defined $v;
	my $myv = $VERSION;
	$myv .= ' [paranoid]' unless $STANDARD_HELP_VERSION;
	my $perlv = $];
	$perlv = sprintf "%vd", $^V if $] >= 5.006;
	print $h <<EOH;
$0 version $v calling Getopt::Std::getopts (version $myv),
running under Perl version $perlv.
EOH
    }
}

sub help_mess ($;$) {
    my $args = shift;
    my $h = output_h;
    if (@@_ and defined &main::HELP_MESSAGE) {
	main::HELP_MESSAGE($h, __PACKAGE__, $VERSION, $args);
    } else {
	my (@@witharg) = ($args =~ /(\S)\s*:/g);
	my (@@rest) = ($args =~ /([^\s:])(?!\s*:)/g);
	my ($help, $arg) = ('', '');
	if (@@witharg) {
	    $help .= "\n\tWith arguments: -" . join " -", @@witharg;
	    $arg = "\nSpace is not required between options and their arguments.";
	}
	if (@@rest) {
	    $help .= "\n\tBoolean (without arguments): -" . join " -", @@rest;
	}
	my ($scr) = ($0 =~ m,([^/\\]+)$,);
	print $h <<EOH if @@_;			# Let the script override this

Usage: $scr [-OPTIONS [-MORE_OPTIONS]] [--] [PROGRAM_ARG1 ...]
EOH
	print $h <<EOH;

The following single-character options are accepted:$help

Options may be merged together.  -- stops processing of options.$arg
EOH
	my $has_pod;
	if ( defined $0 and $0 ne '-e' and -f $0 and -r $0
	     and open my $script, '<', $0 ) {
	    while (<$script>) {
		$has_pod = 1, last if /^=(pod|head1)/;
	    }
	}
	print $h <<EOH if $has_pod;

For more details run
	perldoc -F $0
EOH
    }
}

d121 1
a121 1
    my (@@args,$first,$rest,$exit);
d127 1
a127 1
    while(@@ARGV && ($_ = $ARGV[0]) =~ /^-(.)(.*)/s) {
d133 1
a133 1
	my $pos = index($argumentative,$first);
a165 12
	    if ($first eq '-' and $rest eq 'help') {
		version_mess($argumentative, 'main');
		help_mess($argumentative, 'main');
		try_exit();
		shift(@@ARGV);
		next;
	    } elsif ($first eq '-' and $rest eq 'version') {
		version_mess($argumentative, 'main');
		try_exit();
		shift(@@ARGV);
		next;
	    }
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d7 3
a9 1
getopt, getopts - Process single-character switches with switch clustering
d76 1
a76 1
$VERSION = '1.05';
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d7 1
a7 1
Getopt::Std, getopt, getopts - Process single-character switches with switch clustering
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d7 1
a7 1
getopt, getopts - Process single-character switches with switch clustering
@


1.1.1.9
log
@import perl 5.10.0 from CPAN
@
text
@a30 1
The getopts() function returns true unless an invalid option was found.
@


1.1.1.10
log
@import perl 5.10.1
@
text
@d75 1
a75 1
$VERSION = '1.06';
@


1.1.1.11
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d75 1
a75 1
$VERSION = '1.07';
d150 1
a150 1
   See 'perldoc $p' about \$$p\::STANDARD_HELP_VERSION.]
@


1.1.1.12
log
@Import perl-5.20.1
@
text
@d13 2
a17 3
    getopt('oDI');    # -o, -D & -I take arg.
                      # Sets $opt_* as a side effect.
    getopt('oDI', \%opts);    # -o, -D & -I take arg.  Values in %opts
d21 6
a26 7
The C<getopts()> function processes single-character switches with switch
clustering.  Pass one argument which is a string containing all switches to be
recognized.  For each switch found, if an argument is expected and provided,
C<getopts()> sets C<$opt_x> (where C<x> is the switch name) to the value of
the argument.  If an argument is expected but none is provided, C<$opt_x> is
set to an undefined value.  If a switch does not take an argument, C<$opt_x>
is set to C<1>.
d28 2
a29 2
Switches which take an argument don't care whether there is a space between
the switch and the argument.  If unspecified switches are found on the
d31 1
a31 8

The C<getopts()> function returns true unless an invalid option was found.

The C<getopt()> function is similar, but its argument is a string containing
all switches that take an argument.  If no argument is provided for a switch,
say, C<y>, the corresponding C<$opt_y> will be set to an undefined value.
Unspecified switches are silently accepted.  B<Use of C<getopts()> is not
recommended.>
d34 2
a35 2
vars> pragma, you will need to declare these package variables
with C<our>:
d39 4
a42 4
For those of you who don't like additional global variables being created,
C<getopt()> and C<getopts()> will also accept a hash reference as an optional
second argument.  Hash keys will be C<x> (where C<x> is the switch name) with
key values the value of the argument or C<1> if no argument is specified.
d75 1
a75 1
$VERSION = '1.10';
@


1.1.1.13
log
@Import perl-5.24.2
@
text
@d39 2
a40 2
Unspecified switches are silently accepted.  Use of C<getopt()> is not
recommended.
d84 1
a84 1
$VERSION = '1.11';
@


