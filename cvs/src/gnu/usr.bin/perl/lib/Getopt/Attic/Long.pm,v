head	1.11;
access;
symbols
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.11
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.10
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.9
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.8
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.7
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;


1.11
date	2010.09.24.14.59.40;	author millert;	state dead;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.41;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.12;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.38;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.32;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.38;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.55;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.41;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.44;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.44;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.11;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.45;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.32;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.04;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2004.08.09.17.47.06;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2005.01.15.21.17.20;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2006.03.28.18.48.48;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2008.09.29.17.18.35;	author millert;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	2009.10.12.18.10.55;	author millert;	state Exp;
branches;
next	;


desc
@@


1.11
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@# Getopt::Long.pm -- Universal options parsing

package Getopt::Long;

# RCS Status      : $Id: Long.pm,v 1.10 2009/10/12 18:24:41 millert Exp $
# Author          : Johan Vromans
# Created On      : Tue Sep 11 15:00:12 1990
# Last Modified By: Johan Vromans
# Last Modified On: Mon Mar 30 22:51:17 2009
# Update Count    : 1601
# Status          : Released

################ Module Preamble ################

use 5.004;

use strict;

use vars qw($VERSION);
$VERSION        =  2.38;
# For testing versions only.
#use vars qw($VERSION_STRING);
#$VERSION_STRING = "2.38";

use Exporter;
use vars qw(@@ISA @@EXPORT @@EXPORT_OK);
@@ISA = qw(Exporter);

# Exported subroutines.
sub GetOptions(@@);		# always
sub GetOptionsFromArray(@@);	# on demand
sub GetOptionsFromString(@@);	# on demand
sub Configure(@@);		# on demand
sub HelpMessage(@@);		# on demand
sub VersionMessage(@@);		# in demand

BEGIN {
    # Init immediately so their contents can be used in the 'use vars' below.
    @@EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
    @@EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
		    &GetOptionsFromArray &GetOptionsFromString);
}

# User visible variables.
use vars @@EXPORT, @@EXPORT_OK;
use vars qw($error $debug $major_version $minor_version);
# Deprecated visible variables.
use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
	    $passthrough);
# Official invisible variables.
use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);

# Public subroutines.
sub config(@@);			# deprecated name

# Private subroutines.
sub ConfigDefaults();
sub ParseOptionSpec($$);
sub OptCtl($);
sub FindOption($$$$$);
sub ValidValue ($$$$$);

################ Local Variables ################

# $requested_version holds the version that was mentioned in the 'use'
# or 'require', if any. It can be used to enable or disable specific
# features.
my $requested_version = 0;

################ Resident subroutines ################

sub ConfigDefaults() {
    # Handle POSIX compliancy.
    if ( defined $ENV{"POSIXLY_CORRECT"} ) {
	$genprefix = "(--|-)";
	$autoabbrev = 0;		# no automatic abbrev of options
	$bundling = 0;			# no bundling of single letter switches
	$getopt_compat = 0;		# disallow '+' to start options
	$order = $REQUIRE_ORDER;
    }
    else {
	$genprefix = "(--|-|\\+)";
	$autoabbrev = 1;		# automatic abbrev of options
	$bundling = 0;			# bundling off by default
	$getopt_compat = 1;		# allow '+' to start options
	$order = $PERMUTE;
    }
    # Other configurable settings.
    $debug = 0;			# for debugging
    $error = 0;			# error tally
    $ignorecase = 1;		# ignore case when matching options
    $passthrough = 0;		# leave unrecognized options alone
    $gnu_compat = 0;		# require --opt=val if value is optional
    $longprefix = "(--)";       # what does a long prefix look like
}

# Override import.
sub import {
    my $pkg = shift;		# package
    my @@syms = ();		# symbols to import
    my @@config = ();		# configuration
    my $dest = \@@syms;		# symbols first
    for ( @@_ ) {
	if ( $_ eq ':config' ) {
	    $dest = \@@config;	# config next
	    next;
	}
	push(@@$dest, $_);	# push
    }
    # Hide one level and call super.
    local $Exporter::ExportLevel = 1;
    push(@@syms, qw(&GetOptions)) if @@syms; # always export GetOptions
    $pkg->SUPER::import(@@syms);
    # And configure.
    Configure(@@config) if @@config;
}

################ Initialization ################

# Values for $order. See GNU getopt.c for details.
($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
# Version major/minor numbers.
($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;

ConfigDefaults();

################ OO Interface ################

package Getopt::Long::Parser;

# Store a copy of the default configuration. Since ConfigDefaults has
# just been called, what we get from Configure is the default.
my $default_config = do {
    Getopt::Long::Configure ()
};

sub new {
    my $that = shift;
    my $class = ref($that) || $that;
    my %atts = @@_;

    # Register the callers package.
    my $self = { caller_pkg => (caller)[0] };

    bless ($self, $class);

    # Process config attributes.
    if ( defined $atts{config} ) {
	my $save = Getopt::Long::Configure ($default_config, @@{$atts{config}});
	$self->{settings} = Getopt::Long::Configure ($save);
	delete ($atts{config});
    }
    # Else use default config.
    else {
	$self->{settings} = $default_config;
    }

    if ( %atts ) {		# Oops
	die(__PACKAGE__.": unhandled attributes: ".
	    join(" ", sort(keys(%atts)))."\n");
    }

    $self;
}

sub configure {
    my ($self) = shift;

    # Restore settings, merge new settings in.
    my $save = Getopt::Long::Configure ($self->{settings}, @@_);

    # Restore orig config and save the new config.
    $self->{settings} = Getopt::Long::Configure ($save);
}

sub getoptions {
    my ($self) = shift;

    # Restore config settings.
    my $save = Getopt::Long::Configure ($self->{settings});

    # Call main routine.
    my $ret = 0;
    $Getopt::Long::caller = $self->{caller_pkg};

    eval {
	# Locally set exception handler to default, otherwise it will
	# be called implicitly here, and again explicitly when we try
	# to deliver the messages.
	local ($SIG{__DIE__}) = 'DEFAULT';
	$ret = Getopt::Long::GetOptions (@@_);
    };

    # Restore saved settings.
    Getopt::Long::Configure ($save);

    # Handle errors and return value.
    die ($@@) if $@@;
    return $ret;
}

package Getopt::Long;

################ Back to Normal ################

# Indices in option control info.
# Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
use constant CTL_TYPE    => 0;
#use constant   CTL_TYPE_FLAG   => '';
#use constant   CTL_TYPE_NEG    => '!';
#use constant   CTL_TYPE_INCR   => '+';
#use constant   CTL_TYPE_INT    => 'i';
#use constant   CTL_TYPE_INTINC => 'I';
#use constant   CTL_TYPE_XINT   => 'o';
#use constant   CTL_TYPE_FLOAT  => 'f';
#use constant   CTL_TYPE_STRING => 's';

use constant CTL_CNAME   => 1;

use constant CTL_DEFAULT => 2;

use constant CTL_DEST    => 3;
 use constant   CTL_DEST_SCALAR => 0;
 use constant   CTL_DEST_ARRAY  => 1;
 use constant   CTL_DEST_HASH   => 2;
 use constant   CTL_DEST_CODE   => 3;

use constant CTL_AMIN    => 4;
use constant CTL_AMAX    => 5;

# FFU.
#use constant CTL_RANGE   => ;
#use constant CTL_REPEAT  => ;

# Rather liberal patterns to match numbers.
use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
use constant PAT_XINT  =>
  "(?:".
	  "[-+]?_*[1-9][0-9_]*".
  "|".
	  "0x_*[0-9a-f][0-9a-f_]*".
  "|".
	  "0b_*[01][01_]*".
  "|".
	  "0[0-7_]*".
  ")";
use constant PAT_FLOAT => "[-+]?[0-9._]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";

sub GetOptions(@@) {
    # Shift in default array.
    unshift(@@_, \@@ARGV);
    # Try to keep caller() and Carp consitent.
    goto &GetOptionsFromArray;
}

sub GetOptionsFromString(@@) {
    my ($string) = shift;
    require Text::ParseWords;
    my $args = [ Text::ParseWords::shellwords($string) ];
    $caller ||= (caller)[0];	# current context
    my $ret = GetOptionsFromArray($args, @@_);
    return ( $ret, $args ) if wantarray;
    if ( @@$args ) {
	$ret = 0;
	warn("GetOptionsFromString: Excess data \"@@$args\" in string \"$string\"\n");
    }
    $ret;
}

sub GetOptionsFromArray(@@) {

    my ($argv, @@optionlist) = @@_;	# local copy of the option descriptions
    my $argend = '--';		# option list terminator
    my %opctl = ();		# table of option specs
    my $pkg = $caller || (caller)[0];	# current context
				# Needed if linkage is omitted.
    my @@ret = ();		# accum for non-options
    my %linkage;		# linkage
    my $userlinkage;		# user supplied HASH
    my $opt;			# current option
    my $prefix = $genprefix;	# current prefix

    $error = '';

    if ( $debug ) {
	# Avoid some warnings if debugging.
	local ($^W) = 0;
	print STDERR
	  ("Getopt::Long $Getopt::Long::VERSION (",
	   '$Revision: 1.10 $', ") ",
	   "called from package \"$pkg\".",
	   "\n  ",
	   "argv: (@@$argv)",
	   "\n  ",
	   "autoabbrev=$autoabbrev,".
	   "bundling=$bundling,",
	   "getopt_compat=$getopt_compat,",
	   "gnu_compat=$gnu_compat,",
	   "order=$order,",
	   "\n  ",
	   "ignorecase=$ignorecase,",
	   "requested_version=$requested_version,",
	   "passthrough=$passthrough,",
	   "genprefix=\"$genprefix\",",
	   "longprefix=\"$longprefix\".",
	   "\n");
    }

    # Check for ref HASH as first argument.
    # First argument may be an object. It's OK to use this as long
    # as it is really a hash underneath.
    $userlinkage = undef;
    if ( @@optionlist && ref($optionlist[0]) and
	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
	$userlinkage = shift (@@optionlist);
	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
    }

    # See if the first element of the optionlist contains option
    # starter characters.
    # Be careful not to interpret '<>' as option starters.
    if ( @@optionlist && $optionlist[0] =~ /^\W+$/
	 && !($optionlist[0] eq '<>'
	      && @@optionlist > 0
	      && ref($optionlist[1])) ) {
	$prefix = shift (@@optionlist);
	# Turn into regexp. Needs to be parenthesized!
	$prefix =~ s/(\W)/\\$1/g;
	$prefix = "([" . $prefix . "])";
	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
    }

    # Verify correctness of optionlist.
    %opctl = ();
    while ( @@optionlist ) {
	my $opt = shift (@@optionlist);

	unless ( defined($opt) ) {
	    $error .= "Undefined argument in option spec\n";
	    next;
	}

	# Strip leading prefix so people can specify "--foo=i" if they like.
	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;

	if ( $opt eq '<>' ) {
	    if ( (defined $userlinkage)
		&& !(@@optionlist > 0 && ref($optionlist[0]))
		&& (exists $userlinkage->{$opt})
		&& ref($userlinkage->{$opt}) ) {
		unshift (@@optionlist, $userlinkage->{$opt});
	    }
	    unless ( @@optionlist > 0
		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
		$error .= "Option spec <> requires a reference to a subroutine\n";
		# Kill the linkage (to avoid another error).
		shift (@@optionlist)
		  if @@optionlist && ref($optionlist[0]);
		next;
	    }
	    $linkage{'<>'} = shift (@@optionlist);
	    next;
	}

	# Parse option spec.
	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
	unless ( defined $name ) {
	    # Failed. $orig contains the error message. Sorry for the abuse.
	    $error .= $orig;
	    # Kill the linkage (to avoid another error).
	    shift (@@optionlist)
	      if @@optionlist && ref($optionlist[0]);
	    next;
	}

	# If no linkage is supplied in the @@optionlist, copy it from
	# the userlinkage if available.
	if ( defined $userlinkage ) {
	    unless ( @@optionlist > 0 && ref($optionlist[0]) ) {
		if ( exists $userlinkage->{$orig} &&
		     ref($userlinkage->{$orig}) ) {
		    print STDERR ("=> found userlinkage for \"$orig\": ",
				  "$userlinkage->{$orig}\n")
			if $debug;
		    unshift (@@optionlist, $userlinkage->{$orig});
		}
		else {
		    # Do nothing. Being undefined will be handled later.
		    next;
		}
	    }
	}

	# Copy the linkage. If omitted, link to global variable.
	if ( @@optionlist > 0 && ref($optionlist[0]) ) {
	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
		if $debug;
	    my $rl = ref($linkage{$orig} = shift (@@optionlist));

	    if ( $rl eq "ARRAY" ) {
		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
	    }
	    elsif ( $rl eq "HASH" ) {
		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
	    }
	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
#		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
#		    my $t = $linkage{$orig};
#		    $$t = $linkage{$orig} = [];
#		}
#		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
#		}
#		else {
		    # Ok.
#		}
	    }
	    elsif ( $rl eq "CODE" ) {
		# Ok.
	    }
	    else {
		$error .= "Invalid option linkage for \"$opt\"\n";
	    }
	}
	else {
	    # Link to global $opt_XXX variable.
	    # Make sure a valid perl identifier results.
	    my $ov = $orig;
	    $ov =~ s/\W/_/g;
	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
		print STDERR ("=> link \"$orig\" to \@@$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$orig} = \\\@@".$pkg."::opt_$ov;");
	    }
	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
	    }
	    else {
		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
	    }
	}

	if ( $opctl{$name}[CTL_TYPE] eq 'I'
	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
	   ) {
	    $error .= "Invalid option linkage for \"$opt\"\n";
	}

    }

    # Bail out if errors found.
    die ($error) if $error;
    $error = 0;

    # Supply --version and --help support, if needed and allowed.
    if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
	if ( !defined($opctl{version}) ) {
	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
	    $linkage{version} = \&VersionMessage;
	}
	$auto_version = 1;
    }
    if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
	    $linkage{help} = \&HelpMessage;
	}
	$auto_help = 1;
    }

    # Show the options tables if debugging.
    if ( $debug ) {
	my ($arrow, $k, $v);
	$arrow = "=> ";
	while ( ($k,$v) = each(%opctl) ) {
	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
	    $arrow = "   ";
	}
    }

    # Process argument list
    my $goon = 1;
    while ( $goon && @@$argv > 0 ) {

	# Get next argument.
	$opt = shift (@@$argv);
	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;

	# Double dash is option list terminator.
	if ( $opt eq $argend ) {
	  push (@@ret, $argend) if $passthrough;
	  last;
	}

	# Look it up.
	my $tryopt = $opt;
	my $found;		# success status
	my $key;		# key (if hash type)
	my $arg;		# option argument
	my $ctl;		# the opctl entry

	($found, $opt, $ctl, $arg, $key) =
	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);

	if ( $found ) {

	    # FindOption undefines $opt in case of errors.
	    next unless defined $opt;

	    my $argcnt = 0;
	    while ( defined $arg ) {

		# Get the canonical name.
		print STDERR ("=> cname for \"$opt\" is ") if $debug;
		$opt = $ctl->[CTL_CNAME];
		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;

		if ( defined $linkage{$opt} ) {
		    print STDERR ("=> ref(\$L{$opt}) -> ",
				  ref($linkage{$opt}), "\n") if $debug;

		    if ( ref($linkage{$opt}) eq 'SCALAR'
			 || ref($linkage{$opt}) eq 'REF' ) {
			if ( $ctl->[CTL_TYPE] eq '+' ) {
			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
			      if $debug;
			    if ( defined ${$linkage{$opt}} ) {
			        ${$linkage{$opt}} += $arg;
			    }
		            else {
			        ${$linkage{$opt}} = $arg;
			    }
			}
			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
					  " to ARRAY\n")
			      if $debug;
			    my $t = $linkage{$opt};
			    $$t = $linkage{$opt} = [];
			    print STDERR ("=> push(\@@{\$L{$opt}, \"$arg\")\n")
			      if $debug;
			    push (@@{$linkage{$opt}}, $arg);
			}
			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
					  " to HASH\n")
			      if $debug;
			    my $t = $linkage{$opt};
			    $$t = $linkage{$opt} = {};
			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
			      if $debug;
			    $linkage{$opt}->{$key} = $arg;
			}
			else {
			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
			      if $debug;
			    ${$linkage{$opt}} = $arg;
		        }
		    }
		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
			print STDERR ("=> push(\@@{\$L{$opt}, \"$arg\")\n")
			    if $debug;
			push (@@{$linkage{$opt}}, $arg);
		    }
		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
			    if $debug;
			$linkage{$opt}->{$key} = $arg;
		    }
		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
			print STDERR ("=> &L{$opt}(\"$opt\"",
				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
				      ", \"$arg\")\n")
			    if $debug;
			my $eval_error = do {
			    local $@@;
			    local $SIG{__DIE__}  = 'DEFAULT';
			    eval {
				&{$linkage{$opt}}
				  (Getopt::Long::CallBack->new
				   (name    => $opt,
				    ctl     => $ctl,
				    opctl   => \%opctl,
				    linkage => \%linkage,
				    prefix  => $prefix,
				   ),
				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
				   $arg);
			    };
			    $@@;
			};
			print STDERR ("=> die($eval_error)\n")
			  if $debug && $eval_error ne '';
			if ( $eval_error =~ /^!/ ) {
			    if ( $eval_error =~ /^!FINISH\b/ ) {
				$goon = 0;
			    }
			}
			elsif ( $eval_error ne '' ) {
			    warn ($eval_error);
			    $error++;
			}
		    }
		    else {
			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
				      "\" in linkage\n");
			die("Getopt::Long -- internal error!\n");
		    }
		}
		# No entry in linkage means entry in userlinkage.
		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
		    if ( defined $userlinkage->{$opt} ) {
			print STDERR ("=> push(\@@{\$L{$opt}}, \"$arg\")\n")
			    if $debug;
			push (@@{$userlinkage->{$opt}}, $arg);
		    }
		    else {
			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
			    if $debug;
			$userlinkage->{$opt} = [$arg];
		    }
		}
		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
		    if ( defined $userlinkage->{$opt} ) {
			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
			    if $debug;
			$userlinkage->{$opt}->{$key} = $arg;
		    }
		    else {
			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
			    if $debug;
			$userlinkage->{$opt} = {$key => $arg};
		    }
		}
		else {
		    if ( $ctl->[CTL_TYPE] eq '+' ) {
			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
			  if $debug;
			if ( defined $userlinkage->{$opt} ) {
			    $userlinkage->{$opt} += $arg;
			}
			else {
			    $userlinkage->{$opt} = $arg;
			}
		    }
		    else {
			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
			$userlinkage->{$opt} = $arg;
		    }
		}

		$argcnt++;
		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
		undef($arg);

		# Need more args?
		if ( $argcnt < $ctl->[CTL_AMIN] ) {
		    if ( @@$argv ) {
			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
			    $arg = shift(@@$argv);
			    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
			    next;
			}
			warn("Value \"$$argv[0]\" invalid for option $opt\n");
			$error++;
		    }
		    else {
			warn("Insufficient arguments for option $opt\n");
			$error++;
		    }
		}

		# Any more args?
		if ( @@$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
		    $arg = shift(@@$argv);
		    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
		    next;
		}
	    }
	}

	# Not an option. Save it if we $PERMUTE and don't have a <>.
	elsif ( $order == $PERMUTE ) {
	    # Try non-options call-back.
	    my $cb;
	    if ( (defined ($cb = $linkage{'<>'})) ) {
		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
		  if $debug;
		my $eval_error = do {
		    local $@@;
		    local $SIG{__DIE__}  = 'DEFAULT';
		    eval {
			&$cb
			  (Getopt::Long::CallBack->new
			   (name    => $tryopt,
			    ctl     => $ctl,
			    opctl   => \%opctl,
			    linkage => \%linkage,
			    prefix  => $prefix,
			   ));
		    };
		    $@@;
		};
		print STDERR ("=> die($eval_error)\n")
		  if $debug && $eval_error ne '';
		if ( $eval_error =~ /^!/ ) {
		    if ( $eval_error =~ /^!FINISH\b/ ) {
			$goon = 0;
		    }
		}
		elsif ( $eval_error ne '' ) {
		    warn ($eval_error);
		    $error++;
		}
	    }
	    else {
		print STDERR ("=> saving \"$tryopt\" ",
			      "(not an option, may permute)\n") if $debug;
		push (@@ret, $tryopt);
	    }
	    next;
	}

	# ...otherwise, terminate.
	else {
	    # Push this one back and exit.
	    unshift (@@$argv, $tryopt);
	    return ($error == 0);
	}

    }

    # Finish.
    if ( @@ret && $order == $PERMUTE ) {
	#  Push back accumulated arguments
	print STDERR ("=> restoring \"", join('" "', @@ret), "\"\n")
	    if $debug;
	unshift (@@$argv, @@ret);
    }

    return ($error == 0);
}

# A readable representation of what's in an optbl.
sub OptCtl ($) {
    my ($v) = @@_;
    my @@v = map { defined($_) ? ($_) : ("<undef>") } @@$v;
    "[".
      join(",",
	   "\"$v[CTL_TYPE]\"",
	   "\"$v[CTL_CNAME]\"",
	   "\"$v[CTL_DEFAULT]\"",
	   ("\$","\@@","\%","\&")[$v[CTL_DEST] || 0],
	   $v[CTL_AMIN] || '',
	   $v[CTL_AMAX] || '',
#	   $v[CTL_RANGE] || '',
#	   $v[CTL_REPEAT] || '',
	  ). "]";
}

# Parse an option specification and fill the tables.
sub ParseOptionSpec ($$) {
    my ($opt, $opctl) = @@_;

    # Match option spec.
    if ( $opt !~ m;^
		   (
		     # Option name
		     (?: \w+[-\w]* )
		     # Alias names, or "?"
		     (?: \| (?: \? | \w[-\w]* ) )*
		   )?
		   (
		     # Either modifiers ...
		     [!+]
		     |
		     # ... or a value/dest/repeat specification
		     [=:] [ionfs] [@@%]? (?: \{\d*,?\d*\} )?
		     |
		     # ... or an optional-with-default spec
		     : (?: -?\d+ | \+ ) [@@%]?
		   )?
		   $;x ) {
	return (undef, "Error in option spec: \"$opt\"\n");
    }

    my ($names, $spec) = ($1, $2);
    $spec = '' unless defined $spec;

    # $orig keeps track of the primary name the user specified.
    # This name will be used for the internal or external linkage.
    # In other words, if the user specifies "FoO|BaR", it will
    # match any case combinations of 'foo' and 'bar', but if a global
    # variable needs to be set, it will be $opt_FoO in the exact case
    # as specified.
    my $orig;

    my @@names;
    if ( defined $names ) {
	@@names =  split (/\|/, $names);
	$orig = $names[0];
    }
    else {
	@@names = ('');
	$orig = '';
    }

    # Construct the opctl entries.
    my $entry;
    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
	# Fields are hard-wired here.
	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
    }
    elsif ( $spec =~ /^:(-?\d+|\+)([@@%])?$/ ) {
	my $def = $1;
	my $dest = $2;
	my $type = $def eq '+' ? 'I' : 'i';
	$dest ||= '$';
	$dest = $dest eq '@@' ? CTL_DEST_ARRAY
	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
	# Fields are hard-wired here.
	$entry = [$type,$orig,$def eq '+' ? undef : $def,
		  $dest,0,1];
    }
    else {
	my ($mand, $type, $dest) =
	  $spec =~ /^([=:])([ionfs])([@@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
	  if $bundling && defined($4);
	my ($mi, $cm, $ma) = ($5, $6, $7);
	return (undef, "{0} is useless in option spec: \"$opt\"\n")
	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);

	$type = 'i' if $type eq 'n';
	$dest ||= '$';
	$dest = $dest eq '@@' ? CTL_DEST_ARRAY
	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
	# Default minargs to 1/0 depending on mand status.
	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
	# Adjust mand status according to minargs.
	$mand = $mi ? '=' : ':';
	# Adjust maxargs.
	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
	  if defined($ma) && !$ma;
	return (undef, "Max less than min in option spec: \"$opt\"\n")
	  if defined($ma) && $ma < $mi;

	# Fields are hard-wired here.
	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
    }

    # Process all names. First is canonical, the rest are aliases.
    my $dups = '';
    foreach ( @@names ) {

	$_ = lc ($_)
	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);

	if ( exists $opctl->{$_} ) {
	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
	}

	if ( $spec eq '!' ) {
	    $opctl->{"no$_"} = $entry;
	    $opctl->{"no-$_"} = $entry;
	    $opctl->{$_} = [@@$entry];
	    $opctl->{$_}->[CTL_TYPE] = '';
	}
	else {
	    $opctl->{$_} = $entry;
	}
    }

    if ( $dups && $^W ) {
	foreach ( split(/\n+/, $dups) ) {
	    warn($_."\n");
	}
    }
    ($names[0], $orig);
}

# Option lookup.
sub FindOption ($$$$$) {

    # returns (1, $opt, $ctl, $arg, $key) if okay,
    # returns (1, undef) if option in error,
    # returns (0) otherwise.

    my ($argv, $prefix, $argend, $opt, $opctl) = @@_;

    print STDERR ("=> find \"$opt\"\n") if $debug;

    return (0) unless $opt =~ /^$prefix(.*)$/s;
    return (0) if $opt eq "-" && !defined $opctl->{''};

    $opt = $+;
    my $starter = $1;

    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;

    my $optarg;			# value supplied with --opt=value
    my $rest;			# remainder from unbundling

    # If it is a long option, it may include the value.
    # With getopt_compat, only if not bundling.
    if ( ($starter=~/^$longprefix$/
          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
	  && $opt =~ /^([^=]+)=(.*)$/s ) {
	$opt = $1;
	$optarg = $2;
	print STDERR ("=> option \"", $opt,
		      "\", optarg = \"$optarg\"\n") if $debug;
    }

    #### Look it up ###

    my $tryopt = $opt;		# option to try

    if ( $bundling && $starter eq '-' ) {

	# To try overrides, obey case ignore.
	$tryopt = $ignorecase ? lc($opt) : $opt;

	# If bundling == 2, long options can override bundles.
	if ( $bundling == 2 && length($tryopt) > 1
	     && defined ($opctl->{$tryopt}) ) {
	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
	      if $debug;
	}
	else {
	    $tryopt = $opt;
	    # Unbundle single letter option.
	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
	    $tryopt = substr ($tryopt, 0, 1);
	    $tryopt = lc ($tryopt) if $ignorecase > 1;
	    print STDERR ("=> $starter$tryopt unbundled from ",
			  "$starter$tryopt$rest\n") if $debug;
	    $rest = undef unless $rest ne '';
	}
    }

    # Try auto-abbreviation.
    elsif ( $autoabbrev && $opt ne "" ) {
	# Sort the possible long option names.
	my @@names = sort(keys (%$opctl));
	# Downcase if allowed.
	$opt = lc ($opt) if $ignorecase;
	$tryopt = $opt;
	# Turn option name into pattern.
	my $pat = quotemeta ($opt);
	# Look up in option names.
	my @@hits = grep (/^$pat/, @@names);
	print STDERR ("=> ", scalar(@@hits), " hits (@@hits) with \"$pat\" ",
		      "out of ", scalar(@@names), "\n") if $debug;

	# Check for ambiguous results.
	unless ( (@@hits <= 1) || (grep ($_ eq $opt, @@hits) == 1) ) {
	    # See if all matches are for the same option.
	    my %hit;
	    foreach ( @@hits ) {
		my $hit = $_;
		$hit = $opctl->{$hit}->[CTL_CNAME]
		  if defined $opctl->{$hit}->[CTL_CNAME];
		$hit{$hit} = 1;
	    }
	    # Remove auto-supplied options (version, help).
	    if ( keys(%hit) == 2 ) {
		if ( $auto_version && exists($hit{version}) ) {
		    delete $hit{version};
		}
		elsif ( $auto_help && exists($hit{help}) ) {
		    delete $hit{help};
		}
	    }
	    # Now see if it really is ambiguous.
	    unless ( keys(%hit) == 1 ) {
		return (0) if $passthrough;
		warn ("Option ", $opt, " is ambiguous (",
		      join(", ", @@hits), ")\n");
		$error++;
		return (1, undef);
	    }
	    @@hits = keys(%hit);
	}

	# Complete the option name, if appropriate.
	if ( @@hits == 1 && $hits[0] ne $opt ) {
	    $tryopt = $hits[0];
	    $tryopt = lc ($tryopt) if $ignorecase;
	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
		if $debug;
	}
    }

    # Map to all lowercase if ignoring case.
    elsif ( $ignorecase ) {
	$tryopt = lc ($opt);
    }

    # Check validity by fetching the info.
    my $ctl = $opctl->{$tryopt};
    unless  ( defined $ctl ) {
	return (0) if $passthrough;
	# Pretend one char when bundling.
	if ( $bundling == 1 && length($starter) == 1 ) {
	    $opt = substr($opt,0,1);
            unshift (@@$argv, $starter.$rest) if defined $rest;
	}
	if ( $opt eq "" ) {
	    warn ("Missing option after ", $starter, "\n");
	}
	else {
	    warn ("Unknown option: ", $opt, "\n");
	}
	$error++;
	return (1, undef);
    }
    # Apparently valid.
    $opt = $tryopt;
    print STDERR ("=> found ", OptCtl($ctl),
		  " for \"", $opt, "\"\n") if $debug;

    #### Determine argument status ####

    # If it is an option w/o argument, we're almost finished with it.
    my $type = $ctl->[CTL_TYPE];
    my $arg;

    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
	if ( defined $optarg ) {
	    return (0) if $passthrough;
	    warn ("Option ", $opt, " does not take an argument\n");
	    $error++;
	    undef $opt;
	}
	elsif ( $type eq '' || $type eq '+' ) {
	    # Supply explicit value.
	    $arg = 1;
	}
	else {
	    $opt =~ s/^no-?//i;	# strip NO prefix
	    $arg = 0;		# supply explicit value
	}
	unshift (@@$argv, $starter.$rest) if defined $rest;
	return (1, $opt, $ctl, $arg);
    }

    # Get mandatory status and type info.
    my $mand = $ctl->[CTL_AMIN];

    # Check if there is an option argument available.
    if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
	return (1, $opt, $ctl, $type eq 's' ? '' : 0) ;#unless $mand;
	$optarg = 0 unless $type eq 's';
    }

    # Check if there is an option argument available.
    if ( defined $optarg
	 ? ($optarg eq '')
	 : !(defined $rest || @@$argv > 0) ) {
	# Complain if this option needs an argument.
#	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
	if ( $mand ) {
	    return (0) if $passthrough;
	    warn ("Option ", $opt, " requires an argument\n");
	    $error++;
	    return (1, undef);
	}
	if ( $type eq 'I' ) {
	    # Fake incremental type.
	    my @@c = @@$ctl;
	    $c[CTL_TYPE] = '+';
	    return (1, $opt, \@@c, 1);
	}
	return (1, $opt, $ctl,
		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
		$type eq 's' ? '' : 0);
    }

    # Get (possibly optional) argument.
    $arg = (defined $rest ? $rest
	    : (defined $optarg ? $optarg : shift (@@$argv)));

    # Get key if this is a "name=value" pair for a hash option.
    my $key;
    if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
	     ($mand ? undef : ($type eq 's' ? "" : 1)));
	if (! defined $arg) {
	    warn ("Option $opt, key \"$key\", requires a value\n");
	    $error++;
	    # Push back.
	    unshift (@@$argv, $starter.$rest) if defined $rest;
	    return (1, undef);
	}
    }

    #### Check if the argument is valid for this option ####

    my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";

    if ( $type eq 's' ) {	# string
	# A mandatory string takes anything.
	return (1, $opt, $ctl, $arg, $key) if $mand;

	# Same for optional string as a hash value
	return (1, $opt, $ctl, $arg, $key)
	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;

	# An optional string takes almost anything.
	return (1, $opt, $ctl, $arg, $key)
	  if defined $optarg || defined $rest;
	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??

	# Check for option or option list terminator.
	if ($arg eq $argend ||
	    $arg =~ /^$prefix.+/) {
	    # Push back.
	    unshift (@@$argv, $arg);
	    # Supply empty value.
	    $arg = '';
	}
    }

    elsif ( $type eq 'i'	# numeric/integer
            || $type eq 'I'	# numeric/integer w/ incr default
	    || $type eq 'o' ) { # dec/oct/hex/bin value

	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;

	if ( $bundling && defined $rest
	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
	    ($key, $arg, $rest) = ($1, $2, $+);
	    chop($key) if $key;
	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
	    unshift (@@$argv, $starter.$rest) if defined $rest && $rest ne '';
	}
	elsif ( $arg =~ /^$o_valid$/si ) {
	    $arg =~ tr/_//d;
	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
	}
	else {
	    if ( defined $optarg || $mand ) {
		if ( $passthrough ) {
		    unshift (@@$argv, defined $rest ? $starter.$rest : $arg)
		      unless defined $optarg;
		    return (0);
		}
		warn ("Value \"", $arg, "\" invalid for option ",
		      $opt, " (",
		      $type eq 'o' ? "extended " : '',
		      "number expected)\n");
		$error++;
		# Push back.
		unshift (@@$argv, $starter.$rest) if defined $rest;
		return (1, undef);
	    }
	    else {
		# Push back.
		unshift (@@$argv, defined $rest ? $starter.$rest : $arg);
		if ( $type eq 'I' ) {
		    # Fake incremental type.
		    my @@c = @@$ctl;
		    $c[CTL_TYPE] = '+';
		    return (1, $opt, \@@c, 1);
		}
		# Supply default value.
		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
	    }
	}
    }

    elsif ( $type eq 'f' ) { # real number, int is also ok
	# We require at least one digit before a point or 'e',
	# and at least one digit following the point and 'e'.
	# [-]NN[.NN][eNN]
	my $o_valid = PAT_FLOAT;
	if ( $bundling && defined $rest &&
	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
	    $arg =~ tr/_//d;
	    ($key, $arg, $rest) = ($1, $2, $+);
	    chop($key) if $key;
	    unshift (@@$argv, $starter.$rest) if defined $rest && $rest ne '';
	}
	elsif ( $arg =~ /^$o_valid$/ ) {
	    $arg =~ tr/_//d;
	}
	else {
	    if ( defined $optarg || $mand ) {
		if ( $passthrough ) {
		    unshift (@@$argv, defined $rest ? $starter.$rest : $arg)
		      unless defined $optarg;
		    return (0);
		}
		warn ("Value \"", $arg, "\" invalid for option ",
		      $opt, " (real number expected)\n");
		$error++;
		# Push back.
		unshift (@@$argv, $starter.$rest) if defined $rest;
		return (1, undef);
	    }
	    else {
		# Push back.
		unshift (@@$argv, defined $rest ? $starter.$rest : $arg);
		# Supply default value.
		$arg = 0.0;
	    }
	}
    }
    else {
	die("Getopt::Long internal error (Can't happen)\n");
    }
    return (1, $opt, $ctl, $arg, $key);
}

sub ValidValue ($$$$$) {
    my ($ctl, $arg, $mand, $argend, $prefix) = @@_;

    if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
	return 0 unless $arg =~ /[^=]+=(.*)/;
	$arg = $1;
    }

    my $type = $ctl->[CTL_TYPE];

    if ( $type eq 's' ) {	# string
	# A mandatory string takes anything.
	return (1) if $mand;

	return (1) if $arg eq "-";

	# Check for option or option list terminator.
	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
	return 1;
    }

    elsif ( $type eq 'i'	# numeric/integer
            || $type eq 'I'	# numeric/integer w/ incr default
	    || $type eq 'o' ) { # dec/oct/hex/bin value

	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
	return $arg =~ /^$o_valid$/si;
    }

    elsif ( $type eq 'f' ) { # real number, int is also ok
	# We require at least one digit before a point or 'e',
	# and at least one digit following the point and 'e'.
	# [-]NN[.NN][eNN]
	my $o_valid = PAT_FLOAT;
	return $arg =~ /^$o_valid$/;
    }
    die("ValidValue: Cannot happen\n");
}

# Getopt::Long Configuration.
sub Configure (@@) {
    my (@@options) = @@_;

    my $prevconfig =
      [ $error, $debug, $major_version, $minor_version,
	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
	$longprefix ];

    if ( ref($options[0]) eq 'ARRAY' ) {
	( $error, $debug, $major_version, $minor_version,
	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
	  $longprefix ) = @@{shift(@@options)};
    }

    my $opt;
    foreach $opt ( @@options ) {
	my $try = lc ($opt);
	my $action = 1;
	if ( $try =~ /^no_?(.*)$/s ) {
	    $action = 0;
	    $try = $+;
	}
	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
	    ConfigDefaults ();
	}
	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
	    local $ENV{POSIXLY_CORRECT};
	    $ENV{POSIXLY_CORRECT} = 1 if $action;
	    ConfigDefaults ();
	}
	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
	    $autoabbrev = $action;
	}
	elsif ( $try eq 'getopt_compat' ) {
	    $getopt_compat = $action;
            $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
	}
	elsif ( $try eq 'gnu_getopt' ) {
	    if ( $action ) {
		$gnu_compat = 1;
		$bundling = 1;
		$getopt_compat = 0;
                $genprefix = "(--|-)";
		$order = $PERMUTE;
	    }
	}
	elsif ( $try eq 'gnu_compat' ) {
	    $gnu_compat = $action;
	}
	elsif ( $try =~ /^(auto_?)?version$/ ) {
	    $auto_version = $action;
	}
	elsif ( $try =~ /^(auto_?)?help$/ ) {
	    $auto_help = $action;
	}
	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
	    $ignorecase = $action;
	}
	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
	    $ignorecase = $action ? 2 : 0;
	}
	elsif ( $try eq 'bundling' ) {
	    $bundling = $action;
	}
	elsif ( $try eq 'bundling_override' ) {
	    $bundling = $action ? 2 : 0;
	}
	elsif ( $try eq 'require_order' ) {
	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
	}
	elsif ( $try eq 'permute' ) {
	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
	}
	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
	    $passthrough = $action;
	}
	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
	    $genprefix = $1;
	    # Turn into regexp. Needs to be parenthesized!
	    $genprefix = "(" . quotemeta($genprefix) . ")";
	    eval { '' =~ /$genprefix/; };
	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@@;
	}
	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
	    $genprefix = $1;
	    # Parenthesize if needed.
	    $genprefix = "(" . $genprefix . ")"
	      unless $genprefix =~ /^\(.*\)$/;
	    eval { '' =~ m"$genprefix"; };
	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@@;
	}
	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
	    $longprefix = $1;
	    # Parenthesize if needed.
	    $longprefix = "(" . $longprefix . ")"
	      unless $longprefix =~ /^\(.*\)$/;
	    eval { '' =~ m"$longprefix"; };
	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"") if $@@;
	}
	elsif ( $try eq 'debug' ) {
	    $debug = $action;
	}
	else {
	    die("Getopt::Long: unknown config parameter \"$opt\"")
	}
    }
    $prevconfig;
}

# Deprecated name.
sub config (@@) {
    Configure (@@_);
}

# Issue a standard message for --version.
#
# The arguments are mostly the same as for Pod::Usage::pod2usage:
#
#  - a number (exit value)
#  - a string (lead in message)
#  - a hash with options. See Pod::Usage for details.
#
sub VersionMessage(@@) {
    # Massage args.
    my $pa = setup_pa_args("version", @@_);

    my $v = $main::VERSION;
    my $fh = $pa->{-output} ||
      ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR;

    print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
	       $0, defined $v ? " version $v" : (),
	       "\n",
	       "(", __PACKAGE__, "::", "GetOptions",
	       " version ",
	       defined($Getopt::Long::VERSION_STRING)
	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
	       " Perl version ",
	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
	       ")\n");
    exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
}

# Issue a standard message for --help.
#
# The arguments are the same as for Pod::Usage::pod2usage:
#
#  - a number (exit value)
#  - a string (lead in message)
#  - a hash with options. See Pod::Usage for details.
#
sub HelpMessage(@@) {
    eval {
	require Pod::Usage;
	import Pod::Usage;
	1;
    } || die("Cannot provide help: cannot load Pod::Usage\n");

    # Note that pod2usage will issue a warning if -exitval => NOEXIT.
    pod2usage(setup_pa_args("help", @@_));

}

# Helper routine to set up a normalized hash ref to be used as
# argument to pod2usage.
sub setup_pa_args($@@) {
    my $tag = shift;		# who's calling

    # If called by direct binding to an option, it will get the option
    # name and value as arguments. Remove these, if so.
    @@_ = () if @@_ == 2 && $_[0] eq $tag;

    my $pa;
    if ( @@_ > 1 ) {
	$pa = { @@_ };
    }
    else {
	$pa = shift || {};
    }

    # At this point, $pa can be a number (exit value), string
    # (message) or hash with options.

    if ( UNIVERSAL::isa($pa, 'HASH') ) {
	# Get rid of -msg vs. -message ambiguity.
	$pa->{-message} = $pa->{-msg};
	delete($pa->{-msg});
    }
    elsif ( $pa =~ /^-?\d+$/ ) {
	$pa = { -exitval => $pa };
    }
    else {
	$pa = { -message => $pa };
    }

    # These are _our_ defaults.
    $pa->{-verbose} = 0 unless exists($pa->{-verbose});
    $pa->{-exitval} = 0 unless exists($pa->{-exitval});
    $pa;
}

# Sneak way to know what version the user requested.
sub VERSION {
    $requested_version = $_[1];
    shift->SUPER::VERSION(@@_);
}

package Getopt::Long::CallBack;

sub new {
    my ($pkg, %atts) = @@_;
    bless { %atts }, $pkg;
}

sub name {
    my $self = shift;
    ''.$self->{name};
}

use overload
  # Treat this object as an ordinary string for legacy API.
  '""'	   => \&name,
  fallback => 1;

1;

################ Documentation ################

=head1 NAME

Getopt::Long - Extended processing of command line options

=head1 SYNOPSIS

  use Getopt::Long;
  my $data   = "file.dat";
  my $length = 24;
  my $verbose;
  $result = GetOptions ("length=i" => \$length,    # numeric
                        "file=s"   => \$data,      # string
			"verbose"  => \$verbose);  # flag

=head1 DESCRIPTION

The Getopt::Long module implements an extended getopt function called
GetOptions(). This function adheres to the POSIX syntax for command
line options, with GNU extensions. In general, this means that options
have long names instead of single letters, and are introduced with a
double dash "--". Support for bundling of command line options, as was
the case with the more traditional single-letter approach, is provided
but not enabled by default.

=head1 Command Line Options, an Introduction

Command line operated programs traditionally take their arguments from
the command line, for example filenames or other information that the
program needs to know. Besides arguments, these programs often take
command line I<options> as well. Options are not necessary for the
program to work, hence the name 'option', but are used to modify its
default behaviour. For example, a program could do its job quietly,
but with a suitable option it could provide verbose information about
what it did.

Command line options come in several flavours. Historically, they are
preceded by a single dash C<->, and consist of a single letter.

    -l -a -c

Usually, these single-character options can be bundled:

    -lac

Options can have values, the value is placed after the option
character. Sometimes with whitespace in between, sometimes not:

    -s 24 -s24

Due to the very cryptic nature of these options, another style was
developed that used long names. So instead of a cryptic C<-l> one
could use the more descriptive C<--long>. To distinguish between a
bundle of single-character options and a long one, two dashes are used
to precede the option name. Early implementations of long options used
a plus C<+> instead. Also, option values could be specified either
like

    --size=24

or

    --size 24

The C<+> form is now obsolete and strongly deprecated.

=head1 Getting Started with Getopt::Long

Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
first Perl module that provided support for handling the new style of
command line options, hence the name Getopt::Long. This module also
supports single-character options and bundling. Single character
options may be any alphabetic character, a question mark, and a dash.
Long options may consist of a series of letters, digits, and dashes.
Although this is currently not enforced by Getopt::Long, multiple
consecutive dashes are not allowed, and the option name must not end
with a dash.

To use Getopt::Long from a Perl program, you must include the
following line in your Perl program:

    use Getopt::Long;

This will load the core of the Getopt::Long module and prepare your
program for using it. Most of the actual Getopt::Long code is not
loaded until you really call one of its functions.

In the default configuration, options names may be abbreviated to
uniqueness, case does not matter, and a single dash is sufficient,
even for long option names. Also, options may be placed between
non-option arguments. See L<Configuring Getopt::Long> for more
details on how to configure Getopt::Long.

=head2 Simple options

The most simple options are the ones that take no values. Their mere
presence on the command line enables the option. Popular examples are:

    --all --verbose --quiet --debug

Handling simple options is straightforward:

    my $verbose = '';	# option variable with default value (false)
    my $all = '';	# option variable with default value (false)
    GetOptions ('verbose' => \$verbose, 'all' => \$all);

The call to GetOptions() parses the command line arguments that are
present in C<@@ARGV> and sets the option variable to the value C<1> if
the option did occur on the command line. Otherwise, the option
variable is not touched. Setting the option value to true is often
called I<enabling> the option.

The option name as specified to the GetOptions() function is called
the option I<specification>. Later we'll see that this specification
can contain more than just the option name. The reference to the
variable is called the option I<destination>.

GetOptions() will return a true value if the command line could be
processed successfully. Otherwise, it will write error messages to
STDERR, and return a false result.

=head2 A little bit less simple options

Getopt::Long supports two useful variants of simple options:
I<negatable> options and I<incremental> options.

A negatable option is specified with an exclamation mark C<!> after the
option name:

    my $verbose = '';	# option variable with default value (false)
    GetOptions ('verbose!' => \$verbose);

Now, using C<--verbose> on the command line will enable C<$verbose>,
as expected. But it is also allowed to use C<--noverbose>, which will
disable C<$verbose> by setting its value to C<0>. Using a suitable
default value, the program can find out whether C<$verbose> is false
by default, or disabled by using C<--noverbose>.

An incremental option is specified with a plus C<+> after the
option name:

    my $verbose = '';	# option variable with default value (false)
    GetOptions ('verbose+' => \$verbose);

Using C<--verbose> on the command line will increment the value of
C<$verbose>. This way the program can keep track of how many times the
option occurred on the command line. For example, each occurrence of
C<--verbose> could increase the verbosity level of the program.

=head2 Mixing command line option with other arguments

Usually programs take command line options as well as other arguments,
for example, file names. It is good practice to always specify the
options first, and the other arguments last. Getopt::Long will,
however, allow the options and arguments to be mixed and 'filter out'
all the options before passing the rest of the arguments to the
program. To stop Getopt::Long from processing further arguments,
insert a double dash C<--> on the command line:

    --size 24 -- --all

In this example, C<--all> will I<not> be treated as an option, but
passed to the program unharmed, in C<@@ARGV>.

=head2 Options with values

For options that take values it must be specified whether the option
value is required or not, and what kind of value the option expects.

Three kinds of values are supported: integer numbers, floating point
numbers, and strings.

If the option value is required, Getopt::Long will take the
command line argument that follows the option and assign this to the
option variable. If, however, the option value is specified as
optional, this will only be done if that value does not look like a
valid command line option itself.

    my $tag = '';	# option variable with default value
    GetOptions ('tag=s' => \$tag);

In the option specification, the option name is followed by an equals
sign C<=> and the letter C<s>. The equals sign indicates that this
option requires a value. The letter C<s> indicates that this value is
an arbitrary string. Other possible value types are C<i> for integer
values, and C<f> for floating point values. Using a colon C<:> instead
of the equals sign indicates that the option value is optional. In
this case, if no suitable value is supplied, string valued options get
an empty string C<''> assigned, while numeric options are set to C<0>.

=head2 Options with multiple values

Options sometimes take several values. For example, a program could
use multiple directories to search for library files:

    --library lib/stdlib --library lib/extlib

To accomplish this behaviour, simply specify an array reference as the
destination for the option:

    GetOptions ("library=s" => \@@libfiles);

Alternatively, you can specify that the option can have multiple
values by adding a "@@", and pass a scalar reference as the
destination:

    GetOptions ("library=s@@" => \$libfiles);

Used with the example above, C<@@libfiles> (or C<@@$libfiles>) would
contain two strings upon completion: C<"lib/srdlib"> and
C<"lib/extlib">, in that order. It is also possible to specify that
only integer or floating point numbers are acceptable values.

Often it is useful to allow comma-separated lists of values as well as
multiple occurrences of the options. This is easy using Perl's split()
and join() operators:

    GetOptions ("library=s" => \@@libfiles);
    @@libfiles = split(/,/,join(',',@@libfiles));

Of course, it is important to choose the right separator string for
each purpose.

Warning: What follows is an experimental feature.

Options can take multiple values at once, for example

    --coordinates 52.2 16.4 --rgbcolor 255 255 149

This can be accomplished by adding a repeat specifier to the option
specification. Repeat specifiers are very similar to the C<{...}>
repeat specifiers that can be used with regular expression patterns.
For example, the above command line would be handled as follows:

    GetOptions('coordinates=f{2}' => \@@coor, 'rgbcolor=i{3}' => \@@color);

The destination for the option must be an array or array reference.

It is also possible to specify the minimal and maximal number of
arguments an option takes. C<foo=s{2,4}> indicates an option that
takes at least two and at most 4 arguments. C<foo=s{,}> indicates one
or more values; C<foo:s{,}> indicates zero or more option values.

=head2 Options with hash values

If the option destination is a reference to a hash, the option will
take, as value, strings of the form I<key>C<=>I<value>. The value will
be stored with the specified key in the hash.

    GetOptions ("define=s" => \%defines);

Alternatively you can use:

    GetOptions ("define=s%" => \$defines);

When used with command line options:

    --define os=linux --define vendor=redhat

the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
also possible to specify that only integer or floating point numbers
are acceptable values. The keys are always taken to be strings.

=head2 User-defined subroutines to handle options

Ultimate control over what should be done when (actually: each time)
an option is encountered on the command line can be achieved by
designating a reference to a subroutine (or an anonymous subroutine)
as the option destination. When GetOptions() encounters the option, it
will call the subroutine with two or three arguments. The first
argument is the name of the option. (Actually, it is an object that
stringifies to the name of the option.) For a scalar or array destination,
the second argument is the value to be stored. For a hash destination,
the second arguments is the key to the hash, and the third argument
the value to be stored. It is up to the subroutine to store the value,
or do whatever it thinks is appropriate.

A trivial application of this mechanism is to implement options that
are related to each other. For example:

    my $verbose = '';	# option variable with default value (false)
    GetOptions ('verbose' => \$verbose,
	        'quiet'   => sub { $verbose = 0 });

Here C<--verbose> and C<--quiet> control the same variable
C<$verbose>, but with opposite values.

If the subroutine needs to signal an error, it should call die() with
the desired error message as its argument. GetOptions() will catch the
die(), issue the error message, and record that an error result must
be returned upon completion.

If the text of the error message starts with an exclamation mark C<!>
it is interpreted specially by GetOptions(). There is currently one
special command implemented: C<die("!FINISH")> will cause GetOptions()
to stop processing options, as if it encountered a double dash C<-->.

In version 2.37 the first argument to the callback function was
changed from string to object. This was done to make room for
extensions and more detailed control. The object stringifies to the
option name so this change should not introduce compatibility
problems.

=head2 Options with multiple names

Often it is user friendly to supply alternate mnemonic names for
options. For example C<--height> could be an alternate name for
C<--length>. Alternate names can be included in the option
specification, separated by vertical bar C<|> characters. To implement
the above example:

    GetOptions ('length|height=f' => \$length);

The first name is called the I<primary> name, the other names are
called I<aliases>. When using a hash to store options, the key will
always be the primary name.

Multiple alternate names are possible.

=head2 Case and abbreviations

Without additional configuration, GetOptions() will ignore the case of
option names, and allow the options to be abbreviated to uniqueness.

    GetOptions ('length|height=f' => \$length, "head" => \$head);

This call will allow C<--l> and C<--L> for the length option, but
requires a least C<--hea> and C<--hei> for the head and height options.

=head2 Summary of Option Specifications

Each option specifier consists of two parts: the name specification
and the argument specification.

The name specification contains the name of the option, optionally
followed by a list of alternative names separated by vertical bar
characters.

    length	      option name is "length"
    length|size|l     name is "length", aliases are "size" and "l"

The argument specification is optional. If omitted, the option is
considered boolean, a value of 1 will be assigned when the option is
used on the command line.

The argument specification can be

=over 4

=item !

The option does not take an argument and may be negated by prefixing
it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
0 will be assigned). If the option has aliases, this applies to the
aliases as well.

Using negation on a single letter option when bundling is in effect is
pointless and will result in a warning.

=item +

The option does not take an argument and will be incremented by 1
every time it appears on the command line. E.g. C<"more+">, when used
with C<--more --more --more>, will increment the value three times,
resulting in a value of 3 (provided it was 0 or undefined at first).

The C<+> specifier is ignored if the option destination is not a scalar.

=item = I<type> [ I<desttype> ] [ I<repeat> ]

The option requires an argument of the given type. Supported types
are:

=over 4

=item s

String. An arbitrary sequence of characters. It is valid for the
argument to start with C<-> or C<-->.

=item i

Integer. An optional leading plus or minus sign, followed by a
sequence of digits.

=item o

Extended integer, Perl style. This can be either an optional leading
plus or minus sign, followed by a sequence of digits, or an octal
string (a zero, optionally followed by '0', '1', .. '7'), or a
hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
insensitive), or a binary string (C<0b> followed by a series of '0'
and '1').

=item f

Real number. For example C<3.14>, C<-6.23E24> and so on.

=back

The I<desttype> can be C<@@> or C<%> to specify that the option is
list or a hash valued. This is only needed when the destination for
the option value is not otherwise specified. It should be omitted when
not needed.

The I<repeat> specifies the number of values this option takes per
occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.

I<min> denotes the minimal number of arguments. It defaults to 1 for
options with C<=> and to 0 for options with C<:>, see below. Note that
I<min> overrules the C<=> / C<:> semantics.

I<max> denotes the maximum number of arguments. It must be at least
I<min>. If I<max> is omitted, I<but the comma is not>, there is no
upper bound to the number of argument values taken.

=item : I<type> [ I<desttype> ]

Like C<=>, but designates the argument as optional.
If omitted, an empty string will be assigned to string values options,
and the value zero to numeric options.

Note that if a string argument starts with C<-> or C<-->, it will be
considered an option on itself.

=item : I<number> [ I<desttype> ]

Like C<:i>, but if the value is omitted, the I<number> will be assigned.

=item : + [ I<desttype> ]

Like C<:i>, but if the value is omitted, the current value for the
option will be incremented.

=back

=head1 Advanced Possibilities

=head2 Object oriented interface

Getopt::Long can be used in an object oriented way as well:

    use Getopt::Long;
    $p = new Getopt::Long::Parser;
    $p->configure(...configuration options...);
    if ($p->getoptions(...options descriptions...)) ...

Configuration options can be passed to the constructor:

    $p = new Getopt::Long::Parser
             config => [...configuration options...];

=head2 Thread Safety

Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
I<not> thread safe when using the older (experimental and now
obsolete) threads implementation that was added to Perl 5.005.

=head2 Documentation and help texts

Getopt::Long encourages the use of Pod::Usage to produce help
messages. For example:

    use Getopt::Long;
    use Pod::Usage;

    my $man = 0;
    my $help = 0;

    GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
    pod2usage(1) if $help;
    pod2usage(-exitstatus => 0, -verbose => 2) if $man;

    __END__

    =head1 NAME

    sample - Using Getopt::Long and Pod::Usage

    =head1 SYNOPSIS

    sample [options] [file ...]

     Options:
       -help            brief help message
       -man             full documentation

    =head1 OPTIONS

    =over 8

    =item B<-help>

    Print a brief help message and exits.

    =item B<-man>

    Prints the manual page and exits.

    =back

    =head1 DESCRIPTION

    B<This program> will read the given input file(s) and do something
    useful with the contents thereof.

    =cut

See L<Pod::Usage> for details.

=head2 Parsing options from an arbitrary array

By default, GetOptions parses the options that are present in the
global array C<@@ARGV>. A special entry C<GetOptionsFromArray> can be
used to parse options from an arbitrary array.

    use Getopt::Long qw(GetOptionsFromArray);
    $ret = GetOptionsFromArray(\@@myopts, ...);

When used like this, the global C<@@ARGV> is not touched at all.

The following two calls behave identically:

    $ret = GetOptions( ... );
    $ret = GetOptionsFromArray(\@@ARGV, ... );

=head2 Parsing options from an arbitrary string

A special entry C<GetOptionsFromString> can be used to parse options
from an arbitrary string.

    use Getopt::Long qw(GetOptionsFromString);
    $ret = GetOptionsFromString($string, ...);

The contents of the string are split into arguments using a call to
C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
global C<@@ARGV> is not touched.

It is possible that, upon completion, not all arguments in the string
have been processed. C<GetOptionsFromString> will, when called in list
context, return both the return status and an array reference to any
remaining arguments:

    ($ret, $args) = GetOptionsFromString($string, ... );

If any arguments remain, and C<GetOptionsFromString> was not called in
list context, a message will be given and C<GetOptionsFromString> will
return failure.

=head2 Storing options values in a hash

Sometimes, for example when there are a lot of options, having a
separate variable for each of them can be cumbersome. GetOptions()
supports, as an alternative mechanism, storing options values in a
hash.

To obtain this, a reference to a hash must be passed I<as the first
argument> to GetOptions(). For each option that is specified on the
command line, the option value will be stored in the hash with the
option name as key. Options that are not actually used on the command
line will not be put in the hash, on other words,
C<exists($h{option})> (or defined()) can be used to test if an option
was used. The drawback is that warnings will be issued if the program
runs under C<use strict> and uses C<$h{option}> without testing with
exists() or defined() first.

    my %h = ();
    GetOptions (\%h, 'length=i');	# will store in $h{length}

For options that take list or hash values, it is necessary to indicate
this by appending an C<@@> or C<%> sign after the type:

    GetOptions (\%h, 'colours=s@@');	# will push to @@{$h{colours}}

To make things more complicated, the hash may contain references to
the actual destinations, for example:

    my $len = 0;
    my %h = ('length' => \$len);
    GetOptions (\%h, 'length=i');	# will store in $len

This example is fully equivalent with:

    my $len = 0;
    GetOptions ('length=i' => \$len);	# will store in $len

Any mixture is possible. For example, the most frequently used options
could be stored in variables while all other options get stored in the
hash:

    my $verbose = 0;			# frequently referred
    my $debug = 0;			# frequently referred
    my %h = ('verbose' => \$verbose, 'debug' => \$debug);
    GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
    if ( $verbose ) { ... }
    if ( exists $h{filter} ) { ... option 'filter' was specified ... }

=head2 Bundling

With bundling it is possible to set several single-character options
at once. For example if C<a>, C<v> and C<x> are all valid options,

    -vax

would set all three.

Getopt::Long supports two levels of bundling. To enable bundling, a
call to Getopt::Long::Configure is required.

The first level of bundling can be enabled with:

    Getopt::Long::Configure ("bundling");

Configured this way, single-character options can be bundled but long
options B<must> always start with a double dash C<--> to avoid
ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
options,

    -vax

would set C<a>, C<v> and C<x>, but

    --vax

would set C<vax>.

The second level of bundling lifts this restriction. It can be enabled
with:

    Getopt::Long::Configure ("bundling_override");

Now, C<-vax> would set the option C<vax>.

When any level of bundling is enabled, option values may be inserted
in the bundle. For example:

    -h24w80

is equivalent to

    -h 24 -w 80

When configured for bundling, single-character options are matched
case sensitive while long options are matched case insensitive. To
have the single-character options matched case insensitive as well,
use:

    Getopt::Long::Configure ("bundling", "ignorecase_always");

It goes without saying that bundling can be quite confusing.

=head2 The lonesome dash

Normally, a lone dash C<-> on the command line will not be considered
an option. Option processing will terminate (unless "permute" is
configured) and the dash will be left in C<@@ARGV>.

It is possible to get special treatment for a lone dash. This can be
achieved by adding an option specification with an empty name, for
example:

    GetOptions ('' => \$stdio);

A lone dash on the command line will now be a legal option, and using
it will set variable C<$stdio>.

=head2 Argument callback

A special option 'name' C<< <> >> can be used to designate a subroutine
to handle non-option arguments. When GetOptions() encounters an
argument that does not look like an option, it will immediately call this
subroutine and passes it one parameter: the argument name. Well, actually
it is an object that stringifies to the argument name.

For example:

    my $width = 80;
    sub process { ... }
    GetOptions ('width=i' => \$width, '<>' => \&process);

When applied to the following command line:

    arg1 --width=72 arg2 --width=60 arg3

This will call
C<process("arg1")> while C<$width> is C<80>,
C<process("arg2")> while C<$width> is C<72>, and
C<process("arg3")> while C<$width> is C<60>.

This feature requires configuration option B<permute>, see section
L<Configuring Getopt::Long>.

=head1 Configuring Getopt::Long

Getopt::Long can be configured by calling subroutine
Getopt::Long::Configure(). This subroutine takes a list of quoted
strings, each specifying a configuration option to be enabled, e.g.
C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
matter. Multiple calls to Configure() are possible.

Alternatively, as of version 2.24, the configuration options may be
passed together with the C<use> statement:

    use Getopt::Long qw(:config no_ignore_case bundling);

The following options are available:

=over 12

=item default

This option causes all configuration options to be reset to their
default values.

=item posix_default

This option causes all configuration options to be reset to their
default values as if the environment variable POSIXLY_CORRECT had
been set.

=item auto_abbrev

Allow option names to be abbreviated to uniqueness.
Default is enabled unless environment variable
POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.

=item getopt_compat

Allow C<+> to start options.
Default is enabled unless environment variable
POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.

=item gnu_compat

C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
C<--opt=> will give option C<opt> and empty value.
This is the way GNU getopt_long() does it.

=item gnu_getopt

This is a short way of setting C<gnu_compat> C<bundling> C<permute>
C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
fully compatible with GNU getopt_long().

=item require_order

Whether command line arguments are allowed to be mixed with options.
Default is disabled unless environment variable
POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.

See also C<permute>, which is the opposite of C<require_order>.

=item permute

Whether command line arguments are allowed to be mixed with options.
Default is enabled unless environment variable
POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
Note that C<permute> is the opposite of C<require_order>.

If C<permute> is enabled, this means that

    --foo arg1 --bar arg2 arg3

is equivalent to

    --foo --bar arg1 arg2 arg3

If an argument callback routine is specified, C<@@ARGV> will always be
empty upon successful return of GetOptions() since all options have been
processed. The only exception is when C<--> is used:

    --foo arg1 --bar arg2 -- arg3

This will call the callback routine for arg1 and arg2, and then
terminate GetOptions() leaving C<"arg3"> in C<@@ARGV>.

If C<require_order> is enabled, options processing
terminates when the first non-option is encountered.

    --foo arg1 --bar arg2 arg3

is equivalent to

    --foo -- arg1 --bar arg2 arg3

If C<pass_through> is also enabled, options processing will terminate
at the first unrecognized option, or non-option, whichever comes
first.

=item bundling (default: disabled)

Enabling this option will allow single-character options to be
bundled. To distinguish bundles from long option names, long options
I<must> be introduced with C<--> and bundles with C<->.

Note that, if you have options C<a>, C<l> and C<all>, and
auto_abbrev enabled, possible arguments and option settings are:

    using argument               sets option(s)
    ------------------------------------------
    -a, --a                      a
    -l, --l                      l
    -al, -la, -ala, -all,...     a, l
    --al, --all                  all

The surprising part is that C<--a> sets option C<a> (due to auto
completion), not C<all>.

Note: disabling C<bundling> also disables C<bundling_override>.

=item bundling_override (default: disabled)

If C<bundling_override> is enabled, bundling is enabled as with
C<bundling> but now long option names override option bundles.

Note: disabling C<bundling_override> also disables C<bundling>.

B<Note:> Using option bundling can easily lead to unexpected results,
especially when mixing long options and bundles. Caveat emptor.

=item ignore_case  (default: enabled)

If enabled, case is ignored when matching long option names. If,
however, bundling is enabled as well, single character options will be
treated case-sensitive.

With C<ignore_case>, option specifications for options that only
differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
duplicates.

Note: disabling C<ignore_case> also disables C<ignore_case_always>.

=item ignore_case_always (default: disabled)

When bundling is in effect, case is ignored on single-character
options also.

Note: disabling C<ignore_case_always> also disables C<ignore_case>.

=item auto_version (default:disabled)

Automatically provide support for the B<--version> option if
the application did not specify a handler for this option itself.

Getopt::Long will provide a standard version message that includes the
program name, its version (if $main::VERSION is defined), and the
versions of Getopt::Long and Perl. The message will be written to
standard output and processing will terminate.

C<auto_version> will be enabled if the calling program explicitly
specified a version number higher than 2.32 in the C<use> or
C<require> statement.

=item auto_help (default:disabled)

Automatically provide support for the B<--help> and B<-?> options if
the application did not specify a handler for this option itself.

Getopt::Long will provide a help message using module L<Pod::Usage>. The
message, derived from the SYNOPSIS POD section, will be written to
standard output and processing will terminate.

C<auto_help> will be enabled if the calling program explicitly
specified a version number higher than 2.32 in the C<use> or
C<require> statement.

=item pass_through (default: disabled)

Options that are unknown, ambiguous or supplied with an invalid option
value are passed through in C<@@ARGV> instead of being flagged as
errors. This makes it possible to write wrapper scripts that process
only part of the user supplied command line arguments, and pass the
remaining options to some other program.

If C<require_order> is enabled, options processing will terminate at
the first unrecognized option, or non-option, whichever comes first.
However, if C<permute> is enabled instead, results can become confusing.

Note that the options terminator (default C<-->), if present, will
also be passed through in C<@@ARGV>.

=item prefix

The string that starts options. If a constant string is not
sufficient, see C<prefix_pattern>.

=item prefix_pattern

A Perl pattern that identifies the strings that introduce options.
Default is C<--|-|\+> unless environment variable
POSIXLY_CORRECT has been set, in which case it is C<--|->.

=item long_prefix_pattern

A Perl pattern that allows the disambiguation of long and short
prefixes. Default is C<-->.

Typically you only need to set this if you are using nonstandard
prefixes and want some or all of them to have the same semantics as
'--' does under normal circumstances.

For example, setting prefix_pattern to C<--|-|\+|\/> and
long_prefix_pattern to C<--|\/> would add Win32 style argument
handling.

=item debug (default: disabled)

Enable debugging output.

=back

=head1 Exportable Methods

=over

=item VersionMessage

This subroutine provides a standard version message. Its argument can be:

=over 4

=item *

A string containing the text of a message to print I<before> printing
the standard message.

=item *

A numeric value corresponding to the desired exit status.

=item *

A reference to a hash.

=back

If more than one argument is given then the entire argument list is
assumed to be a hash.  If a hash is supplied (either as a reference or
as a list) it should contain one or more elements with the following
keys:

=over 4

=item C<-message>

=item C<-msg>

The text of a message to print immediately prior to printing the
program's usage message.

=item C<-exitval>

The desired exit status to pass to the B<exit()> function.
This should be an integer, or else the string "NOEXIT" to
indicate that control should simply be returned without
terminating the invoking process.

=item C<-output>

A reference to a filehandle, or the pathname of a file to which the
usage message should be written. The default is C<\*STDERR> unless the
exit value is less than 2 (in which case the default is C<\*STDOUT>).

=back

You cannot tie this routine directly to an option, e.g.:

    GetOptions("version" => \&VersionMessage);

Use this instead:

    GetOptions("version" => sub { VersionMessage() });

=item HelpMessage

This subroutine produces a standard help message, derived from the
program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
arguments as VersionMessage(). In particular, you cannot tie it
directly to an option, e.g.:

    GetOptions("help" => \&HelpMessage);

Use this instead:

    GetOptions("help" => sub { HelpMessage() });

=back

=head1 Return values and Errors

Configuration errors and errors in the option definitions are
signalled using die() and will terminate the calling program unless
the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
}>, or die() was trapped using C<$SIG{__DIE__}>.

GetOptions returns true to indicate success.
It returns false when the function detected one or more errors during
option parsing. These errors are signalled using warn() and can be
trapped with C<$SIG{__WARN__}>.

=head1 Legacy

The earliest development of C<newgetopt.pl> started in 1990, with Perl
version 4. As a result, its development, and the development of
Getopt::Long, has gone through several stages. Since backward
compatibility has always been extremely important, the current version
of Getopt::Long still supports a lot of constructs that nowadays are
no longer necessary or otherwise unwanted. This section describes
briefly some of these 'features'.

=head2 Default destinations

When no destination is specified for an option, GetOptions will store
the resultant value in a global variable named C<opt_>I<XXX>, where
I<XXX> is the primary name of this option. When a progam executes
under C<use strict> (recommended), these variables must be
pre-declared with our() or C<use vars>.

    our $opt_length = 0;
    GetOptions ('length=i');	# will store in $opt_length

To yield a usable Perl variable, characters that are not part of the
syntax for variables are translated to underscores. For example,
C<--fpp-struct-return> will set the variable
C<$opt_fpp_struct_return>. Note that this variable resides in the
namespace of the calling program, not necessarily C<main>. For
example:

    GetOptions ("size=i", "sizes=i@@");

with command line "-size 10 -sizes 24 -sizes 48" will perform the
equivalent of the assignments

    $opt_size = 10;
    @@opt_sizes = (24, 48);

=head2 Alternative option starters

A string of alternative option starter characters may be passed as the
first argument (or the first argument after a leading hash reference
argument).

    my $len = 0;
    GetOptions ('/', 'length=i' => $len);

Now the command line may look like:

    /length 24 -- arg

Note that to terminate options processing still requires a double dash
C<-->.

GetOptions() will not interpret a leading C<< "<>" >> as option starters
if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
option starters, use C<< "><" >>. Confusing? Well, B<using a starter
argument is strongly deprecated> anyway.

=head2 Configuration variables

Previous versions of Getopt::Long used variables for the purpose of
configuring. Although manipulating these variables still work, it is
strongly encouraged to use the C<Configure> routine that was introduced
in version 2.17. Besides, it is much easier.

=head1 Tips and Techniques

=head2 Pushing multiple values in a hash option

Sometimes you want to combine the best of hashes and arrays. For
example, the command line:

  --list add=first --list add=second --list add=third

where each successive 'list add' option will push the value of add
into array ref $list->{'add'}. The result would be like

  $list->{add} = [qw(first second third)];

This can be accomplished with a destination routine:

  GetOptions('list=s%' =>
               sub { push(@@{$list{$_[1]}}, $_[2]) });

=head1 Troubleshooting

=head2 GetOptions does not return a false result when an option is not supplied

That's why they're called 'options'.

=head2 GetOptions does not split the command line correctly

The command line is not split by GetOptions, but by the command line
interpreter (CLI). On Unix, this is the shell. On Windows, it is
COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.

It is important to know that these CLIs may behave different when the
command line contains special characters, in particular quotes or
backslashes. For example, with Unix shells you can use single quotes
(C<'>) and double quotes (C<">) to group words together. The following
alternatives are equivalent on Unix:

    "two words"
    'two words'
    two\ words

In case of doubt, insert the following statement in front of your Perl
program:

    print STDERR (join("|",@@ARGV),"\n");

to verify how your CLI passes the arguments to the program.

=head2 Undefined subroutine &main::GetOptions called

Are you running Windows, and did you write

    use GetOpt::Long;

(note the capital 'O')?

=head2 How do I put a "-?" option into a Getopt::Long?

You can only obtain this using an alias, and Getopt::Long of at least
version 2.13.

    use Getopt::Long;
    GetOptions ("help|?");    # -help and -? will both set $opt_help

=head1 AUTHOR

Johan Vromans <jvromans@@squirrel.nl>

=head1 COPYRIGHT AND DISCLAIMER

This program is Copyright 1990,2009 by Johan Vromans.
This program is free software; you can redistribute it and/or
modify it under the terms of the Perl Artistic License or the
GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any
later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

If you do not have a copy of the GNU General Public License write to
the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
MA 02139, USA.

=cut

@


1.10
log
@Merge in perl 5.10.1
@
text
@d5 1
a5 1
# RCS Status      : $Id: Long.pm,v 2.76 2009/03/30 20:54:30 jv Exp $
d290 1
a290 1
	   '$Revision: 2.76 $', ") ",
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d5 1
a5 1
# RCS Status      : $Id: Long.pm,v 2.74 2007/09/29 13:40:13 jv Exp $
d9 2
a10 2
# Last Modified On: Sat Sep 29 15:38:55 2007
# Update Count    : 1571
a12 18
################ Copyright ################

# This program is Copyright 1990,2007 by Johan Vromans.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the Perl Artistic License or the
# GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# If you do not have a copy of the GNU General Public License write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
# MA 02139, USA.

d20 1
a20 1
$VERSION        =  2.37;
d22 2
a23 2
use vars qw($VERSION_STRING);
$VERSION_STRING = "2.37";
d31 2
a32 2
sub GetOptionsFromArray($@@);	# on demand
sub GetOptionsFromString($@@);	# on demand
d190 1
a190 1
	local ($SIG{__DIE__}) = '__DEFAULT__';
d256 1
a256 1
sub GetOptionsFromString($@@) {
d270 1
a270 1
sub GetOptionsFromArray($@@) {
d290 1
a290 1
	   '$Revision: 2.74 $', ") ",
d445 8
d581 1
a581 1
			    local $SIG{__DIE__}  = '__DEFAULT__';
d699 11
a709 2
		    local $SIG{__DIE__}  = '__DEFAULT__';
		    eval { &$cb ($tryopt) };
d779 1
a779 1
		     (?: \| (?: \? | \w[-\w]* )? )*
d952 1
a952 1
    elsif ( $autoabbrev ) {
d1018 6
a1023 1
	warn ("Unknown option: ", $opt, "\n");
d1488 1
a1488 1
  # Treat this object as an oridinary string for legacy API.
a1489 1
  '0+'	   => sub { 0 },
d1755 1
a1755 1
with value C<"linux> and C<"vendor"> with value C<"redhat">. It is
d1766 2
a1767 1
argument is the name of the option. For a scalar or array destination,
d1793 6
d2168 2
a2169 1
subroutine and passes it one parameter: the argument name.
d2581 1
a2581 1
=head1 Trouble Shooting
d2632 1
a2632 1
This program is Copyright 1990,2007 by Johan Vromans.
@


1.8
log
@merge in perl 5.8.8
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pm,v 2.72 2005-04-28 21:18:33+02 jv Exp $
d9 2
a10 2
# Last Modified On: Wed Dec 14 21:17:21 2005
# Update Count    : 1458
d15 1
a15 1
# This program is Copyright 1990,2005 by Johan Vromans.
d38 1
a38 1
$VERSION        =  2.35;
d40 2
a41 2
#use vars qw($VERSION_STRING);
#$VERSION_STRING = "2.35";
d49 2
d58 2
a59 1
    @@EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure);
d78 1
a78 1
sub FindOption($$$$);
d253 14
d268 19
d288 3
a290 1
    my @@optionlist = @@_;	# local copy of the option descriptions
d308 1
a308 1
	   '$Revision: 2.72 $', ") ",
d311 1
a311 1
	   "ARGV: (@@ARGV)",
d424 1
a424 1
	    elsif ( $rl eq "SCALAR" ) {
d497 1
a497 1
    while ( $goon && @@ARGV > 0 ) {
d500 1
a500 1
	$opt = shift (@@ARGV);
d517 1
a517 1
	  FindOption ($prefix, $argend, $opt, \%opctl);
d536 2
a537 1
		    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
d593 10
a602 3
				&{$linkage{$opt}}($opt,
						  $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
						  $arg);
d672 4
a675 3
		    if ( @@ARGV ) {
			if ( ValidValue($ctl, $ARGV[0], 1, $argend, $prefix) ) {
			    $arg = shift(@@ARGV);
d680 1
a680 1
			warn("Value \"$ARGV[0]\" invalid for option $opt\n");
d690 3
a692 2
		if ( @@ARGV && ValidValue($ctl, $ARGV[0], 0, $argend, $prefix) ) {
		    $arg = shift(@@ARGV);
d736 1
a736 1
	    unshift (@@ARGV, $tryopt);
d747 1
a747 1
	unshift (@@ARGV, @@ret);
d893 1
a893 1
sub FindOption ($$$$) {
d899 1
a899 1
    my ($prefix, $argend, $opt, $opctl) = @@_;
d1017 1
a1017 1
            unshift (@@ARGV, $starter.$rest) if defined $rest;
d1049 1
a1049 1
	unshift (@@ARGV, $starter.$rest) if defined $rest;
d1058 1
a1058 1
	return (1, $opt, $ctl, $type eq 's' ? '' : 0) unless $mand;
d1065 1
a1065 1
	 : !(defined $rest || @@ARGV > 0) ) {
d1067 1
d1087 1
a1087 1
	    : (defined $optarg ? $optarg : shift (@@ARGV)));
d1099 1
a1099 1
	    unshift (@@ARGV, $starter.$rest) if defined $rest;
d1112 4
d1125 1
a1125 1
	    unshift (@@ARGV, $arg);
d1135 1
a1135 3
	my $o_valid =
	  $type eq 'o' ? "[-+]?[1-9][0-9]*|0x[0-9a-f]+|0b[01]+|0[0-7]*"
	    : "[-+]?[0-9]+";
d1142 1
a1142 1
	    unshift (@@ARGV, $starter.$rest) if defined $rest && $rest ne '';
d1144 2
a1145 1
	elsif ( $arg =~ /^($o_valid)$/si ) {
d1151 1
a1151 1
		    unshift (@@ARGV, defined $rest ? $starter.$rest : $arg)
d1161 1
a1161 1
		unshift (@@ARGV, $starter.$rest) if defined $rest;
d1166 1
a1166 1
		unshift (@@ARGV, defined $rest ? $starter.$rest : $arg);
d1183 1
d1185 2
a1186 1
	     $rest =~ /^($key_valid)([-+]?[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?)(.*)$/s ) {
d1189 1
a1189 1
	    unshift (@@ARGV, $starter.$rest) if defined $rest && $rest ne '';
d1191 4
a1194 1
	elsif ( $arg !~ /^[-+]?[0-9.]+(\.[0-9]+)?([eE][-+]?[0-9]+)?$/ ) {
d1197 1
a1197 1
		    unshift (@@ARGV, defined $rest ? $starter.$rest : $arg)
d1205 1
a1205 1
		unshift (@@ARGV, $starter.$rest) if defined $rest;
d1210 1
a1210 1
		unshift (@@ARGV, defined $rest ? $starter.$rest : $arg);
d1247 1
a1247 4
	my $o_valid =
	  $type eq 'o' ? "[-+]?[1-9][0-9]*|0x[0-9a-f]+|0b[01]+|0[0-7]*"
	    : "[-+]?[0-9]+";

d1255 2
a1256 1
	return $arg =~ /^[-+]?[0-9.]+(\.[0-9]+)?([eE][-+]?[0-9]+)?$/;
d1299 1
d1306 1
d1322 1
a1322 1
	elsif ( $try eq 'ignore_case_always' ) {
d1471 18
d1997 40
a2036 1
=head2 Storing option values in a hash
d2040 2
a2041 1
supports, as an alternative mechanism, storing options in a hash.
d2261 1
a2261 1
terminate GetOptions() leaving C<"arg2"> in C<@@ARGV>.
d2551 19
d2621 1
a2621 1
This program is Copyright 1990,2005 by Johan Vromans.
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pm,v 2.68 2003-09-23 15:24:53+02 jv Exp $
d9 2
a10 2
# Last Modified On: Tue Sep 23 15:21:23 2003
# Update Count    : 1364
d15 1
a15 1
# This program is Copyright 1990,2002 by Johan Vromans.
d38 1
a38 1
$VERSION        =  2.34;
d41 1
a41 1
#$VERSION_STRING = "2.33_03";
d66 1
a66 1
use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version);
d76 1
d109 1
d235 1
a235 1
use constant CTL_MAND    => 2;
d243 2
a244 1
use constant CTL_DEFAULT => 4;
d270 1
a270 1
	   '$Revision: 2.68 $', ") ",
d284 2
a285 1
	   "genprefix=\"$genprefix\".",
d294 1
a294 1
	 "$optionlist[0]" =~ /^(?:.*\=)?HASH\([^\(]*\)$/ ) {
d318 5
d486 2
a487 1
	    if ( defined $arg ) {
d619 30
d713 1
a713 1
	   $v[CTL_MAND] ? "O" : "M",
d715 2
a716 1
	   "\"$v[CTL_DEFAULT]\"",
d738 2
a739 2
		     # ... or a value/dest specification
		     [=:] [ionfs] [@@%]?
d773 1
a773 1
	$entry = [$spec,$orig,0,CTL_DEST_SCALAR,undef];
d775 1
a775 1
    elsif ( $spec =~ /:(-?\d+|\+)([@@%])?/ ) {
d783 2
a784 1
	$entry = [$type,$orig,0,$dest,$def eq '+' ? undef : $def];
d787 8
a794 1
	my ($mand, $type, $dest) = $spec =~ /([=:])([ionfs])([@@%])?/;
d799 11
d811 1
a811 1
	$entry = [$type,$orig,$mand eq '=',$dest,undef];
d868 1
a868 1
    if ( ($starter eq "--" 
d923 4
a926 3
		$_ = $opctl->{$_}->[CTL_CNAME]
		  if defined $opctl->{$_}->[CTL_CNAME];
		$hit{$_} = 1;
d967 1
a967 1
	if ( $bundling == 1) {
d1006 1
a1006 1
    my $mand = $ctl->[CTL_MAND];
d1165 41
d1213 2
a1214 1
	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help ];
d1219 2
a1220 2
	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help ) =
	    @@{shift(@@options)};
d1295 1
a1295 1
	    eval { '' =~ /$genprefix/; };
d1298 8
d1485 9
a1493 6
Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was
the first Perl module that provided support for handling the new style
of command line options, hence the name Getopt::Long. This module
also supports single-character options and bundling. In this case, the
options are restricted to alphabetic characters only, and the
characters C<?> and C<->.
d1628 1
a1628 1
only integer or floating point numbers are acceptible values.
d1640 20
d1679 1
a1679 1
are acceptible values. The keys are always taken to be strings.
d1709 1
a1709 1
If the text of the error message starts with an exclamantion mark C<!>
d1725 2
a1726 1
called I<aliases>.
d1762 5
a1766 4
The option does not take an argument and may be negated, i.e. prefixed
by "no". E.g. C<"foo!"> will allow C<--foo> (a value of 1 will be
assigned) and C<--nofoo> and C<--no-foo> (a value of 0 will be assigned). If the
option has aliases, this applies to the aliases as well.
d1780 1
a1780 1
=item = I<type> [ I<desttype> ]
d1817 11
d1915 1
a1915 1
    B<This program> will read the given input file(s) and do someting
d1922 1
a1922 1
=head2 Storing options in a hash
d1987 1
a1987 1
abiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
d2140 1
a2140 1
empty upon succesful return of GetOptions() since all options have been
d2177 1
a2177 1
The suprising part is that C<--a> sets option C<a> (due to auto
d2261 15
a2275 2
Default is C<(--|-|\+)> unless environment variable
POSIXLY_CORRECT has been set, in which case it is C<(--|-)>.
d2487 1
a2487 1
This program is Copyright 2003,1990 by Johan Vromans.
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d1 1
a1 1
# GetOpt::Long.pm -- Universal options parsing
d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pm,v 2.58 2002-06-20 09:32:09+02 jv Exp $
d9 2
a10 2
# Last Modified On: Thu Jun 20 07:48:05 2002
# Update Count    : 1083
d38 1
a38 1
$VERSION        =  2.32;
d40 2
a41 2
use vars qw($VERSION_STRING);
$VERSION_STRING = "2.32";
d44 8
a52 3
use vars qw(@@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS);
@@ISA = qw(Exporter);
%EXPORT_TAGS = qw();
d55 2
a56 2
    @@EXPORT      = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
    @@EXPORT_OK   = qw();
d66 1
a66 1
use vars qw($genprefix $caller $gnu_compat);
d69 1
a69 3
sub Configure (@@);
sub config (@@);			# deprecated name
sub GetOptions;
d72 4
a75 4
sub ConfigDefaults ();
sub ParseOptionSpec ($$);
sub OptCtl ($);
sub FindOption ($$$$);
d79 5
d86 1
a86 1
sub ConfigDefaults () {
d121 1
a121 1
	push (@@$dest, $_);	# push
d125 1
d128 1
a128 1
    Configure (@@config) if @@config;
d217 2
d247 1
a247 1
sub GetOptions {
d262 22
a283 17
    print STDERR ("GetOpt::Long $Getopt::Long::VERSION (",
		  '$Revision: 2.58 $', ") ",
		  "called from package \"$pkg\".",
		  "\n  ",
		  "ARGV: (@@ARGV)",
		  "\n  ",
		  "autoabbrev=$autoabbrev,".
		  "bundling=$bundling,",
		  "getopt_compat=$getopt_compat,",
		  "gnu_compat=$gnu_compat,",
		  "order=$order,",
		  "\n  ",
		  "ignorecase=$ignorecase,",
		  "passthrough=$passthrough,",
		  "genprefix=\"$genprefix\".",
		  "\n")
	if $debug;
d377 12
a388 1
	    elsif ( $rl eq "SCALAR" || $rl eq "CODE" ) {
d422 16
d457 4
a460 1
	last if $opt eq $argend;
d499 20
d767 1
d867 9
d905 5
d937 1
a937 1
	    $opt =~ s/^no//i;	# strip NO prefix
d983 9
a991 1
	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 1);
d996 2
d1025 4
a1028 3
	if ( $bundling && defined $rest && $rest =~ /^($o_valid)(.*)$/si ) {
	    $arg = $1;
	    $rest = $2;
d1071 3
a1073 3
	     $rest =~ /^([-+]?[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?)(.*)$/s ) {
	    $arg = $1;
	    $rest = $+;
d1099 1
a1099 1
	die("GetOpt::Long internal error (Can't happen)\n");
d1111 1
a1111 1
	$gnu_compat, $passthrough, $genprefix ];
d1116 2
a1117 1
	  $gnu_compat, $passthrough, $genprefix ) = @@{shift(@@options)};
d1153 6
d1210 95
a1502 1
    my @@libfiles = ();
d1505 10
a1514 4
Used with the example above, C<@@libfiles> would contain two strings
upon completion: C<"lib/srdlib"> and C<"lib/extlib">, in that order.
It is also possible to specify that only integer or floating point
numbers are acceptible values.
a1519 1
    my @@libfiles = ();
a1531 1
    my %defines = ();
d1534 4
d1542 4
a1545 4
the hash C<%defines> will contain two keys, C<"os"> with value
C<"linux> and C<"vendor"> with value C<"redhat">.
It is also possible to specify that only integer or floating point
numbers are acceptible values. The keys are always taken to be strings.
d1629 1
a1629 1
assigned) and C<--nofoo> (a value of 0 will be assigned). If the
d1742 1
a1742 1
    sample - Using GetOpt::Long and Pod::Usage
d1893 1
a1893 1
A special option 'name' C<<>> can be used to designate a subroutine
a1915 1

d2064 27
d2103 3
d2123 77
a2211 2
Errors that can't happen are signalled using Carp::croak().

a2277 17
=head2 Warning: Ignoring '!' modifier for short option

This warning is issued when the '!' modifier is applied to a short
(one-character) option and bundling is in effect. E.g.,

    Getopt::Long::Configure("bundling");
    GetOptions("foo|f!" => \$foo);

Note that older Getopt::Long versions did not issue a warning, because
the '!' modifier was applied to the first name only. This bug was
fixed in 2.22.

Solution: separate the long and short names and apply the '!' to the
long names only, e.g.,

    GetOptions("foo!" => \$foo, "f" => \$foo);

d2286 1
a2286 1
COMMAND.COM or CMD.EXE. Other operating systems have other CLIs. 
d2305 8
d2327 1
a2327 1
This program is Copyright 2002,1990 by Johan Vromans.
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pl,v 2.26 2001-01-31 10:20:29+01 jv Exp $
d9 2
a10 2
# Last Modified On: Sat Jan  6 17:12:27 2001
# Update Count    : 748
d15 1
a15 1
# This program is Copyright 1990,2001 by Johan Vromans.
d37 5
a41 3
use vars qw($VERSION $VERSION_STRING);
$VERSION        =  2.25;
$VERSION_STRING = "2.25";
a43 1
use AutoLoader qw(AUTOLOAD);
d70 3
a72 2
sub FindOption ($$$$$$$);
sub Croak (@@);			# demand loading the real Croak
a134 5
# NOTE: The object oriented routines use $error for thread locking.
my $_lock = sub {
    lock ($Getopt::Long::error) if $] >= 5.005
};

a137 1
    &$_lock;
a152 1
	&$_lock;
d163 2
a164 2
	Getopt::Long::Croak(__PACKAGE__.": unhandled attributes: ".
			    join(" ", sort(keys(%atts))));
a172 2
    &$_lock;

d177 1
a177 1
    $self->{settings} = Configure ($save);
a182 2
    &$_lock;

d189 8
a196 1
    eval { $ret = Getopt::Long::GetOptions (@@_); };
d208 27
a234 15
################ Package return ################

1;

__END__

################ AutoLoading subroutines ################

# RCS Status      : $Id: GetoptLongAl.pl,v 2.30 2001-01-31 10:21:11+01 jv Exp $
# Author          : Johan Vromans
# Created On      : Fri Mar 27 11:50:30 1998
# Last Modified By: Johan Vromans
# Last Modified On: Tue Dec 26 18:01:16 2000
# Update Count    : 98
# Status          : Released
d240 1
a240 2
    my %opctl = ();		# table of arg.specs (long and abbrevs)
    my %bopctl = ();		# table of arg.specs (bundles)
a242 1
    my %aliases= ();		# alias table
d247 1
a247 2
    my $genprefix = $genprefix;	# so we can call the same module many times
    my @@opctl;			# the possible long option names
d251 2
a252 1
    print STDERR ("GetOpt::Long $Getopt::Long::VERSION ",
a254 2
		  'GetOptionsAl $Revision: 2.30 $ ',
		  "\n  ",
d273 1
a273 1
    if ( ref($optionlist[0]) and
d282 1
a282 1
    if ( $optionlist[0] =~ /^\W+$/
d286 1
a286 1
	$genprefix = shift (@@optionlist);
d288 3
a290 2
	$genprefix =~ s/(\W)/\\$1/g;
	$genprefix = "([" . $genprefix . "])";
d295 1
a295 2
    %bopctl = ();
    while ( @@optionlist > 0 ) {
d299 1
a299 1
	$opt = $+ if $opt =~ /^$genprefix+(.*)$/s;
d311 3
d320 8
a327 3
	# Match option spec. Allow '?' as an alias only.
	if ( $opt !~ /^((\w+[-\w]*)(\|(\?|\w[-\w]*)?)*)?([!~+]|[=:][infse][@@%]?)?$/ ) {
	    $error .= "Error in option spec: \"$opt\"\n";
a329 60
	my ($o, $c, $a) = ($1, $5);
	$c = '' unless defined $c;

	# $linko keeps track of the primary name the user specified.
	# This name will be used for the internal or external linkage.
	# In other words, if the user specifies "FoO|BaR", it will
	# match any case combinations of 'foo' and 'bar', but if a global
	# variable needs to be set, it will be $opt_FoO in the exact case
	# as specified.
	my $linko;

	if ( ! defined $o ) {
	    # empty -> '-' option
	    $linko = $o = '';
	    $opctl{''} = $c;
	    $bopctl{''} = $c if $bundling;
	}
	else {
	    # Handle alias names
	    my @@o =  split (/\|/, $o);
	    $linko = $o = $o[0];
	    # Force an alias if the option name is not locase.
	    $a = $o unless $o eq lc($o);
	    $o = lc ($o)
		if $ignorecase > 1
		    || ($ignorecase
			&& ($bundling ? length($o) > 1  : 1));

	    foreach ( @@o ) {
		if ( $bundling && length($_) == 1 ) {
		    $_ = lc ($_) if $ignorecase > 1;
		    if ( $c eq '!' ) {
			$opctl{"no$_"} = $c;
			warn ("Ignoring '!' modifier for short option $_\n");
			$opctl{$_} = $bopctl{$_} = '';
		    }
		    else {
			$opctl{$_} = $bopctl{$_} = $c;
		    }
		}
		else {
		    $_ = lc ($_) if $ignorecase;
		    if ( $c eq '!' ) {
			$opctl{"no$_"} = $c;
			$opctl{$_} = ''
		    }
		    else {
			$opctl{$_} = $c;
		    }
		}
		if ( defined $a ) {
		    # Note alias.
		    $aliases{$_} = $a;
		}
		else {
		    # Set primary name.
		    $a = $_;
		}
	    }
	}
d335 4
a338 4
		if ( exists $userlinkage->{$linko} &&
		     ref($userlinkage->{$linko}) ) {
		    print STDERR ("=> found userlinkage for \"$linko\": ",
				  "$userlinkage->{$linko}\n")
d340 1
a340 1
		    unshift (@@optionlist, $userlinkage->{$linko});
d351 1
a351 1
	    print STDERR ("=> link \"$linko\" to $optionlist[0]\n")
d353 4
a356 2
	    if ( ref($optionlist[0]) =~ /^(SCALAR|CODE)$/ ) {
		$linkage{$linko} = shift (@@optionlist);
d358 2
a359 7
	    elsif ( ref($optionlist[0]) =~ /^(ARRAY)$/ ) {
		$linkage{$linko} = shift (@@optionlist);
		$opctl{$o} .= '@@'
		  if $opctl{$o} ne '' and $opctl{$o} !~ /\@@$/;
		$bopctl{$o} .= '@@'
		  if $bundling and defined $bopctl{$o} and
		    $bopctl{$o} ne '' and $bopctl{$o} !~ /\@@$/;
d361 2
a362 7
	    elsif ( ref($optionlist[0]) =~ /^(HASH)$/ ) {
		$linkage{$linko} = shift (@@optionlist);
		$opctl{$o} .= '%'
		  if $opctl{$o} ne '' and $opctl{$o} !~ /\%$/;
		$bopctl{$o} .= '%'
		  if $bundling and defined $bopctl{$o} and
		    $bopctl{$o} ne '' and $bopctl{$o} !~ /\%$/;
d371 1
a371 1
	    my $ov = $linko;
d373 2
a374 2
	    if ( $c =~ /@@/ ) {
		print STDERR ("=> link \"$linko\" to \@@$pkg","::opt_$ov\n")
d376 1
a376 1
		eval ("\$linkage{\$linko} = \\\@@".$pkg."::opt_$ov;");
d378 2
a379 2
	    elsif ( $c =~ /%/ ) {
		print STDERR ("=> link \"$linko\" to \%$pkg","::opt_$ov\n")
d381 1
a381 1
		eval ("\$linkage{\$linko} = \\\%".$pkg."::opt_$ov;");
d384 1
a384 1
		print STDERR ("=> link \"$linko\" to \$$pkg","::opt_$ov\n")
d386 1
a386 1
		eval ("\$linkage{\$linko} = \\\$".$pkg."::opt_$ov;");
a394 3
    # Sort the possible long option names.
    @@opctl = sort(keys (%opctl)) if $autoabbrev;

d400 1
a400 6
	    print STDERR ($arrow, "\$opctl{\"$k\"} = \"$v\"\n");
	    $arrow = "   ";
	}
	$arrow = "=> ";
	while ( ($k,$v) = each(%bopctl) ) {
	    print STDERR ($arrow, "\$bopctl{\"$k\"} = \"$v\"\n");
d409 1
a409 2
	#### Get next argument ####

d411 1
a411 3
	print STDERR ("=> option \"", $opt, "\"\n") if $debug;

	#### Determine what we have ####
d414 1
a414 6
	if ( $opt eq $argend ) {
	    # Finish. Push back accumulated arguments and return.
	    unshift (@@ARGV, @@ret)
		if $order == $PERMUTE;
	    return ($error == 0);
	}
d416 1
a418 2
	my $dsttype;		# destination type ('@@' or '%')
	my $incr;		# destination increment
d421 1
d423 2
a424 3
	($found, $opt, $arg, $dsttype, $incr, $key) =
	  FindOption ($genprefix, $argend, $opt,
		      \%opctl, \%bopctl, \@@opctl, \%aliases);
d432 5
a436 5
		if ( defined $aliases{$opt} ) {
		    print STDERR ("=> alias \"$opt\" -> \"$aliases{$opt}\"\n")
		      if $debug;
		    $opt = $aliases{$opt};
		}
d443 1
a443 1
			if ( $incr ) {
d470 3
a472 1
			print STDERR ("=> &L{$opt}(\"$opt\", \"$arg\")\n")
d474 9
a482 3
			local ($@@);
			eval {
			    &{$linkage{$opt}}($opt, $arg);
d484 4
a487 3
			print STDERR ("=> die($@@)\n") if $debug && $@@ ne '';
			if ( $@@ =~ /^!/ ) {
			    if ( $@@ =~ /^!FINISH\b/ ) {
d491 2
a492 2
			elsif ( $@@ ne '' ) {
			    warn ($@@);
d499 1
a499 1
			Croak ("Getopt::Long -- internal error!\n");
d503 1
a503 1
		elsif ( $dsttype eq '@@' ) {
d515 1
a515 1
		elsif ( $dsttype eq '%' ) {
d528 1
a528 1
		    if ( $incr ) {
d551 7
a557 3
		local ($@@);
		eval {
		    &$cb ($tryopt);
d559 4
a562 3
		print STDERR ("=> die($@@)\n") if $debug && $@@ ne '';
		if ( $@@ =~ /^!/ ) {
		    if ( $@@ =~ /^!FINISH\b/ ) {
d566 2
a567 2
		elsif ( $@@ ne '' ) {
		    warn ($@@);
d589 1
a589 1
    if ( $order == $PERMUTE ) {
d592 2
a593 2
	    if $debug && @@ret > 0;
	unshift (@@ARGV, @@ret) if @@ret > 0;
d599 118
d718 1
a718 1
sub FindOption ($$$$$$$) {
d720 2
a721 1
    # returns (1, $opt, $arg, $dsttype, $incr, $key) if okay,
d724 1
a724 3
    my ($prefix, $argend, $opt, $opctl, $bopctl, $names, $aliases) = @@_;
    my $key;			# hash key for a hash option
    my $arg;
d726 1
a726 1
    print STDERR ("=> find \"$opt\", prefix=\"$prefix\"\n") if $debug;
d728 2
a729 2
    return 0 unless $opt =~ /^$prefix(.*)$/s;
    return 0 if $opt eq "-" && !defined $opctl->{""};
d732 1
a732 1
    my ($starter) = $1;
d736 2
a737 2
    my $optarg = undef;	# value supplied with --opt=value
    my $rest = undef;	# remainder from unbundling
d740 4
a743 2
    if (($starter eq "--" || ($getopt_compat && !$bundling))
	&& $opt =~ /^([^=]+)=(.*)$/s ) {
a752 4
    my $optbl = $opctl;		# table to look it up (long names)
    my $type;
    my $dsttype = '';
    my $incr = 0;
d755 3
a757 8
	# Unbundle single letter option.
	$rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : "";
	$tryopt = substr ($tryopt, 0, 1);
	$tryopt = lc ($tryopt) if $ignorecase > 1;
	print STDERR ("=> $starter$tryopt unbundled from ",
		      "$starter$tryopt$rest\n") if $debug;
	$rest = undef unless $rest ne '';
	$optbl = $bopctl;	# look it up in the short names table
d760 12
a771 4
	if ( $bundling == 2 and
	     defined ($rest) and
	     defined ($type = $opctl->{$tryopt.$rest}) ) {
	    print STDERR ("=> $starter$tryopt rebundled to ",
d773 1
a773 2
	    $tryopt .= $rest;
	    undef $rest;
d779 2
d782 2
a783 1
	$tryopt = $opt = lc ($opt) if $ignorecase;
d787 1
a787 1
	my @@hits = grep (/^$pat/, @@{$names});
d789 1
a789 1
		      "out of ", scalar(@@{$names}), "\n") if $debug;
d796 2
a797 1
		$_ = $aliases->{$_} if defined $aliases->{$_};
d806 1
a806 2
		undef $opt;
		return (1, $opt,$arg,$dsttype,$incr,$key);
d826 2
a827 2
    $type = $optbl->{$tryopt} unless defined $type;
    unless  ( defined $type ) {
d831 1
a831 1
	return (1, $opt,$arg,$dsttype,$incr,$key);
d835 2
a836 1
    print STDERR ("=> found \"$type\" for \"", $opt, "\"\n") if $debug;
d841 3
d852 2
a853 2
	    $arg = 1;		# supply explicit value
	    $incr = $type eq '+';
d856 1
a856 1
	    substr ($opt, 0, 2) = ''; # strip NO prefix
d860 1
a860 1
	return (1, $opt,$arg,$dsttype,$incr,$key);
d864 1
a864 2
    my $mand;
    ($mand, $type, $dsttype, $key) = $type =~ /^(.)(.)([@@%]?)$/;
d867 3
a869 5
    if ( $gnu_compat ) {
	return (1, $opt, $optarg, $dsttype, $incr, $key)
	  if defined $optarg;
	return (1, $opt, $type eq "s" ? '' : 0, $dsttype, $incr, $key)
	  if $mand eq ':';
d877 1
a877 1
	if ( $mand eq "=" ) {
d881 1
a881 1
	    undef $opt;
d883 9
a891 1
	return (1, $opt, $type eq "s" ? '' : 0, $dsttype, $incr, $key);
d899 4
a902 3
    $key = undef;
    if ($dsttype eq '%' && defined $arg) {
	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2) : ($arg, 1);
d907 1
a907 1
    if ( $type eq "s" ) {	# string
d909 1
a909 1
	return (1, $opt,$arg,$dsttype,$incr,$key) if $mand eq "=";
d912 1
a912 1
	return (1, $opt,$arg,$dsttype,$incr,$key)
d914 1
a914 1
	return (1, $opt,$arg,$dsttype,$incr,$key) if $arg eq "-"; # ??
d926 9
a934 2
    elsif ( $type eq "n" || $type eq "i" ) { # numeric/integer
	if ( $bundling && defined $rest && $rest =~ /^([-+]?[0-9]+)(.*)$/s ) {
d937 1
d940 5
a944 2
	elsif ( $arg !~ /^[-+]?[0-9]+$/ ) {
	    if ( defined $optarg || $mand eq "=" ) {
d951 3
a953 1
		      $opt, " (number expected)\n");
a954 1
		undef $opt;
d957 1
d962 6
d969 1
a969 1
		$arg = 0;
d974 1
a974 1
    elsif ( $type eq "f" ) { # real number, int is also ok
d985 1
a985 1
	    if ( defined $optarg || $mand eq "=" ) {
a993 1
		undef $opt;
d996 1
d1007 1
a1007 1
	Croak ("GetOpt::Long internal error (Can't happen)\n");
d1009 1
a1009 1
    return (1, $opt, $arg, $dsttype, $incr, $key);
d1054 1
a1054 1
		$permute = 1;
d1086 1
a1086 1
	    Croak ("Getopt::Long: invalid pattern \"$genprefix\"") if $@@;
d1094 1
a1094 1
	    Croak ("Getopt::Long: invalid pattern \"$genprefix\"") if $@@;
d1100 1
a1100 1
	    Croak ("Getopt::Long: unknown config parameter \"$opt\"")
a1110 7
# To prevent Carp from being loaded unnecessarily.
sub Croak (@@) {
    require 'Carp.pm';
    $Carp::CarpLevel = 1;
    Carp::croak(@@_);
};

d1120 6
a1125 1
  $result = GetOptions (...option-descriptions...);
d1235 1
a1235 1
A negatable option is specified with a exclamation mark C<!> after the
d1352 6
a1357 3
will call the subroutine with two arguments: the name of the option,
and the value to be assigned. It is up to the subroutine to store the
value, or do whatever it thinks is appropriate.
d1422 1
a1422 1
=over
d1448 1
a1448 1
=over
d1460 9
d1489 9
d1516 5
a1520 3
For thread safety, each method call will acquire an exclusive lock to
the Getopt::Long module. So don't call these methods from a callback
routine!
d1690 1
a1690 1
=head2 Argument call-back
d1695 1
a1695 1
subroutine and passes it the argument as a parameter.
d1792 1
a1792 1
If an argument call-back routine is specified, C<@@ARGV> will always be
d1798 2
a1799 2
will call the call-back routine for arg1 and arg2, and terminate
GetOptions() leaving C<"arg2"> in C<@@ARGV>.
d1816 16
a1831 4
Enabling this option will allow single-character options to be bundled.
To distinguish bundles from long option names, long options I<must> be
introduced with C<--> and single-character options (and bundles) with
C<->.
d1847 7
a1853 2
If enabled, case is ignored when matching long option names. Single
character options will be treated case-sensitive.
d1994 31
d2031 1
a2031 1
This program is Copyright 2000,1990 by Johan Vromans.
a2048 3
# Local Variables:
# eval: (load-file "pod.el")
# End:
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pl,v 2.24 2000-03-14 21:28:52+01 jv Exp $
d9 2
a10 2
# Last Modified On: Tue Mar 14 21:28:40 2000
# Update Count    : 721
d15 1
a15 1
# This program is Copyright 1990,2000 by Johan Vromans.
d33 2
d37 10
d48 1
a48 6
    require 5.004;
    use Exporter ();
    use vars     qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS);
    $VERSION     = "2.23";

    @@ISA         = qw(Exporter);
a49 1
    %EXPORT_TAGS = qw();
a50 1
    use AutoLoader qw(AUTOLOAD);
d60 1
a60 1
use vars qw($genprefix $caller);
d97 21
d129 81
d218 1
a218 1
# RCS Status      : $Id: GetoptLongAl.pl,v 2.27 2000-03-17 09:07:26+01 jv Exp $
d222 2
a223 2
# Last Modified On: Fri Mar 17 09:00:09 2000
# Update Count    : 55
d247 1
a247 1
		  'GetOptionsAl $Revision: 2.27 $ ',
d254 1
d311 1
a311 1
	# Match option spec. Allow '?' as an alias.
d319 8
d329 3
a331 1
	    $opctl{$o = ''} = $c;
d336 1
a336 1
	    my $linko = $o = $o[0];
a374 1
	    $o = $linko;
d381 4
a384 3
		if ( exists $userlinkage->{$o} && ref($userlinkage->{$o}) ) {
		    print STDERR ("=> found userlinkage for \"$o\": ",
				  "$userlinkage->{$o}\n")
d386 1
a386 1
		    unshift (@@optionlist, $userlinkage->{$o});
d397 1
a397 1
	    print STDERR ("=> link \"$o\" to $optionlist[0]\n")
d400 1
a400 1
		$linkage{$o} = shift (@@optionlist);
d403 1
a403 1
		$linkage{$o} = shift (@@optionlist);
d411 1
a411 1
		$linkage{$o} = shift (@@optionlist);
d425 1
a425 1
	    my $ov = $o;
d428 1
a428 1
		print STDERR ("=> link \"$o\" to \@@$pkg","::opt_$ov\n")
d430 1
a430 1
		eval ("\$linkage{\$o} = \\\@@".$pkg."::opt_$ov;");
d433 1
a433 1
		print STDERR ("=> link \"$o\" to \%$pkg","::opt_$ov\n")
d435 1
a435 1
		eval ("\$linkage{\$o} = \\\%".$pkg."::opt_$ov;");
d438 1
a438 1
		print STDERR ("=> link \"$o\" to \$$pkg","::opt_$ov\n")
d440 1
a440 1
		eval ("\$linkage{\$o} = \\\$".$pkg."::opt_$ov;");
d503 5
a507 1
		$opt = $aliases{$opt} if defined $aliases{$opt};
d668 2
a669 1
    return (0) unless $opt =~ /^$prefix(.*)$/s;
d698 1
a698 1
	$rest = substr ($tryopt, 1);
d772 1
a772 1
    print STDERR ("=> found \"$type\" for ", $opt, "\n") if $debug;
d801 10
a810 1
    if ( defined $optarg ? ($optarg eq '')
d819 1
a819 4
	if ( $mand eq ":" ) {
	    $arg = $type eq "s" ? '' : 0;
	}
	return (1, $opt,$arg,$dsttype,$incr,$key);
d927 1
a927 1
	$passthrough, $genprefix ];
d932 1
a932 1
	  $passthrough, $genprefix ) = @@{shift(@@options)};
d943 7
a949 2
	if ( $try eq 'default' or $try eq 'defaults' ) {
	    ConfigDefaults () if $action;
d957 11
d989 1
a989 1
	elsif ( $try =~ /^prefix=(.+)$/ ) {
d996 1
a996 1
	elsif ( $try =~ /^prefix_pattern=(.+)$/ ) {
d1078 1
a1078 1
like 
d1091 1
a1091 1
the firs Perl module that provided support for handling the new style
d1314 1
a1314 1
and the argument specification. 
d1318 1
a1318 1
characters. 
d1391 18
d1531 1
a1531 1
would set C<a>, C<v> and C<x>, but 
d1564 7
a1570 2
Some applications require the option C<-> (that's a lone dash). This
can be achieved by adding an option specification with an empty name:
d1574 2
a1575 2
A lone dash on the command line will now be legal, and set options
variable C<$stdio>.
d1594 2
a1595 2
This will call 
C<process("arg1")> while C<$width> is C<80>, 
d1607 2
a1608 2
strings, each specifying a configuration option to be set, e.g.
C<ignore_case>, or reset, e.g. C<no_ignore_case>. Case does not
d1611 5
d1625 6
d1634 2
a1635 2
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is reset.
d1640 15
a1654 2
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case C<getopt_compat> is reset.
d1659 2
a1660 2
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case C<require_order> is reset.
d1667 2
a1668 2
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case C<permute> is reset.
d1671 1
a1671 1
If C<permute> is set, this means that 
d1688 1
a1688 1
If C<require_order> is set, options processing
d1697 5
a1701 1
=item bundling (default: reset)
d1703 1
a1703 1
Setting this option will allow single-character options to be bundled.
d1708 1
a1708 1
Note: resetting C<bundling> also resets C<bundling_override>.
d1710 1
a1710 1
=item bundling_override (default: reset)
d1712 2
a1713 2
If C<bundling_override> is set, bundling is enabled as with
C<bundling> but now long option names override option bundles. 
d1715 1
a1715 1
Note: resetting C<bundling_override> also resets C<bundling>.
d1720 1
a1720 1
=item ignore_case  (default: set)
d1722 1
a1722 1
If set, case is ignored when matching long option names. Single
d1725 1
a1725 1
Note: resetting C<ignore_case> also resets C<ignore_case_always>.
d1727 1
a1727 1
=item ignore_case_always (default: reset)
d1730 1
a1730 1
options also. 
d1732 1
a1732 1
Note: resetting C<ignore_case_always> also resets C<ignore_case>.
d1734 1
a1734 1
=item pass_through (default: reset)
d1742 3
a1744 1
This can be very confusing, especially when C<permute> is also set.
d1757 1
a1757 1
=item debug (default: reset)
d1759 1
a1759 1
Enable copious debugging output.
d1770 4
a1773 5
A return value of 1 (true) indicates success.

A return status of 0 (false) indicates that the function detected one
or more errors during option parsing. These errors are signalled using
warn() and can be trapped with C<$SIG{__WARN__}>.
d1829 3
a1831 3
GetOptions() will not interpret a leading C<"<>"> as option starters
if the next argument is a reference. To force C<"<"> and C<">"> as
option starters, use C<"><">. Confusing? Well, B<using a starter
d1837 26
a1862 3
configuring. Although manipulating these variables still work, it
is strongly encouraged to use the new C<config> routine. Besides, it
is much easier.
d1866 1
a1866 1
Johan Vromans E<lt>jvromans@@squirrel.nlE<gt>
d1883 1
a1883 1
the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, 
a1888 1
# mode: perl
@


1.3
log
@perl5.005_03 (stock)
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pl,v 2.18 1998-06-14 15:02:19+02 jv Exp $
d9 2
a10 2
# Last Modified On: Fri Jan  8 14:48:43 1999
# Update Count    : 707
d15 1
a15 1
# This program is Copyright 1990,1999 by Johan Vromans.
d17 5
a21 4
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
d26 1
a26 1
# 
d28 1
a28 1
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, 
d39 1
a39 1
    $VERSION     = "2.19";
d55 1
a55 1
use vars qw($genprefix);
d57 1
a57 1
# Public subroutines. 
d62 1
a62 1
# Private subroutines. 
d101 1
a101 2
# Set defaults.
ConfigDefaults ();
d111 1
a111 1
# RCS Status      : $Id: GetoptLongAl.pl,v 2.20 1998-06-14 15:02:19+02 jv Exp $
d115 2
a116 2
# Last Modified On: Sun Jun 14 13:54:35 1998
# Update Count    : 24
d125 1
a125 1
    my $pkg = (caller)[0];	# current context
d140 1
a140 1
		  'GetOptionsAl $Revision: 2.20 $ ',
d155 1
a155 1
    # Check for ref HASH as first argument. 
d157 1
a157 1
    # as it is really a hash underneath. 
d167 5
a171 1
    if ( $optionlist[0] =~ /^\W+$/ ) {
d194 1
a194 1
	    unless ( @@optionlist > 0 
d222 1
a222 1
		if $ignorecase > 1 
d232 4
a235 1
			$c = '';
a236 1
		    $opctl{$_} = $bopctl{$_} = $c;
d242 4
a245 1
			$c = '';
a246 1
		    $opctl{$_} = $c;
d289 1
a289 1
		  if $bundling and defined $bopctl{$o} and 
d297 1
a297 1
		  if $bundling and defined $bopctl{$o} and 
d350 2
a351 1
    while ( @@ARGV > 0 ) {
d363 1
a363 1
	    unshift (@@ARGV, @@ret) 
d371 1
a371 1
	my $incr;		# destination increment 
d375 2
a376 2
	($found, $opt, $arg, $dsttype, $incr, $key) = 
	  FindOption ($genprefix, $argend, $opt, 
d380 1
a380 1
	    
d421 14
a434 1
			&{$linkage{$opt}}($opt, $arg);
d491 14
a504 1
		&$cb ($tryopt);
d561 1
a561 1
	print STDERR ("=> option \"", $opt, 
d592 1
a592 1
    } 
d678 1
a678 1
    if ( defined $optarg ? ($optarg eq '') 
d700 1
a700 1
	($key, $arg) = ($arg =~ /^(.*)=(.*)$/s) ? ($1, $2) : ($arg, 1);
d706 1
a706 1
	# A mandatory string takes anything. 
d709 2
a710 2
	# An optional string takes almost anything. 
	return (1, $opt,$arg,$dsttype,$incr,$key) 
d725 1
a725 1
	if ( $bundling && defined $rest && $rest =~ /^(-?[0-9]+)(.*)$/s ) {
d730 1
a730 1
	elsif ( $arg !~ /^-?[0-9]+$/ ) {
d758 1
a758 1
	     $rest =~ /^(-?[0-9]+(\.[0-9]+)?([eE]-?[0-9]+)?)(.*)$/s ) {
d763 1
a763 1
	elsif ( $arg !~ /^-?[0-9.]+(\.[0-9]+)?([eE]-?[0-9]+)?$/ ) {
d794 12
d854 1
a854 1
	    $genprefix = "(" . $genprefix . ")" 
d866 1
d885 1
a885 1
GetOptions - extended processing of command line options
d900 185
a1084 2
but not enabled by default. For example, the UNIX "ps" command can be
given the command line "option"
d1086 3
a1088 1
  -vax
d1090 2
a1091 3
which means the combination of B<-v>, B<-a> and B<-x>. With the new
syntax B<--vax> would be a single option, probably indicating a
computer architecture. 
d1093 1
a1093 2
Command line options can be used to set values. These values can be
specified in one of two ways:
d1095 3
a1097 2
  --size 24
  --size=24
d1099 2
a1100 6
GetOptions is called with a list of option-descriptions, each of which
consists of two elements: the option specifier and the option linkage.
The option specifier defines the name of the option and, optionally,
the value it can take. The option linkage is usually a reference to a
variable that will be set when the option is used. For example, the
following call to GetOptions:
d1102 1
a1102 1
  GetOptions("size=i" => \$offset);
d1104 1
a1104 3
will accept a command line option "size" that must have an integer
value. With a command line of "--size 24" this will cause the variable
$offset to get the value 24.
d1106 4
a1109 4
Alternatively, the first argument to GetOptions may be a reference to
a HASH describing the linkage for the options, or an object whose
class is based on a HASH. The following call is equivalent to the
example above:
d1111 1
a1111 2
  %optctl = ("size" => \$offset);
  GetOptions(\%optctl, "size=i");
d1113 7
a1119 3
Linkage may be specified using either of the above methods, or both.
Linkage specified in the argument list takes precedence over the
linkage specified in the HASH.
d1121 2
a1122 6
The command line options are taken from array @@ARGV. Upon completion
of GetOptions, @@ARGV will contain the rest (i.e. the non-options) of
the command line.
 
Each option specifier designates the name of the option, optionally
followed by an argument specifier.
d1124 3
a1126 2
Options that do not take arguments will have no argument specifier. 
The option variable will be set to 1 if the option is used.
d1128 2
a1129 1
For the other options, the values for argument specifiers are:
d1131 54
a1184 1
=over 8
d1188 7
a1194 4
Option does not take an argument and may be negated, i.e. prefixed by
"no". E.g. "foo!" will allow B<--foo> (with value 1) and B<-nofoo>
(with value 0).
The option variable will be set to 1, or 0 if negated.
d1198 4
a1201 4
Option does not take an argument and will be incremented by 1 every
time it appears on the command line. E.g. "more+", when used with
B<--more --more --more>, will set the option variable to 3 (provided
it was 0 or undefined at first).
d1203 1
a1203 1
The B<+> specifier is ignored if the option destination is not a SCALAR.
d1205 1
a1205 1
=item =s
d1207 2
a1208 4
Option takes a mandatory string argument.
This string will be assigned to the option variable.
Note that even if the string argument starts with B<-> or B<-->, it
will not be considered an option on itself.
d1210 1
a1210 1
=item :s
d1212 1
a1212 5
Option takes an optional string argument.
This string will be assigned to the option variable.
If omitted, it will be assigned "" (an empty string).
If the string argument starts with B<-> or B<-->, it
will be considered an option on itself.
d1214 2
a1215 1
=item =i
d1217 1
a1217 4
Option takes a mandatory integer argument.
This value will be assigned to the option variable.
Note that the value may start with B<-> to indicate a negative
value. 
d1219 2
a1220 1
=item :i
d1222 1
a1222 5
Option takes an optional integer argument.
This value will be assigned to the option variable.
If omitted, the value 0 will be assigned.
Note that the value may start with B<-> to indicate a negative
value.
d1224 1
a1224 1
=item =f
d1226 1
a1226 4
Option takes a mandatory real number argument.
This value will be assigned to the option variable.
Note that the value may start with B<-> to indicate a negative
value.
d1228 10
a1237 1
=item :f
d1239 2
a1240 3
Option takes an optional real number argument.
This value will be assigned to the option variable.
If omitted, the value 0 will be assigned.
d1244 1
a1244 2
A lone dash B<-> is considered an option, the corresponding option
name is the empty string.
d1246 1
a1246 1
A double dash on itself B<--> signals end of the options list.
d1248 2
a1249 1
=head2 Linkage specification
d1251 2
a1252 3
The linkage specifier is optional. If no linkage is explicitly
specified but a ref HASH is passed, GetOptions will place the value in
the HASH. For example:
d1254 2
a1255 2
  %optctl = ();
  GetOptions (\%optctl, "size=i");
d1257 3
a1259 1
will perform the equivalent of the assignment
d1261 1
a1261 1
  $optctl{"size"} = 24;
d1263 1
a1263 1
For array options, a reference to an array is used, e.g.:
d1265 1
a1265 2
  %optctl = ();
  GetOptions (\%optctl, "sizes=i@@");
d1267 1
a1267 2
with command line "-sizes 24 -sizes 48" will perform the equivalent of
the assignment
d1269 1
a1269 1
  $optctl{"sizes"} = [24, 48];
d1271 3
a1273 2
For hash options (an option whose argument looks like "name=value"),
a reference to a hash is used, e.g.:
d1275 1
a1275 2
  %optctl = ();
  GetOptions (\%optctl, "define=s%");
d1277 1
a1277 2
with command line "--define foo=hello --define bar=world" will perform the
equivalent of the assignment
d1279 1
a1279 10
  $optctl{"define"} = {foo=>'hello', bar=>'world')

If no linkage is explicitly specified and no ref HASH is passed,
GetOptions will put the value in a global variable named after the
option, prefixed by "opt_". To yield a usable Perl variable,
characters that are not part of the syntax for variables are
translated to underscores. For example, "--fpp-struct-return" will set
the variable $opt_fpp_struct_return. Note that this variable resides
in the namespace of the calling program, not necessarily B<main>.
For example:
d1281 1
a1281 1
  GetOptions ("size=i", "sizes=i@@");
d1283 1
a1283 2
with command line "-size 10 -sizes 24 -sizes 48" will perform the
equivalent of the assignments
d1285 1
a1285 2
  $opt_size = 10;
  @@opt_sizes = (24, 48);
d1287 1
a1287 2
A lone dash B<-> is considered an option, the corresponding Perl
identifier is $opt_ .
d1289 1
a1289 2
The linkage specifier can be a reference to a scalar, a reference to
an array, a reference to a hash or a reference to a subroutine.
d1291 2
a1292 3
Note that, if your code is running under the recommended C<use strict
'vars'> pragma, it may be helpful to declare these package variables
via C<use vars> perhaps something like this:
d1294 1
a1294 1
  use vars qw/ $opt_size @@opt_sizes $opt_bar /;
d1296 1
a1296 3
If a REF SCALAR is supplied, the new value is stored in the referenced
variable. If the option occurs more than once, the previous value is
overwritten. 
d1298 1
a1298 2
If a REF ARRAY is supplied, the new value is appended (pushed) to the
referenced array. 
d1300 3
a1302 4
If a REF HASH is supplied, the option value should look like "key" or
"key=value" (if the "=value" is omitted then a value of 1 is implied).
In this case, the element of the referenced hash with the key "key"
is assigned "value". 
d1304 9
a1312 3
If a REF CODE is supplied, the referenced subroutine is called with
two arguments: the option name and the option value.
The option name is always the true name, not an abbreviation or alias.
d1314 2
a1315 1
=head2 Aliases and abbreviations
d1317 2
a1318 5
The option name may actually be a list of option names, separated by
"|"s, e.g. "foo|bar|blech=s". In this example, "foo" is the true name
of this option. If no linkage is specified, options "foo", "bar" and
"blech" all will set $opt_foo. For convenience, the single character
"?" is allowed as an alias, e.g. "help|?".
d1320 1
a1320 2
Option names may be abbreviated to uniqueness, depending on
configuration option B<auto_abbrev>.
d1322 2
a1323 1
=head2 Non-option call-back routine
d1325 3
a1327 6
A special option specifier, E<lt>E<gt>, can be used to designate a subroutine
to handle non-option arguments. GetOptions will immediately call this
subroutine for every non-option it encounters in the options list.
This subroutine gets the name of the non-option passed.
This feature requires configuration option B<permute>, see section
CONFIGURATION OPTIONS.
d1329 1
a1329 1
See also the examples.
d1331 2
a1332 1
=head2 Option starters
d1334 3
a1336 4
On the command line, options can start with B<-> (traditional), B<-->
(POSIX) and B<+> (GNU, now being phased out). The latter is not
allowed if the environment variable B<POSIXLY_CORRECT> has been
defined.
d1338 6
a1343 2
Options that start with "--" may have an argument appended, separated
with an "=", e.g. "--foo=bar".
d1345 1
a1345 1
=head2 Return values and Errors
d1347 2
a1348 4
Configuration errors and errors in the option definitions are
signalled using C<die()> and will terminate the calling
program unless the call to C<Getopt::Long::GetOptions()> was embedded
in C<eval { ... }> or C<die()> was trapped using C<$SIG{__DIE__}>.
d1350 1
a1350 1
A return value of 1 (true) indicates success.
d1352 1
a1352 3
A return status of 0 (false) indicates that the function detected one
or more errors during option parsing. These errors are signalled using
C<warn()> and can be trapped with C<$SIG{__WARN__}>.
d1354 2
a1355 1
Errors that can't happen are signalled using C<Carp::croak()>.
d1357 1
a1357 1
=head1 COMPATIBILITY
d1359 1
a1359 4
Getopt::Long::GetOptions() is the successor of
B<newgetopt.pl> that came with Perl 4. It is fully upward compatible.
In fact, the Perl 5 version of newgetopt.pl is just a wrapper around
the module.
d1361 4
a1364 4
If an "@@" sign is appended to the argument specifier, the option is
treated as an array. Value(s) are not set, but pushed into array
@@opt_name. If explicit linkage is supplied, this must be a reference
to an ARRAY.
d1366 1
a1366 5
If an "%" sign is appended to the argument specifier, the option is
treated as a hash. Value(s) of the form "name=value" are set by
setting the element of the hash %opt_name with key "name" to "value"
(if the "=value" portion is omitted it defaults to 1). If explicit
linkage is supplied, this must be a reference to a HASH.
d1368 1
a1368 4
If configuration option B<getopt_compat> is set (see section
CONFIGURATION OPTIONS), options that start with "+" or "-" may also
include their arguments, e.g. "+foo=bar". This is for compatiblity
with older implementations of the GNU "getopt" routine.
d1370 1
a1370 5
If the first argument to GetOptions is a string consisting of only
non-alphanumeric characters, it is taken to specify the option starter
characters. Everything starting with one of these characters from the
starter will be considered an option. B<Using a starter argument is
strongly deprecated.>
d1372 1
a1372 2
For convenience, option specifiers may have a leading B<-> or B<-->,
so it is possible to write:
d1374 2
a1375 1
   GetOptions qw(-foo=s --bar=i --ar=s);
d1377 1
a1377 1
=head1 EXAMPLES
d1379 1
a1379 2
If the option specifier is "one:i" (i.e. takes an optional integer
argument), then the following situations are handled:
d1381 2
a1382 2
   -one -two		-> $opt_one = '', -two is next option
   -one -2		-> $opt_one = -2
d1384 1
a1384 1
Also, assume specifiers "foo=s" and "bar:s" :
d1386 1
a1386 3
   -bar -xxx		-> $opt_bar = '', '-xxx' is next option
   -foo -bar		-> $opt_foo = '-bar'
   -foo --		-> $opt_foo = '--'
d1388 1
a1388 1
In GNU or POSIX format, option names and values can be combined:
d1390 4
a1393 3
   +foo=blech		-> $opt_foo = 'blech'
   --bar=		-> $opt_bar = ''
   --bar=--		-> $opt_bar = '--'
d1395 1
a1395 1
Example of using variable references:
d1397 1
a1397 1
   $ret = GetOptions ('foo=s', \$foo, 'bar=i', 'ar=s', \@@ar);
d1399 1
a1399 2
With command line options "-foo blech -bar 24 -ar xx -ar yy" 
this will result in:
d1401 2
a1402 3
   $foo = 'blech'
   $opt_bar = 24
   @@ar = ('xx','yy')
d1404 1
a1404 1
Example of using the E<lt>E<gt> option specifier:
d1406 2
a1407 2
   @@ARGV = qw(-foo 1 bar -foo 2 blech);
   GetOptions("foo=i", \$myfoo, "<>", \&mysub);
d1409 1
a1409 1
Results:
d1411 4
a1414 2
   mysub("bar") will be called (with $myfoo being 1)
   mysub("blech") will be called (with $myfoo being 2)
d1416 1
a1416 1
Compare this with:
d1418 12
a1429 2
   @@ARGV = qw(-foo 1 bar -foo 2 blech);
   GetOptions("foo=i", \$myfoo);
d1431 2
a1432 1
This will leave the non-options in @@ARGV:
a1433 2
   $myfoo -> 2
   @@ARGV -> qw(bar blech)
d1435 1
a1435 1
=head1 CONFIGURATION OPTIONS
d1437 2
a1438 2
B<GetOptions> can be configured by calling subroutine
B<Getopt::Long::Configure>. This subroutine takes a list of quoted
d1440 2
a1441 8
B<ignore_case>. Options can be reset by prefixing with B<no_>, e.g.
B<no_ignore_case>. Case does not matter. Multiple calls to B<config>
are possible.

Previous versions of Getopt::Long used variables for the purpose of
configuring. Although manipulating these variables still work, it
is strongly encouraged to use the new B<config> routine. Besides, it
is much easier.
d1456 1
a1456 1
POSIXLY_CORRECT has been set, in which case B<auto_abbrev> is reset.
d1458 1
a1458 1
=item getopt_compat   
d1460 1
a1460 1
Allow '+' to start options.
d1462 1
a1462 1
POSIXLY_CORRECT has been set, in which case B<getopt_compat> is reset.
d1466 1
a1466 2
Whether non-options are allowed to be mixed with
options.
d1468 1
a1468 1
POSIXLY_CORRECT has been set, in which case b<require_order> is reset.
d1470 1
a1470 1
See also B<permute>, which is the opposite of B<require_order>.
d1474 1
a1474 2
Whether non-options are allowed to be mixed with
options.
d1476 2
a1477 2
POSIXLY_CORRECT has been set, in which case B<permute> is reset.
Note that B<permute> is the opposite of B<require_order>.
d1479 1
a1479 1
If B<permute> is set, this means that 
d1481 1
a1481 1
    -foo arg1 -bar arg2 arg3
d1485 1
a1485 1
    -foo -bar arg1 arg2 arg3
d1487 3
a1489 3
If a non-option call-back routine is specified, @@ARGV will always be
empty upon succesful return of GetOptions since all options have been
processed, except when B<--> is used:
d1491 1
a1491 1
    -foo arg1 -bar arg2 -- arg3
d1494 1
a1494 1
leaving arg2 in @@ARGV.
d1496 1
a1496 1
If B<require_order> is set, options processing
d1499 1
a1499 1
    -foo arg1 -bar arg2 arg3
d1503 1
a1503 1
    -foo -- arg1 -bar arg2 arg3
d1507 4
a1510 10
Setting this variable to a non-zero value will allow single-character
options to be bundled. To distinguish bundles from long option names,
long options must be introduced with B<--> and single-character
options (and bundles) with B<->. For example,

    ps -vax --vax

would be equivalent to

    ps -v -a -x --vax
d1512 1
a1512 14
provided "vax", "v", "a" and "x" have been defined to be valid
options. 

Bundled options can also include a value in the bundle; for strings
this value is the rest of the bundle, but integer and floating values
may be combined in the bundle, e.g.

    scale -h24w80

is equivalent to

    scale -h 24 -w 80

Note: resetting B<bundling> also resets B<bundling_override>.
d1516 2
a1517 4
If B<bundling_override> is set, bundling is enabled as with
B<bundling> but now long option names override option bundles. In the
above example, B<-vax> would be interpreted as the option "vax", not
the bundle "v", "a", "x".
d1519 1
a1519 1
Note: resetting B<bundling_override> also resets B<bundling>.
d1526 2
a1527 1
If set, case is ignored when matching options.
d1529 1
a1529 1
Note: resetting B<ignore_case> also resets B<ignore_case_always>.
d1536 1
a1536 1
Note: resetting B<ignore_case_always> also resets B<ignore_case>.
d1540 4
a1543 3
Unknown options are passed through in @@ARGV instead of being flagged
as errors. This makes it possible to write wrapper scripts that
process only part of the user supplied options, and passes the
d1546 1
a1546 1
This can be very confusing, especially when B<permute> is also set.
d1550 2
a1551 1
The string that starts options. See also B<prefix_pattern>.
d1565 8
a1572 1
=head1 OTHER USEFUL VARIABLES
d1574 47
a1620 1
=over 12
d1622 2
a1623 1
=item $Getopt::Long::VERSION
d1625 1
a1625 3
The version number of this Getopt::Long implementation in the format
C<major>.C<minor>. This can be used to have Exporter check the
version, e.g.
d1627 1
a1627 1
    use Getopt::Long 3.00;
d1629 2
a1630 2
You can inspect $Getopt::Long::major_version and
$Getopt::Long::minor_version for the individual components.
d1632 4
a1635 1
=item $Getopt::Long::error
d1637 1
a1637 2
Internal error flag. May be incremented from a call-back routine to
cause options parsing to fail.
d1639 4
a1642 1
=back
d1650 1
a1650 1
This program is Copyright 1990,1999 by Johan Vromans.
d1652 4
a1655 3
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.
d1667 5
@


1.2
log
@perl 5.004_04
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pm,v 2.11 1997-09-17 12:23:51+02 jv Exp $
d9 2
a10 2
# Last Modified On: Wed Sep 17 12:20:10 1997
# Update Count    : 608
d13 1
a13 1
=head1 NAME
d15 14
a28 1
GetOptions - extended processing of command line options
d30 1
a30 1
=head1 SYNOPSIS
d32 1
a32 2
  use Getopt::Long;
  $result = GetOptions (...option-descriptions...);
d34 5
a38 1
=head1 DESCRIPTION
d40 6
a45 8
The Getopt::Long module implements an extended getopt function called
GetOptions(). This function adheres to the POSIX syntax for command
line options, with GNU extensions. In general, this means that options
have long names instead of single letters, and are introduced with a
double dash "--". Support for bundling of command line options, as was
the case with the more traditional single-letter approach, is provided
but not enabled by default. For example, the UNIX "ps" command can be
given the command line "option"
d47 8
a54 1
  -vax
d56 9
a64 3
which means the combination of B<-v>, B<-a> and B<-x>. With the new
syntax B<--vax> would be a single option, probably indicating a
computer architecture. 
d66 1
a66 2
Command line options can be used to set values. These values can be
specified in one of two ways:
d68 1
a68 2
  --size 24
  --size=24
d70 22
a91 6
GetOptions is called with a list of option-descriptions, each of which
consists of two elements: the option specifier and the option linkage.
The option specifier defines the name of the option and, optionally,
the value it can take. The option linkage is usually a reference to a
variable that will be set when the option is used. For example, the
following call to GetOptions:
d93 1
a93 1
  GetOptions("size=i" => \$offset);
d95 4
a98 3
will accept a command line option "size" that must have an integer
value. With a command line of "--size 24" this will cause the variable
$offset to get the value 24.
d100 2
a101 4
Alternatively, the first argument to GetOptions may be a reference to
a HASH describing the linkage for the options, or an object whose
class is based on a HASH. The following call is equivalent to the
example above:
d103 1
a103 2
  %optctl = ("size" => \$offset);
  GetOptions(\%optctl, "size=i");
d105 1
a105 3
Linkage may be specified using either of the above methods, or both.
Linkage specified in the argument list takes precedence over the
linkage specified in the HASH.
d107 1
a107 6
The command line options are taken from array @@ARGV. Upon completion
of GetOptions, @@ARGV will contain the rest (i.e. the non-options) of
the command line.
 
Each option specifier designates the name of the option, optionally
followed by an argument specifier. Values for argument specifiers are:
d109 1
a109 1
=over 8
d111 7
a117 1
=item E<lt>noneE<gt>
d119 1
a119 2
Option does not take an argument. 
The option variable will be set to 1.
d121 33
a153 1
=item !
d155 9
a163 4
Option does not take an argument and may be negated, i.e. prefixed by
"no". E.g. "foo!" will allow B<--foo> (with value 1) and B<-nofoo>
(with value 0).
The option variable will be set to 1, or 0 if negated.
d165 8
a172 1
=item =s
d174 5
a178 4
Option takes a mandatory string argument.
This string will be assigned to the option variable.
Note that even if the string argument starts with B<-> or B<-->, it
will not be considered an option on itself.
d180 2
a181 1
=item :s
d183 15
a197 5
Option takes an optional string argument.
This string will be assigned to the option variable.
If omitted, it will be assigned "" (an empty string).
If the string argument starts with B<-> or B<-->, it
will be considered an option on itself.
d199 7
a205 1
=item =i
d207 14
a220 4
Option takes a mandatory integer argument.
This value will be assigned to the option variable.
Note that the value may start with B<-> to indicate a negative
value. 
d222 29
a250 1
=item :i
d252 16
a267 5
Option takes an optional integer argument.
This value will be assigned to the option variable.
If omitted, the value 0 will be assigned.
Note that the value may start with B<-> to indicate a negative
value.
d269 49
a317 1
=item =f
d319 3
a321 4
Option takes a mandatory real number argument.
This value will be assigned to the option variable.
Note that the value may start with B<-> to indicate a negative
value.
d323 2
a324 1
=item :f
d326 14
a339 3
Option takes an optional real number argument.
This value will be assigned to the option variable.
If omitted, the value 0 will be assigned.
d341 2
a342 1
=back
d344 1
a344 2
A lone dash B<-> is considered an option, the corresponding option
name is the empty string.
d346 2
a347 1
A double dash on itself B<--> signals end of the options list.
d349 1
a349 1
=head2 Linkage specification
d351 7
a357 3
The linkage specifier is optional. If no linkage is explicitly
specified but a ref HASH is passed, GetOptions will place the value in
the HASH. For example:
d359 10
a368 2
  %optctl = ();
  GetOptions (\%optctl, "size=i");
d370 4
a373 1
will perform the equivalent of the assignment
d375 2
a376 1
  $optctl{"size"} = 24;
d378 3
a380 1
For array options, a reference to an array is used, e.g.:
d382 81
a462 2
  %optctl = ();
  GetOptions (\%optctl, "sizes=i@@");
d464 14
a477 2
with command line "-sizes 24 -sizes 48" will perform the equivalent of
the assignment
d479 6
a484 1
  $optctl{"sizes"} = [24, 48];
d486 1
a486 2
For hash options (an option whose argument looks like "name=value"),
a reference to a hash is used, e.g.:
d488 7
a494 2
  %optctl = ();
  GetOptions (\%optctl, "define=s%");
d496 2
a497 2
with command line "--define foo=hello --define bar=world" will perform the
equivalent of the assignment
d499 2
a500 1
  $optctl{"define"} = {foo=>'hello', bar=>'world')
d502 2
a503 8
If no linkage is explicitly specified and no ref HASH is passed,
GetOptions will put the value in a global variable named after the
option, prefixed by "opt_". To yield a usable Perl variable,
characters that are not part of the syntax for variables are
translated to underscores. For example, "--fpp-struct-return" will set
the variable $opt_fpp_struct_return. Note that this variable resides
in the namespace of the calling program, not necessarily B<main>.
For example:
d505 3
a507 1
  GetOptions ("size=i", "sizes=i@@");
d509 1
a509 2
with command line "-size 10 -sizes 24 -sizes 48" will perform the
equivalent of the assignments
d511 1
a511 2
  $opt_size = 10;
  @@opt_sizes = (24, 48);
d513 2
a514 2
A lone dash B<-> is considered an option, the corresponding Perl
identifier is $opt_ .
d516 1
a516 2
The linkage specifier can be a reference to a scalar, a reference to
an array, a reference to a hash or a reference to a subroutine.
d518 2
a519 3
If a REF SCALAR is supplied, the new value is stored in the referenced
variable. If the option occurs more than once, the previous value is
overwritten. 
d521 8
a528 2
If a REF ARRAY is supplied, the new value is appended (pushed) to the
referenced array. 
d530 1
a530 4
If a REF HASH is supplied, the option value should look like "key" or
"key=value" (if the "=value" is omitted then a value of 1 is implied).
In this case, the element of the referenced hash with the key "key"
is assigned "value". 
d532 5
a536 3
If a REF CODE is supplied, the referenced subroutine is called with
two arguments: the option name and the option value.
The option name is always the true name, not an abbreviation or alias.
d538 9
a546 1
=head2 Aliases and abbreviations
d548 10
a557 4
The option name may actually be a list of option names, separated by
"|"s, e.g. "foo|bar|blech=s". In this example, "foo" is the true name
of this option. If no linkage is specified, options "foo", "bar" and
"blech" all will set $opt_foo.
d559 10
a568 2
Option names may be abbreviated to uniqueness, depending on
configuration option B<auto_abbrev>.
d570 19
a588 1
=head2 Non-option call-back routine
d590 8
a597 6
A special option specifier, E<lt>E<gt>, can be used to designate a subroutine
to handle non-option arguments. GetOptions will immediately call this
subroutine for every non-option it encounters in the options list.
This subroutine gets the name of the non-option passed.
This feature requires configuration option B<permute>, see section
CONFIGURATION OPTIONS.
d599 4
a602 1
See also the examples.
d604 11
a614 1
=head2 Option starters
d616 1
a616 4
On the command line, options can start with B<-> (traditional), B<-->
(POSIX) and B<+> (GNU, now being phased out). The latter is not
allowed if the environment variable B<POSIXLY_CORRECT> has been
defined.
d618 19
a636 2
Options that start with "--" may have an argument appended, separated
with an "=", e.g. "--foo=bar".
d638 3
a640 1
=head2 Return value
d642 15
a656 2
A return status of 0 (false) indicates that the function detected
one or more errors.
d658 3
a660 1
=head1 COMPATIBILITY
d662 5
a666 4
Getopt::Long::GetOptions() is the successor of
B<newgetopt.pl> that came with Perl 4. It is fully upward compatible.
In fact, the Perl 5 version of newgetopt.pl is just a wrapper around
the module.
d668 1
a668 4
If an "@@" sign is appended to the argument specifier, the option is
treated as an array. Value(s) are not set, but pushed into array
@@opt_name. If explicit linkage is supplied, this must be a reference
to an ARRAY.
d670 3
a672 5
If an "%" sign is appended to the argument specifier, the option is
treated as a hash. Value(s) of the form "name=value" are set by
setting the element of the hash %opt_name with key "name" to "value"
(if the "=value" portion is omitted it defaults to 1). If explicit
linkage is supplied, this must be a reference to a HASH.
d674 4
a677 4
If configuration option B<getopt_compat> is set (see section
CONFIGURATION OPTIONS), options that start with "+" or "-" may also
include their arguments, e.g. "+foo=bar". This is for compatiblity
with older implementations of the GNU "getopt" routine.
d679 9
a687 5
If the first argument to GetOptions is a string consisting of only
non-alphanumeric characters, it is taken to specify the option starter
characters. Everything starting with one of these characters from the
starter will be considered an option. B<Using a starter argument is
strongly deprecated.>
d689 28
a716 2
For convenience, option specifiers may have a leading B<-> or B<-->,
so it is possible to write:
d718 37
a754 1
   GetOptions qw(-foo=s --bar=i --ar=s);
d756 64
a819 1
=head1 EXAMPLES
d821 4
a824 2
If the option specifier is "one:i" (i.e. takes an optional integer
argument), then the following situations are handled:
d826 6
a831 2
   -one -two		-> $opt_one = '', -two is next option
   -one -2		-> $opt_one = -2
d833 1
a833 1
Also, assume specifiers "foo=s" and "bar:s" :
d835 1
a835 3
   -bar -xxx		-> $opt_bar = '', '-xxx' is next option
   -foo -bar		-> $opt_foo = '-bar'
   -foo --		-> $opt_foo = '--'
d837 1
a837 1
In GNU or POSIX format, option names and values can be combined:
d839 1
a839 3
   +foo=blech		-> $opt_foo = 'blech'
   --bar=		-> $opt_bar = ''
   --bar=--		-> $opt_bar = '--'
d841 2
a842 1
Example of using variable references:
d844 1
a844 1
   $ret = GetOptions ('foo=s', \$foo, 'bar=i', 'ar=s', \@@ar);
d846 8
a853 2
With command line options "-foo blech -bar 24 -ar xx -ar yy" 
this will result in:
d855 1
a855 3
   $foo = 'blech'
   $opt_bar = 24
   @@ar = ('xx','yy')
d857 3
a859 1
Example of using the E<lt>E<gt> option specifier:
d861 2
a862 2
   @@ARGV = qw(-foo 1 bar -foo 2 blech);
   GetOptions("foo=i", \$myfoo, "<>", \&mysub);
d864 2
a865 1
Results:
d867 6
a872 2
   mysub("bar") will be called (with $myfoo being 1)
   mysub("blech") will be called (with $myfoo being 2)
d874 1
a874 1
Compare this with:
d876 3
a878 2
   @@ARGV = qw(-foo 1 bar -foo 2 blech);
   GetOptions("foo=i", \$myfoo);
d880 4
a883 1
This will leave the non-options in @@ARGV:
d885 2
a886 2
   $myfoo -> 2
   @@ARGV -> qw(bar blech)
d888 3
a890 1
=head1 CONFIGURATION OPTIONS
d892 6
a897 6
B<GetOptions> can be configured by calling subroutine
B<Getopt::Long::config>. This subroutine takes a list of quoted
strings, each specifying a configuration option to be set, e.g.
B<ignore_case>. Options can be reset by prefixing with B<no_>, e.g.
B<no_ignore_case>. Case does not matter. Multiple calls to B<config>
are possible.
d899 2
a900 4
Previous versions of Getopt::Long used variables for the purpose of
configuring. Although manipulating these variables still work, it
is strongly encouraged to use the new B<config> routine. Besides, it
is much easier.
d902 1
a902 1
The following options are available:
d904 1
a904 1
=over 12
d906 1
a906 1
=item default
d908 4
a911 2
This option causes all configuration options to be reset to their
default values.
d913 1
a913 1
=item auto_abbrev
d915 4
a918 3
Allow option names to be abbreviated to uniqueness.
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case B<auto_abbrev> is reset.
d920 1
a920 1
=item getopt_compat   
d922 1
a922 3
Allow '+' to start options.
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case B<getopt_compat> is reset.
d924 4
a927 1
=item require_order
d929 1
a929 4
Whether non-options are allowed to be mixed with
options.
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case b<require_order> is reset.
d931 5
a935 1
See also B<permute>, which is the opposite of B<require_order>.
d937 1
a937 1
=item permute
d939 4
a942 5
Whether non-options are allowed to be mixed with
options.
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case B<permute> is reset.
Note that B<permute> is the opposite of B<require_order>.
d944 1
a944 1
If B<permute> is set, this means that 
d946 5
a950 1
    -foo arg1 -bar arg2 arg3
d952 1
a952 1
is equivalent to
d954 4
a957 1
    -foo -bar arg1 arg2 arg3
d959 1
a959 3
If a non-option call-back routine is specified, @@ARGV will always be
empty upon succesful return of GetOptions since all options have been
processed, except when B<--> is used:
d961 3
a963 1
    -foo arg1 -bar arg2 -- arg3
d965 1
a965 2
will call the call-back routine for arg1 and arg2, and terminate
leaving arg2 in @@ARGV.
d967 2
a968 2
If B<require_order> is set, options processing
terminates when the first non-option is encountered.
d970 1
a970 1
    -foo arg1 -bar arg2 arg3
d972 1
a972 1
is equivalent to
d974 3
a976 1
    -foo -- arg1 -bar arg2 arg3
d978 2
a979 1
=item bundling (default: reset)
d981 1
a981 4
Setting this variable to a non-zero value will allow single-character
options to be bundled. To distinguish bundles from long option names,
long options must be introduced with B<--> and single-character
options (and bundles) with B<->. For example,
d983 1
a983 1
    ps -vax --vax
d985 1
a985 1
would be equivalent to
d987 2
a988 1
    ps -v -a -x --vax
d990 2
a991 2
provided "vax", "v", "a" and "x" have been defined to be valid
options. 
d993 1
a993 2
Bundled options can also include a value in the bundle; this value has
to be the last part of the bundle, e.g.
d995 2
a996 1
    scale -h24 -w80
d998 2
a999 1
is equivalent to
d1001 2
a1002 1
    scale -h 24 -w 80
d1004 1
a1004 1
Note: resetting B<bundling> also resets B<bundling_override>.
d1006 8
a1013 1
=item bundling_override (default: reset)
d1015 1
a1015 4
If B<bundling_override> is set, bundling is enabled as with
B<bundling> but now long option names override option bundles. In the
above example, B<-vax> would be interpreted as the option "vax", not
the bundle "v", "a", "x".
d1017 2
a1018 1
Note: resetting B<bundling_override> also resets B<bundling>.
d1020 2
a1021 2
B<Note:> Using option bundling can easily lead to unexpected results,
especially when mixing long options and bundles. Caveat emptor.
d1023 2
a1024 1
=item ignore_case  (default: set)
d1026 2
a1027 1
If set, case is ignored when matching options.
d1029 3
a1031 1
Note: resetting B<ignore_case> also resets B<ignore_case_always>.
d1033 1
a1033 1
=item ignore_case_always (default: reset)
d1035 3
a1037 2
When bundling is in effect, case is ignored on single-character
options also. 
d1039 2
a1040 1
Note: resetting B<ignore_case_always> also resets B<ignore_case>.
d1042 4
a1045 1
=item pass_through (default: reset)
d1047 3
a1049 4
Unknown options are passed through in @@ARGV instead of being flagged
as errors. This makes it possible to write wrapper scripts that
process only part of the user supplied options, and passes the
remaining options to some other program.
d1051 1
a1051 1
This can be very confusing, especially when B<permute> is also set.
d1053 5
a1057 1
=item debug (default: reset)
d1059 2
a1060 1
Enable copious debugging output.
d1062 1
a1062 1
=back
d1064 6
a1069 1
=head1 OTHER USEFUL VARIABLES
d1071 1
a1071 1
=over 12
d1073 1
a1073 1
=item $Getopt::Long::VERSION
d1075 4
a1078 3
The version number of this Getopt::Long implementation in the format
C<major>.C<minor>. This can be used to have Exporter check the
version, e.g.
d1080 2
a1081 1
    use Getopt::Long 3.00;
d1083 1
a1083 2
You can inspect $Getopt::Long::major_version and
$Getopt::Long::minor_version for the individual components.
d1085 4
a1088 1
=item $Getopt::Long::error
d1090 1
a1090 2
Internal error flag. May be incremented from a call-back routine to
cause options parsing to fail.
d1092 3
a1094 1
=back
d1096 1
a1096 1
=cut
d1098 1
a1098 1
################ Copyright ################
d1100 4
a1103 14
# This program is Copyright 1990,1997 by Johan Vromans.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# If you do not have a copy of the GNU General Public License write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, 
# MA 02139, USA.
d1105 74
a1178 1
################ Module Preamble ################
d1180 2
a1181 1
use strict;
d1183 1
a1183 5
BEGIN {
    require 5.003;
    use Exporter ();
    use vars   qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS);
    $VERSION   = sprintf("%d.%02d", q$Revision: 2.11 $ =~ /(\d+)\.(\d+)/);
d1185 6
a1190 5
    @@ISA       = qw(Exporter);
    @@EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
    %EXPORT_TAGS = ();
    @@EXPORT_OK = qw();
}
d1192 4
a1195 6
use vars @@EXPORT, @@EXPORT_OK;
# User visible variables.
use vars qw($error $debug $major_version $minor_version);
# Deprecated visible variables.
use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
	    $passthrough);
d1197 1
a1197 1
################ Local Variables ################
d1199 1
a1199 16
my $gen_prefix;			# generic prefix (option starters)
my $argend;			# option list terminator
my %opctl;			# table of arg.specs (long and abbrevs)
my %bopctl;			# table of arg.specs (bundles)
my @@opctl;			# the possible long option names
my $pkg;			# current context. Needed if no linkage.
my %aliases;			# alias table
my $genprefix;			# so we can call the same module more 
my $opt;			# current option
my $arg;			# current option value, if any
my $array;			# current option is array typed
my $hash;			# current option is hash typed
my $key;			# hash key for a hash option
				# than once in differing environments
my $config_defaults;		# set config defaults
my $find_option;		# helper routine
d1201 1
a1201 1
################ Subroutines ################
d1203 2
a1204 1
sub GetOptions {
d1206 1
a1206 12
    my @@optionlist = @@_;	# local copy of the option descriptions
    $argend = '--';		# option list terminator
    %opctl = ();		# table of arg.specs (long and abbrevs)
    %bopctl = ();		# table of arg.specs (bundles)
    $pkg = (caller)[0];		# current context
				# Needed if linkage is omitted.
    %aliases= ();		# alias table
    my @@ret = ();		# accum for non-options
    my %linkage;		# linkage
    my $userlinkage;		# user supplied HASH
    $genprefix = $gen_prefix;	# so we can call the same module many times
    $error = 0;
d1208 3
a1210 13
    print STDERR ('GetOptions $Revision: 2.11 $ ',
		  "[GetOpt::Long $Getopt::Long::VERSION] -- ",
		  "called from package \"$pkg\".\n",
		  "  (@@ARGV)\n",
		  "  autoabbrev=$autoabbrev".
		  ",bundling=$bundling",
		  ",getopt_compat=$getopt_compat",
		  ",order=$order",
		  ",\n  ignorecase=$ignorecase",
		  ",passthrough=$passthrough",
		  ",genprefix=\"$genprefix\"",
		  ".\n")
	if $debug;
d1212 1
a1212 9
    # Check for ref HASH as first argument. 
    # First argument may be an object. It's OK to use this as long
    # as it is really a hash underneath. 
    $userlinkage = undef;
    if ( ref($optionlist[0]) and
	 "$optionlist[0]" =~ /^(?:.*\=)?HASH\([^\(]*\)$/ ) {
	$userlinkage = shift (@@optionlist);
	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
    }
d1214 3
a1216 8
    # See if the first element of the optionlist contains option
    # starter characters.
    if ( $optionlist[0] =~ /^\W+$/ ) {
	$genprefix = shift (@@optionlist);
	# Turn into regexp.
	$genprefix =~ s/(\W)/\\$1/g;
	$genprefix = "[" . $genprefix . "]";
    }
d1218 1
a1218 5
    # Verify correctness of optionlist.
    %opctl = ();
    %bopctl = ();
    while ( @@optionlist > 0 ) {
	my $opt = shift (@@optionlist);
d1220 4
a1223 2
	# Strip leading prefix so people can specify "--foo=i" if they like.
	$opt = $' if $opt =~ /^($genprefix)+/;
d1225 1
a1225 16
	if ( $opt eq '<>' ) {
	    if ( (defined $userlinkage)
		&& !(@@optionlist > 0 && ref($optionlist[0]))
		&& (exists $userlinkage->{$opt})
		&& ref($userlinkage->{$opt}) ) {
		unshift (@@optionlist, $userlinkage->{$opt});
	    }
	    unless ( @@optionlist > 0 
		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
		warn ("Option spec <> requires a reference to a subroutine\n");
		$error++;
		next;
	    }
	    $linkage{'<>'} = shift (@@optionlist);
	    next;
	}
d1227 1
a1227 7
	if ( $opt !~ /^(\w+[-\w|]*)?(!|[=:][infse][@@%]?)?$/ ) {
	    warn ("Error in option spec: \"", $opt, "\"\n");
	    $error++;
	    next;
	}
	my ($o, $c, $a) = ($1, $2);
	$c = '' unless defined $c;
d1229 5
a1233 14
	if ( ! defined $o ) {
	    # empty -> '-' option
	    $opctl{$o = ''} = $c;
	}
	else {
	    # Handle alias names
	    my @@o =  split (/\|/, $o);
	    my $linko = $o = $o[0];
	    # Force an alias if the option name is not locase.
	    $a = $o unless $o eq lc($o);
	    $o = lc ($o)
		if $ignorecase > 1 
		    || ($ignorecase
			&& ($bundling ? length($o) > 1  : 1));
d1235 1
a1235 29
	    foreach ( @@o ) {
		if ( $bundling && length($_) == 1 ) {
		    $_ = lc ($_) if $ignorecase > 1;
		    if ( $c eq '!' ) {
			$opctl{"no$_"} = $c;
			warn ("Ignoring '!' modifier for short option $_\n");
			$c = '';
		    }
		    $opctl{$_} = $bopctl{$_} = $c;
		}
		else {
		    $_ = lc ($_) if $ignorecase;
		    if ( $c eq '!' ) {
			$opctl{"no$_"} = $c;
			$c = '';
		    }
		    $opctl{$_} = $c;
		}
		if ( defined $a ) {
		    # Note alias.
		    $aliases{$_} = $a;
		}
		else {
		    # Set primary name.
		    $a = $_;
		}
	    }
	    $o = $linko;
	}
d1237 1
a1237 16
	# If no linkage is supplied in the @@optionlist, copy it from
	# the userlinkage if available.
	if ( defined $userlinkage ) {
	    unless ( @@optionlist > 0 && ref($optionlist[0]) ) {
		if ( exists $userlinkage->{$o} && ref($userlinkage->{$o}) ) {
		    print STDERR ("=> found userlinkage for \"$o\": ",
				  "$userlinkage->{$o}\n")
			if $debug;
		    unshift (@@optionlist, $userlinkage->{$o});
		}
		else {
		    # Do nothing. Being undefined will be handled later.
		    next;
		}
	    }
	}
d1239 1
a1239 48
	# Copy the linkage. If omitted, link to global variable.
	if ( @@optionlist > 0 && ref($optionlist[0]) ) {
	    print STDERR ("=> link \"$o\" to $optionlist[0]\n")
		if $debug;
	    if ( ref($optionlist[0]) =~ /^(SCALAR|CODE)$/ ) {
		$linkage{$o} = shift (@@optionlist);
	    }
	    elsif ( ref($optionlist[0]) =~ /^(ARRAY)$/ ) {
		$linkage{$o} = shift (@@optionlist);
		$opctl{$o} .= '@@'
		  if $opctl{$o} ne '' and $opctl{$o} !~ /\@@$/;
		$bopctl{$o} .= '@@'
		  if $bundling and $bopctl{$o} ne '' and $bopctl{$o} !~ /\@@$/;
	    }
	    elsif ( ref($optionlist[0]) =~ /^(HASH)$/ ) {
		$linkage{$o} = shift (@@optionlist);
		$opctl{$o} .= '%'
		  if $opctl{$o} ne '' and $opctl{$o} !~ /\%$/;
		$bopctl{$o} .= '%'
		  if $bundling and $bopctl{$o} ne '' and $bopctl{$o} !~ /\%$/;
	    }
	    else {
		warn ("Invalid option linkage for \"", $opt, "\"\n");
		$error++;
	    }
	}
	else {
	    # Link to global $opt_XXX variable.
	    # Make sure a valid perl identifier results.
	    my $ov = $o;
	    $ov =~ s/\W/_/g;
	    if ( $c =~ /@@/ ) {
		print STDERR ("=> link \"$o\" to \@@$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$o} = \\\@@".$pkg."::opt_$ov;");
	    }
	    elsif ( $c =~ /%/ ) {
		print STDERR ("=> link \"$o\" to \%$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$o} = \\\%".$pkg."::opt_$ov;");
	    }
	    else {
		print STDERR ("=> link \"$o\" to \$$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$o} = \\\$".$pkg."::opt_$ov;");
	    }
	}
    }
d1241 1
a1241 2
    # Bail out if errors found.
    return 0 if $error;
d1243 3
a1245 2
    # Sort the possible long option names.
    @@opctl = sort(keys (%opctl)) if $autoabbrev;
d1247 1
a1247 14
    # Show the options tables if debugging.
    if ( $debug ) {
	my ($arrow, $k, $v);
	$arrow = "=> ";
	while ( ($k,$v) = each(%opctl) ) {
	    print STDERR ($arrow, "\$opctl{\"$k\"} = \"$v\"\n");
	    $arrow = "   ";
	}
	$arrow = "=> ";
	while ( ($k,$v) = each(%bopctl) ) {
	    print STDERR ($arrow, "\$bopctl{\"$k\"} = \"$v\"\n");
	    $arrow = "   ";
	}
    }
d1249 2
a1250 2
    # Process argument list
    while ( @@ARGV > 0 ) {
d1252 2
a1253 1
	#### Get next argument ####
d1255 1
a1255 4
	$opt = shift (@@ARGV);
	$arg = undef;
	$array = $hash = 0;
	print STDERR ("=> option \"", $opt, "\"\n") if $debug;
d1257 1
a1257 1
	#### Determine what we have ####
d1259 1
a1259 7
	# Double dash is option list terminator.
	if ( $opt eq $argend ) {
	    # Finish. Push back accumulated arguments and return.
	    unshift (@@ARGV, @@ret) 
		if $order == $PERMUTE;
	    return ($error == 0);
	}
d1261 1
a1261 1
	my $tryopt = $opt;
d1263 4
a1266 5
	# find_option operates on the GLOBAL $opt and $arg!
	if ( &$find_option () ) {
	    
	    # find_option undefines $opt in case of errors.
	    next unless defined $opt;
d1268 1
a1268 2
	    if ( defined $arg ) {
		$opt = $aliases{$opt} if defined $aliases{$opt};
d1270 1
a1270 3
		if ( defined $linkage{$opt} ) {
		    print STDERR ("=> ref(\$L{$opt}) -> ",
				  ref($linkage{$opt}), "\n") if $debug;
d1272 1
a1272 56
		    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
			print STDERR ("=> \$\$L{$opt} = \"$arg\"\n") if $debug;
			${$linkage{$opt}} = $arg;
		    }
		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
			print STDERR ("=> push(\@@{\$L{$opt}, \"$arg\")\n")
			    if $debug;
			push (@@{$linkage{$opt}}, $arg);
		    }
		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
			    if $debug;
			$linkage{$opt}->{$key} = $arg;
		    }
		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
			print STDERR ("=> &L{$opt}(\"$opt\", \"$arg\")\n")
			    if $debug;
			&{$linkage{$opt}}($opt, $arg);
		    }
		    else {
			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
				      "\" in linkage\n");
			die ("Getopt::Long -- internal error!\n");
		    }
		}
		# No entry in linkage means entry in userlinkage.
		elsif ( $array ) {
		    if ( defined $userlinkage->{$opt} ) {
			print STDERR ("=> push(\@@{\$L{$opt}}, \"$arg\")\n")
			    if $debug;
			push (@@{$userlinkage->{$opt}}, $arg);
		    }
		    else {
			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
			    if $debug;
			$userlinkage->{$opt} = [$arg];
		    }
		}
		elsif ( $hash ) {
		    if ( defined $userlinkage->{$opt} ) {
			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
			    if $debug;
			$userlinkage->{$opt}->{$key} = $arg;
		    }
		    else {
			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
			    if $debug;
			$userlinkage->{$opt} = {$key => $arg};
		    }
		}
		else {
		    print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
		    $userlinkage->{$opt} = $arg;
		}
	    }
	}
d1274 2
a1275 14
	# Not an option. Save it if we $PERMUTE and don't have a <>.
	elsif ( $order == $PERMUTE ) {
	    # Try non-options call-back.
	    my $cb;
	    if ( (defined ($cb = $linkage{'<>'})) ) {
		&$cb($tryopt);
	    }
	    else {
		print STDERR ("=> saving \"$tryopt\" ",
			      "(not an option, may permute)\n") if $debug;
		push (@@ret, $tryopt);
	    }
	    next;
	}
d1277 3
a1279 6
	# ...otherwise, terminate.
	else {
	    # Push this one back and exit.
	    unshift (@@ARGV, $tryopt);
	    return ($error == 0);
	}
d1281 1
a1281 1
    }
d1283 1
a1283 7
    # Finish.
    if ( $order == $PERMUTE ) {
	#  Push back accumulated arguments
	print STDERR ("=> restoring \"", join('" "', @@ret), "\"\n")
	    if $debug && @@ret > 0;
	unshift (@@ARGV, @@ret) if @@ret > 0;
    }
d1285 1
a1285 2
    return ($error == 0);
}
d1287 1
a1287 49
sub config (@@) {
    my (@@options) = @@_;
    my $opt;
    foreach $opt ( @@options ) {
	my $try = lc ($opt);
	my $action = 1;
	if ( $try =~ /^no_?/ ) {
	    $action = 0;
	    $try = $';
	}
	if ( $try eq 'default' or $try eq 'defaults' ) {
	    &$config_defaults () if $action;
	}
	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
	    $autoabbrev = $action;
	}
	elsif ( $try eq 'getopt_compat' ) {
	    $getopt_compat = $action;
	}
	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
	    $ignorecase = $action;
	}
	elsif ( $try eq 'ignore_case_always' ) {
	    $ignorecase = $action ? 2 : 0;
	}
	elsif ( $try eq 'bundling' ) {
	    $bundling = $action;
	}
	elsif ( $try eq 'bundling_override' ) {
	    $bundling = $action ? 2 : 0;
	}
	elsif ( $try eq 'require_order' ) {
	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
	}
	elsif ( $try eq 'permute' ) {
	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
	}
	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
	    $passthrough = $action;
	}
	elsif ( $try eq 'debug' ) {
	    $debug = $action;
	}
	else {
	    $Carp::CarpLevel = 1;
	    Carp::croak("Getopt::Long: unknown config parameter \"$opt\"")
	}
    }
}
d1289 1
a1289 18
# Modified from Exporter. This one handles 2.001 and 2.01 etc just like 2.1.
sub require_version {
    no strict;
    my ($self, $wanted) = @@_;
    my $pkg = ref $self || $self;
    my $version = $ {"${pkg}::VERSION"} || "(undef)";

    $wanted .= '.0' unless $wanted =~ /\./;
    $wanted = $1 * 1000 + $2 if $wanted =~ /^(\d+)\.(\d+)$/;
    $version = $1 * 1000 + $2 if $version =~ /^(\d+)\.(\d+)$/;
    if ( $version < $wanted ) {
	$version =~ s/^(\d+)(\d\d\d)$/$1.'.'.(0+$2)/e;
	$wanted =~ s/^(\d+)(\d\d\d)$/$1.'.'.(0+$2)/e;
	$Carp::CarpLevel = 1;
	Carp::croak("$pkg $wanted required--this is only version $version")
    }
    $version;
}
d1291 4
a1294 1
################ Private Subroutines ################
d1296 1
a1296 1
$find_option = sub {
d1298 2
a1299 1
    return 0 unless $opt =~ /^$genprefix/;
d1301 1
a1301 2
    $opt = $';
    my ($starter) = $&;
d1303 1
a1303 2
    my $optarg = undef;	# value supplied with --opt=value
    my $rest = undef;	# remainder from unbundling
d1305 1
a1305 8
    # If it is a long option, it may include the value.
    if (($starter eq "--" || $getopt_compat)
	&& $opt =~ /^([^=]+)=/ ) {
	$opt = $1;
	$optarg = $';
	print STDERR ("=> option \"", $opt, 
		      "\", optarg = \"$optarg\"\n") if $debug;
    }
d1307 1
a1307 1
    #### Look it up ###
d1309 2
a1310 3
    my $tryopt = $opt;		# option to try
    my $optbl = \%opctl;	# table to look it up (long names)
    my $type;
d1312 1
a1312 9
    if ( $bundling && $starter eq '-' ) {
	# Unbundle single letter option.
	$rest = substr ($tryopt, 1);
	$tryopt = substr ($tryopt, 0, 1);
	$tryopt = lc ($tryopt) if $ignorecase > 1;
	print STDERR ("=> $starter$tryopt unbundled from ",
		      "$starter$tryopt$rest\n") if $debug;
	$rest = undef unless $rest ne '';
	$optbl = \%bopctl;	# look it up in the short names table
d1314 1
a1314 9
	# If bundling == 2, long options can override bundles.
	if ( $bundling == 2 and
	     defined ($type = $opctl{$tryopt.$rest}) ) {
	    print STDERR ("=> $starter$tryopt rebundled to ",
			  "$starter$tryopt$rest\n") if $debug;
	    $tryopt .= $rest;
	    undef $rest;
	}
    } 
d1316 4
a1319 10
    # Try auto-abbreviation.
    elsif ( $autoabbrev ) {
	# Downcase if allowed.
	$tryopt = $opt = lc ($opt) if $ignorecase;
	# Turn option name into pattern.
	my $pat = quotemeta ($opt);
	# Look up in option names.
	my @@hits = grep (/^$pat/, @@opctl);
	print STDERR ("=> ", scalar(@@hits), " hits (@@hits) with \"$pat\" ",
		      "out of ", scalar(@@opctl), "\n") if $debug;
d1321 1
a1321 19
	# Check for ambiguous results.
	unless ( (@@hits <= 1) || (grep ($_ eq $opt, @@hits) == 1) ) {
	    # See if all matches are for the same option.
	    my %hit;
	    foreach ( @@hits ) {
		$_ = $aliases{$_} if defined $aliases{$_};
		$hit{$_} = 1;
	    }
	    # Now see if it really is ambiguous.
	    unless ( keys(%hit) == 1 ) {
		return 0 if $passthrough;
		print STDERR ("Option ", $opt, " is ambiguous (",
			      join(", ", @@hits), ")\n");
		$error++;
		undef $opt;
		return 1;
	    }
	    @@hits = keys(%hit);
	}
d1323 1
a1323 8
	# Complete the option name, if appropriate.
	if ( @@hits == 1 && $hits[0] ne $opt ) {
	    $tryopt = $hits[0];
	    $tryopt = lc ($tryopt) if $ignorecase;
	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
		if $debug;
	}
    }
d1325 1
a1325 4
    # Map to all lowercase if ignoring case.
    elsif ( $ignorecase ) {
	$tryopt = lc ($opt);
    }
d1327 1
a1327 11
    # Check validity by fetching the info.
    $type = $optbl->{$tryopt} unless defined $type;
    unless  ( defined $type ) {
	return 0 if $passthrough;
	warn ("Unknown option: ", $opt, "\n");
	$error++;
	return 1;
    }
    # Apparently valid.
    $opt = $tryopt;
    print STDERR ("=> found \"$type\" for ", $opt, "\n") if $debug;
d1329 3
a1331 1
    #### Determine argument status ####
d1333 1
a1333 18
    # If it is an option w/o argument, we're almost finished with it.
    if ( $type eq '' || $type eq '!' ) {
	if ( defined $optarg ) {
	    return 0 if $passthrough;
	    print STDERR ("Option ", $opt, " does not take an argument\n");
	    $error++;
	    undef $opt;
	}
	elsif ( $type eq '' ) {
	    $arg = 1;		# supply explicit value
	}
	else {
	    substr ($opt, 0, 2) = ''; # strip NO prefix
	    $arg = 0;		# supply explicit value
	}
	unshift (@@ARGV, $starter.$rest) if defined $rest;
	return 1;
    }
d1335 1
a1335 3
    # Get mandatory status and type info.
    my $mand;
    ($mand, $type, $array, $hash) = $type =~ /^(.)(.)(@@?)(%?)$/;
d1337 1
a1337 15
    # Check if there is an option argument available.
    if ( defined $optarg ? ($optarg eq '') 
	 : !(defined $rest || @@ARGV > 0) ) {
	# Complain if this option needs an argument.
	if ( $mand eq "=" ) {
	    return 0 if $passthrough;
	    print STDERR ("Option ", $opt, " requires an argument\n");
	    $error++;
	    undef $opt;
	}
	if ( $mand eq ":" ) {
	    $arg = $type eq "s" ? '' : 0;
	}
	return 1;
    }
d1339 1
a1339 3
    # Get (possibly optional) argument.
    $arg = (defined $rest ? $rest
	    : (defined $optarg ? $optarg : shift (@@ARGV)));
d1341 1
a1341 5
    # Get key if this is a "name=value" pair for a hash option.
    $key = undef;
    if ($hash && defined $arg) {
	($key, $arg) = ($arg =~ /=/o) ? ($`, $') : ($arg, 1);
    }
d1343 1
a1343 1
    #### Check if the argument is valid for this option ####
d1345 3
a1347 3
    if ( $type eq "s" ) {	# string
	# A mandatory string takes anything. 
	return 1 if $mand eq "=";
d1349 1
a1349 3
	# An optional string takes almost anything. 
	return 1 if defined $optarg || defined $rest;
	return 1 if $arg eq "-"; # ??
d1351 2
a1352 9
	# Check for option or option list terminator.
	if ($arg eq $argend ||
	    $arg =~ /^$genprefix.+/) {
	    # Push back.
	    unshift (@@ARGV, $arg);
	    # Supply empty value.
	    $arg = '';
	}
    }
d1354 1
a1354 23
    elsif ( $type eq "n" || $type eq "i" ) { # numeric/integer
	if ( $arg !~ /^-?[0-9]+$/ ) {
	    if ( defined $optarg || $mand eq "=" ) {
		if ( $passthrough ) {
		    unshift (@@ARGV, defined $rest ? $starter.$rest : $arg)
		      unless defined $optarg;
		    return 0;
		}
		print STDERR ("Value \"", $arg, "\" invalid for option ",
			      $opt, " (number expected)\n");
		$error++;
		undef $opt;
		# Push back.
		unshift (@@ARGV, $starter.$rest) if defined $rest;
	    }
	    else {
		# Push back.
		unshift (@@ARGV, defined $rest ? $starter.$rest : $arg);
		# Supply default value.
		$arg = 0;
	    }
	}
    }
d1356 2
a1357 28
    elsif ( $type eq "f" ) { # real number, int is also ok
	if ( $arg !~ /^-?[0-9.]+([eE]-?[0-9]+)?$/ ) {
	    if ( defined $optarg || $mand eq "=" ) {
		if ( $passthrough ) {
		    unshift (@@ARGV, defined $rest ? $starter.$rest : $arg)
		      unless defined $optarg;
		    return 0;
		}
		print STDERR ("Value \"", $arg, "\" invalid for option ",
			      $opt, " (real number expected)\n");
		$error++;
		undef $opt;
		# Push back.
		unshift (@@ARGV, $starter.$rest) if defined $rest;
	    }
	    else {
		# Push back.
		unshift (@@ARGV, defined $rest ? $starter.$rest : $arg);
		# Supply default value.
		$arg = 0.0;
	    }
	}
    }
    else {
	die ("GetOpt::Long internal error (Can't happen)\n");
    }
    return 1;
};
d1359 1
a1359 22
$config_defaults = sub {
    # Handle POSIX compliancy.
    if ( defined $ENV{"POSIXLY_CORRECT"} ) {
	$gen_prefix = "(--|-)";
	$autoabbrev = 0;		# no automatic abbrev of options
	$bundling = 0;			# no bundling of single letter switches
	$getopt_compat = 0;		# disallow '+' to start options
	$order = $REQUIRE_ORDER;
    }
    else {
	$gen_prefix = "(--|-|\\+)";
	$autoabbrev = 1;		# automatic abbrev of options
	$bundling = 0;			# bundling off by default
	$getopt_compat = 1;		# allow '+' to start options
	$order = $PERMUTE;
    }
    # Other configurable settings.
    $debug = 0;			# for debugging
    $error = 0;			# error tally
    $ignorecase = 1;		# ignore case when matching options
    $passthrough = 0;		# leave unrecognized options alone
};
d1361 1
a1361 1
################ Initialization ################
d1363 1
a1363 4
# Values for $order. See GNU getopt.c for details.
($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
# Version major/minor numbers.
($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;
d1365 1
a1365 2
# Set defaults.
&$config_defaults ();
d1367 14
a1380 1
################ Package return ################
d1382 1
a1382 1
1;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
# GetOpt::Long.pm -- POSIX compatible options parsing
d3 3
a5 1
# RCS Status      : $Id: GetoptLong.pm,v 2.1 1996/02/02 20:24:35 jv Exp $
d9 2
a10 2
# Last Modified On: Fri Feb  2 21:24:32 1996
# Update Count    : 347
a12 9
package Getopt::Long;
require 5.000;
require Exporter;

@@ISA = qw(Exporter);
@@EXPORT = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
$VERSION = sprintf("%d.%02d", q$Revision: 2.1 $ =~ /(\d+)\.(\d+)/);
use strict;

d28 4
a31 3
double dash "--". There is no bundling of command line options, as was
the case with the more traditional single-letter approach. For
example, the UNIX "ps" command can be given the command line "option" 
d52 1
a52 1
  &GetOptions("size=i" => \$offset);
d59 3
a61 2
a HASH describing the linkage for the options. The following call is
equivalent to the example above:
d64 1
a64 1
  &GetOptions(\%optctl, "size=i");
d79 1
a79 1
=item <none>
d148 1
a148 1
  &GetOptions (\%optctl, "size=i");
d157 1
a157 1
  &GetOptions (\%optctl, "sizes=i@@");
d164 11
d184 1
a184 1
  &GetOptions ("size=i", "sizes=i@@");
d196 1
a196 1
an array or a reference to a subroutine.
d205 5
d218 1
a218 1
op this option. If no linkage is specified, options "foo", "bar" and
d222 1
a222 1
configuration variable $Getopt::Long::autoabbrev.
d226 1
a226 1
A special option specifier, <>, can be used to designate a subroutine
d230 3
a232 1
This feature requires $Getopt::Long::order to have the value $PERMUTE.
d258 14
a271 7
treated as an array.  Value(s) are not set, but pushed into array
@@opt_name. This only applies if no linkage is supplied.

If configuration variable $Getopt::Long::getopt_compat is set to a
non-zero value, options that start with "+" may also include their
arguments, e.g. "+foo=bar". This is for compatiblity with older
implementations of the GNU "getopt" routine.
d304 1
a304 1
Example of using variabel references:
d306 1
a306 1
   $ret = &GetOptions ('foo=s', \$foo, 'bar=i', 'ar=s', \@@ar);
d311 1
a311 1
   $bar = 'blech'
d315 1
a315 1
Example of using the <> option specifier:
d318 1
a318 1
   &GetOptions("foo=i", \$myfoo, "<>", \&mysub);
d322 2
a323 2
   &mysub("bar") will be called (with $myfoo being 1)
   &mysub("blech") will be called (with $myfoo being 2)
d328 1
a328 1
   &GetOptions("foo=i", \$myfoo);
d335 13
a347 1
=head1 CONFIGURATION VARIABLES
d349 1
a349 2
The following variables can be set to change the default behaviour of
GetOptions():
d353 6
a358 1
=item $Getopt::Long::autoabbrev      
d361 2
a362 2
Default is 1 unless environment variable
POSIXLY_CORRECT has been set.
d364 1
a364 1
=item $Getopt::Long::getopt_compat   
d367 4
a370 2
Default is 1 unless environment variable
POSIXLY_CORRECT has been set.
d372 8
a379 1
=item $Getopt::Long::order           
d383 3
a385 2
Default is $REQUIRE_ORDER if environment variable
POSIXLY_CORRECT has been set, $PERMUTE otherwise.
d387 1
a387 1
$PERMUTE means that 
d404 1
a404 1
If $Getopt::Long::order is $REQUIRE_ORDER, options processing
d413 8
a420 1
$RETURN_IN_ORDER is not supported by GetOptions().
d422 1
a422 1
=item $Getopt::Long::ignorecase      
d424 59
a482 1
Ignore case when matching options. Default is 1.
d490 1
a490 1
    use Getopt::Long 2.00;
a499 4
=item $Getopt::Long::debug           

Enable copious debugging output. Default is 0.

d504 3
a506 8
################ Introduction ################
#
# This package implements an extended getopt function. This function
# adheres to the new syntax (long option names, no bundling). It tries
# to implement the better functionality of traditional, GNU and POSIX
# getopt functions.
# 
# This program is Copyright 1990,1996 by Johan Vromans.
d521 1
a521 12
################ History ################
# 
# 13-Jan-1996		Johan Vromans
#    Generalized the linkage interface.
#    Eliminated the linkage argument.
#    Add code references as a possible value for the option linkage.
#    Add option specifier <> to have a call-back for non-options.
#
# 26-Dec-1995		Johan Vromans
#    Import from netgetopt.pl.
#    Turned into a decent module.
#    Added linkage argument.
d523 1
a523 1
################ Configuration Section ################
d525 11
a535 4
# Values for $order. See GNU getopt.c for details.
($Getopt::Long::REQUIRE_ORDER,
 $Getopt::Long::PERMUTE, 
 $Getopt::Long::RETURN_IN_ORDER) = (0..2);
d537 6
a542 1
my $gen_prefix;			# generic prefix (option starters)
d544 1
a544 13
# Handle POSIX compliancy.
if ( defined $ENV{"POSIXLY_CORRECT"} ) {
    $gen_prefix = "(--|-)";
    $Getopt::Long::autoabbrev = 0;	# no automatic abbrev of options
    $Getopt::Long::getopt_compat = 0;	# disallow '+' to start options
    $Getopt::Long::order = $Getopt::Long::REQUIRE_ORDER;
}
else {
    $gen_prefix = "(--|-|\\+)";
    $Getopt::Long::autoabbrev = 1;	# automatic abbrev of options
    $Getopt::Long::getopt_compat = 1;	# allow '+' to start options
    $Getopt::Long::order = $Getopt::Long::PERMUTE;
}
d546 16
a561 8
# Other configurable settings.
$Getopt::Long::debug = 0;		# for debugging
$Getopt::Long::error = 0;		# error tally
$Getopt::Long::ignorecase = 1;		# ignore case when matching options
($Getopt::Long::version,
 $Getopt::Long::major_version, 
 $Getopt::Long::minor_version) = '$Revision: 2.1 $ ' =~ /: ((\d+)\.(\d+))/;
$Getopt::Long::version .= '*' if length('$Locker:  $ ') > 12;
d568 4
a571 3
    my $argend = '--';		# option list terminator
    my %opctl;			# table of arg.specs
    my $pkg = (caller)[0];	# current context
d573 1
a573 1
    my %aliases;		# alias table
d577 2
a578 4
    my $debug = $Getopt::Long::debug;	# convenience
    my $genprefix = $gen_prefix; # so we can call the same module more 
				# than once in differing environments
    $Getopt::Long::error = 0;
d580 2
a581 2
    print STDERR ("GetOptions $Getopt::Long::version",
		  " [GetOpt::Long $Getopt::Long::VERSION] -- ",
d583 7
a589 2
		  "  autoabbrev=$Getopt::Long::autoabbrev".
		  ",getopt_compat=$Getopt::Long::getopt_compat",
a590 2
		  ",order=$Getopt::Long::order",
		  ",ignorecase=$Getopt::Long::ignorecase",
d595 2
d598 2
a599 1
    if ( ref($optionlist[0]) && ref($optionlist[0]) eq 'HASH' ) {
d601 1
d615 1
d619 1
a619 1
	# Strip leading prefix so people can specify "-foo=i" if they like.
d632 1
a632 1
		$Getopt::Long::error++;
d639 1
a639 2
	$opt =~ tr/A-Z/a-z/ if $Getopt::Long::ignorecase;
	if ( $opt !~ /^(\w+[-\w|]*)?(!|[=:][infse]@@?)?$/ ) {
d641 1
a641 1
	    $Getopt::Long::error++;
d645 1
d649 1
a649 1
	    $opctl{$o = ''} = defined $c ? $c : '';
d654 8
a661 1
	    $o = $o[0];
d663 16
a678 3
		if ( defined $c && $c eq '!' ) {
		    $opctl{"no$_"} = $c;
		    $c = '';
a679 1
		$opctl{$_} = defined $c ? $c : '';
d689 1
d713 11
a723 3
	    if ( ref($optionlist[0]) eq 'SCALAR'
		|| ref($optionlist[0]) eq 'ARRAY'
		|| ref($optionlist[0]) eq 'CODE' ) {
d725 4
d732 1
a732 1
		$Getopt::Long::error++;
d740 1
a740 1
	    if ( $c && $c =~ /@@/ ) {
d745 5
d759 1
a759 1
    return 0 if $Getopt::Long::error;
d761 2
a762 2
    # Sort the possible option names.
    my @@opctl = sort(keys (%opctl)) if $Getopt::Long::autoabbrev;
d764 1
a764 1
    # Show if debugging.
d772 5
a778 4
    my $opt;			# current option
    my $arg;			# current option value
    my $array;			# current option is array typed

a781 2
	# >>> See also the continue block <<<

d786 1
a786 2
	my $optarg = undef;
	$array = 0;
d795 2
a796 2
		if $Getopt::Long::order == $Getopt::Long::PERMUTE;
	    return ($Getopt::Long::error == 0);
d799 69
a867 10
	if ( $opt =~ /^$genprefix/ ) {
	    # Looks like an option.
	    $opt = $';		# option name (w/o prefix)
	    # If it is a long opt, it may include the value.
	    if (($& eq "--" || ($Getopt::Long::getopt_compat && $& eq "+"))
		&& $opt =~ /^([^=]+)=/ ) {
		$opt = $1;
		$optarg = $';
		print STDERR ("=> option \"", $opt, 
			      "\", optarg = \"$optarg\"\n") if $debug;
a868 1

d872 1
a872 1
	elsif ( $Getopt::Long::order == $Getopt::Long::PERMUTE ) {
d876 1
a876 1
		&$cb($opt);
d879 3
a881 1
		push (@@ret, $opt);
d889 2
a890 2
	    unshift (@@ARGV, $opt);
	    return ($Getopt::Long::error == 0);
d893 1
a893 1
	#### Look it up ###
d895 7
a901 1
	$opt =~ tr/A-Z/a-z/ if $Getopt::Long::ignorecase;
d903 94
a996 3
	my $tryopt = $opt;
	if ( $Getopt::Long::autoabbrev ) {
	    my $pat;
d998 23
a1020 6
	    # Turn option name into pattern.
	    ($pat = $opt) =~ s/(\W)/\\$1/g;
	    # Look up in option names.
	    my @@hits = grep (/^$pat/, @@opctl);
	    print STDERR ("=> ", 0+@@hits, " hits (@@hits) with \"$pat\" ",
			  "out of ", 0+@@opctl, "\n") if $debug;
d1022 22
a1043 2
	    # Check for ambiguous results.
	    unless ( (@@hits <= 1) || (grep ($_ eq $opt, @@hits) == 1) ) {
d1046 3
a1048 9
		$Getopt::Long::error++;
		next;
	    }

	    # Complete the option name, if appropriate.
	    if ( @@hits == 1 && $hits[0] ne $opt ) {
		$tryopt = $hits[0];
		print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
		    if $debug;
d1050 1
d1053 6
a1058 5
	my $type;
	unless  ( defined ( $type = $opctl{$tryopt} ) ) {
	    print STDERR ("Unknown option: ", $opt, "\n");
	    $Getopt::Long::error++;
	    next;
d1060 1
a1060 2
	$opt = $tryopt;
	print STDERR ("=> found \"$type\" for ", $opt, "\n") if $debug;
d1062 4
a1065 1
	#### Determine argument status ####
d1067 28
a1094 14
	# If it is an option w/o argument, we're almost finished with it.
	if ( $type eq '' || $type eq '!' ) {
	    if ( defined $optarg ) {
		print STDERR ("Option ", $opt, " does not take an argument\n");
		$Getopt::Long::error++;
	    }
	    elsif ( $type eq '' ) {
		$arg = 1;		# supply explicit value
	    }
	    else {
		substr ($opt, 0, 2) = ''; # strip NO prefix
		$arg = 0;		# supply explicit value
	    }
	    next;
d1096 3
d1100 16
a1115 16
	# Get mandatory status and type info.
	my $mand;
	($mand, $type, $array) = $type =~ /^(.)(.)(@@?)$/;

	# Check if there is an option argument available.
	if ( defined $optarg ? ($optarg eq '') : (@@ARGV <= 0) ) {

	    # Complain if this option needs an argument.
	    if ( $mand eq "=" ) {
		print STDERR ("Option ", $opt, " requires an argument\n");
		$Getopt::Long::error++;
	    }
	    if ( $mand eq ":" ) {
		$arg = $type eq "s" ? '' : 0;
	    }
	    next;
d1117 2
d1120 9
a1128 2
	# Get (possibly optional) argument.
	$arg = defined $optarg ? $optarg : shift (@@ARGV);
d1130 1
a1130 1
	#### Check if the argument is valid for this option ####
d1132 15
a1146 17
	if ( $type eq "s" ) {	# string
	    # A mandatory string takes anything. 
	    next if $mand eq "=";

	    # An optional string takes almost anything. 
	    next if defined $optarg;
	    next if $arg eq "-";

	    # Check for option or option list terminator.
	    if ($arg eq $argend ||
		$arg =~ /^$genprefix.+/) {
		# Push back.
		unshift (@@ARGV, $arg);
		# Supply empty value.
		$arg = '';
	    }
	    next;
d1148 1
d1150 7
a1156 13
	if ( $type eq "n" || $type eq "i" ) { # numeric/integer
	    if ( $arg !~ /^-?[0-9]+$/ ) {
		if ( defined $optarg || $mand eq "=" ) {
		    print STDERR ("Value \"", $arg, "\" invalid for option ",
				  $opt, " (number expected)\n");
		    $Getopt::Long::error++;
		    undef $arg;	# don't assign it
		}
		else {
		    # Push back.
		    unshift (@@ARGV, $arg);
		    # Supply default value.
		    $arg = 0;
d1158 6
d1165 5
a1169 17
	    next;
	}

	if ( $type eq "f" ) { # fixed real number, int is also ok
	    if ( $arg !~ /^-?[0-9.]+$/ ) {
		if ( defined $optarg || $mand eq "=" ) {
		    print STDERR ("Value \"", $arg, "\" invalid for option ",
				  $opt, " (real number expected)\n");
		    $Getopt::Long::error++;
		    undef $arg;	# don't assign it
		}
		else {
		    # Push back.
		    unshift (@@ARGV, $arg);
		    # Supply default value.
		    $arg = 0.0;
		}
a1170 1
	    next;
a1171 2

	die ("GetOpt::Long internal error (Can't happen)\n");
d1174 7
a1180 39
    continue {
	if ( defined $arg ) {
	    $opt = $aliases{$opt} if defined $aliases{$opt};

	    if ( defined $linkage{$opt} ) {
		print STDERR ("=> ref(\$L{$opt}) -> ",
			      ref($linkage{$opt}), "\n") if $debug;

		if ( ref($linkage{$opt}) eq 'SCALAR' ) {
		    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n") if $debug;
		    ${$linkage{$opt}} = $arg;
		}
		elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
		    print STDERR ("=> push(\@@{\$L{$opt}, \"$arg\")\n")
			if $debug;
		    push (@@{$linkage{$opt}}, $arg);
		}
		elsif ( ref($linkage{$opt}) eq 'CODE' ) {
		    print STDERR ("=> &L{$opt}(\"$opt\", \"$arg\")\n")
			if $debug;
		    &{$linkage{$opt}}($opt, $arg);
		}
		else {
		    print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
				  "\" in linkage\n");
		    die ("Getopt::Long -- internal error!\n");
		}
	    }
	    # No entry in linkage means entry in userlinkage.
	    elsif ( $array ) {
		if ( defined $userlinkage->{$opt} ) {
		    print STDERR ("=> push(\@@{\$L{$opt}}, \"$arg\")\n")
			if $debug;
		    push (@@{$userlinkage->{$opt}}, $arg);
		}
		else {
		    print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
			if $debug;
		    $userlinkage->{$opt} = [$arg];
d1182 6
d1190 4
a1193 2
		print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
		$userlinkage->{$opt} = $arg;
d1197 5
d1203 15
a1217 4
    # Finish.
    if ( $Getopt::Long::order == $Getopt::Long::PERMUTE ) {
	#  Push back accumulated arguments
	unshift (@@ARGV, @@ret) if @@ret > 0;
d1219 8
d1228 7
a1234 2
    return ($Getopt::Long::error == 0);
}
d1238 1
a1238 2
# Returning 1 is so boring...
$Getopt::Long::major_version * 1000 + $Getopt::Long::minor_version;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d1 1
a1 1
# GetOpt::Long.pm -- Universal options parsing
d3 1
a3 3
package Getopt::Long;

# RCS Status      : $Id: GetoptLong.pl,v 2.18 1998-06-14 15:02:19+02 jv Exp $
d7 2
a8 2
# Last Modified On: Fri Jan  8 14:48:43 1999
# Update Count    : 707
d11 3
a13 18
################ Copyright ################

# This program is Copyright 1990,1999 by Johan Vromans.
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# If you do not have a copy of the GNU General Public License write to
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, 
# MA 02139, USA.

################ Module Preamble ################
d15 3
a19 801
BEGIN {
    require 5.004;
    use Exporter ();
    use vars     qw($VERSION @@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS);
    $VERSION     = "2.19";

    @@ISA         = qw(Exporter);
    @@EXPORT      = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
    %EXPORT_TAGS = qw();
    @@EXPORT_OK   = qw();
    use AutoLoader qw(AUTOLOAD);
}

# User visible variables.
use vars @@EXPORT, @@EXPORT_OK;
use vars qw($error $debug $major_version $minor_version);
# Deprecated visible variables.
use vars qw($autoabbrev $getopt_compat $ignorecase $bundling $order
	    $passthrough);
# Official invisible variables.
use vars qw($genprefix);

# Public subroutines. 
sub Configure (@@);
sub config (@@);			# deprecated name
sub GetOptions;

# Private subroutines. 
sub ConfigDefaults ();
sub FindOption ($$$$$$$);
sub Croak (@@);			# demand loading the real Croak

################ Local Variables ################

################ Resident subroutines ################

sub ConfigDefaults () {
    # Handle POSIX compliancy.
    if ( defined $ENV{"POSIXLY_CORRECT"} ) {
	$genprefix = "(--|-)";
	$autoabbrev = 0;		# no automatic abbrev of options
	$bundling = 0;			# no bundling of single letter switches
	$getopt_compat = 0;		# disallow '+' to start options
	$order = $REQUIRE_ORDER;
    }
    else {
	$genprefix = "(--|-|\\+)";
	$autoabbrev = 1;		# automatic abbrev of options
	$bundling = 0;			# bundling off by default
	$getopt_compat = 1;		# allow '+' to start options
	$order = $PERMUTE;
    }
    # Other configurable settings.
    $debug = 0;			# for debugging
    $error = 0;			# error tally
    $ignorecase = 1;		# ignore case when matching options
    $passthrough = 0;		# leave unrecognized options alone
}

################ Initialization ################

# Values for $order. See GNU getopt.c for details.
($REQUIRE_ORDER, $PERMUTE, $RETURN_IN_ORDER) = (0..2);
# Version major/minor numbers.
($major_version, $minor_version) = $VERSION =~ /^(\d+)\.(\d+)/;

# Set defaults.
ConfigDefaults ();

################ Package return ################

1;

__END__

################ AutoLoading subroutines ################

# RCS Status      : $Id: GetoptLongAl.pl,v 2.20 1998-06-14 15:02:19+02 jv Exp $
# Author          : Johan Vromans
# Created On      : Fri Mar 27 11:50:30 1998
# Last Modified By: Johan Vromans
# Last Modified On: Sun Jun 14 13:54:35 1998
# Update Count    : 24
# Status          : Released

sub GetOptions {

    my @@optionlist = @@_;	# local copy of the option descriptions
    my $argend = '--';		# option list terminator
    my %opctl = ();		# table of arg.specs (long and abbrevs)
    my %bopctl = ();		# table of arg.specs (bundles)
    my $pkg = (caller)[0];	# current context
				# Needed if linkage is omitted.
    my %aliases= ();		# alias table
    my @@ret = ();		# accum for non-options
    my %linkage;		# linkage
    my $userlinkage;		# user supplied HASH
    my $opt;			# current option
    my $genprefix = $genprefix;	# so we can call the same module many times
    my @@opctl;			# the possible long option names

    $error = '';

    print STDERR ("GetOpt::Long $Getopt::Long::VERSION ",
		  "called from package \"$pkg\".",
		  "\n  ",
		  'GetOptionsAl $Revision: 2.20 $ ',
		  "\n  ",
		  "ARGV: (@@ARGV)",
		  "\n  ",
		  "autoabbrev=$autoabbrev,".
		  "bundling=$bundling,",
		  "getopt_compat=$getopt_compat,",
		  "order=$order,",
		  "\n  ",
		  "ignorecase=$ignorecase,",
		  "passthrough=$passthrough,",
		  "genprefix=\"$genprefix\".",
		  "\n")
	if $debug;

    # Check for ref HASH as first argument. 
    # First argument may be an object. It's OK to use this as long
    # as it is really a hash underneath. 
    $userlinkage = undef;
    if ( ref($optionlist[0]) and
	 "$optionlist[0]" =~ /^(?:.*\=)?HASH\([^\(]*\)$/ ) {
	$userlinkage = shift (@@optionlist);
	print STDERR ("=> user linkage: $userlinkage\n") if $debug;
    }

    # See if the first element of the optionlist contains option
    # starter characters.
    if ( $optionlist[0] =~ /^\W+$/ ) {
	$genprefix = shift (@@optionlist);
	# Turn into regexp. Needs to be parenthesized!
	$genprefix =~ s/(\W)/\\$1/g;
	$genprefix = "([" . $genprefix . "])";
    }

    # Verify correctness of optionlist.
    %opctl = ();
    %bopctl = ();
    while ( @@optionlist > 0 ) {
	my $opt = shift (@@optionlist);

	# Strip leading prefix so people can specify "--foo=i" if they like.
	$opt = $+ if $opt =~ /^$genprefix+(.*)$/s;

	if ( $opt eq '<>' ) {
	    if ( (defined $userlinkage)
		&& !(@@optionlist > 0 && ref($optionlist[0]))
		&& (exists $userlinkage->{$opt})
		&& ref($userlinkage->{$opt}) ) {
		unshift (@@optionlist, $userlinkage->{$opt});
	    }
	    unless ( @@optionlist > 0 
		    && ref($optionlist[0]) && ref($optionlist[0]) eq 'CODE' ) {
		$error .= "Option spec <> requires a reference to a subroutine\n";
		next;
	    }
	    $linkage{'<>'} = shift (@@optionlist);
	    next;
	}

	# Match option spec. Allow '?' as an alias.
	if ( $opt !~ /^((\w+[-\w]*)(\|(\?|\w[-\w]*)?)*)?([!~+]|[=:][infse][@@%]?)?$/ ) {
	    $error .= "Error in option spec: \"$opt\"\n";
	    next;
	}
	my ($o, $c, $a) = ($1, $5);
	$c = '' unless defined $c;

	if ( ! defined $o ) {
	    # empty -> '-' option
	    $opctl{$o = ''} = $c;
	}
	else {
	    # Handle alias names
	    my @@o =  split (/\|/, $o);
	    my $linko = $o = $o[0];
	    # Force an alias if the option name is not locase.
	    $a = $o unless $o eq lc($o);
	    $o = lc ($o)
		if $ignorecase > 1 
		    || ($ignorecase
			&& ($bundling ? length($o) > 1  : 1));

	    foreach ( @@o ) {
		if ( $bundling && length($_) == 1 ) {
		    $_ = lc ($_) if $ignorecase > 1;
		    if ( $c eq '!' ) {
			$opctl{"no$_"} = $c;
			warn ("Ignoring '!' modifier for short option $_\n");
			$c = '';
		    }
		    $opctl{$_} = $bopctl{$_} = $c;
		}
		else {
		    $_ = lc ($_) if $ignorecase;
		    if ( $c eq '!' ) {
			$opctl{"no$_"} = $c;
			$c = '';
		    }
		    $opctl{$_} = $c;
		}
		if ( defined $a ) {
		    # Note alias.
		    $aliases{$_} = $a;
		}
		else {
		    # Set primary name.
		    $a = $_;
		}
	    }
	    $o = $linko;
	}

	# If no linkage is supplied in the @@optionlist, copy it from
	# the userlinkage if available.
	if ( defined $userlinkage ) {
	    unless ( @@optionlist > 0 && ref($optionlist[0]) ) {
		if ( exists $userlinkage->{$o} && ref($userlinkage->{$o}) ) {
		    print STDERR ("=> found userlinkage for \"$o\": ",
				  "$userlinkage->{$o}\n")
			if $debug;
		    unshift (@@optionlist, $userlinkage->{$o});
		}
		else {
		    # Do nothing. Being undefined will be handled later.
		    next;
		}
	    }
	}

	# Copy the linkage. If omitted, link to global variable.
	if ( @@optionlist > 0 && ref($optionlist[0]) ) {
	    print STDERR ("=> link \"$o\" to $optionlist[0]\n")
		if $debug;
	    if ( ref($optionlist[0]) =~ /^(SCALAR|CODE)$/ ) {
		$linkage{$o} = shift (@@optionlist);
	    }
	    elsif ( ref($optionlist[0]) =~ /^(ARRAY)$/ ) {
		$linkage{$o} = shift (@@optionlist);
		$opctl{$o} .= '@@'
		  if $opctl{$o} ne '' and $opctl{$o} !~ /\@@$/;
		$bopctl{$o} .= '@@'
		  if $bundling and defined $bopctl{$o} and 
		    $bopctl{$o} ne '' and $bopctl{$o} !~ /\@@$/;
	    }
	    elsif ( ref($optionlist[0]) =~ /^(HASH)$/ ) {
		$linkage{$o} = shift (@@optionlist);
		$opctl{$o} .= '%'
		  if $opctl{$o} ne '' and $opctl{$o} !~ /\%$/;
		$bopctl{$o} .= '%'
		  if $bundling and defined $bopctl{$o} and 
		    $bopctl{$o} ne '' and $bopctl{$o} !~ /\%$/;
	    }
	    else {
		$error .= "Invalid option linkage for \"$opt\"\n";
	    }
	}
	else {
	    # Link to global $opt_XXX variable.
	    # Make sure a valid perl identifier results.
	    my $ov = $o;
	    $ov =~ s/\W/_/g;
	    if ( $c =~ /@@/ ) {
		print STDERR ("=> link \"$o\" to \@@$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$o} = \\\@@".$pkg."::opt_$ov;");
	    }
	    elsif ( $c =~ /%/ ) {
		print STDERR ("=> link \"$o\" to \%$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$o} = \\\%".$pkg."::opt_$ov;");
	    }
	    else {
		print STDERR ("=> link \"$o\" to \$$pkg","::opt_$ov\n")
		    if $debug;
		eval ("\$linkage{\$o} = \\\$".$pkg."::opt_$ov;");
	    }
	}
    }

    # Bail out if errors found.
    die ($error) if $error;
    $error = 0;

    # Sort the possible long option names.
    @@opctl = sort(keys (%opctl)) if $autoabbrev;

    # Show the options tables if debugging.
    if ( $debug ) {
	my ($arrow, $k, $v);
	$arrow = "=> ";
	while ( ($k,$v) = each(%opctl) ) {
	    print STDERR ($arrow, "\$opctl{\"$k\"} = \"$v\"\n");
	    $arrow = "   ";
	}
	$arrow = "=> ";
	while ( ($k,$v) = each(%bopctl) ) {
	    print STDERR ($arrow, "\$bopctl{\"$k\"} = \"$v\"\n");
	    $arrow = "   ";
	}
    }

    # Process argument list
    while ( @@ARGV > 0 ) {

	#### Get next argument ####

	$opt = shift (@@ARGV);
	print STDERR ("=> option \"", $opt, "\"\n") if $debug;

	#### Determine what we have ####

	# Double dash is option list terminator.
	if ( $opt eq $argend ) {
	    # Finish. Push back accumulated arguments and return.
	    unshift (@@ARGV, @@ret) 
		if $order == $PERMUTE;
	    return ($error == 0);
	}

	my $tryopt = $opt;
	my $found;		# success status
	my $dsttype;		# destination type ('@@' or '%')
	my $incr;		# destination increment 
	my $key;		# key (if hash type)
	my $arg;		# option argument

	($found, $opt, $arg, $dsttype, $incr, $key) = 
	  FindOption ($genprefix, $argend, $opt, 
		      \%opctl, \%bopctl, \@@opctl, \%aliases);

	if ( $found ) {
	    
	    # FindOption undefines $opt in case of errors.
	    next unless defined $opt;

	    if ( defined $arg ) {
		$opt = $aliases{$opt} if defined $aliases{$opt};

		if ( defined $linkage{$opt} ) {
		    print STDERR ("=> ref(\$L{$opt}) -> ",
				  ref($linkage{$opt}), "\n") if $debug;

		    if ( ref($linkage{$opt}) eq 'SCALAR' ) {
			if ( $incr ) {
			    print STDERR ("=> \$\$L{$opt} += \"$arg\"\n")
			      if $debug;
			    if ( defined ${$linkage{$opt}} ) {
			        ${$linkage{$opt}} += $arg;
			    }
		            else {
			        ${$linkage{$opt}} = $arg;
			    }
			}
			else {
			    print STDERR ("=> \$\$L{$opt} = \"$arg\"\n")
			      if $debug;
			    ${$linkage{$opt}} = $arg;
		        }
		    }
		    elsif ( ref($linkage{$opt}) eq 'ARRAY' ) {
			print STDERR ("=> push(\@@{\$L{$opt}, \"$arg\")\n")
			    if $debug;
			push (@@{$linkage{$opt}}, $arg);
		    }
		    elsif ( ref($linkage{$opt}) eq 'HASH' ) {
			print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
			    if $debug;
			$linkage{$opt}->{$key} = $arg;
		    }
		    elsif ( ref($linkage{$opt}) eq 'CODE' ) {
			print STDERR ("=> &L{$opt}(\"$opt\", \"$arg\")\n")
			    if $debug;
			&{$linkage{$opt}}($opt, $arg);
		    }
		    else {
			print STDERR ("Invalid REF type \"", ref($linkage{$opt}),
				      "\" in linkage\n");
			Croak ("Getopt::Long -- internal error!\n");
		    }
		}
		# No entry in linkage means entry in userlinkage.
		elsif ( $dsttype eq '@@' ) {
		    if ( defined $userlinkage->{$opt} ) {
			print STDERR ("=> push(\@@{\$L{$opt}}, \"$arg\")\n")
			    if $debug;
			push (@@{$userlinkage->{$opt}}, $arg);
		    }
		    else {
			print STDERR ("=>\$L{$opt} = [\"$arg\"]\n")
			    if $debug;
			$userlinkage->{$opt} = [$arg];
		    }
		}
		elsif ( $dsttype eq '%' ) {
		    if ( defined $userlinkage->{$opt} ) {
			print STDERR ("=> \$L{$opt}->{$key} = \"$arg\"\n")
			    if $debug;
			$userlinkage->{$opt}->{$key} = $arg;
		    }
		    else {
			print STDERR ("=>\$L{$opt} = {$key => \"$arg\"}\n")
			    if $debug;
			$userlinkage->{$opt} = {$key => $arg};
		    }
		}
		else {
		    if ( $incr ) {
			print STDERR ("=> \$L{$opt} += \"$arg\"\n")
			  if $debug;
			if ( defined $userlinkage->{$opt} ) {
			    $userlinkage->{$opt} += $arg;
			}
			else {
			    $userlinkage->{$opt} = $arg;
			}
		    }
		    else {
			print STDERR ("=>\$L{$opt} = \"$arg\"\n") if $debug;
			$userlinkage->{$opt} = $arg;
		    }
		}
	    }
	}

	# Not an option. Save it if we $PERMUTE and don't have a <>.
	elsif ( $order == $PERMUTE ) {
	    # Try non-options call-back.
	    my $cb;
	    if ( (defined ($cb = $linkage{'<>'})) ) {
		&$cb ($tryopt);
	    }
	    else {
		print STDERR ("=> saving \"$tryopt\" ",
			      "(not an option, may permute)\n") if $debug;
		push (@@ret, $tryopt);
	    }
	    next;
	}

	# ...otherwise, terminate.
	else {
	    # Push this one back and exit.
	    unshift (@@ARGV, $tryopt);
	    return ($error == 0);
	}

    }

    # Finish.
    if ( $order == $PERMUTE ) {
	#  Push back accumulated arguments
	print STDERR ("=> restoring \"", join('" "', @@ret), "\"\n")
	    if $debug && @@ret > 0;
	unshift (@@ARGV, @@ret) if @@ret > 0;
    }

    return ($error == 0);
}

# Option lookup.
sub FindOption ($$$$$$$) {

    # returns (1, $opt, $arg, $dsttype, $incr, $key) if okay,
    # returns (0) otherwise.

    my ($prefix, $argend, $opt, $opctl, $bopctl, $names, $aliases) = @@_;
    my $key;			# hash key for a hash option
    my $arg;

    print STDERR ("=> find \"$opt\", prefix=\"$prefix\"\n") if $debug;

    return (0) unless $opt =~ /^$prefix(.*)$/s;

    $opt = $+;
    my ($starter) = $1;

    print STDERR ("=> split \"$starter\"+\"$opt\"\n") if $debug;

    my $optarg = undef;	# value supplied with --opt=value
    my $rest = undef;	# remainder from unbundling

    # If it is a long option, it may include the value.
    if (($starter eq "--" || ($getopt_compat && !$bundling))
	&& $opt =~ /^([^=]+)=(.*)$/s ) {
	$opt = $1;
	$optarg = $2;
	print STDERR ("=> option \"", $opt, 
		      "\", optarg = \"$optarg\"\n") if $debug;
    }

    #### Look it up ###

    my $tryopt = $opt;		# option to try
    my $optbl = $opctl;		# table to look it up (long names)
    my $type;
    my $dsttype = '';
    my $incr = 0;

    if ( $bundling && $starter eq '-' ) {
	# Unbundle single letter option.
	$rest = substr ($tryopt, 1);
	$tryopt = substr ($tryopt, 0, 1);
	$tryopt = lc ($tryopt) if $ignorecase > 1;
	print STDERR ("=> $starter$tryopt unbundled from ",
		      "$starter$tryopt$rest\n") if $debug;
	$rest = undef unless $rest ne '';
	$optbl = $bopctl;	# look it up in the short names table

	# If bundling == 2, long options can override bundles.
	if ( $bundling == 2 and
	     defined ($rest) and
	     defined ($type = $opctl->{$tryopt.$rest}) ) {
	    print STDERR ("=> $starter$tryopt rebundled to ",
			  "$starter$tryopt$rest\n") if $debug;
	    $tryopt .= $rest;
	    undef $rest;
	}
    } 

    # Try auto-abbreviation.
    elsif ( $autoabbrev ) {
	# Downcase if allowed.
	$tryopt = $opt = lc ($opt) if $ignorecase;
	# Turn option name into pattern.
	my $pat = quotemeta ($opt);
	# Look up in option names.
	my @@hits = grep (/^$pat/, @@{$names});
	print STDERR ("=> ", scalar(@@hits), " hits (@@hits) with \"$pat\" ",
		      "out of ", scalar(@@{$names}), "\n") if $debug;

	# Check for ambiguous results.
	unless ( (@@hits <= 1) || (grep ($_ eq $opt, @@hits) == 1) ) {
	    # See if all matches are for the same option.
	    my %hit;
	    foreach ( @@hits ) {
		$_ = $aliases->{$_} if defined $aliases->{$_};
		$hit{$_} = 1;
	    }
	    # Now see if it really is ambiguous.
	    unless ( keys(%hit) == 1 ) {
		return (0) if $passthrough;
		warn ("Option ", $opt, " is ambiguous (",
		      join(", ", @@hits), ")\n");
		$error++;
		undef $opt;
		return (1, $opt,$arg,$dsttype,$incr,$key);
	    }
	    @@hits = keys(%hit);
	}

	# Complete the option name, if appropriate.
	if ( @@hits == 1 && $hits[0] ne $opt ) {
	    $tryopt = $hits[0];
	    $tryopt = lc ($tryopt) if $ignorecase;
	    print STDERR ("=> option \"$opt\" -> \"$tryopt\"\n")
		if $debug;
	}
    }

    # Map to all lowercase if ignoring case.
    elsif ( $ignorecase ) {
	$tryopt = lc ($opt);
    }

    # Check validity by fetching the info.
    $type = $optbl->{$tryopt} unless defined $type;
    unless  ( defined $type ) {
	return (0) if $passthrough;
	warn ("Unknown option: ", $opt, "\n");
	$error++;
	return (1, $opt,$arg,$dsttype,$incr,$key);
    }
    # Apparently valid.
    $opt = $tryopt;
    print STDERR ("=> found \"$type\" for ", $opt, "\n") if $debug;

    #### Determine argument status ####

    # If it is an option w/o argument, we're almost finished with it.
    if ( $type eq '' || $type eq '!' || $type eq '+' ) {
	if ( defined $optarg ) {
	    return (0) if $passthrough;
	    warn ("Option ", $opt, " does not take an argument\n");
	    $error++;
	    undef $opt;
	}
	elsif ( $type eq '' || $type eq '+' ) {
	    $arg = 1;		# supply explicit value
	    $incr = $type eq '+';
	}
	else {
	    substr ($opt, 0, 2) = ''; # strip NO prefix
	    $arg = 0;		# supply explicit value
	}
	unshift (@@ARGV, $starter.$rest) if defined $rest;
	return (1, $opt,$arg,$dsttype,$incr,$key);
    }

    # Get mandatory status and type info.
    my $mand;
    ($mand, $type, $dsttype, $key) = $type =~ /^(.)(.)([@@%]?)$/;

    # Check if there is an option argument available.
    if ( defined $optarg ? ($optarg eq '') 
	 : !(defined $rest || @@ARGV > 0) ) {
	# Complain if this option needs an argument.
	if ( $mand eq "=" ) {
	    return (0) if $passthrough;
	    warn ("Option ", $opt, " requires an argument\n");
	    $error++;
	    undef $opt;
	}
	if ( $mand eq ":" ) {
	    $arg = $type eq "s" ? '' : 0;
	}
	return (1, $opt,$arg,$dsttype,$incr,$key);
    }

    # Get (possibly optional) argument.
    $arg = (defined $rest ? $rest
	    : (defined $optarg ? $optarg : shift (@@ARGV)));

    # Get key if this is a "name=value" pair for a hash option.
    $key = undef;
    if ($dsttype eq '%' && defined $arg) {
	($key, $arg) = ($arg =~ /^(.*)=(.*)$/s) ? ($1, $2) : ($arg, 1);
    }

    #### Check if the argument is valid for this option ####

    if ( $type eq "s" ) {	# string
	# A mandatory string takes anything. 
	return (1, $opt,$arg,$dsttype,$incr,$key) if $mand eq "=";

	# An optional string takes almost anything. 
	return (1, $opt,$arg,$dsttype,$incr,$key) 
	  if defined $optarg || defined $rest;
	return (1, $opt,$arg,$dsttype,$incr,$key) if $arg eq "-"; # ??

	# Check for option or option list terminator.
	if ($arg eq $argend ||
	    $arg =~ /^$prefix.+/) {
	    # Push back.
	    unshift (@@ARGV, $arg);
	    # Supply empty value.
	    $arg = '';
	}
    }

    elsif ( $type eq "n" || $type eq "i" ) { # numeric/integer
	if ( $bundling && defined $rest && $rest =~ /^(-?[0-9]+)(.*)$/s ) {
	    $arg = $1;
	    $rest = $2;
	    unshift (@@ARGV, $starter.$rest) if defined $rest && $rest ne '';
	}
	elsif ( $arg !~ /^-?[0-9]+$/ ) {
	    if ( defined $optarg || $mand eq "=" ) {
		if ( $passthrough ) {
		    unshift (@@ARGV, defined $rest ? $starter.$rest : $arg)
		      unless defined $optarg;
		    return (0);
		}
		warn ("Value \"", $arg, "\" invalid for option ",
		      $opt, " (number expected)\n");
		$error++;
		undef $opt;
		# Push back.
		unshift (@@ARGV, $starter.$rest) if defined $rest;
	    }
	    else {
		# Push back.
		unshift (@@ARGV, defined $rest ? $starter.$rest : $arg);
		# Supply default value.
		$arg = 0;
	    }
	}
    }

    elsif ( $type eq "f" ) { # real number, int is also ok
	# We require at least one digit before a point or 'e',
	# and at least one digit following the point and 'e'.
	# [-]NN[.NN][eNN]
	if ( $bundling && defined $rest &&
	     $rest =~ /^(-?[0-9]+(\.[0-9]+)?([eE]-?[0-9]+)?)(.*)$/s ) {
	    $arg = $1;
	    $rest = $+;
	    unshift (@@ARGV, $starter.$rest) if defined $rest && $rest ne '';
	}
	elsif ( $arg !~ /^-?[0-9.]+(\.[0-9]+)?([eE]-?[0-9]+)?$/ ) {
	    if ( defined $optarg || $mand eq "=" ) {
		if ( $passthrough ) {
		    unshift (@@ARGV, defined $rest ? $starter.$rest : $arg)
		      unless defined $optarg;
		    return (0);
		}
		warn ("Value \"", $arg, "\" invalid for option ",
		      $opt, " (real number expected)\n");
		$error++;
		undef $opt;
		# Push back.
		unshift (@@ARGV, $starter.$rest) if defined $rest;
	    }
	    else {
		# Push back.
		unshift (@@ARGV, defined $rest ? $starter.$rest : $arg);
		# Supply default value.
		$arg = 0.0;
	    }
	}
    }
    else {
	Croak ("GetOpt::Long internal error (Can't happen)\n");
    }
    return (1, $opt, $arg, $dsttype, $incr, $key);
}

# Getopt::Long Configuration.
sub Configure (@@) {
    my (@@options) = @@_;
    my $opt;
    foreach $opt ( @@options ) {
	my $try = lc ($opt);
	my $action = 1;
	if ( $try =~ /^no_?(.*)$/s ) {
	    $action = 0;
	    $try = $+;
	}
	if ( $try eq 'default' or $try eq 'defaults' ) {
	    ConfigDefaults () if $action;
	}
	elsif ( $try eq 'auto_abbrev' or $try eq 'autoabbrev' ) {
	    $autoabbrev = $action;
	}
	elsif ( $try eq 'getopt_compat' ) {
	    $getopt_compat = $action;
	}
	elsif ( $try eq 'ignorecase' or $try eq 'ignore_case' ) {
	    $ignorecase = $action;
	}
	elsif ( $try eq 'ignore_case_always' ) {
	    $ignorecase = $action ? 2 : 0;
	}
	elsif ( $try eq 'bundling' ) {
	    $bundling = $action;
	}
	elsif ( $try eq 'bundling_override' ) {
	    $bundling = $action ? 2 : 0;
	}
	elsif ( $try eq 'require_order' ) {
	    $order = $action ? $REQUIRE_ORDER : $PERMUTE;
	}
	elsif ( $try eq 'permute' ) {
	    $order = $action ? $PERMUTE : $REQUIRE_ORDER;
	}
	elsif ( $try eq 'pass_through' or $try eq 'passthrough' ) {
	    $passthrough = $action;
	}
	elsif ( $try =~ /^prefix=(.+)$/ ) {
	    $genprefix = $1;
	    # Turn into regexp. Needs to be parenthesized!
	    $genprefix = "(" . quotemeta($genprefix) . ")";
	    eval { '' =~ /$genprefix/; };
	    Croak ("Getopt::Long: invalid pattern \"$genprefix\"") if $@@;
	}
	elsif ( $try =~ /^prefix_pattern=(.+)$/ ) {
	    $genprefix = $1;
	    # Parenthesize if needed.
	    $genprefix = "(" . $genprefix . ")" 
	      unless $genprefix =~ /^\(.*\)$/;
	    eval { '' =~ /$genprefix/; };
	    Croak ("Getopt::Long: invalid pattern \"$genprefix\"") if $@@;
	}
	elsif ( $try eq 'debug' ) {
	    $debug = $action;
	}
	else {
	    Croak ("Getopt::Long: unknown config parameter \"$opt\"")
	}
    }
}

# Deprecated name.
sub config (@@) {
    Configure (@@_);
}

# To prevent Carp from being loaded unnecessarily.
sub Croak (@@) {
    require 'Carp.pm';
    $Carp::CarpLevel = 1;
    Carp::croak(@@_);
};

################ Documentation ################

d35 3
a37 4
double dash "--". Support for bundling of command line options, as was
the case with the more traditional single-letter approach, is provided
but not enabled by default. For example, the UNIX "ps" command can be
given the command line "option"
d58 1
a58 1
  GetOptions("size=i" => \$offset);
d65 2
a66 3
a HASH describing the linkage for the options, or an object whose
class is based on a HASH. The following call is equivalent to the
example above:
d69 1
a69 1
  GetOptions(\%optctl, "size=i");
d80 1
a80 1
followed by an argument specifier.
d82 1
a82 2
Options that do not take arguments will have no argument specifier. 
The option variable will be set to 1 if the option is used.
d84 1
a84 1
For the other options, the values for argument specifiers are:
d86 2
a87 1
=over 8
a95 9
=item +

Option does not take an argument and will be incremented by 1 every
time it appears on the command line. E.g. "more+", when used with
B<--more --more --more>, will set the option variable to 3 (provided
it was 0 or undefined at first).

The B<+> specifier is ignored if the option destination is not a SCALAR.

d153 1
a153 1
  GetOptions (\%optctl, "size=i");
d162 1
a162 1
  GetOptions (\%optctl, "sizes=i@@");
a168 11
For hash options (an option whose argument looks like "name=value"),
a reference to a hash is used, e.g.:

  %optctl = ();
  GetOptions (\%optctl, "define=s%");

with command line "--define foo=hello --define bar=world" will perform the
equivalent of the assignment

  $optctl{"define"} = {foo=>'hello', bar=>'world')

d178 1
a178 1
  GetOptions ("size=i", "sizes=i@@");
d190 1
a190 7
an array, a reference to a hash or a reference to a subroutine.

Note that, if your code is running under the recommended C<use strict
'vars'> pragma, it may be helpful to declare these package variables
via C<use vars> perhaps something like this:

  use vars qw/ $opt_size @@opt_sizes $opt_bar /;
a198 5
If a REF HASH is supplied, the option value should look like "key" or
"key=value" (if the "=value" is omitted then a value of 1 is implied).
In this case, the element of the referenced hash with the key "key"
is assigned "value". 

d207 2
a208 3
of this option. If no linkage is specified, options "foo", "bar" and
"blech" all will set $opt_foo. For convenience, the single character
"?" is allowed as an alias, e.g. "help|?".
d211 1
a211 1
configuration option B<auto_abbrev>.
d215 1
a215 1
A special option specifier, E<lt>E<gt>, can be used to designate a subroutine
d219 1
a219 3
This feature requires configuration option B<permute>, see section
CONFIGURATION OPTIONS.

d232 1
a232 8
=head2 Return values and Errors

Configuration errors and errors in the option definitions are
signalled using C<die()> and will terminate the calling
program unless the call to C<Getopt::Long::GetOptions()> was embedded
in C<eval { ... }> or C<die()> was trapped using C<$SIG{__DIE__}>.

A return value of 1 (true) indicates success.
d234 2
a235 5
A return status of 0 (false) indicates that the function detected one
or more errors during option parsing. These errors are signalled using
C<warn()> and can be trapped with C<$SIG{__WARN__}>.

Errors that can't happen are signalled using C<Carp::croak()>.
d245 7
a251 14
treated as an array. Value(s) are not set, but pushed into array
@@opt_name. If explicit linkage is supplied, this must be a reference
to an ARRAY.

If an "%" sign is appended to the argument specifier, the option is
treated as a hash. Value(s) of the form "name=value" are set by
setting the element of the hash %opt_name with key "name" to "value"
(if the "=value" portion is omitted it defaults to 1). If explicit
linkage is supplied, this must be a reference to a HASH.

If configuration option B<getopt_compat> is set (see section
CONFIGURATION OPTIONS), options that start with "+" or "-" may also
include their arguments, e.g. "+foo=bar". This is for compatiblity
with older implementations of the GNU "getopt" routine.
d284 1
a284 1
Example of using variable references:
d286 1
a286 1
   $ret = GetOptions ('foo=s', \$foo, 'bar=i', 'ar=s', \@@ar);
d291 1
a291 1
   $foo = 'blech'
d295 1
a295 1
Example of using the E<lt>E<gt> option specifier:
d298 1
a298 1
   GetOptions("foo=i", \$myfoo, "<>", \&mysub);
d302 2
a303 2
   mysub("bar") will be called (with $myfoo being 1)
   mysub("blech") will be called (with $myfoo being 2)
d308 1
a308 1
   GetOptions("foo=i", \$myfoo);
d315 37
a351 1
=head1 CONFIGURATION OPTIONS
d353 1
a353 11
B<GetOptions> can be configured by calling subroutine
B<Getopt::Long::Configure>. This subroutine takes a list of quoted
strings, each specifying a configuration option to be set, e.g.
B<ignore_case>. Options can be reset by prefixing with B<no_>, e.g.
B<no_ignore_case>. Case does not matter. Multiple calls to B<config>
are possible.

Previous versions of Getopt::Long used variables for the purpose of
configuring. Although manipulating these variables still work, it
is strongly encouraged to use the new B<config> routine. Besides, it
is much easier.
d355 2
a356 1
The following options are available:
d358 6
a363 1
=over 12
d365 1
a365 1
=item default
d367 1
a367 2
This option causes all configuration options to be reset to their
default values.
d369 1
a369 1
=item auto_abbrev
d371 1
a371 3
Allow option names to be abbreviated to uniqueness.
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case B<auto_abbrev> is reset.
d373 1
a373 1
=item getopt_compat   
d375 3
a377 3
Allow '+' to start options.
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case B<getopt_compat> is reset.
d379 1
a379 1
=item require_order
d381 2
a382 4
Whether non-options are allowed to be mixed with
options.
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case b<require_order> is reset.
d384 1
a384 1
See also B<permute>, which is the opposite of B<require_order>.
d386 2
a387 1
=item permute
d389 1
a389 5
Whether non-options are allowed to be mixed with
options.
Default is set unless environment variable
POSIXLY_CORRECT has been set, in which case B<permute> is reset.
Note that B<permute> is the opposite of B<require_order>.
d391 1
a391 1
If B<permute> is set, this means that 
d393 1
a393 1
    -foo arg1 -bar arg2 arg3
d395 1
a395 1
is equivalent to
d397 21
a417 1
    -foo -bar arg1 arg2 arg3
d419 12
a430 3
If a non-option call-back routine is specified, @@ARGV will always be
empty upon succesful return of GetOptions since all options have been
processed, except when B<--> is used:
d432 1
a432 1
    -foo arg1 -bar arg2 -- arg3
d434 20
a453 2
will call the call-back routine for arg1 and arg2, and terminate
leaving arg2 in @@ARGV.
d455 8
a462 2
If B<require_order> is set, options processing
terminates when the first non-option is encountered.
d464 1
a464 1
    -foo arg1 -bar arg2 arg3
d466 1
a466 1
is equivalent to
d468 24
a491 1
    -foo -- arg1 -bar arg2 arg3
d493 5
a497 1
=item bundling (default: reset)
d499 8
a506 4
Setting this variable to a non-zero value will allow single-character
options to be bundled. To distinguish bundles from long option names,
long options must be introduced with B<--> and single-character
options (and bundles) with B<->. For example,
d508 4
a511 1
    ps -vax --vax
d513 2
a514 1
would be equivalent to
d516 16
a531 1
    ps -v -a -x --vax
d533 7
a539 2
provided "vax", "v", "a" and "x" have been defined to be valid
options. 
d541 24
a564 3
Bundled options can also include a value in the bundle; for strings
this value is the rest of the bundle, but integer and floating values
may be combined in the bundle, e.g.
d566 16
a581 1
    scale -h24w80
d583 31
a613 1
is equivalent to
d615 2
a616 1
    scale -h 24 -w 80
d618 2
a619 1
Note: resetting B<bundling> also resets B<bundling_override>.
d621 9
a629 1
=item bundling_override (default: reset)
d631 3
a633 4
If B<bundling_override> is set, bundling is enabled as with
B<bundling> but now long option names override option bundles. In the
above example, B<-vax> would be interpreted as the option "vax", not
the bundle "v", "a", "x".
d635 2
a636 1
Note: resetting B<bundling_override> also resets B<bundling>.
d638 1
a638 2
B<Note:> Using option bundling can easily lead to unexpected results,
especially when mixing long options and bundles. Caveat emptor.
d640 1
a640 1
=item ignore_case  (default: set)
d642 5
a646 1
If set, case is ignored when matching options.
d648 1
a648 1
Note: resetting B<ignore_case> also resets B<ignore_case_always>.
d650 7
a656 1
=item ignore_case_always (default: reset)
d658 11
a668 2
When bundling is in effect, case is ignored on single-character
options also. 
d670 1
a670 1
Note: resetting B<ignore_case_always> also resets B<ignore_case>.
d672 12
a683 1
=item pass_through (default: reset)
d685 6
a690 4
Unknown options are passed through in @@ARGV instead of being flagged
as errors. This makes it possible to write wrapper scripts that
process only part of the user supplied options, and passes the
remaining options to some other program.
d692 1
a692 1
This can be very confusing, especially when B<permute> is also set.
d694 1
a694 1
=item prefix
d696 3
a698 1
The string that starts options. See also B<prefix_pattern>.
d700 14
a713 1
=item prefix_pattern
d715 7
a721 3
A Perl pattern that identifies the strings that introduce options.
Default is C<(--|-|\+)> unless environment variable
POSIXLY_CORRECT has been set, in which case it is C<(--|-)>.
d723 8
a730 1
=item debug (default: reset)
d732 1
a732 1
Enable copious debugging output.
d734 15
a748 1
=back
d750 17
a766 1
=head1 OTHER USEFUL VARIABLES
d768 2
a769 1
=over 12
d771 1
a771 1
=item $Getopt::Long::VERSION
d773 18
a790 3
The version number of this Getopt::Long implementation in the format
C<major>.C<minor>. This can be used to have Exporter check the
version, e.g.
d792 17
a808 1
    use Getopt::Long 3.00;
d810 17
a826 2
You can inspect $Getopt::Long::major_version and
$Getopt::Long::minor_version for the individual components.
d828 2
a829 1
=item $Getopt::Long::error
d831 3
a833 2
Internal error flag. May be incremented from a call-back routine to
cause options parsing to fail.
d835 3
a837 1
=back
d839 39
a877 1
=head1 AUTHOR
d879 5
a883 1
Johan Vromans E<lt>jvromans@@squirrel.nlE<gt>
d885 2
a886 1
=head1 COPYRIGHT AND DISCLAIMER
d888 1
a888 14
This program is Copyright 1990,1999 by Johan Vromans.
This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

If you do not have a copy of the GNU General Public License write to
the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, 
MA 02139, USA.
d890 2
a891 1
=cut
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pl,v 2.24 2000-03-14 21:28:52+01 jv Exp $
d9 2
a10 2
# Last Modified On: Tue Mar 14 21:28:40 2000
# Update Count    : 721
d15 1
a15 1
# This program is Copyright 1990,2000 by Johan Vromans.
d17 4
a20 5
# modify it under the terms of the Perl Artistic License or the
# GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any
# later version.
#
d25 1
a25 1
#
d27 1
a27 1
# the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
d38 1
a38 1
    $VERSION     = "2.23";
d54 1
a54 1
use vars qw($genprefix $caller);
d56 1
a56 1
# Public subroutines.
d61 1
a61 1
# Private subroutines.
d100 2
a101 1
ConfigDefaults();
d111 1
a111 1
# RCS Status      : $Id: GetoptLongAl.pl,v 2.27 2000-03-17 09:07:26+01 jv Exp $
d115 2
a116 2
# Last Modified On: Fri Mar 17 09:00:09 2000
# Update Count    : 55
d125 1
a125 1
    my $pkg = $caller || (caller)[0];	# current context
d140 1
a140 1
		  'GetOptionsAl $Revision: 2.27 $ ',
d155 1
a155 1
    # Check for ref HASH as first argument.
d157 1
a157 1
    # as it is really a hash underneath.
d167 1
a167 5
    # Be careful not to interpret '<>' as option starters.
    if ( $optionlist[0] =~ /^\W+$/
	 && !($optionlist[0] eq '<>'
	      && @@optionlist > 0
	      && ref($optionlist[1])) ) {
d190 1
a190 1
	    unless ( @@optionlist > 0
d218 1
a218 1
		if $ignorecase > 1
d228 1
a228 4
			$opctl{$_} = $bopctl{$_} = '';
		    }
		    else {
			$opctl{$_} = $bopctl{$_} = $c;
d230 1
d236 1
a236 4
			$opctl{$_} = ''
		    }
		    else {
			$opctl{$_} = $c;
d238 1
d281 1
a281 1
		  if $bundling and defined $bopctl{$o} and
d289 1
a289 1
		  if $bundling and defined $bopctl{$o} and
d342 1
a342 2
    my $goon = 1;
    while ( $goon && @@ARGV > 0 ) {
d354 1
a354 1
	    unshift (@@ARGV, @@ret)
d362 1
a362 1
	my $incr;		# destination increment
d366 2
a367 2
	($found, $opt, $arg, $dsttype, $incr, $key) =
	  FindOption ($genprefix, $argend, $opt,
d371 1
a371 1

d412 1
a412 14
			local ($@@);
			eval {
			    &{$linkage{$opt}}($opt, $arg);
			};
			print STDERR ("=> die($@@)\n") if $debug && $@@ ne '';
			if ( $@@ =~ /^!/ ) {
			    if ( $@@ =~ /^!FINISH\b/ ) {
				$goon = 0;
			    }
			}
			elsif ( $@@ ne '' ) {
			    warn ($@@);
			    $error++;
			}
d469 1
a469 14
		local ($@@);
		eval {
		    &$cb ($tryopt);
		};
		print STDERR ("=> die($@@)\n") if $debug && $@@ ne '';
		if ( $@@ =~ /^!/ ) {
		    if ( $@@ =~ /^!FINISH\b/ ) {
			$goon = 0;
		    }
		}
		elsif ( $@@ ne '' ) {
		    warn ($@@);
		    $error++;
		}
d526 1
a526 1
	print STDERR ("=> option \"", $opt,
d557 1
a557 1
    }
d643 1
a643 1
    if ( defined $optarg ? ($optarg eq '')
d665 1
a665 1
	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2) : ($arg, 1);
d671 1
a671 1
	# A mandatory string takes anything.
d674 2
a675 2
	# An optional string takes almost anything.
	return (1, $opt,$arg,$dsttype,$incr,$key)
d690 1
a690 1
	if ( $bundling && defined $rest && $rest =~ /^([-+]?[0-9]+)(.*)$/s ) {
d695 1
a695 1
	elsif ( $arg !~ /^[-+]?[0-9]+$/ ) {
d723 1
a723 1
	     $rest =~ /^([-+]?[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?)(.*)$/s ) {
d728 1
a728 1
	elsif ( $arg !~ /^[-+]?[0-9.]+(\.[0-9]+)?([eE][-+]?[0-9]+)?$/ ) {
a758 12

    my $prevconfig =
      [ $error, $debug, $major_version, $minor_version,
	$autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
	$passthrough, $genprefix ];

    if ( ref($options[0]) eq 'ARRAY' ) {
	( $error, $debug, $major_version, $minor_version,
	  $autoabbrev, $getopt_compat, $ignorecase, $bundling, $order,
	  $passthrough, $genprefix ) = @@{shift(@@options)};
    }

d807 1
a807 1
	    $genprefix = "(" . $genprefix . ")"
a818 1
    $prevconfig;
d837 1
a837 1
Getopt::Long - Extended processing of command line options
d852 2
a853 185
but not enabled by default.

=head1 Command Line Options, an Introduction

Command line operated programs traditionally take their arguments from
the command line, for example filenames or other information that the
program needs to know. Besides arguments, these programs often take
command line I<options> as well. Options are not necessary for the
program to work, hence the name 'option', but are used to modify its
default behaviour. For example, a program could do its job quietly,
but with a suitable option it could provide verbose information about
what it did.

Command line options come in several flavours. Historically, they are
preceded by a single dash C<->, and consist of a single letter.

    -l -a -c

Usually, these single-character options can be bundled:

    -lac

Options can have values, the value is placed after the option
character. Sometimes with whitespace in between, sometimes not:

    -s 24 -s24

Due to the very cryptic nature of these options, another style was
developed that used long names. So instead of a cryptic C<-l> one
could use the more descriptive C<--long>. To distinguish between a
bundle of single-character options and a long one, two dashes are used
to precede the option name. Early implementations of long options used
a plus C<+> instead. Also, option values could be specified either
like 

    --size=24

or

    --size 24

The C<+> form is now obsolete and strongly deprecated.

=head1 Getting Started with Getopt::Long

Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was
the firs Perl module that provided support for handling the new style
of command line options, hence the name Getopt::Long. This module
also supports single-character options and bundling. In this case, the
options are restricted to alphabetic characters only, and the
characters C<?> and C<->.

To use Getopt::Long from a Perl program, you must include the
following line in your Perl program:

    use Getopt::Long;

This will load the core of the Getopt::Long module and prepare your
program for using it. Most of the actual Getopt::Long code is not
loaded until you really call one of its functions.

In the default configuration, options names may be abbreviated to
uniqueness, case does not matter, and a single dash is sufficient,
even for long option names. Also, options may be placed between
non-option arguments. See L<Configuring Getopt::Long> for more
details on how to configure Getopt::Long.

=head2 Simple options

The most simple options are the ones that take no values. Their mere
presence on the command line enables the option. Popular examples are:

    --all --verbose --quiet --debug

Handling simple options is straightforward:

    my $verbose = '';	# option variable with default value (false)
    my $all = '';	# option variable with default value (false)
    GetOptions ('verbose' => \$verbose, 'all' => \$all);

The call to GetOptions() parses the command line arguments that are
present in C<@@ARGV> and sets the option variable to the value C<1> if
the option did occur on the command line. Otherwise, the option
variable is not touched. Setting the option value to true is often
called I<enabling> the option.

The option name as specified to the GetOptions() function is called
the option I<specification>. Later we'll see that this specification
can contain more than just the option name. The reference to the
variable is called the option I<destination>.

GetOptions() will return a true value if the command line could be
processed successfully. Otherwise, it will write error messages to
STDERR, and return a false result.

=head2 A little bit less simple options

Getopt::Long supports two useful variants of simple options:
I<negatable> options and I<incremental> options.

A negatable option is specified with a exclamation mark C<!> after the
option name:

    my $verbose = '';	# option variable with default value (false)
    GetOptions ('verbose!' => \$verbose);

Now, using C<--verbose> on the command line will enable C<$verbose>,
as expected. But it is also allowed to use C<--noverbose>, which will
disable C<$verbose> by setting its value to C<0>. Using a suitable
default value, the program can find out whether C<$verbose> is false
by default, or disabled by using C<--noverbose>.

An incremental option is specified with a plus C<+> after the
option name:

    my $verbose = '';	# option variable with default value (false)
    GetOptions ('verbose+' => \$verbose);

Using C<--verbose> on the command line will increment the value of
C<$verbose>. This way the program can keep track of how many times the
option occurred on the command line. For example, each occurrence of
C<--verbose> could increase the verbosity level of the program.

=head2 Mixing command line option with other arguments

Usually programs take command line options as well as other arguments,
for example, file names. It is good practice to always specify the
options first, and the other arguments last. Getopt::Long will,
however, allow the options and arguments to be mixed and 'filter out'
all the options before passing the rest of the arguments to the
program. To stop Getopt::Long from processing further arguments,
insert a double dash C<--> on the command line:

    --size 24 -- --all

In this example, C<--all> will I<not> be treated as an option, but
passed to the program unharmed, in C<@@ARGV>.

=head2 Options with values

For options that take values it must be specified whether the option
value is required or not, and what kind of value the option expects.

Three kinds of values are supported: integer numbers, floating point
numbers, and strings.

If the option value is required, Getopt::Long will take the
command line argument that follows the option and assign this to the
option variable. If, however, the option value is specified as
optional, this will only be done if that value does not look like a
valid command line option itself.

    my $tag = '';	# option variable with default value
    GetOptions ('tag=s' => \$tag);

In the option specification, the option name is followed by an equals
sign C<=> and the letter C<s>. The equals sign indicates that this
option requires a value. The letter C<s> indicates that this value is
an arbitrary string. Other possible value types are C<i> for integer
values, and C<f> for floating point values. Using a colon C<:> instead
of the equals sign indicates that the option value is optional. In
this case, if no suitable value is supplied, string valued options get
an empty string C<''> assigned, while numeric options are set to C<0>.

=head2 Options with multiple values

Options sometimes take several values. For example, a program could
use multiple directories to search for library files:

    --library lib/stdlib --library lib/extlib

To accomplish this behaviour, simply specify an array reference as the
destination for the option:

    my @@libfiles = ();
    GetOptions ("library=s" => \@@libfiles);

Used with the example above, C<@@libfiles> would contain two strings
upon completion: C<"lib/srdlib"> and C<"lib/extlib">, in that order.
It is also possible to specify that only integer or floating point
numbers are acceptible values.

Often it is useful to allow comma-separated lists of values as well as
multiple occurrences of the options. This is easy using Perl's split()
and join() operators:
d855 1
a855 3
    my @@libfiles = ();
    GetOptions ("library=s" => \@@libfiles);
    @@libfiles = split(/,/,join(',',@@libfiles));
d857 3
a859 2
Of course, it is important to choose the right separator string for
each purpose.
d861 2
a862 1
=head2 Options with hash values
d864 2
a865 3
If the option destination is a reference to a hash, the option will
take, as value, strings of the form I<key>C<=>I<value>. The value will
be stored with the specified key in the hash.
d867 6
a872 2
    my %defines = ();
    GetOptions ("define=s" => \%defines);
d874 1
a874 1
When used with command line options:
d876 3
a878 1
    --define os=linux --define vendor=redhat
d880 4
a883 4
the hash C<%defines> will contain two keys, C<"os"> with value
C<"linux> and C<"vendor"> with value C<"redhat">.
It is also possible to specify that only integer or floating point
numbers are acceptible values. The keys are always taken to be strings.
d885 2
a886 1
=head2 User-defined subroutines to handle options
d888 3
a890 7
Ultimate control over what should be done when (actually: each time)
an option is encountered on the command line can be achieved by
designating a reference to a subroutine (or an anonymous subroutine)
as the option destination. When GetOptions() encounters the option, it
will call the subroutine with two arguments: the name of the option,
and the value to be assigned. It is up to the subroutine to store the
value, or do whatever it thinks is appropriate.
d892 6
a897 2
A trivial application of this mechanism is to implement options that
are related to each other. For example:
d899 2
a900 3
    my $verbose = '';	# option variable with default value (false)
    GetOptions ('verbose' => \$verbose,
	        'quiet'   => sub { $verbose = 0 });
d902 1
a902 2
Here C<--verbose> and C<--quiet> control the same variable
C<$verbose>, but with opposite values.
d904 1
a904 54
If the subroutine needs to signal an error, it should call die() with
the desired error message as its argument. GetOptions() will catch the
die(), issue the error message, and record that an error result must
be returned upon completion.

If the text of the error message starts with an exclamantion mark C<!>
it is interpreted specially by GetOptions(). There is currently one
special command implemented: C<die("!FINISH")> will cause GetOptions()
to stop processing options, as if it encountered a double dash C<-->.

=head2 Options with multiple names

Often it is user friendly to supply alternate mnemonic names for
options. For example C<--height> could be an alternate name for
C<--length>. Alternate names can be included in the option
specification, separated by vertical bar C<|> characters. To implement
the above example:

    GetOptions ('length|height=f' => \$length);

The first name is called the I<primary> name, the other names are
called I<aliases>.

Multiple alternate names are possible.

=head2 Case and abbreviations

Without additional configuration, GetOptions() will ignore the case of
option names, and allow the options to be abbreviated to uniqueness.

    GetOptions ('length|height=f' => \$length, "head" => \$head);

This call will allow C<--l> and C<--L> for the length option, but
requires a least C<--hea> and C<--hei> for the head and height options.

=head2 Summary of Option Specifications

Each option specifier consists of two parts: the name specification
and the argument specification. 

The name specification contains the name of the option, optionally
followed by a list of alternative names separated by vertical bar
characters. 

    length	      option name is "length"
    length|size|l     name is "length", aliases are "size" and "l"

The argument specification is optional. If omitted, the option is
considered boolean, a value of 1 will be assigned when the option is
used on the command line.

The argument specification can be

=over
d908 4
a911 7
The option does not take an argument and may be negated, i.e. prefixed
by "no". E.g. C<"foo!"> will allow C<--foo> (a value of 1 will be
assigned) and C<--nofoo> (a value of 0 will be assigned). If the
option has aliases, this applies to the aliases as well.

Using negation on a single letter option when bundling is in effect is
pointless and will result in a warning.
d915 4
a918 4
The option does not take an argument and will be incremented by 1
every time it appears on the command line. E.g. C<"more+">, when used
with C<--more --more --more>, will increment the value three times,
resulting in a value of 3 (provided it was 0 or undefined at first).
d920 1
a920 1
The C<+> specifier is ignored if the option destination is not a scalar.
d922 1
a922 1
=item = I<type> [ I<desttype> ]
d924 4
a927 2
The option requires an argument of the given type. Supported types
are:
d929 1
a929 1
=over
d931 5
a935 1
=item s
d937 1
a937 2
String. An arbitrary sequence of characters. It is valid for the
argument to start with C<-> or C<-->.
d939 4
a942 1
=item i
d944 1
a944 2
Integer. An optional leading plus or minus sign, followed by a
sequence of digits.
d946 5
a950 1
=item f
d952 1
a952 1
Real number. For example C<3.14>, C<-6.23E24> and so on.
d954 4
a957 1
=back
d959 1
a959 10
The I<desttype> can be C<@@> or C<%> to specify that the option is
list or a hash valued. This is only needed when the destination for
the option value is not otherwise specified. It should be omitted when
not needed.

=item : I<type> [ I<desttype> ]

Like C<=>, but designates the argument as optional.
If omitted, an empty string will be assigned to string values options,
and the value zero to numeric options.
d961 3
a963 2
Note that if a string argument starts with C<-> or C<-->, it will be
considered an option on itself.
d967 2
a968 1
=head1 Advanced Possibilities
d970 1
a970 1
=head2 Documentation and help texts
d972 1
a972 2
Getopt::Long encourages the use of Pod::Usage to produce help
messages. For example:
d974 3
a976 2
    use Getopt::Long;
    use Pod::Usage;
d978 2
a979 2
    my $man = 0;
    my $help = 0;
d981 1
a981 3
    GetOptions('help|?' => \$help, man => \$man) or pod2usage(2);
    pod2usage(1) if $help;
    pod2usage(-exitstatus => 0, -verbose => 2) if $man;
d983 1
a983 1
    __END__
d985 1
a985 1
    =head1 NAME
d987 2
a988 1
    sample - Using GetOpt::Long and Pod::Usage
d990 2
a991 1
    =head1 SYNOPSIS
d993 1
a993 1
    sample [options] [file ...]
d995 2
a996 3
     Options:
       -help            brief help message
       -man             full documentation
d998 2
a999 1
    =head1 OPTIONS
d1001 2
a1002 1
    =over 8
d1004 10
a1013 1
    =item B<-help>
d1015 1
a1015 1
    Print a brief help message and exits.
d1017 2
a1018 1
    =item B<-man>
d1020 2
a1021 1
    Prints the manual page and exits.
d1023 2
a1024 1
    =back
d1026 2
a1027 1
    =head1 DESCRIPTION
d1029 3
a1031 2
    B<This program> will read the given input file(s) and do someting
    useful with the contents thereof.
d1033 1
a1033 1
    =cut
d1035 3
a1037 1
See L<Pod::Usage> for details.
d1039 2
a1040 1
=head2 Storing options in a hash
d1042 4
a1045 3
Sometimes, for example when there are a lot of options, having a
separate variable for each of them can be cumbersome. GetOptions()
supports, as an alternative mechanism, storing options in a hash.
d1047 3
a1049 9
To obtain this, a reference to a hash must be passed I<as the first
argument> to GetOptions(). For each option that is specified on the
command line, the option value will be stored in the hash with the
option name as key. Options that are not actually used on the command
line will not be put in the hash, on other words,
C<exists($h{option})> (or defined()) can be used to test if an option
was used. The drawback is that warnings will be issued if the program
runs under C<use strict> and uses C<$h{option}> without testing with
exists() or defined() first.
d1051 1
a1051 2
    my %h = ();
    GetOptions (\%h, 'length=i');	# will store in $h{length}
d1053 5
a1057 2
For options that take list or hash values, it is necessary to indicate
this by appending an C<@@> or C<%> sign after the type:
d1059 2
a1060 1
    GetOptions (\%h, 'colours=s@@');	# will push to @@{$h{colours}}
d1062 1
a1062 2
To make things more complicated, the hash may contain references to
the actual destinations, for example:
d1064 6
a1069 3
    my $len = 0;
    my %h = ('length' => \$len);
    GetOptions (\%h, 'length=i');	# will store in $len
d1071 1
a1071 1
This example is fully equivalent with:
d1073 1
a1073 2
    my $len = 0;
    GetOptions ('length=i' => \$len);	# will store in $len
d1075 4
a1078 3
Any mixture is possible. For example, the most frequently used options
could be stored in variables while all other options get stored in the
hash:
d1080 2
a1081 6
    my $verbose = 0;			# frequently referred
    my $debug = 0;			# frequently referred
    my %h = ('verbose' => \$verbose, 'debug' => \$debug);
    GetOptions (\%h, 'verbose', 'debug', 'filter', 'size=i');
    if ( $verbose ) { ... }
    if ( exists $h{filter} ) { ... option 'filter' was specified ... }
d1083 1
a1083 1
=head2 Bundling
d1085 4
a1088 2
With bundling it is possible to set several single-character options
at once. For example if C<a>, C<v> and C<x> are all valid options,
d1090 1
a1090 1
    -vax
d1092 3
a1094 1
would set all three.
d1096 1
a1096 2
Getopt::Long supports two levels of bundling. To enable bundling, a
call to Getopt::Long::Configure is required.
d1098 1
a1098 1
The first level of bundling can be enabled with:
d1100 4
a1103 1
    Getopt::Long::Configure ("bundling");
d1105 4
a1108 4
Configured this way, single-character options can be bundled but long
options B<must> always start with a double dash C<--> to avoid
abiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
options,
d1110 5
a1114 1
    -vax
d1116 4
a1119 1
would set C<a>, C<v> and C<x>, but 
d1121 5
a1125 1
    --vax
d1127 2
a1128 1
would set C<vax>.
d1130 1
a1130 2
The second level of bundling lifts this restriction. It can be enabled
with:
d1132 1
a1132 1
    Getopt::Long::Configure ("bundling_override");
d1134 2
a1135 1
Now, C<-vax> would set the option C<vax>.
d1137 2
a1138 2
When any level of bundling is enabled, option values may be inserted
in the bundle. For example:
d1140 1
a1140 1
    -h24w80
d1142 3
a1144 1
is equivalent to
d1146 1
a1146 1
    -h 24 -w 80
d1148 3
a1150 4
When configured for bundling, single-character options are matched
case sensitive while long options are matched case insensitive. To
have the single-character options matched case insensitive as well,
use:
d1152 1
a1152 1
    Getopt::Long::Configure ("bundling", "ignorecase_always");
d1154 1
a1154 1
It goes without saying that bundling can be quite confusing.
d1156 2
a1157 1
=head2 The lonesome dash
d1159 3
a1161 2
Some applications require the option C<-> (that's a lone dash). This
can be achieved by adding an option specification with an empty name:
d1163 1
a1163 1
    GetOptions ('' => \$stdio);
d1165 2
a1166 2
A lone dash on the command line will now be legal, and set options
variable C<$stdio>.
d1168 1
a1168 1
=head2 Argument call-back
d1170 2
a1171 4
A special option 'name' C<<>> can be used to designate a subroutine
to handle non-option arguments. When GetOptions() encounters an
argument that does not look like an option, it will immediately call this
subroutine and passes it the argument as a parameter.
d1173 1
a1173 1
For example:
d1175 2
a1176 12
    my $width = 80;
    sub process { ... }
    GetOptions ('width=i' => \$width, '<>' => \&process);

When applied to the following command line:

    arg1 --width=72 arg2 --width=60 arg3

This will call 
C<process("arg1")> while C<$width> is C<80>, 
C<process("arg2")> while C<$width> is C<72>, and
C<process("arg3")> while C<$width> is C<60>.
d1178 1
a1178 2
This feature requires configuration option B<permute>, see section
L<Configuring Getopt::Long>.
d1180 2
d1183 1
a1183 1
=head1 Configuring Getopt::Long
d1185 2
a1186 2
Getopt::Long can be configured by calling subroutine
Getopt::Long::Configure(). This subroutine takes a list of quoted
d1188 8
a1195 2
C<ignore_case>, or reset, e.g. C<no_ignore_case>. Case does not
matter. Multiple calls to Configure() are possible.
d1210 1
a1210 1
POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is reset.
d1212 1
a1212 1
=item getopt_compat
d1214 1
a1214 1
Allow C<+> to start options.
d1216 1
a1216 1
POSIXLY_CORRECT has been set, in which case C<getopt_compat> is reset.
d1220 2
a1221 1
Whether command line arguments are allowed to be mixed with options.
d1223 1
a1223 1
POSIXLY_CORRECT has been set, in which case C<require_order> is reset.
d1225 1
a1225 1
See also C<permute>, which is the opposite of C<require_order>.
d1229 2
a1230 1
Whether command line arguments are allowed to be mixed with options.
d1232 2
a1233 2
POSIXLY_CORRECT has been set, in which case C<permute> is reset.
Note that C<permute> is the opposite of C<require_order>.
d1235 1
a1235 1
If C<permute> is set, this means that 
d1237 1
a1237 1
    --foo arg1 --bar arg2 arg3
d1241 1
a1241 1
    --foo --bar arg1 arg2 arg3
d1243 3
a1245 3
If an argument call-back routine is specified, C<@@ARGV> will always be
empty upon succesful return of GetOptions() since all options have been
processed. The only exception is when C<--> is used:
d1247 1
a1247 1
    --foo arg1 --bar arg2 -- arg3
d1250 1
a1250 1
GetOptions() leaving C<"arg2"> in C<@@ARGV>.
d1252 1
a1252 1
If C<require_order> is set, options processing
d1255 1
a1255 1
    --foo arg1 --bar arg2 arg3
d1259 1
a1259 1
    --foo -- arg1 --bar arg2 arg3
d1263 10
a1272 4
Setting this option will allow single-character options to be bundled.
To distinguish bundles from long option names, long options I<must> be
introduced with C<--> and single-character options (and bundles) with
C<->.
d1274 14
a1287 1
Note: resetting C<bundling> also resets C<bundling_override>.
d1291 4
a1294 2
If C<bundling_override> is set, bundling is enabled as with
C<bundling> but now long option names override option bundles. 
d1296 1
a1296 1
Note: resetting C<bundling_override> also resets C<bundling>.
d1303 1
a1303 2
If set, case is ignored when matching long option names. Single
character options will be treated case-sensitive.
d1305 1
a1305 1
Note: resetting C<ignore_case> also resets C<ignore_case_always>.
d1312 1
a1312 1
Note: resetting C<ignore_case_always> also resets C<ignore_case>.
d1316 3
a1318 4
Options that are unknown, ambiguous or supplied with an invalid option
value are passed through in C<@@ARGV> instead of being flagged as
errors. This makes it possible to write wrapper scripts that process
only part of the user supplied command line arguments, and pass the
d1321 1
a1321 1
This can be very confusing, especially when C<permute> is also set.
d1325 1
a1325 2
The string that starts options. If a constant string is not
sufficient, see C<prefix_pattern>.
d1339 1
a1339 1
=head1 Return values and Errors
d1341 1
a1341 4
Configuration errors and errors in the option definitions are
signalled using die() and will terminate the calling program unless
the call to Getopt::Long::GetOptions() was embedded in C<eval { ...
}>, or die() was trapped using C<$SIG{__DIE__}>.
d1343 1
a1343 1
A return value of 1 (true) indicates success.
d1345 3
a1347 3
A return status of 0 (false) indicates that the function detected one
or more errors during option parsing. These errors are signalled using
warn() and can be trapped with C<$SIG{__WARN__}>.
d1349 1
a1349 1
Errors that can't happen are signalled using Carp::croak().
d1351 2
a1352 1
=head1 Legacy
d1354 1
a1354 25
The earliest development of C<newgetopt.pl> started in 1990, with Perl
version 4. As a result, its development, and the development of
Getopt::Long, has gone through several stages. Since backward
compatibility has always been extremely important, the current version
of Getopt::Long still supports a lot of constructs that nowadays are
no longer necessary or otherwise unwanted. This section describes
briefly some of these 'features'.

=head2 Default destinations

When no destination is specified for an option, GetOptions will store
the resultant value in a global variable named C<opt_>I<XXX>, where
I<XXX> is the primary name of this option. When a progam executes
under C<use strict> (recommended), these variables must be
pre-declared with our() or C<use vars>.

    our $opt_length = 0;
    GetOptions ('length=i');	# will store in $opt_length

To yield a usable Perl variable, characters that are not part of the
syntax for variables are translated to underscores. For example,
C<--fpp-struct-return> will set the variable
C<$opt_fpp_struct_return>. Note that this variable resides in the
namespace of the calling program, not necessarily C<main>. For
example:
d1356 2
a1357 1
    GetOptions ("size=i", "sizes=i@@");
d1359 1
a1359 33
with command line "-size 10 -sizes 24 -sizes 48" will perform the
equivalent of the assignments

    $opt_size = 10;
    @@opt_sizes = (24, 48);

=head2 Alternative option starters

A string of alternative option starter characters may be passed as the
first argument (or the first argument after a leading hash reference
argument).

    my $len = 0;
    GetOptions ('/', 'length=i' => $len);

Now the command line may look like:

    /length 24 -- arg

Note that to terminate options processing still requires a double dash
C<-->.

GetOptions() will not interpret a leading C<"<>"> as option starters
if the next argument is a reference. To force C<"<"> and C<">"> as
option starters, use C<"><">. Confusing? Well, B<using a starter
argument is strongly deprecated> anyway.

=head2 Configuration variables

Previous versions of Getopt::Long used variables for the purpose of
configuring. Although manipulating these variables still work, it
is strongly encouraged to use the new C<config> routine. Besides, it
is much easier.
d1367 1
a1367 1
This program is Copyright 2000,1990 by Johan Vromans.
d1369 3
a1371 4
modify it under the terms of the Perl Artistic License or the
GNU General Public License as published by the Free Software
Foundation; either version 2 of the License, or (at your option) any
later version.
a1382 5

# Local Variables:
# mode: perl
# eval: (load-file "pod.el")
# End:
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pl,v 2.26 2001-01-31 10:20:29+01 jv Exp $
d9 2
a10 2
# Last Modified On: Sat Jan  6 17:12:27 2001
# Update Count    : 748
d15 1
a15 1
# This program is Copyright 1990,2001 by Johan Vromans.
a32 2
use 5.004;

a34 10
use vars qw($VERSION $VERSION_STRING);
$VERSION        =  2.25;
$VERSION_STRING = "2.25";

use Exporter;
use AutoLoader qw(AUTOLOAD);

use vars qw(@@ISA @@EXPORT @@EXPORT_OK %EXPORT_TAGS);
@@ISA = qw(Exporter);
%EXPORT_TAGS = qw();
d36 6
a41 1
    # Init immediately so their contents can be used in the 'use vars' below.
d43 1
d45 1
d55 1
a55 1
use vars qw($genprefix $caller $gnu_compat);
a91 21
    $gnu_compat = 0;		# require --opt=val if value is optional
}

# Override import.
sub import {
    my $pkg = shift;		# package
    my @@syms = ();		# symbols to import
    my @@config = ();		# configuration
    my $dest = \@@syms;		# symbols first
    for ( @@_ ) {
	if ( $_ eq ':config' ) {
	    $dest = \@@config;	# config next
	    next;
	}
	push (@@$dest, $_);	# push
    }
    # Hide one level and call super.
    local $Exporter::ExportLevel = 1;
    $pkg->SUPER::import(@@syms);
    # And configure.
    Configure (@@config) if @@config;
a102 81
################ OO Interface ################

package Getopt::Long::Parser;

# NOTE: The object oriented routines use $error for thread locking.
my $_lock = sub {
    lock ($Getopt::Long::error) if $] >= 5.005
};

# Store a copy of the default configuration. Since ConfigDefaults has
# just been called, what we get from Configure is the default.
my $default_config = do {
    &$_lock;
    Getopt::Long::Configure ()
};

sub new {
    my $that = shift;
    my $class = ref($that) || $that;
    my %atts = @@_;

    # Register the callers package.
    my $self = { caller_pkg => (caller)[0] };

    bless ($self, $class);

    # Process config attributes.
    if ( defined $atts{config} ) {
	&$_lock;
	my $save = Getopt::Long::Configure ($default_config, @@{$atts{config}});
	$self->{settings} = Getopt::Long::Configure ($save);
	delete ($atts{config});
    }
    # Else use default config.
    else {
	$self->{settings} = $default_config;
    }

    if ( %atts ) {		# Oops
	Getopt::Long::Croak(__PACKAGE__.": unhandled attributes: ".
			    join(" ", sort(keys(%atts))));
    }

    $self;
}

sub configure {
    my ($self) = shift;

    &$_lock;

    # Restore settings, merge new settings in.
    my $save = Getopt::Long::Configure ($self->{settings}, @@_);

    # Restore orig config and save the new config.
    $self->{settings} = Configure ($save);
}

sub getoptions {
    my ($self) = shift;

    &$_lock;

    # Restore config settings.
    my $save = Getopt::Long::Configure ($self->{settings});

    # Call main routine.
    my $ret = 0;
    $Getopt::Long::caller = $self->{caller_pkg};
    eval { $ret = Getopt::Long::GetOptions (@@_); };

    # Restore saved settings.
    Getopt::Long::Configure ($save);

    # Handle errors and return value.
    die ($@@) if $@@;
    return $ret;
}

package Getopt::Long;

d111 1
a111 1
# RCS Status      : $Id: GetoptLongAl.pl,v 2.30 2001-01-31 10:21:11+01 jv Exp $
d115 2
a116 2
# Last Modified On: Tue Dec 26 18:01:16 2000
# Update Count    : 98
d140 1
a140 1
		  'GetOptionsAl $Revision: 2.30 $ ',
a146 1
		  "gnu_compat=$gnu_compat,",
d203 1
a203 1
	# Match option spec. Allow '?' as an alias only.
a210 8
	# $linko keeps track of the primary name the user specified.
	# This name will be used for the internal or external linkage.
	# In other words, if the user specifies "FoO|BaR", it will
	# match any case combinations of 'foo' and 'bar', but if a global
	# variable needs to be set, it will be $opt_FoO in the exact case
	# as specified.
	my $linko;

d213 1
a213 3
	    $linko = $o = '';
	    $opctl{''} = $c;
	    $bopctl{''} = $c if $bundling;
d218 1
a218 1
	    $linko = $o = $o[0];
d257 1
d264 3
a266 4
		if ( exists $userlinkage->{$linko} &&
		     ref($userlinkage->{$linko}) ) {
		    print STDERR ("=> found userlinkage for \"$linko\": ",
				  "$userlinkage->{$linko}\n")
d268 1
a268 1
		    unshift (@@optionlist, $userlinkage->{$linko});
d279 1
a279 1
	    print STDERR ("=> link \"$linko\" to $optionlist[0]\n")
d282 1
a282 1
		$linkage{$linko} = shift (@@optionlist);
d285 1
a285 1
		$linkage{$linko} = shift (@@optionlist);
d293 1
a293 1
		$linkage{$linko} = shift (@@optionlist);
d307 1
a307 1
	    my $ov = $linko;
d310 1
a310 1
		print STDERR ("=> link \"$linko\" to \@@$pkg","::opt_$ov\n")
d312 1
a312 1
		eval ("\$linkage{\$linko} = \\\@@".$pkg."::opt_$ov;");
d315 1
a315 1
		print STDERR ("=> link \"$linko\" to \%$pkg","::opt_$ov\n")
d317 1
a317 1
		eval ("\$linkage{\$linko} = \\\%".$pkg."::opt_$ov;");
d320 1
a320 1
		print STDERR ("=> link \"$linko\" to \$$pkg","::opt_$ov\n")
d322 1
a322 1
		eval ("\$linkage{\$linko} = \\\$".$pkg."::opt_$ov;");
d385 1
a385 5
		if ( defined $aliases{$opt} ) {
		    print STDERR ("=> alias \"$opt\" -> \"$aliases{$opt}\"\n")
		      if $debug;
		    $opt = $aliases{$opt};
		}
d546 1
a546 2
    return 0 unless $opt =~ /^$prefix(.*)$/s;
    return 0 if $opt eq "-" && !defined $opctl->{""};
d575 1
a575 1
	$rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : "";
d649 1
a649 1
    print STDERR ("=> found \"$type\" for \"", $opt, "\"\n") if $debug;
d678 1
a678 10
    if ( $gnu_compat ) {
	return (1, $opt, $optarg, $dsttype, $incr, $key)
	  if defined $optarg;
	return (1, $opt, $type eq "s" ? '' : 0, $dsttype, $incr, $key)
	  if $mand eq ':';
    }

    # Check if there is an option argument available.
    if ( defined $optarg
	 ? ($optarg eq '')
d687 4
a690 1
	return (1, $opt, $type eq "s" ? '' : 0, $dsttype, $incr, $key);
d798 1
a798 1
	$gnu_compat, $passthrough, $genprefix ];
d803 1
a803 1
	  $gnu_compat, $passthrough, $genprefix ) = @@{shift(@@options)};
d814 2
a815 7
	if ( ($try eq 'default' or $try eq 'defaults') && $action ) {
	    ConfigDefaults ();
	}
	elsif ( ($try eq 'posix_default' or $try eq 'posix_defaults') ) {
	    local $ENV{POSIXLY_CORRECT};
	    $ENV{POSIXLY_CORRECT} = 1 if $action;
	    ConfigDefaults ();
a822 11
	elsif ( $try eq 'gnu_getopt' ) {
	    if ( $action ) {
		$gnu_compat = 1;
		$bundling = 1;
		$getopt_compat = 0;
		$permute = 1;
	    }
	}
	elsif ( $try eq 'gnu_compat' ) {
	    $gnu_compat = $action;
	}
d844 1
a844 1
	elsif ( $try =~ /^prefix=(.+)$/ && $action ) {
d851 1
a851 1
	elsif ( $try =~ /^prefix_pattern=(.+)$/ && $action ) {
d933 1
a933 1
like
d946 1
a946 1
the first Perl module that provided support for handling the new style
d1169 1
a1169 1
and the argument specification.
d1173 1
a1173 1
characters.
a1245 18
=head2 Object oriented interface

Getopt::Long can be used in an object oriented way as well:

    use Getopt::Long;
    $p = new Getopt::Long::Parser;
    $p->configure(...configuration options...);
    if ($p->getoptions(...options descriptions...)) ...

Configuration options can be passed to the constructor:

    $p = new Getopt::Long::Parser
             config => [...configuration options...];

For thread safety, each method call will acquire an exclusive lock to
the Getopt::Long module. So don't call these methods from a callback
routine!

d1368 1
a1368 1
would set C<a>, C<v> and C<x>, but
d1401 2
a1402 7
Normally, a lone dash C<-> on the command line will not be considered
an option. Option processing will terminate (unless "permute" is
configured) and the dash will be left in C<@@ARGV>.

It is possible to get special treatment for a lone dash. This can be
achieved by adding an option specification with an empty name, for
example:
d1406 2
a1407 2
A lone dash on the command line will now be a legal option, and using
it will set variable C<$stdio>.
d1426 2
a1427 2
This will call
C<process("arg1")> while C<$width> is C<80>,
d1439 2
a1440 2
strings, each specifying a configuration option to be enabled, e.g.
C<ignore_case>, or disabled, e.g. C<no_ignore_case>. Case does not
a1442 5
Alternatively, as of version 2.24, the configuration options may be
passed together with the C<use> statement:

    use Getopt::Long qw(:config no_ignore_case bundling);

a1451 6
=item posix_default

This option causes all configuration options to be reset to their
default values as if the environment variable POSIXLY_CORRECT had
been set.

d1455 2
a1456 2
Default is enabled unless environment variable
POSIXLY_CORRECT has been set, in which case C<auto_abbrev> is disabled.
d1461 2
a1462 15
Default is enabled unless environment variable
POSIXLY_CORRECT has been set, in which case C<getopt_compat> is disabled.

=item gnu_compat

C<gnu_compat> controls whether C<--opt=> is allowed, and what it should
do. Without C<gnu_compat>, C<--opt=> gives an error. With C<gnu_compat>,
C<--opt=> will give option C<opt> and empty value.
This is the way GNU getopt_long() does it.

=item gnu_getopt

This is a short way of setting C<gnu_compat> C<bundling> C<permute>
C<no_getopt_compat>. With C<gnu_getopt>, command line handling should be
fully compatible with GNU getopt_long().
d1467 2
a1468 2
Default is disabled unless environment variable
POSIXLY_CORRECT has been set, in which case C<require_order> is enabled.
d1475 2
a1476 2
Default is enabled unless environment variable
POSIXLY_CORRECT has been set, in which case C<permute> is disabled.
d1479 1
a1479 1
If C<permute> is enabled, this means that
d1496 1
a1496 1
If C<require_order> is enabled, options processing
d1505 1
a1505 5
If C<pass_through> is also enabled, options processing will terminate
at the first unrecognized option, or non-option, whichever comes
first.

=item bundling (default: disabled)
d1507 1
a1507 1
Enabling this option will allow single-character options to be bundled.
d1512 1
a1512 1
Note: disabling C<bundling> also disables C<bundling_override>.
d1514 1
a1514 1
=item bundling_override (default: disabled)
d1516 2
a1517 2
If C<bundling_override> is enabled, bundling is enabled as with
C<bundling> but now long option names override option bundles.
d1519 1
a1519 1
Note: disabling C<bundling_override> also disables C<bundling>.
d1524 1
a1524 1
=item ignore_case  (default: enabled)
d1526 1
a1526 1
If enabled, case is ignored when matching long option names. Single
d1529 1
a1529 1
Note: disabling C<ignore_case> also disables C<ignore_case_always>.
d1531 1
a1531 1
=item ignore_case_always (default: disabled)
d1534 1
a1534 1
options also.
d1536 1
a1536 1
Note: disabling C<ignore_case_always> also disables C<ignore_case>.
d1538 1
a1538 1
=item pass_through (default: disabled)
d1546 1
a1546 3
If C<require_order> is enabled, options processing will terminate at
the first unrecognized option, or non-option, whichever comes first.
However, if C<permute> is enabled instead, results can become confusing.
d1559 1
a1559 1
=item debug (default: disabled)
d1561 1
a1561 1
Enable debugging output.
d1572 5
a1576 4
GetOptions returns true to indicate success.
It returns false when the function detected one or more errors during
option parsing. These errors are signalled using warn() and can be
trapped with C<$SIG{__WARN__}>.
d1632 3
a1634 3
GetOptions() will not interpret a leading C<< "<>" >> as option starters
if the next argument is a reference. To force C<< "<" >> and C<< ">" >> as
option starters, use C<< "><" >>. Confusing? Well, B<using a starter
d1640 3
a1642 26
configuring. Although manipulating these variables still work, it is
strongly encouraged to use the C<Configure> routine that was introduced
in version 2.17. Besides, it is much easier.

=head1 Trouble Shooting

=head2 Warning: Ignoring '!' modifier for short option

This warning is issued when the '!' modifier is applied to a short
(one-character) option and bundling is in effect. E.g.,

    Getopt::Long::Configure("bundling");
    GetOptions("foo|f!" => \$foo);

Note that older Getopt::Long versions did not issue a warning, because
the '!' modifier was applied to the first name only. This bug was
fixed in 2.22.

Solution: separate the long and short names and apply the '!' to the
long names only, e.g.,

    GetOptions("foo!" => \$foo, "f" => \$foo);

=head2 GetOptions does not return a false result when an option is not supplied

That's why they're called 'options'.
d1646 1
a1646 1
Johan Vromans <jvromans@@squirrel.nl>
d1663 1
a1663 1
the Free Software Foundation, Inc., 675 Mass Ave, Cambridge,
d1669 1
@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pm,v 2.58 2002-06-20 09:32:09+02 jv Exp $
d9 2
a10 2
# Last Modified On: Thu Jun 20 07:48:05 2002
# Update Count    : 1083
d15 1
a15 1
# This program is Copyright 1990,2002 by Johan Vromans.
d37 3
a39 5
use vars qw($VERSION);
$VERSION        =  2.32;
# For testing versions only.
use vars qw($VERSION_STRING);
$VERSION_STRING = "2.32";
d42 1
d69 2
a70 3
sub ParseOptionSpec ($$);
sub OptCtl ($);
sub FindOption ($$$$);
d133 5
d141 1
d157 1
d168 2
a169 2
	die(__PACKAGE__.": unhandled attributes: ".
	    join(" ", sort(keys(%atts)))."\n");
d178 2
d184 1
a184 1
    $self->{settings} = Getopt::Long::Configure ($save);
d190 2
d198 1
a198 8

    eval {
	# Locally set exception handler to default, otherwise it will
	# be called implicitly here, and again explicitly when we try
	# to deliver the messages.
	local ($SIG{__DIE__}) = '__DEFAULT__';
	$ret = Getopt::Long::GetOptions (@@_);
    };
d210 15
a224 27
# Indices in option control info.
# Note that ParseOptions uses the fields directly. Search for 'hard-wired'.
use constant CTL_TYPE    => 0;
#use constant   CTL_TYPE_FLAG   => '';
#use constant   CTL_TYPE_NEG    => '!';
#use constant   CTL_TYPE_INCR   => '+';
#use constant   CTL_TYPE_INT    => 'i';
#use constant   CTL_TYPE_INTINC => 'I';
#use constant   CTL_TYPE_XINT   => 'o';
#use constant   CTL_TYPE_FLOAT  => 'f';
#use constant   CTL_TYPE_STRING => 's';

use constant CTL_CNAME   => 1;

use constant CTL_MAND    => 2;

use constant CTL_DEST    => 3;
 use constant   CTL_DEST_SCALAR => 0;
 use constant   CTL_DEST_ARRAY  => 1;
 use constant   CTL_DEST_HASH   => 2;
 use constant   CTL_DEST_CODE   => 3;

use constant CTL_DEFAULT => 4;

# FFU.
#use constant CTL_RANGE   => ;
#use constant CTL_REPEAT  => ;
d230 2
a231 1
    my %opctl = ();		# table of option specs
d234 1
d239 2
a240 1
    my $prefix = $genprefix;	# current prefix
d244 1
a244 2
    print STDERR ("GetOpt::Long $Getopt::Long::VERSION (",
		  '$Revision: 2.58 $', ") ",
d247 2
d267 1
a267 1
    if ( @@optionlist && ref($optionlist[0]) and
d276 1
a276 1
    if ( @@optionlist && $optionlist[0] =~ /^\W+$/
d280 1
a280 1
	$prefix = shift (@@optionlist);
d282 2
a283 3
	$prefix =~ s/(\W)/\\$1/g;
	$prefix = "([" . $prefix . "])";
	print STDERR ("=> prefix=\"$prefix\"\n") if $debug;
d288 2
a289 1
    while ( @@optionlist ) {
d293 1
a293 1
	$opt = $+ if $opt =~ /^$prefix+(.*)$/s;
a304 3
		# Kill the linkage (to avoid another error).
		shift (@@optionlist)
		  if @@optionlist && ref($optionlist[0]);
d311 3
a313 8
	# Parse option spec.
	my ($name, $orig) = ParseOptionSpec ($opt, \%opctl);
	unless ( defined $name ) {
	    # Failed. $orig contains the error message. Sorry for the abuse.
	    $error .= $orig;
	    # Kill the linkage (to avoid another error).
	    shift (@@optionlist)
	      if @@optionlist && ref($optionlist[0]);
d316 60
d381 4
a384 4
		if ( exists $userlinkage->{$orig} &&
		     ref($userlinkage->{$orig}) ) {
		    print STDERR ("=> found userlinkage for \"$orig\": ",
				  "$userlinkage->{$orig}\n")
d386 1
a386 1
		    unshift (@@optionlist, $userlinkage->{$orig});
d397 1
a397 1
	    print STDERR ("=> link \"$orig\" to $optionlist[0]\n")
d399 2
a400 4
	    my $rl = ref($linkage{$orig} = shift (@@optionlist));

	    if ( $rl eq "ARRAY" ) {
		$opctl{$name}[CTL_DEST] = CTL_DEST_ARRAY;
d402 7
a408 2
	    elsif ( $rl eq "HASH" ) {
		$opctl{$name}[CTL_DEST] = CTL_DEST_HASH;
d410 7
a416 2
	    elsif ( $rl eq "SCALAR" || $rl eq "CODE" ) {
		# Ok.
d425 1
a425 1
	    my $ov = $orig;
d427 2
a428 2
	    if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
		print STDERR ("=> link \"$orig\" to \@@$pkg","::opt_$ov\n")
d430 1
a430 1
		eval ("\$linkage{\$orig} = \\\@@".$pkg."::opt_$ov;");
d432 2
a433 2
	    elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
		print STDERR ("=> link \"$orig\" to \%$pkg","::opt_$ov\n")
d435 1
a435 1
		eval ("\$linkage{\$orig} = \\\%".$pkg."::opt_$ov;");
d438 1
a438 1
		print STDERR ("=> link \"$orig\" to \$$pkg","::opt_$ov\n")
d440 1
a440 1
		eval ("\$linkage{\$orig} = \\\$".$pkg."::opt_$ov;");
d449 3
d457 6
a462 1
	    print STDERR ($arrow, "\$opctl{$k} = $v ", OptCtl($v), "\n");
d471 2
a472 1
	# Get next argument.
d474 3
a476 1
	print STDERR ("=> arg \"", $opt, "\"\n") if $debug;
d479 6
a484 1
	last if $opt eq $argend;
a485 1
	# Look it up.
d488 2
a491 1
	my $ctl;		# the opctl entry
d493 3
a495 2
	($found, $opt, $ctl, $arg, $key) =
	  FindOption ($prefix, $argend, $opt, \%opctl);
d503 5
a507 5

		# Get the canonical name.
		print STDERR ("=> cname for \"$opt\" is ") if $debug;
		$opt = $ctl->[CTL_CNAME];
		print STDERR ("\"$ctl->[CTL_CNAME]\"\n") if $debug;
d514 1
a514 1
			if ( $ctl->[CTL_TYPE] eq '+' ) {
d541 1
a541 3
			print STDERR ("=> &L{$opt}(\"$opt\"",
				      $ctl->[CTL_DEST] == CTL_DEST_HASH ? ", \"$key\"" : "",
				      ", \"$arg\")\n")
d543 3
a545 9
			my $eval_error = do {
			    local $@@;
			    local $SIG{__DIE__}  = '__DEFAULT__';
			    eval {
				&{$linkage{$opt}}($opt,
						  $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
						  $arg);
			    };
			    $@@;
d547 3
a549 4
			print STDERR ("=> die($eval_error)\n")
			  if $debug && $eval_error ne '';
			if ( $eval_error =~ /^!/ ) {
			    if ( $eval_error =~ /^!FINISH\b/ ) {
d553 2
a554 2
			elsif ( $eval_error ne '' ) {
			    warn ($eval_error);
d561 1
a561 1
			die("Getopt::Long -- internal error!\n");
d565 1
a565 1
		elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
d577 1
a577 1
		elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
d590 1
a590 1
		    if ( $ctl->[CTL_TYPE] eq '+' ) {
d613 3
a615 7
		print STDERR ("=> &L{$tryopt}(\"$tryopt\")\n")
		  if $debug;
		my $eval_error = do {
		    local $@@;
		    local $SIG{__DIE__}  = '__DEFAULT__';
		    eval { &$cb ($tryopt) };
		    $@@;
d617 3
a619 4
		print STDERR ("=> die($eval_error)\n")
		  if $debug && $eval_error ne '';
		if ( $eval_error =~ /^!/ ) {
		    if ( $eval_error =~ /^!FINISH\b/ ) {
d623 2
a624 2
		elsif ( $eval_error ne '' ) {
		    warn ($eval_error);
d646 1
a646 1
    if ( @@ret && $order == $PERMUTE ) {
d649 2
a650 2
	    if $debug;
	unshift (@@ARGV, @@ret);
a655 118
# A readable representation of what's in an optbl.
sub OptCtl ($) {
    my ($v) = @@_;
    my @@v = map { defined($_) ? ($_) : ("<undef>") } @@$v;
    "[".
      join(",",
	   "\"$v[CTL_TYPE]\"",
	   "\"$v[CTL_CNAME]\"",
	   $v[CTL_MAND] ? "O" : "M",
	   ("\$","\@@","\%","\&")[$v[CTL_DEST] || 0],
	   "\"$v[CTL_DEFAULT]\"",
#	   $v[CTL_RANGE] || '',
#	   $v[CTL_REPEAT] || '',
	  ). "]";
}

# Parse an option specification and fill the tables.
sub ParseOptionSpec ($$) {
    my ($opt, $opctl) = @@_;

    # Match option spec.
    if ( $opt !~ m;^
		   (
		     # Option name
		     (?: \w+[-\w]* )
		     # Alias names, or "?"
		     (?: \| (?: \? | \w[-\w]* )? )*
		   )?
		   (
		     # Either modifiers ...
		     [!+]
		     |
		     # ... or a value/dest specification
		     [=:] [ionfs] [@@%]?
		     |
		     # ... or an optional-with-default spec
		     : (?: -?\d+ | \+ ) [@@%]?
		   )?
		   $;x ) {
	return (undef, "Error in option spec: \"$opt\"\n");
    }

    my ($names, $spec) = ($1, $2);
    $spec = '' unless defined $spec;

    # $orig keeps track of the primary name the user specified.
    # This name will be used for the internal or external linkage.
    # In other words, if the user specifies "FoO|BaR", it will
    # match any case combinations of 'foo' and 'bar', but if a global
    # variable needs to be set, it will be $opt_FoO in the exact case
    # as specified.
    my $orig;

    my @@names;
    if ( defined $names ) {
	@@names =  split (/\|/, $names);
	$orig = $names[0];
    }
    else {
	@@names = ('');
	$orig = '';
    }

    # Construct the opctl entries.
    my $entry;
    if ( $spec eq '' || $spec eq '+' || $spec eq '!' ) {
	# Fields are hard-wired here.
	$entry = [$spec,$orig,0,CTL_DEST_SCALAR,undef];
    }
    elsif ( $spec =~ /:(-?\d+|\+)([@@%])?/ ) {
	my $def = $1;
	my $dest = $2;
	my $type = $def eq '+' ? 'I' : 'i';
	$dest ||= '$';
	$dest = $dest eq '@@' ? CTL_DEST_ARRAY
	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
	# Fields are hard-wired here.
	$entry = [$type,$orig,0,$dest,$def eq '+' ? undef : $def];
    }
    else {
	my ($mand, $type, $dest) = $spec =~ /([=:])([ionfs])([@@%])?/;
	$type = 'i' if $type eq 'n';
	$dest ||= '$';
	$dest = $dest eq '@@' ? CTL_DEST_ARRAY
	  : $dest eq '%' ? CTL_DEST_HASH : CTL_DEST_SCALAR;
	# Fields are hard-wired here.
	$entry = [$type,$orig,$mand eq '=',$dest,undef];
    }

    # Process all names. First is canonical, the rest are aliases.
    my $dups = '';
    foreach ( @@names ) {

	$_ = lc ($_)
	  if $ignorecase > (($bundling && length($_) == 1) ? 1 : 0);

	if ( exists $opctl->{$_} ) {
	    $dups .= "Duplicate specification \"$opt\" for option \"$_\"\n";
	}

	if ( $spec eq '!' ) {
	    $opctl->{"no$_"} = $entry;
	    $opctl->{$_} = [@@$entry];
	    $opctl->{$_}->[CTL_TYPE] = '';
	}
	else {
	    $opctl->{$_} = $entry;
	}
    }

    if ( $dups && $^W ) {
	foreach ( split(/\n+/, $dups) ) {
	    warn($_."\n");
	}
    }
    ($names[0], $orig);
}

d657 1
a657 1
sub FindOption ($$$$) {
d659 1
a659 2
    # returns (1, $opt, $ctl, $arg, $key) if okay,
    # returns (1, undef) if option in error,
d662 3
a664 1
    my ($prefix, $argend, $opt, $opctl) = @@_;
d666 1
a666 1
    print STDERR ("=> find \"$opt\"\n") if $debug;
d668 2
a669 2
    return (0) unless $opt =~ /^$prefix(.*)$/s;
    return (0) if $opt eq "-" && !defined $opctl->{''};
d672 1
a672 1
    my $starter = $1;
d676 2
a677 2
    my $optarg;			# value supplied with --opt=value
    my $rest;			# remainder from unbundling
d680 2
a681 4
    # With getopt_compat, only if not bundling.
    if ( ($starter eq "--" 
          || ($getopt_compat && ($bundling == 0 || $bundling == 2)))
	  && $opt =~ /^([^=]+)=(.*)$/s ) {
d691 4
d697 8
a704 3

	# To try overrides, obey case ignore.
	$tryopt = $ignorecase ? lc($opt) : $opt;
d707 4
a710 12
	if ( $bundling == 2 && length($tryopt) > 1
	     && defined ($opctl->{$tryopt}) ) {
	    print STDERR ("=> $starter$tryopt overrides unbundling\n")
	      if $debug;
	}
	else {
	    $tryopt = $opt;
	    # Unbundle single letter option.
	    $rest = length ($tryopt) > 0 ? substr ($tryopt, 1) : '';
	    $tryopt = substr ($tryopt, 0, 1);
	    $tryopt = lc ($tryopt) if $ignorecase > 1;
	    print STDERR ("=> $starter$tryopt unbundled from ",
d712 2
a713 1
	    $rest = undef unless $rest ne '';
a718 2
	# Sort the possible long option names.
	my @@names = sort(keys (%$opctl));
d720 1
a720 2
	$opt = lc ($opt) if $ignorecase;
	$tryopt = $opt;
d724 1
a724 1
	my @@hits = grep (/^$pat/, @@names);
d726 1
a726 1
		      "out of ", scalar(@@names), "\n") if $debug;
d733 1
a733 2
		$_ = $opctl->{$_}->[CTL_CNAME]
		  if defined $opctl->{$_}->[CTL_CNAME];
d742 2
a743 1
		return (1, undef);
d763 2
a764 2
    my $ctl = $opctl->{$tryopt};
    unless  ( defined $ctl ) {
d768 1
a768 1
	return (1, undef);
d772 1
a772 2
    print STDERR ("=> found ", OptCtl($ctl),
		  " for \"", $opt, "\"\n") if $debug;
a776 3
    my $type = $ctl->[CTL_TYPE];
    my $arg;

d785 2
a786 2
	    # Supply explicit value.
	    $arg = 1;
d789 1
a789 1
	    $opt =~ s/^no//i;	# strip NO prefix
d793 1
a793 1
	return (1, $opt, $ctl, $arg);
d797 2
a798 1
    my $mand = $ctl->[CTL_MAND];
d801 5
a805 3
    if ( $gnu_compat && defined $optarg && $optarg eq '' ) {
	return (1, $opt, $ctl, $type eq 's' ? '' : 0) unless $mand;
	$optarg = 0 unless $type eq 's';
d813 1
a813 1
	if ( $mand ) {
d817 1
a817 1
	    return (1, undef);
d819 1
a819 9
	if ( $type eq 'I' ) {
	    # Fake incremental type.
	    my @@c = @@$ctl;
	    $c[CTL_TYPE] = '+';
	    return (1, $opt, \@@c, 1);
	}
	return (1, $opt, $ctl,
		defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
		$type eq 's' ? '' : 0);
d827 3
a829 4
    my $key;
    if ($ctl->[CTL_DEST] == CTL_DEST_HASH && defined $arg) {
	($key, $arg) = ($arg =~ /^([^=]*)=(.*)$/s) ? ($1, $2)
	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 1);
d834 1
a834 1
    if ( $type eq 's' ) {	# string
d836 1
a836 1
	return (1, $opt, $ctl, $arg, $key) if $mand;
d839 1
a839 1
	return (1, $opt, $ctl, $arg, $key)
d841 1
a841 1
	return (1, $opt, $ctl, $arg, $key) if $arg eq "-"; # ??
d853 2
a854 9
    elsif ( $type eq 'i'	# numeric/integer
            || $type eq 'I'	# numeric/integer w/ incr default
	    || $type eq 'o' ) { # dec/oct/hex/bin value

	my $o_valid =
	  $type eq 'o' ? "[-+]?[1-9][0-9]*|0x[0-9a-f]+|0b[01]+|0[0-7]*"
	    : "[-+]?[0-9]+";

	if ( $bundling && defined $rest && $rest =~ /^($o_valid)(.*)$/si ) {
a856 1
	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
d859 2
a860 5
	elsif ( $arg =~ /^($o_valid)$/si ) {
	    $arg = ($type eq 'o' && $arg =~ /^0/) ? oct($arg) : 0+$arg;
	}
	else {
	    if ( defined $optarg || $mand ) {
d867 1
a867 3
		      $opt, " (",
		      $type eq 'o' ? "extended " : '',
		      "number expected)\n");
d869 1
a871 1
		return (1, undef);
a875 6
		if ( $type eq 'I' ) {
		    # Fake incremental type.
		    my @@c = @@$ctl;
		    $c[CTL_TYPE] = '+';
		    return (1, $opt, \@@c, 1);
		}
d877 1
a877 1
		$arg = defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] : 0;
d882 1
a882 1
    elsif ( $type eq 'f' ) { # real number, int is also ok
d893 1
a893 1
	    if ( defined $optarg || $mand ) {
d902 1
a904 1
		return (1, undef);
d915 1
a915 1
	die("GetOpt::Long internal error (Can't happen)\n");
d917 1
a917 1
    return (1, $opt, $ctl, $arg, $key);
d962 1
a962 1
		$order = $PERMUTE;
d994 1
a994 1
	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@@;
d1002 1
a1002 1
	    die("Getopt::Long: invalid pattern \"$genprefix\"") if $@@;
d1008 1
a1008 1
	    die("Getopt::Long: unknown config parameter \"$opt\"")
d1019 7
d1035 1
a1035 6
  my $data   = "file.dat";
  my $length = 24;
  my $verbose;
  $result = GetOptions ("length=i" => \$length,    # numeric
                        "file=s"   => \$data,      # string
			"verbose"  => \$verbose);  # flag
d1145 1
a1145 1
A negatable option is specified with an exclamation mark C<!> after the
d1262 3
a1264 6
will call the subroutine with two or three arguments. The first
argument is the name of the option. For a scalar or array destination,
the second argument is the value to be stored. For a hash destination,
the second arguments is the key to the hash, and the third argument
the value to be stored. It is up to the subroutine to store the value,
or do whatever it thinks is appropriate.
d1329 1
a1329 1
=over 4
d1355 1
a1355 1
=over 4
a1366 9
=item o

Extended integer, Perl style. This can be either an optional leading
plus or minus sign, followed by a sequence of digits, or an octal
string (a zero, optionally followed by '0', '1', .. '7'), or a
hexadecimal string (C<0x> followed by '0' .. '9', 'a' .. 'f', case
insensitive), or a binary string (C<0b> followed by a series of '0'
and '1').

a1386 9
=item : I<number> [ I<desttype> ]

Like C<:i>, but if the value is omitted, the I<number> will be assigned.

=item : + [ I<desttype> ]

Like C<:i>, but if the value is omitted, the current value for the
option will be incremented.

d1405 3
a1407 5
=head2 Thread Safety

Getopt::Long is thread safe when using ithreads as of Perl 5.8.  It is
I<not> thread safe when using the older (experimental and now
obsolete) threads implementation that was added to Perl 5.005.
d1577 1
a1577 1
=head2 Argument callback
d1582 1
a1582 1
subroutine and passes it one parameter: the argument name.
d1679 1
a1679 1
If an argument callback routine is specified, C<@@ARGV> will always be
d1685 2
a1686 2
This will call the callback routine for arg1 and arg2, and then
terminate GetOptions() leaving C<"arg2"> in C<@@ARGV>.
d1703 4
a1706 16
Enabling this option will allow single-character options to be
bundled. To distinguish bundles from long option names, long options
I<must> be introduced with C<--> and bundles with C<->.

Note that, if you have options C<a>, C<l> and C<all>, and
auto_abbrev enabled, possible arguments and option settings are:

    using argument               sets option(s)
    ------------------------------------------
    -a, --a                      a
    -l, --l                      l
    -al, -la, -ala, -all,...     a, l
    --al, --all                  all

The suprising part is that C<--a> sets option C<a> (due to auto
completion), not C<all>.
d1722 2
a1723 7
If enabled, case is ignored when matching long option names. If,
however, bundling is enabled as well, single character options will be
treated case-sensitive.

With C<ignore_case>, option specifications for options that only
differ in case, e.g., C<"foo"> and C<"Foo">, will be flagged as
duplicates.
a1863 31
=head2 GetOptions does not split the command line correctly

The command line is not split by GetOptions, but by the command line
interpreter (CLI). On Unix, this is the shell. On Windows, it is
COMMAND.COM or CMD.EXE. Other operating systems have other CLIs. 

It is important to know that these CLIs may behave different when the
command line contains special characters, in particular quotes or
backslashes. For example, with Unix shells you can use single quotes
(C<'>) and double quotes (C<">) to group words together. The following
alternatives are equivalent on Unix:

    "two words"
    'two words'
    two\ words

In case of doubt, insert the following statement in front of your Perl
program:

    print STDERR (join("|",@@ARGV),"\n");

to verify how your CLI passes the arguments to the program.

=head2 How do I put a "-?" option into a Getopt::Long?

You can only obtain this using an alias, and Getopt::Long of at least
version 2.13.

    use Getopt::Long;
    GetOptions ("help|?");    # -help and -? will both set $opt_help

d1870 1
a1870 1
This program is Copyright 2002,1990 by Johan Vromans.
d1888 3
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@d1 1
a1 1
# Getopt::Long.pm -- Universal options parsing
d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pm,v 2.68 2003-09-23 15:24:53+02 jv Exp $
d9 2
a10 2
# Last Modified On: Tue Sep 23 15:21:23 2003
# Update Count    : 1364
d38 1
a38 1
$VERSION        =  2.34;
d40 2
a41 2
#use vars qw($VERSION_STRING);
#$VERSION_STRING = "2.33_03";
d44 2
a45 1
use vars qw(@@ISA @@EXPORT @@EXPORT_OK);
d47 1
a47 7

# Exported subroutines.
sub GetOptions(@@);		# always
sub Configure(@@);		# on demand
sub HelpMessage(@@);		# on demand
sub VersionMessage(@@);		# in demand

d50 2
a51 2
    @@EXPORT    = qw(&GetOptions $REQUIRE_ORDER $PERMUTE $RETURN_IN_ORDER);
    @@EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure);
d61 1
a61 1
use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version);
d64 3
a66 1
sub config(@@);			# deprecated name
d69 4
a72 4
sub ConfigDefaults();
sub ParseOptionSpec($$);
sub OptCtl($);
sub FindOption($$$$);
a75 5
# $requested_version holds the version that was mentioned in the 'use'
# or 'require', if any. It can be used to enable or disable specific
# features.
my $requested_version = 0;

d78 1
a78 1
sub ConfigDefaults() {
d113 1
a113 1
	push(@@$dest, $_);	# push
a116 1
    push(@@syms, qw(&GetOptions)) if @@syms; # always export GetOptions
d119 1
a119 1
    Configure(@@config) if @@config;
a207 2
################ Back to Normal ################

d236 1
a236 1
sub GetOptions(@@) {
d251 17
a267 22
    if ( $debug ) {
	# Avoid some warnings if debugging.
	local ($^W) = 0;
	print STDERR
	  ("Getopt::Long $Getopt::Long::VERSION (",
	   '$Revision: 2.68 $', ") ",
	   "called from package \"$pkg\".",
	   "\n  ",
	   "ARGV: (@@ARGV)",
	   "\n  ",
	   "autoabbrev=$autoabbrev,".
	   "bundling=$bundling,",
	   "getopt_compat=$getopt_compat,",
	   "gnu_compat=$gnu_compat,",
	   "order=$order,",
	   "\n  ",
	   "ignorecase=$ignorecase,",
	   "requested_version=$requested_version,",
	   "passthrough=$passthrough,",
	   "genprefix=\"$genprefix\".",
	   "\n");
    }
d361 1
a361 12
	    elsif ( $rl eq "SCALAR" ) {
#		if ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY ) {
#		    my $t = $linkage{$orig};
#		    $$t = $linkage{$orig} = [];
#		}
#		elsif ( $opctl{$name}[CTL_DEST] == CTL_DEST_HASH ) {
#		}
#		else {
		    # Ok.
#		}
	    }
	    elsif ( $rl eq "CODE" ) {
a394 16
    # Supply --version and --help support, if needed and allowed.
    if ( defined($auto_version) ? $auto_version : ($requested_version >= 2.3203) ) {
	if ( !defined($opctl{version}) ) {
	    $opctl{version} = ['','version',0,CTL_DEST_CODE,undef];
	    $linkage{version} = \&VersionMessage;
	}
	$auto_version = 1;
    }
    if ( defined($auto_help) ? $auto_help : ($requested_version >= 2.3203) ) {
	if ( !defined($opctl{help}) && !defined($opctl{'?'}) ) {
	    $opctl{help} = $opctl{'?'} = ['','help',0,CTL_DEST_CODE,undef];
	    $linkage{help} = \&HelpMessage;
	}
	$auto_help = 1;
    }

d414 1
a414 4
	if ( $opt eq $argend ) {
	  push (@@ret, $argend) if $passthrough;
	  last;
	}
a452 20
			elsif ( $ctl->[CTL_DEST] == CTL_DEST_ARRAY ) {
			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
					  " to ARRAY\n")
			      if $debug;
			    my $t = $linkage{$opt};
			    $$t = $linkage{$opt} = [];
			    print STDERR ("=> push(\@@{\$L{$opt}, \"$arg\")\n")
			      if $debug;
			    push (@@{$linkage{$opt}}, $arg);
			}
			elsif ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
			    print STDERR ("=> ref(\$L{$opt}) auto-vivified",
					  " to HASH\n")
			      if $debug;
			    my $t = $linkage{$opt};
			    $$t = $linkage{$opt} = {};
			    print STDERR ("=> \$\$L{$opt}->{$key} = \"$arg\"\n")
			      if $debug;
			    $linkage{$opt}->{$key} = $arg;
			}
a700 1
	    $opctl->{"no-$_"} = $entry;
a799 9
	    # Remove auto-supplied options (version, help).
	    if ( keys(%hit) == 2 ) {
		if ( $auto_version && exists($hit{version}) ) {
		    delete $hit{version};
		}
		elsif ( $auto_help && exists($hit{help}) ) {
		    delete $hit{help};
		}
	    }
a828 5
	# Pretend one char when bundling.
	if ( $bundling == 1) {
	    $opt = substr($opt,0,1);
            unshift (@@ARGV, $starter.$rest) if defined $rest;
	}
d856 1
a856 1
	    $opt =~ s/^no-?//i;	# strip NO prefix
d902 1
a902 9
	  : ($arg, defined($ctl->[CTL_DEFAULT]) ? $ctl->[CTL_DEFAULT] :
	     ($mand ? undef : ($type eq 's' ? "" : 1)));
	if (! defined $arg) {
	    warn ("Option $opt, key \"$key\", requires a value\n");
	    $error++;
	    # Push back.
	    unshift (@@ARGV, $starter.$rest) if defined $rest;
	    return (1, undef);
	}
a906 2
    my $key_valid = $ctl->[CTL_DEST] == CTL_DEST_HASH ? "[^=]+=" : "";

d934 3
a936 4
	if ( $bundling && defined $rest
	     && $rest =~ /^($key_valid)($o_valid)(.*)$/si ) {
	    ($key, $arg, $rest) = ($1, $2, $+);
	    chop($key) if $key;
d979 3
a981 3
	     $rest =~ /^($key_valid)([-+]?[0-9]+(\.[0-9]+)?([eE][-+]?[0-9]+)?)(.*)$/s ) {
	    ($key, $arg, $rest) = ($1, $2, $+);
	    chop($key) if $key;
d1007 1
a1007 1
	die("Getopt::Long internal error (Can't happen)\n");
d1019 1
a1019 1
	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help ];
d1024 1
a1024 2
	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help ) =
	    @@{shift(@@options)};
a1059 6
	elsif ( $try =~ /^(auto_?)?version$/ ) {
	    $auto_version = $action;
	}
	elsif ( $try =~ /^(auto_?)?help$/ ) {
	    $auto_help = $action;
	}
a1110 95
# Issue a standard message for --version.
#
# The arguments are mostly the same as for Pod::Usage::pod2usage:
#
#  - a number (exit value)
#  - a string (lead in message)
#  - a hash with options. See Pod::Usage for details.
#
sub VersionMessage(@@) {
    # Massage args.
    my $pa = setup_pa_args("version", @@_);

    my $v = $main::VERSION;
    my $fh = $pa->{-output} ||
      ($pa->{-exitval} eq "NOEXIT" || $pa->{-exitval} < 2) ? \*STDOUT : \*STDERR;

    print $fh (defined($pa->{-message}) ? $pa->{-message} : (),
	       $0, defined $v ? " version $v" : (),
	       "\n",
	       "(", __PACKAGE__, "::", "GetOptions",
	       " version ",
	       defined($Getopt::Long::VERSION_STRING)
	         ? $Getopt::Long::VERSION_STRING : $VERSION, ";",
	       " Perl version ",
	       $] >= 5.006 ? sprintf("%vd", $^V) : $],
	       ")\n");
    exit($pa->{-exitval}) unless $pa->{-exitval} eq "NOEXIT";
}

# Issue a standard message for --help.
#
# The arguments are the same as for Pod::Usage::pod2usage:
#
#  - a number (exit value)
#  - a string (lead in message)
#  - a hash with options. See Pod::Usage for details.
#
sub HelpMessage(@@) {
    eval {
	require Pod::Usage;
	import Pod::Usage;
	1;
    } || die("Cannot provide help: cannot load Pod::Usage\n");

    # Note that pod2usage will issue a warning if -exitval => NOEXIT.
    pod2usage(setup_pa_args("help", @@_));

}

# Helper routine to set up a normalized hash ref to be used as
# argument to pod2usage.
sub setup_pa_args($@@) {
    my $tag = shift;		# who's calling

    # If called by direct binding to an option, it will get the option
    # name and value as arguments. Remove these, if so.
    @@_ = () if @@_ == 2 && $_[0] eq $tag;

    my $pa;
    if ( @@_ > 1 ) {
	$pa = { @@_ };
    }
    else {
	$pa = shift || {};
    }

    # At this point, $pa can be a number (exit value), string
    # (message) or hash with options.

    if ( UNIVERSAL::isa($pa, 'HASH') ) {
	# Get rid of -msg vs. -message ambiguity.
	$pa->{-message} = $pa->{-msg};
	delete($pa->{-msg});
    }
    elsif ( $pa =~ /^-?\d+$/ ) {
	$pa = { -exitval => $pa };
    }
    else {
	$pa = { -message => $pa };
    }

    # These are _our_ defaults.
    $pa->{-verbose} = 0 unless exists($pa->{-verbose});
    $pa->{-exitval} = 0 unless exists($pa->{-exitval});
    $pa;
}

# Sneak way to know what version the user requested.
sub VERSION {
    $requested_version = $_[1];
    shift->SUPER::VERSION(@@_);
}

1;

d1309 1
d1312 4
a1315 10
Alternatively, you can specify that the option can have multiple
values by adding a "@@", and pass a scalar reference as the
destination:

    GetOptions ("library=s@@" => \$libfiles);

Used with the example above, C<@@libfiles> (or C<@@$libfiles>) would
contain two strings upon completion: C<"lib/srdlib"> and
C<"lib/extlib">, in that order. It is also possible to specify that
only integer or floating point numbers are acceptible values.
d1321 1
d1334 1
a1336 4
Alternatively you can use:

    GetOptions ("define=s%" => \$defines);

d1341 4
a1344 4
the hash C<%defines> (or C<%$defines>) will contain two keys, C<"os">
with value C<"linux> and C<"vendor"> with value C<"redhat">. It is
also possible to specify that only integer or floating point numbers
are acceptible values. The keys are always taken to be strings.
d1428 1
a1428 1
assigned) and C<--nofoo> and C<--no-foo> (a value of 0 will be assigned). If the
d1541 1
a1541 1
    sample - Using Getopt::Long and Pod::Usage
d1692 1
a1692 1
A special option 'name' C<< <> >> can be used to designate a subroutine
d1715 1
a1863 27
=item auto_version (default:disabled)

Automatically provide support for the B<--version> option if
the application did not specify a handler for this option itself.

Getopt::Long will provide a standard version message that includes the
program name, its version (if $main::VERSION is defined), and the
versions of Getopt::Long and Perl. The message will be written to
standard output and processing will terminate.

C<auto_version> will be enabled if the calling program explicitly
specified a version number higher than 2.32 in the C<use> or
C<require> statement.

=item auto_help (default:disabled)

Automatically provide support for the B<--help> and B<-?> options if
the application did not specify a handler for this option itself.

Getopt::Long will provide a help message using module L<Pod::Usage>. The
message, derived from the SYNOPSIS POD section, will be written to
standard output and processing will terminate.

C<auto_help> will be enabled if the calling program explicitly
specified a version number higher than 2.32 in the C<use> or
C<require> statement.

a1875 3
Note that the options terminator (default C<-->), if present, will
also be passed through in C<@@ARGV>.

a1892 77
=head1 Exportable Methods

=over

=item VersionMessage

This subroutine provides a standard version message. Its argument can be:

=over 4

=item *

A string containing the text of a message to print I<before> printing
the standard message.

=item *

A numeric value corresponding to the desired exit status.

=item *

A reference to a hash.

=back

If more than one argument is given then the entire argument list is
assumed to be a hash.  If a hash is supplied (either as a reference or
as a list) it should contain one or more elements with the following
keys:

=over 4

=item C<-message>

=item C<-msg>

The text of a message to print immediately prior to printing the
program's usage message.

=item C<-exitval>

The desired exit status to pass to the B<exit()> function.
This should be an integer, or else the string "NOEXIT" to
indicate that control should simply be returned without
terminating the invoking process.

=item C<-output>

A reference to a filehandle, or the pathname of a file to which the
usage message should be written. The default is C<\*STDERR> unless the
exit value is less than 2 (in which case the default is C<\*STDOUT>).

=back

You cannot tie this routine directly to an option, e.g.:

    GetOptions("version" => \&VersionMessage);

Use this instead:

    GetOptions("version" => sub { VersionMessage() });

=item HelpMessage

This subroutine produces a standard help message, derived from the
program's POD section SYNOPSIS using L<Pod::Usage>. It takes the same
arguments as VersionMessage(). In particular, you cannot tie it
directly to an option, e.g.:

    GetOptions("help" => \&HelpMessage);

Use this instead:

    GetOptions("help" => sub { HelpMessage() });

=back

d1905 2
d1973 17
d1998 1
a1998 1
COMMAND.COM or CMD.EXE. Other operating systems have other CLIs.
a2016 8
=head2 Undefined subroutine &main::GetOptions called

Are you running Windows, and did you write

    use GetOpt::Long;

(note the capital 'O')?

d2031 1
a2031 1
This program is Copyright 2003,1990 by Johan Vromans.
@


1.1.1.7
log
@Import of stock perl 5.8.5
@
text
@d5 1
a5 1
# RCS Status      : $Id: Long.pm,v 1.7 2003/12/03 03:02:38 millert Exp $
d267 1
a267 1
	   '$Revision: 1.7 $', ") ",
@


1.1.1.8
log
@perl 5.8.6 from CPAN
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pm,v 2.68 2003-09-23 15:24:53+02 jv Exp $
d267 1
a267 1
	   '$Revision: 2.68 $', ") ",
@


1.1.1.9
log
@perl 5.8.8 import
@
text
@d5 1
a5 1
# RCS Status      : $Id: GetoptLong.pm,v 2.72 2005-04-28 21:18:33+02 jv Exp $
d9 2
a10 2
# Last Modified On: Wed Dec 14 21:17:21 2005
# Update Count    : 1458
d15 1
a15 1
# This program is Copyright 1990,2005 by Johan Vromans.
d38 1
a38 1
$VERSION        =  2.35;
d41 1
a41 1
#$VERSION_STRING = "2.35";
d66 1
a66 1
use vars qw($genprefix $caller $gnu_compat $auto_help $auto_version $longprefix);
a75 1
sub ValidValue ($$$$$);
a107 1
    $longprefix = "(--)";       # what does a long prefix look like
d233 1
a233 1
use constant CTL_DEFAULT => 2;
d241 1
a241 2
use constant CTL_AMIN    => 4;
use constant CTL_AMAX    => 5;
d267 1
a267 1
	   '$Revision: 2.72 $', ") ",
d281 1
a281 2
	   "genprefix=\"$genprefix\",",
	   "longprefix=\"$longprefix\".",
d290 1
a290 1
	 UNIVERSAL::isa($optionlist[0],'HASH') ) {
a313 5
	unless ( defined($opt) ) {
	    $error .= "Undefined argument in option spec\n";
	    next;
	}

d477 1
a477 2
	    my $argcnt = 0;
	    while ( defined $arg ) {
a608 30

		$argcnt++;
		last if $argcnt >= $ctl->[CTL_AMAX] && $ctl->[CTL_AMAX] != -1;
		undef($arg);

		# Need more args?
		if ( $argcnt < $ctl->[CTL_AMIN] ) {
		    if ( @@ARGV ) {
			if ( ValidValue($ctl, $ARGV[0], 1, $argend, $prefix) ) {
			    $arg = shift(@@ARGV);
			    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
			      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
			    next;
			}
			warn("Value \"$ARGV[0]\" invalid for option $opt\n");
			$error++;
		    }
		    else {
			warn("Insufficient arguments for option $opt\n");
			$error++;
		    }
		}

		# Any more args?
		if ( @@ARGV && ValidValue($ctl, $ARGV[0], 0, $argend, $prefix) ) {
		    $arg = shift(@@ARGV);
		    ($key,$arg) = $arg =~ /^([^=]+)=(.*)/
		      if $ctl->[CTL_DEST] == CTL_DEST_HASH;
		    next;
		}
d673 2
a675 3
	   ("\$","\@@","\%","\&")[$v[CTL_DEST] || 0],
	   $v[CTL_AMIN] || '',
	   $v[CTL_AMAX] || '',
d697 2
a698 2
		     # ... or a value/dest/repeat specification
		     [=:] [ionfs] [@@%]? (?: \{\d*,?\d*\} )?
d732 1
a732 1
	$entry = [$spec,$orig,undef,CTL_DEST_SCALAR,0,0];
d734 1
a734 1
    elsif ( $spec =~ /^:(-?\d+|\+)([@@%])?$/ ) {
d742 1
a742 2
	$entry = [$type,$orig,$def eq '+' ? undef : $def,
		  $dest,0,1];
d745 1
a745 8
	my ($mand, $type, $dest) =
	  $spec =~ /^([=:])([ionfs])([@@%])?(\{(\d+)?(,)?(\d+)?\})?$/;
	return (undef, "Cannot repeat while bundling: \"$opt\"\n")
	  if $bundling && defined($4);
	my ($mi, $cm, $ma) = ($5, $6, $7);
	return (undef, "{0} is useless in option spec: \"$opt\"\n")
	  if defined($mi) && !$mi && !defined($ma) && !defined($cm);

a749 11
	# Default minargs to 1/0 depending on mand status.
	$mi = $mand eq '=' ? 1 : 0 unless defined $mi;
	# Adjust mand status according to minargs.
	$mand = $mi ? '=' : ':';
	# Adjust maxargs.
	$ma = $mi ? $mi : 1 unless defined $ma || defined $cm;
	return (undef, "Max must be greater than zero in option spec: \"$opt\"\n")
	  if defined($ma) && !$ma;
	return (undef, "Max less than min in option spec: \"$opt\"\n")
	  if defined($ma) && $ma < $mi;

d751 1
a751 1
	$entry = [$type,$orig,undef,$dest,$mi,$ma||-1];
d808 1
a808 1
    if ( ($starter=~/^$longprefix$/
d863 3
a865 4
		my $hit = $_;
		$hit = $opctl->{$hit}->[CTL_CNAME]
		  if defined $opctl->{$hit}->[CTL_CNAME];
		$hit{$hit} = 1;
d906 1
a906 1
	if ( $bundling == 1 && length($starter) == 1 ) {
d945 1
a945 1
    my $mand = $ctl->[CTL_AMIN];
a1103 41
sub ValidValue ($$$$$) {
    my ($ctl, $arg, $mand, $argend, $prefix) = @@_;

    if ( $ctl->[CTL_DEST] == CTL_DEST_HASH ) {
	return 0 unless $arg =~ /[^=]+=(.*)/;
	$arg = $1;
    }

    my $type = $ctl->[CTL_TYPE];

    if ( $type eq 's' ) {	# string
	# A mandatory string takes anything.
	return (1) if $mand;

	return (1) if $arg eq "-";

	# Check for option or option list terminator.
	return 0 if $arg eq $argend || $arg =~ /^$prefix.+/;
	return 1;
    }

    elsif ( $type eq 'i'	# numeric/integer
            || $type eq 'I'	# numeric/integer w/ incr default
	    || $type eq 'o' ) { # dec/oct/hex/bin value

	my $o_valid =
	  $type eq 'o' ? "[-+]?[1-9][0-9]*|0x[0-9a-f]+|0b[01]+|0[0-7]*"
	    : "[-+]?[0-9]+";

	return $arg =~ /^$o_valid$/si;
    }

    elsif ( $type eq 'f' ) { # real number, int is also ok
	# We require at least one digit before a point or 'e',
	# and at least one digit following the point and 'e'.
	# [-]NN[.NN][eNN]
	return $arg =~ /^[-+]?[0-9.]+(\.[0-9]+)?([eE][-+]?[0-9]+)?$/;
    }
    die("ValidValue: Cannot happen\n");
}

d1111 1
a1111 2
	$gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
	$longprefix ];
d1116 2
a1117 2
	  $gnu_compat, $passthrough, $genprefix, $auto_version, $auto_help,
	  $longprefix ) = @@{shift(@@options)};
d1192 1
a1192 1
	    eval { '' =~ m"$genprefix"; };
a1194 8
	elsif ( $try =~ /^long_prefix_pattern=(.+)$/ && $action ) {
	    $longprefix = $1;
	    # Parenthesize if needed.
	    $longprefix = "(" . $longprefix . ")"
	      unless $longprefix =~ /^\(.*\)$/;
	    eval { '' =~ m"$longprefix"; };
	    die("Getopt::Long: invalid long prefix pattern \"$longprefix\"") if $@@;
	}
d1374 6
a1379 9
Getopt::Long is the Perl5 successor of C<newgetopt.pl>. This was the
first Perl module that provided support for handling the new style of
command line options, hence the name Getopt::Long. This module also
supports single-character options and bundling. Single character
options may be any alphabetic character, a question mark, and a dash.
Long options may consist of a series of letters, digits, and dashes.
Although this is currently not enforced by Getopt::Long, multiple
consecutive dashes are not allowed, and the option name must not end
with a dash.
d1514 1
a1514 1
only integer or floating point numbers are acceptable values.
a1525 20
Warning: What follows is an experimental feature.

Options can take multiple values at once, for example

    --coordinates 52.2 16.4 --rgbcolor 255 255 149

This can be accomplished by adding a repeat specifier to the option
specification. Repeat specifiers are very similar to the C<{...}>
repeat specifiers that can be used with regular expression patterns.
For example, the above command line would be handled as follows:

    GetOptions('coordinates=f{2}' => \@@coor, 'rgbcolor=i{3}' => \@@color);

The destination for the option must be an array or array reference.

It is also possible to specify the minimal and maximal number of
arguments an option takes. C<foo=s{2,4}> indicates an option that
takes at least two and at most 4 arguments. C<foo=s{,}> indicates one
or more values; C<foo:s{,}> indicates zero or more option values.

d1545 1
a1545 1
are acceptable values. The keys are always taken to be strings.
d1575 1
a1575 1
If the text of the error message starts with an exclamation mark C<!>
d1591 1
a1591 2
called I<aliases>. When using a hash to store options, the key will
always be the primary name.
d1627 4
a1630 5
The option does not take an argument and may be negated by prefixing
it with "no" or "no-". E.g. C<"foo!"> will allow C<--foo> (a value of
1 will be assigned) as well as C<--nofoo> and C<--no-foo> (a value of
0 will be assigned). If the option has aliases, this applies to the
aliases as well.
d1644 1
a1644 1
=item = I<type> [ I<desttype> ] [ I<repeat> ]
a1680 11
The I<repeat> specifies the number of values this option takes per
occurrence on the command line. It has the format C<{> [ I<min> ] [ C<,> [ I<max> ] ] C<}>.

I<min> denotes the minimal number of arguments. It defaults to 1 for
options with C<=> and to 0 for options with C<:>, see below. Note that
I<min> overrules the C<=> / C<:> semantics.

I<max> denotes the maximum number of arguments. It must be at least
I<min>. If I<max> is omitted, I<but the comma is not>, there is no
upper bound to the number of argument values taken.

d1768 1
a1768 1
    B<This program> will read the given input file(s) and do something
d1775 1
a1775 1
=head2 Storing option values in a hash
d1840 1
a1840 1
ambiguity. For example, when C<vax>, C<a>, C<v> and C<x> are all valid
d1993 1
a1993 1
empty upon successful return of GetOptions() since all options have been
d2030 1
a2030 1
The surprising part is that C<--a> sets option C<a> (due to auto
d2114 2
a2115 15
Default is C<--|-|\+> unless environment variable
POSIXLY_CORRECT has been set, in which case it is C<--|->.

=item long_prefix_pattern

A Perl pattern that allows the disambiguation of long and short
prefixes. Default is C<-->.

Typically you only need to set this if you are using nonstandard
prefixes and want some or all of them to have the same semantics as
'--' does under normal circumstances.

For example, setting prefix_pattern to C<--|-|\+|\/> and
long_prefix_pattern to C<--|\/> would add Win32 style argument
handling.
d2327 1
a2327 1
This program is Copyright 1990,2005 by Johan Vromans.
@


1.1.1.10
log
@import perl 5.10.0 from CPAN
@
text
@d5 1
a5 1
# RCS Status      : $Id: Long.pm,v 2.74 2007/09/29 13:40:13 jv Exp $
d9 2
a10 2
# Last Modified On: Sat Sep 29 15:38:55 2007
# Update Count    : 1571
d15 1
a15 1
# This program is Copyright 1990,2007 by Johan Vromans.
d38 1
a38 1
$VERSION        =  2.37;
d40 2
a41 2
use vars qw($VERSION_STRING);
$VERSION_STRING = "2.37";
a48 2
sub GetOptionsFromArray($@@);	# on demand
sub GetOptionsFromString($@@);	# on demand
d56 1
a56 2
    @@EXPORT_OK = qw(&HelpMessage &VersionMessage &Configure
		    &GetOptionsFromArray &GetOptionsFromString);
d75 1
a75 1
sub FindOption($$$$$);
a249 14
# Rather liberal patterns to match numbers.
use constant PAT_INT   => "[-+]?_*[0-9][0-9_]*";
use constant PAT_XINT  =>
  "(?:".
	  "[-+]?_*[1-9][0-9_]*".
  "|".
	  "0x_*[0-9a-f][0-9a-f_]*".
  "|".
	  "0b_*[01][01_]*".
  "|".
	  "0[0-7_]*".
  ")";
use constant PAT_FLOAT => "[-+]?[0-9._]+(\.[0-9_]+)?([eE][-+]?[0-9_]+)?";

a250 19
    # Shift in default array.
    unshift(@@_, \@@ARGV);
    # Try to keep caller() and Carp consitent.
    goto &GetOptionsFromArray;
}

sub GetOptionsFromString($@@) {
    my ($string) = shift;
    require Text::ParseWords;
    my $args = [ Text::ParseWords::shellwords($string) ];
    $caller ||= (caller)[0];	# current context
    my $ret = GetOptionsFromArray($args, @@_);
    return ( $ret, $args ) if wantarray;
    if ( @@$args ) {
	$ret = 0;
	warn("GetOptionsFromString: Excess data \"@@$args\" in string \"$string\"\n");
    }
    $ret;
}
d252 1
a252 3
sub GetOptionsFromArray($@@) {

    my ($argv, @@optionlist) = @@_;	# local copy of the option descriptions
d270 1
a270 1
	   '$Revision: 2.74 $', ") ",
d273 1
a273 1
	   "argv: (@@$argv)",
d386 1
a386 1
	    elsif ( $rl eq "SCALAR" || $rl eq "REF" ) {
d459 1
a459 1
    while ( $goon && @@$argv > 0 ) {
d462 1
a462 1
	$opt = shift (@@$argv);
d479 1
a479 1
	  FindOption ($argv, $prefix, $argend, $opt, \%opctl);
d498 1
a498 2
		    if ( ref($linkage{$opt}) eq 'SCALAR'
			 || ref($linkage{$opt}) eq 'REF' ) {
d554 3
a556 10
				&{$linkage{$opt}}
				  (Getopt::Long::CallBack->new
				   (name    => $opt,
				    ctl     => $ctl,
				    opctl   => \%opctl,
				    linkage => \%linkage,
				    prefix  => $prefix,
				   ),
				   $ctl->[CTL_DEST] == CTL_DEST_HASH ? ($key) : (),
				   $arg);
d626 3
a628 4
		    if ( @@$argv ) {
			if ( ValidValue($ctl, $argv->[0], 1, $argend, $prefix) ) {
			    $arg = shift(@@$argv);
			    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
d633 1
a633 1
			warn("Value \"$$argv[0]\" invalid for option $opt\n");
d643 2
a644 3
		if ( @@$argv && ValidValue($ctl, $argv->[0], 0, $argend, $prefix) ) {
		    $arg = shift(@@$argv);
		    $arg =~ tr/_//d if $ctl->[CTL_TYPE] =~ /^[iIo]$/;
d688 1
a688 1
	    unshift (@@$argv, $tryopt);
d699 1
a699 1
	unshift (@@$argv, @@ret);
d845 1
a845 1
sub FindOption ($$$$$) {
d851 1
a851 1
    my ($argv, $prefix, $argend, $opt, $opctl) = @@_;
d969 1
a969 1
            unshift (@@$argv, $starter.$rest) if defined $rest;
d1001 1
a1001 1
	unshift (@@$argv, $starter.$rest) if defined $rest;
d1010 1
a1010 1
	return (1, $opt, $ctl, $type eq 's' ? '' : 0) ;#unless $mand;
d1017 1
a1017 1
	 : !(defined $rest || @@$argv > 0) ) {
a1018 1
#	if ( $mand && !($type eq 's' ? defined($optarg) : 0) ) {
d1038 1
a1038 1
	    : (defined $optarg ? $optarg : shift (@@$argv)));
d1050 1
a1050 1
	    unshift (@@$argv, $starter.$rest) if defined $rest;
a1062 4
	# Same for optional string as a hash value
	return (1, $opt, $ctl, $arg, $key)
	  if $ctl->[CTL_DEST] == CTL_DEST_HASH;

d1072 1
a1072 1
	    unshift (@@$argv, $arg);
d1082 3
a1084 1
	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
d1091 1
a1091 1
	    unshift (@@$argv, $starter.$rest) if defined $rest && $rest ne '';
d1093 1
a1093 2
	elsif ( $arg =~ /^$o_valid$/si ) {
	    $arg =~ tr/_//d;
d1099 1
a1099 1
		    unshift (@@$argv, defined $rest ? $starter.$rest : $arg)
d1109 1
a1109 1
		unshift (@@$argv, $starter.$rest) if defined $rest;
d1114 1
a1114 1
		unshift (@@$argv, defined $rest ? $starter.$rest : $arg);
a1130 1
	my $o_valid = PAT_FLOAT;
d1132 1
a1132 2
	     $rest =~ /^($key_valid)($o_valid)(.*)$/s ) {
	    $arg =~ tr/_//d;
d1135 1
a1135 1
	    unshift (@@$argv, $starter.$rest) if defined $rest && $rest ne '';
d1137 1
a1137 4
	elsif ( $arg =~ /^$o_valid$/ ) {
	    $arg =~ tr/_//d;
	}
	else {
d1140 1
a1140 1
		    unshift (@@$argv, defined $rest ? $starter.$rest : $arg)
d1148 1
a1148 1
		unshift (@@$argv, $starter.$rest) if defined $rest;
d1153 1
a1153 1
		unshift (@@$argv, defined $rest ? $starter.$rest : $arg);
d1190 4
a1193 1
	my $o_valid = $type eq 'o' ? PAT_XINT : PAT_INT;
d1201 1
a1201 2
	my $o_valid = PAT_FLOAT;
	return $arg =~ /^$o_valid$/;
a1243 1
            $genprefix = $action ? "(--|-|\\+)" : "(--|-)";
a1249 1
                $genprefix = "(--|-)";
d1265 1
a1265 1
	elsif ( $try eq 'ignorecase_always' or $try eq 'ignore_case_always' ) {
a1413 18
package Getopt::Long::CallBack;

sub new {
    my ($pkg, %atts) = @@_;
    bless { %atts }, $pkg;
}

sub name {
    my $self = shift;
    ''.$self->{name};
}

use overload
  # Treat this object as an oridinary string for legacy API.
  '""'	   => \&name,
  '0+'	   => sub { 0 },
  fallback => 1;

d1922 1
a1922 40
=head2 Parsing options from an arbitrary array

By default, GetOptions parses the options that are present in the
global array C<@@ARGV>. A special entry C<GetOptionsFromArray> can be
used to parse options from an arbitrary array.

    use Getopt::Long qw(GetOptionsFromArray);
    $ret = GetOptionsFromArray(\@@myopts, ...);

When used like this, the global C<@@ARGV> is not touched at all.

The following two calls behave identically:

    $ret = GetOptions( ... );
    $ret = GetOptionsFromArray(\@@ARGV, ... );

=head2 Parsing options from an arbitrary string

A special entry C<GetOptionsFromString> can be used to parse options
from an arbitrary string.

    use Getopt::Long qw(GetOptionsFromString);
    $ret = GetOptionsFromString($string, ...);

The contents of the string are split into arguments using a call to
C<Text::ParseWords::shellwords>. As with C<GetOptionsFromArray>, the
global C<@@ARGV> is not touched.

It is possible that, upon completion, not all arguments in the string
have been processed. C<GetOptionsFromString> will, when called in list
context, return both the return status and an array reference to any
remaining arguments:

    ($ret, $args) = GetOptionsFromString($string, ... );

If any arguments remain, and C<GetOptionsFromString> was not called in
list context, a message will be given and C<GetOptionsFromString> will
return failure.

=head2 Storing options values in a hash
d1926 1
a1926 2
supports, as an alternative mechanism, storing options values in a
hash.
d2146 1
a2146 1
terminate GetOptions() leaving C<"arg3"> in C<@@ARGV>.
a2435 19
=head1 Tips and Techniques

=head2 Pushing multiple values in a hash option

Sometimes you want to combine the best of hashes and arrays. For
example, the command line:

  --list add=first --list add=second --list add=third

where each successive 'list add' option will push the value of add
into array ref $list->{'add'}. The result would be like

  $list->{add} = [qw(first second third)];

This can be accomplished with a destination routine:

  GetOptions('list=s%' =>
               sub { push(@@{$list{$_[1]}}, $_[2]) });

d2487 1
a2487 1
This program is Copyright 1990,2007 by Johan Vromans.
@


1.1.1.11
log
@import perl 5.10.1
@
text
@d5 1
a5 1
# RCS Status      : $Id: Long.pm,v 2.76 2009/03/30 20:54:30 jv Exp $
d9 2
a10 2
# Last Modified On: Mon Mar 30 22:51:17 2009
# Update Count    : 1601
d13 18
d38 1
a38 1
$VERSION        =  2.38;
d40 2
a41 2
#use vars qw($VERSION_STRING);
#$VERSION_STRING = "2.38";
d49 2
a50 2
sub GetOptionsFromArray(@@);	# on demand
sub GetOptionsFromString(@@);	# on demand
d208 1
a208 1
	local ($SIG{__DIE__}) = 'DEFAULT';
d274 1
a274 1
sub GetOptionsFromString(@@) {
d288 1
a288 1
sub GetOptionsFromArray(@@) {
d308 1
a308 1
	   '$Revision: 2.76 $', ") ",
a462 8

	if ( $opctl{$name}[CTL_TYPE] eq 'I'
	     && ( $opctl{$name}[CTL_DEST] == CTL_DEST_ARRAY
		  || $opctl{$name}[CTL_DEST] == CTL_DEST_HASH )
	   ) {
	    $error .= "Invalid option linkage for \"$opt\"\n";
	}

d591 1
a591 1
			    local $SIG{__DIE__}  = 'DEFAULT';
d709 2
a710 11
		    local $SIG{__DIE__}  = 'DEFAULT';
		    eval {
			&$cb
			  (Getopt::Long::CallBack->new
			   (name    => $tryopt,
			    ctl     => $ctl,
			    opctl   => \%opctl,
			    linkage => \%linkage,
			    prefix  => $prefix,
			   ));
		    };
d780 1
a780 1
		     (?: \| (?: \? | \w[-\w]* ) )*
d953 1
a953 1
    elsif ( $autoabbrev && $opt ne "" ) {
d1019 1
a1019 6
	if ( $opt eq "" ) {
	    warn ("Missing option after ", $starter, "\n");
	}
	else {
	    warn ("Unknown option: ", $opt, "\n");
	}
d1484 1
a1484 1
  # Treat this object as an ordinary string for legacy API.
d1486 1
d1752 1
a1752 1
with value C<"linux"> and C<"vendor"> with value C<"redhat">. It is
d1763 1
a1763 2
argument is the name of the option. (Actually, it is an object that
stringifies to the name of the option.) For a scalar or array destination,
a1788 6
In version 2.37 the first argument to the callback function was
changed from string to object. This was done to make room for
extensions and more detailed control. The object stringifies to the
option name so this change should not introduce compatibility
problems.

d2158 1
a2158 2
subroutine and passes it one parameter: the argument name. Well, actually
it is an object that stringifies to the argument name.
d2570 1
a2570 1
=head1 Troubleshooting
d2621 1
a2621 1
This program is Copyright 1990,2009 by Johan Vromans.
@


