head	1.6;
access;
symbols
	OPENBSD_6_1:1.6.0.28
	OPENBSD_6_1_BASE:1.6
	OPENBSD_6_0:1.6.0.30
	OPENBSD_6_0_BASE:1.6
	OPENBSD_5_9:1.6.0.24
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.6.0.26
	OPENBSD_5_8_BASE:1.6
	PERL_5_20_2:1.1.1.5
	OPENBSD_5_7:1.6.0.18
	OPENBSD_5_7_BASE:1.6
	PERL_5_20_1:1.1.1.5
	OPENBSD_5_6:1.6.0.22
	OPENBSD_5_6_BASE:1.6
	PERL_5_18_2:1.1.1.5
	PERL:1.1.1
	OPENBSD_5_5:1.6.0.20
	OPENBSD_5_5_BASE:1.6
	OPENBSD_5_4:1.6.0.16
	OPENBSD_5_4_BASE:1.6
	PERL_5_16_3:1.1.1.5
	OPENBSD_5_3:1.6.0.14
	OPENBSD_5_3_BASE:1.6
	OPENBSD_5_2:1.6.0.12
	OPENBSD_5_2_BASE:1.6
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.10
	OPENBSD_5_0:1.6.0.8
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.6.0.6
	OPENBSD_4_9_BASE:1.6
	PERL_5_12_2:1.1.1.5
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.5.0.30
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.26
	OPENBSD_4_5_BASE:1.5
	PERL_5_10_0:1.1.1.4
	OPENBSD_4_4:1.5.0.24
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.22
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.5.0.20
	OPENBSD_4_2_BASE:1.5
	OPENBSD_4_1:1.5.0.18
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.16
	OPENBSD_4_0_BASE:1.5
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.5.0.14
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.12
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.10
	OPENBSD_3_7_BASE:1.5
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.5.0.8
	OPENBSD_3_6_BASE:1.5
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.5.0.6
	OPENBSD_3_5_BASE:1.5
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.6
date	2009.10.12.18.24.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.23;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.05;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.45;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.56.43;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.35;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.18;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2009.10.12.18.10.49;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.6
log
@Merge in perl 5.10.1
@
text
@package FileHandle;

use 5.006;
use strict;
our($VERSION, @@ISA, @@EXPORT, @@EXPORT_OK);

$VERSION = "2.02";

require IO::File;
@@ISA = qw(IO::File);

@@EXPORT = qw(_IOFBF _IOLBF _IONBF);

@@EXPORT_OK = qw(
    pipe

    autoflush
    output_field_separator
    output_record_separator
    input_record_separator
    input_line_number
    format_page_number
    format_lines_per_page
    format_lines_left
    format_name
    format_top_name
    format_line_break_characters
    format_formfeed

    print
    printf
    getline
    getlines
);

#
# Everything we're willing to export, we must first import.
#
import IO::Handle grep { !defined(&$_) } @@EXPORT, @@EXPORT_OK;

#
# Some people call "FileHandle::function", so all the functions
# that were in the old FileHandle class must be imported, too.
#
{
    no strict 'refs';

    my %import = (
	'IO::Handle' =>
	    [qw(DESTROY new_from_fd fdopen close fileno getc ungetc gets
		eof flush error clearerr setbuf setvbuf _open_mode_string)],
	'IO::Seekable' =>
	    [qw(seek tell getpos setpos)],
	'IO::File' =>
	    [qw(new new_tmpfile open)]
    );
    for my $pkg (keys %import) {
	for my $func (@@{$import{$pkg}}) {
	    my $c = *{"${pkg}::$func"}{CODE}
		or die "${pkg}::$func missing";
	    *$func = $c;
	}
    }
}

#
# Specialized importer for Fcntl magic.
#
sub import {
    my $pkg = shift;
    my $callpkg = caller;
    require Exporter;
    Exporter::export($pkg, $callpkg, @@_);

    #
    # If the Fcntl extension is available,
    #  export its constants.
    #
    eval {
	require Fcntl;
	Exporter::export('Fcntl', $callpkg);
    };
}

################################################
# This is the only exported function we define;
# the rest come from other classes.
#

sub pipe {
    my $r = new IO::Handle;
    my $w = new IO::Handle;
    CORE::pipe($r, $w) or return undef;
    ($r, $w);
}

# Rebless standard file handles
bless *STDIN{IO},  "FileHandle" if ref *STDIN{IO}  eq "IO::Handle";
bless *STDOUT{IO}, "FileHandle" if ref *STDOUT{IO} eq "IO::Handle";
bless *STDERR{IO}, "FileHandle" if ref *STDERR{IO} eq "IO::Handle";

1;

__END__

=head1 NAME

FileHandle - supply object methods for filehandles

=head1 SYNOPSIS

    use FileHandle;

    $fh = FileHandle->new;
    if ($fh->open("< file")) {
        print <$fh>;
        $fh->close;
    }

    $fh = FileHandle->new("> FOO");
    if (defined $fh) {
        print $fh "bar\n";
        $fh->close;
    }

    $fh = FileHandle->new("file", "r");
    if (defined $fh) {
        print <$fh>;
        undef $fh;       # automatically closes the file
    }

    $fh = FileHandle->new("file", O_WRONLY|O_APPEND);
    if (defined $fh) {
        print $fh "corge\n";
        undef $fh;       # automatically closes the file
    }

    $pos = $fh->getpos;
    $fh->setpos($pos);

    $fh->setvbuf($buffer_var, _IOLBF, 1024);

    ($readfh, $writefh) = FileHandle::pipe;

    autoflush STDOUT 1;

=head1 DESCRIPTION

NOTE: This class is now a front-end to the IO::* classes.

C<FileHandle::new> creates a C<FileHandle>, which is a reference to a
newly created symbol (see the C<Symbol> package).  If it receives any
parameters, they are passed to C<FileHandle::open>; if the open fails,
the C<FileHandle> object is destroyed.  Otherwise, it is returned to
the caller.

C<FileHandle::new_from_fd> creates a C<FileHandle> like C<new> does.
It requires two parameters, which are passed to C<FileHandle::fdopen>;
if the fdopen fails, the C<FileHandle> object is destroyed.
Otherwise, it is returned to the caller.

C<FileHandle::open> accepts one parameter or two.  With one parameter,
it is just a front end for the built-in C<open> function.  With two
parameters, the first parameter is a filename that may include
whitespace or other special characters, and the second parameter is
the open mode, optionally followed by a file permission value.

If C<FileHandle::open> receives a Perl mode string (">", "+<", etc.)
or a POSIX fopen() mode string ("w", "r+", etc.), it uses the basic
Perl C<open> operator.

If C<FileHandle::open> is given a numeric mode, it passes that mode
and the optional permissions value to the Perl C<sysopen> operator.
For convenience, C<FileHandle::import> tries to import the O_XXX
constants from the Fcntl module.  If dynamic loading is not available,
this may fail, but the rest of FileHandle will still work.

C<FileHandle::fdopen> is like C<open> except that its first parameter
is not a filename but rather a file handle name, a FileHandle object,
or a file descriptor number.

If the C functions fgetpos() and fsetpos() are available, then
C<FileHandle::getpos> returns an opaque value that represents the
current position of the FileHandle, and C<FileHandle::setpos> uses
that value to return to a previously visited position.

If the C function setvbuf() is available, then C<FileHandle::setvbuf>
sets the buffering policy for the FileHandle.  The calling sequence
for the Perl function is the same as its C counterpart, including the
macros C<_IOFBF>, C<_IOLBF>, and C<_IONBF>, except that the buffer
parameter specifies a scalar variable to use as a buffer.  WARNING: A
variable used as a buffer by C<FileHandle::setvbuf> must not be
modified in any way until the FileHandle is closed or until
C<FileHandle::setvbuf> is called again, or memory corruption may
result!

See L<perlfunc> for complete descriptions of each of the following
supported C<FileHandle> methods, which are just front ends for the
corresponding built-in functions:

    close
    fileno
    getc
    gets
    eof
    clearerr
    seek
    tell

See L<perlvar> for complete descriptions of each of the following
supported C<FileHandle> methods:

    autoflush
    output_field_separator
    output_record_separator
    input_record_separator
    input_line_number
    format_page_number
    format_lines_per_page
    format_lines_left
    format_name
    format_top_name
    format_line_break_characters
    format_formfeed

Furthermore, for doing normal I/O you might need these:

=over 4

=item $fh->print

See L<perlfunc/print>.

=item $fh->printf

See L<perlfunc/printf>.

=item $fh->getline

This works like <$fh> described in L<perlop/"I/O Operators">
except that it's more readable and can be safely called in a
list context but still returns just one line.

=item $fh->getlines

This works like <$fh> when called in a list context to
read all the remaining lines in a file, except that it's more readable.
It will also croak() if accidentally called in a scalar context.

=back

There are many other functions available since FileHandle is descended
from IO::File, IO::Seekable, and IO::Handle.  Please see those
respective pages for documentation on more functions.

=head1 SEE ALSO

The B<IO> extension,
L<perlfunc>, 
L<perlop/"I/O Operators">.

=cut
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d7 1
a7 1
$VERSION = "2.01";
d114 1
a114 1
    $fh = new FileHandle;
d120 1
a120 1
    $fh = new FileHandle "> FOO";
d126 1
a126 1
    $fh = new FileHandle "file", "r";
d132 1
a132 1
    $fh = new FileHandle "file", O_WRONLY|O_APPEND;
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d3 1
a3 1
use 5.005_64;
d7 1
a7 1
$VERSION = "2.00";
d228 1
a228 1
=over 
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d241 2
a242 2
except that it's more readable and can be safely called in an
array context but still returns just one line.
d246 1
a246 1
This works like <$fh> when called in an array context to
@


1.2
log
@perl5.005_03 (stock)
@
text
@d3 1
a3 1
use 5.003_11;
d5 1
a5 1
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK);
@


1.1
log
@perl 5.004_04
@
text
@d115 1
a115 1
    if ($fh->open "< file") {
d251 4
@


1.1.1.1
log
@perl5.005_03
@
text
@d115 1
a115 1
    if ($fh->open("< file")) {
a250 4

There are many other functions available since FileHandle is descended
from IO::File, IO::Seekable, and IO::Handle.  Please see those
respective pages for documentation on more functions.
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d3 1
a3 1
use 5.005_64;
d5 1
a5 1
our($VERSION, @@ISA, @@EXPORT, @@EXPORT_OK);
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@d241 2
a242 2
except that it's more readable and can be safely called in a
list context but still returns just one line.
d246 1
a246 1
This works like <$fh> when called in a list context to
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d3 1
a3 1
use 5.006;
d7 1
a7 1
$VERSION = "2.01";
d228 1
a228 1
=over 4
@


1.1.1.5
log
@import perl 5.10.1
@
text
@d7 1
a7 1
$VERSION = "2.02";
d114 1
a114 1
    $fh = FileHandle->new;
d120 1
a120 1
    $fh = FileHandle->new("> FOO");
d126 1
a126 1
    $fh = FileHandle->new("file", "r");
d132 1
a132 1
    $fh = FileHandle->new("file", O_WRONLY|O_APPEND);
@


