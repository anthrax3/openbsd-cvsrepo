head	1.8;
access;
symbols
	OPENBSD_6_1_BASE:1.8
	OPENBSD_6_0:1.7.0.8
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.7.0.2
	OPENBSD_5_9_BASE:1.7
	OPENBSD_5_8:1.7.0.4
	OPENBSD_5_8_BASE:1.7
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.5.0.2
	OPENBSD_5_7_BASE:1.5
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.3.0.4
	OPENBSD_5_6_BASE:1.3
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.2.0.6
	OPENBSD_5_5_BASE:1.2
	OPENBSD_5_4:1.2.0.2
	OPENBSD_5_4_BASE:1.2
	PERL_5_16_3:1.1.1.7
	OPENBSD_5_3:1.1.1.6.0.10
	OPENBSD_5_3_BASE:1.1.1.6
	OPENBSD_5_2:1.1.1.6.0.8
	OPENBSD_5_2_BASE:1.1.1.6
	OPENBSD_5_1_BASE:1.1.1.6
	OPENBSD_5_1:1.1.1.6.0.6
	OPENBSD_5_0:1.1.1.6.0.4
	OPENBSD_5_0_BASE:1.1.1.6
	OPENBSD_4_9:1.1.1.6.0.2
	OPENBSD_4_9_BASE:1.1.1.6
	PERL_5_12_2:1.1.1.6
	OPENBSD_4_8:1.1.1.5.0.8
	OPENBSD_4_8_BASE:1.1.1.5
	OPENBSD_4_7:1.1.1.5.0.4
	OPENBSD_4_7_BASE:1.1.1.5
	PERL_5_10_1:1.1.1.5
	OPENBSD_4_6:1.1.1.5.0.6
	OPENBSD_4_6_BASE:1.1.1.5
	OPENBSD_4_5:1.1.1.5.0.2
	OPENBSD_4_5_BASE:1.1.1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.1.1.4.0.10
	OPENBSD_4_4_BASE:1.1.1.4
	OPENBSD_4_3:1.1.1.4.0.8
	OPENBSD_4_3_BASE:1.1.1.4
	OPENBSD_4_2:1.1.1.4.0.6
	OPENBSD_4_2_BASE:1.1.1.4
	OPENBSD_4_1:1.1.1.4.0.4
	OPENBSD_4_1_BASE:1.1.1.4
	OPENBSD_4_0:1.1.1.4.0.2
	OPENBSD_4_0_BASE:1.1.1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.1.1.3.0.8
	OPENBSD_3_9_BASE:1.1.1.3
	OPENBSD_3_8:1.1.1.3.0.6
	OPENBSD_3_8_BASE:1.1.1.3
	OPENBSD_3_7:1.1.1.3.0.4
	OPENBSD_3_7_BASE:1.1.1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.1.1.3.0.2
	OPENBSD_3_6_BASE:1.1.1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.8
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.7;
commitid	cxJ08BvJA9Pt2PTM;

1.7
date	2015.04.25.19.26.22;	author afresh1;	state Exp;
branches;
next	1.6;
commitid	3qGYFVvfrExB70FB;

1.6
date	2015.04.25.19.14.47;	author afresh1;	state Exp;
branches;
next	1.5;
commitid	XRK22kO4se3v2i2I;

1.5
date	2014.11.17.21.01.00;	author afresh1;	state Exp;
branches;
next	1.4;
commitid	LnErp1MFKSuew5Fr;

1.4
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.3;
commitid	QP75iYx42Uo7mMxO;

1.3
date	2014.03.24.15.05.27;	author afresh1;	state Exp;
branches;
next	1.2;

1.2
date	2013.03.25.20.40.55;	author sthen;	state Exp;
branches;
next	1.1;

1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.43.59;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2004.08.09.17.46.44;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2006.03.28.18.48.36;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2010.09.24.14.48.38;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2013.03.25.20.08.52;	author sthen;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2014.03.24.14.59.03;	author afresh1;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.07;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.8
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@#!./perl -wT

# This tests plain 'use locale' and adorned 'use locale ":not_characters"'
# Because these pragmas are compile time, and I (khw) am trying to test
# without using 'eval' as much as possible, which might cloud the issue,  the
# crucial parts of the code are duplicated in a block for each pragma.

# To make a TODO test, add the string 'TODO' to its %test_names value

my $is_ebcdic = ord("A") == 193;

no warnings 'locale';  # We test even weird locales; and do some scary things
                       # in ok locales

binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

BEGIN {
    chdir 't' if -d 't';
    @@INC = '../lib';
    unshift @@INC, '.';
    require './loc_tools.pl';
    unless (locales_enabled('LC_CTYPE')) {
	print "1..0\n";
	exit;
    }
    $| = 1;
    require Config; import Config;
}

use strict;
use feature 'fc', 'postderef';

# =1 adds debugging output; =2 increases the verbosity somewhat
my $debug = $ENV{PERL_DEBUG_FULL_TEST} // 0;

# Certain tests have been shown to be problematical for a few locales.  Don't
# fail them unless at least this percentage of the tested locales fail.
# On AIX machines, many locales call a no-break space a graphic.
# (There aren't 1000 locales currently in existence, so 99.9 works)
my $acceptable_failure_percentage = ($^O =~ / ^ ( AIX ) $ /ix)
                                     ? 99.9
                                     : 5;

# The list of test numbers of the problematic tests.
my %problematical_tests;

# If any %problematical_tests fails in one of these locales, it is
# considered a TODO.
my %known_bad_locales = (
                          irix => qr/ ^ (?: cs | hu | sk ) $/x,
                          darwin => qr/ ^ lt_LT.ISO8859 /ix,
                          os390 => qr/ ^ italian /ix,
                        );

# cygwin isn't returning proper radix length in this locale, but supposedly to
# be fixed in later versions.
if ($^O eq 'cygwin' && version->new(($Config{osvers} =~ /^(\d+(?:\.\d+)+)/)[0]) le v2.4.1) {
    $known_bad_locales{'cygwin'} = qr/ ^ ps_AF /ix;
}

use Dumpvalue;

my $dumper = Dumpvalue->new(
                            tick => qq{"},
                            quoteHighBit => 0,
                            unctrl => "quote"
                           );
sub debug {
  return unless $debug;
  my($mess) = join "", '# ', @@_;
  chomp $mess;
  print STDERR $dumper->stringify($mess,1), "\n";
}

sub debug_more {
  return unless $debug > 1;
  return debug(@@_);
}

sub debugf {
    printf STDERR @@_ if $debug;
}

$a = 'abc %9';

my $test_num = 0;

sub ok {
    my ($result, $message) = @@_;
    $message = "" unless defined $message;

    print 'not ' unless ($result);
    print "ok " . ++$test_num;
    print " $message";
    print "\n";
    return ($result) ? 1 : 0;
}

# First we'll do a lot of taint checking for locales.
# This is the easiest to test, actually, as any locale,
# even the default locale will taint under 'use locale'.

sub is_tainted { # hello, camel two.
    no warnings 'uninitialized' ;
    my $dummy;
    local $@@;
    not eval { $dummy = join("", @@_), kill 0; 1 }
}

sub check_taint ($;$) {
    my $message_tail = $_[1] // "";

    # Extra blanks are so aligns with taint_not output
    $message_tail = ":     $message_tail" if $message_tail;
    ok is_tainted($_[0]), "verify that is tainted$message_tail";
}

sub check_taint_not ($;$) {
    my $message_tail = $_[1] // "";
    $message_tail = ":  $message_tail" if $message_tail;
    ok((not is_tainted($_[0])), "verify that isn't tainted$message_tail");
}

foreach my $category (qw(ALL COLLATE CTYPE MESSAGES MONETARY NUMERIC TIME)) {
    my $short_result = locales_enabled($category);
    ok ($short_result == 0 || $short_result == 1,
        "Verify locales_enabled('$category') returns 0 or 1");
    debug("locales_enabled('$category') returned '$short_result'");
    my $long_result = locales_enabled("LC_$category");
    if (! ok ($long_result == $short_result,
              "   and locales_enabled('LC_$category') returns "
            . "the same value")
    ) {
        debug("locales_enabled('LC_$category') returned $long_result");
    }
}

"\tb\t" =~ /^m?(\s)(.*)\1$/;
check_taint_not   $&, "not tainted outside 'use locale'";
;

use locale;	# engage locale and therefore locale taint.

# BE SURE TO COPY ANYTHING YOU ADD to these tests to the block below for
# ":notcharacters"

check_taint_not   $a, '$a';

check_taint       uc($a), 'uc($a)';
check_taint       "\U$a", '"\U$a"';
check_taint       ucfirst($a), 'ucfirst($a)';
check_taint       "\u$a", '"\u$a"';
check_taint       lc($a), 'lc($a)';
check_taint       fc($a), 'fc($a)';
check_taint       "\L$a", '"\L$a"';
check_taint       "\F$a", '"\F$a"';
check_taint       lcfirst($a), 'lcfirst($a)';
check_taint       "\l$a", '"\l$a"';

check_taint_not  sprintf('%e', 123.456), "sprintf('%e', 123.456)";
check_taint_not  sprintf('%f', 123.456), "sprintf('%f', 123.456)";
check_taint_not  sprintf('%g', 123.456), "sprintf('%g', 123.456)";
check_taint_not  sprintf('%d', 123.456), "sprintf('%d', 123.456)";
check_taint_not  sprintf('%x', 123.456), "sprintf('%x', 123.456)";

$_ = $a;	# untaint $_

$_ = uc($a);	# taint $_

check_taint      $_, '$_ = uc($a)';

/(\w)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /(\\w)/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /(.)/";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(\W)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /(\\W)/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /(.)/";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(\s)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /(\\s)/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /(.)/";

/(\S)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /(\\S)/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /(.)/";

"0" =~ /(\d)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /(\\d)/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /(.)/";

/(\D)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /(\\D)/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /(.)/";

/([[:alnum:]])/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /([[:alnum:]])/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /(.)/";

/([[:^alnum:]])/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /([[:^alnum:]])/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

"a" =~ /(a)|(\w)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /(a)|(\\w)/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
ok($1 eq 'a', ("\t" x 5) . "\$1 is 'a'");
ok(! defined $2, ("\t" x 5) . "\$2 is undefined");
check_taint_not  $2, "\t\$2";
check_taint_not  $3, "\t\$3";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /(.)/";

"\N{CYRILLIC SMALL LETTER A}" =~ /(\N{CYRILLIC CAPITAL LETTER A})/i;	# no tainting because no locale dependence
check_taint_not      $&, "\$& from /(\\N{CYRILLIC CAPITAL LETTER A})/i";
check_taint_not      $`, "\t\$`";
check_taint_not      $', "\t\$'";
check_taint_not      $+, "\t\$+";
check_taint_not      $1, "\t\$1";
ok($1 eq "\N{CYRILLIC SMALL LETTER A}", ("\t" x 4) . "\t\$1 is 'small cyrillic a'");
check_taint_not      $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /./";

"(\N{KELVIN SIGN})" =~ /(\N{KELVIN SIGN})/i;	# taints because depends on locale
check_taint      $&, "\$& from /(\\N{KELVIN SIGN})/i";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not      $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /(.)/";

"a:" =~ /(.)\b(.)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /(.)\\b(.)/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint      $2, "\t\$2";
check_taint_not  $3, "\t\$3";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /./";

"aa" =~ /(.)\B(.)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\$& from /(.)\\B(.)/";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint      $2, "\t\$2";
check_taint_not  $3, "\t\$3";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$& from /./";

"aaa" =~ /(.).(\1)/i;	# notaint because not locale dependent
check_taint_not      $&, "\$ & from /(.).(\\1)/";
check_taint_not      $`, "\t\$`";
check_taint_not      $', "\t\$'";
check_taint_not      $+, "\t\$+";
check_taint_not      $1, "\t\$1";
check_taint_not      $2, "\t\$2";
check_taint_not      $3, "\t\$3";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\$ & from /./";

$_ = $a;	# untaint $_

check_taint_not  $_, 'untainting $_ works';

/(b)/;		# this must not taint
check_taint_not  $&, "\$ & from /(b)/";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";

$_ = $a;	# untaint $_

check_taint_not  $_, 'untainting $_ works';

$b = uc($a);	# taint $b
s/(.+)/$b/;	# this must taint only the $_

check_taint      $_, '$_ (wasn\'t tainted) from s/(.+)/$b/ where $b is tainted';
check_taint_not  $&, "\t\$&";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";

$_ = $a;	# untaint $_

s/(.+)/b/;	# this must not taint
check_taint_not  $_, '$_ (wasn\'t tainted) from s/(.+)/b/';
check_taint_not  $&, "\t\$&";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";

$b = $a;	# untaint $b

($b = $a) =~ s/\w/$&/;
check_taint      $b, '$b from ($b = $a) =~ s/\w/$&/';	# $b should be tainted.
check_taint_not  $a, '$a from ($b = $a) =~ s/\w/$&/';	# $a should be not.

$_ = $a;	# untaint $_

s/(\w)/\l$1/;	# this must taint
check_taint      $_, '$_ (wasn\'t tainted) from s/(\w)/\l$1/,';	# this must taint
check_taint      $&, "\t\$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

$_ = $a;	# untaint $_

s/(\w)/\L$1/;	# this must taint
check_taint      $_, '$_ (wasn\'t tainted) from s/(\w)/\L$1/,';
check_taint      $&, "\t\$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

$_ = $a;	# untaint $_

s/(\w)/\u$1/;	# this must taint
check_taint      $_, '$_ (wasn\'t tainted) from s/(\w)/\u$1/';
check_taint      $&, "\t\$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

$_ = $a;	# untaint $_

s/(\w)/\U$1/;	# this must taint
check_taint      $_, '$_ (wasn\'t tainted) from s/(\w)/\U$1/';
check_taint      $&, "\t\$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

# After all this tainting $a should be cool.

check_taint_not  $a, '$a still not tainted';

"a" =~ /([a-z])/;
check_taint_not $1, '"a" =~ /([a-z])/';
"foo.bar_baz" =~ /^(.*)[._](.*?)$/;  # Bug 120675
check_taint_not $1, '"foo.bar_baz" =~ /^(.*)[._](.*?)$/';

# BE SURE TO COPY ANYTHING YOU ADD to the block below

{   # This is just the previous tests copied here with a different
    # compile-time pragma.

    use locale ':not_characters'; # engage restricted locale with different
                                  # tainting rules
    check_taint_not   $a, '$a';

    check_taint_not   uc($a), 'uc($a)';
    check_taint_not   "\U$a", '"\U$a"';
    check_taint_not   ucfirst($a), 'ucfirst($a)';
    check_taint_not   "\u$a", '"\u$a"';
    check_taint_not   lc($a), 'lc($a)';
    check_taint_not   fc($a), 'fc($a)';
    check_taint_not   "\L$a", '"\L$a"';
    check_taint_not   "\F$a", '"\F$a"';
    check_taint_not   lcfirst($a), 'lcfirst($a)';
    check_taint_not   "\l$a", '"\l$a"';

    check_taint_not  sprintf('%e', 123.456), "sprintf('%e', 123.456)";
    check_taint_not  sprintf('%f', 123.456), "sprintf('%f', 123.456)";
    check_taint_not  sprintf('%g', 123.456), "sprintf('%g', 123.456)";
    check_taint_not  sprintf('%d', 123.456), "sprintf('%d', 123.456)";
    check_taint_not  sprintf('%x', 123.456), "sprintf('%x', 123.456)";

    $_ = $a;	# untaint $_

    $_ = uc($a);

    check_taint_not  $_, '$_ = uc($a)';

    /(\w)/;
    check_taint_not  $&, "\$& from /(\\w)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /(.)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    /(\W)/;
    check_taint_not  $&, "\$& from /(\\W)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /(.)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    /(\s)/;
    check_taint_not  $&, "\$& from /(\\s)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /(.)/";

    /(\S)/;
    check_taint_not  $&, "\$& from /(\\S)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /(.)/";

    "0" =~ /(\d)/;
    check_taint_not  $&, "\$& from /(\\d)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /(.)/";

    /(\D)/;
    check_taint_not  $&, "\$& from /(\\D)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /(.)/";

    /([[:alnum:]])/;
    check_taint_not  $&, "\$& from /([[:alnum:]])/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /(.)/";

    /([[:^alnum:]])/;
    check_taint_not  $&, "\$& from /([[:^alnum:]])/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    "a" =~ /(a)|(\w)/;
    check_taint_not  $&, "\$& from /(a)|(\\w)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    ok($1 eq 'a', ("\t" x 5) . "\$1 is 'a'");
    ok(! defined $2, ("\t" x 5) . "\$2 is undefined");
    check_taint_not  $2, "\t\$2";
    check_taint_not  $3, "\t\$3";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /(.)/";

    "\N{CYRILLIC SMALL LETTER A}" =~ /(\N{CYRILLIC CAPITAL LETTER A})/i;
    check_taint_not      $&, "\$& from /(\\N{CYRILLIC CAPITAL LETTER A})/i";
    check_taint_not      $`, "\t\$`";
    check_taint_not      $', "\t\$'";
    check_taint_not      $+, "\t\$+";
    check_taint_not      $1, "\t\$1";
    ok($1 eq "\N{CYRILLIC SMALL LETTER A}", ("\t" x 4) . "\t\$1 is 'small cyrillic a'");
    check_taint_not      $2, "\t\$2";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /./";

    "(\N{KELVIN SIGN})" =~ /(\N{KELVIN SIGN})/i;
    check_taint_not  $&, "\$& from /(\\N{KELVIN SIGN})/i";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not      $2, "\t\$2";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /(.)/";

    "a:" =~ /(.)\b(.)/;
    check_taint_not  $&, "\$& from /(.)\\b(.)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";
    check_taint_not  $3, "\t\$3";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /./";

    "aa" =~ /(.)\B(.)/;
    check_taint_not  $&, "\$& from /(.)\\B(.)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";
    check_taint_not  $3, "\t\$3";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$& from /./";

    "aaa" =~ /(.).(\1)/i;	# notaint because not locale dependent
    check_taint_not      $&, "\$ & from /(.).(\\1)/";
    check_taint_not      $`, "\t\$`";
    check_taint_not      $', "\t\$'";
    check_taint_not      $+, "\t\$+";
    check_taint_not      $1, "\t\$1";
    check_taint_not      $2, "\t\$2";
    check_taint_not      $3, "\t\$3";

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&, "\$ & from /./";

    $_ = $a;	# untaint $_

    check_taint_not  $_, 'untainting $_ works';

    /(b)/;
    check_taint_not  $&, "\$ & from /(b)/";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    $_ = $a;	# untaint $_

    check_taint_not  $_, 'untainting $_ works';

    s/(.+)/b/;
    check_taint_not  $_, '$_ (wasn\'t tainted) from s/(.+)/b/';
    check_taint_not  $&, "\t\$&";
    check_taint_not  $`, "\t\$`";
    check_taint_not  $', "\t\$'";
    check_taint_not  $+, "\t\$+";
    check_taint_not  $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    $b = $a;	# untaint $b

    ($b = $a) =~ s/\w/$&/;
    check_taint_not     $b, '$b from ($b = $a) =~ s/\w/$&/';
    check_taint_not  $a, '$a from ($b = $a) =~ s/\w/$&/';

    $_ = $a;	# untaint $_

    s/(\w)/\l$1/;
    check_taint_not     $_, '$_ (wasn\'t tainted) from s/(\w)/\l$1/,';	# this must taint
    check_taint_not     $&, "\t\$&";
    check_taint_not     $`, "\t\$`";
    check_taint_not     $', "\t\$'";
    check_taint_not     $+, "\t\$+";
    check_taint_not     $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    $_ = $a;	# untaint $_

    s/(\w)/\L$1/;
    check_taint_not     $_, '$_ (wasn\'t tainted) from s/(\w)/\L$1/,';
    check_taint_not     $&, "\t\$&";
    check_taint_not     $`, "\t\$`";
    check_taint_not     $', "\t\$'";
    check_taint_not     $+, "\t\$+";
    check_taint_not     $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    $_ = $a;	# untaint $_

    s/(\w)/\u$1/;
    check_taint_not     $_, '$_ (wasn\'t tainted) from s/(\w)/\u$1/';
    check_taint_not     $&, "\t\$&";
    check_taint_not     $`, "\t\$`";
    check_taint_not     $', "\t\$'";
    check_taint_not     $+, "\t\$+";
    check_taint_not     $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    $_ = $a;	# untaint $_

    s/(\w)/\U$1/;
    check_taint_not     $_, '$_ (wasn\'t tainted) from s/(\w)/\U$1/';
    check_taint_not     $&, "\t\$&";
    check_taint_not     $`, "\t\$`";
    check_taint_not     $', "\t\$'";
    check_taint_not     $+, "\t\$+";
    check_taint_not     $1, "\t\$1";
    check_taint_not  $2, "\t\$2";

    # After all this tainting $a should be cool.

    check_taint_not  $a, '$a still not tainted';

    "a" =~ /([a-z])/;
    check_taint_not $1, '"a" =~ /([a-z])/';
    "foo.bar_baz" =~ /^(.*)[._](.*?)$/;  # Bug 120675
    check_taint_not $1, '"foo.bar_baz" =~ /^(.*)[._](.*?)$/';

}

# Here are in scope of 'use locale'

# I think we've seen quite enough of taint.
# Let us do some *real* locale work now,
# unless setlocale() is missing (i.e. minitest).

# The test number before our first setlocale()
my $final_without_setlocale = $test_num;

# Find locales.

debug "Scanning for locales...\n";

require POSIX; import POSIX ':locale_h';

my @@Locale = find_locales([ &POSIX::LC_CTYPE, &POSIX::LC_NUMERIC, &POSIX::LC_ALL ]);

debug "Locales =\n";
for ( @@Locale ) {
    debug "$_\n";
}

unless (@@Locale) {
    print "1..$test_num\n";
    exit;
}


setlocale(&POSIX::LC_ALL, "C");

my %posixes;

my %Problem;
my %Okay;
my %Known_bad_locale;   # Failed test for a locale known to be bad
my %Testing;
my @@Added_alpha;   # Alphas that aren't in the C locale.
my %test_names;

sub disp_chars {
    # This returns a display string denoting the input parameter @@_, each
    # entry of which is a single character in the range 0-255.  The first part
    # of the output is a string of the characters in @@_ that are ASCII
    # graphics, and hence unambiguously displayable.  They are given by code
    # point order.  The second part is the remaining code points, the ordinals
    # of which are each displayed as 2-digit hex.  Blanks are inserted so as
    # to keep anything from the first part looking like a 2-digit hex number.

    no locale;
    my @@chars = sort { ord $a <=> ord $b } @@_;
    my $output = "";
    my $range_start;
    my $start_class;
    push @@chars, chr(258);  # This sentinel simplifies the loop termination
                            # logic
    foreach my $i (0 .. @@chars - 1) {
        my $char = $chars[$i];
        my $range_end;
        my $class;

        # We avoid using [:posix:] classes, as these are being tested in this
        # file.  Each equivalence class below is for things that can appear in
        # a range; those that can't be in a range have class -1.  0 for those
        # which should be output in hex; and >0 for the other ranges
        if ($char =~ /[A-Z]/) {
            $class = 2;
        }
        elsif ($char =~ /[a-z]/) {
            $class = 3;
        }
        elsif ($char =~ /[0-9]/) {
            $class = 4;
        }
        # Uncomment to get literal punctuation displayed instead of hex
        #elsif ($char =~ /[[\]!"#\$\%&\'()*+,.\/:\\;<=>?\@@\^_`{|}~-]/) {
        #    $class = -1;    # Punct never appears in a range
        #}
        else {
            $class = 0;     # Output in hex
        }

        if (! defined $range_start) {
            if ($class < 0) {
                $output .= " " . $char;
            }
            else {
                $range_start = ord $char;
                $start_class = $class;
            }
        } # A range ends if not consecutive, or the class-type changes
        elsif (ord $char != ($range_end = ord($chars[$i-1])) + 1
              || $class != $start_class)
        {

            # Here, the current character is not in the range.  This means the
            # previous character must have been.  Output the range up through
            # that one.
            my $range_length = $range_end - $range_start + 1;
            if ($start_class > 0) {
                $output .= " " . chr($range_start);
                $output .= "-" . chr($range_end) if $range_length > 1;
            }
            else {
                $output .= sprintf(" %02X", $range_start);
                $output .= sprintf("-%02X", $range_end) if $range_length > 1;
            }

            # Handle the new current character, as potentially beginning a new
            # range
            undef $range_start;
            redo;
        }
    }

    $output =~ s/^ //;
    return $output;
}

sub disp_str ($) {
    my $string = shift;

    # Displays the string unambiguously.  ASCII printables are always output
    # as-is, though perhaps separated by blanks from other characters.  If
    # entirely printable ASCII, just returns the string.  Otherwise if valid
    # UTF-8 it uses the character names for non-printable-ASCII.  Otherwise it
    # outputs hex for each non-ASCII-printable byte.

    return $string if $string =~ / ^ [[:print:]]* $/xa;

    my $result = "";
    my $prev_was_punct = 1; # Beginning is considered punct
    if (utf8::valid($string) && utf8::is_utf8($string)) {
        use charnames ();
        foreach my $char (split "", $string) {

            # Keep punctuation adjacent to other characters; otherwise
            # separate them with a blank
            if ($char =~ /[[:punct:]]/a) {
                $result .= $char;
                $prev_was_punct = 1;
            }
            elsif ($char =~ /[[:print:]]/a) {
                $result .= "  " unless $prev_was_punct;
                $result .= $char;
                $prev_was_punct = 0;
            }
            else {
                $result .= "  " unless $prev_was_punct;
                my $name = charnames::viacode(ord $char);
                $result .= (defined $name) ? $name : ':unknown:';
                $prev_was_punct = 0;
            }
        }
    }
    else {
        use bytes;
        foreach my $char (split "", $string) {
            if ($char =~ /[[:punct:]]/a) {
                $result .= $char;
                $prev_was_punct = 1;
            }
            elsif ($char =~ /[[:print:]]/a) {
                $result .= " " unless $prev_was_punct;
                $result .= $char;
                $prev_was_punct = 0;
            }
            else {
                $result .= " " unless $prev_was_punct;
                $result .= sprintf("%02X", ord $char);
                $prev_was_punct = 0;
            }
        }
    }

    return $result;
}

sub report_result {
    my ($Locale, $i, $pass_fail, $message) = @@_;
    $message //= "";
    $message = "  ($message)" if $message;
    if ($pass_fail) {
	push @@{$Okay{$i}}, $Locale;
    }
    else {
	$Known_bad_locale{$i}{$Locale} = 1 if exists $known_bad_locales{$^O}
                                         && $Locale =~ $known_bad_locales{$^O};
	$Problem{$i}{$Locale} = 1;
	debug "failed $i ($test_names{$i}) with locale '$Locale'$message\n";
    }
}

sub report_multi_result {
    my ($Locale, $i, $results_ref) = @@_;

    # $results_ref points to an array, each element of which is a character that was
    # in error for this test numbered '$i'.  If empty, the test passed

    my $message = "";
    if (@@$results_ref) {
        $message = join " ", "for", disp_chars(@@$results_ref);
    }
    report_result($Locale, $i, @@$results_ref == 0, $message);
}

my $first_locales_test_number = $final_without_setlocale + 1;
my $locales_test_number;
my $not_necessarily_a_problem_test_number;
my $first_casing_test_number;
my %setlocale_failed;   # List of locales that setlocale() didn't work on

foreach my $Locale (@@Locale) {
    $locales_test_number = $first_locales_test_number - 1;
    debug "\n";
    debug "Locale = $Locale\n";

    unless (setlocale(&POSIX::LC_ALL, $Locale)) {
        $setlocale_failed{$Locale} = $Locale;
	next;
    }

    # We test UTF-8 locales only under ':not_characters';  It is easier to
    # test them in other test files than here.  Non- UTF-8 locales are tested
    # only under plain 'use locale', as otherwise we would have to convert
    # everything in them to Unicode.

    my %UPPER = ();     # All alpha X for which uc(X) == X and lc(X) != X
    my %lower = ();     # All alpha X for which lc(X) == X and uc(X) != X
    my %BoThCaSe = ();  # All alpha X for which uc(X) == lc(X) == X

    my $is_utf8_locale = is_locale_utf8($Locale);

    debug "is utf8 locale? = $is_utf8_locale\n";

    debug "radix = " . disp_str(localeconv()->{decimal_point}) . "\n";

    if (! $is_utf8_locale) {
        use locale;
        @@{$posixes{'word'}} = grep /\w/, map { chr } 0..255;
        @@{$posixes{'digit'}} = grep /\d/, map { chr } 0..255;
        @@{$posixes{'space'}} = grep /\s/, map { chr } 0..255;
        @@{$posixes{'alpha'}} = grep /[[:alpha:]]/, map {chr } 0..255;
        @@{$posixes{'alnum'}} = grep /[[:alnum:]]/, map {chr } 0..255;
        @@{$posixes{'ascii'}} = grep /[[:ascii:]]/, map {chr } 0..255;
        @@{$posixes{'blank'}} = grep /[[:blank:]]/, map {chr } 0..255;
        @@{$posixes{'cntrl'}} = grep /[[:cntrl:]]/, map {chr } 0..255;
        @@{$posixes{'graph'}} = grep /[[:graph:]]/, map {chr } 0..255;
        @@{$posixes{'lower'}} = grep /[[:lower:]]/, map {chr } 0..255;
        @@{$posixes{'print'}} = grep /[[:print:]]/, map {chr } 0..255;
        @@{$posixes{'punct'}} = grep /[[:punct:]]/, map {chr } 0..255;
        @@{$posixes{'upper'}} = grep /[[:upper:]]/, map {chr } 0..255;
        @@{$posixes{'xdigit'}} = grep /[[:xdigit:]]/, map {chr } 0..255;
        @@{$posixes{'cased'}} = grep /[[:upper:]]/i, map {chr } 0..255;

        # Sieve the uppercase and the lowercase.

        for (@@{$posixes{'word'}}) {
            if (/[^\d_]/) { # skip digits and the _
                if (uc($_) eq $_) {
                    $UPPER{$_} = $_;
                }
                if (lc($_) eq $_) {
                    $lower{$_} = $_;
                }
            }
        }
    }
    else {
        use locale ':not_characters';
        @@{$posixes{'word'}} = grep /\w/, map { chr } 0..255;
        @@{$posixes{'digit'}} = grep /\d/, map { chr } 0..255;
        @@{$posixes{'space'}} = grep /\s/, map { chr } 0..255;
        @@{$posixes{'alpha'}} = grep /[[:alpha:]]/, map {chr } 0..255;
        @@{$posixes{'alnum'}} = grep /[[:alnum:]]/, map {chr } 0..255;
        @@{$posixes{'ascii'}} = grep /[[:ascii:]]/, map {chr } 0..255;
        @@{$posixes{'blank'}} = grep /[[:blank:]]/, map {chr } 0..255;
        @@{$posixes{'cntrl'}} = grep /[[:cntrl:]]/, map {chr } 0..255;
        @@{$posixes{'graph'}} = grep /[[:graph:]]/, map {chr } 0..255;
        @@{$posixes{'lower'}} = grep /[[:lower:]]/, map {chr } 0..255;
        @@{$posixes{'print'}} = grep /[[:print:]]/, map {chr } 0..255;
        @@{$posixes{'punct'}} = grep /[[:punct:]]/, map {chr } 0..255;
        @@{$posixes{'upper'}} = grep /[[:upper:]]/, map {chr } 0..255;
        @@{$posixes{'xdigit'}} = grep /[[:xdigit:]]/, map {chr } 0..255;
        @@{$posixes{'cased'}} = grep /[[:upper:]]/i, map {chr } 0..255;
        for (@@{$posixes{'word'}}) {
            if (/[^\d_]/) { # skip digits and the _
                if (uc($_) eq $_) {
                    $UPPER{$_} = $_;
                }
                if (lc($_) eq $_) {
                    $lower{$_} = $_;
                }
            }
        }
    }

    # Ordered, where possible,  in groups of "this is a subset of the next
    # one"
    debug ":upper:  = ", disp_chars(@@{$posixes{'upper'}}), "\n";
    debug ":lower:  = ", disp_chars(@@{$posixes{'lower'}}), "\n";
    debug ":cased:  = ", disp_chars(@@{$posixes{'cased'}}), "\n";
    debug ":alpha:  = ", disp_chars(@@{$posixes{'alpha'}}), "\n";
    debug ":alnum:  = ", disp_chars(@@{$posixes{'alnum'}}), "\n";
    debug " w       = ", disp_chars(@@{$posixes{'word'}}), "\n";
    debug ":graph:  = ", disp_chars(@@{$posixes{'graph'}}), "\n";
    debug ":print:  = ", disp_chars(@@{$posixes{'print'}}), "\n";
    debug " d       = ", disp_chars(@@{$posixes{'digit'}}), "\n";
    debug ":xdigit: = ", disp_chars(@@{$posixes{'xdigit'}}), "\n";
    debug ":blank:  = ", disp_chars(@@{$posixes{'blank'}}), "\n";
    debug " s       = ", disp_chars(@@{$posixes{'space'}}), "\n";
    debug ":punct:  = ", disp_chars(@@{$posixes{'punct'}}), "\n";
    debug ":cntrl:  = ", disp_chars(@@{$posixes{'cntrl'}}), "\n";
    debug ":ascii:  = ", disp_chars(@@{$posixes{'ascii'}}), "\n";

    foreach (keys %UPPER) {

	$BoThCaSe{$_}++ if exists $lower{$_};
    }
    foreach (keys %lower) {
	$BoThCaSe{$_}++ if exists $UPPER{$_};
    }
    foreach (keys %BoThCaSe) {
	delete $UPPER{$_};
	delete $lower{$_};
    }

    my %Unassigned;
    foreach my $ord ( 0 .. 255 ) {
        $Unassigned{chr $ord} = 1;
    }
    foreach my $class (keys %posixes) {
        foreach my $char (@@{$posixes{$class}}) {
            delete $Unassigned{$char};
        }
    }

    debug "UPPER    = ", disp_chars(sort { ord $a <=> ord $b } keys %UPPER), "\n";
    debug "lower    = ", disp_chars(sort { ord $a <=> ord $b } keys %lower), "\n";
    debug "BoThCaSe = ", disp_chars(sort { ord $a <=> ord $b } keys %BoThCaSe), "\n";
    debug "Unassigned = ", disp_chars(sort { ord $a <=> ord $b } keys %Unassigned), "\n";

    my @@failures;
    my @@fold_failures;
    foreach my $x (sort { ord $a <=> ord $b } keys %UPPER) {
        my $ok;
        my $fold_ok;
        if ($is_utf8_locale) {
            use locale ':not_characters';
            $ok = $x =~ /[[:upper:]]/;
            $fold_ok = $x =~ /[[:lower:]]/i;
        }
        else {
            use locale;
            $ok = $x =~ /[[:upper:]]/;
            $fold_ok = $x =~ /[[:lower:]]/i;
        }
        push @@failures, $x unless $ok;
        push @@fold_failures, $x unless $fold_ok;
    }
    $locales_test_number++;
    $first_casing_test_number = $locales_test_number;
    $test_names{$locales_test_number} = 'Verify that /[[:upper:]]/ matches all alpha X for which uc(X) == X and lc(X) != X';
    report_multi_result($Locale, $locales_test_number, \@@failures);

    $locales_test_number++;

    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/i matches all alpha X for which uc(X) == X and lc(X) != X';
    report_multi_result($Locale, $locales_test_number, \@@fold_failures);

    undef @@failures;
    undef @@fold_failures;

    foreach my $x (sort { ord $a <=> ord $b } keys %lower) {
        my $ok;
        my $fold_ok;
        if ($is_utf8_locale) {
            use locale ':not_characters';
            $ok = $x =~ /[[:lower:]]/;
            $fold_ok = $x =~ /[[:upper:]]/i;
        }
        else {
            use locale;
            $ok = $x =~ /[[:lower:]]/;
            $fold_ok = $x =~ /[[:upper:]]/i;
        }
        push @@failures, $x unless $ok;
        push @@fold_failures, $x unless $fold_ok;
    }

    $locales_test_number++;
    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/ matches all alpha X for which lc(X) == X and uc(X) != X';
    report_multi_result($Locale, $locales_test_number, \@@failures);

    $locales_test_number++;
    $test_names{$locales_test_number} = 'Verify that /[[:upper:]]/i matches all alpha X for which lc(X) == X and uc(X) != X';
    report_multi_result($Locale, $locales_test_number, \@@fold_failures);

    {   # Find the alphabetic characters that are not considered alphabetics
        # in the default (C) locale.

	no locale;

	@@Added_alpha = ();
	for (keys %UPPER, keys %lower, keys %BoThCaSe) {
	    push(@@Added_alpha, $_) if (/\W/);
	}
    }

    @@Added_alpha = sort { ord $a <=> ord $b } @@Added_alpha;

    debug "Added_alpha = ", disp_chars(@@Added_alpha), "\n";

    # Cross-check the whole 8-bit character set.

    ++$locales_test_number;
    my @@f;
    $test_names{$locales_test_number} = 'Verify that \w and [:word:] are identical';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ unless /[[:word:]]/ == /\w/;
        }
        else {
            push @@f, $_ unless /[[:word:]]/ == /\w/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that \d and [:digit:] are identical';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ unless /[[:digit:]]/ == /\d/;
        }
        else {
            push @@f, $_ unless /[[:digit:]]/ == /\d/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that \s and [:space:] are identical';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ unless /[[:space:]]/ == /\s/;
        }
        else {
            push @@f, $_ unless /[[:space:]]/ == /\s/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:posix:] and [:^posix:] are mutually exclusive';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ unless   (/[[:alpha:]]/ xor /[[:^alpha:]]/)   ||
                    (/[[:alnum:]]/ xor /[[:^alnum:]]/)   ||
                    (/[[:ascii:]]/ xor /[[:^ascii:]]/)   ||
                    (/[[:blank:]]/ xor /[[:^blank:]]/)   ||
                    (/[[:cntrl:]]/ xor /[[:^cntrl:]]/)   ||
                    (/[[:digit:]]/ xor /[[:^digit:]]/)   ||
                    (/[[:graph:]]/ xor /[[:^graph:]]/)   ||
                    (/[[:lower:]]/ xor /[[:^lower:]]/)   ||
                    (/[[:print:]]/ xor /[[:^print:]]/)   ||
                    (/[[:space:]]/ xor /[[:^space:]]/)   ||
                    (/[[:upper:]]/ xor /[[:^upper:]]/)   ||
                    (/[[:word:]]/  xor /[[:^word:]]/)    ||
                    (/[[:xdigit:]]/ xor /[[:^xdigit:]]/) ||

                    # effectively is what [:cased:] would be if it existed.
                    (/[[:upper:]]/i xor /[[:^upper:]]/i);
        }
        else {
            push @@f, $_ unless   (/[[:alpha:]]/ xor /[[:^alpha:]]/)   ||
                    (/[[:alnum:]]/ xor /[[:^alnum:]]/)   ||
                    (/[[:ascii:]]/ xor /[[:^ascii:]]/)   ||
                    (/[[:blank:]]/ xor /[[:^blank:]]/)   ||
                    (/[[:cntrl:]]/ xor /[[:^cntrl:]]/)   ||
                    (/[[:digit:]]/ xor /[[:^digit:]]/)   ||
                    (/[[:graph:]]/ xor /[[:^graph:]]/)   ||
                    (/[[:lower:]]/ xor /[[:^lower:]]/)   ||
                    (/[[:print:]]/ xor /[[:^print:]]/)   ||
                    (/[[:space:]]/ xor /[[:^space:]]/)   ||
                    (/[[:upper:]]/ xor /[[:^upper:]]/)   ||
                    (/[[:word:]]/  xor /[[:^word:]]/)    ||
                    (/[[:xdigit:]]/ xor /[[:^xdigit:]]/) ||
                    (/[[:upper:]]/i xor /[[:^upper:]]/i);
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    # The rules for the relationships are given in:
    # http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap07.html


    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:lower:] contains at least a-z';
    for ('a' .. 'z') {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:lower:]]/;
        }
        else {
            push @@f, $_  unless /[[:lower:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:lower:] is a subset of [:alpha:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  if /[[:lower:]]/ and ! /[[:alpha:]]/;
        }
        else {
            push @@f, $_  if /[[:lower:]]/ and ! /[[:alpha:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:upper:] contains at least A-Z';
    for ('A' .. 'Z') {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:upper:]]/;
        }
        else {
            push @@f, $_  unless /[[:upper:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:upper:] is a subset of [:alpha:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  if /[[:upper:]]/ and ! /[[:alpha:]]/;
        }
        else {
            push @@f, $_ if /[[:upper:]]/  and ! /[[:alpha:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/i is a subset of [:alpha:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:lower:]]/i  and ! /[[:alpha:]]/;
        }
        else {
            push @@f, $_ if /[[:lower:]]/i  and ! /[[:alpha:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:alpha:] is a subset of [:alnum:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:alpha:]]/  and ! /[[:alnum:]]/;
        }
        else {
            push @@f, $_ if /[[:alpha:]]/  and ! /[[:alnum:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:digit:] contains at least 0-9';
    for ('0' .. '9') {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:digit:]]/;
        }
        else {
            push @@f, $_  unless /[[:digit:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:digit:] is a subset of [:alnum:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:digit:]]/  and ! /[[:alnum:]]/;
        }
        else {
            push @@f, $_ if /[[:digit:]]/  and ! /[[:alnum:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:digit:] matches either 10 or 20 code points';
    report_result($Locale, $locales_test_number, @@{$posixes{'digit'}} == 10 || @@{$posixes{'digit'}} == 20);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that if there is a second set of digits in [:digit:], they are consecutive';
    if (@@{$posixes{'digit'}} == 20) {
        my $previous_ord;
        for (map { chr } 0..255) {
            next unless /[[:digit:]]/;
            next if /[0-9]/;
            if (defined $previous_ord) {
                if ($is_utf8_locale) {
                    use locale ':not_characters';
                    push @@f, $_ if ord $_ != $previous_ord + 1;
                }
                else {
                    push @@f, $_ if ord $_ != $previous_ord + 1;
                }
            }
            $previous_ord = ord $_;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    my @@xdigit_digits;  # :digit: & :xdigit:
    $test_names{$locales_test_number} = 'Verify that [:xdigit:] contains one or two blocks of 10 consecutive [:digit:] chars';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            # For utf8 locales, we actually use a stricter test: that :digit:
            # is a subset of :xdigit:, as we know that only 0-9 should match
            push @@f, $_ if /[[:digit:]]/ and ! /[[:xdigit:]]/;
        }
        else {
            push @@xdigit_digits, $_ if /[[:digit:]]/ and /[[:xdigit:]]/;
        }
    }
    if (! $is_utf8_locale) {

        # For non-utf8 locales, @@xdigit_digits is a list of the characters
        # that are both :xdigit: and :digit:.  Because :digit: is stored in
        # increasing code point order (unless the tests above failed),
        # @@xdigit_digits is as well.  There should be exactly 10 or
        # 20 of these.
        if (@@xdigit_digits != 10 && @@xdigit_digits != 20) {
            @@f = @@xdigit_digits;
        }
        else {

            # Look for contiguity in the series, adding any wrong ones to @@f
            my @@temp = @@xdigit_digits;
            while (@@temp > 1) {
                push @@f, $temp[1] if ($temp[0] != $temp[1] - 1)

                                     # Skip this test for the 0th character of
                                     # the second block of 10, as it won't be
                                     # contiguous with the previous block
                                     && (! defined $xdigit_digits[10]
                                         || $temp[1] != $xdigit_digits[10]);
                shift @@temp;
            }
        }
    }

    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:xdigit:] contains at least A-F, a-f';
    for ('A' .. 'F', 'a' .. 'f') {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:xdigit:]]/;
        }
        else {
            push @@f, $_  unless /[[:xdigit:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that any additional members of [:xdigit:], are in groups of 6 consecutive code points';
    my $previous_ord;
    my $count = 0;
    for my $chr (map { chr } 0..255) {
        next unless $chr =~ /[[:xdigit:]]/;
        if ($is_utf8_locale) {
            next if $chr =~ /[[:digit:]]/;
        }
        else {
            next if grep { $chr eq $_ } @@xdigit_digits;
        }
        next if $chr =~ /[A-Fa-f]/;
        if (defined $previous_ord) {
            if ($is_utf8_locale) {
                use locale ':not_characters';
                push @@f, $chr if ord $chr != $previous_ord + 1;
            }
            else {
                push @@f, $chr if ord $chr != $previous_ord + 1;
            }
        }
        $count++;
        if ($count == 6) {
            undef $previous_ord;
        }
        else {
            $previous_ord = ord $chr;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:xdigit:] is a subset of [:graph:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:xdigit:]]/  and ! /[[:graph:]]/;
        }
        else {
            push @@f, $_ if /[[:xdigit:]]/  and ! /[[:graph:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    # Note that xdigit doesn't have to be a subset of alnum

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:punct:] is a subset of [:graph:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:punct:]]/  and ! /[[:graph:]]/;
        }
        else {
            push @@f, $_ if /[[:punct:]]/  and ! /[[:graph:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that the space character is not in [:graph:]';
    if ($is_utf8_locale) {
        use locale ':not_characters';
        push @@f, " " if " " =~ /[[:graph:]]/;
    }
    else {
        push @@f, " " if " " =~ /[[:graph:]]/;
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:space:] contains at least [\f\n\r\t\cK ]';
    for (' ', "\f", "\n", "\r", "\t", "\cK") {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:space:]]/;
        }
        else {
            push @@f, $_  unless /[[:space:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:blank:] contains at least [\t ]';
    for (' ', "\t") {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:blank:]]/;
        }
        else {
            push @@f, $_  unless /[[:blank:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:blank:] is a subset of [:space:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:blank:]]/  and ! /[[:space:]]/;
        }
        else {
            push @@f, $_ if /[[:blank:]]/  and ! /[[:space:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:graph:] is a subset of [:print:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:graph:]]/  and ! /[[:print:]]/;
        }
        else {
            push @@f, $_ if /[[:graph:]]/  and ! /[[:print:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that the space character is in [:print:]';
    if ($is_utf8_locale) {
        use locale ':not_characters';
        push @@f, " " if " " !~ /[[:print:]]/;
    }
    else {
        push @@f, " " if " " !~ /[[:print:]]/;
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:cntrl:] and [:print:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if (/[[:print:]]/ and /[[:cntrl:]]/);
        }
        else {
            push @@f, $_ if (/[[:print:]]/ and /[[:cntrl:]]/);
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:alpha:] and [:digit:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:alpha:]]/ and /[[:digit:]]/;
        }
        else {
            push @@f, $_ if /[[:alpha:]]/ and /[[:digit:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:alnum:] and [:punct:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:alnum:]]/ and /[[:punct:]]/;
        }
        else {
            push @@f, $_ if /[[:alnum:]]/ and /[[:punct:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:xdigit:] and [:punct:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if (/[[:punct:]]/ and /[[:xdigit:]]/);
        }
        else {
            push @@f, $_ if (/[[:punct:]]/ and /[[:xdigit:]]/);
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:graph:] and [:space:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if (/[[:graph:]]/ and /[[:space:]]/);
        }
        else {
            push @@f, $_ if (/[[:graph:]]/ and /[[:space:]]/);
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    foreach ($first_casing_test_number..$locales_test_number) {
        $problematical_tests{$_} = 1;
    }


    # Test for read-only scalars' locale vs non-locale comparisons.

    {
        no locale;
        my $ok;
        $a = "qwerty";
        if ($is_utf8_locale) {
            use locale ':not_characters';
            $ok = ($a cmp "qwerty") == 0;
        }
        else {
            use locale;
            $ok = ($a cmp "qwerty") == 0;
        }
        report_result($Locale, ++$locales_test_number, $ok);
        $test_names{$locales_test_number} = 'Verify that cmp works with a read-only scalar; no- vs locale';
    }

    {
        my ($from, $to, $lesser, $greater,
            @@test, %test, $test, $yes, $no, $sign);

        ++$locales_test_number;
        $test_names{$locales_test_number} = 'Verify that "le", "ne", etc work';
        $not_necessarily_a_problem_test_number = $locales_test_number;
        for (0..9) {
            # Select a slice.
            $from = int(($_*@@{$posixes{'word'}})/10);
            $to = $from + int(@@{$posixes{'word'}}/10);
            $to = $#{$posixes{'word'}} if ($to > $#{$posixes{'word'}});
            $lesser  = join('', @@{$posixes{'word'}}[$from..$to]);
            # Select a slice one character on.
            $from++; $to++;
            $to = $#{$posixes{'word'}} if ($to > $#{$posixes{'word'}});
            $greater = join('', @@{$posixes{'word'}}[$from..$to]);
            if ($is_utf8_locale) {
                use locale ':not_characters';
                ($yes, $no, $sign) = ($lesser lt $greater
                                    ? ("    ", "not ", 1)
                                    : ("not ", "    ", -1));
            }
            else {
                use locale;
                ($yes, $no, $sign) = ($lesser lt $greater
                                    ? ("    ", "not ", 1)
                                    : ("not ", "    ", -1));
            }
            # all these tests should FAIL (return 0).  Exact lt or gt cannot
            # be tested because in some locales, say, eacute and E may test
            # equal.
            @@test =
                (
                    $no.'    ($lesser  le $greater)',  # 1
                    'not      ($lesser  ne $greater)', # 2
                    '         ($lesser  eq $greater)', # 3
                    $yes.'    ($lesser  ge $greater)', # 4
                    $yes.'    ($lesser  ge $greater)', # 5
                    $yes.'    ($greater le $lesser )', # 7
                    'not      ($greater ne $lesser )', # 8
                    '         ($greater eq $lesser )', # 9
                    $no.'     ($greater ge $lesser )', # 10
                    'not (($lesser cmp $greater) == -($sign))' # 11
                    );
            @@test{@@test} = 0 x @@test;
            $test = 0;
            for my $ti (@@test) {
                if ($is_utf8_locale) {
                    use locale ':not_characters';
                    $test{$ti} = eval $ti;
                }
                else {
                    # Already in 'use locale';
                    $test{$ti} = eval $ti;
                }
                $test ||= $test{$ti}
            }
            report_result($Locale, $locales_test_number, $test == 0);
            if ($test) {
                debug "lesser  = '$lesser'\n";
                debug "greater = '$greater'\n";
                debug "lesser cmp greater = ",
                        $lesser cmp $greater, "\n";
                debug "greater cmp lesser = ",
                        $greater cmp $lesser, "\n";
                debug "(greater) from = $from, to = $to\n";
                for my $ti (@@test) {
                    debugf("# %-40s %-4s", $ti,
                            $test{$ti} ? 'FAIL' : 'ok');
                    if ($ti =~ /\(\.*(\$.+ +cmp +\$[^\)]+)\.*\)/) {
                        debugf("(%s == %4d)", $1, eval $1);
                    }
                    debugf("\n#");
                }

                last;
            }
        }
    }

    my $ok1;
    my $ok2;
    my $ok3;
    my $ok4;
    my $ok5;
    my $ok6;
    my $ok7;
    my $ok8;
    my $ok9;
    my $ok10;
    my $ok11;
    my $ok12;
    my $ok13;
    my $ok14;
    my $ok14_5;
    my $ok15;
    my $ok16;
    my $ok17;
    my $ok18;
    my $ok19;
    my $ok20;
    my $ok21;

    my $c;
    my $d;
    my $e;
    my $f;
    my $g;
    my $h;
    my $i;
    my $j;

    if (! $is_utf8_locale) {
        use locale;

        my ($x, $y) = (1.23, 1.23);

        $a = "$x";
        printf ''; # printf used to reset locale to "C"
        $b = "$y";
        $ok1 = $a eq $b;

        $c = "$x";
        my $z = sprintf ''; # sprintf used to reset locale to "C"
        $d = "$y";
        $ok2 = $c eq $d;
        {

            use warnings;
            my $w = 0;
            local $SIG{__WARN__} =
                sub {
                    print "# @@_\n";
                    $w++;
                };

            # The == (among other ops) used to warn for locales
            # that had something else than "." as the radix character.

            $ok3 = $c == 1.23;
            $ok4 = $c == $x;
            $ok5 = $c == $d;
            {
                no locale;

                $e = "$x";

                $ok6 = $e == 1.23;
                $ok7 = $e == $x;
                $ok8 = $e == $c;
            }

            $f = "1.23";
            $g = 2.34;
            $h = 1.5;
            $i = 1.25;
            $j = "$h:$i";

            $ok9 = $f == 1.23;
            $ok10 = $f == $x;
            $ok11 = $f == $c;
            $ok12 = abs(($f + $g) - 3.57) < 0.01;
            $ok13 = $w == 0;
            $ok14 = $ok14_5 = $ok15 = $ok16 = 1;  # Skip for non-utf8 locales
        }
        {
            no locale;
            $ok17 = "1.5:1.25" eq sprintf("%g:%g", $h, $i);
        }
        $ok18 = $j eq sprintf("%g:%g", $h, $i);
    }
    else {
        use locale ':not_characters';

        my ($x, $y) = (1.23, 1.23);
        $a = "$x";
        printf ''; # printf used to reset locale to "C"
        $b = "$y";
        $ok1 = $a eq $b;

        $c = "$x";
        my $z = sprintf ''; # sprintf used to reset locale to "C"
        $d = "$y";
        $ok2 = $c eq $d;
        {
            use warnings;
            my $w = 0;
            local $SIG{__WARN__} =
                sub {
                    print "# @@_\n";
                    $w++;
                };
            $ok3 = $c == 1.23;
            $ok4 = $c == $x;
            $ok5 = $c == $d;
            {
                no locale;
                $e = "$x";

                $ok6 = $e == 1.23;
                $ok7 = $e == $x;
                $ok8 = $e == $c;
            }

            $f = "1.23";
            $g = 2.34;
            $h = 1.5;
            $i = 1.25;
            $j = "$h:$i";

            $ok9 = $f == 1.23;
            $ok10 = $f == $x;
            $ok11 = $f == $c;
            $ok12 = abs(($f + $g) - 3.57) < 0.01;
            $ok13 = $w == 0;

            # Look for non-ASCII error messages, and verify that the first
            # such is in UTF-8 (the others almost certainly will be like the
            # first).  This is only done if the current locale has LC_MESSAGES
            $ok14 = 1;
            $ok14_5 = 1;
            if (   locales_enabled('LC_MESSAGES')
                && setlocale(&POSIX::LC_MESSAGES, $Locale))
            {
                foreach my $err (keys %!) {
                    use Errno;
                    $! = eval "&Errno::$err";   # Convert to strerror() output
                    my $strerror = "$!";
                    if ("$strerror" =~ /\P{ASCII}/) {
                        $ok14 = utf8::is_utf8($strerror);
                        no locale;
                        $ok14_5 = "$!" !~ /\P{ASCII}/;
                        last;
                    }
                }
            }

            # Similarly, we verify that a non-ASCII radix is in UTF-8.  This
            # also catches if there is a disparity between sprintf and
            # stringification.

            my $string_g = "$g";
            my $sprintf_g = sprintf("%g", $g);

            $ok15 = $string_g =~ / ^ \p{ASCII}+ $ /x || utf8::is_utf8($string_g);
            $ok16 = $sprintf_g eq $string_g;
        }
        {
            no locale;
            $ok17 = "1.5:1.25" eq sprintf("%g:%g", $h, $i);
        }
        $ok18 = $j eq sprintf("%g:%g", $h, $i);
    }

    $ok19 = $ok20 = 1;
    if (setlocale(&POSIX::LC_TIME, $Locale)) { # These tests aren't affected by
                                               # :not_characters
        my @@times = CORE::localtime();

        use locale;
        $ok19 = POSIX::strftime("%p", @@times) ne "%p"; # [perl #119425]
        my $date = POSIX::strftime("'%A'  '%B'  '%Z'  '%p'", @@times);
        debug("'Day' 'Month' 'TZ' 'am/pm' = ", disp_str($date));

        # If there is any non-ascii, it better be UTF-8 in a UTF-8 locale, and
        # not UTF-8 if the locale isn't UTF-8.
        $ok20 = $date =~ / ^ \p{ASCII}+ $ /x
                || $is_utf8_locale == utf8::is_utf8($date);
    }

    $ok21 = 1;
    if (locales_enabled('LC_MESSAGES')) {
        foreach my $err (keys %!) {
            no locale;
            use Errno;
            $! = eval "&Errno::$err";   # Convert to strerror() output
            my $strerror = "$!";
            if ("$strerror" =~ /\P{ASCII}/) {
                $ok21 = 0;
                last;
            }
        }
    }

    report_result($Locale, ++$locales_test_number, $ok1);
    $test_names{$locales_test_number} = 'Verify that an intervening printf doesn\'t change assignment results';
    my $first_a_test = $locales_test_number;

    debug "$first_a_test..$locales_test_number: \$a = $a, \$b = $b, Locale = $Locale\n";

    report_result($Locale, ++$locales_test_number, $ok2);
    $test_names{$locales_test_number} = 'Verify that an intervening sprintf doesn\'t change assignment results';

    my $first_c_test = $locales_test_number;

    $test_names{++$locales_test_number} = 'Verify that a different locale radix works when doing "==" with a constant';
    if ($Config{usequadmath}) {
        print "# Skip: no locale radix with usequadmath ($test_names{$locales_test_number})\n";
        report_result($Locale, $locales_test_number, 1);
    } else {
        report_result($Locale, $locales_test_number, $ok3);
        $problematical_tests{$locales_test_number} = 1;
    }

    $test_names{++$locales_test_number} = 'Verify that a different locale radix works when doing "==" with a scalar';
    if ($Config{usequadmath}) {
        print "# Skip: no locale radix with usequadmath ($test_names{$locales_test_number})\n";
        report_result($Locale, $locales_test_number, 1);
    } else {
        report_result($Locale, $locales_test_number, $ok4);
        $problematical_tests{$locales_test_number} = 1;
    }

    report_result($Locale, ++$locales_test_number, $ok5);
    $test_names{$locales_test_number} = 'Verify that a different locale radix works when doing "==" with a scalar and an intervening sprintf';
    $problematical_tests{$locales_test_number} = 1;

    debug "$first_c_test..$locales_test_number: \$c = $c, \$d = $d, Locale = $Locale\n";

    report_result($Locale, ++$locales_test_number, $ok6);
    $test_names{$locales_test_number} = 'Verify that can assign stringified under inner no-locale block';
    my $first_e_test = $locales_test_number;

    report_result($Locale, ++$locales_test_number, $ok7);
    $test_names{$locales_test_number} = 'Verify that "==" with a scalar still works in inner no locale';

    $test_names{++$locales_test_number} = 'Verify that "==" with a scalar and an intervening sprintf still works in inner no locale';
    if ($Config{usequadmath}) {
        print "# Skip: no locale radix with usequadmath ($test_names{$locales_test_number})\n";
        report_result($Locale, $locales_test_number, 1);
    } else {
        report_result($Locale, $locales_test_number, $ok8);
        $problematical_tests{$locales_test_number} = 1;
    }

    debug "$first_e_test..$locales_test_number: \$e = $e, no locale\n";

    report_result($Locale, ++$locales_test_number, $ok9);
    $test_names{$locales_test_number} = 'Verify that after a no-locale block, a different locale radix still works when doing "==" with a constant';
    $problematical_tests{$locales_test_number} = 1;
    my $first_f_test = $locales_test_number;

    report_result($Locale, ++$locales_test_number, $ok10);
    $test_names{$locales_test_number} = 'Verify that after a no-locale block, a different locale radix still works when doing "==" with a scalar';
    $problematical_tests{$locales_test_number} = 1;

    $test_names{++$locales_test_number} = 'Verify that after a no-locale block, a different locale radix still works when doing "==" with a scalar and an intervening sprintf';
    if ($Config{usequadmath}) {
        print "# Skip: no locale radix with usequadmath ($test_names{$locales_test_number})\n";
        report_result($Locale, $locales_test_number, 1);
    } else {
        report_result($Locale, $locales_test_number, $ok11);
        $problematical_tests{$locales_test_number} = 1;
    }

    report_result($Locale, ++$locales_test_number, $ok12);
    $test_names{$locales_test_number} = 'Verify that after a no-locale block, a different locale radix can participate in an addition and function call as numeric';
    $problematical_tests{$locales_test_number} = 1;

    report_result($Locale, ++$locales_test_number, $ok13);
    $test_names{$locales_test_number} = 'Verify that don\'t get warning under "==" even if radix is not a dot';
    $problematical_tests{$locales_test_number} = 1;

    report_result($Locale, ++$locales_test_number, $ok14);
    $test_names{$locales_test_number} = 'Verify that non-ASCII UTF-8 error messages are in UTF-8';

    report_result($Locale, ++$locales_test_number, $ok14_5);
    $test_names{$locales_test_number} = '... and are ASCII outside "use locale"';

    report_result($Locale, ++$locales_test_number, $ok15);
    $test_names{$locales_test_number} = 'Verify that a number with a UTF-8 radix has a UTF-8 stringification';

    report_result($Locale, ++$locales_test_number, $ok16);
    $test_names{$locales_test_number} = 'Verify that a sprintf of a number with a UTF-8 radix yields UTF-8';
    $problematical_tests{$locales_test_number} = 1;

    report_result($Locale, ++$locales_test_number, $ok17);
    $test_names{$locales_test_number} = 'Verify that a sprintf of a number outside locale scope uses a dot radix';

    report_result($Locale, ++$locales_test_number, $ok18);
    $test_names{$locales_test_number} = 'Verify that a sprintf of a number back within locale scope uses locale radix';
    $problematical_tests{$locales_test_number} = 1;

    report_result($Locale, ++$locales_test_number, $ok19);
    $test_names{$locales_test_number} = 'Verify that strftime doesn\'t return "%p" in locales where %p is empty';

    report_result($Locale, ++$locales_test_number, $ok20);
    $test_names{$locales_test_number} = 'Verify that strftime returns date with UTF-8 flag appropriately set';
    $problematical_tests{$locales_test_number} = 1;   # This is broken in
                                                      # OS X 10.9.3

    report_result($Locale, ++$locales_test_number, $ok21);
    $test_names{$locales_test_number} = '"$!" is ASCII only outside of locale scope';

    debug "$first_f_test..$locales_test_number: \$f = $f, \$g = $g, back to locale = $Locale\n";

    # Does taking lc separately differ from taking
    # the lc "in-line"?  (This was the bug 19990704.002, change #3568.)
    # The bug was in the caching of the 'o'-magic.
    if (! $is_utf8_locale) {
	use locale;

	sub lcA {
	    my $lc0 = lc $_[0];
	    my $lc1 = lc $_[1];
	    return $lc0 cmp $lc1;
	}

        sub lcB {
	    return lc($_[0]) cmp lc($_[1]);
	}

        my $x = "ab";
        my $y = "aa";
        my $z = "AB";

        report_result($Locale, ++$locales_test_number,
		    lcA($x, $y) == 1 && lcB($x, $y) == 1 ||
		    lcA($x, $z) == 0 && lcB($x, $z) == 0);
    }
    else {
	use locale ':not_characters';

	sub lcC {
	    my $lc0 = lc $_[0];
	    my $lc1 = lc $_[1];
	    return $lc0 cmp $lc1;
	}

        sub lcD {
	    return lc($_[0]) cmp lc($_[1]);
	}

        my $x = "ab";
        my $y = "aa";
        my $z = "AB";

        report_result($Locale, ++$locales_test_number,
		    lcC($x, $y) == 1 && lcD($x, $y) == 1 ||
		    lcC($x, $z) == 0 && lcD($x, $z) == 0);
    }
    $test_names{$locales_test_number} = 'Verify "lc(foo) cmp lc(bar)" is the same as using intermediaries for the cmp';

    # Does lc of an UPPER (if different from the UPPER) match
    # case-insensitively the UPPER, and does the UPPER match
    # case-insensitively the lc of the UPPER.  And vice versa.
    {
        use locale;
        no utf8;
        my $re = qr/[\[\(\{\*\+\?\|\^\$\\]/;

        my @@f = ();
        ++$locales_test_number;
        $test_names{$locales_test_number} = 'Verify case insensitive matching works';
        foreach my $x (sort { ord $a <=> ord $b } keys %UPPER) {
            if (! $is_utf8_locale) {
                my $y = lc $x;
                next unless uc $y eq $x;
                debug_more( "UPPER=", disp_chars(($x)),
                            "; lc=", disp_chars(($y)), "; ",
                            "; fc=", disp_chars((fc $x)), "; ",
                            disp_chars(($x)), "=~/", disp_chars(($y)), "/i=",
                            $x =~ /\Q$y/i ? 1 : 0,
                            "; ",
                            disp_chars(($y)), "=~/", disp_chars(($x)), "/i=",
                            $y =~ /\Q$x/i ? 1 : 0,
                            "\n");
                #
                # If $x and $y contain regular expression characters
                # AND THEY lowercase (/i) to regular expression characters,
                # regcomp() will be mightily confused.  No, the \Q doesn't
                # help here (maybe regex engine internal lowercasing
                # is done after the \Q?)  An example of this happening is
                # the bg_BG (Bulgarian) locale under EBCDIC (OS/390 USS):
                # the chr(173) (the "[") is the lowercase of the chr(235).
                #
                # Similarly losing EBCDIC locales include cs_cz, cs_CZ,
                # el_gr, el_GR, en_us.IBM-037 (!), en_US.IBM-037 (!),
                # et_ee, et_EE, hr_hr, hr_HR, hu_hu, hu_HU, lt_LT,
                # mk_mk, mk_MK, nl_nl.IBM-037, nl_NL.IBM-037,
                # pl_pl, pl_PL, ro_ro, ro_RO, ru_ru, ru_RU,
                # sk_sk, sk_SK, sl_si, sl_SI, tr_tr, tr_TR.
                #
                # Similar things can happen even under (bastardised)
                # non-EBCDIC locales: in many European countries before the
                # advent of ISO 8859-x nationally customised versions of
                # ISO 646 were devised, reusing certain punctuation
                # characters for modified characters needed by the
                # country/language.  For example, the "|" might have
                # stood for U+00F6 or LATIN SMALL LETTER O WITH DIAERESIS.
                #
                if ($x =~ $re || $y =~ $re) {
                    print "# Regex characters in '$x' or '$y', skipping test $locales_test_number for locale '$Locale'\n";
                    next;
                }
                push @@f, $x unless $x =~ /\Q$y/i && $y =~ /\Q$x/i;

                # fc is not a locale concept, so Perl uses lc for it.
                push @@f, $x unless lc $x eq fc $x;
            }
            else {
                use locale ':not_characters';
                my $y = lc $x;
                next unless uc $y eq $x;
                debug_more( "UPPER=", disp_chars(($x)),
                            "; lc=", disp_chars(($y)), "; ",
                            "; fc=", disp_chars((fc $x)), "; ",
                            disp_chars(($x)), "=~/", disp_chars(($y)), "/i=",
                            $x =~ /\Q$y/i ? 1 : 0,
                            "; ",
                            disp_chars(($y)), "=~/", disp_chars(($x)), "/i=",
                            $y =~ /\Q$x/i ? 1 : 0,
                            "\n");

                push @@f, $x unless $x =~ /\Q$y/i && $y =~ /\Q$x/i;

                # The places where Unicode's lc is different from fc are
                # skipped here by virtue of the 'next unless uc...' line above
                push @@f, $x unless lc $x eq fc $x;
            }
        }

	foreach my $x (sort { ord $a <=> ord $b } keys %lower) {
            if (! $is_utf8_locale) {
                my $y = uc $x;
                next unless lc $y eq $x;
                debug_more( "lower=", disp_chars(($x)),
                            "; uc=", disp_chars(($y)), "; ",
                            "; fc=", disp_chars((fc $x)), "; ",
                            disp_chars(($x)), "=~/", disp_chars(($y)), "/i=",
                            $x =~ /\Q$y/i ? 1 : 0,
                            "; ",
                            disp_chars(($y)), "=~/", disp_chars(($x)), "/i=",
                            $y =~ /\Q$x/i ? 1 : 0,
                            "\n");
                if ($x =~ $re || $y =~ $re) { # See above.
                    print "# Regex characters in '$x' or '$y', skipping test $locales_test_number for locale '$Locale'\n";
                    next;
                }
                push @@f, $x unless $x =~ /\Q$y/i && $y =~ /\Q$x/i;

                push @@f, $x unless lc $x eq fc $x;
            }
            else {
                use locale ':not_characters';
                my $y = uc $x;
                next unless lc $y eq $x;
                debug_more( "lower=", disp_chars(($x)),
                            "; uc=", disp_chars(($y)), "; ",
                            "; fc=", disp_chars((fc $x)), "; ",
                            disp_chars(($x)), "=~/", disp_chars(($y)), "/i=",
                            $x =~ /\Q$y/i ? 1 : 0,
                            "; ",
                            disp_chars(($y)), "=~/", disp_chars(($x)), "/i=",
                            $y =~ /\Q$x/i ? 1 : 0,
                            "\n");
                push @@f, $x unless $x =~ /\Q$y/i && $y =~ /\Q$x/i;

                push @@f, $x unless lc $x eq fc $x;
            }
	}
	report_multi_result($Locale, $locales_test_number, \@@f);
        $problematical_tests{$locales_test_number} = 1;
    }

    # [perl #109318]
    {
        my @@f = ();
        ++$locales_test_number;
        $test_names{$locales_test_number} = 'Verify atof with locale radix and negative exponent';
        $problematical_tests{$locales_test_number} = 1;

        my $radix = POSIX::localeconv()->{decimal_point};
        my @@nums = (
             "3.14e+9",  "3${radix}14e+9",  "3.14e-9",  "3${radix}14e-9",
            "-3.14e+9", "-3${radix}14e+9", "-3.14e-9", "-3${radix}14e-9",
        );

        if (! $is_utf8_locale) {
            use locale;
            for my $num (@@nums) {
                push @@f, $num
                    unless sprintf("%g", $num) =~ /3.+14/;
            }
        }
        else {
            use locale ':not_characters';
            for my $num (@@nums) {
                push @@f, $num
                    unless sprintf("%g", $num) =~ /3.+14/;
            }
        }

        if ($Config{usequadmath}) {
            print "# Skip: no locale radix with usequadmath ($Locale)\n";
            report_result($Locale, $locales_test_number, 1);
        } else {
            report_result($Locale, $locales_test_number, @@f == 0);
            if (@@f) {
                print "# failed $locales_test_number locale '$Locale' numbers @@f\n"
            }
	}
    }
}

my $final_locales_test_number = $locales_test_number;

# Recount the errors.

TEST_NUM:
foreach $test_num ($first_locales_test_number..$final_locales_test_number) {
    if (%setlocale_failed) {
        print "not ";
    }
    elsif ($Problem{$test_num}
           || ! defined $Okay{$test_num}
           || ! @@{$Okay{$test_num}})
    {
	if (defined $not_necessarily_a_problem_test_number
            && $test_num == $not_necessarily_a_problem_test_number)
        {
	    print "# The failure of test $not_necessarily_a_problem_test_number is not necessarily fatal.\n";
	    print "# It usually indicates a problem in the environment,\n";
	    print "# not in Perl itself.\n";
	}

        # If there are any locales that pass this test, or are known-bad, it
        # may be that there are enough passes that we TODO the failure.
        if (($Okay{$test_num} || $Known_bad_locale{$test_num})
            && grep { $_ == $test_num } keys %problematical_tests)
        {
            no warnings 'experimental::postderef';

            # Don't count the known-bad failures when calculating the
            # percentage that fail.
            my $known_failures = (exists $Known_bad_locale{$test_num})
                                  ? scalar(keys $Known_bad_locale{$test_num}->%*)
                                  : 0;
            my $adjusted_failures = scalar(keys $Problem{$test_num}->%*)
                                    - $known_failures;

            # Specially handle failures where only known-bad locales fail.
            # This makes the diagnositics clearer.
            if ($adjusted_failures <= 0) {
                print "not ok $test_num $test_names{$test_num} # TODO fails only on ",
                                                                "known bad locales: ",
                      join " ", keys $Known_bad_locale{$test_num}->%*, "\n";
                next TEST_NUM;
            }

            # Round to nearest .1%
            my $percent_fail = (int(.5 + (1000 * $adjusted_failures
                                          / scalar(@@Locale))))
                               / 10;
            if ($percent_fail < $acceptable_failure_percentage) {
                if (! $debug) {
                    $test_names{$test_num} .= 'TODO';
                    print "# ", 100 - $percent_fail, "% of locales not known to be problematic on this platform\n";
                    print "# pass the following test, so it is likely that the failures\n";
                    print "# are errors in the locale definitions.  The test is marked TODO, as the\n";
                    print "# problem is not likely to be Perl's\n";
                }
            }
            if ($debug) {
                print "# $percent_fail% of locales (",
                      scalar(keys $Problem{$test_num}->%*),
                      " of ",
                      scalar(@@Locale),
                      ") fail the above test (TODO cut-off is ",
                      $acceptable_failure_percentage,
                      "%)\n";
            }
        }
        print "#\n";
        if ($debug) {
            print "# The code points that had this failure are given above.  Look for lines\n";
            print "# that match 'failed $test_num'\n";
        }
        else {
            print "# For more details, rerun, with environment variable PERL_DEBUG_FULL_TEST=1.\n";
            print "# Then look at that output for lines that match 'failed $test_num'\n";
        }
	print "not ";
    }
    print "ok $test_num";
    if (defined $test_names{$test_num}) {
        # If TODO is in the test name, make it thus
        my $todo = $test_names{$test_num} =~ s/TODO\s*//;
        print " $test_names{$test_num}";
        print " # TODO" if $todo;
    }
    print "\n";
}

$test_num = $final_locales_test_number;

unless ( $^O =~ m!^(dragonfly|openbsd|bitrig|mirbsd)$! ) {
    # perl #115808
    use warnings;
    my $warned = 0;
    local $SIG{__WARN__} = sub {
        $warned = $_[0] =~ /uninitialized/;
    };
    my $z = "y" . setlocale(&POSIX::LC_ALL, "xyzzy");
    ok($warned, "variable set to setlocale(BAD LOCALE) is considered uninitialized");
}

# Test that tainting and case changing works on utf8 strings.  These tests are
# placed last to avoid disturbing the hard-coded test numbers that existed at
# the time these were added above this in this file.
# This also tests that locale overrides unicode_strings in the same scope for
# non-utf8 strings.
setlocale(&POSIX::LC_ALL, "C");
{
    use locale;
    use feature 'unicode_strings';

    foreach my $function ("uc", "ucfirst", "lc", "lcfirst", "fc") {
        my @@list;   # List of code points to test for $function

        # Used to calculate the changed case for ASCII characters by using the
        # ord, instead of using one of the functions under test.
        my $ascii_case_change_delta;
        my $above_latin1_case_change_delta; # Same for the specific ords > 255
                                            # that we use

        # We test an ASCII character, which should change case;
        # a Latin1 character, which shouldn't change case under this C locale,
        # an above-Latin1 character that when the case is changed would cross
        #   the 255/256 boundary, so doesn't change case
        #   (the \x{149} is one of these, but changes into 2 characters, the
        #   first one of which doesn't cross the boundary.
        # the final one in each list is an above-Latin1 character whose case
        #   does change.  The code below uses its position in its list as a
        #   marker to indicate that it, unlike the other code points above
        #   ASCII, has a successful case change
        #
        # All casing operations under locale (but not :not_characters) should
        # taint
        if ($function =~ /^u/) {
            @@list = ("", "a",
                     chr(utf8::unicode_to_native(0xe0)),
                     chr(utf8::unicode_to_native(0xff)),
                     "\x{fb00}", "\x{149}", "\x{101}");
            $ascii_case_change_delta = ($is_ebcdic) ? +64 : -32;
            $above_latin1_case_change_delta = -1;
        }
        else {
            @@list = ("", "A",
                     chr(utf8::unicode_to_native(0xC0)),
                     "\x{17F}", "\x{100}");
            $ascii_case_change_delta = ($is_ebcdic) ? -64 : +32;
            $above_latin1_case_change_delta = +1;
        }
        foreach my $is_utf8_locale (0 .. 1) {
            foreach my $j (0 .. $#list) {
                my $char = $list[$j];

                for my $encoded_in_utf8 (0 .. 1) {
                    my $should_be;
                    my $changed;
                    if (! $is_utf8_locale) {
                        no warnings 'locale';
                        $should_be = ($j == $#list)
                            ? chr(ord($char) + $above_latin1_case_change_delta)
                            : (length $char == 0 || utf8::native_to_unicode(ord($char)) > 127)
                              ? $char
                              : chr(ord($char) + $ascii_case_change_delta);

                        # This monstrosity is in order to avoid using an eval,
                        # which might perturb the results
                        $changed = ($function eq "uc")
                                    ? uc($char)
                                    : ($function eq "ucfirst")
                                      ? ucfirst($char)
                                      : ($function eq "lc")
                                        ? lc($char)
                                        : ($function eq "lcfirst")
                                          ? lcfirst($char)
                                          : ($function eq "fc")
                                            ? fc($char)
                                            : die("Unexpected function \"$function\"");
                    }
                    else {
                        {
                            no locale;

                            # For utf8-locales the case changing functions
                            # should work just like they do outside of locale.
                            # Can use eval here because not testing it when
                            # not in locale.
                            $should_be = eval "$function('$char')";
                            die "Unexpected eval error $@@ from 'eval \"$function('$char')\"'" if  $@@;

                        }
                        use locale ':not_characters';
                        $changed = ($function eq "uc")
                                    ? uc($char)
                                    : ($function eq "ucfirst")
                                      ? ucfirst($char)
                                      : ($function eq "lc")
                                        ? lc($char)
                                        : ($function eq "lcfirst")
                                          ? lcfirst($char)
                                          : ($function eq "fc")
                                            ? fc($char)
                                            : die("Unexpected function \"$function\"");
                    }
                    ok($changed eq $should_be,
                        "$function(\"$char\") in C locale "
                        . (($is_utf8_locale)
                            ? "(use locale ':not_characters'"
                            : "(use locale")
                        . (($encoded_in_utf8)
                            ? "; encoded in utf8)"
                            : "; not encoded in utf8)")
                        . " should be \"$should_be\", got \"$changed\"");

                    # Tainting shouldn't happen for use locale :not_character
                    # (a utf8 locale)
                    (! $is_utf8_locale)
                    ? check_taint($changed)
                    : check_taint_not($changed);

                    # Use UTF-8 next time through the loop
                    utf8::upgrade($char);
                }
            }
        }
    }
}

# Give final advice.

my $didwarn = 0;

foreach ($first_locales_test_number..$final_locales_test_number) {
    if ($Problem{$_}) {
	my @@f = sort keys %{ $Problem{$_} };

        # Don't list the failures caused by known-bad locales.
        if (exists $known_bad_locales{$^O}) {
            @@f = grep { $_ !~ $known_bad_locales{$^O} } @@f;
            next unless @@f;
        }
	my $f = join(" ", @@f);
	$f =~ s/(.{50,60}) /$1\n#\t/g;
	print
	    "#\n",
            "# The locale ", (@@f == 1 ? "definition" : "definitions"), "\n#\n",
	    "#\t", $f, "\n#\n",
	    "# on your system may have errors because the locale test $_\n",
	    "# \"$test_names{$_}\"\n",
            "# failed in ", (@@f == 1 ? "that locale" : "those locales"),
            ".\n";
	print <<EOW;
#
# If your users are not using these locales you are safe for the moment,
# but please report this failure first to perlbug\@@perl.com using the
# perlbug script (as described in the INSTALL file) so that the exact
# details of the failures can be sorted out first and then your operating
# system supplier can be alerted about these anomalies.
#
EOW
	$didwarn = 1;
    }
}

# Tell which locales were okay and which were not.

if ($didwarn) {
    my (@@s, @@F);

    foreach my $l (@@Locale) {
	my $p = 0;
        if ($setlocale_failed{$l}) {
            $p++;
        }
        else {
            foreach my $t
                        ($first_locales_test_number..$final_locales_test_number)
            {
                $p++ if $Problem{$t}{$l};
            }
	}
	push @@s, $l if $p == 0;
        push @@F, $l unless $p == 0;
    }

    if (@@s) {
        my $s = join(" ", @@s);
        $s =~ s/(.{50,60}) /$1\n#\t/g;

        print
            "# The following locales\n#\n",
            "#\t", $s, "\n#\n",
	    "# tested okay.\n#\n",
    } else {
        print "# None of your locales were fully okay.\n";
    }

    if (@@F) {
        my $F = join(" ", @@F);
        $F =~ s/(.{50,60}) /$1\n#\t/g;

        my $details = "";
        unless ($debug) {
            $details = "# For more details, rerun, with environment variable PERL_DEBUG_FULL_TEST=1.\n";
        }
        elsif ($debug == 1) {
            $details = "# For even more details, rerun, with environment variable PERL_DEBUG_FULL_TEST=2.\n";
        }

        print
          "# The following locales\n#\n",
          "#\t", $F, "\n#\n",
          "# had problems.\n#\n",
          $details;
    } else {
        print "# None of your locales were broken.\n";
    }
}

if (exists $known_bad_locales{$^O} && ! %Known_bad_locale) {
    $test_num++;
    print "ok $test_num $^O no longer has known bad locales # TODO\n";
}

print "1..$test_num\n";

# eof
@


1.7
log
@Apply local patches, remove excess files - perl-5.20.2
@
text
@d10 5
d22 2
a23 2
    require Config; import Config;
    if (!$Config{d_setlocale} || $Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/) {
a26 1
    require './loc_tools.pl';
d28 1
d32 1
a32 1
use feature 'fc';
d39 1
a39 4
# Some Windows machines are defective in every locale but the C, calling \t
# printable; superscripts to be digits, etc.  See
# http://markmail.org/message/5jwam4xsx4amsdnv.  Also on AIX machines, many
# locales call a no-break space a graphic.
d41 1
a41 1
my $acceptable_failure_percentage = ($^O =~ / ^ ( MSWin32 | AIX ) $ /ix)
d48 13
d71 3
a73 3
  my($mess) = join "", @@_;
  chop $mess;
  print $dumper->stringify($mess,1), "\n";
d82 1
a82 1
    printf @@_ if $debug;
d85 1
a85 1
$a = 'abc %';
d97 1
d113 3
a115 1
    $message_tail = ": $message_tail" if $message_tail;
d121 1
a121 1
    $message_tail = ": $message_tail" if $message_tail;
d125 14
d145 4
a148 1
check_taint_not   $a, "\t\$a";
d150 16
a165 16
check_taint       uc($a);
check_taint       "\U$a";
check_taint       ucfirst($a);
check_taint       "\u$a";
check_taint       lc($a);
check_taint       fc($a);
check_taint       "\L$a";
check_taint       "\F$a";
check_taint       lcfirst($a);
check_taint       "\l$a";

check_taint_not  sprintf('%e', 123.456);
check_taint_not  sprintf('%f', 123.456);
check_taint_not  sprintf('%g', 123.456);
check_taint_not  sprintf('%d', 123.456);
check_taint_not  sprintf('%x', 123.456);
d171 1
a171 1
check_taint      $_, "\t\$_";
d174 1
a174 1
check_taint      $&, "\t/(\\w)/ \$&";
d182 1
a182 1
check_taint_not  $&, "\t/(.)/ \$&";
d190 1
a190 1
check_taint      $&, "\t/(\\W)/ \$&";
d198 1
a198 1
check_taint_not  $&, "\t/(.)/ \$&";
d206 1
a206 1
check_taint      $&, "\t/(\\s)/ \$&";
d214 1
a214 1
check_taint_not  $&, "\t/(.)/ \$&";
d217 12
a228 1
check_taint      $&, "\t/(\\S)/ \$&";
d236 31
a266 1
check_taint_not  $&, "\t/(.)/ \$&";
d269 1
a269 1
check_taint      $&, "\t/(a)|(\\w)/ \$&";
d274 2
a275 2
ok($1 eq 'a', ("\t" x 4) . "\$1 is 'a'");
ok(! defined $2, ("\t" x 4) . "\$2 is undefined");
d280 1
a280 1
check_taint_not  $&, "\t/(.)/ \$&";
d283 1
a283 1
check_taint_not      $&, "\t/(\\N{CYRILLIC CAPITAL LETTER A})/i \$&";
d288 1
a288 1
ok($1 eq "\N{CYRILLIC SMALL LETTER A}", ("\t" x 4) . "\$1 is 'small cyrillic a'");
d292 9
a300 1
check_taint_not  $&, "\t/./ \$&";
d303 1
a303 1
check_taint_not  $&, "\t/(.)/ \$&";
d306 1
a306 1
check_taint      $&, "\t/(.)\\b(.)/ \$&";
d315 1
a315 1
check_taint_not  $&, "\t/./ \$&";
d318 1
a318 1
check_taint      $&, "\t/(.)\\B(.)/ \$&";
d327 1
a327 1
check_taint_not  $&, "\t/./ \$&";
d330 1
a330 1
check_taint_not      $&, "\t/(.).(\\1)/ \$&";
d336 1
a336 1
check_taint_not  $3, "\t\$3";
d339 1
a339 1
check_taint_not  $&, "\t/./ \$&";
d343 1
a343 1
check_taint_not  $_, "\t\$_";
d346 1
a346 1
check_taint_not  $&, "\t/(b)/ \$&";
d355 1
a355 1
check_taint_not  $_, "\t\$_";
d360 1
a360 1
check_taint      $_, "\t\$_";
d371 1
a371 1
check_taint_not  $_, "\t\$_";
d382 2
a383 2
check_taint      $b, "\t\$b";	# $b should be tainted.
check_taint_not  $a, "\t\$a";	# $a should be not.
d388 1
a388 1
check_taint      $_, "\t\$_";
d399 1
a399 1
check_taint      $_, "\t\$_";
d410 1
a410 1
check_taint      $_, "\t\$_";
d421 1
a421 1
check_taint      $_, "\t\$_";
d431 1
a431 1
check_taint_not  $a, "\t\$a";
d445 1
d447 16
a462 1
    check_taint_not   $a;
d464 48
a511 16
    check_taint_not	uc($a);
    check_taint_not	"\U$a";
    check_taint_not	ucfirst($a);
    check_taint_not	"\u$a";
    check_taint_not	lc($a);
    check_taint_not	fc($a);
    check_taint_not	"\L$a";
    check_taint_not	"\F$a";
    check_taint_not	lcfirst($a);
    check_taint_not	"\l$a";

    check_taint_not  sprintf('%e', 123.456);
    check_taint_not  sprintf('%f', 123.456);
    check_taint_not  sprintf('%g', 123.456);
    check_taint_not  sprintf('%d', 123.456);
    check_taint_not  sprintf('%x', 123.456);
d513 77
a589 1
    $_ = $a;	# untaint $_
d591 7
a597 1
    $_ = uc($a);	# taint $_
d599 2
a600 1
    check_taint_not	$_;
d602 8
a609 7
    /(\w)/;	# taint $&, $`, $', $+, $1.
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;
d612 1
a612 30
    check_taint_not  $&;
    check_taint_not  $`;
    check_taint_not  $';
    check_taint_not  $+;
    check_taint_not  $1;
    check_taint_not  $2;

    /(\W)/;	# taint $&, $`, $', $+, $1.
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    /(\s)/;	# taint $&, $`, $', $+, $1.
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    /(\S)/;	# taint $&, $`, $', $+, $1.
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;
d614 8
a621 1
    $_ = $a;	# untaint $_
d623 2
a624 1
    check_taint_not  $_;
d626 11
a636 7
    /(b)/;		# this must not taint
    check_taint_not  $&;
    check_taint_not  $`;
    check_taint_not  $';
    check_taint_not  $+;
    check_taint_not  $1;
    check_taint_not  $2;
d640 1
a640 1
    check_taint_not  $_;
d642 7
a648 2
    $b = uc($a);	# taint $b
    s/(.+)/$b/;	# this must taint only the $_
d650 1
a650 7
    check_taint_not	$_;
    check_taint_not  $&;
    check_taint_not  $`;
    check_taint_not  $';
    check_taint_not  $+;
    check_taint_not  $1;
    check_taint_not  $2;
d652 1
a652 1
    $_ = $a;	# untaint $_
d654 8
a661 8
    s/(.+)/b/;	# this must not taint
    check_taint_not  $_;
    check_taint_not  $&;
    check_taint_not  $`;
    check_taint_not  $';
    check_taint_not  $+;
    check_taint_not  $1;
    check_taint_not  $2;
d666 2
a667 2
    check_taint_not	$b;	# $b should be tainted.
    check_taint_not  $a;	# $a should be not.
d671 8
a678 8
    s/(\w)/\l$1/;	# this must taint
    check_taint_not	$_;
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;
d682 8
a689 8
    s/(\w)/\L$1/;	# this must taint
    check_taint_not	$_;
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;
d693 8
a700 8
    s/(\w)/\u$1/;	# this must taint
    check_taint_not	$_;
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;
d704 8
a711 8
    s/(\w)/\U$1/;	# this must taint
    check_taint_not	$_;
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;
d715 1
a715 1
    check_taint_not  $a;
d721 1
d735 1
a735 1
debug "# Scanning for locales...\n";
d739 1
a739 1
my @@Locale = find_locales([ &POSIX::LC_CTYPE, &POSIX::LC_ALL ]);
d741 1
a741 1
debug "# Locales =\n";
d743 1
a743 1
    debug "# $_\n";
d758 1
d842 59
d905 6
a910 1
    unless ($pass_fail) {
d912 1
a912 3
	debug "# failed $i ($test_names{$i}) with locale '$Locale'$message\n";
    } else {
	push @@{$Okay{$i}}, $Locale;
d937 2
a938 2
    debug "#\n";
    debug "# Locale = $Locale\n";
d956 1
a956 1
    debug "# is utf8 locale? = $is_utf8_locale\n";
d958 1
a958 6
    my $radix = localeconv()->{decimal_point};
    if ($radix !~ / ^ [[:ascii:]] + $/x) {
        use bytes;
        $radix = disp_chars(split "", $radix);
    }
    debug "# radix = $radix\n";
d1022 15
a1036 15
    debug "# :upper:  = ", disp_chars(@@{$posixes{'upper'}}), "\n";
    debug "# :lower:  = ", disp_chars(@@{$posixes{'lower'}}), "\n";
    debug "# :cased:  = ", disp_chars(@@{$posixes{'cased'}}), "\n";
    debug "# :alpha:  = ", disp_chars(@@{$posixes{'alpha'}}), "\n";
    debug "# :alnum:  = ", disp_chars(@@{$posixes{'alnum'}}), "\n";
    debug "#  w       = ", disp_chars(@@{$posixes{'word'}}), "\n";
    debug "# :graph:  = ", disp_chars(@@{$posixes{'graph'}}), "\n";
    debug "# :print:  = ", disp_chars(@@{$posixes{'print'}}), "\n";
    debug "#  d       = ", disp_chars(@@{$posixes{'digit'}}), "\n";
    debug "# :xdigit: = ", disp_chars(@@{$posixes{'xdigit'}}), "\n";
    debug "# :blank:  = ", disp_chars(@@{$posixes{'blank'}}), "\n";
    debug "#  s       = ", disp_chars(@@{$posixes{'space'}}), "\n";
    debug "# :punct:  = ", disp_chars(@@{$posixes{'punct'}}), "\n";
    debug "# :cntrl:  = ", disp_chars(@@{$posixes{'cntrl'}}), "\n";
    debug "# :ascii:  = ", disp_chars(@@{$posixes{'ascii'}}), "\n";
d1060 4
a1063 4
    debug "# UPPER    = ", disp_chars(sort { ord $a <=> ord $b } keys %UPPER), "\n";
    debug "# lower    = ", disp_chars(sort { ord $a <=> ord $b } keys %lower), "\n";
    debug "# BoThCaSe = ", disp_chars(sort { ord $a <=> ord $b } keys %BoThCaSe), "\n";
    debug "# Unassigned = ", disp_chars(sort { ord $a <=> ord $b } keys %Unassigned), "\n";
d1134 1
a1134 1
    debug "# Added_alpha = ", disp_chars(@@Added_alpha), "\n";
d1719 3
a1721 3
                debug "# lesser  = '$lesser'\n";
                debug "# greater = '$greater'\n";
                debug "# lesser cmp greater = ",
d1723 1
a1723 1
                debug "# greater cmp lesser = ",
d1725 1
a1725 1
                debug "# (greater) from = $from, to = $to\n";
d1732 1
a1732 1
                    debug "\n#";
d1754 1
d1759 3
d1823 1
a1823 1
            $ok14 = $ok15 = $ok16 = 1;  # Skip for non-utf8 locales
d1877 2
a1878 2
            # such is NOT in UTF-8 (the others almost certainly will be like
            # the first)  See [perl #119499].
d1880 14
a1893 7
            foreach my $err (keys %!) {
                use Errno;
                $! = eval "&Errno::$err";   # Convert to strerror() output
                my $strerror = "$!";
                if ("$strerror" =~ /\P{ASCII}/) {
                    $ok14 = ! utf8::is_utf8($strerror);
                    last;
d1914 30
d1948 1
a1948 1
    debug "# $first_a_test..$locales_test_number: \$a = $a, \$b = $b, Locale = $Locale\n";
d1955 8
a1962 3
    report_result($Locale, ++$locales_test_number, $ok3);
    $test_names{$locales_test_number} = 'Verify that a different locale radix works when doing "==" with a constant';
    $problematical_tests{$locales_test_number} = 1;
d1964 8
a1971 3
    report_result($Locale, ++$locales_test_number, $ok4);
    $test_names{$locales_test_number} = 'Verify that a different locale radix works when doing "==" with a scalar';
    $problematical_tests{$locales_test_number} = 1;
d1977 1
a1977 1
    debug "# $first_c_test..$locales_test_number: \$c = $c, \$d = $d, Locale = $Locale\n";
d1986 8
a1993 3
    report_result($Locale, ++$locales_test_number, $ok8);
    $test_names{$locales_test_number} = 'Verify that "==" with a scalar and an intervening sprintf still works in inner no locale';
    $problematical_tests{$locales_test_number} = 1;
d1995 1
a1995 1
    debug "# $first_e_test..$locales_test_number: \$e = $e, no locale\n";
d2006 8
a2013 3
    report_result($Locale, ++$locales_test_number, $ok11);
    $test_names{$locales_test_number} = 'Verify that after a no-locale block, a different locale radix still works when doing "==" with a scalar and an intervening sprintf';
    $problematical_tests{$locales_test_number} = 1;
d2024 4
a2027 1
    $test_names{$locales_test_number} = 'Verify that non-ASCII UTF-8 error messages are NOT in UTF-8';
d2034 1
d2041 12
d2054 1
a2054 1
    debug "# $first_f_test..$locales_test_number: \$f = $f, \$g = $g, back to locale = $Locale\n";
d2118 1
a2118 1
                debug_more( "# UPPER=", disp_chars(($x)),
d2122 1
a2122 1
                            $x =~ /$y/i ? 1 : 0,
d2125 1
a2125 1
                            $y =~ /$x/i ? 1 : 0,
d2155 1
a2155 1
                push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
d2164 1
a2164 1
                debug_more( "# UPPER=", disp_chars(($x)),
d2168 1
a2168 1
                            $x =~ /$y/i ? 1 : 0,
d2171 1
a2171 1
                            $y =~ /$x/i ? 1 : 0,
d2174 1
a2174 1
                push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
d2186 1
a2186 1
                debug_more( "# lower=", disp_chars(($x)),
d2190 1
a2190 1
                            $x =~ /$y/i ? 1 : 0,
d2193 1
a2193 1
                            $y =~ /$x/i ? 1 : 0,
d2199 1
a2199 1
                push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
d2207 1
a2207 1
                debug_more( "# lower=", disp_chars(($x)),
d2211 1
a2211 1
                            $x =~ /$y/i ? 1 : 0,
d2214 1
a2214 1
                            $y =~ /$x/i ? 1 : 0,
d2216 1
a2216 1
                push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
d2253 8
a2260 3
	report_result($Locale, $locales_test_number, @@f == 0);
	if (@@f) {
	    print "# failed $locales_test_number locale '$Locale' numbers @@f\n"
d2269 1
d2274 4
a2277 1
    elsif ($Problem{$test_num} || !defined $Okay{$test_num} || !@@{$Okay{$test_num}}) {
d2285 25
a2309 2
        if ($Okay{$test_num} && grep { $_ == $test_num } keys %problematical_tests) {
            no warnings 'experimental::autoderef';
d2311 1
a2311 1
            my $percent_fail = (int(.5 + (1000 * scalar(keys $Problem{$test_num})
d2314 17
a2330 6
            if (! $debug && $percent_fail < $acceptable_failure_percentage)
            {
                $test_names{$test_num} .= 'TODO';
                print "# ", 100 - $percent_fail, "% of locales pass the following test, so it is likely that the failures\n";
                print "# are errors in the locale definitions.  The test is marked TODO, as the\n";
                print "# problem is not likely to be Perl's\n";
d2400 5
a2404 2
            @@list = ("", "a", "\xe0", "\xff", "\x{fb00}", "\x{149}", "\x{101}");
            $ascii_case_change_delta = -32;
d2408 4
a2411 2
            @@list = ("", "A", "\xC0", "\x{17F}", "\x{100}");
            $ascii_case_change_delta = +32;
d2422 1
d2425 3
a2427 3
                            : (length $char == 0 || ord($char) > 127)
                            ? $char
                            : chr(ord($char) + $ascii_case_change_delta);
d2499 6
d2581 5
@


1.6
log
@Fix merge issues, remove excess files - match perl-5.20.2 dist
@
text
@d18 1
a18 1
    if (!$Config{d_setlocale} || $Config{ccflags} =~ /\bD?NO_LOCALE\b/) {
@


1.5
log
@Apply local patches to perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d18 1
a18 1
    if (!$Config{d_setlocale} || $Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/) {
@


1.4
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d18 1
a18 1
    if (!$Config{d_setlocale} || $Config{ccflags} =~ /\bD?NO_LOCALE\b/) {
@


1.3
log
@Merge perl-5.18.2 plus local patches, remove old files

OK espie@@ sthen@@ deraadt@@
@
text
@d18 1
a18 1
    if (!$Config{d_setlocale} || $Config{ccflags} =~ /\bD?NO_LOCALE(_|\b)/) {
d22 1
d29 2
a30 1
my $debug = 0;
d34 12
a45 1
my $acceptable_fold_failure_percentage = 5;
d61 5
a69 21
my $have_setlocale = 0;
eval {
    require POSIX;
    import POSIX ':locale_h';
    $have_setlocale++;
};

# Visual C's CRT goes silly on strings of the form "en_US.ISO8859-1"
# and mingw32 uses said silly CRT
# This doesn't seem to be an issue any more, at least on Windows XP,
# so re-enable the tests for Windows XP onwards.
my $winxp = ($^O eq 'MSWin32' && defined &Win32::GetOSVersion &&
		join('.', (Win32::GetOSVersion())[1..2]) >= 5.1);
$have_setlocale = 0 if ((($^O eq 'MSWin32' && !$winxp) || $^O eq 'NetWare') &&
		$Config{cc} =~ /^(cl|gcc)/i);

# UWIN seems to loop after taint tests, just skip for now
$have_setlocale = 0 if ($^O =~ /^uwin/);

sub LC_ALL ();

d113 1
a113 1
check_taint_not   $a;
d136 1
a136 1
check_taint      $_;
d139 6
a144 6
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d147 6
a152 6
check_taint_not  $&;
check_taint_not  $`;
check_taint_not  $';
check_taint_not  $+;
check_taint_not  $1;
check_taint_not  $2;
d155 14
a168 6
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d171 9
a179 6
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d182 74
a255 6
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d259 1
a259 1
check_taint_not  $_;
d262 6
a267 6
check_taint_not  $&;
check_taint_not  $`;
check_taint_not  $';
check_taint_not  $+;
check_taint_not  $1;
check_taint_not  $2;
d271 1
a271 1
check_taint_not  $_;
d276 7
a282 7
check_taint      $_;
check_taint_not  $&;
check_taint_not  $`;
check_taint_not  $';
check_taint_not  $+;
check_taint_not  $1;
check_taint_not  $2;
d287 7
a293 7
check_taint_not  $_;
check_taint_not  $&;
check_taint_not  $`;
check_taint_not  $';
check_taint_not  $+;
check_taint_not  $1;
check_taint_not  $2;
d298 2
a299 2
check_taint      $b;	# $b should be tainted.
check_taint_not  $a;	# $a should be not.
d304 7
a310 7
check_taint      $_;
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d315 7
a321 7
check_taint      $_;
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d326 7
a332 7
check_taint      $_;
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d337 7
a343 7
check_taint      $_;
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d347 8
a354 1
check_taint_not  $a;
d518 5
a530 5
unless ($have_setlocale) {
    print "1..$test_num\n";
    exit;
}

d538 1
a538 60
# Note that it's okay that some languages have their native names
# capitalized here even though that's not "right".  They are lowercased
# anyway later during the scanning process (and besides, some clueless
# vendor might have them capitalized erroneously anyway).

my $locales = <<EOF;
Afrikaans:af:za:1 15
Arabic:ar:dz eg sa:6 arabic8
Brezhoneg Breton:br:fr:1 15
Bulgarski Bulgarian:bg:bg:5
Chinese:zh:cn tw:cn.EUC eucCN eucTW euc.CN euc.TW Big5 GB2312 tw.EUC
Hrvatski Croatian:hr:hr:2
Cymraeg Welsh:cy:cy:1 14 15
Czech:cs:cz:2
Dansk Danish:da:dk:1 15
Nederlands Dutch:nl:be nl:1 15
English American British:en:au ca gb ie nz us uk zw:1 15 cp850
Esperanto:eo:eo:3
Eesti Estonian:et:ee:4 6 13
Suomi Finnish:fi:fi:1 15
Flamish::fl:1 15
Deutsch German:de:at be ch de lu:1 15
Euskaraz Basque:eu:es fr:1 15
Galego Galician:gl:es:1 15
Ellada Greek:el:gr:7 g8
Frysk:fy:nl:1 15
Greenlandic:kl:gl:4 6
Hebrew:iw:il:8 hebrew8
Hungarian:hu:hu:2
Indonesian:id:id:1 15
Gaeilge Irish:ga:IE:1 14 15
Italiano Italian:it:ch it:1 15
Nihongo Japanese:ja:jp:euc eucJP jp.EUC sjis
Korean:ko:kr:
Latine Latin:la:va:1 15
Latvian:lv:lv:4 6 13
Lithuanian:lt:lt:4 6 13
Macedonian:mk:mk:1 15
Maltese:mt:mt:3
Moldovan:mo:mo:2
Norsk Norwegian:no no\@@nynorsk nb nn:no:1 15
Occitan:oc:es:1 15
Polski Polish:pl:pl:2
Rumanian:ro:ro:2
Russki Russian:ru:ru su ua:5 koi8 koi8r KOI8-R koi8u cp1251 cp866
Serbski Serbian:sr:yu:5
Slovak:sk:sk:2
Slovene Slovenian:sl:si:2
Sqhip Albanian:sq:sq:1 15
Svenska Swedish:sv:fi se:1 15
Thai:th:th:11 tis620
Turkish:tr:tr:9 turkish8
Yiddish:yi::1 15
EOF

if ($^O eq 'os390') {
    # These cause heartburn.  Broken locales?
    $locales =~ s/Svenska Swedish:sv:fi se:1 15\n//;
    $locales =~ s/Thai:th:th:11 tis620\n//;
}
d540 1
a540 1
sub in_utf8 () { $^H & 0x08 || (${^OPEN} || "") =~ /:utf8/ }
d542 3
a544 4
if (in_utf8) {
    require "lib/locale/utf8";
} else {
    require "lib/locale/latin1";
d547 3
a549 21
my @@Locale;
my $Locale;
my @@Alnum_;

sub trylocale {
    my $locale = shift;
    return if grep { $locale eq $_ } @@Locale;
    return unless setlocale(LC_ALL, $locale);
    my $badutf8;
    {
        local $SIG{__WARN__} = sub {
            $badutf8 = $_[0] =~ /Malformed UTF-8/;
        };
        $Locale =~ /UTF-?8/i;
    }

    if ($badutf8) {
        ok(0, "Locale name contains malformed utf8");
        return;
    }
    push @@Locale, $locale;
a551 2
sub decode_encodings {
    my @@enc;
d553 1
a553 15
    foreach (split(/ /, shift)) {
	if (/^(\d+)$/) {
	    push @@enc, "ISO8859-$1";
	    push @@enc, "iso8859$1";	# HP
	    if ($1 eq '1') {
		 push @@enc, "roman8";	# HP
	    }
	} else {
	    push @@enc, $_;
   	    push @@enc, "$_.UTF-8";
	}
    }
    if ($^O eq 'os390') {
	push @@enc, qw(IBM-037 IBM-819 IBM-1047);
    }
d555 1
a555 2
    return @@enc;
}
d557 5
a561 11
trylocale("C");
trylocale("POSIX");
foreach (0..15) {
    trylocale("ISO8859-$_");
    trylocale("iso8859$_");
    trylocale("iso8859-$_");
    trylocale("iso_8859_$_");
    trylocale("isolatin$_");
    trylocale("isolatin-$_");
    trylocale("iso_latin_$_");
}
d563 41
a603 2
# Sanitize the environment so that we can run the external 'locale'
# program without the taint mode getting grumpy.
d605 12
a616 2
# $ENV{PATH} is special in VMS.
delete $ENV{PATH} if $^O ne 'VMS' or $Config{d_setenv};
d618 12
a629 2
# Other subversive stuff.
delete @@ENV{qw(IFS CDPATH ENV BASH_ENV)};
d631 5
a635 63
if (-x "/usr/bin/locale" && open(LOCALES, "/usr/bin/locale -a 2>/dev/null|")) {
    while (<LOCALES>) {
	# It seems that /usr/bin/locale steadfastly outputs 8 bit data, which
	# ain't great when we're running this testPERL_UNICODE= so that utf8
	# locales will cause all IO hadles to default to (assume) utf8
	next unless utf8::valid($_);
        chomp;
	trylocale($_);
    }
    close(LOCALES);
} elsif ($^O eq 'VMS' && defined($ENV{'SYS$I18N_LOCALE'}) && -d 'SYS$I18N_LOCALE') {
# The SYS$I18N_LOCALE logical name search list was not present on
# VAX VMS V5.5-12, but was on AXP && VAX VMS V6.2 as well as later versions.
    opendir(LOCALES, "SYS\$I18N_LOCALE:");
    while ($_ = readdir(LOCALES)) {
        chomp;
        trylocale($_);
    }
    close(LOCALES);
} elsif ($^O eq 'openbsd' && -e '/usr/share/locale') {

   # OpenBSD doesn't have a locale executable, so reading /usr/share/locale
   # is much easier and faster than the last resort method.

    opendir(LOCALES, '/usr/share/locale');
    while ($_ = readdir(LOCALES)) {
        chomp;
        trylocale($_);
    }
    close(LOCALES);
} else {

    # This is going to be slow.

    foreach my $locale (split(/\n/, $locales)) {
	my ($locale_name, $language_codes, $country_codes, $encodings) =
	    split(/:/, $locale);
	my @@enc = decode_encodings($encodings);
	foreach my $loc (split(/ /, $locale_name)) {
	    trylocale($loc);
	    foreach my $enc (@@enc) {
		trylocale("$loc.$enc");
	    }
	    $loc = lc $loc;
	    foreach my $enc (@@enc) {
		trylocale("$loc.$enc");
	    }
	}
	foreach my $lang (split(/ /, $language_codes)) {
	    trylocale($lang);
	    foreach my $country (split(/ /, $country_codes)) {
		my $lc = "${lang}_${country}";
		trylocale($lc);
		foreach my $enc (@@enc) {
		    trylocale("$lc.$enc");
		}
		my $lC = "${lang}_\U${country}";
		trylocale($lC);
		foreach my $enc (@@enc) {
		    trylocale("$lC.$enc");
		}
	    }
	}
a636 18
}

setlocale(LC_ALL, "C");

if ($^O eq 'darwin') {
    # Darwin 8/Mac OS X 10.4 and 10.5 have bad Basque locales: perl bug #35895,
    # Apple bug ID# 4139653. It also has a problem in Byelorussian.
    (my $v) = $Config{osvers} =~ /^(\d+)/;
    if ($v >= 8 and $v < 10) {
	debug "# Skipping eu_ES, be_BY locales -- buggy in Darwin\n";
	@@Locale = grep ! m/^(eu_ES(?:\..*)?|be_BY\.CP1131)$/, @@Locale;
    } elsif ($v < 12) {
	debug "# Skipping be_BY locales -- buggy in Darwin\n";
	@@Locale = grep ! m/^be_BY\.CP1131$/, @@Locale;
    }
}

@@Locale = sort @@Locale;
d638 2
a639 3
debug "# Locales =\n";
for ( @@Locale ) {
    debug "# $_\n";
d642 2
a643 8
my %Problem;
my %Okay;
my %Testing;
my @@Neoalpha;   # Alnums that aren't in the C locale.
my %test_names;

sub tryneoalpha {
    my ($Locale, $i, $test, $message) = @@_;
d646 1
a646 1
    unless ($test) {
d648 1
a648 1
	debug "# failed $i with locale '$Locale'$message\n";
d654 13
a670 1
my $final_casing_test_number;
d673 1
a673 1
foreach $Locale (@@Locale) {
d675 1
d678 1
a678 1
    unless (setlocale(LC_ALL, $Locale)) {
d683 19
a701 9
    # We test UTF-8 locales only under ':not_characters'; otherwise they have
    # documented deficiencies.  Non- UTF-8 locales are tested only under plain
    # 'use locale', as otherwise we would have to convert everything in them
    # to Unicode.
    my $is_utf8_locale = $Locale =~ /UTF-?8/i;

    my %UPPER = ();
    my %lower = ();
    my %BoThCaSe = ();
d705 15
a719 3
        @@Alnum_ = sort grep /\w/, map { chr } 0..255;

        debug "# w = ", join("",@@Alnum_), "\n";
d723 1
a723 1
        for (@@Alnum_) {
d736 16
a751 3
        @@Alnum_ = sort grep /\w/, map { chr } 0..255;
        debug "# w = ", join("",@@Alnum_), "\n";
        for (@@Alnum_) {
d762 19
d782 1
d786 517
a1302 1
	$BoThCaSe{$_}++ if exists $UPPER{$_};
d1304 2
a1305 3
    foreach (keys %BoThCaSe) {
	delete $UPPER{$_};
	delete $lower{$_};
d1307 1
d1309 13
a1321 3
    debug "# UPPER    = ", join("", sort keys %UPPER   ), "\n";
    debug "# lower    = ", join("", sort keys %lower   ), "\n";
    debug "# BoThCaSe = ", join("", sort keys %BoThCaSe), "\n";
d1323 4
a1326 5
    my @@failures;
    my @@fold_failures;
    foreach my $x (sort keys %UPPER) {
        my $ok;
        my $fold_ok;
d1329 1
a1329 2
            $ok = $x =~ /[[:upper:]]/;
            $fold_ok = $x =~ /[[:lower:]]/i;
d1332 1
a1332 3
            use locale;
            $ok = $x =~ /[[:upper:]]/;
            $fold_ok = $x =~ /[[:lower:]]/i;
a1333 2
        push @@failures, $x unless $ok;
        push @@fold_failures, $x unless $fold_ok;
d1335 1
a1335 6
    my $message = "";
    $locales_test_number++;
    $first_casing_test_number = $locales_test_number;
    $test_names{$locales_test_number} = 'Verify that /[[:upper:]]/ matches sieved uppercase characters.';
    $message = 'Failed for ' . join ", ", @@failures if @@failures;
    tryneoalpha($Locale, $locales_test_number, scalar @@failures == 0, $message);
d1337 13
a1349 2
    $message = "";
    $locales_test_number++;
d1351 13
a1363 7
    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/i matches sieved uppercase characters.';
    $message = 'Failed for ' . join ", ", @@fold_failures if @@fold_failures;
    tryneoalpha($Locale, $locales_test_number, scalar @@fold_failures == 0, $message);

    $message = "";
    undef @@failures;
    undef @@fold_failures;
d1365 4
a1368 3
    foreach my $x (sort keys %lower) {
        my $ok;
        my $fold_ok;
d1371 1
a1371 2
            $ok = $x =~ /[[:lower:]]/;
            $fold_ok = $x =~ /[[:upper:]]/i;
d1374 1
a1374 3
            use locale;
            $ok = $x =~ /[[:lower:]]/;
            $fold_ok = $x =~ /[[:upper:]]/i;
a1375 2
        push @@failures, $x unless $ok;
        push @@fold_failures, $x unless $fold_ok;
d1377 1
d1379 2
a1380 20
    $locales_test_number++;
    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/ matches sieved lowercase characters.';
    $message = 'Failed for ' . join ", ", @@failures if @@failures;
    tryneoalpha($Locale, $locales_test_number, scalar @@failures == 0, $message);
    $message = "";
    $locales_test_number++;
    $final_casing_test_number = $locales_test_number;
    $test_names{$locales_test_number} = 'Verify that /[[:upper:]]/i matches sieved lowercase characters.';
    $message = 'Failed for ' . join ", ", @@fold_failures if @@fold_failures;
    tryneoalpha($Locale, $locales_test_number, scalar @@fold_failures == 0, $message);

    {   # Find the alphabetic characters that are not considered alphabetics
        # in the default (C) locale.

	no locale;

	@@Neoalpha = ();
	for (keys %UPPER, keys %lower) {
	    push(@@Neoalpha, $_) if (/\W/);
	}
a1382 1
    @@Neoalpha = sort @@Neoalpha;
d1384 1
a1384 1
    debug "# Neoalpha = ", join("",@@Neoalpha), "\n";
d1386 2
a1387 17
    my $first_Neoalpha_test_number =  $locales_test_number + 1;
    my $final_Neoalpha_test_number =  $first_Neoalpha_test_number + 3;
    if (@@Neoalpha == 0) {
	# If we have no Neoalphas the remaining tests are no-ops.
	debug "# no Neoalpha, skipping tests $first_Neoalpha_test_number..$final_Neoalpha_test_number for locale '$Locale'\n";
	foreach ($locales_test_number+1..$final_Neoalpha_test_number) {
	    push @@{$Okay{$_}}, $Locale;
            $locales_test_number++;
	}
    } else {

	# Test \w.

	my $word = join('', @@Neoalpha);

        ++$locales_test_number;
        $test_names{$locales_test_number} = 'Verify that alnums outside the C locale match \w';
d1389 1
d1392 1
a1392 1
	    $ok = $word =~ /^(\w+)$/;
d1395 2
a1396 2
            # Already in 'use locale'; this tests that exiting scopes works
	    $ok = $word =~ /^(\w+)$/;
d1398 3
a1400 1
        tryneoalpha($Locale, $locales_test_number, $ok);
d1402 3
a1404 1
	# Cross-check the whole 8-bit character set.
d1407 12
a1418 21
        $test_names{$locales_test_number} = 'Verify that \w and \W are mutually exclusive, as are \d, \D; \s, \S';
	for (map { chr } 0..255) {
            if ($is_utf8_locale) {
                use locale ':not_characters';
	        $ok =   (/\w/ xor /\W/) ||
			(/\d/ xor /\D/) ||
			(/\s/ xor /\S/);
            }
            else {
	        $ok =   (/\w/ xor /\W/) ||
			(/\d/ xor /\D/) ||
			(/\s/ xor /\S/);
            }
	    tryneoalpha($Locale, $locales_test_number, $ok);
	}

	# Test for read-only scalars' locale vs non-locale comparisons.

	{
	    no locale;
	    $a = "qwerty";
d1421 3
a1423 1
                $ok = ($a cmp "qwerty") == 0;
d1427 3
a1429 1
                $ok = ($a cmp "qwerty") == 0;
d1431 19
a1449 21
            tryneoalpha($Locale, ++$locales_test_number, $ok);
            $test_names{$locales_test_number} = 'Verify that cmp works with a read-only scalar; no- vs locale';
	}

	{
	    my ($from, $to, $lesser, $greater,
		@@test, %test, $test, $yes, $no, $sign);

            ++$locales_test_number;
            $test_names{$locales_test_number} = 'Verify that "le", "ne", etc work';
            $not_necessarily_a_problem_test_number = $locales_test_number;
	    for (0..9) {
		# Select a slice.
		$from = int(($_*@@Alnum_)/10);
		$to = $from + int(@@Alnum_/10);
		$to = $#Alnum_ if ($to > $#Alnum_);
		$lesser  = join('', @@Alnum_[$from..$to]);
		# Select a slice one character on.
		$from++; $to++;
		$to = $#Alnum_ if ($to > $#Alnum_);
		$greater = join('', @@Alnum_[$from..$to]);
d1452 1
a1452 3
                    ($yes, $no, $sign) = ($lesser lt $greater
				      ? ("    ", "not ", 1)
				      : ("not ", "    ", -1));
d1455 2
a1456 4
                    use locale;
                    ($yes, $no, $sign) = ($lesser lt $greater
				      ? ("    ", "not ", 1)
				      : ("not ", "    ", -1));
d1458 16
a1473 22
		# all these tests should FAIL (return 0).
		# Exact lt or gt cannot be tested because
		# in some locales, say, eacute and E may test equal.
		@@test =
		    (
		     $no.'    ($lesser  le $greater)',  # 1
		     'not      ($lesser  ne $greater)', # 2
		     '         ($lesser  eq $greater)', # 3
		     $yes.'    ($lesser  ge $greater)', # 4
		     $yes.'    ($lesser  ge $greater)', # 5
		     $yes.'    ($greater le $lesser )', # 7
		     'not      ($greater ne $lesser )', # 8
		     '         ($greater eq $lesser )', # 9
		     $no.'     ($greater ge $lesser )', # 10
		     'not (($lesser cmp $greater) == -($sign))' # 11
		     );
		@@test{@@test} = 0 x @@test;
		$test = 0;
		for my $ti (@@test) {
                    if ($is_utf8_locale) {
                        use locale ':not_characters';
                        $test{$ti} = eval $ti;
d1475 2
a1476 29
                    else {
                        # Already in 'use locale';
                        $test{$ti} = eval $ti;
                    }
		    $test ||= $test{$ti}
		}
                tryneoalpha($Locale, $locales_test_number, $test == 0);
		if ($test) {
		    debug "# lesser  = '$lesser'\n";
		    debug "# greater = '$greater'\n";
		    debug "# lesser cmp greater = ",
		          $lesser cmp $greater, "\n";
		    debug "# greater cmp lesser = ",
		          $greater cmp $lesser, "\n";
		    debug "# (greater) from = $from, to = $to\n";
		    for my $ti (@@test) {
			debugf("# %-40s %-4s", $ti,
			       $test{$ti} ? 'FAIL' : 'ok');
			if ($ti =~ /\(\.*(\$.+ +cmp +\$[^\)]+)\.*\)/) {
			    debugf("(%s == %4d)", $1, eval $1);
			}
			debug "\n#";
		    }

		    last;
		}
	    }
	}
    }
d1478 3
a1480 6
    if ($locales_test_number != $final_Neoalpha_test_number) {
        die("The delta for \$final_Neoalpha needs to be updated from "
            . ($final_Neoalpha_test_number - $first_Neoalpha_test_number)
            . " to "
            . ($locales_test_number - $first_Neoalpha_test_number)
            );
d1496 5
d1507 3
d1544 1
a1544 11
                # The earlier test was $e = "$x".  But this fails [perl
                # #108378], and the "no locale" was commented out.  But doing
                # that made all the tests in the block after this one
                # meaningless, as originally it was testing the nesting of a
                # "no locale" scope, and how it recovers after that scope is
                # done.  So I (khw) filed a bug report and changed this so it
                # wouldn't fail.  It seemed too much work to add TODOs
                # instead.  Should this be fixed, the following test names
                # would need to be revised; they mostly don't really test
                # anything currently.
                $e = $x;
d1553 3
d1562 1
d1564 5
d1596 1
a1596 1
                $e = $x;
d1605 3
d1614 24
d1639 5
d1646 1
a1646 1
    tryneoalpha($Locale, ++$locales_test_number, $ok1);
d1652 1
a1652 1
    tryneoalpha($Locale, ++$locales_test_number, $ok2);
d1657 1
a1657 1
    tryneoalpha($Locale, ++$locales_test_number, $ok3);
d1659 1
d1661 1
a1661 1
    tryneoalpha($Locale, ++$locales_test_number, $ok4);
d1663 1
d1665 1
a1665 1
    tryneoalpha($Locale, ++$locales_test_number, $ok5);
d1667 1
d1671 2
a1672 2
    tryneoalpha($Locale, ++$locales_test_number, $ok6);
    $test_names{$locales_test_number} = 'Verify that can assign numerically under inner no-locale block';
d1675 1
a1675 1
    tryneoalpha($Locale, ++$locales_test_number, $ok7);
d1678 1
a1678 1
    tryneoalpha($Locale, ++$locales_test_number, $ok8);
d1680 1
d1684 1
a1684 1
    tryneoalpha($Locale, ++$locales_test_number, $ok9);
d1686 1
d1689 1
a1689 1
    tryneoalpha($Locale, ++$locales_test_number, $ok10);
d1691 1
d1693 1
a1693 1
    tryneoalpha($Locale, ++$locales_test_number, $ok11);
d1695 1
d1697 1
a1697 1
    tryneoalpha($Locale, ++$locales_test_number, $ok12);
d1699 1
d1701 1
a1701 1
    tryneoalpha($Locale, ++$locales_test_number, $ok13);
d1703 16
d1742 1
a1742 1
        tryneoalpha($Locale, ++$locales_test_number,
d1763 1
a1763 1
        tryneoalpha($Locale, ++$locales_test_number,
d1780 1
a1780 1
        foreach my $x (sort keys %UPPER) {
d1784 9
a1792 3
                print "# UPPER $x lc $y ",
                        $x =~ /$y/i ? 1 : 0, " ",
                        $y =~ /$x/i ? 1 : 0, "\n" if 0;
d1821 1
a1821 3
                # With utf8 both will fail since the locale concept
                # of upper/lower does not work well in Unicode.
                push @@f, $x unless $x =~ /$y/i == $y =~ /$x/i;
d1830 9
a1838 3
                print "# UPPER $x lc $y ",
                        $x =~ /$y/i ? 1 : 0, " ",
                        $y =~ /$x/i ? 1 : 0, "\n" if 0;
a1839 2
                # Here, we can fully test things, unlike plain 'use locale',
                # because this form does work well with Unicode
d1848 1
a1848 1
	foreach my $x (sort keys %lower) {
d1852 9
a1860 3
                print "# lower $x uc $y ",
                    $x =~ /$y/i ? 1 : 0, " ",
                    $y =~ /$x/i ? 1 : 0, "\n" if 0;
d1865 1
a1865 3
                # With utf8 both will fail since the locale concept
                # of upper/lower does not work well in Unicode.
                push @@f, $x unless $x =~ /$y/i == $y =~ /$x/i;
d1873 9
a1881 3
                print "# lower $x uc $y ",
                        $x =~ /$y/i ? 1 : 0, " ",
                        $y =~ /$x/i ? 1 : 0, "\n" if 0;
d1887 2
a1888 4
	tryneoalpha($Locale, $locales_test_number, @@f == 0);
	if (@@f) {
	    print "# failed $locales_test_number locale '$Locale' characters @@f\n"
	}
d1896 1
d1919 1
a1919 1
	tryneoalpha($Locale, $locales_test_number, @@f == 0);
d1930 1
a1930 1
foreach ($first_locales_test_number..$final_locales_test_number) {
d1934 1
a1934 1
    elsif ($Problem{$_} || !defined $Okay{$_} || !@@{$Okay{$_}}) {
d1936 1
a1936 1
            && $_ == $not_necessarily_a_problem_test_number)
d1942 9
a1950 7
        if ($Okay{$_} && ($_ >= $first_casing_test_number
                          && $_ <= $final_casing_test_number))
        {
            my $percent_fail = int(.5 + (100 * scalar(keys $Problem{$_})
                                             / scalar(@@{$Okay{$_}})));
            if ($percent_fail < $acceptable_fold_failure_percentage) {
                $test_names{$_} .= 'TODO';
d1956 9
d1967 2
a1968 2
    print "ok $_";
    if (defined $test_names{$_}) {
d1970 2
a1971 2
        my $todo = $test_names{$_} =~ s/TODO\s*//;
        print " $test_names{$_}";
d1977 1
a1977 65
# Give final advice.

my $didwarn = 0;

foreach ($first_locales_test_number..$final_locales_test_number) {
    if ($Problem{$_}) {
	my @@f = sort keys %{ $Problem{$_} };
	my $f = join(" ", @@f);
	$f =~ s/(.{50,60}) /$1\n#\t/g;
	print
	    "#\n",
            "# The locale ", (@@f == 1 ? "definition" : "definitions"), "\n#\n",
	    "#\t", $f, "\n#\n",
	    "# on your system may have errors because the locale test $_\n",
            "# failed in ", (@@f == 1 ? "that locale" : "those locales"),
            ".\n";
	print <<EOW;
#
# If your users are not using these locales you are safe for the moment,
# but please report this failure first to perlbug\@@perl.com using the
# perlbug script (as described in the INSTALL file) so that the exact
# details of the failures can be sorted out first and then your operating
# system supplier can be alerted about these anomalies.
#
EOW
	$didwarn = 1;
    }
}

# Tell which locales were okay and which were not.

if ($didwarn) {
    my (@@s, @@F);

    foreach my $l (@@Locale) {
	my $p = 0;
        if ($setlocale_failed{$l}) {
            $p++;
        }
        else {
            foreach my $t
                        ($first_locales_test_number..$final_locales_test_number)
            {
                $p++ if $Problem{$t}{$l};
            }
	}
	push @@s, $l if $p == 0;
        push @@F, $l unless $p == 0;
    }

    if (@@s) {
        my $s = join(" ", @@s);
        $s =~ s/(.{50,60}) /$1\n#\t/g;

        warn
    	    "# The following locales\n#\n",
            "#\t", $s, "\n#\n",
	    "# tested okay.\n#\n",
    } else {
        warn "# None of your locales were fully okay.\n";
    }

    if (@@F) {
        my $F = join(" ", @@F);
        $F =~ s/(.{50,60}) /$1\n#\t/g;
d1979 9
a1987 7
        warn
          "# The following locales\n#\n",
          "#\t", $F, "\n#\n",
          "# had problems.\n#\n",
    } else {
        warn "# None of your locales were broken.\n";
    }
a1989 2
$test_num = $final_locales_test_number;

d1995 1
a1995 1
setlocale(LC_ALL, "C");
d2009 1
a2009 1
        # We test an ASCII character, which should change case and be tainted;
a2010 1
        #   and is tainted.
d2012 2
a2013 2
        #   the 255/256 boundary, so doesn't change case and isn't tainted
        # (the \x{149} is one of these, but changes into 2 characters, the
d2016 6
a2021 3
        #   does change, and shouldn't be tainted.  The code below uses its
        #   position in its list as a marker to indicate that it, unlike the
        #   other code points above ASCII, has a successful case change
d2028 1
a2028 1
            @@list = ("", "A", "\xC0", "\x{1E9E}", "\x{100}");
d2095 3
a2097 3
                    # Tainting shouldn't happen for utf8 locales, empty
                    # strings, or those characters above 255.
                    (! $is_utf8_locale && length($char) > 0 && ord($char) < 256)
d2106 85
@


1.2
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d8 2
d30 4
d98 4
a101 2
sub check_taint ($) {
    ok is_tainted($_[0]), "verify that is tainted";
d104 4
a107 2
sub check_taint_not ($) {
    ok((not is_tainted($_[0])), "verify that isn't tainted");
d110 4
d469 1
a469 1
Dansk Danish:dk:da:1 15
d484 1
a484 1
Indonesian:in:id:1 15
d495 1
a495 1
Norsk Norwegian:no no\@@nynorsk:no:1 15
d685 3
a687 1
    my ($Locale, $i, $test) = @@_;
d690 1
a690 1
	debug "# failed $i with locale '$Locale'\n";
d699 2
d771 64
d850 2
a851 2
    my $first_Neoalpha_test_number =  $locales_test_number;
    my $final_Neoalpha_test_number =  $first_Neoalpha_test_number + 4;
d854 1
a854 1
	debug "# no Neoalpha, skipping tests $locales_test_number..$final_Neoalpha_test_number for locale '$Locale'\n";
d1332 33
d1383 12
d1398 6
a1403 1
    print " $test_names{$_}" if defined $test_names{$_};
@


1.1
log
@Initial revision
@
text
@d3 8
d16 1
a16 1
    if (!$Config{d_setlocale} || $Config{ccflags} =~ /\bD?NO_LOCALE\b/) {
d24 1
d26 1
a26 1
my $debug = 1;
d55 6
a60 1
$have_setlocale = 0 if (($^O eq 'MSWin32' || $^O eq 'NetWare') && $Config{cc} =~ /^(cl|gcc)/i);
d62 2
a63 1
my $last = $have_setlocale ? &last : &last_without_setlocale;
d65 1
a65 1
print "1..$last\n";
d67 1
a67 1
use vars qw(&LC_ALL);
d69 1
a69 1
$a = 'abc %';
d72 2
a73 1
    my ($n, $result) = @@_;
d76 3
a78 1
    print "ok $n\n";
d88 1
d92 2
a93 2
sub check_taint ($$) {
    ok $_[0], is_tainted($_[1]);
d96 2
a97 2
sub check_taint_not ($$) {
    ok $_[0], not is_tainted($_[1]);
d102 1
a102 1
check_taint_not   1, $a;
d104 16
a119 14
check_taint       2, uc($a);
check_taint       3, "\U$a";
check_taint       4, ucfirst($a);
check_taint       5, "\u$a";
check_taint       6, lc($a);
check_taint       7, "\L$a";
check_taint       8, lcfirst($a);
check_taint       9, "\l$a";

check_taint_not  10, sprintf('%e', 123.456);
check_taint_not  11, sprintf('%f', 123.456);
check_taint_not  12, sprintf('%g', 123.456);
check_taint_not  13, sprintf('%d', 123.456);
check_taint_not  14, sprintf('%x', 123.456);
d125 1
a125 1
check_taint      15, $_;
d128 6
a133 6
check_taint      16, $&;
check_taint      17, $`;
check_taint      18, $';
check_taint      19, $+;
check_taint      20, $1;
check_taint_not  21, $2;
d136 6
a141 6
check_taint_not  22, $&;
check_taint_not  23, $`;
check_taint_not  24, $';
check_taint_not  25, $+;
check_taint_not  26, $1;
check_taint_not  27, $2;
d144 6
a149 6
check_taint      28, $&;
check_taint      29, $`;
check_taint      30, $';
check_taint      31, $+;
check_taint      32, $1;
check_taint_not  33, $2;
d152 6
a157 6
check_taint      34, $&;
check_taint      35, $`;
check_taint      36, $';
check_taint      37, $+;
check_taint      38, $1;
check_taint_not  39, $2;
d160 6
a165 6
check_taint      40, $&;
check_taint      41, $`;
check_taint      42, $';
check_taint      43, $+;
check_taint      44, $1;
check_taint_not  45, $2;
d169 1
a169 1
check_taint_not  46, $_;
d172 6
a177 6
check_taint_not  47, $&;
check_taint_not  48, $`;
check_taint_not  49, $';
check_taint_not  50, $+;
check_taint_not  51, $1;
check_taint_not  52, $2;
d181 1
a181 1
check_taint_not  53, $_;
d186 7
a192 7
check_taint      54, $_;
check_taint_not  55, $&;
check_taint_not  56, $`;
check_taint_not  57, $';
check_taint_not  58, $+;
check_taint_not  59, $1;
check_taint_not  60, $2;
d197 7
a203 7
check_taint_not  61, $_;
check_taint_not  62, $&;
check_taint_not  63, $`;
check_taint_not  64, $';
check_taint_not  65, $+;
check_taint_not  66, $1;
check_taint_not  67, $2;
d208 2
a209 2
check_taint      68, $b;	# $b should be tainted.
check_taint_not  69, $a;	# $a should be not.
d214 7
a220 7
check_taint      70, $_;
check_taint      71, $&;
check_taint      72, $`;
check_taint      73, $';
check_taint      74, $+;
check_taint      75, $1;
check_taint_not  76, $2;
d225 7
a231 7
check_taint      77, $_;
check_taint      78, $&;
check_taint      79, $`;
check_taint      80, $';
check_taint      81, $+;
check_taint      82, $1;
check_taint_not  83, $2;
d236 7
a242 7
check_taint      84, $_;
check_taint      85, $&;
check_taint      86, $`;
check_taint      87, $';
check_taint      88, $+;
check_taint      89, $1;
check_taint_not  90, $2;
d247 7
a253 7
check_taint      91, $_;
check_taint      92, $&;
check_taint      93, $`;
check_taint      94, $';
check_taint      95, $+;
check_taint      96, $1;
check_taint_not  97, $2;
d257 160
a416 1
check_taint_not  98, $a;
d418 6
a423 1
sub last_without_setlocale { 98 }
d429 7
a435 1
exit unless $have_setlocale;
d444 1
a444 1
# vendor might have them capitalized errorneously anyway).
a513 7
my @@utf8locale;
my %utf8skip;

sub getalnum_ {
    sort grep /\w/, map { chr } 0..255
}

d516 8
a523 2
    if (setlocale(LC_ALL, $locale)) {
	push @@Locale, $locale;
d525 6
d578 4
d587 1
a587 1
# The SYS$I18N_LOCALE logical name search list was not present on 
d595 11
d644 13
d667 2
a668 2
my @@Neoalpha;
my %Neoalpha;
d680 5
d686 1
a687 2
    @@Alnum_ = getalnum_();
    debug "# w = ", join("",@@Alnum_), "\n";
d690 1
a690 3
	foreach (99..103) {
	    $Problem{$_}{$Locale} = -1;
	}
d694 6
a699 2
    # Sieve the uppercase and the lowercase.
    
d703 34
a736 9
    for (@@Alnum_) {
	if (/[^\d_]/) { # skip digits and the _
	    if (uc($_) eq $_) {
		$UPPER{$_} = $_;
	    }
	    if (lc($_) eq $_) {
		$lower{$_} = $_;
	    }
	}
d753 2
a754 1
    # Find the alphabets that are not alphabets in the default locale.
a755 1
    {
d757 1
a757 1
    
a760 1
	    $Neoalpha{$_} = $_;
d768 2
d772 2
a773 2
	debug "# no Neoalpha, skipping tests 99..102 for locale '$Locale'\n";
	foreach (99..102) {
d775 1
d780 1
a780 1
    
d783 12
a794 10
	if ($Locale =~ /utf-?8/i) {
	    debug "# unknown whether locale and Unicode have the same \\w, skipping test 99 for locale '$Locale'\n";
	    push @@{$Okay{99}}, $Locale;
	} else {
	    if ($word =~ /^(\w+)$/) {
		tryneoalpha($Locale, 99, 1);
	    } else {
		tryneoalpha($Locale, 99, 0);
	    }
	}
d798 2
d801 3
a803 2
	    tryneoalpha($Locale, 100,
			(/\w/ xor /\W/) ||
d805 8
a812 1
			(/\s/ xor /\S/));
d820 10
a829 4
	    {
		use locale;
		tryneoalpha($Locale, 101, ($a cmp "qwerty") == 0);
	    }
d836 3
d849 9
a857 1
		($yes, $no, $sign) = ($lesser lt $greater
d860 1
d864 1
a864 1
		@@test = 
d880 8
a887 1
		    $test{$ti} = eval $ti;
d890 1
a890 1
		tryneoalpha($Locale, 102, $test == 0);
d914 27
a940 1
    use locale;
d942 2
a943 1
    my ($x, $y) = (1.23, 1.23);
d945 1
a945 3
    $a = "$x";
    printf ''; # printf used to reset locale to "C"
    $b = "$y";
d947 98
a1044 1
    debug "# 103..107: a = $a, b = $b, Locale = $Locale\n";
d1046 3
a1048 1
    tryneoalpha($Locale, 103, $a eq $b);
d1050 1
a1050 3
    my $c = "$x";
    my $z = sprintf ''; # sprintf used to reset locale to "C"
    my $d = "$y";
d1052 2
a1053 1
    debug "# 104..107: c = $c, d = $d, Locale = $Locale\n";
d1055 1
a1055 1
    tryneoalpha($Locale, 104, $c eq $d); 
d1057 2
a1058 8
    {
	use warnings;
	my $w = 0;
	local $SIG{__WARN__} =
	    sub {
		print "# @@_\n";
		$w++;
	    };
d1060 2
a1061 2
	# The == (among other ops) used to warn for locales
	# that had something else than "." as the radix character.
d1063 2
a1064 1
	tryneoalpha($Locale, 105, $c == 1.23);
d1066 1
a1066 1
	tryneoalpha($Locale, 106, $c == $x);
d1068 3
a1070 1
	tryneoalpha($Locale, 107, $c == $d);
d1072 2
a1073 4
	{
#	    no locale; # XXX did this ever work correctly?
	
	    my $e = "$x";
d1075 2
a1076 1
	    debug "# 108..110: e = $e, Locale = $Locale\n";
d1078 1
a1078 1
	    tryneoalpha($Locale, 108, $e == 1.23);
d1080 3
a1082 7
	    tryneoalpha($Locale, 109, $e == $x);
	    
	    tryneoalpha($Locale, 110, $e == $c);
	}
	
	my $f = "1.23";
	my $g = 2.34;
d1084 2
a1085 1
	debug "# 111..115: f = $f, g = $g, locale = $Locale\n";
d1087 2
a1088 1
	tryneoalpha($Locale, 111, $f == 1.23);
d1090 2
a1091 3
	tryneoalpha($Locale, 112, $f == $x);
	
	tryneoalpha($Locale, 113, $f == $c);
d1093 2
a1094 1
	tryneoalpha($Locale, 114, abs(($f + $g) - 3.57) < 0.01);
d1096 1
a1096 2
	tryneoalpha($Locale, 115, $w == 0);
    }
d1101 1
a1101 1
    {
d1118 1
a1118 1
        tryneoalpha($Locale, 116,
d1122 22
d1154 60
a1213 56
        foreach my $x (keys %UPPER) {
	    my $y = lc $x;
	    next unless uc $y eq $x;
	    print "# UPPER $x lc $y ",
	    $x =~ /$y/i ? 1 : 0, " ",
	    $y =~ /$x/i ? 1 : 0, "\n" if 0;
	    #
	    # If $x and $y contain regular expression characters
	    # AND THEY lowercase (/i) to regular expression characters,
	    # regcomp() will be mightily confused.  No, the \Q doesn't
	    # help here (maybe regex engine internal lowercasing
	    # is done after the \Q?)  An example of this happening is
	    # the bg_BG (Bulgarian) locale under EBCDIC (OS/390 USS):
	    # the chr(173) (the "[") is the lowercase of the chr(235).
	    #
	    # Similarly losing EBCDIC locales include cs_cz, cs_CZ,
	    # el_gr, el_GR, en_us.IBM-037 (!), en_US.IBM-037 (!),
	    # et_ee, et_EE, hr_hr, hr_HR, hu_hu, hu_HU, lt_LT,
	    # mk_mk, mk_MK, nl_nl.IBM-037, nl_NL.IBM-037,
	    # pl_pl, pl_PL, ro_ro, ro_RO, ru_ru, ru_RU,
	    # sk_sk, sk_SK, sl_si, sl_SI, tr_tr, tr_TR.
	    #
	    # Similar things can happen even under (bastardised)
	    # non-EBCDIC locales: in many European countries before the
	    # advent of ISO 8859-x nationally customised versions of
	    # ISO 646 were devised, reusing certain punctuation
	    # characters for modified characters needed by the
	    # country/language.  For example, the "|" might have
	    # stood for U+00F6 or LATIN SMALL LETTER O WITH DIAERESIS.
	    #
	    if ($x =~ $re || $y =~ $re) {
		print "# Regex characters in '$x' or '$y', skipping test 117 for locale '$Locale'\n";
		next;
	    }
	    # With utf8 both will fail since the locale concept
	    # of upper/lower does not work well in Unicode.
	    push @@f, $x unless $x =~ /$y/i == $y =~ /$x/i;

	    foreach my $x (keys %lower) {
		my $y = uc $x;
		next unless lc $y eq $x;
		print "# lower $x uc $y ",
		$x =~ /$y/i ? 1 : 0, " ",
		$y =~ /$x/i ? 1 : 0, "\n" if 0;
		if ($x =~ $re || $y =~ $re) { # See above.
		    print "# Regex characters in '$x' or '$y', skipping test 117 for locale '$Locale'\n";
		    next;
		}
		# With utf8 both will fail since the locale concept
		# of upper/lower does not work well in Unicode.
		push @@f, $x unless $x =~ /$y/i == $y =~ /$x/i;
	    }
	    tryneoalpha($Locale, 117, @@f == 0);
	    if (@@f) {
		print "# failed 117 locale '$Locale' characters @@f\n"
  	    }
d1215 34
d1252 2
d1256 9
a1264 4
foreach (&last_without_setlocale()+1..$last) {
    if ($Problem{$_} || !defined $Okay{$_} || !@@{$Okay{$_}}) {
	if ($_ == 102) {
	    print "# The failure of test 102 is not necessarily fatal.\n";
d1270 3
a1272 1
    print "ok $_\n";
d1279 1
a1279 1
foreach (99..$last) {
d1308 1
a1308 1
    
d1311 9
a1319 2
	foreach my $t (102..$last) {
	    $p++ if $Problem{$t}{$l};
d1322 1
a1322 1
      push @@F, $l unless $p == 0;
d1324 1
a1324 1
    
d1348 16
d1365 101
a1465 9
    if (@@utf8locale) {
        my $S = join(" ", @@utf8locale);
        $S =~ s/(.{50,60}) /$1\n#\t/g;
    
        warn "#\n# The following locales\n#\n",
             "#\t", $S, "\n#\n",
             "# were skipped for the tests ",
             join(" ", sort {$a<=>$b} keys %utf8skip), "\n",
            "# because UTF-8 and locales do not work together in Perl.\n#\n";
d1469 1
a1469 1
sub last { 117 }
@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@a47 3
# UWIN seems to loop after test 98, just skip for now
$have_setlocale = 0 if ($^O =~ /^uwin/);

d526 1
a526 11
	my $badutf8;
	{
	    local $SIG{__WARN__} = sub {
		$badutf8 = $_[0] =~ /Malformed UTF-8/;
	    };
	    $Locale =~ /utf-?8/i;
	}

	if ($badutf8) {
	    debug "# Locale name contains bad UTF-8, skipping test 99 for locale '$Locale'\n";
	} elsif ($Locale =~ /utf-?8/i) {
@


1.1.1.3
log
@Import of stock perl 5.8.5
@
text
@a384 4
	# It seems that /usr/bin/locale steadfastly outputs 8 bit data, which
	# ain't great when we're running this testPERL_UNICODE= so that utf8
	# locales will cause all IO hadles to default to (assume) utf8
	next unless utf8::valid($_);
@


1.1.1.4
log
@perl 5.8.8 import
@
text
@a439 9
if ($^O eq 'darwin') {
    # Darwin 8/Mac OS X 10.4 has bad Basque locales: perl bug #35895,
    # Apple bug ID# 4139653. It also has a problem in Byelorussian.
    if ($Config{osvers} ge '8' and $Config{osvers} lt '9') {
	debug "# Skipping eu_ES, be_BY locales -- buggy in Darwin\n";
	@@Locale = grep ! m/^(eu_ES|be_BY.CP1131$)/, @@Locale;
    }
}

@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d46 1
a46 6
# This doesn't seem to be an issue any more, at least on Windows XP,
# so re-enable the tests for Windows XP onwards.
my $winxp = ($^O eq 'MSWin32' && defined &Win32::GetOSVersion &&
		join('.', (Win32::GetOSVersion())[1..2]) >= 5.1);
$have_setlocale = 0 if ((($^O eq 'MSWin32' && !$winxp) || $^O eq 'NetWare') &&
		$Config{cc} =~ /^(cl|gcc)/i);
d55 1
a55 1
sub LC_ALL ();
a401 11
} elsif ($^O eq 'openbsd' && -e '/usr/share/locale') {

   # OpenBSD doesn't have a locale executable, so reading /usr/share/locale
   # is much easier and faster than the last resort method.

    opendir(LOCALES, '/usr/share/locale');
    while ($_ = readdir(LOCALES)) {
        chomp;
        trylocale($_);
    }
    close(LOCALES);
d441 1
a441 1
    # Darwin 8/Mac OS X 10.4 and 10.5 have bad Basque locales: perl bug #35895,
d443 1
a443 2
    (my $v) = $Config{osvers} =~ /^(\d+)/;
    if ($v >= 8 and $v < 10) {
@


1.1.1.6
log
@Perl 5.12.2 from CPAN
@
text
@d462 1
a462 4
	@@Locale = grep ! m/^(eu_ES(?:\..*)?|be_BY\.CP1131)$/, @@Locale;
    } elsif ($v < 11) {
	debug "# Skipping be_BY locales -- buggy in Darwin\n";
	@@Locale = grep ! m/^be_BY\.CP1131$/, @@Locale;
@


1.1.1.7
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@a2 8
# This tests plain 'use locale' and adorned 'use locale ":not_characters"'
# Because these pragmas are compile time, and I (khw) am trying to test
# without using 'eval' as much as possible, which might cloud the issue,  the
# crucial parts of the code are duplicated in a block for each pragma.

binmode STDOUT, ':utf8';
binmode STDERR, ':utf8';

a15 1
use feature 'fc';
d17 1
a17 1
my $debug = 0;
d53 1
a53 1
# UWIN seems to loop after taint tests, just skip for now
d56 4
a63 2
my $test_num = 0;

d65 1
a65 2
    my ($result, $message) = @@_;
    $message = "" unless defined $message;
d68 1
a68 3
    print "ok " . ++$test_num;
    print " $message";
    print "\n";
a77 1
    local $@@;
d81 2
a82 2
sub check_taint ($) {
    ok is_tainted($_[0]), "verify that is tainted";
d85 2
a86 2
sub check_taint_not ($) {
    ok((not is_tainted($_[0])), "verify that isn't tainted");
d91 1
a91 1
check_taint_not   $a;
d93 14
a106 16
check_taint       uc($a);
check_taint       "\U$a";
check_taint       ucfirst($a);
check_taint       "\u$a";
check_taint       lc($a);
check_taint       fc($a);
check_taint       "\L$a";
check_taint       "\F$a";
check_taint       lcfirst($a);
check_taint       "\l$a";

check_taint_not  sprintf('%e', 123.456);
check_taint_not  sprintf('%f', 123.456);
check_taint_not  sprintf('%g', 123.456);
check_taint_not  sprintf('%d', 123.456);
check_taint_not  sprintf('%x', 123.456);
d112 1
a112 1
check_taint      $_;
d115 6
a120 6
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d123 6
a128 6
check_taint_not  $&;
check_taint_not  $`;
check_taint_not  $';
check_taint_not  $+;
check_taint_not  $1;
check_taint_not  $2;
d131 6
a136 6
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d139 6
a144 6
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d147 6
a152 6
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d156 1
a156 1
check_taint_not  $_;
d159 6
a164 6
check_taint_not  $&;
check_taint_not  $`;
check_taint_not  $';
check_taint_not  $+;
check_taint_not  $1;
check_taint_not  $2;
d168 1
a168 1
check_taint_not  $_;
d173 7
a179 7
check_taint      $_;
check_taint_not  $&;
check_taint_not  $`;
check_taint_not  $';
check_taint_not  $+;
check_taint_not  $1;
check_taint_not  $2;
d184 7
a190 7
check_taint_not  $_;
check_taint_not  $&;
check_taint_not  $`;
check_taint_not  $';
check_taint_not  $+;
check_taint_not  $1;
check_taint_not  $2;
d195 2
a196 2
check_taint      $b;	# $b should be tainted.
check_taint_not  $a;	# $a should be not.
d201 7
a207 7
check_taint      $_;
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d212 7
a218 7
check_taint      $_;
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d223 7
a229 7
check_taint      $_;
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d234 7
a240 7
check_taint      $_;
check_taint      $&;
check_taint      $`;
check_taint      $';
check_taint      $+;
check_taint      $1;
check_taint_not  $2;
d244 1
a244 4
check_taint_not  $a;

{   # This is just the previous tests copied here with a different
    # compile-time pragma.
d246 1
a246 162
    use locale ':not_characters'; # engage restricted locale with different
                                  # tainting rules

    check_taint_not   $a;

    check_taint_not	uc($a);
    check_taint_not	"\U$a";
    check_taint_not	ucfirst($a);
    check_taint_not	"\u$a";
    check_taint_not	lc($a);
    check_taint_not	fc($a);
    check_taint_not	"\L$a";
    check_taint_not	"\F$a";
    check_taint_not	lcfirst($a);
    check_taint_not	"\l$a";

    check_taint_not  sprintf('%e', 123.456);
    check_taint_not  sprintf('%f', 123.456);
    check_taint_not  sprintf('%g', 123.456);
    check_taint_not  sprintf('%d', 123.456);
    check_taint_not  sprintf('%x', 123.456);

    $_ = $a;	# untaint $_

    $_ = uc($a);	# taint $_

    check_taint_not	$_;

    /(\w)/;	# taint $&, $`, $', $+, $1.
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    /(.)/;	# untaint $&, $`, $', $+, $1.
    check_taint_not  $&;
    check_taint_not  $`;
    check_taint_not  $';
    check_taint_not  $+;
    check_taint_not  $1;
    check_taint_not  $2;

    /(\W)/;	# taint $&, $`, $', $+, $1.
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    /(\s)/;	# taint $&, $`, $', $+, $1.
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    /(\S)/;	# taint $&, $`, $', $+, $1.
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    $_ = $a;	# untaint $_

    check_taint_not  $_;

    /(b)/;		# this must not taint
    check_taint_not  $&;
    check_taint_not  $`;
    check_taint_not  $';
    check_taint_not  $+;
    check_taint_not  $1;
    check_taint_not  $2;

    $_ = $a;	# untaint $_

    check_taint_not  $_;

    $b = uc($a);	# taint $b
    s/(.+)/$b/;	# this must taint only the $_

    check_taint_not	$_;
    check_taint_not  $&;
    check_taint_not  $`;
    check_taint_not  $';
    check_taint_not  $+;
    check_taint_not  $1;
    check_taint_not  $2;

    $_ = $a;	# untaint $_

    s/(.+)/b/;	# this must not taint
    check_taint_not  $_;
    check_taint_not  $&;
    check_taint_not  $`;
    check_taint_not  $';
    check_taint_not  $+;
    check_taint_not  $1;
    check_taint_not  $2;

    $b = $a;	# untaint $b

    ($b = $a) =~ s/\w/$&/;
    check_taint_not	$b;	# $b should be tainted.
    check_taint_not  $a;	# $a should be not.

    $_ = $a;	# untaint $_

    s/(\w)/\l$1/;	# this must taint
    check_taint_not	$_;
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    $_ = $a;	# untaint $_

    s/(\w)/\L$1/;	# this must taint
    check_taint_not	$_;
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    $_ = $a;	# untaint $_

    s/(\w)/\u$1/;	# this must taint
    check_taint_not	$_;
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    $_ = $a;	# untaint $_

    s/(\w)/\U$1/;	# this must taint
    check_taint_not	$_;
    check_taint_not	$&;
    check_taint_not	$`;
    check_taint_not	$';
    check_taint_not	$+;
    check_taint_not	$1;
    check_taint_not  $2;

    # After all this tainting $a should be cool.

    check_taint_not  $a;
}

# Here are in scope of 'use locale'
d252 1
a252 7
unless ($have_setlocale) {
    print "1..$test_num\n";
    exit;
}

# The test number before our first setlocale()
my $final_without_setlocale = $test_num;
d261 1
a261 1
# vendor might have them capitalized erroneously anyway).
d331 7
d340 2
a341 13
    return if grep { $locale eq $_ } @@Locale;
    return unless setlocale(LC_ALL, $locale);
    my $badutf8;
    {
        local $SIG{__WARN__} = sub {
            $badutf8 = $_[0] =~ /Malformed UTF-8/;
        };
        $Locale =~ /UTF-?8/i;
    }

    if ($badutf8) {
        ok(0, "Locale name contains malformed utf8");
        return;
a342 1
    push @@Locale, $locale;
d399 1
a399 1
# The SYS$I18N_LOCALE logical name search list was not present on
d463 1
a463 1
    } elsif ($v < 12) {
d479 2
a480 2
my @@Neoalpha;   # Alnums that aren't in the C locale.
my %test_names;
a491 5
my $first_locales_test_number = $final_without_setlocale + 1;
my $locales_test_number;
my $not_necessarily_a_problem_test_number;
my %setlocale_failed;   # List of locales that setlocale() didn't work on

a492 1
    $locales_test_number = $first_locales_test_number - 1;
d494 2
d498 3
a500 1
        $setlocale_failed{$Locale} = $Locale;
d504 2
a505 6
    # We test UTF-8 locales only under ':not_characters'; otherwise they have
    # documented deficiencies.  Non- UTF-8 locales are tested only under plain
    # 'use locale', as otherwise we would have to convert everything in them
    # to Unicode.
    my $is_utf8_locale = $Locale =~ /UTF-?8/i;

d509 9
a517 34

    if (! $is_utf8_locale) {
        use locale;
        @@Alnum_ = sort grep /\w/, map { chr } 0..255;

        debug "# w = ", join("",@@Alnum_), "\n";

        # Sieve the uppercase and the lowercase.

        for (@@Alnum_) {
            if (/[^\d_]/) { # skip digits and the _
                if (uc($_) eq $_) {
                    $UPPER{$_} = $_;
                }
                if (lc($_) eq $_) {
                    $lower{$_} = $_;
                }
            }
        }
    }
    else {
        use locale ':not_characters';
        @@Alnum_ = sort grep /\w/, map { chr } 0..255;
        debug "# w = ", join("",@@Alnum_), "\n";
        for (@@Alnum_) {
            if (/[^\d_]/) { # skip digits and the _
                if (uc($_) eq $_) {
                    $UPPER{$_} = $_;
                }
                if (lc($_) eq $_) {
                    $lower{$_} = $_;
                }
            }
        }
d534 1
a534 2
    {   # Find the alphabetic characters that are not considered alphabetics
        # in the default (C) locale.
d536 1
d538 1
a538 1

d542 1
a549 2
    my $first_Neoalpha_test_number =  $locales_test_number;
    my $final_Neoalpha_test_number =  $first_Neoalpha_test_number + 4;
d552 2
a553 2
	debug "# no Neoalpha, skipping tests $locales_test_number..$final_Neoalpha_test_number for locale '$Locale'\n";
	foreach ($locales_test_number+1..$final_Neoalpha_test_number) {
a554 1
            $locales_test_number++;
d559 2
d562 7
a568 1
	my $word = join('', @@Neoalpha);
d570 12
a581 12
        ++$locales_test_number;
        $test_names{$locales_test_number} = 'Verify that alnums outside the C locale match \w';
        my $ok;
        if ($is_utf8_locale) {
            use locale ':not_characters';
	    $ok = $word =~ /^(\w+)$/;
        }
        else {
            # Already in 'use locale'; this tests that exiting scopes works
	    $ok = $word =~ /^(\w+)$/;
        }
        tryneoalpha($Locale, $locales_test_number, $ok);
a584 2
        ++$locales_test_number;
        $test_names{$locales_test_number} = 'Verify that \w and \W are mutually exclusive, as are \d, \D; \s, \S';
d586 2
a587 8
            if ($is_utf8_locale) {
                use locale ':not_characters';
	        $ok =   (/\w/ xor /\W/) ||
			(/\d/ xor /\D/) ||
			(/\s/ xor /\S/);
            }
            else {
	        $ok =   (/\w/ xor /\W/) ||
d589 1
a589 3
			(/\s/ xor /\S/);
            }
	    tryneoalpha($Locale, $locales_test_number, $ok);
d597 4
a600 10
            if ($is_utf8_locale) {
                use locale ':not_characters';
                $ok = ($a cmp "qwerty") == 0;
            }
            else {
                use locale;
                $ok = ($a cmp "qwerty") == 0;
            }
            tryneoalpha($Locale, ++$locales_test_number, $ok);
            $test_names{$locales_test_number} = 'Verify that cmp works with a read-only scalar; no- vs locale';
a606 3
            ++$locales_test_number;
            $test_names{$locales_test_number} = 'Verify that "le", "ne", etc work';
            $not_necessarily_a_problem_test_number = $locales_test_number;
d617 1
a617 9
                if ($is_utf8_locale) {
                    use locale ':not_characters';
                    ($yes, $no, $sign) = ($lesser lt $greater
				      ? ("    ", "not ", 1)
				      : ("not ", "    ", -1));
                }
                else {
                    use locale;
                    ($yes, $no, $sign) = ($lesser lt $greater
a619 1
                }
d623 1
a623 1
		@@test =
d639 1
a639 8
                    if ($is_utf8_locale) {
                        use locale ':not_characters';
                        $test{$ti} = eval $ti;
                    }
                    else {
                        # Already in 'use locale';
                        $test{$ti} = eval $ti;
                    }
d642 1
a642 1
                tryneoalpha($Locale, $locales_test_number, $test == 0);
d666 1
a666 30
    if ($locales_test_number != $final_Neoalpha_test_number) {
        die("The delta for \$final_Neoalpha needs to be updated from "
            . ($final_Neoalpha_test_number - $first_Neoalpha_test_number)
            . " to "
            . ($locales_test_number - $first_Neoalpha_test_number)
            );
    }

    my $ok1;
    my $ok2;
    my $ok3;
    my $ok4;
    my $ok5;
    my $ok6;
    my $ok7;
    my $ok8;
    my $ok9;
    my $ok10;
    my $ok11;
    my $ok12;
    my $ok13;

    my $c;
    my $d;
    my $e;
    my $f;
    my $g;

    if (! $is_utf8_locale) {
        use locale;
d668 1
a668 1
        my ($x, $y) = (1.23, 1.23);
d670 3
a672 57
        $a = "$x";
        printf ''; # printf used to reset locale to "C"
        $b = "$y";
        $ok1 = $a eq $b;

        $c = "$x";
        my $z = sprintf ''; # sprintf used to reset locale to "C"
        $d = "$y";
        $ok2 = $c eq $d;
        {

            use warnings;
            my $w = 0;
            local $SIG{__WARN__} =
                sub {
                    print "# @@_\n";
                    $w++;
                };

            # The == (among other ops) used to warn for locales
            # that had something else than "." as the radix character.

            $ok3 = $c == 1.23;
            $ok4 = $c == $x;
            $ok5 = $c == $d;
            {
                no locale;

                # The earlier test was $e = "$x".  But this fails [perl
                # #108378], and the "no locale" was commented out.  But doing
                # that made all the tests in the block after this one
                # meaningless, as originally it was testing the nesting of a
                # "no locale" scope, and how it recovers after that scope is
                # done.  So I (khw) filed a bug report and changed this so it
                # wouldn't fail.  It seemed too much work to add TODOs
                # instead.  Should this be fixed, the following test names
                # would need to be revised; they mostly don't really test
                # anything currently.
                $e = $x;

                $ok6 = $e == 1.23;
                $ok7 = $e == $x;
                $ok8 = $e == $c;
            }

            $f = "1.23";
            $g = 2.34;

            $ok9 = $f == 1.23;
            $ok10 = $f == $x;
            $ok11 = $f == $c;
            $ok12 = abs(($f + $g) - 3.57) < 0.01;
            $ok13 = $w == 0;
        }
    }
    else {
        use locale ':not_characters';
d674 1
a674 40
        my ($x, $y) = (1.23, 1.23);
        $a = "$x";
        printf ''; # printf used to reset locale to "C"
        $b = "$y";
        $ok1 = $a eq $b;

        $c = "$x";
        my $z = sprintf ''; # sprintf used to reset locale to "C"
        $d = "$y";
        $ok2 = $c eq $d;
        {
            use warnings;
            my $w = 0;
            local $SIG{__WARN__} =
                sub {
                    print "# @@_\n";
                    $w++;
                };
            $ok3 = $c == 1.23;
            $ok4 = $c == $x;
            $ok5 = $c == $d;
            {
                no locale;
                $e = $x;

                $ok6 = $e == 1.23;
                $ok7 = $e == $x;
                $ok8 = $e == $c;
            }

            $f = "1.23";
            $g = 2.34;

            $ok9 = $f == 1.23;
            $ok10 = $f == $x;
            $ok11 = $f == $c;
            $ok12 = abs(($f + $g) - 3.57) < 0.01;
            $ok13 = $w == 0;
        }
    }
d676 1
a676 3
    tryneoalpha($Locale, ++$locales_test_number, $ok1);
    $test_names{$locales_test_number} = 'Verify that an intervening printf doesn\'t change assignment results';
    my $first_a_test = $locales_test_number;
d678 3
a680 1
    debug "# $first_a_test..$locales_test_number: \$a = $a, \$b = $b, Locale = $Locale\n";
d682 1
a682 2
    tryneoalpha($Locale, ++$locales_test_number, $ok2);
    $test_names{$locales_test_number} = 'Verify that an intervening sprintf doesn\'t change assignment results';
d684 1
a684 1
    my $first_c_test = $locales_test_number;
d686 8
a693 2
    tryneoalpha($Locale, ++$locales_test_number, $ok3);
    $test_names{$locales_test_number} = 'Verify that a different locale radix works when doing "==" with a constant';
d695 2
a696 2
    tryneoalpha($Locale, ++$locales_test_number, $ok4);
    $test_names{$locales_test_number} = 'Verify that a different locale radix works when doing "==" with a scalar';
d698 1
a698 2
    tryneoalpha($Locale, ++$locales_test_number, $ok5);
    $test_names{$locales_test_number} = 'Verify that a different locale radix works when doing "==" with a scalar and an intervening sprintf';
d700 1
a700 1
    debug "# $first_c_test..$locales_test_number: \$c = $c, \$d = $d, Locale = $Locale\n";
d702 1
a702 3
    tryneoalpha($Locale, ++$locales_test_number, $ok6);
    $test_names{$locales_test_number} = 'Verify that can assign numerically under inner no-locale block';
    my $first_e_test = $locales_test_number;
d704 4
a707 2
    tryneoalpha($Locale, ++$locales_test_number, $ok7);
    $test_names{$locales_test_number} = 'Verify that "==" with a scalar still works in inner no locale';
d709 1
a709 2
    tryneoalpha($Locale, ++$locales_test_number, $ok8);
    $test_names{$locales_test_number} = 'Verify that "==" with a scalar and an intervening sprintf still works in inner no locale';
d711 1
a711 1
    debug "# $first_e_test..$locales_test_number: \$e = $e, no locale\n";
d713 7
a719 3
    tryneoalpha($Locale, ++$locales_test_number, $ok9);
    $test_names{$locales_test_number} = 'Verify that after a no-locale block, a different locale radix still works when doing "==" with a constant';
    my $first_f_test = $locales_test_number;
d721 1
a721 2
    tryneoalpha($Locale, ++$locales_test_number, $ok10);
    $test_names{$locales_test_number} = 'Verify that after a no-locale block, a different locale radix still works when doing "==" with a scalar';
d723 1
a723 2
    tryneoalpha($Locale, ++$locales_test_number, $ok11);
    $test_names{$locales_test_number} = 'Verify that after a no-locale block, a different locale radix still works when doing "==" with a scalar and an intervening sprintf';
d725 3
a727 2
    tryneoalpha($Locale, ++$locales_test_number, $ok12);
    $test_names{$locales_test_number} = 'Verify that after a no-locale block, a different locale radix can participate in an addition and function call as numeric';
d729 1
a729 2
    tryneoalpha($Locale, ++$locales_test_number, $ok13);
    $test_names{$locales_test_number} = 'Verify that don\'t get warning under "==" even if radix is not a dot';
d731 2
a732 1
    debug "# $first_f_test..$locales_test_number: \$f = $f, \$g = $g, back to locale = $Locale\n";
d737 1
a737 1
    if (! $is_utf8_locale) {
d754 1
a754 1
        tryneoalpha($Locale, ++$locales_test_number,
a757 22
    else {
	use locale ':not_characters';

	sub lcC {
	    my $lc0 = lc $_[0];
	    my $lc1 = lc $_[1];
	    return $lc0 cmp $lc1;
	}

        sub lcD {
	    return lc($_[0]) cmp lc($_[1]);
	}

        my $x = "ab";
        my $y = "aa";
        my $z = "AB";

        tryneoalpha($Locale, ++$locales_test_number,
		    lcC($x, $y) == 1 && lcD($x, $y) == 1 ||
		    lcC($x, $z) == 0 && lcD($x, $z) == 0);
    }
    $test_names{$locales_test_number} = 'Verify "lc(foo) cmp lc(bar)" is the same as using intermediaries for the cmp';
d768 56
a823 60
        ++$locales_test_number;
        $test_names{$locales_test_number} = 'Verify case insensitive matching works';
        foreach my $x (sort keys %UPPER) {
            if (! $is_utf8_locale) {
                my $y = lc $x;
                next unless uc $y eq $x;
                print "# UPPER $x lc $y ",
                        $x =~ /$y/i ? 1 : 0, " ",
                        $y =~ /$x/i ? 1 : 0, "\n" if 0;
                #
                # If $x and $y contain regular expression characters
                # AND THEY lowercase (/i) to regular expression characters,
                # regcomp() will be mightily confused.  No, the \Q doesn't
                # help here (maybe regex engine internal lowercasing
                # is done after the \Q?)  An example of this happening is
                # the bg_BG (Bulgarian) locale under EBCDIC (OS/390 USS):
                # the chr(173) (the "[") is the lowercase of the chr(235).
                #
                # Similarly losing EBCDIC locales include cs_cz, cs_CZ,
                # el_gr, el_GR, en_us.IBM-037 (!), en_US.IBM-037 (!),
                # et_ee, et_EE, hr_hr, hr_HR, hu_hu, hu_HU, lt_LT,
                # mk_mk, mk_MK, nl_nl.IBM-037, nl_NL.IBM-037,
                # pl_pl, pl_PL, ro_ro, ro_RO, ru_ru, ru_RU,
                # sk_sk, sk_SK, sl_si, sl_SI, tr_tr, tr_TR.
                #
                # Similar things can happen even under (bastardised)
                # non-EBCDIC locales: in many European countries before the
                # advent of ISO 8859-x nationally customised versions of
                # ISO 646 were devised, reusing certain punctuation
                # characters for modified characters needed by the
                # country/language.  For example, the "|" might have
                # stood for U+00F6 or LATIN SMALL LETTER O WITH DIAERESIS.
                #
                if ($x =~ $re || $y =~ $re) {
                    print "# Regex characters in '$x' or '$y', skipping test $locales_test_number for locale '$Locale'\n";
                    next;
                }
                # With utf8 both will fail since the locale concept
                # of upper/lower does not work well in Unicode.
                push @@f, $x unless $x =~ /$y/i == $y =~ /$x/i;

                # fc is not a locale concept, so Perl uses lc for it.
                push @@f, $x unless lc $x eq fc $x;
            }
            else {
                use locale ':not_characters';
                my $y = lc $x;
                next unless uc $y eq $x;
                print "# UPPER $x lc $y ",
                        $x =~ /$y/i ? 1 : 0, " ",
                        $y =~ /$x/i ? 1 : 0, "\n" if 0;

                # Here, we can fully test things, unlike plain 'use locale',
                # because this form does work well with Unicode
                push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;

                # The places where Unicode's lc is different from fc are
                # skipped here by virtue of the 'next unless uc...' line above
                push @@f, $x unless lc $x eq fc $x;
            }
a824 34

	foreach my $x (sort keys %lower) {
            if (! $is_utf8_locale) {
                my $y = uc $x;
                next unless lc $y eq $x;
                print "# lower $x uc $y ",
                    $x =~ /$y/i ? 1 : 0, " ",
                    $y =~ /$x/i ? 1 : 0, "\n" if 0;
                if ($x =~ $re || $y =~ $re) { # See above.
                    print "# Regex characters in '$x' or '$y', skipping test $locales_test_number for locale '$Locale'\n";
                    next;
                }
                # With utf8 both will fail since the locale concept
                # of upper/lower does not work well in Unicode.
                push @@f, $x unless $x =~ /$y/i == $y =~ /$x/i;

                push @@f, $x unless lc $x eq fc $x;
            }
            else {
                use locale ':not_characters';
                my $y = uc $x;
                next unless lc $y eq $x;
                print "# lower $x uc $y ",
                        $x =~ /$y/i ? 1 : 0, " ",
                        $y =~ /$x/i ? 1 : 0, "\n" if 0;
                push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;

                push @@f, $x unless lc $x eq fc $x;
            }
	}
	tryneoalpha($Locale, $locales_test_number, @@f == 0);
	if (@@f) {
	    print "# failed $locales_test_number locale '$Locale' characters @@f\n"
	}
a827 2
my $final_locales_test_number = $locales_test_number;

d830 4
a833 9
foreach ($first_locales_test_number..$final_locales_test_number) {
    if (%setlocale_failed) {
        print "not ";
    }
    elsif ($Problem{$_} || !defined $Okay{$_} || !@@{$Okay{$_}}) {
	if (defined $not_necessarily_a_problem_test_number
            && $_ == $not_necessarily_a_problem_test_number)
        {
	    print "# The failure of test $not_necessarily_a_problem_test_number is not necessarily fatal.\n";
d839 1
a839 3
    print "ok $_";
    print " $test_names{$_}" if defined $test_names{$_};
    print "\n";
d846 1
a846 1
foreach ($first_locales_test_number..$final_locales_test_number) {
d875 1
a875 1

d878 2
a879 9
        if ($setlocale_failed{$l}) {
            $p++;
        }
        else {
            foreach my $t
                        ($first_locales_test_number..$final_locales_test_number)
            {
                $p++ if $Problem{$t}{$l};
            }
d882 1
a882 1
        push @@F, $l unless $p == 0;
d884 1
a884 1

a907 1
}
d909 9
a917 116
$test_num = $final_locales_test_number;

# Test that tainting and case changing works on utf8 strings.  These tests are
# placed last to avoid disturbing the hard-coded test numbers that existed at
# the time these were added above this in this file.
# This also tests that locale overrides unicode_strings in the same scope for
# non-utf8 strings.
setlocale(LC_ALL, "C");
{
    use locale;
    use feature 'unicode_strings';

    foreach my $function ("uc", "ucfirst", "lc", "lcfirst", "fc") {
        my @@list;   # List of code points to test for $function

        # Used to calculate the changed case for ASCII characters by using the
        # ord, instead of using one of the functions under test.
        my $ascii_case_change_delta;
        my $above_latin1_case_change_delta; # Same for the specific ords > 255
                                            # that we use

        # We test an ASCII character, which should change case and be tainted;
        # a Latin1 character, which shouldn't change case under this C locale,
        #   and is tainted.
        # an above-Latin1 character that when the case is changed would cross
        #   the 255/256 boundary, so doesn't change case and isn't tainted
        # (the \x{149} is one of these, but changes into 2 characters, the
        #   first one of which doesn't cross the boundary.
        # the final one in each list is an above-Latin1 character whose case
        #   does change, and shouldn't be tainted.  The code below uses its
        #   position in its list as a marker to indicate that it, unlike the
        #   other code points above ASCII, has a successful case change
        if ($function =~ /^u/) {
            @@list = ("", "a", "\xe0", "\xff", "\x{fb00}", "\x{149}", "\x{101}");
            $ascii_case_change_delta = -32;
            $above_latin1_case_change_delta = -1;
        }
        else {
            @@list = ("", "A", "\xC0", "\x{1E9E}", "\x{100}");
            $ascii_case_change_delta = +32;
            $above_latin1_case_change_delta = +1;
        }
        foreach my $is_utf8_locale (0 .. 1) {
            foreach my $j (0 .. $#list) {
                my $char = $list[$j];

                for my $encoded_in_utf8 (0 .. 1) {
                    my $should_be;
                    my $changed;
                    if (! $is_utf8_locale) {
                        $should_be = ($j == $#list)
                            ? chr(ord($char) + $above_latin1_case_change_delta)
                            : (length $char == 0 || ord($char) > 127)
                            ? $char
                            : chr(ord($char) + $ascii_case_change_delta);

                        # This monstrosity is in order to avoid using an eval,
                        # which might perturb the results
                        $changed = ($function eq "uc")
                                    ? uc($char)
                                    : ($function eq "ucfirst")
                                      ? ucfirst($char)
                                      : ($function eq "lc")
                                        ? lc($char)
                                        : ($function eq "lcfirst")
                                          ? lcfirst($char)
                                          : ($function eq "fc")
                                            ? fc($char)
                                            : die("Unexpected function \"$function\"");
                    }
                    else {
                        {
                            no locale;

                            # For utf8-locales the case changing functions
                            # should work just like they do outside of locale.
                            # Can use eval here because not testing it when
                            # not in locale.
                            $should_be = eval "$function('$char')";
                            die "Unexpected eval error $@@ from 'eval \"$function('$char')\"'" if  $@@;

                        }
                        use locale ':not_characters';
                        $changed = ($function eq "uc")
                                    ? uc($char)
                                    : ($function eq "ucfirst")
                                      ? ucfirst($char)
                                      : ($function eq "lc")
                                        ? lc($char)
                                        : ($function eq "lcfirst")
                                          ? lcfirst($char)
                                          : ($function eq "fc")
                                            ? fc($char)
                                            : die("Unexpected function \"$function\"");
                    }
                    ok($changed eq $should_be,
                        "$function(\"$char\") in C locale "
                        . (($is_utf8_locale)
                            ? "(use locale ':not_characters'"
                            : "(use locale")
                        . (($encoded_in_utf8)
                            ? "; encoded in utf8)"
                            : "; not encoded in utf8)")
                        . " should be \"$should_be\", got \"$changed\"");

                    # Tainting shouldn't happen for utf8 locales, empty
                    # strings, or those characters above 255.
                    (! $is_utf8_locale && length($char) > 0 && ord($char) < 256)
                    ? check_taint($changed)
                    : check_taint_not($changed);

                    # Use UTF-8 next time through the loop
                    utf8::upgrade($char);
                }
            }
        }
d921 1
a921 1
print "1..$test_num\n";
@


1.1.1.8
log
@Import perl-5.18.2

OK espie@@ sthen@@ deraadt@@
@
text
@a7 2
# To make a TODO test, add the string 'TODO' to its %test_names value

a27 4
# Certain tests have been shown to be problematical for a few locales.  Don't
# fail them unless at least this percentage of the tested locales fail.
my $acceptable_fold_failure_percentage = 5;

d92 2
a93 4
sub check_taint ($;$) {
    my $message_tail = $_[1] // "";
    $message_tail = ": $message_tail" if $message_tail;
    ok is_tainted($_[0]), "verify that is tainted$message_tail";
d96 2
a97 4
sub check_taint_not ($;$) {
    my $message_tail = $_[1] // "";
    $message_tail = ": $message_tail" if $message_tail;
    ok((not is_tainted($_[0])), "verify that isn't tainted$message_tail");
a99 4
"\tb\t" =~ /^m?(\s)(.*)\1$/;
check_taint_not   $&, "not tainted outside 'use locale'";
;

d455 1
a455 1
Dansk Danish:da:dk:1 15
d470 1
a470 1
Indonesian:id:id:1 15
d481 1
a481 1
Norsk Norwegian:no no\@@nynorsk nb nn:no:1 15
d671 1
a671 3
    my ($Locale, $i, $test, $message) = @@_;
    $message //= "";
    $message = "  ($message)" if $message;
d674 1
a674 1
	debug "# failed $i with locale '$Locale'$message\n";
a682 2
my $first_casing_test_number;
my $final_casing_test_number;
a752 64
    my @@failures;
    my @@fold_failures;
    foreach my $x (sort keys %UPPER) {
        my $ok;
        my $fold_ok;
        if ($is_utf8_locale) {
            use locale ':not_characters';
            $ok = $x =~ /[[:upper:]]/;
            $fold_ok = $x =~ /[[:lower:]]/i;
        }
        else {
            use locale;
            $ok = $x =~ /[[:upper:]]/;
            $fold_ok = $x =~ /[[:lower:]]/i;
        }
        push @@failures, $x unless $ok;
        push @@fold_failures, $x unless $fold_ok;
    }
    my $message = "";
    $locales_test_number++;
    $first_casing_test_number = $locales_test_number;
    $test_names{$locales_test_number} = 'Verify that /[[:upper:]]/ matches sieved uppercase characters.';
    $message = 'Failed for ' . join ", ", @@failures if @@failures;
    tryneoalpha($Locale, $locales_test_number, scalar @@failures == 0, $message);

    $message = "";
    $locales_test_number++;

    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/i matches sieved uppercase characters.';
    $message = 'Failed for ' . join ", ", @@fold_failures if @@fold_failures;
    tryneoalpha($Locale, $locales_test_number, scalar @@fold_failures == 0, $message);

    $message = "";
    undef @@failures;
    undef @@fold_failures;

    foreach my $x (sort keys %lower) {
        my $ok;
        my $fold_ok;
        if ($is_utf8_locale) {
            use locale ':not_characters';
            $ok = $x =~ /[[:lower:]]/;
            $fold_ok = $x =~ /[[:upper:]]/i;
        }
        else {
            use locale;
            $ok = $x =~ /[[:lower:]]/;
            $fold_ok = $x =~ /[[:upper:]]/i;
        }
        push @@failures, $x unless $ok;
        push @@fold_failures, $x unless $fold_ok;
    }

    $locales_test_number++;
    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/ matches sieved lowercase characters.';
    $message = 'Failed for ' . join ", ", @@failures if @@failures;
    tryneoalpha($Locale, $locales_test_number, scalar @@failures == 0, $message);
    $message = "";
    $locales_test_number++;
    $final_casing_test_number = $locales_test_number;
    $test_names{$locales_test_number} = 'Verify that /[[:upper:]]/i matches sieved lowercase characters.';
    $message = 'Failed for ' . join ", ", @@fold_failures if @@fold_failures;
    tryneoalpha($Locale, $locales_test_number, scalar @@fold_failures == 0, $message);

d768 2
a769 2
    my $first_Neoalpha_test_number =  $locales_test_number + 1;
    my $final_Neoalpha_test_number =  $first_Neoalpha_test_number + 3;
d772 1
a772 1
	debug "# no Neoalpha, skipping tests $first_Neoalpha_test_number..$final_Neoalpha_test_number for locale '$Locale'\n";
a1249 33

    # [perl #109318]
    {
        my @@f = ();
        ++$locales_test_number;
        $test_names{$locales_test_number} = 'Verify atof with locale radix and negative exponent';

        my $radix = POSIX::localeconv()->{decimal_point};
        my @@nums = (
             "3.14e+9",  "3${radix}14e+9",  "3.14e-9",  "3${radix}14e-9",
            "-3.14e+9", "-3${radix}14e+9", "-3.14e-9", "-3${radix}14e-9",
        );

        if (! $is_utf8_locale) {
            use locale;
            for my $num (@@nums) {
                push @@f, $num
                    unless sprintf("%g", $num) =~ /3.+14/;
            }
        }
        else {
            use locale ':not_characters';
            for my $num (@@nums) {
                push @@f, $num
                    unless sprintf("%g", $num) =~ /3.+14/;
            }
        }

	tryneoalpha($Locale, $locales_test_number, @@f == 0);
	if (@@f) {
	    print "# failed $locales_test_number locale '$Locale' numbers @@f\n"
	}
    }
a1267 12
        if ($Okay{$_} && ($_ >= $first_casing_test_number
                          && $_ <= $final_casing_test_number))
        {
            my $percent_fail = int(.5 + (100 * scalar(keys $Problem{$_})
                                             / scalar(@@{$Okay{$_}})));
            if ($percent_fail < $acceptable_fold_failure_percentage) {
                $test_names{$_} .= 'TODO';
                print "# ", 100 - $percent_fail, "% of locales pass the following test, so it is likely that the failures\n";
                print "# are errors in the locale definitions.  The test is marked TODO, as the\n";
                print "# problem is not likely to be Perl's\n";
            }
        }
d1271 1
a1271 6
    if (defined $test_names{$_}) {
        # If TODO is in the test name, make it thus
        my $todo = $test_names{$_} =~ s/TODO\s*//;
        print " $test_names{$_}";
        print " # TODO" if $todo;
    }
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@a21 1
    require './loc_tools.pl';
d28 1
a28 2
# =1 adds debugging output; =2 increases the verbosity somewhat
my $debug = $ENV{PERL_DEBUG_FULL_TEST} // 0;
d32 1
a32 12
# Some Windows machines are defective in every locale but the C, calling \t
# printable; superscripts to be digits, etc.  See
# http://markmail.org/message/5jwam4xsx4amsdnv.  Also on AIX machines, many
# locales call a no-break space a graphic.
# (There aren't 1000 locales currently in existence, so 99.9 works)
my $acceptable_failure_percentage = ($^O =~ / ^ ( MSWin32 | AIX ) $ /ix)
                                     ? 99.9
                                     : 5;

# The list of test numbers of the problematic tests.
my %problematical_tests;

a47 5
sub debug_more {
  return unless $debug > 1;
  return debug(@@_);
}

d52 21
d116 1
a116 1
check_taint_not   $a, "\t\$a";
d139 1
a139 1
check_taint      $_, "\t\$_";
d142 6
a147 6
check_taint      $&, "\t/(\\w)/ \$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d150 6
a155 6
check_taint_not  $&, "\t/(.)/ \$&";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d158 6
a163 14
check_taint      $&, "\t/(\\W)/ \$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\t/(.)/ \$&";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d166 6
a171 9
check_taint      $&, "\t/(\\s)/ \$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\t/(.)/ \$&";
d174 6
a179 74
check_taint      $&, "\t/(\\S)/ \$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\t/(.)/ \$&";

"a" =~ /(a)|(\w)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\t/(a)|(\\w)/ \$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
ok($1 eq 'a', ("\t" x 4) . "\$1 is 'a'");
ok(! defined $2, ("\t" x 4) . "\$2 is undefined");
check_taint_not  $2, "\t\$2";
check_taint_not  $3, "\t\$3";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\t/(.)/ \$&";

"\N{CYRILLIC SMALL LETTER A}" =~ /(\N{CYRILLIC CAPITAL LETTER A})/i;	# no tainting because no locale dependence
check_taint_not      $&, "\t/(\\N{CYRILLIC CAPITAL LETTER A})/i \$&";
check_taint_not      $`, "\t\$`";
check_taint_not      $', "\t\$'";
check_taint_not      $+, "\t\$+";
check_taint_not      $1, "\t\$1";
ok($1 eq "\N{CYRILLIC SMALL LETTER A}", ("\t" x 4) . "\$1 is 'small cyrillic a'");
check_taint_not      $2, "\t\$2";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\t/./ \$&";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\t/(.)/ \$&";

"a:" =~ /(.)\b(.)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\t/(.)\\b(.)/ \$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint      $2, "\t\$2";
check_taint_not  $3, "\t\$3";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\t/./ \$&";

"aa" =~ /(.)\B(.)/;	# taint $&, $`, $', $+, $1.
check_taint      $&, "\t/(.)\\B(.)/ \$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint      $2, "\t\$2";
check_taint_not  $3, "\t\$3";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\t/./ \$&";

"aaa" =~ /(.).(\1)/i;	# notaint because not locale dependent
check_taint_not      $&, "\t/(.).(\\1)/ \$&";
check_taint_not      $`, "\t\$`";
check_taint_not      $', "\t\$'";
check_taint_not      $+, "\t\$+";
check_taint_not      $1, "\t\$1";
check_taint_not      $2, "\t\$2";
check_taint_not  $3, "\t\$3";

/(.)/;	# untaint $&, $`, $', $+, $1.
check_taint_not  $&, "\t/./ \$&";
d183 1
a183 1
check_taint_not  $_, "\t\$_";
d186 6
a191 6
check_taint_not  $&, "\t/(b)/ \$&";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d195 1
a195 1
check_taint_not  $_, "\t\$_";
d200 7
a206 7
check_taint      $_, "\t\$_";
check_taint_not  $&, "\t\$&";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d211 7
a217 7
check_taint_not  $_, "\t\$_";
check_taint_not  $&, "\t\$&";
check_taint_not  $`, "\t\$`";
check_taint_not  $', "\t\$'";
check_taint_not  $+, "\t\$+";
check_taint_not  $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d222 2
a223 2
check_taint      $b, "\t\$b";	# $b should be tainted.
check_taint_not  $a, "\t\$a";	# $a should be not.
d228 7
a234 7
check_taint      $_, "\t\$_";
check_taint      $&, "\t\$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d239 7
a245 7
check_taint      $_, "\t\$_";
check_taint      $&, "\t\$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d250 7
a256 7
check_taint      $_, "\t\$_";
check_taint      $&, "\t\$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d261 7
a267 7
check_taint      $_, "\t\$_";
check_taint      $&, "\t\$&";
check_taint      $`, "\t\$`";
check_taint      $', "\t\$'";
check_taint      $+, "\t\$+";
check_taint      $1, "\t\$1";
check_taint_not  $2, "\t\$2";
d271 1
a271 8
check_taint_not  $a, "\t\$a";

"a" =~ /([a-z])/;
check_taint_not $1, '"a" =~ /([a-z])/';
"foo.bar_baz" =~ /^(.*)[._](.*?)$/;  # Bug 120675
check_taint_not $1, '"foo.bar_baz" =~ /^(.*)[._](.*?)$/';

# BE SURE TO COPY ANYTHING YOU ADD to the block below
a434 5

    "a" =~ /([a-z])/;
    check_taint_not $1, '"a" =~ /([a-z])/';
    "foo.bar_baz" =~ /^(.*)[._](.*?)$/;  # Bug 120675
    check_taint_not $1, '"foo.bar_baz" =~ /^(.*)[._](.*?)$/';
d443 5
d455 60
a514 1
require POSIX; import POSIX ':locale_h';
d516 1
a516 1
my @@Locale = find_locales([ &POSIX::LC_CTYPE, &POSIX::LC_ALL ]);
d518 4
a521 3
debug "# Locales =\n";
for ( @@Locale ) {
    debug "# $_\n";
d524 21
a544 3
unless (@@Locale) {
    print "1..$test_num\n";
    exit;
d547 2
d550 30
a579 1
setlocale(&POSIX::LC_ALL, "C");
d581 2
a582 1
my %posixes;
d584 2
a585 5
my %Problem;
my %Okay;
my %Testing;
my @@Added_alpha;   # Alphas that aren't in the C locale.
my %test_names;
d587 2
a588 41
sub disp_chars {
    # This returns a display string denoting the input parameter @@_, each
    # entry of which is a single character in the range 0-255.  The first part
    # of the output is a string of the characters in @@_ that are ASCII
    # graphics, and hence unambiguously displayable.  They are given by code
    # point order.  The second part is the remaining code points, the ordinals
    # of which are each displayed as 2-digit hex.  Blanks are inserted so as
    # to keep anything from the first part looking like a 2-digit hex number.

    no locale;
    my @@chars = sort { ord $a <=> ord $b } @@_;
    my $output = "";
    my $range_start;
    my $start_class;
    push @@chars, chr(258);  # This sentinel simplifies the loop termination
                            # logic
    foreach my $i (0 .. @@chars - 1) {
        my $char = $chars[$i];
        my $range_end;
        my $class;

        # We avoid using [:posix:] classes, as these are being tested in this
        # file.  Each equivalence class below is for things that can appear in
        # a range; those that can't be in a range have class -1.  0 for those
        # which should be output in hex; and >0 for the other ranges
        if ($char =~ /[A-Z]/) {
            $class = 2;
        }
        elsif ($char =~ /[a-z]/) {
            $class = 3;
        }
        elsif ($char =~ /[0-9]/) {
            $class = 4;
        }
        # Uncomment to get literal punctuation displayed instead of hex
        #elsif ($char =~ /[[\]!"#\$\%&\'()*+,.\/:\\;<=>?\@@\^_`{|}~-]/) {
        #    $class = -1;    # Punct never appears in a range
        #}
        else {
            $class = 0;     # Output in hex
        }
d590 65
a654 12
        if (! defined $range_start) {
            if ($class < 0) {
                $output .= " " . $char;
            }
            else {
                $range_start = ord $char;
                $start_class = $class;
            }
        } # A range ends if not consecutive, or the class-type changes
        elsif (ord $char != ($range_end = ord($chars[$i-1])) + 1
              || $class != $start_class)
        {
d656 1
a656 12
            # Here, the current character is not in the range.  This means the
            # previous character must have been.  Output the range up through
            # that one.
            my $range_length = $range_end - $range_start + 1;
            if ($start_class > 0) {
                $output .= " " . chr($range_start);
                $output .= "-" . chr($range_end) if $range_length > 1;
            }
            else {
                $output .= sprintf(" %02X", $range_start);
                $output .= sprintf("-%02X", $range_end) if $range_length > 1;
            }
d658 10
a667 5
            # Handle the new current character, as potentially beginning a new
            # range
            undef $range_start;
            redo;
        }
d669 1
d671 5
a675 2
    $output =~ s/^ //;
    return $output;
d678 8
a685 2
sub report_result {
    my ($Locale, $i, $pass_fail, $message) = @@_;
d688 1
a688 1
    unless ($pass_fail) {
d690 1
a690 1
	debug "# failed $i ($test_names{$i}) with locale '$Locale'$message\n";
a695 13
sub report_multi_result {
    my ($Locale, $i, $results_ref) = @@_;

    # $results_ref points to an array, each element of which is a character that was
    # in error for this test numbered '$i'.  If empty, the test passed

    my $message = "";
    if (@@$results_ref) {
        $message = join " ", "for", disp_chars(@@$results_ref);
    }
    report_result($Locale, $i, @@$results_ref == 0, $message);
}

d700 1
d703 1
a703 1
foreach my $Locale (@@Locale) {
a704 1
    debug "#\n";
d707 1
a707 1
    unless (setlocale(&POSIX::LC_ALL, $Locale)) {
d712 9
a720 19
    # We test UTF-8 locales only under ':not_characters';  It is easier to
    # test them in other test files than here.  Non- UTF-8 locales are tested
    # only under plain 'use locale', as otherwise we would have to convert
    # everything in them to Unicode.

    my %UPPER = ();     # All alpha X for which uc(X) == X and lc(X) != X
    my %lower = ();     # All alpha X for which lc(X) == X and uc(X) != X
    my %BoThCaSe = ();  # All alpha X for which uc(X) == lc(X) == X

    my $is_utf8_locale = is_locale_utf8($Locale);

    debug "# is utf8 locale? = $is_utf8_locale\n";

    my $radix = localeconv()->{decimal_point};
    if ($radix !~ / ^ [[:ascii:]] + $/x) {
        use bytes;
        $radix = disp_chars(split "", $radix);
    }
    debug "# radix = $radix\n";
d724 3
a726 15
        @@{$posixes{'word'}} = grep /\w/, map { chr } 0..255;
        @@{$posixes{'digit'}} = grep /\d/, map { chr } 0..255;
        @@{$posixes{'space'}} = grep /\s/, map { chr } 0..255;
        @@{$posixes{'alpha'}} = grep /[[:alpha:]]/, map {chr } 0..255;
        @@{$posixes{'alnum'}} = grep /[[:alnum:]]/, map {chr } 0..255;
        @@{$posixes{'ascii'}} = grep /[[:ascii:]]/, map {chr } 0..255;
        @@{$posixes{'blank'}} = grep /[[:blank:]]/, map {chr } 0..255;
        @@{$posixes{'cntrl'}} = grep /[[:cntrl:]]/, map {chr } 0..255;
        @@{$posixes{'graph'}} = grep /[[:graph:]]/, map {chr } 0..255;
        @@{$posixes{'lower'}} = grep /[[:lower:]]/, map {chr } 0..255;
        @@{$posixes{'print'}} = grep /[[:print:]]/, map {chr } 0..255;
        @@{$posixes{'punct'}} = grep /[[:punct:]]/, map {chr } 0..255;
        @@{$posixes{'upper'}} = grep /[[:upper:]]/, map {chr } 0..255;
        @@{$posixes{'xdigit'}} = grep /[[:xdigit:]]/, map {chr } 0..255;
        @@{$posixes{'cased'}} = grep /[[:upper:]]/i, map {chr } 0..255;
d730 1
a730 1
        for (@@{$posixes{'word'}}) {
d743 3
a745 16
        @@{$posixes{'word'}} = grep /\w/, map { chr } 0..255;
        @@{$posixes{'digit'}} = grep /\d/, map { chr } 0..255;
        @@{$posixes{'space'}} = grep /\s/, map { chr } 0..255;
        @@{$posixes{'alpha'}} = grep /[[:alpha:]]/, map {chr } 0..255;
        @@{$posixes{'alnum'}} = grep /[[:alnum:]]/, map {chr } 0..255;
        @@{$posixes{'ascii'}} = grep /[[:ascii:]]/, map {chr } 0..255;
        @@{$posixes{'blank'}} = grep /[[:blank:]]/, map {chr } 0..255;
        @@{$posixes{'cntrl'}} = grep /[[:cntrl:]]/, map {chr } 0..255;
        @@{$posixes{'graph'}} = grep /[[:graph:]]/, map {chr } 0..255;
        @@{$posixes{'lower'}} = grep /[[:lower:]]/, map {chr } 0..255;
        @@{$posixes{'print'}} = grep /[[:print:]]/, map {chr } 0..255;
        @@{$posixes{'punct'}} = grep /[[:punct:]]/, map {chr } 0..255;
        @@{$posixes{'upper'}} = grep /[[:upper:]]/, map {chr } 0..255;
        @@{$posixes{'xdigit'}} = grep /[[:xdigit:]]/, map {chr } 0..255;
        @@{$posixes{'cased'}} = grep /[[:upper:]]/i, map {chr } 0..255;
        for (@@{$posixes{'word'}}) {
a755 19

    # Ordered, where possible,  in groups of "this is a subset of the next
    # one"
    debug "# :upper:  = ", disp_chars(@@{$posixes{'upper'}}), "\n";
    debug "# :lower:  = ", disp_chars(@@{$posixes{'lower'}}), "\n";
    debug "# :cased:  = ", disp_chars(@@{$posixes{'cased'}}), "\n";
    debug "# :alpha:  = ", disp_chars(@@{$posixes{'alpha'}}), "\n";
    debug "# :alnum:  = ", disp_chars(@@{$posixes{'alnum'}}), "\n";
    debug "#  w       = ", disp_chars(@@{$posixes{'word'}}), "\n";
    debug "# :graph:  = ", disp_chars(@@{$posixes{'graph'}}), "\n";
    debug "# :print:  = ", disp_chars(@@{$posixes{'print'}}), "\n";
    debug "#  d       = ", disp_chars(@@{$posixes{'digit'}}), "\n";
    debug "# :xdigit: = ", disp_chars(@@{$posixes{'xdigit'}}), "\n";
    debug "# :blank:  = ", disp_chars(@@{$posixes{'blank'}}), "\n";
    debug "#  s       = ", disp_chars(@@{$posixes{'space'}}), "\n";
    debug "# :punct:  = ", disp_chars(@@{$posixes{'punct'}}), "\n";
    debug "# :cntrl:  = ", disp_chars(@@{$posixes{'cntrl'}}), "\n";
    debug "# :ascii:  = ", disp_chars(@@{$posixes{'ascii'}}), "\n";

a756 1

d767 3
a769 515
    my %Unassigned;
    foreach my $ord ( 0 .. 255 ) {
        $Unassigned{chr $ord} = 1;
    }
    foreach my $class (keys %posixes) {
        foreach my $char (@@{$posixes{$class}}) {
            delete $Unassigned{$char};
        }
    }

    debug "# UPPER    = ", disp_chars(sort { ord $a <=> ord $b } keys %UPPER), "\n";
    debug "# lower    = ", disp_chars(sort { ord $a <=> ord $b } keys %lower), "\n";
    debug "# BoThCaSe = ", disp_chars(sort { ord $a <=> ord $b } keys %BoThCaSe), "\n";
    debug "# Unassigned = ", disp_chars(sort { ord $a <=> ord $b } keys %Unassigned), "\n";

    my @@failures;
    my @@fold_failures;
    foreach my $x (sort { ord $a <=> ord $b } keys %UPPER) {
        my $ok;
        my $fold_ok;
        if ($is_utf8_locale) {
            use locale ':not_characters';
            $ok = $x =~ /[[:upper:]]/;
            $fold_ok = $x =~ /[[:lower:]]/i;
        }
        else {
            use locale;
            $ok = $x =~ /[[:upper:]]/;
            $fold_ok = $x =~ /[[:lower:]]/i;
        }
        push @@failures, $x unless $ok;
        push @@fold_failures, $x unless $fold_ok;
    }
    $locales_test_number++;
    $first_casing_test_number = $locales_test_number;
    $test_names{$locales_test_number} = 'Verify that /[[:upper:]]/ matches all alpha X for which uc(X) == X and lc(X) != X';
    report_multi_result($Locale, $locales_test_number, \@@failures);

    $locales_test_number++;

    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/i matches all alpha X for which uc(X) == X and lc(X) != X';
    report_multi_result($Locale, $locales_test_number, \@@fold_failures);

    undef @@failures;
    undef @@fold_failures;

    foreach my $x (sort { ord $a <=> ord $b } keys %lower) {
        my $ok;
        my $fold_ok;
        if ($is_utf8_locale) {
            use locale ':not_characters';
            $ok = $x =~ /[[:lower:]]/;
            $fold_ok = $x =~ /[[:upper:]]/i;
        }
        else {
            use locale;
            $ok = $x =~ /[[:lower:]]/;
            $fold_ok = $x =~ /[[:upper:]]/i;
        }
        push @@failures, $x unless $ok;
        push @@fold_failures, $x unless $fold_ok;
    }

    $locales_test_number++;
    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/ matches all alpha X for which lc(X) == X and uc(X) != X';
    report_multi_result($Locale, $locales_test_number, \@@failures);

    $locales_test_number++;
    $test_names{$locales_test_number} = 'Verify that /[[:upper:]]/i matches all alpha X for which lc(X) == X and uc(X) != X';
    report_multi_result($Locale, $locales_test_number, \@@fold_failures);

    {   # Find the alphabetic characters that are not considered alphabetics
        # in the default (C) locale.

	no locale;

	@@Added_alpha = ();
	for (keys %UPPER, keys %lower, keys %BoThCaSe) {
	    push(@@Added_alpha, $_) if (/\W/);
	}
    }

    @@Added_alpha = sort { ord $a <=> ord $b } @@Added_alpha;

    debug "# Added_alpha = ", disp_chars(@@Added_alpha), "\n";

    # Cross-check the whole 8-bit character set.

    ++$locales_test_number;
    my @@f;
    $test_names{$locales_test_number} = 'Verify that \w and [:word:] are identical';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ unless /[[:word:]]/ == /\w/;
        }
        else {
            push @@f, $_ unless /[[:word:]]/ == /\w/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that \d and [:digit:] are identical';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ unless /[[:digit:]]/ == /\d/;
        }
        else {
            push @@f, $_ unless /[[:digit:]]/ == /\d/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that \s and [:space:] are identical';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ unless /[[:space:]]/ == /\s/;
        }
        else {
            push @@f, $_ unless /[[:space:]]/ == /\s/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:posix:] and [:^posix:] are mutually exclusive';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ unless   (/[[:alpha:]]/ xor /[[:^alpha:]]/)   ||
                    (/[[:alnum:]]/ xor /[[:^alnum:]]/)   ||
                    (/[[:ascii:]]/ xor /[[:^ascii:]]/)   ||
                    (/[[:blank:]]/ xor /[[:^blank:]]/)   ||
                    (/[[:cntrl:]]/ xor /[[:^cntrl:]]/)   ||
                    (/[[:digit:]]/ xor /[[:^digit:]]/)   ||
                    (/[[:graph:]]/ xor /[[:^graph:]]/)   ||
                    (/[[:lower:]]/ xor /[[:^lower:]]/)   ||
                    (/[[:print:]]/ xor /[[:^print:]]/)   ||
                    (/[[:space:]]/ xor /[[:^space:]]/)   ||
                    (/[[:upper:]]/ xor /[[:^upper:]]/)   ||
                    (/[[:word:]]/  xor /[[:^word:]]/)    ||
                    (/[[:xdigit:]]/ xor /[[:^xdigit:]]/) ||

                    # effectively is what [:cased:] would be if it existed.
                    (/[[:upper:]]/i xor /[[:^upper:]]/i);
        }
        else {
            push @@f, $_ unless   (/[[:alpha:]]/ xor /[[:^alpha:]]/)   ||
                    (/[[:alnum:]]/ xor /[[:^alnum:]]/)   ||
                    (/[[:ascii:]]/ xor /[[:^ascii:]]/)   ||
                    (/[[:blank:]]/ xor /[[:^blank:]]/)   ||
                    (/[[:cntrl:]]/ xor /[[:^cntrl:]]/)   ||
                    (/[[:digit:]]/ xor /[[:^digit:]]/)   ||
                    (/[[:graph:]]/ xor /[[:^graph:]]/)   ||
                    (/[[:lower:]]/ xor /[[:^lower:]]/)   ||
                    (/[[:print:]]/ xor /[[:^print:]]/)   ||
                    (/[[:space:]]/ xor /[[:^space:]]/)   ||
                    (/[[:upper:]]/ xor /[[:^upper:]]/)   ||
                    (/[[:word:]]/  xor /[[:^word:]]/)    ||
                    (/[[:xdigit:]]/ xor /[[:^xdigit:]]/) ||
                    (/[[:upper:]]/i xor /[[:^upper:]]/i);
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    # The rules for the relationships are given in:
    # http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap07.html


    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:lower:] contains at least a-z';
    for ('a' .. 'z') {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:lower:]]/;
        }
        else {
            push @@f, $_  unless /[[:lower:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:lower:] is a subset of [:alpha:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  if /[[:lower:]]/ and ! /[[:alpha:]]/;
        }
        else {
            push @@f, $_  if /[[:lower:]]/ and ! /[[:alpha:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:upper:] contains at least A-Z';
    for ('A' .. 'Z') {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:upper:]]/;
        }
        else {
            push @@f, $_  unless /[[:upper:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:upper:] is a subset of [:alpha:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  if /[[:upper:]]/ and ! /[[:alpha:]]/;
        }
        else {
            push @@f, $_ if /[[:upper:]]/  and ! /[[:alpha:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that /[[:lower:]]/i is a subset of [:alpha:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:lower:]]/i  and ! /[[:alpha:]]/;
        }
        else {
            push @@f, $_ if /[[:lower:]]/i  and ! /[[:alpha:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:alpha:] is a subset of [:alnum:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:alpha:]]/  and ! /[[:alnum:]]/;
        }
        else {
            push @@f, $_ if /[[:alpha:]]/  and ! /[[:alnum:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:digit:] contains at least 0-9';
    for ('0' .. '9') {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:digit:]]/;
        }
        else {
            push @@f, $_  unless /[[:digit:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:digit:] is a subset of [:alnum:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:digit:]]/  and ! /[[:alnum:]]/;
        }
        else {
            push @@f, $_ if /[[:digit:]]/  and ! /[[:alnum:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:digit:] matches either 10 or 20 code points';
    report_result($Locale, $locales_test_number, @@{$posixes{'digit'}} == 10 || @@{$posixes{'digit'}} == 20);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that if there is a second set of digits in [:digit:], they are consecutive';
    if (@@{$posixes{'digit'}} == 20) {
        my $previous_ord;
        for (map { chr } 0..255) {
            next unless /[[:digit:]]/;
            next if /[0-9]/;
            if (defined $previous_ord) {
                if ($is_utf8_locale) {
                    use locale ':not_characters';
                    push @@f, $_ if ord $_ != $previous_ord + 1;
                }
                else {
                    push @@f, $_ if ord $_ != $previous_ord + 1;
                }
            }
            $previous_ord = ord $_;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    my @@xdigit_digits;  # :digit: & :xdigit:
    $test_names{$locales_test_number} = 'Verify that [:xdigit:] contains one or two blocks of 10 consecutive [:digit:] chars';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            # For utf8 locales, we actually use a stricter test: that :digit:
            # is a subset of :xdigit:, as we know that only 0-9 should match
            push @@f, $_ if /[[:digit:]]/ and ! /[[:xdigit:]]/;
        }
        else {
            push @@xdigit_digits, $_ if /[[:digit:]]/ and /[[:xdigit:]]/;
        }
    }
    if (! $is_utf8_locale) {

        # For non-utf8 locales, @@xdigit_digits is a list of the characters
        # that are both :xdigit: and :digit:.  Because :digit: is stored in
        # increasing code point order (unless the tests above failed),
        # @@xdigit_digits is as well.  There should be exactly 10 or
        # 20 of these.
        if (@@xdigit_digits != 10 && @@xdigit_digits != 20) {
            @@f = @@xdigit_digits;
        }
        else {

            # Look for contiguity in the series, adding any wrong ones to @@f
            my @@temp = @@xdigit_digits;
            while (@@temp > 1) {
                push @@f, $temp[1] if ($temp[0] != $temp[1] - 1)

                                     # Skip this test for the 0th character of
                                     # the second block of 10, as it won't be
                                     # contiguous with the previous block
                                     && (! defined $xdigit_digits[10]
                                         || $temp[1] != $xdigit_digits[10]);
                shift @@temp;
            }
        }
    }

    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:xdigit:] contains at least A-F, a-f';
    for ('A' .. 'F', 'a' .. 'f') {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:xdigit:]]/;
        }
        else {
            push @@f, $_  unless /[[:xdigit:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that any additional members of [:xdigit:], are in groups of 6 consecutive code points';
    my $previous_ord;
    my $count = 0;
    for my $chr (map { chr } 0..255) {
        next unless $chr =~ /[[:xdigit:]]/;
        if ($is_utf8_locale) {
            next if $chr =~ /[[:digit:]]/;
        }
        else {
            next if grep { $chr eq $_ } @@xdigit_digits;
        }
        next if $chr =~ /[A-Fa-f]/;
        if (defined $previous_ord) {
            if ($is_utf8_locale) {
                use locale ':not_characters';
                push @@f, $chr if ord $chr != $previous_ord + 1;
            }
            else {
                push @@f, $chr if ord $chr != $previous_ord + 1;
            }
        }
        $count++;
        if ($count == 6) {
            undef $previous_ord;
        }
        else {
            $previous_ord = ord $chr;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:xdigit:] is a subset of [:graph:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:xdigit:]]/  and ! /[[:graph:]]/;
        }
        else {
            push @@f, $_ if /[[:xdigit:]]/  and ! /[[:graph:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    # Note that xdigit doesn't have to be a subset of alnum

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:punct:] is a subset of [:graph:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:punct:]]/  and ! /[[:graph:]]/;
        }
        else {
            push @@f, $_ if /[[:punct:]]/  and ! /[[:graph:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that the space character is not in [:graph:]';
    if ($is_utf8_locale) {
        use locale ':not_characters';
        push @@f, " " if " " =~ /[[:graph:]]/;
    }
    else {
        push @@f, " " if " " =~ /[[:graph:]]/;
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:space:] contains at least [\f\n\r\t\cK ]';
    for (' ', "\f", "\n", "\r", "\t", "\cK") {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:space:]]/;
        }
        else {
            push @@f, $_  unless /[[:space:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:blank:] contains at least [\t ]';
    for (' ', "\t") {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_  unless /[[:blank:]]/;
        }
        else {
            push @@f, $_  unless /[[:blank:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:blank:] is a subset of [:space:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:blank:]]/  and ! /[[:space:]]/;
        }
        else {
            push @@f, $_ if /[[:blank:]]/  and ! /[[:space:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that [:graph:] is a subset of [:print:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:graph:]]/  and ! /[[:print:]]/;
        }
        else {
            push @@f, $_ if /[[:graph:]]/  and ! /[[:print:]]/;
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);

    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that the space character is in [:print:]';
    if ($is_utf8_locale) {
        use locale ':not_characters';
        push @@f, " " if " " !~ /[[:print:]]/;
    }
    else {
        push @@f, " " if " " !~ /[[:print:]]/;
    }
    report_multi_result($Locale, $locales_test_number, \@@f);
d771 5
a775 4
    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:cntrl:] and [:print:]';
    for (map { chr } 0..255) {
d778 2
a779 1
            push @@f, $_ if (/[[:print:]]/ and /[[:cntrl:]]/);
d782 3
a784 1
            push @@f, $_ if (/[[:print:]]/ and /[[:cntrl:]]/);
d786 2
d789 17
a805 1
    report_multi_result($Locale, $locales_test_number, \@@f);
d807 3
a809 4
    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:alpha:] and [:digit:]';
    for (map { chr } 0..255) {
d812 2
a813 1
            push @@f, $_ if /[[:alpha:]]/ and /[[:digit:]]/;
d816 3
a818 1
            push @@f, $_ if /[[:alpha:]]/ and /[[:digit:]]/;
d820 2
a822 1
    report_multi_result($Locale, $locales_test_number, \@@f);
d824 20
a843 11
    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:alnum:] and [:punct:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if /[[:alnum:]]/ and /[[:punct:]]/;
        }
        else {
            push @@f, $_ if /[[:alnum:]]/ and /[[:punct:]]/;
        }
a844 1
    report_multi_result($Locale, $locales_test_number, \@@f);
d846 1
a846 13
    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:xdigit:] and [:punct:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if (/[[:punct:]]/ and /[[:xdigit:]]/);
        }
        else {
            push @@f, $_ if (/[[:punct:]]/ and /[[:xdigit:]]/);
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);
d848 1
a848 13
    ++$locales_test_number;
    undef @@f;
    $test_names{$locales_test_number} = 'Verify that isn\'t both [:graph:] and [:space:]';
    for (map { chr } 0..255) {
        if ($is_utf8_locale) {
            use locale ':not_characters';
            push @@f, $_ if (/[[:graph:]]/ and /[[:space:]]/);
        }
        else {
            push @@f, $_ if (/[[:graph:]]/ and /[[:space:]]/);
        }
    }
    report_multi_result($Locale, $locales_test_number, \@@f);
d850 10
a859 3
    foreach ($first_casing_test_number..$locales_test_number) {
        $problematical_tests{$_} = 1;
    }
d861 1
d863 1
a863 1
    # Test for read-only scalars' locale vs non-locale comparisons.
d865 2
a866 2
    {
        no locale;
a867 1
        $a = "qwerty";
d870 1
a870 1
            $ok = ($a cmp "qwerty") == 0;
d873 2
a874 2
            use locale;
            $ok = ($a cmp "qwerty") == 0;
d876 1
a876 3
        report_result($Locale, ++$locales_test_number, $ok);
        $test_names{$locales_test_number} = 'Verify that cmp works with a read-only scalar; no- vs locale';
    }
d878 1
a878 3
    {
        my ($from, $to, $lesser, $greater,
            @@test, %test, $test, $yes, $no, $sign);
d881 21
a901 12
        $test_names{$locales_test_number} = 'Verify that "le", "ne", etc work';
        $not_necessarily_a_problem_test_number = $locales_test_number;
        for (0..9) {
            # Select a slice.
            $from = int(($_*@@{$posixes{'word'}})/10);
            $to = $from + int(@@{$posixes{'word'}}/10);
            $to = $#{$posixes{'word'}} if ($to > $#{$posixes{'word'}});
            $lesser  = join('', @@{$posixes{'word'}}[$from..$to]);
            # Select a slice one character on.
            $from++; $to++;
            $to = $#{$posixes{'word'}} if ($to > $#{$posixes{'word'}});
            $greater = join('', @@{$posixes{'word'}}[$from..$to]);
d904 1
a904 3
                ($yes, $no, $sign) = ($lesser lt $greater
                                    ? ("    ", "not ", 1)
                                    : ("not ", "    ", -1));
d908 1
a908 3
                ($yes, $no, $sign) = ($lesser lt $greater
                                    ? ("    ", "not ", 1)
                                    : ("not ", "    ", -1));
d910 21
a930 19
            # all these tests should FAIL (return 0).  Exact lt or gt cannot
            # be tested because in some locales, say, eacute and E may test
            # equal.
            @@test =
                (
                    $no.'    ($lesser  le $greater)',  # 1
                    'not      ($lesser  ne $greater)', # 2
                    '         ($lesser  eq $greater)', # 3
                    $yes.'    ($lesser  ge $greater)', # 4
                    $yes.'    ($lesser  ge $greater)', # 5
                    $yes.'    ($greater le $lesser )', # 7
                    'not      ($greater ne $lesser )', # 8
                    '         ($greater eq $lesser )', # 9
                    $no.'     ($greater ge $lesser )', # 10
                    'not (($lesser cmp $greater) == -($sign))' # 11
                    );
            @@test{@@test} = 0 x @@test;
            $test = 0;
            for my $ti (@@test) {
d933 3
a935 1
                    $test{$ti} = eval $ti;
d938 4
a941 2
                    # Already in 'use locale';
                    $test{$ti} = eval $ti;
d943 26
a968 16
                $test ||= $test{$ti}
            }
            report_result($Locale, $locales_test_number, $test == 0);
            if ($test) {
                debug "# lesser  = '$lesser'\n";
                debug "# greater = '$greater'\n";
                debug "# lesser cmp greater = ",
                        $lesser cmp $greater, "\n";
                debug "# greater cmp lesser = ",
                        $greater cmp $lesser, "\n";
                debug "# (greater) from = $from, to = $to\n";
                for my $ti (@@test) {
                    debugf("# %-40s %-4s", $ti,
                            $test{$ti} ? 'FAIL' : 'ok');
                    if ($ti =~ /\(\.*(\$.+ +cmp +\$[^\)]+)\.*\)/) {
                        debugf("(%s == %4d)", $1, eval $1);
d970 25
a994 2
                    debug "\n#";
                }
d996 6
a1001 3
                last;
            }
        }
a1016 5
    my $ok14;
    my $ok15;
    my $ok16;
    my $ok17;
    my $ok18;
a1022 3
    my $h;
    my $i;
    my $j;
d1057 11
a1067 1
                $e = "$x";
a1075 3
            $h = 1.5;
            $i = 1.25;
            $j = "$h:$i";
a1081 1
            $ok14 = $ok15 = $ok16 = 1;  # Skip for non-utf8 locales
a1082 5
        {
            no locale;
            $ok17 = "1.5:1.25" eq sprintf("%g:%g", $h, $i);
        }
        $ok18 = $j eq sprintf("%g:%g", $h, $i);
d1110 1
a1110 1
                $e = "$x";
a1118 3
            $h = 1.5;
            $i = 1.25;
            $j = "$h:$i";
a1124 24

            # Look for non-ASCII error messages, and verify that the first
            # such is NOT in UTF-8 (the others almost certainly will be like
            # the first)  See [perl #119499].
            $ok14 = 1;
            foreach my $err (keys %!) {
                use Errno;
                $! = eval "&Errno::$err";   # Convert to strerror() output
                my $strerror = "$!";
                if ("$strerror" =~ /\P{ASCII}/) {
                    $ok14 = ! utf8::is_utf8($strerror);
                    last;
                }
            }

            # Similarly, we verify that a non-ASCII radix is in UTF-8.  This
            # also catches if there is a disparity between sprintf and
            # stringification.

            my $string_g = "$g";
            my $sprintf_g = sprintf("%g", $g);

            $ok15 = $string_g =~ / ^ \p{ASCII}+ $ /x || utf8::is_utf8($string_g);
            $ok16 = $sprintf_g eq $string_g;
a1125 5
        {
            no locale;
            $ok17 = "1.5:1.25" eq sprintf("%g:%g", $h, $i);
        }
        $ok18 = $j eq sprintf("%g:%g", $h, $i);
d1128 1
a1128 1
    report_result($Locale, ++$locales_test_number, $ok1);
d1134 1
a1134 1
    report_result($Locale, ++$locales_test_number, $ok2);
d1139 1
a1139 1
    report_result($Locale, ++$locales_test_number, $ok3);
a1140 1
    $problematical_tests{$locales_test_number} = 1;
d1142 1
a1142 1
    report_result($Locale, ++$locales_test_number, $ok4);
a1143 1
    $problematical_tests{$locales_test_number} = 1;
d1145 1
a1145 1
    report_result($Locale, ++$locales_test_number, $ok5);
a1146 1
    $problematical_tests{$locales_test_number} = 1;
d1150 2
a1151 2
    report_result($Locale, ++$locales_test_number, $ok6);
    $test_names{$locales_test_number} = 'Verify that can assign stringified under inner no-locale block';
d1154 1
a1154 1
    report_result($Locale, ++$locales_test_number, $ok7);
d1157 1
a1157 1
    report_result($Locale, ++$locales_test_number, $ok8);
a1158 1
    $problematical_tests{$locales_test_number} = 1;
d1162 1
a1162 1
    report_result($Locale, ++$locales_test_number, $ok9);
a1163 1
    $problematical_tests{$locales_test_number} = 1;
d1166 1
a1166 1
    report_result($Locale, ++$locales_test_number, $ok10);
a1167 1
    $problematical_tests{$locales_test_number} = 1;
d1169 1
a1169 1
    report_result($Locale, ++$locales_test_number, $ok11);
a1170 1
    $problematical_tests{$locales_test_number} = 1;
d1172 1
a1172 1
    report_result($Locale, ++$locales_test_number, $ok12);
a1173 1
    $problematical_tests{$locales_test_number} = 1;
d1175 1
a1175 1
    report_result($Locale, ++$locales_test_number, $ok13);
a1176 16
    $problematical_tests{$locales_test_number} = 1;

    report_result($Locale, ++$locales_test_number, $ok14);
    $test_names{$locales_test_number} = 'Verify that non-ASCII UTF-8 error messages are NOT in UTF-8';

    report_result($Locale, ++$locales_test_number, $ok15);
    $test_names{$locales_test_number} = 'Verify that a number with a UTF-8 radix has a UTF-8 stringification';

    report_result($Locale, ++$locales_test_number, $ok16);
    $test_names{$locales_test_number} = 'Verify that a sprintf of a number with a UTF-8 radix yields UTF-8';

    report_result($Locale, ++$locales_test_number, $ok17);
    $test_names{$locales_test_number} = 'Verify that a sprintf of a number outside locale scope uses a dot radix';

    report_result($Locale, ++$locales_test_number, $ok18);
    $test_names{$locales_test_number} = 'Verify that a sprintf of a number back within locale scope uses locale radix';
d1200 1
a1200 1
        report_result($Locale, ++$locales_test_number,
d1221 1
a1221 1
        report_result($Locale, ++$locales_test_number,
d1238 1
a1238 1
        foreach my $x (sort { ord $a <=> ord $b } keys %UPPER) {
d1242 3
a1244 9
                debug_more( "# UPPER=", disp_chars(($x)),
                            "; lc=", disp_chars(($y)), "; ",
                            "; fc=", disp_chars((fc $x)), "; ",
                            disp_chars(($x)), "=~/", disp_chars(($y)), "/i=",
                            $x =~ /$y/i ? 1 : 0,
                            "; ",
                            disp_chars(($y)), "=~/", disp_chars(($x)), "/i=",
                            $y =~ /$x/i ? 1 : 0,
                            "\n");
d1273 3
a1275 1
                push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
d1284 3
a1286 9
                debug_more( "# UPPER=", disp_chars(($x)),
                            "; lc=", disp_chars(($y)), "; ",
                            "; fc=", disp_chars((fc $x)), "; ",
                            disp_chars(($x)), "=~/", disp_chars(($y)), "/i=",
                            $x =~ /$y/i ? 1 : 0,
                            "; ",
                            disp_chars(($y)), "=~/", disp_chars(($x)), "/i=",
                            $y =~ /$x/i ? 1 : 0,
                            "\n");
d1288 2
d1298 1
a1298 1
	foreach my $x (sort { ord $a <=> ord $b } keys %lower) {
d1302 3
a1304 9
                debug_more( "# lower=", disp_chars(($x)),
                            "; uc=", disp_chars(($y)), "; ",
                            "; fc=", disp_chars((fc $x)), "; ",
                            disp_chars(($x)), "=~/", disp_chars(($y)), "/i=",
                            $x =~ /$y/i ? 1 : 0,
                            "; ",
                            disp_chars(($y)), "=~/", disp_chars(($x)), "/i=",
                            $y =~ /$x/i ? 1 : 0,
                            "\n");
d1309 3
a1311 1
                push @@f, $x unless $x =~ /$y/i && $y =~ /$x/i;
d1319 3
a1321 9
                debug_more( "# lower=", disp_chars(($x)),
                            "; uc=", disp_chars(($y)), "; ",
                            "; fc=", disp_chars((fc $x)), "; ",
                            disp_chars(($x)), "=~/", disp_chars(($y)), "/i=",
                            $x =~ /$y/i ? 1 : 0,
                            "; ",
                            disp_chars(($y)), "=~/", disp_chars(($x)), "/i=",
                            $y =~ /$x/i ? 1 : 0,
                            "\n");
d1327 4
a1330 2
	report_multi_result($Locale, $locales_test_number, \@@f);
        $problematical_tests{$locales_test_number} = 1;
a1337 1
        $problematical_tests{$locales_test_number} = 1;
d1360 1
a1360 1
	report_result($Locale, $locales_test_number, @@f == 0);
d1371 1
a1371 1
foreach $test_num ($first_locales_test_number..$final_locales_test_number) {
d1375 1
a1375 1
    elsif ($Problem{$test_num} || !defined $Okay{$test_num} || !@@{$Okay{$test_num}}) {
d1377 1
a1377 1
            && $test_num == $not_necessarily_a_problem_test_number)
d1383 7
a1389 9
        if ($Okay{$test_num} && grep { $_ == $test_num } keys %problematical_tests) {
            no warnings 'experimental::autoderef';
            # Round to nearest .1%
            my $percent_fail = (int(.5 + (1000 * scalar(keys $Problem{$test_num})
                                          / scalar(@@Locale))))
                               / 10;
            if (! $debug && $percent_fail < $acceptable_failure_percentage)
            {
                $test_names{$test_num} .= 'TODO';
a1394 9
        print "#\n";
        if ($debug) {
            print "# The code points that had this failure are given above.  Look for lines\n";
            print "# that match 'failed $test_num'\n";
        }
        else {
            print "# For more details, rerun, with environment variable PERL_DEBUG_FULL_TEST=1.\n";
            print "# Then look at that output for lines that match 'failed $test_num'\n";
        }
d1397 2
a1398 2
    print "ok $test_num";
    if (defined $test_names{$test_num}) {
d1400 2
a1401 2
        my $todo = $test_names{$test_num} =~ s/TODO\s*//;
        print " $test_names{$test_num}";
d1407 65
a1471 1
$test_num = $final_locales_test_number;
d1473 7
a1479 9
unless ( $^O =~ m!^(dragonfly|openbsd|bitrig|mirbsd)$! ) {
    # perl #115808
    use warnings;
    my $warned = 0;
    local $SIG{__WARN__} = sub {
        $warned = $_[0] =~ /uninitialized/;
    };
    my $z = "y" . setlocale(&POSIX::LC_ALL, "xyzzy");
    ok($warned, "variable set to setlocale(BAD LOCALE) is considered uninitialized");
d1482 2
d1489 1
a1489 1
setlocale(&POSIX::LC_ALL, "C");
d1503 1
a1503 1
        # We test an ASCII character, which should change case;
d1505 1
d1507 2
a1508 2
        #   the 255/256 boundary, so doesn't change case
        #   (the \x{149} is one of these, but changes into 2 characters, the
d1511 3
a1513 6
        #   does change.  The code below uses its position in its list as a
        #   marker to indicate that it, unlike the other code points above
        #   ASCII, has a successful case change
        #
        # All casing operations under locale (but not :not_characters) should
        # taint
d1520 1
a1520 1
            @@list = ("", "A", "\xC0", "\x{17F}", "\x{100}");
d1587 3
a1589 3
                    # Tainting shouldn't happen for use locale :not_character
                    # (a utf8 locale)
                    (! $is_utf8_locale)
a1597 85
    }
}

# Give final advice.

my $didwarn = 0;

foreach ($first_locales_test_number..$final_locales_test_number) {
    if ($Problem{$_}) {
	my @@f = sort keys %{ $Problem{$_} };
	my $f = join(" ", @@f);
	$f =~ s/(.{50,60}) /$1\n#\t/g;
	print
	    "#\n",
            "# The locale ", (@@f == 1 ? "definition" : "definitions"), "\n#\n",
	    "#\t", $f, "\n#\n",
	    "# on your system may have errors because the locale test $_\n",
	    "# \"$test_names{$_}\"\n",
            "# failed in ", (@@f == 1 ? "that locale" : "those locales"),
            ".\n";
	print <<EOW;
#
# If your users are not using these locales you are safe for the moment,
# but please report this failure first to perlbug\@@perl.com using the
# perlbug script (as described in the INSTALL file) so that the exact
# details of the failures can be sorted out first and then your operating
# system supplier can be alerted about these anomalies.
#
EOW
	$didwarn = 1;
    }
}

# Tell which locales were okay and which were not.

if ($didwarn) {
    my (@@s, @@F);

    foreach my $l (@@Locale) {
	my $p = 0;
        if ($setlocale_failed{$l}) {
            $p++;
        }
        else {
            foreach my $t
                        ($first_locales_test_number..$final_locales_test_number)
            {
                $p++ if $Problem{$t}{$l};
            }
	}
	push @@s, $l if $p == 0;
        push @@F, $l unless $p == 0;
    }

    if (@@s) {
        my $s = join(" ", @@s);
        $s =~ s/(.{50,60}) /$1\n#\t/g;

        print
            "# The following locales\n#\n",
            "#\t", $s, "\n#\n",
	    "# tested okay.\n#\n",
    } else {
        print "# None of your locales were fully okay.\n";
    }

    if (@@F) {
        my $F = join(" ", @@F);
        $F =~ s/(.{50,60}) /$1\n#\t/g;

        my $details = "";
        unless ($debug) {
            $details = "# For more details, rerun, with environment variable PERL_DEBUG_FULL_TEST=1.\n";
        }
        elsif ($debug == 1) {
            $details = "# For even more details, rerun, with environment variable PERL_DEBUG_FULL_TEST=2.\n";
        }

        print
          "# The following locales\n#\n",
          "#\t", $F, "\n#\n",
          "# had problems.\n#\n",
          $details;
    } else {
        print "# None of your locales were broken.\n";
@


