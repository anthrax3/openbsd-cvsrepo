head	1.11;
access;
symbols
	OPENBSD_6_1:1.11.0.2
	OPENBSD_6_1_BASE:1.11
	OPENBSD_6_0:1.10.0.10
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.4
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	PERL_5_20_2:1.1.1.9
	OPENBSD_5_7:1.10.0.2
	OPENBSD_5_7_BASE:1.10
	PERL_5_20_1:1.1.1.9
	OPENBSD_5_6:1.9.0.8
	OPENBSD_5_6_BASE:1.9
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.9.0.6
	OPENBSD_5_5_BASE:1.9
	OPENBSD_5_4:1.9.0.2
	OPENBSD_5_4_BASE:1.9
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.8.0.18
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.16
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.14
	OPENBSD_5_0:1.8.0.12
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.10
	OPENBSD_4_9_BASE:1.8
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.8.0.8
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.4
	OPENBSD_4_7_BASE:1.8
	PERL_5_10_1:1.1.1.7
	OPENBSD_4_6:1.8.0.6
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.7.0.20
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.18
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.16
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.14
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.12
	OPENBSD_4_0_BASE:1.7
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.7.0.10
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.8
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.6
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.4
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.7.0.2
	OPENBSD_3_5_BASE:1.7
	PERL_5_8_2:1.1.1.6
	OPENBSD_3_4:1.6.0.4
	OPENBSD_3_4_BASE:1.6
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	PERL_5_8_0:1.1.1.5
	OPENBSD_3_2:1.5.0.6
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.4
	OPENBSD_3_1_BASE:1.5
	OPENBSD_3_0:1.5.0.2
	OPENBSD_3_0_BASE:1.5
	PERL_5_6_1:1.1.1.4
	OPENBSD_2_9:1.4.0.6
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_8:1.4.0.4
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	PERL_5_6_0:1.1.1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.10;
commitid	cxJ08BvJA9Pt2PTM;

1.10
date	2014.11.17.20.57.06;	author afresh1;	state Exp;
branches;
next	1.9;
commitid	QP75iYx42Uo7mMxO;

1.9
date	2013.03.25.20.40.55;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2008.09.29.17.36.10;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.03.03.02.36;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.10.27.22.25.26;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.05.24.18.35.26;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.06.17.06.17;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	99.04.29.22.51.48;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.09;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.37;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.37;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.39.57;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2000.04.06.16.09.39;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2001.05.24.18.23.24;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2003.12.03.02.44.00;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.31;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.08.53;	author sthen;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2014.11.17.20.53.08;	author afresh1;	state Exp;
branches;
next	;
commitid	B31cAbBIXiCqnL97;


desc
@@


1.11
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package strict;

$strict::VERSION = "1.11";

my ( %bitmask, %explicit_bitmask );

BEGIN {
    # Verify that we're called correctly so that strictures will work.
    # Can't use Carp, since Carp uses us!
    # see also warnings.pm.
    die sprintf "Incorrect use of pragma '%s' at %s line %d.\n", __PACKAGE__, +(caller)[1,2]
        if __FILE__ !~ ( '(?x) \b     '.__PACKAGE__.'  \.pmc? \z' )
        && __FILE__ =~ ( '(?x) \b (?i:'.__PACKAGE__.') \.pmc? \z' );

    %bitmask = (
        refs => 0x00000002,
        subs => 0x00000200,
        vars => 0x00000400,
    );

    %explicit_bitmask = (
        refs => 0x00000020,
        subs => 0x00000040,
        vars => 0x00000080,
    );

    my $bits = 0;
    $bits |= $_ for values %bitmask;

    my $inline_all_bits = $bits;
    *all_bits = sub () { $inline_all_bits };

    $bits = 0;
    $bits |= $_ for values %explicit_bitmask;

    my $inline_all_explicit_bits = $bits;
    *all_explicit_bits = sub () { $inline_all_explicit_bits };
}

sub bits {
    my $bits = 0;
    my @@wrong;
    foreach my $s (@@_) {
        if (exists $bitmask{$s}) {
            $^H |= $explicit_bitmask{$s};

            $bits |= $bitmask{$s};
        }
        else {
            push @@wrong, $s;
        }
    }
    if (@@wrong) {
        require Carp;
        Carp::croak("Unknown 'strict' tag(s) '@@wrong'");
    }
    $bits;
}

sub import {
    shift;
    $^H |= @@_ ? &bits : all_bits | all_explicit_bits;
}

sub unimport {
    shift;

    if (@@_) {
        $^H &= ~&bits;
    }
    else {
        $^H &= ~all_bits;
        $^H |= all_explicit_bits;
    }
}

1;
__END__

=head1 NAME

strict - Perl pragma to restrict unsafe constructs

=head1 SYNOPSIS

    use strict;

    use strict "vars";
    use strict "refs";
    use strict "subs";

    use strict;
    no strict "vars";

=head1 DESCRIPTION

The C<strict> pragma disables certain Perl expressions that could behave
unexpectedly or are difficult to debug, turning them into errors. The
effect of this pragma is limited to the current file or scope block.

If no import list is supplied, all possible restrictions are assumed.
(This is the safest mode to operate in, but is sometimes too strict for
casual programming.)  Currently, there are three possible things to be
strict about:  "subs", "vars", and "refs".

=over 6

=item C<strict refs>

This generates a runtime error if you 
use symbolic references (see L<perlref>).

    use strict 'refs';
    $ref = \$foo;
    print $$ref;	# ok
    $ref = "foo";
    print $$ref;	# runtime error; normally ok
    $file = "STDOUT";
    print $file "Hi!";	# error; note: no comma after $file

There is one exception to this rule:

    $bar = \&{'foo'};
    &$bar;

is allowed so that C<goto &$AUTOLOAD> would not break under stricture.


=item C<strict vars>

This generates a compile-time error if you access a variable that was
neither explicitly declared (using any of C<my>, C<our>, C<state>, or C<use
vars>) nor fully qualified.  (Because this is to avoid variable suicide
problems and subtle dynamic scoping issues, a merely C<local> variable isn't
good enough.)  See L<perlfunc/my>, L<perlfunc/our>, L<perlfunc/state>,
L<perlfunc/local>, and L<vars>.

    use strict 'vars';
    $X::foo = 1;	 # ok, fully qualified
    my $foo = 10;	 # ok, my() var
    local $baz = 9;	 # blows up, $baz not declared before

    package Cinna;
    our $bar;			# Declares $bar in current package
    $bar = 'HgS';		# ok, global declared via pragma

The local() generated a compile-time error because you just touched a global
name without fully qualifying it.

Because of their special use by sort(), the variables $a and $b are
exempted from this check.

=item C<strict subs>

This disables the poetry optimization, generating a compile-time error if
you try to use a bareword identifier that's not a subroutine, unless it
is a simple identifier (no colons) and that it appears in curly braces or
on the left hand side of the C<< => >> symbol.

    use strict 'subs';
    $SIG{PIPE} = Plumber;   # blows up
    $SIG{PIPE} = "Plumber"; # fine: quoted string is always ok
    $SIG{PIPE} = \&Plumber; # preferred form

=back

See L<perlmodlib/Pragmatic Modules>.

=head1 HISTORY

C<strict 'subs'>, with Perl 5.6.1, erroneously permitted to use an unquoted
compound identifier (e.g. C<Foo::Bar>) as a hash key (before C<< => >> or
inside curlies), but without forcing it always to a literal string.

Starting with Perl 5.8.1 strict is strict about its restrictions:
if unknown restrictions are used, the strict pragma will abort with

    Unknown 'strict' tag(s) '...'

As of version 1.04 (Perl 5.10), strict verifies that it is used as
"strict" to avoid the dreaded Strict trap on case insensitive file
systems.

=cut
@


1.10
log
@Fix merge conflicts, remove extra files, match upstream perl-5.20.1

ok deraadt@@ sthen@@ espie@@ miod@@
@
text
@d3 1
a3 1
$strict::VERSION = "1.08";
d5 4
a8 2
# Verify that we're called correctly so that strictures will work.
unless ( __FILE__ =~ /(^|[\/\\])\Q${\__PACKAGE__}\E\.pmc?$/ ) {
d10 28
a37 2
    my (undef, $f, $l) = caller;
    die("Incorrect use of pragma '${\__PACKAGE__}' at $f line $l.\n");
a39 11
my %bitmask = (
refs => 0x00000002,
subs => 0x00000200,
vars => 0x00000400
);
my %explicit_bitmask = (
refs => 0x00000020,
subs => 0x00000040,
vars => 0x00000080
);

d44 8
a51 5
	if (exists $bitmask{$s}) {
	    $^H |= $explicit_bitmask{$s};
	}
	else { push @@wrong, $s };
        $bits |= $bitmask{$s} || 0;
a59 2
my @@default_bits = qw(refs subs vars);

d62 1
a62 1
    $^H |= bits(@@_ ? @@_ : @@default_bits);
d67 8
a74 1
    $^H &= ~ bits(@@_ ? @@_ : @@default_bits);
d96 4
@


1.9
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d3 1
a3 1
$strict::VERSION = "1.07";
d132 3
a134 3
    $SIG{PIPE} = Plumber;   	# blows up
    $SIG{PIPE} = "Plumber"; 	# just fine: quoted string is always ok
    $SIG{PIPE} = \&Plumber; 	# preferred form
@


1.8
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 1
a3 1
$strict::VERSION = "1.04";
d17 5
d27 4
a30 1
	push @@wrong, $s unless exists $bitmask{$s};
d40 1
a40 1
my $default_bits = bits(qw(refs subs vars));
d44 1
a44 1
    $^H |= @@_ ? bits(@@_) : $default_bits;
d49 1
a49 1
    $^H &= ~ (@@_ ? bits(@@_) : $default_bits);
d102 6
a107 6
This generates a compile-time error if you access a variable that wasn't
declared via C<our> or C<use vars>,
localized via C<my()>, or wasn't fully qualified.  Because this is to avoid
variable suicide problems and subtle dynamic scoping issues, a merely
local() variable isn't good enough.  See L<perlfunc/my> and
L<perlfunc/local>.
d112 1
a112 1
    local $foo = 9;	 # blows up
@


1.7
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 8
a10 1
$strict::VERSION = "1.03";
d142 4
@


1.6
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 37
d88 1
a88 1
declared via "our" or C<use vars>,
d113 2
a114 2
appears in curly braces or on the left hand side of the "=E<gt>" symbol.

d118 1
a118 1
    $SIG{PIPE} = "Plumber"; 	# just fine: bareword in curlies always ok
a120 2


d125 1
d127 3
a129 1
=cut
d131 2
a132 1
$strict::VERSION = "1.02";
d134 1
a134 5
my %bitmask = (
refs => 0x00000002,
subs => 0x00000200,
vars => 0x00000400
);
d136 1
a136 17
sub bits {
    my $bits = 0;
    foreach my $s (@@_){ $bits |= $bitmask{$s} || 0; };
    $bits;
}

sub import {
    shift;
    $^H |= bits(@@_ ? @@_ : qw(refs subs vars));
}

sub unimport {
    shift;
    $^H &= ~ bits(@@_ ? @@_ : qw(refs subs vars));
}

1;
@


1.5
log
@merge in perl 5.6.1 with our local changes
@
text
@d93 1
a93 1
$strict::VERSION = "1.01";
@


1.4
log
@perl-5.6.0 + local changes
@
text
@d40 8
@


1.3
log
@perl5.005_03 (stock)
@
text
@d37 2
d43 2
a44 2
declared via C<use vars>,
localized via C<my()> or wasn't fully qualified.  Because this is to avoid
d55 1
a55 1
    use vars qw/ $bar /;	# Declares $bar in current package
d60 3
@


1.2
log
@perl 5.004_04
@
text
@d41 1
d52 4
d75 1
a75 1
See L<perlmod/Pragmatic Modules>.
d80 8
d90 1
a90 6
    my $sememe;
    foreach $sememe (@@_) {
	$bits |= 0x00000002, next if $sememe eq 'refs';
	$bits |= 0x00000200, next if $sememe eq 'subs';
	$bits |= 0x00000400, next if $sememe eq 'vars';
    }
@


1.1
log
@Initial revision
@
text
@d58 1
a58 1
appears in curly braces or on the left hand side of the "=>" symbol.
d77 1
d79 3
a81 3
	$bits |= 0x00000002 if $sememe eq 'refs';
	$bits |= 0x00000200 if $sememe eq 'subs';
	$bits |= 0x00000400 if $sememe eq 'vars';
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@a40 1
declared via C<use vars>,
a50 4
    package Cinna;
    use vars qw/ $bar /;	# Declares $bar in current package
    $bar = 'HgS';		# ok, global declared via pragma

d58 1
a58 1
appears in curly braces or on the left hand side of the "=E<gt>" symbol.
d70 1
a70 1
See L<perlmodlib/Pragmatic Modules>.
a74 8
$strict::VERSION = "1.01";

my %bitmask = (
refs => 0x00000002,
subs => 0x00000200,
vars => 0x00000400
);

d77 5
a81 1
    foreach my $s (@@_){ $bits |= $bitmask{$s} || 0; };
@


1.1.1.3
log
@virgin perl 5.6.0
@
text
@a36 2
    $file = "STDOUT";
    print $file "Hi!";	# error; note: no comma after $file
d41 2
a42 2
declared via "our" or C<use vars>,
localized via C<my()>, or wasn't fully qualified.  Because this is to avoid
d53 1
a53 1
    our $bar;			# Declares $bar in current package
a57 3

Because of their special use by sort(), the variables $a and $b are
exempted from this check.
@


1.1.1.4
log
@stock perl 5.6.1
@
text
@a39 8
There is one exception to this rule:

    $bar = \&{'foo'};
    &$bar;

is allowed so that C<goto &$AUTOLOAD> would not break under stricture.


@


1.1.1.5
log
@stock perl 5.8.0 from CPAN
@
text
@d93 1
a93 1
$strict::VERSION = "1.02";
@


1.1.1.6
log
@perl 5.8.2 from CPAN
@
text
@a2 37
$strict::VERSION = "1.03";

my %bitmask = (
refs => 0x00000002,
subs => 0x00000200,
vars => 0x00000400
);

sub bits {
    my $bits = 0;
    my @@wrong;
    foreach my $s (@@_) {
	push @@wrong, $s unless exists $bitmask{$s};
        $bits |= $bitmask{$s} || 0;
    }
    if (@@wrong) {
        require Carp;
        Carp::croak("Unknown 'strict' tag(s) '@@wrong'");
    }
    $bits;
}

my $default_bits = bits(qw(refs subs vars));

sub import {
    shift;
    $^H |= @@_ ? bits(@@_) : $default_bits;
}

sub unimport {
    shift;
    $^H &= ~ (@@_ ? bits(@@_) : $default_bits);
}

1;
__END__

d51 1
a51 1
declared via C<our> or C<use vars>,
d76 2
a77 2
is a simple identifier (no colons) and that it appears in curly braces or
on the left hand side of the C<< => >> symbol.
d81 1
a81 1
    $SIG{PIPE} = "Plumber"; 	# just fine: quoted string is always ok
d84 2
a89 1
=head1 HISTORY
d91 1
a91 3
C<strict 'subs'>, with Perl 5.6.1, erroneously permitted to use an unquoted
compound identifier (e.g. C<Foo::Bar>) as a hash key (before C<< => >> or
inside curlies), but without forcing it always to a literal string.
d93 1
a93 2
Starting with Perl 5.8.1 strict is strict about its restrictions:
if unknown restrictions are used, the strict pragma will abort with
d95 5
a99 1
    Unknown 'strict' tag(s) '...'
d101 17
a117 1
=cut
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 8
$strict::VERSION = "1.04";

# Verify that we're called correctly so that strictures will work.
unless ( __FILE__ =~ /(^|[\/\\])\Q${\__PACKAGE__}\E\.pmc?$/ ) {
    # Can't use Carp, since Carp uses us!
    my (undef, $f, $l) = caller;
    die("Incorrect use of pragma '${\__PACKAGE__}' at $f line $l.\n");
}
a134 4

As of version 1.04 (Perl 5.10), strict verifies that it is used as
"strict" to avoid the dreaded Strict trap on case insensitive file
systems.
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
$strict::VERSION = "1.07";
a16 5
my %explicit_bitmask = (
refs => 0x00000020,
subs => 0x00000040,
vars => 0x00000080
);
d22 1
a22 4
	if (exists $bitmask{$s}) {
	    $^H |= $explicit_bitmask{$s};
	}
	else { push @@wrong, $s };
d32 1
a32 1
my @@default_bits = qw(refs subs vars);
d36 1
a36 1
    $^H |= bits(@@_ ? @@_ : @@default_bits);
d41 1
a41 1
    $^H &= ~ bits(@@_ ? @@_ : @@default_bits);
d94 6
a99 6
This generates a compile-time error if you access a variable that was
neither explicitly declared (using any of C<my>, C<our>, C<state>, or C<use
vars>) nor fully qualified.  (Because this is to avoid variable suicide
problems and subtle dynamic scoping issues, a merely C<local> variable isn't
good enough.)  See L<perlfunc/my>, L<perlfunc/our>, L<perlfunc/state>,
L<perlfunc/local>, and L<vars>.
d104 1
a104 1
    local $baz = 9;	 # blows up, $baz not declared before
@


1.1.1.9
log
@Import perl-5.20.1
@
text
@d3 1
a3 1
$strict::VERSION = "1.08";
d132 3
a134 3
    $SIG{PIPE} = Plumber;   # blows up
    $SIG{PIPE} = "Plumber"; # fine: quoted string is always ok
    $SIG{PIPE} = \&Plumber; # preferred form
@


