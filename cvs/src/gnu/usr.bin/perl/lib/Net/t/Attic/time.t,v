head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.1.0.32
	OPENBSD_4_8_BASE:1.1.1.1
	OPENBSD_4_7:1.1.1.1.0.28
	OPENBSD_4_7_BASE:1.1.1.1
	PERL_5_10_1:1.1.1.1
	OPENBSD_4_6:1.1.1.1.0.30
	OPENBSD_4_6_BASE:1.1.1.1
	OPENBSD_4_5:1.1.1.1.0.26
	OPENBSD_4_5_BASE:1.1.1.1
	PERL_5_10_0:1.1.1.1
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.47;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@#!./perl -w

BEGIN {
    if ($ENV{PERL_CORE}) {
	chdir 't' if -d 't';
	@@INC = '../lib';
    }
    if (!eval "require Socket") {
	print "1..0 # no Socket\n"; exit 0;
    }
    if (ord('A') == 193 && !eval "require Convert::EBCDIC") {
	print "1..0 # EBCDIC but no Convert::EBCDIC\n"; exit 0;
    }
    $INC{'IO/Socket.pm'} = 1;
    $INC{'IO/Select.pm'} = 1;
    $INC{'IO/Socket/INET.pm'} = 1;
}

(my $libnet_t = __FILE__) =~ s/time.t/libnet_t.pl/;
require $libnet_t;

print "1..12\n";
# cannot use(), otherwise it will use IO::Socket and IO::Select
eval{ require Net::Time; };
ok( !$@@, 'should be able to require() Net::Time safely' );
ok( exists $INC{'Net/Time.pm'}, 'should be able to use Net::Time' );

# force the socket to fail
make_fail('IO::Socket::INET', 'new');
my $badsock = Net::Time::_socket('foo', 1, 'bar', 'baz');
is( $badsock, undef, '_socket() should fail if Socket creation fails' );

# if socket is created with protocol UDP (default), it will send a newline
my $sock = Net::Time::_socket('foo', 2, 'bar'); 
ok( $sock->isa('IO::Socket::INET'), 'should be an IO::Socket::INET object' );
is( $sock->{sent}, "\n", 'should send \n with UDP protocol set' );
is( $sock->{timeout}, 120, 'timeout should default to 120' );

# now try it with a custom timeout and a different protocol
$sock = Net::Time::_socket('foo', 3, 'bar', 'tcp', 11);
ok( $sock->isa('IO::Socket::INET'), 'should be an IO::Socket::INET object' );
is( $sock->{sent}, undef, '_socket() should send nothing unless UDP protocol' );
is( $sock->{PeerAddr}, 'bar', '_socket() should set PeerAddr in socket' );
is( $sock->{timeout}, 11, '_socket() should respect custom timeout value' );

# inet_daytime
# check for correct args (daytime, 13)
IO::Socket::INET::set_message('z');
is( Net::Time::inet_daytime('bob'), 'z', 'inet_daytime() should receive data' );

# magic numbers defined in Net::Time
my $offset = $^O eq 'MacOS' ?
	(4 * 31536000) : (70 * 31536000 + 17 * 86400);

# check for correct args (time, 13)
# pretend it is only six seconds since the offset, create a fake message
# inet_time
IO::Socket::INET::set_message(pack("N", $offset + 6));
is( Net::Time::inet_time('foo'), 6, 
	'inet_time() should calculate time since offset for time()' );


my %fail;

sub make_fail {
	my ($pack, $func, $num) = @@_;
	$num = 1 unless defined $num;

	$fail{$pack}{$func} = $num;
}

package IO::Socket::INET;

$fail{'IO::Socket::INET'} = {
	new		=> 0,
	'send'	=> 0,
};

sub new {
	my $class = shift;
	return if $fail{$class}{new} and $fail{$class}{new}--;
	bless( { @@_ }, $class );
}

sub send {
	my $self = shift;
	my $class = ref($self);
	return if $fail{$class}{'send'} and $fail{$class}{'send'}--;
	$self->{sent} .= shift;
}

my $msg;
sub set_message {
	if (ref($_[0])) {
		$_[0]->{msg} = $_[1];
	} else {
		$msg = shift;
	}
}

sub do_recv  {
	my ($len, $msg) = @@_[1,2];
	$_[0] .= substr($msg, 0, $len);
}

sub recv {
	my ($self, $buf, $length, $flags) = @@_;
	my $message = exists $self->{msg} ?
		$self->{msg} : $msg;

	if (defined($message)) {
		do_recv($_[1], $length, $message);
	}
	1;
}

package IO::Select;

sub new {
	my $class = shift;
	return if defined $fail{$class}{new} and $fail{$class}{new}--;
	bless({sock => shift}, $class);
}

sub can_read {
	my ($self, $timeout) = @@_;
	my $class = ref($self);
	return if defined $fail{$class}{can_read} and $fail{class}{can_read}--;
	$self->{sock}{timeout} = $timeout;
	1;
}

1;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@
