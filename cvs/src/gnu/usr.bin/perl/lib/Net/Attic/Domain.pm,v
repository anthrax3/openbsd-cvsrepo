head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.3.0.8
	OPENBSD_4_8_BASE:1.1.1.3
	OPENBSD_4_7:1.1.1.3.0.4
	OPENBSD_4_7_BASE:1.1.1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.1.1.3.0.6
	OPENBSD_4_6_BASE:1.1.1.3
	OPENBSD_4_5:1.1.1.3.0.2
	OPENBSD_4_5_BASE:1.1.1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.1.1.2.0.20
	OPENBSD_4_4_BASE:1.1.1.2
	OPENBSD_4_3:1.1.1.2.0.18
	OPENBSD_4_3_BASE:1.1.1.2
	OPENBSD_4_2:1.1.1.2.0.16
	OPENBSD_4_2_BASE:1.1.1.2
	OPENBSD_4_1:1.1.1.2.0.14
	OPENBSD_4_1_BASE:1.1.1.2
	OPENBSD_4_0:1.1.1.2.0.12
	OPENBSD_4_0_BASE:1.1.1.2
	PERL_5_8_8:1.1.1.2
	OPENBSD_3_9:1.1.1.2.0.10
	OPENBSD_3_9_BASE:1.1.1.2
	OPENBSD_3_8:1.1.1.2.0.8
	OPENBSD_3_8_BASE:1.1.1.2
	OPENBSD_3_7:1.1.1.2.0.6
	OPENBSD_3_7_BASE:1.1.1.2
	PERL_5_8_6:1.1.1.2
	OPENBSD_3_6:1.1.1.2.0.4
	OPENBSD_3_6_BASE:1.1.1.2
	PERL_5_8_5:1.1.1.2
	PERL_5_8_3:1.1.1.2
	OPENBSD_3_5:1.1.1.2.0.2
	OPENBSD_3_5_BASE:1.1.1.2
	PERL_5_8_2:1.1.1.2
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.46;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.00;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2003.12.03.02.44.04;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2008.09.29.17.18.39;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@# Net::Domain.pm
#
# Copyright (c) 1995-1998 Graham Barr <gbarr@@pobox.com>. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.

package Net::Domain;

require Exporter;

use Carp;
use strict;
use vars qw($VERSION @@ISA @@EXPORT_OK);
use Net::Config;

@@ISA = qw(Exporter);
@@EXPORT_OK = qw(hostname hostdomain hostfqdn domainname);

$VERSION = "2.17"; # $Id: //depot/libnet/Net/Domain.pm#19 $

my($host,$domain,$fqdn) = (undef,undef,undef);

# Try every conceivable way to get hostname.

sub _hostname {

    # we already know it
    return $host
    	if(defined $host);

    if ($^O eq 'MSWin32') {
        require Socket;
        my ($name,$alias,$type,$len,@@addr) =  gethostbyname($ENV{'COMPUTERNAME'}||'localhost');
        while (@@addr)
         {
          my $a = shift(@@addr);
          $host = gethostbyaddr($a,Socket::AF_INET());
          last if defined $host;
         }
        if (defined($host) && index($host,'.') > 0) {
           $fqdn = $host;
           ($host,$domain) = $fqdn =~ /^([^\.]+)\.(.*)$/;
         }
        return $host;
    }
    elsif ($^O eq 'MacOS') {
	chomp ($host = `hostname`);
    }
    elsif ($^O eq 'VMS') {   ## multiple varieties of net s/w makes this hard
        $host = $ENV{'UCX$INET_HOST'} if defined($ENV{'UCX$INET_HOST'});
        $host = $ENV{'MULTINET_HOST_NAME'} if defined($ENV{'MULTINET_HOST_NAME'});
        if (index($host,'.') > 0) {
           $fqdn = $host;
           ($host,$domain) = $fqdn =~ /^([^\.]+)\.(.*)$/;
        }
        return $host;
    }
    else {
	local $SIG{'__DIE__'};

	# syscall is preferred since it avoids tainting problems
	eval {
    	    my $tmp = "\0" x 256; ## preload scalar
    	    eval {
    		package main;
     		require "syscall.ph";
		defined(&main::SYS_gethostname);
    	    }
    	    || eval {
    		package main;
     		require "sys/syscall.ph";
		defined(&main::SYS_gethostname);
    	    }
            and $host = (syscall(&main::SYS_gethostname, $tmp, 256) == 0)
		    ? $tmp
		    : undef;
	}

	# POSIX
	|| eval {
	    require POSIX;
	    $host = (POSIX::uname())[1];
	}

	# trusty old hostname command
	|| eval {
    	    chop($host = `(hostname) 2>/dev/null`); # BSD'ish
	}

	# sysV/POSIX uname command (may truncate)
	|| eval {
    	    chop($host = `uname -n 2>/dev/null`); ## SYSV'ish && POSIX'ish
	}

	# Apollo pre-SR10
	|| eval {
    	    $host = (split(/[:\. ]/,`/com/host`,6))[0];
	}

	|| eval {
    	    $host = "";
	};
    }

    # remove garbage
    $host =~ s/[\0\r\n]+//go;
    $host =~ s/(\A\.+|\.+\Z)//go;
    $host =~ s/\.\.+/\./go;

    $host;
}

sub _hostdomain {

    # we already know it
    return $domain
    	if(defined $domain);

    local $SIG{'__DIE__'};

    return $domain = $NetConfig{'inet_domain'}
	if defined $NetConfig{'inet_domain'};

    # try looking in /etc/resolv.conf
    # putting this here and assuming that it is correct, eliminates
    # calls to gethostbyname, and therefore DNS lookups. This helps
    # those on dialup systems.

    local *RES;
    local($_);

    if(open(RES,"/etc/resolv.conf")) {
    	while(<RES>) {
    	    $domain = $1
    	    	if(/\A\s*(?:domain|search)\s+(\S+)/);
    	}
    	close(RES);

    	return $domain
    	    if(defined $domain);
    }

    # just try hostname and system calls

    my $host = _hostname();
    my(@@hosts);

    @@hosts = ($host,"localhost");

    unless (defined($host) && $host =~ /\./) {
	my $dom = undef;
        eval {
    	    my $tmp = "\0" x 256; ## preload scalar
    	    eval {
    	        package main;
     	        require "syscall.ph";
    	    }
    	    || eval {
    	        package main;
     	        require "sys/syscall.ph";
    	    }
            and $dom = (syscall(&main::SYS_getdomainname, $tmp, 256) == 0)
		    ? $tmp
		    : undef;
        };

	chop($dom = `domainname 2>/dev/null`)
		unless(defined $dom || $^O =~ /^(?:cygwin|MSWin32)/);

	if(defined $dom) {
	    my @@h = ();
	    while(length($dom)) {
		push(@@h, "$host.$dom");
		$dom =~ s/^[^.]+.//;
	    }
	    unshift(@@hosts,@@h);
    	}
    }

    # Attempt to locate FQDN

    foreach (grep {defined $_} @@hosts) {
    	my @@info = gethostbyname($_);

    	next unless @@info;

    	# look at real name & aliases
    	my $site;
    	foreach $site ($info[0], split(/ /,$info[1])) {
    	    if(rindex($site,".") > 0) {

    	    	# Extract domain from FQDN

     	    	($domain = $site) =~ s/\A[^\.]+\.//;
     	        return $domain;
    	    }
    	}
    }

    # Look for environment variable

    $domain ||= $ENV{LOCALDOMAIN} || $ENV{DOMAIN};

    if(defined $domain) {
    	$domain =~ s/[\r\n\0]+//g;
    	$domain =~ s/(\A\.+|\.+\Z)//g;
    	$domain =~ s/\.\.+/\./g;
    }

    $domain;
}

sub domainname {

    return $fqdn
    	if(defined $fqdn);

    _hostname();
    _hostdomain();

    # Assumption: If the host name does not contain a period
    # and the domain name does, then assume that they are correct
    # this helps to eliminate calls to gethostbyname, and therefore
    # eleminate DNS lookups

    return $fqdn = $host . "." . $domain
	if(defined $host and defined $domain
		and $host !~ /\./ and $domain =~ /\./);

    # For hosts that have no name, just an IP address
    return $fqdn = $host if defined $host and $host =~ /^\d+(\.\d+){3}$/;

    my @@host   = defined $host   ? split(/\./, $host)   : ('localhost');
    my @@domain = defined $domain ? split(/\./, $domain) : ();
    my @@fqdn   = ();

    # Determine from @@host & @@domain the FQDN

    my @@d = @@domain;

LOOP:
    while(1) {
    	my @@h = @@host;
    	while(@@h) {
    	    my $tmp = join(".",@@h,@@d);
    	    if((gethostbyname($tmp))[0]) {
     	        @@fqdn = (@@h,@@d);
     	        $fqdn = $tmp;
     	      last LOOP;
    	    }
    	    pop @@h;
    	}
    	last unless shift @@d;
    }

    if(@@fqdn) {
    	$host = shift @@fqdn;
    	until((gethostbyname($host))[0]) {
    	    $host .= "." . shift @@fqdn;
    	}
    	$domain = join(".", @@fqdn);
    }
    else {
    	undef $host;
    	undef $domain;
    	undef $fqdn;
    }

    $fqdn;
}

sub hostfqdn { domainname() }

sub hostname {
    domainname()
    	unless(defined $host);
    return $host;
}

sub hostdomain {
    domainname()
    	unless(defined $domain);
    return $domain;
}

1; # Keep require happy

__END__

=head1 NAME

Net::Domain - Attempt to evaluate the current host's internet name and domain

=head1 SYNOPSIS

    use Net::Domain qw(hostname hostfqdn hostdomain);

=head1 DESCRIPTION

Using various methods B<attempt> to find the Fully Qualified Domain Name (FQDN)
of the current host. From this determine the host-name and the host-domain.

Each of the functions will return I<undef> if the FQDN cannot be determined.

=over 4

=item hostfqdn ()

Identify and return the FQDN of the current host.

=item hostname ()

Returns the smallest part of the FQDN which can be used to identify the host.

=item hostdomain ()

Returns the remainder of the FQDN after the I<hostname> has been removed.

=back

=head1 AUTHOR

Graham Barr <gbarr@@pobox.com>.
Adapted from Sys::Hostname by David Sundstrom <sunds@@asictest.sc.ti.com>

=head1 COPYRIGHT

Copyright (c) 1995-1998 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.

=for html <hr>

I<$Id: //depot/libnet/Net/Domain.pm#19 $>

=cut
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@perl 5.8.2 from CPAN
@
text
@d19 1
a19 1
$VERSION = "2.19"; # $Id: //depot/libnet/Net/Domain.pm#21 $
a166 5
	if ( $^O eq 'VMS' ) {
	    $dom ||= $ENV{'TCPIP$INET_DOMAIN'}
		 || $ENV{'UCX$INET_DOMAIN'};
	}

a171 1
	    $dom =~ s/^\.+//;
d174 1
a174 1
		$dom =~ s/^[^.]+.+// or last;
d334 1
a334 1
I<$Id: //depot/libnet/Net/Domain.pm#21 $>
@


1.1.1.3
log
@import perl 5.10.0 from CPAN
@
text
@d16 1
a16 1
@@ISA       = qw(Exporter);
d19 1
a19 1
$VERSION = "2.20";
d21 1
a21 1
my ($host, $domain, $fqdn) = (undef, undef, undef);
a24 1

d27 21
a47 15
  # we already know it
  return $host
    if (defined $host);

  if ($^O eq 'MSWin32') {
    require Socket;
    my ($name, $alias, $type, $len, @@addr) = gethostbyname($ENV{'COMPUTERNAME'} || 'localhost');
    while (@@addr) {
      my $a = shift(@@addr);
      $host = gethostbyaddr($a, Socket::AF_INET());
      last if defined $host;
    }
    if (defined($host) && index($host, '.') > 0) {
      $fqdn = $host;
      ($host, $domain) = $fqdn =~ /^([^\.]+)\.(.*)$/;
d49 54
a102 11
    return $host;
  }
  elsif ($^O eq 'MacOS') {
    chomp($host = `hostname`);
  }
  elsif ($^O eq 'VMS') {    ## multiple varieties of net s/w makes this hard
    $host = $ENV{'UCX$INET_HOST'}      if defined($ENV{'UCX$INET_HOST'});
    $host = $ENV{'MULTINET_HOST_NAME'} if defined($ENV{'MULTINET_HOST_NAME'});
    if (index($host, '.') > 0) {
      $fqdn = $host;
      ($host, $domain) = $fqdn =~ /^([^\.]+)\.(.*)$/;
a103 4
    return $host;
  }
  else {
    local $SIG{'__DIE__'};
d105 4
a108 45
    # syscall is preferred since it avoids tainting problems
    eval {
      my $tmp = "\0" x 256;    ## preload scalar
      eval {
        package main;
        require "syscall.ph";
        defined(&main::SYS_gethostname);
        }
        || eval {
        package main;
        require "sys/syscall.ph";
        defined(&main::SYS_gethostname);
        }
        and $host =
        (syscall(&main::SYS_gethostname, $tmp, 256) == 0)
        ? $tmp
        : undef;
      }

      # POSIX
      || eval {
      require POSIX;
      $host = (POSIX::uname())[1];
      }

      # trusty old hostname command
      || eval {
      chop($host = `(hostname) 2>/dev/null`);    # BSD'ish
      }

      # sysV/POSIX uname command (may truncate)
      || eval {
      chop($host = `uname -n 2>/dev/null`);      ## SYSV'ish && POSIX'ish
      }

      # Apollo pre-SR10
      || eval { $host = (split(/[:\. ]/, `/com/host`, 6))[0]; }

      || eval { $host = ""; };
  }

  # remove garbage
  $host =~ s/[\0\r\n]+//go;
  $host =~ s/(\A\.+|\.+\Z)//go;
  $host =~ s/\.\.+/\./go;
d110 1
a110 1
  $host;
a112 1

d115 3
a117 3
  # we already know it
  return $domain
    if (defined $domain);
d119 1
a119 4
  local $SIG{'__DIE__'};

  return $domain = $NetConfig{'inet_domain'}
    if defined $NetConfig{'inet_domain'};
d121 2
a122 4
  # try looking in /etc/resolv.conf
  # putting this here and assuming that it is correct, eliminates
  # calls to gethostbyname, and therefore DNS lookups. This helps
  # those on dialup systems.
d124 14
a137 2
  local *RES;
  local ($_);
d139 2
a140 4
  if (open(RES, "/etc/resolv.conf")) {
    while (<RES>) {
      $domain = $1
        if (/\A\s*(?:domain|search)\s+(\S+)/);
a141 1
    close(RES);
d143 1
a143 5
    return $domain
      if (defined $domain);
  }

  # just try hostname and system calls
d145 2
a146 2
  my $host = _hostname();
  my (@@hosts);
d148 1
a148 19
  @@hosts = ($host, "localhost");

  unless (defined($host) && $host =~ /\./) {
    my $dom = undef;
    eval {
      my $tmp = "\0" x 256;    ## preload scalar
      eval {
        package main;
        require "syscall.ph";
        }
        || eval {
        package main;
        require "sys/syscall.ph";
        }
        and $dom =
        (syscall(&main::SYS_getdomainname, $tmp, 256) == 0)
        ? $tmp
        : undef;
    };
d150 34
a183 3
    if ($^O eq 'VMS') {
      $dom ||= $ENV{'TCPIP$INET_DOMAIN'}
        || $ENV{'UCX$INET_DOMAIN'};
d186 1
a186 2
    chop($dom = `domainname 2>/dev/null`)
      unless (defined $dom || $^O =~ /^(?:cygwin|MSWin32)/);
d188 2
a189 15
    if (defined $dom) {
      my @@h = ();
      $dom =~ s/^\.+//;
      while (length($dom)) {
        push(@@h, "$host.$dom");
        $dom =~ s/^[^.]+.+// or last;
      }
      unshift(@@hosts, @@h);
    }
  }

  # Attempt to locate FQDN

  foreach (grep { defined $_ } @@hosts) {
    my @@info = gethostbyname($_);
d191 1
a191 1
    next unless @@info;
d193 4
a196 4
    # look at real name & aliases
    my $site;
    foreach $site ($info[0], split(/ /, $info[1])) {
      if (rindex($site, ".") > 0) {
d198 1
a198 1
        # Extract domain from FQDN
d200 4
a203 3
        ($domain = $site) =~ s/\A[^\.]+\.//;
        return $domain;
      }
a204 1
  }
d206 1
a206 1
  # Look for environment variable
d208 1
a208 1
  $domain ||= $ENV{LOCALDOMAIN} || $ENV{DOMAIN};
d210 5
a214 5
  if (defined $domain) {
    $domain =~ s/[\r\n\0]+//g;
    $domain =~ s/(\A\.+|\.+\Z)//g;
    $domain =~ s/\.\.+/\./g;
  }
d216 1
a216 1
  $domain;
a218 1

d221 2
a222 2
  return $fqdn
    if (defined $fqdn);
d224 2
a225 2
  _hostname();
  _hostdomain();
d227 4
a230 4
  # Assumption: If the host name does not contain a period
  # and the domain name does, then assume that they are correct
  # this helps to eliminate calls to gethostbyname, and therefore
  # eleminate DNS lookups
d232 3
a234 5
  return $fqdn = $host . "." . $domain
    if (defined $host
    and defined $domain
    and $host !~ /\./
    and $domain =~ /\./);
d236 2
a237 2
  # For hosts that have no name, just an IP address
  return $fqdn = $host if defined $host and $host =~ /^\d+(\.\d+){3}$/;
d239 3
a241 3
  my @@host   = defined $host   ? split(/\./, $host)   : ('localhost');
  my @@domain = defined $domain ? split(/\./, $domain) : ();
  my @@fqdn   = ();
d243 1
a243 1
  # Determine from @@host & @@domain the FQDN
d245 1
a245 1
  my @@d = @@domain;
d248 26
a273 26
  while (1) {
    my @@h = @@host;
    while (@@h) {
      my $tmp = join(".", @@h, @@d);
      if ((gethostbyname($tmp))[0]) {
        @@fqdn = (@@h, @@d);
        $fqdn = $tmp;
        last LOOP;
      }
      pop @@h;
    }
    last unless shift @@d;
  }

  if (@@fqdn) {
    $host = shift @@fqdn;
    until ((gethostbyname($host))[0]) {
      $host .= "." . shift @@fqdn;
    }
    $domain = join(".", @@fqdn);
  }
  else {
    undef $host;
    undef $domain;
    undef $fqdn;
  }
d275 1
a275 1
  $fqdn;
a277 1

a279 1

d281 3
a283 3
  domainname()
    unless (defined $host);
  return $host;
a285 1

d287 3
a289 3
  domainname()
    unless (defined $domain);
  return $domain;
d292 1
a292 1
1;    # Keep require happy
d302 1
a302 1
    use Net::Domain qw(hostname hostfqdn hostdomain domainname);
a316 4
=item domainname ()

An alias for hostfqdn ().

d337 4
@


