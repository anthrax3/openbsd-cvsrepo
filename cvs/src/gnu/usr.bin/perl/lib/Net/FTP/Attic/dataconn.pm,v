head	1.2;
access;
symbols
	OPENBSD_4_8:1.1.1.2.0.8
	OPENBSD_4_8_BASE:1.1.1.2
	OPENBSD_4_7:1.1.1.2.0.4
	OPENBSD_4_7_BASE:1.1.1.2
	PERL_5_10_1:1.1.1.2
	OPENBSD_4_6:1.1.1.2.0.6
	OPENBSD_4_6_BASE:1.1.1.2
	OPENBSD_4_5:1.1.1.2.0.2
	OPENBSD_4_5_BASE:1.1.1.2
	PERL_5_10_0:1.1.1.2
	OPENBSD_4_4:1.1.1.1.0.24
	OPENBSD_4_4_BASE:1.1.1.1
	OPENBSD_4_3:1.1.1.1.0.22
	OPENBSD_4_3_BASE:1.1.1.1
	OPENBSD_4_2:1.1.1.1.0.20
	OPENBSD_4_2_BASE:1.1.1.1
	OPENBSD_4_1:1.1.1.1.0.18
	OPENBSD_4_1_BASE:1.1.1.1
	OPENBSD_4_0:1.1.1.1.0.16
	OPENBSD_4_0_BASE:1.1.1.1
	PERL_5_8_8:1.1.1.1
	OPENBSD_3_9:1.1.1.1.0.14
	OPENBSD_3_9_BASE:1.1.1.1
	OPENBSD_3_8:1.1.1.1.0.12
	OPENBSD_3_8_BASE:1.1.1.1
	OPENBSD_3_7:1.1.1.1.0.10
	OPENBSD_3_7_BASE:1.1.1.1
	PERL_5_8_6:1.1.1.1
	OPENBSD_3_6:1.1.1.1.0.8
	OPENBSD_3_6_BASE:1.1.1.1
	PERL_5_8_5:1.1.1.1
	PERL_5_8_3:1.1.1.1
	OPENBSD_3_5:1.1.1.1.0.6
	OPENBSD_3_5_BASE:1.1.1.1
	PERL_5_8_2:1.1.1.1
	OPENBSD_3_4:1.1.1.1.0.4
	OPENBSD_3_4_BASE:1.1.1.1
	OPENBSD_3_3:1.1.1.1.0.2
	OPENBSD_3_3_BASE:1.1.1.1
	PERL_5_8_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2010.09.24.14.59.46;	author millert;	state dead;
branches;
next	1.1;

1.1
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2008.09.29.17.18.40;	author millert;	state Exp;
branches;
next	;


desc
@@


1.2
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@##
## Generic data connection package
##

package Net::FTP::dataconn;

use Carp;
use vars qw(@@ISA $timeout $VERSION);
use Net::Cmd;
use Errno;

$VERSION = '0.11';
@@ISA = qw(IO::Socket::INET);

sub reading
{
 my $data = shift;
 ${*$data}{'net_ftp_bytesread'} = 0;
}

sub abort
{
 my $data = shift;
 my $ftp  = ${*$data}{'net_ftp_cmd'};

 # no need to abort if we have finished the xfer
 return $data->close
    if ${*$data}{'net_ftp_eof'};

 # for some reason if we continously open RETR connections and not
 # read a single byte, then abort them after a while the server will
 # close our connection, this prevents the unexpected EOF on the
 # command channel -- GMB
 if(exists ${*$data}{'net_ftp_bytesread'}
	&& (${*$data}{'net_ftp_bytesread'} == 0)) {
   my $buf="";
   my $timeout = $data->timeout;
   $data->can_read($timeout) && sysread($data,$buf,1);
 }

 ${*$data}{'net_ftp_eof'} = 1; # fake

 $ftp->abort; # this will close me
}

sub _close
{
 my $data = shift;
 my $ftp  = ${*$data}{'net_ftp_cmd'};

 $data->SUPER::close();

 delete ${*$ftp}{'net_ftp_dataconn'}
    if exists ${*$ftp}{'net_ftp_dataconn'} &&
        $data == ${*$ftp}{'net_ftp_dataconn'};
}

sub close
{
 my $data = shift;
 my $ftp  = ${*$data}{'net_ftp_cmd'};

 if(exists ${*$data}{'net_ftp_bytesread'} && !${*$data}{'net_ftp_eof'}) {
   my $junk;
   $data->read($junk,1,0);
   return $data->abort unless ${*$data}{'net_ftp_eof'};
 }

 $data->_close;

 $ftp->response() == CMD_OK &&
    $ftp->message =~ /unique file name:\s*(\S*)\s*\)/ &&
    (${*$ftp}{'net_ftp_unique'} = $1);

 $ftp->status == CMD_OK;
}

sub _select {
 my ($data, $timeout, $do_read) = @@_;
 my ($rin,$rout,$win,$wout,$tout,$nfound);

 vec($rin='',fileno($data),1) = 1;

 ($win, $rin) = ($rin, $win) unless $do_read;

 while (1) {
   $nfound = select($rout=$rin, $wout=$win, undef, $tout=$timeout);

   last if $nfound >= 0;
   
   croak "select: $!"
     unless $!{EINTR};
 }

 $nfound;
}

sub can_read
{
 _select(@@_[0,1],1);
}

sub can_write
{
 _select(@@_[0,1],0);
}

sub cmd
{
 my $ftp = shift;

 ${*$ftp}{'net_ftp_cmd'};
}

sub bytes_read {
 my $ftp = shift;

 ${*$ftp}{'net_ftp_bytesread'} || 0;
}

1;
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@stock perl 5.8.0 from CPAN
@
text
@@


1.1.1.2
log
@import perl 5.10.0 from CPAN
@
text
@d13 1
a13 1
@@ISA     = qw(IO::Socket::INET);
d15 4
a18 4

sub reading {
  my $data = shift;
  ${*$data}{'net_ftp_bytesread'} = 0;
d21 4
d26 2
a27 6
sub abort {
  my $data = shift;
  my $ftp  = ${*$data}{'net_ftp_cmd'};

  # no need to abort if we have finished the xfer
  return $data->close
d30 10
a39 11
  # for some reason if we continously open RETR connections and not
  # read a single byte, then abort them after a while the server will
  # close our connection, this prevents the unexpected EOF on the
  # command channel -- GMB
  if (exists ${*$data}{'net_ftp_bytesread'}
    && (${*$data}{'net_ftp_bytesread'} == 0))
  {
    my $buf     = "";
    my $timeout = $data->timeout;
    $data->can_read($timeout) && sysread($data, $buf, 1);
  }
d41 1
a41 1
  ${*$data}{'net_ftp_eof'} = 1;    # fake
d43 1
a43 1
  $ftp->abort;                     # this will close me
d46 4
d51 1
a51 5
sub _close {
  my $data = shift;
  my $ftp  = ${*$data}{'net_ftp_cmd'};

  $data->SUPER::close();
d53 3
a55 3
  delete ${*$ftp}{'net_ftp_dataconn'}
    if exists ${*$ftp}{'net_ftp_dataconn'}
    && $data == ${*$ftp}{'net_ftp_dataconn'};
d58 4
d63 5
a67 3
sub close {
  my $data = shift;
  my $ftp  = ${*$data}{'net_ftp_cmd'};
d69 1
a69 5
  if (exists ${*$data}{'net_ftp_bytesread'} && !${*$data}{'net_ftp_eof'}) {
    my $junk;
    $data->read($junk, 1, 0);
    return $data->abort unless ${*$data}{'net_ftp_eof'};
  }
d71 3
a73 1
  $data->_close;
d75 1
a75 5
  $ftp->response() == CMD_OK
    && $ftp->message =~ /unique file name:\s*(\S*)\s*\)/
    && (${*$ftp}{'net_ftp_unique'} = $1);

  $ftp->status == CMD_OK;
a77 1

d79 2
a80 2
  my ($data, $timeout, $do_read) = @@_;
  my ($rin, $rout, $win, $wout, $tout, $nfound);
d82 1
a82 1
  vec($rin = '', fileno($data), 1) = 1;
d84 1
a84 1
  ($win, $rin) = ($rin, $win) unless $do_read;
d86 2
a87 2
  while (1) {
    $nfound = select($rout = $rin, $wout = $win, undef, $tout = $timeout);
d89 5
a93 1
    last if $nfound >= 0;
d95 1
a95 5
    croak "select: $!"
      unless $!{EINTR};
  }

  $nfound;
d98 3
a100 3

sub can_read {
  _select(@@_[0, 1], 1);
d103 3
a105 3

sub can_write {
  _select(@@_[0, 1], 0);
d108 3
d112 1
a112 4
sub cmd {
  my $ftp = shift;

  ${*$ftp}{'net_ftp_cmd'};
a114 1

d116 1
a116 1
  my $ftp = shift;
d118 1
a118 1
  ${*$ftp}{'net_ftp_bytesread'} || 0;
@

