head	1.12;
access;
symbols
	OPENBSD_5_3:1.11.0.10
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.8
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.6
	OPENBSD_5_0:1.11.0.4
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.2
	OPENBSD_4_9_BASE:1.11
	PERL_5_12_2:1.1.1.10
	OPENBSD_4_8:1.10.0.4
	OPENBSD_4_8_BASE:1.10
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	PERL_5_10_1:1.1.1.9
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	PERL_5_10_0:1.1.1.8
	OPENBSD_4_4:1.8.0.10
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.8
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.6
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.8.0.4
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.2
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.7
	OPENBSD_3_9:1.7.0.8
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.6
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.4
	OPENBSD_3_7_BASE:1.7
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.7.0.2
	OPENBSD_3_6_BASE:1.7
	PERL_5_8_5:1.1.1.6
	PERL_5_8_3:1.1.1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	PERL_5_8_2:1.1.1.5
	OPENBSD_3_4:1.5.0.4
	OPENBSD_3_4_BASE:1.5
	OPENBSD_3_3:1.5.0.2
	OPENBSD_3_3_BASE:1.5
	PERL_5_8_0:1.1.1.4
	OPENBSD_3_2:1.4.0.6
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.4
	OPENBSD_3_1_BASE:1.4
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	PERL_5_6_1:1.1.1.3
	OPENBSD_2_9:1.3.0.6
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_8:1.3.0.4
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.12
date	2013.03.25.20.40.56;	author sthen;	state dead;
branches;
next	1.11;

1.11
date	2010.09.24.15.07.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2009.10.12.18.24.42;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2008.09.29.17.36.13;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2006.03.28.19.23.07;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.04.07.21.33.06;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.03.03.02.40;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.05.24.18.35.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.06.17.06.45;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	99.04.29.22.51.58;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.57.53;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.40.16;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.47;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.05.24.18.23.35;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2003.12.03.02.44.07;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2004.04.07.21.13.21;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2006.03.28.18.48.54;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2008.09.29.17.18.40;	author millert;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	2009.10.12.18.11.05;	author millert;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	2010.09.24.14.48.38;	author millert;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.12
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@package Pod::Html;
use strict;
require Exporter;

use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK);
$VERSION = 1.09;
@@ISA = qw(Exporter);
@@EXPORT = qw(pod2html htmlify);
@@EXPORT_OK = qw(anchorify);

use Carp;
use Config;
use Cwd;
use File::Spec;
use File::Spec::Unix;
use Getopt::Long;

use locale;	# make \w work right in non-ASCII lands

=head1 NAME

Pod::Html - module to convert pod files to HTML

=head1 SYNOPSIS

    use Pod::Html;
    pod2html([options]);

=head1 DESCRIPTION

Converts files from pod format (see L<perlpod>) to HTML format.  It
can automatically generate indexes and cross-references, and it keeps
a cache of things it knows how to cross-reference.

=head1 FUNCTIONS

=head2 pod2html

    pod2html("pod2html",
             "--podpath=lib:ext:pod:vms",
             "--podroot=/usr/src/perl",
             "--htmlroot=/perl/nmanual",
             "--libpods=perlfunc:perlguts:perlvar:perlrun:perlop",
             "--recurse",
             "--infile=foo.pod",
             "--outfile=/perl/nmanual/foo.html");

pod2html takes the following arguments:

=over 4

=item backlink

    --backlink="Back to Top"

Adds "Back to Top" links in front of every C<head1> heading (except for
the first).  By default, no backlinks are generated.

=item cachedir

    --cachedir=name

Creates the item and directory caches in the given directory.

=item css

    --css=stylesheet

Specify the URL of a cascading style sheet.  Also disables all HTML/CSS
C<style> attributes that are output by default (to avoid conflicts).

=item flush

    --flush

Flushes the item and directory caches.

=item header

    --header
    --noheader

Creates header and footer blocks containing the text of the C<NAME>
section.  By default, no headers are generated.

=item help

    --help

Displays the usage message.

=item hiddendirs

    --hiddendirs
    --nohiddendirs

Include hidden directories in the search for POD's in podpath if recurse
is set.
The default is not to traverse any directory whose name begins with C<.>.
See L</"podpath"> and L</"recurse">.

[This option is for backward compatibility only.
It's hard to imagine that one would usefully create a module with a
name component beginning with C<.>.]

=item htmldir

    --htmldir=name

Sets the directory in which the resulting HTML file is placed.  This
is used to generate relative links to other files. Not passing this
causes all links to be absolute, since this is the value that tells
Pod::Html the root of the documentation tree.

=item htmlroot

    --htmlroot=name

Sets the base URL for the HTML files.  When cross-references are made,
the HTML root is prepended to the URL.

=item index

    --index
    --noindex

Generate an index at the top of the HTML file.  This is the default
behaviour.

=item infile

    --infile=name

Specify the pod file to convert.  Input is taken from STDIN if no
infile is specified.

=item libpods

    --libpods=name:...:name

List of page names (eg, "perlfunc") which contain linkable C<=item>s.

=item netscape

    --netscape
    --nonetscape

B<Deprecated>, has no effect. For backwards compatibility only.

=item outfile

    --outfile=name

Specify the HTML file to create.  Output goes to STDOUT if no outfile
is specified.

=item podpath

    --podpath=name:...:name

Specify which subdirectories of the podroot contain pod files whose
HTML converted forms can be linked to in cross references.

=item podroot

    --podroot=name

Specify the base directory for finding library pods.

=item quiet

    --quiet
    --noquiet

Don't display I<mostly harmless> warning messages.  These messages
will be displayed by default.  But this is not the same as C<verbose>
mode.

=item recurse

    --recurse
    --norecurse

Recurse into subdirectories specified in podpath (default behaviour).

=item title

    --title=title

Specify the title of the resulting HTML file.

=item verbose

    --verbose
    --noverbose

Display progress messages.  By default, they won't be displayed.

=back

=head2 htmlify

    htmlify($heading);

Converts a pod section specification to a suitable section specification
for HTML. Note that we keep spaces and special characters except 
C<", ?> (Netscape problem) and the hyphen (writer's problem...).

=head2 anchorify

    anchorify(@@heading);

Similar to C<htmlify()>, but turns non-alphanumerics into underscores.  Note
that C<anchorify()> is not exported by default.

=head1 ENVIRONMENT

Uses C<$Config{pod2html}> to setup default options.

=head1 AUTHOR

Tom Christiansen, E<lt>tchrist@@perl.comE<gt>.

=head1 SEE ALSO

L<perlpod>

=head1 COPYRIGHT

This program is distributed under the Artistic License.

=cut

my($Cachedir);
my($Dircache, $Itemcache);
my @@Begin_Stack;
my @@Libpods;
my($Htmlroot, $Htmldir, $Htmlfile, $Htmlfileurl);
my($Podfile, @@Podpath, $Podroot);
my $Css;

my $Recurse;
my $Quiet;
my $HiddenDirs;
my $Verbose;
my $Doindex;

my $Backlink;
my($Listlevel, @@Listtype);
my $ListNewTerm;
use vars qw($Ignore);  # need to localize it later.

my(%Items_Named, @@Items_Seen);
my($Title, $Header);

my $Top;
my $Paragraph;

my %Sections;

# Caches
my %Pages = ();			# associative array used to find the location
				#   of pages referenced by L<> links.
my %Items = ();			# associative array used to find the location
				#   of =item directives referenced by C<> links

my %Local_Items;
my $Is83;

my $Curdir = File::Spec->curdir;

init_globals();

sub init_globals {
    $Cachedir = ".";		# The directory to which item and directory
				# caches will be written.

    $Dircache = "pod2htmd.tmp";
    $Itemcache = "pod2htmi.tmp";

    @@Begin_Stack = ();		# begin/end stack

    @@Libpods = ();	    	# files to search for links from C<> directives
    $Htmlroot = "/";	    	# http-server base directory from which all
				#   relative paths in $podpath stem.
    $Htmldir = "";	    	# The directory to which the html pages
				# will (eventually) be written.
    $Htmlfile = "";		# write to stdout by default
    $Htmlfileurl = "";		# The url that other files would use to
				# refer to this file.  This is only used
				# to make relative urls that point to
				# other files.

    $Podfile = "";		# read from stdin by default
    @@Podpath = ();		# list of directories containing library pods.
    $Podroot = $Curdir;	        # filesystem base directory from which all
				#   relative paths in $podpath stem.
    $Css = '';                  # Cascading style sheet
    $Recurse = 1;		# recurse on subdirectories in $podpath.
    $Quiet = 0;		        # not quiet by default
    $Verbose = 0;		# not verbose by default
    $Doindex = 1;   	    	# non-zero if we should generate an index
    $Backlink = '';		# text for "back to top" links
    $Listlevel = 0;		# current list depth
    @@Listtype = ();		# list types for open lists
    $ListNewTerm = 0;		# indicates new term in definition list; used
    				# to correctly open/close <dd> tags
    $Ignore = 1;		# whether or not to format text.  we don't
				#   format text until we hit our first pod
				#   directive.

    @@Items_Seen = ();	        # for multiples of the same item in perlfunc
    %Items_Named = ();
    $Header = 0;		# produce block header/footer
    $Title = '';		# title to give the pod(s)
    $Top = 1;			# true if we are at the top of the doc.  used
				#   to prevent the first <hr /> directive.
    $Paragraph = '';		# which paragraph we're processing (used
				#   for error messages)
    %Sections = ();		# sections within this page

    %Local_Items = ();
    $Is83 = $^O eq 'dos';       # Is it an 8.3 filesystem?
}

#
# clean_data: global clean-up of pod data
#
sub clean_data($){
    my( $dataref ) = @@_;
    for my $i ( 0..$#{$dataref} ) {
	${$dataref}[$i] =~ s/\s+\Z//;

        # have a look for all-space lines
      if( ${$dataref}[$i] =~ /^\s+$/m and $dataref->[$i] !~ /^\s/ ){
	    my @@chunks = split( /^\s+$/m, ${$dataref}[$i] );
	    splice( @@$dataref, $i, 1, @@chunks );
	}
    }
}


sub pod2html {
    local(@@ARGV) = @@_;
    local($/);
    local $_;

    init_globals();

    $Is83 = 0 if (defined (&Dos::UseLFN) && Dos::UseLFN());

    # cache of %Pages and %Items from last time we ran pod2html

    #undef $opt_help if defined $opt_help;

    # parse the command-line parameters
    parse_command_line();

    # escape the backlink argument (same goes for title but is done later...)
    $Backlink = html_escape($Backlink) if defined $Backlink;

    # set some variables to their default values if necessary
    local *POD;
    unless (@@ARGV && $ARGV[0]) {
	$Podfile  = "-" unless $Podfile;	# stdin
	open(POD, "<$Podfile")
		|| die "$0: cannot open $Podfile file for input: $!\n";
    } else {
	$Podfile = $ARGV[0];  # XXX: might be more filenames
	*POD = *ARGV;
    }
    $Htmlfile = "-" unless $Htmlfile;	# stdout
    $Htmlroot = "" if $Htmlroot eq "/";	# so we don't get a //
    $Htmldir =~ s#/\z## ;               # so we don't get a //
    if (  $Htmlroot eq ''
       && defined( $Htmldir )
       && $Htmldir ne ''
       && substr( $Htmlfile, 0, length( $Htmldir ) ) eq $Htmldir
       )
    {
	# Set the 'base' url for this file, so that we can use it
	# as the location from which to calculate relative links
	# to other files. If this is '', then absolute links will
	# be used throughout.
        $Htmlfileurl= "$Htmldir/" . substr( $Htmlfile, length( $Htmldir ) + 1);
    }

    # read the pod a paragraph at a time
    warn "Scanning for sections in input file(s)\n" if $Verbose;
    $/ = "";
    my @@poddata  = <POD>;
    close(POD);

    # be eol agnostic
    for (@@poddata) {
	if (/\r/) {
	    if (/\r\n/) {
		@@poddata = map { s/\r\n/\n/g;
				 /\n\n/ ?
				     map { "$_\n\n" } split /\n\n/ :
				     $_ } @@poddata;
	    } else {
		@@poddata = map { s/\r/\n/g;
				 /\n\n/ ?
				     map { "$_\n\n" } split /\n\n/ :
				     $_ } @@poddata;
	    }
	    last;
	}
    }

    clean_data( \@@poddata );

    # scan the pod for =head[1-6] directives and build an index
    my $index = scan_headings(\%Sections, @@poddata);

    unless($index) {
	warn "No headings in $Podfile\n" if $Verbose;
    }

    # open the output file
    open(HTML, ">$Htmlfile")
	    || die "$0: cannot open $Htmlfile file for output: $!\n";

    # put a title in the HTML file if one wasn't specified
    if ($Title eq '') {
	TITLE_SEARCH: {
 	    for (my $i = 0; $i < @@poddata; $i++) {
		if ($poddata[$i] =~ /^=head1\s*NAME\b/m) {
 		    for my $para ( @@poddata[$i, $i+1] ) {
			last TITLE_SEARCH
			    if ($Title) = $para =~ /(\S+\s+-+.*\S)/s;
		    }
		}

	    }
	}
    }
    if (!$Title and $Podfile =~ /\.pod\z/) {
	# probably a split pod so take first =head[12] as title
 	for (my $i = 0; $i < @@poddata; $i++) {
	    last if ($Title) = $poddata[$i] =~ /^=head[12]\s*(.*)/;
	}
	warn "adopted '$Title' as title for $Podfile\n"
	    if $Verbose and $Title;
    }
    if ($Title) {
	$Title =~ s/\s*\(.*\)//;
    } else {
	warn "$0: no title for $Podfile.\n" unless $Quiet;
	$Podfile =~ /^(.*)(\.[^.\/]+)?\z/s;
	$Title = ($Podfile eq "-" ? 'No Title' : $1);
	warn "using $Title" if $Verbose;
    }
    $Title = html_escape($Title);

    my $csslink = '';
    my $bodystyle = ' style="background-color: white"';
    my $tdstyle = ' style="background-color: #cccccc"';

    if ($Css) {
      $csslink = qq(\n<link rel="stylesheet" href="$Css" type="text/css" />);
      $csslink =~ s,\\,/,g;
      $csslink =~ s,(/.):,$1|,;
      $bodystyle = '';
      $tdstyle = '';
    }

      my $block = $Header ? <<END_OF_BLOCK : '';
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block"$tdstyle valign="middle">
<big><strong><span class="block">&nbsp;$Title</span></strong></big>
</td></tr>
</table>
END_OF_BLOCK

    print HTML <<END_OF_HEAD;
<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>$Title</title>$csslink
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:$Config{perladmin}" />
</head>

<body$bodystyle>
$block
END_OF_HEAD

    # load/reload/validate/cache %Pages and %Items
    get_cache($Dircache, $Itemcache, \@@Podpath, $Podroot, $Recurse);

    # scan the pod for =item directives
    scan_items( \%Local_Items, "", @@poddata);

    # put an index at the top of the file.  note, if $Doindex is 0 we
    # still generate an index, but surround it with an html comment.
    # that way some other program can extract it if desired.
    $index =~ s/--+/-/g;

    my $hr = ($Doindex and $index) ? qq(<hr name="index" />) : "";

    unless ($Doindex)
    {
        $index = qq(<!--\n$index\n-->\n);
    }

    print HTML << "END_OF_INDEX";

<!-- INDEX BEGIN -->
<div name="index">
<p><a name=\"__index__\"></a></p>
$index
$hr
</div>
<!-- INDEX END -->

END_OF_INDEX

    # now convert this file
    my $after_item;             # set to true after an =item
    warn "Converting input file $Podfile\n" if $Verbose;
    foreach my $i (0..$#poddata){
	$_ = $poddata[$i];
	$Paragraph = $i+1;
	if (/^(=.*)/s) {	# is it a pod directive?
	    $Ignore = 0;
	    $after_item = 0;
	    $_ = $1;
	    if (/^=begin\s+(\S+)\s*(.*)/si) {# =begin
		process_begin($1, $2);
	    } elsif (/^=end\s+(\S+)\s*(.*)/si) {# =end
		process_end($1, $2);
	    } elsif (/^=cut/) {			# =cut
		process_cut();
	    } elsif (/^=pod/) {			# =pod
		process_pod();
	    } else {
		next if @@Begin_Stack && $Begin_Stack[-1] ne 'html';

		if (/^=(head[1-6])\s+(.*\S)/s) {	# =head[1-6] heading
		    process_head( $1, $2, $Doindex && $index );
		} elsif (/^=item\s*(.*\S)?/sm) {	# =item text
		    process_item( $1 );
		    $after_item = 1;
		} elsif (/^=over\s*(.*)/) {		# =over N
		    process_over();
		} elsif (/^=back/) {		# =back
		    process_back();
		} elsif (/^=for\s+(\S+)\s*(.*)/si) {# =for
		    process_for($1,$2);
		} else {
		    /^=(\S*)\s*/;
		    warn "$0: $Podfile: unknown pod directive '$1' in "
		       . "paragraph $Paragraph.  ignoring.\n" unless $Quiet;
		}
	    }
	    $Top = 0;
	}
	else {
	    next if $Ignore;
	    next if @@Begin_Stack && $Begin_Stack[-1] ne 'html';
	    print HTML and next if @@Begin_Stack && $Begin_Stack[-1] eq 'html';
	    my $text = $_;

	    # Open tag for definition list as we have something to put in it
	    if( $ListNewTerm ){
		print HTML "<dd>\n";
		$ListNewTerm = 0;
	    }

	    if( $text =~ /\A\s+/ ){
		process_pre( \$text );
	        print HTML "<pre>\n$text</pre>\n";

	    } else {
		process_text( \$text );

		# experimental: check for a paragraph where all lines
		# have some ...\t...\t...\n pattern
		if( $text =~ /\t/ ){
		    my @@lines = split( "\n", $text );
		    if( @@lines > 1 ){
			my $all = 2;
			foreach my $line ( @@lines ){
			    if( $line =~ /\S/ && $line !~ /\t/ ){
				$all--;
				last if $all == 0;
			    }
			}
			if( $all > 0 ){
			    $text =~ s/\t+/<td>/g;
			    $text =~ s/^/<tr><td>/gm;
			    $text = '<table cellspacing="0" cellpadding="0">' .
                                    $text . '</table>';
			}
		    }
		}
		## end of experimental

		print HTML "<p>$text</p>\n";
	    }
	    $after_item = 0;
	}
    }

    # finish off any pending directives
    finish_list();

    # link to page index
    print HTML "<p><a href=\"#__index__\"><small>$Backlink</small></a></p>\n"
	if $Doindex and $index and $Backlink;

    print HTML <<END_OF_TAIL;
$block
</body>

</html>
END_OF_TAIL

    # close the html file
    close(HTML);

    warn "Finished\n" if $Verbose;
}

##############################################################################

sub usage {
    my $podfile = shift;
    warn "$0: $podfile: @@_\n" if @@_;
    die <<END_OF_USAGE;
Usage:  $0 --help --htmlroot=<name> --infile=<name> --outfile=<name>
           --podpath=<name>:...:<name> --podroot=<name>
           --libpods=<name>:...:<name> --recurse --verbose --index
           --netscape --norecurse --noindex --cachedir=<name>

  --backlink     - set text for "back to top" links (default: none).
  --cachedir     - directory for the item and directory cache files.
  --css          - stylesheet URL
  --flush        - flushes the item and directory caches.
  --[no]header   - produce block header/footer (default is no headers).
  --help         - prints this message.
  --hiddendirs   - search hidden directories in podpath
  --htmldir      - directory for resulting HTML files.
  --htmlroot     - http-server base directory from which all relative paths
                   in podpath stem (default is /).
  --[no]index    - generate an index at the top of the resulting html
                   (default behaviour).
  --infile       - filename for the pod to convert (input taken from stdin
                   by default).
  --libpods      - colon-separated list of pages to search for =item pod
                   directives in as targets of C<> and implicit links (empty
                   by default).  note, these are not filenames, but rather
                   page names like those that appear in L<> links.
  --outfile      - filename for the resulting html file (output sent to
                   stdout by default).
  --podpath      - colon-separated list of directories containing library
                   pods (empty by default).
  --podroot      - filesystem base directory from which all relative paths
                   in podpath stem (default is .).
  --[no]quiet    - suppress some benign warning messages (default is off).
  --[no]recurse  - recurse on those subdirectories listed in podpath
                   (default behaviour).
  --title        - title that will appear in resulting html file.
  --[no]verbose  - self-explanatory (off by default).
  --[no]netscape - deprecated, has no effect. for backwards compatibility only.

END_OF_USAGE

}

sub parse_command_line {
    my ($opt_backlink,$opt_cachedir,$opt_css,$opt_flush,$opt_header,$opt_help,
	$opt_htmldir,$opt_htmlroot,$opt_index,$opt_infile,$opt_libpods,
	$opt_netscape,$opt_outfile,$opt_podpath,$opt_podroot,$opt_quiet,
	$opt_recurse,$opt_title,$opt_verbose,$opt_hiddendirs);

    unshift @@ARGV, split ' ', $Config{pod2html} if $Config{pod2html};
    my $result = GetOptions(
			    'backlink=s' => \$opt_backlink,
			    'cachedir=s' => \$opt_cachedir,
			    'css=s'      => \$opt_css,
			    'flush'      => \$opt_flush,
			    'header!'    => \$opt_header,
			    'help'       => \$opt_help,
			    'hiddendirs!'=> \$opt_hiddendirs,
			    'htmldir=s'  => \$opt_htmldir,
			    'htmlroot=s' => \$opt_htmlroot,
			    'index!'     => \$opt_index,
			    'infile=s'   => \$opt_infile,
			    'libpods=s'  => \$opt_libpods,
			    'netscape!'  => \$opt_netscape,
			    'outfile=s'  => \$opt_outfile,
			    'podpath=s'  => \$opt_podpath,
			    'podroot=s'  => \$opt_podroot,
			    'quiet!'     => \$opt_quiet,
			    'recurse!'   => \$opt_recurse,
			    'title=s'    => \$opt_title,
			    'verbose!'   => \$opt_verbose,
			   );
    usage("-", "invalid parameters") if not $result;

    usage("-") if defined $opt_help;	# see if the user asked for help
    $opt_help = "";			# just to make -w shut-up.

    @@Podpath  = split(":", $opt_podpath) if defined $opt_podpath;
    @@Libpods  = split(":", $opt_libpods) if defined $opt_libpods;

    $Backlink = $opt_backlink if defined $opt_backlink;
    $Cachedir = $opt_cachedir if defined $opt_cachedir;
    $Css      = $opt_css      if defined $opt_css;
    $Header   = $opt_header   if defined $opt_header;
    $Htmldir  = $opt_htmldir  if defined $opt_htmldir;
    $Htmlroot = $opt_htmlroot if defined $opt_htmlroot;
    $Doindex  = $opt_index    if defined $opt_index;
    $Podfile  = $opt_infile   if defined $opt_infile;
    $HiddenDirs = $opt_hiddendirs if defined $opt_hiddendirs;
    $Htmlfile = $opt_outfile  if defined $opt_outfile;
    $Podroot  = $opt_podroot  if defined $opt_podroot;
    $Quiet    = $opt_quiet    if defined $opt_quiet;
    $Recurse  = $opt_recurse  if defined $opt_recurse;
    $Title    = $opt_title    if defined $opt_title;
    $Verbose  = $opt_verbose  if defined $opt_verbose;

    warn "Flushing item and directory caches\n"
	if $opt_verbose && defined $opt_flush;
    $Dircache = "$Cachedir/pod2htmd.tmp";
    $Itemcache = "$Cachedir/pod2htmi.tmp";
    if (defined $opt_flush) {
	1 while unlink($Dircache, $Itemcache);
    }
}


my $Saved_Cache_Key;

sub get_cache {
    my($dircache, $itemcache, $podpath, $podroot, $recurse) = @@_;
    my @@cache_key_args = @@_;

    # A first-level cache:
    # Don't bother reading the cache files if they still apply
    # and haven't changed since we last read them.

    my $this_cache_key = cache_key(@@cache_key_args);

    return if $Saved_Cache_Key and $this_cache_key eq $Saved_Cache_Key;

    # load the cache of %Pages and %Items if possible.  $tests will be
    # non-zero if successful.
    my $tests = 0;
    if (-f $dircache && -f $itemcache) {
	warn "scanning for item cache\n" if $Verbose;
	$tests = load_cache($dircache, $itemcache, $podpath, $podroot);
    }

    # if we didn't succeed in loading the cache then we must (re)build
    #  %Pages and %Items.
    if (!$tests) {
	warn "scanning directories in pod-path\n" if $Verbose;
	scan_podpath($podroot, $recurse, 0);
    }
    $Saved_Cache_Key = cache_key(@@cache_key_args);
}

sub cache_key {
    my($dircache, $itemcache, $podpath, $podroot, $recurse) = @@_;
    return join('!', $dircache, $itemcache, $recurse,
	@@$podpath, $podroot, stat($dircache), stat($itemcache));
}

#
# load_cache - tries to find if the caches stored in $dircache and $itemcache
#  are valid caches of %Pages and %Items.  if they are valid then it loads
#  them and returns a non-zero value.
#
sub load_cache {
    my($dircache, $itemcache, $podpath, $podroot) = @@_;
    my($tests);
    local $_;

    $tests = 0;

    open(CACHE, "<$itemcache") ||
	die "$0: error opening $itemcache for reading: $!\n";
    $/ = "\n";

    # is it the same podpath?
    $_ = <CACHE>;
    chomp($_);
    $tests++ if (join(":", @@$podpath) eq $_);

    # is it the same podroot?
    $_ = <CACHE>;
    chomp($_);
    $tests++ if ($podroot eq $_);

    # load the cache if its good
    if ($tests != 2) {
	close(CACHE);
	return 0;
    }

    warn "loading item cache\n" if $Verbose;
    while (<CACHE>) {
	/(.*?) (.*)$/;
	$Items{$1} = $2;
    }
    close(CACHE);

    warn "scanning for directory cache\n" if $Verbose;
    open(CACHE, "<$dircache") ||
	die "$0: error opening $dircache for reading: $!\n";
    $/ = "\n";
    $tests = 0;

    # is it the same podpath?
    $_ = <CACHE>;
    chomp($_);
    $tests++ if (join(":", @@$podpath) eq $_);

    # is it the same podroot?
    $_ = <CACHE>;
    chomp($_);
    $tests++ if ($podroot eq $_);

    # load the cache if its good
    if ($tests != 2) {
	close(CACHE);
	return 0;
    }

    warn "loading directory cache\n" if $Verbose;
    while (<CACHE>) {
	/(.*?) (.*)$/;
	$Pages{$1} = $2;
    }

    close(CACHE);

    return 1;
}

#
# scan_podpath - scans the directories specified in @@podpath for directories,
#  .pod files, and .pm files.  it also scans the pod files specified in
#  @@Libpods for =item directives.
#
sub scan_podpath {
    my($podroot, $recurse, $append) = @@_;
    my($pwd, $dir);
    my($libpod, $dirname, $pod, @@files, @@poddata);

    unless($append) {
	%Items = ();
	%Pages = ();
    }

    # scan each directory listed in @@Podpath
    $pwd = getcwd();
    chdir($podroot)
	|| die "$0: error changing to directory $podroot: $!\n";
    foreach $dir (@@Podpath) {
	scan_dir($dir, $recurse);
    }

    # scan the pods listed in @@Libpods for =item directives
    foreach $libpod (@@Libpods) {
	# if the page isn't defined then we won't know where to find it
	# on the system.
	next unless defined $Pages{$libpod} && $Pages{$libpod};

	# if there is a directory then use the .pod and .pm files within it.
	# NOTE: Only finds the first so-named directory in the tree.
#	if ($Pages{$libpod} =~ /([^:]*[^(\.pod|\.pm)]):/) {
	if ($Pages{$libpod} =~ /([^:]*(?<!\.pod)(?<!\.pm)):/) {
	    #  find all the .pod and .pm files within the directory
	    $dirname = $1;
	    opendir(DIR, $dirname) ||
		die "$0: error opening directory $dirname: $!\n";
	    @@files = grep(/(\.pod|\.pm)\z/ && ! -d $_, readdir(DIR));
	    closedir(DIR);

	    # scan each .pod and .pm file for =item directives
	    foreach $pod (@@files) {
		open(POD, "<$dirname/$pod") ||
		    die "$0: error opening $dirname/$pod for input: $!\n";
		@@poddata = <POD>;
		close(POD);
		clean_data( \@@poddata );

		scan_items( \%Items, "$dirname/$pod", @@poddata);
	    }

	    # use the names of files as =item directives too.
### Don't think this should be done this way - confuses issues.(WL)
###	    foreach $pod (@@files) {
###		$pod =~ /^(.*)(\.pod|\.pm)$/;
###		$Items{$1} = "$dirname/$1.html" if $1;
###	    }
	} elsif ($Pages{$libpod} =~ /([^:]*\.pod):/ ||
		 $Pages{$libpod} =~ /([^:]*\.pm):/) {
	    # scan the .pod or .pm file for =item directives
	    $pod = $1;
	    open(POD, "<$pod") ||
		die "$0: error opening $pod for input: $!\n";
	    @@poddata = <POD>;
	    close(POD);
	    clean_data( \@@poddata );

	    scan_items( \%Items, "$pod", @@poddata);
	} else {
	    warn "$0: shouldn't be here (line ".__LINE__."\n" unless $Quiet;
	}
    }
    @@poddata = ();	# clean-up a bit

    chdir($pwd)
	|| die "$0: error changing to directory $pwd: $!\n";

    # cache the item list for later use
    warn "caching items for later use\n" if $Verbose;
    open(CACHE, ">$Itemcache") ||
	die "$0: error open $Itemcache for writing: $!\n";

    print CACHE join(":", @@Podpath) . "\n$podroot\n";
    foreach my $key (keys %Items) {
	print CACHE "$key $Items{$key}\n";
    }

    close(CACHE);

    # cache the directory list for later use
    warn "caching directories for later use\n" if $Verbose;
    open(CACHE, ">$Dircache") ||
	die "$0: error open $Dircache for writing: $!\n";

    print CACHE join(":", @@Podpath) . "\n$podroot\n";
    foreach my $key (keys %Pages) {
	print CACHE "$key $Pages{$key}\n";
    }

    close(CACHE);
}

#
# scan_dir - scans the directory specified in $dir for subdirectories, .pod
#  files, and .pm files.  notes those that it finds.  this information will
#  be used later in order to figure out where the pages specified in L<>
#  links are on the filesystem.
#
sub scan_dir {
    my($dir, $recurse) = @@_;
    my($t, @@subdirs, @@pods, $pod, $dirname, @@dirs);
    local $_;

    @@subdirs = ();
    @@pods = ();

    opendir(DIR, $dir) ||
	die "$0: error opening directory $dir: $!\n";
    while (defined($_ = readdir(DIR))) {
	if (-d "$dir/$_" && $_ ne "." && $_ ne ".."
	    && ($HiddenDirs || !/^\./)
	) {         # directory
	    $Pages{$_}  = "" unless defined $Pages{$_};
	    $Pages{$_} .= "$dir/$_:";
	    push(@@subdirs, $_);
	} elsif (/\.pod\z/) {	    	    	    	    # .pod
	    s/\.pod\z//;
	    $Pages{$_}  = "" unless defined $Pages{$_};
	    $Pages{$_} .= "$dir/$_.pod:";
	    push(@@pods, "$dir/$_.pod");
	} elsif (/\.html\z/) { 	    	    	    	    # .html
	    s/\.html\z//;
	    $Pages{$_}  = "" unless defined $Pages{$_};
	    $Pages{$_} .= "$dir/$_.pod:";
	} elsif (/\.pm\z/) { 	    	    	    	    # .pm
	    s/\.pm\z//;
	    $Pages{$_}  = "" unless defined $Pages{$_};
	    $Pages{$_} .= "$dir/$_.pm:";
	    push(@@pods, "$dir/$_.pm");
	} elsif (-T "$dir/$_") {			    # script(?)
	    local *F;
	    if (open(F, "$dir/$_")) {
		my $line;
		while (defined($line = <F>)) {
		    if ($line =~ /^=(?:pod|head1)/) {
			$Pages{$_}  = "" unless defined $Pages{$_};
			$Pages{$_} .= "$dir/$_.pod:";
			last;
		    }
		}
		close(F);
	    }
	}
    }
    closedir(DIR);

    # recurse on the subdirectories if necessary
    if ($recurse) {
	foreach my $subdir (@@subdirs) {
	    scan_dir("$dir/$subdir", $recurse);
	}
    }
}

#
# scan_headings - scan a pod file for head[1-6] tags, note the tags, and
#  build an index.
#
sub scan_headings {
    my($sections, @@data) = @@_;
    my($tag, $which_head, $otitle, $listdepth, $index);

    local $Ignore = 0;

    $listdepth = 0;
    $index = "";

    # scan for =head directives, note their name, and build an index
    #  pointing to each of them.
    foreach my $line (@@data) {
      if ($line =~ /^=(head)([1-6])\s+(.*)/) {
        ($tag, $which_head, $otitle) = ($1,$2,$3);

        my $title = depod( $otitle );
        my $name = anchorify( $title );
        $$sections{$name} = 1;
        $title = process_text( \$otitle );

	    while ($which_head != $listdepth) {
		if ($which_head > $listdepth) {
		    $index .= "\n" . ("\t" x $listdepth) . "<ul>\n";
		    $listdepth++;
		} elsif ($which_head < $listdepth) {
		    $listdepth--;
		    $index .= "\n" . ("\t" x $listdepth) . "</ul>\n";
		}
	    }

	    $index .= "\n" . ("\t" x $listdepth) . "<li>" .
	              "<a href=\"#" . $name . "\">" .
		      $title . "</a></li>";
	}
    }

    # finish off the lists
    while ($listdepth--) {
	$index .= "\n" . ("\t" x $listdepth) . "</ul>\n";
    }

    # get rid of bogus lists
    $index =~ s,\t*<ul>\s*</ul>\n,,g;

    return $index;
}

#
# scan_items - scans the pod specified by $pod for =item directives.  we
#  will use this information later on in resolving C<> links.
#
sub scan_items {
    my( $itemref, $pod, @@poddata ) = @@_;
    my($i, $item);
    local $_;

    $pod =~ s/\.pod\z//;
    $pod .= ".html" if $pod;

    foreach $i (0..$#poddata) {
	my $txt = depod( $poddata[$i] );

	# figure out what kind of item it is.
	# Build string for referencing this item.
	if ( $txt =~ /\A=item\s+\*\s*(.*)\Z/s ) { # bulleted list
	    next unless $1;
	    $item = $1;
        } elsif( $txt =~ /\A=item\s+(?>\d+\.?)\s*(.*)\Z/s ) { # numbered list
	    $item = $1;
	} elsif( $txt =~ /\A=item\s+(.*)\Z/s ) { # definition list
	    $item = $1;
	} else {
	    next;
	}
	my $fid = fragment_id( $item );
	$$itemref{$fid} = "$pod" if $fid;
    }
}

#
# process_head - convert a pod head[1-6] tag and convert it to HTML format.
#
sub process_head {
    my($tag, $heading, $hasindex) = @@_;

    # figure out the level of the =head
    $tag =~ /head([1-6])/;
    my $level = $1;

    finish_list();

    print HTML "<p>\n";
    if( $level == 1 && ! $Top ){
      print HTML "<a href=\"#__index__\"><small>$Backlink</small></a>\n"
        if $hasindex and $Backlink;
      print HTML "</p>\n<hr />\n"
    } else {
      print HTML "</p>\n";
    }

    my $name = anchorify( depod( $heading ) );
    my $convert = process_text( \$heading );
    print HTML "<h$level><a name=\"$name\">$convert</a></h$level>\n";
}


#
# emit_item_tag - print an =item's text
# Note: The global $EmittedItem is used for inhibiting self-references.
#
my $EmittedItem;

sub emit_item_tag($$$){
    my( $otext, $text, $compact ) = @@_;
    my $item = fragment_id( depod($text) , -generate);
    Carp::confess("Undefined fragment '$text' (".depod($text).") from fragment_id() in emit_item_tag() in $Podfile")
        if !defined $item;
    $EmittedItem = $item;
    ### print STDERR "emit_item_tag=$item ($text)\n";

    print HTML '<strong>';
    if ($Items_Named{$item}++) {
	print HTML process_text( \$otext );
    } else {
        my $name = $item;
        $name = anchorify($name);
	print HTML qq{<a name="$name" class="item">}, process_text( \$otext ), '</a>';
    }
    print HTML "</strong>";
    undef( $EmittedItem );
}

sub new_listitem {
    my( $tag ) = @@_;
    # Open tag for definition list as we have something to put in it
    if( ($tag ne 'dl') && ($ListNewTerm) ){
	print HTML "<dd>\n";
	$ListNewTerm = 0;
    }

    if( $Items_Seen[$Listlevel]++ == 0 ){
	# start of new list
	push( @@Listtype, "$tag" );
	print HTML "<$tag>\n";
    } else {
	# if this is not the first item, close the previous one
	if ( $tag eq 'dl' ){
	    print HTML "</dd>\n" unless $ListNewTerm;
	} else {
	    print HTML "</li>\n";
	}
    }
    my $opentag = $tag eq 'dl' ? 'dt' : 'li';
    print HTML "<$opentag>";
}

#
# process_item - convert a pod item tag and convert it to HTML format.
#
sub process_item {
    my( $otext ) = @@_;

    # lots of documents start a list without doing an =over.  this is
    # bad!  but, the proper thing to do seems to be to just assume
    # they did do an =over.  so warn them once and then continue.
    if( $Listlevel == 0 ){
	warn "$0: $Podfile: unexpected =item directive in paragraph $Paragraph.  ignoring.\n" unless $Quiet;
	process_over();
    }

    # remove formatting instructions from the text
    my $text = depod( $otext );

    # all the list variants:
    if( $text =~ /\A\*/ ){ # bullet
        new_listitem( 'ul' );
        if ($text =~ /\A\*\s+(\S.*)\Z/s ) { # with additional text
            my $tag = $1;
            $otext =~ s/\A\*\s+//;
            emit_item_tag( $otext, $tag, 1 );
            print HTML "\n";
        }

    } elsif( $text =~ /\A\d+/ ){ # numbered list
        new_listitem( 'ol' );
        if ($text =~ /\A(?>\d+\.?)\s*(\S.*)\Z/s ) { # with additional text
            my $tag = $1;
            $otext =~ s/\A\d+\.?\s*//;
            emit_item_tag( $otext, $tag, 1 );
            print HTML "\n";
        }

    } else {			# definition list
        # new_listitem takes care of opening the <dt> tag
        new_listitem( 'dl' );
        if ($text =~ /\A(.+)\Z/s ){ # should have text
            emit_item_tag( $otext, $text, 1 );
	    # write the definition term and close <dt> tag
	    print HTML "</dt>\n";
        }
        # trigger opening a <dd> tag for the actual definition; will not
        # happen if next paragraph is also a definition term (=item)
        $ListNewTerm = 1;
    }
    print HTML "\n";
}

#
# process_over - process a pod over tag and start a corresponding HTML list.
#
sub process_over {
    # start a new list
    $Listlevel++;
    push( @@Items_Seen, 0 );
}

#
# process_back - process a pod back tag and convert it to HTML format.
#
sub process_back {
    if( $Listlevel == 0 ){
	warn "$0: $Podfile: unexpected =back directive in paragraph $Paragraph.  ignoring.\n" unless $Quiet;
	return;
    }

    # close off the list.  note, I check to see if $Listtype[$Listlevel] is
    # defined because an =item directive may have never appeared and thus
    # $Listtype[$Listlevel] may have never been initialized.
    $Listlevel--;
    if( defined $Listtype[$Listlevel] ){
        if ( $Listtype[$Listlevel] eq 'dl' ){
            print HTML "</dd>\n" unless $ListNewTerm;
        } else {
            print HTML "</li>\n";
        }
        print HTML "</$Listtype[$Listlevel]>\n";
        pop( @@Listtype );
        $ListNewTerm = 0;
    }

    # clean up item count
    pop( @@Items_Seen );
}

#
# process_cut - process a pod cut tag, thus start ignoring pod directives.
#
sub process_cut {
    $Ignore = 1;
}

#
# process_pod - process a pod tag, thus stop ignoring pod directives
# until we see a corresponding cut.
#
sub process_pod {
    # no need to set $Ignore to 0 cause the main loop did it
}

#
# process_for - process a =for pod tag.  if it's for html, spit
# it out verbatim, if illustration, center it, otherwise ignore it.
#
sub process_for {
    my($whom, $text) = @@_;
    if ( $whom =~ /^(pod2)?html$/i) {
	print HTML $text;
    } elsif ($whom =~ /^illustration$/i) {
        1 while chomp $text;
	for my $ext (qw[.png .gif .jpeg .jpg .tga .pcl .bmp]) {
	  $text .= $ext, last if -r "$text$ext";
	}
        print HTML qq{<p align="center"><img src="$text" alt="$text illustration" /></p>};
    }
}

#
# process_begin - process a =begin pod tag.  this pushes
# whom we're beginning on the begin stack.  if there's a
# begin stack, we only print if it us.
#
sub process_begin {
    my($whom, $text) = @@_;
    $whom = lc($whom);
    push (@@Begin_Stack, $whom);
    if ( $whom =~ /^(pod2)?html$/) {
	print HTML $text if $text;
    }
}

#
# process_end - process a =end pod tag.  pop the
# begin stack.  die if we're mismatched.
#
sub process_end {
    my($whom, $text) = @@_;
    $whom = lc($whom);
    if (!defined $Begin_Stack[-1] or $Begin_Stack[-1] ne $whom ) {
	Carp::confess("Unmatched begin/end at chunk $Paragraph in pod $Podfile\n")
    }
    pop( @@Begin_Stack );
}

#
# process_pre - indented paragraph, made into <pre></pre>
#
sub process_pre {
    my( $text ) = @@_;
    my( $rest );
    return if $Ignore;

    $rest = $$text;

    # insert spaces in place of tabs
    $rest =~ s#(.+)#
	    my $line = $1;
            1 while $line =~ s/(\t+)/' ' x ((length($1) * 8) - $-[0] % 8)/e;
	    $line;
	#eg;

    # convert some special chars to HTML escapes
    $rest = html_escape($rest);

    # try and create links for all occurrences of perl.* within
    # the preformatted text.
    $rest =~ s{
	         (\s*)(perl\w+)
	      }{
		 if ( defined $Pages{$2} ){	# is a link
		     qq($1<a href="$Htmlroot/$Pages{$2}">$2</a>);
		 } elsif (defined $Pages{dosify($2)}) {	# is a link
		     qq($1<a href="$Htmlroot/$Pages{dosify($2)}">$2</a>);
		 } else {
		     "$1$2";
		 }
	      }xeg;
     $rest =~ s{
		 (<a\ href="?) ([^>:]*:)? ([^>:]*) \.pod: ([^>:]*:)?
               }{
                  my $url ;
                  if ( $Htmlfileurl ne '' ){
		     # Here, we take advantage of the knowledge
		     # that $Htmlfileurl ne '' implies $Htmlroot eq ''.
		     # Since $Htmlroot eq '', we need to prepend $Htmldir
		     # on the fron of the link to get the absolute path
		     # of the link's target. We check for a leading '/'
		     # to avoid corrupting links that are #, file:, etc.
		     my $old_url = $3 ;
		     $old_url = "$Htmldir$old_url" if $old_url =~ m{^\/};
 		     $url = relativize_url( "$old_url.html", $Htmlfileurl );
	          } else {
		     $url = "$3.html" ;
		  }
		  "$1$url" ;
	       }xeg;

    # Look for embedded URLs and make them into links.  We don't
    # relativize them since they are best left as the author intended.

    my $urls = '(' . join ('|', qw{
                http
                telnet
		mailto
		news
                gopher
                file
                wais
                ftp
            } )
        . ')';

    my $ltrs = '\w';
    my $gunk = '/#~:.?+=&%@@!\-';
    my $punc = '.:!?\-;';
    my $any  = "${ltrs}${gunk}${punc}";

    $rest =~ s{
	\b			# start at word boundary
	(			# begin $1  {
	    $urls :		# need resource and a colon
	    (?!:)		# Ignore File::, among others.
	    [$any] +?		# followed by one or more of any valid
				#   character, but be conservative and
				#   take only what you need to....
	)			# end   $1  }
	(?=
	    &quot; &gt;		# maybe pre-quoted '<a href="...">'
	|			# or:
	    [$punc]*		# 0 or more punctuation
	    (?:			#   followed
		[^$any]		#   by a non-url char
	    |			#   or
		$		#   end of the string
	    )			#
	|			# or else
	    $			#   then end of the string
        )
      }{<a href="$1">$1</a>}igox;

    # text should be as it is (verbatim)
    $$text = $rest;
}


#
# pure text processing
#
# pure_text/inIS_text: differ with respect to automatic C<> recognition.
# we don't want this to happen within IS
#
sub pure_text($){
    my $text = shift();
    process_puretext( $text, 1 );
}

sub inIS_text($){
    my $text = shift();
    process_puretext( $text, 0 );
}

#
# process_puretext - process pure text (without pod-escapes) converting
#  double-quotes and handling implicit C<> links.
#
sub process_puretext {
    my($text, $notinIS) = @@_;

    ## Guessing at func() or [\$\@@%&]*var references in plain text is destined
    ## to produce some strange looking ref's. uncomment to disable:
    ## $notinIS = 0;

    my(@@words, $lead, $trail);

    # keep track of leading and trailing white-space
    $lead  = ($text =~ s/\A(\s+)//s ? $1 : "");
    $trail = ($text =~ s/(\s+)\Z//s ? $1 : "");

    # split at space/non-space boundaries
    @@words = split( /(?<=\s)(?=\S)|(?<=\S)(?=\s)/, $text );

    # process each word individually
    foreach my $word (@@words) {
	# skip space runs
 	next if $word =~ /^\s*$/;
	# see if we can infer a link or a function call
	#
	# NOTE: This is a word based search, it won't automatically
	# mark "substr($var, 1, 2)" because the 1st word would be "substr($var"
	# User has to enclose those with proper C<>

	if( $notinIS && $word =~
	    m/
		^([a-z_]{2,})                 # The function name
		\(
		    ([0-9][a-z]*              # Manual page(1) or page(1M)
		    |[^)]*[\$\@@\%][^)]+       # ($foo), (1, @@foo), (%hash)
		    |                         # ()
		    )
		\)
		([.,;]?)$                     # a possible punctuation follows
	    /xi
	) {
	    # has parenthesis so should have been a C<> ref
            ## try for a pagename (perlXXX(1))?
            my( $func, $args, $rest ) = ( $1, $2, $3 || '' );
            if( $args =~ /^\d+$/ ){
                my $url = page_sect( $word, '' );
                if( defined $url ){
                    $word = qq(<a href="$url" class="man">the $word manpage</a>$rest);
                    next;
                }
            }
            ## try function name for a link, append tt'ed argument list
            $word = emit_C( $func, '', "($args)") . $rest;

#### disabled. either all (including $\W, $\w+{.*} etc.) or nothing.
##      } elsif( $notinIS && $word =~ /^[\$\@@%&*]+\w+$/) {
##	    # perl variables, should be a C<> ref
##	    $word = emit_C( $word );

	} elsif ($word =~ m,^\w+://\w,) {
	    # looks like a URL
            # Don't relativize it: leave it as the author intended
	    $word = qq(<a href="$word">$word</a>);
	} elsif ($word =~ /[\w.-]+\@@[\w-]+\.\w/) {
	    # looks like an e-mail address
	    my ($w1, $w2, $w3) = ("", $word, "");
	    ($w1, $w2, $w3) = ("(", $1, ")$2") if $word =~ /^\((.*?)\)(,?)/;
	    ($w1, $w2, $w3) = ("&lt;", $1, "&gt;$2") if $word =~ /^<(.*?)>(,?)/;
	    $word = qq($w1<a href="mailto:$w2">$w2</a>$w3);
	} else {
	    $word = html_escape($word) if $word =~ /["&<>]/;
	}
    }

    # put everything back together
    return $lead . join( '', @@words ) . $trail;
}


#
# process_text - handles plaintext that appears in the input pod file.
# there may be pod commands embedded within the text so those must be
# converted to html commands.
#

sub process_text1($$;$$);
sub pattern ($) { $_[0] ? '\s+'.('>' x ($_[0] + 1)) : '>' }
sub closing ($) { local($_) = shift; (defined && s/\s+\z//) ? length : 0 }

sub process_text {
    return if $Ignore;
    my( $tref ) = @@_;
    my $res = process_text1( 0, $tref );
    $res =~ s/\s+$//s;
    $$tref = $res;
}

sub process_text_rfc_links {
    my $text = shift;

    # For every "RFCnnnn" or "RFC nnn", link it to the authoritative
    # ource. Do not use the /i modifier here. Require "RFC" to be written in
    #  in capital letters.

    $text =~ s{
	(?<=[^<>[:alpha:]])           # Make sure this is not an URL already
	(RFC\s*([0-9]{1,5}))(?![0-9]) # max 5 digits
    }
    {<a href="http://www.ietf.org/rfc/rfc$2.txt" class="rfc">$1</a>}gx;

    $text;
}

sub process_text1($$;$$){
    my( $lev, $rstr, $func, $closing ) = @@_;
    my $res = '';

    unless (defined $func) {
	$func = '';
	$lev++;
    }

    if( $func eq 'B' ){
	# B<text> - boldface
	$res = '<strong>' . process_text1( $lev, $rstr ) . '</strong>';

    } elsif( $func eq 'C' ){
	# C<code> - can be a ref or <code></code>
	# need to extract text
	my $par = go_ahead( $rstr, 'C', $closing );

	## clean-up of the link target
        my $text = depod( $par );

	### my $x = $par =~ /[BI]</ ? 'yes' : 'no' ;
        ### print STDERR "-->call emit_C($par) lev=$lev, par with BI=$x\n";

	$res = emit_C( $text, $lev > 1 || ($par =~ /[BI]</) );

    } elsif( $func eq 'E' ){
	# E<x> - convert to character
	$$rstr =~ s/^([^>]*)>//;
	my $escape = $1;
	$escape =~ s/^0?x([\dA-F]+)$/#x$1/i
	or $escape =~ s/^0([0-7]+)$/'#'.oct($1)/ei
	or $escape =~ s/^(\d+)$/#$1/;
	$res = "&$escape;";

    } elsif( $func eq 'F' ){
	# F<filename> - italicize
	$res = '<em class="file">' . process_text1( $lev, $rstr ) . '</em>';

    } elsif( $func eq 'I' ){
	# I<text> - italicize
	$res = '<em>' . process_text1( $lev, $rstr ) . '</em>';

    } elsif( $func eq 'L' ){
	# L<link> - link
	## L<text|cross-ref> => produce text, use cross-ref for linking
	## L<cross-ref> => make text from cross-ref
	## need to extract text
	my $par = go_ahead( $rstr, 'L', $closing );

        # some L<>'s that shouldn't be:
	# a) full-blown URL's are emitted as-is
        if( $par =~ m{^\w+://}s ){
	    return make_URL_href( $par );
	}
        # b) C<...> is stripped and treated as C<>
        if( $par =~ /^C<(.*)>$/ ){
	    my $text = depod( $1 );
 	    return emit_C( $text, $lev > 1 || ($par =~ /[BI]</) );
	}

	# analyze the contents
	$par =~ s/\n/ /g;   # undo word-wrapped tags
        my $opar = $par;
	my $linktext;
	if( $par =~ s{^([^|]+)\|}{} ){
	    $linktext = $1;
	}

	# make sure sections start with a /
	$par =~ s{^"}{/"};

	my( $page, $section, $ident );

	# check for link patterns
	if( $par =~ m{^([^/]+?)/(?!")(.*?)$} ){     # name/ident
            # we've got a name/ident (no quotes)
            if (length $2) {
                ( $page, $ident ) = ( $1, $2 );
            } else {
                ( $page, $section ) = ( $1, $2 );
            }
            ### print STDERR "--> L<$par> to page $page, ident $ident\n";

	} elsif( $par =~ m{^(.*?)/"?(.*?)"?$} ){ # [name]/"section"
            # even though this should be a "section", we go for ident first
	    ( $page, $ident ) = ( $1, $2 );
            ### print STDERR "--> L<$par> to page $page, section $section\n";

	} elsif( $par =~ /\s/ ){  # this must be a section with missing quotes
	    ( $page, $section ) = ( '', $par );
            ### print STDERR "--> L<$par> to void page, section $section\n";

        } else {
	    ( $page, $section ) = ( $par, '' );
            ### print STDERR "--> L<$par> to page $par, void section\n";
	}

        # now, either $section or $ident is defined. the convoluted logic
        # below tries to resolve L<> according to what the user specified.
        # failing this, we try to find the next best thing...
        my( $url, $ltext, $fid );

        RESOLVE: {
            if( defined $ident ){
                ## try to resolve $ident as an item
	        ( $url, $fid ) = coderef( $page, $ident );
                if( $url ){
                    if( ! defined( $linktext ) ){
                        $linktext = $ident;
                        $linktext .= " in " if $ident && $page;
                        $linktext .= "the $page manpage" if $page;
                    }
                    ###  print STDERR "got coderef url=$url\n";
                    last RESOLVE;
                }
                ## no luck: go for a section (auto-quoting!)
                $section = $ident;
            }
            ## now go for a section
            my $htmlsection = htmlify( $section );
 	    $url = page_sect( $page, $htmlsection );
            if( $url ){
                if( ! defined( $linktext ) ){
                    $linktext = $section;
                    $linktext .= " in " if $section && $page;
                    $linktext .= "the $page manpage" if $page;
                }
                ### print STDERR "got page/section url=$url\n";
                last RESOLVE;
            }
            ## no luck: go for an ident
            if( $section ){
                $ident = $section;
            } else {
                $ident = $page;
                $page  = undef();
            }
            ( $url, $fid ) = coderef( $page, $ident );
            if( $url ){
                if( ! defined( $linktext ) ){
                    $linktext = $ident;
                    $linktext .= " in " if $ident && $page;
                    $linktext .= "the $page manpage" if $page;
                }
                ### print STDERR "got section=>coderef url=$url\n";
                last RESOLVE;
            }

            # warning; show some text.
            $linktext = $opar unless defined $linktext;
            warn "$0: $Podfile: cannot resolve L<$opar> in paragraph $Paragraph.\n" unless $Quiet;
        }

        # now we have a URL or just plain code
        $$rstr = $linktext . '>' . $$rstr;
        if( defined( $url ) ){
            $res = "<a href=\"$url\">" . process_text1( $lev, $rstr ) . '</a>';
        } else {
	    $res = '<em>' . process_text1( $lev, $rstr ) . '</em>';
        }

    } elsif( $func eq 'S' ){
	# S<text> - non-breaking spaces
	$res = process_text1( $lev, $rstr );
	$res =~ s/ /&nbsp;/g;

    } elsif( $func eq 'X' ){
	# X<> - ignore
	warn "$0: $Podfile: invalid X<> in paragraph $Paragraph.\n"
	    unless $$rstr =~ s/^[^>]*>// or $Quiet;
    } elsif( $func eq 'Z' ){
	# Z<> - empty
	warn "$0: $Podfile: invalid Z<> in paragraph $Paragraph.\n"
	    unless $$rstr =~ s/^>// or $Quiet;

    } else {
        my $term = pattern $closing;
	while( $$rstr =~ s/\A(.*?)(([BCEFILSXZ])<(<+[^\S\n]+)?|$term)//s ){
	    # all others: either recurse into new function or
	    # terminate at closing angle bracket(s)
	    my $pt = $1;
            $pt .= $2 if !$3 &&  $lev == 1;
	    $res .= $lev == 1 ? pure_text( $pt ) : inIS_text( $pt );
	    return $res if !$3 && $lev > 1;
            if( $3 ){
		$res .= process_text1( $lev, $rstr, $3, closing $4 );
 	    }
	}
	if( $lev == 1 ){
	    $res .= pure_text( $$rstr );
	} elsif( ! $Quiet ) {
            my $snippet = substr($$rstr,0,60);
            warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph: '$snippet'.\n" 
                
	}
	$res = process_text_rfc_links($res);
    }
    return $res;
}

#
# go_ahead: extract text of an IS (can be nested)
#
sub go_ahead($$$){
    my( $rstr, $func, $closing ) = @@_;
    my $res = '';
    my @@closing = ($closing);
    while( $$rstr =~
      s/\A(.*?)(([BCEFILSXZ])<(<+\s+)?|@@{[pattern $closing[0]]})//s ){
	$res .= $1;
	unless( $3 ){
	    shift @@closing;
	    return $res unless @@closing;
	} else {
	    unshift @@closing, closing $4;
	}
	$res .= $2;
    }
    unless ($Quiet) {
        my $snippet = substr($$rstr,0,60);
        warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph (go_ahead): '$snippet'.\n" 
    }	        
    return $res;
}

#
# emit_C - output result of C<text>
#    $text is the depod-ed text
#
sub emit_C($;$$){
    my( $text, $nocode, $args ) = @@_;
    $args = '' unless defined $args;
    my $res;
    my( $url, $fid ) = coderef( undef(), $text );

    # need HTML-safe text
    my $linktext = html_escape( "$text$args" );

    if( defined( $url ) &&
        (!defined( $EmittedItem ) || $EmittedItem ne $fid ) ){
	$res = "<a href=\"$url\"><code>$linktext</code></a>";
    } elsif( 0 && $nocode ){
	$res = $linktext;
    } else {
	$res = "<code>$linktext</code>";
    }
    return $res;
}

#
# html_escape: make text safe for HTML
#
sub html_escape {
    my $rest = $_[0];
    $rest   =~ s/&/&amp;/g;
    $rest   =~ s/</&lt;/g;
    $rest   =~ s/>/&gt;/g;
    $rest   =~ s/"/&quot;/g;
    # &apos; is only in XHTML, not HTML4.  Be conservative
    #$rest   =~ s/'/&apos;/g;
    return $rest;
}


#
# dosify - convert filenames to 8.3
#
sub dosify {
    my($str) = @@_;
    return lc($str) if $^O eq 'VMS';     # VMS just needs casing
    if ($Is83) {
        $str = lc $str;
        $str =~ s/(\.\w+)/substr ($1,0,4)/ge;
        $str =~ s/(\w+)/substr ($1,0,8)/ge;
    }
    return $str;
}

#
# page_sect - make a URL from the text of a L<>
#
sub page_sect($$) {
    my( $page, $section ) = @@_;
    my( $linktext, $page83, $link);	# work strings

    # check if we know that this is a section in this page
    if (!defined $Pages{$page} && defined $Sections{$page}) {
	$section = $page;
	$page = "";
        ### print STDERR "reset page='', section=$section\n";
    }

    $page83=dosify($page);
    $page=$page83 if (defined $Pages{$page83});
    if ($page eq "") {
        $link = "#" . anchorify( $section );
    } elsif ( $page =~ /::/ ) {
	$page =~ s,::,/,g;
	# Search page cache for an entry keyed under the html page name,
	# then look to see what directory that page might be in.  NOTE:
	# this will only find one page. A better solution might be to produce
	# an intermediate page that is an index to all such pages.
	my $page_name = $page ;
	$page_name =~ s,^.*/,,s ;
	if ( defined( $Pages{ $page_name } ) &&
	     $Pages{ $page_name } =~ /([^:]*$page)\.(?:pod|pm):/
	   ) {
	    $page = $1 ;
	}
	else {
	    # NOTE: This branch assumes that all A::B pages are located in
	    # $Htmlroot/A/B.html . This is often incorrect, since they are
	    # often in $Htmlroot/lib/A/B.html or such like. Perhaps we could
	    # analyze the contents of %Pages and figure out where any
	    # cousins of A::B are, then assume that.  So, if A::B isn't found,
	    # but A::C is found in lib/A/C.pm, then A::B is assumed to be in
	    # lib/A/B.pm. This is also limited, but it's an improvement.
	    # Maybe a hints file so that the links point to the correct places
	    # nonetheless?

	}
	$link = "$Htmlroot/$page.html";
	$link .= "#" . anchorify( $section ) if ($section);
    } elsif (!defined $Pages{$page}) {
	$link = "";
    } else {
	$section = anchorify( $section ) if $section ne "";
        ### print STDERR "...section=$section\n";

	# if there is a directory by the name of the page, then assume that an
	# appropriate section will exist in the subdirectory
#	if ($section ne "" && $Pages{$page} =~ /([^:]*[^(\.pod|\.pm)]):/) {
	if ($section ne "" && $Pages{$page} =~ /([^:]*(?<!\.pod)(?<!\.pm)):/) {
	    $link = "$Htmlroot/$1/$section.html";
            ### print STDERR "...link=$link\n";

	# since there is no directory by the name of the page, the section will
	# have to exist within a .html of the same name.  thus, make sure there
	# is a .pod or .pm that might become that .html
	} else {
	    $section = "#$section" if $section;
            ### print STDERR "...section=$section\n";

	    # check if there is a .pod with the page name.
	    # for L<Foo>, Foo.(pod|pm) is preferred to A/Foo.(pod|pm)
	    if ($Pages{$page} =~ /([^:]*)\.(?:pod|pm):/) {
		$link = "$Htmlroot/$1.html$section";
	    } else {
		$link = "";
	    }
	}
    }

    if ($link) {
	# Here, we take advantage of the knowledge that $Htmlfileurl ne ''
	# implies $Htmlroot eq ''. This means that the link in question
	# needs a prefix of $Htmldir if it begins with '/'. The test for
	# the initial '/' is done to avoid '#'-only links, and to allow
	# for other kinds of links, like file:, ftp:, etc.
        my $url ;
        if (  $Htmlfileurl ne '' ) {
            $link = "$Htmldir$link" if $link =~ m{^/}s;
            $url = relativize_url( $link, $Htmlfileurl );
# print( "  b: [$link,$Htmlfileurl,$url]\n" );
	}
	else {
            $url = $link ;
	}
	return $url;

    } else {
	return undef();
    }
}

#
# relativize_url - convert an absolute URL to one relative to a base URL.
# Assumes both end in a filename.
#
sub relativize_url {
    my ($dest,$source) = @@_ ;

    my ($dest_volume,$dest_directory,$dest_file) =
        File::Spec::Unix->splitpath( $dest ) ;
    $dest = File::Spec::Unix->catpath( $dest_volume, $dest_directory, '' ) ;

    my ($source_volume,$source_directory,$source_file) =
        File::Spec::Unix->splitpath( $source ) ;
    $source = File::Spec::Unix->catpath( $source_volume, $source_directory, '' ) ;

    my $rel_path = '' ;
    if ( $dest ne '' ) {
       $rel_path = File::Spec::Unix->abs2rel( $dest, $source ) ;
    }

    if ( $rel_path ne ''                &&
         substr( $rel_path, -1 ) ne '/' &&
         substr( $dest_file, 0, 1 ) ne '#'
        ) {
        $rel_path .= "/$dest_file" ;
    }
    else {
        $rel_path .= "$dest_file" ;
    }

    return $rel_path ;
}


#
# coderef - make URL from the text of a C<>
#
sub coderef($$){
    my( $page, $item ) = @@_;
    my( $url );

    my $fid = fragment_id( $item );
    
    if( defined( $page ) && $page ne "" ){
	# we have been given a $page...
	$page =~ s{::}{/}g;

        Carp::confess("Undefined fragment '$item' from fragment_id() in coderef() in $Podfile")
            if !defined $fid;    
	# Do we take it? Item could be a section!
	my $base = $Items{$fid} || "";
	$base =~ s{[^/]*/}{};
	if( $base ne "$page.html" ){
            ###   print STDERR "coderef( $page, $item ): items{$fid} = $Items{$fid} = $base => discard page!\n";
	    $page = undef();
	}

    } else {
        # no page - local items precede cached items
	if( defined( $fid ) ){
	    if(  exists $Local_Items{$fid} ){
		$page = $Local_Items{$fid};
	    } else {
		$page = $Items{$fid};
	    }
	}
    }

    # if there was a pod file that we found earlier with an appropriate
    # =item directive, then create a link to that page.
    if( defined $page ){
	if( $page ){
            if( exists $Pages{$page} and $Pages{$page} =~ /([^:.]*)\.[^:]*:/){
		$page = $1 . '.html';
	    }
	    my $link = "$Htmlroot/$page#" . anchorify($fid);

	    # Here, we take advantage of the knowledge that $Htmlfileurl
	    # ne '' implies $Htmlroot eq ''.
	    if (  $Htmlfileurl ne '' ) {
		$link = "$Htmldir$link" ;
		$url = relativize_url( $link, $Htmlfileurl ) ;
	    } else {
		$url = $link ;
	    }
	} else {
	    $url = "#" . anchorify($fid);
	}

	confess "url has space: $url" if $url =~ /"[^"]*\s[^"]*"/;
    }
    return( $url, $fid );
}



#
# Adapted from Nick Ing-Simmons' PodToHtml package.
sub relative_url {
    my $source_file = shift ;
    my $destination_file = shift;

    my $source = URI::file->new_abs($source_file);
    my $uo = URI::file->new($destination_file,$source)->abs;
    return $uo->rel->as_string;
}


#
# finish_list - finish off any pending HTML lists.  this should be called
# after the entire pod file has been read and converted.
#
sub finish_list {
    if( $Listlevel ){
	warn "$0: $Podfile: unterminated list(s) at =head in paragraph $Paragraph.  ignoring.\n" unless $Quiet;
	while( $Listlevel ){
            process_back();
        }
    }
}

#
# htmlify - converts a pod section specification to a suitable section
# specification for HTML. Note that we keep spaces and special characters
# except ", ? (Netscape problem) and the hyphen (writer's problem...).
#
sub htmlify {
    my( $heading) = @@_;
    $heading =~ s/(\s+)/ /g;
    $heading =~ s/\s+\Z//;
    $heading =~ s/\A\s+//;
    # The hyphen is a disgrace to the English language.
    # $heading =~ s/[-"?]//g;
    $heading =~ s/["?]//g;
    $heading = lc( $heading );
    return $heading;
}

#
# similar to htmlify, but turns non-alphanumerics into underscores
#
sub anchorify {
    my ($anchor) = @@_;
    $anchor = htmlify($anchor);
    $anchor =~ s/\W/_/g;
    return $anchor;
}

#
# depod - convert text by eliminating all interior sequences
# Note: can be called with copy or modify semantics
#
my %E2c;
$E2c{lt}     = '<';
$E2c{gt}     = '>';
$E2c{sol}    = '/';
$E2c{verbar} = '|';
$E2c{amp}    = '&'; # in Tk's pods

sub depod1($;$$);

sub depod($){
    my $string;
    if( ref( $_[0] ) ){
	$string =  ${$_[0]};
        ${$_[0]} = depod1( \$string );
    } else {
	$string =  $_[0];
        depod1( \$string );
    }
}

sub depod1($;$$){
  my( $rstr, $func, $closing ) = @@_;
  my $res = '';
  return $res unless defined $$rstr;
  if( ! defined( $func ) ){
      # skip to next begin of an interior sequence
      while( $$rstr =~ s/\A(.*?)([BCEFILSXZ])<(<+[^\S\n]+)?//s ){
         # recurse into its text
	  $res .= $1 . depod1( $rstr, $2, closing $3);
      }
      $res .= $$rstr;
  } elsif( $func eq 'E' ){
      # E<x> - convert to character
      $$rstr =~ s/^([^>]*)>//;
      $res .= $E2c{$1} || "";
  } elsif( $func eq 'X' ){
      # X<> - ignore
      $$rstr =~ s/^[^>]*>//;
  } elsif( $func eq 'Z' ){
      # Z<> - empty
      $$rstr =~ s/^>//;
  } else {
      # all others: either recurse into new function or
      # terminate at closing angle bracket
      my $term = pattern $closing;
      while( $$rstr =~ s/\A(.*?)(([BCEFILSXZ])<(<+[^\S\n]+)?|$term)//s ){
	  $res .= $1;
	  last unless $3;
          $res .= depod1( $rstr, $3, closing $4 );
      }
      ## If we're here and $2 ne '>': undelimited interior sequence.
      ## Ignored, as this is called without proper indication of where we are.
      ## Rely on process_text to produce diagnostics.
  }
  return $res;
}

{
    my %seen;   # static fragment record hash

sub fragment_id_readable {
    my $text     = shift;
    my $generate = shift;   # optional flag

    my $orig = $text;

    # leave the words for the fragment identifier,
    # change everything else to underbars.
    $text =~ s/[^A-Za-z0-9_]+/_/g; # do not use \W to avoid locale dependency.
    $text =~ s/_{2,}/_/g;
    $text =~ s/\A_//;
    $text =~ s/_\Z//;

    unless ($text)
    {
        # Nothing left after removing punctuation, so leave it as is
        # E.g. if option is named: "=item -#"

        $text = $orig;
    }

    if ($generate) {
        if ( exists $seen{$text} ) {
            # This already exists, make it unique
            $seen{$text}++;
            $text = $text . $seen{$text};
        } else {
            $seen{$text} = 1;  # first time seen this fragment
        }
    }

    $text;
}}

my @@HC;
sub fragment_id_obfuscated {  # This was the old "_2d_2d__"
    my $text     = shift;
    my $generate = shift;   # optional flag

    # text? Normalize by obfuscating the fragment id to make it unique
    $text =~ s/\s+/_/sg;

    $text =~ s{(\W)}{
        defined( $HC[ord($1)] ) ? $HC[ord($1)]
        : ( $HC[ord($1)] = sprintf( "%%%02X", ord($1) ) ) }gxe;
    $text = substr( $text, 0, 50 );

    $text;
}

#
# fragment_id - construct a fragment identifier from:
#   a) =item text
#   b) contents of C<...>
#

sub fragment_id {
    my $text     = shift;
    my $generate = shift;   # optional flag

    $text =~ s/\s+\Z//s;
    if( $text ){
	# a method or function?
	return $1 if $text =~ /(\w+)\s*\(/;
	return $1 if $text =~ /->\s*(\w+)\s*\(?/;

	# a variable name?
	return $1 if $text =~ /^([\$\@@%*]\S+)/;

	# some pattern matching operator?
	return $1 if $text =~ m|^(\w+/).*/\w*$|;

	# fancy stuff... like "do { }"
	return $1 if $text =~ m|^(\w+)\s*{.*}$|;

	# honour the perlfunc manpage: func [PAR[,[ ]PAR]...]
	# and some funnies with ... Module ...
	return $1 if $text =~ m{^([a-z\d_]+)(\s+[A-Z,/& ][A-Z\d,/& ]*)?$};
	return $1 if $text =~ m{^([a-z\d]+)\s+Module(\s+[A-Z\d,/& ]+)?$};

	return fragment_id_readable($text, $generate);
    } else {
	return;
    }
}

#
# make_URL_href - generate HTML href from URL
# Special treatment for CGI queries.
#
sub make_URL_href($){
    my( $url ) = @@_;
    if( $url !~
        s{^(http:[-\w/#~:.+=&%@@!]+)(\?.*)$}{<a href="$1$2">$1</a>}i ){
        $url = "<a href=\"$url\">$url</a>";
    }
    return $url;
}

1;
@


1.11
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.10
log
@Merge in perl 5.10.1
@
text
@d1578 3
a1580 1
	$escape =~ s/^(\d+|X[\dA-F]+)$/#$1/i;
@


1.9
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d6 1
a6 1
$VERSION = 1.08;
d249 2
a250 2
my($Listlevel, @@Listend);
my $After_Lpar;
d289 1
a289 1
    $Htmlfileurl = "" ;		# The url that other files would use to
d305 3
a307 2
    @@Listend = ();		# the text to use to end the list.
    $After_Lpar = 0;            # set to true after a par in an =item
a522 1
    my $need_dd = 0;
a529 1
	    $need_dd = 0;
d545 1
a545 1
		    $need_dd = process_item( $1 );
d550 1
a550 1
		    process_back($need_dd);
a564 1
	    print HTML "<dd>\n" if $need_dd;
d566 7
a601 3
		if( $after_item ){
		    $After_Lpar = 1;
		}
a603 1
	    print HTML "</dd>\n" if $need_dd;
d1078 1
a1078 1
	if ( $txt =~ /\A=item\s+\*\s*(.*)\Z/s ) { # bullet
d1083 1
a1083 1
	} elsif( $txt =~ /\A=item\s+(.*)\Z/s ) { # plain item
d1103 1
a1103 6
    if( $Listlevel ){
	warn "$0: $Podfile: unterminated list at =head in paragraph $Paragraph.  ignoring.\n" unless $Quiet;
        while( $Listlevel ){
            process_back();
        }
    }
d1142 1
a1142 1
    print HTML "</strong>\n";
d1146 1
a1146 1
sub emit_li {
d1148 6
d1155 2
a1156 1
	push( @@Listend, "</$tag>" );
d1158 7
d1166 2
a1167 3
    my $emitted = $tag eq 'dl' ? 'dt' : 'li';
    print HTML "<$emitted>";
    return $emitted;
a1174 1
    my $need_dd = 0; # set to 1 if we need a <dd></dd> after an item
a1183 6
    # formatting: insert a paragraph if preceding item has >1 paragraph
    if( $After_Lpar ){
	print HTML $need_dd ? "</dd>\n" : "</li>\n" if $After_Lpar;
	$After_Lpar = 0;
    }

a1186 2
    my $emitted; # the tag actually emitted, used for closing

d1189 1
a1189 1
        $emitted = emit_li( 'ul' );
d1194 1
d1198 1
a1198 1
        $emitted = emit_li( 'ol' );
d1203 1
d1207 2
a1208 1
        $emitted = emit_li( 'dl' );
d1211 2
d1214 3
a1216 1
        $need_dd = 1;
a1218 1
    return $need_dd;
a1227 1
    $After_Lpar = 0;
a1233 1
    my $need_dd = shift;
d1239 1
a1239 1
    # close off the list.  note, I check to see if $Listend[$Listlevel] is
d1241 1
a1241 1
    # $Listend[$Listlevel] may have never been initialized.
d1243 9
a1251 5
    if( defined $Listend[$Listlevel] ){
	print HTML $need_dd ? "</dd>\n" : "</li>\n" if $After_Lpar;
	print HTML $Listend[$Listlevel];
        print HTML "\n";
        pop( @@Listend );
a1252 1
    $After_Lpar = 0;
d2035 5
a2039 3
    while ($Listlevel > 0) {
	print HTML "</dl>\n";
	$Listlevel--;
@


1.8
log
@merge in perl 5.8.8
@
text
@d6 1
a6 1
$VERSION = 1.0504;
d35 1
a35 1
=head1 ARGUMENTS
d37 12
a48 1
Pod::Html takes the following arguments:
d201 11
a211 1
=head1 EXAMPLE
d213 2
a214 8
    pod2html("pod2html",
	     "--podpath=lib:ext:pod:vms",
	     "--podroot=/usr/src/perl",
	     "--htmlroot=/perl/nmanual",
	     "--libpods=perlfunc:perlguts:perlvar:perlrun:perlop",
	     "--recurse",
	     "--infile=foo.pod",
	     "--outfile=/perl/nmanual/foo.html");
a233 1

a268 1
my $PTQuote;
a318 1
    $PTQuote = 0;               # status of double-quote conversion
d500 19
a518 7
    print HTML "<p><a name=\"__index__\"></a></p>\n";
    print HTML "<!-- INDEX BEGIN -->\n";
    print HTML "<!--\n" unless $Doindex;
    print HTML $index;
    print HTML "-->\n" unless $Doindex;
    print HTML "<!-- INDEX END -->\n\n";
    print HTML "<hr />\n" if $Doindex and $index;
a524 2
        $PTQuote = 0; # status of quote conversion

d1132 3
a1134 2
    my $item = fragment_id( $text );

d1142 1
a1142 1
        my $name = 'item_' . $item;
d1144 1
a1144 1
	print HTML qq{<a name="$name">}, process_text( \$otext ), '</a>';
d1190 1
a1190 1
        if ($text =~ /\A\*\s+(.+)\Z/s ) { # with additional text
d1198 1
a1198 1
        if ($text =~ /\A(?>\d+\.?)\s*(.+)\Z/s ) { # with additional text
d1304 2
a1305 2
    if ($Begin_Stack[-1] ne $whom ) {
	die "Unmatched begin/end at chunk $Paragraph\n"
d1419 1
a1419 1
    process_puretext( $text, \$PTQuote, 1 );
d1424 1
a1424 1
    process_puretext( $text, \$PTQuote, 0 );
d1432 1
a1432 1
    my($text, $quote, $notinIS) = @@_;
a1439 7
    # convert double-quotes to single-quotes
    if( $$quote && $text =~ s/"/''/s ){
        $$quote = 0;
    }
    while ($text =~ s/"([^"]*)"/``$1''/sg) {};
    $$quote = 1 if $text =~ s/"/``/s;

d1451 18
a1468 2
	# see if we can infer a link
	if( $notinIS && $word =~ /^(\w+)\((.*)\)$/ ) {
d1471 1
a1471 1
            my( $func, $args ) = ( $1, $2 );
d1475 1
a1475 1
                    $word = "<a href=\"$url\">the $word manpage</a>";
d1480 1
a1480 1
            $word = emit_C( $func, '', "($args)");
d1514 2
a1515 2
sub pattern ($) { $_[0] ? '[^\S\n]+'.('>' x ($_[0] + 1)) : '>' }
sub closing ($) { local($_) = shift; (defined && s/\s+$//) ? length : 0 }
d1521 1
d1525 16
d1575 2
a1576 2
	# F<filename> - italizice
	$res = '<em>' . process_text1( $lev, $rstr ) . '</em>';
d1579 1
a1579 1
	# I<text> - italizice
d1616 5
a1620 1
            ( $page, $ident ) = ( $1, $2 );
d1708 2
a1709 2
	$$rstr =~ s/^[^>]*>//;

d1712 1
a1712 1
	warn "$0: $Podfile: invalid X<> in paragraph $Paragraph.\n"
d1730 4
a1733 2
	} else {
	    warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph.\n" unless $Quiet;
d1735 1
d1748 1
a1748 1
      s/\A(.*?)(([BCEFILSXZ])<(<+[^\S\n]+)?|@@{[pattern $closing[0]]})//s ){
d1758 4
a1761 1
    warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph.\n" unless $Quiet;
d1883 3
a1885 4
	    # check if there is a .pod with the page name
	    if ($Pages{$page} =~ /([^:]*)\.pod:/) {
		$link = "$Htmlroot/$1.html$section";
	    } elsif ($Pages{$page} =~ /([^:]*)\.pm:/) {
d1957 1
d1962 2
d1990 1
a1990 1
	    my $link = "$Htmlroot/$page#item_" . anchorify($fid);
d2001 1
a2001 1
	    $url = "#item_" . anchorify($fid);
d2045 2
a2046 1
    $heading =~ s/[-"?]//g;
d2091 1
a2091 1
      while( $$rstr =~ s/\A(.*?)([BCEFILSXZ])<(<+[^\S\n]+)?// ){
d2110 1
a2110 1
      while( $$rstr =~ s/\A(.*?)(([BCEFILSXZ])<(<+[^\S\n]+)?|$term)// ){
d2122 53
d2180 1
a2180 1
my @@HC;
d2182 3
a2184 1
    my $text = shift();
d2202 1
a2202 1
	return $1 if $text =~ m{^([a-z\d_]+)(\s+[A-Z\d,/& ]+)?$};
d2205 1
a2205 6
	# text? normalize!
	$text =~ s/\s+/_/sg;
	$text =~ s{(\W)}{
         defined( $HC[ord($1)] ) ? $HC[ord($1)]
                 : ( $HC[ord($1)] = sprintf( "%%%02X", ord($1) ) ) }gxe;
        $text = substr( $text, 0, 50 );
d2207 1
a2207 1
	return undef();
@


1.7
log
@merge local changes into perl-5.8.3
@
text
@d6 1
a6 1
$VERSION = 1.0502;
d465 1
d470 1
d529 1
a529 1
		    process_back();
d535 1
a535 1
		       . "paragraph $Paragraph.  ignoring.\n";
a575 1
		    print HTML "$text\n";
a576 2
		} else {
		    print HTML "<p>$text</p>\n";
d578 1
d640 1
a640 1
  --[no]quiet    - supress some benign warning messages (default is off).
d892 1
a892 1
	    warn "$0: shouldn't be here (line ".__LINE__."\n";
d962 13
d1081 1
a1081 1
	warn "$0: $Podfile: unterminated list at =head in paragraph $Paragraph.  ignoring.\n";
d1123 1
a1123 1
    print HTML "</strong><br />\n";
d1149 1
a1149 1
	warn "$0: $Podfile: unexpected =item directive in paragraph $Paragraph.  ignoring.\n";
d1155 1
a1155 1
	print HTML "<p></p>\n";
a1187 1
    print HTML "</$emitted>" if $emitted;
d1206 1
d1208 1
a1208 1
	warn "$0: $Podfile: unexpected =back directive in paragraph $Paragraph.  ignoring.\n";
d1217 1
a1217 1
	print HTML '<p></p>' if $After_Lpar;
d1411 1
a1411 1
    ## Guessing at func() or [$@@%&]*var references in plain text is destined
d1637 1
a1637 1
            warn "$0: $Podfile: cannot resolve L<$opar> in paragraph $Paragraph.\n";
d1660 1
a1660 1
	    unless $$rstr =~ s/^>//;
d1678 1
a1678 1
	    warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph.\n";
d1702 1
a1702 1
    warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph.\n";
d1899 1
a1899 1
    if( defined( $page ) ){
d2075 1
a2075 1
	return $1 if $text =~ /^([$@@%*]\S+)/;
d2085 1
a2085 1
	return $1 if $text =~ m{^([a-z\d]+)(\s+[A-Z\d,/& ]+)?$};
@


1.6
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d6 1
a6 1
$VERSION = 1.0501;
d81 14
d230 1
d622 1
d655 1
a655 1
	$opt_recurse,$opt_title,$opt_verbose);
d665 1
d696 1
d942 3
a944 1
	if (-d "$dir/$_" && $_ ne "." && $_ ne "..") {	    # directory
@


1.5
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d5 2
a6 2
use vars qw($VERSION @@ISA @@EXPORT);
$VERSION = 1.04;
d9 1
a204 5
my $cachedir = ".";		# The directory to which item and directory
				# caches will be written.
my $cache_ext = $^O eq 'VMS' ? ".tmp" : ".x~~";
my $dircache = "pod2htmd$cache_ext";
my $itemcache = "pod2htmi$cache_ext";
d206 23
a228 1
my @@begin_stack = ();		# begin/end stack
d230 1
a230 26
my @@libpods = ();	    	# files to search for links from C<> directives
my $htmlroot = "/";	    	# http-server base directory from which all
				#   relative paths in $podpath stem.
my $htmldir = "";		# The directory to which the html pages
				# will (eventually) be written.
my $htmlfile = "";		# write to stdout by default
my $htmlfileurl = "" ;		# The url that other files would use to
				# refer to this file.  This is only used
				# to make relative urls that point to
				# other files.
my $podfile = "";		# read from stdin by default
my @@podpath = ();		# list of directories containing library pods.
my $podroot = File::Spec->curdir;		# filesystem base directory from which all
				#   relative paths in $podpath stem.
my $css = '';                   # Cascading style sheet
my $recurse = 1;		# recurse on subdirectories in $podpath.
my $quiet = 0;			# not quiet by default
my $verbose = 0;		# not verbose by default
my $doindex = 1;   	    	# non-zero if we should generate an index
my $backlink = '';              # text for "back to top" links
my $listlevel = 0;		# current list depth
my @@listend = ();		# the text to use to end the list.
my $after_lpar = 0;             # set to true after a par in an =item
my $ignore = 1;			# whether or not to format text.  we don't
				#   format text until we hit our first pod
				#   directive.
d232 2
a233 10
my %items_named = ();		# for the multiples of the same item in perlfunc
my @@items_seen = ();
my $title;			# title to give the pod(s)
my $header = 0;			# produce block header/footer
my $top = 1;			# true if we are at the top of the doc.  used
				#   to prevent the first <hr /> directive.
my $paragraph;			# which paragraph we're processing (used
				#   for error messages)
my $ptQuote = 0;                # status of double-quote conversion
my %pages = ();			# associative array used to find the location
d235 1
a235 2
my %sections = ();		# sections within this page
my %items = ();			# associative array used to find the location
d237 8
a244 2
my %local_items = ();           # local items - avoid destruction of %items
my $Is83;                       # is dos with short filenames (8.3)
d247 5
a251 2
$dircache = "pod2htmd$cache_ext";
$itemcache = "pod2htmi$cache_ext";
d253 1
a253 1
@@begin_stack = ();		# begin/end stack
d255 2
a256 2
@@libpods = ();	    	# files to search for links from C<> directives
$htmlroot = "/";	    	# http-server base directory from which all
d258 1
a258 1
$htmldir = "";	    	# The directory to which the html pages
d260 9
a268 4
$htmlfile = "";		# write to stdout by default
$podfile = "";		# read from stdin by default
@@podpath = ();		# list of directories containing library pods.
$podroot = File::Spec->curdir;		# filesystem base directory from which all
d270 10
a279 10
$css = '';                   # Cascading style sheet
$recurse = 1;		# recurse on subdirectories in $podpath.
$quiet = 0;		# not quiet by default
$verbose = 0;		# not verbose by default
$doindex = 1;   	    	# non-zero if we should generate an index
$backlink = '';		# text for "back to top" links
$listlevel = 0;		# current list depth
@@listend = ();		# the text to use to end the list.
$after_lpar = 0;        # set to true after a par in an =item
$ignore = 1;			# whether or not to format text.  we don't
d283 5
a287 5
@@items_seen = ();
%items_named = ();
$header = 0;			# produce block header/footer
$title = '';			# title to give the pod(s)
$top = 1;			# true if we are at the top of the doc.  used
d289 1
a289 1
$paragraph = '';			# which paragraph we're processing (used
d291 2
a292 1
%sections = ();		# sections within this page
d294 2
a295 8
# These are not reinitialised here but are kept as a cache.
# See get_cache and related cache management code.
#%pages = ();			# associative array used to find the location
				#   of pages referenced by L<> links.
#%items = ();			# associative array used to find the location
				#   of =item directives referenced by C<> links
%local_items = ();
$Is83=$^O eq 'dos';
d324 1
a324 1
    # cache of %pages and %items from last time we ran pod2html
d332 1
a332 1
    $backlink = html_escape($backlink) if defined $backlink;
d337 3
a339 3
	$podfile  = "-" unless $podfile;	# stdin
	open(POD, "<$podfile")
		|| die "$0: cannot open $podfile file for input: $!\n";
d341 1
a341 1
	$podfile = $ARGV[0];  # XXX: might be more filenames
d344 7
a350 7
    $htmlfile = "-" unless $htmlfile;	# stdout
    $htmlroot = "" if $htmlroot eq "/";	# so we don't get a //
    $htmldir =~ s#/\z## ;               # so we don't get a //
    if (  $htmlroot eq ''
       && defined( $htmldir )
       && $htmldir ne ''
       && substr( $htmlfile, 0, length( $htmldir ) ) eq $htmldir
d357 1
a357 1
        $htmlfileurl= "$htmldir/" . substr( $htmlfile, length( $htmldir ) + 1);
d361 1
a361 1
    warn "Scanning for sections in input file(s)\n" if $verbose;
d387 1
a387 1
    my $index = scan_headings(\%sections, @@poddata);
d390 1
a390 1
	warn "No headings in $podfile\n" if $verbose;
d394 2
a395 2
    open(HTML, ">$htmlfile")
	    || die "$0: cannot open $htmlfile file for output: $!\n";
d398 1
a398 1
    if ($title eq '') {
d404 1
a404 1
			    if ($title) = $para =~ /(\S+\s+-+.*\S)/s;
d411 1
a411 1
    if (!$title and $podfile =~ /\.pod\z/) {
d414 1
a414 1
	    last if ($title) = $poddata[$i] =~ /^=head[12]\s*(.*)/;
d416 2
a417 2
	warn "adopted '$title' as title for $podfile\n"
	    if $verbose and $title;
d419 2
a420 2
    if ($title) {
	$title =~ s/\s*\(.*\)//;
d422 4
a425 4
	warn "$0: no title for $podfile.\n" unless $quiet;
	$podfile =~ /^(.*)(\.[^.\/]+)?\z/s;
	$title = ($podfile eq "-" ? 'No Title' : $1);
	warn "using $title" if $verbose;
d427 1
a427 1
    $title = html_escape($title);
d433 2
a434 2
    if ($css) {
      $csslink = qq(\n<link rel="stylesheet" href="$css" type="text/css" />);
d441 1
a441 1
      my $block = $header ? <<END_OF_BLOCK : '';
d444 1
a444 1
<big><strong><span class="block">&nbsp;$title</span></strong></big>
d453 1
a453 1
<title>$title</title>$csslink
d461 2
a462 2
    # load/reload/validate/cache %pages and %items
    get_cache($dircache, $itemcache, \@@podpath, $podroot, $recurse);
d465 1
a465 1
    scan_items( \%local_items, "", @@poddata);
d467 1
a467 1
    # put an index at the top of the file.  note, if $doindex is 0 we
d473 1
a473 1
    print HTML "<!--\n" unless $doindex;
d475 1
a475 1
    print HTML "-->\n" unless $doindex;
d477 1
a477 1
    print HTML "<hr />\n" if $doindex and $index;
d482 1
a482 1
    warn "Converting input file $podfile\n" if $verbose;
d484 1
a484 1
        $ptQuote = 0; # status of quote conversion
d487 1
a487 1
	$paragraph = $i+1;
d489 1
a489 1
	    $ignore = 0;
d502 1
a502 1
		next if @@begin_stack && $begin_stack[-1] ne 'html';
d505 1
a505 1
		    process_head( $1, $2, $doindex && $index );
d517 2
a518 2
		    warn "$0: $podfile: unknown pod directive '$1' in "
		       . "paragraph $paragraph.  ignoring.\n";
d521 1
a521 1
	    $top = 0;
d524 3
a526 3
	    next if $ignore;
	    next if @@begin_stack && $begin_stack[-1] ne 'html';
	    print HTML and next if @@begin_stack && $begin_stack[-1] eq 'html';
d560 1
a560 1
		    $after_lpar = 1;
d574 2
a575 2
    print HTML "<p><a href=\"#__index__\"><small>$backlink</small></a></p>\n"
	if $doindex and $index and $backlink;
d587 1
a587 1
    warn "Finished\n" if $verbose;
a591 1
my $usage;			# see below
d595 1
a595 4
    die $usage;
}

$usage =<<END_OF_USAGE;
d633 2
d668 2
a669 2
    @@podpath  = split(":", $opt_podpath) if defined $opt_podpath;
    @@libpods  = split(":", $opt_libpods) if defined $opt_libpods;
d671 14
a684 14
    $backlink = $opt_backlink if defined $opt_backlink;
    $cachedir = $opt_cachedir if defined $opt_cachedir;
    $css      = $opt_css      if defined $opt_css;
    $header   = $opt_header   if defined $opt_header;
    $htmldir  = $opt_htmldir  if defined $opt_htmldir;
    $htmlroot = $opt_htmlroot if defined $opt_htmlroot;
    $doindex  = $opt_index    if defined $opt_index;
    $podfile  = $opt_infile   if defined $opt_infile;
    $htmlfile = $opt_outfile  if defined $opt_outfile;
    $podroot  = $opt_podroot  if defined $opt_podroot;
    $quiet    = $opt_quiet    if defined $opt_quiet;
    $recurse  = $opt_recurse  if defined $opt_recurse;
    $title    = $opt_title    if defined $opt_title;
    $verbose  = $opt_verbose  if defined $opt_verbose;
d688 5
a692 3
    $dircache = "$cachedir/pod2htmd$cache_ext";
    $itemcache = "$cachedir/pod2htmi$cache_ext";
    unlink($dircache, $itemcache) if defined $opt_flush;
d696 1
a696 1
my $saved_cache_key;
d708 1
a708 1
    return if $saved_cache_key and $this_cache_key eq $saved_cache_key;
d710 1
a710 1
    # load the cache of %pages and %items if possible.  $tests will be
d714 1
a714 1
	warn "scanning for item cache\n" if $verbose;
d719 1
a719 1
    #  %pages and %items.
d721 1
a721 1
	warn "scanning directories in pod-path\n" if $verbose;
d724 1
a724 1
    $saved_cache_key = cache_key(@@cache_key_args);
d735 1
a735 1
#  are valid caches of %pages and %items.  if they are valid then it loads
d765 1
a765 1
    warn "loading item cache\n" if $verbose;
d768 1
a768 1
	$items{$1} = $2;
d772 1
a772 1
    warn "scanning for directory cache\n" if $verbose;
d794 1
a794 1
    warn "loading directory cache\n" if $verbose;
d797 1
a797 1
	$pages{$1} = $2;
d808 1
a808 1
#  @@libpods for =item directives.
d816 2
a817 2
	%items = ();
	%pages = ();
d820 1
a820 1
    # scan each directory listed in @@podpath
d824 1
a824 1
    foreach $dir (@@podpath) {
d828 2
a829 2
    # scan the pods listed in @@libpods for =item directives
    foreach $libpod (@@libpods) {
d832 1
a832 1
	next unless defined $pages{$libpod} && $pages{$libpod};
d836 2
a837 2
#	if ($pages{$libpod} =~ /([^:]*[^(\.pod|\.pm)]):/) {
	if ($pages{$libpod} =~ /([^:]*(?<!\.pod)(?<!\.pm)):/) {
d853 1
a853 1
		scan_items( \%items, "$dirname/$pod", @@poddata);
d860 1
a860 1
###		$items{$1} = "$dirname/$1.html" if $1;
d862 2
a863 2
	} elsif ($pages{$libpod} =~ /([^:]*\.pod):/ ||
		 $pages{$libpod} =~ /([^:]*\.pm):/) {
d872 1
a872 1
	    scan_items( \%items, "$pod", @@poddata);
d883 7
a889 7
    warn "caching items for later use\n" if $verbose;
    open(CACHE, ">$itemcache") ||
	die "$0: error open $itemcache for writing: $!\n";

    print CACHE join(":", @@podpath) . "\n$podroot\n";
    foreach my $key (keys %items) {
	print CACHE "$key $items{$key}\n";
d895 7
a901 7
    warn "caching directories for later use\n" if $verbose;
    open(CACHE, ">$dircache") ||
	die "$0: error open $dircache for writing: $!\n";

    print CACHE join(":", @@podpath) . "\n$podroot\n";
    foreach my $key (keys %pages) {
	print CACHE "$key $pages{$key}\n";
d925 2
a926 2
	    $pages{$_}  = "" unless defined $pages{$_};
	    $pages{$_} .= "$dir/$_:";
d930 2
a931 2
	    $pages{$_}  = "" unless defined $pages{$_};
	    $pages{$_} .= "$dir/$_.pod:";
d935 2
a936 2
	    $pages{$_}  = "" unless defined $pages{$_};
	    $pages{$_} .= "$dir/$_.pod:";
d939 2
a940 2
	    $pages{$_}  = "" unless defined $pages{$_};
	    $pages{$_} .= "$dir/$_.pm:";
d962 1
a962 3
    # here we need	local $ignore = 0;
    #  unfortunately, we can't have it, because $ignore is lexical
    $ignore = 0;
a1001 2
    $ignore = 1;	# restore old value;

d1047 3
a1049 3
    if( $listlevel ){
	warn "$0: $podfile: unterminated list at =head in paragraph $paragraph.  ignoring.\n";
        while( $listlevel ){
d1055 3
a1057 3
    if( $level == 1 && ! $top ){
      print HTML "<a href=\"#__index__\"><small>$backlink</small></a>\n"
        if $hasindex and $backlink;
d1083 1
a1083 1
    if ($items_named{$item}++) {
d1096 2
a1097 2
    if( $items_seen[$listlevel]++ == 0 ){
	push( @@listend, "</$tag>" );
d1115 2
a1116 2
    if( $listlevel == 0 ){
	warn "$0: $podfile: unexpected =item directive in paragraph $paragraph.  ignoring.\n";
d1121 1
a1121 1
    if( $after_lpar ){
d1123 1
a1123 1
	$after_lpar = 0;
d1165 3
a1167 3
    $listlevel++;
    push( @@items_seen, 0 );
    $after_lpar = 0;
d1174 2
a1175 2
    if( $listlevel == 0 ){
	warn "$0: $podfile: unexpected =back directive in paragraph $paragraph.  ignoring.\n";
d1179 1
a1179 1
    # close off the list.  note, I check to see if $listend[$listlevel] is
d1181 5
a1185 5
    # $listend[$listlevel] may have never been initialized.
    $listlevel--;
    if( defined $listend[$listlevel] ){
	print HTML '<p></p>' if $after_lpar;
	print HTML $listend[$listlevel];
d1187 1
a1187 1
        pop( @@listend );
d1189 1
a1189 1
    $after_lpar = 0;
d1192 1
a1192 1
    pop( @@items_seen );
d1199 1
a1199 1
    $ignore = 1;
d1207 1
a1207 1
    # no need to set $ignore to 0 cause the main loop did it
d1235 1
a1235 1
    push (@@begin_stack, $whom);
d1248 2
a1249 2
    if ($begin_stack[-1] ne $whom ) {
	die "Unmatched begin/end at chunk $paragraph\n"
d1251 1
a1251 1
    pop( @@begin_stack );
d1260 1
a1260 1
    return if $ignore;
d1279 4
a1282 4
		 if ( defined $pages{$2} ){	# is a link
		     qq($1<a href="$htmlroot/$pages{$2}">$2</a>);
		 } elsif (defined $pages{dosify($2)}) {	# is a link
		     qq($1<a href="$htmlroot/$pages{dosify($2)}">$2</a>);
d1291 1
a1291 1
                  if ( $htmlfileurl ne '' ){
d1293 2
a1294 2
		     # that $htmlfileurl ne '' implies $htmlroot eq ''.
		     # Since $htmlroot eq '', we need to prepend $htmldir
d1299 2
a1300 2
		     $old_url = "$htmldir$old_url" if $old_url =~ m{^\/};
 		     $url = relativize_url( "$old_url.html", $htmlfileurl );
d1328 19
a1346 17
        \b                          # start at word boundary
        (                           # begin $1  {
          $urls     :               # need resource and a colon
	  (?!:)                     # Ignore File::, among others.
          [$any] +?                 # followed by one or more of any valid
                                    #   character, but be conservative and
                                    #   take only what you need to....
        )                           # end   $1  }
        (?=                         # look-ahead non-consumptive assertion
                [$punc]*            # either 0 or more punctuation
                (?:                 #   followed
                    [^$any]         #   by a non-url char
                    |               #   or
                    $               #   end of the string
                )                   #
            |                       # or else
                $                   #   then end of the string
d1363 1
a1363 1
    process_puretext( $text, \$ptQuote, 1 );
d1368 1
a1368 1
    process_puretext( $text, \$ptQuote, 0 );
d1453 1
a1453 1
    return if $ignore;
d1604 1
a1604 1
            warn "$0: $podfile: cannot resolve L<$opar> in paragraph $paragraph.\n";
d1626 1
a1626 1
	warn "$0: $podfile: invalid X<> in paragraph $paragraph.\n"
d1645 1
a1645 1
	    warn "$0: $podfile: undelimited $func<> in paragraph $paragraph.\n";
d1669 1
a1669 1
    warn "$0: $podfile: undelimited $func<> in paragraph $paragraph.\n";
d1734 1
a1734 1
    if (!defined $pages{$page} && defined $sections{$page}) {
d1741 1
a1741 1
    $page=$page83 if (defined $pages{$page83});
d1752 2
a1753 2
	if ( defined( $pages{ $page_name } ) &&
	     $pages{ $page_name } =~ /([^:]*$page)\.(?:pod|pm):/
d1759 3
a1761 3
	    # $htmlroot/A/B.html . This is often incorrect, since they are
	    # often in $htmlroot/lib/A/B.html or such like. Perhaps we could
	    # analyze the contents of %pages and figure out where any
d1769 1
a1769 1
	$link = "$htmlroot/$page.html";
d1771 1
a1771 1
    } elsif (!defined $pages{$page}) {
d1779 3
a1781 3
#	if ($section ne "" && $pages{$page} =~ /([^:]*[^(\.pod|\.pm)]):/) {
	if ($section ne "" && $pages{$page} =~ /([^:]*(?<!\.pod)(?<!\.pm)):/) {
	    $link = "$htmlroot/$1/$section.html";
d1792 4
a1795 4
	    if ($pages{$page} =~ /([^:]*)\.pod:/) {
		$link = "$htmlroot/$1.html$section";
	    } elsif ($pages{$page} =~ /([^:]*)\.pm:/) {
		$link = "$htmlroot/$1.html$section";
d1803 3
a1805 3
	# Here, we take advantage of the knowledge that $htmlfileurl ne ''
	# implies $htmlroot eq ''. This means that the link in question
	# needs a prefix of $htmldir if it begins with '/'. The test for
d1809 4
a1812 4
        if (  $htmlfileurl ne '' ) {
            $link = "$htmldir$link" if $link =~ m{^/}s;
            $url = relativize_url( $link, $htmlfileurl );
# print( "  b: [$link,$htmlfileurl,$url]\n" );
d1871 1
a1871 1
	my $base = $items{$fid} || "";
d1874 1
a1874 1
            ###   print STDERR "coderef( $page, $item ): items{$fid} = $items{$fid} = $base => discard page!\n";
d1881 2
a1882 2
	    if(  exists $local_items{$fid} ){
		$page = $local_items{$fid};
d1884 1
a1884 1
		$page = $items{$fid};
d1893 1
a1893 1
            if( exists $pages{$page} and $pages{$page} =~ /([^:.]*)\.[^:]*:/){
d1896 1
a1896 1
	    my $link = "$htmlroot/$page#item_" . anchorify($fid);
d1898 5
a1902 5
	    # Here, we take advantage of the knowledge that $htmlfileurl
	    # ne '' implies $htmlroot eq ''.
	    if (  $htmlfileurl ne '' ) {
		$link = "$htmldir$link" ;
		$url = relativize_url( $link, $htmlfileurl ) ;
d1934 1
a1934 1
    while ($listlevel > 0) {
d1936 1
a1936 1
	$listlevel--;
d1957 1
a1957 1
# similar to htmlify, but turns spaces into underscores
d1962 1
a1962 1
    $anchor =~ s/\s/_/g; # fixup spaces left by htmlify
d2032 1
a2032 1
my @@hc;
d2058 2
a2059 2
         defined( $hc[ord($1)] ) ? $hc[ord($1)]
                 : ( $hc[ord($1)] = sprintf( "%%%02X", ord($1) ) ) }gxe;
@


1.4
log
@merge in perl 5.6.1 with our local changes
@
text
@d6 1
a6 1
$VERSION = 1.03;
d13 1
a15 1
use Pod::Functions;
d44 8
a51 2
Adds "Back to Top" links in front of every HEAD1 heading (except for
the first).  By default, no backlink are being generated.
d57 2
a58 1
Specify the URL of a cascading style sheet.
d71 2
a72 2
Creates header and footer blocks containing the text of the NAME
section.  By default, no headers are being generated.
d122 1
a122 2
Use Netscape HTML directives when applicable.  By default, they will
B<not> be used.
d136 1
a136 1
HTML converted forms can be linked-to in cross-references.
d178 1
a178 1
	     "--podpath=lib:ext:pod:vms", 
d188 1
a188 1
Uses $Config{pod2html} to setup default options.
d204 2
d224 1
a224 1
my $podroot = ".";		# filesystem base directory from which all
a240 1
my $netscape = 0;		# whether or not to use netscape directives.
d244 1
a244 1
				#   to prevent the first <HR> directive.
d270 1
a270 1
$podroot = ".";		# filesystem base directory from which all
a286 1
$netscape = 0;		# whether or not to use netscape directives.
d290 1
a290 1
				#   to prevent the first <HR> directive.
d310 1
a310 2
    my $i;
    for( $i = 0; $i <= $#$dataref; $i++ ){
d314 1
a314 1
	if( ${$dataref}[$i] =~ /^\s+$/m ){
d338 3
d343 1
a343 1
    unless (@@ARGV && $ARGV[0]) { 
d350 1
a350 1
    } 
d355 1
a355 1
       && defined( $htmldir ) 
d357 2
a358 2
       && substr( $htmlfile, 0, length( $htmldir ) ) eq $htmldir 
       ) 
d361 1
a361 1
	# as the location from which to calculate relative links 
d372 19
d407 1
a407 1
	    for (my $i = 0; $i < @@poddata; $i++) { 
d409 1
a409 1
		    for my $para ( @@poddata[$i, $i+1] ) { 
d413 1
a413 1
		} 
d415 1
a415 1
	    } 
d420 1
a420 1
	for (my $i = 0; $i < @@poddata; $i++) { 
d422 1
a422 1
	} 
d425 1
a425 1
    } 
d429 1
a429 1
	warn "$0: no title for $podfile" unless $quiet;
d434 20
a453 10
    my $csslink = $css ? qq(\n<LINK REL="stylesheet" HREF="$css" TYPE="text/css">) : '';
    $csslink =~ s,\\,/,g;
    $csslink =~ s,(/.):,$1|,;

    my $block = $header ? <<END_OF_BLOCK : '';
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;$title</P></STRONG></FONT>
</TD></TR>
</TABLE>
d457 6
a462 5
<HTML>
<HEAD>
<TITLE>$title</TITLE>$csslink
<LINK REV="made" HREF="mailto:$Config{perladmin}">
</HEAD>
d464 1
a464 1
<BODY>
d478 1
a478 1
    print HTML "<A NAME=\"__index__\"></A>\n";
d484 1
a484 1
    print HTML "<HR>\n" if $doindex and $index;
d488 1
d498 1
d514 1
a514 3
		    warn "$0: $podfile: =item without bullet, number or text"
		       . " in paragraph $paragraph.\n" if !defined($1) or $1 eq '';
		    process_item( $1 );
d533 2
d538 1
a538 1
	        print HTML "<PRE>\n$text</PRE>\n";
d556 4
a559 4
			    $text =~ s/\t+/<TD>/g;
			    $text =~ s/^/<TR><TD>/gm;
			    $text = '<TABLE CELLSPACING=0 CELLPADDING=0>' .
                                    $text . '</TABLE>';
d569 1
a569 1
		    print HTML "<P>$text</P>\n";
d572 1
d581 1
a581 1
    print HTML "<P><A HREF=\"#__index__\"><SMALL>$backlink</SMALL></A></P>\n"
d586 1
a586 1
</BODY>
d588 1
a588 1
</HTML>
d610 1
a610 1
           --netscape --norecurse --noindex
d613 1
a628 2
  --[no]netscape - will use netscape html directives when applicable.
                   (default is not to use them).
d640 1
d645 4
a648 4
    my ($opt_backlink,$opt_css,$opt_flush,$opt_header,$opt_help,$opt_htmldir,
	$opt_htmlroot,$opt_index,$opt_infile,$opt_libpods,$opt_netscape,
	$opt_outfile,$opt_podpath,$opt_podroot,$opt_quiet,$opt_recurse,
	$opt_title,$opt_verbose);
d653 1
d681 1
a687 1
    $netscape = $opt_netscape if defined $opt_netscape;
d697 2
d979 2
a980 2
	if ($line =~ /^=(head)([1-6])\s+(.*)/) {
	    ($tag, $which_head, $otitle) = ($1,$2,$3);
d982 4
a985 4
            my $title = depod( $otitle );
            my $name = htmlify( $title );
	    $$sections{$name} = 1;
	    $title = process_text( \$otitle );
d989 1
a989 1
		    $index .= "\n" . ("\t" x $listdepth) . "<UL>\n";
d993 1
a993 1
		    $index .= "\n" . ("\t" x $listdepth) . "</UL>\n";
d997 3
a999 3
	    $index .= "\n" . ("\t" x $listdepth) . "<LI>" .
	              "<A HREF=\"#" . $name . "\">" .
		      $title . "</A></LI>";
d1005 1
a1005 1
	$index .= "\n" . ("\t" x $listdepth) . "</UL>\n";
d1009 1
a1009 1
    $index =~ s,\t*<UL>\s*</UL>\n,,g;
d1065 1
a1065 1
    print HTML "<P>\n";
d1067 5
a1071 3
	print HTML "<A HREF=\"#__index__\"><SMALL>$backlink</SMALL></A>\n"
	    if $hasindex and $backlink;
	print HTML "<HR>\n"
d1074 1
a1074 1
    my $name = htmlify( depod( $heading ) );
d1076 1
a1076 1
    print HTML "<H$level><A NAME=\"$name\">$convert</A></H$level>\n";
d1093 1
a1093 1
    print HTML '<STRONG>';
d1097 3
a1099 2
	my $name = 'item_' . $item;
	print HTML qq{<A NAME="$name">}, process_text( \$otext ), '</A>';
d1101 1
a1101 1
    print HTML "</STRONG><BR>\n";
d1111 3
a1113 1
    print HTML $tag eq 'DL' ? '<DT>' : '<LI>';
d1121 1
d1133 1
a1133 1
	print HTML "<P></P>\n";
d1140 2
d1144 6
a1149 6
        emit_li( 'UL' );
	if ($text =~ /\A\*\s+(.+)\Z/s ) { # with additional text
	    my $tag = $1;
	    $otext =~ s/\A\*\s+//;
	    emit_item_tag( $otext, $tag, 1 );
	}
d1152 6
a1157 6
	emit_li( 'OL' );
	if ($text =~ /\A(?>\d+\.?)\s*(.+)\Z/s ) { # with additional text
	    my $tag = $1;
	    $otext =~ s/\A\d+\.?\s*//;
	    emit_item_tag( $otext, $tag, 1 );
	}
d1160 5
a1164 5
	emit_li( 'DL' );
	if ($text =~ /\A(.+)\Z/s ){ # should have text
	    emit_item_tag( $otext, $text, 1 );
	}
       print HTML '<DD>';
d1166 1
d1168 1
d1195 1
a1195 1
	print HTML '<P></P>' if $after_lpar;
d1214 1
a1214 1
# process_pod - process a pod pod tag, thus stop ignoring pod directives
d1234 1
a1234 1
        print HTML qq{<p align = "center"><img src = "$text" alt = "$text illustration"></p>};
d1261 1
a1261 1
    } 
d1266 1
a1266 1
# process_pre - indented paragraph, made into <PRE></PRE>
d1276 3
a1278 3
    $rest =~ s#.*#
	    my $line = $&;
	    1 while $line =~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;
d1283 1
a1283 4
    $rest =~ s/&/&amp;/g;
    $rest =~ s/</&lt;/g;
    $rest =~ s/>/&gt;/g;
    $rest =~ s/"/&quot;/g;
d1291 1
a1291 1
		     qq($1<A HREF="$htmlroot/$pages{$2}">$2</A>);
d1293 1
a1293 1
		     qq($1<A HREF="$htmlroot/$pages{dosify($2)}">$2</A>);
d1299 1
a1299 1
		 (<A\ HREF="?) ([^>:]*:)? ([^>:]*) \.pod: ([^>:]*:)?
d1303 1
a1303 1
		     # Here, we take advantage of the knowledge 
d1330 1
a1330 1
            } ) 
d1332 1
a1332 1
  
d1335 1
a1335 1
    my $punc = '.:?\-';
d1343 3
a1345 4
          [$any] +?                 # followed by on or more
                                    #  of any valid character, but
                                    #  be conservative and take only
                                    #  what you need to....
d1348 6
a1353 2
                [$punc]*            # either 0 or more puntuation
                [^$any]             #   followed by a non-url char
d1357 1
a1357 1
      }{<A HREF="$1">$1</A>}igox;
d1419 1
a1419 1
                    $word = "<A HREF=\"$url\">the $word manpage</A>";
d1434 1
a1434 1
	    $word = qq(<A HREF="$word">$word</A>);
d1440 2
a1441 5
	    $word = qq($w1<A HREF="mailto:$w2">$w2</A>$w3);
	} elsif ($word !~ /[a-z]/ && $word =~ /[A-Z]/) {  # all uppercase?
	    $word = html_escape($word) if $word =~ /["&<>]/;
	    $word = "\n<FONT SIZE=-1>$word</FONT>" if $netscape;
	} else { 
d1479 1
a1479 1
	$res = '<STRONG>' . process_text1( $lev, $rstr ) . '</STRONG>';
d1482 1
a1482 1
	# C<code> - can be a ref or <CODE></CODE>
d1490 1
a1490 1
        ### print STDERR "-->call emit_C($par) lev=$lev, par with BI=$x\n"; 
d1503 1
a1503 1
	$res = '<EM>' . process_text1( $lev, $rstr ) . '</EM>';
d1507 1
a1507 1
	$res = '<EM>' . process_text1( $lev, $rstr ) . '</EM>';
d1511 1
a1511 1
	## L<text|cross-ref> => produce text, use cross-ref for linking 
d1534 1
a1534 1
    
d1542 1
a1542 1
            # we've got a name/ident (no quotes) 
d1593 1
a1593 1
            ## no luck: go for an ident 
d1613 1
a1613 1
            warn "$0: $podfile: cannot resolve L<$opar> in paragraph $paragraph.";
d1616 1
a1616 1
        # now we have an URL or just plain code
d1619 1
a1619 1
            $res = "<A HREF=\"$url\">" . process_text1( $lev, $rstr ) . '</A>';
d1621 1
a1621 1
	    $res = '<EM>' . process_text1( $lev, $rstr ) . '</EM>';
d1634 2
a1635 2
	# Z<> - empty 
	warn "$0: $podfile: invalid X<> in paragraph $paragraph."
d1654 1
a1654 1
	    warn "$0: $podfile: undelimited $func<> in paragraph $paragraph.";
d1678 1
a1678 1
    warn "$0: $podfile: undelimited $func<> in paragraph $paragraph.";
d1697 1
a1697 1
	$res = "<A HREF=\"$url\"><CODE>$linktext</CODE></A>";
d1701 1
a1701 1
	$res = "<CODE>$linktext</CODE>";
d1715 2
d1718 1
a1718 1
} 
d1736 1
a1736 1
# page_sect - make an URL from the text of a L<>
d1752 1
a1752 1
	$link = "#" . htmlify( $section );
d1761 2
a1762 2
	if ( defined( $pages{ $page_name } ) && 
	     $pages{ $page_name } =~ /([^:]*$page)\.(?:pod|pm):/ 
d1779 1
a1779 1
	$link .= "#" . htmlify( $section ) if ($section);
d1783 1
a1783 1
	$section = htmlify( $section ) if $section ne "";
d1840 1
a1840 1
    my ($dest_volume,$dest_directory,$dest_file) = 
d1844 1
a1844 1
    my ($source_volume,$source_directory,$source_file) = 
d1853 1
a1853 1
    if ( $rel_path ne ''                && 
d1855 1
a1855 1
         substr( $dest_file, 0, 1 ) ne '#' 
d1905 1
a1905 1
	    my $link = "$htmlroot/$page#item_$fid";
d1916 1
a1916 1
	    $url = "#item_" . $fid;
d1920 1
a1920 1
    }       
d1944 1
a1944 1
	print HTML "</DL>\n";
d1966 10
d1996 1
a1996 1
    }    
d2018 1
a2018 1
      # Z<> - empty 
d2081 3
a2083 3
    if( $url !~ 
        s{^(http:[-\w/#~:.+=&%@@!]+)(\?.*)$}{<A HREF="$1$2">$1</A>}i ){
        $url = "<A HREF=\"$url\">$url</A>";
@


1.3
log
@perl-5.6.0 + local changes
@
text
@d896 4
d1445 4
a1448 2
	$$rstr =~ s/^(\w+)>//;
	$res = "&$1;";
d1949 1
a1949 1
      $$rstr =~ s/^(\w+)>//;
@


1.2
log
@perl5.005_03 (stock)
@
text
@d2 2
d5 3
a7 6
use Pod::Functions;
use Getopt::Long;	# package for handling command-line parameters
require Exporter;
use vars qw($VERSION);
$VERSION = 1.01;
@@ISA = Exporter;
a8 1
use Cwd;
d11 5
a18 4
use strict;

use Config;

d40 27
d73 9
d89 8
a103 20
=item outfile

    --outfile=name

Specify the HTML file to create.  Output goes to STDOUT if no outfile
is specified.

=item podroot

    --podroot=name

Specify the base directory for finding library pods.

=item podpath

    --podpath=name:...:name

Specify which subdirectories of the podroot contain pod files whose
HTML converted forms can be linked-to in cross-references.

d113 4
d118 3
a120 1
Use Netscape HTML directives when applicable.
d122 2
a123 1
=item nonetscape
d125 1
a125 1
    --nonetscape
d127 1
a127 1
Do not use Netscape HTML directives (default).
d129 2
a130 1
=item index
d132 1
a132 1
    --index
d134 1
a134 1
Generate an index at the top of the HTML file (default behaviour).
d136 1
a136 1
=item noindex
d138 1
a138 1
    --noindex
d140 2
a141 1
Do not generate an index at the top of the HTML file.
d143 3
d150 1
a153 6
=item norecurse

    --norecurse

Do not recurse into subdirectories specified in podpath.

d163 1
d165 1
a165 1
Display progress messages.
d180 4
a187 4
=head1 BUGS

Has trouble with C<> etc in = commands.

d198 3
a200 2
my $dircache = "pod2html-dircache";
my $itemcache = "pod2html-itemcache";
d207 2
d210 4
d218 1
d220 1
d223 1
d225 2
a226 7
my @@listitem = ();		# stack of HTML commands to use when a =item is
				#   encountered.  the top of the stack is the
				#   current list.
my @@listdata = ();		# similar to @@listitem, but for the text after
				#   an =item
my @@listend = ();		# similar to @@listitem, but the text to use to
				#   end the list.
d235 1
d240 1
d246 1
d250 2
a251 2
$dircache = "pod2html-dircache";
$itemcache = "pod2html-itemcache";
d258 2
d265 1
d267 1
d270 1
d272 2
a273 7
@@listitem = ();		# stack of HTML commands to use when a =item is
				#   encountered.  the top of the stack is the
				#   current list.
@@listdata = ();		# similar to @@listitem, but for the text after
				#   an =item
@@listend = ();		# similar to @@listitem, but the text to use to
				#   end the list.
d281 1
d295 1
d299 18
d345 13
d364 1
d370 1
a370 2
	warn "No pod in $podfile\n" if $verbose;
	return;
d391 1
a391 1
    if (!$title and $podfile =~ /\.pod$/) {
d402 2
a403 2
	warn "$0: no title for $podfile";
	$podfile =~ /^(.*)(\.[^.\/]+)?$/;
d407 12
d422 1
a422 1
<TITLE>$title</TITLE>
d427 1
a427 1

d434 1
a434 1
    scan_items("", \%items, @@poddata);
d440 1
d446 1
a446 1
    print HTML "<HR>\n" if $doindex;
d449 5
a453 2
    warn "Converting input file\n" if $verbose;
    foreach my $i (0..$#poddata) {
d458 1
d472 6
a477 3
		    process_head($1, $2);
		} elsif (/^=item\s*(.*\S)/sm) {	# =item text
		    process_item($1);
d482 1
a482 1
		} elsif (/^=for\s+(\S+)\s+(.*)/si) {# =for
d496 37
a532 2
	    process_text(\$text, 1);
	    print HTML "<P>\n$text";
d538 5
d544 1
d571 29
a599 26
  --flush      - flushes the item and directory caches.
  --help       - prints this message.
  --htmlroot   - http-server base directory from which all relative paths
                 in podpath stem (default is /).
  --index      - generate an index at the top of the resulting html
                 (default).
  --infile     - filename for the pod to convert (input taken from stdin
                 by default).
  --libpods    - colon-separated list of pages to search for =item pod
                 directives in as targets of C<> and implicit links (empty
                 by default).  note, these are not filenames, but rather
                 page names like those that appear in L<> links.
  --netscape   - will use netscape html directives when applicable.
  --nonetscape - will not use netscape directives (default).
  --outfile    - filename for the resulting html file (output sent to
                 stdout by default).
  --podpath    - colon-separated list of directories containing library
                 pods.  empty by default.
  --podroot    - filesystem base directory from which all relative paths
                 in podpath stem (default is .).
  --noindex    - don't generate an index at the top of the resulting html.
  --norecurse  - don't recurse on those subdirectories listed in podpath.
  --recurse    - recurse on those subdirectories listed in podpath
                 (default behavior).
  --title      - title that will appear in resulting html file.
  --verbose    - self-explanatory
d604 6
a609 1
    my ($opt_flush,$opt_help,$opt_htmlroot,$opt_index,$opt_infile,$opt_libpods,$opt_netscape,$opt_outfile,$opt_podpath,$opt_podroot,$opt_norecurse,$opt_recurse,$opt_title,$opt_verbose);
d611 2
d614 1
d616 1
d625 1
a625 1
			    'norecurse'  => \$opt_norecurse,
d628 1
a628 1
			    'verbose'    => \$opt_verbose,
a634 3
    $podfile  = $opt_infile if defined $opt_infile;
    $htmlfile = $opt_outfile if defined $opt_outfile;

d638 15
a655 9

    $htmlroot = $opt_htmlroot if defined $opt_htmlroot;
    $podroot  = $opt_podroot if defined $opt_podroot;

    $doindex  = $opt_index if defined $opt_index;
    $recurse  = $opt_recurse if defined $opt_recurse;
    $title    = $opt_title if defined $opt_title;
    $verbose  = defined $opt_verbose ? 1 : 0;
    $netscape = $opt_netscape if defined $opt_netscape;
d693 1
a693 1
		@@$podpath, $podroot, stat($dircache), stat($itemcache));
a700 1

d798 3
a800 1
	if ($pages{$libpod} =~ /([^:]*[^(\.pod|\.pm)]):/) {
d805 1
a805 1
	    @@files = grep(/(\.pod|\.pm)$/ && ! -d $_, readdir(DIR));
d814 1
d816 1
a816 1
		scan_items("$dirname/$pod", @@poddata);
d820 5
a824 4
	    foreach $pod (@@files) {
		$pod =~ /^(.*)(\.pod|\.pm)$/;
		$items{$1} = "$dirname/$1.html" if $1;
	    }
d833 1
d835 1
a835 1
	    scan_items("$pod", @@poddata);
d891 2
a892 2
	} elsif (/\.pod$/) {	    	    	    	    # .pod
	    s/\.pod$//;
d896 2
a897 2
	} elsif (/\.pm$/) { 	    	    	    	    # .pm
	    s/\.pm$//;
d919 1
a919 1
    my($tag, $which_head, $title, $listdepth, $index);
d932 6
a937 3
	    ($tag,$which_head, $title) = ($1,$2,$3);
	    chomp($title);
	    $$sections{htmlify(0,$title)} = 1;
d950 2
a951 2
	              "<A HREF=\"#" . htmlify(0,$title) . "\">" .
		      html_escape(process_text(\$title, 0)) . "</A>";
d973 1
a973 1
    my($pod, @@poddata) = @@_;
d977 1
a977 1
    $pod =~ s/\.pod$//;
d981 1
a981 1
	$_ = $poddata[$i];
d983 11
a993 19
	# remove any formatting instructions
	s,[A-Z]<([^<>]*)>,$1,g;

	# figure out what kind of item it is and get the first word of
	#  it's name.
	if (/^=item\s+(\w*)\s*.*$/s) {
	    if ($1 eq "*") {		# bullet list
		/\A=item\s+\*\s*(.*?)\s*\Z/s;
		$item = $1;
	    } elsif ($1 =~ /^\d+/) {	# numbered list
		/\A=item\s+\d+\.?(.*?)\s*\Z/s;
		$item = $1;
	    } else {
#		/\A=item\s+(.*?)\s*\Z/s;
		/\A=item\s+(\w*)/s;
		$item = $1;
	    }

	    $items{$item} = "$pod" if $item;
d995 2
d1004 1
a1004 2
    my($tag, $heading) = @@_;
    my $firstword;
d1010 6
a1015 2
    # can't have a heading full of spaces and speechmarks and so on
    $firstword = $heading; $firstword =~ s/\s*(\w+)\s.*/$1/;
d1017 44
a1060 9
    print HTML "<P>\n" unless $listlevel;
    print HTML "<HR>\n" unless $listlevel || $top;
    print HTML "<H$level>"; # unless $listlevel;
    #print HTML "<H$level>" unless $listlevel;
    my $convert = $heading; process_text(\$convert, 0);
    $convert = html_escape($convert);
    print HTML '<A NAME="' . htmlify(0,$heading) . "\">$convert</A>";
    print HTML "</H$level>"; # unless $listlevel;
    print HTML "\n";
d1067 1
a1067 6
    my $text = $_[0];
    my($i, $quote, $name);

    my $need_preamble = 0;
    my $this_entry;

d1072 4
a1075 3
    warn "$0: $podfile: unexpected =item directive in paragraph $paragraph.  ignoring.\n"
	unless $listlevel;
    process_over() unless $listlevel;
d1077 5
a1081 1
    return unless $listlevel;
d1084 1
a1084 8
    1 while $text =~ s/[A-Z]<([^<>]*)>/$1/g;
    pre_escape(\$text);

    $need_preamble = $items_seen[$listlevel]++ == 0;

    # check if this is the first =item after an =over
    $i = $listlevel - 1;
    my $need_new = $listlevel >= @@listitem;
d1086 21
a1106 55
    if ($text =~ /\A\*/) {		# bullet

	if ($need_preamble) {
	    push(@@listend,  "</UL>");
	    print HTML "<UL>\n";
	}

	print HTML '<LI>';
	if ($text =~ /\A\*\s*(.+)\Z/s) {
	    print HTML '<STRONG>';
	    if ($items_named{$1}++) {
		print HTML html_escape($1);
	    } else {
		my $name = 'item_' . htmlify(1,$1);
		print HTML qq(<A NAME="$name">), html_escape($1), '</A>';
	    }
	    print HTML '</STRONG>';
	}

    } elsif ($text =~ /\A[\d#]+/) {	# numbered list

	if ($need_preamble) {
	    push(@@listend,  "</OL>");
	    print HTML "<OL>\n";
	}

	print HTML '<LI>';
	if ($text =~ /\A\d+\.?\s*(.+)\Z/s) {
	    print HTML '<STRONG>';
	    if ($items_named{$1}++) {
		print HTML html_escape($1);
	    } else {
		my $name = 'item_' . htmlify(0,$1);
		print HTML qq(<A NAME="$name">), html_escape($1), '</A>';
	    }
	    print HTML '</STRONG>';
	}

    } else {			# all others

	if ($need_preamble) {
	    push(@@listend,  '</DL>');
	    print HTML "<DL>\n";
	}

	print HTML '<DT>';
	if ($text =~ /(\S+)/) {
	    print HTML '<STRONG>';
	    if ($items_named{$1}++) {
		print HTML html_escape($text);
	    } else {
		my $name = 'item_' . htmlify(1,$text);
		print HTML qq(<A NAME="$name">), html_escape($text), '</A>';
	    }
	    print HTML '</STRONG>';
a1109 1

d1114 1
a1114 2
# process_over - process a pod over tag and start a corresponding HTML
# list.
d1119 2
d1127 4
a1130 3
    warn "$0: $podfile: unexpected =back directive in paragraph $paragraph.  ignoring.\n"
	unless $listlevel;
    return unless $listlevel;
d1136 7
a1142 7
    print HTML $listend[$listlevel] if defined $listend[$listlevel];
    print HTML "\n";

    # don't need the corresponding perl code anymore
    pop(@@listitem);
    pop(@@listdata);
    pop(@@listend);
d1144 2
a1145 1
    pop(@@items_seen);
d1149 1
a1149 1
# process_cut - process a pod cut tag, thus stop ignoring pod directives.
d1156 2
a1157 2
# process_pod - process a pod pod tag, thus ignore pod directives until we see a
# corresponding cut.
d1164 1
a1164 1
# process_for - process a =for pod tag.  if it's for html, split
d1204 1
a1204 1
    pop @@begin_stack;
d1208 1
a1208 3
# process_text - handles plaintext that appears in the input pod file.
# there may be pod commands embedded within the text so those must be
# converted to html commands.
d1210 3
a1212 5
sub process_text {
    my($text, $escapeQuotes) = @@_;
    my($result, $rest, $s1, $s2, $s3, $s4, $match, $bf);
    my($podcommand, $params, $tag, $quote);

a1214 2
    $quote  = 0;    	    	# status of double-quote conversion
    $result = "";
d1217 2
a1218 3
    if ($rest =~ /^\s+/) {	# preformatted text, no pod directives
	$rest =~ s/\n+\Z//;
	$rest =~ s#.*#
d1224 41
a1264 19
	$rest   =~ s/&/&amp;/g;
	$rest   =~ s/</&lt;/g;
	$rest   =~ s/>/&gt;/g;
	$rest   =~ s/"/&quot;/g;

	# try and create links for all occurrences of perl.* within
	# the preformatted text.
	$rest =~ s{
		    (\s*)(perl\w+)
		  }{
		    if (defined $pages{$2}) {	# is a link
			qq($1<A HREF="$htmlroot/$pages{$2}">$2</A>);
		    } elsif (defined $pages{dosify($2)}) {	# is a link
			qq($1<A HREF="$htmlroot/$pages{dosify($2)}">$2</A>);
		    } else {
			"$1$2";
		    }
		  }xeg;
	$rest =~ s/(<A HREF=)([^>:]*:)?([^>:]*)\.pod:([^>:]*:)?/$1$3.html/g;
d1266 1
a1266 1
  my $urls = '(' . join ('|', qw{
d1278 4
a1281 4
  my $ltrs = '\w';
  my $gunk = '/#~:.?+=&%@@!\-';
  my $punc = '.:?\-';
  my $any  = "${ltrs}${gunk}${punc}";
d1283 1
a1283 1
  $rest =~ s{
d1287 1
d1301 3
a1303 28
	$result =   "<PRE>"	# text should be as it is (verbatim)
		  . "$rest\n"
		  . "</PRE>\n";
    } else {			# formatted text
	# parse through the string, stopping each time we find a
	# pod-escape.  once the string has been throughly processed
	# we can output it.
	while (length $rest) {
	    # check to see if there are any possible pod directives in
	    # the remaining part of the text.
	    if ($rest =~ m/[BCEIFLSZ]</) {
		warn "\$rest\t= $rest\n" unless
		    $rest =~ /\A
			   ([^<]*?)
			   ([BCEIFLSZ]?)
			   <
			   (.*)\Z/xs;

		$s1 = $1;	# pure text
		$s2 = $2;	# the type of pod-escape that follows
		$s3 = '<';	# '<'
		$s4 = $3;	# the rest of the string
	    } else {
		$s1 = $rest;
		$s2 = "";
		$s3 = "";
		$s4 = "";
	    }
a1304 22
	    if ($s3 eq '<' && $s2) {	# a pod-escape
		$result    .= ($escapeQuotes ? process_puretext($s1, \$quote) : $s1);
		$podcommand = "$s2<";
		$rest       = $s4;

		# find the matching '>'
		$match = 1;
		$bf = 0;
		while ($match && !$bf) {
		    $bf = 1;
		    if ($rest =~ /\A([^<>]*[BCEIFLSZ]<)(.*)\Z/s) {
			$bf = 0;
			$match++;
			$podcommand .= $1;
			$rest        = $2;
		    } elsif ($rest =~ /\A([^>]*>)(.*)\Z/s) {
			$bf = 0;
			$match--;
			$podcommand .= $1;
			$rest        = $2;
		    }
		}
d1306 10
a1315 40
		if ($match != 0) {
		    warn <<WARN;
$0: $podfile: cannot find matching > for $s2 in paragraph $paragraph.
WARN
		    $result .= substr $podcommand, 0, 2;
		    $rest = substr($podcommand, 2) . $rest;
		    next;
		}

		# pull out the parameters to the pod-escape
		$podcommand =~ /^([BCFEILSZ]?)<(.*)>$/s;
		$tag    = $1;
		$params = $2;

		# process the text within the pod-escape so that any escapes
		# which must occur do.
		process_text(\$params, 0) unless $tag eq 'L';

		$s1 = $params;
		if (!$tag || $tag eq " ") {	#  <> : no tag
		    $s1 = "&lt;$params&gt;";
		} elsif ($tag eq "L") {		# L<> : link 
		    $s1 = process_L($params);
		} elsif ($tag eq "I" ||		# I<> : italicize text
			 $tag eq "B" ||		# B<> : bold text
			 $tag eq "F") {		# F<> : file specification
		    $s1 = process_BFI($tag, $params);
		} elsif ($tag eq "C") {		# C<> : literal code
		    $s1 = process_C($params, 1);
		} elsif ($tag eq "E") {		# E<> : escape
		    $s1 = process_E($params);
		} elsif ($tag eq "Z") {		# Z<> : zero-width character
		    $s1 = process_Z($params);
		} elsif ($tag eq "S") {		# S<> : non-breaking space
		    $s1 = process_S($params);
		} elsif ($tag eq "X") {		# S<> : non-breaking space
		    $s1 = process_X($params);
		} else {
		    warn "$0: $podfile: unhandled tag '$tag' in paragraph $paragraph\n";
		}
d1317 3
a1319 10
		$result .= "$s1";
	    } else {
		# for pure text we must deal with implicit links and
		# double-quotes among other things.
		$result .= ($escapeQuotes ? process_puretext("$s1$s2$s3", \$quote) : "$s1$s2$s3");
		$rest    = $s4;
	    }
	}
    }
    $$text = $result;
a1321 9
sub html_escape {
    my $rest = $_[0];
    $rest   =~ s/&/&amp;/g;
    $rest   =~ s/</&lt;/g;
    $rest   =~ s/>/&gt;/g;
    $rest   =~ s/"/&quot;/g;
    return $rest;
} 

d1327 7
a1333 2
    my($text, $quote) = @@_;
    my(@@words, $result, $rest, $lead, $trail);
d1336 5
a1340 5
    $text =~ s/\A([^"]*)"/$1''/s if $$quote;
    while ($text =~ s/\A([^"]*)["]([^"]*)["]/$1``$2''/sg) {}

    $$quote = ($text =~ m/"/ ? 1 : 0);
    $text =~ s/\A([^"]*)"/$1``/s if $$quote;
d1343 2
a1344 2
    $lead  = ($text =~ /\A(\s*)/s ? $1 : "");
    $trail = ($text =~ /(\s*)\Z/s ? $1 : "");
d1346 2
a1347 3
    # collapse all white space into a single space
    $text =~ s/\s+/ /g;
    @@words = split(" ", $text);
d1351 2
d1354 1
a1354 1
	if ($word =~ /^\w+\(/) {
d1356 17
a1372 18
	    $word = process_C($word);
#	    $word =~ /^[^()]*]\(/;
#	    if (defined $items{$1} && $items{$1}) {
#		$word =   "\n<CODE><A HREF=\"$htmlroot/$items{$1}#item_"
#			. htmlify(0,$word)
#			. "\">$word</A></CODE>";
#	    } elsif (defined $items{$word} && $items{$word}) {
#		$word =   "\n<CODE><A HREF=\"$htmlroot/$items{$word}#item_"
#			. htmlify(0,$word)
#			. "\">$word</A></CODE>";
#	    } else {
#		$word =   "\n<CODE><A HREF=\"#item_"
#			. htmlify(0,$word)
#			. "\">$word</A></CODE>";
#	    }
	} elsif ($word =~ /^[\$\@@%&*]+\w+$/) {
	    # perl variables, should be a C<> ref
	    $word = process_C($word, 1);
d1375 1
d1391 3
a1393 6
    # build a new string based upon our conversion
    $result = "";
    $rest   = join(" ", @@words);
    while (length($rest) > 75) {
	if ( $rest =~ m/^(.{0,75})\s(.*?)$/o ||
	     $rest =~ m/^(\S*)\s(.*?)$/o) {
d1395 221
a1615 2
	    $result .= "$1\n";
	    $rest    = $2;
d1617 1
a1617 2
	    $result .= "$rest\n";
	    $rest    = "";
d1619 1
d1621 13
a1633 1
    $result .= $rest if $rest;
d1635 2
a1636 2
    # restore the leading and trailing white-space
    $result = "$lead$result$trail";
d1638 9
a1646 1
    return $result;
d1650 1
a1650 1
# pre_escape - convert & in text to $amp;
d1652 8
a1659 2
sub pre_escape {
    my($str) = @@_;
a1660 2
    $$str =~ s,&,&amp;,g;
}
d1667 1
d1677 1
a1677 5
# process_L - convert a pod L<> directive to a corresponding HTML link.
#  most of the links made are inferred rather than known about directly
#  (i.e it's not known whether the =head\d section exists in the target file,
#   or whether a .pod file exists in the case of split files).  however, the
#  guessing usually works.
d1679 9
a1687 29
# Unlike the other directives, this should be called with an unprocessed
# string, else tags in the link won't be matched.
#
sub process_L {
    my($str) = @@_;
    my($s1, $s2, $linktext, $page, $page83, $section, $link);	# work strings

    $str =~ s/\n/ /g;			# undo word-wrapped tags
    $s1 = $str;
    for ($s1) {
	# LREF: a la HREF L<show this text|man/section>
	$linktext = $1 if s:^([^|]+)\|::;

	# make sure sections start with a /
	s,^",/",g;
	s,^,/,g if (!m,/, && / /);

	# check if there's a section specified
	if (m,^(.*?)/"?(.*?)"?$,) {	# yes
	    ($page, $section) = ($1, $2);
	} else {			# no
	    ($page, $section) = ($str, "");
	}

	# check if we know that this is a section in this page
	if (!defined $pages{$page} && defined $sections{$page}) {
	    $section = $page;
	    $page = "";
	}
d1693 1
a1693 2
	$link = "#" . htmlify(0,$section);
	$linktext = $section unless defined($linktext);
a1694 1
	$linktext  = ($section ? "$section" : "$page");
d1696 23
d1720 1
a1720 1
	$link .= "#" . htmlify(0,$section) if ($section);
a1721 1
	warn "$0: $podfile: cannot resolve L<$str> in paragraph $paragraph: no such page '$page'\n";
a1722 1
	$linktext = $page unless defined($linktext);
d1724 2
a1725 2
	$linktext  = ($section ? "$section" : "the $page manpage") unless defined($linktext);
	$section = htmlify(0,$section) if $section ne "";
d1729 2
a1730 1
	if ($section ne "" && $pages{$page} =~ /([^:]*[^(\.pod|\.pm)]):/) {
d1732 1
d1738 3
a1740 1
	    $section = "#$section";
a1746 2
		warn "$0: $podfile: cannot resolve L$str in paragraph $paragraph: ".
			     "no .pod or .pm found\n";
a1747 1
		$linktext = $section unless defined($linktext);
a1751 1
    process_text(\$linktext, 0);
d1753 16
a1768 1
	$s1 = "<A HREF=\"$link\">$linktext</A>";
d1770 1
a1770 1
	$s1 = "<EM>$linktext</EM>";
a1771 1
    return $s1;
d1775 2
a1776 2
# process_BFI - process any of the B<>, F<>, or I<> pod-escapes and
# convert them to corresponding HTML directives.
d1778 2
a1779 6
sub process_BFI {
    my($tag, $str) = @@_;
    my($s1);			# work string
    my(%repltext) = (	'B' => 'STRONG',
			'F' => 'EM',
			'I' => 'EM');
d1781 3
a1783 4
    # extract the modified text and convert to HTML
    $s1 = "<$repltext{$tag}>$str</$repltext{$tag}>";
    return $s1;
}
d1785 3
a1787 6
#
# process_C - process the C<> pod-escape.
#
sub process_C {
    my($str, $doref) = @@_;
    my($s1, $s2);
d1789 4
a1792 5
    $s1 = $str;
    $s1 =~ s/\([^()]*\)//g;	# delete parentheses
    $s2 = $s1;
    $s1 =~ s/\W//g;		# delete bogus characters
    $str = html_escape($str);
d1794 8
a1801 11
    # if there was a pod file that we found earlier with an appropriate
    # =item directive, then create a link to that page.
    if ($doref && defined $items{$s1}) {
	$s1 = ($items{$s1} ?
	       "<A HREF=\"$htmlroot/$items{$s1}#item_" . htmlify(0,$s2) .  "\">$str</A>" :
	       "<A HREF=\"#item_" . htmlify(0,$s2) .  "\">$str</A>");
	$s1 =~ s,(perl\w+/(\S+)\.html)#item_\2\b,$1,; 
	confess "s1 has space: $s1" if $s1 =~ /HREF="[^"]*\s[^"]*"/;
    } else {
	$s1 = "<CODE>$str</CODE>";
	# warn "$0: $podfile: cannot resolve C<$str> in paragraph $paragraph\n" if $verbose
d1804 2
a1806 2
    return $s1;
}
d1809 1
a1809 1
# process_E - process the E<> pod directive which seems to escape a character.
d1811 16
a1826 2
sub process_E {
    my($str) = @@_;
d1828 9
a1836 2
    for ($str) {
	s,([^/].*),\&$1\;,g;
d1839 8
a1846 2
    return $str;
}
d1848 11
a1858 6
#
# process_Z - process the Z<> pod directive which really just amounts to
# ignoring it.  this allows someone to start a paragraph with an =
#
sub process_Z {
    my($str) = @@_;
d1860 3
a1862 3
    # there is no equivalent in HTML for this so just ignore it.
    $str = "";
    return $str;
a1864 6
#
# process_S - process the S<> pod directive which means to convert all
# spaces in the string to non-breaking spaces (in HTML-eze).
#
sub process_S {
    my($str) = @@_;
a1865 4
    # convert all spaces in the text to non-breaking spaces in HTML.
    $str =~ s/ /&nbsp;/g;
    return $str;
}
d1868 8
a1875 5
# process_X - this is supposed to make an index entry.  we'll just 
# ignore it.
#
sub process_X {
    return '';
d1892 2
a1893 1
# specification for HTML.  if first arg is 1, only takes 1st word.
d1896 9
a1904 1
    my($compact, $heading) = @@_;
d1906 98
a2003 15
    if ($compact) {
      $heading =~ /^(\w+)/;
      $heading = $1;
    } 

  # $heading = lc($heading);
  $heading =~ s/[^\w\s]/_/g;
  $heading =~ s/(\s+)/ /g;
  $heading =~ s/^\s*(.*?)\s*$/$1/s;
  $heading =~ s/ /_/g;
  $heading =~ s/\A(.{32}).*\Z/$1/s;
  $heading =~ s/\s+\Z//;
  $heading =~ s/_{2,}/_/g;

  return $heading;
d2006 11
a2016 1
BEGIN {
@


1.1
log
@perl 5.004_04
@
text
@d6 2
d14 2
d18 2
d22 1
a22 1
Pod::HTML - module to convert pod files to HTML
d26 1
a26 1
    use Pod::HTML;
d208 2
d255 1
a255 1

d265 2
d305 11
a315 8
    # put a title in the HTML file
    $title = '';
    TITLE_SEARCH: {
	for (my $i = 0; $i < @@poddata; $i++) { 
	    if ($poddata[$i] =~ /^=head1\s*NAME\b/m) {
		for my $para ( @@poddata[$i, $i+1] ) { 
		    last TITLE_SEARCH if ($title) = $para =~ /(\S+\s+-+\s*.*)/s;
		}
d317 2
a318 3

	} 
    } 
d327 3
a329 1
    unless ($title) { 
d336 5
a340 4
    <HTML> 
	<HEAD> 
	    <TITLE>$title</TITLE> 
	</HEAD>
d342 1
a342 1
	<BODY>
d382 1
a382 1
		if (/^=(head[1-6])\s+(.*)/s) {	# =head[1-6] heading
d384 1
a384 1
		} elsif (/^=item\s*(.*)/sm) {	# =item text
d405 1
a405 1
	    print HTML "$text\n<P>\n\n";
d412 1
a412 1
    </BODY>
d414 1
a414 1
    </HTML>
d784 8
a791 5
	    if ($which_head > $listdepth) {
		$index .= "\n" . ("\t" x $listdepth) . "<UL>\n";
	    } elsif ($which_head < $listdepth) {
		$listdepth--;
		$index .= "\n" . ("\t" x $listdepth) . "</UL>\n";
a792 1
	    $listdepth = $which_head;
d796 1
a796 1
		      process_text(\$title, 0) . "</A>";
d837 2
a838 2
	    } elsif ($1 =~ /^[0-9]+/) {	# numbered list
		/\A=item\s+[0-9]+\.?(.*?)\s*\Z/s;
d870 1
d913 11
a923 8
       print HTML "<LI><STRONG>";
       $text =~ /\A\*\s*(.*)\Z/s;
       print HTML "<A NAME=\"item_" . htmlify(1,$1) . "\">" if $1 && !$items_named{$1}++;
       $quote = 1;
       #print HTML process_puretext($1, \$quote);
       print HTML $1;
       print HTML "</A>" if $1;
       print HTML "</STRONG>";
d925 1
a925 1
    } elsif ($text =~ /\A[0-9#]+/) {	# numbered list
d932 11
a942 8
       print HTML "<LI><STRONG>";
       $text =~ /\A[0-9]+\.?(.*)\Z/s;
       print HTML "<A NAME=\"item_" . htmlify(0,$1) . "\">" if $1;
       $quote = 1;
       #print HTML process_puretext($1, \$quote);
       print HTML $1 if $1;
       print HTML "</A>" if $1;
       print HTML "</STRONG>";
d951 11
a961 12
       print HTML "<DT><STRONG>";
       print HTML "<A NAME=\"item_" . htmlify(1,$text) . "\">" 
	    if $text && !$items_named{($text =~ /(\S+)/)[0]}++;
	    # preceding craziness so that the duplicate leading bits in 
	    # perlfunc work to find just the first one.  otherwise
	    # open etc would have many names
       $quote = 1;
       #print HTML process_puretext($text, \$quote);
       print HTML $text;
       print HTML "</A>" if $text;
       print HTML "</STRONG>";

d1017 1
a1017 1
# it out verbatim, otherwise ignore it.
d1023 7
a1029 1
    } 
d1095 2
d1144 1
a1144 1
	while ($rest) {
d1300 1
a1300 1
	} elsif ($word =~ /[\w.-]+\@@\w+\.\w/) {
d1302 4
a1305 1
	    $word = qq(<A HREF="MAILTO:$word">$word</A>);
d1307 1
a1307 1
	    $word = html_escape($word) if $word =~ /[&<>]/;
d1310 1
a1310 1
	    $word = html_escape($word) if $word =~ /[&<>]/;
d1346 13
d1370 1
a1370 1
    my($s1, $s2, $linktext, $page, $section, $link);	# work strings
d1375 2
a1376 2
	# a :: acts like a /
	s,::,/,;
d1396 2
d1400 6
a1405 1
	$linktext = $section;
d1409 1
a1409 1
	$linktext = $page;
d1411 1
a1411 1
	$linktext  = ($section ? "$section" : "the $page manpage");
d1433 1
a1433 1
		$linktext = $section;
d1474 1
d1544 1
a1544 1
    while ($listlevel >= 0) {
a1577 1

@


1.1.1.1
log
@perl5.005_03
@
text
@a5 2
use vars qw($VERSION);
$VERSION = 1.01;
a11 2
use locale;	# make \w work right in non-ASCII lands

a13 2
use Config;

d16 1
a16 1
Pod::Html - module to convert pod files to HTML
d20 1
a20 1
    use Pod::Html;
a201 2
my $Is83;                       # is dos with short filenames (8.3)

d247 1
a247 1
$Is83=$^O eq 'dos';
a256 2
    $Is83 = 0 if (defined (&Dos::UseLFN) && Dos::UseLFN());

d295 9
a303 10
    # put a title in the HTML file if one wasn't specified
    if ($title eq '') {
	TITLE_SEARCH: {
	    for (my $i = 0; $i < @@poddata; $i++) { 
		if ($poddata[$i] =~ /^=head1\s*NAME\b/m) {
		    for my $para ( @@poddata[$i, $i+1] ) { 
			last TITLE_SEARCH
			    if ($title) = $para =~ /(\S+\s+-+.*\S)/s;
		    }
		} 
d305 2
a306 3
	    } 
	}
    }
d315 1
a315 3
    if ($title) {
	$title =~ s/\s*\(.*\)//;
    } else {
d322 4
a325 5
<HTML>
<HEAD>
<TITLE>$title</TITLE>
<LINK REV="made" HREF="mailto:$Config{perladmin}">
</HEAD>
d327 1
a327 1
<BODY>
d367 1
a367 1
		if (/^=(head[1-6])\s+(.*\S)/s) {	# =head[1-6] heading
d369 1
a369 1
		} elsif (/^=item\s*(.*\S)/sm) {	# =item text
d390 1
a390 1
	    print HTML "<P>\n$text";
d397 1
a397 1
</BODY>
d399 1
a399 1
</HTML>
d769 5
a773 8
	    while ($which_head != $listdepth) {
		if ($which_head > $listdepth) {
		    $index .= "\n" . ("\t" x $listdepth) . "<UL>\n";
		    $listdepth++;
		} elsif ($which_head < $listdepth) {
		    $listdepth--;
		    $index .= "\n" . ("\t" x $listdepth) . "</UL>\n";
		}
d775 1
d779 1
a779 1
		      html_escape(process_text(\$title, 0)) . "</A>";
d820 2
a821 2
	    } elsif ($1 =~ /^\d+/) {	# numbered list
		/\A=item\s+\d+\.?(.*?)\s*\Z/s;
a852 1
    $convert = html_escape($convert);
d895 8
a902 11
	print HTML '<LI>';
	if ($text =~ /\A\*\s*(.+)\Z/s) {
	    print HTML '<STRONG>';
	    if ($items_named{$1}++) {
		print HTML html_escape($1);
	    } else {
		my $name = 'item_' . htmlify(1,$1);
		print HTML qq(<A NAME="$name">), html_escape($1), '</A>';
	    }
	    print HTML '</STRONG>';
	}
d904 1
a904 1
    } elsif ($text =~ /\A[\d#]+/) {	# numbered list
d911 8
a918 11
	print HTML '<LI>';
	if ($text =~ /\A\d+\.?\s*(.+)\Z/s) {
	    print HTML '<STRONG>';
	    if ($items_named{$1}++) {
		print HTML html_escape($1);
	    } else {
		my $name = 'item_' . htmlify(0,$1);
		print HTML qq(<A NAME="$name">), html_escape($1), '</A>';
	    }
	    print HTML '</STRONG>';
	}
d927 12
a938 11
	print HTML '<DT>';
	if ($text =~ /(\S+)/) {
	    print HTML '<STRONG>';
	    if ($items_named{$1}++) {
		print HTML html_escape($text);
	    } else {
		my $name = 'item_' . htmlify(1,$text);
		print HTML qq(<A NAME="$name">), html_escape($text), '</A>';
	    }
	    print HTML '</STRONG>';
	}
d994 1
a994 1
# it out verbatim, if illustration, center it, otherwise ignore it.
d1000 1
a1000 7
    } elsif ($whom =~ /^illustration$/i) {
        1 while chomp $text;
	for my $ext (qw[.png .gif .jpeg .jpg .tga .pcl .bmp]) {
	  $text .= $ext, last if -r "$text$ext";
	}
        print HTML qq{<p align = "center"><img src = "$text" alt = "$text illustration"></p>};
    }
a1065 2
		    } elsif (defined $pages{dosify($2)}) {	# is a link
			qq($1<A HREF="$htmlroot/$pages{dosify($2)}">$2</A>);
d1113 1
a1113 1
	while (length $rest) {
d1269 1
a1269 1
	} elsif ($word =~ /[\w.-]+\@@[\w-]+\.\w/) {
d1271 1
a1271 4
	    my ($w1, $w2, $w3) = ("", $word, "");
	    ($w1, $w2, $w3) = ("(", $1, ")$2") if $word =~ /^\((.*?)\)(,?)/;
	    ($w1, $w2, $w3) = ("&lt;", $1, "&gt;$2") if $word =~ /^<(.*?)>(,?)/;
	    $word = qq($w1<A HREF="mailto:$w2">$w2</A>$w3);
d1273 1
a1273 1
	    $word = html_escape($word) if $word =~ /["&<>]/;
d1276 1
a1276 1
	    $word = html_escape($word) if $word =~ /["&<>]/;
a1311 13
# dosify - convert filenames to 8.3
#
sub dosify {
    my($str) = @@_;
    if ($Is83) {
        $str = lc $str;
        $str =~ s/(\.\w+)/substr ($1,0,4)/ge;
        $str =~ s/(\w+)/substr ($1,0,8)/ge;
    }
    return $str;
}

#
d1323 1
a1323 1
    my($s1, $s2, $linktext, $page, $page83, $section, $link);	# work strings
d1328 2
a1329 2
	# LREF: a la HREF L<show this text|man/section>
	$linktext = $1 if s:^([^|]+)\|::;
a1348 2
    $page83=dosify($page);
    $page=$page83 if (defined $pages{$page83});
d1351 1
a1351 6
	$linktext = $section unless defined($linktext);
    } elsif ( $page =~ /::/ ) {
	$linktext  = ($section ? "$section" : "$page");
	$page =~ s,::,/,g;
	$link = "$htmlroot/$page.html";
	$link .= "#" . htmlify(0,$section) if ($section);
d1355 1
a1355 1
	$linktext = $page unless defined($linktext);
d1357 1
a1357 1
	$linktext  = ($section ? "$section" : "the $page manpage") unless defined($linktext);
d1379 1
a1379 1
		$linktext = $section unless defined($linktext);
a1419 1
    $str = html_escape($str);
d1489 1
a1489 1
    while ($listlevel > 0) {
d1523 1
@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d2 3
a4 1
use strict;
d6 3
a8 4

use vars qw($VERSION @@ISA @@EXPORT);
$VERSION = 1.03;
@@ISA = qw(Exporter);
d10 1
a12 5
use Config;
use Cwd;
use File::Spec::Unix;
use Getopt::Long;
use Pod::Functions;
d16 4
a40 27
=item backlink

    --backlink="Back to Top"

Adds "Back to Top" links in front of every HEAD1 heading (except for
the first).  By default, no backlink are being generated.

=item css

    --css=stylesheet

Specify the URL of a cascading style sheet.

=item flush

    --flush

Flushes the item and directory caches.

=item header

    --header
    --noheader

Creates header and footer blocks containing the text of the NAME
section.  By default, no headers are being generated.

a46 9
=item htmldir

    --htmldir=name

Sets the directory in which the resulting HTML file is placed.  This
is used to generate relative links to other files. Not passing this
causes all links to be absolute, since this is the value that tells
Pod::Html the root of the documentation tree.

a53 8
=item index

    --index
    --noindex

Generate an index at the top of the HTML file.  This is the default
behaviour.

d61 20
a89 1
    --nonetscape
d91 3
a93 2
Use Netscape HTML directives when applicable.  By default, they will
B<not> be used.
d95 1
a95 1
=item outfile
d97 1
a97 1
    --outfile=name
d99 1
a99 2
Specify the HTML file to create.  Output goes to STDOUT if no outfile
is specified.
d101 1
a101 1
=item podpath
d103 1
a103 1
    --podpath=name:...:name
d105 1
a105 2
Specify which subdirectories of the podroot contain pod files whose
HTML converted forms can be linked-to in cross-references.
d107 1
a107 1
=item podroot
d109 1
a109 1
    --podroot=name
a110 1
Specify the base directory for finding library pods.
d112 1
a112 1
=item quiet
d114 1
a114 2
    --quiet
    --noquiet
d116 1
a116 3
Don't display I<mostly harmless> warning messages.  These messages
will be displayed by default.  But this is not the same as C<verbose>
mode.
d118 1
a118 1
=item recurse
a119 1
    --recurse
d122 1
a122 1
Recurse into subdirectories specified in podpath (default behaviour).
a132 1
    --noverbose
d134 1
a134 1
Display progress messages.  By default, they won't be displayed.
d149 1
a149 1
=head1 ENVIRONMENT
d151 1
a151 1
Uses $Config{pod2html} to setup default options.
d153 1
a153 1
=head1 AUTHOR
d155 1
a155 1
Tom Christiansen, E<lt>tchrist@@perl.comE<gt>.
d167 2
a168 3
my $cache_ext = $^O eq 'VMS' ? ".tmp" : ".x~~";
my $dircache = "pod2htmd$cache_ext";
my $itemcache = "pod2htmi$cache_ext";
a174 2
my $htmldir = "";		# The directory to which the html pages
				# will (eventually) be written.
a175 4
my $htmlfileurl = "" ;		# The url that other files would use to
				# refer to this file.  This is only used
				# to make relative urls that point to
				# other files.
a179 1
my $css = '';                   # Cascading style sheet
a180 1
my $quiet = 0;			# not quiet by default
a182 1
my $backlink = '';              # text for "back to top" links
d184 7
a190 2
my @@listend = ();		# the text to use to end the list.
my $after_lpar = 0;             # set to true after a par in an =item
a198 1
my $header = 0;			# produce block header/footer
a202 1
my $ptQuote = 0;                # status of double-quote conversion
a207 1
my %local_items = ();           # local items - avoid destruction of %items
d211 2
a212 2
$dircache = "pod2htmd$cache_ext";
$itemcache = "pod2htmi$cache_ext";
a218 2
$htmldir = "";	    	# The directory to which the html pages
				# will (eventually) be written.
a223 1
$css = '';                   # Cascading style sheet
a224 1
$quiet = 0;		# not quiet by default
a226 1
$backlink = '';		# text for "back to top" links
d228 7
a234 2
@@listend = ();		# the text to use to end the list.
$after_lpar = 0;        # set to true after a par in an =item
a241 1
$header = 0;			# produce block header/footer
a254 1
%local_items = ();
a257 18
#
# clean_data: global clean-up of pod data
#
sub clean_data($){
    my( $dataref ) = @@_;
    my $i;
    for( $i = 0; $i <= $#$dataref; $i++ ){
	${$dataref}[$i] =~ s/\s+\Z//;

        # have a look for all-space lines
	if( ${$dataref}[$i] =~ /^\s+$/m ){
	    my @@chunks = split( /^\s+$/m, ${$dataref}[$i] );
	    splice( @@$dataref, $i, 1, @@chunks );
	}
    }
}


a285 13
    $htmldir =~ s#/\z## ;               # so we don't get a //
    if (  $htmlroot eq ''
       && defined( $htmldir ) 
       && $htmldir ne ''
       && substr( $htmlfile, 0, length( $htmldir ) ) eq $htmldir 
       ) 
    {
	# Set the 'base' url for this file, so that we can use it
	# as the location from which to calculate relative links 
	# to other files. If this is '', then absolute links will
	# be used throughout.
        $htmlfileurl= "$htmldir/" . substr( $htmlfile, length( $htmldir ) + 1);
    }
a291 1
    clean_data( \@@poddata );
d297 2
a298 1
	warn "No headings in $podfile\n" if $verbose;
d319 1
a319 1
    if (!$title and $podfile =~ /\.pod\z/) {
d330 2
a331 2
	warn "$0: no title for $podfile" unless $quiet;
	$podfile =~ /^(.*)(\.[^.\/]+)?\z/s;
a334 12
    my $csslink = $css ? qq(\n<LINK REL="stylesheet" HREF="$css" TYPE="text/css">) : '';
    $csslink =~ s,\\,/,g;
    $csslink =~ s,(/.):,$1|,;

    my $block = $header ? <<END_OF_BLOCK : '';
<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 WIDTH=100%>
<TR><TD CLASS=block VALIGN=MIDDLE WIDTH=100% BGCOLOR="#cccccc">
<FONT SIZE=+1><STRONG><P CLASS=block>&nbsp;$title</P></STRONG></FONT>
</TD></TR>
</TABLE>
END_OF_BLOCK

d338 1
a338 1
<TITLE>$title</TITLE>$csslink
d343 1
a343 1
$block
d350 1
a350 1
    scan_items( \%local_items, "", @@poddata);
a355 1
    print HTML "<A NAME=\"__index__\"></A>\n";
d361 1
a361 1
    print HTML "<HR>\n" if $doindex and $index;
d364 2
a365 5
    my $after_item;             # set to true after an =item
    warn "Converting input file $podfile\n" if $verbose;
    foreach my $i (0..$#poddata){
        $ptQuote = 0; # status of quote conversion

a369 1
	    $after_item = 0;
d383 3
a385 6
		    process_head( $1, $2, $doindex && $index );
		} elsif (/^=item\s*(.*\S)?/sm) {	# =item text
		    warn "$0: $podfile: =item without bullet, number or text"
		       . " in paragraph $paragraph.\n" if !defined($1) or $1 eq '';
		    process_item( $1 );
		    $after_item = 1;
d390 1
a390 1
		} elsif (/^=for\s+(\S+)\s*(.*)/si) {# =for
d404 2
a405 37
	    if( $text =~ /\A\s+/ ){
		process_pre( \$text );
	        print HTML "<PRE>\n$text</PRE>\n";

	    } else {
		process_text( \$text );

		# experimental: check for a paragraph where all lines
		# have some ...\t...\t...\n pattern
		if( $text =~ /\t/ ){
		    my @@lines = split( "\n", $text );
		    if( @@lines > 1 ){
			my $all = 2;
			foreach my $line ( @@lines ){
			    if( $line =~ /\S/ && $line !~ /\t/ ){
				$all--;
				last if $all == 0;
			    }
			}
			if( $all > 0 ){
			    $text =~ s/\t+/<TD>/g;
			    $text =~ s/^/<TR><TD>/gm;
			    $text = '<TABLE CELLSPACING=0 CELLPADDING=0>' .
                                    $text . '</TABLE>';
			}
		    }
		}
		## end of experimental

		if( $after_item ){
		    print HTML "$text\n";
		    $after_lpar = 1;
		} else {
		    print HTML "<P>$text</P>\n";
		}
	    }
	    $after_item = 0;
a410 5

    # link to page index
    print HTML "<P><A HREF=\"#__index__\"><SMALL>$backlink</SMALL></A></P>\n"
	if $doindex and $index and $backlink;

a411 1
$block
d438 26
a463 29
  --backlink     - set text for "back to top" links (default: none).
  --css          - stylesheet URL
  --flush        - flushes the item and directory caches.
  --[no]header   - produce block header/footer (default is no headers).
  --help         - prints this message.
  --htmldir      - directory for resulting HTML files.
  --htmlroot     - http-server base directory from which all relative paths
                   in podpath stem (default is /).
  --[no]index    - generate an index at the top of the resulting html
                   (default behaviour).
  --infile       - filename for the pod to convert (input taken from stdin
                   by default).
  --libpods      - colon-separated list of pages to search for =item pod
                   directives in as targets of C<> and implicit links (empty
                   by default).  note, these are not filenames, but rather
                   page names like those that appear in L<> links.
  --[no]netscape - will use netscape html directives when applicable.
                   (default is not to use them).
  --outfile      - filename for the resulting html file (output sent to
                   stdout by default).
  --podpath      - colon-separated list of directories containing library
                   pods (empty by default).
  --podroot      - filesystem base directory from which all relative paths
                   in podpath stem (default is .).
  --[no]quiet    - supress some benign warning messages (default is off).
  --[no]recurse  - recurse on those subdirectories listed in podpath
                   (default behaviour).
  --title        - title that will appear in resulting html file.
  --[no]verbose  - self-explanatory (off by default).
d468 1
a468 6
    my ($opt_backlink,$opt_css,$opt_flush,$opt_header,$opt_help,$opt_htmldir,
	$opt_htmlroot,$opt_index,$opt_infile,$opt_libpods,$opt_netscape,
	$opt_outfile,$opt_podpath,$opt_podroot,$opt_quiet,$opt_recurse,
	$opt_title,$opt_verbose);

    unshift @@ARGV, split ' ', $Config{pod2html} if $Config{pod2html};
a469 2
			    'backlink=s' => \$opt_backlink,
			    'css=s'      => \$opt_css,
a470 1
			    'header!'    => \$opt_header,
a471 1
			    'htmldir=s'  => \$opt_htmldir,
d480 1
a480 1
			    'quiet!'     => \$opt_quiet,
d483 1
a483 1
			    'verbose!'   => \$opt_verbose,
d490 3
a495 15
    $backlink = $opt_backlink if defined $opt_backlink;
    $css      = $opt_css      if defined $opt_css;
    $header   = $opt_header   if defined $opt_header;
    $htmldir  = $opt_htmldir  if defined $opt_htmldir;
    $htmlroot = $opt_htmlroot if defined $opt_htmlroot;
    $doindex  = $opt_index    if defined $opt_index;
    $podfile  = $opt_infile   if defined $opt_infile;
    $netscape = $opt_netscape if defined $opt_netscape;
    $htmlfile = $opt_outfile  if defined $opt_outfile;
    $podroot  = $opt_podroot  if defined $opt_podroot;
    $quiet    = $opt_quiet    if defined $opt_quiet;
    $recurse  = $opt_recurse  if defined $opt_recurse;
    $title    = $opt_title    if defined $opt_title;
    $verbose  = $opt_verbose  if defined $opt_verbose;

d499 9
d545 1
a545 1
	@@$podpath, $podroot, stat($dircache), stat($itemcache));
d553 1
d651 1
a651 3
	# NOTE: Only finds the first so-named directory in the tree.
#	if ($pages{$libpod} =~ /([^:]*[^(\.pod|\.pm)]):/) {
	if ($pages{$libpod} =~ /([^:]*(?<!\.pod)(?<!\.pm)):/) {
d656 1
a656 1
	    @@files = grep(/(\.pod|\.pm)\z/ && ! -d $_, readdir(DIR));
a664 1
		clean_data( \@@poddata );
d666 1
a666 1
		scan_items( \%items, "$dirname/$pod", @@poddata);
d670 4
a673 5
### Don't think this should be done this way - confuses issues.(WL)
###	    foreach $pod (@@files) {
###		$pod =~ /^(.*)(\.pod|\.pm)$/;
###		$items{$1} = "$dirname/$1.html" if $1;
###	    }
a681 1
	    clean_data( \@@poddata );
d683 1
a683 1
	    scan_items( \%items, "$pod", @@poddata);
d739 2
a740 2
	} elsif (/\.pod\z/) {	    	    	    	    # .pod
	    s/\.pod\z//;
d744 2
a745 2
	} elsif (/\.pm\z/) { 	    	    	    	    # .pm
	    s/\.pm\z//;
d767 1
a767 1
    my($tag, $which_head, $otitle, $listdepth, $index);
d780 3
a782 6
	    ($tag, $which_head, $otitle) = ($1,$2,$3);

            my $title = depod( $otitle );
            my $name = htmlify( $title );
	    $$sections{$name} = 1;
	    $title = process_text( \$otitle );
d795 2
a796 2
	              "<A HREF=\"#" . $name . "\">" .
		      $title . "</A></LI>";
d818 1
a818 1
    my( $itemref, $pod, @@poddata ) = @@_;
d822 1
a822 1
    $pod =~ s/\.pod\z//;
d826 19
a844 1
	my $txt = depod( $poddata[$i] );
d846 1
a846 11
	# figure out what kind of item it is.
	# Build string for referencing this item.
	if ( $txt =~ /\A=item\s+\*\s*(.*)\Z/s ) { # bullet
	    next unless $1;
	    $item = $1;
        } elsif( $txt =~ /\A=item\s+(?>\d+\.?)\s*(.*)\Z/s ) { # numbered list
	    $item = $1;
	} elsif( $txt =~ /\A=item\s+(.*)\Z/s ) { # plain item
	    $item = $1;
	} else {
	    next;
a847 2
	my $fid = fragment_id( $item );
	$$itemref{$fid} = "$pod" if $fid;
d855 2
a856 1
    my($tag, $heading, $hasindex) = @@_;
d862 2
a863 6
    if( $listlevel ){
	warn "$0: $podfile: unterminated list at =head in paragraph $paragraph.  ignoring.\n";
        while( $listlevel ){
            process_back();
        }
    }
d865 9
a873 10
    print HTML "<P>\n";
    if( $level == 1 && ! $top ){
	print HTML "<A HREF=\"#__index__\"><SMALL>$backlink</SMALL></A>\n"
	    if $hasindex and $backlink;
	print HTML "<HR>\n"
    }

    my $name = htmlify( depod( $heading ) );
    my $convert = process_text( \$heading );
    print HTML "<H$level><A NAME=\"$name\">$convert</A></H$level>\n";
a875 1

d877 1
a877 2
# emit_item_tag - print an =item's text
# Note: The global $EmittedItem is used for inhibiting self-references.
d879 3
a881 1
my $EmittedItem;
d883 2
a884 3
sub emit_item_tag($$$){
    my( $otext, $text, $compact ) = @@_;
    my $item = fragment_id( $text );
a885 28
    $EmittedItem = $item;
    ### print STDERR "emit_item_tag=$item ($text)\n";

    print HTML '<STRONG>';
    if ($items_named{$item}++) {
	print HTML process_text( \$otext );
    } else {
	my $name = 'item_' . $item;
	print HTML qq{<A NAME="$name">}, process_text( \$otext ), '</A>';
    }
    print HTML "</STRONG><BR>\n";
    undef( $EmittedItem );
}

sub emit_li {
    my( $tag ) = @@_;
    if( $items_seen[$listlevel]++ == 0 ){
	push( @@listend, "</$tag>" );
	print HTML "<$tag>\n";
    }
    print HTML $tag eq 'DL' ? '<DT>' : '<LI>';
}

#
# process_item - convert a pod item tag and convert it to HTML format.
#
sub process_item {
    my( $otext ) = @@_;
d890 3
a892 4
    if( $listlevel == 0 ){
	warn "$0: $podfile: unexpected =item directive in paragraph $paragraph.  ignoring.\n";
	process_over();
    }
d894 1
a894 5
    # formatting: insert a paragraph if preceding item has >1 paragraph
    if( $after_lpar ){
	print HTML "<P></P>\n";
	$after_lpar = 0;
    }
d897 8
a904 1
    my $text = depod( $otext );
d906 55
a960 21
    # all the list variants:
    if( $text =~ /\A\*/ ){ # bullet
        emit_li( 'UL' );
	if ($text =~ /\A\*\s+(.+)\Z/s ) { # with additional text
	    my $tag = $1;
	    $otext =~ s/\A\*\s+//;
	    emit_item_tag( $otext, $tag, 1 );
	}

    } elsif( $text =~ /\A\d+/ ){ # numbered list
	emit_li( 'OL' );
	if ($text =~ /\A(?>\d+\.?)\s*(.+)\Z/s ) { # with additional text
	    my $tag = $1;
	    $otext =~ s/\A\d+\.?\s*//;
	    emit_item_tag( $otext, $tag, 1 );
	}

    } else {			# definition list
	emit_li( 'DL' );
	if ($text =~ /\A(.+)\Z/s ){ # should have text
	    emit_item_tag( $otext, $text, 1 );
d964 1
d969 2
a970 1
# process_over - process a pod over tag and start a corresponding HTML list.
a974 2
    push( @@items_seen, 0 );
    $after_lpar = 0;
d981 3
a983 4
    if( $listlevel == 0 ){
	warn "$0: $podfile: unexpected =back directive in paragraph $paragraph.  ignoring.\n";
	return;
    }
d989 7
a995 7
    if( defined $listend[$listlevel] ){
	print HTML '<P></P>' if $after_lpar;
	print HTML $listend[$listlevel];
        print HTML "\n";
        pop( @@listend );
    }
    $after_lpar = 0;
d997 1
a997 2
    # clean up item count
    pop( @@items_seen );
d1001 1
a1001 1
# process_cut - process a pod cut tag, thus start ignoring pod directives.
d1008 2
a1009 2
# process_pod - process a pod pod tag, thus stop ignoring pod directives
# until we see a corresponding cut.
d1016 1
a1016 1
# process_for - process a =for pod tag.  if it's for html, spit
d1056 1
a1056 1
    pop( @@begin_stack );
d1060 3
a1062 1
# process_pre - indented paragraph, made into <PRE></PRE>
d1064 5
a1068 3
sub process_pre {
    my( $text ) = @@_;
    my( $rest );
d1071 2
d1075 3
a1077 2
    # insert spaces in place of tabs
    $rest =~ s#.*#
d1083 19
a1101 38
    # convert some special chars to HTML escapes
    $rest =~ s/&/&amp;/g;
    $rest =~ s/</&lt;/g;
    $rest =~ s/>/&gt;/g;
    $rest =~ s/"/&quot;/g;

    # try and create links for all occurrences of perl.* within
    # the preformatted text.
    $rest =~ s{
	         (\s*)(perl\w+)
	      }{
		 if ( defined $pages{$2} ){	# is a link
		     qq($1<A HREF="$htmlroot/$pages{$2}">$2</A>);
		 } elsif (defined $pages{dosify($2)}) {	# is a link
		     qq($1<A HREF="$htmlroot/$pages{dosify($2)}">$2</A>);
		 } else {
		     "$1$2";
		 }
	      }xeg;
     $rest =~ s{
		 (<A\ HREF="?) ([^>:]*:)? ([^>:]*) \.pod: ([^>:]*:)?
               }{
                  my $url ;
                  if ( $htmlfileurl ne '' ){
		     # Here, we take advantage of the knowledge 
		     # that $htmlfileurl ne '' implies $htmlroot eq ''.
		     # Since $htmlroot eq '', we need to prepend $htmldir
		     # on the fron of the link to get the absolute path
		     # of the link's target. We check for a leading '/'
		     # to avoid corrupting links that are #, file:, etc.
		     my $old_url = $3 ;
		     $old_url = "$htmldir$old_url" if $old_url =~ m{^\/};
 		     $url = relativize_url( "$old_url.html", $htmlfileurl );
	          } else {
		     $url = "$3.html" ;
		  }
		  "$1$url" ;
	       }xeg;
d1103 1
a1103 4
    # Look for embedded URLs and make them into links.  We don't
    # relativize them since they are best left as the author intended.

    my $urls = '(' . join ('|', qw{
d1115 4
a1118 4
    my $ltrs = '\w';
    my $gunk = '/#~:.?+=&%@@!\-';
    my $punc = '.:?\-';
    my $any  = "${ltrs}${gunk}${punc}";
d1120 1
a1120 1
    $rest =~ s{
a1123 1
	  (?!:)                     # Ignore File::, among others.
d1137 60
a1196 3
    # text should be as it is (verbatim)
    $$text = $rest;
}
d1198 31
d1230 10
a1239 9
#
# pure text processing
#
# pure_text/inIS_text: differ with respect to automatic C<> recognition.
# we don't want this to happen within IS
#
sub pure_text($){
    my $text = shift();
    process_puretext( $text, \$ptQuote, 1 );
d1242 8
a1249 4
sub inIS_text($){
    my $text = shift();
    process_puretext( $text, \$ptQuote, 0 );
}
d1256 2
a1257 1
    my($text, $quote, $notinIS) = @@_;
d1259 3
a1261 3
    ## Guessing at func() or [$@@%&]*var references in plain text is destined
    ## to produce some strange looking ref's. uncomment to disable:
    ## $notinIS = 0;
d1263 2
a1264 8
    my(@@words, $lead, $trail);

    # convert double-quotes to single-quotes
    if( $$quote && $text =~ s/"/''/s ){
        $$quote = 0;
    }
    while ($text =~ s/"([^"]*)"/``$1''/sg) {};
    $$quote = 1 if $text =~ s/"/``/s;
d1267 2
a1268 2
    $lead  = ($text =~ s/\A(\s+)//s ? $1 : "");
    $trail = ($text =~ s/(\s+)\Z//s ? $1 : "");
d1270 3
a1272 2
    # split at space/non-space boundaries
    @@words = split( /(?<=\s)(?=\S)|(?<=\S)(?=\s)/, $text );
a1275 2
	# skip space runs
 	next if $word =~ /^\s*$/;
d1277 1
a1277 1
	if( $notinIS && $word =~ /^(\w+)\((.*)\)$/ ) {
d1279 18
a1296 17
            ## try for a pagename (perlXXX(1))?
            my( $func, $args ) = ( $1, $2 );
            if( $args =~ /^\d+$/ ){
                my $url = page_sect( $word, '' );
                if( defined $url ){
                    $word = "<A HREF=\"$url\">the $word manpage</A>";
                    next;
                }
            }
            ## try function name for a link, append tt'ed argument list
            $word = emit_C( $func, '', "($args)");

#### disabled. either all (including $\W, $\w+{.*} etc.) or nothing.
##      } elsif( $notinIS && $word =~ /^[\$\@@%&*]+\w+$/) {
##	    # perl variables, should be a C<> ref
##	    $word = emit_C( $word );

a1298 1
            # Don't relativize it: leave it as the author intended
d1314 6
a1319 3
    # put everything back together
    return $lead . join( '', @@words ) . $trail;
}
d1321 2
a1322 201

#
# process_text - handles plaintext that appears in the input pod file.
# there may be pod commands embedded within the text so those must be
# converted to html commands.
#

sub process_text1($$;$$);
sub pattern ($) { $_[0] ? '[^\S\n]+'.('>' x ($_[0] + 1)) : '>' }
sub closing ($) { local($_) = shift; (defined && s/\s+$//) ? length : 0 }

sub process_text {
    return if $ignore;
    my( $tref ) = @@_;
    my $res = process_text1( 0, $tref );
    $$tref = $res;
}

sub process_text1($$;$$){
    my( $lev, $rstr, $func, $closing ) = @@_;
    my $res = '';

    unless (defined $func) {
	$func = '';
	$lev++;
    }

    if( $func eq 'B' ){
	# B<text> - boldface
	$res = '<STRONG>' . process_text1( $lev, $rstr ) . '</STRONG>';

    } elsif( $func eq 'C' ){
	# C<code> - can be a ref or <CODE></CODE>
	# need to extract text
	my $par = go_ahead( $rstr, 'C', $closing );

	## clean-up of the link target
        my $text = depod( $par );

	### my $x = $par =~ /[BI]</ ? 'yes' : 'no' ;
        ### print STDERR "-->call emit_C($par) lev=$lev, par with BI=$x\n"; 

	$res = emit_C( $text, $lev > 1 || ($par =~ /[BI]</) );

    } elsif( $func eq 'E' ){
	# E<x> - convert to character
	$$rstr =~ s/^(\w+)>//;
	$res = "&$1;";

    } elsif( $func eq 'F' ){
	# F<filename> - italizice
	$res = '<EM>' . process_text1( $lev, $rstr ) . '</EM>';

    } elsif( $func eq 'I' ){
	# I<text> - italizice
	$res = '<EM>' . process_text1( $lev, $rstr ) . '</EM>';

    } elsif( $func eq 'L' ){
	# L<link> - link
	## L<text|cross-ref> => produce text, use cross-ref for linking 
	## L<cross-ref> => make text from cross-ref
	## need to extract text
	my $par = go_ahead( $rstr, 'L', $closing );

        # some L<>'s that shouldn't be:
	# a) full-blown URL's are emitted as-is
        if( $par =~ m{^\w+://}s ){
	    return make_URL_href( $par );
	}
        # b) C<...> is stripped and treated as C<>
        if( $par =~ /^C<(.*)>$/ ){
	    my $text = depod( $1 );
 	    return emit_C( $text, $lev > 1 || ($par =~ /[BI]</) );
	}

	# analyze the contents
	$par =~ s/\n/ /g;   # undo word-wrapped tags
        my $opar = $par;
	my $linktext;
	if( $par =~ s{^([^|]+)\|}{} ){
	    $linktext = $1;
	}
    
	# make sure sections start with a /
	$par =~ s{^"}{/"};

	my( $page, $section, $ident );

	# check for link patterns
	if( $par =~ m{^([^/]+?)/(?!")(.*?)$} ){     # name/ident
            # we've got a name/ident (no quotes) 
            ( $page, $ident ) = ( $1, $2 );
            ### print STDERR "--> L<$par> to page $page, ident $ident\n";

	} elsif( $par =~ m{^(.*?)/"?(.*?)"?$} ){ # [name]/"section"
            # even though this should be a "section", we go for ident first
	    ( $page, $ident ) = ( $1, $2 );
            ### print STDERR "--> L<$par> to page $page, section $section\n";

	} elsif( $par =~ /\s/ ){  # this must be a section with missing quotes
	    ( $page, $section ) = ( '', $par );
            ### print STDERR "--> L<$par> to void page, section $section\n";

        } else {
	    ( $page, $section ) = ( $par, '' );
            ### print STDERR "--> L<$par> to page $par, void section\n";
	}

        # now, either $section or $ident is defined. the convoluted logic
        # below tries to resolve L<> according to what the user specified.
        # failing this, we try to find the next best thing...
        my( $url, $ltext, $fid );

        RESOLVE: {
            if( defined $ident ){
                ## try to resolve $ident as an item
	        ( $url, $fid ) = coderef( $page, $ident );
                if( $url ){
                    if( ! defined( $linktext ) ){
                        $linktext = $ident;
                        $linktext .= " in " if $ident && $page;
                        $linktext .= "the $page manpage" if $page;
                    }
                    ###  print STDERR "got coderef url=$url\n";
                    last RESOLVE;
                }
                ## no luck: go for a section (auto-quoting!)
                $section = $ident;
            }
            ## now go for a section
            my $htmlsection = htmlify( $section );
 	    $url = page_sect( $page, $htmlsection );
            if( $url ){
                if( ! defined( $linktext ) ){
                    $linktext = $section;
                    $linktext .= " in " if $section && $page;
                    $linktext .= "the $page manpage" if $page;
                }
                ### print STDERR "got page/section url=$url\n";
                last RESOLVE;
            }
            ## no luck: go for an ident 
            if( $section ){
                $ident = $section;
            } else {
                $ident = $page;
                $page  = undef();
            }
            ( $url, $fid ) = coderef( $page, $ident );
            if( $url ){
                if( ! defined( $linktext ) ){
                    $linktext = $ident;
                    $linktext .= " in " if $ident && $page;
                    $linktext .= "the $page manpage" if $page;
                }
                ### print STDERR "got section=>coderef url=$url\n";
                last RESOLVE;
            }

            # warning; show some text.
            $linktext = $opar unless defined $linktext;
            warn "$0: $podfile: cannot resolve L<$opar> in paragraph $paragraph.";
        }

        # now we have an URL or just plain code
        $$rstr = $linktext . '>' . $$rstr;
        if( defined( $url ) ){
            $res = "<A HREF=\"$url\">" . process_text1( $lev, $rstr ) . '</A>';
        } else {
	    $res = '<EM>' . process_text1( $lev, $rstr ) . '</EM>';
        }

    } elsif( $func eq 'S' ){
	# S<text> - non-breaking spaces
	$res = process_text1( $lev, $rstr );
	$res =~ s/ /&nbsp;/g;

    } elsif( $func eq 'X' ){
	# X<> - ignore
	$$rstr =~ s/^[^>]*>//;

    } elsif( $func eq 'Z' ){
	# Z<> - empty 
	warn "$0: $podfile: invalid X<> in paragraph $paragraph."
	    unless $$rstr =~ s/^>//;

    } else {
        my $term = pattern $closing;
	while( $$rstr =~ s/\A(.*?)(([BCEFILSXZ])<(<+[^\S\n]+)?|$term)//s ){
	    # all others: either recurse into new function or
	    # terminate at closing angle bracket(s)
	    my $pt = $1;
            $pt .= $2 if !$3 &&  $lev == 1;
	    $res .= $lev == 1 ? pure_text( $pt ) : inIS_text( $pt );
	    return $res if !$3 && $lev > 1;
            if( $3 ){
		$res .= process_text1( $lev, $rstr, $3, closing $4 );
 	    }
	}
	if( $lev == 1 ){
	    $res .= pure_text( $$rstr );
d1324 2
a1325 1
	    warn "$0: $podfile: undelimited $func<> in paragraph $paragraph.";
d1328 4
a1331 2
    return $res;
}
d1333 1
a1333 20
#
# go_ahead: extract text of an IS (can be nested)
#
sub go_ahead($$$){
    my( $rstr, $func, $closing ) = @@_;
    my $res = '';
    my @@closing = ($closing);
    while( $$rstr =~
      s/\A(.*?)(([BCEFILSXZ])<(<+[^\S\n]+)?|@@{[pattern $closing[0]]})//s ){
	$res .= $1;
	unless( $3 ){
	    shift @@closing;
	    return $res unless @@closing;
	} else {
	    unshift @@closing, closing $4;
	}
	$res .= $2;
    }
    warn "$0: $podfile: undelimited $func<> in paragraph $paragraph.";
    return $res;
d1337 1
a1337 2
# emit_C - output result of C<text>
#    $text is the depod-ed text
d1339 2
a1340 8
sub emit_C($;$$){
    my( $text, $nocode, $args ) = @@_;
    $args = '' unless defined $args;
    my $res;
    my( $url, $fid ) = coderef( undef(), $text );

    # need HTML-safe text
    my $linktext = html_escape( "$text$args" );
d1342 1
a1342 9
    if( defined( $url ) &&
        (!defined( $EmittedItem ) || $EmittedItem ne $fid ) ){
	$res = "<A HREF=\"$url\"><CODE>$linktext</CODE></A>";
    } elsif( 0 && $nocode ){
	$res = $linktext;
    } else {
	$res = "<CODE>$linktext</CODE>";
    }
    return $res;
a1345 13
# html_escape: make text safe for HTML
#
sub html_escape {
    my $rest = $_[0];
    $rest   =~ s/&/&amp;/g;
    $rest   =~ s/</&lt;/g;
    $rest   =~ s/>/&gt;/g;
    $rest   =~ s/"/&quot;/g;
    return $rest;
} 


#
a1349 1
    return lc($str) if $^O eq 'VMS';     # VMS just needs casing
d1359 5
a1363 1
# page_sect - make an URL from the text of a L<>
d1365 29
a1393 9
sub page_sect($$) {
    my( $page, $section ) = @@_;
    my( $linktext, $page83, $link);	# work strings

    # check if we know that this is a section in this page
    if (!defined $pages{$page} && defined $sections{$page}) {
	$section = $page;
	$page = "";
        ### print STDERR "reset page='', section=$section\n";
d1399 2
a1400 1
	$link = "#" . htmlify( $section );
d1402 1
a1403 23
	# Search page cache for an entry keyed under the html page name,
	# then look to see what directory that page might be in.  NOTE:
	# this will only find one page. A better solution might be to produce
	# an intermediate page that is an index to all such pages.
	my $page_name = $page ;
	$page_name =~ s,^.*/,,s ;
	if ( defined( $pages{ $page_name } ) && 
	     $pages{ $page_name } =~ /([^:]*$page)\.(?:pod|pm):/ 
	   ) {
	    $page = $1 ;
	}
	else {
	    # NOTE: This branch assumes that all A::B pages are located in
	    # $htmlroot/A/B.html . This is often incorrect, since they are
	    # often in $htmlroot/lib/A/B.html or such like. Perhaps we could
	    # analyze the contents of %pages and figure out where any
	    # cousins of A::B are, then assume that.  So, if A::B isn't found,
	    # but A::C is found in lib/A/C.pm, then A::B is assumed to be in
	    # lib/A/B.pm. This is also limited, but it's an improvement.
	    # Maybe a hints file so that the links point to the correct places
	    # nonetheless?

	}
d1405 1
a1405 1
	$link .= "#" . htmlify( $section ) if ($section);
d1407 1
d1409 1
d1411 2
a1412 2
	$section = htmlify( $section ) if $section ne "";
        ### print STDERR "...section=$section\n";
d1416 1
a1416 2
#	if ($section ne "" && $pages{$page} =~ /([^:]*[^(\.pod|\.pm)]):/) {
	if ($section ne "" && $pages{$page} =~ /([^:]*(?<!\.pod)(?<!\.pm)):/) {
a1417 1
            ### print STDERR "...link=$link\n";
d1423 1
a1423 3
	    $section = "#$section" if $section;
            ### print STDERR "...section=$section\n";

d1430 2
d1433 1
d1438 1
d1440 1
a1440 16
	# Here, we take advantage of the knowledge that $htmlfileurl ne ''
	# implies $htmlroot eq ''. This means that the link in question
	# needs a prefix of $htmldir if it begins with '/'. The test for
	# the initial '/' is done to avoid '#'-only links, and to allow
	# for other kinds of links, like file:, ftp:, etc.
        my $url ;
        if (  $htmlfileurl ne '' ) {
            $link = "$htmldir$link" if $link =~ m{^/}s;
            $url = relativize_url( $link, $htmlfileurl );
# print( "  b: [$link,$htmlfileurl,$url]\n" );
	}
	else {
            $url = $link ;
	}
	return $url;

d1442 1
a1442 1
	return undef();
d1444 1
d1448 2
a1449 2
# relativize_url - convert an absolute URL to one relative to a base URL.
# Assumes both end in a filename.
d1451 6
a1456 2
sub relativize_url {
    my ($dest,$source) = @@_ ;
d1458 11
a1468 3
    my ($dest_volume,$dest_directory,$dest_file) = 
        File::Spec::Unix->splitpath( $dest ) ;
    $dest = File::Spec::Unix->catpath( $dest_volume, $dest_directory, '' ) ;
d1470 5
a1474 3
    my ($source_volume,$source_directory,$source_file) = 
        File::Spec::Unix->splitpath( $source ) ;
    $source = File::Spec::Unix->catpath( $source_volume, $source_directory, '' ) ;
d1476 11
a1486 3
    my $rel_path = '' ;
    if ( $dest ne '' ) {
       $rel_path = File::Spec::Unix->abs2rel( $dest, $source ) ;
a1488 9
    if ( $rel_path ne ''                && 
         substr( $rel_path, -1 ) ne '/' &&
         substr( $dest_file, 0, 1 ) ne '#' 
        ) {
        $rel_path .= "/$dest_file" ;
    }
    else {
        $rel_path .= "$dest_file" ;
    }
d1490 1
a1490 1
    return $rel_path ;
a1492 1

d1494 1
a1494 1
# coderef - make URL from the text of a C<>
d1496 2
a1497 16
sub coderef($$){
    my( $page, $item ) = @@_;
    my( $url );

    my $fid = fragment_id( $item );
    if( defined( $page ) ){
	# we have been given a $page...
	$page =~ s{::}{/}g;

	# Do we take it? Item could be a section!
	my $base = $items{$fid} || "";
	$base =~ s{[^/]*/}{};
	if( $base ne "$page.html" ){
            ###   print STDERR "coderef( $page, $item ): items{$fid} = $items{$fid} = $base => discard page!\n";
	    $page = undef();
	}
d1499 2
a1500 9
    } else {
        # no page - local items precede cached items
	if( defined( $fid ) ){
	    if(  exists $local_items{$fid} ){
		$page = $local_items{$fid};
	    } else {
		$page = $items{$fid};
	    }
	}
d1503 2
a1504 8
    # if there was a pod file that we found earlier with an appropriate
    # =item directive, then create a link to that page.
    if( defined $page ){
	if( $page ){
            if( exists $pages{$page} and $pages{$page} =~ /([^:.]*)\.[^:]*:/){
		$page = $1 . '.html';
	    }
	    my $link = "$htmlroot/$page#item_$fid";
d1506 6
a1511 11
	    # Here, we take advantage of the knowledge that $htmlfileurl
	    # ne '' implies $htmlroot eq ''.
	    if (  $htmlfileurl ne '' ) {
		$link = "$htmldir$link" ;
		$url = relativize_url( $link, $htmlfileurl ) ;
	    } else {
		$url = $link ;
	    }
	} else {
	    $url = "#item_" . $fid;
	}
d1513 3
a1515 3
	confess "url has space: $url" if $url =~ /"[^"]*\s[^"]*"/;
    }       
    return( $url, $fid );
d1518 6
d1525 4
d1531 5
a1535 8
# Adapted from Nick Ing-Simmons' PodToHtml package.
sub relative_url {
    my $source_file = shift ;
    my $destination_file = shift;

    my $source = URI::file->new_abs($source_file);
    my $uo = URI::file->new($destination_file,$source)->abs;
    return $uo->rel->as_string;
d1552 1
a1552 2
# specification for HTML. Note that we keep spaces and special characters
# except ", ? (Netscape problem) and the hyphen (writer's problem...).
d1555 15
a1569 9
    my( $heading) = @@_;
    $heading =~ s/(\s+)/ /g;
    $heading =~ s/\s+\Z//;
    $heading =~ s/\A\s+//;
    # The hyphen is a disgrace to the English language.
    $heading =~ s/[-"?]//g;
    $heading = lc( $heading );
    return $heading;
}
d1571 1
a1571 98
#
# depod - convert text by eliminating all interior sequences
# Note: can be called with copy or modify semantics
#
my %E2c;
$E2c{lt}     = '<';
$E2c{gt}     = '>';
$E2c{sol}    = '/';
$E2c{verbar} = '|';
$E2c{amp}    = '&'; # in Tk's pods

sub depod1($;$$);

sub depod($){
    my $string;
    if( ref( $_[0] ) ){
	$string =  ${$_[0]};
        ${$_[0]} = depod1( \$string );
    } else {
	$string =  $_[0];
        depod1( \$string );
    }    
}

sub depod1($;$$){
  my( $rstr, $func, $closing ) = @@_;
  my $res = '';
  return $res unless defined $$rstr;
  if( ! defined( $func ) ){
      # skip to next begin of an interior sequence
      while( $$rstr =~ s/\A(.*?)([BCEFILSXZ])<(<+[^\S\n]+)?// ){
         # recurse into its text
	  $res .= $1 . depod1( $rstr, $2, closing $3);
      }
      $res .= $$rstr;
  } elsif( $func eq 'E' ){
      # E<x> - convert to character
      $$rstr =~ s/^(\w+)>//;
      $res .= $E2c{$1} || "";
  } elsif( $func eq 'X' ){
      # X<> - ignore
      $$rstr =~ s/^[^>]*>//;
  } elsif( $func eq 'Z' ){
      # Z<> - empty 
      $$rstr =~ s/^>//;
  } else {
      # all others: either recurse into new function or
      # terminate at closing angle bracket
      my $term = pattern $closing;
      while( $$rstr =~ s/\A(.*?)(([BCEFILSXZ])<(<+[^\S\n]+)?|$term)// ){
	  $res .= $1;
	  last unless $3;
          $res .= depod1( $rstr, $3, closing $4 );
      }
      ## If we're here and $2 ne '>': undelimited interior sequence.
      ## Ignored, as this is called without proper indication of where we are.
      ## Rely on process_text to produce diagnostics.
  }
  return $res;
}

#
# fragment_id - construct a fragment identifier from:
#   a) =item text
#   b) contents of C<...>
#
my @@hc;
sub fragment_id {
    my $text = shift();
    $text =~ s/\s+\Z//s;
    if( $text ){
	# a method or function?
	return $1 if $text =~ /(\w+)\s*\(/;
	return $1 if $text =~ /->\s*(\w+)\s*\(?/;

	# a variable name?
	return $1 if $text =~ /^([$@@%*]\S+)/;

	# some pattern matching operator?
	return $1 if $text =~ m|^(\w+/).*/\w*$|;

	# fancy stuff... like "do { }"
	return $1 if $text =~ m|^(\w+)\s*{.*}$|;

	# honour the perlfunc manpage: func [PAR[,[ ]PAR]...]
	# and some funnies with ... Module ...
	return $1 if $text =~ m{^([a-z\d]+)(\s+[A-Z\d,/& ]+)?$};
	return $1 if $text =~ m{^([a-z\d]+)\s+Module(\s+[A-Z\d,/& ]+)?$};

	# text? normalize!
	$text =~ s/\s+/_/sg;
	$text =~ s{(\W)}{
         defined( $hc[ord($1)] ) ? $hc[ord($1)]
                 : ( $hc[ord($1)] = sprintf( "%%%02X", ord($1) ) ) }gxe;
        $text = substr( $text, 0, 50 );
    } else {
	return undef();
    }
d1574 1
a1574 11
#
# make_URL_href - generate HTML href from URL
# Special treatment for CGI queries.
#
sub make_URL_href($){
    my( $url ) = @@_;
    if( $url !~ 
        s{^(http:[-\w/#~:.+=&%@@!]+)(\?.*)$}{<A HREF="$1$2">$1</A>}i ){
        $url = "<A HREF=\"$url\">$url</A>";
    }
    return $url;
@


1.1.1.3
log
@stock perl 5.6.1
@
text
@a895 4
	} elsif (/\.html\z/) { 	    	    	    	    # .html
	    s/\.html\z//;
	    $pages{$_}  = "" unless defined $pages{$_};
	    $pages{$_} .= "$dir/$_.pod:";
d1441 2
a1442 4
	$$rstr =~ s/^([^>]*)>//;
	my $escape = $1;
	$escape =~ s/^(\d+|X[\dA-F]+)$/#$1/i;
	$res = "&$escape;";
d1943 1
a1943 1
      $$rstr =~ s/^([^>]*)>//;
@


1.1.1.4
log
@stock perl 5.8.0 from CPAN
@
text
@d6 1
a6 1
$VERSION = 1.04;
a12 1
use File::Spec;
d15 1
d44 2
a45 8
Adds "Back to Top" links in front of every C<head1> heading (except for
the first).  By default, no backlinks are generated.

=item cachedir

    --cachedir=name

Creates the item and directory caches in the given directory.
d51 1
a51 2
Specify the URL of a cascading style sheet.  Also disables all HTML/CSS
C<style> attributes that are output by default (to avoid conflicts).
d64 2
a65 2
Creates header and footer blocks containing the text of the C<NAME>
section.  By default, no headers are generated.
d115 2
a116 1
B<Deprecated>, has no effect. For backwards compatibility only.
d130 1
a130 1
HTML converted forms can be linked to in cross references.
d172 1
a172 1
	     "--podpath=lib:ext:pod:vms",
d182 1
a182 1
Uses C<$Config{pod2html}> to setup default options.
a197 2
my $cachedir = ".";		# The directory to which item and directory
				# caches will be written.
d216 1
a216 1
my $podroot = File::Spec->curdir;		# filesystem base directory from which all
d233 1
d237 1
a237 1
				#   to prevent the first <hr /> directive.
d263 1
a263 1
$podroot = File::Spec->curdir;		# filesystem base directory from which all
d280 1
d284 1
a284 1
				#   to prevent the first <hr /> directive.
d304 2
a305 1
    for my $i ( 0..$#{$dataref} ) {
d309 1
a309 1
      if( ${$dataref}[$i] =~ /^\s+$/m and $dataref->[$i] !~ /^\s/ ){
a332 3
    # escape the backlink argument (same goes for title but is done later...)
    $backlink = html_escape($backlink) if defined $backlink;

d335 1
a335 1
    unless (@@ARGV && $ARGV[0]) {
d342 1
a342 1
    }
d347 1
a347 1
       && defined( $htmldir )
d349 2
a350 2
       && substr( $htmlfile, 0, length( $htmldir ) ) eq $htmldir
       )
d353 1
a353 1
	# as the location from which to calculate relative links
a363 19

    # be eol agnostic
    for (@@poddata) {
	if (/\r/) {
	    if (/\r\n/) {
		@@poddata = map { s/\r\n/\n/g;
				 /\n\n/ ?
				     map { "$_\n\n" } split /\n\n/ :
				     $_ } @@poddata;
	    } else {
		@@poddata = map { s/\r/\n/g;
				 /\n\n/ ?
				     map { "$_\n\n" } split /\n\n/ :
				     $_ } @@poddata;
	    }
	    last;
	}
    }

d380 1
a380 1
 	    for (my $i = 0; $i < @@poddata; $i++) {
d382 1
a382 1
 		    for my $para ( @@poddata[$i, $i+1] ) {
d386 1
a386 1
		}
d388 1
a388 1
	    }
d393 1
a393 1
 	for (my $i = 0; $i < @@poddata; $i++) {
d395 1
a395 1
	}
d398 1
a398 1
    }
d402 1
a402 1
	warn "$0: no title for $podfile.\n" unless $quiet;
d407 10
a416 20
    $title = html_escape($title);

    my $csslink = '';
    my $bodystyle = ' style="background-color: white"';
    my $tdstyle = ' style="background-color: #cccccc"';

    if ($css) {
      $csslink = qq(\n<link rel="stylesheet" href="$css" type="text/css" />);
      $csslink =~ s,\\,/,g;
      $csslink =~ s,(/.):,$1|,;
      $bodystyle = '';
      $tdstyle = '';
    }

      my $block = $header ? <<END_OF_BLOCK : '';
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block"$tdstyle valign="middle">
<big><strong><span class="block">&nbsp;$title</span></strong></big>
</td></tr>
</table>
d420 5
a424 6
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>$title</title>$csslink
<link rev="made" href="mailto:$Config{perladmin}" />
</head>
d426 1
a426 1
<body$bodystyle>
d440 1
a440 1
    print HTML "<p><a name=\"__index__\"></a></p>\n";
d446 1
a446 1
    print HTML "<hr />\n" if $doindex and $index;
a449 1
    my $need_dd = 0;
a458 1
	    $need_dd = 0;
d474 3
a476 1
		    $need_dd = process_item( $1 );
a494 2
	    print HTML and next if @@begin_stack && $begin_stack[-1] eq 'html';
	    print HTML "<dd>\n" if $need_dd;
d498 1
a498 1
	        print HTML "<pre>\n$text</pre>\n";
d516 4
a519 4
			    $text =~ s/\t+/<td>/g;
			    $text =~ s/^/<tr><td>/gm;
			    $text = '<table cellspacing="0" cellpadding="0">' .
                                    $text . '</table>';
d529 1
a529 1
		    print HTML "<p>$text</p>\n";
a531 1
	    print HTML "</dd>\n" if $need_dd;
d540 1
a540 1
    print HTML "<p><a href=\"#__index__\"><small>$backlink</small></a></p>\n"
d545 1
a545 1
</body>
d547 1
a547 1
</html>
d569 1
a569 1
           --netscape --norecurse --noindex --cachedir=<name>
a571 1
  --cachedir     - directory for the item and directory cache files.
d587 2
a599 1
  --[no]netscape - deprecated, has no effect. for backwards compatibility only.
d604 4
a607 4
    my ($opt_backlink,$opt_cachedir,$opt_css,$opt_flush,$opt_header,$opt_help,
	$opt_htmldir,$opt_htmlroot,$opt_index,$opt_infile,$opt_libpods,
	$opt_netscape,$opt_outfile,$opt_podpath,$opt_podroot,$opt_quiet,
	$opt_recurse,$opt_title,$opt_verbose);
a611 1
			    'cachedir=s' => \$opt_cachedir,
a638 1
    $cachedir = $opt_cachedir if defined $opt_cachedir;
d645 1
a654 2
    $dircache = "$cachedir/pod2htmd$cache_ext";
    $itemcache = "$cachedir/pod2htmi$cache_ext";
d935 2
a936 2
      if ($line =~ /^=(head)([1-6])\s+(.*)/) {
        ($tag, $which_head, $otitle) = ($1,$2,$3);
d938 4
a941 4
        my $title = depod( $otitle );
        my $name = anchorify( $title );
        $$sections{$name} = 1;
        $title = process_text( \$otitle );
d945 1
a945 1
		    $index .= "\n" . ("\t" x $listdepth) . "<ul>\n";
d949 1
a949 1
		    $index .= "\n" . ("\t" x $listdepth) . "</ul>\n";
d953 3
a955 3
	    $index .= "\n" . ("\t" x $listdepth) . "<li>" .
	              "<a href=\"#" . $name . "\">" .
		      $title . "</a></li>";
d961 1
a961 1
	$index .= "\n" . ("\t" x $listdepth) . "</ul>\n";
d965 1
a965 1
    $index =~ s,\t*<ul>\s*</ul>\n,,g;
d1021 1
a1021 1
    print HTML "<p>\n";
d1023 3
a1025 5
      print HTML "<a href=\"#__index__\"><small>$backlink</small></a>\n"
        if $hasindex and $backlink;
      print HTML "</p>\n<hr />\n"
    } else {
      print HTML "</p>\n";
d1028 1
a1028 1
    my $name = anchorify( depod( $heading ) );
d1030 1
a1030 1
    print HTML "<h$level><a name=\"$name\">$convert</a></h$level>\n";
d1047 1
a1047 1
    print HTML '<strong>';
d1051 2
a1052 3
        my $name = 'item_' . $item;
        $name = anchorify($name);
	print HTML qq{<a name="$name">}, process_text( \$otext ), '</a>';
d1054 1
a1054 1
    print HTML "</strong><br />\n";
d1064 1
a1064 3
    my $emitted = $tag eq 'dl' ? 'dt' : 'li';
    print HTML "<$emitted>";
    return $emitted;
a1071 1
    my $need_dd = 0; # set to 1 if we need a <dd></dd> after an item
d1083 1
a1083 1
	print HTML "<p></p>\n";
a1089 2
    my $emitted; # the tag actually emitted, used for closing

d1092 6
a1097 6
        $emitted = emit_li( 'ul' );
        if ($text =~ /\A\*\s+(.+)\Z/s ) { # with additional text
            my $tag = $1;
            $otext =~ s/\A\*\s+//;
            emit_item_tag( $otext, $tag, 1 );
        }
d1100 6
a1105 6
        $emitted = emit_li( 'ol' );
        if ($text =~ /\A(?>\d+\.?)\s*(.+)\Z/s ) { # with additional text
            my $tag = $1;
            $otext =~ s/\A\d+\.?\s*//;
            emit_item_tag( $otext, $tag, 1 );
        }
d1108 5
a1112 5
        $emitted = emit_li( 'dl' );
        if ($text =~ /\A(.+)\Z/s ){ # should have text
            emit_item_tag( $otext, $text, 1 );
        }
        $need_dd = 1;
a1113 1
    print HTML "</$emitted>" if $emitted;
a1114 1
    return $need_dd;
d1141 1
a1141 1
	print HTML '<p></p>' if $after_lpar;
d1160 1
a1160 1
# process_pod - process a pod tag, thus stop ignoring pod directives
d1180 1
a1180 1
        print HTML qq{<p align="center"><img src="$text" alt="$text illustration" /></p>};
d1207 1
a1207 1
    }
d1212 1
a1212 1
# process_pre - indented paragraph, made into <pre></pre>
d1222 3
a1224 3
    $rest =~ s#(.+)#
	    my $line = $1;
            1 while $line =~ s/(\t+)/' ' x ((length($1) * 8) - $-[0] % 8)/e;
d1229 4
a1232 1
    $rest = html_escape($rest);
d1240 1
a1240 1
		     qq($1<a href="$htmlroot/$pages{$2}">$2</a>);
d1242 1
a1242 1
		     qq($1<a href="$htmlroot/$pages{dosify($2)}">$2</a>);
d1248 1
a1248 1
		 (<a\ href="?) ([^>:]*:)? ([^>:]*) \.pod: ([^>:]*:)?
d1252 1
a1252 1
		     # Here, we take advantage of the knowledge
d1279 1
a1279 1
            } )
d1281 1
a1281 1

d1284 1
a1284 1
    my $punc = '.:!?\-;';
d1292 4
a1295 3
          [$any] +?                 # followed by one or more of any valid
                                    #   character, but be conservative and
                                    #   take only what you need to....
d1298 2
a1299 6
                [$punc]*            # either 0 or more punctuation
                (?:                 #   followed
                    [^$any]         #   by a non-url char
                    |               #   or
                    $               #   end of the string
                )                   #
d1303 1
a1303 1
      }{<a href="$1">$1</a>}igox;
d1365 1
a1365 1
                    $word = "<a href=\"$url\">the $word manpage</a>";
d1380 1
a1380 1
	    $word = qq(<a href="$word">$word</a>);
d1386 5
a1390 2
	    $word = qq($w1<a href="mailto:$w2">$w2</a>$w3);
	} else {
d1428 1
a1428 1
	$res = '<strong>' . process_text1( $lev, $rstr ) . '</strong>';
d1431 1
a1431 1
	# C<code> - can be a ref or <code></code>
d1439 1
a1439 1
        ### print STDERR "-->call emit_C($par) lev=$lev, par with BI=$x\n";
d1452 1
a1452 1
	$res = '<em>' . process_text1( $lev, $rstr ) . '</em>';
d1456 1
a1456 1
	$res = '<em>' . process_text1( $lev, $rstr ) . '</em>';
d1460 1
a1460 1
	## L<text|cross-ref> => produce text, use cross-ref for linking
d1483 1
a1483 1

d1491 1
a1491 1
            # we've got a name/ident (no quotes)
d1542 1
a1542 1
            ## no luck: go for an ident
d1562 1
a1562 1
            warn "$0: $podfile: cannot resolve L<$opar> in paragraph $paragraph.\n";
d1565 1
a1565 1
        # now we have a URL or just plain code
d1568 1
a1568 1
            $res = "<a href=\"$url\">" . process_text1( $lev, $rstr ) . '</a>';
d1570 1
a1570 1
	    $res = '<em>' . process_text1( $lev, $rstr ) . '</em>';
d1583 2
a1584 2
	# Z<> - empty
	warn "$0: $podfile: invalid X<> in paragraph $paragraph.\n"
d1603 1
a1603 1
	    warn "$0: $podfile: undelimited $func<> in paragraph $paragraph.\n";
d1627 1
a1627 1
    warn "$0: $podfile: undelimited $func<> in paragraph $paragraph.\n";
d1646 1
a1646 1
	$res = "<a href=\"$url\"><code>$linktext</code></a>";
d1650 1
a1650 1
	$res = "<code>$linktext</code>";
a1663 2
    # &apos; is only in XHTML, not HTML4.  Be conservative
    #$rest   =~ s/'/&apos;/g;
d1665 1
a1665 1
}
d1683 1
a1683 1
# page_sect - make a URL from the text of a L<>
d1699 1
a1699 1
        $link = "#" . anchorify( $section );
d1708 2
a1709 2
	if ( defined( $pages{ $page_name } ) &&
	     $pages{ $page_name } =~ /([^:]*$page)\.(?:pod|pm):/
d1726 1
a1726 1
	$link .= "#" . anchorify( $section ) if ($section);
d1730 1
a1730 1
	$section = anchorify( $section ) if $section ne "";
d1787 1
a1787 1
    my ($dest_volume,$dest_directory,$dest_file) =
d1791 1
a1791 1
    my ($source_volume,$source_directory,$source_file) =
d1800 1
a1800 1
    if ( $rel_path ne ''                &&
d1802 1
a1802 1
         substr( $dest_file, 0, 1 ) ne '#'
d1852 1
a1852 1
	    my $link = "$htmlroot/$page#item_" . anchorify($fid);
d1863 1
a1863 1
	    $url = "#item_" . anchorify($fid);
d1867 1
a1867 1
    }
d1891 1
a1891 1
	print HTML "</dl>\n";
a1912 10
# similar to htmlify, but turns spaces into underscores
#
sub anchorify {
    my ($anchor) = @@_;
    $anchor = htmlify($anchor);
    $anchor =~ s/\s/_/g; # fixup spaces left by htmlify
    return $anchor;
}

#
d1933 1
a1933 1
    }
d1955 1
a1955 1
      # Z<> - empty
d2018 3
a2020 3
    if( $url !~
        s{^(http:[-\w/#~:.+=&%@@!]+)(\?.*)$}{<a href="$1$2">$1</a>}i ){
        $url = "<a href=\"$url\">$url</a>";
@


1.1.1.5
log
@perl 5.8.2 from CPAN
@
text
@d5 2
a6 2
use vars qw($VERSION @@ISA @@EXPORT @@EXPORT_OK);
$VERSION = 1.0501;
a8 1
@@EXPORT_OK = qw(anchorify);
d204 5
d210 1
a210 20
my($Cachedir);
my($Dircache, $Itemcache);
my @@Begin_Stack;
my @@Libpods;
my($Htmlroot, $Htmldir, $Htmlfile, $Htmlfileurl);
my($Podfile, @@Podpath, $Podroot);
my $Css;

my $Recurse;
my $Quiet;
my $Verbose;
my $Doindex;

my $Backlink;
my($Listlevel, @@Listend);
my $After_Lpar;
use vars qw($Ignore);  # need to localize it later.

my(%Items_Named, @@Items_Seen);
my($Title, $Header);
d212 26
a237 2
my $Top;
my $Paragraph;
d239 10
a248 4
my %Sections;

# Caches
my %Pages = ();			# associative array used to find the location
d250 2
a251 1
my %Items = ();			# associative array used to find the location
d253 2
a254 8

my %Local_Items;
my $Is83;
my $PTQuote;

my $Curdir = File::Spec->curdir;

init_globals();
d257 2
a258 5
    $Cachedir = ".";		# The directory to which item and directory
				# caches will be written.

    $Dircache = "pod2htmd.tmp";
    $Itemcache = "pod2htmi.tmp";
d260 1
a260 1
    @@Begin_Stack = ();		# begin/end stack
d262 2
a263 2
    @@Libpods = ();	    	# files to search for links from C<> directives
    $Htmlroot = "/";	    	# http-server base directory from which all
d265 1
a265 1
    $Htmldir = "";	    	# The directory to which the html pages
d267 4
a270 9
    $Htmlfile = "";		# write to stdout by default
    $Htmlfileurl = "" ;		# The url that other files would use to
				# refer to this file.  This is only used
				# to make relative urls that point to
				# other files.

    $Podfile = "";		# read from stdin by default
    @@Podpath = ();		# list of directories containing library pods.
    $Podroot = $Curdir;	        # filesystem base directory from which all
d272 10
a281 10
    $Css = '';                  # Cascading style sheet
    $Recurse = 1;		# recurse on subdirectories in $podpath.
    $Quiet = 0;		        # not quiet by default
    $Verbose = 0;		# not verbose by default
    $Doindex = 1;   	    	# non-zero if we should generate an index
    $Backlink = '';		# text for "back to top" links
    $Listlevel = 0;		# current list depth
    @@Listend = ();		# the text to use to end the list.
    $After_Lpar = 0;            # set to true after a par in an =item
    $Ignore = 1;		# whether or not to format text.  we don't
d285 5
a289 5
    @@Items_Seen = ();	        # for multiples of the same item in perlfunc
    %Items_Named = ();
    $Header = 0;		# produce block header/footer
    $Title = '';		# title to give the pod(s)
    $Top = 1;			# true if we are at the top of the doc.  used
d291 1
a291 1
    $Paragraph = '';		# which paragraph we're processing (used
d293 1
a293 2
    $PTQuote = 0;               # status of double-quote conversion
    %Sections = ();		# sections within this page
d295 8
a302 2
    %Local_Items = ();
    $Is83 = $^O eq 'dos';       # Is it an 8.3 filesystem?
d331 1
a331 1
    # cache of %Pages and %Items from last time we ran pod2html
d339 1
a339 1
    $Backlink = html_escape($Backlink) if defined $Backlink;
d344 3
a346 3
	$Podfile  = "-" unless $Podfile;	# stdin
	open(POD, "<$Podfile")
		|| die "$0: cannot open $Podfile file for input: $!\n";
d348 1
a348 1
	$Podfile = $ARGV[0];  # XXX: might be more filenames
d351 7
a357 7
    $Htmlfile = "-" unless $Htmlfile;	# stdout
    $Htmlroot = "" if $Htmlroot eq "/";	# so we don't get a //
    $Htmldir =~ s#/\z## ;               # so we don't get a //
    if (  $Htmlroot eq ''
       && defined( $Htmldir )
       && $Htmldir ne ''
       && substr( $Htmlfile, 0, length( $Htmldir ) ) eq $Htmldir
d364 1
a364 1
        $Htmlfileurl= "$Htmldir/" . substr( $Htmlfile, length( $Htmldir ) + 1);
d368 1
a368 1
    warn "Scanning for sections in input file(s)\n" if $Verbose;
d394 1
a394 1
    my $index = scan_headings(\%Sections, @@poddata);
d397 1
a397 1
	warn "No headings in $Podfile\n" if $Verbose;
d401 2
a402 2
    open(HTML, ">$Htmlfile")
	    || die "$0: cannot open $Htmlfile file for output: $!\n";
d405 1
a405 1
    if ($Title eq '') {
d411 1
a411 1
			    if ($Title) = $para =~ /(\S+\s+-+.*\S)/s;
d418 1
a418 1
    if (!$Title and $Podfile =~ /\.pod\z/) {
d421 1
a421 1
	    last if ($Title) = $poddata[$i] =~ /^=head[12]\s*(.*)/;
d423 2
a424 2
	warn "adopted '$Title' as title for $Podfile\n"
	    if $Verbose and $Title;
d426 2
a427 2
    if ($Title) {
	$Title =~ s/\s*\(.*\)//;
d429 4
a432 4
	warn "$0: no title for $Podfile.\n" unless $Quiet;
	$Podfile =~ /^(.*)(\.[^.\/]+)?\z/s;
	$Title = ($Podfile eq "-" ? 'No Title' : $1);
	warn "using $Title" if $Verbose;
d434 1
a434 1
    $Title = html_escape($Title);
d440 2
a441 2
    if ($Css) {
      $csslink = qq(\n<link rel="stylesheet" href="$Css" type="text/css" />);
d448 1
a448 1
      my $block = $Header ? <<END_OF_BLOCK : '';
d451 1
a451 1
<big><strong><span class="block">&nbsp;$Title</span></strong></big>
d460 1
a460 1
<title>$Title</title>$csslink
d468 2
a469 2
    # load/reload/validate/cache %Pages and %Items
    get_cache($Dircache, $Itemcache, \@@Podpath, $Podroot, $Recurse);
d472 1
a472 1
    scan_items( \%Local_Items, "", @@poddata);
d474 1
a474 1
    # put an index at the top of the file.  note, if $Doindex is 0 we
d480 1
a480 1
    print HTML "<!--\n" unless $Doindex;
d482 1
a482 1
    print HTML "-->\n" unless $Doindex;
d484 1
a484 1
    print HTML "<hr />\n" if $Doindex and $index;
d489 1
a489 1
    warn "Converting input file $Podfile\n" if $Verbose;
d491 1
a491 1
        $PTQuote = 0; # status of quote conversion
d494 1
a494 1
	$Paragraph = $i+1;
d496 1
a496 1
	    $Ignore = 0;
d509 1
a509 1
		next if @@Begin_Stack && $Begin_Stack[-1] ne 'html';
d512 1
a512 1
		    process_head( $1, $2, $Doindex && $index );
d524 2
a525 2
		    warn "$0: $Podfile: unknown pod directive '$1' in "
		       . "paragraph $Paragraph.  ignoring.\n";
d528 1
a528 1
	    $Top = 0;
d531 3
a533 3
	    next if $Ignore;
	    next if @@Begin_Stack && $Begin_Stack[-1] ne 'html';
	    print HTML and next if @@Begin_Stack && $Begin_Stack[-1] eq 'html';
d567 1
a567 1
		    $After_Lpar = 1;
d581 2
a582 2
    print HTML "<p><a href=\"#__index__\"><small>$Backlink</small></a></p>\n"
	if $Doindex and $index and $Backlink;
d594 1
a594 1
    warn "Finished\n" if $Verbose;
d599 1
d603 4
a606 1
    die <<END_OF_USAGE;
a643 2
}

d677 2
a678 2
    @@Podpath  = split(":", $opt_podpath) if defined $opt_podpath;
    @@Libpods  = split(":", $opt_libpods) if defined $opt_libpods;
d680 14
a693 14
    $Backlink = $opt_backlink if defined $opt_backlink;
    $Cachedir = $opt_cachedir if defined $opt_cachedir;
    $Css      = $opt_css      if defined $opt_css;
    $Header   = $opt_header   if defined $opt_header;
    $Htmldir  = $opt_htmldir  if defined $opt_htmldir;
    $Htmlroot = $opt_htmlroot if defined $opt_htmlroot;
    $Doindex  = $opt_index    if defined $opt_index;
    $Podfile  = $opt_infile   if defined $opt_infile;
    $Htmlfile = $opt_outfile  if defined $opt_outfile;
    $Podroot  = $opt_podroot  if defined $opt_podroot;
    $Quiet    = $opt_quiet    if defined $opt_quiet;
    $Recurse  = $opt_recurse  if defined $opt_recurse;
    $Title    = $opt_title    if defined $opt_title;
    $Verbose  = $opt_verbose  if defined $opt_verbose;
d697 3
a699 5
    $Dircache = "$Cachedir/pod2htmd.tmp";
    $Itemcache = "$Cachedir/pod2htmi.tmp";
    if (defined $opt_flush) {
	1 while unlink($Dircache, $Itemcache);
    }
d703 1
a703 1
my $Saved_Cache_Key;
d715 1
a715 1
    return if $Saved_Cache_Key and $this_cache_key eq $Saved_Cache_Key;
d717 1
a717 1
    # load the cache of %Pages and %Items if possible.  $tests will be
d721 1
a721 1
	warn "scanning for item cache\n" if $Verbose;
d726 1
a726 1
    #  %Pages and %Items.
d728 1
a728 1
	warn "scanning directories in pod-path\n" if $Verbose;
d731 1
a731 1
    $Saved_Cache_Key = cache_key(@@cache_key_args);
d742 1
a742 1
#  are valid caches of %Pages and %Items.  if they are valid then it loads
d772 1
a772 1
    warn "loading item cache\n" if $Verbose;
d775 1
a775 1
	$Items{$1} = $2;
d779 1
a779 1
    warn "scanning for directory cache\n" if $Verbose;
d801 1
a801 1
    warn "loading directory cache\n" if $Verbose;
d804 1
a804 1
	$Pages{$1} = $2;
d815 1
a815 1
#  @@Libpods for =item directives.
d823 2
a824 2
	%Items = ();
	%Pages = ();
d827 1
a827 1
    # scan each directory listed in @@Podpath
d831 1
a831 1
    foreach $dir (@@Podpath) {
d835 2
a836 2
    # scan the pods listed in @@Libpods for =item directives
    foreach $libpod (@@Libpods) {
d839 1
a839 1
	next unless defined $Pages{$libpod} && $Pages{$libpod};
d843 2
a844 2
#	if ($Pages{$libpod} =~ /([^:]*[^(\.pod|\.pm)]):/) {
	if ($Pages{$libpod} =~ /([^:]*(?<!\.pod)(?<!\.pm)):/) {
d860 1
a860 1
		scan_items( \%Items, "$dirname/$pod", @@poddata);
d867 1
a867 1
###		$Items{$1} = "$dirname/$1.html" if $1;
d869 2
a870 2
	} elsif ($Pages{$libpod} =~ /([^:]*\.pod):/ ||
		 $Pages{$libpod} =~ /([^:]*\.pm):/) {
d879 1
a879 1
	    scan_items( \%Items, "$pod", @@poddata);
d890 7
a896 7
    warn "caching items for later use\n" if $Verbose;
    open(CACHE, ">$Itemcache") ||
	die "$0: error open $Itemcache for writing: $!\n";

    print CACHE join(":", @@Podpath) . "\n$podroot\n";
    foreach my $key (keys %Items) {
	print CACHE "$key $Items{$key}\n";
d902 7
a908 7
    warn "caching directories for later use\n" if $Verbose;
    open(CACHE, ">$Dircache") ||
	die "$0: error open $Dircache for writing: $!\n";

    print CACHE join(":", @@Podpath) . "\n$podroot\n";
    foreach my $key (keys %Pages) {
	print CACHE "$key $Pages{$key}\n";
d932 2
a933 2
	    $Pages{$_}  = "" unless defined $Pages{$_};
	    $Pages{$_} .= "$dir/$_:";
d937 2
a938 2
	    $Pages{$_}  = "" unless defined $Pages{$_};
	    $Pages{$_} .= "$dir/$_.pod:";
d942 2
a943 2
	    $Pages{$_}  = "" unless defined $Pages{$_};
	    $Pages{$_} .= "$dir/$_.pod:";
d946 2
a947 2
	    $Pages{$_}  = "" unless defined $Pages{$_};
	    $Pages{$_} .= "$dir/$_.pm:";
d969 3
a971 1
    local $Ignore = 0;
d1011 2
d1058 3
a1060 3
    if( $Listlevel ){
	warn "$0: $Podfile: unterminated list at =head in paragraph $Paragraph.  ignoring.\n";
        while( $Listlevel ){
d1066 3
a1068 3
    if( $level == 1 && ! $Top ){
      print HTML "<a href=\"#__index__\"><small>$Backlink</small></a>\n"
        if $hasindex and $Backlink;
d1094 1
a1094 1
    if ($Items_Named{$item}++) {
d1107 2
a1108 2
    if( $Items_Seen[$Listlevel]++ == 0 ){
	push( @@Listend, "</$tag>" );
d1126 2
a1127 2
    if( $Listlevel == 0 ){
	warn "$0: $Podfile: unexpected =item directive in paragraph $Paragraph.  ignoring.\n";
d1132 1
a1132 1
    if( $After_Lpar ){
d1134 1
a1134 1
	$After_Lpar = 0;
d1176 3
a1178 3
    $Listlevel++;
    push( @@Items_Seen, 0 );
    $After_Lpar = 0;
d1185 2
a1186 2
    if( $Listlevel == 0 ){
	warn "$0: $Podfile: unexpected =back directive in paragraph $Paragraph.  ignoring.\n";
d1190 1
a1190 1
    # close off the list.  note, I check to see if $Listend[$Listlevel] is
d1192 5
a1196 5
    # $Listend[$Listlevel] may have never been initialized.
    $Listlevel--;
    if( defined $Listend[$Listlevel] ){
	print HTML '<p></p>' if $After_Lpar;
	print HTML $Listend[$Listlevel];
d1198 1
a1198 1
        pop( @@Listend );
d1200 1
a1200 1
    $After_Lpar = 0;
d1203 1
a1203 1
    pop( @@Items_Seen );
d1210 1
a1210 1
    $Ignore = 1;
d1218 1
a1218 1
    # no need to set $Ignore to 0 cause the main loop did it
d1246 1
a1246 1
    push (@@Begin_Stack, $whom);
d1259 2
a1260 2
    if ($Begin_Stack[-1] ne $whom ) {
	die "Unmatched begin/end at chunk $Paragraph\n"
d1262 1
a1262 1
    pop( @@Begin_Stack );
d1271 1
a1271 1
    return if $Ignore;
d1290 4
a1293 4
		 if ( defined $Pages{$2} ){	# is a link
		     qq($1<a href="$Htmlroot/$Pages{$2}">$2</a>);
		 } elsif (defined $Pages{dosify($2)}) {	# is a link
		     qq($1<a href="$Htmlroot/$Pages{dosify($2)}">$2</a>);
d1302 1
a1302 1
                  if ( $Htmlfileurl ne '' ){
d1304 2
a1305 2
		     # that $Htmlfileurl ne '' implies $Htmlroot eq ''.
		     # Since $Htmlroot eq '', we need to prepend $Htmldir
d1310 2
a1311 2
		     $old_url = "$Htmldir$old_url" if $old_url =~ m{^\/};
 		     $url = relativize_url( "$old_url.html", $Htmlfileurl );
d1339 17
a1355 19
	\b			# start at word boundary
	(			# begin $1  {
	    $urls :		# need resource and a colon
	    (?!:)		# Ignore File::, among others.
	    [$any] +?		# followed by one or more of any valid
				#   character, but be conservative and
				#   take only what you need to....
	)			# end   $1  }
	(?=
	    &quot; &gt;		# maybe pre-quoted '<a href="...">'
	|			# or:
	    [$punc]*		# 0 or more punctuation
	    (?:			#   followed
		[^$any]		#   by a non-url char
	    |			#   or
		$		#   end of the string
	    )			#
	|			# or else
	    $			#   then end of the string
d1372 1
a1372 1
    process_puretext( $text, \$PTQuote, 1 );
d1377 1
a1377 1
    process_puretext( $text, \$PTQuote, 0 );
d1462 1
a1462 1
    return if $Ignore;
d1613 1
a1613 1
            warn "$0: $Podfile: cannot resolve L<$opar> in paragraph $Paragraph.\n";
d1635 1
a1635 1
	warn "$0: $Podfile: invalid X<> in paragraph $Paragraph.\n"
d1654 1
a1654 1
	    warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph.\n";
d1678 1
a1678 1
    warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph.\n";
d1743 1
a1743 1
    if (!defined $Pages{$page} && defined $Sections{$page}) {
d1750 1
a1750 1
    $page=$page83 if (defined $Pages{$page83});
d1761 2
a1762 2
	if ( defined( $Pages{ $page_name } ) &&
	     $Pages{ $page_name } =~ /([^:]*$page)\.(?:pod|pm):/
d1768 3
a1770 3
	    # $Htmlroot/A/B.html . This is often incorrect, since they are
	    # often in $Htmlroot/lib/A/B.html or such like. Perhaps we could
	    # analyze the contents of %Pages and figure out where any
d1778 1
a1778 1
	$link = "$Htmlroot/$page.html";
d1780 1
a1780 1
    } elsif (!defined $Pages{$page}) {
d1788 3
a1790 3
#	if ($section ne "" && $Pages{$page} =~ /([^:]*[^(\.pod|\.pm)]):/) {
	if ($section ne "" && $Pages{$page} =~ /([^:]*(?<!\.pod)(?<!\.pm)):/) {
	    $link = "$Htmlroot/$1/$section.html";
d1801 4
a1804 4
	    if ($Pages{$page} =~ /([^:]*)\.pod:/) {
		$link = "$Htmlroot/$1.html$section";
	    } elsif ($Pages{$page} =~ /([^:]*)\.pm:/) {
		$link = "$Htmlroot/$1.html$section";
d1812 3
a1814 3
	# Here, we take advantage of the knowledge that $Htmlfileurl ne ''
	# implies $Htmlroot eq ''. This means that the link in question
	# needs a prefix of $Htmldir if it begins with '/'. The test for
d1818 4
a1821 4
        if (  $Htmlfileurl ne '' ) {
            $link = "$Htmldir$link" if $link =~ m{^/}s;
            $url = relativize_url( $link, $Htmlfileurl );
# print( "  b: [$link,$Htmlfileurl,$url]\n" );
d1880 1
a1880 1
	my $base = $Items{$fid} || "";
d1883 1
a1883 1
            ###   print STDERR "coderef( $page, $item ): items{$fid} = $Items{$fid} = $base => discard page!\n";
d1890 2
a1891 2
	    if(  exists $Local_Items{$fid} ){
		$page = $Local_Items{$fid};
d1893 1
a1893 1
		$page = $Items{$fid};
d1902 1
a1902 1
            if( exists $Pages{$page} and $Pages{$page} =~ /([^:.]*)\.[^:]*:/){
d1905 1
a1905 1
	    my $link = "$Htmlroot/$page#item_" . anchorify($fid);
d1907 5
a1911 5
	    # Here, we take advantage of the knowledge that $Htmlfileurl
	    # ne '' implies $Htmlroot eq ''.
	    if (  $Htmlfileurl ne '' ) {
		$link = "$Htmldir$link" ;
		$url = relativize_url( $link, $Htmlfileurl ) ;
d1943 1
a1943 1
    while ($Listlevel > 0) {
d1945 1
a1945 1
	$Listlevel--;
d1966 1
a1966 1
# similar to htmlify, but turns non-alphanumerics into underscores
d1971 1
a1971 1
    $anchor =~ s/\W/_/g;
d2041 1
a2041 1
my @@HC;
d2067 2
a2068 2
         defined( $HC[ord($1)] ) ? $HC[ord($1)]
                 : ( $HC[ord($1)] = sprintf( "%%%02X", ord($1) ) ) }gxe;
@


1.1.1.6
log
@perl 5.8.3 from CPAN
@
text
@d6 1
a6 1
$VERSION = 1.0502;
a80 14
=item hiddendirs

    --hiddendirs
    --nohiddendirs

Include hidden directories in the search for POD's in podpath if recurse
is set.
The default is not to traverse any directory whose name begins with C<.>.
See L</"podpath"> and L</"recurse">.

[This option is for backward compatibility only.
It's hard to imagine that one would usefully create a module with a
name component beginning with C<.>.]

a215 1
my $HiddenDirs;
a606 1
  --hiddendirs   - search hidden directories in podpath
d639 1
a639 1
	$opt_recurse,$opt_title,$opt_verbose,$opt_hiddendirs);
a648 1
			    'hiddendirs!'=> \$opt_hiddendirs,
a678 1
    $HiddenDirs = $opt_hiddendirs if defined $opt_hiddendirs;
d924 1
a924 3
	if (-d "$dir/$_" && $_ ne "." && $_ ne ".."
	    && ($HiddenDirs || !/^\./)
	) {         # directory
@


1.1.1.7
log
@perl 5.8.8 import
@
text
@d6 1
a6 1
$VERSION = 1.0504;
a464 1
<?xml version="1.0" ?>
a468 1
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
d527 1
a527 1
		    process_back($need_dd);
d533 1
a533 1
		       . "paragraph $Paragraph.  ignoring.\n" unless $Quiet;
d574 1
d576 2
a578 1
		print HTML "<p>$text</p>\n";
d640 1
a640 1
  --[no]quiet    - suppress some benign warning messages (default is off).
d892 1
a892 1
	    warn "$0: shouldn't be here (line ".__LINE__."\n" unless $Quiet;
a961 13
	} elsif (-T "$dir/$_") {			    # script(?)
	    local *F;
	    if (open(F, "$dir/$_")) {
		my $line;
		while (defined($line = <F>)) {
		    if ($line =~ /^=(?:pod|head1)/) {
			$Pages{$_}  = "" unless defined $Pages{$_};
			$Pages{$_} .= "$dir/$_.pod:";
			last;
		    }
		}
		close(F);
	    }
d1068 1
a1068 1
	warn "$0: $Podfile: unterminated list at =head in paragraph $Paragraph.  ignoring.\n" unless $Quiet;
d1110 1
a1110 1
    print HTML "</strong>\n";
d1136 1
a1136 1
	warn "$0: $Podfile: unexpected =item directive in paragraph $Paragraph.  ignoring.\n" unless $Quiet;
d1142 1
a1142 1
	print HTML $need_dd ? "</dd>\n" : "</li>\n" if $After_Lpar;
d1175 1
a1193 1
    my $need_dd = shift;
d1195 1
a1195 1
	warn "$0: $Podfile: unexpected =back directive in paragraph $Paragraph.  ignoring.\n" unless $Quiet;
d1204 1
a1204 1
	print HTML $need_dd ? "</dd>\n" : "</li>\n" if $After_Lpar;
d1398 1
a1398 1
    ## Guessing at func() or [\$\@@%&]*var references in plain text is destined
d1624 1
a1624 1
            warn "$0: $Podfile: cannot resolve L<$opar> in paragraph $Paragraph.\n" unless $Quiet;
d1647 1
a1647 1
	    unless $$rstr =~ s/^>// or $Quiet;
d1665 1
a1665 1
	    warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph.\n" unless $Quiet;
d1689 1
a1689 1
    warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph.\n" unless $Quiet;
d1886 1
a1886 1
    if( defined( $page ) && $page ne "" ){
d2062 1
a2062 1
	return $1 if $text =~ /^([\$\@@%*]\S+)/;
d2072 1
a2072 1
	return $1 if $text =~ m{^([a-z\d_]+)(\s+[A-Z\d,/& ]+)?$};
@


1.1.1.8
log
@import perl 5.10.0 from CPAN
@
text
@d6 1
a6 1
$VERSION = 1.08;
d35 1
a35 1
=head1 FUNCTIONS
d37 1
a37 12
=head2 pod2html

    pod2html("pod2html",
             "--podpath=lib:ext:pod:vms",
             "--podroot=/usr/src/perl",
             "--htmlroot=/perl/nmanual",
             "--libpods=perlfunc:perlguts:perlvar:perlrun:perlop",
             "--recurse",
             "--infile=foo.pod",
             "--outfile=/perl/nmanual/foo.html");

pod2html takes the following arguments:
d190 1
a190 1
=head2 htmlify
d192 8
a199 12
    htmlify($heading);

Converts a pod section specification to a suitable section specification
for HTML. Note that we keep spaces and special characters except 
C<", ?> (Netscape problem) and the hyphen (writer's problem...).

=head2 anchorify

    anchorify(@@heading);

Similar to C<htmlify()>, but turns non-alphanumerics into underscores.  Note
that C<anchorify()> is not exported by default.
d219 1
d255 1
d306 1
d488 7
a494 19

    my $hr = ($Doindex and $index) ? qq(<hr name="index" />) : "";

    unless ($Doindex)
    {
        $index = qq(<!--\n$index\n-->\n);
    }

    print HTML << "END_OF_INDEX";

<!-- INDEX BEGIN -->
<div name="index">
<p><a name=\"__index__\"></a></p>
$index
$hr
</div>
<!-- INDEX END -->

END_OF_INDEX
d501 2
d1110 2
a1111 3
    my $item = fragment_id( depod($text) , -generate);
    Carp::confess("Undefined fragment '$text' (".depod($text).") from fragment_id() in emit_item_tag() in $Podfile")
        if !defined $item;
d1119 1
a1119 1
        my $name = $item;
d1121 1
a1121 1
	print HTML qq{<a name="$name" class="item">}, process_text( \$otext ), '</a>';
d1167 1
a1167 1
        if ($text =~ /\A\*\s+(\S.*)\Z/s ) { # with additional text
d1175 1
a1175 1
        if ($text =~ /\A(?>\d+\.?)\s*(\S.*)\Z/s ) { # with additional text
d1281 2
a1282 2
    if (!defined $Begin_Stack[-1] or $Begin_Stack[-1] ne $whom ) {
	Carp::confess("Unmatched begin/end at chunk $Paragraph in pod $Podfile\n")
d1396 1
a1396 1
    process_puretext( $text, 1 );
d1401 1
a1401 1
    process_puretext( $text, 0 );
d1409 1
a1409 1
    my($text, $notinIS) = @@_;
d1417 7
d1435 2
a1436 18
	# see if we can infer a link or a function call
	#
	# NOTE: This is a word based search, it won't automatically
	# mark "substr($var, 1, 2)" because the 1st word would be "substr($var"
	# User has to enclose those with proper C<>

	if( $notinIS && $word =~
	    m/
		^([a-z_]{2,})                 # The function name
		\(
		    ([0-9][a-z]*              # Manual page(1) or page(1M)
		    |[^)]*[\$\@@\%][^)]+       # ($foo), (1, @@foo), (%hash)
		    |                         # ()
		    )
		\)
		([.,;]?)$                     # a possible punctuation follows
	    /xi
	) {
d1439 1
a1439 1
            my( $func, $args, $rest ) = ( $1, $2, $3 || '' );
d1443 1
a1443 1
                    $word = qq(<a href="$url" class="man">the $word manpage</a>$rest);
d1448 1
a1448 1
            $word = emit_C( $func, '', "($args)") . $rest;
d1482 2
a1483 2
sub pattern ($) { $_[0] ? '\s+'.('>' x ($_[0] + 1)) : '>' }
sub closing ($) { local($_) = shift; (defined && s/\s+\z//) ? length : 0 }
a1488 1
    $res =~ s/\s+$//s;
a1491 16
sub process_text_rfc_links {
    my $text = shift;

    # For every "RFCnnnn" or "RFC nnn", link it to the authoritative
    # ource. Do not use the /i modifier here. Require "RFC" to be written in
    #  in capital letters.

    $text =~ s{
	(?<=[^<>[:alpha:]])           # Make sure this is not an URL already
	(RFC\s*([0-9]{1,5}))(?![0-9]) # max 5 digits
    }
    {<a href="http://www.ietf.org/rfc/rfc$2.txt" class="rfc">$1</a>}gx;

    $text;
}

d1526 2
a1527 2
	# F<filename> - italicize
	$res = '<em class="file">' . process_text1( $lev, $rstr ) . '</em>';
d1530 1
a1530 1
	# I<text> - italicize
d1567 1
a1567 5
            if (length $2) {
                ( $page, $ident ) = ( $1, $2 );
            } else {
                ( $page, $section ) = ( $1, $2 );
            }
d1655 2
a1656 2
	warn "$0: $Podfile: invalid X<> in paragraph $Paragraph.\n"
	    unless $$rstr =~ s/^[^>]*>// or $Quiet;
d1659 1
a1659 1
	warn "$0: $Podfile: invalid Z<> in paragraph $Paragraph.\n"
d1677 2
a1678 4
	} elsif( ! $Quiet ) {
            my $snippet = substr($$rstr,0,60);
            warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph: '$snippet'.\n" 
                
a1679 1
	$res = process_text_rfc_links($res);
d1692 1
a1692 1
      s/\A(.*?)(([BCEFILSXZ])<(<+\s+)?|@@{[pattern $closing[0]]})//s ){
d1702 1
a1702 4
    unless ($Quiet) {
        my $snippet = substr($$rstr,0,60);
        warn "$0: $Podfile: undelimited $func<> in paragraph $Paragraph (go_ahead): '$snippet'.\n" 
    }	        
d1824 4
a1827 3
	    # check if there is a .pod with the page name.
	    # for L<Foo>, Foo.(pod|pm) is preferred to A/Foo.(pod|pm)
	    if ($Pages{$page} =~ /([^:]*)\.(?:pod|pm):/) {
a1898 1
    
a1902 2
        Carp::confess("Undefined fragment '$item' from fragment_id() in coderef() in $Podfile")
            if !defined $fid;    
d1929 1
a1929 1
	    my $link = "$Htmlroot/$page#" . anchorify($fid);
d1940 1
a1940 1
	    $url = "#" . anchorify($fid);
d1984 1
a1984 2
    # $heading =~ s/[-"?]//g;
    $heading =~ s/["?]//g;
d2029 1
a2029 1
      while( $$rstr =~ s/\A(.*?)([BCEFILSXZ])<(<+[^\S\n]+)?//s ){
d2048 1
a2048 1
      while( $$rstr =~ s/\A(.*?)(([BCEFILSXZ])<(<+[^\S\n]+)?|$term)//s ){
a2059 53
{
    my %seen;   # static fragment record hash

sub fragment_id_readable {
    my $text     = shift;
    my $generate = shift;   # optional flag

    my $orig = $text;

    # leave the words for the fragment identifier,
    # change everything else to underbars.
    $text =~ s/[^A-Za-z0-9_]+/_/g; # do not use \W to avoid locale dependency.
    $text =~ s/_{2,}/_/g;
    $text =~ s/\A_//;
    $text =~ s/_\Z//;

    unless ($text)
    {
        # Nothing left after removing punctuation, so leave it as is
        # E.g. if option is named: "=item -#"

        $text = $orig;
    }

    if ($generate) {
        if ( exists $seen{$text} ) {
            # This already exists, make it unique
            $seen{$text}++;
            $text = $text . $seen{$text};
        } else {
            $seen{$text} = 1;  # first time seen this fragment
        }
    }

    $text;
}}

my @@HC;
sub fragment_id_obfuscated {  # This was the old "_2d_2d__"
    my $text     = shift;
    my $generate = shift;   # optional flag

    # text? Normalize by obfuscating the fragment id to make it unique
    $text =~ s/\s+/_/sg;

    $text =~ s{(\W)}{
        defined( $HC[ord($1)] ) ? $HC[ord($1)]
        : ( $HC[ord($1)] = sprintf( "%%%02X", ord($1) ) ) }gxe;
    $text = substr( $text, 0, 50 );

    $text;
}

d2065 1
a2065 1

d2067 1
a2067 3
    my $text     = shift;
    my $generate = shift;   # optional flag

d2085 1
a2085 1
	return $1 if $text =~ m{^([a-z\d_]+)(\s+[A-Z,/& ][A-Z\d,/& ]*)?$};
d2088 6
a2093 1
	return fragment_id_readable($text, $generate);
d2095 1
a2095 1
	return;
@


1.1.1.9
log
@import perl 5.10.1
@
text
@d6 1
a6 1
$VERSION = 1.09;
d249 2
a250 2
my($Listlevel, @@Listtype);
my $ListNewTerm;
d289 1
a289 1
    $Htmlfileurl = "";		# The url that other files would use to
d305 2
a306 3
    @@Listtype = ();		# list types for open lists
    $ListNewTerm = 0;		# indicates new term in definition list; used
    				# to correctly open/close <dd> tags
d522 1
d530 1
d546 1
a546 1
		    process_item( $1 );
d551 1
a551 1
		    process_back();
d566 1
a567 7

	    # Open tag for definition list as we have something to put in it
	    if( $ListNewTerm ){
		print HTML "<dd>\n";
		$ListNewTerm = 0;
	    }

d597 3
d602 1
d1077 1
a1077 1
	if ( $txt =~ /\A=item\s+\*\s*(.*)\Z/s ) { # bulleted list
d1082 1
a1082 1
	} elsif( $txt =~ /\A=item\s+(.*)\Z/s ) { # definition list
d1102 6
a1107 1
    finish_list();
d1146 1
a1146 1
    print HTML "</strong>";
d1150 1
a1150 1
sub new_listitem {
a1151 6
    # Open tag for definition list as we have something to put in it
    if( ($tag ne 'dl') && ($ListNewTerm) ){
	print HTML "<dd>\n";
	$ListNewTerm = 0;
    }

d1153 1
a1153 2
	# start of new list
	push( @@Listtype, "$tag" );
a1154 7
    } else {
	# if this is not the first item, close the previous one
	if ( $tag eq 'dl' ){
	    print HTML "</dd>\n" unless $ListNewTerm;
	} else {
	    print HTML "</li>\n";
	}
d1156 3
a1158 2
    my $opentag = $tag eq 'dl' ? 'dt' : 'li';
    print HTML "<$opentag>";
d1166 1
d1176 6
d1185 2
d1189 1
a1189 1
        new_listitem( 'ul' );
a1193 1
            print HTML "\n";
d1197 1
a1197 1
        new_listitem( 'ol' );
a1201 1
            print HTML "\n";
d1205 1
a1205 2
        # new_listitem takes care of opening the <dt> tag
        new_listitem( 'dl' );
a1207 2
	    # write the definition term and close <dt> tag
	    print HTML "</dt>\n";
d1209 1
a1209 3
        # trigger opening a <dd> tag for the actual definition; will not
        # happen if next paragraph is also a definition term (=item)
        $ListNewTerm = 1;
d1212 1
d1222 1
d1229 1
d1235 1
a1235 1
    # close off the list.  note, I check to see if $Listtype[$Listlevel] is
d1237 1
a1237 1
    # $Listtype[$Listlevel] may have never been initialized.
d1239 5
a1243 9
    if( defined $Listtype[$Listlevel] ){
        if ( $Listtype[$Listlevel] eq 'dl' ){
            print HTML "</dd>\n" unless $ListNewTerm;
        } else {
            print HTML "</li>\n";
        }
        print HTML "</$Listtype[$Listlevel]>\n";
        pop( @@Listtype );
        $ListNewTerm = 0;
d1245 1
d2028 3
a2030 5
    if( $Listlevel ){
	warn "$0: $Podfile: unterminated list(s) at =head in paragraph $Paragraph.  ignoring.\n" unless $Quiet;
	while( $Listlevel ){
            process_back();
        }
@


1.1.1.10
log
@Perl 5.12.2 from CPAN
@
text
@d1578 1
a1578 3
	$escape =~ s/^0?x([\dA-F]+)$/#x$1/i
	or $escape =~ s/^0([0-7]+)$/'#'.oct($1)/ei
	or $escape =~ s/^(\d+)$/#$1/;
@


