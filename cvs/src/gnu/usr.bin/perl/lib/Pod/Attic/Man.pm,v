head	1.14;
access;
symbols
	OPENBSD_4_8:1.13.0.4
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.2
	OPENBSD_4_7_BASE:1.13
	PERL_5_10_1:1.1.1.8
	OPENBSD_4_6:1.11.0.6
	OPENBSD_4_6_BASE:1.11
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	PERL_5_10_0:1.1.1.7
	OPENBSD_4_4:1.10.0.8
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.6
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.4
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.2
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.8.0.12
	OPENBSD_4_0_BASE:1.8
	PERL_5_8_8:1.1.1.6
	OPENBSD_3_9:1.8.0.10
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.8.0.8
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.8.0.6
	OPENBSD_3_7_BASE:1.8
	PERL_5_8_6:1.1.1.6
	OPENBSD_3_6:1.8.0.4
	OPENBSD_3_6_BASE:1.8
	PERL_5_8_5:1.1.1.5
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.7.0.4
	OPENBSD_3_4_BASE:1.7
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.6.0.6
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.5.0.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	PERL_5_6_0:1.1.1.1
	CPAN:1.1.1;
locks; strict;
comment	@# @;


1.14
date	2010.09.24.14.59.48;	author millert;	state dead;
branches;
next	1.13;

1.13
date	2009.11.16.15.10.18;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2009.10.12.18.24.42;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2008.09.29.17.36.13;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.16.21.56.24;	author espie;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.15.16.43.43;	author espie;	state Exp;
branches;
next	1.8;

1.8
date	2003.12.03.03.02.40;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.24.18.35.36;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.24.02.33.20;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.24.01.20.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.09.05.40.02;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.17.06.47;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.06.16.09.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2000.04.06.16.09.47;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.05.24.18.23.35;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.08;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2004.08.09.17.47.21;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2005.01.15.21.17.26;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2008.09.29.17.18.40;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2009.10.12.18.11.05;	author millert;	state Exp;
branches;
next	;


desc
@@


1.14
log
@remove files no longer in perl 5.12.2 (or that have moved)
@
text
@# Pod::Man -- Convert POD data to formatted *roff input.
#
# Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
#     Russ Allbery <rra@@stanford.edu>
# Substantial contributions by Sean Burke <sburke@@cpan.org>
#
# This program is free software; you may redistribute it and/or modify it
# under the same terms as Perl itself.
#
# This module translates POD documentation into *roff markup using the man
# macro set, and is intended for converting POD documents written as Unix
# manual pages to manual pages that can be read by the man(1) command.  It is
# a replacement for the pod2man command distributed with versions of Perl
# prior to 5.6.
#
# Perl core hackers, please note that this module is also separately
# maintained outside of the Perl core as part of the podlators.  Please send
# me any patches at the address above in addition to sending them to the
# standard Perl mailing lists.

##############################################################################
# Modules and declarations
##############################################################################

package Pod::Man;

require 5.005;

use strict;
use subs qw(makespace);
use vars qw(@@ISA %ESCAPES $PREAMBLE $VERSION);

use Carp qw(croak);
use Pod::Simple ();
use POSIX qw(strftime);

@@ISA = qw(Pod::Simple);

$VERSION = '2.22';

# Set the debugging level.  If someone has inserted a debug function into this
# class already, use that.  Otherwise, use any Pod::Simple debug function
# that's defined, and failing that, define a debug level of 10.
BEGIN {
    my $parent = defined (&Pod::Simple::DEBUG) ? \&Pod::Simple::DEBUG : undef;
    unless (defined &DEBUG) {
        *DEBUG = $parent || sub () { 10 };
    }
}

# Import the ASCII constant from Pod::Simple.  This is true iff we're in an
# ASCII-based universe (including such things as ISO 8859-1 and UTF-8), and is
# generally only false for EBCDIC.
BEGIN { *ASCII = \&Pod::Simple::ASCII }

# Pretty-print a data structure.  Only used for debugging.
BEGIN { *pretty = \&Pod::Simple::pretty }

##############################################################################
# Object initialization
##############################################################################

# Initialize the object and set various Pod::Simple options that we need.
# Here, we also process any additional options passed to the constructor or
# set up defaults if none were given.  Note that all internal object keys are
# in all-caps, reserving all lower-case object keys for Pod::Simple and user
# arguments.
sub new {
    my $class = shift;
    my $self = $class->SUPER::new;

    # Tell Pod::Simple not to handle S<> by automatically inserting &nbsp;.
    $self->nbsp_for_S (1);

    # Tell Pod::Simple to keep whitespace whenever possible.
    if ($self->can ('preserve_whitespace')) {
        $self->preserve_whitespace (1);
    } else {
        $self->fullstop_space_harden (1);
    }

    # The =for and =begin targets that we accept.
    $self->accept_targets (qw/man MAN roff ROFF/);

    # Ensure that contiguous blocks of code are merged together.  Otherwise,
    # some of the guesswork heuristics don't work right.
    $self->merge_text (1);

    # Pod::Simple doesn't do anything useful with our arguments, but we want
    # to put them in our object as hash keys and values.  This could cause
    # problems if we ever clash with Pod::Simple's own internal class
    # variables.
    %$self = (%$self, @@_);

    # Send errors to stderr if requested.
    if ($$self{stderr}) {
        $self->no_errata_section (1);
        $self->complain_stderr (1);
        delete $$self{stderr};
    }

    # Initialize various other internal constants based on our arguments.
    $self->init_fonts;
    $self->init_quotes;
    $self->init_page;

    # For right now, default to turning on all of the magic.
    $$self{MAGIC_CPP}       = 1;
    $$self{MAGIC_EMDASH}    = 1;
    $$self{MAGIC_FUNC}      = 1;
    $$self{MAGIC_MANREF}    = 1;
    $$self{MAGIC_SMALLCAPS} = 1;
    $$self{MAGIC_VARS}      = 1;

    return $self;
}

# Translate a font string into an escape.
sub toescape { (length ($_[0]) > 1 ? '\f(' : '\f') . $_[0] }

# Determine which fonts the user wishes to use and store them in the object.
# Regular, italic, bold, and bold-italic are constants, but the fixed width
# fonts may be set by the user.  Sets the internal hash key FONTS which is
# used to map our internal font escapes to actual *roff sequences later.
sub init_fonts {
    my ($self) = @@_;

    # Figure out the fixed-width font.  If user-supplied, make sure that they
    # are the right length.
    for (qw/fixed fixedbold fixeditalic fixedbolditalic/) {
        my $font = $$self{$_};
        if (defined ($font) && (length ($font) < 1 || length ($font) > 2)) {
            croak qq(roff font should be 1 or 2 chars, not "$font");
        }
    }

    # Set the default fonts.  We can't be sure portably across different
    # implementations what fixed bold-italic may be called (if it's even
    # available), so default to just bold.
    $$self{fixed}           ||= 'CW';
    $$self{fixedbold}       ||= 'CB';
    $$self{fixeditalic}     ||= 'CI';
    $$self{fixedbolditalic} ||= 'CB';

    # Set up a table of font escapes.  First number is fixed-width, second is
    # bold, third is italic.
    $$self{FONTS} = { '000' => '\fR', '001' => '\fI',
                      '010' => '\fB', '011' => '\f(BI',
                      '100' => toescape ($$self{fixed}),
                      '101' => toescape ($$self{fixeditalic}),
                      '110' => toescape ($$self{fixedbold}),
                      '111' => toescape ($$self{fixedbolditalic}) };
}

# Initialize the quotes that we'll be using for C<> text.  This requires some
# special handling, both to parse the user parameter if given and to make sure
# that the quotes will be safe against *roff.  Sets the internal hash keys
# LQUOTE and RQUOTE.
sub init_quotes {
    my ($self) = (@@_);

    $$self{quotes} ||= '"';
    if ($$self{quotes} eq 'none') {
        $$self{LQUOTE} = $$self{RQUOTE} = '';
    } elsif (length ($$self{quotes}) == 1) {
        $$self{LQUOTE} = $$self{RQUOTE} = $$self{quotes};
    } elsif ($$self{quotes} =~ /^(.)(.)$/
             || $$self{quotes} =~ /^(..)(..)$/) {
        $$self{LQUOTE} = $1;
        $$self{RQUOTE} = $2;
    } else {
        croak(qq(Invalid quote specification "$$self{quotes}"))
    }

    # Double the first quote; note that this should not be s///g as two double
    # quotes is represented in *roff as three double quotes, not four.  Weird,
    # I know.
    $$self{LQUOTE} =~ s/\"/\"\"/;
    $$self{RQUOTE} =~ s/\"/\"\"/;
}

# Initialize the page title information and indentation from our arguments.
sub init_page {
    my ($self) = @@_;

    # We used to try first to get the version number from a local binary, but
    # we shouldn't need that any more.  Get the version from the running Perl.
    # Work a little magic to handle subversions correctly under both the
    # pre-5.6 and the post-5.6 version numbering schemes.
    my @@version = ($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);
    $version[2] ||= 0;
    $version[2] *= 10 ** (3 - length $version[2]);
    for (@@version) { $_ += 0 }
    my $version = join ('.', @@version);

    # Set the defaults for page titles and indentation if the user didn't
    # override anything.
    $$self{center} = 'User Contributed Perl Documentation'
        unless defined $$self{center};
    $$self{release} = 'perl v' . $version
        unless defined $$self{release};
    $$self{indent} = 4
        unless defined $$self{indent};

    # Double quotes in things that will be quoted.
    for (qw/center release/) {
        $$self{$_} =~ s/\"/\"\"/g if $$self{$_};
    }
}

##############################################################################
# Core parsing
##############################################################################

# This is the glue that connects the code below with Pod::Simple itself.  The
# goal is to convert the event stream coming from the POD parser into method
# calls to handlers once the complete content of a tag has been seen.  Each
# paragraph or POD command will have textual content associated with it, and
# as soon as all of a paragraph or POD command has been seen, that content
# will be passed in to the corresponding method for handling that type of
# object.  The exceptions are handlers for lists, which have opening tag
# handlers and closing tag handlers that will be called right away.
#
# The internal hash key PENDING is used to store the contents of a tag until
# all of it has been seen.  It holds a stack of open tags, each one
# represented by a tuple of the attributes hash for the tag, formatting
# options for the tag (which are inherited), and the contents of the tag.

# Add a block of text to the contents of the current node, formatting it
# according to the current formatting instructions as we do.
sub _handle_text {
    my ($self, $text) = @@_;
    DEBUG > 3 and print "== $text\n";
    my $tag = $$self{PENDING}[-1];
    $$tag[2] .= $self->format_text ($$tag[1], $text);
}

# Given an element name, get the corresponding method name.
sub method_for_element {
    my ($self, $element) = @@_;
    $element =~ tr/-/_/;
    $element =~ tr/A-Z/a-z/;
    $element =~ tr/_a-z0-9//cd;
    return $element;
}

# Handle the start of a new element.  If cmd_element is defined, assume that
# we need to collect the entire tree for this element before passing it to the
# element method, and create a new tree into which we'll collect blocks of
# text and nested elements.  Otherwise, if start_element is defined, call it.
sub _handle_element_start {
    my ($self, $element, $attrs) = @@_;
    DEBUG > 3 and print "++ $element (<", join ('> <', %$attrs), ">)\n";
    my $method = $self->method_for_element ($element);

    # If we have a command handler, we need to accumulate the contents of the
    # tag before calling it.  Turn off IN_NAME for any command other than
    # <Para> so that IN_NAME isn't still set for the first heading after the
    # NAME heading.
    if ($self->can ("cmd_$method")) {
        DEBUG > 2 and print "<$element> starts saving a tag\n";
        $$self{IN_NAME} = 0 if ($element ne 'Para');

        # How we're going to format embedded text blocks depends on the tag
        # and also depends on our parent tags.  Thankfully, inside tags that
        # turn off guesswork and reformatting, nothing else can turn it back
        # on, so this can be strictly inherited.
        my $formatting = $$self{PENDING}[-1][1];
        $formatting = $self->formatting ($formatting, $element);
        push (@@{ $$self{PENDING} }, [ $attrs, $formatting, '' ]);
        DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
    } elsif ($self->can ("start_$method")) {
        my $method = 'start_' . $method;
        $self->$method ($attrs, '');
    } else {
        DEBUG > 2 and print "No $method start method, skipping\n";
    }
}

# Handle the end of an element.  If we had a cmd_ method for this element,
# this is where we pass along the tree that we built.  Otherwise, if we have
# an end_ method for the element, call that.
sub _handle_element_end {
    my ($self, $element) = @@_;
    DEBUG > 3 and print "-- $element\n";
    my $method = $self->method_for_element ($element);

    # If we have a command handler, pull off the pending text and pass it to
    # the handler along with the saved attribute hash.
    if ($self->can ("cmd_$method")) {
        DEBUG > 2 and print "</$element> stops saving a tag\n";
        my $tag = pop @@{ $$self{PENDING} };
        DEBUG > 4 and print "Popped: [", pretty ($tag), "]\n";
        DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
        my $method = 'cmd_' . $method;
        my $text = $self->$method ($$tag[0], $$tag[2]);
        if (defined $text) {
            if (@@{ $$self{PENDING} } > 1) {
                $$self{PENDING}[-1][2] .= $text;
            } else {
                $self->output ($text);
            }
        }
    } elsif ($self->can ("end_$method")) {
        my $method = 'end_' . $method;
        $self->$method ();
    } else {
        DEBUG > 2 and print "No $method end method, skipping\n";
    }
}

##############################################################################
# General formatting
##############################################################################

# Return formatting instructions for a new block.  Takes the current
# formatting and the new element.  Formatting inherits negatively, in the
# sense that if the parent has turned off guesswork, all child elements should
# leave it off.  We therefore return a copy of the same formatting
# instructions but possibly with more things turned off depending on the
# element.
sub formatting {
    my ($self, $current, $element) = @@_;
    my %options;
    if ($current) {
        %options = %$current;
    } else {
        %options = (guesswork => 1, cleanup => 1, convert => 1);
    }
    if ($element eq 'Data') {
        $options{guesswork} = 0;
        $options{cleanup} = 0;
        $options{convert} = 0;
    } elsif ($element eq 'X') {
        $options{guesswork} = 0;
        $options{cleanup} = 0;
    } elsif ($element eq 'Verbatim' || $element eq 'C') {
        $options{guesswork} = 0;
        $options{literal} = 1;
    }
    return \%options;
}

# Format a text block.  Takes a hash of formatting options and the text to
# format.  Currently, the only formatting options are guesswork, cleanup, and
# convert, all of which are boolean.
sub format_text {
    my ($self, $options, $text) = @@_;
    my $guesswork = $$options{guesswork} && !$$self{IN_NAME};
    my $cleanup = $$options{cleanup};
    my $convert = $$options{convert};
    my $literal = $$options{literal};

    # Cleanup just tidies up a few things, telling *roff that the hyphens are
    # hard, putting a bit of space between consecutive underscores, and
    # escaping backslashes.  Be careful not to mangle our character
    # translations by doing this before processing character translation.
    if ($cleanup) {
        $text =~ s/\\/\\e/g;
        $text =~ s/-/\\-/g;
        $text =~ s/_(?=_)/_\\|/g;
    }

    # Normally we do character translation, but we won't even do that in
    # <Data> blocks or if UTF-8 output is desired.
    if ($convert && !$$self{utf8} && ASCII) {
        $text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg;
    }

    # Ensure that *roff doesn't convert literal quotes to UTF-8 single quotes,
    # but don't mess up our accept escapes.
    if ($literal) {
        $text =~ s/(?<!\\\*)\'/\\*\(Aq/g;
        $text =~ s/(?<!\\\*)\`/\\\`/g;
    }

    # If guesswork is asked for, do that.  This involves more substantial
    # formatting based on various heuristics that may only be appropriate for
    # particular documents.
    if ($guesswork) {
        $text = $self->guesswork ($text);
    }

    return $text;
}

# Handles C<> text, deciding whether to put \*C` around it or not.  This is a
# whole bunch of messy heuristics to try to avoid overquoting, originally from
# Barrie Slaymaker.  This largely duplicates similar code in Pod::Text.
sub quote_literal {
    my $self = shift;
    local $_ = shift;

    # A regex that matches the portion of a variable reference that's the
    # array or hash index, separated out just because we want to use it in
    # several places in the following regex.
    my $index = '(?: \[.*\] | \{.*\} )?';

    # Check for things that we don't want to quote, and if we find any of
    # them, return the string with just a font change and no quoting.
    m{
      ^\s*
      (?:
         ( [\'\`\"] ) .* \1                             # already quoted
       | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
       | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
       | \$+ [\#^]? \S $index                           # special ($^Foo, $")
       | [\$\@@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
       | [\$\@@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
       | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
       | 0x [a-fA-F\d]+                                 # a hex constant
      )
      \s*\z
     }xso and return '\f(FS' . $_ . '\f(FE';

    # If we didn't return, go ahead and quote the text.
    return '\f(FS\*(C`' . $_ . "\\*(C'\\f(FE";
}

# Takes a text block to perform guesswork on.  Returns the text block with
# formatting codes added.  This is the code that marks up various Perl
# constructs and things commonly used in man pages without requiring the user
# to add any explicit markup, and is applied to all non-literal text.  We're
# guaranteed that the text we're applying guesswork to does not contain any
# *roff formatting codes.  Note that the inserted font sequences must be
# treated later with mapfonts or textmapfonts.
#
# This method is very fragile, both in the regular expressions it uses and in
# the ordering of those modifications.  Care and testing is required when
# modifying it.
sub guesswork {
    my $self = shift;
    local $_ = shift;
    DEBUG > 5 and print "   Guesswork called on [$_]\n";

    # By the time we reach this point, all hypens will be escaped by adding a
    # backslash.  We want to undo that escaping if they're part of regular
    # words and there's only a single dash, since that's a real hyphen that
    # *roff gets to consider a possible break point.  Make sure that a dash
    # after the first character of a word stays non-breaking, however.
    #
    # Note that this is not user-controllable; we pretty much have to do this
    # transformation or *roff will mangle the output in unacceptable ways.
    s{
        ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
        ( (?: [a-zA-Z\']+ \\-)+ )
        ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
        \b
    } {
        my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
        $hyphen ||= '';
        $main =~ s/\\-/-/g;
        $prefix . $hyphen . $main . $suffix;
    }egx;

    # Translate "--" into a real em-dash if it's used like one.  This means
    # that it's either surrounded by whitespace, it follows a regular word, or
    # it occurs between two regular words.
    if ($$self{MAGIC_EMDASH}) {
        s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;
        s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx;
    }

    # Make words in all-caps a little bit smaller; they look better that way.
    # However, we don't want to change Perl code (like @@ARGV), nor do we want
    # to fix the MIME in MIME-Version since it looks weird with the
    # full-height V.
    #
    # We change only a string of all caps (2) either at the beginning of the
    # line or following regular punctuation (like quotes) or whitespace (1),
    # and followed by either similar punctuation, an em-dash, or the end of
    # the line (3).
    if ($$self{MAGIC_SMALLCAPS}) {
        s{
            ( ^ | [\s\(\"\'\`\[\{<>] | \\\  )                   # (1)
            ( [A-Z] [A-Z] (?: [/A-Z+:\d_\$&] | \\- )* )         # (2)
            (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\\  | $ )   # (3)
        } {
            $1 . '\s-1' . $2 . '\s0'
        }egx;
    }

    # Note that from this point forward, we have to adjust for \s-1 and \s-0
    # strings inserted around things that we've made small-caps if later
    # transforms should work on those strings.

    # Italize functions in the form func(), including functions that are in
    # all capitals, but don't italize if there's anything between the parens.
    # The function must start with an alphabetic character or underscore and
    # then consist of word characters or colons.
    if ($$self{MAGIC_FUNC}) {
        s{
            ( \b | \\s-1 )
            ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
        } {
            $1 . '\f(IS' . $2 . '\f(IE'
        }egx;
    }

    # Change references to manual pages to put the page name in italics but
    # the number in the regular font, with a thin space between the name and
    # the number.  Only recognize func(n) where func starts with an alphabetic
    # character or underscore and contains only word characters, periods (for
    # configuration file man pages), or colons, and n is a single digit,
    # optionally followed by some number of lowercase letters.  Note that this
    # does not recognize man page references like perl(l) or socket(3SOCKET).
    if ($$self{MAGIC_MANREF}) {
        s{
            ( \b | \\s-1 )
            ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
            ( \( \d [a-z]* \) )
        } {
            $1 . '\f(IS' . $2 . '\f(IE\|' . $3
        }egx;
    }

    # Convert simple Perl variable references to a fixed-width font.  Be
    # careful not to convert functions, though; there are too many subtleties
    # with them to want to perform this transformation.
    if ($$self{MAGIC_VARS}) {
        s{
           ( ^ | \s+ )
           ( [\$\@@%] [\w:]+ )
           (?! \( )
        } {
            $1 . '\f(FS' . $2 . '\f(FE'
        }egx;
    }

    # Fix up double quotes.  Unfortunately, we miss this transformation if the
    # quoted text contains any code with formatting codes and there's not much
    # we can effectively do about that, which makes it somewhat unclear if
    # this is really a good idea.
    s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;

    # Make C++ into \*(C+, which is a squinched version.
    if ($$self{MAGIC_CPP}) {
        s{ \b C\+\+ } {\\*\(C+}gx;
    }

    # Done.
    DEBUG > 5 and print "   Guesswork returning [$_]\n";
    return $_;
}

##############################################################################
# Output
##############################################################################

# When building up the *roff code, we don't use real *roff fonts.  Instead, we
# embed font codes of the form \f(<font>[SE] where <font> is one of B, I, or
# F, S stands for start, and E stands for end.  This method turns these into
# the right start and end codes.
#
# We add this level of complexity because the old pod2man didn't get code like
# B<someI<thing> else> right; after I<> it switched back to normal text rather
# than bold.  We take care of this by using variables that state whether bold,
# italic, or fixed are turned on as a combined pointer to our current font
# sequence, and set each to the number of current nestings of start tags for
# that font.
#
# \fP changes to the previous font, but only one previous font is kept.  We
# don't know what the outside level font is; normally it's R, but if we're
# inside a heading it could be something else.  So arrange things so that the
# outside font is always the "previous" font and end with \fP instead of \fR.
# Idea from Zack Weinberg.
sub mapfonts {
    my ($self, $text) = @@_;
    my ($fixed, $bold, $italic) = (0, 0, 0);
    my %magic = (F => \$fixed, B => \$bold, I => \$italic);
    my $last = '\fR';
    $text =~ s<
        \\f\((.)(.)
    > <
        my $sequence = '';
        my $f;
        if ($last ne '\fR') { $sequence = '\fP' }
        ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
        $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
        if ($f eq $last) {
            '';
        } else {
            if ($f ne '\fR') { $sequence .= $f }
            $last = $f;
            $sequence;
        }
    >gxe;
    return $text;
}

# Unfortunately, there is a bug in Solaris 2.6 nroff (not present in GNU
# groff) where the sequence \fB\fP\f(CW\fP leaves the font set to B rather
# than R, presumably because \f(CW doesn't actually do a font change.  To work
# around this, use a separate textmapfonts for text blocks where the default
# font is always R and only use the smart mapfonts for headings.
sub textmapfonts {
    my ($self, $text) = @@_;
    my ($fixed, $bold, $italic) = (0, 0, 0);
    my %magic = (F => \$fixed, B => \$bold, I => \$italic);
    $text =~ s<
        \\f\((.)(.)
    > <
        ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
        $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
    >gxe;
    return $text;
}

# Given a command and a single argument that may or may not contain double
# quotes, handle double-quote formatting for it.  If there are no double
# quotes, just return the command followed by the argument in double quotes.
# If there are double quotes, use an if statement to test for nroff, and for
# nroff output the command followed by the argument in double quotes with
# embedded double quotes doubled.  For other formatters, remap paired double
# quotes to LQUOTE and RQUOTE.
sub switchquotes {
    my ($self, $command, $text, $extra) = @@_;
    $text =~ s/\\\*\([LR]\"/\"/g;

    # We also have to deal with \*C` and \*C', which are used to add the
    # quotes around C<> text, since they may expand to " and if they do this
    # confuses the .SH macros and the like no end.  Expand them ourselves.
    # Also separate troff from nroff if there are any fixed-width fonts in use
    # to work around problems with Solaris nroff.
    my $c_is_quote = ($$self{LQUOTE} =~ /\"/) || ($$self{RQUOTE} =~ /\"/);
    my $fixedpat = join '|', @@{ $$self{FONTS} }{'100', '101', '110', '111'};
    $fixedpat =~ s/\\/\\\\/g;
    $fixedpat =~ s/\(/\\\(/g;
    if ($text =~ m/\"/ || $text =~ m/$fixedpat/) {
        $text =~ s/\"/\"\"/g;
        my $nroff = $text;
        my $troff = $text;
        $troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;
        if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/) {
            $nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;
            $nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;
            $troff =~ s/\\\*\(C[\'\`]//g;
        }
        $nroff = qq("$nroff") . ($extra ? " $extra" : '');
        $troff = qq("$troff") . ($extra ? " $extra" : '');

        # Work around the Solaris nroff bug where \f(CW\fP leaves the font set
        # to Roman rather than the actual previous font when used in headings.
        # troff output may still be broken, but at least we can fix nroff by
        # just switching the font changes to the non-fixed versions.
        $nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f[PR]/$1/g;
        $nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)\\f([PR])/\\fI$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)\\f([PR])/\\fB$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)\\f([PR])/\\f\(BI$1\\f$2/g;

        # Now finally output the command.  Bother with .ie only if the nroff
        # and troff output aren't the same.
        if ($nroff ne $troff) {
            return ".ie n $command $nroff\n.el $command $troff\n";
        } else {
            return "$command $nroff\n";
        }
    } else {
        $text = qq("$text") . ($extra ? " $extra" : '');
        return "$command $text\n";
    }
}

# Protect leading quotes and periods against interpretation as commands.  Also
# protect anything starting with a backslash, since it could expand or hide
# something that *roff would interpret as a command.  This is overkill, but
# it's much simpler than trying to parse *roff here.
sub protect {
    my ($self, $text) = @@_;
    $text =~ s/^([.\'\\])/\\&$1/mg;
    return $text;
}

# Make vertical whitespace if NEEDSPACE is set, appropriate to the indentation
# level the situation.  This function is needed since in *roff one has to
# create vertical whitespace after paragraphs and between some things, but
# other macros create their own whitespace.  Also close out a sequence of
# repeated =items, since calling makespace means we're about to begin the item
# body.
sub makespace {
    my ($self) = @@_;
    $self->output (".PD\n") if $$self{ITEMS} > 1;
    $$self{ITEMS} = 0;
    $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n")
        if $$self{NEEDSPACE};
}

# Output any pending index entries, and optionally an index entry given as an
# argument.  Support multiple index entries in X<> separated by slashes, and
# strip special escapes from index entries.
sub outindex {
    my ($self, $section, $index) = @@_;
    my @@entries = map { split m%\s*/\s*% } @@{ $$self{INDEX} };
    return unless ($section || @@entries);

    # We're about to output all pending entries, so clear our pending queue.
    $$self{INDEX} = [];

    # Build the output.  Regular index entries are marked Xref, and headings
    # pass in their own section.  Undo some *roff formatting on headings.
    my @@output;
    if (@@entries) {
        push @@output, [ 'Xref', join (' ', @@entries) ];
    }
    if ($section) {
        $index =~ s/\\-/-/g;
        $index =~ s/\\(?:s-?\d|.\(..|.)//g;
        push @@output, [ $section, $index ];
    }

    # Print out the .IX commands.
    for (@@output) {
        my ($type, $entry) = @@$_;
        $entry =~ s/\"/\"\"/g;
	$entry =~ s/\\/\\\\/g;
        $self->output (".IX $type " . '"' . $entry . '"' . "\n");
    }
}

# Output some text, without any additional changes.
sub output {
    my ($self, @@text) = @@_;
    print { $$self{output_fh} } @@text;
}

##############################################################################
# Document initialization
##############################################################################

# Handle the start of the document.  Here we handle empty documents, as well
# as setting up our basic macros in a preamble and building the page title.
sub start_document {
    my ($self, $attrs) = @@_;
    if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
        DEBUG and print "Document is contentless\n";
        $$self{CONTENTLESS} = 1;
        return;
    }

    # If we were given the utf8 option, set an output encoding on our file
    # handle.  Wrap in an eval in case we're using a version of Perl too old
    # to understand this.
    #
    # This is evil because it changes the global state of a file handle that
    # we may not own.  However, we can't just blindly encode all output, since
    # there may be a pre-applied output encoding (such as from PERL_UNICODE)
    # and then we would double-encode.  This seems to be the least bad
    # approach.
    if ($$self{utf8}) {
        eval { binmode ($$self{output_fh}, ':encoding(UTF-8)') };
    }

    # Determine information for the preamble and then output it.
    my ($name, $section);
    if (defined $$self{name}) {
        $name = $$self{name};
        $section = $$self{section} || 1;
    } else {
        ($name, $section) = $self->devise_title;
    }
    my $date = $$self{date} || $self->devise_date;
    $self->preamble ($name, $section, $date)
        unless $self->bare_output or DEBUG > 9;

    # Initialize a few per-document variables.
    $$self{INDENT}    = 0;      # Current indentation level.
    $$self{INDENTS}   = [];     # Stack of indentations.
    $$self{INDEX}     = [];     # Index keys waiting to be printed.
    $$self{IN_NAME}   = 0;      # Whether processing the NAME section.
    $$self{ITEMS}     = 0;      # The number of consecutive =items.
    $$self{ITEMTYPES} = [];     # Stack of =item types, one per list.
    $$self{SHIFTWAIT} = 0;      # Whether there is a shift waiting.
    $$self{SHIFTS}    = [];     # Stack of .RS shifts.
    $$self{PENDING}   = [[]];   # Pending output.
}

# Handle the end of the document.  This does nothing but print out a final
# comment at the end of the document under debugging.
sub end_document {
    my ($self) = @@_;
    return if $self->bare_output;
    return if ($$self{CONTENTLESS} && !$$self{ALWAYS_EMIT_SOMETHING});
    $self->output (q(.\" [End document]) . "\n") if DEBUG;
}

# Try to figure out the name and section from the file name and return them as
# a list, returning an empty name and section 1 if we can't find any better
# information.  Uses File::Basename and File::Spec as necessary.
sub devise_title {
    my ($self) = @@_;
    my $name = $self->source_filename || '';
    my $section = $$self{section} || 1;
    $section = 3 if (!$$self{section} && $name =~ /\.pm\z/i);
    $name =~ s/\.p(od|[lm])\z//i;

    # If the section isn't 3, then the name defaults to just the basename of
    # the file.  Otherwise, assume we're dealing with a module.  We want to
    # figure out the full module name from the path to the file, but we don't
    # want to include too much of the path into the module name.  Lose
    # anything up to the first off:
    #
    #     */lib/*perl*/         standard or site_perl module
    #     */*perl*/lib/         from -Dprefix=/opt/perl
    #     */*perl*/             random module hierarchy
    #
    # which works.  Also strip off a leading site, site_perl, or vendor_perl
    # component, any OS-specific component, and any version number component,
    # and strip off an initial component of "lib" or "blib/lib" since that's
    # what ExtUtils::MakeMaker creates.  splitdir requires at least File::Spec
    # 0.8.
    if ($section !~ /^3/) {
        require File::Basename;
        $name = uc File::Basename::basename ($name);
    } else {
        require File::Spec;
        my ($volume, $dirs, $file) = File::Spec->splitpath ($name);
        my @@dirs = File::Spec->splitdir ($dirs);
        my $cut = 0;
        my $i;
        for ($i = 0; $i < @@dirs; $i++) {
            if ($dirs[$i] =~ /perl/) {
                $cut = $i + 1;
                $cut++ if ($dirs[$i + 1] && $dirs[$i + 1] eq 'lib');
                last;
            } elsif ($dirs[$i] eq 'lib' && $dirs[$i + 1] && $dirs[0] eq 'ext') {
                $cut = $i + 1;
	    }
        }
        if ($cut > 0) {
            splice (@@dirs, 0, $cut);
            shift @@dirs if ($dirs[0] =~ /^(site|vendor)(_perl)?$/);
            shift @@dirs if ($dirs[0] =~ /^[\d.]+$/);
            shift @@dirs if ($dirs[0] =~ /^(.*-$^O|$^O-.*|$^O)$/);
        }
        shift @@dirs if $dirs[0] eq 'lib';
        splice (@@dirs, 0, 2) if ($dirs[0] eq 'blib' && $dirs[1] eq 'lib');

        # Remove empty directories when building the module name; they
        # occur too easily on Unix by doubling slashes.
        $name = join ('::', (grep { $_ ? $_ : () } @@dirs), $file);
    }
    return ($name, $section);
}

# Determine the modification date and return that, properly formatted in ISO
# format.  If we can't get the modification date of the input, instead use the
# current time.  Pod::Simple returns a completely unuseful stringified file
# handle as the source_filename for input from a file handle, so we have to
# deal with that as well.
sub devise_date {
    my ($self) = @@_;
    my $input = $self->source_filename;
    my $time;
    if ($input) {
        $time = (stat $input)[9] || time;
    } else {
        $time = time;
    }
    return strftime ('%Y-%m-%d', localtime $time);
}

# Print out the preamble and the title.  The meaning of the arguments to .TH
# unfortunately vary by system; some systems consider the fourth argument to
# be a "source" and others use it as a version number.  Generally it's just
# presented as the left-side footer, though, so it doesn't matter too much if
# a particular system gives it another interpretation.
#
# The order of date and release used to be reversed in older versions of this
# module, but this order is correct for both Solaris and Linux.
sub preamble {
    my ($self, $name, $section, $date) = @@_;
    my $preamble = $self->preamble_template (!$$self{utf8});

    # Build the index line and make sure that it will be syntactically valid.
    my $index = "$name $section";
    $index =~ s/\"/\"\"/g;

    # If name or section contain spaces, quote them (section really never
    # should, but we may as well be cautious).
    for ($name, $section) {
        if (/\s/) {
            s/\"/\"\"/g;
            $_ = '"' . $_ . '"';
        }
    }

    # Double quotes in date, since it will be quoted.
    $date =~ s/\"/\"\"/g;

    # Substitute into the preamble the configuration options.
    $preamble =~ s/\@@CFONT\@@/$$self{fixed}/;
    $preamble =~ s/\@@LQUOTE\@@/$$self{LQUOTE}/;
    $preamble =~ s/\@@RQUOTE\@@/$$self{RQUOTE}/;
    chomp $preamble;

    # Get the version information.
    my $version = $self->version_report;

    # Finally output everything.
    $self->output (<<"----END OF HEADER----");
.\\" Automatically generated by $version
.\\"
.\\" Standard preamble:
.\\" ========================================================================
$preamble
.\\" ========================================================================
.\\"
.IX Title "$index"
.TH $name $section "$date" "$$self{release}" "$$self{center}"
.\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\\" way too many mistakes in technical documents.
.if n .ad l
.nh
----END OF HEADER----
    $self->output (".\\\" [End of preamble]\n") if DEBUG;
}

##############################################################################
# Text blocks
##############################################################################

# Handle a basic block of text.  The only tricky part of this is if this is
# the first paragraph of text after an =over, in which case we have to change
# indentations for *roff.
sub cmd_para {
    my ($self, $attrs, $text) = @@_;
    my $line = $$attrs{start_line};

    # Output the paragraph.  We also have to handle =over without =item.  If
    # there's an =over without =item, SHIFTWAIT will be set, and we need to
    # handle creation of the indent here.  Add the shift to SHIFTS so that it
    # will be cleaned up on =back.
    $self->makespace;
    if ($$self{SHIFTWAIT}) {
        $self->output (".RS $$self{INDENT}\n");
        push (@@{ $$self{SHIFTS} }, $$self{INDENT});
        $$self{SHIFTWAIT} = 0;
    }

    # Add the line number for debugging, but not in the NAME section just in
    # case the comment would confuse apropos.
    $self->output (".\\\" [At source line $line]\n")
        if defined ($line) && DEBUG && !$$self{IN_NAME};

    # Force exactly one newline at the end and strip unwanted trailing
    # whitespace at the end.
    $text =~ s/\s*$/\n/;

    # Output the paragraph.
    $self->output ($self->protect ($self->textmapfonts ($text)));
    $self->outindex;
    $$self{NEEDSPACE} = 1;
    return '';
}

# Handle a verbatim paragraph.  Put a null token at the beginning of each line
# to protect against commands and wrap in .Vb/.Ve (which we define in our
# prelude).
sub cmd_verbatim {
    my ($self, $attrs, $text) = @@_;

    # Ignore an empty verbatim paragraph.
    return unless $text =~ /\S/;

    # Force exactly one newline at the end and strip unwanted trailing
    # whitespace at the end.
    $text =~ s/\s*$/\n/;

    # Get a count of the number of lines before the first blank line, which
    # we'll pass to .Vb as its parameter.  This tells *roff to keep that many
    # lines together.  We don't want to tell *roff to keep huge blocks
    # together.
    my @@lines = split (/\n/, $text);
    my $unbroken = 0;
    for (@@lines) {
        last if /^\s*$/;
        $unbroken++;
    }
    $unbroken = 10 if ($unbroken > 12 && !$$self{MAGIC_VNOPAGEBREAK_LIMIT});

    # Prepend a null token to each line.
    $text =~ s/^/\\&/gm;

    # Output the results.
    $self->makespace;
    $self->output (".Vb $unbroken\n$text.Ve\n");
    $$self{NEEDSPACE} = 1;
    return '';
}

# Handle literal text (produced by =for and similar constructs).  Just output
# it with the minimum of changes.
sub cmd_data {
    my ($self, $attrs, $text) = @@_;
    $text =~ s/^\n+//;
    $text =~ s/\n{0,2}$/\n/;
    $self->output ($text);
    return '';
}

##############################################################################
# Headings
##############################################################################

# Common code for all headings.  This is called before the actual heading is
# output.  It returns the cleaned up heading text (putting the heading all on
# one line) and may do other things, like closing bad =item blocks.
sub heading_common {
    my ($self, $text, $line) = @@_;
    $text =~ s/\s+$//;
    $text =~ s/\s*\n\s*/ /g;

    # This should never happen; it means that we have a heading after =item
    # without an intervening =back.  But just in case, handle it anyway.
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }

    # Output the current source line.
    $self->output ( ".\\\" [At source line $line]\n" )
        if defined ($line) && DEBUG;
    return $text;
}

# First level heading.  We can't output .IX in the NAME section due to a bug
# in some versions of catman, so don't output a .IX for that section.  .SH
# already uses small caps, so remove \s0 and \s-1.  Maintain IN_NAME as
# appropriate.
sub cmd_head1 {
    my ($self, $attrs, $text) = @@_;
    $text =~ s/\\s-?\d//g;
    $text = $self->heading_common ($text, $$attrs{start_line});
    my $isname = ($text eq 'NAME' || $text =~ /\(NAME\)/);
    $self->output ($self->switchquotes ('.SH', $self->mapfonts ($text)));
    $self->outindex ('Header', $text) unless $isname;
    $$self{NEEDSPACE} = 0;
    $$self{IN_NAME} = $isname;
    return '';
}

# Second level heading.
sub cmd_head2 {
    my ($self, $attrs, $text) = @@_;
    $text = $self->heading_common ($text, $$attrs{start_line});
    $self->output ($self->switchquotes ('.SS', $self->mapfonts ($text)));
    $self->outindex ('Subsection', $text);
    $$self{NEEDSPACE} = 0;
    return '';
}

# Third level heading.  *roff doesn't have this concept, so just put the
# heading in italics as a normal paragraph.
sub cmd_head3 {
    my ($self, $attrs, $text) = @@_;
    $text = $self->heading_common ($text, $$attrs{start_line});
    $self->makespace;
    $self->output ($self->textmapfonts ('\f(IS' . $text . '\f(IE') . "\n");
    $self->outindex ('Subsection', $text);
    $$self{NEEDSPACE} = 1;
    return '';
}

# Fourth level heading.  *roff doesn't have this concept, so just put the
# heading as a normal paragraph.
sub cmd_head4 {
    my ($self, $attrs, $text) = @@_;
    $text = $self->heading_common ($text, $$attrs{start_line});
    $self->makespace;
    $self->output ($self->textmapfonts ($text) . "\n");
    $self->outindex ('Subsection', $text);
    $$self{NEEDSPACE} = 1;
    return '';
}

##############################################################################
# Formatting codes
##############################################################################

# All of the formatting codes that aren't handled internally by the parser,
# other than L<> and X<>.
sub cmd_b { return '\f(BS' . $_[2] . '\f(BE' }
sub cmd_i { return '\f(IS' . $_[2] . '\f(IE' }
sub cmd_f { return '\f(IS' . $_[2] . '\f(IE' }
sub cmd_c { return $_[0]->quote_literal ($_[2]) }

# Index entries are just added to the pending entries.
sub cmd_x {
    my ($self, $attrs, $text) = @@_;
    push (@@{ $$self{INDEX} }, $text);
    return '';
}

# Links reduce to the text that we're given, wrapped in angle brackets if it's
# a URL.
sub cmd_l {
    my ($self, $attrs, $text) = @@_;
    return $$attrs{type} eq 'url' ? "<$text>" : $text;
}

##############################################################################
# List handling
##############################################################################

# Handle the beginning of an =over block.  Takes the type of the block as the
# first argument, and then the attr hash.  This is called by the handlers for
# the four different types of lists (bullet, number, text, and block).
sub over_common_start {
    my ($self, $type, $attrs) = @@_;
    my $line = $$attrs{start_line};
    my $indent = $$attrs{indent};
    DEBUG > 3 and print " Starting =over $type (line $line, indent ",
        ($indent || '?'), "\n";

    # Find the indentation level.
    unless (defined ($indent) && $indent =~ /^[-+]?\d{1,4}\s*$/) {
        $indent = $$self{indent};
    }

    # If we've gotten multiple indentations in a row, we need to emit the
    # pending indentation for the last level that we saw and haven't acted on
    # yet.  SHIFTS is the stack of indentations that we've actually emitted
    # code for.
    if (@@{ $$self{SHIFTS} } < @@{ $$self{INDENTS} }) {
        $self->output (".RS $$self{INDENT}\n");
        push (@@{ $$self{SHIFTS} }, $$self{INDENT});
    }

    # Now, do record-keeping.  INDENTS is a stack of indentations that we've
    # seen so far, and INDENT is the current level of indentation.  ITEMTYPES
    # is a stack of list types that we've seen.
    push (@@{ $$self{INDENTS} }, $$self{INDENT});
    push (@@{ $$self{ITEMTYPES} }, $type);
    $$self{INDENT} = $indent + 0;
    $$self{SHIFTWAIT} = 1;
}

# End an =over block.  Takes no options other than the class pointer.
# Normally, once we close a block and therefore remove something from INDENTS,
# INDENTS will now be longer than SHIFTS, indicating that we also need to emit
# *roff code to close the indent.  This isn't *always* true, depending on the
# circumstance.  If we're still inside an indentation, we need to emit another
# .RE and then a new .RS to unconfuse *roff.
sub over_common_end {
    my ($self) = @@_;
    DEBUG > 3 and print " Ending =over\n";
    $$self{INDENT} = pop @@{ $$self{INDENTS} };
    pop @@{ $$self{ITEMTYPES} };

    # If we emitted code for that indentation, end it.
    if (@@{ $$self{SHIFTS} } > @@{ $$self{INDENTS} }) {
        $self->output (".RE\n");
        pop @@{ $$self{SHIFTS} };
    }

    # If we're still in an indentation, *roff will have now lost track of the
    # right depth of that indentation, so fix that.
    if (@@{ $$self{INDENTS} } > 0) {
        $self->output (".RE\n");
        $self->output (".RS $$self{INDENT}\n");
    }
    $$self{NEEDSPACE} = 1;
    $$self{SHIFTWAIT} = 0;
}

# Dispatch the start and end calls as appropriate.
sub start_over_bullet { my $s = shift; $s->over_common_start ('bullet', @@_) }
sub start_over_number { my $s = shift; $s->over_common_start ('number', @@_) }
sub start_over_text   { my $s = shift; $s->over_common_start ('text',   @@_) }
sub start_over_block  { my $s = shift; $s->over_common_start ('block',  @@_) }
sub end_over_bullet { $_[0]->over_common_end }
sub end_over_number { $_[0]->over_common_end }
sub end_over_text   { $_[0]->over_common_end }
sub end_over_block  { $_[0]->over_common_end }

# The common handler for all item commands.  Takes the type of the item, the
# attributes, and then the text of the item.
#
# Emit an index entry for anything that's interesting, but don't emit index
# entries for things like bullets and numbers.  Newlines in an item title are
# turned into spaces since *roff can't handle them embedded.
sub item_common {
    my ($self, $type, $attrs, $text) = @@_;
    my $line = $$attrs{start_line};
    DEBUG > 3 and print "  $type item (line $line): $text\n";

    # Clean up the text.  We want to end up with two variables, one ($text)
    # which contains any body text after taking out the item portion, and
    # another ($item) which contains the actual item text.
    $text =~ s/\s+$//;
    my ($item, $index);
    if ($type eq 'bullet') {
        $item = "\\\(bu";
        $text =~ s/\n*$/\n/;
    } elsif ($type eq 'number') {
        $item = $$attrs{number} . '.';
    } else {
        $item = $text;
        $item =~ s/\s*\n\s*/ /g;
        $text = '';
        $index = $item if ($item =~ /\w/);
    }

    # Take care of the indentation.  If shifts and indents are equal, close
    # the top shift, since we're about to create an indentation with .IP.
    # Also output .PD 0 to turn off spacing between items if this item is
    # directly following another one.  We only have to do that once for a
    # whole chain of items so do it for the second item in the change.  Note
    # that makespace is what undoes this.
    if (@@{ $$self{SHIFTS} } == @@{ $$self{INDENTS} }) {
        $self->output (".RE\n");
        pop @@{ $$self{SHIFTS} };
    }
    $self->output (".PD 0\n") if ($$self{ITEMS} == 1);

    # Now, output the item tag itself.
    $item = $self->textmapfonts ($item);
    $self->output ($self->switchquotes ('.IP', $item, $$self{INDENT}));
    $$self{NEEDSPACE} = 0;
    $$self{ITEMS}++;
    $$self{SHIFTWAIT} = 0;

    # If body text for this item was included, go ahead and output that now.
    if ($text) {
        $text =~ s/\s*$/\n/;
        $self->makespace;
        $self->output ($self->protect ($self->textmapfonts ($text)));
        $$self{NEEDSPACE} = 1;
    }
    $self->outindex ($index ? ('Item', $index) : ());
}

# Dispatch the item commands to the appropriate place.
sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @@_) }
sub cmd_item_number { my $self = shift; $self->item_common ('number', @@_) }
sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @@_) }
sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @@_) }

##############################################################################
# Backward compatibility
##############################################################################

# Reset the underlying Pod::Simple object between calls to parse_from_file so
# that the same object can be reused to convert multiple pages.
sub parse_from_file {
    my $self = shift;
    $self->reinit;

    # Fake the old cutting option to Pod::Parser.  This fiddings with internal
    # Pod::Simple state and is quite ugly; we need a better approach.
    if (ref ($_[0]) eq 'HASH') {
        my $opts = shift @@_;
        if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
            $$self{in_pod} = 1;
            $$self{last_was_blank} = 1;
        }
    }

    # Do the work.
    my $retval = $self->SUPER::parse_from_file (@@_);

    # Flush output, since Pod::Simple doesn't do this.  Ideally we should also
    # close the file descriptor if we had to open one, but we can't easily
    # figure this out.
    my $fh = $self->output_fh ();
    my $oldfh = select $fh;
    my $oldflush = $|;
    $| = 1;
    print $fh '';
    $| = $oldflush;
    select $oldfh;
    return $retval;
}

# Pod::Simple failed to provide this backward compatibility function, so
# implement it ourselves.  File handles are one of the inputs that
# parse_from_file supports.
sub parse_from_filehandle {
    my $self = shift;
    $self->parse_from_file (@@_);
}

##############################################################################
# Translation tables
##############################################################################

# The following table is adapted from Tom Christiansen's pod2man.  It assumes
# that the standard preamble has already been printed, since that's what
# defines all of the accent marks.  We really want to do something better than
# this when *roff actually supports other character sets itself, since these
# results are pretty poor.
#
# This only works in an ASCII world.  What to do in a non-ASCII world is very
# unclear -- hopefully we can assume UTF-8 and just leave well enough alone.
@@ESCAPES{0xA0 .. 0xFF} = (
    "\\ ", undef, undef, undef,            undef, undef, undef, undef,
    undef, undef, undef, undef,            undef, "\\%", undef, undef,

    undef, undef, undef, undef,            undef, undef, undef, undef,
    undef, undef, undef, undef,            undef, undef, undef, undef,

    "A\\*`",  "A\\*'", "A\\*^", "A\\*~",   "A\\*:", "A\\*o", "\\*(AE", "C\\*,",
    "E\\*`",  "E\\*'", "E\\*^", "E\\*:",   "I\\*`", "I\\*'", "I\\*^",  "I\\*:",

    "\\*(D-", "N\\*~", "O\\*`", "O\\*'",   "O\\*^", "O\\*~", "O\\*:",  undef,
    "O\\*/",  "U\\*`", "U\\*'", "U\\*^",   "U\\*:", "Y\\*'", "\\*(Th", "\\*8",

    "a\\*`",  "a\\*'", "a\\*^", "a\\*~",   "a\\*:", "a\\*o", "\\*(ae", "c\\*,",
    "e\\*`",  "e\\*'", "e\\*^", "e\\*:",   "i\\*`", "i\\*'", "i\\*^",  "i\\*:",

    "\\*(d-", "n\\*~", "o\\*`", "o\\*'",   "o\\*^", "o\\*~", "o\\*:",  undef,
    "o\\*/" , "u\\*`", "u\\*'", "u\\*^",   "u\\*:", "y\\*'", "\\*(th", "y\\*:",
) if ASCII;

##############################################################################
# Premable
##############################################################################

# The following is the static preamble which starts all *roff output we
# generate.  Most is static except for the font to use as a fixed-width font,
# which is designed by @@CFONT@@, and the left and right quotes to use for C<>
# text, designated by @@LQOUTE@@ and @@RQUOTE@@.  However, the second part, which
# defines the accent marks, is only used if $escapes is set to true.
sub preamble_template {
    my ($self, $accents) = @@_;
    my $preamble = <<'----END OF PREAMBLE----';
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft @@CFONT@@
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` @@LQUOTE@@
.    ds C' @@RQUOTE@@
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
----END OF PREAMBLE----

    if ($accents) {
        $preamble .= <<'----END OF PREAMBLE----'
.\"
.\" Accent mark definitions (@@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
----END OF PREAMBLE----
#`# for cperl-mode
    }
    return $preamble;
}

##############################################################################
# Module return value and documentation
##############################################################################

1;
__END__

=head1 NAME

Pod::Man - Convert POD data to formatted *roff input

=for stopwords
en em ALLCAPS teeny fixedbold fixeditalic fixedbolditalic stderr utf8
UTF-8 Allbery Sean Burke Ossanna Solaris formatters troff uppercased
Christiansen

=head1 SYNOPSIS

    use Pod::Man;
    my $parser = Pod::Man->new (release => $VERSION, section => 8);

    # Read POD from STDIN and write to STDOUT.
    $parser->parse_file (\*STDIN);

    # Read POD from file.pod and write to file.1.
    $parser->parse_from_file ('file.pod', 'file.1');

=head1 DESCRIPTION

Pod::Man is a module to convert documentation in the POD format (the
preferred language for documenting Perl) into *roff input using the man
macro set.  The resulting *roff code is suitable for display on a terminal
using L<nroff(1)>, normally via L<man(1)>, or printing using L<troff(1)>.
It is conventionally invoked using the driver script B<pod2man>, but it can
also be used directly.

As a derived class from Pod::Simple, Pod::Man supports the same methods and
interfaces.  See L<Pod::Simple> for all the details.

new() can take options, in the form of key/value pairs that control the
behavior of the parser.  See below for details.

If no options are given, Pod::Man uses the name of the input file with any
trailing C<.pod>, C<.pm>, or C<.pl> stripped as the man page title, to
section 1 unless the file ended in C<.pm> in which case it defaults to
section 3, to a centered title of "User Contributed Perl Documentation", to
a centered footer of the Perl version it is run with, and to a left-hand
footer of the modification date of its input (or the current date if given
C<STDIN> for input).

Pod::Man assumes that your *roff formatters have a fixed-width font named
C<CW>.  If yours is called something else (like C<CR>), use the C<fixed>
option to specify it.  This generally only matters for troff output for
printing.  Similarly, you can set the fonts used for bold, italic, and
bold italic fixed-width output.

Besides the obvious pod conversions, Pod::Man also takes care of
formatting func(), func(3), and simple variable references like $foo or
@@bar so you don't have to use code escapes for them; complex expressions
like C<$fred{'stuff'}> will still need to be escaped, though.  It also
translates dashes that aren't used as hyphens into en dashes, makes long
dashes--like this--into proper em dashes, fixes "paired quotes," makes C++
look right, puts a little space between double underscores, makes ALLCAPS
a teeny bit smaller in B<troff>, and escapes stuff that *roff treats as
special so that you don't have to.

The recognized options to new() are as follows.  All options take a single
argument.

=over 4

=item center

Sets the centered page header to use instead of "User Contributed Perl
Documentation".

=item date

Sets the left-hand footer.  By default, the modification date of the input
file will be used, or the current date if stat() can't find that file (the
case if the input is from C<STDIN>), and the date will be formatted as
C<YYYY-MM-DD>.

=item fixed

The fixed-width font to use for verbatim text and code.  Defaults to
C<CW>.  Some systems may want C<CR> instead.  Only matters for B<troff>
output.

=item fixedbold

Bold version of the fixed-width font.  Defaults to C<CB>.  Only matters
for B<troff> output.

=item fixeditalic

Italic version of the fixed-width font (actually, something of a misnomer,
since most fixed-width fonts only have an oblique version, not an italic
version).  Defaults to C<CI>.  Only matters for B<troff> output.

=item fixedbolditalic

Bold italic (probably actually oblique) version of the fixed-width font.
Pod::Man doesn't assume you have this, and defaults to C<CB>.  Some
systems (such as Solaris) have this font available as C<CX>.  Only matters
for B<troff> output.

=item name

Set the name of the manual page.  Without this option, the manual name is
set to the uppercased base name of the file being converted unless the
manual section is 3, in which case the path is parsed to see if it is a Perl
module path.  If it is, a path like C<.../lib/Pod/Man.pm> is converted into
a name like C<Pod::Man>.  This option, if given, overrides any automatic
determination of the name.

=item quotes

Sets the quote marks used to surround CE<lt>> text.  If the value is a
single character, it is used as both the left and right quote; if it is two
characters, the first character is used as the left quote and the second as
the right quoted; and if it is four characters, the first two are used as
the left quote and the second two as the right quote.

This may also be set to the special value C<none>, in which case no quote
marks are added around CE<lt>> text (but the font is still changed for troff
output).

=item release

Set the centered footer.  By default, this is the version of Perl you run
Pod::Man under.  Note that some system an macro sets assume that the
centered footer will be a modification date and will prepend something like
"Last modified: "; if this is the case, you may want to set C<release> to
the last modified date and C<date> to the version number.

=item section

Set the section for the C<.TH> macro.  The standard section numbering
convention is to use 1 for user commands, 2 for system calls, 3 for
functions, 4 for devices, 5 for file formats, 6 for games, 7 for
miscellaneous information, and 8 for administrator commands.  There is a lot
of variation here, however; some systems (like Solaris) use 4 for file
formats, 5 for miscellaneous information, and 7 for devices.  Still others
use 1m instead of 8, or some mix of both.  About the only section numbers
that are reliably consistent are 1, 2, and 3.

By default, section 1 will be used unless the file ends in C<.pm> in which
case section 3 will be selected.

=item stderr

Send error messages about invalid POD to standard error instead of
appending a POD ERRORS section to the generated *roff output.

=item utf8

By default, Pod::Man produces the most conservative possible *roff output
to try to ensure that it will work with as many different *roff
implementations as possible.  Many *roff implementations cannot handle
non-ASCII characters, so this means all non-ASCII characters are converted
either to a *roff escape sequence that tries to create a properly accented
character (at least for troff output) or to C<X>.

If this option is set, Pod::Man will instead output UTF-8.  If your *roff
implementation can handle it, this is the best output format to use and
avoids corruption of documents containing non-ASCII characters.  However,
be warned that *roff source with literal UTF-8 characters is not supported
by many implementations and may even result in segfaults and other bad
behavior.

Be aware that, when using this option, the input encoding of your POD
source must be properly declared unless it is US-ASCII or Latin-1.  POD
input without an C<=encoding> command will be assumed to be in Latin-1,
and if it's actually in UTF-8, the output will be double-encoded.  See
L<perlpod(1)> for more information on the C<=encoding> command.

=back

The standard Pod::Simple method parse_file() takes one argument naming the
POD file to read from.  By default, the output is sent to C<STDOUT>, but
this can be changed with the output_fd() method.

The standard Pod::Simple method parse_from_file() takes up to two
arguments, the first being the input file to read POD from and the second
being the file to write the formatted output to.

You can also call parse_lines() to parse an array of lines or
parse_string_document() to parse a document already in memory.  To put the
output into a string instead of a file handle, call the output_string()
method.  See L<Pod::Simple> for the specific details.

=head1 DIAGNOSTICS

=over 4

=item roff font should be 1 or 2 chars, not "%s"

(F) You specified a *roff font (using C<fixed>, C<fixedbold>, etc.) that
wasn't either one or two characters.  Pod::Man doesn't support *roff fonts
longer than two characters, although some *roff extensions do (the canonical
versions of B<nroff> and B<troff> don't either).

=item Invalid quote specification "%s"

(F) The quote specification given (the quotes option to the constructor) was
invalid.  A quote specification must be one, two, or four characters long.

=back

=head1 BUGS

Encoding handling assumes that PerlIO is available and does not work
properly if it isn't.  The C<utf8> option is therefore not supported
unless Perl is built with PerlIO support.

There is currently no way to turn off the guesswork that tries to format
unmarked text appropriately, and sometimes it isn't wanted (particularly
when using POD to document something other than Perl).  Most of the work
toward fixing this has now been done, however, and all that's still needed
is a user interface.

The NAME section should be recognized specially and index entries emitted
for everything in that section.  This would have to be deferred until the
next section, since extraneous things in NAME tends to confuse various man
page processors.  Currently, no index entries are emitted for anything in
NAME.

Pod::Man doesn't handle font names longer than two characters.  Neither do
most B<troff> implementations, but GNU troff does as an extension.  It would
be nice to support as an option for those who want to use it.

The preamble added to each output file is rather verbose, and most of it
is only necessary in the presence of non-ASCII characters.  It would
ideally be nice if all of those definitions were only output if needed,
perhaps on the fly as the characters are used.

Pod::Man is excessively slow.

=head1 CAVEATS

If Pod::Man is given the C<utf8> option, the encoding of its output file
handle will be forced to UTF-8 if possible, overriding any existing
encoding.  This will be done even if the file handle is not created by
Pod::Man and was passed in from outside.  This maintains consistency
regardless of PERL_UNICODE and other settings.

The handling of hyphens and em dashes is somewhat fragile, and one may get
the wrong one under some circumstances.  This should only matter for
B<troff> output.

When and whether to use small caps is somewhat tricky, and Pod::Man doesn't
necessarily get it right.

Converting neutral double quotes to properly matched double quotes doesn't
work unless there are no formatting codes between the quote marks.  This
only matters for troff output.

=head1 AUTHOR

Russ Allbery <rra@@stanford.edu>, based I<very> heavily on the original
B<pod2man> by Tom Christiansen <tchrist@@mox.perl.com>.  The modifications to
work with Pod::Simple instead of Pod::Parser were originally contributed by
Sean Burke (but I've since hacked them beyond recognition and all bugs are
mine).

=head1 COPYRIGHT AND LICENSE

Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
Russ Allbery <rra@@stanford.edu>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

=head1 SEE ALSO

L<Pod::Simple>, L<perlpod(1)>, L<pod2man(1)>, L<nroff(1)>, L<troff(1)>,
L<man(1)>, L<man(7)>

Ossanna, Joseph F., and Brian W. Kernighan.  "Troff User's Manual,"
Computing Science Technical Report No. 54, AT&T Bell Laboratories.  This is
the best documentation of standard B<nroff> and B<troff>.  At the time of
this writing, it's available at
L<http://www.cs.bell-labs.com/cm/cs/cstr.html>.

The man page documenting the man macro set may be L<man(5)> instead of
L<man(7)> on your system.  Also, please see L<pod2man(1)> for extensive
documentation on writing manual pages if you've not done it before and
aren't familiar with the conventions.

The current version of this module is always available from its web site at
L<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.

=cut
@


1.13
log
@Fix generation of .IX entries that include characters escaped with
a backslash.  Fix from Russ Allbery, the podlators maintainer.
@
text
@@


1.12
log
@Merge in perl 5.10.1
@
text
@d715 1
@


1.11
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@a1 1
# $Id: Man.pm,v 2.16 2007-11-29 01:35:53 eagle Exp $
d3 1
a3 1
# Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d39 1
a39 4
# Don't use the CVS revision as the version, since this module is also in Perl
# core and too many things could munge CVS magic revision strings.  This
# number should ideally be the same as the CVS revision in podlators, however.
$VERSION = '2.16';
d72 1
a72 1
    # Tell Pod::Simple to handle S<> by automatically inserting &nbsp;.
d95 7
a353 10
    # Normally we do character translation, but we won't even do that in
    # <Data> blocks.
    if ($convert) {
        if (ASCII) {
            $text =~ s/(\\|[^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg;
        } else {
            $text =~ s/(\\)/$ESCAPES{ord ($1)} || "X"/eg;
        }
    }

d355 3
a357 1
    # hard and putting a bit of space between consecutive underscores.
d359 1
d364 6
d646 4
a649 4
        $nroff =~ s/\Q$$self{FONTS}{100}\E(.*)\\f[PR]/$1/g;
        $nroff =~ s/\Q$$self{FONTS}{101}\E(.*)\\f([PR])/\\fI$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{110}\E(.*)\\f([PR])/\\fB$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{111}\E(.*)\\f([PR])/\\f\(BI$1\\f$2/g;
d739 13
a773 2
    $$self{EXCLUDE}   = 0;
    $$self{VERBATIM}  = 0;
d824 3
a826 1
            }
d871 1
a871 1
    my $preamble = $self->preamble_template;
d1045 1
a1045 1
    $self->output ($self->switchquotes ('.Sh', $self->mapfonts ($text)));
d1293 1
a1293 1
# unclear.
d1296 1
a1296 1
    undef, "\\(co", undef, undef,            undef, "\\%", undef, undef,
a1313 3
# Make sure that at least this works even outside of ASCII.
$ESCAPES{ord("\\")} = "\\e";

d1319 4
a1322 3
# generate.  It's completely static except for the font to use as a
# fixed-width font, which is designed by @@CFONT@@, and the left and right
# quotes to use for C<> text, designated by @@LQOUTE@@ and @@RQUOTE@@.
d1324 2
a1325 9
    return <<'----END OF PREAMBLE----';
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
d1369 1
a1369 1
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
d1383 4
d1451 2
d1466 5
d1503 1
a1503 1
STDIN for input).
d1506 14
a1519 14
CW.  If yours is called something else (like CR), use the C<fixed> option to
specify it.  This generally only matters for troff output for printing.
Similarly, you can set the fonts used for bold, italic, and bold italic
fixed-width output.

Besides the obvious pod conversions, Pod::Man also takes care of formatting
func(), func(3), and simple variable references like $foo or @@bar so you
don't have to use code escapes for them; complex expressions like
C<$fred{'stuff'}> will still need to be escaped, though.  It also translates
dashes that aren't used as hyphens into en dashes, makes long dashes--like
this--into proper em dashes, fixes "paired quotes," makes C++ look right,
puts a little space between double underbars, makes ALLCAPS a teeny bit
smaller in B<troff>, and escapes stuff that *roff treats as special so that
you don't have to.
d1535 2
a1536 2
case if the input is from STDIN), and the date will be formatted as
YYYY-MM-DD.
d1540 3
a1542 2
The fixed-width font to use for vertabim text and code.  Defaults to CW.
Some systems may want CR instead.  Only matters for B<troff> output.
d1546 2
a1547 2
Bold version of the fixed-width font.  Defaults to CB.  Only matters for
B<troff> output.
d1553 1
a1553 1
version).  Defaults to CI.  Only matters for B<troff> output.
d1558 3
a1560 3
Pod::Man doesn't assume you have this, and defaults to CB.  Some systems
(such as Solaris) have this font available as CX.  Only matters for B<troff>
output.
d1602 29
a1630 2
By default, section 1 will be used unless the file ends in .pm in which case
section 3 will be selected.
d1635 2
a1636 2
POD file to read from.  By default, the output is sent to STDOUT, but this
can be changed with the output_fd() method.
d1667 3
a1669 8
Eight-bit input data isn't handled at all well at present.  The correct
approach would be to map EE<lt>E<gt> escapes to the appropriate UTF-8
characters and then do a translation pass on the output according to the
user-specified output character set.  Unfortunately, we can't send eight-bit
data directly to the output unless the user says this is okay, since some
vendor *roff implementations can't handle eight-bit data.  If the *roff
implementation can, however, that's far superior to the current hacked
characters that only work under troff.
d1674 1
a1674 1
towards fixing this has now been done, however, and all that's still needed
d1696 6
d1723 2
a1724 2
Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
by Russ Allbery <rra@@stanford.edu>.
@


1.10
log
@let E<copy> be recognized for man documents as well.
Noticed by jasper@@,

work by millert@@ and me, okay millert@@
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.9 2006/11/15 16:43:43 espie Exp $
d4 3
a6 1
# Copyright 1999, 2000, 2001, 2002, 2003 by Russ Allbery <rra@@stanford.edu>
a29 4
use Carp qw(carp croak);
use Pod::ParseLink qw(parselink);
use Pod::Parser ();

d34 5
a38 1
@@ISA = qw(Pod::Parser);
d43 16
a58 1
$VERSION = 1.37;
d60 2
d64 1
a64 1
# Preamble and *roff output tables
d67 18
a84 214
# The following is the static preamble which starts all *roff output we
# generate.  It's completely static except for the font to use as a
# fixed-width font, which is designed by @@CFONT@@, and the left and right
# quotes to use for C<> text, designated by @@LQOUTE@@ and @@RQUOTE@@.  $PREAMBLE
# should therefore be run through s/\@@CFONT\@@/<font>/g before output.
$PREAMBLE = <<'----END OF PREAMBLE----';
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft @@CFONT@@
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` @@LQUOTE@@
.    ds C' @@RQUOTE@@
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
----END OF PREAMBLE----
#`# for cperl-mode

# This table is taken nearly verbatim from Tom Christiansen's pod2man.  It
# assumes that the standard preamble has already been printed, since that's
# what defines all of the accent marks.  Note that some of these are quoted
# with double quotes since they contain embedded single quotes, so use \\
# uniformly for backslash for readability.
%ESCAPES = (
    'amp'       =>    '&',      # ampersand
    'apos'      =>    "'",      # apostrophe
    'lt'        =>    '<',      # left chevron, less-than
    'gt'        =>    '>',      # right chevron, greater-than
    'quot'      =>    '"',      # double quote
    'sol'       =>    '/',      # solidus (forward slash)
    'verbar'    =>    '|',      # vertical bar

    'Aacute'    =>    "A\\*'",  # capital A, acute accent
    'aacute'    =>    "a\\*'",  # small a, acute accent
    'Acirc'     =>    'A\\*^',  # capital A, circumflex accent
    'acirc'     =>    'a\\*^',  # small a, circumflex accent
    'AElig'     =>    '\*(AE',  # capital AE diphthong (ligature)
    'aelig'     =>    '\*(ae',  # small ae diphthong (ligature)
    'Agrave'    =>    "A\\*`",  # capital A, grave accent
    'agrave'    =>    "A\\*`",  # small a, grave accent
    'Aring'     =>    'A\\*o',  # capital A, ring
    'aring'     =>    'a\\*o',  # small a, ring
    'Atilde'    =>    'A\\*~',  # capital A, tilde
    'atilde'    =>    'a\\*~',  # small a, tilde
    'Auml'      =>    'A\\*:',  # capital A, dieresis or umlaut mark
    'auml'      =>    'a\\*:',  # small a, dieresis or umlaut mark
    'Ccedil'    =>    'C\\*,',  # capital C, cedilla
    'ccedil'    =>    'c\\*,',  # small c, cedilla
    'Eacute'    =>    "E\\*'",  # capital E, acute accent
    'eacute'    =>    "e\\*'",  # small e, acute accent
    'Ecirc'     =>    'E\\*^',  # capital E, circumflex accent
    'ecirc'     =>    'e\\*^',  # small e, circumflex accent
    'Egrave'    =>    'E\\*`',  # capital E, grave accent
    'egrave'    =>    'e\\*`',  # small e, grave accent
    'ETH'       =>    '\\*(D-', # capital Eth, Icelandic
    'eth'       =>    '\\*(d-', # small eth, Icelandic
    'Euml'      =>    'E\\*:',  # capital E, dieresis or umlaut mark
    'euml'      =>    'e\\*:',  # small e, dieresis or umlaut mark
    'Iacute'    =>    "I\\*'",  # capital I, acute accent
    'iacute'    =>    "i\\*'",  # small i, acute accent
    'Icirc'     =>    'I\\*^',  # capital I, circumflex accent
    'icirc'     =>    'i\\*^',  # small i, circumflex accent
    'Igrave'    =>    'I\\*`',  # capital I, grave accent
    'igrave'    =>    'i\\*`',  # small i, grave accent
    'Iuml'      =>    'I\\*:',  # capital I, dieresis or umlaut mark
    'iuml'      =>    'i\\*:',  # small i, dieresis or umlaut mark
    'Ntilde'    =>    'N\*~',   # capital N, tilde
    'ntilde'    =>    'n\*~',   # small n, tilde
    'Oacute'    =>    "O\\*'",  # capital O, acute accent
    'oacute'    =>    "o\\*'",  # small o, acute accent
    'Ocirc'     =>    'O\\*^',  # capital O, circumflex accent
    'ocirc'     =>    'o\\*^',  # small o, circumflex accent
    'Ograve'    =>    'O\\*`',  # capital O, grave accent
    'ograve'    =>    'o\\*`',  # small o, grave accent
    'Oslash'    =>    'O\\*/',  # capital O, slash
    'oslash'    =>    'o\\*/',  # small o, slash
    'Otilde'    =>    'O\\*~',  # capital O, tilde
    'otilde'    =>    'o\\*~',  # small o, tilde
    'Ouml'      =>    'O\\*:',  # capital O, dieresis or umlaut mark
    'ouml'      =>    'o\\*:',  # small o, dieresis or umlaut mark
    'szlig'     =>    '\*8',    # small sharp s, German (sz ligature)
    'THORN'     =>    '\\*(Th', # capital THORN, Icelandic
    'thorn'     =>    '\\*(th', # small thorn, Icelandic
    'Uacute'    =>    "U\\*'",  # capital U, acute accent
    'uacute'    =>    "u\\*'",  # small u, acute accent
    'Ucirc'     =>    'U\\*^',  # capital U, circumflex accent
    'ucirc'     =>    'u\\*^',  # small u, circumflex accent
    'Ugrave'    =>    'U\\*`',  # capital U, grave accent
    'ugrave'    =>    'u\\*`',  # small u, grave accent
    'Uuml'      =>    'U\\*:',  # capital U, dieresis or umlaut mark
    'uuml'      =>    'u\\*:',  # small u, dieresis or umlaut mark
    'Yacute'    =>    "Y\\*'",  # capital Y, acute accent
    'yacute'    =>    "y\\*'",  # small y, acute accent
    'yuml'      =>    'y\\*:',  # small y, dieresis or umlaut mark

    'nbsp'      =>    '\\ ',    # non-breaking space
    'shy'       =>    '',       # soft (discretionary) hyphen
    'copy'	=>    '\(co',	# copyright
);
d86 2
d89 22
a110 3
##############################################################################
# Static helper functions
##############################################################################
d112 1
a112 8
# Protect leading quotes and periods against interpretation as commands.  Also
# protect anything starting with a backslash, since it could expand or hide
# something that *roff would interpret as a command.  This is overkill, but
# it's much simpler than trying to parse *roff here.
sub protect {
    local $_ = shift;
    s/^([.\'\\])/\\&$1/mg;
    $_;
d118 6
a123 13

##############################################################################
# Initialization
##############################################################################

# Initialize the object.  Here, we also process any additional options passed
# to the constructor or set up defaults if none were given.  center is the
# centered title, release is the version number, and date is the date for the
# documentation.  Note that we can't know what file name we're processing due
# to the architecture of Pod::Parser, so that *has* to either be passed to the
# constructor or set separately with Pod::Man::name().
sub initialize {
    my $self = shift;
d128 3
a130 7
        if (defined $$self{$_}) {
            if (length ($$self{$_}) < 1 || length ($$self{$_}) > 2) {
                croak qq(roff font should be 1 or 2 chars,)
                    . qq( not "$$self{$_}");
            }
        } else {
            $$self{$_} = '';
d134 3
a136 2
    # Set the default fonts.  We can't be sure what fixed bold-italic is going
    # to be called, so default to just bold.
d144 549
a692 6
    $$self{FONTS} = { '000' => '\fR', '001' => '\fI',
                      '010' => '\fB', '011' => '\f(BI',
                      '100' => toescape ($$self{fixed}),
                      '101' => toescape ($$self{fixeditalic}),
                      '110' => toescape ($$self{fixedbold}),
                      '111' => toescape ($$self{fixedbolditalic})};
d694 2
a695 4
    # Extra stuff for page titles.
    $$self{center} = 'User Contributed Perl Documentation'
        unless defined $$self{center};
    $$self{indent} = 4 unless defined $$self{indent};
d697 5
a701 10
    # We used to try first to get the version number from a local binary, but
    # we shouldn't need that any more.  Get the version from the running Perl.
    # Work a little magic to handle subversions correctly under both the
    # pre-5.6 and the post-5.6 version numbering schemes.
    if (!defined $$self{release}) {
        my @@version = ($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);
        $version[2] ||= 0;
        $version[2] *= 10 ** (3 - length $version[2]);
        for (@@version) { $_ += 0 }
        $$self{release} = 'perl v' . join ('.', @@version);
d703 4
a706 4

    # Double quotes in things that will be quoted.
    for (qw/center date release/) {
        $$self{$_} =~ s/\"/\"\"/g if $$self{$_};
d709 5
a713 12
    # Figure out what quotes we'll be using for C<> text.
    $$self{quotes} ||= '"';
    if ($$self{quotes} eq 'none') {
        $$self{LQUOTE} = $$self{RQUOTE} = '';
    } elsif (length ($$self{quotes}) == 1) {
        $$self{LQUOTE} = $$self{RQUOTE} = $$self{quotes};
    } elsif ($$self{quotes} =~ /^(.)(.)$/
             || $$self{quotes} =~ /^(..)(..)$/) {
        $$self{LQUOTE} = $1;
        $$self{RQUOTE} = $2;
    } else {
        croak qq(Invalid quote specification "$$self{quotes}");
d715 1
d717 4
a720 7
    # Double the first quote; note that this should not be s///g as two double
    # quotes is represented in *roff as three double quotes, not four.  Weird,
    # I know.
    $$self{LQUOTE} =~ s/\"/\"\"/;
    $$self{RQUOTE} =~ s/\"/\"\"/;

    $self->SUPER::initialize;
d723 3
a725 3
# For each document we process, output the preamble first.
sub begin_pod {
    my $self = shift;
d727 9
a735 48
    # Try to figure out the name and section from the file name.
    my $section = $$self{section} || 1;
    my $name = $$self{name};
    if (!defined $name) {
        $name = $self->input_file;
        $section = 3 if (!$$self{section} && $name =~ /\.pm\z/i);
        $name =~ s/\.p(od|[lm])\z//i;
        if ($section !~ /^3/) {
            require File::Basename;
            $name = uc File::Basename::basename ($name);
        } else {
            # Assume that we're dealing with a module.  We want to figure out
            # the full module name from the path to the file, but we don't
            # want to include too much of the path into the module name.  Lose
            # everything up to the first of:
            #
            #     */lib/*perl*/         standard or site_perl module
            #     */*perl*/lib/         from -Dprefix=/opt/perl
            #     */*perl*/             random module hierarchy
            #
            # which works.  Also strip off a leading site or site_perl
            # component, any OS-specific component, and any version number
            # component, and strip off an initial component of "lib" or
            # "blib/lib" since that's what ExtUtils::MakeMaker creates.
            # splitdir requires at least File::Spec 0.8.
            require File::Spec;
            my ($volume, $dirs, $file) = File::Spec->splitpath ($name);
            my @@dirs = File::Spec->splitdir ($dirs);
            my $cut = 0;
            my $i;
            for ($i = 0; $i < scalar @@dirs; $i++) {
                if ($dirs[$i] eq 'lib' && $dirs[$i + 1] =~ /perl/) {
                    $cut = $i + 2;
                    last;
                } elsif ($dirs[$i] =~ /perl/) {
                    $cut = $i + 1;
                    $cut++ if $dirs[$i + 1] eq 'lib';
                    last;
                }
            }
            if ($cut > 0) {
                splice (@@dirs, 0, $cut);
                shift @@dirs if ($dirs[0] =~ /^site(_perl)?$/);
                shift @@dirs if ($dirs[0] =~ /^[\d.]+$/);
                shift @@dirs if ($dirs[0] =~ /^(.*-$^O|$^O-.*|$^O)$/);
            }
            shift @@dirs if $dirs[0] eq 'lib';
            splice (@@dirs, 0, 2) if ($dirs[0] eq 'blib' && $dirs[1] eq 'lib');
d737 7
a743 4
            # Remove empty directories when building the module name; they
            # occur too easily on Unix by doubling slashes.
            $name = join ('::', (grep { $_ ? $_ : () } @@dirs), $file);
        }
d745 3
d749 1
a749 42
    # If $name contains spaces, quote it; this mostly comes up in the case of
    # input from stdin.
    $name = '"' . $name . '"' if ($name =~ /\s/);

    # Modification date header.  Try to use the modification time of our
    # input.
    if (!defined $$self{date}) {
        my $time = (stat $self->input_file)[9] || time;
        my ($day, $month, $year) = (localtime $time)[3,4,5];
        $month++;
        $year += 1900;
        $$self{date} = sprintf ('%4d-%02d-%02d', $year, $month, $day);
    }

    # Now, print out the preamble and the title.  The meaning of the arguments
    # to .TH unfortunately vary by system; some systems consider the fourth
    # argument to be a "source" and others use it as a version number.
    # Generally it's just presented as the left-side footer, though, so it
    # doesn't matter too much if a particular system gives it another
    # interpretation.
    #
    # The order of date and release used to be reversed in older versions of
    # this module, but this order is correct for both Solaris and Linux.
    local $_ = $PREAMBLE;
    s/\@@CFONT\@@/$$self{fixed}/;
    s/\@@LQUOTE\@@/$$self{LQUOTE}/;
    s/\@@RQUOTE\@@/$$self{RQUOTE}/;
    chomp $_;
    my $pversion = $Pod::Parser::VERSION;
    print { $self->output_handle } <<"----END OF HEADER----";
.\\" Automatically generated by Pod::Man v$VERSION, Pod::Parser v$pversion
.\\"
.\\" Standard preamble:
.\\" ========================================================================
$_
.\\" ========================================================================
.\\"
.IX Title "$name $section"
.TH $name $section "$$self{date}" "$$self{release}" "$$self{center}"
----END OF HEADER----

    # Initialize a few per-file variables.
d758 1
d763 18
d782 39
a820 3
##############################################################################
# Core overrides
##############################################################################
d822 18
a839 12
# Called for each command paragraph.  Gets the command, the associated
# paragraph, the line number, and a Pod::Paragraph object.  Just dispatches
# the command to a method named the same as the command.  =cut is handled
# internally by Pod::Parser.
sub command {
    my $self = shift;
    my $command = shift;
    return if $command eq 'pod';
    return if ($$self{EXCLUDE} && $command ne 'end');
    if ($self->can ('cmd_' . $command)) {
        $command = 'cmd_' . $command;
        $self->$command (@@_);
d841 1
a841 7
        my ($text, $line, $paragraph) = @@_;
        my $file;
        ($file, $line) = $paragraph->file_line;
        $text =~ s/\n+\z//;
        $text = " $text" if ($text =~ /^\S/);
        warn qq($file:$line: Unknown command paragraph "=$command$text"\n);
        return;
d843 1
d846 54
a899 17
# Called for a verbatim paragraph.  Gets the paragraph, the line number, and a
# Pod::Paragraph object.  Rofficate backslashes, untabify, put a zero-width
# character at the beginning of each line to protect against commands, and
# wrap in .Vb/.Ve.
sub verbatim {
    my $self = shift;
    return if $$self{EXCLUDE};
    local $_ = shift;
    return if /^\s+$/;
    s/\s+$/\n/;
    my $lines = tr/\n/\n/;
    1 while s/^(.*?)(\t+)/$1 . ' ' x (length ($2) * 8 - length ($1) % 8)/me;
    s/\\/\\e/g;
    s/^(\s*\S)/'\&' . $1/gme;
    $self->makespace;
    $self->output (".Vb $lines\n$_.Ve\n");
    $$self{NEEDSPACE} = 1;
d902 3
a904 6
# Called for a regular text block.  Gets the paragraph, the line number, and a
# Pod::Paragraph object.  Perform interpolation and output the results.
sub textblock {
    my $self = shift;
    return if $$self{EXCLUDE};
    $self->output ($_[0]), return if $$self{VERBATIM};
d906 6
a911 6
    # Parse the tree.  collapse knows about references to scalars as well as
    # scalars and does the right thing with them.  Tidy up any trailing
    # whitespace.
    my $text = shift;
    $text = $self->parse ($text, @@_);
    $text =~ s/\n\s*$/\n/;
d923 12
a934 1
    $self->output (protect $self->textmapfonts ($text));
d937 1
d940 22
a961 37
# Called for a formatting code.  Takes a Pod::InteriorSequence object and
# returns a reference to a scalar.  This scalar is the final formatted text.
# It's returned as a reference to an array so that other formatting codes
# above us know that the text has already been processed.
sub sequence {
    my ($self, $seq) = @@_;
    my $command = $seq->cmd_name;

    # We have to defer processing of the inside of an L<> formatting code.  If
    # this code is nested inside an L<> code, return the literal raw text of
    # it.
    my $parent = $seq->nested;
    while (defined $parent) {
        return $seq->raw_text if ($parent->cmd_name eq 'L');
        $parent = $parent->nested;
    }

    # Zero-width characters.
    return [ '\&' ] if ($command eq 'Z');

    # C<>, L<>, X<>, and E<> don't apply guesswork to their contents.  C<>
    # needs some additional special handling.
    my $literal = ($command =~ /^[CELX]$/);
    local $_ = $self->collapse ($seq->parse_tree, $literal, $command eq 'C');

    # Handle E<> escapes.  Numeric escapes that match one of the supported ISO
    # 8859-1 characters don't work at present.
    if ($command eq 'E') {
        if (/^\d+$/) {
            return [ chr ($_) ];
        } elsif (exists $ESCAPES{$_}) {
            return [ $ESCAPES{$_} ];
        } else {
            my ($file, $line) = $seq->file_line;
            warn "$file:$line: Unknown escape E<$_>\n";
            return [ "E<$_>" ];
        }
d963 1
d965 2
a966 2
    # For all the other codes, empty content produces no output.
    return '' if $_ eq '';
d968 6
a973 30
    # Handle simple formatting codes.
    if ($command eq 'B') {
        return [ '\f(BS' . $_ . '\f(BE' ];
    } elsif ($command eq 'F' || $command eq 'I') {
        return [ '\f(IS' . $_ . '\f(IE' ];
    } elsif ($command eq 'C') {
        return [ $self->quote_literal ($_) ];
    }

    # Handle links.
    if ($command eq 'L') {
        my ($text, $type) = (parselink ($_))[1,4];
        return '' unless $text;
        my ($file, $line) = $seq->file_line;
        $text = $self->parse ($text, $line);
        $text = '<' . $text . '>' if $type eq 'url';
        return [ $text ];
    }

    # Whitespace protection replaces whitespace with "\ ".
    if ($command eq 'S') {
        s/\s+/\\ /g;
        return [ $_ ];
    }

    # Add an index entry to the list of ones waiting to be output.
    if ($command eq 'X') {
        push (@@{ $$self{INDEX} }, $_);
        return '';
    }
d975 8
a982 3
    # Anything else is unknown.
    my ($file, $line) = $seq->file_line;
    warn "$file:$line: Unknown formatting code $command<$_>\n";
a984 1

d986 1
a986 1
# Command paragraphs
d989 7
a995 1
# All command paragraphs take the paragraph and the line number.
d997 2
a998 12
# First level heading.  We can't output .IX in the NAME section due to a bug
# in some versions of catman, so don't output a .IX for that section.  .SH
# already uses small caps, so remove \s1 and \s-1.  Maintain IN_NAME as
# appropriate, but don't leave it set while calling parse() so as to not
# override guesswork on section headings after NAME.
sub cmd_head1 {
    my $self = shift;
    $$self{IN_NAME} = 0;
    local $_ = $self->parse (@@_);
    s/\s+$//;
    s/\\s-?\d//g;
    s/\s*\n\s*/ /g;
d1003 18
a1020 2
    $self->output ($self->switchquotes ('.SH', $self->mapfonts ($_)));
    $self->outindex (($_ eq 'NAME') ? () : ('Header', $_));
d1022 2
a1023 1
    $$self{IN_NAME} = ($_ eq 'NAME');
d1028 4
a1031 10
    my $self = shift;
    local $_ = $self->parse (@@_);
    s/\s+$//;
    s/\s*\n\s*/ /g;
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }
    $self->output ($self->switchquotes ('.Sh', $self->mapfonts ($_)));
    $self->outindex ('Subsection', $_);
d1033 1
d1036 2
a1037 1
# Third level heading.
d1039 2
a1040 8
    my $self = shift;
    local $_ = $self->parse (@@_);
    s/\s+$//;
    s/\s*\n\s*/ /g;
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }
d1042 2
a1043 2
    $self->output ($self->textmapfonts ('\f(IS' . $_ . '\f(IE') . "\n");
    $self->outindex ('Subsection', $_);
d1045 1
d1048 2
a1049 1
# Fourth level heading.
d1051 2
a1052 8
    my $self = shift;
    local $_ = $self->parse (@@_);
    s/\s+$//;
    s/\s*\n\s*/ /g;
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }
d1054 2
a1055 2
    $self->output ($self->textmapfonts ($_) . "\n");
    $self->outindex ('Subsection', $_);
d1057 26
d1085 23
a1107 6
# Start a list.  For indents after the first, wrap the outside indent in .RS
# so that hanging paragraph tags will be correct.
sub cmd_over {
    my $self = shift;
    local $_ = shift;
    unless (/^[-+]?\d+\s+$/) { $_ = $$self{indent} }
d1112 4
d1117 2
a1118 2
    push (@@{ $$self{ITEMTYPES} }, 'unknown');
    $$self{INDENT} = ($_ + 0);
d1122 9
a1130 5
# End a list.  If we've closed an embedded indent, we've mangled the hanging
# paragraph indent, so temporarily replace it with .RS and set WEIRDINDENT.
# We'll close that .RS at the next =back or =item.
sub cmd_back {
    my $self = shift;
d1132 3
a1134 8
    if (defined $$self{INDENT}) {
        pop @@{ $$self{ITEMTYPES} };
    } else {
        my ($file, $line, $paragraph) = @@_;
        ($file, $line) = $paragraph->file_line;
        warn "$file:$line: Unmatched =back\n";
        $$self{INDENT} = 0;
    }
d1139 3
d1150 9
a1158 39
# An individual list item.  Emit an index entry for anything that's
# interesting, but don't emit index entries for things like bullets and
# numbers.  rofficate bullets too while we're at it (so for nice output, use *
# for your lists rather than o or . or - or some other thing).  Newlines in an
# item title are turned into spaces since *roff can't handle them embedded.
sub cmd_item {
    my $self = shift;
    local $_ = $self->parse (@@_);
    s/\s+$//;
    s/\s*\n\s*/ /g;
    my $index;
    if (/\w/ && !/^\w[.\)]\s*$/) {
        $index = $_;
        $index =~ s/^\s*[-*+o.]?(?:\s+|\Z)//;
    }
    $_ = '*' unless length ($_) > 0;
    my $type = $$self{ITEMTYPES}[0];
    unless (defined $type) {
        my ($file, $line, $paragraph) = @@_;
        ($file, $line) = $paragraph->file_line;
        $type = 'unknown';
    }
    if ($type eq 'unknown') {
        $type = /^\*\s*\Z/ ? 'bullet' : 'text';
        $$self{ITEMTYPES}[0] = $type if $$self{ITEMTYPES}[0];
    }
    s/^\*\s*\Z/\\\(bu/ if $type eq 'bullet';
    if (@@{ $$self{SHIFTS} } == @@{ $$self{INDENTS} }) {
        $self->output (".RE\n");
        pop @@{ $$self{SHIFTS} };
    }
    $_ = $self->textmapfonts ($_);
    $self->output (".PD 0\n") if ($$self{ITEMS} == 1);
    $self->output ($self->switchquotes ('.IP', $_, $$self{INDENT}));
    $self->outindex ($index ? ('Item', $index) : ());
    $$self{NEEDSPACE} = 0;
    $$self{ITEMS}++;
    $$self{SHIFTWAIT} = 0;
}
d1160 21
a1180 8
# Begin a block for a particular translator.  Setting VERBATIM triggers
# special handling in textblock().
sub cmd_begin {
    my $self = shift;
    local $_ = shift;
    my ($kind) = /^(\S+)/ or return;
    if ($kind eq 'man' || $kind eq 'roff') {
        $$self{VERBATIM} = 1;
d1182 4
a1185 1
        $$self{EXCLUDE} = 1;
a1186 211
}

# End a block for a particular translator.  We assume that all =begin/=end
# pairs are properly closed.
sub cmd_end {
    my $self = shift;
    $$self{EXCLUDE} = 0;
    $$self{VERBATIM} = 0;
}

# One paragraph for a particular translator.  Ignore it unless it's intended
# for man or roff, in which case we output it verbatim.
sub cmd_for {
    my $self = shift;
    local $_ = shift;
    return unless s/^(?:man|roff)\b[ \t]*\n?//;
    $self->output ($_);
}


##############################################################################
# Escaping and fontification
##############################################################################

# At this point, we'll have embedded font codes of the form \f(<font>[SE]
# where <font> is one of B, I, or F.  Turn those into the right font start or
# end codes.  The old pod2man didn't get B<someI<thing> else> right; after I<>
# it switched back to normal text rather than bold.  We take care of this by
# using variables as a combined pointer to our current font sequence, and set
# each to the number of current nestings of start tags for that font.  Use
# them as a vector to look up what font sequence to use.
#
# \fP changes to the previous font, but only one previous font is kept.  We
# don't know what the outside level font is; normally it's R, but if we're
# inside a heading it could be something else.  So arrange things so that the
# outside font is always the "previous" font and end with \fP instead of \fR.
# Idea from Zack Weinberg.
sub mapfonts {
    my $self = shift;
    local $_ = shift;

    my ($fixed, $bold, $italic) = (0, 0, 0);
    my %magic = (F => \$fixed, B => \$bold, I => \$italic);
    my $last = '\fR';
    s { \\f\((.)(.) } {
        my $sequence = '';
        my $f;
        if ($last ne '\fR') { $sequence = '\fP' }
        ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
        $f = $$self{FONTS}{($fixed && 1) . ($bold && 1) . ($italic && 1)};
        if ($f eq $last) {
            '';
        } else {
            if ($f ne '\fR') { $sequence .= $f }
            $last = $f;
            $sequence;
        }
    }gxe;
    $_;
}

# Unfortunately, there is a bug in Solaris 2.6 nroff (not present in GNU
# groff) where the sequence \fB\fP\f(CW\fP leaves the font set to B rather
# than R, presumably because \f(CW doesn't actually do a font change.  To work
# around this, use a separate textmapfonts for text blocks where the default
# font is always R and only use the smart mapfonts for headings.
sub textmapfonts {
    my $self = shift;
    local $_ = shift;

    my ($fixed, $bold, $italic) = (0, 0, 0);
    my %magic = (F => \$fixed, B => \$bold, I => \$italic);
    s { \\f\((.)(.) } {
        ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
        $$self{FONTS}{($fixed && 1) . ($bold && 1) . ($italic && 1)};
    }gxe;
    $_;
}


##############################################################################
# *roff-specific parsing and magic
##############################################################################

# Called instead of parse_text, calls parse_text with the right flags.
sub parse {
    my $self = shift;
    $self->parse_text ({ -expand_seq   => 'sequence',
                         -expand_ptree => 'collapse' }, @@_);
}

# Takes a parse tree, a flag saying whether or not to treat it as literal text
# (not call guesswork on it), and a flag saying whether or not to clean some
# things up for *roff, and returns the concatenation of all of the text
# strings in that parse tree.  If the literal flag isn't true, guesswork()
# will be called on all plain scalars in the parse tree.  Otherwise, if
# collapse is being called on a C<> code, $cleanup should be set to true and
# some additional cleanup will be done.  Assumes that everything in the parse
# tree is either a scalar or a reference to a scalar.
sub collapse {
    my ($self, $ptree, $literal, $cleanup) = @@_;

    # If we're processing the NAME section, don't do normal guesswork.  This
    # is because NAME lines are often extracted by utilities like catman that
    # require plain text and don't understand *roff markup.  We still need to
    # escape backslashes and hyphens for *roff (and catman expects \- instead
    # of -).
    if ($$self{IN_NAME}) {
        $literal = 1;
        $cleanup = 1;
    }

    # Do the collapse of the parse tree as described above.
    return join ('', map {
        if (ref $_) {
            join ('', @@$_);
        } elsif ($literal) {
            if ($cleanup) {
                s/\\/\\e/g;
                s/-/\\-/g;
                s/__/_\\|_/g;
            }
            $_;
        } else {
            $self->guesswork ($_);
        }
    } $ptree->children);
}

# Takes a text block to perform guesswork on; this is guaranteed not to
# contain any formatting codes.  Returns the text block with remapping done.
sub guesswork {
    my $self = shift;
    local $_ = shift;

    # rofficate backslashes.
    s/\\/\\e/g;

    # Ensure double underbars have a tiny space between them.
    s/__/_\\|_/g;

    # Leave hyphens only if they're part of regular words and there is only
    # one dash at a time.  Leave a dash after the first character as a regular
    # non-breaking dash, but don't let it mark the rest of the word invalid
    # for hyphenation.
    s/-/\\-/g;
    s{
      ( (?:\G|^|\s) [a-zA-Z] ) ( \\- )?
      ( (?: [a-zA-Z]+ \\-)+ )
      ( [a-zA-Z]+ ) (?=\s|\Z)
      \b
     } {
         my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
         $hyphen ||= '';
         $main =~ s/\\-/-/g;
         $prefix . $hyphen . $main . $suffix;
    }egx;

    # Translate -- into a real em dash if it's used like one.
    s{ (\s) \\-\\- (\s) }                         { $1 . '\*(--' . $2 }egx;
    s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx;

    # Make all caps a little smaller.  Be careful here, since we don't want to
    # make @@ARGV into small caps, nor do we want to fix the MIME in
    # MIME-Version, since it looks weird with the full-height V.
    s{
        ( ^ | [\s\(\"\'\`\[\{<>] )
        ( [A-Z] [A-Z] (?: [/A-Z+:\d_\$&] | \\- )* )
        (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | $ )
    } { $1 . '\s-1' . $2 . '\s0' }egx;

    # Italize functions in the form func().
    s{
        ( \b | \\s-1 )
        (
            [A-Za-z_] ([:\w]|\\s-?[01])+ \(\)
        )
    } { $1 . '\f(IS' . $2 . '\f(IE' }egx;

    # func(n) is a reference to a manual page.  Make it \fIfunc\fR\|(n).
    s{
        ( \b | \\s-1 )
        ( [A-Za-z_] (?:[.:\w]|\\-|\\s-?[01])+ )
        (
            \( \d [a-z]* \)
        )
    } { $1 . '\f(IS' . $2 . '\f(IE\|' . $3 }egx;

    # Convert simple Perl variable references to a fixed-width font.
    s{
        ( \s+ )
        ( [\$\@@%] [\w:]+ )
        (?! \( )
    } { $1 . '\f(FS' . $2 . '\f(FE'}egx;

    # Fix up double quotes.
    s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;

    # Make C++ into \*(C+, which is a squinched version.
    s{ \b C\+\+ } {\\*\(C+}gx;

    # All done.
    $_;
}

# Handles C<> text, deciding whether to put \*C` around it or not.  This is a
# whole bunch of messy heuristics to try to avoid overquoting, originally from
# Barrie Slaymaker.  This largely duplicates similar code in Pod::Text.
sub quote_literal {
    my $self = shift;
    local $_ = shift;
d1188 11
a1198 4
    # A regex that matches the portion of a variable reference that's the
    # array or hash index, separated out just because we want to use it in
    # several places in the following regex.
    my $index = '(?: \[.*\] | \{.*\} )?';
d1200 6
a1205 15
    # Check for things that we don't want to quote, and if we find any of
    # them, return the string with just a font change and no quoting.
    m{
      ^\s*
      (?:
         ( [\'\`\"] ) .* \1                             # already quoted
       | \` .* \'                                       # `quoted'
       | \$+ [\#^]? \S $index                           # special ($^Foo, $")
       | [\$\@@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
       | [\$\@@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
       | [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
       | 0x [a-fA-F\d]+                                 # a hex constant
      )
      \s*\z
     }xo && return '\f(FS' . $_ . '\f(FE';
d1207 8
a1214 2
    # If we didn't return, go ahead and quote the text.
    return '\f(FS\*(C`' . $_ . "\\*(C'\\f(FE";
d1217 5
d1224 1
a1224 1
# Output formatting
d1227 36
a1262 2
# Make vertical whitespace.
sub makespace {
d1264 1
a1264 4
    $self->output (".PD\n") if ($$self{ITEMS} > 1);
    $$self{ITEMS} = 0;
    $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n")
        if $$self{NEEDSPACE};
d1267 3
a1269 23
# Output any pending index entries, and optionally an index entry given as an
# argument.  Support multiple index entries in X<> separated by slashes, and
# strip special escapes from index entries.
sub outindex {
    my ($self, $section, $index) = @@_;
    my @@entries = map { split m%\s*/\s*% } @@{ $$self{INDEX} };
    return unless ($section || @@entries);
    $$self{INDEX} = [];
    my @@output;
    if (@@entries) {
        push (@@output, [ 'Xref', join (' ', @@entries) ]);
    }
    if ($section) {
        $index =~ s/\\-/-/g;
        $index =~ s/\\(?:s-?\d|.\(..|.)//g;
        push (@@output, [ $section, $index ]);
    }
    for (@@output) {
        my ($type, $entry) = @@$_;
        $entry =~ s/\"/\"\"/g;
        $self->output (".IX $type " . '"' . $entry . '"' . "\n");
    }
}
d1271 27
a1297 2
# Output text to the output device.
sub output { print { $_[0]->output_handle } $_[1] }
d1299 2
a1300 13
# Given a command and a single argument that may or may not contain double
# quotes, handle double-quote formatting for it.  If there are no double
# quotes, just return the command followed by the argument in double quotes.
# If there are double quotes, use an if statement to test for nroff, and for
# nroff output the command followed by the argument in double quotes with
# embedded double quotes doubled.  For other formatters, remap paired double
# quotes to LQUOTE and RQUOTE.
sub switchquotes {
    my $self = shift;
    my $command = shift;
    local $_ = shift;
    my $extra = shift;
    s/\\\*\([LR]\"/\"/g;
d1302 3
a1304 21
    # We also have to deal with \*C` and \*C', which are used to add the
    # quotes around C<> text, since they may expand to " and if they do this
    # confuses the .SH macros and the like no end.  Expand them ourselves.
    # Also separate troff from nroff if there are any fixed-width fonts in use
    # to work around problems with Solaris nroff.
    my $c_is_quote = ($$self{LQUOTE} =~ /\"/) || ($$self{RQUOTE} =~ /\"/);
    my $fixedpat = join ('|', @@{ $$self{FONTS} }{'100', '101', '110', '111'});
    $fixedpat =~ s/\\/\\\\/g;
    $fixedpat =~ s/\(/\\\(/g;
    if (/\"/ || /$fixedpat/) {
        s/\"/\"\"/g;
        my $nroff = $_;
        my $troff = $_;
        $troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;
        if ($c_is_quote && /\\\*\(C[\'\`]/) {
            $nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;
            $nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;
            $troff =~ s/\\\*\(C[\'\`]//g;
        }
        $nroff = qq("$nroff") . ($extra ? " $extra" : '');
        $troff = qq("$troff") . ($extra ? " $extra" : '');
d1306 135
a1440 20
        # Work around the Solaris nroff bug where \f(CW\fP leaves the font set
        # to Roman rather than the actual previous font when used in headings.
        # troff output may still be broken, but at least we can fix nroff by
        # just switching the font changes to the non-fixed versions.
        $nroff =~ s/\Q$$self{FONTS}{100}\E(.*)\\f[PR]/$1/g;
        $nroff =~ s/\Q$$self{FONTS}{101}\E(.*)\\f([PR])/\\fI$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{110}\E(.*)\\f([PR])/\\fB$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{111}\E(.*)\\f([PR])/\\f\(BI$1\\f$2/g;

        # Now finally output the command.  Only bother with .ie if the nroff
        # and troff output isn't the same.
        if ($nroff ne $troff) {
            return ".ie n $command $nroff\n.el $command $troff\n";
        } else {
            return "$command $nroff\n";
        }
    } else {
        $_ = qq("$_") . ($extra ? " $extra" : '');
        return "$command $_\n";
    }
d1460 1
a1460 1
    $parser->parse_from_filehandle;
d1474 2
a1475 4
As a derived class from Pod::Parser, Pod::Man supports the same methods and
interfaces.  See L<Pod::Parser> for all the details; briefly, one creates a
new parser with C<< Pod::Man->new() >> and then calls either
parse_from_filehandle() or parse_from_file().
d1589 12
a1600 7
The standard Pod::Parser method parse_from_filehandle() takes up to two
arguments, the first being the file handle to read POD from and the second
being the file handle to write the formatted output to.  The first defaults
to STDIN if not given, and the second defaults to STDOUT.  The method
parse_from_file() is almost identical, except that its two arguments are the
input and output disk files instead.  See L<Pod::Parser> for the specific
details.
a1612 6
=item Invalid link %s

(W) The POD source contained a C<LE<lt>E<gt>> formatting code that
Pod::Man was unable to parse.  You should never see this error message; it
probably indicates a bug in Pod::Man.

a1617 20
=item %s:%d: Unknown command paragraph "%s".

(W) The POD source contained a non-standard command paragraph (something of
the form C<=command args>) that Pod::Man didn't know about.  It was ignored.

=item %s:%d: Unknown escape EE<lt>%sE<gt>

(W) The POD source contained an C<EE<lt>E<gt>> escape that Pod::Man didn't
know about.  C<EE<lt>%sE<gt>> was printed verbatim in the output.

=item %s:%d: Unknown formatting code %s

(W) The POD source contained a non-standard formatting code (something of
the form C<XE<lt>E<gt>>) that Pod::Man didn't know about.  It was ignored.

=item %s:%d: Unmatched =back

(W) Pod::Man encountered a C<=back> command that didn't correspond to an
C<=over> command.

d1633 3
a1635 1
when using POD to document something other than Perl).
d1640 2
a1641 1
page processors.
d1647 4
a1650 4
The preamble added to each output file is rather verbose, and most of it is
only necessary in the presence of EE<lt>E<gt> escapes for non-ASCII
characters.  It would ideally be nice if all of those definitions were only
output if needed, perhaps on the fly as the characters are used.
d1663 20
d1685 1
a1685 1
L<Pod::Parser>, L<perlpod(1)>, L<pod2man(1)>, L<nroff(1)>, L<troff(1)>,
a1701 12

=head1 AUTHOR

Russ Allbery <rra@@stanford.edu>, based I<very> heavily on the original
B<pod2man> by Tom Christiansen <tchrist@@mox.perl.com>.

=head1 COPYRIGHT AND LICENSE

Copyright 1999, 2000, 2001, 2002, 2003 by Russ Allbery <rra@@stanford.edu>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
@


1.9
log
@make sure pod parsers are in a sane state at beginning of parse.

pod2text and pod2man re-use the same parser on a list of files,
and will lose some information if some intermediate documents produce
unbalanced calls to begin_cmd/end_cmd.

okay millert@@
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.8 2003/12/03 03:02:40 millert Exp $
d260 1
@


1.8
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.37 2003/03/30 22:34:11 eagle Exp $
d477 2
@


1.7
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.34 2002/07/15 05:46:00 eagle Exp $
d4 1
a4 1
# Copyright 1999, 2000, 2001, 2002 by Russ Allbery <rra@@stanford.edu>
d41 1
a41 1
$VERSION = 1.34;
d474 1
d541 3
a543 3
    # there's an =over without =item, NEWINDENT will be set, and we need to
    # handle creation of the indent here.  Set WEIRDINDENT so that it will be
    # cleaned up on =back.
d720 1
d731 3
a733 1
    unless (defined $$self{INDENT}) {
d766 12
a777 2
    $_ = '*' unless $_;
    s/^\*(\s|\Z)/\\\(bu$1/;
a1137 2
__END__

d1139 1
a1139 1
# Documentation
d1142 3
d1405 1
a1405 1
Copyright 1999, 2000, 2001, 2002 by Russ Allbery <rra@@stanford.edu>.
@


1.6
log
@merge in perl 5.6.1 with our local changes
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.15 2001/02/10 06:50:22 eagle Exp $
d4 1
a4 1
# Copyright 1999, 2000, 2001 by Russ Allbery <rra@@stanford.edu>
d6 1
a6 1
# This program is free software; you can redistribute it and/or modify it
d9 5
a13 5
# This module is intended to be a replacement for the pod2man script
# distributed with versions of Perl prior to 5.6, and attempts to match its
# output except for some specific circumstances where other decisions seemed
# to produce better output.  It uses Pod::Parser and is designed to be easy
# to subclass.
d20 1
a20 1
############################################################################
d22 1
a22 1
############################################################################
d26 1
a26 1
require 5.004;
d29 1
d38 4
a41 5
# Don't use the CVS revision as the version, since this module is also in
# Perl core and too many things could munge CVS magic revision strings.
# This number should ideally be the same as the CVS revision in podlators,
# however.
$VERSION = 1.15;
d44 1
a44 1
############################################################################
d46 1
a46 1
############################################################################
d51 2
a52 3
# quotes to use for C<> text, designated by @@LQOUTE@@ and @@RQUOTE@@.
# $PREAMBLE should therefore be run through s/\@@CFONT\@@/<font>/g before
# output.
a65 6
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
a72 1

d78 3
a80 3
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used
.\" to do unbreakable dashes and therefore won't be available.  \*(C` and
.\" \*(C' expand to `' in nroff, nothing in troff, for use with C<>
d100 4
a103 4
.\" If the F register is turned on, we'll generate index entries on stderr
.\" for titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and
.\" index entries marked with X<> in POD.  Of course, you'll have to process
.\" the output yourself in some meaningful fashion.
d112 2
a113 2
.\" For nroff, turn off justification.  Always turn off hyphenation; it
.\" makes way too many mistakes in technical documents.
a118 1
.bd B 3
d188 1
d257 3
d263 1
a263 1
############################################################################
d265 1
a265 1
############################################################################
d267 4
a270 4
# Protect leading quotes and periods against interpretation as commands.
# Also protect anything starting with a backslash, since it could expand
# or hide something that *roff would interpret as a command.  This is
# overkill, but it's much simpler than trying to parse *roff here.
d281 1
a281 1
############################################################################
d283 1
a283 1
############################################################################
d285 6
a290 6
# Initialize the object.  Here, we also process any additional options
# passed to the constructor or set up defaults if none were given.  center
# is the centered title, release is the version number, and date is the date
# for the documentation.  Note that we can't know what file name we're
# processing due to the architecture of Pod::Parser, so that *has* to either
# be passed to the constructor or set separately with Pod::Man::name().
d294 2
a295 2
    # Figure out the fixed-width font.  If user-supplied, make sure that
    # they are the right length.
d307 2
a308 2
    # Set the default fonts.  We can't be sure what fixed bold-italic is
    # going to be called, so default to just bold.
d314 2
a315 2
    # Set up a table of font escapes.  First number is fixed-width, second
    # is bold, third is italic.
d326 1
a326 1
    $$self{indent}  = 4 unless defined $$self{indent};
d328 4
a331 4
    # We used to try first to get the version number from a local binary,
    # but we shouldn't need that any more.  Get the version from the running
    # Perl.  Work a little magic to handle subversions correctly under both
    # the pre-5.6 and the post-5.6 version numbering schemes.
d359 3
a361 3
    # Double the first quote; note that this should not be s///g as two
    # double quotes is represented in *roff as three double quotes, not
    # four.  Weird, I know.
a364 5
    $$self{INDENT}  = 0;        # Current indentation level.
    $$self{INDENTS} = [];       # Stack of indentations.
    $$self{INDEX}   = [];       # Index keys waiting to be printed.
    $$self{ITEMS}   = 0;        # The number of consecutive =items.

d379 1
a379 1
        if ($section =~ /^1/) {
d383 27
a409 13
            # Lose everything up to the first of
            #     */lib/*perl*      standard or site_perl module
            #     */*perl*/lib      from -D prefix=/opt/perl
            #     */*perl*/         random module hierarchy
            # which works.  Should be fixed to use File::Spec.  Also handle
            # a leading lib/ since that's what ExtUtils::MakeMaker creates.
            for ($name) {
                s%//+%/%g;
                if (     s%^.*?/lib/[^/]*perl[^/]*/%%si
                      or s%^.*?/[^/]*perl[^/]*/(?:lib/)?%%si) {
                    s%^site(_perl)?/%%s;      # site and site_perl
                    s%^(.*-$^O|$^O-.*)/%%so;  # arch
                    s%^\d+\.\d+%%s;           # version
a410 2
                s%^lib/%%;
                s%/%::%g;
d412 12
d427 2
a428 2
    # If $name contains spaces, quote it; this mostly comes up in the case
    # of input from stdin.
d441 9
a449 1
    # Now, print out the preamble and the title.
d455 1
d457 1
a457 2
.\\" Automatically generated by Pod::Man version $VERSION
.\\" @@{[ scalar localtime ]}
d460 1
a460 1
.\\" ======================================================================
d462 1
a462 1
.\\" ======================================================================
d465 1
a465 2
.TH $name $section "$$self{release}" "$$self{date}" "$$self{center}"
.UC
a466 1
#"# for cperl-mode
d469 7
a475 2
    $$self{INDENT} = 0;
    $$self{NEEDSPACE} = 0;
d479 1
a479 1
############################################################################
d481 1
a481 1
############################################################################
d491 1
a491 1
   return if ($$self{EXCLUDE} && $command ne 'end');
d495 1
a495 1
     } else {
d506 4
a509 4
# Called for a verbatim paragraph.  Gets the paragraph, the line number, and
# a Pod::Paragraph object.  Rofficate backslashes, untabify, put a
# zero-width character at the beginning of each line to protect against
# commands, and wrap in .Vb/.Ve.
d522 1
a522 1
    $$self{NEEDSPACE} = 0;
d525 2
a526 2
# Called for a regular text block.  Gets the paragraph, the line number, and
# a Pod::Paragraph object.  Perform interpolation and output the results.
d532 3
a534 3
    # Perform a little magic to collapse multiple L<> references.  We'll
    # just rewrite the whole thing into actual text at this part, bypassing
    # the whole internal sequence parsing thing.
a535 34
    $text =~ s{
        (L<                     # A link of the form L</something>.
              /
              (
                  [:\w]+        # The item has to be a simple word...
                  (\(\))?       # ...or simple function.
              )
          >
          (
              ,?\s+(and\s+)?    # Allow lots of them, conjuncted.
              L<
                  /
                  ( [:\w]+ ( \(\) )? )
              >
          )+
        )
    } {
        local $_ = $1;
        s{ L< / ( [^>]+ ) > } {$1}xg;
        my @@items = split /(?:,?\s+(?:and\s+)?)/;
        my $string = 'the ';
        my $i;
        for ($i = 0; $i < @@items; $i++) {
            $string .= $items[$i];
            $string .= ', ' if @@items > 2 && $i != $#items;
            $string .= ' ' if @@items == 2 && $i == 2;
            $string .= 'and ' if ($i == $#items - 1);
        }
        $string .= ' entries elsewhere in this document';
        $string;
    }gex;

    # Parse the tree and output it.  collapse knows about references to
    # scalars as well as scalars and does the right thing with them.
d538 5
d544 5
d554 1
a554 1
# Called for an interior sequence.  Takes a Pod::InteriorSequence object and
d556 2
a557 2
# It's returned as a reference so that other interior sequences above us
# know that the text has already been processed.
d562 9
d572 1
a572 5
    if ($command eq 'Z') {
        # Workaround to generate a blessable reference, needed by 5.005.
        my $tmp = '\&';
        return bless \ "$tmp", 'Pod::Man::String';
    }
d577 1
a577 2
    $literal++ if $command eq 'C';
    local $_ = $self->collapse ($seq->parse_tree, $literal);
d579 2
a580 1
    # Handle E<> escapes.
d583 1
a583 1
            return bless \ chr ($_), 'Pod::Man::String';
d585 1
a585 1
            return bless \ "$ESCAPES{$_}", 'Pod::Man::String';
d587 3
a589 2
            carp "Unknown escape E<$1>";
            return bless \ "E<$_>", 'Pod::Man::String';
d593 1
a593 1
    # For all the other sequences, empty content produces no output.
d596 1
a596 1
    # Handle formatting sequences.
d598 3
a600 5
        return bless \ ('\f(BS' . $_ . '\f(BE'), 'Pod::Man::String';
    } elsif ($command eq 'F') {
        return bless \ ('\f(IS' . $_ . '\f(IE'), 'Pod::Man::String';
    } elsif ($command eq 'I') {
        return bless \ ('\f(IS' . $_ . '\f(IE'), 'Pod::Man::String';
d602 1
a602 2
        return bless \ ('\f(FS\*(C`' . $_ . "\\*(C'\\f(FE"),
            'Pod::Man::String';
d607 6
a612 3
        # A bug in lvalue subs in 5.6 requires the temporary variable.
        my $tmp = $self->buildlink ($_);
        return bless \ "$tmp", 'Pod::Man::String';
d618 1
a618 1
        return bless \ "$_", 'Pod::Man::String';
d622 4
a625 1
    if ($command eq 'X') { push (@@{ $$self{INDEX} }, $_); return '' }
d628 2
a629 1
    carp "Unknown sequence $command<$_>";
d633 1
a633 1
############################################################################
d635 1
a635 1
############################################################################
d641 3
a643 2
# already uses small caps, so remove any E<> sequences that would cause
# them.
d646 1
d658 1
d687 1
a687 1
    $self->output ($self->switchquotes ('.I', $self->mapfonts ($_)));
d714 1
a714 1
    if (@@{ $$self{INDENTS} } > 0) {
d716 1
d720 1
d730 3
a732 1
        carp "Unmatched =back";
d735 1
a735 1
    if ($$self{WEIRDINDENT}) {
d737 1
a737 1
        $$self{WEIRDINDENT} = 0;
a741 1
        $$self{WEIRDINDENT} = 1;
d744 1
d749 3
a751 4
# numbers.  rofficate bullets too while we're at it (so for nice output, use
# * for your lists rather than o or . or - or some other thing).  Newlines
# in an item title are turned into spaces since *roff can't handle them
# embedded.
d762 1
d764 1
a764 1
    if ($$self{WEIRDINDENT}) {
d766 1
a766 1
        $$self{WEIRDINDENT} = 0;
d770 1
a770 1
    $self->output ($self->switchquotes ('.Ip', $_, $$self{INDENT}));
d774 1
d808 1
a808 68
############################################################################
# Link handling
############################################################################

# Handle links.  We can't actually make real hyperlinks, so this is all to
# figure out what text and formatting we print out.
sub buildlink {
    my $self = shift;
    local $_ = shift;

    # Smash whitespace in case we were split across multiple lines.
    s/\s+/ /g;

    # If we were given any explicit text, just output it.
    if (m{ ^ ([^|]+) \| }x) { return $1 }

    # Okay, leading and trailing whitespace isn't important.
    s/^\s+//;
    s/\s+$//;

    # If the argument looks like a URL, return it verbatim.  This only
    # handles URLs that use the server syntax.
    if (m%^[a-z]+://\S+$%) { return $_ }

    # Default to using the whole content of the link entry as a section
    # name.  Note that L<manpage/> forces a manpage interpretation, as does
    # something looking like L<manpage(section)>.  Do the same thing to
    # L<manpage(section)> as we would to manpage(section) without the L<>;
    # see guesswork().  If we've added italics, don't add the "manpage"
    # text; markup is sufficient.
    my ($manpage, $section) = ('', $_);
    if (/^"\s*(.*?)\s*"$/) {
        $section = '"' . $1 . '"';
    } elsif (m{ ^ [-:.\w]+ (?: \( \S+ \) )? $ }x) {
        ($manpage, $section) = ($_, '');
        $manpage =~ s/^([^\(]+)\(/'\f(IS' . $1 . '\f(IE\|('/e;
    } elsif (m%/%) {
        ($manpage, $section) = split (/\s*\/\s*/, $_, 2);
        if ($manpage =~ /^[-:.\w]+(?:\(\S+\))?$/) {
            $manpage =~ s/^([^\(]+)\(/'\f(IS' . $1 . '\f(IE\|'/e;
        }
        $section =~ s/^\"\s*//;
        $section =~ s/\s*\"$//;
    }
    if ($manpage && $manpage !~ /\\f\(IS/) {
        $manpage = "the $manpage manpage";
    }

    # Now build the actual output text.
    my $text = '';
    if (!length ($section) && !length ($manpage)) {
        carp "Invalid link $_";
    } elsif (!length ($section)) {
        $text = $manpage;
    } elsif ($section =~ /^[:\w]+(?:\(\))?/) {
        $text .= 'the ' . $section . ' entry';
        $text .= (length $manpage) ? " in $manpage"
                                   : " elsewhere in this document";
    } else {
        if ($section !~ /^".*"$/) { $section = '"' . $section . '"' }
        $text .= 'the section on ' . $section;
        $text .= " in $manpage" if length $manpage;
    }
    $text;
}


############################################################################
d810 1
a810 1
############################################################################
d813 6
a818 6
# where <font> is one of B, I, or F.  Turn those into the right font start
# or end codes.  The old pod2man didn't get B<someI<thing> else> right;
# after I<> it switched back to normal text rather than bold.  We take care
# of this by using variables as a combined pointer to our current font
# sequence, and set each to the number of current nestings of start tags for
# that font.  Use them as a vector to look up what font sequence to use.
d822 3
a824 3
# inside a heading it could be something else.  So arrange things so that
# the outside font is always the "previous" font and end with \fP instead of
# \fR.  Idea from Zack Weinberg.
d851 3
a853 3
# than R, presumably because \f(CW doesn't actually do a font change.  To
# work around this, use a separate textmapfonts for text blocks where the
# default font is always R and only use the smart mapfonts for headings.
d868 3
a870 3
############################################################################
# *roff-specific parsing
############################################################################
d879 8
a886 8
# Takes a parse tree and a flag saying whether or not to treat it as literal
# text (not call guesswork on it), and returns the concatenation of all of
# the text strings in that parse tree.  If the literal flag isn't true,
# guesswork() will be called on all plain scalars in the parse tree.
# Otherwise, just escape backslashes in the normal case.  If collapse is
# being called on a C<> sequence, literal is set to 2, and we do some
# additional cleanup.  Assumes that everything in the parse tree is either a
# scalar or a reference to a scalar.
d888 18
a905 6
    my ($self, $ptree, $literal) = @@_;
    if ($literal) {
        return join ('', map {
            if (ref $_) {
                $$_;
            } else {
d907 2
a908 3
                s/-/\\-/g    if $literal > 1;
                s/__/_\\|_/g if $literal > 1;
                $_;
d910 5
a914 6
        } $ptree->children);
    } else {
        return join ('', map {
            ref ($_) ? $$_ : $self->guesswork ($_)
        } $ptree->children);
    }
d918 1
a918 2
# contain any interior sequences.  Returns the text block with remapping
# done.
d929 23
a951 2
    # Make all caps a little smaller.  Be careful here, since we don't want
    # to make @@ARGV into small caps, nor do we want to fix the MIME in
d955 2
a956 2
        ( [A-Z] [A-Z] [/A-Z+:\d_\$&-]* )
        (?: (?= [\s>\}\]\)\'\".?!,;:] | -- ) | $ )
a958 3
    # Turn PI into a pretty pi.
    s{ (?: \\s-1 | \b ) PI (?: \\s0 | \b ) } {\\*\(PI}gx;

d961 1
a961 1
        \b
d963 1
a963 1
            [:\w]+ (?:\\s-1)? \(\)
d965 1
a965 1
    } { '\f(IS' . $1 . '\f(IE' }egx;
d969 2
a970 2
        \b
        (\w[-:.\w]+ (?:\\s-1)?)
d972 1
a972 1
            \( [^\)] \)
d974 1
a974 1
    } { '\f(IS' . $1 . '\f(IE\|' . $2 }egx;
a982 18
    # Translate -- into a real em dash if it's used like one and fix up
    # dashes, but keep hyphens hyphens.
    s{ (\G|^|.) (-+) (\b|.) } {
        my ($pre, $dash, $post) = ($1, $2, $3);
        if (length ($dash) == 1) {
            ($pre =~ /[a-zA-Z]/) ? "$pre-$post" : "$pre\\-$post";
        } elsif (length ($dash) == 2
                 && ((!$pre && !$post)
                     || ($pre =~ /\w/ && !$post)
                     || ($pre eq ' ' && $post eq ' ')
                     || ($pre eq '=' && $post ne '=')
                     || ($pre ne '=' && $post eq '='))) {
            "$pre\\*(--$post";
        } else {
            $pre . ('\-' x length $dash) . $post;
        }
    }egxs;

d993 32
d1026 1
a1026 1
############################################################################
d1028 1
a1028 1
############################################################################
d1039 3
a1041 3
# Output any pending index entries, and optionally an index entry given as
# an argument.  Support multiple index entries in X<> separated by slashes,
# and strip special escapes from index entries.
d1047 1
a1047 1
    my $output;
d1049 1
a1049 3
        my $output = '.IX Xref "'
            . join (' ', map { s/\"/\"\"/; $_ } @@entries)
            . '"' . "\n";
a1051 1
        $index =~ s/\"/\"\"/;
d1054 6
a1059 1
        $output .= ".IX $section " . '"' . $index . '"' . "\n";
a1060 1
    $self->output ($output);
d1083 2
a1084 2
    # If $extra is set, we're dealing with =item, which in most nroff macro
    # sets requires an extra level of quoting of double quotes.
d1086 4
a1089 1
    if (/\"/ || ($c_is_quote && /\\\*\(C[\'\`]/)) {
d1091 1
d1094 6
a1099 6
        s/\\\*\(C\`/$$self{LQUOTE}/g;
        s/\\\*\(C\'/$$self{RQUOTE}/g;
        $troff =~ s/\\\*\(C[\'\`]//g;
        s/\"/\"\"/g if $extra;
        $troff =~ s/\"/\"\"/g if $extra;
        $_ = qq("$_") . ($extra ? " $extra" : '');
d1101 17
a1117 1
        return ".if n $command $_\n.el $command $troff\n";
d1126 1
a1126 31
.\" These are some extra bits of roff that I don't want to lose track of
.\" but that have been removed from the preamble to make it a bit shorter
.\" since they're not currently being used.  They're accents and special
.\" characters we don't currently have escapes for.
.if n \{\
.    ds ? ?
.    ds ! !
.    ds q
.\}
.if t \{\
.    ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.    ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.    ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds v \h'-1'\o'\(aa\(ga'
.    ds _ \h'-1'^
.    ds . \h'-1'.
.    ds 3 3
.    ds oe oe
.    ds Oe OE
.\}

############################################################################
d1128 1
a1128 1
############################################################################
d1150 3
a1152 3
using nroff(1), normally via man(1), or printing using troff(1).  It is
conventionally invoked using the driver script B<pod2man>, but it can also
be used directly.
d1156 1
a1156 1
new parser with C<Pod::Man-E<gt>new()> and then calls either
d1177 1
a1177 1
func(), func(n), and simple variable references like $foo or @@bar so you
d1181 4
a1184 4
this--into proper em dashes, fixes "paired quotes," makes C++ and PI look
right, puts a little space between double underbars, makes ALLCAPS a teeny
bit smaller in troff(1), and escapes stuff that *roff treats as special so
that you don't have to.
d1206 1
a1206 1
Some systems may want CR instead.  Only matters for troff(1) output.
d1211 1
a1211 1
troff(1) output.
d1217 1
a1217 1
version).  Defaults to CI.  Only matters for troff(1) output.
d1223 1
a1223 1
(such as Solaris) have this font available as CX.  Only matters for troff(1)
d1226 9
d1288 1
a1288 1
versions of nroff(1) and troff(1) don't either).
d1292 3
a1294 3
(W) The POD source contained a C<LE<lt>E<gt>> sequence that Pod::Man was
unable to parse.  You should never see this error message; it probably
indicates a bug in Pod::Man.
d1306 1
a1306 1
=item Unknown escape EE<lt>%sE<gt>
d1311 1
a1311 1
=item Unknown sequence %s
d1313 1
a1313 1
(W) The POD source contained a non-standard interior sequence (something of
d1316 1
a1316 6
=item %s: Unknown command paragraph "%s" on line %d.

(W) The POD source contained a non-standard command paragraph (something of
the form C<=command args>) that Pod::Man didn't know about. It was ignored.

=item Unmatched =back
d1325 12
a1336 3
The lint-like features and strict POD format checking done by B<pod2man> are
not yet implemented and should be, along with the corresponding C<lax>
option.
a1342 7
The handling of hyphens, en dashes, and em dashes is somewhat fragile, and
one may get the wrong one under some circumstances.  This should only matter
for troff(1) output.

When and whether to use small caps is somewhat tricky, and Pod::Man doesn't
necessarily get it right.

d1344 1
a1344 1
most troff(1) implementations, but GNU troff does as an extension.  It would
d1352 3
a1354 2
Some of the automagic applied to file names assumes Unix directory
separators.
d1356 6
a1361 1
Pod::Man is excessively slow.
d1365 2
a1366 2
L<Pod::Parser|Pod::Parser>, perlpod(1), pod2man(1), nroff(1), troff(1),
man(1), man(7)
d1370 14
a1383 2
the best documentation of standard nroff(1) and troff(1).  At the time of
this writing, it's available at http://www.cs.bell-labs.com/cm/cs/cstr.html.
d1385 2
a1386 4
The man page documenting the man macro set may be man(5) instead of man(7)
on your system.  Also, please see pod2man(1) for extensive documentation on
writing manual pages if you've not done it before and aren't familiar with
the conventions.
d1388 3
a1390 1
=head1 AUTHOR
d1392 2
a1393 2
Russ Allbery E<lt>rra@@stanford.eduE<gt>, based I<very> heavily on the
original B<pod2man> by Tom Christiansen E<lt>tchrist@@mox.perl.comE<gt>.
@


1.5
log
@Better fix for all the dash shenanigans; rra@@stanford.edu
Updates Man.pm to version 1.04.
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.3 2000/04/09 09:23:54 eagle Exp $
d4 1
a4 1
# Copyright 1999, 2000 by Russ Allbery <rra@@stanford.edu>
d41 1
a41 1
$VERSION = 1.04;
d50 4
a53 2
# fixed-width font, which is designed by @@CFONT@@.  $PREAMBLE should
# therefore be run through s/\@@CFONT\@@/<font>/g before output.
d98 2
a99 2
.    ds C` `
.    ds C' '
d115 1
a115 1
.    .
d188 2
a189 1
                                   
d200 2
a280 27
                    
# Given a command and a single argument that may or may not contain double
# quotes, handle double-quote formatting for it.  If there are no double
# quotes, just return the command followed by the argument in double quotes.
# If there are double quotes, use an if statement to test for nroff, and for
# nroff output the command followed by the argument in double quotes with
# embedded double quotes doubled.  For other formatters, remap paired double
# quotes to `` and ''.
sub switchquotes {
    my $command = shift;
    local $_ = shift;
    my $extra = shift;
    s/\\\*\([LR]\"/\"/g;
    if (/\"/) {
        s/\"/\"\"/g;
        my $troff = $_;
        $troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;
        s/\"/\"\"/g if $extra;
        $troff =~ s/\"/\"\"/g if $extra;
        $_ = qq("$_") . ($extra ? " $extra" : '');
        $troff = qq("$troff") . ($extra ? " $extra" : '');
        return ".if n $command $_\n.el $command $troff\n";
    } else {
        $_ = qq("$_") . ($extra ? " $extra" : '');
        return "$command $_\n";
    }
}
d285 1
a285 1
                    
d304 2
a305 1
                croak "roff font should be 1 or 2 chars, not `$$self{$_}'";
d350 20
d373 1
d378 1
a378 3
# For each document we process, output the preamble first.  Note that the
# fixed width font is a global default; once we interpolate it into the
# PREAMBLE, it ain't ever changing.  Maybe fix this later.
d413 4
d428 5
a432 2
    $PREAMBLE =~ s/\@@CFONT\@@/$$self{fixed}/;
    chomp $PREAMBLE;
d439 1
a439 1
$PREAMBLE
d466 13
a478 3
    return if ($$self{EXCLUDE} && $command ne 'end');
    $command = 'cmd_' . $command;
    $self->$command (@@_);
d495 1
a495 1
    $self->makespace if $$self{NEEDSPACE};
d521 1
a521 1
              L<  
d547 2
a548 2
    $self->makespace if $$self{NEEDSPACE};
    $self->output (protect $self->mapfonts ($text));
d607 1
a607 1
                         
d637 6
a642 1
    $self->output (switchquotes ('.SH', $self->mapfonts ($_)));
d652 6
a657 1
    $self->output (switchquotes ('.Sh', $self->mapfonts ($_)));
d662 32
d743 1
a743 1
        $index =~ s/^\s*[-*+o.]?\s*//;
d750 3
a752 2
    $_ = $self->mapfonts ($_);
    $self->output (switchquotes ('.Ip', $_, $$self{INDENT}));
d755 1
d809 4
d862 11
a872 6
# or end codes.  B<someI<thing> else> should map to \fBsome\f(BIthing\fB
# else\fR.  The old pod2man didn't get this right; the second \fB was \fR,
# so nested sequences didn't work right.  We take care of this by using
# variables as a combined pointer to our current font sequence, and set each
# to the number of current nestings of start tags for that font.  Use them
# as a vector to look up what font sequence to use.
d879 29
d926 1
a926 1
    
d1040 4
a1043 1
    $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n");
d1072 38
d1242 12
d1290 1
a1290 1
=item roff font should be 1 or 2 chars, not `%s'
d1303 10
d1322 5
@


1.4
log
@Fix in scalar vs. list dereference bug in InputObjects.pm.  Keep
dashes in C<> blocks from getting \e prepended to them.  They should
have a \ prepended to escape them which this does correctly do yet,
but at least it produces legible documentation; rra@@stanford.edu
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.3 2000/04/09 05:40:02 millert Exp $
d41 1
a41 1
$VERSION = 1.02;
d553 5
a557 19
    # C<> needs to fix hyphens and underscores but can't apply guesswork and
    # can't just apply those fixes to the entire string, since then it might
    # mess up the results of guesswork on substrings.  So we do this
    # somewhat roundabout way of handling it.
    if ($command eq 'C') {
        my @@children = map {
            my $block = $_;
	    if (ref $block) {
		$block;
	    } else {
		$block =~ s/-/\\-/g;
		$block =~ s/__/_\\|_/g;
		bless \ "$block", 'Pod::Man::String';
            }
        } $seq->parse_tree ()->children;
    }

    # C<>, L<>, X<>, and E<> don't apply guesswork to their contents.
    local $_ = $self->collapse ($seq->parse_tree, $command =~ /^[CELX]$/);
d834 4
a837 2
# Assumes that everything in the parse tree is either a scalar or a
# reference to a scalar.
d846 2
@


1.3
log
@Fix bug when doing C<FOO I<BAR>>; rra@@stanford.edu
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.2 2000/04/06 17:06:47 millert Exp $
d558 8
a565 5
        my @@children = $seq->parse_tree ()->children;
        for (@@children) {
            unless (ref) {
                s/-/\\-/g;
                s/__/_\\|_/g;
d567 1
a567 2
        }
        $seq->parse_tree ()->children (@@children);
@


1.2
log
@perl-5.6.0 + local changes
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.2 2000/03/19 07:30:13 eagle Exp $
d553 15
a593 2
        s/-/\\-/g;
        s/__/_\\|_/g;
d882 5
a886 6
# XXX - disabled for now since it messes up on escapes nested in C<>
#    s{
#        ( ^ | [\s\(\"\'\`\[\{<>] )
#        ( [A-Z] [A-Z] [/A-Z+:\d_\$&-]* )
#        (?: (?= [\s>\}\]\)\'\".?!,;:] | -- ) | $ )
#    } { $1 . '\s-1' . $2 . '\s0' }egx;
@


1.1
log
@Initial revision
@
text
@d869 6
a874 5
    s{
        ( ^ | [\s\(\"\'\`\[\{<>] )
        ( [A-Z] [A-Z] [/A-Z+:\d_\$&-]* )
        (?: (?= [\s>\}\]\)\'\".?!,;:] | -- ) | $ )
    } { $1 . '\s-1' . $2 . '\s0' }egx;
@


1.1.1.1
log
@virgin perl 5.6.0
@
text
@@


1.1.1.2
log
@stock perl 5.6.1
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.15 2001/02/10 06:50:22 eagle Exp $
d4 1
a4 1
# Copyright 1999, 2000, 2001 by Russ Allbery <rra@@stanford.edu>
d41 1
a41 1
$VERSION = 1.15;
d50 2
a51 4
# fixed-width font, which is designed by @@CFONT@@, and the left and right
# quotes to use for C<> text, designated by @@LQOUTE@@ and @@RQUOTE@@.
# $PREAMBLE should therefore be run through s/\@@CFONT\@@/<font>/g before
# output.
d96 2
a97 2
.    ds C` @@LQUOTE@@
.    ds C' @@RQUOTE@@
d113 1
a113 1
..
d186 1
a186 2
#`# for cperl-mode

a196 2
    'sol'       =>    '/',      # solidus (forward slash)
    'verbar'    =>    '|',      # vertical bar
d276 27
d307 1
a307 1

d326 1
a326 2
                croak qq(roff font should be 1 or 2 chars,)
                    . qq( not "$$self{$_}");
a370 20
    # Figure out what quotes we'll be using for C<> text.
    $$self{quotes} ||= '"';
    if ($$self{quotes} eq 'none') {
        $$self{LQUOTE} = $$self{RQUOTE} = '';
    } elsif (length ($$self{quotes}) == 1) {
        $$self{LQUOTE} = $$self{RQUOTE} = $$self{quotes};
    } elsif ($$self{quotes} =~ /^(.)(.)$/
             || $$self{quotes} =~ /^(..)(..)$/) {
        $$self{LQUOTE} = $1;
        $$self{RQUOTE} = $2;
    } else {
        croak qq(Invalid quote specification "$$self{quotes}");
    }

    # Double the first quote; note that this should not be s///g as two
    # double quotes is represented in *roff as three double quotes, not
    # four.  Weird, I know.
    $$self{LQUOTE} =~ s/\"/\"\"/;
    $$self{RQUOTE} =~ s/\"/\"\"/;

a373 1
    $$self{ITEMS}   = 0;        # The number of consecutive =items.
d378 3
a380 1
# For each document we process, output the preamble first.
a414 4
    # If $name contains spaces, quote it; this mostly comes up in the case
    # of input from stdin.
    $name = '"' . $name . '"' if ($name =~ /\s/);

d426 2
a427 5
    local $_ = $PREAMBLE;
    s/\@@CFONT\@@/$$self{fixed}/;
    s/\@@LQUOTE\@@/$$self{LQUOTE}/;
    s/\@@RQUOTE\@@/$$self{RQUOTE}/;
    chomp $_;
d434 1
a434 1
$_
d461 3
a463 13
   return if ($$self{EXCLUDE} && $command ne 'end');
    if ($self->can ('cmd_' . $command)) {
        $command = 'cmd_' . $command;
        $self->$command (@@_);
     } else {
        my ($text, $line, $paragraph) = @@_;
        my $file;
        ($file, $line) = $paragraph->file_line;
        $text =~ s/\n+\z//;
        $text = " $text" if ($text =~ /^\S/);
        warn qq($file:$line: Unknown command paragraph "=$command$text"\n);
        return;
    }
d480 1
a480 1
    $self->makespace;
d506 1
a506 1
              L<
d532 2
a533 2
    $self->makespace;
    $self->output (protect $self->textmapfonts ($text));
d553 2
a554 5
    # C<>, L<>, X<>, and E<> don't apply guesswork to their contents.  C<>
    # needs some additional special handling.
    my $literal = ($command =~ /^[CELX]$/);
    $literal++ if $command eq 'C';
    local $_ = $self->collapse ($seq->parse_tree, $literal);
d579 2
d591 1
a591 1

d621 1
a621 6
    s/\s*\n\s*/ /g;
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }
    $self->output ($self->switchquotes ('.SH', $self->mapfonts ($_)));
d631 1
a631 6
    s/\s*\n\s*/ /g;
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }
    $self->output ($self->switchquotes ('.Sh', $self->mapfonts ($_)));
a635 32
# Third level heading.
sub cmd_head3 {
    my $self = shift;
    local $_ = $self->parse (@@_);
    s/\s+$//;
    s/\s*\n\s*/ /g;
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }
    $self->makespace;
    $self->output ($self->switchquotes ('.I', $self->mapfonts ($_)));
    $self->outindex ('Subsection', $_);
    $$self{NEEDSPACE} = 1;
}

# Fourth level heading.
sub cmd_head4 {
    my $self = shift;
    local $_ = $self->parse (@@_);
    s/\s+$//;
    s/\s*\n\s*/ /g;
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }
    $self->makespace;
    $self->output ($self->textmapfonts ($_) . "\n");
    $self->outindex ('Subsection', $_);
    $$self{NEEDSPACE} = 1;
}

d685 1
a685 1
        $index =~ s/^\s*[-*+o.]?(?:\s+|\Z)//;
d692 2
a693 3
    $_ = $self->textmapfonts ($_);
    $self->output (".PD 0\n") if ($$self{ITEMS} == 1);
    $self->output ($self->switchquotes ('.Ip', $_, $$self{INDENT}));
a695 1
    $$self{ITEMS}++;
a748 4
    # If the argument looks like a URL, return it verbatim.  This only
    # handles URLs that use the server syntax.
    if (m%^[a-z]+://\S+$%) { return $_ }

d798 6
a803 11
# or end codes.  The old pod2man didn't get B<someI<thing> else> right;
# after I<> it switched back to normal text rather than bold.  We take care
# of this by using variables as a combined pointer to our current font
# sequence, and set each to the number of current nestings of start tags for
# that font.  Use them as a vector to look up what font sequence to use.
#
# \fP changes to the previous font, but only one previous font is kept.  We
# don't know what the outside level font is; normally it's R, but if we're
# inside a heading it could be something else.  So arrange things so that
# the outside font is always the "previous" font and end with \fP instead of
# \fR.  Idea from Zack Weinberg.
a809 29
    my $last = '\fR';
    s { \\f\((.)(.) } {
        my $sequence = '';
        my $f;
        if ($last ne '\fR') { $sequence = '\fP' }
        ${ $magic{$1} } += ($2 eq 'S') ? 1 : -1;
        $f = $$self{FONTS}{($fixed && 1) . ($bold && 1) . ($italic && 1)};
        if ($f eq $last) {
            '';
        } else {
            if ($f ne '\fR') { $sequence .= $f }
            $last = $f;
            $sequence;
        }
    }gxe;
    $_;
}

# Unfortunately, there is a bug in Solaris 2.6 nroff (not present in GNU
# groff) where the sequence \fB\fP\f(CW\fP leaves the font set to B rather
# than R, presumably because \f(CW doesn't actually do a font change.  To
# work around this, use a separate textmapfonts for text blocks where the
# default font is always R and only use the smart mapfonts for headings.
sub textmapfonts {
    my $self = shift;
    local $_ = shift;

    my ($fixed, $bold, $italic) = (0, 0, 0);
    my %magic = (F => \$fixed, B => \$bold, I => \$italic);
d828 1
a828 1

d833 2
a834 4
# Otherwise, just escape backslashes in the normal case.  If collapse is
# being called on a C<> sequence, literal is set to 2, and we do some
# additional cleanup.  Assumes that everything in the parse tree is either a
# scalar or a reference to a scalar.
a842 2
                s/-/\\-/g    if $literal > 1;
                s/__/_\\|_/g if $literal > 1;
d938 1
a938 4
    $self->output (".PD\n") if ($$self{ITEMS} > 1);
    $$self{ITEMS} = 0;
    $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n")
        if $$self{NEEDSPACE};
a966 38
# Given a command and a single argument that may or may not contain double
# quotes, handle double-quote formatting for it.  If there are no double
# quotes, just return the command followed by the argument in double quotes.
# If there are double quotes, use an if statement to test for nroff, and for
# nroff output the command followed by the argument in double quotes with
# embedded double quotes doubled.  For other formatters, remap paired double
# quotes to LQUOTE and RQUOTE.
sub switchquotes {
    my $self = shift;
    my $command = shift;
    local $_ = shift;
    my $extra = shift;
    s/\\\*\([LR]\"/\"/g;

    # We also have to deal with \*C` and \*C', which are used to add the
    # quotes around C<> text, since they may expand to " and if they do this
    # confuses the .SH macros and the like no end.  Expand them ourselves.
    # If $extra is set, we're dealing with =item, which in most nroff macro
    # sets requires an extra level of quoting of double quotes.
    my $c_is_quote = ($$self{LQUOTE} =~ /\"/) || ($$self{RQUOTE} =~ /\"/);
    if (/\"/ || ($c_is_quote && /\\\*\(C[\'\`]/)) {
        s/\"/\"\"/g;
        my $troff = $_;
        $troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;
        s/\\\*\(C\`/$$self{LQUOTE}/g;
        s/\\\*\(C\'/$$self{RQUOTE}/g;
        $troff =~ s/\\\*\(C[\'\`]//g;
        s/\"/\"\"/g if $extra;
        $troff =~ s/\"/\"\"/g if $extra;
        $_ = qq("$_") . ($extra ? " $extra" : '');
        $troff = qq("$troff") . ($extra ? " $extra" : '');
        return ".if n $command $_\n.el $command $troff\n";
    } else {
        $_ = qq("$_") . ($extra ? " $extra" : '');
        return "$command $_\n";
    }
}

a1098 12
=item quotes

Sets the quote marks used to surround CE<lt>> text.  If the value is a
single character, it is used as both the left and right quote; if it is two
characters, the first character is used as the left quote and the second as
the right quoted; and if it is four characters, the first two are used as
the left quote and the second two as the right quote.

This may also be set to the special value C<none>, in which case no quote
marks are added around CE<lt>> text (but the font is still changed for troff
output).

d1135 1
a1135 1
=item roff font should be 1 or 2 chars, not "%s"
a1147 10
=item Invalid quote specification "%s"

(F) The quote specification given (the quotes option to the constructor) was
invalid.  A quote specification must be one, two, or four characters long.

=item %s:%d: Unknown command paragraph "%s".

(W) The POD source contained a non-standard command paragraph (something of
the form C<=command args>) that Pod::Man didn't know about.  It was ignored.

a1156 5

=item %s: Unknown command paragraph "%s" on line %d.

(W) The POD source contained a non-standard command paragraph (something of
the form C<=command args>) that Pod::Man didn't know about. It was ignored.
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.34 2002/07/15 05:46:00 eagle Exp $
d4 1
a4 1
# Copyright 1999, 2000, 2001, 2002 by Russ Allbery <rra@@stanford.edu>
d6 1
a6 1
# This program is free software; you may redistribute it and/or modify it
d9 5
a13 5
# This module translates POD documentation into *roff markup using the man
# macro set, and is intended for converting POD documents written as Unix
# manual pages to manual pages that can be read by the man(1) command.  It is
# a replacement for the pod2man command distributed with versions of Perl
# prior to 5.6.
d20 1
a20 1
##############################################################################
d22 1
a22 1
##############################################################################
d26 1
a26 1
require 5.005;
a28 1
use Pod::ParseLink qw(parselink);
d37 5
a41 4
# Don't use the CVS revision as the version, since this module is also in Perl
# core and too many things could munge CVS magic revision strings.  This
# number should ideally be the same as the CVS revision in podlators, however.
$VERSION = 1.34;
d44 1
a44 1
##############################################################################
d46 1
a46 1
##############################################################################
d51 3
a53 2
# quotes to use for C<> text, designated by @@LQOUTE@@ and @@RQUOTE@@.  $PREAMBLE
# should therefore be run through s/\@@CFONT\@@/<font>/g before output.
d67 6
d80 1
d86 3
a88 3
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
d108 4
a111 4
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
d120 2
a121 2
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
d127 1
a196 1
    'apos'      =>    "'",      # apostrophe
a264 3

    'nbsp'      =>    '\\ ',    # non-breaking space
    'shy'       =>    '',       # soft (discretionary) hyphen
d268 1
a268 1
##############################################################################
d270 1
a270 1
##############################################################################
d272 4
a275 4
# Protect leading quotes and periods against interpretation as commands.  Also
# protect anything starting with a backslash, since it could expand or hide
# something that *roff would interpret as a command.  This is overkill, but
# it's much simpler than trying to parse *roff here.
d286 1
a286 1
##############################################################################
d288 1
a288 1
##############################################################################
d290 6
a295 6
# Initialize the object.  Here, we also process any additional options passed
# to the constructor or set up defaults if none were given.  center is the
# centered title, release is the version number, and date is the date for the
# documentation.  Note that we can't know what file name we're processing due
# to the architecture of Pod::Parser, so that *has* to either be passed to the
# constructor or set separately with Pod::Man::name().
d299 2
a300 2
    # Figure out the fixed-width font.  If user-supplied, make sure that they
    # are the right length.
d312 2
a313 2
    # Set the default fonts.  We can't be sure what fixed bold-italic is going
    # to be called, so default to just bold.
d319 2
a320 2
    # Set up a table of font escapes.  First number is fixed-width, second is
    # bold, third is italic.
d331 1
a331 1
    $$self{indent} = 4 unless defined $$self{indent};
d333 4
a336 4
    # We used to try first to get the version number from a local binary, but
    # we shouldn't need that any more.  Get the version from the running Perl.
    # Work a little magic to handle subversions correctly under both the
    # pre-5.6 and the post-5.6 version numbering schemes.
d364 3
a366 3
    # Double the first quote; note that this should not be s///g as two double
    # quotes is represented in *roff as three double quotes, not four.  Weird,
    # I know.
d370 5
d389 1
a389 1
        if ($section !~ /^3/) {
d393 13
a405 27
            # Assume that we're dealing with a module.  We want to figure out
            # the full module name from the path to the file, but we don't
            # want to include too much of the path into the module name.  Lose
            # everything up to the first of:
            #
            #     */lib/*perl*/         standard or site_perl module
            #     */*perl*/lib/         from -Dprefix=/opt/perl
            #     */*perl*/             random module hierarchy
            #
            # which works.  Also strip off a leading site or site_perl
            # component, any OS-specific component, and any version number
            # component, and strip off an initial component of "lib" or
            # "blib/lib" since that's what ExtUtils::MakeMaker creates.
            # splitdir requires at least File::Spec 0.8.
            require File::Spec;
            my ($volume, $dirs, $file) = File::Spec->splitpath ($name);
            my @@dirs = File::Spec->splitdir ($dirs);
            my $cut = 0;
            my $i;
            for ($i = 0; $i < scalar @@dirs; $i++) {
                if ($dirs[$i] eq 'lib' && $dirs[$i + 1] =~ /perl/) {
                    $cut = $i + 2;
                    last;
                } elsif ($dirs[$i] =~ /perl/) {
                    $cut = $i + 1;
                    $cut++ if $dirs[$i + 1] eq 'lib';
                    last;
d407 2
a409 12
            if ($cut > 0) {
                splice (@@dirs, 0, $cut);
                shift @@dirs if ($dirs[0] =~ /^site(_perl)?$/);
                shift @@dirs if ($dirs[0] =~ /^[\d.]+$/);
                shift @@dirs if ($dirs[0] =~ /^(.*-$^O|$^O-.*|$^O)$/);
            }
            shift @@dirs if $dirs[0] eq 'lib';
            splice (@@dirs, 0, 2) if ($dirs[0] eq 'blib' && $dirs[1] eq 'lib');

            # Remove empty directories when building the module name; they
            # occur too easily on Unix by doubling slashes.
            $name = join ('::', (grep { $_ ? $_ : () } @@dirs), $file);
d413 2
a414 2
    # If $name contains spaces, quote it; this mostly comes up in the case of
    # input from stdin.
d427 1
a427 9
    # Now, print out the preamble and the title.  The meaning of the arguments
    # to .TH unfortunately vary by system; some systems consider the fourth
    # argument to be a "source" and others use it as a version number.
    # Generally it's just presented as the left-side footer, though, so it
    # doesn't matter too much if a particular system gives it another
    # interpretation.
    #
    # The order of date and release used to be reversed in older versions of
    # this module, but this order is correct for both Solaris and Linux.
a432 1
    my $pversion = $Pod::Parser::VERSION;
d434 2
a435 1
.\\" Automatically generated by Pod::Man v$VERSION, Pod::Parser v$pversion
d438 1
a438 1
.\\" ========================================================================
d440 1
a440 1
.\\" ========================================================================
d443 2
a444 1
.TH $name $section "$$self{date}" "$$self{release}" "$$self{center}"
d446 1
d449 2
a450 7
    $$self{INDENT}    = 0;      # Current indentation level.
    $$self{INDENTS}   = [];     # Stack of indentations.
    $$self{INDEX}     = [];     # Index keys waiting to be printed.
    $$self{IN_NAME}   = 0;      # Whether processing the NAME section.
    $$self{ITEMS}     = 0;      # The number of consecutive =items.
    $$self{SHIFTWAIT} = 0;      # Whether there is a shift waiting.
    $$self{SHIFTS}    = [];     # Stack of .RS shifts.
d454 1
a454 1
##############################################################################
d456 1
a456 1
##############################################################################
d466 1
a466 1
    return if ($$self{EXCLUDE} && $command ne 'end');
d470 1
a470 1
    } else {
d481 4
a484 4
# Called for a verbatim paragraph.  Gets the paragraph, the line number, and a
# Pod::Paragraph object.  Rofficate backslashes, untabify, put a zero-width
# character at the beginning of each line to protect against commands, and
# wrap in .Vb/.Ve.
d497 1
a497 1
    $$self{NEEDSPACE} = 1;
d500 2
a501 2
# Called for a regular text block.  Gets the paragraph, the line number, and a
# Pod::Paragraph object.  Perform interpolation and output the results.
d507 3
a509 3
    # Parse the tree.  collapse knows about references to scalars as well as
    # scalars and does the right thing with them.  Tidy up any trailing
    # whitespace.
d511 34
a546 5

    # Output the paragraph.  We also have to handle =over without =item.  If
    # there's an =over without =item, NEWINDENT will be set, and we need to
    # handle creation of the indent here.  Set WEIRDINDENT so that it will be
    # cleaned up on =back.
a547 5
    if ($$self{SHIFTWAIT}) {
        $self->output (".RS $$self{INDENT}\n");
        push (@@{ $$self{SHIFTS} }, $$self{INDENT});
        $$self{SHIFTWAIT} = 0;
    }
d553 1
a553 1
# Called for a formatting code.  Takes a Pod::InteriorSequence object and
d555 2
a556 2
# It's returned as a reference to an array so that other formatting codes
# above us know that the text has already been processed.
d561 5
a565 7
    # We have to defer processing of the inside of an L<> formatting code.  If
    # this code is nested inside an L<> code, return the literal raw text of
    # it.
    my $parent = $seq->nested;
    while (defined $parent) {
        return $seq->raw_text if ($parent->cmd_name eq 'L');
        $parent = $parent->nested;
a567 3
    # Zero-width characters.
    return [ '\&' ] if ($command eq 'Z');

d571 2
a572 1
    local $_ = $self->collapse ($seq->parse_tree, $literal, $command eq 'C');
d574 1
a574 2
    # Handle E<> escapes.  Numeric escapes that match one of the supported ISO
    # 8859-1 characters don't work at present.
d577 1
a577 1
            return [ chr ($_) ];
d579 1
a579 1
            return [ $ESCAPES{$_} ];
d581 2
a582 3
            my ($file, $line) = $seq->file_line;
            warn "$file:$line: Unknown escape E<$_>\n";
            return [ "E<$_>" ];
d586 1
a586 1
    # For all the other codes, empty content produces no output.
d589 1
a589 1
    # Handle simple formatting codes.
d591 5
a595 3
        return [ '\f(BS' . $_ . '\f(BE' ];
    } elsif ($command eq 'F' || $command eq 'I') {
        return [ '\f(IS' . $_ . '\f(IE' ];
d597 2
a598 1
        return [ $self->quote_literal ($_) ];
d603 3
a605 6
        my ($text, $type) = (parselink ($_))[1,4];
        return '' unless $text;
        my ($file, $line) = $seq->file_line;
        $text = $self->parse ($text, $line);
        $text = '<' . $text . '>' if $type eq 'url';
        return [ $text ];
d611 1
a611 1
        return [ $_ ];
d615 1
a615 4
    if ($command eq 'X') {
        push (@@{ $$self{INDEX} }, $_);
        return '';
    }
d618 1
a618 2
    my ($file, $line) = $seq->file_line;
    warn "$file:$line: Unknown formatting code $command<$_>\n";
d622 1
a622 1
##############################################################################
d624 1
a624 1
##############################################################################
d630 2
a631 3
# already uses small caps, so remove \s1 and \s-1.  Maintain IN_NAME as
# appropriate, but don't leave it set while calling parse() so as to not
# override guesswork on section headings after NAME.
a633 1
    $$self{IN_NAME} = 0;
a644 1
    $$self{IN_NAME} = ($_ eq 'NAME');
d673 1
a673 1
    $self->output ($self->textmapfonts ('\f(IS' . $_ . '\f(IE') . "\n");
d700 1
a700 1
    if (@@{ $$self{SHIFTS} } < @@{ $$self{INDENTS} }) {
a701 1
        push (@@{ $$self{SHIFTS} }, $$self{INDENT});
a704 1
    $$self{SHIFTWAIT} = 1;
d714 1
a714 3
        my ($file, $line, $paragraph) = @@_;
        ($file, $line) = $paragraph->file_line;
        warn "$file:$line: Unmatched =back\n";
d717 1
a717 1
    if (@@{ $$self{SHIFTS} } > @@{ $$self{INDENTS} }) {
d719 1
a719 1
        pop @@{ $$self{SHIFTS} };
d724 1
a726 1
    $$self{SHIFTWAIT} = 0;
d731 4
a734 3
# numbers.  rofficate bullets too while we're at it (so for nice output, use *
# for your lists rather than o or . or - or some other thing).  Newlines in an
# item title are turned into spaces since *roff can't handle them embedded.
a744 1
    $_ = '*' unless $_;
d746 1
a746 1
    if (@@{ $$self{SHIFTS} } == @@{ $$self{INDENTS} }) {
d748 1
a748 1
        pop @@{ $$self{SHIFTS} };
d752 1
a752 1
    $self->output ($self->switchquotes ('.IP', $_, $$self{INDENT}));
a755 1
    $$self{SHIFTWAIT} = 0;
d789 68
a856 1
##############################################################################
d858 1
a858 1
##############################################################################
d861 6
a866 6
# where <font> is one of B, I, or F.  Turn those into the right font start or
# end codes.  The old pod2man didn't get B<someI<thing> else> right; after I<>
# it switched back to normal text rather than bold.  We take care of this by
# using variables as a combined pointer to our current font sequence, and set
# each to the number of current nestings of start tags for that font.  Use
# them as a vector to look up what font sequence to use.
d870 3
a872 3
# inside a heading it could be something else.  So arrange things so that the
# outside font is always the "previous" font and end with \fP instead of \fR.
# Idea from Zack Weinberg.
d899 3
a901 3
# than R, presumably because \f(CW doesn't actually do a font change.  To work
# around this, use a separate textmapfonts for text blocks where the default
# font is always R and only use the smart mapfonts for headings.
d916 3
a918 3
##############################################################################
# *roff-specific parsing and magic
##############################################################################
d927 8
a934 8
# Takes a parse tree, a flag saying whether or not to treat it as literal text
# (not call guesswork on it), and a flag saying whether or not to clean some
# things up for *roff, and returns the concatenation of all of the text
# strings in that parse tree.  If the literal flag isn't true, guesswork()
# will be called on all plain scalars in the parse tree.  Otherwise, if
# collapse is being called on a C<> code, $cleanup should be set to true and
# some additional cleanup will be done.  Assumes that everything in the parse
# tree is either a scalar or a reference to a scalar.
d936 6
a941 18
    my ($self, $ptree, $literal, $cleanup) = @@_;

    # If we're processing the NAME section, don't do normal guesswork.  This
    # is because NAME lines are often extracted by utilities like catman that
    # require plain text and don't understand *roff markup.  We still need to
    # escape backslashes and hyphens for *roff (and catman expects \- instead
    # of -).
    if ($$self{IN_NAME}) {
        $literal = 1;
        $cleanup = 1;
    }

    # Do the collapse of the parse tree as described above.
    return join ('', map {
        if (ref $_) {
            join ('', @@$_);
        } elsif ($literal) {
            if ($cleanup) {
d943 3
a945 2
                s/-/\\-/g;
                s/__/_\\|_/g;
d947 6
a952 5
            $_;
        } else {
            $self->guesswork ($_);
        }
    } $ptree->children);
d956 2
a957 1
# contain any formatting codes.  Returns the text block with remapping done.
d968 2
a969 23
    # Leave hyphens only if they're part of regular words and there is only
    # one dash at a time.  Leave a dash after the first character as a regular
    # non-breaking dash, but don't let it mark the rest of the word invalid
    # for hyphenation.
    s/-/\\-/g;
    s{
      ( (?:\G|^|\s) [a-zA-Z] ) ( \\- )?
      ( (?: [a-zA-Z]+ \\-)+ )
      ( [a-zA-Z]+ ) (?=\s|\Z)
      \b
     } {
         my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
         $hyphen ||= '';
         $main =~ s/\\-/-/g;
         $prefix . $hyphen . $main . $suffix;
    }egx;

    # Translate -- into a real em dash if it's used like one.
    s{ (\s) \\-\\- (\s) }                         { $1 . '\*(--' . $2 }egx;
    s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx;

    # Make all caps a little smaller.  Be careful here, since we don't want to
    # make @@ARGV into small caps, nor do we want to fix the MIME in
d973 2
a974 2
        ( [A-Z] [A-Z] (?: [/A-Z+:\d_\$&] | \\- )* )
        (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | $ )
d977 3
d982 1
a982 1
        ( \b | \\s-1 )
d984 1
a984 1
            [A-Za-z_] ([:\w]|\\s-?[01])+ \(\)
d986 1
a986 1
    } { $1 . '\f(IS' . $2 . '\f(IE' }egx;
d990 2
a991 2
        ( \b | \\s-1 )
        ( [A-Za-z_] (?:[.:\w]|\\-|\\s-?[01])+ )
d993 1
a993 1
            \( \d [a-z]* \)
d995 1
a995 1
    } { $1 . '\f(IS' . $2 . '\f(IE\|' . $3 }egx;
d1004 18
a1031 32
# Handles C<> text, deciding whether to put \*C` around it or not.  This is a
# whole bunch of messy heuristics to try to avoid overquoting, originally from
# Barrie Slaymaker.  This largely duplicates similar code in Pod::Text.
sub quote_literal {
    my $self = shift;
    local $_ = shift;

    # A regex that matches the portion of a variable reference that's the
    # array or hash index, separated out just because we want to use it in
    # several places in the following regex.
    my $index = '(?: \[.*\] | \{.*\} )?';

    # Check for things that we don't want to quote, and if we find any of
    # them, return the string with just a font change and no quoting.
    m{
      ^\s*
      (?:
         ( [\'\`\"] ) .* \1                             # already quoted
       | \` .* \'                                       # `quoted'
       | \$+ [\#^]? \S $index                           # special ($^Foo, $")
       | [\$\@@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
       | [\$\@@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
       | [+-]? ( \d[\d.]* | \.\d+ ) (?: [eE][+-]?\d+ )? # a number
       | 0x [a-fA-F\d]+                                 # a hex constant
      )
      \s*\z
     }xo && return '\f(FS' . $_ . '\f(FE';

    # If we didn't return, go ahead and quote the text.
    return '\f(FS\*(C`' . $_ . "\\*(C'\\f(FE";
}

d1033 1
a1033 1
##############################################################################
d1035 1
a1035 1
##############################################################################
d1046 3
a1048 3
# Output any pending index entries, and optionally an index entry given as an
# argument.  Support multiple index entries in X<> separated by slashes, and
# strip special escapes from index entries.
d1054 1
a1054 1
    my @@output;
d1056 3
a1058 1
        push (@@output, [ 'Xref', join (' ', @@entries) ]);
d1061 1
d1064 1
a1064 6
        push (@@output, [ $section, $index ]);
    }
    for (@@output) {
        my ($type, $entry) = @@$_;
        $entry =~ s/\"/\"\"/g;
        $self->output (".IX $type " . '"' . $entry . '"' . "\n");
d1066 1
d1089 2
a1090 2
    # Also separate troff from nroff if there are any fixed-width fonts in use
    # to work around problems with Solaris nroff.
d1092 1
a1092 4
    my $fixedpat = join ('|', @@{ $$self{FONTS} }{'100', '101', '110', '111'});
    $fixedpat =~ s/\\/\\\\/g;
    $fixedpat =~ s/\(/\\\(/g;
    if (/\"/ || /$fixedpat/) {
a1093 1
        my $nroff = $_;
d1096 6
a1101 6
        if ($c_is_quote && /\\\*\(C[\'\`]/) {
            $nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;
            $nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;
            $troff =~ s/\\\*\(C[\'\`]//g;
        }
        $nroff = qq("$nroff") . ($extra ? " $extra" : '');
d1103 1
a1103 17

        # Work around the Solaris nroff bug where \f(CW\fP leaves the font set
        # to Roman rather than the actual previous font when used in headings.
        # troff output may still be broken, but at least we can fix nroff by
        # just switching the font changes to the non-fixed versions.
        $nroff =~ s/\Q$$self{FONTS}{100}\E(.*)\\f[PR]/$1/g;
        $nroff =~ s/\Q$$self{FONTS}{101}\E(.*)\\f([PR])/\\fI$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{110}\E(.*)\\f([PR])/\\fB$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{111}\E(.*)\\f([PR])/\\f\(BI$1\\f$2/g;

        # Now finally output the command.  Only bother with .ie if the nroff
        # and troff output isn't the same.
        if ($nroff ne $troff) {
            return ".ie n $command $nroff\n.el $command $troff\n";
        } else {
            return "$command $nroff\n";
        }
d1112 31
a1142 1
##############################################################################
d1144 1
a1144 1
##############################################################################
d1166 3
a1168 3
using L<nroff(1)>, normally via L<man(1)>, or printing using L<troff(1)>.
It is conventionally invoked using the driver script B<pod2man>, but it can
also be used directly.
d1172 1
a1172 1
new parser with C<< Pod::Man->new() >> and then calls either
d1193 1
a1193 1
func(), func(3), and simple variable references like $foo or @@bar so you
d1197 4
a1200 4
this--into proper em dashes, fixes "paired quotes," makes C++ look right,
puts a little space between double underbars, makes ALLCAPS a teeny bit
smaller in B<troff>, and escapes stuff that *roff treats as special so that
you don't have to.
d1222 1
a1222 1
Some systems may want CR instead.  Only matters for B<troff> output.
d1227 1
a1227 1
B<troff> output.
d1233 1
a1233 1
version).  Defaults to CI.  Only matters for B<troff> output.
d1239 1
a1239 1
(such as Solaris) have this font available as CX.  Only matters for B<troff>
a1241 9
=item name

Set the name of the manual page.  Without this option, the manual name is
set to the uppercased base name of the file being converted unless the
manual section is 3, in which case the path is parsed to see if it is a Perl
module path.  If it is, a path like C<.../lib/Pod/Man.pm> is converted into
a name like C<Pod::Man>.  This option, if given, overrides any automatic
determination of the name.

d1295 1
a1295 1
versions of B<nroff> and B<troff> don't either).
d1299 3
a1301 3
(W) The POD source contained a C<LE<lt>E<gt>> formatting code that
Pod::Man was unable to parse.  You should never see this error message; it
probably indicates a bug in Pod::Man.
d1313 1
a1313 1
=item %s:%d: Unknown escape EE<lt>%sE<gt>
d1318 1
a1318 1
=item %s:%d: Unknown formatting code %s
d1320 1
a1320 1
(W) The POD source contained a non-standard formatting code (something of
d1323 6
a1328 1
=item %s:%d: Unmatched =back
d1337 3
a1339 12
Eight-bit input data isn't handled at all well at present.  The correct
approach would be to map EE<lt>E<gt> escapes to the appropriate UTF-8
characters and then do a translation pass on the output according to the
user-specified output character set.  Unfortunately, we can't send eight-bit
data directly to the output unless the user says this is okay, since some
vendor *roff implementations can't handle eight-bit data.  If the *roff
implementation can, however, that's far superior to the current hacked
characters that only work under troff.

There is currently no way to turn off the guesswork that tries to format
unmarked text appropriately, and sometimes it isn't wanted (particularly
when using POD to document something other than Perl).
d1346 7
d1354 1
a1354 1
most B<troff> implementations, but GNU troff does as an extension.  It would
d1362 3
a1366 9
=head1 CAVEATS

The handling of hyphens and em dashes is somewhat fragile, and one may get
the wrong one under some circumstances.  This should only matter for
B<troff> output.

When and whether to use small caps is somewhat tricky, and Pod::Man doesn't
necessarily get it right.

d1369 2
a1370 2
L<Pod::Parser>, L<perlpod(1)>, L<pod2man(1)>, L<nroff(1)>, L<troff(1)>,
L<man(1)>, L<man(7)>
d1374 7
a1380 12
the best documentation of standard B<nroff> and B<troff>.  At the time of
this writing, it's available at
L<http://www.cs.bell-labs.com/cm/cs/cstr.html>.

The man page documenting the man macro set may be L<man(5)> instead of
L<man(7)> on your system.  Also, please see L<pod2man(1)> for extensive
documentation on writing manual pages if you've not done it before and
aren't familiar with the conventions.

The current version of this module is always available from its web site at
L<http://www.eyrie.org/~eagle/software/podlators/>.  It is also part of the
Perl core distribution as of 5.6.0.
d1384 2
a1385 9
Russ Allbery <rra@@stanford.edu>, based I<very> heavily on the original
B<pod2man> by Tom Christiansen <tchrist@@mox.perl.com>.

=head1 COPYRIGHT AND LICENSE

Copyright 1999, 2000, 2001, 2002 by Russ Allbery <rra@@stanford.edu>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.37 2003/03/30 22:34:11 eagle Exp $
d4 1
a4 1
# Copyright 1999, 2000, 2001, 2002, 2003 by Russ Allbery <rra@@stanford.edu>
d41 1
a41 1
$VERSION = 1.37;
a473 1
    $$self{ITEMTYPES} = [];     # Stack of =item types, one per list.
d540 3
a542 3
    # there's an =over without =item, SHIFTWAIT will be set, and we need to
    # handle creation of the indent here.  Add the shift to SHIFTS so that it
    # will be cleaned up on =back.
a718 1
    push (@@{ $$self{ITEMTYPES} }, 'unknown');
d729 1
a729 3
    if (defined $$self{INDENT}) {
        pop @@{ $$self{ITEMTYPES} };
    } else {
d762 2
a763 12
    $_ = '*' unless length ($_) > 0;
    my $type = $$self{ITEMTYPES}[0];
    unless (defined $type) {
        my ($file, $line, $paragraph) = @@_;
        ($file, $line) = $paragraph->file_line;
        $type = 'unknown';
    }
    if ($type eq 'unknown') {
        $type = /^\*\s*\Z/ ? 'bullet' : 'text';
        $$self{ITEMTYPES}[0] = $type if $$self{ITEMTYPES}[0];
    }
    s/^\*\s*\Z/\\\(bu/ if $type eq 'bullet';
d1124 2
d1127 1
a1127 1
# Module return value and documentation
a1129 3
1;
__END__

d1390 1
a1390 1
Copyright 1999, 2000, 2001, 2002, 2003 by Russ Allbery <rra@@stanford.edu>.
@


1.1.1.5
log
@Import of stock perl 5.8.5
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.8 2003/12/03 03:02:40 millert Exp $
@


1.1.1.6
log
@perl 5.8.6 from CPAN
@
text
@d2 1
a2 1
# $Id: Man.pm,v 1.37 2003/03/30 22:34:11 eagle Exp $
@


1.1.1.7
log
@import perl 5.10.0 from CPAN
@
text
@d2 1
a2 1
# $Id: Man.pm,v 2.16 2007-11-29 01:35:53 eagle Exp $
d4 1
a4 3
# Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
#     Russ Allbery <rra@@stanford.edu>
# Substantial contributions by Sean Burke <sburke@@cpan.org>
d28 4
d36 1
a36 5
use Carp qw(croak);
use Pod::Simple ();
use POSIX qw(strftime);

@@ISA = qw(Pod::Simple);
d41 1
a41 16
$VERSION = '2.16';

# Set the debugging level.  If someone has inserted a debug function into this
# class already, use that.  Otherwise, use any Pod::Simple debug function
# that's defined, and failing that, define a debug level of 10.
BEGIN {
    my $parent = defined (&Pod::Simple::DEBUG) ? \&Pod::Simple::DEBUG : undef;
    unless (defined &DEBUG) {
        *DEBUG = $parent || sub () { 10 };
    }
}

# Import the ASCII constant from Pod::Simple.  This is true iff we're in an
# ASCII-based universe (including such things as ISO 8859-1 and UTF-8), and is
# generally only false for EBCDIC.
BEGIN { *ASCII = \&Pod::Simple::ASCII }
a42 2
# Pretty-print a data structure.  Only used for debugging.
BEGIN { *pretty = \&Pod::Simple::pretty }
d45 1
a45 1
# Object initialization
d48 213
a260 18
# Initialize the object and set various Pod::Simple options that we need.
# Here, we also process any additional options passed to the constructor or
# set up defaults if none were given.  Note that all internal object keys are
# in all-caps, reserving all lower-case object keys for Pod::Simple and user
# arguments.
sub new {
    my $class = shift;
    my $self = $class->SUPER::new;

    # Tell Pod::Simple to handle S<> by automatically inserting &nbsp;.
    $self->nbsp_for_S (1);

    # Tell Pod::Simple to keep whitespace whenever possible.
    if ($self->can ('preserve_whitespace')) {
        $self->preserve_whitespace (1);
    } else {
        $self->fullstop_space_harden (1);
    }
a261 2
    # The =for and =begin targets that we accept.
    $self->accept_targets (qw/man MAN roff ROFF/);
d263 3
a265 22
    # Ensure that contiguous blocks of code are merged together.  Otherwise,
    # some of the guesswork heuristics don't work right.
    $self->merge_text (1);

    # Pod::Simple doesn't do anything useful with our arguments, but we want
    # to put them in our object as hash keys and values.  This could cause
    # problems if we ever clash with Pod::Simple's own internal class
    # variables.
    %$self = (%$self, @@_);

    # Initialize various other internal constants based on our arguments.
    $self->init_fonts;
    $self->init_quotes;
    $self->init_page;

    # For right now, default to turning on all of the magic.
    $$self{MAGIC_CPP}       = 1;
    $$self{MAGIC_EMDASH}    = 1;
    $$self{MAGIC_FUNC}      = 1;
    $$self{MAGIC_MANREF}    = 1;
    $$self{MAGIC_SMALLCAPS} = 1;
    $$self{MAGIC_VARS}      = 1;
d267 8
a274 1
    return $self;
d280 13
a292 6
# Determine which fonts the user wishes to use and store them in the object.
# Regular, italic, bold, and bold-italic are constants, but the fixed width
# fonts may be set by the user.  Sets the internal hash key FONTS which is
# used to map our internal font escapes to actual *roff sequences later.
sub init_fonts {
    my ($self) = @@_;
d297 7
a303 3
        my $font = $$self{$_};
        if (defined ($font) && (length ($font) < 1 || length ($font) > 2)) {
            croak qq(roff font should be 1 or 2 chars, not "$font");
d307 2
a308 3
    # Set the default fonts.  We can't be sure portably across different
    # implementations what fixed bold-italic may be called (if it's even
    # available), so default to just bold.
d321 18
a338 2
                      '111' => toescape ($$self{fixedbolditalic}) };
}
d340 4
a343 6
# Initialize the quotes that we'll be using for C<> text.  This requires some
# special handling, both to parse the user parameter if given and to make sure
# that the quotes will be safe against *roff.  Sets the internal hash keys
# LQUOTE and RQUOTE.
sub init_quotes {
    my ($self) = (@@_);
d345 1
d356 1
a356 1
        croak(qq(Invalid quote specification "$$self{quotes}"))
d364 2
d368 52
a419 3
# Initialize the page title information and indentation from our arguments.
sub init_page {
    my ($self) = @@_;
d421 5
a425 9
    # We used to try first to get the version number from a local binary, but
    # we shouldn't need that any more.  Get the version from the running Perl.
    # Work a little magic to handle subversions correctly under both the
    # pre-5.6 and the post-5.6 version numbering schemes.
    my @@version = ($] =~ /^(\d+)\.(\d{3})(\d{0,3})$/);
    $version[2] ||= 0;
    $version[2] *= 10 ** (3 - length $version[2]);
    for (@@version) { $_ += 0 }
    my $version = join ('.', @@version);
d427 40
a466 8
    # Set the defaults for page titles and indentation if the user didn't
    # override anything.
    $$self{center} = 'User Contributed Perl Documentation'
        unless defined $$self{center};
    $$self{release} = 'perl v' . $version
        unless defined $$self{release};
    $$self{indent} = 4
        unless defined $$self{indent};
d468 9
a476 4
    # Double quotes in things that will be quoted.
    for (qw/center release/) {
        $$self{$_} =~ s/\"/\"\"/g if $$self{$_};
    }
d479 1
d481 1
a481 1
# Core parsing
d484 12
a495 60
# This is the glue that connects the code below with Pod::Simple itself.  The
# goal is to convert the event stream coming from the POD parser into method
# calls to handlers once the complete content of a tag has been seen.  Each
# paragraph or POD command will have textual content associated with it, and
# as soon as all of a paragraph or POD command has been seen, that content
# will be passed in to the corresponding method for handling that type of
# object.  The exceptions are handlers for lists, which have opening tag
# handlers and closing tag handlers that will be called right away.
#
# The internal hash key PENDING is used to store the contents of a tag until
# all of it has been seen.  It holds a stack of open tags, each one
# represented by a tuple of the attributes hash for the tag, formatting
# options for the tag (which are inherited), and the contents of the tag.

# Add a block of text to the contents of the current node, formatting it
# according to the current formatting instructions as we do.
sub _handle_text {
    my ($self, $text) = @@_;
    DEBUG > 3 and print "== $text\n";
    my $tag = $$self{PENDING}[-1];
    $$tag[2] .= $self->format_text ($$tag[1], $text);
}

# Given an element name, get the corresponding method name.
sub method_for_element {
    my ($self, $element) = @@_;
    $element =~ tr/-/_/;
    $element =~ tr/A-Z/a-z/;
    $element =~ tr/_a-z0-9//cd;
    return $element;
}

# Handle the start of a new element.  If cmd_element is defined, assume that
# we need to collect the entire tree for this element before passing it to the
# element method, and create a new tree into which we'll collect blocks of
# text and nested elements.  Otherwise, if start_element is defined, call it.
sub _handle_element_start {
    my ($self, $element, $attrs) = @@_;
    DEBUG > 3 and print "++ $element (<", join ('> <', %$attrs), ">)\n";
    my $method = $self->method_for_element ($element);

    # If we have a command handler, we need to accumulate the contents of the
    # tag before calling it.  Turn off IN_NAME for any command other than
    # <Para> so that IN_NAME isn't still set for the first heading after the
    # NAME heading.
    if ($self->can ("cmd_$method")) {
        DEBUG > 2 and print "<$element> starts saving a tag\n";
        $$self{IN_NAME} = 0 if ($element ne 'Para');

        # How we're going to format embedded text blocks depends on the tag
        # and also depends on our parent tags.  Thankfully, inside tags that
        # turn off guesswork and reformatting, nothing else can turn it back
        # on, so this can be strictly inherited.
        my $formatting = $$self{PENDING}[-1][1];
        $formatting = $self->formatting ($formatting, $element);
        push (@@{ $$self{PENDING} }, [ $attrs, $formatting, '' ]);
        DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
    } elsif ($self->can ("start_$method")) {
        my $method = 'start_' . $method;
        $self->$method ($attrs, '');
d497 7
a503 1
        DEBUG > 2 and print "No $method start method, skipping\n";
d507 17
a523 30
# Handle the end of an element.  If we had a cmd_ method for this element,
# this is where we pass along the tree that we built.  Otherwise, if we have
# an end_ method for the element, call that.
sub _handle_element_end {
    my ($self, $element) = @@_;
    DEBUG > 3 and print "-- $element\n";
    my $method = $self->method_for_element ($element);

    # If we have a command handler, pull off the pending text and pass it to
    # the handler along with the saved attribute hash.
    if ($self->can ("cmd_$method")) {
        DEBUG > 2 and print "</$element> stops saving a tag\n";
        my $tag = pop @@{ $$self{PENDING} };
        DEBUG > 4 and print "Popped: [", pretty ($tag), "]\n";
        DEBUG > 4 and print "Pending: [", pretty ($$self{PENDING}), "]\n";
        my $method = 'cmd_' . $method;
        my $text = $self->$method ($$tag[0], $$tag[2]);
        if (defined $text) {
            if (@@{ $$self{PENDING} } > 1) {
                $$self{PENDING}[-1][2] .= $text;
            } else {
                $self->output ($text);
            }
        }
    } elsif ($self->can ("end_$method")) {
        my $method = 'end_' . $method;
        $self->$method ();
    } else {
        DEBUG > 2 and print "No $method end method, skipping\n";
    }
d526 13
a538 3
##############################################################################
# General formatting
##############################################################################
d540 9
a548 13
# Return formatting instructions for a new block.  Takes the current
# formatting and the new element.  Formatting inherits negatively, in the
# sense that if the parent has turned off guesswork, all child elements should
# leave it off.  We therefore return a copy of the same formatting
# instructions but possibly with more things turned off depending on the
# element.
sub formatting {
    my ($self, $current, $element) = @@_;
    my %options;
    if ($current) {
        %options = %$current;
    } else {
        %options = (guesswork => 1, cleanup => 1, convert => 1);
d550 37
a586 29
    if ($element eq 'Data') {
        $options{guesswork} = 0;
        $options{cleanup} = 0;
        $options{convert} = 0;
    } elsif ($element eq 'X') {
        $options{guesswork} = 0;
        $options{cleanup} = 0;
    } elsif ($element eq 'Verbatim' || $element eq 'C') {
        $options{guesswork} = 0;
        $options{literal} = 1;
    }
    return \%options;
}

# Format a text block.  Takes a hash of formatting options and the text to
# format.  Currently, the only formatting options are guesswork, cleanup, and
# convert, all of which are boolean.
sub format_text {
    my ($self, $options, $text) = @@_;
    my $guesswork = $$options{guesswork} && !$$self{IN_NAME};
    my $cleanup = $$options{cleanup};
    my $convert = $$options{convert};
    my $literal = $$options{literal};

    # Normally we do character translation, but we won't even do that in
    # <Data> blocks.
    if ($convert) {
        if (ASCII) {
            $text =~ s/(\\|[^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg;
d588 3
a590 1
            $text =~ s/(\\)/$ESCAPES{ord ($1)} || "X"/eg;
d594 20
a613 5
    # Cleanup just tidies up a few things, telling *roff that the hyphens are
    # hard and putting a bit of space between consecutive underscores.
    if ($cleanup) {
        $text =~ s/-/\\-/g;
        $text =~ s/_(?=_)/_\\|/g;
d616 4
a619 5
    # Ensure that *roff doesn't convert literal quotes to UTF-8 single quotes,
    # but don't mess up our accept escapes.
    if ($literal) {
        $text =~ s/(?<!\\\*)\'/\\*\(Aq/g;
        $text =~ s/(?<!\\\*)\`/\\\`/g;
d622 4
a625 5
    # If guesswork is asked for, do that.  This involves more substantial
    # formatting based on various heuristics that may only be appropriate for
    # particular documents.
    if ($guesswork) {
        $text = $self->guesswork ($text);
d628 3
a630 1
    return $text;
a632 11
# Handles C<> text, deciding whether to put \*C` around it or not.  This is a
# whole bunch of messy heuristics to try to avoid overquoting, originally from
# Barrie Slaymaker.  This largely duplicates similar code in Pod::Text.
sub quote_literal {
    my $self = shift;
    local $_ = shift;

    # A regex that matches the portion of a variable reference that's the
    # array or hash index, separated out just because we want to use it in
    # several places in the following regex.
    my $index = '(?: \[.*\] | \{.*\} )?';
d634 3
a636 16
    # Check for things that we don't want to quote, and if we find any of
    # them, return the string with just a font change and no quoting.
    m{
      ^\s*
      (?:
         ( [\'\`\"] ) .* \1                             # already quoted
       | \\\*\(Aq .* \\\*\(Aq                           # quoted and escaped
       | \\?\` .* ( \' | \\\*\(Aq )                     # `quoted'
       | \$+ [\#^]? \S $index                           # special ($^Foo, $")
       | [\$\@@%&*]+ \#? [:\'\w]+ $index                 # plain var or func
       | [\$\@@%&*]* [:\'\w]+ (?: -> )? \(\s*[^\s,]\s*\) # 0/1-arg func call
       | [-+]? ( \d[\d.]* | \.\d+ ) (?: [eE][-+]?\d+ )? # a number
       | 0x [a-fA-F\d]+                                 # a hex constant
      )
      \s*\z
     }xso and return '\f(FS' . $_ . '\f(FE';
d638 1
a638 3
    # If we didn't return, go ahead and quote the text.
    return '\f(FS\*(C`' . $_ . "\\*(C'\\f(FE";
}
d640 72
a711 12
# Takes a text block to perform guesswork on.  Returns the text block with
# formatting codes added.  This is the code that marks up various Perl
# constructs and things commonly used in man pages without requiring the user
# to add any explicit markup, and is applied to all non-literal text.  We're
# guaranteed that the text we're applying guesswork to does not contain any
# *roff formatting codes.  Note that the inserted font sequences must be
# treated later with mapfonts or textmapfonts.
#
# This method is very fragile, both in the regular expressions it uses and in
# the ordering of those modifications.  Care and testing is required when
# modifying it.
sub guesswork {
d714 10
a723 1
    DEBUG > 5 and print "   Guesswork called on [$_]\n";
d725 25
a749 19
    # By the time we reach this point, all hypens will be escaped by adding a
    # backslash.  We want to undo that escaping if they're part of regular
    # words and there's only a single dash, since that's a real hyphen that
    # *roff gets to consider a possible break point.  Make sure that a dash
    # after the first character of a word stays non-breaking, however.
    #
    # Note that this is not user-controllable; we pretty much have to do this
    # transformation or *roff will mangle the output in unacceptable ways.
    s{
        ( (?:\G|^|\s) [\(\"]* [a-zA-Z] ) ( \\- )?
        ( (?: [a-zA-Z\']+ \\-)+ )
        ( [a-zA-Z\']+ ) (?= [\)\".?!,;:]* (?:\s|\Z|\\\ ) )
        \b
    } {
        my ($prefix, $hyphen, $main, $suffix) = ($1, $2, $3, $4);
        $hyphen ||= '';
        $main =~ s/\\-/-/g;
        $prefix . $hyphen . $main . $suffix;
    }egx;
d751 30
a780 6
    # Translate "--" into a real em-dash if it's used like one.  This means
    # that it's either surrounded by whitespace, it follows a regular word, or
    # it occurs between two regular words.
    if ($$self{MAGIC_EMDASH}) {
        s{          (\s) \\-\\- (\s)                } { $1 . '\*(--' . $2 }egx;
        s{ (\b[a-zA-Z]+) \\-\\- (\s|\Z|[a-zA-Z]+\b) } { $1 . '\*(--' . $2 }egx;
d782 8
d791 12
a802 71
    # Make words in all-caps a little bit smaller; they look better that way.
    # However, we don't want to change Perl code (like @@ARGV), nor do we want
    # to fix the MIME in MIME-Version since it looks weird with the
    # full-height V.
    #
    # We change only a string of all caps (2) either at the beginning of the
    # line or following regular punctuation (like quotes) or whitespace (1),
    # and followed by either similar punctuation, an em-dash, or the end of
    # the line (3).
    if ($$self{MAGIC_SMALLCAPS}) {
        s{
            ( ^ | [\s\(\"\'\`\[\{<>] | \\\  )                   # (1)
            ( [A-Z] [A-Z] (?: [/A-Z+:\d_\$&] | \\- )* )         # (2)
            (?= [\s>\}\]\(\)\'\".?!,;] | \\*\(-- | \\\  | $ )   # (3)
        } {
            $1 . '\s-1' . $2 . '\s0'
        }egx;
    }

    # Note that from this point forward, we have to adjust for \s-1 and \s-0
    # strings inserted around things that we've made small-caps if later
    # transforms should work on those strings.

    # Italize functions in the form func(), including functions that are in
    # all capitals, but don't italize if there's anything between the parens.
    # The function must start with an alphabetic character or underscore and
    # then consist of word characters or colons.
    if ($$self{MAGIC_FUNC}) {
        s{
            ( \b | \\s-1 )
            ( [A-Za-z_] ([:\w] | \\s-?[01])+ \(\) )
        } {
            $1 . '\f(IS' . $2 . '\f(IE'
        }egx;
    }

    # Change references to manual pages to put the page name in italics but
    # the number in the regular font, with a thin space between the name and
    # the number.  Only recognize func(n) where func starts with an alphabetic
    # character or underscore and contains only word characters, periods (for
    # configuration file man pages), or colons, and n is a single digit,
    # optionally followed by some number of lowercase letters.  Note that this
    # does not recognize man page references like perl(l) or socket(3SOCKET).
    if ($$self{MAGIC_MANREF}) {
        s{
            ( \b | \\s-1 )
            ( [A-Za-z_] (?:[.:\w] | \\- | \\s-?[01])+ )
            ( \( \d [a-z]* \) )
        } {
            $1 . '\f(IS' . $2 . '\f(IE\|' . $3
        }egx;
    }

    # Convert simple Perl variable references to a fixed-width font.  Be
    # careful not to convert functions, though; there are too many subtleties
    # with them to want to perform this transformation.
    if ($$self{MAGIC_VARS}) {
        s{
           ( ^ | \s+ )
           ( [\$\@@%] [\w:]+ )
           (?! \( )
        } {
            $1 . '\f(FS' . $2 . '\f(FE'
        }egx;
    }

    # Fix up double quotes.  Unfortunately, we miss this transformation if the
    # quoted text contains any code with formatting codes and there's not much
    # we can effectively do about that, which makes it somewhat unclear if
    # this is really a good idea.
    s{ \" ([^\"]+) \" } { '\*(L"' . $1 . '\*(R"' }egx;
d804 7
a810 4
    # Make C++ into \*(C+, which is a squinched version.
    if ($$self{MAGIC_CPP}) {
        s{ \b C\+\+ } {\\*\(C+}gx;
    }
d812 7
a818 3
    # Done.
    DEBUG > 5 and print "   Guesswork returning [$_]\n";
    return $_;
d821 1
d823 1
a823 1
# Output
d826 7
a832 11
# When building up the *roff code, we don't use real *roff fonts.  Instead, we
# embed font codes of the form \f(<font>[SE] where <font> is one of B, I, or
# F, S stands for start, and E stands for end.  This method turns these into
# the right start and end codes.
#
# We add this level of complexity because the old pod2man didn't get code like
# B<someI<thing> else> right; after I<> it switched back to normal text rather
# than bold.  We take care of this by using variables that state whether bold,
# italic, or fixed are turned on as a combined pointer to our current font
# sequence, and set each to the number of current nestings of start tags for
# that font.
d840 3
a842 1
    my ($self, $text) = @@_;
d846 1
a846 3
    $text =~ s<
        \\f\((.)(.)
    > <
d851 1
a851 1
        $f = $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
d859 2
a860 2
    >gxe;
    return $text;
d869 3
a871 1
    my ($self, $text) = @@_;
d874 1
a874 3
    $text =~ s<
        \\f\((.)(.)
    > <
d876 3
a878 113
        $$self{FONTS}{ ($fixed && 1) . ($bold && 1) . ($italic && 1) };
    >gxe;
    return $text;
}

# Given a command and a single argument that may or may not contain double
# quotes, handle double-quote formatting for it.  If there are no double
# quotes, just return the command followed by the argument in double quotes.
# If there are double quotes, use an if statement to test for nroff, and for
# nroff output the command followed by the argument in double quotes with
# embedded double quotes doubled.  For other formatters, remap paired double
# quotes to LQUOTE and RQUOTE.
sub switchquotes {
    my ($self, $command, $text, $extra) = @@_;
    $text =~ s/\\\*\([LR]\"/\"/g;

    # We also have to deal with \*C` and \*C', which are used to add the
    # quotes around C<> text, since they may expand to " and if they do this
    # confuses the .SH macros and the like no end.  Expand them ourselves.
    # Also separate troff from nroff if there are any fixed-width fonts in use
    # to work around problems with Solaris nroff.
    my $c_is_quote = ($$self{LQUOTE} =~ /\"/) || ($$self{RQUOTE} =~ /\"/);
    my $fixedpat = join '|', @@{ $$self{FONTS} }{'100', '101', '110', '111'};
    $fixedpat =~ s/\\/\\\\/g;
    $fixedpat =~ s/\(/\\\(/g;
    if ($text =~ m/\"/ || $text =~ m/$fixedpat/) {
        $text =~ s/\"/\"\"/g;
        my $nroff = $text;
        my $troff = $text;
        $troff =~ s/\"\"([^\"]*)\"\"/\`\`$1\'\'/g;
        if ($c_is_quote and $text =~ m/\\\*\(C[\'\`]/) {
            $nroff =~ s/\\\*\(C\`/$$self{LQUOTE}/g;
            $nroff =~ s/\\\*\(C\'/$$self{RQUOTE}/g;
            $troff =~ s/\\\*\(C[\'\`]//g;
        }
        $nroff = qq("$nroff") . ($extra ? " $extra" : '');
        $troff = qq("$troff") . ($extra ? " $extra" : '');

        # Work around the Solaris nroff bug where \f(CW\fP leaves the font set
        # to Roman rather than the actual previous font when used in headings.
        # troff output may still be broken, but at least we can fix nroff by
        # just switching the font changes to the non-fixed versions.
        $nroff =~ s/\Q$$self{FONTS}{100}\E(.*)\\f[PR]/$1/g;
        $nroff =~ s/\Q$$self{FONTS}{101}\E(.*)\\f([PR])/\\fI$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{110}\E(.*)\\f([PR])/\\fB$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{111}\E(.*)\\f([PR])/\\f\(BI$1\\f$2/g;

        # Now finally output the command.  Bother with .ie only if the nroff
        # and troff output aren't the same.
        if ($nroff ne $troff) {
            return ".ie n $command $nroff\n.el $command $troff\n";
        } else {
            return "$command $nroff\n";
        }
    } else {
        $text = qq("$text") . ($extra ? " $extra" : '');
        return "$command $text\n";
    }
}

# Protect leading quotes and periods against interpretation as commands.  Also
# protect anything starting with a backslash, since it could expand or hide
# something that *roff would interpret as a command.  This is overkill, but
# it's much simpler than trying to parse *roff here.
sub protect {
    my ($self, $text) = @@_;
    $text =~ s/^([.\'\\])/\\&$1/mg;
    return $text;
}

# Make vertical whitespace if NEEDSPACE is set, appropriate to the indentation
# level the situation.  This function is needed since in *roff one has to
# create vertical whitespace after paragraphs and between some things, but
# other macros create their own whitespace.  Also close out a sequence of
# repeated =items, since calling makespace means we're about to begin the item
# body.
sub makespace {
    my ($self) = @@_;
    $self->output (".PD\n") if $$self{ITEMS} > 1;
    $$self{ITEMS} = 0;
    $self->output ($$self{INDENT} > 0 ? ".Sp\n" : ".PP\n")
        if $$self{NEEDSPACE};
}

# Output any pending index entries, and optionally an index entry given as an
# argument.  Support multiple index entries in X<> separated by slashes, and
# strip special escapes from index entries.
sub outindex {
    my ($self, $section, $index) = @@_;
    my @@entries = map { split m%\s*/\s*% } @@{ $$self{INDEX} };
    return unless ($section || @@entries);

    # We're about to output all pending entries, so clear our pending queue.
    $$self{INDEX} = [];

    # Build the output.  Regular index entries are marked Xref, and headings
    # pass in their own section.  Undo some *roff formatting on headings.
    my @@output;
    if (@@entries) {
        push @@output, [ 'Xref', join (' ', @@entries) ];
    }
    if ($section) {
        $index =~ s/\\-/-/g;
        $index =~ s/\\(?:s-?\d|.\(..|.)//g;
        push @@output, [ $section, $index ];
    }

    # Print out the .IX commands.
    for (@@output) {
        my ($type, $entry) = @@$_;
        $entry =~ s/\"/\"\"/g;
        $self->output (".IX $type " . '"' . $entry . '"' . "\n");
    }
a880 5
# Output some text, without any additional changes.
sub output {
    my ($self, @@text) = @@_;
    print { $$self{output_fh} } @@text;
}
d883 1
a883 1
# Document initialization
d886 5
a890 32
# Handle the start of the document.  Here we handle empty documents, as well
# as setting up our basic macros in a preamble and building the page title.
sub start_document {
    my ($self, $attrs) = @@_;
    if ($$attrs{contentless} && !$$self{ALWAYS_EMIT_SOMETHING}) {
        DEBUG and print "Document is contentless\n";
        $$self{CONTENTLESS} = 1;
        return;
    }

    # Determine information for the preamble and then output it.
    my ($name, $section);
    if (defined $$self{name}) {
        $name = $$self{name};
        $section = $$self{section} || 1;
    } else {
        ($name, $section) = $self->devise_title;
    }
    my $date = $$self{date} || $self->devise_date;
    $self->preamble ($name, $section, $date)
        unless $self->bare_output or DEBUG > 9;

    # Initialize a few per-document variables.
    $$self{INDENT}    = 0;      # Current indentation level.
    $$self{INDENTS}   = [];     # Stack of indentations.
    $$self{INDEX}     = [];     # Index keys waiting to be printed.
    $$self{IN_NAME}   = 0;      # Whether processing the NAME section.
    $$self{ITEMS}     = 0;      # The number of consecutive =items.
    $$self{ITEMTYPES} = [];     # Stack of =item types, one per list.
    $$self{SHIFTWAIT} = 0;      # Whether there is a shift waiting.
    $$self{SHIFTS}    = [];     # Stack of .RS shifts.
    $$self{PENDING}   = [[]];   # Pending output.
d893 30
a922 48
# Handle the end of the document.  This does nothing but print out a final
# comment at the end of the document under debugging.
sub end_document {
    my ($self) = @@_;
    return if $self->bare_output;
    return if ($$self{CONTENTLESS} && !$$self{ALWAYS_EMIT_SOMETHING});
    $self->output (q(.\" [End document]) . "\n") if DEBUG;
}

# Try to figure out the name and section from the file name and return them as
# a list, returning an empty name and section 1 if we can't find any better
# information.  Uses File::Basename and File::Spec as necessary.
sub devise_title {
    my ($self) = @@_;
    my $name = $self->source_filename || '';
    my $section = $$self{section} || 1;
    $section = 3 if (!$$self{section} && $name =~ /\.pm\z/i);
    $name =~ s/\.p(od|[lm])\z//i;

    # If the section isn't 3, then the name defaults to just the basename of
    # the file.  Otherwise, assume we're dealing with a module.  We want to
    # figure out the full module name from the path to the file, but we don't
    # want to include too much of the path into the module name.  Lose
    # anything up to the first off:
    #
    #     */lib/*perl*/         standard or site_perl module
    #     */*perl*/lib/         from -Dprefix=/opt/perl
    #     */*perl*/             random module hierarchy
    #
    # which works.  Also strip off a leading site, site_perl, or vendor_perl
    # component, any OS-specific component, and any version number component,
    # and strip off an initial component of "lib" or "blib/lib" since that's
    # what ExtUtils::MakeMaker creates.  splitdir requires at least File::Spec
    # 0.8.
    if ($section !~ /^3/) {
        require File::Basename;
        $name = uc File::Basename::basename ($name);
    } else {
        require File::Spec;
        my ($volume, $dirs, $file) = File::Spec->splitpath ($name);
        my @@dirs = File::Spec->splitdir ($dirs);
        my $cut = 0;
        my $i;
        for ($i = 0; $i < @@dirs; $i++) {
            if ($dirs[$i] =~ /perl/) {
                $cut = $i + 1;
                $cut++ if ($dirs[$i + 1] && $dirs[$i + 1] eq 'lib');
                last;
d924 3
d928 1
a928 31
        if ($cut > 0) {
            splice (@@dirs, 0, $cut);
            shift @@dirs if ($dirs[0] =~ /^(site|vendor)(_perl)?$/);
            shift @@dirs if ($dirs[0] =~ /^[\d.]+$/);
            shift @@dirs if ($dirs[0] =~ /^(.*-$^O|$^O-.*|$^O)$/);
        }
        shift @@dirs if $dirs[0] eq 'lib';
        splice (@@dirs, 0, 2) if ($dirs[0] eq 'blib' && $dirs[1] eq 'lib');

        # Remove empty directories when building the module name; they
        # occur too easily on Unix by doubling slashes.
        $name = join ('::', (grep { $_ ? $_ : () } @@dirs), $file);
    }
    return ($name, $section);
}

# Determine the modification date and return that, properly formatted in ISO
# format.  If we can't get the modification date of the input, instead use the
# current time.  Pod::Simple returns a completely unuseful stringified file
# handle as the source_filename for input from a file handle, so we have to
# deal with that as well.
sub devise_date {
    my ($self) = @@_;
    my $input = $self->source_filename;
    my $time;
    if ($input) {
        $time = (stat $input)[9] || time;
    } else {
        $time = time;
    }
    return strftime ('%Y-%m-%d', localtime $time);
d931 5
a935 24
# Print out the preamble and the title.  The meaning of the arguments to .TH
# unfortunately vary by system; some systems consider the fourth argument to
# be a "source" and others use it as a version number.  Generally it's just
# presented as the left-side footer, though, so it doesn't matter too much if
# a particular system gives it another interpretation.
#
# The order of date and release used to be reversed in older versions of this
# module, but this order is correct for both Solaris and Linux.
sub preamble {
    my ($self, $name, $section, $date) = @@_;
    my $preamble = $self->preamble_template;

    # Build the index line and make sure that it will be syntactically valid.
    my $index = "$name $section";
    $index =~ s/\"/\"\"/g;

    # If name or section contain spaces, quote them (section really never
    # should, but we may as well be cautious).
    for ($name, $section) {
        if (/\s/) {
            s/\"/\"\"/g;
            $_ = '"' . $_ . '"';
        }
    }
d937 2
a938 2
    # Double quotes in date, since it will be quoted.
    $date =~ s/\"/\"\"/g;
d940 2
a941 27
    # Substitute into the preamble the configuration options.
    $preamble =~ s/\@@CFONT\@@/$$self{fixed}/;
    $preamble =~ s/\@@LQUOTE\@@/$$self{LQUOTE}/;
    $preamble =~ s/\@@RQUOTE\@@/$$self{RQUOTE}/;
    chomp $preamble;

    # Get the version information.
    my $version = $self->version_report;

    # Finally output everything.
    $self->output (<<"----END OF HEADER----");
.\\" Automatically generated by $version
.\\"
.\\" Standard preamble:
.\\" ========================================================================
$preamble
.\\" ========================================================================
.\\"
.IX Title "$index"
.TH $name $section "$date" "$$self{release}" "$$self{center}"
.\\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\\" way too many mistakes in technical documents.
.if n .ad l
.nh
----END OF HEADER----
    $self->output (".\\\" [End of preamble]\n") if DEBUG;
}
d943 16
a958 3
##############################################################################
# Text blocks
##############################################################################
d960 12
a971 6
# Handle a basic block of text.  The only tricky part of this is if this is
# the first paragraph of text after an =over, in which case we have to change
# indentations for *roff.
sub cmd_para {
    my ($self, $attrs, $text) = @@_;
    my $line = $$attrs{start_line};
d973 7
a979 10
    # Output the paragraph.  We also have to handle =over without =item.  If
    # there's an =over without =item, SHIFTWAIT will be set, and we need to
    # handle creation of the indent here.  Add the shift to SHIFTS so that it
    # will be cleaned up on =back.
    $self->makespace;
    if ($$self{SHIFTWAIT}) {
        $self->output (".RS $$self{INDENT}\n");
        push (@@{ $$self{SHIFTS} }, $$self{INDENT});
        $$self{SHIFTWAIT} = 0;
    }
d981 8
a988 8
    # Add the line number for debugging, but not in the NAME section just in
    # case the comment would confuse apropos.
    $self->output (".\\\" [At source line $line]\n")
        if defined ($line) && DEBUG && !$$self{IN_NAME};

    # Force exactly one newline at the end and strip unwanted trailing
    # whitespace at the end.
    $text =~ s/\s*$/\n/;
d990 6
a995 6
    # Output the paragraph.
    $self->output ($self->protect ($self->textmapfonts ($text)));
    $self->outindex;
    $$self{NEEDSPACE} = 1;
    return '';
}
d997 2
a998 24
# Handle a verbatim paragraph.  Put a null token at the beginning of each line
# to protect against commands and wrap in .Vb/.Ve (which we define in our
# prelude).
sub cmd_verbatim {
    my ($self, $attrs, $text) = @@_;

    # Ignore an empty verbatim paragraph.
    return unless $text =~ /\S/;

    # Force exactly one newline at the end and strip unwanted trailing
    # whitespace at the end.
    $text =~ s/\s*$/\n/;

    # Get a count of the number of lines before the first blank line, which
    # we'll pass to .Vb as its parameter.  This tells *roff to keep that many
    # lines together.  We don't want to tell *roff to keep huge blocks
    # together.
    my @@lines = split (/\n/, $text);
    my $unbroken = 0;
    for (@@lines) {
        last if /^\s*$/;
        $unbroken++;
    }
    $unbroken = 10 if ($unbroken > 12 && !$$self{MAGIC_VNOPAGEBREAK_LIMIT});
d1000 2
a1001 2
    # Prepend a null token to each line.
    $text =~ s/^/\\&/gm;
d1003 2
a1004 5
    # Output the results.
    $self->makespace;
    $self->output (".Vb $unbroken\n$text.Ve\n");
    $$self{NEEDSPACE} = 1;
    return '';
d1007 6
a1012 9
# Handle literal text (produced by =for and similar constructs).  Just output
# it with the minimum of changes.
sub cmd_data {
    my ($self, $attrs, $text) = @@_;
    $text =~ s/^\n+//;
    $text =~ s/\n{0,2}$/\n/;
    $self->output ($text);
    return '';
}
d1014 4
a1017 3
##############################################################################
# Headings
##############################################################################
d1019 15
a1033 7
# Common code for all headings.  This is called before the actual heading is
# output.  It returns the cleaned up heading text (putting the heading all on
# one line) and may do other things, like closing bad =item blocks.
sub heading_common {
    my ($self, $text, $line) = @@_;
    $text =~ s/\s+$//;
    $text =~ s/\s*\n\s*/ /g;
d1035 2
a1036 123
    # This should never happen; it means that we have a heading after =item
    # without an intervening =back.  But just in case, handle it anyway.
    if ($$self{ITEMS} > 1) {
        $$self{ITEMS} = 0;
        $self->output (".PD\n");
    }

    # Output the current source line.
    $self->output ( ".\\\" [At source line $line]\n" )
        if defined ($line) && DEBUG;
    return $text;
}

# First level heading.  We can't output .IX in the NAME section due to a bug
# in some versions of catman, so don't output a .IX for that section.  .SH
# already uses small caps, so remove \s0 and \s-1.  Maintain IN_NAME as
# appropriate.
sub cmd_head1 {
    my ($self, $attrs, $text) = @@_;
    $text =~ s/\\s-?\d//g;
    $text = $self->heading_common ($text, $$attrs{start_line});
    my $isname = ($text eq 'NAME' || $text =~ /\(NAME\)/);
    $self->output ($self->switchquotes ('.SH', $self->mapfonts ($text)));
    $self->outindex ('Header', $text) unless $isname;
    $$self{NEEDSPACE} = 0;
    $$self{IN_NAME} = $isname;
    return '';
}

# Second level heading.
sub cmd_head2 {
    my ($self, $attrs, $text) = @@_;
    $text = $self->heading_common ($text, $$attrs{start_line});
    $self->output ($self->switchquotes ('.Sh', $self->mapfonts ($text)));
    $self->outindex ('Subsection', $text);
    $$self{NEEDSPACE} = 0;
    return '';
}

# Third level heading.  *roff doesn't have this concept, so just put the
# heading in italics as a normal paragraph.
sub cmd_head3 {
    my ($self, $attrs, $text) = @@_;
    $text = $self->heading_common ($text, $$attrs{start_line});
    $self->makespace;
    $self->output ($self->textmapfonts ('\f(IS' . $text . '\f(IE') . "\n");
    $self->outindex ('Subsection', $text);
    $$self{NEEDSPACE} = 1;
    return '';
}

# Fourth level heading.  *roff doesn't have this concept, so just put the
# heading as a normal paragraph.
sub cmd_head4 {
    my ($self, $attrs, $text) = @@_;
    $text = $self->heading_common ($text, $$attrs{start_line});
    $self->makespace;
    $self->output ($self->textmapfonts ($text) . "\n");
    $self->outindex ('Subsection', $text);
    $$self{NEEDSPACE} = 1;
    return '';
}

##############################################################################
# Formatting codes
##############################################################################

# All of the formatting codes that aren't handled internally by the parser,
# other than L<> and X<>.
sub cmd_b { return '\f(BS' . $_[2] . '\f(BE' }
sub cmd_i { return '\f(IS' . $_[2] . '\f(IE' }
sub cmd_f { return '\f(IS' . $_[2] . '\f(IE' }
sub cmd_c { return $_[0]->quote_literal ($_[2]) }

# Index entries are just added to the pending entries.
sub cmd_x {
    my ($self, $attrs, $text) = @@_;
    push (@@{ $$self{INDEX} }, $text);
    return '';
}

# Links reduce to the text that we're given, wrapped in angle brackets if it's
# a URL.
sub cmd_l {
    my ($self, $attrs, $text) = @@_;
    return $$attrs{type} eq 'url' ? "<$text>" : $text;
}

##############################################################################
# List handling
##############################################################################

# Handle the beginning of an =over block.  Takes the type of the block as the
# first argument, and then the attr hash.  This is called by the handlers for
# the four different types of lists (bullet, number, text, and block).
sub over_common_start {
    my ($self, $type, $attrs) = @@_;
    my $line = $$attrs{start_line};
    my $indent = $$attrs{indent};
    DEBUG > 3 and print " Starting =over $type (line $line, indent ",
        ($indent || '?'), "\n";

    # Find the indentation level.
    unless (defined ($indent) && $indent =~ /^[-+]?\d{1,4}\s*$/) {
        $indent = $$self{indent};
    }

    # If we've gotten multiple indentations in a row, we need to emit the
    # pending indentation for the last level that we saw and haven't acted on
    # yet.  SHIFTS is the stack of indentations that we've actually emitted
    # code for.
    if (@@{ $$self{SHIFTS} } < @@{ $$self{INDENTS} }) {
        $self->output (".RS $$self{INDENT}\n");
        push (@@{ $$self{SHIFTS} }, $$self{INDENT});
    }

    # Now, do record-keeping.  INDENTS is a stack of indentations that we've
    # seen so far, and INDENT is the current level of indentation.  ITEMTYPES
    # is a stack of list types that we've seen.
    push (@@{ $$self{INDENTS} }, $$self{INDENT});
    push (@@{ $$self{ITEMTYPES} }, $type);
    $$self{INDENT} = $indent + 0;
    $$self{SHIFTWAIT} = 1;
a1038 11
# End an =over block.  Takes no options other than the class pointer.
# Normally, once we close a block and therefore remove something from INDENTS,
# INDENTS will now be longer than SHIFTS, indicating that we also need to emit
# *roff code to close the indent.  This isn't *always* true, depending on the
# circumstance.  If we're still inside an indentation, we need to emit another
# .RE and then a new .RS to unconfuse *roff.
sub over_common_end {
    my ($self) = @@_;
    DEBUG > 3 and print " Ending =over\n";
    $$self{INDENT} = pop @@{ $$self{INDENTS} };
    pop @@{ $$self{ITEMTYPES} };
d1040 3
a1042 5
    # If we emitted code for that indentation, end it.
    if (@@{ $$self{SHIFTS} } > @@{ $$self{INDENTS} }) {
        $self->output (".RE\n");
        pop @@{ $$self{SHIFTS} };
    }
d1044 7
a1050 8
    # If we're still in an indentation, *roff will have now lost track of the
    # right depth of that indentation, so fix that.
    if (@@{ $$self{INDENTS} } > 0) {
        $self->output (".RE\n");
        $self->output (".RS $$self{INDENT}\n");
    }
    $$self{NEEDSPACE} = 1;
    $$self{SHIFTWAIT} = 0;
d1053 11
a1063 36
# Dispatch the start and end calls as appropriate.
sub start_over_bullet { my $s = shift; $s->over_common_start ('bullet', @@_) }
sub start_over_number { my $s = shift; $s->over_common_start ('number', @@_) }
sub start_over_text   { my $s = shift; $s->over_common_start ('text',   @@_) }
sub start_over_block  { my $s = shift; $s->over_common_start ('block',  @@_) }
sub end_over_bullet { $_[0]->over_common_end }
sub end_over_number { $_[0]->over_common_end }
sub end_over_text   { $_[0]->over_common_end }
sub end_over_block  { $_[0]->over_common_end }

# The common handler for all item commands.  Takes the type of the item, the
# attributes, and then the text of the item.
#
# Emit an index entry for anything that's interesting, but don't emit index
# entries for things like bullets and numbers.  Newlines in an item title are
# turned into spaces since *roff can't handle them embedded.
sub item_common {
    my ($self, $type, $attrs, $text) = @@_;
    my $line = $$attrs{start_line};
    DEBUG > 3 and print "  $type item (line $line): $text\n";

    # Clean up the text.  We want to end up with two variables, one ($text)
    # which contains any body text after taking out the item portion, and
    # another ($item) which contains the actual item text.
    $text =~ s/\s+$//;
    my ($item, $index);
    if ($type eq 'bullet') {
        $item = "\\\(bu";
        $text =~ s/\n*$/\n/;
    } elsif ($type eq 'number') {
        $item = $$attrs{number} . '.';
    } else {
        $item = $text;
        $item =~ s/\s*\n\s*/ /g;
        $text = '';
        $index = $item if ($item =~ /\w/);
d1065 4
a1068 10

    # Take care of the indentation.  If shifts and indents are equal, close
    # the top shift, since we're about to create an indentation with .IP.
    # Also output .PD 0 to turn off spacing between items if this item is
    # directly following another one.  We only have to do that once for a
    # whole chain of items so do it for the second item in the change.  Note
    # that makespace is what undoes this.
    if (@@{ $$self{SHIFTS} } == @@{ $$self{INDENTS} }) {
        $self->output (".RE\n");
        pop @@{ $$self{SHIFTS} };
d1070 4
a1073 15
    $self->output (".PD 0\n") if ($$self{ITEMS} == 1);

    # Now, output the item tag itself.
    $item = $self->textmapfonts ($item);
    $self->output ($self->switchquotes ('.IP', $item, $$self{INDENT}));
    $$self{NEEDSPACE} = 0;
    $$self{ITEMS}++;
    $$self{SHIFTWAIT} = 0;

    # If body text for this item was included, go ahead and output that now.
    if ($text) {
        $text =~ s/\s*$/\n/;
        $self->makespace;
        $self->output ($self->protect ($self->textmapfonts ($text)));
        $$self{NEEDSPACE} = 1;
a1074 1
    $self->outindex ($index ? ('Item', $index) : ());
d1077 2
a1078 5
# Dispatch the item commands to the appropriate place.
sub cmd_item_bullet { my $self = shift; $self->item_common ('bullet', @@_) }
sub cmd_item_number { my $self = shift; $self->item_common ('number', @@_) }
sub cmd_item_text   { my $self = shift; $self->item_common ('text',   @@_) }
sub cmd_item_block  { my $self = shift; $self->item_common ('block',  @@_) }
d1080 13
a1092 3
##############################################################################
# Backward compatibility
##############################################################################
d1094 18
a1111 13
# Reset the underlying Pod::Simple object between calls to parse_from_file so
# that the same object can be reused to convert multiple pages.
sub parse_from_file {
    my $self = shift;
    $self->reinit;

    # Fake the old cutting option to Pod::Parser.  This fiddings with internal
    # Pod::Simple state and is quite ugly; we need a better approach.
    if (ref ($_[0]) eq 'HASH') {
        my $opts = shift @@_;
        if (defined ($$opts{-cutting}) && !$$opts{-cutting}) {
            $$self{in_pod} = 1;
            $$self{last_was_blank} = 1;
d1113 2
a1114 1
    }
d1116 8
a1123 2
    # Do the work.
    my $retval = $self->SUPER::parse_from_file (@@_);
d1125 11
a1135 195
    # Flush output, since Pod::Simple doesn't do this.  Ideally we should also
    # close the file descriptor if we had to open one, but we can't easily
    # figure this out.
    my $fh = $self->output_fh ();
    my $oldfh = select $fh;
    my $oldflush = $|;
    $| = 1;
    print $fh '';
    $| = $oldflush;
    select $oldfh;
    return $retval;
}

# Pod::Simple failed to provide this backward compatibility function, so
# implement it ourselves.  File handles are one of the inputs that
# parse_from_file supports.
sub parse_from_filehandle {
    my $self = shift;
    $self->parse_from_file (@@_);
}

##############################################################################
# Translation tables
##############################################################################

# The following table is adapted from Tom Christiansen's pod2man.  It assumes
# that the standard preamble has already been printed, since that's what
# defines all of the accent marks.  We really want to do something better than
# this when *roff actually supports other character sets itself, since these
# results are pretty poor.
#
# This only works in an ASCII world.  What to do in a non-ASCII world is very
# unclear.
@@ESCAPES{0xA0 .. 0xFF} = (
    "\\ ", undef, undef, undef,            undef, undef, undef, undef,
    undef, undef, undef, undef,            undef, "\\%", undef, undef,

    undef, undef, undef, undef,            undef, undef, undef, undef,
    undef, undef, undef, undef,            undef, undef, undef, undef,

    "A\\*`",  "A\\*'", "A\\*^", "A\\*~",   "A\\*:", "A\\*o", "\\*(AE", "C\\*,",
    "E\\*`",  "E\\*'", "E\\*^", "E\\*:",   "I\\*`", "I\\*'", "I\\*^",  "I\\*:",

    "\\*(D-", "N\\*~", "O\\*`", "O\\*'",   "O\\*^", "O\\*~", "O\\*:",  undef,
    "O\\*/",  "U\\*`", "U\\*'", "U\\*^",   "U\\*:", "Y\\*'", "\\*(Th", "\\*8",

    "a\\*`",  "a\\*'", "a\\*^", "a\\*~",   "a\\*:", "a\\*o", "\\*(ae", "c\\*,",
    "e\\*`",  "e\\*'", "e\\*^", "e\\*:",   "i\\*`", "i\\*'", "i\\*^",  "i\\*:",

    "\\*(d-", "n\\*~", "o\\*`", "o\\*'",   "o\\*^", "o\\*~", "o\\*:",  undef,
    "o\\*/" , "u\\*`", "u\\*'", "u\\*^",   "u\\*:", "y\\*'", "\\*(th", "y\\*:",
) if ASCII;

# Make sure that at least this works even outside of ASCII.
$ESCAPES{ord("\\")} = "\\e";

##############################################################################
# Premable
##############################################################################

# The following is the static preamble which starts all *roff output we
# generate.  It's completely static except for the font to use as a
# fixed-width font, which is designed by @@CFONT@@, and the left and right
# quotes to use for C<> text, designated by @@LQOUTE@@ and @@RQUOTE@@.
sub preamble_template {
    return <<'----END OF PREAMBLE----';
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft @@CFONT@@
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` @@LQUOTE@@
.    ds C' @@RQUOTE@@
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
----END OF PREAMBLE----
#`# for cperl-mode
d1155 1
a1155 1
    $parser->parse_file (\*STDIN);
d1169 4
a1172 2
As a derived class from Pod::Simple, Pod::Man supports the same methods and
interfaces.  See L<Pod::Simple> for all the details.
d1286 7
a1292 12
The standard Pod::Simple method parse_file() takes one argument naming the
POD file to read from.  By default, the output is sent to STDOUT, but this
can be changed with the output_fd() method.

The standard Pod::Simple method parse_from_file() takes up to two
arguments, the first being the input file to read POD from and the second
being the file to write the formatted output to.

You can also call parse_lines() to parse an array of lines or
parse_string_document() to parse a document already in memory.  To put the
output into a string instead of a file handle, call the output_string()
method.  See L<Pod::Simple> for the specific details.
d1305 6
d1316 20
d1351 1
a1351 3
when using POD to document something other than Perl).  Most of the work
towards fixing this has now been done, however, and all that's still needed
is a user interface.
d1356 1
a1356 2
page processors.  Currently, no index entries are emitted for anything in
NAME.
d1362 4
a1365 4
The preamble added to each output file is rather verbose, and most of it
is only necessary in the presence of non-ASCII characters.  It would
ideally be nice if all of those definitions were only output if needed,
perhaps on the fly as the characters are used.
a1377 20
Converting neutral double quotes to properly matched double quotes doesn't
work unless there are no formatting codes between the quote marks.  This
only matters for troff output.

=head1 AUTHOR

Russ Allbery <rra@@stanford.edu>, based I<very> heavily on the original
B<pod2man> by Tom Christiansen <tchrist@@mox.perl.com>.  The modifications to
work with Pod::Simple instead of Pod::Parser were originally contributed by
Sean Burke (but I've since hacked them beyond recognition and all bugs are
mine).

=head1 COPYRIGHT AND LICENSE

Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
by Russ Allbery <rra@@stanford.edu>.

This program is free software; you may redistribute it and/or modify it
under the same terms as Perl itself.

d1380 1
a1380 1
L<Pod::Simple>, L<perlpod(1)>, L<pod2man(1)>, L<nroff(1)>, L<troff(1)>,
d1397 12
@


1.1.1.8
log
@import perl 5.10.1
@
text
@d2 1
d4 1
a4 1
# Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d40 4
a43 1
$VERSION = '2.22';
d76 1
a76 1
    # Tell Pod::Simple not to handle S<> by automatically inserting &nbsp;.
a98 7
    # Send errors to stderr if requested.
    if ($$self{stderr}) {
        $self->no_errata_section (1);
        $self->complain_stderr (1);
        delete $$self{stderr};
    }

d351 10
d362 1
a362 3
    # hard, putting a bit of space between consecutive underscores, and
    # escaping backslashes.  Be careful not to mangle our character
    # translations by doing this before processing character translation.
a363 1
        $text =~ s/\\/\\e/g;
a367 6
    # Normally we do character translation, but we won't even do that in
    # <Data> blocks or if UTF-8 output is desired.
    if ($convert && !$$self{utf8} && ASCII) {
        $text =~ s/([^\x00-\x7F])/$ESCAPES{ord ($1)} || "X"/eg;
    }

d644 4
a647 4
        $nroff =~ s/\Q$$self{FONTS}{100}\E(.*?)\\f[PR]/$1/g;
        $nroff =~ s/\Q$$self{FONTS}{101}\E(.*?)\\f([PR])/\\fI$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{110}\E(.*?)\\f([PR])/\\fB$1\\f$2/g;
        $nroff =~ s/\Q$$self{FONTS}{111}\E(.*?)\\f([PR])/\\f\(BI$1\\f$2/g;
a736 13
    # If we were given the utf8 option, set an output encoding on our file
    # handle.  Wrap in an eval in case we're using a version of Perl too old
    # to understand this.
    #
    # This is evil because it changes the global state of a file handle that
    # we may not own.  However, we can't just blindly encode all output, since
    # there may be a pre-applied output encoding (such as from PERL_UNICODE)
    # and then we would double-encode.  This seems to be the least bad
    # approach.
    if ($$self{utf8}) {
        eval { binmode ($$self{output_fh}, ':encoding(UTF-8)') };
    }

d854 1
a854 1
    my $preamble = $self->preamble_template (!$$self{utf8});
d1028 1
a1028 1
    $self->output ($self->switchquotes ('.SS', $self->mapfonts ($text)));
d1276 1
a1276 1
# unclear -- hopefully we can assume UTF-8 and just leave well enough alone.
d1297 3
d1305 3
a1307 4
# generate.  Most is static except for the font to use as a fixed-width font,
# which is designed by @@CFONT@@, and the left and right quotes to use for C<>
# text, designated by @@LQOUTE@@ and @@RQUOTE@@.  However, the second part, which
# defines the accent marks, is only used if $escapes is set to true.
d1309 9
a1317 2
    my ($self, $accents) = @@_;
    my $preamble = <<'----END OF PREAMBLE----';
d1361 1
a1361 1
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
a1374 4
----END OF PREAMBLE----

    if ($accents) {
        $preamble .= <<'----END OF PREAMBLE----'
a1438 2
    }
    return $preamble;
a1451 5
=for stopwords
en em ALLCAPS teeny fixedbold fixeditalic fixedbolditalic stderr utf8
UTF-8 Allbery Sean Burke Ossanna Solaris formatters troff uppercased
Christiansen

d1484 1
a1484 1
C<STDIN> for input).
d1487 14
a1500 14
C<CW>.  If yours is called something else (like C<CR>), use the C<fixed>
option to specify it.  This generally only matters for troff output for
printing.  Similarly, you can set the fonts used for bold, italic, and
bold italic fixed-width output.

Besides the obvious pod conversions, Pod::Man also takes care of
formatting func(), func(3), and simple variable references like $foo or
@@bar so you don't have to use code escapes for them; complex expressions
like C<$fred{'stuff'}> will still need to be escaped, though.  It also
translates dashes that aren't used as hyphens into en dashes, makes long
dashes--like this--into proper em dashes, fixes "paired quotes," makes C++
look right, puts a little space between double underscores, makes ALLCAPS
a teeny bit smaller in B<troff>, and escapes stuff that *roff treats as
special so that you don't have to.
d1516 2
a1517 2
case if the input is from C<STDIN>), and the date will be formatted as
C<YYYY-MM-DD>.
d1521 2
a1522 3
The fixed-width font to use for verbatim text and code.  Defaults to
C<CW>.  Some systems may want C<CR> instead.  Only matters for B<troff>
output.
d1526 2
a1527 2
Bold version of the fixed-width font.  Defaults to C<CB>.  Only matters
for B<troff> output.
d1533 1
a1533 1
version).  Defaults to C<CI>.  Only matters for B<troff> output.
d1538 3
a1540 3
Pod::Man doesn't assume you have this, and defaults to C<CB>.  Some
systems (such as Solaris) have this font available as C<CX>.  Only matters
for B<troff> output.
d1582 2
a1583 29
By default, section 1 will be used unless the file ends in C<.pm> in which
case section 3 will be selected.

=item stderr

Send error messages about invalid POD to standard error instead of
appending a POD ERRORS section to the generated *roff output.

=item utf8

By default, Pod::Man produces the most conservative possible *roff output
to try to ensure that it will work with as many different *roff
implementations as possible.  Many *roff implementations cannot handle
non-ASCII characters, so this means all non-ASCII characters are converted
either to a *roff escape sequence that tries to create a properly accented
character (at least for troff output) or to C<X>.

If this option is set, Pod::Man will instead output UTF-8.  If your *roff
implementation can handle it, this is the best output format to use and
avoids corruption of documents containing non-ASCII characters.  However,
be warned that *roff source with literal UTF-8 characters is not supported
by many implementations and may even result in segfaults and other bad
behavior.

Be aware that, when using this option, the input encoding of your POD
source must be properly declared unless it is US-ASCII or Latin-1.  POD
input without an C<=encoding> command will be assumed to be in Latin-1,
and if it's actually in UTF-8, the output will be double-encoded.  See
L<perlpod(1)> for more information on the C<=encoding> command.
d1588 2
a1589 2
POD file to read from.  By default, the output is sent to C<STDOUT>, but
this can be changed with the output_fd() method.
d1620 8
a1627 3
Encoding handling assumes that PerlIO is available and does not work
properly if it isn't.  The C<utf8> option is therefore not supported
unless Perl is built with PerlIO support.
d1632 1
a1632 1
toward fixing this has now been done, however, and all that's still needed
a1653 6
If Pod::Man is given the C<utf8> option, the encoding of its output file
handle will be forced to UTF-8 if possible, overriding any existing
encoding.  This will be done even if the file handle is not created by
Pod::Man and was passed in from outside.  This maintains consistency
regardless of PERL_UNICODE and other settings.

d1675 2
a1676 2
Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
Russ Allbery <rra@@stanford.edu>.
@


