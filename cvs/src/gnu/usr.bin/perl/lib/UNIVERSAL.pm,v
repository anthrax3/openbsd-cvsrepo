head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.2
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.16
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.8.0.10
	OPENBSD_5_9_BASE:1.8
	OPENBSD_5_8:1.8.0.12
	OPENBSD_5_8_BASE:1.8
	PERL_5_20_2:1.1.1.8
	OPENBSD_5_7:1.8.0.4
	OPENBSD_5_7_BASE:1.8
	PERL_5_20_1:1.1.1.8
	OPENBSD_5_6:1.8.0.8
	OPENBSD_5_6_BASE:1.8
	PERL_5_18_2:1.1.1.8
	PERL:1.1.1
	OPENBSD_5_5:1.8.0.6
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	PERL_5_16_3:1.1.1.8
	OPENBSD_5_3:1.7.0.10
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.8
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.6
	OPENBSD_5_0:1.7.0.4
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.2
	OPENBSD_4_9_BASE:1.7
	PERL_5_12_2:1.1.1.7
	OPENBSD_4_8:1.6.0.4
	OPENBSD_4_8_BASE:1.6
	OPENBSD_4_7:1.6.0.2
	OPENBSD_4_7_BASE:1.6
	PERL_5_10_1:1.1.1.6
	OPENBSD_4_6:1.5.0.6
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.2
	OPENBSD_4_5_BASE:1.5
	PERL_5_10_0:1.1.1.5
	OPENBSD_4_4:1.4.0.20
	OPENBSD_4_4_BASE:1.4
	OPENBSD_4_3:1.4.0.18
	OPENBSD_4_3_BASE:1.4
	OPENBSD_4_2:1.4.0.16
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.14
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.12
	OPENBSD_4_0_BASE:1.4
	PERL_5_8_8:1.1.1.4
	OPENBSD_3_9:1.4.0.10
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.8
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.6
	OPENBSD_3_7_BASE:1.4
	PERL_5_8_6:1.1.1.4
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4
	PERL_5_8_5:1.1.1.4
	PERL_5_8_3:1.1.1.4
	OPENBSD_3_5:1.4.0.2
	OPENBSD_3_5_BASE:1.4
	PERL_5_8_2:1.1.1.4
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.2.0.12
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.10
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.4
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.1.0.8
	OPENBSD_2_6_BASE:1.1
	PERL_500503:1.1.1.1
	CPAN:1.1.1
	OPENBSD_2_5:1.1.0.6
	OPENBSD_2_5_BASE:1.1
	OPENBSD_2_4:1.1.0.4
	OPENBSD_2_4_BASE:1.1
	OPENBSD_2_3:1.1.0.2
	OPENBSD_2_3_BASE:1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.9
date	2017.02.05.00.32.15;	author afresh1;	state Exp;
branches;
next	1.8;
commitid	cxJ08BvJA9Pt2PTM;

1.8
date	2013.03.25.20.40.55;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2010.09.24.15.06.59;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2009.10.12.18.24.38;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2008.09.29.17.36.09;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2003.12.03.03.02.36;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.22.25.25;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.06.17.06.06;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	97.11.30.07.56.47;	author millert;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.29.22.39.48;	author millert;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.04.06.16.09.36;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.14.58;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2003.12.03.02.44.00;	author millert;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2008.09.29.17.18.30;	author millert;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	2009.10.12.18.10.49;	author millert;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	2010.09.24.14.48.35;	author millert;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	2013.03.25.20.08.53;	author sthen;	state Exp;
branches;
next	;


desc
@perl 5.004_04
@


1.9
log
@Fix merge issues, remove excess files - match perl-5.24.1 dist
@
text
@package UNIVERSAL;

our $VERSION = '1.13';

# UNIVERSAL should not contain any extra subs/methods beyond those
# that it exists to define. The existence of import() below is a historical
# accident that can't be fixed without breaking code.

# Make sure that even though the import method is called, it doesn't do
# anything unless called on UNIVERSAL.
sub import {
    return unless $_[0] eq __PACKAGE__;
    return unless @@_ > 1;
    require Carp;
    Carp::croak("UNIVERSAL does not export anything");
}

1;
__END__

=head1 NAME

UNIVERSAL - base class for ALL classes (blessed references)

=head1 SYNOPSIS

    $is_io    = $fd->isa("IO::Handle");
    $is_io    = Class->isa("IO::Handle");

    $does_log = $obj->DOES("Logger");
    $does_log = Class->DOES("Logger");

    $sub      = $obj->can("print");
    $sub      = Class->can("print");

    $sub      = eval { $ref->can("fandango") };
    $ver      = $obj->VERSION;

    # but never do this!
    $is_io    = UNIVERSAL::isa($fd, "IO::Handle");
    $sub      = UNIVERSAL::can($obj, "print");

=head1 DESCRIPTION

C<UNIVERSAL> is the base class from which all blessed references inherit.
See L<perlobj>.

C<UNIVERSAL> provides the following methods:

=over 4

=item C<< $obj->isa( TYPE ) >>

=item C<< CLASS->isa( TYPE ) >>

=item C<< eval { VAL->isa( TYPE ) } >>

Where

=over 4

=item C<TYPE>

is a package name

=item C<$obj>

is a blessed reference or a package name

=item C<CLASS>

is a package name

=item C<VAL>

is any of the above or an unblessed reference

=back

When used as an instance or class method (C<< $obj->isa( TYPE ) >>),
C<isa> returns I<true> if $obj is blessed into package C<TYPE> or
inherits from package C<TYPE>.

When used as a class method (C<< CLASS->isa( TYPE ) >>, sometimes
referred to as a static method), C<isa> returns I<true> if C<CLASS>
inherits from (or is itself) the name of the package C<TYPE> or
inherits from package C<TYPE>.

If you're not sure what you have (the C<VAL> case), wrap the method call in an
C<eval> block to catch the exception if C<VAL> is undefined.

If you want to be sure that you're calling C<isa> as a method, not a class,
check the invocand with C<blessed> from L<Scalar::Util> first:

  use Scalar::Util 'blessed';

  if ( blessed( $obj ) && $obj->isa("Some::Class") ) {
      ...
  }

=item C<< $obj->DOES( ROLE ) >>

=item C<< CLASS->DOES( ROLE ) >>

C<DOES> checks if the object or class performs the role C<ROLE>.  A role is a
named group of specific behavior (often methods of particular names and
signatures), similar to a class, but not necessarily a complete class by
itself.  For example, logging or serialization may be roles.

C<DOES> and C<isa> are similar, in that if either is true, you know that the
object or class on which you call the method can perform specific behavior.
However, C<DOES> is different from C<isa> in that it does not care I<how> the
invocand performs the operations, merely that it does.  (C<isa> of course
mandates an inheritance relationship.  Other relationships include aggregation,
delegation, and mocking.)

By default, classes in Perl only perform the C<UNIVERSAL> role, as well as the
role of all classes in their inheritance.  In other words, by default C<DOES>
responds identically to C<isa>.

There is a relationship between roles and classes, as each class implies the
existence of a role of the same name.  There is also a relationship between
inheritance and roles, in that a subclass that inherits from an ancestor class
implicitly performs any roles its parent performs.  Thus you can use C<DOES> in
place of C<isa> safely, as it will return true in all places where C<isa> will
return true (provided that any overridden C<DOES> I<and> C<isa> methods behave
appropriately).

=item C<< $obj->can( METHOD ) >>

=item C<< CLASS->can( METHOD ) >>

=item C<< eval { VAL->can( METHOD ) } >>

C<can> checks if the object or class has a method called C<METHOD>. If it does,
then it returns a reference to the sub.  If it does not, then it returns
I<undef>.  This includes methods inherited or imported by C<$obj>, C<CLASS>, or
C<VAL>.

C<can> cannot know whether an object will be able to provide a method through
AUTOLOAD (unless the object's class has overridden C<can> appropriately), so a
return value of I<undef> does not necessarily mean the object will not be able
to handle the method call. To get around this some module authors use a forward
declaration (see L<perlsub>) for methods they will handle via AUTOLOAD. For
such 'dummy' subs, C<can> will still return a code reference, which, when
called, will fall through to the AUTOLOAD. If no suitable AUTOLOAD is provided,
calling the coderef will cause an error.

You may call C<can> as a class (static) method or an object method.

Again, the same rule about having a valid invocand applies -- use an C<eval>
block or C<blessed> if you need to be extra paranoid.

=item C<VERSION ( [ REQUIRE ] )>

C<VERSION> will return the value of the variable C<$VERSION> in the
package the object is blessed into. If C<REQUIRE> is given then
it will do a comparison and die if the package version is not
greater than or equal to C<REQUIRE>, or if either C<$VERSION> or C<REQUIRE>
is not a "lax" version number (as defined by the L<version> module).

The return from C<VERSION> will actually be the stringified version object
using the package C<$VERSION> scalar, which is guaranteed to be equivalent
but may not be precisely the contents of the C<$VERSION> scalar.  If you want
the actual contents of C<$VERSION>, use C<$CLASS::VERSION> instead.

C<VERSION> can be called as either a class (static) method or an object
method.

=back

=head1 WARNINGS

B<NOTE:> C<can> directly uses Perl's internal code for method lookup, and
C<isa> uses a very similar method and cache-ing strategy. This may cause
strange effects if the Perl code dynamically changes @@ISA in any package.

You may add other methods to the UNIVERSAL class via Perl or XS code.
You do not need to C<use UNIVERSAL> to make these methods
available to your program (and you should not do so).

=head1 EXPORTS

None.

Previous versions of this documentation suggested using C<isa> as
a function to determine the type of a reference:

  $yes = UNIVERSAL::isa($h, "HASH");
  $yes = UNIVERSAL::isa("Foo", "Bar");

The problem is that this code would I<never> call an overridden C<isa> method in
any class.  Instead, use C<reftype> from L<Scalar::Util> for the first case:

  use Scalar::Util 'reftype';

  $yes = reftype( $h ) eq "HASH";

and the method form of C<isa> for the second:

  $yes = Foo->isa("Bar");

=cut
@


1.8
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@d3 1
a3 1
our $VERSION = '1.11';
d6 2
a7 7
# that it exists to define. The use of Exporter below is a historical
# accident that can't be fixed without breaking code.  Note that we
# *don't* set @@ISA here, as we don't want all classes/objects inheriting from
# Exporter.  It's bad enough that all classes have a import() method
# whenever UNIVERSAL.pm is loaded.
require Exporter;
@@EXPORT_OK = qw(isa can VERSION);
d14 2
a15 6
    require warnings;
    warnings::warnif(
      'deprecated',
      'UNIVERSAL->import is deprecated and will be removed in a future perl',
    );
    goto &Exporter::import;
d184 1
a184 1
None by default.
d186 1
a186 5
You may request the import of three functions (C<isa>, C<can>, and C<VERSION>),
B<but this feature is deprecated and will be removed>.  Please don't do this in
new code.

For example, previous versions of this documentation suggested using C<isa> as
d189 2
a190 4
  use UNIVERSAL 'isa';

  $yes = isa $h, "HASH";
  $yes = isa "Foo", "Bar";
d192 1
a192 1
The problem is that this code will I<never> call an overridden C<isa> method in
@


1.7
log
@merge in perl 5.12.2 plus local changes
@
text
@d3 1
a3 1
our $VERSION = '1.06';
d102 1
a102 1
check the invocant with C<blessed> from L<Scalar::Util> first:
d106 1
a106 1
  if ( blessed( $obj ) && $obj->isa("Some::Class") {
d122 1
a122 1
invocant performs the operations, merely that it does.  (C<isa> of course
d160 1
a160 1
Again, the same rule about having a valid invocant applies -- use an C<eval>
d168 7
a174 3
greater than or equal to C<REQUIRE>.  Both C<$VERSION> or C<REQUIRE>
must be "lax" version numbers (as defined by the L<version> module)
or C<VERSION> will die with an error.
@


1.6
log
@Merge in perl 5.10.1
@
text
@d3 1
a3 1
our $VERSION = '1.05';
d18 6
d150 1
a150 1
AUTOLOAD (unless the object's class has overriden C<can> appropriately), so a
d168 3
a170 1
greater than or equal to C<REQUIRE>.
d192 2
a193 1
however it is usually harmful to do so.  Please don't do this in new code.
@


1.5
log
@fix conflicts and merge in local changes to perl 5.10.0
@
text
@d3 1
a3 1
our $VERSION = '1.04';
d71 1
a71 1
is a blessed reference or a string containing a package name
d120 3
a122 2
By default, classes in Perl only perform the C<UNIVERSAL> role.  To mark that
your own classes perform other roles, override C<DOES> appropriately.
d168 10
@


1.4
log
@Resolve conflicts for perl 5.8.2, remove old files, and add OpenBSD-specific scaffolding
@
text
@d3 1
a3 1
our $VERSION = '1.01';
d8 1
a8 1
# *don't* set @@ISA here, don't want all classes/objects inheriting from
a11 1
*import = \&Exporter::import;
d14 7
d30 5
a34 2
    $is_io = $fd->isa("IO::Handle");
    $is_io = Class->isa("IO::Handle");
d36 2
a37 2
    $sub = $obj->can("print");
    $sub = Class->can("print");
d39 6
a44 4
    use UNIVERSAL qw( isa can VERSION );
    $yes = isa $ref, "HASH" ;
    $sub = can $ref, "fandango" ;
    $ver = VERSION $obj ;
d48 2
a49 2
C<UNIVERSAL> is the base class which all bless references will inherit from,
see L<perlobj>.
d51 1
a51 1
C<UNIVERSAL> provides the following methods and functions:
d57 1
a57 1
=item C<< CLASS->isa( TYPE ) >> 
d59 1
a59 1
=item C<isa( VAL, TYPE )>
d87 1
a87 1
When used as a class method (C<< CLASS->isa( TYPE ) >>: sometimes
d92 2
a93 5
When used as a function, like

   use UNIVERSAL qw( isa ) ;
   $yes = isa $h, "HASH";
   $yes = isa "Foo", "Bar";
d95 2
a96 1
or
d98 1
a98 2
   require UNIVERSAL ;
   $yes = UNIVERSAL::isa $a, "ARRAY";
d100 30
a129 3
C<isa> returns I<true> in the same cases as above and also if C<VAL> is an
unblessed reference to a perl variable of type C<TYPE>, such as "HASH",
"ARRAY", or "Regexp".
d135 1
a135 1
=item C<can( VAL, METHOD )>
d137 3
a139 3
C<can> checks if the object or class has a method called C<METHOD>. If it does
then a reference to the sub is returned. If it does not then I<undef> is
returned.  This includes methods inherited or imported by C<$obj>, C<CLASS>, or
d142 13
a154 16
C<can> cannot know whether an object will be able to provide a method
through AUTOLOAD, so a return value of I<undef> does not necessarily mean
the object will not be able to handle the method call. To get around
this some module authors use a forward declaration (see L<perlsub>)
for methods they will handle via AUTOLOAD. For such 'dummy' subs, C<can>
will still return a code reference, which, when called, will fall through
to the AUTOLOAD. If no suitable AUTOLOAD is provided, calling the coderef
will cause an error.

C<can> can be called as a class (static) method, an object method, or a
function.

When used as a function, if C<VAL> is a blessed reference or package name which
has a method called C<METHOD>, C<can> returns a reference to the subroutine.
If C<VAL> is not a blessed reference, or if it does not have a method
C<METHOD>, I<undef> is returned.
d163 2
a164 3
C<VERSION> can be called as either a class (static) method, an object
method or a function.

d172 21
a192 5
You may request the import of all three functions (C<isa>, C<can>, and
C<VERSION>), however it isn't usually necessary to do so.  Perl magically
makes these functions act as methods on all objects.  The one exception is
C<isa>, which is useful as a function when operating on non-blessed
references.
@


1.3
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d3 1
a3 1
our $VERSION = '1.00';
d44 1
a44 1
=item $obj->isa( TYPE ), CLASS->isa( TYPE ), isa( VAL, TYPE )
d46 34
a79 12
    C<TYPE> is a package name
    $obj is a blessed reference or a string containing a package name
    C<CLASS> is a package name
    C<VAL> is any of the above or an unblessed reference

When used as an instance or class method (C<$obj->isa( TYPE )>), C<isa>
returns I<true> if $obj is blessed into package C<TYPE> or inherits from
package C<TYPE>.

When used as a class method (C<CLASS->isa( TYPE )>; sometimes referred to as a
static method), C<isa> returns I<true> if C<CLASS> inherits from (or is itself)
the name of the package C<TYPE> or inherits from package C<TYPE>.
d92 1
a92 1
, C<isa> returns I<true> in the same cases as above and also if C<VAL> is an
d96 5
a100 1
=item $obj->can( METHOD ), CLASS->can( METHOD ), can( VAL, METHOD )
d124 1
a124 1
=item VERSION ( [ REQUIRE ] )
d131 2
a132 2
C<VERSION> can be called as either a class (static) method, an object method or
or a function.
d137 1
a137 2
These subroutines should I<not> be imported via S<C<use UNIVERSAL qw(...)>>.
If you want simple local access to them you can do
d139 1
a139 1
  *isa = \&UNIVERSAL::isa;
d141 5
a145 1
to import isa into your package.
@


1.2
log
@perl-5.6.0 + local changes
@
text
@d3 2
d7 4
a10 1
# accident that should be fixed sometime.
d13 1
a13 1
@@EXPORT_OK = qw(isa can);
d24 5
a28 2
    $io = $fd->isa("IO::Handle");
    $sub = $obj->can('print');
d30 4
a33 1
    $yes = UNIVERSAL::isa($ref, "HASH");
d38 1
a38 1
see L<perlobj>
d40 1
a40 1
C<UNIVERSAL> provides the following methods
d44 1
a44 1
=item isa ( TYPE )
d46 4
a49 2
C<isa> returns I<true> if C<REF> is blessed into package C<TYPE>
or inherits from package C<TYPE>.
d51 3
a53 1
C<isa> can be called as either a static or object method call.
d55 42
a96 7
=item can ( METHOD )

C<can> checks if the object has a method called C<METHOD>. If it does
then a reference to the sub is returned. If it does not then I<undef>
is returned.

C<can> can be called as either a static or object method call.
d105 2
a106 31
C<VERSION> can be called as either a static or object method call.

=back

The C<isa> and C<can> methods can also be called as subroutines

=over 4

=item UNIVERSAL::isa ( VAL, TYPE )

C<isa> returns I<true> if one of the following statements is true.

=over 8

=item *

C<VAL> is a reference blessed into either package C<TYPE> or a package
which inherits from package C<TYPE>.

=item *

C<VAL> is a reference to a C<TYPE> of Perl variable (e.g. 'HASH').

=item *

C<VAL> is the name of a package that inherits from (or is itself)
package C<TYPE>.

=back

=item UNIVERSAL::can ( VAL, METHOD )
a107 4
If C<VAL> is a blessed reference which has a method called C<METHOD>,
C<can> returns a reference to the subroutine.   If C<VAL> is not
a blessed reference, or if it does not have a method C<METHOD>,
I<undef> is returned.
@


1.1
log
@perl 5.004_04
@
text
@d65 1
a65 2
C<isa> returns I<true> if the first argument is a reference and either
of the following statements is true.
d69 1
a69 1
=item
d71 2
a72 2
C<VAL> is a blessed reference and is blessed into package C<TYPE>
or inherits from package C<TYPE>
d74 1
a74 1
=item
d76 6
a81 1
C<VAL> is a reference to a C<TYPE> of perl variable (er 'HASH')
@


1.1.1.1
log
@perl5.005_03
@
text
@@


1.1.1.2
log
@virgin perl 5.6.0
@
text
@d65 2
a66 1
C<isa> returns I<true> if one of the following statements is true.
d70 1
a70 1
=item *
d72 2
a73 2
C<VAL> is a reference blessed into either package C<TYPE> or a package
which inherits from package C<TYPE>.
d75 1
a75 1
=item *
d77 1
a77 6
C<VAL> is a reference to a C<TYPE> of Perl variable (e.g. 'HASH').

=item *

C<VAL> is the name of a package that inherits from (or is itself)
package C<TYPE>.
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@a2 2
our $VERSION = '1.00';

d5 1
a5 4
# accident that can't be fixed without breaking code.  Note that we
# *don't* set @@ISA here, don't want all classes/objects inheriting from
# Exporter.  It's bad enough that all classes have a import() method
# whenever UNIVERSAL.pm is loaded.
d8 1
a8 1
@@EXPORT_OK = qw(isa can VERSION);
d19 2
a20 5
    $is_io = $fd->isa("IO::Handle");
    $is_io = Class->isa("IO::Handle");

    $sub = $obj->can("print");
    $sub = Class->can("print");
d22 1
a22 4
    use UNIVERSAL qw( isa can VERSION );
    $yes = isa $ref, "HASH" ;
    $sub = can $ref, "fandango" ;
    $ver = VERSION $obj ;
d27 1
a27 1
see L<perlobj>.
d29 1
a29 1
C<UNIVERSAL> provides the following methods and functions:
d33 4
a36 1
=item $obj->isa( TYPE ), CLASS->isa( TYPE ), isa( VAL, TYPE )
d38 1
a38 4
    C<TYPE> is a package name
    $obj is a blessed reference or a string containing a package name
    C<CLASS> is a package name
    C<VAL> is any of the above or an unblessed reference
d40 5
a44 3
When used as an instance or class method (C<$obj->isa( TYPE )>), C<isa>
returns I<true> if $obj is blessed into package C<TYPE> or inherits from
package C<TYPE>.
d46 1
a46 42
When used as a class method (C<CLASS->isa( TYPE )>; sometimes referred to as a
static method), C<isa> returns I<true> if C<CLASS> inherits from (or is itself)
the name of the package C<TYPE> or inherits from package C<TYPE>.

When used as a function, like

   use UNIVERSAL qw( isa ) ;
   $yes = isa $h, "HASH";
   $yes = isa "Foo", "Bar";

or

   require UNIVERSAL ;
   $yes = UNIVERSAL::isa $a, "ARRAY";

, C<isa> returns I<true> in the same cases as above and also if C<VAL> is an
unblessed reference to a perl variable of type C<TYPE>, such as "HASH",
"ARRAY", or "Regexp".

=item $obj->can( METHOD ), CLASS->can( METHOD ), can( VAL, METHOD )

C<can> checks if the object or class has a method called C<METHOD>. If it does
then a reference to the sub is returned. If it does not then I<undef> is
returned.  This includes methods inherited or imported by C<$obj>, C<CLASS>, or
C<VAL>.

C<can> cannot know whether an object will be able to provide a method
through AUTOLOAD, so a return value of I<undef> does not necessarily mean
the object will not be able to handle the method call. To get around
this some module authors use a forward declaration (see L<perlsub>)
for methods they will handle via AUTOLOAD. For such 'dummy' subs, C<can>
will still return a code reference, which, when called, will fall through
to the AUTOLOAD. If no suitable AUTOLOAD is provided, calling the coderef
will cause an error.

C<can> can be called as a class (static) method, an object method, or a
function.

When used as a function, if C<VAL> is a blessed reference or package name which
has a method called C<METHOD>, C<can> returns a reference to the subroutine.
If C<VAL> is not a blessed reference, or if it does not have a method
C<METHOD>, I<undef> is returned.
d55 31
a85 2
C<VERSION> can be called as either a class (static) method, an object method or
or a function.
d87 4
@


1.1.1.4
log
@perl 5.8.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.01';
d44 1
a44 1
=item C<< $obj->isa( TYPE ) >>
d46 12
a57 34
=item C<< CLASS->isa( TYPE ) >> 

=item C<isa( VAL, TYPE )>

Where

=over 4

=item C<TYPE>

is a package name

=item C<$obj>

is a blessed reference or a string containing a package name

=item C<CLASS>

is a package name

=item C<VAL>

is any of the above or an unblessed reference

=back

When used as an instance or class method (C<< $obj->isa( TYPE ) >>),
C<isa> returns I<true> if $obj is blessed into package C<TYPE> or
inherits from package C<TYPE>.

When used as a class method (C<< CLASS->isa( TYPE ) >>: sometimes
referred to as a static method), C<isa> returns I<true> if C<CLASS>
inherits from (or is itself) the name of the package C<TYPE> or
inherits from package C<TYPE>.
d70 1
a70 1
C<isa> returns I<true> in the same cases as above and also if C<VAL> is an
d74 1
a74 5
=item C<< $obj->can( METHOD ) >>

=item C<< CLASS->can( METHOD ) >>

=item C<can( VAL, METHOD )>
d98 1
a98 1
=item C<VERSION ( [ REQUIRE ] )>
d105 2
a106 2
C<VERSION> can be called as either a class (static) method, an object
method or a function.
d111 2
a112 1
=head1 EXPORTS
d114 1
a114 1
None by default.
d116 1
a116 5
You may request the import of all three functions (C<isa>, C<can>, and
C<VERSION>), however it isn't usually necessary to do so.  Perl magically
makes these functions act as methods on all objects.  The one exception is
C<isa>, which is useful as a function when operating on non-blessed
references.
@


1.1.1.5
log
@import perl 5.10.0 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.04';
d8 1
a8 1
# *don't* set @@ISA here, as we don't want all classes/objects inheriting from
d12 1
a14 7
# Make sure that even though the import method is called, it doesn't do
# anything unless called on UNIVERSAL.
sub import {
    return unless $_[0] eq __PACKAGE__;
    goto &Exporter::import;
}

d24 2
a25 5
    $is_io    = $fd->isa("IO::Handle");
    $is_io    = Class->isa("IO::Handle");

    $does_log = $obj->DOES("Logger");
    $does_log = Class->DOES("Logger");
d27 2
a28 2
    $sub      = $obj->can("print");
    $sub      = Class->can("print");
d30 4
a33 6
    $sub      = eval { $ref->can("fandango") };
    $ver      = $obj->VERSION;

    # but never do this!
    $is_io    = UNIVERSAL::isa($fd, "IO::Handle");
    $sub      = UNIVERSAL::can($obj, "print");
d37 2
a38 2
C<UNIVERSAL> is the base class from which all blessed references inherit.
See L<perlobj>.
d40 1
a40 1
C<UNIVERSAL> provides the following methods:
d46 1
a46 1
=item C<< CLASS->isa( TYPE ) >>
d48 1
a48 1
=item C<< eval { VAL->isa( TYPE ) } >>
d76 1
a76 1
When used as a class method (C<< CLASS->isa( TYPE ) >>, sometimes
d81 5
a85 2
If you're not sure what you have (the C<VAL> case), wrap the method call in an
C<eval> block to catch the exception if C<VAL> is undefined.
d87 1
a87 2
If you want to be sure that you're calling C<isa> as a method, not a class,
check the invocant with C<blessed> from L<Scalar::Util> first:
d89 2
a90 1
  use Scalar::Util 'blessed';
d92 3
a94 30
  if ( blessed( $obj ) && $obj->isa("Some::Class") {
      ...
  }

=item C<< $obj->DOES( ROLE ) >>

=item C<< CLASS->DOES( ROLE ) >>

C<DOES> checks if the object or class performs the role C<ROLE>.  A role is a
named group of specific behavior (often methods of particular names and
signatures), similar to a class, but not necessarily a complete class by
itself.  For example, logging or serialization may be roles.

C<DOES> and C<isa> are similar, in that if either is true, you know that the
object or class on which you call the method can perform specific behavior.
However, C<DOES> is different from C<isa> in that it does not care I<how> the
invocant performs the operations, merely that it does.  (C<isa> of course
mandates an inheritance relationship.  Other relationships include aggregation,
delegation, and mocking.)

By default, classes in Perl only perform the C<UNIVERSAL> role.  To mark that
your own classes perform other roles, override C<DOES> appropriately.

There is a relationship between roles and classes, as each class implies the
existence of a role of the same name.  There is also a relationship between
inheritance and roles, in that a subclass that inherits from an ancestor class
implicitly performs any roles its parent performs.  Thus you can use C<DOES> in
place of C<isa> safely, as it will return true in all places where C<isa> will
return true (provided that any overridden C<DOES> I<and> C<isa> methods behave
appropriately).
d100 1
a100 1
=item C<< eval { VAL->can( METHOD ) } >>
d102 3
a104 3
C<can> checks if the object or class has a method called C<METHOD>. If it does,
then it returns a reference to the sub.  If it does not, then it returns
I<undef>.  This includes methods inherited or imported by C<$obj>, C<CLASS>, or
d107 16
a122 13
C<can> cannot know whether an object will be able to provide a method through
AUTOLOAD (unless the object's class has overriden C<can> appropriately), so a
return value of I<undef> does not necessarily mean the object will not be able
to handle the method call. To get around this some module authors use a forward
declaration (see L<perlsub>) for methods they will handle via AUTOLOAD. For
such 'dummy' subs, C<can> will still return a code reference, which, when
called, will fall through to the AUTOLOAD. If no suitable AUTOLOAD is provided,
calling the coderef will cause an error.

You may call C<can> as a class (static) method or an object method.

Again, the same rule about having a valid invocant applies -- use an C<eval>
block or C<blessed> if you need to be extra paranoid.
d131 3
a133 2
C<VERSION> can be called as either a class (static) method or an object
method.
d141 5
a145 21
You may request the import of three functions (C<isa>, C<can>, and C<VERSION>),
however it is usually harmful to do so.  Please don't do this in new code.

For example, previous versions of this documentation suggested using C<isa> as
a function to determine the type of a reference:

  use UNIVERSAL 'isa';

  $yes = isa $h, "HASH";
  $yes = isa "Foo", "Bar";

The problem is that this code will I<never> call an overridden C<isa> method in
any class.  Instead, use C<reftype> from L<Scalar::Util> for the first case:

  use Scalar::Util 'reftype';

  $yes = reftype( $h ) eq "HASH";

and the method form of C<isa> for the second:

  $yes = Foo->isa("Bar");
@


1.1.1.6
log
@import perl 5.10.1
@
text
@d3 1
a3 1
our $VERSION = '1.05';
d71 1
a71 1
is a blessed reference or a package name
d120 2
a121 3
By default, classes in Perl only perform the C<UNIVERSAL> role, as well as the
role of all classes in their inheritance.  In other words, by default C<DOES>
responds identically to C<isa>.
a166 10

=head1 WARNINGS

B<NOTE:> C<can> directly uses Perl's internal code for method lookup, and
C<isa> uses a very similar method and cache-ing strategy. This may cause
strange effects if the Perl code dynamically changes @@ISA in any package.

You may add other methods to the UNIVERSAL class via Perl or XS code.
You do not need to C<use UNIVERSAL> to make these methods
available to your program (and you should not do so).
@


1.1.1.7
log
@Perl 5.12.2 from CPAN
@
text
@d3 1
a3 1
our $VERSION = '1.06';
a17 6
    return unless @@_ > 1;
    require warnings;
    warnings::warnif(
      'deprecated',
      'UNIVERSAL->import is deprecated and will be removed in a future perl',
    );
d144 1
a144 1
AUTOLOAD (unless the object's class has overridden C<can> appropriately), so a
d162 1
a162 3
greater than or equal to C<REQUIRE>.  Both C<$VERSION> or C<REQUIRE>
must be "lax" version numbers (as defined by the L<version> module)
or C<VERSION> will die with an error.
d184 1
a184 2
B<but this feature is deprecated and will be removed>.  Please don't do this in
new code.
@


1.1.1.8
log
@import perl 5.16.3 from CPAN - worked on by Andrew Fresh and myself
@
text
@d3 1
a3 1
our $VERSION = '1.11';
d102 1
a102 1
check the invocand with C<blessed> from L<Scalar::Util> first:
d106 1
a106 1
  if ( blessed( $obj ) && $obj->isa("Some::Class") ) {
d122 1
a122 1
invocand performs the operations, merely that it does.  (C<isa> of course
d160 1
a160 1
Again, the same rule about having a valid invocand applies -- use an C<eval>
d168 3
a170 7
greater than or equal to C<REQUIRE>, or if either C<$VERSION> or C<REQUIRE>
is not a "lax" version number (as defined by the L<version> module).

The return from C<VERSION> will actually be the stringified version object
using the package C<$VERSION> scalar, which is guaranteed to be equivalent
but may not be precisely the contents of the C<$VERSION> scalar.  If you want
the actual contents of C<$VERSION>, use C<$CLASS::VERSION> instead.
@


