head	1.5;
access;
symbols
	OPENBSD_5_3:1.4.0.10
	OPENBSD_5_3_BASE:1.4
	OPENBSD_5_2:1.4.0.8
	OPENBSD_5_2_BASE:1.4
	OPENBSD_5_1_BASE:1.4
	OPENBSD_5_1:1.4.0.6
	OPENBSD_5_0:1.4.0.4
	OPENBSD_5_0_BASE:1.4
	OPENBSD_4_9:1.4.0.2
	OPENBSD_4_9_BASE:1.4
	PERL_5_12_2:1.1.1.4
	OPENBSD_4_8:1.3.0.32
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.28
	OPENBSD_4_7_BASE:1.3
	PERL_5_10_1:1.1.1.3
	OPENBSD_4_6:1.3.0.30
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.26
	OPENBSD_4_5_BASE:1.3
	PERL_5_10_0:1.1.1.3
	OPENBSD_4_4:1.3.0.24
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.3.0.22
	OPENBSD_4_3_BASE:1.3
	OPENBSD_4_2:1.3.0.20
	OPENBSD_4_2_BASE:1.3
	OPENBSD_4_1:1.3.0.18
	OPENBSD_4_1_BASE:1.3
	OPENBSD_4_0:1.3.0.16
	OPENBSD_4_0_BASE:1.3
	PERL_5_8_8:1.1.1.3
	OPENBSD_3_9:1.3.0.14
	OPENBSD_3_9_BASE:1.3
	OPENBSD_3_8:1.3.0.12
	OPENBSD_3_8_BASE:1.3
	OPENBSD_3_7:1.3.0.10
	OPENBSD_3_7_BASE:1.3
	PERL_5_8_6:1.1.1.3
	OPENBSD_3_6:1.3.0.8
	OPENBSD_3_6_BASE:1.3
	PERL_5_8_5:1.1.1.3
	PERL_5_8_3:1.1.1.3
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	PERL_5_8_2:1.1.1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	OPENBSD_3_3:1.3.0.2
	OPENBSD_3_3_BASE:1.3
	PERL_5_8_0:1.1.1.3
	OPENBSD_3_2:1.2.0.20
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.18
	OPENBSD_3_1_BASE:1.2
	OPENBSD_3_0:1.2.0.16
	OPENBSD_3_0_BASE:1.2
	PERL_5_6_1:1.1.1.2
	OPENBSD_2_9:1.2.0.14
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_8:1.2.0.12
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.10
	OPENBSD_2_7_BASE:1.2
	PERL_5_6_0:1.1.1.2
	OPENBSD_2_6:1.2.0.8
	OPENBSD_2_6_BASE:1.2
	PERL_500503:1.1.1.2
	CPAN:1.1.1
	OPENBSD_2_5:1.2.0.6
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.1.1.0.6
	OPENBSD_2_2_BASE:1.1.1.1
	OPENBSD_2_1:1.1.1.1.0.4
	OPENBSD_2_1_BASE:1.1.1.1
	OPENBSD_2_0:1.1.1.1.0.2
	OPENBSD_2_0_BASE:1.1.1.1
	perl5003:1.1.1.1
	lwall:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2013.03.25.20.40.56;	author sthen;	state dead;
branches;
next	1.4;

1.4
date	2010.09.24.15.07.02;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.27.22.25.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	97.11.30.07.57.55;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	96.08.19.10.12.48;	author downsj;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.08.19.10.12.48;	author downsj;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.29.22.40.16;	author millert;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.10.27.22.15.01;	author millert;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2010.09.24.14.48.41;	author millert;	state Exp;
branches;
next	;


desc
@@


1.5
log
@merge/resolve conflicts
(some more to do after this one)
@
text
@package Search::Dict;
require 5.000;
require Exporter;

use strict;

our $VERSION = '1.02';
our @@ISA = qw(Exporter);
our @@EXPORT = qw(look);

=head1 NAME

Search::Dict, look - search for key in dictionary file

=head1 SYNOPSIS

    use Search::Dict;
    look *FILEHANDLE, $key, $dict, $fold;

    use Search::Dict;
    look *FILEHANDLE, $params;

=head1 DESCRIPTION

Sets file position in FILEHANDLE to be first line greater than or equal
(stringwise) to I<$key>.  Returns the new file position, or -1 if an error
occurs.

The flags specify dictionary order and case folding:

If I<$dict> is true, search by dictionary order (ignore anything but word
characters and whitespace).  The default is honour all characters.

If I<$fold> is true, ignore case.  The default is to honour case.

If there are only three arguments and the third argument is a hash
reference, the keys of that hash can have values C<dict>, C<fold>, and
C<comp> or C<xfrm> (see below), and their corresponding values will be
used as the parameters.

If a comparison subroutine (comp) is defined, it must return less than zero,
zero, or greater than zero, if the first comparand is less than,
equal, or greater than the second comparand.

If a transformation subroutine (xfrm) is defined, its value is used to
transform the lines read from the filehandle before their comparison.

=cut

sub look {
    my($fh,$key,$dict,$fold) = @@_;
    my ($comp, $xfrm);
    if (@@_ == 3 && ref $dict eq 'HASH') {
	my $params = $dict;
	$dict = 0;
	$dict = $params->{dict} if exists $params->{dict};
	$fold = $params->{fold} if exists $params->{fold};
	$comp = $params->{comp} if exists $params->{comp};
	$xfrm = $params->{xfrm} if exists $params->{xfrm};
    }
    $comp = sub { $_[0] cmp $_[1] } unless defined $comp;
    local($_);
    my(@@stat) = stat($fh)
	or return -1;
    my($size, $blksize) = @@stat[7,11];
    $blksize ||= 8192;
    $key =~ s/[^\w\s]//g if $dict;
    $key = lc $key       if $fold;
    # find the right block
    my($min, $max) = (0, int($size / $blksize));
    my $mid;
    while ($max - $min > 1) {
	$mid = int(($max + $min) / 2);
	seek($fh, $mid * $blksize, 0)
	    or return -1;
	<$fh> if $mid;			# probably a partial line
	$_ = <$fh>;
	$_ = $xfrm->($_) if defined $xfrm;
	chomp;
	s/[^\w\s]//g if $dict;
	$_ = lc $_   if $fold;
	if (defined($_) && $comp->($_, $key) < 0) {
	    $min = $mid;
	}
	else {
	    $max = $mid;
	}
    }
    # find the right line
    $min *= $blksize;
    seek($fh,$min,0)
	or return -1;
    <$fh> if $min;
    for (;;) {
	$min = tell($fh);
	defined($_ = <$fh>)
	    or last;
	$_ = $xfrm->($_) if defined $xfrm;
	chomp;
	s/[^\w\s]//g if $dict;
	$_ = lc $_   if $fold;
	last if $comp->($_, $key) >= 0;
    }
    seek($fh,$min,0);
    $min;
}

1;
@


1.4
log
@merge in perl 5.12.2 plus local changes
@
text
@@


1.3
log
@Resolve conflicts, remove old files, merge local changes
@
text
@d38 1
a38 1
C<comp> or C<xfrm> (see below), and their correponding values will be
@


1.2
log
@perl 5.004_04
@
text
@d5 5
a9 2
@@ISA = qw(Exporter);
@@EXPORT = qw(look);
d20 3
d32 3
a34 1
characters and whitespace).
d36 11
a46 1
If I<$fold> is true, ignore case.
d51 11
a61 1
    local(*FH,$key,$dict,$fold) = @@_;
d63 1
a63 1
    my(@@stat) = stat(FH)
d68 4
a71 2
    $key = lc $key if $fold;
    my($min, $max, $mid) = (0, int($size / $blksize));
d74 1
a74 1
	seek(FH, $mid * $blksize, 0)
d76 4
a79 3
	<FH> if $mid;			# probably a partial line
	$_ = <FH>;
	chop;
d81 2
a82 2
	$_ = lc $_ if $fold;
	if (defined($_) && $_ lt $key) {
d89 1
d91 1
a91 1
    seek(FH,$min,0)
d93 1
a93 1
    <FH> if $min;
d95 2
a96 2
	$min = tell(FH);
	defined($_ = <FH>)
d98 2
a99 1
	chop;
d101 2
a102 2
	$_ = lc $_ if $fold;
	last if $_ ge $key;
d104 1
a104 1
    seek(FH,$min,0);
@


1.1
log
@Initial revision
@
text
@d40 1
a40 1
    $key =~ tr/A-Z/a-z/ if $fold;
d50 1
a50 1
	tr/A-Z/a-z/ if $fold;
d64 1
a64 1
	$_ = <FH>
d68 1
a68 1
	y/A-Z/a-z/ if $fold;
@


1.1.1.1
log
@Import of Perl 5.003 into the tree.  Makefile.bsd-wrapper and
config.sh.OpenBSD are the only local changes.
@
text
@@


1.1.1.2
log
@perl5.005_03
@
text
@d40 1
a40 1
    $key = lc $key if $fold;
d50 1
a50 1
	$_ = lc $_ if $fold;
d64 1
a64 1
	defined($_ = <FH>)
d68 1
a68 1
	$_ = lc $_ if $fold;
@


1.1.1.3
log
@stock perl 5.8.0 from CPAN
@
text
@d5 2
a6 5
use strict;

our $VERSION = '1.02';
our @@ISA = qw(Exporter);
our @@EXPORT = qw(look);
a16 3
    use Search::Dict;
    look *FILEHANDLE, $params;

d26 1
a26 3
characters and whitespace).  The default is honour all characters.

If I<$fold> is true, ignore case.  The default is to honour case.
d28 1
a28 11
If there are only three arguments and the third argument is a hash
reference, the keys of that hash can have values C<dict>, C<fold>, and
C<comp> or C<xfrm> (see below), and their correponding values will be
used as the parameters.

If a comparison subroutine (comp) is defined, it must return less than zero,
zero, or greater than zero, if the first comparand is less than,
equal, or greater than the second comparand.

If a transformation subroutine (xfrm) is defined, its value is used to
transform the lines read from the filehandle before their comparison.
d33 1
a33 11
    my($fh,$key,$dict,$fold) = @@_;
    my ($comp, $xfrm);
    if (@@_ == 3 && ref $dict eq 'HASH') {
	my $params = $dict;
	$dict = 0;
	$dict = $params->{dict} if exists $params->{dict};
	$fold = $params->{fold} if exists $params->{fold};
	$comp = $params->{comp} if exists $params->{comp};
	$xfrm = $params->{xfrm} if exists $params->{xfrm};
    }
    $comp = sub { $_[0] cmp $_[1] } unless defined $comp;
d35 1
a35 1
    my(@@stat) = stat($fh)
d40 2
a41 4
    $key = lc $key       if $fold;
    # find the right block
    my($min, $max) = (0, int($size / $blksize));
    my $mid;
d44 1
a44 1
	seek($fh, $mid * $blksize, 0)
d46 3
a48 4
	<$fh> if $mid;			# probably a partial line
	$_ = <$fh>;
	$_ = $xfrm->($_) if defined $xfrm;
	chomp;
d50 2
a51 2
	$_ = lc $_   if $fold;
	if (defined($_) && $comp->($_, $key) < 0) {
a57 1
    # find the right line
d59 1
a59 1
    seek($fh,$min,0)
d61 1
a61 1
    <$fh> if $min;
d63 2
a64 2
	$min = tell($fh);
	defined($_ = <$fh>)
d66 1
a66 2
	$_ = $xfrm->($_) if defined $xfrm;
	chomp;
d68 2
a69 2
	$_ = lc $_   if $fold;
	last if $comp->($_, $key) >= 0;
d71 1
a71 1
    seek($fh,$min,0);
@


1.1.1.4
log
@Perl 5.12.2 from CPAN
@
text
@d38 1
a38 1
C<comp> or C<xfrm> (see below), and their corresponding values will be
@


